
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-vda.h</h3>
            <pre><code>1  #ifndef AVCODEC_VDA_H
2  #define AVCODEC_VDA_H
3  #include "libavcodec/avcodec.h"
4  #include <stdint.h>
5  #undef __GNUC_STDC_INLINE__
6  #define Picture QuickdrawPicture
7  #include <VideoDecodeAcceleration/VDADecoder.h>
8  #undef Picture
9  #include "libavcodec/version.h"
10  enum {
11      kVDADecodeInfo_Asynchronous = 1UL << 0,
12      kVDADecodeInfo_FrameDropped = 1UL << 1
13  };
14  struct vda_context {
15      VDADecoder          decoder;
16      CVPixelBufferRef    cv_buffer;
<span onclick='openModal()' class='match'>17      int                 use_sync_decoding;
18      int                 width;
19      int                 height;
20      int                 format;
21      OSType              cv_pix_fmt_type;
22      uint8_t             *priv_bitstream;
</span>23      int                 priv_bitstream_size;
24      int                 priv_allocated_size;
25      int                 use_ref_buffer;
26  };
27  int ff_vda_create_decoder(struct vda_context *vda_ctx,
28                            uint8_t *extradata,
29                            int extradata_size);
30  int ff_vda_destroy_decoder(struct vda_context *vda_ctx);
31  typedef struct AVVDAContext {
32      VDADecoder decoder;
33      VDADecoderOutputCallback output_callback;
34      OSType cv_pix_fmt_type;
35  } AVVDAContext;
36  AVVDAContext *av_vda_alloc_context(void);
37  int av_vda_default_init(AVCodecContext *avctx);
38  int av_vda_default_init2(AVCodecContext *avctx, AVVDAContext *vdactx);
39  void av_vda_default_free(AVCodecContext *avctx);
40  #endif &bsol;* AVCODEC_VDA_H */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-server.h</h3>
            <pre><code>1  #ifndef __REDIS_H
2  #define __REDIS_H
3  #ifdef _WIN32
4  #include "Win32_Interop/Win32_Portability.h"
5  #include "Win32_Interop/win32fixes.h"
6  #include "Win32_Interop/Win32_FDAPI.h"
7  #include "Win32_Interop/win32_wsiocp2.h"
8  #include "Win32_Interop/Win32_Signal_Process.h"
9  #include "Win32_Interop/Win32_RedisLog.h"
10  #include "Win32_Interop/Win32_Time.h"
11  #endif
12  #include "fmacros.h"
13  #include "config.h"
14  #include "solarisfixes.h"
15  #include "rio.h"
16  #include <stdio.h>
17  #include <stdlib.h>
18  #include <string.h>
19  #include <time.h>
20  #include <limits.h>
21  POSIX_ONLY(#include <unistd.h>)
22  #include <errno.h>
23  #ifndef _WIN32
24  #include <inttypes.h>
25  #include <pthread.h>
26  #include <syslog.h>
27  #include <netinet/in.h>
28  #else
29  #include "Win32_Interop\Win32_PThread.h"
30  #endif
31  #include <lua.h>
32  #include <signal.h>
33  typedef PORT_LONGLONG mstime_t; &bsol;* millisecond time type. */
34  typedef PORT_LONGLONG ustime_t; &bsol;* microsecond time type. */
35  #include "ae.h"      &bsol;* Event driven programming library */
36  #include "sds.h"     &bsol;* Dynamic safe strings */
37  #include "dict.h"    &bsol;* Hash tables */
38  #include "adlist.h"  &bsol;* Linked lists */
39  #include "zmalloc.h" &bsol;* total memory usage aware version of malloc/free */
40  #include "anet.h"    &bsol;* Networking the easy way */
41  #include "ziplist.h" &bsol;* Compact list data structure */
42  #include "intset.h"  &bsol;* Compact integer set structure */
43  #include "version.h" &bsol;* Version macro */
44  #include "util.h"    &bsol;* Misc functions useful in many places */
45  #include "latency.h" &bsol;* Latency monitor API */
46  #include "sparkline.h" &bsol;* ASCII graphs API */
47  #include "quicklist.h"  &bsol;* Lists are encoded as linked lists of
48                             N-elements flat arrays */
49  #include "rax.h"     &bsol;* Radix tree */
50  #include "zipmap.h"
51  #include "sha1.h"
52  #include "endianconv.h"
53  #include "crc64.h"
54  #define C_OK                    0
55  #define C_ERR                   -1
56  #define CONFIG_DEFAULT_DYNAMIC_HZ 1             &bsol;* Adapt hz to # of clients.*/
57  #define CONFIG_DEFAULT_HZ        10             &bsol;* Time interrupt calls/sec. */
58  #define CONFIG_MIN_HZ            1
59  #define CONFIG_MAX_HZ            500
60  #define MAX_CLIENTS_PER_CLOCK_TICK 200          &bsol;* HZ is adapted based on that. */
61  #define CONFIG_DEFAULT_SERVER_PORT        6379  &bsol;* TCP port. */
62  #define CONFIG_DEFAULT_TCP_BACKLOG       511    &bsol;* TCP listen backlog. */
63  #define CONFIG_DEFAULT_CLIENT_TIMEOUT       0   &bsol;* Default client timeout: infinite */
64  #define CONFIG_DEFAULT_DBNUM     16
65  #define CONFIG_MAX_LINE    1024
66  #define CRON_DBS_PER_CALL 16
67  #define NET_MAX_WRITES_PER_EVENT (1024*64)
68  #define PROTO_SHARED_SELECT_CMDS 10
69  #define OBJ_SHARED_INTEGERS 10000
70  #define OBJ_SHARED_BULKHDR_LEN 32
71  #define LOG_MAX_LEN    1024 &bsol;* Default maximum length of syslog messages.*/
72  #define AOF_REWRITE_PERC  100
73  #define AOF_REWRITE_MIN_SIZE (64*1024*1024)
74  #define AOF_REWRITE_ITEMS_PER_CMD 64
75  #define AOF_READ_DIFF_INTERVAL_BYTES (1024*10)
76  #define CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN 10000
77  #define CONFIG_DEFAULT_SLOWLOG_MAX_LEN 128
78  #define CONFIG_DEFAULT_MAX_CLIENTS 10000
79  #define CONFIG_AUTHPASS_MAX_LEN 512
80  #define CONFIG_DEFAULT_SLAVE_PRIORITY 100
81  #define CONFIG_DEFAULT_REPL_TIMEOUT 60
82  #define CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD 10
83  #define CONFIG_RUN_ID_SIZE 40
84  #define RDB_EOF_MARK_SIZE 40
85  #define CONFIG_DEFAULT_REPL_BACKLOG_SIZE (1024*1024)    &bsol;* 1mb */
86  #define CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT (60*60)  &bsol;* 1 hour */
87  #define CONFIG_REPL_BACKLOG_MIN_SIZE (1024*16)          &bsol;* 16k */
88  #define CONFIG_BGSAVE_RETRY_DELAY 5 &bsol;* Wait a few secs before trying again. */
89  #define CONFIG_DEFAULT_PID_FILE "/var/run/redis.pid"
90  #define CONFIG_DEFAULT_SYSLOG_IDENT "redis"
91  #define CONFIG_DEFAULT_CLUSTER_CONFIG_FILE "nodes.conf"
92  #define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP NULL         &bsol;* Auto detect. */
93  #define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT 0          &bsol;* Use server.port */
94  #define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT 0      &bsol;* Use +10000 offset. */
95  #define CONFIG_DEFAULT_DAEMONIZE 0
96  #define CONFIG_DEFAULT_UNIX_SOCKET_PERM 0
97  #define CONFIG_DEFAULT_TCP_KEEPALIVE 300
98  #define CONFIG_DEFAULT_PROTECTED_MODE 1
99  #define CONFIG_DEFAULT_LOGFILE ""
100  #define CONFIG_DEFAULT_SYSLOG_ENABLED 0
101  #define CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR 1
102  #define CONFIG_DEFAULT_RDB_COMPRESSION 1
103  #define CONFIG_DEFAULT_RDB_CHECKSUM 1
104  #define CONFIG_DEFAULT_RDB_FILENAME "dump.rdb"
105  #define CONFIG_DEFAULT_REPL_DISKLESS_SYNC 0
106  #define CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY 5
107  #define CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA 1
108  #define CONFIG_DEFAULT_SLAVE_READ_ONLY 1
109  #define CONFIG_DEFAULT_SLAVE_IGNORE_MAXMEMORY 1
110  #define CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP NULL
111  #define CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT 0
112  #define CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY 0
113  #define CONFIG_DEFAULT_MAXMEMORY 0
114  #define CONFIG_DEFAULT_MAXMEMORY_SAMPLES 5
115  #define CONFIG_DEFAULT_LFU_LOG_FACTOR 10
116  #define CONFIG_DEFAULT_LFU_DECAY_TIME 1
117  #define CONFIG_DEFAULT_AOF_FILENAME "appendonly.aof"
118  #define CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE 0
119  #define CONFIG_DEFAULT_AOF_LOAD_TRUNCATED 1
120  #define CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE 1
121  #define CONFIG_DEFAULT_ACTIVE_REHASHING 1
122  #define CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC 1
123  #define CONFIG_DEFAULT_RDB_SAVE_INCREMENTAL_FSYNC 1
124  #define CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE 0
125  #define CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG 10
126  #define NET_IP_STR_LEN 46 &bsol;* INET6_ADDRSTRLEN is 46, but we need to be sure */
127  #define NET_PEER_ID_LEN (NET_IP_STR_LEN+32) &bsol;* Must be enough for ip:port */
128  #define CONFIG_BINDADDR_MAX 16
129  #define CONFIG_MIN_RESERVED_FDS 32
130  #define CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD 0
131  #define CONFIG_DEFAULT_SLAVE_LAZY_FLUSH 0
132  #define CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION 0
133  #define CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE 0
134  #define CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL 0
135  #define CONFIG_DEFAULT_ALWAYS_SHOW_LOGO 0
136  #define CONFIG_DEFAULT_ACTIVE_DEFRAG 0
137  #define CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER 10 &bsol;* don't defrag when fragmentation is below 10% */
138  #define CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER 100 &bsol;* maximum defrag force at 100% fragmentation */
139  #define CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES (100<<20) &bsol;* don't defrag if frag overhead is below 100mb */
140  #define CONFIG_DEFAULT_DEFRAG_CYCLE_MIN 5 &bsol;* 5% CPU min (at lower threshold) */
141  #define CONFIG_DEFAULT_DEFRAG_CYCLE_MAX 75 &bsol;* 75% CPU max (at upper threshold) */
142  #define CONFIG_DEFAULT_DEFRAG_MAX_SCAN_FIELDS 1000 &bsol;* keys with more than 1000 fields will be processed separately */
143  #define CONFIG_DEFAULT_PROTO_MAX_BULK_LEN (512ll*1024*1024) &bsol;* Bulk request max size */
144  #define ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 20 &bsol;* Loopkups per loop. */
145  #define ACTIVE_EXPIRE_CYCLE_FAST_DURATION 1000 &bsol;* Microseconds */
146  #define ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 25 &bsol;* CPU max % for keys collection */
147  #define ACTIVE_EXPIRE_CYCLE_SLOW 0
148  #define ACTIVE_EXPIRE_CYCLE_FAST 1
149  #define STATS_METRIC_SAMPLES 16     &bsol;* Number of samples per metric. */
150  #define STATS_METRIC_COMMAND 0      &bsol;* Number of commands executed. */
151  #define STATS_METRIC_NET_INPUT 1    &bsol;* Bytes read to network .*/
152  #define STATS_METRIC_NET_OUTPUT 2   &bsol;* Bytes written to network. */
153  #define STATS_METRIC_COUNT 3
154  #define PROTO_MAX_QUERYBUF_LEN  (1024*1024*1024) &bsol;* 1GB max query buffer. */
155  #define PROTO_IOBUF_LEN         (1024*16)  &bsol;* Generic I/O buffer size */
156  #define PROTO_REPLY_CHUNK_BYTES (16*1024) &bsol;* 16k output buffer */
157  #define PROTO_INLINE_MAX_SIZE   (1024*64) &bsol;* Max size of inline reads */
158  #define PROTO_MBULK_BIG_ARG     (1024*32)
159  #define LONG_STR_SIZE      21          &bsol;* Bytes needed for long -> str + '\0' */
160  #define REDIS_AUTOSYNC_BYTES (1024*1024*32) &bsol;* fdatasync every 32MB */
161  #define LIMIT_PENDING_QUERYBUF (4*1024*1024) &bsol;* 4mb */
162  #define CONFIG_FDSET_INCR (CONFIG_MIN_RESERVED_FDS+96)
163  #define HASHTABLE_MIN_FILL        10      &bsol;* Minimal hash table fill 10% */
164  #define CMD_WRITE (1<<0)            &bsol;* "w" flag */
165  #define CMD_READONLY (1<<1)         &bsol;* "r" flag */
166  #define CMD_DENYOOM (1<<2)          &bsol;* "m" flag */
167  #define CMD_MODULE (1<<3)           &bsol;* Command exported by module. */
168  #define CMD_ADMIN (1<<4)            &bsol;* "a" flag */
169  #define CMD_PUBSUB (1<<5)           &bsol;* "p" flag */
170  #define CMD_NOSCRIPT (1<<6)         &bsol;* "s" flag */
171  #define CMD_RANDOM (1<<7)           &bsol;* "R" flag */
172  #define CMD_SORT_FOR_SCRIPT (1<<8)  &bsol;* "S" flag */
173  #define CMD_LOADING (1<<9)          &bsol;* "l" flag */
174  #define CMD_STALE (1<<10)           &bsol;* "t" flag */
175  #define CMD_SKIP_MONITOR (1<<11)    &bsol;* "M" flag */
176  #define CMD_ASKING (1<<12)          &bsol;* "k" flag */
177  #define CMD_FAST (1<<13)            &bsol;* "F" flag */
178  #define CMD_MODULE_GETKEYS (1<<14)  &bsol;* Use the modules getkeys interface. */
179  #define CMD_MODULE_NO_CLUSTER (1<<15) &bsol;* Deny on Redis Cluster. */
180  #define AOF_OFF 0             &bsol;* AOF is off */
181  #define AOF_ON 1              &bsol;* AOF is on */
182  #define AOF_WAIT_REWRITE 2    &bsol;* AOF waits rewrite to start appending */
183  #define CLIENT_SLAVE (1<<0)   &bsol;* This client is a slave server */
184  #define CLIENT_MASTER (1<<1)  &bsol;* This client is a master server */
185  #define CLIENT_MONITOR (1<<2) &bsol;* This client is a slave monitor, see MONITOR */
186  #define CLIENT_MULTI (1<<3)   &bsol;* This client is in a MULTI context */
187  #define CLIENT_BLOCKED (1<<4) &bsol;* The client is waiting in a blocking operation */
188  #define CLIENT_DIRTY_CAS (1<<5) &bsol;* Watched keys modified. EXEC will fail. */
189  #define CLIENT_CLOSE_AFTER_REPLY (1<<6) &bsol;* Close after writing entire reply. */
190  #define CLIENT_UNBLOCKED (1<<7) &bsol;* This client was unblocked and is stored in
191                                    server.unblocked_clients */
192  #define CLIENT_LUA (1<<8) &bsol;* This is a non connected client used by Lua */
193  #define CLIENT_ASKING (1<<9)     &bsol;* Client issued the ASKING command */
194  #define CLIENT_CLOSE_ASAP (1<<10)&bsol;* Close this client ASAP */
195  #define CLIENT_UNIX_SOCKET (1<<11) &bsol;* Client connected via Unix domain socket */
196  #define CLIENT_DIRTY_EXEC (1<<12)  &bsol;* EXEC will fail for errors while queueing */
197  #define CLIENT_MASTER_FORCE_REPLY (1<<13)  &bsol;* Queue replies even if is master */
198  #define CLIENT_FORCE_AOF (1<<14)   &bsol;* Force AOF propagation of current cmd. */
199  #define CLIENT_FORCE_REPL (1<<15)  &bsol;* Force replication of current cmd. */
200  #define CLIENT_PRE_PSYNC (1<<16)   &bsol;* Instance don't understand PSYNC. */
201  #define CLIENT_READONLY (1<<17)    &bsol;* Cluster client is in read-only state. */
202  #define CLIENT_PUBSUB (1<<18)      &bsol;* Client is in Pub/Sub mode. */
203  #define CLIENT_PREVENT_AOF_PROP (1<<19)  &bsol;* Don't propagate to AOF. */
204  #define CLIENT_PREVENT_REPL_PROP (1<<20)  &bsol;* Don't propagate to slaves. */
205  #define CLIENT_PREVENT_PROP (CLIENT_PREVENT_AOF_PROP|CLIENT_PREVENT_REPL_PROP)
206  #define CLIENT_PENDING_WRITE (1<<21) &bsol;* Client has output to send but a write
207                                          handler is yet not installed. */
208  #define CLIENT_REPLY_OFF (1<<22)   &bsol;* Don't send replies to client. */
209  #define CLIENT_REPLY_SKIP_NEXT (1<<23)  &bsol;* Set CLIENT_REPLY_SKIP for next cmd */
210  #define CLIENT_REPLY_SKIP (1<<24)  &bsol;* Don't send just this reply. */
211  #define CLIENT_LUA_DEBUG (1<<25)  &bsol;* Run EVAL in debug mode. */
212  #define CLIENT_LUA_DEBUG_SYNC (1<<26)  &bsol;* EVAL debugging without fork() */
213  #define CLIENT_MODULE (1<<27) &bsol;* Non connected client used by some module. */
214  #define CLIENT_PROTECTED (1<<28) &bsol;* Client should not be freed for now. */
215  #define BLOCKED_NONE 0    &bsol;* Not blocked, no CLIENT_BLOCKED flag set. */
216  #define BLOCKED_LIST 1    &bsol;* BLPOP & co. */
217  #define BLOCKED_WAIT 2    &bsol;* WAIT for synchronous replication. */
218  #define BLOCKED_MODULE 3  &bsol;* Blocked by a loadable module. */
219  #define BLOCKED_STREAM 4  &bsol;* XREAD. */
220  #define BLOCKED_ZSET 5    &bsol;* BZPOP et al. */
221  #define BLOCKED_NUM 6     &bsol;* Number of blocked states. */
222  #define PROTO_REQ_INLINE 1
223  #define PROTO_REQ_MULTIBULK 2
224  #define CLIENT_TYPE_NORMAL 0 &bsol;* Normal req-reply clients + MONITORs */
225  #define CLIENT_TYPE_SLAVE 1  &bsol;* Slaves. */
226  #define CLIENT_TYPE_PUBSUB 2 &bsol;* Clients subscribed to PubSub channels. */
227  #define CLIENT_TYPE_MASTER 3 &bsol;* Master. */
228  #define CLIENT_TYPE_OBUF_COUNT 3 &bsol;* Number of clients to expose to output
229                                      buffer configuration. Just the first
230                                      three: normal, slave, pubsub. */
231  #define REPL_STATE_NONE 0 &bsol;* No active replication */
232  #define REPL_STATE_CONNECT 1 &bsol;* Must connect to master */
233  #define REPL_STATE_CONNECTING 2 &bsol;* Connecting to master */
234  #define REPL_STATE_RECEIVE_PONG 3 &bsol;* Wait for PING reply */
235  #define REPL_STATE_SEND_AUTH 4 &bsol;* Send AUTH to master */
236  #define REPL_STATE_RECEIVE_AUTH 5 &bsol;* Wait for AUTH reply */
237  #define REPL_STATE_SEND_PORT 6 &bsol;* Send REPLCONF listening-port */
238  #define REPL_STATE_RECEIVE_PORT 7 &bsol;* Wait for REPLCONF reply */
239  #define REPL_STATE_SEND_IP 8 &bsol;* Send REPLCONF ip-address */
240  #define REPL_STATE_RECEIVE_IP 9 &bsol;* Wait for REPLCONF reply */
241  #define REPL_STATE_SEND_CAPA 10 &bsol;* Send REPLCONF capa */
242  #define REPL_STATE_RECEIVE_CAPA 11 &bsol;* Wait for REPLCONF reply */
243  #define REPL_STATE_SEND_PSYNC 12 &bsol;* Send PSYNC */
244  #define REPL_STATE_RECEIVE_PSYNC 13 &bsol;* Wait for PSYNC reply */
245  #define REPL_STATE_TRANSFER 14 &bsol;* Receiving .rdb from master */
246  #define REPL_STATE_CONNECTED 15 &bsol;* Connected to master */
247  #define SLAVE_STATE_WAIT_BGSAVE_START 6 &bsol;* We need to produce a new RDB file. */
248  #define SLAVE_STATE_WAIT_BGSAVE_END 7 &bsol;* Waiting RDB file creation to finish. */
249  #define SLAVE_STATE_SEND_BULK 8 &bsol;* Sending RDB file to slave. */
250  #define SLAVE_STATE_ONLINE 9 &bsol;* RDB file transmitted, sending just updates. */
251  #define SLAVE_CAPA_NONE 0
252  #define SLAVE_CAPA_EOF (1<<0)    &bsol;* Can parse the RDB EOF streaming format. */
253  #define SLAVE_CAPA_PSYNC2 (1<<1) &bsol;* Supports PSYNC2 protocol. */
254  #define CONFIG_REPL_SYNCIO_TIMEOUT 5
255  #define LIST_HEAD 0
256  #define LIST_TAIL 1
257  #define ZSET_MIN 0
258  #define ZSET_MAX 1
259  #define SORT_OP_GET 0
260  #define LL_DEBUG 0
261  #define LL_VERBOSE 1
262  #define LL_NOTICE 2
263  #define LL_WARNING 3
264  #define LL_RAW (1<<10) &bsol;* Modifier to log without timestamp */
265  #define CONFIG_DEFAULT_VERBOSITY LL_NOTICE
266  #define SUPERVISED_NONE 0
267  #define SUPERVISED_AUTODETECT 1
268  #define SUPERVISED_SYSTEMD 2
269  #define SUPERVISED_UPSTART 3
270  #define UNUSED(V) ((void) V)
271  #define ZSKIPLIST_MAXLEVEL 64 &bsol;* Should be enough for 2^64 elements */
272  #define ZSKIPLIST_P 0.25      &bsol;* Skiplist P = 1/4 */
273  #define AOF_FSYNC_NO 0
274  #define AOF_FSYNC_ALWAYS 1
275  #define AOF_FSYNC_EVERYSEC 2
276  #define CONFIG_DEFAULT_AOF_FSYNC AOF_FSYNC_EVERYSEC
277  #define OBJ_HASH_MAX_ZIPLIST_ENTRIES 512
278  #define OBJ_HASH_MAX_ZIPLIST_VALUE 64
279  #define OBJ_SET_MAX_INTSET_ENTRIES 512
280  #define OBJ_ZSET_MAX_ZIPLIST_ENTRIES 128
281  #define OBJ_ZSET_MAX_ZIPLIST_VALUE 64
282  #define OBJ_STREAM_NODE_MAX_BYTES 4096
283  #define OBJ_STREAM_NODE_MAX_ENTRIES 100
284  #define OBJ_LIST_MAX_ZIPLIST_SIZE -2
285  #define OBJ_LIST_COMPRESS_DEPTH 0
286  #define CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES 3000
287  #define SET_OP_UNION 0
288  #define SET_OP_DIFF 1
289  #define SET_OP_INTER 2
290  #define MAXMEMORY_FLAG_LRU (1<<0)
291  #define MAXMEMORY_FLAG_LFU (1<<1)
292  #define MAXMEMORY_FLAG_ALLKEYS (1<<2)
293  #define MAXMEMORY_FLAG_NO_SHARED_INTEGERS \
294      (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU)
295  #define MAXMEMORY_VOLATILE_LRU ((0<<8)|MAXMEMORY_FLAG_LRU)
296  #define MAXMEMORY_VOLATILE_LFU ((1<<8)|MAXMEMORY_FLAG_LFU)
297  #define MAXMEMORY_VOLATILE_TTL (2<<8)
298  #define MAXMEMORY_VOLATILE_RANDOM (3<<8)
299  #define MAXMEMORY_ALLKEYS_LRU ((4<<8)|MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_ALLKEYS)
300  #define MAXMEMORY_ALLKEYS_LFU ((5<<8)|MAXMEMORY_FLAG_LFU|MAXMEMORY_FLAG_ALLKEYS)
301  #define MAXMEMORY_ALLKEYS_RANDOM ((6<<8)|MAXMEMORY_FLAG_ALLKEYS)
302  #define MAXMEMORY_NO_EVICTION (7<<8)
303  #define CONFIG_DEFAULT_MAXMEMORY_POLICY MAXMEMORY_NO_EVICTION
304  #define LUA_SCRIPT_TIME_LIMIT 5000 &bsol;* milliseconds */
305  #define UNIT_SECONDS 0
306  #define UNIT_MILLISECONDS 1
307  #define SHUTDOWN_NOFLAGS 0      &bsol;* No flags. */
308  #define SHUTDOWN_SAVE 1         &bsol;* Force SAVE on SHUTDOWN even if no save
309                                     points are configured. */
310  #define SHUTDOWN_NOSAVE 2       &bsol;* Don't SAVE on SHUTDOWN. */
311  #define CMD_CALL_NONE 0
312  #define CMD_CALL_SLOWLOG (1<<0)
313  #define CMD_CALL_STATS (1<<1)
314  #define CMD_CALL_PROPAGATE_AOF (1<<2)
315  #define CMD_CALL_PROPAGATE_REPL (1<<3)
316  #define CMD_CALL_PROPAGATE (CMD_CALL_PROPAGATE_AOF|CMD_CALL_PROPAGATE_REPL)
317  #define CMD_CALL_FULL (CMD_CALL_SLOWLOG | CMD_CALL_STATS | CMD_CALL_PROPAGATE)
318  #define PROPAGATE_NONE 0
319  #define PROPAGATE_AOF 1
320  #define PROPAGATE_REPL 2
321  #define RDB_CHILD_TYPE_NONE 0
322  #define RDB_CHILD_TYPE_DISK 1     &bsol;* RDB is written to disk. */
323  #define RDB_CHILD_TYPE_SOCKET 2   &bsol;* RDB is written to slave socket. */
324  #define NOTIFY_KEYSPACE (1<<0)    &bsol;* K */
325  #define NOTIFY_KEYEVENT (1<<1)    &bsol;* E */
326  #define NOTIFY_GENERIC (1<<2)     &bsol;* g */
327  #define NOTIFY_STRING (1<<3)      &bsol;* $ */
328  #define NOTIFY_LIST (1<<4)        &bsol;* l */
329  #define NOTIFY_SET (1<<5)         &bsol;* s */
330  #define NOTIFY_HASH (1<<6)        &bsol;* h */
331  #define NOTIFY_ZSET (1<<7)        &bsol;* z */
332  #define NOTIFY_EXPIRED (1<<8)     &bsol;* x */
333  #define NOTIFY_EVICTED (1<<9)     &bsol;* e */
334  #define NOTIFY_STREAM (1<<10)     &bsol;* t */
335  #define NOTIFY_ALL (NOTIFY_GENERIC | NOTIFY_STRING | NOTIFY_LIST | NOTIFY_SET | NOTIFY_HASH | NOTIFY_ZSET | NOTIFY_EXPIRED | NOTIFY_EVICTED | NOTIFY_STREAM) &bsol;* A flag */
336  #define NET_FIRST_BIND_ADDR (server.bindaddr_count ? server.bindaddr[0] : NULL)
337  #define run_with_period(_ms_) if ((_ms_ <= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))
338  #define serverAssertWithInfo(_c,_o,_e) ((_e)?(void)0 : (_serverAssertWithInfo(_c,_o,#_e,__FILE__,__LINE__),_exit(1)))
339  #define serverAssert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))
340  #define serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)
341  #define OBJ_STRING 0    &bsol;* String object. */
342  #define OBJ_LIST 1      &bsol;* List object. */
343  #define OBJ_SET 2       &bsol;* Set object. */
344  #define OBJ_ZSET 3      &bsol;* Sorted set object. */
345  #define OBJ_HASH 4      &bsol;* Hash object. */
346  #define OBJ_MODULE 5    &bsol;* Module object. */
347  #define OBJ_STREAM 6    &bsol;* Stream object. */
348  #define REDISMODULE_TYPE_ENCVER_BITS 10
349  #define REDISMODULE_TYPE_ENCVER_MASK ((1<<REDISMODULE_TYPE_ENCVER_BITS)-1)
350  #define REDISMODULE_TYPE_ENCVER(id) (id & REDISMODULE_TYPE_ENCVER_MASK)
351  #define REDISMODULE_TYPE_SIGN(id) ((id & ~((uint64_t)REDISMODULE_TYPE_ENCVER_MASK)) >>REDISMODULE_TYPE_ENCVER_BITS)
352  #define REDISMODULE_AUX_BEFORE_RDB (1<<0)
353  #define REDISMODULE_AUX_AFTER_RDB (1<<1)
354  struct RedisModule;
355  struct RedisModuleIO;
356  struct RedisModuleDigest;
357  struct RedisModuleCtx;
358  struct redisObject;
359  typedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);
360  typedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);
361  typedef int (*moduleTypeAuxLoadFunc)(struct RedisModuleIO *rdb, int encver, int when);
362  typedef void (*moduleTypeAuxSaveFunc)(struct RedisModuleIO *rdb, int when);
363  typedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);
364  typedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);
365  typedef size_t (*moduleTypeMemUsageFunc)(const void *value);
366  typedef void (*moduleTypeFreeFunc)(void *value);
367  typedef struct RedisModuleType {
368      uint64_t id; &bsol;* Higher 54 bits of type ID + 10 lower bits of encoding ver. */
369      struct RedisModule *module;
370      moduleTypeLoadFunc rdb_load;
371      moduleTypeSaveFunc rdb_save;
372      moduleTypeRewriteFunc aof_rewrite;
373      moduleTypeMemUsageFunc mem_usage;
374      moduleTypeDigestFunc digest;
375      moduleTypeFreeFunc free;
376      moduleTypeAuxLoadFunc aux_load;
377      moduleTypeAuxSaveFunc aux_save;
378      int aux_save_triggers;
379      char name[10]; &bsol;* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */
380  } moduleType;
381  typedef struct moduleValue {
382      moduleType *type;
383      void *value;
384  } moduleValue;
385  typedef struct RedisModuleIO {
386      size_t bytes;       &bsol;* Bytes read / written so far. */
387      rio *rio;           &bsol;* Rio stream. */
388      moduleType *type;   &bsol;* Module type doing the operation. */
389      int error;          &bsol;* True if error condition happened. */
390      int ver;            &bsol;* Module serialization version: 1 (old),
391                           * 2 (current version with opcodes annotation). */
392      struct RedisModuleCtx *ctx; &bsol;* Optional context, see RM_GetContextFromIO()*/
393      struct redisObject *key;    &bsol;* Optional name of key processed */
394  } RedisModuleIO;
395  #define moduleInitIOContext(iovar,mtype,rioptr,keyptr) do { \
396      iovar.rio = rioptr; \
397      iovar.type = mtype; \
398      iovar.bytes = 0; \
399      iovar.error = 0; \
400      iovar.ver = 0; \
401      iovar.key = keyptr; \
402      iovar.ctx = NULL; \
403  } while(0);
404  typedef struct RedisModuleDigest {
405      unsigned char o[20];    &bsol;* Ordered elements. */
406      unsigned char x[20];    &bsol;* Xored elements. */
407  } RedisModuleDigest;
408  #define moduleInitDigestContext(mdvar) do { \
409      memset(mdvar.o,0,sizeof(mdvar.o)); \
410      memset(mdvar.x,0,sizeof(mdvar.x)); \
411  } while(0);
412  #define OBJ_ENCODING_RAW 0     &bsol;* Raw representation */
413  #define OBJ_ENCODING_INT 1     &bsol;* Encoded as integer */
414  #define OBJ_ENCODING_HT 2      &bsol;* Encoded as hash table */
415  #define OBJ_ENCODING_ZIPMAP 3  &bsol;* Encoded as zipmap */
416  #define OBJ_ENCODING_LINKEDLIST 4 &bsol;* No longer used: old list encoding. */
417  #define OBJ_ENCODING_ZIPLIST 5 &bsol;* Encoded as ziplist */
418  #define OBJ_ENCODING_INTSET 6  &bsol;* Encoded as intset */
419  #define OBJ_ENCODING_SKIPLIST 7  &bsol;* Encoded as skiplist */
420  #define OBJ_ENCODING_EMBSTR 8  &bsol;* Embedded sds string encoding */
421  #define OBJ_ENCODING_QUICKLIST 9 &bsol;* Encoded as linked list of ziplists */
422  #define OBJ_ENCODING_STREAM 10 &bsol;* Encoded as a radix tree of listpacks */
423  #define LRU_BITS 24
424  #define LRU_CLOCK_MAX ((1<<LRU_BITS)-1) &bsol;* Max value of obj->lru */
425  #define LRU_CLOCK_RESOLUTION 1000 &bsol;* LRU clock resolution in ms */
426  #define OBJ_SHARED_REFCOUNT INT_MAX
427  typedef struct redisObject {
428      unsigned type:4;
429      unsigned encoding:4;
430      unsigned lru:LRU_BITS; &bsol;* LRU time (relative to global lru_clock) or
431                              * LFU data (least significant 8 bits frequency
432                              * and most significant 16 bits access time). */
433      int refcount;
434      void *ptr;
435  } robj;
436  #define initStaticStringObject(_var,_ptr) do { \
437      _var.refcount = 1; \
438      _var.type = OBJ_STRING; \
439      _var.encoding = OBJ_ENCODING_RAW; \
440      _var.ptr = _ptr; \
441  } while(0)
442  struct evictionPoolEntry; &bsol;* Defined in evict.c */
443  typedef struct clientReplyBlock {
444      size_t size, used;
445      char buf[];
446  } clientReplyBlock;
447  typedef struct redisDb {
448      dict *dict;                 &bsol;* The keyspace for this DB */
449      dict *expires;              &bsol;* Timeout of keys with a timeout set */
450      dict *blocking_keys;        &bsol;* Keys with clients waiting for data (BLPOP)*/
451      dict *ready_keys;           &bsol;* Blocked keys that received a PUSH */
452      dict *watched_keys;         &bsol;* WATCHED keys for MULTI/EXEC CAS */
453      int id;                     &bsol;* Database ID */
454      PORT_LONGLONG avg_ttl;      &bsol;* Average TTL, just for stats */
455      list *defrag_later;         &bsol;* List of key names to attempt to defrag one by one, gradually. */
456  } redisDb;
457  typedef struct multiCmd {
458      robj **argv;
459      int argc;
460      struct redisCommand *cmd;
461  } multiCmd;
462  typedef struct multiState {
463      multiCmd *commands;     &bsol;* Array of MULTI commands */
464      int count;              &bsol;* Total number of MULTI commands */
465      int cmd_flags;          &bsol;* The accumulated command flags OR-ed together.
466                                 So if at least a command has a given flag, it
467                                 will be set in this field. */
468      int minreplicas;        &bsol;* MINREPLICAS for synchronous replication */
469      time_t minreplicas_timeout; &bsol;* MINREPLICAS timeout as unixtime. */
470  } multiState;
471  typedef struct blockingState {
472      mstime_t timeout;       &bsol;* Blocking operation timeout. If UNIX current time
473                               * is > timeout then the operation timed out. */
474      dict *keys;             &bsol;* The keys we are waiting to terminate a blocking
475                               * operation such as BLPOP or XREAD. Or NULL. */
476      robj *target;           &bsol;* The key that should receive the element,
477                               * for BRPOPLPUSH. */
478      size_t xread_count;     &bsol;* XREAD COUNT option. */
479      robj *xread_group;      &bsol;* XREADGROUP group name. */
480      robj *xread_consumer;   &bsol;* XREADGROUP consumer name. */
481      mstime_t xread_retry_time, xread_retry_ttl;
482      int xread_group_noack;
483      int numreplicas;        &bsol;* Number of replicas we are waiting for ACK. */
484      PORT_LONGLONG reploffset;   &bsol;* Replication offset to reach. */
485      void *module_blocked_handle; &bsol;* RedisModuleBlockedClient structure.
486                                      which is opaque for the Redis core, only
487                                      handled in module.c. */
488  } blockingState;
489  typedef struct readyList {
490      redisDb *db;
491      robj *key;
492  } readyList;
493  typedef struct client {
494      uint64_t id;            &bsol;* Client incremental unique ID. */
495      int fd;                 &bsol;* Client socket. */
496      redisDb *db;            &bsol;* Pointer to currently SELECTed DB. */
497      robj *name;             &bsol;* As set by CLIENT SETNAME. */
498      sds querybuf;           &bsol;* Buffer we use to accumulate client queries. */
499      size_t qb_pos;          &bsol;* The position we have read in querybuf. */
500      sds pending_querybuf;   &bsol;* If this client is flagged as master, this buffer
501                                 represents the yet not applied portion of the
502                                 replication stream that we are receiving from
503                                 the master. */
504      size_t querybuf_peak;   &bsol;* Recent (100ms or more) peak of querybuf size. */
505      int argc;               &bsol;* Num of arguments of current command. */
506      robj **argv;            &bsol;* Arguments of current command. */
507      struct redisCommand *cmd, *lastcmd;  &bsol;* Last command executed. */
508      int reqtype;            &bsol;* Request protocol type: PROTO_REQ_* */
509      int multibulklen;       &bsol;* Number of multi bulk arguments left to read. */
510      PORT_LONG bulklen;           &bsol;* Length of bulk argument in multi bulk request. */
511      list *reply;            &bsol;* List of reply objects to send to the client. */
512      PORT_ULONGLONG reply_bytes; &bsol;* Tot bytes of objects in reply list. */
513      size_t sentlen;         &bsol;* Amount of bytes already sent in the current
514                                 buffer or object being sent. */
515      time_t ctime;           &bsol;* Client creation time. */
516      time_t lastinteraction; &bsol;* Time of the last interaction, used for timeout */
517      time_t obuf_soft_limit_reached_time;
518      int flags;              &bsol;* Client flags: CLIENT_* macros. */
519      int authenticated;      &bsol;* When requirepass is non-NULL. */
520      int replstate;          &bsol;* Replication state if this is a slave. */
521      int repl_put_online_on_ack; &bsol;* Install slave write handler on first ACK. */
522      int repldbfd;           &bsol;* Replication DB file descriptor. */
523      off_t repldboff;        &bsol;* Replication DB file offset. */
524      off_t repldbsize;       &bsol;* Replication DB file size. */
525      sds replpreamble;       &bsol;* Replication DB preamble. */
526      PORT_LONGLONG read_reploff; &bsol;* Read replication offset if this is a master. */
527      PORT_LONGLONG reploff;      &bsol;* Applied replication offset if this is a master. */
528      PORT_LONGLONG repl_ack_off; &bsol;* Replication ack offset, if this is a slave. */
529      PORT_LONGLONG repl_ack_time;&bsol;* Replication ack time, if this is a slave. */
530      PORT_LONGLONG psync_initial_offset; &bsol;* FULLRESYNC reply offset other slaves
531                                         copying this slave output buffer
532                                         should use. */
533      char replid[CONFIG_RUN_ID_SIZE+1]; &bsol;* Master replication ID (if master). */
534      int slave_listening_port; &bsol;* As configured with: SLAVECONF listening-port */
535      char slave_ip[NET_IP_STR_LEN]; &bsol;* Optionally given by REPLCONF ip-address */
536      int slave_capa;         &bsol;* Slave capabilities: SLAVE_CAPA_* bitwise OR. */
537      multiState mstate;      &bsol;* MULTI/EXEC state */
538      int btype;              &bsol;* Type of blocking op if CLIENT_BLOCKED. */
539      blockingState bpop;     &bsol;* blocking state */
540      PORT_LONGLONG woff;         &bsol;* Last write global replication offset. */
541      list *watched_keys;     &bsol;* Keys WATCHED for MULTI/EXEC CAS */
542      dict *pubsub_channels;  &bsol;* channels a client is interested in (SUBSCRIBE) */
543      list *pubsub_patterns;  &bsol;* patterns a client is interested in (SUBSCRIBE) */
544      sds peerid;             &bsol;* Cached peer ID. */
545      listNode *client_list_node; &bsol;* list node in client list */
546      WIN32_ONLY(char replFileCopy[_MAX_PATH];)
547      int bufpos;
548      char buf[PROTO_REPLY_CHUNK_BYTES];
549  } client;
550  struct saveparam {
551      time_t seconds;
552      int changes;
553  };
554  struct moduleLoadQueueEntry {
555      sds path;
556      int argc;
557      robj **argv;
558  };
559  struct sharedObjectsStruct {
560      robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,
561      *colon, *nullbulk, *nullmultibulk, *queued,
562      *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,
563      *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,
564      *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,
565      *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,
566      *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,
567      *rpop, *lpop, *lpush, *rpoplpush, *zpopmin, *zpopmax, *emptyscan,
568      *select[PROTO_SHARED_SELECT_CMDS],
569      *integers[OBJ_SHARED_INTEGERS],
570      *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], &bsol;* "*<value>\r\n" */
571      *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  &bsol;* "$<value>\r\n" */
572      sds minstring, maxstring;
573  };
574  typedef struct zskiplistNode {
575      sds ele;
576      double score;
577      struct zskiplistNode *backward;
578      struct zskiplistLevel {
579          struct zskiplistNode *forward;
580          PORT_ULONG span;
581      } level[];
582  } zskiplistNode;
583  typedef struct zskiplist {
584      struct zskiplistNode *header, *tail;
585      PORT_ULONG length;
586      int level;
587  } zskiplist;
588  typedef struct zset {
589      dict *dict;
590      zskiplist *zsl;
591  } zset;
592  typedef struct clientBufferLimitsConfig {
593      PORT_ULONGLONG hard_limit_bytes;
594      PORT_ULONGLONG soft_limit_bytes;
595      time_t soft_limit_seconds;
596  } clientBufferLimitsConfig;
597  extern clientBufferLimitsConfig clientBufferLimitsDefaults[CLIENT_TYPE_OBUF_COUNT];
598  typedef struct redisOp {
599      robj **argv;
600      int argc, dbid, target;
601      struct redisCommand *cmd;
602  } redisOp;
603  typedef struct redisOpArray {
604      redisOp *ops;
605      int numops;
606  } redisOpArray;
607  struct redisMemOverhead {
608      size_t peak_allocated;
609      size_t total_allocated;
610      size_t startup_allocated;
611      size_t repl_backlog;
612      size_t clients_slaves;
613      size_t clients_normal;
614      size_t aof_buffer;
615      size_t lua_caches;
616      size_t overhead_total;
617      size_t dataset;
618      size_t total_keys;
619      size_t bytes_per_key;
620      float dataset_perc;
621      float peak_perc;
622      float total_frag;
623      ssize_t total_frag_bytes;
624      float allocator_frag;
625      ssize_t allocator_frag_bytes;
626      float allocator_rss;
627      ssize_t allocator_rss_bytes;
628      float rss_extra;
629      size_t rss_extra_bytes;
630      size_t num_dbs;
631      struct {
632          size_t dbid;
633          size_t overhead_ht_main;
634          size_t overhead_ht_expires;
635      } *db;
636  };
637  typedef struct rdbSaveInfo {
638      int repl_stream_db;  &bsol;* DB to select in server.master client. */
639      int repl_id_is_set;  &bsol;* True if repl_id field is set. */
640      char repl_id[CONFIG_RUN_ID_SIZE+1];     &bsol;* Replication ID. */
641      PORT_LONGLONG repl_offset;                  &bsol;* Replication offset. */
642  } rdbSaveInfo;
643  #define RDB_SAVE_INFO_INIT {-1,0,"000000000000000000000000000000",-1}
644  struct malloc_stats {
645      size_t zmalloc_used;
646      size_t process_rss;
647      size_t allocator_allocated;
648      size_t allocator_active;
649      size_t allocator_resident;
650  };
651  struct clusterState;
652  #ifdef _AIX
653  #undef hz
654  #endif
655  #define CHILD_INFO_MAGIC 0xC17DDA7A12345678LL
656  #define CHILD_INFO_TYPE_RDB 0
657  #define CHILD_INFO_TYPE_AOF 1
658  struct redisServer {
659      pid_t pid;                  &bsol;* Main process pid. */
660      char *configfile;           &bsol;* Absolute config file path, or NULL */
661      char *executable;           &bsol;* Absolute executable file path. */
662      char **exec_argv;           &bsol;* Executable argv vector (copy). */
663      int dynamic_hz;             &bsol;* Change hz value depending on # of clients. */
664      int config_hz;              &bsol;* Configured HZ value. May be different than
665                                     the actual 'hz' field value if dynamic-hz
666                                     is enabled. */
667      int hz;                     &bsol;* serverCron() calls frequency in hertz */
668      redisDb *db;
669      dict *commands;             &bsol;* Command table */
670      dict *orig_commands;        &bsol;* Command table before command renaming. */
671      aeEventLoop *el;
672      unsigned int lruclock;      &bsol;* Clock for LRU eviction */
673      int shutdown_asap;          &bsol;* SHUTDOWN needed ASAP */
674      int activerehashing;        &bsol;* Incremental rehash in serverCron() */
675      int active_defrag_running;  &bsol;* Active defragmentation running (holds current scan aggressiveness) */
676      char *requirepass;          &bsol;* Pass for AUTH command, or NULL */
677      char *pidfile;              &bsol;* PID file path */
678      int arch_bits;              &bsol;* 32 or 64 depending on sizeof(long) */
679      int cronloops;              &bsol;* Number of times the cron function run */
680      char runid[CONFIG_RUN_ID_SIZE+1];  &bsol;* ID always different at every exec. */
681      int sentinel_mode;          &bsol;* True if this instance is a Sentinel. */
682      size_t initial_memory_usage; &bsol;* Bytes used after initialization. */
683      int always_show_logo;       &bsol;* Show logo even for non-stdout logging. */
684      dict *moduleapi;            &bsol;* Exported core APIs dictionary for modules. */
685      dict *sharedapi;            &bsol;* Like moduleapi but containing the APIs that
686                                     modules share with each other. */
687      list *loadmodule_queue;     &bsol;* List of modules to load at startup. */
688      int module_blocked_pipe[2]; &bsol;* Pipe used to awake the event loop if a
689                                     client blocked on a module command needs
690                                     to be processed. */
691      int port;                   &bsol;* TCP listening port */
692      int tcp_backlog;            &bsol;* TCP listen() backlog */
693      char *bindaddr[CONFIG_BINDADDR_MAX]; &bsol;* Addresses we should bind to */
694      int bindaddr_count;         &bsol;* Number of addresses in server.bindaddr[] */
695      char *unixsocket;           &bsol;* UNIX socket path */
696      mode_t unixsocketperm;      &bsol;* UNIX socket permission */
697      int ipfd[CONFIG_BINDADDR_MAX]; &bsol;* TCP socket file descriptors */
698      int ipfd_count;             &bsol;* Used slots in ipfd[] */
699      int sofd;                   &bsol;* Unix socket file descriptor */
700      int cfd[CONFIG_BINDADDR_MAX];&bsol;* Cluster bus listening socket */
701      int cfd_count;              &bsol;* Used slots in cfd[] */
702      list *clients;              &bsol;* List of active clients */
703      list *clients_to_close;     &bsol;* Clients to close asynchronously */
704      list *clients_pending_write; &bsol;* There is to write or install handler. */
705      list *slaves, *monitors;    &bsol;* List of slaves and MONITORs */
706      client *current_client;     &bsol;* Current client executing the command. */
707      PORT_LONG fixed_time_expire; &bsol;* If > 0, expire keys against server.mstime. */
708      rax *clients_index;         &bsol;* Active clients dictionary by client ID. */
709      int clients_paused;         &bsol;* True if clients are currently paused */
710      mstime_t clients_pause_end_time; &bsol;* Time when we undo clients_paused */
711      char neterr[ANET_ERR_LEN];   &bsol;* Error buffer for anet.c */
712      dict *migrate_cached_sockets;&bsol;* MIGRATE cached sockets */
713      uint64_t next_client_id;    &bsol;* Next client unique ID. Incremental. */
714      int protected_mode;         &bsol;* Don't accept external connections. */
715      int loading;                &bsol;* We are loading data from disk if true */
716      off_t loading_total_bytes;
717      off_t loading_loaded_bytes;
718      time_t loading_start_time;
719      off_t loading_process_events_interval_bytes;
720      struct redisCommand *delCommand, *multiCommand, *lpushCommand,
721                          *lpopCommand, *rpopCommand, *zpopminCommand,
722                          *zpopmaxCommand, *sremCommand, *execCommand,
723                          *expireCommand, *pexpireCommand, *xclaimCommand,
724                          *xgroupCommand;
725      time_t stat_starttime;          &bsol;* Server start time */
726      PORT_LONGLONG stat_numcommands;     &bsol;* Number of processed commands */
727      PORT_LONGLONG stat_numconnections;  &bsol;* Number of connections received */
728      PORT_LONGLONG stat_expiredkeys;     &bsol;* Number of expired keys */
729      double stat_expired_stale_perc; &bsol;* Percentage of keys probably expired */
730      PORT_LONGLONG stat_expired_time_cap_reached_count; &bsol;* Early expire cylce stops.*/
731      PORT_LONGLONG stat_evictedkeys;     &bsol;* Number of evicted keys (maxmemory) */
732      PORT_LONGLONG stat_keyspace_hits;   &bsol;* Number of successful lookups of keys */
733      PORT_LONGLONG stat_keyspace_misses; &bsol;* Number of failed lookups of keys */
734      PORT_LONGLONG stat_active_defrag_hits;      &bsol;* number of allocations moved */
735      PORT_LONGLONG stat_active_defrag_misses;    &bsol;* number of allocations scanned but not moved */
736      PORT_LONGLONG stat_active_defrag_key_hits;  &bsol;* number of keys with moved allocations */
737      PORT_LONGLONG stat_active_defrag_key_misses;&bsol;* number of keys scanned and not moved */
738      PORT_LONGLONG stat_active_defrag_scanned;   &bsol;* number of dictEntries scanned */
739      size_t stat_peak_memory;        &bsol;* Max used memory record */
740      PORT_LONGLONG stat_fork_time;       &bsol;* Time needed to perform latest fork() */
741      double stat_fork_rate;          &bsol;* Fork rate in GB/sec. */
742      PORT_LONGLONG stat_rejected_conn;   &bsol;* Clients rejected because of maxclients */
743      PORT_LONGLONG stat_sync_full;       &bsol;* Number of full resyncs with slaves. */
744      PORT_LONGLONG stat_sync_partial_ok; &bsol;* Number of accepted PSYNC requests. */
745      PORT_LONGLONG stat_sync_partial_err;&bsol;* Number of unaccepted PSYNC requests. */
746      list *slowlog;                  &bsol;* SLOWLOG list of commands */
747      PORT_LONGLONG slowlog_entry_id;     &bsol;* SLOWLOG current entry ID */
748      PORT_LONGLONG slowlog_log_slower_than; &bsol;* SLOWLOG time limit (to get logged) */
749      PORT_ULONG slowlog_max_len;     &bsol;* SLOWLOG max number of items logged */
750      struct malloc_stats cron_malloc_stats; &bsol;* sampled in serverCron(). */
751      PORT_LONGLONG stat_net_input_bytes; &bsol;* Bytes read from network. */
752      PORT_LONGLONG stat_net_output_bytes; &bsol;* Bytes written to network. */
753      size_t stat_rdb_cow_bytes;      &bsol;* Copy on write bytes during RDB saving. */
754      size_t stat_aof_cow_bytes;      &bsol;* Copy on write bytes during AOF rewrite. */
755      struct {
756          PORT_LONGLONG last_sample_time; &bsol;* Timestamp of last sample in ms */
757          PORT_LONGLONG last_sample_count;&bsol;* Count in last sample */
758          PORT_LONGLONG samples[STATS_METRIC_SAMPLES];
759          int idx;
760      } inst_metric[STATS_METRIC_COUNT];
761      int verbosity;                  &bsol;* Loglevel in redis.conf */
762      int maxidletime;                &bsol;* Client timeout in seconds */
763      int tcpkeepalive;               &bsol;* Set SO_KEEPALIVE if non-zero. */
764      int active_expire_enabled;      &bsol;* Can be disabled for testing purposes. */
765      int active_defrag_enabled;
766      size_t active_defrag_ignore_bytes; &bsol;* minimum amount of fragmentation waste to start active defrag */
767      int active_defrag_threshold_lower; &bsol;* minimum percentage of fragmentation to start active defrag */
768      int active_defrag_threshold_upper; &bsol;* maximum percentage of fragmentation at which we use maximum effort */
769      int active_defrag_cycle_min;       &bsol;* minimal effort for defrag in CPU percentage */
770      int active_defrag_cycle_max;       &bsol;* maximal effort for defrag in CPU percentage */
771      PORT_ULONG active_defrag_max_scan_fields; &bsol;* maximum number of fields of set/hash/zset/list to process from within the main dict scan */
772      size_t client_max_querybuf_len; &bsol;* Limit for client query buffer length */
773      int dbnum;                      &bsol;* Total number of configured DBs */
774      int supervised;                 &bsol;* 1 if supervised, 0 otherwise. */
775      int supervised_mode;            &bsol;* See SUPERVISED_* */
776      int daemonize;                  &bsol;* True if running as a daemon */
777      clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];
778      int aof_state;                  &bsol;* AOF_(ON|OFF|WAIT_REWRITE) */
779      int aof_fsync;                  &bsol;* Kind of fsync() policy */
780      char *aof_filename;             &bsol;* Name of the AOF file */
781      int aof_no_fsync_on_rewrite;    &bsol;* Don't fsync if a rewrite is in prog. */
782      int aof_rewrite_perc;           &bsol;* Rewrite AOF if % growth is > M and... */
783      off_t aof_rewrite_min_size;     &bsol;* the AOF file is at least N bytes. */
784      off_t aof_rewrite_base_size;    &bsol;* AOF size on latest startup or rewrite. */
785      off_t aof_current_size;         &bsol;* AOF current size. */
786      off_t aof_fsync_offset;         &bsol;* AOF offset which is already synced to disk. */
787      int aof_rewrite_scheduled;      &bsol;* Rewrite once BGSAVE terminates. */
788      pid_t aof_child_pid;            &bsol;* PID if rewriting process */
789      list *aof_rewrite_buf_blocks;   &bsol;* Hold changes during an AOF rewrite. */
790      sds aof_buf;      &bsol;* AOF buffer, written before entering the event loop */
791      int aof_fd;       &bsol;* File descriptor of currently selected AOF file */
792      int aof_selected_db; &bsol;* Currently selected DB in AOF */
793      time_t aof_flush_postponed_start; &bsol;* UNIX time of postponed AOF flush */
794      time_t aof_last_fsync;            &bsol;* UNIX time of last fsync() */
795      time_t aof_rewrite_time_last;   &bsol;* Time used by last AOF rewrite run. */
796      time_t aof_rewrite_time_start;  &bsol;* Current AOF rewrite start time. */
797      int aof_lastbgrewrite_status;   &bsol;* C_OK or C_ERR */
798      PORT_ULONG aof_delayed_fsync;  &bsol;* delayed AOF fsync() counter */
799      int aof_rewrite_incremental_fsync;&bsol;* fsync incrementally while aof rewriting? */
800      int rdb_save_incremental_fsync;   &bsol;* fsync incrementally while rdb saving? */
801      int aof_last_write_status;      &bsol;* C_OK or C_ERR */
802      int aof_last_write_errno;       &bsol;* Valid if aof_last_write_status is ERR */
803      int aof_load_truncated;         &bsol;* Don't stop on unexpected AOF EOF. */
804      int aof_use_rdb_preamble;       &bsol;* Use RDB preamble on AOF rewrites. */
805      int aof_pipe_write_data_to_child;
806      int aof_pipe_read_data_from_parent;
807      int aof_pipe_write_ack_to_parent;
808      int aof_pipe_read_ack_from_child;
809      int aof_pipe_write_ack_to_child;
810      int aof_pipe_read_ack_from_parent;
811      int aof_stop_sending_diff;     &bsol;* If true stop sending accumulated diffs
812                                        to child process. */
813      sds aof_child_diff;             &bsol;* AOF diff accumulator child side. */
814      PORT_LONGLONG dirty;                &bsol;* Changes to DB from the last save */
815      PORT_LONGLONG dirty_before_bgsave;  &bsol;* Used to restore dirty on failed BGSAVE */
816      pid_t rdb_child_pid;            &bsol;* PID of RDB saving child */
817      struct saveparam *saveparams;   &bsol;* Save points array for RDB */
818      int saveparamslen;              &bsol;* Number of saving points */
819      char *rdb_filename;             &bsol;* Name of RDB file */
820      int rdb_compression;            &bsol;* Use compression in RDB? */
821      int rdb_checksum;               &bsol;* Use RDB checksum? */
822      time_t lastsave;                &bsol;* Unix time of last successful save */
823      time_t lastbgsave_try;          &bsol;* Unix time of last attempted bgsave */
824      time_t rdb_save_time_last;      &bsol;* Time used by last RDB save run. */
825      time_t rdb_save_time_start;     &bsol;* Current RDB save start time. */
826      int rdb_bgsave_scheduled;       &bsol;* BGSAVE when possible if true. */
827      int rdb_child_type;             &bsol;* Type of save by active child. */
828      int lastbgsave_status;          &bsol;* C_OK or C_ERR */
829      int stop_writes_on_bgsave_err;  &bsol;* Don't allow writes if can't BGSAVE */
830      int rdb_pipe_write_result_to_parent; &bsol;* RDB pipes used to return the state */
831      int rdb_pipe_read_result_from_child; &bsol;* of each slave in diskless SYNC. */
832      int child_info_pipe[2];         &bsol;* Pipe used to write the child_info_data. */
833      struct {
834          int process_type;           &bsol;* AOF or RDB child? */
835          size_t cow_size;            &bsol;* Copy on write size. */
836          PORT_ULONGLONG magic;   &bsol;* Magic value to make sure data is valid. */
837      } child_info_data;
838      redisOpArray also_propagate;    &bsol;* Additional command to propagate. */
839      char *logfile;                  &bsol;* Path of log file */
840      int syslog_enabled;             &bsol;* Is syslog enabled? */
841      char *syslog_ident;             &bsol;* Syslog ident */
842      POSIX_ONLY(int syslog_facility;) &bsol;* Syslog facility */
843      char replid[CONFIG_RUN_ID_SIZE+1];  &bsol;* My current replication ID. */
844      char replid2[CONFIG_RUN_ID_SIZE+1]; &bsol;* replid inherited from master*/
845      PORT_LONGLONG master_repl_offset;   &bsol;* My current replication offset */
846      PORT_LONGLONG second_replid_offset; &bsol;* Accept offsets up to this for replid2. */
847      int slaveseldb;                 &bsol;* Last SELECTed DB in replication output */
848      int repl_ping_slave_period;     &bsol;* Master pings the slave every N seconds */
849      char *repl_backlog;             &bsol;* Replication backlog for partial syncs */
850      PORT_LONGLONG repl_backlog_size;    &bsol;* Backlog circular buffer size */
851      PORT_LONGLONG repl_backlog_histlen; &bsol;* Backlog actual data length */
852      PORT_LONGLONG repl_backlog_idx;     &bsol;* Backlog circular buffer current offset,
853                                         that is the next byte will'll write to.*/
854      PORT_LONGLONG repl_backlog_off;     &bsol;* Replication "master offset" of first
855                                         byte in the replication backlog buffer.*/
856      time_t repl_backlog_time_limit; &bsol;* Time without slaves after the backlog
857                                         gets released. */
858      time_t repl_no_slaves_since;    &bsol;* We have no slaves since that time.
859                                         Only valid if server.slaves len is 0. */
860      int repl_min_slaves_to_write;   &bsol;* Min number of slaves to write. */
861      int repl_min_slaves_max_lag;    &bsol;* Max lag of <count> slaves to write. */
862      int repl_good_slaves_count;     &bsol;* Number of slaves with lag <= max_lag. */
863      int repl_diskless_sync;         &bsol;* Send RDB to slaves sockets directly. */
864      int repl_diskless_sync_delay;   &bsol;* Delay to start a diskless repl BGSAVE. */
865      char *masterauth;               &bsol;* AUTH with this password with master */
866      char *masterhost;               &bsol;* Hostname of master */
867      int masterport;                 &bsol;* Port of master */
868      int repl_timeout;               &bsol;* Timeout after N seconds of master idle */
869      client *master;     &bsol;* Client that is master for this slave */
870      client *cached_master; &bsol;* Cached master to be reused for PSYNC. */
871      int repl_syncio_timeout; &bsol;* Timeout for synchronous I/O calls */
872      int repl_state;          &bsol;* Replication status if the instance is a slave */
873      off_t repl_transfer_size; &bsol;* Size of RDB to read from master during sync. */
874      off_t repl_transfer_read; &bsol;* Amount of RDB read from master during sync. */
875      off_t repl_transfer_last_fsync_off; &bsol;* Offset when we fsync-ed last time. */
876      int repl_transfer_s;     &bsol;* Slave -> Master SYNC socket */
877      int repl_transfer_fd;    &bsol;* Slave -> Master SYNC temp file descriptor */
878      char *repl_transfer_tmpfile; &bsol;* Slave-> master SYNC temp file name */
879      time_t repl_transfer_lastio; &bsol;* Unix time of the latest read, for timeout */
880      int repl_serve_stale_data; &bsol;* Serve stale data when link is down? */
881      int repl_slave_ro;          &bsol;* Slave is read only? */
882      int repl_slave_ignore_maxmemory;    &bsol;* If true slaves do not evict. */
883      time_t repl_down_since; &bsol;* Unix time at which link with master went down */
884      int repl_disable_tcp_nodelay;   &bsol;* Disable TCP_NODELAY after SYNC? */
885      int slave_priority;             &bsol;* Reported in INFO and used by Sentinel. */
886      int slave_announce_port;        &bsol;* Give the master this listening port. */
887      char *slave_announce_ip;        &bsol;* Give the master this ip address. */
888      char master_replid[CONFIG_RUN_ID_SIZE+1];  &bsol;* Master PSYNC runid. */
889      PORT_LONGLONG master_initial_offset;           &bsol;* Master PSYNC offset. */
890      int repl_slave_lazy_flush;          &bsol;* Lazy FLUSHALL before loading DB? */
891      dict *repl_scriptcache_dict;        &bsol;* SHA1 all slaves are aware of. */
892      list *repl_scriptcache_fifo;        &bsol;* First in, first out LRU eviction. */
893      unsigned int repl_scriptcache_size; &bsol;* Max number of elements. */
894      list *clients_waiting_acks;         &bsol;* Clients waiting in WAIT command. */
895      int get_ack_from_slaves;            &bsol;* If true we send REPLCONF GETACK. */
896      unsigned int maxclients;            &bsol;* Max number of simultaneous clients */
897      PORT_ULONGLONG maxmemory;   &bsol;* Max number of memory bytes to use */
898      int maxmemory_policy;           &bsol;* Policy for key eviction */
899      int maxmemory_samples;          &bsol;* Pricision of random sampling */
900      int lfu_log_factor;             &bsol;* LFU logarithmic counter factor. */
901      int lfu_decay_time;             &bsol;* LFU counter decay factor. */
902      PORT_LONGLONG proto_max_bulk_len;   &bsol;* Protocol bulk length maximum size. */
903      unsigned int blocked_clients;   &bsol;* # of clients executing a blocking cmd.*/
904      unsigned int blocked_clients_by_type[BLOCKED_NUM];
905      list *unblocked_clients; &bsol;* list of clients to unblock before next loop */
906      list *ready_keys;        &bsol;* List of readyList structures for BLPOP & co */
<span onclick='openModal()' class='match'>907      int sort_desc;
908      int sort_alpha;
909      int sort_bypattern;
910      int sort_store;
911      size_t hash_max_ziplist_entries;
912      size_t hash_max_ziplist_value;
</span>913      size_t set_max_intset_entries;
914      size_t zset_max_ziplist_entries;
915      size_t zset_max_ziplist_value;
916      size_t hll_sparse_max_bytes;
917      size_t stream_node_max_bytes;
918      int64_t stream_node_max_entries;
919      int list_max_ziplist_size;
920      int list_compress_depth;
921      time_t unixtime;    &bsol;* Unix time sampled every cron cycle. */
922      time_t timezone;    &bsol;* Cached timezone. As set by tzset(). */
923      int daylight_active;    &bsol;* Currently in daylight saving time. */
924      mstime_t mstime;            &bsol;* 'unixtime' in milliseconds. */
925      ustime_t ustime;            &bsol;* 'unixtime' in microseconds. */
926      dict *pubsub_channels;  &bsol;* Map channels to list of subscribed clients */
927      list *pubsub_patterns;  &bsol;* A list of pubsub_patterns */
928      int notify_keyspace_events; &bsol;* Events to propagate via Pub/Sub. This is an
929                                     xor of NOTIFY_... flags. */
930      int cluster_enabled;      &bsol;* Is cluster enabled? */
931      mstime_t cluster_node_timeout; &bsol;* Cluster node timeout. */
932      char *cluster_configfile; &bsol;* Cluster auto-generated config file name. */
933      struct clusterState *cluster;  &bsol;* State of the cluster */
934      int cluster_migration_barrier; &bsol;* Cluster replicas migration barrier. */
935      int cluster_slave_validity_factor; &bsol;* Slave max data age for failover. */
936      int cluster_require_full_coverage; &bsol;* If true, put the cluster down if
937                                            there is at least an uncovered slot.*/
938      int cluster_slave_no_failover;  &bsol;* Prevent slave from starting a failover
939                                         if the master is in failure state. */
940      char *cluster_announce_ip;  &bsol;* IP address to announce on cluster bus. */
941      int cluster_announce_port;     &bsol;* base port to announce on cluster bus. */
942      int cluster_announce_bus_port; &bsol;* bus port to announce on cluster bus. */
943      int cluster_module_flags;      &bsol;* Set of flags that Redis modules are able
944                                        to set in order to suppress certain
945                                        native Redis Cluster features. Check the
946                                        REDISMODULE_CLUSTER_FLAG_*. */
947      lua_State *lua; &bsol;* The Lua interpreter. We use just one for all clients */
948      client *lua_client;   &bsol;* The "fake client" to query Redis from Lua */
949      client *lua_caller;   &bsol;* The client running EVAL right now, or NULL */
950      dict *lua_scripts;         &bsol;* A dictionary of SHA1 -> Lua scripts */
951      PORT_ULONGLONG lua_scripts_mem;  &bsol;* Cached scripts' memory + oh */
952      mstime_t lua_time_limit;  &bsol;* Script timeout in milliseconds */
953      mstime_t lua_time_start;  &bsol;* Start time of script, milliseconds time */
954      int lua_write_dirty;  &bsol;* True if a write command was called during the
955                               execution of the current script. */
956      int lua_random_dirty; &bsol;* True if a random command was called during the
957                               execution of the current script. */
958      int lua_replicate_commands; &bsol;* True if we are doing single commands repl. */
959      int lua_multi_emitted;&bsol;* True if we already proagated MULTI. */
960      int lua_repl;         &bsol;* Script replication flags for redis.set_repl(). */
961      int lua_timedout;     &bsol;* True if we reached the time limit for script
962                               execution. */
963      int lua_kill;         &bsol;* Kill the script if true. */
964      int lua_always_replicate_commands; &bsol;* Default replication type. */
965      int lua_oom;          &bsol;* OOM detected when script start? */
966      int lazyfree_lazy_eviction;
967      int lazyfree_lazy_expire;
968      int lazyfree_lazy_server_del;
969      PORT_LONGLONG latency_monitor_threshold;
970      dict *latency_events;
971      const char *assert_failed;
972      const char *assert_file;
973      int assert_line;
974      int bug_report_start; &bsol;* True if bug report header was already logged. */
975      int watchdog_period;  &bsol;* Software watchdog period in ms. 0 = off */
976      size_t system_memory_size;  &bsol;* Total memory in system as reported by OS */
977      pthread_mutex_t lruclock_mutex;
978      pthread_mutex_t next_client_id_mutex;
979      pthread_mutex_t unixtime_mutex;
980  };
981  #ifdef _WIN32
982  dict* modules; &bsol;* Hash table of modules. SDS -> RedisModule ptr.*/
983  #endif
984  typedef struct pubsubPattern {
985      client *client;
986      robj *pattern;
987  } pubsubPattern;
988  typedef void redisCommandProc(client *c);
989  typedef int *redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
990  struct redisCommand {
991      char *name;
992      redisCommandProc *proc;
993      int arity;
994      char *sflags; &bsol;* Flags as string representation, one char per flag. */
995      int flags;    &bsol;* The actual flags, obtained from the 'sflags' field. */
996      redisGetKeysProc *getkeys_proc;
997      int firstkey; &bsol;* The first argument that's a key (0 = no keys) */
998      int lastkey;  &bsol;* The last argument that's a key */
999      int keystep;  &bsol;* The step between first and last key */
1000      PORT_LONGLONG microseconds, calls;
1001  };
1002  struct redisFunctionSym {
1003      char *name;
1004      PORT_ULONG pointer;
1005  };
1006  typedef struct _redisSortObject {
1007      robj *obj;
1008      union {
1009          double score;
1010          robj *cmpobj;
1011      } u;
1012  } redisSortObject;
1013  typedef struct _redisSortOperation {
1014      int type;
1015      robj *pattern;
1016  } redisSortOperation;
1017  typedef struct {
1018      robj *subject;
1019      unsigned char encoding;
1020      unsigned char direction; &bsol;* Iteration direction */
1021      quicklistIter *iter;
1022  } listTypeIterator;
1023  typedef struct {
1024      listTypeIterator *li;
1025      quicklistEntry entry; &bsol;* Entry in quicklist */
1026  } listTypeEntry;
1027  typedef struct {
1028      robj *subject;
1029      int encoding;
1030      int ii; &bsol;* intset iterator */
1031      dictIterator *di;
1032  } setTypeIterator;
1033  typedef struct {
1034      robj *subject;
1035      int encoding;
1036      unsigned char *fptr, *vptr;
1037      dictIterator *di;
1038      dictEntry *de;
1039  } hashTypeIterator;
1040  #include "stream.h"  &bsol;* Stream data type header file. */
1041  #define OBJ_HASH_KEY 1
1042  #define OBJ_HASH_VALUE 2
1043  extern struct redisServer server;
1044  extern struct sharedObjectsStruct shared;
1045  extern dictType objectKeyPointerValueDictType;
1046  extern dictType objectKeyHeapPointerValueDictType;
1047  extern dictType setDictType;
1048  extern dictType zsetDictType;
1049  extern dictType clusterNodesDictType;
1050  extern dictType clusterNodesBlackListDictType;
1051  extern dictType dbDictType;
1052  extern dictType shaScriptObjectDictType;
1053  extern double R_Zero, R_PosInf, R_NegInf, R_Nan;
1054  extern dictType hashDictType;
1055  extern dictType replScriptCacheDictType;
1056  extern dictType keyptrDictType;
1057  extern dictType modulesDictType;
1058  void moduleInitModulesSystem(void);
1059  int moduleLoad(const char *path, void **argv, int argc);
1060  void moduleLoadFromQueue(void);
1061  int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
1062  moduleType *moduleTypeLookupModuleByID(uint64_t id);
1063  void moduleTypeNameByID(char *name, uint64_t moduleid);
1064  void moduleFreeContext(struct RedisModuleCtx *ctx);
1065  void unblockClientFromModule(client *c);
1066  void moduleHandleBlockedClients(void);
1067  void moduleBlockedClientTimedOut(client *c);
1068  void moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask);
1069  size_t moduleCount(void);
1070  void moduleAcquireGIL(void);
1071  void moduleReleaseGIL(void);
1072  void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid);
1073  void moduleCallCommandFilters(client *c);
1074  ssize_t rdbSaveModulesAux(rio *rdb, int when);
1075  PORT_LONGLONG ustime(void);
1076  PORT_LONGLONG mstime(void);
1077  void getRandomHexChars(char *p, size_t len);
1078  void getRandomBytes(unsigned char *p, size_t len);
1079  uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);
1080  void exitFromChild(int retcode);
1081  size_t redisPopcount(void *s, PORT_LONG count);
1082  void redisSetProcTitle(char *title);
1083  client *createClient(int fd);
1084  void closeTimedoutClients(void);
1085  void freeClient(client *c);
1086  void freeClientAsync(client *c);
1087  void resetClient(client *c);
1088  void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask);
1089  void *addDeferredMultiBulkLength(client *c);
1090  void setDeferredMultiBulkLength(client *c, void *node, PORT_LONG length);
1091  void processInputBuffer(client *c);
1092  void processInputBufferAndReplicate(client *c);
1093  void acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);
1094  void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask);
1095  void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask);
1096  void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask);
1097  void addReplyString(client *c, const char *s, size_t len);
1098  void AddReplyFromClient(client *c, client *src);
1099  void addReplyBulk(client *c, robj *obj);
1100  void addReplyBulkCString(client *c, const char *s);
1101  void addReplyBulkCBuffer(client *c, const void *p, size_t len);
1102  void addReplyBulkLongLong(client *c, PORT_LONGLONG ll);
1103  void addReply(client *c, robj *obj);
1104  void addReplySds(client *c, sds s);
1105  void addReplyBulkSds(client *c, sds s);
1106  void addReplyError(client *c, const char *err);
1107  void addReplyStatus(client *c, const char *status);
1108  void addReplyDouble(client *c, double d);
1109  void addReplyHumanLongDouble(client *c, PORT_LONGDOUBLE d);
1110  void addReplyLongLong(client *c, PORT_LONGLONG ll);
1111  void addReplyMultiBulkLen(client *c, PORT_LONG length);
1112  void addReplyHelp(client *c, const char **help);
1113  void addReplySubcommandSyntaxError(client *c);
1114  void copyClientOutputBuffer(client *dst, client *src);
1115  size_t sdsZmallocSize(sds s);
1116  size_t getStringObjectSdsUsedMemory(robj *o);
1117  void freeClientReplyValue(void *o);
1118  void *dupClientReplyValue(void *o);
1119  void getClientsMaxBuffers(PORT_ULONG *longest_output_list,
1120                            PORT_ULONG *biggest_input_buffer);
1121  char *getClientPeerId(client *client);
1122  sds catClientInfoString(sds s, client *client);
1123  sds getAllClientsInfoString(int type);
1124  void rewriteClientCommandVector(client *c, int argc, ...);
1125  void rewriteClientCommandArgument(client *c, int i, robj *newval);
1126  void replaceClientCommandVector(client *c, int argc, robj **argv);
1127  PORT_ULONG getClientOutputBufferMemoryUsage(client *c);
1128  void freeClientsInAsyncFreeQueue(void);
1129  void asyncCloseClientOnOutputBufferLimitReached(client *c);
1130  int getClientType(client *c);
1131  int getClientTypeByName(char *name);
1132  char *getClientTypeName(int IF_WIN32(_class,class));
1133  void flushSlavesOutputBuffers(void);
1134  void disconnectSlaves(void);
1135  int listenToPort(int port, int *fds, int *count);
1136  void pauseClients(mstime_t duration);
1137  int clientsArePaused(void);
1138  int processEventsWhileBlocked(void);
1139  int handleClientsWithPendingWrites(void);
1140  int clientHasPendingReplies(client *c);
1141  void unlinkClient(client *c);
1142  int writeToClient(int fd, client *c, int handler_installed);
1143  void linkClient(client *c);
1144  void protectClient(client *c);
1145  void unprotectClient(client *c);
1146  #ifdef __GNUC__
1147  void addReplyErrorFormat(client *c, const char *fmt, ...)
1148      __attribute__((format(printf, 2, 3)));
1149  void addReplyStatusFormat(client *c, const char *fmt, ...)
1150      __attribute__((format(printf, 2, 3)));
1151  #else
1152  void addReplyErrorFormat(client *c, const char *fmt, ...);
1153  void addReplyStatusFormat(client *c, const char *fmt, ...);
1154  #endif
1155  void listTypeTryConversion(robj *subject, robj *value);
1156  void listTypePush(robj *subject, robj *value, int where);
1157  robj *listTypePop(robj *subject, int where);
1158  PORT_ULONG listTypeLength(const robj *subject);
1159  listTypeIterator *listTypeInitIterator(robj *subject, PORT_LONG index, unsigned char direction);
1160  void listTypeReleaseIterator(listTypeIterator *li);
1161  int listTypeNext(listTypeIterator *li, listTypeEntry *entry);
1162  robj *listTypeGet(listTypeEntry *entry);
1163  void listTypeInsert(listTypeEntry *entry, robj *value, int where);
1164  int listTypeEqual(listTypeEntry *entry, robj *o);
1165  void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry);
1166  void listTypeConvert(robj *subject, int enc);
1167  void unblockClientWaitingData(client *c);
1168  void popGenericCommand(client *c, int where);
1169  void unwatchAllKeys(client *c);
1170  void initClientMultiState(client *c);
1171  void freeClientMultiState(client *c);
1172  void queueMultiCommand(client *c);
1173  void touchWatchedKey(redisDb *db, robj *key);
1174  void touchWatchedKeysOnFlush(int dbid);
1175  void discardTransaction(client *c);
1176  void flagTransaction(client *c);
1177  void execCommandPropagateMulti(client *c);
1178  void decrRefCount(robj *o);
1179  void decrRefCountVoid(void *o);
1180  void incrRefCount(robj *o);
1181  robj *makeObjectShared(robj *o);
1182  robj *resetRefCount(robj *obj);
1183  void freeStringObject(robj *o);
1184  void freeListObject(robj *o);
1185  void freeSetObject(robj *o);
1186  void freeZsetObject(robj *o);
1187  void freeHashObject(robj *o);
1188  robj *createObject(int type, void *ptr);
1189  robj *createStringObject(const char *ptr, size_t len);
1190  robj *createRawStringObject(const char *ptr, size_t len);
1191  robj *createEmbeddedStringObject(const char *ptr, size_t len);
1192  robj *dupStringObject(const robj *o);
1193  int isSdsRepresentableAsLongLong(sds s, PORT_LONGLONG *llval);
1194  int isObjectRepresentableAsLongLong(robj *o, PORT_LONGLONG *llongval);
1195  robj *tryObjectEncoding(robj *o);
1196  robj *getDecodedObject(robj *o);
1197  size_t stringObjectLen(robj *o);
1198  robj *createStringObjectFromLongLong(PORT_LONGLONG value);
1199  robj *createStringObjectFromLongLongForValue(PORT_LONGLONG value);
1200  robj *createStringObjectFromLongDouble(PORT_LONGDOUBLE value, int humanfriendly);
1201  robj *createQuicklistObject(void);
1202  robj *createZiplistObject(void);
1203  robj *createSetObject(void);
1204  robj *createIntsetObject(void);
1205  robj *createHashObject(void);
1206  robj *createZsetObject(void);
1207  robj *createZsetZiplistObject(void);
1208  robj *createStreamObject(void);
1209  robj *createModuleObject(moduleType *mt, void *value);
1210  int getLongFromObjectOrReply(client *c, robj *o, PORT_LONG *target, const char *msg);
1211  int checkType(client *c, robj *o, int type);
1212  int getLongLongFromObjectOrReply(client *c, robj *o, PORT_LONGLONG *target, const char *msg);
1213  int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg);
1214  int getDoubleFromObject(const robj *o, double *target);
1215  int getLongLongFromObject(robj *o, PORT_LONGLONG *target);
1216  int getLongDoubleFromObject(robj *o, PORT_LONGDOUBLE *target);
1217  int getLongDoubleFromObjectOrReply(client *c, robj *o, PORT_LONGDOUBLE *target, const char *msg);
1218  char *strEncoding(int encoding);
1219  int compareStringObjects(robj *a, robj *b);
1220  int collateStringObjects(robj *a, robj *b);
1221  int equalStringObjects(robj *a, robj *b);
1222  PORT_ULONGLONG estimateObjectIdleTime(robj *o);
1223  void trimStringObjectIfNeeded(robj *o);
1224  #define sdsEncodedObject(objptr) (objptr->encoding == OBJ_ENCODING_RAW || objptr->encoding == OBJ_ENCODING_EMBSTR)
1225  ssize_t syncWrite(int fd, char *ptr, ssize_t size, PORT_LONGLONG timeout);
1226  ssize_t syncRead(int fd, char *ptr, ssize_t size, PORT_LONGLONG timeout);
1227  ssize_t syncReadLine(int fd, char *ptr, ssize_t size, PORT_LONGLONG timeout);
1228  void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);
1229  void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen);
1230  void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc);
1231  void updateSlavesWaitingBgsave(int bgsaveerr, int type);
1232  void replicationCron(void);
1233  void replicationHandleMasterDisconnection(void);
1234  void replicationCacheMaster(client *c);
1235  void resizeReplicationBacklog(PORT_LONGLONG newsize);
1236  void replicationSetMaster(char *ip, int port);
1237  void replicationUnsetMaster(void);
1238  void refreshGoodSlavesCount(void);
1239  void replicationScriptCacheInit(void);
1240  void replicationScriptCacheFlush(void);
1241  void replicationScriptCacheAdd(sds sha1);
1242  int replicationScriptCacheExists(sds sha1);
1243  void processClientsWaitingReplicas(void);
1244  void unblockClientWaitingReplicas(client *c);
1245  int replicationCountAcksByOffset(PORT_LONGLONG offset);
1246  void replicationSendNewlineToMaster(void);
1247  PORT_LONGLONG replicationGetSlaveOffset(void);
1248  char *replicationGetSlaveName(client *c);
1249  PORT_LONGLONG getPsyncInitialOffset(void);
1250  int replicationSetupSlaveForFullResync(client *slave, PORT_LONGLONG offset);
1251  void changeReplicationId(void);
1252  void clearReplicationId2(void);
1253  void chopReplicationBacklog(void);
1254  void replicationCacheMasterUsingMyself(void);
1255  void feedReplicationBacklog(void *ptr, size_t len);
1256  void startLoading(FILE *fp);
1257  void loadingProgress(off_t pos);
1258  void stopLoading(void);
1259  #define DISK_ERROR_TYPE_AOF 1       &bsol;* Don't accept writes: AOF errors. */
1260  #define DISK_ERROR_TYPE_RDB 2       &bsol;* Don't accept writes: RDB errors. */
1261  #define DISK_ERROR_TYPE_NONE 0      &bsol;* No problems, we can accept writes. */
1262  int writeCommandsDeniedByDiskError(void);
1263  #include "rdb.h"
1264  int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi);
1265  void flushAppendOnlyFile(int force);
1266  void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc);
1267  void aofRemoveTempFile(pid_t childpid);
1268  int rewriteAppendOnlyFileBackground(void);
1269  int loadAppendOnlyFile(char *filename);
1270  void stopAppendOnly(void);
1271  int startAppendOnly(void);
1272  void backgroundRewriteDoneHandler(int exitcode, int bysignal);
1273  void aofRewriteBufferReset(void);
1274  PORT_ULONG aofRewriteBufferSize(void);
1275  WIN32_ONLY(void aofProcessDiffRewriteEvents(aeEventLoop* eventLoop);)
1276  ssize_t aofReadDiffFromParent(void);
1277  void openChildInfoPipe(void);
1278  void closeChildInfoPipe(void);
1279  void sendChildInfo(int process_type);
1280  void receiveChildInfo(void);
1281  int hasActiveChildProcess();
1282  #define ZADD_NONE 0
1283  #define ZADD_INCR (1<<0)    &bsol;* Increment the score instead of setting it. */
1284  #define ZADD_NX (1<<1)      &bsol;* Don't touch elements not already existing. */
1285  #define ZADD_XX (1<<2)      &bsol;* Only touch elements already existing. */
1286  #define ZADD_NOP (1<<3)     &bsol;* Operation not performed because of conditionals.*/
1287  #define ZADD_NAN (1<<4)     &bsol;* Only touch elements already existing. */
1288  #define ZADD_ADDED (1<<5)   &bsol;* The element was new and was added. */
1289  #define ZADD_UPDATED (1<<6) &bsol;* The element already existed, score updated. */
1290  #define ZADD_CH (1<<16)      &bsol;* Return num of elements added or updated. */
1291  typedef struct {
1292      double min, max;
1293      int minex, maxex; &bsol;* are min or max exclusive? */
1294  } zrangespec;
1295  typedef struct {
1296      sds min, max;     &bsol;* May be set to shared.(minstring|maxstring) */
1297      int minex, maxex; &bsol;* are min or max exclusive? */
1298  } zlexrangespec;
1299  zskiplist *zslCreate(void);
1300  void zslFree(zskiplist *zsl);
1301  zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);
1302  unsigned char *zzlInsert(unsigned char *zl, sds ele, double score);
1303  int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);
1304  zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);
1305  zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);
1306  double zzlGetScore(unsigned char *sptr);
1307  void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);
1308  void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);
1309  unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);
1310  unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);
1311  PORT_ULONG zsetLength(const robj *zobj);
1312  void zsetConvert(robj *zobj, int encoding);
1313  void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);
1314  int zsetScore(robj *zobj, sds member, double *score);
1315  PORT_ULONG zslGetRank(zskiplist *zsl, double score, sds o);
1316  int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);
1317  PORT_LONG zsetRank(robj *zobj, sds ele, int reverse);
1318  int zsetDel(robj *zobj, sds ele);
1319  void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, robj *countarg);
1320  sds ziplistGetObject(unsigned char *sptr);
1321  int zslValueGteMin(double value, zrangespec *spec);
1322  int zslValueLteMax(double value, zrangespec *spec);
1323  void zslFreeLexRange(zlexrangespec *spec);
1324  int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec);
1325  unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range);
1326  unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range);
1327  zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range);
1328  zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);
1329  int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec);
1330  int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec);
1331  int zslLexValueGteMin(sds value, zlexrangespec *spec);
1332  int zslLexValueLteMax(sds value, zlexrangespec *spec);
1333  int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level);
1334  size_t freeMemoryGetNotCountedMemory();
1335  int freeMemoryIfNeeded(void);
1336  int freeMemoryIfNeededAndSafe(void);
1337  int processCommand(client *c);
1338  void setupSignalHandlers(void);
1339  struct redisCommand *lookupCommand(sds name);
1340  struct redisCommand *lookupCommandByCString(char *s);
1341  struct redisCommand *lookupCommandOrOriginal(sds name);
1342  void call(client *c, int flags);
1343  void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags);
1344  void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target);
1345  void redisOpArrayInit(redisOpArray *oa);
1346  void redisOpArrayFree(redisOpArray *oa);
1347  void forceCommandPropagation(client *c, int flags);
1348  void preventCommandPropagation(client *c);
1349  void preventCommandAOF(client *c);
1350  void preventCommandReplication(client *c);
1351  int prepareForShutdown();
1352  #ifdef __GNUC__
1353  void serverLog(int level, const char *fmt, ...)
1354      __attribute__((format(printf, 2, 3)));
1355  #else
1356  void serverLog(int level, const char *fmt, ...);
1357  #endif
1358  void serverLogRaw(int level, const char *msg);
1359  void serverLogFromHandler(int level, const char *msg);
1360  void usage(void);
1361  void updateDictResizePolicy(void);
1362  int htNeedsResize(dict *dict);
1363  void populateCommandTable(void);
1364  void resetCommandTableStats(void);
1365  void adjustOpenFilesLimit(void);
1366  void closeListeningSockets(int unlink_unix_socket);
1367  void updateCachedTime(int update_daylight_info);
1368  void resetServerStats(void);
1369  void activeDefragCycle(void);
1370  unsigned int getLRUClock(void);
1371  unsigned int LRU_CLOCK(void);
1372  const char *evictPolicyToString(void);
1373  struct redisMemOverhead *getMemoryOverheadData(void);
1374  void freeMemoryOverheadData(struct redisMemOverhead *mh);
1375  #define RESTART_SERVER_NONE 0
1376  #define RESTART_SERVER_GRACEFULLY (1<<0)     &bsol;* Do proper shutdown. */
1377  #define RESTART_SERVER_CONFIG_REWRITE (1<<1) &bsol;* CONFIG REWRITE before restart.*/
1378  int restartServer(int flags, mstime_t delay);
1379  robj *setTypeCreate(sds value);
1380  int setTypeAdd(robj *subject, sds value);
1381  int setTypeRemove(robj *subject, sds value);
1382  int setTypeIsMember(robj *subject, sds value);
1383  setTypeIterator *setTypeInitIterator(robj *subject);
1384  void setTypeReleaseIterator(setTypeIterator *si);
1385  int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele);
1386  sds setTypeNextObject(setTypeIterator *si);
1387  int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele);
1388  PORT_ULONG setTypeRandomElements(robj *set, PORT_ULONG count, robj *aux_set);
1389  PORT_ULONG setTypeSize(const robj *subject);
1390  void setTypeConvert(robj *subject, int enc);
1391  #define HASH_SET_TAKE_FIELD (1<<0)
1392  #define HASH_SET_TAKE_VALUE (1<<1)
1393  #define HASH_SET_COPY 0
1394  void hashTypeConvert(robj *o, int enc);
1395  void hashTypeTryConversion(robj *subject, robj **argv, int start, int end);
1396  void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2);
1397  int hashTypeExists(robj *o, sds key);
1398  int hashTypeDelete(robj *o, sds key);
1399  PORT_ULONG hashTypeLength(const robj *o);
1400  hashTypeIterator *hashTypeInitIterator(robj *subject);
1401  void hashTypeReleaseIterator(hashTypeIterator *hi);
1402  int hashTypeNext(hashTypeIterator *hi);
1403  void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,
1404                                  unsigned char **vstr,
1405                                  unsigned int *vlen,
1406                                  PORT_LONGLONG *vll);
1407  sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what);
1408  void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, PORT_LONGLONG *vll);
1409  sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what);
1410  robj *hashTypeLookupWriteOrCreate(client *c, robj *key);
1411  robj *hashTypeGetValueObject(robj *o, sds field);
1412  int hashTypeSet(robj *o, sds field, sds value, int flags);
1413  int pubsubUnsubscribeAllChannels(client *c, int notify);
1414  int pubsubUnsubscribeAllPatterns(client *c, int notify);
1415  void freePubsubPattern(void *p);
1416  int listMatchPubsubPattern(void *a, void *b);
1417  int pubsubPublishMessage(robj *channel, robj *message);
1418  void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);
1419  int keyspaceEventsStringToFlags(char *classes);
1420  sds keyspaceEventsFlagsToString(int flags);
1421  void loadServerConfig(char *filename, char *options);
1422  void appendServerSaveParams(time_t seconds, int changes);
1423  void resetServerSaveParams(void);
1424  struct rewriteConfigState; &bsol;* Forward declaration to export API. */
1425  void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force);
1426  int rewriteConfig(char *path);
1427  int removeExpire(redisDb *db, robj *key);
1428  void propagateExpire(redisDb *db, robj *key, int lazy);
1429  int expireIfNeeded(redisDb *db, robj *key);
1430  PORT_LONGLONG getExpire(redisDb *db, robj *key);
1431  void setExpire(client *c, redisDb *db, robj *key, PORT_LONGLONG when);
1432  int checkAlreadyExpired(PORT_LONGLONG when);
1433  #ifdef _WIN32
1434  time_t getExpireForSave(redisDb *db, robj *key);
1435  #endif
1436  robj *lookupKey(redisDb *db, robj *key, int flags);
1437  robj *lookupKeyRead(redisDb *db, robj *key);
1438  robj *lookupKeyWrite(redisDb *db, robj *key);
1439  robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply);
1440  robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply);
1441  robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags);
1442  robj *objectCommandLookup(client *c, robj *key);
1443  robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply);
1444  void objectSetLRUOrLFU(robj *val, PORT_LONGLONG lfu_freq, PORT_LONGLONG lru_idle,
1445                         PORT_LONGLONG lru_clock);
1446  #define LOOKUP_NONE 0
1447  #define LOOKUP_NOTOUCH (1<<0)
1448  void dbAdd(redisDb *db, robj *key, robj *val);
1449  void dbOverwrite(redisDb *db, robj *key, robj *val);
1450  void setKey(redisDb *db, robj *key, robj *val);
1451  int dbExists(redisDb *db, robj *key);
1452  robj *dbRandomKey(redisDb *db);
1453  int dbSyncDelete(redisDb *db, robj *key);
1454  int dbDelete(redisDb *db, robj *key);
1455  robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);
1456  #define EMPTYDB_NO_FLAGS 0      &bsol;* No flags. */
1457  #define EMPTYDB_ASYNC (1<<0)    &bsol;* Reclaim memory in another thread. */
1458  PORT_LONGLONG emptyDb(int dbnum, int flags, void(callback)(void*));
1459  int selectDb(client *c, int id);
1460  void signalModifiedKey(redisDb *db, robj *key);
1461  void signalFlushedDb(int dbid);
1462  unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);
1463  unsigned int countKeysInSlot(unsigned int hashslot);
1464  unsigned int delKeysInSlot(unsigned int hashslot);
1465  int verifyClusterConfigWithData(void);
1466  void scanGenericCommand(client *c, robj *o, PORT_ULONG cursor);
1467  int parseScanCursorOrReply(client *c, robj *o, PORT_ULONG *cursor);
1468  void slotToKeyAdd(robj *key);
1469  void slotToKeyDel(robj *key);
1470  void slotToKeyFlush(void);
1471  int dbAsyncDelete(redisDb *db, robj *key);
1472  void emptyDbAsync(redisDb *db);
1473  void slotToKeyFlushAsync(void);
1474  size_t lazyfreeGetPendingObjectsCount(void);
1475  void freeObjAsync(robj *o);
1476  int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
1477  void getKeysFreeResult(int *result);
1478  int *zunionInterGetKeys(struct redisCommand *cmd,robj **argv, int argc, int *numkeys);
1479  int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
1480  int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
1481  int *migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
1482  int *georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
1483  int *xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
1484  void clusterInit(void);
1485  unsigned short crc16(const char *buf, int len);
1486  unsigned int keyHashSlot(char *key, int keylen);
1487  void clusterCron(void);
1488  void clusterPropagatePublish(robj *channel, robj *message);
1489  void migrateCloseTimedoutSockets(void);
1490  void clusterBeforeSleep(void);
1491  int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, unsigned char *payload, uint32_t len);
1492  void initSentinelConfig(void);
1493  void initSentinel(void);
1494  void sentinelTimer(void);
1495  char *sentinelHandleConfiguration(char **argv, int argc);
1496  void sentinelIsRunning(void);
1497  int redis_check_rdb(char *rdbfilename, FILE *fp);
1498  int redis_check_rdb_main(int argc, char **argv, FILE *fp);
1499  int redis_check_aof_main(int argc, char **argv);
1500  void scriptingInit(int setup);
1501  int ldbRemoveChild(pid_t pid);
1502  void ldbKillForkedSessions(void);
1503  int ldbPendingChildren(void);
1504  sds luaCreateFunction(client *c, lua_State *lua, robj *body);
1505  void processUnblockedClients(void);
1506  void blockClient(client *c, int btype);
1507  void unblockClient(client *c);
1508  void queueClientForReprocessing(client *c);
1509  void replyToBlockedClientTimedOut(client *c);
1510  int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit);
1511  void disconnectAllBlockedClients(void);
1512  void handleClientsBlockedOnKeys(void);
1513  void signalKeyAsReady(redisDb *db, robj *key);
1514  void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, robj *target, streamID *ids);
1515  void activeExpireCycle(int type);
1516  void expireSlaveKeys(void);
1517  void rememberSlaveKeyWithExpire(redisDb *db, robj *key);
1518  void flushSlaveKeysWithExpireList(void);
1519  size_t getSlaveKeyWithExpireCount(void);
1520  void evictionPoolAlloc(void);
1521  #define LFU_INIT_VAL 5
1522  PORT_ULONG LFUGetTimeInMinutes(void);
1523  uint8_t LFULogIncr(uint8_t value);
1524  PORT_ULONG LFUDecrAndReturn(robj *o);
1525  uint64_t dictSdsHash(const void *key);
1526  int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
1527  void dictSdsDestructor(void *privdata, void *val);
1528  char *redisGitSHA1(void);
1529  char *redisGitDirty(void);
1530  uint64_t redisBuildId(void);
1531  void authCommand(client *c);
1532  void pingCommand(client *c);
1533  void echoCommand(client *c);
1534  void commandCommand(client *c);
1535  void setCommand(client *c);
1536  void setnxCommand(client *c);
1537  void setexCommand(client *c);
1538  void psetexCommand(client *c);
1539  void getCommand(client *c);
1540  void delCommand(client *c);
1541  void unlinkCommand(client *c);
1542  void existsCommand(client *c);
1543  void setbitCommand(client *c);
1544  void getbitCommand(client *c);
1545  void bitfieldCommand(client *c);
1546  void setrangeCommand(client *c);
1547  void getrangeCommand(client *c);
1548  void incrCommand(client *c);
1549  void decrCommand(client *c);
1550  void incrbyCommand(client *c);
1551  void decrbyCommand(client *c);
1552  void incrbyfloatCommand(client *c);
1553  void selectCommand(client *c);
1554  void swapdbCommand(client *c);
1555  void randomkeyCommand(client *c);
1556  void keysCommand(client *c);
1557  void scanCommand(client *c);
1558  void dbsizeCommand(client *c);
1559  void lastsaveCommand(client *c);
1560  void saveCommand(client *c);
1561  void bgsaveCommand(client *c);
1562  void bgrewriteaofCommand(client *c);
1563  void shutdownCommand(client *c);
1564  void moveCommand(client *c);
1565  void renameCommand(client *c);
1566  void renamenxCommand(client *c);
1567  void lpushCommand(client *c);
1568  void rpushCommand(client *c);
1569  void lpushxCommand(client *c);
1570  void rpushxCommand(client *c);
1571  void linsertCommand(client *c);
1572  void lpopCommand(client *c);
1573  void rpopCommand(client *c);
1574  void llenCommand(client *c);
1575  void lindexCommand(client *c);
1576  void lrangeCommand(client *c);
1577  void ltrimCommand(client *c);
1578  void typeCommand(client *c);
1579  void lsetCommand(client *c);
1580  void saddCommand(client *c);
1581  void sremCommand(client *c);
1582  void smoveCommand(client *c);
1583  void sismemberCommand(client *c);
1584  void scardCommand(client *c);
1585  void spopCommand(client *c);
1586  void srandmemberCommand(client *c);
1587  void sinterCommand(client *c);
1588  void sinterstoreCommand(client *c);
1589  void sunionCommand(client *c);
1590  void sunionstoreCommand(client *c);
1591  void sdiffCommand(client *c);
1592  void sdiffstoreCommand(client *c);
1593  void sscanCommand(client *c);
1594  void syncCommand(client *c);
1595  void flushdbCommand(client *c);
1596  void flushallCommand(client *c);
1597  void sortCommand(client *c);
1598  void lremCommand(client *c);
1599  void rpoplpushCommand(client *c);
1600  void infoCommand(client *c);
1601  void mgetCommand(client *c);
1602  void monitorCommand(client *c);
1603  void expireCommand(client *c);
1604  void expireatCommand(client *c);
1605  void pexpireCommand(client *c);
1606  void pexpireatCommand(client *c);
1607  void getsetCommand(client *c);
1608  void ttlCommand(client *c);
1609  void touchCommand(client *c);
1610  void pttlCommand(client *c);
1611  void persistCommand(client *c);
1612  void replicaofCommand(client *c);
1613  void roleCommand(client *c);
1614  void debugCommand(client *c);
1615  void msetCommand(client *c);
1616  void msetnxCommand(client *c);
1617  void zaddCommand(client *c);
1618  void zincrbyCommand(client *c);
1619  void zrangeCommand(client *c);
1620  void zrangebyscoreCommand(client *c);
1621  void zrevrangebyscoreCommand(client *c);
1622  void zrangebylexCommand(client *c);
1623  void zrevrangebylexCommand(client *c);
1624  void zcountCommand(client *c);
1625  void zlexcountCommand(client *c);
1626  void zrevrangeCommand(client *c);
1627  void zcardCommand(client *c);
1628  void zremCommand(client *c);
1629  void zscoreCommand(client *c);
1630  void zremrangebyscoreCommand(client *c);
1631  void zremrangebylexCommand(client *c);
1632  void zpopminCommand(client *c);
1633  void zpopmaxCommand(client *c);
1634  void bzpopminCommand(client *c);
1635  void bzpopmaxCommand(client *c);
1636  void multiCommand(client *c);
1637  void execCommand(client *c);
1638  void discardCommand(client *c);
1639  void blpopCommand(client *c);
1640  void brpopCommand(client *c);
1641  void brpoplpushCommand(client *c);
1642  void appendCommand(client *c);
1643  void strlenCommand(client *c);
1644  void zrankCommand(client *c);
1645  void zrevrankCommand(client *c);
1646  void hsetCommand(client *c);
1647  void hsetnxCommand(client *c);
1648  void hgetCommand(client *c);
1649  void hmsetCommand(client *c);
1650  void hmgetCommand(client *c);
1651  void hdelCommand(client *c);
1652  void hlenCommand(client *c);
1653  void hstrlenCommand(client *c);
1654  void zremrangebyrankCommand(client *c);
1655  void zunionstoreCommand(client *c);
1656  void zinterstoreCommand(client *c);
1657  void zscanCommand(client *c);
1658  void hkeysCommand(client *c);
1659  void hvalsCommand(client *c);
1660  void hgetallCommand(client *c);
1661  void hexistsCommand(client *c);
1662  void hscanCommand(client *c);
1663  void configCommand(client *c);
1664  void hincrbyCommand(client *c);
1665  void hincrbyfloatCommand(client *c);
1666  void subscribeCommand(client *c);
1667  void unsubscribeCommand(client *c);
1668  void psubscribeCommand(client *c);
1669  void punsubscribeCommand(client *c);
1670  void publishCommand(client *c);
1671  void pubsubCommand(client *c);
1672  void watchCommand(client *c);
1673  void unwatchCommand(client *c);
1674  void clusterCommand(client *c);
1675  void restoreCommand(client *c);
1676  void migrateCommand(client *c);
1677  void askingCommand(client *c);
1678  void readonlyCommand(client *c);
1679  void readwriteCommand(client *c);
1680  void dumpCommand(client *c);
1681  void objectCommand(client *c);
1682  void memoryCommand(client *c);
1683  void clientCommand(client *c);
1684  void evalCommand(client *c);
1685  void evalShaCommand(client *c);
1686  void scriptCommand(client *c);
1687  void timeCommand(client *c);
1688  void bitopCommand(client *c);
1689  void bitcountCommand(client *c);
1690  void bitposCommand(client *c);
1691  void replconfCommand(client *c);
1692  void waitCommand(client *c);
1693  void geoencodeCommand(client *c);
1694  void geodecodeCommand(client *c);
1695  void georadiusbymemberCommand(client *c);
1696  void georadiusbymemberroCommand(client *c);
1697  void georadiusCommand(client *c);
1698  void georadiusroCommand(client *c);
1699  void geoaddCommand(client *c);
1700  void geohashCommand(client *c);
1701  void geoposCommand(client *c);
1702  void geodistCommand(client *c);
1703  void pfselftestCommand(client *c);
1704  void pfaddCommand(client *c);
1705  void pfcountCommand(client *c);
1706  void pfmergeCommand(client *c);
1707  void pfdebugCommand(client *c);
1708  void latencyCommand(client *c);
1709  void moduleCommand(client *c);
1710  void securityWarningCommand(client *c);
1711  void xaddCommand(client *c);
1712  void xrangeCommand(client *c);
1713  void xrevrangeCommand(client *c);
1714  void xlenCommand(client *c);
1715  void xreadCommand(client *c);
1716  void xgroupCommand(client *c);
1717  void xsetidCommand(client *c);
1718  void xackCommand(client *c);
1719  void xpendingCommand(client *c);
1720  void xclaimCommand(client *c);
1721  void xinfoCommand(client *c);
1722  void xdelCommand(client *c);
1723  void xtrimCommand(client *c);
1724  void lolwutCommand(client *c);
1725  #if defined(__GNUC__)
1726  void *calloc(size_t count, size_t size) __attribute__ ((deprecated));
1727  void free(void *ptr) __attribute__ ((deprecated));
1728  void *malloc(size_t size) __attribute__ ((deprecated));
1729  void *realloc(void *ptr, size_t size) __attribute__ ((deprecated));
1730  #endif
1731  void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line);
1732  void _serverAssert(const char *estr, const char *file, int line);
1733  void _serverPanic(const char *file, int line, const char *msg, ...);
1734  void bugReportStart(void);
1735  void serverLogObjectDebugInfo(const robj *o);
1736  POSIX_ONLY(void sigsegvHandler(int sig, siginfo_t *info, void *secret);)
1737  sds genRedisInfoString(char *section);
1738  void enableWatchdog(int period);
1739  void disableWatchdog(void);
1740  void watchdogScheduleSignal(int period);
1741  void serverLogHexDump(int level, char *descr, void *value, size_t len);
1742  int memtest_preserving_test(PORT_ULONG *m, size_t bytes, int passes);
1743  void mixDigest(unsigned char *digest, void *ptr, size_t len);
1744  void xorDigest(unsigned char *digest, void *ptr, size_t len);
1745  #define redisDebug(fmt, ...) \
1746      printf("DEBUG %s:%d > " fmt "\n", __FILE__, __LINE__, __VA_ARGS__)
1747  #define redisDebugMark() \
1748      printf("-- MARK %s:%d --\n", __FILE__, __LINE__)
1749  #ifdef _WIN32
1750  extern pthread_mutex_t lazyfree_objects_mutex;
1751  extern pthread_mutex_t used_memory_mutex;
1752  extern pthread_mutex_t moduleUnblockedClientsMutex;
1753  extern pthread_mutex_t moduleGIL;
1754  #endif
1755  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-vda.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-server.h</div>
                </div>
                <div class="column column_space"><pre><code>17      int                 use_sync_decoding;
18      int                 width;
19      int                 height;
20      int                 format;
21      OSType              cv_pix_fmt_type;
22      uint8_t             *priv_bitstream;
</pre></code></div>
                <div class="column column_space"><pre><code>907      int sort_desc;
908      int sort_alpha;
909      int sort_bypattern;
910      int sort_store;
911      size_t hash_max_ziplist_entries;
912      size_t hash_max_ziplist_value;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    