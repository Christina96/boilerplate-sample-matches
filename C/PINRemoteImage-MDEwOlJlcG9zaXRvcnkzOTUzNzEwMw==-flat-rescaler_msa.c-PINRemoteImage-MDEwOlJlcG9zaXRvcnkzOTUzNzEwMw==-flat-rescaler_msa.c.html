
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 88, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_msa.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MSA) && !defined(WEBP_REDUCE_SIZE)
3  #include <assert.h>
4  #include "src/utils/rescaler_utils.h"
5  #include "src/dsp/msa_macro.h"
6  #define ROUNDER (WEBP_RESCALER_ONE >> 1)
7  #define MULT_FIX(x, y) (((uint64_t)(x) * (y) + ROUNDER) >> WEBP_RESCALER_RFIX)
8  #define MULT_FIX_FLOOR(x, y) (((uint64_t)(x) * (y)) >> WEBP_RESCALER_RFIX)
9  #define CALC_MULT_FIX_16(in0, in1, in2, in3, scale, shift, dst) do {  \
10    v4u32 tmp0, tmp1, tmp2, tmp3;                                       \
11    v16u8 t0, t1, t2, t3, t4, t5;                                       \
12    v2u64 out0, out1, out2, out3;                                       \
13    ILVRL_W2_UW(zero, in0, tmp0, tmp1);                                 \
14    ILVRL_W2_UW(zero, in1, tmp2, tmp3);                                 \
15    DOTP_UW2_UD(tmp0, tmp1, scale, scale, out0, out1);                  \
16    DOTP_UW2_UD(tmp2, tmp3, scale, scale, out2, out3);                  \
17    SRAR_D4_UD(out0, out1, out2, out3, shift);                          \
18    PCKEV_B2_UB(out1, out0, out3, out2, t0, t1);                        \
19    ILVRL_W2_UW(zero, in2, tmp0, tmp1);                                 \
20    ILVRL_W2_UW(zero, in3, tmp2, tmp3);                                 \
21    DOTP_UW2_UD(tmp0, tmp1, scale, scale, out0, out1);                  \
22    DOTP_UW2_UD(tmp2, tmp3, scale, scale, out2, out3);                  \
23    SRAR_D4_UD(out0, out1, out2, out3, shift);                          \
24    PCKEV_B2_UB(out1, out0, out3, out2, t2, t3);                        \
25    PCKEV_B2_UB(t1, t0, t3, t2, t4, t5);                                \
26    dst = (v16u8)__msa_pckev_b((v16i8)t5, (v16i8)t4);                   \
27  } while (0)
28  #define CALC_MULT_FIX_4(in0, scale, shift, dst) do {  \
29    v4u32 tmp0, tmp1;                                   \
30    v16i8 t0, t1;                                       \
31    v2u64 out0, out1;                                   \
32    ILVRL_W2_UW(zero, in0, tmp0, tmp1);                 \
33    DOTP_UW2_UD(tmp0, tmp1, scale, scale, out0, out1);  \
34    SRAR_D2_UD(out0, out1, shift);                      \
35    t0 = __msa_pckev_b((v16i8)out1, (v16i8)out0);       \
36    t1 = __msa_pckev_b(t0, t0);                         \
37    t0 = __msa_pckev_b(t1, t1);                         \
38    dst = __msa_copy_s_w((v4i32)t0, 0);                 \
39  } while (0)
40  #define CALC_MULT_FIX1_16(in0, in1, in2, in3, fyscale, shift,  \
41                            dst0, dst1, dst2, dst3) do {         \
42    v4u32 tmp0, tmp1, tmp2, tmp3;                                \
43    v2u64 out0, out1, out2, out3;                                \
44    ILVRL_W2_UW(zero, in0, tmp0, tmp1);                          \
45    ILVRL_W2_UW(zero, in1, tmp2, tmp3);                          \
46    DOTP_UW2_UD(tmp0, tmp1, fyscale, fyscale, out0, out1);       \
47    DOTP_UW2_UD(tmp2, tmp3, fyscale, fyscale, out2, out3);       \
48    SRAR_D4_UD(out0, out1, out2, out3, shift);                   \
49    PCKEV_W2_UW(out1, out0, out3, out2, dst0, dst1);             \
50    ILVRL_W2_UW(zero, in2, tmp0, tmp1);                          \
51    ILVRL_W2_UW(zero, in3, tmp2, tmp3);                          \
52    DOTP_UW2_UD(tmp0, tmp1, fyscale, fyscale, out0, out1);       \
53    DOTP_UW2_UD(tmp2, tmp3, fyscale, fyscale, out2, out3);       \
54    SRAR_D4_UD(out0, out1, out2, out3, shift);                   \
55    PCKEV_W2_UW(out1, out0, out3, out2, dst2, dst3);             \
56  } while (0)
57  #define CALC_MULT_FIX1_4(in0, scale, shift, dst) do {    \
58    v4u32 tmp0, tmp1;                                      \
59    v2u64 out0, out1;                                      \
60    ILVRL_W2_UW(zero, in0, tmp0, tmp1);                    \
61    DOTP_UW2_UD(tmp0, tmp1, scale, scale, out0, out1);     \
62    SRAR_D2_UD(out0, out1, shift);                         \
63    dst = (v4u32)__msa_pckev_w((v4i32)out1, (v4i32)out0);  \
64  } while (0)
65  #define CALC_MULT_FIX2_16(in0, in1, in2, in3, mult, scale, shift,  \
66                            dst0, dst1) do {                         \
67    v4u32 tmp0, tmp1, tmp2, tmp3;                                    \
68    v2u64 out0, out1, out2, out3;                                    \
69    ILVRL_W2_UW(in0, in2, tmp0, tmp1);                               \
70    ILVRL_W2_UW(in1, in3, tmp2, tmp3);                               \
71    DOTP_UW2_UD(tmp0, tmp1, mult, mult, out0, out1);                 \
72    DOTP_UW2_UD(tmp2, tmp3, mult, mult, out2, out3);                 \
73    SRAR_D4_UD(out0, out1, out2, out3, shift);                       \
74    DOTP_UW2_UD(out0, out1, scale, scale, out0, out1);               \
75    DOTP_UW2_UD(out2, out3, scale, scale, out2, out3);               \
76    SRAR_D4_UD(out0, out1, out2, out3, shift);                       \
77    PCKEV_B2_UB(out1, out0, out3, out2, dst0, dst1);                 \
78  } while (0)
79  #define CALC_MULT_FIX2_4(in0, in1, mult, scale, shift, dst) do {  \
80    v4u32 tmp0, tmp1;                                               \
81    v2u64 out0, out1;                                               \
82    v16i8 t0, t1;                                                   \
83    ILVRL_W2_UW(in0, in1, tmp0, tmp1);                              \
84    DOTP_UW2_UD(tmp0, tmp1, mult, mult, out0, out1);                \
85    SRAR_D2_UD(out0, out1, shift);                                  \
86    DOTP_UW2_UD(out0, out1, scale, scale, out0, out1);              \
87    SRAR_D2_UD(out0, out1, shift);                                  \
88    t0 = __msa_pckev_b((v16i8)out1, (v16i8)out0);                   \
89    t1 = __msa_pckev_b(t0, t0);                                     \
90    t0 = __msa_pckev_b(t1, t1);                                     \
91    dst = __msa_copy_s_w((v4i32)t0, 0);                             \
92  } while (0)
93  static WEBP_INLINE void ExportRowExpand_0(const uint32_t* frow, uint8_t* dst,
94                                            int length,
95                                            WebPRescaler* const wrk) {
96    const v4u32 scale = (v4u32)__msa_fill_w(wrk->fy_scale);
97    const v4u32 shift = (v4u32)__msa_fill_w(WEBP_RESCALER_RFIX);
98    const v4i32 zero = { 0 };
99    while (length >= 16) {
100      v4u32 src0, src1, src2, src3;
101      v16u8 out;
102      LD_UW4(frow, 4, src0, src1, src2, src3);
103      CALC_MULT_FIX_16(src0, src1, src2, src3, scale, shift, out);
104      ST_UB(out, dst);
105      length -= 16;
106      frow   += 16;
107      dst    += 16;
108    }
109    if (length > 0) {
110      int x_out;
111      if (length >= 12) {
112        uint32_t val0_m, val1_m, val2_m;
113        v4u32 src0, src1, src2;
114        LD_UW3(frow, 4, src0, src1, src2);
115        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
116        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
117        CALC_MULT_FIX_4(src2, scale, shift, val2_m);
<span onclick='openModal()' class='match'>118        SW3(val0_m, val1_m, val2_m, dst, 4);
119        length -= 12;
120        frow   += 12;
121        dst    += 12;
122      } else if (length >= 8) {
123        uint32_t val0_m, val1_m;
124        v4u32 src0, src1;
125        LD_UW2(frow, 4, src0, src1);
126        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
127        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
128        SW2(val0_m, val1_m, dst, 4);
129        length -= 8;
</span>130        frow   += 8;
131        dst    += 8;
132      } else if (length >= 4) {
133        uint32_t val0_m;
134        const v4u32 src0 = LD_UW(frow);
135        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
136        SW(val0_m, dst);
137        length -= 4;
138        frow   += 4;
139        dst    += 4;
140      }
141      for (x_out = 0; x_out < length; ++x_out) {
142        const uint32_t J = frow[x_out];
143        const int v = (int)MULT_FIX(J, wrk->fy_scale);
144        dst[x_out] = (v > 255) ? 255u : (uint8_t)v;
145      }
146    }
147  }
148  static WEBP_INLINE void ExportRowExpand_1(const uint32_t* frow, uint32_t* irow,
149                                            uint8_t* dst, int length,
150                                            WebPRescaler* const wrk) {
151    const uint32_t B = WEBP_RESCALER_FRAC(-wrk->y_accum, wrk->y_sub);
152    const uint32_t A = (uint32_t)(WEBP_RESCALER_ONE - B);
153    const v4i32 B1 = __msa_fill_w(B);
154    const v4i32 A1 = __msa_fill_w(A);
155    const v4i32 AB = __msa_ilvr_w(A1, B1);
156    const v4u32 scale = (v4u32)__msa_fill_w(wrk->fy_scale);
157    const v4u32 shift = (v4u32)__msa_fill_w(WEBP_RESCALER_RFIX);
158    while (length >= 16) {
159      v4u32 frow0, frow1, frow2, frow3, irow0, irow1, irow2, irow3;
160      v16u8 t0, t1, t2, t3, t4, t5;
161      LD_UW4(frow, 4, frow0, frow1, frow2, frow3);
162      LD_UW4(irow, 4, irow0, irow1, irow2, irow3);
163      CALC_MULT_FIX2_16(frow0, frow1, irow0, irow1, AB, scale, shift, t0, t1);
164      CALC_MULT_FIX2_16(frow2, frow3, irow2, irow3, AB, scale, shift, t2, t3);
165      PCKEV_B2_UB(t1, t0, t3, t2, t4, t5);
166      t0 = (v16u8)__msa_pckev_b((v16i8)t5, (v16i8)t4);
167      ST_UB(t0, dst);
168      frow   += 16;
169      irow   += 16;
170      dst    += 16;
171      length -= 16;
172    }
173    if (length > 0) {
174      int x_out;
175      if (length >= 12) {
176        uint32_t val0_m, val1_m, val2_m;
177        v4u32 frow0, frow1, frow2, irow0, irow1, irow2;
178        LD_UW3(frow, 4, frow0, frow1, frow2);
179        LD_UW3(irow, 4, irow0, irow1, irow2);
180        CALC_MULT_FIX2_4(frow0, irow0, AB, scale, shift, val0_m);
181        CALC_MULT_FIX2_4(frow1, irow1, AB, scale, shift, val1_m);
182        CALC_MULT_FIX2_4(frow2, irow2, AB, scale, shift, val2_m);
183        SW3(val0_m, val1_m, val2_m, dst, 4);
184        frow   += 12;
185        irow   += 12;
186        dst    += 12;
187        length -= 12;
188      } else if (length >= 8) {
189        uint32_t val0_m, val1_m;
190        v4u32 frow0, frow1, irow0, irow1;
191        LD_UW2(frow, 4, frow0, frow1);
192        LD_UW2(irow, 4, irow0, irow1);
193        CALC_MULT_FIX2_4(frow0, irow0, AB, scale, shift, val0_m);
194        CALC_MULT_FIX2_4(frow1, irow1, AB, scale, shift, val1_m);
195        SW2(val0_m, val1_m, dst, 4);
196        frow   += 4;
197        irow   += 4;
198        dst    += 4;
199        length -= 4;
200      } else if (length >= 4) {
201        uint32_t val0_m;
202        const v4u32 frow0 = LD_UW(frow + 0);
203        const v4u32 irow0 = LD_UW(irow + 0);
204        CALC_MULT_FIX2_4(frow0, irow0, AB, scale, shift, val0_m);
205        SW(val0_m, dst);
206        frow   += 4;
207        irow   += 4;
208        dst    += 4;
209        length -= 4;
210      }
211      for (x_out = 0; x_out < length; ++x_out) {
212        const uint64_t I = (uint64_t)A * frow[x_out]
213                         + (uint64_t)B * irow[x_out];
214        const uint32_t J = (uint32_t)((I + ROUNDER) >> WEBP_RESCALER_RFIX);
215        const int v = (int)MULT_FIX(J, wrk->fy_scale);
216        dst[x_out] = (v > 255) ? 255u : (uint8_t)v;
217      }
218    }
219  }
220  static void RescalerExportRowExpand_MIPSdspR2(WebPRescaler* const wrk) {
221    uint8_t* dst = wrk->dst;
222    rescaler_t* irow = wrk->irow;
223    const int x_out_max = wrk->dst_width * wrk->num_channels;
224    const rescaler_t* frow = wrk->frow;
225    assert(!WebPRescalerOutputDone(wrk));
226    assert(wrk->y_accum <= 0);
227    assert(wrk->y_expand);
228    assert(wrk->y_sub != 0);
229    if (wrk->y_accum == 0) {
230      ExportRowExpand_0(frow, dst, x_out_max, wrk);
231    } else {
232      ExportRowExpand_1(frow, irow, dst, x_out_max, wrk);
233    }
234  }
235  #if 0  
236  static WEBP_INLINE void ExportRowShrink_0(const uint32_t* frow, uint32_t* irow,
237                                            uint8_t* dst, int length,
238                                            const uint32_t yscale,
239                                            WebPRescaler* const wrk) {
240    const v4u32 y_scale = (v4u32)__msa_fill_w(yscale);
241    const v4u32 fxyscale = (v4u32)__msa_fill_w(wrk->fxy_scale);
242    const v4u32 shiftval = (v4u32)__msa_fill_w(WEBP_RESCALER_RFIX);
243    const v4i32 zero = { 0 };
244    while (length >= 16) {
245      v4u32 src0, src1, src2, src3, frac0, frac1, frac2, frac3;
246      v16u8 out;
247      LD_UW4(frow, 4, src0, src1, src2, src3);
248      CALC_MULT_FIX1_16(src0, src1, src2, src3, y_scale, shiftval,
249                        frac0, frac1, frac2, frac3);
250      LD_UW4(irow, 4, src0, src1, src2, src3);
251      SUB4(src0, frac0, src1, frac1, src2, frac2, src3, frac3,
252           src0, src1, src2, src3);
253      CALC_MULT_FIX_16(src0, src1, src2, src3, fxyscale, shiftval, out);
254      ST_UB(out, dst);
255      ST_UW4(frac0, frac1, frac2, frac3, irow, 4);
256      frow   += 16;
257      irow   += 16;
258      dst    += 16;
259      length -= 16;
260    }
261    if (length > 0) {
262      int x_out;
263      if (length >= 12) {
264        uint32_t val0_m, val1_m, val2_m;
265        v4u32 src0, src1, src2, frac0, frac1, frac2;
266        LD_UW3(frow, 4, src0, src1, src2);
267        CALC_MULT_FIX1_4(src0, y_scale, shiftval, frac0);
268        CALC_MULT_FIX1_4(src1, y_scale, shiftval, frac1);
269        CALC_MULT_FIX1_4(src2, y_scale, shiftval, frac2);
270        LD_UW3(irow, 4, src0, src1, src2);
271        SUB3(src0, frac0, src1, frac1, src2, frac2, src0, src1, src2);
272        CALC_MULT_FIX_4(src0, fxyscale, shiftval, val0_m);
273        CALC_MULT_FIX_4(src1, fxyscale, shiftval, val1_m);
274        CALC_MULT_FIX_4(src2, fxyscale, shiftval, val2_m);
275        SW3(val0_m, val1_m, val2_m, dst, 4);
276        ST_UW3(frac0, frac1, frac2, irow, 4);
277        frow   += 12;
278        irow   += 12;
279        dst    += 12;
280        length -= 12;
281      } else if (length >= 8) {
282        uint32_t val0_m, val1_m;
283        v4u32 src0, src1, frac0, frac1;
284        LD_UW2(frow, 4, src0, src1);
285        CALC_MULT_FIX1_4(src0, y_scale, shiftval, frac0);
286        CALC_MULT_FIX1_4(src1, y_scale, shiftval, frac1);
287        LD_UW2(irow, 4, src0, src1);
288        SUB2(src0, frac0, src1, frac1, src0, src1);
289        CALC_MULT_FIX_4(src0, fxyscale, shiftval, val0_m);
290        CALC_MULT_FIX_4(src1, fxyscale, shiftval, val1_m);
291        SW2(val0_m, val1_m, dst, 4);
292        ST_UW2(frac0, frac1, irow, 4);
293        frow   += 8;
294        irow   += 8;
295        dst    += 8;
296        length -= 8;
297      } else if (length >= 4) {
298        uint32_t val0_m;
299        v4u32 frac0;
300        v4u32 src0 = LD_UW(frow);
301        CALC_MULT_FIX1_4(src0, y_scale, shiftval, frac0);
302        src0 = LD_UW(irow);
303        src0 = src0 - frac0;
304        CALC_MULT_FIX_4(src0, fxyscale, shiftval, val0_m);
305        SW(val0_m, dst);
306        ST_UW(frac0, irow);
307        frow   += 4;
308        irow   += 4;
309        dst    += 4;
310        length -= 4;
311      }
312      for (x_out = 0; x_out < length; ++x_out) {
313        const uint32_t frac = (uint32_t)MULT_FIX_FLOOR(frow[x_out], yscale);
314        const int v = (int)MULT_FIX(irow[x_out] - frac, wrk->fxy_scale);
315        dst[x_out] = (v > 255) ? 255u : (uint8_t)v;
316        irow[x_out] = frac;
317      }
318    }
319  }
320  static WEBP_INLINE void ExportRowShrink_1(uint32_t* irow, uint8_t* dst,
321                                            int length,
322                                            WebPRescaler* const wrk) {
323    const v4u32 scale = (v4u32)__msa_fill_w(wrk->fxy_scale);
324    const v4u32 shift = (v4u32)__msa_fill_w(WEBP_RESCALER_RFIX);
325    const v4i32 zero = { 0 };
326    while (length >= 16) {
327      v4u32 src0, src1, src2, src3;
328      v16u8 dst0;
329      LD_UW4(irow, 4, src0, src1, src2, src3);
330      CALC_MULT_FIX_16(src0, src1, src2, src3, scale, shift, dst0);
331      ST_UB(dst0, dst);
332      ST_SW4(zero, zero, zero, zero, irow, 4);
333      length -= 16;
334      irow   += 16;
335      dst    += 16;
336    }
337    if (length > 0) {
338      int x_out;
339      if (length >= 12) {
340        uint32_t val0_m, val1_m, val2_m;
341        v4u32 src0, src1, src2;
342        LD_UW3(irow, 4, src0, src1, src2);
343        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
344        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
345        CALC_MULT_FIX_4(src2, scale, shift, val2_m);
346        SW3(val0_m, val1_m, val2_m, dst, 4);
347        ST_SW3(zero, zero, zero, irow, 4);
348        length -= 12;
349        irow   += 12;
350        dst    += 12;
351      } else if (length >= 8) {
352        uint32_t val0_m, val1_m;
353        v4u32 src0, src1;
354        LD_UW2(irow, 4, src0, src1);
355        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
356        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
357        SW2(val0_m, val1_m, dst, 4);
358        ST_SW2(zero, zero, irow, 4);
359        length -= 8;
360        irow   += 8;
361        dst    += 8;
362      } else if (length >= 4) {
363        uint32_t val0_m;
364        const v4u32 src0 = LD_UW(irow + 0);
365        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
366        SW(val0_m, dst);
367        ST_SW(zero, irow);
368        length -= 4;
369        irow   += 4;
370        dst    += 4;
371      }
372      for (x_out = 0; x_out < length; ++x_out) {
373        const int v = (int)MULT_FIX(irow[x_out], wrk->fxy_scale);
374        dst[x_out] = (v > 255) ? 255u : (uint8_t)v;
375        irow[x_out] = 0;
376      }
377    }
378  }
379  static void RescalerExportRowShrink_MIPSdspR2(WebPRescaler* const wrk) {
380    uint8_t* dst = wrk->dst;
381    rescaler_t* irow = wrk->irow;
382    const int x_out_max = wrk->dst_width * wrk->num_channels;
383    const rescaler_t* frow = wrk->frow;
384    const uint32_t yscale = wrk->fy_scale * (-wrk->y_accum);
385    assert(!WebPRescalerOutputDone(wrk));
386    assert(wrk->y_accum <= 0);
387    assert(!wrk->y_expand);
388    if (yscale) {
389      ExportRowShrink_0(frow, irow, dst, x_out_max, yscale, wrk);
390    } else {
391      ExportRowShrink_1(irow, dst, x_out_max, wrk);
392    }
393  }
394  #endif  
395  extern void WebPRescalerDspInitMSA(void);
396  WEBP_TSAN_IGNORE_FUNCTION void WebPRescalerDspInitMSA(void) {
397    WebPRescalerExportRowExpand = RescalerExportRowExpand_MIPSdspR2;
398  }
399  #else     
400  WEBP_DSP_INIT_STUB(WebPRescalerDspInitMSA)
401  #endif    
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_msa.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MSA) && !defined(WEBP_REDUCE_SIZE)
3  #include <assert.h>
4  #include "src/utils/rescaler_utils.h"
5  #include "src/dsp/msa_macro.h"
6  #define ROUNDER (WEBP_RESCALER_ONE >> 1)
7  #define MULT_FIX(x, y) (((uint64_t)(x) * (y) + ROUNDER) >> WEBP_RESCALER_RFIX)
8  #define MULT_FIX_FLOOR(x, y) (((uint64_t)(x) * (y)) >> WEBP_RESCALER_RFIX)
9  #define CALC_MULT_FIX_16(in0, in1, in2, in3, scale, shift, dst) do {  \
10    v4u32 tmp0, tmp1, tmp2, tmp3;                                       \
11    v16u8 t0, t1, t2, t3, t4, t5;                                       \
12    v2u64 out0, out1, out2, out3;                                       \
13    ILVRL_W2_UW(zero, in0, tmp0, tmp1);                                 \
14    ILVRL_W2_UW(zero, in1, tmp2, tmp3);                                 \
15    DOTP_UW2_UD(tmp0, tmp1, scale, scale, out0, out1);                  \
16    DOTP_UW2_UD(tmp2, tmp3, scale, scale, out2, out3);                  \
17    SRAR_D4_UD(out0, out1, out2, out3, shift);                          \
18    PCKEV_B2_UB(out1, out0, out3, out2, t0, t1);                        \
19    ILVRL_W2_UW(zero, in2, tmp0, tmp1);                                 \
20    ILVRL_W2_UW(zero, in3, tmp2, tmp3);                                 \
21    DOTP_UW2_UD(tmp0, tmp1, scale, scale, out0, out1);                  \
22    DOTP_UW2_UD(tmp2, tmp3, scale, scale, out2, out3);                  \
23    SRAR_D4_UD(out0, out1, out2, out3, shift);                          \
24    PCKEV_B2_UB(out1, out0, out3, out2, t2, t3);                        \
25    PCKEV_B2_UB(t1, t0, t3, t2, t4, t5);                                \
26    dst = (v16u8)__msa_pckev_b((v16i8)t5, (v16i8)t4);                   \
27  } while (0)
28  #define CALC_MULT_FIX_4(in0, scale, shift, dst) do {  \
29    v4u32 tmp0, tmp1;                                   \
30    v16i8 t0, t1;                                       \
31    v2u64 out0, out1;                                   \
32    ILVRL_W2_UW(zero, in0, tmp0, tmp1);                 \
33    DOTP_UW2_UD(tmp0, tmp1, scale, scale, out0, out1);  \
34    SRAR_D2_UD(out0, out1, shift);                      \
35    t0 = __msa_pckev_b((v16i8)out1, (v16i8)out0);       \
36    t1 = __msa_pckev_b(t0, t0);                         \
37    t0 = __msa_pckev_b(t1, t1);                         \
38    dst = __msa_copy_s_w((v4i32)t0, 0);                 \
39  } while (0)
40  #define CALC_MULT_FIX1_16(in0, in1, in2, in3, fyscale, shift,  \
41                            dst0, dst1, dst2, dst3) do {         \
42    v4u32 tmp0, tmp1, tmp2, tmp3;                                \
43    v2u64 out0, out1, out2, out3;                                \
44    ILVRL_W2_UW(zero, in0, tmp0, tmp1);                          \
45    ILVRL_W2_UW(zero, in1, tmp2, tmp3);                          \
46    DOTP_UW2_UD(tmp0, tmp1, fyscale, fyscale, out0, out1);       \
47    DOTP_UW2_UD(tmp2, tmp3, fyscale, fyscale, out2, out3);       \
48    SRAR_D4_UD(out0, out1, out2, out3, shift);                   \
49    PCKEV_W2_UW(out1, out0, out3, out2, dst0, dst1);             \
50    ILVRL_W2_UW(zero, in2, tmp0, tmp1);                          \
51    ILVRL_W2_UW(zero, in3, tmp2, tmp3);                          \
52    DOTP_UW2_UD(tmp0, tmp1, fyscale, fyscale, out0, out1);       \
53    DOTP_UW2_UD(tmp2, tmp3, fyscale, fyscale, out2, out3);       \
54    SRAR_D4_UD(out0, out1, out2, out3, shift);                   \
55    PCKEV_W2_UW(out1, out0, out3, out2, dst2, dst3);             \
56  } while (0)
57  #define CALC_MULT_FIX1_4(in0, scale, shift, dst) do {    \
58    v4u32 tmp0, tmp1;                                      \
59    v2u64 out0, out1;                                      \
60    ILVRL_W2_UW(zero, in0, tmp0, tmp1);                    \
61    DOTP_UW2_UD(tmp0, tmp1, scale, scale, out0, out1);     \
62    SRAR_D2_UD(out0, out1, shift);                         \
63    dst = (v4u32)__msa_pckev_w((v4i32)out1, (v4i32)out0);  \
64  } while (0)
65  #define CALC_MULT_FIX2_16(in0, in1, in2, in3, mult, scale, shift,  \
66                            dst0, dst1) do {                         \
67    v4u32 tmp0, tmp1, tmp2, tmp3;                                    \
68    v2u64 out0, out1, out2, out3;                                    \
69    ILVRL_W2_UW(in0, in2, tmp0, tmp1);                               \
70    ILVRL_W2_UW(in1, in3, tmp2, tmp3);                               \
71    DOTP_UW2_UD(tmp0, tmp1, mult, mult, out0, out1);                 \
72    DOTP_UW2_UD(tmp2, tmp3, mult, mult, out2, out3);                 \
73    SRAR_D4_UD(out0, out1, out2, out3, shift);                       \
74    DOTP_UW2_UD(out0, out1, scale, scale, out0, out1);               \
75    DOTP_UW2_UD(out2, out3, scale, scale, out2, out3);               \
76    SRAR_D4_UD(out0, out1, out2, out3, shift);                       \
77    PCKEV_B2_UB(out1, out0, out3, out2, dst0, dst1);                 \
78  } while (0)
79  #define CALC_MULT_FIX2_4(in0, in1, mult, scale, shift, dst) do {  \
80    v4u32 tmp0, tmp1;                                               \
81    v2u64 out0, out1;                                               \
82    v16i8 t0, t1;                                                   \
83    ILVRL_W2_UW(in0, in1, tmp0, tmp1);                              \
84    DOTP_UW2_UD(tmp0, tmp1, mult, mult, out0, out1);                \
85    SRAR_D2_UD(out0, out1, shift);                                  \
86    DOTP_UW2_UD(out0, out1, scale, scale, out0, out1);              \
87    SRAR_D2_UD(out0, out1, shift);                                  \
88    t0 = __msa_pckev_b((v16i8)out1, (v16i8)out0);                   \
89    t1 = __msa_pckev_b(t0, t0);                                     \
90    t0 = __msa_pckev_b(t1, t1);                                     \
91    dst = __msa_copy_s_w((v4i32)t0, 0);                             \
92  } while (0)
93  static WEBP_INLINE void ExportRowExpand_0(const uint32_t* frow, uint8_t* dst,
94                                            int length,
95                                            WebPRescaler* const wrk) {
96    const v4u32 scale = (v4u32)__msa_fill_w(wrk->fy_scale);
97    const v4u32 shift = (v4u32)__msa_fill_w(WEBP_RESCALER_RFIX);
98    const v4i32 zero = { 0 };
99    while (length >= 16) {
100      v4u32 src0, src1, src2, src3;
101      v16u8 out;
102      LD_UW4(frow, 4, src0, src1, src2, src3);
103      CALC_MULT_FIX_16(src0, src1, src2, src3, scale, shift, out);
104      ST_UB(out, dst);
105      length -= 16;
106      frow   += 16;
107      dst    += 16;
108    }
109    if (length > 0) {
110      int x_out;
111      if (length >= 12) {
112        uint32_t val0_m, val1_m, val2_m;
113        v4u32 src0, src1, src2;
114        LD_UW3(frow, 4, src0, src1, src2);
115        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
116        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
117        CALC_MULT_FIX_4(src2, scale, shift, val2_m);
118        SW3(val0_m, val1_m, val2_m, dst, 4);
119        length -= 12;
120        frow   += 12;
121        dst    += 12;
122      } else if (length >= 8) {
123        uint32_t val0_m, val1_m;
124        v4u32 src0, src1;
125        LD_UW2(frow, 4, src0, src1);
126        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
127        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
128        SW2(val0_m, val1_m, dst, 4);
129        length -= 8;
130        frow   += 8;
131        dst    += 8;
132      } else if (length >= 4) {
133        uint32_t val0_m;
134        const v4u32 src0 = LD_UW(frow);
135        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
136        SW(val0_m, dst);
137        length -= 4;
138        frow   += 4;
139        dst    += 4;
140      }
141      for (x_out = 0; x_out < length; ++x_out) {
142        const uint32_t J = frow[x_out];
143        const int v = (int)MULT_FIX(J, wrk->fy_scale);
144        dst[x_out] = (v > 255) ? 255u : (uint8_t)v;
145      }
146    }
147  }
148  static WEBP_INLINE void ExportRowExpand_1(const uint32_t* frow, uint32_t* irow,
149                                            uint8_t* dst, int length,
150                                            WebPRescaler* const wrk) {
151    const uint32_t B = WEBP_RESCALER_FRAC(-wrk->y_accum, wrk->y_sub);
152    const uint32_t A = (uint32_t)(WEBP_RESCALER_ONE - B);
153    const v4i32 B1 = __msa_fill_w(B);
154    const v4i32 A1 = __msa_fill_w(A);
155    const v4i32 AB = __msa_ilvr_w(A1, B1);
156    const v4u32 scale = (v4u32)__msa_fill_w(wrk->fy_scale);
157    const v4u32 shift = (v4u32)__msa_fill_w(WEBP_RESCALER_RFIX);
158    while (length >= 16) {
159      v4u32 frow0, frow1, frow2, frow3, irow0, irow1, irow2, irow3;
160      v16u8 t0, t1, t2, t3, t4, t5;
161      LD_UW4(frow, 4, frow0, frow1, frow2, frow3);
162      LD_UW4(irow, 4, irow0, irow1, irow2, irow3);
163      CALC_MULT_FIX2_16(frow0, frow1, irow0, irow1, AB, scale, shift, t0, t1);
164      CALC_MULT_FIX2_16(frow2, frow3, irow2, irow3, AB, scale, shift, t2, t3);
165      PCKEV_B2_UB(t1, t0, t3, t2, t4, t5);
166      t0 = (v16u8)__msa_pckev_b((v16i8)t5, (v16i8)t4);
167      ST_UB(t0, dst);
168      frow   += 16;
169      irow   += 16;
170      dst    += 16;
171      length -= 16;
172    }
173    if (length > 0) {
174      int x_out;
175      if (length >= 12) {
176        uint32_t val0_m, val1_m, val2_m;
177        v4u32 frow0, frow1, frow2, irow0, irow1, irow2;
178        LD_UW3(frow, 4, frow0, frow1, frow2);
179        LD_UW3(irow, 4, irow0, irow1, irow2);
180        CALC_MULT_FIX2_4(frow0, irow0, AB, scale, shift, val0_m);
181        CALC_MULT_FIX2_4(frow1, irow1, AB, scale, shift, val1_m);
182        CALC_MULT_FIX2_4(frow2, irow2, AB, scale, shift, val2_m);
183        SW3(val0_m, val1_m, val2_m, dst, 4);
184        frow   += 12;
185        irow   += 12;
186        dst    += 12;
187        length -= 12;
188      } else if (length >= 8) {
189        uint32_t val0_m, val1_m;
190        v4u32 frow0, frow1, irow0, irow1;
191        LD_UW2(frow, 4, frow0, frow1);
192        LD_UW2(irow, 4, irow0, irow1);
193        CALC_MULT_FIX2_4(frow0, irow0, AB, scale, shift, val0_m);
194        CALC_MULT_FIX2_4(frow1, irow1, AB, scale, shift, val1_m);
195        SW2(val0_m, val1_m, dst, 4);
196        frow   += 4;
197        irow   += 4;
198        dst    += 4;
199        length -= 4;
200      } else if (length >= 4) {
201        uint32_t val0_m;
202        const v4u32 frow0 = LD_UW(frow + 0);
203        const v4u32 irow0 = LD_UW(irow + 0);
204        CALC_MULT_FIX2_4(frow0, irow0, AB, scale, shift, val0_m);
205        SW(val0_m, dst);
206        frow   += 4;
207        irow   += 4;
208        dst    += 4;
209        length -= 4;
210      }
211      for (x_out = 0; x_out < length; ++x_out) {
212        const uint64_t I = (uint64_t)A * frow[x_out]
213                         + (uint64_t)B * irow[x_out];
214        const uint32_t J = (uint32_t)((I + ROUNDER) >> WEBP_RESCALER_RFIX);
215        const int v = (int)MULT_FIX(J, wrk->fy_scale);
216        dst[x_out] = (v > 255) ? 255u : (uint8_t)v;
217      }
218    }
219  }
220  static void RescalerExportRowExpand_MIPSdspR2(WebPRescaler* const wrk) {
221    uint8_t* dst = wrk->dst;
222    rescaler_t* irow = wrk->irow;
223    const int x_out_max = wrk->dst_width * wrk->num_channels;
224    const rescaler_t* frow = wrk->frow;
225    assert(!WebPRescalerOutputDone(wrk));
226    assert(wrk->y_accum <= 0);
227    assert(wrk->y_expand);
228    assert(wrk->y_sub != 0);
229    if (wrk->y_accum == 0) {
230      ExportRowExpand_0(frow, dst, x_out_max, wrk);
231    } else {
232      ExportRowExpand_1(frow, irow, dst, x_out_max, wrk);
233    }
234  }
235  #if 0  
236  static WEBP_INLINE void ExportRowShrink_0(const uint32_t* frow, uint32_t* irow,
237                                            uint8_t* dst, int length,
238                                            const uint32_t yscale,
239                                            WebPRescaler* const wrk) {
240    const v4u32 y_scale = (v4u32)__msa_fill_w(yscale);
241    const v4u32 fxyscale = (v4u32)__msa_fill_w(wrk->fxy_scale);
242    const v4u32 shiftval = (v4u32)__msa_fill_w(WEBP_RESCALER_RFIX);
243    const v4i32 zero = { 0 };
244    while (length >= 16) {
245      v4u32 src0, src1, src2, src3, frac0, frac1, frac2, frac3;
246      v16u8 out;
247      LD_UW4(frow, 4, src0, src1, src2, src3);
248      CALC_MULT_FIX1_16(src0, src1, src2, src3, y_scale, shiftval,
249                        frac0, frac1, frac2, frac3);
250      LD_UW4(irow, 4, src0, src1, src2, src3);
251      SUB4(src0, frac0, src1, frac1, src2, frac2, src3, frac3,
252           src0, src1, src2, src3);
253      CALC_MULT_FIX_16(src0, src1, src2, src3, fxyscale, shiftval, out);
254      ST_UB(out, dst);
255      ST_UW4(frac0, frac1, frac2, frac3, irow, 4);
256      frow   += 16;
257      irow   += 16;
258      dst    += 16;
259      length -= 16;
260    }
261    if (length > 0) {
262      int x_out;
263      if (length >= 12) {
264        uint32_t val0_m, val1_m, val2_m;
265        v4u32 src0, src1, src2, frac0, frac1, frac2;
266        LD_UW3(frow, 4, src0, src1, src2);
267        CALC_MULT_FIX1_4(src0, y_scale, shiftval, frac0);
268        CALC_MULT_FIX1_4(src1, y_scale, shiftval, frac1);
269        CALC_MULT_FIX1_4(src2, y_scale, shiftval, frac2);
270        LD_UW3(irow, 4, src0, src1, src2);
271        SUB3(src0, frac0, src1, frac1, src2, frac2, src0, src1, src2);
272        CALC_MULT_FIX_4(src0, fxyscale, shiftval, val0_m);
273        CALC_MULT_FIX_4(src1, fxyscale, shiftval, val1_m);
274        CALC_MULT_FIX_4(src2, fxyscale, shiftval, val2_m);
275        SW3(val0_m, val1_m, val2_m, dst, 4);
276        ST_UW3(frac0, frac1, frac2, irow, 4);
277        frow   += 12;
278        irow   += 12;
279        dst    += 12;
280        length -= 12;
281      } else if (length >= 8) {
282        uint32_t val0_m, val1_m;
283        v4u32 src0, src1, frac0, frac1;
284        LD_UW2(frow, 4, src0, src1);
285        CALC_MULT_FIX1_4(src0, y_scale, shiftval, frac0);
286        CALC_MULT_FIX1_4(src1, y_scale, shiftval, frac1);
287        LD_UW2(irow, 4, src0, src1);
288        SUB2(src0, frac0, src1, frac1, src0, src1);
289        CALC_MULT_FIX_4(src0, fxyscale, shiftval, val0_m);
290        CALC_MULT_FIX_4(src1, fxyscale, shiftval, val1_m);
291        SW2(val0_m, val1_m, dst, 4);
292        ST_UW2(frac0, frac1, irow, 4);
293        frow   += 8;
294        irow   += 8;
295        dst    += 8;
296        length -= 8;
297      } else if (length >= 4) {
298        uint32_t val0_m;
299        v4u32 frac0;
300        v4u32 src0 = LD_UW(frow);
301        CALC_MULT_FIX1_4(src0, y_scale, shiftval, frac0);
302        src0 = LD_UW(irow);
303        src0 = src0 - frac0;
304        CALC_MULT_FIX_4(src0, fxyscale, shiftval, val0_m);
305        SW(val0_m, dst);
306        ST_UW(frac0, irow);
307        frow   += 4;
308        irow   += 4;
309        dst    += 4;
310        length -= 4;
311      }
312      for (x_out = 0; x_out < length; ++x_out) {
313        const uint32_t frac = (uint32_t)MULT_FIX_FLOOR(frow[x_out], yscale);
314        const int v = (int)MULT_FIX(irow[x_out] - frac, wrk->fxy_scale);
315        dst[x_out] = (v > 255) ? 255u : (uint8_t)v;
316        irow[x_out] = frac;
317      }
318    }
319  }
320  static WEBP_INLINE void ExportRowShrink_1(uint32_t* irow, uint8_t* dst,
321                                            int length,
322                                            WebPRescaler* const wrk) {
323    const v4u32 scale = (v4u32)__msa_fill_w(wrk->fxy_scale);
324    const v4u32 shift = (v4u32)__msa_fill_w(WEBP_RESCALER_RFIX);
325    const v4i32 zero = { 0 };
326    while (length >= 16) {
327      v4u32 src0, src1, src2, src3;
328      v16u8 dst0;
329      LD_UW4(irow, 4, src0, src1, src2, src3);
330      CALC_MULT_FIX_16(src0, src1, src2, src3, scale, shift, dst0);
331      ST_UB(dst0, dst);
332      ST_SW4(zero, zero, zero, zero, irow, 4);
333      length -= 16;
334      irow   += 16;
335      dst    += 16;
336    }
337    if (length > 0) {
338      int x_out;
339      if (length >= 12) {
340        uint32_t val0_m, val1_m, val2_m;
341        v4u32 src0, src1, src2;
342        LD_UW3(irow, 4, src0, src1, src2);
343        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
344        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
345        CALC_MULT_FIX_4(src2, scale, shift, val2_m);
346        SW3(val0_m, val1_m, val2_m, dst, 4);
<span onclick='openModal()' class='match'>347        ST_SW3(zero, zero, zero, irow, 4);
348        length -= 12;
349        irow   += 12;
350        dst    += 12;
351      } else if (length >= 8) {
352        uint32_t val0_m, val1_m;
353        v4u32 src0, src1;
354        LD_UW2(irow, 4, src0, src1);
355        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
356        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
357        SW2(val0_m, val1_m, dst, 4);
358        ST_SW2(zero, zero, irow, 4);
</span>359        length -= 8;
360        irow   += 8;
361        dst    += 8;
362      } else if (length >= 4) {
363        uint32_t val0_m;
364        const v4u32 src0 = LD_UW(irow + 0);
365        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
366        SW(val0_m, dst);
367        ST_SW(zero, irow);
368        length -= 4;
369        irow   += 4;
370        dst    += 4;
371      }
372      for (x_out = 0; x_out < length; ++x_out) {
373        const int v = (int)MULT_FIX(irow[x_out], wrk->fxy_scale);
374        dst[x_out] = (v > 255) ? 255u : (uint8_t)v;
375        irow[x_out] = 0;
376      }
377    }
378  }
379  static void RescalerExportRowShrink_MIPSdspR2(WebPRescaler* const wrk) {
380    uint8_t* dst = wrk->dst;
381    rescaler_t* irow = wrk->irow;
382    const int x_out_max = wrk->dst_width * wrk->num_channels;
383    const rescaler_t* frow = wrk->frow;
384    const uint32_t yscale = wrk->fy_scale * (-wrk->y_accum);
385    assert(!WebPRescalerOutputDone(wrk));
386    assert(wrk->y_accum <= 0);
387    assert(!wrk->y_expand);
388    if (yscale) {
389      ExportRowShrink_0(frow, irow, dst, x_out_max, yscale, wrk);
390    } else {
391      ExportRowShrink_1(irow, dst, x_out_max, wrk);
392    }
393  }
394  #endif  
395  extern void WebPRescalerDspInitMSA(void);
396  WEBP_TSAN_IGNORE_FUNCTION void WebPRescalerDspInitMSA(void) {
397    WebPRescalerExportRowExpand = RescalerExportRowExpand_MIPSdspR2;
398  }
399  #else     
400  WEBP_DSP_INIT_STUB(WebPRescalerDspInitMSA)
401  #endif    
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_msa.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_msa.c</div>
                </div>
                <div class="column column_space"><pre><code>118        SW3(val0_m, val1_m, val2_m, dst, 4);
119        length -= 12;
120        frow   += 12;
121        dst    += 12;
122      } else if (length >= 8) {
123        uint32_t val0_m, val1_m;
124        v4u32 src0, src1;
125        LD_UW2(frow, 4, src0, src1);
126        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
127        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
128        SW2(val0_m, val1_m, dst, 4);
129        length -= 8;
</pre></code></div>
                <div class="column column_space"><pre><code>347        ST_SW3(zero, zero, zero, irow, 4);
348        length -= 12;
349        irow   += 12;
350        dst    += 12;
351      } else if (length >= 8) {
352        uint32_t val0_m, val1_m;
353        v4u32 src0, src1;
354        LD_UW2(irow, 4, src0, src1);
355        CALC_MULT_FIX_4(src0, scale, shift, val0_m);
356        CALC_MULT_FIX_4(src1, scale, shift, val1_m);
357        SW2(val0_m, val1_m, dst, 4);
358        ST_SW2(zero, zero, irow, 4);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    