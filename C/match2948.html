<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-test-traffic-replay.c &amp; inf-text-gtk-view.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-traffic-replay.c &amp; inf-text-gtk-view.c
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-traffic-replay.c (2.2304833%)<th>inf-text-gtk-view.c (1.4652015%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(48-73)<td><a href="#" name="0">(53-98)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-traffic-replay.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #define _XOPEN_SOURCE 700
2 #include "util/inf-test-util.h"
3 #include &lt;libinfinity/server/infd-xml-server.h&gt;
4 #include &lt;libinfinity/server/infd-xmpp-server.h&gt;
5 #include &lt;libinfinity/common/inf-standalone-io.h&gt;
6 #include &lt;libinfinity/common/inf-cert-util.h&gt;
7 #include &lt;libinfinity/common/inf-init.h&gt;
8 #include &lt;gnutls/gnutls.h&gt;
9 #include &lt;gnutls/x509.h&gt;
10 #include &lt;libxml/xmlsave.h&gt;
11 #include &lt;time.h&gt;
12 #include &lt;string.h&gt;
13 #include &lt;errno.h&gt;
14 #include &lt;assert.h&gt;
15 typedef struct _InfTestTrafficReplay InfTestTrafficReplay;
16 struct _InfTestTrafficReplay {
17   InfStandaloneIo* io;
18   guint port;
19   InfdXmppServer* xmpp;
20   const gchar* filename;
21 <a name="0"></a>  GSList* conns;
22 };
23 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef enum _InfTestTrafficReplayMessageType {
24   INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING,
25   INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING,
26   INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT,
27   INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT,
28   INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR
29 } InfTestTrafficReplayMessageType;
30 typedef struct _InfTestTrafficReplayMessage InfTestTrafficReplayMessage;
31 struct _InfTestTrafficReplayMessage {
32   gint64 timestamp;   InfTestTrafficReplayMessageType type;
33   xmlNodePtr xml;
34   xmlNodePtr xml_iter;
35 };
36 typedef struct _InfTestTrafficReplayConnection InfTestTrafficReplayConnection;
37 struct _InfTestTrafficReplayConnection {
38   gchar* name;
39   InfTestTrafficReplay* replay;
40   InfCertificateCredentials* creds;
41   InfXmppConnection* xmpp;
42   FILE* file;
43   InfTestTrafficReplayMessage* message;
44   GHashTable* group_queues; };</b></font>
45 typedef enum _InfTestTrafficReplayError {
46   INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
47   INF_TEST_TRAFFIC_REPLAY_ERROR_UNEXPECTED_EOF
48 } InfTestTrafficReplayError;
49 static GQuark
50 inf_test_traffic_replay_error_quark()
51 {
52   return g_quark_from_static_string("INF_TEST_TRAFFIC_REPLAY_ERROR");
53 }
54 static void
55 inf_test_traffic_replay_received_cb(InfXmppConnection* connection,
56                                     xmlNodePtr xml,
57                                     gpointer user_data);
58 static void
59 inf_test_traffic_replay_notify_status_cb(GObject* object,
60                                          GParamSpec* pspec,
61                                          gpointer user_data);
62 static void
63 inf_test_traffic_replay_queue_free(GQueue* queue)
64 {
65   g_queue_free_full(queue, (GDestroyNotify)xmlFreeDoc);
66 }
67 static void
68 inf_test_traffic_replay_message_free(InfTestTrafficReplayMessage* message)
69 {
70   if(message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
71      message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
72   {
73     if(message-&gt;xml != NULL)
74       xmlFreeNode(message-&gt;xml);
75   }
76   g_slice_free(InfTestTrafficReplayMessage, message);
77 }
78 static char*
79 inf_test_traffic_replay_get_next_line(InfTestTrafficReplayConnection* conn,
80                                       size_t* len,
81                                       GError** error)
82 {
83   char* line;
84   size_t n;
85   ssize_t len_;
86   int err;
87   line = NULL;
88   n = 0;
89   len_ = getline(&amp;line, &amp;n, conn-&gt;file);
90   if(len_ &gt;= 0)
91   {
92     *len = len_;
93     return line;
94   }
95   else
96   {
97     if(feof(conn-&gt;file))
98     {
99       g_set_error(
100         error,
101         inf_test_traffic_replay_error_quark(),
102         INF_TEST_TRAFFIC_REPLAY_ERROR_UNEXPECTED_EOF,
103         "Unexpected end of file"
104       );
105     }
106     else
107     {
108       err = ferror(conn-&gt;file);
109       g_set_error_literal(
110         error,
111         G_FILE_ERROR,
112         g_file_error_from_errno(err),
113         strerror(err)
114       );
115     }
116     return NULL;
117   }
118 }
119 static InfTestTrafficReplayMessage*
120 inf_test_traffic_replay_get_next_message(InfTestTrafficReplayConnection* conn,
121                                          GError** error)
122 {
123   char* line;
124   size_t len;
125   size_t n;
126   struct tm tm;
127   char* end;
128   gulong msecs;
129   InfTestTrafficReplayMessageType type;
130   xmlDocPtr xml;
131   GString* str;
132   InfTestTrafficReplayMessage* message;
133   line = inf_test_traffic_replay_get_next_line(conn, &amp;len, error);
134   if(!line) return NULL;
135   if(line[0] != '[')
136   {
137     g_set_error(
138       error,
139       inf_test_traffic_replay_error_quark(),
140       INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
141       "Line does not start with a timestamp"
142     );
143     free(line);
144     return FALSE;
145   }
146   end = strptime(&amp;line[1], "%a %d %b %Y %I:%M:%S %p %Z", &amp;tm);
147   if(end == NULL || *end != ' ' || *(end+1) != '.')
148   {
149     g_set_error(
150       error,
151       inf_test_traffic_replay_error_quark(),
152       INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
153       "Failed to parse timestamp"
154     );
155     free(line);
156     return FALSE;
157   }
158   errno = 0;
159   msecs = strtoul(&amp;end[2], &amp;end, 10);
160   if(errno != 0 || *end != ']' || msecs &gt;= 1000000)
161   {
162     g_set_error(
163       error,
164       inf_test_traffic_replay_error_quark(),
165       INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
166       "Failed to parse timestamp"
167     );
168     free(line);
169     return FALSE;
170   }
171   ++end;
172   tm.tm_isdst = 1;
173   n = (end - line) + 1;
174   if(line[n] == '!')
175   {
176     if(strstr(line + n + 4, "connected") != NULL)
177       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT;
178     else if(strstr(line + n + 4, "Connection error") != NULL)
179       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR;
180     else if(strstr(line + n + 4, "closed") != NULL)
181       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT;
182     else
183     {
184       g_set_error(
185         error,
186         inf_test_traffic_replay_error_quark(),
187         INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
188         "Unknown connection event \"%s\"",
189         line + n + 4
190       );
191       free(line);
192       return FALSE;
193     }
194   }
195   else if(line[n] == '&lt;')
196   {
197     if(FALSE)       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING;
198     else
199       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING;
200   }
201   else if(line[n] == '&gt;')
202   {
203       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING;
204     else
205       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING;
206   }
207   else
208   {
209     g_set_error(
210       error,
211       inf_test_traffic_replay_error_quark(),
212       INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
213       "Unknown control character \"%c\" (%d)",
214       line[n],
215       (int)line[n]
216     );
217     free(line);
218     return FALSE;
219   }
220   if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
221      type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
222   {
223     str = g_string_new_len(line + n + 4, len - n - 5);
224     xml = xmlReadDoc(str-&gt;str, NULL, "UTF-8", XML_PARSE_NOWARNING | XML_PARSE_NOERROR);
225     while(!xml)
226     {
227       free(line);
228       line = inf_test_traffic_replay_get_next_line(conn, &amp;len, error);
229       if(!line)
230       {
231         g_string_free(str, TRUE);
232         return NULL;
233       }
234       g_string_append_c(str, '\n');
235       g_string_append_len(str, line, len - 1);
236       xml = xmlReadDoc(str-&gt;str, NULL, "UTF-8", XML_PARSE_NOWARNING | XML_PARSE_NOERROR);
237     }
238     g_string_free(str, TRUE);
239   }
240   free(line);
241   message = g_slice_new(InfTestTrafficReplayMessage);
242   message-&gt;timestamp = (gint64)mktime(&amp;tm) * 1000000 + msecs;
243   message-&gt;type = type;
244   if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
245      type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
246   {
247     message-&gt;xml = xmlCopyNode(xmlDocGetRootElement(xml), 1);
248     if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
249       message-&gt;xml_iter = message-&gt;xml-&gt;children;
250     xmlFreeDoc(xml);
251   }
252   return message;
253 }
254 static void
255 inf_test_traffic_replay_connection_close(InfTestTrafficReplayConnection* conn)
256 {
257   InfXmlConnectionStatus status;
258   g_signal_handlers_disconnect_by_func(
259     G_OBJECT(conn-&gt;xmpp),
260     G_CALLBACK(inf_test_traffic_replay_received_cb),
261     conn
262   );
263   g_signal_handlers_disconnect_by_func(
264     G_OBJECT(conn-&gt;xmpp),
265     G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
266     conn
267   );
268   if(conn-&gt;xmpp != NULL)
269   {
270     g_object_get(G_OBJECT(conn-&gt;xmpp), "status", &amp;status, NULL);
271     if(status == INF_XML_CONNECTION_OPEN ||
272        status == INF_XML_CONNECTION_OPENING)
273     {
274       inf_xml_connection_close(INF_XML_CONNECTION(conn-&gt;xmpp));
275     }
276   }
277   if(conn-&gt;creds != NULL)
278     inf_certificate_credentials_unref(conn-&gt;creds);
279   g_object_unref(conn-&gt;xmpp);
280   if(conn-&gt;file != NULL) fclose(conn-&gt;file);
281   g_hash_table_destroy(conn-&gt;group_queues);
282   fprintf(stderr, "[%s] Disconnected\n", conn-&gt;name);
283   g_free(conn-&gt;name);
284   conn-&gt;replay-&gt;conns = g_slist_remove(conn-&gt;replay-&gt;conns, conn);
285   if(conn-&gt;replay-&gt;conns == NULL)
286     inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
287   g_slice_free(InfTestTrafficReplayConnection, conn);
288 }
289 static void
290 inf_test_traffic_replay_connection_check_message(
291   InfTestTrafficReplayConnection* conn,
292   xmlNodePtr xml)
293 {
294   xmlBufferPtr received_buffer;
295   xmlBufferPtr expected_buffer;
296   xmlSaveCtxtPtr ctx;
297   received_buffer = xmlBufferCreate();
298   expected_buffer = xmlBufferCreate();
299   if(strcmp(conn-&gt;message-&gt;xml_iter-&gt;name, "message") == 0)
300     xmlSetProp(conn-&gt;message-&gt;xml_iter, "time", NULL);
301   if(strcmp(xml-&gt;name, "message") == 0)
302     xmlSetProp(xml, "time", NULL);
303   ctx = xmlSaveToBuffer(expected_buffer, "UTF-8", 0);
304   xmlSaveTree(ctx, conn-&gt;message-&gt;xml_iter);
305   xmlSaveClose(ctx);
306   ctx = xmlSaveToBuffer(received_buffer, "UTF-8", 0);
307   xmlSaveTree(ctx, xml);
308   xmlSaveClose(ctx);
309   if(strcmp(xmlBufferContent(expected_buffer), xmlBufferContent(received_buffer)) != 0)
310   {
311     fprintf(
312       stderr,
313       "[WARNING] [%s] Mismatch between expected and received: "
314       "\n\n\"%s\"\n\nvs.\n\n\"%s\"\n",
315       conn-&gt;name,
316       (const gchar*)xmlBufferContent(expected_buffer),
317       (const gchar*)xmlBufferContent(received_buffer)
318     );
319     xmlBufferFree(expected_buffer);
320     xmlBufferFree(received_buffer);
321     if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
322       inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
323     return;
324   }
325   xmlBufferFree(expected_buffer);
326   xmlBufferFree(received_buffer);
327 }
328 static gboolean
329 inf_test_traffic_replay_connection_process_next_message(
330   InfTestTrafficReplayConnection* conn)
331 {
332   InfIpAddress* addr;
333   InfTcpConnection* tcp;
334   GError* error;
335   xmlChar* group;
336   GQueue* queue;
337   switch(conn-&gt;message-&gt;type)
338   {
339   case INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT:
340     if(conn-&gt;xmpp != NULL)
341       return FALSE;
342     fprintf(stderr, "[%s] Connecting...\n", conn-&gt;name);
343     addr = inf_ip_address_new_loopback4();
344     tcp = inf_tcp_connection_new(
345       INF_IO(conn-&gt;replay-&gt;io),
346       addr,
347       conn-&gt;replay-&gt;port
348     );
349     inf_ip_address_free(addr);
350     conn-&gt;xmpp = inf_xmpp_connection_new(
351       tcp,
352       INF_XMPP_CONNECTION_CLIENT,
353       NULL,
354       "localhost",
355       INF_XMPP_CONNECTION_SECURITY_ONLY_TLS,
356       conn-&gt;creds,
357       NULL,
358       NULL
359     );
360     g_signal_connect(
361       G_OBJECT(conn-&gt;xmpp),
362       "received",
363       G_CALLBACK(inf_test_traffic_replay_received_cb),
364       conn
365     );
366     g_signal_connect(
367       G_OBJECT(conn-&gt;xmpp),
368       "notify::status",
369       G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
370       conn
371     );
372     error = NULL;
373     if(!inf_tcp_connection_open(tcp, &amp;error))
374     {
375       fprintf(stderr, "[ERROR] [%s] %s\n", conn-&gt;name, error-&gt;message);
376       g_error_free(error);
377       if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
378         inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
379       return FALSE;
380     }
381     g_object_unref(tcp);
382     return FALSE;
383   case INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT:
384     g_assert(conn-&gt;xmpp != NULL);
385     inf_test_traffic_replay_connection_close(conn);
386     return TRUE;
387   case INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR:
388     g_assert(conn-&gt;xmpp != NULL);
389     fprintf(stderr, "[%s] Recorded connection error, ignored\n", conn-&gt;name);
390     return TRUE;
391   case INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING:
392     g_assert(conn-&gt;xmpp != NULL);
393     group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
394     fprintf(stderr, "[%s] Expecting data (%s, %s)\n", conn-&gt;name, group, conn-&gt;message-&gt;xml_iter-&gt;name);     queue = g_hash_table_lookup(conn-&gt;group_queues, group);
395     xmlFree(group);
396     g_assert(queue == NULL || g_queue_is_empty(queue));
397     return FALSE;
398   case INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING:
399     g_assert(conn-&gt;xmpp != NULL);
400     group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
401     fprintf(stderr, "[%s] Sending data (%s, %s)\n", conn-&gt;name, group, conn-&gt;message-&gt;xml-&gt;children-&gt;name);     xmlFree(group);
402     inf_xml_connection_send(
403       INF_XML_CONNECTION(conn-&gt;xmpp),
404       conn-&gt;message-&gt;xml
405     );
406     conn-&gt;message-&gt;xml = NULL;
407     return TRUE;
408   default:
409     g_assert_not_reached();
410     break;
411   }
412 }
413 static void
414 inf_test_traffic_replay_process_next_message(InfTestTrafficReplay* replay);
415 static void
416 inf_test_traffic_replay_connection_fetch_next_message(
417   InfTestTrafficReplayConnection* conn)
418 {
419   xmlChar* group;
420   GQueue* queue;
421   xmlNodePtr xml;
422   if(!inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
423     return;
424   if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING &amp;&amp;
425      conn-&gt;message-&gt;xml_iter-&gt;next != NULL)
426   {
427     conn-&gt;message-&gt;xml_iter = conn-&gt;message-&gt;xml_iter-&gt;next;
428   }
429   else
430   {
431     GError* error;
432     inf_test_traffic_replay_message_free(conn-&gt;message);
433     error = NULL;
434     conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
435     if(error != NULL)
436     {
437       fprintf(
438         stderr,
439         "[ERROR] [%s] Failed to fetch message: %s\n",
440         conn-&gt;name,
441         error-&gt;message
442       );
443       g_error_free(error);
444       if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
445         inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
446       return;
447     }
448   }
449   if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
450   {
451     group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
452     queue = g_hash_table_lookup(conn-&gt;group_queues, group);
453     if(queue != NULL &amp;&amp; !g_queue_is_empty(queue))
454     {
455       xml = g_queue_pop_head(queue);
456       fprintf(stderr, "[%s] Replay data (%s, %s)\n", conn-&gt;name, group, xml-&gt;name);
457       inf_test_traffic_replay_connection_check_message(conn, xml);
458       inf_test_traffic_replay_connection_fetch_next_message(conn);
459       xmlFree(group);
460       return;
461     }
462     xmlFree(group);
463   }
464   inf_test_traffic_replay_process_next_message(conn-&gt;replay);
465 }
466 static void
467 inf_test_traffic_replay_process_next_message(InfTestTrafficReplay* replay)
468 {
469   GSList* item;
470   InfTestTrafficReplayConnection* conn;
471   InfTestTrafficReplayConnection* low;
472   if(!inf_standalone_io_loop_running(replay-&gt;io))
473     return;
474   low = NULL;
475   for(item = replay-&gt;conns; item != NULL; item = item-&gt;next)
476   {
477     conn = (InfTestTrafficReplayConnection*)item-&gt;data;
478     if(low == NULL || conn-&gt;message-&gt;timestamp &lt; low-&gt;message-&gt;timestamp)
479       low = conn;
480     else if(conn-&gt;message-&gt;timestamp == low-&gt;message-&gt;timestamp)
481     {
482       if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING &amp;&amp;
483          low-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
484       {
485         low = conn;
486       }
487     }
488   }
489   if(inf_test_traffic_replay_connection_process_next_message(low))
490   {
491     if(g_slist_find(replay-&gt;conns, low))
492       inf_test_traffic_replay_connection_fetch_next_message(low);
493     else
494       inf_test_traffic_replay_process_next_message(replay);
495   }
496 }
497 static void
498 inf_test_traffic_replay_received_cb(InfXmppConnection* connection,
499                                     xmlNodePtr xml,
500                                     gpointer user_data)
501 {
502   InfTestTrafficReplayConnection* conn;
503   xmlBufferPtr buffer;
504   xmlSaveCtxtPtr ctx;
505   xmlNodePtr child;
506   GQueue* queue;
507   xmlChar* received_group;
508   xmlChar* expected_group;
509   conn = (InfTestTrafficReplayConnection*)user_data;
510   g_assert(strcmp(xml-&gt;name, "group") == 0);
511   for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
512   {
513     if(!inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
514       break;
515     if(!conn-&gt;message ||
516        conn-&gt;message-&gt;type != INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
517     {
518       buffer = xmlBufferCreate();
519       ctx = xmlSaveToBuffer(buffer, "UTF-8", 0);
520       xmlSaveTree(ctx, child);
521       xmlSaveClose(ctx);
522       fprintf(
523         stderr,
524         "[ERROR] [%s] Received text \"%s\" without expecting any\n",
525         conn-&gt;name,
526         (const gchar*)xmlBufferContent(buffer)
527       );
528       xmlBufferFree(buffer);
529       inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
530       return;
531     }
532     received_group = xmlGetProp(xml, "name");
533     expected_group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
534     fprintf(
535       stderr,
536       "[%s] Received data (%s, %s), expected %s\n",
537       conn-&gt;name,
538       received_group,
539       child-&gt;name,
540       expected_group
541     );
542     queue = g_hash_table_lookup(conn-&gt;group_queues, expected_group);
543     g_assert(queue == NULL || g_queue_is_empty(queue));
544     if(strcmp(received_group, expected_group) != 0)
545     {
546       queue = g_hash_table_lookup(conn-&gt;group_queues, received_group);
547       if(!queue)
548       {
549         queue = g_queue_new();
550         g_hash_table_insert(
551           conn-&gt;group_queues,
552           g_strdup(received_group),
553           queue
554         );
555       }
556       g_queue_push_tail(queue, xmlCopyNode(child, 1));
557       xmlFree(received_group);
558       xmlFree(expected_group);
559     }
560     else
561     {
562       xmlFree(received_group);
563       xmlFree(expected_group);
564       inf_test_traffic_replay_connection_check_message(conn, child);
565       inf_test_traffic_replay_connection_fetch_next_message(conn);
566     }
567   }
568 }
569 static void
570 inf_test_traffic_replay_notify_status_cb(GObject* object,
571                                          GParamSpec* pspec,
572                                          gpointer user_data)
573 {
574   InfTestTrafficReplayConnection* conn;
575   InfXmlConnectionStatus status;
576   conn = (InfTestTrafficReplayConnection*)user_data;
577   g_object_get(object, "status", &amp;status, NULL);
578   switch(status)
579   {
580   case INF_XML_CONNECTION_OPENING:
581     break;
582   case INF_XML_CONNECTION_OPEN:
583     fprintf(stderr, "[%s] Connected\n", conn-&gt;name);
584     inf_test_traffic_replay_connection_fetch_next_message(conn);
585     break;
586   case INF_XML_CONNECTION_CLOSING:
587   case INF_XML_CONNECTION_CLOSED:
588     fprintf(stderr, "[ERROR] [%s] Remote connection closed\n", conn-&gt;name);
589     inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
590     break;
591   }
592 }
593 static void
594 inf_test_traffic_replay_new_connection_cb(InfdXmppServer* server,
595                                           InfXmppConnection* xmpp,
596                                           gpointer user_data)
597 {
598   InfTestTrafficReplayConnection* conn;
599   InfTestTrafficReplay* replay;
600   InfXmlConnectionStatus status;
601   GError* error;
602   conn = g_slice_new(InfTestTrafficReplayConnection);
603   replay = (InfTestTrafficReplay*)user_data;
604   conn-&gt;name = g_strdup("server");
605   conn-&gt;replay = replay;
606   conn-&gt;creds = NULL;
607   conn-&gt;xmpp = xmpp;
608   conn-&gt;group_queues = g_hash_table_new_full(
609     g_str_hash,
610     g_str_equal,
611     g_free,
612     (GDestroyNotify)inf_test_traffic_replay_queue_free
613   );
614   error = NULL;
615   conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
616   if(error != NULL)
617   {
618     fprintf(
619       stderr,
620       "Failed to read initial message for %s: %s\n",
621       conn-&gt;name,
622       error-&gt;message
623     );
624     inf_test_traffic_replay_connection_close(conn);
625   }
626   replay-&gt;conns = g_slist_prepend(replay-&gt;conns, conn);
627   g_object_ref(xmpp);
628   g_signal_connect(
629     G_OBJECT(xmpp),
630     "received",
631     G_CALLBACK(inf_test_traffic_replay_received_cb),
632     conn
633   );
634   g_signal_connect(
635     G_OBJECT(conn-&gt;xmpp),
636     "notify::status",
637     G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
638     conn
639   );
640   conn-&gt;file = fopen(replay-&gt;filename, "r");
641   if(!conn-&gt;file)
642   {
643     fprintf(
644       stderr,
645       "Failed to open %s: %s\n",
646       replay-&gt;filename,
647       strerror(errno)
648     );
649     inf_test_traffic_replay_connection_close(conn);
650   }
651   else
652   {
653     g_object_get(G_OBJECT(conn-&gt;xmpp), "status", &amp;status, NULL);
654     if(status == INF_XML_CONNECTION_OPEN)
655     {
656       inf_test_traffic_replay_connection_fetch_next_message(conn);
657     }
658   }
659 }
660 static InfCertificateCredentials*
661 inf_test_traffic_replay_load_server_credentials(GError** error)
662 {
663   GPtrArray* array;
664   gnutls_x509_privkey_t key;
665   InfCertificateCredentials* creds;
666   gnutls_certificate_credentials_t gcreds;
667   guint i;
668   key = inf_cert_util_read_private_key(
669     "/home/armin/kombia/kombia.cert",
670     error
671   );
672   if(!key) return NULL;
673   array = inf_cert_util_read_certificate(
674     "/home/armin/kombia/kombia.cert",
675     NULL,
676     error
677   );
678   if(!array) return NULL;
679   creds = inf_certificate_credentials_new();
680   gcreds = inf_certificate_credentials_get(creds);
681   gnutls_certificate_set_x509_key(
682     gcreds,
683     (gnutls_x509_crt_t*)array-&gt;pdata,
684     array-&gt;len,
685     key
686   );
687   gnutls_certificate_set_x509_trust(
688     gcreds,
689     (gnutls_x509_crt_t*)array-&gt;pdata,
690     array-&gt;len
691   );
692   gnutls_x509_privkey_deinit(key);
693   for(i = 0; i &lt; array-&gt;len; ++i)
694     gnutls_x509_crt_deinit(array-&gt;pdata[i]);
695   g_ptr_array_free(array, TRUE);
696   return creds;
697 }
698 static InfCertificateCredentials*
699 inf_test_traffic_replay_load_client_credentials(const gchar* path,
700                                                 GError** error)
701 {
702   gchar* basename;
703   gchar* dirname;
704   gchar* full;
705   GPtrArray* array;
706   gnutls_x509_privkey_t key;
707   InfCertificateCredentials* creds;
708   gnutls_certificate_credentials_t gcreds;
709   guint i;
710   basename = g_path_get_basename(path);
711   dirname = g_path_get_dirname(path);
712   full = g_build_filename(dirname, "certs", basename, NULL);
713   g_free(basename);
714   g_free(dirname);
715   key = inf_cert_util_read_private_key(full, error);
716   if(!key) { g_free(full); return NULL; }
717   array = inf_cert_util_read_certificate(full, NULL, error);
718   if(!array) { g_free(full); return NULL; }
719   g_free(full);
720   creds = inf_certificate_credentials_new();
721   gcreds = inf_certificate_credentials_get(creds);
722   gnutls_certificate_set_x509_key(
723     gcreds,
724     (gnutls_x509_crt_t*)array-&gt;pdata,
725     array-&gt;len,
726     key
727   );
728   gnutls_certificate_set_x509_trust(
729     gcreds,
730     (gnutls_x509_crt_t*)&amp;array-&gt;pdata[array-&gt;len - 1],
731     1
732   );
733   gnutls_x509_privkey_deinit(key);
734   for(i = 0; i &lt; array-&gt;len; ++i)
735     gnutls_x509_crt_deinit(array-&gt;pdata[i]);
736   g_ptr_array_free(array, TRUE);
737   return creds;
738 }
739 static void
740 inf_test_traffic_replay_start_func(gpointer user_data)
741 {
742   inf_test_traffic_replay_process_next_message(user_data);
743 }
744 int main(int argc, char* argv[])
745 {
746   InfTestTrafficReplay replay;
747   InfdTcpServer* server;
748   InfCertificateCredentials* creds;
749   GError* error;
750   gboolean as_server;
751   guint port;
752   int i;
753   FILE* f;
754   InfTestTrafficReplayConnection* conn;
755   as_server = FALSE;
756   port = 6524;
757   if(argc &lt; 2)
758   {
759     fprintf(stderr, "Usage: %s &lt;traffic-log&gt;\n", argv[0]);
760     return -1;
761   }
762   error = NULL;
763   if(!inf_init(&amp;error))
764   {
765     fprintf(stderr, "%s\n", error-&gt;message);
766     g_error_free(error);
767     return -1;
768   }
769   replay.io = inf_standalone_io_new();
770   replay.port = port;
771   replay.xmpp = NULL;
772   replay.conns = NULL;
773   if(as_server == TRUE)
774   {
775     replay.filename = argv[1];
776     creds = inf_test_traffic_replay_load_server_credentials(&amp;error);
777     if(!creds)
778     {
779       fprintf(stderr, "%s\n", error-&gt;message);
780       g_error_free(error);
781       return -1;
782     }
783     server = g_object_new(
784       INFD_TYPE_TCP_SERVER,
785       "io", replay.io,
786       "local-address", NULL,
787       "local-port", port,
788       NULL
789     );
790     replay.xmpp = infd_xmpp_server_new(
791       server,
792       INF_XMPP_CONNECTION_SECURITY_ONLY_TLS,
793       creds,
794       NULL,
795       NULL
796     );
797     inf_certificate_credentials_unref(creds);
798     g_signal_connect(
799       G_OBJECT(replay.xmpp),
800       "new-connection",
801       G_CALLBACK(inf_test_traffic_replay_new_connection_cb),
802       &amp;replay
803     );
804     if(!infd_tcp_server_open(server, &amp;error))
805     {
806       fprintf(stderr, "%s\n", error-&gt;message);
807       g_error_free(error);
808       return 1;
809     }
810     g_object_unref(server);
811   }
812   else
813   {
814     replay.filename = NULL;
815     for(i = 1; i &lt; argc; ++i)
816     {
817       f = fopen(argv[i], "r");
818       if(!f)
819       {
820         fprintf(
821           stderr,
822           "Failed to open %s: %s\n",
823           argv[i],
824           strerror(errno)
825         );
826         return 1;
827       }
828       conn = g_slice_new(InfTestTrafficReplayConnection);
829       conn-&gt;replay = &amp;replay;
830       conn-&gt;name = g_strdup_printf("client %d (%s)", i, argv[i]);
831       conn-&gt;xmpp = NULL;
832       conn-&gt;file = f;
833       conn-&gt;group_queues = g_hash_table_new_full(
834         g_str_hash,
835         g_str_equal,
836         g_free,
837         (GDestroyNotify)inf_test_traffic_replay_queue_free
838       );
839       conn-&gt;creds = inf_test_traffic_replay_load_client_credentials(argv[i], &amp;error);
840       if(error != NULL)
841       {
842         if(error-&gt;domain == G_FILE_ERROR &amp;&amp; error-&gt;code == G_FILE_ERROR_NOENT)
843         {
844           printf("No client credentials for %s\n", conn-&gt;name);
845           g_error_free(error);
846           error = NULL;
847         }
848         else
849         {
850           fprintf(
851             stderr,
852             "Failed to load client credentials for %s: %s\n",
853             conn-&gt;name,
854             error-&gt;message
855           );
856           return 1;
857         }
858       }
859       else
860       {
861         printf("Loaded client credentials for %s\n", conn-&gt;name);
862       }
863       replay.conns = g_slist_prepend(replay.conns, conn);
864       conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
865       if(error != NULL)
866       {
867         fprintf(
868           stderr,
869           "Failed to read initial message for %s: %s\n",
870           conn-&gt;name,
871           error-&gt;message
872         );
873         return 1;
874       }
875     }
876     inf_io_add_dispatch(
877       INF_IO(replay.io),
878       inf_test_traffic_replay_start_func,
879       &amp;replay,
880       NULL
881     );
882   }
883   inf_standalone_io_loop(replay.io);
884   return 0;
885 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftextgtk/inf-text-gtk-view.h&gt;
2 #include &lt;libinfinity/inf-signals.h&gt;
3 <a name="0"></a>#include &lt;gdk/gdk.h&gt;
4 typedef struct _InfTextGtkViewUser InfTextGtkViewUser;
5 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>struct _InfTextGtkViewUser {
6   InfTextGtkView* view;
7   InfTextUser* user;
8   gboolean cursor_visible;
9   InfIoTimeout* timeout;   guint revalidate_idle;
10   GdkRectangle cursor_rect;
11   GdkRectangle selection_bound_rect;
12   gint line_y;
13   gint line_height;
14 };
15 typedef struct _InfTextGtkViewUserToggle InfTextGtkViewUserToggle;
16 struct _InfTextGtkViewUserToggle {
17   InfTextGtkViewUser* user;
18   guint pos;
19   InfTextGtkViewUserToggle* on_toggle;
20   gint x;
21   gint y;
22 };
23 typedef struct _InfTextGtkViewPrivate InfTextGtkViewPrivate;
24 struct _InfTextGtkViewPrivate {
25   InfIo* io;
26   GtkTextView* textview;
27   InfUserTable* user_table;
28   InfTextUser* active_user;
29   GSList* users;
30   gboolean show_remote_cursors;
31   gboolean show_remote_selections;
32   gboolean show_remote_current_lines;
33 };</b></font>
34 enum {
35   PROP_0,
36   PROP_IO,
37   PROP_VIEW,
38   PROP_USER_TABLE,
39   PROP_ACTIVE_USER,
40   PROP_SHOW_REMOTE_CURSORS,
41   PROP_SHOW_REMOTE_SELECTIONS,
42   PROP_SHOW_REMOTE_CURRENT_LINES
43 };
44 #define INF_TEXT_GTK_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_VIEW, InfTextGtkViewPrivate))
45 G_DEFINE_TYPE_WITH_CODE(InfTextGtkView, inf_text_gtk_view, G_TYPE_OBJECT,
46   G_ADD_PRIVATE(InfTextGtkView))
47 static InfTextGtkViewUser*
48 inf_text_gtk_view_find_user(InfTextGtkView* view,
49                             InfTextUser* user)
50 {
51   InfTextGtkViewPrivate* priv;
52   GSList* item;
53   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
54   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
55     if( ((InfTextGtkViewUser*)item-&gt;data)-&gt;user == user)
56       return (InfTextGtkViewUser*)item-&gt;data;
57   return NULL;
58 }
59 static void
60 inf_text_gtk_view_user_compute_user_area(InfTextGtkViewUser* view_user)
61 {
62   InfTextGtkViewPrivate* priv;
63   GtkTextIter iter;
64   gfloat cursor_aspect_ratio;
65   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
66   gtk_widget_style_get(
67     GTK_WIDGET(priv-&gt;textview),
68     "cursor-aspect-ratio", &amp;cursor_aspect_ratio,
69     NULL
70   );
71   gtk_text_buffer_get_iter_at_offset(
72     gtk_text_view_get_buffer(priv-&gt;textview),
73     &amp;iter,
74     inf_text_user_get_caret_position(view_user-&gt;user)
75   );
76   gtk_text_view_get_line_yrange(
77     priv-&gt;textview,
78     &amp;iter,
79     &amp;view_user-&gt;line_y,
80     &amp;view_user-&gt;line_height
81   );
82   gtk_text_view_get_iter_location(
83     priv-&gt;textview,
84     &amp;iter,
85     &amp;view_user-&gt;cursor_rect
86   );
87   view_user-&gt;cursor_rect.width = MAX(
88     (int)(view_user-&gt;cursor_rect.height * cursor_aspect_ratio),
89     1
90   );
91   gtk_text_iter_forward_chars(
92     &amp;iter,
93     inf_text_user_get_selection_length(view_user-&gt;user)
94   );
95   gtk_text_view_get_iter_location(
96     priv-&gt;textview,
97     &amp;iter,
98     &amp;view_user-&gt;selection_bound_rect
99   );
100   view_user-&gt;selection_bound_rect.width = MAX(
101     (int)(view_user-&gt;selection_bound_rect.height * cursor_aspect_ratio),
102     1
103   );
104 }
105 static guint
106 inf_text_gtk_view_get_left_margin(GtkTextView* view)
107 {
108   GtkAdjustment* hadjustment;
109   gint margin;
110   gint hadj;
111   hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));
112   margin = gtk_text_view_get_left_margin(view);
113   if(!hadjustment) return margin;
114   hadj = gtk_adjustment_get_value(hadjustment);
115   if(hadj &lt; margin) return margin - hadj;
116   return 0;
117 }
118 static guint
119 inf_text_gtk_view_get_right_margin(GtkTextView* view)
120 {
121   GtkAdjustment* hadjustment;
122   gint margin;
123   gdouble hadj;
124   gdouble hupper;
125   gdouble hpage;
126   hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));
127   margin = gtk_text_view_get_right_margin(view);
128   if(!hadjustment) return margin;
129   hadj = gtk_adjustment_get_value(hadjustment) + 1;
130   g_object_get(
131     G_OBJECT(hadjustment),
132     "upper", &amp;hupper,
133     "page-size", &amp;hpage,
134     NULL
135   );
136   if(hadj &gt; hupper - hpage - margin)
137     return margin - (gint)(hupper - hpage - hadj);
138   return 0;
139 }
140 static void
141 inf_text_gtk_view_user_invalidate_user_area(InfTextGtkViewUser* view_user)
142 {
143   InfTextGtkViewPrivate* priv;
144   GdkWindow* window;
145   GdkRectangle invalidate_rect;
146   gint selection_bound_x;
147   gint selection_bound_y;
148   gint window_width;
149   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
150   if(gtk_widget_get_realized(GTK_WIDGET(priv-&gt;textview)))
151   {
152     if(priv-&gt;show_remote_cursors || priv-&gt;show_remote_selections ||
153        priv-&gt;show_remote_current_lines)
154     {
155       window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
156       window_width = gdk_window_get_width(window);
157       gtk_text_view_buffer_to_window_coords(
158         priv-&gt;textview,
159         GTK_TEXT_WINDOW_TEXT,
160         view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
161         &amp;invalidate_rect.x, &amp;invalidate_rect.y
162       );
163       invalidate_rect.width = view_user-&gt;cursor_rect.width;
164       invalidate_rect.height = view_user-&gt;cursor_rect.height;
165       if(priv-&gt;show_remote_selections &amp;&amp;
166          (view_user-&gt;selection_bound_rect.x != view_user-&gt;cursor_rect.x ||
167           view_user-&gt;selection_bound_rect.y != view_user-&gt;cursor_rect.y))
168       {
169         gtk_text_view_buffer_to_window_coords(
170           priv-&gt;textview,
171           GTK_TEXT_WINDOW_TEXT,
172           view_user-&gt;selection_bound_rect.x,
173           view_user-&gt;selection_bound_rect.y,
174           &amp;selection_bound_x, &amp;selection_bound_y
175         );
176         if(selection_bound_y == invalidate_rect.y)
177         {
178           if(selection_bound_x &gt; invalidate_rect.x)
179           {
180             invalidate_rect.width = MAX(
181               selection_bound_x - invalidate_rect.x,
182               invalidate_rect.width
183             );
184           }
185           else
186           {
187             invalidate_rect.width += (invalidate_rect.x - selection_bound_x);
188             invalidate_rect.x = selection_bound_x;
189           }
190         }
191         else
192         {
193           invalidate_rect.width = window_width;
194           invalidate_rect.height = MAX(
195             invalidate_rect.y + invalidate_rect.height,
196             selection_bound_y + view_user-&gt;selection_bound_rect.height
197           ) - MIN(invalidate_rect.y, selection_bound_y);
198           invalidate_rect.x =
199             inf_text_gtk_view_get_left_margin(priv-&gt;textview);
200           invalidate_rect.y = MIN(invalidate_rect.y, selection_bound_y);
201           invalidate_rect.width -=
202             inf_text_gtk_view_get_left_margin(priv-&gt;textview) +
203             inf_text_gtk_view_get_right_margin(priv-&gt;textview);
204         }
205         gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
206       }
207       if(priv-&gt;show_remote_current_lines)
208       {
209         gtk_text_view_buffer_to_window_coords(
210           priv-&gt;textview,
211           GTK_TEXT_WINDOW_TEXT,
212           0, view_user-&gt;line_y,
213           NULL, &amp;invalidate_rect.y
214         );
215         invalidate_rect.x =
216           inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
217         invalidate_rect.width = window_width - invalidate_rect.x;
218         invalidate_rect.height = view_user-&gt;line_height;
219       }
220       gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
221     }
222   }
223 }
224 static gint
225 inf_text_gtk_view_user_line_position_cmp(gconstpointer first,
226                                          gconstpointer second)
227 {
228   const InfTextGtkViewUser* first_user;
229   const InfTextGtkViewUser* second_user;
230   first_user = (const InfTextGtkViewUser*)first;
231   second_user = (const InfTextGtkViewUser*)second;
232   if(second_user-&gt;line_y &lt; first_user-&gt;line_y)
233     return 1;
234   else if(second_user-&gt;line_y &gt; first_user-&gt;line_y)
235     return -1;
236   return 0;
237 }
238 static gint
239 inf_text_gtk_view_user_toggle_position_cmp(gconstpointer first,
240                                            gconstpointer second,
241                                            gpointer user_data)
242 {
243   const InfTextGtkViewUserToggle* first_toggle;
244   const InfTextGtkViewUserToggle* second_toggle;
245   first_toggle = (const InfTextGtkViewUserToggle*)first;
246   second_toggle = (const InfTextGtkViewUserToggle*)second;
247   if(second_toggle-&gt;pos &lt; first_toggle-&gt;pos)
248     return 1;
249   else if(second_toggle-&gt;pos &gt; first_toggle-&gt;pos)
250     return -1;
251   return 0;
252 }
253 static gint
254 inf_text_gtk_view_user_toggle_user_cmp(gconstpointer first,
255                                        gconstpointer second)
256 {
257   const InfTextGtkViewUserToggle* first_toggle;
258   const InfTextGtkViewUserToggle* second_toggle;
259   guint first_id;
260   guint second_id;
261   first_toggle = (const InfTextGtkViewUserToggle*)first;
262   second_toggle = (const InfTextGtkViewUserToggle*)second;
263   first_id = inf_user_get_id(INF_USER(first_toggle-&gt;user-&gt;user));
264   second_id = inf_user_get_id(INF_USER(second_toggle-&gt;user-&gt;user));
265   if(second_id &lt; first_id)
266     return 1;
267   else if(second_id &gt; first_id)
268     return -1;
269   return 0;
270 }
271 static void
272 inf_text_gtk_view_user_toggle_free(gpointer data)
273 {
274   g_slice_free(InfTextGtkViewUserToggle, data);
275 }
276 static InfTextGtkViewUserToggle*
277 inf_text_gtk_view_add_user_toggle(GSequence* sequence,
278                                   guint position,
279                                   InfTextGtkViewUser* user,
280                                   InfTextGtkViewUserToggle* on_toggle,
281                                   gint x,
282                                   gint y)
283 {
284   InfTextGtkViewUserToggle* toggle;
285   toggle = g_slice_new(InfTextGtkViewUserToggle);
286   toggle-&gt;user = user;
287   toggle-&gt;pos = position;
288   toggle-&gt;on_toggle = on_toggle;
289   toggle-&gt;x = x;
290   toggle-&gt;y = y;
291   g_sequence_insert_sorted(
292     sequence,
293     toggle,
294     inf_text_gtk_view_user_toggle_position_cmp,
295     NULL
296   );
297   return toggle;
298 }
299 static void
300 inf_text_gtk_view_add_user_toggle_pair(GSequence* sequence,
301                                        guint begin,
302                                        guint end,
303                                        InfTextGtkViewUser* user,
304                                        gint begin_x,
305                                        gint begin_y,
306                                        gint end_x,
307                                        gint end_y)
308 {
309   InfTextGtkViewUserToggle* begin_toggle;
310   g_assert(end &gt; begin);
311   begin_toggle = inf_text_gtk_view_add_user_toggle(
312     sequence,
313     begin,
314     user,
315     NULL,
316     begin_x,
317     begin_y
318   );
319   inf_text_gtk_view_add_user_toggle(
320     sequence,
321     end,
322     user,
323     begin_toggle,
324     end_x,
325     end_y
326   );
327 }
328 static gboolean
329 inf_text_gtk_view_draw_before_cb(GtkWidget* widget,
330                                  cairo_t* cr,
331                                  gpointer user_data)
332 {
333   InfTextGtkView* view;
334   InfTextGtkViewPrivate* priv;
335   GSList* item;
336   GSList* prev_item;
337   InfTextGtkViewUser* prev_user;
338   InfTextGtkViewUser* view_user;
339   GtkAdjustment* hadjustment;
340   GtkAdjustment* vadjustment;
341   GdkWindow *text_window;
342   GtkStyleContext* style;
343   GdkRGBA bg;
344   double h, s, v;
345   double r, g, b;
346   GSList* sort_users;
347   GdkRectangle rect;
348   gint window_width;
349   gint rx, ry;
350   GdkRectangle clip_area;
351   cairo_pattern_t* pattern;
352   double n, n_users;
353   cairo_matrix_t matrix;
354   view = INF_TEXT_GTK_VIEW(user_data);
355   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
356   text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
357   if(!gtk_cairo_should_draw_window(cr, text_window))
358   {
359     return FALSE;
360   }
361   if(priv-&gt;show_remote_current_lines)
362   {
363     gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
364     gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
365     window_width = gdk_window_get_width(text_window);
366     style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
367     gtk_style_context_save(style);
368     gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
369     gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &amp;bg);
370     gtk_style_context_restore(style);
371     gtk_rgb_to_hsv(bg.red, bg.green, bg.blue, &amp;h, &amp;s, &amp;v);
372     v = MAX(v, 0.3);
373     s = MAX(s, 0.1 + 0.3*(1 - v));
374     sort_users = g_slist_copy(priv-&gt;users);
375     sort_users =
376       g_slist_sort(sort_users, inf_text_gtk_view_user_line_position_cmp);
377     prev_item = sort_users;
378     if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
379     n_users = 1.0;
380     for(item = sort_users; item != NULL; item = item-&gt;next, n_users += 1.0)
381     {
382       if(item-&gt;next == NULL ||
383          ((InfTextGtkViewUser*)item-&gt;next-&gt;data)-&gt;line_y != prev_user-&gt;line_y)
384       {
385         gtk_text_view_buffer_to_window_coords(
386           priv-&gt;textview,
387           GTK_TEXT_WINDOW_TEXT,
388           0, prev_user-&gt;line_y,
389           NULL, &amp;rect.y
390         );
391         rect.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
392         rect.width = window_width - rect.x;
393         rect.height = prev_user-&gt;line_height;
394         if(gdk_rectangle_intersect(&amp;clip_area, &amp;rect, NULL))
395         {
396           hadjustment =
397             gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
398           vadjustment =
399             gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));
400           rx = gtk_adjustment_get_value(vadjustment);
401           ry = gtk_adjustment_get_value(hadjustment);
402           pattern =
403             cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
404           cairo_matrix_init_translate(&amp;matrix, rx, ry);
405           cairo_pattern_set_matrix(pattern, &amp;matrix);
406           cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
407           for(n = 0.0;
408               prev_item != item-&gt;next;
409               prev_item = prev_item-&gt;next, n += 1.0)
410           {
411             view_user = (InfTextGtkViewUser*)prev_item-&gt;data;
412             h = inf_text_user_get_hue(view_user-&gt;user);
413             gtk_hsv_to_rgb(h, s, v, &amp;r, &amp;g, &amp;b);
414             cairo_pattern_add_color_stop_rgb(
415               pattern,
416               n/n_users,
417               r, g, b
418             );
419             cairo_pattern_add_color_stop_rgb(
420               pattern,
421               (n+1.0)/n_users,
422               r, g, b
423             );
424           }
425           cairo_set_source(cr, pattern);
426           gdk_cairo_rectangle(cr, &amp;rect);
427           cairo_fill(cr);
428           cairo_pattern_destroy(pattern);
429         }
430         prev_item = item-&gt;next;
431         if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
432         n_users = 0.0;
433       }
434     }
435     g_slist_free(sort_users);
436   }
437   return FALSE;
438 }
439 static gboolean
440 inf_text_gtk_view_draw_after_cb(GtkWidget* widget,
441                                 cairo_t* cr,
442                                 gpointer user_data)
443 {
444   InfTextGtkView* view;
445   InfTextGtkViewPrivate* priv;
446   gint window_width;
447   GtkStyleContext* style;
448   GdkColor* cursor_color;
449   GdkRGBA fg;
450   double hc,sc,vc;
451   double hs,ss,vs;
452   GSList* item;
453   InfTextGtkViewUser* view_user;
454   double rc,gc,bc;
455   double rs,gs,bs;
456   GdkRectangle clip_area;
457   gint ax, ay;
458   GtkTextIter begin_iter;
459   GtkTextIter end_iter;
460   guint area_begin;
461   guint area_end;
462   guint own_sel_begin;
463   guint own_sel_end;
464   gint osbx, osby;
465   gint osex, osey;
466   gint sel;
467   guint begin;
468   guint end;
469   GSequence* toggles;
470   GSequenceIter* tog_iter;
471   InfTextGtkViewUserToggle* cur_toggle;
472   InfTextGtkViewUserToggle* prev_toggle;
473   guint n_users;
474   GSList* users;
475   cairo_pattern_t* pattern;
476   GtkAdjustment* hadjustment;
477   GtkAdjustment* vadjustment;
478   double n;
479   cairo_matrix_t matrix;
480   GdkRectangle rct;
481   gint rx, ry;
482   GdkWindow *text_window;
483   view = INF_TEXT_GTK_VIEW(user_data);
484   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
485   text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
486   if(!gtk_cairo_should_draw_window(cr, text_window))
487   {
488     return FALSE;
489   }
490   gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
491   gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
492   style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
493   gtk_style_context_save(style);
494   gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
495   gtk_style_context_get_color(style, GTK_STATE_FLAG_NORMAL, &amp;fg);
496   gtk_style_context_restore(style);
497   if(priv-&gt;show_remote_selections)
498   {
499     window_width = gdk_window_get_width(text_window);
500     gtk_rgb_to_hsv(fg.red, fg.green, fg.blue, &amp;hs, &amp;ss, &amp;vs);
501     vs = MAX(vs, 0.5);
502     ss = 1.0 - 0.4*(vs);
503     gtk_text_view_window_to_buffer_coords(
504       priv-&gt;textview,
505       GTK_TEXT_WINDOW_TEXT,
506       clip_area.x, clip_area.y,
507       &amp;ax, &amp;ay
508     );
509     gtk_text_view_get_iter_at_location(
510       priv-&gt;textview,
511       &amp;begin_iter,
512       ax,
513       ay
514     );
515     gtk_text_view_get_iter_at_location(
516       priv-&gt;textview,
517       &amp;end_iter,
518       ax + clip_area.width,
519       ay + clip_area.height
520     );
521     area_begin = gtk_text_iter_get_offset(&amp;begin_iter);
522     area_end = gtk_text_iter_get_offset(&amp;end_iter);
523     g_assert(area_end &gt;= area_begin);
524     gtk_text_buffer_get_selection_bounds(
525       gtk_text_view_get_buffer(priv-&gt;textview),
526       &amp;begin_iter,
527       &amp;end_iter
528     );
529     own_sel_begin = gtk_text_iter_get_offset(&amp;begin_iter);
530     own_sel_end = gtk_text_iter_get_offset(&amp;end_iter);
531     if(own_sel_begin != own_sel_end)
532     {
533       gtk_text_view_get_iter_location(priv-&gt;textview, &amp;begin_iter, &amp;rct);
534       gtk_text_view_buffer_to_window_coords(
535         priv-&gt;textview,
536         GTK_TEXT_WINDOW_TEXT,
537         rct.x, rct.y,
538         &amp;osbx, &amp;osby
539       );
540       gtk_text_view_get_iter_location(priv-&gt;textview, &amp;end_iter, &amp;rct);
541       gtk_text_view_buffer_to_window_coords(
542         priv-&gt;textview,
543         GTK_TEXT_WINDOW_TEXT,
544         rct.x, rct.y,
545         &amp;osex, &amp;osey
546       );
547     }
548     toggles = g_sequence_new(inf_text_gtk_view_user_toggle_free);
549     for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
550     {
551       view_user = (InfTextGtkViewUser*)item-&gt;data;
552       if(inf_text_user_get_selection_length(view_user-&gt;user) != 0)
553       {
554         begin = inf_text_user_get_caret_position(view_user-&gt;user);
555         sel = inf_text_user_get_selection_length(view_user-&gt;user);
556         if(sel &gt; 0)
557         {
558           end = begin + sel;
559         }
560         else
561         {
562           g_assert(begin &gt;= (unsigned int)-sel);
563           end = begin;
564           begin += sel;
565         }
566         if(begin &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
567           begin = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
568         if(end &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
569           end = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
570         begin = MIN(MAX(begin, area_begin), area_end);
571         end = MIN(MAX(end, area_begin), area_end);
572         g_assert(end &gt;= begin);
573         if(begin != end)
574         {
575           if(sel &gt; 0)
576           {
577             gtk_text_view_buffer_to_window_coords(
578               priv-&gt;textview,
579               GTK_TEXT_WINDOW_TEXT,
580               view_user-&gt;cursor_rect.x,
581               view_user-&gt;cursor_rect.y,
582               &amp;rx, &amp;ry
583             );
584             gtk_text_view_buffer_to_window_coords(
585               priv-&gt;textview,
586               GTK_TEXT_WINDOW_TEXT,
587               view_user-&gt;selection_bound_rect.x,
588               view_user-&gt;selection_bound_rect.y,
589               &amp;ax, &amp;ay
590             );
591           }
592           else
593           {
594             gtk_text_view_buffer_to_window_coords(
595               priv-&gt;textview,
596               GTK_TEXT_WINDOW_TEXT,
597               view_user-&gt;selection_bound_rect.x,
598               view_user-&gt;selection_bound_rect.y,
599               &amp;rx, &amp;ry
600             );
601             gtk_text_view_buffer_to_window_coords(
602               priv-&gt;textview,
603               GTK_TEXT_WINDOW_TEXT,
604               view_user-&gt;cursor_rect.x,
605               view_user-&gt;cursor_rect.y,
606               &amp;ax, &amp;ay
607             );
608           }
609           if(own_sel_begin == own_sel_end ||
610              own_sel_end &lt;= begin || own_sel_begin &gt;= end)
611           {
612             inf_text_gtk_view_add_user_toggle_pair(
613               toggles,
614               begin, end,
615               view_user,
616               rx, ry,
617               ax, ay
618             );
619           }
620           else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &gt;= end)
621           {
622           }
623           else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &gt;= end)
624           {
625             inf_text_gtk_view_add_user_toggle_pair(
626               toggles,
627               begin, own_sel_begin,
628               view_user,
629               rx, ry,
630               osbx, osby
631             );
632           }
633           else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &lt; end)
634           {
635             inf_text_gtk_view_add_user_toggle_pair(
636               toggles,
637               own_sel_end, end,
638               view_user,
639               osex, osey,
640               ax, ay
641             );
642           }
643           else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &lt; end)
644           {
645             inf_text_gtk_view_add_user_toggle_pair(
646               toggles,
647               begin, own_sel_begin,
648               view_user,
649               rx, ry,
650               osbx, osby
651             );
652             inf_text_gtk_view_add_user_toggle_pair(
653               toggles,
654               own_sel_end, end,
655               view_user,
656               osex, osey,
657               ax, ay
658             );
659           }
660           else
661           {
662             g_assert_not_reached();
663           }
664         }
665       }
666     }
667     tog_iter = g_sequence_get_begin_iter(toggles);
668     cur_toggle = NULL;
669     prev_toggle = NULL;
670     users = NULL;
671     n_users = 0;
672     tog_iter = g_sequence_get_begin_iter(toggles);
673     while(!g_sequence_iter_is_end(tog_iter))
674     {
675       cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
676       if(users != NULL)
677       {
678         g_assert(prev_toggle != NULL);
679         g_assert(n_users &gt; 0);
680         hadjustment =
681           gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
682         vadjustment =
683           gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));
684         rx = gtk_adjustment_get_value(hadjustment);
685         ry = gtk_adjustment_get_value(vadjustment);
686         pattern =
687           cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
688         cairo_matrix_init_translate(&amp;matrix, rx, ry);
689         cairo_pattern_set_matrix(pattern, &amp;matrix);
690         cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
691         for(item = users, n = 0.0; item != NULL; item = item-&gt;next, n += 1.0)
692         {
693           view_user = ((InfTextGtkViewUserToggle*)item-&gt;data)-&gt;user;
694           hs = inf_text_user_get_hue(view_user-&gt;user);
695           gtk_hsv_to_rgb(hs, ss, vs, &amp;rs, &amp;gs, &amp;bs);
696           cairo_pattern_add_color_stop_rgba(
697             pattern,
698             n/n_users,
699             rs, gs, bs, 0.5
700           );
701           cairo_pattern_add_color_stop_rgba(
702             pattern,
703             (n+1.0)/n_users,
704             rs, gs, bs, 0.5
705           );
706         }
707         cairo_set_source(cr, pattern);
708         if(prev_toggle-&gt;y == cur_toggle-&gt;y)
709         {
710           g_assert(prev_toggle-&gt;x &lt; cur_toggle-&gt;x);
711           rct.x = prev_toggle-&gt;x;
712           rct.y = prev_toggle-&gt;y;
713           rct.width = cur_toggle-&gt;x - prev_toggle-&gt;x;
714           rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
715           gdk_cairo_rectangle(cr, &amp;rct);
716         }
717         else
718         {
719           g_assert(
720             cur_toggle-&gt;y - prev_toggle-&gt;y &gt;=
721             cur_toggle-&gt;user-&gt;selection_bound_rect.height
722           );
723           if(window_width &gt; prev_toggle-&gt;x)
724           {
725             rct.x = prev_toggle-&gt;x;
726             rct.y = prev_toggle-&gt;y;
727             rct.width = window_width - prev_toggle-&gt;x -
728               inf_text_gtk_view_get_right_margin(priv-&gt;textview);
729             rct.height = prev_toggle-&gt;user-&gt;selection_bound_rect.height;
730             gdk_cairo_rectangle(cr, &amp;rct);
731           }
732           if(cur_toggle-&gt;x &gt; 0)
733           {
734             rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
735             rct.y = cur_toggle-&gt;y;
736             rct.width = cur_toggle-&gt;x - rct.x;
737             rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
738             gdk_cairo_rectangle(cr, &amp;rct);
739           }
740           if(cur_toggle-&gt;y - prev_toggle-&gt;y &gt;
741              cur_toggle-&gt;user-&gt;selection_bound_rect.height)
742           {
743             rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
744             rct.y = prev_toggle-&gt;y +
745               prev_toggle-&gt;user-&gt;selection_bound_rect.height;
746             rct.width = window_width - rct.x -
747               inf_text_gtk_view_get_right_margin(priv-&gt;textview);
748             rct.height = cur_toggle-&gt;y - prev_toggle-&gt;y -
749               cur_toggle-&gt;user-&gt;selection_bound_rect.height;
750             gdk_cairo_rectangle(cr, &amp;rct);
751           }
752         }
753         cairo_fill(cr);
754         cairo_pattern_destroy(pattern);
755       }
756       prev_toggle = cur_toggle;
757       do
758       {
759         if(cur_toggle-&gt;on_toggle == NULL)
760         {
761           users = g_slist_insert_sorted(
762             users,
763             cur_toggle,
764             inf_text_gtk_view_user_toggle_user_cmp
765           );
766           ++n_users;
767         }
768         else
769         {
770           g_assert(n_users &gt; 0);
771           users = g_slist_remove(users, cur_toggle-&gt;on_toggle);
772           --n_users;
773         }
774         tog_iter = g_sequence_iter_next(tog_iter);
775         if(g_sequence_iter_is_end(tog_iter))
776           break;
777         cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
778       } while(cur_toggle-&gt;pos == prev_toggle-&gt;pos);
779     }
780     g_assert(n_users == 0);
781     g_assert(users == NULL);
782     g_sequence_free(toggles);
783   }
784   if(priv-&gt;show_remote_cursors)
785   {
786     gtk_widget_style_get (widget, "cursor-color", &amp;cursor_color, NULL);
787     if(cursor_color != NULL)
788     {
789       rc = cursor_color-&gt;red / 65535.0;
790       bc = cursor_color-&gt;green / 65535.0;
791       gc = cursor_color-&gt;blue / 65535.0;
792       gdk_color_free(cursor_color);
793     }
794     else
795     {
796       rc = fg.red;
797       bc = fg.green;
798       gc = fg.blue;
799     }
800     gtk_rgb_to_hsv(rc, bc, gc, &amp;hc, &amp;sc, &amp;vc);
801     sc = MIN(MAX(sc, 0.3), 0.8);
802     vc = MAX(vc, 0.7);
803     for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
804     {
805       view_user = (InfTextGtkViewUser*)item-&gt;data;
806       if(view_user-&gt;cursor_visible)
807       {
808         gtk_text_view_buffer_to_window_coords(
809           priv-&gt;textview,
810           GTK_TEXT_WINDOW_TEXT,
811           view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
812           &amp;rct.x, &amp;rct.y
813         );
814         rct.width = view_user-&gt;cursor_rect.width;
815         rct.height = view_user-&gt;cursor_rect.height;
816         if(gdk_rectangle_intersect(&amp;clip_area, &amp;rct, NULL))
817         {
818           hc = inf_text_user_get_hue(view_user-&gt;user);
819           gtk_hsv_to_rgb(hc, sc, vc, &amp;rc, &amp;gc, &amp;bc);
820           cairo_set_source_rgb(cr, rc, gc, bc);
821           gdk_cairo_rectangle(cr, &amp;rct);
822           cairo_fill(cr);
823         }
824       }
825     }
826   }
827   return FALSE;
828 }
829 static void
830 inf_text_gtk_view_style_updated_cb(GtkWidget* widget,
831                                    gpointer user_data)
832 {
833   InfTextGtkView* view;
834   InfTextGtkViewPrivate* priv;
835   GSList* item;
836   InfTextGtkViewUser* view_user;
837   view = INF_TEXT_GTK_VIEW(user_data);
838   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
839   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
840   {
841     view_user = (InfTextGtkViewUser*)item-&gt;data;
842     inf_text_gtk_view_user_compute_user_area(view_user);
843   }
844 }
845 static void
846 inf_text_gtk_view_size_allocate_cb(GtkWidget* widget,
847                                    GtkAllocation* allocation,
848                                    gpointer user_data)
849 {
850   InfTextGtkView* view;
851   InfTextGtkViewPrivate* priv;
852   GSList* item;
853   InfTextGtkViewUser* view_user;
854   view = INF_TEXT_GTK_VIEW(user_data);
855   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
856   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
857   {
858     view_user = (InfTextGtkViewUser*)item-&gt;data;
859     inf_text_gtk_view_user_compute_user_area(view_user);
860   }
861 }
862 static void
863 inf_text_gtk_view_user_cursor_blink_timeout_func(gpointer user_data)
864 {
865   InfTextGtkViewUser* view_user;
866   InfTextGtkViewPrivate* priv;
867   GtkSettings* settings;
868   gboolean cursor_blink;
869   gint cursor_blink_time;
870   view_user = (InfTextGtkViewUser*)user_data;
871   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
872   view_user-&gt;cursor_visible = !view_user-&gt;cursor_visible;
873   inf_text_gtk_view_user_invalidate_user_area(view_user);
874   settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));
875   g_object_get(
876     G_OBJECT(settings),
877     "gtk-cursor-blink", &amp;cursor_blink,
878     "gtk-cursor-blink-time", &amp;cursor_blink_time,
879     NULL
880   );
881   if(cursor_blink)
882   {
883     if(!view_user-&gt;cursor_visible)
884       cursor_blink_time = cursor_blink_time * 1 / 3;
885     else
886       cursor_blink_time = cursor_blink_time * 2 / 3;
887     view_user-&gt;timeout = inf_io_add_timeout(
888       priv-&gt;io,
889       cursor_blink_time,
890       inf_text_gtk_view_user_cursor_blink_timeout_func,
891       view_user,
892       NULL
893     );
894   }
895   else
896   {
897     view_user-&gt;timeout = NULL;
898   }
899 }
900 static void
901 inf_text_gtk_view_user_reset_timeout(InfTextGtkViewUser* view_user)
902 {
903   InfTextGtkViewPrivate* priv;
904   GtkSettings* settings;
905   gboolean cursor_blink;
906   gint cursor_blink_time;
907   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
908   if(view_user-&gt;timeout)
909   {
910     inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
911     view_user-&gt;timeout = NULL;
912   }
913   if(!view_user-&gt;cursor_visible)
914   {
915     view_user-&gt;cursor_visible = TRUE;
916     inf_text_gtk_view_user_invalidate_user_area(view_user);
917   }
918   settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));
919   g_object_get(
920     G_OBJECT(settings),
921     "gtk-cursor-blink", &amp;cursor_blink,
922     "gtk-cursor-blink-time", &amp;cursor_blink_time,
923     NULL
924   );
925   if(cursor_blink)
926   {
927     view_user-&gt;timeout = inf_io_add_timeout(
928       priv-&gt;io,
929       cursor_blink_time,
930       inf_text_gtk_view_user_cursor_blink_timeout_func,
931       view_user,
932       NULL
933     );
934   }
935 }
936 static gboolean
937 inf_text_gtk_view_user_selection_changed_cb_idle_func(gpointer user_data)
938 {
939   InfTextGtkViewUser* view_user;
940   view_user = (InfTextGtkViewUser*)user_data;
941   g_assert(view_user-&gt;revalidate_idle != 0);
942   view_user-&gt;revalidate_idle = 0;
943   inf_text_gtk_view_user_invalidate_user_area(view_user);
944   return FALSE;
945 }
946 static void
947 inf_text_gtk_view_user_selection_changed_cb(InfTextUser* user,
948                                             guint position,
949                                             gint length,
950                                             gboolean by_request,
951                                             gpointer user_data)
952 {
953   InfTextGtkViewUser* view_user;
954   InfTextGtkViewPrivate* priv;
955   view_user = (InfTextGtkViewUser*)user_data;
956   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
957   if(by_request)
958   {
959     inf_text_gtk_view_user_invalidate_user_area(view_user);
960   }
961   inf_text_gtk_view_user_compute_user_area(view_user);
962   if(by_request)
963   {
964     inf_text_gtk_view_user_reset_timeout(view_user);
965     if(view_user-&gt;revalidate_idle == 0)
966     {
967       view_user-&gt;revalidate_idle = g_idle_add_full(
968         GTK_TEXT_VIEW_PRIORITY_VALIDATE + 1,
969         inf_text_gtk_view_user_selection_changed_cb_idle_func,
970         view_user,
971         NULL
972       );
973     }
974   }
975 }
976 static void
977 inf_text_gtk_view_user_notify_hue_cb(GObject* object,
978                                      GParamSpec* pspec,
979                                      gpointer user_data)
980 {
981   InfTextGtkViewUser* view_user;
982   InfTextGtkViewPrivate* priv;
983   view_user = (InfTextGtkViewUser*)user_data;
984   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
985   gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
986 }
987 static void
988 inf_text_gtk_view_add_user(InfTextGtkView* view,
989                            InfTextUser* user)
990 {
991   InfTextGtkViewPrivate* priv;
992   InfTextGtkViewUser* view_user;
993   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
994   view_user = g_slice_new(InfTextGtkViewUser);
995   view_user-&gt;view = view;
996   view_user-&gt;user = INF_TEXT_USER(user);
997   view_user-&gt;cursor_visible = TRUE;
998   view_user-&gt;timeout = NULL;
999   view_user-&gt;revalidate_idle = 0;
1000   inf_text_gtk_view_user_compute_user_area(view_user);
1001   inf_text_gtk_view_user_reset_timeout(view_user);
1002   priv-&gt;users = g_slist_prepend(priv-&gt;users, view_user);
1003   g_signal_connect_after(
1004     user,
1005     "selection-changed",
1006     G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
1007     view_user
1008   );
1009   g_signal_connect(
1010     user,
1011     "notify::hue",
1012     G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
1013     view_user
1014   );
1015   inf_text_gtk_view_user_invalidate_user_area(view_user);
1016 }
1017 static void
1018 inf_text_gtk_view_remove_user(InfTextGtkViewUser* view_user)
1019 {
1020   InfTextGtkViewPrivate* priv;
1021   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
1022   inf_signal_handlers_disconnect_by_func(
1023     view_user-&gt;user,
1024     G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
1025     view_user
1026   );
1027   inf_signal_handlers_disconnect_by_func(
1028     view_user-&gt;user,
1029     G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
1030     view_user
1031   );
1032   if(view_user-&gt;timeout != NULL)
1033     inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
1034   if(view_user-&gt;revalidate_idle != 0)
1035     g_source_remove(view_user-&gt;revalidate_idle);
1036   inf_text_gtk_view_user_invalidate_user_area(view_user);
1037   priv-&gt;users = g_slist_remove(priv-&gt;users, view_user);
1038   g_slice_free(InfTextGtkViewUser, view_user);
1039 }
1040 static void
1041 inf_text_gtk_view_user_notify_status_cb(GObject* object,
1042                                         GParamSpec* pspec,
1043                                         gpointer user_data)
1044 {
1045   InfTextGtkView* view;
1046   InfTextGtkViewPrivate* priv;
1047   InfTextUser* user;
1048   InfTextGtkViewUser* view_user;
1049   view = INF_TEXT_GTK_VIEW(user_data);
1050   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1051   user = INF_TEXT_USER(object);
1052   g_assert(user != priv-&gt;active_user);
1053   view_user = inf_text_gtk_view_find_user(view, user);
1054   if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1055   {
1056     if(!view_user)
1057       inf_text_gtk_view_add_user(view, user);
1058   }
1059   else
1060   {
1061     if(view_user)
1062       inf_text_gtk_view_remove_user(view_user);
1063   }
1064 }
1065 static void
1066 inf_text_gtk_view_user_removed(InfTextGtkView* view,
1067                                InfTextUser* user)
1068 {
1069   InfTextGtkViewPrivate* priv;
1070   InfTextGtkViewUser* view_user;
1071   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1072   if(user == priv-&gt;active_user)
1073   {
1074     priv-&gt;active_user = NULL;
1075     g_object_notify(G_OBJECT(view), "active-user");
1076   }
1077   else
1078   {
1079     inf_signal_handlers_disconnect_by_func(
1080       user,
1081       G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
1082       view
1083     );
1084     if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1085     {
1086       view_user = inf_text_gtk_view_find_user(view, user);
1087       g_assert(view_user != NULL);
1088       inf_text_gtk_view_remove_user(view_user);
1089     }
1090   }
1091 }
1092 static void
1093 inf_text_gtk_view_user_added(InfTextGtkView* view,
1094                              InfTextUser* user)
1095 {
1096   InfTextGtkViewPrivate* priv;
1097   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1098   g_assert(user != priv-&gt;active_user);
1099   g_signal_connect(
1100     user,
1101     "notify::status",
1102     G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
1103     view
1104   );
1105   if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1106     inf_text_gtk_view_add_user(view, user);
1107 }
1108 static void
1109 inf_text_gtk_view_add_user_cb(InfUserTable* user_table,
1110                               InfUser* user,
1111                               gpointer user_data)
1112 {
1113   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1114   g_assert(INF_TEXT_IS_USER(user));
1115   inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
1116 }
1117 static void
1118 inf_text_gtk_view_remove_user_cb(InfUserTable* user_table,
1119                                  InfUser* user,
1120                                  gpointer user_data)
1121 {
1122   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1123   g_assert(INF_TEXT_IS_USER(user));
1124   inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
1125 }
1126 static void
1127 inf_text_gtk_view_set_user_table_foreach_new_user_func(InfUser* user,
1128                                                        gpointer user_data)
1129 {
1130   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1131   g_assert(INF_TEXT_IS_USER(user));
1132   inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
1133 }
1134 static void
1135 inf_text_gtk_view_set_user_table_foreach_old_user_func(InfUser* user,
1136                                                        gpointer user_data)
1137 {
1138   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1139   g_assert(INF_TEXT_IS_USER(user));
1140   inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
1141 }
1142 static void
1143 inf_text_gtk_view_set_view(InfTextGtkView* view,
1144                            GtkTextView* gtk_view)
1145 {
1146   InfTextGtkViewPrivate* priv;
1147   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1148   if(priv-&gt;textview != NULL)
1149   {
1150     inf_signal_handlers_disconnect_by_func(
1151       G_OBJECT(priv-&gt;textview),
1152       G_CALLBACK(inf_text_gtk_view_draw_before_cb),
1153       view
1154     );
1155     inf_signal_handlers_disconnect_by_func(
1156       G_OBJECT(priv-&gt;textview),
1157       G_CALLBACK(inf_text_gtk_view_draw_after_cb),
1158       view
1159     );
1160     inf_signal_handlers_disconnect_by_func(
1161       G_OBJECT(priv-&gt;textview),
1162       G_CALLBACK(inf_text_gtk_view_style_updated_cb),
1163       view
1164     );
1165     inf_signal_handlers_disconnect_by_func(
1166       G_OBJECT(priv-&gt;textview),
1167       G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
1168       view
1169     );
1170     g_object_unref(priv-&gt;textview);
1171   }
1172   priv-&gt;textview = gtk_view;
1173   if(gtk_view != NULL)
1174   {
1175     g_object_ref(gtk_view);
1176     g_signal_connect(
1177       G_OBJECT(gtk_view),
1178       "draw",
1179       G_CALLBACK(inf_text_gtk_view_draw_before_cb),
1180       view
1181     );
1182     g_signal_connect_after(
1183       G_OBJECT(gtk_view),
1184       "draw",
1185       G_CALLBACK(inf_text_gtk_view_draw_after_cb),
1186       view
1187     );
1188     g_signal_connect_after(
1189       G_OBJECT(gtk_view),
1190       "style-updated",
1191       G_CALLBACK(inf_text_gtk_view_style_updated_cb),
1192       view
1193     );
1194     g_signal_connect_after(
1195       G_OBJECT(gtk_view),
1196       "size-allocate",
1197       G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
1198       view
1199     );
1200   }
1201   g_object_notify(G_OBJECT(view), "view");
1202 }
1203 static void
1204 inf_text_gtk_view_set_user_table(InfTextGtkView* view,
1205                                  InfUserTable* user_table)
1206 {
1207   InfTextGtkViewPrivate* priv;
1208   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1209   if(priv-&gt;user_table != NULL)
1210   {
1211     inf_signal_handlers_disconnect_by_func(
1212       G_OBJECT(priv-&gt;user_table),
1213       G_CALLBACK(inf_text_gtk_view_add_user_cb),
1214       view
1215     );
1216     inf_signal_handlers_disconnect_by_func(
1217       G_OBJECT(priv-&gt;user_table),
1218       G_CALLBACK(inf_text_gtk_view_remove_user_cb),
1219       view
1220     );
1221     inf_user_table_foreach_user(
1222       priv-&gt;user_table,
1223       inf_text_gtk_view_set_user_table_foreach_old_user_func,
1224       view
1225     );
1226     g_object_unref(priv-&gt;user_table);
1227   }
1228   priv-&gt;user_table = user_table;
1229   if(user_table != NULL)
1230   {
1231     g_object_ref(user_table);
1232     g_signal_connect(
1233       G_OBJECT(user_table),
1234       "add-user",
1235       G_CALLBACK(inf_text_gtk_view_add_user_cb),
1236       view
1237     );
1238     g_signal_connect(
1239       G_OBJECT(user_table),
1240       "remove-user",
1241       G_CALLBACK(inf_text_gtk_view_remove_user_cb),
1242       view
1243     );
1244     inf_user_table_foreach_user(
1245       user_table,
1246       inf_text_gtk_view_set_user_table_foreach_new_user_func,
1247       view
1248     );
1249   }
1250   g_object_notify(G_OBJECT(view), "user-table");
1251 }
1252 static void
1253 inf_text_gtk_view_init(InfTextGtkView* view)
1254 {
1255   InfTextGtkViewPrivate* priv;
1256   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1257   priv-&gt;io = NULL;
1258   priv-&gt;textview = NULL;
1259   priv-&gt;user_table = NULL;
1260   priv-&gt;active_user = NULL;
1261   priv-&gt;users = NULL;
1262   priv-&gt;show_remote_cursors = TRUE;
1263   priv-&gt;show_remote_selections = TRUE;
1264   priv-&gt;show_remote_current_lines = TRUE;
1265 }
1266 static void
1267 inf_text_gtk_view_dispose(GObject* object)
1268 {
1269   InfTextGtkView* view;
1270   InfTextGtkViewPrivate* priv;
1271   view = INF_TEXT_GTK_VIEW(object);
1272   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1273   inf_text_gtk_view_set_user_table(view, NULL);
1274   inf_text_gtk_view_set_view(view, NULL);
1275   g_assert(priv-&gt;active_user == NULL);
1276   g_assert(priv-&gt;users == NULL);
1277   if(priv-&gt;io != NULL)
1278   {
1279     g_object_unref(priv-&gt;io);
1280     priv-&gt;io = NULL;
1281   }
1282   G_OBJECT_CLASS(inf_text_gtk_view_parent_class)-&gt;dispose(object);
1283 }
1284 static void
1285 inf_text_gtk_view_set_property(GObject* object,
1286                                  guint prop_id,
1287                                  const GValue* value,
1288                                  GParamSpec* pspec)
1289 {
1290   InfTextGtkView* view;
1291   InfTextGtkViewPrivate* priv;
1292   view = INF_TEXT_GTK_VIEW(object);
1293   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1294   switch(prop_id)
1295   {
1296   case PROP_IO:
1297     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
1298     break;
1299   case PROP_VIEW:
1300     g_assert(priv-&gt;textview == NULL); 
1301     inf_text_gtk_view_set_view(
1302       view,
1303       GTK_TEXT_VIEW(g_value_get_object(value))
1304     );
1305     break;
1306   case PROP_USER_TABLE:
1307     g_assert(priv-&gt;user_table == NULL); 
1308     inf_text_gtk_view_set_user_table(
1309       view,
1310       INF_USER_TABLE(g_value_get_object(value))
1311     );
1312     break;
1313   case PROP_ACTIVE_USER:
1314     inf_text_gtk_view_set_active_user(
1315       view,
1316       INF_TEXT_USER(g_value_get_object(value))
1317     );
1318     break;
1319   case PROP_SHOW_REMOTE_CURSORS:
1320     inf_text_gtk_view_set_show_remote_cursors(
1321       view,
1322       g_value_get_boolean(value)
1323     );
1324     break;
1325   case PROP_SHOW_REMOTE_SELECTIONS:
1326     inf_text_gtk_view_set_show_remote_selections(
1327       view,
1328       g_value_get_boolean(value)
1329     );
1330     break;
1331   case PROP_SHOW_REMOTE_CURRENT_LINES:
1332     inf_text_gtk_view_set_show_remote_current_lines(
1333       view,
1334       g_value_get_boolean(value)
1335     );
1336     break;
1337   default:
1338     G_OBJECT_WARN_INVALID_PROPERTY_ID(value, prop_id, pspec);
1339     break;
1340   }
1341 }
1342 static void
1343 inf_text_gtk_view_get_property(GObject* object,
1344                                  guint prop_id,
1345                                  GValue* value,
1346                                  GParamSpec* pspec)
1347 {
1348   InfTextGtkView* view;
1349   InfTextGtkViewPrivate* priv;
1350   view = INF_TEXT_GTK_VIEW(object);
1351   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1352   switch(prop_id)
1353   {
1354   case PROP_IO:
1355     g_value_set_object(value, G_OBJECT(priv-&gt;io));
1356     break;
1357   case PROP_VIEW:
1358     g_value_set_object(value, G_OBJECT(priv-&gt;textview));
1359     break;
1360   case PROP_USER_TABLE:
1361     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
1362     break;
1363   case PROP_ACTIVE_USER:
1364     g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
1365     break;
1366   case PROP_SHOW_REMOTE_CURSORS:
1367     g_value_set_boolean(value, priv-&gt;show_remote_cursors);
1368     break;
1369   case PROP_SHOW_REMOTE_SELECTIONS:
1370     g_value_set_boolean(value, priv-&gt;show_remote_selections);
1371     break;
1372   case PROP_SHOW_REMOTE_CURRENT_LINES:
1373     g_value_set_boolean(value, priv-&gt;show_remote_current_lines);
1374     break;
1375   default:
1376     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1377     break;
1378   }
1379 }
1380 static void
1381 inf_text_gtk_view_class_init(InfTextGtkViewClass* view_class)
1382 {
1383   GObjectClass* object_class;
1384   object_class = G_OBJECT_CLASS(view_class);
1385   object_class-&gt;dispose = inf_text_gtk_view_dispose;
1386   object_class-&gt;set_property = inf_text_gtk_view_set_property;
1387   object_class-&gt;get_property = inf_text_gtk_view_get_property;
1388   g_object_class_install_property(
1389     object_class,
1390     PROP_IO,
1391     g_param_spec_object(
1392       "io",
1393       "IO",
1394       "The IO object to schedule timeouts",
1395       INF_TYPE_IO,
1396       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1397     )
1398   );
1399   g_object_class_install_property(
1400     object_class,
1401     PROP_VIEW,
1402     g_param_spec_object(
1403       "view",
1404       "View",
1405       "The underlying GtkTextView",
1406       GTK_TYPE_TEXT_VIEW,
1407       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1408     )
1409   );
1410   g_object_class_install_property(
1411     object_class,
1412     PROP_USER_TABLE,
1413     g_param_spec_object(
1414       "user-table",
1415       "User table",
1416       "The user table containing the users of the session shown in the view",
1417       INF_TYPE_USER_TABLE,
1418       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1419     )
1420   );
1421   g_object_class_install_property(
1422     object_class,
1423     PROP_ACTIVE_USER,
1424     g_param_spec_object(
1425       "active-user",
1426       "Active user",
1427       "The user for which to show the view",
1428       INF_TEXT_TYPE_USER,
1429       G_PARAM_READWRITE
1430     )
1431   );
1432   g_object_class_install_property(
1433     object_class,
1434     PROP_SHOW_REMOTE_CURSORS,
1435     g_param_spec_boolean(
1436       "show-remote-cursors",
1437       "Show remote cursors",
1438       "Whether to show cursors of non-local users",
1439       TRUE,
1440       G_PARAM_READWRITE
1441     )
1442   );
1443   g_object_class_install_property(
1444     object_class,
1445     PROP_SHOW_REMOTE_SELECTIONS,
1446     g_param_spec_boolean(
1447       "show-remote-selections",
1448       "Show remote selections",
1449       "Whether to highlight text selected by non-local users",
1450       TRUE,
1451       G_PARAM_READWRITE
1452     )
1453   );
1454   g_object_class_install_property(
1455     object_class,
1456     PROP_SHOW_REMOTE_CURRENT_LINES,
1457     g_param_spec_boolean(
1458       "show-remote-current-lines",
1459       "Show remote current lines",
1460       "Whether to highlight the line in which the cursor of non-local users is",
1461       TRUE,
1462       G_PARAM_READWRITE
1463     )
1464   );
1465 }
1466 InfTextGtkView*
1467 inf_text_gtk_view_new(InfIo* io,
1468                       GtkTextView* view,
1469                       InfUserTable* user_table)
1470 {
1471   GObject* object;
1472   g_return_val_if_fail(INF_IS_IO(io), NULL);
1473   g_return_val_if_fail(GTK_IS_TEXT_VIEW(view), NULL);
1474   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1475   object = g_object_new(
1476     INF_TEXT_GTK_TYPE_VIEW,
1477     "io", io,
1478     "view", view,
1479     "user-table", user_table,
1480     NULL
1481   );
1482   return INF_TEXT_GTK_VIEW(object);
1483 }
1484 GtkTextView*
1485 inf_text_gtk_view_get_text_view(InfTextGtkView* view)
1486 {
1487   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1488   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;textview;
1489 }
1490 InfUserTable*
1491 inf_text_gtk_view_get_user_table(InfTextGtkView* view)
1492 {
1493   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1494   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;user_table;
1495 }
1496 void
1497 inf_text_gtk_view_set_active_user(InfTextGtkView* view,
1498                                   InfTextUser* user)
1499 {
1500   InfTextGtkViewPrivate* priv;
1501   InfTextUser* active_user;
1502   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1503   g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
1504   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1505   g_return_if_fail(
1506     user == NULL ||
1507     inf_user_table_lookup_user_by_id(
1508       priv-&gt;user_table,
1509       inf_user_get_id(INF_USER(user))
1510     ) == INF_USER(user)
1511   );
1512   if(priv-&gt;active_user != NULL)
1513   {
1514     active_user = priv-&gt;active_user;
1515     priv-&gt;active_user = NULL;
1516     inf_text_gtk_view_user_added(view, active_user);
1517   }
1518   if(user != NULL)
1519   {
1520     inf_text_gtk_view_user_removed(view, user);
1521   }
1522   priv-&gt;active_user = user;
1523   g_object_notify(G_OBJECT(view), "active-user");
1524 }
1525 InfTextUser*
1526 inf_text_gtk_view_get_active_user(InfTextGtkView* view)
1527 {
1528   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1529   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;active_user;
1530 }
1531 void
1532 inf_text_gtk_view_set_show_remote_cursors(InfTextGtkView* view,
1533                                           gboolean show)
1534 {
1535   InfTextGtkViewPrivate* priv;
1536   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1537   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1538   if(priv-&gt;show_remote_cursors != show)
1539   {
1540     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1541     priv-&gt;show_remote_cursors = show;
1542     g_object_notify(G_OBJECT(view), "show-remote-cursors");
1543   }
1544 }
1545 void
1546 inf_text_gtk_view_set_show_remote_selections(InfTextGtkView* view,
1547                                              gboolean show)
1548 {
1549   InfTextGtkViewPrivate* priv;
1550   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1551   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1552   if(priv-&gt;show_remote_selections != show)
1553   {
1554     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1555     priv-&gt;show_remote_selections = show;
1556     g_object_notify(G_OBJECT(view), "show-remote-selections");
1557   }
1558 }
1559 void
1560 inf_text_gtk_view_set_show_remote_current_lines(InfTextGtkView* view,
1561                                                 gboolean show)
1562 {
1563   InfTextGtkViewPrivate* priv;
1564   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1565   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1566   if(priv-&gt;show_remote_current_lines != show)
1567   {
1568     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1569     priv-&gt;show_remote_current_lines = show;
1570     g_object_notify(G_OBJECT(view), "show-remote-current-lines");
1571   }
1572 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
