<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-test-traffic-replay.c &amp; inf-text-gtk-view.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-test-traffic-replay.c &amp; inf-text-gtk-view.c
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-test-traffic-replay.c (2.2304833%)<th>inf-text-gtk-view.c (1.4652015%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(48-73)<td><a href="#" name="0">(53-98)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-test-traffic-replay.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#define _XOPEN_SOURCE 700
#include "util/inf-test-util.h"
#include &lt;libinfinity/server/infd-xml-server.h&gt;
#include &lt;libinfinity/server/infd-xmpp-server.h&gt;
#include &lt;libinfinity/common/inf-standalone-io.h&gt;
#include &lt;libinfinity/common/inf-cert-util.h&gt;
#include &lt;libinfinity/common/inf-init.h&gt;
#include &lt;gnutls/gnutls.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;libxml/xmlsave.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;assert.h&gt;
typedef struct _InfTestTrafficReplay InfTestTrafficReplay;
struct _InfTestTrafficReplay {
  InfStandaloneIo* io;
  guint port;
  InfdXmppServer* xmpp;
  const gchar* filename;
<a name="0"></a>  GSList* conns;
};
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef enum _InfTestTrafficReplayMessageType {
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING,
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING,
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT,
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT,
  INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR
} InfTestTrafficReplayMessageType;
typedef struct _InfTestTrafficReplayMessage InfTestTrafficReplayMessage;
struct _InfTestTrafficReplayMessage {
  gint64 timestamp;   InfTestTrafficReplayMessageType type;
  xmlNodePtr xml;
  xmlNodePtr xml_iter;
};
typedef struct _InfTestTrafficReplayConnection InfTestTrafficReplayConnection;
struct _InfTestTrafficReplayConnection {
  gchar* name;
  InfTestTrafficReplay* replay;
  InfCertificateCredentials* creds;
  InfXmppConnection* xmpp;
  FILE* file;
  InfTestTrafficReplayMessage* message;
  GHashTable* group_queues; };</b></font>
typedef enum _InfTestTrafficReplayError {
  INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
  INF_TEST_TRAFFIC_REPLAY_ERROR_UNEXPECTED_EOF
} InfTestTrafficReplayError;
static GQuark
inf_test_traffic_replay_error_quark()
{
  return g_quark_from_static_string("INF_TEST_TRAFFIC_REPLAY_ERROR");
}
static void
inf_test_traffic_replay_received_cb(InfXmppConnection* connection,
                                    xmlNodePtr xml,
                                    gpointer user_data);
static void
inf_test_traffic_replay_notify_status_cb(GObject* object,
                                         GParamSpec* pspec,
                                         gpointer user_data);
static void
inf_test_traffic_replay_queue_free(GQueue* queue)
{
  g_queue_free_full(queue, (GDestroyNotify)xmlFreeDoc);
}
static void
inf_test_traffic_replay_message_free(InfTestTrafficReplayMessage* message)
{
  if(message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
     message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
  {
    if(message-&gt;xml != NULL)
      xmlFreeNode(message-&gt;xml);
  }
  g_slice_free(InfTestTrafficReplayMessage, message);
}
static char*
inf_test_traffic_replay_get_next_line(InfTestTrafficReplayConnection* conn,
                                      size_t* len,
                                      GError** error)
{
  char* line;
  size_t n;
  ssize_t len_;
  int err;
  line = NULL;
  n = 0;
  len_ = getline(&amp;line, &amp;n, conn-&gt;file);
  if(len_ &gt;= 0)
  {
    *len = len_;
    return line;
  }
  else
  {
    if(feof(conn-&gt;file))
    {
      g_set_error(
        error,
        inf_test_traffic_replay_error_quark(),
        INF_TEST_TRAFFIC_REPLAY_ERROR_UNEXPECTED_EOF,
        "Unexpected end of file"
      );
    }
    else
    {
      err = ferror(conn-&gt;file);
      g_set_error_literal(
        error,
        G_FILE_ERROR,
        g_file_error_from_errno(err),
        strerror(err)
      );
    }
    return NULL;
  }
}
static InfTestTrafficReplayMessage*
inf_test_traffic_replay_get_next_message(InfTestTrafficReplayConnection* conn,
                                         GError** error)
{
  char* line;
  size_t len;
  size_t n;
  struct tm tm;
  char* end;
  gulong msecs;
  InfTestTrafficReplayMessageType type;
  xmlDocPtr xml;
  GString* str;
  InfTestTrafficReplayMessage* message;
  line = inf_test_traffic_replay_get_next_line(conn, &amp;len, error);
  if(!line) return NULL;
  if(line[0] != '[')
  {
    g_set_error(
      error,
      inf_test_traffic_replay_error_quark(),
      INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
      "Line does not start with a timestamp"
    );
    free(line);
    return FALSE;
  }
  end = strptime(&amp;line[1], "%a %d %b %Y %I:%M:%S %p %Z", &amp;tm);
  if(end == NULL || *end != ' ' || *(end+1) != '.')
  {
    g_set_error(
      error,
      inf_test_traffic_replay_error_quark(),
      INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
      "Failed to parse timestamp"
    );
    free(line);
    return FALSE;
  }
  errno = 0;
  msecs = strtoul(&amp;end[2], &amp;end, 10);
  if(errno != 0 || *end != ']' || msecs &gt;= 1000000)
  {
    g_set_error(
      error,
      inf_test_traffic_replay_error_quark(),
      INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
      "Failed to parse timestamp"
    );
    free(line);
    return FALSE;
  }
  ++end;
  tm.tm_isdst = 1;
  n = (end - line) + 1;
  if(line[n] == '!')
  {
    if(strstr(line + n + 4, "connected") != NULL)
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT;
    else if(strstr(line + n + 4, "Connection error") != NULL)
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR;
    else if(strstr(line + n + 4, "closed") != NULL)
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT;
    else
    {
      g_set_error(
        error,
        inf_test_traffic_replay_error_quark(),
        INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
        "Unknown connection event \"%s\"",
        line + n + 4
      );
      free(line);
      return FALSE;
    }
  }
  else if(line[n] == '&lt;')
  {
    if(FALSE)       type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING;
    else
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING;
  }
  else if(line[n] == '&gt;')
  {
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING;
    else
      type = INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING;
  }
  else
  {
    g_set_error(
      error,
      inf_test_traffic_replay_error_quark(),
      INF_TEST_TRAFFIC_REPLAY_ERROR_INVALID_LINE,
      "Unknown control character \"%c\" (%d)",
      line[n],
      (int)line[n]
    );
    free(line);
    return FALSE;
  }
  if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
     type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
  {
    str = g_string_new_len(line + n + 4, len - n - 5);
    xml = xmlReadDoc(str-&gt;str, NULL, "UTF-8", XML_PARSE_NOWARNING | XML_PARSE_NOERROR);
    while(!xml)
    {
      free(line);
      line = inf_test_traffic_replay_get_next_line(conn, &amp;len, error);
      if(!line)
      {
        g_string_free(str, TRUE);
        return NULL;
      }
      g_string_append_c(str, '\n');
      g_string_append_len(str, line, len - 1);
      xml = xmlReadDoc(str-&gt;str, NULL, "UTF-8", XML_PARSE_NOWARNING | XML_PARSE_NOERROR);
    }
    g_string_free(str, TRUE);
  }
  free(line);
  message = g_slice_new(InfTestTrafficReplayMessage);
  message-&gt;timestamp = (gint64)mktime(&amp;tm) * 1000000 + msecs;
  message-&gt;type = type;
  if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING ||
     type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING)
  {
    message-&gt;xml = xmlCopyNode(xmlDocGetRootElement(xml), 1);
    if(type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
      message-&gt;xml_iter = message-&gt;xml-&gt;children;
    xmlFreeDoc(xml);
  }
  return message;
}
static void
inf_test_traffic_replay_connection_close(InfTestTrafficReplayConnection* conn)
{
  InfXmlConnectionStatus status;
  g_signal_handlers_disconnect_by_func(
    G_OBJECT(conn-&gt;xmpp),
    G_CALLBACK(inf_test_traffic_replay_received_cb),
    conn
  );
  g_signal_handlers_disconnect_by_func(
    G_OBJECT(conn-&gt;xmpp),
    G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
    conn
  );
  if(conn-&gt;xmpp != NULL)
  {
    g_object_get(G_OBJECT(conn-&gt;xmpp), "status", &amp;status, NULL);
    if(status == INF_XML_CONNECTION_OPEN ||
       status == INF_XML_CONNECTION_OPENING)
    {
      inf_xml_connection_close(INF_XML_CONNECTION(conn-&gt;xmpp));
    }
  }
  if(conn-&gt;creds != NULL)
    inf_certificate_credentials_unref(conn-&gt;creds);
  g_object_unref(conn-&gt;xmpp);
  if(conn-&gt;file != NULL) fclose(conn-&gt;file);
  g_hash_table_destroy(conn-&gt;group_queues);
  fprintf(stderr, "[%s] Disconnected\n", conn-&gt;name);
  g_free(conn-&gt;name);
  conn-&gt;replay-&gt;conns = g_slist_remove(conn-&gt;replay-&gt;conns, conn);
  if(conn-&gt;replay-&gt;conns == NULL)
    inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
  g_slice_free(InfTestTrafficReplayConnection, conn);
}
static void
inf_test_traffic_replay_connection_check_message(
  InfTestTrafficReplayConnection* conn,
  xmlNodePtr xml)
{
  xmlBufferPtr received_buffer;
  xmlBufferPtr expected_buffer;
  xmlSaveCtxtPtr ctx;
  received_buffer = xmlBufferCreate();
  expected_buffer = xmlBufferCreate();
  if(strcmp(conn-&gt;message-&gt;xml_iter-&gt;name, "message") == 0)
    xmlSetProp(conn-&gt;message-&gt;xml_iter, "time", NULL);
  if(strcmp(xml-&gt;name, "message") == 0)
    xmlSetProp(xml, "time", NULL);
  ctx = xmlSaveToBuffer(expected_buffer, "UTF-8", 0);
  xmlSaveTree(ctx, conn-&gt;message-&gt;xml_iter);
  xmlSaveClose(ctx);
  ctx = xmlSaveToBuffer(received_buffer, "UTF-8", 0);
  xmlSaveTree(ctx, xml);
  xmlSaveClose(ctx);
  if(strcmp(xmlBufferContent(expected_buffer), xmlBufferContent(received_buffer)) != 0)
  {
    fprintf(
      stderr,
      "[WARNING] [%s] Mismatch between expected and received: "
      "\n\n\"%s\"\n\nvs.\n\n\"%s\"\n",
      conn-&gt;name,
      (const gchar*)xmlBufferContent(expected_buffer),
      (const gchar*)xmlBufferContent(received_buffer)
    );
    xmlBufferFree(expected_buffer);
    xmlBufferFree(received_buffer);
    if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
      inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
    return;
  }
  xmlBufferFree(expected_buffer);
  xmlBufferFree(received_buffer);
}
static gboolean
inf_test_traffic_replay_connection_process_next_message(
  InfTestTrafficReplayConnection* conn)
{
  InfIpAddress* addr;
  InfTcpConnection* tcp;
  GError* error;
  xmlChar* group;
  GQueue* queue;
  switch(conn-&gt;message-&gt;type)
  {
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_CONNECT:
    if(conn-&gt;xmpp != NULL)
      return FALSE;
    fprintf(stderr, "[%s] Connecting...\n", conn-&gt;name);
    addr = inf_ip_address_new_loopback4();
    tcp = inf_tcp_connection_new(
      INF_IO(conn-&gt;replay-&gt;io),
      addr,
      conn-&gt;replay-&gt;port
    );
    inf_ip_address_free(addr);
    conn-&gt;xmpp = inf_xmpp_connection_new(
      tcp,
      INF_XMPP_CONNECTION_CLIENT,
      NULL,
      "localhost",
      INF_XMPP_CONNECTION_SECURITY_ONLY_TLS,
      conn-&gt;creds,
      NULL,
      NULL
    );
    g_signal_connect(
      G_OBJECT(conn-&gt;xmpp),
      "received",
      G_CALLBACK(inf_test_traffic_replay_received_cb),
      conn
    );
    g_signal_connect(
      G_OBJECT(conn-&gt;xmpp),
      "notify::status",
      G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
      conn
    );
    error = NULL;
    if(!inf_tcp_connection_open(tcp, &amp;error))
    {
      fprintf(stderr, "[ERROR] [%s] %s\n", conn-&gt;name, error-&gt;message);
      g_error_free(error);
      if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
        inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
      return FALSE;
    }
    g_object_unref(tcp);
    return FALSE;
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_DISCONNECT:
    g_assert(conn-&gt;xmpp != NULL);
    inf_test_traffic_replay_connection_close(conn);
    return TRUE;
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_ERROR:
    g_assert(conn-&gt;xmpp != NULL);
    fprintf(stderr, "[%s] Recorded connection error, ignored\n", conn-&gt;name);
    return TRUE;
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING:
    g_assert(conn-&gt;xmpp != NULL);
    group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
    fprintf(stderr, "[%s] Expecting data (%s, %s)\n", conn-&gt;name, group, conn-&gt;message-&gt;xml_iter-&gt;name);     queue = g_hash_table_lookup(conn-&gt;group_queues, group);
    xmlFree(group);
    g_assert(queue == NULL || g_queue_is_empty(queue));
    return FALSE;
  case INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING:
    g_assert(conn-&gt;xmpp != NULL);
    group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
    fprintf(stderr, "[%s] Sending data (%s, %s)\n", conn-&gt;name, group, conn-&gt;message-&gt;xml-&gt;children-&gt;name);     xmlFree(group);
    inf_xml_connection_send(
      INF_XML_CONNECTION(conn-&gt;xmpp),
      conn-&gt;message-&gt;xml
    );
    conn-&gt;message-&gt;xml = NULL;
    return TRUE;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_test_traffic_replay_process_next_message(InfTestTrafficReplay* replay);
static void
inf_test_traffic_replay_connection_fetch_next_message(
  InfTestTrafficReplayConnection* conn)
{
  xmlChar* group;
  GQueue* queue;
  xmlNodePtr xml;
  if(!inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
    return;
  if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING &amp;&amp;
     conn-&gt;message-&gt;xml_iter-&gt;next != NULL)
  {
    conn-&gt;message-&gt;xml_iter = conn-&gt;message-&gt;xml_iter-&gt;next;
  }
  else
  {
    GError* error;
    inf_test_traffic_replay_message_free(conn-&gt;message);
    error = NULL;
    conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
    if(error != NULL)
    {
      fprintf(
        stderr,
        "[ERROR] [%s] Failed to fetch message: %s\n",
        conn-&gt;name,
        error-&gt;message
      );
      g_error_free(error);
      if(inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
        inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
      return;
    }
  }
  if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
  {
    group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
    queue = g_hash_table_lookup(conn-&gt;group_queues, group);
    if(queue != NULL &amp;&amp; !g_queue_is_empty(queue))
    {
      xml = g_queue_pop_head(queue);
      fprintf(stderr, "[%s] Replay data (%s, %s)\n", conn-&gt;name, group, xml-&gt;name);
      inf_test_traffic_replay_connection_check_message(conn, xml);
      inf_test_traffic_replay_connection_fetch_next_message(conn);
      xmlFree(group);
      return;
    }
    xmlFree(group);
  }
  inf_test_traffic_replay_process_next_message(conn-&gt;replay);
}
static void
inf_test_traffic_replay_process_next_message(InfTestTrafficReplay* replay)
{
  GSList* item;
  InfTestTrafficReplayConnection* conn;
  InfTestTrafficReplayConnection* low;
  if(!inf_standalone_io_loop_running(replay-&gt;io))
    return;
  low = NULL;
  for(item = replay-&gt;conns; item != NULL; item = item-&gt;next)
  {
    conn = (InfTestTrafficReplayConnection*)item-&gt;data;
    if(low == NULL || conn-&gt;message-&gt;timestamp &lt; low-&gt;message-&gt;timestamp)
      low = conn;
    else if(conn-&gt;message-&gt;timestamp == low-&gt;message-&gt;timestamp)
    {
      if(conn-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_OUTGOING &amp;&amp;
         low-&gt;message-&gt;type == INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
      {
        low = conn;
      }
    }
  }
  if(inf_test_traffic_replay_connection_process_next_message(low))
  {
    if(g_slist_find(replay-&gt;conns, low))
      inf_test_traffic_replay_connection_fetch_next_message(low);
    else
      inf_test_traffic_replay_process_next_message(replay);
  }
}
static void
inf_test_traffic_replay_received_cb(InfXmppConnection* connection,
                                    xmlNodePtr xml,
                                    gpointer user_data)
{
  InfTestTrafficReplayConnection* conn;
  xmlBufferPtr buffer;
  xmlSaveCtxtPtr ctx;
  xmlNodePtr child;
  GQueue* queue;
  xmlChar* received_group;
  xmlChar* expected_group;
  conn = (InfTestTrafficReplayConnection*)user_data;
  g_assert(strcmp(xml-&gt;name, "group") == 0);
  for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
  {
    if(!inf_standalone_io_loop_running(conn-&gt;replay-&gt;io))
      break;
    if(!conn-&gt;message ||
       conn-&gt;message-&gt;type != INF_TEST_TRAFFIC_REPLAY_MESSAGE_INCOMING)
    {
      buffer = xmlBufferCreate();
      ctx = xmlSaveToBuffer(buffer, "UTF-8", 0);
      xmlSaveTree(ctx, child);
      xmlSaveClose(ctx);
      fprintf(
        stderr,
        "[ERROR] [%s] Received text \"%s\" without expecting any\n",
        conn-&gt;name,
        (const gchar*)xmlBufferContent(buffer)
      );
      xmlBufferFree(buffer);
      inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
      return;
    }
    received_group = xmlGetProp(xml, "name");
    expected_group = xmlGetProp(conn-&gt;message-&gt;xml, "name");
    fprintf(
      stderr,
      "[%s] Received data (%s, %s), expected %s\n",
      conn-&gt;name,
      received_group,
      child-&gt;name,
      expected_group
    );
    queue = g_hash_table_lookup(conn-&gt;group_queues, expected_group);
    g_assert(queue == NULL || g_queue_is_empty(queue));
    if(strcmp(received_group, expected_group) != 0)
    {
      queue = g_hash_table_lookup(conn-&gt;group_queues, received_group);
      if(!queue)
      {
        queue = g_queue_new();
        g_hash_table_insert(
          conn-&gt;group_queues,
          g_strdup(received_group),
          queue
        );
      }
      g_queue_push_tail(queue, xmlCopyNode(child, 1));
      xmlFree(received_group);
      xmlFree(expected_group);
    }
    else
    {
      xmlFree(received_group);
      xmlFree(expected_group);
      inf_test_traffic_replay_connection_check_message(conn, child);
      inf_test_traffic_replay_connection_fetch_next_message(conn);
    }
  }
}
static void
inf_test_traffic_replay_notify_status_cb(GObject* object,
                                         GParamSpec* pspec,
                                         gpointer user_data)
{
  InfTestTrafficReplayConnection* conn;
  InfXmlConnectionStatus status;
  conn = (InfTestTrafficReplayConnection*)user_data;
  g_object_get(object, "status", &amp;status, NULL);
  switch(status)
  {
  case INF_XML_CONNECTION_OPENING:
    break;
  case INF_XML_CONNECTION_OPEN:
    fprintf(stderr, "[%s] Connected\n", conn-&gt;name);
    inf_test_traffic_replay_connection_fetch_next_message(conn);
    break;
  case INF_XML_CONNECTION_CLOSING:
  case INF_XML_CONNECTION_CLOSED:
    fprintf(stderr, "[ERROR] [%s] Remote connection closed\n", conn-&gt;name);
    inf_standalone_io_loop_quit(conn-&gt;replay-&gt;io);
    break;
  }
}
static void
inf_test_traffic_replay_new_connection_cb(InfdXmppServer* server,
                                          InfXmppConnection* xmpp,
                                          gpointer user_data)
{
  InfTestTrafficReplayConnection* conn;
  InfTestTrafficReplay* replay;
  InfXmlConnectionStatus status;
  GError* error;
  conn = g_slice_new(InfTestTrafficReplayConnection);
  replay = (InfTestTrafficReplay*)user_data;
  conn-&gt;name = g_strdup("server");
  conn-&gt;replay = replay;
  conn-&gt;creds = NULL;
  conn-&gt;xmpp = xmpp;
  conn-&gt;group_queues = g_hash_table_new_full(
    g_str_hash,
    g_str_equal,
    g_free,
    (GDestroyNotify)inf_test_traffic_replay_queue_free
  );
  error = NULL;
  conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
  if(error != NULL)
  {
    fprintf(
      stderr,
      "Failed to read initial message for %s: %s\n",
      conn-&gt;name,
      error-&gt;message
    );
    inf_test_traffic_replay_connection_close(conn);
  }
  replay-&gt;conns = g_slist_prepend(replay-&gt;conns, conn);
  g_object_ref(xmpp);
  g_signal_connect(
    G_OBJECT(xmpp),
    "received",
    G_CALLBACK(inf_test_traffic_replay_received_cb),
    conn
  );
  g_signal_connect(
    G_OBJECT(conn-&gt;xmpp),
    "notify::status",
    G_CALLBACK(inf_test_traffic_replay_notify_status_cb),
    conn
  );
  conn-&gt;file = fopen(replay-&gt;filename, "r");
  if(!conn-&gt;file)
  {
    fprintf(
      stderr,
      "Failed to open %s: %s\n",
      replay-&gt;filename,
      strerror(errno)
    );
    inf_test_traffic_replay_connection_close(conn);
  }
  else
  {
    g_object_get(G_OBJECT(conn-&gt;xmpp), "status", &amp;status, NULL);
    if(status == INF_XML_CONNECTION_OPEN)
    {
      inf_test_traffic_replay_connection_fetch_next_message(conn);
    }
  }
}
static InfCertificateCredentials*
inf_test_traffic_replay_load_server_credentials(GError** error)
{
  GPtrArray* array;
  gnutls_x509_privkey_t key;
  InfCertificateCredentials* creds;
  gnutls_certificate_credentials_t gcreds;
  guint i;
  key = inf_cert_util_read_private_key(
    "/home/armin/kombia/kombia.cert",
    error
  );
  if(!key) return NULL;
  array = inf_cert_util_read_certificate(
    "/home/armin/kombia/kombia.cert",
    NULL,
    error
  );
  if(!array) return NULL;
  creds = inf_certificate_credentials_new();
  gcreds = inf_certificate_credentials_get(creds);
  gnutls_certificate_set_x509_key(
    gcreds,
    (gnutls_x509_crt_t*)array-&gt;pdata,
    array-&gt;len,
    key
  );
  gnutls_certificate_set_x509_trust(
    gcreds,
    (gnutls_x509_crt_t*)array-&gt;pdata,
    array-&gt;len
  );
  gnutls_x509_privkey_deinit(key);
  for(i = 0; i &lt; array-&gt;len; ++i)
    gnutls_x509_crt_deinit(array-&gt;pdata[i]);
  g_ptr_array_free(array, TRUE);
  return creds;
}
static InfCertificateCredentials*
inf_test_traffic_replay_load_client_credentials(const gchar* path,
                                                GError** error)
{
  gchar* basename;
  gchar* dirname;
  gchar* full;
  GPtrArray* array;
  gnutls_x509_privkey_t key;
  InfCertificateCredentials* creds;
  gnutls_certificate_credentials_t gcreds;
  guint i;
  basename = g_path_get_basename(path);
  dirname = g_path_get_dirname(path);
  full = g_build_filename(dirname, "certs", basename, NULL);
  g_free(basename);
  g_free(dirname);
  key = inf_cert_util_read_private_key(full, error);
  if(!key) { g_free(full); return NULL; }
  array = inf_cert_util_read_certificate(full, NULL, error);
  if(!array) { g_free(full); return NULL; }
  g_free(full);
  creds = inf_certificate_credentials_new();
  gcreds = inf_certificate_credentials_get(creds);
  gnutls_certificate_set_x509_key(
    gcreds,
    (gnutls_x509_crt_t*)array-&gt;pdata,
    array-&gt;len,
    key
  );
  gnutls_certificate_set_x509_trust(
    gcreds,
    (gnutls_x509_crt_t*)&amp;array-&gt;pdata[array-&gt;len - 1],
    1
  );
  gnutls_x509_privkey_deinit(key);
  for(i = 0; i &lt; array-&gt;len; ++i)
    gnutls_x509_crt_deinit(array-&gt;pdata[i]);
  g_ptr_array_free(array, TRUE);
  return creds;
}
static void
inf_test_traffic_replay_start_func(gpointer user_data)
{
  inf_test_traffic_replay_process_next_message(user_data);
}
int main(int argc, char* argv[])
{
  InfTestTrafficReplay replay;
  InfdTcpServer* server;
  InfCertificateCredentials* creds;
  GError* error;
  gboolean as_server;
  guint port;
  int i;
  FILE* f;
  InfTestTrafficReplayConnection* conn;
  as_server = FALSE;
  port = 6524;
  if(argc &lt; 2)
  {
    fprintf(stderr, "Usage: %s &lt;traffic-log&gt;\n", argv[0]);
    return -1;
  }
  error = NULL;
  if(!inf_init(&amp;error))
  {
    fprintf(stderr, "%s\n", error-&gt;message);
    g_error_free(error);
    return -1;
  }
  replay.io = inf_standalone_io_new();
  replay.port = port;
  replay.xmpp = NULL;
  replay.conns = NULL;
  if(as_server == TRUE)
  {
    replay.filename = argv[1];
    creds = inf_test_traffic_replay_load_server_credentials(&amp;error);
    if(!creds)
    {
      fprintf(stderr, "%s\n", error-&gt;message);
      g_error_free(error);
      return -1;
    }
    server = g_object_new(
      INFD_TYPE_TCP_SERVER,
      "io", replay.io,
      "local-address", NULL,
      "local-port", port,
      NULL
    );
    replay.xmpp = infd_xmpp_server_new(
      server,
      INF_XMPP_CONNECTION_SECURITY_ONLY_TLS,
      creds,
      NULL,
      NULL
    );
    inf_certificate_credentials_unref(creds);
    g_signal_connect(
      G_OBJECT(replay.xmpp),
      "new-connection",
      G_CALLBACK(inf_test_traffic_replay_new_connection_cb),
      &amp;replay
    );
    if(!infd_tcp_server_open(server, &amp;error))
    {
      fprintf(stderr, "%s\n", error-&gt;message);
      g_error_free(error);
      return 1;
    }
    g_object_unref(server);
  }
  else
  {
    replay.filename = NULL;
    for(i = 1; i &lt; argc; ++i)
    {
      f = fopen(argv[i], "r");
      if(!f)
      {
        fprintf(
          stderr,
          "Failed to open %s: %s\n",
          argv[i],
          strerror(errno)
        );
        return 1;
      }
      conn = g_slice_new(InfTestTrafficReplayConnection);
      conn-&gt;replay = &amp;replay;
      conn-&gt;name = g_strdup_printf("client %d (%s)", i, argv[i]);
      conn-&gt;xmpp = NULL;
      conn-&gt;file = f;
      conn-&gt;group_queues = g_hash_table_new_full(
        g_str_hash,
        g_str_equal,
        g_free,
        (GDestroyNotify)inf_test_traffic_replay_queue_free
      );
      conn-&gt;creds = inf_test_traffic_replay_load_client_credentials(argv[i], &amp;error);
      if(error != NULL)
      {
        if(error-&gt;domain == G_FILE_ERROR &amp;&amp; error-&gt;code == G_FILE_ERROR_NOENT)
        {
          printf("No client credentials for %s\n", conn-&gt;name);
          g_error_free(error);
          error = NULL;
        }
        else
        {
          fprintf(
            stderr,
            "Failed to load client credentials for %s: %s\n",
            conn-&gt;name,
            error-&gt;message
          );
          return 1;
        }
      }
      else
      {
        printf("Loaded client credentials for %s\n", conn-&gt;name);
      }
      replay.conns = g_slist_prepend(replay.conns, conn);
      conn-&gt;message = inf_test_traffic_replay_get_next_message(conn, &amp;error);
      if(error != NULL)
      {
        fprintf(
          stderr,
          "Failed to read initial message for %s: %s\n",
          conn-&gt;name,
          error-&gt;message
        );
        return 1;
      }
    }
    inf_io_add_dispatch(
      INF_IO(replay.io),
      inf_test_traffic_replay_start_func,
      &amp;replay,
      NULL
    );
  }
  inf_standalone_io_loop(replay.io);
  return 0;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinftextgtk/inf-text-gtk-view.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
<a name="0"></a>#include &lt;gdk/gdk.h&gt;
typedef struct _InfTextGtkViewUser InfTextGtkViewUser;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>struct _InfTextGtkViewUser {
  InfTextGtkView* view;
  InfTextUser* user;
  gboolean cursor_visible;
  InfIoTimeout* timeout;   guint revalidate_idle;
  GdkRectangle cursor_rect;
  GdkRectangle selection_bound_rect;
  gint line_y;
  gint line_height;
};
typedef struct _InfTextGtkViewUserToggle InfTextGtkViewUserToggle;
struct _InfTextGtkViewUserToggle {
  InfTextGtkViewUser* user;
  guint pos;
  InfTextGtkViewUserToggle* on_toggle;
  gint x;
  gint y;
};
typedef struct _InfTextGtkViewPrivate InfTextGtkViewPrivate;
struct _InfTextGtkViewPrivate {
  InfIo* io;
  GtkTextView* textview;
  InfUserTable* user_table;
  InfTextUser* active_user;
  GSList* users;
  gboolean show_remote_cursors;
  gboolean show_remote_selections;
  gboolean show_remote_current_lines;
};</b></font>
enum {
  PROP_0,
  PROP_IO,
  PROP_VIEW,
  PROP_USER_TABLE,
  PROP_ACTIVE_USER,
  PROP_SHOW_REMOTE_CURSORS,
  PROP_SHOW_REMOTE_SELECTIONS,
  PROP_SHOW_REMOTE_CURRENT_LINES
};
#define INF_TEXT_GTK_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_VIEW, InfTextGtkViewPrivate))
G_DEFINE_TYPE_WITH_CODE(InfTextGtkView, inf_text_gtk_view, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextGtkView))
static InfTextGtkViewUser*
inf_text_gtk_view_find_user(InfTextGtkView* view,
                            InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  GSList* item;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    if( ((InfTextGtkViewUser*)item-&gt;data)-&gt;user == user)
      return (InfTextGtkViewUser*)item-&gt;data;
  return NULL;
}
static void
inf_text_gtk_view_user_compute_user_area(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GtkTextIter iter;
  gfloat cursor_aspect_ratio;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
  gtk_widget_style_get(
    GTK_WIDGET(priv-&gt;textview),
    "cursor-aspect-ratio", &amp;cursor_aspect_ratio,
    NULL
  );
  gtk_text_buffer_get_iter_at_offset(
    gtk_text_view_get_buffer(priv-&gt;textview),
    &amp;iter,
    inf_text_user_get_caret_position(view_user-&gt;user)
  );
  gtk_text_view_get_line_yrange(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;line_y,
    &amp;view_user-&gt;line_height
  );
  gtk_text_view_get_iter_location(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;cursor_rect
  );
  view_user-&gt;cursor_rect.width = MAX(
    (int)(view_user-&gt;cursor_rect.height * cursor_aspect_ratio),
    1
  );
  gtk_text_iter_forward_chars(
    &amp;iter,
    inf_text_user_get_selection_length(view_user-&gt;user)
  );
  gtk_text_view_get_iter_location(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;selection_bound_rect
  );
  view_user-&gt;selection_bound_rect.width = MAX(
    (int)(view_user-&gt;selection_bound_rect.height * cursor_aspect_ratio),
    1
  );
}
static guint
inf_text_gtk_view_get_left_margin(GtkTextView* view)
{
  GtkAdjustment* hadjustment;
  gint margin;
  gint hadj;
  hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));
  margin = gtk_text_view_get_left_margin(view);
  if(!hadjustment) return margin;
  hadj = gtk_adjustment_get_value(hadjustment);
  if(hadj &lt; margin) return margin - hadj;
  return 0;
}
static guint
inf_text_gtk_view_get_right_margin(GtkTextView* view)
{
  GtkAdjustment* hadjustment;
  gint margin;
  gdouble hadj;
  gdouble hupper;
  gdouble hpage;
  hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));
  margin = gtk_text_view_get_right_margin(view);
  if(!hadjustment) return margin;
  hadj = gtk_adjustment_get_value(hadjustment) + 1;
  g_object_get(
    G_OBJECT(hadjustment),
    "upper", &amp;hupper,
    "page-size", &amp;hpage,
    NULL
  );
  if(hadj &gt; hupper - hpage - margin)
    return margin - (gint)(hupper - hpage - hadj);
  return 0;
}
static void
inf_text_gtk_view_user_invalidate_user_area(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GdkWindow* window;
  GdkRectangle invalidate_rect;
  gint selection_bound_x;
  gint selection_bound_y;
  gint window_width;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
  if(gtk_widget_get_realized(GTK_WIDGET(priv-&gt;textview)))
  {
    if(priv-&gt;show_remote_cursors || priv-&gt;show_remote_selections ||
       priv-&gt;show_remote_current_lines)
    {
      window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
      window_width = gdk_window_get_width(window);
      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
        &amp;invalidate_rect.x, &amp;invalidate_rect.y
      );
      invalidate_rect.width = view_user-&gt;cursor_rect.width;
      invalidate_rect.height = view_user-&gt;cursor_rect.height;
      if(priv-&gt;show_remote_selections &amp;&amp;
         (view_user-&gt;selection_bound_rect.x != view_user-&gt;cursor_rect.x ||
          view_user-&gt;selection_bound_rect.y != view_user-&gt;cursor_rect.y))
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          view_user-&gt;selection_bound_rect.x,
          view_user-&gt;selection_bound_rect.y,
          &amp;selection_bound_x, &amp;selection_bound_y
        );
        if(selection_bound_y == invalidate_rect.y)
        {
          if(selection_bound_x &gt; invalidate_rect.x)
          {
            invalidate_rect.width = MAX(
              selection_bound_x - invalidate_rect.x,
              invalidate_rect.width
            );
          }
          else
          {
            invalidate_rect.width += (invalidate_rect.x - selection_bound_x);
            invalidate_rect.x = selection_bound_x;
          }
        }
        else
        {
          invalidate_rect.width = window_width;
          invalidate_rect.height = MAX(
            invalidate_rect.y + invalidate_rect.height,
            selection_bound_y + view_user-&gt;selection_bound_rect.height
          ) - MIN(invalidate_rect.y, selection_bound_y);
          invalidate_rect.x =
            inf_text_gtk_view_get_left_margin(priv-&gt;textview);
          invalidate_rect.y = MIN(invalidate_rect.y, selection_bound_y);
          invalidate_rect.width -=
            inf_text_gtk_view_get_left_margin(priv-&gt;textview) +
            inf_text_gtk_view_get_right_margin(priv-&gt;textview);
        }
        gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
      }
      if(priv-&gt;show_remote_current_lines)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          0, view_user-&gt;line_y,
          NULL, &amp;invalidate_rect.y
        );
        invalidate_rect.x =
          inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
        invalidate_rect.width = window_width - invalidate_rect.x;
        invalidate_rect.height = view_user-&gt;line_height;
      }
      gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
    }
  }
}
static gint
inf_text_gtk_view_user_line_position_cmp(gconstpointer first,
                                         gconstpointer second)
{
  const InfTextGtkViewUser* first_user;
  const InfTextGtkViewUser* second_user;
  first_user = (const InfTextGtkViewUser*)first;
  second_user = (const InfTextGtkViewUser*)second;
  if(second_user-&gt;line_y &lt; first_user-&gt;line_y)
    return 1;
  else if(second_user-&gt;line_y &gt; first_user-&gt;line_y)
    return -1;
  return 0;
}
static gint
inf_text_gtk_view_user_toggle_position_cmp(gconstpointer first,
                                           gconstpointer second,
                                           gpointer user_data)
{
  const InfTextGtkViewUserToggle* first_toggle;
  const InfTextGtkViewUserToggle* second_toggle;
  first_toggle = (const InfTextGtkViewUserToggle*)first;
  second_toggle = (const InfTextGtkViewUserToggle*)second;
  if(second_toggle-&gt;pos &lt; first_toggle-&gt;pos)
    return 1;
  else if(second_toggle-&gt;pos &gt; first_toggle-&gt;pos)
    return -1;
  return 0;
}
static gint
inf_text_gtk_view_user_toggle_user_cmp(gconstpointer first,
                                       gconstpointer second)
{
  const InfTextGtkViewUserToggle* first_toggle;
  const InfTextGtkViewUserToggle* second_toggle;
  guint first_id;
  guint second_id;
  first_toggle = (const InfTextGtkViewUserToggle*)first;
  second_toggle = (const InfTextGtkViewUserToggle*)second;
  first_id = inf_user_get_id(INF_USER(first_toggle-&gt;user-&gt;user));
  second_id = inf_user_get_id(INF_USER(second_toggle-&gt;user-&gt;user));
  if(second_id &lt; first_id)
    return 1;
  else if(second_id &gt; first_id)
    return -1;
  return 0;
}
static void
inf_text_gtk_view_user_toggle_free(gpointer data)
{
  g_slice_free(InfTextGtkViewUserToggle, data);
}
static InfTextGtkViewUserToggle*
inf_text_gtk_view_add_user_toggle(GSequence* sequence,
                                  guint position,
                                  InfTextGtkViewUser* user,
                                  InfTextGtkViewUserToggle* on_toggle,
                                  gint x,
                                  gint y)
{
  InfTextGtkViewUserToggle* toggle;
  toggle = g_slice_new(InfTextGtkViewUserToggle);
  toggle-&gt;user = user;
  toggle-&gt;pos = position;
  toggle-&gt;on_toggle = on_toggle;
  toggle-&gt;x = x;
  toggle-&gt;y = y;
  g_sequence_insert_sorted(
    sequence,
    toggle,
    inf_text_gtk_view_user_toggle_position_cmp,
    NULL
  );
  return toggle;
}
static void
inf_text_gtk_view_add_user_toggle_pair(GSequence* sequence,
                                       guint begin,
                                       guint end,
                                       InfTextGtkViewUser* user,
                                       gint begin_x,
                                       gint begin_y,
                                       gint end_x,
                                       gint end_y)
{
  InfTextGtkViewUserToggle* begin_toggle;
  g_assert(end &gt; begin);
  begin_toggle = inf_text_gtk_view_add_user_toggle(
    sequence,
    begin,
    user,
    NULL,
    begin_x,
    begin_y
  );
  inf_text_gtk_view_add_user_toggle(
    sequence,
    end,
    user,
    begin_toggle,
    end_x,
    end_y
  );
}
static gboolean
inf_text_gtk_view_draw_before_cb(GtkWidget* widget,
                                 cairo_t* cr,
                                 gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  GSList* prev_item;
  InfTextGtkViewUser* prev_user;
  InfTextGtkViewUser* view_user;
  GtkAdjustment* hadjustment;
  GtkAdjustment* vadjustment;
  GdkWindow *text_window;
  GtkStyleContext* style;
  GdkRGBA bg;
  double h, s, v;
  double r, g, b;
  GSList* sort_users;
  GdkRectangle rect;
  gint window_width;
  gint rx, ry;
  GdkRectangle clip_area;
  cairo_pattern_t* pattern;
  double n, n_users;
  cairo_matrix_t matrix;
  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
  if(!gtk_cairo_should_draw_window(cr, text_window))
  {
    return FALSE;
  }
  if(priv-&gt;show_remote_current_lines)
  {
    gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
    gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
    window_width = gdk_window_get_width(text_window);
    style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
    gtk_style_context_save(style);
    gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
    gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &amp;bg);
    gtk_style_context_restore(style);
    gtk_rgb_to_hsv(bg.red, bg.green, bg.blue, &amp;h, &amp;s, &amp;v);
    v = MAX(v, 0.3);
    s = MAX(s, 0.1 + 0.3*(1 - v));
    sort_users = g_slist_copy(priv-&gt;users);
    sort_users =
      g_slist_sort(sort_users, inf_text_gtk_view_user_line_position_cmp);
    prev_item = sort_users;
    if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
    n_users = 1.0;
    for(item = sort_users; item != NULL; item = item-&gt;next, n_users += 1.0)
    {
      if(item-&gt;next == NULL ||
         ((InfTextGtkViewUser*)item-&gt;next-&gt;data)-&gt;line_y != prev_user-&gt;line_y)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          0, prev_user-&gt;line_y,
          NULL, &amp;rect.y
        );
        rect.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
        rect.width = window_width - rect.x;
        rect.height = prev_user-&gt;line_height;
        if(gdk_rectangle_intersect(&amp;clip_area, &amp;rect, NULL))
        {
          hadjustment =
            gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
          vadjustment =
            gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));
          rx = gtk_adjustment_get_value(vadjustment);
          ry = gtk_adjustment_get_value(hadjustment);
          pattern =
            cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
          cairo_matrix_init_translate(&amp;matrix, rx, ry);
          cairo_pattern_set_matrix(pattern, &amp;matrix);
          cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
          for(n = 0.0;
              prev_item != item-&gt;next;
              prev_item = prev_item-&gt;next, n += 1.0)
          {
            view_user = (InfTextGtkViewUser*)prev_item-&gt;data;
            h = inf_text_user_get_hue(view_user-&gt;user);
            gtk_hsv_to_rgb(h, s, v, &amp;r, &amp;g, &amp;b);
            cairo_pattern_add_color_stop_rgb(
              pattern,
              n/n_users,
              r, g, b
            );
            cairo_pattern_add_color_stop_rgb(
              pattern,
              (n+1.0)/n_users,
              r, g, b
            );
          }
          cairo_set_source(cr, pattern);
          gdk_cairo_rectangle(cr, &amp;rect);
          cairo_fill(cr);
          cairo_pattern_destroy(pattern);
        }
        prev_item = item-&gt;next;
        if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
        n_users = 0.0;
      }
    }
    g_slist_free(sort_users);
  }
  return FALSE;
}
static gboolean
inf_text_gtk_view_draw_after_cb(GtkWidget* widget,
                                cairo_t* cr,
                                gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  gint window_width;
  GtkStyleContext* style;
  GdkColor* cursor_color;
  GdkRGBA fg;
  double hc,sc,vc;
  double hs,ss,vs;
  GSList* item;
  InfTextGtkViewUser* view_user;
  double rc,gc,bc;
  double rs,gs,bs;
  GdkRectangle clip_area;
  gint ax, ay;
  GtkTextIter begin_iter;
  GtkTextIter end_iter;
  guint area_begin;
  guint area_end;
  guint own_sel_begin;
  guint own_sel_end;
  gint osbx, osby;
  gint osex, osey;
  gint sel;
  guint begin;
  guint end;
  GSequence* toggles;
  GSequenceIter* tog_iter;
  InfTextGtkViewUserToggle* cur_toggle;
  InfTextGtkViewUserToggle* prev_toggle;
  guint n_users;
  GSList* users;
  cairo_pattern_t* pattern;
  GtkAdjustment* hadjustment;
  GtkAdjustment* vadjustment;
  double n;
  cairo_matrix_t matrix;
  GdkRectangle rct;
  gint rx, ry;
  GdkWindow *text_window;
  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
  if(!gtk_cairo_should_draw_window(cr, text_window))
  {
    return FALSE;
  }
  gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
  gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
  style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
  gtk_style_context_save(style);
  gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
  gtk_style_context_get_color(style, GTK_STATE_FLAG_NORMAL, &amp;fg);
  gtk_style_context_restore(style);
  if(priv-&gt;show_remote_selections)
  {
    window_width = gdk_window_get_width(text_window);
    gtk_rgb_to_hsv(fg.red, fg.green, fg.blue, &amp;hs, &amp;ss, &amp;vs);
    vs = MAX(vs, 0.5);
    ss = 1.0 - 0.4*(vs);
    gtk_text_view_window_to_buffer_coords(
      priv-&gt;textview,
      GTK_TEXT_WINDOW_TEXT,
      clip_area.x, clip_area.y,
      &amp;ax, &amp;ay
    );
    gtk_text_view_get_iter_at_location(
      priv-&gt;textview,
      &amp;begin_iter,
      ax,
      ay
    );
    gtk_text_view_get_iter_at_location(
      priv-&gt;textview,
      &amp;end_iter,
      ax + clip_area.width,
      ay + clip_area.height
    );
    area_begin = gtk_text_iter_get_offset(&amp;begin_iter);
    area_end = gtk_text_iter_get_offset(&amp;end_iter);
    g_assert(area_end &gt;= area_begin);
    gtk_text_buffer_get_selection_bounds(
      gtk_text_view_get_buffer(priv-&gt;textview),
      &amp;begin_iter,
      &amp;end_iter
    );
    own_sel_begin = gtk_text_iter_get_offset(&amp;begin_iter);
    own_sel_end = gtk_text_iter_get_offset(&amp;end_iter);
    if(own_sel_begin != own_sel_end)
    {
      gtk_text_view_get_iter_location(priv-&gt;textview, &amp;begin_iter, &amp;rct);
      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        rct.x, rct.y,
        &amp;osbx, &amp;osby
      );
      gtk_text_view_get_iter_location(priv-&gt;textview, &amp;end_iter, &amp;rct);
      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        rct.x, rct.y,
        &amp;osex, &amp;osey
      );
    }
    toggles = g_sequence_new(inf_text_gtk_view_user_toggle_free);
    for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    {
      view_user = (InfTextGtkViewUser*)item-&gt;data;
      if(inf_text_user_get_selection_length(view_user-&gt;user) != 0)
      {
        begin = inf_text_user_get_caret_position(view_user-&gt;user);
        sel = inf_text_user_get_selection_length(view_user-&gt;user);
        if(sel &gt; 0)
        {
          end = begin + sel;
        }
        else
        {
          g_assert(begin &gt;= (unsigned int)-sel);
          end = begin;
          begin += sel;
        }
        if(begin &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
          begin = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
        if(end &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
          end = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
        begin = MIN(MAX(begin, area_begin), area_end);
        end = MIN(MAX(end, area_begin), area_end);
        g_assert(end &gt;= begin);
        if(begin != end)
        {
          if(sel &gt; 0)
          {
            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;cursor_rect.x,
              view_user-&gt;cursor_rect.y,
              &amp;rx, &amp;ry
            );
            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;selection_bound_rect.x,
              view_user-&gt;selection_bound_rect.y,
              &amp;ax, &amp;ay
            );
          }
          else
          {
            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;selection_bound_rect.x,
              view_user-&gt;selection_bound_rect.y,
              &amp;rx, &amp;ry
            );
            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;cursor_rect.x,
              view_user-&gt;cursor_rect.y,
              &amp;ax, &amp;ay
            );
          }
          if(own_sel_begin == own_sel_end ||
             own_sel_end &lt;= begin || own_sel_begin &gt;= end)
          {
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, end,
              view_user,
              rx, ry,
              ax, ay
            );
          }
          else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &gt;= end)
          {
          }
          else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &gt;= end)
          {
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, own_sel_begin,
              view_user,
              rx, ry,
              osbx, osby
            );
          }
          else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &lt; end)
          {
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              own_sel_end, end,
              view_user,
              osex, osey,
              ax, ay
            );
          }
          else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &lt; end)
          {
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, own_sel_begin,
              view_user,
              rx, ry,
              osbx, osby
            );
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              own_sel_end, end,
              view_user,
              osex, osey,
              ax, ay
            );
          }
          else
          {
            g_assert_not_reached();
          }
        }
      }
    }
    tog_iter = g_sequence_get_begin_iter(toggles);
    cur_toggle = NULL;
    prev_toggle = NULL;
    users = NULL;
    n_users = 0;
    tog_iter = g_sequence_get_begin_iter(toggles);
    while(!g_sequence_iter_is_end(tog_iter))
    {
      cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
      if(users != NULL)
      {
        g_assert(prev_toggle != NULL);
        g_assert(n_users &gt; 0);
        hadjustment =
          gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
        vadjustment =
          gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));
        rx = gtk_adjustment_get_value(hadjustment);
        ry = gtk_adjustment_get_value(vadjustment);
        pattern =
          cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
        cairo_matrix_init_translate(&amp;matrix, rx, ry);
        cairo_pattern_set_matrix(pattern, &amp;matrix);
        cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
        for(item = users, n = 0.0; item != NULL; item = item-&gt;next, n += 1.0)
        {
          view_user = ((InfTextGtkViewUserToggle*)item-&gt;data)-&gt;user;
          hs = inf_text_user_get_hue(view_user-&gt;user);
          gtk_hsv_to_rgb(hs, ss, vs, &amp;rs, &amp;gs, &amp;bs);
          cairo_pattern_add_color_stop_rgba(
            pattern,
            n/n_users,
            rs, gs, bs, 0.5
          );
          cairo_pattern_add_color_stop_rgba(
            pattern,
            (n+1.0)/n_users,
            rs, gs, bs, 0.5
          );
        }
        cairo_set_source(cr, pattern);
        if(prev_toggle-&gt;y == cur_toggle-&gt;y)
        {
          g_assert(prev_toggle-&gt;x &lt; cur_toggle-&gt;x);
          rct.x = prev_toggle-&gt;x;
          rct.y = prev_toggle-&gt;y;
          rct.width = cur_toggle-&gt;x - prev_toggle-&gt;x;
          rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
          gdk_cairo_rectangle(cr, &amp;rct);
        }
        else
        {
          g_assert(
            cur_toggle-&gt;y - prev_toggle-&gt;y &gt;=
            cur_toggle-&gt;user-&gt;selection_bound_rect.height
          );
          if(window_width &gt; prev_toggle-&gt;x)
          {
            rct.x = prev_toggle-&gt;x;
            rct.y = prev_toggle-&gt;y;
            rct.width = window_width - prev_toggle-&gt;x -
              inf_text_gtk_view_get_right_margin(priv-&gt;textview);
            rct.height = prev_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }
          if(cur_toggle-&gt;x &gt; 0)
          {
            rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
            rct.y = cur_toggle-&gt;y;
            rct.width = cur_toggle-&gt;x - rct.x;
            rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }
          if(cur_toggle-&gt;y - prev_toggle-&gt;y &gt;
             cur_toggle-&gt;user-&gt;selection_bound_rect.height)
          {
            rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
            rct.y = prev_toggle-&gt;y +
              prev_toggle-&gt;user-&gt;selection_bound_rect.height;
            rct.width = window_width - rct.x -
              inf_text_gtk_view_get_right_margin(priv-&gt;textview);
            rct.height = cur_toggle-&gt;y - prev_toggle-&gt;y -
              cur_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }
        }
        cairo_fill(cr);
        cairo_pattern_destroy(pattern);
      }
      prev_toggle = cur_toggle;
      do
      {
        if(cur_toggle-&gt;on_toggle == NULL)
        {
          users = g_slist_insert_sorted(
            users,
            cur_toggle,
            inf_text_gtk_view_user_toggle_user_cmp
          );
          ++n_users;
        }
        else
        {
          g_assert(n_users &gt; 0);
          users = g_slist_remove(users, cur_toggle-&gt;on_toggle);
          --n_users;
        }
        tog_iter = g_sequence_iter_next(tog_iter);
        if(g_sequence_iter_is_end(tog_iter))
          break;
        cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
      } while(cur_toggle-&gt;pos == prev_toggle-&gt;pos);
    }
    g_assert(n_users == 0);
    g_assert(users == NULL);
    g_sequence_free(toggles);
  }
  if(priv-&gt;show_remote_cursors)
  {
    gtk_widget_style_get (widget, "cursor-color", &amp;cursor_color, NULL);
    if(cursor_color != NULL)
    {
      rc = cursor_color-&gt;red / 65535.0;
      bc = cursor_color-&gt;green / 65535.0;
      gc = cursor_color-&gt;blue / 65535.0;
      gdk_color_free(cursor_color);
    }
    else
    {
      rc = fg.red;
      bc = fg.green;
      gc = fg.blue;
    }
    gtk_rgb_to_hsv(rc, bc, gc, &amp;hc, &amp;sc, &amp;vc);
    sc = MIN(MAX(sc, 0.3), 0.8);
    vc = MAX(vc, 0.7);
    for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    {
      view_user = (InfTextGtkViewUser*)item-&gt;data;
      if(view_user-&gt;cursor_visible)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
          &amp;rct.x, &amp;rct.y
        );
        rct.width = view_user-&gt;cursor_rect.width;
        rct.height = view_user-&gt;cursor_rect.height;
        if(gdk_rectangle_intersect(&amp;clip_area, &amp;rct, NULL))
        {
          hc = inf_text_user_get_hue(view_user-&gt;user);
          gtk_hsv_to_rgb(hc, sc, vc, &amp;rc, &amp;gc, &amp;bc);
          cairo_set_source_rgb(cr, rc, gc, bc);
          gdk_cairo_rectangle(cr, &amp;rct);
          cairo_fill(cr);
        }
      }
    }
  }
  return FALSE;
}
static void
inf_text_gtk_view_style_updated_cb(GtkWidget* widget,
                                   gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  InfTextGtkViewUser* view_user;
  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    view_user = (InfTextGtkViewUser*)item-&gt;data;
    inf_text_gtk_view_user_compute_user_area(view_user);
  }
}
static void
inf_text_gtk_view_size_allocate_cb(GtkWidget* widget,
                                   GtkAllocation* allocation,
                                   gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  InfTextGtkViewUser* view_user;
  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    view_user = (InfTextGtkViewUser*)item-&gt;data;
    inf_text_gtk_view_user_compute_user_area(view_user);
  }
}
static void
inf_text_gtk_view_user_cursor_blink_timeout_func(gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;
  GtkSettings* settings;
  gboolean cursor_blink;
  gint cursor_blink_time;
  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
  view_user-&gt;cursor_visible = !view_user-&gt;cursor_visible;
  inf_text_gtk_view_user_invalidate_user_area(view_user);
  settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));
  g_object_get(
    G_OBJECT(settings),
    "gtk-cursor-blink", &amp;cursor_blink,
    "gtk-cursor-blink-time", &amp;cursor_blink_time,
    NULL
  );
  if(cursor_blink)
  {
    if(!view_user-&gt;cursor_visible)
      cursor_blink_time = cursor_blink_time * 1 / 3;
    else
      cursor_blink_time = cursor_blink_time * 2 / 3;
    view_user-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      cursor_blink_time,
      inf_text_gtk_view_user_cursor_blink_timeout_func,
      view_user,
      NULL
    );
  }
  else
  {
    view_user-&gt;timeout = NULL;
  }
}
static void
inf_text_gtk_view_user_reset_timeout(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GtkSettings* settings;
  gboolean cursor_blink;
  gint cursor_blink_time;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
  if(view_user-&gt;timeout)
  {
    inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
    view_user-&gt;timeout = NULL;
  }
  if(!view_user-&gt;cursor_visible)
  {
    view_user-&gt;cursor_visible = TRUE;
    inf_text_gtk_view_user_invalidate_user_area(view_user);
  }
  settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));
  g_object_get(
    G_OBJECT(settings),
    "gtk-cursor-blink", &amp;cursor_blink,
    "gtk-cursor-blink-time", &amp;cursor_blink_time,
    NULL
  );
  if(cursor_blink)
  {
    view_user-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      cursor_blink_time,
      inf_text_gtk_view_user_cursor_blink_timeout_func,
      view_user,
      NULL
    );
  }
}
static gboolean
inf_text_gtk_view_user_selection_changed_cb_idle_func(gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  view_user = (InfTextGtkViewUser*)user_data;
  g_assert(view_user-&gt;revalidate_idle != 0);
  view_user-&gt;revalidate_idle = 0;
  inf_text_gtk_view_user_invalidate_user_area(view_user);
  return FALSE;
}
static void
inf_text_gtk_view_user_selection_changed_cb(InfTextUser* user,
                                            guint position,
                                            gint length,
                                            gboolean by_request,
                                            gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;
  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
  if(by_request)
  {
    inf_text_gtk_view_user_invalidate_user_area(view_user);
  }
  inf_text_gtk_view_user_compute_user_area(view_user);
  if(by_request)
  {
    inf_text_gtk_view_user_reset_timeout(view_user);
    if(view_user-&gt;revalidate_idle == 0)
    {
      view_user-&gt;revalidate_idle = g_idle_add_full(
        GTK_TEXT_VIEW_PRIORITY_VALIDATE + 1,
        inf_text_gtk_view_user_selection_changed_cb_idle_func,
        view_user,
        NULL
      );
    }
  }
}
static void
inf_text_gtk_view_user_notify_hue_cb(GObject* object,
                                     GParamSpec* pspec,
                                     gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;
  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
  gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
}
static void
inf_text_gtk_view_add_user(InfTextGtkView* view,
                           InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextGtkViewUser* view_user;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  view_user = g_slice_new(InfTextGtkViewUser);
  view_user-&gt;view = view;
  view_user-&gt;user = INF_TEXT_USER(user);
  view_user-&gt;cursor_visible = TRUE;
  view_user-&gt;timeout = NULL;
  view_user-&gt;revalidate_idle = 0;
  inf_text_gtk_view_user_compute_user_area(view_user);
  inf_text_gtk_view_user_reset_timeout(view_user);
  priv-&gt;users = g_slist_prepend(priv-&gt;users, view_user);
  g_signal_connect_after(
    user,
    "selection-changed",
    G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
    view_user
  );
  g_signal_connect(
    user,
    "notify::hue",
    G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
    view_user
  );
  inf_text_gtk_view_user_invalidate_user_area(view_user);
}
static void
inf_text_gtk_view_remove_user(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
  inf_signal_handlers_disconnect_by_func(
    view_user-&gt;user,
    G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
    view_user
  );
  inf_signal_handlers_disconnect_by_func(
    view_user-&gt;user,
    G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
    view_user
  );
  if(view_user-&gt;timeout != NULL)
    inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
  if(view_user-&gt;revalidate_idle != 0)
    g_source_remove(view_user-&gt;revalidate_idle);
  inf_text_gtk_view_user_invalidate_user_area(view_user);
  priv-&gt;users = g_slist_remove(priv-&gt;users, view_user);
  g_slice_free(InfTextGtkViewUser, view_user);
}
static void
inf_text_gtk_view_user_notify_status_cb(GObject* object,
                                        GParamSpec* pspec,
                                        gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  InfTextUser* user;
  InfTextGtkViewUser* view_user;
  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  user = INF_TEXT_USER(object);
  g_assert(user != priv-&gt;active_user);
  view_user = inf_text_gtk_view_find_user(view, user);
  if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
  {
    if(!view_user)
      inf_text_gtk_view_add_user(view, user);
  }
  else
  {
    if(view_user)
      inf_text_gtk_view_remove_user(view_user);
  }
}
static void
inf_text_gtk_view_user_removed(InfTextGtkView* view,
                               InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextGtkViewUser* view_user;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  if(user == priv-&gt;active_user)
  {
    priv-&gt;active_user = NULL;
    g_object_notify(G_OBJECT(view), "active-user");
  }
  else
  {
    inf_signal_handlers_disconnect_by_func(
      user,
      G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
      view
    );
    if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
    {
      view_user = inf_text_gtk_view_find_user(view, user);
      g_assert(view_user != NULL);
      inf_text_gtk_view_remove_user(view_user);
    }
  }
}
static void
inf_text_gtk_view_user_added(InfTextGtkView* view,
                             InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  g_assert(user != priv-&gt;active_user);
  g_signal_connect(
    user,
    "notify::status",
    G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
    view
  );
  if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
    inf_text_gtk_view_add_user(view, user);
}
static void
inf_text_gtk_view_add_user_cb(InfUserTable* user_table,
                              InfUser* user,
                              gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
}
static void
inf_text_gtk_view_remove_user_cb(InfUserTable* user_table,
                                 InfUser* user,
                                 gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
}
static void
inf_text_gtk_view_set_user_table_foreach_new_user_func(InfUser* user,
                                                       gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
}
static void
inf_text_gtk_view_set_user_table_foreach_old_user_func(InfUser* user,
                                                       gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
}
static void
inf_text_gtk_view_set_view(InfTextGtkView* view,
                           GtkTextView* gtk_view)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  if(priv-&gt;textview != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_draw_before_cb),
      view
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_draw_after_cb),
      view
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_style_updated_cb),
      view
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
      view
    );
    g_object_unref(priv-&gt;textview);
  }
  priv-&gt;textview = gtk_view;
  if(gtk_view != NULL)
  {
    g_object_ref(gtk_view);
    g_signal_connect(
      G_OBJECT(gtk_view),
      "draw",
      G_CALLBACK(inf_text_gtk_view_draw_before_cb),
      view
    );
    g_signal_connect_after(
      G_OBJECT(gtk_view),
      "draw",
      G_CALLBACK(inf_text_gtk_view_draw_after_cb),
      view
    );
    g_signal_connect_after(
      G_OBJECT(gtk_view),
      "style-updated",
      G_CALLBACK(inf_text_gtk_view_style_updated_cb),
      view
    );
    g_signal_connect_after(
      G_OBJECT(gtk_view),
      "size-allocate",
      G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
      view
    );
  }
  g_object_notify(G_OBJECT(view), "view");
}
static void
inf_text_gtk_view_set_user_table(InfTextGtkView* view,
                                 InfUserTable* user_table)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  if(priv-&gt;user_table != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_text_gtk_view_add_user_cb),
      view
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_text_gtk_view_remove_user_cb),
      view
    );
    inf_user_table_foreach_user(
      priv-&gt;user_table,
      inf_text_gtk_view_set_user_table_foreach_old_user_func,
      view
    );
    g_object_unref(priv-&gt;user_table);
  }
  priv-&gt;user_table = user_table;
  if(user_table != NULL)
  {
    g_object_ref(user_table);
    g_signal_connect(
      G_OBJECT(user_table),
      "add-user",
      G_CALLBACK(inf_text_gtk_view_add_user_cb),
      view
    );
    g_signal_connect(
      G_OBJECT(user_table),
      "remove-user",
      G_CALLBACK(inf_text_gtk_view_remove_user_cb),
      view
    );
    inf_user_table_foreach_user(
      user_table,
      inf_text_gtk_view_set_user_table_foreach_new_user_func,
      view
    );
  }
  g_object_notify(G_OBJECT(view), "user-table");
}
static void
inf_text_gtk_view_init(InfTextGtkView* view)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  priv-&gt;io = NULL;
  priv-&gt;textview = NULL;
  priv-&gt;user_table = NULL;
  priv-&gt;active_user = NULL;
  priv-&gt;users = NULL;
  priv-&gt;show_remote_cursors = TRUE;
  priv-&gt;show_remote_selections = TRUE;
  priv-&gt;show_remote_current_lines = TRUE;
}
static void
inf_text_gtk_view_dispose(GObject* object)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  inf_text_gtk_view_set_user_table(view, NULL);
  inf_text_gtk_view_set_view(view, NULL);
  g_assert(priv-&gt;active_user == NULL);
  g_assert(priv-&gt;users == NULL);
  if(priv-&gt;io != NULL)
  {
    g_object_unref(priv-&gt;io);
    priv-&gt;io = NULL;
  }
  G_OBJECT_CLASS(inf_text_gtk_view_parent_class)-&gt;dispose(object);
}
static void
inf_text_gtk_view_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_VIEW:
    g_assert(priv-&gt;textview == NULL); 
    inf_text_gtk_view_set_view(
      view,
      GTK_TEXT_VIEW(g_value_get_object(value))
    );
    break;
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL); 
    inf_text_gtk_view_set_user_table(
      view,
      INF_USER_TABLE(g_value_get_object(value))
    );
    break;
  case PROP_ACTIVE_USER:
    inf_text_gtk_view_set_active_user(
      view,
      INF_TEXT_USER(g_value_get_object(value))
    );
    break;
  case PROP_SHOW_REMOTE_CURSORS:
    inf_text_gtk_view_set_show_remote_cursors(
      view,
      g_value_get_boolean(value)
    );
    break;
  case PROP_SHOW_REMOTE_SELECTIONS:
    inf_text_gtk_view_set_show_remote_selections(
      view,
      g_value_get_boolean(value)
    );
    break;
  case PROP_SHOW_REMOTE_CURRENT_LINES:
    inf_text_gtk_view_set_show_remote_current_lines(
      view,
      g_value_get_boolean(value)
    );
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(value, prop_id, pspec);
    break;
  }
}
static void
inf_text_gtk_view_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_VIEW:
    g_value_set_object(value, G_OBJECT(priv-&gt;textview));
    break;
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;
  case PROP_ACTIVE_USER:
    g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
    break;
  case PROP_SHOW_REMOTE_CURSORS:
    g_value_set_boolean(value, priv-&gt;show_remote_cursors);
    break;
  case PROP_SHOW_REMOTE_SELECTIONS:
    g_value_set_boolean(value, priv-&gt;show_remote_selections);
    break;
  case PROP_SHOW_REMOTE_CURRENT_LINES:
    g_value_set_boolean(value, priv-&gt;show_remote_current_lines);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_text_gtk_view_class_init(InfTextGtkViewClass* view_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(view_class);
  object_class-&gt;dispose = inf_text_gtk_view_dispose;
  object_class-&gt;set_property = inf_text_gtk_view_set_property;
  object_class-&gt;get_property = inf_text_gtk_view_get_property;
  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      "io",
      "IO",
      "The IO object to schedule timeouts",
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_VIEW,
    g_param_spec_object(
      "view",
      "View",
      "The underlying GtkTextView",
      GTK_TYPE_TEXT_VIEW,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      "user-table",
      "User table",
      "The user table containing the users of the session shown in the view",
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_ACTIVE_USER,
    g_param_spec_object(
      "active-user",
      "Active user",
      "The user for which to show the view",
      INF_TEXT_TYPE_USER,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_CURSORS,
    g_param_spec_boolean(
      "show-remote-cursors",
      "Show remote cursors",
      "Whether to show cursors of non-local users",
      TRUE,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_SELECTIONS,
    g_param_spec_boolean(
      "show-remote-selections",
      "Show remote selections",
      "Whether to highlight text selected by non-local users",
      TRUE,
      G_PARAM_READWRITE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_CURRENT_LINES,
    g_param_spec_boolean(
      "show-remote-current-lines",
      "Show remote current lines",
      "Whether to highlight the line in which the cursor of non-local users is",
      TRUE,
      G_PARAM_READWRITE
    )
  );
}
InfTextGtkView*
inf_text_gtk_view_new(InfIo* io,
                      GtkTextView* view,
                      InfUserTable* user_table)
{
  GObject* object;
  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(GTK_IS_TEXT_VIEW(view), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
  object = g_object_new(
    INF_TEXT_GTK_TYPE_VIEW,
    "io", io,
    "view", view,
    "user-table", user_table,
    NULL
  );
  return INF_TEXT_GTK_VIEW(object);
}
GtkTextView*
inf_text_gtk_view_get_text_view(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;textview;
}
InfUserTable*
inf_text_gtk_view_get_user_table(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;user_table;
}
void
inf_text_gtk_view_set_active_user(InfTextGtkView* view,
                                  InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextUser* active_user;
  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  g_return_if_fail(
    user == NULL ||
    inf_user_table_lookup_user_by_id(
      priv-&gt;user_table,
      inf_user_get_id(INF_USER(user))
    ) == INF_USER(user)
  );
  if(priv-&gt;active_user != NULL)
  {
    active_user = priv-&gt;active_user;
    priv-&gt;active_user = NULL;
    inf_text_gtk_view_user_added(view, active_user);
  }
  if(user != NULL)
  {
    inf_text_gtk_view_user_removed(view, user);
  }
  priv-&gt;active_user = user;
  g_object_notify(G_OBJECT(view), "active-user");
}
InfTextUser*
inf_text_gtk_view_get_active_user(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;active_user;
}
void
inf_text_gtk_view_set_show_remote_cursors(InfTextGtkView* view,
                                          gboolean show)
{
  InfTextGtkViewPrivate* priv;
  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  if(priv-&gt;show_remote_cursors != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
    priv-&gt;show_remote_cursors = show;
    g_object_notify(G_OBJECT(view), "show-remote-cursors");
  }
}
void
inf_text_gtk_view_set_show_remote_selections(InfTextGtkView* view,
                                             gboolean show)
{
  InfTextGtkViewPrivate* priv;
  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  if(priv-&gt;show_remote_selections != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
    priv-&gt;show_remote_selections = show;
    g_object_notify(G_OBJECT(view), "show-remote-selections");
  }
}
void
inf_text_gtk_view_set_show_remote_current_lines(InfTextGtkView* view,
                                                gboolean show)
{
  InfTextGtkViewPrivate* priv;
  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  if(priv-&gt;show_remote_current_lines != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
    priv-&gt;show_remote_current_lines = show;
    g_object_notify(G_OBJECT(view), "show-remote-current-lines");
  }
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
