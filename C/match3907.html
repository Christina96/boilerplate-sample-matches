<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inputfilegen.c &amp; stream.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inputfilegen.c &amp; stream.c
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inputfilegen.c (16.304348%)<th>stream.c (0.9009009%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(44-57)<td><a href="#" name="0">(261-274)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inputfilegen.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;stdio.h&gt;
2 #include &lt;stdlib.h&gt;
3 #include &lt;unistd.h&gt;
4 #include &lt;string.h&gt;
5 #if defined(_AIX)
6 	#include  &lt;unistd.h&gt;
7 #else
8 	#include &lt;getopt.h&gt;
9 #endif
10 #define DEFMSGS 5
11 #define NOEXTRADATA -1
12 int main(int argc, char* argv[])
13 {
14 	int c, i;
15 	long long nmsgs = DEFMSGS;
16 	long long nmsgstart = 0;
17 	int nchars = NOEXTRADATA;
18 	int errflg = 0;
19 	long long filesize = -1;
20 	char *extradata = NULL;
21 <a name="0"></a>	const char *msgcntfile = NULL;
22 	while((c=getopt(argc, argv, "m:M:i:d:s:")) != -1) {
23 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		switch(c) {
24 		case 'm':
25 			nmsgs = atoi(optarg);
26 			break;
27 		case 'M':
28 			msgcntfile = optarg;
29 			break;
30 		case 'i':
31 			nmsgstart = atoi(optarg);
32 			break;
33 		case 'd':
34 			nchars = atoi(optarg);
35 			break;
36 		case 's':</b></font>
37 			filesize = atoll(optarg);
38 			break;
39 		case ':':
40 			fprintf(stderr, "Option -%c requires an operand\n", optopt);
41 			errflg++;
42 			break;
43 		case '?':
44 			fprintf(stderr, "Unrecognized option: -%c\n", optopt);
45 			errflg++;
46 			break;
47 		}
48 	}
49 	if(errflg) {
50 		fprintf(stderr, "invalid call\n");
51 		exit(2);
52 	}
53 	if(filesize != -1) {
54 		const int linesize = (17 + nchars); 		nmsgs = filesize / linesize;
55 		fprintf(stderr, "file size requested %lld, actual %lld with "
56 			"%lld lines, %lld bytes less\n",
57 			filesize, nmsgs * linesize, nmsgs, filesize - nmsgs * linesize);
58 		if(nmsgs &gt; 100000000) {
59 			fprintf(stderr, "number of lines exhaust 8-digit line numbers "
60 				"which are standard inside the testbench.\n"
61 				"Use -d switch to add extra data (e.g. -d111 for "
62 				"128 byte lines or -d47 for 64 byte lines)\n");
63 			exit(1);
64 		}
65 	}
66 	if(msgcntfile != NULL) {
67 		FILE *const fh = fopen(msgcntfile, "w");
68 		if(fh == NULL) {
69 			perror(msgcntfile);
70 			exit(1);
71 		}
72 		fprintf(fh, "%lld", nmsgs);
73 		fclose(fh);
74 	}
75 	if(nchars != NOEXTRADATA) {
76 		extradata = (char *)malloc(nchars + 1);
77 		memset(extradata, 'X', nchars);
78 		extradata[nchars] = '\0';
79 	}
80 	for(i = nmsgstart; i &lt; (nmsgs+nmsgstart); ++i) {
81 		printf("msgnum:%8.8d:", i);
82 		if(nchars != NOEXTRADATA) {
83 			printf("%s", extradata);
84 		}
85 		printf("\n");
86 	}
87 	free(extradata);
88 	return 0;
89 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>stream.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;signal.h&gt;
6 #include &lt;pthread.h&gt;
7 #include &lt;fcntl.h&gt;
8 #include &lt;unistd.h&gt;
9 #include &lt;sys/types.h&gt;
10 #include &lt;sys/stat.h&gt;	 #include &lt;errno.h&gt;
11 #include &lt;pthread.h&gt;
12 #include &lt;poll.h&gt;
13 #ifdef HAVE_SYS_PRCTL_H
14 #  include &lt;sys/prctl.h&gt;
15 #endif
16 #include "rsyslog.h"
17 #include "stringbuf.h"
18 #include "srUtils.h"
19 #include "obj.h"
20 #include "stream.h"
21 #include "unicode-helper.h"
22 #include "module-template.h"
23 #include "errmsg.h"
24 #include "cryprov.h"
25 #include "datetime.h"
26 #include "rsconf.h"
27 #ifndef O_LARGEFILE
28 #  define O_LARGEFILE 0
29 #endif
30 #ifndef HAVE_LSEEK64
31 #  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
32 #endif
33 DEFobjStaticHelpers
34 DEFobjCurrIf(zlibw)
35 static rsRetVal strmFlushInternal(strm_t *pThis, int bFlushZip);
36 static rsRetVal strmWrite(strm_t *__restrict__ const pThis, const uchar *__restrict__ const pBuf,
37 	const size_t lenBuf);
38 static rsRetVal strmOpenFile(strm_t *pThis);
39 static rsRetVal strmCloseFile(strm_t *pThis);
40 static void *asyncWriterThread(void *pPtr);
41 static rsRetVal doZipWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf, int bFlush);
42 static rsRetVal doZipFinish(strm_t *pThis);
43 static rsRetVal strmPhysWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf);
44 static rsRetVal strmSeekCurrOffs(strm_t *pThis);
45 const uchar * ATTR_NONNULL()
46 strmGetPrevLineSegment(strm_t *const pThis)
47 {
48 	const uchar *ret = NULL;
49 	if(pThis-&gt;prevLineSegment != NULL) {
50 		cstrFinalize(pThis-&gt;prevLineSegment);
51 		ret = rsCStrGetSzStrNoNULL(pThis-&gt;prevLineSegment);
52 	}
53 	return ret;
54 }
55 const uchar * ATTR_NONNULL()
56 strmGetPrevMsgSegment(strm_t *const pThis)
57 {
58 	const uchar *ret = NULL;
59 	if(pThis-&gt;prevMsgSegment != NULL) {
60 		cstrFinalize(pThis-&gt;prevMsgSegment);
61 		ret = rsCStrGetSzStrNoNULL(pThis-&gt;prevMsgSegment);
62 	}
63 	return ret;
64 }
65 int ATTR_NONNULL()
66 strmGetPrevWasNL(const strm_t *const pThis)
67 {
68 	return pThis-&gt;bPrevWasNL;
69 }
70 static const char *
71 getFileDebugName(const strm_t *const pThis)
72 {
73 	  return (pThis-&gt;pszCurrFName == NULL) ?
74 		  ((pThis-&gt;pszFName == NULL) ? "N/A" : (char*)pThis-&gt;pszFName)
75 		: (const char*) pThis-&gt;pszCurrFName;
76 }
77 static rsRetVal
78 resolveFileSizeLimit(strm_t *pThis, uchar *pszCurrFName)
79 {
80 	uchar *pParams;
81 	uchar *pCmd;
82 	uchar *p;
83 	off_t actualFileSize;
84 	rsRetVal localRet;
85 	DEFiRet;
86 	ISOBJ_TYPE_assert(pThis, strm);
87 	assert(pszCurrFName != NULL);
88 	if(pThis-&gt;pszSizeLimitCmd == NULL) {
89 		ABORT_FINALIZE(RS_RET_NON_SIZELIMITCMD); 	}
90 	CHKmalloc(pCmd = ustrdup(pThis-&gt;pszSizeLimitCmd));
91 	for(p = pCmd ; *p &amp;&amp; *p != ' ' ; ++p) {
92 	}
93 	if(*p == ' ') {
94 		*p = '\0'; 		pParams = p+1;
95 	} else
96 		pParams = NULL;
97 	execProg(pCmd, 1, pParams);
98 	free(pCmd);
99 	localRet = getFileSize(pszCurrFName, &amp;actualFileSize);
100 	if(localRet == RS_RET_OK &amp;&amp; actualFileSize &gt;= pThis-&gt;iSizeLimit) {
101 		ABORT_FINALIZE(RS_RET_SIZELIMITCMD_DIDNT_RESOLVE); 	} else if(localRet != RS_RET_FILE_NOT_FOUND) {
102 		ABORT_FINALIZE(localRet);
103 	}
104 finalize_it:
105 	if(iRet != RS_RET_OK) {
106 		if(iRet == RS_RET_SIZELIMITCMD_DIDNT_RESOLVE) {
107 			LogError(0, RS_RET_ERR, "file size limit cmd for file '%s' "
108 				"did no resolve situation\n", pszCurrFName);
109 		} else {
110 			LogError(0, RS_RET_ERR, "file size limit cmd for file '%s' "
111 				"failed with code %d.\n", pszCurrFName, iRet);
112 		}
113 		pThis-&gt;bDisabled = 1;
114 	}
115 	RETiRet;
116 }
117 static rsRetVal
118 doSizeLimitProcessing(strm_t *pThis)
119 {
120 	uchar *pszCurrFName = NULL;
121 	DEFiRet;
122 	ISOBJ_TYPE_assert(pThis, strm);
123 	assert(pThis-&gt;iSizeLimit != 0);
124 	assert(pThis-&gt;fd != -1);
125 	if(pThis-&gt;iCurrOffs &gt;= pThis-&gt;iSizeLimit) {
126 		CHKmalloc(pszCurrFName = ustrdup(pThis-&gt;pszCurrFName));
127 		CHKiRet(strmCloseFile(pThis));
128 		CHKiRet(resolveFileSizeLimit(pThis, pszCurrFName));
129 	}
130 finalize_it:
131 	free(pszCurrFName);
132 	RETiRet;
133 }
134 static rsRetVal
135 doPhysOpen(strm_t *pThis)
136 {
137 	int iFlags = 0;
138 	struct stat statOpen;
139 	DEFiRet;
140 <a name="0"></a>	ISOBJ_TYPE_assert(pThis, strm);
141 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	switch(pThis-&gt;tOperationsMode) {
142 		case STREAMMODE_READ:
143 			iFlags = O_CLOEXEC | O_NOCTTY | O_RDONLY;
144 			break;
145 		case STREAMMODE_WRITE:				iFlags = O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT;
146 			break;
147 		case STREAMMODE_WRITE_TRUNC:
148 			iFlags = O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC;
149 			break;
150 		case STREAMMODE_WRITE_APPEND:
151 			iFlags = O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_APPEND;
152 			break;
153 		case STREAMMMODE_INVALID:</b></font>
154 		default:assert(0);
155 			break;
156 	}
157 	if(pThis-&gt;sType == STREAMTYPE_NAMED_PIPE) {
158 		DBGPRINTF("Note: stream '%s' is a named pipe, open with O_NONBLOCK\n", pThis-&gt;pszCurrFName);
159 		iFlags |= O_NONBLOCK;
160 	}
161 	if(pThis-&gt;bAsyncWrite)d_pthread_mutex_lock(&amp;pThis-&gt;mut);
162 	pThis-&gt;fd = open((char*)pThis-&gt;pszCurrFName, iFlags | O_LARGEFILE, pThis-&gt;tOpenMode);
163 	if(pThis-&gt;bAsyncWrite) d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
164 	const int errno_save = errno; 	DBGPRINTF("file '%s' opened as #%d with mode %d\n", pThis-&gt;pszCurrFName,
165 		  pThis-&gt;fd, (int) pThis-&gt;tOpenMode);
166 	if(pThis-&gt;fd == -1) {
167 		const rsRetVal errcode = (errno_save == ENOENT) ? RS_RET_FILE_NOT_FOUND
168 			: RS_RET_FILE_OPEN_ERROR;
169 		if(pThis-&gt;fileNotFoundError) {
170 			if(pThis-&gt;noRepeatedErrorOutput == 0) {
171 				LogError(errno_save, errcode, "file '%s': open error", pThis-&gt;pszCurrFName);
172 				pThis-&gt;noRepeatedErrorOutput = 1;
173 			}
174 		} else {
175 			DBGPRINTF("file '%s': open error", pThis-&gt;pszCurrFName);
176 		}
177 		ABORT_FINALIZE(errcode);
178 	} else {
179 		pThis-&gt;noRepeatedErrorOutput = 0;
180 	}
181 	if(pThis-&gt;tOperationsMode == STREAMMODE_READ) {
182 		if(fstat(pThis-&gt;fd, &amp;statOpen) == -1) {
183 			DBGPRINTF("Error: cannot obtain inode# for file %s\n", pThis-&gt;pszCurrFName);
184 			ABORT_FINALIZE(RS_RET_IO_ERROR);
185 		}
186 		pThis-&gt;inode = statOpen.st_ino;
187 	}
188 	if(!ustrcmp(pThis-&gt;pszCurrFName, UCHAR_CONSTANT(_PATH_CONSOLE)) || isatty(pThis-&gt;fd)) {
189 		DBGPRINTF("file %d is a tty-type file\n", pThis-&gt;fd);
190 		pThis-&gt;bIsTTY = 1;
191 	} else {
192 		pThis-&gt;bIsTTY = 0;
193 	}
194 	if(pThis-&gt;cryprov != NULL) {
195 		CHKiRet(pThis-&gt;cryprov-&gt;OnFileOpen(pThis-&gt;cryprovData,
196 		 	pThis-&gt;pszCurrFName, &amp;pThis-&gt;cryprovFileData,
197 			(pThis-&gt;tOperationsMode == STREAMMODE_READ) ? 'r' : 'w'));
198 		pThis-&gt;cryprov-&gt;SetDeleteOnClose(pThis-&gt;cryprovFileData, pThis-&gt;bDeleteOnClose);
199 	}
200 finalize_it:
201 	RETiRet;
202 }
203 static rsRetVal
204 strmSetCurrFName(strm_t *pThis)
205 {
206 	DEFiRet;
207 	if(pThis-&gt;sType == STREAMTYPE_FILE_CIRCULAR) {
208 		CHKiRet(genFileName(&amp;pThis-&gt;pszCurrFName, pThis-&gt;pszDir, pThis-&gt;lenDir,
209 				    pThis-&gt;pszFName, pThis-&gt;lenFName, pThis-&gt;iCurrFNum, pThis-&gt;iFileNumDigits));
210 	} else {
211 		if(pThis-&gt;pszDir == NULL) {
212 			if((pThis-&gt;pszCurrFName = ustrdup(pThis-&gt;pszFName)) == NULL)
213 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
214 		} else {
215 			CHKiRet(genFileName(&amp;pThis-&gt;pszCurrFName, pThis-&gt;pszDir, pThis-&gt;lenDir,
216 					    pThis-&gt;pszFName, pThis-&gt;lenFName, -1, 0));
217 		}
218 	}
219 finalize_it:
220 	RETiRet;
221 }
222 static rsRetVal
223 CheckFileChange(strm_t *pThis)
224 {
225 	struct stat statName;
226 	DEFiRet;
227 	CHKiRet(strmSetCurrFName(pThis));
228 	if(stat((char*) pThis-&gt;pszCurrFName, &amp;statName) == -1)
229 		ABORT_FINALIZE(RS_RET_IO_ERROR);
230 	DBGPRINTF("CheckFileChange: stream/after deserialize checking for file change "
231 		"on '%s', inode %u/%u, size/currOffs %llu/%llu\n",
232 		pThis-&gt;pszCurrFName, (unsigned) pThis-&gt;inode,
233 		(unsigned) statName.st_ino,
234 		(long long unsigned) statName.st_size,
235 		(long long unsigned) pThis-&gt;iCurrOffs);
236 	if(pThis-&gt;inode != statName.st_ino || statName.st_size &lt; pThis-&gt;iCurrOffs) {
237 		DBGPRINTF("stream: file %s has changed\n", pThis-&gt;pszCurrFName);
238 		pThis-&gt;iCurrOffs = 0;
239 	}
240 finalize_it:
241 	RETiRet;
242 }
243 static rsRetVal strmOpenFile(strm_t *pThis)
244 {
245 	DEFiRet;
246 	off_t offset;
247 	assert(pThis != NULL);
248 	if(pThis-&gt;fd != -1)
249 		ABORT_FINALIZE(RS_RET_OK);
250 	free(pThis-&gt;pszCurrFName);
251 	pThis-&gt;pszCurrFName = NULL; 
252 	if(pThis-&gt;pszFName == NULL)
253 		ABORT_FINALIZE(RS_RET_FILE_PREFIX_MISSING);
254 	CHKiRet(strmSetCurrFName(pThis));
255 	CHKiRet(doPhysOpen(pThis));
256 	pThis-&gt;iCurrOffs = 0;
257 	pThis-&gt;iBufPtrMax = 0;
258 	CHKiRet(getFileSize(pThis-&gt;pszCurrFName, &amp;offset));
259 	if(pThis-&gt;tOperationsMode == STREAMMODE_WRITE_APPEND) {
260 		pThis-&gt;iCurrOffs = offset;
261 	} else if(pThis-&gt;tOperationsMode == STREAMMODE_WRITE_TRUNC) {
262 		if(offset != 0) {
263 			LogError(0, 0, "file '%s' opened for truncate write, but "
264 				"already contains %zd bytes\n",
265 				pThis-&gt;pszCurrFName, (ssize_t) offset);
266 		}
267 	}
268 	DBGOPRINT((obj_t*) pThis, "opened file '%s' for %s as %d\n", pThis-&gt;pszCurrFName,
269 		  (pThis-&gt;tOperationsMode == STREAMMODE_READ) ? "READ" : "WRITE", pThis-&gt;fd);
270 finalize_it:
271 	if(iRet == RS_RET_OK) {
272 		assert(pThis-&gt;fd != -1);
273 	} else {
274 		if(pThis-&gt;pszCurrFName != NULL) {
275 			free(pThis-&gt;pszCurrFName);
276 			pThis-&gt;pszCurrFName = NULL; 		}
277 		if(pThis-&gt;fd != -1) {
278 			close(pThis-&gt;fd);
279 			pThis-&gt;fd = -1;
280 		}
281 	}
282 	RETiRet;
283 }
284 static void
285 strmWaitAsyncWriterDone(strm_t *pThis)
286 {
287 	if(pThis-&gt;bAsyncWrite) {
288 		while(pThis-&gt;iCnt &gt; 0) {
289 			pthread_cond_signal(&amp;pThis-&gt;notEmpty);
290 			d_pthread_cond_wait(&amp;pThis-&gt;isEmpty, &amp;pThis-&gt;mut);
291 		}
292 	}
293 }
294 static void
295 stopWriter(strm_t *const pThis)
296 {
297 	pThis-&gt;bStopWriter = 1;
298 	pthread_cond_signal(&amp;pThis-&gt;notEmpty);
299 	d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
300 	pthread_join(pThis-&gt;writerThreadID, NULL);
301 }
302 static rsRetVal strmCloseFile(strm_t *pThis)
303 {
304 	off64_t currOffs;
305 	DEFiRet;
306 	assert(pThis != NULL);
307 	DBGOPRINT((obj_t*) pThis, "file %d(%s) closing, bDeleteOnClose %d\n", pThis-&gt;fd,
308 		getFileDebugName(pThis), pThis-&gt;bDeleteOnClose);
309 	if(pThis-&gt;tOperationsMode != STREAMMODE_READ) {
310 		if(pThis-&gt;bAsyncWrite) {
311 			strmWaitAsyncWriterDone(pThis);
312 		}
313 		strmFlushInternal(pThis, 0);
314 		if(pThis-&gt;iZipLevel) {
315 			doZipFinish(pThis);
316 		}
317 		if(pThis-&gt;bAsyncWrite) {
318 			stopWriter(pThis);
319 		}
320 	}
321 	if(pThis-&gt;cryprov != NULL &amp;&amp; pThis-&gt;fd == -1) {
322 		const rsRetVal localRet = strmOpenFile(pThis);
323 		if(localRet != RS_RET_OK) {
324 			LogError(0, localRet, "could not open file %s, this "
325 				"may result in problems with encryption - "
326 				"unfortunately, we cannot do anything against "
327 				"this.", pThis-&gt;pszCurrFName);
328 		}
329 	}
330 	if(pThis-&gt;fd != -1) {
331 		DBGOPRINT((obj_t*) pThis, "file %d(%s) closing\n",
332 			pThis-&gt;fd, getFileDebugName(pThis));
333 		currOffs = lseek64(pThis-&gt;fd, 0, SEEK_CUR);
334 		close(pThis-&gt;fd);
335 		pThis-&gt;fd = -1;
336 		pThis-&gt;inode = 0;
337 		if(pThis-&gt;cryprov != NULL) {
338 			pThis-&gt;cryprov-&gt;OnFileClose(pThis-&gt;cryprovFileData, currOffs);
339 			pThis-&gt;cryprovFileData = NULL;
340 		}
341 	}
342 	if(pThis-&gt;fdDir != -1) {
343 		close(pThis-&gt;fdDir);
344 		pThis-&gt;fdDir = -1;
345 	}
346 	if(pThis-&gt;bDeleteOnClose) {
347 		if(pThis-&gt;pszCurrFName == NULL) {
348 			CHKiRet(genFileName(&amp;pThis-&gt;pszCurrFName, pThis-&gt;pszDir, pThis-&gt;lenDir,
349 					    pThis-&gt;pszFName, pThis-&gt;lenFName, pThis-&gt;iCurrFNum,
350 					    pThis-&gt;iFileNumDigits));
351 		}
352 		DBGPRINTF("strmCloseFile: deleting '%s'\n", pThis-&gt;pszCurrFName);
353 		if(unlink((char*) pThis-&gt;pszCurrFName) == -1) {
354 			char errStr[1024];
355 			int err = errno;
356 			rs_strerror_r(err, errStr, sizeof(errStr));
357 			DBGPRINTF("error %d unlinking '%s' - ignored: %s\n",
358 				   errno, pThis-&gt;pszCurrFName, errStr);
359 		}
360 	}
361 	pThis-&gt;iCurrOffs = 0;	
362 finalize_it:
363 	free(pThis-&gt;pszCurrFName);
364 	pThis-&gt;pszCurrFName = NULL;
365 	RETiRet;
366 }
367 static rsRetVal
368 strmNextFile(strm_t *pThis)
369 {
370 	DEFiRet;
371 	assert(pThis != NULL);
372 	assert(pThis-&gt;sType == STREAMTYPE_FILE_CIRCULAR);
373 	assert(pThis-&gt;iMaxFiles != 0);
374 	assert(pThis-&gt;fd != -1);
375 	CHKiRet(strmCloseFile(pThis));
376 	pThis-&gt;iCurrFNum = (pThis-&gt;iCurrFNum + 1) % pThis-&gt;iMaxFiles;
377 finalize_it:
378 	RETiRet;
379 }
380 static rsRetVal ATTR_NONNULL()
381 strmHandleEOFMonitor(strm_t *const pThis)
382 {
383 	DEFiRet;
384 	struct stat statName;
385 	ISOBJ_TYPE_assert(pThis, strm);
386 	if(stat((char*) pThis-&gt;pszCurrFName, &amp;statName) == -1)
387 		ABORT_FINALIZE(RS_RET_IO_ERROR);
388 	DBGPRINTF("strmHandleEOFMonitor: stream checking for file change on '%s', inode %u/%u size %llu/%llu\n",
389 		pThis-&gt;pszCurrFName, (unsigned) pThis-&gt;inode, (unsigned) statName.st_ino,
390 		(long long unsigned) pThis-&gt;iCurrOffs, (long long unsigned) statName.st_size);
391 	if (pThis-&gt;inode != statName.st_ino
392 		  || (pThis-&gt;bReopenOnTruncate &amp;&amp; statName.st_size &lt; pThis-&gt;iCurrOffs)) {
393 		DBGPRINTF("we had a file change on '%s'\n", pThis-&gt;pszCurrFName);
394 		CHKiRet(strmCloseFile(pThis));
395 		CHKiRet(strmOpenFile(pThis));
396 	} else {
397 		ABORT_FINALIZE(RS_RET_EOF);
398 	}
399 finalize_it:
400 	RETiRet;
401 }
402 static rsRetVal ATTR_NONNULL()
403 strmHandleEOF(strm_t *const pThis)
404 {
405 	DEFiRet;
406 	ISOBJ_TYPE_assert(pThis, strm);
407 	switch(pThis-&gt;sType) {
408 		case STREAMTYPE_FILE_SINGLE:
409 		case STREAMTYPE_NAMED_PIPE:
410 			ABORT_FINALIZE(RS_RET_EOF);
411 			break;
412 		case STREAMTYPE_FILE_CIRCULAR:
413 			DBGOPRINT((obj_t*) pThis, "file %d EOF\n", pThis-&gt;fd);
414 			CHKiRet(strmNextFile(pThis));
415 			break;
416 		case STREAMTYPE_FILE_MONITOR:
417 			DBGOPRINT((obj_t*) pThis, "file '%s' (%d) EOF, rotationCheck %d\n",
418 				pThis-&gt;pszCurrFName, pThis-&gt;fd, pThis-&gt;rotationCheck);
419 			if(pThis-&gt;rotationCheck == STRM_ROTATION_DO_CHECK) {
420 				CHKiRet(strmHandleEOFMonitor(pThis));
421 			} else {
422 				ABORT_FINALIZE(RS_RET_EOF);
423 			}
424 			break;
425 	}
426 finalize_it:
427 	RETiRet;
428 }
429 static rsRetVal ATTR_NONNULL()
430 rereadTruncated(strm_t *const pThis, const int err_no, const char *const reason, const long long data)
431 {
432 	DEFiRet;
433 	LogMsg(err_no, RS_RET_FILE_TRUNCATED, LOG_WARNING, "file '%s': truncation detected, "
434 		"(%s) - re-start reading from beginning (data %lld)",
435 		pThis-&gt;pszCurrFName, reason, data);
436 	DBGPRINTF("checkTruncation, file %s last buffer CHANGED\n", pThis-&gt;pszCurrFName);
437 	CHKiRet(strmCloseFile(pThis));
438 	CHKiRet(strmOpenFile(pThis));
439 	iRet = RS_RET_FILE_TRUNCATED;
440 finalize_it:
441 	RETiRet;
442 }
443 static rsRetVal ATTR_NONNULL()
444 checkTruncation(strm_t *const pThis)
445 {
446 	DEFiRet;
447 	off64_t ret;
448 	assert(pThis-&gt;bReopenOnTruncate);
449 	assert(pThis-&gt;fd != -1);
450 	DBGPRINTF("checkTruncation, file %s, iBufPtrMax %zd\n", pThis-&gt;pszCurrFName, pThis-&gt;iBufPtrMax);
451 	if(pThis-&gt;iBufPtrMax == 0) {
452 		FINALIZE;
453 	}
454 	const off64_t backseek = -1 * (off64_t) pThis-&gt;iBufPtrMax;
455 	ret = lseek64(pThis-&gt;fd, backseek, SEEK_CUR);
456 	if(ret &lt; 0) {
457 		iRet = rereadTruncated(pThis, errno,
458 			"cannot seek backward to begin of last block", backseek);
459 		FINALIZE;
460 	}
461 	const ssize_t lenRead = read(pThis-&gt;fd, pThis-&gt;pIOBuf_truncation, pThis-&gt;iBufPtrMax);
462 	if(lenRead != (ssize_t) pThis-&gt;iBufPtrMax) {
463 		iRet = rereadTruncated(pThis, errno,
464 			"last block could not be re-read", lenRead);
465 		FINALIZE;
466 	}
467 	if(!memcmp(pThis-&gt;pIOBuf_truncation, pThis-&gt;pIOBuf, pThis-&gt;iBufPtrMax)) {
468 		DBGPRINTF("checkTruncation, file %s last buffer unchanged\n", pThis-&gt;pszCurrFName);
469 	} else {
470 		iRet = rereadTruncated(pThis, errno, "last block data different", 0);
471 	}
472 finalize_it:
473 	RETiRet;
474 }
475 static rsRetVal
476 strmReadBuf(strm_t *pThis, int *padBytes)
477 {
478 	DEFiRet;
479 	int bRun;
480 	long iLenRead;
481 	size_t actualDataLen;
482 	size_t toRead;
483 	ssize_t bytesLeft;
484 	ISOBJ_TYPE_assert(pThis, strm);
485 	bRun = 1;
486 	while(bRun) {
487 		CHKiRet(strmOpenFile(pThis));
488 		if(pThis-&gt;cryprov == NULL) {
489 			toRead = pThis-&gt;sIOBufSize;
490 		} else {
491 			CHKiRet(pThis-&gt;cryprov-&gt;GetBytesLeftInBlock(pThis-&gt;cryprovFileData, &amp;bytesLeft));
492 			if(bytesLeft == -1 || bytesLeft &gt; (ssize_t) pThis-&gt;sIOBufSize)  {
493 				toRead = pThis-&gt;sIOBufSize;
494 			} else {
495 				toRead = (size_t) bytesLeft;
496 			}
497 		}
498 		if(pThis-&gt;bReopenOnTruncate) {
499 			rsRetVal localRet = checkTruncation(pThis);
500 			if(localRet == RS_RET_FILE_TRUNCATED) {
501 				continue;
502 			}
503 			CHKiRet(localRet);
504 		}
505 		iLenRead = read(pThis-&gt;fd, pThis-&gt;pIOBuf, toRead);
506 		DBGOPRINT((obj_t*) pThis, "file %d read %ld bytes\n", pThis-&gt;fd, iLenRead);
507 		if(iLenRead == 0) {
508 			CHKiRet(strmHandleEOF(pThis));
509 		} else if(iLenRead &lt; 0)
510 			ABORT_FINALIZE(RS_RET_IO_ERROR);
511 		else { 			if(pThis-&gt;cryprov != NULL) {
512 				actualDataLen = iLenRead;
513 				pThis-&gt;cryprov-&gt;Decrypt(pThis-&gt;cryprovFileData, pThis-&gt;pIOBuf, &amp;actualDataLen);
514 				*padBytes = iLenRead - actualDataLen;
515 				iLenRead = actualDataLen;
516 				DBGOPRINT((obj_t*) pThis, "encrypted file %d pad bytes %d, actual "
517 					"data %ld\n", pThis-&gt;fd, *padBytes, iLenRead);
518 			} else {
519 				*padBytes = 0;
520 			}
521 			pThis-&gt;iBufPtrMax = iLenRead;
522 			bRun = 0;			}
523 	}
524 	pThis-&gt;iBufPtr = 0;
525 finalize_it:
526 	RETiRet;
527 }
528 void
529 strmDebugOutBuf(const strm_t *const pThis)
530 {
531 	int strtIdx = pThis-&gt;iBufPtr - 50;
532 	if(strtIdx &lt; 0)
533 		strtIdx = 0;
534 	DBGOPRINT((obj_t*) pThis, "strmRead ungetc %d, index %zd, max %zd, buf '%.*s', CURR: '%.*s'\n",
535 		pThis-&gt;iUngetC, pThis-&gt;iBufPtr, pThis-&gt;iBufPtrMax, (int) pThis-&gt;iBufPtrMax - strtIdx,
536 		pThis-&gt;pIOBuf+strtIdx, (int) (pThis-&gt;iBufPtrMax - pThis-&gt;iBufPtr), pThis-&gt;pIOBuf+pThis-&gt;iBufPtr);
537 }
538 static rsRetVal strmReadChar(strm_t *pThis, uchar *pC)
539 {
540 	int padBytes = 0; 	DEFiRet;
541 	assert(pThis != NULL);
542 	assert(pC != NULL);
543 	if(pThis-&gt;iUngetC != -1) {			*pC = pThis-&gt;iUngetC;
544 		++pThis-&gt;iCurrOffs; 		pThis-&gt;iUngetC = -1;
545 		ABORT_FINALIZE(RS_RET_OK);
546 	}
547 	if(pThis-&gt;iBufPtr &gt;= pThis-&gt;iBufPtrMax) {
548 		CHKiRet(strmReadBuf(pThis, &amp;padBytes));
549 	}
550 	pThis-&gt;iCurrOffs += padBytes;
551 	*pC = pThis-&gt;pIOBuf[pThis-&gt;iBufPtr++];
552 	++pThis-&gt;iCurrOffs; 
553 finalize_it:
554 	RETiRet;
555 }
556 static rsRetVal strmUnreadChar(strm_t *pThis, uchar c)
557 {
558 	assert(pThis != NULL);
559 	assert(pThis-&gt;iUngetC == -1);
560 	pThis-&gt;iUngetC = c;
561 	return RS_RET_OK;
562 }
563 static rsRetVal ATTR_NONNULL(1, 2)
564 strmReadLine(strm_t *const pThis, cstr_t **ppCStr, uint8_t mode, sbool bEscapeLF,
565 	const uchar *const escapeLFString, uint32_t trimLineOverBytes, int64 *const strtOffs)
566 {
567 	uchar c;
568 	uchar finished;
569 	const int escapeLFString_len = (escapeLFString == NULL) ? 4 : strlen((char*) escapeLFString);
570 	DEFiRet;
571 	assert(pThis != NULL);
572 	assert(ppCStr != NULL);
573 	CHKiRet(cstrConstruct(ppCStr));
574 	CHKiRet(strmReadChar(pThis, &amp;c));
575 	if(pThis-&gt;prevLineSegment != NULL) {
576 		cstrFinalize(pThis-&gt;prevLineSegment);
577 		dbgprintf("readLine: have previous line segment: '%s'\n",
578 			rsCStrGetSzStrNoNULL(pThis-&gt;prevLineSegment));
579 		CHKiRet(cstrAppendCStr(*ppCStr, pThis-&gt;prevLineSegment));
580 		cstrDestruct(&amp;pThis-&gt;prevLineSegment);
581 	}
582 	if(mode == 0) {
583 		while(c != '\n') {
584 			CHKiRet(cstrAppendChar(*ppCStr, c));
585 			CHKiRet(strmReadChar(pThis, &amp;c));
586 		}
587 		if (trimLineOverBytes &gt; 0 &amp;&amp; (uint32_t) cstrLen(*ppCStr) &gt; trimLineOverBytes) {
588 			dbgprintf("Truncate long line at %u, mode %d\n", trimLineOverBytes, mode);
589 			rsCStrTruncate(*ppCStr, cstrLen(*ppCStr) - trimLineOverBytes);
590 			cstrAppendChar(*ppCStr, '\n');
591 		}
592 		cstrFinalize(*ppCStr);
593 	} else if(mode == 1) {
594 		finished=0;
595 		while(finished == 0){
596 			if(c != '\n') {
597 				CHKiRet(cstrAppendChar(*ppCStr, c));
598 				CHKiRet(strmReadChar(pThis, &amp;c));
599 				pThis-&gt;bPrevWasNL = 0;
600 			} else {
601 				if ((((*ppCStr)-&gt;iStrLen) &gt; 0) ){
602 					if(pThis-&gt;bPrevWasNL &amp;&amp; escapeLFString_len &gt; 0) {
603 						rsCStrTruncate(*ppCStr, (bEscapeLF) ? escapeLFString_len : 1);
604 						finished=1;
605 					} else {
606 						if(bEscapeLF) {
607 							if(escapeLFString == NULL) {
608 								CHKiRet(rsCStrAppendStrWithLen(*ppCStr,
609 									(uchar*)"#012", sizeof("#012")-1));
610 							} else {
611 								CHKiRet(rsCStrAppendStrWithLen(*ppCStr,
612 									escapeLFString, escapeLFString_len));
613 							}
614 						} else {
615 							CHKiRet(cstrAppendChar(*ppCStr, c));
616 						}
617 						CHKiRet(strmReadChar(pThis, &amp;c));
618 						pThis-&gt;bPrevWasNL = 1;
619 					}
620 				} else {
621 				}
622 			}
623 		}
624 		cstrFinalize(*ppCStr);
625 		pThis-&gt;bPrevWasNL = 0;
626 	} else if(mode == 2) {
627 		finished=0;
628 		while(finished == 0){
629 			if ((*ppCStr)-&gt;iStrLen == 0){
630 				if(c != '\n') {
631 					CHKiRet(cstrAppendChar(*ppCStr, c));
632 					CHKiRet(strmReadChar(pThis, &amp;c));
633 				} else {
634 				}
635 			} else {
636 				if(pThis-&gt;bPrevWasNL) {
637 					if ((c == ' ') || (c == '\t')){
638 						CHKiRet(cstrAppendChar(*ppCStr, c));
639 						CHKiRet(strmReadChar(pThis, &amp;c));
640 						pThis-&gt;bPrevWasNL = 0;
641 					} else {
642 						CHKiRet(strmUnreadChar(pThis, c));
643 						if(bEscapeLF &amp;&amp; escapeLFString_len &gt; 0) {
644 							rsCStrTruncate(*ppCStr, (bEscapeLF) ? escapeLFString_len : 1);
645 						}
646 						finished=1;
647 					}
648 				} else { 					if(c == '\n') {
649 						pThis-&gt;bPrevWasNL = 1;
650 						if(bEscapeLF &amp;&amp; escapeLFString_len &gt; 0) {
651 							if(escapeLFString == NULL) {
652 								CHKiRet(rsCStrAppendStrWithLen(*ppCStr,
653 									(uchar*)"#012", sizeof("#012")-1));
654 							} else {
655 								CHKiRet(rsCStrAppendStrWithLen(*ppCStr,
656 									escapeLFString, escapeLFString_len));
657 							}
658 						} else {
659 							CHKiRet(cstrAppendChar(*ppCStr, c));
660 						}
661 					} else {
662 						CHKiRet(cstrAppendChar(*ppCStr, c));
663 					}
664 					CHKiRet(strmReadChar(pThis, &amp;c));
665 				}
666 			}
667 		}
668 		if (trimLineOverBytes &gt; 0 &amp;&amp; (uint32_t) cstrLen(*ppCStr) &gt; trimLineOverBytes) {
669 			dbgprintf("Truncate long line at %u, mode %d\n", trimLineOverBytes, mode);
670 			rsCStrTruncate(*ppCStr, cstrLen(*ppCStr) - trimLineOverBytes);
671 			cstrAppendChar(*ppCStr, '\n');
672 		}
673 		cstrFinalize(*ppCStr);
674 		pThis-&gt;bPrevWasNL = 0;
675 	}
676 finalize_it:
677 	if(iRet == RS_RET_OK) {
678 		if(strtOffs != NULL) {
679 			*strtOffs = pThis-&gt;strtOffs;
680 		}
681 		pThis-&gt;strtOffs = pThis-&gt;iCurrOffs; 	} else {
682 		if(*ppCStr != NULL) {
683 			if(cstrLen(*ppCStr) &gt; 0) {
684 				if(rsCStrConstructFromCStr(&amp;pThis-&gt;prevLineSegment, *ppCStr) != RS_RET_OK) {
685 					 pThis-&gt;prevLineSegment = NULL;
686 				}
687 			}
688 			cstrDestruct(ppCStr);
689 		}
690 	}
691 	RETiRet;
692 }
693 int
694 strmReadMultiLine_isTimedOut(const strm_t *const __restrict__ pThis)
695 {
696 	DBGPRINTF("strmReadMultiline_isTimedOut: prevMsgSeg %p, readTimeout %d, "
697 		"lastRead %lld\n", pThis-&gt;prevMsgSegment, pThis-&gt;readTimeout,
698 		(long long) pThis-&gt;lastRead);
699 	return(   (pThis-&gt;readTimeout)
700 	       &amp;&amp; (pThis-&gt;prevMsgSegment != NULL)
701 	       &amp;&amp; (getTime(NULL) &gt; pThis-&gt;lastRead + pThis-&gt;readTimeout) );
702 }
703 rsRetVal ATTR_NONNULL(1,2)
704 strmReadMultiLine(strm_t *pThis, cstr_t **ppCStr, regex_t *start_preg, regex_t *end_preg, const sbool bEscapeLF,
705 	const uchar *const escapeLFString, const sbool discardTruncatedMsg, const sbool msgDiscardingError,
706 	int64 *const strtOffs)
707 {
708 	uchar c;
709 	uchar finished = 0;
710 	cstr_t *thisLine = NULL;
711 	rsRetVal readCharRet;
712 	const time_t tCurr = pThis-&gt;readTimeout ? getTime(NULL) : 0;
713 	int maxMsgSize = glblGetMaxLine(runConf);
714 	DEFiRet;
715 	do {
716 		CHKiRet(strmReadChar(pThis, &amp;c)); 		pThis-&gt;lastRead = tCurr;
717 		CHKiRet(cstrConstruct(&amp;thisLine));
718 		if(pThis-&gt;prevLineSegment != NULL) {
719 			CHKiRet(cstrAppendCStr(thisLine, pThis-&gt;prevLineSegment));
720 			cstrDestruct(&amp;pThis-&gt;prevLineSegment);
721 		}
722 		while(c != '\n') {
723 			CHKiRet(cstrAppendChar(thisLine, c));
724 			readCharRet = strmReadChar(pThis, &amp;c);
725 			if(readCharRet == RS_RET_EOF) {				CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevLineSegment, thisLine));
726 			}
727 			CHKiRet(readCharRet);
728 		}
729 		cstrFinalize(thisLine);
730 		const int isStartMatch = start_preg ?
731 				!regexec(start_preg, (char*)rsCStrGetSzStrNoNULL(thisLine), 0, NULL, 0) :
732 				0;
733 		const int isEndMatch = end_preg ?
734 				!regexec(end_preg, (char*)rsCStrGetSzStrNoNULL(thisLine), 0, NULL, 0) :
735 				0;
736 		if(isStartMatch) {
737 			if(pThis-&gt;ignoringMsg == 0) {
738 				if(pThis-&gt;prevMsgSegment != NULL) {
739 					finished = 1;
740 					*ppCStr = pThis-&gt;prevMsgSegment;
741 				}
742 			}
743 			CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevMsgSegment, thisLine));
744 			pThis-&gt;ignoringMsg = 0;
745 		} else {
746 			if(pThis-&gt;ignoringMsg == 0) {
747 				if(pThis-&gt;prevMsgSegment == NULL) {
748 					CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevMsgSegment, thisLine));
749 				} else {
750 					if(bEscapeLF) {
751 						if(escapeLFString == NULL) {
752 							rsCStrAppendStrWithLen(pThis-&gt;prevMsgSegment, (uchar*)"\\n", 2);
753 						} else {
754 							rsCStrAppendStr(pThis-&gt;prevMsgSegment, escapeLFString);
755 						}
756 					} else {
757 						cstrAppendChar(pThis-&gt;prevMsgSegment, '\n');
758 					}
759 					int currLineLen = cstrLen(thisLine);
760 					if(currLineLen &gt; 0) {
761 						int len;
762 						if((len = cstrLen(pThis-&gt;prevMsgSegment) + currLineLen) &lt;
763 						maxMsgSize) {
764 							CHKiRet(cstrAppendCStr(pThis-&gt;prevMsgSegment, thisLine));
765 						} else {
766 							if (cstrLen(pThis-&gt;prevMsgSegment) &gt; maxMsgSize) {
767 								len = 0;
768 							} else {
769 								len = currLineLen-(len-maxMsgSize);
770 								for(int z=0; z&lt;len; z++) {
771 									cstrAppendChar(pThis-&gt;prevMsgSegment,
772 										thisLine-&gt;pBuf[z]);
773 								}
774 							}
775 							finished = 1;
776 							*ppCStr = pThis-&gt;prevMsgSegment;
777 							CHKiRet(rsCStrConstructFromszStr(&amp;pThis-&gt;prevMsgSegment,
778 								thisLine-&gt;pBuf+len));
779 							if(discardTruncatedMsg == 1) {
780 								pThis-&gt;ignoringMsg = 1;
781 							}
782 							if(msgDiscardingError == 1) {
783 								if(discardTruncatedMsg == 1) {
784 									LogError(0, RS_RET_ERR,
785 									"imfile error: message received is "
786 									"larger than max msg size; "
787 									"rest of message will not be "
788 									"processed");
789 								} else {
790 									LogError(0, RS_RET_ERR,
791 									"imfile error: message received is "
792 									"larger than max msg size; message "
793 									"will be split and processed as "
794 									"another message");
795 								}
796 							}
797 						}
798 					}
799 				}
800 			}
801 		}
802 		if(isEndMatch) {
803 			if(pThis-&gt;ignoringMsg == 0) {
804 				if(pThis-&gt;prevMsgSegment != NULL) {
805 					finished = 1;
806 					*ppCStr = pThis-&gt;prevMsgSegment;
807 					pThis-&gt;prevMsgSegment= NULL;
808 				}
809 			}
810 			pThis-&gt;ignoringMsg = 0;
811 		}
812 		cstrDestruct(&amp;thisLine);
813 	} while(finished == 0);
814 finalize_it:
815 	*strtOffs = pThis-&gt;strtOffs;
816 	if(thisLine != NULL) {
817 		cstrDestruct(&amp;thisLine);
818 	}
819 	if(iRet == RS_RET_OK) {
820 		pThis-&gt;strtOffs = pThis-&gt;iCurrOffs; 		cstrFinalize(*ppCStr);
821 	} else {
822 		if(   pThis-&gt;readTimeout
823 		   &amp;&amp; (pThis-&gt;prevMsgSegment != NULL)
824 		   &amp;&amp; (tCurr &gt; pThis-&gt;lastRead + pThis-&gt;readTimeout)) {
825 			if(rsCStrConstructFromCStr(ppCStr, pThis-&gt;prevMsgSegment) == RS_RET_OK) {
826 				cstrFinalize(*ppCStr);
827 				cstrDestruct(&amp;pThis-&gt;prevMsgSegment);
828 				pThis-&gt;lastRead = tCurr;
829 				pThis-&gt;strtOffs = pThis-&gt;iCurrOffs; 				dbgprintf("stream: generated msg based on timeout: %s\n",
830 					cstrGetSzStrNoNULL(*ppCStr));
831 				iRet = RS_RET_OK;
832 			}
833 		}
834 	}
835 	RETiRet;
836 }
837 BEGINobjConstruct(strm) 	pThis-&gt;iCurrFNum = 1;
838 	pThis-&gt;fd = -1;
839 	pThis-&gt;fdDir = -1;
840 	pThis-&gt;iUngetC = -1;
841 	pThis-&gt;bVeryReliableZip = 0;
842 	pThis-&gt;sType = STREAMTYPE_FILE_SINGLE;
843 	pThis-&gt;sIOBufSize = glblGetIOBufSize();
844 	pThis-&gt;tOpenMode = 0600;
845 	pThis-&gt;pszSizeLimitCmd = NULL;
846 	pThis-&gt;prevLineSegment = NULL;
847 	pThis-&gt;prevMsgSegment = NULL;
848 	pThis-&gt;strtOffs = 0;
849 	pThis-&gt;ignoringMsg = 0;
850 	pThis-&gt;bPrevWasNL = 0;
851 	pThis-&gt;fileNotFoundError = 1;
852 	pThis-&gt;noRepeatedErrorOutput = 0;
853 	pThis-&gt;lastRead = getTime(NULL);
854 ENDobjConstruct(strm)
855 static rsRetVal strmConstructFinalize(strm_t *pThis)
856 {
857 	pthread_mutexattr_t mutAttr;
858 	rsRetVal localRet;
859 	int i;
860 	DEFiRet;
861 	assert(pThis != NULL);
862 	pThis-&gt;iBufPtrMax = 0; 	if(pThis-&gt;iZipLevel) { 		localRet = objUse(zlibw, LM_ZLIBW_FILENAME);
863 		if(localRet != RS_RET_OK) {
864 			pThis-&gt;iZipLevel = 0;
865 			DBGPRINTF("stream was requested with zip mode, but zlibw module unavailable (%d) - using "
866 				  "without zip\n", localRet);
867 		} else {
868 			CHKmalloc(pThis-&gt;pZipBuf = (Bytef*) malloc(pThis-&gt;sIOBufSize + 128));
869 		}
870 	}
871 	if(pThis-&gt;bSync &amp;&amp; !pThis-&gt;bIsTTY &amp;&amp; pThis-&gt;pszDir != NULL) {
872 		pThis-&gt;fdDir = open((char*)pThis-&gt;pszDir, O_RDONLY | O_CLOEXEC | O_NOCTTY);
873 		if(pThis-&gt;fdDir == -1) {
874 			char errStr[1024];
875 			int err = errno;
876 			rs_strerror_r(err, errStr, sizeof(errStr));
877 			DBGPRINTF("error %d opening directory file for fsync() use - fsync for directory "
878 				"disabled: %s\n", errno, errStr);
879 		}
880 	}
881 	if(pThis-&gt;iFlushInterval != 0) {
882 		pThis-&gt;bAsyncWrite = 1;
883 	}
884 	DBGPRINTF("file stream %s params: flush interval %d, async write %d\n",
885 		  getFileDebugName(pThis),
886 		  pThis-&gt;iFlushInterval, pThis-&gt;bAsyncWrite);
887 	if(pThis-&gt;bAsyncWrite) {
888 		pthread_mutexattr_init(&amp;mutAttr);
889 		pthread_mutexattr_settype(&amp;mutAttr, PTHREAD_MUTEX_RECURSIVE);
890 		pthread_mutex_init(&amp;pThis-&gt;mut, &amp;mutAttr);
891 		pthread_cond_init(&amp;pThis-&gt;notFull, 0);
892 		pthread_cond_init(&amp;pThis-&gt;notEmpty, 0);
893 		pthread_cond_init(&amp;pThis-&gt;isEmpty, 0);
894 		pThis-&gt;iCnt = pThis-&gt;iEnq = pThis-&gt;iDeq = 0;
895 		for(i = 0 ; i &lt; STREAM_ASYNC_NUMBUFS ; ++i) {
896 			CHKmalloc(pThis-&gt;asyncBuf[i].pBuf = (uchar*) malloc(pThis-&gt;sIOBufSize));
897 		}
898 		pThis-&gt;pIOBuf = pThis-&gt;asyncBuf[0].pBuf;
899 		pThis-&gt;bStopWriter = 0;
900 		if(pthread_create(&amp;pThis-&gt;writerThreadID,
901 			    	  &amp;default_thread_attr,
902 				  asyncWriterThread, pThis) != 0)
903 			DBGPRINTF("ERROR: stream %p cold not create writer thread\n", pThis);
904 	} else {
905 		CHKmalloc(pThis-&gt;pIOBuf = (uchar*) malloc(pThis-&gt;sIOBufSize));
906 		CHKmalloc(pThis-&gt;pIOBuf_truncation = (char*) malloc(pThis-&gt;sIOBufSize));
907 	}
908 finalize_it:
909 	RETiRet;
910 }
911 BEGINobjDestruct(strm) 	int i;
912 CODESTARTobjDestruct(strm)
913 	if(pThis-&gt;bAsyncWrite)
914 		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
915 	strmCloseFile(pThis);
916 	if(pThis-&gt;bAsyncWrite) {
917 		pthread_mutex_destroy(&amp;pThis-&gt;mut);
918 		pthread_cond_destroy(&amp;pThis-&gt;notFull);
919 		pthread_cond_destroy(&amp;pThis-&gt;notEmpty);
920 		pthread_cond_destroy(&amp;pThis-&gt;isEmpty);
921 		for(i = 0 ; i &lt; STREAM_ASYNC_NUMBUFS ; ++i) {
922 			free(pThis-&gt;asyncBuf[i].pBuf);
923 		}
924 	} else {
925 		free(pThis-&gt;pIOBuf);
926 		free(pThis-&gt;pIOBuf_truncation);
927 	}
928 	if(pThis-&gt;prevLineSegment)
929 		cstrDestruct(&amp;pThis-&gt;prevLineSegment);
930 	if(pThis-&gt;prevMsgSegment)
931 		cstrDestruct(&amp;pThis-&gt;prevMsgSegment);
932 	free(pThis-&gt;pszDir);
933 	free(pThis-&gt;pZipBuf);
934 	free(pThis-&gt;pszCurrFName);
935 	free(pThis-&gt;pszFName);
936 	free(pThis-&gt;pszSizeLimitCmd);
937 	pThis-&gt;bStopWriter = 2; ENDobjDestruct(strm)
938 static rsRetVal strmCheckNextOutputFile(strm_t *pThis)
939 {
940 	DEFiRet;
941 	if(pThis-&gt;fd == -1 || pThis-&gt;sType != STREAMTYPE_FILE_CIRCULAR)
942 		FINALIZE;
943 	strmWaitAsyncWriterDone(pThis);
944 	if(pThis-&gt;iCurrOffs &gt;= pThis-&gt;iMaxFileSize) {
945 		DBGOPRINT((obj_t*) pThis, "max file size %ld reached for %d, now %ld - starting new file\n",
946 			  (long) pThis-&gt;iMaxFileSize, pThis-&gt;fd, (long) pThis-&gt;iCurrOffs);
947 		CHKiRet(strmNextFile(pThis));
948 	}
949 finalize_it:
950 	RETiRet;
951 }
952 #ifdef linux
953 #	define ERR_TTYHUP EIO
954 #else
955 #	define ERR_TTYHUP EBADF
956 #endif
957 static rsRetVal
958 tryTTYRecover(strm_t *pThis, int err)
959 {
960 	DEFiRet;
961 	ISOBJ_TYPE_assert(pThis, strm);
962 #ifndef __FreeBSD__
963 	if(err == ERR_TTYHUP) {
964 #else
965 	if(err == ERR_TTYHUP || err == ENXIO || err == EIO) {
966 #endif 		close(pThis-&gt;fd);
967 		pThis-&gt;fd = -1;
968 		CHKiRet(doPhysOpen(pThis));
969 	}
970 finalize_it:
971 	RETiRet;
972 }
973 #undef ER_TTYHUP
974 static rsRetVal ATTR_NONNULL(1,2,3)
975 doWriteCall(strm_t *pThis, uchar *pBuf, size_t *pLenBuf)
976 {
977 	ssize_t lenBuf;
978 	ssize_t iTotalWritten;
979 	ssize_t iWritten;
980 	char *pWriteBuf;
981 	DEFiRet;
982 	ISOBJ_TYPE_assert(pThis, strm);
983 #ifdef __FreeBSD__
984 	sbool crnlNow = 0;
985 #endif 
986 	lenBuf = *pLenBuf;
987 	pWriteBuf = (char*) pBuf;
988 	iTotalWritten = 0;
989 	do {
990 		#ifdef __FreeBSD__
991 		if (pThis-&gt;bIsTTY &amp;&amp; !pThis-&gt;iZipLevel &amp;&amp; !pThis-&gt;cryprov) {
992 			char *pNl = NULL;
993 			if (crnlNow == 0) pNl = strchr(pWriteBuf, '\n');
994 			else crnlNow = 0;
995 			if (pNl == pWriteBuf) {
996 				iWritten = write(pThis-&gt;fd, "\r", 1);
997 				if (iWritten &gt; 0) {
998 					crnlNow = 1;
999 					iWritten = 0;
1000 				}
1001 			} else iWritten = write(pThis-&gt;fd, pWriteBuf, pNl ? pNl - pWriteBuf : lenBuf);
1002 		} else
1003 		#endif 		iWritten = write(pThis-&gt;fd, pWriteBuf, lenBuf);
1004 		if(iWritten &lt; 0) {
1005 			const int err = errno;
1006 			iWritten = 0; 			if(err == EBADF) {
1007 				LogError(err, RS_RET_IO_ERROR, "file %s: fd %d no longer valid, recovery by "
1008 					"reopen; if you see this, consider reporting at "
1009 					"https://github.com/rsyslog/rsyslog/issues/3404 "
1010 					"so that we know when it happens. Include output of uname -a. "
1011 					"OS error reason", pThis-&gt;pszCurrFName, pThis-&gt;fd);
1012 				pThis-&gt;fd = -1;
1013 				CHKiRet(doPhysOpen(pThis));
1014 			} else {
1015 				if(err != EINTR) {
1016 					LogError(err, RS_RET_IO_ERROR, "file '%s'[%d] write error - see "
1017 						"https://www.rsyslog.com/solving-rsyslog-write-errors/ for help "
1018 						"OS error", pThis-&gt;pszCurrFName, pThis-&gt;fd);
1019 				}
1020 				if(err == EINTR) {
1021 				} else if( !pThis-&gt;bIsTTY &amp;&amp; ( err == ENOTCONN || err == EIO )) {
1022 					close(pThis-&gt;fd);
1023 					pThis-&gt;fd = -1;
1024 					CHKiRet(doPhysOpen(pThis));
1025 				} else {
1026 					if(pThis-&gt;bIsTTY) {
1027 						CHKiRet(tryTTYRecover(pThis, err));
1028 					} else {
1029 						ABORT_FINALIZE(RS_RET_IO_ERROR);
1030 					}
1031 				}
1032 			}
1033 	 	}
1034 		iTotalWritten += iWritten;
1035 		lenBuf -= iWritten;
1036 		pWriteBuf += iWritten;
1037 	} while(lenBuf &gt; 0);	
1038 	DBGOPRINT((obj_t*) pThis, "file %d write wrote %d bytes\n", pThis-&gt;fd, (int) iWritten);
1039 finalize_it:
1040 	*pLenBuf = iTotalWritten;
1041 	RETiRet;
1042 }
1043 static rsRetVal
1044 doWriteInternal(strm_t *pThis, uchar *pBuf, const size_t lenBuf, const int bFlush)
1045 {
1046 	DEFiRet;
1047 	DBGOPRINT((obj_t*) pThis, "file %d(%s) doWriteInternal: bFlush %d\n",
1048 		pThis-&gt;fd, getFileDebugName(pThis), bFlush);
1049 	if(pThis-&gt;iZipLevel) {
1050 		CHKiRet(doZipWrite(pThis, pBuf, lenBuf, bFlush));
1051 	} else {
1052 		CHKiRet(strmPhysWrite(pThis, pBuf, lenBuf));
1053 	}
1054 finalize_it:
1055 	RETiRet;
1056 }
1057 static rsRetVal
1058 doAsyncWriteInternal(strm_t *pThis, size_t lenBuf, const int bFlushZip)
1059 {
1060 	DEFiRet;
1061 	ISOBJ_TYPE_assert(pThis, strm);
1062 	DBGOPRINT((obj_t*) pThis, "file %d(%s) doAsyncWriteInternal at begin: "
1063 		"iCnt %d, iEnq %d, bFlushZip %d\n",
1064 		pThis-&gt;fd, getFileDebugName(pThis),
1065 		pThis-&gt;iCnt, pThis-&gt;iEnq, bFlushZip);
1066 	while(pThis-&gt;iCnt &gt;= STREAM_ASYNC_NUMBUFS - 1)
1067 		d_pthread_cond_wait(&amp;pThis-&gt;notFull, &amp;pThis-&gt;mut);
1068 	pThis-&gt;asyncBuf[pThis-&gt;iEnq % STREAM_ASYNC_NUMBUFS].lenBuf = lenBuf;
1069 	pThis-&gt;pIOBuf = pThis-&gt;asyncBuf[++pThis-&gt;iEnq % STREAM_ASYNC_NUMBUFS].pBuf;
1070 	if(!pThis-&gt;bFlushNow) 		pThis-&gt;bFlushNow = bFlushZip;
1071 	pThis-&gt;bDoTimedWait = 0; 	if(++pThis-&gt;iCnt == 1) {
1072 		pthread_cond_signal(&amp;pThis-&gt;notEmpty);
1073 		DBGOPRINT((obj_t*) pThis, "doAsyncWriteInternal signaled notEmpty\n");
1074 	}
1075 	DBGOPRINT((obj_t*) pThis, "file %d(%s) doAsyncWriteInternal at exit: "
1076 		"iCnt %d, iEnq %d, bFlushZip %d\n",
1077 		pThis-&gt;fd, getFileDebugName(pThis),
1078 		pThis-&gt;iCnt, pThis-&gt;iEnq, bFlushZip);
1079 	RETiRet;
1080 }
1081 static rsRetVal
1082 strmSchedWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf, const int bFlushZip)
1083 {
1084 	DEFiRet;
1085 	assert(pThis != NULL);
1086 	pThis-&gt;iBufPtr = 0; 	if(pThis-&gt;bAsyncWrite) {
1087 		CHKiRet(doAsyncWriteInternal(pThis, lenBuf, bFlushZip));
1088 	} else {
1089 		CHKiRet(doWriteInternal(pThis, pBuf, lenBuf, bFlushZip));
1090 	}
1091 finalize_it:
1092 	RETiRet;
1093 }
1094 static void*
1095 asyncWriterThread(void *pPtr)
1096 {
1097 	int iDeq;
1098 	struct timespec t;
1099 	sbool bTimedOut = 0;
1100 	strm_t *pThis = (strm_t*) pPtr;
1101 	int err;
1102 	uchar thrdName[256] = "rs:";
1103 	ISOBJ_TYPE_assert(pThis, strm);
1104 	ustrncpy(thrdName+3, pThis-&gt;pszFName, sizeof(thrdName)-4);
1105 	dbgOutputTID((char*)thrdName);
1106 #	if defined(HAVE_PRCTL) &amp;&amp; defined(PR_SET_NAME)
1107 	if(prctl(PR_SET_NAME, (char*)thrdName, 0, 0, 0) != 0) {
1108 		DBGPRINTF("prctl failed, not setting thread name for '%s'\n", "stream writer");
1109 	}
1110 #	endif
1111 	d_pthread_mutex_lock(&amp;pThis-&gt;mut);
1112 	while(1) { 		while(pThis-&gt;iCnt == 0) {
1113 			DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread new iteration, "
1114 				  "iCnt %d, bTimedOut %d, iFlushInterval %d\n", pThis-&gt;fd,
1115 				  getFileDebugName(pThis),
1116 				  pThis-&gt;iCnt, bTimedOut, pThis-&gt;iFlushInterval);
1117 			if(pThis-&gt;bStopWriter) {
1118 				pthread_cond_broadcast(&amp;pThis-&gt;isEmpty);
1119 				d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
1120 				goto finalize_it; 			}
1121 			if(bTimedOut &amp;&amp; pThis-&gt;iBufPtr &gt; 0) {
1122 				strmFlushInternal(pThis, 1);
1123 				bTimedOut = 0;
1124 				continue;
1125 			}
1126 			bTimedOut = 0;
1127 			if(pThis-&gt;bDoTimedWait) {
1128 				timeoutComp(&amp;t, pThis-&gt;iFlushInterval * 1000); 				if((err = pthread_cond_timedwait(&amp;pThis-&gt;notEmpty, &amp;pThis-&gt;mut, &amp;t)) != 0) {
1129 					DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread timed out\n",
1130 						  pThis-&gt;fd, getFileDebugName(pThis));
1131 					bTimedOut = 1; 					if(err != ETIMEDOUT) {
1132 						char errStr[1024];
1133 						rs_strerror_r(err, errStr, sizeof(errStr));
1134 						DBGPRINTF("stream async writer timeout with error (%d): %s - "
1135 							"ignoring\n", err, errStr);
1136 					}
1137 				}
1138 			} else {
1139 				d_pthread_cond_wait(&amp;pThis-&gt;notEmpty, &amp;pThis-&gt;mut);
1140 			}
1141 		}
1142 		DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread awoken, "
1143 			  "iCnt %d, bTimedOut %d\n", pThis-&gt;fd, getFileDebugName(pThis),
1144 			  pThis-&gt;iCnt, bTimedOut);
1145 		bTimedOut = 0; 
1146 		iDeq = pThis-&gt;iDeq++ % STREAM_ASYNC_NUMBUFS;
1147 		const int bFlush = (pThis-&gt;bFlushNow || bTimedOut) ? 1 : 0;
1148 		pThis-&gt;bFlushNow = 0;
1149 		d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
1150 		doWriteInternal(pThis, pThis-&gt;asyncBuf[iDeq].pBuf, pThis-&gt;asyncBuf[iDeq].lenBuf, bFlush);
1151 		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
1152 		--pThis-&gt;iCnt;
1153 		if(pThis-&gt;iCnt &lt; STREAM_ASYNC_NUMBUFS) {
1154 			pthread_cond_signal(&amp;pThis-&gt;notFull);
1155 			if(pThis-&gt;iCnt == 0)
1156 				pthread_cond_broadcast(&amp;pThis-&gt;isEmpty);
1157 		}
1158 	}
1159 finalize_it:
1160 	DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread terminated\n",
1161 		pThis-&gt;fd, getFileDebugName(pThis));
1162 	return NULL; }
1163 #undef SYNCCALL
1164 #if defined(HAVE_FDATASYNC) &amp;&amp; !defined(__APPLE__)
1165 #	define SYNCCALL(x) fdatasync(x)
1166 #else
1167 #	define SYNCCALL(x) fsync(x)
1168 #endif
1169 static rsRetVal
1170 syncFile(strm_t *pThis)
1171 {
1172 	int ret;
1173 	DEFiRet;
1174 	if(pThis-&gt;bIsTTY)
1175 		FINALIZE; 
1176 	DBGPRINTF("syncing file %d\n", pThis-&gt;fd);
1177 	ret = SYNCCALL(pThis-&gt;fd);
1178 	if(ret != 0) {
1179 		char errStr[1024];
1180 		int err = errno;
1181 		rs_strerror_r(err, errStr, sizeof(errStr));
1182 		DBGPRINTF("sync failed for file %d with error (%d): %s - ignoring\n",
1183 			   pThis-&gt;fd, err, errStr);
1184 	}
1185 	if(pThis-&gt;fdDir != -1) {
1186 		if(fsync(pThis-&gt;fdDir) != 0)
1187 			DBGPRINTF("stream/syncFile: fsync returned error, ignoring\n");
1188 	}
1189 finalize_it:
1190 	RETiRet;
1191 }
1192 #undef SYNCCALL
1193 static rsRetVal
1194 strmPhysWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf)
1195 {
1196 	size_t iWritten;
1197 	DEFiRet;
1198 	ISOBJ_TYPE_assert(pThis, strm);
1199 	DBGPRINTF("strmPhysWrite, stream %p, len %u\n", pThis, (unsigned)lenBuf);
1200 	if(pThis-&gt;fd == -1)
1201 		CHKiRet(strmOpenFile(pThis));
1202 	if(pThis-&gt;cryprov != NULL) {
1203 		pThis-&gt;cryprov-&gt;Encrypt(pThis-&gt;cryprovFileData, pBuf, &amp;lenBuf);
1204 	}
1205 	iWritten = lenBuf;
1206 	CHKiRet(doWriteCall(pThis, pBuf, &amp;iWritten));
1207 	pThis-&gt;iCurrOffs += iWritten;
1208 	if(pThis-&gt;pUsrWCntr != NULL)
1209 		*pThis-&gt;pUsrWCntr += iWritten;
1210 	if(pThis-&gt;bSync) {
1211 		CHKiRet(syncFile(pThis));
1212 	}
1213 	if(pThis-&gt;sType == STREAMTYPE_FILE_CIRCULAR) {
1214 		CHKiRet(strmCheckNextOutputFile(pThis));
1215 	}
1216 finalize_it:
1217 	RETiRet;
1218 }
1219 static rsRetVal
1220 doZipWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf, const int bFlush)
1221 {
1222 	int zRet;		DEFiRet;
1223 	unsigned outavail = 0;
1224 	assert(pThis != NULL);
1225 	assert(pBuf != NULL);
1226 	if(!pThis-&gt;bzInitDone) {
1227 		pThis-&gt;zstrm.zalloc = Z_NULL;
1228 		pThis-&gt;zstrm.zfree = Z_NULL;
1229 		pThis-&gt;zstrm.opaque = Z_NULL;
1230 		zRet = zlibw.DeflateInit2(&amp;pThis-&gt;zstrm, pThis-&gt;iZipLevel, Z_DEFLATED, 31, 9, Z_DEFAULT_STRATEGY);
1231 		if(zRet != Z_OK) {
1232 			LogError(0, RS_RET_ZLIB_ERR, "error %d returned from zlib/deflateInit2()", zRet);
1233 			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
1234 		}
1235 		pThis-&gt;bzInitDone = RSTRUE;
1236 	}
1237 	pThis-&gt;zstrm.next_in = (Bytef*) pBuf;
1238 	pThis-&gt;zstrm.avail_in = lenBuf;
1239 	do {
1240 		DBGPRINTF("in deflate() loop, avail_in %d, total_in %ld, bFlush %d\n",
1241 			pThis-&gt;zstrm.avail_in, pThis-&gt;zstrm.total_in, bFlush);
1242 		pThis-&gt;zstrm.avail_out = pThis-&gt;sIOBufSize;
1243 		pThis-&gt;zstrm.next_out = pThis-&gt;pZipBuf;
1244 		zRet = zlibw.Deflate(&amp;pThis-&gt;zstrm, bFlush ? Z_SYNC_FLUSH : Z_NO_FLUSH);    		DBGPRINTF("after deflate, ret %d, avail_out %d, to write %d\n",
1245 			zRet, pThis-&gt;zstrm.avail_out, outavail);
1246 		if(zRet != Z_OK) {
1247 			LogError(0, RS_RET_ZLIB_ERR, "error %d returned from zlib/Deflate()", zRet);
1248 			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
1249 		}
1250 		outavail = pThis-&gt;sIOBufSize - pThis-&gt;zstrm.avail_out;
1251 		if(outavail != 0) {
1252 			CHKiRet(strmPhysWrite(pThis, (uchar*)pThis-&gt;pZipBuf, outavail));
1253 		}
1254 	} while (pThis-&gt;zstrm.avail_out == 0);
1255 finalize_it:
1256 	if(pThis-&gt;bzInitDone &amp;&amp; pThis-&gt;bVeryReliableZip) {
1257 		doZipFinish(pThis);
1258 	}
1259 	RETiRet;
1260 }
1261 static rsRetVal
1262 doZipFinish(strm_t *pThis)
1263 {
1264 	int zRet;		DEFiRet;
1265 	unsigned outavail;
1266 	assert(pThis != NULL);
1267 	if(!pThis-&gt;bzInitDone)
1268 		goto done;
1269 	pThis-&gt;zstrm.avail_in = 0;
1270 	do {
1271 		DBGPRINTF("in deflate() loop, avail_in %d, total_in %ld\n", pThis-&gt;zstrm.avail_in,
1272 			pThis-&gt;zstrm.total_in);
1273 		pThis-&gt;zstrm.avail_out = pThis-&gt;sIOBufSize;
1274 		pThis-&gt;zstrm.next_out = pThis-&gt;pZipBuf;
1275 		zRet = zlibw.Deflate(&amp;pThis-&gt;zstrm, Z_FINISH);    		DBGPRINTF("after deflate, ret %d, avail_out %d\n", zRet, pThis-&gt;zstrm.avail_out);
1276 		outavail = pThis-&gt;sIOBufSize - pThis-&gt;zstrm.avail_out;
1277 		if(outavail != 0) {
1278 			CHKiRet(strmPhysWrite(pThis, (uchar*)pThis-&gt;pZipBuf, outavail));
1279 		}
1280 	} while (pThis-&gt;zstrm.avail_out == 0);
1281 finalize_it:
1282 	zRet = zlibw.DeflateEnd(&amp;pThis-&gt;zstrm);
1283 	if(zRet != Z_OK) {
1284 		LogError(0, RS_RET_ZLIB_ERR, "error %d returned from zlib/deflateEnd()", zRet);
1285 	}
1286 	pThis-&gt;bzInitDone = 0;
1287 done:	RETiRet;
1288 }
1289 static rsRetVal
1290 strmFlushInternal(strm_t *pThis, int bFlushZip)
1291 {
1292 	DEFiRet;
1293 	assert(pThis != NULL);
1294 	DBGOPRINT((obj_t*) pThis, "strmFlushinternal: file %d(%s) flush, buflen %ld%s\n", pThis-&gt;fd,
1295 		  getFileDebugName(pThis),
1296 		  (long) pThis-&gt;iBufPtr, (pThis-&gt;iBufPtr == 0) ? " (no need to flush)" : "");
1297 	if(pThis-&gt;tOperationsMode != STREAMMODE_READ &amp;&amp; pThis-&gt;iBufPtr &gt; 0) {
1298 		iRet = strmSchedWrite(pThis, pThis-&gt;pIOBuf, pThis-&gt;iBufPtr, bFlushZip);
1299 	}
1300 	RETiRet;
1301 }
1302 static rsRetVal
1303 strmFlush(strm_t *pThis)
1304 {
1305 	DEFiRet;
1306 	assert(pThis != NULL);
1307 	DBGOPRINT((obj_t*) pThis, "file %d strmFlush\n", pThis-&gt;fd);
1308 	if(pThis-&gt;bAsyncWrite)
1309 		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
1310 	CHKiRet(strmFlushInternal(pThis, 1));
1311 finalize_it:
1312 	if(pThis-&gt;bAsyncWrite)
1313 		d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
1314 	RETiRet;
1315 }
1316 static rsRetVal ATTR_NONNULL()
1317 strmSeek(strm_t *pThis, const off64_t offs)
1318 {
1319 	DEFiRet;
1320 	ISOBJ_TYPE_assert(pThis, strm);
1321 	if(pThis-&gt;fd == -1) {
1322 		CHKiRet(strmOpenFile(pThis));
1323 	} else {
1324 		CHKiRet(strmFlushInternal(pThis, 0));
1325 	}
1326 	DBGOPRINT((obj_t*) pThis, "file %d seek, pos %llu\n", pThis-&gt;fd, (long long unsigned) offs);
1327 	const off64_t i = lseek64(pThis-&gt;fd, offs, SEEK_SET);
1328 	if(i != offs) {
1329 		LogError(errno, RS_RET_IO_ERROR, "file %s: unexpected error seeking to "
1330 			"offset %lld (ret %lld) - further malfunctions may happen",
1331 			pThis-&gt;pszCurrFName, (long long) i, (long long) offs);
1332 		ABORT_FINALIZE(RS_RET_IO_ERROR);
1333 	}
1334 	pThis-&gt;strtOffs = pThis-&gt;iCurrOffs = offs; 	pThis-&gt;iBufPtr = 0; 
1335 finalize_it:
1336 	RETiRet;
1337 }
1338 rsRetVal
1339 strmMultiFileSeek(strm_t *pThis, unsigned int FNum, off64_t offs, off64_t *bytesDel)
1340 {
1341 	struct stat statBuf;
1342 	int skipped_files;
1343 	DEFiRet;
1344 	ISOBJ_TYPE_assert(pThis, strm);
1345 	if(FNum == 0 &amp;&amp; offs == 0) { 		*bytesDel = 0;
1346 		FINALIZE;
1347 	}
1348 	skipped_files = FNum - pThis-&gt;iCurrFNum;
1349 	*bytesDel = 0;
1350 	while(skipped_files &gt; 0) {
1351 		CHKiRet(genFileName(&amp;pThis-&gt;pszCurrFName, pThis-&gt;pszDir, pThis-&gt;lenDir,
1352 				    pThis-&gt;pszFName, pThis-&gt;lenFName, pThis-&gt;iCurrFNum,
1353 				    pThis-&gt;iFileNumDigits));
1354 		dbgprintf("rger: processing file %s\n", pThis-&gt;pszCurrFName);
1355 		if(stat((char*)pThis-&gt;pszCurrFName, &amp;statBuf) != 0) {
1356 			LogError(errno, RS_RET_IO_ERROR, "unexpected error doing a stat() "
1357 				"on file %s - further malfunctions may happen",
1358 				pThis-&gt;pszCurrFName);
1359 		}
1360 		*bytesDel += statBuf.st_size;
1361 		DBGPRINTF("strmMultiFileSeek: detected new filenum, was %u, new %u, "
1362 			  "deleting '%s' (%lld bytes)\n", pThis-&gt;iCurrFNum, FNum,
1363 			  pThis-&gt;pszCurrFName, (long long) statBuf.st_size);
1364 		unlink((char*)pThis-&gt;pszCurrFName);
1365 		if(pThis-&gt;cryprov != NULL)
1366 			pThis-&gt;cryprov-&gt;DeleteStateFiles(pThis-&gt;pszCurrFName);
1367 		free(pThis-&gt;pszCurrFName);
1368 		pThis-&gt;pszCurrFName = NULL;
1369 		pThis-&gt;iCurrFNum++;
1370 		--skipped_files;
1371 	}
1372 	DBGOPRINT((obj_t*) pThis, "strmMultiFileSeek: deleted %lld bytes in this run\n",
1373 		(long long) *bytesDel);
1374 	pThis-&gt;strtOffs = pThis-&gt;iCurrOffs = offs;
1375 finalize_it:
1376 	RETiRet;
1377 }
1378 static rsRetVal strmSeekCurrOffs(strm_t *pThis)
1379 {
1380 	off64_t targetOffs;
1381 	uchar c;
1382 	DEFiRet;
1383 	ISOBJ_TYPE_assert(pThis, strm);
1384 	if(pThis-&gt;cryprov == NULL || pThis-&gt;tOperationsMode != STREAMMODE_READ) {
1385 		iRet = strmSeek(pThis, pThis-&gt;iCurrOffs);
1386 		FINALIZE;
1387 	}
1388 	targetOffs = pThis-&gt;iCurrOffs;
1389 	pThis-&gt;strtOffs = pThis-&gt;iCurrOffs = 0;
1390 	DBGOPRINT((obj_t*) pThis, "encrypted, doing skip read of %lld bytes\n",
1391 		(long long) targetOffs);
1392 	while(targetOffs != pThis-&gt;iCurrOffs) {
1393 		CHKiRet(strmReadChar(pThis, &amp;c));
1394 	}
1395 finalize_it:
1396 	RETiRet;
1397 }
1398 static rsRetVal strmWriteChar(strm_t *__restrict__ const pThis, const uchar c)
1399 {
1400 	DEFiRet;
1401 	assert(pThis != NULL);
1402 	if(pThis-&gt;bAsyncWrite)
1403 		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
1404 	if(pThis-&gt;bDisabled)
1405 		ABORT_FINALIZE(RS_RET_STREAM_DISABLED);
1406 	if(pThis-&gt;iBufPtr == pThis-&gt;sIOBufSize) {
1407 		CHKiRet(strmFlushInternal(pThis, 0));
1408 	}
1409 	*(pThis-&gt;pIOBuf + pThis-&gt;iBufPtr) = c;
1410 	pThis-&gt;iBufPtr++;
1411 finalize_it:
1412 	if(pThis-&gt;bAsyncWrite)
1413 		d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
1414 	RETiRet;
1415 }
1416 static rsRetVal strmWriteLong(strm_t *__restrict__ const pThis, const long i)
1417 {
1418 	DEFiRet;
1419 	uchar szBuf[32];
1420 	assert(pThis != NULL);
1421 	CHKiRet(srUtilItoA((char*)szBuf, sizeof(szBuf), i));
1422 	CHKiRet(strmWrite(pThis, szBuf, strlen((char*)szBuf)));
1423 finalize_it:
1424 	RETiRet;
1425 }
1426 static rsRetVal ATTR_NONNULL(1,2)
1427 strmWrite(strm_t *__restrict__ const pThis, const uchar *__restrict__ const pBuf, size_t lenBuf)
1428 {
1429 	DEFiRet;
1430 	size_t iWrite;
1431 	size_t iOffset;
1432 	assert(pThis != NULL);
1433 	assert(pBuf != NULL);
1434 	if(pThis-&gt;bDisabled)
1435 		ABORT_FINALIZE(RS_RET_STREAM_DISABLED);
1436 	if(pThis-&gt;bAsyncWrite)
1437 		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
1438 	iOffset = 0;
1439 	do {
1440 		if(pThis-&gt;iBufPtr == pThis-&gt;sIOBufSize) {
1441 			CHKiRet(strmFlushInternal(pThis, 0)); 		}
1442 		iWrite = pThis-&gt;sIOBufSize - pThis-&gt;iBufPtr; 		if(iWrite &gt; lenBuf)
1443 			iWrite = lenBuf;
1444 		memcpy(pThis-&gt;pIOBuf + pThis-&gt;iBufPtr, pBuf + iOffset, iWrite);
1445 		pThis-&gt;iBufPtr += iWrite;
1446 		iOffset += iWrite;
1447 		lenBuf -= iWrite;
1448 	} while(lenBuf &gt; 0);
1449 	if(pThis-&gt;iBufPtr == pThis-&gt;sIOBufSize) {
1450 		CHKiRet(strmFlushInternal(pThis, 0)); 	}
1451 	if(pThis-&gt;fd != -1 &amp;&amp; pThis-&gt;iSizeLimit != 0) { 		CHKiRet(doSizeLimitProcessing(pThis));
1452 	}
1453 finalize_it:
1454 	if(pThis-&gt;bAsyncWrite) {
1455 		if(pThis-&gt;bDoTimedWait == 0) {
1456 			pThis-&gt;bDoTimedWait = 1;
1457 			pthread_cond_signal(&amp;pThis-&gt;notEmpty);
1458 		}
1459 		d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
1460 	}
1461 	RETiRet;
1462 }
1463 DEFpropSetMeth(strm, iMaxFileSize, int64)
1464 DEFpropSetMeth(strm, iFileNumDigits, int)
1465 DEFpropSetMeth(strm, tOperationsMode, int)
1466 DEFpropSetMeth(strm, tOpenMode, mode_t)
1467 DEFpropSetMeth(strm, sType, strmType_t)
1468 DEFpropSetMeth(strm, iZipLevel, int)
1469 DEFpropSetMeth(strm, bVeryReliableZip, int)
1470 DEFpropSetMeth(strm, bSync, int)
1471 DEFpropSetMeth(strm, bReopenOnTruncate, int)
1472 DEFpropSetMeth(strm, sIOBufSize, size_t)
1473 DEFpropSetMeth(strm, iSizeLimit, off_t)
1474 DEFpropSetMeth(strm, iFlushInterval, int)
1475 DEFpropSetMeth(strm, pszSizeLimitCmd, uchar*)
1476 DEFpropSetMeth(strm, cryprov, cryprov_if_t*)
1477 DEFpropSetMeth(strm, cryprovData, void*)
1478 void ATTR_NONNULL()
1479 strmSetReadTimeout(strm_t *const __restrict__ pThis, const int val)
1480 {
1481 	ISOBJ_TYPE_assert(pThis, strm);
1482 	pThis-&gt;readTimeout = val;
1483 }
1484 void ATTR_NONNULL()
1485 strmSet_checkRotation(strm_t *const pThis, const int val) {
1486 	ISOBJ_TYPE_assert(pThis, strm);
1487 	assert(val == STRM_ROTATION_DO_CHECK || val == STRM_ROTATION_DO_NOT_CHECK);
1488 	pThis-&gt;rotationCheck = val;
1489 }
1490 static rsRetVal ATTR_NONNULL()
1491 strmSetbDeleteOnClose(strm_t *const pThis, const int val)
1492 {
1493 	ISOBJ_TYPE_assert(pThis, strm);
1494 	pThis-&gt;bDeleteOnClose = val;
1495 	if(pThis-&gt;cryprov != NULL) {
1496 		pThis-&gt;cryprov-&gt;SetDeleteOnClose(pThis-&gt;cryprovFileData, pThis-&gt;bDeleteOnClose);
1497 	}
1498 	return RS_RET_OK;
1499 }
1500 static rsRetVal ATTR_NONNULL()
1501 strmSetiMaxFiles(strm_t *const pThis, const int iNewVal)
1502 {
1503 	ISOBJ_TYPE_assert(pThis, strm);
1504 	pThis-&gt;iMaxFiles = iNewVal;
1505 	pThis-&gt;iFileNumDigits = getNumberDigits(iNewVal);
1506 	return RS_RET_OK;
1507 }
1508 static rsRetVal ATTR_NONNULL()
1509 strmSetFileNotFoundError(strm_t *const pThis, const int pFileNotFoundError)
1510 {
1511 	ISOBJ_TYPE_assert(pThis, strm);
1512 	pThis-&gt;fileNotFoundError = pFileNotFoundError;
1513 	return RS_RET_OK;
1514 }
1515 static rsRetVal
1516 strmSetFName(strm_t *pThis, uchar *pszName, size_t iLenName)
1517 {
1518 	DEFiRet;
1519 	assert(pThis != NULL);
1520 	assert(pszName != NULL);
1521 	if(iLenName &lt; 1)
1522 		ABORT_FINALIZE(RS_RET_FILE_PREFIX_MISSING);
1523 	if(pThis-&gt;pszFName != NULL)
1524 		free(pThis-&gt;pszFName);
1525 	if((pThis-&gt;pszFName = malloc(iLenName + 1)) == NULL)
1526 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1527 	memcpy(pThis-&gt;pszFName, pszName, iLenName + 1); 	pThis-&gt;lenFName = iLenName;
1528 finalize_it:
1529 	RETiRet;
1530 }
1531 static rsRetVal
1532 strmSetDir(strm_t *pThis, uchar *pszDir, size_t iLenDir)
1533 {
1534 	DEFiRet;
1535 	assert(pThis != NULL);
1536 	assert(pszDir != NULL);
1537 	if(iLenDir &lt; 1)
1538 		ABORT_FINALIZE(RS_RET_FILE_PREFIX_MISSING);
1539 	CHKmalloc(pThis-&gt;pszDir = malloc(iLenDir + 1));
1540 	memcpy(pThis-&gt;pszDir, pszDir, iLenDir + 1); 	pThis-&gt;lenDir = iLenDir;
1541 finalize_it:
1542 	RETiRet;
1543 }
1544 static rsRetVal strmRecordBegin(strm_t *pThis)
1545 {
1546 	assert(pThis != NULL);
1547 	assert(pThis-&gt;bInRecord == 0);
1548 	pThis-&gt;bInRecord = 1;
1549 	return RS_RET_OK;
1550 }
1551 static rsRetVal strmRecordEnd(strm_t *pThis)
1552 {
1553 	DEFiRet;
1554 	assert(pThis != NULL);
1555 	assert(pThis-&gt;bInRecord == 1);
1556 	pThis-&gt;bInRecord = 0;
1557 	iRet = strmCheckNextOutputFile(pThis); 
1558 	RETiRet;
1559 }
1560 static rsRetVal strmSerialize(strm_t *pThis, strm_t *pStrm)
1561 {
1562 	DEFiRet;
1563 	int i;
1564 	int64 l;
1565 	ISOBJ_TYPE_assert(pThis, strm);
1566 	ISOBJ_TYPE_assert(pStrm, strm);
1567 	strmFlushInternal(pThis, 0);
1568 	CHKiRet(obj.BeginSerialize(pStrm, (obj_t*) pThis));
1569 	objSerializeSCALAR(pStrm, iCurrFNum, INT); 	objSerializePTR(pStrm, pszFName, PSZ);
1570 	objSerializeSCALAR(pStrm, iMaxFiles, INT);
1571 	objSerializeSCALAR(pStrm, bDeleteOnClose, INT);
1572 	i = pThis-&gt;sType;
1573 	objSerializeSCALAR_VAR(pStrm, sType, INT, i);
1574 	i = pThis-&gt;tOperationsMode;
1575 	objSerializeSCALAR_VAR(pStrm, tOperationsMode, INT, i);
1576 	i = pThis-&gt;tOpenMode;
1577 	objSerializeSCALAR_VAR(pStrm, tOpenMode, INT, i);
1578 	l = pThis-&gt;iCurrOffs;
1579 	objSerializeSCALAR_VAR(pStrm, iCurrOffs, INT64, l);
1580 	l = pThis-&gt;inode;
1581 	objSerializeSCALAR_VAR(pStrm, inode, INT64, l);
1582 	l = pThis-&gt;strtOffs;
1583 	objSerializeSCALAR_VAR(pStrm, strtOffs, INT64, l);
1584 	dbgprintf("strmSerialize: pThis-&gt;prevLineSegment %p\n", pThis-&gt;prevLineSegment);
1585 	if(pThis-&gt;prevLineSegment != NULL) {
1586 		cstrFinalize(pThis-&gt;prevLineSegment);
1587 		objSerializePTR(pStrm, prevLineSegment, CSTR);
1588 	}
1589 	if(pThis-&gt;prevMsgSegment != NULL) {
1590 		cstrFinalize(pThis-&gt;prevMsgSegment);
1591 		objSerializePTR(pStrm, prevMsgSegment, CSTR);
1592 	}
1593 	i = pThis-&gt;bPrevWasNL;
1594 	objSerializeSCALAR_VAR(pStrm, bPrevWasNL, INT, i);
1595 	CHKiRet(obj.EndSerialize(pStrm));
1596 finalize_it:
1597 	RETiRet;
1598 }
1599 static rsRetVal
1600 strmDup(strm_t *const pThis, strm_t **ppNew)
1601 {
1602 	strm_t *pNew = NULL;
1603 	DEFiRet;
1604 	ISOBJ_TYPE_assert(pThis, strm);
1605 	assert(ppNew != NULL);
1606 	CHKiRet(strmConstruct(&amp;pNew));
1607 	pNew-&gt;sType = pThis-&gt;sType;
1608 	pNew-&gt;iCurrFNum = pThis-&gt;iCurrFNum;
1609 	CHKmalloc(pNew-&gt;pszFName = ustrdup(pThis-&gt;pszFName));
1610 	pNew-&gt;lenFName = pThis-&gt;lenFName;
1611 	CHKmalloc(pNew-&gt;pszDir = ustrdup(pThis-&gt;pszDir));
1612 	pNew-&gt;lenDir = pThis-&gt;lenDir;
1613 	pNew-&gt;tOperationsMode = pThis-&gt;tOperationsMode;
1614 	pNew-&gt;tOpenMode = pThis-&gt;tOpenMode;
1615 	pNew-&gt;iMaxFileSize = pThis-&gt;iMaxFileSize;
1616 	pNew-&gt;iMaxFiles = pThis-&gt;iMaxFiles;
1617 	pNew-&gt;iFileNumDigits = pThis-&gt;iFileNumDigits;
1618 	pNew-&gt;bDeleteOnClose = pThis-&gt;bDeleteOnClose;
1619 	pNew-&gt;iCurrOffs = pThis-&gt;iCurrOffs;
1620 	*ppNew = pNew;
1621 	pNew = NULL;
1622 finalize_it:
1623 	if(pNew != NULL)
1624 		strmDestruct(&amp;pNew);
1625 	RETiRet;
1626 }
1627 static rsRetVal
1628 strmSetWCntr(strm_t *pThis, number_t *pWCnt)
1629 {
1630 	DEFiRet;
1631 	ISOBJ_TYPE_assert(pThis, strm);
1632 	if(pWCnt != NULL)
1633 		*pWCnt = 0;
1634 	pThis-&gt;pUsrWCntr = pWCnt;
1635 	RETiRet;
1636 }
1637 #include "stringbuf.h"
1638 #define isProp(name) !rsCStrSzStrCmp(pProp-&gt;pcsName, UCHAR_CONSTANT(name), sizeof(name) - 1)
1639 static rsRetVal strmSetProperty(strm_t *pThis, var_t *pProp)
1640 {
1641 	DEFiRet;
1642 	ISOBJ_TYPE_assert(pThis, strm);
1643 	assert(pProp != NULL);
1644 	if(isProp("sType")) {
1645 		CHKiRet(strmSetsType(pThis, (strmType_t) pProp-&gt;val.num));
1646 	} else if(isProp("iCurrFNum")) {
1647 		pThis-&gt;iCurrFNum = (unsigned) pProp-&gt;val.num;
1648 	} else if(isProp("pszFName")) {
1649 		CHKiRet(strmSetFName(pThis, rsCStrGetSzStrNoNULL(pProp-&gt;val.pStr), rsCStrLen(pProp-&gt;val.pStr)));
1650 	} else if(isProp("tOperationsMode")) {
1651 		CHKiRet(strmSettOperationsMode(pThis, pProp-&gt;val.num));
1652 	} else if(isProp("tOpenMode")) {
1653 		CHKiRet(strmSettOpenMode(pThis, pProp-&gt;val.num));
1654 	} else if(isProp("iCurrOffs")) {
1655 		pThis-&gt;iCurrOffs = pProp-&gt;val.num;
1656 	} else if(isProp("inode")) {
1657 		pThis-&gt;inode = (ino_t) pProp-&gt;val.num;
1658 	} else if(isProp("strtOffs")) {
1659 		pThis-&gt;strtOffs = pProp-&gt;val.num;
1660 	} else if(isProp("iMaxFileSize")) {
1661 		CHKiRet(strmSetiMaxFileSize(pThis, pProp-&gt;val.num));
1662 	} else if(isProp("fileNotFoundError")) {
1663 		CHKiRet(strmSetFileNotFoundError(pThis, pProp-&gt;val.num));
1664 	} else if(isProp("iMaxFiles")) {
1665 		CHKiRet(strmSetiMaxFiles(pThis, pProp-&gt;val.num));
1666 	} else if(isProp("iFileNumDigits")) {
1667 		CHKiRet(strmSetiFileNumDigits(pThis, pProp-&gt;val.num));
1668 	} else if(isProp("bDeleteOnClose")) {
1669 		CHKiRet(strmSetbDeleteOnClose(pThis, pProp-&gt;val.num));
1670 	} else if(isProp("prevLineSegment")) {
1671 		CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevLineSegment, pProp-&gt;val.pStr));
1672 	} else if(isProp("prevMsgSegment")) {
1673 		CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevMsgSegment, pProp-&gt;val.pStr));
1674 	} else if(isProp("bPrevWasNL")) {
1675 		pThis-&gt;bPrevWasNL = (sbool) pProp-&gt;val.num;
1676 	}
1677 finalize_it:
1678 	RETiRet;
1679 }
1680 #undef	isProp
1681 static rsRetVal
1682 strmGetCurrOffset(strm_t *pThis, int64 *pOffs)
1683 {
1684 	DEFiRet;
1685 	ISOBJ_TYPE_assert(pThis, strm);
1686 	assert(pOffs != NULL);
1687 	*pOffs = pThis-&gt;iCurrOffs;
1688 	RETiRet;
1689 }
1690 BEGINobjQueryInterface(strm)
1691 CODESTARTobjQueryInterface(strm)
1692 	if(pIf-&gt;ifVersion != strmCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
1693 	}
1694 	pIf-&gt;Construct = strmConstruct;
1695 	pIf-&gt;ConstructFinalize = strmConstructFinalize;
1696 	pIf-&gt;Destruct = strmDestruct;
1697 	pIf-&gt;ReadChar = strmReadChar;
1698 	pIf-&gt;UnreadChar = strmUnreadChar;
1699 	pIf-&gt;ReadLine = strmReadLine;
1700 	pIf-&gt;SeekCurrOffs = strmSeekCurrOffs;
1701 	pIf-&gt;Write = strmWrite;
1702 	pIf-&gt;WriteChar = strmWriteChar;
1703 	pIf-&gt;WriteLong = strmWriteLong;
1704 	pIf-&gt;SetFName = strmSetFName;
1705 	pIf-&gt;SetFileNotFoundError = strmSetFileNotFoundError;
1706 	pIf-&gt;SetDir = strmSetDir;
1707 	pIf-&gt;Flush = strmFlush;
1708 	pIf-&gt;RecordBegin = strmRecordBegin;
1709 	pIf-&gt;RecordEnd = strmRecordEnd;
1710 	pIf-&gt;Serialize = strmSerialize;
1711 	pIf-&gt;GetCurrOffset = strmGetCurrOffset;
1712 	pIf-&gt;Dup = strmDup;
1713 	pIf-&gt;SetWCntr = strmSetWCntr;
1714 	pIf-&gt;CheckFileChange = CheckFileChange;
1715 	pIf-&gt;SetbDeleteOnClose = strmSetbDeleteOnClose;
1716 	pIf-&gt;SetiMaxFileSize = strmSetiMaxFileSize;
1717 	pIf-&gt;SetiMaxFiles = strmSetiMaxFiles;
1718 	pIf-&gt;SetiFileNumDigits = strmSetiFileNumDigits;
1719 	pIf-&gt;SettOperationsMode = strmSettOperationsMode;
1720 	pIf-&gt;SettOpenMode = strmSettOpenMode;
1721 	pIf-&gt;SetsType = strmSetsType;
1722 	pIf-&gt;SetiZipLevel = strmSetiZipLevel;
1723 	pIf-&gt;SetbVeryReliableZip = strmSetbVeryReliableZip;
1724 	pIf-&gt;SetbSync = strmSetbSync;
1725 	pIf-&gt;SetbReopenOnTruncate = strmSetbReopenOnTruncate;
1726 	pIf-&gt;SetsIOBufSize = strmSetsIOBufSize;
1727 	pIf-&gt;SetiSizeLimit = strmSetiSizeLimit;
1728 	pIf-&gt;SetiFlushInterval = strmSetiFlushInterval;
1729 	pIf-&gt;SetpszSizeLimitCmd = strmSetpszSizeLimitCmd;
1730 	pIf-&gt;Setcryprov = strmSetcryprov;
1731 	pIf-&gt;SetcryprovData = strmSetcryprovData;
1732 finalize_it:
1733 ENDobjQueryInterface(strm)
1734 BEGINObjClassInit(strm, 1, OBJ_IS_CORE_MODULE)
1735 	OBJSetMethodHandler(objMethod_SERIALIZE, strmSerialize);
1736 	OBJSetMethodHandler(objMethod_SETPROPERTY, strmSetProperty);
1737 	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, strmConstructFinalize);
1738 ENDObjClassInit(strm)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
