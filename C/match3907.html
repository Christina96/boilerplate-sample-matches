<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inputfilegen.c &amp; stream.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inputfilegen.c &amp; stream.c
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inputfilegen.c (16.304348%)<th>stream.c (0.9009009%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(44-57)<td><a href="#" name="0">(261-274)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inputfilegen.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#if defined(_AIX)
	#include  &lt;unistd.h&gt;
#else
	#include &lt;getopt.h&gt;
#endif
#define DEFMSGS 5
#define NOEXTRADATA -1
int main(int argc, char* argv[])
{
	int c, i;
	long long nmsgs = DEFMSGS;
	long long nmsgstart = 0;
	int nchars = NOEXTRADATA;
	int errflg = 0;
	long long filesize = -1;
	char *extradata = NULL;
<a name="0"></a>	const char *msgcntfile = NULL;
	while((c=getopt(argc, argv, "m:M:i:d:s:")) != -1) {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		switch(c) {
		case 'm':
			nmsgs = atoi(optarg);
			break;
		case 'M':
			msgcntfile = optarg;
			break;
		case 'i':
			nmsgstart = atoi(optarg);
			break;
		case 'd':
			nchars = atoi(optarg);
			break;
		case 's':</b></font>
			filesize = atoll(optarg);
			break;
		case ':':
			fprintf(stderr, "Option -%c requires an operand\n", optopt);
			errflg++;
			break;
		case '?':
			fprintf(stderr, "Unrecognized option: -%c\n", optopt);
			errflg++;
			break;
		}
	}
	if(errflg) {
		fprintf(stderr, "invalid call\n");
		exit(2);
	}
	if(filesize != -1) {
		const int linesize = (17 + nchars); 		nmsgs = filesize / linesize;
		fprintf(stderr, "file size requested %lld, actual %lld with "
			"%lld lines, %lld bytes less\n",
			filesize, nmsgs * linesize, nmsgs, filesize - nmsgs * linesize);
		if(nmsgs &gt; 100000000) {
			fprintf(stderr, "number of lines exhaust 8-digit line numbers "
				"which are standard inside the testbench.\n"
				"Use -d switch to add extra data (e.g. -d111 for "
				"128 byte lines or -d47 for 64 byte lines)\n");
			exit(1);
		}
	}
	if(msgcntfile != NULL) {
		FILE *const fh = fopen(msgcntfile, "w");
		if(fh == NULL) {
			perror(msgcntfile);
			exit(1);
		}
		fprintf(fh, "%lld", nmsgs);
		fclose(fh);
	}
	if(nchars != NOEXTRADATA) {
		extradata = (char *)malloc(nchars + 1);
		memset(extradata, 'X', nchars);
		extradata[nchars] = '\0';
	}
	for(i = nmsgstart; i &lt; (nmsgs+nmsgstart); ++i) {
		printf("msgnum:%8.8d:", i);
		if(nchars != NOEXTRADATA) {
			printf("%s", extradata);
		}
		printf("\n");
	}
	free(extradata);
	return 0;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>stream.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;pthread.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;	 #include &lt;errno.h&gt;
#include &lt;pthread.h&gt;
#include &lt;poll.h&gt;
#ifdef HAVE_SYS_PRCTL_H
#  include &lt;sys/prctl.h&gt;
#endif
#include "rsyslog.h"
#include "stringbuf.h"
#include "srUtils.h"
#include "obj.h"
#include "stream.h"
#include "unicode-helper.h"
#include "module-template.h"
#include "errmsg.h"
#include "cryprov.h"
#include "datetime.h"
#include "rsconf.h"
#ifndef O_LARGEFILE
#  define O_LARGEFILE 0
#endif
#ifndef HAVE_LSEEK64
#  define lseek64(fd, offset, whence) lseek(fd, offset, whence)
#endif
DEFobjStaticHelpers
DEFobjCurrIf(zlibw)
static rsRetVal strmFlushInternal(strm_t *pThis, int bFlushZip);
static rsRetVal strmWrite(strm_t *__restrict__ const pThis, const uchar *__restrict__ const pBuf,
	const size_t lenBuf);
static rsRetVal strmOpenFile(strm_t *pThis);
static rsRetVal strmCloseFile(strm_t *pThis);
static void *asyncWriterThread(void *pPtr);
static rsRetVal doZipWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf, int bFlush);
static rsRetVal doZipFinish(strm_t *pThis);
static rsRetVal strmPhysWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf);
static rsRetVal strmSeekCurrOffs(strm_t *pThis);
const uchar * ATTR_NONNULL()
strmGetPrevLineSegment(strm_t *const pThis)
{
	const uchar *ret = NULL;
	if(pThis-&gt;prevLineSegment != NULL) {
		cstrFinalize(pThis-&gt;prevLineSegment);
		ret = rsCStrGetSzStrNoNULL(pThis-&gt;prevLineSegment);
	}
	return ret;
}
const uchar * ATTR_NONNULL()
strmGetPrevMsgSegment(strm_t *const pThis)
{
	const uchar *ret = NULL;
	if(pThis-&gt;prevMsgSegment != NULL) {
		cstrFinalize(pThis-&gt;prevMsgSegment);
		ret = rsCStrGetSzStrNoNULL(pThis-&gt;prevMsgSegment);
	}
	return ret;
}
int ATTR_NONNULL()
strmGetPrevWasNL(const strm_t *const pThis)
{
	return pThis-&gt;bPrevWasNL;
}
static const char *
getFileDebugName(const strm_t *const pThis)
{
	  return (pThis-&gt;pszCurrFName == NULL) ?
		  ((pThis-&gt;pszFName == NULL) ? "N/A" : (char*)pThis-&gt;pszFName)
		: (const char*) pThis-&gt;pszCurrFName;
}
static rsRetVal
resolveFileSizeLimit(strm_t *pThis, uchar *pszCurrFName)
{
	uchar *pParams;
	uchar *pCmd;
	uchar *p;
	off_t actualFileSize;
	rsRetVal localRet;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	assert(pszCurrFName != NULL);
	if(pThis-&gt;pszSizeLimitCmd == NULL) {
		ABORT_FINALIZE(RS_RET_NON_SIZELIMITCMD); 	}
	CHKmalloc(pCmd = ustrdup(pThis-&gt;pszSizeLimitCmd));
	for(p = pCmd ; *p &amp;&amp; *p != ' ' ; ++p) {
	}
	if(*p == ' ') {
		*p = '\0'; 		pParams = p+1;
	} else
		pParams = NULL;
	execProg(pCmd, 1, pParams);
	free(pCmd);
	localRet = getFileSize(pszCurrFName, &amp;actualFileSize);
	if(localRet == RS_RET_OK &amp;&amp; actualFileSize &gt;= pThis-&gt;iSizeLimit) {
		ABORT_FINALIZE(RS_RET_SIZELIMITCMD_DIDNT_RESOLVE); 	} else if(localRet != RS_RET_FILE_NOT_FOUND) {
		ABORT_FINALIZE(localRet);
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		if(iRet == RS_RET_SIZELIMITCMD_DIDNT_RESOLVE) {
			LogError(0, RS_RET_ERR, "file size limit cmd for file '%s' "
				"did no resolve situation\n", pszCurrFName);
		} else {
			LogError(0, RS_RET_ERR, "file size limit cmd for file '%s' "
				"failed with code %d.\n", pszCurrFName, iRet);
		}
		pThis-&gt;bDisabled = 1;
	}
	RETiRet;
}
static rsRetVal
doSizeLimitProcessing(strm_t *pThis)
{
	uchar *pszCurrFName = NULL;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	assert(pThis-&gt;iSizeLimit != 0);
	assert(pThis-&gt;fd != -1);
	if(pThis-&gt;iCurrOffs &gt;= pThis-&gt;iSizeLimit) {
		CHKmalloc(pszCurrFName = ustrdup(pThis-&gt;pszCurrFName));
		CHKiRet(strmCloseFile(pThis));
		CHKiRet(resolveFileSizeLimit(pThis, pszCurrFName));
	}
finalize_it:
	free(pszCurrFName);
	RETiRet;
}
static rsRetVal
doPhysOpen(strm_t *pThis)
{
	int iFlags = 0;
	struct stat statOpen;
	DEFiRet;
<a name="0"></a>	ISOBJ_TYPE_assert(pThis, strm);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	switch(pThis-&gt;tOperationsMode) {
		case STREAMMODE_READ:
			iFlags = O_CLOEXEC | O_NOCTTY | O_RDONLY;
			break;
		case STREAMMODE_WRITE:				iFlags = O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT;
			break;
		case STREAMMODE_WRITE_TRUNC:
			iFlags = O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_TRUNC;
			break;
		case STREAMMODE_WRITE_APPEND:
			iFlags = O_CLOEXEC | O_NOCTTY | O_WRONLY | O_CREAT | O_APPEND;
			break;
		case STREAMMMODE_INVALID:</b></font>
		default:assert(0);
			break;
	}
	if(pThis-&gt;sType == STREAMTYPE_NAMED_PIPE) {
		DBGPRINTF("Note: stream '%s' is a named pipe, open with O_NONBLOCK\n", pThis-&gt;pszCurrFName);
		iFlags |= O_NONBLOCK;
	}
	if(pThis-&gt;bAsyncWrite)d_pthread_mutex_lock(&amp;pThis-&gt;mut);
	pThis-&gt;fd = open((char*)pThis-&gt;pszCurrFName, iFlags | O_LARGEFILE, pThis-&gt;tOpenMode);
	if(pThis-&gt;bAsyncWrite) d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
	const int errno_save = errno; 	DBGPRINTF("file '%s' opened as #%d with mode %d\n", pThis-&gt;pszCurrFName,
		  pThis-&gt;fd, (int) pThis-&gt;tOpenMode);
	if(pThis-&gt;fd == -1) {
		const rsRetVal errcode = (errno_save == ENOENT) ? RS_RET_FILE_NOT_FOUND
			: RS_RET_FILE_OPEN_ERROR;
		if(pThis-&gt;fileNotFoundError) {
			if(pThis-&gt;noRepeatedErrorOutput == 0) {
				LogError(errno_save, errcode, "file '%s': open error", pThis-&gt;pszCurrFName);
				pThis-&gt;noRepeatedErrorOutput = 1;
			}
		} else {
			DBGPRINTF("file '%s': open error", pThis-&gt;pszCurrFName);
		}
		ABORT_FINALIZE(errcode);
	} else {
		pThis-&gt;noRepeatedErrorOutput = 0;
	}
	if(pThis-&gt;tOperationsMode == STREAMMODE_READ) {
		if(fstat(pThis-&gt;fd, &amp;statOpen) == -1) {
			DBGPRINTF("Error: cannot obtain inode# for file %s\n", pThis-&gt;pszCurrFName);
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		}
		pThis-&gt;inode = statOpen.st_ino;
	}
	if(!ustrcmp(pThis-&gt;pszCurrFName, UCHAR_CONSTANT(_PATH_CONSOLE)) || isatty(pThis-&gt;fd)) {
		DBGPRINTF("file %d is a tty-type file\n", pThis-&gt;fd);
		pThis-&gt;bIsTTY = 1;
	} else {
		pThis-&gt;bIsTTY = 0;
	}
	if(pThis-&gt;cryprov != NULL) {
		CHKiRet(pThis-&gt;cryprov-&gt;OnFileOpen(pThis-&gt;cryprovData,
		 	pThis-&gt;pszCurrFName, &amp;pThis-&gt;cryprovFileData,
			(pThis-&gt;tOperationsMode == STREAMMODE_READ) ? 'r' : 'w'));
		pThis-&gt;cryprov-&gt;SetDeleteOnClose(pThis-&gt;cryprovFileData, pThis-&gt;bDeleteOnClose);
	}
finalize_it:
	RETiRet;
}
static rsRetVal
strmSetCurrFName(strm_t *pThis)
{
	DEFiRet;
	if(pThis-&gt;sType == STREAMTYPE_FILE_CIRCULAR) {
		CHKiRet(genFileName(&amp;pThis-&gt;pszCurrFName, pThis-&gt;pszDir, pThis-&gt;lenDir,
				    pThis-&gt;pszFName, pThis-&gt;lenFName, pThis-&gt;iCurrFNum, pThis-&gt;iFileNumDigits));
	} else {
		if(pThis-&gt;pszDir == NULL) {
			if((pThis-&gt;pszCurrFName = ustrdup(pThis-&gt;pszFName)) == NULL)
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		} else {
			CHKiRet(genFileName(&amp;pThis-&gt;pszCurrFName, pThis-&gt;pszDir, pThis-&gt;lenDir,
					    pThis-&gt;pszFName, pThis-&gt;lenFName, -1, 0));
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
CheckFileChange(strm_t *pThis)
{
	struct stat statName;
	DEFiRet;
	CHKiRet(strmSetCurrFName(pThis));
	if(stat((char*) pThis-&gt;pszCurrFName, &amp;statName) == -1)
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	DBGPRINTF("CheckFileChange: stream/after deserialize checking for file change "
		"on '%s', inode %u/%u, size/currOffs %llu/%llu\n",
		pThis-&gt;pszCurrFName, (unsigned) pThis-&gt;inode,
		(unsigned) statName.st_ino,
		(long long unsigned) statName.st_size,
		(long long unsigned) pThis-&gt;iCurrOffs);
	if(pThis-&gt;inode != statName.st_ino || statName.st_size &lt; pThis-&gt;iCurrOffs) {
		DBGPRINTF("stream: file %s has changed\n", pThis-&gt;pszCurrFName);
		pThis-&gt;iCurrOffs = 0;
	}
finalize_it:
	RETiRet;
}
static rsRetVal strmOpenFile(strm_t *pThis)
{
	DEFiRet;
	off_t offset;
	assert(pThis != NULL);
	if(pThis-&gt;fd != -1)
		ABORT_FINALIZE(RS_RET_OK);
	free(pThis-&gt;pszCurrFName);
	pThis-&gt;pszCurrFName = NULL; 
	if(pThis-&gt;pszFName == NULL)
		ABORT_FINALIZE(RS_RET_FILE_PREFIX_MISSING);
	CHKiRet(strmSetCurrFName(pThis));
	CHKiRet(doPhysOpen(pThis));
	pThis-&gt;iCurrOffs = 0;
	pThis-&gt;iBufPtrMax = 0;
	CHKiRet(getFileSize(pThis-&gt;pszCurrFName, &amp;offset));
	if(pThis-&gt;tOperationsMode == STREAMMODE_WRITE_APPEND) {
		pThis-&gt;iCurrOffs = offset;
	} else if(pThis-&gt;tOperationsMode == STREAMMODE_WRITE_TRUNC) {
		if(offset != 0) {
			LogError(0, 0, "file '%s' opened for truncate write, but "
				"already contains %zd bytes\n",
				pThis-&gt;pszCurrFName, (ssize_t) offset);
		}
	}
	DBGOPRINT((obj_t*) pThis, "opened file '%s' for %s as %d\n", pThis-&gt;pszCurrFName,
		  (pThis-&gt;tOperationsMode == STREAMMODE_READ) ? "READ" : "WRITE", pThis-&gt;fd);
finalize_it:
	if(iRet == RS_RET_OK) {
		assert(pThis-&gt;fd != -1);
	} else {
		if(pThis-&gt;pszCurrFName != NULL) {
			free(pThis-&gt;pszCurrFName);
			pThis-&gt;pszCurrFName = NULL; 		}
		if(pThis-&gt;fd != -1) {
			close(pThis-&gt;fd);
			pThis-&gt;fd = -1;
		}
	}
	RETiRet;
}
static void
strmWaitAsyncWriterDone(strm_t *pThis)
{
	if(pThis-&gt;bAsyncWrite) {
		while(pThis-&gt;iCnt &gt; 0) {
			pthread_cond_signal(&amp;pThis-&gt;notEmpty);
			d_pthread_cond_wait(&amp;pThis-&gt;isEmpty, &amp;pThis-&gt;mut);
		}
	}
}
static void
stopWriter(strm_t *const pThis)
{
	pThis-&gt;bStopWriter = 1;
	pthread_cond_signal(&amp;pThis-&gt;notEmpty);
	d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
	pthread_join(pThis-&gt;writerThreadID, NULL);
}
static rsRetVal strmCloseFile(strm_t *pThis)
{
	off64_t currOffs;
	DEFiRet;
	assert(pThis != NULL);
	DBGOPRINT((obj_t*) pThis, "file %d(%s) closing, bDeleteOnClose %d\n", pThis-&gt;fd,
		getFileDebugName(pThis), pThis-&gt;bDeleteOnClose);
	if(pThis-&gt;tOperationsMode != STREAMMODE_READ) {
		if(pThis-&gt;bAsyncWrite) {
			strmWaitAsyncWriterDone(pThis);
		}
		strmFlushInternal(pThis, 0);
		if(pThis-&gt;iZipLevel) {
			doZipFinish(pThis);
		}
		if(pThis-&gt;bAsyncWrite) {
			stopWriter(pThis);
		}
	}
	if(pThis-&gt;cryprov != NULL &amp;&amp; pThis-&gt;fd == -1) {
		const rsRetVal localRet = strmOpenFile(pThis);
		if(localRet != RS_RET_OK) {
			LogError(0, localRet, "could not open file %s, this "
				"may result in problems with encryption - "
				"unfortunately, we cannot do anything against "
				"this.", pThis-&gt;pszCurrFName);
		}
	}
	if(pThis-&gt;fd != -1) {
		DBGOPRINT((obj_t*) pThis, "file %d(%s) closing\n",
			pThis-&gt;fd, getFileDebugName(pThis));
		currOffs = lseek64(pThis-&gt;fd, 0, SEEK_CUR);
		close(pThis-&gt;fd);
		pThis-&gt;fd = -1;
		pThis-&gt;inode = 0;
		if(pThis-&gt;cryprov != NULL) {
			pThis-&gt;cryprov-&gt;OnFileClose(pThis-&gt;cryprovFileData, currOffs);
			pThis-&gt;cryprovFileData = NULL;
		}
	}
	if(pThis-&gt;fdDir != -1) {
		close(pThis-&gt;fdDir);
		pThis-&gt;fdDir = -1;
	}
	if(pThis-&gt;bDeleteOnClose) {
		if(pThis-&gt;pszCurrFName == NULL) {
			CHKiRet(genFileName(&amp;pThis-&gt;pszCurrFName, pThis-&gt;pszDir, pThis-&gt;lenDir,
					    pThis-&gt;pszFName, pThis-&gt;lenFName, pThis-&gt;iCurrFNum,
					    pThis-&gt;iFileNumDigits));
		}
		DBGPRINTF("strmCloseFile: deleting '%s'\n", pThis-&gt;pszCurrFName);
		if(unlink((char*) pThis-&gt;pszCurrFName) == -1) {
			char errStr[1024];
			int err = errno;
			rs_strerror_r(err, errStr, sizeof(errStr));
			DBGPRINTF("error %d unlinking '%s' - ignored: %s\n",
				   errno, pThis-&gt;pszCurrFName, errStr);
		}
	}
	pThis-&gt;iCurrOffs = 0;	
finalize_it:
	free(pThis-&gt;pszCurrFName);
	pThis-&gt;pszCurrFName = NULL;
	RETiRet;
}
static rsRetVal
strmNextFile(strm_t *pThis)
{
	DEFiRet;
	assert(pThis != NULL);
	assert(pThis-&gt;sType == STREAMTYPE_FILE_CIRCULAR);
	assert(pThis-&gt;iMaxFiles != 0);
	assert(pThis-&gt;fd != -1);
	CHKiRet(strmCloseFile(pThis));
	pThis-&gt;iCurrFNum = (pThis-&gt;iCurrFNum + 1) % pThis-&gt;iMaxFiles;
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
strmHandleEOFMonitor(strm_t *const pThis)
{
	DEFiRet;
	struct stat statName;
	ISOBJ_TYPE_assert(pThis, strm);
	if(stat((char*) pThis-&gt;pszCurrFName, &amp;statName) == -1)
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	DBGPRINTF("strmHandleEOFMonitor: stream checking for file change on '%s', inode %u/%u size %llu/%llu\n",
		pThis-&gt;pszCurrFName, (unsigned) pThis-&gt;inode, (unsigned) statName.st_ino,
		(long long unsigned) pThis-&gt;iCurrOffs, (long long unsigned) statName.st_size);
	if (pThis-&gt;inode != statName.st_ino
		  || (pThis-&gt;bReopenOnTruncate &amp;&amp; statName.st_size &lt; pThis-&gt;iCurrOffs)) {
		DBGPRINTF("we had a file change on '%s'\n", pThis-&gt;pszCurrFName);
		CHKiRet(strmCloseFile(pThis));
		CHKiRet(strmOpenFile(pThis));
	} else {
		ABORT_FINALIZE(RS_RET_EOF);
	}
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
strmHandleEOF(strm_t *const pThis)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	switch(pThis-&gt;sType) {
		case STREAMTYPE_FILE_SINGLE:
		case STREAMTYPE_NAMED_PIPE:
			ABORT_FINALIZE(RS_RET_EOF);
			break;
		case STREAMTYPE_FILE_CIRCULAR:
			DBGOPRINT((obj_t*) pThis, "file %d EOF\n", pThis-&gt;fd);
			CHKiRet(strmNextFile(pThis));
			break;
		case STREAMTYPE_FILE_MONITOR:
			DBGOPRINT((obj_t*) pThis, "file '%s' (%d) EOF, rotationCheck %d\n",
				pThis-&gt;pszCurrFName, pThis-&gt;fd, pThis-&gt;rotationCheck);
			if(pThis-&gt;rotationCheck == STRM_ROTATION_DO_CHECK) {
				CHKiRet(strmHandleEOFMonitor(pThis));
			} else {
				ABORT_FINALIZE(RS_RET_EOF);
			}
			break;
	}
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
rereadTruncated(strm_t *const pThis, const int err_no, const char *const reason, const long long data)
{
	DEFiRet;
	LogMsg(err_no, RS_RET_FILE_TRUNCATED, LOG_WARNING, "file '%s': truncation detected, "
		"(%s) - re-start reading from beginning (data %lld)",
		pThis-&gt;pszCurrFName, reason, data);
	DBGPRINTF("checkTruncation, file %s last buffer CHANGED\n", pThis-&gt;pszCurrFName);
	CHKiRet(strmCloseFile(pThis));
	CHKiRet(strmOpenFile(pThis));
	iRet = RS_RET_FILE_TRUNCATED;
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
checkTruncation(strm_t *const pThis)
{
	DEFiRet;
	off64_t ret;
	assert(pThis-&gt;bReopenOnTruncate);
	assert(pThis-&gt;fd != -1);
	DBGPRINTF("checkTruncation, file %s, iBufPtrMax %zd\n", pThis-&gt;pszCurrFName, pThis-&gt;iBufPtrMax);
	if(pThis-&gt;iBufPtrMax == 0) {
		FINALIZE;
	}
	const off64_t backseek = -1 * (off64_t) pThis-&gt;iBufPtrMax;
	ret = lseek64(pThis-&gt;fd, backseek, SEEK_CUR);
	if(ret &lt; 0) {
		iRet = rereadTruncated(pThis, errno,
			"cannot seek backward to begin of last block", backseek);
		FINALIZE;
	}
	const ssize_t lenRead = read(pThis-&gt;fd, pThis-&gt;pIOBuf_truncation, pThis-&gt;iBufPtrMax);
	if(lenRead != (ssize_t) pThis-&gt;iBufPtrMax) {
		iRet = rereadTruncated(pThis, errno,
			"last block could not be re-read", lenRead);
		FINALIZE;
	}
	if(!memcmp(pThis-&gt;pIOBuf_truncation, pThis-&gt;pIOBuf, pThis-&gt;iBufPtrMax)) {
		DBGPRINTF("checkTruncation, file %s last buffer unchanged\n", pThis-&gt;pszCurrFName);
	} else {
		iRet = rereadTruncated(pThis, errno, "last block data different", 0);
	}
finalize_it:
	RETiRet;
}
static rsRetVal
strmReadBuf(strm_t *pThis, int *padBytes)
{
	DEFiRet;
	int bRun;
	long iLenRead;
	size_t actualDataLen;
	size_t toRead;
	ssize_t bytesLeft;
	ISOBJ_TYPE_assert(pThis, strm);
	bRun = 1;
	while(bRun) {
		CHKiRet(strmOpenFile(pThis));
		if(pThis-&gt;cryprov == NULL) {
			toRead = pThis-&gt;sIOBufSize;
		} else {
			CHKiRet(pThis-&gt;cryprov-&gt;GetBytesLeftInBlock(pThis-&gt;cryprovFileData, &amp;bytesLeft));
			if(bytesLeft == -1 || bytesLeft &gt; (ssize_t) pThis-&gt;sIOBufSize)  {
				toRead = pThis-&gt;sIOBufSize;
			} else {
				toRead = (size_t) bytesLeft;
			}
		}
		if(pThis-&gt;bReopenOnTruncate) {
			rsRetVal localRet = checkTruncation(pThis);
			if(localRet == RS_RET_FILE_TRUNCATED) {
				continue;
			}
			CHKiRet(localRet);
		}
		iLenRead = read(pThis-&gt;fd, pThis-&gt;pIOBuf, toRead);
		DBGOPRINT((obj_t*) pThis, "file %d read %ld bytes\n", pThis-&gt;fd, iLenRead);
		if(iLenRead == 0) {
			CHKiRet(strmHandleEOF(pThis));
		} else if(iLenRead &lt; 0)
			ABORT_FINALIZE(RS_RET_IO_ERROR);
		else { 			if(pThis-&gt;cryprov != NULL) {
				actualDataLen = iLenRead;
				pThis-&gt;cryprov-&gt;Decrypt(pThis-&gt;cryprovFileData, pThis-&gt;pIOBuf, &amp;actualDataLen);
				*padBytes = iLenRead - actualDataLen;
				iLenRead = actualDataLen;
				DBGOPRINT((obj_t*) pThis, "encrypted file %d pad bytes %d, actual "
					"data %ld\n", pThis-&gt;fd, *padBytes, iLenRead);
			} else {
				*padBytes = 0;
			}
			pThis-&gt;iBufPtrMax = iLenRead;
			bRun = 0;			}
	}
	pThis-&gt;iBufPtr = 0;
finalize_it:
	RETiRet;
}
void
strmDebugOutBuf(const strm_t *const pThis)
{
	int strtIdx = pThis-&gt;iBufPtr - 50;
	if(strtIdx &lt; 0)
		strtIdx = 0;
	DBGOPRINT((obj_t*) pThis, "strmRead ungetc %d, index %zd, max %zd, buf '%.*s', CURR: '%.*s'\n",
		pThis-&gt;iUngetC, pThis-&gt;iBufPtr, pThis-&gt;iBufPtrMax, (int) pThis-&gt;iBufPtrMax - strtIdx,
		pThis-&gt;pIOBuf+strtIdx, (int) (pThis-&gt;iBufPtrMax - pThis-&gt;iBufPtr), pThis-&gt;pIOBuf+pThis-&gt;iBufPtr);
}
static rsRetVal strmReadChar(strm_t *pThis, uchar *pC)
{
	int padBytes = 0; 	DEFiRet;
	assert(pThis != NULL);
	assert(pC != NULL);
	if(pThis-&gt;iUngetC != -1) {			*pC = pThis-&gt;iUngetC;
		++pThis-&gt;iCurrOffs; 		pThis-&gt;iUngetC = -1;
		ABORT_FINALIZE(RS_RET_OK);
	}
	if(pThis-&gt;iBufPtr &gt;= pThis-&gt;iBufPtrMax) {
		CHKiRet(strmReadBuf(pThis, &amp;padBytes));
	}
	pThis-&gt;iCurrOffs += padBytes;
	*pC = pThis-&gt;pIOBuf[pThis-&gt;iBufPtr++];
	++pThis-&gt;iCurrOffs; 
finalize_it:
	RETiRet;
}
static rsRetVal strmUnreadChar(strm_t *pThis, uchar c)
{
	assert(pThis != NULL);
	assert(pThis-&gt;iUngetC == -1);
	pThis-&gt;iUngetC = c;
	return RS_RET_OK;
}
static rsRetVal ATTR_NONNULL(1, 2)
strmReadLine(strm_t *const pThis, cstr_t **ppCStr, uint8_t mode, sbool bEscapeLF,
	const uchar *const escapeLFString, uint32_t trimLineOverBytes, int64 *const strtOffs)
{
	uchar c;
	uchar finished;
	const int escapeLFString_len = (escapeLFString == NULL) ? 4 : strlen((char*) escapeLFString);
	DEFiRet;
	assert(pThis != NULL);
	assert(ppCStr != NULL);
	CHKiRet(cstrConstruct(ppCStr));
	CHKiRet(strmReadChar(pThis, &amp;c));
	if(pThis-&gt;prevLineSegment != NULL) {
		cstrFinalize(pThis-&gt;prevLineSegment);
		dbgprintf("readLine: have previous line segment: '%s'\n",
			rsCStrGetSzStrNoNULL(pThis-&gt;prevLineSegment));
		CHKiRet(cstrAppendCStr(*ppCStr, pThis-&gt;prevLineSegment));
		cstrDestruct(&amp;pThis-&gt;prevLineSegment);
	}
	if(mode == 0) {
		while(c != '\n') {
			CHKiRet(cstrAppendChar(*ppCStr, c));
			CHKiRet(strmReadChar(pThis, &amp;c));
		}
		if (trimLineOverBytes &gt; 0 &amp;&amp; (uint32_t) cstrLen(*ppCStr) &gt; trimLineOverBytes) {
			dbgprintf("Truncate long line at %u, mode %d\n", trimLineOverBytes, mode);
			rsCStrTruncate(*ppCStr, cstrLen(*ppCStr) - trimLineOverBytes);
			cstrAppendChar(*ppCStr, '\n');
		}
		cstrFinalize(*ppCStr);
	} else if(mode == 1) {
		finished=0;
		while(finished == 0){
			if(c != '\n') {
				CHKiRet(cstrAppendChar(*ppCStr, c));
				CHKiRet(strmReadChar(pThis, &amp;c));
				pThis-&gt;bPrevWasNL = 0;
			} else {
				if ((((*ppCStr)-&gt;iStrLen) &gt; 0) ){
					if(pThis-&gt;bPrevWasNL &amp;&amp; escapeLFString_len &gt; 0) {
						rsCStrTruncate(*ppCStr, (bEscapeLF) ? escapeLFString_len : 1);
						finished=1;
					} else {
						if(bEscapeLF) {
							if(escapeLFString == NULL) {
								CHKiRet(rsCStrAppendStrWithLen(*ppCStr,
									(uchar*)"#012", sizeof("#012")-1));
							} else {
								CHKiRet(rsCStrAppendStrWithLen(*ppCStr,
									escapeLFString, escapeLFString_len));
							}
						} else {
							CHKiRet(cstrAppendChar(*ppCStr, c));
						}
						CHKiRet(strmReadChar(pThis, &amp;c));
						pThis-&gt;bPrevWasNL = 1;
					}
				} else {
				}
			}
		}
		cstrFinalize(*ppCStr);
		pThis-&gt;bPrevWasNL = 0;
	} else if(mode == 2) {
		finished=0;
		while(finished == 0){
			if ((*ppCStr)-&gt;iStrLen == 0){
				if(c != '\n') {
					CHKiRet(cstrAppendChar(*ppCStr, c));
					CHKiRet(strmReadChar(pThis, &amp;c));
				} else {
				}
			} else {
				if(pThis-&gt;bPrevWasNL) {
					if ((c == ' ') || (c == '\t')){
						CHKiRet(cstrAppendChar(*ppCStr, c));
						CHKiRet(strmReadChar(pThis, &amp;c));
						pThis-&gt;bPrevWasNL = 0;
					} else {
						CHKiRet(strmUnreadChar(pThis, c));
						if(bEscapeLF &amp;&amp; escapeLFString_len &gt; 0) {
							rsCStrTruncate(*ppCStr, (bEscapeLF) ? escapeLFString_len : 1);
						}
						finished=1;
					}
				} else { 					if(c == '\n') {
						pThis-&gt;bPrevWasNL = 1;
						if(bEscapeLF &amp;&amp; escapeLFString_len &gt; 0) {
							if(escapeLFString == NULL) {
								CHKiRet(rsCStrAppendStrWithLen(*ppCStr,
									(uchar*)"#012", sizeof("#012")-1));
							} else {
								CHKiRet(rsCStrAppendStrWithLen(*ppCStr,
									escapeLFString, escapeLFString_len));
							}
						} else {
							CHKiRet(cstrAppendChar(*ppCStr, c));
						}
					} else {
						CHKiRet(cstrAppendChar(*ppCStr, c));
					}
					CHKiRet(strmReadChar(pThis, &amp;c));
				}
			}
		}
		if (trimLineOverBytes &gt; 0 &amp;&amp; (uint32_t) cstrLen(*ppCStr) &gt; trimLineOverBytes) {
			dbgprintf("Truncate long line at %u, mode %d\n", trimLineOverBytes, mode);
			rsCStrTruncate(*ppCStr, cstrLen(*ppCStr) - trimLineOverBytes);
			cstrAppendChar(*ppCStr, '\n');
		}
		cstrFinalize(*ppCStr);
		pThis-&gt;bPrevWasNL = 0;
	}
finalize_it:
	if(iRet == RS_RET_OK) {
		if(strtOffs != NULL) {
			*strtOffs = pThis-&gt;strtOffs;
		}
		pThis-&gt;strtOffs = pThis-&gt;iCurrOffs; 	} else {
		if(*ppCStr != NULL) {
			if(cstrLen(*ppCStr) &gt; 0) {
				if(rsCStrConstructFromCStr(&amp;pThis-&gt;prevLineSegment, *ppCStr) != RS_RET_OK) {
					 pThis-&gt;prevLineSegment = NULL;
				}
			}
			cstrDestruct(ppCStr);
		}
	}
	RETiRet;
}
int
strmReadMultiLine_isTimedOut(const strm_t *const __restrict__ pThis)
{
	DBGPRINTF("strmReadMultiline_isTimedOut: prevMsgSeg %p, readTimeout %d, "
		"lastRead %lld\n", pThis-&gt;prevMsgSegment, pThis-&gt;readTimeout,
		(long long) pThis-&gt;lastRead);
	return(   (pThis-&gt;readTimeout)
	       &amp;&amp; (pThis-&gt;prevMsgSegment != NULL)
	       &amp;&amp; (getTime(NULL) &gt; pThis-&gt;lastRead + pThis-&gt;readTimeout) );
}
rsRetVal ATTR_NONNULL(1,2)
strmReadMultiLine(strm_t *pThis, cstr_t **ppCStr, regex_t *start_preg, regex_t *end_preg, const sbool bEscapeLF,
	const uchar *const escapeLFString, const sbool discardTruncatedMsg, const sbool msgDiscardingError,
	int64 *const strtOffs)
{
	uchar c;
	uchar finished = 0;
	cstr_t *thisLine = NULL;
	rsRetVal readCharRet;
	const time_t tCurr = pThis-&gt;readTimeout ? getTime(NULL) : 0;
	int maxMsgSize = glblGetMaxLine(runConf);
	DEFiRet;
	do {
		CHKiRet(strmReadChar(pThis, &amp;c)); 		pThis-&gt;lastRead = tCurr;
		CHKiRet(cstrConstruct(&amp;thisLine));
		if(pThis-&gt;prevLineSegment != NULL) {
			CHKiRet(cstrAppendCStr(thisLine, pThis-&gt;prevLineSegment));
			cstrDestruct(&amp;pThis-&gt;prevLineSegment);
		}
		while(c != '\n') {
			CHKiRet(cstrAppendChar(thisLine, c));
			readCharRet = strmReadChar(pThis, &amp;c);
			if(readCharRet == RS_RET_EOF) {				CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevLineSegment, thisLine));
			}
			CHKiRet(readCharRet);
		}
		cstrFinalize(thisLine);
		const int isStartMatch = start_preg ?
				!regexec(start_preg, (char*)rsCStrGetSzStrNoNULL(thisLine), 0, NULL, 0) :
				0;
		const int isEndMatch = end_preg ?
				!regexec(end_preg, (char*)rsCStrGetSzStrNoNULL(thisLine), 0, NULL, 0) :
				0;
		if(isStartMatch) {
			if(pThis-&gt;ignoringMsg == 0) {
				if(pThis-&gt;prevMsgSegment != NULL) {
					finished = 1;
					*ppCStr = pThis-&gt;prevMsgSegment;
				}
			}
			CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevMsgSegment, thisLine));
			pThis-&gt;ignoringMsg = 0;
		} else {
			if(pThis-&gt;ignoringMsg == 0) {
				if(pThis-&gt;prevMsgSegment == NULL) {
					CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevMsgSegment, thisLine));
				} else {
					if(bEscapeLF) {
						if(escapeLFString == NULL) {
							rsCStrAppendStrWithLen(pThis-&gt;prevMsgSegment, (uchar*)"\\n", 2);
						} else {
							rsCStrAppendStr(pThis-&gt;prevMsgSegment, escapeLFString);
						}
					} else {
						cstrAppendChar(pThis-&gt;prevMsgSegment, '\n');
					}
					int currLineLen = cstrLen(thisLine);
					if(currLineLen &gt; 0) {
						int len;
						if((len = cstrLen(pThis-&gt;prevMsgSegment) + currLineLen) &lt;
						maxMsgSize) {
							CHKiRet(cstrAppendCStr(pThis-&gt;prevMsgSegment, thisLine));
						} else {
							if (cstrLen(pThis-&gt;prevMsgSegment) &gt; maxMsgSize) {
								len = 0;
							} else {
								len = currLineLen-(len-maxMsgSize);
								for(int z=0; z&lt;len; z++) {
									cstrAppendChar(pThis-&gt;prevMsgSegment,
										thisLine-&gt;pBuf[z]);
								}
							}
							finished = 1;
							*ppCStr = pThis-&gt;prevMsgSegment;
							CHKiRet(rsCStrConstructFromszStr(&amp;pThis-&gt;prevMsgSegment,
								thisLine-&gt;pBuf+len));
							if(discardTruncatedMsg == 1) {
								pThis-&gt;ignoringMsg = 1;
							}
							if(msgDiscardingError == 1) {
								if(discardTruncatedMsg == 1) {
									LogError(0, RS_RET_ERR,
									"imfile error: message received is "
									"larger than max msg size; "
									"rest of message will not be "
									"processed");
								} else {
									LogError(0, RS_RET_ERR,
									"imfile error: message received is "
									"larger than max msg size; message "
									"will be split and processed as "
									"another message");
								}
							}
						}
					}
				}
			}
		}
		if(isEndMatch) {
			if(pThis-&gt;ignoringMsg == 0) {
				if(pThis-&gt;prevMsgSegment != NULL) {
					finished = 1;
					*ppCStr = pThis-&gt;prevMsgSegment;
					pThis-&gt;prevMsgSegment= NULL;
				}
			}
			pThis-&gt;ignoringMsg = 0;
		}
		cstrDestruct(&amp;thisLine);
	} while(finished == 0);
finalize_it:
	*strtOffs = pThis-&gt;strtOffs;
	if(thisLine != NULL) {
		cstrDestruct(&amp;thisLine);
	}
	if(iRet == RS_RET_OK) {
		pThis-&gt;strtOffs = pThis-&gt;iCurrOffs; 		cstrFinalize(*ppCStr);
	} else {
		if(   pThis-&gt;readTimeout
		   &amp;&amp; (pThis-&gt;prevMsgSegment != NULL)
		   &amp;&amp; (tCurr &gt; pThis-&gt;lastRead + pThis-&gt;readTimeout)) {
			if(rsCStrConstructFromCStr(ppCStr, pThis-&gt;prevMsgSegment) == RS_RET_OK) {
				cstrFinalize(*ppCStr);
				cstrDestruct(&amp;pThis-&gt;prevMsgSegment);
				pThis-&gt;lastRead = tCurr;
				pThis-&gt;strtOffs = pThis-&gt;iCurrOffs; 				dbgprintf("stream: generated msg based on timeout: %s\n",
					cstrGetSzStrNoNULL(*ppCStr));
				iRet = RS_RET_OK;
			}
		}
	}
	RETiRet;
}
BEGINobjConstruct(strm) 	pThis-&gt;iCurrFNum = 1;
	pThis-&gt;fd = -1;
	pThis-&gt;fdDir = -1;
	pThis-&gt;iUngetC = -1;
	pThis-&gt;bVeryReliableZip = 0;
	pThis-&gt;sType = STREAMTYPE_FILE_SINGLE;
	pThis-&gt;sIOBufSize = glblGetIOBufSize();
	pThis-&gt;tOpenMode = 0600;
	pThis-&gt;pszSizeLimitCmd = NULL;
	pThis-&gt;prevLineSegment = NULL;
	pThis-&gt;prevMsgSegment = NULL;
	pThis-&gt;strtOffs = 0;
	pThis-&gt;ignoringMsg = 0;
	pThis-&gt;bPrevWasNL = 0;
	pThis-&gt;fileNotFoundError = 1;
	pThis-&gt;noRepeatedErrorOutput = 0;
	pThis-&gt;lastRead = getTime(NULL);
ENDobjConstruct(strm)
static rsRetVal strmConstructFinalize(strm_t *pThis)
{
	pthread_mutexattr_t mutAttr;
	rsRetVal localRet;
	int i;
	DEFiRet;
	assert(pThis != NULL);
	pThis-&gt;iBufPtrMax = 0; 	if(pThis-&gt;iZipLevel) { 		localRet = objUse(zlibw, LM_ZLIBW_FILENAME);
		if(localRet != RS_RET_OK) {
			pThis-&gt;iZipLevel = 0;
			DBGPRINTF("stream was requested with zip mode, but zlibw module unavailable (%d) - using "
				  "without zip\n", localRet);
		} else {
			CHKmalloc(pThis-&gt;pZipBuf = (Bytef*) malloc(pThis-&gt;sIOBufSize + 128));
		}
	}
	if(pThis-&gt;bSync &amp;&amp; !pThis-&gt;bIsTTY &amp;&amp; pThis-&gt;pszDir != NULL) {
		pThis-&gt;fdDir = open((char*)pThis-&gt;pszDir, O_RDONLY | O_CLOEXEC | O_NOCTTY);
		if(pThis-&gt;fdDir == -1) {
			char errStr[1024];
			int err = errno;
			rs_strerror_r(err, errStr, sizeof(errStr));
			DBGPRINTF("error %d opening directory file for fsync() use - fsync for directory "
				"disabled: %s\n", errno, errStr);
		}
	}
	if(pThis-&gt;iFlushInterval != 0) {
		pThis-&gt;bAsyncWrite = 1;
	}
	DBGPRINTF("file stream %s params: flush interval %d, async write %d\n",
		  getFileDebugName(pThis),
		  pThis-&gt;iFlushInterval, pThis-&gt;bAsyncWrite);
	if(pThis-&gt;bAsyncWrite) {
		pthread_mutexattr_init(&amp;mutAttr);
		pthread_mutexattr_settype(&amp;mutAttr, PTHREAD_MUTEX_RECURSIVE);
		pthread_mutex_init(&amp;pThis-&gt;mut, &amp;mutAttr);
		pthread_cond_init(&amp;pThis-&gt;notFull, 0);
		pthread_cond_init(&amp;pThis-&gt;notEmpty, 0);
		pthread_cond_init(&amp;pThis-&gt;isEmpty, 0);
		pThis-&gt;iCnt = pThis-&gt;iEnq = pThis-&gt;iDeq = 0;
		for(i = 0 ; i &lt; STREAM_ASYNC_NUMBUFS ; ++i) {
			CHKmalloc(pThis-&gt;asyncBuf[i].pBuf = (uchar*) malloc(pThis-&gt;sIOBufSize));
		}
		pThis-&gt;pIOBuf = pThis-&gt;asyncBuf[0].pBuf;
		pThis-&gt;bStopWriter = 0;
		if(pthread_create(&amp;pThis-&gt;writerThreadID,
			    	  &amp;default_thread_attr,
				  asyncWriterThread, pThis) != 0)
			DBGPRINTF("ERROR: stream %p cold not create writer thread\n", pThis);
	} else {
		CHKmalloc(pThis-&gt;pIOBuf = (uchar*) malloc(pThis-&gt;sIOBufSize));
		CHKmalloc(pThis-&gt;pIOBuf_truncation = (char*) malloc(pThis-&gt;sIOBufSize));
	}
finalize_it:
	RETiRet;
}
BEGINobjDestruct(strm) 	int i;
CODESTARTobjDestruct(strm)
	if(pThis-&gt;bAsyncWrite)
		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
	strmCloseFile(pThis);
	if(pThis-&gt;bAsyncWrite) {
		pthread_mutex_destroy(&amp;pThis-&gt;mut);
		pthread_cond_destroy(&amp;pThis-&gt;notFull);
		pthread_cond_destroy(&amp;pThis-&gt;notEmpty);
		pthread_cond_destroy(&amp;pThis-&gt;isEmpty);
		for(i = 0 ; i &lt; STREAM_ASYNC_NUMBUFS ; ++i) {
			free(pThis-&gt;asyncBuf[i].pBuf);
		}
	} else {
		free(pThis-&gt;pIOBuf);
		free(pThis-&gt;pIOBuf_truncation);
	}
	if(pThis-&gt;prevLineSegment)
		cstrDestruct(&amp;pThis-&gt;prevLineSegment);
	if(pThis-&gt;prevMsgSegment)
		cstrDestruct(&amp;pThis-&gt;prevMsgSegment);
	free(pThis-&gt;pszDir);
	free(pThis-&gt;pZipBuf);
	free(pThis-&gt;pszCurrFName);
	free(pThis-&gt;pszFName);
	free(pThis-&gt;pszSizeLimitCmd);
	pThis-&gt;bStopWriter = 2; ENDobjDestruct(strm)
static rsRetVal strmCheckNextOutputFile(strm_t *pThis)
{
	DEFiRet;
	if(pThis-&gt;fd == -1 || pThis-&gt;sType != STREAMTYPE_FILE_CIRCULAR)
		FINALIZE;
	strmWaitAsyncWriterDone(pThis);
	if(pThis-&gt;iCurrOffs &gt;= pThis-&gt;iMaxFileSize) {
		DBGOPRINT((obj_t*) pThis, "max file size %ld reached for %d, now %ld - starting new file\n",
			  (long) pThis-&gt;iMaxFileSize, pThis-&gt;fd, (long) pThis-&gt;iCurrOffs);
		CHKiRet(strmNextFile(pThis));
	}
finalize_it:
	RETiRet;
}
#ifdef linux
#	define ERR_TTYHUP EIO
#else
#	define ERR_TTYHUP EBADF
#endif
static rsRetVal
tryTTYRecover(strm_t *pThis, int err)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
#ifndef __FreeBSD__
	if(err == ERR_TTYHUP) {
#else
	if(err == ERR_TTYHUP || err == ENXIO || err == EIO) {
#endif 		close(pThis-&gt;fd);
		pThis-&gt;fd = -1;
		CHKiRet(doPhysOpen(pThis));
	}
finalize_it:
	RETiRet;
}
#undef ER_TTYHUP
static rsRetVal ATTR_NONNULL(1,2,3)
doWriteCall(strm_t *pThis, uchar *pBuf, size_t *pLenBuf)
{
	ssize_t lenBuf;
	ssize_t iTotalWritten;
	ssize_t iWritten;
	char *pWriteBuf;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
#ifdef __FreeBSD__
	sbool crnlNow = 0;
#endif 
	lenBuf = *pLenBuf;
	pWriteBuf = (char*) pBuf;
	iTotalWritten = 0;
	do {
		#ifdef __FreeBSD__
		if (pThis-&gt;bIsTTY &amp;&amp; !pThis-&gt;iZipLevel &amp;&amp; !pThis-&gt;cryprov) {
			char *pNl = NULL;
			if (crnlNow == 0) pNl = strchr(pWriteBuf, '\n');
			else crnlNow = 0;
			if (pNl == pWriteBuf) {
				iWritten = write(pThis-&gt;fd, "\r", 1);
				if (iWritten &gt; 0) {
					crnlNow = 1;
					iWritten = 0;
				}
			} else iWritten = write(pThis-&gt;fd, pWriteBuf, pNl ? pNl - pWriteBuf : lenBuf);
		} else
		#endif 		iWritten = write(pThis-&gt;fd, pWriteBuf, lenBuf);
		if(iWritten &lt; 0) {
			const int err = errno;
			iWritten = 0; 			if(err == EBADF) {
				LogError(err, RS_RET_IO_ERROR, "file %s: fd %d no longer valid, recovery by "
					"reopen; if you see this, consider reporting at "
					"https://github.com/rsyslog/rsyslog/issues/3404 "
					"so that we know when it happens. Include output of uname -a. "
					"OS error reason", pThis-&gt;pszCurrFName, pThis-&gt;fd);
				pThis-&gt;fd = -1;
				CHKiRet(doPhysOpen(pThis));
			} else {
				if(err != EINTR) {
					LogError(err, RS_RET_IO_ERROR, "file '%s'[%d] write error - see "
						"https://www.rsyslog.com/solving-rsyslog-write-errors/ for help "
						"OS error", pThis-&gt;pszCurrFName, pThis-&gt;fd);
				}
				if(err == EINTR) {
				} else if( !pThis-&gt;bIsTTY &amp;&amp; ( err == ENOTCONN || err == EIO )) {
					close(pThis-&gt;fd);
					pThis-&gt;fd = -1;
					CHKiRet(doPhysOpen(pThis));
				} else {
					if(pThis-&gt;bIsTTY) {
						CHKiRet(tryTTYRecover(pThis, err));
					} else {
						ABORT_FINALIZE(RS_RET_IO_ERROR);
					}
				}
			}
	 	}
		iTotalWritten += iWritten;
		lenBuf -= iWritten;
		pWriteBuf += iWritten;
	} while(lenBuf &gt; 0);	
	DBGOPRINT((obj_t*) pThis, "file %d write wrote %d bytes\n", pThis-&gt;fd, (int) iWritten);
finalize_it:
	*pLenBuf = iTotalWritten;
	RETiRet;
}
static rsRetVal
doWriteInternal(strm_t *pThis, uchar *pBuf, const size_t lenBuf, const int bFlush)
{
	DEFiRet;
	DBGOPRINT((obj_t*) pThis, "file %d(%s) doWriteInternal: bFlush %d\n",
		pThis-&gt;fd, getFileDebugName(pThis), bFlush);
	if(pThis-&gt;iZipLevel) {
		CHKiRet(doZipWrite(pThis, pBuf, lenBuf, bFlush));
	} else {
		CHKiRet(strmPhysWrite(pThis, pBuf, lenBuf));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
doAsyncWriteInternal(strm_t *pThis, size_t lenBuf, const int bFlushZip)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	DBGOPRINT((obj_t*) pThis, "file %d(%s) doAsyncWriteInternal at begin: "
		"iCnt %d, iEnq %d, bFlushZip %d\n",
		pThis-&gt;fd, getFileDebugName(pThis),
		pThis-&gt;iCnt, pThis-&gt;iEnq, bFlushZip);
	while(pThis-&gt;iCnt &gt;= STREAM_ASYNC_NUMBUFS - 1)
		d_pthread_cond_wait(&amp;pThis-&gt;notFull, &amp;pThis-&gt;mut);
	pThis-&gt;asyncBuf[pThis-&gt;iEnq % STREAM_ASYNC_NUMBUFS].lenBuf = lenBuf;
	pThis-&gt;pIOBuf = pThis-&gt;asyncBuf[++pThis-&gt;iEnq % STREAM_ASYNC_NUMBUFS].pBuf;
	if(!pThis-&gt;bFlushNow) 		pThis-&gt;bFlushNow = bFlushZip;
	pThis-&gt;bDoTimedWait = 0; 	if(++pThis-&gt;iCnt == 1) {
		pthread_cond_signal(&amp;pThis-&gt;notEmpty);
		DBGOPRINT((obj_t*) pThis, "doAsyncWriteInternal signaled notEmpty\n");
	}
	DBGOPRINT((obj_t*) pThis, "file %d(%s) doAsyncWriteInternal at exit: "
		"iCnt %d, iEnq %d, bFlushZip %d\n",
		pThis-&gt;fd, getFileDebugName(pThis),
		pThis-&gt;iCnt, pThis-&gt;iEnq, bFlushZip);
	RETiRet;
}
static rsRetVal
strmSchedWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf, const int bFlushZip)
{
	DEFiRet;
	assert(pThis != NULL);
	pThis-&gt;iBufPtr = 0; 	if(pThis-&gt;bAsyncWrite) {
		CHKiRet(doAsyncWriteInternal(pThis, lenBuf, bFlushZip));
	} else {
		CHKiRet(doWriteInternal(pThis, pBuf, lenBuf, bFlushZip));
	}
finalize_it:
	RETiRet;
}
static void*
asyncWriterThread(void *pPtr)
{
	int iDeq;
	struct timespec t;
	sbool bTimedOut = 0;
	strm_t *pThis = (strm_t*) pPtr;
	int err;
	uchar thrdName[256] = "rs:";
	ISOBJ_TYPE_assert(pThis, strm);
	ustrncpy(thrdName+3, pThis-&gt;pszFName, sizeof(thrdName)-4);
	dbgOutputTID((char*)thrdName);
#	if defined(HAVE_PRCTL) &amp;&amp; defined(PR_SET_NAME)
	if(prctl(PR_SET_NAME, (char*)thrdName, 0, 0, 0) != 0) {
		DBGPRINTF("prctl failed, not setting thread name for '%s'\n", "stream writer");
	}
#	endif
	d_pthread_mutex_lock(&amp;pThis-&gt;mut);
	while(1) { 		while(pThis-&gt;iCnt == 0) {
			DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread new iteration, "
				  "iCnt %d, bTimedOut %d, iFlushInterval %d\n", pThis-&gt;fd,
				  getFileDebugName(pThis),
				  pThis-&gt;iCnt, bTimedOut, pThis-&gt;iFlushInterval);
			if(pThis-&gt;bStopWriter) {
				pthread_cond_broadcast(&amp;pThis-&gt;isEmpty);
				d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
				goto finalize_it; 			}
			if(bTimedOut &amp;&amp; pThis-&gt;iBufPtr &gt; 0) {
				strmFlushInternal(pThis, 1);
				bTimedOut = 0;
				continue;
			}
			bTimedOut = 0;
			if(pThis-&gt;bDoTimedWait) {
				timeoutComp(&amp;t, pThis-&gt;iFlushInterval * 1000); 				if((err = pthread_cond_timedwait(&amp;pThis-&gt;notEmpty, &amp;pThis-&gt;mut, &amp;t)) != 0) {
					DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread timed out\n",
						  pThis-&gt;fd, getFileDebugName(pThis));
					bTimedOut = 1; 					if(err != ETIMEDOUT) {
						char errStr[1024];
						rs_strerror_r(err, errStr, sizeof(errStr));
						DBGPRINTF("stream async writer timeout with error (%d): %s - "
							"ignoring\n", err, errStr);
					}
				}
			} else {
				d_pthread_cond_wait(&amp;pThis-&gt;notEmpty, &amp;pThis-&gt;mut);
			}
		}
		DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread awoken, "
			  "iCnt %d, bTimedOut %d\n", pThis-&gt;fd, getFileDebugName(pThis),
			  pThis-&gt;iCnt, bTimedOut);
		bTimedOut = 0; 
		iDeq = pThis-&gt;iDeq++ % STREAM_ASYNC_NUMBUFS;
		const int bFlush = (pThis-&gt;bFlushNow || bTimedOut) ? 1 : 0;
		pThis-&gt;bFlushNow = 0;
		d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
		doWriteInternal(pThis, pThis-&gt;asyncBuf[iDeq].pBuf, pThis-&gt;asyncBuf[iDeq].lenBuf, bFlush);
		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
		--pThis-&gt;iCnt;
		if(pThis-&gt;iCnt &lt; STREAM_ASYNC_NUMBUFS) {
			pthread_cond_signal(&amp;pThis-&gt;notFull);
			if(pThis-&gt;iCnt == 0)
				pthread_cond_broadcast(&amp;pThis-&gt;isEmpty);
		}
	}
finalize_it:
	DBGOPRINT((obj_t*) pThis, "file %d(%s) asyncWriterThread terminated\n",
		pThis-&gt;fd, getFileDebugName(pThis));
	return NULL; }
#undef SYNCCALL
#if defined(HAVE_FDATASYNC) &amp;&amp; !defined(__APPLE__)
#	define SYNCCALL(x) fdatasync(x)
#else
#	define SYNCCALL(x) fsync(x)
#endif
static rsRetVal
syncFile(strm_t *pThis)
{
	int ret;
	DEFiRet;
	if(pThis-&gt;bIsTTY)
		FINALIZE; 
	DBGPRINTF("syncing file %d\n", pThis-&gt;fd);
	ret = SYNCCALL(pThis-&gt;fd);
	if(ret != 0) {
		char errStr[1024];
		int err = errno;
		rs_strerror_r(err, errStr, sizeof(errStr));
		DBGPRINTF("sync failed for file %d with error (%d): %s - ignoring\n",
			   pThis-&gt;fd, err, errStr);
	}
	if(pThis-&gt;fdDir != -1) {
		if(fsync(pThis-&gt;fdDir) != 0)
			DBGPRINTF("stream/syncFile: fsync returned error, ignoring\n");
	}
finalize_it:
	RETiRet;
}
#undef SYNCCALL
static rsRetVal
strmPhysWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf)
{
	size_t iWritten;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	DBGPRINTF("strmPhysWrite, stream %p, len %u\n", pThis, (unsigned)lenBuf);
	if(pThis-&gt;fd == -1)
		CHKiRet(strmOpenFile(pThis));
	if(pThis-&gt;cryprov != NULL) {
		pThis-&gt;cryprov-&gt;Encrypt(pThis-&gt;cryprovFileData, pBuf, &amp;lenBuf);
	}
	iWritten = lenBuf;
	CHKiRet(doWriteCall(pThis, pBuf, &amp;iWritten));
	pThis-&gt;iCurrOffs += iWritten;
	if(pThis-&gt;pUsrWCntr != NULL)
		*pThis-&gt;pUsrWCntr += iWritten;
	if(pThis-&gt;bSync) {
		CHKiRet(syncFile(pThis));
	}
	if(pThis-&gt;sType == STREAMTYPE_FILE_CIRCULAR) {
		CHKiRet(strmCheckNextOutputFile(pThis));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
doZipWrite(strm_t *pThis, uchar *pBuf, size_t lenBuf, const int bFlush)
{
	int zRet;		DEFiRet;
	unsigned outavail = 0;
	assert(pThis != NULL);
	assert(pBuf != NULL);
	if(!pThis-&gt;bzInitDone) {
		pThis-&gt;zstrm.zalloc = Z_NULL;
		pThis-&gt;zstrm.zfree = Z_NULL;
		pThis-&gt;zstrm.opaque = Z_NULL;
		zRet = zlibw.DeflateInit2(&amp;pThis-&gt;zstrm, pThis-&gt;iZipLevel, Z_DEFLATED, 31, 9, Z_DEFAULT_STRATEGY);
		if(zRet != Z_OK) {
			LogError(0, RS_RET_ZLIB_ERR, "error %d returned from zlib/deflateInit2()", zRet);
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		}
		pThis-&gt;bzInitDone = RSTRUE;
	}
	pThis-&gt;zstrm.next_in = (Bytef*) pBuf;
	pThis-&gt;zstrm.avail_in = lenBuf;
	do {
		DBGPRINTF("in deflate() loop, avail_in %d, total_in %ld, bFlush %d\n",
			pThis-&gt;zstrm.avail_in, pThis-&gt;zstrm.total_in, bFlush);
		pThis-&gt;zstrm.avail_out = pThis-&gt;sIOBufSize;
		pThis-&gt;zstrm.next_out = pThis-&gt;pZipBuf;
		zRet = zlibw.Deflate(&amp;pThis-&gt;zstrm, bFlush ? Z_SYNC_FLUSH : Z_NO_FLUSH);    		DBGPRINTF("after deflate, ret %d, avail_out %d, to write %d\n",
			zRet, pThis-&gt;zstrm.avail_out, outavail);
		if(zRet != Z_OK) {
			LogError(0, RS_RET_ZLIB_ERR, "error %d returned from zlib/Deflate()", zRet);
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		}
		outavail = pThis-&gt;sIOBufSize - pThis-&gt;zstrm.avail_out;
		if(outavail != 0) {
			CHKiRet(strmPhysWrite(pThis, (uchar*)pThis-&gt;pZipBuf, outavail));
		}
	} while (pThis-&gt;zstrm.avail_out == 0);
finalize_it:
	if(pThis-&gt;bzInitDone &amp;&amp; pThis-&gt;bVeryReliableZip) {
		doZipFinish(pThis);
	}
	RETiRet;
}
static rsRetVal
doZipFinish(strm_t *pThis)
{
	int zRet;		DEFiRet;
	unsigned outavail;
	assert(pThis != NULL);
	if(!pThis-&gt;bzInitDone)
		goto done;
	pThis-&gt;zstrm.avail_in = 0;
	do {
		DBGPRINTF("in deflate() loop, avail_in %d, total_in %ld\n", pThis-&gt;zstrm.avail_in,
			pThis-&gt;zstrm.total_in);
		pThis-&gt;zstrm.avail_out = pThis-&gt;sIOBufSize;
		pThis-&gt;zstrm.next_out = pThis-&gt;pZipBuf;
		zRet = zlibw.Deflate(&amp;pThis-&gt;zstrm, Z_FINISH);    		DBGPRINTF("after deflate, ret %d, avail_out %d\n", zRet, pThis-&gt;zstrm.avail_out);
		outavail = pThis-&gt;sIOBufSize - pThis-&gt;zstrm.avail_out;
		if(outavail != 0) {
			CHKiRet(strmPhysWrite(pThis, (uchar*)pThis-&gt;pZipBuf, outavail));
		}
	} while (pThis-&gt;zstrm.avail_out == 0);
finalize_it:
	zRet = zlibw.DeflateEnd(&amp;pThis-&gt;zstrm);
	if(zRet != Z_OK) {
		LogError(0, RS_RET_ZLIB_ERR, "error %d returned from zlib/deflateEnd()", zRet);
	}
	pThis-&gt;bzInitDone = 0;
done:	RETiRet;
}
static rsRetVal
strmFlushInternal(strm_t *pThis, int bFlushZip)
{
	DEFiRet;
	assert(pThis != NULL);
	DBGOPRINT((obj_t*) pThis, "strmFlushinternal: file %d(%s) flush, buflen %ld%s\n", pThis-&gt;fd,
		  getFileDebugName(pThis),
		  (long) pThis-&gt;iBufPtr, (pThis-&gt;iBufPtr == 0) ? " (no need to flush)" : "");
	if(pThis-&gt;tOperationsMode != STREAMMODE_READ &amp;&amp; pThis-&gt;iBufPtr &gt; 0) {
		iRet = strmSchedWrite(pThis, pThis-&gt;pIOBuf, pThis-&gt;iBufPtr, bFlushZip);
	}
	RETiRet;
}
static rsRetVal
strmFlush(strm_t *pThis)
{
	DEFiRet;
	assert(pThis != NULL);
	DBGOPRINT((obj_t*) pThis, "file %d strmFlush\n", pThis-&gt;fd);
	if(pThis-&gt;bAsyncWrite)
		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
	CHKiRet(strmFlushInternal(pThis, 1));
finalize_it:
	if(pThis-&gt;bAsyncWrite)
		d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
strmSeek(strm_t *pThis, const off64_t offs)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	if(pThis-&gt;fd == -1) {
		CHKiRet(strmOpenFile(pThis));
	} else {
		CHKiRet(strmFlushInternal(pThis, 0));
	}
	DBGOPRINT((obj_t*) pThis, "file %d seek, pos %llu\n", pThis-&gt;fd, (long long unsigned) offs);
	const off64_t i = lseek64(pThis-&gt;fd, offs, SEEK_SET);
	if(i != offs) {
		LogError(errno, RS_RET_IO_ERROR, "file %s: unexpected error seeking to "
			"offset %lld (ret %lld) - further malfunctions may happen",
			pThis-&gt;pszCurrFName, (long long) i, (long long) offs);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}
	pThis-&gt;strtOffs = pThis-&gt;iCurrOffs = offs; 	pThis-&gt;iBufPtr = 0; 
finalize_it:
	RETiRet;
}
rsRetVal
strmMultiFileSeek(strm_t *pThis, unsigned int FNum, off64_t offs, off64_t *bytesDel)
{
	struct stat statBuf;
	int skipped_files;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	if(FNum == 0 &amp;&amp; offs == 0) { 		*bytesDel = 0;
		FINALIZE;
	}
	skipped_files = FNum - pThis-&gt;iCurrFNum;
	*bytesDel = 0;
	while(skipped_files &gt; 0) {
		CHKiRet(genFileName(&amp;pThis-&gt;pszCurrFName, pThis-&gt;pszDir, pThis-&gt;lenDir,
				    pThis-&gt;pszFName, pThis-&gt;lenFName, pThis-&gt;iCurrFNum,
				    pThis-&gt;iFileNumDigits));
		dbgprintf("rger: processing file %s\n", pThis-&gt;pszCurrFName);
		if(stat((char*)pThis-&gt;pszCurrFName, &amp;statBuf) != 0) {
			LogError(errno, RS_RET_IO_ERROR, "unexpected error doing a stat() "
				"on file %s - further malfunctions may happen",
				pThis-&gt;pszCurrFName);
		}
		*bytesDel += statBuf.st_size;
		DBGPRINTF("strmMultiFileSeek: detected new filenum, was %u, new %u, "
			  "deleting '%s' (%lld bytes)\n", pThis-&gt;iCurrFNum, FNum,
			  pThis-&gt;pszCurrFName, (long long) statBuf.st_size);
		unlink((char*)pThis-&gt;pszCurrFName);
		if(pThis-&gt;cryprov != NULL)
			pThis-&gt;cryprov-&gt;DeleteStateFiles(pThis-&gt;pszCurrFName);
		free(pThis-&gt;pszCurrFName);
		pThis-&gt;pszCurrFName = NULL;
		pThis-&gt;iCurrFNum++;
		--skipped_files;
	}
	DBGOPRINT((obj_t*) pThis, "strmMultiFileSeek: deleted %lld bytes in this run\n",
		(long long) *bytesDel);
	pThis-&gt;strtOffs = pThis-&gt;iCurrOffs = offs;
finalize_it:
	RETiRet;
}
static rsRetVal strmSeekCurrOffs(strm_t *pThis)
{
	off64_t targetOffs;
	uchar c;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	if(pThis-&gt;cryprov == NULL || pThis-&gt;tOperationsMode != STREAMMODE_READ) {
		iRet = strmSeek(pThis, pThis-&gt;iCurrOffs);
		FINALIZE;
	}
	targetOffs = pThis-&gt;iCurrOffs;
	pThis-&gt;strtOffs = pThis-&gt;iCurrOffs = 0;
	DBGOPRINT((obj_t*) pThis, "encrypted, doing skip read of %lld bytes\n",
		(long long) targetOffs);
	while(targetOffs != pThis-&gt;iCurrOffs) {
		CHKiRet(strmReadChar(pThis, &amp;c));
	}
finalize_it:
	RETiRet;
}
static rsRetVal strmWriteChar(strm_t *__restrict__ const pThis, const uchar c)
{
	DEFiRet;
	assert(pThis != NULL);
	if(pThis-&gt;bAsyncWrite)
		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
	if(pThis-&gt;bDisabled)
		ABORT_FINALIZE(RS_RET_STREAM_DISABLED);
	if(pThis-&gt;iBufPtr == pThis-&gt;sIOBufSize) {
		CHKiRet(strmFlushInternal(pThis, 0));
	}
	*(pThis-&gt;pIOBuf + pThis-&gt;iBufPtr) = c;
	pThis-&gt;iBufPtr++;
finalize_it:
	if(pThis-&gt;bAsyncWrite)
		d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
	RETiRet;
}
static rsRetVal strmWriteLong(strm_t *__restrict__ const pThis, const long i)
{
	DEFiRet;
	uchar szBuf[32];
	assert(pThis != NULL);
	CHKiRet(srUtilItoA((char*)szBuf, sizeof(szBuf), i));
	CHKiRet(strmWrite(pThis, szBuf, strlen((char*)szBuf)));
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL(1,2)
strmWrite(strm_t *__restrict__ const pThis, const uchar *__restrict__ const pBuf, size_t lenBuf)
{
	DEFiRet;
	size_t iWrite;
	size_t iOffset;
	assert(pThis != NULL);
	assert(pBuf != NULL);
	if(pThis-&gt;bDisabled)
		ABORT_FINALIZE(RS_RET_STREAM_DISABLED);
	if(pThis-&gt;bAsyncWrite)
		d_pthread_mutex_lock(&amp;pThis-&gt;mut);
	iOffset = 0;
	do {
		if(pThis-&gt;iBufPtr == pThis-&gt;sIOBufSize) {
			CHKiRet(strmFlushInternal(pThis, 0)); 		}
		iWrite = pThis-&gt;sIOBufSize - pThis-&gt;iBufPtr; 		if(iWrite &gt; lenBuf)
			iWrite = lenBuf;
		memcpy(pThis-&gt;pIOBuf + pThis-&gt;iBufPtr, pBuf + iOffset, iWrite);
		pThis-&gt;iBufPtr += iWrite;
		iOffset += iWrite;
		lenBuf -= iWrite;
	} while(lenBuf &gt; 0);
	if(pThis-&gt;iBufPtr == pThis-&gt;sIOBufSize) {
		CHKiRet(strmFlushInternal(pThis, 0)); 	}
	if(pThis-&gt;fd != -1 &amp;&amp; pThis-&gt;iSizeLimit != 0) { 		CHKiRet(doSizeLimitProcessing(pThis));
	}
finalize_it:
	if(pThis-&gt;bAsyncWrite) {
		if(pThis-&gt;bDoTimedWait == 0) {
			pThis-&gt;bDoTimedWait = 1;
			pthread_cond_signal(&amp;pThis-&gt;notEmpty);
		}
		d_pthread_mutex_unlock(&amp;pThis-&gt;mut);
	}
	RETiRet;
}
DEFpropSetMeth(strm, iMaxFileSize, int64)
DEFpropSetMeth(strm, iFileNumDigits, int)
DEFpropSetMeth(strm, tOperationsMode, int)
DEFpropSetMeth(strm, tOpenMode, mode_t)
DEFpropSetMeth(strm, sType, strmType_t)
DEFpropSetMeth(strm, iZipLevel, int)
DEFpropSetMeth(strm, bVeryReliableZip, int)
DEFpropSetMeth(strm, bSync, int)
DEFpropSetMeth(strm, bReopenOnTruncate, int)
DEFpropSetMeth(strm, sIOBufSize, size_t)
DEFpropSetMeth(strm, iSizeLimit, off_t)
DEFpropSetMeth(strm, iFlushInterval, int)
DEFpropSetMeth(strm, pszSizeLimitCmd, uchar*)
DEFpropSetMeth(strm, cryprov, cryprov_if_t*)
DEFpropSetMeth(strm, cryprovData, void*)
void ATTR_NONNULL()
strmSetReadTimeout(strm_t *const __restrict__ pThis, const int val)
{
	ISOBJ_TYPE_assert(pThis, strm);
	pThis-&gt;readTimeout = val;
}
void ATTR_NONNULL()
strmSet_checkRotation(strm_t *const pThis, const int val) {
	ISOBJ_TYPE_assert(pThis, strm);
	assert(val == STRM_ROTATION_DO_CHECK || val == STRM_ROTATION_DO_NOT_CHECK);
	pThis-&gt;rotationCheck = val;
}
static rsRetVal ATTR_NONNULL()
strmSetbDeleteOnClose(strm_t *const pThis, const int val)
{
	ISOBJ_TYPE_assert(pThis, strm);
	pThis-&gt;bDeleteOnClose = val;
	if(pThis-&gt;cryprov != NULL) {
		pThis-&gt;cryprov-&gt;SetDeleteOnClose(pThis-&gt;cryprovFileData, pThis-&gt;bDeleteOnClose);
	}
	return RS_RET_OK;
}
static rsRetVal ATTR_NONNULL()
strmSetiMaxFiles(strm_t *const pThis, const int iNewVal)
{
	ISOBJ_TYPE_assert(pThis, strm);
	pThis-&gt;iMaxFiles = iNewVal;
	pThis-&gt;iFileNumDigits = getNumberDigits(iNewVal);
	return RS_RET_OK;
}
static rsRetVal ATTR_NONNULL()
strmSetFileNotFoundError(strm_t *const pThis, const int pFileNotFoundError)
{
	ISOBJ_TYPE_assert(pThis, strm);
	pThis-&gt;fileNotFoundError = pFileNotFoundError;
	return RS_RET_OK;
}
static rsRetVal
strmSetFName(strm_t *pThis, uchar *pszName, size_t iLenName)
{
	DEFiRet;
	assert(pThis != NULL);
	assert(pszName != NULL);
	if(iLenName &lt; 1)
		ABORT_FINALIZE(RS_RET_FILE_PREFIX_MISSING);
	if(pThis-&gt;pszFName != NULL)
		free(pThis-&gt;pszFName);
	if((pThis-&gt;pszFName = malloc(iLenName + 1)) == NULL)
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	memcpy(pThis-&gt;pszFName, pszName, iLenName + 1); 	pThis-&gt;lenFName = iLenName;
finalize_it:
	RETiRet;
}
static rsRetVal
strmSetDir(strm_t *pThis, uchar *pszDir, size_t iLenDir)
{
	DEFiRet;
	assert(pThis != NULL);
	assert(pszDir != NULL);
	if(iLenDir &lt; 1)
		ABORT_FINALIZE(RS_RET_FILE_PREFIX_MISSING);
	CHKmalloc(pThis-&gt;pszDir = malloc(iLenDir + 1));
	memcpy(pThis-&gt;pszDir, pszDir, iLenDir + 1); 	pThis-&gt;lenDir = iLenDir;
finalize_it:
	RETiRet;
}
static rsRetVal strmRecordBegin(strm_t *pThis)
{
	assert(pThis != NULL);
	assert(pThis-&gt;bInRecord == 0);
	pThis-&gt;bInRecord = 1;
	return RS_RET_OK;
}
static rsRetVal strmRecordEnd(strm_t *pThis)
{
	DEFiRet;
	assert(pThis != NULL);
	assert(pThis-&gt;bInRecord == 1);
	pThis-&gt;bInRecord = 0;
	iRet = strmCheckNextOutputFile(pThis); 
	RETiRet;
}
static rsRetVal strmSerialize(strm_t *pThis, strm_t *pStrm)
{
	DEFiRet;
	int i;
	int64 l;
	ISOBJ_TYPE_assert(pThis, strm);
	ISOBJ_TYPE_assert(pStrm, strm);
	strmFlushInternal(pThis, 0);
	CHKiRet(obj.BeginSerialize(pStrm, (obj_t*) pThis));
	objSerializeSCALAR(pStrm, iCurrFNum, INT); 	objSerializePTR(pStrm, pszFName, PSZ);
	objSerializeSCALAR(pStrm, iMaxFiles, INT);
	objSerializeSCALAR(pStrm, bDeleteOnClose, INT);
	i = pThis-&gt;sType;
	objSerializeSCALAR_VAR(pStrm, sType, INT, i);
	i = pThis-&gt;tOperationsMode;
	objSerializeSCALAR_VAR(pStrm, tOperationsMode, INT, i);
	i = pThis-&gt;tOpenMode;
	objSerializeSCALAR_VAR(pStrm, tOpenMode, INT, i);
	l = pThis-&gt;iCurrOffs;
	objSerializeSCALAR_VAR(pStrm, iCurrOffs, INT64, l);
	l = pThis-&gt;inode;
	objSerializeSCALAR_VAR(pStrm, inode, INT64, l);
	l = pThis-&gt;strtOffs;
	objSerializeSCALAR_VAR(pStrm, strtOffs, INT64, l);
	dbgprintf("strmSerialize: pThis-&gt;prevLineSegment %p\n", pThis-&gt;prevLineSegment);
	if(pThis-&gt;prevLineSegment != NULL) {
		cstrFinalize(pThis-&gt;prevLineSegment);
		objSerializePTR(pStrm, prevLineSegment, CSTR);
	}
	if(pThis-&gt;prevMsgSegment != NULL) {
		cstrFinalize(pThis-&gt;prevMsgSegment);
		objSerializePTR(pStrm, prevMsgSegment, CSTR);
	}
	i = pThis-&gt;bPrevWasNL;
	objSerializeSCALAR_VAR(pStrm, bPrevWasNL, INT, i);
	CHKiRet(obj.EndSerialize(pStrm));
finalize_it:
	RETiRet;
}
static rsRetVal
strmDup(strm_t *const pThis, strm_t **ppNew)
{
	strm_t *pNew = NULL;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	assert(ppNew != NULL);
	CHKiRet(strmConstruct(&amp;pNew));
	pNew-&gt;sType = pThis-&gt;sType;
	pNew-&gt;iCurrFNum = pThis-&gt;iCurrFNum;
	CHKmalloc(pNew-&gt;pszFName = ustrdup(pThis-&gt;pszFName));
	pNew-&gt;lenFName = pThis-&gt;lenFName;
	CHKmalloc(pNew-&gt;pszDir = ustrdup(pThis-&gt;pszDir));
	pNew-&gt;lenDir = pThis-&gt;lenDir;
	pNew-&gt;tOperationsMode = pThis-&gt;tOperationsMode;
	pNew-&gt;tOpenMode = pThis-&gt;tOpenMode;
	pNew-&gt;iMaxFileSize = pThis-&gt;iMaxFileSize;
	pNew-&gt;iMaxFiles = pThis-&gt;iMaxFiles;
	pNew-&gt;iFileNumDigits = pThis-&gt;iFileNumDigits;
	pNew-&gt;bDeleteOnClose = pThis-&gt;bDeleteOnClose;
	pNew-&gt;iCurrOffs = pThis-&gt;iCurrOffs;
	*ppNew = pNew;
	pNew = NULL;
finalize_it:
	if(pNew != NULL)
		strmDestruct(&amp;pNew);
	RETiRet;
}
static rsRetVal
strmSetWCntr(strm_t *pThis, number_t *pWCnt)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	if(pWCnt != NULL)
		*pWCnt = 0;
	pThis-&gt;pUsrWCntr = pWCnt;
	RETiRet;
}
#include "stringbuf.h"
#define isProp(name) !rsCStrSzStrCmp(pProp-&gt;pcsName, UCHAR_CONSTANT(name), sizeof(name) - 1)
static rsRetVal strmSetProperty(strm_t *pThis, var_t *pProp)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	assert(pProp != NULL);
	if(isProp("sType")) {
		CHKiRet(strmSetsType(pThis, (strmType_t) pProp-&gt;val.num));
	} else if(isProp("iCurrFNum")) {
		pThis-&gt;iCurrFNum = (unsigned) pProp-&gt;val.num;
	} else if(isProp("pszFName")) {
		CHKiRet(strmSetFName(pThis, rsCStrGetSzStrNoNULL(pProp-&gt;val.pStr), rsCStrLen(pProp-&gt;val.pStr)));
	} else if(isProp("tOperationsMode")) {
		CHKiRet(strmSettOperationsMode(pThis, pProp-&gt;val.num));
	} else if(isProp("tOpenMode")) {
		CHKiRet(strmSettOpenMode(pThis, pProp-&gt;val.num));
	} else if(isProp("iCurrOffs")) {
		pThis-&gt;iCurrOffs = pProp-&gt;val.num;
	} else if(isProp("inode")) {
		pThis-&gt;inode = (ino_t) pProp-&gt;val.num;
	} else if(isProp("strtOffs")) {
		pThis-&gt;strtOffs = pProp-&gt;val.num;
	} else if(isProp("iMaxFileSize")) {
		CHKiRet(strmSetiMaxFileSize(pThis, pProp-&gt;val.num));
	} else if(isProp("fileNotFoundError")) {
		CHKiRet(strmSetFileNotFoundError(pThis, pProp-&gt;val.num));
	} else if(isProp("iMaxFiles")) {
		CHKiRet(strmSetiMaxFiles(pThis, pProp-&gt;val.num));
	} else if(isProp("iFileNumDigits")) {
		CHKiRet(strmSetiFileNumDigits(pThis, pProp-&gt;val.num));
	} else if(isProp("bDeleteOnClose")) {
		CHKiRet(strmSetbDeleteOnClose(pThis, pProp-&gt;val.num));
	} else if(isProp("prevLineSegment")) {
		CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevLineSegment, pProp-&gt;val.pStr));
	} else if(isProp("prevMsgSegment")) {
		CHKiRet(rsCStrConstructFromCStr(&amp;pThis-&gt;prevMsgSegment, pProp-&gt;val.pStr));
	} else if(isProp("bPrevWasNL")) {
		pThis-&gt;bPrevWasNL = (sbool) pProp-&gt;val.num;
	}
finalize_it:
	RETiRet;
}
#undef	isProp
static rsRetVal
strmGetCurrOffset(strm_t *pThis, int64 *pOffs)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strm);
	assert(pOffs != NULL);
	*pOffs = pThis-&gt;iCurrOffs;
	RETiRet;
}
BEGINobjQueryInterface(strm)
CODESTARTobjQueryInterface(strm)
	if(pIf-&gt;ifVersion != strmCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;Construct = strmConstruct;
	pIf-&gt;ConstructFinalize = strmConstructFinalize;
	pIf-&gt;Destruct = strmDestruct;
	pIf-&gt;ReadChar = strmReadChar;
	pIf-&gt;UnreadChar = strmUnreadChar;
	pIf-&gt;ReadLine = strmReadLine;
	pIf-&gt;SeekCurrOffs = strmSeekCurrOffs;
	pIf-&gt;Write = strmWrite;
	pIf-&gt;WriteChar = strmWriteChar;
	pIf-&gt;WriteLong = strmWriteLong;
	pIf-&gt;SetFName = strmSetFName;
	pIf-&gt;SetFileNotFoundError = strmSetFileNotFoundError;
	pIf-&gt;SetDir = strmSetDir;
	pIf-&gt;Flush = strmFlush;
	pIf-&gt;RecordBegin = strmRecordBegin;
	pIf-&gt;RecordEnd = strmRecordEnd;
	pIf-&gt;Serialize = strmSerialize;
	pIf-&gt;GetCurrOffset = strmGetCurrOffset;
	pIf-&gt;Dup = strmDup;
	pIf-&gt;SetWCntr = strmSetWCntr;
	pIf-&gt;CheckFileChange = CheckFileChange;
	pIf-&gt;SetbDeleteOnClose = strmSetbDeleteOnClose;
	pIf-&gt;SetiMaxFileSize = strmSetiMaxFileSize;
	pIf-&gt;SetiMaxFiles = strmSetiMaxFiles;
	pIf-&gt;SetiFileNumDigits = strmSetiFileNumDigits;
	pIf-&gt;SettOperationsMode = strmSettOperationsMode;
	pIf-&gt;SettOpenMode = strmSettOpenMode;
	pIf-&gt;SetsType = strmSetsType;
	pIf-&gt;SetiZipLevel = strmSetiZipLevel;
	pIf-&gt;SetbVeryReliableZip = strmSetbVeryReliableZip;
	pIf-&gt;SetbSync = strmSetbSync;
	pIf-&gt;SetbReopenOnTruncate = strmSetbReopenOnTruncate;
	pIf-&gt;SetsIOBufSize = strmSetsIOBufSize;
	pIf-&gt;SetiSizeLimit = strmSetiSizeLimit;
	pIf-&gt;SetiFlushInterval = strmSetiFlushInterval;
	pIf-&gt;SetpszSizeLimitCmd = strmSetpszSizeLimitCmd;
	pIf-&gt;Setcryprov = strmSetcryprov;
	pIf-&gt;SetcryprovData = strmSetcryprovData;
finalize_it:
ENDobjQueryInterface(strm)
BEGINObjClassInit(strm, 1, OBJ_IS_CORE_MODULE)
	OBJSetMethodHandler(objMethod_SERIALIZE, strmSerialize);
	OBJSetMethodHandler(objMethod_SETPROPERTY, strmSetProperty);
	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, strmConstructFinalize);
ENDObjClassInit(strm)
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
