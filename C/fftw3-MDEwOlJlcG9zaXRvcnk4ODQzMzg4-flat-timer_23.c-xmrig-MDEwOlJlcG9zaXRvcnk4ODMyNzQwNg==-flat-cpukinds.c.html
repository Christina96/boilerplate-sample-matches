
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4896265560165975%, Tokens: 9</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-timer_23.c</h3>
            <pre><code>1  #include "kernel/ifftw.h"
2  #ifdef HAVE_UNISTD_H
3  #  include <unistd.h>
4  #endif
5  #ifndef WITH_SLOW_TIMER
6  #  include "cycle.h"
7  #endif
8  #ifndef FFTW_TIME_LIMIT
9  #define FFTW_TIME_LIMIT 2.0  &bsol;* don't run for more than two seconds */
10  #endif
11  #if 0 && (defined(__WIN32__) || defined(_WIN32) || defined(_WIN64))
12  crude_time X(get_crude_time)(void)
13  {
14       crude_time tv;
15       QueryPerformanceCounter(&tv);
16       return tv;
17  }
18  static double elapsed_since(crude_time t0)
19  {
20       crude_time t1, freq;
21       QueryPerformanceCounter(&t1);
22       QueryPerformanceFrequency(&freq);
23       return (((double) (t1.QuadPart - t0.QuadPart))) /
24  	  ((double) freq.QuadPart);
25  }
26  #  define TIME_MIN_SEC 1.0e-2
27  #elif defined(HAVE_GETTIMEOFDAY)
28  crude_time X(get_crude_time)(void)
29  {
30       crude_time tv;
31       gettimeofday(&tv, 0);
32       return tv;
33  }
34  #define elapsed_sec(t1,t0) ((double)(t1.tv_sec - t0.tv_sec) +		\
35  			    (double)(t1.tv_usec - t0.tv_usec) * 1.0E-6)
36  static double elapsed_since(crude_time t0)
37  {
38       crude_time t1;
39       gettimeofday(&t1, 0);
40       return elapsed_sec(t1, t0);
41  }
42  #  define TIME_MIN_SEC 1.0e-3
43  #else &bsol;* !HAVE_GETTIMEOFDAY */
44  crude_time X(get_crude_time)(void) { return clock(); }
45  #define elapsed_sec(t1,t0) ((double) ((t1) - (t0)) / CLOCKS_PER_SEC)
46  static double elapsed_since(crude_time t0)
47  {
48       return elapsed_sec(clock(), t0);
49  }
50  #  define TIME_MIN_SEC 2.0e-1 &bsol;* from fftw2 */
51  #endif &bsol;* !HAVE_GETTIMEOFDAY */
52  double X(elapsed_since)(const planner *plnr, const problem *p, crude_time t0)
53  {
54       double t = elapsed_since(t0);
55       if (plnr->cost_hook)
56  	  t = plnr->cost_hook(p, t, COST_MAX);
57       return t;
58  }
59  #ifdef WITH_SLOW_TIMER
60  typedef crude_time ticks;
61  #  define getticks X(get_crude_time)
62  #  define elapsed(t1,t0) elapsed_sec(t1,t0)
63  #  define TIME_MIN TIME_MIN_SEC
64  #  define TIME_REPEAT 4 &bsol;* from fftw2 */
65  #  define HAVE_TICK_COUNTER
66  #endif
67  #ifdef HAVE_TICK_COUNTER
68  #  ifndef TIME_MIN
69  #    define TIME_MIN 100.0
70  #  endif
71  #  ifndef TIME_REPEAT
72  #    define TIME_REPEAT 8
73  #  endif
74    static double measure(plan *pln, const problem *p, int iter)
75    {
76         ticks t0, t1;
77         int i;
78         t0 = getticks();
79         for (i = 0; i < iter; ++i) 
80  	    pln->adt->solve(pln, p);
81         t1 = getticks();
82         return elapsed(t1, t0);
83    }
84    double X(measure_execution_time)(const planner *plnr, 
85  				   plan *pln, const problem *p)
86    {
87         int iter;
88         int repeat;
89         X(plan_awake)(pln, AWAKE_ZERO);
90         p->adt->zero(p);
91    start_over:
92         for (iter = 1; iter; iter *= 2) {
93  	    double tmin = 0;
<span onclick='openModal()' class='match'>94  	    int first = 1;
95  	    crude_time begin = X(get_crude_time)();
96  	    for (repeat = 0; repeat < TIME_REPEAT; ++repeat) {
97  		 double t = measure(pln, p, iter);
98  		 if (plnr->cost_hook)
</span>99  		      t = plnr->cost_hook(p, t, COST_MAX);
100  		 if (t < 0)
101  		      goto start_over;
102  		 if (first || t < tmin)
103  		      tmin = t;
104  		 first = 0;
105  		 if (X(elapsed_since)(plnr, p, begin) > FFTW_TIME_LIMIT)
106  		      break;
107  	    }
108  	    if (tmin >= TIME_MIN) {
109  		 X(plan_awake)(pln, SLEEPY);
110  		 return tmin / (double) iter;
111  	    }
112         }
113         goto start_over; &bsol;* may happen if timer is screwed up */
114    }
115  #else &bsol;* no cycle counter */
116    double X(measure_execution_time)(const planner *plnr, 
117  				   plan *pln, const problem *p)
118    {
119         UNUSED(plnr);
120         UNUSED(p);
121         UNUSED(pln);
122         return -1.0;
123    }
124  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-cpukinds.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc.h"
3  #include "private/private.h"
4  #include "private/debug.h"
5  void
6  hwloc_internal_cpukinds_init(struct hwloc_topology *topology)
7  {
8    topology->cpukinds = NULL;
9    topology->nr_cpukinds = 0;
10    topology->nr_cpukinds_allocated = 0;
11  }
12  void
13  hwloc_internal_cpukinds_destroy(struct hwloc_topology *topology)
14  {
15    unsigned i;
16    for(i=0; i<topology->nr_cpukinds; i++) {
17      struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
18      hwloc_bitmap_free(kind->cpuset);
19      hwloc__free_infos(kind->infos, kind->nr_infos);
20    }
21    free(topology->cpukinds);
22    topology->cpukinds = NULL;
23    topology->nr_cpukinds = 0;
24  }
25  int
26  hwloc_internal_cpukinds_dup(hwloc_topology_t new, hwloc_topology_t old)
27  {
28    struct hwloc_tma *tma = new->tma;
29    struct hwloc_internal_cpukind_s *kinds;
30    unsigned i;
31    if (!old->nr_cpukinds)
32      return 0;
33    kinds = hwloc_tma_malloc(tma, old->nr_cpukinds * sizeof(*kinds));
34    if (!kinds)
35      return -1;
36    new->cpukinds = kinds;
37    new->nr_cpukinds = old->nr_cpukinds;
38    memcpy(kinds, old->cpukinds, old->nr_cpukinds * sizeof(*kinds));
39    for(i=0;i<old->nr_cpukinds; i++) {
40      kinds[i].cpuset = hwloc_bitmap_tma_dup(tma, old->cpukinds[i].cpuset);
41      if (!kinds[i].cpuset) {
42        new->nr_cpukinds = i;
43        goto failed;
44      }
45      if (hwloc__tma_dup_infos(tma,
46                               &kinds[i].infos, &kinds[i].nr_infos,
47                               old->cpukinds[i].infos, old->cpukinds[i].nr_infos) < 0) {
48        assert(!tma || !tma->dontfree); &bsol;* this tma cannot fail to allocate */
49        hwloc_bitmap_free(kinds[i].cpuset);
50        new->nr_cpukinds = i;
51        goto failed;
52      }
53    }
54    return 0;
55   failed:
56    hwloc_internal_cpukinds_destroy(new);
57    return -1;
58  }
59  void
60  hwloc_internal_cpukinds_restrict(hwloc_topology_t topology)
61  {
62    unsigned i;
63    int removed = 0;
64    for(i=0; i<topology->nr_cpukinds; i++) {
65      struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
66      hwloc_bitmap_and(kind->cpuset, kind->cpuset, hwloc_get_root_obj(topology)->cpuset);
67      if (hwloc_bitmap_iszero(kind->cpuset)) {
68        hwloc_bitmap_free(kind->cpuset);
69        hwloc__free_infos(kind->infos, kind->nr_infos);
70        memmove(kind, kind+1, (topology->nr_cpukinds - i - 1)*sizeof(*kind));
71        i--;
72        topology->nr_cpukinds--;
73        removed = 1;
74      }
75    }
76    if (removed)
77      hwloc_internal_cpukinds_rank(topology);
78  }
79  static __hwloc_inline int
80  hwloc__cpukind_check_duplicate_info(struct hwloc_internal_cpukind_s *kind,
81                                      const char *name, const char *value)
82  {
83    unsigned i;
84    for(i=0; i<kind->nr_infos; i++)
85      if (!strcmp(kind->infos[i].name, name)
86          && !strcmp(kind->infos[i].value, value))
87        return 1;
88    return 0;
89  }
90  static __hwloc_inline void
91  hwloc__cpukind_add_infos(struct hwloc_internal_cpukind_s *kind,
92                           const struct hwloc_info_s *infos, unsigned nr_infos)
93  {
94    unsigned i;
95    for(i=0; i<nr_infos; i++) {
96      if (hwloc__cpukind_check_duplicate_info(kind, infos[i].name, infos[i].value))
97        continue;
98      hwloc__add_info(&kind->infos, &kind->nr_infos, infos[i].name, infos[i].value);
99    }
100  }
101  int
102  hwloc_internal_cpukinds_register(hwloc_topology_t topology, hwloc_cpuset_t cpuset,
103                                   int forced_efficiency,
104                                   const struct hwloc_info_s *infos, unsigned nr_infos,
105                                   unsigned long flags)
106  {
107    struct hwloc_internal_cpukind_s *kinds;
108    unsigned i, max, bits, oldnr, newnr;
109    if (hwloc_bitmap_iszero(cpuset)) {
110      hwloc_bitmap_free(cpuset);
111      errno = EINVAL;
112      return -1;
113    }
114    if (flags & ~HWLOC_CPUKINDS_REGISTER_FLAG_OVERWRITE_FORCED_EFFICIENCY) {
115      errno = EINVAL;
116      return -1;
117    }
118    max = 2 * topology->nr_cpukinds + 1;
119    bits = hwloc_flsl(max-1) + 1;
120    max = 1U<<bits;
121    if (max < 8)
122      max = 8;
123    kinds = topology->cpukinds;
124    if (max > topology->nr_cpukinds_allocated) {
125      kinds = realloc(kinds, max * sizeof(*kinds));
126      if (!kinds) {
127        hwloc_bitmap_free(cpuset);
128        return -1;
129      }
130      memset(&kinds[topology->nr_cpukinds_allocated], 0, (max - topology->nr_cpukinds_allocated) * sizeof(*kinds));
131      topology->nr_cpukinds_allocated = max;
132      topology->cpukinds = kinds;
133    }
<span onclick='openModal()' class='match'>134    newnr = oldnr = topology->nr_cpukinds;
135    for(i=0; i<oldnr; i++) {
136      int res = hwloc_bitmap_compare_inclusion(cpuset, kinds[i].cpuset);
137      if (res == HWLOC_BITMAP_INTERSECTS || res == HWLOC_BITMAP_INCLUDED) {
</span>138        kinds[newnr].cpuset = hwloc_bitmap_alloc();
139        kinds[newnr].efficiency = HWLOC_CPUKIND_EFFICIENCY_UNKNOWN;
140        kinds[newnr].forced_efficiency = forced_efficiency;
141        hwloc_bitmap_and(kinds[newnr].cpuset, cpuset, kinds[i].cpuset);
142        hwloc__cpukind_add_infos(&kinds[newnr], kinds[i].infos, kinds[i].nr_infos);
143        hwloc__cpukind_add_infos(&kinds[newnr], infos, nr_infos);
144        hwloc_bitmap_andnot(kinds[i].cpuset, kinds[i].cpuset, kinds[newnr].cpuset);
145        hwloc_bitmap_andnot(cpuset, cpuset, kinds[newnr].cpuset);
146        newnr++;
147      } else if (res == HWLOC_BITMAP_CONTAINS
148                 || res == HWLOC_BITMAP_EQUAL) {
149        hwloc__cpukind_add_infos(&kinds[i], infos, nr_infos);
150        if ((flags & HWLOC_CPUKINDS_REGISTER_FLAG_OVERWRITE_FORCED_EFFICIENCY)
151            || kinds[i].forced_efficiency == HWLOC_CPUKIND_EFFICIENCY_UNKNOWN)
152          kinds[i].forced_efficiency = forced_efficiency;
153        hwloc_bitmap_andnot(cpuset, cpuset, kinds[i].cpuset);
154      } else {
155        assert(res == HWLOC_BITMAP_DIFFERENT);
156      }
157      if (hwloc_bitmap_iszero(cpuset))
158        break;
159    }
160    if (!hwloc_bitmap_iszero(cpuset)) {
161      kinds[newnr].cpuset = cpuset;
162      kinds[newnr].efficiency = HWLOC_CPUKIND_EFFICIENCY_UNKNOWN;
163      kinds[newnr].forced_efficiency = forced_efficiency;
164      hwloc__cpukind_add_infos(&kinds[newnr], infos, nr_infos);
165      newnr++;
166    } else {
167      hwloc_bitmap_free(cpuset);
168    }
169    topology->nr_cpukinds = newnr;
170    return 0;
171  }
172  int
173  hwloc_cpukinds_register(hwloc_topology_t topology, hwloc_cpuset_t _cpuset,
174                          int forced_efficiency,
175                          unsigned nr_infos, struct hwloc_info_s *infos,
176                          unsigned long flags)
177  {
178    hwloc_bitmap_t cpuset;
179    int err;
180    if (flags) {
181      errno = EINVAL;
182      return -1;
183    }
184    if (!_cpuset || hwloc_bitmap_iszero(_cpuset)) {
185      errno = EINVAL;
186      return -1;
187    }
188    cpuset = hwloc_bitmap_dup(_cpuset);
189    if (!cpuset)
190      return -1;
191    if (forced_efficiency < 0)
192      forced_efficiency = HWLOC_CPUKIND_EFFICIENCY_UNKNOWN;
193    err = hwloc_internal_cpukinds_register(topology, cpuset, forced_efficiency, infos, nr_infos, HWLOC_CPUKINDS_REGISTER_FLAG_OVERWRITE_FORCED_EFFICIENCY);
194    if (err < 0)
195      return err;
196    hwloc_internal_cpukinds_rank(topology);
197    return 0;
198  }
199  static int
200  hwloc__cpukinds_check_duplicate_rankings(struct hwloc_topology *topology)
201  {
202    unsigned i,j;
203    for(i=0; i<topology->nr_cpukinds; i++)
204      for(j=i+1; j<topology->nr_cpukinds; j++)
205        if (topology->cpukinds[i].ranking_value == topology->cpukinds[j].ranking_value)
206          return -1;
207    return 0;
208  }
209  static int
210  hwloc__cpukinds_try_rank_by_forced_efficiency(struct hwloc_topology *topology)
211  {
212    unsigned i;
213    hwloc_debug("Trying to rank cpukinds by forced efficiency...\n");
214    for(i=0; i<topology->nr_cpukinds; i++) {
215      if (topology->cpukinds[i].forced_efficiency == HWLOC_CPUKIND_EFFICIENCY_UNKNOWN)
216        return -1;
217      topology->cpukinds[i].ranking_value = topology->cpukinds[i].forced_efficiency;
218    }
219    return hwloc__cpukinds_check_duplicate_rankings(topology);
220  }
221  struct hwloc_cpukinds_info_summary {
222    int have_max_freq;
223    int have_base_freq;
224    int have_intel_core_type;
225    struct hwloc_cpukind_info_summary {
226      unsigned intel_core_type; &bsol;* 1 for atom, 2 for core */
227      unsigned max_freq, base_freq; &bsol;* MHz, hence < 100000 */
228    } * summaries;
229  };
230  static void
231  hwloc__cpukinds_summarize_info(struct hwloc_topology *topology,
232                                 struct hwloc_cpukinds_info_summary *summary)
233  {
234    unsigned i, j;
235    summary->have_max_freq = 1;
236    summary->have_base_freq = 1;
237    summary->have_intel_core_type = 1;
238    for(i=0; i<topology->nr_cpukinds; i++) {
239      struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
240      for(j=0; j<kind->nr_infos; j++) {
241        struct hwloc_info_s *info = &kind->infos[j];
242        if (!strcmp(info->name, "FrequencyMaxMHz")) {
243          summary->summaries[i].max_freq = atoi(info->value);
244        } else if (!strcmp(info->name, "FrequencyBaseMHz")) {
245          summary->summaries[i].base_freq = atoi(info->value);
246        } else if (!strcmp(info->name, "CoreType")) {
247          if (!strcmp(info->value, "IntelAtom"))
248            summary->summaries[i].intel_core_type = 1;
249          else if (!strcmp(info->value, "IntelCore"))
250            summary->summaries[i].intel_core_type = 2;
251        }
252      }
253      hwloc_debug("cpukind #%u has intel_core_type %u max_freq %u base_freq %u\n",
254                  i, summary->summaries[i].intel_core_type,
255                  summary->summaries[i].max_freq, summary->summaries[i].base_freq);
256      if (!summary->summaries[i].base_freq)
257        summary->have_base_freq = 0;
258      if (!summary->summaries[i].max_freq)
259        summary->have_max_freq = 0;
260      if (!summary->summaries[i].intel_core_type)
261        summary->have_intel_core_type = 0;
262    }
263  }
264  enum hwloc_cpukinds_ranking {
265    HWLOC_CPUKINDS_RANKING_DEFAULT, &bsol;* forced + frequency on ARM, forced + coretype_frequency otherwise */
266    HWLOC_CPUKINDS_RANKING_NO_FORCED_EFFICIENCY, &bsol;* default without forced */
267    HWLOC_CPUKINDS_RANKING_FORCED_EFFICIENCY,
268    HWLOC_CPUKINDS_RANKING_CORETYPE_FREQUENCY, &bsol;* either coretype or frequency or both */
269    HWLOC_CPUKINDS_RANKING_CORETYPE_FREQUENCY_STRICT, &bsol;* both coretype and frequency are required */
270    HWLOC_CPUKINDS_RANKING_CORETYPE,
271    HWLOC_CPUKINDS_RANKING_FREQUENCY,
272    HWLOC_CPUKINDS_RANKING_FREQUENCY_MAX,
273    HWLOC_CPUKINDS_RANKING_FREQUENCY_BASE,
274    HWLOC_CPUKINDS_RANKING_NONE
275  };
276  static int
277  hwloc__cpukinds_try_rank_by_info(struct hwloc_topology *topology,
278                                   enum hwloc_cpukinds_ranking heuristics,
279                                   struct hwloc_cpukinds_info_summary *summary)
280  {
281    unsigned i;
282    if (HWLOC_CPUKINDS_RANKING_CORETYPE_FREQUENCY_STRICT == heuristics) {
283      hwloc_debug("Trying to rank cpukinds by coretype+frequency_strict...\n");
284      if (!summary->have_intel_core_type
285          || (!summary->have_max_freq && !summary->have_base_freq))
286        return -1;
287      for(i=0; i<topology->nr_cpukinds; i++) {
288        struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
289        if (summary->have_base_freq)
290          kind->ranking_value = (summary->summaries[i].intel_core_type << 20) + summary->summaries[i].base_freq;
291        else
292          kind->ranking_value = (summary->summaries[i].intel_core_type << 20) + summary->summaries[i].max_freq;
293      }
294    } else if (HWLOC_CPUKINDS_RANKING_CORETYPE_FREQUENCY == heuristics) {
295      hwloc_debug("Trying to rank cpukinds by coretype+frequency...\n");
296      if (!summary->have_intel_core_type
297          && (!summary->have_max_freq && !summary->have_base_freq))
298        return -1;
299      for(i=0; i<topology->nr_cpukinds; i++) {
300        struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
301        if (summary->have_base_freq)
302          kind->ranking_value = (summary->summaries[i].intel_core_type << 20) + summary->summaries[i].base_freq;
303        else
304          kind->ranking_value = (summary->summaries[i].intel_core_type << 20) + summary->summaries[i].max_freq;
305      }
306    } else if (HWLOC_CPUKINDS_RANKING_CORETYPE == heuristics) {
307      hwloc_debug("Trying to rank cpukinds by coretype...\n");
308      if (!summary->have_intel_core_type)
309        return -1;
310      for(i=0; i<topology->nr_cpukinds; i++) {
311        struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
312        kind->ranking_value = (summary->summaries[i].intel_core_type << 20);
313      }
314    } else if (HWLOC_CPUKINDS_RANKING_FREQUENCY == heuristics) {
315      hwloc_debug("Trying to rank cpukinds by frequency...\n");
316      if (!summary->have_max_freq && !summary->have_base_freq)
317        return -1;
318      for(i=0; i<topology->nr_cpukinds; i++) {
319        struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
320        if (summary->have_base_freq)
321          kind->ranking_value = summary->summaries[i].base_freq;
322        else
323          kind->ranking_value = summary->summaries[i].max_freq;
324      }
325    } else if (HWLOC_CPUKINDS_RANKING_FREQUENCY_MAX == heuristics) {
326      hwloc_debug("Trying to rank cpukinds by frequency max...\n");
327      if (!summary->have_max_freq)
328        return -1;
329      for(i=0; i<topology->nr_cpukinds; i++) {
330        struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
331        kind->ranking_value = summary->summaries[i].max_freq;
332      }
333    } else if (HWLOC_CPUKINDS_RANKING_FREQUENCY_BASE == heuristics) {
334      hwloc_debug("Trying to rank cpukinds by frequency base...\n");
335      if (!summary->have_base_freq)
336        return -1;
337      for(i=0; i<topology->nr_cpukinds; i++) {
338        struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[i];
339        kind->ranking_value = summary->summaries[i].base_freq;
340      }
341    } else assert(0);
342    return hwloc__cpukinds_check_duplicate_rankings(topology);
343  }
344  static int hwloc__cpukinds_compare_ranking_values(const void *_a, const void *_b)
345  {
346    const struct hwloc_internal_cpukind_s *a = _a;
347    const struct hwloc_internal_cpukind_s *b = _b;
348    uint64_t arv = a->ranking_value;
349    uint64_t brv = b->ranking_value;
350    return arv < brv ? -1 : arv > brv ? 1 : 0;
351  }
352  static void
353  hwloc__cpukinds_finalize_ranking(struct hwloc_topology *topology)
354  {
355    unsigned i;
356    qsort(topology->cpukinds, topology->nr_cpukinds, sizeof(*topology->cpukinds), hwloc__cpukinds_compare_ranking_values);
357    for(i=0; i<topology->nr_cpukinds; i++)
358      topology->cpukinds[i].efficiency = i;
359  }
360  int
361  hwloc_internal_cpukinds_rank(struct hwloc_topology *topology)
362  {
363    enum hwloc_cpukinds_ranking heuristics;
364    char *env;
365    unsigned i;
366    int err;
367    if (!topology->nr_cpukinds)
368      return 0;
369    if (topology->nr_cpukinds == 1) {
370      topology->cpukinds[0].efficiency = 0;
371      return 0;
372    }
373    heuristics = HWLOC_CPUKINDS_RANKING_DEFAULT;
374    env = getenv("HWLOC_CPUKINDS_RANKING");
375    if (env) {
376      if (!strcmp(env, "default"))
377        heuristics = HWLOC_CPUKINDS_RANKING_DEFAULT;
378      else if (!strcmp(env, "none"))
379        heuristics = HWLOC_CPUKINDS_RANKING_NONE;
380      else if (!strcmp(env, "coretype+frequency"))
381        heuristics = HWLOC_CPUKINDS_RANKING_CORETYPE_FREQUENCY;
382      else if (!strcmp(env, "coretype+frequency_strict"))
383        heuristics = HWLOC_CPUKINDS_RANKING_CORETYPE_FREQUENCY_STRICT;
384      else if (!strcmp(env, "coretype"))
385        heuristics = HWLOC_CPUKINDS_RANKING_CORETYPE;
386      else if (!strcmp(env, "frequency"))
387        heuristics = HWLOC_CPUKINDS_RANKING_FREQUENCY;
388      else if (!strcmp(env, "frequency_max"))
389        heuristics = HWLOC_CPUKINDS_RANKING_FREQUENCY_MAX;
390      else if (!strcmp(env, "frequency_base"))
391        heuristics = HWLOC_CPUKINDS_RANKING_FREQUENCY_BASE;
392      else if (!strcmp(env, "forced_efficiency"))
393        heuristics = HWLOC_CPUKINDS_RANKING_FORCED_EFFICIENCY;
394      else if (!strcmp(env, "no_forced_efficiency"))
395        heuristics = HWLOC_CPUKINDS_RANKING_NO_FORCED_EFFICIENCY;
396      else if (HWLOC_SHOW_CRITICAL_ERRORS())
397        fprintf(stderr, "hwloc: Failed to recognize HWLOC_CPUKINDS_RANKING value %s\n", env);
398    }
399    if (heuristics == HWLOC_CPUKINDS_RANKING_DEFAULT
400        || heuristics == HWLOC_CPUKINDS_RANKING_NO_FORCED_EFFICIENCY) {
401      struct hwloc_cpukinds_info_summary summary;
402      if (heuristics == HWLOC_CPUKINDS_RANKING_DEFAULT)
403        hwloc_debug("Using default ranking strategy...\n");
404      else
405        hwloc_debug("Using custom ranking strategy from HWLOC_CPUKINDS_RANKING=%s\n", env);
406      if (heuristics != HWLOC_CPUKINDS_RANKING_NO_FORCED_EFFICIENCY) {
407        err = hwloc__cpukinds_try_rank_by_forced_efficiency(topology);
408        if (!err)
409          goto ready;
410      }
411      summary.summaries = calloc(topology->nr_cpukinds, sizeof(*summary.summaries));
412      if (!summary.summaries)
413        goto failed;
414      hwloc__cpukinds_summarize_info(topology, &summary);
415      err = hwloc__cpukinds_try_rank_by_info(topology, HWLOC_CPUKINDS_RANKING_CORETYPE_FREQUENCY, &summary);
416      free(summary.summaries);
417      if (!err)
418        goto ready;
419    } else if (heuristics == HWLOC_CPUKINDS_RANKING_FORCED_EFFICIENCY) {
420      hwloc_debug("Using custom ranking strategy from HWLOC_CPUKINDS_RANKING=%s\n", env);
421      err = hwloc__cpukinds_try_rank_by_forced_efficiency(topology);
422      if (!err)
423        goto ready;
424    } else if (heuristics != HWLOC_CPUKINDS_RANKING_NONE) {
425      struct hwloc_cpukinds_info_summary summary;
426      hwloc_debug("Using custom ranking strategy from HWLOC_CPUKINDS_RANKING=%s\n", env);
427      summary.summaries = calloc(topology->nr_cpukinds, sizeof(*summary.summaries));
428      if (!summary.summaries)
429        goto failed;
430      hwloc__cpukinds_summarize_info(topology, &summary);
431      err = hwloc__cpukinds_try_rank_by_info(topology, heuristics, &summary);
432      free(summary.summaries);
433      if (!err)
434        goto ready;
435    }
436   failed:
437    for(i=0; i<topology->nr_cpukinds; i++)
438      topology->cpukinds[i].efficiency = HWLOC_CPUKIND_EFFICIENCY_UNKNOWN;
439    hwloc_debug("Failed to rank cpukinds.\n\n");
440    return 0;
441   ready:
442    for(i=0; i<topology->nr_cpukinds; i++)
443      hwloc_debug("cpukind #%u got ranking value %llu\n", i, (unsigned long long) topology->cpukinds[i].ranking_value);
444    hwloc__cpukinds_finalize_ranking(topology);
445  #ifdef HWLOC_DEBUG
446    for(i=0; i<topology->nr_cpukinds; i++)
447      assert(topology->cpukinds[i].efficiency == (int) i);
448  #endif
449    hwloc_debug("\n");
450    return 0;
451  }
452  int
453  hwloc_cpukinds_get_nr(hwloc_topology_t topology, unsigned long flags)
454  {
455    if (flags) {
456      errno = EINVAL;
457      return -1;
458    }
459    return topology->nr_cpukinds;
460  }
461  int
462  hwloc_cpukinds_get_info(hwloc_topology_t topology,
463                          unsigned id,
464                          hwloc_bitmap_t cpuset,
465                          int *efficiencyp,
466                          unsigned *nr_infosp, struct hwloc_info_s **infosp,
467                          unsigned long flags)
468  {
469    struct hwloc_internal_cpukind_s *kind;
470    if (flags) {
471      errno = EINVAL;
472      return -1;
473    }
474    if (id >= topology->nr_cpukinds) {
475      errno = ENOENT;
476      return -1;
477    }
478    kind = &topology->cpukinds[id];
479    if (cpuset)
480      hwloc_bitmap_copy(cpuset, kind->cpuset);
481    if (efficiencyp)
482      *efficiencyp = kind->efficiency;
483    if (nr_infosp && infosp) {
484      *nr_infosp = kind->nr_infos;
485      *infosp = kind->infos;
486    }
487    return 0;
488  }
489  int
490  hwloc_cpukinds_get_by_cpuset(hwloc_topology_t topology,
491                               hwloc_const_bitmap_t cpuset,
492                               unsigned long flags)
493  {
494    unsigned id;
495    if (flags) {
496      errno = EINVAL;
497      return -1;
498    }
499    if (!cpuset || hwloc_bitmap_iszero(cpuset)) {
500      errno = EINVAL;
501      return -1;
502    }
503    for(id=0; id<topology->nr_cpukinds; id++) {
504      struct hwloc_internal_cpukind_s *kind = &topology->cpukinds[id];
505      int res = hwloc_bitmap_compare_inclusion(cpuset, kind->cpuset);
506      if (res == HWLOC_BITMAP_EQUAL || res == HWLOC_BITMAP_INCLUDED) {
507        return (int) id;
508      } else if (res == HWLOC_BITMAP_INTERSECTS || res == HWLOC_BITMAP_CONTAINS) {
509        errno = EXDEV;
510        return -1;
511      }
512    }
513    errno = ENOENT;
514    return -1;
515  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-timer_23.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-cpukinds.c</div>
                </div>
                <div class="column column_space"><pre><code>94  	    int first = 1;
95  	    crude_time begin = X(get_crude_time)();
96  	    for (repeat = 0; repeat < TIME_REPEAT; ++repeat) {
97  		 double t = measure(pln, p, iter);
98  		 if (plnr->cost_hook)
</pre></code></div>
                <div class="column column_space"><pre><code>134    newnr = oldnr = topology->nr_cpukinds;
135    for(i=0; i<oldnr; i++) {
136      int res = hwloc_bitmap_compare_inclusion(cpuset, kinds[i].cpuset);
137      if (res == HWLOC_BITMAP_INTERSECTS || res == HWLOC_BITMAP_INCLUDED) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    