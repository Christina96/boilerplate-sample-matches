<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for timezones.c &amp; pmciscoios.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for timezones.c &amp; pmciscoios.c
      </h3>
<h1 align="center">
        18.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>timezones.c (19.607843%)<th>pmciscoios.c (17.647058%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(40-48)<td><a href="#" name="0">(55-63)</a><td align="center"><font color="#ff0000">17</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(89-99)<td><a href="#" name="1">(116-127)</a><td align="center"><font color="#c30000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>timezones.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;sys/types.h&gt;
4 #include &lt;unistd.h&gt;
5 #include &lt;ctype.h&gt;
6 #include &lt;stdint.h&gt;
7 #include &lt;errno.h&gt;
8 #include "rsyslog.h"
9 #include "unicode-helper.h"
10 #include "errmsg.h"
11 #include "parserif.h"
12 #include "rainerscript.h"
13 #include "srUtils.h"
14 <a name="0"></a>#include "rsconf.h"
15 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static struct cnfparamdescr timezonecnfparamdescr[] = {
16 	{ "id", eCmdHdlrString, CNFPARAM_REQUIRED},
17 	{ "offset", eCmdHdlrGetWord, CNFPARAM_REQUIRED }
18 };
19 static struct cnfparamblk timezonepblk = {
20 	CNFPARAMBLK_VERSION,
21 	sizeof(timezonecnfparamdescr)/sizeof(struct cnfparamdescr),
22 	timezonecnfparamdescr
23 };</b></font>
24 static rsRetVal
25 addTimezoneInfo(rsconf_t *cnf, uchar *tzid, char offsMode, int8_t offsHour, int8_t offsMin)
26 {
27 	DEFiRet;
28 	tzinfo_t *newti;
29 	CHKmalloc(newti = realloc(cnf-&gt;timezones.tzinfos, (cnf-&gt;timezones.ntzinfos+1)*sizeof(tzinfo_t)));
30 	if((newti[cnf-&gt;timezones.ntzinfos].id = strdup((char*)tzid)) == NULL) {
31 		free(newti);
32 		DBGPRINTF("addTimezoneInfo: strdup failed with OOM\n");
33 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
34 	}
35 	newti[cnf-&gt;timezones.ntzinfos].offsMode = offsMode;
36 	newti[cnf-&gt;timezones.ntzinfos].offsHour = offsHour;
37 	newti[cnf-&gt;timezones.ntzinfos].offsMin = offsMin;
38 	++cnf-&gt;timezones.ntzinfos, cnf-&gt;timezones.tzinfos = newti;
39 finalize_it:
40 	RETiRet;
41 }
42 void
43 glblProcessTimezone(struct cnfobj *o)
44 {
45 	struct cnfparamvals *pvals;
46 	uchar *id = NULL;
47 	uchar *offset = NULL;
48 	char offsMode;
49 	int8_t offsHour;
50 	int8_t offsMin;
51 	int i;
52 	pvals = nvlstGetParams(o-&gt;nvlst, &amp;timezonepblk, NULL);
53 	if(pvals == NULL) {
54 <a name="1"></a>		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing timezone "
55 				"config parameters");
56 		goto done;
57 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
58 	if(Debug) {
59 		dbgprintf("timezone param blk after glblProcessTimezone:\n");
60 		cnfparamsPrint(&amp;timezonepblk, pvals);
61 	}
62 	for(i = 0 ; i &lt; timezonepblk.nParams ; ++i) {
63 		if(!pvals[i].bUsed)
64 			continue;
65 		if(!strcmp(timezonepblk.descr[i].name, "id")) {
66 			id = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
67 		} else if(!strcmp(timezonepblk.descr[i].name, "offset")) {
68 			offset = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
69 		} else {
70 			dbgprintf("glblProcessTimezone: program error, non-handled "
71 			  "param '%s'\n", timezonepblk.descr[i].name);
72 		}
73 	}
74 	if(offset == NULL) {
75 		parser_errmsg("offset parameter missing (logic error?), timezone config ignored");
76 		goto done;
77 	}
78 	if(id == NULL) {
79 		parser_errmsg("id parameter missing (logic error?), timezone config ignored");
80 		goto done;
81 	}
82 	if(   strlen((char*)offset) != 6
83 	   || !(offset[0] == '-' || offset[0] == '+')
84 	   || !(isdigit(offset[1]) &amp;&amp; isdigit(offset[2]))
85 	   || offset[3] != ':'
86 	   || !(isdigit(offset[4]) &amp;&amp; isdigit(offset[5]))
87 	  ) {
88 		parser_errmsg("timezone offset has invalid format. Must be +/-hh:mm, e.g. \"-07:00\".");
89 		goto done;
90 	}
91 	offsHour = (offset[1] - '0') * 10 + offset[2] - '0';
92 	offsMin  = (offset[4] - '0') * 10 + offset[5] - '0';
93 	offsMode = offset[0];
94 	if(offsHour &gt; 12 || offsMin &gt; 59) {
95 		parser_errmsg("timezone offset outside of supported range (hours 0..12, minutes 0..59)");
96 		goto done;
97 	}
98 	addTimezoneInfo(loadConf, id, offsMode, offsHour, offsMin);
99 done:
100 	cnfparamvalsDestruct(pvals, &amp;timezonepblk);
101 	free(id);
102 	free(offset);
103 }
104 static int
105 qs_arrcmp_tzinfo(const void *s1, const void *s2)
106 {
107 	return strcmp(((tzinfo_t*)s1)-&gt;id, ((tzinfo_t*)s2)-&gt;id);
108 }
109 void sortTimezones(rsconf_t *cnf)
110 {
111 	if (cnf-&gt;timezones.ntzinfos &gt; 0) {
112 		qsort(cnf-&gt;timezones.tzinfos, cnf-&gt;timezones.ntzinfos,
113 		sizeof(tzinfo_t), qs_arrcmp_tzinfo);
114 	}
115 }
116 void
117 displayTimezones(rsconf_t *cnf)
118 {
119 	if(!Debug)
120 		return;
121 	for(int i = 0 ; i &lt; cnf-&gt;timezones.ntzinfos ; ++i)
122 		dbgprintf("tzinfo: '%s':%c%2.2d:%2.2d\n",
123 			cnf-&gt;timezones.tzinfos[i].id, cnf-&gt;timezones.tzinfos[i].offsMode,
124 			cnf-&gt;timezones.tzinfos[i].offsHour, cnf-&gt;timezones.tzinfos[i].offsMin);
125 }
126 static int
127 bs_arrcmp_tzinfo(const void *s1, const void *s2)
128 {
129 	return strcmp((char*)s1, (char*)((tzinfo_t*)s2)-&gt;id);
130 }
131 tzinfo_t*
132 glblFindTimezone(rsconf_t *cnf, char *id)
133 {
134 	return (tzinfo_t*) bsearch(
135 		id, cnf-&gt;timezones.tzinfos, cnf-&gt;timezones.ntzinfos, sizeof(tzinfo_t), bs_arrcmp_tzinfo);
136 }
137 static void
138 freeTimezone(tzinfo_t *tzinfo)
139 {
140 	free(tzinfo-&gt;id);
141 }
142 void
143 freeTimezones(rsconf_t *cnf)
144 {
145 	for(int i = 0; i &lt; cnf-&gt;timezones.ntzinfos ; ++i)
146 		freeTimezone(&amp;cnf-&gt;timezones.tzinfos[i]);
147 	if (cnf-&gt;timezones.ntzinfos &gt; 0)
148 		free(cnf-&gt;timezones.tzinfos);
149 	cnf-&gt;timezones.tzinfos = NULL;
150 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmciscoios.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdlib.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;ctype.h&gt;
8 #include "conf.h"
9 #include "syslogd-types.h"
10 #include "template.h"
11 #include "msg.h"
12 #include "module-template.h"
13 #include "glbl.h"
14 #include "errmsg.h"
15 #include "parser.h"
16 #include "datetime.h"
17 #include "unicode-helper.h"
18 MODULE_TYPE_PARSER
19 MODULE_TYPE_NOKEEP
20 PARSER_NAME("rsyslog.ciscoios")
21 MODULE_CNFNAME("pmciscoios")
22 DEF_PMOD_STATIC_DATA
23 DEFobjCurrIf(glbl)
24 DEFobjCurrIf(parser)
25 DEFobjCurrIf(datetime)
26 <a name="0"></a>
27 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static struct cnfparamdescr parserpdescr[] = {
28 	{ "present.origin", eCmdHdlrBinary, 0 },
29 	{ "present.xr", eCmdHdlrBinary, 0 }
30 };
31 static struct cnfparamblk parserpblk =
32 	{ CNFPARAMBLK_VERSION,
33 	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
34 	  parserpdescr
35 	};</b></font>
36 struct instanceConf_s {
37 	int bOriginPresent; 	int bXrPresent; };
38 BEGINisCompatibleWithFeature
39 CODESTARTisCompatibleWithFeature
40 	if(eFeat == sFEATUREAutomaticSanitazion)
41 		iRet = RS_RET_OK;
42 	if(eFeat == sFEATUREAutomaticPRIParsing)
43 		iRet = RS_RET_OK;
44 ENDisCompatibleWithFeature
45 static rsRetVal
46 createInstance(instanceConf_t **pinst)
47 {
48 	instanceConf_t *inst;
49 	DEFiRet;
50 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
51 	inst-&gt;bOriginPresent = 0;
52 	inst-&gt;bXrPresent = 0;
53 	*pinst = inst;
54 finalize_it:
55 	RETiRet;
56 }
57 BEGINfreeParserInst
58 CODESTARTfreeParserInst
59 	dbgprintf("pmciscoios: free parser instance %p\n", pInst);
60 ENDfreeParserInst
61 BEGINnewParserInst
62 	struct cnfparamvals *pvals = NULL;
63 	int i;
64 CODESTARTnewParserInst
65 	DBGPRINTF("newParserInst (pmciscoios)\n");
66 	inst = NULL;
67 	CHKiRet(createInstance(&amp;inst));
68 	if(lst == NULL)
69 		FINALIZE;  <a name="1"></a>
70 	if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
71 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
72 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
73 	if(Debug) {
74 		dbgprintf("parser param blk in pmciscoios:\n");
75 		cnfparamsPrint(&amp;parserpblk, pvals);
76 	}
77 	for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
78 		if(!pvals[i].bUsed)
79 			continue;
80 		if(!strcmp(parserpblk.descr[i].name, "present.origin")) {
81 			inst-&gt;bOriginPresent = (int) pvals[i].val.d.n;</b></font>
82 		} else if(!strcmp(parserpblk.descr[i].name, "present.xr")) {
83 			inst-&gt;bXrPresent = (int) pvals[i].val.d.n;
84 		} else {
85 			dbgprintf("pmciscoios: program error, non-handled "
86 				"param '%s'\n", parserpblk.descr[i].name);
87 		}
88 	}
89 finalize_it:
90 CODE_STD_FINALIZERnewParserInst
91 	if(lst != NULL)
92 		cnfparamvalsDestruct(pvals, &amp;parserpblk);
93 	if(iRet != RS_RET_OK)
94 		freeParserInst(inst);
95 ENDnewParserInst
96 BEGINparse2
97 	uchar *p2parse;
98 	long long msgcounter;
99 	int lenMsg;
100 	int i;
101 	int iHostname = 0;
102 	uchar bufParseTAG[512];
103 	uchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE]; CODESTARTparse2
104 	DBGPRINTF("Message will now be parsed by pmciscoios\n");
105 	assert(pMsg != NULL);
106 	assert(pMsg-&gt;pszRawMsg != NULL);
107 	lenMsg = pMsg-&gt;iLenRawMsg - pMsg-&gt;offAfterPRI;
108 	p2parse = pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI; 
109 	msgcounter = 0;
110 	while(lenMsg &gt; 0 &amp;&amp; (*p2parse &gt;= '0' &amp;&amp; *p2parse &lt;= '9') ) {
111 		msgcounter = msgcounter * 10 + *p2parse - '0';
112 		++p2parse, --lenMsg;
113 	}
114 	DBGPRINTF("pmciscoios: msgcntr %lld\n", msgcounter);
115 	if(lenMsg &lt; 2 || *p2parse != ':' || *(p2parse+1) != ' ') {
116 		DBGPRINTF("pmciscoios: fail after seqno: '%s'\n", p2parse);
117 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
118 	}
119 	p2parse += 2;
120 	if(pInst-&gt;bOriginPresent) {
121 		iHostname = 0;
122 		while(   lenMsg &gt; 1
123 		      &amp;&amp; !(*p2parse == ':' &amp;&amp; *(p2parse+1) == ' ')  		      &amp;&amp; iHostname &lt; (int) sizeof(bufParseHOSTNAME) - 1 ) {
124 			bufParseHOSTNAME[iHostname++] = *p2parse++;
125 			--lenMsg;
126 		}
127 		bufParseHOSTNAME[iHostname] = '\0';
128 		if(lenMsg &lt; 2 || *(p2parse+1) != ' ') {
129 			DBGPRINTF("pmciscoios: fail after origin: '%s'\n", p2parse);
130 			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
131 		}
132 		p2parse += 2;
133 	}
134 	if(pInst-&gt;bXrPresent) {
135 		while(   lenMsg &gt; 1
136 			&amp;&amp; !(*p2parse == ':')) {
137 			--lenMsg;
138 			++p2parse;
139 		}
140 		if(lenMsg &lt; 2) {
141 			DBGPRINTF("pmciscoios: fail after XR: '%s'\n", p2parse);
142 			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
143 		}
144 		p2parse += 1;
145 	}
146 	if(p2parse[0] == '*' || p2parse[0] == '.') p2parse++;
147 	if(datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg, PARSE3164_TZSTRING,
148 	NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
149 		if(pMsg-&gt;dfltTZ[0] != '\0')
150 			applyDfltTZ(&amp;pMsg-&gt;tTIMESTAMP, pMsg-&gt;dfltTZ);
151 	} else {
152 		DBGPRINTF("pmciscoios: fail at timestamp: '%s'\n", p2parse);
153 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
154 	}
155 	if(pInst-&gt;bXrPresent) {
156 		while(   lenMsg &gt; 1
157 			&amp;&amp; !(*p2parse == '%')) {
158 			--lenMsg;
159 			p2parse++;
160 		}
161 		if(lenMsg &lt; 2) {
162 			DBGPRINTF("pmciscoios: fail after XR tag search: '%s'\n", p2parse);
163 			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
164 		}
165 	}
166 	if(lenMsg &lt; 1 || *p2parse != '%') {
167 		DBGPRINTF("pmciscoios: fail at tag begin (no '%%'): '%s'\n", p2parse);
168 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
169 	}
170 	i = 0;
171 	while(lenMsg &gt; 0 &amp;&amp; *p2parse != ':' &amp;&amp; *p2parse != ' ' &amp;&amp; i &lt; (int) sizeof(bufParseTAG) - 2) {
172 		bufParseTAG[i++] = *p2parse++;
173 		--lenMsg;
174 	}
175 	if(pInst-&gt;bXrPresent) p2parse++;
176 	if(lenMsg &lt; 2 || *p2parse != ':' || *(p2parse+1) != ' ') {
177 		DBGPRINTF("pmciscoios: fail after tag: '%s'\n", p2parse);
178 		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
179 	}
180 	++p2parse;
181 	bufParseTAG[i++] = ':';
182 	bufParseTAG[i] = '\0';	
183 	MsgSetTAG(pMsg, bufParseTAG, i);
184 	if(pInst-&gt;bOriginPresent)
185 		MsgSetHOSTNAME(pMsg, bufParseHOSTNAME, iHostname);
186 	MsgSetMSGoffs(pMsg, p2parse - pMsg-&gt;pszRawMsg);
187 	setProtocolVersion(pMsg, MSG_LEGACY_PROTOCOL);
188 finalize_it:
189 ENDparse2
190 BEGINmodExit
191 CODESTARTmodExit
192 	objRelease(glbl, CORE_COMPONENT);
193 	objRelease(parser, CORE_COMPONENT);
194 	objRelease(datetime, CORE_COMPONENT);
195 ENDmodExit
196 BEGINqueryEtryPt
197 CODESTARTqueryEtryPt
198 CODEqueryEtryPt_STD_PMOD2_QUERIES
199 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
200 ENDqueryEtryPt
201 BEGINmodInit()
202 CODESTARTmodInit
203 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
204 	CHKiRet(objUse(glbl, CORE_COMPONENT));
205 	CHKiRet(objUse(parser, CORE_COMPONENT));
206 	CHKiRet(objUse(datetime, CORE_COMPONENT));
207 	DBGPRINTF("pmciscoios parser init called\n");
208 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
