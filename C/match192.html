<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for timezones.c & pmciscoios.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for timezones.c & pmciscoios.c
      </h3>
      <h1 align="center">
        18.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>timezones.c (19.607843%)<TH>pmciscoios.c (17.647058%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match192-0.html#0',2,'match192-1.html#0',3)" NAME="0">(40-48)<TD><A HREF="javascript:ZweiFrames('match192-0.html#0',2,'match192-1.html#0',3)" NAME="0">(55-63)</A><TD ALIGN=center><FONT COLOR="#ff0000">17</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match192-0.html#1',2,'match192-1.html#1',3)" NAME="1">(89-99)<TD><A HREF="javascript:ZweiFrames('match192-0.html#1',2,'match192-1.html#1',3)" NAME="1">(116-127)</A><TD ALIGN=center><FONT COLOR="#c30000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>timezones.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* timezones.c
 * Support for timezones in RainerScript.
 *
 * Copyright 2022 Attila Lakatos and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *		 http://www.apache.org/licenses/LICENSE-2.0
 *		 -or-
 *		 see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include &quot;config.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdint.h&gt;
#include &lt;errno.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parserif.h&quot;
#include &quot;rainerscript.h&quot;
#include &quot;srUtils.h&quot;
<A NAME="0"></A>#include &quot;rsconf.h&quot;


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match192-1.html#0',3,'match192-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static struct cnfparamdescr timezonecnfparamdescr[] = {
	{ &quot;id&quot;, eCmdHdlrString, CNFPARAM_REQUIRED},
	{ &quot;offset&quot;, eCmdHdlrGetWord, CNFPARAM_REQUIRED }
};
static struct cnfparamblk timezonepblk = {
	CNFPARAMBLK_VERSION,
	sizeof(timezonecnfparamdescr)/sizeof(struct cnfparamdescr),
	timezonecnfparamdescr
};</B></FONT>

/* Note: this function is NOT thread-safe!
 * This is currently not needed as used only during
 * initialization.
 */
static rsRetVal
addTimezoneInfo(rsconf_t *cnf, uchar *tzid, char offsMode, int8_t offsHour, int8_t offsMin)
{
	DEFiRet;
	tzinfo_t *newti;
	CHKmalloc(newti = realloc(cnf-&gt;timezones.tzinfos, (cnf-&gt;timezones.ntzinfos+1)*sizeof(tzinfo_t)));
	if((newti[cnf-&gt;timezones.ntzinfos].id = strdup((char*)tzid)) == NULL) {
		free(newti);
		DBGPRINTF(&quot;addTimezoneInfo: strdup failed with OOM\n&quot;);
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	newti[cnf-&gt;timezones.ntzinfos].offsMode = offsMode;
	newti[cnf-&gt;timezones.ntzinfos].offsHour = offsHour;
	newti[cnf-&gt;timezones.ntzinfos].offsMin = offsMin;
	++cnf-&gt;timezones.ntzinfos, cnf-&gt;timezones.tzinfos = newti;
finalize_it:
	RETiRet;
}

void
glblProcessTimezone(struct cnfobj *o)
{
	struct cnfparamvals *pvals;
	uchar *id = NULL;
	uchar *offset = NULL;
	char offsMode;
	int8_t offsHour;
	int8_t offsMin;
	int i;

	pvals = nvlstGetParams(o-&gt;nvlst, &amp;timezonepblk, NULL);
	if(pvals == NULL) {
<A NAME="1"></A>		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing timezone &quot;
				&quot;config parameters&quot;);
		goto done;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match192-1.html#1',3,'match192-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	}
	if(Debug) {
		dbgprintf(&quot;timezone param blk after glblProcessTimezone:\n&quot;);
		cnfparamsPrint(&amp;timezonepblk, pvals);
	}

	for(i = 0 ; i &lt; timezonepblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(timezonepblk.descr[i].name, &quot;id&quot;)) {
			id = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
		} else if(!strcmp(timezonepblk.descr[i].name, &quot;offset&quot;)) {
			offset = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;glblProcessTimezone: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, timezonepblk.descr[i].name);
		}
	}

	/* note: the following two checks for NULL are not strictly necessary
	 * as these are required parameters for the config block. But we keep
	 * them to make the clang static analyzer happy, which also helps
	 * guard against logic errors.
	 */
	if(offset == NULL) {
		parser_errmsg(&quot;offset parameter missing (logic error?), timezone config ignored&quot;);
		goto done;
	}
	if(id == NULL) {
		parser_errmsg(&quot;id parameter missing (logic error?), timezone config ignored&quot;);
		goto done;
	}

	if(   strlen((char*)offset) != 6
	   || !(offset[0] == '-' || offset[0] == '+')
	   || !(isdigit(offset[1]) &amp;&amp; isdigit(offset[2]))
	   || offset[3] != ':'
	   || !(isdigit(offset[4]) &amp;&amp; isdigit(offset[5]))
	  ) {
		parser_errmsg(&quot;timezone offset has invalid format. Must be +/-hh:mm, e.g. \&quot;-07:00\&quot;.&quot;);
		goto done;
	}

	offsHour = (offset[1] - '0') * 10 + offset[2] - '0';
	offsMin  = (offset[4] - '0') * 10 + offset[5] - '0';
	offsMode = offset[0];

	if(offsHour &gt; 12 || offsMin &gt; 59) {
		parser_errmsg(&quot;timezone offset outside of supported range (hours 0..12, minutes 0..59)&quot;);
		goto done;
	}

	addTimezoneInfo(loadConf, id, offsMode, offsHour, offsMin);

done:
	cnfparamvalsDestruct(pvals, &amp;timezonepblk);
	free(id);
	free(offset);
}

/* comparison function for qsort() and string array compare
 * this is for the string lookup table type
 */
static int
qs_arrcmp_tzinfo(const void *s1, const void *s2)
{
	return strcmp(((tzinfo_t*)s1)-&gt;id, ((tzinfo_t*)s2)-&gt;id);
}

void sortTimezones(rsconf_t *cnf)
{
	if (cnf-&gt;timezones.ntzinfos &gt; 0) {
		qsort(cnf-&gt;timezones.tzinfos, cnf-&gt;timezones.ntzinfos,
		sizeof(tzinfo_t), qs_arrcmp_tzinfo);
	}
}

void
displayTimezones(rsconf_t *cnf)
{
	if(!Debug)
		return;
	for(int i = 0 ; i &lt; cnf-&gt;timezones.ntzinfos ; ++i)
		dbgprintf(&quot;tzinfo: '%s':%c%2.2d:%2.2d\n&quot;,
			cnf-&gt;timezones.tzinfos[i].id, cnf-&gt;timezones.tzinfos[i].offsMode,
			cnf-&gt;timezones.tzinfos[i].offsHour, cnf-&gt;timezones.tzinfos[i].offsMin);
}

static int
bs_arrcmp_tzinfo(const void *s1, const void *s2)
{
	return strcmp((char*)s1, (char*)((tzinfo_t*)s2)-&gt;id);
}

/* returns matching timezone info or NULL if no entry exists */
tzinfo_t*
glblFindTimezone(rsconf_t *cnf, char *id)
{
	return (tzinfo_t*) bsearch(
		id, cnf-&gt;timezones.tzinfos, cnf-&gt;timezones.ntzinfos, sizeof(tzinfo_t), bs_arrcmp_tzinfo);
}

static void
freeTimezone(tzinfo_t *tzinfo)
{
	free(tzinfo-&gt;id);
}

void
freeTimezones(rsconf_t *cnf)
{
	for(int i = 0; i &lt; cnf-&gt;timezones.ntzinfos ; ++i)
		freeTimezone(&amp;cnf-&gt;timezones.tzinfos[i]);
	if (cnf-&gt;timezones.ntzinfos &gt; 0)
		free(cnf-&gt;timezones.tzinfos);
	cnf-&gt;timezones.tzinfos = NULL;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmciscoios.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* pmrciscoios.c
 * This is a parser module for CISCO IOS &quot;syslog&quot; format.
 *
 * File begun on 2014-07-07 by RGerhards
 *
 * Copyright 2014-2015 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;template.h&quot;
#include &quot;msg.h&quot;
#include &quot;module-template.h&quot;
#include &quot;glbl.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parser.h&quot;
#include &quot;datetime.h&quot;
#include &quot;unicode-helper.h&quot;

MODULE_TYPE_PARSER
MODULE_TYPE_NOKEEP
PARSER_NAME(&quot;rsyslog.ciscoios&quot;)
MODULE_CNFNAME(&quot;pmciscoios&quot;)

/* internal structures */
DEF_PMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)
<A NAME="0"></A>

/* parser instance parameters */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match192-0.html#0',2,'match192-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static struct cnfparamdescr parserpdescr[] = {
	{ &quot;present.origin&quot;, eCmdHdlrBinary, 0 },
	{ &quot;present.xr&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk parserpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
	  parserpdescr
	};</B></FONT>

struct instanceConf_s {
	int bOriginPresent; /* is ORIGIN field present? */
	int bXrPresent; /* is XR? */
};

BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATUREAutomaticSanitazion)
		iRet = RS_RET_OK;
	if(eFeat == sFEATUREAutomaticPRIParsing)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;bOriginPresent = 0;
	inst-&gt;bXrPresent = 0;
	*pinst = inst;
finalize_it:
	RETiRet;
}


BEGINfreeParserInst
CODESTARTfreeParserInst
	dbgprintf(&quot;pmciscoios: free parser instance %p\n&quot;, pInst);
ENDfreeParserInst


BEGINnewParserInst
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTnewParserInst
	DBGPRINTF(&quot;newParserInst (pmciscoios)\n&quot;);

	inst = NULL;
	CHKiRet(createInstance(&amp;inst));

	if(lst == NULL)
		FINALIZE;  /* just set defaults, no param block! */
<A NAME="1"></A>
	if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match192-0.html#1',2,'match192-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	}

	if(Debug) {
		dbgprintf(&quot;parser param blk in pmciscoios:\n&quot;);
		cnfparamsPrint(&amp;parserpblk, pvals);
	}

	for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(parserpblk.descr[i].name, &quot;present.origin&quot;)) {
			inst-&gt;bOriginPresent = (int) pvals[i].val.d.n;</B></FONT>
		} else if(!strcmp(parserpblk.descr[i].name, &quot;present.xr&quot;)) {
			inst-&gt;bXrPresent = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;pmciscoios: program error, non-handled &quot;
				&quot;param '%s'\n&quot;, parserpblk.descr[i].name);
		}
	}
finalize_it:
CODE_STD_FINALIZERnewParserInst
	if(lst != NULL)
		cnfparamvalsDestruct(pvals, &amp;parserpblk);
	if(iRet != RS_RET_OK)
		freeParserInst(inst);
ENDnewParserInst


BEGINparse2
	uchar *p2parse;
	long long msgcounter;
	int lenMsg;
	int i;
	int iHostname = 0;
	uchar bufParseTAG[512];
	uchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE]; /* used by origin */
CODESTARTparse2
	DBGPRINTF(&quot;Message will now be parsed by pmciscoios\n&quot;);
	assert(pMsg != NULL);
	assert(pMsg-&gt;pszRawMsg != NULL);
	lenMsg = pMsg-&gt;iLenRawMsg - pMsg-&gt;offAfterPRI;
	/* note: offAfterPRI is already the number of PRI chars (do not add one!) */
	p2parse = pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI; /* point to start of text, after PRI */

	/* first obtain the MESSAGE COUNTER. It must be numeric up until
	 * the &quot;: &quot; terminator sequence
	 */
	msgcounter = 0;
	while(lenMsg &gt; 0 &amp;&amp; (*p2parse &gt;= '0' &amp;&amp; *p2parse &lt;= '9') ) {
		msgcounter = msgcounter * 10 + *p2parse - '0';
		++p2parse, --lenMsg;
	}
	DBGPRINTF(&quot;pmciscoios: msgcntr %lld\n&quot;, msgcounter);

	/* delimiter check */
	if(lenMsg &lt; 2 || *p2parse != ':' || *(p2parse+1) != ' ') {
		DBGPRINTF(&quot;pmciscoios: fail after seqno: '%s'\n&quot;, p2parse);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}
	p2parse += 2;

	/* ORIGIN (optional) */
	if(pInst-&gt;bOriginPresent) {
		iHostname = 0;
		while(   lenMsg &gt; 1
		      &amp;&amp; !(*p2parse == ':' &amp;&amp; *(p2parse+1) == ' ')  /* IPv6 is e.g. &quot;::1&quot; (loopback) */
		      &amp;&amp; iHostname &lt; (int) sizeof(bufParseHOSTNAME) - 1 ) {
			bufParseHOSTNAME[iHostname++] = *p2parse++;
			--lenMsg;
		}
		bufParseHOSTNAME[iHostname] = '\0';
		/* delimiter check */
		if(lenMsg &lt; 2 || *(p2parse+1) != ' ') {
			DBGPRINTF(&quot;pmciscoios: fail after origin: '%s'\n&quot;, p2parse);
			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
		}
		p2parse += 2;
	}

	/* XR RSP (optional) */
	if(pInst-&gt;bXrPresent) {
		while(   lenMsg &gt; 1
			&amp;&amp; !(*p2parse == ':')) {
			--lenMsg;
			++p2parse;
		}
		/* delimiter check */
		if(lenMsg &lt; 2) {
			DBGPRINTF(&quot;pmciscoios: fail after XR: '%s'\n&quot;, p2parse);
			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
		}
		p2parse += 1;
	}

	/* TIMESTAMP */
	if(p2parse[0] == '*' || p2parse[0] == '.') p2parse++;
	if(datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg, PARSE3164_TZSTRING,
	NO_PERMIT_YEAR_AFTER_TIME) == RS_RET_OK) {
		if(pMsg-&gt;dfltTZ[0] != '\0')
			applyDfltTZ(&amp;pMsg-&gt;tTIMESTAMP, pMsg-&gt;dfltTZ);
	} else {
		DBGPRINTF(&quot;pmciscoios: fail at timestamp: '%s'\n&quot;, p2parse);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}
	/* Note: date parser strips &quot;: &quot;, so we cannot do the delimiter check here */

	/* XR RSP (optional) */
	if(pInst-&gt;bXrPresent) {
		while(   lenMsg &gt; 1
			&amp;&amp; !(*p2parse == '%')) {
			--lenMsg;
			p2parse++;
		}
		/* delimiter check */
		if(lenMsg &lt; 2) {
			DBGPRINTF(&quot;pmciscoios: fail after XR tag search: '%s'\n&quot;, p2parse);
			ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
		}
	}

	/* parse SYSLOG TAG. must always start with '%', else we have a field mismatch */
	if(lenMsg &lt; 1 || *p2parse != '%') {
		DBGPRINTF(&quot;pmciscoios: fail at tag begin (no '%%'): '%s'\n&quot;, p2parse);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}

	i = 0;
	while(lenMsg &gt; 0 &amp;&amp; *p2parse != ':' &amp;&amp; *p2parse != ' ' &amp;&amp; i &lt; (int) sizeof(bufParseTAG) - 2) {
		bufParseTAG[i++] = *p2parse++;
		--lenMsg;
	}
	/* delimiter check */
	if(pInst-&gt;bXrPresent) p2parse++;
	if(lenMsg &lt; 2 || *p2parse != ':' || *(p2parse+1) != ' ') {
		DBGPRINTF(&quot;pmciscoios: fail after tag: '%s'\n&quot;, p2parse);
		ABORT_FINALIZE(RS_RET_COULD_NOT_PARSE);
	}

	++p2parse;
	bufParseTAG[i++] = ':';
	bufParseTAG[i] = '\0';	/* terminate string */

	/* if we reach this point, we have a wellformed message and can persist the values */
	MsgSetTAG(pMsg, bufParseTAG, i);
	/* if bOriginPresent !=0 iHostname gets initialized */
	if(pInst-&gt;bOriginPresent)
		MsgSetHOSTNAME(pMsg, bufParseHOSTNAME, iHostname);
	MsgSetMSGoffs(pMsg, p2parse - pMsg-&gt;pszRawMsg);
	setProtocolVersion(pMsg, MSG_LEGACY_PROTOCOL);
finalize_it:
ENDparse2


BEGINmodExit
CODESTARTmodExit
	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(parser, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_PMOD2_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));

	DBGPRINTF(&quot;pmciscoios parser init called\n&quot;);
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
