
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dwebp.c</h3>
            <pre><code>1  #include &lt;assert.h&gt;
2  #include &lt;stdio.h&gt;
3  #include &lt;stdlib.h&gt;
4  #include &lt;string.h&gt;
5  #ifdef HAVE_CONFIG_H
6  #include &quot;webp/config.h&quot;
7  #endif
8  #include &quot;../examples/example_util.h&quot;
9  #include &quot;../imageio/image_enc.h&quot;
10  #include &quot;../imageio/webpdec.h&quot;
11  #include &quot;./stopwatch.h&quot;
12  #include &quot;./unicode.h&quot;
13  static int verbose = 0;
14  static int quiet = 0;
15  #ifndef WEBP_DLL
16  #ifdef __cplusplus
<span onclick='openModal()' class='match'>17  extern &quot;C&quot; {
18  #endif
19  extern void* VP8GetCPUInfo;   
20  #ifdef __cplusplus
21  }    
22  #endif
23  #endif  
24  static int SaveOutput(const WebPDecBuffer* const buffer,
</span>25                        WebPOutputFileFormat format, const char* const out_file) {
26    const int use_stdout = (out_file != NULL) &amp;&amp; !WSTRCMP(out_file, &quot;-&quot;);
27    int ok = 1;
28    Stopwatch stop_watch;
29    if (verbose) {
30      StopwatchReset(&amp;stop_watch);
31    }
32    ok = WebPSaveImage(buffer, format, out_file);
33    if (ok) {
34      if (!quiet) {
35        if (use_stdout) {
36          fprintf(stderr, &quot;Saved to stdout\n&quot;);
37        } else {
38          WFPRINTF(stderr, &quot;Saved file %s\n&quot;, (const W_CHAR*)out_file);
39        }
40      }
41      if (verbose) {
42        const double write_time = StopwatchReadAndReset(&amp;stop_watch);
43        fprintf(stderr, &quot;Time to write output: %.3fs\n&quot;, write_time);
44      }
45    } else {
46      if (use_stdout) {
47        fprintf(stderr, &quot;Error writing to stdout !!\n&quot;);
48      } else {
49        WFPRINTF(stderr, &quot;Error writing file %s !!\n&quot;, (const W_CHAR*)out_file);
50      }
51    }
52    return ok;
53  }
54  static void Help(void) {
55    printf(&quot;Usage: dwebp in_file [options] [-o out_file]\n\n&quot;
56           &quot;Decodes the WebP image file to PNG format [Default]\n&quot;
57           &quot;Use following options to convert into alternate image formats:\n&quot;
58           &quot;  -pam ......... save the raw RGBA samples as a color PAM\n&quot;
59           &quot;  -ppm ......... save the raw RGB samples as a color PPM\n&quot;
60           &quot;  -bmp ......... save as uncompressed BMP format\n&quot;
61           &quot;  -tiff ........ save as uncompressed TIFF format\n&quot;
62           &quot;  -pgm ......... save the raw YUV samples as a grayscale PGM\n&quot;
63           &quot;                 file with IMC4 layout\n&quot;
64           &quot;  -yuv ......... save the raw YUV samples in flat layout\n&quot;
65           &quot;\n&quot;
66           &quot; Other options are:\n&quot;
67           &quot;  -version ..... print version number and exit\n&quot;
68           &quot;  -nofancy ..... don&#x27;t use the fancy YUV420 upscaler\n&quot;
69           &quot;  -nofilter .... disable in-loop filtering\n&quot;
70           &quot;  -nodither .... disable dithering\n&quot;
71           &quot;  -dither &lt;d&gt; .. dithering strength (in 0..100)\n&quot;
72           &quot;  -alpha_dither  use alpha-plane dithering if needed\n&quot;
73           &quot;  -mt .......... use multi-threading\n&quot;
74           &quot;  -crop &lt;x&gt; &lt;y&gt; &lt;w&gt; &lt;h&gt; ... crop output with the given rectangle\n&quot;
75           &quot;  -resize &lt;w&gt; &lt;h&gt; ......... scale the output (*after* any cropping)\n&quot;
76           &quot;  -flip ........ flip the output vertically\n&quot;
77           &quot;  -alpha ....... only save the alpha plane\n&quot;
78           &quot;  -incremental . use incremental decoding (useful for tests)\n&quot;
79           &quot;  -h ........... this help message\n&quot;
80           &quot;  -v ........... verbose (e.g. print encoding/decoding times)\n&quot;
81           &quot;  -quiet ....... quiet mode, don&#x27;t print anything\n&quot;
82  #ifndef WEBP_DLL
83           &quot;  -noasm ....... disable all assembly optimizations\n&quot;
84  #endif
85          );
86  }
87  static const char* const kFormatType[] = {
88    &quot;unspecified&quot;, &quot;lossy&quot;, &quot;lossless&quot;
89  };
90  static uint8_t* AllocateExternalBuffer(WebPDecoderConfig* config,
91                                         WebPOutputFileFormat format,
92                                         int use_external_memory) {
93    uint8_t* external_buffer = NULL;
94    WebPDecBuffer* const output_buffer = &amp;config-&gt;output;
95    int w = config-&gt;input.width;
96    int h = config-&gt;input.height;
97    if (config-&gt;options.use_scaling) {
98      w = config-&gt;options.scaled_width;
99      h = config-&gt;options.scaled_height;
100    } else if (config-&gt;options.use_cropping) {
101      w = config-&gt;options.crop_width;
102      h = config-&gt;options.crop_height;
103    }
104    if (format &gt;= RGB &amp;&amp; format &lt;= rgbA_4444) {
105      const int bpp = (format == RGB || format == BGR) ? 3
106                    : (format == RGBA_4444 || format == rgbA_4444 ||
107                       format == RGB_565) ? 2
108                    : 4;
109      uint32_t stride = bpp * w + 7;   
110      external_buffer = (uint8_t*)WebPMalloc(stride * h);
111      if (external_buffer == NULL) return NULL;
112      output_buffer-&gt;u.RGBA.stride = stride;
113      output_buffer-&gt;u.RGBA.size = stride * h;
114      output_buffer-&gt;u.RGBA.rgba = external_buffer;
115    } else {    
116      const int has_alpha = WebPIsAlphaMode(output_buffer-&gt;colorspace);
117      uint8_t* tmp;
118      uint32_t stride = w + 3;
119      uint32_t uv_stride = (w + 1) / 2 + 13;
120      uint32_t total_size = stride * h * (has_alpha ? 2 : 1)
121                          + 2 * uv_stride * (h + 1) / 2;
122      assert(format &gt;= YUV &amp;&amp; format &lt;= YUVA);
123      external_buffer = (uint8_t*)WebPMalloc(total_size);
124      if (external_buffer == NULL) return NULL;
125      tmp = external_buffer;
126      output_buffer-&gt;u.YUVA.y = tmp;
127      output_buffer-&gt;u.YUVA.y_stride = stride;
128      output_buffer-&gt;u.YUVA.y_size = stride * h;
129      tmp += output_buffer-&gt;u.YUVA.y_size;
130      if (has_alpha) {
131        output_buffer-&gt;u.YUVA.a = tmp;
132        output_buffer-&gt;u.YUVA.a_stride = stride;
133        output_buffer-&gt;u.YUVA.a_size = stride * h;
134        tmp += output_buffer-&gt;u.YUVA.a_size;
135      } else {
136        output_buffer-&gt;u.YUVA.a = NULL;
137        output_buffer-&gt;u.YUVA.a_stride = 0;
138      }
139      output_buffer-&gt;u.YUVA.u = tmp;
140      output_buffer-&gt;u.YUVA.u_stride = uv_stride;
141      output_buffer-&gt;u.YUVA.u_size = uv_stride * (h + 1) / 2;
142      tmp += output_buffer-&gt;u.YUVA.u_size;
143      output_buffer-&gt;u.YUVA.v = tmp;
144      output_buffer-&gt;u.YUVA.v_stride = uv_stride;
145      output_buffer-&gt;u.YUVA.v_size = uv_stride * (h + 1) / 2;
146      tmp += output_buffer-&gt;u.YUVA.v_size;
147      assert(tmp &lt;= external_buffer + total_size);
148    }
149    output_buffer-&gt;is_external_memory = use_external_memory;
150    return external_buffer;
151  }
152  int main(int argc, const char* argv[]) {
153    int ok = 0;
154    const char* in_file = NULL;
155    const char* out_file = NULL;
156    WebPDecoderConfig config;
157    WebPDecBuffer* const output_buffer = &amp;config.output;
158    WebPBitstreamFeatures* const bitstream = &amp;config.input;
159    WebPOutputFileFormat format = PNG;
160    uint8_t* external_buffer = NULL;
161    int use_external_memory = 0;
162    const uint8_t* data = NULL;
163    int incremental = 0;
164    int c;
165    INIT_WARGV(argc, argv);
166    if (!WebPInitDecoderConfig(&amp;config)) {
167      fprintf(stderr, &quot;Library version mismatch!\n&quot;);
168      FREE_WARGV_AND_RETURN(-1);
169    }
170    for (c = 1; c &lt; argc; ++c) {
171      int parse_error = 0;
172      if (!strcmp(argv[c], &quot;-h&quot;) || !strcmp(argv[c], &quot;-help&quot;)) {
173        Help();
174        FREE_WARGV_AND_RETURN(0);
175      } else if (!strcmp(argv[c], &quot;-o&quot;) &amp;&amp; c &lt; argc - 1) {
176        out_file = (const char*)GET_WARGV(argv, ++c);
177      } else if (!strcmp(argv[c], &quot;-alpha&quot;)) {
178        format = ALPHA_PLANE_ONLY;
179      } else if (!strcmp(argv[c], &quot;-nofancy&quot;)) {
180        config.options.no_fancy_upsampling = 1;
181      } else if (!strcmp(argv[c], &quot;-nofilter&quot;)) {
182        config.options.bypass_filtering = 1;
183      } else if (!strcmp(argv[c], &quot;-pam&quot;)) {
184        format = PAM;
185      } else if (!strcmp(argv[c], &quot;-ppm&quot;)) {
186        format = PPM;
187      } else if (!strcmp(argv[c], &quot;-bmp&quot;)) {
188        format = BMP;
189      } else if (!strcmp(argv[c], &quot;-tiff&quot;)) {
190        format = TIFF;
191      } else if (!strcmp(argv[c], &quot;-quiet&quot;)) {
192        quiet = 1;
193      } else if (!strcmp(argv[c], &quot;-version&quot;)) {
194        const int version = WebPGetDecoderVersion();
195        printf(&quot;%d.%d.%d\n&quot;,
196               (version &gt;&gt; 16) &amp; 0xff, (version &gt;&gt; 8) &amp; 0xff, version &amp; 0xff);
197        FREE_WARGV_AND_RETURN(0);
198      } else if (!strcmp(argv[c], &quot;-pgm&quot;)) {
199        format = PGM;
200      } else if (!strcmp(argv[c], &quot;-yuv&quot;)) {
201        format = RAW_YUV;
202      } else if (!strcmp(argv[c], &quot;-pixel_format&quot;) &amp;&amp; c &lt; argc - 1) {
203        const char* const fmt = argv[++c];
204        if      (!strcmp(fmt, &quot;RGB&quot;))  format = RGB;
205        else if (!strcmp(fmt, &quot;RGBA&quot;)) format = RGBA;
206        else if (!strcmp(fmt, &quot;BGR&quot;))  format = BGR;
207        else if (!strcmp(fmt, &quot;BGRA&quot;)) format = BGRA;
208        else if (!strcmp(fmt, &quot;ARGB&quot;)) format = ARGB;
209        else if (!strcmp(fmt, &quot;RGBA_4444&quot;)) format = RGBA_4444;
210        else if (!strcmp(fmt, &quot;RGB_565&quot;)) format = RGB_565;
211        else if (!strcmp(fmt, &quot;rgbA&quot;)) format = rgbA;
212        else if (!strcmp(fmt, &quot;bgrA&quot;)) format = bgrA;
213        else if (!strcmp(fmt, &quot;Argb&quot;)) format = Argb;
214        else if (!strcmp(fmt, &quot;rgbA_4444&quot;)) format = rgbA_4444;
215        else if (!strcmp(fmt, &quot;YUV&quot;))  format = YUV;
216        else if (!strcmp(fmt, &quot;YUVA&quot;)) format = YUVA;
217        else {
218          fprintf(stderr, &quot;Can&#x27;t parse pixel_format %s\n&quot;, fmt);
219          parse_error = 1;
220        }
221      } else if (!strcmp(argv[c], &quot;-external_memory&quot;) &amp;&amp; c &lt; argc - 1) {
222        use_external_memory = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
223        parse_error |= (use_external_memory &gt; 2 || use_external_memory &lt; 0);
224        if (parse_error) {
225          fprintf(stderr, &quot;Can&#x27;t parse &#x27;external_memory&#x27; value %s\n&quot;, argv[c]);
226        }
227      } else if (!strcmp(argv[c], &quot;-mt&quot;)) {
228        config.options.use_threads = 1;
229      } else if (!strcmp(argv[c], &quot;-alpha_dither&quot;)) {
230        config.options.alpha_dithering_strength = 100;
231      } else if (!strcmp(argv[c], &quot;-nodither&quot;)) {
232        config.options.dithering_strength = 0;
233      } else if (!strcmp(argv[c], &quot;-dither&quot;) &amp;&amp; c &lt; argc - 1) {
234        config.options.dithering_strength =
235            ExUtilGetInt(argv[++c], 0, &amp;parse_error);
236      } else if (!strcmp(argv[c], &quot;-crop&quot;) &amp;&amp; c &lt; argc - 4) {
237        config.options.use_cropping = 1;
238        config.options.crop_left   = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
239        config.options.crop_top    = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
240        config.options.crop_width  = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
241        config.options.crop_height = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
242      } else if ((!strcmp(argv[c], &quot;-scale&quot;) || !strcmp(argv[c], &quot;-resize&quot;)) &amp;&amp;
243                 c &lt; argc - 2) {  
244        config.options.use_scaling = 1;
245        config.options.scaled_width  = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
246        config.options.scaled_height = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
247      } else if (!strcmp(argv[c], &quot;-flip&quot;)) {
248        config.options.flip = 1;
249      } else if (!strcmp(argv[c], &quot;-v&quot;)) {
250        verbose = 1;
251  #ifndef WEBP_DLL
252      } else if (!strcmp(argv[c], &quot;-noasm&quot;)) {
253        VP8GetCPUInfo = NULL;
254  #endif
255      } else if (!strcmp(argv[c], &quot;-incremental&quot;)) {
256        incremental = 1;
257      } else if (!strcmp(argv[c], &quot;--&quot;)) {
258        if (c &lt; argc - 1) in_file = (const char*)GET_WARGV(argv, ++c);
259        break;
260      } else if (argv[c][0] == &#x27;-&#x27;) {
261        fprintf(stderr, &quot;Unknown option &#x27;%s&#x27;\n&quot;, argv[c]);
262        Help();
263        FREE_WARGV_AND_RETURN(-1);
264      } else {
265        in_file = (const char*)GET_WARGV(argv, c);
266      }
267      if (parse_error) {
268        Help();
269        FREE_WARGV_AND_RETURN(-1);
270      }
271    }
272    if (in_file == NULL) {
273      fprintf(stderr, &quot;missing input file!!\n&quot;);
274      Help();
275      FREE_WARGV_AND_RETURN(-1);
276    }
277    if (quiet) verbose = 0;
278    {
279      VP8StatusCode status = VP8_STATUS_OK;
280      size_t data_size = 0;
281      if (!LoadWebP(in_file, &amp;data, &amp;data_size, bitstream)) {
282        FREE_WARGV_AND_RETURN(-1);
283      }
284      switch (format) {
285        case PNG:
286  #ifdef HAVE_WINCODEC_H
287          output_buffer-&gt;colorspace = bitstream-&gt;has_alpha ? MODE_BGRA : MODE_BGR;
288  #else
289          output_buffer-&gt;colorspace = bitstream-&gt;has_alpha ? MODE_RGBA : MODE_RGB;
290  #endif
291          break;
292        case PAM:
293          output_buffer-&gt;colorspace = MODE_RGBA;
294          break;
295        case PPM:
296          output_buffer-&gt;colorspace = MODE_RGB;  
297          break;
298        case BMP:
299          output_buffer-&gt;colorspace = bitstream-&gt;has_alpha ? MODE_BGRA : MODE_BGR;
300          break;
301        case TIFF:
302          output_buffer-&gt;colorspace = bitstream-&gt;has_alpha ? MODE_RGBA : MODE_RGB;
303          break;
304        case PGM:
305        case RAW_YUV:
306          output_buffer-&gt;colorspace = bitstream-&gt;has_alpha ? MODE_YUVA : MODE_YUV;
307          break;
308        case ALPHA_PLANE_ONLY:
309          output_buffer-&gt;colorspace = MODE_YUVA;
310          break;
311        case RGB: output_buffer-&gt;colorspace = MODE_RGB; break;
312        case RGBA: output_buffer-&gt;colorspace = MODE_RGBA; break;
313        case BGR: output_buffer-&gt;colorspace = MODE_BGR; break;
314        case BGRA: output_buffer-&gt;colorspace = MODE_BGRA; break;
315        case ARGB: output_buffer-&gt;colorspace = MODE_ARGB; break;
316        case RGBA_4444: output_buffer-&gt;colorspace = MODE_RGBA_4444; break;
317        case RGB_565: output_buffer-&gt;colorspace = MODE_RGB_565; break;
318        case rgbA: output_buffer-&gt;colorspace = MODE_rgbA; break;
319        case bgrA: output_buffer-&gt;colorspace = MODE_bgrA; break;
320        case Argb: output_buffer-&gt;colorspace = MODE_Argb; break;
321        case rgbA_4444: output_buffer-&gt;colorspace = MODE_rgbA_4444; break;
322        case YUV: output_buffer-&gt;colorspace = MODE_YUV; break;
323        case YUVA: output_buffer-&gt;colorspace = MODE_YUVA; break;
324        default: goto Exit;
325      }
326      if (use_external_memory &gt; 0 &amp;&amp; format &gt;= RGB) {
327        external_buffer = AllocateExternalBuffer(&amp;config, format,
328                                                 use_external_memory);
329        if (external_buffer == NULL) goto Exit;
330      }
331      {
332        Stopwatch stop_watch;
333        if (verbose) StopwatchReset(&amp;stop_watch);
334        if (incremental) {
335          status = DecodeWebPIncremental(data, data_size, &amp;config);
336        } else {
337          status = DecodeWebP(data, data_size, &amp;config);
338        }
339        if (verbose) {
340          const double decode_time = StopwatchReadAndReset(&amp;stop_watch);
341          fprintf(stderr, &quot;Time to decode picture: %.3fs\n&quot;, decode_time);
342        }
343      }
344      ok = (status == VP8_STATUS_OK);
345      if (!ok) {
346        PrintWebPError(in_file, status);
347        goto Exit;
348      }
349    }
350    if (out_file != NULL) {
351      if (!quiet) {
352        WFPRINTF(stderr, &quot;Decoded %s.&quot;, (const W_CHAR*)in_file);
353        fprintf(stderr, &quot; Dimensions: %d x %d %s. Format: %s. Now saving...\n&quot;,
354                output_buffer-&gt;width, output_buffer-&gt;height,
355                bitstream-&gt;has_alpha ? &quot; (with alpha)&quot; : &quot;&quot;,
356                kFormatType[bitstream-&gt;format]);
357      }
358      ok = SaveOutput(output_buffer, format, out_file);
359    } else {
360      if (!quiet) {
361        WFPRINTF(stderr, &quot;File %s can be decoded &quot;, (const W_CHAR*)in_file);
362        fprintf(stderr, &quot;(dimensions: %d x %d %s. Format: %s).\n&quot;,
363                output_buffer-&gt;width, output_buffer-&gt;height,
364                bitstream-&gt;has_alpha ? &quot; (with alpha)&quot; : &quot;&quot;,
365                kFormatType[bitstream-&gt;format]);
366        fprintf(stderr, &quot;Nothing written; &quot;
367                        &quot;use -o flag to save the result as e.g. PNG.\n&quot;);
368      }
369    }
370   Exit:
371    WebPFreeDecBuffer(output_buffer);
372    WebPFree((void*)external_buffer);
373    WebPFree((void*)data);
374    FREE_WARGV_AND_RETURN(ok ? 0 : -1);
375  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cwebp.c</h3>
            <pre><code>1  #include &lt;stdio.h&gt;
2  #include &lt;stdlib.h&gt;
3  #include &lt;string.h&gt;
4  #ifdef HAVE_CONFIG_H
5  #include &quot;webp/config.h&quot;
6  #endif
7  #include &quot;../examples/example_util.h&quot;
8  #include &quot;../imageio/image_dec.h&quot;
9  #include &quot;../imageio/imageio_util.h&quot;
10  #include &quot;./stopwatch.h&quot;
11  #include &quot;./unicode.h&quot;
12  #include &quot;webp/encode.h&quot;
13  #ifndef WEBP_DLL
14  #ifdef __cplusplus
<span onclick='openModal()' class='match'>15  extern &quot;C&quot; {
16  #endif
17  extern void* VP8GetCPUInfo;   
18  #ifdef __cplusplus
19  }    
20  #endif
21  #endif  
22  static int verbose = 0;
</span>23  static int ReadYUV(const uint8_t* const data, size_t data_size,
24                     WebPPicture* const pic) {
25    const int use_argb = pic-&gt;use_argb;
26    const int uv_width = (pic-&gt;width + 1) / 2;
27    const int uv_height = (pic-&gt;height + 1) / 2;
28    const int y_plane_size = pic-&gt;width * pic-&gt;height;
29    const int uv_plane_size = uv_width * uv_height;
30    const size_t expected_data_size = y_plane_size + 2 * uv_plane_size;
31    if (data_size != expected_data_size) {
32      fprintf(stderr,
33              &quot;input data doesn&#x27;t have the expected size (%d instead of %d)\n&quot;,
34              (int)data_size, (int)expected_data_size);
35      return 0;
36    }
37    pic-&gt;use_argb = 0;
38    if (!WebPPictureAlloc(pic)) return 0;
39    ImgIoUtilCopyPlane(data, pic-&gt;width, pic-&gt;y, pic-&gt;y_stride,
40                       pic-&gt;width, pic-&gt;height);
41    ImgIoUtilCopyPlane(data + y_plane_size, uv_width,
42                       pic-&gt;u, pic-&gt;uv_stride, uv_width, uv_height);
43    ImgIoUtilCopyPlane(data + y_plane_size + uv_plane_size, uv_width,
44                       pic-&gt;v, pic-&gt;uv_stride, uv_width, uv_height);
45    return use_argb ? WebPPictureYUVAToARGB(pic) : 1;
46  }
47  #ifdef HAVE_WINCODEC_H
48  static int ReadPicture(const char* const filename, WebPPicture* const pic,
49                         int keep_alpha, Metadata* const metadata) {
50    int ok = 0;
51    const uint8_t* data = NULL;
52    size_t data_size = 0;
53    if (pic-&gt;width != 0 &amp;&amp; pic-&gt;height != 0) {
54      ok = ImgIoUtilReadFile(filename, &amp;data, &amp;data_size);
55      ok = ok &amp;&amp; ReadYUV(data, data_size, pic);
56    } else {
57      ok = ReadPictureWithWIC(filename, pic, keep_alpha, metadata);
58      if (!ok) {
59        ok = ImgIoUtilReadFile(filename, &amp;data, &amp;data_size);
60        ok = ok &amp;&amp; ReadWebP(data, data_size, pic, keep_alpha, metadata);
61      }
62    }
63    if (!ok) {
64      WFPRINTF(stderr, &quot;Error! Could not process file %s\n&quot;,
65               (const W_CHAR*)filename);
66    }
67    free((void*)data);
68    return ok;
69  }
70  #else  
71  static int ReadPicture(const char* const filename, WebPPicture* const pic,
72                         int keep_alpha, Metadata* const metadata) {
73    const uint8_t* data = NULL;
74    size_t data_size = 0;
75    int ok = 0;
76    ok = ImgIoUtilReadFile(filename, &amp;data, &amp;data_size);
77    if (!ok) goto End;
78    if (pic-&gt;width == 0 || pic-&gt;height == 0) {
79      WebPImageReader reader = WebPGuessImageReader(data, data_size);
80      ok = reader(data, data_size, pic, keep_alpha, metadata);
81    } else {
82      ok = ReadYUV(data, data_size, pic);
83    }
84   End:
85    if (!ok) {
86      WFPRINTF(stderr, &quot;Error! Could not process file %s\n&quot;,
87               (const W_CHAR*)filename);
88    }
89    free((void*)data);
90    return ok;
91  }
92  #endif  
93  static void AllocExtraInfo(WebPPicture* const pic) {
94    const int mb_w = (pic-&gt;width + 15) / 16;
95    const int mb_h = (pic-&gt;height + 15) / 16;
96    pic-&gt;extra_info =
97        (uint8_t*)WebPMalloc(mb_w * mb_h * sizeof(*pic-&gt;extra_info));
98  }
99  static void PrintByteCount(const int bytes[4], int total_size,
100                             int* const totals) {
101    int s;
102    int total = 0;
103    for (s = 0; s &lt; 4; ++s) {
104      fprintf(stderr, &quot;| %7d &quot;, bytes[s]);
105      total += bytes[s];
106      if (totals) totals[s] += bytes[s];
107    }
108    fprintf(stderr, &quot;| %7d  (%.1f%%)\n&quot;, total, 100.f * total / total_size);
109  }
110  static void PrintPercents(const int counts[4]) {
111    int s;
112    const int total = counts[0] + counts[1] + counts[2] + counts[3];
113    for (s = 0; s &lt; 4; ++s) {
114      fprintf(stderr, &quot;|      %2d%%&quot;, (int)(100. * counts[s] / total + .5));
115    }
116    fprintf(stderr, &quot;| %7d\n&quot;, total);
117  }
118  static void PrintValues(const int values[4]) {
119    int s;
120    for (s = 0; s &lt; 4; ++s) {
121      fprintf(stderr, &quot;| %7d &quot;, values[s]);
122    }
123    fprintf(stderr, &quot;|\n&quot;);
124  }
125  static void PrintFullLosslessInfo(const WebPAuxStats* const stats,
126                                    const char* const description) {
127    fprintf(stderr, &quot;Lossless-%s compressed size: %d bytes\n&quot;,
128            description, stats-&gt;lossless_size);
129    fprintf(stderr, &quot;  * Header size: %d bytes, image data size: %d\n&quot;,
130            stats-&gt;lossless_hdr_size, stats-&gt;lossless_data_size);
131    if (stats-&gt;lossless_features) {
132      fprintf(stderr, &quot;  * Lossless features used:&quot;);
133      if (stats-&gt;lossless_features &amp; 1) fprintf(stderr, &quot; PREDICTION&quot;);
134      if (stats-&gt;lossless_features &amp; 2) fprintf(stderr, &quot; CROSS-COLOR-TRANSFORM&quot;);
135      if (stats-&gt;lossless_features &amp; 4) fprintf(stderr, &quot; SUBTRACT-GREEN&quot;);
136      if (stats-&gt;lossless_features &amp; 8) fprintf(stderr, &quot; PALETTE&quot;);
137      fprintf(stderr, &quot;\n&quot;);
138    }
139    fprintf(stderr, &quot;  * Precision Bits: histogram=%d transform=%d cache=%d\n&quot;,
140            stats-&gt;histogram_bits, stats-&gt;transform_bits, stats-&gt;cache_bits);
141    if (stats-&gt;palette_size &gt; 0) {
142      fprintf(stderr, &quot;  * Palette size:   %d\n&quot;, stats-&gt;palette_size);
143    }
144  }
145  static void PrintExtraInfoLossless(const WebPPicture* const pic,
146                                     int short_output,
147                                     const char* const file_name) {
148    const WebPAuxStats* const stats = pic-&gt;stats;
149    if (short_output) {
150      fprintf(stderr, &quot;%7d %2.2f\n&quot;, stats-&gt;coded_size, stats-&gt;PSNR[3]);
151    } else {
152      WFPRINTF(stderr, &quot;File:      %s\n&quot;, (const W_CHAR*)file_name);
153      fprintf(stderr, &quot;Dimension: %d x %d\n&quot;, pic-&gt;width, pic-&gt;height);
154      fprintf(stderr, &quot;Output:    %d bytes (%.2f bpp)\n&quot;, stats-&gt;coded_size,
155              8.f * stats-&gt;coded_size / pic-&gt;width / pic-&gt;height);
156      PrintFullLosslessInfo(stats, &quot;ARGB&quot;);
157    }
158  }
159  static void PrintExtraInfoLossy(const WebPPicture* const pic, int short_output,
160                                  int full_details,
161                                  const char* const file_name) {
162    const WebPAuxStats* const stats = pic-&gt;stats;
163    if (short_output) {
164      fprintf(stderr, &quot;%7d %2.2f\n&quot;, stats-&gt;coded_size, stats-&gt;PSNR[3]);
165    } else {
166      const int num_i4 = stats-&gt;block_count[0];
167      const int num_i16 = stats-&gt;block_count[1];
168      const int num_skip = stats-&gt;block_count[2];
169      const int total = num_i4 + num_i16;
170      WFPRINTF(stderr, &quot;File:      %s\n&quot;, (const W_CHAR*)file_name);
171      fprintf(stderr, &quot;Dimension: %d x %d%s\n&quot;,
172              pic-&gt;width, pic-&gt;height,
173              stats-&gt;alpha_data_size ? &quot; (with alpha)&quot; : &quot;&quot;);
174      fprintf(stderr, &quot;Output:    &quot;
175              &quot;%d bytes Y-U-V-All-PSNR %2.2f %2.2f %2.2f   %2.2f dB\n&quot;
176              &quot;           (%.2f bpp)\n&quot;,
177              stats-&gt;coded_size,
178              stats-&gt;PSNR[0], stats-&gt;PSNR[1], stats-&gt;PSNR[2], stats-&gt;PSNR[3],
179              8.f * stats-&gt;coded_size / pic-&gt;width / pic-&gt;height);
180      if (total &gt; 0) {
181        int totals[4] = { 0, 0, 0, 0 };
182        fprintf(stderr, &quot;block count:  intra4:     %6d  (%.2f%%)\n&quot;
183                        &quot;              intra16:    %6d  (%.2f%%)\n&quot;
184                        &quot;              skipped:    %6d  (%.2f%%)\n&quot;,
185                num_i4, 100.f * num_i4 / total,
186                num_i16, 100.f * num_i16 / total,
187                num_skip, 100.f * num_skip / total);
188        fprintf(stderr, &quot;bytes used:  header:         %6d  (%.1f%%)\n&quot;
189                        &quot;             mode-partition: %6d  (%.1f%%)\n&quot;,
190                stats-&gt;header_bytes[0],
191                100.f * stats-&gt;header_bytes[0] / stats-&gt;coded_size,
192                stats-&gt;header_bytes[1],
193                100.f * stats-&gt;header_bytes[1] / stats-&gt;coded_size);
194        if (stats-&gt;alpha_data_size &gt; 0) {
195          fprintf(stderr, &quot;             transparency:   %6d (%.1f dB)\n&quot;,
196                  stats-&gt;alpha_data_size, stats-&gt;PSNR[4]);
197        }
198        fprintf(stderr, &quot; Residuals bytes  &quot;
199                        &quot;|segment 1|segment 2|segment 3&quot;
200                        &quot;|segment 4|  total\n&quot;);
201        if (full_details) {
202          fprintf(stderr, &quot;  intra4-coeffs:  &quot;);
203          PrintByteCount(stats-&gt;residual_bytes[0], stats-&gt;coded_size, totals);
204          fprintf(stderr, &quot; intra16-coeffs:  &quot;);
205          PrintByteCount(stats-&gt;residual_bytes[1], stats-&gt;coded_size, totals);
206          fprintf(stderr, &quot;  chroma coeffs:  &quot;);
207          PrintByteCount(stats-&gt;residual_bytes[2], stats-&gt;coded_size, totals);
208        }
209        fprintf(stderr, &quot;    macroblocks:  &quot;);
210        PrintPercents(stats-&gt;segment_size);
211        fprintf(stderr, &quot;      quantizer:  &quot;);
212        PrintValues(stats-&gt;segment_quant);
213        fprintf(stderr, &quot;   filter level:  &quot;);
214        PrintValues(stats-&gt;segment_level);
215        if (full_details) {
216          fprintf(stderr, &quot;------------------+---------&quot;);
217          fprintf(stderr, &quot;+---------+---------+---------+-----------------\n&quot;);
218          fprintf(stderr, &quot; segments total:  &quot;);
219          PrintByteCount(totals, stats-&gt;coded_size, NULL);
220        }
221      }
222      if (stats-&gt;lossless_size &gt; 0) {
223        PrintFullLosslessInfo(stats, &quot;alpha&quot;);
224      }
225    }
226  }
227  static void PrintMapInfo(const WebPPicture* const pic) {
228    if (pic-&gt;extra_info != NULL) {
229      const int mb_w = (pic-&gt;width + 15) / 16;
230      const int mb_h = (pic-&gt;height + 15) / 16;
231      const int type = pic-&gt;extra_info_type;
232      int x, y;
233      for (y = 0; y &lt; mb_h; ++y) {
234        for (x = 0; x &lt; mb_w; ++x) {
235          const int c = pic-&gt;extra_info[x + y * mb_w];
236          if (type == 1) {   
237            fprintf(stderr, &quot;%c&quot;, &quot;+.&quot;[c]);
238          } else if (type == 2) {    
239            fprintf(stderr, &quot;%c&quot;, &quot;.-*X&quot;[c]);
240          } else if (type == 3) {    
241            fprintf(stderr, &quot;%.2d &quot;, c);
242          } else if (type == 6 || type == 7) {
243            fprintf(stderr, &quot;%3d &quot;, c);
244          } else {
245            fprintf(stderr, &quot;0x%.2x &quot;, c);
246          }
247        }
248        fprintf(stderr, &quot;\n&quot;);
249      }
250    }
251  }
252  static int MyWriter(const uint8_t* data, size_t data_size,
253                      const WebPPicture* const pic) {
254    FILE* const out = (FILE*)pic-&gt;custom_ptr;
255    return data_size ? (fwrite(data, data_size, 1, out) == 1) : 1;
256  }
257  static int DumpPicture(const WebPPicture* const picture, const char* PGM_name) {
258    int y;
259    const int uv_width = (picture-&gt;width + 1) / 2;
260    const int uv_height = (picture-&gt;height + 1) / 2;
261    const int stride = (picture-&gt;width + 1) &amp; ~1;
262    const uint8_t* src_y = picture-&gt;y;
263    const uint8_t* src_u = picture-&gt;u;
264    const uint8_t* src_v = picture-&gt;v;
265    const uint8_t* src_a = picture-&gt;a;
266    const int alpha_height =
267        WebPPictureHasTransparency(picture) ? picture-&gt;height : 0;
268    const int height = picture-&gt;height + uv_height + alpha_height;
269    FILE* const f = WFOPEN(PGM_name, &quot;wb&quot;);
270    if (f == NULL) return 0;
271    fprintf(f, &quot;P5\n%d %d\n255\n&quot;, stride, height);
272    for (y = 0; y &lt; picture-&gt;height; ++y) {
273      if (fwrite(src_y, picture-&gt;width, 1, f) != 1) return 0;
274      if (picture-&gt;width &amp; 1) fputc(0, f);  
275      src_y += picture-&gt;y_stride;
276    }
277    for (y = 0; y &lt; uv_height; ++y) {
278      if (fwrite(src_u, uv_width, 1, f) != 1) return 0;
279      if (fwrite(src_v, uv_width, 1, f) != 1) return 0;
280      src_u += picture-&gt;uv_stride;
281      src_v += picture-&gt;uv_stride;
282    }
283    for (y = 0; y &lt; alpha_height; ++y) {
284      if (fwrite(src_a, picture-&gt;width, 1, f) != 1) return 0;
285      if (picture-&gt;width &amp; 1) fputc(0, f);  
286      src_a += picture-&gt;a_stride;
287    }
288    fclose(f);
289    return 1;
290  }
291  enum {
292    METADATA_EXIF = (1 &lt;&lt; 0),
293    METADATA_ICC  = (1 &lt;&lt; 1),
294    METADATA_XMP  = (1 &lt;&lt; 2),
295    METADATA_ALL  = METADATA_EXIF | METADATA_ICC | METADATA_XMP
296  };
297  static const int kChunkHeaderSize = 8;
298  static const int kTagSize = 4;
299  static void PrintMetadataInfo(const Metadata* const metadata,
300                                int metadata_written) {
301    if (metadata == NULL || metadata_written == 0) return;
302    fprintf(stderr, &quot;Metadata:\n&quot;);
303    if (metadata_written &amp; METADATA_ICC) {
304      fprintf(stderr, &quot;  * ICC profile:  %6d bytes\n&quot;, (int)metadata-&gt;iccp.size);
305    }
306    if (metadata_written &amp; METADATA_EXIF) {
307      fprintf(stderr, &quot;  * EXIF data:    %6d bytes\n&quot;, (int)metadata-&gt;exif.size);
308    }
309    if (metadata_written &amp; METADATA_XMP) {
310      fprintf(stderr, &quot;  * XMP data:     %6d bytes\n&quot;, (int)metadata-&gt;xmp.size);
311    }
312  }
313  static int WriteLE(FILE* const out, uint32_t val, int num) {
314    uint8_t buf[4];
315    int i;
316    for (i = 0; i &lt; num; ++i) {
317      buf[i] = (uint8_t)(val &amp; 0xff);
318      val &gt;&gt;= 8;
319    }
320    return (fwrite(buf, num, 1, out) == 1);
321  }
322  static int WriteLE24(FILE* const out, uint32_t val) {
323    return WriteLE(out, val, 3);
324  }
325  static int WriteLE32(FILE* const out, uint32_t val) {
326    return WriteLE(out, val, 4);
327  }
328  static int WriteMetadataChunk(FILE* const out, const char fourcc[4],
329                                const MetadataPayload* const payload) {
330    const uint8_t zero = 0;
331    const size_t need_padding = payload-&gt;size &amp; 1;
332    int ok = (fwrite(fourcc, kTagSize, 1, out) == 1);
333    ok = ok &amp;&amp; WriteLE32(out, (uint32_t)payload-&gt;size);
334    ok = ok &amp;&amp; (fwrite(payload-&gt;bytes, payload-&gt;size, 1, out) == 1);
335    return ok &amp;&amp; (fwrite(&amp;zero, need_padding, need_padding, out) == need_padding);
336  }
337  static int UpdateFlagsAndSize(const MetadataPayload* const payload,
338                                int keep, int flag,
339                                uint32_t* vp8x_flags, uint64_t* metadata_size) {
340    if (keep &amp;&amp; payload-&gt;bytes != NULL &amp;&amp; payload-&gt;size &gt; 0) {
341      *vp8x_flags |= flag;
342      *metadata_size += kChunkHeaderSize + payload-&gt;size + (payload-&gt;size &amp; 1);
343      return 1;
344    }
345    return 0;
346  }
347  static int WriteWebPWithMetadata(FILE* const out,
348                                   const WebPPicture* const picture,
349                                   const WebPMemoryWriter* const memory_writer,
350                                   const Metadata* const metadata,
351                                   int keep_metadata,
352                                   int* const metadata_written) {
353    const char kVP8XHeader[] = &quot;VP8X\x0a\x00\x00\x00&quot;;
354    const int kAlphaFlag = 0x10;
355    const int kEXIFFlag  = 0x08;
356    const int kICCPFlag  = 0x20;
357    const int kXMPFlag   = 0x04;
358    const size_t kRiffHeaderSize = 12;
359    const size_t kMaxChunkPayload = ~0 - kChunkHeaderSize - 1;
360    const size_t kMinSize = kRiffHeaderSize + kChunkHeaderSize;
361    uint32_t flags = 0;
362    uint64_t metadata_size = 0;
363    const int write_exif = UpdateFlagsAndSize(&amp;metadata-&gt;exif,
364                                              !!(keep_metadata &amp; METADATA_EXIF),
365                                              kEXIFFlag, &amp;flags, &amp;metadata_size);
366    const int write_iccp = UpdateFlagsAndSize(&amp;metadata-&gt;iccp,
367                                              !!(keep_metadata &amp; METADATA_ICC),
368                                              kICCPFlag, &amp;flags, &amp;metadata_size);
369    const int write_xmp  = UpdateFlagsAndSize(&amp;metadata-&gt;xmp,
370                                              !!(keep_metadata &amp; METADATA_XMP),
371                                              kXMPFlag, &amp;flags, &amp;metadata_size);
372    uint8_t* webp = memory_writer-&gt;mem;
373    size_t webp_size = memory_writer-&gt;size;
374    *metadata_written = 0;
375    if (webp_size &lt; kMinSize) return 0;
376    if (webp_size - kChunkHeaderSize + metadata_size &gt; kMaxChunkPayload) {
377      fprintf(stderr, &quot;Error! Addition of metadata would exceed &quot;
378                      &quot;container size limit.\n&quot;);
379      return 0;
380    }
381    if (metadata_size &gt; 0) {
382      const int kVP8XChunkSize = 18;
383      const int has_vp8x = !memcmp(webp + kRiffHeaderSize, &quot;VP8X&quot;, kTagSize);
384      const uint32_t riff_size = (uint32_t)(webp_size - kChunkHeaderSize +
385                                            (has_vp8x ? 0 : kVP8XChunkSize) +
386                                            metadata_size);
387      int ok = (fwrite(webp, kTagSize, 1, out) == 1);
388      ok = ok &amp;&amp; WriteLE32(out, riff_size);
389      webp += kChunkHeaderSize;
390      webp_size -= kChunkHeaderSize;
391      ok = ok &amp;&amp; (fwrite(webp, kTagSize, 1, out) == 1);
392      webp += kTagSize;
393      webp_size -= kTagSize;
394      if (has_vp8x) {  
395        webp[kChunkHeaderSize] |= (uint8_t)(flags &amp; 0xff);
396        ok = ok &amp;&amp; (fwrite(webp, kVP8XChunkSize, 1, out) == 1);
397        webp += kVP8XChunkSize;
398        webp_size -= kVP8XChunkSize;
399      } else {
400        const int is_lossless = !memcmp(webp, &quot;VP8L&quot;, kTagSize);
401        if (is_lossless) {
402          if (webp[kChunkHeaderSize + 4] &amp; (1 &lt;&lt; 4)) flags |= kAlphaFlag;
403        }
404        ok = ok &amp;&amp; (fwrite(kVP8XHeader, kChunkHeaderSize, 1, out) == 1);
405        ok = ok &amp;&amp; WriteLE32(out, flags);
406        ok = ok &amp;&amp; WriteLE24(out, picture-&gt;width - 1);
407        ok = ok &amp;&amp; WriteLE24(out, picture-&gt;height - 1);
408      }
409      if (write_iccp) {
410        ok = ok &amp;&amp; WriteMetadataChunk(out, &quot;ICCP&quot;, &amp;metadata-&gt;iccp);
411        *metadata_written |= METADATA_ICC;
412      }
413      ok = ok &amp;&amp; (fwrite(webp, webp_size, 1, out) == 1);
414      if (write_exif) {
415        ok = ok &amp;&amp; WriteMetadataChunk(out, &quot;EXIF&quot;, &amp;metadata-&gt;exif);
416        *metadata_written |= METADATA_EXIF;
417      }
418      if (write_xmp) {
419        ok = ok &amp;&amp; WriteMetadataChunk(out, &quot;XMP &quot;, &amp;metadata-&gt;xmp);
420        *metadata_written |= METADATA_XMP;
421      }
422      return ok;
423    }
424    return (fwrite(webp, webp_size, 1, out) == 1);
425  }
426  static int ProgressReport(int percent, const WebPPicture* const picture) {
427    fprintf(stderr, &quot;[%s]: %3d %%      \r&quot;,
428            (char*)picture-&gt;user_data, percent);
429    return 1;  
430  }
431  static void HelpShort(void) {
432    printf(&quot;Usage:\n\n&quot;);
433    printf(&quot;   cwebp [options] -q quality input.png -o output.webp\n\n&quot;);
434    printf(&quot;where quality is between 0 (poor) to 100 (very good).\n&quot;);
435    printf(&quot;Typical value is around 80.\n\n&quot;);
436    printf(&quot;Try -longhelp for an exhaustive list of advanced options.\n&quot;);
437  }
438  static void HelpLong(void) {
439    printf(&quot;Usage:\n&quot;);
440    printf(&quot; cwebp [-preset &lt;...&gt;] [options] in_file [-o out_file]\n\n&quot;);
441    printf(&quot;If input size (-s) for an image is not specified, it is\n&quot;
442           &quot;assumed to be a PNG, JPEG, TIFF or WebP file.\n&quot;);
443  #ifdef HAVE_WINCODEC_H
444    printf(&quot;Windows builds can take as input any of the files handled by WIC.\n&quot;);
445  #endif
446    printf(&quot;\nOptions:\n&quot;);
447    printf(&quot;  -h / -help ............. short help\n&quot;);
448    printf(&quot;  -H / -longhelp ......... long help\n&quot;);
449    printf(&quot;  -q &lt;float&gt; ............. quality factor (0:small..100:big), &quot;
450           &quot;default=75\n&quot;);
451    printf(&quot;  -alpha_q &lt;int&gt; ......... transparency-compression quality (0..100),&quot;
452           &quot;\n                           default=100\n&quot;);
453    printf(&quot;  -preset &lt;string&gt; ....... preset setting, one of:\n&quot;);
454    printf(&quot;                            default, photo, picture,\n&quot;);
455    printf(&quot;                            drawing, icon, text\n&quot;);
456    printf(&quot;     -preset must come first, as it overwrites other parameters\n&quot;);
457    printf(&quot;  -z &lt;int&gt; ............... activates lossless preset with given\n&quot;
458           &quot;                           level in [0:fast, ..., 9:slowest]\n&quot;);
459    printf(&quot;\n&quot;);
460    printf(&quot;  -m &lt;int&gt; ............... compression method (0=fast, 6=slowest), &quot;
461           &quot;default=4\n&quot;);
462    printf(&quot;  -segments &lt;int&gt; ........ number of segments to use (1..4), &quot;
463           &quot;default=4\n&quot;);
464    printf(&quot;  -size &lt;int&gt; ............ target size (in bytes)\n&quot;);
465    printf(&quot;  -psnr &lt;float&gt; .......... target PSNR (in dB. typically: 42)\n&quot;);
466    printf(&quot;\n&quot;);
467    printf(&quot;  -s &lt;int&gt; &lt;int&gt; ......... input size (width x height) for YUV\n&quot;);
468    printf(&quot;  -sns &lt;int&gt; ............. spatial noise shaping (0:off, 100:max), &quot;
469           &quot;default=50\n&quot;);
470    printf(&quot;  -f &lt;int&gt; ............... filter strength (0=off..100), &quot;
471           &quot;default=60\n&quot;);
472    printf(&quot;  -sharpness &lt;int&gt; ....... &quot;
473           &quot;filter sharpness (0:most .. 7:least sharp), default=0\n&quot;);
474    printf(&quot;  -strong ................ use strong filter instead &quot;
475                                       &quot;of simple (default)\n&quot;);
476    printf(&quot;  -nostrong .............. use simple filter instead of strong\n&quot;);
477    printf(&quot;  -sharp_yuv ............. use sharper (and slower) RGB-&gt;YUV &quot;
478                                       &quot;conversion\n&quot;);
479    printf(&quot;  -partition_limit &lt;int&gt; . limit quality to fit the 512k limit on\n&quot;);
480    printf(&quot;                           &quot;
481           &quot;the first partition (0=no degradation ... 100=full)\n&quot;);
482    printf(&quot;  -pass &lt;int&gt; ............ analysis pass number (1..10)\n&quot;);
483    printf(&quot;  -crop &lt;x&gt; &lt;y&gt; &lt;w&gt; &lt;h&gt; .. crop picture with the given rectangle\n&quot;);
484    printf(&quot;  -resize &lt;w&gt; &lt;h&gt; ........ resize picture (after any cropping)\n&quot;);
485    printf(&quot;  -mt .................... use multi-threading if available\n&quot;);
486    printf(&quot;  -low_memory ............ reduce memory usage (slower encoding)\n&quot;);
487    printf(&quot;  -map &lt;int&gt; ............. print map of extra info\n&quot;);
488    printf(&quot;  -print_psnr ............ prints averaged PSNR distortion\n&quot;);
489    printf(&quot;  -print_ssim ............ prints averaged SSIM distortion\n&quot;);
490    printf(&quot;  -print_lsim ............ prints local-similarity distortion\n&quot;);
491    printf(&quot;  -d &lt;file.pgm&gt; .......... dump the compressed output (PGM file)\n&quot;);
492    printf(&quot;  -alpha_method &lt;int&gt; .... transparency-compression method (0..1), &quot;
493           &quot;default=1\n&quot;);
494    printf(&quot;  -alpha_filter &lt;string&gt; . predictive filtering for alpha plane,\n&quot;);
495    printf(&quot;                           one of: none, fast (default) or best\n&quot;);
496    printf(&quot;  -exact ................. preserve RGB values in transparent area, &quot;
497           &quot;default=off\n&quot;);
498    printf(&quot;  -blend_alpha &lt;hex&gt; ..... blend colors against background color\n&quot;
499           &quot;                           expressed as RGB values written in\n&quot;
500           &quot;                           hexadecimal, e.g. 0xc0e0d0 for red=0xc0\n&quot;
501           &quot;                           green=0xe0 and blue=0xd0\n&quot;);
502    printf(&quot;  -noalpha ............... discard any transparency information\n&quot;);
503    printf(&quot;  -lossless .............. encode image losslessly, default=off\n&quot;);
504    printf(&quot;  -near_lossless &lt;int&gt; ... use near-lossless image\n&quot;
505           &quot;                           preprocessing (0..100=off), &quot;
506           &quot;default=100\n&quot;);
507    printf(&quot;  -hint &lt;string&gt; ......... specify image characteristics hint,\n&quot;);
508    printf(&quot;                           one of: photo, picture or graph\n&quot;);
509    printf(&quot;\n&quot;);
510    printf(&quot;  -metadata &lt;string&gt; ..... comma separated list of metadata to\n&quot;);
511    printf(&quot;                           &quot;);
512    printf(&quot;copy from the input to the output if present.\n&quot;);
513    printf(&quot;                           &quot;
514           &quot;Valid values: all, none (default), exif, icc, xmp\n&quot;);
515    printf(&quot;\n&quot;);
516    printf(&quot;  -short ................. condense printed message\n&quot;);
517    printf(&quot;  -quiet ................. don&#x27;t print anything\n&quot;);
518    printf(&quot;  -version ............... print version number and exit\n&quot;);
519  #ifndef WEBP_DLL
520    printf(&quot;  -noasm ................. disable all assembly optimizations\n&quot;);
521  #endif
522    printf(&quot;  -v ..................... verbose, e.g. print encoding/decoding &quot;
523           &quot;times\n&quot;);
524    printf(&quot;  -progress .............. report encoding progress\n&quot;);
525    printf(&quot;\n&quot;);
526    printf(&quot;Experimental Options:\n&quot;);
527    printf(&quot;  -jpeg_like ............. roughly match expected JPEG size\n&quot;);
528    printf(&quot;  -af .................... auto-adjust filter strength\n&quot;);
529    printf(&quot;  -pre &lt;int&gt; ............. pre-processing filter\n&quot;);
530    printf(&quot;\n&quot;);
531  }
532  static const char* const kErrorMessages[VP8_ENC_ERROR_LAST] = {
533    &quot;OK&quot;,
534    &quot;OUT_OF_MEMORY: Out of memory allocating objects&quot;,
535    &quot;BITSTREAM_OUT_OF_MEMORY: Out of memory re-allocating byte buffer&quot;,
536    &quot;NULL_PARAMETER: NULL parameter passed to function&quot;,
537    &quot;INVALID_CONFIGURATION: configuration is invalid&quot;,
538    &quot;BAD_DIMENSION: Bad picture dimension. Maximum width and height &quot;
539    &quot;allowed is 16383 pixels.&quot;,
540    &quot;PARTITION0_OVERFLOW: Partition #0 is too big to fit 512k.\n&quot;
541    &quot;To reduce the size of this partition, try using less segments &quot;
542    &quot;with the -segments option, and eventually reduce the number of &quot;
543    &quot;header bits using -partition_limit. More details are available &quot;
544    &quot;in the manual (`man cwebp`)&quot;,
545    &quot;PARTITION_OVERFLOW: Partition is too big to fit 16M&quot;,
546    &quot;BAD_WRITE: Picture writer returned an I/O error&quot;,
547    &quot;FILE_TOO_BIG: File would be too big to fit in 4G&quot;,
548    &quot;USER_ABORT: encoding abort requested by user&quot;
549  };
550  int main(int argc, const char* argv[]) {
551    int return_value = -1;
552    const char* in_file = NULL, *out_file = NULL, *dump_file = NULL;
553    FILE* out = NULL;
554    int c;
555    int short_output = 0;
556    int quiet = 0;
557    int keep_alpha = 1;
558    int blend_alpha = 0;
559    uint32_t background_color = 0xffffffu;
560    int crop = 0, crop_x = 0, crop_y = 0, crop_w = 0, crop_h = 0;
561    int resize_w = 0, resize_h = 0;
562    int lossless_preset = 6;
563    int use_lossless_preset = -1;  
564    int show_progress = 0;
565    int keep_metadata = 0;
566    int metadata_written = 0;
567    WebPPicture picture;
568    int print_distortion = -1;        
569    WebPPicture original_picture;    
570    WebPConfig config;
571    WebPAuxStats stats;
572    WebPMemoryWriter memory_writer;
573    Metadata metadata;
574    Stopwatch stop_watch;
575    INIT_WARGV(argc, argv);
576    MetadataInit(&amp;metadata);
577    WebPMemoryWriterInit(&amp;memory_writer);
578    if (!WebPPictureInit(&amp;picture) ||
579        !WebPPictureInit(&amp;original_picture) ||
580        !WebPConfigInit(&amp;config)) {
581      fprintf(stderr, &quot;Error! Version mismatch!\n&quot;);
582      FREE_WARGV_AND_RETURN(-1);
583    }
584    if (argc == 1) {
585      HelpShort();
586      FREE_WARGV_AND_RETURN(0);
587    }
588    for (c = 1; c &lt; argc; ++c) {
589      int parse_error = 0;
590      if (!strcmp(argv[c], &quot;-h&quot;) || !strcmp(argv[c], &quot;-help&quot;)) {
591        HelpShort();
592        FREE_WARGV_AND_RETURN(0);
593      } else if (!strcmp(argv[c], &quot;-H&quot;) || !strcmp(argv[c], &quot;-longhelp&quot;)) {
594        HelpLong();
595        FREE_WARGV_AND_RETURN(0);
596      } else if (!strcmp(argv[c], &quot;-o&quot;) &amp;&amp; c &lt; argc - 1) {
597        out_file = (const char*)GET_WARGV(argv, ++c);
598      } else if (!strcmp(argv[c], &quot;-d&quot;) &amp;&amp; c &lt; argc - 1) {
599        dump_file = (const char*)GET_WARGV(argv, ++c);
600        config.show_compressed = 1;
601      } else if (!strcmp(argv[c], &quot;-print_psnr&quot;)) {
602        config.show_compressed = 1;
603        print_distortion = 0;
604      } else if (!strcmp(argv[c], &quot;-print_ssim&quot;)) {
605        config.show_compressed = 1;
606        print_distortion = 1;
607      } else if (!strcmp(argv[c], &quot;-print_lsim&quot;)) {
608        config.show_compressed = 1;
609        print_distortion = 2;
610      } else if (!strcmp(argv[c], &quot;-short&quot;)) {
611        ++short_output;
612      } else if (!strcmp(argv[c], &quot;-s&quot;) &amp;&amp; c &lt; argc - 2) {
613        picture.width = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
614        picture.height = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
615        if (picture.width &gt; WEBP_MAX_DIMENSION || picture.width &lt; 0 ||
616            picture.height &gt; WEBP_MAX_DIMENSION ||  picture.height &lt; 0) {
617          fprintf(stderr,
618                  &quot;Specified dimension (%d x %d) is out of range.\n&quot;,
619                  picture.width, picture.height);
620          goto Error;
621        }
622      } else if (!strcmp(argv[c], &quot;-m&quot;) &amp;&amp; c &lt; argc - 1) {
623        config.method = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
624        use_lossless_preset = 0;   
625      } else if (!strcmp(argv[c], &quot;-q&quot;) &amp;&amp; c &lt; argc - 1) {
626        config.quality = ExUtilGetFloat(argv[++c], &amp;parse_error);
627        use_lossless_preset = 0;   
628      } else if (!strcmp(argv[c], &quot;-z&quot;) &amp;&amp; c &lt; argc - 1) {
629        lossless_preset = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
630        if (use_lossless_preset != 0) use_lossless_preset = 1;
631      } else if (!strcmp(argv[c], &quot;-alpha_q&quot;) &amp;&amp; c &lt; argc - 1) {
632        config.alpha_quality = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
633      } else if (!strcmp(argv[c], &quot;-alpha_method&quot;) &amp;&amp; c &lt; argc - 1) {
634        config.alpha_compression = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
635      } else if (!strcmp(argv[c], &quot;-alpha_cleanup&quot;)) {
636        config.exact = 0;
637      } else if (!strcmp(argv[c], &quot;-exact&quot;)) {
638        config.exact = 1;
639      } else if (!strcmp(argv[c], &quot;-blend_alpha&quot;) &amp;&amp; c &lt; argc - 1) {
640        blend_alpha = 1;
641        background_color = ExUtilGetInt(argv[++c], 16, &amp;parse_error);
642        background_color = background_color &amp; 0x00ffffffu;
643      } else if (!strcmp(argv[c], &quot;-alpha_filter&quot;) &amp;&amp; c &lt; argc - 1) {
644        ++c;
645        if (!strcmp(argv[c], &quot;none&quot;)) {
646          config.alpha_filtering = 0;
647        } else if (!strcmp(argv[c], &quot;fast&quot;)) {
648          config.alpha_filtering = 1;
649        } else if (!strcmp(argv[c], &quot;best&quot;)) {
650          config.alpha_filtering = 2;
651        } else {
652          fprintf(stderr, &quot;Error! Unrecognized alpha filter: %s\n&quot;, argv[c]);
653          goto Error;
654        }
655      } else if (!strcmp(argv[c], &quot;-noalpha&quot;)) {
656        keep_alpha = 0;
657      } else if (!strcmp(argv[c], &quot;-lossless&quot;)) {
658        config.lossless = 1;
659      } else if (!strcmp(argv[c], &quot;-near_lossless&quot;) &amp;&amp; c &lt; argc - 1) {
660        config.near_lossless = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
661        config.lossless = 1;  
662      } else if (!strcmp(argv[c], &quot;-hint&quot;) &amp;&amp; c &lt; argc - 1) {
663        ++c;
664        if (!strcmp(argv[c], &quot;photo&quot;)) {
665          config.image_hint = WEBP_HINT_PHOTO;
666        } else if (!strcmp(argv[c], &quot;picture&quot;)) {
667          config.image_hint = WEBP_HINT_PICTURE;
668        } else if (!strcmp(argv[c], &quot;graph&quot;)) {
669          config.image_hint = WEBP_HINT_GRAPH;
670        } else {
671          fprintf(stderr, &quot;Error! Unrecognized image hint: %s\n&quot;, argv[c]);
672          goto Error;
673        }
674      } else if (!strcmp(argv[c], &quot;-size&quot;) &amp;&amp; c &lt; argc - 1) {
675        config.target_size = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
676      } else if (!strcmp(argv[c], &quot;-psnr&quot;) &amp;&amp; c &lt; argc - 1) {
677        config.target_PSNR = ExUtilGetFloat(argv[++c], &amp;parse_error);
678      } else if (!strcmp(argv[c], &quot;-sns&quot;) &amp;&amp; c &lt; argc - 1) {
679        config.sns_strength = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
680      } else if (!strcmp(argv[c], &quot;-f&quot;) &amp;&amp; c &lt; argc - 1) {
681        config.filter_strength = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
682      } else if (!strcmp(argv[c], &quot;-af&quot;)) {
683        config.autofilter = 1;
684      } else if (!strcmp(argv[c], &quot;-jpeg_like&quot;)) {
685        config.emulate_jpeg_size = 1;
686      } else if (!strcmp(argv[c], &quot;-mt&quot;)) {
687        ++config.thread_level;  
688      } else if (!strcmp(argv[c], &quot;-low_memory&quot;)) {
689        config.low_memory = 1;
690      } else if (!strcmp(argv[c], &quot;-strong&quot;)) {
691        config.filter_type = 1;
692      } else if (!strcmp(argv[c], &quot;-nostrong&quot;)) {
693        config.filter_type = 0;
694      } else if (!strcmp(argv[c], &quot;-sharpness&quot;) &amp;&amp; c &lt; argc - 1) {
695        config.filter_sharpness = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
696      } else if (!strcmp(argv[c], &quot;-sharp_yuv&quot;)) {
697        config.use_sharp_yuv = 1;
698      } else if (!strcmp(argv[c], &quot;-pass&quot;) &amp;&amp; c &lt; argc - 1) {
699        config.pass = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
700      } else if (!strcmp(argv[c], &quot;-pre&quot;) &amp;&amp; c &lt; argc - 1) {
701        config.preprocessing = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
702      } else if (!strcmp(argv[c], &quot;-segments&quot;) &amp;&amp; c &lt; argc - 1) {
703        config.segments = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
704      } else if (!strcmp(argv[c], &quot;-partition_limit&quot;) &amp;&amp; c &lt; argc - 1) {
705        config.partition_limit = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
706      } else if (!strcmp(argv[c], &quot;-map&quot;) &amp;&amp; c &lt; argc - 1) {
707        picture.extra_info_type = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
708      } else if (!strcmp(argv[c], &quot;-crop&quot;) &amp;&amp; c &lt; argc - 4) {
709        crop = 1;
710        crop_x = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
711        crop_y = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
712        crop_w = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
713        crop_h = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
714      } else if (!strcmp(argv[c], &quot;-resize&quot;) &amp;&amp; c &lt; argc - 2) {
715        resize_w = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
716        resize_h = ExUtilGetInt(argv[++c], 0, &amp;parse_error);
717  #ifndef WEBP_DLL
718      } else if (!strcmp(argv[c], &quot;-noasm&quot;)) {
719        VP8GetCPUInfo = NULL;
720  #endif
721      } else if (!strcmp(argv[c], &quot;-version&quot;)) {
722        const int version = WebPGetEncoderVersion();
723        printf(&quot;%d.%d.%d\n&quot;,
724               (version &gt;&gt; 16) &amp; 0xff, (version &gt;&gt; 8) &amp; 0xff, version &amp; 0xff);
725        FREE_WARGV_AND_RETURN(0);
726      } else if (!strcmp(argv[c], &quot;-progress&quot;)) {
727        show_progress = 1;
728      } else if (!strcmp(argv[c], &quot;-quiet&quot;)) {
729        quiet = 1;
730      } else if (!strcmp(argv[c], &quot;-preset&quot;) &amp;&amp; c &lt; argc - 1) {
731        WebPPreset preset;
732        ++c;
733        if (!strcmp(argv[c], &quot;default&quot;)) {
734          preset = WEBP_PRESET_DEFAULT;
735        } else if (!strcmp(argv[c], &quot;photo&quot;)) {
736          preset = WEBP_PRESET_PHOTO;
737        } else if (!strcmp(argv[c], &quot;picture&quot;)) {
738          preset = WEBP_PRESET_PICTURE;
739        } else if (!strcmp(argv[c], &quot;drawing&quot;)) {
740          preset = WEBP_PRESET_DRAWING;
741        } else if (!strcmp(argv[c], &quot;icon&quot;)) {
742          preset = WEBP_PRESET_ICON;
743        } else if (!strcmp(argv[c], &quot;text&quot;)) {
744          preset = WEBP_PRESET_TEXT;
745        } else {
746          fprintf(stderr, &quot;Error! Unrecognized preset: %s\n&quot;, argv[c]);
747          goto Error;
748        }
749        if (!WebPConfigPreset(&amp;config, preset, config.quality)) {
750          fprintf(stderr, &quot;Error! Could initialize configuration with preset.\n&quot;);
751          goto Error;
752        }
753      } else if (!strcmp(argv[c], &quot;-metadata&quot;) &amp;&amp; c &lt; argc - 1) {
754        static const struct {
755          const char* option;
756          int flag;
757        } kTokens[] = {
758          { &quot;all&quot;,  METADATA_ALL },
759          { &quot;none&quot;, 0 },
760          { &quot;exif&quot;, METADATA_EXIF },
761          { &quot;icc&quot;,  METADATA_ICC },
762          { &quot;xmp&quot;,  METADATA_XMP },
763        };
764        const size_t kNumTokens = sizeof(kTokens) / sizeof(kTokens[0]);
765        const char* start = argv[++c];
766        const char* const end = start + strlen(start);
767        while (start &lt; end) {
768          size_t i;
769          const char* token = strchr(start, &#x27;,&#x27;);
770          if (token == NULL) token = end;
771          for (i = 0; i &lt; kNumTokens; ++i) {
772            if ((size_t)(token - start) == strlen(kTokens[i].option) &amp;&amp;
773                !strncmp(start, kTokens[i].option, strlen(kTokens[i].option))) {
774              if (kTokens[i].flag != 0) {
775                keep_metadata |= kTokens[i].flag;
776              } else {
777                keep_metadata = 0;
778              }
779              break;
780            }
781          }
782          if (i == kNumTokens) {
783            fprintf(stderr, &quot;Error! Unknown metadata type &#x27;%.*s&#x27;\n&quot;,
784                    (int)(token - start), start);
785            FREE_WARGV_AND_RETURN(-1);
786          }
787          start = token + 1;
788        }
789  #ifdef HAVE_WINCODEC_H
790        if (keep_metadata != 0 &amp;&amp; keep_metadata != METADATA_ICC) {
791          fprintf(stderr, &quot;Warning: only ICC profile extraction is currently&quot;
792                          &quot; supported on this platform!\n&quot;);
793        }
794  #endif
795      } else if (!strcmp(argv[c], &quot;-v&quot;)) {
796        verbose = 1;
797      } else if (!strcmp(argv[c], &quot;--&quot;)) {
798        if (c &lt; argc - 1) in_file = (const char*)GET_WARGV(argv, ++c);
799        break;
800      } else if (argv[c][0] == &#x27;-&#x27;) {
801        fprintf(stderr, &quot;Error! Unknown option &#x27;%s&#x27;\n&quot;, argv[c]);
802        HelpLong();
803        FREE_WARGV_AND_RETURN(-1);
804      } else {
805        in_file = (const char*)GET_WARGV(argv, c);
806      }
807      if (parse_error) {
808        HelpLong();
809        FREE_WARGV_AND_RETURN(-1);
810      }
811    }
812    if (in_file == NULL) {
813      fprintf(stderr, &quot;No input file specified!\n&quot;);
814      HelpShort();
815      goto Error;
816    }
817    if (use_lossless_preset == 1) {
818      if (!WebPConfigLosslessPreset(&amp;config, lossless_preset)) {
819        fprintf(stderr, &quot;Invalid lossless preset (-z %d)\n&quot;, lossless_preset);
820        goto Error;
821      }
822    }
823    if (!quiet &amp;&amp; config.lossless == 1) {
824      if (config.target_size &gt; 0 || config.target_PSNR &gt; 0) {
825        fprintf(stderr, &quot;Encoding for specified size or PSNR is not supported&quot;
826                        &quot; for lossless encoding. Ignoring such option(s)!\n&quot;);
827      }
828      if (config.partition_limit &gt; 0) {
829        fprintf(stderr, &quot;Partition limit option is not required for lossless&quot;
830                        &quot; encoding. Ignoring this option!\n&quot;);
831      }
832    }
833    if (config.target_size &gt; 0 || config.target_PSNR &gt; 0) {
834      if (config.pass == 1) config.pass = 6;
835    }
836    if (!WebPValidateConfig(&amp;config)) {
837      fprintf(stderr, &quot;Error! Invalid configuration.\n&quot;);
838      goto Error;
839    }
840    picture.use_argb = (config.lossless || config.use_sharp_yuv ||
841                        config.preprocessing &gt; 0 ||
842                        crop || (resize_w | resize_h) &gt; 0);
843    if (verbose) {
844      StopwatchReset(&amp;stop_watch);
845    }
846    if (!ReadPicture(in_file, &amp;picture, keep_alpha,
847                     (keep_metadata == 0) ? NULL : &amp;metadata)) {
848      WFPRINTF(stderr, &quot;Error! Cannot read input picture file &#x27;%s&#x27;\n&quot;,
849               (const W_CHAR*)in_file);
850      goto Error;
851    }
852    picture.progress_hook = (show_progress &amp;&amp; !quiet) ? ProgressReport : NULL;
853    if (blend_alpha) {
854      WebPBlendAlpha(&amp;picture, background_color);
855    }
856    if (verbose) {
857      const double read_time = StopwatchReadAndReset(&amp;stop_watch);
858      fprintf(stderr, &quot;Time to read input: %.3fs\n&quot;, read_time);
859    }
860    if (out_file != NULL) {
861      const int use_stdout = !WSTRCMP(out_file, &quot;-&quot;);
862      out = use_stdout ? ImgIoUtilSetBinaryMode(stdout) : WFOPEN(out_file, &quot;wb&quot;);
863      if (out == NULL) {
864        WFPRINTF(stderr, &quot;Error! Cannot open output file &#x27;%s&#x27;\n&quot;,
865                 (const W_CHAR*)out_file);
866        goto Error;
867      } else {
868        if (!short_output &amp;&amp; !quiet) {
869          WFPRINTF(stderr, &quot;Saving file &#x27;%s&#x27;\n&quot;, (const W_CHAR*)out_file);
870        }
871      }
872      if (keep_metadata == 0) {
873        picture.writer = MyWriter;
874        picture.custom_ptr = (void*)out;
875      } else {
876        picture.writer = WebPMemoryWrite;
877        picture.custom_ptr = (void*)&amp;memory_writer;
878      }
879    } else {
880      out = NULL;
881      if (!quiet &amp;&amp; !short_output) {
882        fprintf(stderr, &quot;No output file specified (no -o flag). Encoding will\n&quot;);
883        fprintf(stderr, &quot;be performed, but its results discarded.\n\n&quot;);
884      }
885    }
886    if (!quiet) {
887      picture.stats = &amp;stats;
888      picture.user_data = (void*)in_file;
889    }
890    if (verbose) {
891      StopwatchReset(&amp;stop_watch);
892    }
893    if (crop != 0) {
894      if (!WebPPictureView(&amp;picture, crop_x, crop_y, crop_w, crop_h, &amp;picture)) {
895        fprintf(stderr, &quot;Error! Cannot crop picture\n&quot;);
896        goto Error;
897      }
898    }
899    if ((resize_w | resize_h) &gt; 0) {
900      WebPPicture picture_no_alpha;
901      if (config.exact) {
902        if (!WebPPictureCopy(&amp;picture, &amp;picture_no_alpha)) {
903          fprintf(stderr, &quot;Error! Cannot copy temporary picture\n&quot;);
904          goto Error;
905        }
906        {
907          int x, y;
908          uint32_t* argb_no_alpha = picture_no_alpha.argb;
909          for (y = 0; y &lt; picture_no_alpha.height; ++y) {
910            for (x = 0; x &lt; picture_no_alpha.width; ++x) {
911              argb_no_alpha[x] |= 0xff000000;  
912            }
913            argb_no_alpha += picture_no_alpha.argb_stride;
914          }
915        }
916        if (!WebPPictureRescale(&amp;picture_no_alpha, resize_w, resize_h)) {
917          fprintf(stderr, &quot;Error! Cannot resize temporary picture\n&quot;);
918          goto Error;
919        }
920      }
921      if (!WebPPictureRescale(&amp;picture, resize_w, resize_h)) {
922        fprintf(stderr, &quot;Error! Cannot resize picture\n&quot;);
923        goto Error;
924      }
925      if (config.exact) {  
926        int x, y;
927        uint32_t* argb_no_alpha = picture_no_alpha.argb;
928        uint32_t* argb = picture.argb;
929        for (y = 0; y &lt; picture_no_alpha.height; ++y) {
930          for (x = 0; x &lt; picture_no_alpha.width; ++x) {
931            argb[x] = (argb[x] &amp; 0xff000000) | (argb_no_alpha[x] &amp; 0x00ffffff);
932          }
933          argb_no_alpha += picture_no_alpha.argb_stride;
934          argb += picture.argb_stride;
935        }
936        WebPPictureFree(&amp;picture_no_alpha);
937      }
938    }
939    if (verbose &amp;&amp; (crop != 0 || (resize_w | resize_h) &gt; 0)) {
940      const double preproc_time = StopwatchReadAndReset(&amp;stop_watch);
941      fprintf(stderr, &quot;Time to crop/resize picture: %.3fs\n&quot;, preproc_time);
942    }
943    if (picture.extra_info_type &gt; 0) {
944      AllocExtraInfo(&amp;picture);
945    }
946    if (print_distortion &gt;= 0) {  
947      WebPPictureCopy(&amp;picture, &amp;original_picture);
948    }
949    if (verbose) {
950      StopwatchReset(&amp;stop_watch);
951    }
952    if (!WebPEncode(&amp;config, &amp;picture)) {
953      fprintf(stderr, &quot;Error! Cannot encode picture as WebP\n&quot;);
954      fprintf(stderr, &quot;Error code: %d (%s)\n&quot;,
955              picture.error_code, kErrorMessages[picture.error_code]);
956      goto Error;
957    }
958    if (verbose) {
959      const double encode_time = StopwatchReadAndReset(&amp;stop_watch);
960      fprintf(stderr, &quot;Time to encode picture: %.3fs\n&quot;, encode_time);
961    }
962    if (dump_file) {
963      if (picture.use_argb) {
964        fprintf(stderr, &quot;Warning: can&#x27;t dump file (-d option) &quot;
965                        &quot;in lossless mode.\n&quot;);
966      } else if (!DumpPicture(&amp;picture, dump_file)) {
967        WFPRINTF(stderr, &quot;Warning, couldn&#x27;t dump picture %s\n&quot;,
968                 (const W_CHAR*)dump_file);
969      }
970    }
971    if (keep_metadata != 0) {
972      if (out != NULL) {
973        if (!WriteWebPWithMetadata(out, &amp;picture, &amp;memory_writer,
974                                   &amp;metadata, keep_metadata, &amp;metadata_written)) {
975          fprintf(stderr, &quot;Error writing WebP file with metadata!\n&quot;);
976          goto Error;
977        }
978      } else {  
979        const struct {
980          const MetadataPayload* const payload;
981          int flag;
982        } *iter, info[] = {
983          { &amp;metadata.exif, METADATA_EXIF },
984          { &amp;metadata.iccp, METADATA_ICC },
985          { &amp;metadata.xmp, METADATA_XMP },
986          { NULL, 0 }
987        };
988        uint32_t unused1 = 0;
989        uint64_t unused2 = 0;
990        for (iter = info; iter-&gt;payload != NULL; ++iter) {
991          if (UpdateFlagsAndSize(iter-&gt;payload, !!(keep_metadata &amp; iter-&gt;flag),
992                                 0, &amp;unused1, &amp;unused2)) {
993            metadata_written |= iter-&gt;flag;
994          }
995        }
996      }
997    }
998    if (!quiet) {
999      if (!short_output || print_distortion &lt; 0) {
1000        if (config.lossless) {
1001          PrintExtraInfoLossless(&amp;picture, short_output, in_file);
1002        } else {
1003          PrintExtraInfoLossy(&amp;picture, short_output, config.low_memory, in_file);
1004        }
1005      }
1006      if (!short_output &amp;&amp; picture.extra_info_type &gt; 0) {
1007        PrintMapInfo(&amp;picture);
1008      }
1009      if (print_distortion &gt;= 0) {    
1010        static const char* distortion_names[] = { &quot;PSNR&quot;, &quot;SSIM&quot;, &quot;LSIM&quot; };
1011        float values[5];
1012        if (!WebPPictureDistortion(&amp;picture, &amp;original_picture,
1013                                   print_distortion, values)) {
1014          fprintf(stderr, &quot;Error while computing the distortion.\n&quot;);
1015          goto Error;
1016        }
1017        if (!short_output) {
1018          fprintf(stderr, &quot;%s: &quot;, distortion_names[print_distortion]);
1019          fprintf(stderr, &quot;B:%.2f G:%.2f R:%.2f A:%.2f  Total:%.2f\n&quot;,
1020                  values[0], values[1], values[2], values[3], values[4]);
1021        } else {
1022          fprintf(stderr, &quot;%7d %.4f\n&quot;, picture.stats-&gt;coded_size, values[4]);
1023        }
1024      }
1025      if (!short_output) {
1026        PrintMetadataInfo(&amp;metadata, metadata_written);
1027      }
1028    }
1029    return_value = 0;
1030   Error:
1031    WebPMemoryWriterClear(&amp;memory_writer);
1032    WebPFree(picture.extra_info);
1033    MetadataFree(&amp;metadata);
1034    WebPPictureFree(&amp;picture);
1035    WebPPictureFree(&amp;original_picture);
1036    if (out != NULL &amp;&amp; out != stdout) {
1037      fclose(out);
1038    }
1039    FREE_WARGV_AND_RETURN(return_value);
1040  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dwebp.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-cwebp.c</div>
                </div>
                <div class="column column_space"><pre><code>17  extern &quot;C&quot; {
18  #endif
19  extern void* VP8GetCPUInfo;   
20  #ifdef __cplusplus
21  }    
22  #endif
23  #endif  
24  static int SaveOutput(const WebPDecBuffer* const buffer,
</pre></code></div>
                <div class="column column_space"><pre><code>15  extern &quot;C&quot; {
16  #endif
17  extern void* VP8GetCPUInfo;   
18  #ifdef __cplusplus
19  }    
20  #endif
21  #endif  
22  static int verbose = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    