
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.5502958579881656%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_Signal_Process.c</h3>
            <pre><code>1  #include "Win32_Signal_Process.h"
2  #include <errno.h>
3  #define UNUSED(V) ((void) V)
4  int sigaction(int sig, struct sigaction *in, struct sigaction *out) {
5      UNUSED(out);
6      if (in->sa_flags & SA_SIGINFO) {
7          signal(sig, in->sa_sigaction);
8      } else {
9          signal(sig, in->sa_handler);
10      }
11      return 0;
12  }
<span onclick='openModal()' class='match'>13  int kill(pid_t pid, int sig) {
14      if (sig == SIGUSR1) {
15          return 0;
16      } else if (sig == SIGKILL) {
17          HANDLE h = OpenProcess(PROCESS_TERMINATE, 0, pid);
</span>18          if (!TerminateProcess(h, 127)) {
19              errno = EINVAL; &bsol;* GetLastError() */
20              CloseHandle(h);
21              return -1;
22          };
23          CloseHandle(h);
24          return 0;
25      } else {
26          errno = EINVAL;
27          return -1;
28      }
29  }
30  int getrusage(int who, struct rusage * r) {
31      FILETIME starttime, exittime, kerneltime, usertime;
32      ULARGE_INTEGER li;
33      if (r == NULL) {
34          errno = EFAULT;
35          return -1;
36      }
37      memset(r, 0, sizeof(struct rusage));
38      if (who == RUSAGE_SELF) {
39          if (!GetProcessTimes(GetCurrentProcess(),
40              &starttime,
41              &exittime,
42              &kerneltime,
43              &usertime))
44          {
45              errno = EFAULT;
46              return -1;
47          }
48      }
49      if (who == RUSAGE_CHILDREN) {
50          starttime.dwLowDateTime = 0;
51          starttime.dwHighDateTime = 0;
52          exittime.dwLowDateTime = 0;
53          exittime.dwHighDateTime = 0;
54          kerneltime.dwLowDateTime = 0;
55          kerneltime.dwHighDateTime = 0;
56          usertime.dwLowDateTime = 0;
57          usertime.dwHighDateTime = 0;
58      }
59      memcpy(&li, &kerneltime, sizeof(FILETIME));
60      li.QuadPart /= 10L;
61      r->ru_stime.tv_sec = (long) (li.QuadPart / 1000000L);
62      r->ru_stime.tv_usec = (long) (li.QuadPart % 1000000L);
63      memcpy(&li, &usertime, sizeof(FILETIME));
64      li.QuadPart /= 10L;
65      r->ru_utime.tv_sec = (long) (li.QuadPart / 1000000L);
66      r->ru_utime.tv_usec = (long) (li.QuadPart % 1000000L);
67      return 0;
68  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-snf.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #ifndef _WIN32
5  #include <sys/param.h>
6  #endif &bsol;* !_WIN32 */
7  #include <stdlib.h>
8  #include <string.h>
9  #include <errno.h>
10  #include <limits.h> &bsol;* for INT_MAX */
11  #ifndef _WIN32
12  #include <netinet/in.h>
13  #include <sys/mman.h>
14  #include <sys/socket.h>
15  #include <sys/types.h>
16  #include <unistd.h>
17  #endif &bsol;* !_WIN32 */
18  #include <snf.h>
19  #if SNF_VERSION_API >= 0x0003
20  #define SNF_HAVE_INJECT_API
21  #endif
22  #include "pcap-int.h"
23  #include "pcap-snf.h"
24  struct pcap_snf {
25  	snf_handle_t snf_handle; &bsol;* opaque device handle */
26  	snf_ring_t   snf_ring;   &bsol;* opaque device ring handle */
27  #ifdef SNF_HAVE_INJECT_API
28  	snf_inject_t snf_inj;    &bsol;* inject handle, if inject is used */
29  #endif
30  	int          snf_timeout;
31  	int          snf_boardnum;
32  };
33  static int
34  snf_set_datalink(pcap_t *p, int dlt)
35  {
36  	p->linktype = dlt;
37  	return (0);
38  }
39  static int
40  snf_pcap_stats(pcap_t *p, struct pcap_stat *ps)
41  {
42  	struct snf_ring_stats stats;
43  	struct pcap_snf *snfps = p->priv;
44  	int rc;
45  	if ((rc = snf_ring_getstats(snfps->snf_ring, &stats))) {
46  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
47  		    rc, "snf_get_stats");
48  		return -1;
49  	}
50  	ps->ps_recv = stats.ring_pkt_recv + stats.ring_pkt_overflow;
51  	ps->ps_drop = stats.ring_pkt_overflow;
52  	ps->ps_ifdrop = stats.nic_pkt_overflow + stats.nic_pkt_bad;
53  	return 0;
54  }
55  static void
56  snf_platform_cleanup(pcap_t *p)
57  {
58  	struct pcap_snf *ps = p->priv;
59  #ifdef SNF_HAVE_INJECT_API
60  	if (ps->snf_inj)
61  		snf_inject_close(ps->snf_inj);
62  #endif
63  	snf_ring_close(ps->snf_ring);
64  	snf_close(ps->snf_handle);
65  	pcap_cleanup_live_common(p);
66  }
67  static int
68  snf_getnonblock(pcap_t *p)
69  {
70  	struct pcap_snf *ps = p->priv;
71  	return (ps->snf_timeout == 0);
72  }
73  static int
74  snf_setnonblock(pcap_t *p, int nonblock)
75  {
76  	struct pcap_snf *ps = p->priv;
77  	if (nonblock)
78  		ps->snf_timeout = 0;
79  	else {
80  		if (p->opt.timeout <= 0)
81  			ps->snf_timeout = -1; &bsol;* forever */
82  		else
83  			ps->snf_timeout = p->opt.timeout;
84  	}
85  	return (0);
86  }
87  #define _NSEC_PER_SEC 1000000000
88  static inline
89  struct timeval
90  snf_timestamp_to_timeval(const int64_t ts_nanosec, const int tstamp_precision)
91  {
92  	struct timeval tv;
93  	long tv_nsec;
94          const static struct timeval zero_timeval;
95          if (ts_nanosec == 0)
96                  return zero_timeval;
97  	tv.tv_sec = ts_nanosec / _NSEC_PER_SEC;
98  	tv_nsec = (ts_nanosec % _NSEC_PER_SEC);
99  	if (tstamp_precision == PCAP_TSTAMP_PRECISION_NANO)
100  		tv.tv_usec = tv_nsec;
101  	else
102  		tv.tv_usec = tv_nsec / 1000;
103  	return tv;
104  }
105  static int
106  snf_read(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
107  {
108  	struct pcap_snf *ps = p->priv;
109  	struct pcap_pkthdr hdr;
110  	int i, flags, err, caplen, n;
111  	struct snf_recv_req req;
112  	int nonblock, timeout;
113  	if (PACKET_COUNT_IS_UNLIMITED(cnt))
114  		cnt = INT_MAX;
115  	n = 0;
116  	timeout = ps->snf_timeout;
117  	while (n < cnt) {
118  		if (p->break_loop) {
119  			if (n == 0) {
120  				p->break_loop = 0;
121  				return (-2);
122  			} else {
123  				return (n);
124  			}
125  		}
126  		err = snf_ring_recv(ps->snf_ring, timeout, &req);
<span onclick='openModal()' class='match'>127  		if (err) {
128  			if (err == EBUSY || err == EAGAIN) {
129  				return (n);
130  			}
131  			else if (err == EINTR) {
132  				timeout = 0;
</span>133  				continue;
134  			}
135  			else {
136  				pcap_fmt_errmsg_for_errno(p->errbuf,
137  				    PCAP_ERRBUF_SIZE, err, "snf_read");
138  				return -1;
139  			}
140  		}
141  		caplen = req.length;
142  		if (caplen > p->snapshot)
143  			caplen = p->snapshot;
144  		if ((p->fcode.bf_insns == NULL) ||
145  		     pcap_filter(p->fcode.bf_insns, req.pkt_addr, req.length, caplen)) {
146  			hdr.ts = snf_timestamp_to_timeval(req.timestamp, p->opt.tstamp_precision);
147  			hdr.caplen = caplen;
148  			hdr.len = req.length;
149  			callback(user, &hdr, req.pkt_addr);
150  			n++;
151  		}
152  		if (timeout != 0)
153  			timeout = 0;
154  	}
155  	return (n);
156  }
157  static int
158  snf_inject(pcap_t *p, const void *buf _U_, int size _U_)
159  {
160  #ifdef SNF_HAVE_INJECT_API
161  	struct pcap_snf *ps = p->priv;
162  	int rc;
163  	if (ps->snf_inj == NULL) {
164  		rc = snf_inject_open(ps->snf_boardnum, 0, &ps->snf_inj);
165  		if (rc) {
166  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
167  			    rc, "snf_inject_open");
168  			return (-1);
169  		}
170  	}
171  	rc = snf_inject_send(ps->snf_inj, -1, 0, buf, size);
172  	if (!rc) {
173  		return (size);
174  	}
175  	else {
176  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
177  		    rc, "snf_inject_send");
178  		return (-1);
179  	}
180  #else
181  	pcap_strlcpy(p->errbuf, "Sending packets isn't supported with this snf version",
182  	    PCAP_ERRBUF_SIZE);
183  	return (-1);
184  #endif
185  }
186  static int
187  snf_activate(pcap_t* p)
188  {
189  	struct pcap_snf *ps = p->priv;
190  	char *device = p->opt.device;
191  	const char *nr = NULL;
192  	int err;
193  	int flags = -1, ring_id = -1;
194  	if (device == NULL) {
195  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "device is NULL");
196  		return -1;
197  	}
198  	if ((nr = getenv("SNF_FLAGS")) && *nr)
199  		flags = strtol(nr, NULL, 0);
200  	else if ((nr = getenv("SNF_NUM_RINGS")) && *nr && atoi(nr) > 1)
201  		flags = SNF_F_PSHARED;
202  	else
203  		nr = NULL;
204  	err = snf_open(ps->snf_boardnum,
205  			0, &bsol;* let SNF API parse SNF_NUM_RINGS, if set */
206  			NULL, &bsol;* default RSS, or use SNF_RSS_FLAGS env */
207                          (p->opt.buffer_size > 0 && p->opt.buffer_size < 1048576) ? 1048576 : p->opt.buffer_size, &bsol;* default to SNF_DATARING_SIZE from env */
208  			flags, &bsol;* may want pshared */
209  			&ps->snf_handle);
210  	if (err != 0) {
211  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
212  		    err, "snf_open failed");
213  		return -1;
214  	}
215  	if ((nr = getenv("SNF_PCAP_RING_ID")) && *nr) {
216  		ring_id = (int) strtol(nr, NULL, 0);
217  	}
218  	err = snf_ring_open_id(ps->snf_handle, ring_id, &ps->snf_ring);
219  	if (err != 0) {
220  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
221  		    err, "snf_ring_open_id(ring=%d) failed", ring_id);
222  		return -1;
223  	}
224  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
225  		p->snapshot = MAXIMUM_SNAPLEN;
226  	if (p->opt.timeout <= 0)
227  		ps->snf_timeout = -1;
228  	else
229  		ps->snf_timeout = p->opt.timeout;
230  	err = snf_start(ps->snf_handle);
231  	if (err != 0) {
232  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
233  		    err, "snf_start failed");
234  		return -1;
235  	}
236  #ifndef _WIN32
237  	p->selectable_fd = -1;
238  #endif &bsol;* !_WIN32 */
239  	p->linktype = DLT_EN10MB;
240  	p->read_op = snf_read;
241  	p->inject_op = snf_inject;
242  	p->setfilter_op = pcap_install_bpf_program;
243  	p->setdirection_op = NULL; &bsol;* Not implemented.*/
244  	p->set_datalink_op = snf_set_datalink;
245  	p->getnonblock_op = snf_getnonblock;
246  	p->setnonblock_op = snf_setnonblock;
247  	p->stats_op = snf_pcap_stats;
248  	p->cleanup_op = snf_platform_cleanup;
249  #ifdef SNF_HAVE_INJECT_API
250  	ps->snf_inj = NULL;
251  #endif
252  	return 0;
253  }
254  #define MAX_DESC_LENGTH 128
255  int
256  snf_findalldevs(pcap_if_list_t *devlistp, char *errbuf)
257  {
258  	pcap_if_t *dev;
259  #ifdef _WIN32
260  	struct sockaddr_in addr;
261  #endif
262  	struct snf_ifaddrs *ifaddrs, *ifa;
263  	char name[MAX_DESC_LENGTH];
264  	char desc[MAX_DESC_LENGTH];
265  	int ret, allports = 0, merge = 0;
266  	const char *nr = NULL;
267  	if (snf_init(SNF_VERSION_API)) {
268  		(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
269  		    "snf_getifaddrs: snf_init failed");
270  		return (-1);
271  	}
272  	if (snf_getifaddrs(&ifaddrs) || ifaddrs == NULL)
273  	{
274  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
275  		    errno, "snf_getifaddrs");
276  		return (-1);
277  	}
278  	if ((nr = getenv("SNF_FLAGS")) && *nr) {
279  		errno = 0;
280  		merge = strtol(nr, NULL, 0);
281  		if (errno) {
282  			(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,
283  				"snf_getifaddrs: SNF_FLAGS is not a valid number");
284  			return (-1);
285  		}
286  		merge = merge & SNF_F_AGGREGATE_PORTMASK;
287  	}
288  	for (ifa = ifaddrs; ifa != NULL; ifa = ifa->snf_ifa_next) {
289  		(void)snprintf(desc,MAX_DESC_LENGTH,"Myricom %ssnf%d",
290  			merge ? "Merge Bitmask Port " : "",
291  			merge ? 1 << ifa->snf_ifa_portnum : ifa->snf_ifa_portnum);
292  		if (merge)
293  			allports |= 1 << ifa->snf_ifa_portnum;
294  		dev = pcap_find_dev(devlistp, ifa->snf_ifa_name);
295  		if (dev != NULL) {
296  			char *desc_str;
297  			desc_str = strdup(desc);
298  			if (desc_str == NULL) {
299  				pcap_fmt_errmsg_for_errno(errbuf,
300  				    PCAP_ERRBUF_SIZE, errno,
301  				    "snf_findalldevs strdup");
302  				return -1;
303  			}
304  			free(dev->description);
305  			dev->description = desc_str;
306  		} else {
307  			dev = pcap_add_dev(devlistp, ifa->snf_ifa_name, 0, desc,
308  			    errbuf);
309  			if (dev == NULL)
310  				return -1;
311  #ifdef _WIN32
312                          ret = inet_pton(AF_INET, dev->name, &addr.sin_addr);
313                          if (ret == 1) {
314  				addr.sin_family = AF_INET;
315  				if (pcap_add_addr_to_dev(dev, &addr, sizeof(addr),
316  				    NULL, 0, NULL, 0, NULL, 0, errbuf) == -1)
317  					return -1;
318                          } else if (ret == -1) {
319  				pcap_fmt_errmsg_for_errno(errbuf,
320  				    PCAP_ERRBUF_SIZE, errno,
321  				    "sinf_findalldevs inet_pton");
322                                  return -1;
323                          }
324  #endif _WIN32
325  		}
326  	}
327  	snf_freeifaddrs(ifaddrs);
328  	if (merge) {
329  		(void)snprintf(name,MAX_DESC_LENGTH,"snf%d",allports);
330  		(void)snprintf(desc,MAX_DESC_LENGTH,"Myricom Merge Bitmask All Ports snf%d",
331  			allports);
332  		if (pcap_add_dev(devlistp, name,
333  		    PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE, desc,
334  		    errbuf) == NULL)
335  			return (-1);
336  	}
337  	return 0;
338  }
339  pcap_t *
340  snf_create(const char *device, char *ebuf, int *is_ours)
341  {
342  	pcap_t *p;
343  	int boardnum = -1;
344  	struct snf_ifaddrs *ifaddrs, *ifa;
345  	size_t devlen;
346  	struct pcap_snf *ps;
347  	if (snf_init(SNF_VERSION_API)) {
348  		*is_ours = 0;
349  		return NULL;
350  	}
351  	if (snf_getifaddrs(&ifaddrs) || ifaddrs == NULL) {
352  		*is_ours = 0;
353  		return NULL;
354  	}
355  	devlen = strlen(device) + 1;
356  	ifa = ifaddrs;
357  	while (ifa) {
358  		if (strncmp(device, ifa->snf_ifa_name, devlen) == 0) {
359  			boardnum = ifa->snf_ifa_boardnum;
360  			break;
361  		}
362  		ifa = ifa->snf_ifa_next;
363  	}
364  	snf_freeifaddrs(ifaddrs);
365  	if (ifa == NULL) {
366  		if (sscanf(device, "snf10g%d", &boardnum) != 1 &&
367  		    sscanf(device, "snf%d", &boardnum) != 1) {
368  			*is_ours = 0;
369  			return NULL;
370  		}
371  	}
372  	*is_ours = 1;
373  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_snf);
374  	if (p == NULL)
375  		return NULL;
376  	ps = p->priv;
377  	p->tstamp_precision_list = malloc(2 * sizeof(u_int));
378  	if (p->tstamp_precision_list == NULL) {
379  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,
380  		    "malloc");
381  		pcap_close(p);
382  		return NULL;
383  	}
384  	p->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;
385  	p->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;
386  	p->tstamp_precision_count = 2;
387  	p->activate_op = snf_activate;
388  	ps->snf_boardnum = boardnum;
389  	return p;
390  }
391  #ifdef SNF_ONLY
392  int
393  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
394  {
395  	return (0);
396  }
397  pcap_t *
398  pcap_create_interface(const char *device, char *errbuf)
399  {
400  	snprintf(errbuf, PCAP_ERRBUF_SIZE,
401  	    "This version of libpcap only supports SNF cards");
402  	return NULL;
403  }
404  const char *
405  pcap_lib_version(void)
406  {
407  	return (PCAP_VERSION_STRING " (SNF-only)");
408  }
409  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_Signal_Process.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-snf.c</div>
                </div>
                <div class="column column_space"><pre><code>13  int kill(pid_t pid, int sig) {
14      if (sig == SIGUSR1) {
15          return 0;
16      } else if (sig == SIGKILL) {
17          HANDLE h = OpenProcess(PROCESS_TERMINATE, 0, pid);
</pre></code></div>
                <div class="column column_space"><pre><code>127  		if (err) {
128  			if (err == EBUSY || err == EAGAIN) {
129  				return (n);
130  			}
131  			else if (err == EINTR) {
132  				timeout = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    