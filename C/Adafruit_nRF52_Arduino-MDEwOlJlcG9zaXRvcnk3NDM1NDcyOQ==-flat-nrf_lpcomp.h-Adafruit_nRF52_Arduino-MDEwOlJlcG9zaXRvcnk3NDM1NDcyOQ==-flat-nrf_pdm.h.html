
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 53.95894428152492%, Tokens: 9</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_lpcomp.h</h3>
            <pre><code>1  #ifndef NRF_LPCOMP_H_
2  #define NRF_LPCOMP_H_
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9  #if (LPCOMP_REFSEL_RESOLUTION == 8) || defined(__NRFX_DOXYGEN__)
10      NRF_LPCOMP_REF_SUPPLY_1_8   = LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling,    &bsol;**< Use supply with a 1/8 prescaler as reference. */
11      NRF_LPCOMP_REF_SUPPLY_2_8   = LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling,   &bsol;**< Use supply with a 2/8 prescaler as reference. */
12      NRF_LPCOMP_REF_SUPPLY_3_8   = LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling, &bsol;**< Use supply with a 3/8 prescaler as reference. */
13      NRF_LPCOMP_REF_SUPPLY_4_8   = LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling,  &bsol;**< Use supply with a 4/8 prescaler as reference. */
14      NRF_LPCOMP_REF_SUPPLY_5_8   = LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling,  &bsol;**< Use supply with a 5/8 prescaler as reference. */
15      NRF_LPCOMP_REF_SUPPLY_6_8   = LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling,   &bsol;**< Use supply with a 6/8 prescaler as reference. */
16      NRF_LPCOMP_REF_SUPPLY_7_8   = LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling, &bsol;**< Use supply with a 7/8 prescaler as reference. */
17  #elif (LPCOMP_REFSEL_RESOLUTION == 16) || defined(__NRFX_DOXYGEN__)
18      NRF_LPCOMP_REF_SUPPLY_1_8   = LPCOMP_REFSEL_REFSEL_Ref1_8Vdd,   &bsol;**< Use supply with a 1/8 prescaler as reference. */
19      NRF_LPCOMP_REF_SUPPLY_2_8   = LPCOMP_REFSEL_REFSEL_Ref2_8Vdd,   &bsol;**< Use supply with a 2/8 prescaler as reference. */
20      NRF_LPCOMP_REF_SUPPLY_3_8   = LPCOMP_REFSEL_REFSEL_Ref3_8Vdd,   &bsol;**< Use supply with a 3/8 prescaler as reference. */
21      NRF_LPCOMP_REF_SUPPLY_4_8   = LPCOMP_REFSEL_REFSEL_Ref4_8Vdd,   &bsol;**< Use supply with a 4/8 prescaler as reference. */
22      NRF_LPCOMP_REF_SUPPLY_5_8   = LPCOMP_REFSEL_REFSEL_Ref5_8Vdd,   &bsol;**< Use supply with a 5/8 prescaler as reference. */
23      NRF_LPCOMP_REF_SUPPLY_6_8   = LPCOMP_REFSEL_REFSEL_Ref6_8Vdd,   &bsol;**< Use supply with a 6/8 prescaler as reference. */
24      NRF_LPCOMP_REF_SUPPLY_7_8   = LPCOMP_REFSEL_REFSEL_Ref7_8Vdd,   &bsol;**< Use supply with a 7/8 prescaler as reference. */
25      NRF_LPCOMP_REF_SUPPLY_1_16  = LPCOMP_REFSEL_REFSEL_Ref1_16Vdd,  &bsol;**< Use supply with a 1/16 prescaler as reference. */
26      NRF_LPCOMP_REF_SUPPLY_3_16  = LPCOMP_REFSEL_REFSEL_Ref3_16Vdd,  &bsol;**< Use supply with a 3/16 prescaler as reference. */
27      NRF_LPCOMP_REF_SUPPLY_5_16  = LPCOMP_REFSEL_REFSEL_Ref5_16Vdd,  &bsol;**< Use supply with a 5/16 prescaler as reference. */
28      NRF_LPCOMP_REF_SUPPLY_7_16  = LPCOMP_REFSEL_REFSEL_Ref7_16Vdd,  &bsol;**< Use supply with a 7/16 prescaler as reference. */
29      NRF_LPCOMP_REF_SUPPLY_9_16  = LPCOMP_REFSEL_REFSEL_Ref9_16Vdd,  &bsol;**< Use supply with a 9/16 prescaler as reference. */
30      NRF_LPCOMP_REF_SUPPLY_11_16 = LPCOMP_REFSEL_REFSEL_Ref11_16Vdd, &bsol;**< Use supply with a 11/16 prescaler as reference. */
31      NRF_LPCOMP_REF_SUPPLY_13_16 = LPCOMP_REFSEL_REFSEL_Ref13_16Vdd, &bsol;**< Use supply with a 13/16 prescaler as reference. */
32      NRF_LPCOMP_REF_SUPPLY_15_16 = LPCOMP_REFSEL_REFSEL_Ref15_16Vdd, &bsol;**< Use supply with a 15/16 prescaler as reference. */
33  #endif
34      NRF_LPCOMP_REF_EXT_REF0     = LPCOMP_REFSEL_REFSEL_ARef |
35                                    (LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 << 16), &bsol;**< External reference 0. */
36      NRF_LPCOMP_REF_EXT_REF1     = LPCOMP_REFSEL_REFSEL_ARef |
37                                    (LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 << 16), &bsol;**< External reference 1. */
38  } nrf_lpcomp_ref_t;
39  typedef enum
40  {
41      NRF_LPCOMP_INPUT_0 = LPCOMP_PSEL_PSEL_AnalogInput0, &bsol;**< Input 0. */
42      NRF_LPCOMP_INPUT_1 = LPCOMP_PSEL_PSEL_AnalogInput1, &bsol;**< Input 1. */
43      NRF_LPCOMP_INPUT_2 = LPCOMP_PSEL_PSEL_AnalogInput2, &bsol;**< Input 2. */
44      NRF_LPCOMP_INPUT_3 = LPCOMP_PSEL_PSEL_AnalogInput3, &bsol;**< Input 3. */
45      NRF_LPCOMP_INPUT_4 = LPCOMP_PSEL_PSEL_AnalogInput4, &bsol;**< Input 4. */
46      NRF_LPCOMP_INPUT_5 = LPCOMP_PSEL_PSEL_AnalogInput5, &bsol;**< Input 5. */
47      NRF_LPCOMP_INPUT_6 = LPCOMP_PSEL_PSEL_AnalogInput6, &bsol;**< Input 6. */
48      NRF_LPCOMP_INPUT_7 = LPCOMP_PSEL_PSEL_AnalogInput7  &bsol;**< Input 7. */
49  } nrf_lpcomp_input_t;
50  typedef enum
51  {
52      NRF_LPCOMP_DETECT_CROSS = LPCOMP_ANADETECT_ANADETECT_Cross, &bsol;**< Generate ANADETEC on crossing, both upwards and downwards crossing. */
53      NRF_LPCOMP_DETECT_UP    = LPCOMP_ANADETECT_ANADETECT_Up,    &bsol;**< Generate ANADETEC on upwards crossing only. */
54      NRF_LPCOMP_DETECT_DOWN  = LPCOMP_ANADETECT_ANADETECT_Down   &bsol;**< Generate ANADETEC on downwards crossing only. */
55  } nrf_lpcomp_detect_t;
56  typedef enum
57  {
58      NRF_LPCOMP_TASK_START  = offsetof(NRF_LPCOMP_Type, TASKS_START), &bsol;**< LPCOMP start sampling task. */
59      NRF_LPCOMP_TASK_STOP   = offsetof(NRF_LPCOMP_Type, TASKS_STOP),  &bsol;**< LPCOMP stop sampling task. */
60      NRF_LPCOMP_TASK_SAMPLE = offsetof(NRF_LPCOMP_Type, TASKS_SAMPLE) &bsol;**< Sample comparator value. */
61  } nrf_lpcomp_task_t;
62  typedef enum
63  {
64      NRF_LPCOMP_EVENT_READY = offsetof(NRF_LPCOMP_Type, EVENTS_READY), &bsol;**< LPCOMP is ready and output is valid. */
65      NRF_LPCOMP_EVENT_DOWN  = offsetof(NRF_LPCOMP_Type, EVENTS_DOWN),  &bsol;**< Input voltage crossed the threshold going down. */
66      NRF_LPCOMP_EVENT_UP    = offsetof(NRF_LPCOMP_Type, EVENTS_UP),    &bsol;**< Input voltage crossed the threshold going up. */
67      NRF_LPCOMP_EVENT_CROSS = offsetof(NRF_LPCOMP_Type, EVENTS_CROSS)  &bsol;**< Input voltage crossed the threshold in any direction. */
68  } nrf_lpcomp_event_t;
69  typedef enum
70  {
71      NRF_LPCOMP_SHORT_CROSS_STOP_MASK   = LPCOMP_SHORTS_CROSS_STOP_Msk,  &bsol;*!< Shortcut between CROSS event and STOP task. */
72      NRF_LPCOMP_SHORT_UP_STOP_MASK      = LPCOMP_SHORTS_UP_STOP_Msk,     &bsol;*!< Shortcut between UP event and STOP task. */
73      NRF_LPCOMP_SHORT_DOWN_STOP_MASK    = LPCOMP_SHORTS_DOWN_STOP_Msk,   &bsol;*!< Shortcut between DOWN event and STOP task. */
74      NRF_LPCOMP_SHORT_READY_STOP_MASK   = LPCOMP_SHORTS_READY_STOP_Msk,  &bsol;*!< Shortcut between READY event and STOP task. */
75      NRF_LPCOMP_SHORT_READY_SAMPLE_MASK = LPCOMP_SHORTS_READY_SAMPLE_Msk &bsol;*!< Shortcut between READY event and SAMPLE task. */
76  } nrf_lpcomp_short_mask_t;
77  #if defined(LPCOMP_FEATURE_HYST_PRESENT) || defined(__NRFX_DOXYGEN__)
78  typedef enum
79  {
80  #ifdef LPCOMP_HYST_HYST_NoHyst
81      NRF_LPCOMP_HYST_NOHYST  = LPCOMP_HYST_HYST_NoHyst,   &bsol;**< Comparator hysteresis disabled. */
82  #else
83      NRF_LPCOMP_HYST_NOHYST  = LPCOMP_HYST_HYST_Disabled, &bsol;**< Comparator hysteresis disabled. */
84  #endif
85  #ifdef LPCOMP_HYST_HYST_Hyst50mV
86      NRF_LPCOMP_HYST_ENABLED = LPCOMP_HYST_HYST_Hyst50mV  &bsol;**< Comparator hysteresis enabled (typically 50 mV). */
87  #else
88      NRF_LPCOMP_HYST_ENABLED = LPCOMP_HYST_HYST_Enabled   &bsol;**< Comparator hysteresis enabled (typically 50 mV). */
89  #endif
90  }nrf_lpcomp_hysteresis_t;
91  #endif 
92  typedef struct
93  {
94      nrf_lpcomp_ref_t        reference; &bsol;**< LPCOMP reference. */
95      nrf_lpcomp_detect_t     detection; &bsol;**< LPCOMP detection type. */
96  #if defined(LPCOMP_FEATURE_HYST_PRESENT) || defined(__NRFX_DOXYGEN__)
97      nrf_lpcomp_hysteresis_t hyst;      &bsol;**< LPCOMP hysteresis. */
98  #endif 
99  } nrf_lpcomp_config_t;
100  NRF_STATIC_INLINE void nrf_lpcomp_configure(NRF_LPCOMP_Type *           p_reg,
101                                              nrf_lpcomp_config_t const * p_config);
102  NRF_STATIC_INLINE void nrf_lpcomp_input_select(NRF_LPCOMP_Type * p_reg, nrf_lpcomp_input_t input);
103  NRF_STATIC_INLINE void nrf_lpcomp_enable(NRF_LPCOMP_Type * p_reg);
104  NRF_STATIC_INLINE void nrf_lpcomp_disable(NRF_LPCOMP_Type * p_reg);
105  NRF_STATIC_INLINE uint32_t nrf_lpcomp_result_get(NRF_LPCOMP_Type const * p_reg);
106  NRF_STATIC_INLINE void nrf_lpcomp_int_enable(NRF_LPCOMP_Type * p_reg, uint32_t mask);
107  NRF_STATIC_INLINE void nrf_lpcomp_int_disable(NRF_LPCOMP_Type * p_reg, uint32_t mask);
108  NRF_STATIC_INLINE uint32_t nrf_lpcomp_int_enable_check(NRF_LPCOMP_Type const * p_reg,
109                                                         uint32_t                mask);
110  NRF_STATIC_INLINE uint32_t nrf_lpcomp_task_address_get(NRF_LPCOMP_Type const * p_reg,
111                                                         nrf_lpcomp_task_t       task);
112  NRF_STATIC_INLINE uint32_t nrf_lpcomp_event_address_get(NRF_LPCOMP_Type const * p_reg,
113                                                          nrf_lpcomp_event_t      event);
114  NRF_STATIC_INLINE void nrf_lpcomp_shorts_enable(NRF_LPCOMP_Type * p_reg, uint32_t mask);
115  NRF_STATIC_INLINE void nrf_lpcomp_shorts_disable(NRF_LPCOMP_Type * p_reg, uint32_t mask);
116  NRF_STATIC_INLINE void nrf_lpcomp_task_trigger(NRF_LPCOMP_Type * p_reg, nrf_lpcomp_task_t task);
117  NRF_STATIC_INLINE void nrf_lpcomp_event_clear(NRF_LPCOMP_Type * p_reg, nrf_lpcomp_event_t event);
118  NRF_STATIC_INLINE bool nrf_lpcomp_event_check(NRF_LPCOMP_Type const * p_reg,
119                                                nrf_lpcomp_event_t      event);
120  #ifndef NRF_DECLARE_ONLY
121  NRF_STATIC_INLINE void nrf_lpcomp_configure(NRF_LPCOMP_Type *           p_reg,
122                                              nrf_lpcomp_config_t const * p_config)
123  {
124      p_reg->TASKS_STOP = 1;
125      p_reg->ENABLE     = LPCOMP_ENABLE_ENABLE_Disabled << LPCOMP_ENABLE_ENABLE_Pos;
126      p_reg->REFSEL     =
127          (p_config->reference << LPCOMP_REFSEL_REFSEL_Pos) & LPCOMP_REFSEL_REFSEL_Msk;
128      if ((p_config->reference & LPCOMP_REFSEL_REFSEL_ARef)==LPCOMP_REFSEL_REFSEL_ARef)
129      {
130          uint32_t extref  = p_config->reference >> 16;
131          p_reg->EXTREFSEL = (extref << LPCOMP_EXTREFSEL_EXTREFSEL_Pos) &
132                             LPCOMP_EXTREFSEL_EXTREFSEL_Msk;
133      }
134      p_reg->ANADETECT = (p_config->detection << LPCOMP_ANADETECT_ANADETECT_Pos) &
135                         LPCOMP_ANADETECT_ANADETECT_Msk;
136  #ifdef LPCOMP_FEATURE_HYST_PRESENT
137      p_reg->HYST      = ((p_config->hyst) << LPCOMP_HYST_HYST_Pos) & LPCOMP_HYST_HYST_Msk;
138  #endif 
139      p_reg->SHORTS    = 0;
140      p_reg->INTENCLR  = LPCOMP_INTENCLR_CROSS_Msk | LPCOMP_INTENCLR_UP_Msk |
141                         LPCOMP_INTENCLR_DOWN_Msk | LPCOMP_INTENCLR_READY_Msk;
142  }
143  NRF_STATIC_INLINE void nrf_lpcomp_input_select(NRF_LPCOMP_Type * p_reg, nrf_lpcomp_input_t input)
144  {
145      uint32_t lpcomp_enable_state = p_reg->ENABLE;
146      p_reg->ENABLE = LPCOMP_ENABLE_ENABLE_Disabled << LPCOMP_ENABLE_ENABLE_Pos;
147      p_reg->PSEL   = ((uint32_t)input << LPCOMP_PSEL_PSEL_Pos) |
148                      (p_reg->PSEL & ~LPCOMP_PSEL_PSEL_Msk);
149      p_reg->ENABLE = lpcomp_enable_state;
150  }
151  NRF_STATIC_INLINE void nrf_lpcomp_enable(NRF_LPCOMP_Type * p_reg)
152  {
153      p_reg->ENABLE = LPCOMP_ENABLE_ENABLE_Enabled << LPCOMP_ENABLE_ENABLE_Pos;
154      p_reg->EVENTS_READY = 0;
155      p_reg->EVENTS_DOWN  = 0;
156      p_reg->EVENTS_UP    = 0;
157      p_reg->EVENTS_CROSS = 0;
158  }
159  NRF_STATIC_INLINE void nrf_lpcomp_disable(NRF_LPCOMP_Type * p_reg)
160  {
161      p_reg->ENABLE = LPCOMP_ENABLE_ENABLE_Disabled << LPCOMP_ENABLE_ENABLE_Pos;
162  }
163  NRF_STATIC_INLINE uint32_t nrf_lpcomp_result_get(NRF_LPCOMP_Type const * p_reg)
164  {
165      return (uint32_t)p_reg->RESULT;
166  }
167  NRF_STATIC_INLINE void nrf_lpcomp_int_enable(NRF_LPCOMP_Type * p_reg, uint32_t mask)
168  {
169      p_reg->INTENSET = mask;
170  }
171  NRF_STATIC_INLINE void nrf_lpcomp_int_disable(NRF_LPCOMP_Type * p_reg, uint32_t mask)
172  {
<span onclick='openModal()' class='match'>173      p_reg->INTENCLR = mask;
174  }
175  NRF_STATIC_INLINE uint32_t nrf_lpcomp_int_enable_check(NRF_LPCOMP_Type const * p_reg,
176                                                         uint32_t                mask)
177  {
178      return p_reg->INTENSET & mask; 
179  }
180  NRF_STATIC_INLINE uint32_t nrf_lpcomp_task_address_get(NRF_LPCOMP_Type const * p_reg,
181                                                         nrf_lpcomp_task_t       task)
182  {
183      return (uint32_t)((uint8_t *)p_reg + task);
</span>184  }
185  NRF_STATIC_INLINE uint32_t nrf_lpcomp_event_address_get(NRF_LPCOMP_Type const * p_reg,
186                                                          nrf_lpcomp_event_t      event)
187  {
188      return (uint32_t)((uint8_t *)p_reg + event);
189  }
190  NRF_STATIC_INLINE void nrf_lpcomp_shorts_enable(NRF_LPCOMP_Type * p_reg, uint32_t short_mask)
191  {
192      p_reg->SHORTS |= short_mask;
193  }
194  NRF_STATIC_INLINE void nrf_lpcomp_shorts_disable(NRF_LPCOMP_Type * p_reg, uint32_t short_mask)
195  {
196      p_reg->SHORTS &= ~short_mask;
197  }
198  NRF_STATIC_INLINE void nrf_lpcomp_task_trigger(NRF_LPCOMP_Type * p_reg, nrf_lpcomp_task_t task)
199  {
200      *( (volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)task) ) = 1;
201  }
202  NRF_STATIC_INLINE void nrf_lpcomp_event_clear(NRF_LPCOMP_Type * p_reg, nrf_lpcomp_event_t event)
203  {
204      *( (volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)event) ) = 0;
205  #if __CORTEX_M == 0x04
206      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
207      (void)dummy;
208  #endif
209  }
210  NRF_STATIC_INLINE bool nrf_lpcomp_event_check(NRF_LPCOMP_Type const * p_reg,
211                                                nrf_lpcomp_event_t      event)
212  {
213      return (bool) (*(volatile uint32_t *)( (uint8_t *)p_reg + (uint32_t)event));
214  }
215  #endif 
216  #ifdef __cplusplus
217  }
218  #endif
219  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_pdm.h</h3>
            <pre><code>1  #ifndef NRF_PDM_H_
2  #define NRF_PDM_H_
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #ifndef NRF_PDM0
8  #define NRF_PDM0 NRF_PDM
9  #endif
10  #if defined(PDM_MCLKCONFIG_SRC_Msk) || defined(__NRFX_DOXYGEN__)
11  #define NRF_PDM_HAS_MCLKCONFIG 1
12  #else
13  #define NRF_PDM_HAS_MCLKCONFIG 0
14  #endif
15  #if defined(PDM_RATIO_RATIO_Msk) || defined(__NRFX_DOXYGEN__)
16  #define NRF_PDM_HAS_RATIO_CONFIG 1
17  #else
18  #define NRF_PDM_HAS_RATIO_CONFIG 0
19  #endif
20  #define NRF_PDM_GAIN_MINIMUM  0x00
21  #define NRF_PDM_GAIN_DEFAULT  0x28
22  #define NRF_PDM_GAIN_MAXIMUM  0x50
23  typedef uint8_t nrf_pdm_gain_t;
24  typedef enum
25  {
26      NRF_PDM_TASK_START = offsetof(NRF_PDM_Type, TASKS_START), 
27      NRF_PDM_TASK_STOP  = offsetof(NRF_PDM_Type, TASKS_STOP)   
28  } nrf_pdm_task_t;
29  typedef enum
30  {
31      NRF_PDM_EVENT_STARTED = offsetof(NRF_PDM_Type, EVENTS_STARTED), 
32      NRF_PDM_EVENT_STOPPED = offsetof(NRF_PDM_Type, EVENTS_STOPPED), 
33      NRF_PDM_EVENT_END     = offsetof(NRF_PDM_Type, EVENTS_END)      
34  } nrf_pdm_event_t;
35  typedef enum
36  {
37      NRF_PDM_INT_STARTED = PDM_INTENSET_STARTED_Msk, 
38      NRF_PDM_INT_STOPPED = PDM_INTENSET_STOPPED_Msk, 
39      NRF_PDM_INT_END     = PDM_INTENSET_END_Msk      
40  } nrf_pdm_int_mask_t;
41  typedef enum
42  {
43      NRF_PDM_FREQ_1000K = PDM_PDMCLKCTRL_FREQ_1000K,   
44      NRF_PDM_FREQ_1032K = PDM_PDMCLKCTRL_FREQ_Default, 
45      NRF_PDM_FREQ_1067K = PDM_PDMCLKCTRL_FREQ_1067K,   
46  #if defined(PDM_PDMCLKCTRL_FREQ_1231K) || defined(__NRFX_DOXYGEN__)
47      NRF_PDM_FREQ_1231K = PDM_PDMCLKCTRL_FREQ_1231K,   
48  #endif
49  #if defined(PDM_PDMCLKCTRL_FREQ_1280K) || defined(__NRFX_DOXYGEN__)
50      NRF_PDM_FREQ_1280K = PDM_PDMCLKCTRL_FREQ_1280K,   
51  #endif
52  #if defined(PDM_PDMCLKCTRL_FREQ_1333K) || defined(__NRFX_DOXYGEN__)
53      NRF_PDM_FREQ_1333K = PDM_PDMCLKCTRL_FREQ_1333K    
54  #endif
55  } nrf_pdm_freq_t;
56  #if NRF_PDM_HAS_RATIO_CONFIG
57  typedef enum
58  {
59      NRF_PDM_RATIO_64X = PDM_RATIO_RATIO_Ratio64, 
60      NRF_PDM_RATIO_80X = PDM_RATIO_RATIO_Ratio80  
61  } nrf_pdm_ratio_t;
62  #endif
63  typedef enum
64  {
65      NRF_PDM_MODE_STEREO = PDM_MODE_OPERATION_Stereo,  
66      NRF_PDM_MODE_MONO   = PDM_MODE_OPERATION_Mono     
67  } nrf_pdm_mode_t;
68  typedef enum
69  {
70      NRF_PDM_EDGE_LEFTFALLING = PDM_MODE_EDGE_LeftFalling,  
71      NRF_PDM_EDGE_LEFTRISING  = PDM_MODE_EDGE_LeftRising    
72  } nrf_pdm_edge_t;
73  #if NRF_PDM_HAS_MCLKCONFIG
74  typedef enum
75  {
76      NRF_PDM_MCLKSRC_PCLK32M = PDM_MCLKCONFIG_SRC_PCLK32M, 
77      NRF_PDM_MCLKSRC_ACLK    = PDM_MCLKCONFIG_SRC_ACLK     
78  } nrf_pdm_mclksrc_t;
79  #endif
80  NRF_STATIC_INLINE void nrf_pdm_task_trigger(NRF_PDM_Type * p_reg, nrf_pdm_task_t task);
81  NRF_STATIC_INLINE uint32_t nrf_pdm_task_address_get(NRF_PDM_Type const * p_reg,
82                                                      nrf_pdm_task_t       task);
83  NRF_STATIC_INLINE bool nrf_pdm_event_check(NRF_PDM_Type const * p_reg, nrf_pdm_event_t event);
84  NRF_STATIC_INLINE void nrf_pdm_event_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event);
85  NRF_STATIC_INLINE uint32_t nrf_pdm_event_address_get(NRF_PDM_Type const * p_reg,
86                                                       nrf_pdm_event_t      event);
87  NRF_STATIC_INLINE void nrf_pdm_int_enable(NRF_PDM_Type * p_reg, uint32_t mask);
88  NRF_STATIC_INLINE uint32_t nrf_pdm_int_enable_check(NRF_PDM_Type const * p_reg, uint32_t mask);
89  NRF_STATIC_INLINE void nrf_pdm_int_disable(NRF_PDM_Type * p_reg, uint32_t mask);
90  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
91  NRF_STATIC_INLINE void nrf_pdm_subscribe_set(NRF_PDM_Type * p_reg,
92                                               nrf_pdm_task_t task,
93                                               uint8_t        channel);
94  NRF_STATIC_INLINE void nrf_pdm_subscribe_clear(NRF_PDM_Type * p_reg, nrf_pdm_task_t task);
95  NRF_STATIC_INLINE void nrf_pdm_publish_set(NRF_PDM_Type *  p_reg,
96                                             nrf_pdm_event_t event,
97                                             uint8_t         channel);
98  NRF_STATIC_INLINE void nrf_pdm_publish_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event);
99  #endif 
100  NRF_STATIC_INLINE void nrf_pdm_enable(NRF_PDM_Type * p_reg);
101  NRF_STATIC_INLINE void nrf_pdm_disable(NRF_PDM_Type * p_reg);
102  NRF_STATIC_INLINE bool nrf_pdm_enable_check(NRF_PDM_Type const * p_reg);
103  NRF_STATIC_INLINE void nrf_pdm_mode_set(NRF_PDM_Type * p_reg,
104                                          nrf_pdm_mode_t pdm_mode,
105                                          nrf_pdm_edge_t pdm_edge);
106  NRF_STATIC_INLINE void nrf_pdm_mode_get(NRF_PDM_Type const * p_reg,
107                                          nrf_pdm_mode_t *     p_pdm_mode,
108                                          nrf_pdm_edge_t *     p_pdm_edge);
109  NRF_STATIC_INLINE void nrf_pdm_clock_set(NRF_PDM_Type * p_reg, nrf_pdm_freq_t pdm_freq);
110  NRF_STATIC_INLINE nrf_pdm_freq_t nrf_pdm_clock_get(NRF_PDM_Type const * p_reg);
111  NRF_STATIC_INLINE void nrf_pdm_psel_connect(NRF_PDM_Type * p_reg,
112                                              uint32_t       psel_clk,
113                                              uint32_t       psel_din);
114  NRF_STATIC_INLINE void nrf_pdm_psel_disconnect(NRF_PDM_Type * p_reg);
115  NRF_STATIC_INLINE void nrf_pdm_gain_set(NRF_PDM_Type * p_reg,
116                                          nrf_pdm_gain_t gain_l,
117                                          nrf_pdm_gain_t gain_r);
118  NRF_STATIC_INLINE void nrf_pdm_gain_get(NRF_PDM_Type const * p_reg,
119                                          nrf_pdm_gain_t *     p_gain_l,
120                                          nrf_pdm_gain_t *     p_gain_r);
121  NRF_STATIC_INLINE void nrf_pdm_buffer_set(NRF_PDM_Type * p_reg, uint32_t * p_buffer, uint32_t num);
122  NRF_STATIC_INLINE uint32_t * nrf_pdm_buffer_get(NRF_PDM_Type const * p_reg);
123  #if NRF_PDM_HAS_RATIO_CONFIG
124  NRF_STATIC_INLINE void nrf_pdm_ratio_set(NRF_PDM_Type * p_reg, nrf_pdm_ratio_t ratio);
125  #endif
126  #if NRF_PDM_HAS_MCLKCONFIG
127  NRF_STATIC_INLINE void nrf_pdm_mclksrc_configure(NRF_PDM_Type * p_reg, nrf_pdm_mclksrc_t mclksrc);
128  #endif
129  #ifndef NRF_DECLARE_ONLY
130  NRF_STATIC_INLINE void nrf_pdm_task_trigger(NRF_PDM_Type * p_reg, nrf_pdm_task_t task)
131  {
<span onclick='openModal()' class='match'>132      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
133  }
134  NRF_STATIC_INLINE uint32_t nrf_pdm_task_address_get(NRF_PDM_Type const * p_reg, nrf_pdm_task_t task)
135  {
136      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
137  }
138  NRF_STATIC_INLINE bool nrf_pdm_event_check(NRF_PDM_Type const * p_reg, nrf_pdm_event_t event)
139  {
140      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
</span>141  }
142  NRF_STATIC_INLINE void nrf_pdm_event_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event)
143  {
144      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
145  #if __CORTEX_M == 0x04
146      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
147      (void)dummy;
148  #endif
149  }
150  NRF_STATIC_INLINE uint32_t nrf_pdm_event_address_get(NRF_PDM_Type const * p_reg,
151                                                       nrf_pdm_event_t      event)
152  {
153      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
154  }
155  NRF_STATIC_INLINE void nrf_pdm_int_enable(NRF_PDM_Type * p_reg, uint32_t mask)
156  {
157      p_reg->INTENSET = mask;
158  }
159  NRF_STATIC_INLINE uint32_t nrf_pdm_int_enable_check(NRF_PDM_Type const * p_reg, uint32_t mask)
160  {
161      return p_reg->INTENSET & mask;
162  }
163  NRF_STATIC_INLINE void nrf_pdm_int_disable(NRF_PDM_Type * p_reg, uint32_t mask)
164  {
165      p_reg->INTENCLR = mask;
166  }
167  #if defined(DPPI_PRESENT)
168  NRF_STATIC_INLINE void nrf_pdm_subscribe_set(NRF_PDM_Type * p_reg,
169                                               nrf_pdm_task_t task,
170                                               uint8_t        channel)
171  {
172      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
173              ((uint32_t)channel | PDM_SUBSCRIBE_START_EN_Msk);
174  }
175  NRF_STATIC_INLINE void nrf_pdm_subscribe_clear(NRF_PDM_Type * p_reg, nrf_pdm_task_t task)
176  {
177      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
178  }
179  NRF_STATIC_INLINE void nrf_pdm_publish_set(NRF_PDM_Type *  p_reg,
180                                             nrf_pdm_event_t event,
181                                             uint8_t         channel)
182  {
183      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
184              ((uint32_t)channel | PDM_PUBLISH_STARTED_EN_Msk);
185  }
186  NRF_STATIC_INLINE void nrf_pdm_publish_clear(NRF_PDM_Type * p_reg, nrf_pdm_event_t event)
187  {
188      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
189  }
190  #endif 
191  NRF_STATIC_INLINE void nrf_pdm_enable(NRF_PDM_Type * p_reg)
192  {
193      p_reg->ENABLE = (PDM_ENABLE_ENABLE_Enabled << PDM_ENABLE_ENABLE_Pos);
194  }
195  NRF_STATIC_INLINE void nrf_pdm_disable(NRF_PDM_Type * p_reg)
196  {
197      p_reg->ENABLE = (PDM_ENABLE_ENABLE_Disabled << PDM_ENABLE_ENABLE_Pos);
198  }
199  NRF_STATIC_INLINE bool nrf_pdm_enable_check(NRF_PDM_Type const * p_reg)
200  {
201      return (p_reg->ENABLE == (PDM_ENABLE_ENABLE_Enabled << PDM_ENABLE_ENABLE_Pos));
202  }
203  NRF_STATIC_INLINE void nrf_pdm_mode_set(NRF_PDM_Type * p_reg,
204                                          nrf_pdm_mode_t pdm_mode,
205                                          nrf_pdm_edge_t pdm_edge)
206  {
207      p_reg->MODE = ((pdm_mode << PDM_MODE_OPERATION_Pos) & PDM_MODE_OPERATION_Msk)
208                      | ((pdm_edge << PDM_MODE_EDGE_Pos) & PDM_MODE_EDGE_Msk);
209  }
210  NRF_STATIC_INLINE void nrf_pdm_mode_get(NRF_PDM_Type const * p_reg,
211                                          nrf_pdm_mode_t * p_pdm_mode,
212                                          nrf_pdm_edge_t * p_pdm_edge)
213  {
214      uint32_t mode = p_reg->MODE;
215      *p_pdm_mode = (nrf_pdm_mode_t)((mode & PDM_MODE_OPERATION_Msk ) >> PDM_MODE_OPERATION_Pos);
216      *p_pdm_edge = (nrf_pdm_edge_t)((mode & PDM_MODE_EDGE_Msk ) >> PDM_MODE_EDGE_Pos);
217  }
218  NRF_STATIC_INLINE void nrf_pdm_clock_set(NRF_PDM_Type * p_reg, nrf_pdm_freq_t pdm_freq)
219  {
220      p_reg->PDMCLKCTRL = ((pdm_freq << PDM_PDMCLKCTRL_FREQ_Pos) & PDM_PDMCLKCTRL_FREQ_Msk);
221  }
222  NRF_STATIC_INLINE nrf_pdm_freq_t nrf_pdm_clock_get(NRF_PDM_Type const * p_reg)
223  {
224       return (nrf_pdm_freq_t) ((p_reg->PDMCLKCTRL << PDM_PDMCLKCTRL_FREQ_Pos) &
225                                PDM_PDMCLKCTRL_FREQ_Msk);
226  }
227  NRF_STATIC_INLINE void nrf_pdm_psel_connect(NRF_PDM_Type * p_reg,
228                                              uint32_t       psel_clk,
229                                              uint32_t       psel_din)
230  {
231      p_reg->PSEL.CLK = psel_clk;
232      p_reg->PSEL.DIN = psel_din;
233  }
234  NRF_STATIC_INLINE void nrf_pdm_psel_disconnect(NRF_PDM_Type * p_reg)
235  {
236      p_reg->PSEL.CLK = ((PDM_PSEL_CLK_CONNECT_Disconnected << PDM_PSEL_CLK_CONNECT_Pos)
237                           & PDM_PSEL_CLK_CONNECT_Msk);
238      p_reg->PSEL.DIN = ((PDM_PSEL_DIN_CONNECT_Disconnected << PDM_PSEL_DIN_CONNECT_Pos)
239                           & PDM_PSEL_DIN_CONNECT_Msk);
240  }
241  NRF_STATIC_INLINE void nrf_pdm_gain_set(NRF_PDM_Type * p_reg,
242                                          nrf_pdm_gain_t gain_l,
243                                          nrf_pdm_gain_t gain_r)
244  {
245      p_reg->GAINL = gain_l;
246      p_reg->GAINR = gain_r;
247  }
248  NRF_STATIC_INLINE void nrf_pdm_gain_get(NRF_PDM_Type const * p_reg,
249                                          nrf_pdm_gain_t *     p_gain_l,
250                                          nrf_pdm_gain_t *     p_gain_r)
251  {
252      *p_gain_l = p_reg->GAINL;
253      *p_gain_r = p_reg->GAINR;
254  }
255  NRF_STATIC_INLINE void nrf_pdm_buffer_set(NRF_PDM_Type * p_reg, uint32_t * p_buffer, uint32_t num)
256  {
257      p_reg->SAMPLE.PTR = (uint32_t)p_buffer;
258      p_reg->SAMPLE.MAXCNT = num;
259  }
260  NRF_STATIC_INLINE uint32_t * nrf_pdm_buffer_get(NRF_PDM_Type const * p_reg)
261  {
262      return (uint32_t *)p_reg->SAMPLE.PTR;
263  }
264  #if NRF_PDM_HAS_RATIO_CONFIG
265  NRF_STATIC_INLINE void nrf_pdm_ratio_set(NRF_PDM_Type * p_reg, nrf_pdm_ratio_t ratio)
266  {
267      p_reg->RATIO = ratio;
268  }
269  #endif
270  #if NRF_PDM_HAS_MCLKCONFIG
271  NRF_STATIC_INLINE void nrf_pdm_mclksrc_configure(NRF_PDM_Type * p_reg, nrf_pdm_mclksrc_t mclksrc)
272  {
273      p_reg->MCLKCONFIG = mclksrc;
274  }
275  #endif
276  #endif 
277  #ifdef __cplusplus
278  }
279  #endif
280  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_lpcomp.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_pdm.h</div>
                <div class="column column_space"><pre><code>173      p_reg->INTENCLR = mask;
174  }
175  NRF_STATIC_INLINE uint32_t nrf_lpcomp_int_enable_check(NRF_LPCOMP_Type const * p_reg,
176                                                         uint32_t                mask)
177  {
178      return p_reg->INTENSET & mask; 
179  }
180  NRF_STATIC_INLINE uint32_t nrf_lpcomp_task_address_get(NRF_LPCOMP_Type const * p_reg,
181                                                         nrf_lpcomp_task_t       task)
182  {
183      return (uint32_t)((uint8_t *)p_reg + task);
</pre></code></div>
                <div class="column column_space"><pre><code>132      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
133  }
134  NRF_STATIC_INLINE uint32_t nrf_pdm_task_address_get(NRF_PDM_Type const * p_reg, nrf_pdm_task_t task)
135  {
136      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
137  }
138  NRF_STATIC_INLINE bool nrf_pdm_event_check(NRF_PDM_Type const * p_reg, nrf_pdm_event_t event)
139  {
140      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    