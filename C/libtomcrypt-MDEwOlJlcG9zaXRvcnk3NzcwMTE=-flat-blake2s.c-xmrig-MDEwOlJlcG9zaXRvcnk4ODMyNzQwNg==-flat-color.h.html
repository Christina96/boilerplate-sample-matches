
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.491228070175438%, Tokens: 8</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2s.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BLAKE2S
3  enum blake2s_constant {
4     BLAKE2S_BLOCKBYTES = 64,
5     BLAKE2S_OUTBYTES = 32,
6     BLAKE2S_KEYBYTES = 32,
7     BLAKE2S_SALTBYTES = 8,
8     BLAKE2S_PERSONALBYTES = 8,
9     BLAKE2S_PARAM_SIZE = 32
10  };
11  enum {
12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 14,
20     O_INNER_LENGTH = 15,
21     O_SALT = 16,
22     O_PERSONAL = 24
23  };
24  const struct ltc_hash_descriptor blake2s_128_desc =
25  {
26      "blake2s-128",
27      21,
28      16,
29      64,
30      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 4 },
31      11,
32      &blake2s_128_init,
33      &blake2s_process,
34      &blake2s_done,
35      &blake2s_128_test,
36      NULL
37  };
38  const struct ltc_hash_descriptor blake2s_160_desc =
39  {
40      "blake2s-160",
41      22,
42      20,
43      64,
44      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 5 },
45      11,
46      &blake2s_160_init,
47      &blake2s_process,
48      &blake2s_done,
49      &blake2s_160_test,
50      NULL
51  };
52  const struct ltc_hash_descriptor blake2s_224_desc =
53  {
54      "blake2s-224",
55      23,
56      28,
57      64,
58      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 7 },
59      11,
60      &blake2s_224_init,
61      &blake2s_process,
62      &blake2s_done,
63      &blake2s_224_test,
64      NULL
65  };
66  const struct ltc_hash_descriptor blake2s_256_desc =
67  {
68      "blake2s-256",
69      24,
70      32,
71      64,
72      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 8 },
73      11,
74      &blake2s_256_init,
75      &blake2s_process,
76      &blake2s_done,
77      &blake2s_256_test,
78      NULL
79  };
80  static const ulong32 blake2s_IV[8] = {
81      0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,
82      0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL
83  };
84  static const unsigned char blake2s_sigma[10][16] = {
85      { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
86      { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
87      { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
88      { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
89      { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
90      { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },
91      { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },
92      { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },
93      { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },
94      { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },
95  };
96  static void s_blake2s_set_lastnode(hash_state *md) { md->blake2s.f[1] = 0xffffffffUL; }
97  static int s_blake2s_is_lastblock(const hash_state *md) { return md->blake2s.f[0] != 0; }
98  static void s_blake2s_set_lastblock(hash_state *md)
99  {
100     if (md->blake2s.last_node) {
101        s_blake2s_set_lastnode(md);
102     }
103     md->blake2s.f[0] = 0xffffffffUL;
104  }
105  static void s_blake2s_increment_counter(hash_state *md, const ulong32 inc)
106  {
107     md->blake2s.t[0] += inc;
108     if (md->blake2s.t[0] < inc) md->blake2s.t[1]++;
109  }
110  static int s_blake2s_init0(hash_state *md)
111  {
112     int i;
113     XMEMSET(&md->blake2s, 0, sizeof(struct blake2s_state));
114     for (i = 0; i < 8; ++i) {
115        md->blake2s.h[i] = blake2s_IV[i];
116     }
117     return CRYPT_OK;
118  }
119  static int s_blake2s_init_param(hash_state *md, const unsigned char *P)
120  {
121     unsigned long i;
122     s_blake2s_init0(md);
123     for (i = 0; i < 8; ++i) {
124        ulong32 tmp;
125        LOAD32L(tmp, P + i * 4);
126        md->blake2s.h[i] ^= tmp;
127     }
128     md->blake2s.outlen = P[O_DIGEST_LENGTH];
129     return CRYPT_OK;
130  }
131  int blake2s_init(hash_state *md, unsigned long outlen, const unsigned char *key, unsigned long keylen)
132  {
133     unsigned char P[BLAKE2S_PARAM_SIZE];
134     int err;
135     LTC_ARGCHK(md != NULL);
136     if ((!outlen) || (outlen > BLAKE2S_OUTBYTES)) {
137        return CRYPT_INVALID_ARG;
138     }
139     if ((key && !keylen) || (keylen && !key) || (keylen > BLAKE2S_KEYBYTES)) {
140        return CRYPT_INVALID_ARG;
141     }
142     XMEMSET(P, 0, sizeof(P));
143     P[O_DIGEST_LENGTH] = (unsigned char)outlen;
144     P[O_KEY_LENGTH] = (unsigned char)keylen;
145     P[O_FANOUT] = 1;
146     P[O_DEPTH] = 1;
147     err = s_blake2s_init_param(md, P);
148     if (err != CRYPT_OK) return err;
149     if (key) {
150        unsigned char block[BLAKE2S_BLOCKBYTES];
151        XMEMSET(block, 0, BLAKE2S_BLOCKBYTES);
152        XMEMCPY(block, key, keylen);
153        blake2s_process(md, block, BLAKE2S_BLOCKBYTES);
154  #ifdef LTC_CLEAN_STACK
155        zeromem(block, sizeof(block));
156  #endif
157     }
158     return CRYPT_OK;
159  }
160  int blake2s_128_init(hash_state *md) { return blake2s_init(md, 16, NULL, 0); }
161  int blake2s_160_init(hash_state *md) { return blake2s_init(md, 20, NULL, 0); }
162  int blake2s_224_init(hash_state *md) { return blake2s_init(md, 28, NULL, 0); }
163  int blake2s_256_init(hash_state *md) { return blake2s_init(md, 32, NULL, 0); }
164  #define G(r, i, a, b, c, d)                                                                                            \
165     do {                                                                                                                \
166        a = a + b + m[blake2s_sigma[r][2 * i + 0]];                                                                      \
167        d = ROR(d ^ a, 16);                                                                                              \
168        c = c + d;                                                                                                       \
169        b = ROR(b ^ c, 12);                                                                                              \
170        a = a + b + m[blake2s_sigma[r][2 * i + 1]];                                                                      \
171        d = ROR(d ^ a, 8);                                                                                               \
172        c = c + d;                                                                                                       \
173        b = ROR(b ^ c, 7);                                                                                               \
174     } while (0)
175  #define ROUND(r)                                                                                                       \
176     do {                                                                                                                \
177        G(r, 0, v[0], v[4], v[8], v[12]);                                                                                \
178        G(r, 1, v[1], v[5], v[9], v[13]);                                                                                \
179        G(r, 2, v[2], v[6], v[10], v[14]);                                                                               \
180        G(r, 3, v[3], v[7], v[11], v[15]);                                                                               \
181        G(r, 4, v[0], v[5], v[10], v[15]);                                                                               \
182        G(r, 5, v[1], v[6], v[11], v[12]);                                                                               \
183        G(r, 6, v[2], v[7], v[8], v[13]);                                                                                \
184        G(r, 7, v[3], v[4], v[9], v[14]);                                                                                \
185     } while (0)
186  #ifdef LTC_CLEAN_STACK
187  static int ss_blake2s_compress(hash_state *md, const unsigned char *buf)
188  #else
189  static int s_blake2s_compress(hash_state *md, const unsigned char *buf)
190  #endif
191  {
192     unsigned long i;
193     ulong32 m[16];
194     ulong32 v[16];
195     for (i = 0; i < 16; ++i) {
196        LOAD32L(m[i], buf + i * sizeof(m[i]));
197     }
198     for (i = 0; i < 8; ++i) {
199        v[i] = md->blake2s.h[i];
200     }
<span onclick='openModal()' class='match'>201     v[8] = blake2s_IV[0];
202     v[9] = blake2s_IV[1];
203     v[10] = blake2s_IV[2];
204     v[11] = blake2s_IV[3];
205     v[12] = md->blake2s.t[0] ^ blake2s_IV[4];
206     v[13] = md->blake2s.t[1] ^ blake2s_IV[5];
207     v[14] = md->blake2s.f[0] ^ blake2s_IV[6];
208     v[15] = md->blake2s.f[1] ^ blake2s_IV[7];
</span>209     ROUND(0);
210     ROUND(1);
211     ROUND(2);
212     ROUND(3);
213     ROUND(4);
214     ROUND(5);
215     ROUND(6);
216     ROUND(7);
217     ROUND(8);
218     ROUND(9);
219     for (i = 0; i < 8; ++i) {
220        md->blake2s.h[i] = md->blake2s.h[i] ^ v[i] ^ v[i + 8];
221     }
222     return CRYPT_OK;
223  }
224  #undef G
225  #undef ROUND
226  #ifdef LTC_CLEAN_STACK
227  static int s_blake2s_compress(hash_state *md, const unsigned char *buf)
228  {
229     int err;
230     err = ss_blake2s_compress(md, buf);
231     burn_stack(sizeof(ulong32) * (32) + sizeof(unsigned long));
232     return err;
233  }
234  #endif
235  int blake2s_process(hash_state *md, const unsigned char *in, unsigned long inlen)
236  {
237     LTC_ARGCHK(md != NULL);
238     LTC_ARGCHK(in != NULL);
239     if (md->blake2s.curlen > sizeof(md->blake2s.buf)) {
240        return CRYPT_INVALID_ARG;
241     }
242     if (inlen > 0) {
243        unsigned long left = md->blake2s.curlen;
244        unsigned long fill = BLAKE2S_BLOCKBYTES - left;
245        if (inlen > fill) {
246           md->blake2s.curlen = 0;
247           XMEMCPY(md->blake2s.buf + (left % sizeof(md->blake2s.buf)), in, fill); &bsol;* Fill buffer */
248           s_blake2s_increment_counter(md, BLAKE2S_BLOCKBYTES);
249           s_blake2s_compress(md, md->blake2s.buf); &bsol;* Compress */
250           in += fill;
251           inlen -= fill;
252           while (inlen > BLAKE2S_BLOCKBYTES) {
253              s_blake2s_increment_counter(md, BLAKE2S_BLOCKBYTES);
254              s_blake2s_compress(md, in);
255              in += BLAKE2S_BLOCKBYTES;
256              inlen -= BLAKE2S_BLOCKBYTES;
257           }
258        }
259        XMEMCPY(md->blake2s.buf + md->blake2s.curlen, in, inlen);
260        md->blake2s.curlen += inlen;
261     }
262     return CRYPT_OK;
263  }
264  int blake2s_done(hash_state *md, unsigned char *out)
265  {
266     unsigned char buffer[BLAKE2S_OUTBYTES] = { 0 };
267     unsigned long i;
268     LTC_ARGCHK(md != NULL);
269     LTC_ARGCHK(out != NULL);
270     if (s_blake2s_is_lastblock(md)) {
271        return CRYPT_ERROR;
272     }
273     s_blake2s_increment_counter(md, md->blake2s.curlen);
274     s_blake2s_set_lastblock(md);
275     XMEMSET(md->blake2s.buf + md->blake2s.curlen, 0, BLAKE2S_BLOCKBYTES - md->blake2s.curlen); &bsol;* Padding */
276     s_blake2s_compress(md, md->blake2s.buf);
277     for (i = 0; i < 8; ++i) { &bsol;* Output full hash to temp buffer */
278        STORE32L(md->blake2s.h[i], buffer + i * 4);
279     }
280     XMEMCPY(out, buffer, md->blake2s.outlen);
281     zeromem(md, sizeof(hash_state));
282  #ifdef LTC_CLEAN_STACK
283     zeromem(buffer, sizeof(buffer));
284  #endif
285     return CRYPT_OK;
286  }
287  int blake2s_256_test(void)
288  {
289  #ifndef LTC_TEST
290     return CRYPT_NOP;
291  #else
292     static const struct {
293        const char *msg;
294        unsigned char hash[32];
295    } tests[] = {
296      { "",
297        { 0x69, 0x21, 0x7a, 0x30, 0x79, 0x90, 0x80, 0x94,
298          0xe1, 0x11, 0x21, 0xd0, 0x42, 0x35, 0x4a, 0x7c,
299          0x1f, 0x55, 0xb6, 0x48, 0x2c, 0xa1, 0xa5, 0x1e,
300          0x1b, 0x25, 0x0d, 0xfd, 0x1e, 0xd0, 0xee, 0xf9 } },
301      { "abc",
302        { 0x50, 0x8c, 0x5e, 0x8c, 0x32, 0x7c, 0x14, 0xe2,
303          0xe1, 0xa7, 0x2b, 0xa3, 0x4e, 0xeb, 0x45, 0x2f,
304          0x37, 0x45, 0x8b, 0x20, 0x9e, 0xd6, 0x3a, 0x29,
305          0x4d, 0x99, 0x9b, 0x4c, 0x86, 0x67, 0x59, 0x82 } },
306      { "12345678901234567890123456789012345678901234567890"
307        "12345678901234567890123456789012345678901234567890"
308        "12345678901234567890123456789012345678901234567890"
309        "12345678901234567890123456789012345678901234567890"
310        "12345678901234567890123456789012345678901234567890"
311        "12345678901234567890123456789012345678901234567890",
312        { 0xa3, 0x78, 0x8b, 0x5b, 0x59, 0xee, 0xe4, 0x41,
313          0x95, 0x23, 0x58, 0x00, 0xa4, 0xf9, 0xfa, 0x41,
314          0x86, 0x0c, 0x7b, 0x1c, 0x35, 0xa2, 0x42, 0x70,
315          0x50, 0x80, 0x79, 0x56, 0xe3, 0xbe, 0x31, 0x74 } },
316      { NULL, { 0 } }
317    };
318     int i;
319     unsigned char tmp[32];
320     hash_state md;
321     for (i = 0; tests[i].msg != NULL; i++) {
322        blake2s_256_init(&md);
323        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
324        blake2s_done(&md, tmp);
325        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_256", i)) {
326           return CRYPT_FAIL_TESTVECTOR;
327        }
328     }
329     return CRYPT_OK;
330  #endif
331  }
332  int blake2s_224_test(void)
333  {
334  #ifndef LTC_TEST
335     return CRYPT_NOP;
336  #else
337     static const struct {
338        const char *msg;
339        unsigned char hash[28];
340    } tests[] = {
341      { "",
342        { 0x1f, 0xa1, 0x29, 0x1e, 0x65, 0x24, 0x8b, 0x37,
343          0xb3, 0x43, 0x34, 0x75, 0xb2, 0xa0, 0xdd, 0x63,
344          0xd5, 0x4a, 0x11, 0xec, 0xc4, 0xe3, 0xe0, 0x34,
345          0xe7, 0xbc, 0x1e, 0xf4 } },
346      { "abc",
347        { 0x0b, 0x03, 0x3f, 0xc2, 0x26, 0xdf, 0x7a, 0xbd,
348          0xe2, 0x9f, 0x67, 0xa0, 0x5d, 0x3d, 0xc6, 0x2c,
349          0xf2, 0x71, 0xef, 0x3d, 0xfe, 0xa4, 0xd3, 0x87,
350          0x40, 0x7f, 0xbd, 0x55 } },
351      { NULL, { 0 } }
352    };
353     int i;
354     unsigned char tmp[28];
355     hash_state md;
356     for (i = 0; tests[i].msg != NULL; i++) {
357        blake2s_224_init(&md);
358        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
359        blake2s_done(&md, tmp);
360        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_224", i)) {
361           return CRYPT_FAIL_TESTVECTOR;
362        }
363     }
364     return CRYPT_OK;
365  #endif
366  }
367  int blake2s_160_test(void)
368  {
369  #ifndef LTC_TEST
370     return CRYPT_NOP;
371  #else
372     static const struct {
373        const char *msg;
374        unsigned char hash[20];
375    } tests[] = {
376      { "",
377        { 0x35, 0x4c, 0x9c, 0x33, 0xf7, 0x35, 0x96, 0x24,
378          0x18, 0xbd, 0xac, 0xb9, 0x47, 0x98, 0x73, 0x42,
379          0x9c, 0x34, 0x91, 0x6f} },
380      { "abc",
381        { 0x5a, 0xe3, 0xb9, 0x9b, 0xe2, 0x9b, 0x01, 0x83,
382          0x4c, 0x3b, 0x50, 0x85, 0x21, 0xed, 0xe6, 0x04,
383          0x38, 0xf8, 0xde, 0x17 } },
384      { NULL, { 0 } }
385    };
386     int i;
387     unsigned char tmp[20];
388     hash_state md;
389     for (i = 0; tests[i].msg != NULL; i++) {
390        blake2s_160_init(&md);
391        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
392        blake2s_done(&md, tmp);
393        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_160", i)) {
394           return CRYPT_FAIL_TESTVECTOR;
395        }
396     }
397     return CRYPT_OK;
398  #endif
399  }
400  int blake2s_128_test(void)
401  {
402  #ifndef LTC_TEST
403     return CRYPT_NOP;
404  #else
405     static const struct {
406        const char *msg;
407        unsigned char hash[16];
408    } tests[] = {
409      { "",
410        { 0x64, 0x55, 0x0d, 0x6f, 0xfe, 0x2c, 0x0a, 0x01,
411          0xa1, 0x4a, 0xba, 0x1e, 0xad, 0xe0, 0x20, 0x0c } },
412      { "abc",
413        { 0xaa, 0x49, 0x38, 0x11, 0x9b, 0x1d, 0xc7, 0xb8,
414          0x7c, 0xba, 0xd0, 0xff, 0xd2, 0x00, 0xd0, 0xae } },
415      { NULL, { 0 } }
416    };
417     int i;
418     unsigned char tmp[16];
419     hash_state md;
420     for (i = 0; tests[i].msg != NULL; i++) {
421        blake2s_128_init(&md);
422        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
423        blake2s_done(&md, tmp);
424        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_128", i)) {
425           return CRYPT_FAIL_TESTVECTOR;
426        }
427     }
428     return CRYPT_OK;
429  #endif
430  }
431  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-color.h</h3>
            <pre><code>1  #ifndef FMT_COLOR_H_
2  #define FMT_COLOR_H_
3  #include "format.h"
4  FMT_BEGIN_NAMESPACE
5  enum class color : uint32_t {
6    alice_blue = 0xF0F8FF,               
7    antique_white = 0xFAEBD7,            
8    aqua = 0x00FFFF,                     
9    aquamarine = 0x7FFFD4,               
10    azure = 0xF0FFFF,                    
11    beige = 0xF5F5DC,                    
12    bisque = 0xFFE4C4,                   
13    black = 0x000000,                    
14    blanched_almond = 0xFFEBCD,          
15    blue = 0x0000FF,                     
16    blue_violet = 0x8A2BE2,              
<span onclick='openModal()' class='match'>17    brown = 0xA52A2A,                    
18    burly_wood = 0xDEB887,               
19    cadet_blue = 0x5F9EA0,               
20    chartreuse = 0x7FFF00,               
21    chocolate = 0xD2691E,                
22    coral = 0xFF7F50,                    
23    cornflower_blue = 0x6495ED,          
24    cornsilk = 0xFFF8DC,                 
</span>25    crimson = 0xDC143C,                  
26    cyan = 0x00FFFF,                     
27    dark_blue = 0x00008B,                
28    dark_cyan = 0x008B8B,                
29    dark_golden_rod = 0xB8860B,          
30    dark_gray = 0xA9A9A9,                
31    dark_green = 0x006400,               
32    dark_khaki = 0xBDB76B,               
33    dark_magenta = 0x8B008B,             
34    dark_olive_green = 0x556B2F,         
35    dark_orange = 0xFF8C00,              
36    dark_orchid = 0x9932CC,              
37    dark_red = 0x8B0000,                 
38    dark_salmon = 0xE9967A,              
39    dark_sea_green = 0x8FBC8F,           
40    dark_slate_blue = 0x483D8B,          
41    dark_slate_gray = 0x2F4F4F,          
42    dark_turquoise = 0x00CED1,           
43    dark_violet = 0x9400D3,              
44    deep_pink = 0xFF1493,                
45    deep_sky_blue = 0x00BFFF,            
46    dim_gray = 0x696969,                 
47    dodger_blue = 0x1E90FF,              
48    fire_brick = 0xB22222,               
49    floral_white = 0xFFFAF0,             
50    forest_green = 0x228B22,             
51    fuchsia = 0xFF00FF,                  
52    gainsboro = 0xDCDCDC,                
53    ghost_white = 0xF8F8FF,              
54    gold = 0xFFD700,                     
55    golden_rod = 0xDAA520,               
56    gray = 0x808080,                     
57    green = 0x008000,                    
58    green_yellow = 0xADFF2F,             
59    honey_dew = 0xF0FFF0,                
60    hot_pink = 0xFF69B4,                 
61    indian_red = 0xCD5C5C,               
62    indigo = 0x4B0082,                   
63    ivory = 0xFFFFF0,                    
64    khaki = 0xF0E68C,                    
65    lavender = 0xE6E6FA,                 
66    lavender_blush = 0xFFF0F5,           
67    lawn_green = 0x7CFC00,               
68    lemon_chiffon = 0xFFFACD,            
69    light_blue = 0xADD8E6,               
70    light_coral = 0xF08080,              
71    light_cyan = 0xE0FFFF,               
72    light_golden_rod_yellow = 0xFAFAD2,  
73    light_gray = 0xD3D3D3,               
74    light_green = 0x90EE90,              
75    light_pink = 0xFFB6C1,               
76    light_salmon = 0xFFA07A,             
77    light_sea_green = 0x20B2AA,          
78    light_sky_blue = 0x87CEFA,           
79    light_slate_gray = 0x778899,         
80    light_steel_blue = 0xB0C4DE,         
81    light_yellow = 0xFFFFE0,             
82    lime = 0x00FF00,                     
83    lime_green = 0x32CD32,               
84    linen = 0xFAF0E6,                    
85    magenta = 0xFF00FF,                  
86    maroon = 0x800000,                   
87    medium_aquamarine = 0x66CDAA,        
88    medium_blue = 0x0000CD,              
89    medium_orchid = 0xBA55D3,            
90    medium_purple = 0x9370DB,            
91    medium_sea_green = 0x3CB371,         
92    medium_slate_blue = 0x7B68EE,        
93    medium_spring_green = 0x00FA9A,      
94    medium_turquoise = 0x48D1CC,         
95    medium_violet_red = 0xC71585,        
96    midnight_blue = 0x191970,            
97    mint_cream = 0xF5FFFA,               
98    misty_rose = 0xFFE4E1,               
99    moccasin = 0xFFE4B5,                 
100    navajo_white = 0xFFDEAD,             
101    navy = 0x000080,                     
102    old_lace = 0xFDF5E6,                 
103    olive = 0x808000,                    
104    olive_drab = 0x6B8E23,               
105    orange = 0xFFA500,                   
106    orange_red = 0xFF4500,               
107    orchid = 0xDA70D6,                   
108    pale_golden_rod = 0xEEE8AA,          
109    pale_green = 0x98FB98,               
110    pale_turquoise = 0xAFEEEE,           
111    pale_violet_red = 0xDB7093,          
112    papaya_whip = 0xFFEFD5,              
113    peach_puff = 0xFFDAB9,               
114    peru = 0xCD853F,                     
115    pink = 0xFFC0CB,                     
116    plum = 0xDDA0DD,                     
117    powder_blue = 0xB0E0E6,              
118    purple = 0x800080,                   
119    rebecca_purple = 0x663399,           
120    red = 0xFF0000,                      
121    rosy_brown = 0xBC8F8F,               
122    royal_blue = 0x4169E1,               
123    saddle_brown = 0x8B4513,             
124    salmon = 0xFA8072,                   
125    sandy_brown = 0xF4A460,              
126    sea_green = 0x2E8B57,                
127    sea_shell = 0xFFF5EE,                
128    sienna = 0xA0522D,                   
129    silver = 0xC0C0C0,                   
130    sky_blue = 0x87CEEB,                 
131    slate_blue = 0x6A5ACD,               
132    slate_gray = 0x708090,               
133    snow = 0xFFFAFA,                     
134    spring_green = 0x00FF7F,             
135    steel_blue = 0x4682B4,               
136    tan = 0xD2B48C,                      
137    teal = 0x008080,                     
138    thistle = 0xD8BFD8,                  
139    tomato = 0xFF6347,                   
140    turquoise = 0x40E0D0,                
141    violet = 0xEE82EE,                   
142    wheat = 0xF5DEB3,                    
143    white = 0xFFFFFF,                    
144    white_smoke = 0xF5F5F5,              
145    yellow = 0xFFFF00,                   
146    yellow_green = 0x9ACD32              
147  };                                     
148  enum class terminal_color : uint8_t {
149    black = 30,
150    red,
151    green,
152    yellow,
153    blue,
154    magenta,
155    cyan,
156    white,
157    bright_black = 90,
158    bright_red,
159    bright_green,
160    bright_yellow,
161    bright_blue,
162    bright_magenta,
163    bright_cyan,
164    bright_white
165  };
166  enum class emphasis : uint8_t {
167    bold = 1,
168    italic = 1 << 1,
169    underline = 1 << 2,
170    strikethrough = 1 << 3
171  };
172  struct rgb {
173    FMT_CONSTEXPR rgb() : r(0), g(0), b(0) {}
174    FMT_CONSTEXPR rgb(uint8_t r_, uint8_t g_, uint8_t b_) : r(r_), g(g_), b(b_) {}
175    FMT_CONSTEXPR rgb(uint32_t hex)
176        : r((hex >> 16) & 0xFF), g((hex >> 8) & 0xFF), b(hex & 0xFF) {}
177    FMT_CONSTEXPR rgb(color hex)
178        : r((uint32_t(hex) >> 16) & 0xFF),
179          g((uint32_t(hex) >> 8) & 0xFF),
180          b(uint32_t(hex) & 0xFF) {}
181    uint8_t r;
182    uint8_t g;
183    uint8_t b;
184  };
185  namespace detail {
186  struct color_type {
187    FMT_CONSTEXPR color_type() FMT_NOEXCEPT : is_rgb(), value{} {}
188    FMT_CONSTEXPR color_type(color rgb_color) FMT_NOEXCEPT : is_rgb(true),
189                                                             value{} {
190      value.rgb_color = static_cast<uint32_t>(rgb_color);
191    }
192    FMT_CONSTEXPR color_type(rgb rgb_color) FMT_NOEXCEPT : is_rgb(true), value{} {
193      value.rgb_color = (static_cast<uint32_t>(rgb_color.r) << 16) |
194                        (static_cast<uint32_t>(rgb_color.g) << 8) | rgb_color.b;
195    }
196    FMT_CONSTEXPR color_type(terminal_color term_color) FMT_NOEXCEPT : is_rgb(),
197                                                                       value{} {
198      value.term_color = static_cast<uint8_t>(term_color);
199    }
200    bool is_rgb;
201    union color_union {
202      uint8_t term_color;
203      uint32_t rgb_color;
204    } value;
205  };
206  }  
207  class text_style {
208   public:
209    FMT_CONSTEXPR text_style(emphasis em = emphasis()) FMT_NOEXCEPT
210        : set_foreground_color(),
211          set_background_color(),
212          ems(em) {}
213    FMT_CONSTEXPR text_style& operator|=(const text_style& rhs) {
214      if (!set_foreground_color) {
215        set_foreground_color = rhs.set_foreground_color;
216        foreground_color = rhs.foreground_color;
217      } else if (rhs.set_foreground_color) {
218        if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
219          FMT_THROW(format_error("can't OR a terminal color"));
220        foreground_color.value.rgb_color |= rhs.foreground_color.value.rgb_color;
221      }
222      if (!set_background_color) {
223        set_background_color = rhs.set_background_color;
224        background_color = rhs.background_color;
225      } else if (rhs.set_background_color) {
226        if (!background_color.is_rgb || !rhs.background_color.is_rgb)
227          FMT_THROW(format_error("can't OR a terminal color"));
228        background_color.value.rgb_color |= rhs.background_color.value.rgb_color;
229      }
230      ems = static_cast<emphasis>(static_cast<uint8_t>(ems) |
231                                  static_cast<uint8_t>(rhs.ems));
232      return *this;
233    }
234    friend FMT_CONSTEXPR text_style operator|(text_style lhs,
235                                              const text_style& rhs) {
236      return lhs |= rhs;
237    }
238    FMT_CONSTEXPR text_style& operator&=(const text_style& rhs) {
239      if (!set_foreground_color) {
240        set_foreground_color = rhs.set_foreground_color;
241        foreground_color = rhs.foreground_color;
242      } else if (rhs.set_foreground_color) {
243        if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
244          FMT_THROW(format_error("can't AND a terminal color"));
245        foreground_color.value.rgb_color &= rhs.foreground_color.value.rgb_color;
246      }
247      if (!set_background_color) {
248        set_background_color = rhs.set_background_color;
249        background_color = rhs.background_color;
250      } else if (rhs.set_background_color) {
251        if (!background_color.is_rgb || !rhs.background_color.is_rgb)
252          FMT_THROW(format_error("can't AND a terminal color"));
253        background_color.value.rgb_color &= rhs.background_color.value.rgb_color;
254      }
255      ems = static_cast<emphasis>(static_cast<uint8_t>(ems) &
256                                  static_cast<uint8_t>(rhs.ems));
257      return *this;
258    }
259    friend FMT_CONSTEXPR text_style operator&(text_style lhs,
260                                              const text_style& rhs) {
261      return lhs &= rhs;
262    }
263    FMT_CONSTEXPR bool has_foreground() const FMT_NOEXCEPT {
264      return set_foreground_color;
265    }
266    FMT_CONSTEXPR bool has_background() const FMT_NOEXCEPT {
267      return set_background_color;
268    }
269    FMT_CONSTEXPR bool has_emphasis() const FMT_NOEXCEPT {
270      return static_cast<uint8_t>(ems) != 0;
271    }
272    FMT_CONSTEXPR detail::color_type get_foreground() const FMT_NOEXCEPT {
273      FMT_ASSERT(has_foreground(), "no foreground specified for this style");
274      return foreground_color;
275    }
276    FMT_CONSTEXPR detail::color_type get_background() const FMT_NOEXCEPT {
277      FMT_ASSERT(has_background(), "no background specified for this style");
278      return background_color;
279    }
280    FMT_CONSTEXPR emphasis get_emphasis() const FMT_NOEXCEPT {
281      FMT_ASSERT(has_emphasis(), "no emphasis specified for this style");
282      return ems;
283    }
284   private:
285    FMT_CONSTEXPR text_style(bool is_foreground,
286                             detail::color_type text_color) FMT_NOEXCEPT
287        : set_foreground_color(),
288          set_background_color(),
289          ems() {
290      if (is_foreground) {
291        foreground_color = text_color;
292        set_foreground_color = true;
293      } else {
294        background_color = text_color;
295        set_background_color = true;
296      }
297    }
298    friend FMT_CONSTEXPR_DECL text_style fg(detail::color_type foreground)
299        FMT_NOEXCEPT;
300    friend FMT_CONSTEXPR_DECL text_style bg(detail::color_type background)
301        FMT_NOEXCEPT;
302    detail::color_type foreground_color;
303    detail::color_type background_color;
304    bool set_foreground_color;
305    bool set_background_color;
306    emphasis ems;
307  };
308  FMT_CONSTEXPR text_style fg(detail::color_type foreground) FMT_NOEXCEPT {
309    return text_style(&bsol;*is_foreground=*/true, foreground);
310  }
311  FMT_CONSTEXPR text_style bg(detail::color_type background) FMT_NOEXCEPT {
312    return text_style(&bsol;*is_foreground=*/false, background);
313  }
314  FMT_CONSTEXPR text_style operator|(emphasis lhs, emphasis rhs) FMT_NOEXCEPT {
315    return text_style(lhs) | rhs;
316  }
317  namespace detail {
318  template <typename Char> struct ansi_color_escape {
319    FMT_CONSTEXPR ansi_color_escape(detail::color_type text_color,
320                                    const char* esc) FMT_NOEXCEPT {
321      if (!text_color.is_rgb) {
322        bool is_background = esc == detail::data::background_color;
323        uint32_t value = text_color.value.term_color;
324        if (is_background) value += 10u;
325        size_t index = 0;
326        buffer[index++] = static_cast<Char>('\x1b');
327        buffer[index++] = static_cast<Char>('[');
328        if (value >= 100u) {
329          buffer[index++] = static_cast<Char>('1');
330          value %= 100u;
331        }
332        buffer[index++] = static_cast<Char>('0' + value / 10u);
333        buffer[index++] = static_cast<Char>('0' + value % 10u);
334        buffer[index++] = static_cast<Char>('m');
335        buffer[index++] = static_cast<Char>('\0');
336        return;
337      }
338      for (int i = 0; i < 7; i++) {
339        buffer[i] = static_cast<Char>(esc[i]);
340      }
341      rgb color(text_color.value.rgb_color);
342      to_esc(color.r, buffer + 7, ';');
343      to_esc(color.g, buffer + 11, ';');
344      to_esc(color.b, buffer + 15, 'm');
345      buffer[19] = static_cast<Char>(0);
346    }
347    FMT_CONSTEXPR ansi_color_escape(emphasis em) FMT_NOEXCEPT {
348      uint8_t em_codes[4] = {};
349      uint8_t em_bits = static_cast<uint8_t>(em);
350      if (em_bits & static_cast<uint8_t>(emphasis::bold)) em_codes[0] = 1;
351      if (em_bits & static_cast<uint8_t>(emphasis::italic)) em_codes[1] = 3;
352      if (em_bits & static_cast<uint8_t>(emphasis::underline)) em_codes[2] = 4;
353      if (em_bits & static_cast<uint8_t>(emphasis::strikethrough))
354        em_codes[3] = 9;
355      size_t index = 0;
356      for (int i = 0; i < 4; ++i) {
357        if (!em_codes[i]) continue;
358        buffer[index++] = static_cast<Char>('\x1b');
359        buffer[index++] = static_cast<Char>('[');
360        buffer[index++] = static_cast<Char>('0' + em_codes[i]);
361        buffer[index++] = static_cast<Char>('m');
362      }
363      buffer[index++] = static_cast<Char>(0);
364    }
365    FMT_CONSTEXPR operator const Char*() const FMT_NOEXCEPT { return buffer; }
366    FMT_CONSTEXPR const Char* begin() const FMT_NOEXCEPT { return buffer; }
367    FMT_CONSTEXPR const Char* end() const FMT_NOEXCEPT {
368      return buffer + std::char_traits<Char>::length(buffer);
369    }
370   private:
371    Char buffer[7u + 3u * 4u + 1u];
372    static FMT_CONSTEXPR void to_esc(uint8_t c, Char* out,
373                                     char delimiter) FMT_NOEXCEPT {
374      out[0] = static_cast<Char>('0' + c / 100);
375      out[1] = static_cast<Char>('0' + c / 10 % 10);
376      out[2] = static_cast<Char>('0' + c % 10);
377      out[3] = static_cast<Char>(delimiter);
378    }
379  };
380  template <typename Char>
381  FMT_CONSTEXPR ansi_color_escape<Char> make_foreground_color(
382      detail::color_type foreground) FMT_NOEXCEPT {
383    return ansi_color_escape<Char>(foreground, detail::data::foreground_color);
384  }
385  template <typename Char>
386  FMT_CONSTEXPR ansi_color_escape<Char> make_background_color(
387      detail::color_type background) FMT_NOEXCEPT {
388    return ansi_color_escape<Char>(background, detail::data::background_color);
389  }
390  template <typename Char>
391  FMT_CONSTEXPR ansi_color_escape<Char> make_emphasis(emphasis em) FMT_NOEXCEPT {
392    return ansi_color_escape<Char>(em);
393  }
394  template <typename Char>
395  inline void fputs(const Char* chars, FILE* stream) FMT_NOEXCEPT {
396    std::fputs(chars, stream);
397  }
398  template <>
399  inline void fputs<wchar_t>(const wchar_t* chars, FILE* stream) FMT_NOEXCEPT {
400    std::fputws(chars, stream);
401  }
402  template <typename Char> inline void reset_color(FILE* stream) FMT_NOEXCEPT {
403    fputs(detail::data::reset_color, stream);
404  }
405  template <> inline void reset_color<wchar_t>(FILE* stream) FMT_NOEXCEPT {
406    fputs(detail::data::wreset_color, stream);
407  }
408  template <typename Char>
409  inline void reset_color(buffer<Char>& buffer) FMT_NOEXCEPT {
410    const char* begin = data::reset_color;
411    const char* end = begin + sizeof(data::reset_color) - 1;
412    buffer.append(begin, end);
413  }
414  template <typename Char>
415  void vformat_to(buffer<Char>& buf, const text_style& ts,
416                  basic_string_view<Char> format_str,
417                  basic_format_args<buffer_context<type_identity_t<Char>>> args) {
418    bool has_style = false;
419    if (ts.has_emphasis()) {
420      has_style = true;
421      auto emphasis = detail::make_emphasis<Char>(ts.get_emphasis());
422      buf.append(emphasis.begin(), emphasis.end());
423    }
424    if (ts.has_foreground()) {
425      has_style = true;
426      auto foreground = detail::make_foreground_color<Char>(ts.get_foreground());
427      buf.append(foreground.begin(), foreground.end());
428    }
429    if (ts.has_background()) {
430      has_style = true;
431      auto background = detail::make_background_color<Char>(ts.get_background());
432      buf.append(background.begin(), background.end());
433    }
434    detail::vformat_to(buf, format_str, args);
435    if (has_style) detail::reset_color<Char>(buf);
436  }
437  }  
438  template <typename S, typename Char = char_t<S>>
439  void vprint(std::FILE* f, const text_style& ts, const S& format,
440              basic_format_args<buffer_context<type_identity_t<Char>>> args) {
441    basic_memory_buffer<Char> buf;
442    detail::vformat_to(buf, ts, to_string_view(format), args);
443    buf.push_back(Char(0));
444    detail::fputs(buf.data(), f);
445  }
446  template <typename S, typename... Args,
447            FMT_ENABLE_IF(detail::is_string<S>::value)>
448  void print(std::FILE* f, const text_style& ts, const S& format_str,
449             const Args&... args) {
450    vprint(f, ts, format_str,
451           fmt::make_args_checked<Args...>(format_str, args...));
452  }
453  template <typename S, typename... Args,
454            FMT_ENABLE_IF(detail::is_string<S>::value)>
455  void print(const text_style& ts, const S& format_str, const Args&... args) {
456    return print(stdout, ts, format_str, args...);
457  }
458  template <typename S, typename Char = char_t<S>>
459  inline std::basic_string<Char> vformat(
460      const text_style& ts, const S& format_str,
461      basic_format_args<buffer_context<type_identity_t<Char>>> args) {
462    basic_memory_buffer<Char> buf;
463    detail::vformat_to(buf, ts, to_string_view(format_str), args);
464    return fmt::to_string(buf);
465  }
466  template <typename S, typename... Args, typename Char = char_t<S>>
467  inline std::basic_string<Char> format(const text_style& ts, const S& format_str,
468                                        const Args&... args) {
469    return vformat(ts, to_string_view(format_str),
470                   fmt::make_args_checked<Args...>(format_str, args...));
471  }
472  template <typename OutputIt, typename Char,
473            FMT_ENABLE_IF(detail::is_output_iterator<OutputIt>::value)>
474  OutputIt vformat_to(
475      OutputIt out, const text_style& ts, basic_string_view<Char> format_str,
476      basic_format_args<buffer_context<type_identity_t<Char>>> args) {
477    decltype(detail::get_buffer<Char>(out)) buf(detail::get_buffer_init(out));
478    detail::vformat_to(buf, ts, format_str, args);
479    return detail::get_iterator(buf);
480  }
481  template <typename OutputIt, typename S, typename... Args,
482            FMT_ENABLE_IF(detail::is_output_iterator<OutputIt>::value&&
483                              detail::is_string<S>::value)>
484  inline OutputIt format_to(OutputIt out, const text_style& ts,
485                            const S& format_str, Args&&... args) {
486    return vformat_to(out, ts, to_string_view(format_str),
487                      fmt::make_args_checked<Args...>(format_str, args...));
488  }
489  FMT_END_NAMESPACE
490  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2s.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-color.h</div>
                </div>
                <div class="column column_space"><pre><code>201     v[8] = blake2s_IV[0];
202     v[9] = blake2s_IV[1];
203     v[10] = blake2s_IV[2];
204     v[11] = blake2s_IV[3];
205     v[12] = md->blake2s.t[0] ^ blake2s_IV[4];
206     v[13] = md->blake2s.t[1] ^ blake2s_IV[5];
207     v[14] = md->blake2s.f[0] ^ blake2s_IV[6];
208     v[15] = md->blake2s.f[1] ^ blake2s_IV[7];
</pre></code></div>
                <div class="column column_space"><pre><code>17    brown = 0xA52A2A,                    
18    burly_wood = 0xDEB887,               
19    cadet_blue = 0x5F9EA0,               
20    chartreuse = 0x7FFF00,               
21    chocolate = 0xD2691E,                
22    coral = 0xFF7F50,                    
23    cornflower_blue = 0x6495ED,          
24    cornsilk = 0xFFF8DC,                 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    