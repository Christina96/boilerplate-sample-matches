<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for nfsim_func.c &amp; diffuse.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for nfsim_func.c &amp; diffuse.c
      </h3>
<h1 align="center">
        1.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>nfsim_func.c (12.037037%)<th>diffuse.c (0.5299633%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(43-53)<td><a href="#" name="0">(273-283)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(24-33)<td><a href="#" name="1">(283-291)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nfsim_func.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "nfsim_func.h"
2 #include "map_c.h"
3 static map_t graph_reaction_map = NULL;
4 void initialize_rxn_diffusion_functions(struct rxn *mol_ptr);
5 double get_standard_diffusion(void *self);
6 double get_nfsim_diffusion(void *self);
7 double get_standard_space_step(void *self);
8 double get_nfsim_space_step(void *self);
9 double get_standard_time_step(void *self);
10 double get_nfsim_time_step(void *self);
11 double rxn_get_nfsim_diffusion(struct rxn *, int);
12 double rxn_get_standard_diffusion(struct rxn *, int);
13 double rxn_get_nfsim_space_step(struct rxn *, int);
14 double rxn_get_standard_time_step(struct rxn *, int);
15 double rxn_get_nfsim_time_step(struct rxn *, int);
16 double rxn_get_standard_space_step(struct rxn *, int);
17 <a name="1"></a>
18 void initialize_diffusion_function(struct abstract_molecule *mol_ptr) {
19 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if (mol_ptr-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES &amp;&amp;
20       mol_ptr-&gt;graph_data-&gt;graph_diffusion != -1.0) {
21     mol_ptr-&gt;get_diffusion = &amp;get_nfsim_diffusion;
22     mol_ptr-&gt;get_space_step = &amp;get_nfsim_space_step;
23     mol_ptr-&gt;get_time_step = &amp;get_nfsim_time_step;
24   } else {
25     mol_ptr-&gt;get_diffusion = &amp;get_standard_diffusion;
26     mol_ptr-&gt;get_space_step = &amp;get_standard_space_step;
27     mol_ptr-&gt;get_time_step = &amp;get_standard_time_step;
28   }</b></font>
29   if (mol_ptr-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES &amp;&amp;
30       mol_ptr-&gt;graph_data-&gt;flags &gt;= 0) {
31     mol_ptr-&gt;get_flags = &amp;get_nfsim_flags;
32   } else {
33     mol_ptr-&gt;get_flags = &amp;get_standard_flags;
34 <a name="0"></a>  }
35 }
36 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>void initialize_rxn_diffusion_functions(struct rxn *mol_ptr) {
37   if (mol_ptr-&gt;players[0]-&gt;flags &amp; EXTERNAL_SPECIES) {
38     mol_ptr-&gt;get_reactant_diffusion = rxn_get_nfsim_diffusion;
39     mol_ptr-&gt;get_reactant_space_step = rxn_get_nfsim_space_step;
40     mol_ptr-&gt;get_reactant_time_step = rxn_get_nfsim_time_step;
41   } else {
42     mol_ptr-&gt;get_reactant_diffusion = rxn_get_standard_diffusion;
43     mol_ptr-&gt;get_reactant_space_step = rxn_get_standard_space_step;
44     mol_ptr-&gt;get_reactant_time_step = rxn_get_standard_time_step;
45   }
46 }</b></font>
47 u_int get_standard_flags(void *mol_ptr) {
48   struct abstract_molecule *am = (struct abstract_molecule *)mol_ptr;
49   return am-&gt;properties-&gt;flags;
50 }
51 u_int get_nfsim_flags(void *mol_ptr) {
52   struct abstract_molecule *am = (struct abstract_molecule *)mol_ptr;
53   if (am-&gt;graph_data-&gt;flags &lt; 0)
54     return get_standard_flags(am);
55   return (unsigned int)am-&gt;graph_data-&gt;flags;
56 }
57 double get_standard_diffusion(void *mol_ptr) {
58   struct abstract_molecule *am = (struct abstract_molecule *)mol_ptr;
59   return am-&gt;properties-&gt;D;
60 }
61 double get_nfsim_diffusion(void *mol_ptr) {
62   struct abstract_molecule *am = (struct abstract_molecule *)mol_ptr;
63   if (am-&gt;graph_data-&gt;graph_diffusion &gt; 0) {
64     return am-&gt;graph_data-&gt;graph_diffusion;
65   }
66   return get_standard_diffusion(am);
67 }
68 double get_standard_space_step(void *mol_ptr) {
69   struct abstract_molecule *am = (struct abstract_molecule *)mol_ptr;
70   return am-&gt;properties-&gt;space_step;
71 }
72 double get_nfsim_space_step(void *mol_ptr) {
73   struct abstract_molecule *am = (struct abstract_molecule *)mol_ptr;
74   if (am-&gt;graph_data-&gt;graph_diffusion &gt;= 0)
75     return am-&gt;graph_data-&gt;space_step;
76   return get_standard_space_step(am);
77 }
78 double get_standard_time_step(void *mol_ptr) {
79   struct abstract_molecule *am = (struct abstract_molecule *)mol_ptr;
80   return am-&gt;properties-&gt;time_step;
81 }
82 double get_nfsim_time_step(void *mol_ptr) {
83   struct abstract_molecule *am = (struct abstract_molecule *)mol_ptr;
84   if (am-&gt;graph_data-&gt;graph_diffusion &gt;= 0)
85     return am-&gt;graph_data-&gt;time_step;
86   return get_standard_time_step(am);
87 }
88 double rxn_get_standard_diffusion(struct rxn *mol_ptr, int index) {
89   return mol_ptr-&gt;players[index]-&gt;D;
90 }
91 double rxn_get_nfsim_diffusion(struct rxn *mol_ptr, int index) {
92   if (mol_ptr-&gt;reactant_graph_data &amp;&amp;
93       mol_ptr-&gt;reactant_graph_data[index]-&gt;graph_diffusion &gt;= 0) {
94     return mol_ptr-&gt;reactant_graph_data[index]-&gt;graph_diffusion;
95   }
96   return rxn_get_standard_diffusion(mol_ptr, index);
97 }
98 double rxn_get_standard_time_step(struct rxn *mol_ptr, int index) {
99   return mol_ptr-&gt;players[index]-&gt;time_step;
100 }
101 double rxn_get_nfsim_time_step(struct rxn *mol_ptr, int index) {
102   if (mol_ptr-&gt;reactant_graph_data &amp;&amp;
103       mol_ptr-&gt;reactant_graph_data[index]-&gt;graph_diffusion &gt;= 0) {
104     return mol_ptr-&gt;reactant_graph_data[index]-&gt;time_step;
105   }
106   return rxn_get_standard_time_step(mol_ptr, index);
107 }
108 double rxn_get_standard_space_step(struct rxn *mol_ptr, int index) {
109   return mol_ptr-&gt;players[index]-&gt;space_step;
110 }
111 double rxn_get_nfsim_space_step(struct rxn *mol_ptr, int index) {
112   if (mol_ptr-&gt;reactant_graph_data &amp;&amp;
113       mol_ptr-&gt;reactant_graph_data[index]-&gt;graph_diffusion &gt;= 0) {
114     return mol_ptr-&gt;reactant_graph_data[index]-&gt;space_step;
115   }
116   return rxn_get_standard_space_step(mol_ptr, index);
117 }
118 void initialize_graph_hashmap() { graph_reaction_map = hashmap_new(); }
119 int get_graph_data(unsigned long graph_pattern_hash,
120                    struct graph_data **graph_data) {
121   return hashmap_get_nohash(graph_reaction_map, graph_pattern_hash,
122                             graph_pattern_hash, (void **)(graph_data));
123 }
124 int store_graph_data(unsigned long graph_pattern_hash,
125                      struct graph_data *graph_data) {
126   return hashmap_put_nohash(graph_reaction_map, graph_pattern_hash,
127                             graph_pattern_hash, graph_data);
128 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>diffuse.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;assert.h&gt;
3 #include &lt;math.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include "diffuse.h"
7 #include "logging.h"
8 #include "mcell_structs.h"
9 #include "count_util.h"
10 #include "grid_util.h"
11 #include "vol_util.h"
12 #include "wall_util.h"
13 #include "react.h"
14 #include "react_nfsim.h"
15 #include "nfsim_func.h"
16 #include "debug_config.h"
17 #include "debug.h"
18 #include "dump_state.h"
19 #ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
20 #include &lt;vector&gt;
21 #endif
22 #define FREE_COLLISION_LISTS()                                                 \
23   do {                                                                         \
24     if (shead2 != NULL)                                                        \
25       mem_put_list(sv-&gt;local_storage-&gt;coll, shead2);                           \
26     if (shead != NULL)                                                         \
27       mem_put_list(sv-&gt;local_storage-&gt;coll, shead);                            \
28   } while (0)
29 static const int inert_to_mol = 1;
30 static const int inert_to_all = 2;
31 int move_sm_on_same_triangle(
32     struct volume *state,
33     struct surface_molecule *sm,
34     struct vector2 *new_loc,
35     struct periodic_image *previous_box,
36     struct wall *new_wall,
37     struct hit_data *hd_info);
38 static void redo_collision_list(struct volume* world, struct collision** shead,
39   struct collision** stail, struct collision** shead_exp,
40   struct volume_molecule* m, struct vector3* displacement, struct subvolume* sv);
41 static int collide_and_react_with_vol_mol(
42   struct volume* world, struct collision* smash, struct volume_molecule* vm,
43   struct collision** tentative, struct vector3* displacement,
44   struct vector3* loc_certain, double t_steps, double r_rate_factor);
45 static int collide_and_react_with_surf_mol(
46   struct volume* world, struct collision* smash, struct volume_molecule* vm,
47   struct collision** tentative, struct vector3** loc_certain, double t_steps,
48   int mol_grid_flag, int mol_mol_grid_flag, double r_rate_factor);
49 static int collide_and_react_with_walls(
50   struct volume* world, struct collision* smash, struct volume_molecule* vm,
51   struct collision** tentative, struct vector3** loc_certain, double t_steps,
52   int inertness, double r_rate_factor);
53 static int reflect_or_periodic_bc(
54   struct volume* world, struct collision* smash, struct vector3* displacement,
55   struct volume_molecule** mol, struct wall** reflectee,
56   struct collision** tentative, double* t_steps);
57 static void reflect_absorb_inside_out(
58     struct volume *world, struct surface_molecule *sm, struct hit_data *hd_head,
59     struct rxn **rx, struct rxn *matching_rxns[], struct vector2 boundary_pos,
60     struct wall *this_wall, int index_edge_was_hit, int *reflect_now,
61     int *absorb_now, int *this_wall_edge_region_border);
62 int reflect_absorb_outside_in( 
63     struct volume *world,
64     struct surface_molecule *sm,
65     struct hit_data **hd_head,
66     struct rxn **rx,
67     struct rxn *matching_rxns[],
68     struct vector2 boundary_pos,
69     struct wall *target_wall,
70     struct wall *this_wall,
71     int *reflect_now,
72     int *absorb_now,
73     int this_wall_edge_region_border);
74 void collide_and_react_with_subvol(
75   struct volume* world, struct collision *smash, struct vector3* displacement,
76   struct volume_molecule** mol, struct collision** tentative, double* t_steps);
77 void compute_displacement(
78   struct volume* world, struct collision* shead, struct volume_molecule* vm,
79   struct vector3* displacement, struct vector3* displacement2,
80   double* rate_factor, double* r_rate_factor, double* steps, double* t_steps,
81   double max_time);
82 void determine_mol_mol_reactions(
83   struct volume* world, struct volume_molecule* vm, struct collision** shead,
84   struct collision** stail, int interness);
85 void set_inertness_and_maxtime(
86   struct volume* world, struct volume_molecule* vm, double* maxtime,
87   int* inertness);
88 void register_hits(
89   struct volume* world, struct volume_molecule* m,
90   struct collision** tentative, struct wall** reflect_w, double* reflect_t,
91   struct vector3* displacement, struct collision* smash, double* t_steps);
92 void count_tentative_collisions(
93   struct volume *world, struct collision **tc, struct collision *smash, struct volume_molecule* m,
94   struct species *spec, double t_confident, int destroy_flag,
95   struct periodic_image *box, u_long id);
96 void change_boxes_2D(
97     bool periodic_traditional,
98     struct surface_molecule *sm,
99     struct geom_object *periodic_box_obj,
100     struct vector3 *hit_xyz,
101     struct vector3 *teleport_xyz);
102 void pick_2D_displacement(struct vector2 *v, double scale,
103                           struct rng_state *rng) {
104   static const double one_over_2_to_16th = 1.52587890625e-5;
105   struct vector2 a;
106   double f;
107   do {
108     unsigned int n = rng_uint(rng);
109     a.u = 2.0 * one_over_2_to_16th * (n &amp; 0xFFFF) - 1.0;
110     a.v = 2.0 * one_over_2_to_16th * (n &gt;&gt; 16) - 1.0;
111     f = a.u * a.u + a.v * a.v;
112   } while ((f &lt; EPS_C) || (f &gt; 1.0));
113   double normalFactor = sqrt(-log(f) / f);
114   v-&gt;u = a.u * normalFactor * scale;
115   v-&gt;v = a.v * normalFactor * scale;
116 }
117 void pick_clamped_displacement(struct vector3 *v, struct volume_molecule *vm,
118                                double *r_step_surface, struct rng_state *rng,
119                                u_int radial_subdivisions) {
120   static const double one_over_2_to_20th = 9.5367431640625e-7;
121   struct wall *w = vm-&gt;previous_wall;
122   unsigned int n = rng_uint(rng);
123   double r_n = r_step_surface[n &amp; (radial_subdivisions - 1)];
124   double p = one_over_2_to_20th * ((n &gt;&gt; 12) + 0.5);
125   double t = r_n / erfcinv(p * erfc(r_n));
126   struct vector2 r_uv;
127   pick_2D_displacement(&amp;r_uv, sqrt(t) * vm-&gt;get_space_step(vm), rng);
128   r_n *= vm-&gt;index * vm-&gt;get_space_step(vm);
129   v-&gt;x = r_n * w-&gt;normal.x + r_uv.u * w-&gt;unit_u.x + r_uv.v * w-&gt;unit_v.x;
130   v-&gt;y = r_n * w-&gt;normal.y + r_uv.u * w-&gt;unit_u.y + r_uv.v * w-&gt;unit_v.y;
131   v-&gt;z = r_n * w-&gt;normal.z + r_uv.u * w-&gt;unit_u.z + r_uv.v * w-&gt;unit_v.z;
132 }
133 void pick_release_displacement(struct vector3 *in_disk, struct vector3 *away,
134                                double scale, double *r_step_release,
135                                double *d_step, u_int radial_subdivisions,
136                                int directions_mask, u_int num_directions,
137                                double rx_radius_3d, struct rng_state *rng) {
138   static const double one_over_2_to_16th = 1.52587890625e-5;
139   struct vector2 disk;
140   struct vector3 orth, axo;
141   u_int bits = rng_uint(rng);
142   u_int x_bit = (bits &amp; 0x80000000);
143   u_int y_bit = (bits &amp; 0x40000000);
144   u_int z_bit = (bits &amp; 0x20000000);
145   u_int thetaphi_bits = (bits &amp; 0x1FFFF000) &gt;&gt; 12;
146   u_int r_bits = (bits &amp; 0x00000FFF);
147   double r = scale * r_step_release[r_bits &amp; (radial_subdivisions - 1)];
148   u_int idx = thetaphi_bits &amp; directions_mask;
149   while (idx &gt;= num_directions) {
150     idx = rng_uint(rng) &amp; directions_mask;
151   }
152   if (x_bit)
153     away-&gt;x = d_step[idx];
154   else
155     away-&gt;x = -d_step[idx];
156   if (y_bit)
157     away-&gt;y = d_step[idx + 1];
158   else
159     away-&gt;y = -d_step[idx + 1];
160   if (z_bit)
161     away-&gt;z = d_step[idx + 2];
162 <a name="0"></a>  else
163     away-&gt;z = -d_step[idx + 2];
164 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if (d_step[idx] &lt; d_step[idx + 1]) {
165     if (d_step[idx] &lt; d_step[idx + 2]) {
166       orth.x = 0;
167       orth.y = away-&gt;z;
168       orth.z = -away-&gt;y;
169     } else {
170       orth.x = away-&gt;y;
171 <a name="1"></a>      orth.y = -away-&gt;x;
172       orth.z = 0;
173     }
174   } else if (d_step[idx + 1] &lt; d_step[idx + 2]) {</b></font><font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>
175     orth.x = away-&gt;z;
176     orth.y = 0;
177     orth.z = -away-&gt;x;
178   } else {
179     orth.x = away-&gt;y;
180     orth.y = -away-&gt;x;
181     orth.z = 0;
182   }</b></font>
183   normalize(&amp;orth);
184   cross_prod(away, &amp;orth, &amp;axo);
185   double f;
186   do {
187     bits = rng_uint(rng);
188     disk.u = 2.0 * one_over_2_to_16th * (bits &amp; 0xFFFF) - 1.0;
189     disk.v = 2.0 * one_over_2_to_16th * (bits &gt;&gt; 16) - 1.0;
190     f = disk.u * disk.u + disk.v * disk.v;
191   } while (f &lt; 0.01 || f &gt; 1.0);
192   in_disk-&gt;x = (disk.u * orth.x + disk.v * axo.x) * rx_radius_3d;
193   in_disk-&gt;y = (disk.u * orth.y + disk.v * axo.y) * rx_radius_3d;
194   in_disk-&gt;z = (disk.u * orth.z + disk.v * axo.z) * rx_radius_3d;
195   away-&gt;x *= r;
196   away-&gt;y *= r;
197   away-&gt;z *= r;
198 }
199 void pick_displacement(struct vector3 *v, double scale, struct rng_state *rng) {
200   v-&gt;x = scale * rng_gauss(rng) * .70710678118654752440;
201   v-&gt;y = scale * rng_gauss(rng) * .70710678118654752440;
202   v-&gt;z = scale * rng_gauss(rng) * .70710678118654752440;
203 }
204 struct vector3* reflect_periodic_2D(
205     struct volume *state,
206     int index_edge_was_hit,
207     struct vector2 *origin_uv,
208     struct wall *curr_wall,
209     struct vector2 *disp_uv,
210     struct vector2 *boundary_uv,
211     struct vector3 *origin_xyz) {
212   struct vector3 target_xyz;
213   struct vector2 target_uv = {
214     origin_uv-&gt;u + disp_uv-&gt;u,
215     origin_uv-&gt;v + disp_uv-&gt;v
216   };
217   if (index_edge_was_hit == -1) {
218     uv2xyz(&amp;target_uv, curr_wall, &amp;target_xyz);
219   }
220   else if (index_edge_was_hit == 0 || 
221            index_edge_was_hit == 1 ||
222            index_edge_was_hit == 2) {
223     uv2xyz(boundary_uv, curr_wall, &amp;target_xyz);
224   }
225   else {
226     return NULL;
227   }
228   struct vector3 delta_xyz = {target_xyz.x - origin_xyz-&gt;x,
229                               target_xyz.y - origin_xyz-&gt;y,
230                               target_xyz.z - origin_xyz-&gt;z};
231   struct vector3 updated_xyz = *origin_xyz;
232   for (struct subvolume *sv = find_subvolume(state, origin_xyz, NULL);
233        sv != NULL; sv = next_subvol(
234           &amp;updated_xyz, &amp;delta_xyz, sv, state-&gt;x_fineparts, state-&gt;y_fineparts,
235           state-&gt;z_fineparts, state-&gt;ny_parts,
236           state-&gt;nz_parts)) {
237     for (struct wall_list *wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
238       if (wl-&gt;this_wall-&gt;parent_object != state-&gt;periodic_box_obj) {
239         continue;
240       }
241       struct vector3 *hit_xyz = (struct vector3 *)malloc(sizeof(*hit_xyz));
242       double t = 0.0;
243       int i = collide_wall(
244           &amp;updated_xyz, &amp;delta_xyz, wl-&gt;this_wall, &amp;t, hit_xyz, 0, state-&gt;rng,
245           state-&gt;notify, &amp;(state-&gt;ray_polygon_tests));
246       if (i != COLLIDE_MISS &amp;&amp;
247           (hit_xyz-&gt;x - target_xyz.x) * delta_xyz.x +
248           (hit_xyz-&gt;y - target_xyz.y) * delta_xyz.y +
249           (hit_xyz-&gt;z - target_xyz.z) * delta_xyz.z &lt; 0) {
250         if (!state-&gt;periodic_traditional) {
251           struct vector2 hit_uv;
252           xyz2uv(hit_xyz, curr_wall, &amp;hit_uv);
253           disp_uv-&gt;u = -(target_uv.u-hit_uv.u);
254           disp_uv-&gt;v = -(target_uv.v-hit_uv.v);
255           origin_uv-&gt;u = hit_uv.u;
256           origin_uv-&gt;v = hit_uv.v;
257         }
258         return hit_xyz;
259       }
260       free(hit_xyz);
261     }
262   }
263   return NULL;
264 }
265 void change_boxes_2D(
266     bool periodic_traditional,
267     struct surface_molecule *sm,
268     struct geom_object *periodic_box_obj,
269     struct vector3 *hit_xyz,
270     struct vector3 *teleport_xyz) {
271   assert(periodic_box_obj-&gt;object_type == BOX_OBJ);
272   struct polygon_object* p = (struct polygon_object*)(periodic_box_obj-&gt;contents);
273   struct subdivided_box* sb = p-&gt;sb;
274   double llx = sb-&gt;x[0];
275   double urx = sb-&gt;x[1];
276   double lly = sb-&gt;y[0];
277   double ury = sb-&gt;y[1];
278   double llz = sb-&gt;z[0];
279   double urz = sb-&gt;z[1];
280   int x_inc = (sm-&gt;periodic_box-&gt;x % 2 == 0) ? 1 : -1;
281   int y_inc = (sm-&gt;periodic_box-&gt;y % 2 == 0) ? 1 : -1;
282   int z_inc = (sm-&gt;periodic_box-&gt;z % 2 == 0) ? 1 : -1;
283   int box_inc_x = 0;
284   int box_inc_y = 0;
285   int box_inc_z = 0;
286   double x_pos = 0;
287   double y_pos = 0;
288   double z_pos = 0;
289   if (!distinguishable(hit_xyz-&gt;x, llx, EPS_C)) {
290     x_pos = urx - EPS_C;
291     box_inc_x = -x_inc;
292   } else if (!distinguishable(hit_xyz-&gt;x, urx, EPS_C)) {
293     x_pos = llx + EPS_C;
294     box_inc_x = x_inc;
295   }
296   if (periodic_traditional &amp;&amp; x_pos) {
297     teleport_xyz-&gt;x = x_pos;
298   }
299   if (!distinguishable(hit_xyz-&gt;y, lly, EPS_C)) {
300     y_pos = ury - EPS_C;
301     box_inc_y = -y_inc;
302   } else if (!distinguishable(hit_xyz-&gt;y, ury, EPS_C)) {
303     y_pos = lly + EPS_C;
304     box_inc_y = y_inc;
305   }
306   if (periodic_traditional &amp;&amp; y_pos) {
307     teleport_xyz-&gt;y = y_pos;
308   }
309   if (!distinguishable(hit_xyz-&gt;z, llz, EPS_C)) {
310     z_pos = urz - EPS_C;
311     box_inc_z = -z_inc;
312   } else if (!distinguishable(hit_xyz-&gt;z, urz, EPS_C)) {
313     z_pos = llz + EPS_C;
314     box_inc_z = z_inc;
315   }
316   if (periodic_traditional &amp;&amp; z_pos) {
317     teleport_xyz-&gt;z = z_pos;
318   }
319   if (!(periodic_traditional) &amp;&amp; (box_inc_x || box_inc_y || box_inc_z)) {
320     sm-&gt;periodic_box-&gt;x += box_inc_x;
321     sm-&gt;periodic_box-&gt;y += box_inc_y;
322     sm-&gt;periodic_box-&gt;z += box_inc_z;
323   }
324 }
325 void reflect_absorb_inside_out(
326     struct volume *world,
327     struct surface_molecule *sm,
328     struct hit_data *hd_head,
329     struct rxn **rx,
330     struct rxn *matching_rxns[],
331     struct vector2 boundary_pos,
332     struct wall *this_wall,
333     int index_edge_was_hit,
334     int *reflect_now,
335     int *absorb_now,
336     int *this_wall_edge_region_border) {
337   struct edge *this_edge = this_wall-&gt;edges[index_edge_was_hit];
338   if (is_wall_edge_region_border(this_wall, this_edge)) {
339     *this_wall_edge_region_border = 1;
340   }
341   struct wall *nbr_wall = NULL;
342   int nbr_edge_ind = -1;
343   find_neighbor_wall_and_edge(this_wall, index_edge_was_hit, &amp;nbr_wall, &amp;nbr_edge_ind);
344   int nbr_wall_edge_region_border = 0;
345   if (nbr_wall != NULL) {
346     if (is_wall_edge_region_border(nbr_wall, nbr_wall-&gt;edges[nbr_edge_ind])) {
347       nbr_wall_edge_region_border = 1;
348     }
349   }
350   if (is_wall_edge_restricted_region_border(world, this_wall, this_edge, sm)) {
351     int num_matching_rxns = trigger_intersect(
352         world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
353         world-&gt;all_volume_mols, world-&gt;all_surface_mols,
354         sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm, sm-&gt;orient,
355         this_wall, matching_rxns, 1, 1, 1);
356     for (int i = 0; i &lt; num_matching_rxns; i++) {
357       *rx = matching_rxns[i];
358       if ((*rx)-&gt;n_pathways == RX_REFLEC) {
359         *reflect_now = 1;
360         break;
361       } else if ((*rx)-&gt;n_pathways == RX_ABSORB_REGION_BORDER) {
362         *absorb_now = 1;
363         break;
364       }
365     }
366     if (reflect_now || absorb_now) {
367       if (this_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
368         update_hit_data(&amp;hd_head, this_wall, this_wall, sm, boundary_pos, 1, 0);
369       }
370       if (nbr_wall != NULL &amp;&amp; nbr_wall_edge_region_border) {
371         if (nbr_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
372           update_hit_data(&amp;hd_head, this_wall, nbr_wall, sm, boundary_pos, 0, 0);
373         }
374       }
375     }
376   }
377 }
378 int reflect_absorb_outside_in( 
379     struct volume *world,
380     struct surface_molecule *sm,
381     struct hit_data **hd_head,
382     struct rxn **rx,
383     struct rxn *matching_rxns[],
384     struct vector2 boundary_pos,
385     struct wall *target_wall,
386     struct wall *this_wall,
387     int *reflect_now,
388     int *absorb_now,
389     int this_wall_edge_region_border) {
390   int target_edge_ind = find_shared_edge_index_of_neighbor_wall(this_wall, target_wall);
391   int target_wall_edge_region_border = 0;
392   if (is_wall_edge_region_border(target_wall, target_wall-&gt;edges[target_edge_ind])) {
393     target_wall_edge_region_border = 1;
394   }
395   if (is_wall_edge_restricted_region_border(world, target_wall, target_wall-&gt;edges[target_edge_ind], sm)) {
396     *reflect_now = 0;
397     *absorb_now = 0;
398     int num_matching_rxns = trigger_intersect(
399         world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
400         world-&gt;all_volume_mols, world-&gt;all_surface_mols,
401         sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm,
402         sm-&gt;orient, target_wall, matching_rxns, 1, 1, 1);
403     for (int i = 0; i &lt; num_matching_rxns; i++) {
404       *rx = matching_rxns[i];
405       if ((*rx)-&gt;n_pathways == RX_REFLEC) {
406         *reflect_now = 1;
407         break;
408       } else if ((*rx)-&gt;n_pathways == RX_ABSORB_REGION_BORDER) {
409         *absorb_now = 1;
410         break;
411       }
412     }
413     if (*reflect_now || *absorb_now) {
414       if (target_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
415         update_hit_data(hd_head, this_wall, target_wall, sm, boundary_pos, 0, 0);
416         update_hit_data(hd_head, this_wall, this_wall, sm, boundary_pos, 1, 0);
417       }
418     }
419     if (*reflect_now || *absorb_now) {
420       return 1; 
421     }
422   }
423   if (this_wall_edge_region_border) {
424     if (this_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
425       update_hit_data(hd_head, this_wall, this_wall, sm, boundary_pos, 1, 1);
426     }
427   }
428   if (target_wall_edge_region_border) {
429     if (target_wall-&gt;flags &amp; sm-&gt;properties-&gt;flags &amp; COUNT_HITS) {
430       update_hit_data(hd_head, this_wall, target_wall, sm, boundary_pos, 0, 1);
431     }
432   }
433   return 0;
434 }
435 struct wall *ray_trace_2D(
436     struct volume *world,
437     struct surface_molecule *sm,
438     struct vector2 *disp,
439     struct vector2 *pos,
440     int *kill_me,
441     struct rxn **rxp,
442     struct hit_data **hit_data_info) {
443   struct hit_data *hit_data_head = NULL;
444   struct wall *this_wall = sm-&gt;grid-&gt;surface;
445   struct vector2 orig_pos = { sm-&gt;s_pos.u,
446                               sm-&gt;s_pos.v
447                             };
448   struct vector2 this_pos = { sm-&gt;s_pos.u,
449                              sm-&gt;s_pos.v
450                             };
451   struct vector2 this_disp = { disp-&gt;u,
452                               disp-&gt;v
453                              };
454   struct periodic_image orig_box = {sm-&gt;periodic_box-&gt;x,
455                                     sm-&gt;periodic_box-&gt;y,
456                                     sm-&gt;periodic_box-&gt;z
457                                    };
458   struct vector3 origin_xyz;
459   uv2xyz(&amp;this_pos, this_wall, &amp;origin_xyz);
460   struct rxn *rx = NULL;
461   while (1) {
462     int this_wall_edge_region_border = 0;
463     int absorb_now = 0;
464     int reflect_now = 0;
465     struct vector2 boundary_pos;
466     int index_edge_was_hit =
467         find_edge_point(this_wall, &amp;this_pos, &amp;this_disp, &amp;boundary_pos);
468     if (world-&gt;periodic_box_obj) {
469       struct vector3 *hit_xyz = reflect_periodic_2D(
470           world,
471           index_edge_was_hit,
472           &amp;this_pos,
473           this_wall,
474           &amp;this_disp,
475           &amp;boundary_pos,
476           &amp;origin_xyz);
477       if (hit_xyz) {
478         struct vector3 teleport_xyz = {hit_xyz-&gt;x,
479                                        hit_xyz-&gt;y,
480                                        hit_xyz-&gt;z
481                                       };
482         change_boxes_2D(
483           world-&gt;periodic_traditional, sm, world-&gt;periodic_box_obj, hit_xyz,
484           &amp;teleport_xyz);
485         if (world-&gt;periodic_traditional) {
486           struct vector2 target_uv = { this_pos.u + this_disp.u,
487                                       this_pos.v + this_disp.v
488                                      };
489           struct vector3 target_xyz;
490           uv2xyz(&amp;target_uv, this_wall, &amp;target_xyz);
491           struct vector3 remaining_disp_xyz = {target_xyz.x - hit_xyz-&gt;x,
492                                                target_xyz.y - hit_xyz-&gt;y,
493                                                target_xyz.z - hit_xyz-&gt;z
494                                               };
495           struct vector3 new_target_xyz = {teleport_xyz.x + remaining_disp_xyz.x,
496                                            teleport_xyz.y + remaining_disp_xyz.y,
497                                            teleport_xyz.z + remaining_disp_xyz.z,
498                                           };
499           int grid_index = 0;
500           int *grid_index_p = &amp;grid_index;
501           struct wall *prev_wall = this_wall;
502           this_wall = find_closest_wall(
503             world, &amp;teleport_xyz, 0.0, &amp;this_pos, grid_index_p, sm-&gt;properties, NULL, NULL, NULL);
504           if ((this_wall == NULL) ||
505               (this_wall-&gt;parent_object != prev_wall-&gt;parent_object) ) {
506             *hit_data_info = hit_data_head;
507             free(hit_xyz);
508             return NULL;
509           }
510           struct vector2 new_target_uv;
511           xyz2uv(&amp;new_target_xyz, this_wall, &amp;new_target_uv);
512           this_disp.u = new_target_uv.u - this_pos.u;
513           this_disp.v = new_target_uv.v - this_pos.v;
514         }
515         else {
516           origin_xyz.x = hit_xyz-&gt;x;
517           origin_xyz.y = hit_xyz-&gt;y;
518           origin_xyz.z = hit_xyz-&gt;z;
519         }
520         free(hit_xyz);
521         continue;
522       }
523     }
524     if (index_edge_was_hit == -2) {
525       sm-&gt;s_pos.u = orig_pos.u;
526       sm-&gt;s_pos.v = orig_pos.v;
527       sm-&gt;periodic_box-&gt;x = orig_box.x;
528       sm-&gt;periodic_box-&gt;y = orig_box.y;
529       sm-&gt;periodic_box-&gt;z = orig_box.z;
530       *hit_data_info = hit_data_head;
531       return NULL;
532     }
533     else if (index_edge_was_hit == -1) {
534       pos-&gt;u = this_pos.u + this_disp.u;
535       pos-&gt;v = this_pos.v + this_disp.v;
536       sm-&gt;s_pos.u = orig_pos.u;
537       sm-&gt;s_pos.v = orig_pos.v;
538       *hit_data_info = hit_data_head;
539       return this_wall;
540     }
541     struct vector2 old_pos = {this_pos.u,
542                              this_pos.v
543                              };
544     struct rxn *matching_rxns[MAX_MATCHING_RXNS];
545     if (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) {
546       reflect_absorb_inside_out(
547           world, sm, hit_data_head, &amp;rx, matching_rxns, boundary_pos, this_wall,
548           index_edge_was_hit, &amp;reflect_now, &amp;absorb_now,
549           &amp;this_wall_edge_region_border);
550       if (absorb_now) {
551         *kill_me = 1;
552         *rxp = rx;
553         *hit_data_info = hit_data_head;
554         return NULL;
555       }
556     }
557     struct vector2 new_disp;
558     if (!reflect_now) {
559       struct wall *target_wall =
560           traverse_surface(this_wall, &amp;old_pos, index_edge_was_hit, &amp;this_pos);
561       if (target_wall != NULL) {
562         if (sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) {
563           if (reflect_absorb_outside_in(
564               world, sm, &amp;hit_data_head, &amp;rx, matching_rxns, boundary_pos,
565               target_wall, this_wall, &amp;reflect_now, &amp;absorb_now,
566               this_wall_edge_region_border)) {
567             if (absorb_now) {
568               *kill_me = 1;
569               *rxp = rx;
570               *hit_data_info = hit_data_head;
571               return NULL;
572             }
573           }
574         }
575         if (!reflect_now) {
576           this_disp.u = old_pos.u + this_disp.u;
577           this_disp.v = old_pos.v + this_disp.v;
578           traverse_surface(this_wall, &amp;this_disp, index_edge_was_hit, &amp;new_disp);
579           this_disp.u = new_disp.u - this_pos.u;
580           this_disp.v = new_disp.v - this_pos.v;
581           this_wall = target_wall;
582           continue;
583         }
584       }
585     }
586     if (!reflect_now) {
587       *hit_data_info = hit_data_head;
588     }
589     new_disp.u = this_disp.u - (boundary_pos.u - old_pos.u);
590     new_disp.v = this_disp.v - (boundary_pos.v - old_pos.v);
591     double f;
592     struct vector2 reflector;
593     switch (index_edge_was_hit) {
594     case 0:
595       new_disp.v *= -1.0;
596       break;
597     case 1:
598       reflector.u = -this_wall-&gt;uv_vert2.v;
599       reflector.v = this_wall-&gt;uv_vert2.u - this_wall-&gt;uv_vert1_u;
600       f = 1.0 / sqrt(reflector.u * reflector.u + reflector.v * reflector.v);
601       reflector.u *= f;
602       reflector.v *= f;
603       f = 2.0 * (new_disp.u * reflector.u + new_disp.v * reflector.v);
604       new_disp.u -= f * reflector.u;
605       new_disp.v -= f * reflector.v;
606       break;
607     case 2:
608       reflector.u = this_wall-&gt;uv_vert2.v;
609       reflector.v = -this_wall-&gt;uv_vert2.u;
610       f = 1.0 / sqrt(reflector.u * reflector.u + reflector.v * reflector.v);
611       reflector.u *= f;
612       reflector.v *= f;
613       f = 2.0 * (new_disp.u * reflector.u + new_disp.v * reflector.v);
614       new_disp.u -= f * reflector.u;
615       new_disp.v -= f * reflector.v;
616       break;
617     default:
618       UNHANDLED_CASE(index_edge_was_hit);
619     }
620     this_pos.u = boundary_pos.u;
621     this_pos.v = boundary_pos.v;
622     this_disp.u = new_disp.u;
623     this_disp.v = new_disp.v;
624   } 
625   sm-&gt;s_pos.u = orig_pos.u;
626   sm-&gt;s_pos.v = orig_pos.v;
627   *hit_data_info = hit_data_head;
628   return NULL;
629 }
630 struct collision *ray_trace(struct volume *world, struct vector3 *init_pos,
631                             struct collision *c, struct subvolume *sv,
632                             struct vector3 *v, struct wall *reflectee) {
633   double tx, ty, tz;
634   world-&gt;ray_voxel_tests++;
635   struct collision *shead = NULL;
636   struct collision *smash = (struct collision *)CHECKED_MEM_GET(
637       sv-&gt;local_storage-&gt;coll, "collision structure");
638 #ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
639   std::vector&lt;wall_list*&gt; sorted_walls;
640   for (struct wall_list *wlp = sv-&gt;wall_head; wlp != NULL; wlp = wlp-&gt;next) {
641     sorted_walls.insert(sorted_walls.begin(), wlp);
642   }
643 #endif
644   struct wall_list fake_wlp;
645   fake_wlp.next = sv-&gt;wall_head;
646 #ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
647   for (unsigned wall_array_index = 0; wall_array_index &lt; sorted_walls.size(); wall_array_index++) {
648     struct wall_list *wlp = sorted_walls[wall_array_index];
649 #else
650   for (struct wall_list *wlp = sv-&gt;wall_head; wlp != NULL; wlp = wlp-&gt;next) {
651 #endif
652     if (wlp-&gt;this_wall == reflectee)
653       continue;
654 #ifdef DEBUG_COLLISIONS_WALL_EXTRA
655     DUMP_CONDITION3(
656         std::cout &lt;&lt; "Checking wall:\n";
657         dump_wall(wlp-&gt;this_wall, "", true);
658     );
659 #endif
660     int i = collide_wall(init_pos, v, wlp-&gt;this_wall, &amp;(smash-&gt;t), &amp;(smash-&gt;loc),
661                      1, world-&gt;rng, world-&gt;notify, &amp;(world-&gt;ray_polygon_tests));
662 #ifdef DEBUG_COLLISIONS_WALL_EXTRA
663     DUMP_CONDITION3(
664         if (i == COLLIDE_REDO || i == COLLIDE_FRONT || i == COLLIDE_BACK) {
665           std::cout &lt;&lt; "Collide wall: vm pos: " &lt;&lt; *init_pos  &lt;&lt; ", displacement: " &lt;&lt; *v &lt;&lt; "\n";
666           dump_wall(wlp-&gt;this_wall, "", true);
667           std::cout &lt;&lt; "collision time: " &lt;&lt; smash-&gt;t &lt;&lt; ", collision pos: " &lt;&lt; smash-&gt;loc &lt;&lt; "\n";
668         }
669     );
670 #endif
671     if (i == COLLIDE_REDO) {
672       if (shead != NULL)
673         mem_put_list(sv-&gt;local_storage-&gt;coll, shead);
674       shead = NULL;
675       wlp = &amp;fake_wlp;
676 #ifdef MCELL3_SORTED_WALLS_FOR_COLLISION
677       wall_array_index = 0;
678 #endif
679       continue;
680     } else if (i != COLLIDE_MISS) {
681       world-&gt;ray_polygon_colls++;
682       smash-&gt;what = COLLIDE_WALL + i;
683       smash-&gt;target = (void *)wlp-&gt;this_wall;
684       smash-&gt;next = shead;
685       shead = smash;
686       smash = (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
687                                                   "collision structure");
688     }
689   }
690   double dx, dy, dz;
691   dx = dy = dz = 0.0;
692   int i = -10;
693   if (v-&gt;x &lt; 0.0) {
694     dx = world-&gt;x_fineparts[sv-&gt;llf.x] - init_pos-&gt;x;
695     i = 0;
696   } else if (v-&gt;x &gt; 0.0) {
697     dx = world-&gt;x_fineparts[sv-&gt;urb.x] - init_pos-&gt;x;
698     i = 1;
699   }
700   int j = -10;
701   if (v-&gt;y &lt; 0.0) {
702     dy = world-&gt;y_fineparts[sv-&gt;llf.y] - init_pos-&gt;y;
703     j = 0;
704   } else if (v-&gt;y &gt; 0.0) {
705     dy = world-&gt;y_fineparts[sv-&gt;urb.y] - init_pos-&gt;y;
706     j = 1;
707   }
708   int k = -10;
709   if (v-&gt;z &lt; 0.0) {
710     dz = world-&gt;z_fineparts[sv-&gt;llf.z] - init_pos-&gt;z;
711     k = 0;
712   } else if (v-&gt;z &gt; 0.0) {
713     dz = world-&gt;z_fineparts[sv-&gt;urb.z] - init_pos-&gt;z;
714     k = 1;
715   }
716   if (i + j + k &lt; 0)   {
717     if (i + j + k &lt; -15)     {
718       if (i &gt;= 0)       {
719         smash-&gt;t = dx / v-&gt;x;
720         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
721       } else if (j &gt;= 0)       {
722         smash-&gt;t = dy / v-&gt;y;
723         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
724       } else if (k &gt;= 0)       {
725         smash-&gt;t = dz / v-&gt;z;
726         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
727       } else {
728         smash-&gt;t = FOREVER;
729         smash-&gt;what =
730       }
731     } else     {
732       if (i &lt; 0) {
733         ty = fabs(dy * v-&gt;z);
734         tz = fabs(v-&gt;y * dz);
735         if (ty &lt; tz) {
736           smash-&gt;t = dy / v-&gt;y;
737           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
738         } else {
739           smash-&gt;t = dz / v-&gt;z;
740           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
741         }
742       } else if (j &lt; 0) {
743         tx = fabs(dx * v-&gt;z);
744         tz = fabs(v-&gt;x * dz);
745         if (tx &lt; tz) {
746           smash-&gt;t = dx / v-&gt;x;
747           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
748         } else 
749 {          smash-&gt;t = dz / v-&gt;z;
750           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k
751 ;        }
752       } else       {
753         tx = fabs(dx * v-&gt;y);
754         ty = fabs(v-&gt;x * dy);
755         if (tx &lt; ty) {
756           smash-&gt;t = dx / v-&gt;x;
757           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
758         } else {
759           smash-&gt;t = dy / v-&gt;y;
760           smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
761         }
762       }
763     }
764   } else   {
765     tx = fabs(dx * v-&gt;y * v-&gt;z);
766     ty = fabs(v-&gt;x * dy * v-&gt;z);
767     tz = fabs(v-&gt;x * v-&gt;y * dz);
768     if (tx &lt; ty) {
769       if (tx &lt; tz) {
770         smash-&gt;t = dx / v-&gt;x;
771         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NX + i;
772       } else {
773         smash-&gt;t = dz / v-&gt;z;
774         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
775       }
776     } else {
777       if (ty &lt; tz) {
778         smash-&gt;t = dy / v-&gt;y;
779         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NY + j;
780       } else {
781         smash-&gt;t = dz / v-&gt;z;
782         smash-&gt;what = COLLIDE_SUBVOL + COLLIDE_SV_NZ + k;
783       }
784     }
785   }
786   smash-&gt;loc.x = init_pos-&gt;x + smash-&gt;t * v-&gt;x;
787   smash-&gt;loc.y = init_pos-&gt;y + smash-&gt;t * v-&gt;y;
788   smash-&gt;loc.z = init_pos-&gt;z + smash-&gt;t * v-&gt;z;
789   smash-&gt;target = sv;
790   smash-&gt;next = shead;
791   shead = smash;
792   for (; c != NULL; c = c-&gt;next) {
793     struct abstract_molecule *a = (struct abstract_molecule *)c-&gt;target;
794     if (a-&gt;properties == NULL)
795       continue;
796     i = collide_mol(init_pos, v, a, &amp;(c-&gt;t), &amp;(c-&gt;loc), world-&gt;rx_radius_3d);
797     if (i != COLLIDE_MISS) {
798       smash = (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
799                                                   "collision structure");
800       memcpy(smash, c, sizeof(struct collision));
801       smash-&gt;what = COLLIDE_VOL + i;
802       smash-&gt;next = shead;
803       shead = smash;
804     }
805   }
806   return shead;
807 }
808 struct exd_vector3 {
809   double m, u, v;
810 };
811 static double exd_zetize(double y, double x) {
812   if (y &gt;= 0.0) {
813     if (x &gt;= 0) {
814       if (x &lt; y)
815         return 1.0 - 0.5 * x / y;
816       else
817         return 0.5 * y / x;
818     } else {
819       if (-x &lt; y)
820         return 1.0 - 0.5 * x / y;
821       else
822         return 2.0 + 0.5 * y / x;
823     }
824   } else {
825     if (x &lt;= 0) {
826       if (y &lt; x)
827         return 3.0 - 0.5 * x / y;
828       else
829         return 2.0 + 0.5 * y / x;
830     } else {
831       if (x &lt; -y)
832         return 3.0 - 0.5 * x / y;
833       else
834         return 4.0 + 0.5 * y / x;
835     }
836   }
837 }
838 static void exd_coordize(struct vector3 *mv, struct vector3 *m,
839                          struct vector3 *u, struct vector3 *v) {
840   double a;
841   a = 1.0 / sqrt(mv-&gt;x * mv-&gt;x + mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z);
842   m-&gt;x = a * mv-&gt;x;
843   m-&gt;y = a * mv-&gt;y;
844   m-&gt;z = a * mv-&gt;z;
845   if (m-&gt;x * m-&gt;x &gt; m-&gt;y * m-&gt;y) {
846     if (m-&gt;x * m-&gt;x &gt; m-&gt;z * m-&gt;z) {
847       if (m-&gt;y * m-&gt;y &gt; m-&gt;z * m-&gt;z) {
848         u-&gt;x = m-&gt;y;
849         u-&gt;y = -m-&gt;x;
850         u-&gt;z = 0.0;
851         a = 1.0 - m-&gt;z * m-&gt;z;
852         v-&gt;x = m-&gt;z * m-&gt;x;
853         v-&gt;y = m-&gt;z * m-&gt;y;
854         v-&gt;z = -a;
855       } else {
856         u-&gt;x = m-&gt;z;
857         u-&gt;y = 0.0;
858         u-&gt;z = -m-&gt;x;
859         a = 1.0 - m-&gt;y * m-&gt;y;
860         v-&gt;x = -m-&gt;y * m-&gt;x;
861         v-&gt;y = a;
862         v-&gt;z = -m-&gt;y * m-&gt;z;
863       }
864     } else {
865       u-&gt;x = -m-&gt;z;
866       u-&gt;y = 0.0;
867       u-&gt;z = m-&gt;x;
868       a = 1.0 - m-&gt;y * m-&gt;y;
869       v-&gt;x = m-&gt;y * m-&gt;x;
870       v-&gt;y = -a;
871       v-&gt;z = m-&gt;y * m-&gt;z;
872     }
873   } else {
874     if (m-&gt;y * m-&gt;y &gt; m-&gt;z * m-&gt;z) {
875       if (m-&gt;x * m-&gt;x &gt; m-&gt;z * m-&gt;z) {
876         u-&gt;x = -m-&gt;y;
877         u-&gt;y = m-&gt;x;
878         u-&gt;z = 0.0;
879         a = 1.0 - m-&gt;z * m-&gt;z;
880         v-&gt;x = -m-&gt;z * m-&gt;x;
881         v-&gt;y = -m-&gt;z * m-&gt;y;
882         v-&gt;z = a;
883       } else {
884         u-&gt;x = 0.0;
885         u-&gt;y = m-&gt;z;
886         u-&gt;z = -m-&gt;y;
887         a = 1.0 - m-&gt;x * m-&gt;x;
888         v-&gt;x = -a;
889         v-&gt;y = m-&gt;x * m-&gt;y;
890         v-&gt;z = m-&gt;x * m-&gt;z;
891       }
892     } else {
893       u-&gt;x = 0.0;
894       u-&gt;y = -m-&gt;z;
895       u-&gt;z = m-&gt;y;
896       a = 1.0 - m-&gt;x * m-&gt;x;
897       v-&gt;x = a;
898       v-&gt;y = -m-&gt;x * m-&gt;y;
899       v-&gt;z = -m-&gt;x * m-&gt;z;
900     }
901   }
902   a = 1 / sqrt(a);
903   u-&gt;x *= a;
904   u-&gt;y *= a;
905   u-&gt;z *= a;
906   v-&gt;x *= a;
907   v-&gt;y *= a;
908   v-&gt;z *= a;
909 }
910 enum {
911   EXD_HEAD,
912   EXD_TAIL,
913   EXD_CROSS,
914   EXD_SPAN,
915   EXD_OTHER
916 };
917 #define TARGET_OCCLUDED -1
918 double exact_disk(struct volume *world, struct vector3 *loc, struct vector3 *mv,
919                   double R, struct subvolume *sv,
920                   struct volume_molecule *moving,
921                   struct volume_molecule *target, int use_expanded_list,
922                   double *x_fineparts, double *y_fineparts,
923                   double *z_fineparts) {
924 #define EXD_SPAN_CALC(v1, v2, p)                                               \
925   ((v1)-&gt;u - (p)-&gt;u) * ((v2)-&gt;v - (p)-&gt;v) -                                    \
926       ((v2)-&gt;u - (p)-&gt;u) * ((v1)-&gt;v - (p)-&gt;v)
927 #define EXD_TIME_CALC(v1, v2, p)                                               \
928   ((p)-&gt;u *(v1)-&gt;v - (p)-&gt;v *(v1)-&gt;u) /                                        \
929       ((p)-&gt;v *((v2)-&gt;u - (v1)-&gt;u) - (p)-&gt;u *((v2)-&gt;v - (v1)-&gt;v))
930   struct wall_list *wl;
931   struct wall *w;
932   struct vector3 llf, urb;
933   struct exd_vector3 v0muv, v1muv, v2muv;
934   struct exd_vertex pa, pb;
935   struct exd_vertex *ppa, *ppb, *pqa, *pqb, *vertex_head, *vp, *vq, *vr, *vs;
936   double pa_pb;
937   int n_verts, n_edges;
938   int p_flags;
939   double R2;
940   struct vector3 m, u, v;
941   struct exd_vector3 Lmuv;
942   struct exd_vertex sm;
943   double m2_i;
944   double l_n, m_n;
945   double a, b, c, d, r, s, t, A, zeta, last_zeta;
946   int i;
947   int num_matching_rxns = 0;
948   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
949   vertex_head = NULL;
950   n_verts = 0;
951   n_edges = 0;
952   R2 = R * R;
953   m2_i = 1.0 / (mv-&gt;x * mv-&gt;x + mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z);
954   Lmuv.m = Lmuv.u = Lmuv.v = 0.0;        sm.u = sm.v = sm.r2 = sm.zeta = 0.0; 
955   exd_coordize(mv, &amp;m, &amp;u, &amp;v);
956   Lmuv.m = loc-&gt;x * m.x + loc-&gt;y * m.y + loc-&gt;z * m.z;
957   Lmuv.u = loc-&gt;x * u.x + loc-&gt;y * u.y + loc-&gt;z * u.z;
958   Lmuv.v = loc-&gt;x * v.x + loc-&gt;y * v.y + loc-&gt;z * v.z;
959   if (!distinguishable_vec3(loc, &amp;(target-&gt;pos), EPS_C)) {     sm.u = sm.v = sm.r2 = sm.zeta = 0.0;
960   } else {     sm.u = (target-&gt;pos.x - loc-&gt;x) * u.x + (target-&gt;pos.y - loc-&gt;y) * u.y +
961            (target-&gt;pos.z - loc-&gt;z) * u.z;
962     sm.v = (target-&gt;pos.x - loc-&gt;x) * v.x + (target-&gt;pos.y - loc-&gt;y) * v.y +
963            (target-&gt;pos.z - loc-&gt;z) * v.z;
964     sm.r2 = sm.u * sm.u + sm.v * sm.v;
965     sm.zeta = exd_zetize(sm.v, sm.u);
966   }
967   for (wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
968     w = wl-&gt;this_wall;
969     l_n = loc-&gt;x * w-&gt;normal.x + loc-&gt;y * w-&gt;normal.y + loc-&gt;z * w-&gt;normal.z;
970     d = w-&gt;d - l_n;
971     m_n = mv-&gt;x * w-&gt;normal.x + mv-&gt;y * w-&gt;normal.y + mv-&gt;z * w-&gt;normal.z;
972     if (d * d &gt;= R2 * (1 - m2_i * m_n * m_n))
973       continue;
974     urb.x = llf.x = w-&gt;vert[0]-&gt;x;
975     if (w-&gt;vert[1]-&gt;x &lt; llf.x)
976       llf.x = w-&gt;vert[1]-&gt;x;
977     else
978       urb.x = w-&gt;vert[1]-&gt;x;
979     if (w-&gt;vert[2]-&gt;x &lt; llf.x)
980       llf.x = w-&gt;vert[2]-&gt;x;
981     else if (w-&gt;vert[2]-&gt;x &gt; urb.x)
982       urb.x = w-&gt;vert[2]-&gt;x;
983     urb.y = llf.y = w-&gt;vert[0]-&gt;y;
984     if (w-&gt;vert[1]-&gt;y &lt; llf.y)
985       llf.y = w-&gt;vert[1]-&gt;y;
986     else
987       urb.y = w-&gt;vert[1]-&gt;y;
988     if (w-&gt;vert[2]-&gt;y &lt; llf.y)
989       llf.y = w-&gt;vert[2]-&gt;y;
990     else if (w-&gt;vert[2]-&gt;y &gt; urb.y)
991       urb.y = w-&gt;vert[2]-&gt;y;
992     urb.z = llf.z = w-&gt;vert[0]-&gt;z;
993     if (w-&gt;vert[1]-&gt;z &lt; llf.z)
994       llf.z = w-&gt;vert[1]-&gt;z;
995     else
996       urb.z = w-&gt;vert[1]-&gt;z;
997     if (w-&gt;vert[2]-&gt;z &lt; llf.z)
998       llf.z = w-&gt;vert[2]-&gt;z;
999     else if (w-&gt;vert[2]-&gt;z &gt; urb.z)
1000       urb.z = w-&gt;vert[2]-&gt;z;
1001     b = R2 * (1.0 - mv-&gt;x * mv-&gt;x * m2_i);
1002     a = llf.x - loc-&gt;x;
1003     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1004       continue;
1005     a = loc-&gt;x - urb.x;
1006     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1007       continue;
1008     b = R2 * (1.0 - mv-&gt;y * mv-&gt;y * m2_i);
1009     a = llf.y - loc-&gt;y;
1010     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1011       continue;
1012     a = loc-&gt;y - urb.y;
1013     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1014       continue;
1015     b = R2 * (1.0 - mv-&gt;z * mv-&gt;z * m2_i);
1016     a = llf.z - loc-&gt;z;
1017     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1018       continue;
1019     a = loc-&gt;z - urb.z;
1020     if (a &gt; 0 &amp;&amp; a * a &gt;= b)
1021       continue;
1022     if ((moving-&gt;properties-&gt;flags &amp; CAN_VOLWALL) != 0) {
1023       num_matching_rxns = trigger_intersect(
1024           world-&gt;reaction_hash, world-&gt;rx_hashsize, world-&gt;all_mols,
1025           world-&gt;all_volume_mols, world-&gt;all_surface_mols,
1026           moving-&gt;properties-&gt;hashval, (struct abstract_molecule *)moving, 0, w,
1027           matching_rxns, 1, 1, 0);
1028       if (num_matching_rxns != 0) {
1029         bool all_transparent = true;
1030         for (i = 0; i &lt; num_matching_rxns; i++) {
1031           if (matching_rxns[i]-&gt;n_pathways != RX_TRANSP) {
1032             all_transparent = false;
1033             break;
1034           }
1035         }
1036         if (all_transparent) {
1037           continue;
1038         }
1039       }
1040     }
1041 #if 0
1042     if (uncoordinated) {
1043       exd_coordize(mv, &amp;m, &amp;u, &amp;v);
1044       Lmuv.m = loc-&gt;x * m.x + loc-&gt;y * m.y + loc-&gt;z * m.z;
1045       Lmuv.u = loc-&gt;x * u.x + loc-&gt;y * u.y + loc-&gt;z * u.z;
1046       Lmuv.v = loc-&gt;x * v.x + loc-&gt;y * v.y + loc-&gt;z * v.z;
1047       if (!distinguishable_vec3(loc, &amp;(target-&gt;pos),
1048                                 EPS_C))       {
1049         sm.u = sm.v = sm.r2 = sm.zeta = 0.0;
1050       } else       {
1051         sm.u = (target-&gt;pos.x - loc-&gt;x) * u.x + (target-&gt;pos.y - loc-&gt;y) * u.y +
1052                (target-&gt;pos.z - loc-&gt;z) * u.z;
1053         sm.v = (target-&gt;pos.x - loc-&gt;x) * v.x + (target-&gt;pos.y - loc-&gt;y) * v.y +
1054                (target-&gt;pos.z - loc-&gt;z) * v.z;
1055         sm.r2 = sm.u * sm.u + sm.v * sm.v;
1056         sm.zeta = exd_zetize(sm.v, sm.u);
1057       }
1058       uncoordinated = 0;
1059     }
1060 #endif
1061     v0muv.m = w-&gt;vert[0]-&gt;x * m.x + w-&gt;vert[0]-&gt;y * m.y + w-&gt;vert[0]-&gt;z * m.z -
1062               Lmuv.m;
1063     v0muv.u = w-&gt;vert[0]-&gt;x * u.x + w-&gt;vert[0]-&gt;y * u.y + w-&gt;vert[0]-&gt;z * u.z -
1064               Lmuv.u;
1065     v0muv.v = w-&gt;vert[0]-&gt;x * v.x + w-&gt;vert[0]-&gt;y * v.y + w-&gt;vert[0]-&gt;z * v.z -
1066               Lmuv.v;
1067     v1muv.m = w-&gt;vert[1]-&gt;x * m.x + w-&gt;vert[1]-&gt;y * m.y + w-&gt;vert[1]-&gt;z * m.z -
1068               Lmuv.m;
1069     v1muv.u = w-&gt;vert[1]-&gt;x * u.x + w-&gt;vert[1]-&gt;y * u.y + w-&gt;vert[1]-&gt;z * u.z -
1070               Lmuv.u;
1071     v1muv.v = w-&gt;vert[1]-&gt;x * v.x + w-&gt;vert[1]-&gt;y * v.y + w-&gt;vert[1]-&gt;z * v.z -
1072               Lmuv.v;
1073     v2muv.m = w-&gt;vert[2]-&gt;x * m.x + w-&gt;vert[2]-&gt;y * m.y + w-&gt;vert[2]-&gt;z * m.z -
1074               Lmuv.m;
1075     v2muv.u = w-&gt;vert[2]-&gt;x * u.x + w-&gt;vert[2]-&gt;y * u.y + w-&gt;vert[2]-&gt;z * u.z -
1076               Lmuv.u;
1077     v2muv.v = w-&gt;vert[2]-&gt;x * v.x + w-&gt;vert[2]-&gt;y * v.y + w-&gt;vert[2]-&gt;z * v.z -
1078               Lmuv.v;
1079     if ((v0muv.m &lt; 0) == (v1muv.m &lt; 0))     {
1080       if ((v2muv.m &lt; 0) == (v1muv.m &lt; 0))
1081         continue;
1082       t = v0muv.m / (v0muv.m - v2muv.m);
1083       pa.u = v0muv.u + (v2muv.u - v0muv.u) * t;
1084       pa.v = v0muv.v + (v2muv.v - v0muv.v) * t;
1085       t = v1muv.m / (v1muv.m - v2muv.m);
1086       pb.u = v1muv.u + (v2muv.u - v1muv.u) * t;
1087       pb.v = v1muv.v + (v2muv.v - v1muv.v) * t;
1088     } else if ((v0muv.m &lt; 0) == (v2muv.m &lt; 0))     {
1089       t = v0muv.m / (v0muv.m - v1muv.m);
1090       pa.u = v0muv.u + (v1muv.u - v0muv.u) * t;
1091       pa.v = v0muv.v + (v1muv.v - v0muv.v) * t;
1092       t = v2muv.m / (v2muv.m - v1muv.m);
1093       pb.u = v2muv.u + (v1muv.u - v2muv.u) * t;
1094       pb.v = v2muv.v + (v1muv.v - v2muv.v) * t;
1095     } else     {
1096       t = v1muv.m / (v1muv.m - v0muv.m);
1097       pa.u = v1muv.u + (v0muv.u - v1muv.u) * t;
1098       pa.v = v1muv.v + (v0muv.v - v1muv.v) * t;
1099       t = v2muv.m / (v2muv.m - v0muv.m);
1100       pb.u = v2muv.u + (v0muv.u - v2muv.u) * t;
1101       pb.v = v2muv.v + (v0muv.v - v2muv.v) * t;
1102     }
1103     pa.r2 = pa.u * pa.u + pa.v * pa.v;
1104     pb.r2 = pb.u * pb.u + pb.v * pb.v;
1105     if (pa.r2 &lt; EPS_C * R2 ||
1106     {
1107       if (vertex_head != NULL)
1108         mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
1109       return TARGET_OCCLUDED;
1110     }
1111     if (!distinguishable(pa.u * pb.v, pb.u * pa.v, EPS_C) &amp;&amp;
1112         pa.u * pb.u + pa.v * pb.v &lt;
1113             0)     {
1114       if (vertex_head != NULL)
1115         mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
1116       return TARGET_OCCLUDED;
1117     }
1118     t = 0;
1119     s = 1;
1120     if (pa.r2 &gt; R2 || pb.r2 &gt; R2) {
1121       pa_pb = pa.u * pb.u + pa.v * pb.v;
1122       if (!distinguishable(pa.r2 + pb.r2, 2 * pa_pb,
1123       {
1124         if (sm.r2 &lt; pa.r2 &amp;&amp; sm.r2 &lt; pb.r2 &amp;&amp;
1125             distinguishable(sm.r2, pa.r2, EPS_C) &amp;&amp;
1126             distinguishable(sm.r2, pa.r2, EPS_C))
1127           continue;
1128         if (!distinguishable(sm.u * pa.v, sm.v * pa.u, SQRT_EPS_C) ||
1129             !distinguishable(sm.u * pb.v, sm.v * pb.u, SQRT_EPS_C)) {
1130           if (vertex_head != NULL)
1131             mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
1132           return TARGET_OCCLUDED;
1133         }
1134         continue;
1135       }
1136       a = 1.0 / (pa.r2 + pb.r2 - 2 * pa_pb);
1137       b = (pa_pb - pa.r2) * a;
1138       c = (R2 - pa.r2) * a;
1139       d = b * b + c;
1140       if (d &lt;= 0)
1141         continue;
1142       d = sqrt(d);
1143       t = -b - d;
1144       if (t &gt;= 1)
1145         continue;
1146       if (t &lt; 0)
1147         t = 0;
1148       s = -b + d;
1149       if (s &lt;= 0)
1150         continue;
1151       if (s &gt; 1)
1152         s = 1;
1153     }
1154     ppa = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1155                                                "exact disk vertex");
1156     ppb = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1157                                                "exact disk vertex");
1158     if (t &gt; 0) {
1159       ppa-&gt;u = pa.u + t * (pb.u - pa.u);
1160       ppa-&gt;v = pa.v + t * (pb.v - pa.v);
1161       ppa-&gt;r2 = ppa-&gt;u * ppa-&gt;u + ppa-&gt;v * ppa-&gt;v;
1162       ppa-&gt;zeta = exd_zetize(ppa-&gt;v, ppa-&gt;u);
1163     } else {
1164       ppa-&gt;u = pa.u;
1165       ppa-&gt;v = pa.v;
1166       ppa-&gt;r2 = pa.r2;
1167       ppa-&gt;zeta = exd_zetize(pa.v, pa.u);
1168     }
1169     if (s &lt; 1) {
1170       ppb-&gt;u = pa.u + s * (pb.u - pa.u);
1171       ppb-&gt;v = pa.v + s * (pb.v - pa.v);
1172       ppb-&gt;r2 = ppb-&gt;u * ppb-&gt;u + ppb-&gt;v * ppb-&gt;v;
1173       ppb-&gt;zeta = exd_zetize(ppb-&gt;v, ppb-&gt;u);
1174     } else {
1175       ppb-&gt;u = pb.u;
1176       ppb-&gt;v = pb.v;
1177       ppb-&gt;r2 = pb.r2;
1178       ppb-&gt;zeta = exd_zetize(pb.v, pb.u);
1179     }
1180     a = (ppb-&gt;zeta - ppa-&gt;zeta);
1181     if (a &lt; 0)
1182       a += 4.0;
1183     if (a &gt;= 2.0) {
1184       vp = ppb;
1185       ppb = ppa;
1186       ppa = vp;
1187       a = 4.0 - a;
1188     }
1189     b = (sm.zeta - ppa-&gt;zeta);
1190     if (b &lt; 0)
1191       b += 4.0;
1192     if (b &lt; a) {
1193       c = (ppa-&gt;u - sm.u) * (ppb-&gt;v - sm.v) - (ppa-&gt;v - sm.v) * (ppb-&gt;u - sm.u);
1194       if (c &lt; 0 || !distinguishable((ppa-&gt;u - sm.u) * (ppb-&gt;v - sm.v),
1195                                     (ppa-&gt;v - sm.v) * (ppb-&gt;u - sm.u),
1196                                     EPS_C))       {
1197         ppa-&gt;next = ppb;
1198         ppb-&gt;next = vertex_head;
1199         mem_put_list(sv-&gt;local_storage-&gt;exdv, ppa);
1200         return TARGET_OCCLUDED;
1201       }
1202     }
1203     ppa-&gt;role = EXD_HEAD;
1204     ppb-&gt;role = EXD_TAIL;
1205     ppa-&gt;e = ppb;
1206     ppb-&gt;e = NULL;
1207     ppb-&gt;next = vertex_head;
1208     ppa-&gt;next = ppb;
1209     vertex_head = ppa;
1210     n_verts += 2;
1211     n_edges++;
1212   }
1213   if (!use_expanded_list)   {
1214     p_flags = 0;
1215     d = loc-&gt;x - x_fineparts[sv-&gt;llf.x];
1216     if (d &lt; R) {
1217       c = R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z) * m2_i;
1218       if (d * d &lt; c)
1219         p_flags |= X_NEG_BIT;
1220       d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
1221       if (d * d &lt; c)
1222         p_flags |= X_POS_BIT;
1223     } else {
1224       d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
1225       if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;z * mv-&gt;z) * m2_i)
1226         p_flags |= X_POS_BIT;
1227     }
1228     d = loc-&gt;y - y_fineparts[sv-&gt;llf.y];
1229     if (d &lt; R) {
1230       c = R2 * (mv-&gt;x * mv-&gt;x + mv-&gt;z * mv-&gt;z) * m2_i;
1231       if (d * d &lt; c)
1232         p_flags |= Y_NEG_BIT;
1233       d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
1234       if (d * d &lt; c)
1235         p_flags |= Y_POS_BIT;
1236     } else {
1237       d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
1238       if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;x * mv-&gt;x + mv-&gt;z * mv-&gt;z) * m2_i)
1239         p_flags |= Y_POS_BIT;
1240     }
1241     d = loc-&gt;z - z_fineparts[sv-&gt;llf.z];
1242     if (d &lt; R) {
1243       c = R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;x * mv-&gt;x) * m2_i;
1244       if (d * d &lt; c)
1245         p_flags |= Z_NEG_BIT;
1246       d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
1247       if (d * d &lt; c)
1248         p_flags |= Z_POS_BIT;
1249     } else {
1250       d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
1251       if (d &lt; R &amp;&amp; d * d &lt; R2 * (mv-&gt;y * mv-&gt;y + mv-&gt;x * mv-&gt;x) * m2_i)
1252         p_flags |= Z_POS_BIT;
1253     }
1254     if (p_flags) {
1255       for (i = 1; i &lt;= p_flags; i *= 2) {
1256         if ((i &amp; p_flags) != 0) {
1257           switch (i) {
1258           case X_NEG_BIT:
1259             d = x_fineparts[sv-&gt;llf.x] - loc-&gt;x;
1260             a = u.x;
1261             b = v.x;
1262             break;
1263           case X_POS_BIT:
1264             d = x_fineparts[sv-&gt;urb.x] - loc-&gt;x;
1265             a = u.x;
1266             b = v.x;
1267             break;
1268           case Y_NEG_BIT:
1269             d = y_fineparts[sv-&gt;llf.y] - loc-&gt;y;
1270             a = u.y;
1271             b = v.y;
1272             break;
1273           case Y_POS_BIT:
1274             d = y_fineparts[sv-&gt;urb.y] - loc-&gt;y;
1275             a = u.y;
1276             b = v.y;
1277             break;
1278           case Z_NEG_BIT:
1279             d = z_fineparts[sv-&gt;llf.z] - loc-&gt;z;
1280             a = u.z;
1281             b = v.z;
1282             break;
1283           case Z_POS_BIT:
1284             d = z_fineparts[sv-&gt;urb.z] - loc-&gt;z;
1285             a = u.z;
1286             b = v.z;
1287             break;
1288           default:
1289             continue;
1290           }
1291           if (!distinguishable(a, 0, EPS_C)) {
1292             s = d / b;
1293             if (s * s &gt; R2) {
1294               mcell_internal_error(
1295                   "Unexpected results in exact disk: s=%.2f s^2=%.2f R2=%.2f\n",
1296                   s, s * s, R2);
1297             }
1298             t = sqrt(R2 - s * s);
1299             pa.u = t;
1300             pa.v = s;
1301             pb.u = -t;
1302             pb.v = s;
1303           } else if (!distinguishable(b, 0, EPS_C)) {
1304             t = d / a;
1305             if (t * t &gt; R2) {
1306               mcell_internal_error(
1307                   "Unexpected results in exact disk: t=%.2f t^2=%.2f R2=%.2f\n",
1308                   t, t * t, R2);
1309             }
1310             s = sqrt(R2 - t * t);
1311             pa.u = t;
1312             pa.v = s;
1313             pb.u = t;
1314             pb.v = -s;
1315           } else {
1316             c = a * a + b * b;
1317             s = d * b;
1318             if (d * d &gt; R2 * c) {
1319               mcell_internal_error("Unexpected results in exact disk: d=%.2f "
1320                                    "d^2=%.2f R2=%.2f c=%.2f R2*c=%.2f\n",
1321                                    d, d * d, R2, c, R2 * c);
1322             }
1323             t = sqrt(R2 * c - d * d);
1324             c = 1.0 / c;
1325             r = 1.0 / a;
1326             pa.v = c * (s + t * a);
1327             pa.u = (d - b * pa.v) * r;
1328             pb.v = c * (s - t * a);
1329             pb.u = (d - b * pb.v) * r;
1330           }
1331           ppa = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1332                                                      "exact disk vertex");
1333           ppb = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1334                                                      "exact disk vertex");
1335           a = exd_zetize(pa.v, pa.u);
1336           b = exd_zetize(pb.v, pb.u);
1337           c = b - a;
1338           if (c &lt; 0)
1339             c += 4;
1340           if (c &lt; 2) {
1341             ppa-&gt;u = pa.u;
1342             ppa-&gt;v = pa.v;
1343             ppa-&gt;r2 = pa.u * pa.u + pa.v * pa.v;
1344             ppa-&gt;zeta = a;
1345             ppb-&gt;u = pb.u;
1346             ppb-&gt;v = pb.v;
1347             ppb-&gt;r2 = pb.u * pb.u + pb.v * pb.v;
1348             ppb-&gt;zeta = b;
1349           } else {
1350             ppb-&gt;u = pa.u;
1351             ppb-&gt;v = pa.v;
1352             ppb-&gt;r2 = pa.u * pa.u + pa.v * pa.v;
1353             ppb-&gt;zeta = a;
1354             ppa-&gt;u = pb.u;
1355             ppa-&gt;v = pb.v;
1356             ppa-&gt;r2 = pb.u * pb.u + pb.v * pb.v;
1357             ppa-&gt;zeta = b;
1358           }
1359           ppa-&gt;role = EXD_HEAD;
1360           ppb-&gt;role = EXD_TAIL;
1361           ppa-&gt;e = ppb;
1362           ppb-&gt;e = NULL;
1363           ppb-&gt;next = vertex_head;
1364           ppa-&gt;next = ppb;
1365           vertex_head = ppa;
1366           n_verts += 2;
1367           n_edges++;
1368         }
1369       }
1370     }
1371   }
1372   if (n_edges == 0) {
1373     return 1.0;
1374   }
1375   else if (n_edges == 1) {
1376     ppa = vertex_head;
1377     ppb = ppa-&gt;e;
1378     a = ppa-&gt;u * ppb-&gt;u + ppa-&gt;v * ppb-&gt;v;
1379     b = ppa-&gt;u * ppb-&gt;v - ppa-&gt;v * ppb-&gt;u;
1380     if (a &lt;= 0)     {
1381       s = atan(-a / b) + 0.5 * MY_PI;
1382     } else {
1383       s = atan(b / a);
1384     }
1385     A = (0.5 * b + R2 * (MY_PI - 0.5 * s)) / (MY_PI * R2);
1386     mem_put_list(sv-&gt;local_storage-&gt;exdv, vertex_head);
1387     return A;
1388   }
1389   vp = vertex_head-&gt;next;
1390   ppa = ppb = vertex_head;
1391   ppa-&gt;next = NULL;
1392   ppa-&gt;span = NULL;
1393   while (vp != NULL) {
1394     vp-&gt;span = NULL;
1395     vq = vp-&gt;next;
1396     if (vp-&gt;zeta &lt; ppa-&gt;zeta) {
1397       vp-&gt;next = ppa;
1398       ppa = vp;
1399     } else {
1400       for (pqa = ppa; pqa-&gt;next != NULL; pqa = pqa-&gt;next) {
1401         if (vp-&gt;zeta &lt; pqa-&gt;next-&gt;zeta)
1402           break;
1403       }
1404       vp-&gt;next = pqa-&gt;next;
1405       pqa-&gt;next = vp;
1406       if (vp-&gt;next == NULL)
1407         ppb = vp;
1408     }
1409     vp = vq;
1410   }
1411   vertex_head = ppa;
1412   ppb-&gt;next = ppa;
1413   ppb = NULL;
1414   for (ppa = vertex_head; ppa != vertex_head || ppb == NULL; ppa = ppa-&gt;next) {
1415     if (ppa-&gt;role != EXD_HEAD)
1416       continue;
1417     ppb = ppa-&gt;e;
1418     for (pqa = ppa-&gt;next; pqa != ppb; pqa = pqa-&gt;next) {
1419       if (pqa-&gt;role != EXD_HEAD)
1420         continue;
1421       pqb = pqa-&gt;e;
1422       pa.u = ppb-&gt;u - ppa-&gt;u;
1423       pa.v = ppb-&gt;v - ppa-&gt;v;
1424       pb.u = pqb-&gt;u - pqa-&gt;u;
1425       pb.v = pqb-&gt;v - pqa-&gt;v;
1426       r = pb.u * pa.v - pa.u * pb.v;
1427       if (r * r &lt;
1428           EPS_C * (pa.u * pa.u + pa.v * pa.v) * (pb.u * pb.u + pb.v * pb.v)) {
1429         pqa-&gt;e = NULL;
1430         pqa-&gt;role = EXD_OTHER;
1431         a = pqb-&gt;zeta - ppb-&gt;zeta;
1432         if (a &lt; 0)
1433           a += 4.0;
1434         if (a &gt; 2)         {
1435           pqb-&gt;role = EXD_OTHER;
1436         } else         {
1437           ppa-&gt;e = pqb;
1438           ppb-&gt;role = EXD_OTHER;
1439           ppb = pqb;
1440           pqa = ppa;
1441         }
1442         continue;
1443       }
1444       s = (ppa-&gt;u - pqa-&gt;u) * pa.v - (ppa-&gt;v - pqa-&gt;v) * pa.u;
1445       if (s * r &lt;= EPS_C * R2 * R2)
1446         continue;
1447       t = s / r;
1448       if (t &gt;= 1 - EPS_C)
1449         continue;
1450       if (pa.u * pa.u &gt; pa.v * pa.v) {
1451         s = (pqa-&gt;u - ppa-&gt;u + t * pb.u) * pa.u;
1452         if (s &lt;= EPS_C * R2 || s &gt;= pa.u * pa.u * (1.0 - EPS_C))
1453           continue;
1454       } else {
1455         s = (pqa-&gt;v - ppa-&gt;v + t * pb.v) * pa.v;
1456         if (s &lt;= EPS_C * R2 || s &gt;= pa.v * pa.v * (1.0 - EPS_C))
1457           continue;
1458       }
1459       vq = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1460                                                 "exact disk vertex");
1461       vq-&gt;u = pqa-&gt;u + t * pb.u;
1462       vq-&gt;v = pqa-&gt;v + t * pb.v;
1463       vq-&gt;r2 = vq-&gt;u * vq-&gt;u + vq-&gt;v * vq-&gt;v;
1464       vq-&gt;zeta = exd_zetize(vq-&gt;v, vq-&gt;u);
1465       vq-&gt;e = ppb;
1466       vq-&gt;span = NULL;
1467       vq-&gt;role = EXD_CROSS;
1468       for (vp = ppa; vp != ppb; vp = vp-&gt;next) {
1469         a = vq-&gt;zeta - vp-&gt;next-&gt;zeta;
1470         if (a &gt; 2.0)
1471           a -= 4.0;
1472         else if (a &lt; -2.0)
1473           a += 4.0;
1474         if (a &lt; 0)
1475           break;
1476       }
1477       vq-&gt;next = vp-&gt;next;
1478       vp-&gt;next = vq;
1479       if (vq-&gt;zeta &lt; vertex_head-&gt;zeta)
1480         vertex_head = vq;
1481     }
1482   }
1483   for (vp = vertex_head, vq = NULL; vq != vertex_head; vp = vq) {
1484     for (vq = vp-&gt;next; vq != vertex_head; vq = vq-&gt;next) {
1485       if (vq-&gt;zeta - vp-&gt;zeta &lt; EPS_C) {
1486         vq-&gt;zeta = vp-&gt;zeta;
1487         if (-EPS_C &lt; vq-&gt;r2 - vp-&gt;r2 &amp;&amp; EPS_C &gt; vq-&gt;r2 - vp-&gt;r2) {
1488           vq-&gt;r2 = vp-&gt;r2;
1489         }
1490       } else
1491         break;
1492     }
1493   }
1494   vq = NULL;
1495   for (vp = vertex_head; vp != vertex_head || vq == NULL; vp = vp-&gt;next) {
1496     if (vp-&gt;role != EXD_HEAD)
1497       continue;
1498     for (vq = vp-&gt;next; vq != vp-&gt;e; vq = vq-&gt;next) {
1499       if (!distinguishable(vq-&gt;zeta, vp-&gt;zeta, EPS_C))
1500         continue;
1501       if (!distinguishable(vq-&gt;zeta, vp-&gt;e-&gt;zeta, EPS_C))
1502         break;
1503       if (vq-&gt;role == EXD_OTHER)
1504         continue;
1505       vr = (struct exd_vertex *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;exdv,
1506                                                 "exact disk vertex");
1507       vr-&gt;next = vq-&gt;span;
1508       vq-&gt;span = vr;
1509       vr-&gt;e = vp;
1510       vr-&gt;zeta = vq-&gt;zeta;
1511       vr-&gt;role = EXD_SPAN;
1512     }
1513   }
1514   A = 0.0;
1515   zeta = 0.0;
1516   last_zeta = -1;
1517   vs = NULL;
1518   for (vp = vertex_head; zeta &lt; 4.0 - EPS_C; vp = vp-&gt;next) {
1519     if (vp-&gt;role == EXD_OTHER)
1520       continue;
1521     if (!distinguishable(vp-&gt;zeta, last_zeta, EPS_C))
1522       continue;
1523     last_zeta = vp-&gt;zeta;
1524     if (vs == &amp;pa)
1525       vr = &amp;pb;
1526     else
1527       vr = &amp;pa;
1528     vr-&gt;u = vp-&gt;u;
1529     vr-&gt;v = vp-&gt;v;
1530     vr-&gt;zeta = vp-&gt;zeta;
1531     if (vp-&gt;role == EXD_TAIL) {
1532       vr-&gt;r2 = R2 * (1.0 + EPS_C);
1533       vr-&gt;e = NULL;
1534     } else {
1535       vr-&gt;r2 = vp-&gt;r2;
1536       vr-&gt;e = vp-&gt;e;
1537     }
1538     for (vq = vp-&gt;next; (!distinguishable(vq-&gt;zeta, last_zeta, EPS_C));
1539          vq = vq-&gt;next) {
1540       if (vq-&gt;role == EXD_HEAD) {
1541         if (vq-&gt;r2 &lt; vp-&gt;r2 || vr-&gt;e == NULL) {
1542           vr-&gt;u = vq-&gt;u;
1543           vr-&gt;v = vq-&gt;v;
1544           vr-&gt;r2 = vq-&gt;r2;
1545           vr-&gt;e = vq-&gt;e;
1546         } else if (!distinguishable(vq-&gt;r2, vr-&gt;r2, EPS_C)) {
1547           b = EXD_SPAN_CALC(vr, vr-&gt;e, vq-&gt;e);
1548           if (b &gt; 0)
1549             vr-&gt;e = vq-&gt;e;
1550         }
1551       }
1552     }
1553     for (vq = vp-&gt;span; vq != NULL; vq = vq-&gt;next) {
1554       ppa = vq-&gt;e;
1555       ppb = ppa-&gt;e;
1556       b = EXD_SPAN_CALC(ppa, ppb, vr);
1557       c = b * b;
1558       if (c &lt; R2 * R2 * EPS_C)       {
1559         if (vr-&gt;e == NULL) {
1560           vr-&gt;r2 = vr-&gt;u * vr-&gt;u + vr-&gt;v * vr-&gt;v;
1561           vr-&gt;e = ppb;
1562         } else {
1563           b = EXD_SPAN_CALC(vr, vr-&gt;e, ppb);
1564           if (b &gt; 0)
1565             vr-&gt;e = ppb;
1566         }
1567       } else if (b &lt; 0 ||
1568                  vr-&gt;e == NULL)       {
1569         t = EXD_TIME_CALC(ppa, ppb, vp);
1570         vr-&gt;u = ppa-&gt;u + t * (ppb-&gt;u - ppa-&gt;u);
1571         vr-&gt;v = ppa-&gt;v + t * (ppb-&gt;v - ppa-&gt;v);
1572         vr-&gt;r2 = vr-&gt;u * vr-&gt;u + vr-&gt;v * vr-&gt;v;
1573         vr-&gt;e = ppb;
1574       }
1575     }
1576     if (vs == NULL)     {
1577       vs = vr;
1578     } else {
1579       c = vr-&gt;zeta - vs-&gt;zeta;
1580       if (c &lt; 0)
1581         c += 4.0;
1582         zeta += c;
1583         if (vs-&gt;e == NULL ||
1584             (vs-&gt;e-&gt;zeta - vs-&gt;zeta) * (vs-&gt;e-&gt;zeta - vs-&gt;zeta) &lt;
1585                 EPS_C * EPS_C) {
1586           if (c &gt;= 2.0)           {
1587             vs-&gt;u = -vs-&gt;u;
1588             vs-&gt;v = -vs-&gt;v;
1589             A += 0.5 * MY_PI * R2;
1590           }
1591           a = vs-&gt;u * vr-&gt;u + vs-&gt;v * vr-&gt;v;
1592           b = vs-&gt;u * vr-&gt;v - vs-&gt;v * vr-&gt;u;
1593           if (a &lt;= 0)           {
1594             s = atan(-a / b) + 0.5 * MY_PI;
1595           } else {
1596             s = atan(b / a);
1597           }
1598           A += 0.5 * s * R2;
1599         } else {
1600           if (!distinguishable(vs-&gt;e-&gt;zeta, vr-&gt;zeta, EPS_C)) {
1601             A += 0.5 * (vs-&gt;u * vs-&gt;e-&gt;v - vs-&gt;v * vs-&gt;e-&gt;u);
1602           } else {
1603             t = EXD_TIME_CALC(vs, vs-&gt;e, vr);
1604             b = vs-&gt;u + (vs-&gt;e-&gt;u - vs-&gt;u) * t;
1605             c = vs-&gt;v + (vs-&gt;e-&gt;v - vs-&gt;v) * t;
1606             A += 0.5 * (vs-&gt;u * c - vs-&gt;v * b);
1607           }
1608         }
1609         vs = vr;
1610       } else {
1611         if (vr-&gt;e != NULL)
1612           vs = vr;
1613       }
1614     }
1615   }
1616   ppa = vertex_head-&gt;next;
1617   vertex_head-&gt;next = NULL;
1618   for (ppb = ppa; ppb != NULL; ppb = ppb-&gt;next) {
1619     if (ppb-&gt;span != NULL) {
1620       struct exd_vertex *next = ppb-&gt;next;
1621       ppb-&gt;next = ppb-&gt;span;
1622       ppb-&gt;span = NULL;
1623       while (ppb-&gt;next != NULL)
1624         ppb = ppb-&gt;next;
1625       ppb-&gt;next = next;
1626     }
1627   }
1628   mem_put_list(sv-&gt;local_storage-&gt;exdv, ppa);
1629   return A / (MY_PI * R2);
1630 #undef EXD_TIME_CALC
1631 #undef EXD_SPAN_CALC
1632 }
1633 double safe_diffusion_step(struct volume_molecule *vm, struct collision *shead,
1634                            u_int radial_subdivisions, double *r_step,
1635                            double *x_fineparts, double *y_fineparts,
1636                            double *z_fineparts) {
1637   double d2;
1638   double d2_nearmax;
1639   double d2min = GIGANTIC;
1640   struct subvolume *sv = vm-&gt;subvol;
1641   struct wall *w;
1642   struct wall_list *wl;
1643   struct collision *smash;
1644   double steps;
1645   struct volume_molecule *mp;
1646   d2_nearmax = vm-&gt;get_space_step(vm) *
1647                r_step[(int)(radial_subdivisions * MULTISTEP_PERCENTILE)];
1648   d2_nearmax *= d2_nearmax;
1649   if ((vm-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) {
1650     for (smash = shead; smash != NULL; smash = smash-&gt;next) {
1651       mp = (struct volume_molecule *)smash-&gt;target;
1652       d2 = (vm-&gt;pos.x - mp-&gt;pos.x) * (vm-&gt;pos.x - mp-&gt;pos.x) +
1653            (vm-&gt;pos.y - mp-&gt;pos.y) * (vm-&gt;pos.y - mp-&gt;pos.y) +
1654            (vm-&gt;pos.z - mp-&gt;pos.z) * (vm-&gt;pos.z - mp-&gt;pos.z);
1655       if (d2 &lt; d2min)
1656         d2min = d2;
1657     }
1658   }
1659   for (wl = sv-&gt;wall_head; wl != NULL; wl = wl-&gt;next) {
1660     w = wl-&gt;this_wall;
1661     d2 = (w-&gt;normal.x * vm-&gt;pos.x + w-&gt;normal.y * vm-&gt;pos.y +
1662           w-&gt;normal.z * vm-&gt;pos.z) -
1663          w-&gt;d;
1664     d2 *= d2;
1665     if (d2 &lt; d2min)
1666       d2min = d2;
1667   }
1668   d2 = (vm-&gt;pos.x - x_fineparts[sv-&gt;llf.x]);
1669   d2 *= d2;
1670   if (d2 &lt; d2min)
1671     d2min = d2;
1672   d2 = (vm-&gt;pos.x - x_fineparts[sv-&gt;urb.x]);
1673   d2 *= d2;
1674   if (d2 &lt; d2min)
1675     d2min = d2;
1676   d2 = (vm-&gt;pos.y - y_fineparts[sv-&gt;llf.y]);
1677   d2 *= d2;
1678   if (d2 &lt; d2min)
1679     d2min = d2;
1680   d2 = (vm-&gt;pos.y - y_fineparts[sv-&gt;urb.y]);
1681   d2 *= d2;
1682   if (d2 &lt; d2min)
1683     d2min = d2;
1684   d2 = (vm-&gt;pos.z - z_fineparts[sv-&gt;llf.z]);
1685   d2 *= d2;
1686   if (d2 &lt; d2min)
1687     d2min = d2;
1688   d2 = (vm-&gt;pos.z - z_fineparts[sv-&gt;urb.z]);
1689   d2 *= d2;
1690   if (d2 &lt; d2min)
1691     d2min = d2;
1692 #ifdef MCELL3_4_SAFE_DIFF_STEP_RETURNS_CONSTANT
1693   return 1;
1694 #else
1695   if (d2min &lt; d2_nearmax)
1696     steps = 1.0;
1697   else {
1698     double steps_sq = d2min / d2_nearmax;
1699     if (steps_sq &lt; MULTISTEP_WORTHWHILE * MULTISTEP_WORTHWHILE)
1700       steps = 1.0;
1701     else
1702       steps = sqrt(steps_sq);
1703   }
1704   return steps;
1705 #endif
1706 }
1707 static struct collision *expand_collision_list_for_neighbor(struct volume *world,
1708     struct subvolume *sv, struct volume_molecule *vm, struct subvolume *new_sv,
1709     struct vector3 *path_llf, struct vector3 *path_urb,
1710     struct collision *shead1, double trim_x, double trim_y, double trim_z,
1711     double *x_fineparts, double *y_fineparts, double *z_fineparts,
1712     int rx_hashsize, struct rxn **reaction_hash) {
1713   int num_matching_rxns = 0;
1714   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
1715   struct vector3 new_sv_llf, new_sv_urb;
1716   new_sv_llf.x = x_fineparts[new_sv-&gt;llf.x];
1717   new_sv_llf.y = y_fineparts[new_sv-&gt;llf.y];
1718   new_sv_llf.z = z_fineparts[new_sv-&gt;llf.z];
1719   new_sv_urb.x = x_fineparts[new_sv-&gt;urb.x];
1720   new_sv_urb.y = y_fineparts[new_sv-&gt;urb.y];
1721   new_sv_urb.z = z_fineparts[new_sv-&gt;urb.z];
1722   if (!test_bounding_boxes(path_llf, path_urb, &amp;new_sv_llf, &amp;new_sv_urb))
1723     return shead1;
1724   double x_min, x_max;
1725   double y_min, y_max;
1726   double z_min, z_max;
1727   if (trim_x &lt; 0.0) {
1728     x_min = new_sv_urb.x + trim_x;
1729     x_max = new_sv_urb.x + EPS_C;
1730   } else if (trim_x &gt; 0.0) {
1731     x_min = new_sv_llf.x - EPS_C;
1732     x_max = new_sv_llf.x + trim_x;
1733   } else {
1734     x_min = new_sv_llf.x - EPS_C;
1735     x_max = new_sv_urb.x + EPS_C;
1736   }
1737   if (trim_y &lt; 0.0) {
1738     y_min = new_sv_urb.y + trim_y;
1739     y_max = new_sv_urb.y + EPS_C;
1740   } else if (trim_y &gt; 0.0) {
1741     y_min = new_sv_llf.y - EPS_C;
1742     y_max = new_sv_llf.y + trim_y;
1743   } else {
1744     y_min = new_sv_llf.y - EPS_C;
1745     y_max = new_sv_urb.y + EPS_C;
1746   }
1747   if (trim_z &lt; 0.0) {
1748     z_min = new_sv_urb.z + trim_z;
1749     z_max = new_sv_urb.z + EPS_C;
1750   } else if (trim_z &gt; 0.0) {
1751     z_min = new_sv_llf.z - EPS_C;
1752     z_max = new_sv_llf.z + trim_z;
1753   } else {
1754     z_min = new_sv_llf.z - EPS_C;
1755     z_max = new_sv_urb.z + EPS_C;
1756   }
1757   struct per_species_list *psl_next, *psl, **psl_head = &amp;new_sv-&gt;species_head;
1758   for (psl = new_sv-&gt;species_head; psl != NULL; psl = psl_next) {
1759     psl_next = psl-&gt;next;
1760     if (psl-&gt;properties == NULL) {
1761       psl_head = &amp;psl-&gt;next;
1762       continue;
1763     }
1764     if (psl-&gt;head == NULL) {
1765       *psl_head = psl-&gt;next;
1766       ht_remove(&amp;new_sv-&gt;mol_by_species, psl);
1767       mem_put(new_sv-&gt;local_storage-&gt;pslv, psl);
1768       continue;
1769     } else
1770       psl_head = &amp;psl-&gt;next;
1771     if(vm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
1772       if(!trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)vm, (struct abstract_molecule *)psl-&gt;head))
1773         continue;
1774     }
1775     else{
1776     if (!trigger_bimolecular_preliminary(
1777              reaction_hash, rx_hashsize, vm-&gt;properties-&gt;hashval,
1778              psl-&gt;properties-&gt;hashval, vm-&gt;properties, psl-&gt;properties))
1779       continue;
1780     }
1781     for (struct volume_molecule *mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
1782       if (mp-&gt;properties == NULL)
1783         continue;
1784       if (mp-&gt;pos.x &lt; x_min || mp-&gt;pos.x &gt; x_max)
1785         continue;
1786       if (mp-&gt;pos.y &lt; y_min || mp-&gt;pos.y &gt; y_max)
1787         continue;
1788       if (mp-&gt;pos.z &lt; z_min || mp-&gt;pos.z &gt; z_max)
1789         continue;
1790       if (!periodic_boxes_are_identical(vm-&gt;periodic_box, mp-&gt;periodic_box)) {
1791         continue;
1792       }
1793         if(vm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
1794           num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)vm,
1795             (struct abstract_molecule *)mp, 0, 0, matching_rxns);
1796         } 
1797         else{     
1798           num_matching_rxns = trigger_bimolecular(
1799               reaction_hash, rx_hashsize, vm-&gt;properties-&gt;hashval,
1800               mp-&gt;properties-&gt;hashval, (struct abstract_molecule *)vm,
1801               (struct abstract_molecule *)mp, 0, 0, matching_rxns);
1802         }
1803       if (num_matching_rxns &lt;= 0)
1804         continue;
1805       for (int i = 0; i &lt; num_matching_rxns; i++) {
1806         struct collision *smash = (struct collision *)CHECKED_MEM_GET(
1807             sv-&gt;local_storage-&gt;coll, "collision data");
1808         smash-&gt;target = (void *)mp;
1809         smash-&gt;intermediate = matching_rxns[i];
1810         smash-&gt;next = shead1;
1811         smash-&gt;what = 0;
1812         smash-&gt;what |= COLLIDE_VOL;
1813         shead1 = smash;
1814       }
1815     }
1816   }
1817   return shead1;
1818 }
1819 static struct collision *
1820 expand_collision_list(struct volume *world, struct volume_molecule *vm, struct vector3 *mv,
1821                       struct subvolume *sv, double rx_radius_3d,
1822                       int ny_parts, int nz_parts, double *x_fineparts,
1823                       double *y_fineparts, double *z_fineparts, int rx_hashsize,
1824                       struct rxn **reaction_hash) {
1825   struct collision *shead1 = NULL;
1826   struct vector3 path_llf, path_urb;
1827   double R = (rx_radius_3d);
1828   path_bounding_box(&amp;vm-&gt;pos, mv, &amp;path_llf, &amp;path_urb, rx_radius_3d);
1829   int x_neg = 0, x_pos = 0, y_neg = 0, y_pos = 0, z_neg = 0, z_pos = 0;
1830   if (!(sv-&gt;world_edge &amp; X_POS_BIT) &amp;&amp; path_urb.x + R &gt; x_fineparts[sv-&gt;urb.x])
1831     x_pos = 1;
1832   if (!(sv-&gt;world_edge &amp; X_NEG_BIT) &amp;&amp; path_llf.x - R &lt; x_fineparts[sv-&gt;llf.x])
1833     x_neg = 1;
1834   if (!(sv-&gt;world_edge &amp; Y_POS_BIT) &amp;&amp; path_urb.y + R &gt; y_fineparts[sv-&gt;urb.y])
1835     y_pos = 1;
1836   if (!(sv-&gt;world_edge &amp; Y_NEG_BIT) &amp;&amp; path_llf.y - R &lt; y_fineparts[sv-&gt;llf.y])
1837     y_neg = 1;
1838   if (!(sv-&gt;world_edge &amp; Z_POS_BIT) &amp;&amp; path_urb.z + R &gt; z_fineparts[sv-&gt;urb.z])
1839     z_pos = 1;
1840   if (!(sv-&gt;world_edge &amp; Z_NEG_BIT) &amp;&amp; path_llf.z - R &lt; z_fineparts[sv-&gt;llf.z])
1841     z_neg = 1;
1842   if (x_pos) {
1843     struct subvolume *new_sv = sv + (nz_parts - 1) * (ny_parts - 1);
1844     shead1 = expand_collision_list_for_neighbor(world,
1845         sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, 0.0, x_fineparts,
1846         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1847     if (y_pos) {
1848       struct subvolume *new_sv_y = new_sv + (nz_parts - 1);
1849       shead1 = expand_collision_list_for_neighbor(world,
1850           sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, R, R, 0.0, x_fineparts,
1851           y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1852       if (z_pos)
1853         shead1 = expand_collision_list_for_neighbor(world,
1854             sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, R, R, R,
1855             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1856       if (z_neg)
1857         shead1 = expand_collision_list_for_neighbor(world,
1858             sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, R, R, -R,
1859             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1860     }
1861     if (y_neg) {
1862       struct subvolume *new_sv_y = new_sv - (nz_parts - 1);
1863       shead1 = expand_collision_list_for_neighbor(world,
1864           sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, R, -R, 0.0,
1865           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1866       if (z_pos)
1867         shead1 = expand_collision_list_for_neighbor(world,
1868             sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, R, -R, R,
1869             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1870       if (z_neg)
1871         shead1 = expand_collision_list_for_neighbor(world,
1872             sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, R, -R, -R,
1873             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1874     }
1875     if (z_pos)
1876       shead1 = expand_collision_list_for_neighbor(world,
1877           sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, R,
1878           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1879     if (z_neg)
1880       shead1 = expand_collision_list_for_neighbor(world,
1881           sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, R, 0.0, -R,
1882           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1883   }
1884   if (x_neg) {
1885     struct subvolume *new_sv = sv - (nz_parts - 1) * (ny_parts - 1);
1886     shead1 = expand_collision_list_for_neighbor(world,
1887         sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, 0.0, x_fineparts,
1888         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1889     if (y_pos) {
1890       struct subvolume *new_sv_y = new_sv + (nz_parts - 1);
1891       shead1 = expand_collision_list_for_neighbor(world,
1892           sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, -R, R, 0.0,
1893           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1894       if (z_pos)
1895         shead1 = expand_collision_list_for_neighbor(world,
1896             sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, -R, R, R,
1897             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1898       if (z_neg)
1899         shead1 = expand_collision_list_for_neighbor(world,
1900             sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, -R, R, -R,
1901             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1902     }
1903     if (y_neg) {
1904       struct subvolume *new_sv_y = new_sv - (nz_parts - 1);
1905       shead1 = expand_collision_list_for_neighbor(world,
1906           sv, vm, new_sv_y, &amp;path_llf, &amp;path_urb, shead1, -R, -R, 0.0,
1907           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1908       if (z_pos)
1909         shead1 = expand_collision_list_for_neighbor(world,
1910             sv, vm, new_sv_y + 1, &amp;path_llf, &amp;path_urb, shead1, -R, -R, R,
1911             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1912       if (z_neg)
1913         shead1 = expand_collision_list_for_neighbor(world,
1914             sv, vm, new_sv_y - 1, &amp;path_llf, &amp;path_urb, shead1, -R, -R, -R,
1915             x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1916     }
1917     if (z_pos)
1918       shead1 = expand_collision_list_for_neighbor(world,
1919           sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, R,
1920           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1921     if (z_neg)
1922       shead1 = expand_collision_list_for_neighbor(world,
1923           sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, -R, 0.0, -R,
1924           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1925   }
1926   if (y_pos) {
1927     struct subvolume *new_sv = sv + (nz_parts - 1);
1928     shead1 = expand_collision_list_for_neighbor(world,
1929         sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, 0.0, x_fineparts,
1930         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1931     if (z_pos)
1932       shead1 = expand_collision_list_for_neighbor(world,
1933           sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, R,
1934           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1935     if (z_neg)
1936       shead1 = expand_collision_list_for_neighbor(world,
1937           sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, R, -R,
1938           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1939   }
1940   if (y_neg) {
1941     struct subvolume *new_sv = sv - (nz_parts - 1);
1942     shead1 = expand_collision_list_for_neighbor(world,
1943         sv, vm, new_sv, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, 0.0, x_fineparts,
1944         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1945     if (z_pos)
1946       shead1 = expand_collision_list_for_neighbor(world,
1947           sv, vm, new_sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, R,
1948           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1949     if (z_neg)
1950       shead1 = expand_collision_list_for_neighbor(world,
1951           sv, vm, new_sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, -R, -R,
1952           x_fineparts, y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1953   }
1954   if (z_pos)
1955     shead1 = expand_collision_list_for_neighbor(world,
1956         sv, vm, sv + 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, 0.0, R, x_fineparts,
1957         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1958   if (z_neg)
1959     shead1 = expand_collision_list_for_neighbor(world,
1960         sv, vm, sv - 1, &amp;path_llf, &amp;path_urb, shead1, 0.0, 0.0, -R, x_fineparts,
1961         y_fineparts, z_fineparts, rx_hashsize, reaction_hash);
1962   return shead1;
1963 }
1964 struct sp_collision *expand_collision_partner_list_for_neighbor(
1965     struct subvolume *sv, struct volume_molecule *vm, struct vector3 *mv,
1966     struct subvolume *new_sv, struct vector3 *path_llf,
1967     struct vector3 *path_urb, struct sp_collision *shead1, double trim_x,
1968     double trim_y, double trim_z, double *x_fineparts, double *y_fineparts,
1969     double *z_fineparts, int rx_hashsize, struct rxn **reaction_hash) {
1970   struct species *spec = vm-&gt;properties;
1971   struct sp_collision *smash;
1972   struct vector3 new_sv_llf, new_sv_urb;
1973   new_sv_llf.x = x_fineparts[new_sv-&gt;llf.x];
1974   new_sv_llf.y = y_fineparts[new_sv-&gt;llf.y];
1975   new_sv_llf.z = z_fineparts[new_sv-&gt;llf.z];
1976   new_sv_urb.x = x_fineparts[new_sv-&gt;urb.x];
1977   new_sv_urb.y = y_fineparts[new_sv-&gt;urb.y];
1978   new_sv_urb.z = z_fineparts[new_sv-&gt;urb.z];
1979   if (!test_bounding_boxes(path_llf, path_urb, &amp;new_sv_llf, &amp;new_sv_urb))
1980     return shead1;
1981   int moving_tri_molecular_flag = 0, moving_bi_molecular_flag = 0,
1982       moving_mol_mol_grid_flag = 0;
1983   int col_tri_molecular_flag = 0, col_bi_molecular_flag = 0,
1984       col_mol_mol_grid_flag = 0;
1985   moving_tri_molecular_flag =
1986       ((spec-&gt;flags &amp; (CAN_VOLVOLVOL | CANT_INITIATE)) == CAN_VOLVOLVOL);
1987   moving_bi_molecular_flag =
1988       ((spec-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL);
1989   moving_mol_mol_grid_flag =
1990       ((spec-&gt;flags &amp; (CAN_VOLVOLSURF | CANT_INITIATE)) == CAN_VOLVOLSURF);
1991   double x_min, x_max;
1992   double y_min, y_max;
1993   double z_min, z_max;
1994   if (trim_x &lt; 0.0) {
1995     x_min = new_sv_urb.x + trim_x;
1996     x_max = new_sv_urb.x + EPS_C;
1997   } else if (trim_x &gt; 0.0) {
1998     x_min = new_sv_llf.x - EPS_C;
1999     x_max = new_sv_llf.x + trim_x;
2000   } else {
2001     x_min = new_sv_llf.x - EPS_C;
2002     x_max = new_sv_urb.x + EPS_C;
2003   }
2004   if (trim_y &lt; 0.0) {
2005     y_min = new_sv_urb.y + trim_y;
2006     y_max = new_sv_urb.y + EPS_C;
2007   } else if (trim_y &gt; 0.0) {
2008     y_min = new_sv_llf.y - EPS_C;
2009     y_max = new_sv_llf.y + trim_y;
2010   } else {
2011     y_min = new_sv_llf.y - EPS_C;
2012     y_max = new_sv_urb.y + EPS_C;
2013   }
2014   if (trim_z &lt; 0.0) {
2015     z_min = new_sv_urb.z + trim_z;
2016     z_max = new_sv_urb.z + EPS_C;
2017   } else if (trim_z &gt; 0.0) {
2018     z_min = new_sv_llf.z - EPS_C;
2019     z_max = new_sv_llf.z + trim_z;
2020   } else {
2021     z_min = new_sv_llf.z - EPS_C;
2022     z_max = new_sv_urb.z + EPS_C;
2023   }
2024   struct per_species_list *psl_next, *psl, **psl_head = &amp;new_sv-&gt;species_head;
2025   for (psl = new_sv-&gt;species_head; psl != NULL; psl = psl_next) {
2026     psl_next = psl-&gt;next;
2027     if (psl-&gt;properties == NULL) {
2028       psl_head = &amp;psl-&gt;next;
2029       continue;
2030     }
2031     if (psl-&gt;head == NULL) {
2032       *psl_head = psl-&gt;next;
2033       ht_remove(&amp;new_sv-&gt;mol_by_species, psl);
2034       mem_put(new_sv-&gt;local_storage-&gt;pslv, psl);
2035       continue;
2036     } else
2037       psl_head = &amp;psl-&gt;next;
2038     int preliminary_check = 0;
2039     if(spec-&gt;flags &amp; EXTERNAL_SPECIES){
2040         preliminary_check =trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)vm, 
2041                                                                  (struct abstract_molecule *)psl-&gt;head);
2042     }
2043     else{
2044         preliminary_check = trigger_bimolecular_preliminary(reaction_hash, rx_hashsize,
2045                                         spec-&gt;hashval, psl-&gt;properties-&gt;hashval,
2046                                         spec, psl-&gt;properties);
2047     }
2048     col_tri_molecular_flag =
2049         moving_tri_molecular_flag &amp;&amp;
2050         ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOLVOL) == CAN_VOLVOLVOL);
2051     col_bi_molecular_flag =
2052         moving_bi_molecular_flag &amp;&amp;
2053         ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOL) == CAN_VOLVOL) &amp;&amp; preliminary_check;
2054     col_mol_mol_grid_flag =
2055         moving_mol_mol_grid_flag &amp;&amp;
2056         ((psl-&gt;properties-&gt;flags &amp; CAN_VOLVOLSURF) == CAN_VOLVOLSURF);
2057     if (col_bi_molecular_flag || col_tri_molecular_flag ||
2058         col_mol_mol_grid_flag) {
2059       struct volume_molecule *mp;
2060       for (mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
2061         if (mp-&gt;properties == NULL)
2062           continue;
2063         if (mp-&gt;pos.x &lt; x_min || mp-&gt;pos.x &gt; x_max)
2064           continue;
2065         if (mp-&gt;pos.y &lt; y_min || mp-&gt;pos.y &gt; y_max)
2066           continue;
2067         if (mp-&gt;pos.z &lt; z_min || mp-&gt;pos.z &gt; z_max)
2068           continue;
2069         smash = (struct sp_collision *)CHECKED_MEM_GET(
2070             sv-&gt;local_storage-&gt;sp_coll, "collision data");
2071         smash-&gt;t = 0.0;
2072         smash-&gt;t_start = 0.0;
2073         smash-&gt;pos_start.x = vm-&gt;pos.x;
2074         smash-&gt;pos_start.y = vm-&gt;pos.y;
2075         smash-&gt;pos_start.z = vm-&gt;pos.z;
2076         smash-&gt;sv_start = sv;
2077         smash-&gt;disp.x = mv-&gt;x;
2078         smash-&gt;disp.y = mv-&gt;y;
2079         smash-&gt;disp.z = mv-&gt;z;
2080         smash-&gt;loc.x = 0.0;
2081         smash-&gt;loc.y = 0.0;
2082         smash-&gt;loc.z = 0.0;
2083         smash-&gt;moving = spec;
2084         smash-&gt;target = (void *)mp;
2085         smash-&gt;what = 0;
2086         if (col_bi_molecular_flag) {
2087           smash-&gt;what |= COLLIDE_VOL;
2088         }
2089         if (col_tri_molecular_flag) {
2090           smash-&gt;what |= COLLIDE_VOL_VOL;
2091         }
2092         if (col_mol_mol_grid_flag) {
2093           smash-&gt;what |= COLLIDE_VOL_SURF;
2094         }
2095         smash-&gt;next = shead1;
2096         shead1 = smash;
2097       }
2098     }
2099   }
2100   return shead1;
2101 }
2102 struct volume_molecule *diffuse_3D(
2103     struct volume *world,
2104     struct volume_molecule *vm,
2105     double max_time) {
2106   world-&gt;diffuse_3d_calls++;
2107   struct species* spec = vm-&gt;properties;
2108   if (spec == NULL) {
2109     mcell_internal_error(
2110         "Attempted to take a diffusion step for a defunct molecule.");
2111   }
2112   int mol_grid_flag = ((spec-&gt;flags &amp; CAN_VOLSURF) == CAN_VOLSURF);
2113   int mol_grid_grid_flag = ((spec-&gt;flags &amp; CAN_VOLSURFSURF) == CAN_VOLSURFSURF);
2114   if (vm-&gt;get_space_step(vm) &lt;= 0.0) {
2115     vm-&gt;t += max_time;
2116     return vm;
2117   }
2118 #ifdef DEBUG_DIFFUSION
2119   DUMP_CONDITION3(
2120   		dump_volume_molecule(vm, "", true, "Diffusing vm:", world-&gt;current_iterations, vm-&gt;t, true);
2121   );
2122 #endif
2123   int inertness = 0;
2124   set_inertness_and_maxtime(world, vm, &amp;max_time, &amp;inertness);
2125   ASSERT_FOR_MCELL4(inertness == 0);
2126   int calculate_displacement = 1;
2127   int redo_expand_collision_list_flag = 0;
2128   double steps = 1.0;
2129   double t_steps = 1.0;
2130   double rate_factor = 1.0;
2131   double r_rate_factor = 1.0;
2132   struct vector3 displacement;    struct vector3 displacement2; 
2133   bool displacement_printed = false;   bool timing_printed = false; 
2134 pretend_to_call_diffuse_3D: ; 
2135   struct subvolume *sv = vm-&gt;subvol;
2136   if ((spec-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL &amp;&amp;
2137       inertness &lt; inert_to_all) {
2138     determine_mol_mol_reactions(world, vm, &amp;shead, &amp;stail, inertness);
2139   }
2140   if (calculate_displacement) {
2141     compute_displacement(world, shead, vm, &amp;displacement, &amp;displacement2,
2142       &amp;rate_factor, &amp;r_rate_factor, &amp;steps, &amp;t_steps, max_time);
2143   }
2144 #ifdef DEBUG_TIMING
2145   DUMP_CONDITION3(
2146       if (!timing_printed) {
2147         MCell::dump_vol_mol_timing(
2148             "- Timing vm", world-&gt;current_iterations, vm-&gt;id,
2149             vm-&gt;t, max_time, vm-&gt;t + vm-&gt;t2,
2150             rate_factor, r_rate_factor, steps, t_steps
2151         );
2152         timing_printed = true;
2153       }
2154   );
2155 #endif
2156 #ifdef DEBUG_DIFFUSION
2157   DUMP_CONDITION3(
2158 		if (!displacement_printed) {
2159 			dump_vector3(displacement, "  displacement:");
2160             std::cout &lt;&lt; "t_steps: " &lt;&lt; t_steps &lt;&lt; "\n";
2161 			displacement_printed = true;
2162 		}
2163   );
2164 #endif
2165   if (world-&gt;use_expanded_list &amp;&amp;
2166       ((vm-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) &amp;&amp;
2167       !inertness) {
2168     shead_exp = expand_collision_list(world,
2169       vm, &amp;displacement, sv, world-&gt;rx_radius_3d, world-&gt;ny_parts,
2170       world-&gt;nz_parts, world-&gt;x_fineparts, world-&gt;y_fineparts,
2171       world-&gt;z_fineparts, world-&gt;rx_hashsize, world-&gt;reaction_hash);
2172     if (stail != NULL)
2173       stail-&gt;next = shead_exp;
2174     else {
2175       if (shead != NULL)
2176         mcell_internal_error("Collision lists corrupted.  While expanding the "
2177                              "collision lists, expected shead to be NULL, but "
2178                              "it wasn't.");
2179       shead = shead_exp;
2180     }
2181   }
2182   struct wall* reflectee = NULL;
2183   struct collision *smash;        do {
2184     if (world-&gt;use_expanded_list &amp;&amp; redo_expand_collision_list_flag) {
2185       redo_collision_list(world, &amp;shead, &amp;stail, &amp;shead_exp, vm, &amp;displacement, sv);
2186     }
2187     struct collision* shead2 = ray_trace(world, &amp;(vm-&gt;pos), shead, sv, &amp;displacement, reflectee);
2188     if (shead2 == NULL) {
2189       mcell_internal_error("ray_trace returned NULL.");
2190     }
2191     if (shead2-&gt;next != NULL) {
2192       shead2 =
2193           (struct collision *)ae_list_sort((struct abstract_element *)shead2);
2194     }
2195 #ifdef DEBUG_COLLISIONS
2196     DUMP_CONDITION3(
2197     		dump_collisions(shead2);
2198     );
2199 #endif
2200     struct vector3* loc_certain = NULL;
2201     struct collision *tentative = shead2;
2202     for (smash = shead2; smash != NULL; smash = smash-&gt;next) {
2203       if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) {
2204         if (((smash-&gt;what &amp; COLLIDE_VOL) != 0) &amp;&amp;
2205             (world-&gt;rxn_flags.vol_vol_reaction_flag)) {
2206           world-&gt;vol_vol_colls++;
2207         }
2208       }
2209       if (smash-&gt;t &gt;= 1.0 || smash-&gt;t &lt; 0.0) {
2210         if ((smash-&gt;what &amp; COLLIDE_VOL) != 0) {
2211           mcell_internal_error(
2212               "Detected a mol-mol collision outside of the 0.0...1.0 time "
2213               "window.  Iteration %lld, time of collision %.8e, mol1=%s, "
2214               "mol2=%s",
2215               world-&gt;current_iterations, smash-&gt;t, vm-&gt;properties-&gt;sym-&gt;name,
2216               ((struct volume_molecule *)smash-&gt;target)-&gt;properties-&gt;sym-&gt;name);
2217         }
2218         smash = NULL;
2219         break;
2220       }
2221       if ((smash-&gt;what &amp; COLLIDE_VOL) != 0) {
2222         if (smash-&gt;t &lt; EPS_C) {
2223           continue;
2224         }
2225         if (collide_and_react_with_vol_mol(world, smash, vm, &amp;tentative,
2226           &amp;displacement, loc_certain, t_steps, r_rate_factor) == 1) {
2227           FREE_COLLISION_LISTS();
2228           return NULL;
2229         } else {
2230           continue;
2231         }
2232       } else if ((smash-&gt;what &amp; COLLIDE_WALL) != 0) {
2233         struct wall* w = (struct wall *)smash-&gt;target;
2234         if (w-&gt;grid != NULL &amp;&amp; (mol_grid_flag || mol_grid_grid_flag) &amp;&amp;
2235           inertness &lt; inert_to_all) {
2236           int destroyed = collide_and_react_with_surf_mol(world, smash, vm,
2237             &amp;tentative, &amp;loc_certain, t_steps, mol_grid_flag, mol_grid_grid_flag,
2238             r_rate_factor);
2239           if (destroyed == 1) {
2240             FREE_COLLISION_LISTS();
2241             return NULL;
2242           } else if (destroyed == 0) {
2243             continue;
2244           }
2245         }
2246         if ((spec-&gt;flags &amp; CAN_VOLWALL) != 0) {
2247           int destroyed = collide_and_react_with_walls(world, smash, vm,
2248             &amp;tentative, &amp;loc_certain, t_steps, inertness, r_rate_factor);
2249           if (destroyed == 1) {
2250             FREE_COLLISION_LISTS();
2251             return NULL;
2252           } else if (destroyed == 0) {
2253             continue;
2254           }
2255         }
2256         if (reflect_or_periodic_bc(world, smash, &amp;displacement, &amp;vm, &amp;reflectee,
2257             &amp;tentative, &amp;t_steps) == 1) {
2258           FREE_COLLISION_LISTS();
2259           calculate_displacement = 0;
2260           if (vm-&gt;properties == NULL) {
2261             mcell_internal_error("A defunct molecule is diffusing.");
2262           }
2263           goto pretend_to_call_diffuse_3D;
2264         }
2265         redo_expand_collision_list_flag = 1; 
2266         break;
2267       } else if ((smash-&gt;what &amp; COLLIDE_SUBVOL) != 0) {
2268         collide_and_react_with_subvol(
2269           world, smash, &amp;displacement, &amp;vm, &amp;tentative, &amp;t_steps);
2270         FREE_COLLISION_LISTS();
2271         calculate_displacement = 0;
2272         if (vm-&gt;properties == NULL) {
2273           mcell_internal_error("A defunct molecule is diffusing.");
2274         }
2275         goto pretend_to_call_diffuse_3D;
2276       }
2277     }
2278     if (shead2 != NULL) {
2279       mem_put_list(sv-&gt;local_storage-&gt;coll, shead2);
2280     }
2281   } while (smash != NULL);
2282   vm-&gt;pos.x += displacement.x;
2283   vm-&gt;pos.y += displacement.y;
2284   vm-&gt;pos.z += displacement.z;
2285   vm-&gt;t += t_steps;
2286   if (inertness == inert_to_all) 
2287   {
2288     inertness = inert_to_mol;
2289     t_steps = vm-&gt;get_time_step(vm);
2290     displacement = displacement2;
2291     calculate_displacement = 0;
2292     goto pretend_to_call_diffuse_3D;
2293   }
2294   vm-&gt;index = -1;
2295   vm-&gt;previous_wall = NULL;
2296   if (shead != NULL)
2297     mem_put_list(sv-&gt;local_storage-&gt;coll, shead);
2298 #ifdef DEBUG_DIFFUSION
2299   if (vm-&gt;properties != NULL) {
2300     DUMP_CONDITION3(
2301     );
2302   }
2303 #endif
2304   return vm;
2305 }
2306 int move_sm_on_same_triangle(
2307     struct volume *state,
2308     struct surface_molecule *sm,
2309     struct vector2 *new_loc,
2310     struct periodic_image *previous_box,
2311     struct wall *new_wall,
2312     struct hit_data *hd_info) {
2313   unsigned int new_idx = uv2grid(new_loc, new_wall-&gt;grid);
2314   if (new_idx &gt;= sm-&gt;grid-&gt;n_tiles) {
2315     mcell_internal_error("After ray_trace_2D, selected u, v coordinates "
2316                          "map to an out-of-bounds grid cell.  uv=(%.2f, "
2317                          "%.2f) sm=%d/%d",
2318                          new_loc-&gt;u, new_loc-&gt;v, new_idx, sm-&gt;grid-&gt;n_tiles);
2319   }
2320   struct surface_molecule_list *sm_list = sm-&gt;grid-&gt;sm_list[new_idx];
2321   if (new_idx != sm-&gt;grid_index) {
2322     if ((state-&gt;periodic_box_obj &amp;&amp; periodicbox_in_surfmol_list(sm-&gt;periodic_box, sm_list)) ||
2323         (!state-&gt;periodic_box_obj &amp;&amp; sm_list &amp;&amp; sm_list-&gt;sm)) {
2324       if (hd_info != NULL) {
2325         delete_void_list((struct void_list *)hd_info);
2326         hd_info = NULL;
2327       }
2328       return 1;     }
2329     remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
2330     sm-&gt;grid_index = new_idx;
2331     sm-&gt;grid-&gt;sm_list[new_idx] = add_surfmol_with_unique_pb_to_list(
2332       sm-&gt;grid-&gt;sm_list[new_idx], sm);
2333     assert(sm-&gt;grid-&gt;sm_list[new_idx] != NULL);
2334     count_moved_surface_mol(
2335       state, sm, sm-&gt;grid, new_loc, state-&gt;count_hashmask,
2336       state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
2337   } else {
2338     count_moved_surface_mol(
2339       state, sm, sm-&gt;grid, new_loc, state-&gt;count_hashmask,
2340       state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
2341   }
2342   sm-&gt;s_pos.u = new_loc-&gt;u;
2343   sm-&gt;s_pos.v = new_loc-&gt;v;
2344   return 0;
2345 }
2346 int move_sm_to_new_triangle(
2347     struct volume *state,
2348     struct surface_molecule *sm,
2349     struct vector2 *new_loc,
2350     struct periodic_image *previous_box,
2351     struct wall *new_wall,
2352     struct hit_data *hd_info) {
2353   if (new_wall-&gt;grid == NULL) {
2354     if (create_grid(state, new_wall, NULL))
2355       mcell_allocfailed("Failed to create a grid for a wall.");
2356   }
2357   unsigned int new_idx = uv2grid(new_loc, new_wall-&gt;grid);
2358   if (new_idx &gt;= new_wall-&gt;grid-&gt;n_tiles) {
2359     mcell_internal_error(
2360         "After ray_trace_2D to a new wall, selected u, v coordinates map "
2361         "to an out-of-bounds grid cell.  uv=(%.2f, %.2f) sm=%d/%d",
2362         new_loc-&gt;u, new_loc-&gt;v, new_idx, new_wall-&gt;grid-&gt;n_tiles);
2363   }
2364   struct surface_molecule_list *sm_list = new_wall-&gt;grid-&gt;sm_list[new_idx];
2365   if ((state-&gt;periodic_box_obj &amp;&amp; periodicbox_in_surfmol_list(sm-&gt;periodic_box, sm_list)) ||
2366       (!state-&gt;periodic_box_obj &amp;&amp; sm_list &amp;&amp; sm_list-&gt;sm)) {
2367     if (hd_info != NULL) {
2368       delete_void_list((struct void_list *)hd_info);
2369       hd_info = NULL;
2370     }
2371     return 1;   }
2372   count_moved_surface_mol(
2373     state, sm, new_wall-&gt;grid, new_loc, state-&gt;count_hashmask,
2374     state-&gt;count_hash, &amp;state-&gt;ray_polygon_colls, previous_box);
2375   remove_surfmol_from_list(&amp;sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index], sm);
2376   sm-&gt;grid-&gt;n_occupied--;
2377   sm-&gt;grid = new_wall-&gt;grid;
2378   sm-&gt;grid_index = new_idx;
2379   sm_list = add_surfmol_with_unique_pb_to_list(sm-&gt;grid-&gt;sm_list[new_idx], sm);
2380   assert(sm_list != NULL);
2381   sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index] = sm_list;
2382   sm-&gt;grid-&gt;n_occupied++;
2383   sm-&gt;s_pos.u = new_loc-&gt;u;
2384   sm-&gt;s_pos.v = new_loc-&gt;v;
2385   return 0;
2386 }
2387 struct surface_molecule *diffuse_2D(
2388     struct volume *world,
2389     struct surface_molecule *sm,
2390     double max_time,
2391     double *advance_time) {
2392   struct species *spec = sm-&gt;properties;
2393   if (spec == NULL) {
2394     mcell_internal_error(
2395         "Attempted to take a 2-D diffusion step for a defunct molecule.");
2396   }
2397 #ifdef DEBUG_DIFFUSION
2398   DUMP_CONDITION3(
2399       dump_surface_molecule(sm, "", true, "Diffusing sm:", world-&gt;current_iterations, sm-&gt;t, true);
2400   );
2401 #endif
2402   if (sm-&gt;get_space_step(sm) &lt;= 0.0) {
2403     sm-&gt;t += max_time;
2404     return sm;
2405   }
2406   if (sm-&gt;get_time_step(sm) &gt; 1.0) {
2407     double sched_time = convert_iterations_to_seconds(
2408         world-&gt;start_iterations, world-&gt;time_unit,
2409         world-&gt;simulation_start_seconds, sm-&gt;t);
2410     double f = 1 + 0.2 * ((sched_time - sm-&gt;birthday)/world-&gt;time_unit);
2411     if (f &lt; 1)
2412       mcell_internal_error("A %s molecule is scheduled to move before it was "
2413                            "born [birthday=%.15g, t=%.15g]",
2414                            spec-&gt;sym-&gt;name, sm-&gt;birthday, sched_time);
2415     if (max_time &gt; f)
2416       max_time = f;
2417   }
2418   double steps = 0.0;
2419   double t_steps = 0.0;
2420   double space_factor = 0.0;
2421   if (sm-&gt;get_time_step(sm) &gt; max_time) {
2422     t_steps = max_time;
2423     steps = max_time / sm-&gt;get_time_step(sm);
2424   } else {
2425     t_steps = sm-&gt;get_time_step(sm);
2426     steps = 1.0;
2427   }
2428   if (steps &lt; EPS_C) {
2429     steps = EPS_C;
2430     t_steps = EPS_C * sm-&gt;get_time_step(sm);
2431   }
2432   if (steps == 1.0)
2433     space_factor = sm-&gt;get_space_step(sm);
2434   else
2435     space_factor = sm-&gt;get_space_step(sm) * sqrt(steps);
2436 #ifdef DEBUG_TIMING
2437   DUMP_CONDITION3(
2438       MCell::dump_surf_mol_timing(
2439           "- Timing sm", world-&gt;current_iterations, sm-&gt;id,
2440           sm-&gt;t, max_time, sm-&gt;t + sm-&gt;t2,
2441           space_factor, steps, t_steps
2442       );   );
2443 #endif
2444   world-&gt;diffusion_number++;
2445   world-&gt;diffusion_cumtime += steps;
2446   struct periodic_image previous_box = {sm-&gt;periodic_box-&gt;x,
2447                                         sm-&gt;periodic_box-&gt;y,
2448                                         sm-&gt;periodic_box-&gt;z
2449                                        };
2450   struct hit_data *hd_info = NULL;
2451   for (int find_new_position = (SURFACE_DIFFUSION_RETRIES + 1);
2452        find_new_position &gt; 0; find_new_position--) {
2453     hd_info = NULL;
2454     struct vector2 displacement;
2455     pick_2D_displacement(&amp;displacement, space_factor, world-&gt;rng);
2456 #ifdef DEBUG_DIFFUSION
2457     DUMP_CONDITION3(
2458         dump_vector2(displacement, "  displacement:")
2459     );
2460 #endif
2461     if (sm-&gt;properties-&gt;flags &amp; SET_MAX_STEP_LENGTH) {
2462       double disp_length = sqrt(displacement.u * displacement.u +
2463                          displacement.v * displacement.v);
2464       if (disp_length &gt; sm-&gt;properties-&gt;max_step_length) {
2465         displacement.u *= (sm-&gt;properties-&gt;max_step_length / disp_length);
2466         displacement.v *= (sm-&gt;properties-&gt;max_step_length / disp_length);
2467       }
2468     }
2469     struct vector2 new_loc;
2470     struct rxn *rxp = NULL;
2471     int kill_me = 0;
2472     struct wall *new_wall = ray_trace_2D(world, sm, &amp;displacement, &amp;new_loc,
2473       &amp;kill_me, &amp;rxp, &amp;hd_info);
2474     if (new_wall == NULL) {
2475       if (kill_me == 1) {
2476         if (rxp == NULL) {
2477           mcell_internal_error("Error in 'ray_trace_2D()' after hitting "
2478                                "ABSORPTIVE region border.");
2479         }
2480         if (hd_info != NULL) {
2481           count_region_border_update(world, sm-&gt;properties, hd_info, sm-&gt;id);
2482         }
2483         int result = outcome_unimolecular(world, rxp, 0,
2484                                       (struct abstract_molecule *)sm, sm-&gt;t);
2485         if (result != RX_DESTROY) {
2486           mcell_internal_error("Molecule should disappear after hitting "
2487                                "ABSORPTIVE region border.");
2488         }
2489         delete_void_list((struct void_list *)hd_info);
2490         hd_info = NULL;
2491         return NULL;
2492       }
2493       if (hd_info != NULL) {
2494         delete_void_list((struct void_list *)hd_info);
2495         hd_info = NULL;
2496       }
2497       continue;     }
2498     if (new_wall == sm-&gt;grid-&gt;surface) {
2499       if (move_sm_on_same_triangle(world, sm, &amp;new_loc, &amp;previous_box, new_wall, hd_info)) {
2500         continue; 
2501       }
2502     }
2503     else {
2504       if (move_sm_to_new_triangle(world, sm, &amp;new_loc, &amp;previous_box, new_wall, hd_info)) {
2505         continue;
2506       }
2507     }
2508     find_new_position = 0;
2509   }
2510   if (hd_info != NULL) {
2511     count_region_border_update(world, sm-&gt;properties, hd_info, sm-&gt;id);
2512     delete_void_list((struct void_list *)hd_info);
2513     hd_info = NULL;
2514   }
2515   *advance_time = t_steps;
2516   return sm;
2517 }
2518 struct surface_molecule *
2519 react_2D_all_neighbors(struct volume *world, struct surface_molecule *sm,
2520                        double t, enum notify_level_t molecule_collision_report,
2521                        int grid_grid_reaction_flag,
2522                        long long *surf_surf_colls) {
2523 #ifdef DEBUG_TIMING
2524   DUMP_CONDITION3(
2525       MCell::dump_react_2D_all_neighbors_timing(t, sm-&gt;t);
2526   );
2527 #endif
2528   int l = 0;
2529   int num_matching_rxns = 0;
2530   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
2531   struct tile_neighbor *tile_nbr_head = NULL, *curr;
2532   int list_length = 0; 
2533   if ((u_int)sm-&gt;grid_index &gt;= sm-&gt;grid-&gt;n_tiles) {
2534     mcell_internal_error("tile index %u is greater or equal number_of_tiles %u",
2535                          (u_int)sm-&gt;grid_index, sm-&gt;grid-&gt;n_tiles);
2536   }
2537   find_neighbor_tiles(world, sm, sm-&gt;grid, sm-&gt;grid_index, 0, 1, &amp;tile_nbr_head,
2538                       &amp;list_length);
2539   if (tile_nbr_head == NULL)
2540     return sm; 
2541   const int num_nbrs = list_length;
2542   int max_size = num_nbrs * MAX_MATCHING_RXNS;
2543   std::vector&lt;struct rxn *&gt; rxn_array(max_size);
2544   std::vector&lt;double&gt; cf(max_size); 
2545   std::vector&lt;struct surface_molecule *&gt; smol(max_size); 
2546   local_prob_factor = 3.0 / num_nbrs;
2547   for (int kk = 0; kk &lt; max_size; kk++) {     rxn_array[kk] = NULL;
2548     smol[kk] = NULL;
2549     cf[kk] = 0;
2550   }
2551   for (curr = tile_nbr_head; curr != NULL; curr = curr-&gt;next) {
2552     struct surface_molecule_list *sm_list = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]; 
2553     if (sm_list == NULL || sm_list-&gt;sm == NULL)
2554       continue;
2555     struct surface_molecule *smp = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]-&gt;sm;
2556 #ifdef DEBUG_RXNS
2557     DUMP_CONDITION3(
2558         dump_surface_molecule(smp, "", true, "  checking in react_2D_all_neighbors: ", world-&gt;current_iterations, 0.0, true);
2559     );
2560 #endif
2561     if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
2562         (smp-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
2563       if (sm-&gt;grid-&gt;surface != smp-&gt;grid-&gt;surface) {
2564         if (walls_belong_to_at_least_one_different_restricted_region(
2565                 world, sm-&gt;grid-&gt;surface, sm, smp-&gt;grid-&gt;surface, smp))
2566           continue;
2567         if (walls_belong_to_at_least_one_different_restricted_region(
2568                 world, sm-&gt;grid-&gt;surface, smp, smp-&gt;grid-&gt;surface, sm))
2569           continue;
2570       }
2571     }
2572     if(sm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
2573       num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)sm,
2574         (struct abstract_molecule *)smp, sm-&gt;orient, smp-&gt;orient, matching_rxns);
2575     } 
2576     else{     
2577     num_matching_rxns = trigger_bimolecular(
2578         world-&gt;reaction_hash, world-&gt;rx_hashsize, sm-&gt;properties-&gt;hashval,
2579         smp-&gt;properties-&gt;hashval, (struct abstract_molecule *)sm,
2580         (struct abstract_molecule *)smp, sm-&gt;orient, smp-&gt;orient,
2581         matching_rxns);
2582     }
2583     if (num_matching_rxns &gt; 0) {
2584       if (molecule_collision_report == NOTIFY_FULL) {
2585         if (grid_grid_reaction_flag)
2586           surf_surf_colls++;
2587       }
2588       for (int jj = 0; jj &lt; num_matching_rxns; jj++) {
2589         if (matching_rxns[jj] != NULL) {
2590           if (matching_rxns[jj]-&gt;prob_t != NULL)
2591             update_probs(world, matching_rxns[jj], sm-&gt;t);
2592           rxn_array[l] = matching_rxns[jj];
2593           cf[l] = t / (curr-&gt;grid-&gt;binding_factor);
2594           smol[l] = smp;
2595           l++;
2596         }
2597       }
2598       n += num_matching_rxns;
2599     }
2600   }
2601   delete_tile_neighbor_list(tile_nbr_head);
2602   if (n == 0) {
2603     return sm;   } else if (n == 1) {
2604     i = test_bimolecular(rxn_array[0], cf[0], local_prob_factor, NULL, NULL,
2605                          world-&gt;rng);
2606     j = 0;
2607   } else {
2608     int all_neighbors_flag = 1;
2609     j = test_many_bimolecular(&amp;rxn_array[0], &amp;cf[0], local_prob_factor, n, &amp;(i),
2610                               world-&gt;rng, all_neighbors_flag);
2611   }
2612   if ((j == RX_NO_RX) || (i &lt; RX_LEAST_VALID_PATHWAY)) {
2613     return sm;   }
2614   int outcome_bimol_result = outcome_bimolecular(
2615       world, rxn_array[j], i, (struct abstract_molecule *)sm,
2616       (struct abstract_molecule *)smol[j], sm-&gt;orient, smol[j]-&gt;orient, sm-&gt;t,
2617       NULL, NULL);
2618   if (outcome_bimol_result == RX_DESTROY) {
2619     mem_put(sm-&gt;birthplace, sm);
2620     return NULL;
2621   }
2622   return sm;
2623 }
2624 void clean_up_old_molecules(struct storage *local) {
2625   if (local-&gt;timer-&gt;defunct_count &gt; MIN_DEFUNCT_FOR_GC &amp;&amp;
2626       MAX_DEFUNCT_FRAC * (local-&gt;timer-&gt;count) &lt; local-&gt;timer-&gt;defunct_count) {
2627     struct abstract_molecule *am;
2628     am = (struct abstract_molecule *)schedule_cleanup(local-&gt;timer,
2629                                                       *is_defunct_molecule);
2630     while (am != NULL) {
2631       struct abstract_molecule *temp = am;
2632       am = am-&gt;next;
2633       if ((temp-&gt;flags &amp; IN_MASK) == IN_SCHEDULE) {
2634         temp-&gt;next = NULL;
2635         mem_put(temp-&gt;birthplace, temp);
2636       } else {
2637         temp-&gt;flags &amp;= ~IN_SCHEDULE;
2638       }
2639     }
2640   }
2641 }
2642 void reschedule_surface_molecules(
2643     struct volume *state, struct storage *local,
2644     struct abstract_molecule *am) {
2645   struct vector3 pos3d;
2646   struct surface_molecule *sm = (struct surface_molecule *)(void *)am;
2647   uv2xyz(&amp;sm-&gt;s_pos, sm-&gt;grid-&gt;surface, &amp;pos3d);
2648   struct subvolume *sv = find_subvolume(state, &amp;pos3d, sm-&gt;grid-&gt;subvol);
2649   if (sv-&gt;local_storage != local) {
2650     struct surface_molecule *sm_new =
2651         (struct surface_molecule *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;smol,
2652                                                    "surface molecule");
2653     memcpy(sm_new, sm, sizeof(struct surface_molecule));
2654     sm_new-&gt;next = NULL;
2655     sm_new-&gt;birthplace = sv-&gt;local_storage-&gt;smol;
2656     if (sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index] &amp;&amp; 
2657         (sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index]-&gt;sm == sm)) {
2658       sm-&gt;grid-&gt;sm_list[sm-&gt;grid_index]-&gt;sm = sm_new;
2659       sm-&gt;grid = NULL;
2660       sm-&gt;grid_index = 0;
2661     }
2662     mem_put(sm-&gt;birthplace, sm);
2663     if (schedule_add_mol(sv-&gt;local_storage-&gt;timer, sm_new))
2664       mcell_allocfailed("Failed to add a '%s' surface molecule to scheduler "
2665                         "after migrating to a new memory store.",
2666                         am-&gt;properties-&gt;sym-&gt;name);
2667   } else {
2668     if (schedule_add_mol(local-&gt;timer, am))
2669       mcell_allocfailed("Failed to add a '%s' surface molecule to scheduler "
2670                         "after taking a diffusion step.",
2671                         am-&gt;properties-&gt;sym-&gt;name);
2672   }
2673 }
2674 void run_timestep(struct volume *state, struct storage *local,
2675                   double release_time, double checkpt_time) {
2676   struct abstract_molecule *am;
2677   clean_up_old_molecules(local);
2678 #ifdef MCELL3_SORTED_MOLS_ON_RUN_TIMESTEP
2679   #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2680     dump_schedule_helper(local-&gt;timer, "Before sorting", "", "", true);
2681   #endif
2682   sort_schedule_by_time_and_id(local-&gt;timer);
2683   #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2684     dump_schedule_helper(local-&gt;timer, "After sorting", "", "", true);
2685   #endif
2686 #endif
2687   while (local-&gt;timer-&gt;current != NULL) {
2688 #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2689     dump_schedule_helper(local-&gt;timer, "local", "", "", true);
2690 #endif
2691 #ifdef MCELL3_4_ALWAYS_SORT_MOLS_BY_TIME_AND_ID
2692 #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2693   dump_schedule_helper(local-&gt;timer, "Before sorting", "", "", true);
2694 #endif
2695   sort_schedule_by_time_and_id(local-&gt;timer);
2696 #ifdef DUMP_LOCAL_SCHEDULE_HELPER
2697   dump_schedule_helper(local-&gt;timer, "After sorting", "", "", true);
2698 #endif
2699 #endif
2700     am = (struct abstract_molecule *)schedule_next(local-&gt;timer);
2701     if (am-&gt;properties == NULL)     {
2702       if ((am-&gt;flags &amp; IN_MASK) == IN_SCHEDULE) {
2703         am-&gt;next = NULL;
2704         mem_put(am-&gt;birthplace, am);
2705       } else
2706         am-&gt;flags &amp;= ~IN_SCHEDULE;
2707       if (local-&gt;timer-&gt;defunct_count &gt; 0)
2708         local-&gt;timer-&gt;defunct_count--;
2709       continue;
2710     }
2711 #ifdef DEBUG_SCHEDULER
2712     {
2713       struct volume *world = state;
2714       DUMP_CONDITION3(
2715           struct volume_molecule* vm = (struct volume_molecule*)am;
2716           dump_volume_molecule(vm, "", true, "\n* Running scheduled action: ", world-&gt;current_iterations, vm-&gt;t, true);
2717       );
2718     }
2719 #endif
2720     am-&gt;flags &amp;= ~IN_SCHEDULE;
2721     if (am-&gt;t2 &lt; EPS_C || am-&gt;t2 &lt; EPS_C * am-&gt;t) {
2722       if (!check_for_unimolecular_reaction(state, am)) {
2723         continue;
2724       }
2725     }
2726     double surface_mol_advance_time = 0;
2727     struct wall *current_wall = NULL;
2728     double max_time;
2729 #ifdef MCELL_ALWAYS_DIFFUSE
2730     int can_diffuse = 1;
2731 #else
2732     int can_diffuse = ((am-&gt;flags &amp; ACT_DIFFUSE) != 0);
2733 #endif
2734     if (can_diffuse) {
2735       max_time = checkpt_time - am-&gt;t;
2736       if (local-&gt;max_timestep &lt; max_time)
2737         max_time = local-&gt;max_timestep;
2738       if ((am-&gt;flags &amp; (ACT_REACT)) != 0 &amp;&amp; am-&gt;t2 &lt; max_time)
2739         max_time = am-&gt;t2;
2740       if ((am-&gt;flags &amp; TYPE_VOL) != 0) {
2741         double save_sched_time = am-&gt;t;
2742         if (max_time &gt; release_time - am-&gt;t)
2743           max_time = release_time - am-&gt;t;
2744         if (am-&gt;properties-&gt;flags &amp; (CAN_VOLVOLVOL | CAN_VOLVOLSURF))
2745           am = (struct abstract_molecule *)diffuse_3D_big_list(
2746               state, (struct volume_molecule *)am, max_time);
2747         else
2748           am = (struct abstract_molecule *)diffuse_3D(
2749               state, (struct volume_molecule *)am, max_time);
2750         if (am != NULL)         {
2751           if ((am-&gt;flags &amp; ACT_REACT) != 0) {
2752             am-&gt;t2 -= am-&gt;t - save_sched_time;
2753             if (am-&gt;t2 &lt; 0)
2754               am-&gt;t2 = 0;
2755           }
2756         } else
2757           continue;
2758       } else {
2759         if (max_time &gt; release_time - am-&gt;t) {
2760           max_time = release_time - am-&gt;t;
2761         }
2762         current_wall = ((struct surface_molecule *)am)-&gt;grid-&gt;surface;
2763         am = (struct abstract_molecule *)diffuse_2D(
2764             state, (struct surface_molecule *)am, max_time,
2765             &amp;surface_mol_advance_time);
2766         if (am == NULL) {
2767           continue;
2768         }
2769       }
2770     }
2771     else {
2772 #ifdef DEBUG_DIFFUSION
2773       struct volume *world = state;
2774       if ((am-&gt;flags &amp; TYPE_VOL) != 0) {
2775         DUMP_CONDITION3(
2776             dump_volume_molecule((struct volume_molecule *)am, "", true, "Not diffusing vm:", world-&gt;current_iterations, am-&gt;t, true);
2777         );
2778       }
2779       else {
2780         DUMP_CONDITION3(
2781             dump_surface_molecule((struct surface_molecule *)am, "", true, "Not diffusing sm:", world-&gt;current_iterations, am-&gt;t, true);
2782         );
2783       }
2784 #endif
2785     }
2786     int can_surface_mol_react = (am-&gt;get_flags(am) &amp; (CAN_SURFSURFSURF | CAN_SURFSURF));
2787     if (((am-&gt;flags &amp; TYPE_SURF) != 0) &amp;&amp; can_surface_mol_react) {
2788       if (!can_diffuse) 
2789       {
2790         max_time = checkpt_time - am-&gt;t;
2791         if (am-&gt;t2 &lt; max_time &amp;&amp; (am-&gt;flags &amp; (ACT_REACT)) != 0)
2792           max_time = am-&gt;t2;
2793         if (max_time &gt; release_time - am-&gt;t)
2794           max_time = release_time - am-&gt;t;
2795         if (am-&gt;get_time_step(am) &lt; max_time)
2796           max_time = am-&gt;get_time_step(am);
2797         surface_mol_advance_time = max_time;
2798       } else
2799         max_time = surface_mol_advance_time;
2800       if (can_surface_mol_react) {
2801         if ((am-&gt;properties-&gt;flags &amp; (CANT_INITIATE | CAN_SURFSURF)) ==
2802             CAN_SURFSURF) {
2803           am = (struct abstract_molecule *)react_2D_all_neighbors(
2804               state, (struct surface_molecule *)am, max_time,
2805               state-&gt;notify-&gt;molecule_collision_report,
2806               state-&gt;rxn_flags.surf_surf_reaction_flag,
2807               &amp;(state-&gt;surf_surf_colls));
2808           if (am == NULL)
2809             continue;
2810         }
2811         if ((am-&gt;properties-&gt;flags &amp; (CANT_INITIATE | CAN_SURFSURFSURF)) ==
2812             CAN_SURFSURFSURF) {
2813           am = (struct abstract_molecule *)react_2D_trimol_all_neighbors(
2814               state, (struct surface_molecule *)am, max_time,
2815               state-&gt;notify-&gt;molecule_collision_report,
2816               state-&gt;notify-&gt;final_summary,
2817               state-&gt;rxn_flags.surf_surf_surf_reaction_flag,
2818               &amp;(state-&gt;surf_surf_surf_colls));
2819           if (am == NULL)
2820             continue;
2821         }
2822       }
2823     }
2824     if ((am-&gt;flags &amp; TYPE_SURF) != 0 &amp;&amp; (can_diffuse || can_surface_mol_react)) {
2825       am-&gt;t += surface_mol_advance_time;
2826       if ((am-&gt;flags &amp; ACT_REACT) != 0) {
2827         int can_surf_react = ((am-&gt;properties-&gt;flags &amp; CAN_SURFWALL) != 0);
2828         if (can_surf_react &amp;&amp; !distinguishable(am-&gt;t2, (double)FOREVER, EPS_C)) {
2829           am-&gt;t2 = 0;
2830           am-&gt;flags |= ACT_CHANGE;         }
2831         else {
2832           am-&gt;t2 -= surface_mol_advance_time;
2833           if (am-&gt;t2 &lt; 0) {
2834             am-&gt;t2 = 0;
2835           }
2836           if ((current_wall !=
2837               ((struct surface_molecule *)am)-&gt;grid-&gt;surface) &amp;&amp;
2838               (am-&gt;t2 &gt; EPS_C || am-&gt;t2 &gt; EPS_C * am-&gt;t)) {
2839             am-&gt;t2 = 0;
2840             am-&gt;flags |= ACT_CHANGE;           }
2841         }
2842       }
2843     } else if (!can_diffuse) {
2844       if (am-&gt;t2 == 0)
2845         am-&gt;t += MAX_UNI_TIMESKIP;
2846       else {
2847         am-&gt;t += am-&gt;t2;
2848         am-&gt;t2 = 0;
2849       }
2850     }
2851     am-&gt;flags |= IN_SCHEDULE;
2852     double t = ceil(am-&gt;t) * (1.0 + 0.1 * EPS_C);
2853     if (!distinguishable(t, am-&gt;t, EPS_C))
2854       am-&gt;t = t;
2855     if (am-&gt;flags &amp; TYPE_SURF) {
2856       reschedule_surface_molecules(state, local, am);
2857     } else {
2858       if (schedule_add(
2859               ((struct volume_molecule *)am)-&gt;subvol-&gt;local_storage-&gt;timer, am))
2860         mcell_allocfailed("Failed to add a '%s' volume molecule to scheduler "
2861                           "after taking a diffusion step.",
2862                           am-&gt;properties-&gt;sym-&gt;name);
2863     }
2864   }
2865   if (local-&gt;timer-&gt;error)
2866     mcell_internal_error("Scheduler reported an out-of-memory error while "
2867                          "retrieving molecules, but this should never happen.");
2868 }
2869 void run_clamp(struct volume *world, double t_now) {
2870   int this_count = 0;
2871   static int total_count = 0;
2872   for (struct clamp_data *cdp = world-&gt;clamp_list; cdp != NULL; cdp = cdp-&gt;next) {
2873     if (cdp-&gt;objp == NULL) {
2874       continue;
2875     }
2876     for (struct clamp_data *cdpo = cdp; cdpo != NULL; cdpo = cdpo-&gt;next_obj) {
2877       for (struct clamp_data *cdpm = cdpo; cdpm != NULL; cdpm = cdpm-&gt;next_mol) {
2878         double n_collisions = cdpo-&gt;scaling_factor * cdpm-&gt;mol-&gt;space_step *
2879                        cdpm-&gt;clamp_value / cdpm-&gt;mol-&gt;time_step;
2880         if (cdpm-&gt;orient != 0) {
2881           n_collisions *= 0.5;
2882         }
2883         int n_emitted = poisson_dist(n_collisions, rng_dbl(world-&gt;rng));
2884         if (n_emitted == 0)
2885           continue;
2886         struct volume_molecule vm;
2887         vm.t = t_now + 0.5;
2888         vm.t2 = 0;
2889         vm.flags = IN_SCHEDULE | ACT_NEWBIE | TYPE_VOL | IN_VOLUME |
2890                   ACT_CLAMPED | ACT_DIFFUSE;
2891         vm.properties = cdpm-&gt;mol;
2892         initialize_diffusion_function((struct abstract_molecule*)&amp;vm);
2893         vm.mesh_name = NULL;
2894         vm.birthplace = NULL;
2895         vm.birthday = convert_iterations_to_seconds(
2896             world-&gt;start_iterations, world-&gt;time_unit,
2897             world-&gt;simulation_start_seconds, t_now);
2898         vm.subvol = NULL;
2899         vm.previous_wall = NULL;
2900         vm.index = 0;
2901         struct volume_molecule *vmp = NULL;
2902         this_count += n_emitted;
2903         while (n_emitted &gt; 0) {
2904           int idx = bisect_high(cdpo-&gt;cum_area, cdpo-&gt;n_sides,
2905                             rng_dbl(world-&gt;rng) *
2906                                 cdpo-&gt;cum_area[cdp-&gt;n_sides - 1]);
2907           struct wall *w = cdpo-&gt;objp-&gt;wall_p[cdpo-&gt;side_idx[idx]];
2908           double s1 = sqrt(rng_dbl(world-&gt;rng));
2909           double s2 = rng_dbl(world-&gt;rng) * s1;
2910           struct vector3 v;
2911           v.x = w-&gt;vert[0]-&gt;x + s1 * (w-&gt;vert[1]-&gt;x - w-&gt;vert[0]-&gt;x) +
2912                 s2 * (w-&gt;vert[2]-&gt;x - w-&gt;vert[1]-&gt;x);
2913           v.y = w-&gt;vert[0]-&gt;y + s1 * (w-&gt;vert[1]-&gt;y - w-&gt;vert[0]-&gt;y) +
2914                 s2 * (w-&gt;vert[2]-&gt;y - w-&gt;vert[1]-&gt;y);
2915           v.z = w-&gt;vert[0]-&gt;z + s1 * (w-&gt;vert[1]-&gt;z - w-&gt;vert[0]-&gt;z) +
2916                 s2 * (w-&gt;vert[2]-&gt;z - w-&gt;vert[1]-&gt;z);
2917           if (cdpm-&gt;orient == 1) {
2918             vm.index = 1;
2919           }
2920           else if (cdpm-&gt;orient == -1) {
2921             vm.index = -1;
2922           }
2923           else {
2924             vm.index = (rng_uint(world-&gt;rng) &amp; 2) - 1;
2925           }
2926           double eps = EPS_C * vm.index;
2927           s1 = fabs(v.x);
2928           s2 = fabs(v.y);
2929           if (s1 &lt; s2) {
2930             s1 = s2;
2931           }
2932           s2 = fabs(v.z);
2933           if (s1 &lt; s2) {
2934             s1 = s2;
2935           }
2936           if (s1 &gt; 1.0){
2937             eps *= s1;
2938           }
2939           vm.pos.x = v.x + w-&gt;normal.x * eps;
2940           vm.pos.y = v.y + w-&gt;normal.y * eps;
2941           vm.pos.z = v.z + w-&gt;normal.z * eps;
2942           vm.previous_wall = w;
2943           struct periodic_image periodic_box = {0, 0, 0};
2944           vm.periodic_box = &amp;periodic_box;
2945           if (vmp == NULL) {
2946             vmp = insert_volume_molecule(world, &amp;vm, vmp);
2947             if (vmp == NULL)
2948               mcell_allocfailed("Failed to insert a '%s' volume molecule while "
2949                                 "concentration/flux clamping.",
2950                                 vm.properties-&gt;sym-&gt;name);
2951             if (trigger_unimolecular(world-&gt;reaction_hash, world-&gt;rx_hashsize,
2952                                      cdpm-&gt;mol-&gt;hashval,
2953                                      (struct abstract_molecule *)vmp) != NULL) {
2954               vm.flags |= ACT_REACT;
2955               vmp-&gt;flags |= ACT_REACT;
2956             }
2957           } else {
2958             vmp = insert_volume_molecule(world, &amp;vm, vmp);
2959             if (vmp == NULL)
2960               mcell_allocfailed("Failed to insert a '%s' volume molecule while "
2961                                 "concentration/flux clamping.",
2962                                 vm.properties-&gt;sym-&gt;name);
2963           }
2964           n_emitted--;
2965         }
2966       }
2967     }
2968   }
2969   total_count += this_count;
2970 }
2971 void redo_collision_list(struct volume* world, struct collision** shead,
2972   struct collision** stail, struct collision** shead_exp, struct volume_molecule* m,
2973   struct vector3* displacement, struct subvolume* sv) {
2974   struct collision* st = *stail;
2975   struct collision* sh = *shead_exp;
2976   if (st != NULL) {
2977     st-&gt;next = NULL;
2978     if (sh != NULL) {
2979       mem_put_list(sv-&gt;local_storage-&gt;coll, sh);
2980       sh = NULL;
2981     }
2982   } else if (sh != NULL) {
2983     mem_put_list(sv-&gt;local_storage-&gt;coll, sh);
2984     sh = NULL;
2985     *shead = NULL;
2986   }
2987   if ((m-&gt;properties-&gt;flags &amp; (CAN_VOLVOL | CANT_INITIATE)) == CAN_VOLVOL) {
2988     sh = expand_collision_list(world, m, displacement, sv, world-&gt;rx_radius_3d,
2989       world-&gt;ny_parts, world-&gt;nz_parts, world-&gt;x_fineparts,
2990       world-&gt;y_fineparts, world-&gt;z_fineparts, world-&gt;rx_hashsize,
2991       world-&gt;reaction_hash);
2992     if (st != NULL)
2993       st-&gt;next = sh;
2994     else {
2995       if (*shead != NULL)
2996         mcell_internal_error("Collision lists corrupted.  While expanding "
2997                              "the collision lists, expected shead to be "
2998                              "NULL, but it wasn't.");
2999       *shead = sh;
3000     }
3001   }
3002   *stail = st;
3003   *shead_exp = sh;
3004 }
3005 static int collide_and_react_with_vol_mol(struct volume* world,
3006   struct collision* smash, struct volume_molecule* m, struct collision**
3007   tentative, struct vector3* displacement, struct vector3* loc_certain, double
3008   t_steps, double r_rate_factor) {
3009   struct abstract_molecule* am = (struct abstract_molecule *)smash-&gt;target;
3010   double factor = exact_disk(
3011       world, &amp;(smash-&gt;loc), displacement, world-&gt;rx_radius_3d, m-&gt;subvol,
3012       m, (struct volume_molecule *)am, world-&gt;use_expanded_list,
3013       world-&gt;x_fineparts, world-&gt;y_fineparts, world-&gt;z_fineparts);
3014   if (factor &lt; 0) {     return 0;   }
3015   double scaling = factor * r_rate_factor;
3016   struct rxn* rx = smash-&gt;intermediate;
3017   if ((rx != NULL) &amp;&amp; (rx-&gt;prob_t != NULL)) {
3018     update_probs(world, rx, m-&gt;t);
3019   }
3020   struct species *spec = m-&gt;properties;
3021   struct periodic_image *periodic_box = m-&gt;periodic_box;
3022   int i = test_bimolecular(
3023     rx, scaling, 0, am, (struct abstract_molecule *)m, world-&gt;rng);
3024   if (i &lt; RX_LEAST_VALID_PATHWAY) {
3025     return 0;
3026   }
3027   if (loc_certain != NULL) {
3028   }
3029   int j = outcome_bimolecular(world, rx, i, (struct abstract_molecule *)m, am,
3030     0, 0, m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc_certain);
3031   if (j != RX_DESTROY) {
3032     return 0;
3033   } else {
3034     struct collision* ttv = *tentative;
3035     for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t; ttv = ttv-&gt;next) {
3036       if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
3037         continue;
3038       }
3039       if (m-&gt;properties == NULL) {
3040         continue;
3041       }
3042       if (!(m-&gt;properties-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp;
3043             COUNT_SOME_MASK)) {
3044         continue;
3045       }
3046       count_region_update(world, m, spec, m-&gt;id, periodic_box,
3047         ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
3048         ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 0, &amp;(ttv-&gt;loc), ttv-&gt;t);
3049       if (ttv == smash) {
3050         break;
3051       }
3052     }
3053     *tentative = ttv;
3054   }
3055   return 1;
3056 }
3057 int collide_and_react_with_surf_mol(struct volume* world, struct collision* smash,
3058   struct volume_molecule* m, struct collision** tentative,
3059   struct vector3** loc_certain, double t_steps, int mol_grid_flag,
3060   int mol_grid_grid_flag, double r_rate_factor) {
3061   ASSERT_FOR_MCELL4(mol_grid_flag == 1);
3062   struct collision* ttv = *tentative;
3063   struct vector3* loc = *loc_certain;
3064   struct wall* w = (struct wall *)smash-&gt;target;
3065   double t_confident = 0.0;
3066   if (smash-&gt;next == NULL) {
3067     t_confident = smash-&gt;t;
3068   } else if (smash-&gt;next-&gt;t * (1.0 - EPS_C) &gt; smash-&gt;t) {
3069     t_confident = smash-&gt;t;
3070   } else {
3071 	  ASSERT_FOR_MCELL4(false);
3072     t_confident = smash-&gt;t * (1.0 - EPS_C);
3073   }
3074   int k = -1;
3075   if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
3076     k = 1;
3077   }
3078   int j = xyz2grid(&amp;(smash-&gt;loc), w-&gt;grid);
3079   struct surface_molecule_list *sm_list = w-&gt;grid-&gt;sm_list[j]; 
3080   if (sm_list == NULL || sm_list-&gt;sm == NULL) {
3081     return -1;
3082   }
3083   struct surface_molecule* sm = w-&gt;grid-&gt;sm_list[j]-&gt;sm;
3084   if (m-&gt;index == j &amp;&amp; m-&gt;previous_wall == w) {
3085     m-&gt;index = -1;     return -1;
3086   }
3087   int num_matching_rxns = 0;
3088   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
3089   double scaling_coef[MAX_MATCHING_RXNS];
3090   struct species* spec = m-&gt;properties;
3091   struct periodic_image *periodic_box = m-&gt;periodic_box;
3092   int ii = 0, jj = 0;
3093   if (mol_grid_flag) {
3094     if(sm-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
3095       num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)m,
3096         (struct abstract_molecule *)sm, k, sm-&gt;orient, matching_rxns);
3097     }
3098     else{
3099     num_matching_rxns = trigger_bimolecular(
3100       world-&gt;reaction_hash, world-&gt;rx_hashsize, spec-&gt;hashval,
3101       sm-&gt;properties-&gt;hashval, (struct abstract_molecule *)m,
3102       (struct abstract_molecule *)sm, k, sm-&gt;orient, matching_rxns);
3103     }
3104     if (num_matching_rxns &gt; 0) {
3105       if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) {
3106         if (world-&gt;rxn_flags.vol_surf_reaction_flag)
3107           world-&gt;vol_surf_colls++;
3108       }
3109       for (int l = 0; l &lt; num_matching_rxns; l++) {
3110         if (matching_rxns[l]-&gt;prob_t != NULL) { 
3111 	        ASSERT_FOR_MCELL4(false);
3112           update_probs(world, matching_rxns[l], m-&gt;t); 
3113         }
3114         scaling_coef[l] = r_rate_factor / w-&gt;grid-&gt;binding_factor;
3115       }
3116       if (num_matching_rxns == 1) {
3117         ii = test_bimolecular(matching_rxns[0], scaling_coef[0], 0,
3118           (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
3119           world-&gt;rng);
3120         jj = 0;
3121       } else {
3122         ASSERT_FOR_MCELL4(false);      
3123         jj = test_many_bimolecular(matching_rxns, scaling_coef, 0,
3124           num_matching_rxns, &amp;(ii), world-&gt;rng, 0);
3125       }
3126       if ((jj &gt; RX_NO_RX) &amp;&amp; (ii &gt;= RX_LEAST_VALID_PATHWAY)) {
3127         short mflags = m-&gt;flags;
3128         int l = outcome_bimolecular(world, matching_rxns[jj], ii,
3129           (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
3130           k, sm-&gt;orient, m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc);
3131         if (l == RX_FLIP) {
3132           if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3133             int destroy_flag = 0;
3134             count_tentative_collisions(
3135               world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3136               periodic_box, m-&gt;id);
3137           }
3138           *tentative = ttv;
3139           *loc_certain = &amp;(ttv-&gt;loc);
3140           return 0;         } else if (l == RX_DESTROY) {
3141           if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
3142             int destroy_flag = 0;
3143             count_tentative_collisions(
3144               world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3145               periodic_box, m-&gt;id);
3146           }
3147           *tentative = ttv;
3148           return 1;
3149         }
3150       }
3151     }
3152   }
3153   if (mol_grid_grid_flag) {
3154     struct surface_molecule *smp;     struct tile_neighbor *tile_nbr_head = NULL, *curr;
3155     int list_length = 0;
3156     find_neighbor_tiles(world, sm, sm-&gt;grid, sm-&gt;grid_index, 0, 1,
3157       &amp;tile_nbr_head, &amp;list_length);
3158     if (tile_nbr_head != NULL) {
3159       const int num_nbrs = (int)list_length;
3160       int max_size = num_nbrs * MAX_MATCHING_RXNS;
3161       std::vector&lt;struct rxn *&gt; rxn_array(max_size);
3162       std::vector&lt;double&gt; cf(max_size); 
3163       std::vector&lt;struct surface_molecule *&gt; smol(max_size); 
3164       local_prob_factor = 3.0 / num_nbrs;
3165       jj = RX_NO_RX;
3166       ii = RX_LEAST_VALID_PATHWAY - 1;
3167       for (int kk = 0; kk &lt; max_size; kk++) {
3168         smol[kk] = NULL;
3169         rxn_array[kk] = NULL;
3170         cf[kk] = 0;
3171       }
3172       int ll = 0;
3173       for (curr = tile_nbr_head; curr != NULL; curr = curr-&gt;next) {
3174         sm_list = curr-&gt;grid-&gt;sm_list[curr-&gt;idx];
3175         if (sm_list == NULL || sm_list-&gt;sm == NULL)
3176           continue;
3177         smp = curr-&gt;grid-&gt;sm_list[curr-&gt;idx]-&gt;sm;
3178         if ((sm-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER) ||
3179             (smp-&gt;properties-&gt;flags &amp; CAN_REGION_BORDER)) {
3180           if (sm-&gt;grid-&gt;surface != smp-&gt;grid-&gt;surface) {
3181             if (walls_belong_to_at_least_one_different_restricted_region(
3182                     world, sm-&gt;grid-&gt;surface, sm, smp-&gt;grid-&gt;surface, smp)) {
3183               continue;
3184             }
3185             if (walls_belong_to_at_least_one_different_restricted_region(
3186                     world, sm-&gt;grid-&gt;surface, smp, smp-&gt;grid-&gt;surface, sm)) {
3187               continue;
3188             }
3189           }
3190         }
3191         num_matching_rxns = trigger_trimolecular(world-&gt;reaction_hash,
3192           world-&gt;rx_hashsize, spec-&gt;hashval, sm-&gt;properties-&gt;hashval,
3193           smp-&gt;properties-&gt;hashval, spec, sm-&gt;properties, smp-&gt;properties,
3194           k, sm-&gt;orient, smp-&gt;orient, matching_rxns);
3195         if (num_matching_rxns &gt; 0) {
3196           if (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL &amp;&amp;
3197               world-&gt;rxn_flags.vol_surf_surf_reaction_flag) {
3198               world-&gt;vol_surf_surf_colls++;
3199           }
3200           for (j = 0; j &lt; num_matching_rxns; j++) {
3201             if (matching_rxns[j]-&gt;prob_t != NULL) {
3202               update_probs(world, matching_rxns[j], m-&gt;t);
3203             }
3204             rxn_array[ll] = matching_rxns[j];
3205             cf[ll] = r_rate_factor / (w-&gt;grid-&gt;binding_factor *
3206                                       curr-&gt;grid-&gt;binding_factor);
3207             smol[ll] = smp;
3208             ll++;
3209           }
3210           n += num_matching_rxns;
3211         }
3212       }
3213       delete_tile_neighbor_list(tile_nbr_head);
3214       if (n == 1) {
3215         ii = test_bimolecular(rxn_array[0], cf[0], local_prob_factor,
3216           NULL, NULL, world-&gt;rng);
3217         jj = 0;
3218       } else if (n &gt; 1) {
3219         int all_neighbors_flag = 1;
3220         jj = test_many_bimolecular(&amp;rxn_array[0], &amp;cf[0], local_prob_factor,
3221           n, &amp;(ii), world-&gt;rng, all_neighbors_flag);
3222       }
3223       if (n &gt; max_size)
3224         mcell_internal_error(
3225             "The size of the reactions array is not sufficient.");
3226       if ((n &gt; 0) &amp;&amp; (ii &gt;= RX_LEAST_VALID_PATHWAY) &amp;&amp; (jj &gt; RX_NO_RX)) {
3227         int mflags = m-&gt;flags;
3228         int l = outcome_trimolecular(world, rxn_array[jj], ii,
3229           (struct abstract_molecule *)m, (struct abstract_molecule *)sm,
3230           (struct abstract_molecule *)smol[jj], k, sm-&gt;orient,
3231           smol[jj]-&gt;orient, m-&gt;t + t_steps * smash-&gt;t, &amp;smash-&gt;loc, &amp;m-&gt;pos);
3232         if (l == RX_FLIP) {
3233           if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3234             int destroy_flag = 0;
3235             count_tentative_collisions(
3236               world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3237               periodic_box, m-&gt;id);
3238           }
3239           *loc_certain = &amp;(ttv-&gt;loc);
3240           *tentative = ttv;
3241           return 0;         } else if (l == RX_DESTROY) {
3242           if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
3243             int destroy_flag = 0;
3244             count_tentative_collisions(
3245               world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3246               periodic_box, m-&gt;id);
3247           }
3248           *tentative = ttv;
3249           return 1;
3250         }
3251       }
3252     }
3253   }
3254   return -1;
3255 }
3256 int collide_and_react_with_walls(struct volume* world, struct collision* smash,
3257   struct volume_molecule* m, struct collision** tentative,
3258   struct vector3** loc_certain, double t_steps, int inertness,
3259   double r_rate_factor) {
3260   struct collision *ttv = *tentative;
3261   struct vector3 *loc = *loc_certain;
3262   double t_confident = 0.0;
3263   if (smash-&gt;next == NULL) {
3264     t_confident = smash-&gt;t;
3265   } else if (smash-&gt;next-&gt;t * (1.0 - EPS_C) &gt; smash-&gt;t) {
3266     t_confident = smash-&gt;t;
3267   } else {
3268     t_confident = smash-&gt;t * (1.0 - EPS_C);
3269   }
3270   int k = -1;
3271   if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
3272     k = 1;
3273   }
3274   m-&gt;index = -1;
3275   int num_matching_rxns = 0;
3276   struct rxn* rx = NULL;
3277   struct species* spec = m-&gt;properties;
3278   struct wall* w = (struct wall *)smash-&gt;target;
3279   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
3280   num_matching_rxns = trigger_intersect(world-&gt;reaction_hash,
3281     world-&gt;rx_hashsize, world-&gt;all_mols, world-&gt;all_volume_mols,
3282     world-&gt;all_surface_mols, spec-&gt;hashval, (struct abstract_molecule *)m, k, w,
3283     matching_rxns, 1, 0, 0);
3284   if (num_matching_rxns == 0) {
3285     return -1;
3286   }
3287   int is_transp_flag = 0;
3288   struct rxn *transp_rx = NULL;
3289   for (int ii = 0; ii &lt; num_matching_rxns; ii++) {
3290     rx = matching_rxns[ii];
3291     if (rx-&gt;n_pathways == RX_TRANSP) {
3292       is_transp_flag = 1;
3293       transp_rx = matching_rxns[ii];
3294       break;
3295     }
3296   }
3297   if ((!is_transp_flag) &amp;&amp; (world-&gt;notify-&gt;molecule_collision_report == NOTIFY_FULL) &amp;&amp;
3298        world-&gt;rxn_flags.vol_wall_reaction_flag) {
3299     world-&gt;vol_wall_colls++;
3300   }
3301   struct periodic_image *periodic_box = m-&gt;periodic_box;
3302   if (is_transp_flag) {
3303     transp_rx-&gt;n_occurred++;
3304     if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3305       int destroy_flag = 0;
3306       count_tentative_collisions(
3307         world, tentative, smash, m, spec, smash-&gt;t, destroy_flag, periodic_box,
3308         m-&gt;id);
3309       for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= t_confident; ttv = ttv-&gt;next) {
3310         *loc_certain = &amp;(ttv-&gt;loc);
3311       }
3312     }
3313 #ifdef DEBUG_TRANSPARENT_SURFACES
3314   std::cout &lt;&lt; "Crossed a transparent wall, side: " &lt;&lt; ((wall*)smash-&gt;target)-&gt;side &lt;&lt; "\n";
3315 #endif
3316     return 0;   } else if (inertness &lt; inert_to_all) {
3317     for (int l = 0; l &lt; num_matching_rxns; l++) {
3318       if (matching_rxns[l]-&gt;prob_t != NULL) {
3319         update_probs(world, matching_rxns[l], m-&gt;t);
3320       }
3321     }
3322     int jj = 0;
3323     int i = 0;
3324     if (num_matching_rxns == 1) {
3325       i = test_intersect(matching_rxns[0], r_rate_factor, world-&gt;rng);
3326       jj = 0;
3327     } else {
3328       jj = test_many_intersect(matching_rxns, r_rate_factor,
3329                                num_matching_rxns, &amp;(i), world-&gt;rng);
3330     }
3331     if ((i &gt;= RX_LEAST_VALID_PATHWAY) &amp;&amp; (jj &gt; RX_NO_RX)) {
3332       rx = matching_rxns[jj];
3333       int mflags = m-&gt;flags;
3334       int j = outcome_intersect(world, rx, i, w, (struct abstract_molecule *)m, k,
3335         m-&gt;t + t_steps * smash-&gt;t, &amp;(smash-&gt;loc), loc);
3336       if (j == RX_FLIP) {
3337         if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3338           int destroy_flag = 0;
3339           count_tentative_collisions(
3340             world, &amp;ttv, smash, m, spec, t_confident, destroy_flag,
3341             periodic_box, m-&gt;id);
3342         }
3343         *loc_certain = &amp;(ttv-&gt;loc);
3344         *tentative = ttv;
3345         return 0;       } else if (j == RX_DESTROY) {
3346         if ((mflags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_HITS) != 0) {
3347           int destroy_flag = 1;
3348           count_tentative_collisions(
3349             world, tentative, smash, m, spec, smash-&gt;t, destroy_flag,
3350             periodic_box, m-&gt;id);
3351         }
3352         return 1;
3353       }
3354     }
3355   }
3356   return -1;
3357 }
3358 int reflect_or_periodic_bc(
3359     struct volume* world, struct collision* smash,
3360     struct vector3* displacement, struct volume_molecule** mol,
3361     struct wall** reflectee, struct collision** tentative, double* t_steps) {
3362   struct wall* w = (struct wall*)smash-&gt;target;
3363   struct wall *reflect_w = w;
3364   double reflect_t = smash-&gt;t;
3365   struct volume_molecule* vm = *mol;
3366   bool periodic_traditional = world-&gt;periodic_traditional; 
3367   ASSERT_FOR_MCELL4(!periodic_traditional);
3368   register_hits(world, vm, tentative, &amp;reflect_w, &amp;reflect_t, displacement,
3369     smash, t_steps);
3370   struct vector3 orig_pos = {vm-&gt;pos.x, vm-&gt;pos.y, vm-&gt;pos.z};
3371   (*reflectee) = reflect_w;
3372   int k = -1;
3373   if ((smash-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) {
3374     k = 1;
3375   }
3376   bool periodic_x = w-&gt;parent_object-&gt;periodic_x &amp;&amp; (k == -1);
3377   bool periodic_y = w-&gt;parent_object-&gt;periodic_y &amp;&amp; (k == -1);
3378   bool periodic_z = w-&gt;parent_object-&gt;periodic_z &amp;&amp; (k == -1);
3379   double llx = 0.0;
3380   double urx = 0.0;
3381   double lly = 0.0;
3382   double ury = 0.0;
3383   double llz = 0.0;
3384   double urz = 0.0;
3385   if (periodic_x || periodic_y || periodic_z) {
3386     struct geom_object* o = w-&gt;parent_object;
3387     assert(o-&gt;object_type == BOX_OBJ);
3388     struct polygon_object* p = (struct polygon_object*)(o-&gt;contents);
3389     struct subdivided_box* sb = p-&gt;sb;
3390     llx = sb-&gt;x[0];
3391     urx = sb-&gt;x[1];
3392     lly = sb-&gt;y[0];
3393     ury = sb-&gt;y[1];
3394     llz = sb-&gt;z[0];
3395     urz = sb-&gt;z[1];
3396   }
3397   double reflectFactor = -2.0 * (displacement-&gt;x * reflect_w-&gt;normal.x +
3398     displacement-&gt;y * reflect_w-&gt;normal.y + displacement-&gt;z *
3399     reflect_w-&gt;normal.z);
3400   int box_inc_x = 0;
3401   int box_inc_y = 0;
3402   int box_inc_z = 0;
3403   double x_pos = 0;
3404   double y_pos = 0;
3405   double z_pos = 0;
3406   if (periodic_x) {
3407     int x_inc = (vm-&gt;periodic_box-&gt;x % 2 == 0) ? 1 : -1;
3408     if (!distinguishable(vm-&gt;pos.x, llx, EPS_C)) {
3409       x_pos = urx - EPS_C;
3410       box_inc_x = -x_inc;
3411     } else if (!distinguishable(vm-&gt;pos.x, urx, EPS_C)) {
3412       x_pos = llx + EPS_C;
3413       box_inc_x = x_inc;
3414     }
3415     if (periodic_traditional &amp;&amp; x_pos) {
3416       vm-&gt;pos.x = x_pos;
3417     }
3418   }
3419   if ((!periodic_x) || (periodic_x &amp;&amp; !periodic_traditional)) {
3420     displacement-&gt;x = (displacement-&gt;x + reflectFactor * reflect_w-&gt;normal.x) *
3421       (1.0 - reflect_t);
3422   }
3423   else {
3424     displacement-&gt;x *= (1.0 - reflect_t);
3425   }
3426   if (periodic_y) {
3427     int y_inc = (vm-&gt;periodic_box-&gt;y % 2 == 0) ? 1 : -1;
3428     if (!distinguishable(vm-&gt;pos.y, lly, EPS_C)) {
3429       y_pos = ury - EPS_C;
3430       box_inc_y = -y_inc;
3431     } else if (!distinguishable(vm-&gt;pos.y, ury, EPS_C)) {
3432       y_pos = lly + EPS_C;
3433       box_inc_y = y_inc;
3434     }
3435     if (periodic_traditional &amp;&amp; y_pos) {
3436       vm-&gt;pos.y = y_pos;
3437     }
3438   }
3439   if ((!periodic_y) || (periodic_y &amp;&amp; !periodic_traditional)) {
3440     displacement-&gt;y = (displacement-&gt;y + reflectFactor * reflect_w-&gt;normal.y) *
3441       (1.0 - reflect_t);
3442   }
3443   else {
3444     displacement-&gt;y *= (1.0 - reflect_t);
3445   }
3446   if (periodic_z) {
3447     int z_inc = (vm-&gt;periodic_box-&gt;z % 2 == 0) ? 1 : -1;
3448     if (!distinguishable(vm-&gt;pos.z, llz, EPS_C)) {
3449       z_pos = urz - EPS_C;
3450       box_inc_z = -z_inc;
3451     } else if (!distinguishable(vm-&gt;pos.z, urz, EPS_C)) {
3452       z_pos = llz + EPS_C;
3453       box_inc_z = z_inc;
3454     }
3455     if (periodic_traditional &amp;&amp; z_pos) {
3456       vm-&gt;pos.z =  z_pos;
3457     }
3458   }
3459   if ((!periodic_z) || (periodic_z &amp;&amp; !periodic_traditional)) {
3460     displacement-&gt;z = (displacement-&gt;z + reflectFactor * reflect_w-&gt;normal.z) *
3461       (1.0 - reflect_t);
3462   }
3463   else {
3464     displacement-&gt;z *= (1.0 - reflect_t);
3465   }
3466   if ((periodic_traditional) &amp;&amp; (periodic_x || periodic_y || periodic_z)) {
3467     (*reflectee) = NULL;
3468     struct subvolume *nsv = find_subvolume(world, &amp;vm-&gt;pos, NULL);
3469     if (nsv == NULL) {
3470       struct species* spec = vm-&gt;properties;
3471       mcell_internal_error(
3472           "A %s molecule escaped the periodic box at [%.2f, %.2f, %.2f]",
3473           spec-&gt;sym-&gt;name, vm-&gt;pos.x * world-&gt;length_unit,
3474           vm-&gt;pos.y * world-&gt;length_unit, vm-&gt;pos.z * world-&gt;length_unit);
3475     } else {
3476       if (vm-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
3477         count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
3478                                   -1, &amp;(orig_pos), NULL, reflect_t, NULL);
3479       }
3480       struct volume_molecule *new_m = migrate_volume_molecule(vm, nsv);
3481       if (new_m-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
3482       count_region_from_scratch(world, (struct abstract_molecule *)new_m, NULL, 1,
3483                                 &amp;(new_m-&gt;pos), NULL, reflect_t, NULL);
3484       }
3485       *mol = new_m;
3486     }
3487     return 1;
3488   }
3489   if (!(periodic_traditional) &amp;&amp; (box_inc_x || box_inc_y || box_inc_z)) {
3490     (*reflectee) = NULL;
3491     struct subvolume *nsv = find_subvolume(world, &amp;vm-&gt;pos, NULL);
3492     if (nsv == NULL) {
3493       struct species* spec = vm-&gt;properties;
3494       mcell_internal_error(
3495           "A %s molecule escaped the periodic box at [%.2f, %.2f, %.2f]",
3496           spec-&gt;sym-&gt;name, vm-&gt;pos.x * world-&gt;length_unit,
3497           vm-&gt;pos.y * world-&gt;length_unit, vm-&gt;pos.z * world-&gt;length_unit);
3498     } else {
3499       if (vm-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
3500         count_region_from_scratch(world, (struct abstract_molecule *)vm, NULL,
3501                                   -1, &amp;(orig_pos), NULL, reflect_t,
3502                                   vm-&gt;periodic_box);
3503       }
3504       struct volume_molecule *new_m = migrate_volume_molecule(vm, nsv);
3505       vm-&gt;periodic_box-&gt;x += box_inc_x;
3506       vm-&gt;periodic_box-&gt;y += box_inc_y;
3507       vm-&gt;periodic_box-&gt;z += box_inc_z;
3508       if (new_m-&gt;properties-&gt;flags &amp; (COUNT_CONTENTS | COUNT_ENCLOSED)) {
3509         count_region_from_scratch(world, (struct abstract_molecule *)new_m,
3510                                   NULL, 1, &amp;(new_m-&gt;pos), NULL, reflect_t,
3511                                   new_m-&gt;periodic_box);
3512       }
3513       *mol = new_m;
3514     }
3515     return 1;
3516   }
3517   *mol = vm;
3518   return 0;
3519 }
3520  void register_hits(struct volume* world, struct volume_molecule* m,
3521   struct collision** tentative, struct wall** reflect_w, double* reflect_t,
3522   struct vector3* displacement, struct collision* smash, double* t_steps) {
3523   struct collision* ttv = *tentative;
3524   struct species* spec = m-&gt;properties;
3525   struct vector3 reflect_pt = smash-&gt;loc;
3526   if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3527     while (ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t &amp;&amp;
3528            !(ttv-&gt;what &amp; COLLIDE_WALL)) {
3529       ttv = ttv-&gt;next;
3530     }
3531     assert(ttv != NULL);
3532     (*reflect_w) = ((struct wall *)ttv-&gt;target);
3533     reflect_pt = ttv-&gt;loc;
3534     (*reflect_t) = ttv-&gt;t * (1 - EPS_C);
3535     for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= smash-&gt;t; ttv = ttv-&gt;next) {
3536       if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
3537         continue;
3538       }
3539       if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp;
3540             COUNT_SOME_MASK)) {
3541         continue;
3542       }
3543       count_region_update(world, m, m-&gt;properties, m-&gt;id, m-&gt;periodic_box,
3544         ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
3545         ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 0, &amp;(ttv-&gt;loc), ttv-&gt;t);
3546       if (ttv == smash)
3547         break;
3548     }
3549   }
3550   *tentative = ttv;
3551   m-&gt;pos = reflect_pt;
3552   m-&gt;t += *t_steps * (*reflect_t);
3553   *t_steps *= (1.0 - (*reflect_t));
3554 }
3555 void collide_and_react_with_subvol(struct volume* world, struct collision *smash,
3556   struct vector3* displacement, struct volume_molecule** mol,
3557   struct collision** tentative, double* t_steps) {
3558   struct collision* ttv = *tentative;
3559   struct volume_molecule* m = *mol;
3560   struct species* spec = m-&gt;properties;
3561   if ((m-&gt;flags &amp; COUNT_ME) != 0 &amp;&amp; (spec-&gt;flags &amp; COUNT_SOME_MASK) != 0) {
3562     for (; ttv != NULL &amp;&amp; ttv != smash; ttv = ttv-&gt;next) {
3563       if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
3564         continue;
3565       }
3566       if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp; COUNT_SOME_MASK)) {
3567         continue;
3568       }
3569       count_region_update(world, m, spec, m-&gt;id, m-&gt;periodic_box,
3570           ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
3571           ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, 1, &amp;(ttv-&gt;loc), ttv-&gt;t);
3572     }
3573   }
3574   m-&gt;pos.x = smash-&gt;loc.x;
3575   m-&gt;pos.y = smash-&gt;loc.y;
3576   m-&gt;pos.z = smash-&gt;loc.z;
3577   displacement-&gt;x *= (1.0 - smash-&gt;t);
3578   displacement-&gt;y *= (1.0 - smash-&gt;t);
3579   displacement-&gt;z *= (1.0 - smash-&gt;t);
3580   m-&gt;t += (*t_steps) * smash-&gt;t;
3581   (*t_steps) *= (1.0 - smash-&gt;t);
3582   if (*t_steps &lt; EPS_C) {
3583     *t_steps = EPS_C;
3584   }
3585   struct subvolume *nsv = traverse_subvol(
3586     m-&gt;subvol, smash-&gt;what - COLLIDE_SV_NX - COLLIDE_SUBVOL, world-&gt;ny_parts,
3587     world-&gt;nz_parts);
3588   if (nsv == NULL) {
3589     mcell_internal_error(
3590         "A %s molecule escaped the world at [%.2f, %.2f, %.2f]",
3591         spec-&gt;sym-&gt;name, m-&gt;pos.x * world-&gt;length_unit,
3592         m-&gt;pos.y * world-&gt;length_unit, m-&gt;pos.z * world-&gt;length_unit);
3593   } else {
3594     m = migrate_volume_molecule(m, nsv);
3595   }
3596   *mol = m;
3597   *tentative = ttv;
3598 }
3599 void compute_displacement(struct volume* world, struct collision* shead,
3600   struct volume_molecule* m, struct vector3* displacement,
3601   struct vector3* displacement2, double* rate_factor, double* r_rate_factor,
3602   double* steps, double* t_steps, double max_time) {
3603   struct species* spec = m-&gt;properties;
3604   if (m-&gt;flags &amp; ACT_CLAMPED) {     if (m-&gt;index &lt;= DISSOCIATION_MAX) {       pick_release_displacement(displacement, displacement2, m-&gt;get_space_step(m),
3605         world-&gt;r_step_release, world-&gt;d_step, world-&gt;radial_subdivisions,
3606         world-&gt;directions_mask, world-&gt;num_directions, world-&gt;rx_radius_3d,
3607         world-&gt;rng);
3608       *t_steps = 0;
3609     } else {       pick_clamped_displacement(displacement, m, world-&gt;r_step_surface,
3610         world-&gt;rng, world-&gt;radial_subdivisions);
3611       *t_steps = m-&gt;get_time_step(m);
3612       m-&gt;previous_wall = NULL;
3613       m-&gt;index = -1;
3614     }
3615     m-&gt;flags -= ACT_CLAMPED;
3616     *r_rate_factor = *rate_factor = 1.0;
3617     *steps = 1.0;
3618   } else {
3619     if (max_time &gt; MULTISTEP_WORTHWHILE) {
3620       *steps = safe_diffusion_step(m, shead, world-&gt;radial_subdivisions,
3621         world-&gt;r_step, world-&gt;x_fineparts, world-&gt;y_fineparts, world-&gt;z_fineparts);
3622     } else {
3623       *steps = 1.0;
3624     }
3625     *t_steps = *steps * m-&gt;get_time_step(m);
3626     if (*t_steps &gt; max_time) {
3627       *t_steps = max_time;
3628       *steps = max_time / m-&gt;get_time_step(m);
3629       #ifdef MCELL3_ROUND_TSTEPS
3630         if (*t_steps &gt; 1.0 - EPS_C &amp;&amp; *t_steps &lt; 1.0 + EPS_C) {
3631           *t_steps = 1.0;
3632         }
3633         if (*steps &gt; 1.0 - EPS_C &amp;&amp; *steps &lt; 1.0 + EPS_C) {
3634           *steps = 1.0;
3635         }
3636       #endif
3637     }
3638     if (*steps &lt; EPS_C) {
3639       *steps = EPS_C;
3640       *t_steps = EPS_C * m-&gt;get_time_step(m);
3641     }
3642     if (*steps == 1.0) {
3643       pick_displacement(displacement, m-&gt;get_space_step(m), world-&gt;rng);
3644       *r_rate_factor = *rate_factor = 1.0;
3645     } else {
3646       *rate_factor = sqrt(*steps);
3647       *r_rate_factor = 1.0 / *rate_factor;
3648       pick_displacement(displacement, *rate_factor * m-&gt;get_space_step(m), world-&gt;rng);
3649     }
3650   }
3651   if (spec-&gt;flags &amp; SET_MAX_STEP_LENGTH) {
3652     double disp_length = vect_length(displacement);
3653     if (disp_length &gt; spec-&gt;max_step_length) {
3654       displacement-&gt;x *= (spec-&gt;max_step_length / disp_length);
3655       displacement-&gt;y *= (spec-&gt;max_step_length / disp_length);
3656       displacement-&gt;z *= (spec-&gt;max_step_length / disp_length);
3657     }
3658   }
3659   world-&gt;diffusion_number++;
3660   world-&gt;diffusion_cumtime += *steps;
3661 }
3662 void determine_mol_mol_reactions(struct volume* world, struct volume_molecule* m,
3663   struct collision** shead, struct collision** stail, int inertness) {
3664   struct subvolume* sv = m-&gt;subvol;
3665   struct rxn *matching_rxns[MAX_MATCHING_RXNS];
3666   int num_matching_rxns = 0;
3667   struct species* spec = m-&gt;properties;
3668   struct per_species_list *psl_next, *psl, **psl_head = &amp;sv-&gt;species_head;
3669   for (psl = sv-&gt;species_head; psl != NULL; psl = psl_next) {
3670     psl_next = psl-&gt;next;
3671     if (psl-&gt;properties == NULL) {
3672       psl_head = &amp;psl-&gt;next;
3673       continue;
3674     }
3675     if (psl-&gt;head == NULL) {
3676       *psl_head = psl-&gt;next;
3677       ht_remove(&amp;sv-&gt;mol_by_species, psl);
3678       mem_put(sv-&gt;local_storage-&gt;pslv, psl);
3679       continue;
3680     } else
3681       psl_head = &amp;psl-&gt;next;
3682     if(m-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
3683       if(!trigger_bimolecular_preliminary_nfsim((struct abstract_molecule *)m, 
3684                                                 (struct abstract_molecule *)psl-&gt;head)){
3685         continue;
3686       }
3687     }
3688     else{
3689       if (!trigger_bimolecular_preliminary(world-&gt;reaction_hash, world-&gt;rx_hashsize,
3690         m-&gt;properties-&gt;hashval, psl-&gt;properties-&gt;hashval, m-&gt;properties, psl-&gt;properties)) {
3691         continue;
3692       }
3693     }
3694     for (struct volume_molecule* mp = psl-&gt;head; mp != NULL; mp = mp-&gt;next_v) {
3695       if (mp == m) {
3696         continue;
3697       }
3698       if (inertness == inert_to_mol &amp;&amp; m-&gt;index == mp-&gt;index) {
3699         continue;
3700       }
3701       if (!periodic_boxes_are_identical(m-&gt;periodic_box, mp-&gt;periodic_box)) {
3702         continue;
3703       }
3704       if(m-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES){
3705         num_matching_rxns = trigger_bimolecular_nfsim(world, (struct abstract_molecule *)m,
3706           (struct abstract_molecule *)mp,0, 0, matching_rxns);
3707       } 
3708       else{
3709         num_matching_rxns = trigger_bimolecular(world-&gt;reaction_hash,
3710           world-&gt;rx_hashsize, spec-&gt;hashval, psl-&gt;properties-&gt;hashval,
3711           (struct abstract_molecule *)m, (struct abstract_molecule *)mp, 0, 0,
3712           matching_rxns);
3713       }
3714       if (num_matching_rxns &gt; 0) {
3715         for (int i = 0; i &lt; num_matching_rxns; i++) {
3716           struct collision* smash =
3717            (struct collision *)CHECKED_MEM_GET(sv-&gt;local_storage-&gt;coll,
3718             "collision data");
3719           smash-&gt;target = (void *)mp;
3720           smash-&gt;what = COLLIDE_VOL;
3721           smash-&gt;intermediate = matching_rxns[i];
3722           smash-&gt;next = *shead;
3723           *shead = smash;
3724           if (*stail == NULL)
3725             *stail = *shead;
3726         }
3727       }
3728     }
3729   }
3730 }
3731 void set_inertness_and_maxtime(
3732     struct volume* world, struct volume_molecule* m, double* max_time,
3733     int* inertness) {
3734   struct species* spec = m-&gt;properties;
3735   if (world-&gt;volume_reversibility || world-&gt;surface_reversibility) {
3736     if (world-&gt;volume_reversibility &amp;&amp;
3737         m-&gt;index &lt;= DISSOCIATION_MAX) {       if ((m-&gt;flags &amp; ACT_CLAMPED) != 0) {
3738         *inertness = inert_to_all;
3739       } else {
3740         m-&gt;index = -1;
3741       }
3742     } else if (!world-&gt;surface_reversibility) {
3743       if (m-&gt;flags &amp; ACT_CLAMPED) {         m-&gt;birthday -= 5 * m-&gt;get_time_step(m);       }
3744     }
3745   } else {
3746     if (m-&gt;flags &amp; ACT_CLAMPED) {       m-&gt;birthday -= 5 * m-&gt;get_time_step(m);     } else if ((m-&gt;flags &amp; MATURE_MOLECULE) == 0) {
3747     #ifndef MCELL3_MOLECULE_MOVES_WITH_MAXIMUM_TIMESTEP
3748       if (m-&gt;get_time_step(m) &gt; 1.0) {
3749         double f = 1.0 + 0.2 * (m-&gt;t - m-&gt;birthday / world-&gt;time_unit);
3750         if (f &lt; 1 - EPS_C)
3751           mcell_internal_error("A %s molecule is scheduled to move before it "
3752                                "was born [birthday=%.15g, t=%.15g]",
3753                                spec-&gt;sym-&gt;name, m-&gt;birthday,
3754                                m-&gt;t * world-&gt;time_unit);
3755         if (*max_time &gt; f) {
3756           *max_time = f;
3757         }
3758         if (f &gt; m-&gt;subvol-&gt;local_storage-&gt;max_timestep) {
3759           m-&gt;flags |= MATURE_MOLECULE;
3760         }
3761       }
3762     #else
3763       m-&gt;flags |= MATURE_MOLECULE;
3764     #endif     }
3765   }
3766 }
3767 void count_tentative_collisions(
3768   struct volume *world, struct collision **tc, struct collision *smash, struct volume_molecule* m,
3769   struct species *spec, double t_confident, int destroy_flag,
3770   struct periodic_image *box, u_long id) {
3771   int crossed_flag = 1;
3772   if (destroy_flag == 1) {
3773     crossed_flag = 0; 
3774   }
3775   struct collision *ttv = *tc;
3776   for (; ttv != NULL &amp;&amp; ttv-&gt;t &lt;= t_confident; ttv = ttv-&gt;next) {
3777     if (!(ttv-&gt;what &amp; COLLIDE_WALL)) {
3778       continue;
3779     }
3780     if (!(spec-&gt;flags &amp; ((struct wall *)ttv-&gt;target)-&gt;flags &amp; COUNT_SOME_MASK)) {
3781       continue;
3782     }
3783     count_region_update(
3784       world, m, spec, id, box, ((struct wall *)ttv-&gt;target)-&gt;counting_regions,
3785       ((ttv-&gt;what &amp; COLLIDE_MASK) == COLLIDE_FRONT) ? 1 : -1, crossed_flag,
3786       &amp;(ttv-&gt;loc), ttv-&gt;t);
3787     if ((destroy_flag) &amp;&amp; (ttv == smash)) {
3788       break;
3789     }
3790   }
3791   *tc = ttv;
3792 }
3793 bool periodicbox_in_surfmol_list(
3794     struct periodic_image *periodic_box,
3795     struct surface_molecule_list *sml) {
3796   for (struct surface_molecule_list *sml_curr = sml;
3797        sml_curr != NULL;
3798        sml_curr = sml_curr-&gt;next) {
3799     struct surface_molecule *sm = sml_curr-&gt;sm;
3800     if (sm &amp;&amp; periodic_boxes_are_identical(periodic_box, sm-&gt;periodic_box)) {
3801       return true;
3802     }
3803   }
3804   return false;
3805 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
