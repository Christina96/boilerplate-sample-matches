<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for nearest.c &amp; jxlsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for nearest.c &amp; jxlsave.c
      </h3>
<h1 align="center">
        5.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>nearest.c (6.930693%)<th>jxlsave.c (4.229607%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(298-311)<td><a href="#" name="0">(540-553)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>nearest.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include &lt;vips/internal.h&gt;
7 #include "pmorphology.h"
8 typedef struct _Seed {
9 	int x;
10 	int y;
11 	int r;
12 	int octant_mask;
13 } Seed;
14 typedef struct _VipsFillNearest {
15 	VipsMorphology parent_instance;
16 	VipsImage *out;
17 	VipsImage *distance;
18 	int width;
19 	int height;
20 	GArray *seeds;
21 } VipsFillNearest;
22 typedef VipsMorphologyClass VipsFillNearestClass;
23 G_DEFINE_TYPE( VipsFillNearest, vips_fill_nearest, VIPS_TYPE_MORPHOLOGY );
24 static void
25 vips_fill_nearest_finalize( GObject *gobject )
26 {
27 	VipsFillNearest *nearest = (VipsFillNearest *) gobject;
28 #ifdef DEBUG
29 	printf( "vips_fill_nearest_finalize: " );
30 	vips_object_print_name( VIPS_OBJECT( gobject ) );
31 	printf( "\n" );
32 	VIPS_FREEF( g_array_unref, nearest-&gt;seeds ); 
33 	G_OBJECT_CLASS( vips_fill_nearest_parent_class )-&gt;finalize( gobject );
34 }
35 struct _Circle;
36 typedef void (*VipsFillNearestPixel)( struct _Circle *circle, 
37 	int x, int y, int octant );
38 typedef struct _Circle {
39 	VipsFillNearest *nearest;
40 	Seed *seed;
41 	int octant_mask;
42 	VipsFillNearestPixel nearest_pixel;
43 } Circle;
44 static void 
45 vips_fill_nearest_pixel( Circle *circle, int x, int y, int octant )
46 {
47 	float *p;
48 	float radius;
49 	int dx, dy;
50 	if( (circle-&gt;seed-&gt;octant_mask &amp; (1 &lt;&lt; octant)) == 0 )
51 		return;
52 	p = (float *) VIPS_IMAGE_ADDR( circle-&gt;nearest-&gt;distance, x, y );
53 	dx = x - circle-&gt;seed-&gt;x;
54 	dy = y - circle-&gt;seed-&gt;y;
55 	radius = sqrt( dx * dx + dy * dy );
56 	if( p[0] == 0 ||
57 		p[0] &gt; radius ) {
58 		VipsMorphology *morphology = VIPS_MORPHOLOGY( circle-&gt;nearest );
59 		VipsImage *in = morphology-&gt;in;
60 		int ps = VIPS_IMAGE_SIZEOF_PEL( in );
61 		VipsPel *pi = VIPS_IMAGE_ADDR( in,
62 			circle-&gt;seed-&gt;x, circle-&gt;seed-&gt;y );
63 		VipsPel *qi = VIPS_IMAGE_ADDR( circle-&gt;nearest-&gt;out, 
64 			x, y ); 
65 		int i;
66 		p[0] = radius;
67 		circle-&gt;octant_mask |= 1 &lt;&lt; octant;
68 		for( i = 0; i &lt; ps; i++ )
69 			qi[i] = pi[i];
70 	}
71 }
72 static void 
73 vips_fill_nearest_pixel_clip( Circle *circle, int x, int y, int octant )
74 {
75 	if( (circle-&gt;seed-&gt;octant_mask &amp; (1 &lt;&lt; octant)) == 0 )
76 		return;
77 	if( x &gt;= 0 &amp;&amp;
78 		x &lt; circle-&gt;nearest-&gt;width &amp;&amp;
79 		y &gt;= 0 &amp;&amp;
80 		y &lt; circle-&gt;nearest-&gt;height )
81 		vips_fill_nearest_pixel( circle, x, y, octant );
82 }
83 static void
84 vips_fill_nearest_scanline( VipsImage *image, 
85 	int y, int x1, int x2, int quadrant, void *client )
86 {
87 	Circle *circle = (Circle *) client;
88 	circle-&gt;nearest_pixel( circle, x1, y, quadrant );
89 	circle-&gt;nearest_pixel( circle, x2, y, quadrant + 4 );
90 	if( quadrant == 0 ) {
91 		circle-&gt;nearest_pixel( circle, x1, y - 1, quadrant );
92 		circle-&gt;nearest_pixel( circle, x2, y - 1, quadrant + 4 );
93 	}
94 	else if( quadrant == 1 ) {
95 		circle-&gt;nearest_pixel( circle, x1, y + 1, quadrant );
96 		circle-&gt;nearest_pixel( circle, x2, y + 1, quadrant + 4 );
97 	}
98 	else {
99 		circle-&gt;nearest_pixel( circle, x1 + 1, y, quadrant );
100 		circle-&gt;nearest_pixel( circle, x2 - 1, y, quadrant + 4 );
101 	}
102 }
103 static void
104 vips_fill_nearest_grow_seed( VipsFillNearest *nearest, Seed *seed )
105 {
106 	Circle circle;
107 	circle.nearest = nearest;
108 	circle.seed = seed;
109 	circle.octant_mask = 0;
110 	if( seed-&gt;x - seed-&gt;r &gt;= 0 &amp;&amp;
111 		seed-&gt;x + seed-&gt;r &lt; nearest-&gt;width &amp;&amp;
112 		seed-&gt;y - seed-&gt;r &gt;= 0 &amp;&amp;
113 		seed-&gt;y + seed-&gt;r &lt; nearest-&gt;height )
114 		circle.nearest_pixel = vips_fill_nearest_pixel;
115 	else
116 		circle.nearest_pixel = vips_fill_nearest_pixel_clip;
117 	vips__draw_circle_direct( nearest-&gt;distance, 
118 		seed-&gt;x, seed-&gt;y, seed-&gt;r, 
119 		vips_fill_nearest_scanline, &amp;circle );
120 	seed-&gt;octant_mask = circle.octant_mask; 
121 	seed-&gt;r += 1;
122 }
123 static int
124 vips_fill_nearest_build( VipsObject *object )
125 {
126 	VipsMorphology *morphology = VIPS_MORPHOLOGY( object );
127 	VipsFillNearest *nearest = (VipsFillNearest *) object;
128 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 2 );
129 	int ps;
130 	int x, y, i;
131 	if( VIPS_OBJECT_CLASS( vips_fill_nearest_parent_class )-&gt;
132 		build( object ) )
133 		return( -1 );
134 	if( vips_image_wio_input( morphology-&gt;in ) )
135 		return( -1 ); 
136 	nearest-&gt;width = morphology-&gt;in-&gt;Xsize;
137 	nearest-&gt;height = morphology-&gt;in-&gt;Ysize;
138 	ps = VIPS_IMAGE_SIZEOF_PEL( morphology-&gt;in );
139 	nearest-&gt;seeds = g_array_new( FALSE, FALSE, sizeof( Seed ) );
140 	for( y = 0; y &lt; nearest-&gt;height; y++ )  {
141 		VipsPel *p;
142 		p = VIPS_IMAGE_ADDR( morphology-&gt;in, 0, y ); 
143 		for( x = 0; x &lt; nearest-&gt;width; x++ ) {
144 			for( i = 0; i &lt; ps; i++ )
145 				if( p[i] )
146 					break;
147 			if( i != ps ) { 
148 				Seed *seed;
149 				g_array_set_size( nearest-&gt;seeds, 
150 					nearest-&gt;seeds-&gt;len + 1 );
151 				seed = &amp;g_array_index( nearest-&gt;seeds, 
152 					Seed, nearest-&gt;seeds-&gt;len - 1 );
153 				seed-&gt;x = x;
154 				seed-&gt;y = y;
155 				seed-&gt;r = 1;
156 				seed-&gt;octant_mask = 255;
157 			}
158 			p += ps;
159 		}
160 	}
161 	g_object_set( object, "distance", vips_image_new_memory(), NULL );
162 	if( vips_black( &amp;t[1], nearest-&gt;width, nearest-&gt;height, NULL ) ||
163 		vips_cast( t[1], &amp;t[2], VIPS_FORMAT_FLOAT, NULL ) || 
164 		vips_image_write( t[2], nearest-&gt;distance ) )
165 		return( -1 );
166 	g_object_set( object, "out", vips_image_new_memory(), NULL );
167 	if( vips_image_write( morphology-&gt;in, nearest-&gt;out ) )
168 		return( -1 );
169 	while( nearest-&gt;seeds-&gt;len &gt; 0 ) {
170 #ifdef DEBUG
171 		printf( "looping for %d seeds ...\n", nearest-&gt;seeds-&gt;len );
172 		for( i = 0; i &lt; nearest-&gt;seeds-&gt;len; i++ ) 
173 			vips_fill_nearest_grow_seed( nearest, 
174 				&amp;g_array_index( nearest-&gt;seeds, Seed, i ) );
175 		i = 0; 
176 		while( i &lt; nearest-&gt;seeds-&gt;len )  {
177 			Seed *seed = &amp;g_array_index( nearest-&gt;seeds, Seed, i );
178 			if( seed-&gt;octant_mask == 0 )
179 				g_array_remove_index_fast( nearest-&gt;seeds, i );
180 			else
181 				i += 1;
182 <a name="0"></a>		}
183 	}
184 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
185 }
186 static void
187 vips_fill_nearest_class_init( VipsFillNearestClass *class )
188 {
189 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
190 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
191 	gobject_class-&gt;finalize = vips_fill_nearest_finalize;
192 	gobject_class-&gt;set_property = vips_object_set_property;
193 	gobject_class-&gt;get_property = vips_object_get_property;
194 	vobject_class-&gt;nickname = "fill_nearest";</b></font>
195 	vobject_class-&gt;description = 
196 		_( "fill image zeros with nearest non-zero pixel" ); 
197 	vobject_class-&gt;build = vips_fill_nearest_build;
198 	VIPS_ARG_IMAGE( class, "out", 2, 
199 		_( "Out" ), 
200 		_( "Value of nearest non-zero pixel" ),
201 		VIPS_ARGUMENT_REQUIRED_OUTPUT,
202 		G_STRUCT_OFFSET( VipsFillNearest, out ) ); 
203 	VIPS_ARG_IMAGE( class, "distance", 3, 
204 		_( "Distance" ), 
205 		_( "Distance to nearest non-zero pixel" ),
206 		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
207 		G_STRUCT_OFFSET( VipsFillNearest, distance ) ); 
208 }
209 static void
210 vips_fill_nearest_init( VipsFillNearest *nearest )
211 {
212 }
213 int
214 vips_fill_nearest( VipsImage *in, VipsImage **out, ... ) 
215 {
216 	va_list ap;
217 	int result;
218 	va_start( ap, out );
219 	result = vips_call_split( "fill_nearest", ap, in, out );
220 	va_end( ap );
221 	return( result );
222 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>jxlsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #ifdef HAVE_LIBJXL
5 #include &lt;stdio.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include &lt;jxl/encode.h&gt;
11 #include &lt;jxl/thread_parallel_runner.h&gt;
12 #include "pforeign.h"
13 #define OUTPUT_BUFFER_SIZE (4096)
14 typedef struct _VipsForeignSaveJxl {
15 	VipsForeignSave parent_object;
16 	VipsTarget *target;
17 	int tier;
18 	double distance;
19 	int effort;
20 	gboolean lossless;
21 	int Q;
22 	JxlBasicInfo info;
23 	JxlColorEncoding color_encoding;
24 	JxlPixelFormat format;
25 	void *runner;
26 	JxlEncoder *encoder;
27 	uint8_t output_buffer[OUTPUT_BUFFER_SIZE];
28 } VipsForeignSaveJxl;
29 typedef VipsForeignSaveClass VipsForeignSaveJxlClass;
30 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveJxl, vips_foreign_save_jxl, 
31 	VIPS_TYPE_FOREIGN_SAVE );
32 static void
33 vips_foreign_save_jxl_dispose( GObject *gobject )
34 {
35 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) gobject;
36 	VIPS_FREEF( JxlThreadParallelRunnerDestroy, jxl-&gt;runner );
37 	VIPS_FREEF( JxlEncoderDestroy, jxl-&gt;encoder );
38 	G_OBJECT_CLASS( vips_foreign_save_jxl_parent_class )-&gt;
39 		dispose( gobject );
40 }
41 static void
42 vips_foreign_save_jxl_error( VipsForeignSaveJxl *jxl, const char *details )
43 {
44 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( jxl );
45 	vips_error( class-&gt;nickname, "error %s", details );
46 }
47 #ifdef DEBUG
48 static void
49 vips_foreign_save_jxl_print_info( JxlBasicInfo *info )
50 {
51 	printf( "JxlBasicInfo:\n" );
52 	printf( "    have_container = %d\n", info-&gt;have_container );
53 	printf( "    xsize = %d\n", info-&gt;xsize );
54 	printf( "    ysize = %d\n", info-&gt;ysize );
55 	printf( "    bits_per_sample = %d\n", info-&gt;bits_per_sample );
56 	printf( "    exponent_bits_per_sample = %d\n", 
57 		info-&gt;exponent_bits_per_sample );
58 	printf( "    intensity_target = %g\n", info-&gt;intensity_target );
59 	printf( "    min_nits = %g\n", info-&gt;min_nits );
60 	printf( "    relative_to_max_display = %d\n", 
61 		info-&gt;relative_to_max_display );
62 	printf( "    linear_below = %g\n", info-&gt;linear_below );
63 	printf( "    uses_original_profile = %d\n", 
64 		info-&gt;uses_original_profile );
65 	printf( "    have_preview = %d\n", info-&gt;have_preview );
66 	printf( "    have_animation = %d\n", info-&gt;have_animation );
67 	printf( "    orientation = %d\n", info-&gt;orientation );
68 	printf( "    num_color_channels = %d\n", info-&gt;num_color_channels );
69 	printf( "    num_extra_channels = %d\n", info-&gt;num_extra_channels );
70 	printf( "    alpha_bits = %d\n", info-&gt;alpha_bits );
71 	printf( "    alpha_exponent_bits = %d\n", info-&gt;alpha_exponent_bits );
72 	printf( "    alpha_premultiplied = %d\n", info-&gt;alpha_premultiplied );
73 	printf( "    preview.xsize = %d\n", info-&gt;preview.xsize );
74 	printf( "    preview.ysize = %d\n", info-&gt;preview.ysize );
75 	printf( "    animation.tps_numerator = %d\n", 
76 		info-&gt;animation.tps_numerator );
77 	printf( "    animation.tps_denominator = %d\n", 
78 		info-&gt;animation.tps_denominator );
79 	printf( "    animation.num_loops = %d\n", info-&gt;animation.num_loops );
80 	printf( "    animation.have_timecodes = %d\n", 
81 		info-&gt;animation.have_timecodes );
82 }
83 static void
84 vips_foreign_save_jxl_print_format( JxlPixelFormat *format )
85 {
86 	printf( "JxlPixelFormat:\n" );
87 	printf( "    data_type = " );
88 	switch( format-&gt;data_type ) {
89 	case JXL_TYPE_UINT8: 
90 		printf( "JXL_TYPE_UINT8" );
91 		break;
92 	case JXL_TYPE_UINT16: 
93 		printf( "JXL_TYPE_UINT16" );
94 		break;
95 	case JXL_TYPE_UINT32: 
96 		printf( "JXL_TYPE_UINT32" );
97 		break;
98 	case JXL_TYPE_FLOAT: 
99 		printf( "JXL_TYPE_FLOAT" );
100 		break;
101 	default:
102 		printf( "(unknown)" );
103 		break;
104 	}
105 	printf( "\n" );
106 	printf( "    num_channels = %d\n", format-&gt;num_channels );
107 	printf( "    endianness = %d\n", format-&gt;endianness );
108 	printf( "    align = %zd\n", format-&gt;align );
109 }
110 static void
111 vips_foreign_save_jxl_print_status( JxlEncoderStatus status )
112 {
113 	switch( status ) {
114 	case JXL_ENC_SUCCESS:
115 		printf( "JXL_ENC_SUCCESS\n" );
116 		break;
117 	case JXL_ENC_ERROR:
118 		printf( "JXL_ENC_ERROR\n" );
119 		break;
120 	case JXL_ENC_NEED_MORE_OUTPUT:
121 		printf( "JXL_ENC_NEED_MORE_OUTPUT\n" );
122 		break;
123 	case JXL_ENC_NOT_SUPPORTED:
124 		printf( "JXL_ENC_NOT_SUPPORTED\n" );
125 		break;
126 	default:
127 		printf( "JXL_ENC_&lt;unknown&gt;\n" );
128 		break;
129 	}
130 }
131 static int
132 vips_foreign_save_jxl_build( VipsObject *object )
133 {
134 	VipsForeignSave *save = (VipsForeignSave *) object;
135 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) object;
136 	JxlEncoderOptions *options;
137 	JxlEncoderStatus status;
138 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jxl_parent_class )-&gt;
139 		build( object ) )
140 		return( -1 );
141 	if( !vips_object_argument_isset( object, "distance" ) ) 
142 		jxl-&gt;distance = jxl-&gt;Q &gt;= 30 ?
143 			0.1 + (100 - jxl-&gt;Q) * 0.09 :
144 			6.4 + pow(2.5, (30 - jxl-&gt;Q) / 5.0f) / 6.25f;
145 	if( jxl-&gt;distance == 0 )
146 		jxl-&gt;lossless = TRUE;
147 	jxl-&gt;runner = JxlThreadParallelRunnerCreate( NULL, 
148 		vips_concurrency_get() );
149 	jxl-&gt;encoder = JxlEncoderCreate( NULL );
150 	if( JxlEncoderSetParallelRunner( jxl-&gt;encoder, 
151 		JxlThreadParallelRunner, jxl-&gt;runner ) ) {
152 		vips_foreign_save_jxl_error( jxl, 
153 			"JxlDecoderSetParallelRunner" );
154 		return( -1 );
155 	}
156 	switch( save-&gt;ready-&gt;BandFmt ) {
157 	case VIPS_FORMAT_UCHAR:
158 		jxl-&gt;info.bits_per_sample = 8;
159 		jxl-&gt;info.exponent_bits_per_sample = 0;
160 		jxl-&gt;format.data_type = JXL_TYPE_UINT8;
161 		break;
162 	case VIPS_FORMAT_USHORT:
163 		jxl-&gt;info.bits_per_sample = 16;
164 		jxl-&gt;info.exponent_bits_per_sample = 0;
165 		jxl-&gt;format.data_type = JXL_TYPE_UINT16;
166 		break;
167 	case VIPS_FORMAT_UINT:
168 		jxl-&gt;info.bits_per_sample = 32;
169 		jxl-&gt;info.exponent_bits_per_sample = 0;
170 		jxl-&gt;format.data_type = JXL_TYPE_UINT32;
171 		break;
172 	case VIPS_FORMAT_FLOAT:
173 		jxl-&gt;info.bits_per_sample = 32;
174 		jxl-&gt;info.exponent_bits_per_sample = 8;
175 		jxl-&gt;format.data_type = JXL_TYPE_FLOAT;
176 		break;
177 	default:
178 		g_assert_not_reached();
179 		break;
180 	}
181 	switch( save-&gt;ready-&gt;Type ) {
182 	case VIPS_INTERPRETATION_B_W:
183 	case VIPS_INTERPRETATION_GREY16:
184 		jxl-&gt;info.num_color_channels = 1;
185 		break;
186 	case VIPS_INTERPRETATION_sRGB:
187 	case VIPS_INTERPRETATION_scRGB:
188 	case VIPS_INTERPRETATION_RGB16:
189 		jxl-&gt;info.num_color_channels = 3;
190 		break;
191 	default:
192 		jxl-&gt;info.num_color_channels = save-&gt;ready-&gt;Bands;
193 	}
194 	jxl-&gt;info.num_extra_channels = VIPS_MAX( 0, 
195 		save-&gt;ready-&gt;Bands - jxl-&gt;info.num_color_channels );
196 	jxl-&gt;info.xsize = save-&gt;ready-&gt;Xsize;
197 	jxl-&gt;info.ysize = save-&gt;ready-&gt;Ysize;
198 	jxl-&gt;format.num_channels = save-&gt;ready-&gt;Bands;
199 	jxl-&gt;format.endianness = JXL_NATIVE_ENDIAN;
200 	jxl-&gt;format.align = 0;
201 	if( vips_image_hasalpha( save-&gt;ready ) ) {
202 		jxl-&gt;info.alpha_bits = jxl-&gt;info.bits_per_sample;
203 		jxl-&gt;info.alpha_exponent_bits = 
204 			jxl-&gt;info.exponent_bits_per_sample;
205 	}
206 	else {
207 		jxl-&gt;info.alpha_exponent_bits = 0;
208 		jxl-&gt;info.alpha_bits = 0;
209 	}
210 	if( vips_image_get_typeof( save-&gt;ready, "stonits" ) ) {
211 		double stonits;
212 		if( vips_image_get_double( save-&gt;ready, "stonits", &amp;stonits ) )
213 			return( -1 );
214 		jxl-&gt;info.intensity_target = stonits;
215 	}
216 	jxl-&gt;info.uses_original_profile = JXL_FALSE;
217 	if( JxlEncoderSetBasicInfo( jxl-&gt;encoder, &amp;jxl-&gt;info ) ) {
218 		vips_foreign_save_jxl_error( jxl, "JxlEncoderSetBasicInfo" );
219 		return( -1 );
220 	}
221 	JxlColorEncodingSetToSRGB( &amp;jxl-&gt;color_encoding, 
222 		jxl-&gt;format.num_channels &lt; 3 );
223 	if( JxlEncoderSetColorEncoding( jxl-&gt;encoder, &amp;jxl-&gt;color_encoding ) ) {
224 		vips_foreign_save_jxl_error( jxl, 
225 			"JxlEncoderSetColorEncoding" );
226 		return( -1 );
227 	}
228 	if( vips_image_wio_input( save-&gt;ready ) )
229 		return( -1 );
230 	options = JxlEncoderOptionsCreate( jxl-&gt;encoder, NULL );
231 	JxlEncoderOptionsSetDecodingSpeed( options, jxl-&gt;tier );
232 	JxlEncoderOptionsSetDistance( options, jxl-&gt;distance );
233 	JxlEncoderOptionsSetEffort( options, jxl-&gt;effort );
234 	JxlEncoderOptionsSetLossless( options, jxl-&gt;lossless );
235 #ifdef DEBUG
236 	vips_foreign_save_jxl_print_info( &amp;jxl-&gt;info );
237 	vips_foreign_save_jxl_print_format( &amp;jxl-&gt;format );
238 	printf( "JxlEncoderOptions:\n" );
239 	printf( "    tier = %d\n", jxl-&gt;tier );
240 	printf( "    distance = %g\n", jxl-&gt;distance );
241 	printf( "    effort = %d\n", jxl-&gt;effort );
242 	printf( "    lossless = %d\n", jxl-&gt;lossless );
243 	if( JxlEncoderAddImageFrame( options, &amp;jxl-&gt;format, 
244 		VIPS_IMAGE_ADDR( save-&gt;ready, 0, 0 ),
245 		VIPS_IMAGE_SIZEOF_IMAGE( save-&gt;ready ) ) ) { 
246 		vips_foreign_save_jxl_error( jxl, "JxlEncoderAddImageFrame" );
247 		return( -1 );
248 	}
249 	do {
250 		uint8_t *out;
251 		size_t avail_out;
252 		out = jxl-&gt;output_buffer;
253 		avail_out = OUTPUT_BUFFER_SIZE;
254 		status = JxlEncoderProcessOutput( jxl-&gt;encoder,
255 			&amp;out, &amp;avail_out );
256 		switch( status ) {
257 		case JXL_ENC_SUCCESS:
258 		case JXL_ENC_NEED_MORE_OUTPUT:
259 			if( vips_target_write( jxl-&gt;target,
260 				jxl-&gt;output_buffer, 
261 				OUTPUT_BUFFER_SIZE - avail_out ) )
262 				return( -1 );
263 			break;
264 		default:
265 			vips_foreign_save_jxl_error( jxl, 
266 				"JxlEncoderProcessOutput" );
267 #ifdef DEBUG
268 			vips_foreign_save_jxl_print_status( status );
269 			return( -1 );
270 		}
271 	} while( status != JXL_ENC_SUCCESS );
272 	vips_target_finish( jxl-&gt;target );
273 	return( 0 );
274 }
275 #define UC VIPS_FORMAT_UCHAR
276 #define US VIPS_FORMAT_USHORT
277 #define UI VIPS_FORMAT_UINT
278 #define F VIPS_FORMAT_FLOAT
279 static int bandfmt_jpeg[10] = {
280 	UC, UC, US, US, UI, UI, F, F, F, F
281 };
282 static void
283 vips_foreign_save_jxl_class_init( VipsForeignSaveJxlClass *class )
284 {
285 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
286 	VipsObjectClass *object_class = (VipsObjectClass *) class;
287 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
288 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
289 	gobject_class-&gt;dispose = vips_foreign_save_jxl_dispose;
290 	gobject_class-&gt;set_property = vips_object_set_property;
291 	gobject_class-&gt;get_property = vips_object_get_property;
292 	object_class-&gt;nickname = "jxlsave_base";
293 	object_class-&gt;description = _( "save image in JPEG-XL format" );
294 	object_class-&gt;build = vips_foreign_save_jxl_build;
295 	foreign_class-&gt;suffs = vips__jxl_suffs;
296 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
297 	save_class-&gt;format_table = bandfmt_jpeg;
298 	VIPS_ARG_INT( class, "tier", 10, 
299 		_( "Tier" ), 
300 		_( "Decode speed tier" ),
301 		VIPS_ARGUMENT_OPTIONAL_INPUT,
302 		G_STRUCT_OFFSET( VipsForeignSaveJxl, tier ),
303 		0, 4, 0 );
304 	VIPS_ARG_DOUBLE( class, "distance", 11, 
305 		_( "Distance" ), 
306 		_( "Target butteraugli distance" ),
307 		VIPS_ARGUMENT_OPTIONAL_INPUT,
308 		G_STRUCT_OFFSET( VipsForeignSaveJxl, distance ),
309 		0, 15, 1.0 );
310 	VIPS_ARG_INT( class, "effort", 12, 
311 		_( "effort" ), 
312 		_( "Encoding effort" ),
313 		VIPS_ARGUMENT_OPTIONAL_INPUT,
314 		G_STRUCT_OFFSET( VipsForeignSaveJxl, effort ),
315 		3, 9, 7 );
316 	VIPS_ARG_BOOL( class, "lossless", 13, 
317 		_( "Lossless" ), 
318 		_( "Enable lossless compression" ),
319 		VIPS_ARGUMENT_OPTIONAL_INPUT,
320 		G_STRUCT_OFFSET( VipsForeignSaveJxl, lossless ),
321 		FALSE ); 
322 	VIPS_ARG_INT( class, "Q", 14, 
323 		_( "Q" ), 
324 		_( "Quality factor" ),
325 		VIPS_ARGUMENT_OPTIONAL_INPUT,
326 		G_STRUCT_OFFSET( VipsForeignSaveJxl, Q ),
327 		0, 100, 75 );
328 }
329 static void
330 vips_foreign_save_jxl_init( VipsForeignSaveJxl *jxl )
331 {
332 	jxl-&gt;tier = 0;
333 	jxl-&gt;distance = 1.0;
334 	jxl-&gt;effort = 7;
335 	jxl-&gt;lossless = FALSE;
336 	jxl-&gt;Q = 75;
337 }
338 typedef struct _VipsForeignSaveJxlFile {
339 	VipsForeignSaveJxl parent_object;
340 	char *filename; 
341 } VipsForeignSaveJxlFile;
342 typedef VipsForeignSaveJxlClass VipsForeignSaveJxlFileClass;
343 G_DEFINE_TYPE( VipsForeignSaveJxlFile, vips_foreign_save_jxl_file, 
344 	vips_foreign_save_jxl_get_type() );
345 static int
346 vips_foreign_save_jxl_file_build( VipsObject *object )
347 {
348 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) object;
349 	VipsForeignSaveJxlFile *file = (VipsForeignSaveJxlFile *) object;
350 	if( !(jxl-&gt;target = vips_target_new_to_file( file-&gt;filename )) )
351 		return( -1 );
352 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jxl_file_parent_class )-&gt;
353 <a name="0"></a>		build( object ) )
354 		return( -1 );
355 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
356 }
357 static void
358 vips_foreign_save_jxl_file_class_init( VipsForeignSaveJxlFileClass *class )
359 {
360 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
361 	VipsObjectClass *object_class = (VipsObjectClass *) class;
362 	gobject_class-&gt;set_property = vips_object_set_property;
363 	gobject_class-&gt;get_property = vips_object_get_property;
364 	object_class-&gt;nickname = "jxlsave";
365 	object_class-&gt;build = vips_foreign_save_jxl_file_build;</b></font>
366 	VIPS_ARG_STRING( class, "filename", 1, 
367 		_( "Filename" ),
368 		_( "Filename to load from" ),
369 		VIPS_ARGUMENT_REQUIRED_INPUT, 
370 		G_STRUCT_OFFSET( VipsForeignSaveJxlFile, filename ),
371 		NULL );
372 }
373 static void
374 vips_foreign_save_jxl_file_init( VipsForeignSaveJxlFile *file )
375 {
376 }
377 typedef struct _VipsForeignSaveJxlBuffer {
378 	VipsForeignSaveJxl parent_object;
379 	VipsArea *buf;
380 } VipsForeignSaveJxlBuffer;
381 typedef VipsForeignSaveJxlClass VipsForeignSaveJxlBufferClass;
382 G_DEFINE_TYPE( VipsForeignSaveJxlBuffer, vips_foreign_save_jxl_buffer, 
383 	vips_foreign_save_jxl_get_type() );
384 static int
385 vips_foreign_save_jxl_buffer_build( VipsObject *object )
386 {
387 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) object;
388 	VipsForeignSaveJxlBuffer *buffer = 
389 		(VipsForeignSaveJxlBuffer *) object;
390 	VipsBlob *blob;
391 	if( !(jxl-&gt;target = vips_target_new_to_memory()) )
392 		return( -1 );
393 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jxl_buffer_parent_class )-&gt;
394 		build( object ) )
395 		return( -1 );
396 	g_object_get( jxl-&gt;target, "blob", &amp;blob, NULL );
397 	g_object_set( buffer, "buffer", blob, NULL );
398 	vips_area_unref( VIPS_AREA( blob ) );
399 	return( 0 );
400 }
401 static void
402 vips_foreign_save_jxl_buffer_class_init( 
403 	VipsForeignSaveJxlBufferClass *class )
404 {
405 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
406 	VipsObjectClass *object_class = (VipsObjectClass *) class;
407 	gobject_class-&gt;set_property = vips_object_set_property;
408 	gobject_class-&gt;get_property = vips_object_get_property;
409 	object_class-&gt;nickname = "jxlsave_buffer";
410 	object_class-&gt;build = vips_foreign_save_jxl_buffer_build;
411 	VIPS_ARG_BOXED( class, "buffer", 1, 
412 		_( "Buffer" ),
413 		_( "Buffer to save to" ),
414 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
415 		G_STRUCT_OFFSET( VipsForeignSaveJxlBuffer, buf ),
416 		VIPS_TYPE_BLOB );
417 }
418 static void
419 vips_foreign_save_jxl_buffer_init( VipsForeignSaveJxlBuffer *buffer )
420 {
421 }
422 typedef struct _VipsForeignSaveJxlTarget {
423 	VipsForeignSaveJxl parent_object;
424 	VipsTarget *target;
425 } VipsForeignSaveJxlTarget;
426 typedef VipsForeignSaveJxlClass VipsForeignSaveJxlTargetClass;
427 G_DEFINE_TYPE( VipsForeignSaveJxlTarget, vips_foreign_save_jxl_target, 
428 	vips_foreign_save_jxl_get_type() );
429 static int
430 vips_foreign_save_jxl_target_build( VipsObject *object )
431 {
432 	VipsForeignSaveJxl *jxl = (VipsForeignSaveJxl *) object;
433 	VipsForeignSaveJxlTarget *target = 
434 		(VipsForeignSaveJxlTarget *) object;
435 	if( target-&gt;target ) {
436 		jxl-&gt;target = target-&gt;target;
437 		g_object_ref( jxl-&gt;target );
438 	}
439 	if( VIPS_OBJECT_CLASS( vips_foreign_save_jxl_target_parent_class )-&gt;
440 		build( object ) )
441 		return( -1 );
442 	return( 0 );
443 }
444 static void
445 vips_foreign_save_jxl_target_class_init( 
446 	VipsForeignSaveJxlTargetClass *class )
447 {
448 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
449 	VipsObjectClass *object_class = (VipsObjectClass *) class;
450 	gobject_class-&gt;set_property = vips_object_set_property;
451 	gobject_class-&gt;get_property = vips_object_get_property;
452 	object_class-&gt;nickname = "jxlsave_target";
453 	object_class-&gt;build = vips_foreign_save_jxl_target_build;
454 	VIPS_ARG_OBJECT( class, "target", 1,
455 		_( "Target" ),
456 		_( "Target to save to" ),
457 		VIPS_ARGUMENT_REQUIRED_INPUT, 
458 		G_STRUCT_OFFSET( VipsForeignSaveJxlTarget, target ),
459 		VIPS_TYPE_TARGET );
460 }
461 static void
462 vips_foreign_save_jxl_target_init( VipsForeignSaveJxlTarget *target )
463 {
464 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
