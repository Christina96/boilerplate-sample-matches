<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for hist_plot.c &amp; foreign.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for hist_plot.c &amp; foreign.c
      </h3>
<h1 align="center">
        1.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>hist_plot.c (6.0085835%)<th>foreign.c (1.0401188%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(283-296)<td><a href="#" name="0">(356-369)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>hist_plot.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include "phistogram.h"
9 typedef struct _VipsHistPlot {
10 	VipsOperation parent_instance;
11 	VipsImage *in;
12 	VipsImage *out;
13 } VipsHistPlot;
14 typedef VipsOperationClass VipsHistPlotClass;
15 G_DEFINE_TYPE( VipsHistPlot, vips_hist_plot, VIPS_TYPE_OPERATION );
16 #define VERT( TYPE ) { \
17 	TYPE *p1 = (TYPE *) p; \
18 	\
19 	for( x = le; x &lt; ri; x++ ) { \
20 		for( z = 0; z &lt; nb; z++ )  \
21 			q[z] = p1[z] &lt; ((TYPE) x) ? 0 : 255; \
22 		\
23 		q += nb; \
24 	} \
25 }
26 static int
27 vips_hist_plot_vert_gen( VipsRegion *or, void *seq, void *a, void *b,
28 	gboolean *stop )
29 {
30 	VipsImage *in = (VipsImage *) a;
31 	VipsRect *r = &amp;or-&gt;valid;
32 	int le = r-&gt;left;
33 	int to = r-&gt;top;
34 	int ri = VIPS_RECT_RIGHT( r );
35 	int bo = VIPS_RECT_BOTTOM( r );
36 	int nb = in-&gt;Bands;
37 	int x, y, z;
38 	for( y = to; y &lt; bo; y++ ) {
39 		VipsPel *q = VIPS_REGION_ADDR( or, le, y );
40 		VipsPel *p = VIPS_IMAGE_ADDR( in, 0, y );
41 		switch( in-&gt;BandFmt ) {
42 		case VIPS_FORMAT_UCHAR: 	VERT( unsigned char ); break;
43 		case VIPS_FORMAT_CHAR: 		VERT( signed char ); break; 
44 		case VIPS_FORMAT_USHORT: 	VERT( unsigned short ); break; 
45 		case VIPS_FORMAT_SHORT: 	VERT( signed short ); break; 
46 		case VIPS_FORMAT_UINT: 		VERT( unsigned int ); break; 
47 		case VIPS_FORMAT_INT: 		VERT( signed int );  break; 
48 		case VIPS_FORMAT_FLOAT: 	VERT( float ); break; 
49 		case VIPS_FORMAT_DOUBLE:	VERT( double ); break; 
50 		default:
51 			g_assert_not_reached(); 
52 		}
53 	}
54 	return( 0 );
55 }
56 #define HORZ( TYPE ) { \
57 	TYPE *p1 = (TYPE *) p; \
58 	\
59 	for( y = to; y &lt; bo; y++ ) { \
60 		for( z = 0; z &lt; nb; z++ )  \
61 			q[z] = p1[z] &lt; ((TYPE) (ht - y)) ? 0 : 255; \
62 		\
63 		q += lsk; \
64 	} \
65 }
66 static int
67 vips_hist_plot_horz_gen( VipsRegion *or, void *seq, void *a, void *b,
68 	gboolean *stop )
69 {
70 	VipsImage *in = (VipsImage *) a;
71 	VipsRect *r = &amp;or-&gt;valid;
72 	int le = r-&gt;left;
73 	int to = r-&gt;top;
74 	int ri = VIPS_RECT_RIGHT( r );
75 	int bo = VIPS_RECT_BOTTOM( r );
76 	int nb = in-&gt;Bands;
77 	int lsk = VIPS_REGION_LSKIP( or );
78 	int ht = or-&gt;im-&gt;Ysize;
79 	int x, y, z;
80 	for( x = le; x &lt; ri; x++ ) {
81 		VipsPel *q = VIPS_REGION_ADDR( or, x, to );
82 		VipsPel *p = VIPS_IMAGE_ADDR( in, x, 0 );
83 		switch( in-&gt;BandFmt ) {
84 		case VIPS_FORMAT_UCHAR: 	HORZ( unsigned char ); break;
85 		case VIPS_FORMAT_CHAR: 		HORZ( signed char ); break; 
86 		case VIPS_FORMAT_USHORT:	HORZ( unsigned short ); break; 
87 		case VIPS_FORMAT_SHORT: 	HORZ( signed short ); break; 
88 		case VIPS_FORMAT_UINT: 		HORZ( unsigned int ); break; 
89 		case VIPS_FORMAT_INT: 		HORZ( signed int );  break; 
90 		case VIPS_FORMAT_FLOAT: 	HORZ( float ); break; 
91 		case VIPS_FORMAT_DOUBLE:	HORZ( double ); break; 
92 		default:
93 			g_assert_not_reached();
94 		}
95 	}
96 	return( 0 );
97 }
98 static int
99 vips_hist_plot_build( VipsObject *object )
100 {
101 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
102 	VipsHistPlot *plot = (VipsHistPlot *) object;
103 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 2 );
104 	VipsImage *in;
105 	double min, max;
106 	int width, height, tsize;
107 	VipsGenerateFn generate_fn;
108 	g_object_set( plot, "out", vips_image_new(), NULL ); 
109 	if( VIPS_OBJECT_CLASS( vips_hist_plot_parent_class )-&gt;build( object ) )
110 		return( -1 );
111 	in = plot-&gt;in;
112 	if( vips_check_uncoded( class-&gt;nickname, in ) ||
113 		vips_check_noncomplex( class-&gt;nickname, in ) ||
114 		vips_check_hist( class-&gt;nickname, in ) )
115 		return( -1 );
116 	if( !vips_band_format_isuint( in-&gt;BandFmt ) &amp;&amp;
117 		vips_band_format_isint( in-&gt;BandFmt ) ) {
118 		double min;
119 		if( vips_min( in, &amp;min, NULL ) ||
120 			vips_linear1( in, &amp;t[0], 1.0, -min, NULL ) )
121 			return( -1 );
122 		in = t[0];
123 	}
124 	else if( vips_band_format_isfloat( in-&gt;BandFmt ) ) {
125 		int any = in-&gt;Xsize * in-&gt;Ysize;
126 		if( vips_stats( in, &amp;t[0], NULL ) )
127 			return( -1 );
128 		min = *VIPS_MATRIX( t[0], 0, 0 );
129 		max = *VIPS_MATRIX( t[0], 1, 0 );
130 		if( vips_linear1( in, &amp;t[1], 
131 			any / (max - min), -min * any / (max - min), NULL ) )
132 			return( -1 );
133 		in = t[1];
134 	}
135 	if( vips_image_wio_input( in ) )
136 		return( -1 );
137 	if( vips_max( in, &amp;max, NULL ) )
138 		return( -1 );
139 	g_assert( max &gt;= 0 );
140 	if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR )
141 		tsize = 256;
142 	else
143 		tsize = VIPS_CEIL( max );
144 	if( tsize == 0 )
145 		tsize = 1;
146 	if( in-&gt;Xsize == 1 ) {
147 		width = tsize;
148 		height = in-&gt;Ysize;
149 		generate_fn = vips_hist_plot_vert_gen;
150 	}
151 	else {
152 		width = in-&gt;Xsize;
153 		height = tsize;
154 		generate_fn = vips_hist_plot_horz_gen;
155 	}
156 	vips_image_init_fields( plot-&gt;out, width, height, in-&gt;Bands, 
157 		VIPS_FORMAT_UCHAR, VIPS_CODING_NONE, 
158 		VIPS_INTERPRETATION_HISTOGRAM, 
159 		1.0, 1.0 ); 
160 	if( vips_image_pipelinev( plot-&gt;out, VIPS_DEMAND_STYLE_ANY, NULL ) ||
161 		vips_image_generate( plot-&gt;out, 
162 			NULL, generate_fn, NULL, in, NULL ) )
163 <a name="0"></a>		return( -1 );
164 	return( 0 );
165 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
166 static void
167 vips_hist_plot_class_init( VipsHistPlotClass *class )
168 {
169 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
170 	VipsObjectClass *object_class = (VipsObjectClass *) class;
171 	gobject_class-&gt;set_property = vips_object_set_property;
172 	gobject_class-&gt;get_property = vips_object_get_property;
173 	object_class-&gt;nickname = "hist_plot";
174 	object_class-&gt;description = _( "plot histogram" );
175 	object_class-&gt;build = vips_hist_plot_build;</b></font>
176 	VIPS_ARG_IMAGE( class, "in", 1, 
177 		_( "Input" ), 
178 		_( "Input image" ),
179 		VIPS_ARGUMENT_REQUIRED_INPUT,
180 		G_STRUCT_OFFSET( VipsHistPlot, in ) );
181 	VIPS_ARG_IMAGE( class, "out", 2, 
182 		_( "Output" ), 
183 		_( "Output image" ),
184 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
185 		G_STRUCT_OFFSET( VipsHistPlot, out ) );
186 }
187 static void
188 vips_hist_plot_init( VipsHistPlot *hist_plot )
189 {
190 }
191 int 
192 vips_hist_plot( VipsImage *in, VipsImage **out, ... )
193 {
194 	va_list ap;
195 	int result;
196 	va_start( ap, out );
197 	result = vips_call_split( "hist_plot", ap, in, out );
198 	va_end( ap );
199 	return( result );
200 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>foreign.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/internal.h&gt;
8 #include &lt;vips/debug.h&gt;
9 #include "pforeign.h"
10 static GQuark vips__foreign_load_operation = 0; 
11 G_DEFINE_ABSTRACT_TYPE( VipsForeign, vips_foreign, VIPS_TYPE_OPERATION );
12 static void
13 vips_foreign_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
14 {
15 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( object_class );
16 	VIPS_OBJECT_CLASS( vips_foreign_parent_class )-&gt;
17 		summary_class( object_class, buf );
18 	if( class-&gt;suffs ) {
19 		const char **p;
20 		vips_buf_appends( buf, " (" );
21 		for( p = class-&gt;suffs; *p; p++ ) {
22 			vips_buf_appendf( buf, "%s", *p );
23 			if( p[1] )
24 				vips_buf_appends( buf, ", " );
25 		}
26 		vips_buf_appends( buf, ")" );
27 	}
28 <a name="0"></a>
29 	vips_buf_appendf( buf, ", priority=%d", class-&gt;priority );
30 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
31 static void
32 vips_foreign_class_init( VipsForeignClass *class )
33 {
34 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
35 	VipsObjectClass *object_class = (VipsObjectClass *) class;
36 	gobject_class-&gt;set_property = vips_object_set_property;
37 	gobject_class-&gt;get_property = vips_object_get_property;
38 	object_class-&gt;nickname = "foreign";
39 	object_class-&gt;description = _( "load and save image files" );
40 	object_class-&gt;summary_class = vips_foreign_summary_class;</b></font>
41 }
42 static void
43 vips_foreign_init( VipsForeign *object )
44 {
45 }
46 static void *
47 file_add_class( VipsForeignClass *class, GSList **files )
48 {
49 	if( !vips_isprefix( "rawload", VIPS_OBJECT_CLASS( class )-&gt;nickname ) ) 
50 		*files = g_slist_append( *files, class );
51 	return( NULL );
52 }
53 static gint
54 file_compare( VipsForeignClass *a, VipsForeignClass *b, void *user_data )
55 {
56         return( b-&gt;priority - a-&gt;priority );
57 }
58 void *
59 vips_foreign_map( const char *base, VipsSListMap2Fn fn, void *a, void *b )
60 {
61 	GSList *files;
62 	void *result;
63 	files = NULL;
64 	(void) vips_class_map_all( g_type_from_name( base ), 
65 		(VipsClassMapFn) file_add_class, (void *) &amp;files );
66 	files = g_slist_sort( files, (GCompareFunc) file_compare );
67 #ifdef DEBUG
68 {
69 	GSList *p;
70 	printf( "vips_foreign_map: search order\n" );
71 	for( p = files; p; p = p-&gt;next ) {
72 		VipsForeignClass *class = (VipsForeignClass *) p-&gt;data;
73 		printf( "\t%s\n", VIPS_OBJECT_CLASS( class )-&gt;nickname );
74 	}
75 }
76 	result = vips_slist_map2( files, fn, a, b );
77 	g_slist_free( files );
78 	return( result );
79 }
80 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoad, vips_foreign_load, VIPS_TYPE_FOREIGN );
81 static void
82 vips_foreign_load_dispose( GObject *gobject )
83 {
84 	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( gobject );
85 	VIPS_UNREF( load-&gt;real );
86 	G_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;dispose( gobject );
87 }
88 static void
89 vips_foreign_load_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
90 {
91 	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_CLASS( object_class );
92 	VIPS_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;
93 		summary_class( object_class, buf );
94 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) ) {
95 		if( class-&gt;is_a )
96 			vips_buf_appends( buf, ", is_a" );
97 		if( class-&gt;is_a_buffer )
98 			vips_buf_appends( buf, ", is_a_buffer" );
99 		if( class-&gt;is_a_source )
100 			vips_buf_appends( buf, ", is_a_source" );
101 		if( class-&gt;get_flags )
102 			vips_buf_appends( buf, ", get_flags" );
103 		if( class-&gt;get_flags_filename )
104 			vips_buf_appends( buf, ", get_flags_filename" );
105 		if( class-&gt;header )
106 			vips_buf_appends( buf, ", header" );
107 		if( class-&gt;load )
108 			vips_buf_appends( buf, ", load" );
109 		g_assert( class-&gt;header );
110 	}
111 }
112 static void *
113 vips_foreign_find_load_sub( VipsForeignLoadClass *load_class, 
114 	const char *filename, void *b )
115 {
116 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( load_class );
117 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( load_class );
118 	if( vips_ispostfix( object_class-&gt;nickname, "_buffer" ) ||
119 		vips_ispostfix( object_class-&gt;nickname, "_source" ) ) 
120 		return( NULL );
121 #ifdef DEBUG
122 	printf( "vips_foreign_find_load_sub: %s\n", 
123 		VIPS_OBJECT_CLASS( class )-&gt;nickname );
124 	if( load_class-&gt;is_a ) {
125 		if( load_class-&gt;is_a( filename ) ) 
126 			return( load_class );
127 #ifdef DEBUG
128 		printf( "vips_foreign_find_load_sub: is_a failed\n" ); 
129 	}
130 	else if( class-&gt;suffs ) {
131 		if( vips_filename_suffix_match( filename, class-&gt;suffs ) )
132 			return( load_class );
133 	}
134 	else 
135 		g_warning( "loader %s has no is_a method and no suffix list", 
136 			object_class-&gt;nickname );
137 	return( NULL );
138 }
139 const char *
140 vips_foreign_find_load( const char *name )
141 {
142 	char filename[VIPS_PATH_MAX];
143 	char option_string[VIPS_PATH_MAX];
144 	VipsForeignLoadClass *load_class;
145 	vips__filename_split8( name, filename, option_string );
146 	if( !vips_existsf( "%s", filename ) ) {
147 		vips_error( "VipsForeignLoad", 
148 			_( "file \"%s\" does not exist" ), name );
149 		return( NULL );
150 	}
151 	if( vips_isdirf( "%s", filename ) ) {
152 		vips_error( "VipsForeignLoad", 
153 			_( "\"%s\" is a directory" ), name );
154 		return( NULL );
155 	}
156 	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
157 		"VipsForeignLoad",
158 		(VipsSListMap2Fn) vips_foreign_find_load_sub, 
159 		(void *) filename, NULL )) ) {
160 		vips_error( "VipsForeignLoad", 
161 			_( "\"%s\" is not a known file format" ), name );
162 		return( NULL );
163 	}
164 #ifdef DEBUG
165 	printf( "vips_foreign_find_load: selected %s\n", 
166 		VIPS_OBJECT_CLASS( load_class )-&gt;nickname );
167 	return( G_OBJECT_CLASS_NAME( load_class ) );
168 }
169 int
170 vips_foreign_load( const char *name, VipsImage **out, ... )
171 {
172 	char filename[VIPS_PATH_MAX];
173 	char option_string[VIPS_PATH_MAX];
174 	const char *operation_name;
175 	va_list ap;
176 	int result;
177 	vips__filename_split8( name, filename, option_string );
178 	if( !(operation_name = vips_foreign_find_load( filename )) )
179 		return( -1 );
180 	va_start( ap, out );
181 	result = vips_call_split_option_string( operation_name, option_string, 
182 		ap, filename, out );
183 	va_end( ap );
184 	return( result );
185 }
186 static void *
187 vips_foreign_find_load_buffer_sub( VipsForeignLoadClass *load_class, 
188 	const void **buf, size_t *len )
189 {
190 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( load_class );
191 	if( !vips_ispostfix( object_class-&gt;nickname, "_buffer" ) )
192 		return( NULL );
193 	if( load_class-&gt;is_a_buffer ) {
194 		if( load_class-&gt;is_a_buffer( *buf, *len ) ) 
195 			return( load_class );
196 	}
197 	else
198 		g_warning( "loader %s has no is_a_buffer method", 
199 			object_class-&gt;nickname );
200 	return( NULL );
201 }
202 const char *
203 vips_foreign_find_load_buffer( const void *data, size_t size )
204 {
205 	VipsForeignLoadClass *load_class;
206 	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
207 		"VipsForeignLoad",
208 		(VipsSListMap2Fn) vips_foreign_find_load_buffer_sub, 
209 		&amp;data, &amp;size )) ) {
210 		vips_error( "VipsForeignLoad", 
211 			"%s", _( "buffer is not in a known format" ) ); 
212 		return( NULL );
213 	}
214 	return( G_OBJECT_CLASS_NAME( load_class ) );
215 }
216 static void *
217 vips_foreign_find_load_source_sub( void *item, void *a, void *b )
218 {
219 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( item );
220 	VipsForeignLoadClass *load_class = VIPS_FOREIGN_LOAD_CLASS( item );
221 	VipsSource *source = VIPS_SOURCE( a );
222 	if( !vips_ispostfix( object_class-&gt;nickname, "_source" ) )
223 		return( NULL );
224 	if( load_class-&gt;is_a_source ) {
225 		(void) vips_source_rewind( source );
226 		if( load_class-&gt;is_a_source( source ) ) 
227 			return( load_class );
228 	}
229 	else 
230 		g_warning( "loader %s has no is_a_source method", 
231 			object_class-&gt;nickname );
232 	return( NULL );
233 }
234 const char *
235 vips_foreign_find_load_source( VipsSource *source )
236 {
237 	VipsForeignLoadClass *load_class;
238 	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
239 		"VipsForeignLoad",
240 		vips_foreign_find_load_source_sub, 
241 		source, NULL )) ) {
242 		vips_error( "VipsForeignLoad", 
243 			"%s", _( "source is not in a known format" ) ); 
244 		return( NULL );
245 	}
246 	return( G_OBJECT_CLASS_NAME( load_class ) );
247 }
248 gboolean 
249 vips_foreign_is_a( const char *loader, const char *filename )
250 {
251 	const VipsObjectClass *class;
252 	VipsForeignLoadClass *load_class;
253 	if( !(class = vips_class_find( "VipsForeignLoad", loader )) ) 
254 		return( FALSE );
255 	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
256 	if( load_class-&gt;is_a &amp;&amp;
257 		load_class-&gt;is_a( filename ) ) 
258 		return( TRUE );
259 	return( FALSE );
260 }
261 gboolean
262 vips_foreign_is_a_buffer( const char *loader, const void *data, size_t size )
263 {
264 	const VipsObjectClass *class;
265 	VipsForeignLoadClass *load_class;
266 	if( !(class = vips_class_find( "VipsForeignLoad", loader )) )
267 		return( FALSE );
268 	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
269 	if( load_class-&gt;is_a_buffer &amp;&amp;
270 		load_class-&gt;is_a_buffer( data, size ) )
271 		return( TRUE );
272 	return( FALSE );
273 }
274 gboolean
275 vips_foreign_is_a_source( const char *loader, VipsSource *source )
276 {
277 	const VipsObjectClass *class;
278 	VipsForeignLoadClass *load_class;
279 	if( !(class = vips_class_find( "VipsForeignLoad", loader )) )
280 		return( FALSE );
281 	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
282 	if( load_class-&gt;is_a_source &amp;&amp;
283 		load_class-&gt;is_a_source( source ) )
284 		return( TRUE );
285 	return( FALSE );
286 }
287 VipsForeignFlags 
288 vips_foreign_flags( const char *loader, const char *filename )
289 {
290 	const VipsObjectClass *class;
291 	if( (class = vips_class_find( "VipsForeignLoad", loader )) ) {
292 		VipsForeignLoadClass *load_class = 
293 			VIPS_FOREIGN_LOAD_CLASS( class );
294 		if( load_class-&gt;get_flags_filename ) 
295 			return( load_class-&gt;get_flags_filename( filename ) );
296 	}
297 	return( 0 );
298 }
299 static VipsObject *
300 vips_foreign_load_new_from_string( const char *string )
301 {
302 	const char *file_op;
303 	GType type;
304 	VipsForeignLoad *load;
305 	if( !(file_op = vips_foreign_find_load( string )) )
306 		return( NULL );
307 	type = g_type_from_name( file_op );
308 	g_assert( type ); 
309 	load = VIPS_FOREIGN_LOAD( g_object_new( type, NULL ) );
310 	g_object_set( load,
311 		"filename", string,
312 		NULL );
313 	return( VIPS_OBJECT( load ) );
314 }
315 static VipsImage *
316 vips_foreign_load_temp( VipsForeignLoad *load )
317 {
318 	const guint64 disc_threshold = vips_get_disc_threshold();
319 	const guint64 image_size = VIPS_IMAGE_SIZEOF_IMAGE( load-&gt;out );
320 	if( !load-&gt;disc )
321 		load-&gt;memory = TRUE;
322 	if( load-&gt;memory ) {
323 #ifdef DEBUG
324 		printf( "vips_foreign_load_temp: forced memory temp\n" );
325 		return( vips_image_new_memory() );
326 	}
327 	if( load-&gt;flags &amp; VIPS_FOREIGN_PARTIAL ) {
328 #ifdef DEBUG
329 		printf( "vips_foreign_load_temp: partial temp\n" );
330 		return( vips_image_new() );
331 	}
332 	if( (load-&gt;flags &amp; VIPS_FOREIGN_SEQUENTIAL) &amp;&amp; 
333 		load-&gt;access != VIPS_ACCESS_RANDOM ) {
334 #ifdef DEBUG
335 		printf( "vips_foreign_load_temp: partial sequential temp\n" );
336 		return( vips_image_new() );
337 	}
338 	if( image_size &gt; disc_threshold ) {
339 #ifdef DEBUG
340 		printf( "vips_foreign_load_temp: disc temp\n" );
341 		return( vips_image_new_temp_file( "%s.v" ) );
342 	}
343 #ifdef DEBUG
344 	printf( "vips_foreign_load_temp: fallback memory temp\n" );
345 	return( vips_image_new_memory() );
346 }
347 static gboolean
348 vips_foreign_load_iscompat( VipsImage *a, VipsImage *b )
349 {
350 	if( a-&gt;Xsize != b-&gt;Xsize ||
351 		a-&gt;Ysize != b-&gt;Ysize ||
352 		a-&gt;Bands != b-&gt;Bands ||
353 		a-&gt;Coding != b-&gt;Coding ||
354 		a-&gt;BandFmt != b-&gt;BandFmt ) {
355 		vips_error( "VipsForeignLoad",
356 			"%s", _( "images do not match" ) ); 
357 		return( FALSE );
358 	}
359 	return( TRUE );
360 }
361 static void *
362 vips_foreign_load_start( VipsImage *out, void *a, void *b )
363 {
364 	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );
365 	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );
366 	if( load-&gt;error )
367 		return( NULL );
368 	if( !load-&gt;real ) {
369 		if( !(load-&gt;real = vips_foreign_load_temp( load )) )
370 			return( NULL );
371 #ifdef DEBUG
372 		printf( "vips_foreign_load_start: triggering -&gt;load()\n" );
373 		load-&gt;real-&gt;progress_signal = load-&gt;out;
374 		g_object_set_qdata( G_OBJECT( load-&gt;real ), 
375 			vips__foreign_load_operation, load ); 
376 		if( class-&gt;load( load ) ||
377 			vips_image_pio_input( load-&gt;real ) || 
378 			!vips_foreign_load_iscompat( load-&gt;real, out ) ) {
379 			vips_operation_invalidate( VIPS_OPERATION( load ) ); 
380 			load-&gt;error = TRUE;
381 			return( NULL );
382 		}
383 		if( vips_image_pipelinev( load-&gt;out, load-&gt;out-&gt;dhint, 
384 			load-&gt;real, NULL ) )
385 			return( NULL );
386 	}
387 	return( vips_region_new( load-&gt;real ) );
388 }
389 static int
390 vips_foreign_load_generate( VipsRegion *or, 
391 	void *seq, void *a, void *b, gboolean *stop )
392 {
393 	VipsRegion *ir = (VipsRegion *) seq;
394         VipsRect *r = &amp;or-&gt;valid;
395         if( vips_region_prepare( ir, r ) )
396                 return( -1 );
397         if( vips_region_region( or, ir, r, r-&gt;left, r-&gt;top ) )
398                 return( -1 );
399         return( 0 );
400 }
401 static int
402 vips_foreign_load_build( VipsObject *object )
403 {
404 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
405 	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( object );
406 	VipsForeignLoadClass *fclass = VIPS_FOREIGN_LOAD_GET_CLASS( object );
407 	VipsForeignFlags flags;
408 	gboolean sequential;
409 #ifdef DEBUG
410 	printf( "vips_foreign_load_build:\n" );
411 	flags = 0;
412 	if( fclass-&gt;get_flags )
413 		flags |= fclass-&gt;get_flags( load );
414 	if( (flags &amp; VIPS_FOREIGN_PARTIAL) &amp;&amp;
415 		(flags &amp; VIPS_FOREIGN_SEQUENTIAL) ) {
416 		g_warning( "%s", 
417 			_( "VIPS_FOREIGN_PARTIAL and VIPS_FOREIGN_SEQUENTIAL "
418 				"both set -- using SEQUENTIAL" ) );
419 		flags ^= VIPS_FOREIGN_PARTIAL;
420 	}
421 	g_object_set( load, "flags", flags, NULL );
422 	sequential = (load-&gt;flags &amp; VIPS_FOREIGN_SEQUENTIAL) &amp;&amp; 
423 		load-&gt;access != VIPS_ACCESS_RANDOM;
424 	if( sequential )
425 		load-&gt;nocache = TRUE;
426 	if( VIPS_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;
427 		build( object ) )
428 		return( -1 );
429 	if( load-&gt;sequential ) 
430 		g_warning( "%s", 
431 			_( "ignoring deprecated \"sequential\" mode -- "
432 				"please use \"access\" instead" ) ); 
433 	g_object_set( object, "out", vips_image_new(), NULL ); 
434 	vips_image_set_string( load-&gt;out, 
435 		VIPS_META_LOADER, class-&gt;nickname );
436 #ifdef DEBUG
437 	printf( "vips_foreign_load_build: triggering -&gt;header()\n" );
438 	if( fclass-&gt;header &amp;&amp;
439 		fclass-&gt;header( load ) ) 
440 		return( -1 );
441 	if( fclass-&gt;load ) {
442 #ifdef DEBUG
443 		printf( "vips_foreign_load_build: delaying read ...\n" );
444 		if( vips_image_pipelinev( load-&gt;out, load-&gt;out-&gt;dhint, NULL ) )
445 			return( -1 );
446 		if( vips_image_generate( load-&gt;out, 
447 			vips_foreign_load_start, 
448 			vips_foreign_load_generate, 
449 			vips_stop_one, 
450 			NULL, load ) ) 
451 			return( -1 );
452 	}
453 	if( sequential ) 
454 		vips_image_set_area( load-&gt;out, 
455 			VIPS_META_SEQUENTIAL, NULL, NULL ); 
456 	return( 0 );
457 }
458 static VipsOperationFlags 
459 vips_foreign_load_operation_get_flags( VipsOperation *operation )
460 {
461 	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( operation );
462 	VipsOperationFlags flags;
463 	flags = VIPS_OPERATION_CLASS( vips_foreign_load_parent_class )-&gt;
464 		get_flags( operation );
465 	if( load-&gt;nocache )
466 		flags |= VIPS_OPERATION_NOCACHE;
467 	return( flags );
468 }
469 static void
470 vips_foreign_load_class_init( VipsForeignLoadClass *class )
471 {
472 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
473 	VipsObjectClass *object_class = (VipsObjectClass *) class;
474 	VipsOperationClass *operation_class = (VipsOperationClass *) class;
475 	gobject_class-&gt;dispose = vips_foreign_load_dispose;
476 	gobject_class-&gt;set_property = vips_object_set_property;
477 	gobject_class-&gt;get_property = vips_object_get_property;
478 	object_class-&gt;build = vips_foreign_load_build;
479 	object_class-&gt;summary_class = vips_foreign_load_summary_class;
480 	object_class-&gt;new_from_string = vips_foreign_load_new_from_string;
481 	object_class-&gt;nickname = "fileload";
482 	object_class-&gt;description = _( "file loaders" );
483 	operation_class-&gt;get_flags = vips_foreign_load_operation_get_flags;
484 	VIPS_ARG_IMAGE( class, "out", 2, 
485 		_( "Output" ), 
486 		_( "Output image" ),
487 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
488 		G_STRUCT_OFFSET( VipsForeignLoad, out ) );
489 	VIPS_ARG_FLAGS( class, "flags", 106, 
490 		_( "Flags" ), 
491 		_( "Flags for this file" ),
492 		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
493 		G_STRUCT_OFFSET( VipsForeignLoad, flags ),
494 		VIPS_TYPE_FOREIGN_FLAGS, VIPS_FOREIGN_NONE ); 
495 	VIPS_ARG_BOOL( class, "memory", 107, 
496 		_( "Memory" ), 
497 		_( "Force open via memory" ),
498 		VIPS_ARGUMENT_OPTIONAL_INPUT,
499 		G_STRUCT_OFFSET( VipsForeignLoad, memory ),
500 		FALSE );
501 	VIPS_ARG_ENUM( class, "access", 108, 
502 		_( "Access" ), 
503 		_( "Required access pattern for this file" ),
504 		VIPS_ARGUMENT_OPTIONAL_INPUT,
505 		G_STRUCT_OFFSET( VipsForeignLoad, access ),
506 		VIPS_TYPE_ACCESS, VIPS_ACCESS_RANDOM ); 
507 	VIPS_ARG_BOOL( class, "sequential", 109, 
508 		_( "Sequential" ), 
509 		_( "Sequential read only" ),
510 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
511 		G_STRUCT_OFFSET( VipsForeignLoad, sequential ),
512 		FALSE );
513 	VIPS_ARG_BOOL( class, "fail", 110, 
514 		_( "Fail" ), 
515 		_( "Fail on first error" ),
516 		VIPS_ARGUMENT_OPTIONAL_INPUT,
517 		G_STRUCT_OFFSET( VipsForeignLoad, fail ),
518 		FALSE );
519 	VIPS_ARG_BOOL( class, "disc", 111, 
520 		_( "Disc" ), 
521 		_( "Open to disc" ),
522 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
523 		G_STRUCT_OFFSET( VipsForeignLoad, disc ),
524 		TRUE );
525 }
526 static void
527 vips_foreign_load_init( VipsForeignLoad *load )
528 {
529 	load-&gt;disc = TRUE;
530 	load-&gt;access = VIPS_ACCESS_RANDOM;
531 }
532 void
533 vips_foreign_load_invalidate( VipsImage *image )
534 {
535 	VipsOperation *operation; 
536 #ifdef DEBUG
537 	printf( "vips_foreign_load_invalidate: %p\n", image ); 
538 	if( (operation = g_object_get_qdata( G_OBJECT( image ), 
539 		vips__foreign_load_operation )) ) {
540 		vips_operation_invalidate( operation ); 
541 	}
542 }
543 G_DEFINE_ABSTRACT_TYPE( VipsForeignSave, vips_foreign_save, VIPS_TYPE_FOREIGN );
544 static void
545 vips_foreign_save_dispose( GObject *gobject )
546 {
547 	VipsForeignSave *save = VIPS_FOREIGN_SAVE( gobject );
548 	VIPS_UNREF( save-&gt;ready );
549 	G_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;dispose( gobject );
550 }
551 static void
552 vips_foreign_save_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
553 {
554 	VipsForeignSaveClass *class = VIPS_FOREIGN_SAVE_CLASS( object_class );
555 	VIPS_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;
556 		summary_class( object_class, buf );
557 	vips_buf_appendf( buf, ", %s", 
558 		vips_enum_nick( VIPS_TYPE_SAVEABLE, class-&gt;saveable ) );
559 }
560 static VipsObject *
561 vips_foreign_save_new_from_string( const char *string )
562 {
563 	const char *file_op;
564 	GType type;
565 	VipsForeignSave *save;
566 	if( !(file_op = vips_foreign_find_save( string )) )
567 		return( NULL );
568 	type = g_type_from_name( file_op );
569 	g_assert( type ); 
570 	save = VIPS_FOREIGN_SAVE( g_object_new( type, NULL ) );
571 	g_object_set( save,
572 		"filename", string,
573 		NULL );
574 	return( VIPS_OBJECT( save ) );
575 }
576 int
577 vips__foreign_convert_saveable( VipsImage *in, VipsImage **ready,
578 	VipsSaveable saveable, VipsBandFormat *format, VipsCoding *coding,
579 	VipsArrayDouble *background )
580 {
581 	g_object_ref( in );
582 	if( in-&gt;Coding != VIPS_CODING_NONE &amp;&amp;
583 		coding[in-&gt;Coding] ) {
584 		*ready = in;
585 		return( 0 );
586 	}
587 	if( in-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
588 	        saveable == VIPS_SAVEABLE_ANY &amp;&amp;
589 		format[in-&gt;BandFmt] == in-&gt;BandFmt ) {
590 		*ready = in;
591 		return( 0 );
592 	}
593 	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
594 		VipsImage *out;
595 		if( vips_LabQ2sRGB( in, &amp;out, NULL ) ) {
596 			g_object_unref( in );
597 			return( -1 );
598 		}
599 		g_object_unref( in );
600 		in = out;
601 	}
602 	if( in-&gt;Coding == VIPS_CODING_RAD ) {
603 		VipsImage *out;
604 		if( vips_rad2float( in, &amp;out, NULL ) ) {
605 			g_object_unref( in );
606 			return( -1 );
607 		}
608 		g_object_unref( in );
609 		in = out;
610 	}
611 	if( coding[VIPS_CODING_RAD] ) {
612 		if( in-&gt;Type != VIPS_INTERPRETATION_scRGB &amp;&amp;
613 			in-&gt;Type != VIPS_INTERPRETATION_XYZ ) {
614 			VipsImage *out;
615 			if( vips_colourspace( in, &amp;out, 
616 				VIPS_INTERPRETATION_scRGB, NULL ) ) {
617 				g_object_unref( in );
618 				return( -1 );
619 			}
620 			g_object_unref( in );
621 			in = out;
622 		}
623 	}
624 	if( in-&gt;Type == VIPS_INTERPRETATION_CMYK &amp;&amp;
625 		in-&gt;Bands &gt;= 4 &amp;&amp;
626 		(saveable == VIPS_SAVEABLE_RGB ||
627 		 saveable == VIPS_SAVEABLE_RGBA ||
628 		 saveable == VIPS_SAVEABLE_RGBA_ONLY) ) { 
629 		VipsImage *out;
630 		if( vips_icc_import( in, &amp;out, 
631 			"pcs", VIPS_PCS_XYZ,
632 			"embedded", TRUE,
633 			"input_profile", "cmyk",
634 			NULL ) ) {
635 			g_object_unref( in );
636 			return( -1 );
637 		}
638 		g_object_unref( in );
639 		in = out;
640 	}
641 	if( !coding[VIPS_CODING_RAD] &amp;&amp;
642 		in-&gt;Bands &gt;= 3 &amp;&amp;
643 		in-&gt;Type != VIPS_INTERPRETATION_CMYK &amp;&amp;
644 		in-&gt;Type != VIPS_INTERPRETATION_sRGB &amp;&amp;
645 		in-&gt;Type != VIPS_INTERPRETATION_RGB16 &amp;&amp;
646 		in-&gt;Type != VIPS_INTERPRETATION_scRGB &amp;&amp;
647 		vips_colourspace_issupported( in ) &amp;&amp;
648 		(saveable == VIPS_SAVEABLE_RGB ||
649 		 saveable == VIPS_SAVEABLE_RGBA ||
650 		 saveable == VIPS_SAVEABLE_RGBA_ONLY ||
651 		 saveable == VIPS_SAVEABLE_RGB_CMYK) ) { 
652 		VipsImage *out;
653 		VipsInterpretation interpretation;
654 		if( vips_band_format_is8bit( format[in-&gt;BandFmt] ) )
655 			interpretation = VIPS_INTERPRETATION_sRGB;
656 		else
657 			interpretation = VIPS_INTERPRETATION_RGB16;
658 		if( vips_colourspace( in, &amp;out, interpretation, NULL ) ) {
659 			g_object_unref( in );
660 			return( -1 );
661 		}
662 		g_object_unref( in );
663 		in = out;
664 	}
665 	if( !coding[VIPS_CODING_RAD] &amp;&amp;
666 		in-&gt;Bands &lt; 3 &amp;&amp;
667 		vips_colourspace_issupported( in ) &amp;&amp;
668 		saveable == VIPS_SAVEABLE_RGBA_ONLY ) { 
669 		VipsImage *out;
670 		VipsInterpretation interpretation;
671 		if( vips_band_format_is8bit( format[in-&gt;BandFmt] ) )
672 			interpretation = VIPS_INTERPRETATION_sRGB;
673 		else
674 			interpretation = VIPS_INTERPRETATION_RGB16;
675 		if( vips_colourspace( in, &amp;out, interpretation, NULL ) ) {
676 			g_object_unref( in );
677 			return( -1 );
678 		}
679 		g_object_unref( in );
680 		in = out;
681 	}
682 	if( in-&gt;Coding == VIPS_CODING_NONE ) {
683 		if( (in-&gt;Bands == 2 ||
684 			(in-&gt;Bands == 4 &amp;&amp; 
685 			 in-&gt;Type != VIPS_INTERPRETATION_CMYK)) &amp;&amp;
686 			(saveable == VIPS_SAVEABLE_MONO ||
687 			 saveable == VIPS_SAVEABLE_RGB ||
688 			 saveable == VIPS_SAVEABLE_RGB_CMYK) ) {
689 			VipsImage *out;
690 			if( vips_flatten( in, &amp;out, 
691 				"background", background,
692 				NULL ) ) {
693 				g_object_unref( in );
694 				return( -1 );
695 			}
696 			g_object_unref( in );
697 			in = out;
698 		}
699 		else if( in-&gt;Bands &gt; 3 &amp;&amp; 
700 			(saveable == VIPS_SAVEABLE_RGB ||
701 			 (saveable == VIPS_SAVEABLE_RGB_CMYK &amp;&amp;
702 			  in-&gt;Type != VIPS_INTERPRETATION_CMYK)) ) { 
703 			VipsImage *out;
704 			if( vips_extract_band( in, &amp;out, 0, 
705 				"n", 3,
706 				NULL ) ) {
707 				g_object_unref( in );
708 				return( -1 );
709 			}
710 			g_object_unref( in );
711 			in = out;
712 		}
713 		else if( in-&gt;Bands &gt; 4 &amp;&amp; 
714 			((saveable == VIPS_SAVEABLE_RGB_CMYK &amp;&amp;
715 			  in-&gt;Type == VIPS_INTERPRETATION_CMYK) ||
716 			 saveable == VIPS_SAVEABLE_RGBA ||
717 			 saveable == VIPS_SAVEABLE_RGBA_ONLY) ) {
718 			VipsImage *out;
719 			if( vips_extract_band( in, &amp;out, 0, 
720 				"n", 4,
721 				NULL ) ) {
722 				g_object_unref( in );
723 				return( -1 );
724 			}
725 			g_object_unref( in );
726 			in = out;
727 		}
728 		else if( in-&gt;Bands &gt; 1 &amp;&amp; 
729 			saveable == VIPS_SAVEABLE_MONO ) {
730 			VipsImage *out;
731 			if( vips_extract_band( in, &amp;out, 0, NULL ) ) {
732 				g_object_unref( in );
733 				return( -1 );
734 			}
735 			g_object_unref( in );
736 			in = out;
737 		}
738 	}
739 	if( (in-&gt;Type == VIPS_INTERPRETATION_RGB16 ||
740 		 in-&gt;Type == VIPS_INTERPRETATION_GREY16) &amp;&amp;
741 		!vips_band_format_is8bit( in-&gt;BandFmt ) ) {
742 		if( format[VIPS_FORMAT_USHORT] == VIPS_FORMAT_USHORT ) {
743 			VipsImage *out;
744 			if( vips_cast( in, &amp;out, VIPS_FORMAT_USHORT, NULL ) ) {
745 				g_object_unref( in );
746 				return( -1 );
747 			}
748 			g_object_unref( in );
749 			in = out;
750 		}
751 		else {
752 			VipsImage *out;
753 			if( vips_rshift_const1( in, &amp;out, 8, NULL ) ) { 
754 				g_object_unref( in );
755 				return( -1 );
756 			}
757 			g_object_unref( in );
758 			in = out;
759 			if( vips_cast( in, &amp;out, VIPS_FORMAT_UCHAR, NULL ) ) {
760 				g_object_unref( in );
761 				return( -1 );
762 			}
763 			g_object_unref( in );
764 			in = out;
765 		}
766 	}
767 	{
768 		VipsImage *out;
769 		if( vips_cast( in, &amp;out, format[in-&gt;BandFmt], NULL ) ) {
770 			g_object_unref( in );
771 			return( -1 );
772 		}
773 		g_object_unref( in );
774 		in = out;
775 	}
776 	if( coding[VIPS_CODING_NONE] ) {
777 	}
778 	else if( coding[VIPS_CODING_LABQ] ) {
779 		VipsImage *out;
780 		if( vips_Lab2LabQ( in, &amp;out, NULL ) ) {
781 			g_object_unref( in );
782 			return( -1 );
783 		}
784 		g_object_unref( in );
785 		in = out;
786 	}
787 	else if( coding[VIPS_CODING_RAD] ) {
788 		VipsImage *out;
789 		if( vips_float2rad( in, &amp;out, NULL ) ) {
790 			g_object_unref( in );
791 			return( -1 );
792 		}
793 		g_object_unref( in );
794 		in = out;
795 	}
796 	if( vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ) {
797 		const void *data;
798 		size_t length;
799 		if( !vips_image_get_blob( in, VIPS_META_ICC_NAME, 
800 			&amp;data, &amp;length ) &amp;&amp;
801 			!vips_icc_is_compatible_profile( in, data, length ) ) {
802 			VipsImage *out;
803 			if( vips_copy( in, &amp;out, NULL ) ) {
804 				g_object_unref( in );
805 				return( -1 );
806 			}
807 			g_object_unref( in );
808 			in = out;
809 			vips_image_remove( in, VIPS_META_ICC_NAME );
810 		}
811 	}
812 	*ready = in;
813 	return( 0 );
814 }
815 static int
816 vips_foreign_save_build( VipsObject *object )
817 {
818 	VipsForeignSave *save = VIPS_FOREIGN_SAVE( object );
819 	if( save-&gt;in ) {
820 		VipsForeignSaveClass *class = 
821 			VIPS_FOREIGN_SAVE_GET_CLASS( save );
822 		VipsImage *ready;
823 		if( vips__foreign_convert_saveable( save-&gt;in, &amp;ready,
824 			class-&gt;saveable, class-&gt;format_table, class-&gt;coding,
825 			save-&gt;background ) )
826 			return( -1 );
827 		if( save-&gt;page_height ) {
828 			VipsImage *x;
829 			if( vips_copy( ready, &amp;x, NULL ) ) {
830 				VIPS_UNREF( ready );
831 				return( -1 );
832 			}
833 			VIPS_UNREF( ready );
834 			ready = x;
835 			vips_image_set_int( ready, 
836 				VIPS_META_PAGE_HEIGHT, save-&gt;page_height );
837 		}
838 		VIPS_UNREF( save-&gt;ready );
839 		save-&gt;ready = ready;
840 	}
841 	if( VIPS_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;
842 		build( object ) )
843 		return( -1 );
844 	return( 0 );
845 }
846 #define UC VIPS_FORMAT_UCHAR
847 #define C VIPS_FORMAT_CHAR
848 #define US VIPS_FORMAT_USHORT
849 #define S VIPS_FORMAT_SHORT
850 #define UI VIPS_FORMAT_UINT
851 #define I VIPS_FORMAT_INT
852 #define F VIPS_FORMAT_FLOAT
853 #define X VIPS_FORMAT_COMPLEX
854 #define D VIPS_FORMAT_DOUBLE
855 #define DX VIPS_FORMAT_DPCOMPLEX
856 static int vips_foreign_save_format_table[10] = {
857    UC, C,  US, S,  UI, I, F, X, D, DX
858 };
859 static void
860 vips_foreign_save_class_init( VipsForeignSaveClass *class )
861 {
862 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
863 	VipsObjectClass *object_class = (VipsObjectClass *) class;
864 	VipsOperationClass *operation_class = (VipsOperationClass *) class;
865 	int i;
866 	gobject_class-&gt;dispose = vips_foreign_save_dispose;
867 	gobject_class-&gt;set_property = vips_object_set_property;
868 	gobject_class-&gt;get_property = vips_object_get_property;
869 	object_class-&gt;build = vips_foreign_save_build;
870 	object_class-&gt;summary_class = vips_foreign_save_summary_class;
871 	object_class-&gt;new_from_string = vips_foreign_save_new_from_string;
872 	object_class-&gt;nickname = "filesave";
873 	object_class-&gt;description = _( "file savers" );
874 	operation_class-&gt;flags |= VIPS_OPERATION_SEQUENTIAL;
875 	operation_class-&gt;flags |= VIPS_OPERATION_NOCACHE;
876 	for( i = 0; i &lt; VIPS_CODING_LAST; i++ )
877 		class-&gt;coding[i] = FALSE;
878 	class-&gt;coding[VIPS_CODING_NONE] = TRUE;
879 	class-&gt;format_table = vips_foreign_save_format_table; 
880 	VIPS_ARG_IMAGE( class, "in", 0, 
881 		_( "Input" ), 
882 		_( "Image to save" ),
883 		VIPS_ARGUMENT_REQUIRED_INPUT,
884 		G_STRUCT_OFFSET( VipsForeignSave, in ) );
885 	VIPS_ARG_BOOL( class, "strip", 100,
886 		_( "Strip" ),
887 		_( "Strip all metadata from image" ),
888 		VIPS_ARGUMENT_OPTIONAL_INPUT,
889 		G_STRUCT_OFFSET( VipsForeignSave, strip ),
890 		FALSE );
891 	VIPS_ARG_BOXED( class, "background", 101, 
892 		_( "Background" ), 
893 		_( "Background value" ),
894 		VIPS_ARGUMENT_OPTIONAL_INPUT,
895 		G_STRUCT_OFFSET( VipsForeignSave, background ),
896 		VIPS_TYPE_ARRAY_DOUBLE );
897 	VIPS_ARG_INT( class, "page_height", 102, 
898 		_( "Page height" ), 
899 		_( "Set page height for multipage save" ),
900 		VIPS_ARGUMENT_OPTIONAL_INPUT,
901 		G_STRUCT_OFFSET( VipsForeignSave, page_height ),
902 		0, VIPS_MAX_COORD, 0 ); 
903 }
904 static void
905 vips_foreign_save_init( VipsForeignSave *save )
906 {
907 	save-&gt;background = vips_array_double_newv( 1, 0.0 );
908 }
909 static void *
910 vips_foreign_find_save_sub( VipsForeignSaveClass *save_class, 
911 	const char *filename, void *b )
912 {
913 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
914 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
915 	const char **p;
916 	if( !class-&gt;suffs )
917 		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
918 	if( vips_ispostfix( object_class-&gt;nickname, "_buffer" ) ||
919 		vips_ispostfix( object_class-&gt;nickname, "_target" ) )
920 		return( NULL );
921 	for( p = class-&gt;suffs; *p; p++ ) 
922 		if( vips_iscasepostfix( filename, *p ) ) 
923 			return( save_class );
924 	return( NULL );
925 }
926 const char *
927 vips_foreign_find_save( const char *name )
928 {
929 	char filename[VIPS_PATH_MAX];
930 	char option_string[VIPS_PATH_MAX];
931 	VipsForeignSaveClass *save_class;
932 	vips__filename_split8( name, filename, option_string );
933 	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
934 		"VipsForeignSave",
935 		(VipsSListMap2Fn) vips_foreign_find_save_sub, 
936 		(void *) filename, NULL )) ) {
937 		vips_error( "VipsForeignSave",
938 			_( "\"%s\" is not a known file format" ), name );
939 		return( NULL );
940 	}
941 	return( G_OBJECT_CLASS_NAME( save_class ) );
942 }
943 static void *
944 vips_foreign_get_suffixes_count_cb( VipsForeignSaveClass *save_class, 
945 	void *a, void *b )
946 {
947 	VipsForeignClass *foreign_class = VIPS_FOREIGN_CLASS( save_class );
948 	int *n_fields = (int *) a;
949 	int i;
950 	if( foreign_class-&gt;suffs )
951 		for( i = 0; foreign_class-&gt;suffs[i]; i++ )
952 			*n_fields += 1;
953 	return( NULL ); 
954 }
955 static void *
956 vips_foreign_get_suffixes_add_cb( VipsForeignSaveClass *save_class, 
957 	void *a, void *b )
958 {
959 	VipsForeignClass *foreign_class = VIPS_FOREIGN_CLASS( save_class );
960 	gchar ***p = (gchar ***) a;
961 	int i;
962 	if( foreign_class-&gt;suffs )
963 		for( i = 0; foreign_class-&gt;suffs[i]; i++ ) {
964 			**p = g_strdup( foreign_class-&gt;suffs[i] ); 
965 			*p += 1;
966 		}
967 	return( NULL ); 
968 }
969 gchar ** 
970 vips_foreign_get_suffixes( void )
971 {
972 	int n_suffs;
973 	gchar **suffs;
974 	gchar **p;
975 	n_suffs = 0;
976 	(void) vips_foreign_map( 
977 		"VipsForeignSave",
978 		(VipsSListMap2Fn) vips_foreign_get_suffixes_count_cb, 
979 		&amp;n_suffs, NULL );
980 	suffs = g_new0( gchar *, n_suffs + 1 ); 
981 	p = suffs;
982 	(void) vips_foreign_map( 
983 		"VipsForeignSave",
984 		(VipsSListMap2Fn) vips_foreign_get_suffixes_add_cb, 
985 		&amp;p, NULL );
986 	return( suffs ); 
987 }
988 int
989 vips_foreign_save( VipsImage *in, const char *name, ... )
990 {
991 	char filename[VIPS_PATH_MAX];
992 	char option_string[VIPS_PATH_MAX];
993 	const char *operation_name;
994 	va_list ap;
995 	int result;
996 	vips__filename_split8( name, filename, option_string );
997 	if( !(operation_name = vips_foreign_find_save( filename )) )
998 		return( -1 );
999 	va_start( ap, name );
1000 	result = vips_call_split_option_string( operation_name, option_string, 
1001 		ap, in, filename );
1002 	va_end( ap );
1003 	return( result );
1004 }
1005 static void *
1006 vips_foreign_find_save_target_sub( VipsForeignSaveClass *save_class, 
1007 	const char *suffix, void *b )
1008 {
1009 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
1010 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
1011 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
1012 		!class-&gt;suffs )
1013 		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
1014 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
1015 		class-&gt;suffs &amp;&amp;
1016 		vips_ispostfix( object_class-&gt;nickname, "_target" ) &amp;&amp;
1017 		vips_filename_suffix_match( suffix, class-&gt;suffs ) )
1018 		return( save_class );
1019 	return( NULL );
1020 }
1021 const char *
1022 vips_foreign_find_save_target( const char *name )
1023 {
1024 	char suffix[VIPS_PATH_MAX];
1025 	char option_string[VIPS_PATH_MAX];
1026 	VipsForeignSaveClass *save_class;
1027 	vips__filename_split8( name, suffix, option_string );
1028 	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
1029 		"VipsForeignSave",
1030 		(VipsSListMap2Fn) vips_foreign_find_save_target_sub, 
1031 		(void *) suffix, NULL )) ) {
1032 		vips_error( "VipsForeignSave",
1033 			_( "\"%s\" is not a known target format" ), name );
1034 		return( NULL );
1035 	}
1036 	return( G_OBJECT_CLASS_NAME( save_class ) );
1037 }
1038 static void *
1039 vips_foreign_find_save_buffer_sub( VipsForeignSaveClass *save_class, 
1040 	const char *suffix, void *b )
1041 {
1042 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
1043 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
1044 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
1045 		!class-&gt;suffs )
1046 		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
1047 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
1048 		class-&gt;suffs &amp;&amp;
1049 		vips_ispostfix( object_class-&gt;nickname, "_buffer" ) &amp;&amp;
1050 		vips_filename_suffix_match( suffix, class-&gt;suffs ) )
1051 		return( save_class );
1052 	return( NULL );
1053 }
1054 const char *
1055 vips_foreign_find_save_buffer( const char *name )
1056 {
1057 	char suffix[VIPS_PATH_MAX];
1058 	char option_string[VIPS_PATH_MAX];
1059 	VipsForeignSaveClass *save_class;
1060 	vips__filename_split8( name, suffix, option_string );
1061 	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
1062 		"VipsForeignSave",
1063 		(VipsSListMap2Fn) vips_foreign_find_save_buffer_sub, 
1064 		(void *) suffix, NULL )) ) {
1065 		vips_error( "VipsForeignSave",
1066 			_( "\"%s\" is not a known buffer format" ), name );
1067 		return( NULL );
1068 	}
1069 	return( G_OBJECT_CLASS_NAME( save_class ) );
1070 }
1071 int
1072 vips_heifload( const char *filename, VipsImage **out, ... )
1073 {
1074 	va_list ap;
1075 	int result;
1076 	va_start( ap, out );
1077 	result = vips_call_split( "heifload", ap, filename, out );
1078 	va_end( ap );
1079 	return( result );
1080 }
1081 int
1082 vips_heifload_buffer( void *buf, size_t len, VipsImage **out, ... )
1083 {
1084 	va_list ap;
1085 	VipsBlob *blob;
1086 	int result;
1087 	blob = vips_blob_new( NULL, buf, len );
1088 	va_start( ap, out );
1089 	result = vips_call_split( "heifload_buffer", ap, blob, out );
1090 	va_end( ap );
1091 	vips_area_unref( VIPS_AREA( blob ) );
1092 	return( result );
1093 }
1094 int
1095 vips_heifload_source( VipsSource *source, VipsImage **out, ... )
1096 {
1097 	va_list ap;
1098 	int result;
1099 	va_start( ap, out );
1100 	result = vips_call_split( "heifload_source", ap, source, out );
1101 	va_end( ap );
1102 	return( result );
1103 }
1104 int
1105 vips_heifsave( VipsImage *in, const char *filename, ... )
1106 {
1107 	va_list ap;
1108 	int result;
1109 	va_start( ap, filename );
1110 	result = vips_call_split( "heifsave", ap, in, filename );
1111 	va_end( ap );
1112 	return( result );
1113 }
1114 int
1115 vips_heifsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
1116 {
1117 	va_list ap;
1118 	VipsArea *area;
1119 	int result;
1120 	area = NULL; 
1121 	va_start( ap, len );
1122 	result = vips_call_split( "heifsave_buffer", ap, in, &amp;area );
1123 	va_end( ap );
1124 	if( !result &amp;&amp;
1125 		area ) { 
1126 		if( buf ) {
1127 			*buf = area-&gt;data;
1128 			area-&gt;free_fn = NULL;
1129 		}
1130 		if( len ) 
1131 			*len = area-&gt;length;
1132 		vips_area_unref( area );
1133 	}
1134 	return( result );
1135 }
1136 int
1137 vips_heifsave_target( VipsImage *in, VipsTarget *target, ... )
1138 {
1139 	va_list ap;
1140 	int result;
1141 	va_start( ap, target );
1142 	result = vips_call_split( "heifsave_target", ap, in, target );
1143 	va_end( ap );
1144 	return( result );
1145 }
1146 int
1147 vips_jxlload( const char *filename, VipsImage **out, ... )
1148 {
1149 	va_list ap;
1150 	int result;
1151 	va_start( ap, out );
1152 	result = vips_call_split( "jxlload", ap, filename, out );
1153 	va_end( ap );
1154 	return( result );
1155 }
1156 int
1157 vips_jxlload_buffer( void *buf, size_t len, VipsImage **out, ... )
1158 {
1159 	va_list ap;
1160 	VipsBlob *blob;
1161 	int result;
1162 	blob = vips_blob_new( NULL, buf, len );
1163 	va_start( ap, out );
1164 	result = vips_call_split( "jxlload_buffer", ap, blob, out );
1165 	va_end( ap );
1166 	vips_area_unref( VIPS_AREA( blob ) );
1167 	return( result );
1168 }
1169 int
1170 vips_jxlload_source( VipsSource *source, VipsImage **out, ... )
1171 {
1172 	va_list ap;
1173 	int result;
1174 	va_start( ap, out );
1175 	result = vips_call_split( "jxlload_source", ap, source, out );
1176 	va_end( ap );
1177 	return( result );
1178 }
1179 int
1180 vips_jxlsave( VipsImage *in, const char *filename, ... )
1181 {
1182 	va_list ap;
1183 	int result;
1184 	va_start( ap, filename );
1185 	result = vips_call_split( "jxlsave", ap, in, filename );
1186 	va_end( ap );
1187 	return( result );
1188 }
1189 int
1190 vips_jxlsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
1191 {
1192 	va_list ap;
1193 	VipsArea *area;
1194 	int result;
1195 	area = NULL; 
1196 	va_start( ap, len );
1197 	result = vips_call_split( "jxlsave_buffer", ap, in, &amp;area );
1198 	va_end( ap );
1199 	if( !result &amp;&amp;
1200 		area ) { 
1201 		if( buf ) {
1202 			*buf = area-&gt;data;
1203 			area-&gt;free_fn = NULL;
1204 		}
1205 		if( len ) 
1206 			*len = area-&gt;length;
1207 		vips_area_unref( area );
1208 	}
1209 	return( result );
1210 }
1211 int
1212 vips_jxlsave_target( VipsImage *in, VipsTarget *target, ... )
1213 {
1214 	va_list ap;
1215 	int result;
1216 	va_start( ap, target );
1217 	result = vips_call_split( "jxlsave_target", ap, in, target );
1218 	va_end( ap );
1219 	return( result );
1220 }
1221 int
1222 vips_pdfload( const char *filename, VipsImage **out, ... )
1223 {
1224 	va_list ap;
1225 	int result;
1226 	va_start( ap, out );
1227 	result = vips_call_split( "pdfload", ap, filename, out );
1228 	va_end( ap );
1229 	return( result );
1230 }
1231 int
1232 vips_pdfload_buffer( void *buf, size_t len, VipsImage **out, ... )
1233 {
1234 	va_list ap;
1235 	VipsBlob *blob;
1236 	int result;
1237 	blob = vips_blob_new( NULL, buf, len );
1238 	va_start( ap, out );
1239 	result = vips_call_split( "pdfload_buffer", ap, blob, out );
1240 	va_end( ap );
1241 	vips_area_unref( VIPS_AREA( blob ) );
1242 	return( result );
1243 }
1244 int
1245 vips_pdfload_source( VipsSource *source, VipsImage **out, ... )
1246 {
1247 	va_list ap;
1248 	int result;
1249 	va_start( ap, out );
1250 	result = vips_call_split( "pdfload_source", ap, source, out );
1251 	va_end( ap );
1252 	return( result );
1253 }
1254 int
1255 vips_openslideload( const char *filename, VipsImage **out, ... )
1256 {
1257 	va_list ap;
1258 	int result;
1259 	va_start( ap, out );
1260 	result = vips_call_split( "openslideload", ap, filename, out );
1261 	va_end( ap );
1262 	return( result );
1263 }
1264 int
1265 vips_openslideload_source( VipsSource *source, VipsImage **out, ... )
1266 {
1267 	va_list ap;
1268 	int result;
1269 	va_start( ap, out );
1270 	result = vips_call_split( "openslideload_source", ap, source, out );
1271 	va_end( ap );
1272 	return( result );
1273 }
1274 void
1275 vips_foreign_operation_init( void )
1276 {
1277 	extern GType vips_foreign_load_rad_file_get_type( void ); 
1278 	extern GType vips_foreign_load_rad_buffer_get_type( void ); 
1279 	extern GType vips_foreign_load_rad_source_get_type( void ); 
1280 	extern GType vips_foreign_save_rad_file_get_type( void ); 
1281 	extern GType vips_foreign_save_rad_buffer_get_type( void ); 
1282 	extern GType vips_foreign_save_rad_target_get_type( void ); 
1283 	extern GType vips_foreign_load_mat_get_type( void ); 
1284 	extern GType vips_foreign_load_ppm_file_get_type( void ); 
1285 	extern GType vips_foreign_load_ppm_source_get_type( void ); 
1286 	extern GType vips_foreign_save_ppm_file_get_type( void ); 
1287 	extern GType vips_foreign_save_ppm_target_get_type( void ); 
1288 	extern GType vips_foreign_load_png_file_get_type( void ); 
1289 	extern GType vips_foreign_load_png_buffer_get_type( void ); 
1290 	extern GType vips_foreign_load_png_source_get_type( void ); 
1291 	extern GType vips_foreign_save_png_file_get_type( void ); 
1292 	extern GType vips_foreign_save_png_buffer_get_type( void ); 
1293 	extern GType vips_foreign_save_png_target_get_type( void ); 
1294 	extern GType vips_foreign_load_csv_file_get_type( void ); 
1295 	extern GType vips_foreign_load_csv_source_get_type( void ); 
1296 	extern GType vips_foreign_save_csv_file_get_type( void ); 
1297 	extern GType vips_foreign_save_csv_target_get_type( void ); 
1298 	extern GType vips_foreign_load_matrix_file_get_type( void ); 
1299 	extern GType vips_foreign_load_matrix_source_get_type( void ); 
1300 	extern GType vips_foreign_save_matrix_file_get_type( void ); 
1301 	extern GType vips_foreign_save_matrix_target_get_type( void ); 
1302 	extern GType vips_foreign_print_matrix_get_type( void ); 
1303 	extern GType vips_foreign_load_fits_file_get_type( void ); 
1304 	extern GType vips_foreign_load_fits_source_get_type( void ); 
1305 	extern GType vips_foreign_save_fits_get_type( void ); 
1306 	extern GType vips_foreign_load_analyze_get_type( void ); 
1307 	extern GType vips_foreign_load_openexr_get_type( void ); 
1308 	extern GType vips_foreign_load_openslide_file_get_type( void ); 
1309 	extern GType vips_foreign_load_openslide_source_get_type( void ); 
1310 	extern GType vips_foreign_load_vips_file_get_type( void ); 
1311 	extern GType vips_foreign_load_vips_source_get_type( void ); 
1312 	extern GType vips_foreign_save_vips_file_get_type( void ); 
1313 	extern GType vips_foreign_save_vips_target_get_type( void ); 
1314 	extern GType vips_foreign_load_jpeg_file_get_type( void ); 
1315 	extern GType vips_foreign_load_jpeg_buffer_get_type( void ); 
1316 	extern GType vips_foreign_load_jpeg_source_get_type( void ); 
1317 	extern GType vips_foreign_save_jpeg_file_get_type( void ); 
1318 	extern GType vips_foreign_save_jpeg_buffer_get_type( void ); 
1319 	extern GType vips_foreign_save_jpeg_target_get_type( void ); 
1320 	extern GType vips_foreign_save_jpeg_mime_get_type( void ); 
1321 	extern GType vips_foreign_load_tiff_file_get_type( void ); 
1322 	extern GType vips_foreign_load_tiff_buffer_get_type( void ); 
1323 	extern GType vips_foreign_load_tiff_source_get_type( void ); 
1324 	extern GType vips_foreign_save_tiff_file_get_type( void ); 
1325 	extern GType vips_foreign_save_tiff_buffer_get_type( void ); 
1326 	extern GType vips_foreign_load_raw_get_type( void ); 
1327 	extern GType vips_foreign_save_raw_get_type( void ); 
1328 	extern GType vips_foreign_save_raw_fd_get_type( void ); 
1329 	extern GType vips_foreign_load_magick_file_get_type( void ); 
1330 	extern GType vips_foreign_load_magick_buffer_get_type( void ); 
1331 	extern GType vips_foreign_load_magick7_file_get_type( void ); 
1332 	extern GType vips_foreign_load_magick7_buffer_get_type( void ); 
1333 	extern GType vips_foreign_save_magick_file_get_type( void );
1334 	extern GType vips_foreign_save_magick_buffer_get_type( void );
1335 	extern GType vips_foreign_save_dz_file_get_type( void ); 
1336 	extern GType vips_foreign_save_dz_buffer_get_type( void ); 
1337 	extern GType vips_foreign_load_webp_file_get_type( void ); 
1338 	extern GType vips_foreign_load_webp_buffer_get_type( void ); 
1339 	extern GType vips_foreign_load_webp_source_get_type( void ); 
1340 	extern GType vips_foreign_save_webp_file_get_type( void ); 
1341 	extern GType vips_foreign_save_webp_buffer_get_type( void ); 
1342 	extern GType vips_foreign_save_webp_target_get_type( void ); 
1343 	extern GType vips_foreign_load_pdf_file_get_type( void ); 
1344 	extern GType vips_foreign_load_pdf_buffer_get_type( void ); 
1345 	extern GType vips_foreign_load_pdf_source_get_type( void ); 
1346 	extern GType vips_foreign_load_svg_file_get_type( void ); 
1347 	extern GType vips_foreign_load_svg_buffer_get_type( void ); 
1348 	extern GType vips_foreign_load_svg_source_get_type( void ); 
1349 	extern GType vips_foreign_load_jp2k_file_get_type( void ); 
1350 	extern GType vips_foreign_load_jp2k_buffer_get_type( void ); 
1351 	extern GType vips_foreign_load_jp2k_source_get_type( void ); 
1352 	extern GType vips_foreign_save_jp2k_file_get_type( void ); 
1353 	extern GType vips_foreign_save_jp2k_buffer_get_type( void ); 
1354 	extern GType vips_foreign_save_jp2k_target_get_type( void ); 
1355 	extern GType vips_foreign_load_jxl_file_get_type( void ); 
1356 	extern GType vips_foreign_load_jxl_buffer_get_type( void ); 
1357 	extern GType vips_foreign_load_jxl_source_get_type( void ); 
1358 	extern GType vips_foreign_save_jxl_file_get_type( void ); 
1359 	extern GType vips_foreign_save_jxl_buffer_get_type( void ); 
1360 	extern GType vips_foreign_save_jxl_target_get_type( void ); 
1361 	extern GType vips_foreign_load_heif_file_get_type( void ); 
1362 	extern GType vips_foreign_load_heif_buffer_get_type( void ); 
1363 	extern GType vips_foreign_load_heif_source_get_type( void ); 
1364 	extern GType vips_foreign_save_heif_file_get_type( void ); 
1365 	extern GType vips_foreign_save_heif_buffer_get_type( void ); 
1366 	extern GType vips_foreign_save_heif_target_get_type( void ); 
1367 	extern GType vips_foreign_load_nifti_file_get_type( void ); 
1368 	extern GType vips_foreign_load_nifti_source_get_type( void ); 
1369 	extern GType vips_foreign_save_nifti_get_type( void ); 
1370 	extern GType vips_foreign_load_nsgif_file_get_type( void ); 
1371 	extern GType vips_foreign_load_nsgif_buffer_get_type( void ); 
1372 	extern GType vips_foreign_load_nsgif_source_get_type( void ); 
1373 	extern GType vips_foreign_save_cgif_file_get_type( void );
1374 	extern GType vips_foreign_save_cgif_buffer_get_type( void );
1375 	extern GType vips_foreign_save_cgif_target_get_type( void );
1376 	vips_foreign_load_csv_file_get_type(); 
1377 	vips_foreign_load_csv_source_get_type(); 
1378 	vips_foreign_save_csv_file_get_type(); 
1379 	vips_foreign_save_csv_target_get_type(); 
1380 	vips_foreign_load_matrix_file_get_type(); 
1381 	vips_foreign_load_matrix_source_get_type(); 
1382 	vips_foreign_save_matrix_file_get_type(); 
1383 	vips_foreign_save_matrix_target_get_type(); 
1384 	vips_foreign_print_matrix_get_type(); 
1385 	vips_foreign_load_raw_get_type(); 
1386 	vips_foreign_save_raw_get_type(); 
1387 	vips_foreign_save_raw_fd_get_type(); 
1388 	vips_foreign_load_vips_file_get_type(); 
1389 	vips_foreign_load_vips_source_get_type(); 
1390 	vips_foreign_save_vips_file_get_type(); 
1391 	vips_foreign_save_vips_target_get_type(); 
1392 #ifdef HAVE_ANALYZE
1393 	vips_foreign_load_analyze_get_type(); 
1394 #ifdef HAVE_PPM
1395 	vips_foreign_load_ppm_file_get_type(); 
1396 	vips_foreign_load_ppm_source_get_type(); 
1397 	vips_foreign_save_ppm_file_get_type(); 
1398 	vips_foreign_save_ppm_target_get_type(); 
1399 #ifdef HAVE_RADIANCE
1400 	vips_foreign_load_rad_file_get_type(); 
1401 	vips_foreign_load_rad_buffer_get_type(); 
1402 	vips_foreign_load_rad_source_get_type(); 
1403 	vips_foreign_save_rad_file_get_type(); 
1404 	vips_foreign_save_rad_buffer_get_type(); 
1405 	vips_foreign_save_rad_target_get_type(); 
1406 #if defined(HAVE_POPPLER) &amp;&amp; !defined(POPPLER_MODULE)
1407 	vips_foreign_load_pdf_file_get_type(); 
1408 	vips_foreign_load_pdf_buffer_get_type(); 
1409 	vips_foreign_load_pdf_source_get_type(); 
1410 #ifdef HAVE_PDFIUM
1411 	vips_foreign_load_pdf_file_get_type(); 
1412 	vips_foreign_load_pdf_buffer_get_type(); 
1413 	vips_foreign_load_pdf_source_get_type(); 
1414 #ifdef HAVE_RSVG
1415 	vips_foreign_load_svg_file_get_type(); 
1416 	vips_foreign_load_svg_buffer_get_type(); 
1417 	vips_foreign_load_svg_source_get_type(); 
1418 #if defined(HAVE_LIBJXL) &amp;&amp; !defined(LIBJXL_MODULE)
1419 	vips_foreign_load_jxl_file_get_type(); 
1420 	vips_foreign_load_jxl_buffer_get_type(); 
1421 	vips_foreign_load_jxl_source_get_type(); 
1422 	vips_foreign_save_jxl_file_get_type(); 
1423 	vips_foreign_save_jxl_buffer_get_type(); 
1424 	vips_foreign_save_jxl_target_get_type(); 
1425 #ifdef HAVE_LIBOPENJP2
1426 	vips_foreign_load_jp2k_file_get_type(); 
1427 	vips_foreign_load_jp2k_buffer_get_type(); 
1428 	vips_foreign_load_jp2k_source_get_type(); 
1429 	vips_foreign_save_jp2k_file_get_type(); 
1430 	vips_foreign_save_jp2k_buffer_get_type(); 
1431 	vips_foreign_save_jp2k_target_get_type(); 
1432 #ifdef HAVE_NSGIF
1433 	vips_foreign_load_nsgif_file_get_type();
1434 	vips_foreign_load_nsgif_buffer_get_type(); 
1435 	vips_foreign_load_nsgif_source_get_type(); 
1436 #ifdef HAVE_CGIF
1437 	vips_foreign_save_cgif_file_get_type();
1438 	vips_foreign_save_cgif_buffer_get_type();
1439 	vips_foreign_save_cgif_target_get_type();
1440 #ifdef HAVE_GSF
1441 	vips_foreign_save_dz_file_get_type(); 
1442 	vips_foreign_save_dz_buffer_get_type(); 
1443 #ifdef HAVE_PNG
1444 	vips_foreign_load_png_file_get_type(); 
1445 	vips_foreign_load_png_buffer_get_type(); 
1446 	vips_foreign_load_png_source_get_type(); 
1447 	vips_foreign_save_png_file_get_type(); 
1448 	vips_foreign_save_png_buffer_get_type(); 
1449 	vips_foreign_save_png_target_get_type(); 
1450 #ifdef HAVE_SPNG
1451 	vips_foreign_load_png_file_get_type(); 
1452 	vips_foreign_load_png_buffer_get_type(); 
1453 	vips_foreign_load_png_source_get_type(); 
1454 #ifdef HAVE_MATIO
1455 	vips_foreign_load_mat_get_type(); 
1456 #ifdef HAVE_JPEG
1457 	vips_foreign_load_jpeg_file_get_type(); 
1458 	vips_foreign_load_jpeg_buffer_get_type(); 
1459 	vips_foreign_load_jpeg_source_get_type(); 
1460 	vips_foreign_save_jpeg_file_get_type(); 
1461 	vips_foreign_save_jpeg_buffer_get_type(); 
1462 	vips_foreign_save_jpeg_target_get_type(); 
1463 	vips_foreign_save_jpeg_mime_get_type(); 
1464 #ifdef HAVE_LIBWEBP
1465 	vips_foreign_load_webp_file_get_type(); 
1466 	vips_foreign_load_webp_buffer_get_type(); 
1467 	vips_foreign_load_webp_source_get_type(); 
1468 	vips_foreign_save_webp_file_get_type(); 
1469 	vips_foreign_save_webp_buffer_get_type(); 
1470 	vips_foreign_save_webp_target_get_type(); 
1471 #ifdef HAVE_TIFF
1472 	vips_foreign_load_tiff_file_get_type(); 
1473 	vips_foreign_load_tiff_buffer_get_type(); 
1474 	vips_foreign_load_tiff_source_get_type(); 
1475 	vips_foreign_save_tiff_file_get_type(); 
1476 	vips_foreign_save_tiff_buffer_get_type(); 
1477 #if defined(HAVE_OPENSLIDE) &amp;&amp; !defined(OPENSLIDE_MODULE)
1478 	vips_foreign_load_openslide_file_get_type(); 
1479 	vips_foreign_load_openslide_source_get_type(); 
1480 #if defined(ENABLE_MAGICKLOAD) &amp;&amp; !defined(MAGICK_MODULE)
1481 #ifdef HAVE_MAGICK6
1482 	vips_foreign_load_magick_file_get_type();
1483 	vips_foreign_load_magick_buffer_get_type();
1484 #ifdef HAVE_MAGICK7
1485 	vips_foreign_load_magick7_file_get_type();
1486 	vips_foreign_load_magick7_buffer_get_type();
1487 #if defined(ENABLE_MAGICKSAVE) &amp;&amp; !defined(MAGICK_MODULE)
1488 	vips_foreign_save_magick_file_get_type();
1489 	vips_foreign_save_magick_buffer_get_type();
1490 #ifdef HAVE_CFITSIO
1491 	vips_foreign_load_fits_file_get_type(); 
1492 	vips_foreign_load_fits_source_get_type(); 
1493 	vips_foreign_save_fits_get_type(); 
1494 #ifdef HAVE_OPENEXR
1495 	vips_foreign_load_openexr_get_type(); 
1496 #ifdef HAVE_NIFTI
1497 	vips_foreign_load_nifti_file_get_type(); 
1498 	vips_foreign_load_nifti_source_get_type(); 
1499 	vips_foreign_save_nifti_get_type(); 
1500 #if defined(HAVE_HEIF_DECODER) &amp;&amp; !defined(HEIF_MODULE)
1501 	vips_foreign_load_heif_file_get_type(); 
1502 	vips_foreign_load_heif_buffer_get_type(); 
1503 	vips_foreign_load_heif_source_get_type(); 
1504 #if defined(HAVE_HEIF_ENCODER) &amp;&amp; !defined(HEIF_MODULE)
1505 	vips_foreign_save_heif_file_get_type(); 
1506 	vips_foreign_save_heif_buffer_get_type(); 
1507 	vips_foreign_save_heif_target_get_type(); 
1508 	vips__foreign_load_operation = 
1509 		g_quark_from_static_string( "vips-foreign-load-operation" ); 
1510 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
