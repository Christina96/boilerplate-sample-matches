
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstrlib.c</h3>
            <pre><code>1  #include &lt;ctype.h&gt;
2  #include &lt;stddef.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdlib.h&gt;
5  #include &lt;string.h&gt;
6  #define lstrlib_c
7  #define LUA_LIB
8  #include &quot;lua.h&quot;
9  #include &quot;lauxlib.h&quot;
10  #include &quot;lualib.h&quot;
11  #define uchar(c)        ((unsigned char)(c))
12  static int str_len (lua_State *L) {
13    size_t l;
14    luaL_checklstring(L, 1, &amp;l);
15    lua_pushinteger(L, l);
16    return 1;
17  }
18  static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
19    if (pos &lt; 0) pos += (ptrdiff_t)len + 1;
20    return (pos &gt;= 0) ? pos : 0;
21  }
22  static int str_sub (lua_State *L) {
23    size_t l;
24    const char *s = luaL_checklstring(L, 1, &amp;l);
25    ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
26    ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
27    if (start &lt; 1) start = 1;
28    if (end &gt; (ptrdiff_t)l) end = (ptrdiff_t)l;
29    if (start &lt;= end)
30      lua_pushlstring(L, s+start-1, end-start+1);
31    else lua_pushliteral(L, &quot;&quot;);
32    return 1;
33  }
34  static int str_reverse (lua_State *L) {
35    size_t l;
36    luaL_Buffer b;
37    const char *s = luaL_checklstring(L, 1, &amp;l);
38    luaL_buffinit(L, &amp;b);
39    while (l--) luaL_addchar(&amp;b, s[l]);
40    luaL_pushresult(&amp;b);
41    return 1;
42  }
43  static int str_lower (lua_State *L) {
44    size_t l;
45    size_t i;
46    luaL_Buffer b;
47    const char *s = luaL_checklstring(L, 1, &amp;l);
48    luaL_buffinit(L, &amp;b);
49    for (i=0; i&lt;l; i++)
50      luaL_addchar(&amp;b, tolower(uchar(s[i])));
51    luaL_pushresult(&amp;b);
52    return 1;
53  }
54  static int str_upper (lua_State *L) {
55    size_t l;
56    size_t i;
57    luaL_Buffer b;
58    const char *s = luaL_checklstring(L, 1, &amp;l);
59    luaL_buffinit(L, &amp;b);
60    for (i=0; i&lt;l; i++)
61      luaL_addchar(&amp;b, toupper(uchar(s[i])));
62    luaL_pushresult(&amp;b);
63    return 1;
64  }
65  static int str_rep (lua_State *L) {
66    size_t l;
67    luaL_Buffer b;
68    const char *s = luaL_checklstring(L, 1, &amp;l);
69    int n = luaL_checkint(L, 2);
70    luaL_buffinit(L, &amp;b);
71    while (n-- &gt; 0)
72      luaL_addlstring(&amp;b, s, l);
73    luaL_pushresult(&amp;b);
74    return 1;
75  }
76  static int str_byte (lua_State *L) {
77    size_t l;
78    const char *s = luaL_checklstring(L, 1, &amp;l);
79    ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
80    ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
81    int n, i;
82    if (posi &lt;= 0) posi = 1;
83    if ((size_t)pose &gt; l) pose = l;
84    if (posi &gt; pose) return 0;  &amp;bsol;* empty interval; return no values */
85    n = (int)(pose -  posi + 1);
86    if (posi + n &lt;= pose)  &amp;bsol;* overflow? */
87      luaL_error(L, &quot;string slice too long&quot;);
88    luaL_checkstack(L, n, &quot;string slice too long&quot;);
89    for (i=0; i&lt;n; i++)
90      lua_pushinteger(L, uchar(s[posi+i-1]));
91    return n;
92  }
93  static int str_char (lua_State *L) {
94    int n = lua_gettop(L);  &amp;bsol;* number of arguments */
95    int i;
96    luaL_Buffer b;
97    luaL_buffinit(L, &amp;b);
98    for (i=1; i&lt;=n; i++) {
99      int c = luaL_checkint(L, i);
100      luaL_argcheck(L, uchar(c) == c, i, &quot;invalid value&quot;);
101      luaL_addchar(&amp;b, uchar(c));
102    }
103    luaL_pushresult(&amp;b);
104    return 1;
105  }
106  static int writer (lua_State *L, const void* b, size_t size, void* B) {
107    (void)L;
108    luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
109    return 0;
110  }
111  static int str_dump (lua_State *L) {
112    luaL_Buffer b;
113    luaL_checktype(L, 1, LUA_TFUNCTION);
114    lua_settop(L, 1);
115    luaL_buffinit(L,&amp;b);
116    if (lua_dump(L, writer, &amp;b) != 0)
117      luaL_error(L, &quot;unable to dump given function&quot;);
118    luaL_pushresult(&amp;b);
119    return 1;
120  }
121  #define CAP_UNFINISHED	(-1)
122  #define CAP_POSITION	(-2)
123  typedef struct MatchState {
124    const char *src_init;  &amp;bsol;* init of source string */
125    const char *src_end;  &amp;bsol;* end (`\0&#x27;) of source string */
126    lua_State *L;
127    int level;  &amp;bsol;* total number of captures (finished or unfinished) */
128    struct {
129      const char *init;
130      ptrdiff_t len;
131    } capture[LUA_MAXCAPTURES];
132  } MatchState;
133  #define L_ESC		&#x27;%&#x27;
134  #define SPECIALS	&quot;^$*+?.([%-&quot;
135  static int check_capture (MatchState *ms, int l) {
136    l -= &#x27;1&#x27;;
137    if (l &lt; 0 || l &gt;= ms-&gt;level || ms-&gt;capture[l].len == CAP_UNFINISHED)
138      return luaL_error(ms-&gt;L, &quot;invalid capture index&quot;);
139    return l;
140  }
141  static int capture_to_close (MatchState *ms) {
142    int level = ms-&gt;level;
143    for (level--; level&gt;=0; level--)
144      if (ms-&gt;capture[level].len == CAP_UNFINISHED) return level;
145    return luaL_error(ms-&gt;L, &quot;invalid pattern capture&quot;);
146  }
147  static const char *classend (MatchState *ms, const char *p) {
148    switch (*p++) {
149      case L_ESC: {
150        if (*p == &#x27;\0&#x27;)
151          luaL_error(ms-&gt;L, &quot;malformed pattern (ends with &quot; LUA_QL(&quot;%%&quot;) &quot;)&quot;);
152        return p+1;
153      }
154      case &#x27;[&#x27;: {
155        if (*p == &#x27;^&#x27;) p++;
156        do {  &amp;bsol;* look for a `]&#x27; */
157          if (*p == &#x27;\0&#x27;)
158            luaL_error(ms-&gt;L, &quot;malformed pattern (missing &quot; LUA_QL(&quot;]&quot;) &quot;)&quot;);
159          if (*(p++) == L_ESC &amp;&amp; *p != &#x27;\0&#x27;)
160            p++;  &amp;bsol;* skip escapes (e.g. `%]&#x27;) */
161        } while (*p != &#x27;]&#x27;);
162        return p+1;
163      }
164      default: {
165        return p;
166      }
167    }
168  }
169  static int match_class (int c, int cl) {
170    int res;
171    switch (tolower(cl)) {
172      case &#x27;a&#x27; : res = isalpha(c); break;
173      case &#x27;c&#x27; : res = iscntrl(c); break;
174      case &#x27;d&#x27; : res = isdigit(c); break;
175      case &#x27;l&#x27; : res = islower(c); break;
176      case &#x27;p&#x27; : res = ispunct(c); break;
177      case &#x27;s&#x27; : res = isspace(c); break;
178      case &#x27;u&#x27; : res = isupper(c); break;
179      case &#x27;w&#x27; : res = isalnum(c); break;
180      case &#x27;x&#x27; : res = isxdigit(c); break;
181      case &#x27;z&#x27; : res = (c == 0); break;
182      default: return (cl == c);
183    }
184    return (islower(cl) ? res : !res);
185  }
186  static int matchbracketclass (int c, const char *p, const char *ec) {
187    int sig = 1;
188    if (*(p+1) == &#x27;^&#x27;) {
189      sig = 0;
190      p++;  &amp;bsol;* skip the `^&#x27; */
191    }
192    while (++p &lt; ec) {
193      if (*p == L_ESC) {
194        p++;
195        if (match_class(c, uchar(*p)))
196          return sig;
197      }
198      else if ((*(p+1) == &#x27;-&#x27;) &amp;&amp; (p+2 &lt; ec)) {
199        p+=2;
200        if (uchar(*(p-2)) &lt;= c &amp;&amp; c &lt;= uchar(*p))
201          return sig;
202      }
203      else if (uchar(*p) == c) return sig;
204    }
205    return !sig;
206  }
207  static int singlematch (int c, const char *p, const char *ep) {
208    switch (*p) {
209      case &#x27;.&#x27;: return 1;  &amp;bsol;* matches any char */
210      case L_ESC: return match_class(c, uchar(*(p+1)));
211      case &#x27;[&#x27;: return matchbracketclass(c, p, ep-1);
212      default:  return (uchar(*p) == c);
213    }
214  }
215  static const char *match (MatchState *ms, const char *s, const char *p);
216  static const char *matchbalance (MatchState *ms, const char *s,
217                                     const char *p) {
218    if (*p == 0 || *(p+1) == 0)
219      luaL_error(ms-&gt;L, &quot;unbalanced pattern&quot;);
220    if (*s != *p) return NULL;
221    else {
222      int b = *p;
223      int e = *(p+1);
224      int cont = 1;
225      while (++s &lt; ms-&gt;src_end) {
226        if (*s == e) {
227          if (--cont == 0) return s+1;
228        }
229        else if (*s == b) cont++;
230      }
231    }
232    return NULL;  &amp;bsol;* string ends out of balance */
233  }
234  static const char *max_expand (MatchState *ms, const char *s,
235                                   const char *p, const char *ep) {
236    ptrdiff_t i = 0;  &amp;bsol;* counts maximum expand for item */
237    while ((s+i)&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*(s+i)), p, ep))
238      i++;
239    while (i&gt;=0) {
240      const char *res = match(ms, (s+i), ep+1);
241      if (res) return res;
242      i--;  &amp;bsol;* else didn&#x27;t match; reduce 1 repetition to try again */
243    }
244    return NULL;
245  }
246  static const char *min_expand (MatchState *ms, const char *s,
247                                   const char *p, const char *ep) {
248    for (;;) {
249      const char *res = match(ms, s, ep+1);
250      if (res != NULL)
251        return res;
252      else if (s&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*s), p, ep))
253        s++;  &amp;bsol;* try with one more repetition */
254      else return NULL;
255    }
256  }
257  static const char *start_capture (MatchState *ms, const char *s,
258                                      const char *p, int what) {
259    const char *res;
260    int level = ms-&gt;level;
261    if (level &gt;= LUA_MAXCAPTURES) luaL_error(ms-&gt;L, &quot;too many captures&quot;);
262    ms-&gt;capture[level].init = s;
263    ms-&gt;capture[level].len = what;
264    ms-&gt;level = level+1;
265    if ((res=match(ms, s, p)) == NULL)  &amp;bsol;* match failed? */
266      ms-&gt;level--;  &amp;bsol;* undo capture */
267    return res;
268  }
269  static const char *end_capture (MatchState *ms, const char *s,
270                                    const char *p) {
271    int l = capture_to_close(ms);
272    const char *res;
273    ms-&gt;capture[l].len = s - ms-&gt;capture[l].init;  &amp;bsol;* close capture */
274    if ((res = match(ms, s, p)) == NULL)  &amp;bsol;* match failed? */
275      ms-&gt;capture[l].len = CAP_UNFINISHED;  &amp;bsol;* undo capture */
276    return res;
277  }
278  static const char *match_capture (MatchState *ms, const char *s, int l) {
279    size_t len;
280    l = check_capture(ms, l);
281    len = ms-&gt;capture[l].len;
282    if ((size_t)(ms-&gt;src_end-s) &gt;= len &amp;&amp;
283        memcmp(ms-&gt;capture[l].init, s, len) == 0)
284      return s+len;
285    else return NULL;
286  }
287  static const char *match (MatchState *ms, const char *s, const char *p) {
288    init: &amp;bsol;* using goto&#x27;s to optimize tail recursion */
289    switch (*p) {
290      case &#x27;(&#x27;: {  &amp;bsol;* start capture */
291        if (*(p+1) == &#x27;)&#x27;)  &amp;bsol;* position capture? */
292          return start_capture(ms, s, p+2, CAP_POSITION);
293        else
294          return start_capture(ms, s, p+1, CAP_UNFINISHED);
295      }
296      case &#x27;)&#x27;: {  &amp;bsol;* end capture */
297        return end_capture(ms, s, p+1);
298      }
299      case L_ESC: {
300        switch (*(p+1)) {
301          case &#x27;b&#x27;: {  &amp;bsol;* balanced string? */
302            s = matchbalance(ms, s, p+2);
303            if (s == NULL) return NULL;
304            p+=4; goto init;  &amp;bsol;* else return match(ms, s, p+4); */
305          }
306          case &#x27;f&#x27;: {  &amp;bsol;* frontier? */
307            const char *ep; char previous;
308            p += 2;
309            if (*p != &#x27;[&#x27;)
310              luaL_error(ms-&gt;L, &quot;missing &quot; LUA_QL(&quot;[&quot;) &quot; after &quot;
311                                 LUA_QL(&quot;%%f&quot;) &quot; in pattern&quot;);
312            ep = classend(ms, p);  &amp;bsol;* points to what is next */
313            previous = (s == ms-&gt;src_init) ? &#x27;\0&#x27; : *(s-1);
314            if (matchbracketclass(uchar(previous), p, ep-1) ||
315               !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
316            p=ep; goto init;  &amp;bsol;* else return match(ms, s, ep); */
317          }
318          default: {
319            if (isdigit(uchar(*(p+1)))) {  &amp;bsol;* capture results (%0-%9)? */
320              s = match_capture(ms, s, uchar(*(p+1)));
321              if (s == NULL) return NULL;
322              p+=2; goto init;  &amp;bsol;* else return match(ms, s, p+2) */
323            }
324            goto dflt;  &amp;bsol;* case default */
325          }
326        }
327      }
328      case &#x27;\0&#x27;: {  &amp;bsol;* end of pattern */
329        return s;  &amp;bsol;* match succeeded */
330      }
331      case &#x27;$&#x27;: {
332        if (*(p+1) == &#x27;\0&#x27;)  &amp;bsol;* is the `$&#x27; the last char in pattern? */
333          return (s == ms-&gt;src_end) ? s : NULL;  &amp;bsol;* check end of string */
334        else goto dflt;
335      }
336      default: dflt: {  &amp;bsol;* it is a pattern item */
337        const char *ep = classend(ms, p);  &amp;bsol;* points to what is next */
338        int m = s&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*s), p, ep);
339        switch (*ep) {
340          case &#x27;?&#x27;: {  &amp;bsol;* optional */
341            const char *res;
342            if (m &amp;&amp; ((res=match(ms, s+1, ep+1)) != NULL))
343              return res;
344            p=ep+1; goto init;  &amp;bsol;* else return match(ms, s, ep+1); */
345          }
346          case &#x27;*&#x27;: {  &amp;bsol;* 0 or more repetitions */
347            return max_expand(ms, s, p, ep);
348          }
349          case &#x27;+&#x27;: {  &amp;bsol;* 1 or more repetitions */
350            return (m ? max_expand(ms, s+1, p, ep) : NULL);
351          }
352          case &#x27;-&#x27;: {  &amp;bsol;* 0 or more repetitions (minimum) */
353            return min_expand(ms, s, p, ep);
354          }
355          default: {
356            if (!m) return NULL;
357            s++; p=ep; goto init;  &amp;bsol;* else return match(ms, s+1, ep); */
358          }
359        }
360      }
361    }
362  }
363  static const char *lmemfind (const char *s1, size_t l1,
364                                 const char *s2, size_t l2) {
365    if (l2 == 0) return s1;  &amp;bsol;* empty strings are everywhere */
366    else if (l2 &gt; l1) return NULL;  &amp;bsol;* avoids a negative `l1&#x27; */
367    else {
368      const char *init;  &amp;bsol;* to search for a `*s2&#x27; inside `s1&#x27; */
369      l2--;  &amp;bsol;* 1st char will be checked by `memchr&#x27; */
370      l1 = l1-l2;  &amp;bsol;* `s2&#x27; cannot be found after that */
371      while (l1 &gt; 0 &amp;&amp; (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
372        init++;   &amp;bsol;* 1st char is already checked */
373        if (memcmp(init, s2+1, l2) == 0)
374          return init-1;
375        else {  &amp;bsol;* correct `l1&#x27; and `s1&#x27; to try again */
376          l1 -= init-s1;
377          s1 = init;
378        }
379      }
380      return NULL;  &amp;bsol;* not found */
381    }
382  }
383  static void push_onecapture (MatchState *ms, int i, const char *s,
384                                                      const char *e) {
385    if (i &gt;= ms-&gt;level) {
386      if (i == 0)  &amp;bsol;* ms-&gt;level == 0, too */
387        lua_pushlstring(ms-&gt;L, s, e - s);  &amp;bsol;* add whole match */
388      else
389        luaL_error(ms-&gt;L, &quot;invalid capture index&quot;);
390    }
391    else {
392      ptrdiff_t l = ms-&gt;capture[i].len;
393      if (l == CAP_UNFINISHED) luaL_error(ms-&gt;L, &quot;unfinished capture&quot;);
394      if (l == CAP_POSITION)
395        lua_pushinteger(ms-&gt;L, ms-&gt;capture[i].init - ms-&gt;src_init + 1);
396      else
397        lua_pushlstring(ms-&gt;L, ms-&gt;capture[i].init, l);
398    }
399  }
400  static int push_captures (MatchState *ms, const char *s, const char *e) {
401    int i;
402    int nlevels = (ms-&gt;level == 0 &amp;&amp; s) ? 1 : ms-&gt;level;
403    luaL_checkstack(ms-&gt;L, nlevels, &quot;too many captures&quot;);
404    for (i = 0; i &lt; nlevels; i++)
405      push_onecapture(ms, i, s, e);
406    return nlevels;  &amp;bsol;* number of strings pushed */
407  }
408  static int str_find_aux (lua_State *L, int find) {
409    size_t l1, l2;
410    const char *s = luaL_checklstring(L, 1, &amp;l1);
411    const char *p = luaL_checklstring(L, 2, &amp;l2);
412    ptrdiff_t init = posrelat(luaL_optinteger(L, 3, 1), l1) - 1;
413    if (init &lt; 0) init = 0;
414    else if ((size_t)(init) &gt; l1) init = (ptrdiff_t)l1;
415    if (find &amp;&amp; (lua_toboolean(L, 4) ||  &amp;bsol;* explicit request? */
416        strpbrk(p, SPECIALS) == NULL)) {  &amp;bsol;* or no special characters? */
417      const char *s2 = lmemfind(s+init, l1-init, p, l2);
418      if (s2) {
419        lua_pushinteger(L, s2-s+1);
420        lua_pushinteger(L, s2-s+l2);
421        return 2;
422      }
423    }
424    else {
425      MatchState ms;
<span onclick='openModal()' class='match'>426      int anchor = (*p == &#x27;^&#x27;) ? (p++, 1) : 0;
427      const char *s1=s+init;
</span>428      ms.L = L;
429      ms.src_init = s;
430      ms.src_end = s+l1;
431      do {
432        const char *res;
433        ms.level = 0;
434        if ((res=match(&amp;ms, s1, p)) != NULL) {
435          if (find) {
436            lua_pushinteger(L, s1-s+1);  &amp;bsol;* start */
437            lua_pushinteger(L, res-s);   &amp;bsol;* end */
438            return push_captures(&amp;ms, NULL, 0) + 2;
439          }
440          else
441            return push_captures(&amp;ms, s1, res);
442        }
443      } while (s1++ &lt; ms.src_end &amp;&amp; !anchor);
444    }
445    lua_pushnil(L);  &amp;bsol;* not found */
446    return 1;
447  }
448  static int str_find (lua_State *L) {
449    return str_find_aux(L, 1);
450  }
451  static int str_match (lua_State *L) {
452    return str_find_aux(L, 0);
453  }
454  static int gmatch_aux (lua_State *L) {
455    MatchState ms;
456    size_t ls;
457    const char *s = lua_tolstring(L, lua_upvalueindex(1), &amp;ls);
458    const char *p = lua_tostring(L, lua_upvalueindex(2));
459    const char *src;
460    ms.L = L;
461    ms.src_init = s;
462    ms.src_end = s+ls;
463    for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
464         src &lt;= ms.src_end;
465         src++) {
466      const char *e;
467      ms.level = 0;
468      if ((e = match(&amp;ms, src, p)) != NULL) {
469        lua_Integer newstart = e-s;
470        if (e == src) newstart++;  &amp;bsol;* empty match? go at least one position */
471        lua_pushinteger(L, newstart);
472        lua_replace(L, lua_upvalueindex(3));
473        return push_captures(&amp;ms, src, e);
474      }
475    }
476    return 0;  &amp;bsol;* not found */
477  }
478  static int gmatch (lua_State *L) {
479    luaL_checkstring(L, 1);
480    luaL_checkstring(L, 2);
481    lua_settop(L, 2);
482    lua_pushinteger(L, 0);
483    lua_pushcclosure(L, gmatch_aux, 3);
484    return 1;
485  }
486  static int gfind_nodef (lua_State *L) {
487    return luaL_error(L, LUA_QL(&quot;string.gfind&quot;) &quot; was renamed to &quot;
488                         LUA_QL(&quot;string.gmatch&quot;));
489  }
490  static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
491                                                     const char *e) {
492    size_t l, i;
493    const char *news = lua_tolstring(ms-&gt;L, 3, &amp;l);
494    for (i = 0; i &lt; l; i++) {
495      if (news[i] != L_ESC)
496        luaL_addchar(b, news[i]);
497      else {
498        i++;  &amp;bsol;* skip ESC */
499        if (!isdigit(uchar(news[i])))
500          luaL_addchar(b, news[i]);
501        else if (news[i] == &#x27;0&#x27;)
502            luaL_addlstring(b, s, e - s);
503        else {
504          push_onecapture(ms, news[i] - &#x27;1&#x27;, s, e);
505          luaL_addvalue(b);  &amp;bsol;* add capture to accumulated result */
506        }
507      }
508    }
509  }
510  static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
511                                                         const char *e) {
512    lua_State *L = ms-&gt;L;
513    switch (lua_type(L, 3)) {
514      case LUA_TNUMBER:
515      case LUA_TSTRING: {
516        add_s(ms, b, s, e);
517        return;
518      }
519      case LUA_TFUNCTION: {
520        int n;
521        lua_pushvalue(L, 3);
522        n = push_captures(ms, s, e);
523        lua_call(L, n, 1);
524        break;
525      }
526      case LUA_TTABLE: {
527        push_onecapture(ms, 0, s, e);
528        lua_gettable(L, 3);
529        break;
530      }
531    }
532    if (!lua_toboolean(L, -1)) {  &amp;bsol;* nil or false? */
533      lua_pop(L, 1);
534      lua_pushlstring(L, s, e - s);  &amp;bsol;* keep original text */
535    }
536    else if (!lua_isstring(L, -1))
537      luaL_error(L, &quot;invalid replacement value (a %s)&quot;, luaL_typename(L, -1)); 
538    luaL_addvalue(b);  &amp;bsol;* add result to accumulator */
539  }
540  static int str_gsub (lua_State *L) {
541    size_t srcl;
542    const char *src = luaL_checklstring(L, 1, &amp;srcl);
543    const char *p = luaL_checkstring(L, 2);
544    int  tr = lua_type(L, 3);
545    int max_s = luaL_optint(L, 4, srcl+1);
546    int anchor = (*p == &#x27;^&#x27;) ? (p++, 1) : 0;
547    int n = 0;
548    MatchState ms;
549    luaL_Buffer b;
550    luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
551                     tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
552                        &quot;string/function/table expected&quot;);
553    luaL_buffinit(L, &amp;b);
554    ms.L = L;
555    ms.src_init = src;
556    ms.src_end = src+srcl;
557    while (n &lt; max_s) {
558      const char *e;
559      ms.level = 0;
560      e = match(&amp;ms, src, p);
561      if (e) {
562        n++;
563        add_value(&amp;ms, &amp;b, src, e);
564      }
565      if (e &amp;&amp; e&gt;src) &amp;bsol;* non empty match? */
566        src = e;  &amp;bsol;* skip it */
567      else if (src &lt; ms.src_end)
568        luaL_addchar(&amp;b, *src++);
569      else break;
570      if (anchor) break;
571    }
572    luaL_addlstring(&amp;b, src, ms.src_end-src);
573    luaL_pushresult(&amp;b);
574    lua_pushinteger(L, n);  &amp;bsol;* number of substitutions */
575    return 2;
576  }
577  #define MAX_ITEM	512
578  #define FLAGS	&quot;-+ #0&quot;
579  #define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
580  static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
581    size_t l;
582    const char *s = luaL_checklstring(L, arg, &amp;l);
583    luaL_addchar(b, &#x27;&quot;&#x27;);
584    while (l--) {
585      switch (*s) {
586        case &#x27;&quot;&#x27;: case &#x27;\\&#x27;: case &#x27;\n&#x27;: {
587          luaL_addchar(b, &#x27;\\&#x27;);
588          luaL_addchar(b, *s);
589          break;
590        }
591        case &#x27;\r&#x27;: {
592          luaL_addlstring(b, &quot;\\r&quot;, 2);
593          break;
594        }
595        case &#x27;\0&#x27;: {
596          luaL_addlstring(b, &quot;\\000&quot;, 4);
597          break;
598        }
599        default: {
600          luaL_addchar(b, *s);
601          break;
602        }
603      }
604      s++;
605    }
606    luaL_addchar(b, &#x27;&quot;&#x27;);
607  }
608  static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
609    const char *p = strfrmt;
610    while (*p != &#x27;\0&#x27; &amp;&amp; strchr(FLAGS, *p) != NULL) p++;  &amp;bsol;* skip flags */
611    if ((size_t)(p - strfrmt) &gt;= sizeof(FLAGS))
612      luaL_error(L, &quot;invalid format (repeated flags)&quot;);
613    if (isdigit(uchar(*p))) p++;  &amp;bsol;* skip width */
614    if (isdigit(uchar(*p))) p++;  &amp;bsol;* (2 digits at most) */
615    if (*p == &#x27;.&#x27;) {
616      p++;
617      if (isdigit(uchar(*p))) p++;  &amp;bsol;* skip precision */
618      if (isdigit(uchar(*p))) p++;  &amp;bsol;* (2 digits at most) */
619    }
620    if (isdigit(uchar(*p)))
621      luaL_error(L, &quot;invalid format (width or precision too long)&quot;);
622    *(form++) = &#x27;%&#x27;;
623    strncpy(form, strfrmt, p - strfrmt + 1);
624    form += p - strfrmt + 1;
625    *form = &#x27;\0&#x27;;
626    return p;
627  }
628  static void addintlen (char *form) {
629    size_t l = strlen(form);
630    char spec = form[l - 1];
631    strcpy(form + l - 1, LUA_INTFRMLEN);
632    form[l + sizeof(LUA_INTFRMLEN) - 2] = spec;
633    form[l + sizeof(LUA_INTFRMLEN) - 1] = &#x27;\0&#x27;;
634  }
635  static int str_format (lua_State *L) {
636    int top = lua_gettop(L);
637    int arg = 1;
638    size_t sfl;
639    const char *strfrmt = luaL_checklstring(L, arg, &amp;sfl);
640    const char *strfrmt_end = strfrmt+sfl;
641    luaL_Buffer b;
642    luaL_buffinit(L, &amp;b);
643    while (strfrmt &lt; strfrmt_end) {
644      if (*strfrmt != L_ESC)
645        luaL_addchar(&amp;b, *strfrmt++);
646      else if (*++strfrmt == L_ESC)
647        luaL_addchar(&amp;b, *strfrmt++);  &amp;bsol;* %% */
648      else { &amp;bsol;* format item */
649        char form[MAX_FORMAT];  &amp;bsol;* to store the format (`%...&#x27;) */
650        char buff[MAX_ITEM];  &amp;bsol;* to store the formatted item */
651        if (++arg &gt; top)
652          luaL_argerror(L, arg, &quot;no value&quot;);
653        strfrmt = scanformat(L, strfrmt, form);
654        switch (*strfrmt++) {
655          case &#x27;c&#x27;: {
656            sprintf(buff, form, (int)luaL_checknumber(L, arg));
657            break;
658          }
659          case &#x27;d&#x27;:  case &#x27;i&#x27;: {
660            addintlen(form);
661            sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
662            break;
663          }
664          case &#x27;o&#x27;:  case &#x27;u&#x27;:  case &#x27;x&#x27;:  case &#x27;X&#x27;: {
665            addintlen(form);
666            sprintf(buff, form, (unsigned LUA_INTFRM_T)luaL_checknumber(L, arg));
667            break;
668          }
669          case &#x27;e&#x27;:  case &#x27;E&#x27;: case &#x27;f&#x27;:
670          case &#x27;g&#x27;: case &#x27;G&#x27;: {
671            sprintf(buff, form, (double)luaL_checknumber(L, arg));
672            break;
673          }
674          case &#x27;q&#x27;: {
675            addquoted(L, &amp;b, arg);
676            continue;  &amp;bsol;* skip the &#x27;addsize&#x27; at the end */
677          }
678          case &#x27;s&#x27;: {
679            size_t l;
680            const char *s = luaL_checklstring(L, arg, &amp;l);
681            if (!strchr(form, &#x27;.&#x27;) &amp;&amp; l &gt;= 100) {
682              lua_pushvalue(L, arg);
683              luaL_addvalue(&amp;b);
684              continue;  &amp;bsol;* skip the `addsize&#x27; at the end */
685            }
686            else {
687              sprintf(buff, form, s);
688              break;
689            }
690          }
691          default: {  &amp;bsol;* also treat cases `pnLlh&#x27; */
692            return luaL_error(L, &quot;invalid option &quot; LUA_QL(&quot;%%%c&quot;) &quot; to &quot;
693                                 LUA_QL(&quot;format&quot;), *(strfrmt - 1));
694          }
695        }
696        luaL_addlstring(&amp;b, buff, strlen(buff));
697      }
698    }
699    luaL_pushresult(&amp;b);
700    return 1;
701  }
702  static const luaL_Reg strlib[] = {
703    {&quot;byte&quot;, str_byte},
704    {&quot;char&quot;, str_char},
705    {&quot;dump&quot;, str_dump},
706    {&quot;find&quot;, str_find},
707    {&quot;format&quot;, str_format},
708    {&quot;gfind&quot;, gfind_nodef},
709    {&quot;gmatch&quot;, gmatch},
710    {&quot;gsub&quot;, str_gsub},
711    {&quot;len&quot;, str_len},
712    {&quot;lower&quot;, str_lower},
713    {&quot;match&quot;, str_match},
714    {&quot;rep&quot;, str_rep},
715    {&quot;reverse&quot;, str_reverse},
716    {&quot;sub&quot;, str_sub},
717    {&quot;upper&quot;, str_upper},
718    {NULL, NULL}
719  };
720  static void createmetatable (lua_State *L) {
721    lua_createtable(L, 0, 1);  &amp;bsol;* create metatable for strings */
722    lua_pushliteral(L, &quot;&quot;);  &amp;bsol;* dummy string */
723    lua_pushvalue(L, -2);
724    lua_setmetatable(L, -2);  &amp;bsol;* set string metatable */
725    lua_pop(L, 1);  &amp;bsol;* pop dummy string */
726    lua_pushvalue(L, -2);  &amp;bsol;* string library... */
727    lua_setfield(L, -2, &quot;__index&quot;);  &amp;bsol;* ...is the __index metamethod */
728    lua_pop(L, 1);  &amp;bsol;* pop metatable */
729  }
730  LUALIB_API int luaopen_string (lua_State *L) {
731    luaL_register(L, LUA_STRLIBNAME, strlib);
732  #if defined(LUA_COMPAT_GFIND)
733    lua_getfield(L, -1, &quot;gmatch&quot;);
734    lua_setfield(L, -2, &quot;gfind&quot;);
735  #endif
736    createmetatable(L);
737    return 1;
738  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstrlib.c</h3>
            <pre><code>1  #include &lt;ctype.h&gt;
2  #include &lt;stddef.h&gt;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdlib.h&gt;
5  #include &lt;string.h&gt;
6  #define lstrlib_c
7  #define LUA_LIB
8  #include &quot;lua.h&quot;
9  #include &quot;lauxlib.h&quot;
10  #include &quot;lualib.h&quot;
11  #define uchar(c)        ((unsigned char)(c))
12  static int str_len (lua_State *L) {
13    size_t l;
14    luaL_checklstring(L, 1, &amp;l);
15    lua_pushinteger(L, l);
16    return 1;
17  }
18  static ptrdiff_t posrelat (ptrdiff_t pos, size_t len) {
19    if (pos &lt; 0) pos += (ptrdiff_t)len + 1;
20    return (pos &gt;= 0) ? pos : 0;
21  }
22  static int str_sub (lua_State *L) {
23    size_t l;
24    const char *s = luaL_checklstring(L, 1, &amp;l);
25    ptrdiff_t start = posrelat(luaL_checkinteger(L, 2), l);
26    ptrdiff_t end = posrelat(luaL_optinteger(L, 3, -1), l);
27    if (start &lt; 1) start = 1;
28    if (end &gt; (ptrdiff_t)l) end = (ptrdiff_t)l;
29    if (start &lt;= end)
30      lua_pushlstring(L, s+start-1, end-start+1);
31    else lua_pushliteral(L, &quot;&quot;);
32    return 1;
33  }
34  static int str_reverse (lua_State *L) {
35    size_t l;
36    luaL_Buffer b;
37    const char *s = luaL_checklstring(L, 1, &amp;l);
38    luaL_buffinit(L, &amp;b);
39    while (l--) luaL_addchar(&amp;b, s[l]);
40    luaL_pushresult(&amp;b);
41    return 1;
42  }
43  static int str_lower (lua_State *L) {
44    size_t l;
45    size_t i;
46    luaL_Buffer b;
47    const char *s = luaL_checklstring(L, 1, &amp;l);
48    luaL_buffinit(L, &amp;b);
49    for (i=0; i&lt;l; i++)
50      luaL_addchar(&amp;b, tolower(uchar(s[i])));
51    luaL_pushresult(&amp;b);
52    return 1;
53  }
54  static int str_upper (lua_State *L) {
55    size_t l;
56    size_t i;
57    luaL_Buffer b;
58    const char *s = luaL_checklstring(L, 1, &amp;l);
59    luaL_buffinit(L, &amp;b);
60    for (i=0; i&lt;l; i++)
61      luaL_addchar(&amp;b, toupper(uchar(s[i])));
62    luaL_pushresult(&amp;b);
63    return 1;
64  }
65  static int str_rep (lua_State *L) {
66    size_t l;
67    luaL_Buffer b;
68    const char *s = luaL_checklstring(L, 1, &amp;l);
69    int n = luaL_checkint(L, 2);
70    luaL_buffinit(L, &amp;b);
71    while (n-- &gt; 0)
72      luaL_addlstring(&amp;b, s, l);
73    luaL_pushresult(&amp;b);
74    return 1;
75  }
76  static int str_byte (lua_State *L) {
77    size_t l;
78    const char *s = luaL_checklstring(L, 1, &amp;l);
79    ptrdiff_t posi = posrelat(luaL_optinteger(L, 2, 1), l);
80    ptrdiff_t pose = posrelat(luaL_optinteger(L, 3, posi), l);
81    int n, i;
82    if (posi &lt;= 0) posi = 1;
83    if ((size_t)pose &gt; l) pose = l;
84    if (posi &gt; pose) return 0;  &amp;bsol;* empty interval; return no values */
85    n = (int)(pose -  posi + 1);
86    if (posi + n &lt;= pose)  &amp;bsol;* overflow? */
87      luaL_error(L, &quot;string slice too long&quot;);
88    luaL_checkstack(L, n, &quot;string slice too long&quot;);
89    for (i=0; i&lt;n; i++)
90      lua_pushinteger(L, uchar(s[posi+i-1]));
91    return n;
92  }
93  static int str_char (lua_State *L) {
94    int n = lua_gettop(L);  &amp;bsol;* number of arguments */
95    int i;
96    luaL_Buffer b;
97    luaL_buffinit(L, &amp;b);
98    for (i=1; i&lt;=n; i++) {
99      int c = luaL_checkint(L, i);
100      luaL_argcheck(L, uchar(c) == c, i, &quot;invalid value&quot;);
101      luaL_addchar(&amp;b, uchar(c));
102    }
103    luaL_pushresult(&amp;b);
104    return 1;
105  }
106  static int writer (lua_State *L, const void* b, size_t size, void* B) {
107    (void)L;
108    luaL_addlstring((luaL_Buffer*) B, (const char *)b, size);
109    return 0;
110  }
111  static int str_dump (lua_State *L) {
112    luaL_Buffer b;
113    luaL_checktype(L, 1, LUA_TFUNCTION);
114    lua_settop(L, 1);
115    luaL_buffinit(L,&amp;b);
116    if (lua_dump(L, writer, &amp;b) != 0)
117      luaL_error(L, &quot;unable to dump given function&quot;);
118    luaL_pushresult(&amp;b);
119    return 1;
120  }
121  #define CAP_UNFINISHED	(-1)
122  #define CAP_POSITION	(-2)
123  typedef struct MatchState {
124    const char *src_init;  &amp;bsol;* init of source string */
125    const char *src_end;  &amp;bsol;* end (`\0&#x27;) of source string */
126    lua_State *L;
127    int level;  &amp;bsol;* total number of captures (finished or unfinished) */
128    struct {
129      const char *init;
130      ptrdiff_t len;
131    } capture[LUA_MAXCAPTURES];
132  } MatchState;
133  #define L_ESC		&#x27;%&#x27;
134  #define SPECIALS	&quot;^$*+?.([%-&quot;
135  static int check_capture (MatchState *ms, int l) {
136    l -= &#x27;1&#x27;;
137    if (l &lt; 0 || l &gt;= ms-&gt;level || ms-&gt;capture[l].len == CAP_UNFINISHED)
138      return luaL_error(ms-&gt;L, &quot;invalid capture index&quot;);
139    return l;
140  }
141  static int capture_to_close (MatchState *ms) {
142    int level = ms-&gt;level;
143    for (level--; level&gt;=0; level--)
144      if (ms-&gt;capture[level].len == CAP_UNFINISHED) return level;
145    return luaL_error(ms-&gt;L, &quot;invalid pattern capture&quot;);
146  }
147  static const char *classend (MatchState *ms, const char *p) {
148    switch (*p++) {
149      case L_ESC: {
150        if (*p == &#x27;\0&#x27;)
151          luaL_error(ms-&gt;L, &quot;malformed pattern (ends with &quot; LUA_QL(&quot;%%&quot;) &quot;)&quot;);
152        return p+1;
153      }
154      case &#x27;[&#x27;: {
155        if (*p == &#x27;^&#x27;) p++;
156        do {  &amp;bsol;* look for a `]&#x27; */
157          if (*p == &#x27;\0&#x27;)
158            luaL_error(ms-&gt;L, &quot;malformed pattern (missing &quot; LUA_QL(&quot;]&quot;) &quot;)&quot;);
159          if (*(p++) == L_ESC &amp;&amp; *p != &#x27;\0&#x27;)
160            p++;  &amp;bsol;* skip escapes (e.g. `%]&#x27;) */
161        } while (*p != &#x27;]&#x27;);
162        return p+1;
163      }
164      default: {
165        return p;
166      }
167    }
168  }
169  static int match_class (int c, int cl) {
170    int res;
171    switch (tolower(cl)) {
172      case &#x27;a&#x27; : res = isalpha(c); break;
173      case &#x27;c&#x27; : res = iscntrl(c); break;
174      case &#x27;d&#x27; : res = isdigit(c); break;
175      case &#x27;l&#x27; : res = islower(c); break;
176      case &#x27;p&#x27; : res = ispunct(c); break;
177      case &#x27;s&#x27; : res = isspace(c); break;
178      case &#x27;u&#x27; : res = isupper(c); break;
179      case &#x27;w&#x27; : res = isalnum(c); break;
180      case &#x27;x&#x27; : res = isxdigit(c); break;
181      case &#x27;z&#x27; : res = (c == 0); break;
182      default: return (cl == c);
183    }
184    return (islower(cl) ? res : !res);
185  }
186  static int matchbracketclass (int c, const char *p, const char *ec) {
187    int sig = 1;
188    if (*(p+1) == &#x27;^&#x27;) {
189      sig = 0;
190      p++;  &amp;bsol;* skip the `^&#x27; */
191    }
192    while (++p &lt; ec) {
193      if (*p == L_ESC) {
194        p++;
195        if (match_class(c, uchar(*p)))
196          return sig;
197      }
198      else if ((*(p+1) == &#x27;-&#x27;) &amp;&amp; (p+2 &lt; ec)) {
199        p+=2;
200        if (uchar(*(p-2)) &lt;= c &amp;&amp; c &lt;= uchar(*p))
201          return sig;
202      }
203      else if (uchar(*p) == c) return sig;
204    }
205    return !sig;
206  }
207  static int singlematch (int c, const char *p, const char *ep) {
208    switch (*p) {
209      case &#x27;.&#x27;: return 1;  &amp;bsol;* matches any char */
210      case L_ESC: return match_class(c, uchar(*(p+1)));
211      case &#x27;[&#x27;: return matchbracketclass(c, p, ep-1);
212      default:  return (uchar(*p) == c);
213    }
214  }
215  static const char *match (MatchState *ms, const char *s, const char *p);
216  static const char *matchbalance (MatchState *ms, const char *s,
217                                     const char *p) {
218    if (*p == 0 || *(p+1) == 0)
219      luaL_error(ms-&gt;L, &quot;unbalanced pattern&quot;);
220    if (*s != *p) return NULL;
221    else {
222      int b = *p;
223      int e = *(p+1);
224      int cont = 1;
225      while (++s &lt; ms-&gt;src_end) {
226        if (*s == e) {
227          if (--cont == 0) return s+1;
228        }
229        else if (*s == b) cont++;
230      }
231    }
232    return NULL;  &amp;bsol;* string ends out of balance */
233  }
234  static const char *max_expand (MatchState *ms, const char *s,
235                                   const char *p, const char *ep) {
236    ptrdiff_t i = 0;  &amp;bsol;* counts maximum expand for item */
237    while ((s+i)&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*(s+i)), p, ep))
238      i++;
239    while (i&gt;=0) {
240      const char *res = match(ms, (s+i), ep+1);
241      if (res) return res;
242      i--;  &amp;bsol;* else didn&#x27;t match; reduce 1 repetition to try again */
243    }
244    return NULL;
245  }
246  static const char *min_expand (MatchState *ms, const char *s,
247                                   const char *p, const char *ep) {
248    for (;;) {
249      const char *res = match(ms, s, ep+1);
250      if (res != NULL)
251        return res;
252      else if (s&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*s), p, ep))
253        s++;  &amp;bsol;* try with one more repetition */
254      else return NULL;
255    }
256  }
257  static const char *start_capture (MatchState *ms, const char *s,
258                                      const char *p, int what) {
259    const char *res;
260    int level = ms-&gt;level;
261    if (level &gt;= LUA_MAXCAPTURES) luaL_error(ms-&gt;L, &quot;too many captures&quot;);
262    ms-&gt;capture[level].init = s;
263    ms-&gt;capture[level].len = what;
264    ms-&gt;level = level+1;
265    if ((res=match(ms, s, p)) == NULL)  &amp;bsol;* match failed? */
266      ms-&gt;level--;  &amp;bsol;* undo capture */
267    return res;
268  }
269  static const char *end_capture (MatchState *ms, const char *s,
270                                    const char *p) {
271    int l = capture_to_close(ms);
272    const char *res;
273    ms-&gt;capture[l].len = s - ms-&gt;capture[l].init;  &amp;bsol;* close capture */
274    if ((res = match(ms, s, p)) == NULL)  &amp;bsol;* match failed? */
275      ms-&gt;capture[l].len = CAP_UNFINISHED;  &amp;bsol;* undo capture */
276    return res;
277  }
278  static const char *match_capture (MatchState *ms, const char *s, int l) {
279    size_t len;
280    l = check_capture(ms, l);
281    len = ms-&gt;capture[l].len;
282    if ((size_t)(ms-&gt;src_end-s) &gt;= len &amp;&amp;
283        memcmp(ms-&gt;capture[l].init, s, len) == 0)
284      return s+len;
285    else return NULL;
286  }
287  static const char *match (MatchState *ms, const char *s, const char *p) {
288    init: &amp;bsol;* using goto&#x27;s to optimize tail recursion */
289    switch (*p) {
290      case &#x27;(&#x27;: {  &amp;bsol;* start capture */
291        if (*(p+1) == &#x27;)&#x27;)  &amp;bsol;* position capture? */
292          return start_capture(ms, s, p+2, CAP_POSITION);
293        else
294          return start_capture(ms, s, p+1, CAP_UNFINISHED);
295      }
296      case &#x27;)&#x27;: {  &amp;bsol;* end capture */
297        return end_capture(ms, s, p+1);
298      }
299      case L_ESC: {
300        switch (*(p+1)) {
301          case &#x27;b&#x27;: {  &amp;bsol;* balanced string? */
302            s = matchbalance(ms, s, p+2);
303            if (s == NULL) return NULL;
304            p+=4; goto init;  &amp;bsol;* else return match(ms, s, p+4); */
305          }
306          case &#x27;f&#x27;: {  &amp;bsol;* frontier? */
307            const char *ep; char previous;
308            p += 2;
309            if (*p != &#x27;[&#x27;)
310              luaL_error(ms-&gt;L, &quot;missing &quot; LUA_QL(&quot;[&quot;) &quot; after &quot;
311                                 LUA_QL(&quot;%%f&quot;) &quot; in pattern&quot;);
312            ep = classend(ms, p);  &amp;bsol;* points to what is next */
313            previous = (s == ms-&gt;src_init) ? &#x27;\0&#x27; : *(s-1);
314            if (matchbracketclass(uchar(previous), p, ep-1) ||
315               !matchbracketclass(uchar(*s), p, ep-1)) return NULL;
316            p=ep; goto init;  &amp;bsol;* else return match(ms, s, ep); */
317          }
318          default: {
319            if (isdigit(uchar(*(p+1)))) {  &amp;bsol;* capture results (%0-%9)? */
320              s = match_capture(ms, s, uchar(*(p+1)));
321              if (s == NULL) return NULL;
322              p+=2; goto init;  &amp;bsol;* else return match(ms, s, p+2) */
323            }
324            goto dflt;  &amp;bsol;* case default */
325          }
326        }
327      }
328      case &#x27;\0&#x27;: {  &amp;bsol;* end of pattern */
329        return s;  &amp;bsol;* match succeeded */
330      }
331      case &#x27;$&#x27;: {
332        if (*(p+1) == &#x27;\0&#x27;)  &amp;bsol;* is the `$&#x27; the last char in pattern? */
333          return (s == ms-&gt;src_end) ? s : NULL;  &amp;bsol;* check end of string */
334        else goto dflt;
335      }
336      default: dflt: {  &amp;bsol;* it is a pattern item */
337        const char *ep = classend(ms, p);  &amp;bsol;* points to what is next */
338        int m = s&lt;ms-&gt;src_end &amp;&amp; singlematch(uchar(*s), p, ep);
339        switch (*ep) {
340          case &#x27;?&#x27;: {  &amp;bsol;* optional */
341            const char *res;
342            if (m &amp;&amp; ((res=match(ms, s+1, ep+1)) != NULL))
343              return res;
344            p=ep+1; goto init;  &amp;bsol;* else return match(ms, s, ep+1); */
345          }
346          case &#x27;*&#x27;: {  &amp;bsol;* 0 or more repetitions */
347            return max_expand(ms, s, p, ep);
348          }
349          case &#x27;+&#x27;: {  &amp;bsol;* 1 or more repetitions */
350            return (m ? max_expand(ms, s+1, p, ep) : NULL);
351          }
352          case &#x27;-&#x27;: {  &amp;bsol;* 0 or more repetitions (minimum) */
353            return min_expand(ms, s, p, ep);
354          }
355          default: {
356            if (!m) return NULL;
357            s++; p=ep; goto init;  &amp;bsol;* else return match(ms, s+1, ep); */
358          }
359        }
360      }
361    }
362  }
363  static const char *lmemfind (const char *s1, size_t l1,
364                                 const char *s2, size_t l2) {
365    if (l2 == 0) return s1;  &amp;bsol;* empty strings are everywhere */
366    else if (l2 &gt; l1) return NULL;  &amp;bsol;* avoids a negative `l1&#x27; */
367    else {
368      const char *init;  &amp;bsol;* to search for a `*s2&#x27; inside `s1&#x27; */
369      l2--;  &amp;bsol;* 1st char will be checked by `memchr&#x27; */
370      l1 = l1-l2;  &amp;bsol;* `s2&#x27; cannot be found after that */
371      while (l1 &gt; 0 &amp;&amp; (init = (const char *)memchr(s1, *s2, l1)) != NULL) {
372        init++;   &amp;bsol;* 1st char is already checked */
373        if (memcmp(init, s2+1, l2) == 0)
374          return init-1;
375        else {  &amp;bsol;* correct `l1&#x27; and `s1&#x27; to try again */
376          l1 -= init-s1;
377          s1 = init;
378        }
379      }
380      return NULL;  &amp;bsol;* not found */
381    }
382  }
383  static void push_onecapture (MatchState *ms, int i, const char *s,
384                                                      const char *e) {
385    if (i &gt;= ms-&gt;level) {
386      if (i == 0)  &amp;bsol;* ms-&gt;level == 0, too */
387        lua_pushlstring(ms-&gt;L, s, e - s);  &amp;bsol;* add whole match */
388      else
389        luaL_error(ms-&gt;L, &quot;invalid capture index&quot;);
390    }
391    else {
392      ptrdiff_t l = ms-&gt;capture[i].len;
393      if (l == CAP_UNFINISHED) luaL_error(ms-&gt;L, &quot;unfinished capture&quot;);
394      if (l == CAP_POSITION)
395        lua_pushinteger(ms-&gt;L, ms-&gt;capture[i].init - ms-&gt;src_init + 1);
396      else
397        lua_pushlstring(ms-&gt;L, ms-&gt;capture[i].init, l);
398    }
399  }
400  static int push_captures (MatchState *ms, const char *s, const char *e) {
401    int i;
402    int nlevels = (ms-&gt;level == 0 &amp;&amp; s) ? 1 : ms-&gt;level;
403    luaL_checkstack(ms-&gt;L, nlevels, &quot;too many captures&quot;);
404    for (i = 0; i &lt; nlevels; i++)
405      push_onecapture(ms, i, s, e);
406    return nlevels;  &amp;bsol;* number of strings pushed */
407  }
408  static int str_find_aux (lua_State *L, int find) {
409    size_t l1, l2;
410    const char *s = luaL_checklstring(L, 1, &amp;l1);
411    const char *p = luaL_checklstring(L, 2, &amp;l2);
412    ptrdiff_t init = posrelat(luaL_optinteger(L, 3, 1), l1) - 1;
413    if (init &lt; 0) init = 0;
414    else if ((size_t)(init) &gt; l1) init = (ptrdiff_t)l1;
415    if (find &amp;&amp; (lua_toboolean(L, 4) ||  &amp;bsol;* explicit request? */
416        strpbrk(p, SPECIALS) == NULL)) {  &amp;bsol;* or no special characters? */
417      const char *s2 = lmemfind(s+init, l1-init, p, l2);
418      if (s2) {
419        lua_pushinteger(L, s2-s+1);
420        lua_pushinteger(L, s2-s+l2);
421        return 2;
422      }
423    }
424    else {
425      MatchState ms;
426      int anchor = (*p == &#x27;^&#x27;) ? (p++, 1) : 0;
427      const char *s1=s+init;
428      ms.L = L;
429      ms.src_init = s;
430      ms.src_end = s+l1;
431      do {
432        const char *res;
433        ms.level = 0;
434        if ((res=match(&amp;ms, s1, p)) != NULL) {
435          if (find) {
436            lua_pushinteger(L, s1-s+1);  &amp;bsol;* start */
437            lua_pushinteger(L, res-s);   &amp;bsol;* end */
438            return push_captures(&amp;ms, NULL, 0) + 2;
439          }
440          else
441            return push_captures(&amp;ms, s1, res);
442        }
443      } while (s1++ &lt; ms.src_end &amp;&amp; !anchor);
444    }
445    lua_pushnil(L);  &amp;bsol;* not found */
446    return 1;
447  }
448  static int str_find (lua_State *L) {
449    return str_find_aux(L, 1);
450  }
451  static int str_match (lua_State *L) {
452    return str_find_aux(L, 0);
453  }
454  static int gmatch_aux (lua_State *L) {
455    MatchState ms;
456    size_t ls;
457    const char *s = lua_tolstring(L, lua_upvalueindex(1), &amp;ls);
458    const char *p = lua_tostring(L, lua_upvalueindex(2));
459    const char *src;
460    ms.L = L;
461    ms.src_init = s;
462    ms.src_end = s+ls;
463    for (src = s + (size_t)lua_tointeger(L, lua_upvalueindex(3));
464         src &lt;= ms.src_end;
465         src++) {
466      const char *e;
467      ms.level = 0;
468      if ((e = match(&amp;ms, src, p)) != NULL) {
469        lua_Integer newstart = e-s;
470        if (e == src) newstart++;  &amp;bsol;* empty match? go at least one position */
471        lua_pushinteger(L, newstart);
472        lua_replace(L, lua_upvalueindex(3));
473        return push_captures(&amp;ms, src, e);
474      }
475    }
476    return 0;  &amp;bsol;* not found */
477  }
478  static int gmatch (lua_State *L) {
479    luaL_checkstring(L, 1);
480    luaL_checkstring(L, 2);
481    lua_settop(L, 2);
482    lua_pushinteger(L, 0);
483    lua_pushcclosure(L, gmatch_aux, 3);
484    return 1;
485  }
486  static int gfind_nodef (lua_State *L) {
487    return luaL_error(L, LUA_QL(&quot;string.gfind&quot;) &quot; was renamed to &quot;
488                         LUA_QL(&quot;string.gmatch&quot;));
489  }
490  static void add_s (MatchState *ms, luaL_Buffer *b, const char *s,
491                                                     const char *e) {
492    size_t l, i;
493    const char *news = lua_tolstring(ms-&gt;L, 3, &amp;l);
494    for (i = 0; i &lt; l; i++) {
495      if (news[i] != L_ESC)
496        luaL_addchar(b, news[i]);
497      else {
498        i++;  &amp;bsol;* skip ESC */
499        if (!isdigit(uchar(news[i])))
500          luaL_addchar(b, news[i]);
501        else if (news[i] == &#x27;0&#x27;)
502            luaL_addlstring(b, s, e - s);
503        else {
504          push_onecapture(ms, news[i] - &#x27;1&#x27;, s, e);
505          luaL_addvalue(b);  &amp;bsol;* add capture to accumulated result */
506        }
507      }
508    }
509  }
510  static void add_value (MatchState *ms, luaL_Buffer *b, const char *s,
511                                                         const char *e) {
512    lua_State *L = ms-&gt;L;
513    switch (lua_type(L, 3)) {
514      case LUA_TNUMBER:
515      case LUA_TSTRING: {
516        add_s(ms, b, s, e);
517        return;
518      }
519      case LUA_TFUNCTION: {
520        int n;
521        lua_pushvalue(L, 3);
522        n = push_captures(ms, s, e);
523        lua_call(L, n, 1);
524        break;
525      }
526      case LUA_TTABLE: {
527        push_onecapture(ms, 0, s, e);
528        lua_gettable(L, 3);
529        break;
530      }
531    }
532    if (!lua_toboolean(L, -1)) {  &amp;bsol;* nil or false? */
533      lua_pop(L, 1);
534      lua_pushlstring(L, s, e - s);  &amp;bsol;* keep original text */
535    }
536    else if (!lua_isstring(L, -1))
537      luaL_error(L, &quot;invalid replacement value (a %s)&quot;, luaL_typename(L, -1)); 
538    luaL_addvalue(b);  &amp;bsol;* add result to accumulator */
539  }
540  static int str_gsub (lua_State *L) {
541    size_t srcl;
542    const char *src = luaL_checklstring(L, 1, &amp;srcl);
543    const char *p = luaL_checkstring(L, 2);
544    int  tr = lua_type(L, 3);
545    int max_s = luaL_optint(L, 4, srcl+1);
<span onclick='openModal()' class='match'>546    int anchor = (*p == &#x27;^&#x27;) ? (p++, 1) : 0;
547    int n = 0;
</span>548    MatchState ms;
549    luaL_Buffer b;
550    luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
551                     tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
552                        &quot;string/function/table expected&quot;);
553    luaL_buffinit(L, &amp;b);
554    ms.L = L;
555    ms.src_init = src;
556    ms.src_end = src+srcl;
557    while (n &lt; max_s) {
558      const char *e;
559      ms.level = 0;
560      e = match(&amp;ms, src, p);
561      if (e) {
562        n++;
563        add_value(&amp;ms, &amp;b, src, e);
564      }
565      if (e &amp;&amp; e&gt;src) &amp;bsol;* non empty match? */
566        src = e;  &amp;bsol;* skip it */
567      else if (src &lt; ms.src_end)
568        luaL_addchar(&amp;b, *src++);
569      else break;
570      if (anchor) break;
571    }
572    luaL_addlstring(&amp;b, src, ms.src_end-src);
573    luaL_pushresult(&amp;b);
574    lua_pushinteger(L, n);  &amp;bsol;* number of substitutions */
575    return 2;
576  }
577  #define MAX_ITEM	512
578  #define FLAGS	&quot;-+ #0&quot;
579  #define MAX_FORMAT	(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
580  static void addquoted (lua_State *L, luaL_Buffer *b, int arg) {
581    size_t l;
582    const char *s = luaL_checklstring(L, arg, &amp;l);
583    luaL_addchar(b, &#x27;&quot;&#x27;);
584    while (l--) {
585      switch (*s) {
586        case &#x27;&quot;&#x27;: case &#x27;\\&#x27;: case &#x27;\n&#x27;: {
587          luaL_addchar(b, &#x27;\\&#x27;);
588          luaL_addchar(b, *s);
589          break;
590        }
591        case &#x27;\r&#x27;: {
592          luaL_addlstring(b, &quot;\\r&quot;, 2);
593          break;
594        }
595        case &#x27;\0&#x27;: {
596          luaL_addlstring(b, &quot;\\000&quot;, 4);
597          break;
598        }
599        default: {
600          luaL_addchar(b, *s);
601          break;
602        }
603      }
604      s++;
605    }
606    luaL_addchar(b, &#x27;&quot;&#x27;);
607  }
608  static const char *scanformat (lua_State *L, const char *strfrmt, char *form) {
609    const char *p = strfrmt;
610    while (*p != &#x27;\0&#x27; &amp;&amp; strchr(FLAGS, *p) != NULL) p++;  &amp;bsol;* skip flags */
611    if ((size_t)(p - strfrmt) &gt;= sizeof(FLAGS))
612      luaL_error(L, &quot;invalid format (repeated flags)&quot;);
613    if (isdigit(uchar(*p))) p++;  &amp;bsol;* skip width */
614    if (isdigit(uchar(*p))) p++;  &amp;bsol;* (2 digits at most) */
615    if (*p == &#x27;.&#x27;) {
616      p++;
617      if (isdigit(uchar(*p))) p++;  &amp;bsol;* skip precision */
618      if (isdigit(uchar(*p))) p++;  &amp;bsol;* (2 digits at most) */
619    }
620    if (isdigit(uchar(*p)))
621      luaL_error(L, &quot;invalid format (width or precision too long)&quot;);
622    *(form++) = &#x27;%&#x27;;
623    strncpy(form, strfrmt, p - strfrmt + 1);
624    form += p - strfrmt + 1;
625    *form = &#x27;\0&#x27;;
626    return p;
627  }
628  static void addintlen (char *form) {
629    size_t l = strlen(form);
630    char spec = form[l - 1];
631    strcpy(form + l - 1, LUA_INTFRMLEN);
632    form[l + sizeof(LUA_INTFRMLEN) - 2] = spec;
633    form[l + sizeof(LUA_INTFRMLEN) - 1] = &#x27;\0&#x27;;
634  }
635  static int str_format (lua_State *L) {
636    int top = lua_gettop(L);
637    int arg = 1;
638    size_t sfl;
639    const char *strfrmt = luaL_checklstring(L, arg, &amp;sfl);
640    const char *strfrmt_end = strfrmt+sfl;
641    luaL_Buffer b;
642    luaL_buffinit(L, &amp;b);
643    while (strfrmt &lt; strfrmt_end) {
644      if (*strfrmt != L_ESC)
645        luaL_addchar(&amp;b, *strfrmt++);
646      else if (*++strfrmt == L_ESC)
647        luaL_addchar(&amp;b, *strfrmt++);  &amp;bsol;* %% */
648      else { &amp;bsol;* format item */
649        char form[MAX_FORMAT];  &amp;bsol;* to store the format (`%...&#x27;) */
650        char buff[MAX_ITEM];  &amp;bsol;* to store the formatted item */
651        if (++arg &gt; top)
652          luaL_argerror(L, arg, &quot;no value&quot;);
653        strfrmt = scanformat(L, strfrmt, form);
654        switch (*strfrmt++) {
655          case &#x27;c&#x27;: {
656            sprintf(buff, form, (int)luaL_checknumber(L, arg));
657            break;
658          }
659          case &#x27;d&#x27;:  case &#x27;i&#x27;: {
660            addintlen(form);
661            sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
662            break;
663          }
664          case &#x27;o&#x27;:  case &#x27;u&#x27;:  case &#x27;x&#x27;:  case &#x27;X&#x27;: {
665            addintlen(form);
666            sprintf(buff, form, (unsigned LUA_INTFRM_T)luaL_checknumber(L, arg));
667            break;
668          }
669          case &#x27;e&#x27;:  case &#x27;E&#x27;: case &#x27;f&#x27;:
670          case &#x27;g&#x27;: case &#x27;G&#x27;: {
671            sprintf(buff, form, (double)luaL_checknumber(L, arg));
672            break;
673          }
674          case &#x27;q&#x27;: {
675            addquoted(L, &amp;b, arg);
676            continue;  &amp;bsol;* skip the &#x27;addsize&#x27; at the end */
677          }
678          case &#x27;s&#x27;: {
679            size_t l;
680            const char *s = luaL_checklstring(L, arg, &amp;l);
681            if (!strchr(form, &#x27;.&#x27;) &amp;&amp; l &gt;= 100) {
682              lua_pushvalue(L, arg);
683              luaL_addvalue(&amp;b);
684              continue;  &amp;bsol;* skip the `addsize&#x27; at the end */
685            }
686            else {
687              sprintf(buff, form, s);
688              break;
689            }
690          }
691          default: {  &amp;bsol;* also treat cases `pnLlh&#x27; */
692            return luaL_error(L, &quot;invalid option &quot; LUA_QL(&quot;%%%c&quot;) &quot; to &quot;
693                                 LUA_QL(&quot;format&quot;), *(strfrmt - 1));
694          }
695        }
696        luaL_addlstring(&amp;b, buff, strlen(buff));
697      }
698    }
699    luaL_pushresult(&amp;b);
700    return 1;
701  }
702  static const luaL_Reg strlib[] = {
703    {&quot;byte&quot;, str_byte},
704    {&quot;char&quot;, str_char},
705    {&quot;dump&quot;, str_dump},
706    {&quot;find&quot;, str_find},
707    {&quot;format&quot;, str_format},
708    {&quot;gfind&quot;, gfind_nodef},
709    {&quot;gmatch&quot;, gmatch},
710    {&quot;gsub&quot;, str_gsub},
711    {&quot;len&quot;, str_len},
712    {&quot;lower&quot;, str_lower},
713    {&quot;match&quot;, str_match},
714    {&quot;rep&quot;, str_rep},
715    {&quot;reverse&quot;, str_reverse},
716    {&quot;sub&quot;, str_sub},
717    {&quot;upper&quot;, str_upper},
718    {NULL, NULL}
719  };
720  static void createmetatable (lua_State *L) {
721    lua_createtable(L, 0, 1);  &amp;bsol;* create metatable for strings */
722    lua_pushliteral(L, &quot;&quot;);  &amp;bsol;* dummy string */
723    lua_pushvalue(L, -2);
724    lua_setmetatable(L, -2);  &amp;bsol;* set string metatable */
725    lua_pop(L, 1);  &amp;bsol;* pop dummy string */
726    lua_pushvalue(L, -2);  &amp;bsol;* string library... */
727    lua_setfield(L, -2, &quot;__index&quot;);  &amp;bsol;* ...is the __index metamethod */
728    lua_pop(L, 1);  &amp;bsol;* pop metatable */
729  }
730  LUALIB_API int luaopen_string (lua_State *L) {
731    luaL_register(L, LUA_STRLIBNAME, strlib);
732  #if defined(LUA_COMPAT_GFIND)
733    lua_getfield(L, -1, &quot;gmatch&quot;);
734    lua_setfield(L, -2, &quot;gfind&quot;);
735  #endif
736    createmetatable(L);
737    return 1;
738  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstrlib.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstrlib.c</div>
                </div>
                <div class="column column_space"><pre><code>426      int anchor = (*p == &#x27;^&#x27;) ? (p++, 1) : 0;
427      const char *s1=s+init;
</pre></code></div>
                <div class="column column_space"><pre><code>546    int anchor = (*p == &#x27;^&#x27;) ? (p++, 1) : 0;
547    int n = 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    