
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 301, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-vrank-geq1.c</h3>
            <pre><code>1  #include "threads/threads.h"
2  typedef struct {
3       solver super;
4       int vecloop_dim;
5       const int *buddies;
6       size_t nbuddies;
7  } S;
8  typedef struct {
9       plan_dft super;
10       plan **cldrn;
11       INT its, ots;
12       int nthr;
13       const S *solver;
14  } P;
15  typedef struct {
16       INT its, ots;
17       R *ri, *ii, *ro, *io;
18       plan **cldrn;
19  } PD;
20  static void *spawn_apply(spawn_data *d)
21  {
22       PD *ego = (PD *) d->data;
23       INT its = ego->its;
24       INT ots = ego->ots;
25       int thr_num = d->thr_num;
26       plan_dft *cld = (plan_dft *) ego->cldrn[thr_num];
27       cld->apply((plan *) cld,
28  		ego->ri + thr_num * its, ego->ii + thr_num * its,
29  		ego->ro + thr_num * ots, ego->io + thr_num * ots);
30       return 0;
31  }
32  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
33  {
34       const P *ego = (const P *) ego_;
35       PD d;
36       d.its = ego->its;
37       d.ots = ego->ots;
38       d.cldrn = ego->cldrn;
39       d.ri = ri; d.ii = ii; d.ro = ro; d.io = io;
40       X(spawn_loop)(ego->nthr, ego->nthr, spawn_apply, (void*) &d);
41  }
42  static void awake(plan *ego_, enum wakefulness wakefulness)
43  {
44       P *ego = (P *) ego_;
45       int i;
46       for (i = 0; i < ego->nthr; ++i)
47  	  X(plan_awake)(ego->cldrn[i], wakefulness);
48  }
49  static void destroy(plan *ego_)
50  {
51       P *ego = (P *) ego_;
52       int i;
53       for (i = 0; i < ego->nthr; ++i)
54  	  X(plan_destroy_internal)(ego->cldrn[i]);
55       X(ifree)(ego->cldrn);
56  }
57  static void print(const plan *ego_, printer *p)
58  {
59       const P *ego = (const P *) ego_;
60       const S *s = ego->solver;
61       int i;
62       p->print(p, "(dft-thr-vrank>=1-x%d/%d", ego->nthr, s->vecloop_dim);
63       for (i = 0; i < ego->nthr; ++i)
64  	  if (i == 0 || (ego->cldrn[i] != ego->cldrn[i-1] &&
65  			 (i <= 1 || ego->cldrn[i] != ego->cldrn[i-2])))
66  	       p->print(p, "%(%p%)", ego->cldrn[i]);
67       p->putchr(p, ')');
68  }
69  static int pickdim(const S *ego, const tensor *vecsz, int oop, int *dp)
70  {
71       return X(pickdim)(ego->vecloop_dim, ego->buddies, ego->nbuddies,
72                         vecsz, oop, dp);
73  }
74  static int applicable0(const solver *ego_, const problem *p_,
75  		       const planner *plnr, int *dp)
76  {
77       const S *ego = (const S *) ego_;
78       const problem_dft *p = (const problem_dft *) p_;
79       return (1
80  	     && plnr->nthr > 1
81  	     && FINITE_RNK(p->vecsz->rnk)
82  	     && p->vecsz->rnk > 0
83  	     && pickdim(ego, p->vecsz, p->ri != p->ro, dp)
84  	  );
85  }
86  static int applicable(const solver *ego_, const problem *p_,
87  		      const planner *plnr, int *dp)
88  {
89       const S *ego = (const S *)ego_;
90       if (!applicable0(ego_, p_, plnr, dp)) return 0;
91       if (NO_VRANK_SPLITSP(plnr) && (ego->vecloop_dim != ego->buddies[0]))
92  	  return 0;
93       return 1;
94  }
95  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
96  {
97       const S *ego = (const S *) ego_;
98       const problem_dft *p;
99       P *pln;
100       problem *cldp;
101       int vdim;
102       iodim *d;
103       plan **cldrn = (plan **) 0;
104       int i, nthr;
105       INT its, ots, block_size;
106       tensor *vecsz = 0;
107       static const plan_adt padt = {
108  	  X(dft_solve), awake, print, destroy
109       };
110       if (!applicable(ego_, p_, plnr, &vdim))
111            return (plan *) 0;
112       p = (const problem_dft *) p_;
113       d = p->vecsz->dims + vdim;
114       block_size = (d->n + plnr->nthr - 1) / plnr->nthr;
115       nthr = (int)((d->n + block_size - 1) / block_size);
116       plnr->nthr = (plnr->nthr + nthr - 1) / nthr;
117       its = d->is * block_size;
118       ots = d->os * block_size;
119       cldrn = (plan **)MALLOC(sizeof(plan *) * nthr, PLANS);
120       for (i = 0; i < nthr; ++i) cldrn[i] = (plan *) 0;
121       vecsz = X(tensor_copy)(p->vecsz);
122       for (i = 0; i < nthr; ++i) {
123  	  vecsz->dims[vdim].n =
124  	       (i == nthr - 1) ? (d->n - i*block_size) : block_size;
125  	  cldp = X(mkproblem_dft)(p->sz, vecsz,
126  				  p->ri + i*its, p->ii + i*its, 
127  				  p->ro + i*ots, p->io + i*ots);
<span onclick='openModal()' class='match'>128  	  cldrn[i] = X(mkplan_d)(plnr, cldp);
129  	  if (!cldrn[i]) goto nada;
130       }
131       X(tensor_destroy)(vecsz);
132       pln = MKPLAN_DFT(P, &padt, apply);
133       pln->cldrn = cldrn;
134       pln->its = its;
135       pln->ots = ots;
136       pln->nthr = nthr;
137       pln->solver = ego;
138       X(ops_zero)(&pln->super.super.ops);
139       pln->super.super.pcost = 0;
140       for (i = 0; i < nthr; ++i) {
141  	  X(ops_add2)(&cldrn[i]->ops, &pln->super.super.ops);
142  	  pln->super.super.pcost += cldrn[i]->pcost;
143       }
144       return &(pln->super.super);
145   nada:
146       if (cldrn) {
147  	  for (i = 0; i < nthr; ++i)
148  	       X(plan_destroy_internal)(cldrn[i]);
149  	  X(ifree)(cldrn);
150       }
151       X(tensor_destroy)(vecsz);
152       return (plan *) 0;
153  }
154  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
155  {
156       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
157       S *slv = MKSOLVER(S, &sadt);
158       slv->vecloop_dim = vecloop_dim;
159       slv->buddies = buddies;
160       slv->nbuddies = nbuddies;
161       return &(slv->super);
162  }
163  void X(dft_thr_vrank_geq1_register)(planner *p)
164  {
165       static const int buddies[] = { 1, -1 };
</span>166       size_t i;
167       for (i = 0; i < NELEM(buddies); ++i)
168            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
169  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-vrank-geq1-rdft2.c</h3>
            <pre><code>1  #include "threads/threads.h"
2  typedef struct {
3       solver super;
4       int vecloop_dim;
5       const int *buddies;
6       size_t nbuddies;
7  } S;
8  typedef struct {
9       plan_rdft2 super;
10       plan **cldrn;
11       INT its, ots;
12       int nthr;
13       const S *solver;
14  } P;
15  typedef struct {
16       INT its, ots;
17       R *r0, *r1, *cr, *ci;
18       plan **cldrn;
19  } PD;
20  static void *spawn_apply(spawn_data *d)
21  {
22       PD *ego = (PD *) d->data;
23       INT its = ego->its;
24       INT ots = ego->ots;
25       int thr_num = d->thr_num;
26       plan_rdft2 *cld = (plan_rdft2 *) ego->cldrn[d->thr_num];
27       cld->apply((plan *) cld,
28  		ego->r0 + thr_num * its, ego->r1 + thr_num * its,
29  		ego->cr + thr_num * ots, ego->ci + thr_num * ots);
30       return 0;
31  }
32  static void apply(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
33  {
34       const P *ego = (const P *) ego_;
35       PD d;
36       d.its = ego->its;
37       d.ots = ego->ots;
38       d.cldrn = ego->cldrn;
39       d.r0 = r0; d.r1 = r1; d.cr = cr; d.ci = ci;
40       X(spawn_loop)(ego->nthr, ego->nthr, spawn_apply, (void*) &d);
41  }
42  static void awake(plan *ego_, enum wakefulness wakefulness)
43  {
44       P *ego = (P *) ego_;
45       int i;
46       for (i = 0; i < ego->nthr; ++i)
47  	  X(plan_awake)(ego->cldrn[i], wakefulness);
48  }
49  static void destroy(plan *ego_)
50  {
51       P *ego = (P *) ego_;
52       int i;
53       for (i = 0; i < ego->nthr; ++i)
54  	  X(plan_destroy_internal)(ego->cldrn[i]);
55       X(ifree)(ego->cldrn);
56  }
57  static void print(const plan *ego_, printer *p)
58  {
59       const P *ego = (const P *) ego_;
60       const S *s = ego->solver;
61       int i;
62       p->print(p, "(rdft2-thr-vrank>=1-x%d/%d)", ego->nthr, s->vecloop_dim);
63       for (i = 0; i < ego->nthr; ++i)
64  	  if (i == 0 || (ego->cldrn[i] != ego->cldrn[i-1] &&
65  			 (i <= 1 || ego->cldrn[i] != ego->cldrn[i-2])))
66  	       p->print(p, "%(%p%)", ego->cldrn[i]);
67       p->putchr(p, ')');
68  }
69  static int pickdim(const S *ego, const tensor *vecsz, int oop, int *dp)
70  {
71       return X(pickdim)(ego->vecloop_dim, ego->buddies, ego->nbuddies,
72  		       vecsz, oop, dp);
73  }
74  static int applicable0(const solver *ego_, const problem *p_,
75  		       const planner *plnr, int *dp)
76  {
77       const S *ego = (const S *) ego_;
78       const problem_rdft2 *p = (const problem_rdft2 *) p_;
79       if (FINITE_RNK(p->vecsz->rnk)
80  	 && p->vecsz->rnk > 0
81  	 && plnr->nthr > 1
82  	 && pickdim(ego, p->vecsz, p->r0 != p->cr, dp)) {
83  	  if (p->r0 != p->cr)
84  	       return 1;  &bsol;* can always operate out-of-place */
85  	  return(X(rdft2_inplace_strides)(p, *dp));
86       }
87       return 0;
88  }
89  static int applicable(const solver *ego_, const problem *p_,
90  		      const planner *plnr, int *dp)
91  {
92       const S *ego = (const S *)ego_;
93       if (!applicable0(ego_, p_, plnr, dp)) return 0;
94       if (NO_VRANK_SPLITSP(plnr) && (ego->vecloop_dim != ego->buddies[0]))
95  	  return 0;
96       return 1;
97  }
98  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
99  {
100       const S *ego = (const S *) ego_;
101       const problem_rdft2 *p;
102       P *pln;
103       problem *cldp;
104       int vdim;
105       iodim *d;
106       plan **cldrn = (plan **) 0;
107       int i, nthr;
108       INT its, ots, block_size;
109       tensor *vecsz;
110       static const plan_adt padt = {
111  	  X(rdft2_solve), awake, print, destroy
112       };
113       if (!applicable(ego_, p_, plnr, &vdim))
114            return (plan *) 0;
115       p = (const problem_rdft2 *) p_;
116       d = p->vecsz->dims + vdim;
117       block_size = (d->n + plnr->nthr - 1) / plnr->nthr;
118       nthr = (int)((d->n + block_size - 1) / block_size);
119       plnr->nthr = (plnr->nthr + nthr - 1) / nthr;
120       X(rdft2_strides)(p->kind, d, &its, &ots);
121       its *= block_size; ots *= block_size;
122       cldrn = (plan **)MALLOC(sizeof(plan *) * nthr, PLANS);
123       for (i = 0; i < nthr; ++i) cldrn[i] = (plan *) 0;
124       vecsz = X(tensor_copy)(p->vecsz);
125       for (i = 0; i < nthr; ++i) {
126  	  vecsz->dims[vdim].n =
127  	       (i == nthr - 1) ? (d->n - i*block_size) : block_size;
128  	  cldp = X(mkproblem_rdft2)(p->sz, vecsz,
129  				    p->r0 + i*its, p->r1 + i*its,
130  				    p->cr + i*ots, p->ci + i*ots, 
131  				    p->kind);
<span onclick='openModal()' class='match'>132  	  cldrn[i] = X(mkplan_d)(plnr, cldp);
133  	  if (!cldrn[i]) goto nada;
134       }
135       X(tensor_destroy)(vecsz);
136       pln = MKPLAN_RDFT2(P, &padt, apply);
137       pln->cldrn = cldrn;
138       pln->its = its;
139       pln->ots = ots;
140       pln->nthr = nthr;
141       pln->solver = ego;
142       X(ops_zero)(&pln->super.super.ops);
143       pln->super.super.pcost = 0;
144       for (i = 0; i < nthr; ++i) {
145  	  X(ops_add2)(&cldrn[i]->ops, &pln->super.super.ops);
146  	  pln->super.super.pcost += cldrn[i]->pcost;
147       }
148       return &(pln->super.super);
149   nada:
150       if (cldrn) {
151  	  for (i = 0; i < nthr; ++i)
152  	       X(plan_destroy_internal)(cldrn[i]);
153  	  X(ifree)(cldrn);
154       }
155       X(tensor_destroy)(vecsz);
156       return (plan *) 0;
157  }
158  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
159  {
160       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
161       S *slv = MKSOLVER(S, &sadt);
162       slv->vecloop_dim = vecloop_dim;
163       slv->buddies = buddies;
164       slv->nbuddies = nbuddies;
165       return &(slv->super);
166  }
167  void X(rdft2_thr_vrank_geq1_register)(planner *p)
168  {
169       static const int buddies[] = { 1, -1 };
</span>170       size_t i;
171       for (i = 0; i < NELEM(buddies); ++i)
172            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
173  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dft-vrank-geq1.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-vrank-geq1-rdft2.c</div>
                </div>
                <div class="column column_space"><pre><code>128  	  cldrn[i] = X(mkplan_d)(plnr, cldp);
129  	  if (!cldrn[i]) goto nada;
130       }
131       X(tensor_destroy)(vecsz);
132       pln = MKPLAN_DFT(P, &padt, apply);
133       pln->cldrn = cldrn;
134       pln->its = its;
135       pln->ots = ots;
136       pln->nthr = nthr;
137       pln->solver = ego;
138       X(ops_zero)(&pln->super.super.ops);
139       pln->super.super.pcost = 0;
140       for (i = 0; i < nthr; ++i) {
141  	  X(ops_add2)(&cldrn[i]->ops, &pln->super.super.ops);
142  	  pln->super.super.pcost += cldrn[i]->pcost;
143       }
144       return &(pln->super.super);
145   nada:
146       if (cldrn) {
147  	  for (i = 0; i < nthr; ++i)
148  	       X(plan_destroy_internal)(cldrn[i]);
149  	  X(ifree)(cldrn);
150       }
151       X(tensor_destroy)(vecsz);
152       return (plan *) 0;
153  }
154  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
155  {
156       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
157       S *slv = MKSOLVER(S, &sadt);
158       slv->vecloop_dim = vecloop_dim;
159       slv->buddies = buddies;
160       slv->nbuddies = nbuddies;
161       return &(slv->super);
162  }
163  void X(dft_thr_vrank_geq1_register)(planner *p)
164  {
165       static const int buddies[] = { 1, -1 };
</pre></code></div>
                <div class="column column_space"><pre><code>132  	  cldrn[i] = X(mkplan_d)(plnr, cldp);
133  	  if (!cldrn[i]) goto nada;
134       }
135       X(tensor_destroy)(vecsz);
136       pln = MKPLAN_RDFT2(P, &padt, apply);
137       pln->cldrn = cldrn;
138       pln->its = its;
139       pln->ots = ots;
140       pln->nthr = nthr;
141       pln->solver = ego;
142       X(ops_zero)(&pln->super.super.ops);
143       pln->super.super.pcost = 0;
144       for (i = 0; i < nthr; ++i) {
145  	  X(ops_add2)(&cldrn[i]->ops, &pln->super.super.ops);
146  	  pln->super.super.pcost += cldrn[i]->pcost;
147       }
148       return &(pln->super.super);
149   nada:
150       if (cldrn) {
151  	  for (i = 0; i < nthr; ++i)
152  	       X(plan_destroy_internal)(cldrn[i]);
153  	  X(ifree)(cldrn);
154       }
155       X(tensor_destroy)(vecsz);
156       return (plan *) 0;
157  }
158  static solver *mksolver(int vecloop_dim, const int *buddies, size_t nbuddies)
159  {
160       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
161       S *slv = MKSOLVER(S, &sadt);
162       slv->vecloop_dim = vecloop_dim;
163       slv->buddies = buddies;
164       slv->nbuddies = nbuddies;
165       return &(slv->super);
166  }
167  void X(rdft2_thr_vrank_geq1_register)(planner *p)
168  {
169       static const int buddies[] = { 1, -1 };
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    