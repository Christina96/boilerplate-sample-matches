<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imklog.c &amp; ommail.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imklog.c &amp; ommail.c
      </h3>
<h1 align="center">
        11.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imklog.c (16.071428%)<th>ommail.c (8.92562%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(100-113)<td><a href="#" name="0">(116-129)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(366-377)<td><a href="#" name="1">(713-726)</a><td align="center"><font color="#ad0000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(389-397)<td><a href="#" name="2">(749-756)</a><td align="center"><font color="#7a0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imklog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include "dirty.h"
#include "cfsysline.h"
#include "parserif.h"
#include "obj.h"
#include "msg.h"
#include "module-template.h"
#include "datetime.h"
#include "imklog.h"
#include "net.h"
#include "glbl.h"
#include "prop.h"
#include "errmsg.h"
#include "unicode-helper.h"
#include "ruleset.h"
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imklog")
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(datetime)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(net)
typedef struct configSettings_s {
	int bPermitNonKernel; 	int bParseKernelStamp; 	int bKeepKernelStamp; 	int iFacilIntMsg; 	uchar *pszPath;
	int console_log_level; 	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
} configSettings_t;
static configSettings_t cs;
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;static int bLegacyCnfModGlobalsPermitted;
<a name="0"></a>static struct cnfparamdescr modpdescr[] = {
	{ "ruleset", eCmdHdlrString, 0 },
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "logpath", eCmdHdlrGetWord, 0 },
	{ "permitnonkernelfacility", eCmdHdlrBinary, 0 },
	{ "consoleloglevel", eCmdHdlrInt, 0 },
	{ "parsekerneltimestamp", eCmdHdlrBinary, 0 },
	{ "keepkerneltimestamp", eCmdHdlrBinary, 0 },
	{ "internalmsgfacility", eCmdHdlrFacility, 0 },
	{ "ratelimitinterval", eCmdHdlrInt, 0 },
	{ "ratelimitburst", eCmdHdlrInt, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};</b></font>
static prop_t *pInputName = NULL;
static prop_t *pLocalHostIP = NULL;
static inline void std_mod_checkRuleset_genErrMsg(const modConfData_t *const modConf);
static inline rsRetVal
std_mod_checkRuleset(modConfData_t *const modConf)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;
	modConf-&gt;pBindRuleset = NULL;	
	if(modConf-&gt;pszBindRuleset == NULL)
		FINALIZE;
	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
	if(localRet == RS_RET_NOT_FOUND) {
		std_mod_checkRuleset_genErrMsg(modConf);
	}
	CHKiRet(localRet);
	modConf-&gt;pBindRuleset = pRuleset;
finalize_it:
	RETiRet;
}
static inline void
std_mod_checkRuleset_genErrMsg(const modConfData_t *const modConf)
{
	LogError(0, NO_ERRCODE, "imklog: ruleset '%s' not found - "
			"using default ruleset instead", modConf-&gt;pszBindRuleset);
}
static void
initConfigSettings(void)
{
	cs.bPermitNonKernel = 0;
	cs.bParseKernelStamp = 0;
	cs.bKeepKernelStamp = 0;
	cs.console_log_level = -1;
	cs.pszPath = NULL;
	cs.iFacilIntMsg = klogFacilIntMsg();
}
static rsRetVal
enqMsg(uchar *const __restrict__ msg,
	uchar* pszTag,
	const syslog_pri_t pri,
	struct timeval *tp,
	ratelimit_t *ratelimiter)
{
	struct syslogTime st;
	smsg_t *pMsg;
	DEFiRet;
	assert(msg != NULL);
	assert(pszTag != NULL);
	if(tp == NULL) {
		CHKiRet(msgConstruct(&amp;pMsg));
	} else {
		datetime.timeval2syslogTime(tp, &amp;st, TIME_IN_LOCALTIME);
		CHKiRet(msgConstructWithTime(&amp;pMsg, &amp;st, tp-&gt;tv_sec));
	}
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsgWOSize(pMsg, (char*)msg);
	MsgSetRuleset(pMsg, runModConf-&gt;pBindRuleset);
	MsgSetMSGoffs(pMsg, 0);		MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	MsgSetRcvFromIP(pMsg, pLocalHostIP);
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetTAG(pMsg, pszTag, ustrlen(pszTag));
	msgSetPRI(pMsg, pri);
	ratelimitAddMsg(ratelimiter, NULL, pMsg);
finalize_it:
	RETiRet;
}
static rsRetVal
parsePRI(uchar **ppSz, syslog_pri_t *piPri)
{
	DEFiRet;
	syslog_pri_t i;
	uchar *pSz;
	assert(ppSz != NULL);
	pSz = *ppSz;
	assert(pSz != NULL);
	assert(piPri != NULL);
	if(*pSz != '&lt;' || !isdigit(*(pSz+1)))
		ABORT_FINALIZE(RS_RET_INVALID_PRI);
	++pSz;
	i = 0;
	while(isdigit(*pSz) &amp;&amp; i &lt;= LOG_MAXPRI) {
		i = i * 10 + *pSz++ - '0';
	}
	if(*pSz != '&gt;' || i &gt; LOG_MAXPRI)
		ABORT_FINALIZE(RS_RET_INVALID_PRI);
	*piPri = i;
	*ppSz = pSz + 1; 
finalize_it:
	RETiRet;
}
rsRetVal imklogLogIntMsg(syslog_pri_t priority, const char *fmt, ...)
{
	DEFiRet;
	va_list ap;
	uchar msgBuf[2048]; 
	va_start(ap, fmt);
	vsnprintf((char*)msgBuf, sizeof(msgBuf), fmt, ap);
	va_end(ap);
	logmsgInternal(NO_ERRCODE, priority, msgBuf, 0);
	RETiRet;
}
rsRetVal Syslog(modConfData_t *pModConf, syslog_pri_t priority, uchar *pMsg, struct timeval *tp)
{
	syslog_pri_t pri;
	int bPRISet = 0;
	rsRetVal localRet;
	DEFiRet;
	if(pMsg[3] == '&lt;' || (pMsg[3] == ' ' &amp;&amp; pMsg[4] == '&lt;')) { 		uchar *pMsgTmp = pMsg + ((pMsg[3] == '&lt;') ? 3 : 4);
		localRet = parsePRI(&amp;pMsgTmp, &amp;pri);
		if(localRet == RS_RET_OK &amp;&amp; pri &gt;= 8 &amp;&amp; pri &lt;= LOG_MAXPRI) {
			DBGPRINTF("imklog detected secondary PRI(%d) in klog msg\n", pri);
			pMsg = pMsgTmp;
			priority = pri;
			bPRISet = 1;
		}
	}
	if(!bPRISet) {
		localRet = parsePRI(&amp;pMsg, &amp;priority);
		if(localRet != RS_RET_INVALID_PRI &amp;&amp; localRet != RS_RET_OK)
			FINALIZE;
	}
	if(pModConf-&gt;bPermitNonKernel == 0 &amp;&amp; pri2fac(priority) != LOG_KERN)
		FINALIZE; 
	iRet = enqMsg((uchar*)pMsg, (uchar*) "kernel:", priority, tp, pModConf-&gt;ratelimiter);
finalize_it:
	RETiRet;
}
int klog_getMaxLine(void)
{
	return glbl.GetMaxLine(runConf);
}
BEGINrunInput
CODESTARTrunInput
	while(!pThrd-&gt;bShallStop) {
		CHKiRet(klogLogKMsg(runModConf));
	}
finalize_it:
ENDrunInput
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;pszPath = NULL;
	pModConf-&gt;bPermitNonKernel = 0;
	pModConf-&gt;bParseKernelStamp = 0;
	pModConf-&gt;bKeepKernelStamp = 0;
	pModConf-&gt;console_log_level = -1;
	pModConf-&gt;bKeepKernelStamp = 0;
	pModConf-&gt;iFacilIntMsg = klogFacilIntMsg();
	loadModConf-&gt;configSetViaV2Method = 0;
	pModConf-&gt;ratelimiter = NULL;
	pModConf-&gt;ratelimitBurst = 10000; 	pModConf-&gt;ratelimitInterval = 0; 	bLegacyCnfModGlobalsPermitted = 1;
	initConfigSettings();
ENDbeginCnfLoad
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
				"config parameters [module(...)]");
<a name="1"></a>		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if(Debug) {
		dbgprintf("module (global) param blk for imklog:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "logpath")) {
			loadModConf-&gt;pszPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "permitnonkernelfacility")) {
			loadModConf-&gt;bPermitNonKernel = (int) pvals[i].val.d.n;</b></font>
		} else if(!strcmp(modpblk.descr[i].name, "parsekerneltimestamp")) {
			loadModConf-&gt;bParseKernelStamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "keepkerneltimestamp")) {
			loadModConf-&gt;bKeepKernelStamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "consoleloglevel")) {
			loadModConf-&gt;console_log_level= (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "internalmsgfacility")) {
			loadModConf-&gt;iFacilIntMsg = (int) pvals[i].val.d.n;
<a name="2"></a>		} else if(!strcmp(modpblk.descr[i].name, "ratelimitburst")) {
			loadModConf-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "ratelimitinterval")) {
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			loadModConf-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "ruleset")) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			LogMsg(0, RS_RET_INTERNAL_ERROR, LOG_WARNING,
				"imklog: RSYSLOG BUG, non-handled param '%s' in "
				"beginCnfLoad\n", modpblk.descr[i].name);
		}
	}</b></font>
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		loadModConf-&gt;bPermitNonKernel = cs.bPermitNonKernel;
		loadModConf-&gt;bParseKernelStamp = cs.bParseKernelStamp;
		loadModConf-&gt;bKeepKernelStamp = cs.bKeepKernelStamp;
		loadModConf-&gt;iFacilIntMsg = cs.iFacilIntMsg;
		loadModConf-&gt;console_log_level = cs.console_log_level;
		if((cs.pszPath == NULL) || (cs.pszPath[0] == '\0')) {
			loadModConf-&gt;pszPath = NULL;
			if(cs.pszPath != NULL)
				free(cs.pszPath);
		} else {
			loadModConf-&gt;pszPath = cs.pszPath;
		}
		cs.pszPath = NULL;
	}
	loadModConf = NULL; ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
	std_mod_checkRuleset(pModConf);
ENDcheckCnf
BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
	iRet = klogWillRunPrePrivDrop(runModConf);
ENDactivateCnfPrePrivDrop
BEGINactivateCnf
CODESTARTactivateCnf
	CHKiRet(ratelimitNew(&amp;runModConf-&gt;ratelimiter, "imklog", NULL));
	ratelimitSetLinuxLike(runModConf-&gt;ratelimiter,
			      runModConf-&gt;ratelimitInterval,
			      runModConf-&gt;ratelimitBurst);
finalize_it:
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;pszBindRuleset);
ENDfreeCnf
BEGINwillRun
CODESTARTwillRun
	pLocalHostIP = glbl.GetLocalHostIP();
	iRet = klogWillRunPostPrivDrop(runModConf);
ENDwillRun
BEGINafterRun
CODESTARTafterRun
	ratelimitDestruct(runModConf-&gt;ratelimiter);
	iRet = klogAfterRun(runModConf);
ENDafterRun
BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(net, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	cs.bPermitNonKernel = 0;
	cs.bParseKernelStamp = 0;
	cs.bKeepKernelStamp = 0;
	if(cs.pszPath != NULL) {
		free(cs.pszPath);
		cs.pszPath = NULL;
	}
	cs.iFacilIntMsg = klogFacilIntMsg();
	return RS_RET_OK;
}
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(net, CORE_COMPONENT));
	CHKiRet(prop.CreateStringProp(&amp;pInputName, UCHAR_CONSTANT("imklog"), sizeof("imklog") - 1));
	initConfigSettings();
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogLocalipif", 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"debugprintkernelsymbols", 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(regCfSysLineHdlr2((uchar *)"klogpath", 0, eCmdHdlrGetWord,
			NULL, &amp;cs.pszPath, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogsymbollookup", 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogsymbolstwice", 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"klogusesyscallinterface", 0, eCmdHdlrGoneAway,
			NULL, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(regCfSysLineHdlr2((uchar *)"klogpermitnonkernelfacility", 0, eCmdHdlrBinary,
			NULL, &amp;cs.bPermitNonKernel, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"klogconsoleloglevel", 0, eCmdHdlrInt,
			NULL, &amp;cs.console_log_level, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"kloginternalmsgfacility", 0, eCmdHdlrFacility,
			NULL, &amp;cs.iFacilIntMsg, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"klogparsekerneltimestamp", 0, eCmdHdlrBinary,
			NULL, &amp;cs.bParseKernelStamp, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(regCfSysLineHdlr2((uchar *)"klogkeepkerneltimestamp", 0, eCmdHdlrBinary,
			NULL, &amp;cs.bKeepKernelStamp, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
			resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ommail.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;netdb.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/socket.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "cfsysline.h"
#include "module-template.h"
#include "errmsg.h"
#include "datetime.h"
#include "glbl.h"
#include "parserif.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("ommail")
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(datetime)
typedef struct toRcpt_s toRcpt_t;
struct toRcpt_s {
	uchar *pszTo;
	toRcpt_t *pNext;
};
typedef struct _instanceData {
	uchar *tplName;		uchar *constSubject; 	int8_t iMode;		sbool bHaveSubject; 	sbool bEnableBody; 	union {
		struct {
			uchar *pszSrv;
			uchar *pszSrvPort;
			uchar *pszFrom;
			toRcpt_t *lstRcpt;
			} smtp;
	} md;	} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	union {
		struct {
			char RcvBuf[1024]; 			size_t lenRcvBuf;
			size_t iRcvBuf;				int sock;				} smtp;
	} md;	} wrkrInstanceData_t;
typedef struct configSettings_s {
	toRcpt_t *lstRcpt;
	uchar *pszSrv;
	uchar *pszSrvPort;
	uchar *pszFrom;
	uchar *pszSubject;
	int bEnableBody; } configSettings_t;
static configSettings_t cs;
<a name="0"></a>static struct cnfparamdescr actpdescr[] = {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "server", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ "port", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ "mailfrom", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ "mailto", eCmdHdlrArray, CNFPARAM_REQUIRED },
	{ "subject.template", eCmdHdlrGetWord, 0 },
	{ "subject.text", eCmdHdlrString, 0 },
	{ "body.enable", eCmdHdlrBinary, 0 },
	{ "template", eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</b></font>
BEGINinitConfVars		CODESTARTinitConfVars
	cs.lstRcpt = NULL;
	cs.pszSrv = NULL;
	cs.pszSrvPort = NULL;
	cs.pszFrom = NULL;
	cs.pszSubject = NULL;
	cs.bEnableBody = 1; ENDinitConfVars
static rsRetVal Send(int sock, const char *msg, size_t len);
static rsRetVal readResponse(wrkrInstanceData_t *pWrkrData, int *piState, int iExpected);
static void lstRcptDestruct(toRcpt_t *pRoot)
{
	toRcpt_t *pDel;
	while(pRoot != NULL) {
		pDel = pRoot;
		pRoot = pRoot-&gt;pNext;
		free(pDel-&gt;pszTo);
		free(pDel);
	}
}
static rsRetVal
addRcpt(toRcpt_t **ppLstRcpt, uchar *newRcpt)
{
	DEFiRet;
	toRcpt_t *pNew = NULL;
	CHKmalloc(pNew = calloc(1, sizeof(toRcpt_t)));
	pNew-&gt;pszTo = newRcpt;
	pNew-&gt;pNext = *ppLstRcpt;
	*ppLstRcpt = pNew;
	DBGPRINTF("ommail::addRcpt adds recipient %s\n", newRcpt);
finalize_it:
	if(iRet != RS_RET_OK) {
		free(pNew);
		free(newRcpt); 	}
	RETiRet;
}
static rsRetVal
legacyConfAddRcpt(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	return addRcpt(&amp;cs.lstRcpt, pNewVal);
}
static rsRetVal
WriteRcpts(wrkrInstanceData_t *pWrkrData, uchar *pszOp, size_t lenOp, int iStatusToCheck)
{
	toRcpt_t *pRcpt;
	int iState;
	DEFiRet;
	assert(lenOp != 0);
	for(pRcpt = pWrkrData-&gt;pData-&gt;md.smtp.lstRcpt ; pRcpt != NULL ; pRcpt = pRcpt-&gt;pNext) {
		DBGPRINTF("Sending '%s: &lt;%s&gt;'\n", pszOp, pRcpt-&gt;pszTo);
		CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)pszOp, lenOp));
		CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, ":&lt;", sizeof(":&lt;") - 1));
		CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)pRcpt-&gt;pszTo, strlen((char*)pRcpt-&gt;pszTo)));
		CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "&gt;\r\n", sizeof("&gt;\r\n") - 1));
		if(iStatusToCheck &gt;= 0)
			CHKiRet(readResponse(pWrkrData, &amp;iState, iStatusToCheck));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
WriteTos(wrkrInstanceData_t *pWrkrData, uchar *pszOp, size_t lenOp)
{
	toRcpt_t *pRcpt;
	int iTos;
	DEFiRet;
	assert(lenOp != 0);
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)pszOp, lenOp));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, ": ", sizeof(": ") - 1));
	for(pRcpt = pWrkrData-&gt;pData-&gt;md.smtp.lstRcpt, iTos = 0; pRcpt != NULL ; pRcpt = pRcpt-&gt;pNext, iTos++) {
		DBGPRINTF("Sending '%s: &lt;%s&gt;'\n", pszOp, pRcpt-&gt;pszTo);
		if(iTos)
			CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, ", ", sizeof(", ") - 1));
		CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "&lt;", sizeof("&lt;") - 1));
		CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)pRcpt-&gt;pszTo, strlen((char*)pRcpt-&gt;pszTo)));
		CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "&gt;", sizeof("&gt;") - 1));
	}
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "\r\n", sizeof("\r\n") - 1));
finalize_it:
	RETiRet;
}
BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;constSubject = NULL;
	pData-&gt;bEnableBody = 1;
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;tplName);
	if(pData-&gt;iMode == 0) {
		free(pData-&gt;md.smtp.pszSrv);
		free(pData-&gt;md.smtp.pszSrvPort);
		free(pData-&gt;md.smtp.pszFrom);
		lstRcptDestruct(pData-&gt;md.smtp.lstRcpt);
	}
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	printf("mail"); ENDdbgPrintInstInfo
static rsRetVal
getRcvChar(wrkrInstanceData_t *pWrkrData, char *pC)
{
	DEFiRet;
	ssize_t lenBuf;
	if(pWrkrData-&gt;md.smtp.iRcvBuf == pWrkrData-&gt;md.smtp.lenRcvBuf) { 		do {
			lenBuf = recv(pWrkrData-&gt;md.smtp.sock, pWrkrData-&gt;md.smtp.RcvBuf,
			              sizeof(pWrkrData-&gt;md.smtp.RcvBuf), 0);
			if(lenBuf == 0) {
				ABORT_FINALIZE(RS_RET_NO_MORE_DATA);
			} else if(lenBuf &lt; 0) {
				if(errno != EAGAIN) {
					ABORT_FINALIZE(RS_RET_IO_ERROR);
				}
			} else {
				pWrkrData-&gt;md.smtp.iRcvBuf = 0;
				pWrkrData-&gt;md.smtp.lenRcvBuf = lenBuf;
			}
		} while(lenBuf &lt; 1);
	}
	*pC = pWrkrData-&gt;md.smtp.RcvBuf[pWrkrData-&gt;md.smtp.iRcvBuf++];
finalize_it:
	RETiRet;
}
static rsRetVal
serverDisconnect(wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	assert(pWrkrData != NULL);
	if(pWrkrData-&gt;md.smtp.sock != -1) {
		close(pWrkrData-&gt;md.smtp.sock);
		pWrkrData-&gt;md.smtp.sock = -1;
	}
	RETiRet;
}
static rsRetVal
serverConnect(wrkrInstanceData_t *pWrkrData)
{
	struct addrinfo *res = NULL;
	struct addrinfo hints;
	const char *smtpPort;
	const char *smtpSrv;
	char errStr[1024];
	instanceData *pData;
	DEFiRet;
	pData = pWrkrData-&gt;pData;
	if(pData-&gt;md.smtp.pszSrv == NULL)
		smtpSrv = "127.0.0.1";
	else
		smtpSrv = (char*)pData-&gt;md.smtp.pszSrv;
	if(pData-&gt;md.smtp.pszSrvPort == NULL)
		smtpPort = "25";
	else
		smtpPort = (char*)pData-&gt;md.smtp.pszSrvPort;
	memset(&amp;hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC; 	hints.ai_socktype = SOCK_STREAM;
	if(getaddrinfo(smtpSrv, smtpPort, &amp;hints, &amp;res) != 0) {
		DBGPRINTF("error %d in getaddrinfo\n", errno);
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}
	if((pWrkrData-&gt;md.smtp.sock = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol)) == -1) {
		DBGPRINTF("couldn't create send socket, reason %s", rs_strerror_r(errno, errStr, sizeof(errStr)));
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}
	if(connect(pWrkrData-&gt;md.smtp.sock, res-&gt;ai_addr, res-&gt;ai_addrlen) != 0) {
		DBGPRINTF("create tcp connection failed, reason %s", rs_strerror_r(errno, errStr, sizeof(errStr)));
		ABORT_FINALIZE(RS_RET_IO_ERROR);
	}
finalize_it:
	if(res != NULL)
		freeaddrinfo(res);
	if(iRet != RS_RET_OK) {
		if(pWrkrData-&gt;md.smtp.sock != -1) {
			close(pWrkrData-&gt;md.smtp.sock);
			pWrkrData-&gt;md.smtp.sock = -1;
		}
	}
	RETiRet;
}
static rsRetVal
Send(const int sock, const char *const __restrict__ msg, const size_t len)
{
	DEFiRet;
	size_t offsBuf = 0;
	ssize_t lenSend;
	assert(msg != NULL);
	if(len == 0) 		FINALIZE;
	do {
		lenSend = send(sock, msg + offsBuf, len - offsBuf, 0);
		if(lenSend == -1) {
			if(errno != EAGAIN) {
				DBGPRINTF("message not (smtp/tcp)send, errno %d", errno);
				ABORT_FINALIZE(RS_RET_TCP_SEND_ERROR);
			}
		} else if(lenSend != (ssize_t) (len - offsBuf)) {
			offsBuf += lenSend; 		} else {
			FINALIZE;
		}
	} while(1);
finalize_it:
	RETiRet;
}
static rsRetVal
bodySend(wrkrInstanceData_t *pWrkrData, char *msg, size_t len)
{
	DEFiRet;
	char szBuf[2048];
	size_t iSrc;
	size_t iBuf = 0;
	int bHadCR = 0;
	int bInStartOfLine = 1;
	assert(pWrkrData != NULL);
	assert(msg != NULL);
	for(iSrc = 0 ; iSrc &lt; len ; ++iSrc) {
		if(iBuf &gt;= sizeof(szBuf) - 1) { 			CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, szBuf, iBuf));
			iBuf = 0;
		}
		szBuf[iBuf++] = msg[iSrc];
		switch(msg[iSrc]) {
			case '\r':
				bHadCR = 1;
				break;
			case '\n':
				if(bHadCR)
					bInStartOfLine = 1;
				bHadCR = 0;
				break;
			case '.':
				if(bInStartOfLine)
			default:
				bInStartOfLine = 0;
				bHadCR = 0;
				break;
		}
	}
	if(iBuf &gt; 0) { 		CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, szBuf, iBuf));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
readResponseLn(wrkrInstanceData_t *pWrkrData, char *pLn, size_t lenLn, size_t *const __restrict__ respLen)
{
	DEFiRet;
	size_t i = 0;
	char c;
	assert(pWrkrData != NULL);
	assert(pLn != NULL);
	do {
		CHKiRet(getRcvChar(pWrkrData, &amp;c));
		if(c == '\n')
			break;
		if(i &lt; (lenLn - 1)) 			pLn[i++] = c;
	} while(1);
	DBGPRINTF("smtp server response: %s\n", pLn);
finalize_it:
	pLn[i] = '\0';
	*respLen = i;
	RETiRet;
}
static rsRetVal
readResponse(wrkrInstanceData_t *pWrkrData, int *piState, int iExpected)
{
	DEFiRet;
	int bCont;
	char buf[128];
	size_t respLen;
	assert(pWrkrData != NULL);
	assert(piState != NULL);
	bCont = 1;
	do {
		CHKiRet(readResponseLn(pWrkrData, buf, sizeof(buf), &amp;respLen));
		if(respLen &lt; 4) 			ABORT_FINALIZE(RS_RET_SMTP_ERROR);
		if(buf[3] != '-') { 			bCont = 0;
			*piState = buf[0] - '0';
			*piState = *piState * 10 + buf[1] - '0';
			*piState = *piState * 10 + buf[2] - '0';
			if(*piState != iExpected)
				ABORT_FINALIZE(RS_RET_SMTP_ERROR);
		}
	} while(bCont);
finalize_it:
	RETiRet;
}
static void
mkSMTPTimestamp(uchar *pszBuf, size_t lenBuf)
{
	time_t tCurr;
	struct tm tmCurr;
	static const char szDay[][4] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
	static const char szMonth[][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep",
	"Oct", "Nov", "Dec"};
	datetime.GetTime(&amp;tCurr);
	gmtime_r(&amp;tCurr, &amp;tmCurr);
	snprintf((char*)pszBuf, lenBuf, "Date: %s, %2d %s %4d %02d:%02d:%02d +0000\r\n", szDay[tmCurr.tm_wday],
	tmCurr.tm_mday,
		 szMonth[tmCurr.tm_mon], 1900 + tmCurr.tm_year, tmCurr.tm_hour, tmCurr.tm_min, tmCurr.tm_sec);
}
static rsRetVal
sendSMTP(wrkrInstanceData_t *pWrkrData, uchar *body, uchar *subject)
{
	DEFiRet;
	int iState; 	instanceData *pData;
	uchar szDateBuf[64];
	pData = pWrkrData-&gt;pData;
	CHKiRet(serverConnect(pWrkrData));
	CHKiRet(readResponse(pWrkrData, &amp;iState, 220));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "HELO ", 5));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)glbl.GetLocalHostName(),
		strlen((char*)glbl.GetLocalHostName())));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "\r\n", sizeof("\r\n") - 1));
	CHKiRet(readResponse(pWrkrData, &amp;iState, 250));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "MAIL FROM:&lt;", sizeof("MAIL FROM:&lt;") - 1));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)pData-&gt;md.smtp.pszFrom, strlen((char*)pData-&gt;md.smtp.pszFrom)));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "&gt;\r\n", sizeof("&gt;\r\n") - 1));
	CHKiRet(readResponse(pWrkrData, &amp;iState, 250));
	CHKiRet(WriteRcpts(pWrkrData, (uchar*)"RCPT TO", sizeof("RCPT TO") - 1, 250));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "DATA\r\n",   sizeof("DATA\r\n") - 1));
	CHKiRet(readResponse(pWrkrData, &amp;iState, 354));
	mkSMTPTimestamp(szDateBuf, sizeof(szDateBuf));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)szDateBuf, strlen((char*)szDateBuf)));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "From: &lt;", sizeof("From: &lt;") - 1));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)pData-&gt;md.smtp.pszFrom, strlen((char*)pData-&gt;md.smtp.pszFrom)));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "&gt;\r\n", sizeof("&gt;\r\n") - 1));
	CHKiRet(WriteTos(pWrkrData, (uchar*)"To", sizeof("To") - 1));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "Subject: ",   sizeof("Subject: ") - 1));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, (char*)subject, strlen((char*)subject)));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "\r\n", sizeof("\r\n") - 1));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "X-Mailer: rsyslog-ommail\r\n",
		sizeof("x-mailer: rsyslog-ommail\r\n") - 1));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "\r\n",   sizeof("\r\n") - 1)); 
	if(pData-&gt;bEnableBody)
		CHKiRet(bodySend(pWrkrData, (char*)body, strlen((char*) body)));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "\r\n.\r\n",   sizeof("\r\n.\r\n") - 1));
	CHKiRet(readResponse(pWrkrData, &amp;iState, 250));
	CHKiRet(Send(pWrkrData-&gt;md.smtp.sock, "QUIT\r\n",   sizeof("QUIT\r\n") - 1));
	CHKiRet(readResponse(pWrkrData, &amp;iState, 221));
	CHKiRet(serverDisconnect(pWrkrData));
finalize_it:
	RETiRet;
}
BEGINtryResume
CODESTARTtryResume
	CHKiRet(serverConnect(pWrkrData));
	CHKiRet(serverDisconnect(pWrkrData)); finalize_it:
	if(iRet == RS_RET_IO_ERROR)
		iRet = RS_RET_SUSPENDED;
ENDtryResume
BEGINdoAction
	uchar *subject;
	const instanceData *const __restrict__ pData = pWrkrData-&gt;pData;
CODESTARTdoAction
	DBGPRINTF("ommail doAction()\n");
	if(pData-&gt;constSubject != NULL)
		subject = pData-&gt;constSubject;
	else if(pData-&gt;bHaveSubject)
		subject = ppString[1];
	else
		subject = (uchar*)"message from rsyslog";
	iRet = sendSMTP(pWrkrData, ppString[0], subject);
	if(iRet != RS_RET_OK) {
		DBGPRINTF("error sending mail, suspending\n");
		iRet = RS_RET_SUSPENDED;
	}
ENDdoAction
static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;tplName = NULL;
	pData-&gt;constSubject = NULL;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
<a name="1"></a>	uchar *tplSubject = NULL;
	int i, j;
CODESTARTnewActInst
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "server")) {
			pData-&gt;md.smtp.pszSrv = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "port")) {
			pData-&gt;md.smtp.pszSrvPort =  (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(actpblk.descr[i].name, "mailfrom")) {
			pData-&gt;md.smtp.pszFrom = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "mailto")) {
			for(j = 0 ; j &lt; pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				addRcpt(&amp;(pData-&gt;md.smtp.lstRcpt),
					(uchar*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL));
			}
		} else if(!strcmp(actpblk.descr[i].name, "subject.template")) {
			if(pData-&gt;constSubject != NULL) {
				parser_errmsg("ommail: only one of subject.template, subject.text "
					      "can be set");
				ABORT_FINALIZE(RS_RET_DUP_PARAM);
			}
			tplSubject = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "subject.text")) {
			if(tplSubject != NULL) {
				parser_errmsg("ommail: only one of subject.template, subject.text "
					      "can be set");
				ABORT_FINALIZE(RS_RET_DUP_PARAM);
<a name="2"></a>			}
			pData-&gt;constSubject = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "body.enable")) {
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			pData-&gt;bEnableBody =  (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			DBGPRINTF("ommail: program error, non-handled "
			  "param '%s'\n", actpblk.descr[i].name);
		}
	}</b></font>
	if(tplSubject == NULL) {
		CODE_STD_STRING_REQUESTparseSelectorAct(1)
	} else {
		CODE_STD_STRING_REQUESTparseSelectorAct(2)
		pData-&gt;bHaveSubject = 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, 1, tplSubject, OMSR_NO_RQD_TPL_OPTS));
	}
	if(pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup("RSYSLOG_FileFormat"),
			OMSR_NO_RQD_TPL_OPTS));
	} else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
			(uchar*) strdup((char*) pData-&gt;tplName),
			OMSR_NO_RQD_TPL_OPTS));
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINparseSelectorAct
CODESTARTparseSelectorAct
	if(!strncmp((char*) p, ":ommail:", sizeof(":ommail:") - 1)) {
		p += sizeof(":ommail:") - 1; 	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}
	if((iRet = createInstance(&amp;pData)) != RS_RET_OK)
		FINALIZE;
	if(cs.pszFrom == NULL) {
		LogError(0, RS_RET_MAIL_NO_FROM, "no sender address given - specify $ActionMailFrom");
		ABORT_FINALIZE(RS_RET_MAIL_NO_FROM);
	}
	if(cs.lstRcpt == NULL) {
		LogError(0, RS_RET_MAIL_NO_TO, "no recipient address given - specify $ActionMailTo");
		ABORT_FINALIZE(RS_RET_MAIL_NO_TO);
	}
	pData-&gt;md.smtp.pszFrom = (uchar*) strdup((char*)cs.pszFrom);
	pData-&gt;md.smtp.lstRcpt = cs.lstRcpt; 	cs.lstRcpt = NULL; 
	if(cs.pszSubject == NULL) {
		CODE_STD_STRING_REQUESTparseSelectorAct(1)
	} else {
		CODE_STD_STRING_REQUESTparseSelectorAct(2)
		pData-&gt;bHaveSubject = 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, 1, (uchar*)strdup((char*) cs.pszSubject), OMSR_NO_RQD_TPL_OPTS));
	}
	if(cs.pszSrv != NULL)
		pData-&gt;md.smtp.pszSrv = (uchar*) strdup((char*)cs.pszSrv);
	if(cs.pszSrvPort != NULL)
		pData-&gt;md.smtp.pszSrvPort = (uchar*) strdup((char*)cs.pszSrvPort);
	pData-&gt;bEnableBody = cs.bEnableBody;
	iRet = cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, (uchar*) "RSYSLOG_FileFormat");
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
static rsRetVal freeConfigVariables(void)
{
	DEFiRet;
	free(cs.pszSrv);
	cs.pszSrv = NULL;
	free(cs.pszSrvPort);
	cs.pszSrvPort = NULL;
	free(cs.pszFrom);
	cs.pszFrom = NULL;
	lstRcptDestruct(cs.lstRcpt);
	cs.lstRcpt = NULL;
	RETiRet;
}
BEGINmodExit
CODESTARTmodExit
	freeConfigVariables();
	objRelease(datetime, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	cs.bEnableBody = 1;
	iRet = freeConfigVariables();
	RETiRet;
}
BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	DBGPRINTF("ommail version %s initializing\n", VERSION);
	CHKiRet(omsdRegCFSLineHdlr(	(uchar *)"actionmailsmtpserver", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszSrv,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(	(uchar *)"actionmailsmtpport", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszSrvPort,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(	(uchar *)"actionmailfrom", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszFrom,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(	(uchar *)"actionmailto", 0, eCmdHdlrGetWord, legacyConfAddRcpt, NULL,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(	(uchar *)"actionmailsubject", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszSubject,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(	(uchar *)"actionmailenablebody", 0, eCmdHdlrBinary, NULL, &amp;cs.bEnableBody,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr(	(uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
	resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
