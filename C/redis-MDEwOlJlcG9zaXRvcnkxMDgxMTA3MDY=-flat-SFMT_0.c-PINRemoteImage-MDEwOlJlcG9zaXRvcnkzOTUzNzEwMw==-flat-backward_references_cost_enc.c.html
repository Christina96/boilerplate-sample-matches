
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-SFMT_0.c</h3>
            <pre><code>1  #define SFMT_C_
2  #include "test/jemalloc_test.h"
3  #include "test/SFMT-params.h"
4  #if defined(JEMALLOC_BIG_ENDIAN) && !defined(BIG_ENDIAN64)
5  #define BIG_ENDIAN64 1
6  #endif
7  #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64)
8  #define BIG_ENDIAN64 1
9  #endif
10  #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64)
11  #define BIG_ENDIAN64 1
12  #endif
13  #if defined(ONLY64) && !defined(BIG_ENDIAN64)
14    #if defined(__GNUC__)
15      #error "-DONLY64 must be specified with -DBIG_ENDIAN64"
16    #endif
17  #undef ONLY64
18  #endif
19  #if defined(HAVE_ALTIVEC)
20  union W128_T {
21      vector unsigned int s;
22      uint32_t u[4];
23  };
24  typedef union W128_T w128_t;
25  #elif defined(HAVE_SSE2)
26  union W128_T {
27      __m128i si;
28      uint32_t u[4];
29  };
30  typedef union W128_T w128_t;
31  #else
32  struct W128_T {
33      uint32_t u[4];
34  };
35  typedef struct W128_T w128_t;
36  #endif
37  struct sfmt_s {
38      w128_t sfmt[N];
39      int idx;
40      int initialized;
41  };
42  static uint32_t parity[4] = {PARITY1, PARITY2, PARITY3, PARITY4};
43  static inline int idxof(int i);
44  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
45  static inline void rshift128(w128_t *out,  w128_t const *in, int shift);
46  static inline void lshift128(w128_t *out,  w128_t const *in, int shift);
47  #endif
48  static inline void gen_rand_all(sfmt_t *ctx);
49  static inline void gen_rand_array(sfmt_t *ctx, w128_t *array, int size);
50  static inline uint32_t func1(uint32_t x);
51  static inline uint32_t func2(uint32_t x);
52  static void period_certification(sfmt_t *ctx);
53  #if defined(BIG_ENDIAN64) && !defined(ONLY64)
54  static inline void swap(w128_t *array, int size);
55  #endif
56  #if defined(HAVE_ALTIVEC)
57    #include "test/SFMT-alti.h"
58  #elif defined(HAVE_SSE2)
59    #include "test/SFMT-sse2.h"
60  #endif
61  #ifdef ONLY64
62  static inline int idxof(int i) {
63      return i ^ 1;
64  }
65  #else
66  static inline int idxof(int i) {
67      return i;
68  }
69  #endif
70  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
71  #ifdef ONLY64
72  static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
73      uint64_t th, tl, oh, ol;
74      th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
75      tl = ((uint64_t)in->u[0] << 32) | ((uint64_t)in->u[1]);
76      oh = th >> (shift * 8);
77      ol = tl >> (shift * 8);
78      ol |= th << (64 - shift * 8);
79      out->u[0] = (uint32_t)(ol >> 32);
80      out->u[1] = (uint32_t)ol;
81      out->u[2] = (uint32_t)(oh >> 32);
82      out->u[3] = (uint32_t)oh;
83  }
84  #else
85  static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
86      uint64_t th, tl, oh, ol;
87      th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
88      tl = ((uint64_t)in->u[1] << 32) | ((uint64_t)in->u[0]);
89      oh = th >> (shift * 8);
90      ol = tl >> (shift * 8);
91      ol |= th << (64 - shift * 8);
92      out->u[1] = (uint32_t)(ol >> 32);
93      out->u[0] = (uint32_t)ol;
94      out->u[3] = (uint32_t)(oh >> 32);
95      out->u[2] = (uint32_t)oh;
96  }
97  #endif
98  #ifdef ONLY64
99  static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
100      uint64_t th, tl, oh, ol;
101      th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
102      tl = ((uint64_t)in->u[0] << 32) | ((uint64_t)in->u[1]);
103      oh = th << (shift * 8);
104      ol = tl << (shift * 8);
105      oh |= tl >> (64 - shift * 8);
106      out->u[0] = (uint32_t)(ol >> 32);
107      out->u[1] = (uint32_t)ol;
108      out->u[2] = (uint32_t)(oh >> 32);
109      out->u[3] = (uint32_t)oh;
110  }
111  #else
112  static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
113      uint64_t th, tl, oh, ol;
114      th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
115      tl = ((uint64_t)in->u[1] << 32) | ((uint64_t)in->u[0]);
116      oh = th << (shift * 8);
117      ol = tl << (shift * 8);
118      oh |= tl >> (64 - shift * 8);
119      out->u[1] = (uint32_t)(ol >> 32);
120      out->u[0] = (uint32_t)ol;
121      out->u[3] = (uint32_t)(oh >> 32);
122      out->u[2] = (uint32_t)oh;
123  }
124  #endif
125  #endif
126  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
127  #ifdef ONLY64
128  static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
129  				w128_t *d) {
130      w128_t x;
131      w128_t y;
132      lshift128(&x, a, SL2);
133      rshift128(&y, c, SR2);
134      r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> SR1) & MSK2) ^ y.u[0]
135  	^ (d->u[0] << SL1);
136      r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> SR1) & MSK1) ^ y.u[1]
137  	^ (d->u[1] << SL1);
138      r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> SR1) & MSK4) ^ y.u[2]
139  	^ (d->u[2] << SL1);
140      r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK3) ^ y.u[3]
141  	^ (d->u[3] << SL1);
142  }
143  #else
144  static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
145  				w128_t *d) {
146      w128_t x;
147      w128_t y;
148      lshift128(&x, a, SL2);
149      rshift128(&y, c, SR2);
150      r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> SR1) & MSK1) ^ y.u[0]
151  	^ (d->u[0] << SL1);
152      r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> SR1) & MSK2) ^ y.u[1]
153  	^ (d->u[1] << SL1);
154      r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> SR1) & MSK3) ^ y.u[2]
155  	^ (d->u[2] << SL1);
156      r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK4) ^ y.u[3]
157  	^ (d->u[3] << SL1);
158  }
159  #endif
160  #endif
161  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
162  static inline void gen_rand_all(sfmt_t *ctx) {
163      int i;
164      w128_t *r1, *r2;
165      r1 = &ctx->sfmt[N - 2];
166      r2 = &ctx->sfmt[N - 1];
167      for (i = 0; i < N - POS1; i++) {
168  	do_recursion(&ctx->sfmt[i], &ctx->sfmt[i], &ctx->sfmt[i + POS1], r1,
169  	  r2);
170  	r1 = r2;
171  	r2 = &ctx->sfmt[i];
172      }
173      for (; i < N; i++) {
174  	do_recursion(&ctx->sfmt[i], &ctx->sfmt[i], &ctx->sfmt[i + POS1 - N], r1,
175  	  r2);
176  	r1 = r2;
177  	r2 = &ctx->sfmt[i];
178      }
179  }
180  static inline void gen_rand_array(sfmt_t *ctx, w128_t *array, int size) {
181      int i, j;
182      w128_t *r1, *r2;
183      r1 = &ctx->sfmt[N - 2];
184      r2 = &ctx->sfmt[N - 1];
185      for (i = 0; i < N - POS1; i++) {
186  	do_recursion(&array[i], &ctx->sfmt[i], &ctx->sfmt[i + POS1], r1, r2);
187  	r1 = r2;
188  	r2 = &array[i];
189      }
190      for (; i < N; i++) {
191  	do_recursion(&array[i], &ctx->sfmt[i], &array[i + POS1 - N], r1, r2);
192  	r1 = r2;
193  	r2 = &array[i];
194      }
195      for (; i < size - N; i++) {
196  	do_recursion(&array[i], &array[i - N], &array[i + POS1 - N], r1, r2);
197  	r1 = r2;
198  	r2 = &array[i];
199      }
200      for (j = 0; j < 2 * N - size; j++) {
201  	ctx->sfmt[j] = array[j + size - N];
202      }
203      for (; i < size; i++, j++) {
204  	do_recursion(&array[i], &array[i - N], &array[i + POS1 - N], r1, r2);
205  	r1 = r2;
206  	r2 = &array[i];
207  	ctx->sfmt[j] = array[i];
208      }
209  }
210  #endif
211  #if defined(BIG_ENDIAN64) && !defined(ONLY64) && !defined(HAVE_ALTIVEC)
212  static inline void swap(w128_t *array, int size) {
213      int i;
214      uint32_t x, y;
215      for (i = 0; i < size; i++) {
216  	x = array[i].u[0];
217  	y = array[i].u[2];
218  	array[i].u[0] = array[i].u[1];
219  	array[i].u[2] = array[i].u[3];
220  	array[i].u[1] = x;
221  	array[i].u[3] = y;
222      }
223  }
224  #endif
225  static uint32_t func1(uint32_t x) {
226      return (x ^ (x >> 27)) * (uint32_t)1664525UL;
227  }
228  static uint32_t func2(uint32_t x) {
229      return (x ^ (x >> 27)) * (uint32_t)1566083941UL;
230  }
231  static void period_certification(sfmt_t *ctx) {
232      int inner = 0;
233      int i, j;
234      uint32_t work;
235      uint32_t *psfmt32 = &ctx->sfmt[0].u[0];
236      for (i = 0; i < 4; i++)
237  	inner ^= psfmt32[idxof(i)] & parity[i];
238      for (i = 16; i > 0; i >>= 1)
239  	inner ^= inner >> i;
240      inner &= 1;
241      if (inner == 1) {
242  	return;
243      }
244      for (i = 0; i < 4; i++) {
245  	work = 1;
246  	for (j = 0; j < 32; j++) {
247  	    if ((work & parity[i]) != 0) {
248  		psfmt32[idxof(i)] ^= work;
249  		return;
250  	    }
251  	    work = work << 1;
252  	}
253      }
254  }
255  const char *get_idstring(void) {
256      return IDSTR;
257  }
258  int get_min_array_size32(void) {
259      return N32;
260  }
261  int get_min_array_size64(void) {
262      return N64;
263  }
264  #ifndef ONLY64
265  uint32_t gen_rand32(sfmt_t *ctx) {
266      uint32_t r;
267      uint32_t *psfmt32 = &ctx->sfmt[0].u[0];
268      assert(ctx->initialized);
269      if (ctx->idx >= N32) {
270  	gen_rand_all(ctx);
271  	ctx->idx = 0;
272      }
273      r = psfmt32[ctx->idx++];
274      return r;
275  }
276  uint32_t gen_rand32_range(sfmt_t *ctx, uint32_t limit) {
277      uint32_t ret, above;
278      above = 0xffffffffU - (0xffffffffU % limit);
279      while (1) {
280  	ret = gen_rand32(ctx);
281  	if (ret < above) {
282  	    ret %= limit;
283  	    break;
284  	}
285      }
286      return ret;
287  }
288  #endif
289  uint64_t gen_rand64(sfmt_t *ctx) {
290  #if defined(BIG_ENDIAN64) && !defined(ONLY64)
291      uint32_t r1, r2;
292      uint32_t *psfmt32 = &ctx->sfmt[0].u[0];
293  #else
294      uint64_t r;
295      uint64_t *psfmt64 = (uint64_t *)&ctx->sfmt[0].u[0];
296  #endif
297      assert(ctx->initialized);
298      assert(ctx->idx % 2 == 0);
299      if (ctx->idx >= N32) {
300  	gen_rand_all(ctx);
301  	ctx->idx = 0;
302      }
303  #if defined(BIG_ENDIAN64) && !defined(ONLY64)
304      r1 = psfmt32[ctx->idx];
305      r2 = psfmt32[ctx->idx + 1];
306      ctx->idx += 2;
307      return ((uint64_t)r2 << 32) | r1;
308  #else
309      r = psfmt64[ctx->idx / 2];
310      ctx->idx += 2;
311      return r;
312  #endif
313  }
314  uint64_t gen_rand64_range(sfmt_t *ctx, uint64_t limit) {
315      uint64_t ret, above;
316      above = KQU(0xffffffffffffffff) - (KQU(0xffffffffffffffff) % limit);
317      while (1) {
318  	ret = gen_rand64(ctx);
319  	if (ret < above) {
320  	    ret %= limit;
321  	    break;
322  	}
323      }
324      return ret;
325  }
326  #ifndef ONLY64
327  void fill_array32(sfmt_t *ctx, uint32_t *array, int size) {
328      assert(ctx->initialized);
329      assert(ctx->idx == N32);
330      assert(size % 4 == 0);
331      assert(size >= N32);
332      gen_rand_array(ctx, (w128_t *)array, size / 4);
333      ctx->idx = N32;
334  }
335  #endif
336  void fill_array64(sfmt_t *ctx, uint64_t *array, int size) {
337      assert(ctx->initialized);
338      assert(ctx->idx == N32);
339      assert(size % 2 == 0);
340      assert(size >= N64);
341      gen_rand_array(ctx, (w128_t *)array, size / 2);
342      ctx->idx = N32;
343  #if defined(BIG_ENDIAN64) && !defined(ONLY64)
344      swap((w128_t *)array, size /2);
345  #endif
346  }
347  sfmt_t *init_gen_rand(uint32_t seed) {
348      void *p;
349      sfmt_t *ctx;
350      int i;
351      uint32_t *psfmt32;
352      if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {
353  	return NULL;
354      }
355      ctx = (sfmt_t *)p;
356      psfmt32 = &ctx->sfmt[0].u[0];
357      psfmt32[idxof(0)] = seed;
358      for (i = 1; i < N32; i++) {
359  	psfmt32[idxof(i)] = 1812433253UL * (psfmt32[idxof(i - 1)]
360  					    ^ (psfmt32[idxof(i - 1)] >> 30))
361  	    + i;
362      }
363      ctx->idx = N32;
364      period_certification(ctx);
365      ctx->initialized = 1;
366      return ctx;
367  }
368  sfmt_t *init_by_array(uint32_t *init_key, int key_length) {
369      void *p;
370      sfmt_t *ctx;
371      int i, j, count;
372      uint32_t r;
373      int lag;
374      int mid;
375      int size = N * 4;
376      uint32_t *psfmt32;
377      if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {
378  	return NULL;
379      }
380      ctx = (sfmt_t *)p;
381      psfmt32 = &ctx->sfmt[0].u[0];
382      if (size >= 623) {
383  	lag = 11;
384      } else if (size >= 68) {
385  	lag = 7;
386      } else if (size >= 39) {
387  	lag = 5;
388      } else {
389  	lag = 3;
390      }
391      mid = (size - lag) / 2;
392      memset(ctx->sfmt, 0x8b, sizeof(ctx->sfmt));
393      if (key_length + 1 > N32) {
394  	count = key_length + 1;
395      } else {
396  	count = N32;
397      }
398      r = func1(psfmt32[idxof(0)] ^ psfmt32[idxof(mid)]
399  	      ^ psfmt32[idxof(N32 - 1)]);
400      psfmt32[idxof(mid)] += r;
401      r += key_length;
402      psfmt32[idxof(mid + lag)] += r;
403      psfmt32[idxof(0)] = r;
404      count--;
405      for (i = 1, j = 0; (j < count) && (j < key_length); j++) {
406  	r = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % N32)]
407  		  ^ psfmt32[idxof((i + N32 - 1) % N32)]);
408  	psfmt32[idxof((i + mid) % N32)] += r;
409  	r += init_key[j] + i;
410  	psfmt32[idxof((i + mid + lag) % N32)] += r;
411  	psfmt32[idxof(i)] = r;
412  	i = (i + 1) % N32;
413      }
414      for (; j < count; j++) {
415  	r = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % N32)]
416  		  ^ psfmt32[idxof((i + N32 - 1) % N32)]);
417  	psfmt32[idxof((i + mid) % N32)] += r;
418  	r += i;
419  	psfmt32[idxof((i + mid + lag) % N32)] += r;
420  	psfmt32[idxof(i)] = r;
421  	i = (i + 1) % N32;
422      }
423      for (j = 0; j < N32; j++) {
424  	r = func2(psfmt32[idxof(i)] + psfmt32[idxof((i + mid) % N32)]
425  		  + psfmt32[idxof((i + N32 - 1) % N32)]);
426  	psfmt32[idxof((i + mid) % N32)] ^= r;
427  	r -= i;
428  	psfmt32[idxof((i + mid + lag) % N32)] ^= r;
429  	psfmt32[idxof(i)] = r;
430  	i = (i + 1) % N32;
431      }
<span onclick='openModal()' class='match'>432      ctx->idx = N32;
433      period_certification(ctx);
434      ctx->initialized = 1;
435      return ctx;
</span>436  }
437  void fini_gen_rand(sfmt_t *ctx) {
438      assert(ctx != NULL);
439      ctx->initialized = 0;
440      free(ctx);
441  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include "src/enc/backward_references_enc.h"
3  #include "src/enc/histogram_enc.h"
4  #include "src/dsp/lossless_common.h"
5  #include "src/utils/color_cache_utils.h"
6  #include "src/utils/utils.h"
7  #define VALUES_IN_BYTE 256
8  extern void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs);
9  extern int VP8LDistanceToPlaneCode(int xsize, int dist);
10  extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
11                                        const PixOrCopy v);
12  typedef struct {
13    double alpha_[VALUES_IN_BYTE];
14    double red_[VALUES_IN_BYTE];
15    double blue_[VALUES_IN_BYTE];
16    double distance_[NUM_DISTANCE_CODES];
17    double* literal_;
18  } CostModel;
19  static void ConvertPopulationCountTableToBitEstimates(
20      int num_symbols, const uint32_t population_counts[], double output[]) {
21    uint32_t sum = 0;
22    int nonzeros = 0;
23    int i;
24    for (i = 0; i < num_symbols; ++i) {
25      sum += population_counts[i];
26      if (population_counts[i] > 0) {
27        ++nonzeros;
28      }
29    }
30    if (nonzeros <= 1) {
31      memset(output, 0, num_symbols * sizeof(*output));
32    } else {
33      const double logsum = VP8LFastLog2(sum);
34      for (i = 0; i < num_symbols; ++i) {
35        output[i] = logsum - VP8LFastLog2(population_counts[i]);
36      }
37    }
38  }
39  static int CostModelBuild(CostModel* const m, int xsize, int cache_bits,
40                            const VP8LBackwardRefs* const refs) {
41    int ok = 0;
42    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
43    VP8LHistogram* const histo = VP8LAllocateHistogram(cache_bits);
44    if (histo == NULL) goto Error;
45    VP8LHistogramInit(histo, cache_bits, &bsol;*init_arrays=*/ 1);
46    while (VP8LRefsCursorOk(&c)) {
47      VP8LHistogramAddSinglePixOrCopy(histo, c.cur_pos, VP8LDistanceToPlaneCode,
48                                      xsize);
49      VP8LRefsCursorNext(&c);
50    }
51    ConvertPopulationCountTableToBitEstimates(
52        VP8LHistogramNumCodes(histo->palette_code_bits_),
53        histo->literal_, m->literal_);
54    ConvertPopulationCountTableToBitEstimates(
55        VALUES_IN_BYTE, histo->red_, m->red_);
56    ConvertPopulationCountTableToBitEstimates(
57        VALUES_IN_BYTE, histo->blue_, m->blue_);
58    ConvertPopulationCountTableToBitEstimates(
59        VALUES_IN_BYTE, histo->alpha_, m->alpha_);
60    ConvertPopulationCountTableToBitEstimates(
61        NUM_DISTANCE_CODES, histo->distance_, m->distance_);
62    ok = 1;
63   Error:
64    VP8LFreeHistogram(histo);
65    return ok;
66  }
67  static WEBP_INLINE double GetLiteralCost(const CostModel* const m, uint32_t v) {
68    return m->alpha_[v >> 24] +
69           m->red_[(v >> 16) & 0xff] +
70           m->literal_[(v >> 8) & 0xff] +
71           m->blue_[v & 0xff];
72  }
73  static WEBP_INLINE double GetCacheCost(const CostModel* const m, uint32_t idx) {
74    const int literal_idx = VALUES_IN_BYTE + NUM_LENGTH_CODES + idx;
75    return m->literal_[literal_idx];
76  }
77  static WEBP_INLINE double GetLengthCost(const CostModel* const m,
78                                          uint32_t length) {
79    int code, extra_bits;
80    VP8LPrefixEncodeBits(length, &code, &extra_bits);
81    return m->literal_[VALUES_IN_BYTE + code] + extra_bits;
82  }
83  static WEBP_INLINE double GetDistanceCost(const CostModel* const m,
84                                            uint32_t distance) {
85    int code, extra_bits;
86    VP8LPrefixEncodeBits(distance, &code, &extra_bits);
87    return m->distance_[code] + extra_bits;
88  }
89  static WEBP_INLINE void AddSingleLiteralWithCostModel(
90      const uint32_t* const argb, VP8LColorCache* const hashers,
91      const CostModel* const cost_model, int idx, int use_color_cache,
92      float prev_cost, float* const cost, uint16_t* const dist_array) {
93    double cost_val = prev_cost;
94    const uint32_t color = argb[idx];
95    const int ix = use_color_cache ? VP8LColorCacheContains(hashers, color) : -1;
96    if (ix >= 0) {
97      const double mul0 = 0.68;
98      cost_val += GetCacheCost(cost_model, ix) * mul0;
99    } else {
100      const double mul1 = 0.82;
101      if (use_color_cache) VP8LColorCacheInsert(hashers, color);
102      cost_val += GetLiteralCost(cost_model, color) * mul1;
103    }
104    if (cost[idx] > cost_val) {
105      cost[idx] = (float)cost_val;
106      dist_array[idx] = 1;  
107    }
108  }
109  #define COST_CACHE_INTERVAL_SIZE_MAX 500
110  typedef struct CostInterval CostInterval;
111  struct CostInterval {
112    float cost_;
113    int start_;
114    int end_;
115    int index_;
116    CostInterval* previous_;
117    CostInterval* next_;
118  };
119  typedef struct {
120    double cost_;
121    int start_;
122    int end_;       
123  } CostCacheInterval;
124  #define COST_MANAGER_MAX_FREE_LIST 10
125  typedef struct {
126    CostInterval* head_;
127    int count_;  
128    CostCacheInterval* cache_intervals_;
129    size_t cache_intervals_size_;
130    double cost_cache_[MAX_LENGTH];  
131    float* costs_;
132    uint16_t* dist_array_;
133    CostInterval intervals_[COST_MANAGER_MAX_FREE_LIST];
134    CostInterval* free_intervals_;
135    CostInterval* recycled_intervals_;
136  } CostManager;
137  static void CostIntervalAddToFreeList(CostManager* const manager,
138                                        CostInterval* const interval) {
139    interval->next_ = manager->free_intervals_;
140    manager->free_intervals_ = interval;
141  }
142  static int CostIntervalIsInFreeList(const CostManager* const manager,
143                                      const CostInterval* const interval) {
144    return (interval >= &manager->intervals_[0] &&
145            interval <= &manager->intervals_[COST_MANAGER_MAX_FREE_LIST - 1]);
146  }
147  static void CostManagerInitFreeList(CostManager* const manager) {
148    int i;
149    manager->free_intervals_ = NULL;
150    for (i = 0; i < COST_MANAGER_MAX_FREE_LIST; ++i) {
151      CostIntervalAddToFreeList(manager, &manager->intervals_[i]);
152    }
153  }
154  static void DeleteIntervalList(CostManager* const manager,
155                                 const CostInterval* interval) {
156    while (interval != NULL) {
157      const CostInterval* const next = interval->next_;
158      if (!CostIntervalIsInFreeList(manager, interval)) {
159        WebPSafeFree((void*)interval);
160      }  
161      interval = next;
162    }
163  }
164  static void CostManagerClear(CostManager* const manager) {
165    if (manager == NULL) return;
166    WebPSafeFree(manager->costs_);
167    WebPSafeFree(manager->cache_intervals_);
168    DeleteIntervalList(manager, manager->head_);
169    manager->head_ = NULL;
170    DeleteIntervalList(manager, manager->recycled_intervals_);
171    manager->recycled_intervals_ = NULL;
172    memset(manager, 0, sizeof(*manager));
173    CostManagerInitFreeList(manager);
174  }
175  static int CostManagerInit(CostManager* const manager,
176                             uint16_t* const dist_array, int pix_count,
177                             const CostModel* const cost_model) {
178    int i;
179    const int cost_cache_size = (pix_count > MAX_LENGTH) ? MAX_LENGTH : pix_count;
180    manager->costs_ = NULL;
181    manager->cache_intervals_ = NULL;
182    manager->head_ = NULL;
183    manager->recycled_intervals_ = NULL;
184    manager->count_ = 0;
<span onclick='openModal()' class='match'>185    manager->dist_array_ = dist_array;
186    CostManagerInitFreeList(manager);
187    manager->cache_intervals_size_ = 1;
188    manager->cost_cache_[0] = GetLengthCost(cost_model, 0);
</span>189    for (i = 1; i < cost_cache_size; ++i) {
190      manager->cost_cache_[i] = GetLengthCost(cost_model, i);
191      if (manager->cost_cache_[i] != manager->cost_cache_[i - 1]) {
192        ++manager->cache_intervals_size_;
193      }
194    }
195    assert(manager->cache_intervals_size_ <= MAX_LENGTH);
196    manager->cache_intervals_ = (CostCacheInterval*)WebPSafeMalloc(
197        manager->cache_intervals_size_, sizeof(*manager->cache_intervals_));
198    if (manager->cache_intervals_ == NULL) {
199      CostManagerClear(manager);
200      return 0;
201    }
202    {
203      CostCacheInterval* cur = manager->cache_intervals_;
204      cur->start_ = 0;
205      cur->end_ = 1;
206      cur->cost_ = manager->cost_cache_[0];
207      for (i = 1; i < cost_cache_size; ++i) {
208        const double cost_val = manager->cost_cache_[i];
209        if (cost_val != cur->cost_) {
210          ++cur;
211          cur->start_ = i;
212          cur->cost_ = cost_val;
213        }
214        cur->end_ = i + 1;
215      }
216    }
217    manager->costs_ = (float*)WebPSafeMalloc(pix_count, sizeof(*manager->costs_));
218    if (manager->costs_ == NULL) {
219      CostManagerClear(manager);
220      return 0;
221    }
222    for (i = 0; i < pix_count; ++i) manager->costs_[i] = 1e38f;
223    return 1;
224  }
225  static WEBP_INLINE void UpdateCost(CostManager* const manager, int i,
226                                     int position, float cost) {
227    const int k = i - position;
228    assert(k >= 0 && k < MAX_LENGTH);
229    if (manager->costs_[i] > cost) {
230      manager->costs_[i] = cost;
231      manager->dist_array_[i] = k + 1;
232    }
233  }
234  static WEBP_INLINE void UpdateCostPerInterval(CostManager* const manager,
235                                                int start, int end, int position,
236                                                float cost) {
237    int i;
238    for (i = start; i < end; ++i) UpdateCost(manager, i, position, cost);
239  }
240  static WEBP_INLINE void ConnectIntervals(CostManager* const manager,
241                                           CostInterval* const prev,
242                                           CostInterval* const next) {
243    if (prev != NULL) {
244      prev->next_ = next;
245    } else {
246      manager->head_ = next;
247    }
248    if (next != NULL) next->previous_ = prev;
249  }
250  static WEBP_INLINE void PopInterval(CostManager* const manager,
251                                      CostInterval* const interval) {
252    if (interval == NULL) return;
253    ConnectIntervals(manager, interval->previous_, interval->next_);
254    if (CostIntervalIsInFreeList(manager, interval)) {
255      CostIntervalAddToFreeList(manager, interval);
256    } else {  
257      interval->next_ = manager->recycled_intervals_;
258      manager->recycled_intervals_ = interval;
259    }
260    --manager->count_;
261    assert(manager->count_ >= 0);
262  }
263  static WEBP_INLINE void UpdateCostAtIndex(CostManager* const manager, int i,
264                                            int do_clean_intervals) {
265    CostInterval* current = manager->head_;
266    while (current != NULL && current->start_ <= i) {
267      CostInterval* const next = current->next_;
268      if (current->end_ <= i) {
269        if (do_clean_intervals) {
270          PopInterval(manager, current);
271        }
272      } else {
273        UpdateCost(manager, i, current->index_, current->cost_);
274      }
275      current = next;
276    }
277  }
278  static WEBP_INLINE void PositionOrphanInterval(CostManager* const manager,
279                                                 CostInterval* const current,
280                                                 CostInterval* previous) {
281    assert(current != NULL);
282    if (previous == NULL) previous = manager->head_;
283    while (previous != NULL && current->start_ < previous->start_) {
284      previous = previous->previous_;
285    }
286    while (previous != NULL && previous->next_ != NULL &&
287           previous->next_->start_ < current->start_) {
288      previous = previous->next_;
289    }
290    if (previous != NULL) {
291      ConnectIntervals(manager, current, previous->next_);
292    } else {
293      ConnectIntervals(manager, current, manager->head_);
294    }
295    ConnectIntervals(manager, previous, current);
296  }
297  static WEBP_INLINE void InsertInterval(CostManager* const manager,
298                                         CostInterval* const interval_in,
299                                         float cost, int position, int start,
300                                         int end) {
301    CostInterval* interval_new;
302    if (start >= end) return;
303    if (manager->count_ >= COST_CACHE_INTERVAL_SIZE_MAX) {
304      UpdateCostPerInterval(manager, start, end, position, cost);
305      return;
306    }
307    if (manager->free_intervals_ != NULL) {
308      interval_new = manager->free_intervals_;
309      manager->free_intervals_ = interval_new->next_;
310    } else if (manager->recycled_intervals_ != NULL) {
311      interval_new = manager->recycled_intervals_;
312      manager->recycled_intervals_ = interval_new->next_;
313    } else {  
314      interval_new = (CostInterval*)WebPSafeMalloc(1, sizeof(*interval_new));
315      if (interval_new == NULL) {
316        UpdateCostPerInterval(manager, start, end, position, cost);
317        return;
318      }
319    }
320    interval_new->cost_ = cost;
321    interval_new->index_ = position;
322    interval_new->start_ = start;
323    interval_new->end_ = end;
324    PositionOrphanInterval(manager, interval_new, interval_in);
325    ++manager->count_;
326  }
327  static WEBP_INLINE void PushInterval(CostManager* const manager,
328                                       double distance_cost, int position,
329                                       int len) {
330    size_t i;
331    CostInterval* interval = manager->head_;
332    CostInterval* interval_next;
333    const CostCacheInterval* const cost_cache_intervals =
334        manager->cache_intervals_;
335    const int kSkipDistance = 10;
336    if (len < kSkipDistance) {
337      int j;
338      for (j = position; j < position + len; ++j) {
339        const int k = j - position;
340        float cost_tmp;
341        assert(k >= 0 && k < MAX_LENGTH);
342        cost_tmp = (float)(distance_cost + manager->cost_cache_[k]);
343        if (manager->costs_[j] > cost_tmp) {
344          manager->costs_[j] = cost_tmp;
345          manager->dist_array_[j] = k + 1;
346        }
347      }
348      return;
349    }
350    for (i = 0; i < manager->cache_intervals_size_ &&
351                cost_cache_intervals[i].start_ < len;
352         ++i) {
353      int start = position + cost_cache_intervals[i].start_;
354      const int end = position + (cost_cache_intervals[i].end_ > len
355                                   ? len
356                                   : cost_cache_intervals[i].end_);
357      const float cost = (float)(distance_cost + cost_cache_intervals[i].cost_);
358      for (; interval != NULL && interval->start_ < end;
359           interval = interval_next) {
360        interval_next = interval->next_;
361        if (start >= interval->end_) continue;
362        if (cost >= interval->cost_) {
363          const int start_new = interval->end_;
364          InsertInterval(manager, interval, cost, position, start,
365                         interval->start_);
366          start = start_new;
367          if (start >= end) break;
368          continue;
369        }
370        if (start <= interval->start_) {
371          if (interval->end_ <= end) {
372            PopInterval(manager, interval);
373          } else {
374            interval->start_ = end;
375            break;
376          }
377        } else {
378          if (end < interval->end_) {
379            const int end_original = interval->end_;
380            interval->end_ = start;
381            InsertInterval(manager, interval, interval->cost_, interval->index_,
382                           end, end_original);
383            interval = interval->next_;
384            break;
385          } else {
386            interval->end_ = start;
387          }
388        }
389      }
390      InsertInterval(manager, interval, cost, position, start, end);
391    }
392  }
393  static int BackwardReferencesHashChainDistanceOnly(
394      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
395      const VP8LHashChain* const hash_chain, const VP8LBackwardRefs* const refs,
396      uint16_t* const dist_array) {
397    int i;
398    int ok = 0;
399    int cc_init = 0;
400    const int pix_count = xsize * ysize;
401    const int use_color_cache = (cache_bits > 0);
402    const size_t literal_array_size =
403        sizeof(double) * (NUM_LITERAL_CODES + NUM_LENGTH_CODES +
404                          ((cache_bits > 0) ? (1 << cache_bits) : 0));
405    const size_t cost_model_size = sizeof(CostModel) + literal_array_size;
406    CostModel* const cost_model =
407        (CostModel*)WebPSafeCalloc(1ULL, cost_model_size);
408    VP8LColorCache hashers;
409    CostManager* cost_manager =
410        (CostManager*)WebPSafeMalloc(1ULL, sizeof(*cost_manager));
411    int offset_prev = -1, len_prev = -1;
412    double offset_cost = -1;
413    int first_offset_is_constant = -1;  
414    int reach = 0;
415    if (cost_model == NULL || cost_manager == NULL) goto Error;
416    cost_model->literal_ = (double*)(cost_model + 1);
417    if (use_color_cache) {
418      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
419      if (!cc_init) goto Error;
420    }
421    if (!CostModelBuild(cost_model, xsize, cache_bits, refs)) {
422      goto Error;
423    }
424    if (!CostManagerInit(cost_manager, dist_array, pix_count, cost_model)) {
425      goto Error;
426    }
427    dist_array[0] = 0;
428    AddSingleLiteralWithCostModel(argb, &hashers, cost_model, 0, use_color_cache,
429                                  0.f, cost_manager->costs_, dist_array);
430    for (i = 1; i < pix_count; ++i) {
431      const float prev_cost = cost_manager->costs_[i - 1];
432      int offset, len;
433      VP8LHashChainFindCopy(hash_chain, i, &offset, &len);
434      AddSingleLiteralWithCostModel(argb, &hashers, cost_model, i,
435                                    use_color_cache, prev_cost,
436                                    cost_manager->costs_, dist_array);
437      if (len >= 2) {
438        if (offset != offset_prev) {
439          const int code = VP8LDistanceToPlaneCode(xsize, offset);
440          offset_cost = GetDistanceCost(cost_model, code);
441          first_offset_is_constant = 1;
442          PushInterval(cost_manager, prev_cost + offset_cost, i, len);
443        } else {
444          assert(offset_cost >= 0);
445          assert(len_prev >= 0);
446          assert(first_offset_is_constant == 0 || first_offset_is_constant == 1);
447          if (first_offset_is_constant) {
448            reach = i - 1 + len_prev - 1;
449            first_offset_is_constant = 0;
450          }
451          if (i + len - 1 > reach) {
452            int offset_j, len_j = 0;
453            int j;
454            assert(len == MAX_LENGTH || len == pix_count - i);
455            for (j = i; j <= reach; ++j) {
456              VP8LHashChainFindCopy(hash_chain, j + 1, &offset_j, &len_j);
457              if (offset_j != offset) {
458                VP8LHashChainFindCopy(hash_chain, j, &offset_j, &len_j);
459                break;
460              }
461            }
462            UpdateCostAtIndex(cost_manager, j - 1, 0);
463            UpdateCostAtIndex(cost_manager, j, 0);
464            PushInterval(cost_manager, cost_manager->costs_[j - 1] + offset_cost,
465                         j, len_j);
466            reach = j + len_j - 1;
467          }
468        }
469      }
470      UpdateCostAtIndex(cost_manager, i, 1);
471      offset_prev = offset;
472      len_prev = len;
473    }
474    ok = !refs->error_;
475  Error:
476    if (cc_init) VP8LColorCacheClear(&hashers);
477    CostManagerClear(cost_manager);
478    WebPSafeFree(cost_model);
479    WebPSafeFree(cost_manager);
480    return ok;
481  }
482  static void TraceBackwards(uint16_t* const dist_array,
483                             int dist_array_size,
484                             uint16_t** const chosen_path,
485                             int* const chosen_path_size) {
486    uint16_t* path = dist_array + dist_array_size;
487    uint16_t* cur = dist_array + dist_array_size - 1;
488    while (cur >= dist_array) {
489      const int k = *cur;
490      --path;
491      *path = k;
492      cur -= k;
493    }
494    *chosen_path = path;
495    *chosen_path_size = (int)(dist_array + dist_array_size - path);
496  }
497  static int BackwardReferencesHashChainFollowChosenPath(
498      const uint32_t* const argb, int cache_bits,
499      const uint16_t* const chosen_path, int chosen_path_size,
500      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs) {
501    const int use_color_cache = (cache_bits > 0);
502    int ix;
503    int i = 0;
504    int ok = 0;
505    int cc_init = 0;
506    VP8LColorCache hashers;
507    if (use_color_cache) {
508      cc_init = VP8LColorCacheInit(&hashers, cache_bits);
509      if (!cc_init) goto Error;
510    }
511    VP8LClearBackwardRefs(refs);
512    for (ix = 0; ix < chosen_path_size; ++ix) {
513      const int len = chosen_path[ix];
514      if (len != 1) {
515        int k;
516        const int offset = VP8LHashChainFindOffset(hash_chain, i);
517        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(offset, len));
518        if (use_color_cache) {
519          for (k = 0; k < len; ++k) {
520            VP8LColorCacheInsert(&hashers, argb[i + k]);
521          }
522        }
523        i += len;
524      } else {
525        PixOrCopy v;
526        const int idx =
527            use_color_cache ? VP8LColorCacheContains(&hashers, argb[i]) : -1;
528        if (idx >= 0) {
529          v = PixOrCopyCreateCacheIdx(idx);
530        } else {
531          if (use_color_cache) VP8LColorCacheInsert(&hashers, argb[i]);
532          v = PixOrCopyCreateLiteral(argb[i]);
533        }
534        VP8LBackwardRefsCursorAdd(refs, v);
535        ++i;
536      }
537    }
538    ok = !refs->error_;
539   Error:
540    if (cc_init) VP8LColorCacheClear(&hashers);
541    return ok;
542  }
543  extern int VP8LBackwardReferencesTraceBackwards(
544      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
545      const VP8LHashChain* const hash_chain,
546      const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
547  int VP8LBackwardReferencesTraceBackwards(int xsize, int ysize,
548                                           const uint32_t* const argb,
549                                           int cache_bits,
550                                           const VP8LHashChain* const hash_chain,
551                                           const VP8LBackwardRefs* const refs_src,
552                                           VP8LBackwardRefs* const refs_dst) {
553    int ok = 0;
554    const int dist_array_size = xsize * ysize;
555    uint16_t* chosen_path = NULL;
556    int chosen_path_size = 0;
557    uint16_t* dist_array =
558        (uint16_t*)WebPSafeMalloc(dist_array_size, sizeof(*dist_array));
559    if (dist_array == NULL) goto Error;
560    if (!BackwardReferencesHashChainDistanceOnly(
561            xsize, ysize, argb, cache_bits, hash_chain, refs_src, dist_array)) {
562      goto Error;
563    }
564    TraceBackwards(dist_array, dist_array_size, &chosen_path, &chosen_path_size);
565    if (!BackwardReferencesHashChainFollowChosenPath(
566            argb, cache_bits, chosen_path, chosen_path_size, hash_chain,
567            refs_dst)) {
568      goto Error;
569    }
570    ok = 1;
571   Error:
572    WebPSafeFree(dist_array);
573    return ok;
574  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-SFMT_0.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_cost_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>432      ctx->idx = N32;
433      period_certification(ctx);
434      ctx->initialized = 1;
435      return ctx;
</pre></code></div>
                <div class="column column_space"><pre><code>185    manager->dist_array_ = dist_array;
186    CostManagerInitFreeList(manager);
187    manager->cache_intervals_size_ = 1;
188    manager->cost_cache_[0] = GetLengthCost(cost_model, 0);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    