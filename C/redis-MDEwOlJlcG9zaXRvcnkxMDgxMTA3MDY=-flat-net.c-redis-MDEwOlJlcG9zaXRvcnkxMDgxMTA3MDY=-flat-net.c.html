
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 39, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-net.c</h3>
            <pre><code>1  #include "fmacros.h"
2  #include <sys/types.h>
3  #ifndef _WIN32
4  #include <sys/socket.h>
5  #include <sys/select.h>
6  #include <sys/un.h>
7  #include <netinet/in.h>
8  #include <netinet/tcp.h>
9  #include <arpa/inet.h>
10  #include <unistd.h>
11  #include <netdb.h>
12  #endif
13  #include <fcntl.h>
14  #include <string.h>
15  #ifndef _WIN32
16  #include <netdb.h>
17  #endif
18  #include <errno.h>
19  #include <stdarg.h>
20  #include <stdio.h>
21  #ifndef _WIN32
22  #include <poll.h>
23  #endif
24  #include <limits.h>
25  #include "net.h"
26  #include "sds.h"
27  #ifdef _WIN32
28  #include "win32_hiredis.h"
29  #include "mstcpip.h"
30  #endif
31  void __redisSetError(redisContext *c, int type, const char *str);
32  static void redisContextCloseFd(redisContext *c) {
33  	if (c && c->fd >= 0) {
34  		close(c->fd);
35  		c->fd = -1;
36  	}
37  }
38  static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {
39  	char buf[128] = { 0 };
40  	size_t len = 0;
41  	if (prefix != NULL)
42  		len = snprintf(buf, sizeof(buf), "%s: ", prefix);
43  	__redis_strerror_r(errno, (char *)(buf + len), sizeof(buf) - len);
44  	__redisSetError(c, type, buf);
45  }
<span onclick='openModal()' class='match'>46  static int redisSetReuseAddr(redisContext *c) {
47  	int on = 1;
48  	if (setsockopt(c->fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
49  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
</span>50  		redisContextCloseFd(c);
51  		return REDIS_ERR;
52  	}
53  	return REDIS_OK;
54  }
55  static int redisCreateSocket(redisContext *c, int type) {
56  	int s;
57  	if ((s = socket(type, SOCK_STREAM, 0)) == -1) {
58  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
59  		return REDIS_ERR;
60  	}
61  	c->fd = s;
62  	if (type == AF_INET) {
63  		if (redisSetReuseAddr(c) == REDIS_ERR) {
64  			return REDIS_ERR;
65  		}
66  	}
67  	return REDIS_OK;
68  }
69  static int redisSetBlocking(redisContext *c, int blocking) {
70  	int flags;
71  	if ((flags = fcntl(c->fd, F_GETFL, 0)) == -1) {
72  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "fcntl(F_GETFL)");
73  		redisContextCloseFd(c);
74  		return REDIS_ERR;
75  	}
76  	if (blocking)
77  		flags &= ~O_NONBLOCK;
78  	else
79  		flags |= O_NONBLOCK;
80  	if (fcntl(c->fd, F_SETFL, flags) == -1) {
81  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "fcntl(F_SETFL)");
82  		redisContextCloseFd(c);
83  		return REDIS_ERR;
84  	}
85  	return REDIS_OK;
86  }
87  int redisKeepAlive(redisContext *c, int interval) {
88  	int val = 1;
89  	int fd = c->fd;
90  	if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1) {
91  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
92  		return REDIS_ERR;
93  	}
94  	val = interval;
95  #ifdef _OSX
96  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &val, sizeof(val)) < 0) {
97  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
98  		return REDIS_ERR;
99  	}
100  #else
101  #ifndef __sun
102  #ifdef _WIN32
103  	{
104  		struct tcp_keepalive settings;
105  		DWORD bytesReturned;
106  		WSAOVERLAPPED overlapped;
107  		settings.onoff = 1;
108  		settings.keepalivetime = interval * 1000;
109  		settings.keepaliveinterval = interval * 1000 / 3;
110  		overlapped.hEvent = NULL;
111  		FDAPI_WSAIoctl(fd,
112  			SIO_KEEPALIVE_VALS,
113  			&settings,
114  			sizeof(struct tcp_keepalive),
115  			NULL,
116  			0,
117  			&bytesReturned,
118  			&overlapped,
119  			NULL);
120  	}
121  #else
122  	val = interval;
123  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {
124  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
125  		return REDIS_ERR;
126  	}
127  	val = interval / 3;
128  	if (val == 0) val = 1;
129  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &val, sizeof(val)) < 0) {
130  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
131  		return REDIS_ERR;
132  	}
133  	val = 3;
134  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &val, sizeof(val)) < 0) {
135  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
136  		return REDIS_ERR;
137  	}
138  #endif
139  #endif
140  #endif
141  	return REDIS_OK;
142  }
143  static int redisSetTcpNoDelay(redisContext *c) {
144  	int yes = 1;
145  	if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes)) == -1) {
146  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(TCP_NODELAY)");
147  		redisContextCloseFd(c);
148  		return REDIS_ERR;
149  	}
150  	return REDIS_OK;
151  }
152  #define __MAX_MSEC (((LONG_MAX) - 999) / 1000)
153  static int redisContextTimeoutMsec(redisContext *c, PORT_LONG *result)
154  {
155  	const struct timeval *timeout = c->timeout;
156  	PORT_LONG msec = -1;
157  	if (timeout != NULL) {
158  		if (timeout->tv_usec > 1000000 || timeout->tv_sec > __MAX_MSEC) {
159  			*result = msec;
160  			return REDIS_ERR;
161  		}
162  		msec = (timeout->tv_sec * 1000) + ((timeout->tv_usec + 999) / 1000);
163  		if (msec < 0 || msec > INT_MAX) {
164  			msec = INT_MAX;
165  		}
166  	}
167  	*result = msec;
168  	return REDIS_OK;
169  }
170  static int redisContextWaitReady(redisContext *c, PORT_LONG msec) {
171  	struct pollfd   wfd[1];
172  	wfd[0].fd = c->fd;
173  	wfd[0].events = POLLOUT;
174  	if (errno == EINPROGRESS) {
175  		int res;
176  		if ((res = poll(wfd, 1, (int)msec)) == -1) {
177  			WIN_PORT_FIX &bsol;* cast (int) */
178  				__redisSetErrorFromErrno(c, REDIS_ERR_IO, "poll(2)");
179  			redisContextCloseFd(c);
180  			return REDIS_ERR;
181  		}
182  		else if (res == 0) {
183  			errno = ETIMEDOUT;
184  			__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
185  			redisContextCloseFd(c);
186  			return REDIS_ERR;
187  		}
188  		if (redisCheckSocketError(c) != REDIS_OK)
189  			return REDIS_ERR;
190  		return REDIS_OK;
191  	}
192  	__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
193  	redisContextCloseFd(c);
194  	return REDIS_ERR;
195  }
196  int redisCheckSocketError(redisContext *c) {
197  	int err = 0;
198  	socklen_t errlen = sizeof(err);
199  	if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {
200  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "getsockopt(SO_ERROR)");
201  		return REDIS_ERR;
202  	}
203  	if (err) {
204  		errno = err;
205  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
206  		return REDIS_ERR;
207  	}
208  	return REDIS_OK;
209  }
210  int redisContextSetTimeout(redisContext *c, const struct timeval tv) {
211  	if (setsockopt(c->fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
212  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(SO_RCVTIMEO)");
213  		return REDIS_ERR;
214  	}
215  	if (setsockopt(c->fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
216  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(SO_SNDTIMEO)");
217  		return REDIS_ERR;
218  	}
219  	return REDIS_OK;
220  }
221  #ifdef _WIN32
222  int redisContextPreConnectTcp(
223  	redisContext *c,
224  	const char *addr,
225  	int port,
226  	struct timeval *timeout,
227  	SOCKADDR_STORAGE* ss) {
228  	int blocking = (c->flags & REDIS_BLOCK);
229  	if (ParseStorageAddress(addr, port, ss) == FALSE) {
230  		return REDIS_ERR;
231  	}
232  	if (REDIS_OK != redisCreateSocket(c, ss->ss_family)) {
233  		return REDIS_ERR;
234  	}
235  	if (redisSetTcpNoDelay(c) != REDIS_OK)
236  		return REDIS_ERR;
237  	if (blocking == 0) {
238  		if (redisSetBlocking(c, 0) != REDIS_OK)
239  			return REDIS_ERR;
240  	}
241  	return REDIS_OK;
242  }
243  #endif
244  static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
245  	const struct timeval *timeout,
246  	const char *source_addr) {
247  	int s, rv, n;
248  	char _port[6];  &bsol;* strlen("65535"); */
249  	struct addrinfo hints, *servinfo, *bservinfo, *p, *b;
250  	int blocking = (c->flags & REDIS_BLOCK);
251  	int reuseaddr = (c->flags & REDIS_REUSEADDR);
252  	int reuses = 0;
253  	PORT_LONG timeout_msec = -1;
254  	servinfo = NULL;
255  	c->connection_type = REDIS_CONN_TCP;
256  	c->tcp.port = port;
257  	if (c->tcp.host != addr) {
258  		if (c->tcp.host)
259  			free(c->tcp.host);
260  		c->tcp.host = strdup(addr);
261  	}
262  	if (timeout) {
263  		if (c->timeout != timeout) {
264  			if (c->timeout == NULL)
265  				c->timeout = malloc(sizeof(struct timeval));
266  			memcpy(c->timeout, timeout, sizeof(struct timeval));
267  		}
268  	}
269  	else {
270  		if (c->timeout)
271  			free(c->timeout);
272  		c->timeout = NULL;
273  	}
274  	if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) {
275  		__redisSetError(c, REDIS_ERR_IO, "Invalid timeout specified");
276  		goto error;
277  	}
278  	if (source_addr == NULL) {
279  		free(c->tcp.source_addr);
280  		c->tcp.source_addr = NULL;
281  	}
282  	else if (c->tcp.source_addr != source_addr) {
283  		free(c->tcp.source_addr);
284  		c->tcp.source_addr = strdup(source_addr);
285  	}
286  	snprintf(_port, 6, "%d", port);
287  	memset(&hints, 0, sizeof(hints));
288  	hints.ai_family = AF_INET;
289  	hints.ai_socktype = SOCK_STREAM;
290  	if ((rv = getaddrinfo(c->tcp.host, _port, &hints, &servinfo)) != 0) {
291  		hints.ai_family = AF_INET6;
292  		if ((rv = getaddrinfo(addr, _port, &hints, &servinfo)) != 0) {
293  			__redisSetError(c, REDIS_ERR_OTHER, gai_strerror(rv));
294  			return REDIS_ERR;
295  		}
296  	}
297  	for (p = servinfo; p != NULL; p = p->ai_next) {
298  	addrretry:
299  		if ((s = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1)
300  			continue;
301  		c->fd = s;
302  		if (redisSetBlocking(c, 0) != REDIS_OK)
303  			goto error;
304  		if (c->tcp.source_addr) {
305  			int bound = 0;
306  			if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {
307  				char buf[128];
308  				snprintf(buf, sizeof(buf), "Can't get addr: %s", gai_strerror(rv));
309  				__redisSetError(c, REDIS_ERR_OTHER, buf);
310  				goto error;
311  			}
312  			if (reuseaddr) {
313  				n = 1;
314  				if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*)&n,
315  					sizeof(n)) < 0) {
316  					goto error;
317  				}
318  			}
319  			for (b = bservinfo; b != NULL; b = b->ai_next) {
320  				if (bind(s, b->ai_addr, b->ai_addrlen) != -1) {
321  					bound = 1;
322  					break;
323  				}
324  			}
325  			freeaddrinfo(bservinfo);
326  			if (!bound) {
327  				char buf[128];
328  				snprintf(buf, sizeof(buf), "Can't bind socket: %s", strerror(errno));
329  				__redisSetError(c, REDIS_ERR_OTHER, buf);
330  				goto error;
331  			}
332  		}
333  		if (connect(s, p->ai_addr, p->ai_addrlen) == -1) {
334  			if (errno == EHOSTUNREACH) {
335  				redisContextCloseFd(c);
336  				continue;
337  			}
338  			else if (errno == EINPROGRESS && !blocking) {
339  			}
340  			else if (errno == EADDRNOTAVAIL && reuseaddr) {
341  				if (++reuses >= REDIS_CONNECT_RETRIES) {
342  					goto error;
343  				}
344  				else {
345  					redisContextCloseFd(c);
346  					goto addrretry;
347  				}
348  			}
349  			else {
350  				if (redisContextWaitReady(c, timeout_msec) != REDIS_OK)
351  					goto error;
352  			}
353  		}
354  		if (blocking && redisSetBlocking(c, 1) != REDIS_OK)
355  			goto error;
356  		if (redisSetTcpNoDelay(c) != REDIS_OK)
357  			goto error;
358  		c->flags |= REDIS_CONNECTED;
359  		rv = REDIS_OK;
360  		goto end;
361  	}
362  	if (p == NULL) {
363  		char buf[128];
364  		snprintf(buf, sizeof(buf), "Can't create socket: %s", strerror(errno));
365  		__redisSetError(c, REDIS_ERR_OTHER, buf);
366  		goto error;
367  	}
368  error:
369  	rv = REDIS_ERR;
370  end:
371  	freeaddrinfo(servinfo);
372  	return rv;  
373  }
374  int redisContextConnectTcp(redisContext *c, const char *addr, int port,
375  	const struct timeval *timeout) {
376  	return _redisContextConnectTcp(c, addr, port, timeout, NULL);
377  }
378  int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,
379  	const struct timeval *timeout,
380  	const char *source_addr) {
381  	return _redisContextConnectTcp(c, addr, port, timeout, source_addr);
382  }
383  #ifdef _WIN32
384  int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {
385  	(void)timeout;
386  	__redisSetError(c, REDIS_ERR_IO,
387  		sdscatprintf(sdsempty(), "Unix sockets are not suported on Windows platform. (%s)\n", path));
388  	return REDIS_ERR;
389  }
390  #else
391  int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {
392  	int blocking = (c->flags & REDIS_BLOCK);
393  	struct sockaddr_un sa;
394  	PORT_LONG timeout_msec = -1;
395  	if (redisCreateSocket(c, AF_LOCAL) < 0)
396  		return REDIS_ERR;
397  	if (redisSetBlocking(c, 0) != REDIS_OK)
398  		return REDIS_ERR;
399  	c->connection_type = REDIS_CONN_UNIX;
400  	if (c->unix_sock.path != path)
401  		c->unix_sock.path = strdup(path);
402  	if (timeout) {
403  		if (c->timeout != timeout) {
404  			if (c->timeout == NULL)
405  				c->timeout = malloc(sizeof(struct timeval));
406  			memcpy(c->timeout, timeout, sizeof(struct timeval));
407  		}
408  	}
409  	else {
410  		if (c->timeout)
411  			free(c->timeout);
412  		c->timeout = NULL;
413  	}
414  	if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK)
415  		return REDIS_ERR;
416  	sa.sun_family = AF_LOCAL;
417  	strncpy(sa.sun_path, path, sizeof(sa.sun_path) - 1);
418  	if (connect(c->fd, (struct sockaddr*)&sa, sizeof(sa)) == -1) {
419  		if (errno == EINPROGRESS && !blocking) {
420  		}
421  		else {
422  			if (redisContextWaitReady(c, timeout_msec) != REDIS_OK)
423  				return REDIS_ERR;
424  		}
425  	}
426  	if (blocking && redisSetBlocking(c, 1) != REDIS_OK)
427  		return REDIS_ERR;
428  	c->flags |= REDIS_CONNECTED;
429  	return REDIS_OK;
430  }
431  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-net.c</h3>
            <pre><code>1  #include "fmacros.h"
2  #include <sys/types.h>
3  #ifndef _WIN32
4  #include <sys/socket.h>
5  #include <sys/select.h>
6  #include <sys/un.h>
7  #include <netinet/in.h>
8  #include <netinet/tcp.h>
9  #include <arpa/inet.h>
10  #include <unistd.h>
11  #include <netdb.h>
12  #endif
13  #include <fcntl.h>
14  #include <string.h>
15  #ifndef _WIN32
16  #include <netdb.h>
17  #endif
18  #include <errno.h>
19  #include <stdarg.h>
20  #include <stdio.h>
21  #ifndef _WIN32
22  #include <poll.h>
23  #endif
24  #include <limits.h>
25  #include "net.h"
26  #include "sds.h"
27  #ifdef _WIN32
28  #include "win32_hiredis.h"
29  #include "mstcpip.h"
30  #endif
31  void __redisSetError(redisContext *c, int type, const char *str);
32  static void redisContextCloseFd(redisContext *c) {
33  	if (c && c->fd >= 0) {
34  		close(c->fd);
35  		c->fd = -1;
36  	}
37  }
38  static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {
39  	char buf[128] = { 0 };
40  	size_t len = 0;
41  	if (prefix != NULL)
42  		len = snprintf(buf, sizeof(buf), "%s: ", prefix);
43  	__redis_strerror_r(errno, (char *)(buf + len), sizeof(buf) - len);
44  	__redisSetError(c, type, buf);
45  }
46  static int redisSetReuseAddr(redisContext *c) {
47  	int on = 1;
48  	if (setsockopt(c->fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
49  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
50  		redisContextCloseFd(c);
51  		return REDIS_ERR;
52  	}
53  	return REDIS_OK;
54  }
55  static int redisCreateSocket(redisContext *c, int type) {
56  	int s;
57  	if ((s = socket(type, SOCK_STREAM, 0)) == -1) {
58  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
59  		return REDIS_ERR;
60  	}
61  	c->fd = s;
62  	if (type == AF_INET) {
63  		if (redisSetReuseAddr(c) == REDIS_ERR) {
64  			return REDIS_ERR;
65  		}
66  	}
67  	return REDIS_OK;
68  }
69  static int redisSetBlocking(redisContext *c, int blocking) {
70  	int flags;
71  	if ((flags = fcntl(c->fd, F_GETFL, 0)) == -1) {
72  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "fcntl(F_GETFL)");
73  		redisContextCloseFd(c);
74  		return REDIS_ERR;
75  	}
76  	if (blocking)
77  		flags &= ~O_NONBLOCK;
78  	else
79  		flags |= O_NONBLOCK;
80  	if (fcntl(c->fd, F_SETFL, flags) == -1) {
81  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "fcntl(F_SETFL)");
82  		redisContextCloseFd(c);
83  		return REDIS_ERR;
84  	}
85  	return REDIS_OK;
86  }
87  int redisKeepAlive(redisContext *c, int interval) {
88  	int val = 1;
89  	int fd = c->fd;
90  	if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1) {
91  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
92  		return REDIS_ERR;
93  	}
94  	val = interval;
95  #ifdef _OSX
96  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &val, sizeof(val)) < 0) {
97  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
98  		return REDIS_ERR;
99  	}
100  #else
101  #ifndef __sun
102  #ifdef _WIN32
103  	{
104  		struct tcp_keepalive settings;
105  		DWORD bytesReturned;
106  		WSAOVERLAPPED overlapped;
107  		settings.onoff = 1;
108  		settings.keepalivetime = interval * 1000;
109  		settings.keepaliveinterval = interval * 1000 / 3;
110  		overlapped.hEvent = NULL;
111  		FDAPI_WSAIoctl(fd,
112  			SIO_KEEPALIVE_VALS,
113  			&settings,
114  			sizeof(struct tcp_keepalive),
115  			NULL,
116  			0,
117  			&bytesReturned,
118  			&overlapped,
119  			NULL);
120  	}
121  #else
122  	val = interval;
123  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {
124  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
125  		return REDIS_ERR;
126  	}
127  	val = interval / 3;
128  	if (val == 0) val = 1;
129  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &val, sizeof(val)) < 0) {
130  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
131  		return REDIS_ERR;
132  	}
133  	val = 3;
134  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &val, sizeof(val)) < 0) {
135  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
136  		return REDIS_ERR;
137  	}
138  #endif
139  #endif
140  #endif
141  	return REDIS_OK;
142  }
<span onclick='openModal()' class='match'>143  static int redisSetTcpNoDelay(redisContext *c) {
144  	int yes = 1;
145  	if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes)) == -1) {
146  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(TCP_NODELAY)");
</span>147  		redisContextCloseFd(c);
148  		return REDIS_ERR;
149  	}
150  	return REDIS_OK;
151  }
152  #define __MAX_MSEC (((LONG_MAX) - 999) / 1000)
153  static int redisContextTimeoutMsec(redisContext *c, PORT_LONG *result)
154  {
155  	const struct timeval *timeout = c->timeout;
156  	PORT_LONG msec = -1;
157  	if (timeout != NULL) {
158  		if (timeout->tv_usec > 1000000 || timeout->tv_sec > __MAX_MSEC) {
159  			*result = msec;
160  			return REDIS_ERR;
161  		}
162  		msec = (timeout->tv_sec * 1000) + ((timeout->tv_usec + 999) / 1000);
163  		if (msec < 0 || msec > INT_MAX) {
164  			msec = INT_MAX;
165  		}
166  	}
167  	*result = msec;
168  	return REDIS_OK;
169  }
170  static int redisContextWaitReady(redisContext *c, PORT_LONG msec) {
171  	struct pollfd   wfd[1];
172  	wfd[0].fd = c->fd;
173  	wfd[0].events = POLLOUT;
174  	if (errno == EINPROGRESS) {
175  		int res;
176  		if ((res = poll(wfd, 1, (int)msec)) == -1) {
177  			WIN_PORT_FIX &bsol;* cast (int) */
178  				__redisSetErrorFromErrno(c, REDIS_ERR_IO, "poll(2)");
179  			redisContextCloseFd(c);
180  			return REDIS_ERR;
181  		}
182  		else if (res == 0) {
183  			errno = ETIMEDOUT;
184  			__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
185  			redisContextCloseFd(c);
186  			return REDIS_ERR;
187  		}
188  		if (redisCheckSocketError(c) != REDIS_OK)
189  			return REDIS_ERR;
190  		return REDIS_OK;
191  	}
192  	__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
193  	redisContextCloseFd(c);
194  	return REDIS_ERR;
195  }
196  int redisCheckSocketError(redisContext *c) {
197  	int err = 0;
198  	socklen_t errlen = sizeof(err);
199  	if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {
200  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "getsockopt(SO_ERROR)");
201  		return REDIS_ERR;
202  	}
203  	if (err) {
204  		errno = err;
205  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
206  		return REDIS_ERR;
207  	}
208  	return REDIS_OK;
209  }
210  int redisContextSetTimeout(redisContext *c, const struct timeval tv) {
211  	if (setsockopt(c->fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
212  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(SO_RCVTIMEO)");
213  		return REDIS_ERR;
214  	}
215  	if (setsockopt(c->fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
216  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(SO_SNDTIMEO)");
217  		return REDIS_ERR;
218  	}
219  	return REDIS_OK;
220  }
221  #ifdef _WIN32
222  int redisContextPreConnectTcp(
223  	redisContext *c,
224  	const char *addr,
225  	int port,
226  	struct timeval *timeout,
227  	SOCKADDR_STORAGE* ss) {
228  	int blocking = (c->flags & REDIS_BLOCK);
229  	if (ParseStorageAddress(addr, port, ss) == FALSE) {
230  		return REDIS_ERR;
231  	}
232  	if (REDIS_OK != redisCreateSocket(c, ss->ss_family)) {
233  		return REDIS_ERR;
234  	}
235  	if (redisSetTcpNoDelay(c) != REDIS_OK)
236  		return REDIS_ERR;
237  	if (blocking == 0) {
238  		if (redisSetBlocking(c, 0) != REDIS_OK)
239  			return REDIS_ERR;
240  	}
241  	return REDIS_OK;
242  }
243  #endif
244  static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
245  	const struct timeval *timeout,
246  	const char *source_addr) {
247  	int s, rv, n;
248  	char _port[6];  &bsol;* strlen("65535"); */
249  	struct addrinfo hints, *servinfo, *bservinfo, *p, *b;
250  	int blocking = (c->flags & REDIS_BLOCK);
251  	int reuseaddr = (c->flags & REDIS_REUSEADDR);
252  	int reuses = 0;
253  	PORT_LONG timeout_msec = -1;
254  	servinfo = NULL;
255  	c->connection_type = REDIS_CONN_TCP;
256  	c->tcp.port = port;
257  	if (c->tcp.host != addr) {
258  		if (c->tcp.host)
259  			free(c->tcp.host);
260  		c->tcp.host = strdup(addr);
261  	}
262  	if (timeout) {
263  		if (c->timeout != timeout) {
264  			if (c->timeout == NULL)
265  				c->timeout = malloc(sizeof(struct timeval));
266  			memcpy(c->timeout, timeout, sizeof(struct timeval));
267  		}
268  	}
269  	else {
270  		if (c->timeout)
271  			free(c->timeout);
272  		c->timeout = NULL;
273  	}
274  	if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) {
275  		__redisSetError(c, REDIS_ERR_IO, "Invalid timeout specified");
276  		goto error;
277  	}
278  	if (source_addr == NULL) {
279  		free(c->tcp.source_addr);
280  		c->tcp.source_addr = NULL;
281  	}
282  	else if (c->tcp.source_addr != source_addr) {
283  		free(c->tcp.source_addr);
284  		c->tcp.source_addr = strdup(source_addr);
285  	}
286  	snprintf(_port, 6, "%d", port);
287  	memset(&hints, 0, sizeof(hints));
288  	hints.ai_family = AF_INET;
289  	hints.ai_socktype = SOCK_STREAM;
290  	if ((rv = getaddrinfo(c->tcp.host, _port, &hints, &servinfo)) != 0) {
291  		hints.ai_family = AF_INET6;
292  		if ((rv = getaddrinfo(addr, _port, &hints, &servinfo)) != 0) {
293  			__redisSetError(c, REDIS_ERR_OTHER, gai_strerror(rv));
294  			return REDIS_ERR;
295  		}
296  	}
297  	for (p = servinfo; p != NULL; p = p->ai_next) {
298  	addrretry:
299  		if ((s = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1)
300  			continue;
301  		c->fd = s;
302  		if (redisSetBlocking(c, 0) != REDIS_OK)
303  			goto error;
304  		if (c->tcp.source_addr) {
305  			int bound = 0;
306  			if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {
307  				char buf[128];
308  				snprintf(buf, sizeof(buf), "Can't get addr: %s", gai_strerror(rv));
309  				__redisSetError(c, REDIS_ERR_OTHER, buf);
310  				goto error;
311  			}
312  			if (reuseaddr) {
313  				n = 1;
314  				if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*)&n,
315  					sizeof(n)) < 0) {
316  					goto error;
317  				}
318  			}
319  			for (b = bservinfo; b != NULL; b = b->ai_next) {
320  				if (bind(s, b->ai_addr, b->ai_addrlen) != -1) {
321  					bound = 1;
322  					break;
323  				}
324  			}
325  			freeaddrinfo(bservinfo);
326  			if (!bound) {
327  				char buf[128];
328  				snprintf(buf, sizeof(buf), "Can't bind socket: %s", strerror(errno));
329  				__redisSetError(c, REDIS_ERR_OTHER, buf);
330  				goto error;
331  			}
332  		}
333  		if (connect(s, p->ai_addr, p->ai_addrlen) == -1) {
334  			if (errno == EHOSTUNREACH) {
335  				redisContextCloseFd(c);
336  				continue;
337  			}
338  			else if (errno == EINPROGRESS && !blocking) {
339  			}
340  			else if (errno == EADDRNOTAVAIL && reuseaddr) {
341  				if (++reuses >= REDIS_CONNECT_RETRIES) {
342  					goto error;
343  				}
344  				else {
345  					redisContextCloseFd(c);
346  					goto addrretry;
347  				}
348  			}
349  			else {
350  				if (redisContextWaitReady(c, timeout_msec) != REDIS_OK)
351  					goto error;
352  			}
353  		}
354  		if (blocking && redisSetBlocking(c, 1) != REDIS_OK)
355  			goto error;
356  		if (redisSetTcpNoDelay(c) != REDIS_OK)
357  			goto error;
358  		c->flags |= REDIS_CONNECTED;
359  		rv = REDIS_OK;
360  		goto end;
361  	}
362  	if (p == NULL) {
363  		char buf[128];
364  		snprintf(buf, sizeof(buf), "Can't create socket: %s", strerror(errno));
365  		__redisSetError(c, REDIS_ERR_OTHER, buf);
366  		goto error;
367  	}
368  error:
369  	rv = REDIS_ERR;
370  end:
371  	freeaddrinfo(servinfo);
372  	return rv;  
373  }
374  int redisContextConnectTcp(redisContext *c, const char *addr, int port,
375  	const struct timeval *timeout) {
376  	return _redisContextConnectTcp(c, addr, port, timeout, NULL);
377  }
378  int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,
379  	const struct timeval *timeout,
380  	const char *source_addr) {
381  	return _redisContextConnectTcp(c, addr, port, timeout, source_addr);
382  }
383  #ifdef _WIN32
384  int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {
385  	(void)timeout;
386  	__redisSetError(c, REDIS_ERR_IO,
387  		sdscatprintf(sdsempty(), "Unix sockets are not suported on Windows platform. (%s)\n", path));
388  	return REDIS_ERR;
389  }
390  #else
391  int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {
392  	int blocking = (c->flags & REDIS_BLOCK);
393  	struct sockaddr_un sa;
394  	PORT_LONG timeout_msec = -1;
395  	if (redisCreateSocket(c, AF_LOCAL) < 0)
396  		return REDIS_ERR;
397  	if (redisSetBlocking(c, 0) != REDIS_OK)
398  		return REDIS_ERR;
399  	c->connection_type = REDIS_CONN_UNIX;
400  	if (c->unix_sock.path != path)
401  		c->unix_sock.path = strdup(path);
402  	if (timeout) {
403  		if (c->timeout != timeout) {
404  			if (c->timeout == NULL)
405  				c->timeout = malloc(sizeof(struct timeval));
406  			memcpy(c->timeout, timeout, sizeof(struct timeval));
407  		}
408  	}
409  	else {
410  		if (c->timeout)
411  			free(c->timeout);
412  		c->timeout = NULL;
413  	}
414  	if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK)
415  		return REDIS_ERR;
416  	sa.sun_family = AF_LOCAL;
417  	strncpy(sa.sun_path, path, sizeof(sa.sun_path) - 1);
418  	if (connect(c->fd, (struct sockaddr*)&sa, sizeof(sa)) == -1) {
419  		if (errno == EINPROGRESS && !blocking) {
420  		}
421  		else {
422  			if (redisContextWaitReady(c, timeout_msec) != REDIS_OK)
423  				return REDIS_ERR;
424  		}
425  	}
426  	if (blocking && redisSetBlocking(c, 1) != REDIS_OK)
427  		return REDIS_ERR;
428  	c->flags |= REDIS_CONNECTED;
429  	return REDIS_OK;
430  }
431  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-net.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-net.c</div>
                </div>
                <div class="column column_space"><pre><code>46  static int redisSetReuseAddr(redisContext *c) {
47  	int on = 1;
48  	if (setsockopt(c->fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
49  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
</pre></code></div>
                <div class="column column_space"><pre><code>143  static int redisSetTcpNoDelay(redisContext *c) {
144  	int yes = 1;
145  	if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes)) == -1) {
146  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(TCP_NODELAY)");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    