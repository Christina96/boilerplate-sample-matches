
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-skipjack.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SKIPJACK
3  const struct ltc_cipher_descriptor skipjack_desc =
4  {
5      "skipjack",
6      17,
7      10, 10, 8, 32,
8      &skipjack_setup,
9      &skipjack_ecb_encrypt,
10      &skipjack_ecb_decrypt,
11      &skipjack_test,
12      &skipjack_done,
13      &skipjack_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  static const unsigned char sbox[256] = {
17     0xa3,0xd7,0x09,0x83,0xf8,0x48,0xf6,0xf4,0xb3,0x21,0x15,0x78,0x99,0xb1,0xaf,0xf9,
18     0xe7,0x2d,0x4d,0x8a,0xce,0x4c,0xca,0x2e,0x52,0x95,0xd9,0x1e,0x4e,0x38,0x44,0x28,
19     0x0a,0xdf,0x02,0xa0,0x17,0xf1,0x60,0x68,0x12,0xb7,0x7a,0xc3,0xe9,0xfa,0x3d,0x53,
20     0x96,0x84,0x6b,0xba,0xf2,0x63,0x9a,0x19,0x7c,0xae,0xe5,0xf5,0xf7,0x16,0x6a,0xa2,
21     0x39,0xb6,0x7b,0x0f,0xc1,0x93,0x81,0x1b,0xee,0xb4,0x1a,0xea,0xd0,0x91,0x2f,0xb8,
22     0x55,0xb9,0xda,0x85,0x3f,0x41,0xbf,0xe0,0x5a,0x58,0x80,0x5f,0x66,0x0b,0xd8,0x90,
23     0x35,0xd5,0xc0,0xa7,0x33,0x06,0x65,0x69,0x45,0x00,0x94,0x56,0x6d,0x98,0x9b,0x76,
24     0x97,0xfc,0xb2,0xc2,0xb0,0xfe,0xdb,0x20,0xe1,0xeb,0xd6,0xe4,0xdd,0x47,0x4a,0x1d,
25     0x42,0xed,0x9e,0x6e,0x49,0x3c,0xcd,0x43,0x27,0xd2,0x07,0xd4,0xde,0xc7,0x67,0x18,
26     0x89,0xcb,0x30,0x1f,0x8d,0xc6,0x8f,0xaa,0xc8,0x74,0xdc,0xc9,0x5d,0x5c,0x31,0xa4,
27     0x70,0x88,0x61,0x2c,0x9f,0x0d,0x2b,0x87,0x50,0x82,0x54,0x64,0x26,0x7d,0x03,0x40,
28     0x34,0x4b,0x1c,0x73,0xd1,0xc4,0xfd,0x3b,0xcc,0xfb,0x7f,0xab,0xe6,0x3e,0x5b,0xa5,
29     0xad,0x04,0x23,0x9c,0x14,0x51,0x22,0xf0,0x29,0x79,0x71,0x7e,0xff,0x8c,0x0e,0xe2,
30     0x0c,0xef,0xbc,0x72,0x75,0x6f,0x37,0xa1,0xec,0xd3,0x8e,0x62,0x8b,0x86,0x10,0xe8,
31     0x08,0x77,0x11,0xbe,0x92,0x4f,0x24,0xc5,0x32,0x36,0x9d,0xcf,0xf3,0xa6,0xbb,0xac,
32     0x5e,0x6c,0xa9,0x13,0x57,0x25,0xb5,0xe3,0xbd,0xa8,0x3a,0x01,0x05,0x59,0x2a,0x46
33  };
34  static const int keystep[] =  { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
35  static const int ikeystep[] = { 9, 0, 1, 2, 3, 4, 5, 6, 7, 8 };
36  int skipjack_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
37  {
38     int x;
39     LTC_ARGCHK(key  != NULL);
40     LTC_ARGCHK(skey != NULL);
41     if (keylen != 10) {
42        return CRYPT_INVALID_KEYSIZE;
43     }
44     if (num_rounds != 32 && num_rounds != 0) {
45        return CRYPT_INVALID_ROUNDS;
46     }
47     for (x = 0; x < 10; x++) {
48         skey->skipjack.key[x] = key[x] & 255;
49     }
50     return CRYPT_OK;
51  }
52  #define RULE_A \
53     tmp = g_func(w1, &kp, skey->skipjack.key);      \
54     w1  = tmp ^ w4 ^ x;                            \
55     w4  = w3; w3 = w2;                             \
56     w2  = tmp;
57  #define RULE_B \
58     tmp  = g_func(w1, &kp, skey->skipjack.key);     \
59     tmp1 = w4; w4  = w3;                           \
60     w3   = w1 ^ w2 ^ x;                            \
61     w1   = tmp1; w2 = tmp;
62  #define RULE_A1 \
63     tmp = w1 ^ w2 ^ x;                             \
64     w1  = ig_func(w2, &kp, skey->skipjack.key);     \
65     w2  = w3; w3 = w4; w4 = tmp;
66  #define RULE_B1 \
67     tmp = ig_func(w2, &kp, skey->skipjack.key);     \
68     w2  = tmp ^ w3 ^ x;                            \
69     w3  = w4; w4 = w1; w1 = tmp;
70  static unsigned g_func(unsigned w, int *kp, const unsigned char *key)
71  {
72     unsigned char g1,g2;
73     g1 = (w >> 8) & 255; g2 = w & 255;
74     g1 ^= sbox[g2^key[*kp]]; *kp = keystep[*kp];
75     g2 ^= sbox[g1^key[*kp]]; *kp = keystep[*kp];
76     g1 ^= sbox[g2^key[*kp]]; *kp = keystep[*kp];
77     g2 ^= sbox[g1^key[*kp]]; *kp = keystep[*kp];
78     return ((unsigned)g1<<8)|(unsigned)g2;
79  }
80  static unsigned ig_func(unsigned w, int *kp, const unsigned char *key)
81  {
82     unsigned char g1,g2;
83     g1 = (w >> 8) & 255; g2 = w & 255;
84     *kp = ikeystep[*kp]; g2 ^= sbox[g1^key[*kp]];
85     *kp = ikeystep[*kp]; g1 ^= sbox[g2^key[*kp]];
86     *kp = ikeystep[*kp]; g2 ^= sbox[g1^key[*kp]];
87     *kp = ikeystep[*kp]; g1 ^= sbox[g2^key[*kp]];
88     return ((unsigned)g1<<8)|(unsigned)g2;
89  }
90  #ifdef LTC_CLEAN_STACK
91  static int s_skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
92  #else
93  int skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
94  #endif
95  {
96     unsigned w1,w2,w3,w4,tmp,tmp1;
97     int x, kp;
98     LTC_ARGCHK(pt   != NULL);
99     LTC_ARGCHK(ct   != NULL);
100     LTC_ARGCHK(skey != NULL);
101     w1 = ((unsigned)pt[0]<<8)|pt[1];
102     w2 = ((unsigned)pt[2]<<8)|pt[3];
103     w3 = ((unsigned)pt[4]<<8)|pt[5];
104     w4 = ((unsigned)pt[6]<<8)|pt[7];
105     for (x = 1, kp = 0; x < 9; x++) {
106         RULE_A;
107     }
108     for (; x < 17; x++) {
109         RULE_B;
110     }
111     for (; x < 25; x++) {
<span onclick='openModal()' class='match'>112         RULE_A;
113     }
114     for (; x < 33; x++) {
115         RULE_B;
116     }
117     ct[0] = (w1>>8)&255; ct[1] = w1&255;
</span>118     ct[2] = (w2>>8)&255; ct[3] = w2&255;
119     ct[4] = (w3>>8)&255; ct[5] = w3&255;
120     ct[6] = (w4>>8)&255; ct[7] = w4&255;
121     return CRYPT_OK;
122  }
123  #ifdef LTC_CLEAN_STACK
124  int skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
125  {
126     int err = s_skipjack_ecb_encrypt(pt, ct, skey);
127     burn_stack(sizeof(unsigned) * 8 + sizeof(int) * 2);
128     return err;
129  }
130  #endif
131  #ifdef LTC_CLEAN_STACK
132  static int s_skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
133  #else
134  int skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
135  #endif
136  {
137     unsigned w1,w2,w3,w4,tmp;
138     int x, kp;
139     LTC_ARGCHK(pt   != NULL);
140     LTC_ARGCHK(ct   != NULL);
141     LTC_ARGCHK(skey != NULL);
142     w1 = ((unsigned)ct[0]<<8)|ct[1];
143     w2 = ((unsigned)ct[2]<<8)|ct[3];
144     w3 = ((unsigned)ct[4]<<8)|ct[5];
145     w4 = ((unsigned)ct[6]<<8)|ct[7];
146     for (x = 32, kp = 8; x > 24; x--) {
147         RULE_B1;
148     }
149     for (; x > 16; x--) {
150         RULE_A1;
151     }
152     for (; x > 8; x--) {
153         RULE_B1;
154     }
155     for (; x > 0; x--) {
156         RULE_A1;
157     }
158     pt[0] = (w1>>8)&255; pt[1] = w1&255;
159     pt[2] = (w2>>8)&255; pt[3] = w2&255;
160     pt[4] = (w3>>8)&255; pt[5] = w3&255;
161     pt[6] = (w4>>8)&255; pt[7] = w4&255;
162     return CRYPT_OK;
163  }
164  #ifdef LTC_CLEAN_STACK
165  int skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
166  {
167     int err = s_skipjack_ecb_decrypt(ct, pt, skey);
168     burn_stack(sizeof(unsigned) * 7 + sizeof(int) * 2);
169     return err;
170  }
171  #endif
172  int skipjack_test(void)
173  {
174   #ifndef LTC_TEST
175      return CRYPT_NOP;
176   #else
177     static const struct {
178         unsigned char key[10], pt[8], ct[8];
179     } tests[] = {
180     {
181         { 0x00, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11 },
182         { 0x33, 0x22, 0x11, 0x00, 0xdd, 0xcc, 0xbb, 0xaa },
183         { 0x25, 0x87, 0xca, 0xe2, 0x7a, 0x12, 0xd3, 0x00 }
184     }
185     };
186     unsigned char buf[2][8];
187     int x, y, err;
188     symmetric_key key;
189     for (x = 0; x < (int)(sizeof(tests) / sizeof(tests[0])); x++) {
190        if ((err = skipjack_setup(tests[x].key, 10, 0, &key)) != CRYPT_OK) {
191           return err;
192        }
193        skipjack_ecb_encrypt(tests[x].pt, buf[0], &key);
194        skipjack_ecb_decrypt(buf[0], buf[1], &key);
195        if (compare_testvector(buf[0], 8, tests[x].ct, 8, "Skipjack Encrypt", x) != 0 ||
196              compare_testvector(buf[1], 8, tests[x].pt, 8, "Skipjack Decrypt", x) != 0) {
197           return CRYPT_FAIL_TESTVECTOR;
198        }
199        for (y = 0; y < 8; y++) buf[0][y] = 0;
200        for (y = 0; y < 1000; y++) skipjack_ecb_encrypt(buf[0], buf[0], &key);
201        for (y = 0; y < 1000; y++) skipjack_ecb_decrypt(buf[0], buf[0], &key);
202        for (y = 0; y < 8; y++) if (buf[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
203     }
204     return CRYPT_OK;
205    #endif
206  }
207  void skipjack_done(symmetric_key *skey)
208  {
209    LTC_UNUSED_PARAM(skey);
210  }
211  int skipjack_keysize(int *keysize)
212  {
213     LTC_ARGCHK(keysize != NULL);
214     if (*keysize < 10) {
215        return CRYPT_INVALID_KEYSIZE;
216     }
217     if (*keysize > 10) {
218        *keysize = 10;
219     }
220     return CRYPT_OK;
221  }
222  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-skipjack.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SKIPJACK
3  const struct ltc_cipher_descriptor skipjack_desc =
4  {
5      "skipjack",
6      17,
7      10, 10, 8, 32,
8      &skipjack_setup,
9      &skipjack_ecb_encrypt,
10      &skipjack_ecb_decrypt,
11      &skipjack_test,
12      &skipjack_done,
13      &skipjack_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  static const unsigned char sbox[256] = {
17     0xa3,0xd7,0x09,0x83,0xf8,0x48,0xf6,0xf4,0xb3,0x21,0x15,0x78,0x99,0xb1,0xaf,0xf9,
18     0xe7,0x2d,0x4d,0x8a,0xce,0x4c,0xca,0x2e,0x52,0x95,0xd9,0x1e,0x4e,0x38,0x44,0x28,
19     0x0a,0xdf,0x02,0xa0,0x17,0xf1,0x60,0x68,0x12,0xb7,0x7a,0xc3,0xe9,0xfa,0x3d,0x53,
20     0x96,0x84,0x6b,0xba,0xf2,0x63,0x9a,0x19,0x7c,0xae,0xe5,0xf5,0xf7,0x16,0x6a,0xa2,
21     0x39,0xb6,0x7b,0x0f,0xc1,0x93,0x81,0x1b,0xee,0xb4,0x1a,0xea,0xd0,0x91,0x2f,0xb8,
22     0x55,0xb9,0xda,0x85,0x3f,0x41,0xbf,0xe0,0x5a,0x58,0x80,0x5f,0x66,0x0b,0xd8,0x90,
23     0x35,0xd5,0xc0,0xa7,0x33,0x06,0x65,0x69,0x45,0x00,0x94,0x56,0x6d,0x98,0x9b,0x76,
24     0x97,0xfc,0xb2,0xc2,0xb0,0xfe,0xdb,0x20,0xe1,0xeb,0xd6,0xe4,0xdd,0x47,0x4a,0x1d,
25     0x42,0xed,0x9e,0x6e,0x49,0x3c,0xcd,0x43,0x27,0xd2,0x07,0xd4,0xde,0xc7,0x67,0x18,
26     0x89,0xcb,0x30,0x1f,0x8d,0xc6,0x8f,0xaa,0xc8,0x74,0xdc,0xc9,0x5d,0x5c,0x31,0xa4,
27     0x70,0x88,0x61,0x2c,0x9f,0x0d,0x2b,0x87,0x50,0x82,0x54,0x64,0x26,0x7d,0x03,0x40,
28     0x34,0x4b,0x1c,0x73,0xd1,0xc4,0xfd,0x3b,0xcc,0xfb,0x7f,0xab,0xe6,0x3e,0x5b,0xa5,
29     0xad,0x04,0x23,0x9c,0x14,0x51,0x22,0xf0,0x29,0x79,0x71,0x7e,0xff,0x8c,0x0e,0xe2,
30     0x0c,0xef,0xbc,0x72,0x75,0x6f,0x37,0xa1,0xec,0xd3,0x8e,0x62,0x8b,0x86,0x10,0xe8,
31     0x08,0x77,0x11,0xbe,0x92,0x4f,0x24,0xc5,0x32,0x36,0x9d,0xcf,0xf3,0xa6,0xbb,0xac,
32     0x5e,0x6c,0xa9,0x13,0x57,0x25,0xb5,0xe3,0xbd,0xa8,0x3a,0x01,0x05,0x59,0x2a,0x46
33  };
34  static const int keystep[] =  { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
35  static const int ikeystep[] = { 9, 0, 1, 2, 3, 4, 5, 6, 7, 8 };
36  int skipjack_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
37  {
38     int x;
39     LTC_ARGCHK(key  != NULL);
40     LTC_ARGCHK(skey != NULL);
41     if (keylen != 10) {
42        return CRYPT_INVALID_KEYSIZE;
43     }
44     if (num_rounds != 32 && num_rounds != 0) {
45        return CRYPT_INVALID_ROUNDS;
46     }
47     for (x = 0; x < 10; x++) {
48         skey->skipjack.key[x] = key[x] & 255;
49     }
50     return CRYPT_OK;
51  }
52  #define RULE_A \
53     tmp = g_func(w1, &kp, skey->skipjack.key);      \
54     w1  = tmp ^ w4 ^ x;                            \
55     w4  = w3; w3 = w2;                             \
56     w2  = tmp;
57  #define RULE_B \
58     tmp  = g_func(w1, &kp, skey->skipjack.key);     \
59     tmp1 = w4; w4  = w3;                           \
60     w3   = w1 ^ w2 ^ x;                            \
61     w1   = tmp1; w2 = tmp;
62  #define RULE_A1 \
63     tmp = w1 ^ w2 ^ x;                             \
64     w1  = ig_func(w2, &kp, skey->skipjack.key);     \
65     w2  = w3; w3 = w4; w4 = tmp;
66  #define RULE_B1 \
67     tmp = ig_func(w2, &kp, skey->skipjack.key);     \
68     w2  = tmp ^ w3 ^ x;                            \
69     w3  = w4; w4 = w1; w1 = tmp;
70  static unsigned g_func(unsigned w, int *kp, const unsigned char *key)
71  {
72     unsigned char g1,g2;
73     g1 = (w >> 8) & 255; g2 = w & 255;
74     g1 ^= sbox[g2^key[*kp]]; *kp = keystep[*kp];
75     g2 ^= sbox[g1^key[*kp]]; *kp = keystep[*kp];
76     g1 ^= sbox[g2^key[*kp]]; *kp = keystep[*kp];
77     g2 ^= sbox[g1^key[*kp]]; *kp = keystep[*kp];
78     return ((unsigned)g1<<8)|(unsigned)g2;
79  }
80  static unsigned ig_func(unsigned w, int *kp, const unsigned char *key)
81  {
82     unsigned char g1,g2;
83     g1 = (w >> 8) & 255; g2 = w & 255;
84     *kp = ikeystep[*kp]; g2 ^= sbox[g1^key[*kp]];
85     *kp = ikeystep[*kp]; g1 ^= sbox[g2^key[*kp]];
86     *kp = ikeystep[*kp]; g2 ^= sbox[g1^key[*kp]];
87     *kp = ikeystep[*kp]; g1 ^= sbox[g2^key[*kp]];
88     return ((unsigned)g1<<8)|(unsigned)g2;
89  }
90  #ifdef LTC_CLEAN_STACK
91  static int s_skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
92  #else
93  int skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
94  #endif
95  {
96     unsigned w1,w2,w3,w4,tmp,tmp1;
97     int x, kp;
98     LTC_ARGCHK(pt   != NULL);
99     LTC_ARGCHK(ct   != NULL);
100     LTC_ARGCHK(skey != NULL);
101     w1 = ((unsigned)pt[0]<<8)|pt[1];
102     w2 = ((unsigned)pt[2]<<8)|pt[3];
103     w3 = ((unsigned)pt[4]<<8)|pt[5];
104     w4 = ((unsigned)pt[6]<<8)|pt[7];
105     for (x = 1, kp = 0; x < 9; x++) {
106         RULE_A;
107     }
108     for (; x < 17; x++) {
109         RULE_B;
110     }
111     for (; x < 25; x++) {
<span onclick='openModal()' class='match'>112         RULE_A;
113     }
114     for (; x < 33; x++) {
115         RULE_B;
116     }
117     ct[0] = (w1>>8)&255; ct[1] = w1&255;
</span>118     ct[2] = (w2>>8)&255; ct[3] = w2&255;
119     ct[4] = (w3>>8)&255; ct[5] = w3&255;
120     ct[6] = (w4>>8)&255; ct[7] = w4&255;
121     return CRYPT_OK;
122  }
123  #ifdef LTC_CLEAN_STACK
124  int skipjack_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
125  {
126     int err = s_skipjack_ecb_encrypt(pt, ct, skey);
127     burn_stack(sizeof(unsigned) * 8 + sizeof(int) * 2);
128     return err;
129  }
130  #endif
131  #ifdef LTC_CLEAN_STACK
132  static int s_skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
133  #else
134  int skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
135  #endif
136  {
137     unsigned w1,w2,w3,w4,tmp;
138     int x, kp;
139     LTC_ARGCHK(pt   != NULL);
140     LTC_ARGCHK(ct   != NULL);
141     LTC_ARGCHK(skey != NULL);
142     w1 = ((unsigned)ct[0]<<8)|ct[1];
143     w2 = ((unsigned)ct[2]<<8)|ct[3];
144     w3 = ((unsigned)ct[4]<<8)|ct[5];
145     w4 = ((unsigned)ct[6]<<8)|ct[7];
146     for (x = 32, kp = 8; x > 24; x--) {
147         RULE_B1;
148     }
149     for (; x > 16; x--) {
150         RULE_A1;
151     }
152     for (; x > 8; x--) {
153         RULE_B1;
154     }
155     for (; x > 0; x--) {
156         RULE_A1;
157     }
158     pt[0] = (w1>>8)&255; pt[1] = w1&255;
159     pt[2] = (w2>>8)&255; pt[3] = w2&255;
160     pt[4] = (w3>>8)&255; pt[5] = w3&255;
161     pt[6] = (w4>>8)&255; pt[7] = w4&255;
162     return CRYPT_OK;
163  }
164  #ifdef LTC_CLEAN_STACK
165  int skipjack_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
166  {
167     int err = s_skipjack_ecb_decrypt(ct, pt, skey);
168     burn_stack(sizeof(unsigned) * 7 + sizeof(int) * 2);
169     return err;
170  }
171  #endif
172  int skipjack_test(void)
173  {
174   #ifndef LTC_TEST
175      return CRYPT_NOP;
176   #else
177     static const struct {
178         unsigned char key[10], pt[8], ct[8];
179     } tests[] = {
180     {
181         { 0x00, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11 },
182         { 0x33, 0x22, 0x11, 0x00, 0xdd, 0xcc, 0xbb, 0xaa },
183         { 0x25, 0x87, 0xca, 0xe2, 0x7a, 0x12, 0xd3, 0x00 }
184     }
185     };
186     unsigned char buf[2][8];
187     int x, y, err;
188     symmetric_key key;
189     for (x = 0; x < (int)(sizeof(tests) / sizeof(tests[0])); x++) {
190        if ((err = skipjack_setup(tests[x].key, 10, 0, &key)) != CRYPT_OK) {
191           return err;
192        }
193        skipjack_ecb_encrypt(tests[x].pt, buf[0], &key);
194        skipjack_ecb_decrypt(buf[0], buf[1], &key);
195        if (compare_testvector(buf[0], 8, tests[x].ct, 8, "Skipjack Encrypt", x) != 0 ||
196              compare_testvector(buf[1], 8, tests[x].pt, 8, "Skipjack Decrypt", x) != 0) {
197           return CRYPT_FAIL_TESTVECTOR;
198        }
199        for (y = 0; y < 8; y++) buf[0][y] = 0;
200        for (y = 0; y < 1000; y++) skipjack_ecb_encrypt(buf[0], buf[0], &key);
201        for (y = 0; y < 1000; y++) skipjack_ecb_decrypt(buf[0], buf[0], &key);
202        for (y = 0; y < 8; y++) if (buf[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
203     }
204     return CRYPT_OK;
205    #endif
206  }
207  void skipjack_done(symmetric_key *skey)
208  {
209    LTC_UNUSED_PARAM(skey);
210  }
211  int skipjack_keysize(int *keysize)
212  {
213     LTC_ARGCHK(keysize != NULL);
214     if (*keysize < 10) {
215        return CRYPT_INVALID_KEYSIZE;
216     }
217     if (*keysize > 10) {
218        *keysize = 10;
219     }
220     return CRYPT_OK;
221  }
222  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-skipjack.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-skipjack.c</div>
                </div>
                <div class="column column_space"><pre><code>112         RULE_A;
113     }
114     for (; x < 33; x++) {
115         RULE_B;
116     }
117     ct[0] = (w1>>8)&255; ct[1] = w1&255;
</pre></code></div>
                <div class="column column_space"><pre><code>112         RULE_A;
113     }
114     for (; x < 33; x++) {
115         RULE_B;
116     }
117     ct[0] = (w1>>8)&255; ct[1] = w1&255;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    