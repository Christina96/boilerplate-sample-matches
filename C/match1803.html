<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pmrfc3164.c &amp; ommysql.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pmrfc3164.c &amp; ommysql.c
      </h3>
<h1 align="center">
        6.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pmrfc3164.c (7.984791%)<th>ommysql.c (5.46875%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(65-76)<td><a href="#" name="0">(89-100)</a><td align="center"><font color="#ff0000">21</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmrfc3164.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include "syslogd.h"
#include "conf.h"
#include "syslogd-types.h"
#include "template.h"
#include "msg.h"
#include "module-template.h"
#include "glbl.h"
#include "errmsg.h"
#include "parser.h"
#include "datetime.h"
#include "unicode-helper.h"
#include "rsconf.h"
MODULE_TYPE_PARSER
MODULE_TYPE_NOKEEP
PARSER_NAME("rsyslog.rfc3164")
MODULE_CNFNAME("pmrfc3164")
DEF_PMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)
static int bParseHOSTNAMEandTAG;	
<a name="0"></a>
static struct cnfparamdescr parserpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "detect.yearaftertimestamp", eCmdHdlrBinary, 0 },
	{ "permit.squarebracketsinhostname", eCmdHdlrBinary, 0 },
	{ "permit.slashesinhostname", eCmdHdlrBinary, 0 },
	{ "permit.atsignsinhostname", eCmdHdlrBinary, 0 },
	{ "force.tagendingbycolon", eCmdHdlrBinary, 0},
	{ "remove.msgfirstspace", eCmdHdlrBinary, 0},
};
static struct cnfparamblk parserpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
	  parserpdescr
	};</b></font>
struct instanceConf_s {
	int bDetectYearAfterTimestamp;
	int bPermitSquareBracketsInHostname;
	int bPermitSlashesInHostname;
	int bPermitAtSignsInHostname;
	int bForceTagEndingByColon;
	int bRemoveMsgFirstSpace;
};
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATUREAutomaticSanitazion)
		iRet = RS_RET_OK;
	if(eFeat == sFEATUREAutomaticPRIParsing)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;bDetectYearAfterTimestamp = 0;
	inst-&gt;bPermitSquareBracketsInHostname = 0;
	inst-&gt;bPermitSlashesInHostname = 0;
	inst-&gt;bPermitAtSignsInHostname = 0;
	inst-&gt;bForceTagEndingByColon = 0;
	inst-&gt;bRemoveMsgFirstSpace = 0;
	bParseHOSTNAMEandTAG = glbl.GetParseHOSTNAMEandTAG(loadConf);
	*pinst = inst;
finalize_it:
	RETiRet;
}
BEGINnewParserInst
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTnewParserInst
	DBGPRINTF("newParserInst (pmrfc3164)\n");
	inst = NULL;
	CHKiRet(createInstance(&amp;inst));
	if(lst == NULL)
		FINALIZE;  
	if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("parser param blk in pmrfc3164:\n");
		cnfparamsPrint(&amp;parserpblk, pvals);
	}
	for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(parserpblk.descr[i].name, "detect.yearaftertimestamp")) {
			inst-&gt;bDetectYearAfterTimestamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, "permit.squarebracketsinhostname")) {
			inst-&gt;bPermitSquareBracketsInHostname = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, "permit.slashesinhostname")) {
			inst-&gt;bPermitSlashesInHostname = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, "permit.atsignsinhostname")) {
			inst-&gt;bPermitAtSignsInHostname = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, "force.tagendingbycolon")) {
			inst-&gt;bForceTagEndingByColon = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, "remove.msgfirstspace")) {
			inst-&gt;bRemoveMsgFirstSpace = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("pmrfc3164: program error, non-handled "
			  "param '%s'\n", parserpblk.descr[i].name);
		}
	}
finalize_it:
CODE_STD_FINALIZERnewParserInst
	if(lst != NULL)
		cnfparamvalsDestruct(pvals, &amp;parserpblk);
	if(iRet != RS_RET_OK)
		free(inst);
ENDnewParserInst
BEGINfreeParserInst
CODESTARTfreeParserInst
	dbgprintf("pmrfc3164: free parser instance %p\n", pInst);
ENDfreeParserInst
BEGINparse2
	uchar *p2parse;
	int lenMsg;
	int i;		uchar bufParseTAG[CONF_TAG_MAXSIZE];
	uchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE];
CODESTARTparse
	assert(pMsg != NULL);
	assert(pMsg-&gt;pszRawMsg != NULL);
	lenMsg = pMsg-&gt;iLenRawMsg - pMsg-&gt;offAfterPRI;
	DBGPRINTF("Message will now be parsed by the legacy syslog parser (offAfterPRI=%d, lenMsg=%d.\n",
		pMsg-&gt;offAfterPRI, lenMsg);
	p2parse = pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI; 	setProtocolVersion(pMsg, MSG_LEGACY_PROTOCOL);
	if(pMsg-&gt;iFacility == (LOG_INVLD&gt;&gt;3)) {
		DBGPRINTF("facility LOG_INVLD, do not parse\n");
		FINALIZE;
	}
	i = 0;
	while(i &lt; lenMsg &amp;&amp; (p2parse[i] == ' ' || p2parse[i] == '\t')) {
		++i;
	}
	if(i &lt; lenMsg &amp;&amp; (p2parse[i] == '{' || p2parse[i] == '[')) {
		DBGPRINTF("msg seems to be headerless, treating it as such\n");
		FINALIZE;
	}
	if(datetime.ParseTIMESTAMP3339(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg) == RS_RET_OK) {
	} else if(datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg,
		NO_PARSE3164_TZSTRING, pInst-&gt;bDetectYearAfterTimestamp) == RS_RET_OK) {
		if(pMsg-&gt;dfltTZ[0] != '\0')
			applyDfltTZ(&amp;pMsg-&gt;tTIMESTAMP, pMsg-&gt;dfltTZ);
	} else if(*p2parse == ' ' &amp;&amp; lenMsg &gt; 1) {
		++p2parse;			--lenMsg;
		if(datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg,
			NO_PARSE3164_TZSTRING, pInst-&gt;bDetectYearAfterTimestamp) == RS_RET_OK) {
			--p2parse;
			++lenMsg;
		}
	}
	if(pMsg-&gt;msgFlags &amp; IGNDATE) {
		memcpy(&amp;pMsg-&gt;tTIMESTAMP, &amp;pMsg-&gt;tRcvdAt, sizeof(struct syslogTime));
	}
	if(bParseHOSTNAMEandTAG &amp;&amp; !(pMsg-&gt;msgFlags &amp; INTERNAL_MSG)) {
		if(lenMsg &gt; 0 &amp;&amp; pMsg-&gt;msgFlags &amp; PARSE_HOSTNAME) {
			i = 0;
			int bHadSBracket = 0;
			if(pInst-&gt;bPermitSquareBracketsInHostname) {
				assert(i &lt; lenMsg);
				if(p2parse[i] == '[') {
					bHadSBracket = 1;
					bufParseHOSTNAME[0] = '[';
					++i;
				}
			}
			while(i &lt; lenMsg
			        &amp;&amp; (isalnum(p2parse[i]) || p2parse[i] == '.'
					|| p2parse[i] == '_' || p2parse[i] == '-'
					|| (p2parse[i] == ']' &amp;&amp; bHadSBracket)
					|| (p2parse[i] == '@' &amp;&amp; pInst-&gt;bPermitAtSignsInHostname)
					|| (p2parse[i] == '/' &amp;&amp; pInst-&gt;bPermitSlashesInHostname) )
				&amp;&amp; i &lt; (CONF_HOSTNAME_MAXSIZE - 1)) {
				bufParseHOSTNAME[i] = p2parse[i];
				++i;
				if(p2parse[i] == ']')
					break;				}
			if(i == lenMsg) {
				p2parse += i;
				lenMsg -= i;
				bufParseHOSTNAME[i] = '\0';
				MsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);
			} else {
				int isHostName = 0;
				if(i &gt; 0) {
					if(bHadSBracket) {
						if(p2parse[i] == ']') {
							bufParseHOSTNAME[i] = ']';
							++i;
							isHostName = 1;
						}
					} else {
						if(isalnum(p2parse[i-1])) {
							isHostName = 1;
						}
					}
					if(p2parse[i] != ' ')
						isHostName = 0;
				}
				if(isHostName) {
					p2parse += i + 1; 					lenMsg -= i + 1;
					bufParseHOSTNAME[i] = '\0';
					MsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);
				}
			}
		}
		i = 0;
		while(lenMsg &gt; 0 &amp;&amp; *p2parse != ':' &amp;&amp; *p2parse != ' ' &amp;&amp; i &lt; CONF_TAG_MAXSIZE - 2) {
			bufParseTAG[i++] = *p2parse++;
			--lenMsg;
		}
		if(lenMsg &gt; 0 &amp;&amp; *p2parse == ':') {
			++p2parse;
			--lenMsg;
			bufParseTAG[i++] = ':';
		}
		else if (pInst-&gt;bForceTagEndingByColon) {
			p2parse -= ( i + 1 );
			lenMsg += ( i + 1 );
			i = 0;
			bufParseTAG[i++] = '-';
		}
		bufParseTAG[i] = '\0';			MsgSetTAG(pMsg, bufParseTAG, i);
		if(!(pMsg-&gt;msgFlags &amp; INTERNAL_MSG)) {
			DBGPRINTF("HOSTNAME and TAG not parsed by user configuration.\n");
		}
	}
finalize_it:
	if (pInst-&gt;bRemoveMsgFirstSpace &amp;&amp; *p2parse == ' ') {
	        p2parse++;
	        lenMsg--;
	}
	MsgSetMSGoffs(pMsg, p2parse - pMsg-&gt;pszRawMsg);
ENDparse2
BEGINmodExit
CODESTARTmodExit
	objRelease(glbl, CORE_COMPONENT);
	objRelease(parser, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_PMOD2_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
BEGINmodInit(pmrfc3164)
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	DBGPRINTF("rfc3164 parser init called\n");
	bParseHOSTNAMEandTAG = glbl.GetParseHOSTNAMEandTAG(loadConf);
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ommysql.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;netdb.h&gt;
#include &lt;mysql.h&gt;
#include &lt;mysqld_error.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "parserif.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("ommysql")
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
DEF_OMOD_STATIC_DATA
typedef struct _instanceData {
	unsigned int dbsrvPort;			char	dbname[_DB_MAXDBLEN+1];		char	dbuid[_DB_MAXUNAMELEN+1];		char	dbpwd[_DB_MAXPWDLEN+1];		uchar   *configfile;				uchar   *configsection;			uchar	*tplName;				uchar	*socket;			} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	MYSQL	*hmysql;				unsigned uLastMySQLErrno;		} wrkrInstanceData_t;
typedef struct configSettings_s {
	int iSrvPort;					uchar *pszMySQLConfigFile;		uchar *pszMySQLConfigSection;	} configSettings_t;
static configSettings_t cs;
static struct cnfparamdescr actpdescr[] = {
<a name="0"></a>	{ "server", eCmdHdlrGetWord, 1 },
	{ "db", eCmdHdlrGetWord, 1 },
	{ "uid", eCmdHdlrGetWord, 1 },
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "pwd", eCmdHdlrGetWord, 1 },
	{ "serverport", eCmdHdlrInt, 0 },
	{ "mysqlconfig.file", eCmdHdlrGetWord, 0 },
	{ "mysqlconfig.section", eCmdHdlrGetWord, 0 },
	{ "template", eCmdHdlrGetWord, 0 },
	{ "socket", eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</b></font>
pthread_rwlock_t rwlock_hmysql;
BEGINinitConfVars		CODESTARTinitConfVars
	resetConfigVariables(NULL, NULL);
ENDinitConfVars
BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
	pWrkrData-&gt;hmysql = NULL;
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
static void closeMySQL(wrkrInstanceData_t *pWrkrData)
{
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
	if(pWrkrData-&gt;hmysql != NULL) {			mysql_close(pWrkrData-&gt;hmysql);
		pWrkrData-&gt;hmysql = NULL;
	}
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
}
BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;configfile);
	free(pData-&gt;configsection);
	free(pData-&gt;tplName);
	free(pData-&gt;socket);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	closeMySQL(pWrkrData);
	mysql_thread_end();
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo
static void reportDBError(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	char errMsg[512];
	unsigned uMySQLErrno;
	errno = 0;
	if(pWrkrData-&gt;hmysql == NULL) {
		LogError(0, NO_ERRCODE, "ommysql: unknown DB error occurred - could not obtain MySQL handle");
	} else { 		uMySQLErrno = mysql_errno(pWrkrData-&gt;hmysql);
		snprintf(errMsg, sizeof(errMsg), "db error (%u): %s\n", uMySQLErrno,
			mysql_error(pWrkrData-&gt;hmysql));
		if(bSilent || uMySQLErrno == pWrkrData-&gt;uLastMySQLErrno)
			dbgprintf("mysql, DBError(silent): %s\n", errMsg);
		else {
			pWrkrData-&gt;uLastMySQLErrno = uMySQLErrno;
			LogError(0, NO_ERRCODE, "ommysql: %s", errMsg);
		}
	}
	return;
}
static rsRetVal initMySQL(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	instanceData *pData;
	DEFiRet;
	assert(pWrkrData-&gt;hmysql == NULL);
	pData = pWrkrData-&gt;pData;
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
	pWrkrData-&gt;hmysql = mysql_init(NULL);
	if(pWrkrData-&gt;hmysql == NULL) {
		LogError(0, RS_RET_SUSPENDED, "can not initialize MySQL handle");
		iRet = RS_RET_SUSPENDED;
	} else { 		mysql_options(pWrkrData-&gt;hmysql,MYSQL_READ_DEFAULT_GROUP,
		((pData-&gt;configsection!=NULL)?(char*)pData-&gt;configsection:"client"));
		if(pData-&gt;configfile!=NULL){
			FILE * fp;
			fp=fopen((char*)pData-&gt;configfile,"r");
			int err=errno;
			if(fp==NULL){
				char msg[512];
				snprintf(msg,sizeof(msg),"Could not open '%s' for reading",pData-&gt;configfile);
				if(bSilent) {
					char errStr[512];
					rs_strerror_r(err, errStr, sizeof(errStr));
					dbgprintf("mysql configuration error(%d): %s - %s\n",err,msg,errStr);
				} else
					LogError(err,NO_ERRCODE,"mysql configuration error: %s\n",msg);
			} else {
				fclose(fp);
				mysql_options(pWrkrData-&gt;hmysql,MYSQL_READ_DEFAULT_FILE,pData-&gt;configfile);
			}
		}
		if(mysql_real_connect(pWrkrData-&gt;hmysql, pData-&gt;dbsrv, pData-&gt;dbuid,
				      pData-&gt;dbpwd, pData-&gt;dbname, pData-&gt;dbsrvPort,
					  (const char *)pData-&gt;socket, 0) == NULL) {
			reportDBError(pWrkrData, bSilent);
			closeMySQL(pWrkrData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		if(mysql_autocommit(pWrkrData-&gt;hmysql, 0)) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "ommysql: activating autocommit failed, "
				"some data may be duplicated\n");
			reportDBError(pWrkrData, 0);
		}
	}
finalize_it:
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	RETiRet;
}
static rsRetVal writeMySQL(wrkrInstanceData_t *pWrkrData, const uchar *const psz)
{
	DEFiRet;
	if(pWrkrData-&gt;hmysql == NULL) {
		CHKiRet(initMySQL(pWrkrData, 0));
	}
	if(mysql_query(pWrkrData-&gt;hmysql, (char*)psz)) {
		const int mysql_err = mysql_errno(pWrkrData-&gt;hmysql);
		if(mysql_err &lt; 2000 || mysql_err &gt; 2999) {
			reportDBError(pWrkrData, 0);
			LogError(0, RS_RET_DATAFAIL, "The error statement was: %s", psz);
			ABORT_FINALIZE(RS_RET_DATAFAIL);
		}
		closeMySQL(pWrkrData); 		CHKiRet(initMySQL(pWrkrData, 0)); 		if(mysql_query(pWrkrData-&gt;hmysql, (char*)psz)) { 			DBGPRINTF("ommysql: suspending due to failed write of '%s'\n", psz);
			reportDBError(pWrkrData, 0);
			closeMySQL(pWrkrData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}
finalize_it:
	if(iRet == RS_RET_OK) {
		pWrkrData-&gt;uLastMySQLErrno = 0; 	}
	RETiRet;
}
BEGINtryResume
CODESTARTtryResume
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	if(pWrkrData-&gt;hmysql == NULL) {
		iRet = initMySQL(pWrkrData, 1);
	}
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDtryResume
BEGINbeginTransaction
CODESTARTbeginTransaction
ENDbeginTransaction
BEGINcommitTransaction
CODESTARTcommitTransaction
	DBGPRINTF("ommysql: commitTransaction\n");
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	CHKiRet(writeMySQL(pWrkrData, (uchar*)"START TRANSACTION"));
	for(unsigned i = 0 ; i &lt; nParams ; ++i) {
		iRet = writeMySQL(pWrkrData, actParam(pParams, 1, i, 0).param);
		if(iRet != RS_RET_OK
			&amp;&amp; iRet != RS_RET_DEFER_COMMIT
			&amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED) {
			if(mysql_rollback(pWrkrData-&gt;hmysql) != 0) {
				DBGPRINTF("ommysql: server error: transaction could not be rolled back\n");
			}
			closeMySQL(pWrkrData);
			FINALIZE;
		}
	}
	if(mysql_commit(pWrkrData-&gt;hmysql) != 0) {
		DBGPRINTF("ommysql: server error: transaction not committed\n");
		reportDBError(pWrkrData, 0);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	DBGPRINTF("ommysql: transaction committed\n");
finalize_it:
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDcommitTransaction
static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;dbsrvPort = 0;
	pData-&gt;configfile = NULL;
	pData-&gt;configsection = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;socket = NULL;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	char *cstr;
	size_t len;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	CODE_STD_STRING_REQUESTparseSelectorAct(1)
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "server")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbsrv)-1) {
				parser_errmsg("ommysql: dbname parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;dbsrv)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbsrv, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, "serverport")) {
			pData-&gt;dbsrvPort = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "db")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbname)-1) {
				parser_errmsg("ommysql: dbname parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;dbname)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbname, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbuid)-1) {
				parser_errmsg("ommysql: uid parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;dbuid)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbuid, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbpwd)-1) {
				parser_errmsg("ommysql: pwd parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;dbpwd)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbpwd, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, "mysqlconfig.file")) {
			pData-&gt;configfile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "mysqlconfig.section")) {
			pData-&gt;configsection = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "socket")) {
			pData-&gt;socket = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("ommysql: program error, non-handled "
			  "param '%s'\n", actpblk.descr[i].name);
		}
	}
	if(pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup(" StdDBFmt"),
			OMSR_RQD_TPL_OPT_SQL));
	} else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
			(uchar*) strdup((char*) pData-&gt;tplName),
			OMSR_RQD_TPL_OPT_SQL));
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINparseSelectorAct
	int iMySQLPropErr = 0;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(*p == '&gt;') {
	} else if(!strncmp((char*) p, ":ommysql:", sizeof(":ommysql:") - 1)) {
		p += sizeof(":ommysql:") - 1; 	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}
	CHKiRet(createInstance(&amp;pData));
	if(getSubString(&amp;p, pData-&gt;dbsrv, MAXHOSTNAMELEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbsrv == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbname, _DB_MAXDBLEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbname == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbuid, _DB_MAXUNAMELEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbuid == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbpwd, _DB_MAXPWDLEN+1, ';'))
		iMySQLPropErr++;
	if(*(p-1) == ';')
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*) " StdDBFmt"));
	if (iMySQLPropErr) {
		LogError(0, RS_RET_INVALID_PARAMS, "Trouble with MySQL connection properties. "
				"-MySQL logging disabled");
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	} else {
		pData-&gt;dbsrvPort = (unsigned) cs.iSrvPort;			pData-&gt;configfile = cs.pszMySQLConfigFile;
		pData-&gt;configsection = cs.pszMySQLConfigSection;
		pData-&gt;socket = NULL;
	}
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
BEGINmodExit
CODESTARTmodExit
	pthread_rwlock_destroy(&amp;rwlock_hmysql);
#	ifdef HAVE_MYSQL_LIBRARY_INIT
	mysql_library_end();
#	else
	mysql_server_end();
#	endif
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMODTX_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	cs.iSrvPort = 0; 	free(cs.pszMySQLConfigFile);
	cs.pszMySQLConfigFile = NULL;
	free(cs.pszMySQLConfigSection);
	cs.pszMySQLConfigSection = NULL;
	RETiRet;
}
BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	if(!bCoreSupportsBatching) {
		LogError(0, NO_ERRCODE, "ommysql: rsyslog core too old");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(
#	ifdef HAVE_MYSQL_LIBRARY_INIT
	   mysql_library_init(0, NULL, NULL)
#	else
	   mysql_server_init(0, NULL, NULL)
#	endif
	                                   ) {
		LogError(0, NO_ERRCODE, "ommysql: initializing mysql client failed, plugin "
		                "can not run");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	pthread_rwlock_init(&amp;rwlock_hmysql, NULL);
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionommysqlserverport", 0, eCmdHdlrInt, NULL, &amp;cs.iSrvPort,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"ommysqlconfigfile",0,eCmdHdlrGetWord,NULL,&amp;cs.pszMySQLConfigFile,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"ommysqlconfigsection",0,eCmdHdlrGetWord,NULL,&amp;cs.pszMySQLConfigSection,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
	NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
