<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for pmrfc3164.c & ommysql.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for pmrfc3164.c & ommysql.c
      </h3>
      <h1 align="center">
        6.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>pmrfc3164.c (7.984791%)<TH>ommysql.c (5.46875%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1803-0.html#0',2,'match1803-1.html#0',3)" NAME="0">(65-76)<TD><A HREF="javascript:ZweiFrames('match1803-0.html#0',2,'match1803-1.html#0',3)" NAME="0">(89-100)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pmrfc3164.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* pmrfc3164.c
 * This is a parser module for RFC3164(legacy syslog)-formatted messages.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * File begun on 2009-11-04 by RGerhards
 *
 * Copyright 2007-2017 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &quot;syslogd.h&quot;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;template.h&quot;
#include &quot;msg.h&quot;
#include &quot;module-template.h&quot;
#include &quot;glbl.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parser.h&quot;
#include &quot;datetime.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;rsconf.h&quot;
MODULE_TYPE_PARSER
MODULE_TYPE_NOKEEP
PARSER_NAME(&quot;rsyslog.rfc3164&quot;)
MODULE_CNFNAME(&quot;pmrfc3164&quot;)

/* internal structures
 */
DEF_PMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(parser)
DEFobjCurrIf(datetime)


/* static data */
static int bParseHOSTNAMEandTAG;	/* cache for the equally-named global param - performance enhancement */

<A NAME="0"></A>
/* parser instance parameters */
static struct cnfparamdescr parserpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1803-1.html#0',3,'match1803-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;detect.yearaftertimestamp&quot;, eCmdHdlrBinary, 0 },
	{ &quot;permit.squarebracketsinhostname&quot;, eCmdHdlrBinary, 0 },
	{ &quot;permit.slashesinhostname&quot;, eCmdHdlrBinary, 0 },
	{ &quot;permit.atsignsinhostname&quot;, eCmdHdlrBinary, 0 },
	{ &quot;force.tagendingbycolon&quot;, eCmdHdlrBinary, 0},
	{ &quot;remove.msgfirstspace&quot;, eCmdHdlrBinary, 0},
};
static struct cnfparamblk parserpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(parserpdescr)/sizeof(struct cnfparamdescr),
	  parserpdescr
	};</B></FONT>

struct instanceConf_s {
	int bDetectYearAfterTimestamp;
	int bPermitSquareBracketsInHostname;
	int bPermitSlashesInHostname;
	int bPermitAtSignsInHostname;
	int bForceTagEndingByColon;
	int bRemoveMsgFirstSpace;
};


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATUREAutomaticSanitazion)
		iRet = RS_RET_OK;
	if(eFeat == sFEATUREAutomaticPRIParsing)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;bDetectYearAfterTimestamp = 0;
	inst-&gt;bPermitSquareBracketsInHostname = 0;
	inst-&gt;bPermitSlashesInHostname = 0;
	inst-&gt;bPermitAtSignsInHostname = 0;
	inst-&gt;bForceTagEndingByColon = 0;
	inst-&gt;bRemoveMsgFirstSpace = 0;
	bParseHOSTNAMEandTAG = glbl.GetParseHOSTNAMEandTAG(loadConf);
	*pinst = inst;
finalize_it:
	RETiRet;
}

BEGINnewParserInst
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTnewParserInst
	DBGPRINTF(&quot;newParserInst (pmrfc3164)\n&quot;);

	inst = NULL;
	CHKiRet(createInstance(&amp;inst));

	if(lst == NULL)
		FINALIZE;  /* just set defaults, no param block! */

	if((pvals = nvlstGetParams(lst, &amp;parserpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;parser param blk in pmrfc3164:\n&quot;);
		cnfparamsPrint(&amp;parserpblk, pvals);
	}

	for(i = 0 ; i &lt; parserpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(parserpblk.descr[i].name, &quot;detect.yearaftertimestamp&quot;)) {
			inst-&gt;bDetectYearAfterTimestamp = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, &quot;permit.squarebracketsinhostname&quot;)) {
			inst-&gt;bPermitSquareBracketsInHostname = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, &quot;permit.slashesinhostname&quot;)) {
			inst-&gt;bPermitSlashesInHostname = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, &quot;permit.atsignsinhostname&quot;)) {
			inst-&gt;bPermitAtSignsInHostname = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, &quot;force.tagendingbycolon&quot;)) {
			inst-&gt;bForceTagEndingByColon = (int) pvals[i].val.d.n;
		} else if(!strcmp(parserpblk.descr[i].name, &quot;remove.msgfirstspace&quot;)) {
			inst-&gt;bRemoveMsgFirstSpace = (int) pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;pmrfc3164: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, parserpblk.descr[i].name);
		}
	}
finalize_it:
CODE_STD_FINALIZERnewParserInst
	if(lst != NULL)
		cnfparamvalsDestruct(pvals, &amp;parserpblk);
	if(iRet != RS_RET_OK)
		free(inst);
ENDnewParserInst


BEGINfreeParserInst
CODESTARTfreeParserInst
	dbgprintf(&quot;pmrfc3164: free parser instance %p\n&quot;, pInst);
ENDfreeParserInst


/* parse a legay-formatted syslog message.
 */
BEGINparse2
	uchar *p2parse;
	int lenMsg;
	int i;	/* general index for parsing */
	uchar bufParseTAG[CONF_TAG_MAXSIZE];
	uchar bufParseHOSTNAME[CONF_HOSTNAME_MAXSIZE];
CODESTARTparse
	assert(pMsg != NULL);
	assert(pMsg-&gt;pszRawMsg != NULL);
	lenMsg = pMsg-&gt;iLenRawMsg - pMsg-&gt;offAfterPRI;
	DBGPRINTF(&quot;Message will now be parsed by the legacy syslog parser (offAfterPRI=%d, lenMsg=%d.\n&quot;,
		pMsg-&gt;offAfterPRI, lenMsg);
	/* note: offAfterPRI is already the number of PRI chars (do not add one!) */
	p2parse = pMsg-&gt;pszRawMsg + pMsg-&gt;offAfterPRI; /* point to start of text, after PRI */
	setProtocolVersion(pMsg, MSG_LEGACY_PROTOCOL);
	if(pMsg-&gt;iFacility == (LOG_INVLD&gt;&gt;3)) {
		DBGPRINTF(&quot;facility LOG_INVLD, do not parse\n&quot;);
		FINALIZE;
	}

	/* now check if we have a completely headerless message. This is indicated
	 * by spaces or tabs followed '{' or '['.
	 */
	i = 0;
	while(i &lt; lenMsg &amp;&amp; (p2parse[i] == ' ' || p2parse[i] == '\t')) {
		++i;
	}
	if(i &lt; lenMsg &amp;&amp; (p2parse[i] == '{' || p2parse[i] == '[')) {
		DBGPRINTF(&quot;msg seems to be headerless, treating it as such\n&quot;);
		FINALIZE;
	}


	/* Check to see if msg contains a timestamp. We start by assuming
	 * that the message timestamp is the time of reception (which we
	 * generated ourselfs and then try to actually find one inside the
	 * message. There we go from high-to low precison and are done
	 * when we find a matching one. -- rgerhards, 2008-09-16
	 */
	if(datetime.ParseTIMESTAMP3339(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg) == RS_RET_OK) {
		/* we are done - parse pointer is moved by ParseTIMESTAMP3339 */;
	} else if(datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg,
		NO_PARSE3164_TZSTRING, pInst-&gt;bDetectYearAfterTimestamp) == RS_RET_OK) {
		if(pMsg-&gt;dfltTZ[0] != '\0')
			applyDfltTZ(&amp;pMsg-&gt;tTIMESTAMP, pMsg-&gt;dfltTZ);
		/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;
	} else if(*p2parse == ' ' &amp;&amp; lenMsg &gt; 1) {
	/* try to see if it is slighly malformed - HP procurve seems to do that sometimes */
		++p2parse;	/* move over space */
		--lenMsg;
		if(datetime.ParseTIMESTAMP3164(&amp;(pMsg-&gt;tTIMESTAMP), &amp;p2parse, &amp;lenMsg,
			NO_PARSE3164_TZSTRING, pInst-&gt;bDetectYearAfterTimestamp) == RS_RET_OK) {
			/* indeed, we got it! */
			/* we are done - parse pointer is moved by ParseTIMESTAMP3164 */;
		} else {/* parse pointer needs to be restored, as we moved it off-by-one
			 * for this try.
			 */
			--p2parse;
			++lenMsg;
		}
	}

	if(pMsg-&gt;msgFlags &amp; IGNDATE) {
		/* we need to ignore the msg data, so simply copy over reception date */
		memcpy(&amp;pMsg-&gt;tTIMESTAMP, &amp;pMsg-&gt;tRcvdAt, sizeof(struct syslogTime));
	}

	/* rgerhards, 2006-03-13: next, we parse the hostname and tag. But we
	 * do this only when the user has not forbidden this. I now introduce some
	 * code that allows a user to configure rsyslogd to treat the rest of the
	 * message as MSG part completely. In this case, the hostname will be the
	 * machine that we received the message from and the tag will be empty. This
	 * is meant to be an interim solution, but for now it is in the code.
	 */
	if(bParseHOSTNAMEandTAG &amp;&amp; !(pMsg-&gt;msgFlags &amp; INTERNAL_MSG)) {
		/* parse HOSTNAME - but only if this is network-received!
		 * rger, 2005-11-14: we still have a problem with BSD messages. These messages
		 * do NOT include a host name. In most cases, this leads to the TAG to be treated
		 * as hostname and the first word of the message as the TAG. Clearly, this is not
		 * of advantage ;) I think I have now found a way to handle this situation: there
		 * are certain characters which are frequently used in TAG (e.g. ':'), which are
		 * *invalid* in host names. So while parsing the hostname, I check for these characters.
		 * If I find them, I set a simple flag but continue. After parsing, I check the flag.
		 * If it was set, then we most probably do not have a hostname but a TAG. Thus, I change
		 * the fields. I think this logic shall work with any type of syslog message.
		 * rgerhards, 2009-06-23: and I now have extended this logic to every character
		 * that is not a valid hostname.
		 * A &quot;hostname&quot; can validly include &quot;[]&quot; at the beginning and end. This sometimes
		 * happens with IP address (e.g. &quot;[192.168.0.1]&quot;). This must be turned on via
		 * an option as it may interfere with non-hostnames in some message formats.
		 * rgerhards, 2015-04-20
		 */
		if(lenMsg &gt; 0 &amp;&amp; pMsg-&gt;msgFlags &amp; PARSE_HOSTNAME) {
			i = 0;
			int bHadSBracket = 0;
			if(pInst-&gt;bPermitSquareBracketsInHostname) {
				assert(i &lt; lenMsg);
				if(p2parse[i] == '[') {
					bHadSBracket = 1;
					bufParseHOSTNAME[0] = '[';
					++i;
				}
			}
			while(i &lt; lenMsg
			        &amp;&amp; (isalnum(p2parse[i]) || p2parse[i] == '.'
					|| p2parse[i] == '_' || p2parse[i] == '-'
					|| (p2parse[i] == ']' &amp;&amp; bHadSBracket)
					|| (p2parse[i] == '@' &amp;&amp; pInst-&gt;bPermitAtSignsInHostname)
					|| (p2parse[i] == '/' &amp;&amp; pInst-&gt;bPermitSlashesInHostname) )
				&amp;&amp; i &lt; (CONF_HOSTNAME_MAXSIZE - 1)) {
				bufParseHOSTNAME[i] = p2parse[i];
				++i;
				if(p2parse[i] == ']')
					break;	/* must be closing bracket */
			}

			if(i == lenMsg) {
				/* we have a message that is empty immediately after the hostname,
				* but the hostname thus is valid! -- rgerhards, 2010-02-22
				*/
				p2parse += i;
				lenMsg -= i;
				bufParseHOSTNAME[i] = '\0';
				MsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);
			} else {
				int isHostName = 0;
				if(i &gt; 0) {
					if(bHadSBracket) {
						if(p2parse[i] == ']') {
							bufParseHOSTNAME[i] = ']';
							++i;
							isHostName = 1;
						}
					} else {
						if(isalnum(p2parse[i-1])) {
							isHostName = 1;
						}
					}
					if(p2parse[i] != ' ')
						isHostName = 0;
				}

				if(isHostName) {
					/* we got a hostname! */
					p2parse += i + 1; /* &quot;eat&quot; it (including SP delimiter) */
					lenMsg -= i + 1;
					bufParseHOSTNAME[i] = '\0';
					MsgSetHOSTNAME(pMsg, bufParseHOSTNAME, i);
				}
			}
		}

		/* now parse TAG - that should be present in message from all sources.
		 * This code is somewhat not compliant with RFC 3164. As of 3164,
		 * the TAG field is ended by any non-alphanumeric character. In
		 * practice, however, the TAG often contains dashes and other things,
		 * which would end the TAG. So it is not desirable. As such, we only
		 * accept colon and SP to be terminators. Even there is a slight difference:
		 * a colon is PART of the TAG, while a SP is NOT part of the tag
		 * (it is CONTENT). Starting 2008-04-04, we have removed the 32 character
		 * size limit (from RFC3164) on the tag. This had bad effects on existing
		 * envrionments, as sysklogd didn't obey it either (probably another bug
		 * in RFC3164...). We now receive the full size, but will modify the
		 * outputs so that only 32 characters max are used by default.
		 */
		i = 0;
		while(lenMsg &gt; 0 &amp;&amp; *p2parse != ':' &amp;&amp; *p2parse != ' ' &amp;&amp; i &lt; CONF_TAG_MAXSIZE - 2) {
			bufParseTAG[i++] = *p2parse++;
			--lenMsg;
		}
		if(lenMsg &gt; 0 &amp;&amp; *p2parse == ':') {
			++p2parse;
			--lenMsg;
			bufParseTAG[i++] = ':';
		}
		else if (pInst-&gt;bForceTagEndingByColon) {
			/* Tag need to be ended by a colon or it's not a tag but the
			 * begin of the message
			 */
			p2parse -= ( i + 1 );
			lenMsg += ( i + 1 );
			i = 0;
			/* Default TAG is dash (without ':')
			 */
			bufParseTAG[i++] = '-';
		}

		/* no TAG can only be detected if the message immediatly ends, in which case an empty TAG
		 * is considered OK. So we do not need to check for empty TAG. -- rgerhards, 2009-06-23
		 */
		bufParseTAG[i] = '\0';	/* terminate string */
		MsgSetTAG(pMsg, bufParseTAG, i);
	} else {/* we enter this code area when the user has instructed rsyslog NOT
		 * to parse HOSTNAME and TAG - rgerhards, 2006-03-13
		 */
		if(!(pMsg-&gt;msgFlags &amp; INTERNAL_MSG)) {
			DBGPRINTF(&quot;HOSTNAME and TAG not parsed by user configuration.\n&quot;);
		}
	}

finalize_it:
	if (pInst-&gt;bRemoveMsgFirstSpace &amp;&amp; *p2parse == ' ') {
		/* Bypass first space found in MSG part */
	        p2parse++;
	        lenMsg--;
	}
	MsgSetMSGoffs(pMsg, p2parse - pMsg-&gt;pszRawMsg);
ENDparse2


BEGINmodExit
CODESTARTmodExit
	/* release what we no longer need */
	objRelease(glbl, CORE_COMPONENT);
	objRelease(parser, CORE_COMPONENT);
	objRelease(datetime, CORE_COMPONENT);
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_PMOD2_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit(pmrfc3164)
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
	/* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(parser, CORE_COMPONENT));
	CHKiRet(objUse(datetime, CORE_COMPONENT));

	DBGPRINTF(&quot;rfc3164 parser init called\n&quot;);
	bParseHOSTNAMEandTAG = glbl.GetParseHOSTNAMEandTAG(loadConf);
	/* cache value, is set only during rsyslogd option processing */


ENDmodInit

/* vim:set ai:
 */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ommysql.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* ommysql.c
 * This is the implementation of the build-in output module for MySQL.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * File begun on 2007-07-20 by RGerhards (extracted from syslogd.c)
 *
 * Copyright 2007-2021 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;netdb.h&gt;
#include &lt;mysql.h&gt;
#include &lt;mysqld_error.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;parserif.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;ommysql&quot;)

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* internal structures
 */
DEF_OMOD_STATIC_DATA

typedef struct _instanceData {
	char	dbsrv[MAXHOSTNAMELEN+1];	/* IP or hostname of DB server*/
	unsigned int dbsrvPort;		/* port of MySQL server */
	char	dbname[_DB_MAXDBLEN+1];	/* DB name */
	char	dbuid[_DB_MAXUNAMELEN+1];	/* DB user */
	char	dbpwd[_DB_MAXPWDLEN+1];	/* DB user's password */
	uchar   *configfile;			/* MySQL Client Configuration File */
	uchar   *configsection;		/* MySQL Client Configuration Section */
	uchar	*tplName;			/* format template to use */
	uchar	*socket;			/* MySQL socket path */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	MYSQL	*hmysql;			/* handle to MySQL */
	unsigned uLastMySQLErrno;		/* last errno returned by MySQL or 0 if all is well */
} wrkrInstanceData_t;

typedef struct configSettings_s {
	int iSrvPort;				/* database server port */
	uchar *pszMySQLConfigFile;	/* MySQL Client Configuration File */
	uchar *pszMySQLConfigSection;	/* MySQL Client Configuration Section */
} configSettings_t;
static configSettings_t cs;

/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
<A NAME="0"></A>	{ &quot;server&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;db&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;uid&quot;, eCmdHdlrGetWord, 1 },
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1803-0.html#0',2,'match1803-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;pwd&quot;, eCmdHdlrGetWord, 1 },
	{ &quot;serverport&quot;, eCmdHdlrInt, 0 },
	{ &quot;mysqlconfig.file&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;mysqlconfig.section&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;socket&quot;, eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

/* we need to synchronize access to the mysql handle, because multiple threads
 * use it and we may need to (re)init it during processing. This could lead to
 * races with potentially wrong addresses or NULL accesses.
 */
pthread_rwlock_t rwlock_hmysql;

BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	resetConfigVariables(NULL, NULL);
ENDinitConfVars


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
	pWrkrData-&gt;hmysql = NULL;
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


/* The following function is responsible for closing a
 * MySQL connection.
 * Initially added 2004-10-28
 */
static void closeMySQL(wrkrInstanceData_t *pWrkrData)
{
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);
	if(pWrkrData-&gt;hmysql != NULL) {	/* just to be on the safe side... */
		mysql_close(pWrkrData-&gt;hmysql);
		pWrkrData-&gt;hmysql = NULL;
	}
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
}

BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;configfile);
	free(pData-&gt;configsection);
	free(pData-&gt;tplName);
	free(pData-&gt;socket);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	closeMySQL(pWrkrData);
	mysql_thread_end();
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	/* nothing special here */
ENDdbgPrintInstInfo


/* log a database error with descriptive message.
 * We check if we have a valid MySQL handle. If not, we simply
 * report an error, but can not be specific. RGerhards, 2007-01-30
 */
static void reportDBError(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	char errMsg[512];
	unsigned uMySQLErrno;

	/* output log message */
	errno = 0;
	if(pWrkrData-&gt;hmysql == NULL) {
		LogError(0, NO_ERRCODE, &quot;ommysql: unknown DB error occurred - could not obtain MySQL handle&quot;);
	} else { /* we can ask mysql for the error description... */
		uMySQLErrno = mysql_errno(pWrkrData-&gt;hmysql);
		snprintf(errMsg, sizeof(errMsg), &quot;db error (%u): %s\n&quot;, uMySQLErrno,
			mysql_error(pWrkrData-&gt;hmysql));
		if(bSilent || uMySQLErrno == pWrkrData-&gt;uLastMySQLErrno)
			dbgprintf(&quot;mysql, DBError(silent): %s\n&quot;, errMsg);
		else {
			pWrkrData-&gt;uLastMySQLErrno = uMySQLErrno;
			LogError(0, NO_ERRCODE, &quot;ommysql: %s&quot;, errMsg);
		}
	}

	return;
}


/* The following function is responsible for initializing a
 * MySQL connection.
 * Initially added 2004-10-28 mmeckelein
 */
static rsRetVal initMySQL(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	instanceData *pData;
	DEFiRet;

	assert(pWrkrData-&gt;hmysql == NULL);
	pData = pWrkrData-&gt;pData;

	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_wrlock(&amp;rwlock_hmysql);

	pWrkrData-&gt;hmysql = mysql_init(NULL);
	if(pWrkrData-&gt;hmysql == NULL) {
		LogError(0, RS_RET_SUSPENDED, &quot;can not initialize MySQL handle&quot;);
		iRet = RS_RET_SUSPENDED;
	} else { /* we could get the handle, now on with work... */
		mysql_options(pWrkrData-&gt;hmysql,MYSQL_READ_DEFAULT_GROUP,
		((pData-&gt;configsection!=NULL)?(char*)pData-&gt;configsection:&quot;client&quot;));
		if(pData-&gt;configfile!=NULL){
			FILE * fp;
			fp=fopen((char*)pData-&gt;configfile,&quot;r&quot;);
			int err=errno;
			if(fp==NULL){
				char msg[512];
				snprintf(msg,sizeof(msg),&quot;Could not open '%s' for reading&quot;,pData-&gt;configfile);
				if(bSilent) {
					char errStr[512];
					rs_strerror_r(err, errStr, sizeof(errStr));
					dbgprintf(&quot;mysql configuration error(%d): %s - %s\n&quot;,err,msg,errStr);
				} else
					LogError(err,NO_ERRCODE,&quot;mysql configuration error: %s\n&quot;,msg);
			} else {
				fclose(fp);
				mysql_options(pWrkrData-&gt;hmysql,MYSQL_READ_DEFAULT_FILE,pData-&gt;configfile);
			}
		}
		/* Connect to database */
		if(mysql_real_connect(pWrkrData-&gt;hmysql, pData-&gt;dbsrv, pData-&gt;dbuid,
				      pData-&gt;dbpwd, pData-&gt;dbname, pData-&gt;dbsrvPort,
					  (const char *)pData-&gt;socket, 0) == NULL) {
			reportDBError(pWrkrData, bSilent);
			closeMySQL(pWrkrData); /* ignore any error we may get */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		if(mysql_autocommit(pWrkrData-&gt;hmysql, 0)) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, &quot;ommysql: activating autocommit failed, &quot;
				&quot;some data may be duplicated\n&quot;);
			reportDBError(pWrkrData, 0);
		}
	}

finalize_it:
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	RETiRet;
}


/* The following function writes the current log entry
 * to an established MySQL session.
 * Initially added 2004-10-28 mmeckelein
 */
static rsRetVal writeMySQL(wrkrInstanceData_t *pWrkrData, const uchar *const psz)
{
	DEFiRet;

	/* see if we are ready to proceed */
	if(pWrkrData-&gt;hmysql == NULL) {
		CHKiRet(initMySQL(pWrkrData, 0));
	}

	/* try insert */
	if(mysql_query(pWrkrData-&gt;hmysql, (char*)psz)) {
		const int mysql_err = mysql_errno(pWrkrData-&gt;hmysql);
		/* We assume server error codes are non-recoverable, mainly data errors.
		 * This also means we need to differentiate between client and server error
		 * codes. Unfortunately, the API does not provide a specified function for
		 * this. Howerver, error codes 2000..2999 are currently client error codes.
		 * So we use this as guideline.
		 */
		if(mysql_err &lt; 2000 || mysql_err &gt; 2999) {
			reportDBError(pWrkrData, 0);
			LogError(0, RS_RET_DATAFAIL, &quot;The error statement was: %s&quot;, psz);
			ABORT_FINALIZE(RS_RET_DATAFAIL);
		}
		/* potentially recoverable error occurred, try to re-init connection and retry */
		closeMySQL(pWrkrData); /* close the current handle */
		CHKiRet(initMySQL(pWrkrData, 0)); /* try to re-open */
		if(mysql_query(pWrkrData-&gt;hmysql, (char*)psz)) { /* re-try insert */
			/* we failed, giving up for now */
			DBGPRINTF(&quot;ommysql: suspending due to failed write of '%s'\n&quot;, psz);
			reportDBError(pWrkrData, 0);
			closeMySQL(pWrkrData); /* free ressources */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}

finalize_it:
	if(iRet == RS_RET_OK) {
		pWrkrData-&gt;uLastMySQLErrno = 0; /* reset error for error supression */
	}

	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	if(pWrkrData-&gt;hmysql == NULL) {
		iRet = initMySQL(pWrkrData, 1);
	}
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDtryResume

BEGINbeginTransaction
CODESTARTbeginTransaction
	// NOTHING TO DO IN HERE
ENDbeginTransaction

BEGINcommitTransaction
CODESTARTcommitTransaction
	DBGPRINTF(&quot;ommysql: commitTransaction\n&quot;);
	pthread_rwlock_rdlock(&amp;rwlock_hmysql);
	CHKiRet(writeMySQL(pWrkrData, (uchar*)&quot;START TRANSACTION&quot;));

	for(unsigned i = 0 ; i &lt; nParams ; ++i) {
		iRet = writeMySQL(pWrkrData, actParam(pParams, 1, i, 0).param);
		if(iRet != RS_RET_OK
			&amp;&amp; iRet != RS_RET_DEFER_COMMIT
			&amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED) {
			if(mysql_rollback(pWrkrData-&gt;hmysql) != 0) {
				DBGPRINTF(&quot;ommysql: server error: transaction could not be rolled back\n&quot;);
			}
			closeMySQL(pWrkrData);
			FINALIZE;
		}
	}

	if(mysql_commit(pWrkrData-&gt;hmysql) != 0) {
		DBGPRINTF(&quot;ommysql: server error: transaction not committed\n&quot;);
		reportDBError(pWrkrData, 0);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	DBGPRINTF(&quot;ommysql: transaction committed\n&quot;);
finalize_it:
	pthread_rwlock_unlock(&amp;rwlock_hmysql);
ENDcommitTransaction

static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;dbsrvPort = 0;
	pData-&gt;configfile = NULL;
	pData-&gt;configsection = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;socket = NULL;
}


/* note: we use the fixed-size buffers inside the config object to avoid
 * changing too much of the previous plumbing. rgerhards, 2012-02-02
 */
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	char *cstr;
	size_t len;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	CODE_STD_STRING_REQUESTparseSelectorAct(1)
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;server&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbsrv)-1) {
				parser_errmsg(&quot;ommysql: dbname parameter longer than supported &quot;
					&quot;maximum of %d characters&quot;, (int)sizeof(pData-&gt;dbsrv)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbsrv, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, &quot;serverport&quot;)) {
			pData-&gt;dbsrvPort = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;db&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbname)-1) {
				parser_errmsg(&quot;ommysql: dbname parameter longer than supported &quot;
					&quot;maximum of %d characters&quot;, (int)sizeof(pData-&gt;dbname)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbname, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, &quot;uid&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbuid)-1) {
				parser_errmsg(&quot;ommysql: uid parameter longer than supported &quot;
					&quot;maximum of %d characters&quot;, (int)sizeof(pData-&gt;dbuid)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbuid, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, &quot;pwd&quot;)) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbpwd)-1) {
				parser_errmsg(&quot;ommysql: pwd parameter longer than supported &quot;
					&quot;maximum of %d characters&quot;, (int)sizeof(pData-&gt;dbpwd)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbpwd, cstr, len+1);
			free(cstr);
		} else if(!strcmp(actpblk.descr[i].name, &quot;mysqlconfig.file&quot;)) {
			pData-&gt;configfile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;mysqlconfig.section&quot;)) {
			pData-&gt;configsection = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, &quot;socket&quot;)) {
			pData-&gt;socket = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;ommysql: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	if(pData-&gt;tplName == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup(&quot; StdDBFmt&quot;),
			OMSR_RQD_TPL_OPT_SQL));
	} else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0,
			(uchar*) strdup((char*) pData-&gt;tplName),
			OMSR_RQD_TPL_OPT_SQL));
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINparseSelectorAct
	int iMySQLPropErr = 0;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us
	 * The first test [*p == '&gt;'] can be skipped if a module shall only
	 * support the newer slection syntax [:modname:]. This is in fact
	 * recommended for new modules. Please note that over time this part
	 * will be handled by rsyslogd itself, but for the time being it is
	 * a good compromise to do it at the module level.
	 * rgerhards, 2007-10-15
	 */
	if(*p == '&gt;') {
		p++; /* eat '&gt;' '*/
	} else if(!strncmp((char*) p, &quot;:ommysql:&quot;, sizeof(&quot;:ommysql:&quot;) - 1)) {
		p += sizeof(&quot;:ommysql:&quot;) - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	} else {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	CHKiRet(createInstance(&amp;pData));

	/* rger 2004-10-28: added support for MySQL
	 * &gt;server,dbname,userid,password
	 * Now we read the MySQL connection properties
	 * and verify that the properties are valid.
	 */
	if(getSubString(&amp;p, pData-&gt;dbsrv, MAXHOSTNAMELEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbsrv == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbname, _DB_MAXDBLEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbname == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbuid, _DB_MAXUNAMELEN+1, ','))
		iMySQLPropErr++;
	if(*pData-&gt;dbuid == '\0')
		iMySQLPropErr++;
	if(getSubString(&amp;p, pData-&gt;dbpwd, _DB_MAXPWDLEN+1, ';'))
		iMySQLPropErr++;
	/* now check for template
	 * We specify that the SQL option must be present in the template.
	 * This is for your own protection (prevent sql injection).
	 */
	if(*(p-1) == ';')
		--p;	/* TODO: the whole parsing of the MySQL module needs to be re-thought - but this here
			 *       is clean enough for the time being -- rgerhards, 2007-07-30
			 */
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*) &quot; StdDBFmt&quot;));
	
	/* If we detect invalid properties, we disable logging,
	 * because right properties are vital at this place.
	 * Retries make no sense.
	 */
	if (iMySQLPropErr) {
		LogError(0, RS_RET_INVALID_PARAMS, &quot;Trouble with MySQL connection properties. &quot;
				&quot;-MySQL logging disabled&quot;);
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	} else {
		pData-&gt;dbsrvPort = (unsigned) cs.iSrvPort;	/* set configured port */
		pData-&gt;configfile = cs.pszMySQLConfigFile;
		pData-&gt;configsection = cs.pszMySQLConfigSection;
		pData-&gt;socket = NULL;
	}

CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
	pthread_rwlock_destroy(&amp;rwlock_hmysql);
#	ifdef HAVE_MYSQL_LIBRARY_INIT
	mysql_library_end();
#	else
	mysql_server_end();
#	endif
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMODTX_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt


/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	cs.iSrvPort = 0; /* zero is the default port */
	free(cs.pszMySQLConfigFile);
	cs.pszMySQLConfigFile = NULL;
	free(cs.pszMySQLConfigSection);
	cs.pszMySQLConfigSection = NULL;
	RETiRet;
}

BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	if(!bCoreSupportsBatching) {
		LogError(0, NO_ERRCODE, &quot;ommysql: rsyslog core too old&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	/* we need to init the MySQL library. If that fails, we cannot run */
	if(
#	ifdef HAVE_MYSQL_LIBRARY_INIT
	   mysql_library_init(0, NULL, NULL)
#	else
	   mysql_server_init(0, NULL, NULL)
#	endif
	                                   ) {
		LogError(0, NO_ERRCODE, &quot;ommysql: initializing mysql client failed, plugin &quot;
		                &quot;can not run&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	pthread_rwlock_init(&amp;rwlock_hmysql, NULL);

	/* register our config handlers */
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionommysqlserverport&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iSrvPort,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;ommysqlconfigfile&quot;,0,eCmdHdlrGetWord,NULL,&amp;cs.pszMySQLConfigFile,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;ommysqlconfigsection&quot;,0,eCmdHdlrGetWord,NULL,&amp;cs.pszMySQLConfigSection,
	STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler, resetConfigVariables,
	NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
