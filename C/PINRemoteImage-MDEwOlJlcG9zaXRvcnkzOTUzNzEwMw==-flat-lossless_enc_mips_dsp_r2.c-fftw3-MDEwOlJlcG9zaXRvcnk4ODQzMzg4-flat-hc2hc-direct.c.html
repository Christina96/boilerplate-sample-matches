
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.673913043478262%, Tokens: 10</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_mips_dsp_r2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_MIPS_DSP_R2)
3  #include "src/dsp/lossless.h"
4  static void SubtractGreenFromBlueAndRed_MIPSdspR2(uint32_t* argb_data,
5                                                    int num_pixels) {
6    uint32_t temp0, temp1, temp2, temp3, temp4, temp5, temp6, temp7;
7    uint32_t* const p_loop1_end = argb_data + (num_pixels & ~3);
8    uint32_t* const p_loop2_end = p_loop1_end + (num_pixels & 3);
9    __asm__ volatile (
10      ".set       push                                          \n\t"
11      ".set       noreorder                                     \n\t"
12      "beq        %[argb_data],    %[p_loop1_end],     3f       \n\t"
13      " nop                                                     \n\t"
14    "0:                                                         \n\t"
15      "lw         %[temp0],        0(%[argb_data])              \n\t"
16      "lw         %[temp1],        4(%[argb_data])              \n\t"
17      "lw         %[temp2],        8(%[argb_data])              \n\t"
18      "lw         %[temp3],        12(%[argb_data])             \n\t"
19      "ext        %[temp4],        %[temp0],           8,    8  \n\t"
20      "ext        %[temp5],        %[temp1],           8,    8  \n\t"
21      "ext        %[temp6],        %[temp2],           8,    8  \n\t"
22      "ext        %[temp7],        %[temp3],           8,    8  \n\t"
23      "addiu      %[argb_data],    %[argb_data],       16       \n\t"
24      "replv.ph   %[temp4],        %[temp4]                     \n\t"
25      "replv.ph   %[temp5],        %[temp5]                     \n\t"
26      "replv.ph   %[temp6],        %[temp6]                     \n\t"
27      "replv.ph   %[temp7],        %[temp7]                     \n\t"
28      "subu.qb    %[temp0],        %[temp0],           %[temp4] \n\t"
29      "subu.qb    %[temp1],        %[temp1],           %[temp5] \n\t"
30      "subu.qb    %[temp2],        %[temp2],           %[temp6] \n\t"
31      "subu.qb    %[temp3],        %[temp3],           %[temp7] \n\t"
32      "sw         %[temp0],        -16(%[argb_data])            \n\t"
33      "sw         %[temp1],        -12(%[argb_data])            \n\t"
34      "sw         %[temp2],        -8(%[argb_data])             \n\t"
35      "bne        %[argb_data],    %[p_loop1_end],     0b       \n\t"
36      " sw        %[temp3],        -4(%[argb_data])             \n\t"
37    "3:                                                         \n\t"
38      "beq        %[argb_data],    %[p_loop2_end],     2f       \n\t"
39      " nop                                                     \n\t"
40    "1:                                                         \n\t"
41      "lw         %[temp0],        0(%[argb_data])              \n\t"
42      "addiu      %[argb_data],    %[argb_data],       4        \n\t"
43      "ext        %[temp4],        %[temp0],           8,    8  \n\t"
44      "replv.ph   %[temp4],        %[temp4]                     \n\t"
45      "subu.qb    %[temp0],        %[temp0],           %[temp4] \n\t"
46      "bne        %[argb_data],    %[p_loop2_end],     1b       \n\t"
47      " sw        %[temp0],        -4(%[argb_data])             \n\t"
48    "2:                                                         \n\t"
49      ".set       pop                                           \n\t"
50      : [argb_data]"+&r"(argb_data), [temp0]"=&r"(temp0),
51        [temp1]"=&r"(temp1), [temp2]"=&r"(temp2), [temp3]"=&r"(temp3),
52        [temp4]"=&r"(temp4), [temp5]"=&r"(temp5), [temp6]"=&r"(temp6),
53        [temp7]"=&r"(temp7)
54      : [p_loop1_end]"r"(p_loop1_end), [p_loop2_end]"r"(p_loop2_end)
55      : "memory"
56    );
57  }
58  static WEBP_INLINE uint32_t ColorTransformDelta(int8_t color_pred,
59                                                  int8_t color) {
60    return (uint32_t)((int)(color_pred) * color) >> 5;
61  }
62  static void TransformColor_MIPSdspR2(const VP8LMultipliers* const m,
63                                       uint32_t* data, int num_pixels) {
64    int temp0, temp1, temp2, temp3, temp4, temp5;
65    uint32_t argb, argb1, new_red, new_red1;
66    const uint32_t G_to_R = m->green_to_red_;
67    const uint32_t G_to_B = m->green_to_blue_;
68    const uint32_t R_to_B = m->red_to_blue_;
69    uint32_t* const p_loop_end = data + (num_pixels & ~1);
70    __asm__ volatile (
71      ".set            push                                    \n\t"
72      ".set            noreorder                               \n\t"
73      "beq             %[data],      %[p_loop_end],  1f        \n\t"
74      " nop                                                    \n\t"
75      "replv.ph        %[temp0],     %[G_to_R]                 \n\t"
76      "replv.ph        %[temp1],     %[G_to_B]                 \n\t"
77      "replv.ph        %[temp2],     %[R_to_B]                 \n\t"
78      "shll.ph         %[temp0],     %[temp0],       8         \n\t"
79      "shll.ph         %[temp1],     %[temp1],       8         \n\t"
80      "shll.ph         %[temp2],     %[temp2],       8         \n\t"
81      "shra.ph         %[temp0],     %[temp0],       8         \n\t"
82      "shra.ph         %[temp1],     %[temp1],       8         \n\t"
83      "shra.ph         %[temp2],     %[temp2],       8         \n\t"
84    "0:                                                        \n\t"
85      "lw              %[argb],      0(%[data])                \n\t"
86      "lw              %[argb1],     4(%[data])                \n\t"
87      "lhu             %[new_red],   2(%[data])                \n\t"
88      "lhu             %[new_red1],  6(%[data])                \n\t"
89      "precrq.qb.ph    %[temp3],     %[argb],        %[argb1]  \n\t"
90      "precr.qb.ph     %[temp4],     %[argb],        %[argb1]  \n\t"
91      "preceu.ph.qbra  %[temp3],     %[temp3]                  \n\t"
92      "preceu.ph.qbla  %[temp4],     %[temp4]                  \n\t"
93      "shll.ph         %[temp3],     %[temp3],       8         \n\t"
94      "shll.ph         %[temp4],     %[temp4],       8         \n\t"
95      "shra.ph         %[temp3],     %[temp3],       8         \n\t"
96      "shra.ph         %[temp4],     %[temp4],       8         \n\t"
97      "mul.ph          %[temp5],     %[temp3],       %[temp0]  \n\t"
98      "mul.ph          %[temp3],     %[temp3],       %[temp1]  \n\t"
99      "mul.ph          %[temp4],     %[temp4],       %[temp2]  \n\t"
100      "addiu           %[data],      %[data],        8         \n\t"
101      "ins             %[new_red1],  %[new_red],     16,   16  \n\t"
102      "ins             %[argb1],     %[argb],        16,   16  \n\t"
103      "shra.ph         %[temp5],     %[temp5],       5         \n\t"
104      "shra.ph         %[temp3],     %[temp3],       5         \n\t"
105      "shra.ph         %[temp4],     %[temp4],       5         \n\t"
106      "subu.ph         %[new_red1],  %[new_red1],    %[temp5]  \n\t"
107      "subu.ph         %[argb1],     %[argb1],       %[temp3]  \n\t"
108      "preceu.ph.qbra  %[temp5],     %[new_red1]               \n\t"
109      "subu.ph         %[argb1],     %[argb1],       %[temp4]  \n\t"
110      "preceu.ph.qbra  %[temp3],     %[argb1]                  \n\t"
111      "sb              %[temp5],     -2(%[data])               \n\t"
112      "sb              %[temp3],     -4(%[data])               \n\t"
113      "sra             %[temp5],     %[temp5],       16        \n\t"
114      "sra             %[temp3],     %[temp3],       16        \n\t"
115      "sb              %[temp5],     -6(%[data])               \n\t"
116      "bne             %[data],      %[p_loop_end],  0b        \n\t"
117      " sb             %[temp3],     -8(%[data])               \n\t"
118    "1:                                                        \n\t"
119      ".set            pop                                     \n\t"
120      : [temp0]"=&r"(temp0), [temp1]"=&r"(temp1), [temp2]"=&r"(temp2),
121        [temp3]"=&r"(temp3), [temp4]"=&r"(temp4), [temp5]"=&r"(temp5),
122        [new_red1]"=&r"(new_red1), [new_red]"=&r"(new_red),
123        [argb]"=&r"(argb), [argb1]"=&r"(argb1), [data]"+&r"(data)
124      : [G_to_R]"r"(G_to_R), [R_to_B]"r"(R_to_B),
125        [G_to_B]"r"(G_to_B), [p_loop_end]"r"(p_loop_end)
126      : "memory", "hi", "lo"
127    );
128    if (num_pixels & 1) {
129      const uint32_t argb_ = data[0];
130      const uint32_t green = argb_ >> 8;
131      const uint32_t red = argb_ >> 16;
132      uint32_t new_blue = argb_;
133      new_red = red;
134      new_red -= ColorTransformDelta(m->green_to_red_, green);
135      new_red &= 0xff;
136      new_blue -= ColorTransformDelta(m->green_to_blue_, green);
137      new_blue -= ColorTransformDelta(m->red_to_blue_, red);
138      new_blue &= 0xff;
139      data[0] = (argb_ & 0xff00ff00u) | (new_red << 16) | (new_blue);
140    }
141  }
142  static WEBP_INLINE uint8_t TransformColorBlue(uint8_t green_to_blue,
143                                                uint8_t red_to_blue,
144                                                uint32_t argb) {
145    const uint32_t green = argb >> 8;
146    const uint32_t red = argb >> 16;
147    uint8_t new_blue = argb;
148    new_blue -= ColorTransformDelta(green_to_blue, green);
149    new_blue -= ColorTransformDelta(red_to_blue, red);
<span onclick='openModal()' class='match'>150    return (new_blue & 0xff);
151  }
152  static void CollectColorBlueTransforms_MIPSdspR2(const uint32_t* argb,
153                                                   int stride,
154                                                   int tile_width,
155                                                   int tile_height,
156                                                   int green_to_blue,
157                                                   int red_to_blue,
158                                                   int histo[]) {
</span>159    const int rtb = (red_to_blue << 16) | (red_to_blue & 0xffff);
160    const int gtb = (green_to_blue << 16) | (green_to_blue & 0xffff);
161    const uint32_t mask = 0xff00ffu;
162    while (tile_height-- > 0) {
163      int x;
164      const uint32_t* p_argb = argb;
165      argb += stride;
166      for (x = 0; x < (tile_width >> 1); ++x) {
167        int temp0, temp1, temp2, temp3, temp4, temp5, temp6;
168        __asm__ volatile (
169          "lw           %[temp0],  0(%[p_argb])             \n\t"
170          "lw           %[temp1],  4(%[p_argb])             \n\t"
171          "precr.qb.ph  %[temp2],  %[temp0],  %[temp1]      \n\t"
172          "ins          %[temp1],  %[temp0],  16,    16     \n\t"
173          "shra.ph      %[temp2],  %[temp2],  8             \n\t"
174          "shra.ph      %[temp3],  %[temp1],  8             \n\t"
175          "mul.ph       %[temp5],  %[temp2],  %[rtb]        \n\t"
176          "mul.ph       %[temp6],  %[temp3],  %[gtb]        \n\t"
177          "and          %[temp4],  %[temp1],  %[mask]       \n\t"
178          "addiu        %[p_argb], %[p_argb], 8             \n\t"
179          "shra.ph      %[temp5],  %[temp5],  5             \n\t"
180          "shra.ph      %[temp6],  %[temp6],  5             \n\t"
181          "subu.qb      %[temp2],  %[temp4],  %[temp5]      \n\t"
182          "subu.qb      %[temp2],  %[temp2],  %[temp6]      \n\t"
183          : [p_argb]"+&r"(p_argb), [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
184            [temp2]"=&r"(temp2), [temp3]"=&r"(temp3), [temp4]"=&r"(temp4),
185            [temp5]"=&r"(temp5), [temp6]"=&r"(temp6)
186          : [rtb]"r"(rtb), [gtb]"r"(gtb), [mask]"r"(mask)
187          : "memory", "hi", "lo"
188        );
189        ++histo[(uint8_t)(temp2 >> 16)];
190        ++histo[(uint8_t)temp2];
191      }
192      if (tile_width & 1) {
193        ++histo[TransformColorBlue(green_to_blue, red_to_blue, *p_argb)];
194      }
195    }
196  }
197  static WEBP_INLINE uint8_t TransformColorRed(uint8_t green_to_red,
198                                               uint32_t argb) {
199    const uint32_t green = argb >> 8;
200    uint32_t new_red = argb >> 16;
201    new_red -= ColorTransformDelta(green_to_red, green);
202    return (new_red & 0xff);
203  }
204  static void CollectColorRedTransforms_MIPSdspR2(const uint32_t* argb,
205                                                  int stride,
206                                                  int tile_width,
207                                                  int tile_height,
208                                                  int green_to_red,
209                                                  int histo[]) {
210    const int gtr = (green_to_red << 16) | (green_to_red & 0xffff);
211    while (tile_height-- > 0) {
212      int x;
213      const uint32_t* p_argb = argb;
214      argb += stride;
215      for (x = 0; x < (tile_width >> 1); ++x) {
216        int temp0, temp1, temp2, temp3, temp4;
217        __asm__ volatile (
218          "lw           %[temp0],  0(%[p_argb])             \n\t"
219          "lw           %[temp1],  4(%[p_argb])             \n\t"
220          "precrq.ph.w  %[temp4],  %[temp0],  %[temp1]      \n\t"
221          "ins          %[temp1],  %[temp0],  16,    16     \n\t"
222          "shra.ph      %[temp3],  %[temp1],  8             \n\t"
223          "mul.ph       %[temp2],  %[temp3],  %[gtr]        \n\t"
224          "addiu        %[p_argb], %[p_argb], 8             \n\t"
225          "shra.ph      %[temp2],  %[temp2],  5             \n\t"
226          "subu.qb      %[temp2],  %[temp4],  %[temp2]      \n\t"
227          : [p_argb]"+&r"(p_argb), [temp0]"=&r"(temp0), [temp1]"=&r"(temp1),
228            [temp2]"=&r"(temp2), [temp3]"=&r"(temp3), [temp4]"=&r"(temp4)
229          : [gtr]"r"(gtr)
230          : "memory", "hi", "lo"
231        );
232        ++histo[(uint8_t)(temp2 >> 16)];
233        ++histo[(uint8_t)temp2];
234      }
235      if (tile_width & 1) {
236        ++histo[TransformColorRed(green_to_red, *p_argb)];
237      }
238    }
239  }
240  extern void VP8LEncDspInitMIPSdspR2(void);
241  WEBP_TSAN_IGNORE_FUNCTION void VP8LEncDspInitMIPSdspR2(void) {
242    VP8LSubtractGreenFromBlueAndRed = SubtractGreenFromBlueAndRed_MIPSdspR2;
243    VP8LTransformColor = TransformColor_MIPSdspR2;
244    VP8LCollectColorBlueTransforms = CollectColorBlueTransforms_MIPSdspR2;
245    VP8LCollectColorRedTransforms = CollectColorRedTransforms_MIPSdspR2;
246  }
247  #else  
248  WEBP_DSP_INIT_STUB(VP8LEncDspInitMIPSdspR2)
249  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-hc2hc-direct.c</h3>
            <pre><code>1  #include "rdft/hc2hc.h"
2  typedef struct {
3       hc2hc_solver super;
4       const hc2hc_desc *desc;
5       khc2hc k;
6       int bufferedp;
7  } S;
8  typedef struct {
9       plan_hc2hc super;
10       khc2hc k;
11       plan *cld0, *cldm; &bsol;* children for 0th and middle butterflies */
12       INT r, m, v;
13       INT ms, vs, mb, me;
14       stride rs, brs;
15       twid *td;
16       const S *slv;
17  } P;
18  static void apply(const plan *ego_, R *IO)
19  {
20       const P *ego = (const P *) ego_;
21       plan_rdft *cld0 = (plan_rdft *) ego->cld0;
22       plan_rdft *cldm = (plan_rdft *) ego->cldm;
23       INT i, m = ego->m, v = ego->v;
24       INT mb = ego->mb, me = ego->me;
25       INT ms = ego->ms, vs = ego->vs;
26       for (i = 0; i < v; ++i, IO += vs) {
27  	  cld0->apply((plan *) cld0, IO, IO);
28  	  ego->k(IO + ms * mb, IO + (m - mb) * ms, 
29  		 ego->td->W, ego->rs, mb, me, ms);
30  	  cldm->apply((plan *) cldm, IO + (m/2) * ms, IO + (m/2) * ms);
31       }
32  }
33  static INT compute_batchsize(INT radix)
34  {
35       radix += 3;
36       radix &= -4;
37       return (radix + 2);
38  }
39  static void dobatch(const P *ego, R *IOp, R *IOm,
40  		    INT mb, INT me, R *bufp)
41  {
42       INT b = WS(ego->brs, 1);
43       INT rs = WS(ego->rs, 1);
44       INT r = ego->r;
45       INT ms = ego->ms;
46       R *bufm = bufp + b - 1;
47       X(cpy2d_ci)(IOp + mb * ms, bufp, r, rs, b, me - mb,  ms,  1, 1);
48       X(cpy2d_ci)(IOm - mb * ms, bufm, r, rs, b, me - mb, -ms, -1, 1);
49       ego->k(bufp, bufm, ego->td->W, ego->brs, mb, me, 1);
50       X(cpy2d_co)(bufp, IOp + mb * ms, r, b, rs, me - mb,  1,  ms, 1);
51       X(cpy2d_co)(bufm, IOm - mb * ms, r, b, rs, me - mb, -1, -ms, 1);
52  }
53  static void apply_buf(const plan *ego_, R *IO)
54  {
55       const P *ego = (const P *) ego_;
56       plan_rdft *cld0 = (plan_rdft *) ego->cld0;
57       plan_rdft *cldm = (plan_rdft *) ego->cldm;
58       INT i, j, m = ego->m, v = ego->v, r = ego->r;
59       INT mb = ego->mb, me = ego->me, ms = ego->ms;
60       INT batchsz = compute_batchsize(r);
61       R *buf;
62       size_t bufsz = r * batchsz * 2 * sizeof(R);
63       BUF_ALLOC(R *, buf, bufsz);
64       for (i = 0; i < v; ++i, IO += ego->vs) {
65  	  R *IOp = IO;
66  	  R *IOm = IO + m * ms;
67  	  cld0->apply((plan *) cld0, IO, IO);
68  	  for (j = mb; j + batchsz < me; j += batchsz) 	       
69  	       dobatch(ego, IOp, IOm, j, j + batchsz, buf);
70  	  dobatch(ego, IOp, IOm, j, me, buf);
71  	  cldm->apply((plan *) cldm, IO + ms * (m/2), IO + ms * (m/2));
72       }
73       BUF_FREE(buf, bufsz);
74  }
75  static void awake(plan *ego_, enum wakefulness wakefulness)
76  {
77       P *ego = (P *) ego_;
78       X(plan_awake)(ego->cld0, wakefulness);
79       X(plan_awake)(ego->cldm, wakefulness);
80       X(twiddle_awake)(wakefulness, &ego->td, ego->slv->desc->tw, 
81  		      ego->r * ego->m, ego->r, (ego->m - 1) / 2);
82  }
83  static void destroy(plan *ego_)
84  {
85       P *ego = (P *) ego_;
86       X(plan_destroy_internal)(ego->cld0);
87       X(plan_destroy_internal)(ego->cldm);
88       X(stride_destroy)(ego->rs);
89       X(stride_destroy)(ego->brs);
90  }
91  static void print(const plan *ego_, printer *p)
92  {
93       const P *ego = (const P *) ego_;
94       const S *slv = ego->slv;
95       const hc2hc_desc *e = slv->desc;
96       INT batchsz = compute_batchsize(ego->r);
97       if (slv->bufferedp)
98  	  p->print(p, "(hc2hc-directbuf/%D-%D/%D%v \"%s\"%(%p%)%(%p%))",
99  		   batchsz, ego->r, X(twiddle_length)(ego->r, e->tw), 
100  		   ego->v, e->nam, ego->cld0, ego->cldm);
101       else
102  	  p->print(p, "(hc2hc-direct-%D/%D%v \"%s\"%(%p%)%(%p%))",
103  		   ego->r, X(twiddle_length)(ego->r, e->tw), ego->v, e->nam,
104  		   ego->cld0, ego->cldm);
105  }
106  static int applicable0(const S *ego, rdft_kind kind, INT r)
107  {
108       const hc2hc_desc *e = ego->desc;
109       return (1
110  	     && r == e->radix
111  	     && kind == e->genus->kind
112  	  );
113  }
114  static int applicable(const S *ego, rdft_kind kind, INT r, INT m, INT v,
115  		      const planner *plnr)
116  {
117       if (!applicable0(ego, kind, r))
118            return 0;
119       if (NO_UGLYP(plnr) && X(ct_uglyp)((ego->bufferedp? (INT)512 : (INT)16),
120  				       v, m * r, r)) 
121  	  return 0;
<span onclick='openModal()' class='match'>122       return 1;
123  }
124  #define CLDMP(m, mstart, mcount) (2 * ((mstart) + (mcount)) == (m) + 2)
125  #define CLD0P(mstart) ((mstart) == 0)
126  static plan *mkcldw(const hc2hc_solver *ego_, 
127  		    rdft_kind kind, INT r, INT m, INT ms, INT v, INT vs, 
128  		    INT mstart, INT mcount,
</span>129  		    R *IO, planner *plnr)
130  {
131       const S *ego = (const S *) ego_;
132       P *pln;
133       const hc2hc_desc *e = ego->desc;
134       plan *cld0 = 0, *cldm = 0;
135       INT imid = (m / 2) * ms;
136       INT rs = m * ms;
137       static const plan_adt padt = {
138  	  0, awake, print, destroy
139       };
140       if (!applicable(ego, kind, r, m, v, plnr))
141            return (plan *)0;
142       cld0 = X(mkplan_d)(
143  	  plnr, 
144  	  X(mkproblem_rdft_1_d)((CLD0P(mstart) ?
145  				 X(mktensor_1d)(r, rs, rs) : X(mktensor_0d)()),
146  				X(mktensor_0d)(),
147  				TAINT(IO, vs), TAINT(IO, vs), 
148  				kind));
149       if (!cld0) goto nada;
150       cldm = X(mkplan_d)(
151  	  plnr, 
152  	  X(mkproblem_rdft_1_d)((CLDMP(m, mstart, mcount) ?
153  				 X(mktensor_1d)(r, rs, rs) : X(mktensor_0d)()),
154  				X(mktensor_0d)(),
155  				TAINT(IO + imid, vs), TAINT(IO + imid, vs),
156  				kind == R2HC ? R2HCII : HC2RIII));
157       if (!cldm) goto nada;
158       pln = MKPLAN_HC2HC(P, &padt, ego->bufferedp ? apply_buf : apply);
159       pln->k = ego->k;
160       pln->td = 0;
161       pln->r = r; pln->rs = X(mkstride)(r, rs);
162       pln->m = m; pln->ms = ms;
163       pln->v = v; pln->vs = vs;
164       pln->slv = ego;
165       pln->brs = X(mkstride)(r, 2 * compute_batchsize(r));
166       pln->cld0 = cld0;
167       pln->cldm = cldm;
168       pln->mb = mstart + CLD0P(mstart);
169       pln->me = mstart + mcount - CLDMP(m, mstart, mcount);
170       X(ops_zero)(&pln->super.super.ops);
171       X(ops_madd2)(v * ((pln->me - pln->mb) / e->genus->vl),
172  		  &e->ops, &pln->super.super.ops);
173       X(ops_madd2)(v, &cld0->ops, &pln->super.super.ops);
174       X(ops_madd2)(v, &cldm->ops, &pln->super.super.ops);
175       if (ego->bufferedp) 
176  	  pln->super.super.ops.other += 4 * r * (pln->me - pln->mb) * v;
177       pln->super.super.could_prune_now_p =
178  	  (!ego->bufferedp && r >= 5 && r < 64 && m >= r);
179       return &(pln->super.super);
180   nada:
181       X(plan_destroy_internal)(cld0);
182       X(plan_destroy_internal)(cldm);
183       return 0;
184  }
185  static void regone(planner *plnr, khc2hc codelet, const hc2hc_desc *desc,
186  		   int bufferedp)
187  {
188       S *slv = (S *)X(mksolver_hc2hc)(sizeof(S), desc->radix, mkcldw);
189       slv->k = codelet;
190       slv->desc = desc;
191       slv->bufferedp = bufferedp;
192       REGISTER_SOLVER(plnr, &(slv->super.super));
193       if (X(mksolver_hc2hc_hook)) {
194  	  slv = (S *)X(mksolver_hc2hc_hook)(sizeof(S), desc->radix, mkcldw);
195  	  slv->k = codelet;
196  	  slv->desc = desc;
197  	  slv->bufferedp = bufferedp;
198  	  REGISTER_SOLVER(plnr, &(slv->super.super));
199       }
200  }
201  void X(regsolver_hc2hc_direct)(planner *plnr, khc2hc codelet,
202  			       const hc2hc_desc *desc)
203  {
204       regone(plnr, codelet, desc, &bsol;* bufferedp */0);
205       regone(plnr, codelet, desc, &bsol;* bufferedp */1);
206  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc_mips_dsp_r2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-hc2hc-direct.c</div>
                </div>
                <div class="column column_space"><pre><code>150    return (new_blue & 0xff);
151  }
152  static void CollectColorBlueTransforms_MIPSdspR2(const uint32_t* argb,
153                                                   int stride,
154                                                   int tile_width,
155                                                   int tile_height,
156                                                   int green_to_blue,
157                                                   int red_to_blue,
158                                                   int histo[]) {
</pre></code></div>
                <div class="column column_space"><pre><code>122       return 1;
123  }
124  #define CLDMP(m, mstart, mcount) (2 * ((mstart) + (mcount)) == (m) + 2)
125  #define CLD0P(mstart) ((mstart) == 0)
126  static plan *mkcldw(const hc2hc_solver *ego_, 
127  		    rdft_kind kind, INT r, INT m, INT ms, INT v, INT vs, 
128  		    INT mstart, INT mcount,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    