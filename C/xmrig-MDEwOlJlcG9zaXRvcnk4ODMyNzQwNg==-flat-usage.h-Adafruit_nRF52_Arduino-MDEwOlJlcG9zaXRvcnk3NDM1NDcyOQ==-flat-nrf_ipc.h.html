
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 45.22968197879859%, Tokens: 16</h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-usage.h</h3>
            <pre><code>1  #ifndef XMRIG_USAGE_H
2  #define XMRIG_USAGE_H
3  #include "version.h"
4  #include <string>
5  namespace xmrig {
6  static inline const std::string &usage()
7  {
8      static std::string u;
9      if (!u.empty()) {
10          return u;
11      }
12      u += "Usage: " APP_ID " [OPTIONS]\n\nNetwork:\n";
13      u += "  -o, --url=URL                 URL of mining server\n";
14      u += "  -a, --algo=ALGO               mining algorithm https:&bsol;&bsol;xmrig.com/docs/algorithms\n";
15      u += "      --coin=COIN               specify coin instead of algorithm\n";
16      u += "  -u, --user=USERNAME           username for mining server\n";
17      u += "  -p, --pass=PASSWORD           password for mining server\n";
18      u += "  -O, --userpass=U:P            username:password pair for mining server\n";
19      u += "  -x, --proxy=HOST:PORT         connect through a SOCKS5 proxy\n";
20      u += "  -k, --keepalive               send keepalived packet for prevent timeout (needs pool support)\n";
21      u += "      --nicehash                enable nicehash.com support\n";
22      u += "      --rig-id=ID               rig identifier for pool-side statistics (needs pool support)\n";
23  #   ifdef XMRIG_FEATURE_TLS
24      u += "      --tls                     enable SSL/TLS support (needs pool support)\n";
25      u += "      --tls-fingerprint=HEX     pool TLS certificate fingerprint for strict certificate pinning\n";
26  #   endif
27      u += "      --dns-ipv6                prefer IPv6 records from DNS responses\n";
28      u += "      --dns-ttl=N               N seconds (default: 30) TTL for internal DNS cache\n";
29  #   ifdef XMRIG_FEATURE_HTTP
30      u += "      --daemon                  use daemon RPC instead of pool for solo mining\n";
<span onclick='openModal()' class='match'>31      u += "      --daemon-zmq-port         daemon's zmq-pub port number (only use it if daemon has it enabled)\n";
32      u += "      --daemon-poll-interval=N  daemon poll interval in milliseconds (default: 1000)\n";
33      u += "      --daemon-job-timeout=N    daemon job timeout in milliseconds (default: 15000)\n";
34      u += "      --self-select=URL         self-select block templates from URL\n";
35      u += "      --submit-to-origin        also submit solution back to self-select URL\n";
36  #   endif
37      u += "  -r, --retries=N               number of times to retry before switch to backup server (default: 5)\n";
38      u += "  -R, --retry-pause=N           time to pause between retries (default: 5)\n";
39      u += "      --user-agent              set custom user-agent string for pool\n";
40      u += "      --donate-level=N          donate level, default 1%% (1 minute in 100 minutes)\n";
41      u += "      --donate-over-proxy=N     control donate over xmrig-proxy feature\n";
42      u += "\nCPU backend:\n";
43      u += "      --no-cpu                  disable CPU mining backend\n";
44      u += "  -t, --threads=N               number of CPU threads, proper CPU affinity required for some optimizations.\n";
45      u += "      --cpu-affinity=N          set process affinity to CPU core(s), mask 0x3 for cores 0 and 1\n";
46      u += "  -v, --av=N                    algorithm variation, 0 auto select\n";
47      u += "      --cpu-priority=N          set process priority (0 idle, 2 normal to 5 highest)\n";
</span>48      u += "      --cpu-max-threads-hint=N  maximum CPU threads count (in percentage) hint for autoconfig\n";
49      u += "      --cpu-memory-pool=N       number of 2 MB pages for persistent memory pool, -1 (auto), 0 (disable)\n";
50      u += "      --cpu-no-yield            prefer maximum hashrate rather than system response/stability\n";
51      u += "      --no-huge-pages           disable huge pages support\n";
52  #   ifdef XMRIG_OS_LINUX
53      u += "      --hugepage-size=N         custom hugepage size in kB\n";
54  #   endif
55  #   ifdef XMRIG_ALGO_RANDOMX
56      u += "      --huge-pages-jit          enable huge pages support for RandomX JIT code\n";
57  #   endif
58      u += "      --asm=ASM                 ASM optimizations, possible values: auto, none, intel, ryzen, bulldozer\n";
59  #   if defined(__x86_64__) || defined(_M_AMD64)
60      u += "      --argon2-impl=IMPL        argon2 implementation: x86_64, SSE2, SSSE3, XOP, AVX2, AVX-512F\n";
61  #   endif
62  #   ifdef XMRIG_ALGO_RANDOMX
63      u += "      --randomx-init=N          threads count to initialize RandomX dataset\n";
64      u += "      --randomx-no-numa         disable NUMA support for RandomX\n";
65      u += "      --randomx-mode=MODE       RandomX mode: auto, fast, light\n";
66      u += "      --randomx-1gb-pages       use 1GB hugepages for RandomX dataset (Linux only)\n";
67      u += "      --randomx-wrmsr=N         write custom value(s) to MSR registers or disable MSR mod (-1)\n";
68      u += "      --randomx-no-rdmsr        disable reverting initial MSR values on exit\n";
69      u += "      --randomx-cache-qos       enable Cache QoS\n";
70  #   endif
71  #   ifdef XMRIG_FEATURE_OPENCL
72      u += "\nOpenCL backend:\n";
73      u += "      --opencl                  enable OpenCL mining backend\n";
74      u += "      --opencl-devices=N        comma separated list of OpenCL devices to use\n";
75      u += "      --opencl-platform=N       OpenCL platform index or name\n";
76      u += "      --opencl-loader=PATH      path to OpenCL-ICD-Loader (OpenCL.dll or libOpenCL.so)\n";
77      u += "      --opencl-no-cache         disable OpenCL cache\n";
78      u += "      --print-platforms         print available OpenCL platforms and exit\n";
79  #   endif
80  #   ifdef XMRIG_FEATURE_CUDA
81      u += "\nCUDA backend:\n";
82      u += "      --cuda                    enable CUDA mining backend\n";
83      u += "      --cuda-loader=PATH        path to CUDA plugin (xmrig-cuda.dll or libxmrig-cuda.so)\n";
84      u += "      --cuda-devices=N          comma separated list of CUDA devices to use\n";
85      u += "      --cuda-bfactor-hint=N     bfactor hint for autoconfig (0-12)\n";
86      u += "      --cuda-bsleep-hint=N      bsleep hint for autoconfig\n";
87  #   endif
88  #   ifdef XMRIG_FEATURE_NVML
89      u += "      --no-nvml                 disable NVML (NVIDIA Management Library) support\n";
90  #   endif
91  #   ifdef XMRIG_FEATURE_HTTP
92      u += "\nAPI:\n";
93      u += "      --api-worker-id=ID        custom worker-id for API\n";
94      u += "      --api-id=ID               custom instance ID for API\n";
95      u += "      --http-host=HOST          bind host for HTTP API (default: 127.0.0.1)\n";
96      u += "      --http-port=N             bind port for HTTP API\n";
97      u += "      --http-access-token=T     access token for HTTP API\n";
98      u += "      --http-no-restricted      enable full remote access to HTTP API (only if access token set)\n";
99  #   endif
100  #   ifdef XMRIG_FEATURE_TLS
101      u += "\nTLS:\n";
102      u += "      --tls-gen=HOSTNAME        generate TLS certificate for specific hostname\n";
103      u += "      --tls-cert=FILE           load TLS certificate chain from a file in the PEM format\n";
104      u += "      --tls-cert-key=FILE       load TLS certificate private key from a file in the PEM format\n";
105      u += "      --tls-dhparam=FILE        load DH parameters for DHE ciphers from a file in the PEM format\n";
106      u += "      --tls-protocols=N         enable specified TLS protocols, example: \"TLSv1 TLSv1.1 TLSv1.2 TLSv1.3\"\n";
107      u += "      --tls-ciphers=S           set list of available ciphers (TLSv1.2 and below)\n";
108      u += "      --tls-ciphersuites=S      set list of available TLSv1.3 ciphersuites\n";
109  #   endif
110      u += "\nLogging:\n";
111  #   ifdef HAVE_SYSLOG_H
112      u += "  -S, --syslog                  use system log for output messages\n";
113  #   endif
114      u += "  -l, --log-file=FILE           log all output to a file\n";
115      u += "      --print-time=N            print hashrate report every N seconds\n";
116  #   if defined(XMRIG_FEATURE_NVML) || defined(XMRIG_FEATURE_ADL)
117      u += "      --health-print-time=N     print health report every N seconds\n";
118  #   endif
119      u += "      --no-color                disable colored output\n";
120      u += "      --verbose                 verbose output\n";
121      u += "\nMisc:\n";
122      u += "  -c, --config=FILE             load a JSON-format configuration file\n";
123      u += "  -B, --background              run the miner in the background\n";
124      u += "  -V, --version                 output version information and exit\n";
125      u += "  -h, --help                    display this help and exit\n";
126      u += "      --dry-run                 test configuration and exit\n";
127  #   ifdef XMRIG_FEATURE_HWLOC
128      u += "      --export-topology         export hwloc topology to a XML file and exit\n";
129  #   endif
130  #   ifdef XMRIG_OS_WIN
131      u += "      --title                   set custom console window title\n";
132      u += "      --no-title                disable setting console window title\n";
133  #   endif
134      u += "      --pause-on-battery        pause mine on battery power\n";
135      u += "      --pause-on-active=N       pause mine when the user is active (resume after N seconds of last activity)\n";
136  #   ifdef XMRIG_FEATURE_BENCHMARK
137      u += "      --stress                  run continuous stress test to check system stability\n";
138      u += "      --bench=N                 run benchmark, N can be between 1M and 10M\n";
139  #   ifdef XMRIG_FEATURE_HTTP
140      u += "      --submit                  perform an online benchmark and submit result for sharing\n";
141      u += "      --verify=ID               verify submitted benchmark by ID\n";
142  #   endif
143      u += "      --seed=SEED               custom RandomX seed for benchmark\n";
144      u += "      --hash=HASH               compare benchmark result with specified hash\n";
145  #   endif
146  #   ifdef XMRIG_FEATURE_DMI
147      u += "      --no-dmi                  disable DMI/SMBIOS reader\n";
148  #   endif
149      return u;
150  }
151  } &bsol;* namespace xmrig */
152  #endif &bsol;* XMRIG_USAGE_H */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ipc.h</h3>
            <pre><code>1  #ifndef NRF_IPC_H__
2  #define NRF_IPC_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_IPC_TASK_SEND_0  = offsetof(NRF_IPC_Type, TASKS_SEND[0]),  
10      NRF_IPC_TASK_SEND_1  = offsetof(NRF_IPC_Type, TASKS_SEND[1]),  
11      NRF_IPC_TASK_SEND_2  = offsetof(NRF_IPC_Type, TASKS_SEND[2]),  
12      NRF_IPC_TASK_SEND_3  = offsetof(NRF_IPC_Type, TASKS_SEND[3]),  
13      NRF_IPC_TASK_SEND_4  = offsetof(NRF_IPC_Type, TASKS_SEND[4]),  
14      NRF_IPC_TASK_SEND_5  = offsetof(NRF_IPC_Type, TASKS_SEND[5]),  
15      NRF_IPC_TASK_SEND_6  = offsetof(NRF_IPC_Type, TASKS_SEND[6]),  
16      NRF_IPC_TASK_SEND_7  = offsetof(NRF_IPC_Type, TASKS_SEND[7]),  
17  #if (IPC_TASKS_NUM > 8) || defined(__NRFX_DOXYGEN__)
18      NRF_IPC_TASK_SEND_8  = offsetof(NRF_IPC_Type, TASKS_SEND[8]),  
19      NRF_IPC_TASK_SEND_9  = offsetof(NRF_IPC_Type, TASKS_SEND[9]),  
20      NRF_IPC_TASK_SEND_10 = offsetof(NRF_IPC_Type, TASKS_SEND[10]), 
21      NRF_IPC_TASK_SEND_11 = offsetof(NRF_IPC_Type, TASKS_SEND[11]), 
22      NRF_IPC_TASK_SEND_12 = offsetof(NRF_IPC_Type, TASKS_SEND[12]), 
23      NRF_IPC_TASK_SEND_13 = offsetof(NRF_IPC_Type, TASKS_SEND[13]), 
24      NRF_IPC_TASK_SEND_14 = offsetof(NRF_IPC_Type, TASKS_SEND[14]), 
25      NRF_IPC_TASK_SEND_15 = offsetof(NRF_IPC_Type, TASKS_SEND[15]), 
26  #endif 
27  } nrf_ipc_task_t;
28  typedef enum
29  {
<span onclick='openModal()' class='match'>30      NRF_IPC_EVENT_RECEIVE_0  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[0]),  
31      NRF_IPC_EVENT_RECEIVE_1  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[1]),  
32      NRF_IPC_EVENT_RECEIVE_2  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[2]),  
33      NRF_IPC_EVENT_RECEIVE_3  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[3]),  
34      NRF_IPC_EVENT_RECEIVE_4  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[4]),  
35      NRF_IPC_EVENT_RECEIVE_5  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[5]),  
36      NRF_IPC_EVENT_RECEIVE_6  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[6]),  
37      NRF_IPC_EVENT_RECEIVE_7  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[7]),  
38  #if (IPC_EVENTS_NUM > 8) || defined(__NRFX_DOXYGEN__)
39      NRF_IPC_EVENT_RECEIVE_8  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[8]),  
40      NRF_IPC_EVENT_RECEIVE_9  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[9]),  
41      NRF_IPC_EVENT_RECEIVE_10 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[10]), 
42      NRF_IPC_EVENT_RECEIVE_11 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[11]), 
43      NRF_IPC_EVENT_RECEIVE_12 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[12]), 
44      NRF_IPC_EVENT_RECEIVE_13 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[13]), 
45      NRF_IPC_EVENT_RECEIVE_14 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[14]), 
46      NRF_IPC_EVENT_RECEIVE_15 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[15]), 
</span>47  #endif 
48  } nrf_ipc_event_t;
49  typedef enum
50  {
51      NRF_IPC_CHANNEL_0 = IPC_RECEIVE_CNF_CHEN0_Msk,   
52      NRF_IPC_CHANNEL_1 = IPC_RECEIVE_CNF_CHEN1_Msk,   
53      NRF_IPC_CHANNEL_2 = IPC_RECEIVE_CNF_CHEN2_Msk,   
54      NRF_IPC_CHANNEL_3 = IPC_RECEIVE_CNF_CHEN3_Msk,   
55      NRF_IPC_CHANNEL_4 = IPC_RECEIVE_CNF_CHEN4_Msk,   
56      NRF_IPC_CHANNEL_5 = IPC_RECEIVE_CNF_CHEN5_Msk,   
57      NRF_IPC_CHANNEL_6 = IPC_RECEIVE_CNF_CHEN6_Msk,   
58      NRF_IPC_CHANNEL_7 = IPC_RECEIVE_CNF_CHEN7_Msk,   
59  #if (IPC_CH_NUM > 8) || defined(__NRFX_DOXYGEN__)
60      NRF_IPC_CHANNEL_8  = IPC_RECEIVE_CNF_CHEN8_Msk,  
61      NRF_IPC_CHANNEL_9  = IPC_RECEIVE_CNF_CHEN9_Msk,  
62      NRF_IPC_CHANNEL_10 = IPC_RECEIVE_CNF_CHEN10_Msk, 
63      NRF_IPC_CHANNEL_11 = IPC_RECEIVE_CNF_CHEN11_Msk, 
64      NRF_IPC_CHANNEL_12 = IPC_RECEIVE_CNF_CHEN12_Msk, 
65      NRF_IPC_CHANNEL_13 = IPC_RECEIVE_CNF_CHEN13_Msk, 
66      NRF_IPC_CHANNEL_14 = IPC_RECEIVE_CNF_CHEN14_Msk, 
67      NRF_IPC_CHANNEL_15 = IPC_RECEIVE_CNF_CHEN15_Msk, 
68  #endif 
69  } nrf_ipc_channel_t;
70  typedef enum
71  {
72      NRF_IPC_INT_RECEIVE_0  = IPC_INTEN_RECEIVE0_Msk,  
73      NRF_IPC_INT_RECEIVE_1  = IPC_INTEN_RECEIVE1_Msk,  
74      NRF_IPC_INT_RECEIVE_2  = IPC_INTEN_RECEIVE2_Msk,  
75      NRF_IPC_INT_RECEIVE_3  = IPC_INTEN_RECEIVE3_Msk,  
76      NRF_IPC_INT_RECEIVE_4  = IPC_INTEN_RECEIVE4_Msk,  
77      NRF_IPC_INT_RECEIVE_5  = IPC_INTEN_RECEIVE5_Msk,  
78      NRF_IPC_INT_RECEIVE_6  = IPC_INTEN_RECEIVE6_Msk,  
79      NRF_IPC_INT_RECEIVE_7  = IPC_INTEN_RECEIVE7_Msk,  
80  #if (IPC_EVENTS_NUM > 8) || defined(__NRFX_DOXYGEN__)
81      NRF_IPC_INT_RECEIVE_8  = IPC_INTEN_RECEIVE8_Msk,  
82      NRF_IPC_INT_RECEIVE_9  = IPC_INTEN_RECEIVE9_Msk,  
83      NRF_IPC_INT_RECEIVE_10 = IPC_INTEN_RECEIVE10_Msk, 
84      NRF_IPC_INT_RECEIVE_11 = IPC_INTEN_RECEIVE11_Msk, 
85      NRF_IPC_INT_RECEIVE_12 = IPC_INTEN_RECEIVE12_Msk, 
86      NRF_IPC_INT_RECEIVE_13 = IPC_INTEN_RECEIVE13_Msk, 
87      NRF_IPC_INT_RECEIVE_14 = IPC_INTEN_RECEIVE14_Msk, 
88      NRF_IPC_INT_RECEIVE_15 = IPC_INTEN_RECEIVE15_Msk, 
89  #endif 
90  } nrf_ipc_int_mask_t;
91  NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task);
92  NRF_STATIC_INLINE uint32_t nrf_ipc_task_address_get(NRF_IPC_Type const * p_reg,
93                                                      nrf_ipc_task_t       task);
94  NRF_STATIC_INLINE void nrf_ipc_event_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event);
95  NRF_STATIC_INLINE bool nrf_ipc_event_check(NRF_IPC_Type const * p_reg, nrf_ipc_event_t event);
96  NRF_STATIC_INLINE uint32_t nrf_ipc_event_address_get(NRF_IPC_Type const * p_reg,
97                                                       nrf_ipc_event_t      event);
98  NRF_STATIC_INLINE void nrf_ipc_int_enable(NRF_IPC_Type * p_reg, uint32_t mask);
99  NRF_STATIC_INLINE void nrf_ipc_int_disable(NRF_IPC_Type * p_reg, uint32_t mask);
100  NRF_STATIC_INLINE uint32_t nrf_ipc_int_enable_check(NRF_IPC_Type const * p_reg, uint32_t mask);
101  NRF_STATIC_INLINE uint32_t nrf_ipc_int_pending_get(NRF_IPC_Type const * p_reg);
102  NRF_STATIC_INLINE void nrf_ipc_subscribe_set(NRF_IPC_Type * p_reg,
103                                               nrf_ipc_task_t task,
104                                               uint8_t        channel);
105  NRF_STATIC_INLINE void nrf_ipc_subscribe_clear(NRF_IPC_Type * p_reg, nrf_ipc_task_t task);
106  NRF_STATIC_INLINE void nrf_ipc_publish_set(NRF_IPC_Type *  p_reg,
107                                             nrf_ipc_event_t event,
108                                             uint8_t         channel);
109  NRF_STATIC_INLINE void nrf_ipc_publish_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event);
110  NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
111                                                 uint8_t        index,
112                                                 uint32_t       channels_mask);
113  NRF_STATIC_INLINE uint32_t nrf_ipc_send_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
114  NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
115                                                    uint8_t        index,
116                                                    uint32_t       channels_mask);
117  NRF_STATIC_INLINE uint32_t nrf_ipc_receive_config_get(NRF_IPC_Type * const p_reg, uint8_t index);
118  NRF_STATIC_INLINE void nrf_ipc_gpmem_set(NRF_IPC_Type * p_reg,
119                                           uint8_t        index,
120                                           uint32_t       data);
121  NRF_STATIC_INLINE uint32_t nrf_ipc_gpmem_get(NRF_IPC_Type const * p_reg, uint8_t index);
122  NRF_STATIC_INLINE nrf_ipc_task_t nrf_ipc_send_task_get(uint8_t index);
123  NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index);
124  #ifndef NRF_DECLARE_ONLY
125  NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
126  {
127      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
128  }
129  NRF_STATIC_INLINE uint32_t nrf_ipc_task_address_get(NRF_IPC_Type const * p_reg,
130                                                      nrf_ipc_task_t       task)
131  {
132      return ((uint32_t)p_reg + (uint32_t)task);
133  }
134  NRF_STATIC_INLINE void nrf_ipc_event_clear(NRF_IPC_Type * p_reg, nrf_ipc_event_t event)
135  {
136      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
137  }
138  NRF_STATIC_INLINE bool nrf_ipc_event_check(NRF_IPC_Type const * p_reg, nrf_ipc_event_t event)
139  {
140      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
141  }
142  NRF_STATIC_INLINE uint32_t nrf_ipc_event_address_get(NRF_IPC_Type const * p_reg,
143                                                       nrf_ipc_event_t      event)
144  {
145      return ((uint32_t)p_reg + (uint32_t)event);
146  }
147  NRF_STATIC_INLINE void nrf_ipc_int_enable(NRF_IPC_Type * p_reg, uint32_t mask)
148  {
149      p_reg->INTENSET = mask;
150  }
151  NRF_STATIC_INLINE void nrf_ipc_int_disable(NRF_IPC_Type * p_reg, uint32_t mask)
152  {
153      p_reg->INTENCLR = mask;
154  }
155  NRF_STATIC_INLINE uint32_t nrf_ipc_int_enable_check(NRF_IPC_Type const * p_reg, uint32_t mask)
156  {
157      return p_reg->INTENSET & mask;
158  }
159  NRF_STATIC_INLINE uint32_t nrf_ipc_int_pending_get(NRF_IPC_Type const * p_reg)
160  {
161      return p_reg->INTPEND;
162  }
163  NRF_STATIC_INLINE void nrf_ipc_subscribe_set(NRF_IPC_Type * p_reg,
164                                               nrf_ipc_task_t task,
165                                               uint8_t        channel)
166  {
167      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
168              ((uint32_t)channel | IPC_SUBSCRIBE_SEND_EN_Msk);
169  }
170  NRF_STATIC_INLINE void nrf_ipc_subscribe_clear(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
171  {
172      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
173  }
174  NRF_STATIC_INLINE void nrf_ipc_publish_set(NRF_IPC_Type *  p_reg,
175                                             nrf_ipc_event_t event,
176                                             uint8_t         channel)
177  {
178      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
179              ((uint32_t)channel | IPC_PUBLISH_RECEIVE_EN_Msk);
180  }
181  NRF_STATIC_INLINE void nrf_ipc_publish_clear(NRF_IPC_Type *  p_reg, nrf_ipc_event_t event)
182  {
183      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
184  }
185  NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
186                                                 uint8_t        index,
187                                                 uint32_t       channels_mask)
188  {
189      p_reg->SEND_CNF[index] = channels_mask;
190  }
191  NRF_STATIC_INLINE uint32_t nrf_ipc_send_config_get(NRF_IPC_Type * const p_reg, uint8_t index)
192  {
193      return p_reg->SEND_CNF[index];
194  }
195  NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
196                                                    uint8_t        index,
197                                                    uint32_t       channels_mask)
198  {
199      p_reg->RECEIVE_CNF[index] = channels_mask;
200  }
201  NRF_STATIC_INLINE uint32_t nrf_ipc_receive_config_get(NRF_IPC_Type * const p_reg, uint8_t index)
202  {
203      return p_reg->RECEIVE_CNF[index];
204  }
205  NRF_STATIC_INLINE void nrf_ipc_gpmem_set(NRF_IPC_Type * p_reg,
206                                           uint8_t        index,
207                                           uint32_t       data)
208  {
209      NRFX_ASSERT(index < IPC_GPMEM_NUM);
210      p_reg->GPMEM[index] = data;
211  }
212  NRF_STATIC_INLINE uint32_t nrf_ipc_gpmem_get(NRF_IPC_Type const * p_reg,  uint8_t index)
213  {
214      NRFX_ASSERT(index < IPC_GPMEM_NUM);
215      return p_reg->GPMEM[index];
216  }
217  NRF_STATIC_INLINE nrf_ipc_task_t nrf_ipc_send_task_get(uint8_t index)
218  {
219      NRFX_ASSERT(index < IPC_CH_NUM);
220      return (nrf_ipc_task_t)(NRFX_OFFSETOF(NRF_IPC_Type, TASKS_SEND[index]));
221  }
222  NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
223  {
224      NRFX_ASSERT(index < IPC_CH_NUM);
225      return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
226  }
227  #endif 
228  #ifdef __cplusplus
229  }
230  #endif
231  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-usage.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ipc.h</div>
                </div>
                <div class="column column_space"><pre><code>31      u += "      --daemon-zmq-port         daemon's zmq-pub port number (only use it if daemon has it enabled)\n";
32      u += "      --daemon-poll-interval=N  daemon poll interval in milliseconds (default: 1000)\n";
33      u += "      --daemon-job-timeout=N    daemon job timeout in milliseconds (default: 15000)\n";
34      u += "      --self-select=URL         self-select block templates from URL\n";
35      u += "      --submit-to-origin        also submit solution back to self-select URL\n";
36  #   endif
37      u += "  -r, --retries=N               number of times to retry before switch to backup server (default: 5)\n";
38      u += "  -R, --retry-pause=N           time to pause between retries (default: 5)\n";
39      u += "      --user-agent              set custom user-agent string for pool\n";
40      u += "      --donate-level=N          donate level, default 1%% (1 minute in 100 minutes)\n";
41      u += "      --donate-over-proxy=N     control donate over xmrig-proxy feature\n";
42      u += "\nCPU backend:\n";
43      u += "      --no-cpu                  disable CPU mining backend\n";
44      u += "  -t, --threads=N               number of CPU threads, proper CPU affinity required for some optimizations.\n";
45      u += "      --cpu-affinity=N          set process affinity to CPU core(s), mask 0x3 for cores 0 and 1\n";
46      u += "  -v, --av=N                    algorithm variation, 0 auto select\n";
47      u += "      --cpu-priority=N          set process priority (0 idle, 2 normal to 5 highest)\n";
</pre></code></div>
                <div class="column column_space"><pre><code>30      NRF_IPC_EVENT_RECEIVE_0  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[0]),  
31      NRF_IPC_EVENT_RECEIVE_1  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[1]),  
32      NRF_IPC_EVENT_RECEIVE_2  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[2]),  
33      NRF_IPC_EVENT_RECEIVE_3  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[3]),  
34      NRF_IPC_EVENT_RECEIVE_4  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[4]),  
35      NRF_IPC_EVENT_RECEIVE_5  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[5]),  
36      NRF_IPC_EVENT_RECEIVE_6  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[6]),  
37      NRF_IPC_EVENT_RECEIVE_7  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[7]),  
38  #if (IPC_EVENTS_NUM > 8) || defined(__NRFX_DOXYGEN__)
39      NRF_IPC_EVENT_RECEIVE_8  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[8]),  
40      NRF_IPC_EVENT_RECEIVE_9  = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[9]),  
41      NRF_IPC_EVENT_RECEIVE_10 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[10]), 
42      NRF_IPC_EVENT_RECEIVE_11 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[11]), 
43      NRF_IPC_EVENT_RECEIVE_12 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[12]), 
44      NRF_IPC_EVENT_RECEIVE_13 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[13]), 
45      NRF_IPC_EVENT_RECEIVE_14 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[14]), 
46      NRF_IPC_EVENT_RECEIVE_15 = offsetof(NRF_IPC_Type, EVENTS_RECEIVE[15]), 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    