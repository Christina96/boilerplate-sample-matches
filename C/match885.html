<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-session.c &amp; inf-adopted-session.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-session.c &amp; inf-adopted-session.c
      </h3>
<h1 align="center">
        11.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-session.c (11.90184%)<th>inf-adopted-session.c (11.672684%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1748-1778)<td><a href="#" name="0">(1529-1563)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1239-1287)<td><a href="#" name="1">(1404-1445)</a><td align="center"><font color="#f20000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(261-282)<td><a href="#" name="2">(926-948)</a><td align="center"><font color="#cc0000">16</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(178-198)<td><a href="#" name="3">(112-133)</a><td align="center"><font color="#cc0000">16</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(874-896)<td><a href="#" name="4">(971-993)</a><td align="center"><font color="#a50000">13</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(42-60)<td><a href="#" name="5">(57-89)</a><td align="center"><font color="#a50000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-session.h&gt;
2 #include &lt;libinftext/inf-text-default-insert-operation.h&gt;
3 #include &lt;libinftext/inf-text-default-delete-operation.h&gt;
4 #include &lt;libinftext/inf-text-remote-delete-operation.h&gt;
5 #include &lt;libinftext/inf-text-insert-operation.h&gt;
6 #include &lt;libinftext/inf-text-delete-operation.h&gt;
7 #include &lt;libinftext/inf-text-move-operation.h&gt;
8 #include &lt;libinftext/inf-text-chunk.h&gt;
9 #include &lt;libinftext/inf-text-user.h&gt;
10 #include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
11 #include &lt;libinfinity/common/inf-xml-util.h&gt;
12 #include &lt;libinfinity/common/inf-error.h&gt;
13 #include &lt;libinfinity/inf-i18n.h&gt;
14 #include &lt;libinfinity/inf-signals.h&gt;
15 #include &lt;libxml/tree.h&gt;
16 #include &lt;string.h&gt;
17 #include &lt;errno.h&gt;
18 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfTextSessionLocalUser InfTextSessionLocalUser;
19 struct _InfTextSessionLocalUser {
20   InfTextSession* session;
21   InfTextUser* user;
22   GTimeVal last_caret_update;
23   InfIoTimeout* caret_timeout;
24 };
25 typedef struct _InfTextSessionPrivate InfTextSessionPrivate;
26 struct _InfTextSessionPrivate {
27   guint caret_update_interval;
28   GSList* local_users;
29 };
30 enum {
31   PROP_0,
32   PROP_CARET_UPDATE_INTERVAL
33 };</b></font>
34 typedef struct _InfTextSessionInsertForeachData
35   InfTextSessionInsertForeachData;
36 typedef struct _InfTextSessionEraseForeachData
37   InfTextSessionEraseForeachData;
38 struct _InfTextSessionInsertForeachData {
39   guint position;
40   InfTextChunk* chunk;
41   InfUser* user;
42 };
43 struct _InfTextSessionEraseForeachData {
44   guint position;
45   guint length;
46   InfUser* user;
47 };
48 #define INF_TEXT_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_SESSION, InfTextSessionPrivate))
49 static GQuark inf_text_session_error_quark;
50 G_DEFINE_TYPE_WITH_CODE(InfTextSession, inf_text_session, INF_ADOPTED_TYPE_SESSION,
51   G_ADD_PRIVATE(InfTextSession))
52 static guint
53 inf_text_session_timeval_diff(GTimeVal* first,
54                               GTimeVal* second)
55 {
56   g_assert(first-&gt;tv_sec &gt; second-&gt;tv_sec ||
57            (first-&gt;tv_sec == second-&gt;tv_sec &amp;&amp;
58             first-&gt;tv_usec &gt;= second-&gt;tv_usec));
59   return (first-&gt;tv_sec - second-&gt;tv_sec) * 1000 +
60          (first-&gt;tv_usec+500)/1000 - (second-&gt;tv_usec+500)/1000;
61 }
62 static void
63 inf_text_session_segment_to_xml(GIConv* cd,
64                                 xmlNodePtr xml,
65                                 gconstpointer text,
66                                 gsize* bytes,                                 guint author)
67 {
68   gchar utf8_text[1024];
69   gsize result;
70   gsize bytes_left;
71   gchar* inbuf;
72   gchar* outbuf;
73   bytes_left = 1024;
74   inbuf = *(gchar**)(gpointer)&amp;text;   outbuf = utf8_text;
75   result = g_iconv(
76     *cd,
77     &amp;inbuf,
78     bytes,
79     &amp;outbuf,
80     &amp;bytes_left
81   );
82   g_assert(result == 0 || errno == E2BIG);
83   inf_xml_util_add_child_text(xml, utf8_text, 1024 - bytes_left);
84   inf_xml_util_set_attribute_uint(xml, "author", author);
85 }
86 static gpointer
87 inf_text_session_segment_from_xml(GIConv* cd,
88                                   xmlNodePtr xml,
89                                   guint* length,
90                                   gsize* bytes,
91                                   guint* author,
92                                   GError** error)
93 {
94   gsize bytes_read;
95   gchar* utf8_text;
96   gpointer text;
97   if(!inf_xml_util_get_attribute_uint_required(xml, "author", author, error))
98     return NULL;
99   utf8_text = inf_xml_util_get_child_text(xml, &amp;bytes_read, length, error);
100   if(!utf8_text)
101     return NULL;
102   text = g_convert_with_iconv(
103     utf8_text,
104     bytes_read,
105     *cd,
106     NULL,
107     bytes,
108     error
109   );
110   g_free(utf8_text);
111   return text;
112 }
113 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static InfTextSessionLocalUser*
114 inf_text_session_find_local_user(InfTextSession* session,
115                                  InfTextUser* user)
116 {
117   InfTextSessionPrivate* priv;
118   GSList* item;
119   InfTextSessionLocalUser* local;
120   priv = INF_TEXT_SESSION_PRIVATE(session);
121   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
122   {
123     local = (InfTextSessionLocalUser*)item-&gt;data;
124     if(local-&gt;user == user)
125       return local;
126   }
127   return NULL;
128 }
129 static void</b></font>
130 inf_text_session_broadcast_caret_selection(InfTextSession* session,
131                                            InfTextSessionLocalUser* local)
132 {
133   InfAdoptedOperation* operation;
134   InfAdoptedAlgorithm* algorithm;
135   InfAdoptedRequest* request;
136   guint buf_len;
137   guint position;
138   int sel;
139   guint end;
140   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
141   position = inf_text_user_get_caret_position(local-&gt;user);
142   sel = inf_text_user_get_selection_length(local-&gt;user);
143   end = position + sel;
144   buf_len = inf_text_buffer_get_length(
145     INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)))
146   );
147   if(position &gt; buf_len)
148     position = buf_len;
149   if(end &gt; buf_len)
150     end = buf_len;
151   if(end &gt;= position)
152     sel = (int)(end - position);
153   else
154     sel = -(int)(position - end);
155   operation = INF_ADOPTED_OPERATION(
156     inf_text_move_operation_new(position, sel)
157   );
158   request = inf_adopted_algorithm_generate_request(
159     algorithm,
160     INF_ADOPTED_REQUEST_DO,
161     INF_ADOPTED_USER(local-&gt;user),
162     operation
163   );
164   inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
165   g_object_unref(operation);
166   inf_adopted_session_broadcast_request(
167     INF_ADOPTED_SESSION(session),
168     request
169   );
170   g_object_unref(request);
171 <a name="2"></a>
172   g_get_current_time(&amp;local-&gt;last_caret_update);
173 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if(local-&gt;caret_timeout != NULL)
174   {
175     inf_io_remove_timeout(
176       inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
177       local-&gt;caret_timeout
178     );
179     local-&gt;caret_timeout = NULL;
180   }
181 }
182 static void
183 inf_text_session_caret_update_timeout_func(gpointer user_data)
184 {
185   InfTextSessionLocalUser* local;
186   local = (InfTextSessionLocalUser*)user_data;
187   local-&gt;caret_timeout = NULL;
188   inf_text_session_broadcast_caret_selection(local-&gt;session, local);
189 }
190 static void</b></font>
191 inf_text_session_selection_changed_cb(InfTextUser* user,
192                                       guint position,
193                                       gint sel,
194                                       gboolean by_request,
195                                       gpointer user_data)
196 {
197   InfTextSession* session;
198   InfTextSessionPrivate* priv;
199   InfAdoptedAlgorithm* algorithm;
200   InfAdoptedRequest* execute_request;
201   InfTextSessionLocalUser* local;
202   GTimeVal current;
203   guint diff;
204   session = INF_TEXT_SESSION(user_data);
205   priv = INF_TEXT_SESSION_PRIVATE(session);
206   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
207   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
208   g_assert( (execute_request != NULL &amp;&amp; by_request == FALSE) ||
209             (execute_request == NULL &amp;&amp; by_request == TRUE));
210   if(execute_request == NULL)
211   {
212     local = inf_text_session_find_local_user(session, user);
213     g_assert(local != NULL);
214     g_get_current_time(&amp;current);
215     diff = inf_text_session_timeval_diff(&amp;current, &amp;local-&gt;last_caret_update);
216     if(diff &lt; priv-&gt;caret_update_interval)
217     {
218       if(local-&gt;caret_timeout == NULL)
219       {
220         local-&gt;caret_timeout = inf_io_add_timeout(
221           inf_adopted_session_get_io(INF_ADOPTED_SESSION(local-&gt;session)),
222           priv-&gt;caret_update_interval - diff,
223           inf_text_session_caret_update_timeout_func,
224           local,
225           NULL
226         );
227       }
228     }
229     else
230     {
231       inf_text_session_broadcast_caret_selection(session, local);
232     }
233   }
234 }
235 static void
236 inf_text_session_add_local_user(InfTextSession* session,
237                                 InfTextUser* user)
238 {
239   InfTextSessionPrivate* priv;
240   InfTextSessionLocalUser* local;
241   priv = INF_TEXT_SESSION_PRIVATE(session);
242   local = g_slice_new(InfTextSessionLocalUser);
243   local-&gt;session = session;
244   local-&gt;user = user;
245   g_get_current_time(&amp;local-&gt;last_caret_update);
246   local-&gt;caret_timeout = NULL;
247   priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
248   g_signal_connect_after(
249     G_OBJECT(user),
250     "selection-changed",
251     G_CALLBACK(inf_text_session_selection_changed_cb),
252     session
253   );
254 }
255 static void
256 inf_text_session_remove_local_user(InfTextSession* session,
257                                    InfTextSessionLocalUser* local)
258 {
259   InfTextSessionPrivate* priv;
260   priv = INF_TEXT_SESSION_PRIVATE(session);
261   if(local-&gt;caret_timeout != NULL)
262   {
263     inf_io_remove_timeout(
264       inf_adopted_session_get_io(INF_ADOPTED_SESSION(session)),
265       local-&gt;caret_timeout
266     );
267   }
268   inf_signal_handlers_disconnect_by_func(
269     G_OBJECT(local-&gt;user),
270     G_CALLBACK(inf_text_session_selection_changed_cb),
271     session
272   );
273   g_slice_free(InfTextSessionLocalUser, local);
274   priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
275 }
276 static void
277 inf_text_session_local_user_added_cb(InfUserTable* user_table,
278                                      InfUser* user,
279                                      gpointer user_data)
280 {
281   g_assert(INF_TEXT_IS_USER(user));
282   inf_text_session_add_local_user(
283     INF_TEXT_SESSION(user_data),
284     INF_TEXT_USER(user)
285   );
286 }
287 static void
288 inf_text_session_local_user_removed_cb(InfUserTable* user_table,
289                                        InfUser* user,
290                                        gpointer user_data)
291 {
292   InfTextSession* session;
293   InfTextSessionLocalUser* local;
294   g_assert(INF_TEXT_IS_USER(user));
295   session = INF_TEXT_SESSION(user_data);
296   local = inf_text_session_find_local_user(session, INF_TEXT_USER(user));
297   g_assert(local != NULL);
298   inf_text_session_remove_local_user(session, local);
299 }
300 static void
301 inf_text_session_block_local_users_selection_changed(InfTextSession* session)
302 {
303   InfTextSessionPrivate* priv;
304   GSList* item;
305   InfTextSessionLocalUser* local;
306   priv = INF_TEXT_SESSION_PRIVATE(session);
307   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
308   {
309     local = (InfTextSessionLocalUser*)item-&gt;data;
310     inf_signal_handlers_block_by_func(
311       G_OBJECT(local-&gt;user),
312       G_CALLBACK(inf_text_session_selection_changed_cb),
313       session
314     );
315   }
316 }
317 static void
318 inf_text_session_unblock_local_users_selection_changed(InfTextSession* sess)
319 {
320   InfTextSessionPrivate* priv;
321   GSList* item;
322   InfTextSessionLocalUser* local;
323   priv = INF_TEXT_SESSION_PRIVATE(sess);
324   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
325   {
326     local = (InfTextSessionLocalUser*)item-&gt;data;
327     inf_signal_handlers_unblock_by_func(
328       G_OBJECT(local-&gt;user),
329       G_CALLBACK(inf_text_session_selection_changed_cb),
330       sess
331     );
332   }
333 }
334 static void
335 inf_text_session_buffer_text_inserted_cb_foreach_func(InfUser* user,
336                                                       gpointer user_data)
337 {
338   InfTextSessionInsertForeachData* data;
339   guint position;
340   gint length;
341   data = (InfTextSessionInsertForeachData*)user_data;
342   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
343   {
344     position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
345     length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
346     inf_text_move_operation_transform_insert(
347       data-&gt;position,
348       inf_text_chunk_get_length(data-&gt;chunk),
349       &amp;position,
350       &amp;length,
351       user == data-&gt;user ? FALSE : TRUE
352     );
353     inf_text_user_set_selection(
354       INF_TEXT_USER(user),
355       position,
356       length,
357       user == data-&gt;user ? TRUE : FALSE
358     );
359   }
360 }
361 static void
362 inf_text_session_buffer_text_erased_cb_foreach_func(InfUser* user,
363                                                     gpointer user_data)
364 {
365   InfTextSessionEraseForeachData* data;
366   guint position;
367   gint length;
368   data = (InfTextSessionEraseForeachData*)user_data;
369   if(inf_user_get_status(user) != INF_USER_UNAVAILABLE)
370   {
371     position = inf_text_user_get_caret_position(INF_TEXT_USER(user));
372     length = inf_text_user_get_selection_length(INF_TEXT_USER(user));
373     inf_text_move_operation_transform_delete(
374       data-&gt;position,
375       data-&gt;length,
376       &amp;position,
377       &amp;length
378     );
379     inf_text_user_set_selection(
380       INF_TEXT_USER(user),
381       position,
382       length,
383       user == data-&gt;user ? TRUE : FALSE
384     );
385   }
386 }
387 static void
388 inf_text_session_buffer_text_inserted_cb(InfTextBuffer* buffer,
389                                          guint pos,
390                                          InfTextChunk* chunk,
391                                          InfUser* user,
392                                          gpointer user_data)
393 {
394   InfTextSession* session;
395   InfTextSessionPrivate* priv;
396   InfUserTable* user_table;
397   InfAdoptedAlgorithm* algorithm;
398   InfAdoptedRequest* execute_request;
399   InfAdoptedOperation* operation;
400   InfAdoptedRequest* request;
401   InfTextSessionInsertForeachData data;
402   g_assert(INF_TEXT_IS_USER(user));
403   session = INF_TEXT_SESSION(user_data);
404   priv = INF_TEXT_SESSION_PRIVATE(session);
405   user_table = inf_session_get_user_table(INF_SESSION(session));
406   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
407   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
408   if(execute_request == NULL)
409   {
410     operation = INF_ADOPTED_OPERATION(
411       inf_text_default_insert_operation_new(pos, chunk)
412     );
413     request = inf_adopted_algorithm_generate_request(
414       algorithm,
415       INF_ADOPTED_REQUEST_DO,
416       INF_ADOPTED_USER(user),
417       operation
418     );
419     inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
420     inf_adopted_session_broadcast_request(
421       INF_ADOPTED_SESSION(session),
422       request
423     );
424     g_object_unref(request);
425     g_object_unref(operation);
426   }
427   data.position = pos;
428   data.chunk = chunk;
429   data.user = user;
430   inf_text_session_block_local_users_selection_changed(session);
431   inf_user_table_foreach_user(
432     user_table,
433     inf_text_session_buffer_text_inserted_cb_foreach_func,
434     &amp;data
435   );
436 #if 0
437   if(user != NULL)
438   {
439     inf_text_user_set_selection(
440       INF_TEXT_USER(user),
441       pos + inf_text_chunk_get_length(chunk),
442       0,
443       TRUE
444     );
445   }
446 #endif
447   inf_text_session_unblock_local_users_selection_changed(session);
448 }
449 static void
450 inf_text_session_buffer_text_erased_cb(InfTextBuffer* buffer,
451                                        guint pos,
452                                        InfTextChunk* chunk,
453                                        InfUser* user,
454                                        gpointer user_data)
455 {
456   InfTextSession* session;
457   InfTextSessionPrivate* priv;
458   InfUserTable* user_table;
459   InfAdoptedAlgorithm* algorithm;
460   InfAdoptedRequest* execute_request;
461   InfAdoptedOperation* operation;
462   InfAdoptedRequest* request;
463   InfTextSessionEraseForeachData data;
464   g_assert(INF_TEXT_IS_USER(user));
465   session = INF_TEXT_SESSION(user_data);
466   priv = INF_TEXT_SESSION_PRIVATE(session);
467   user_table = inf_session_get_user_table(INF_SESSION(session));
468   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
469   execute_request = inf_adopted_algorithm_get_execute_request(algorithm);
470   if(execute_request == NULL)
471   {
472     operation = INF_ADOPTED_OPERATION(
473       inf_text_default_delete_operation_new(pos, chunk)
474     );
475     request = inf_adopted_algorithm_generate_request(
476       algorithm,
477       INF_ADOPTED_REQUEST_DO,
478       INF_ADOPTED_USER(user),
479       operation
480     );
481     inf_adopted_algorithm_execute_request(algorithm, request, FALSE, NULL);
482     inf_adopted_session_broadcast_request(
483       INF_ADOPTED_SESSION(session),
484       request
485     );
486     g_object_unref(request);
487     g_object_unref(operation);
488   }
489   data.position = pos;
490   data.length = inf_text_chunk_get_length(chunk);
491   data.user = user;
492   inf_text_session_block_local_users_selection_changed(session);
493   inf_user_table_foreach_user(
494     user_table,
495     inf_text_session_buffer_text_erased_cb_foreach_func,
496     &amp;data
497   );
498 #if 0
499   if(user != NULL)
500     inf_text_user_set_selection(INF_TEXT_USER(user), pos, 0, TRUE);
501 #endif
502   inf_text_session_unblock_local_users_selection_changed(session);
503 }
504 static void
505 inf_text_session_init_text_handlers_user_foreach_func(InfUser* user,
506                                                       gpointer user_data)
507 {
508   g_assert(INF_TEXT_IS_USER(user));
509   inf_text_session_add_local_user(
510     INF_TEXT_SESSION(user_data),
511     INF_TEXT_USER(user)
512   );
513 }
514 static void
515 inf_text_session_init_text_handlers(InfTextSession* session)
516 {
517   InfTextBuffer* buffer;
518   InfAdoptedAlgorithm* algorithm;
519   InfUserTable* user_table;
520   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
521   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
522   user_table = inf_session_get_user_table(INF_SESSION(session));
523   g_signal_connect(
524     G_OBJECT(buffer),
525     "text-inserted",
526     G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
527     session
528   );
529   g_signal_connect(
530     G_OBJECT(buffer),
531     "text-erased",
532     G_CALLBACK(inf_text_session_buffer_text_erased_cb),
533     session
534   );
535   g_signal_connect(
536     G_OBJECT(user_table),
537     "add-local-user",
538     G_CALLBACK(inf_text_session_local_user_added_cb),
539     session
540   );
541   g_signal_connect(
542     G_OBJECT(user_table),
543     "remove-local-user",
544     G_CALLBACK(inf_text_session_local_user_removed_cb),
545     session
546   );
547   inf_user_table_foreach_local_user(
548     user_table,
549     inf_text_session_init_text_handlers_user_foreach_func,
550     session
551   );
552 }
553 static void
554 inf_text_session_init(InfTextSession* session)
555 {
556   InfTextSessionPrivate* priv;
557   priv = INF_TEXT_SESSION_PRIVATE(session);
558   priv-&gt;caret_update_interval = 500;
559 }
560 static void
561 inf_text_session_constructed(GObject* object)
562 {
563   InfTextSession* session;
564   InfTextSessionPrivate* priv;
565   InfTextBuffer* buffer;
566   InfSessionStatus status;
567   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;constructed(object);
568   session = INF_TEXT_SESSION(object);
569   priv = INF_TEXT_SESSION_PRIVATE(session);
570   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
571   g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
572   g_assert(
573     status == INF_SESSION_RUNNING ||
574     inf_text_buffer_get_length(buffer) == 0
575   );
576   if(status == INF_SESSION_RUNNING)
577     inf_text_session_init_text_handlers(session);
578 }
579 static void
580 inf_text_session_dispose(GObject* object)
581 {
582   InfTextSession* session;
583   InfTextSessionPrivate* priv;
584   InfTextBuffer* buffer;
585   InfUserTable* user_table;
586   InfAdoptedAlgorithm* algorithm;
587   session = INF_TEXT_SESSION(object);
588   priv = INF_TEXT_SESSION_PRIVATE(session);
589   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
590   user_table = inf_session_get_user_table(INF_SESSION(session));
591   algorithm = inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session));
592   while(priv-&gt;local_users != NULL)
593   {
594     inf_text_session_remove_local_user(
595       session,
596       (InfTextSessionLocalUser*)priv-&gt;local_users-&gt;data
597     );
598   }
599   inf_signal_handlers_disconnect_by_func(
600     G_OBJECT(buffer),
601     G_CALLBACK(inf_text_session_buffer_text_inserted_cb),
602     session
603   );
604   inf_signal_handlers_disconnect_by_func(
605     G_OBJECT(buffer),
606     G_CALLBACK(inf_text_session_buffer_text_erased_cb),
607     session
608   );
609   inf_signal_handlers_disconnect_by_func(
610     G_OBJECT(user_table),
611     G_CALLBACK(inf_text_session_local_user_added_cb),
612     session
613   );
614   inf_signal_handlers_disconnect_by_func(
615     G_OBJECT(user_table),
616     G_CALLBACK(inf_text_session_local_user_removed_cb),
617     session
618   );
619   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;dispose(object);
620 }
621 static void
622 inf_text_session_finalize(GObject* object)
623 {
624   InfTextSession* session;
625   InfTextSessionPrivate* priv;
626   session = INF_TEXT_SESSION(object);
627   priv = INF_TEXT_SESSION_PRIVATE(session);
628   G_OBJECT_CLASS(inf_text_session_parent_class)-&gt;finalize(object);
629 }
630 static void
631 inf_text_session_set_property(GObject* object,
632                               guint prop_id,
633                               const GValue* value,
634                               GParamSpec* pspec)
635 {
636   InfTextSession* session;
637   InfTextSessionPrivate* priv;
638   session = INF_TEXT_SESSION(object);
639   priv = INF_TEXT_SESSION_PRIVATE(session);
640   switch(prop_id)
641   {
642 <a name="4"></a>  case PROP_CARET_UPDATE_INTERVAL:
643     priv-&gt;caret_update_interval = g_value_get_uint(value);
644     break;
645 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  default:
646     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
647     break;
648   }
649 }
650 static void
651 inf_text_session_get_property(GObject* object,
652                               guint prop_id,
653                               GValue* value,
654                               GParamSpec* pspec)
655 {
656   InfTextSession* session;
657   InfTextSessionPrivate* priv;
658   session = INF_TEXT_SESSION(object);
659   priv = INF_TEXT_SESSION_PRIVATE(session);
660   switch(prop_id)
661   {
662   case PROP_CARET_UPDATE_INTERVAL:
663     g_value_set_uint(value, priv-&gt;caret_update_interval);
664     break;</b></font>
665   default:
666     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
667     break;
668   }
669 }
670 static InfCommunicationScope
671 inf_text_session_handle_user_color_change(InfTextSession* session,
672                                           InfXmlConnection* connection,
673                                           xmlNodePtr xml,
674                                           GError** error)
675 {
676   InfUserTable* user_table;
677   guint user_id;
678   InfUser* user;
679   gdouble hue;
680   user_table = inf_session_get_user_table(INF_SESSION(session));
681   if(!inf_xml_util_get_attribute_uint_required(xml, "id", &amp;user_id, error))
682     return INF_COMMUNICATION_SCOPE_PTP;
683   if(!inf_xml_util_get_attribute_double_required(xml, "hue", &amp;hue, error))
684     return INF_COMMUNICATION_SCOPE_PTP;
685   user = inf_user_table_lookup_user_by_id(user_table, user_id);
686   if(user == NULL)
687   {
688     g_set_error(
689       error,
690       inf_user_error_quark(),
691       INF_USER_ERROR_NO_SUCH_USER,
692       _("No such user with ID '%u'"),
693       user_id
694     );
695     return INF_COMMUNICATION_SCOPE_PTP;
696   }
697   if(inf_user_get_status(user) == INF_USER_UNAVAILABLE ||
698      inf_user_get_connection(user) != connection)
699   {
700     g_set_error_literal(
701       error,
702       inf_user_error_quark(),
703       INF_USER_ERROR_NOT_JOINED,
704       _("User did not join from this connection")
705     );
706     return INF_COMMUNICATION_SCOPE_PTP;
707   }
708   g_assert(INF_TEXT_IS_USER(user));
709   if(hue &lt; 0.0 || hue &gt; 1.0)
710   {
711     g_set_error(
712       error,
713       inf_text_session_error_quark,
714       INF_TEXT_SESSION_ERROR_INVALID_HUE,
715       _("Invalid hue value: '%g'"),
716       hue
717     );
718     return INF_COMMUNICATION_SCOPE_PTP;
719   }
720   g_object_set(G_OBJECT(user), "hue", hue, NULL);
721   return INF_COMMUNICATION_SCOPE_GROUP;
722 }
723 static void
724 inf_text_session_to_xml_sync(InfSession* session,
725                              xmlNodePtr parent)
726 {
727   InfTextBuffer* buffer;
728   InfTextBufferIter* iter;
729   xmlNodePtr xml;
730   gboolean result;
731   gchar* text;
732   gsize total_bytes;
733   gsize bytes_left;
734   GIConv cd;
735   INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;to_xml_sync(
736     session,
737     parent
738   );
739   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
740   cd = g_iconv_open("UTF-8", inf_text_buffer_get_encoding(buffer));
741   iter = inf_text_buffer_create_begin_iter(buffer);
742   if(iter != NULL)
743   {
744     result = TRUE;
745     while(result == TRUE)
746     {
747       text = inf_text_buffer_iter_get_text(buffer, iter);
748       total_bytes = inf_text_buffer_iter_get_bytes(buffer, iter);
749       bytes_left = total_bytes;
750       while(bytes_left &gt; 0)
751       {
752         xml = xmlNewChild(parent, NULL, (const xmlChar*)"sync-segment", NULL);
753         inf_text_session_segment_to_xml(
754           &amp;cd,
755           xml,
756           text + total_bytes - bytes_left,
757           &amp;bytes_left,
758           inf_text_buffer_iter_get_author(buffer, iter)
759         );
760       }
761       g_free(text);
762       result = inf_text_buffer_iter_next(buffer, iter);
763     }
764     inf_text_buffer_destroy_iter(buffer, iter);
765   }
766   g_iconv_close(cd);
767 }
768 static gboolean
769 inf_text_session_process_xml_sync(InfSession* session,
770                                   InfXmlConnection* connection,
771                                   const xmlNodePtr xml,
772                                   GError** error)
773 {
774   InfTextBuffer* buffer;
775   GIConv cd;
776   gpointer text;
777   gsize bytes;
778   guint length;
779   guint author;
780   InfUser* user;
781   if(strcmp((const char*)xml-&gt;name, "sync-segment") == 0)
782   {
783     buffer = INF_TEXT_BUFFER(inf_session_get_buffer(session));
784     cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
785     text = inf_text_session_segment_from_xml(
786       &amp;cd,
787       xml,
788       &amp;length,
789       &amp;bytes,
790       &amp;author,
791       error
792     );
793     g_iconv_close(cd);
794     if(text == NULL) return FALSE;
795     if(author != 0)
796     {
797       user = inf_user_table_lookup_user_by_id(
798         inf_session_get_user_table(session),
799         author
800       );
801       if(user == NULL)
802       {
803         g_free(text);
804         g_set_error(
805           error,
806           inf_user_error_quark(),
807           INF_USER_ERROR_NO_SUCH_USER,
808           _("No such user with ID '%u'"),
809           author
810         );
811         return FALSE;
812       }
813     }
814     else
815     {
816       user = NULL;
817     }
818     inf_text_buffer_insert_text(
819       buffer,
820       inf_text_buffer_get_length(buffer),
821       text,
822       bytes,
823       length,
824       user
825     );
826     g_free(text);
827     return TRUE;
828   }
829   else
830   {
831     return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_sync(
832       session,
833       connection,
834       xml,
835       error
836     );
837   }
838 }
839 static InfCommunicationScope
840 inf_text_session_process_xml_run(InfSession* session,
841                                  InfXmlConnection* connection,
842                                  const xmlNodePtr xml,
843                                  GError** error)
844 {
845   if(strcmp((const char*)xml-&gt;name, "user-color-change") == 0)
846   {
847     return inf_text_session_handle_user_color_change(
848       INF_TEXT_SESSION(session),
849       connection,
850       xml,
851       error
852     );
853   }
854   else
855   {
856     return INF_SESSION_CLASS(inf_text_session_parent_class)-&gt;process_xml_run(
857       session,
858       connection,
859       xml,
860       error
861     );
862   }
863 }
864 static GArray*
865 inf_text_session_get_xml_user_props(InfSession* session,
866                                     InfXmlConnection* connection,
867                                     const xmlNodePtr xml)
868 {
869   InfSessionClass* parent_class;
870   GArray* array;
871   GParameter* parameter;
872   guint caret;
873   gint selection;
874   gdouble hue;
875   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
876   array = parent_class-&gt;get_xml_user_props(session, connection, xml);
877   if(inf_xml_util_get_attribute_uint(xml, "caret", &amp;caret, NULL))
878   {
879     parameter = inf_session_get_user_property(array, "caret-position");
880     g_value_init(&amp;parameter-&gt;value, G_TYPE_UINT);
881     g_value_set_uint(&amp;parameter-&gt;value, caret);
882   }
883   parameter = inf_session_get_user_property(array, "selection-length");
884   g_value_init(&amp;parameter-&gt;value, G_TYPE_INT);
885   if(inf_xml_util_get_attribute_int(xml, "selection", &amp;selection, NULL))
886     g_value_set_int(&amp;parameter-&gt;value, selection);
887   else
888     g_value_set_int(&amp;parameter-&gt;value, 0);
889   parameter = inf_session_get_user_property(array, "hue");
890   g_value_init(&amp;parameter-&gt;value, G_TYPE_DOUBLE);
891   if(inf_xml_util_get_attribute_double(xml, "hue", &amp;hue, NULL))
892     g_value_set_double(&amp;parameter-&gt;value, hue);
893   else
894     g_value_set_double(&amp;parameter-&gt;value, g_random_double());
895   return array;
896 }
897 static void
898 inf_text_session_set_xml_user_props(InfSession* session,
899                                     const GParameter* params,
900                                     guint n_params,
901                                     xmlNodePtr xml)
902 {
903   InfSessionClass* parent_class;
904   const GParameter* param;
905   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
906   parent_class-&gt;set_xml_user_props(session, params, n_params, xml);
907   param = inf_session_lookup_user_property(
908     params,
909     n_params,
910     "caret-position"
911   );
912   if(param != NULL)
913   {
914     inf_xml_util_set_attribute_uint(
915       xml,
916       "caret",
917       g_value_get_uint(&amp;param-&gt;value)
918     );
919   }
920   param = inf_session_lookup_user_property(
921     params,
922     n_params,
923     "selection-length"
924   );
925   if(param != NULL)
926   {
927     inf_xml_util_set_attribute_int(
928       xml,
929       "selection",
930       g_value_get_int(&amp;param-&gt;value)
931     );
932   }
933   param = inf_session_lookup_user_property(
934     params,
935     n_params,
936     "hue"
937   );
938   if(param != NULL)
939   {
940     inf_xml_util_set_attribute_double(
941       xml,
942 <a name="1"></a>      "hue",
943       g_value_get_double(&amp;param-&gt;value)
944     );
945 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
946 }
947 static gboolean
948 inf_text_session_validate_user_props(InfSession* session,
949                                      const GParameter* params,
950                                      guint n_params,
951                                      InfUser* exclude,
952                                      GError** error)
953 {
954   InfSessionClass* parent_class;
955   const GParameter* caret;
956   gboolean result;
957   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
958   result = parent_class-&gt;validate_user_props(
959     session,
960     params,
961     n_params,
962     exclude,
963     error
964   );
965   if(result == FALSE) return FALSE;
966   caret = inf_session_lookup_user_property(
967     params,
968     n_params,
969     "caret-position"
970   );
971   if(caret == NULL)
972   {
973     g_set_error_literal(
974       error,
975       inf_request_error_quark(),
976       INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
977       _("\"caret\" attribute in user message is missing")
978     );
979     return FALSE;
980   }
981   return result;
982 }
983 static InfUser*</b></font>
984 inf_text_session_user_new(InfSession* session,
985                           GParameter* params,
986                           guint n_params)
987 {
988   GObject* object;
989   object = g_object_newv(INF_TEXT_TYPE_USER, n_params, params);
990   return INF_USER(object);
991 }
992 static void
993 inf_text_session_synchronization_complete(InfSession* session,
994                                           InfXmlConnection* connection)
995 {
996   InfSessionClass* parent_class;
997   InfSessionStatus status;
998   parent_class = INF_SESSION_CLASS(inf_text_session_parent_class);
999   status = inf_session_get_status(session);
1000   parent_class-&gt;synchronization_complete(session, connection);
1001   if(status == INF_SESSION_SYNCHRONIZING)
1002     inf_text_session_init_text_handlers(INF_TEXT_SESSION(session));
1003 }
1004 static void
1005 inf_text_session_request_to_xml(InfAdoptedSession* session,
1006                                 xmlNodePtr xml,
1007                                 InfAdoptedRequest* request,
1008                                 InfAdoptedStateVector* diff_vec,
1009                                 gboolean for_sync)
1010 {
1011   InfTextChunk* chunk;
1012   InfTextChunkIter iter;
1013   gboolean result;
1014   xmlNodePtr op_xml;
1015   gchar* utf8_text;
1016   gsize bytes_read;
1017   gsize bytes_written;
1018   GIConv cd;
1019   xmlNodePtr child;
1020   const gchar* text;
1021   gsize total_bytes;
1022   gsize bytes_left;
1023   InfAdoptedOperation* operation;
1024   switch(inf_adopted_request_get_request_type(request))
1025   {
1026   case INF_ADOPTED_REQUEST_DO:
1027     operation = inf_adopted_request_get_operation(request);
1028     if(INF_TEXT_IS_INSERT_OPERATION(operation))
1029     {
1030       op_xml = xmlNewNode(NULL, (const xmlChar*)"insert-caret");
1031       inf_xml_util_set_attribute_uint(
1032         op_xml,
1033         "pos",
1034         inf_text_insert_operation_get_position(
1035           INF_TEXT_INSERT_OPERATION(operation)
1036         )
1037       );
1038       g_assert(INF_TEXT_IS_DEFAULT_INSERT_OPERATION(operation));
1039       chunk = inf_text_default_insert_operation_get_chunk(
1040         INF_TEXT_DEFAULT_INSERT_OPERATION(operation)
1041       );
1042       result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
1043       g_assert(result == TRUE);
1044       utf8_text = g_convert(
1045         inf_text_chunk_iter_get_text(&amp;iter),
1046         inf_text_chunk_iter_get_bytes(&amp;iter),
1047         "UTF-8",
1048         inf_text_chunk_get_encoding(chunk),
1049         &amp;bytes_read,
1050         &amp;bytes_written,
1051         NULL
1052       );
1053       g_assert(utf8_text != NULL);
1054       g_assert(bytes_read == inf_text_chunk_iter_get_bytes(&amp;iter));
1055       inf_xml_util_add_child_text(op_xml, utf8_text, bytes_written);
1056       g_free(utf8_text);
1057       g_assert(inf_text_chunk_iter_next(&amp;iter) == FALSE);
1058     }
1059     else if(INF_TEXT_IS_DELETE_OPERATION(operation))
1060     {
1061       op_xml = xmlNewNode(NULL, (const xmlChar*)"delete-caret");
1062       inf_xml_util_set_attribute_uint(
1063         op_xml,
1064         "pos",
1065         inf_text_delete_operation_get_position(
1066           INF_TEXT_DELETE_OPERATION(operation)
1067         )
1068       );
1069       if(for_sync == TRUE)
1070       {
1071         g_assert(INF_TEXT_IS_DEFAULT_DELETE_OPERATION(operation));
1072         chunk = inf_text_default_delete_operation_get_chunk(
1073           INF_TEXT_DEFAULT_DELETE_OPERATION(operation)
1074         );
1075         cd = g_iconv_open("UTF-8", inf_text_chunk_get_encoding(chunk));
1076         result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
1077         while(result == TRUE)
1078         {
1079           text = inf_text_chunk_iter_get_text(&amp;iter);
1080           total_bytes = inf_text_chunk_iter_get_bytes(&amp;iter);
1081           bytes_left = total_bytes;
1082           child = xmlNewChild(op_xml, NULL, (const xmlChar*)"segment", NULL);
1083           while(bytes_left &gt; 0)
1084           {
1085             inf_text_session_segment_to_xml(
1086               &amp;cd,
1087               child,
1088               text + total_bytes - bytes_left,
1089               &amp;bytes_left,
1090               inf_text_chunk_iter_get_author(&amp;iter)
1091             );
1092           }
1093           result = inf_text_chunk_iter_next(&amp;iter);
1094         }
1095         g_iconv_close(cd);
1096       }
1097       else
1098       {
1099         inf_xml_util_set_attribute_uint(
1100           op_xml,
1101           "len",
1102           inf_text_delete_operation_get_length(
1103             INF_TEXT_DELETE_OPERATION(operation)
1104           )
1105         );
1106       }
1107     }
1108     else if(for_sync == FALSE &amp;&amp; INF_TEXT_IS_MOVE_OPERATION(operation))
1109     {
1110       op_xml = xmlNewNode(NULL, (const xmlChar*)"move");
1111       inf_xml_util_set_attribute_uint(
1112         op_xml,
1113         "caret",
1114         inf_text_move_operation_get_position(
1115           INF_TEXT_MOVE_OPERATION(operation)
1116         )
1117       );
1118       inf_xml_util_set_attribute_int(
1119         op_xml,
1120         "selection",
1121         inf_text_move_operation_get_length(INF_TEXT_MOVE_OPERATION(operation))
1122       );
1123     }
1124     else if(for_sync == FALSE &amp;&amp; INF_ADOPTED_IS_NO_OPERATION(operation))
1125     {
1126       op_xml = xmlNewNode(NULL, (const xmlChar*)"no-op");
1127     }
1128     else
1129     {
1130       g_assert_not_reached();
1131     }
1132     break;
1133   case INF_ADOPTED_REQUEST_UNDO:
1134     op_xml = xmlNewNode(NULL, (const xmlChar*)"undo-caret");
1135     break;
1136   case INF_ADOPTED_REQUEST_REDO:
1137     op_xml = xmlNewNode(NULL, (const xmlChar*)"redo-caret");
1138     break;
1139   default:
1140     g_assert_not_reached();
1141     break;
1142   }
1143   g_assert(op_xml != NULL);
1144   inf_adopted_session_write_request_info(
1145     session,
1146     request,
1147     diff_vec,
1148     xml,
1149     op_xml
1150   );
1151 }
1152 static InfAdoptedRequest*
1153 inf_text_session_xml_to_request(InfAdoptedSession* session,
1154                                 xmlNodePtr xml,
1155                                 InfAdoptedStateVector* diff_vec,
1156                                 gboolean for_sync,
1157                                 GError** error)
1158 {
1159   InfTextBuffer* buffer;
1160   InfAdoptedUser* user;
1161   guint user_id;
1162   InfAdoptedStateVector* vector;
1163   xmlNodePtr op_xml;
1164   InfAdoptedOperation* operation;
1165   InfAdoptedRequestType type;
1166   InfAdoptedRequest* request;
1167   guint pos;
1168   gchar* text;
1169   gsize bytes;
1170   InfTextChunk* chunk;
1171   gchar* utf8_text;
1172   gsize in_bytes;
1173   guint length;
1174   xmlNodePtr child;
1175   GIConv cd;
1176   guint author;
1177   gboolean cmp;
1178   gint selection;
1179   buffer = INF_TEXT_BUFFER(inf_session_get_buffer(INF_SESSION(session)));
1180   cmp = inf_adopted_session_read_request_info(
1181     session,
1182     xml,
1183     diff_vec,
1184     &amp;user,
1185     &amp;vector,
1186     &amp;op_xml,
1187     error
1188   );
1189   if(cmp == FALSE) return FALSE;
1190   user_id = (user == NULL) ? 0 : inf_user_get_id(INF_USER(user));
1191   if(strcmp((const char*)op_xml-&gt;name, "insert") == 0 ||
1192      strcmp((const char*)op_xml-&gt;name, "insert-caret") == 0)
1193   {
1194     type = INF_ADOPTED_REQUEST_DO;
1195     if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
1196       goto fail;
1197     utf8_text = inf_xml_util_get_child_text(op_xml, &amp;in_bytes, &amp;length, error);
1198     if(!utf8_text)
1199       goto fail;
1200     text = g_convert(
1201       utf8_text,
1202       in_bytes,
1203       inf_text_buffer_get_encoding(buffer),
1204       "UTF-8",
1205       NULL,
1206       &amp;bytes,
1207       error
1208     );
1209     g_free(utf8_text);
1210     if(text == NULL) goto fail;
1211     chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
1212     inf_text_chunk_insert_text(chunk, 0, text, bytes, length, user_id);
1213     g_free(text);
1214     operation = INF_ADOPTED_OPERATION(
1215       inf_text_default_insert_operation_new(pos, chunk)
1216     );
1217     inf_text_chunk_free(chunk);
1218   }
1219   else if(strcmp((const char*)op_xml-&gt;name, "delete") == 0 ||
1220           strcmp((const char*)op_xml-&gt;name, "delete-caret") == 0)
1221   {
1222     type = INF_ADOPTED_REQUEST_DO;
1223     if(!inf_xml_util_get_attribute_uint_required(op_xml, "pos", &amp;pos, error))
1224       goto fail;
1225     if(for_sync == TRUE)
1226     {
1227       chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(buffer));
1228       cd = g_iconv_open(inf_text_buffer_get_encoding(buffer), "UTF-8");
1229       g_assert(cd != (GIConv)(-1));
1230       for(child = op_xml-&gt;children; child != NULL; child = child-&gt;next)
1231       {
1232         if(strcmp((const char*)child-&gt;name, "segment") == 0)
1233         {
1234           text = inf_text_session_segment_from_xml(
1235             &amp;cd,
1236             child,
1237             &amp;length,
1238             &amp;bytes,
1239             &amp;author,
1240             error
1241           );
1242           if(text == NULL)
1243           {
1244             inf_text_chunk_free(chunk);
1245             g_iconv_close(cd);
1246             goto fail;
1247           }
1248           else
1249           {
1250             inf_text_chunk_insert_text(
1251               chunk,
1252               inf_text_chunk_get_length(chunk),
1253               text,
1254               bytes,
1255               length,
1256               author
1257             );
1258             g_free(text);
1259           }
1260         }
1261         else
1262         {
1263         }
1264       }
1265       g_iconv_close(cd);
1266       operation = INF_ADOPTED_OPERATION(
1267         inf_text_default_delete_operation_new(pos, chunk)
1268       );
1269       inf_text_chunk_free(chunk);
1270     }
1271     else
1272     {
1273       cmp = inf_xml_util_get_attribute_uint_required(
1274         op_xml,
1275         "len",
1276         &amp;length,
1277         error
1278       );
1279       if(cmp == FALSE) goto fail;
1280       operation = INF_ADOPTED_OPERATION(
1281         inf_text_remote_delete_operation_new(pos, length)
1282       );
1283     }
1284   }
1285   else if(strcmp((const char*)op_xml-&gt;name, "move") == 0)
1286   {
1287     type = INF_ADOPTED_REQUEST_DO;
1288     cmp = inf_xml_util_get_attribute_uint_required(
1289       op_xml,
1290       "caret",
1291       &amp;pos,
1292       error
1293     );
1294     if(cmp == FALSE) goto fail;
1295     cmp = inf_xml_util_get_attribute_int_required(
1296       op_xml,
1297       "selection",
1298       &amp;selection,
1299       error
1300     );
1301     if(cmp == FALSE) goto fail;
1302     operation = INF_ADOPTED_OPERATION(
1303       inf_text_move_operation_new(pos, selection)
1304     );
1305   }
1306   else if(strcmp((const char*)op_xml-&gt;name, "no-op") == 0)
1307   {
1308     type = INF_ADOPTED_REQUEST_DO;
1309     operation = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
1310   }
1311   else if(strcmp((const char*)op_xml-&gt;name, "undo") == 0 ||
1312           strcmp((const char*)op_xml-&gt;name, "undo-caret") == 0)
1313   {
1314     type = INF_ADOPTED_REQUEST_UNDO;
1315   }
1316   else if(strcmp((const char*)op_xml-&gt;name, "redo") == 0 ||
1317           strcmp((const char*)op_xml-&gt;name, "redo-caret") == 0)
1318   {
1319     type = INF_ADOPTED_REQUEST_REDO;
1320   }
1321   else
1322   {
1323     goto fail;
1324   }
1325   switch(type)
1326   {
1327   case INF_ADOPTED_REQUEST_DO:
1328     g_assert(operation != NULL);
1329     request = inf_adopted_request_new_do(
1330       vector,
1331       user_id,
1332       operation,
1333       g_get_real_time()
1334     );
1335     g_object_unref(operation);
1336     break;
1337   case INF_ADOPTED_REQUEST_UNDO:
1338     request = inf_adopted_request_new_undo(
1339       vector,
1340       user_id,
1341       g_get_real_time()
1342     );
1343     break;
1344   case INF_ADOPTED_REQUEST_REDO:
1345     request = inf_adopted_request_new_redo(
1346       vector,
1347       user_id,
1348       g_get_real_time()
1349     );
1350     break;
1351   default:
1352     g_assert_not_reached();
1353     break;
1354   }
1355   inf_adopted_state_vector_free(vector);
1356   return request;
1357 <a name="0"></a>fail:
1358   inf_adopted_state_vector_free(vector);
1359   return NULL;
1360 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
1361 static void
1362 inf_text_session_class_init(InfTextSessionClass* text_session_class)
1363 {
1364   GObjectClass* object_class;
1365   InfSessionClass* session_class;
1366   InfAdoptedSessionClass* adopted_session_class;
1367   object_class = G_OBJECT_CLASS(text_session_class);
1368   session_class = INF_SESSION_CLASS(text_session_class);
1369   adopted_session_class = INF_ADOPTED_SESSION_CLASS(text_session_class);
1370   object_class-&gt;constructed = inf_text_session_constructed;
1371   object_class-&gt;dispose = inf_text_session_dispose;
1372   object_class-&gt;finalize = inf_text_session_finalize;
1373   object_class-&gt;set_property = inf_text_session_set_property;
1374   object_class-&gt;get_property = inf_text_session_get_property;
1375   session_class-&gt;to_xml_sync = inf_text_session_to_xml_sync;
1376   session_class-&gt;process_xml_sync = inf_text_session_process_xml_sync;
1377   session_class-&gt;process_xml_run = inf_text_session_process_xml_run;
1378   session_class-&gt;get_xml_user_props = inf_text_session_get_xml_user_props;
1379   session_class-&gt;set_xml_user_props = inf_text_session_set_xml_user_props;
1380   session_class-&gt;validate_user_props = inf_text_session_validate_user_props;
1381   session_class-&gt;user_new = inf_text_session_user_new;
1382   session_class-&gt;synchronization_complete =</b></font>
1383     inf_text_session_synchronization_complete;
1384   adopted_session_class-&gt;xml_to_request = inf_text_session_xml_to_request;
1385   adopted_session_class-&gt;request_to_xml = inf_text_session_request_to_xml;
1386   inf_text_session_error_quark = g_quark_from_static_string(
1387     "INF_TEXT_SESSION_ERROR"
1388   );
1389   g_object_class_install_property(
1390     object_class,
1391     PROP_CARET_UPDATE_INTERVAL,
1392     g_param_spec_uint(
1393       "caret-update-interval",
1394       "Caret update interval",
1395       "Minimum number of milliseconds between caret update broadcasts",
1396       0,
1397       G_MAXUINT,
1398       500,
1399       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
1400     )
1401   );
1402 }
1403 InfTextSession*
1404 inf_text_session_new(InfCommunicationManager* manager,
1405                      InfTextBuffer* buffer,
1406                      InfIo* io,
1407                      InfSessionStatus status,
1408                      InfCommunicationGroup* sync_group,
1409                      InfXmlConnection* sync_connection)
1410 {
1411   GObject* object;
1412   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
1413   g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
1414   g_return_val_if_fail(INF_IS_IO(io), NULL);
1415   g_return_val_if_fail(
1416     (status == INF_SESSION_RUNNING &amp;&amp;
1417      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
1418     (status != INF_SESSION_RUNNING &amp;&amp;
1419      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
1420      INF_IS_XML_CONNECTION(sync_connection)),
1421     NULL
1422   );
1423   object = g_object_new(
1424     INF_TEXT_TYPE_SESSION,
1425     "communication-manager", manager,
1426     "buffer", buffer,
1427     "status", status,
1428     "sync-group", sync_group,
1429     "sync-connection", sync_connection,
1430     "io", io,
1431     NULL
1432   );
1433   return INF_TEXT_SESSION(object);
1434 }
1435 InfTextSession*
1436 inf_text_session_new_with_user_table(InfCommunicationManager* manager,
1437                                      InfTextBuffer* buffer,
1438                                      InfIo* io,
1439                                      InfUserTable* user_table,
1440                                      InfSessionStatus status,
1441                                      InfCommunicationGroup* sync_group,
1442                                      InfXmlConnection* sync_connection)
1443 {
1444   GObject* object;
1445   g_return_val_if_fail(INF_COMMUNICATION_IS_MANAGER(manager), NULL);
1446   g_return_val_if_fail(INF_TEXT_IS_BUFFER(buffer), NULL);
1447   g_return_val_if_fail(INF_IS_IO(io), NULL);
1448   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1449   g_return_val_if_fail(
1450     (status == INF_SESSION_RUNNING &amp;&amp;
1451      sync_group == NULL &amp;&amp; sync_connection == NULL) ||
1452     (status != INF_SESSION_RUNNING &amp;&amp;
1453      INF_COMMUNICATION_IS_GROUP(sync_group) &amp;&amp;
1454      INF_IS_XML_CONNECTION(sync_connection)),
1455     NULL
1456   );
1457   object = g_object_new(
1458     INF_TEXT_TYPE_SESSION,
1459     "communication-manager", manager,
1460     "buffer", buffer,
1461     "user-table", user_table,
1462     "status", status,
1463     "sync-group", sync_group,
1464     "sync-connection", sync_connection,
1465     "io", io,
1466     NULL
1467   );
1468   return INF_TEXT_SESSION(object);
1469 }
1470 void
1471 inf_text_session_set_user_color(InfTextSession* session,
1472                                 InfTextUser* user,
1473                                 gdouble hue)
1474 {
1475   xmlNodePtr xml;
1476   g_return_if_fail(INF_TEXT_IS_SESSION(session));
1477   g_return_if_fail(INF_TEXT_IS_USER(user));
1478   g_return_if_fail(hue &gt;= 0.0 &amp;&amp; hue &lt;= 1.0);
1479   g_return_if_fail(
1480     inf_user_get_status(INF_USER(user)) != INF_USER_UNAVAILABLE
1481   );
1482   g_return_if_fail(
1483     (inf_user_get_flags(INF_USER(user)) &amp; INF_USER_LOCAL) != 0
1484   );
1485   xml = xmlNewNode(NULL, (const xmlChar*)"user-color-change");
1486   inf_xml_util_set_attribute_uint(xml, "id", inf_user_get_id(INF_USER(user)));
1487   inf_xml_util_set_attribute_double(xml, "hue", hue);
1488   inf_session_send_to_subscriptions(INF_SESSION(session), xml);
1489   g_object_set(G_OBJECT(user), "hue", hue, NULL);
1490 }
1491 void
1492 inf_text_session_flush_requests_for_user(InfTextSession* session,
1493                                          InfTextUser* user)
1494 {
1495   InfTextSessionLocalUser* local;
1496   g_return_if_fail(INF_TEXT_IS_SESSION(session));
1497   g_return_if_fail(INF_TEXT_IS_USER(user));
1498   local = inf_text_session_find_local_user(session, user);
1499   g_assert(local != NULL);
1500   if(local-&gt;caret_timeout != NULL)
1501   {
1502     inf_text_session_broadcast_caret_selection(session, local);
1503   }
1504 }
1505 InfRequest*
1506 inf_text_session_join_user(InfSessionProxy* proxy,
1507                            const gchar* name,
1508                            InfUserStatus status,
1509                            gdouble hue,
1510                            guint caret_position,
1511                            int selection_length,
1512                            InfRequestFunc func,
1513                            gpointer user_data)
1514 {
1515 #define N_PARAMS 6u
1516   GParameter params[N_PARAMS] = {
1517     { "hue", { 0 } },
1518     { "vector", { 0 } },
1519     { "caret-position", { 0 } },
1520     { "selection-length", { 0 } },
1521     { "name", { 0 } },
1522     { "status", { 0 } }
1523   };
1524   InfSession* session;
1525   InfRequest* request;
1526   guint i;
1527   g_return_val_if_fail(INF_IS_SESSION_PROXY(proxy), NULL);
1528   g_object_get(G_OBJECT(proxy), "session", &amp;session, NULL);
1529   g_return_val_if_fail(INF_TEXT_IS_SESSION(session), NULL);
1530   g_value_init(&amp;params[0].value, G_TYPE_DOUBLE);
1531   g_value_set_double(&amp;params[0].value, hue);
1532   g_value_init(&amp;params[1].value, INF_ADOPTED_TYPE_STATE_VECTOR);
1533   g_value_set_boxed(
1534     &amp;params[1].value,
1535     inf_adopted_algorithm_get_current(
1536       inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
1537     )
1538   );
1539   g_value_init(&amp;params[2].value, G_TYPE_UINT);
1540   g_value_set_uint(&amp;params[2].value, caret_position);
1541   g_value_init(&amp;params[3].value, G_TYPE_INT);
1542   g_value_set_int(&amp;params[3].value, selection_length);
1543   g_value_init(&amp;params[4].value, G_TYPE_STRING);
1544   g_value_set_string(&amp;params[4].value, name); 
1545   g_value_init(&amp;params[5].value, INF_TYPE_USER_STATUS);
1546   g_value_set_enum(&amp;params[5].value, status);
1547   request = inf_session_proxy_join_user(
1548     proxy,
1549     N_PARAMS,
1550     params,
1551     func,
1552     user_data
1553   );
1554   for(i = 0; i &lt; N_PARAMS; ++i)
1555     g_value_unset(&amp;params[i].value);
1556 #undef N_PARAMS
1557   g_object_unref(session);
1558   return request;
1559 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-adopted-session.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/adopted/inf-adopted-session.h&gt;
2 #include &lt;libinfinity/adopted/inf-adopted-no-operation.h&gt;
3 #include &lt;libinfinity/common/inf-xml-util.h&gt;
4 #include &lt;libinfinity/common/inf-error.h&gt;
5 #include &lt;libinfinity/inf-i18n.h&gt;
6 #include &lt;libinfinity/inf-signals.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;time.h&gt;
9 typedef struct _InfAdoptedSessionToXmlSyncForeachData
10   InfAdoptedSessionToXmlSyncForeachData;
11 struct _InfAdoptedSessionToXmlSyncForeachData {
12   InfAdoptedSession* session;
13 <a name="5"></a>  xmlNodePtr parent_xml;
14 };
15 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfAdoptedSessionLocalUser InfAdoptedSessionLocalUser;
16 struct _InfAdoptedSessionLocalUser {
17   InfAdoptedUser* user;
18   InfAdoptedStateVector* last_send_vector;
19   time_t noop_time; };
20 typedef struct _InfAdoptedSessionPrivate InfAdoptedSessionPrivate;
21 struct _InfAdoptedSessionPrivate {
22   InfIo* io;
23   guint max_total_log_size;
24   InfAdoptedAlgorithm* algorithm;
25   GSList* local_users; 
26   InfIoTimeout* noop_timeout;
27   InfAdoptedSessionLocalUser* next_noop_user;
28   GPtrArray* request_buffer;
29 };
30 enum {
31   PROP_0,
32   PROP_IO,
33   PROP_MAX_TOTAL_LOG_SIZE,
34   PROP_ALGORITHM
35 };</b></font>
36 enum {
37   CHECK_REQUEST,
38   LAST_SIGNAL
39 };
40 #define INF_ADOPTED_SESSION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_ADOPTED_TYPE_SESSION, InfAdoptedSessionPrivate))
41 static guint session_signals[LAST_SIGNAL];
42 static GQuark inf_adopted_session_error_quark;
43 static const int INF_ADOPTED_SESSION_NOOP_INTERVAL = 30;
44 G_DEFINE_TYPE_WITH_CODE(InfAdoptedSession, inf_adopted_session, INF_TYPE_SESSION,
45   G_ADD_PRIVATE(InfAdoptedSession))
46 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static InfAdoptedSessionLocalUser*
47 inf_adopted_session_lookup_local_user(InfAdoptedSession* session,
48                                       InfAdoptedUser* user)
49 {
50   InfAdoptedSessionPrivate* priv;
51   InfAdoptedSessionLocalUser* local;
52   GSList* item;
53   priv = INF_ADOPTED_SESSION_PRIVATE(session);
54   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
55   {
56     local = (InfAdoptedSessionLocalUser*)item-&gt;data;
57     if(local-&gt;user == user)
58       return local;
59   }
60   return NULL;
61 }
62 static gboolean</b></font>
63 inf_adopted_session_validate_request(InfAdoptedRequestLog* log,
64                                      InfAdoptedRequest* request,
65                                      GError** error)
66 {
67   InfAdoptedStateVector* vector;
68   guint user_id;
69   guint n;
70   guint begin;
71   guint end;
72   vector = inf_adopted_request_get_vector(request);
73   user_id = inf_adopted_request_get_user_id(request);
74   n = inf_adopted_state_vector_get(vector, user_id);
75   begin = inf_adopted_request_log_get_begin(log);
76   end = inf_adopted_request_log_get_end(log);
77   if(end != n &amp;&amp; begin != end)
78   {
79     g_set_error(
80       error,
81       inf_adopted_session_error_quark,
82       INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
83       _("Request has index '%u', but index '%u' was expected"),
84       n,
85       inf_adopted_request_log_get_end(log)
86     );
87     return FALSE;
88   }
89   else
90   {
91     switch(inf_adopted_request_get_request_type(request))
92     {
93     case INF_ADOPTED_REQUEST_DO:
94       return TRUE;
95     case INF_ADOPTED_REQUEST_UNDO:
96       if(inf_adopted_request_log_next_undo(log) == NULL)
97       {
98         g_set_error_literal(
99           error,
100           inf_adopted_session_error_quark,
101           INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
102           _("Undo received, but no previous request found")
103         );
104         return FALSE;
105       }
106       else
107       {
108         return TRUE;
109       }
110     case INF_ADOPTED_REQUEST_REDO:
111       if(inf_adopted_request_log_next_redo(log) == NULL)
112       {
113         g_set_error_literal(
114           error,
115           inf_adopted_session_error_quark,
116           INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
117           _("Redo received, but no previous request found")
118         );
119         return FALSE;
120       }
121       else
122       {
123         return TRUE;
124       }
125     default:
126       g_assert_not_reached();
127       return FALSE;
128     }
129   }
130 }
131 static InfAdoptedUser*
132 inf_adopted_session_user_from_request_xml(InfAdoptedSession* session,
133                                           xmlNodePtr xml,
134                                           GError** error)
135 {
136   InfUserTable* user_table;
137   InfUser* user;
138   guint user_id;
139   user_table = inf_session_get_user_table(INF_SESSION(session));
140   if(!inf_xml_util_get_attribute_uint_required(xml, "user", &amp;user_id, error))
141     return FALSE;
142   if(user_id == 0) return NULL;
143   user = inf_user_table_lookup_user_by_id(user_table, user_id);
144   if(user == NULL)
145   {
146     g_set_error(
147       error,
148       inf_adopted_session_error_quark,
149       INF_ADOPTED_SESSION_ERROR_NO_SUCH_USER,
150       _("No such user with user ID '%u'"),
151       user_id
152     );
153     return NULL;
154   }
155   g_assert(INF_ADOPTED_IS_USER(user));
156   return INF_ADOPTED_USER(user);
157 }
158 static void
159 inf_adopted_session_noop_timeout_func(gpointer user_data)
160 {
161   InfAdoptedSession* session;
162   InfAdoptedSessionPrivate* priv;
163   InfAdoptedOperation* op;
164   InfAdoptedRequest* request;
165   session = INF_ADOPTED_SESSION(user_data);
166   priv = INF_ADOPTED_SESSION_PRIVATE(session);
167   priv-&gt;noop_timeout = NULL;
168   g_assert(priv-&gt;next_noop_user != NULL);
169   op = INF_ADOPTED_OPERATION(inf_adopted_no_operation_new());
170   request = inf_adopted_algorithm_generate_request(
171     priv-&gt;algorithm,
172     INF_ADOPTED_REQUEST_DO,
173     priv-&gt;next_noop_user-&gt;user,
174     op
175   );
176   g_object_unref(op);
177   inf_adopted_session_broadcast_request(session, request);
178   g_object_unref(request);
179 }
180 static InfAdoptedSessionLocalUser*
181 inf_adopted_session_find_next_noop_user(InfAdoptedSession* session)
182 {
183   InfAdoptedSessionPrivate* priv;
184   GSList* item;
185   InfAdoptedSessionLocalUser* local;
186   InfAdoptedSessionLocalUser* next_user;
187   priv = INF_ADOPTED_SESSION_PRIVATE(session);
188   next_user = NULL;
189   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
190   {
191     local = (InfAdoptedSessionLocalUser*)item-&gt;data;
192     if(local-&gt;noop_time != 0)
193       if(next_user == NULL || local-&gt;noop_time &lt; next_user-&gt;noop_time)
194         next_user = local;
195   }
196   return next_user;
197 }
198 static void
199 inf_adopted_session_schedule_noop_timer(InfAdoptedSession* session)
200 {
201   InfAdoptedSessionPrivate* priv;
202   time_t current;
203   time_t sched;
204   priv = INF_ADOPTED_SESSION_PRIVATE(session);
205   if(priv-&gt;noop_timeout != NULL)
206   {
207     inf_io_remove_timeout(priv-&gt;io, priv-&gt;noop_timeout);
208     priv-&gt;noop_timeout = NULL;
209   }
210   if(priv-&gt;next_noop_user != NULL)
211   {
212     current = time(NULL);
213     sched =
214       priv-&gt;next_noop_user-&gt;noop_time + INF_ADOPTED_SESSION_NOOP_INTERVAL;
215     if(sched &gt;= current)
216       sched -= current;
217     else
218       sched = 0;
219     priv-&gt;noop_timeout = inf_io_add_timeout(
220       priv-&gt;io,
221       sched * 1000,
222       inf_adopted_session_noop_timeout_func,
223       session,
224       NULL
225     );
226   }
227 }
228 static void
229 inf_adopted_session_start_noop_timer(InfAdoptedSession* session,
230                                      InfAdoptedSessionLocalUser* local)
231 {
232   InfAdoptedSessionPrivate* priv;
233   priv = INF_ADOPTED_SESSION_PRIVATE(session);
234   g_assert(local-&gt;noop_time == 0);
235   local-&gt;noop_time = time(NULL);
236   if(priv-&gt;noop_timeout == NULL)
237   {
238     priv-&gt;next_noop_user = inf_adopted_session_find_next_noop_user(session);
239     g_assert(priv-&gt;next_noop_user != NULL);
240     inf_adopted_session_schedule_noop_timer(session);
241   }
242 }
243 static void
244 inf_adopted_session_stop_noop_timer(InfAdoptedSession* session,
245                                     InfAdoptedSessionLocalUser* local)
246 {
247   InfAdoptedSessionPrivate* priv;
248   InfAdoptedSessionLocalUser* next_noop_user;
249   priv = INF_ADOPTED_SESSION_PRIVATE(session);
250   if(local-&gt;noop_time &gt; 0)
251   {
252     local-&gt;noop_time = 0;
253     next_noop_user = inf_adopted_session_find_next_noop_user(session);
254     if(next_noop_user != priv-&gt;next_noop_user)
255     {
256       priv-&gt;next_noop_user = next_noop_user;
257       inf_adopted_session_schedule_noop_timer(session);
258     }
259   }
260 }
261 static void
262 inf_adopted_session_broadcast_n_requests(InfAdoptedSession* session,
263                                          InfAdoptedRequest* request,
264                                          guint n)
265 {
266   InfAdoptedSessionPrivate* priv;
267   InfAdoptedSessionClass* session_class;
268   InfUserTable* user_table;
269   guint user_id;
270   InfUser* user;
271   InfAdoptedSessionLocalUser* local;
272   xmlNodePtr xml;
273   priv = INF_ADOPTED_SESSION_PRIVATE(session);
274   session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
275   g_assert(session_class-&gt;request_to_xml != NULL);
276   user_table = inf_session_get_user_table(INF_SESSION(session));
277   user_id = inf_adopted_request_get_user_id(request);
278   user = inf_user_table_lookup_user_by_id(user_table, user_id);
279   g_assert(user != NULL);
280   local = inf_adopted_session_lookup_local_user(
281     session,
282     INF_ADOPTED_USER(user)
283   );
284   g_assert(local != NULL);
285   xml = xmlNewNode(NULL, (const xmlChar*)"request");
286   session_class-&gt;request_to_xml(
287     session,
288     xml,
289     request,
290     local-&gt;last_send_vector,
291     FALSE
292   );
293   if(n &gt; 1) inf_xml_util_set_attribute_uint(xml, "num", n);
294   inf_session_send_to_subscriptions(INF_SESSION(session), xml);
295   inf_adopted_state_vector_free(local-&gt;last_send_vector);
296   local-&gt;last_send_vector = inf_adopted_state_vector_copy(
297     inf_adopted_request_get_vector(request)
298   );
299   if(inf_adopted_request_affects_buffer(request) == TRUE)
300     inf_adopted_state_vector_add(local-&gt;last_send_vector, user_id, n);
301   inf_adopted_session_stop_noop_timer(session, local);
302 }
303 static gboolean
304 inf_adopted_session_process_request(InfAdoptedSession* session,
305                                     InfAdoptedRequest* request,
306                                     InfAdoptedUser* user,
307                                     GError** error)
308 {
309   InfAdoptedSessionPrivate* priv;
310   InfAdoptedStateVector* request_vector;
311   InfAdoptedStateVector* current_vector;
312   gboolean reject_request;
313   GError* local_error;
314   gboolean execute_result;
315   xmlNodePtr reply_xml;
316   gchar* request_str;
317   gchar* current_str;
318   priv = INF_ADOPTED_SESSION_PRIVATE(session);
319   request_vector = inf_adopted_request_get_vector(request);
320   current_vector = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
321   if(inf_adopted_state_vector_causally_before(request_vector, current_vector))
322   {
323     g_signal_emit(
324       G_OBJECT(session),
325       session_signals[CHECK_REQUEST],
326       0,
327       request,
328       user,
329       &amp;reject_request
330     );
331     local_error = NULL;
332     if(reject_request)
333     {
334       g_set_error_literal(
335         &amp;local_error,
336         inf_adopted_session_error_quark,
337         INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
338         _("The request was rejected via the API")
339       );
340       execute_result = FALSE;
341     }
342     else
343     {
344       execute_result = inf_adopted_algorithm_execute_request(
345         priv-&gt;algorithm,
346         request,
347         TRUE,
348         &amp;local_error
349       );
350     }
351     if(local_error != NULL)
352     {
353       if(inf_user_get_connection(INF_USER(user)) != NULL)
354       {
355         request_str = inf_adopted_state_vector_to_string(request_vector);
356         current_str = inf_adopted_state_vector_to_string(current_vector);
357         reply_xml = xmlNewNode(NULL, (const xmlChar*)"invalid-request");
358         inf_xml_util_set_attribute(
359           reply_xml,
360           "request",
361           request_str
362         );
363         inf_xml_util_set_attribute(
364           reply_xml,
365           "state",
366           current_str
367         );
368         inf_xml_util_set_attribute_uint(
369           reply_xml,
370           "user",
371           inf_user_get_id(INF_USER(user))
372         );
373         xmlNewChild(
374           reply_xml,
375           NULL,
376           (const xmlChar*)"reason",
377           (const xmlChar*)local_error-&gt;message
378         );
379         g_free(request_str);
380         g_free(current_str);
381         inf_communication_group_send_message(
382           inf_session_get_subscription_group(INF_SESSION(session)),
383           inf_user_get_connection(INF_USER(user)),
384           reply_xml
385         );
386       }
387       g_propagate_error(error, local_error);
388     }
389     return execute_result;
390   }
391   else
392   {
393     if(priv-&gt;request_buffer == NULL)
394       priv-&gt;request_buffer = g_ptr_array_new();
395     g_ptr_array_add(priv-&gt;request_buffer, request);
396     g_object_ref(request);
397     return TRUE;
398   }
399 }
400 static void
401 inf_adopted_session_process_buffered_requests(InfAdoptedSession* session)
402 {
403   InfAdoptedSessionPrivate* priv;
404   InfUserTable* user_table;
405   InfAdoptedStateVector* current;
406   guint i;
407   InfAdoptedRequest* request;
408   InfAdoptedStateVector* vector;
409   guint user_id;
410   InfUser* user;
411   priv = INF_ADOPTED_SESSION_PRIVATE(session);
412   if(priv-&gt;request_buffer != NULL)
413   {
414     user_table = inf_session_get_user_table(INF_SESSION(session));
415     current = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
416     for(i = 0; i &lt; priv-&gt;request_buffer-&gt;len; ++i)
417     {
418       request =
419         INF_ADOPTED_REQUEST(g_ptr_array_index(priv-&gt;request_buffer, i));
420       vector = inf_adopted_request_get_vector(request);
421       if(inf_adopted_state_vector_causally_before(vector, current))
422       {
423         g_ptr_array_remove_index_fast(priv-&gt;request_buffer, i);
424         user_id = inf_adopted_request_get_user_id(request);
425         user = inf_user_table_lookup_user_by_id(user_table, user_id);
426         g_assert(INF_ADOPTED_IS_USER(user));
427         inf_adopted_session_process_request(
428           session,
429           request,
430           INF_ADOPTED_USER(user),
431           NULL
432         );
433         g_object_unref(request);
434         return inf_adopted_session_process_buffered_requests(session);
435       }
436     }
437   }
438 }
439 static void
440 inf_adopted_session_local_user_added(InfAdoptedSession* session,
441                                      InfAdoptedUser* user)
442 {
443   InfAdoptedSessionPrivate* priv;
444   InfSessionStatus status;
445   InfAdoptedSessionLocalUser* local;
446   InfAdoptedStateVector* current_state;
447   priv = INF_ADOPTED_SESSION_PRIVATE(session);
448   status = inf_session_get_status(INF_SESSION(session));
449   g_assert(status == INF_SESSION_RUNNING);
450   local = g_slice_new(InfAdoptedSessionLocalUser);
451   local-&gt;user = user;
452   local-&gt;last_send_vector = inf_adopted_state_vector_copy(
453     inf_adopted_user_get_vector(user)
454   );
455   inf_adopted_user_set_vector(
456     user,
457     inf_adopted_state_vector_copy(
458       inf_adopted_algorithm_get_current(priv-&gt;algorithm)
459     )
460   );
461   local-&gt;noop_time = 0;
462   priv-&gt;local_users = g_slist_prepend(priv-&gt;local_users, local);
463   current_state = inf_adopted_algorithm_get_current(priv-&gt;algorithm);
464   if(inf_adopted_state_vector_compare(current_state, local-&gt;last_send_vector))
465     inf_adopted_session_start_noop_timer(session, local);
466 }
467 static void
468 inf_adopted_session_remove_local_user_cb(InfUserTable* user_table,
469                                          InfUser* user,
470                                          gpointer user_data)
471 {
472   InfAdoptedSession* session;
473   InfAdoptedSessionPrivate* priv;
474   InfAdoptedSessionLocalUser* local;
475   session = INF_ADOPTED_SESSION(user_data);
476   priv = INF_ADOPTED_SESSION_PRIVATE(session);
477   local = inf_adopted_session_lookup_local_user(
478     session,
479     INF_ADOPTED_USER(user)
480   );
481   g_assert(local != NULL);
482   inf_adopted_session_stop_noop_timer(session, local);
483   inf_adopted_state_vector_free(local-&gt;last_send_vector);
484   priv-&gt;local_users = g_slist_remove(priv-&gt;local_users, local);
485   g_slice_free(InfAdoptedSessionLocalUser, local);
486 }
487 static void
488 inf_adopted_session_add_local_user_cb(InfUserTable* user_table,
489                                       InfUser* user,
490                                       gpointer user_data)
491 {
492   g_assert(INF_ADOPTED_IS_USER(user));
493   inf_adopted_session_local_user_added(
494     INF_ADOPTED_SESSION(user_data),
495     INF_ADOPTED_USER(user)
496   );
497 }
498 static void
499 inf_adopted_session_constructed_foreach_local_user_func(InfUser* user,
500                                                         gpointer user_data)
501 {
502   g_assert(INF_ADOPTED_IS_USER(user));
503   inf_adopted_session_local_user_added(
504     INF_ADOPTED_SESSION(user_data),
505     INF_ADOPTED_USER(user)
506   );
507 }
508 static void
509 inf_adopted_session_end_execute_request_cb(InfAdoptedAlgorithm* algorithm,
510                                           InfAdoptedUser* user,
511                                           InfAdoptedRequest* request,
512                                           InfAdoptedRequest* translated,
513                                           const GError* error,
514                                           gpointer user_data)
515 {
516   InfAdoptedSession* session;
517   InfAdoptedSessionPrivate* priv;
518   GSList* item;
519   InfAdoptedSessionLocalUser* local;
520   guint id;
521   InfAdoptedOperation* operation;
522   session = INF_ADOPTED_SESSION(user_data);
523   priv = INF_ADOPTED_SESSION_PRIVATE(session);
524   if(translated != NULL)
525   {
526     if(inf_adopted_request_affects_buffer(translated))
527     {
528       id = inf_adopted_request_get_user_id(translated);
529       for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
530       {
531         local = (InfAdoptedSessionLocalUser*)item-&gt;data;
532         if(local-&gt;noop_time == 0)
533           if(inf_user_get_id(INF_USER(local-&gt;user)) != id)
534             inf_adopted_session_start_noop_timer(session, local);
535       }
536     }
537     operation = inf_adopted_request_get_operation(translated);
538     if(!INF_ADOPTED_IS_NO_OPERATION(operation))
539     {
540       if(inf_user_get_status(INF_USER(user)) == INF_USER_INACTIVE)
541         g_object_set(G_OBJECT(user), "status", INF_USER_ACTIVE, NULL);
542     }
543   }
544 }
545 static void
546 inf_adopted_session_create_algorithm(InfAdoptedSession* session)
547 {
548   InfAdoptedSessionPrivate* priv;
549   priv = INF_ADOPTED_SESSION_PRIVATE(session);
550   g_assert(priv-&gt;algorithm == NULL);
551   g_assert(
552     inf_session_get_status(INF_SESSION(session)) == INF_SESSION_RUNNING
553   );
554   priv-&gt;algorithm = inf_adopted_algorithm_new_full(
555     inf_session_get_user_table(INF_SESSION(session)),
556     inf_session_get_buffer(INF_SESSION(session)),
557     priv-&gt;max_total_log_size
558   );
559   g_signal_connect(
560     G_OBJECT(priv-&gt;algorithm),
561     "end-execute-request",
562     G_CALLBACK(inf_adopted_session_end_execute_request_cb),
563     session
564   );
565   g_object_notify(G_OBJECT(session), "algorithm");
566 }
567 static void
568 inf_adopted_session_init(InfAdoptedSession* session)
569 {
570   InfAdoptedSessionPrivate* priv;
571   priv = INF_ADOPTED_SESSION_PRIVATE(session);
572   priv-&gt;io = NULL;
573   priv-&gt;max_total_log_size = 2048;
574   priv-&gt;algorithm = NULL;
575   priv-&gt;local_users = NULL;
576   priv-&gt;noop_timeout = NULL;
577   priv-&gt;next_noop_user = NULL;
578   priv-&gt;request_buffer = NULL;
579 }
580 static void
581 inf_adopted_session_constructed(GObject* object)
582 {
583   InfAdoptedSession* session;
584   InfAdoptedSessionPrivate* priv;
585   InfSessionStatus status;
586   InfUserTable* user_table;
587   G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;constructed(object);
588   session = INF_ADOPTED_SESSION(object);
589   priv = INF_ADOPTED_SESSION_PRIVATE(session);
590   g_assert(priv-&gt;io != NULL);
591   g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
592   user_table = inf_session_get_user_table(INF_SESSION(session));
593   g_signal_connect(
594     G_OBJECT(user_table),
595     "add-local-user",
596     G_CALLBACK(inf_adopted_session_add_local_user_cb),
597     session
598   );
599   g_signal_connect(
600     G_OBJECT(user_table),
601     "remove-local-user",
602     G_CALLBACK(inf_adopted_session_remove_local_user_cb),
603     session
604   );
605   switch(status)
606   {
607   case INF_SESSION_PRESYNC:
608   case INF_SESSION_SYNCHRONIZING:
609     break;
610   case INF_SESSION_RUNNING:
611     g_assert(inf_session_get_buffer(INF_SESSION(session)) != NULL);
612     inf_adopted_session_create_algorithm(session);
613     break;
614   case INF_SESSION_CLOSED:
615   default:
616     g_assert_not_reached();
617     break;
618   }
619   inf_user_table_foreach_local_user(
620     user_table,
621     inf_adopted_session_constructed_foreach_local_user_func,
622     session
623   );
624 }
625 static void
626 inf_adopted_session_dispose(GObject* object)
627 {
628   InfAdoptedSession* session;
629   InfAdoptedSessionPrivate* priv;
630   InfUserTable* user_table;
631   guint i;
632   session = INF_ADOPTED_SESSION(object);
633   priv = INF_ADOPTED_SESSION_PRIVATE(session);
634   user_table = inf_session_get_user_table(INF_SESSION(session));
635   inf_signal_handlers_disconnect_by_func(
636     G_OBJECT(user_table),
637     G_CALLBACK(inf_adopted_session_add_local_user_cb),
638     session
639   );
640   inf_signal_handlers_disconnect_by_func(
641     G_OBJECT(user_table),
642     G_CALLBACK(inf_adopted_session_remove_local_user_cb),
643     session
644   );
645   if(priv-&gt;noop_timeout != NULL)
646   {
647     inf_io_remove_timeout(priv-&gt;io, priv-&gt;noop_timeout);
648     priv-&gt;noop_timeout = NULL;
649   }
650   G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;dispose(object);
651   g_assert(priv-&gt;local_users == NULL);
652   if(priv-&gt;request_buffer != NULL)
653   {
654     for(i = 0; i &lt; priv-&gt;request_buffer-&gt;len; ++i)
655       g_object_unref(g_ptr_array_index(priv-&gt;request_buffer, i));
656     g_ptr_array_free(priv-&gt;request_buffer, TRUE);
657     priv-&gt;request_buffer = NULL;
658   }
659   if(priv-&gt;algorithm != NULL)
660   {
661     inf_signal_handlers_disconnect_by_func(
662       G_OBJECT(priv-&gt;algorithm),
663       G_CALLBACK(inf_adopted_session_end_execute_request_cb),
664       session
665     );
666     g_object_unref(G_OBJECT(priv-&gt;algorithm));
667 <a name="2"></a>    priv-&gt;algorithm = NULL;
668   }
669 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(priv-&gt;io != NULL)
670   {
671     g_object_unref(G_OBJECT(priv-&gt;io));
672     priv-&gt;io = NULL;
673   }
674 }
675 static void
676 inf_adopted_session_finalize(GObject* object)
677 {
678   InfAdoptedSession* session;
679   InfAdoptedSessionPrivate* priv;
680   session = INF_ADOPTED_SESSION(object);
681   priv = INF_ADOPTED_SESSION_PRIVATE(session);
682   g_assert(priv-&gt;local_users == NULL);
683   G_OBJECT_CLASS(inf_adopted_session_parent_class)-&gt;finalize(object);
684 }
685 static void</b></font>
686 inf_adopted_session_set_property(GObject* object,
687                                  guint prop_id,
688                                  const GValue* value,
689                                  GParamSpec* pspec)
690 {
691   InfAdoptedSession* session;
692   InfAdoptedSessionPrivate* priv;
693   session = INF_ADOPTED_SESSION(object);
694   priv = INF_ADOPTED_SESSION_PRIVATE(session);
695   switch(prop_id)
696   {
697   case PROP_IO:
698     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
699     break;
700   case PROP_MAX_TOTAL_LOG_SIZE:
701     priv-&gt;max_total_log_size = g_value_get_uint(value);
702 <a name="4"></a>    break;
703   case PROP_ALGORITHM:
704 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  default:
705     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
706     break;
707   }
708 }
709 static void
710 inf_adopted_session_get_property(GObject* object,
711                                  guint prop_id,
712                                  GValue* value,
713                                  GParamSpec* pspec)
714 {
715   InfAdoptedSession* session;
716   InfAdoptedSessionPrivate* priv;
717   session = INF_ADOPTED_SESSION(object);
718   priv = INF_ADOPTED_SESSION_PRIVATE(session);
719   switch(prop_id)
720   {
721   case PROP_IO:
722     g_value_set_object(value, G_OBJECT(priv-&gt;io));
723     break;</b></font>
724   case PROP_MAX_TOTAL_LOG_SIZE:
725     g_value_set_uint(value, priv-&gt;max_total_log_size);
726     break;
727   case PROP_ALGORITHM:
728     g_value_set_object(value, G_OBJECT(priv-&gt;algorithm));
729     break;
730   default:
731     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
732     break;
733   }
734 }
735 static void
736 inf_adopted_session_to_xml_sync_foreach_user_func(InfUser* user,
737                                                   gpointer user_data)
738 {
739   InfAdoptedRequestLog* log;
740   InfAdoptedSessionToXmlSyncForeachData* data;
741   InfAdoptedSessionClass* session_class;
742   guint i;
743   guint end;
744   xmlNodePtr xml;
745   InfAdoptedRequest* request;
746   g_assert(INF_ADOPTED_IS_USER(user));
747   data = (InfAdoptedSessionToXmlSyncForeachData*)user_data;
748   log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(user));
749   end = inf_adopted_request_log_get_end(log);
750   session_class = INF_ADOPTED_SESSION_GET_CLASS(data-&gt;session);
751   g_assert(session_class-&gt;request_to_xml != NULL);
752   for(i = inf_adopted_request_log_get_begin(log); i &lt; end; ++ i)
753   {
754     request = inf_adopted_request_log_get_request(log, i);
755     xml = xmlNewChild(
756       data-&gt;parent_xml,
757       NULL,
758       (const xmlChar*)"sync-request",
759       NULL
760     );
761     session_class-&gt;request_to_xml(data-&gt;session, xml, request, NULL, TRUE);
762     xmlAddChild(data-&gt;parent_xml, xml);
763   }
764 }
765 static void
766 inf_adopted_session_to_xml_sync(InfSession* session,
767                                 xmlNodePtr parent)
768 {
769   InfAdoptedSessionPrivate* priv;
770   InfAdoptedSessionToXmlSyncForeachData foreach_data;
771   priv = INF_ADOPTED_SESSION_PRIVATE(session);
772   g_assert(priv-&gt;algorithm != NULL);
773   INF_SESSION_CLASS(inf_adopted_session_parent_class)-&gt;to_xml_sync(
774     session,
775     parent
776   );
777   foreach_data.session = INF_ADOPTED_SESSION(session);
778   foreach_data.parent_xml = parent;
779   inf_user_table_foreach_user(
780     inf_session_get_user_table(session),
781     inf_adopted_session_to_xml_sync_foreach_user_func,
782     &amp;foreach_data
783   );
784 }
785 static gboolean
786 inf_adopted_session_process_xml_sync(InfSession* session,
787                                      InfXmlConnection* connection,
788                                      const xmlNodePtr xml,
789                                      GError** error)
790 {
791   InfAdoptedSessionClass* session_class;
792   InfAdoptedRequest* request;
793   InfAdoptedUser* user;
794   InfAdoptedRequestLog* log;
795   InfSessionClass* parent_class;
796   if(strcmp((const char*)xml-&gt;name, "sync-request") == 0)
797   {
798     session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
799     g_assert(session_class-&gt;xml_to_request != NULL);
800     request = session_class-&gt;xml_to_request(
801       INF_ADOPTED_SESSION(session),
802       xml,
803       NULL,       TRUE,
804       error
805     );
806     if(request == NULL) return FALSE;
807     user = INF_ADOPTED_USER(
808       inf_user_table_lookup_user_by_id(
809         inf_session_get_user_table(session),
810         inf_adopted_request_get_user_id(request)
811       )
812     );
813     log = inf_adopted_user_get_request_log(user);
814     if(inf_adopted_session_validate_request(log, request, error) == FALSE)
815     {
816       g_object_unref(request);
817       return FALSE;
818     }
819     inf_adopted_request_log_add_request(log, request);
820     g_object_unref(request);
821     return TRUE;
822   }
823   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
824   return parent_class-&gt;process_xml_sync(session, connection, xml, error);
825 }
826 static InfCommunicationScope
827 inf_adopted_session_process_xml_run(InfSession* session,
828                                     InfXmlConnection* connection,
829                                     const xmlNodePtr xml,
830                                     GError** error)
831 {
832   InfAdoptedSessionPrivate* priv;
833   InfAdoptedSessionClass* session_class;
834   InfAdoptedRequest* request;
835   InfAdoptedUser* user;
836   guint user_id;
837   InfAdoptedStateVector* user_vector;
838   InfAdoptedStateVector* request_vector;
839   gboolean has_num;
840   gboolean process_request;
841   guint num;
842   GError* local_error;
843   InfAdoptedRequest* copy_req;
844   guint i;
845   gchar* request_str;
846   gchar* user_str;
847   InfSessionClass* parent_class;
848   priv = INF_ADOPTED_SESSION_PRIVATE(session);
849   if(strcmp((const char*)xml-&gt;name, "request") == 0)
850   {
851     session_class = INF_ADOPTED_SESSION_GET_CLASS(session);
852     g_assert(session_class-&gt;xml_to_request != NULL);
853     user = inf_adopted_session_user_from_request_xml(
854       INF_ADOPTED_SESSION(session),
855       xml,
856       error
857     );
858     if(user == NULL)
859       return INF_COMMUNICATION_SCOPE_PTP;
860     if(inf_user_get_status(INF_USER(user)) == INF_USER_UNAVAILABLE ||
861        inf_user_get_connection(INF_USER(user)) != connection)
862     {
863       g_set_error_literal(
864         error,
865         inf_user_error_quark(),
866         INF_USER_ERROR_NOT_JOINED,
867         _("User did not join from this connection")
868       );
869       return INF_COMMUNICATION_SCOPE_PTP;
870     }
871     local_error = NULL;
872     has_num = inf_xml_util_get_attribute_uint(xml, "num", &amp;num, &amp;local_error);
873     if(local_error != NULL)
874     {
875       g_propagate_error(error, local_error);
876       return INF_COMMUNICATION_SCOPE_PTP;
877     }
878     if(has_num == FALSE)
879       num = 1;
880     user_id = inf_user_get_id(INF_USER(user));
881     user_vector = inf_adopted_user_get_vector(user);
882     request = session_class-&gt;xml_to_request(
883       INF_ADOPTED_SESSION(session),
884       xml,
885       user_vector,
886       FALSE,
887       error
888     );
889     if(request == NULL)
890       return INF_COMMUNICATION_SCOPE_PTP;
891     request_vector = inf_adopted_request_get_vector(request);
892     if(!inf_adopted_state_vector_causally_before(user_vector, request_vector))
893     {
894       g_assert_not_reached();
895     }
896     else if(inf_adopted_request_get_index(request) !=
897             inf_adopted_state_vector_get(user_vector, user_id))
898     {
899       request_str = inf_adopted_state_vector_to_string(request_vector);
900       user_str = inf_adopted_state_vector_to_string(user_vector);
901       g_set_error(
902         error,
903         inf_adopted_session_error_quark,
904         INF_ADOPTED_SESSION_ERROR_INVALID_REQUEST,
905         _("Request \"%s\" by user \"%s\" is not consecutive with respect to "
906           "previously received request \"%s\""),
907         request_str,
908         inf_user_get_name(INF_USER(user)),
909         user_str
910       );
911       g_free(request_str);
912       g_free(user_str);
913       g_object_unref(request);
914       return INF_COMMUNICATION_SCOPE_PTP;
915     }
916     user_vector = inf_adopted_state_vector_copy(request_vector);
917     inf_adopted_user_set_vector(INF_ADOPTED_USER(user), user_vector);
918     for(i = 0; i &lt; num; ++i)
919     {
920       if(i == 0)
921       {
922         copy_req = request;
923         g_object_ref(copy_req);
924       }
925       else
926       {
927         copy_req = inf_adopted_request_copy(request);
928         inf_adopted_state_vector_add(
929           inf_adopted_request_get_vector(copy_req),
930           inf_user_get_id(INF_USER(user)),
931           i
932         );
933       }
934       process_request = inf_adopted_session_process_request(
935         INF_ADOPTED_SESSION(session),
936         copy_req,
937         user,
938         error
939       );
940       g_object_unref(copy_req);
941       if(inf_adopted_request_affects_buffer(request))
942       {
943         user_vector = inf_adopted_state_vector_copy(
944           inf_adopted_request_get_vector(copy_req)
945         );
946         inf_adopted_state_vector_add(user_vector, user_id, 1);
947         inf_adopted_user_set_vector(INF_ADOPTED_USER(user), user_vector);
948       }
949       if(process_request == FALSE)
950         break;
951     }
952     g_object_unref(request);
953     if(i &gt; 0)
954     {
955       inf_adopted_session_process_buffered_requests(
956         INF_ADOPTED_SESSION(session)
957       );
958     }
959     inf_adopted_algorithm_cleanup(
960       inf_adopted_session_get_algorithm(INF_ADOPTED_SESSION(session))
961     );
962     return INF_COMMUNICATION_SCOPE_GROUP;
963   }
964   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
965   return parent_class-&gt;process_xml_run(session, connection, xml, error);
966 }
967 static GArray*
968 inf_adopted_session_get_xml_user_props(InfSession* session,
969                                        InfXmlConnection* conn,
970                                        const xmlNodePtr xml)
971 {
972   InfSessionClass* parent_class;
973   GArray* array;
974   GParameter* parameter;
975   InfAdoptedStateVector* vector;
976   xmlChar* time;
977   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
978   array = parent_class-&gt;get_xml_user_props(session, conn, xml);
979   time = inf_xml_util_get_attribute(xml, "time");
980   if(time != NULL)
981   {
982     vector = inf_adopted_state_vector_from_string((const gchar*)time, NULL);
983     xmlFree(time);
984     if(vector != NULL)
985     {
986       parameter = inf_session_get_user_property(array, "vector");
987       g_value_init(&amp;parameter-&gt;value, INF_ADOPTED_TYPE_STATE_VECTOR);
988       g_value_take_boxed(&amp;parameter-&gt;value, vector);
989     }
990   }
991   return array;
992 }
993 static void
994 inf_adopted_session_set_xml_user_props(InfSession* session,
995                                        const GParameter* params,
996                                        guint n_params,
997                                        xmlNodePtr xml)
998 {
999   InfSessionClass* parent_class;
1000   InfAdoptedSessionPrivate* priv;
1001   const GParameter* time;
1002   InfAdoptedStateVector* vector;
1003   gchar* time_string;
1004   const GParameter* id_param;
1005   guint id;
1006   GSList* item;
1007   InfAdoptedSessionLocalUser* local_user;
1008   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
1009   parent_class-&gt;set_xml_user_props(session, params, n_params, xml);
1010   priv = INF_ADOPTED_SESSION_PRIVATE(INF_ADOPTED_SESSION(session));
1011   time = inf_session_lookup_user_property(params, n_params, "vector");
1012   if(time != NULL)
1013   {
1014     vector = NULL;
1015     id_param = inf_session_lookup_user_property(params, n_params, "id");
1016     if(id_param != NULL)
1017     {
1018       id = g_value_get_uint(&amp;id_param-&gt;value);
1019       for(item = priv-&gt;local_users; item != NULL; item = item-&gt;next)
1020       {
1021         local_user = (InfAdoptedSessionLocalUser*)item-&gt;data;
1022         if(inf_user_get_id(INF_USER(local_user-&gt;user)) == id)
1023         {
1024           vector = local_user-&gt;last_send_vector;
1025           break;
1026         }
1027       }
1028     }
1029     if(vector == NULL)
1030     {
1031       vector = (InfAdoptedStateVector*)g_value_get_boxed(&amp;time-&gt;value);
1032     }
1033 <a name="1"></a>    time_string = inf_adopted_state_vector_to_string(vector);
1034     inf_xml_util_set_attribute(xml, "time", time_string);
1035     g_free(time_string);
1036 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
1037 }
1038 static gboolean
1039 inf_adopted_session_validate_user_props(InfSession* session,
1040                                         const GParameter* params,
1041                                         guint n_params,
1042                                         InfUser* exclude,
1043                                         GError** error)
1044 {
1045   InfSessionClass* parent_class;
1046   const GParameter* time;
1047   gboolean result;
1048   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
1049   result = parent_class-&gt;validate_user_props(
1050     session,
1051     params,
1052     n_params,
1053     exclude,
1054     error
1055   );
1056   if(result == FALSE) return FALSE;
1057   time = inf_session_lookup_user_property(params, n_params, "vector");
1058   if(time == NULL)
1059   {
1060     g_set_error_literal(
1061       error,
1062       inf_adopted_session_error_quark,
1063       INF_ADOPTED_SESSION_ERROR_MISSING_STATE_VECTOR,
1064       _("\"time\" attribute in user message is missing")
1065     );
1066     return FALSE;
1067   }
1068   return TRUE;
1069 }
1070 static void</b></font>
1071 inf_adopted_session_close(InfSession* session)
1072 {
1073   InfAdoptedSessionPrivate* priv;
1074   InfAdoptedSessionLocalUser* local;
1075   GSList* item;
1076   priv = INF_ADOPTED_SESSION_PRIVATE(session);
1077   for(item = priv-&gt;local_users; item != NULL; item = g_slist_next(item))
1078   {
1079     local = (InfAdoptedSessionLocalUser*)item-&gt;data;
1080     inf_adopted_state_vector_free(local-&gt;last_send_vector);
1081     g_slice_free(InfAdoptedSessionLocalUser, local);
1082   }
1083   g_slist_free(priv-&gt;local_users);
1084   priv-&gt;local_users = NULL;
1085   INF_SESSION_CLASS(inf_adopted_session_parent_class)-&gt;close(session);
1086 }
1087 static void
1088 inf_adopted_session_synchronization_complete_foreach_user_func(InfUser* user,
1089                                                                gpointer data)
1090 {
1091   InfAdoptedRequestLog* log;
1092   log = inf_adopted_user_get_request_log(INF_ADOPTED_USER(user));
1093   if(inf_adopted_request_log_is_empty(log))
1094   {
1095     inf_adopted_request_log_set_begin(
1096       log,
1097       inf_adopted_state_vector_get(
1098         inf_adopted_user_get_vector(INF_ADOPTED_USER(user)),
1099         inf_user_get_id(user)
1100       )
1101     );
1102   }
1103 }
1104 static void
1105 inf_adopted_session_synchronization_complete(InfSession* session,
1106                                              InfXmlConnection* connection)
1107 {
1108   InfSessionClass* parent_class;
1109   InfAdoptedSessionPrivate* priv;
1110   InfSessionStatus status;
1111   priv = INF_ADOPTED_SESSION_PRIVATE(session);
1112   status = inf_session_get_status(session);
1113   g_object_freeze_notify(G_OBJECT(session));
1114   parent_class = INF_SESSION_CLASS(inf_adopted_session_parent_class);
1115   parent_class-&gt;synchronization_complete(session, connection);
1116   if(status == INF_SESSION_SYNCHRONIZING)
1117   {
1118     inf_user_table_foreach_user(
1119       inf_session_get_user_table(session),
1120       inf_adopted_session_synchronization_complete_foreach_user_func,
1121       NULL
1122     );
1123     g_assert(priv-&gt;algorithm == NULL);
1124     inf_adopted_session_create_algorithm(INF_ADOPTED_SESSION(session));
1125   }
1126   g_object_thaw_notify(G_OBJECT(session));
1127 }
1128 static gboolean
1129 inf_adopted_session_check_request(InfAdoptedSession* session,
1130                                   InfAdoptedRequest* request,
1131                                   InfAdoptedUser* user)
1132 <a name="0"></a>{
1133   return FALSE;
1134 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1135 static void
1136 inf_adopted_session_class_init(InfAdoptedSessionClass* adopted_session_class)
1137 {
1138   GObjectClass* object_class;
1139   InfSessionClass* session_class;
1140   object_class = G_OBJECT_CLASS(adopted_session_class);
1141   session_class = INF_SESSION_CLASS(adopted_session_class);
1142   object_class-&gt;constructed = inf_adopted_session_constructed;
1143   object_class-&gt;dispose = inf_adopted_session_dispose;
1144   object_class-&gt;finalize = inf_adopted_session_finalize;
1145   object_class-&gt;set_property = inf_adopted_session_set_property;
1146   object_class-&gt;get_property = inf_adopted_session_get_property;
1147   session_class-&gt;to_xml_sync = inf_adopted_session_to_xml_sync;
1148   session_class-&gt;process_xml_sync = inf_adopted_session_process_xml_sync;
1149   session_class-&gt;process_xml_run = inf_adopted_session_process_xml_run;
1150   session_class-&gt;get_xml_user_props = inf_adopted_session_get_xml_user_props;
1151   session_class-&gt;set_xml_user_props = inf_adopted_session_set_xml_user_props;
1152   session_class-&gt;validate_user_props =
1153     inf_adopted_session_validate_user_props;
1154   session_class-&gt;close = inf_adopted_session_close;
1155   session_class-&gt;synchronization_complete =
1156     inf_adopted_session_synchronization_complete;
1157   adopted_session_class-&gt;xml_to_request = NULL;</b></font>
1158   adopted_session_class-&gt;request_to_xml = NULL;
1159   adopted_session_class-&gt;check_request = inf_adopted_session_check_request;
1160   inf_adopted_session_error_quark = g_quark_from_static_string(
1161     "INF_ADOPTED_SESSION_ERROR"
1162   );
1163   session_signals[CHECK_REQUEST] = g_signal_new(
1164     "check-request",
1165     G_OBJECT_CLASS_TYPE(object_class),
1166     G_SIGNAL_RUN_LAST,
1167     G_STRUCT_OFFSET(InfAdoptedSessionClass, check_request),
1168     g_signal_accumulator_true_handled, NULL,
1169     NULL,
1170     G_TYPE_BOOLEAN,
1171     2,
1172     INF_ADOPTED_TYPE_REQUEST,
1173     INF_ADOPTED_TYPE_USER
1174   );
1175   g_object_class_install_property(
1176     object_class,
1177     PROP_IO,
1178     g_param_spec_object(
1179       "io",
1180       "IO",
1181       "The IO object used for timeouts",
1182       INF_TYPE_IO,
1183       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1184     )
1185   );
1186   g_object_class_install_property(
1187     object_class,
1188     PROP_MAX_TOTAL_LOG_SIZE,
1189     g_param_spec_uint(
1190       "max-total-log-size",
1191       "Maxmimum total log size",
1192       "The maximum number of requests to keep in all user's logs",
1193       0,
1194       G_MAXUINT,
1195       2048,
1196       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1197     )
1198   );
1199   g_object_class_install_property(
1200     object_class,
1201     PROP_ALGORITHM,
1202     g_param_spec_object(
1203       "algorithm",
1204       "Algorithm",
1205       "The adOPTed algorithm used for translating incoming requests",
1206       INF_ADOPTED_TYPE_ALGORITHM,
1207       G_PARAM_READABLE
1208     )
1209   );
1210 }
1211 InfIo*
1212 inf_adopted_session_get_io(InfAdoptedSession* session)
1213 {
1214   g_return_val_if_fail(INF_ADOPTED_IS_SESSION(session), NULL);
1215   return INF_ADOPTED_SESSION_PRIVATE(session)-&gt;io;
1216 }
1217 InfAdoptedAlgorithm*
1218 inf_adopted_session_get_algorithm(InfAdoptedSession* session)
1219 {
1220   g_return_val_if_fail(INF_ADOPTED_IS_SESSION(session), NULL);
1221   return INF_ADOPTED_SESSION_PRIVATE(session)-&gt;algorithm;
1222 }
1223 void
1224 inf_adopted_session_broadcast_request(InfAdoptedSession* session,
1225                                       InfAdoptedRequest* request)
1226 {
1227   g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
1228   g_return_if_fail(INF_ADOPTED_IS_REQUEST(request));
1229   inf_adopted_session_broadcast_n_requests(session, request, 1);
1230 }
1231 void
1232 inf_adopted_session_undo(InfAdoptedSession* session,
1233                          InfAdoptedUser* user,
1234                          guint n)
1235 {
1236   InfAdoptedSessionPrivate* priv;
1237   InfAdoptedRequest* first_request;
1238   InfAdoptedRequest* request;
1239   guint i;
1240   gboolean result;
1241   g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
1242   g_return_if_fail(INF_ADOPTED_IS_USER(user));
1243   g_return_if_fail(n &gt;= 1);
1244   priv = INF_ADOPTED_SESSION_PRIVATE(session);
1245   first_request = NULL;
1246   for(i = 0; i &lt; n; ++i)
1247   {
1248     request = inf_adopted_algorithm_generate_request(
1249       priv-&gt;algorithm,
1250       INF_ADOPTED_REQUEST_UNDO,
1251       user,
1252       NULL
1253     );
1254     result = inf_adopted_algorithm_execute_request(
1255       priv-&gt;algorithm,
1256       request,
1257       TRUE,
1258       NULL
1259     );
1260     g_assert(result == TRUE);
1261     if(first_request == NULL)
1262       first_request = request;
1263     else
1264       g_object_unref(request);
1265   }
1266   inf_adopted_session_broadcast_n_requests(session, first_request, n);
1267   g_object_unref(first_request);
1268 }
1269 void
1270 inf_adopted_session_redo(InfAdoptedSession* session,
1271                          InfAdoptedUser* user,
1272                          guint n)
1273 {
1274   InfAdoptedSessionPrivate* priv;
1275   InfAdoptedRequest* first_request;
1276   InfAdoptedRequest* request;
1277   guint i;
1278   gboolean result;
1279   g_return_if_fail(INF_ADOPTED_IS_SESSION(session));
1280   g_return_if_fail(INF_ADOPTED_IS_USER(user));
1281   g_return_if_fail(n &gt;= 1);
1282   priv = INF_ADOPTED_SESSION_PRIVATE(session);
1283   first_request = NULL;
1284   for(i = 0; i &lt; n; ++i)
1285   {
1286     request = inf_adopted_algorithm_generate_request(
1287       priv-&gt;algorithm,
1288       INF_ADOPTED_REQUEST_REDO,
1289       user,
1290       NULL
1291     );
1292     result = inf_adopted_algorithm_execute_request(
1293       priv-&gt;algorithm,
1294       request,
1295       TRUE,
1296       NULL
1297     );
1298     g_assert(result == TRUE);
1299     if(first_request == NULL)
1300       first_request = request;
1301     else
1302       g_object_unref(request);
1303   }
1304   inf_adopted_session_broadcast_n_requests(session, first_request, n);
1305   g_object_unref(first_request);
1306 }
1307 gboolean
1308 inf_adopted_session_read_request_info(InfAdoptedSession* session,
1309                                       xmlNodePtr xml,
1310                                       InfAdoptedStateVector* diff_vec,
1311                                       InfAdoptedUser** user,
1312                                       InfAdoptedStateVector** time,
1313                                       xmlNodePtr* operation,
1314                                       GError** error)
1315 {
1316   xmlChar* attr;
1317   xmlNodePtr child;
1318   if(user != NULL)
1319   {
1320     *user = inf_adopted_session_user_from_request_xml(session, xml, error);
1321     if(*user == NULL) return FALSE;
1322   }
1323   if(time != NULL)
1324   {
1325     attr = inf_xml_util_get_attribute_required(xml, "time", error);
1326     if(attr == NULL) return FALSE;
1327     if(diff_vec == NULL)
1328     {
1329       *time = inf_adopted_state_vector_from_string((const gchar*)attr, error);
1330     }
1331     else
1332     {
1333       *time = inf_adopted_state_vector_from_string_diff(
1334         (const gchar*)attr,
1335         diff_vec,
1336         error
1337       );
1338     }
1339     xmlFree(attr);
1340     if(*time == NULL) return FALSE;
1341   }
1342   if(operation != NULL)
1343   {
1344     child = xml-&gt;children;
1345     while(child != NULL &amp;&amp; child-&gt;type != XML_ELEMENT_NODE)
1346       child = child-&gt;next;
1347     if(child == NULL)
1348     {
1349       g_set_error_literal(
1350         error,
1351         inf_adopted_session_error_quark,
1352         INF_ADOPTED_SESSION_ERROR_MISSING_OPERATION,
1353         _("Operation for request missing")
1354       );
1355       if(time) inf_adopted_state_vector_free(*time);
1356       return FALSE;
1357     }
1358     *operation = child;
1359   }
1360   return TRUE;
1361 }
1362 void
1363 inf_adopted_session_write_request_info(InfAdoptedSession* session,
1364                                        InfAdoptedRequest* request,
1365                                        InfAdoptedStateVector* diff_vec,
1366                                        xmlNodePtr xml,
1367                                        xmlNodePtr operation)
1368 {
1369   InfAdoptedStateVector* vector;
1370   guint user_id;
1371   gchar* vec_str;
1372   vector = inf_adopted_request_get_vector(request);
1373   user_id = inf_adopted_request_get_user_id(request);
1374   inf_xml_util_set_attribute_uint(xml, "user", user_id);
1375   if(diff_vec == NULL)
1376     vec_str = inf_adopted_state_vector_to_string(vector);
1377   else
1378     vec_str = inf_adopted_state_vector_to_string_diff(vector, diff_vec);
1379   inf_xml_util_set_attribute(xml, "time", vec_str);
1380   g_free(vec_str);
1381   if(operation != NULL)
1382     xmlAddChild(xml, operation);
1383 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
