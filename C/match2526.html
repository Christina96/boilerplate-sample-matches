<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for srutils.c &amp; action.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for srutils.c &amp; action.c
      </h3>
<h1 align="center">
        4.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>srutils.c (7.5642967%)<th>action.c (3.1269543%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(84-102)<td><a href="#" name="0">(188-206)</a><td align="center"><font color="#ff0000">36</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(839-845)<td><a href="#" name="1">(2071-2077)</a><td align="center"><font color="#630000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>srutils.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;unistd.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;sys/stat.h&gt;
8 #include &lt;sys/types.h&gt;
9 #include &lt;signal.h&gt;
10 #include &lt;assert.h&gt;
11 #include &lt;sys/wait.h&gt;
12 #include &lt;ctype.h&gt;
13 #include &lt;inttypes.h&gt;
14 #include &lt;fcntl.h&gt;
15 #include "rsyslog.h"
16 #include "srUtils.h"
17 #include "obj.h"
18 #include "errmsg.h"
19 #include "glbl.h"
20 #include "rsconf.h"
21 #if _POSIX_TIMERS &lt;= 0
22 #include &lt;sys/time.h&gt;
23 #endif
24 syslogName_t	syslogPriNames[] = {
25 	{"alert",	LOG_ALERT},
26 	{"crit",	LOG_CRIT},
27 	{"debug",	LOG_DEBUG},
28 	{"emerg",	LOG_EMERG},
29 	{"err",		LOG_ERR},
30 	{"error",	LOG_ERR},			{"info",	LOG_INFO},
31 	{"none",	INTERNAL_NOPRI},		{"notice",	LOG_NOTICE},
32 	{"panic",	LOG_EMERG},			{"warn",	LOG_WARNING},			{"warning",	LOG_WARNING},
33 	{"*",		TABLE_ALLPRI},
34 	{NULL,		-1}
35 };
36 <a name="0"></a>#ifndef LOG_AUTHPRIV
37 #	define LOG_AUTHPRIV LOG_AUTH
38 #endif
39 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>syslogName_t	syslogFacNames[] = {
40 	{"auth",         LOG_AUTH},
41 	{"authpriv",     LOG_AUTHPRIV},
42 	{"cron",         LOG_CRON},
43 	{"daemon",       LOG_DAEMON},
44 	{"kern",         LOG_KERN},
45 	{"lpr",          LOG_LPR},
46 	{"mail",         LOG_MAIL},
47 	{"mark",         LOG_MARK},			{"news",         LOG_NEWS},
48 	{"ntp",          (12&lt;&lt;3) },             	{"security",     LOG_AUTH},			{"bsd_security", (13&lt;&lt;3) },			{"syslog",       LOG_SYSLOG},
49 	{"user",         LOG_USER},
50 	{"uucp",         LOG_UUCP},
51 #if defined(_AIX)  	{ "caa",         LOG_CAA },
52 	{ "aso",         LOG_ASO },</b></font>
53 #endif
54 #if defined(LOG_FTP)
55 	{"ftp",          LOG_FTP},
56 #endif
57 #if defined(LOG_AUDIT)
58 	{"audit",        LOG_AUDIT},
59 #endif
60 	{"console",	 (14 &lt;&lt; 3)},			{"local0",       LOG_LOCAL0},
61 	{"local1",       LOG_LOCAL1},
62 	{"local2",       LOG_LOCAL2},
63 	{"local3",       LOG_LOCAL3},
64 	{"local4",       LOG_LOCAL4},
65 	{"local5",       LOG_LOCAL5},
66 	{"local6",       LOG_LOCAL6},
67 	{"local7",       LOG_LOCAL7},
68 	{"invld",        LOG_INVLD},
69 	{NULL,           -1},
70 };
71 rsRetVal srUtilItoA(char *pBuf, int iLenBuf, number_t iToConv)
72 {
73 	int i;
74 	int bIsNegative;
75 	char szBuf[64];	
76 	assert(pBuf != NULL);
77 	assert(iLenBuf &gt; 1);	
78 	if(iToConv &lt; 0)
79 	{
80 		bIsNegative = RSTRUE;
81 		iToConv *= -1;
82 	}
83 	else
84 		bIsNegative = RSFALSE;
85 	i = 0;
86 	do
87 	{
88 		szBuf[i++] = iToConv % 10 + '0';
89 		iToConv /= 10;
90 	} while(iToConv &gt; 0);		--i; 
91 	if(i + 2 &gt; iLenBuf)			return RS_RET_PROVIDED_BUFFER_TOO_SMALL;
92 	if(bIsNegative == RSTRUE)
93 		*pBuf++ = '-';
94 	while(i &gt;= 0)
95 		*pBuf++ = szBuf[i--];
96 	*pBuf = '\0';	
97 	return RS_RET_OK;
98 }
99 uchar *srUtilStrDup(uchar *pOld, size_t len)
100 {
101 	uchar *pNew;
102 	assert(pOld != NULL);
103 	if((pNew = malloc(len + 1)) != NULL)
104 		memcpy(pNew, pOld, len + 1);
105 	return pNew;
106 }
107 static int real_makeFileParentDirs(const uchar *const szFile, const size_t lenFile, const mode_t mode,
108 	const uid_t uid, const gid_t gid, const int bFailOnChownFail)
109 {
110 	uchar *p;
111 	uchar *pszWork;
112 	size_t len;
113 	assert(szFile != NULL);
114 	assert(lenFile &gt; 0);
115 	len = lenFile + 1; 	if((pszWork = malloc(len)) == NULL)
116 		return -1;
117 	memcpy(pszWork, szFile, len);
118 	for(p = pszWork+1 ; *p ; p++)
119 		if(*p == '/') {
120 			*p = '\0';
121 			int bErr = 0;
122 			if(mkdir((char*)pszWork, mode) == 0) {
123 				if(uid != (uid_t) -1 || gid != (gid_t) -1) {
124 					if(chown((char*)pszWork, uid, gid) != 0) {
125 						LogError(errno, RS_RET_DIR_CHOWN_ERROR,
126 							"chown for directory '%s' failed", pszWork);
127 						if(bFailOnChownFail) {
128 							bErr = 1;
129 						}
130 					}
131 				}
132 			} else if(errno != EEXIST) {
133 				bErr = 1;
134 			}
135 			if(bErr) {
136 				int eSave = errno;
137 				free(pszWork);
138 				errno = eSave;
139 				return -1;
140 			}
141 			*p = '/';
142 		}
143 	free(pszWork);
144 	return 0;
145 }
146 int makeFileParentDirs(const uchar *const szFile, const size_t lenFile, const mode_t mode,
147 		       const uid_t uid, const gid_t gid, const int bFailOnChownFail)
148 {
149 	static pthread_mutex_t mutParentDir = PTHREAD_MUTEX_INITIALIZER;
150 	int r;		pthread_mutex_lock(&amp;mutParentDir);
151 	pthread_cleanup_push(mutexCancelCleanup, &amp;mutParentDir);
152 	r = real_makeFileParentDirs(szFile, lenFile, mode, uid, gid, bFailOnChownFail);
153 	pthread_mutex_unlock(&amp;mutParentDir);
154 	pthread_cleanup_pop(0);
155 	return r;
156 }
157 int execProg(uchar *program, int bWait, uchar *arg)
158 {
159 	int pid;
160 	int sig;
161 	struct sigaction sigAct;
162 	dbgprintf("exec program '%s' with param '%s'\n", program, arg);
163 	pid = fork();
164 	if (pid &lt; 0) {
165 		return 0;
166 	}
167 	if(pid) {       		if(bWait) {
168 			int status;
169 			if(waitpid(pid, &amp;status, 0) == pid) {
170 				glblReportChildProcessExit(runConf, program, pid, status);
171 			} else if(errno != ECHILD) {
172 				dbgprintf("could not wait on child after executing '%s'",
173 						(char*)program);
174 			}
175 		}
176 		return pid;
177 	}
178 	alarm(0); 
179 	memset(&amp;sigAct, 0, sizeof(sigAct));
180 	sigemptyset(&amp;sigAct.sa_mask);
181 	sigAct.sa_handler = SIG_DFL;
182 	for(sig = 1 ; sig &lt; NSIG ; ++sig)
183 		sigaction(sig, &amp;sigAct, NULL);
184 	execlp((char*)program, (char*) program, (char*)arg, NULL);
185 	perror("exec");
186 	fprintf(stderr, "exec program was '%s' with param '%s'\n", program, arg);
187 	exit(1); }
188 void skipWhiteSpace(uchar **pp)
189 {
190 	register uchar *p;
191 	assert(pp != NULL);
192 	assert(*pp != NULL);
193 	p = *pp;
194 	while(*p &amp;&amp; isspace((int) *p))
195 		++p;
196 	*pp = p;
197 }
198 PRAGMA_DIAGNOSTIC_PUSH
199 PRAGMA_IGNORE_Wformat_nonliteral
200 rsRetVal genFileName(uchar **ppName, uchar *pDirName, size_t lenDirName, uchar *pFName,
201 		     size_t lenFName, int64_t lNum, int lNumDigits)
202 {
203 	DEFiRet;
204 	uchar *pName;
205 	uchar *pNameWork;
206 	size_t lenName;
207 	uchar szBuf[128];		char szFmtBuf[32];		size_t lenBuf;
208 	if(lNum &lt; 0) {
209 		szBuf[0] = '\0';
210 		lenBuf = 0;
211 	} else {
212 		if(lNumDigits &gt; 0) {
213 			snprintf(szFmtBuf, sizeof(szFmtBuf), ".%%0%d" PRId64, lNumDigits);
214 			lenBuf = snprintf((char*)szBuf, sizeof(szBuf), szFmtBuf, lNum);
215 		} else
216 			lenBuf = snprintf((char*)szBuf, sizeof(szBuf), ".%" PRId64, lNum);
217 	}
218 	lenName = lenDirName + 1 + lenFName + lenBuf + 1; 	if((pName = malloc(lenName)) == NULL)
219 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
220 	memcpy(pName, pDirName, lenDirName);
221 	pNameWork = pName + lenDirName;
222 	*pNameWork++ = '/';
223 	memcpy(pNameWork, pFName, lenFName);
224 	pNameWork += lenFName;
225 	if(lenBuf &gt; 0) {
226 		memcpy(pNameWork, szBuf, lenBuf);
227 		pNameWork += lenBuf;
228 	}
229 	*pNameWork = '\0';
230 	*ppName = pName;
231 finalize_it:
232 	RETiRet;
233 }
234 PRAGMA_DIAGNOSTIC_POP
235 int getNumberDigits(long lNum)
236 {
237 	int iDig;
238 	if(lNum == 0)
239 		iDig = 1;
240 	else
241 		for(iDig = 0 ; lNum != 0 ; ++iDig)
242 			lNum /= 10;
243 	return iDig;
244 }
245 rsRetVal
246 timeoutComp(struct timespec *pt, long iTimeout)
247 {
248 #	if _POSIX_TIMERS &lt;= 0
249 	struct timeval tv;
250 #	endif
251 	assert(pt != NULL);
252 #	if _POSIX_TIMERS &gt; 0
253 	clock_gettime(CLOCK_REALTIME, pt);
254 #	else
255 	gettimeofday(&amp;tv, NULL);
256 	pt-&gt;tv_sec = tv.tv_sec;
257 	pt-&gt;tv_nsec = tv.tv_usec * 1000;
258 #	endif
259 	pt-&gt;tv_sec += iTimeout / 1000;
260 	pt-&gt;tv_nsec += (iTimeout % 1000) * 1000000; 	if(pt-&gt;tv_nsec &gt; 999999999) { 		pt-&gt;tv_nsec -= 1000000000;
261 		++pt-&gt;tv_sec;
262 	}
263 	return RS_RET_OK; }
264 long long
265 currentTimeMills(void)
266 {
267 	struct timespec tm;
268 #	if _POSIX_TIMERS &lt;= 0
269 	struct timeval tv;
270 #	endif
271 #	if _POSIX_TIMERS &gt; 0
272 	clock_gettime(CLOCK_REALTIME, &amp;tm);
273 #	else
274 	gettimeofday(&amp;tv, NULL);
275 	tm.tv_sec = tv.tv_sec;
276 	tm.tv_nsec = tv.tv_usec * 1000;
277 #	endif
278 	return ((long long) tm.tv_sec) * 1000 + (tm.tv_nsec / 1000000);
279 }
280 long
281 timeoutVal(struct timespec *pt)
282 {
283 	struct timespec t;
284 	long iTimeout;
285 #	if _POSIX_TIMERS &lt;= 0
286 	struct timeval tv;
287 #	endif
288 	assert(pt != NULL);
289 #	if _POSIX_TIMERS &gt; 0
290 	clock_gettime(CLOCK_REALTIME, &amp;t);
291 #	else
292 	gettimeofday(&amp;tv, NULL);
293 	t.tv_sec = tv.tv_sec;
294 	t.tv_nsec = tv.tv_usec * 1000;
295 #	endif
296 	iTimeout = (pt-&gt;tv_nsec - t.tv_nsec) / 1000000;
297 	iTimeout += (pt-&gt;tv_sec - t.tv_sec) * 1000;
298 	if(iTimeout &lt; 0)
299 		iTimeout = 0;
300 	return iTimeout;
301 }
302 void
303 mutexCancelCleanup(void *arg)
304 {
305 	assert(arg != NULL);
306 	d_pthread_mutex_unlock((pthread_mutex_t*) arg);
307 }
308 void
309 srSleep(int iSeconds, int iuSeconds)
310 {
311 	struct timeval tvSelectTimeout;
312 	tvSelectTimeout.tv_sec = iSeconds;
313 	tvSelectTimeout.tv_usec = iuSeconds; 	select(0, NULL, NULL, NULL, &amp;tvSelectTimeout);
314 }
315 char *rs_strerror_r(int errnum, char *buf, size_t buflen) {
316 #ifndef HAVE_STRERROR_R
317 	char *pszErr;
318 	pszErr = strerror(errnum);
319 	snprintf(buf, buflen, "%s", pszErr);
320 #else
321 #	ifdef STRERROR_R_CHAR_P
322 		char *p = strerror_r(errnum, buf, buflen);
323 		if (p != buf) {
324 			strncpy(buf, p, buflen);
325 			buf[buflen - 1] = '\0';
326 		}
327 #	else
328 		strerror_r(errnum, buf, buflen);
329 #	endif
330 #endif 	return buf;
331 }
332 int decodeSyslogName(uchar *name, syslogName_t *codetab)
333 {
334 	register syslogName_t *c;
335 	register uchar *p;
336 	uchar buf[80];
337 	assert(name != NULL);
338 	assert(codetab != NULL);
339 	DBGPRINTF("symbolic name: %s", name);
340 	if(isdigit((int) *name)) {
341 		DBGPRINTF("\n");
342 		return (atoi((char*) name));
343 	}
344 	strncpy((char*) buf, (char*) name, 79);
345 	for(p = buf; *p; p++) {
346 		if (isupper((int) *p))
347 			*p = tolower((int) *p);
348 	}
349 	for(c = codetab; c-&gt;c_name; c++) {
350 		if(!strcmp((char*) buf, (char*) c-&gt;c_name)) {
351 			DBGPRINTF(" ==&gt; %d\n", c-&gt;c_val);
352 			return (c-&gt;c_val);
353 		}
354 	}
355 	DBGPRINTF("\n");
356 	return (-1);
357 }
358 int getSubString(uchar **ppSrc,  char *pDst, size_t DstSize, char cSep)
359 {
360 	uchar *pSrc = *ppSrc;
361 	int iErr = 0; 	while((cSep == ' ' ? !isspace(*pSrc) : *pSrc != cSep) &amp;&amp; *pSrc != '\n' &amp;&amp; *pSrc != '\0' &amp;&amp; DstSize&gt;1) {
362 		*pDst++ = *(pSrc)++;
363 		DstSize--;
364 	}
365 	if ((cSep == ' ' ? !isspace(*pSrc) : *pSrc != cSep) &amp;&amp; *pSrc != '\n' &amp;&amp; *pSrc != '\0') {
366 		dbgprintf("in getSubString, error Src buffer &gt; Dst buffer\n");
367 		iErr = 1;
368 	}
369 	if (*pSrc == '\0' || *pSrc == '\n')
370 		*ppSrc = pSrc;
371 	else
372 		*ppSrc = pSrc+1;
373 	*pDst = '\0';
374 	return iErr;
375 }
376 rsRetVal
377 getFileSize(uchar *pszName, off_t *pSize)
378 {
379 	int ret;
380 	struct stat statBuf;
381 	DEFiRet;
382 	ret = stat((char*) pszName, &amp;statBuf);
383 	if(ret == -1) {
384 		switch(errno) {
385 			case EACCES: ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
386 			case ENOTDIR:
387 			case ENOENT:  ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
388 			default:      ABORT_FINALIZE(RS_RET_FILE_NO_STAT);
389 		}
390 	}
391 	*pSize = statBuf.st_size;
392 finalize_it:
393 	RETiRet;
394 }
395 int
396 containsGlobWildcard(char *str)
397 {
398 	char *p;
399 	if(!str) {
400 		return 0;
401 	}
402 	for(p = str; *p != '\0'; p++) {
403 		if((*p == '?' || *p == '*' || *p == '[' || *p == '{') &amp;&amp;
404 				(p == str || *(p-1) != '\\')) {
405 			return 1;
406 		}
407 	}
408 	return 0;
409 }
410 static void seedRandomInsecureNumber(void)
411 {
412 	struct timespec t;
413 	timeoutComp(&amp;t, 0);
414 	long long x = t.tv_sec * 3 + t.tv_nsec * 2;
415 	srandom((unsigned int) x);
416 }
417 static long int randomInsecureNumber(void)
418 {
419 	return random();
420 }
421 #ifdef OS_LINUX
422 static int fdURandom = -1;
423 void seedRandomNumber(void)
424 {
425 	if(fdURandom &gt;= 0) {
426 		return;
427 	}
428 	fdURandom = open("/dev/urandom", O_RDONLY);
429 	if(fdURandom == -1) {
430 		LogError(errno, RS_RET_IO_ERROR, "failed to seed random number generation,"
431 			" will use fallback (open urandom failed)");
432 		seedRandomInsecureNumber();
433 	}
434 }
435 void seedRandomNumberForChild(void)
436 {
437 	fdURandom = -1;
438 	seedRandomNumber();
439 }
440 long int randomNumber(void)
441 {
442 	long int ret;
443 	if(fdURandom &gt;= 0) {
444 		if(read(fdURandom, &amp;ret, sizeof(long int)) == -1) {
445 			LogError(errno, RS_RET_IO_ERROR, "failed to generate random number, will"
446 				" use fallback (read urandom failed)");
447 			ret = randomInsecureNumber();
448 		}
449 	} else {
450 		ret = randomInsecureNumber();
451 	}
452 	return ret;
453 }
454 #else
455 void seedRandomNumber(void)
456 {
457 	seedRandomInsecureNumber();
458 }
459 void seedRandomNumberForChild(void)
460 {
461 	seedRandomNumber();
462 }
463 long int randomNumber(void)
464 {
465 	return randomInsecureNumber();
466 }
467 #endif
468 rsRetVal ATTR_NONNULL()
469 split_binary_parameters(uchar **const szBinary, char ***const __restrict__ aParams,
470 	int *const iParams, es_str_t *const param_binary)
471 {
472 	es_size_t iCnt;
473 	es_size_t iStr;
474 	int iPrm;
475 	es_str_t *estrParams = NULL;
476 	es_str_t *estrBinary = param_binary;
477 	es_str_t *estrTmp = NULL;
478 	uchar *c;
479 	int bInQuotes;
480 	DEFiRet;
481 	assert(iParams != NULL);
482 	assert(param_binary != NULL);
483 	c = es_getBufAddr(param_binary);
484 	iCnt = 0;
485 	while(iCnt &lt; es_strlen(param_binary) ) {
486 		if (c[iCnt] == ' ') {
487 			estrBinary = es_newStrFromSubStr( param_binary, 0, iCnt);
488 			estrParams = es_newStrFromSubStr( param_binary, iCnt+1,
489 					es_strlen(param_binary));
490 			break;
491 		}
492 		iCnt++;
493 	}
494 	*szBinary = (uchar*)es_str2cstr(estrBinary, NULL);
495 	DBGPRINTF("szBinary = '%s'\n", *szBinary);
496 	*iParams = 1; 	if (estrParams != NULL) {
497 		 (*iParams)++; 		if(Debug) {
498 			char *params = es_str2cstr(estrParams, NULL);
499 			dbgprintf("szParams = '%s'\n", params);
500 			free(params);
501 		}
502 		c = es_getBufAddr(estrParams);
503 		for(iCnt = 0 ; iCnt &lt; es_strlen(estrParams) ; ++iCnt) {
504 			if (c[iCnt] == ' ' &amp;&amp; c[iCnt-1] != '\\')
505 				 (*iParams)++;
506 		}
507 	}
508 	DBGPRINTF("iParams %d (+1 for NULL terminator)\n", *iParams);
509 	CHKmalloc(*aParams = malloc((*iParams + 1) * sizeof(char*)));
510 	iPrm = 0;
511 	bInQuotes = FALSE;
512 	(*aParams)[iPrm] = strdup((char*)*szBinary);
513 	iPrm++;
514 	if (estrParams != NULL) {
515 <a name="1"></a>		iCnt = iStr = 0;
516 		c = es_getBufAddr(estrParams); 		while(iCnt &lt; es_strlen(estrParams) ) {
517 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			if ( c[iCnt] == ' ' &amp;&amp; !bInQuotes ) {
518 				estrTmp = es_newStrFromSubStr( estrParams, iStr, iCnt-iStr);
519 			} else if ( iCnt+1 &gt;= es_strlen(estrParams) ) {
520 				estrTmp = es_newStrFromSubStr( estrParams, iStr, iCnt-iStr+1);
521 			} else if (c[iCnt] == '"') {
522 				bInQuotes = !bInQuotes;
523 			}</b></font>
524 			if ( estrTmp != NULL ) {
525 				(*aParams)[iPrm] = es_str2cstr(estrTmp, NULL);
526 				iStr = iCnt+1; 				DBGPRINTF("Param (%d): '%s'\n", iPrm, (*aParams)[iPrm]);
527 				es_deleteStr( estrTmp );
528 				estrTmp = NULL;
529 				iPrm++;
530 			}
531 			iCnt++;
532 		}
533 	}
534 	(*aParams)[iPrm] = NULL; 
535 finalize_it:
536 	if(estrBinary != param_binary) {
537 		es_deleteStr(estrBinary);
538 	}
539 	if(estrParams != NULL) {
540 		es_deleteStr(estrParams);
541 	}
542 	RETiRet;
543 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>action.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;assert.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;strings.h&gt;
8 #include &lt;time.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;sys/types.h&gt;
11 #include &lt;sys/stat.h&gt;
12 #include &lt;fcntl.h&gt;
13 #include &lt;unistd.h&gt;
14 #include &lt;json.h&gt;
15 #include "rsyslog.h"
16 #include "dirty.h"
17 #include "template.h"
18 #include "action.h"
19 #include "modules.h"
20 #include "cfsysline.h"
21 #include "srUtils.h"
22 #include "errmsg.h"
23 #include "batch.h"
24 #include "wti.h"
25 #include "rsconf.h"
26 #include "datetime.h"
27 #include "unicode-helper.h"
28 #include "atomic.h"
29 #include "ruleset.h"
30 #include "parserif.h"
31 #include "statsobj.h"
32 #ifdef _AIX
33 #define cs legacy_cs
34 #endif
35 PRAGMA_INGORE_Wswitch_enum
36 #ifndef O_LARGEFILE
37 #define O_LARGEFILE 0
38 #endif
39 #define NO_TIME_PROVIDED 0 
40 static rsRetVal ATTR_NONNULL() processBatchMain(void *pVoid, batch_t *pBatch, wti_t * const pWti);
41 static rsRetVal doSubmitToActionQ(action_t * const pAction, wti_t * const pWti, smsg_t*);
42 static rsRetVal doSubmitToActionQComplex(action_t * const pAction, wti_t * const pWti, smsg_t*);
43 static rsRetVal doSubmitToActionQNotAllMark(action_t * const pAction, wti_t * const pWti, smsg_t*);
44 static void ATTR_NONNULL() actionSuspend(action_t * const pThis, wti_t * const pWti);
45 static void ATTR_NONNULL() actionRetry(action_t * const pThis, wti_t * const pWti);
46 DEFobjCurrIf(obj)
47 DEFobjCurrIf(datetime)
48 DEFobjCurrIf(module)
49 DEFobjCurrIf(statsobj)
50 DEFobjCurrIf(ruleset)
51 typedef struct configSettings_s {
52 	int bActExecWhenPrevSusp;				int bActionWriteAllMarkMsgs;				int iActExecOnceInterval;				int iActExecEveryNthOccur;				time_t iActExecEveryNthOccurTO;				int glbliActionResumeInterval;
53 	int glbliActionResumeRetryCount;			int bActionRepMsgHasMsg;				uchar *pszActionName;					queueType_t ActionQueType;				int iActionQueueSize;					int iActionQueueDeqBatchSize;				int iActionQHighWtrMark;				int iActionQLowWtrMark;					int iActionQDiscardMark;				int iActionQDiscardSeverity;
54 	int iActionQueueNumWorkers;				uchar *pszActionQFName;					int64 iActionQueMaxFileSize;
55 	int iActionQPersistUpdCnt;				int bActionQSyncQeueFiles;				int iActionQtoQShutdown;				int iActionQtoActShutdown;				int iActionQtoEnq;					int iActionQtoWrkShutdown;				int iActionQWrkMinMsgs;					int bActionQSaveOnShutdown;				int64 iActionQueMaxDiskSpace;				int iActionQueueDeqSlowdown;				int iActionQueueDeqtWinFromHr;				int iActionQueueDeqtWinToHr;			} configSettings_t;
56 <a name="0"></a>static configSettings_t cs;					
57 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static struct cnfparamdescr cnfparamdescr[] = {
58 	{ "name", eCmdHdlrGetWord, 0 }, 	{ "type", eCmdHdlrString, CNFPARAM_REQUIRED }, 	{ "action.errorfile", eCmdHdlrString, 0 },
59 	{ "action.errorfile.maxsize", eCmdHdlrInt, 0 },
60 	{ "action.writeallmarkmessages", eCmdHdlrBinary, 0 }, 	{ "action.execonlyeverynthtime", eCmdHdlrInt, 0 }, 	{ "action.execonlyeverynthtimetimeout", eCmdHdlrInt, 0 }, 	{ "action.execonlyonceeveryinterval", eCmdHdlrInt, 0 }, 	{ "action.execonlywhenpreviousissuspended", eCmdHdlrBinary, 0 },
61 	{ "action.repeatedmsgcontainsoriginalmsg", eCmdHdlrBinary, 0 }, 	{ "action.resumeretrycount", eCmdHdlrInt, 0 }, 	{ "action.reportsuspension", eCmdHdlrBinary, 0 },
62 	{ "action.reportsuspensioncontinuation", eCmdHdlrBinary, 0 },
63 	{ "action.resumeintervalmax", eCmdHdlrPositiveInt, 0 },
64 	{ "action.resumeinterval", eCmdHdlrInt, 0 },
65 	{ "action.externalstate.file", eCmdHdlrString, 0 },
66 	{ "action.copymsg", eCmdHdlrBinary, 0 }</b></font>
67 };
68 static struct cnfparamblk pblk =
69 	{ CNFPARAMBLK_VERSION,
70 	  sizeof(cnfparamdescr)/sizeof(struct cnfparamdescr),
71 	  cnfparamdescr
72 	};
73 #if 0
74 static const char *
75 batchState2String(const batch_state_t state)
76 {
77 	switch(state) {
78 	case BATCH_STATE_RDY:
79 		return "BATCH_STATE_RDY";
80 	case BATCH_STATE_BAD:
81 		return "BATCH_STATE_BAD";
82 	case BATCH_STATE_SUB:
83 		return "BATCH_STATE_SUB";
84 	case BATCH_STATE_COMM:
85 		return "BATCH_STATE_COMM";
86 	case BATCH_STATE_DISC:
87 		return "BATCH_STATE_DISC";
88 	default:
89 		return "ERROR, batch state not known!";
90 	}
91 }
92 #endif 
93 static time_t
94 getActNow(action_t * const pThis)
95 {
96 	assert(pThis != NULL);
97 	if(pThis-&gt;tActNow == -1) {
98 		pThis-&gt;tActNow = datetime.GetTime(NULL); 		if(pThis-&gt;tLastExec &gt; pThis-&gt;tActNow) {
99 			pThis-&gt;tLastExec = (time_t) 0;
100 		}
101 	}
102 	return pThis-&gt;tActNow;
103 }
104 static rsRetVal
105 actionResetQueueParams(void)
106 {
107 	DEFiRet;
108 	cs.ActionQueType = QUEUETYPE_DIRECT;			cs.iActionQueueSize = 1000;				cs.iActionQueueDeqBatchSize = 16;			cs.iActionQHighWtrMark = -1;				cs.iActionQLowWtrMark = -1;				cs.iActionQDiscardMark = 980;				cs.iActionQDiscardSeverity = 8;				cs.iActionQueueNumWorkers = 1;				cs.iActionQueMaxFileSize = 1024*1024;
109 	cs.iActionQPersistUpdCnt = 0;				cs.bActionQSyncQeueFiles = 0;
110 	cs.iActionQtoQShutdown = 0;				cs.iActionQtoActShutdown = 1000;			cs.iActionQtoEnq = 50;					cs.iActionQtoWrkShutdown = 60000;			cs.iActionQWrkMinMsgs = -1;				cs.bActionQSaveOnShutdown = 1;				cs.iActionQueMaxDiskSpace = 0;
111 	cs.iActionQueueDeqSlowdown = 0;
112 	cs.iActionQueueDeqtWinFromHr = 0;
113 	cs.iActionQueueDeqtWinToHr = 25;		
114 	cs.glbliActionResumeRetryCount = 0;		
115 	free(cs.pszActionQFName);
116 	cs.pszActionQFName = NULL;			
117 	RETiRet;
118 }
119 rsRetVal actionDestruct(action_t * const pThis)
120 {
121 	DEFiRet;
122 	assert(pThis != NULL);
123 	if(!strcmp((char*)modGetName(pThis-&gt;pMod), "builtin:omdiscard")) {
124 		FINALIZE;
125 	}
126 	if(pThis-&gt;pQueue != NULL) {
127 		qqueueDestruct(&amp;pThis-&gt;pQueue);
128 	}
129 	if(pThis-&gt;statsobj != NULL)
130 		statsobj.Destruct(&amp;pThis-&gt;statsobj);
131 	if(pThis-&gt;pModData != NULL)
132 		pThis-&gt;pMod-&gt;freeInstance(pThis-&gt;pModData);
133 	if(pThis-&gt;fdErrFile != -1)
134 		close(pThis-&gt;fdErrFile);
135 	pthread_mutex_destroy(&amp;pThis-&gt;mutErrFile);
136 	pthread_mutex_destroy(&amp;pThis-&gt;mutAction);
137 	pthread_mutex_destroy(&amp;pThis-&gt;mutWrkrDataTable);
138 	free((void*)pThis-&gt;pszErrFile);
139 	free((void*)pThis-&gt;pszExternalStateFile);
140 	free(pThis-&gt;pszName);
141 	free(pThis-&gt;ppTpl);
142 	free(pThis-&gt;peParamPassing);
143 	free(pThis-&gt;wrkrDataTable);
144 finalize_it:
145 	free(pThis);
146 	RETiRet;
147 }
148 static inline void
149 actionDisable(action_t *__restrict__ const pThis)
150 {
151 	pThis-&gt;bDisabled = 1;
152 }
153 rsRetVal actionConstruct(action_t **ppThis)
154 {
155 	DEFiRet;
156 	action_t *pThis;
157 	assert(ppThis != NULL);
158 	CHKmalloc(pThis = (action_t*) calloc(1, sizeof(action_t)));
159 	pThis-&gt;iResumeInterval = 30;
160 	pThis-&gt;iResumeIntervalMax = 1800; 	pThis-&gt;iResumeRetryCount = 0;
161 	pThis-&gt;pszName = NULL;
162 	pThis-&gt;pszErrFile = NULL;
163 	pThis-&gt;maxErrFileSize = 0;
164 	pThis-&gt;currentErrFileSize = 0;
165 	pThis-&gt;pszExternalStateFile = NULL;
166 	pThis-&gt;fdErrFile = -1;
167 	pThis-&gt;bWriteAllMarkMsgs = 1;
168 	pThis-&gt;iExecEveryNthOccur = 0;
169 	pThis-&gt;iExecEveryNthOccurTO = 0;
170 	pThis-&gt;iSecsExecOnceInterval = 0;
171 	pThis-&gt;bExecWhenPrevSusp = 0;
172 	pThis-&gt;bRepMsgHasMsg = 0;
173 	pThis-&gt;bDisabled = 0;
174 	pThis-&gt;isTransactional = 0;
175 	pThis-&gt;bReportSuspension = -1; 	pThis-&gt;bReportSuspensionCont = -1; 	pThis-&gt;bCopyMsg = 0;
176 	pThis-&gt;tLastOccur = datetime.GetTime(NULL);		pThis-&gt;iActionNbr = loadConf-&gt;actions.iActionNbr;
177 	pthread_mutex_init(&amp;pThis-&gt;mutErrFile, NULL);
178 	pthread_mutex_init(&amp;pThis-&gt;mutAction, NULL);
179 	pthread_mutex_init(&amp;pThis-&gt;mutWrkrDataTable, NULL);
180 	INIT_ATOMIC_HELPER_MUT(pThis-&gt;mutCAS);
181 	loadConf-&gt;actions.iActionNbr++;
182 finalize_it:
183 	*ppThis = pThis;
184 	RETiRet;
185 }
186 rsRetVal
187 actionConstructFinalize(action_t *__restrict__ const pThis, struct nvlst *lst)
188 {
189 	DEFiRet;
190 	uchar pszAName[64]; 
191 	if(!strcmp((char*)modGetName(pThis-&gt;pMod), "builtin:omdiscard")) {
192 		FINALIZE;
193 	}
194 	if(pThis-&gt;pszName == NULL) {
195 		snprintf((char*) pszAName, sizeof(pszAName), "action-%d-%s",
196 			pThis-&gt;iActionNbr, pThis-&gt;pMod-&gt;pszName);
197 		pThis-&gt;pszName = ustrdup(pszAName);
198 	}
199 	pThis-&gt;isTransactional = pThis-&gt;pMod-&gt;mod.om.supportsTX;
200 	if(pThis-&gt;isTransactional) {
201 		int i;
202 		for(i = 0 ; i &lt; pThis-&gt;iNumTpls ; ++i) {
203 			if(pThis-&gt;peParamPassing[i] != ACT_STRING_PASSING) {
204 				LogError(0, RS_RET_INVLD_OMOD, "action '%s'(%d) is transactional but "
205 						"parameter %d "
206 						"uses invalid parameter passing mode -- disabling "
207 						"action. This is probably caused by a pre-v7 "
208 						"output module that needs upgrade.",
209 						pThis-&gt;pszName, pThis-&gt;iActionNbr, i);
210 				actionDisable(pThis);
211 				ABORT_FINALIZE(RS_RET_INVLD_OMOD);
212 			}
213 		}
214 	}
215 	CHKiRet(statsobj.Construct(&amp;pThis-&gt;statsobj));
216 	CHKiRet(statsobj.SetName(pThis-&gt;statsobj, pThis-&gt;pszName));
217 	CHKiRet(statsobj.SetOrigin(pThis-&gt;statsobj, (uchar*)"core.action"));
218 	STATSCOUNTER_INIT(pThis-&gt;ctrProcessed, pThis-&gt;mutCtrProcessed);
219 	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("processed"),
220 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrProcessed));
221 	STATSCOUNTER_INIT(pThis-&gt;ctrFail, pThis-&gt;mutCtrFail);
222 	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("failed"),
223 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrFail));
224 	STATSCOUNTER_INIT(pThis-&gt;ctrSuspend, pThis-&gt;mutCtrSuspend);
225 	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("suspended"),
226 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrSuspend));
227 	STATSCOUNTER_INIT(pThis-&gt;ctrSuspendDuration, pThis-&gt;mutCtrSuspendDuration);
228 	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("suspended.duration"),
229 		ctrType_IntCtr, 0, &amp;pThis-&gt;ctrSuspendDuration));
230 	STATSCOUNTER_INIT(pThis-&gt;ctrResume, pThis-&gt;mutCtrResume);
231 	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT("resumed"),
232 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrResume));
233 	CHKiRet(statsobj.ConstructFinalize(pThis-&gt;statsobj));
234 	snprintf((char*) pszAName, sizeof(pszAName), "%s queue",
235 		 pThis-&gt;pszName);
236 	if(   pThis-&gt;iExecEveryNthOccur &gt; 1
237 	   || pThis-&gt;iSecsExecOnceInterval
238 	  ) {
239 		DBGPRINTF("info: firehose mode disabled for action because "
240 		          "iExecEveryNthOccur=%d, iSecsExecOnceInterval=%d\n",
241 			  pThis-&gt;iExecEveryNthOccur, pThis-&gt;iSecsExecOnceInterval);
242 		pThis-&gt;submitToActQ = doSubmitToActionQComplex;
243 	} else if(pThis-&gt;bWriteAllMarkMsgs) {
244 		pThis-&gt;submitToActQ = doSubmitToActionQ;
245 	} else {
246 		pThis-&gt;submitToActQ = doSubmitToActionQNotAllMark;
247 	}
248 	CHKiRet(qqueueConstruct(&amp;pThis-&gt;pQueue, cs.ActionQueType, 1, cs.iActionQueueSize,
249 					processBatchMain));
250 	obj.SetName((obj_t*) pThis-&gt;pQueue, pszAName);
251 	qqueueSetpAction(pThis-&gt;pQueue, pThis);
252 	if(lst == NULL) { #		define setQPROP(func, directive, data) \
253 		CHKiRet_Hdlr(func(pThis-&gt;pQueue, data)) { \
254 			LogError(0, NO_ERRCODE, "Invalid " #directive ", \
255 				error %d. Ignored, running with default setting", iRet); \
256 		}
257 #		define setQPROPstr(func, directive, data) \
258 		CHKiRet_Hdlr(func(pThis-&gt;pQueue, data, (data == NULL)? 0 : strlen((char*) data))) { \
259 			LogError(0, NO_ERRCODE, "Invalid " #directive ", \
260 				error %d. Ignored, running with default setting", iRet); \
261 		}
262 		setQPROP(qqueueSetsizeOnDiskMax, "$ActionQueueMaxDiskSpace", cs.iActionQueMaxDiskSpace);
263 		setQPROP(qqueueSetiDeqBatchSize, "$ActionQueueDequeueBatchSize", cs.iActionQueueDeqBatchSize);
264 		setQPROP(qqueueSetMaxFileSize, "$ActionQueueFileSize", cs.iActionQueMaxFileSize);
265 		setQPROPstr(qqueueSetFilePrefix, "$ActionQueueFileName", cs.pszActionQFName);
266 		setQPROP(qqueueSetiPersistUpdCnt, "$ActionQueueCheckpointInterval", cs.iActionQPersistUpdCnt);
267 		setQPROP(qqueueSetbSyncQueueFiles, "$ActionQueueSyncQueueFiles", cs.bActionQSyncQeueFiles);
268 		setQPROP(qqueueSettoQShutdown, "$ActionQueueTimeoutShutdown", cs.iActionQtoQShutdown );
269 		setQPROP(qqueueSettoActShutdown, "$ActionQueueTimeoutActionCompletion", cs.iActionQtoActShutdown);
270 		setQPROP(qqueueSettoWrkShutdown, "$ActionQueueWorkerTimeoutThreadShutdown", cs.iActionQtoWrkShutdown);
271 		setQPROP(qqueueSettoEnq, "$ActionQueueTimeoutEnqueue", cs.iActionQtoEnq);
272 		setQPROP(qqueueSetiHighWtrMrk, "$ActionQueueHighWaterMark", cs.iActionQHighWtrMark);
273 		setQPROP(qqueueSetiLowWtrMrk, "$ActionQueueLowWaterMark", cs.iActionQLowWtrMark);
274 		setQPROP(qqueueSetiDiscardMrk, "$ActionQueueDiscardMark", cs.iActionQDiscardMark);
275 		setQPROP(qqueueSetiDiscardSeverity, "$ActionQueueDiscardSeverity", cs.iActionQDiscardSeverity);
276 		setQPROP(qqueueSetiMinMsgsPerWrkr, "$ActionQueueWorkerThreadMinimumMessages", cs.iActionQWrkMinMsgs);
277 		setQPROP(qqueueSetiNumWorkerThreads, "$ActionQueueWorkerThreads", cs.iActionQueueNumWorkers);
278 		setQPROP(qqueueSetbSaveOnShutdown, "$ActionQueueSaveOnShutdown", cs.bActionQSaveOnShutdown);
279 		setQPROP(qqueueSetiDeqSlowdown,    "$ActionQueueDequeueSlowdown", cs.iActionQueueDeqSlowdown);
280 		setQPROP(qqueueSetiDeqtWinFromHr,  "$ActionQueueDequeueTimeBegin", cs.iActionQueueDeqtWinFromHr);
281 		setQPROP(qqueueSetiDeqtWinToHr,    "$ActionQueueDequeueTimeEnd", cs.iActionQueueDeqtWinToHr);
282 	} else {
283 		qqueueSetDefaultsActionQueue(pThis-&gt;pQueue);
284 		qqueueApplyCnfParam(pThis-&gt;pQueue, lst);
285 	}
286 	qqueueCorrectParams(pThis-&gt;pQueue);
287 #	undef setQPROP
288 #	undef setQPROPstr
289 	qqueueDbgPrint(pThis-&gt;pQueue);
290 	DBGPRINTF("Action %p: queue %p created\n", pThis, pThis-&gt;pQueue);
291 	if(pThis-&gt;bUsesMsgPassingMode &amp;&amp; pThis-&gt;pQueue-&gt;qType != QUEUETYPE_DIRECT) {
292 		parser_warnmsg("module %s with message passing mode uses "
293 			"non-direct queue. This most probably leads to undesired "
294 			"results. For message modificaton modules (mm*), this means "
295 			"that they will have no effect - "
296 			"see https://www.rsyslog.com/mm-no-queue/", (char*)modGetName(pThis-&gt;pMod));
297 	}
298 	actionResetQueueParams();
299 finalize_it:
300 	RETiRet;
301 }
302 rsRetVal actionSetGlobalResumeInterval(int iNewVal)
303 {
304 	cs.glbliActionResumeInterval = iNewVal;
305 	return RS_RET_OK;
306 }
307 static uchar *getActStateName(action_t * const pThis, wti_t * const pWti)
308 {
309 	switch(getActionState(pWti, pThis)) {
310 		case ACT_STATE_RDY:
311 			return (uchar*) "rdy";
312 		case ACT_STATE_ITX:
313 			return (uchar*) "itx";
314 		case ACT_STATE_RTRY:
315 			return (uchar*) "rtry";
316 		case ACT_STATE_SUSP:
317 			return (uchar*) "susp";
318 		case ACT_STATE_DATAFAIL:
319 			return (uchar*) "datafail";
320 		default:
321 			return (uchar*) "ERROR/UNKNWON";
322 	}
323 }
324 static rsRetVal getReturnCode(action_t * const pThis, wti_t * const pWti)
325 {
326 	DEFiRet;
327 	switch(getActionState(pWti, pThis)) {
328 		case ACT_STATE_RDY:
329 			iRet = RS_RET_OK;
330 			break;
331 		case ACT_STATE_ITX:
332 			if(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit) {
333 				pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 0; 				iRet = RS_RET_PREVIOUS_COMMITTED;
334 			} else {
335 				iRet = RS_RET_DEFER_COMMIT;
336 			}
337 			break;
338 		case ACT_STATE_RTRY:
339 			iRet = RS_RET_SUSPENDED;
340 			break;
341 		case ACT_STATE_SUSP:
342 			iRet = RS_RET_ACTION_FAILED;
343 			break;
344 		case ACT_STATE_DATAFAIL:
345 			iRet = RS_RET_DATAFAIL;
346 			break;
347 		default:
348 			DBGPRINTF("Invalid action engine state %u, program error\n",
349 				  getActionState(pWti, pThis));
350 			iRet = RS_RET_ERR;
351 			break;
352 	}
353 	RETiRet;
354 }
355 static void
356 actionSetState(action_t * const pThis, wti_t * const pWti, uint8_t newState)
357 {
358 	setActionState(pWti, pThis, newState);
359 	DBGPRINTF("action[%s] transitioned to state: %s\n",
360 		  pThis-&gt;pszName, getActStateName(pThis, pWti));
361 }
362 static void actionCommitted(action_t * const pThis, wti_t * const pWti)
363 {
364 	actionSetState(pThis, pWti, ACT_STATE_RDY);
365 }
366 static rsRetVal ATTR_NONNULL()
367 checkExternalStateFile(action_t *const pThis, wti_t *const pWti)
368 {
369 	char filebuf[1024];
370 	int fd = -1;
371 	int r;
372 	DEFiRet;
373 	DBGPRINTF("checking external state file\n");
374 	if(pThis-&gt;pszExternalStateFile == NULL) {
375 		FINALIZE;
376 	}
377 	fd = open(pThis-&gt;pszExternalStateFile, O_RDONLY|O_CLOEXEC);
378 	if(fd == -1) {
379 		dbgprintf("could not read external state file\n");
380 		FINALIZE;
381 	}
382 	r = read(fd, filebuf, sizeof(filebuf) - 1);
383 	if(r &lt; 1) {
384 		dbgprintf("checkExternalStateFile read() returned %d\n", r);
385 		FINALIZE;
386 	}
387 	filebuf[r] = '\0';
388 	dbgprintf("external state file content: '%s'\n", filebuf);
389 	for(int j = r-1 ; j &gt; 0 ; --j) {
390 		if(filebuf[j] == '\n' || filebuf[j] == '\t' || filebuf[j] == ' ') {
391 			filebuf[j] = '\0';
392 		} else {
393 			break;
394 		}
395 	}
396 	if(!strcmp(filebuf, "SUSPENDED")) {
397 		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
398 		      "action '%s' suspended (module '%s') by external state file",
399 		      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
400 		actionRetry(pThis, pWti);
401 		ABORT_FINALIZE(RS_RET_SUSPENDED);
402 	}
403 finalize_it:
404 	if(fd != -1) {
405 		close(fd);
406 	}
407 	DBGPRINTF("done checking external state file, iRet=%d\n", iRet);
408 	RETiRet;
409 }
410 static void
411 setSuspendMessageConfVars(action_t *__restrict__ const pThis)
412 {
413 	if(pThis-&gt;bReportSuspension == -1)
414 		pThis-&gt;bReportSuspension = runConf-&gt;globals.bActionReportSuspension;
415 	if(pThis-&gt;bReportSuspensionCont == -1) {
416 		pThis-&gt;bReportSuspensionCont = runConf-&gt;globals.bActionReportSuspensionCont;
417 		if(pThis-&gt;bReportSuspensionCont == -1)
418 			pThis-&gt;bReportSuspensionCont = 1;
419 	}
420 }
421 static void ATTR_NONNULL() actionRetry(action_t * const pThis, wti_t * const pWti)
422 {
423 	setSuspendMessageConfVars(pThis);
424 	actionSetState(pThis, pWti, ACT_STATE_RTRY);
425 	if(pThis-&gt;bReportSuspension) {
426 		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
427 		      "action '%s' suspended (module '%s'), retry %d. There should "
428 		      "be messages before this one giving the reason for suspension.",
429 		      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName,
430 		      getActionNbrResRtry(pWti, pThis));
431 	}
432 	incActionResumeInRow(pWti, pThis);
433 }
434 static void ATTR_NONNULL()
435 actionSuspend(action_t * const pThis, wti_t * const pWti)
436 {
437 	time_t ttNow;
438 	int suspendDuration;
439 	char timebuf[32];
440 	setSuspendMessageConfVars(pThis);
441 	datetime.GetTime(&amp;ttNow);
442 	suspendDuration = pThis-&gt;iResumeInterval * (getActionNbrResRtry(pWti, pThis) / 10 + 1);
443 	if(pThis-&gt;iResumeIntervalMax &gt; 0 &amp;&amp; suspendDuration &gt; pThis-&gt;iResumeIntervalMax) {
444 		suspendDuration = pThis-&gt;iResumeIntervalMax;
445 	}
446 	pThis-&gt;ttResumeRtry = ttNow + suspendDuration;
447 	actionSetState(pThis, pWti, ACT_STATE_SUSP);
448 	pThis-&gt;ctrSuspendDuration += suspendDuration;
449 	if(getActionNbrResRtry(pWti, pThis) == 0) {
450 		STATSCOUNTER_INC(pThis-&gt;ctrSuspend, pThis-&gt;mutCtrSuspend);
451 	}
452 	if(   pThis-&gt;bReportSuspensionCont
453 	   || (pThis-&gt;bReportSuspension &amp;&amp; getActionNbrResRtry(pWti, pThis) == 0) ) {
454 		ctime_r(&amp;pThis-&gt;ttResumeRtry, timebuf);
455 		timebuf[strlen(timebuf)-1] = '\0'; 		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
456 			      "action '%s' suspended (module '%s'), next retry is %s, retry nbr %d. "
457 			      "There should be messages before this one giving the reason for suspension.",
458 			      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName, timebuf,
459 			      getActionNbrResRtry(pWti, pThis));
460 	}
461 	DBGPRINTF("action '%s' suspended, earliest retry=%lld (now %lld), iNbrResRtry %d, "
462 		  "duration %d\n",
463 		  pThis-&gt;pszName, (long long) pThis-&gt;ttResumeRtry, (long long) ttNow,
464 		  getActionNbrResRtry(pWti, pThis), suspendDuration);
465 }
466 static rsRetVal ATTR_NONNULL()
467 actionDoRetry(action_t * const pThis, wti_t * const pWti)
468 {
469 	int iRetries;
470 	int iSleepPeriod;
471 	int bTreatOKasSusp;
472 	DEFiRet;
473 	assert(pThis != NULL);
474 	iRetries = 0;
475 	while((*pWti-&gt;pbShutdownImmediate == 0) &amp;&amp; getActionState(pWti, pThis) == ACT_STATE_RTRY) {
476 		DBGPRINTF("actionDoRetry: %s enter loop, iRetries=%d, ResumeInRow %d\n",
477 			pThis-&gt;pszName, iRetries, getActionResumeInRow(pWti, pThis));
478 			iRet = pThis-&gt;pMod-&gt;tryResume(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
479 		DBGPRINTF("actionDoRetry: %s action-&gt;tryResume returned %d\n", pThis-&gt;pszName, iRet);
480 		if((getActionResumeInRow(pWti, pThis) &gt; 9) &amp;&amp; (getActionResumeInRow(pWti, pThis) % 10 == 0)) {
481 			bTreatOKasSusp = 1;
482 			setActionResumeInRow(pWti, pThis, 0);
483 			iRet = RS_RET_SUSPENDED;
484 		} else {
485 			bTreatOKasSusp = 0;
486 		}
487 		if((iRet == RS_RET_OK) &amp;&amp; (!bTreatOKasSusp)) {
488 			DBGPRINTF("actionDoRetry: %s had success RDY again (iRet=%d)\n",
489 				  pThis-&gt;pszName, iRet);
490 			STATSCOUNTER_INC(pThis-&gt;ctrResume, pThis-&gt;mutCtrResume);
491 			if(pThis-&gt;bReportSuspension) {
492 				LogMsg(0, RS_RET_RESUMED, LOG_INFO, "action '%s' "
493 					      "resumed (module '%s')",
494 					      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
495 			}
496 			actionSetState(pThis, pWti, ACT_STATE_RDY);
497 		} else if(iRet == RS_RET_SUSPENDED || bTreatOKasSusp) {
498 			DBGPRINTF("actionDoRetry: %s check for max retries, iResumeRetryCount "
499 				  "%d, iRetries %d\n",
500 				  pThis-&gt;pszName, pThis-&gt;iResumeRetryCount, iRetries);
501 			if((pThis-&gt;iResumeRetryCount != -1 &amp;&amp; iRetries &gt;= pThis-&gt;iResumeRetryCount)) {
502 				actionSuspend(pThis, pWti);
503 				if(getActionNbrResRtry(pWti, pThis) &lt; 20)
504 					incActionNbrResRtry(pWti, pThis);
505 			} else {
506 				++iRetries;
507 				iSleepPeriod = pThis-&gt;iResumeInterval;
508 				srSleep(iSleepPeriod, 0);
509 				if(*pWti-&gt;pbShutdownImmediate) {
510 					ABORT_FINALIZE(RS_RET_FORCE_TERM);
511 				}
512 			}
513 		} else if(iRet == RS_RET_DISABLE_ACTION) {
514 			actionDisable(pThis);
515 		}
516 	}
517 	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
518 		setActionNbrResRtry(pWti, pThis, 0);
519 	}
520 finalize_it:
521 	RETiRet;
522 }
523 static rsRetVal ATTR_NONNULL()
524 actionDoRetry_extFile(action_t *const pThis, wti_t *const pWti)
525 {
526 	int iRetries;
527 	int iSleepPeriod;
528 	DEFiRet;
529 	assert(pThis != NULL);
530 	DBGPRINTF("actionDoRetry_extFile: enter, actionState: %d\n",getActionState(pWti, pThis));
531 	iRetries = 0;
532 	while((*pWti-&gt;pbShutdownImmediate == 0) &amp;&amp; getActionState(pWti, pThis) == ACT_STATE_RTRY) {
533 		DBGPRINTF("actionDoRetry_extFile: %s enter loop, iRetries=%d, ResumeInRow %d\n",
534 			pThis-&gt;pszName, iRetries, getActionResumeInRow(pWti, pThis));
535 			iRet = checkExternalStateFile(pThis, pWti);
536 		DBGPRINTF("actionDoRetry_extFile: %s checkExternalStateFile returned %d\n", pThis-&gt;pszName, iRet);
537 		if(iRet == RS_RET_OK) {
538 			DBGPRINTF("actionDoRetry_extFile: %s had success RDY again (iRet=%d)\n",
539 				  pThis-&gt;pszName, iRet);
540 			if(pThis-&gt;bReportSuspension) {
541 				LogMsg(0, RS_RET_RESUMED, LOG_INFO, "action '%s' "
542 				      "resumed (module '%s') via external state file",
543 				      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
544 			}
545 			actionSetState(pThis, pWti, ACT_STATE_RDY);
546 		} else if(iRet == RS_RET_SUSPENDED) {
547 			DBGPRINTF("actionDoRetry_extFile: %s check for max retries, iResumeRetryCount "
548 				  "%d, iRetries %d\n",
549 				  pThis-&gt;pszName, pThis-&gt;iResumeRetryCount, iRetries);
550 			if((pThis-&gt;iResumeRetryCount != -1 &amp;&amp; iRetries &gt;= pThis-&gt;iResumeRetryCount)) {
551 				DBGPRINTF("actionDoRetry_extFile: did not work out, suspending\n");
552 				actionSuspend(pThis, pWti);
553 				pWti-&gt;execState.bPrevWasSuspended = 1;
554 				if(getActionNbrResRtry(pWti, pThis) &lt; 20)
555 					incActionNbrResRtry(pWti, pThis);
556 			} else {
557 				++iRetries;
558 				iSleepPeriod = pThis-&gt;iResumeInterval;
559 				srSleep(iSleepPeriod, 0);
560 				if(*pWti-&gt;pbShutdownImmediate) {
561 					ABORT_FINALIZE(RS_RET_FORCE_TERM);
562 				}
563 			}
564 		} else if(iRet == RS_RET_DISABLE_ACTION) {
565 			actionDisable(pThis);
566 		}
567 	}
568 	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
569 		setActionNbrResRtry(pWti, pThis, 0);
570 	}
571 finalize_it:
572 	RETiRet;
573 }
574 static rsRetVal
575 actionCheckAndCreateWrkrInstance(action_t * const pThis, const wti_t *const pWti)
576 {
577 	int locked = 0;
578 	DEFiRet;
579 	if(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData == NULL) {
580 		DBGPRINTF("wti %p: we need to create a new action worker instance for "
581 			  "action %d\n", pWti, pThis-&gt;iActionNbr);
582 		CHKiRet(pThis-&gt;pMod-&gt;mod.om.createWrkrInstance(&amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData),
583 						               pThis-&gt;pModData));
584 		pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].pAction = pThis;
585 		setActionState(pWti, pThis, ACT_STATE_RDY); 
586 		pthread_mutex_lock(&amp;pThis-&gt;mutWrkrDataTable);
587 		locked = 1;
588 		int freeSpot;
589 		for(freeSpot = 0 ; freeSpot &lt; pThis-&gt;wrkrDataTableSize ; ++freeSpot)
590 			if(pThis-&gt;wrkrDataTable[freeSpot] == NULL)
591 				break;
592 		if(pThis-&gt;nWrkr == pThis-&gt;wrkrDataTableSize) {
593 			void *const newTable = realloc(pThis-&gt;wrkrDataTable,
594 				(pThis-&gt;wrkrDataTableSize + 1) * sizeof(void*));
595 			if(newTable == NULL) {
596 				DBGPRINTF("actionCheckAndCreateWrkrInstance: out of "
597 					"memory realloc wrkrDataTable\n")
598 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
599 			}
600 			pThis-&gt;wrkrDataTable = newTable;
601 			pThis-&gt;wrkrDataTableSize++;
602 		}
603 		pThis-&gt;wrkrDataTable[freeSpot] = pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData;
604 		pThis-&gt;nWrkr++;
605 		DBGPRINTF("wti %p: created action worker instance %d for "
606 			  "action %d\n", pWti, pThis-&gt;nWrkr, pThis-&gt;iActionNbr);
607 	}
608 finalize_it:
609 	if(locked) {
610 		pthread_mutex_unlock(&amp;pThis-&gt;mutWrkrDataTable);
611 	}
612 	RETiRet;
613 }
614 static rsRetVal
615 actionTryResume(action_t * const pThis, wti_t * const pWti)
616 {
617 	DEFiRet;
618 	time_t ttNow = NO_TIME_PROVIDED;
619 	if(getActionState(pWti, pThis) == ACT_STATE_SUSP) {
620 		datetime.GetTime(&amp;ttNow); 		if(ttNow &gt;= pThis-&gt;ttResumeRtry) {
621 			actionSetState(pThis, pWti, ACT_STATE_RTRY); 		}
622 	}
623 	if(getActionState(pWti, pThis) == ACT_STATE_RTRY) {
624 		CHKiRet(actionDoRetry(pThis, pWti));
625 	}
626 	if(Debug &amp;&amp; (getActionState(pWti, pThis) == ACT_STATE_RTRY ||
627 		getActionState(pWti, pThis) == ACT_STATE_SUSP)) {
628 		if(ttNow == NO_TIME_PROVIDED) 			datetime.GetTime(&amp;ttNow);
629 		dbgprintf("actionTryResume: action[%s] state: %s, next retry (if applicable): %u [now %u]\n",
630 			pThis-&gt;pszName, getActStateName(pThis, pWti),
631 			(unsigned) pThis-&gt;ttResumeRtry, (unsigned) ttNow);
632 	}
633 finalize_it:
634 	RETiRet;
635 }
636 static rsRetVal ATTR_NONNULL()
637 actionPrepare(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
638 {
639 	DEFiRet;
640 DBGPRINTF("actionPrepare[%s]: enter\n", pThis-&gt;pszName);
641 	CHKiRet(actionCheckAndCreateWrkrInstance(pThis, pWti));
642 	CHKiRet(actionTryResume(pThis, pWti));
643 	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
644 		iRet = checkExternalStateFile(pThis, pWti);
645 		if(iRet == RS_RET_SUSPENDED) {
646 			DBGPRINTF("actionPrepare[%s]: SUSPENDED via external state file, "
647 				"doing retry processing\n", pThis-&gt;pszName);
648 			CHKiRet(actionDoRetry_extFile(pThis, pWti));
649 		}
650 		iRet = pThis-&gt;pMod-&gt;mod.om.beginTransaction(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
651 		switch(iRet) {
652 			case RS_RET_OK:
653 				actionSetState(pThis, pWti, ACT_STATE_ITX);
654 				break;
655 			case RS_RET_SUSPENDED:
656 				actionRetry(pThis, pWti);
657 				break;
658 			case RS_RET_DISABLE_ACTION:
659 				actionDisable(pThis);
660 				break;
661 			default:FINALIZE;
662 		}
663 	}
664 finalize_it:
665 	RETiRet;
666 }
667 static rsRetVal
668 prepareDoActionParams(action_t * __restrict__ const pAction,
669 		      wti_t * __restrict__ const pWti,
670 		      smsg_t *__restrict__ const pMsg,
671 		      struct syslogTime *ttNow)
672 {
673 	int i;
674 	struct json_object *json;
675 	actWrkrIParams_t *iparams;
676 	actWrkrInfo_t *__restrict__ pWrkrInfo;
677 	DEFiRet;
678 	pWrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr]);
679 	if(pAction-&gt;isTransactional) {
680 		CHKiRet(wtiNewIParam(pWti, pAction, &amp;iparams));
681 		for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
682 			CHKiRet(tplToString(pAction-&gt;ppTpl[i], pMsg,
683 					    &amp;actParam(iparams, pAction-&gt;iNumTpls, 0, i),
684 				            ttNow));
685 		}
686 	} else {
687 		for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
688 			switch(pAction-&gt;peParamPassing[i]) {
689 			case ACT_STRING_PASSING:
690 				CHKiRet(tplToString(pAction-&gt;ppTpl[i], pMsg,
691 					   &amp;(pWrkrInfo-&gt;p.nontx.actParams[i]),
692 					   ttNow));
693 				break;
694 			case ACT_MSG_PASSING:
695 				pWrkrInfo-&gt;p.nontx.actParams[i].param = (void*) pMsg;
696 				break;
697 			case ACT_JSON_PASSING:
698 				CHKiRet(tplToJSON(pAction-&gt;ppTpl[i], pMsg, &amp;json, ttNow));
699 				pWrkrInfo-&gt;p.nontx.actParams[i].param = (void*) json;
700 				break;
701 			default:dbgprintf("software bug/error: unknown "
702 				"pAction-&gt;peParamPassing[%d] %d in prepareDoActionParams\n",
703 					  i, (int) pAction-&gt;peParamPassing[i]);
704 				break;
705 			}
706 		}
707 	}
708 finalize_it:
709 	RETiRet;
710 }
711 void
712 releaseDoActionParams(action_t *__restrict__ const pAction, wti_t *__restrict__ const pWti, int action_destruct)
713 {
714 	int j;
715 	actWrkrInfo_t *__restrict__ pWrkrInfo;
716 	pWrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr]);
717 	for(j = 0 ; j &lt; pAction-&gt;iNumTpls ; ++j) {
718 		if (action_destruct) {
719 			if (ACT_STRING_PASSING == pAction-&gt;peParamPassing[j]) {
720 				free(pWrkrInfo-&gt;p.nontx.actParams[j].param);
721 				pWrkrInfo-&gt;p.nontx.actParams[j].param = NULL;
722 				pWrkrInfo-&gt;p.nontx.actParams[j].lenBuf = 0;
723 				pWrkrInfo-&gt;p.nontx.actParams[j].lenStr = 0;
724 			}
725 		} else {
726 			switch(pAction-&gt;peParamPassing[j]) {
727 			case ACT_ARRAY_PASSING:
728 				LogError(0, RS_RET_ERR, "plugin error: no longer supported "
729 					"ARRAY_PASSING mode is used (see action.c)");
730 				return;
731 			case ACT_JSON_PASSING:
732 				json_object_put((struct json_object*)
733 								pWrkrInfo-&gt;p.nontx.actParams[j].param);
734 				pWrkrInfo-&gt;p.nontx.actParams[j].param = NULL;
735 				pWrkrInfo-&gt;p.nontx.actParams[j].lenBuf = 0;
736 				pWrkrInfo-&gt;p.nontx.actParams[j].lenStr = 0;
737 				break;
738 			case ACT_STRING_PASSING:
739 			case ACT_MSG_PASSING:
740 				break;
741 			}
742 		}
743 	}
744 	return;
745 }
746 static void
747 actionSetActionWorked(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
748 {
749 	setActionResumeInRow(pWti, pThis, 0);
750 }
751 static rsRetVal
752 handleActionExecResult(action_t *__restrict__ const pThis,
753 	wti_t *__restrict__ const pWti,
754 	const rsRetVal ret)
755 {
756 	DEFiRet;
757 	switch(ret) {
758 		case RS_RET_OK:
759 			actionCommitted(pThis, pWti);
760 			actionSetActionWorked(pThis, pWti); 			break;
761 		case RS_RET_DEFER_COMMIT:
762 			actionSetActionWorked(pThis, pWti); 			break;
763 		case RS_RET_PREVIOUS_COMMITTED:
764 			pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 1;
765 			actionSetActionWorked(pThis, pWti); 			break;
766 		case RS_RET_DISABLE_ACTION:
767 			actionDisable(pThis);
768 			break;
769 		case RS_RET_SUSPENDED:
770 			actionRetry(pThis, pWti);
771 			break;
772 			LogError(0, ret, "action '%s' (module '%s') "
773 				"message lost, could not be processed. Check for "
774 				"additional error messages before this one.",
775 				pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
776 			actionSetState(pThis, pWti, ACT_STATE_DATAFAIL);
777 			break;
778 	}
779 	iRet = getReturnCode(pThis, pWti);
780 	RETiRet;
781 }
782 static rsRetVal
783 actionCallDoAction(action_t *__restrict__ const pThis,
784 	actWrkrIParams_t *__restrict__ const iparams,
785 	wti_t *__restrict__ const pWti)
786 {
787 	void *param[CONF_OMOD_NUMSTRINGS_MAXSIZE];
788 	int i;
789 	DEFiRet;
790 	DBGPRINTF("entering actionCalldoAction(), state: %s, actionNbr %d\n",
791 		  getActStateName(pThis, pWti), pThis-&gt;iActionNbr);
792 	pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 0;
793 	for(i = 0 ; i &lt; pThis-&gt;iNumTpls ; ++i) {
794 		param[i] = actParam(iparams, pThis-&gt;iNumTpls, 0, i).param;
795 	}
796 	iRet = pThis-&gt;pMod-&gt;mod.om.doAction(param,
797 				            pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
798 	iRet = handleActionExecResult(pThis, pWti, iRet);
799 	RETiRet;
800 }
801 static rsRetVal ATTR_NONNULL()
802 actionCallCommitTransaction(action_t * const pThis,
803 	wti_t *const pWti,
804 	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
805 {
806 	DEFiRet;
807 	DBGPRINTF("entering actionCallCommitTransaction[%s], state: %s, nMsgs %u\n",
808 		  pThis-&gt;pszName, getActStateName(pThis, pWti), nparams);
809 	iRet = pThis-&gt;pMod-&gt;mod.om.commitTransaction(
810 		    pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData,
811 		    iparams, nparams);
812 	DBGPRINTF("actionCallCommitTransaction[%s] state: %s "
813 		"mod commitTransaction returned %d\n",
814 		pThis-&gt;pszName, getActStateName(pThis, pWti), iRet);
815 	iRet = handleActionExecResult(pThis, pWti, iRet);
816 	RETiRet;
817 }
818 static rsRetVal
819 actionProcessMessage(action_t * const pThis, void *actParams, wti_t * const pWti)
820 {
821 	DEFiRet;
822 	CHKiRet(actionPrepare(pThis, pWti));
823 	if(pThis-&gt;pMod-&gt;mod.om.SetShutdownImmdtPtr != NULL)
824 		pThis-&gt;pMod-&gt;mod.om.SetShutdownImmdtPtr(pThis-&gt;pModData, pWti-&gt;pbShutdownImmediate);
825 	if(getActionState(pWti, pThis) == ACT_STATE_ITX)
826 		CHKiRet(actionCallDoAction(pThis, actParams, pWti));
827 	iRet = getReturnCode(pThis, pWti);
828 finalize_it:
829 	RETiRet;
830 }
831 static rsRetVal
832 doTransaction(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
833 	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
834 {
835 	actWrkrInfo_t *wrkrInfo;
836 	int i;
837 	DEFiRet;
838 	wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
839 	if(pThis-&gt;pMod-&gt;mod.om.commitTransaction != NULL) {
840 		DBGPRINTF("doTransaction: have commitTransaction IF, using that, pWrkrInfo %p\n", wrkrInfo);
841 		CHKiRet(actionCallCommitTransaction(pThis, pWti, iparams, nparams));
842 	} else { 		DBGPRINTF("doTransaction: action '%s', currIParam %d\n",
843 			   pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam);
844 		for(i = 0 ; i &lt; nparams ; ++i) {
845 			iRet = actionProcessMessage(pThis,
846 				&amp;actParam(iparams, pThis-&gt;iNumTpls, i, 0), pWti);
847 			DBGPRINTF("doTransaction: action %d, processing msg %d, result %d\n",
848 			   pThis-&gt;iActionNbr, i,iRet);
849 			if(iRet == RS_RET_SUSPENDED) {
850 				srSleep(1, 0);
851 			} else if(iRet != RS_RET_DEFER_COMMIT &amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED &amp;&amp;
852 			   iRet != RS_RET_OK) {
853 				FINALIZE; 			}
854 		}
855 	}
856 finalize_it:
857 	if(iRet == RS_RET_DEFER_COMMIT || iRet == RS_RET_PREVIOUS_COMMITTED)
858 		iRet = RS_RET_OK; 	RETiRet;
859 }
860 static rsRetVal ATTR_NONNULL()
861 actionTryCommit(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
862 	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
863 {
864 	DEFiRet;
865 	DBGPRINTF("actionTryCommit[%s] enter\n", pThis-&gt;pszName);
866 	CHKiRet(actionPrepare(pThis, pWti));
867 	CHKiRet(doTransaction(pThis, pWti, iparams, nparams));
868 	if(getActionState(pWti, pThis) == ACT_STATE_ITX) {
869 		iRet = pThis-&gt;pMod-&gt;mod.om.endTransaction(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
870 		switch(iRet) {
871 			case RS_RET_OK:
872 				actionCommitted(pThis, pWti);
873 				break;
874 			case RS_RET_SUSPENDED:
875 				actionRetry(pThis, pWti);
876 				break;
877 			case RS_RET_DISABLE_ACTION:
878 				actionDisable(pThis);
879 				break;
880 			case RS_RET_DEFER_COMMIT:
881 				DBGPRINTF("output plugin error: endTransaction() returns RS_RET_DEFER_COMMIT "
882 					  "- ignored\n");
883 				actionCommitted(pThis, pWti);
884 				break;
885 			case RS_RET_PREVIOUS_COMMITTED:
886 				DBGPRINTF("output plugin error: endTransaction() returns RS_RET_PREVIOUS_COMMITTED "
887 					  "- ignored\n");
888 				actionCommitted(pThis, pWti);
889 				break;
890 				DBGPRINTF("action[%s]: actionTryCommit receveived iRet %d\n",
891 					pThis-&gt;pszName, iRet);
892 				FINALIZE;
893 		}
894 	}
895 	iRet = getReturnCode(pThis, pWti);
896 finalize_it:
897 	RETiRet;
898 }
899 static void ATTR_NONNULL()
900 actionWriteErrorFile(action_t *__restrict__ const pThis, const rsRetVal ret,
901 	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
902 {
903 	fjson_object *etry=NULL;
904 	int bNeedUnlock = 0;
905 	STATSCOUNTER_INC(pThis-&gt;ctrFail, pThis-&gt;mutCtrFail);
906 	if(pThis-&gt;pszErrFile == NULL) {
907 		DBGPRINTF("action %s: commit failed, no error file set, silently "
908 			"discarding %d messages\n", pThis-&gt;pszName, nparams);
909 		goto done;
910 	}
911 	DBGPRINTF("action %d commit failed, writing %u messages (%d tpls) to error file\n",
912 		pThis-&gt;iActionNbr, nparams, pThis-&gt;iNumTpls);
913 	pthread_mutex_lock(&amp;pThis-&gt;mutErrFile);
914 	bNeedUnlock = 1;
915 	if(pThis-&gt;fdErrFile == -1) {
916 		pThis-&gt;fdErrFile = open(pThis-&gt;pszErrFile,
917 					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
918 					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
919 		if(pThis-&gt;fdErrFile == -1) {
920 			LogError(errno, RS_RET_ERR, "action %s: error opening error file %s",
921 				pThis-&gt;pszName, pThis-&gt;pszErrFile);
922 			goto done;
923 		}
924 		if (pThis-&gt;maxErrFileSize &gt; 0) {
925 			struct stat statbuf;
926 			if (fstat(pThis-&gt;fdErrFile, &amp;statbuf) == -1) {
927 				LogError(errno, RS_RET_ERR, "failed to fstat %s", pThis-&gt;pszErrFile);
928 				goto done;
929 			}
930 			pThis-&gt;currentErrFileSize = statbuf.st_size;
931 		}
932 	}
933 	for(int i = 0 ; i &lt; nparams ; ++i) {
934 		if((etry = fjson_object_new_object()) == NULL)
935 			goto done;
936 		fjson_object_object_add(etry, "action", fjson_object_new_string((char*)pThis-&gt;pszName));
937 		fjson_object_object_add(etry, "status", fjson_object_new_int(ret));
938 		for(int j = 0 ; j &lt; pThis-&gt;iNumTpls ; ++j) {
939 			char tplname[20];
940 			snprintf(tplname, sizeof(tplname), "template%d", j);
941 			tplname[sizeof(tplname)-1] = '\0';
942 			fjson_object_object_add(etry, tplname,
943 				fjson_object_new_string((char*)actParam(iparams, 1, i, j).param));
944 		}
945 		char *const rendered = strdup((char*)fjson_object_to_json_string(etry));
946 		if(rendered == NULL)
947 			goto done;
948 		size_t toWrite = strlen(rendered) + 1;
949 		if (pThis-&gt;maxErrFileSize &gt; 0) {
950 			if (pThis-&gt;currentErrFileSize + toWrite &gt; pThis-&gt;maxErrFileSize) {
951 				toWrite = pThis-&gt;maxErrFileSize - pThis-&gt;currentErrFileSize;
952 			}
953 			pThis-&gt;currentErrFileSize += toWrite;
954 		}
955 		if(toWrite &gt; 0) {
956 			rendered[toWrite-1] = '\n'; 			const ssize_t wrRet = write(pThis-&gt;fdErrFile, rendered, toWrite);
957 			if(wrRet != (ssize_t) toWrite) {
958 				LogError(errno, RS_RET_IO_ERROR,
959 					"action %s: error writing errorFile %s, write returned %lld",
960 					pThis-&gt;pszName, pThis-&gt;pszErrFile, (long long) wrRet);
961 			}
962 		}
963 		free(rendered);
964 		fjson_object_put(etry);
965 		etry = NULL;
966 	}
967 done:
968 	if(bNeedUnlock) {
969 		pthread_mutex_unlock(&amp;pThis-&gt;mutErrFile);
970 	}
971 	fjson_object_put(etry);
972 	return;
973 }
974 static rsRetVal
975 actionTryRemoveHardErrorsFromBatch(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
976 	actWrkrIParams_t *const new_iparams, unsigned *new_nMsgs)
977 {
978 	actWrkrInfo_t *const wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
979 	const unsigned nMsgs = wrkrInfo-&gt;p.tx.currIParam;
980 	actWrkrIParams_t oneParamSet[CONF_OMOD_NUMSTRINGS_MAXSIZE];
981 	rsRetVal ret;
982 	DEFiRet;
983 	*new_nMsgs = 0;
984 	for(unsigned i = 0 ; i &lt; nMsgs ; ++i) {
985 		setActionResumeInRow(pWti, pThis, 0); 		memcpy(&amp;oneParamSet, &amp;actParam(wrkrInfo-&gt;p.tx.iparams, pThis-&gt;iNumTpls, i, 0),
986 			sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls);
987 		ret = actionTryCommit(pThis, pWti, oneParamSet, 1);
988 		if(ret == RS_RET_SUSPENDED) {
989 			memcpy(new_iparams + (*new_nMsgs * pThis-&gt;iNumTpls), &amp;oneParamSet,
990 				sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls);
991 			++(*new_nMsgs);
992 		} else if(ret != RS_RET_OK) {
993 			actionWriteErrorFile(pThis, ret, oneParamSet, 1);
994 		}
995 	}
996 	RETiRet;
997 }
998 static rsRetVal ATTR_NONNULL()
999 actionCommit(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
1000 {
1001 	actWrkrInfo_t *const wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
1002 	unsigned nMsgs = 0;
1003 	actWrkrIParams_t *iparams = NULL;
1004 	int needfree_iparams = 0; 	DEFiRet;
1005 	DBGPRINTF("actionCommit[%s]: enter, %d msgs\n", pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam);
1006 	if(!pThis-&gt;isTransactional || pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].p.tx.currIParam == 0) {
1007 		FINALIZE;
1008 	} else if(getActionState(pWti, pThis) == ACT_STATE_SUSP) {
1009 		actionWriteErrorFile(pThis, iRet, wrkrInfo-&gt;p.tx.iparams, wrkrInfo-&gt;p.tx.currIParam);
1010 		FINALIZE;
1011 	}
1012 	DBGPRINTF("actionCommit[%s]: processing...\n", pThis-&gt;pszName);
1013 	iRet = actionTryCommit(pThis, pWti, wrkrInfo-&gt;p.tx.iparams, wrkrInfo-&gt;p.tx.currIParam);
1014 DBGPRINTF("actionCommit[%s]: return actionTryCommit %d\n", pThis-&gt;pszName, iRet);
1015 	if(iRet == RS_RET_OK) {
1016 		FINALIZE;
1017 	}
1018 	if(wrkrInfo-&gt;p.tx.currIParam == 1) {
1019 		needfree_iparams = 0;
1020 		iparams = wrkrInfo-&gt;p.tx.iparams;
1021 		nMsgs = wrkrInfo-&gt;p.tx.currIParam;
1022 		if(iRet == RS_RET_DATAFAIL) {
1023 			FINALIZE;
1024 		}
1025 	} else {
1026 		DBGPRINTF("actionCommit[%s]: somewhat unhappy, full batch of %d msgs returned "
1027 			"status %d. Trying messages as individual actions.\n",
1028 			pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam, iRet);
1029 		CHKmalloc(iparams = malloc(sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls
1030 			* wrkrInfo-&gt;p.tx.currIParam));
1031 		needfree_iparams = 1;
1032 		actionTryRemoveHardErrorsFromBatch(pThis, pWti, iparams, &amp;nMsgs);
1033 	}
1034 	if(nMsgs == 0) {
1035 		ABORT_FINALIZE(RS_RET_OK); 	}
1036 	DBGPRINTF("actionCommit[%s]: unhappy, we still have %d uncommitted messages.\n",
1037 		pThis-&gt;pszName, nMsgs);
1038 	int bDone = 0;
1039 	do {
1040 		iRet = actionTryCommit(pThis, pWti, iparams, nMsgs);
1041 		DBGPRINTF("actionCommit[%s]: in retry loop, iRet %d\n",
1042 			pThis-&gt;pszName, iRet);
1043 		if(iRet == RS_RET_FORCE_TERM) {
1044 			ABORT_FINALIZE(RS_RET_FORCE_TERM);
1045 		} else if(iRet == RS_RET_SUSPENDED) {
1046 			iRet = actionDoRetry(pThis, pWti);
1047 			DBGPRINTF("actionCommit[%s]: actionDoRetry returned %d\n",
1048 				pThis-&gt;pszName, iRet);
1049 			if(iRet == RS_RET_FORCE_TERM) {
1050 				ABORT_FINALIZE(RS_RET_FORCE_TERM);
1051 			} else if(iRet != RS_RET_OK) {
1052 				actionWriteErrorFile(pThis, iRet, iparams, nMsgs);
1053 				bDone = 1;
1054 			}
1055 			continue;
1056 		} else if(iRet == RS_RET_OK ||
1057 		          iRet == RS_RET_SUSPENDED ||
1058 			  iRet == RS_RET_ACTION_FAILED) {
1059 			bDone = 1;
1060 		}
1061 		if(getActionState(pWti, pThis) == ACT_STATE_RDY  ||
1062 		   getActionState(pWti, pThis) == ACT_STATE_SUSP) {
1063 			bDone = 1;
1064 		}
1065 	} while(!bDone);
1066 finalize_it:
1067 	DBGPRINTF("actionCommit[%s]: done, iRet %d\n", pThis-&gt;pszName, iRet);
1068 	if(needfree_iparams) {
1069 		free(iparams);
1070 	}
1071 	wrkrInfo-&gt;p.tx.currIParam = 0; 	RETiRet;
1072 }
1073 void ATTR_NONNULL()
1074 actionCommitAllDirect(wti_t *__restrict__ const pWti)
1075 {
1076 	int i;
1077 	action_t *pAction;
1078 	for(i = 0 ; i &lt; runConf-&gt;actions.iActionNbr ; ++i) {
1079 		pAction = pWti-&gt;actWrkrInfo[i].pAction;
1080 		if(pAction == NULL)
1081 			continue;
1082 		DBGPRINTF("actionCommitAllDirect: action %d, state %u, nbr to commit %d "
1083 			  "isTransactional %d\n",
1084 			  i, getActionStateByNbr(pWti, i), pWti-&gt;actWrkrInfo-&gt;p.tx.currIParam,
1085 			  pAction-&gt;isTransactional);
1086 		if(pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT)
1087 			actionCommit(pAction, pWti);
1088 	}
1089 }
1090 static rsRetVal
1091 processMsgMain(action_t *__restrict__ const pAction,
1092 	wti_t *__restrict__ const pWti,
1093 	smsg_t *__restrict__ const pMsg,
1094 	struct syslogTime *ttNow)
1095 {
1096 	DEFiRet;
1097 	CHKiRet(prepareDoActionParams(pAction, pWti, pMsg, ttNow));
1098 	if(pAction-&gt;isTransactional) {
1099 		pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr].pAction = pAction;
1100 		DBGPRINTF("action '%s': is transactional - executing in commit phase\n", pAction-&gt;pszName);
1101 		actionPrepare(pAction, pWti);
1102 		iRet = getReturnCode(pAction, pWti);
1103 		FINALIZE;
1104 	}
1105 	iRet = actionProcessMessage(pAction,
1106 				    pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr].p.nontx.actParams,
1107 				    pWti);
1108 	if(pAction-&gt;bNeedReleaseBatch)
1109 		releaseDoActionParams(pAction, pWti, 0);
1110 finalize_it:
1111 	if(iRet == RS_RET_OK) {
1112 		if(pWti-&gt;execState.bDoAutoCommit)
1113 			iRet = actionCommit(pAction, pWti);
1114 	}
1115 	RETiRet;
1116 }
1117 static rsRetVal ATTR_NONNULL()
1118 processBatchMain(void *__restrict__ const pVoid,
1119 	batch_t *__restrict__ const pBatch,
1120 	wti_t *__restrict__ const pWti)
1121 {
1122 	action_t *__restrict__ const pAction = (action_t*__restrict__ const) pVoid;
1123 	int i;
1124 	struct syslogTime ttNow;
1125 	DEFiRet;
1126 	wtiResetExecState(pWti, pBatch);
1127 	ttNow.year = 0;
1128 	for(i = 0 ; i &lt; batchNumMsgs(pBatch) &amp;&amp; !*pWti-&gt;pbShutdownImmediate ; ++i) {
1129 		if(batchIsValidElem(pBatch, i)) {
1130 			rsRetVal localRet = processMsgMain(pAction, pWti, pBatch-&gt;pElem[i].pMsg, &amp;ttNow);
1131 			DBGPRINTF("processBatchMain: i %d, processMsgMain iRet %d\n", i, localRet);
1132 			if(   localRet == RS_RET_OK
1133 			   || localRet == RS_RET_DEFER_COMMIT
1134 			   || localRet == RS_RET_ACTION_FAILED
1135 			   || localRet == RS_RET_PREVIOUS_COMMITTED ) {
1136 				batchSetElemState(pBatch, i, BATCH_STATE_COMM);
1137 				DBGPRINTF("processBatchMain: i %d, COMM state set\n", i);
1138 			}
1139 		}
1140 	}
1141 	iRet = actionCommit(pAction, pWti);
1142 	RETiRet;
1143 }
1144 void
1145 actionRemoveWorker(action_t *const __restrict__ pAction,
1146 	void *const __restrict__ actWrkrData)
1147 {
1148 	pthread_mutex_lock(&amp;pAction-&gt;mutWrkrDataTable);
1149 	pAction-&gt;nWrkr--;
1150 	for(int w = 0 ; w &lt; pAction-&gt;wrkrDataTableSize ; ++w) {
1151 		if(pAction-&gt;wrkrDataTable[w] == actWrkrData) {
1152 			pAction-&gt;wrkrDataTable[w] = NULL;
1153 			break; 		}
1154 	}
1155 	pthread_mutex_unlock(&amp;pAction-&gt;mutWrkrDataTable);
1156 }
1157 rsRetVal
1158 actionCallHUPHdlr(action_t * const pAction)
1159 {
1160 	DEFiRet;
1161 	assert(pAction != NULL);
1162 	DBGPRINTF("Action %p checks HUP hdlr, act level: %p, wrkr level %p\n",
1163 		pAction, pAction-&gt;pMod-&gt;doHUP, pAction-&gt;pMod-&gt;doHUPWrkr);
1164 	if(pAction-&gt;pMod-&gt;doHUP != NULL) {
1165 		CHKiRet(pAction-&gt;pMod-&gt;doHUP(pAction-&gt;pModData));
1166 	}
1167 	if(pAction-&gt;pMod-&gt;doHUPWrkr != NULL) {
1168 		pthread_mutex_lock(&amp;pAction-&gt;mutWrkrDataTable);
1169 		for(int i = 0 ; i &lt; pAction-&gt;wrkrDataTableSize ; ++i) {
1170 			dbgprintf("HUP: table entry %d: %p %s\n", i,
1171 				pAction-&gt;wrkrDataTable[i],
1172 				pAction-&gt;wrkrDataTable[i] == NULL ? "[unused]" : "");
1173 			if(pAction-&gt;wrkrDataTable[i] != NULL) {
1174 				const rsRetVal localRet
1175 					= pAction-&gt;pMod-&gt;doHUPWrkr(pAction-&gt;wrkrDataTable[i]);
1176 				if(localRet != RS_RET_OK) {
1177 					DBGPRINTF("HUP handler returned error state %d - "
1178 						  "ignored\n", localRet);
1179 				}
1180 			}
1181 		}
1182 		pthread_mutex_unlock(&amp;pAction-&gt;mutWrkrDataTable);
1183 	}
1184 finalize_it:
1185 	RETiRet;
1186 }
1187 static rsRetVal setActionQueType(void __attribute__((unused)) *pVal, uchar *pszType)
1188 {
1189 	DEFiRet;
1190 	if (!strcasecmp((char *) pszType, "fixedarray")) {
1191 		cs.ActionQueType = QUEUETYPE_FIXED_ARRAY;
1192 		DBGPRINTF("action queue type set to FIXED_ARRAY\n");
1193 	} else if (!strcasecmp((char *) pszType, "linkedlist")) {
1194 		cs.ActionQueType = QUEUETYPE_LINKEDLIST;
1195 		DBGPRINTF("action queue type set to LINKEDLIST\n");
1196 	} else if (!strcasecmp((char *) pszType, "disk")) {
1197 		cs.ActionQueType = QUEUETYPE_DISK;
1198 		DBGPRINTF("action queue type set to DISK\n");
1199 	} else if (!strcasecmp((char *) pszType, "direct")) {
1200 		cs.ActionQueType = QUEUETYPE_DIRECT;
1201 		DBGPRINTF("action queue type set to DIRECT (no queueing at all)\n");
1202 	} else {
1203 		LogError(0, RS_RET_INVALID_PARAMS, "unknown actionqueue parameter: %s", (char *) pszType);
1204 		iRet = RS_RET_INVALID_PARAMS;
1205 	}
1206 	free(pszType); 
1207 	RETiRet;
1208 }
1209 static rsRetVal ATTR_NONNULL()
1210 doSubmitToActionQ(action_t * const pAction, wti_t * const pWti, smsg_t *pMsg)
1211 {
1212 	struct syslogTime ttNow; 	DEFiRet;
1213 	DBGPRINTF("action '%s': called, logging to %s (susp %d/%d, direct q %d)\n",
1214 		pAction-&gt;pszName, module.GetStateName(pAction-&gt;pMod),
1215 		pAction-&gt;bExecWhenPrevSusp, pWti-&gt;execState.bPrevWasSuspended,
1216 		pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT);
1217 	if(   pAction-&gt;bExecWhenPrevSusp
1218 	   &amp;&amp; !pWti-&gt;execState.bPrevWasSuspended) {
1219 		DBGPRINTF("action '%s': NOT executing, as previous action was "
1220 			  "not suspended\n", pAction-&gt;pszName);
1221 		FINALIZE;
1222 	}
1223 	STATSCOUNTER_INC(pAction-&gt;ctrProcessed, pAction-&gt;mutCtrProcessed);
1224 	if(pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT) {
1225 		ttNow.year = 0;
1226 		iRet = processMsgMain(pAction, pWti, pMsg, &amp;ttNow);
1227 		iRet = qqueueEnqMsg(pAction-&gt;pQueue, eFLOWCTL_NO_DELAY,
1228 			pAction-&gt;bCopyMsg ? MsgDup(pMsg) : MsgAddRef(pMsg));
1229 	}
1230 	pWti-&gt;execState.bPrevWasSuspended =
1231 		(iRet == RS_RET_SUSPENDED || iRet == RS_RET_ACTION_FAILED);
1232 	if (iRet == RS_RET_ACTION_FAILED)			STATSCOUNTER_INC(pAction-&gt;ctrFail, pAction-&gt;mutCtrFail);
1233 	DBGPRINTF("action '%s': set suspended state to %d\n",
1234 		pAction-&gt;pszName, pWti-&gt;execState.bPrevWasSuspended);
1235 finalize_it:
1236 	RETiRet;
1237 }
1238 rsRetVal
1239 actionWriteToAction(action_t * const pAction, smsg_t *pMsg, wti_t * const pWti)
1240 {
1241 	DEFiRet;
1242 	if(pAction-&gt;iExecEveryNthOccur &gt; 1) {
1243 		if(   pAction-&gt;iExecEveryNthOccurTO &gt; 0
1244 		   &amp;&amp; (getActNow(pAction) - pAction-&gt;tLastOccur) &gt; pAction-&gt;iExecEveryNthOccurTO) {
1245 		  	DBGPRINTF("n-th occurrence handling timed out (%d sec), restarting from 0\n",
1246 				  (int) (getActNow(pAction) - pAction-&gt;tLastOccur));
1247 			pAction-&gt;iNbrNoExec = 0;
1248 			pAction-&gt;tLastOccur = getActNow(pAction);
1249 		   }
1250 		if(pAction-&gt;iNbrNoExec &lt; pAction-&gt;iExecEveryNthOccur - 1) {
1251 			++pAction-&gt;iNbrNoExec;
1252 			DBGPRINTF("action %p passed %d times to execution - less than configured - discarding\n",
1253 			  pAction, pAction-&gt;iNbrNoExec);
1254 			FINALIZE;
1255 		} else {
1256 			pAction-&gt;iNbrNoExec = 0; 		}
1257 	}
1258 	DBGPRINTF("Called action(complex case), logging to %s\n", module.GetStateName(pAction-&gt;pMod));
1259 	if(pAction-&gt;iSecsExecOnceInterval &gt; 0 &amp;&amp;
1260 	   pAction-&gt;iSecsExecOnceInterval + pAction-&gt;tLastExec &gt; getActNow(pAction)) {
1261 		DBGPRINTF("action not yet ready again to be executed, onceInterval %d, tCurr %d, tNext %d\n",
1262 			  (int) pAction-&gt;iSecsExecOnceInterval, (int) getActNow(pAction),
1263 			  (int) (pAction-&gt;iSecsExecOnceInterval + pAction-&gt;tLastExec));
1264 		FINALIZE;
1265 	}
1266 	pAction-&gt;tLastExec = getActNow(pAction); 	pAction-&gt;f_time = pMsg-&gt;ttGenTime;
1267 	iRet = doSubmitToActionQ(pAction, pWti, pMsg);
1268 finalize_it:
1269 	RETiRet;
1270 }
1271 PRAGMA_DIAGNOSTIC_PUSH;
1272 PRAGMA_IGNORE_Wempty_body;
1273 static rsRetVal
1274 doSubmitToActionQComplex(action_t * const pAction, wti_t * const pWti, smsg_t *pMsg)
1275 {
1276 	DEFiRet;
1277 	d_pthread_mutex_lock(&amp;pAction-&gt;mutAction);
1278 	pthread_cleanup_push(mutexCancelCleanup, &amp;pAction-&gt;mutAction);
1279 	DBGPRINTF("Called action %p (complex case), logging to %s\n",
1280 		  pAction, module.GetStateName(pAction-&gt;pMod));
1281 	pAction-&gt;tActNow = -1; 
1282 	if(pAction-&gt;bWriteAllMarkMsgs == 0
1283 	   &amp;&amp; (pMsg-&gt;msgFlags &amp; MARK) &amp;&amp; (getActNow(pAction) - pAction-&gt;f_time) &lt; MarkInterval / 2) {
1284 		ABORT_FINALIZE(RS_RET_OK);
1285 	}
1286 	iRet = actionWriteToAction(pAction, pMsg, pWti);
1287 finalize_it:
1288 	d_pthread_mutex_unlock(&amp;pAction-&gt;mutAction);
1289 	pthread_cleanup_pop(0); 
1290 	RETiRet;
1291 }
1292 PRAGMA_DIAGNOSTIC_POP
1293 DEFFUNC_llExecFunc(doActivateActions)
1294 {
1295 	rsRetVal localRet;
1296 	action_t * const pThis = (action_t*) pData;
1297 	localRet = qqueueStart(runConf, pThis-&gt;pQueue);
1298 	if(localRet != RS_RET_OK) {
1299 		LogError(0, localRet, "error starting up action queue");
1300 		if(localRet == RS_RET_FILE_PREFIX_MISSING) {
1301 			LogError(0, localRet, "file prefix (work directory?) "
1302 					"is missing");
1303 		}
1304 		actionDisable(pThis);
1305 	}
1306 	DBGPRINTF("Action %s[%p]: queue %p started\n", modGetName(pThis-&gt;pMod),
1307 		  pThis, pThis-&gt;pQueue);
1308 	return RS_RET_OK; }
1309 rsRetVal
1310 activateActions(void)
1311 {
1312 	DEFiRet;
1313 	iRet = ruleset.IterateAllActions(runConf, doActivateActions, NULL);
1314 	RETiRet;
1315 }
1316 static rsRetVal
1317 doSubmitToActionQNotAllMark(action_t * const pAction, wti_t * const pWti, smsg_t * const pMsg)
1318 {
1319 	int doProcess = 1;
1320 	time_t lastAct;
1321 	DEFiRet;
1322 	do {
1323 		lastAct = pAction-&gt;f_time;
1324 		if(pMsg-&gt;msgFlags &amp; MARK) {
1325 			if((pMsg-&gt;ttGenTime - lastAct) &lt; MarkInterval / 2) {
1326 				doProcess = 0;
1327 				DBGPRINTF("action was recently called, ignoring mark message\n");
1328 				break; 			}
1329 		}
1330 	} while(ATOMIC_CAS_time_t(&amp;pAction-&gt;f_time, lastAct,
1331 		pMsg-&gt;ttGenTime, &amp;pAction-&gt;mutCAS) == 0);
1332 	if(doProcess) {
1333 		DBGPRINTF("Called action(NotAllMark), processing via '%s'\n",
1334 			  module.GetStateName(pAction-&gt;pMod));
1335 		iRet = doSubmitToActionQ(pAction, pWti, pMsg);
1336 	}
1337 	RETiRet;
1338 }
1339 static rsRetVal
1340 actionApplyCnfParam(action_t * const pAction, struct cnfparamvals * const pvals)
1341 {
1342 	int i;
1343 	for(i = 0 ; i &lt; pblk.nParams ; ++i) {
1344 		if(!pvals[i].bUsed)
1345 			continue;
1346 		if(!strcmp(pblk.descr[i].name, "name")) {
1347 			pAction-&gt;pszName = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
1348 		} else if(!strcmp(pblk.descr[i].name, "type")) {
1349 			continue; 		} else if(!strcmp(pblk.descr[i].name, "action.errorfile")) {
1350 			pAction-&gt;pszErrFile = es_str2cstr(pvals[i].val.d.estr, NULL);
1351 		} else if(!strcmp(pblk.descr[i].name, "action.errorfile.maxsize")) {
1352 <a name="1"></a>			pAction-&gt;maxErrFileSize = pvals[i].val.d.n;
1353 		} else if(!strcmp(pblk.descr[i].name, "action.externalstate.file")) {
1354 			pAction-&gt;pszExternalStateFile = es_str2cstr(pvals[i].val.d.estr, NULL);
1355 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(pblk.descr[i].name, "action.writeallmarkmessages")) {
1356 			pAction-&gt;bWriteAllMarkMsgs = pvals[i].val.d.n;
1357 		} else if(!strcmp(pblk.descr[i].name, "action.execonlyeverynthtime")) {
1358 			pAction-&gt;iExecEveryNthOccur = pvals[i].val.d.n;
1359 		} else if(!strcmp(pblk.descr[i].name, "action.execonlyeverynthtimetimeout")) {
1360 			pAction-&gt;iExecEveryNthOccurTO = pvals[i].val.d.n;
1361 		} else if(!strcmp(pblk.descr[i].name, "action.execonlyonceeveryinterval")) {</b></font>
1362 			pAction-&gt;iSecsExecOnceInterval = pvals[i].val.d.n;
1363 		} else if(!strcmp(pblk.descr[i].name, "action.execonlywhenpreviousissuspended")) {
1364 			pAction-&gt;bExecWhenPrevSusp = pvals[i].val.d.n;
1365 		} else if(!strcmp(pblk.descr[i].name, "action.repeatedmsgcontainsoriginalmsg")) {
1366 			pAction-&gt;bRepMsgHasMsg = pvals[i].val.d.n;
1367 		} else if(!strcmp(pblk.descr[i].name, "action.resumeretrycount")) {
1368 			pAction-&gt;iResumeRetryCount = pvals[i].val.d.n;
1369 		} else if(!strcmp(pblk.descr[i].name, "action.reportsuspension")) {
1370 			pAction-&gt;bReportSuspension = (int) pvals[i].val.d.n;
1371 		} else if(!strcmp(pblk.descr[i].name, "action.reportsuspensioncontinuation")) {
1372 			pAction-&gt;bReportSuspensionCont = (int) pvals[i].val.d.n;
1373 		} else if(!strcmp(pblk.descr[i].name, "action.copymsg")) {
1374 			pAction-&gt;bCopyMsg = (int) pvals[i].val.d.n;
1375 		} else if(!strcmp(pblk.descr[i].name, "action.resumeinterval")) {
1376 			pAction-&gt;iResumeInterval = pvals[i].val.d.n;
1377 		} else if(!strcmp(pblk.descr[i].name, "action.resumeintervalMax")) {
1378 			pAction-&gt;iResumeIntervalMax = pvals[i].val.d.n;
1379 		} else {
1380 			dbgprintf("action: program error, non-handled "
1381 			  "param '%s'\n", pblk.descr[i].name);
1382 		}
1383 	}
1384 	return RS_RET_OK;
1385 }
1386 rsRetVal
1387 addAction(action_t **ppAction, modInfo_t *pMod, void *pModData,
1388 	  omodStringRequest_t *pOMSR, struct cnfparamvals *actParams,
1389 	  struct nvlst * const lst)
1390 {
1391 	DEFiRet;
1392 	int i;
1393 	int iTplOpts;
1394 	uchar *pTplName;
1395 	action_t *pAction;
1396 	char errMsg[512];
1397 	assert(ppAction != NULL);
1398 	assert(pMod != NULL);
1399 	assert(pOMSR != NULL);
1400 	DBGPRINTF("Module %s processes this action.\n", module.GetName(pMod));
1401 	CHKiRet(actionConstruct(&amp;pAction)); 	pAction-&gt;pMod = pMod;
1402 	pAction-&gt;pModData = pModData;
1403 	if(actParams == NULL) { 		pAction-&gt;pszName = cs.pszActionName;
1404 		pAction-&gt;iResumeInterval = cs.glbliActionResumeInterval;
1405 		pAction-&gt;iResumeRetryCount = cs.glbliActionResumeRetryCount;
1406 		pAction-&gt;bWriteAllMarkMsgs = cs.bActionWriteAllMarkMsgs;
1407 		pAction-&gt;bExecWhenPrevSusp = cs.bActExecWhenPrevSusp;
1408 		pAction-&gt;iSecsExecOnceInterval = cs.iActExecOnceInterval;
1409 		pAction-&gt;iExecEveryNthOccur = cs.iActExecEveryNthOccur;
1410 		pAction-&gt;iExecEveryNthOccurTO = cs.iActExecEveryNthOccurTO;
1411 		pAction-&gt;bRepMsgHasMsg = cs.bActionRepMsgHasMsg;
1412 		cs.iActExecEveryNthOccur = 0; 		cs.iActExecEveryNthOccurTO = 0; 		cs.bActionWriteAllMarkMsgs = 1; 		cs.pszActionName = NULL;		} else {
1413 		actionApplyCnfParam(pAction, actParams);
1414 	}
1415 	pAction-&gt;iNumTpls = OMSRgetEntryCount(pOMSR);
1416 	if(pAction-&gt;iNumTpls &gt; 0) {
1417 		CHKmalloc(pAction-&gt;ppTpl = (struct template **)calloc(pAction-&gt;iNumTpls, sizeof(struct template *)));
1418 		CHKmalloc(pAction-&gt;peParamPassing = (paramPassing_t*)calloc(pAction-&gt;iNumTpls,
1419 			sizeof(paramPassing_t)));
1420 	}
1421 	pAction-&gt;bUsesMsgPassingMode = 0;
1422 	pAction-&gt;bNeedReleaseBatch = 0;
1423 	for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
1424 		CHKiRet(OMSRgetEntry(pOMSR, i, &amp;pTplName, &amp;iTplOpts));
1425 		if(!(iTplOpts &amp; OMSR_TPL_AS_MSG)) {
1426 		   	if((pAction-&gt;ppTpl[i] =
1427 				tplFind(loadConf, (char*)pTplName, strlen((char*)pTplName))) == NULL) {
1428 				snprintf(errMsg, sizeof(errMsg),
1429 					 " Could not find template %d '%s' - action disabled",
1430 					 i, pTplName);
1431 				errno = 0;
1432 				LogError(0, RS_RET_NOT_FOUND, "%s", errMsg);
1433 				ABORT_FINALIZE(RS_RET_NOT_FOUND);
1434 			}
1435 			if(   (iTplOpts &amp; OMSR_RQD_TPL_OPT_SQL)
1436 			   &amp;&amp; (pAction-&gt;ppTpl[i]-&gt;optFormatEscape == 0)) {
1437 				errno = 0;
1438 				LogError(0, RS_RET_RQD_TPLOPT_MISSING, "Action disabled."
1439 						" To use this action, you have to specify "
1440 						"the SQL or stdSQL option in your template!\n");
1441 				ABORT_FINALIZE(RS_RET_RQD_TPLOPT_MISSING);
1442 			}
1443 		}
1444 		if(iTplOpts &amp; OMSR_TPL_AS_ARRAY) {
1445 			ABORT_FINALIZE(RS_RET_ERR);
1446 		} else if(iTplOpts &amp; OMSR_TPL_AS_MSG) {
1447 			pAction-&gt;peParamPassing[i] = ACT_MSG_PASSING;
1448 			pAction-&gt;bUsesMsgPassingMode = 1;
1449 		} else if(iTplOpts &amp; OMSR_TPL_AS_JSON) {
1450 			pAction-&gt;peParamPassing[i] = ACT_JSON_PASSING;
1451 			pAction-&gt;bNeedReleaseBatch = 1;
1452 		} else {
1453 			pAction-&gt;peParamPassing[i] = ACT_STRING_PASSING;
1454 		}
1455 		DBGPRINTF("template: '%s' assigned\n", pTplName);
1456 	}
1457 	pAction-&gt;pMod = pMod;
1458 	pAction-&gt;pModData = pModData;
1459 	CHKiRet(actionConstructFinalize(pAction, lst));
1460 	*ppAction = pAction; 
1461 finalize_it:
1462 	if(iRet == RS_RET_OK)
1463 		iRet = OMSRdestruct(pOMSR);
1464 	else {
1465 		OMSRdestruct(pOMSR);
1466 		if(pAction != NULL)
1467 			actionDestruct(pAction);
1468 	}
1469 	RETiRet;
1470 }
1471 static rsRetVal
1472 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
1473 {
1474 	cs.iActExecOnceInterval = 0;
1475 	cs.bActExecWhenPrevSusp = 0;
1476 	return RS_RET_OK;
1477 }
1478 static void
1479 initConfigVariables(void)
1480 {
1481 	cs.bActionWriteAllMarkMsgs = 1;
1482 	cs.glbliActionResumeRetryCount = 0;
1483 	cs.bActExecWhenPrevSusp = 0;
1484 	cs.iActExecOnceInterval = 0;
1485 	cs.iActExecEveryNthOccur = 0;
1486 	cs.iActExecEveryNthOccurTO = 0;
1487 	cs.glbliActionResumeInterval = 30;
1488 	cs.glbliActionResumeRetryCount = 0;
1489 	cs.bActionRepMsgHasMsg = 0;
1490 	if(cs.pszActionName != NULL) {
1491 		free(cs.pszActionName);
1492 		cs.pszActionName = NULL;
1493 	}
1494 	actionResetQueueParams();
1495 }
1496 rsRetVal
1497 actionNewInst(struct nvlst *lst, action_t **ppAction)
1498 {
1499 	struct cnfparamvals *paramvals;
1500 	modInfo_t *pMod;
1501 	uchar *cnfModName = NULL;
1502 	omodStringRequest_t *pOMSR;
1503 	void *pModData;
1504 	action_t *pAction;
1505 	DEFiRet;
1506 	paramvals = nvlstGetParams(lst, &amp;pblk, NULL);
1507 	if(paramvals == NULL) {
1508 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
1509 	}
1510 	dbgprintf("action param blk after actionNewInst:\n");
1511 	cnfparamsPrint(&amp;pblk, paramvals);
1512 	cnfModName = (uchar*)es_str2cstr(paramvals[cnfparamGetIdx(&amp;pblk, ("type"))].val.d.estr, NULL);
1513 	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_OUT)) == NULL) {
1514 		LogError(0, RS_RET_MOD_UNKNOWN, "module name '%s' is unknown", cnfModName);
1515 		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
1516 	}
1517 	CHKiRet(pMod-&gt;mod.om.newActInst(cnfModName, lst, &amp;pModData, &amp;pOMSR));
1518 	if((iRet = addAction(&amp;pAction, pMod, pModData, pOMSR, paramvals, lst)) == RS_RET_OK) {
1519 		loadConf-&gt;actions.nbrActions++;			*ppAction = pAction;
1520 	} else {
1521 	}
1522 finalize_it:
1523 	free(cnfModName);
1524 	cnfparamvalsDestruct(paramvals, &amp;pblk);
1525 	RETiRet;
1526 }
1527 rsRetVal actionClassInit(void)
1528 {
1529 	DEFiRet;
1530 	CHKiRet(objGetObjInterface(&amp;obj)); 	CHKiRet(objUse(datetime, CORE_COMPONENT));
1531 	CHKiRet(objUse(module, CORE_COMPONENT));
1532 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1533 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
1534 	CHKiRet(regCfSysLineHdlr((uchar *)"actionname", 0, eCmdHdlrGetWord, NULL, &amp;cs.pszActionName, NULL));
1535 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuefilename", 0, eCmdHdlrGetWord, NULL,
1536 		&amp;cs.pszActionQFName, NULL));
1537 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuesize", 0, eCmdHdlrInt, NULL, &amp;cs.iActionQueueSize,
1538 		NULL));
1539 	CHKiRet(regCfSysLineHdlr((uchar *)"actionwriteallmarkmessages", 0, eCmdHdlrBinary, NULL,
1540 		&amp;cs.bActionWriteAllMarkMsgs, NULL));
1541 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuedequeuebatchsize", 0, eCmdHdlrInt, NULL,
1542 		&amp;cs.iActionQueueDeqBatchSize, NULL));
1543 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuemaxdiskspace", 0, eCmdHdlrSize, NULL,
1544 		&amp;cs.iActionQueMaxDiskSpace, NULL));
1545 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuehighwatermark", 0, eCmdHdlrInt, NULL,
1546 		&amp;cs.iActionQHighWtrMark, NULL));
1547 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuelowwatermark", 0, eCmdHdlrInt, NULL,
1548 		&amp;cs.iActionQLowWtrMark, NULL));
1549 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuediscardmark", 0, eCmdHdlrInt, NULL,
1550 		&amp;cs.iActionQDiscardMark, NULL));
1551 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuediscardseverity", 0, eCmdHdlrInt, NULL,
1552 		&amp;cs.iActionQDiscardSeverity, NULL));
1553 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuecheckpointinterval", 0, eCmdHdlrInt, NULL,
1554 		&amp;cs.iActionQPersistUpdCnt, NULL));
1555 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuesyncqueuefiles", 0, eCmdHdlrBinary, NULL,
1556 		&amp;cs.bActionQSyncQeueFiles, NULL));
1557 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuetype", 0, eCmdHdlrGetWord, setActionQueType, NULL, NULL));
1558 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueueworkerthreads", 0, eCmdHdlrInt, NULL,
1559 		&amp;cs.iActionQueueNumWorkers, NULL));
1560 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuetimeoutshutdown", 0, eCmdHdlrInt, NULL,
1561 		&amp;cs.iActionQtoQShutdown, NULL));
1562 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuetimeoutactioncompletion", 0, eCmdHdlrInt, NULL,
1563 		&amp;cs.iActionQtoActShutdown, NULL));
1564 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuetimeoutenqueue", 0, eCmdHdlrInt, NULL,
1565 		&amp;cs.iActionQtoEnq, NULL));
1566 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueueworkertimeoutthreadshutdown", 0, eCmdHdlrInt, NULL,
1567 		&amp;cs.iActionQtoWrkShutdown, NULL));
1568 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueueworkerthreadminimummessages", 0, eCmdHdlrInt, NULL,
1569 		&amp;cs.iActionQWrkMinMsgs, NULL));
1570 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuemaxfilesize", 0, eCmdHdlrSize, NULL,
1571 		&amp;cs.iActionQueMaxFileSize, NULL));
1572 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuesaveonshutdown", 0, eCmdHdlrBinary, NULL,
1573 		&amp;cs.bActionQSaveOnShutdown, NULL));
1574 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuedequeueslowdown", 0, eCmdHdlrInt, NULL,
1575 		&amp;cs.iActionQueueDeqSlowdown, NULL));
1576 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuedequeuetimebegin", 0, eCmdHdlrInt, NULL,
1577 		&amp;cs.iActionQueueDeqtWinFromHr, NULL));
1578 	CHKiRet(regCfSysLineHdlr((uchar *)"actionqueuedequeuetimeend", 0, eCmdHdlrInt, NULL,
1579 		&amp;cs.iActionQueueDeqtWinToHr, NULL));
1580 	CHKiRet(regCfSysLineHdlr((uchar *)"actionexeconlyeverynthtime", 0, eCmdHdlrInt, NULL,
1581 		&amp;cs.iActExecEveryNthOccur, NULL));
1582 	CHKiRet(regCfSysLineHdlr((uchar *)"actionexeconlyeverynthtimetimeout", 0, eCmdHdlrInt, NULL,
1583 		&amp;cs.iActExecEveryNthOccurTO, NULL));
1584 	CHKiRet(regCfSysLineHdlr((uchar *)"actionexeconlyonceeveryinterval", 0, eCmdHdlrInt, NULL,
1585 		&amp;cs.iActExecOnceInterval, NULL));
1586 	CHKiRet(regCfSysLineHdlr((uchar *)"repeatedmsgcontainsoriginalmsg", 0, eCmdHdlrBinary, NULL,
1587 		&amp;cs.bActionRepMsgHasMsg, NULL));
1588 	CHKiRet(regCfSysLineHdlr((uchar *)"actionexeconlywhenpreviousissuspended", 0, eCmdHdlrBinary, NULL,
1589 		&amp;cs.bActExecWhenPrevSusp, NULL));
1590 	CHKiRet(regCfSysLineHdlr((uchar *)"actionresumeretrycount", 0, eCmdHdlrInt, NULL,
1591 		&amp;cs.glbliActionResumeRetryCount, NULL));
1592 	CHKiRet(regCfSysLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
1593 		resetConfigVariables, NULL, NULL));
1594 	initConfigVariables(); 
1595 finalize_it:
1596 	RETiRet;
1597 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
