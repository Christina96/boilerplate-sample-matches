<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for srutils.c & action.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for srutils.c & action.c
      </h3>
      <h1 align="center">
        4.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>srutils.c (7.5642967%)<TH>action.c (3.1269543%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2526-0.html#0',2,'match2526-1.html#0',3)" NAME="0">(84-102)<TD><A HREF="javascript:ZweiFrames('match2526-0.html#0',2,'match2526-1.html#0',3)" NAME="0">(188-206)</A><TD ALIGN=center><FONT COLOR="#ff0000">36</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2526-0.html#1',2,'match2526-1.html#1',3)" NAME="1">(839-845)<TD><A HREF="javascript:ZweiFrames('match2526-0.html#1',2,'match2526-1.html#1',3)" NAME="1">(2071-2077)</A><TD ALIGN=center><FONT COLOR="#630000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>srutils.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/**\file srUtils.c
 * \brief General utilties that fit nowhere else.
 *
 * The namespace for this file is &quot;srUtil&quot;.
 *
 * \author  Rainer Gerhards &lt;rgerhards@adiscon.com&gt;
 * \date    2003-09-09
 *          Coding begun.
 *
 * Copyright 2003-2018 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of the rsyslog runtime library.
 *
 * The rsyslog runtime library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The rsyslog runtime library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with the rsyslog runtime library.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 * A copy of the LGPL can be found in the file &quot;COPYING.LESSER&quot; in this distribution.
 */
#include &quot;config.h&quot;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;ctype.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;fcntl.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;obj.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;glbl.h&quot;
#include &quot;rsconf.h&quot;

#if _POSIX_TIMERS &lt;= 0
#include &lt;sys/time.h&gt;
#endif

/* here we host some syslog specific names. There currently is no better place
 * to do it, but over here is also not ideal... -- rgerhards, 2008-02-14
 * rgerhards, 2008-04-16: note in LGPL move: the code tables below exist in
 * the same way in BSD, so it is not a problem to move them from GPLv3 to LGPL.
 * And nobody modified them since it was under LGPL, so we can also move it
 * to ASL 2.0.
 */
syslogName_t	syslogPriNames[] = {
	{&quot;alert&quot;,	LOG_ALERT},
	{&quot;crit&quot;,	LOG_CRIT},
	{&quot;debug&quot;,	LOG_DEBUG},
	{&quot;emerg&quot;,	LOG_EMERG},
	{&quot;err&quot;,		LOG_ERR},
	{&quot;error&quot;,	LOG_ERR},		/* DEPRECATED */
	{&quot;info&quot;,	LOG_INFO},
	{&quot;none&quot;,	INTERNAL_NOPRI},	/* INTERNAL */
	{&quot;notice&quot;,	LOG_NOTICE},
	{&quot;panic&quot;,	LOG_EMERG},		/* DEPRECATED */
	{&quot;warn&quot;,	LOG_WARNING},		/* DEPRECATED */
	{&quot;warning&quot;,	LOG_WARNING},
	{&quot;*&quot;,		TABLE_ALLPRI},
	{NULL,		-1}
};

<A NAME="0"></A>#ifndef LOG_AUTHPRIV
#	define LOG_AUTHPRIV LOG_AUTH
#endif
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2526-1.html#0',3,'match2526-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>syslogName_t	syslogFacNames[] = {
	{&quot;auth&quot;,         LOG_AUTH},
	{&quot;authpriv&quot;,     LOG_AUTHPRIV},
	{&quot;cron&quot;,         LOG_CRON},
	{&quot;daemon&quot;,       LOG_DAEMON},
	{&quot;kern&quot;,         LOG_KERN},
	{&quot;lpr&quot;,          LOG_LPR},
	{&quot;mail&quot;,         LOG_MAIL},
	{&quot;mark&quot;,         LOG_MARK},		/* INTERNAL */
	{&quot;news&quot;,         LOG_NEWS},
	{&quot;ntp&quot;,          (12&lt;&lt;3) },             /* NTP, perhaps BSD-specific? */
	{&quot;security&quot;,     LOG_AUTH},		/* DEPRECATED */
	{&quot;bsd_security&quot;, (13&lt;&lt;3) },		/* BSD-specific, unfortunatly with duplicate name... */
	{&quot;syslog&quot;,       LOG_SYSLOG},
	{&quot;user&quot;,         LOG_USER},
	{&quot;uucp&quot;,         LOG_UUCP},
#if defined(_AIX)  /* AIXPORT : These are necessary for AIX */
	{ &quot;caa&quot;,         LOG_CAA },
	{ &quot;aso&quot;,         LOG_ASO },</B></FONT>
#endif
#if defined(LOG_FTP)
	{&quot;ftp&quot;,          LOG_FTP},
#endif
#if defined(LOG_AUDIT)
	{&quot;audit&quot;,        LOG_AUDIT},
#endif
	{&quot;console&quot;,	 (14 &lt;&lt; 3)},		/* BSD-specific priority */
	{&quot;local0&quot;,       LOG_LOCAL0},
	{&quot;local1&quot;,       LOG_LOCAL1},
	{&quot;local2&quot;,       LOG_LOCAL2},
	{&quot;local3&quot;,       LOG_LOCAL3},
	{&quot;local4&quot;,       LOG_LOCAL4},
	{&quot;local5&quot;,       LOG_LOCAL5},
	{&quot;local6&quot;,       LOG_LOCAL6},
	{&quot;local7&quot;,       LOG_LOCAL7},
	{&quot;invld&quot;,        LOG_INVLD},
	{NULL,           -1},
};

/* ################################################################# *
 * private members                                                   *
 * ################################################################# */

/* As this is not a &quot;real&quot; object, there won't be any private
 * members in this file.
 */

/* ################################################################# *
 * public members                                                    *
 * ################################################################# */

rsRetVal srUtilItoA(char *pBuf, int iLenBuf, number_t iToConv)
{
	int i;
	int bIsNegative;
	char szBuf[64];	/* sufficiently large for my lifespan and those of my children... ;) */

	assert(pBuf != NULL);
	assert(iLenBuf &gt; 1);	/* This is actually an app error and as thus checked for... */

	if(iToConv &lt; 0)
	{
		bIsNegative = RSTRUE;
		iToConv *= -1;
	}
	else
		bIsNegative = RSFALSE;

	/* first generate a string with the digits in the reverse direction */
	i = 0;
	do
	{
		szBuf[i++] = iToConv % 10 + '0';
		iToConv /= 10;
	} while(iToConv &gt; 0);	/* warning: do...while()! */
	--i; /* undo last increment - we were pointing at NEXT location */

	/* make sure we are within bounds... */
	if(i + 2 &gt; iLenBuf)	/* +2 because: a) i starts at zero! b) the \0 byte */
		return RS_RET_PROVIDED_BUFFER_TOO_SMALL;

	/* then move it to the right direction... */
	if(bIsNegative == RSTRUE)
		*pBuf++ = '-';
	while(i &gt;= 0)
		*pBuf++ = szBuf[i--];
	*pBuf = '\0';	/* terminate it!!! */

	return RS_RET_OK;
}

uchar *srUtilStrDup(uchar *pOld, size_t len)
{
	uchar *pNew;

	assert(pOld != NULL);

	if((pNew = malloc(len + 1)) != NULL)
		memcpy(pNew, pOld, len + 1);

	return pNew;
}


/* creates a path recursively
 * Return 0 on success, -1 otherwise. On failure, errno * hold the last OS error.
 * Param &quot;mode&quot; holds the mode that all non-existing directories are to be
 * created with.
 * Note that we have a potential race inside that code, a race that even exists
 * outside of the rsyslog process (if multiple instances run, or other programs
 * generate directories): If the directory does not exist, a context switch happens,
 * at that moment another process creates it, then our creation on the context
 * switch back fails. This actually happened in practice, and depending on the
 * configuration it is even likely to happen. We can not solve this situation
 * with a mutex, as that works only within out process space. So the solution
 * is that we take the optimistic approach, try the creation, and if it fails
 * with &quot;already exists&quot; we go back and do one retry of the check/create
 * sequence. That should then succeed. If the directory is still not found but
 * the creation fails in the similar way, we return an error on that second
 * try because otherwise we would potentially run into an endless loop.
 * loop. -- rgerhards, 2010-03-25
 * The likeliest scenario for a prolonged contest of creating the parent directiories
 * is within our process space. This can happen with a high probability when two
 * threads, that want to start logging to files within same directory tree, are
 * started close to each other. We should fix what we can. -- nipakoo, 2017-11-25
 */
static int real_makeFileParentDirs(const uchar *const szFile, const size_t lenFile, const mode_t mode,
	const uid_t uid, const gid_t gid, const int bFailOnChownFail)
{
	uchar *p;
	uchar *pszWork;
	size_t len;

	assert(szFile != NULL);
	assert(lenFile &gt; 0);

	len = lenFile + 1; /* add one for '\0'-byte */
	if((pszWork = malloc(len)) == NULL)
		return -1;
	memcpy(pszWork, szFile, len);
	for(p = pszWork+1 ; *p ; p++)
		if(*p == '/') {
			/* temporarily terminate string, create dir and go on */
			*p = '\0';
			int bErr = 0;
			if(mkdir((char*)pszWork, mode) == 0) {
				if(uid != (uid_t) -1 || gid != (gid_t) -1) {
					/* we need to set owner/group */
					if(chown((char*)pszWork, uid, gid) != 0) {
						LogError(errno, RS_RET_DIR_CHOWN_ERROR,
							&quot;chown for directory '%s' failed&quot;, pszWork);
						if(bFailOnChownFail) {
							/* ignore if configured to do so */
							bErr = 1;
						}
					}
				}
			} else if(errno != EEXIST) {
				/* EEXIST is ok, means this component exists */
				bErr = 1;
			}

			if(bErr) {
				int eSave = errno;
				free(pszWork);
				errno = eSave;
				return -1;
			}
			*p = '/';
		}
	free(pszWork);
	return 0;
}
/* note: this small function is the stub for the brain-dead POSIX cancel handling */
int makeFileParentDirs(const uchar *const szFile, const size_t lenFile, const mode_t mode,
		       const uid_t uid, const gid_t gid, const int bFailOnChownFail)
{
	static pthread_mutex_t mutParentDir = PTHREAD_MUTEX_INITIALIZER;
	int r;	/* needs to be declared OUTSIDE of pthread_cleanup... macros! */
	pthread_mutex_lock(&amp;mutParentDir);
	pthread_cleanup_push(mutexCancelCleanup, &amp;mutParentDir);

	r = real_makeFileParentDirs(szFile, lenFile, mode, uid, gid, bFailOnChownFail);

	pthread_mutex_unlock(&amp;mutParentDir);
	pthread_cleanup_pop(0);
	return r;
}


/* execute a program with a single argument
 * returns child pid if everything ok, 0 on failure. if
 * it fails, errno is set. if it fails after the fork(), the caller
 * can not be notfied for obvious reasons. if bwait is set to 1,
 * the code waits until the child terminates - that potentially takes
 * a lot of time.
 * implemented 2007-07-20 rgerhards
 */
int execProg(uchar *program, int bWait, uchar *arg)
{
	int pid;
	int sig;
	struct sigaction sigAct;

	dbgprintf(&quot;exec program '%s' with param '%s'\n&quot;, program, arg);
	pid = fork();
	if (pid &lt; 0) {
		return 0;
	}

	if(pid) {       /* Parent */
		if(bWait) {
			/* waitpid will fail with errno == ECHILD if the child process has already
			   been reaped by the rsyslogd main loop (see rsyslogd.c) */
			int status;
			if(waitpid(pid, &amp;status, 0) == pid) {
				glblReportChildProcessExit(runConf, program, pid, status);
			} else if(errno != ECHILD) {
				/* we do not use logerror(), because
				* that might bring us into an endless
				* loop. At some time, we may
				* reconsider this behaviour.
				*/
				dbgprintf(&quot;could not wait on child after executing '%s'&quot;,
						(char*)program);
			}
		}
		return pid;
	}
	/* Child */
	alarm(0); /* create a clean environment before we exec the real child */

	memset(&amp;sigAct, 0, sizeof(sigAct));
	sigemptyset(&amp;sigAct.sa_mask);
	sigAct.sa_handler = SIG_DFL;

	for(sig = 1 ; sig &lt; NSIG ; ++sig)
		sigaction(sig, &amp;sigAct, NULL);

	execlp((char*)program, (char*) program, (char*)arg, NULL);
	/* In the long term, it's a good idea to implement some enhanced error
	 * checking here. However, it can not easily be done. For starters, we
	 * may run into endless loops if we log to syslog. The next problem is
	 * that output is typically not seen by the user. For the time being,
	 * we use no error reporting, which is quite consitent with the old
	 * system() way of doing things. rgerhards, 2007-07-20
	 */
	perror(&quot;exec&quot;);
	fprintf(stderr, &quot;exec program was '%s' with param '%s'\n&quot;, program, arg);
	exit(1); /* not much we can do in this case */
}


/* skip over whitespace in a standard C string. The
 * provided pointer is advanced to the first non-whitespace
 * charater or the \0 byte, if there is none. It is never
 * moved past the \0.
 */
void skipWhiteSpace(uchar **pp)
{
	register uchar *p;

	assert(pp != NULL);
	assert(*pp != NULL);

	p = *pp;
	while(*p &amp;&amp; isspace((int) *p))
		++p;
	*pp = p;
}


/* generate a file name from four parts:
 * &lt;directory name&gt;/&lt;name&gt;.&lt;number&gt;
 * If number is negative, it is not used. If any of the strings is
 * NULL, an empty string is used instead. Length must be provided.
 * lNumDigits is the minimum number of digits that lNum should have. This
 * is to pretty-print the file name, e.g. lNum = 3, lNumDigits= 4 will
 * result in &quot;0003&quot; being used inside the file name. Set lNumDigits to 0
 * to use as few space as possible.
 * rgerhards, 2008-01-03
 */
PRAGMA_DIAGNOSTIC_PUSH
PRAGMA_IGNORE_Wformat_nonliteral
rsRetVal genFileName(uchar **ppName, uchar *pDirName, size_t lenDirName, uchar *pFName,
		     size_t lenFName, int64_t lNum, int lNumDigits)
{
	DEFiRet;
	uchar *pName;
	uchar *pNameWork;
	size_t lenName;
	uchar szBuf[128];	/* buffer for number */
	char szFmtBuf[32];	/* buffer for snprintf format */
	size_t lenBuf;

	if(lNum &lt; 0) {
		szBuf[0] = '\0';
		lenBuf = 0;
	} else {
		if(lNumDigits &gt; 0) {
			snprintf(szFmtBuf, sizeof(szFmtBuf), &quot;.%%0%d&quot; PRId64, lNumDigits);
			lenBuf = snprintf((char*)szBuf, sizeof(szBuf), szFmtBuf, lNum);
		} else
			lenBuf = snprintf((char*)szBuf, sizeof(szBuf), &quot;.%&quot; PRId64, lNum);
	}

	lenName = lenDirName + 1 + lenFName + lenBuf + 1; /* last +1 for \0 char! */
	if((pName = malloc(lenName)) == NULL)
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);

	/* got memory, now construct string */
	memcpy(pName, pDirName, lenDirName);
	pNameWork = pName + lenDirName;
	*pNameWork++ = '/';
	memcpy(pNameWork, pFName, lenFName);
	pNameWork += lenFName;
	if(lenBuf &gt; 0) {
		memcpy(pNameWork, szBuf, lenBuf);
		pNameWork += lenBuf;
	}
	*pNameWork = '\0';

	*ppName = pName;

finalize_it:
	RETiRet;
}
PRAGMA_DIAGNOSTIC_POP

/* get the number of digits required to represent a given number. We use an
 * iterative approach as we do not like to draw in the floating point
 * library just for log(). -- rgerhards, 2008-01-10
 */
int getNumberDigits(long lNum)
{
	int iDig;

	if(lNum == 0)
		iDig = 1;
	else
		for(iDig = 0 ; lNum != 0 ; ++iDig)
			lNum /= 10;

	return iDig;
}


/* compute an absolute time timeout suitable for calls to pthread_cond_timedwait()
 * iTimeout is in milliseconds
 * rgerhards, 2008-01-14
 */
rsRetVal
timeoutComp(struct timespec *pt, long iTimeout)
{
#	if _POSIX_TIMERS &lt;= 0
	struct timeval tv;
#	endif

	assert(pt != NULL);
	/* compute timeout */

#	if _POSIX_TIMERS &gt; 0
	/* this is the &quot;regular&quot; code */
	clock_gettime(CLOCK_REALTIME, pt);
#	else
	gettimeofday(&amp;tv, NULL);
	pt-&gt;tv_sec = tv.tv_sec;
	pt-&gt;tv_nsec = tv.tv_usec * 1000;
#	endif
	pt-&gt;tv_sec += iTimeout / 1000;
	pt-&gt;tv_nsec += (iTimeout % 1000) * 1000000; /* think INTEGER arithmetic! */
	if(pt-&gt;tv_nsec &gt; 999999999) { /* overrun? */
		pt-&gt;tv_nsec -= 1000000000;
		++pt-&gt;tv_sec;
	}
	return RS_RET_OK; /* so far, this is static... */
}

long long
currentTimeMills(void)
{
	struct timespec tm;
#	if _POSIX_TIMERS &lt;= 0
	struct timeval tv;
#	endif

#	if _POSIX_TIMERS &gt; 0
	clock_gettime(CLOCK_REALTIME, &amp;tm);
#	else
	gettimeofday(&amp;tv, NULL);
	tm.tv_sec = tv.tv_sec;
	tm.tv_nsec = tv.tv_usec * 1000;
#	endif

	return ((long long) tm.tv_sec) * 1000 + (tm.tv_nsec / 1000000);
}


/* This function is kind of the reverse of timeoutComp() - it takes an absolute
 * timeout value and computes how far this is in the future. If the value is already
 * in the past, 0 is returned. The return value is in ms.
 * rgerhards, 2008-01-25
 */
long
timeoutVal(struct timespec *pt)
{
	struct timespec t;
	long iTimeout;
#	if _POSIX_TIMERS &lt;= 0
	struct timeval tv;
#	endif

	assert(pt != NULL);
	/* compute timeout */
#	if _POSIX_TIMERS &gt; 0
	/* this is the &quot;regular&quot; code */
	clock_gettime(CLOCK_REALTIME, &amp;t);
#	else
	gettimeofday(&amp;tv, NULL);
	t.tv_sec = tv.tv_sec;
	t.tv_nsec = tv.tv_usec * 1000;
#	endif
	iTimeout = (pt-&gt;tv_nsec - t.tv_nsec) / 1000000;
	iTimeout += (pt-&gt;tv_sec - t.tv_sec) * 1000;

	if(iTimeout &lt; 0)
		iTimeout = 0;

	return iTimeout;
}


/* cancellation cleanup handler - frees provided mutex
 * rgerhards, 2008-01-14
 */
void
mutexCancelCleanup(void *arg)
{
	assert(arg != NULL);
	d_pthread_mutex_unlock((pthread_mutex_t*) arg);
}


/* rsSleep() - a fairly portable way to to sleep. It
 * will wake up when
 * a) the wake-time is over
 * rgerhards, 2008-01-28
 */
void
srSleep(int iSeconds, int iuSeconds)
{
	struct timeval tvSelectTimeout;

	tvSelectTimeout.tv_sec = iSeconds;
	tvSelectTimeout.tv_usec = iuSeconds; /* micro seconds */
	select(0, NULL, NULL, NULL, &amp;tvSelectTimeout);
}


/* From varmojfekoj's mail on why he provided rs_strerror_r():
 * There are two problems with strerror_r():
 * I see you've rewritten some of the code which calls it to use only
 * the supplied buffer; unfortunately the GNU implementation sometimes
 * doesn't use the buffer at all and returns a pointer to some
 * immutable string instead, as noted in the man page.
 *
 * The other problem is that on some systems strerror_r() has a return
 * type of int.
 *
 * So I've written a wrapper function rs_strerror_r(), which should
 * take care of all this and be used instead.
 *
 * Added 2008-01-30
 */
char *rs_strerror_r(int errnum, char *buf, size_t buflen) {
#ifndef HAVE_STRERROR_R
	char *pszErr;
	pszErr = strerror(errnum);
	snprintf(buf, buflen, &quot;%s&quot;, pszErr);
#else
#	ifdef STRERROR_R_CHAR_P
		char *p = strerror_r(errnum, buf, buflen);
		if (p != buf) {
			strncpy(buf, p, buflen);
			buf[buflen - 1] = '\0';
		}
#	else
		strerror_r(errnum, buf, buflen);
#	endif
#endif /* #ifdef __hpux */
	return buf;
}


/*  Decode a symbolic name to a numeric value */
int decodeSyslogName(uchar *name, syslogName_t *codetab)
{
	register syslogName_t *c;
	register uchar *p;
	uchar buf[80];

	assert(name != NULL);
	assert(codetab != NULL);

	DBGPRINTF(&quot;symbolic name: %s&quot;, name);
	if(isdigit((int) *name)) {
		DBGPRINTF(&quot;\n&quot;);
		return (atoi((char*) name));
	}
	strncpy((char*) buf, (char*) name, 79);
	for(p = buf; *p; p++) {
		if (isupper((int) *p))
			*p = tolower((int) *p);
	}
	for(c = codetab; c-&gt;c_name; c++) {
		if(!strcmp((char*) buf, (char*) c-&gt;c_name)) {
			DBGPRINTF(&quot; ==&gt; %d\n&quot;, c-&gt;c_val);
			return (c-&gt;c_val);
		}
	}
	DBGPRINTF(&quot;\n&quot;);
	return (-1);
}


/**
 * getSubString
 *
 * Copy a string byte by byte until the occurrence
 * of a given separator.
 *
 * \param ppSrc		Pointer to a pointer of the source array of characters. If a
			separator detected the Pointer points to the next char after the
			separator. Except if the end of the string is dedected ('\n').
			Then it points to the terminator char.
 * \param pDst		Pointer to the destination array of characters. Here the substing
			will be stored.
 * \param DstSize	Maximum numbers of characters to store.
 * \param cSep		Separator char.
 * \ret int		Returns 0 if no error occurred.
 *
 * rgerhards, 2008-02-12: some notes are due... I will once again fix this function, this time
 * so that it treats ' ' as a request for whitespace. But in general, the function and its callers
 * should be changed over time, this is not really very good code...
 */
int getSubString(uchar **ppSrc,  char *pDst, size_t DstSize, char cSep)
{
	uchar *pSrc = *ppSrc;
	int iErr = 0; /* 0 = no error, &gt;0 = error */
	while((cSep == ' ' ? !isspace(*pSrc) : *pSrc != cSep) &amp;&amp; *pSrc != '\n' &amp;&amp; *pSrc != '\0' &amp;&amp; DstSize&gt;1) {
		*pDst++ = *(pSrc)++;
		DstSize--;
	}
	/* check if the Dst buffer was to small */
	if ((cSep == ' ' ? !isspace(*pSrc) : *pSrc != cSep) &amp;&amp; *pSrc != '\n' &amp;&amp; *pSrc != '\0') {
		dbgprintf(&quot;in getSubString, error Src buffer &gt; Dst buffer\n&quot;);
		iErr = 1;
	}
	if (*pSrc == '\0' || *pSrc == '\n')
		/* this line was missing, causing ppSrc to be invalid when it
		 * was returned in case of end-of-string. rgerhards 2005-07-29
		 */
		*ppSrc = pSrc;
	else
		*ppSrc = pSrc+1;
	*pDst = '\0';
	return iErr;
}


/* get the size of a file or return appropriate error code. If an error is returned,
 * *pSize content is undefined.
 * rgerhards, 2009-06-12
 */
rsRetVal
getFileSize(uchar *pszName, off_t *pSize)
{
	int ret;
	struct stat statBuf;
	DEFiRet;

	ret = stat((char*) pszName, &amp;statBuf);
	if(ret == -1) {
		switch(errno) {
			case EACCES: ABORT_FINALIZE(RS_RET_NO_FILE_ACCESS);
			case ENOTDIR:
			case ENOENT:  ABORT_FINALIZE(RS_RET_FILE_NOT_FOUND);
			default:      ABORT_FINALIZE(RS_RET_FILE_NO_STAT);
		}
	}

	*pSize = statBuf.st_size;

finalize_it:
	RETiRet;
}

/* Returns 1 if the given string contains a non-escaped glob(3)
 * wildcard character and 0 otherwise (or if the string is empty).
 */
int
containsGlobWildcard(char *str)
{
	char *p;
	if(!str) {
		return 0;
	}
	/* From Linux Programmer's Guide:
	 * &quot;A string is a wildcard pattern if it contains one of the characters '?', '*', '{' or '['&quot;
	 * &quot;One can remove the special meaning of '?', '*', '{' and '[' by preceding them by a backslash&quot;
	 */
	for(p = str; *p != '\0'; p++) {
		if((*p == '?' || *p == '*' || *p == '[' || *p == '{') &amp;&amp;
				(p == str || *(p-1) != '\\')) {
			return 1;
		}
	}
	return 0;
}

static void seedRandomInsecureNumber(void)
{
	struct timespec t;
	timeoutComp(&amp;t, 0);
	long long x = t.tv_sec * 3 + t.tv_nsec * 2;
	srandom((unsigned int) x);
}

static long int randomInsecureNumber(void)
{
	return random();
}

#ifdef OS_LINUX
static int fdURandom = -1;
void seedRandomNumber(void)
{
	if(fdURandom &gt;= 0) {
		/* Already opened. */
		return;
	}
	fdURandom = open(&quot;/dev/urandom&quot;, O_RDONLY);
	if(fdURandom == -1) {
		LogError(errno, RS_RET_IO_ERROR, &quot;failed to seed random number generation,&quot;
			&quot; will use fallback (open urandom failed)&quot;);
		seedRandomInsecureNumber();
	}
}

void seedRandomNumberForChild(void)
{
	/* The file descriptor inherited from our parent will have been closed after
	 * the fork. Discard this and call seedRandomNumber() to open /dev/urandom
	 * again.
	 */
	fdURandom = -1;
	seedRandomNumber();
}

long int randomNumber(void)
{
	long int ret;
	if(fdURandom &gt;= 0) {
		if(read(fdURandom, &amp;ret, sizeof(long int)) == -1) {
			LogError(errno, RS_RET_IO_ERROR, &quot;failed to generate random number, will&quot;
				&quot; use fallback (read urandom failed)&quot;);
			ret = randomInsecureNumber();
		}
	} else {
		ret = randomInsecureNumber();
	}
	return ret;
}
#else
void seedRandomNumber(void)
{
	seedRandomInsecureNumber();
}

void seedRandomNumberForChild(void)
{
	seedRandomNumber();
}

long int randomNumber(void)
{
	return randomInsecureNumber();
}
#endif


/* process &quot;binary&quot; parameters where this is needed to execute
 * programs (namely mmexternal and omprog).
 * Most importantly, split them into argv[] and get the binary name
 */
rsRetVal ATTR_NONNULL()
split_binary_parameters(uchar **const szBinary, char ***const __restrict__ aParams,
	int *const iParams, es_str_t *const param_binary)
{
	es_size_t iCnt;
	es_size_t iStr;
	int iPrm;
	es_str_t *estrParams = NULL;
	es_str_t *estrBinary = param_binary;
	es_str_t *estrTmp = NULL;
	uchar *c;
	int bInQuotes;
	DEFiRet;
	assert(iParams != NULL);
	assert(param_binary != NULL);

	/* Search for end of binary name */
	c = es_getBufAddr(param_binary);
	iCnt = 0;
	while(iCnt &lt; es_strlen(param_binary) ) {
		if (c[iCnt] == ' ') {
			/* Split binary name from parameters */
			estrBinary = es_newStrFromSubStr( param_binary, 0, iCnt);
			estrParams = es_newStrFromSubStr( param_binary, iCnt+1,
					es_strlen(param_binary));
			break;
		}
		iCnt++;
	}
	*szBinary = (uchar*)es_str2cstr(estrBinary, NULL);
	DBGPRINTF(&quot;szBinary = '%s'\n&quot;, *szBinary);

	*iParams = 1; /* we always have argv[0] */
	/* count size of argv[] */
	if (estrParams != NULL) {
		 (*iParams)++; /* last parameter is not counted in loop below! */
		if(Debug) {
			char *params = es_str2cstr(estrParams, NULL);
			dbgprintf(&quot;szParams = '%s'\n&quot;, params);
			free(params);
		}
		c = es_getBufAddr(estrParams);
		for(iCnt = 0 ; iCnt &lt; es_strlen(estrParams) ; ++iCnt) {
			if (c[iCnt] == ' ' &amp;&amp; c[iCnt-1] != '\\')
				 (*iParams)++;
		}
	}
	DBGPRINTF(&quot;iParams %d (+1 for NULL terminator)\n&quot;, *iParams);

	/* create argv[] */
	CHKmalloc(*aParams = malloc((*iParams + 1) * sizeof(char*)));
	iPrm = 0;
	bInQuotes = FALSE;
	/* Set first parameter to binary */
	(*aParams)[iPrm] = strdup((char*)*szBinary);
	iPrm++;
	if (estrParams != NULL) {
<A NAME="1"></A>		iCnt = iStr = 0;
		c = es_getBufAddr(estrParams); /* Reset to beginning */
		while(iCnt &lt; es_strlen(estrParams) ) {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2526-1.html#1',3,'match2526-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			if ( c[iCnt] == ' ' &amp;&amp; !bInQuotes ) {
				estrTmp = es_newStrFromSubStr( estrParams, iStr, iCnt-iStr);
			} else if ( iCnt+1 &gt;= es_strlen(estrParams) ) {
				estrTmp = es_newStrFromSubStr( estrParams, iStr, iCnt-iStr+1);
			} else if (c[iCnt] == '&quot;') {
				bInQuotes = !bInQuotes;
			}</B></FONT>

			if ( estrTmp != NULL ) {
				(*aParams)[iPrm] = es_str2cstr(estrTmp, NULL);
				iStr = iCnt+1; /* Set new start */
				DBGPRINTF(&quot;Param (%d): '%s'\n&quot;, iPrm, (*aParams)[iPrm]);
				es_deleteStr( estrTmp );
				estrTmp = NULL;
				iPrm++;
			}
			iCnt++;
		}
	}
	(*aParams)[iPrm] = NULL; /* NULL per argv[] convention */

finalize_it:
	if(estrBinary != param_binary) {
		es_deleteStr(estrBinary);
	}
	if(estrParams != NULL) {
		es_deleteStr(estrParams);
	}
	RETiRet;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>action.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* action.c
 *
 * Implementation of the action object.
 *
 * File begun on 2007-08-06 by RGerhards (extracted from syslogd.c)
 *
 * Some notes on processing (this hopefully makes it easier to find
 * the right code in question): For performance reasons, this module
 * uses different methods of message submission based on the user-selected
 * configuration. This code is similar, but can not be abstracted because
 * of the performance-affecting differences in it. As such, it is often
 * necessary to triple-check that everything works well in *all* modes.
 * The different modes (and calling sequence) are:
 *
 * if set iExecEveryNthOccur &gt; 1 || iSecsExecOnceInterval
 * - doSubmitToActionQComplex
 *   handles mark message reduction, but in essence calls
 * - actionWriteToAction
 * - doSubmitToActionQ
 *   (now queue engine processing)
 * if(pThis-&gt;bWriteAllMarkMsgs == RSFALSE)
 * - doSubmitToActionQNotAllMark
 * - doSubmitToActionQ (and from here like in the else case below!)
 * else
 * - doSubmitToActionQ
 * - qqueueEnqObj
 *   (now queue engine processing)
 *
 * Note that bWriteAllMakrMsgs on or off creates almost the same processing.
 * The difference ist that if WriteAllMarkMsgs is not set, we need to
 * preprocess the batch and drop mark messages which are not yet due for
 * writing.
 *
 * After dequeue, processing is as follows:
 * - processBatchMain
 * - processMsgMain (direct entry for DIRECT queue!)
 * - ...
 *
 * MORE ON PROCESSING, QUEUES and FILTERING
 * All filtering needs to be done BEFORE messages are enqueued to an
 * action. In previous code, part of the filtering was done at the
 * &quot;remote end&quot; of the action queue, which lead to problems in
 * non-direct mode (because then things run asynchronously). In order
 * to solve this problem once and for all, I have changed the code so
 * that all filtering is done before enq, and processing on the
 * dequeue side of action processing now always executes whatever is
 * enqueued. This is the only way to handle things consistently and
 * (as much as possible) in a queue-type agnostic way. However, it is
 * a rather radical change, which I unfortunately needed to make from
 * stable version 5.8.1 to 5.8.2. If new problems pop up, you now know
 * what may be their cause. In any case, the way it is done now is the
 * only correct one.
 * A problem is that, under fortunate conditions, we use the current
 * batch for the output system as well. This is very good from a performance
 * point of view, but makes the distinction between enq and deq side of
 * the queue a bit hard. The current idea is that the filter condition
 * alone is checked at the deq side of the queue (seems to be unavoidable
 * to do it that way), but all other complex conditons (like failover
 * handling) go into the computation of the filter condition. For
 * non-direct queues, we still enqueue only what is acutally necessary.
 * Note that in this case the rest of the code must ensure that the filter
 * is set to &quot;true&quot;. While this is not perfect and not as simple as
 * we would like to see it, it looks like the best way to tackle that
 * beast.
 * rgerhards, 2011-06-15
 *
 * Copyright 2007-2019 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file &quot;COPYING&quot; in this distribution.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;json.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;dirty.h&quot;
#include &quot;template.h&quot;
#include &quot;action.h&quot;
#include &quot;modules.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;batch.h&quot;
#include &quot;wti.h&quot;
#include &quot;rsconf.h&quot;
#include &quot;datetime.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;atomic.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;parserif.h&quot;
#include &quot;statsobj.h&quot;

/* AIXPORT : cs renamed to legacy_cs as clashes with libpthreads variable in complete file*/
#ifdef _AIX
#define cs legacy_cs
#endif

PRAGMA_INGORE_Wswitch_enum

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

#define NO_TIME_PROVIDED 0 /* indicate we do not provide any cached time */

/* forward definitions */
static rsRetVal ATTR_NONNULL() processBatchMain(void *pVoid, batch_t *pBatch, wti_t * const pWti);
static rsRetVal doSubmitToActionQ(action_t * const pAction, wti_t * const pWti, smsg_t*);
static rsRetVal doSubmitToActionQComplex(action_t * const pAction, wti_t * const pWti, smsg_t*);
static rsRetVal doSubmitToActionQNotAllMark(action_t * const pAction, wti_t * const pWti, smsg_t*);
static void ATTR_NONNULL() actionSuspend(action_t * const pThis, wti_t * const pWti);
static void ATTR_NONNULL() actionRetry(action_t * const pThis, wti_t * const pWti);

/* object static data (once for all instances) */
DEFobjCurrIf(obj)
DEFobjCurrIf(datetime)
DEFobjCurrIf(module)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(ruleset)


typedef struct configSettings_s {
	int bActExecWhenPrevSusp;			/* execute action only when previous one was suspended? */
	int bActionWriteAllMarkMsgs;			/* should all mark messages be unconditionally written? */
	int iActExecOnceInterval;			/* execute action once every nn seconds */
	int iActExecEveryNthOccur;			/* execute action every n-th occurrence (0,1=always) */
	time_t iActExecEveryNthOccurTO;			/* timeout for n-occurrence setting (in seconds, 0=never) */
	int glbliActionResumeInterval;
	int glbliActionResumeRetryCount;		/* how often should suspended actions be retried? */
	int bActionRepMsgHasMsg;			/* last messsage repeated... has msg fragment in it */
	uchar *pszActionName;				/* short name for the action */
	/* action queue and its configuration parameters */
	queueType_t ActionQueType;			/* type of the main message queue above */
	int iActionQueueSize;				/* size of the main message queue above */
	int iActionQueueDeqBatchSize;			/* batch size for action queues */
	int iActionQHighWtrMark;			/* high water mark for disk-assisted queues */
	int iActionQLowWtrMark;				/* low water mark for disk-assisted queues */
	int iActionQDiscardMark;			/* begin to discard messages */
	int iActionQDiscardSeverity;
	/* by default, discard nothing to prevent unintentional loss */
	int iActionQueueNumWorkers;			/* number of worker threads for the mm queue above */
	uchar *pszActionQFName;				/* prefix for the main message queue file */
	int64 iActionQueMaxFileSize;
	int iActionQPersistUpdCnt;			/* persist queue info every n updates */
	int bActionQSyncQeueFiles;			/* sync queue files */
	int iActionQtoQShutdown;			/* queue shutdown */
	int iActionQtoActShutdown;			/* action shutdown (in phase 2) */
	int iActionQtoEnq;				/* timeout for queue enque */
	int iActionQtoWrkShutdown;			/* timeout for worker thread shutdown */
	int iActionQWrkMinMsgs;				/* minimum messages per worker needed to start a new one */
	int bActionQSaveOnShutdown;			/* save queue on shutdown (when DA enabled)? */
	int64 iActionQueMaxDiskSpace;			/* max disk space allocated 0 ==&gt; unlimited */
	int iActionQueueDeqSlowdown;			/* dequeue slowdown (simple rate limiting) */
	int iActionQueueDeqtWinFromHr;			/* hour begin of time frame when queue is to be dequeued */
	int iActionQueueDeqtWinToHr;			/* hour begin of time frame when queue is to be dequeued */
} configSettings_t;


<A NAME="0"></A>static configSettings_t cs;					/* our current config settings */

/* tables for interfacing with the v6 config system */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2526-0.html#0',2,'match2526-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static struct cnfparamdescr cnfparamdescr[] = {
	{ &quot;name&quot;, eCmdHdlrGetWord, 0 }, /* legacy: actionname */
	{ &quot;type&quot;, eCmdHdlrString, CNFPARAM_REQUIRED }, /* legacy: actionname */
	{ &quot;action.errorfile&quot;, eCmdHdlrString, 0 },
	{ &quot;action.errorfile.maxsize&quot;, eCmdHdlrInt, 0 },
	{ &quot;action.writeallmarkmessages&quot;, eCmdHdlrBinary, 0 }, /* legacy: actionwriteallmarkmessages */
	{ &quot;action.execonlyeverynthtime&quot;, eCmdHdlrInt, 0 }, /* legacy: actionexeconlyeverynthtime */
	{ &quot;action.execonlyeverynthtimetimeout&quot;, eCmdHdlrInt, 0 }, /* legacy: actionexeconlyeverynthtimetimeout */
	{ &quot;action.execonlyonceeveryinterval&quot;, eCmdHdlrInt, 0 }, /* legacy: actionexeconlyonceeveryinterval */
	{ &quot;action.execonlywhenpreviousissuspended&quot;, eCmdHdlrBinary, 0 },
	/* legacy: actionexeconlywhenpreviousissuspended */
	{ &quot;action.repeatedmsgcontainsoriginalmsg&quot;, eCmdHdlrBinary, 0 }, /* legacy: repeatedmsgcontainsoriginalmsg */
	{ &quot;action.resumeretrycount&quot;, eCmdHdlrInt, 0 }, /* legacy: actionresumeretrycount */
	{ &quot;action.reportsuspension&quot;, eCmdHdlrBinary, 0 },
	{ &quot;action.reportsuspensioncontinuation&quot;, eCmdHdlrBinary, 0 },
	{ &quot;action.resumeintervalmax&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;action.resumeinterval&quot;, eCmdHdlrInt, 0 },
	{ &quot;action.externalstate.file&quot;, eCmdHdlrString, 0 },
	{ &quot;action.copymsg&quot;, eCmdHdlrBinary, 0 }</B></FONT>
};
static struct cnfparamblk pblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(cnfparamdescr)/sizeof(struct cnfparamdescr),
	  cnfparamdescr
	};


/* primarily a helper for debug purposes, get human-readble name of state */
/* currently not needed, but may be useful in the future! */
#if 0
static const char *
batchState2String(const batch_state_t state)
{
	switch(state) {
	case BATCH_STATE_RDY:
		return &quot;BATCH_STATE_RDY&quot;;
	case BATCH_STATE_BAD:
		return &quot;BATCH_STATE_BAD&quot;;
	case BATCH_STATE_SUB:
		return &quot;BATCH_STATE_SUB&quot;;
	case BATCH_STATE_COMM:
		return &quot;BATCH_STATE_COMM&quot;;
	case BATCH_STATE_DISC:
		return &quot;BATCH_STATE_DISC&quot;;
	default:
		return &quot;ERROR, batch state not known!&quot;;
	}
}
#endif // #if 0

/* ------------------------------ methods ------------------------------ */

/* This function returns the &quot;current&quot; time for this action. Current time
 * is not necessarily real-time. In order to enhance performance, current
 * system time is obtained the first time an action needs to know the time
 * and then kept cached inside the action structure. Later requests will
 * always return that very same time. Wile not totally accurate, it is far
 * accurate in most cases and considered &quot;acurate enough&quot; for all cases.
 * When changing the threading model, please keep in mind that this
 * logic needs to be changed should we once allow more than one parallel
 * call into the same action (object). As this is currently not supported,
 * we simply cache the time inside the action object itself, after it
 * is under mutex protection.
 * Side-note: the value -1 is used as tActNow, because it also is the
 * error return value of time(). So we would do a retry with the next
 * invocation if time() failed. Then, of course, we would probably already
 * be in trouble, but for the sake of performance we accept this very,
 * very slight risk.
 * This logic has been added as part of an overall performance improvment
 * effort inspired by David Lang. -- rgerhards, 2008-09-16
 * Note: this function does not use the usual iRet call conventions
 * because that would provide little to no benefit but complicate things
 * a lot. So we simply return the system time.
 */
static time_t
getActNow(action_t * const pThis)
{
	assert(pThis != NULL);
	if(pThis-&gt;tActNow == -1) {
		pThis-&gt;tActNow = datetime.GetTime(NULL); /* good time call - the only one done */
		if(pThis-&gt;tLastExec &gt; pThis-&gt;tActNow) {
			/* if we are traveling back in time, reset tLastExec */
			pThis-&gt;tLastExec = (time_t) 0;
		}
	}

	return pThis-&gt;tActNow;
}


/* resets action queue parameters to their default values. This happens
 * after each action has been created in order to prevent any wild defaults
 * to be used. It is somewhat against the original spirit of the config file
 * reader, but I think it is a good thing to do.
 * rgerhards, 2008-01-29
 */
static rsRetVal
actionResetQueueParams(void)
{
	DEFiRet;

	cs.ActionQueType = QUEUETYPE_DIRECT;		/* type of the main message queue above */
	cs.iActionQueueSize = 1000;			/* size of the main message queue above */
	cs.iActionQueueDeqBatchSize = 16;		/* default batch size */
	cs.iActionQHighWtrMark = -1;			/* high water mark for disk-assisted queues */
	cs.iActionQLowWtrMark = -1;			/* low water mark for disk-assisted queues */
	cs.iActionQDiscardMark = 980;			/* begin to discard messages */
	cs.iActionQDiscardSeverity = 8;			/* discard warning and above */
	cs.iActionQueueNumWorkers = 1;			/* number of worker threads for the mm queue above */
	cs.iActionQueMaxFileSize = 1024*1024;
	cs.iActionQPersistUpdCnt = 0;			/* persist queue info every n updates */
	cs.bActionQSyncQeueFiles = 0;
	cs.iActionQtoQShutdown = 0;			/* queue shutdown */
	cs.iActionQtoActShutdown = 1000;		/* action shutdown (in phase 2) */
	cs.iActionQtoEnq = 50;				/* timeout for queue enque */
	cs.iActionQtoWrkShutdown = 60000;		/* timeout for worker thread shutdown */
	cs.iActionQWrkMinMsgs = -1;			/* minimum messages per worker needed to start a new one */
	cs.bActionQSaveOnShutdown = 1;			/* save queue on shutdown (when DA enabled)? */
	cs.iActionQueMaxDiskSpace = 0;
	cs.iActionQueueDeqSlowdown = 0;
	cs.iActionQueueDeqtWinFromHr = 0;
	cs.iActionQueueDeqtWinToHr = 25;		/* 25 disables time windowed dequeuing */

	cs.glbliActionResumeRetryCount = 0;		/* I guess it is smart to reset this one, too */

	free(cs.pszActionQFName);
	cs.pszActionQFName = NULL;			/* prefix for the main message queue file */

	RETiRet;
}


/* destructs an action descriptor object
 * rgerhards, 2007-08-01
 */
rsRetVal actionDestruct(action_t * const pThis)
{
	DEFiRet;
	assert(pThis != NULL);

	if(!strcmp((char*)modGetName(pThis-&gt;pMod), &quot;builtin:omdiscard&quot;)) {
		/* discard actions will be optimized out */
		FINALIZE;
	}

	if(pThis-&gt;pQueue != NULL) {
		qqueueDestruct(&amp;pThis-&gt;pQueue);
	}

	/* destroy stats object, if we have one (may not always be
	 * be the case, e.g. if turned off)
	 */
	if(pThis-&gt;statsobj != NULL)
		statsobj.Destruct(&amp;pThis-&gt;statsobj);

	if(pThis-&gt;pModData != NULL)
		pThis-&gt;pMod-&gt;freeInstance(pThis-&gt;pModData);

	if(pThis-&gt;fdErrFile != -1)
		close(pThis-&gt;fdErrFile);
	pthread_mutex_destroy(&amp;pThis-&gt;mutErrFile);
	pthread_mutex_destroy(&amp;pThis-&gt;mutAction);
	pthread_mutex_destroy(&amp;pThis-&gt;mutWrkrDataTable);
	free((void*)pThis-&gt;pszErrFile);
	free((void*)pThis-&gt;pszExternalStateFile);
	free(pThis-&gt;pszName);
	free(pThis-&gt;ppTpl);
	free(pThis-&gt;peParamPassing);
	free(pThis-&gt;wrkrDataTable);

finalize_it:
	free(pThis);
	RETiRet;
}


/* Disable action, this means it will never again be usable
 * until rsyslog is reloaded. Use only as a last resort, but
 * depends on output module.
 * rgerhards, 2007-08-02
 */
static inline void
actionDisable(action_t *__restrict__ const pThis)
{
	pThis-&gt;bDisabled = 1;
}



/* create a new action descriptor object
 * rgerhards, 2007-08-01
 * Note that it is vital to set proper initial values as the v6 config
 * system depends on these!
 */
rsRetVal actionConstruct(action_t **ppThis)
{
	DEFiRet;
	action_t *pThis;

	assert(ppThis != NULL);

	CHKmalloc(pThis = (action_t*) calloc(1, sizeof(action_t)));
	pThis-&gt;iResumeInterval = 30;
	pThis-&gt;iResumeIntervalMax = 1800; /* max interval default is half an hour */
	pThis-&gt;iResumeRetryCount = 0;
	pThis-&gt;pszName = NULL;
	pThis-&gt;pszErrFile = NULL;
	pThis-&gt;maxErrFileSize = 0;
	pThis-&gt;currentErrFileSize = 0;
	pThis-&gt;pszExternalStateFile = NULL;
	pThis-&gt;fdErrFile = -1;
	pThis-&gt;bWriteAllMarkMsgs = 1;
	pThis-&gt;iExecEveryNthOccur = 0;
	pThis-&gt;iExecEveryNthOccurTO = 0;
	pThis-&gt;iSecsExecOnceInterval = 0;
	pThis-&gt;bExecWhenPrevSusp = 0;
	pThis-&gt;bRepMsgHasMsg = 0;
	pThis-&gt;bDisabled = 0;
	pThis-&gt;isTransactional = 0;
	pThis-&gt;bReportSuspension = -1; /* indicate &quot;not yet set&quot; */
	pThis-&gt;bReportSuspensionCont = -1; /* indicate &quot;not yet set&quot; */
	pThis-&gt;bCopyMsg = 0;
	pThis-&gt;tLastOccur = datetime.GetTime(NULL);	/* done once per action on startup only */
	pThis-&gt;iActionNbr = loadConf-&gt;actions.iActionNbr;
	pthread_mutex_init(&amp;pThis-&gt;mutErrFile, NULL);
	pthread_mutex_init(&amp;pThis-&gt;mutAction, NULL);
	pthread_mutex_init(&amp;pThis-&gt;mutWrkrDataTable, NULL);
	INIT_ATOMIC_HELPER_MUT(pThis-&gt;mutCAS);

	/* indicate we have a new action */
	loadConf-&gt;actions.iActionNbr++;

finalize_it:
	*ppThis = pThis;
	RETiRet;
}


/* action construction finalizer
 */
rsRetVal
actionConstructFinalize(action_t *__restrict__ const pThis, struct nvlst *lst)
{
	DEFiRet;
	uchar pszAName[64]; /* friendly name of our action */

	if(!strcmp((char*)modGetName(pThis-&gt;pMod), &quot;builtin:omdiscard&quot;)) {
		/* discard actions will be optimized out */
		FINALIZE;
	}
	/* generate a friendly name for us action stats */
	if(pThis-&gt;pszName == NULL) {
		snprintf((char*) pszAName, sizeof(pszAName), &quot;action-%d-%s&quot;,
			pThis-&gt;iActionNbr, pThis-&gt;pMod-&gt;pszName);
		pThis-&gt;pszName = ustrdup(pszAName);
	}

	/* cache transactional attribute */
	pThis-&gt;isTransactional = pThis-&gt;pMod-&gt;mod.om.supportsTX;
	if(pThis-&gt;isTransactional) {
		int i;
		for(i = 0 ; i &lt; pThis-&gt;iNumTpls ; ++i) {
			if(pThis-&gt;peParamPassing[i] != ACT_STRING_PASSING) {
				LogError(0, RS_RET_INVLD_OMOD, &quot;action '%s'(%d) is transactional but &quot;
						&quot;parameter %d &quot;
						&quot;uses invalid parameter passing mode -- disabling &quot;
						&quot;action. This is probably caused by a pre-v7 &quot;
						&quot;output module that needs upgrade.&quot;,
						pThis-&gt;pszName, pThis-&gt;iActionNbr, i);
				actionDisable(pThis);
				ABORT_FINALIZE(RS_RET_INVLD_OMOD);

			}
		}
	}


	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;pThis-&gt;statsobj));
	CHKiRet(statsobj.SetName(pThis-&gt;statsobj, pThis-&gt;pszName));
	CHKiRet(statsobj.SetOrigin(pThis-&gt;statsobj, (uchar*)&quot;core.action&quot;));

	STATSCOUNTER_INIT(pThis-&gt;ctrProcessed, pThis-&gt;mutCtrProcessed);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;processed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrProcessed));

	STATSCOUNTER_INIT(pThis-&gt;ctrFail, pThis-&gt;mutCtrFail);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;failed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrFail));

	STATSCOUNTER_INIT(pThis-&gt;ctrSuspend, pThis-&gt;mutCtrSuspend);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;suspended&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrSuspend));
	STATSCOUNTER_INIT(pThis-&gt;ctrSuspendDuration, pThis-&gt;mutCtrSuspendDuration);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;suspended.duration&quot;),
		ctrType_IntCtr, 0, &amp;pThis-&gt;ctrSuspendDuration));

	STATSCOUNTER_INIT(pThis-&gt;ctrResume, pThis-&gt;mutCtrResume);
	CHKiRet(statsobj.AddCounter(pThis-&gt;statsobj, UCHAR_CONSTANT(&quot;resumed&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;pThis-&gt;ctrResume));

	CHKiRet(statsobj.ConstructFinalize(pThis-&gt;statsobj));

	/* create our queue */

	/* generate a friendly name for the queue */
	snprintf((char*) pszAName, sizeof(pszAName), &quot;%s queue&quot;,
		 pThis-&gt;pszName);

	/* now check if we can run the action in &quot;firehose mode&quot; during stage one of
	 * its processing (that is before messages are enqueued into the action q).
	 * This is only possible if some features, which require strict sequence, are
	 * not used. Thankfully, that is usually the case. The benefit of firehose
	 * mode is much faster processing (and simpler code) -- rgerhards, 2010-06-08
	 */
	if(   pThis-&gt;iExecEveryNthOccur &gt; 1
	   || pThis-&gt;iSecsExecOnceInterval
	  ) {
		DBGPRINTF(&quot;info: firehose mode disabled for action because &quot;
		          &quot;iExecEveryNthOccur=%d, iSecsExecOnceInterval=%d\n&quot;,
			  pThis-&gt;iExecEveryNthOccur, pThis-&gt;iSecsExecOnceInterval);
		pThis-&gt;submitToActQ = doSubmitToActionQComplex;
	} else if(pThis-&gt;bWriteAllMarkMsgs) {
		/* full firehose submission mode, default case*/
		pThis-&gt;submitToActQ = doSubmitToActionQ;
	} else {
		/* nearly full-speed submission mode */
		pThis-&gt;submitToActQ = doSubmitToActionQNotAllMark;
	}

	/* create queue */
	/* action queues always (for now) have just one worker. This may change when
	 * we begin to implement an interface the enable output modules to request
	 * to be run on multiple threads. So far, this is forbidden by the interface
	 * spec. -- rgerhards, 2008-01-30
	 */
	CHKiRet(qqueueConstruct(&amp;pThis-&gt;pQueue, cs.ActionQueType, 1, cs.iActionQueueSize,
					processBatchMain));
	obj.SetName((obj_t*) pThis-&gt;pQueue, pszAName);
	qqueueSetpAction(pThis-&gt;pQueue, pThis);

	if(lst == NULL) { /* use legacy params? */
		/* ... set some properties ... */
#		define setQPROP(func, directive, data) \
		CHKiRet_Hdlr(func(pThis-&gt;pQueue, data)) { \
			LogError(0, NO_ERRCODE, &quot;Invalid &quot; #directive &quot;, \
				error %d. Ignored, running with default setting&quot;, iRet); \
		}
#		define setQPROPstr(func, directive, data) \
		CHKiRet_Hdlr(func(pThis-&gt;pQueue, data, (data == NULL)? 0 : strlen((char*) data))) { \
			LogError(0, NO_ERRCODE, &quot;Invalid &quot; #directive &quot;, \
				error %d. Ignored, running with default setting&quot;, iRet); \
		}
		setQPROP(qqueueSetsizeOnDiskMax, &quot;$ActionQueueMaxDiskSpace&quot;, cs.iActionQueMaxDiskSpace);
		setQPROP(qqueueSetiDeqBatchSize, &quot;$ActionQueueDequeueBatchSize&quot;, cs.iActionQueueDeqBatchSize);
		setQPROP(qqueueSetMaxFileSize, &quot;$ActionQueueFileSize&quot;, cs.iActionQueMaxFileSize);
		setQPROPstr(qqueueSetFilePrefix, &quot;$ActionQueueFileName&quot;, cs.pszActionQFName);
		setQPROP(qqueueSetiPersistUpdCnt, &quot;$ActionQueueCheckpointInterval&quot;, cs.iActionQPersistUpdCnt);
		setQPROP(qqueueSetbSyncQueueFiles, &quot;$ActionQueueSyncQueueFiles&quot;, cs.bActionQSyncQeueFiles);
		setQPROP(qqueueSettoQShutdown, &quot;$ActionQueueTimeoutShutdown&quot;, cs.iActionQtoQShutdown );
		setQPROP(qqueueSettoActShutdown, &quot;$ActionQueueTimeoutActionCompletion&quot;, cs.iActionQtoActShutdown);
		setQPROP(qqueueSettoWrkShutdown, &quot;$ActionQueueWorkerTimeoutThreadShutdown&quot;, cs.iActionQtoWrkShutdown);
		setQPROP(qqueueSettoEnq, &quot;$ActionQueueTimeoutEnqueue&quot;, cs.iActionQtoEnq);
		setQPROP(qqueueSetiHighWtrMrk, &quot;$ActionQueueHighWaterMark&quot;, cs.iActionQHighWtrMark);
		setQPROP(qqueueSetiLowWtrMrk, &quot;$ActionQueueLowWaterMark&quot;, cs.iActionQLowWtrMark);
		setQPROP(qqueueSetiDiscardMrk, &quot;$ActionQueueDiscardMark&quot;, cs.iActionQDiscardMark);
		setQPROP(qqueueSetiDiscardSeverity, &quot;$ActionQueueDiscardSeverity&quot;, cs.iActionQDiscardSeverity);
		setQPROP(qqueueSetiMinMsgsPerWrkr, &quot;$ActionQueueWorkerThreadMinimumMessages&quot;, cs.iActionQWrkMinMsgs);
		setQPROP(qqueueSetiNumWorkerThreads, &quot;$ActionQueueWorkerThreads&quot;, cs.iActionQueueNumWorkers);
		setQPROP(qqueueSetbSaveOnShutdown, &quot;$ActionQueueSaveOnShutdown&quot;, cs.bActionQSaveOnShutdown);
		setQPROP(qqueueSetiDeqSlowdown,    &quot;$ActionQueueDequeueSlowdown&quot;, cs.iActionQueueDeqSlowdown);
		setQPROP(qqueueSetiDeqtWinFromHr,  &quot;$ActionQueueDequeueTimeBegin&quot;, cs.iActionQueueDeqtWinFromHr);
		setQPROP(qqueueSetiDeqtWinToHr,    &quot;$ActionQueueDequeueTimeEnd&quot;, cs.iActionQueueDeqtWinToHr);
	} else {
		/* we have v6-style config params */
		qqueueSetDefaultsActionQueue(pThis-&gt;pQueue);
		qqueueApplyCnfParam(pThis-&gt;pQueue, lst);
	}
	qqueueCorrectParams(pThis-&gt;pQueue);

#	undef setQPROP
#	undef setQPROPstr

	qqueueDbgPrint(pThis-&gt;pQueue);

	DBGPRINTF(&quot;Action %p: queue %p created\n&quot;, pThis, pThis-&gt;pQueue);

	if(pThis-&gt;bUsesMsgPassingMode &amp;&amp; pThis-&gt;pQueue-&gt;qType != QUEUETYPE_DIRECT) {
		parser_warnmsg(&quot;module %s with message passing mode uses &quot;
			&quot;non-direct queue. This most probably leads to undesired &quot;
			&quot;results. For message modificaton modules (mm*), this means &quot;
			&quot;that they will have no effect - &quot;
			&quot;see https://www.rsyslog.com/mm-no-queue/&quot;, (char*)modGetName(pThis-&gt;pMod));
	}

	/* and now reset the queue params (see comment in its function header!) */
	actionResetQueueParams();

finalize_it:
	RETiRet;
}



/* set the global resume interval
 */
rsRetVal actionSetGlobalResumeInterval(int iNewVal)
{
	cs.glbliActionResumeInterval = iNewVal;
	return RS_RET_OK;
}


/* returns the action state name in human-readable form
 * returned string must not be modified.
 * rgerhards, 2009-05-07
 */
static uchar *getActStateName(action_t * const pThis, wti_t * const pWti)
{
	switch(getActionState(pWti, pThis)) {
		case ACT_STATE_RDY:
			return (uchar*) &quot;rdy&quot;;
		case ACT_STATE_ITX:
			return (uchar*) &quot;itx&quot;;
		case ACT_STATE_RTRY:
			return (uchar*) &quot;rtry&quot;;
		case ACT_STATE_SUSP:
			return (uchar*) &quot;susp&quot;;
		case ACT_STATE_DATAFAIL:
			return (uchar*) &quot;datafail&quot;;
		default:
			return (uchar*) &quot;ERROR/UNKNWON&quot;;
	}
}


/* returns a suitable return code based on action state
 * rgerhards, 2009-05-07
 */
static rsRetVal getReturnCode(action_t * const pThis, wti_t * const pWti)
{
	DEFiRet;

	switch(getActionState(pWti, pThis)) {
		case ACT_STATE_RDY:
			iRet = RS_RET_OK;
			break;
		case ACT_STATE_ITX:
			if(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit) {
				pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 0; /* auto-reset */
				iRet = RS_RET_PREVIOUS_COMMITTED;
			} else {
				iRet = RS_RET_DEFER_COMMIT;
			}
			break;
		case ACT_STATE_RTRY:
			iRet = RS_RET_SUSPENDED;
			break;
		case ACT_STATE_SUSP:
			iRet = RS_RET_ACTION_FAILED;
			break;
		case ACT_STATE_DATAFAIL:
			iRet = RS_RET_DATAFAIL;
			break;
		default:
			DBGPRINTF(&quot;Invalid action engine state %u, program error\n&quot;,
				  getActionState(pWti, pThis));
			iRet = RS_RET_ERR;
			break;
	}

	RETiRet;
}


/* set the action to a new state
 * rgerhards, 2007-08-02
 */
static void
actionSetState(action_t * const pThis, wti_t * const pWti, uint8_t newState)
{
	setActionState(pWti, pThis, newState);
	DBGPRINTF(&quot;action[%s] transitioned to state: %s\n&quot;,
		  pThis-&gt;pszName, getActStateName(pThis, pWti));
}

/* Handles the transient commit state. So far, this is
 * mostly a dummy...
 * rgerhards, 2007-08-02
 */
static void actionCommitted(action_t * const pThis, wti_t * const pWti)
{
	actionSetState(pThis, pWti, ACT_STATE_RDY);
}


/* set action state according to external state file (if configured)
*/
static rsRetVal ATTR_NONNULL()
checkExternalStateFile(action_t *const pThis, wti_t *const pWti)
{
	char filebuf[1024];
	int fd = -1;
	int r;
	DEFiRet;

	DBGPRINTF(&quot;checking external state file\n&quot;);

	if(pThis-&gt;pszExternalStateFile == NULL) {
		FINALIZE;
	}

	fd = open(pThis-&gt;pszExternalStateFile, O_RDONLY|O_CLOEXEC);
	if(fd == -1) {
		dbgprintf(&quot;could not read external state file\n&quot;);
		FINALIZE;
	}

	r = read(fd, filebuf, sizeof(filebuf) - 1);
	if(r &lt; 1) {
		dbgprintf(&quot;checkExternalStateFile read() returned %d\n&quot;, r);
		FINALIZE;
	}

	filebuf[r] = '\0';
	dbgprintf(&quot;external state file content: '%s'\n&quot;, filebuf);
	/* trim trailing whitespace */
	for(int j = r-1 ; j &gt; 0 ; --j) {
		if(filebuf[j] == '\n' || filebuf[j] == '\t' || filebuf[j] == ' ') {
			filebuf[j] = '\0';
		} else {
			break;
		}
	}
	if(!strcmp(filebuf, &quot;SUSPENDED&quot;)) {
		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		      &quot;action '%s' suspended (module '%s') by external state file&quot;,
		      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
		actionRetry(pThis, pWti);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}

finalize_it:
	if(fd != -1) {
		close(fd);
	}
	DBGPRINTF(&quot;done checking external state file, iRet=%d\n&quot;, iRet);
	RETiRet;
}


/* we need to defer setting the action's own bReportSuspension state until
 * after the full config has been processed. So the most simple case to do
 * that is here. It's not a performance problem, as it happens infrequently.
 * it's not a threading race problem, as always the same value will be written.
 * As we need to do this in several places, we have moved the code to its own
 * helper function.
 */
static void
setSuspendMessageConfVars(action_t *__restrict__ const pThis)
{
	if(pThis-&gt;bReportSuspension == -1)
		pThis-&gt;bReportSuspension = runConf-&gt;globals.bActionReportSuspension;
	if(pThis-&gt;bReportSuspensionCont == -1) {
		pThis-&gt;bReportSuspensionCont = runConf-&gt;globals.bActionReportSuspensionCont;
		if(pThis-&gt;bReportSuspensionCont == -1)
			pThis-&gt;bReportSuspensionCont = 1;
	}
}


/* set action to &quot;rtry&quot; state.
 * rgerhards, 2007-08-02
 */
static void ATTR_NONNULL() actionRetry(action_t * const pThis, wti_t * const pWti)
{
	setSuspendMessageConfVars(pThis);
	actionSetState(pThis, pWti, ACT_STATE_RTRY);
	if(pThis-&gt;bReportSuspension) {
		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		      &quot;action '%s' suspended (module '%s'), retry %d. There should &quot;
		      &quot;be messages before this one giving the reason for suspension.&quot;,
		      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName,
		      getActionNbrResRtry(pWti, pThis));
	}
	incActionResumeInRow(pWti, pThis);
}

/* Suspend action, this involves changing the action state as well
 * as setting the next retry time.
 * if we have more than 10 retries, we prolong the
 * retry interval. If something is really stalled, it will
 * get re-tried only very, very seldom - but that saves
 * CPU time. TODO: maybe a config option for that?
 * rgerhards, 2007-08-02
 */
static void ATTR_NONNULL()
actionSuspend(action_t * const pThis, wti_t * const pWti)
{
	time_t ttNow;
	int suspendDuration;
	char timebuf[32];

	setSuspendMessageConfVars(pThis);

	/* note: we can NOT use a cached timestamp, as time may have evolved
	 * since caching, and this would break logic (and it actually did so!)
	 */
	datetime.GetTime(&amp;ttNow);
	suspendDuration = pThis-&gt;iResumeInterval * (getActionNbrResRtry(pWti, pThis) / 10 + 1);
	if(pThis-&gt;iResumeIntervalMax &gt; 0 &amp;&amp; suspendDuration &gt; pThis-&gt;iResumeIntervalMax) {
		suspendDuration = pThis-&gt;iResumeIntervalMax;
	}
	pThis-&gt;ttResumeRtry = ttNow + suspendDuration;
	actionSetState(pThis, pWti, ACT_STATE_SUSP);
	pThis-&gt;ctrSuspendDuration += suspendDuration;
	if(getActionNbrResRtry(pWti, pThis) == 0) {
		STATSCOUNTER_INC(pThis-&gt;ctrSuspend, pThis-&gt;mutCtrSuspend);
	}

	if(   pThis-&gt;bReportSuspensionCont
	   || (pThis-&gt;bReportSuspension &amp;&amp; getActionNbrResRtry(pWti, pThis) == 0) ) {
		ctime_r(&amp;pThis-&gt;ttResumeRtry, timebuf);
		timebuf[strlen(timebuf)-1] = '\0'; /* strip LF */
		LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
			      &quot;action '%s' suspended (module '%s'), next retry is %s, retry nbr %d. &quot;
			      &quot;There should be messages before this one giving the reason for suspension.&quot;,
			      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName, timebuf,
			      getActionNbrResRtry(pWti, pThis));
	}
	DBGPRINTF(&quot;action '%s' suspended, earliest retry=%lld (now %lld), iNbrResRtry %d, &quot;
		  &quot;duration %d\n&quot;,
		  pThis-&gt;pszName, (long long) pThis-&gt;ttResumeRtry, (long long) ttNow,
		  getActionNbrResRtry(pWti, pThis), suspendDuration);
}


/* actually do retry processing. Note that the function receives a timestamp so
 * that we do not need to call the (expensive) time() API.
 * Note that we do the full retry processing here, doing the configured number of
 * iterations. -- rgerhards, 2009-05-07
 * We need to guard against module which always return RS_RET_OK from their tryResume()
 * entry point. This is invalid, but has harsh consequences: it will cause the rsyslog
 * engine to go into a tight loop. That obviously is not acceptable. As such, we track the
 * count of iterations that a tryResume returning RS_RET_OK is immediately followed by
 * an unsuccessful call to doAction(). If that happens more than 10 times, we assume
 * the return acutally is a RS_RET_SUSPENDED. In order to go through the various
 * resumption stages, we do this for every 10 requests. This magic number 10 may
 * not be the most appropriate, but it should be thought of a &quot;if nothing else helps&quot;
 * kind of facility: in the first place, the module should return a proper indication
 * of its inability to recover. -- rgerhards, 2010-04-26.
 */
static rsRetVal ATTR_NONNULL()
actionDoRetry(action_t * const pThis, wti_t * const pWti)
{
	int iRetries;
	int iSleepPeriod;
	int bTreatOKasSusp;
	DEFiRet;

	assert(pThis != NULL);

	iRetries = 0;
	while((*pWti-&gt;pbShutdownImmediate == 0) &amp;&amp; getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		DBGPRINTF(&quot;actionDoRetry: %s enter loop, iRetries=%d, ResumeInRow %d\n&quot;,
			pThis-&gt;pszName, iRetries, getActionResumeInRow(pWti, pThis));
			iRet = pThis-&gt;pMod-&gt;tryResume(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		DBGPRINTF(&quot;actionDoRetry: %s action-&gt;tryResume returned %d\n&quot;, pThis-&gt;pszName, iRet);
		if((getActionResumeInRow(pWti, pThis) &gt; 9) &amp;&amp; (getActionResumeInRow(pWti, pThis) % 10 == 0)) {
			bTreatOKasSusp = 1;
			setActionResumeInRow(pWti, pThis, 0);
			iRet = RS_RET_SUSPENDED;
		} else {
			bTreatOKasSusp = 0;
		}
		if((iRet == RS_RET_OK) &amp;&amp; (!bTreatOKasSusp)) {
			DBGPRINTF(&quot;actionDoRetry: %s had success RDY again (iRet=%d)\n&quot;,
				  pThis-&gt;pszName, iRet);
			STATSCOUNTER_INC(pThis-&gt;ctrResume, pThis-&gt;mutCtrResume);
			if(pThis-&gt;bReportSuspension) {
				LogMsg(0, RS_RET_RESUMED, LOG_INFO, &quot;action '%s' &quot;
					      &quot;resumed (module '%s')&quot;,
					      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			}
			actionSetState(pThis, pWti, ACT_STATE_RDY);
		} else if(iRet == RS_RET_SUSPENDED || bTreatOKasSusp) {
			/* max retries reached? */
			DBGPRINTF(&quot;actionDoRetry: %s check for max retries, iResumeRetryCount &quot;
				  &quot;%d, iRetries %d\n&quot;,
				  pThis-&gt;pszName, pThis-&gt;iResumeRetryCount, iRetries);
			if((pThis-&gt;iResumeRetryCount != -1 &amp;&amp; iRetries &gt;= pThis-&gt;iResumeRetryCount)) {
				actionSuspend(pThis, pWti);
				if(getActionNbrResRtry(pWti, pThis) &lt; 20)
					incActionNbrResRtry(pWti, pThis);
			} else {
				++iRetries;
				iSleepPeriod = pThis-&gt;iResumeInterval;
				srSleep(iSleepPeriod, 0);
				if(*pWti-&gt;pbShutdownImmediate) {
					ABORT_FINALIZE(RS_RET_FORCE_TERM);
				}
			}
		} else if(iRet == RS_RET_DISABLE_ACTION) {
			actionDisable(pThis);
		}
	}

	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		setActionNbrResRtry(pWti, pThis, 0);
	}

finalize_it:
	RETiRet;
}


/* special retry handling if disabled via file: simply wait for the file
 * to indicate whether or not it is ready again
 */
static rsRetVal ATTR_NONNULL()
actionDoRetry_extFile(action_t *const pThis, wti_t *const pWti)
{
	int iRetries;
	int iSleepPeriod;
	DEFiRet;

	assert(pThis != NULL);

	DBGPRINTF(&quot;actionDoRetry_extFile: enter, actionState: %d\n&quot;,getActionState(pWti, pThis));
	iRetries = 0;
	while((*pWti-&gt;pbShutdownImmediate == 0) &amp;&amp; getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		DBGPRINTF(&quot;actionDoRetry_extFile: %s enter loop, iRetries=%d, ResumeInRow %d\n&quot;,
			pThis-&gt;pszName, iRetries, getActionResumeInRow(pWti, pThis));
			iRet = checkExternalStateFile(pThis, pWti);
		DBGPRINTF(&quot;actionDoRetry_extFile: %s checkExternalStateFile returned %d\n&quot;, pThis-&gt;pszName, iRet);
		if(iRet == RS_RET_OK) {
			DBGPRINTF(&quot;actionDoRetry_extFile: %s had success RDY again (iRet=%d)\n&quot;,
				  pThis-&gt;pszName, iRet);
			if(pThis-&gt;bReportSuspension) {
				LogMsg(0, RS_RET_RESUMED, LOG_INFO, &quot;action '%s' &quot;
				      &quot;resumed (module '%s') via external state file&quot;,
				      pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			}
			actionSetState(pThis, pWti, ACT_STATE_RDY);
		} else if(iRet == RS_RET_SUSPENDED) {
			/* max retries reached? */
			DBGPRINTF(&quot;actionDoRetry_extFile: %s check for max retries, iResumeRetryCount &quot;
				  &quot;%d, iRetries %d\n&quot;,
				  pThis-&gt;pszName, pThis-&gt;iResumeRetryCount, iRetries);
			if((pThis-&gt;iResumeRetryCount != -1 &amp;&amp; iRetries &gt;= pThis-&gt;iResumeRetryCount)) {
				DBGPRINTF(&quot;actionDoRetry_extFile: did not work out, suspending\n&quot;);
				actionSuspend(pThis, pWti);
				pWti-&gt;execState.bPrevWasSuspended = 1;
				if(getActionNbrResRtry(pWti, pThis) &lt; 20)
					incActionNbrResRtry(pWti, pThis);
			} else {
				++iRetries;
				iSleepPeriod = pThis-&gt;iResumeInterval;
				srSleep(iSleepPeriod, 0);
				if(*pWti-&gt;pbShutdownImmediate) {
					ABORT_FINALIZE(RS_RET_FORCE_TERM);
				}
			}
		} else if(iRet == RS_RET_DISABLE_ACTION) {
			actionDisable(pThis);
		}
	}

	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		setActionNbrResRtry(pWti, pThis, 0);
	}

finalize_it:
	RETiRet;
}

static rsRetVal
actionCheckAndCreateWrkrInstance(action_t * const pThis, const wti_t *const pWti)
{
	int locked = 0;
	DEFiRet;
	if(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData == NULL) {
		DBGPRINTF(&quot;wti %p: we need to create a new action worker instance for &quot;
			  &quot;action %d\n&quot;, pWti, pThis-&gt;iActionNbr);
		CHKiRet(pThis-&gt;pMod-&gt;mod.om.createWrkrInstance(&amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData),
						               pThis-&gt;pModData));
		pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].pAction = pThis;
		setActionState(pWti, pThis, ACT_STATE_RDY); /* action is enabled */

		/* maintain worker data table -- only needed if wrkrHUP is requested! */

		pthread_mutex_lock(&amp;pThis-&gt;mutWrkrDataTable);
		locked = 1;
		int freeSpot;
		for(freeSpot = 0 ; freeSpot &lt; pThis-&gt;wrkrDataTableSize ; ++freeSpot)
			if(pThis-&gt;wrkrDataTable[freeSpot] == NULL)
				break;
		if(pThis-&gt;nWrkr == pThis-&gt;wrkrDataTableSize) {
			void *const newTable = realloc(pThis-&gt;wrkrDataTable,
				(pThis-&gt;wrkrDataTableSize + 1) * sizeof(void*));
			if(newTable == NULL) {
				DBGPRINTF(&quot;actionCheckAndCreateWrkrInstance: out of &quot;
					&quot;memory realloc wrkrDataTable\n&quot;)
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
			pThis-&gt;wrkrDataTable = newTable;
			pThis-&gt;wrkrDataTableSize++;
		}
		pThis-&gt;wrkrDataTable[freeSpot] = pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData;
		pThis-&gt;nWrkr++;
		DBGPRINTF(&quot;wti %p: created action worker instance %d for &quot;
			  &quot;action %d\n&quot;, pWti, pThis-&gt;nWrkr, pThis-&gt;iActionNbr);
	}
finalize_it:
	if(locked) {
		pthread_mutex_unlock(&amp;pThis-&gt;mutWrkrDataTable);
	}
	RETiRet;
}

/* try to resume an action -- rgerhards, 2007-08-02
 * changed to new action state engine -- rgerhards, 2009-05-07
 */
static rsRetVal
actionTryResume(action_t * const pThis, wti_t * const pWti)
{
	DEFiRet;
	time_t ttNow = NO_TIME_PROVIDED;

	if(getActionState(pWti, pThis) == ACT_STATE_SUSP) {
		/* if we are suspended, we need to check if the timeout expired.
		 * for this handling, we must always obtain a fresh timestamp. We used
		 * to use the action timestamp, but in this case we will never reach a
		 * point where a resumption is actually tried, because the action timestamp
		 * is always in the past. So we can not avoid doing a fresh time() call
		 * here. -- rgerhards, 2009-03-18
		 */
		datetime.GetTime(&amp;ttNow); /* cache &quot;now&quot; */
		if(ttNow &gt;= pThis-&gt;ttResumeRtry) {
			actionSetState(pThis, pWti, ACT_STATE_RTRY); /* back to retries */
		}
	}

	if(getActionState(pWti, pThis) == ACT_STATE_RTRY) {
		CHKiRet(actionDoRetry(pThis, pWti));
	}

	if(Debug &amp;&amp; (getActionState(pWti, pThis) == ACT_STATE_RTRY ||
		getActionState(pWti, pThis) == ACT_STATE_SUSP)) {
		if(ttNow == NO_TIME_PROVIDED) /* use cached result if we have it */
			datetime.GetTime(&amp;ttNow);
		dbgprintf(&quot;actionTryResume: action[%s] state: %s, next retry (if applicable): %u [now %u]\n&quot;,
			pThis-&gt;pszName, getActStateName(pThis, pWti),
			(unsigned) pThis-&gt;ttResumeRtry, (unsigned) ttNow);
	}

finalize_it:
	RETiRet;
}


/* prepare an action for performing work. This involves trying to recover it,
 * depending on its current state.
 * rgerhards, 2009-05-07
 */
static rsRetVal ATTR_NONNULL()
actionPrepare(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	DEFiRet;

DBGPRINTF(&quot;actionPrepare[%s]: enter\n&quot;, pThis-&gt;pszName);
	CHKiRet(actionCheckAndCreateWrkrInstance(pThis, pWti));
	CHKiRet(actionTryResume(pThis, pWti));

	/* if we are now ready, we initialize the transaction and advance
	 * action state accordingly
	 */
	if(getActionState(pWti, pThis) == ACT_STATE_RDY) {
		iRet = checkExternalStateFile(pThis, pWti);
		if(iRet == RS_RET_SUSPENDED) {
			DBGPRINTF(&quot;actionPrepare[%s]: SUSPENDED via external state file, &quot;
				&quot;doing retry processing\n&quot;, pThis-&gt;pszName);
			CHKiRet(actionDoRetry_extFile(pThis, pWti));
		}
		iRet = pThis-&gt;pMod-&gt;mod.om.beginTransaction(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		switch(iRet) {
			case RS_RET_OK:
				actionSetState(pThis, pWti, ACT_STATE_ITX);
				break;
			case RS_RET_SUSPENDED:
				actionRetry(pThis, pWti);
				break;
			case RS_RET_DISABLE_ACTION:
				actionDisable(pThis);
				break;
			default:FINALIZE;
		}
	}

finalize_it:
	RETiRet;
}


/* prepare the calling parameters for doAction()
 * rgerhards, 2009-05-07
 */
static rsRetVal
prepareDoActionParams(action_t * __restrict__ const pAction,
		      wti_t * __restrict__ const pWti,
		      smsg_t *__restrict__ const pMsg,
		      struct syslogTime *ttNow)
{
	int i;
	struct json_object *json;
	actWrkrIParams_t *iparams;
	actWrkrInfo_t *__restrict__ pWrkrInfo;
	DEFiRet;

	pWrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr]);
	if(pAction-&gt;isTransactional) {
		CHKiRet(wtiNewIParam(pWti, pAction, &amp;iparams));
		for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
			CHKiRet(tplToString(pAction-&gt;ppTpl[i], pMsg,
					    &amp;actParam(iparams, pAction-&gt;iNumTpls, 0, i),
				            ttNow));
		}
	} else {
		for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
			switch(pAction-&gt;peParamPassing[i]) {
			case ACT_STRING_PASSING:
				CHKiRet(tplToString(pAction-&gt;ppTpl[i], pMsg,
					   &amp;(pWrkrInfo-&gt;p.nontx.actParams[i]),
					   ttNow));
				break;
			/* note: ARRAY_PASSING mode has been removed in 8.26.0; if it
			 * is ever needed again, it can be found in 8.25.0.
			 * rgerhards 2017-03-06
			 */
			case ACT_MSG_PASSING:
				pWrkrInfo-&gt;p.nontx.actParams[i].param = (void*) pMsg;
				break;
			case ACT_JSON_PASSING:
				CHKiRet(tplToJSON(pAction-&gt;ppTpl[i], pMsg, &amp;json, ttNow));
				pWrkrInfo-&gt;p.nontx.actParams[i].param = (void*) json;
				break;
			default:dbgprintf(&quot;software bug/error: unknown &quot;
				&quot;pAction-&gt;peParamPassing[%d] %d in prepareDoActionParams\n&quot;,
					  i, (int) pAction-&gt;peParamPassing[i]);
				break;
			}
		}
	}

finalize_it:
	RETiRet;
}


void
releaseDoActionParams(action_t *__restrict__ const pAction, wti_t *__restrict__ const pWti, int action_destruct)
{
	int j;
	actWrkrInfo_t *__restrict__ pWrkrInfo;

	pWrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr]);
	for(j = 0 ; j &lt; pAction-&gt;iNumTpls ; ++j) {
		if (action_destruct) {
			if (ACT_STRING_PASSING == pAction-&gt;peParamPassing[j]) {
				free(pWrkrInfo-&gt;p.nontx.actParams[j].param);
				pWrkrInfo-&gt;p.nontx.actParams[j].param = NULL;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenBuf = 0;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenStr = 0;
			}
		} else {
			switch(pAction-&gt;peParamPassing[j]) {
			case ACT_ARRAY_PASSING:
				LogError(0, RS_RET_ERR, &quot;plugin error: no longer supported &quot;
					&quot;ARRAY_PASSING mode is used (see action.c)&quot;);
				return;
			case ACT_JSON_PASSING:
				json_object_put((struct json_object*)
								pWrkrInfo-&gt;p.nontx.actParams[j].param);
				pWrkrInfo-&gt;p.nontx.actParams[j].param = NULL;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenBuf = 0;
				pWrkrInfo-&gt;p.nontx.actParams[j].lenStr = 0;
				break;
			case ACT_STRING_PASSING:
			case ACT_MSG_PASSING:
				/* no need to do anything with these */
				break;
			}
		}
	}

	return;
}


/* This is used in resume processing. We only finally know that a resume
 * worked when we have been able to actually process a messages. As such,
 * we need to do some cleanup and status tracking in that case.
 */
static void
actionSetActionWorked(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	setActionResumeInRow(pWti, pThis, 0);
}

static rsRetVal
handleActionExecResult(action_t *__restrict__ const pThis,
	wti_t *__restrict__ const pWti,
	const rsRetVal ret)
{
	DEFiRet;
	switch(ret) {
		case RS_RET_OK:
			actionCommitted(pThis, pWti);
			actionSetActionWorked(pThis, pWti); /* we had a successful call! */
			break;
		case RS_RET_DEFER_COMMIT:
			actionSetActionWorked(pThis, pWti); /* we had a successful call! */
			/* we are done, action state remains the same */
			break;
		case RS_RET_PREVIOUS_COMMITTED:
			/* action state remains the same, but we had a commit. */
			pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 1;
			actionSetActionWorked(pThis, pWti); /* we had a successful call! */
			break;
		case RS_RET_DISABLE_ACTION:
			actionDisable(pThis);
			break;
		case RS_RET_SUSPENDED:
			actionRetry(pThis, pWti);
			break;
		default:/* error happened - if it hits us here, we assume the message cannot
			 * be processed but an retry makes no sense. Usually, this should be
			 * return code RS_RET_DATAFAIL. -- rgerhards, 2017-10-06
			 */
			LogError(0, ret, &quot;action '%s' (module '%s') &quot;
				&quot;message lost, could not be processed. Check for &quot;
				&quot;additional error messages before this one.&quot;,
				pThis-&gt;pszName, pThis-&gt;pMod-&gt;pszName);
			actionSetState(pThis, pWti, ACT_STATE_DATAFAIL);
			break;
	}
	iRet = getReturnCode(pThis, pWti);

	RETiRet;
}

/* call the DoAction output plugin entry point
 * rgerhards, 2008-01-28
 */
static rsRetVal
actionCallDoAction(action_t *__restrict__ const pThis,
	actWrkrIParams_t *__restrict__ const iparams,
	wti_t *__restrict__ const pWti)
{
	void *param[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	int i;
	DEFiRet;

	DBGPRINTF(&quot;entering actionCalldoAction(), state: %s, actionNbr %d\n&quot;,
		  getActStateName(pThis, pWti), pThis-&gt;iActionNbr);

	pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].bHadAutoCommit = 0;
	/* for this interface, we need to emulate the old style way
	 * of parameter passing.
	 */
	for(i = 0 ; i &lt; pThis-&gt;iNumTpls ; ++i) {
		param[i] = actParam(iparams, pThis-&gt;iNumTpls, 0, i).param;
	}

	iRet = pThis-&gt;pMod-&gt;mod.om.doAction(param,
				            pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
	iRet = handleActionExecResult(pThis, pWti, iRet);
	RETiRet;
}


/* call the commitTransaction output plugin entry point */
static rsRetVal ATTR_NONNULL()
actionCallCommitTransaction(action_t * const pThis,
	wti_t *const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	DEFiRet;

	DBGPRINTF(&quot;entering actionCallCommitTransaction[%s], state: %s, nMsgs %u\n&quot;,
		  pThis-&gt;pszName, getActStateName(pThis, pWti), nparams);

	iRet = pThis-&gt;pMod-&gt;mod.om.commitTransaction(
		    pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData,
		    iparams, nparams);
	DBGPRINTF(&quot;actionCallCommitTransaction[%s] state: %s &quot;
		&quot;mod commitTransaction returned %d\n&quot;,
		pThis-&gt;pszName, getActStateName(pThis, pWti), iRet);
	iRet = handleActionExecResult(pThis, pWti, iRet);
	RETiRet;
}


/* process a message
 * this readies the action and then calls doAction()
 * rgerhards, 2008-01-28
 */
static rsRetVal
actionProcessMessage(action_t * const pThis, void *actParams, wti_t * const pWti)
{
	DEFiRet;

	CHKiRet(actionPrepare(pThis, pWti));
	if(pThis-&gt;pMod-&gt;mod.om.SetShutdownImmdtPtr != NULL)
		pThis-&gt;pMod-&gt;mod.om.SetShutdownImmdtPtr(pThis-&gt;pModData, pWti-&gt;pbShutdownImmediate);
	if(getActionState(pWti, pThis) == ACT_STATE_ITX)
		CHKiRet(actionCallDoAction(pThis, actParams, pWti));

	iRet = getReturnCode(pThis, pWti);
finalize_it:
	RETiRet;
}


/* the following function uses the new-style transactional interface */
static rsRetVal
doTransaction(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	actWrkrInfo_t *wrkrInfo;
	int i;
	DEFiRet;

	wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	if(pThis-&gt;pMod-&gt;mod.om.commitTransaction != NULL) {
		DBGPRINTF(&quot;doTransaction: have commitTransaction IF, using that, pWrkrInfo %p\n&quot;, wrkrInfo);
		CHKiRet(actionCallCommitTransaction(pThis, pWti, iparams, nparams));
	} else { /* note: this branch is for compatibility with old TX modules */
		DBGPRINTF(&quot;doTransaction: action '%s', currIParam %d\n&quot;,
			   pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam);
		for(i = 0 ; i &lt; nparams ; ++i) {
			/* Note: we provide the message's base iparam - actionProcessMessage()
			 * uses this as *base* address.
			 */
			iRet = actionProcessMessage(pThis,
				&amp;actParam(iparams, pThis-&gt;iNumTpls, i, 0), pWti);
			DBGPRINTF(&quot;doTransaction: action %d, processing msg %d, result %d\n&quot;,
			   pThis-&gt;iActionNbr, i,iRet);
			if(iRet == RS_RET_SUSPENDED) {
				--i; /* we need to re-submit */
				/* note: we are suspended and need to retry. In order not to
				 * hammer the CPU, we now do a voluntarly wait of 1 second.
				 * The rest will be handled by the standard retry handler.
				 */
				srSleep(1, 0);
			} else if(iRet != RS_RET_DEFER_COMMIT &amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED &amp;&amp;
			   iRet != RS_RET_OK) {
				FINALIZE; /* let upper peer handle the error condition! */
			}
		}
	}
finalize_it:
	if(iRet == RS_RET_DEFER_COMMIT || iRet == RS_RET_PREVIOUS_COMMITTED)
		iRet = RS_RET_OK; /* this is expected for transactional action! */
	RETiRet;
}


/* Commit try committing (do not handle retry processing and such) */
static rsRetVal ATTR_NONNULL()
actionTryCommit(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	DEFiRet;

	DBGPRINTF(&quot;actionTryCommit[%s] enter\n&quot;, pThis-&gt;pszName);
	CHKiRet(actionPrepare(pThis, pWti));

	CHKiRet(doTransaction(pThis, pWti, iparams, nparams));

	if(getActionState(pWti, pThis) == ACT_STATE_ITX) {
		iRet = pThis-&gt;pMod-&gt;mod.om.endTransaction(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].actWrkrData);
		switch(iRet) {
			case RS_RET_OK:
				actionCommitted(pThis, pWti);
				break;
			case RS_RET_SUSPENDED:
				actionRetry(pThis, pWti);
				break;
			case RS_RET_DISABLE_ACTION:
				actionDisable(pThis);
				break;
			case RS_RET_DEFER_COMMIT:
				DBGPRINTF(&quot;output plugin error: endTransaction() returns RS_RET_DEFER_COMMIT &quot;
					  &quot;- ignored\n&quot;);
				actionCommitted(pThis, pWti);
				break;
			case RS_RET_PREVIOUS_COMMITTED:
				DBGPRINTF(&quot;output plugin error: endTransaction() returns RS_RET_PREVIOUS_COMMITTED &quot;
					  &quot;- ignored\n&quot;);
				actionCommitted(pThis, pWti);
				break;
			default:/* permanent failure of this message - no sense in retrying. This is
				 * not yet handled (but easy TODO)
				 */
				DBGPRINTF(&quot;action[%s]: actionTryCommit receveived iRet %d\n&quot;,
					pThis-&gt;pszName, iRet);
				FINALIZE;
		}
	}
	iRet = getReturnCode(pThis, pWti);

finalize_it:
	RETiRet;
}

/* If a transcation failed, we write the error file (if configured).
 */
static void ATTR_NONNULL()
actionWriteErrorFile(action_t *__restrict__ const pThis, const rsRetVal ret,
	actWrkrIParams_t *__restrict__ const iparams, const int nparams)
{
	fjson_object *etry=NULL;
	int bNeedUnlock = 0;

	STATSCOUNTER_INC(pThis-&gt;ctrFail, pThis-&gt;mutCtrFail);

	if(pThis-&gt;pszErrFile == NULL) {
		DBGPRINTF(&quot;action %s: commit failed, no error file set, silently &quot;
			&quot;discarding %d messages\n&quot;, pThis-&gt;pszName, nparams);
		goto done;
	}

	DBGPRINTF(&quot;action %d commit failed, writing %u messages (%d tpls) to error file\n&quot;,
		pThis-&gt;iActionNbr, nparams, pThis-&gt;iNumTpls);

	pthread_mutex_lock(&amp;pThis-&gt;mutErrFile);
	bNeedUnlock = 1;

	if(pThis-&gt;fdErrFile == -1) {
		pThis-&gt;fdErrFile = open(pThis-&gt;pszErrFile,
					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
		if(pThis-&gt;fdErrFile == -1) {
			LogError(errno, RS_RET_ERR, &quot;action %s: error opening error file %s&quot;,
				pThis-&gt;pszName, pThis-&gt;pszErrFile);
			goto done;
		}
		if (pThis-&gt;maxErrFileSize &gt; 0) {
			struct stat statbuf;
			if (fstat(pThis-&gt;fdErrFile, &amp;statbuf) == -1) {
				LogError(errno, RS_RET_ERR, &quot;failed to fstat %s&quot;, pThis-&gt;pszErrFile);
				goto done;
			}
			pThis-&gt;currentErrFileSize = statbuf.st_size;
		}
	}

	for(int i = 0 ; i &lt; nparams ; ++i) {
		if((etry = fjson_object_new_object()) == NULL)
			goto done;
		fjson_object_object_add(etry, &quot;action&quot;, fjson_object_new_string((char*)pThis-&gt;pszName));
		fjson_object_object_add(etry, &quot;status&quot;, fjson_object_new_int(ret));
		for(int j = 0 ; j &lt; pThis-&gt;iNumTpls ; ++j) {
			char tplname[20];
			snprintf(tplname, sizeof(tplname), &quot;template%d&quot;, j);
			tplname[sizeof(tplname)-1] = '\0';
			fjson_object_object_add(etry, tplname,
				fjson_object_new_string((char*)actParam(iparams, 1, i, j).param));
		}

		char *const rendered = strdup((char*)fjson_object_to_json_string(etry));
		if(rendered == NULL)
			goto done;

		size_t toWrite = strlen(rendered) + 1;
		// Check if need to truncate the amount of bytes to write
		if (pThis-&gt;maxErrFileSize &gt; 0) {
			if (pThis-&gt;currentErrFileSize + toWrite &gt; pThis-&gt;maxErrFileSize) {
				// Truncate to the pending available
				toWrite = pThis-&gt;maxErrFileSize - pThis-&gt;currentErrFileSize;
			}
			pThis-&gt;currentErrFileSize += toWrite;
		}
		if(toWrite &gt; 0) {
			/* note: we use the '\0' inside the string to store a LF - we do not
			 * otherwise need it and it safes us a copy/realloc.
			 */
			rendered[toWrite-1] = '\n'; /* NO LONGER A STRING! */
			const ssize_t wrRet = write(pThis-&gt;fdErrFile, rendered, toWrite);
			if(wrRet != (ssize_t) toWrite) {
				LogError(errno, RS_RET_IO_ERROR,
					&quot;action %s: error writing errorFile %s, write returned %lld&quot;,
					pThis-&gt;pszName, pThis-&gt;pszErrFile, (long long) wrRet);
			}
		}
		free(rendered);

		fjson_object_put(etry);
		etry = NULL;
	}
done:
	if(bNeedUnlock) {
		pthread_mutex_unlock(&amp;pThis-&gt;mutErrFile);
	}
	fjson_object_put(etry);
	return;
}


static rsRetVal
actionTryRemoveHardErrorsFromBatch(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti,
	actWrkrIParams_t *const new_iparams, unsigned *new_nMsgs)
{
	actWrkrInfo_t *const wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	const unsigned nMsgs = wrkrInfo-&gt;p.tx.currIParam;
	actWrkrIParams_t oneParamSet[CONF_OMOD_NUMSTRINGS_MAXSIZE];
	rsRetVal ret;
	DEFiRet;

	*new_nMsgs = 0;
	for(unsigned i = 0 ; i &lt; nMsgs ; ++i) {
		setActionResumeInRow(pWti, pThis, 0); // make sure we do not trigger OK-as-SUSPEND handling
		memcpy(&amp;oneParamSet, &amp;actParam(wrkrInfo-&gt;p.tx.iparams, pThis-&gt;iNumTpls, i, 0),
			sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls);
		ret = actionTryCommit(pThis, pWti, oneParamSet, 1);
		if(ret == RS_RET_SUSPENDED) {
			memcpy(new_iparams + (*new_nMsgs * pThis-&gt;iNumTpls), &amp;oneParamSet,
				sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls);
			++(*new_nMsgs);
		} else if(ret != RS_RET_OK) {
			actionWriteErrorFile(pThis, ret, oneParamSet, 1);
		}
	}
	RETiRet;
}

/* Note: we currently need to return an iRet, as this is used in
 * direct mode. TODO: However, it may be worth further investigating this,
 * as it looks like there is no ultimate consumer of this code.
 * rgerhards, 2013-11-06
 */
static rsRetVal ATTR_NONNULL()
actionCommit(action_t *__restrict__ const pThis, wti_t *__restrict__ const pWti)
{
	actWrkrInfo_t *const wrkrInfo = &amp;(pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr]);
	/* Variables that permit us to override the batch of messages */
	unsigned nMsgs = 0;
	actWrkrIParams_t *iparams = NULL;
	int needfree_iparams = 0; // work-around for clang static analyzer false positive
	DEFiRet;

	DBGPRINTF(&quot;actionCommit[%s]: enter, %d msgs\n&quot;, pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam);
	if(!pThis-&gt;isTransactional || pWti-&gt;actWrkrInfo[pThis-&gt;iActionNbr].p.tx.currIParam == 0) {
		FINALIZE;
	} else if(getActionState(pWti, pThis) == ACT_STATE_SUSP) {
		/* if we are suspended, we already tried everything to recover the
		 * action - and failed. So all we can do here is write the error file.
		 */
		actionWriteErrorFile(pThis, iRet, wrkrInfo-&gt;p.tx.iparams, wrkrInfo-&gt;p.tx.currIParam);
		FINALIZE;
	}
	DBGPRINTF(&quot;actionCommit[%s]: processing...\n&quot;, pThis-&gt;pszName);

	/* we now do one try at commiting the whole batch. Usually, this will
	 * succeed. If so, we are happy and done. If not, we dig into the details
	 * of finding out if we have a non-temporary error and try to handle this
	 * as well as retry processing. Due to this logic we do a bit more retries
	 * than configured (if temporary failure), but this unavoidable and should
	 * do no real harm. - rgerhards, 2017-10-06
	 */
	iRet = actionTryCommit(pThis, pWti, wrkrInfo-&gt;p.tx.iparams, wrkrInfo-&gt;p.tx.currIParam);
DBGPRINTF(&quot;actionCommit[%s]: return actionTryCommit %d\n&quot;, pThis-&gt;pszName, iRet);
	if(iRet == RS_RET_OK) {
		FINALIZE;
	}

	/* check if this was a single-message batch. If it had a datafail error, we
	 * are done. If it is a multi-message batch, we need to sort out the individual
	 * message states.
	 */
	if(wrkrInfo-&gt;p.tx.currIParam == 1) {
		needfree_iparams = 0;
		iparams = wrkrInfo-&gt;p.tx.iparams;
		nMsgs = wrkrInfo-&gt;p.tx.currIParam;
		if(iRet == RS_RET_DATAFAIL) {
			FINALIZE;
		}
	} else {
		DBGPRINTF(&quot;actionCommit[%s]: somewhat unhappy, full batch of %d msgs returned &quot;
			&quot;status %d. Trying messages as individual actions.\n&quot;,
			pThis-&gt;pszName, wrkrInfo-&gt;p.tx.currIParam, iRet);
		CHKmalloc(iparams = malloc(sizeof(actWrkrIParams_t) * pThis-&gt;iNumTpls
			* wrkrInfo-&gt;p.tx.currIParam));
		needfree_iparams = 1;
		actionTryRemoveHardErrorsFromBatch(pThis, pWti, iparams, &amp;nMsgs);
	}

	if(nMsgs == 0) {
		ABORT_FINALIZE(RS_RET_OK); // here, we consider everyting OK
	}

	/* We still have some messages with suspend error. So now let's do our
	 * &quot;regular&quot; retry and suspend processing.
	 */
	DBGPRINTF(&quot;actionCommit[%s]: unhappy, we still have %d uncommitted messages.\n&quot;,
		pThis-&gt;pszName, nMsgs);
	int bDone = 0;
	do {
		iRet = actionTryCommit(pThis, pWti, iparams, nMsgs);
		DBGPRINTF(&quot;actionCommit[%s]: in retry loop, iRet %d\n&quot;,
			pThis-&gt;pszName, iRet);
		if(iRet == RS_RET_FORCE_TERM) {
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		} else if(iRet == RS_RET_SUSPENDED) {
			iRet = actionDoRetry(pThis, pWti);
			DBGPRINTF(&quot;actionCommit[%s]: actionDoRetry returned %d\n&quot;,
				pThis-&gt;pszName, iRet);
			if(iRet == RS_RET_FORCE_TERM) {
				ABORT_FINALIZE(RS_RET_FORCE_TERM);
			} else if(iRet != RS_RET_OK) {
				actionWriteErrorFile(pThis, iRet, iparams, nMsgs);
				bDone = 1;
			}
			continue;
		} else if(iRet == RS_RET_OK ||
		          iRet == RS_RET_SUSPENDED ||
			  iRet == RS_RET_ACTION_FAILED) {
			bDone = 1;
		}
		if(getActionState(pWti, pThis) == ACT_STATE_RDY  ||
		   getActionState(pWti, pThis) == ACT_STATE_SUSP) {
			bDone = 1;
		}
	} while(!bDone);
finalize_it:
	DBGPRINTF(&quot;actionCommit[%s]: done, iRet %d\n&quot;, pThis-&gt;pszName, iRet);
	if(needfree_iparams) {
		free(iparams);
	}
	wrkrInfo-&gt;p.tx.currIParam = 0; /* reset to beginning */
	RETiRet;
}

/* Commit all active transactions in *DIRECT mode* */
void ATTR_NONNULL()
actionCommitAllDirect(wti_t *__restrict__ const pWti)
{
	int i;
	action_t *pAction;

	for(i = 0 ; i &lt; runConf-&gt;actions.iActionNbr ; ++i) {
		pAction = pWti-&gt;actWrkrInfo[i].pAction;
		if(pAction == NULL)
			continue;
		DBGPRINTF(&quot;actionCommitAllDirect: action %d, state %u, nbr to commit %d &quot;
			  &quot;isTransactional %d\n&quot;,
			  i, getActionStateByNbr(pWti, i), pWti-&gt;actWrkrInfo-&gt;p.tx.currIParam,
			  pAction-&gt;isTransactional);
		if(pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT)
			actionCommit(pAction, pWti);
	}
}

/* process a single message. This is both called if we run from the
 * consumer side of an action queue as well as directly from the main
 * queue thread if the action queue is set to &quot;direct&quot;.
 */
static rsRetVal
processMsgMain(action_t *__restrict__ const pAction,
	wti_t *__restrict__ const pWti,
	smsg_t *__restrict__ const pMsg,
	struct syslogTime *ttNow)
{
	DEFiRet;

	CHKiRet(prepareDoActionParams(pAction, pWti, pMsg, ttNow));

	if(pAction-&gt;isTransactional) {
		pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr].pAction = pAction;
		DBGPRINTF(&quot;action '%s': is transactional - executing in commit phase\n&quot;, pAction-&gt;pszName);
		actionPrepare(pAction, pWti);
		iRet = getReturnCode(pAction, pWti);
		FINALIZE;
	}

	iRet = actionProcessMessage(pAction,
				    pWti-&gt;actWrkrInfo[pAction-&gt;iActionNbr].p.nontx.actParams,
				    pWti);
	if(pAction-&gt;bNeedReleaseBatch)
		releaseDoActionParams(pAction, pWti, 0);
finalize_it:
	if(iRet == RS_RET_OK) {
		if(pWti-&gt;execState.bDoAutoCommit)
			iRet = actionCommit(pAction, pWti);
	}
	RETiRet;
}

/* This entry point is called by the ACTION queue (not main queue!)
 */
static rsRetVal ATTR_NONNULL()
processBatchMain(void *__restrict__ const pVoid,
	batch_t *__restrict__ const pBatch,
	wti_t *__restrict__ const pWti)
{
	action_t *__restrict__ const pAction = (action_t*__restrict__ const) pVoid;
	int i;
	struct syslogTime ttNow;
	DEFiRet;

	wtiResetExecState(pWti, pBatch);
	/* indicate we have not yet read the date */
	ttNow.year = 0;

	for(i = 0 ; i &lt; batchNumMsgs(pBatch) &amp;&amp; !*pWti-&gt;pbShutdownImmediate ; ++i) {
		if(batchIsValidElem(pBatch, i)) {
			/* we do not check error state below, because aborting would be
			 * more harmful than continuing.
			 */
			rsRetVal localRet = processMsgMain(pAction, pWti, pBatch-&gt;pElem[i].pMsg, &amp;ttNow);
			DBGPRINTF(&quot;processBatchMain: i %d, processMsgMain iRet %d\n&quot;, i, localRet);
			if(   localRet == RS_RET_OK
			   || localRet == RS_RET_DEFER_COMMIT
			   || localRet == RS_RET_ACTION_FAILED
			   || localRet == RS_RET_PREVIOUS_COMMITTED ) {
				batchSetElemState(pBatch, i, BATCH_STATE_COMM);
				DBGPRINTF(&quot;processBatchMain: i %d, COMM state set\n&quot;, i);
			}
		}
	}

	iRet = actionCommit(pAction, pWti);
	RETiRet;
}


/* remove an action worker instance from our table of
 * workers. To be called from worker handler (wti).
 */
void
actionRemoveWorker(action_t *const __restrict__ pAction,
	void *const __restrict__ actWrkrData)
{
	pthread_mutex_lock(&amp;pAction-&gt;mutWrkrDataTable);
	pAction-&gt;nWrkr--;
	for(int w = 0 ; w &lt; pAction-&gt;wrkrDataTableSize ; ++w) {
		if(pAction-&gt;wrkrDataTable[w] == actWrkrData) {
			pAction-&gt;wrkrDataTable[w] = NULL;
			break; /* done */
		}
	}
	pthread_mutex_unlock(&amp;pAction-&gt;mutWrkrDataTable);
}


/* call the HUP handler for a given action, if such a handler is defined.
 * Note that the action must be able to service HUP requests concurrently
 * to any current doAction() processing.
 */
rsRetVal
actionCallHUPHdlr(action_t * const pAction)
{
	DEFiRet;

	assert(pAction != NULL);
	DBGPRINTF(&quot;Action %p checks HUP hdlr, act level: %p, wrkr level %p\n&quot;,
		pAction, pAction-&gt;pMod-&gt;doHUP, pAction-&gt;pMod-&gt;doHUPWrkr);

	if(pAction-&gt;pMod-&gt;doHUP != NULL) {
		CHKiRet(pAction-&gt;pMod-&gt;doHUP(pAction-&gt;pModData));
	}

	if(pAction-&gt;pMod-&gt;doHUPWrkr != NULL) {
		pthread_mutex_lock(&amp;pAction-&gt;mutWrkrDataTable);
		for(int i = 0 ; i &lt; pAction-&gt;wrkrDataTableSize ; ++i) {
			dbgprintf(&quot;HUP: table entry %d: %p %s\n&quot;, i,
				pAction-&gt;wrkrDataTable[i],
				pAction-&gt;wrkrDataTable[i] == NULL ? &quot;[unused]&quot; : &quot;&quot;);
			if(pAction-&gt;wrkrDataTable[i] != NULL) {
				const rsRetVal localRet
					= pAction-&gt;pMod-&gt;doHUPWrkr(pAction-&gt;wrkrDataTable[i]);
				if(localRet != RS_RET_OK) {
					DBGPRINTF(&quot;HUP handler returned error state %d - &quot;
						  &quot;ignored\n&quot;, localRet);
				}
			}
		}
		pthread_mutex_unlock(&amp;pAction-&gt;mutWrkrDataTable);
	}

finalize_it:
	RETiRet;
}


/* set the action message queue mode
 * TODO: probably move this into queue object, merge with MainMsgQueue!
 * rgerhards, 2008-01-28
 */
static rsRetVal setActionQueType(void __attribute__((unused)) *pVal, uchar *pszType)
{
	DEFiRet;

	if (!strcasecmp((char *) pszType, &quot;fixedarray&quot;)) {
		cs.ActionQueType = QUEUETYPE_FIXED_ARRAY;
		DBGPRINTF(&quot;action queue type set to FIXED_ARRAY\n&quot;);
	} else if (!strcasecmp((char *) pszType, &quot;linkedlist&quot;)) {
		cs.ActionQueType = QUEUETYPE_LINKEDLIST;
		DBGPRINTF(&quot;action queue type set to LINKEDLIST\n&quot;);
	} else if (!strcasecmp((char *) pszType, &quot;disk&quot;)) {
		cs.ActionQueType = QUEUETYPE_DISK;
		DBGPRINTF(&quot;action queue type set to DISK\n&quot;);
	} else if (!strcasecmp((char *) pszType, &quot;direct&quot;)) {
		cs.ActionQueType = QUEUETYPE_DIRECT;
		DBGPRINTF(&quot;action queue type set to DIRECT (no queueing at all)\n&quot;);
	} else {
		LogError(0, RS_RET_INVALID_PARAMS, &quot;unknown actionqueue parameter: %s&quot;, (char *) pszType);
		iRet = RS_RET_INVALID_PARAMS;
	}
	free(pszType); /* no longer needed */

	RETiRet;
}


/* This submits the message to the action queue in case we do NOT need to handle repeat
 * message processing. That case permits us to gain lots of freedom during processing
 * and thus speed. This is also utilized to submit messages in more complex cases once
 * the complex logic has been applied ;)
 * rgerhards, 2010-06-08
 */
static rsRetVal ATTR_NONNULL()
doSubmitToActionQ(action_t * const pAction, wti_t * const pWti, smsg_t *pMsg)
{
	struct syslogTime ttNow; // TODO: think if we can buffer this in pWti
	DEFiRet;

	DBGPRINTF(&quot;action '%s': called, logging to %s (susp %d/%d, direct q %d)\n&quot;,
		pAction-&gt;pszName, module.GetStateName(pAction-&gt;pMod),
		pAction-&gt;bExecWhenPrevSusp, pWti-&gt;execState.bPrevWasSuspended,
		pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT);

	if(   pAction-&gt;bExecWhenPrevSusp
	   &amp;&amp; !pWti-&gt;execState.bPrevWasSuspended) {
		DBGPRINTF(&quot;action '%s': NOT executing, as previous action was &quot;
			  &quot;not suspended\n&quot;, pAction-&gt;pszName);
		FINALIZE;
	}

	STATSCOUNTER_INC(pAction-&gt;ctrProcessed, pAction-&gt;mutCtrProcessed);
	if(pAction-&gt;pQueue-&gt;qType == QUEUETYPE_DIRECT) {
		ttNow.year = 0;
		iRet = processMsgMain(pAction, pWti, pMsg, &amp;ttNow);
	} else {/* in this case, we do single submits to the queue.
		 * TODO: optimize this, we may do at least a multi-submit!
		 */
		iRet = qqueueEnqMsg(pAction-&gt;pQueue, eFLOWCTL_NO_DELAY,
			pAction-&gt;bCopyMsg ? MsgDup(pMsg) : MsgAddRef(pMsg));
	}
	pWti-&gt;execState.bPrevWasSuspended =
		(iRet == RS_RET_SUSPENDED || iRet == RS_RET_ACTION_FAILED);

	if (iRet == RS_RET_ACTION_FAILED)	/* Increment failed counter */
		STATSCOUNTER_INC(pAction-&gt;ctrFail, pAction-&gt;mutCtrFail);

	DBGPRINTF(&quot;action '%s': set suspended state to %d\n&quot;,
		pAction-&gt;pszName, pWti-&gt;execState.bPrevWasSuspended);

finalize_it:
	RETiRet;
}


/* This function builds up a batch of messages to be (later)
 * submitted to the action queue.
 * Important: this function MUST not be called with messages that are to
 * be discarded due to their &quot;prevWasSuspended&quot; state. It will not check for
 * this and submit all messages to the queue for execution. So these must
 * be filtered out before calling us (what is done currently!).
 */
rsRetVal
actionWriteToAction(action_t * const pAction, smsg_t *pMsg, wti_t * const pWti)
{
	DEFiRet;

	/* first, we check if the action should actually be called. The action-specific
	 * $ActionExecOnlyEveryNthTime permits us to execute an action only every Nth
	 * time. So we need to check if we need to drop the (otherwise perfectly executable)
	 * action for this reason. Note that in case we need to drop it, we return RS_RET_OK
	 * as the action was properly &quot;passed to execution&quot; from the upper layer's point
	 * of view. -- rgerhards, 2008-08-07.
	 */
	if(pAction-&gt;iExecEveryNthOccur &gt; 1) {
		/* we need to care about multiple occurrences */
		if(   pAction-&gt;iExecEveryNthOccurTO &gt; 0
		   &amp;&amp; (getActNow(pAction) - pAction-&gt;tLastOccur) &gt; pAction-&gt;iExecEveryNthOccurTO) {
		  	DBGPRINTF(&quot;n-th occurrence handling timed out (%d sec), restarting from 0\n&quot;,
				  (int) (getActNow(pAction) - pAction-&gt;tLastOccur));
			pAction-&gt;iNbrNoExec = 0;
			pAction-&gt;tLastOccur = getActNow(pAction);
		   }
		if(pAction-&gt;iNbrNoExec &lt; pAction-&gt;iExecEveryNthOccur - 1) {
			++pAction-&gt;iNbrNoExec;
			DBGPRINTF(&quot;action %p passed %d times to execution - less than configured - discarding\n&quot;,
			  pAction, pAction-&gt;iNbrNoExec);
			FINALIZE;
		} else {
			pAction-&gt;iNbrNoExec = 0; /* we execute the action now, so the number of no execs is down to */
		}
	}

	DBGPRINTF(&quot;Called action(complex case), logging to %s\n&quot;, module.GetStateName(pAction-&gt;pMod));

	/* now check if we need to drop the message because otherwise the action would be too
	 * frequently called. -- rgerhards, 2008-04-08
	 * Note that the check for &quot;pAction-&gt;iSecsExecOnceInterval &gt; 0&quot; is not necessary from
	 * a purely logical point of view. However, if safes us to check the system time in
	 * (those common) cases where ExecOnceInterval is not used. -- rgerhards, 2008-09-16
	 */
	if(pAction-&gt;iSecsExecOnceInterval &gt; 0 &amp;&amp;
	   pAction-&gt;iSecsExecOnceInterval + pAction-&gt;tLastExec &gt; getActNow(pAction)) {
		/* in this case we need to discard the message - its not yet time to exec the action */
		DBGPRINTF(&quot;action not yet ready again to be executed, onceInterval %d, tCurr %d, tNext %d\n&quot;,
			  (int) pAction-&gt;iSecsExecOnceInterval, (int) getActNow(pAction),
			  (int) (pAction-&gt;iSecsExecOnceInterval + pAction-&gt;tLastExec));
		FINALIZE;
	}

	/* we use reception time, not dequeue time - this is considered more appropriate and also faster ;)
	 * rgerhards, 2008-09-17 */
	pAction-&gt;tLastExec = getActNow(pAction); /* re-init time flags */
	pAction-&gt;f_time = pMsg-&gt;ttGenTime;

	/* When we reach this point, we have a valid, non-disabled action.
	 * So let's enqueue our message for execution. -- rgerhards, 2007-07-24
	 */
	iRet = doSubmitToActionQ(pAction, pWti, pMsg);

finalize_it:
	RETiRet;
}


/* Call configured action, most complex case with all features supported (and thus slow).
 * rgerhards, 2010-06-08
 */

PRAGMA_DIAGNOSTIC_PUSH;
PRAGMA_IGNORE_Wempty_body;
static rsRetVal
doSubmitToActionQComplex(action_t * const pAction, wti_t * const pWti, smsg_t *pMsg)
{
	DEFiRet;

	d_pthread_mutex_lock(&amp;pAction-&gt;mutAction);
	pthread_cleanup_push(mutexCancelCleanup, &amp;pAction-&gt;mutAction);
	DBGPRINTF(&quot;Called action %p (complex case), logging to %s\n&quot;,
		  pAction, module.GetStateName(pAction-&gt;pMod));

	pAction-&gt;tActNow = -1; /* we do not yet know our current time (clear prev. value) */
	// TODO: can we optimize the &quot;now&quot; handling again (was batch, I guess...)?

	/* don't output marks to recently written outputs */
	if(pAction-&gt;bWriteAllMarkMsgs == 0
	   &amp;&amp; (pMsg-&gt;msgFlags &amp; MARK) &amp;&amp; (getActNow(pAction) - pAction-&gt;f_time) &lt; MarkInterval / 2) {
		ABORT_FINALIZE(RS_RET_OK);
	}

	/* call the output driver */
	iRet = actionWriteToAction(pAction, pMsg, pWti);

finalize_it:
	d_pthread_mutex_unlock(&amp;pAction-&gt;mutAction);
	pthread_cleanup_pop(0); /* remove mutex cleanup handler */

	RETiRet;
}
PRAGMA_DIAGNOSTIC_POP


/* helper to activateActions, it activates a specific action.
 */
DEFFUNC_llExecFunc(doActivateActions)
{
	rsRetVal localRet;
	action_t * const pThis = (action_t*) pData;
	localRet = qqueueStart(runConf, pThis-&gt;pQueue);
	if(localRet != RS_RET_OK) {
		LogError(0, localRet, &quot;error starting up action queue&quot;);
		if(localRet == RS_RET_FILE_PREFIX_MISSING) {
			LogError(0, localRet, &quot;file prefix (work directory?) &quot;
					&quot;is missing&quot;);
		}
		actionDisable(pThis);
	}
	DBGPRINTF(&quot;Action %s[%p]: queue %p started\n&quot;, modGetName(pThis-&gt;pMod),
		  pThis, pThis-&gt;pQueue);
	return RS_RET_OK; /* we ignore errors, we can not do anything either way */
}


/* This function &quot;activates&quot; the action after privileges have been dropped. Currently,
 * this means that the queues are started.
 * rgerhards, 2011-05-02
 */
rsRetVal
activateActions(void)
{
	DEFiRet;
	iRet = ruleset.IterateAllActions(runConf, doActivateActions, NULL);
	RETiRet;
}



/* This submits the message to the action queue in case where we need to handle
 * bWriteAllMarkMessage == RSFALSE only. Note that we use a non-blocking CAS loop
 * for the synchronization. Here, we just modify the filter condition to be false when
 * a mark message must not be written. However, in this case we must save the previous
 * filter as we may need it in the next action (potential future optimization: check if this is
 * the last action TODO).
 * rgerhards, 2010-06-08
 */
static rsRetVal
doSubmitToActionQNotAllMark(action_t * const pAction, wti_t * const pWti, smsg_t * const pMsg)
{
	int doProcess = 1;
	time_t lastAct;
	DEFiRet;

	/* TODO: think about the whole logic. If messages come in out of order, things
	 * tend to become a bit unreliable. On the other hand, this only happens if we have
	 * very high traffic, in which this use case here is not really affected (as the
	 * MarkInterval is pretty corase).
	 */
	/* CAS loop, we write back a bit early, but that's OK... */
	/* we use reception time, not dequeue time - this is considered more appropriate and
	 * also faster ;) -- rgerhards, 2008-09-17 */
	do {
		lastAct = pAction-&gt;f_time;
		if(pMsg-&gt;msgFlags &amp; MARK) {
			if((pMsg-&gt;ttGenTime - lastAct) &lt; MarkInterval / 2) {
				doProcess = 0;
				DBGPRINTF(&quot;action was recently called, ignoring mark message\n&quot;);
				break; /* do not update timestamp for non-written mark messages */
			}
		}
	} while(ATOMIC_CAS_time_t(&amp;pAction-&gt;f_time, lastAct,
		pMsg-&gt;ttGenTime, &amp;pAction-&gt;mutCAS) == 0);

	if(doProcess) {
		DBGPRINTF(&quot;Called action(NotAllMark), processing via '%s'\n&quot;,
			  module.GetStateName(pAction-&gt;pMod));
		iRet = doSubmitToActionQ(pAction, pWti, pMsg);
	}

	RETiRet;
}


/* apply all params from param block to action. This supports the v6 config system.
 * Defaults must have been set appropriately during action construct!
 * rgerhards, 2011-08-01
 */
static rsRetVal
actionApplyCnfParam(action_t * const pAction, struct cnfparamvals * const pvals)
{
	int i;

	for(i = 0 ; i &lt; pblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(pblk.descr[i].name, &quot;name&quot;)) {
			pAction-&gt;pszName = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, &quot;type&quot;)) {
			continue; /* this is handled seperately during module select! */
		} else if(!strcmp(pblk.descr[i].name, &quot;action.errorfile&quot;)) {
			pAction-&gt;pszErrFile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(pblk.descr[i].name, &quot;action.errorfile.maxsize&quot;)) {
<A NAME="1"></A>			pAction-&gt;maxErrFileSize = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.externalstate.file&quot;)) {
			pAction-&gt;pszExternalStateFile = es_str2cstr(pvals[i].val.d.estr, NULL);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2526-0.html#1',2,'match2526-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(pblk.descr[i].name, &quot;action.writeallmarkmessages&quot;)) {
			pAction-&gt;bWriteAllMarkMsgs = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.execonlyeverynthtime&quot;)) {
			pAction-&gt;iExecEveryNthOccur = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.execonlyeverynthtimetimeout&quot;)) {
			pAction-&gt;iExecEveryNthOccurTO = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.execonlyonceeveryinterval&quot;)) {</B></FONT>
			pAction-&gt;iSecsExecOnceInterval = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.execonlywhenpreviousissuspended&quot;)) {
			pAction-&gt;bExecWhenPrevSusp = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.repeatedmsgcontainsoriginalmsg&quot;)) {
			pAction-&gt;bRepMsgHasMsg = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.resumeretrycount&quot;)) {
			pAction-&gt;iResumeRetryCount = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.reportsuspension&quot;)) {
			pAction-&gt;bReportSuspension = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.reportsuspensioncontinuation&quot;)) {
			pAction-&gt;bReportSuspensionCont = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.copymsg&quot;)) {
			pAction-&gt;bCopyMsg = (int) pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.resumeinterval&quot;)) {
			pAction-&gt;iResumeInterval = pvals[i].val.d.n;
		} else if(!strcmp(pblk.descr[i].name, &quot;action.resumeintervalMax&quot;)) {
			pAction-&gt;iResumeIntervalMax = pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;action: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, pblk.descr[i].name);
		}
	}
	return RS_RET_OK;
}


/* add an Action to the current selector
 * The pOMSR is freed, as it is not needed after this function.
 * Note: this function pulls global data that specifies action config state.
 * rgerhards, 2007-07-27
 */
rsRetVal
addAction(action_t **ppAction, modInfo_t *pMod, void *pModData,
	  omodStringRequest_t *pOMSR, struct cnfparamvals *actParams,
	  struct nvlst * const lst)
{
	DEFiRet;
	int i;
	int iTplOpts;
	uchar *pTplName;
	action_t *pAction;
	char errMsg[512];

	assert(ppAction != NULL);
	assert(pMod != NULL);
	assert(pOMSR != NULL);
	DBGPRINTF(&quot;Module %s processes this action.\n&quot;, module.GetName(pMod));

	CHKiRet(actionConstruct(&amp;pAction)); /* create action object first */
	pAction-&gt;pMod = pMod;
	pAction-&gt;pModData = pModData;
	if(actParams == NULL) { /* use legacy systemn */
		pAction-&gt;pszName = cs.pszActionName;
		pAction-&gt;iResumeInterval = cs.glbliActionResumeInterval;
		pAction-&gt;iResumeRetryCount = cs.glbliActionResumeRetryCount;
		pAction-&gt;bWriteAllMarkMsgs = cs.bActionWriteAllMarkMsgs;
		pAction-&gt;bExecWhenPrevSusp = cs.bActExecWhenPrevSusp;
		pAction-&gt;iSecsExecOnceInterval = cs.iActExecOnceInterval;
		pAction-&gt;iExecEveryNthOccur = cs.iActExecEveryNthOccur;
		pAction-&gt;iExecEveryNthOccurTO = cs.iActExecEveryNthOccurTO;
		pAction-&gt;bRepMsgHasMsg = cs.bActionRepMsgHasMsg;
		cs.iActExecEveryNthOccur = 0; /* auto-reset */
		cs.iActExecEveryNthOccurTO = 0; /* auto-reset */
		cs.bActionWriteAllMarkMsgs = 1; /* auto-reset */
		cs.pszActionName = NULL;	/* free again! */
	} else {
		actionApplyCnfParam(pAction, actParams);
	}

	/* check if we can obtain the template pointers - TODO: move to separate function? */
	pAction-&gt;iNumTpls = OMSRgetEntryCount(pOMSR);
	assert(pAction-&gt;iNumTpls &gt;= 0); /* only debug check because this &quot;can not happen&quot; */
	/* please note: iNumTpls may validly be zero. This is the case if the module
	 * does not request any templates. This sounds unlikely, but an actual example is
	 * the discard action, which does not require a string. -- rgerhards, 2007-07-30
	 */
	if(pAction-&gt;iNumTpls &gt; 0) {
		/* we first need to create the template arrays */
		CHKmalloc(pAction-&gt;ppTpl = (struct template **)calloc(pAction-&gt;iNumTpls, sizeof(struct template *)));
		CHKmalloc(pAction-&gt;peParamPassing = (paramPassing_t*)calloc(pAction-&gt;iNumTpls,
			sizeof(paramPassing_t)));
	}

	pAction-&gt;bUsesMsgPassingMode = 0;
	pAction-&gt;bNeedReleaseBatch = 0;
	for(i = 0 ; i &lt; pAction-&gt;iNumTpls ; ++i) {
		CHKiRet(OMSRgetEntry(pOMSR, i, &amp;pTplName, &amp;iTplOpts));
		/* Ok, we got everything, so it now is time to look up the template
		 * (Hint: templates MUST be defined before they are used!)
		 */
		if(!(iTplOpts &amp; OMSR_TPL_AS_MSG)) {
		   	if((pAction-&gt;ppTpl[i] =
				tplFind(loadConf, (char*)pTplName, strlen((char*)pTplName))) == NULL) {
				snprintf(errMsg, sizeof(errMsg),
					 &quot; Could not find template %d '%s' - action disabled&quot;,
					 i, pTplName);
				errno = 0;
				LogError(0, RS_RET_NOT_FOUND, &quot;%s&quot;, errMsg);
				ABORT_FINALIZE(RS_RET_NOT_FOUND);
			}
			/* check required template options */
			if(   (iTplOpts &amp; OMSR_RQD_TPL_OPT_SQL)
			   &amp;&amp; (pAction-&gt;ppTpl[i]-&gt;optFormatEscape == 0)) {
				errno = 0;
				LogError(0, RS_RET_RQD_TPLOPT_MISSING, &quot;Action disabled.&quot;
						&quot; To use this action, you have to specify &quot;
						&quot;the SQL or stdSQL option in your template!\n&quot;);
				ABORT_FINALIZE(RS_RET_RQD_TPLOPT_MISSING);
			}
		}

		/* set parameter-passing mode */
		if(iTplOpts &amp; OMSR_TPL_AS_ARRAY) {
			ABORT_FINALIZE(RS_RET_ERR);
		} else if(iTplOpts &amp; OMSR_TPL_AS_MSG) {
			pAction-&gt;peParamPassing[i] = ACT_MSG_PASSING;
			pAction-&gt;bUsesMsgPassingMode = 1;
		} else if(iTplOpts &amp; OMSR_TPL_AS_JSON) {
			pAction-&gt;peParamPassing[i] = ACT_JSON_PASSING;
			pAction-&gt;bNeedReleaseBatch = 1;
		} else {
			pAction-&gt;peParamPassing[i] = ACT_STRING_PASSING;
		}

		DBGPRINTF(&quot;template: '%s' assigned\n&quot;, pTplName);
	}

	pAction-&gt;pMod = pMod;
	pAction-&gt;pModData = pModData;

	CHKiRet(actionConstructFinalize(pAction, lst));

	*ppAction = pAction; /* finally store the action pointer */

finalize_it:
	if(iRet == RS_RET_OK)
		iRet = OMSRdestruct(pOMSR);
	else {
		/* do not overwrite error state! */
		OMSRdestruct(pOMSR);
		if(pAction != NULL)
			actionDestruct(pAction);
	}

	RETiRet;
}


/* Reset config variables to default values.
 * rgerhards, 2009-11-12
 */
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	cs.iActExecOnceInterval = 0;
	cs.bActExecWhenPrevSusp = 0;
	return RS_RET_OK;
}


/* initialize (current) config variables.
 * Used at program start and when a new scope is created.
 */
static void
initConfigVariables(void)
{
	cs.bActionWriteAllMarkMsgs = 1;
	cs.glbliActionResumeRetryCount = 0;
	cs.bActExecWhenPrevSusp = 0;
	cs.iActExecOnceInterval = 0;
	cs.iActExecEveryNthOccur = 0;
	cs.iActExecEveryNthOccurTO = 0;
	cs.glbliActionResumeInterval = 30;
	cs.glbliActionResumeRetryCount = 0;
	cs.bActionRepMsgHasMsg = 0;
	if(cs.pszActionName != NULL) {
		free(cs.pszActionName);
		cs.pszActionName = NULL;
	}
	actionResetQueueParams();
}


rsRetVal
actionNewInst(struct nvlst *lst, action_t **ppAction)
{
	struct cnfparamvals *paramvals;
	modInfo_t *pMod;
	uchar *cnfModName = NULL;
	omodStringRequest_t *pOMSR;
	void *pModData;
	action_t *pAction;
	DEFiRet;

	paramvals = nvlstGetParams(lst, &amp;pblk, NULL);
	if(paramvals == NULL) {
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	dbgprintf(&quot;action param blk after actionNewInst:\n&quot;);
	cnfparamsPrint(&amp;pblk, paramvals);
	cnfModName = (uchar*)es_str2cstr(paramvals[cnfparamGetIdx(&amp;pblk, (&quot;type&quot;))].val.d.estr, NULL);
	if((pMod = module.FindWithCnfName(loadConf, cnfModName, eMOD_OUT)) == NULL) {
		LogError(0, RS_RET_MOD_UNKNOWN, &quot;module name '%s' is unknown&quot;, cnfModName);
		ABORT_FINALIZE(RS_RET_MOD_UNKNOWN);
	}
	CHKiRet(pMod-&gt;mod.om.newActInst(cnfModName, lst, &amp;pModData, &amp;pOMSR));

	if((iRet = addAction(&amp;pAction, pMod, pModData, pOMSR, paramvals, lst)) == RS_RET_OK) {
		/* check if the module is compatible with select features
		 * (currently no such features exist) */
		loadConf-&gt;actions.nbrActions++;	/* one more active action! */
		*ppAction = pAction;
	} else {
		// TODO: cleanup
	}

finalize_it:
	free(cnfModName);
	cnfparamvalsDestruct(paramvals, &amp;pblk);
	RETiRet;
}

rsRetVal actionClassInit(void)
{
	DEFiRet;
	/* request objects we use */
	CHKiRet(objGetObjInterface(&amp;obj)); /* this provides the root pointer for all other queries */
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	CHKiRet(objUse(module, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));

	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionname&quot;, 0, eCmdHdlrGetWord, NULL, &amp;cs.pszActionName, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuefilename&quot;, 0, eCmdHdlrGetWord, NULL,
		&amp;cs.pszActionQFName, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuesize&quot;, 0, eCmdHdlrInt, NULL, &amp;cs.iActionQueueSize,
		NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionwriteallmarkmessages&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionWriteAllMarkMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuedequeuebatchsize&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqBatchSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuemaxdiskspace&quot;, 0, eCmdHdlrSize, NULL,
		&amp;cs.iActionQueMaxDiskSpace, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuehighwatermark&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQHighWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuelowwatermark&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQLowWtrMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuediscardmark&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQDiscardMark, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuediscardseverity&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQDiscardSeverity, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuecheckpointinterval&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQPersistUpdCnt, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuesyncqueuefiles&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionQSyncQeueFiles, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuetype&quot;, 0, eCmdHdlrGetWord, setActionQueType, NULL, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueueworkerthreads&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueNumWorkers, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuetimeoutshutdown&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoQShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuetimeoutactioncompletion&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoActShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuetimeoutenqueue&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoEnq, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueueworkertimeoutthreadshutdown&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQtoWrkShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueueworkerthreadminimummessages&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQWrkMinMsgs, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuemaxfilesize&quot;, 0, eCmdHdlrSize, NULL,
		&amp;cs.iActionQueMaxFileSize, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuesaveonshutdown&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionQSaveOnShutdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuedequeueslowdown&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqSlowdown, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuedequeuetimebegin&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqtWinFromHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionqueuedequeuetimeend&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActionQueueDeqtWinToHr, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionexeconlyeverynthtime&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecEveryNthOccur, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionexeconlyeverynthtimetimeout&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecEveryNthOccurTO, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionexeconlyonceeveryinterval&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.iActExecOnceInterval, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;repeatedmsgcontainsoriginalmsg&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActionRepMsgHasMsg, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionexeconlywhenpreviousissuspended&quot;, 0, eCmdHdlrBinary, NULL,
		&amp;cs.bActExecWhenPrevSusp, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;actionresumeretrycount&quot;, 0, eCmdHdlrInt, NULL,
		&amp;cs.glbliActionResumeRetryCount, NULL));
	CHKiRet(regCfSysLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, NULL));

	initConfigVariables(); /* first-time init of config setings */

finalize_it:
	RETiRet;
}

/* vi:set ai:
 */
</PRE>
</div>
  </div>
</body>
</html>
