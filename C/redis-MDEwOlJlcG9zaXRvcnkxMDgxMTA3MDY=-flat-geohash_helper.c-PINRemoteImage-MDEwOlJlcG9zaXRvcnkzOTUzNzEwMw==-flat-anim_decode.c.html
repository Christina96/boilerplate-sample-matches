
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.800312012480499%, Tokens: 8</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-geohash_helper.c</h3>
            <pre><code>1  #include "geohash_helper.h"
2  #ifdef _WIN32
3  #define inline __inline
4  #define _USE_MATH_DEFINES 
5  #include <math.h>
6  #endif
7  #define D_R (M_PI / 180.0)
8  #define R_MAJOR 6378137.0
9  #define R_MINOR 6356752.3142
10  #define RATIO (R_MINOR / R_MAJOR)
11  #define ECCENT (sqrt(1.0 - (RATIO *RATIO)))
12  #define COM (0.5 * ECCENT)
13  const double DEG_TO_RAD = 0.017453292519943295769236907684886;
14  const double EARTH_RADIUS_IN_METERS = 6372797.560856;
15  const double MERCATOR_MAX = 20037726.37;
16  const double MERCATOR_MIN = -20037726.37;
17  static inline double deg_rad(double ang) { return ang * D_R; }
18  static inline double rad_deg(double ang) { return ang / D_R; }
19  uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
20      if (range_meters == 0) return 26;
21      int step = 1;
22      while (range_meters < MERCATOR_MAX) {
23          range_meters *= 2;
24          step++;
25      }
26      step -= 2; &bsol;* Make sure range is included in the worst case. */
27      if (lat > 67 || lat < -67) step--;
28      if (lat > 80 || lat < -80) step--;
29      if (step < 1) step = 1;
30      if (step > 26) step = 26;
31      return step;
32  }
33  int geohashBitsComparator(const GeoHashBits *a, const GeoHashBits *b) {
34      return a->step != b->step ? a->step - b->step : a->bits - b->bits;
35  }
36  int geohashBoundingBox(double longitude, double latitude, double radius_meters,
37                         double *bounds) {
38      if (!bounds) return 0;
39      double lonr, latr;
40      lonr = deg_rad(longitude);
41      latr = deg_rad(latitude);
42      if (radius_meters > EARTH_RADIUS_IN_METERS)
43          radius_meters = EARTH_RADIUS_IN_METERS;
44      double distance = radius_meters / EARTH_RADIUS_IN_METERS;
45      double min_latitude = latr - distance;
46      double max_latitude = latr + distance;
47      double min_longitude, max_longitude;
48      double difference_longitude = asin(sin(distance) / cos(latr));
49      min_longitude = lonr - difference_longitude;
50      max_longitude = lonr + difference_longitude;
51      bounds[0] = rad_deg(min_longitude);
52      bounds[1] = rad_deg(min_latitude);
53      bounds[2] = rad_deg(max_longitude);
54      bounds[3] = rad_deg(max_latitude);
55      return 1;
56  }
57  GeoHashRadius geohashGetAreasByRadius(double longitude, double latitude, double radius_meters) {
58      GeoHashRange long_range, lat_range;
59      GeoHashRadius radius = { { 0 } };
60      GeoHashBits hash = { 0 };
61      GeoHashNeighbors neighbors = { { 0 } };
62      GeoHashArea area = { { 0 } };
63      double min_lon, max_lon, min_lat, max_lat;
64      double bounds[4];
65      int steps;
66      geohashBoundingBox(longitude, latitude, radius_meters, bounds);
67      min_lon = bounds[0];
68      min_lat = bounds[1];
69      max_lon = bounds[2];
70      max_lat = bounds[3];
71      steps = geohashEstimateStepsByRadius(radius_meters,latitude);
72      geohashGetCoordRange(&long_range, &lat_range);
73      geohashEncode(&long_range, &lat_range, longitude, latitude, steps, &hash);
74      geohashNeighbors(&hash, &neighbors);
75      geohashGetCoordRange(&long_range, &lat_range);
76      geohashDecode(long_range, lat_range, hash, &area);
77      if (area.latitude.min < min_lat) {
78          GZERO(neighbors.south);
79          GZERO(neighbors.south_west);
80          GZERO(neighbors.south_east);
81      }
82      if (area.latitude.max > max_lat) {
83          GZERO(neighbors.north);
84          GZERO(neighbors.north_east);
85          GZERO(neighbors.north_west);
86      }
87      if (area.longitude.min < min_lon) {
88          GZERO(neighbors.west);
89          GZERO(neighbors.south_west);
90          GZERO(neighbors.north_west);
91      }
92      if (area.longitude.max > max_lon) {
93          GZERO(neighbors.east);
94          GZERO(neighbors.south_east);
95          GZERO(neighbors.north_east);
96      }
97      radius.hash = hash;
98      radius.neighbors = neighbors;
99      radius.area = area;
100      return radius;
101  }
102  GeoHashRadius geohashGetAreasByRadiusWGS84(double longitude, double latitude,
103                                             double radius_meters) {
104      return geohashGetAreasByRadius(longitude, latitude, radius_meters);
105  }
106  GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash) {
107      uint64_t bits = hash.bits;
108      bits <<= (52 - hash.step * 2);
109      return bits;
110  }
<span onclick='openModal()' class='match'>111  double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {
112      double lat1r, lon1r, lat2r, lon2r, u, v;
113      lat1r = deg_rad(lat1d);
</span>114      lon1r = deg_rad(lon1d);
115      lat2r = deg_rad(lat2d);
116      lon2r = deg_rad(lon2d);
117      u = sin((lat2r - lat1r) / 2);
118      v = sin((lon2r - lon1r) / 2);
119      return 2.0 * EARTH_RADIUS_IN_METERS *
120             asin(sqrt(u * u + cos(lat1r) * cos(lat2r) * v * v));
121  }
122  int geohashGetDistanceIfInRadius(double x1, double y1,
123                                   double x2, double y2, double radius,
124                                   double *distance) {
125      *distance = geohashGetDistance(x1, y1, x2, y2);
126      if (*distance > radius) return 0;
127      return 1;
128  }
129  int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
130                                        double y2, double radius,
131                                        double *distance) {
132      return geohashGetDistanceIfInRadius(x1, y1, x2, y2, radius, distance);
133  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_decode.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "src/webp/config.h"
3  #endif
4  #include <assert.h>
5  #include <string.h>
6  #include "src/utils/utils.h"
7  #include "src/webp/decode.h"
8  #include "src/webp/demux.h"
9  #define NUM_CHANNELS 4
10  typedef void (*BlendRowFunc)(uint32_t* const, const uint32_t* const, int);
11  static void BlendPixelRowNonPremult(uint32_t* const src,
12                                      const uint32_t* const dst, int num_pixels);
13  static void BlendPixelRowPremult(uint32_t* const src, const uint32_t* const dst,
14                                   int num_pixels);
15  struct WebPAnimDecoder {
16    WebPDemuxer* demux_;             
17    WebPDecoderConfig config_;       
18    BlendRowFunc blend_func_;        
19    WebPAnimInfo info_;              
20    uint8_t* curr_frame_;            
21    uint8_t* prev_frame_disposed_;   
22    int prev_frame_timestamp_;       
23    WebPIterator prev_iter_;         
24    int prev_frame_was_keyframe_;    
25    int next_frame_;                 
26  };
27  static void DefaultDecoderOptions(WebPAnimDecoderOptions* const dec_options) {
28    dec_options->color_mode = MODE_RGBA;
29    dec_options->use_threads = 0;
30  }
31  int WebPAnimDecoderOptionsInitInternal(WebPAnimDecoderOptions* dec_options,
32                                         int abi_version) {
33    if (dec_options == NULL ||
34        WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_DEMUX_ABI_VERSION)) {
35      return 0;
36    }
37    DefaultDecoderOptions(dec_options);
38    return 1;
39  }
40  static int ApplyDecoderOptions(const WebPAnimDecoderOptions* const dec_options,
41                                 WebPAnimDecoder* const dec) {
42    WEBP_CSP_MODE mode;
43    WebPDecoderConfig* config = &dec->config_;
44    assert(dec_options != NULL);
45    mode = dec_options->color_mode;
46    if (mode != MODE_RGBA && mode != MODE_BGRA &&
47        mode != MODE_rgbA && mode != MODE_bgrA) {
48      return 0;
49    }
50    dec->blend_func_ = (mode == MODE_RGBA || mode == MODE_BGRA)
51                           ? &BlendPixelRowNonPremult
52                           : &BlendPixelRowPremult;
53    WebPInitDecoderConfig(config);
54    config->output.colorspace = mode;
55    config->output.is_external_memory = 1;
56    config->options.use_threads = dec_options->use_threads;
57    return 1;
58  }
59  WebPAnimDecoder* WebPAnimDecoderNewInternal(
60      const WebPData* webp_data, const WebPAnimDecoderOptions* dec_options,
61      int abi_version) {
62    WebPAnimDecoderOptions options;
63    WebPAnimDecoder* dec = NULL;
64    if (webp_data == NULL ||
65        WEBP_ABI_IS_INCOMPATIBLE(abi_version, WEBP_DEMUX_ABI_VERSION)) {
66      return NULL;
67    }
68    dec = (WebPAnimDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
69    if (dec == NULL) goto Error;
70    if (dec_options != NULL) {
71      options = *dec_options;
72    } else {
73      DefaultDecoderOptions(&options);
74    }
75    if (!ApplyDecoderOptions(&options, dec)) goto Error;
76    dec->demux_ = WebPDemux(webp_data);
77    if (dec->demux_ == NULL) goto Error;
78    dec->info_.canvas_width = WebPDemuxGetI(dec->demux_, WEBP_FF_CANVAS_WIDTH);
79    dec->info_.canvas_height = WebPDemuxGetI(dec->demux_, WEBP_FF_CANVAS_HEIGHT);
80    dec->info_.loop_count = WebPDemuxGetI(dec->demux_, WEBP_FF_LOOP_COUNT);
81    dec->info_.bgcolor = WebPDemuxGetI(dec->demux_, WEBP_FF_BACKGROUND_COLOR);
82    dec->info_.frame_count = WebPDemuxGetI(dec->demux_, WEBP_FF_FRAME_COUNT);
83    dec->curr_frame_ = (uint8_t*)WebPSafeCalloc(
84        dec->info_.canvas_width * NUM_CHANNELS, dec->info_.canvas_height);
85    if (dec->curr_frame_ == NULL) goto Error;
86    dec->prev_frame_disposed_ = (uint8_t*)WebPSafeCalloc(
87        dec->info_.canvas_width * NUM_CHANNELS, dec->info_.canvas_height);
88    if (dec->prev_frame_disposed_ == NULL) goto Error;
89    WebPAnimDecoderReset(dec);
90    return dec;
91   Error:
92    WebPAnimDecoderDelete(dec);
93    return NULL;
94  }
95  int WebPAnimDecoderGetInfo(const WebPAnimDecoder* dec, WebPAnimInfo* info) {
96    if (dec == NULL || info == NULL) return 0;
97    *info = dec->info_;
98    return 1;
99  }
100  static int IsFullFrame(int width, int height, int canvas_width,
101                         int canvas_height) {
102    return (width == canvas_width && height == canvas_height);
103  }
104  static int ZeroFillCanvas(uint8_t* buf, uint32_t canvas_width,
105                            uint32_t canvas_height) {
106    const uint64_t size =
107        (uint64_t)canvas_width * canvas_height * NUM_CHANNELS * sizeof(*buf);
108    if (size != (size_t)size) return 0;
109    memset(buf, 0, (size_t)size);
110    return 1;
111  }
<span onclick='openModal()' class='match'>112  static void ZeroFillFrameRect(uint8_t* buf, int buf_stride, int x_offset,
113                                int y_offset, int width, int height) {
114    int j;
115    assert(width * NUM_CHANNELS <= buf_stride);
116    buf += y_offset * buf_stride + x_offset * NUM_CHANNELS;
</span>117    for (j = 0; j < height; ++j) {
118      memset(buf, 0, width * NUM_CHANNELS);
119      buf += buf_stride;
120    }
121  }
122  static int CopyCanvas(const uint8_t* src, uint8_t* dst,
123                        uint32_t width, uint32_t height) {
124    const uint64_t size = (uint64_t)width * height * NUM_CHANNELS;
125    if (size != (size_t)size) return 0;
126    assert(src != NULL && dst != NULL);
127    memcpy(dst, src, (size_t)size);
128    return 1;
129  }
130  static int IsKeyFrame(const WebPIterator* const curr,
131                        const WebPIterator* const prev,
132                        int prev_frame_was_key_frame,
133                        int canvas_width, int canvas_height) {
134    if (curr->frame_num == 1) {
135      return 1;
136    } else if ((!curr->has_alpha || curr->blend_method == WEBP_MUX_NO_BLEND) &&
137               IsFullFrame(curr->width, curr->height,
138                           canvas_width, canvas_height)) {
139      return 1;
140    } else {
141      return (prev->dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) &&
142             (IsFullFrame(prev->width, prev->height, canvas_width,
143                          canvas_height) ||
144              prev_frame_was_key_frame);
145    }
146  }
147  static uint8_t BlendChannelNonPremult(uint32_t src, uint8_t src_a,
148                                        uint32_t dst, uint8_t dst_a,
149                                        uint32_t scale, int shift) {
150    const uint8_t src_channel = (src >> shift) & 0xff;
151    const uint8_t dst_channel = (dst >> shift) & 0xff;
152    const uint32_t blend_unscaled = src_channel * src_a + dst_channel * dst_a;
153    assert(blend_unscaled < (1ULL << 32) / scale);
154    return (blend_unscaled * scale) >> 24;
155  }
156  static uint32_t BlendPixelNonPremult(uint32_t src, uint32_t dst) {
157    const uint8_t src_a = (src >> 24) & 0xff;
158    if (src_a == 0) {
159      return dst;
160    } else {
161      const uint8_t dst_a = (dst >> 24) & 0xff;
162      const uint8_t dst_factor_a = (dst_a * (256 - src_a)) >> 8;
163      const uint8_t blend_a = src_a + dst_factor_a;
164      const uint32_t scale = (1UL << 24) / blend_a;
165      const uint8_t blend_r =
166          BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 0);
167      const uint8_t blend_g =
168          BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 8);
169      const uint8_t blend_b =
170          BlendChannelNonPremult(src, src_a, dst, dst_factor_a, scale, 16);
171      assert(src_a + dst_factor_a < 256);
172      return (blend_r << 0) |
173             (blend_g << 8) |
174             (blend_b << 16) |
175             ((uint32_t)blend_a << 24);
176    }
177  }
178  static void BlendPixelRowNonPremult(uint32_t* const src,
179                                      const uint32_t* const dst, int num_pixels) {
180    int i;
181    for (i = 0; i < num_pixels; ++i) {
182      const uint8_t src_alpha = (src[i] >> 24) & 0xff;
183      if (src_alpha != 0xff) {
184        src[i] = BlendPixelNonPremult(src[i], dst[i]);
185      }
186    }
187  }
188  static WEBP_INLINE uint32_t ChannelwiseMultiply(uint32_t pix, uint32_t scale) {
189    uint32_t mask = 0x00FF00FF;
190    uint32_t rb = ((pix & mask) * scale) >> 8;
191    uint32_t ag = ((pix >> 8) & mask) * scale;
192    return (rb & mask) | (ag & ~mask);
193  }
194  static uint32_t BlendPixelPremult(uint32_t src, uint32_t dst) {
195    const uint8_t src_a = (src >> 24) & 0xff;
196    return src + ChannelwiseMultiply(dst, 256 - src_a);
197  }
198  static void BlendPixelRowPremult(uint32_t* const src, const uint32_t* const dst,
199                                   int num_pixels) {
200    int i;
201    for (i = 0; i < num_pixels; ++i) {
202      const uint8_t src_alpha = (src[i] >> 24) & 0xff;
203      if (src_alpha != 0xff) {
204        src[i] = BlendPixelPremult(src[i], dst[i]);
205      }
206    }
207  }
208  static void FindBlendRangeAtRow(const WebPIterator* const src,
209                                  const WebPIterator* const dst, int canvas_y,
210                                  int* const left1, int* const width1,
211                                  int* const left2, int* const width2) {
212    const int src_max_x = src->x_offset + src->width;
213    const int dst_max_x = dst->x_offset + dst->width;
214    const int dst_max_y = dst->y_offset + dst->height;
215    assert(canvas_y >= src->y_offset && canvas_y < (src->y_offset + src->height));
216    *left1 = -1;
217    *width1 = 0;
218    *left2 = -1;
219    *width2 = 0;
220    if (canvas_y < dst->y_offset || canvas_y >= dst_max_y ||
221        src->x_offset >= dst_max_x || src_max_x <= dst->x_offset) {
222      *left1 = src->x_offset;
223      *width1 = src->width;
224      return;
225    }
226    if (src->x_offset < dst->x_offset) {
227      *left1 = src->x_offset;
228      *width1 = dst->x_offset - src->x_offset;
229    }
230    if (src_max_x > dst_max_x) {
231      *left2 = dst_max_x;
232      *width2 = src_max_x - dst_max_x;
233    }
234  }
235  int WebPAnimDecoderGetNext(WebPAnimDecoder* dec,
236                             uint8_t** buf_ptr, int* timestamp_ptr) {
237    WebPIterator iter;
238    uint32_t width;
239    uint32_t height;
240    int is_key_frame;
241    int timestamp;
242    BlendRowFunc blend_row;
243    if (dec == NULL || buf_ptr == NULL || timestamp_ptr == NULL) return 0;
244    if (!WebPAnimDecoderHasMoreFrames(dec)) return 0;
245    width = dec->info_.canvas_width;
246    height = dec->info_.canvas_height;
247    blend_row = dec->blend_func_;
248    if (!WebPDemuxGetFrame(dec->demux_, dec->next_frame_, &iter)) {
249      return 0;
250    }
251    timestamp = dec->prev_frame_timestamp_ + iter.duration;
252    is_key_frame = IsKeyFrame(&iter, &dec->prev_iter_,
253                              dec->prev_frame_was_keyframe_, width, height);
254    if (is_key_frame) {
255      if (!ZeroFillCanvas(dec->curr_frame_, width, height)) {
256        goto Error;
257      }
258    } else {
259      if (!CopyCanvas(dec->prev_frame_disposed_, dec->curr_frame_,
260                      width, height)) {
261        goto Error;
262      }
263    }
264    {
265      const uint8_t* in = iter.fragment.bytes;
266      const size_t in_size = iter.fragment.size;
267      const size_t out_offset =
268          (iter.y_offset * width + iter.x_offset) * NUM_CHANNELS;
269      WebPDecoderConfig* const config = &dec->config_;
270      WebPRGBABuffer* const buf = &config->output.u.RGBA;
271      buf->stride = NUM_CHANNELS * width;
272      buf->size = buf->stride * iter.height;
273      buf->rgba = dec->curr_frame_ + out_offset;
274      if (WebPDecode(in, in_size, config) != VP8_STATUS_OK) {
275        goto Error;
276      }
277    }
278    if (iter.frame_num > 1 && iter.blend_method == WEBP_MUX_BLEND &&
279        !is_key_frame) {
280      if (dec->prev_iter_.dispose_method == WEBP_MUX_DISPOSE_NONE) {
281        int y;
282        for (y = 0; y < iter.height; ++y) {
283          const size_t offset =
284              (iter.y_offset + y) * width + iter.x_offset;
285          blend_row((uint32_t*)dec->curr_frame_ + offset,
286                    (uint32_t*)dec->prev_frame_disposed_ + offset, iter.width);
287        }
288      } else {
289        int y;
290        assert(dec->prev_iter_.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND);
291        for (y = 0; y < iter.height; ++y) {
292          const int canvas_y = iter.y_offset + y;
293          int left1, width1, left2, width2;
294          FindBlendRangeAtRow(&iter, &dec->prev_iter_, canvas_y, &left1, &width1,
295                              &left2, &width2);
296          if (width1 > 0) {
297            const size_t offset1 = canvas_y * width + left1;
298            blend_row((uint32_t*)dec->curr_frame_ + offset1,
299                      (uint32_t*)dec->prev_frame_disposed_ + offset1, width1);
300          }
301          if (width2 > 0) {
302            const size_t offset2 = canvas_y * width + left2;
303            blend_row((uint32_t*)dec->curr_frame_ + offset2,
304                      (uint32_t*)dec->prev_frame_disposed_ + offset2, width2);
305          }
306        }
307      }
308    }
309    dec->prev_frame_timestamp_ = timestamp;
310    WebPDemuxReleaseIterator(&dec->prev_iter_);
311    dec->prev_iter_ = iter;
312    dec->prev_frame_was_keyframe_ = is_key_frame;
313    CopyCanvas(dec->curr_frame_, dec->prev_frame_disposed_, width, height);
314    if (dec->prev_iter_.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) {
315      ZeroFillFrameRect(dec->prev_frame_disposed_, width * NUM_CHANNELS,
316                        dec->prev_iter_.x_offset, dec->prev_iter_.y_offset,
317                        dec->prev_iter_.width, dec->prev_iter_.height);
318    }
319    ++dec->next_frame_;
320    *buf_ptr = dec->curr_frame_;
321    *timestamp_ptr = timestamp;
322    return 1;
323   Error:
324    WebPDemuxReleaseIterator(&iter);
325    return 0;
326  }
327  int WebPAnimDecoderHasMoreFrames(const WebPAnimDecoder* dec) {
328    if (dec == NULL) return 0;
329    return (dec->next_frame_ <= (int)dec->info_.frame_count);
330  }
331  void WebPAnimDecoderReset(WebPAnimDecoder* dec) {
332    if (dec != NULL) {
333      dec->prev_frame_timestamp_ = 0;
334      WebPDemuxReleaseIterator(&dec->prev_iter_);
335      memset(&dec->prev_iter_, 0, sizeof(dec->prev_iter_));
336      dec->prev_frame_was_keyframe_ = 0;
337      dec->next_frame_ = 1;
338    }
339  }
340  const WebPDemuxer* WebPAnimDecoderGetDemuxer(const WebPAnimDecoder* dec) {
341    if (dec == NULL) return NULL;
342    return dec->demux_;
343  }
344  void WebPAnimDecoderDelete(WebPAnimDecoder* dec) {
345    if (dec != NULL) {
346      WebPDemuxReleaseIterator(&dec->prev_iter_);
347      WebPDemuxDelete(dec->demux_);
348      WebPSafeFree(dec->curr_frame_);
349      WebPSafeFree(dec->prev_frame_disposed_);
350      WebPSafeFree(dec);
351    }
352  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-geohash_helper.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_decode.c</div>
                </div>
                <div class="column column_space"><pre><code>111  double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {
112      double lat1r, lon1r, lat2r, lon2r, u, v;
113      lat1r = deg_rad(lat1d);
</pre></code></div>
                <div class="column column_space"><pre><code>112  static void ZeroFillFrameRect(uint8_t* buf, int buf_stride, int x_offset,
113                                int y_offset, int width, int height) {
114    int j;
115    assert(width * NUM_CHANNELS <= buf_stride);
116    buf += y_offset * buf_stride + x_offset * NUM_CHANNELS;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    