<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for react_outc_nfsim.c &amp; util.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc_nfsim.c &amp; util.c
      </h3>
<h1 align="center">
        2.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc_nfsim.c (4.428571%)<th>util.c (1.4265991%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(406-425)<td><a href="#" name="0">(169-179)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(209-226)<td><a href="#" name="1">(325-331)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc_nfsim.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"

#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "count_util.h"
#include "grid_util.h"
#include "logging.h"
#include "mcell_reactions.h"
#include "nfsim_func.h"
#include "react.h"
#include "react_nfsim.h"
#include "react_util.h"
#include "rng.h"
#include "util.h"
#include "vol_util.h"
#include "wall_util.h"

static queryOptions
initializeNFSimQueryforUnimolecularFiring(struct abstract_molecule *am,
                                          const char *external_path);

static bool calculate_nfsim_reactivity(struct graph_data *);
static void calculate_nfsim_diffusion_derived_data(struct volume *state,
                                                   struct graph_data *data);

void set_nfsim_product_geometries(struct pathway *path, struct rxn *rx,
                                  int prod_orientation, int prod_index) {
  if ((prod_orientation + path-&gt;orientation1) *
              (prod_orientation - path-&gt;orientation1) ==
          0 &amp;&amp;
      prod_orientation * path-&gt;orientation1 != 0) {
    if (prod_orientation == path-&gt;orientation1)
      rx-&gt;geometries[prod_index] = 1;
    else
      rx-&gt;geometries[prod_index] = -1;
  } else if (rx-&gt;n_reactants &gt; 1 &amp;&amp;
             (prod_orientation + path-&gt;orientation2) *
                     (prod_orientation - path-&gt;orientation2) ==
                 0 &amp;&amp;
             prod_orientation * path-&gt;orientation2 != 0) {
    if (prod_orientation == path-&gt;orientation2)
      rx-&gt;geometries[prod_index] = 2;
    else
      rx-&gt;geometries[prod_index] = -2;
  } else {
    rx-&gt;geometries[prod_index] = 1;
  }
}

queryOptions initializeNFSimQueryNoFiring(struct abstract_molecule *am) {
  // constant settings
  queryOptions options;

  static const char *optionKeys[1] = {"systemQuery"};

  options.optionValues = CHECKED_MALLOC_ARRAY(char *, 1, "option array");

  options.optionValues[0] = strdup("complex");

  // initialize speciesArray with the string we are going to query
  char **speciesArray =
      CHECKED_MALLOC_ARRAY(char *, 1, "string array of patterns");
  speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;

  static const int optionSeeds[1] = {1};

  // copy these settings to the options object
  options.initKeys = speciesArray;
  options.initValues = optionSeeds;
  options.numOfInitElements = 1;

  // experiment design: query for reactions with 1 reactant
  options.optionKeys = optionKeys;
  // options.optionValues = optionValues;
  options.numOfOptions = 1;
  return options;
}

/**********************************************************************
 *
 * This function creates a queryOptions object for designing an NFSim
 * experiment query after a unimolecular reaction fires.
 *
 * In: The abstract molecule whose nfsim status we are going to verify
 *
 * Out: the queryOptions object we will use to interact with nfsim
 *
 **********************************************************************/
queryOptions
initializeNFSimQueryforUnimolecularFiring(struct abstract_molecule *am,
                                          const char *external_path) {
  // constant settings
  queryOptions options;

  static const char *optionKeys[2] = {"systemQuery", "reaction"};

  options.optionValues = CHECKED_MALLOC_ARRAY(char *, 2, "option array");

  options.optionValues[0] = strdup("complex");
  options.optionValues[1] = strdup(external_path);

  // initialize speciesArray with the string we are going to query
  char **speciesArray =
      CHECKED_MALLOC_ARRAY(char *, 1, "string array of patterns");
  speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;

  static const int optionSeeds[1] = {1};

  // copy these settings to the options object
  options.initKeys = speciesArray;
  options.initValues = optionSeeds;
  options.numOfInitElements = 1;

  // experiment design: query for reactions with 1 reactant
  options.optionKeys = optionKeys;
  // options.optionValues = optionValues;
  options.numOfOptions = 2;
  return options;
}

queryOptions
initializeNFSimQueryforBimolecularFiring(struct abstract_molecule *am,
                                         struct abstract_molecule *am2,
                                         const char *external_path) {
  // constant settings
  queryOptions options;

  static const char *optionKeys[2] = {"systemQuery", "reaction"};

  options.optionValues = CHECKED_MALLOC_ARRAY(char *, 2, "option array");

  // options.optionValues[0] = CHECKED_MALLOC_ARRAY(char, strlen("complex"),
  // "reaction which we will step over");
  // strcpy(options.optionValues[0], "complex");

  // optionValues[0] = "complex";

  // options.optionValues[1] = CHECKED_MALLOC_ARRAY(char, strlen(external_path),
  // "reaction which we will step over");
  // strcpy(options.optionValues[1], external_path);

  options.optionValues[0] = strdup("complex");
  options.optionValues[1] = strdup(external_path);

  // initialize speciesArray with the string we are going to query
  char **speciesArray =
      CHECKED_MALLOC_ARRAY(char *, 2, "string array of patterns");
  speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;
  speciesArray[1] = am2-&gt;graph_data-&gt;graph_pattern;

  static const int optionSeeds[2] = {1, 1};

  // copy these settings to the options object
  options.initKeys = speciesArray;
  options.initValues = optionSeeds;
  options.numOfInitElements = 2;

  // experiment design: query for reactions with 1 reactant
  options.optionKeys = optionKeys;
  // options.optionValues = optionValues;
  options.numOfOptions = 2;
  return options;
}

static void find_objects(struct geom_object* current_parent,
                  const char* name1, struct geom_object** obj1,
                  const char* name2, struct geom_object** obj2) {

  struct geom_object* curr = current_parent;
  while (curr != NULL) {
    // did we find our object?
    if (*obj1 == NULL &amp;&amp; curr-&gt;last_name != NULL &amp;&amp; strcmp(curr-&gt;last_name, name1) == 0) {
      *obj1 = curr;
    }
    if (*obj2 == NULL &amp;&amp; curr-&gt;last_name != NULL &amp;&amp; strcmp(curr-&gt;last_name, name2) == 0) {
      *obj2 = curr;
    }
    if (*obj1 != NULL &amp;&amp; *obj2 != NULL) {
      // terminate search
      return;
    }
    // check children
    find_objects(curr-&gt;first_child, name1, obj1, name2, obj2);

    // next object in list
    curr = curr-&gt;next;
  }
}

static bool has_region(struct geom_object* obj, const char* reg_name) {

  for (struct region_list *r = obj-&gt;regions; r != NULL; r = r-&gt;next) {
    if (r-&gt;reg != NULL &amp;&amp; strcmp(r-&gt;reg-&gt;region_last_name, reg_name) == 0) {
      return true;
    }
  }
  return false;
}

int prepare_reaction_nfsim(struct volume *world, struct rxn *rx, void *results,
                           int path, struct abstract_molecule *reac,
                           struct abstract_molecule *reac2) {
<a name="1"></a>
  const char *product_pattern = NULL;
  void *individualResult;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  int numOfResults = mapvector_size(results);

  for (int productIdx = 0; productIdx &lt; numOfResults; productIdx++) {
    individualResult = mapvector_get(results, productIdx);
    product_pattern = map_get(individualResult,
                              "label"); // results-&gt;results[productIdx].label;
    constructNauty_c(product_pattern, 1);
    // TODO: we are ignoring optimizing for overlaps for now
    /*if(strcmp(reac-&gt;graph_pattern, product_pattern) == 0 &amp;&amp; overlapFlag == 0){
      overlapFlag = 1;
    }
    else{
        rx-&gt;product_idx_aux[path]++;

    }*/
  }
  rx-&gt;product_idx_aux[path] = numOfResults;
  if (rx-&gt;nfsim_players[path] == NULL) {</b></font>
    rx-&gt;nfsim_players[path] = CHECKED_MALLOC_ARRAY(
        struct species *, numOfResults, "reaction players array");
    rx-&gt;nfsim_geometries[path] = CHECKED_MALLOC_ARRAY(
        short, numOfResults, "geometries associated to this path");
  }

  rx-&gt;product_graph_data[path] = CHECKED_MALLOC_ARRAY(
      struct graph_data *, rx-&gt;product_idx_aux[path],
      "graph patterns for products that have been added to the system");
  int counter = 0;
  const char *diffusion;
  rx-&gt;external_reaction_data[path].products = numOfResults;
  for (int productIdx = 0; productIdx &lt; numOfResults; productIdx++) {
    individualResult = mapvector_get(results, productIdx);

    product_pattern = map_get(individualResult,
                              "label"); // results-&gt;results[productIdx].label;

    // query  graph_pattern hashmap instead of recreating stuff
    unsigned long graph_hash = lhash(product_pattern);
    int error =
        get_graph_data(graph_hash, &amp;rx-&gt;product_graph_data[path][counter]);
    if (error != 0) {
      rx-&gt;product_graph_data[path][counter] = CHECKED_MALLOC_ARRAY(
          struct graph_data, 1, "graph pattern for a single path");
      rx-&gt;product_graph_data[path][counter]-&gt;graph_pattern =
          strdup(product_pattern);
      rx-&gt;product_graph_data[path][counter]-&gt;graph_pattern_hash =
          lhash(product_pattern);
      diffusion = map_get(individualResult, "diffusion_function");
      if (diffusion) {
        rx-&gt;product_graph_data[path][counter]-&gt;graph_diffusion =
            atof(diffusion);
        calculate_nfsim_diffusion_derived_data(
            world, rx-&gt;product_graph_data[path][counter]);
      } else {
        rx-&gt;product_graph_data[path][counter]-&gt;graph_diffusion = -1;
        rx-&gt;product_graph_data[path][counter]-&gt;time_step = -1;
        rx-&gt;product_graph_data[path][counter]-&gt;space_step = -1;
      }

      calculate_nfsim_reactivity(rx-&gt;product_graph_data[path][counter]);

      store_graph_data(graph_hash, rx-&gt;product_graph_data[path][counter]);
      world-&gt;n_NFSimSpecies += 1;
    }
    counter++;
    //}
  }

  // recalculate the position of all players
  int num_players = rx-&gt;n_reactants;
  int kk = rx-&gt;n_pathways;
  if (kk &lt;= RX_SPECIAL)
    kk = 1;

  for (int n_pathway = 0; n_pathway &lt; kk; n_pathway++) {
    int k = rx-&gt;product_idx_aux[n_pathway] + rx-&gt;n_reactants;
    rx-&gt;product_idx[n_pathway] = num_players;
    num_players += k;
  }
  rx-&gt;product_idx[kk] = num_players;

  // we will be recreating the players and geometries arrays. this might not be
  // the most efficient approach but this is because we don't know the total
  // number of products before each path is fired individually in nfsim
  // XXX: maybe fire them manually and just get the number of products per path
  // even if we don't store path information?
  if (rx-&gt;players != NULL)
    free(rx-&gt;players);
  free(rx-&gt;geometries);

  rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
                                     "reaction players array");
  rx-&gt;geometries =
      CHECKED_MALLOC_ARRAY(short, num_players, "reaction geometries array");

  memset(rx-&gt;players, 0, sizeof(struct species *) * num_players);
  memset(rx-&gt;geometries, 0, sizeof(short) * num_players);

  // create pathway that will form players
  struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
      struct pathway, "reaction pathway");
  if (pathp == NULL) {
    return -1;
  }
  memset(pathp, 0, sizeof(struct pathway));

  /* Scan reactants, copying into the new pathway */
  int num_vol_mols = 0;
  int num_surface_mols = 0;
  int all_3d = 1;
  /*int complex_type = 0;*/
  int reactant_idx = 0;
  int oriented_count = 0;
  /*int num_complex_reactants = 0;*/
  bool orientation_flag1 = 0, orientation_flag2 = 0;
  int reactantOrientation1, reactantOrientation2, productOrientation;

  // obtain orientation information
  calculate_reactant_orientation(reac, reac2, &amp;orientation_flag1,
                                 &amp;orientation_flag2, &amp;reactantOrientation1,
                                 &amp;reactantOrientation2);
  struct sym_entry *nfsim_molecule = reac-&gt;properties-&gt;sym;

  // create first reactant entry
  rx-&gt;geometries[0] = reactantOrientation1;
  struct mcell_species *reactants = mcell_add_to_species_list(
      nfsim_molecule, orientation_flag1, reactantOrientation1, NULL);

  // second reactant entry
  if (reac2 != NULL) {
    rx-&gt;geometries[1] = reactantOrientation2;
    nfsim_molecule = reac2-&gt;properties-&gt;sym;
    reactants = mcell_add_to_species_list(nfsim_molecule, orientation_flag2,
                                          reactantOrientation2, reactants);
  }
  // we will be storing prodcut compartment information in here
  compartmentStruct *compartmentInfoArray =
      CHECKED_MALLOC_ARRAY(compartmentStruct, numOfResults,
                           "Creating array of compartment information");

  for (int i = 0; i &lt; numOfResults; i++) {
    // what compartment is the species now in
    individualResult = mapvector_get(results, i);
    compartmentInfoArray[i] = getCompartmentInformation_c(map_get(
        individualResult,
        "compartment")); // getCompartmentInformation_c(results-&gt;results[i].compartment);
  }

  struct species *nfsim_molecule_template;

  // get the mcell species proxy we will be using
  if (compartmentInfoArray[0].spatialDimensions == 2)
    nfsim_molecule_template = world-&gt;global_nfsim_surface;
  else
    nfsim_molecule_template = world-&gt;global_nfsim_volume;

  // calculate orientation information if its not a vol vol reaciton
  if (orientation_flag2) {
    orientation_flag1 = true;
    individualResult = mapvector_get(results, 0);
    const char* outside = compartmentInfoArray[0].outside;
    // originalCompartment is in fact the taget compartment where we should place out product
    const char* originalCompartment = map_get(individualResult, "originalCompartment");

    bool originalCompartmentEmpty = strcmp(originalCompartment, "") == 0;

    if (!originalCompartmentEmpty &amp;&amp; strcmp(outside, originalCompartment) == 0) {
      // outside and original are the same, not completely sure what to do here,
      // keeping original implementation
      productOrientation = -1;
    }
    else if (!originalCompartmentEmpty &amp;&amp; strcmp(outside, "") != 0) {
      // 1) find object with "outside or "originalCompartment" name in world-&gt;root_instance,
      // then check its regions
      // 2) a region of its object is either "ALL" or its surface
      // 3) if we go from surface into the object -&gt; orientation == -1,
      //    all other cases are kept as they were implemented originally because we
      //    do not have other information about the hierarchy of objects
      struct geom_object* objOutside = NULL;
      struct geom_object* objOrigCompartment = NULL;
      find_objects(world-&gt;root_instance, outside, &amp;objOutside, originalCompartment, &amp;objOrigCompartment);

      // if we found only one of these objects, check its regions
      if (objOutside != NULL &amp;&amp; objOrigCompartment != NULL) {
        // both are objects, default behavior should be ok
        mcell_warn(
            "Handling orientation of NFsim reaction where both compartents %s (orig) and %s (outside) are objects is not supported yet, "
            "using default orientation 1 (outside)", originalCompartment, outside);
        productOrientation = 1;
      } else if (objOutside == NULL &amp;&amp; objOrigCompartment == NULL) {
        mcell_error(
            "NFsim reaction returned compartments %s (orig) and %s (outside) that were not identified as object, this is not supported yet.",
            originalCompartment, outside
        );
<a name="0"></a>        exit(1);
      } else {
        if (objOrigCompartment != NULL) {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          if (has_region(objOrigCompartment, outside)) {
            // we go from outside (e.g. PM) inside (e.g. CP)
            productOrientation = -1;
          } else {
            // relationship is not known...
            mcell_warn(
                "Handling orientation of NFsim reaction where both compartent %s (orig) and %s (outside) are not in object-region relationship is not supported yet, "
                "using default orientation 1 (outside)", originalCompartment, outside);
            productOrientation = 1;
          }
        } else {
          if (has_region(objOutside, originalCompartment)) {
            // we go from inside (e.g. CP) outside (e.g. PM)
            productOrientation = 1;
          } else {
            // relationship is not known but we can assume that we go onto surface because the original compartment object is NULL,
            // therefore it is a region not an object,
            // selecting 1 because we need to stay on the 'outside' side of the surface
            productOrientation = 1;
          }</b></font>
        }
      }
    } else {
      // outside is empty, we get this type of information from reactions like this:
      // MemA@PM -&gt; Mem@PM+A@EC  -  we need to go outside from membrane PM to EC
      productOrientation = 1;
    }

  } else {
    orientation_flag1 = false;
    productOrientation = 0;
  }

  struct mcell_species *products =
      mcell_add_to_species_list(nfsim_molecule_template-&gt;sym, orientation_flag1,
                                productOrientation, NULL);
  rx-&gt;nfsim_geometries[path][0] = productOrientation;
  // if theres more than one product
  for (int i = 1; i &lt; numOfResults; i++) {
    // compartmentInfo =
    // getCompartmentInformation_c(results-&gt;results[i].compartment);
    if (compartmentInfoArray[i].spatialDimensions == 2)
      nfsim_molecule_template = world-&gt;global_nfsim_surface;
    else
      nfsim_molecule_template = world-&gt;global_nfsim_volume;

    if (orientation_flag2) {

      individualResult = mapvector_get(results, i);
      if (strcmp(compartmentInfoArray[i].outside,
                 map_get(individualResult, "originalCompartment")) ==
          0) { // results-&gt;results[i].originalCompartment) == 0){
        productOrientation = -1;
      } else {
        productOrientation = 1;
      }

    } else {
      productOrientation = 0;
    }

    rx-&gt;nfsim_geometries[path][i] = productOrientation;
    products = mcell_add_to_species_list(nfsim_molecule_template-&gt;sym,
                                         orientation_flag1, productOrientation,
                                         products);
  }

  // free up compartment struct helpers
  for (int i = 0; i &lt; numOfResults; i++) {
    delete_compartmentStructs(compartmentInfoArray[i]);
  }
  free(compartmentInfoArray);

  // create out pathway
  if (extract_reactants(pathp, reactants, &amp;reactant_idx, &amp;num_vol_mols,
                        &amp;num_surface_mols, &amp;all_3d, &amp;oriented_count) != 0) {
    return -1;
  }

  int num_surf_products = 0;
  /*int num_complex_products = 0;*/
  int bidirectional = 0;

  if (extract_products(world-&gt;notify, pathp, products, &amp;num_surf_products,
                       bidirectional, all_3d) == MCELL_FAIL) {
    return MCELL_FAIL;
  }

  mcell_delete_species_list(reactants);
  mcell_delete_species_list(products);

  int k = 0;
  struct product *prod = NULL;

  // store this nfsim path information
  counter = 0;

  // XXX: it might be necessary to clear out the stuff in pathp at the very end
  for (prod = pathp-&gt;product_head; counter &lt; numOfResults;) {
    rx-&gt;nfsim_players[path][counter] = prod-&gt;prod;
    ++counter;
    if (counter &lt; numOfResults)
      prod = prod-&gt;next;
  }
  prod-&gt;next = NULL;

  if (rx-&gt;players != NULL) {
    free(rx-&gt;players);
    free(rx-&gt;geometries);
  }

  rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
                                     "reaction players array");
  rx-&gt;geometries =
      CHECKED_MALLOC_ARRAY(short, num_players, "reaction geometries array");

  memset(rx-&gt;players, 0, sizeof(struct species *) * num_players);
  memset(rx-&gt;geometries, 0, sizeof(short) * num_players);

  // recreate players array
  rx-&gt;players[0] = pathp-&gt;reactant1;

  // if its a bimolecular reaction
  if (reac2 != NULL)
    rx-&gt;players[1] = pathp-&gt;reactant2;

  for (int n_pathway = 0; n_pathway &lt; rx-&gt;n_pathways; n_pathway++) {
    k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
    counter = 0;
    for (counter = 0; counter &lt; rx-&gt;product_idx_aux[n_pathway]; counter++) {
      // XXX: right now we are ignoring recycled species which is inefficient

      // if (recycled1 == 0 &amp;&amp; prod-&gt;prod == pathp-&gt;reactant1) {
      //  recycled1 = 1;
      //  kk = rx-&gt;product_idx[path] + 0;
      //}
      // else {
      kk = k;
      k++;
      //}
      // kk = rx-&gt;product_idx[path] + 0;
      rx-&gt;players[kk] = rx-&gt;nfsim_players[n_pathway][counter];
      set_nfsim_product_geometries(
          pathp, rx, rx-&gt;nfsim_geometries[n_pathway][counter], kk);
    }
  } /* end for (n_pathway = 0, ...) */

  init_reaction_info(rx);
  rx-&gt;info[path].pathname = NULL;

  // adjust reaction probabilities
  // adjust_rates_nfsim(world, rx, pathp);

  // cleanup path information
  struct product *tmp = pathp-&gt;product_head;
  struct product *tmp2 = NULL;
  while (tmp != NULL) {
    tmp2 = tmp-&gt;next;
    free(tmp);
    tmp = tmp2;
  }
  free(pathp);

  return MCELL_SUCCESS;
}

void free_reaction_nfsim(struct rxn *rx, int path) {
  free(rx-&gt;nfsim_players[path]);
  free(rx-&gt;nfsim_geometries[path]);

  // i actually need to iterate over all products
  /*for(int i=0; i &lt; rx-&gt;external_reaction_data[path].products;i++){
    free(rx-&gt;product_graph_data[path][i]-&gt;graph_pattern);
    free(rx-&gt;product_graph_data[path][i]);
  }*/
  free(rx-&gt;product_graph_data[path]);

  rx-&gt;nfsim_players[path] = NULL;
  rx-&gt;nfsim_geometries[path] = NULL;
  rx-&gt;product_graph_data[path] = NULL;
}

//int outcome_unimolecular_nfsim(struct volume *world, struct rxn *rx, int path,
//                               struct abstract_molecule *reac, double t) {
//  int result = RX_A_OK;
//
//  if (rx-&gt;product_idx_aux[path] == -1) {
//    mcell_log("uni restart %s\n", reac-&gt;graph_data-&gt;graph_pattern);
//    queryOptions options = initializeNFSimQueryforUnimolecularFiring(
//        reac, rx-&gt;external_reaction_data[path].reaction_name);
//
//    void *results = mapvector_create();
//
//    initAndQuerySystemStatus_c(options, results);
//
//    constructNauty_c(reac-&gt;graph_data-&gt;graph_pattern, -1);
//
//    // fill in the rxn react structure with the appropiate information
//    world-&gt;n_NFSimReactions += 1;
//    prepare_reaction_nfsim(world, rx, results, path, reac, NULL);
//  }
//  return result;
//}

/*
Calculate the space_Step and time_step associated to this molecule based on
right now it only considers global time_steps and space_steps
*/
void calculate_nfsim_diffusion_derived_data(struct volume *state,
                                            struct graph_data *data) {

  double global_time_unit = state-&gt;time_unit;

  const char *compartment1 =
      extractSpeciesCompartmentFromNauty_c(data-&gt;graph_pattern);
  compartmentStruct reactantCompartmentInfo1 =
      getCompartmentInformation_c(compartment1);
  // free string allocated in extractSpeciesCompartmentFromNauty_c
  free((char*)compartment1);

  if (!distinguishable(state-&gt;space_step, 0, EPS_C)) // Global timestep
  {
    data-&gt;space_step =
        sqrt(4.0 * 1.0e8 * data-&gt;graph_diffusion * global_time_unit) *
        state-&gt;r_length_unit;
    data-&gt;time_step = 1.0;
  } else /* Global spacestep */
  {
    double space_step = state-&gt;space_step * state-&gt;length_unit;
    if (reactantCompartmentInfo1.spatialDimensions == 2) {
      data-&gt;time_step =
          space_step * space_step /
          (MY_PI * 1.0e8 * data-&gt;graph_diffusion * global_time_unit);
    } else {
      data-&gt;time_step =
          space_step * space_step * MY_PI /
          (16.0 * 1.0e8 * data-&gt;graph_diffusion * global_time_unit);
    }
    data-&gt;space_step = sqrt(4.0 * 1.0e8 * data-&gt;graph_diffusion *
                            data-&gt;time_step * global_time_unit) *
                       state-&gt;r_length_unit;
  }

  // free strings allocated in getCompartmentInformation_c
  free(reactantCompartmentInfo1.name);
  free(reactantCompartmentInfo1.outside);
}

bool calculate_nfsim_reactivity(struct graph_data *graph) {
  graph-&gt;flags = 0;

  queryOptions options =
      initializeNFSimQueryForBimolecularReactions(graph, NULL, "0");
  void *results = mapvectormap_create();
  initAndQueryByNumReactant_c(options, results);

  bool dimensionalityFlag = true;
  if (mapvectormap_size(results) &gt; 0) {
    char **resultKeys = mapvectormap_getKeys(results);
    // we know that it only contains one result
    void *headComplex = mapvectormap_get(results, resultKeys[0]);

    int resultSize = mapvectormap_size(results);
    for (int i = 0; i &lt; resultSize; i++) {
      free(resultKeys[i]);
    }
    free(resultKeys);

    int headNumAssociatedReactions = mapvector_size(headComplex);
    void *pathInformation;

    for (int path = 0; path &lt; headNumAssociatedReactions; path++) {
      pathInformation = mapvector_get(headComplex, path);
      const char *dimensionality =
          map_get(pathInformation, "reactionDimensionality");
      if (!dimensionality) {
        dimensionalityFlag = false;
        break;
      }
      if (strcmp(dimensionality, "VOLSURF") == 0) {
        graph-&gt;flags |= CAN_VOLSURF;
      }
      if (strcmp(dimensionality, "VOLVOL") == 0) {
        graph-&gt;flags |= CAN_VOLVOL;
      }
      if (strcmp(dimensionality, "SURFSURF") == 0) {
        graph-&gt;flags |= CAN_SURFSURF;
      }
    }
  }

  // cleanup
  mapvectormap_delete(results);

  if (dimensionalityFlag) {
    return true;
  } else {
    graph-&gt;flags = -1;
    return false;
  }
}

/**
Doesn't fire any reactions, it just queries NFSim for the properties of a given
graph pattern
used for initialization and copies them to the reac-&gt;graph_data object
**/
void properties_nfsim(struct volume *world, struct abstract_molecule *reac) {

  // XXX: this could be stored in a hashmap for initialization purposes if it
  // becomes oto much of an
  // issue to query everytime. we are not doi9ng it right now since this
  // function is only called
  // when initially releasing particles. moreover it might be worth it to have a
  // hashmap containing
  // graph_data properties instead of it being stored in every particle...

  // initialize system with only one molecule
  queryOptions options = initializeNFSimQueryNoFiring(reac);
  void *results = mapvector_create();
  initAndQuerySystemStatus_c(options, results);
  // get the first result since we are only querying information for one
  // molecule
  void *individualResult = mapvector_get(results, 0);
  const char *result = map_get(individualResult, "diffusion_function");

  if (result) {
    reac-&gt;graph_data-&gt;graph_diffusion = atof(result);
    calculate_nfsim_diffusion_derived_data(world, reac-&gt;graph_data);
  } else {
    reac-&gt;graph_data-&gt;graph_diffusion = -1;
    reac-&gt;graph_data-&gt;space_step = -1;
    reac-&gt;graph_data-&gt;time_step = -1;
    reac-&gt;get_diffusion = get_standard_diffusion;
    reac-&gt;get_space_step = get_standard_space_step;
    reac-&gt;get_time_step = get_standard_time_step;
  }
  mapvector_delete(results);

  // now lets get information about the reactionality of this reactant
  if (calculate_nfsim_reactivity(reac-&gt;graph_data)) {
    reac-&gt;get_flags = get_nfsim_flags;
  } else {
    reac-&gt;get_flags = get_standard_flags;
  }

  free(options.optionValues[0]);
  free(options.optionValues);
  free(options.initKeys);
}

int outcome_nfsim(struct volume *world, struct rxn *rx, int path,
                  struct abstract_molecule *reac,
                  struct abstract_molecule *reac2, double t) {
  int result = RX_A_OK;
  queryOptions options;
  // if this is a reaction rule that can be mapped in different ways we need to
  // resample
  if (rx-&gt;product_idx_aux[path] != -1 &amp;&amp;
      rx-&gt;external_reaction_data[path].resample == 1) {
    free_reaction_nfsim(rx, path);
    rx-&gt;product_idx_aux[path] = -1;
  }
  // if we don't have previous information about this path then build up the
  // rxn structure

  if (rx-&gt;product_idx_aux[path] == -1) {

    world-&gt;n_NFSimReactions += 1;

    if (reac2 == NULL)
      options = initializeNFSimQueryforUnimolecularFiring(
          reac, rx-&gt;external_reaction_data[path].reaction_name);
    else {
      options = initializeNFSimQueryforBimolecularFiring(
          reac, reac2, rx-&gt;external_reaction_data[path].reaction_name);
    }

    void *results = mapvector_create();

    initAndQuerySystemStatus_c(options, results);

    // queryResults results = initAndQuerySystemStatus_c(options);

    // frees up the option object
    free(options.optionValues[0]);
    free(options.optionValues[1]);
    free(options.optionValues);
    free(options.initKeys);

    // fill in the rxn react structure with the appropiate information
    prepare_reaction_nfsim(world, rx, results, path, reac, reac2);
    // frees up the query result
    mapvector_delete(results);

  }
  // otherwise just update populations
  else {
    for (int i = 0; i &lt; rx-&gt;product_idx_aux[path]; i++) {
      constructNauty_c(rx-&gt;product_graph_data[path][i]-&gt;graph_pattern, 1);
    }
    // and clean the info information for good measure
    rx-&gt;info[path].pathname = NULL;
  }
  // also decrease reactant populations
  constructNauty_c(reac-&gt;graph_data-&gt;graph_pattern, -1);
  if (reac2 != NULL)
    constructNauty_c(reac2-&gt;graph_data-&gt;graph_pattern, -1);

  return result;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>util.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

#include "config.h"

#include &lt;assert.h&gt;
#include &lt;float.h&gt;
#include &lt;math.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;vector&gt;

#ifndef _MSC_VER
#include &lt;unistd.h&gt;
#include &lt;sys/resource.h&gt; // Linux include
#else
typedef unsigned int uint;
#endif

#include "logging.h"
#include "util.h"
#include "mcell_structs.h"

#include "bng/shared_defines.h"
#include "bng/filesystem_utils.h"

/*******************************************************************
new_bit_array: mallocs an array of the desired number of bits

 In:
    bits: how many bits to place in the array

 Out:
    A pointer to a newly allocated bit_array struct, or NULL
    on memory error.
*******************************************************************/
struct bit_array *new_bit_array(int bits) {
  int n = (bits + 8 * sizeof(int) - 1) / (8 * sizeof(int));
  /* Allocate contiguous memory for struct bit_array and its associated bits */
  struct bit_array *ba = (struct bit_array *)malloc(sizeof(struct bit_array) +
    sizeof(int) * n);
  if (ba == NULL) {
    return NULL;
  }

  ba-&gt;nbits = bits;
  ba-&gt;nints = n;
  return ba;
}

/*************************************************************************
duplicate_bit_array: mallocs an array and copies an existing bit array

 In:
    old: existing bit array to duplicate (in newly malloced memory)

 Out:
    A pointer to a newly allocated bit_array struct, or NULL
    on memory error.
*************************************************************************/
struct bit_array *duplicate_bit_array(struct bit_array *old) {
  struct bit_array *ba = (struct bit_array *)malloc(sizeof(struct bit_array) +
    sizeof(int) * old-&gt;nints);
  if (ba == NULL) {
    return NULL;
  }

  memcpy(ba, old, sizeof(struct bit_array) + sizeof(int) * old-&gt;nints);
  return ba;
}

/*******************************************************************
get_bit: returns the value of a bit in a bit_array

 In:
    ba: pointer to a bit_array struct
    idx: the index of the bit to return

 Out:
    0 or 1, depending on whether the idx'th bit is set.  No
    bounds checking is performed.
*******************************************************************/
int get_bit(struct bit_array *ba, int idx) {
  int *data = &amp;(ba-&gt;nints);
  data++; /* At start of bit array memory */

  size_t ofs = idx &amp; (8 * sizeof(int) - 1);
  idx = idx / (8 * sizeof(int));
  ofs = 1u &lt;&lt; ofs;

  if ((data[idx] &amp; ofs) != 0) {
    return 1;
  } else {
    return 0;
  }
}

/*******************************************************************
set_bit: set a value in a bit array

 In:
    ba: pointer to a bit_array struct
    idx: the index of the bit to set
    value: 0 = turn bit off; nonzero = turn bit on

 Out:
    Nothing
*******************************************************************/
void set_bit(struct bit_array *ba, int idx, int value) {
  int *data = &amp;(ba-&gt;nints);
  data++; /* At start of bit array memory */

  size_t ofs = idx &amp; (8 * sizeof(int) - 1);
  idx = idx / (8 * sizeof(int));
  ofs = (1u &lt;&lt; ofs);

  if (value) {
    value = ofs;
  } else {
    value = 0;
  }

  data[idx] = (data[idx] &amp; ~ofs) | value;
}

/*******************************************************************
set_bit_range: set many bits to a value in a bit array

 In:
    ba: pointer to a bit_array struct
    idx1: the index of the first bit to set
    idx2: the index of the last bit to set
    value: 0 = turn bits off; nonzero = turn bits on

 Out:
    Nothing
*******************************************************************/
void set_bit_range(struct bit_array *ba, int idx1, int idx2, int value) {
  int *data = &amp;(ba-&gt;nints);
  data++; /* At start of bit array memory */

  int ofs1 = idx1 &amp; (8 * sizeof(int) - 1);
  int ofs2 = idx2 &amp; (8 * sizeof(int) - 1);
  idx1 = idx1 / (8 * sizeof(int));
  idx2 = idx2 / (8 * sizeof(int));

  unsigned int mask, cmask;
  if (idx1 == idx2) {
    mask = 0;
    for (int i = ofs1; i &lt;= ofs2; i++) {
      mask |= (1u &lt;&lt; i);
<a name="0"></a>    }
    cmask = ~mask;

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (value) {
      data[idx1] = (data[idx1] &amp; cmask) | mask;
    } else {
      data[idx1] = data[idx1] &amp; cmask;
    }
  } else {
    if (value) {
      value = ~0;
    } else {
      value = 0;
    }</b></font>
    for (int i = idx1 + 1; i &lt; idx2; i++) {
      data[i] = value;
    }

    mask = 0;
    for (unsigned int i = ofs1; i &lt; 8 * sizeof(int); i++) {
      mask |= (1u &lt;&lt; i);
    }
    cmask = ~mask;
    if (value) {
      data[idx1] = (data[idx1] &amp; cmask) | mask;
    } else {
      data[idx1] = data[idx1] &amp; cmask;
    }

    mask = 0;
    for (int i = 0; i &lt;= ofs2; i++) {
      mask |= (1u &lt;&lt; i);
    }
    cmask = ~mask;
    if (value) {
      data[idx2] = (data[idx2] &amp; cmask) | mask;
    } else {
      data[idx2] = data[idx2] &amp; cmask;
    }
  }
}

/*******************************************************************
set_all_bits: sets all values in a bit array

 In:
    ba: pointer to a bit_array struct
    value: 0 = turn bits off; nonzero = turn bits on

 Out:
    Nothing
*******************************************************************/
void set_all_bits(struct bit_array *ba, int value) {
  if (value) {
    value = ~0;
  }

  int *data = &amp;(ba-&gt;nints);
  data++; /* At start of bit array memory */

  for (int i = 0; i &lt; ba-&gt;nints; i++) {
    data[i] = value;
  }
}

/*******************************************************************
bit operation: performs a logical operation on two bit arrays

 In:
    ba: pointer to a bit_array struct
    bb: pointer to another bit_array struct
    op: character that determines which operation to perform
        '!' -- ba = NOT ba
        '~' -- same
        '|' -- ba = ba OR bb
        '+' -- same
        '&amp;' -- ba = ba AND bb
        '^' -- ba = ba XOR bb
        '-' -- ba = ba AND NOT bb

 Out:
    Nothing
*******************************************************************/
void bit_operation(struct bit_array *ba, struct bit_array *bb, char op) {
  int *da, *db;
  if (op == '!' || op == '~') {
    da = &amp;(ba-&gt;nints);
    da++;
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] = ~da[i];
    }
    return;
  }

  if (ba-&gt;nbits != bb-&gt;nbits) {
    return;
  }

  da = &amp;(ba-&gt;nints);
  da++;
  db = &amp;(bb-&gt;nints);
  db++;

  switch (op) {
  case '^':
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] ^= db[i];
    }
    break;
  case '|':
  case '+':
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] |= db[i];
    }
    break;
  case '-':
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] &amp;= ~db[i];
    }
    break;
  case '&amp;':
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] &amp;= db[i];
    }
    break;
  default:
    break;
  }
}

/**********************************************************************
count_bits: count how many bits are set in a bit array

 In:
    ba: pointer to a bit_array struct

 Out:
    int containing number of nonzero bits
**********************************************************************/
int count_bits(struct bit_array *ba) {
  static const int cb_table[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
  };

  int *dd = &amp;(ba-&gt;nints);
  dd++;
<a name="1"></a>  unsigned char *d = (unsigned char *)dd;

  int n = (ba-&gt;nints - 1) * sizeof(int);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int cnt = 0;
  for (int i = 0; i &lt; n; i++) {
    cnt += cb_table[(*d++)];
  }

  n = ba-&gt;nbits - n * 8;
  if (n == 0)</b></font>
    return cnt;

  int j = dd[ba-&gt;nints - 1];
  while (n &gt;= 8) {
    cnt += cb_table[j &amp; 0xFF];
    n -= 8;
    j &gt;&gt;= 8;
  }
  if (n &gt; 0) {
    cnt += cb_table[j &amp; 0xFF] - cb_table[(j &amp; 0xFF) &gt;&gt; n];
  }
  return cnt;
}

/**********************************************************************
free_bit_array: frees a bit array (just a wrapper to free() for now)

 In:
    ba: pointer to a bit_array struct

 Out:
    Nothing
**********************************************************************/
void free_bit_array(struct bit_array *ba) { free(ba); }

/*************************************************************************
bisect:
  In: array of doubles, sorted low to high
      int saying how many doubles there are
      double we are using to bisect the array
  Out: index of the largest element in the array smaller than the bisector
*************************************************************************/
int bisect(double *list, int n, double val) {
  int lo = 0;
  int hi = n;
  int mid = 0;
  while (hi - lo &gt; 1) {
    mid = (hi + lo) / 2;
    if (list[mid] &gt; val)
    {
      hi = mid;
    } else {
      lo = mid;
    }
  }
  return lo;
}

/*************************************************************************
bisect_near:
  In: array of doubles, sorted low to high
      int saying how many doubles there are
      double we are using to bisect the array
  Out: index of the element closest to val
*************************************************************************/
int bisect_near(double *list, int n, double val) {
  int lo = 0;
  int hi = n - 1;
  int mid = 0;
  while (hi - lo &gt; 1) {
    mid = (hi + lo) / 2;
    if (list[mid] &gt; val)
    {
      hi = mid;
    } else {
      lo = mid;
    }
  }
  if (val &gt; list[hi]) {
    return hi;
  } else if (val &lt; list[lo]) {
    return lo;
  } else if (val - list[lo] &lt; list[hi] - val) {
    return lo;
  } else {
    return hi;
  }
}

/*************************************************************************
bisect_high:
  In: array of doubles, sorted low to high
      int saying how many doubles there are
      double we are using to bisect the array
  Out: index of the smallest element in the array larger than the bisector
*************************************************************************/
int bisect_high(double *list, int n, double val) {
  int lo = 0;
  int hi = n - 1;
  int mid = 0;
  while (hi - lo &gt; 1) {
    mid = (hi + lo) / 2;
    if (list[mid] &gt; val) {
      hi = mid;
    } else {
      lo = mid;
    }
  }
  if (list[lo] &gt; val)
  {
    return lo;
  } else {
    return hi;
  }
}

/**********************************************************************
distinguishable: reports whether two doubles are measurably different

 In:
    a: first double
    b: second double
    eps: fractional difference that we think is different

 Out:
    1 if the numbers are different, 0 otherwise
**********************************************************************/
int distinguishable(double a, double b, double eps) {
  double c = fabs(a - b);
  a = fabs(a);
  if (a &lt; 1) {
    a = 1;
  }
  b = fabs(b);

  if (b &lt; a) {
    eps *= a;
  } else {
    eps *= b;
  }
  return (c &gt; eps);
}

/**********************************************************************
is_reverse_abbrev: reports whether the first string is a reverse
  abbreviation of the second, i.e. whether it matches the end of
  the second string.
**********************************************************************/
int is_reverse_abbrev(const char *abbrev, const char *full) {
  size_t na = strlen(abbrev);
  size_t nf = strlen(full);
  if (na &gt; nf) {
    return 0;
  }
  return (strcmp(abbrev, full + (nf - na)) == 0);
}

/*************************************************************************
void_list_sort:
  In: linked list contining void pointers
  Out: linked list is mergesorted by memory address
*************************************************************************/
struct void_list *void_list_sort(struct void_list *vl) {
  struct void_list *stack[64];
  int stack_n[64];
  struct void_list *left, *right, *merge, *tail;
  int si = 0;

  /* HACK: If vl == NULL, we return stack[0] unmodified, so initialize it to
   *       NULL. */
  stack[0] = NULL;

  while (vl != NULL) {
    if (vl-&gt;next == NULL) {
      stack[si] = vl;
      stack_n[si] = 1;
      vl = NULL;
      si++;
    } else if ((intptr_t)vl-&gt;data &lt;= (intptr_t)vl-&gt;next-&gt;data) {
      stack[si] = vl;
      stack_n[si] = 2;
      vl = vl-&gt;next-&gt;next;
      stack[si]-&gt;next-&gt;next = NULL;
      si++;
    } else {
      stack[si] = vl-&gt;next;
      stack_n[si] = 2;
      left = vl;
      vl = vl-&gt;next-&gt;next;
      stack[si]-&gt;next = left;
      left-&gt;next = NULL;
      si++;
    }
    while (si &gt; 1 &amp;&amp; stack_n[si - 1] * 2 &gt;= stack_n[si - 2]) {
      stack_n[si - 2] += stack_n[si - 1];

      left = stack[si - 2];
      right = stack[si - 1];
      if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
        merge = left;
        left = left-&gt;next;
      } else {
        merge = right;
        right = right-&gt;next;
      }
      merge-&gt;next = NULL;
      tail = merge;

      while (1) {
        if (left == NULL) {
          tail-&gt;next = right;
          break;
        }
        if (right == NULL) {
          tail-&gt;next = left;
          break;
        }

        if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
          tail-&gt;next = left;
          tail = left;
          left = left-&gt;next;
        } else {
          tail-&gt;next = right;
          tail = right;
          right = right-&gt;next;
        }
      }

      stack[si - 2] = merge;
      si--;
    }
  }

  while (si &gt; 1) /* Exact duplicate of code in loop--keep it this way! */
  {
    stack_n[si - 2] += stack_n[si - 1];

    left = stack[si - 2];
    right = stack[si - 1];
    if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
      merge = left;
      left = left-&gt;next;
    } else {
      merge = right;
      right = right-&gt;next;
    }
    merge-&gt;next = NULL;
    tail = merge;

    while (1) {
      if (left == NULL) {
        tail-&gt;next = right;
        break;
      }
      if (right == NULL) {
        tail-&gt;next = left;
        break;
      }

      if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
        tail-&gt;next = left;
        tail = left;
        left = left-&gt;next;
      } else {
        tail-&gt;next = right;
        tail = right;
        right = right-&gt;next;
      }
    }

    stack[si - 2] = merge;
    si--;
  }

  return stack[0];
}

/*************************************************************************
void_list_sort_by:
  In: linked list containing void pointers
      comparison function that compares two void pointers
  Out: linked list is mergesorted according to function
  Note: function should implement "less than or equal to", i.e., it
        should return a nonzero value if the first pointer is considered
        to be less than or equal to the second (based on contents or
        whatever), and it should return zero otherwise.
*************************************************************************/
struct void_list *void_list_sort_by(struct void_list *vl,
                                    int (*leq)(void *, void *)) {
  struct void_list *stack[64];
  int stack_n[64];
  struct void_list *left, *right, *merge, *tail;
  int si = 0;

  /* HACK: If vl == NULL, we return stack[0] unmodified, so initialize it to
   *       NULL. */
  stack[0] = NULL;

  while (vl != NULL) {
    if (vl-&gt;next == NULL) {
      stack[si] = vl;
      stack_n[si] = 1;
      vl = NULL;
      si++;
    } else if ((*leq)(vl-&gt;data, vl-&gt;next-&gt;data)) {
      stack[si] = vl;
      stack_n[si] = 2;
      vl = vl-&gt;next-&gt;next;
      stack[si]-&gt;next-&gt;next = NULL;
      si++;
    } else {
      stack[si] = vl-&gt;next;
      stack_n[si] = 2;
      left = vl;
      vl = vl-&gt;next-&gt;next;
      stack[si]-&gt;next = left;
      left-&gt;next = NULL;
      si++;
    }
    while (si &gt; 1 &amp;&amp; stack_n[si - 1] * 2 &gt;= stack_n[si - 2]) {
      stack_n[si - 2] += stack_n[si - 1];

      left = stack[si - 2];
      right = stack[si - 1];
      if ((*leq)(left-&gt;data, right-&gt;data)) {
        merge = left;
        left = left-&gt;next;
      } else {
        merge = right;
        right = right-&gt;next;
      }
      merge-&gt;next = NULL;
      tail = merge;

      while (1) {
        if (left == NULL) {
          tail-&gt;next = right;
          break;
        }
        if (right == NULL) {
          tail-&gt;next = left;
          break;
        }

        if ((*leq)(left-&gt;data, right-&gt;data)) {
          tail-&gt;next = left;
          tail = left;
          left = left-&gt;next;
        } else {
          tail-&gt;next = right;
          tail = right;
          right = right-&gt;next;
        }
      }

      stack[si - 2] = merge;
      si--;
    }
  }

  while (si &gt; 1) /* Exact duplicate of code in loop--keep it this way! */
  {
    stack_n[si - 2] += stack_n[si - 1];

    left = stack[si - 2];
    right = stack[si - 1];
    if ((*leq)(left-&gt;data, right-&gt;data)) {
      merge = left;
      left = left-&gt;next;
    } else {
      merge = right;
      right = right-&gt;next;
    }
    merge-&gt;next = NULL;
    tail = merge;

    while (1) {
      if (left == NULL) {
        tail-&gt;next = right;
        break;
      }
      if (right == NULL) {
        tail-&gt;next = left;
        break;
      }

      if ((*leq)(left-&gt;data, right-&gt;data)) {
        tail-&gt;next = left;
        tail = left;
        left = left-&gt;next;
      } else {
        tail-&gt;next = right;
        tail = right;
        right = right-&gt;next;
      }
    }

    stack[si - 2] = merge;
    si--;
  }

  return stack[0];
}

/*************************************************************************
void_array_search:
  In: array of void pointers sorted by memory address
      length of the array
      void pointer we're trying to find
  Out: index of the void pointer in the array, or -1 if there is no
       matching pointer in the list
*************************************************************************/
int void_array_search(void **array, int n, void *to_find) {
  int lo = 0;
  int hi = n - 1;
  int m;
  while (hi - lo &gt; 1) {
    m = (hi + lo) / 2;
    if (to_find == array[m]) {
      return m;
    } else if ((intptr_t)to_find &gt; (intptr_t)array[m]) {
      lo = m;
    } else {
      hi = m;
    }
  }

  if (to_find == array[lo]) {
    return lo;
  }
  if (to_find == array[hi]) {
    return hi;
  }
  return -1;
}

/*************************************************************************
void_ptr_compare:
    Utility function to allow sorting an array of pointers by address.
    Conventions are appropriate for use with qsort.

  In: void const *v1 - first pointer
      void const *v2 - second pointer
  Out: -1, 0, or 1 as *(void **)v1 &lt;, =, or &gt; *(void **)v2 resp.
*************************************************************************/
int void_ptr_compare(void const *v1, void const *v2) {
  void const **v1p = (void const **)v1;
  void const **v2p = (void const **)v2;
  intptr_t i1 = (intptr_t) * v1p;
  intptr_t i2 = (intptr_t) * v2p;
  if (i1 &lt; i2) {
    return -1;
  } else if (i1 &gt; i2) {
    return 1;
  }
  return 0;
}

/*********************************************************************
allocate_uint_array:
   In: int size - length of the array to allocate
       u_int value - value with which to initialize elements
   Out: the newly allocated array, with all elements initialized to 'value'
***********************************************************************/
u_int *allocate_uint_array(int size, u_int value) {
  u_int *arr;
  if ((arr = CHECKED_MALLOC_ARRAY_NODIE(u_int, size, NULL)) == NULL) {
    return NULL;
  }
  for (int i = 0; i &lt; size; ++i) {
    arr[i] = value;
  }

  return arr;
}

/*********************************************************************
allocate_ptr_array:
    Allocate an array of pointers.  Use free_ptr_array to free if you want the
    pointers in the array to be freed as well.

        In: int size - length of the array to allocate
        Out: the newly allocated array, with all elements initialized to NULL.
***********************************************************************/
void **allocate_ptr_array(int size) {
  if (size == 0) {
    size = 1;
  }

  void **arr;
  if ((arr = CHECKED_MALLOC_ARRAY_NODIE(void *, size, NULL)) == NULL) {
    return NULL;
  }

  memset(arr, 0, size * sizeof(void *));
  return arr;
}

/*************************************************************************
free_ptr_array:
    Free an array of pointers, freeing any non-NULL pointers within the array.

        In:  void **pa - pointer array to free
             int count - length of pointer array
        Out: All non-NULL pointers in the array are freed, as is the array
             itself.
**************************************************************************/
void free_ptr_array(void **pa, int count) {
  for (int i = 0; i &lt; count; ++i) {
    if (pa[i] != NULL) {
      free(pa[i]);
    }
  }
  free(pa);
}

/*************************************************************************
free_num_expr_list:
    Free a num_expr_list.

        In:  struct num_expr_list *nlist - the list to free
        Out: All elements in the list are freed.
**************************************************************************/
void free_num_expr_list(struct num_expr_list *nlist) {
  struct num_expr_list *nnext;
  while (nlist != NULL) {
    nnext = nlist-&gt;next;
    free(nlist);
    nlist = nnext;
  }
}

/*************************************************************************
dir_exists:
    Utility to check if a given directory exists.

        In:  char const *path - absolute or relative path of dir
        Out: 1 if it's a directory, 0 if not
**************************************************************************/
int dir_exists(char const *path) {
#ifdef _MSC_VER // TODO
  release_assert(false);
  return false;
#else
  struct stat sb;
  if (stat(path, &amp;sb) == 0 &amp;&amp; S_ISDIR(sb.st_mode)) {
    return 1;
  }
  return 0;
#endif
}

/*************************************************************************
is_writable_dir:
    Utility to check if a given directory exists and is readable/writable.

        In:  char const *path - absolute or relative path of dir
        Out: 1 if writable, 0 if not
**************************************************************************/
int is_writable_dir(char const *path) {
#ifdef _MSC_VER // TODO
  release_assert(false);
  return false;
#else
  if (dir_exists(path) &amp;&amp; !access(path, R_OK | W_OK | X_OK)) {
    return 1;
  }
  return 0;
#endif
}

/*************************************************************************
make_parent_dir:
    Utility to make the (possibly nested) parent directory of a file.
    If the directory already exists. this function will
    return success.

        In:  char const *path - absolute or relative path of file
        Out: 0 on success, terminates with exit(1) on failure
**************************************************************************/
int make_parent_dir(char const *path) {
  FSUtils::make_dir_for_file_w_multiple_attempts(path);
  return 0;
}

/*************************************************************************
mkdirs:
    Utility to make a (possibly nested) directory.  Will attempt to create a
    directory with full rwx permission.  If the directory already exists and
    has rwx permission for the user, this function will return success.

        In:  char const *path - absolute or relative path for dir
        Out: 0 on success, 1 on failure
**************************************************************************/
int mkdirs(char const *path) {
  char *pathtmp = CHECKED_STRDUP(path, "directory path");
  char *curpos = pathtmp;

  /* we need to skip leading '/' in case we have absolute paths */
  while (curpos != NULL &amp;&amp; *curpos == '/') {
    ++curpos;
  }

  while (curpos != NULL) {
    /* Find next '/', turn it into '\0' */
    char *nextel = strchr(curpos, '/');
    if (nextel != NULL) {
      *nextel = '\0';
    }

    /* if this directory exists */
    if (dir_exists(pathtmp)) {
      /* Turn '\0' back to '/' */
      if (nextel) {
        *nextel = '/';
        curpos = nextel + 1;
      } else {
        curpos = NULL;
      }
      continue;
    }

    /* Make the directory */
    if (!is_writable_dir(pathtmp) &amp;&amp; mkdir(pathtmp, 0777) != 0) {
      mcell_perror_nodie(errno, "Failed to create directory '%s'", path);
      free(pathtmp);
      return 1;
    }

    /* Turn '\0' back to '/' */
    if (nextel) {
      *nextel = '/';
      curpos = nextel + 1;
    } else {
      curpos = NULL;
    }
  }
  free(pathtmp);

  return 0;
}

/*************************************************************************
open_file:
    Utility to open a file, printing a sensible error message if opening
    fails.
        In: char const *fname - filename for new file
            char const *mode - mode for file access
        Out: file handle for file, NULL on error
**************************************************************************/
FILE *open_file(const char *fname, const char *mode) {
  FILE *f;
  if ((f = fopen(fname, mode)) == NULL) {
    mcell_perror_nodie(errno, "Failed to open file %s.", fname);
    return NULL;
  }

  return f;
}

/*************************************************************************
erfcinv:

  Fast rational function approximation to inverse of the error function,
  based upon algorithm for inverse of Normal cumulative distribution
  function at http://home.online.no/~pjacklam/notes/invnorm/index.html
  by Peter J. Acklam. Accurate to about 4e-9 in absolute value.

  In: a value between 0 and 1 (not including endpoints)
  Out: the value y such that erfc(y) = input value
*************************************************************************/
double erfcinv(double x) {
  /* Misc constants */
  static const double tail_cutoff = 0.0485;
  static const double neg_twice_log_half = 1.386294361119891;
  // static const double sqrt_half_pi = 1.253314137315501;  /* For refinement */
  static const double scaling_const = -0.7071067811865475;

  /* Tail numerator */
  static const double tn0 = 2.938163982698783;
  static const double tn1 = 4.374664141464968;
  static const double tn2 = -2.549732539343734;
  static const double tn3 = -2.400758277161838;
  static const double tn4 = -3.223964580411365e-1;
  static const double tn5 = -7.784894002430293e-3;
  /* Tail denominator */
  static const double td1 = 3.754408661907416;
  static const double td2 = 2.445134137142996;
  static const double td3 = 3.224671290700398e-1;
  static const double td4 = 7.784695709041462e-3;

  /* Central numerator */
  static const double cn0 = 2.506628277459239;
  static const double cn1 = -3.066479806614716e1;
  static const double cn2 = 1.383577518672690e2;
  static const double cn3 = -2.759285104469687e2;
  static const double cn4 = 2.209460984245205e2;
  static const double cn5 = -3.969683028665376e1;
  /* Central denominator */
  static const double cd1 = -1.328068155288572e1;
  static const double cd2 = 6.680131188771972e1;
  static const double cd3 = -1.556989798598866e2;
  static const double cd4 = 1.615858368580409e2;
  static const double cd5 = -5.447609879822406e1;

  double p, q, r;

  if (x &lt; tail_cutoff) {
    p = sqrt(-2 * log(x) + neg_twice_log_half);
    r = (tn0 + p * (tn1 + p * (tn2 + p * (tn3 + p * (tn4 + p * tn5))))) /
        (1.0 + p * (td1 + p * (td2 + p * (td3 + p * td4))));
  } else {
    p = 0.5 * x - 0.5;
    q = p * p;
    r = p * (cn0 + q * (cn1 + q * (cn2 + q * (cn3 + q * (cn4 + q * cn5))))) /
        (1.0 + q * (cd1 + q * (cd2 + q * (cd3 + q * (cd4 + q * cd5)))));
  }
  return scaling_const * r;
  /*
  Use the code below to refine to macine precision.  Rather slow, though.
  p = (erfc(scaling_const*r)-x)*sqrt_half_pi*exp(0.5*r*r);
  return scaling_const*(r - p/(1 + r*p/2));
  */
}

/*************************************************************************
poisson_dist:
  In: mean value
      random number distributed uniformly between 0 and 1
  Out: integer sampled from the Poisson distribution.
  Note: This does not sample the CDF.  Instead, it works its way outwards
        from the peak of the PDF.  Kinda weird.  It is not the case
        that low values of the random number will give low values.  It
        is also not super-efficient, but it works.
*************************************************************************/
int poisson_dist(double lambda, double p) {
  int i, lo, hi;
  double plo, phi, pctr;
  double lambda_i;

  i = (int)lambda;
  pctr = exp(-lambda + i * log(lambda) -
             lgamma(i + 1)); /* Highest probability bin */

  if (p &lt; pctr)
    return i;

  lo = hi = i;
  plo = phi = pctr; /* Start at highest-probability bin and work outwards */

  p -= pctr;
  lambda_i = 1.0 / lambda;
  while (p &gt; 0) /* Keep going until we exhaust probabilities */
  {
    if (lo &gt; 0) /* We still have a low tail, test it */
    {
      plo *= lo * lambda_i; /* Recursive formula for p for this bin */
      lo--;
      if (p &lt; plo)
        return lo;
      p -= plo;
    }
    /* Always test the high tail (it's infinite) */
    hi++;
    phi = phi * lambda / hi; /* Recursive formula for p for this bin */
    if (p &lt; phi)
      return hi;
    p -= phi + DBL_EPSILON; /* Avoid infinite loop from poor roundoff */
  }

  /* should never get here */
  assert(false);
  return -1;
}

/*************************************************************************
byte_swap:
  In: array of bytes to be swapped
      size of this array
  Out: array of bytes swapped so that the last byte becomes the first one, etc.
       No return value
*************************************************************************/
void byte_swap(void *data, int size) {
  if (size &lt; 2){
    return;
  }

  unsigned char temp;
  unsigned char *c = (unsigned char *)data;
  for (int i = 0, j = size - 1; i &lt; j; i++, j--) {
    temp = c[i];
    c[i] = c[j];
    c[j] = temp;
  }
}

/************************************************************************\
                   Begin Rex's string matching code
\************************************************************************/

/*************************************************************************
  wild strings have wildcard characters * ? [...] and \ as an escape char
  feral strings have the same except no * character
  tame strings don't have any wildcard characters
*************************************************************************/

/* Measure the length of the tame string matched by a feral string of
 * length&lt;=n*/
int feral_strlenn(char *feral, int n) {
  int real_n = 0;
  int i;
  for (i = 0; i &lt; n; i++) {
    if (feral[i] == '\\') {
      i++;
      if (feral[i] == '\0')
        return real_n;
    } else if (feral[i] == '[') {
      while (i &lt; n &amp;&amp; feral[i] != ']') {
        if (feral[i] == '\0')
          return real_n;
        if (feral[i] == '\\') {
          i += 2;
          if (i &gt; n || feral[i - 1] == '\0')
            return real_n;
        } else if (feral[i] == '-') {
          i += 2;
          if (i &gt; n || feral[i - 1] == '\0')
            return real_n;
        } else
          i++;
      }
    } else if (feral[i] == '\0')
      return real_n;
    real_n++;
  }
  return real_n;
}

/* Check if the first n characters in the feral string is
an abbreviation for the tame string (i.e. matches the first
part of the tame string); return 0 if not found or the number
of matched characters if they are found */
int is_feral_nabbrev(char *feral, int n, char *tame) {
  char c, cc;
  int i = 0;
  int nfound = 0;
  int ok;

  if (n &lt;= 0)
    return 0;

  while (*tame != '\0') {
    if (feral[i] == '[') /* Try to match character set */
    {
      i++;
      ok = 0;
      while (i &lt; n &amp;&amp; feral[i] != ']') {
        c = feral[i++];
        if (c == '\0')
          return 0; /* Malformed feral string */
        if (c == '\\') {
          if (i &gt;= n)
            return 0; /* Malformed feral string */
          c = feral[i++];
          if (c == '\0')
            return 0; /* Malformed feral string */
        }
        if (i &lt; n &amp;&amp; feral[i] == '-') {
          i++;
          if (i &gt;= n)
            return 0; /* Malformed feral string */
          cc = feral[i++];
          if (cc == '\0')
            return 0; /* Malformed feral string */
          if (cc == '\\') {
            if (i &gt;= n)
              return 0; /* Malformed feral string */
            cc = feral[i++];
            if (cc == '\0')
              return 0; /* Malformed feral string */
          }
          if (c &lt;= *tame &amp;&amp; *tame &lt;= cc) {
            ok = 1;
            break;
          }
        } else if (c == *tame) {
          ok = 1;
          break;
        }
      }
      if (i &gt;= n)
        return 0; /* Malformed feral string */
      if (!ok)
        return 0;                      /* Set never matched */
      tame++;                          /* Matched */
      while (i &lt; n &amp;&amp; feral[i] != ']') /* Find trailing ] */
      {
        if (feral[i] == '\0')
          return 0; /* Malformed feral string */
        if (feral[i] == '\\') {
          i += 2;
          if (i &gt; n || feral[i - 1] == '\0')
            return 0; /* Malformed feral string */
        } else
          i++;
      }
      if (i &gt;= n)
        return 0; /* Malformed feral string */
      i++;
    } else /* Match single possibly escaped character */
    {
      c = feral[i++];
      if (c == '\\') {
        if (i &gt;= n)
          return 0; /* Malformed feral string */
        c = feral[i++];
        if (c != *tame++)
          return 0; /* Mismatch */
      } else if (c != *tame++ &amp;&amp; c != '?')
        return 0; /* Mismatch */
    }
    nfound++;
    if (i &gt;= n)
      return nfound; /* Ran out of feral string--it's an abbreviation! */
  }

  return 0; /* Ran out of tame string with feral string left--not abbrev */
}

/* Find a substring of a tame haystack string that matches the first n
characters of the feral string needle (same syntax as strstr except using
a feral string with a length delimiter). Returns NULL if matching substring not
found. */

char *feral_strstrn(char *tame_haystack, char *feral_needle, int n) {
  char c = 0;
  char cc;
  char set[256];
  int isset = 0;
  int i, j;
  int scoot = 0;

  for (i = 0; i &lt; n; i++)
    if (feral_needle[i] == '\0')
      break;
  n = i;

  /* Toss leading ?'s */
  i = 0;
  while (feral_needle[i] == '?' &amp;&amp; i &lt; n &amp;&amp; *tame_haystack != '\0') {
    i++;
    tame_haystack++;
    scoot++;
  }

  if (i &gt;= n)
    return tame_haystack - scoot;

  /* Beginning of needle is either a single character to match or a set of
   * characters */
  /* Efficiently search character set if it's first */
  if (feral_needle[i] == '[') {
    isset = 1;
    memset(set, 0, 256);
    set[0] = 1;
    i++;
    while (i &lt; n &amp;&amp; feral_needle[i] != ']') {
      c = feral_needle[i++];
      if (feral_needle[i] == '\0')
        return NULL; /* Can't match broken pattern */
      if (c == '\\') {
        if (i &gt;= n)
          return NULL; /* Can't match broken pattern */
        c = feral_needle[i++];
      }
      if (i &lt; n &amp;&amp; feral_needle[i] == '-') {
        i++;
        if (i &gt;= n)
          return NULL; /* Can't match broken pattern */
        cc = feral_needle[i++];
        if (cc == '\0')
          return NULL; /* Can't match broken pattern */
        if (cc == '\\') {
          if (i &gt;= n)
            return NULL; /* Can't match broken pattern */
          cc = feral_needle[i++];
          if (cc == '\0')
            return NULL; /* Can't match broken pattern */
        }
        for (j = (int)c; j &lt;= (int)cc; j++)
          set[j] = 1;
      } else
        set[(int)c] = 1;
    }
    if (i &gt;= n)
      return NULL; /* Can't match broken pattern */
    i++;           /* Skip ] */
  } else {
    c = feral_needle[i++];
    if (c == '\\') {
      if (i &gt;= n)
        return NULL; /* Can't match broken pattern */
      c = feral_needle[i++];
    }
    if (c == '\0')
      return NULL; /* Can't match broken pattern */
  }

  /* Match needle with haystack */
  while (*tame_haystack != '\0') {
    /* Try to match the first non-'?' character in needle with haystack */
    if (isset) /* Find next position in haystack that matches a set of
                  characters */
    {
      while (!set[(int)*tame_haystack])
        tame_haystack++;
      if (*tame_haystack == '\0')
        return NULL;
    } else /* Find next position in haystack that matches a single character */
    {
      while (*tame_haystack != c &amp;&amp; *tame_haystack != '\0')
        tame_haystack++;
      if (*tame_haystack == '\0')
        return NULL;
    }

    if (i == n)
      return tame_haystack - scoot;
    else if (is_feral_nabbrev(feral_needle + i, n - i,
                              tame_haystack + 1)) /* Try to match the rest of
                                                     the needle */
    {
      return tame_haystack - scoot;
    }

    tame_haystack++;
  }

  return NULL;
}

/* Returns 1 if the wildcard string wild matches the tame string tame */
int is_wildcard_match(char *wild, char *tame) {
  int nstars;
  int n;

  if (*wild == '\0' &amp;&amp; *tame == '\0')
    return 1;

  for (n = 0, nstars = 0; wild[n] != '\0'; n++) {
    if (wild[n] == '[') {
      n++;
      while (wild[n] != '\0' &amp;&amp; wild[n] != ']') {
        if (wild[n] == '\\') {
          n++;
          if (wild[n] == '\0')
            return 0; /* Malformed wild string */
        }
        n++;
      }
      if (wild[n] == '\0')
        return 0; /* Malformed wild string */
    } else if (wild[n] == '\\') {
      n++;
      if (wild[n] == '\0')
        return 0; /* Malformed wild string */
    } else if (wild[n] == '*')
      nstars++;
  }

  if (nstars == 0)
    return (is_feral_nabbrev(wild, n, tame) == (int)strlen(tame));
  else {
    std::vector&lt;int&gt; staridx;
    staridx.resize(nstars);
    std::vector&lt;int&gt; idxA;
    idxA.resize(nstars + 1);
    std::vector&lt;int&gt; idxB;
    idxB.resize(nstars + 1);

    char *m;
    int nidx;
    int i, j;
    int tail_len;
    int old_length;

    for (i = n = 0; wild[n] != '\0'; n++) {
      if (wild[n] == '[') {
        do {
          n++;
          if (wild[n] == '\\')
            n++;
        } while (wild[n] != ']');
      } else if (wild[n] == '\\')
        n++;
      else if (wild[n] == '*')
        staridx[i++] = n;
    }

    for (i = 0; i &lt; nstars &amp;&amp; staridx[i] == i; i++) {
    } /* Skip over '*'s at the beginning of wild string */

    if (i &gt;= nstars)
      return 1; /* All stars, of course it matches */

    if (i == 0) /* First character is not a star */
    {
      j = is_feral_nabbrev(wild, staridx[0], tame);
      if (j == 0)
        return 0; /* Didn't match start string */

      tame += j; /* Matched first j characters, toss them */

      wild += staridx[0]; /* And advance to star */
      n -= staridx[0];
      for (i = nstars - 1; i &gt;= 0; i--)
        staridx[i] -= staridx[0];
    }

    if (staridx[nstars - 1] &lt; n - 1) /* Last character is not a star */
    {
      j = staridx[nstars - 1] + 1;
      tail_len = feral_strlenn(wild + j, n - j);

      j = is_feral_nabbrev(wild + j, n - j, tame + (strlen(tame) - tail_len));
      if (j == 0)
        return 0; /* Didn't match tail string */
    } else
      tail_len = 0;

    /* Head and tail are matched, if any.  Now build rest of list to match */
    nidx = 0;
    for (i = 1; i &lt; nstars; i++) {
      idxA[nidx] = staridx[i - 1] + 1;
      idxB[nidx] = staridx[i];
      nidx++;
    }

    /* And now we match all the pieces */
    old_length = 0;
    m = tame;
    for (i = 0; i &lt; nidx; i++) {
      idxB[i] -= idxA[i]; /* Calculate length of feral string */

      if (idxB[i] == 0)
        continue; /* Just more stars */

      m = m + old_length;

      m = feral_strstrn(m, wild + idxA[i], idxB[i]);
      if (m == NULL)
        return 0; /* Couldn't find appropriate substring */
      old_length = feral_strlenn(wild + idxA[i], idxB[i]);
    }

    m = m + old_length;

    if (strlen(m) &lt; (size_t)tail_len)
      return 0; /* Ran over tail string--no good */

    return 1;
  }
}

/************************************************************************\
                    End Rex's string matching code
\************************************************************************/

/*************************************************************************
initialize_string_buffer:
  Initialize the state of a string buffer.

  In: struct string_buffer *sb - the string buffer
      int maxstr - the maximum number of strings to add to this buffer
  Out: 0 on success; 1 if allocation fails.  All fields in the buffer are
       filled in.
**************************************************************************/
int initialize_string_buffer(struct string_buffer *sb, int maxstr) {
  if (maxstr &gt; 0) {
    if ((sb-&gt;strings = (char **)allocate_ptr_array(maxstr)) == NULL)
      mcell_allocfailed("Failed to allocate buffer of %d strings.", maxstr);
  }

  sb-&gt;max_strings = maxstr;
  sb-&gt;n_strings = 0;
  return 0;
}

/*************************************************************************
destroy_string_buffer:
  Destroy the state of a string buffer.

  In: struct string_buffer *sb - the string buffer
  Out: The fields of the string buffer are freed, as are all strings
       added to the string buffer.  The string buffer itself is not freed.
**************************************************************************/
int destroy_string_buffer(struct string_buffer *sb) {
  if (sb-&gt;strings) {
    free_ptr_array((void **)sb-&gt;strings, sb-&gt;max_strings);
  }
  sb-&gt;strings = NULL;
  sb-&gt;max_strings = 0;
  sb-&gt;n_strings = 0;
  return 0;
}

/*************************************************************************
add_string_to_buffer:
    Add a string to the string buffer.  The string becomes "owned" by the
    buffer if this function is successful.  If this function fails, it is the
    caller's responsibility to free it.

        In: struct string_buffer *sb - the string buffer
            char *str - the string to add
        Out: 0 on success; 1 if the string is not stored because the buffer is
             full already.
**************************************************************************/
int add_string_to_buffer(struct string_buffer *sb, char *str) {
  if (sb-&gt;n_strings &gt;= sb-&gt;max_strings) {
    mcell_internal_error("Attempt to overrun string buffer (max fill is %d).",
                         sb-&gt;max_strings);
    /*return 1;*/
  }

  sb-&gt;strings[sb-&gt;n_strings++] = str;
  return 0;
}

/*******************************************************************
 Pointer hashes implementation
*******************************************************************/

/*************************************************************************
  Initialize a pointer hash to a given initial size.  Returns 0 on success.
  Note that the desired table size may be exceeded.  Presently, the
  implementation always rounds the table size up to the nearest integer power
  of two.

  In:  struct pointer_hash *ht - the hash table to initialize
       int size - the desired table size
  Out: 0 on success; 1 if memory allocation fails.
**************************************************************************/
int pointer_hash_init(struct pointer_hash *ht, int size) {
  assert(size &gt;= 0);

  memset(ht, 0, sizeof(struct pointer_hash));

  /* Don't allow size 0 tables.  Otherwise, the key &amp; (tablesize-1) trick fails
   * spectacularly. */
  if (size == 0) {
    ++size;
  }

  /* Fold size to next larger power of 2 if it isn't a power of 2 already */
  if ((size) &amp; (size - 1)) {
    size |= (size &gt;&gt; 1);
    size |= (size &gt;&gt; 2);
    size |= (size &gt;&gt; 4);
    size |= (size &gt;&gt; 8);
    size |= (size &gt;&gt; 16);
    ++size;
  }

  /* Initialize fields */
  ht-&gt;num_items = 0;
  ht-&gt;table_size = size;
  if ((ht-&gt;hashes = (unsigned int *)malloc(sizeof(unsigned int) *size)) ==
          NULL ||
      (ht-&gt;keys = (void const **)malloc(sizeof(void const *) *size)) == NULL ||
      (ht-&gt;values = (void **)malloc(sizeof(void *) * size)) == NULL)
    goto failure;

  /* Make sure our table starts out empty */
  memset(ht-&gt;hashes, 0, sizeof(unsigned int) * size);
  memset(ht-&gt;keys, 0, sizeof(void *) * size);
  memset(ht-&gt;values, 0, sizeof(void *) * size);

  return 0;

failure:
  pointer_hash_destroy(ht);
  return 1;
}

/*************************************************************************
  Destroy a pointer hash, freeing all memory associated with it.

  In:  struct pointer_hash *ht - the hash table to destroy
  Out: hash table is destroyed and associated memory is freed
**************************************************************************/
void pointer_hash_destroy(struct pointer_hash *ht) {
  if (ht-&gt;hashes)
    free(ht-&gt;hashes);
  if (ht-&gt;keys)
    free(ht-&gt;keys);
  if (ht-&gt;values)
    free(ht-&gt;values);
  ht-&gt;num_items = 0;
  ht-&gt;table_size = 0;
  ht-&gt;hashes = NULL;
  ht-&gt;keys = NULL;
  ht-&gt;values = NULL;
}

/*************************************************************************
  Manually resize a pointer hash to have at least 'new_size' bins.  New size
  may exceed requested size.  Works exactly like pointer_hash_init, except
  values are copied from the old table to the new one.

  In:  struct pointer_hash *ht - the hash table to resize
       int new_size - the desired table size
  Out: 0 on success; 1 if memory allocation fails.

  On failure, the hash table is left unchanged from its prior state.
**************************************************************************/
int pointer_hash_resize(struct pointer_hash *ht, int new_size) {
  if (new_size == ht-&gt;table_size)
    return 0;
  if (new_size &lt; ht-&gt;num_items)
    return 1;

  /* Save old hash, allocate new hash */
  struct pointer_hash old = *ht;
  if (pointer_hash_init(ht, new_size)) {
    *ht = old;
    return 1;
  }

  /* Copy items over to new hash */
  for (int old_item_idx = 0; old_item_idx &lt; old.table_size; ++old_item_idx) {
    if (old.keys[old_item_idx] == NULL)
      continue;

    if (pointer_hash_add(ht, old.keys[old_item_idx], old.hashes[old_item_idx],
                         old.values[old_item_idx]))
      goto failure;
  }

  /* Destroy the old hash */
  pointer_hash_destroy(&amp;old);
  return 0;

failure:
  pointer_hash_destroy(ht);
  *ht = old;
  return 1;
}

/*************************************************************************
  Add a value to a pointer hash.  If a previous item was added for that key,
  the new value will replace the old value.

  In:  struct pointer_hash *ht - the hash table to receive a new item
       void const *key - the key
       unsigned int keyhash - the hash value associated with the key
       void *value - the value to store
  Out: 0 on success; 1 if memory allocation fails.
**************************************************************************/
int pointer_hash_add(struct pointer_hash *ht, void const *key,
                     unsigned int keyhash, void *value) {
  /* In case pointer hash was initialized using memset, we'll allocate space
   * on-demand.  */
  if (ht-&gt;table_size == 0) {
    if (pointer_hash_resize(ht, 2))
      return 1;
  }

  /* Make sure our table always has free space */
  if (ht-&gt;num_items &gt;= (ht-&gt;table_size &gt;&gt; 1)) {
    if (pointer_hash_resize(ht, ht-&gt;table_size &lt;&lt; 1))
      return 1;
  }

  /* Scan over entries until the end of the table */
  unsigned int start_index = keyhash &amp; (ht-&gt;table_size - 1);
  for (unsigned int i = 0; i &lt; (unsigned int)ht-&gt;table_size; i++) {
    unsigned int cur_index = (start_index + i) &amp; (ht-&gt;table_size - 1);

    /* Found an old value for this key.  Replace it.  Do not increment the item
     * count. */
    if (ht-&gt;keys[cur_index] == key) {
      ht-&gt;values[cur_index] = value;
      return 0;
    }

    /* Found an empty slot.  Fill it. */
    if (ht-&gt;keys[cur_index] == NULL) {
      ht-&gt;hashes[cur_index] = keyhash;
      ht-&gt;keys[cur_index] = key;
      ht-&gt;values[cur_index] = value;
      goto done;
    }
  }

  /* This shouldn't happen unless the pointer hash is corrupted, since we've
   * already ensured that we have enough space */
  return 1;

done:
  ++ht-&gt;num_items;
  return 0;
}

/*************************************************************************
  Look up a value in a pointer hash.  Returns default_value if no item was
  found, or if the value associated with the key was default_value.

  In:  struct pointer_hash *ht - the hash table to search
       void const *key - the key to find
       unsigned int keyhash - the hash value associated with the key
       void const *default_value - value to return if item is not found
  Out: the value, or default_value if not found
**************************************************************************/
void *pointer_hash_lookup_ext(struct pointer_hash const *ht, void const *key,
                              unsigned int keyhash, void *default_value) {
  /* Empty table.  Not found. */
  if (ht-&gt;table_size == 0)
    return default_value;

  /* Search from start position to end of table */
  unsigned int start_index = keyhash &amp; (ht-&gt;table_size - 1);
  for (unsigned int i = 0; i &lt; (unsigned int)ht-&gt;table_size; i++) {
    unsigned int cur_index = (start_index + i) &amp; (ht-&gt;table_size - 1);

    /* Empty slot - key not found. */
    if (ht-&gt;keys[cur_index] == NULL)
      return default_value;

    /* Found our value. */
    if (ht-&gt;keys[cur_index] == key)
      return ht-&gt;values[cur_index];
  }

  /* Worst case scenario.  We searched the entire table.  Shouldn't happen with
   * the current tuning parameters, which do not permit the table to be full.
   */
  return default_value;
}

/*************************************************************************
  Remove a value from a pointer hash.  Returns 0 if the item was
  successfully removed, or 0 if the item was not found.  Note that a
  NULL key is not allowed in a pointer hash.

  In:  struct pointer_hash *ht - the hash table to remove from
       void const *key - the key to remove
       unsigned int keyhash - the hash value associated with the key
  Out: 0 on success; 1 on failure

  Regardless of success or failure, the table will remain in a valid
  state.
**************************************************************************/
int pointer_hash_remove(struct pointer_hash *ht, void const *key,
                        unsigned int keyhash) {
  /* If the key is NULL, we're done */
  if (key == NULL)
    return 1;

  /* If the table is empty, we're done */
  if (ht-&gt;table_size == 0)
    return 1;

  int start = keyhash &amp; (ht-&gt;table_size - 1); /* Where do we start? */
  int next_slot = -1;                         /* Next vacant slot to fill */

  /* Scan through the table to remove the item, and resituate any
   * entries which would, due to the streaming collision-avoidance
   * approach, be orphaned.
   */
  int cur = start;
  do {
    /* If we found the item to remove, remove it */
    if (key != NULL &amp;&amp; ht-&gt;keys[cur] == key) {
      /* Clear this value */
      ht-&gt;keys[cur] = NULL;
      ht-&gt;values[cur] = NULL;
      ht-&gt;hashes[cur] = 0;
      --ht-&gt;num_items;

      if (ht-&gt;table_size &gt; (ht-&gt;num_items &lt;&lt; 2)) {
        /* If resizing the pointer hash succeeded, we don't need to do
         * any more work, since it will have prevented orphans. */
        if (!pointer_hash_resize(ht, ht-&gt;num_items &lt;&lt; 1))
          return 0;
      }

      /* We may need to move something into this empty slot, so
       * remember where we were. */
      next_slot = cur;

      /* This indicates that we've already removed the value and are
       * now just fixing the table contents */
      key = NULL;
    }

    /* We found a NULL entry, so stop scanning -- the table is in a
     * valid state */
    else if (ht-&gt;keys[cur] == NULL) {
      if (key == NULL)
        return 0;
      else
        return 1;
    }

    /* This entry may need to be reseated */
    else if (next_slot != -1) {
      /* This is the slot where we'd start looking for this entry */
      int desiredSlot = ht-&gt;hashes[cur] &amp; (ht-&gt;table_size - 1);

      /* If we would have hit our newly introduced NULL entry after we
       * started searching for this entry, but before we found what we
       * were looking for, resituate this entry.
       */
      if ((next_slot &lt; cur &amp;&amp;
           (desiredSlot &lt;= next_slot || desiredSlot &gt; cur)) ||
          (next_slot &gt; cur &amp;&amp;
           (desiredSlot &lt;= next_slot &amp;&amp; desiredSlot &gt; cur))) {
        /* Move this entry to its new location */
        ht-&gt;hashes[next_slot] = ht-&gt;hashes[cur];
        ht-&gt;keys[next_slot] = ht-&gt;keys[cur];
        ht-&gt;values[next_slot] = ht-&gt;values[cur];

        /* Free this slot */
        ht-&gt;hashes[cur] = 0;
        ht-&gt;keys[cur] = NULL;
        ht-&gt;values[cur] = NULL;

        /* We may need to move something into this empty slot, so
         * remember where we were. */
        next_slot = cur;
      }
    }

    /* Advance to the next entry */
    if (++cur == ht-&gt;table_size)
      cur = 0;
  } while (cur != start);

  /* If we found our entry, success, else failure. */
  if (key == NULL)
    return 0;
  else
    return 1;
}

/*************************************************************************
remove_both_duplicates:
  In: sorted linked list containing void pointers
  Out: if linked list contains two duplicates they are both removed
       Returns number of unique items in the linked list
       after removal
  Note: linked list should be sorted in advance.
        Also this function is used in the way that we do not expect more
        than two duplicates.
        Example: input = (a,b,c,d,d, e,f,g)
                 output = (a,b,c,e,f,g)
*************************************************************************/
int remove_both_duplicates(struct void_list **head) {
  struct void_list *curr = *head, *tmp, *prev, *next_Next;
  int count = 0;

  tmp = curr;
  prev = NULL;
  while ((tmp != NULL) &amp;&amp; (tmp-&gt;next != NULL)) {
    if (tmp-&gt;data == tmp-&gt;next-&gt;data) {
      next_Next = tmp-&gt;next-&gt;next;
      free(tmp-&gt;next);
      free(tmp);
      tmp = next_Next;
      if (prev != NULL) {
        prev-&gt;next = tmp;
      } else {
        curr = tmp;
      }
    } else {
      prev = tmp;
      tmp = tmp-&gt;next; /* only advance if there is no deletion */
    }
  }

  *head = curr;

  for (tmp = *head; tmp != NULL; tmp = tmp-&gt;next) {
    count++;
  }

  return count;
}

/*********************************************************************
delete_void_list:
  In: linked list
  Out: none.  The memory is freed.
*********************************************************************/
void delete_void_list(struct void_list *head) {
  struct void_list *nnext;
  while (head != NULL) {
    nnext = head-&gt;next;
    free(head);
    head = nnext;
  }
}


/*************************************************************************
 double_cmp:
    Comparison function for doubles, to be passed to qsort.

 In:  i1: first item for comparison
      i2: second item for comparison
 Out: -1, 0, or 1 if the first item is less than, equal to, or greater than the
      second, resp.
*************************************************************************/
int double_cmp(void const *i1, void const *i2) {
  double const *d1 = (double const *)i1;
  double const *d2 = (double const *)i2;
  if (*d1 &lt; *d2)
    return -1;
  else if (*d1 &gt; *d2)
    return 1;
  else
    return 0;
}

/**************************************************************************
is_string_present_in_string_array:
  In: string "str"
      array of strings "strings"
      length of the array of strings "length"
  Out: Return 1 if string "str" is present in the array of strings "strings",
       and 0 otherwise.
**************************************************************************/
int is_string_present_in_string_array(const char * str, char ** strings, int length)
{
  int found = 0, i;

  for (i = 0; i &lt; length; i++) {
    if (strcmp(str, strings[i]) == 0) {
      found = 1;
      break;
    }
  }

  return found;
}

/******************************************************************************
 convert_seconds_to_iterations:

 Converts time in seconds to iterations. This is offset by the number of
 iterations at the start of the simulation, which is usually 0 unless you're
 checkpointing. Alternatively, this function could be thought of as converting
 seconds to the internal/scaled time (i.e. the time in units of the timestep),
 but this doesn't really make sense if one changes the timestep during a
 checkpointing event (e.g. 1e-6 to 1e-7 seconds).
 *****************************************************************************/
double convert_seconds_to_iterations(
    long long start_iterations,
    double time_step_seconds,
    double simulation_start_seconds,
    double seconds) {
  double delta_iterations =
    (seconds - simulation_start_seconds) / time_step_seconds;
  return (start_iterations + delta_iterations);
}

/******************************************************************************
 convert_iterations_to_seconds:
 
 As you might imagine, this is essentially the inverse of
 convert_seconds_to_iterations.

 NOTE: Do not use iteration values that happened in the past or delta iteration
 values. Only input values that are greater the starting number of iterations
 In other words, use either the current number of iterations or some number
 corresponding to some time in the future.
 *****************************************************************************/
double convert_iterations_to_seconds(
    long long start_iterations,
    double time_step_seconds,
    double simulation_start_seconds,
    double iterations) {
  // Probably should add an assert here
  double delta_time = (iterations - start_iterations) * time_step_seconds;
  return (simulation_start_seconds + delta_time);
}

/*************************************************************************
 generate_range:
    Generate a num_expr_list containing the numeric values from start to end,
    incrementing by step.

 In:  state: the simulation state
      list:  destination to receive list of values
      start: start of range
      end:   end of range
      step:  increment
 Out: 0 on success, 1 on failure.  On success, list is filled in.
*************************************************************************/
int generate_range(struct num_expr_list_head *list, double start, double end,
                   double step) {
  list-&gt;value_head = NULL;
  list-&gt;value_tail = NULL;
  list-&gt;value_count = 0;
  list-&gt;shared = 0;

  if (step &gt; 0) {
    /* JW 2008-03-31: In the guard on the loop below, it seems to me that
     * the third condition is redundant with the second.
     */
    for (double tmp_dbl = start;
         tmp_dbl &lt; end || !distinguishable(tmp_dbl, end, EPS_C) ||
             fabs(end - tmp_dbl) &lt;= EPS_C;
         tmp_dbl += step) {
      if (advance_range(list, tmp_dbl))
        return 1;
    }
  } else /* if (step &lt; 0) */
  {
    /* JW 2008-03-31: In the guard on the loop below, it seems to me that
     * the third condition is redundant with the second.
     */
    for (double tmp_dbl = start;
         tmp_dbl &gt; end || !distinguishable(tmp_dbl, end, EPS_C) ||
             fabs(end - tmp_dbl) &lt;= EPS_C;
         tmp_dbl += step) {
      if (advance_range(list, tmp_dbl))
        return 1;
    }
  }

  // MCell4
  list-&gt;start_end_step_set = true;
  list-&gt;start = start;
  list-&gt;end = end;
  list-&gt;step = step;

  return 0;
}

// Maybe move this somewhere else
int advance_range(struct num_expr_list_head *list, double tmp_dbl) {
  struct num_expr_list *nel;
  nel = CHECKED_MALLOC_STRUCT(struct num_expr_list, "numeric list");
  if (nel == NULL) {
    free_numeric_list(list-&gt;value_head);
    list-&gt;value_head = list-&gt;value_tail = NULL;
    return 1;
  }
  nel-&gt;value = tmp_dbl;
  nel-&gt;next = NULL;

  ++list-&gt;value_count;
  if (list-&gt;value_tail != NULL)
    list-&gt;value_tail-&gt;next = nel;
  else
    list-&gt;value_head = nel;
  list-&gt;value_tail = nel;
  return 0;
}

/*************************************************************************
 free_numeric_list:
    Free a num_expr_list.

 In:  nel:  the list to free
 Out: all elements are freed
*************************************************************************/
void free_numeric_list(struct num_expr_list *nel) {
  while (nel != NULL) {
    struct num_expr_list *n = nel;
    nel = nel-&gt;next;
    free(n);
  }
}


#define hashsize(n) ((ub4)1 &lt;&lt; (n))

/* ================ Bob Jenkin hash function ======================== */

/*--------------------------------------------------------------------
mix -- mix 3 32-bit values reversibly.
For every delta with one or two bits set, and the deltas of all three
  high bits or all three low bits, whether the original value of a,b,c
  is almost all zero or is uniformly distributed,
* If mix() is run forward or backward, at least 32 bits in a,b,c
  have at least 1/4 probability of changing.
* If mix() is run forward, every bit of c will change between 1/3 and
  2/3 of the time.  (Well, 22/100 and 78/100 for some 2-bit deltas.)
mix() was built out of 36 single-cycle latency instructions in a
  structure that could supported 2x parallelism, like so:
      a -= b;
      a -= c; x = (c&gt;&gt;13);
      b -= c; a ^= x;
      b -= a; x = (a&lt;&lt;8);
      c -= a; b ^= x;
      c -= b; x = (b&gt;&gt;13);
      ...
  Unfortunately, superscalar Pentiums and Sparcs can't take advantage
  of that parallelism.  They've also turned some of those single-cycle
  latency instructions into multi-cycle latency instructions.  Still,
  this is the fastest good hash I could find.  There were about 2^^68
  to choose from.  I only looked at a billion or so.
--------------------------------------------------------------------*/

#define mix(a, b, c)                                                           \
  {                                                                            \
    a -= b;                                                                    \
    a -= c;                                                                    \
    a ^= (c &gt;&gt; 13);                                                            \
    b -= c;                                                                    \
    b -= a;                                                                    \
    b ^= (a &lt;&lt; 8);                                                             \
    c -= a;                                                                    \
    c -= b;                                                                    \
    c ^= (b &gt;&gt; 13);                                                            \
    a -= b;                                                                    \
    a -= c;                                                                    \
    a ^= (c &gt;&gt; 12);                                                            \
    b -= c;                                                                    \
    b -= a;                                                                    \
    b ^= (a &lt;&lt; 16);                                                            \
    c -= a;                                                                    \
    c -= b;                                                                    \
    c ^= (b &gt;&gt; 5);                                                             \
    a -= b;                                                                    \
    a -= c;                                                                    \
    a ^= (c &gt;&gt; 3);                                                             \
    b -= c;                                                                    \
    b -= a;                                                                    \
    b ^= (a &lt;&lt; 10);                                                            \
    c -= a;                                                                    \
    c -= b;                                                                    \
    c ^= (b &gt;&gt; 15);                                                            \
  }
/*--------------------------------------------------------------------
hash() -- hash a variable-length key into a 32-bit value
  k       : the key (the unaligned variable-length array of bytes)
  len     : the length of the key, counting by bytes
  initval : can be any 4-byte value
Returns a 32-bit value.  Every bit of the key affects every bit of
the return value.  Every 1-bit and 2-bit delta achieves avalanche.
About 6*len+35 instructions.

The best hash table sizes are powers of 2.  There is no need to do
mod a prime (mod is sooo slow!).  If you need less than 32 bits,
use a bitmask.  For example, if you need only 10 bits, do
  h = (h &amp; hashmask(10));
In which case, the hash table should have hashsize(10) elements.

If you are hashing n strings (ub1 **)k, do it like this:
  for (i=0, h=0; i&lt;n; ++i) h = hash(k[i], len[i], h);

By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this
code any way you wish, private, educational, or commercial.  It's free.

See http://burtleburtle.net/bob/hash/evahash.html
Use for hash table lookup, or anything where one collision in 2^^32 is
acceptable.  Do NOT use for cryptographic purposes.
--------------------------------------------------------------------*/

ub4 jenkins_hash(ub1 *k, ub4 length) {
  ub4 a, b, c, len, initval;
  /* Set up the internal state */
  initval = 0;
  len = length;
  a = b = 0x9e3779b9; /* the golden ratio; an arbitrary value */
  c = initval;        /* the previous hash value */
  length++;
  /*---------------------------------------- handle most of the key */
  while (len &gt;= 12) {
    a += (k[0] + ((ub4)k[1] &lt;&lt; 8) + ((ub4)k[2] &lt;&lt; 16) + ((ub4)k[3] &lt;&lt; 24));
    b += (k[4] + ((ub4)k[5] &lt;&lt; 8) + ((ub4)k[6] &lt;&lt; 16) + ((ub4)k[7] &lt;&lt; 24));
    c += (k[8] + ((ub4)k[9] &lt;&lt; 8) + ((ub4)k[10] &lt;&lt; 16) + ((ub4)k[11] &lt;&lt; 24));
    mix(a, b, c);
    k += 12;
    len -= 12;
  }

  /*------------------------------------- handle the last 11 bytes */
  c += length;
  switch (len) /* all the case statements fall through */
  {
  case 11:
    c += ((ub4)k[10] &lt;&lt; 24); /* fallthrough */
  case 10:
    c += ((ub4)k[9] &lt;&lt; 16); /* fallthrough */
  case 9:
    c += ((ub4)k[8] &lt;&lt; 8); /* fallthrough */
  /* the first byte of c is reserved for the length */
  case 8:
    b += ((ub4)k[7] &lt;&lt; 24); /* fallthrough */
  case 7:
    b += ((ub4)k[6] &lt;&lt; 16); /* fallthrough */
  case 6:
    b += ((ub4)k[5] &lt;&lt; 8); /* fallthrough */
  case 5:
    b += k[4]; /* fallthrough */
  case 4:
    a += ((ub4)k[3] &lt;&lt; 24); /* fallthrough */
  case 3:
    a += ((ub4)k[2] &lt;&lt; 16); /* fallthrough */
  case 2:
    a += ((ub4)k[1] &lt;&lt; 8); /* fallthrough */
  case 1:
    a += k[0]; /* fallthrough */
    /* case 0: nothing left to add */
  }
  mix(a, b, c);
  /*-------------------------------------------- report the result */
  return (c);
}


// initializer list for rusage causes many compilation warnings when used
void reset_rusage(rusage* r) {
  r-&gt;ru_utime.tv_sec = 0;
  r-&gt;ru_utime.tv_usec = 0;
  r-&gt;ru_stime.tv_sec = 0;
  r-&gt;ru_stime.tv_usec = 0;
}



#ifdef _MSC_VER
int _win_rename(const char *old, const char *new_name) {
  DWORD dwAttrib = GetFileAttributes(new_name);
  if (dwAttrib != INVALID_FILE_ATTRIBUTES &amp;&amp;
      !(dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY)) {
    /* new_name file exists */
    if (ReplaceFile(new_name, old, NULL, REPLACEFILE_WRITE_THROUGH, NULL, NULL)) {
      return 0;
    }
    /* fixme: set errno based on GetLastError() [possibly doing some filtering
     * before] */
    errno = EACCES;
    return -1;
  } else {
    return rename(old, new_name);
  }
}
#endif

</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
