<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for react_outc_nfsim.c &amp; util.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc_nfsim.c &amp; util.c
      </h3>
<h1 align="center">
        2.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc_nfsim.c (4.428571%)<th>util.c (1.4265991%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(406-425)<td><a href="#" name="0">(169-179)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(209-226)<td><a href="#" name="1">(325-331)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc_nfsim.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;assert.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "count_util.h"
#include "grid_util.h"
#include "logging.h"
#include "mcell_reactions.h"
#include "nfsim_func.h"
#include "react.h"
#include "react_nfsim.h"
#include "react_util.h"
#include "rng.h"
#include "util.h"
#include "vol_util.h"
#include "wall_util.h"
static queryOptions
initializeNFSimQueryforUnimolecularFiring(struct abstract_molecule *am,
                                          const char *external_path);
static bool calculate_nfsim_reactivity(struct graph_data *);
static void calculate_nfsim_diffusion_derived_data(struct volume *state,
                                                   struct graph_data *data);
void set_nfsim_product_geometries(struct pathway *path, struct rxn *rx,
                                  int prod_orientation, int prod_index) {
  if ((prod_orientation + path-&gt;orientation1) *
              (prod_orientation - path-&gt;orientation1) ==
          0 &amp;&amp;
      prod_orientation * path-&gt;orientation1 != 0) {
    if (prod_orientation == path-&gt;orientation1)
      rx-&gt;geometries[prod_index] = 1;
    else
      rx-&gt;geometries[prod_index] = -1;
  } else if (rx-&gt;n_reactants &gt; 1 &amp;&amp;
             (prod_orientation + path-&gt;orientation2) *
                     (prod_orientation - path-&gt;orientation2) ==
                 0 &amp;&amp;
             prod_orientation * path-&gt;orientation2 != 0) {
    if (prod_orientation == path-&gt;orientation2)
      rx-&gt;geometries[prod_index] = 2;
    else
      rx-&gt;geometries[prod_index] = -2;
  } else {
    rx-&gt;geometries[prod_index] = 1;
  }
}
queryOptions initializeNFSimQueryNoFiring(struct abstract_molecule *am) {
  queryOptions options;
  static const char *optionKeys[1] = {"systemQuery"};
  options.optionValues = CHECKED_MALLOC_ARRAY(char *, 1, "option array");
  options.optionValues[0] = strdup("complex");
  char **speciesArray =
      CHECKED_MALLOC_ARRAY(char *, 1, "string array of patterns");
  speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;
  static const int optionSeeds[1] = {1};
  options.initKeys = speciesArray;
  options.initValues = optionSeeds;
  options.numOfInitElements = 1;
  options.optionKeys = optionKeys;
  options.numOfOptions = 1;
  return options;
}
queryOptions
initializeNFSimQueryforUnimolecularFiring(struct abstract_molecule *am,
                                          const char *external_path) {
  queryOptions options;
  static const char *optionKeys[2] = {"systemQuery", "reaction"};
  options.optionValues = CHECKED_MALLOC_ARRAY(char *, 2, "option array");
  options.optionValues[0] = strdup("complex");
  options.optionValues[1] = strdup(external_path);
  char **speciesArray =
      CHECKED_MALLOC_ARRAY(char *, 1, "string array of patterns");
  speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;
  static const int optionSeeds[1] = {1};
  options.initKeys = speciesArray;
  options.initValues = optionSeeds;
  options.numOfInitElements = 1;
  options.optionKeys = optionKeys;
  options.numOfOptions = 2;
  return options;
}
queryOptions
initializeNFSimQueryforBimolecularFiring(struct abstract_molecule *am,
                                         struct abstract_molecule *am2,
                                         const char *external_path) {
  queryOptions options;
  static const char *optionKeys[2] = {"systemQuery", "reaction"};
  options.optionValues = CHECKED_MALLOC_ARRAY(char *, 2, "option array");
  options.optionValues[0] = strdup("complex");
  options.optionValues[1] = strdup(external_path);
  char **speciesArray =
      CHECKED_MALLOC_ARRAY(char *, 2, "string array of patterns");
  speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;
  speciesArray[1] = am2-&gt;graph_data-&gt;graph_pattern;
  static const int optionSeeds[2] = {1, 1};
  options.initKeys = speciesArray;
  options.initValues = optionSeeds;
  options.numOfInitElements = 2;
  options.optionKeys = optionKeys;
  options.numOfOptions = 2;
  return options;
}
static void find_objects(struct geom_object* current_parent,
                  const char* name1, struct geom_object** obj1,
                  const char* name2, struct geom_object** obj2) {
  struct geom_object* curr = current_parent;
  while (curr != NULL) {
    if (*obj1 == NULL &amp;&amp; curr-&gt;last_name != NULL &amp;&amp; strcmp(curr-&gt;last_name, name1) == 0) {
      *obj1 = curr;
    }
    if (*obj2 == NULL &amp;&amp; curr-&gt;last_name != NULL &amp;&amp; strcmp(curr-&gt;last_name, name2) == 0) {
      *obj2 = curr;
    }
    if (*obj1 != NULL &amp;&amp; *obj2 != NULL) {
      return;
    }
    find_objects(curr-&gt;first_child, name1, obj1, name2, obj2);
    curr = curr-&gt;next;
  }
}
static bool has_region(struct geom_object* obj, const char* reg_name) {
  for (struct region_list *r = obj-&gt;regions; r != NULL; r = r-&gt;next) {
    if (r-&gt;reg != NULL &amp;&amp; strcmp(r-&gt;reg-&gt;region_last_name, reg_name) == 0) {
      return true;
    }
  }
  return false;
}
int prepare_reaction_nfsim(struct volume *world, struct rxn *rx, void *results,
                           int path, struct abstract_molecule *reac,
                           struct abstract_molecule *reac2) {
<a name="1"></a>
  const char *product_pattern = NULL;
  void *individualResult;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  int numOfResults = mapvector_size(results);
  for (int productIdx = 0; productIdx &lt; numOfResults; productIdx++) {
    individualResult = mapvector_get(results, productIdx);
    product_pattern = map_get(individualResult,
                              "label");     constructNauty_c(product_pattern, 1);
  }
  rx-&gt;product_idx_aux[path] = numOfResults;
  if (rx-&gt;nfsim_players[path] == NULL) {</b></font>
    rx-&gt;nfsim_players[path] = CHECKED_MALLOC_ARRAY(
        struct species *, numOfResults, "reaction players array");
    rx-&gt;nfsim_geometries[path] = CHECKED_MALLOC_ARRAY(
        short, numOfResults, "geometries associated to this path");
  }
  rx-&gt;product_graph_data[path] = CHECKED_MALLOC_ARRAY(
      struct graph_data *, rx-&gt;product_idx_aux[path],
      "graph patterns for products that have been added to the system");
  int counter = 0;
  const char *diffusion;
  rx-&gt;external_reaction_data[path].products = numOfResults;
  for (int productIdx = 0; productIdx &lt; numOfResults; productIdx++) {
    individualResult = mapvector_get(results, productIdx);
    product_pattern = map_get(individualResult,
                              "label"); 
    unsigned long graph_hash = lhash(product_pattern);
    int error =
        get_graph_data(graph_hash, &amp;rx-&gt;product_graph_data[path][counter]);
    if (error != 0) {
      rx-&gt;product_graph_data[path][counter] = CHECKED_MALLOC_ARRAY(
          struct graph_data, 1, "graph pattern for a single path");
      rx-&gt;product_graph_data[path][counter]-&gt;graph_pattern =
          strdup(product_pattern);
      rx-&gt;product_graph_data[path][counter]-&gt;graph_pattern_hash =
          lhash(product_pattern);
      diffusion = map_get(individualResult, "diffusion_function");
      if (diffusion) {
        rx-&gt;product_graph_data[path][counter]-&gt;graph_diffusion =
            atof(diffusion);
        calculate_nfsim_diffusion_derived_data(
            world, rx-&gt;product_graph_data[path][counter]);
      } else {
        rx-&gt;product_graph_data[path][counter]-&gt;graph_diffusion = -1;
        rx-&gt;product_graph_data[path][counter]-&gt;time_step = -1;
        rx-&gt;product_graph_data[path][counter]-&gt;space_step = -1;
      }
      calculate_nfsim_reactivity(rx-&gt;product_graph_data[path][counter]);
      store_graph_data(graph_hash, rx-&gt;product_graph_data[path][counter]);
      world-&gt;n_NFSimSpecies += 1;
    }
    counter++;
  }
  int num_players = rx-&gt;n_reactants;
  int kk = rx-&gt;n_pathways;
  if (kk &lt;= RX_SPECIAL)
    kk = 1;
  for (int n_pathway = 0; n_pathway &lt; kk; n_pathway++) {
    int k = rx-&gt;product_idx_aux[n_pathway] + rx-&gt;n_reactants;
    rx-&gt;product_idx[n_pathway] = num_players;
    num_players += k;
  }
  rx-&gt;product_idx[kk] = num_players;
  if (rx-&gt;players != NULL)
    free(rx-&gt;players);
  free(rx-&gt;geometries);
  rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
                                     "reaction players array");
  rx-&gt;geometries =
      CHECKED_MALLOC_ARRAY(short, num_players, "reaction geometries array");
  memset(rx-&gt;players, 0, sizeof(struct species *) * num_players);
  memset(rx-&gt;geometries, 0, sizeof(short) * num_players);
  struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
      struct pathway, "reaction pathway");
  if (pathp == NULL) {
    return -1;
  }
  memset(pathp, 0, sizeof(struct pathway));
  int num_vol_mols = 0;
  int num_surface_mols = 0;
  int all_3d = 1;
  int reactant_idx = 0;
  int oriented_count = 0;
  bool orientation_flag1 = 0, orientation_flag2 = 0;
  int reactantOrientation1, reactantOrientation2, productOrientation;
  calculate_reactant_orientation(reac, reac2, &amp;orientation_flag1,
                                 &amp;orientation_flag2, &amp;reactantOrientation1,
                                 &amp;reactantOrientation2);
  struct sym_entry *nfsim_molecule = reac-&gt;properties-&gt;sym;
  rx-&gt;geometries[0] = reactantOrientation1;
  struct mcell_species *reactants = mcell_add_to_species_list(
      nfsim_molecule, orientation_flag1, reactantOrientation1, NULL);
  if (reac2 != NULL) {
    rx-&gt;geometries[1] = reactantOrientation2;
    nfsim_molecule = reac2-&gt;properties-&gt;sym;
    reactants = mcell_add_to_species_list(nfsim_molecule, orientation_flag2,
                                          reactantOrientation2, reactants);
  }
  compartmentStruct *compartmentInfoArray =
      CHECKED_MALLOC_ARRAY(compartmentStruct, numOfResults,
                           "Creating array of compartment information");
  for (int i = 0; i &lt; numOfResults; i++) {
    individualResult = mapvector_get(results, i);
    compartmentInfoArray[i] = getCompartmentInformation_c(map_get(
        individualResult,
        "compartment"));   }
  struct species *nfsim_molecule_template;
  if (compartmentInfoArray[0].spatialDimensions == 2)
    nfsim_molecule_template = world-&gt;global_nfsim_surface;
  else
    nfsim_molecule_template = world-&gt;global_nfsim_volume;
  if (orientation_flag2) {
    orientation_flag1 = true;
    individualResult = mapvector_get(results, 0);
    const char* outside = compartmentInfoArray[0].outside;
    const char* originalCompartment = map_get(individualResult, "originalCompartment");
    bool originalCompartmentEmpty = strcmp(originalCompartment, "") == 0;
    if (!originalCompartmentEmpty &amp;&amp; strcmp(outside, originalCompartment) == 0) {
      productOrientation = -1;
    }
    else if (!originalCompartmentEmpty &amp;&amp; strcmp(outside, "") != 0) {
      struct geom_object* objOutside = NULL;
      struct geom_object* objOrigCompartment = NULL;
      find_objects(world-&gt;root_instance, outside, &amp;objOutside, originalCompartment, &amp;objOrigCompartment);
      if (objOutside != NULL &amp;&amp; objOrigCompartment != NULL) {
        mcell_warn(
            "Handling orientation of NFsim reaction where both compartents %s (orig) and %s (outside) are objects is not supported yet, "
            "using default orientation 1 (outside)", originalCompartment, outside);
        productOrientation = 1;
      } else if (objOutside == NULL &amp;&amp; objOrigCompartment == NULL) {
        mcell_error(
            "NFsim reaction returned compartments %s (orig) and %s (outside) that were not identified as object, this is not supported yet.",
            originalCompartment, outside
        );
<a name="0"></a>        exit(1);
      } else {
        if (objOrigCompartment != NULL) {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          if (has_region(objOrigCompartment, outside)) {
            productOrientation = -1;
          } else {
            mcell_warn(
                "Handling orientation of NFsim reaction where both compartent %s (orig) and %s (outside) are not in object-region relationship is not supported yet, "
                "using default orientation 1 (outside)", originalCompartment, outside);
            productOrientation = 1;
          }
        } else {
          if (has_region(objOutside, originalCompartment)) {
            productOrientation = 1;
          } else {
            productOrientation = 1;
          }</b></font>
        }
      }
    } else {
      productOrientation = 1;
    }
  } else {
    orientation_flag1 = false;
    productOrientation = 0;
  }
  struct mcell_species *products =
      mcell_add_to_species_list(nfsim_molecule_template-&gt;sym, orientation_flag1,
                                productOrientation, NULL);
  rx-&gt;nfsim_geometries[path][0] = productOrientation;
  for (int i = 1; i &lt; numOfResults; i++) {
    if (compartmentInfoArray[i].spatialDimensions == 2)
      nfsim_molecule_template = world-&gt;global_nfsim_surface;
    else
      nfsim_molecule_template = world-&gt;global_nfsim_volume;
    if (orientation_flag2) {
      individualResult = mapvector_get(results, i);
      if (strcmp(compartmentInfoArray[i].outside,
                 map_get(individualResult, "originalCompartment")) ==
          0) {         productOrientation = -1;
      } else {
        productOrientation = 1;
      }
    } else {
      productOrientation = 0;
    }
    rx-&gt;nfsim_geometries[path][i] = productOrientation;
    products = mcell_add_to_species_list(nfsim_molecule_template-&gt;sym,
                                         orientation_flag1, productOrientation,
                                         products);
  }
  for (int i = 0; i &lt; numOfResults; i++) {
    delete_compartmentStructs(compartmentInfoArray[i]);
  }
  free(compartmentInfoArray);
  if (extract_reactants(pathp, reactants, &amp;reactant_idx, &amp;num_vol_mols,
                        &amp;num_surface_mols, &amp;all_3d, &amp;oriented_count) != 0) {
    return -1;
  }
  int num_surf_products = 0;
  int bidirectional = 0;
  if (extract_products(world-&gt;notify, pathp, products, &amp;num_surf_products,
                       bidirectional, all_3d) == MCELL_FAIL) {
    return MCELL_FAIL;
  }
  mcell_delete_species_list(reactants);
  mcell_delete_species_list(products);
  int k = 0;
  struct product *prod = NULL;
  counter = 0;
  for (prod = pathp-&gt;product_head; counter &lt; numOfResults;) {
    rx-&gt;nfsim_players[path][counter] = prod-&gt;prod;
    ++counter;
    if (counter &lt; numOfResults)
      prod = prod-&gt;next;
  }
  prod-&gt;next = NULL;
  if (rx-&gt;players != NULL) {
    free(rx-&gt;players);
    free(rx-&gt;geometries);
  }
  rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
                                     "reaction players array");
  rx-&gt;geometries =
      CHECKED_MALLOC_ARRAY(short, num_players, "reaction geometries array");
  memset(rx-&gt;players, 0, sizeof(struct species *) * num_players);
  memset(rx-&gt;geometries, 0, sizeof(short) * num_players);
  rx-&gt;players[0] = pathp-&gt;reactant1;
  if (reac2 != NULL)
    rx-&gt;players[1] = pathp-&gt;reactant2;
  for (int n_pathway = 0; n_pathway &lt; rx-&gt;n_pathways; n_pathway++) {
    k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
    counter = 0;
    for (counter = 0; counter &lt; rx-&gt;product_idx_aux[n_pathway]; counter++) {
      kk = k;
      k++;
      rx-&gt;players[kk] = rx-&gt;nfsim_players[n_pathway][counter];
      set_nfsim_product_geometries(
          pathp, rx, rx-&gt;nfsim_geometries[n_pathway][counter], kk);
    }
  } 
  init_reaction_info(rx);
  rx-&gt;info[path].pathname = NULL;
  struct product *tmp = pathp-&gt;product_head;
  struct product *tmp2 = NULL;
  while (tmp != NULL) {
    tmp2 = tmp-&gt;next;
    free(tmp);
    tmp = tmp2;
  }
  free(pathp);
  return MCELL_SUCCESS;
}
void free_reaction_nfsim(struct rxn *rx, int path) {
  free(rx-&gt;nfsim_players[path]);
  free(rx-&gt;nfsim_geometries[path]);
  free(rx-&gt;product_graph_data[path]);
  rx-&gt;nfsim_players[path] = NULL;
  rx-&gt;nfsim_geometries[path] = NULL;
  rx-&gt;product_graph_data[path] = NULL;
}
void calculate_nfsim_diffusion_derived_data(struct volume *state,
                                            struct graph_data *data) {
  double global_time_unit = state-&gt;time_unit;
  const char *compartment1 =
      extractSpeciesCompartmentFromNauty_c(data-&gt;graph_pattern);
  compartmentStruct reactantCompartmentInfo1 =
      getCompartmentInformation_c(compartment1);
  free((char*)compartment1);
  if (!distinguishable(state-&gt;space_step, 0, EPS_C))   {
    data-&gt;space_step =
        sqrt(4.0 * 1.0e8 * data-&gt;graph_diffusion * global_time_unit) *
        state-&gt;r_length_unit;
    data-&gt;time_step = 1.0;
  } else   {
    double space_step = state-&gt;space_step * state-&gt;length_unit;
    if (reactantCompartmentInfo1.spatialDimensions == 2) {
      data-&gt;time_step =
          space_step * space_step /
          (MY_PI * 1.0e8 * data-&gt;graph_diffusion * global_time_unit);
    } else {
      data-&gt;time_step =
          space_step * space_step * MY_PI /
          (16.0 * 1.0e8 * data-&gt;graph_diffusion * global_time_unit);
    }
    data-&gt;space_step = sqrt(4.0 * 1.0e8 * data-&gt;graph_diffusion *
                            data-&gt;time_step * global_time_unit) *
                       state-&gt;r_length_unit;
  }
  free(reactantCompartmentInfo1.name);
  free(reactantCompartmentInfo1.outside);
}
bool calculate_nfsim_reactivity(struct graph_data *graph) {
  graph-&gt;flags = 0;
  queryOptions options =
      initializeNFSimQueryForBimolecularReactions(graph, NULL, "0");
  void *results = mapvectormap_create();
  initAndQueryByNumReactant_c(options, results);
  bool dimensionalityFlag = true;
  if (mapvectormap_size(results) &gt; 0) {
    char **resultKeys = mapvectormap_getKeys(results);
    void *headComplex = mapvectormap_get(results, resultKeys[0]);
    int resultSize = mapvectormap_size(results);
    for (int i = 0; i &lt; resultSize; i++) {
      free(resultKeys[i]);
    }
    free(resultKeys);
    int headNumAssociatedReactions = mapvector_size(headComplex);
    void *pathInformation;
    for (int path = 0; path &lt; headNumAssociatedReactions; path++) {
      pathInformation = mapvector_get(headComplex, path);
      const char *dimensionality =
          map_get(pathInformation, "reactionDimensionality");
      if (!dimensionality) {
        dimensionalityFlag = false;
        break;
      }
      if (strcmp(dimensionality, "VOLSURF") == 0) {
        graph-&gt;flags |= CAN_VOLSURF;
      }
      if (strcmp(dimensionality, "VOLVOL") == 0) {
        graph-&gt;flags |= CAN_VOLVOL;
      }
      if (strcmp(dimensionality, "SURFSURF") == 0) {
        graph-&gt;flags |= CAN_SURFSURF;
      }
    }
  }
  mapvectormap_delete(results);
  if (dimensionalityFlag) {
    return true;
  } else {
    graph-&gt;flags = -1;
    return false;
  }
}
void properties_nfsim(struct volume *world, struct abstract_molecule *reac) {
  queryOptions options = initializeNFSimQueryNoFiring(reac);
  void *results = mapvector_create();
  initAndQuerySystemStatus_c(options, results);
  void *individualResult = mapvector_get(results, 0);
  const char *result = map_get(individualResult, "diffusion_function");
  if (result) {
    reac-&gt;graph_data-&gt;graph_diffusion = atof(result);
    calculate_nfsim_diffusion_derived_data(world, reac-&gt;graph_data);
  } else {
    reac-&gt;graph_data-&gt;graph_diffusion = -1;
    reac-&gt;graph_data-&gt;space_step = -1;
    reac-&gt;graph_data-&gt;time_step = -1;
    reac-&gt;get_diffusion = get_standard_diffusion;
    reac-&gt;get_space_step = get_standard_space_step;
    reac-&gt;get_time_step = get_standard_time_step;
  }
  mapvector_delete(results);
  if (calculate_nfsim_reactivity(reac-&gt;graph_data)) {
    reac-&gt;get_flags = get_nfsim_flags;
  } else {
    reac-&gt;get_flags = get_standard_flags;
  }
  free(options.optionValues[0]);
  free(options.optionValues);
  free(options.initKeys);
}
int outcome_nfsim(struct volume *world, struct rxn *rx, int path,
                  struct abstract_molecule *reac,
                  struct abstract_molecule *reac2, double t) {
  int result = RX_A_OK;
  queryOptions options;
  if (rx-&gt;product_idx_aux[path] != -1 &amp;&amp;
      rx-&gt;external_reaction_data[path].resample == 1) {
    free_reaction_nfsim(rx, path);
    rx-&gt;product_idx_aux[path] = -1;
  }
  if (rx-&gt;product_idx_aux[path] == -1) {
    world-&gt;n_NFSimReactions += 1;
    if (reac2 == NULL)
      options = initializeNFSimQueryforUnimolecularFiring(
          reac, rx-&gt;external_reaction_data[path].reaction_name);
    else {
      options = initializeNFSimQueryforBimolecularFiring(
          reac, reac2, rx-&gt;external_reaction_data[path].reaction_name);
    }
    void *results = mapvector_create();
    initAndQuerySystemStatus_c(options, results);
    free(options.optionValues[0]);
    free(options.optionValues[1]);
    free(options.optionValues);
    free(options.initKeys);
    prepare_reaction_nfsim(world, rx, results, path, reac, reac2);
    mapvector_delete(results);
  }
  else {
    for (int i = 0; i &lt; rx-&gt;product_idx_aux[path]; i++) {
      constructNauty_c(rx-&gt;product_graph_data[path][i]-&gt;graph_pattern, 1);
    }
    rx-&gt;info[path].pathname = NULL;
  }
  constructNauty_c(reac-&gt;graph_data-&gt;graph_pattern, -1);
  if (reac2 != NULL)
    constructNauty_c(reac2-&gt;graph_data-&gt;graph_pattern, -1);
  return result;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>util.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;assert.h&gt;
#include &lt;float.h&gt;
#include &lt;math.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;memory.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;vector&gt;
#ifndef _MSC_VER
#include &lt;unistd.h&gt;
#include &lt;sys/resource.h&gt; #else
typedef unsigned int uint;
#endif
#include "logging.h"
#include "util.h"
#include "mcell_structs.h"
#include "bng/shared_defines.h"
#include "bng/filesystem_utils.h"
struct bit_array *new_bit_array(int bits) {
  int n = (bits + 8 * sizeof(int) - 1) / (8 * sizeof(int));
  struct bit_array *ba = (struct bit_array *)malloc(sizeof(struct bit_array) +
    sizeof(int) * n);
  if (ba == NULL) {
    return NULL;
  }
  ba-&gt;nbits = bits;
  ba-&gt;nints = n;
  return ba;
}
struct bit_array *duplicate_bit_array(struct bit_array *old) {
  struct bit_array *ba = (struct bit_array *)malloc(sizeof(struct bit_array) +
    sizeof(int) * old-&gt;nints);
  if (ba == NULL) {
    return NULL;
  }
  memcpy(ba, old, sizeof(struct bit_array) + sizeof(int) * old-&gt;nints);
  return ba;
}
int get_bit(struct bit_array *ba, int idx) {
  int *data = &amp;(ba-&gt;nints);
  data++; 
  size_t ofs = idx &amp; (8 * sizeof(int) - 1);
  idx = idx / (8 * sizeof(int));
  ofs = 1u &lt;&lt; ofs;
  if ((data[idx] &amp; ofs) != 0) {
    return 1;
  } else {
    return 0;
  }
}
void set_bit(struct bit_array *ba, int idx, int value) {
  int *data = &amp;(ba-&gt;nints);
  data++; 
  size_t ofs = idx &amp; (8 * sizeof(int) - 1);
  idx = idx / (8 * sizeof(int));
  ofs = (1u &lt;&lt; ofs);
  if (value) {
    value = ofs;
  } else {
    value = 0;
  }
  data[idx] = (data[idx] &amp; ~ofs) | value;
}
void set_bit_range(struct bit_array *ba, int idx1, int idx2, int value) {
  int *data = &amp;(ba-&gt;nints);
  data++; 
  int ofs1 = idx1 &amp; (8 * sizeof(int) - 1);
  int ofs2 = idx2 &amp; (8 * sizeof(int) - 1);
  idx1 = idx1 / (8 * sizeof(int));
  idx2 = idx2 / (8 * sizeof(int));
  unsigned int mask, cmask;
  if (idx1 == idx2) {
    mask = 0;
    for (int i = ofs1; i &lt;= ofs2; i++) {
      mask |= (1u &lt;&lt; i);
<a name="0"></a>    }
    cmask = ~mask;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (value) {
      data[idx1] = (data[idx1] &amp; cmask) | mask;
    } else {
      data[idx1] = data[idx1] &amp; cmask;
    }
  } else {
    if (value) {
      value = ~0;
    } else {
      value = 0;
    }</b></font>
    for (int i = idx1 + 1; i &lt; idx2; i++) {
      data[i] = value;
    }
    mask = 0;
    for (unsigned int i = ofs1; i &lt; 8 * sizeof(int); i++) {
      mask |= (1u &lt;&lt; i);
    }
    cmask = ~mask;
    if (value) {
      data[idx1] = (data[idx1] &amp; cmask) | mask;
    } else {
      data[idx1] = data[idx1] &amp; cmask;
    }
    mask = 0;
    for (int i = 0; i &lt;= ofs2; i++) {
      mask |= (1u &lt;&lt; i);
    }
    cmask = ~mask;
    if (value) {
      data[idx2] = (data[idx2] &amp; cmask) | mask;
    } else {
      data[idx2] = data[idx2] &amp; cmask;
    }
  }
}
void set_all_bits(struct bit_array *ba, int value) {
  if (value) {
    value = ~0;
  }
  int *data = &amp;(ba-&gt;nints);
  data++; 
  for (int i = 0; i &lt; ba-&gt;nints; i++) {
    data[i] = value;
  }
}
void bit_operation(struct bit_array *ba, struct bit_array *bb, char op) {
  int *da, *db;
  if (op == '!' || op == '~') {
    da = &amp;(ba-&gt;nints);
    da++;
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] = ~da[i];
    }
    return;
  }
  if (ba-&gt;nbits != bb-&gt;nbits) {
    return;
  }
  da = &amp;(ba-&gt;nints);
  da++;
  db = &amp;(bb-&gt;nints);
  db++;
  switch (op) {
  case '^':
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] ^= db[i];
    }
    break;
  case '|':
  case '+':
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] |= db[i];
    }
    break;
  case '-':
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] &amp;= ~db[i];
    }
    break;
  case '&amp;':
    for (int i = 0; i &lt; ba-&gt;nints; i++) {
      da[i] &amp;= db[i];
    }
    break;
  default:
    break;
  }
}
int count_bits(struct bit_array *ba) {
  static const int cb_table[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4,
    2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5,
    3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,
    4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
  };
  int *dd = &amp;(ba-&gt;nints);
  dd++;
<a name="1"></a>  unsigned char *d = (unsigned char *)dd;
  int n = (ba-&gt;nints - 1) * sizeof(int);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int cnt = 0;
  for (int i = 0; i &lt; n; i++) {
    cnt += cb_table[(*d++)];
  }
  n = ba-&gt;nbits - n * 8;
  if (n == 0)</b></font>
    return cnt;
  int j = dd[ba-&gt;nints - 1];
  while (n &gt;= 8) {
    cnt += cb_table[j &amp; 0xFF];
    n -= 8;
    j &gt;&gt;= 8;
  }
  if (n &gt; 0) {
    cnt += cb_table[j &amp; 0xFF] - cb_table[(j &amp; 0xFF) &gt;&gt; n];
  }
  return cnt;
}
void free_bit_array(struct bit_array *ba) { free(ba); }
int bisect(double *list, int n, double val) {
  int lo = 0;
  int hi = n;
  int mid = 0;
  while (hi - lo &gt; 1) {
    mid = (hi + lo) / 2;
    if (list[mid] &gt; val)
    {
      hi = mid;
    } else {
      lo = mid;
    }
  }
  return lo;
}
int bisect_near(double *list, int n, double val) {
  int lo = 0;
  int hi = n - 1;
  int mid = 0;
  while (hi - lo &gt; 1) {
    mid = (hi + lo) / 2;
    if (list[mid] &gt; val)
    {
      hi = mid;
    } else {
      lo = mid;
    }
  }
  if (val &gt; list[hi]) {
    return hi;
  } else if (val &lt; list[lo]) {
    return lo;
  } else if (val - list[lo] &lt; list[hi] - val) {
    return lo;
  } else {
    return hi;
  }
}
int bisect_high(double *list, int n, double val) {
  int lo = 0;
  int hi = n - 1;
  int mid = 0;
  while (hi - lo &gt; 1) {
    mid = (hi + lo) / 2;
    if (list[mid] &gt; val) {
      hi = mid;
    } else {
      lo = mid;
    }
  }
  if (list[lo] &gt; val)
  {
    return lo;
  } else {
    return hi;
  }
}
int distinguishable(double a, double b, double eps) {
  double c = fabs(a - b);
  a = fabs(a);
  if (a &lt; 1) {
    a = 1;
  }
  b = fabs(b);
  if (b &lt; a) {
    eps *= a;
  } else {
    eps *= b;
  }
  return (c &gt; eps);
}
int is_reverse_abbrev(const char *abbrev, const char *full) {
  size_t na = strlen(abbrev);
  size_t nf = strlen(full);
  if (na &gt; nf) {
    return 0;
  }
  return (strcmp(abbrev, full + (nf - na)) == 0);
}
struct void_list *void_list_sort(struct void_list *vl) {
  struct void_list *stack[64];
  int stack_n[64];
  struct void_list *left, *right, *merge, *tail;
  int si = 0;
  stack[0] = NULL;
  while (vl != NULL) {
    if (vl-&gt;next == NULL) {
      stack[si] = vl;
      stack_n[si] = 1;
      vl = NULL;
      si++;
    } else if ((intptr_t)vl-&gt;data &lt;= (intptr_t)vl-&gt;next-&gt;data) {
      stack[si] = vl;
      stack_n[si] = 2;
      vl = vl-&gt;next-&gt;next;
      stack[si]-&gt;next-&gt;next = NULL;
      si++;
    } else {
      stack[si] = vl-&gt;next;
      stack_n[si] = 2;
      left = vl;
      vl = vl-&gt;next-&gt;next;
      stack[si]-&gt;next = left;
      left-&gt;next = NULL;
      si++;
    }
    while (si &gt; 1 &amp;&amp; stack_n[si - 1] * 2 &gt;= stack_n[si - 2]) {
      stack_n[si - 2] += stack_n[si - 1];
      left = stack[si - 2];
      right = stack[si - 1];
      if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
        merge = left;
        left = left-&gt;next;
      } else {
        merge = right;
        right = right-&gt;next;
      }
      merge-&gt;next = NULL;
      tail = merge;
      while (1) {
        if (left == NULL) {
          tail-&gt;next = right;
          break;
        }
        if (right == NULL) {
          tail-&gt;next = left;
          break;
        }
        if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
          tail-&gt;next = left;
          tail = left;
          left = left-&gt;next;
        } else {
          tail-&gt;next = right;
          tail = right;
          right = right-&gt;next;
        }
      }
      stack[si - 2] = merge;
      si--;
    }
  }
  while (si &gt; 1)   {
    stack_n[si - 2] += stack_n[si - 1];
    left = stack[si - 2];
    right = stack[si - 1];
    if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
      merge = left;
      left = left-&gt;next;
    } else {
      merge = right;
      right = right-&gt;next;
    }
    merge-&gt;next = NULL;
    tail = merge;
    while (1) {
      if (left == NULL) {
        tail-&gt;next = right;
        break;
      }
      if (right == NULL) {
        tail-&gt;next = left;
        break;
      }
      if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
        tail-&gt;next = left;
        tail = left;
        left = left-&gt;next;
      } else {
        tail-&gt;next = right;
        tail = right;
        right = right-&gt;next;
      }
    }
    stack[si - 2] = merge;
    si--;
  }
  return stack[0];
}
struct void_list *void_list_sort_by(struct void_list *vl,
                                    int (*leq)(void *, void *)) {
  struct void_list *stack[64];
  int stack_n[64];
  struct void_list *left, *right, *merge, *tail;
  int si = 0;
  stack[0] = NULL;
  while (vl != NULL) {
    if (vl-&gt;next == NULL) {
      stack[si] = vl;
      stack_n[si] = 1;
      vl = NULL;
      si++;
    } else if ((*leq)(vl-&gt;data, vl-&gt;next-&gt;data)) {
      stack[si] = vl;
      stack_n[si] = 2;
      vl = vl-&gt;next-&gt;next;
      stack[si]-&gt;next-&gt;next = NULL;
      si++;
    } else {
      stack[si] = vl-&gt;next;
      stack_n[si] = 2;
      left = vl;
      vl = vl-&gt;next-&gt;next;
      stack[si]-&gt;next = left;
      left-&gt;next = NULL;
      si++;
    }
    while (si &gt; 1 &amp;&amp; stack_n[si - 1] * 2 &gt;= stack_n[si - 2]) {
      stack_n[si - 2] += stack_n[si - 1];
      left = stack[si - 2];
      right = stack[si - 1];
      if ((*leq)(left-&gt;data, right-&gt;data)) {
        merge = left;
        left = left-&gt;next;
      } else {
        merge = right;
        right = right-&gt;next;
      }
      merge-&gt;next = NULL;
      tail = merge;
      while (1) {
        if (left == NULL) {
          tail-&gt;next = right;
          break;
        }
        if (right == NULL) {
          tail-&gt;next = left;
          break;
        }
        if ((*leq)(left-&gt;data, right-&gt;data)) {
          tail-&gt;next = left;
          tail = left;
          left = left-&gt;next;
        } else {
          tail-&gt;next = right;
          tail = right;
          right = right-&gt;next;
        }
      }
      stack[si - 2] = merge;
      si--;
    }
  }
  while (si &gt; 1)   {
    stack_n[si - 2] += stack_n[si - 1];
    left = stack[si - 2];
    right = stack[si - 1];
    if ((*leq)(left-&gt;data, right-&gt;data)) {
      merge = left;
      left = left-&gt;next;
    } else {
      merge = right;
      right = right-&gt;next;
    }
    merge-&gt;next = NULL;
    tail = merge;
    while (1) {
      if (left == NULL) {
        tail-&gt;next = right;
        break;
      }
      if (right == NULL) {
        tail-&gt;next = left;
        break;
      }
      if ((*leq)(left-&gt;data, right-&gt;data)) {
        tail-&gt;next = left;
        tail = left;
        left = left-&gt;next;
      } else {
        tail-&gt;next = right;
        tail = right;
        right = right-&gt;next;
      }
    }
    stack[si - 2] = merge;
    si--;
  }
  return stack[0];
}
int void_array_search(void **array, int n, void *to_find) {
  int lo = 0;
  int hi = n - 1;
  int m;
  while (hi - lo &gt; 1) {
    m = (hi + lo) / 2;
    if (to_find == array[m]) {
      return m;
    } else if ((intptr_t)to_find &gt; (intptr_t)array[m]) {
      lo = m;
    } else {
      hi = m;
    }
  }
  if (to_find == array[lo]) {
    return lo;
  }
  if (to_find == array[hi]) {
    return hi;
  }
  return -1;
}
int void_ptr_compare(void const *v1, void const *v2) {
  void const **v1p = (void const **)v1;
  void const **v2p = (void const **)v2;
  intptr_t i1 = (intptr_t) * v1p;
  intptr_t i2 = (intptr_t) * v2p;
  if (i1 &lt; i2) {
    return -1;
  } else if (i1 &gt; i2) {
    return 1;
  }
  return 0;
}
u_int *allocate_uint_array(int size, u_int value) {
  u_int *arr;
  if ((arr = CHECKED_MALLOC_ARRAY_NODIE(u_int, size, NULL)) == NULL) {
    return NULL;
  }
  for (int i = 0; i &lt; size; ++i) {
    arr[i] = value;
  }
  return arr;
}
void **allocate_ptr_array(int size) {
  if (size == 0) {
    size = 1;
  }
  void **arr;
  if ((arr = CHECKED_MALLOC_ARRAY_NODIE(void *, size, NULL)) == NULL) {
    return NULL;
  }
  memset(arr, 0, size * sizeof(void *));
  return arr;
}
void free_ptr_array(void **pa, int count) {
  for (int i = 0; i &lt; count; ++i) {
    if (pa[i] != NULL) {
      free(pa[i]);
    }
  }
  free(pa);
}
void free_num_expr_list(struct num_expr_list *nlist) {
  struct num_expr_list *nnext;
  while (nlist != NULL) {
    nnext = nlist-&gt;next;
    free(nlist);
    nlist = nnext;
  }
}
int dir_exists(char const *path) {
#ifdef _MSC_VER   release_assert(false);
  return false;
#else
  struct stat sb;
  if (stat(path, &amp;sb) == 0 &amp;&amp; S_ISDIR(sb.st_mode)) {
    return 1;
  }
  return 0;
#endif
}
int is_writable_dir(char const *path) {
#ifdef _MSC_VER   release_assert(false);
  return false;
#else
  if (dir_exists(path) &amp;&amp; !access(path, R_OK | W_OK | X_OK)) {
    return 1;
  }
  return 0;
#endif
}
int make_parent_dir(char const *path) {
  FSUtils::make_dir_for_file_w_multiple_attempts(path);
  return 0;
}
int mkdirs(char const *path) {
  char *pathtmp = CHECKED_STRDUP(path, "directory path");
  char *curpos = pathtmp;
  while (curpos != NULL &amp;&amp; *curpos == '/') {
    ++curpos;
  }
  while (curpos != NULL) {
    char *nextel = strchr(curpos, '/');
    if (nextel != NULL) {
      *nextel = '\0';
    }
    if (dir_exists(pathtmp)) {
      if (nextel) {
        *nextel = '/';
        curpos = nextel + 1;
      } else {
        curpos = NULL;
      }
      continue;
    }
    if (!is_writable_dir(pathtmp) &amp;&amp; mkdir(pathtmp, 0777) != 0) {
      mcell_perror_nodie(errno, "Failed to create directory '%s'", path);
      free(pathtmp);
      return 1;
    }
    if (nextel) {
      *nextel = '/';
      curpos = nextel + 1;
    } else {
      curpos = NULL;
    }
  }
  free(pathtmp);
  return 0;
}
FILE *open_file(const char *fname, const char *mode) {
  FILE *f;
  if ((f = fopen(fname, mode)) == NULL) {
    mcell_perror_nodie(errno, "Failed to open file %s.", fname);
    return NULL;
  }
  return f;
}
double erfcinv(double x) {
  static const double tail_cutoff = 0.0485;
  static const double neg_twice_log_half = 1.386294361119891;
  static const double scaling_const = -0.7071067811865475;
  static const double tn0 = 2.938163982698783;
  static const double tn1 = 4.374664141464968;
  static const double tn2 = -2.549732539343734;
  static const double tn3 = -2.400758277161838;
  static const double tn4 = -3.223964580411365e-1;
  static const double tn5 = -7.784894002430293e-3;
  static const double td1 = 3.754408661907416;
  static const double td2 = 2.445134137142996;
  static const double td3 = 3.224671290700398e-1;
  static const double td4 = 7.784695709041462e-3;
  static const double cn0 = 2.506628277459239;
  static const double cn1 = -3.066479806614716e1;
  static const double cn2 = 1.383577518672690e2;
  static const double cn3 = -2.759285104469687e2;
  static const double cn4 = 2.209460984245205e2;
  static const double cn5 = -3.969683028665376e1;
  static const double cd1 = -1.328068155288572e1;
  static const double cd2 = 6.680131188771972e1;
  static const double cd3 = -1.556989798598866e2;
  static const double cd4 = 1.615858368580409e2;
  static const double cd5 = -5.447609879822406e1;
  double p, q, r;
  if (x &lt; tail_cutoff) {
    p = sqrt(-2 * log(x) + neg_twice_log_half);
    r = (tn0 + p * (tn1 + p * (tn2 + p * (tn3 + p * (tn4 + p * tn5))))) /
        (1.0 + p * (td1 + p * (td2 + p * (td3 + p * td4))));
  } else {
    p = 0.5 * x - 0.5;
    q = p * p;
    r = p * (cn0 + q * (cn1 + q * (cn2 + q * (cn3 + q * (cn4 + q * cn5))))) /
        (1.0 + q * (cd1 + q * (cd2 + q * (cd3 + q * (cd4 + q * cd5)))));
  }
  return scaling_const * r;
}
int poisson_dist(double lambda, double p) {
  int i, lo, hi;
  double plo, phi, pctr;
  double lambda_i;
  i = (int)lambda;
  pctr = exp(-lambda + i * log(lambda) -
             lgamma(i + 1)); 
  if (p &lt; pctr)
    return i;
  lo = hi = i;
  plo = phi = pctr; 
  p -= pctr;
  lambda_i = 1.0 / lambda;
  while (p &gt; 0)   {
    if (lo &gt; 0)     {
      plo *= lo * lambda_i;       lo--;
      if (p &lt; plo)
        return lo;
      p -= plo;
    }
    hi++;
    phi = phi * lambda / hi;     if (p &lt; phi)
      return hi;
    p -= phi + DBL_EPSILON;   }
  assert(false);
  return -1;
}
void byte_swap(void *data, int size) {
  if (size &lt; 2){
    return;
  }
  unsigned char temp;
  unsigned char *c = (unsigned char *)data;
  for (int i = 0, j = size - 1; i &lt; j; i++, j--) {
    temp = c[i];
    c[i] = c[j];
    c[j] = temp;
  }
}
int feral_strlenn(char *feral, int n) {
  int real_n = 0;
  int i;
  for (i = 0; i &lt; n; i++) {
    if (feral[i] == '\\') {
      i++;
      if (feral[i] == '\0')
        return real_n;
    } else if (feral[i] == '[') {
      while (i &lt; n &amp;&amp; feral[i] != ']') {
        if (feral[i] == '\0')
          return real_n;
        if (feral[i] == '\\') {
          i += 2;
          if (i &gt; n || feral[i - 1] == '\0')
            return real_n;
        } else if (feral[i] == '-') {
          i += 2;
          if (i &gt; n || feral[i - 1] == '\0')
            return real_n;
        } else
          i++;
      }
    } else if (feral[i] == '\0')
      return real_n;
    real_n++;
  }
  return real_n;
}
int is_feral_nabbrev(char *feral, int n, char *tame) {
  char c, cc;
  int i = 0;
  int nfound = 0;
  int ok;
  if (n &lt;= 0)
    return 0;
  while (*tame != '\0') {
    if (feral[i] == '[')     {
      i++;
      ok = 0;
      while (i &lt; n &amp;&amp; feral[i] != ']') {
        c = feral[i++];
        if (c == '\0')
          return 0;         if (c == '\\') {
          if (i &gt;= n)
            return 0;           c = feral[i++];
          if (c == '\0')
            return 0;         }
        if (i &lt; n &amp;&amp; feral[i] == '-') {
          i++;
          if (i &gt;= n)
            return 0;           cc = feral[i++];
          if (cc == '\0')
            return 0;           if (cc == '\\') {
            if (i &gt;= n)
              return 0;             cc = feral[i++];
            if (cc == '\0')
              return 0;           }
          if (c &lt;= *tame &amp;&amp; *tame &lt;= cc) {
            ok = 1;
            break;
          }
        } else if (c == *tame) {
          ok = 1;
          break;
        }
      }
      if (i &gt;= n)
        return 0;       if (!ok)
        return 0;                            tame++;                                while (i &lt; n &amp;&amp; feral[i] != ']')       {
        if (feral[i] == '\0')
          return 0;         if (feral[i] == '\\') {
          i += 2;
          if (i &gt; n || feral[i - 1] == '\0')
            return 0;         } else
          i++;
      }
      if (i &gt;= n)
        return 0;       i++;
    } else     {
      c = feral[i++];
      if (c == '\\') {
        if (i &gt;= n)
          return 0;         c = feral[i++];
        if (c != *tame++)
          return 0;       } else if (c != *tame++ &amp;&amp; c != '?')
        return 0;     }
    nfound++;
    if (i &gt;= n)
      return nfound;   }
  return 0; }
char *feral_strstrn(char *tame_haystack, char *feral_needle, int n) {
  char c = 0;
  char cc;
  char set[256];
  int isset = 0;
  int i, j;
  int scoot = 0;
  for (i = 0; i &lt; n; i++)
    if (feral_needle[i] == '\0')
      break;
  n = i;
  i = 0;
  while (feral_needle[i] == '?' &amp;&amp; i &lt; n &amp;&amp; *tame_haystack != '\0') {
    i++;
    tame_haystack++;
    scoot++;
  }
  if (i &gt;= n)
    return tame_haystack - scoot;
  if (feral_needle[i] == '[') {
    isset = 1;
    memset(set, 0, 256);
    set[0] = 1;
    i++;
    while (i &lt; n &amp;&amp; feral_needle[i] != ']') {
      c = feral_needle[i++];
      if (feral_needle[i] == '\0')
        return NULL;       if (c == '\\') {
        if (i &gt;= n)
          return NULL;         c = feral_needle[i++];
      }
      if (i &lt; n &amp;&amp; feral_needle[i] == '-') {
        i++;
        if (i &gt;= n)
          return NULL;         cc = feral_needle[i++];
        if (cc == '\0')
          return NULL;         if (cc == '\\') {
          if (i &gt;= n)
            return NULL;           cc = feral_needle[i++];
          if (cc == '\0')
            return NULL;         }
        for (j = (int)c; j &lt;= (int)cc; j++)
          set[j] = 1;
      } else
        set[(int)c] = 1;
    }
    if (i &gt;= n)
      return NULL;     i++;             } else {
    c = feral_needle[i++];
    if (c == '\\') {
      if (i &gt;= n)
        return NULL;       c = feral_needle[i++];
    }
    if (c == '\0')
      return NULL;   }
  while (*tame_haystack != '\0') {
    {
      while (!set[(int)*tame_haystack])
        tame_haystack++;
      if (*tame_haystack == '\0')
        return NULL;
    } else     {
      while (*tame_haystack != c &amp;&amp; *tame_haystack != '\0')
        tame_haystack++;
      if (*tame_haystack == '\0')
        return NULL;
    }
    if (i == n)
      return tame_haystack - scoot;
    else if (is_feral_nabbrev(feral_needle + i, n - i,
    {
      return tame_haystack - scoot;
    }
    tame_haystack++;
  }
  return NULL;
}
int is_wildcard_match(char *wild, char *tame) {
  int nstars;
  int n;
  if (*wild == '\0' &amp;&amp; *tame == '\0')
    return 1;
  for (n = 0, nstars = 0; wild[n] != '\0'; n++) {
    if (wild[n] == '[') {
      n++;
      while (wild[n] != '\0' &amp;&amp; wild[n] != ']') {
        if (wild[n] == '\\') {
          n++;
          if (wild[n] == '\0')
            return 0;         }
        n++;
      }
      if (wild[n] == '\0')
        return 0;     } else if (wild[n] == '\\') {
      n++;
      if (wild[n] == '\0')
        return 0;     } else if (wild[n] == '*')
      nstars++;
  }
  if (nstars == 0)
    return (is_feral_nabbrev(wild, n, tame) == (int)strlen(tame));
  else {
    std::vector&lt;int&gt; staridx;
    staridx.resize(nstars);
    std::vector&lt;int&gt; idxA;
    idxA.resize(nstars + 1);
    std::vector&lt;int&gt; idxB;
    idxB.resize(nstars + 1);
    char *m;
    int nidx;
    int i, j;
    int tail_len;
    int old_length;
    for (i = n = 0; wild[n] != '\0'; n++) {
      if (wild[n] == '[') {
        do {
          n++;
          if (wild[n] == '\\')
            n++;
        } while (wild[n] != ']');
      } else if (wild[n] == '\\')
        n++;
      else if (wild[n] == '*')
        staridx[i++] = n;
    }
    for (i = 0; i &lt; nstars &amp;&amp; staridx[i] == i; i++) {
    } 
    if (i &gt;= nstars)
      return 1; 
    if (i == 0)     {
      j = is_feral_nabbrev(wild, staridx[0], tame);
      if (j == 0)
        return 0; 
      tame += j; 
      wild += staridx[0];       n -= staridx[0];
      for (i = nstars - 1; i &gt;= 0; i--)
        staridx[i] -= staridx[0];
    }
    if (staridx[nstars - 1] &lt; n - 1)     {
      j = staridx[nstars - 1] + 1;
      tail_len = feral_strlenn(wild + j, n - j);
      j = is_feral_nabbrev(wild + j, n - j, tame + (strlen(tame) - tail_len));
      if (j == 0)
        return 0;     } else
      tail_len = 0;
    nidx = 0;
    for (i = 1; i &lt; nstars; i++) {
      idxA[nidx] = staridx[i - 1] + 1;
      idxB[nidx] = staridx[i];
      nidx++;
    }
    old_length = 0;
    m = tame;
    for (i = 0; i &lt; nidx; i++) {
      idxB[i] -= idxA[i]; 
      if (idxB[i] == 0)
        continue; 
      m = m + old_length;
      m = feral_strstrn(m, wild + idxA[i], idxB[i]);
      if (m == NULL)
        return 0;       old_length = feral_strlenn(wild + idxA[i], idxB[i]);
    }
    m = m + old_length;
    if (strlen(m) &lt; (size_t)tail_len)
      return 0; 
    return 1;
  }
}
int initialize_string_buffer(struct string_buffer *sb, int maxstr) {
  if (maxstr &gt; 0) {
    if ((sb-&gt;strings = (char **)allocate_ptr_array(maxstr)) == NULL)
      mcell_allocfailed("Failed to allocate buffer of %d strings.", maxstr);
  }
  sb-&gt;max_strings = maxstr;
  sb-&gt;n_strings = 0;
  return 0;
}
int destroy_string_buffer(struct string_buffer *sb) {
  if (sb-&gt;strings) {
    free_ptr_array((void **)sb-&gt;strings, sb-&gt;max_strings);
  }
  sb-&gt;strings = NULL;
  sb-&gt;max_strings = 0;
  sb-&gt;n_strings = 0;
  return 0;
}
int add_string_to_buffer(struct string_buffer *sb, char *str) {
  if (sb-&gt;n_strings &gt;= sb-&gt;max_strings) {
    mcell_internal_error("Attempt to overrun string buffer (max fill is %d).",
                         sb-&gt;max_strings);
  }
  sb-&gt;strings[sb-&gt;n_strings++] = str;
  return 0;
}
int pointer_hash_init(struct pointer_hash *ht, int size) {
  assert(size &gt;= 0);
  memset(ht, 0, sizeof(struct pointer_hash));
  if (size == 0) {
    ++size;
  }
  if ((size) &amp; (size - 1)) {
    size |= (size &gt;&gt; 1);
    size |= (size &gt;&gt; 2);
    size |= (size &gt;&gt; 4);
    size |= (size &gt;&gt; 8);
    size |= (size &gt;&gt; 16);
    ++size;
  }
  ht-&gt;num_items = 0;
  ht-&gt;table_size = size;
  if ((ht-&gt;hashes = (unsigned int *)malloc(sizeof(unsigned int) *size)) ==
          NULL ||
      (ht-&gt;keys = (void const **)malloc(sizeof(void const *) *size)) == NULL ||
      (ht-&gt;values = (void **)malloc(sizeof(void *) * size)) == NULL)
    goto failure;
  memset(ht-&gt;hashes, 0, sizeof(unsigned int) * size);
  memset(ht-&gt;keys, 0, sizeof(void *) * size);
  memset(ht-&gt;values, 0, sizeof(void *) * size);
  return 0;
failure:
  pointer_hash_destroy(ht);
  return 1;
}
void pointer_hash_destroy(struct pointer_hash *ht) {
  if (ht-&gt;hashes)
    free(ht-&gt;hashes);
  if (ht-&gt;keys)
    free(ht-&gt;keys);
  if (ht-&gt;values)
    free(ht-&gt;values);
  ht-&gt;num_items = 0;
  ht-&gt;table_size = 0;
  ht-&gt;hashes = NULL;
  ht-&gt;keys = NULL;
  ht-&gt;values = NULL;
}
int pointer_hash_resize(struct pointer_hash *ht, int new_size) {
  if (new_size == ht-&gt;table_size)
    return 0;
  if (new_size &lt; ht-&gt;num_items)
    return 1;
  struct pointer_hash old = *ht;
  if (pointer_hash_init(ht, new_size)) {
    *ht = old;
    return 1;
  }
  for (int old_item_idx = 0; old_item_idx &lt; old.table_size; ++old_item_idx) {
    if (old.keys[old_item_idx] == NULL)
      continue;
    if (pointer_hash_add(ht, old.keys[old_item_idx], old.hashes[old_item_idx],
                         old.values[old_item_idx]))
      goto failure;
  }
  pointer_hash_destroy(&amp;old);
  return 0;
failure:
  pointer_hash_destroy(ht);
  *ht = old;
  return 1;
}
int pointer_hash_add(struct pointer_hash *ht, void const *key,
                     unsigned int keyhash, void *value) {
  if (ht-&gt;table_size == 0) {
    if (pointer_hash_resize(ht, 2))
      return 1;
  }
  if (ht-&gt;num_items &gt;= (ht-&gt;table_size &gt;&gt; 1)) {
    if (pointer_hash_resize(ht, ht-&gt;table_size &lt;&lt; 1))
      return 1;
  }
  unsigned int start_index = keyhash &amp; (ht-&gt;table_size - 1);
  for (unsigned int i = 0; i &lt; (unsigned int)ht-&gt;table_size; i++) {
    unsigned int cur_index = (start_index + i) &amp; (ht-&gt;table_size - 1);
    if (ht-&gt;keys[cur_index] == key) {
      ht-&gt;values[cur_index] = value;
      return 0;
    }
    if (ht-&gt;keys[cur_index] == NULL) {
      ht-&gt;hashes[cur_index] = keyhash;
      ht-&gt;keys[cur_index] = key;
      ht-&gt;values[cur_index] = value;
      goto done;
    }
  }
  return 1;
done:
  ++ht-&gt;num_items;
  return 0;
}
void *pointer_hash_lookup_ext(struct pointer_hash const *ht, void const *key,
                              unsigned int keyhash, void *default_value) {
  if (ht-&gt;table_size == 0)
    return default_value;
  unsigned int start_index = keyhash &amp; (ht-&gt;table_size - 1);
  for (unsigned int i = 0; i &lt; (unsigned int)ht-&gt;table_size; i++) {
    unsigned int cur_index = (start_index + i) &amp; (ht-&gt;table_size - 1);
    if (ht-&gt;keys[cur_index] == NULL)
      return default_value;
    if (ht-&gt;keys[cur_index] == key)
      return ht-&gt;values[cur_index];
  }
  return default_value;
}
int pointer_hash_remove(struct pointer_hash *ht, void const *key,
                        unsigned int keyhash) {
  if (key == NULL)
    return 1;
  if (ht-&gt;table_size == 0)
    return 1;
  int start = keyhash &amp; (ht-&gt;table_size - 1);   int next_slot = -1;                         
  int cur = start;
  do {
    if (key != NULL &amp;&amp; ht-&gt;keys[cur] == key) {
      ht-&gt;keys[cur] = NULL;
      ht-&gt;values[cur] = NULL;
      ht-&gt;hashes[cur] = 0;
      --ht-&gt;num_items;
      if (ht-&gt;table_size &gt; (ht-&gt;num_items &lt;&lt; 2)) {
        if (!pointer_hash_resize(ht, ht-&gt;num_items &lt;&lt; 1))
          return 0;
      }
      next_slot = cur;
      key = NULL;
    }
    else if (ht-&gt;keys[cur] == NULL) {
      if (key == NULL)
        return 0;
      else
        return 1;
    }
    else if (next_slot != -1) {
      int desiredSlot = ht-&gt;hashes[cur] &amp; (ht-&gt;table_size - 1);
      if ((next_slot &lt; cur &amp;&amp;
           (desiredSlot &lt;= next_slot || desiredSlot &gt; cur)) ||
          (next_slot &gt; cur &amp;&amp;
           (desiredSlot &lt;= next_slot &amp;&amp; desiredSlot &gt; cur))) {
        ht-&gt;hashes[next_slot] = ht-&gt;hashes[cur];
        ht-&gt;keys[next_slot] = ht-&gt;keys[cur];
        ht-&gt;values[next_slot] = ht-&gt;values[cur];
        ht-&gt;hashes[cur] = 0;
        ht-&gt;keys[cur] = NULL;
        ht-&gt;values[cur] = NULL;
        next_slot = cur;
      }
    }
    if (++cur == ht-&gt;table_size)
      cur = 0;
  } while (cur != start);
  if (key == NULL)
    return 0;
  else
    return 1;
}
int remove_both_duplicates(struct void_list **head) {
  struct void_list *curr = *head, *tmp, *prev, *next_Next;
  int count = 0;
  tmp = curr;
  prev = NULL;
  while ((tmp != NULL) &amp;&amp; (tmp-&gt;next != NULL)) {
    if (tmp-&gt;data == tmp-&gt;next-&gt;data) {
      next_Next = tmp-&gt;next-&gt;next;
      free(tmp-&gt;next);
      free(tmp);
      tmp = next_Next;
      if (prev != NULL) {
        prev-&gt;next = tmp;
      } else {
        curr = tmp;
      }
    } else {
      prev = tmp;
      tmp = tmp-&gt;next;     }
  }
  *head = curr;
  for (tmp = *head; tmp != NULL; tmp = tmp-&gt;next) {
    count++;
  }
  return count;
}
void delete_void_list(struct void_list *head) {
  struct void_list *nnext;
  while (head != NULL) {
    nnext = head-&gt;next;
    free(head);
    head = nnext;
  }
}
int double_cmp(void const *i1, void const *i2) {
  double const *d1 = (double const *)i1;
  double const *d2 = (double const *)i2;
  if (*d1 &lt; *d2)
    return -1;
  else if (*d1 &gt; *d2)
    return 1;
  else
    return 0;
}
int is_string_present_in_string_array(const char * str, char ** strings, int length)
{
  int found = 0, i;
  for (i = 0; i &lt; length; i++) {
    if (strcmp(str, strings[i]) == 0) {
      found = 1;
      break;
    }
  }
  return found;
}
double convert_seconds_to_iterations(
    long long start_iterations,
    double time_step_seconds,
    double simulation_start_seconds,
    double seconds) {
  double delta_iterations =
    (seconds - simulation_start_seconds) / time_step_seconds;
  return (start_iterations + delta_iterations);
}
double convert_iterations_to_seconds(
    long long start_iterations,
    double time_step_seconds,
    double simulation_start_seconds,
    double iterations) {
  double delta_time = (iterations - start_iterations) * time_step_seconds;
  return (simulation_start_seconds + delta_time);
}
int generate_range(struct num_expr_list_head *list, double start, double end,
                   double step) {
  list-&gt;value_head = NULL;
  list-&gt;value_tail = NULL;
  list-&gt;value_count = 0;
  list-&gt;shared = 0;
  if (step &gt; 0) {
    for (double tmp_dbl = start;
         tmp_dbl &lt; end || !distinguishable(tmp_dbl, end, EPS_C) ||
             fabs(end - tmp_dbl) &lt;= EPS_C;
         tmp_dbl += step) {
      if (advance_range(list, tmp_dbl))
        return 1;
    }
  } else   {
    for (double tmp_dbl = start;
         tmp_dbl &gt; end || !distinguishable(tmp_dbl, end, EPS_C) ||
             fabs(end - tmp_dbl) &lt;= EPS_C;
         tmp_dbl += step) {
      if (advance_range(list, tmp_dbl))
        return 1;
    }
  }
  list-&gt;start_end_step_set = true;
  list-&gt;start = start;
  list-&gt;end = end;
  list-&gt;step = step;
  return 0;
}
int advance_range(struct num_expr_list_head *list, double tmp_dbl) {
  struct num_expr_list *nel;
  nel = CHECKED_MALLOC_STRUCT(struct num_expr_list, "numeric list");
  if (nel == NULL) {
    free_numeric_list(list-&gt;value_head);
    list-&gt;value_head = list-&gt;value_tail = NULL;
    return 1;
  }
  nel-&gt;value = tmp_dbl;
  nel-&gt;next = NULL;
  ++list-&gt;value_count;
  if (list-&gt;value_tail != NULL)
    list-&gt;value_tail-&gt;next = nel;
  else
    list-&gt;value_head = nel;
  list-&gt;value_tail = nel;
  return 0;
}
void free_numeric_list(struct num_expr_list *nel) {
  while (nel != NULL) {
    struct num_expr_list *n = nel;
    nel = nel-&gt;next;
    free(n);
  }
}
#define hashsize(n) ((ub4)1 &lt;&lt; (n))
#define mix(a, b, c)                                                           \
  {                                                                            \
    a -= b;                                                                    \
    a -= c;                                                                    \
    a ^= (c &gt;&gt; 13);                                                            \
    b -= c;                                                                    \
    b -= a;                                                                    \
    b ^= (a &lt;&lt; 8);                                                             \
    c -= a;                                                                    \
    c -= b;                                                                    \
    c ^= (b &gt;&gt; 13);                                                            \
    a -= b;                                                                    \
    a -= c;                                                                    \
    a ^= (c &gt;&gt; 12);                                                            \
    b -= c;                                                                    \
    b -= a;                                                                    \
    b ^= (a &lt;&lt; 16);                                                            \
    c -= a;                                                                    \
    c -= b;                                                                    \
    c ^= (b &gt;&gt; 5);                                                             \
    a -= b;                                                                    \
    a -= c;                                                                    \
    a ^= (c &gt;&gt; 3);                                                             \
    b -= c;                                                                    \
    b -= a;                                                                    \
    b ^= (a &lt;&lt; 10);                                                            \
    c -= a;                                                                    \
    c -= b;                                                                    \
    c ^= (b &gt;&gt; 15);                                                            \
  }
ub4 jenkins_hash(ub1 *k, ub4 length) {
  ub4 a, b, c, len, initval;
  initval = 0;
  len = length;
  a = b = 0x9e3779b9;   c = initval;          length++;
  while (len &gt;= 12) {
    a += (k[0] + ((ub4)k[1] &lt;&lt; 8) + ((ub4)k[2] &lt;&lt; 16) + ((ub4)k[3] &lt;&lt; 24));
    b += (k[4] + ((ub4)k[5] &lt;&lt; 8) + ((ub4)k[6] &lt;&lt; 16) + ((ub4)k[7] &lt;&lt; 24));
    c += (k[8] + ((ub4)k[9] &lt;&lt; 8) + ((ub4)k[10] &lt;&lt; 16) + ((ub4)k[11] &lt;&lt; 24));
    mix(a, b, c);
    k += 12;
    len -= 12;
  }
  c += length;
  switch (len)   {
  case 11:
    c += ((ub4)k[10] &lt;&lt; 24);   case 10:
    c += ((ub4)k[9] &lt;&lt; 16);   case 9:
    c += ((ub4)k[8] &lt;&lt; 8);   case 8:
    b += ((ub4)k[7] &lt;&lt; 24);   case 7:
    b += ((ub4)k[6] &lt;&lt; 16);   case 6:
    b += ((ub4)k[5] &lt;&lt; 8);   case 5:
    b += k[4];   case 4:
    a += ((ub4)k[3] &lt;&lt; 24);   case 3:
    a += ((ub4)k[2] &lt;&lt; 16);   case 2:
    a += ((ub4)k[1] &lt;&lt; 8);   case 1:
    a += k[0];   }
  mix(a, b, c);
  return (c);
}
void reset_rusage(rusage* r) {
  r-&gt;ru_utime.tv_sec = 0;
  r-&gt;ru_utime.tv_usec = 0;
  r-&gt;ru_stime.tv_sec = 0;
  r-&gt;ru_stime.tv_usec = 0;
}
#ifdef _MSC_VER
int _win_rename(const char *old, const char *new_name) {
  DWORD dwAttrib = GetFileAttributes(new_name);
  if (dwAttrib != INVALID_FILE_ATTRIBUTES &amp;&amp;
      !(dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY)) {
    if (ReplaceFile(new_name, old, NULL, REPLACEFILE_WRITE_THROUGH, NULL, NULL)) {
      return 0;
    }
    errno = EACCES;
    return -1;
  } else {
    return rename(old, new_name);
  }
}
#endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
