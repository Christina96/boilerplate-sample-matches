<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for react_outc_nfsim.c &amp; util.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for react_outc_nfsim.c &amp; util.c
      </h3>
<h1 align="center">
        2.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>react_outc_nfsim.c (4.428571%)<th>util.c (1.4265991%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(406-425)<td><a href="#" name="0">(169-179)</a><td align="center"><font color="#ff0000">19</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(209-226)<td><a href="#" name="1">(325-331)</a><td align="center"><font color="#a10000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>react_outc_nfsim.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;assert.h&gt;
3 #include &lt;math.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include "count_util.h"
7 #include "grid_util.h"
8 #include "logging.h"
9 #include "mcell_reactions.h"
10 #include "nfsim_func.h"
11 #include "react.h"
12 #include "react_nfsim.h"
13 #include "react_util.h"
14 #include "rng.h"
15 #include "util.h"
16 #include "vol_util.h"
17 #include "wall_util.h"
18 static queryOptions
19 initializeNFSimQueryforUnimolecularFiring(struct abstract_molecule *am,
20                                           const char *external_path);
21 static bool calculate_nfsim_reactivity(struct graph_data *);
22 static void calculate_nfsim_diffusion_derived_data(struct volume *state,
23                                                    struct graph_data *data);
24 void set_nfsim_product_geometries(struct pathway *path, struct rxn *rx,
25                                   int prod_orientation, int prod_index) {
26   if ((prod_orientation + path-&gt;orientation1) *
27               (prod_orientation - path-&gt;orientation1) ==
28           0 &amp;&amp;
29       prod_orientation * path-&gt;orientation1 != 0) {
30     if (prod_orientation == path-&gt;orientation1)
31       rx-&gt;geometries[prod_index] = 1;
32     else
33       rx-&gt;geometries[prod_index] = -1;
34   } else if (rx-&gt;n_reactants &gt; 1 &amp;&amp;
35              (prod_orientation + path-&gt;orientation2) *
36                      (prod_orientation - path-&gt;orientation2) ==
37                  0 &amp;&amp;
38              prod_orientation * path-&gt;orientation2 != 0) {
39     if (prod_orientation == path-&gt;orientation2)
40       rx-&gt;geometries[prod_index] = 2;
41     else
42       rx-&gt;geometries[prod_index] = -2;
43   } else {
44     rx-&gt;geometries[prod_index] = 1;
45   }
46 }
47 queryOptions initializeNFSimQueryNoFiring(struct abstract_molecule *am) {
48   queryOptions options;
49   static const char *optionKeys[1] = {"systemQuery"};
50   options.optionValues = CHECKED_MALLOC_ARRAY(char *, 1, "option array");
51   options.optionValues[0] = strdup("complex");
52   char **speciesArray =
53       CHECKED_MALLOC_ARRAY(char *, 1, "string array of patterns");
54   speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;
55   static const int optionSeeds[1] = {1};
56   options.initKeys = speciesArray;
57   options.initValues = optionSeeds;
58   options.numOfInitElements = 1;
59   options.optionKeys = optionKeys;
60   options.numOfOptions = 1;
61   return options;
62 }
63 queryOptions
64 initializeNFSimQueryforUnimolecularFiring(struct abstract_molecule *am,
65                                           const char *external_path) {
66   queryOptions options;
67   static const char *optionKeys[2] = {"systemQuery", "reaction"};
68   options.optionValues = CHECKED_MALLOC_ARRAY(char *, 2, "option array");
69   options.optionValues[0] = strdup("complex");
70   options.optionValues[1] = strdup(external_path);
71   char **speciesArray =
72       CHECKED_MALLOC_ARRAY(char *, 1, "string array of patterns");
73   speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;
74   static const int optionSeeds[1] = {1};
75   options.initKeys = speciesArray;
76   options.initValues = optionSeeds;
77   options.numOfInitElements = 1;
78   options.optionKeys = optionKeys;
79   options.numOfOptions = 2;
80   return options;
81 }
82 queryOptions
83 initializeNFSimQueryforBimolecularFiring(struct abstract_molecule *am,
84                                          struct abstract_molecule *am2,
85                                          const char *external_path) {
86   queryOptions options;
87   static const char *optionKeys[2] = {"systemQuery", "reaction"};
88   options.optionValues = CHECKED_MALLOC_ARRAY(char *, 2, "option array");
89   options.optionValues[0] = strdup("complex");
90   options.optionValues[1] = strdup(external_path);
91   char **speciesArray =
92       CHECKED_MALLOC_ARRAY(char *, 2, "string array of patterns");
93   speciesArray[0] = am-&gt;graph_data-&gt;graph_pattern;
94   speciesArray[1] = am2-&gt;graph_data-&gt;graph_pattern;
95   static const int optionSeeds[2] = {1, 1};
96   options.initKeys = speciesArray;
97   options.initValues = optionSeeds;
98   options.numOfInitElements = 2;
99   options.optionKeys = optionKeys;
100   options.numOfOptions = 2;
101   return options;
102 }
103 static void find_objects(struct geom_object* current_parent,
104                   const char* name1, struct geom_object** obj1,
105                   const char* name2, struct geom_object** obj2) {
106   struct geom_object* curr = current_parent;
107   while (curr != NULL) {
108     if (*obj1 == NULL &amp;&amp; curr-&gt;last_name != NULL &amp;&amp; strcmp(curr-&gt;last_name, name1) == 0) {
109       *obj1 = curr;
110     }
111     if (*obj2 == NULL &amp;&amp; curr-&gt;last_name != NULL &amp;&amp; strcmp(curr-&gt;last_name, name2) == 0) {
112       *obj2 = curr;
113     }
114     if (*obj1 != NULL &amp;&amp; *obj2 != NULL) {
115       return;
116     }
117     find_objects(curr-&gt;first_child, name1, obj1, name2, obj2);
118     curr = curr-&gt;next;
119   }
120 }
121 static bool has_region(struct geom_object* obj, const char* reg_name) {
122   for (struct region_list *r = obj-&gt;regions; r != NULL; r = r-&gt;next) {
123     if (r-&gt;reg != NULL &amp;&amp; strcmp(r-&gt;reg-&gt;region_last_name, reg_name) == 0) {
124       return true;
125     }
126   }
127   return false;
128 }
129 int prepare_reaction_nfsim(struct volume *world, struct rxn *rx, void *results,
130                            int path, struct abstract_molecule *reac,
131                            struct abstract_molecule *reac2) {
132 <a name="1"></a>
133   const char *product_pattern = NULL;
134   void *individualResult;
135 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  int numOfResults = mapvector_size(results);
136   for (int productIdx = 0; productIdx &lt; numOfResults; productIdx++) {
137     individualResult = mapvector_get(results, productIdx);
138     product_pattern = map_get(individualResult,
139                               "label");     constructNauty_c(product_pattern, 1);
140   }
141   rx-&gt;product_idx_aux[path] = numOfResults;
142   if (rx-&gt;nfsim_players[path] == NULL) {</b></font>
143     rx-&gt;nfsim_players[path] = CHECKED_MALLOC_ARRAY(
144         struct species *, numOfResults, "reaction players array");
145     rx-&gt;nfsim_geometries[path] = CHECKED_MALLOC_ARRAY(
146         short, numOfResults, "geometries associated to this path");
147   }
148   rx-&gt;product_graph_data[path] = CHECKED_MALLOC_ARRAY(
149       struct graph_data *, rx-&gt;product_idx_aux[path],
150       "graph patterns for products that have been added to the system");
151   int counter = 0;
152   const char *diffusion;
153   rx-&gt;external_reaction_data[path].products = numOfResults;
154   for (int productIdx = 0; productIdx &lt; numOfResults; productIdx++) {
155     individualResult = mapvector_get(results, productIdx);
156     product_pattern = map_get(individualResult,
157                               "label"); 
158     unsigned long graph_hash = lhash(product_pattern);
159     int error =
160         get_graph_data(graph_hash, &amp;rx-&gt;product_graph_data[path][counter]);
161     if (error != 0) {
162       rx-&gt;product_graph_data[path][counter] = CHECKED_MALLOC_ARRAY(
163           struct graph_data, 1, "graph pattern for a single path");
164       rx-&gt;product_graph_data[path][counter]-&gt;graph_pattern =
165           strdup(product_pattern);
166       rx-&gt;product_graph_data[path][counter]-&gt;graph_pattern_hash =
167           lhash(product_pattern);
168       diffusion = map_get(individualResult, "diffusion_function");
169       if (diffusion) {
170         rx-&gt;product_graph_data[path][counter]-&gt;graph_diffusion =
171             atof(diffusion);
172         calculate_nfsim_diffusion_derived_data(
173             world, rx-&gt;product_graph_data[path][counter]);
174       } else {
175         rx-&gt;product_graph_data[path][counter]-&gt;graph_diffusion = -1;
176         rx-&gt;product_graph_data[path][counter]-&gt;time_step = -1;
177         rx-&gt;product_graph_data[path][counter]-&gt;space_step = -1;
178       }
179       calculate_nfsim_reactivity(rx-&gt;product_graph_data[path][counter]);
180       store_graph_data(graph_hash, rx-&gt;product_graph_data[path][counter]);
181       world-&gt;n_NFSimSpecies += 1;
182     }
183     counter++;
184   }
185   int num_players = rx-&gt;n_reactants;
186   int kk = rx-&gt;n_pathways;
187   if (kk &lt;= RX_SPECIAL)
188     kk = 1;
189   for (int n_pathway = 0; n_pathway &lt; kk; n_pathway++) {
190     int k = rx-&gt;product_idx_aux[n_pathway] + rx-&gt;n_reactants;
191     rx-&gt;product_idx[n_pathway] = num_players;
192     num_players += k;
193   }
194   rx-&gt;product_idx[kk] = num_players;
195   if (rx-&gt;players != NULL)
196     free(rx-&gt;players);
197   free(rx-&gt;geometries);
198   rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
199                                      "reaction players array");
200   rx-&gt;geometries =
201       CHECKED_MALLOC_ARRAY(short, num_players, "reaction geometries array");
202   memset(rx-&gt;players, 0, sizeof(struct species *) * num_players);
203   memset(rx-&gt;geometries, 0, sizeof(short) * num_players);
204   struct pathway *pathp = (struct pathway *)CHECKED_MALLOC_STRUCT(
205       struct pathway, "reaction pathway");
206   if (pathp == NULL) {
207     return -1;
208   }
209   memset(pathp, 0, sizeof(struct pathway));
210   int num_vol_mols = 0;
211   int num_surface_mols = 0;
212   int all_3d = 1;
213   int reactant_idx = 0;
214   int oriented_count = 0;
215   bool orientation_flag1 = 0, orientation_flag2 = 0;
216   int reactantOrientation1, reactantOrientation2, productOrientation;
217   calculate_reactant_orientation(reac, reac2, &amp;orientation_flag1,
218                                  &amp;orientation_flag2, &amp;reactantOrientation1,
219                                  &amp;reactantOrientation2);
220   struct sym_entry *nfsim_molecule = reac-&gt;properties-&gt;sym;
221   rx-&gt;geometries[0] = reactantOrientation1;
222   struct mcell_species *reactants = mcell_add_to_species_list(
223       nfsim_molecule, orientation_flag1, reactantOrientation1, NULL);
224   if (reac2 != NULL) {
225     rx-&gt;geometries[1] = reactantOrientation2;
226     nfsim_molecule = reac2-&gt;properties-&gt;sym;
227     reactants = mcell_add_to_species_list(nfsim_molecule, orientation_flag2,
228                                           reactantOrientation2, reactants);
229   }
230   compartmentStruct *compartmentInfoArray =
231       CHECKED_MALLOC_ARRAY(compartmentStruct, numOfResults,
232                            "Creating array of compartment information");
233   for (int i = 0; i &lt; numOfResults; i++) {
234     individualResult = mapvector_get(results, i);
235     compartmentInfoArray[i] = getCompartmentInformation_c(map_get(
236         individualResult,
237         "compartment"));   }
238   struct species *nfsim_molecule_template;
239   if (compartmentInfoArray[0].spatialDimensions == 2)
240     nfsim_molecule_template = world-&gt;global_nfsim_surface;
241   else
242     nfsim_molecule_template = world-&gt;global_nfsim_volume;
243   if (orientation_flag2) {
244     orientation_flag1 = true;
245     individualResult = mapvector_get(results, 0);
246     const char* outside = compartmentInfoArray[0].outside;
247     const char* originalCompartment = map_get(individualResult, "originalCompartment");
248     bool originalCompartmentEmpty = strcmp(originalCompartment, "") == 0;
249     if (!originalCompartmentEmpty &amp;&amp; strcmp(outside, originalCompartment) == 0) {
250       productOrientation = -1;
251     }
252     else if (!originalCompartmentEmpty &amp;&amp; strcmp(outside, "") != 0) {
253       struct geom_object* objOutside = NULL;
254       struct geom_object* objOrigCompartment = NULL;
255       find_objects(world-&gt;root_instance, outside, &amp;objOutside, originalCompartment, &amp;objOrigCompartment);
256       if (objOutside != NULL &amp;&amp; objOrigCompartment != NULL) {
257         mcell_warn(
258             "Handling orientation of NFsim reaction where both compartents %s (orig) and %s (outside) are objects is not supported yet, "
259             "using default orientation 1 (outside)", originalCompartment, outside);
260         productOrientation = 1;
261       } else if (objOutside == NULL &amp;&amp; objOrigCompartment == NULL) {
262         mcell_error(
263             "NFsim reaction returned compartments %s (orig) and %s (outside) that were not identified as object, this is not supported yet.",
264             originalCompartment, outside
265         );
266 <a name="0"></a>        exit(1);
267       } else {
268         if (objOrigCompartment != NULL) {
269 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>          if (has_region(objOrigCompartment, outside)) {
270             productOrientation = -1;
271           } else {
272             mcell_warn(
273                 "Handling orientation of NFsim reaction where both compartent %s (orig) and %s (outside) are not in object-region relationship is not supported yet, "
274                 "using default orientation 1 (outside)", originalCompartment, outside);
275             productOrientation = 1;
276           }
277         } else {
278           if (has_region(objOutside, originalCompartment)) {
279             productOrientation = 1;
280           } else {
281             productOrientation = 1;
282           }</b></font>
283         }
284       }
285     } else {
286       productOrientation = 1;
287     }
288   } else {
289     orientation_flag1 = false;
290     productOrientation = 0;
291   }
292   struct mcell_species *products =
293       mcell_add_to_species_list(nfsim_molecule_template-&gt;sym, orientation_flag1,
294                                 productOrientation, NULL);
295   rx-&gt;nfsim_geometries[path][0] = productOrientation;
296   for (int i = 1; i &lt; numOfResults; i++) {
297     if (compartmentInfoArray[i].spatialDimensions == 2)
298       nfsim_molecule_template = world-&gt;global_nfsim_surface;
299     else
300       nfsim_molecule_template = world-&gt;global_nfsim_volume;
301     if (orientation_flag2) {
302       individualResult = mapvector_get(results, i);
303       if (strcmp(compartmentInfoArray[i].outside,
304                  map_get(individualResult, "originalCompartment")) ==
305           0) {         productOrientation = -1;
306       } else {
307         productOrientation = 1;
308       }
309     } else {
310       productOrientation = 0;
311     }
312     rx-&gt;nfsim_geometries[path][i] = productOrientation;
313     products = mcell_add_to_species_list(nfsim_molecule_template-&gt;sym,
314                                          orientation_flag1, productOrientation,
315                                          products);
316   }
317   for (int i = 0; i &lt; numOfResults; i++) {
318     delete_compartmentStructs(compartmentInfoArray[i]);
319   }
320   free(compartmentInfoArray);
321   if (extract_reactants(pathp, reactants, &amp;reactant_idx, &amp;num_vol_mols,
322                         &amp;num_surface_mols, &amp;all_3d, &amp;oriented_count) != 0) {
323     return -1;
324   }
325   int num_surf_products = 0;
326   int bidirectional = 0;
327   if (extract_products(world-&gt;notify, pathp, products, &amp;num_surf_products,
328                        bidirectional, all_3d) == MCELL_FAIL) {
329     return MCELL_FAIL;
330   }
331   mcell_delete_species_list(reactants);
332   mcell_delete_species_list(products);
333   int k = 0;
334   struct product *prod = NULL;
335   counter = 0;
336   for (prod = pathp-&gt;product_head; counter &lt; numOfResults;) {
337     rx-&gt;nfsim_players[path][counter] = prod-&gt;prod;
338     ++counter;
339     if (counter &lt; numOfResults)
340       prod = prod-&gt;next;
341   }
342   prod-&gt;next = NULL;
343   if (rx-&gt;players != NULL) {
344     free(rx-&gt;players);
345     free(rx-&gt;geometries);
346   }
347   rx-&gt;players = CHECKED_MALLOC_ARRAY(struct species *, num_players,
348                                      "reaction players array");
349   rx-&gt;geometries =
350       CHECKED_MALLOC_ARRAY(short, num_players, "reaction geometries array");
351   memset(rx-&gt;players, 0, sizeof(struct species *) * num_players);
352   memset(rx-&gt;geometries, 0, sizeof(short) * num_players);
353   rx-&gt;players[0] = pathp-&gt;reactant1;
354   if (reac2 != NULL)
355     rx-&gt;players[1] = pathp-&gt;reactant2;
356   for (int n_pathway = 0; n_pathway &lt; rx-&gt;n_pathways; n_pathway++) {
357     k = rx-&gt;product_idx[n_pathway] + rx-&gt;n_reactants;
358     counter = 0;
359     for (counter = 0; counter &lt; rx-&gt;product_idx_aux[n_pathway]; counter++) {
360       kk = k;
361       k++;
362       rx-&gt;players[kk] = rx-&gt;nfsim_players[n_pathway][counter];
363       set_nfsim_product_geometries(
364           pathp, rx, rx-&gt;nfsim_geometries[n_pathway][counter], kk);
365     }
366   } 
367   init_reaction_info(rx);
368   rx-&gt;info[path].pathname = NULL;
369   struct product *tmp = pathp-&gt;product_head;
370   struct product *tmp2 = NULL;
371   while (tmp != NULL) {
372     tmp2 = tmp-&gt;next;
373     free(tmp);
374     tmp = tmp2;
375   }
376   free(pathp);
377   return MCELL_SUCCESS;
378 }
379 void free_reaction_nfsim(struct rxn *rx, int path) {
380   free(rx-&gt;nfsim_players[path]);
381   free(rx-&gt;nfsim_geometries[path]);
382   free(rx-&gt;product_graph_data[path]);
383   rx-&gt;nfsim_players[path] = NULL;
384   rx-&gt;nfsim_geometries[path] = NULL;
385   rx-&gt;product_graph_data[path] = NULL;
386 }
387 void calculate_nfsim_diffusion_derived_data(struct volume *state,
388                                             struct graph_data *data) {
389   double global_time_unit = state-&gt;time_unit;
390   const char *compartment1 =
391       extractSpeciesCompartmentFromNauty_c(data-&gt;graph_pattern);
392   compartmentStruct reactantCompartmentInfo1 =
393       getCompartmentInformation_c(compartment1);
394   free((char*)compartment1);
395   if (!distinguishable(state-&gt;space_step, 0, EPS_C))   {
396     data-&gt;space_step =
397         sqrt(4.0 * 1.0e8 * data-&gt;graph_diffusion * global_time_unit) *
398         state-&gt;r_length_unit;
399     data-&gt;time_step = 1.0;
400   } else   {
401     double space_step = state-&gt;space_step * state-&gt;length_unit;
402     if (reactantCompartmentInfo1.spatialDimensions == 2) {
403       data-&gt;time_step =
404           space_step * space_step /
405           (MY_PI * 1.0e8 * data-&gt;graph_diffusion * global_time_unit);
406     } else {
407       data-&gt;time_step =
408           space_step * space_step * MY_PI /
409           (16.0 * 1.0e8 * data-&gt;graph_diffusion * global_time_unit);
410     }
411     data-&gt;space_step = sqrt(4.0 * 1.0e8 * data-&gt;graph_diffusion *
412                             data-&gt;time_step * global_time_unit) *
413                        state-&gt;r_length_unit;
414   }
415   free(reactantCompartmentInfo1.name);
416   free(reactantCompartmentInfo1.outside);
417 }
418 bool calculate_nfsim_reactivity(struct graph_data *graph) {
419   graph-&gt;flags = 0;
420   queryOptions options =
421       initializeNFSimQueryForBimolecularReactions(graph, NULL, "0");
422   void *results = mapvectormap_create();
423   initAndQueryByNumReactant_c(options, results);
424   bool dimensionalityFlag = true;
425   if (mapvectormap_size(results) &gt; 0) {
426     char **resultKeys = mapvectormap_getKeys(results);
427     void *headComplex = mapvectormap_get(results, resultKeys[0]);
428     int resultSize = mapvectormap_size(results);
429     for (int i = 0; i &lt; resultSize; i++) {
430       free(resultKeys[i]);
431     }
432     free(resultKeys);
433     int headNumAssociatedReactions = mapvector_size(headComplex);
434     void *pathInformation;
435     for (int path = 0; path &lt; headNumAssociatedReactions; path++) {
436       pathInformation = mapvector_get(headComplex, path);
437       const char *dimensionality =
438           map_get(pathInformation, "reactionDimensionality");
439       if (!dimensionality) {
440         dimensionalityFlag = false;
441         break;
442       }
443       if (strcmp(dimensionality, "VOLSURF") == 0) {
444         graph-&gt;flags |= CAN_VOLSURF;
445       }
446       if (strcmp(dimensionality, "VOLVOL") == 0) {
447         graph-&gt;flags |= CAN_VOLVOL;
448       }
449       if (strcmp(dimensionality, "SURFSURF") == 0) {
450         graph-&gt;flags |= CAN_SURFSURF;
451       }
452     }
453   }
454   mapvectormap_delete(results);
455   if (dimensionalityFlag) {
456     return true;
457   } else {
458     graph-&gt;flags = -1;
459     return false;
460   }
461 }
462 void properties_nfsim(struct volume *world, struct abstract_molecule *reac) {
463   queryOptions options = initializeNFSimQueryNoFiring(reac);
464   void *results = mapvector_create();
465   initAndQuerySystemStatus_c(options, results);
466   void *individualResult = mapvector_get(results, 0);
467   const char *result = map_get(individualResult, "diffusion_function");
468   if (result) {
469     reac-&gt;graph_data-&gt;graph_diffusion = atof(result);
470     calculate_nfsim_diffusion_derived_data(world, reac-&gt;graph_data);
471   } else {
472     reac-&gt;graph_data-&gt;graph_diffusion = -1;
473     reac-&gt;graph_data-&gt;space_step = -1;
474     reac-&gt;graph_data-&gt;time_step = -1;
475     reac-&gt;get_diffusion = get_standard_diffusion;
476     reac-&gt;get_space_step = get_standard_space_step;
477     reac-&gt;get_time_step = get_standard_time_step;
478   }
479   mapvector_delete(results);
480   if (calculate_nfsim_reactivity(reac-&gt;graph_data)) {
481     reac-&gt;get_flags = get_nfsim_flags;
482   } else {
483     reac-&gt;get_flags = get_standard_flags;
484   }
485   free(options.optionValues[0]);
486   free(options.optionValues);
487   free(options.initKeys);
488 }
489 int outcome_nfsim(struct volume *world, struct rxn *rx, int path,
490                   struct abstract_molecule *reac,
491                   struct abstract_molecule *reac2, double t) {
492   int result = RX_A_OK;
493   queryOptions options;
494   if (rx-&gt;product_idx_aux[path] != -1 &amp;&amp;
495       rx-&gt;external_reaction_data[path].resample == 1) {
496     free_reaction_nfsim(rx, path);
497     rx-&gt;product_idx_aux[path] = -1;
498   }
499   if (rx-&gt;product_idx_aux[path] == -1) {
500     world-&gt;n_NFSimReactions += 1;
501     if (reac2 == NULL)
502       options = initializeNFSimQueryforUnimolecularFiring(
503           reac, rx-&gt;external_reaction_data[path].reaction_name);
504     else {
505       options = initializeNFSimQueryforBimolecularFiring(
506           reac, reac2, rx-&gt;external_reaction_data[path].reaction_name);
507     }
508     void *results = mapvector_create();
509     initAndQuerySystemStatus_c(options, results);
510     free(options.optionValues[0]);
511     free(options.optionValues[1]);
512     free(options.optionValues);
513     free(options.initKeys);
514     prepare_reaction_nfsim(world, rx, results, path, reac, reac2);
515     mapvector_delete(results);
516   }
517   else {
518     for (int i = 0; i &lt; rx-&gt;product_idx_aux[path]; i++) {
519       constructNauty_c(rx-&gt;product_graph_data[path][i]-&gt;graph_pattern, 1);
520     }
521     rx-&gt;info[path].pathname = NULL;
522   }
523   constructNauty_c(reac-&gt;graph_data-&gt;graph_pattern, -1);
524   if (reac2 != NULL)
525     constructNauty_c(reac2-&gt;graph_data-&gt;graph_pattern, -1);
526   return result;
527 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>util.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;assert.h&gt;
3 #include &lt;float.h&gt;
4 #include &lt;math.h&gt;
5 #include &lt;inttypes.h&gt;
6 #include &lt;memory.h&gt;
7 #include &lt;stdio.h&gt;
8 #include &lt;stdlib.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;sys/stat.h&gt;
11 #include &lt;stdbool.h&gt;
12 #include &lt;vector&gt;
13 #ifndef _MSC_VER
14 #include &lt;unistd.h&gt;
15 #include &lt;sys/resource.h&gt; #else
16 typedef unsigned int uint;
17 #endif
18 #include "logging.h"
19 #include "util.h"
20 #include "mcell_structs.h"
21 #include "bng/shared_defines.h"
22 #include "bng/filesystem_utils.h"
23 struct bit_array *new_bit_array(int bits) {
24   int n = (bits + 8 * sizeof(int) - 1) / (8 * sizeof(int));
25   struct bit_array *ba = (struct bit_array *)malloc(sizeof(struct bit_array) +
26     sizeof(int) * n);
27   if (ba == NULL) {
28     return NULL;
29   }
30   ba-&gt;nbits = bits;
31   ba-&gt;nints = n;
32   return ba;
33 }
34 struct bit_array *duplicate_bit_array(struct bit_array *old) {
35   struct bit_array *ba = (struct bit_array *)malloc(sizeof(struct bit_array) +
36     sizeof(int) * old-&gt;nints);
37   if (ba == NULL) {
38     return NULL;
39   }
40   memcpy(ba, old, sizeof(struct bit_array) + sizeof(int) * old-&gt;nints);
41   return ba;
42 }
43 int get_bit(struct bit_array *ba, int idx) {
44   int *data = &amp;(ba-&gt;nints);
45   data++; 
46   size_t ofs = idx &amp; (8 * sizeof(int) - 1);
47   idx = idx / (8 * sizeof(int));
48   ofs = 1u &lt;&lt; ofs;
49   if ((data[idx] &amp; ofs) != 0) {
50     return 1;
51   } else {
52     return 0;
53   }
54 }
55 void set_bit(struct bit_array *ba, int idx, int value) {
56   int *data = &amp;(ba-&gt;nints);
57   data++; 
58   size_t ofs = idx &amp; (8 * sizeof(int) - 1);
59   idx = idx / (8 * sizeof(int));
60   ofs = (1u &lt;&lt; ofs);
61   if (value) {
62     value = ofs;
63   } else {
64     value = 0;
65   }
66   data[idx] = (data[idx] &amp; ~ofs) | value;
67 }
68 void set_bit_range(struct bit_array *ba, int idx1, int idx2, int value) {
69   int *data = &amp;(ba-&gt;nints);
70   data++; 
71   int ofs1 = idx1 &amp; (8 * sizeof(int) - 1);
72   int ofs2 = idx2 &amp; (8 * sizeof(int) - 1);
73   idx1 = idx1 / (8 * sizeof(int));
74   idx2 = idx2 / (8 * sizeof(int));
75   unsigned int mask, cmask;
76   if (idx1 == idx2) {
77     mask = 0;
78     for (int i = ofs1; i &lt;= ofs2; i++) {
79       mask |= (1u &lt;&lt; i);
80 <a name="0"></a>    }
81     cmask = ~mask;
82 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (value) {
83       data[idx1] = (data[idx1] &amp; cmask) | mask;
84     } else {
85       data[idx1] = data[idx1] &amp; cmask;
86     }
87   } else {
88     if (value) {
89       value = ~0;
90     } else {
91       value = 0;
92     }</b></font>
93     for (int i = idx1 + 1; i &lt; idx2; i++) {
94       data[i] = value;
95     }
96     mask = 0;
97     for (unsigned int i = ofs1; i &lt; 8 * sizeof(int); i++) {
98       mask |= (1u &lt;&lt; i);
99     }
100     cmask = ~mask;
101     if (value) {
102       data[idx1] = (data[idx1] &amp; cmask) | mask;
103     } else {
104       data[idx1] = data[idx1] &amp; cmask;
105     }
106     mask = 0;
107     for (int i = 0; i &lt;= ofs2; i++) {
108       mask |= (1u &lt;&lt; i);
109     }
110     cmask = ~mask;
111     if (value) {
112       data[idx2] = (data[idx2] &amp; cmask) | mask;
113     } else {
114       data[idx2] = data[idx2] &amp; cmask;
115     }
116   }
117 }
118 void set_all_bits(struct bit_array *ba, int value) {
119   if (value) {
120     value = ~0;
121   }
122   int *data = &amp;(ba-&gt;nints);
123   data++; 
124   for (int i = 0; i &lt; ba-&gt;nints; i++) {
125     data[i] = value;
126   }
127 }
128 void bit_operation(struct bit_array *ba, struct bit_array *bb, char op) {
129   int *da, *db;
130   if (op == '!' || op == '~') {
131     da = &amp;(ba-&gt;nints);
132     da++;
133     for (int i = 0; i &lt; ba-&gt;nints; i++) {
134       da[i] = ~da[i];
135     }
136     return;
137   }
138   if (ba-&gt;nbits != bb-&gt;nbits) {
139     return;
140   }
141   da = &amp;(ba-&gt;nints);
142   da++;
143   db = &amp;(bb-&gt;nints);
144   db++;
145   switch (op) {
146   case '^':
147     for (int i = 0; i &lt; ba-&gt;nints; i++) {
148       da[i] ^= db[i];
149     }
150     break;
151   case '|':
152   case '+':
153     for (int i = 0; i &lt; ba-&gt;nints; i++) {
154       da[i] |= db[i];
155     }
156     break;
157   case '-':
158     for (int i = 0; i &lt; ba-&gt;nints; i++) {
159       da[i] &amp;= ~db[i];
160     }
161     break;
162   case '&amp;':
163     for (int i = 0; i &lt; ba-&gt;nints; i++) {
164       da[i] &amp;= db[i];
165     }
166     break;
167   default:
168     break;
169   }
170 }
171 int count_bits(struct bit_array *ba) {
172   static const int cb_table[256] = {
173     0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4,
174     2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
175     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4,
176     2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
177     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,
178     4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
179     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5,
180     3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
181     2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6,
182     4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
183     4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
184   };
185   int *dd = &amp;(ba-&gt;nints);
186   dd++;
187 <a name="1"></a>  unsigned char *d = (unsigned char *)dd;
188   int n = (ba-&gt;nints - 1) * sizeof(int);
189 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int cnt = 0;
190   for (int i = 0; i &lt; n; i++) {
191     cnt += cb_table[(*d++)];
192   }
193   n = ba-&gt;nbits - n * 8;
194   if (n == 0)</b></font>
195     return cnt;
196   int j = dd[ba-&gt;nints - 1];
197   while (n &gt;= 8) {
198     cnt += cb_table[j &amp; 0xFF];
199     n -= 8;
200     j &gt;&gt;= 8;
201   }
202   if (n &gt; 0) {
203     cnt += cb_table[j &amp; 0xFF] - cb_table[(j &amp; 0xFF) &gt;&gt; n];
204   }
205   return cnt;
206 }
207 void free_bit_array(struct bit_array *ba) { free(ba); }
208 int bisect(double *list, int n, double val) {
209   int lo = 0;
210   int hi = n;
211   int mid = 0;
212   while (hi - lo &gt; 1) {
213     mid = (hi + lo) / 2;
214     if (list[mid] &gt; val)
215     {
216       hi = mid;
217     } else {
218       lo = mid;
219     }
220   }
221   return lo;
222 }
223 int bisect_near(double *list, int n, double val) {
224   int lo = 0;
225   int hi = n - 1;
226   int mid = 0;
227   while (hi - lo &gt; 1) {
228     mid = (hi + lo) / 2;
229     if (list[mid] &gt; val)
230     {
231       hi = mid;
232     } else {
233       lo = mid;
234     }
235   }
236   if (val &gt; list[hi]) {
237     return hi;
238   } else if (val &lt; list[lo]) {
239     return lo;
240   } else if (val - list[lo] &lt; list[hi] - val) {
241     return lo;
242   } else {
243     return hi;
244   }
245 }
246 int bisect_high(double *list, int n, double val) {
247   int lo = 0;
248   int hi = n - 1;
249   int mid = 0;
250   while (hi - lo &gt; 1) {
251     mid = (hi + lo) / 2;
252     if (list[mid] &gt; val) {
253       hi = mid;
254     } else {
255       lo = mid;
256     }
257   }
258   if (list[lo] &gt; val)
259   {
260     return lo;
261   } else {
262     return hi;
263   }
264 }
265 int distinguishable(double a, double b, double eps) {
266   double c = fabs(a - b);
267   a = fabs(a);
268   if (a &lt; 1) {
269     a = 1;
270   }
271   b = fabs(b);
272   if (b &lt; a) {
273     eps *= a;
274   } else {
275     eps *= b;
276   }
277   return (c &gt; eps);
278 }
279 int is_reverse_abbrev(const char *abbrev, const char *full) {
280   size_t na = strlen(abbrev);
281   size_t nf = strlen(full);
282   if (na &gt; nf) {
283     return 0;
284   }
285   return (strcmp(abbrev, full + (nf - na)) == 0);
286 }
287 struct void_list *void_list_sort(struct void_list *vl) {
288   struct void_list *stack[64];
289   int stack_n[64];
290   struct void_list *left, *right, *merge, *tail;
291   int si = 0;
292   stack[0] = NULL;
293   while (vl != NULL) {
294     if (vl-&gt;next == NULL) {
295       stack[si] = vl;
296       stack_n[si] = 1;
297       vl = NULL;
298       si++;
299     } else if ((intptr_t)vl-&gt;data &lt;= (intptr_t)vl-&gt;next-&gt;data) {
300       stack[si] = vl;
301       stack_n[si] = 2;
302       vl = vl-&gt;next-&gt;next;
303       stack[si]-&gt;next-&gt;next = NULL;
304       si++;
305     } else {
306       stack[si] = vl-&gt;next;
307       stack_n[si] = 2;
308       left = vl;
309       vl = vl-&gt;next-&gt;next;
310       stack[si]-&gt;next = left;
311       left-&gt;next = NULL;
312       si++;
313     }
314     while (si &gt; 1 &amp;&amp; stack_n[si - 1] * 2 &gt;= stack_n[si - 2]) {
315       stack_n[si - 2] += stack_n[si - 1];
316       left = stack[si - 2];
317       right = stack[si - 1];
318       if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
319         merge = left;
320         left = left-&gt;next;
321       } else {
322         merge = right;
323         right = right-&gt;next;
324       }
325       merge-&gt;next = NULL;
326       tail = merge;
327       while (1) {
328         if (left == NULL) {
329           tail-&gt;next = right;
330           break;
331         }
332         if (right == NULL) {
333           tail-&gt;next = left;
334           break;
335         }
336         if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
337           tail-&gt;next = left;
338           tail = left;
339           left = left-&gt;next;
340         } else {
341           tail-&gt;next = right;
342           tail = right;
343           right = right-&gt;next;
344         }
345       }
346       stack[si - 2] = merge;
347       si--;
348     }
349   }
350   while (si &gt; 1)   {
351     stack_n[si - 2] += stack_n[si - 1];
352     left = stack[si - 2];
353     right = stack[si - 1];
354     if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
355       merge = left;
356       left = left-&gt;next;
357     } else {
358       merge = right;
359       right = right-&gt;next;
360     }
361     merge-&gt;next = NULL;
362     tail = merge;
363     while (1) {
364       if (left == NULL) {
365         tail-&gt;next = right;
366         break;
367       }
368       if (right == NULL) {
369         tail-&gt;next = left;
370         break;
371       }
372       if ((intptr_t)left-&gt;data &lt;= (intptr_t)right-&gt;data) {
373         tail-&gt;next = left;
374         tail = left;
375         left = left-&gt;next;
376       } else {
377         tail-&gt;next = right;
378         tail = right;
379         right = right-&gt;next;
380       }
381     }
382     stack[si - 2] = merge;
383     si--;
384   }
385   return stack[0];
386 }
387 struct void_list *void_list_sort_by(struct void_list *vl,
388                                     int (*leq)(void *, void *)) {
389   struct void_list *stack[64];
390   int stack_n[64];
391   struct void_list *left, *right, *merge, *tail;
392   int si = 0;
393   stack[0] = NULL;
394   while (vl != NULL) {
395     if (vl-&gt;next == NULL) {
396       stack[si] = vl;
397       stack_n[si] = 1;
398       vl = NULL;
399       si++;
400     } else if ((*leq)(vl-&gt;data, vl-&gt;next-&gt;data)) {
401       stack[si] = vl;
402       stack_n[si] = 2;
403       vl = vl-&gt;next-&gt;next;
404       stack[si]-&gt;next-&gt;next = NULL;
405       si++;
406     } else {
407       stack[si] = vl-&gt;next;
408       stack_n[si] = 2;
409       left = vl;
410       vl = vl-&gt;next-&gt;next;
411       stack[si]-&gt;next = left;
412       left-&gt;next = NULL;
413       si++;
414     }
415     while (si &gt; 1 &amp;&amp; stack_n[si - 1] * 2 &gt;= stack_n[si - 2]) {
416       stack_n[si - 2] += stack_n[si - 1];
417       left = stack[si - 2];
418       right = stack[si - 1];
419       if ((*leq)(left-&gt;data, right-&gt;data)) {
420         merge = left;
421         left = left-&gt;next;
422       } else {
423         merge = right;
424         right = right-&gt;next;
425       }
426       merge-&gt;next = NULL;
427       tail = merge;
428       while (1) {
429         if (left == NULL) {
430           tail-&gt;next = right;
431           break;
432         }
433         if (right == NULL) {
434           tail-&gt;next = left;
435           break;
436         }
437         if ((*leq)(left-&gt;data, right-&gt;data)) {
438           tail-&gt;next = left;
439           tail = left;
440           left = left-&gt;next;
441         } else {
442           tail-&gt;next = right;
443           tail = right;
444           right = right-&gt;next;
445         }
446       }
447       stack[si - 2] = merge;
448       si--;
449     }
450   }
451   while (si &gt; 1)   {
452     stack_n[si - 2] += stack_n[si - 1];
453     left = stack[si - 2];
454     right = stack[si - 1];
455     if ((*leq)(left-&gt;data, right-&gt;data)) {
456       merge = left;
457       left = left-&gt;next;
458     } else {
459       merge = right;
460       right = right-&gt;next;
461     }
462     merge-&gt;next = NULL;
463     tail = merge;
464     while (1) {
465       if (left == NULL) {
466         tail-&gt;next = right;
467         break;
468       }
469       if (right == NULL) {
470         tail-&gt;next = left;
471         break;
472       }
473       if ((*leq)(left-&gt;data, right-&gt;data)) {
474         tail-&gt;next = left;
475         tail = left;
476         left = left-&gt;next;
477       } else {
478         tail-&gt;next = right;
479         tail = right;
480         right = right-&gt;next;
481       }
482     }
483     stack[si - 2] = merge;
484     si--;
485   }
486   return stack[0];
487 }
488 int void_array_search(void **array, int n, void *to_find) {
489   int lo = 0;
490   int hi = n - 1;
491   int m;
492   while (hi - lo &gt; 1) {
493     m = (hi + lo) / 2;
494     if (to_find == array[m]) {
495       return m;
496     } else if ((intptr_t)to_find &gt; (intptr_t)array[m]) {
497       lo = m;
498     } else {
499       hi = m;
500     }
501   }
502   if (to_find == array[lo]) {
503     return lo;
504   }
505   if (to_find == array[hi]) {
506     return hi;
507   }
508   return -1;
509 }
510 int void_ptr_compare(void const *v1, void const *v2) {
511   void const **v1p = (void const **)v1;
512   void const **v2p = (void const **)v2;
513   intptr_t i1 = (intptr_t) * v1p;
514   intptr_t i2 = (intptr_t) * v2p;
515   if (i1 &lt; i2) {
516     return -1;
517   } else if (i1 &gt; i2) {
518     return 1;
519   }
520   return 0;
521 }
522 u_int *allocate_uint_array(int size, u_int value) {
523   u_int *arr;
524   if ((arr = CHECKED_MALLOC_ARRAY_NODIE(u_int, size, NULL)) == NULL) {
525     return NULL;
526   }
527   for (int i = 0; i &lt; size; ++i) {
528     arr[i] = value;
529   }
530   return arr;
531 }
532 void **allocate_ptr_array(int size) {
533   if (size == 0) {
534     size = 1;
535   }
536   void **arr;
537   if ((arr = CHECKED_MALLOC_ARRAY_NODIE(void *, size, NULL)) == NULL) {
538     return NULL;
539   }
540   memset(arr, 0, size * sizeof(void *));
541   return arr;
542 }
543 void free_ptr_array(void **pa, int count) {
544   for (int i = 0; i &lt; count; ++i) {
545     if (pa[i] != NULL) {
546       free(pa[i]);
547     }
548   }
549   free(pa);
550 }
551 void free_num_expr_list(struct num_expr_list *nlist) {
552   struct num_expr_list *nnext;
553   while (nlist != NULL) {
554     nnext = nlist-&gt;next;
555     free(nlist);
556     nlist = nnext;
557   }
558 }
559 int dir_exists(char const *path) {
560 #ifdef _MSC_VER   release_assert(false);
561   return false;
562 #else
563   struct stat sb;
564   if (stat(path, &amp;sb) == 0 &amp;&amp; S_ISDIR(sb.st_mode)) {
565     return 1;
566   }
567   return 0;
568 #endif
569 }
570 int is_writable_dir(char const *path) {
571 #ifdef _MSC_VER   release_assert(false);
572   return false;
573 #else
574   if (dir_exists(path) &amp;&amp; !access(path, R_OK | W_OK | X_OK)) {
575     return 1;
576   }
577   return 0;
578 #endif
579 }
580 int make_parent_dir(char const *path) {
581   FSUtils::make_dir_for_file_w_multiple_attempts(path);
582   return 0;
583 }
584 int mkdirs(char const *path) {
585   char *pathtmp = CHECKED_STRDUP(path, "directory path");
586   char *curpos = pathtmp;
587   while (curpos != NULL &amp;&amp; *curpos == '/') {
588     ++curpos;
589   }
590   while (curpos != NULL) {
591     char *nextel = strchr(curpos, '/');
592     if (nextel != NULL) {
593       *nextel = '\0';
594     }
595     if (dir_exists(pathtmp)) {
596       if (nextel) {
597         *nextel = '/';
598         curpos = nextel + 1;
599       } else {
600         curpos = NULL;
601       }
602       continue;
603     }
604     if (!is_writable_dir(pathtmp) &amp;&amp; mkdir(pathtmp, 0777) != 0) {
605       mcell_perror_nodie(errno, "Failed to create directory '%s'", path);
606       free(pathtmp);
607       return 1;
608     }
609     if (nextel) {
610       *nextel = '/';
611       curpos = nextel + 1;
612     } else {
613       curpos = NULL;
614     }
615   }
616   free(pathtmp);
617   return 0;
618 }
619 FILE *open_file(const char *fname, const char *mode) {
620   FILE *f;
621   if ((f = fopen(fname, mode)) == NULL) {
622     mcell_perror_nodie(errno, "Failed to open file %s.", fname);
623     return NULL;
624   }
625   return f;
626 }
627 double erfcinv(double x) {
628   static const double tail_cutoff = 0.0485;
629   static const double neg_twice_log_half = 1.386294361119891;
630   static const double scaling_const = -0.7071067811865475;
631   static const double tn0 = 2.938163982698783;
632   static const double tn1 = 4.374664141464968;
633   static const double tn2 = -2.549732539343734;
634   static const double tn3 = -2.400758277161838;
635   static const double tn4 = -3.223964580411365e-1;
636   static const double tn5 = -7.784894002430293e-3;
637   static const double td1 = 3.754408661907416;
638   static const double td2 = 2.445134137142996;
639   static const double td3 = 3.224671290700398e-1;
640   static const double td4 = 7.784695709041462e-3;
641   static const double cn0 = 2.506628277459239;
642   static const double cn1 = -3.066479806614716e1;
643   static const double cn2 = 1.383577518672690e2;
644   static const double cn3 = -2.759285104469687e2;
645   static const double cn4 = 2.209460984245205e2;
646   static const double cn5 = -3.969683028665376e1;
647   static const double cd1 = -1.328068155288572e1;
648   static const double cd2 = 6.680131188771972e1;
649   static const double cd3 = -1.556989798598866e2;
650   static const double cd4 = 1.615858368580409e2;
651   static const double cd5 = -5.447609879822406e1;
652   double p, q, r;
653   if (x &lt; tail_cutoff) {
654     p = sqrt(-2 * log(x) + neg_twice_log_half);
655     r = (tn0 + p * (tn1 + p * (tn2 + p * (tn3 + p * (tn4 + p * tn5))))) /
656         (1.0 + p * (td1 + p * (td2 + p * (td3 + p * td4))));
657   } else {
658     p = 0.5 * x - 0.5;
659     q = p * p;
660     r = p * (cn0 + q * (cn1 + q * (cn2 + q * (cn3 + q * (cn4 + q * cn5))))) /
661         (1.0 + q * (cd1 + q * (cd2 + q * (cd3 + q * (cd4 + q * cd5)))));
662   }
663   return scaling_const * r;
664 }
665 int poisson_dist(double lambda, double p) {
666   int i, lo, hi;
667   double plo, phi, pctr;
668   double lambda_i;
669   i = (int)lambda;
670   pctr = exp(-lambda + i * log(lambda) -
671              lgamma(i + 1)); 
672   if (p &lt; pctr)
673     return i;
674   lo = hi = i;
675   plo = phi = pctr; 
676   p -= pctr;
677   lambda_i = 1.0 / lambda;
678   while (p &gt; 0)   {
679     if (lo &gt; 0)     {
680       plo *= lo * lambda_i;       lo--;
681       if (p &lt; plo)
682         return lo;
683       p -= plo;
684     }
685     hi++;
686     phi = phi * lambda / hi;     if (p &lt; phi)
687       return hi;
688     p -= phi + DBL_EPSILON;   }
689   assert(false);
690   return -1;
691 }
692 void byte_swap(void *data, int size) {
693   if (size &lt; 2){
694     return;
695   }
696   unsigned char temp;
697   unsigned char *c = (unsigned char *)data;
698   for (int i = 0, j = size - 1; i &lt; j; i++, j--) {
699     temp = c[i];
700     c[i] = c[j];
701     c[j] = temp;
702   }
703 }
704 int feral_strlenn(char *feral, int n) {
705   int real_n = 0;
706   int i;
707   for (i = 0; i &lt; n; i++) {
708     if (feral[i] == '\\') {
709       i++;
710       if (feral[i] == '\0')
711         return real_n;
712     } else if (feral[i] == '[') {
713       while (i &lt; n &amp;&amp; feral[i] != ']') {
714         if (feral[i] == '\0')
715           return real_n;
716         if (feral[i] == '\\') {
717           i += 2;
718           if (i &gt; n || feral[i - 1] == '\0')
719             return real_n;
720         } else if (feral[i] == '-') {
721           i += 2;
722           if (i &gt; n || feral[i - 1] == '\0')
723             return real_n;
724         } else
725           i++;
726       }
727     } else if (feral[i] == '\0')
728       return real_n;
729     real_n++;
730   }
731   return real_n;
732 }
733 int is_feral_nabbrev(char *feral, int n, char *tame) {
734   char c, cc;
735   int i = 0;
736   int nfound = 0;
737   int ok;
738   if (n &lt;= 0)
739     return 0;
740   while (*tame != '\0') {
741     if (feral[i] == '[')     {
742       i++;
743       ok = 0;
744       while (i &lt; n &amp;&amp; feral[i] != ']') {
745         c = feral[i++];
746         if (c == '\0')
747           return 0;         if (c == '\\') {
748           if (i &gt;= n)
749             return 0;           c = feral[i++];
750           if (c == '\0')
751             return 0;         }
752         if (i &lt; n &amp;&amp; feral[i] == '-') {
753           i++;
754           if (i &gt;= n)
755             return 0;           cc = feral[i++];
756           if (cc == '\0')
757             return 0;           if (cc == '\\') {
758             if (i &gt;= n)
759               return 0;             cc = feral[i++];
760             if (cc == '\0')
761               return 0;           }
762           if (c &lt;= *tame &amp;&amp; *tame &lt;= cc) {
763             ok = 1;
764             break;
765           }
766         } else if (c == *tame) {
767           ok = 1;
768           break;
769         }
770       }
771       if (i &gt;= n)
772         return 0;       if (!ok)
773         return 0;                            tame++;                                while (i &lt; n &amp;&amp; feral[i] != ']')       {
774         if (feral[i] == '\0')
775           return 0;         if (feral[i] == '\\') {
776           i += 2;
777           if (i &gt; n || feral[i - 1] == '\0')
778             return 0;         } else
779           i++;
780       }
781       if (i &gt;= n)
782         return 0;       i++;
783     } else     {
784       c = feral[i++];
785       if (c == '\\') {
786         if (i &gt;= n)
787           return 0;         c = feral[i++];
788         if (c != *tame++)
789           return 0;       } else if (c != *tame++ &amp;&amp; c != '?')
790         return 0;     }
791     nfound++;
792     if (i &gt;= n)
793       return nfound;   }
794   return 0; }
795 char *feral_strstrn(char *tame_haystack, char *feral_needle, int n) {
796   char c = 0;
797   char cc;
798   char set[256];
799   int isset = 0;
800   int i, j;
801   int scoot = 0;
802   for (i = 0; i &lt; n; i++)
803     if (feral_needle[i] == '\0')
804       break;
805   n = i;
806   i = 0;
807   while (feral_needle[i] == '?' &amp;&amp; i &lt; n &amp;&amp; *tame_haystack != '\0') {
808     i++;
809     tame_haystack++;
810     scoot++;
811   }
812   if (i &gt;= n)
813     return tame_haystack - scoot;
814   if (feral_needle[i] == '[') {
815     isset = 1;
816     memset(set, 0, 256);
817     set[0] = 1;
818     i++;
819     while (i &lt; n &amp;&amp; feral_needle[i] != ']') {
820       c = feral_needle[i++];
821       if (feral_needle[i] == '\0')
822         return NULL;       if (c == '\\') {
823         if (i &gt;= n)
824           return NULL;         c = feral_needle[i++];
825       }
826       if (i &lt; n &amp;&amp; feral_needle[i] == '-') {
827         i++;
828         if (i &gt;= n)
829           return NULL;         cc = feral_needle[i++];
830         if (cc == '\0')
831           return NULL;         if (cc == '\\') {
832           if (i &gt;= n)
833             return NULL;           cc = feral_needle[i++];
834           if (cc == '\0')
835             return NULL;         }
836         for (j = (int)c; j &lt;= (int)cc; j++)
837           set[j] = 1;
838       } else
839         set[(int)c] = 1;
840     }
841     if (i &gt;= n)
842       return NULL;     i++;             } else {
843     c = feral_needle[i++];
844     if (c == '\\') {
845       if (i &gt;= n)
846         return NULL;       c = feral_needle[i++];
847     }
848     if (c == '\0')
849       return NULL;   }
850   while (*tame_haystack != '\0') {
851     {
852       while (!set[(int)*tame_haystack])
853         tame_haystack++;
854       if (*tame_haystack == '\0')
855         return NULL;
856     } else     {
857       while (*tame_haystack != c &amp;&amp; *tame_haystack != '\0')
858         tame_haystack++;
859       if (*tame_haystack == '\0')
860         return NULL;
861     }
862     if (i == n)
863       return tame_haystack - scoot;
864     else if (is_feral_nabbrev(feral_needle + i, n - i,
865     {
866       return tame_haystack - scoot;
867     }
868     tame_haystack++;
869   }
870   return NULL;
871 }
872 int is_wildcard_match(char *wild, char *tame) {
873   int nstars;
874   int n;
875   if (*wild == '\0' &amp;&amp; *tame == '\0')
876     return 1;
877   for (n = 0, nstars = 0; wild[n] != '\0'; n++) {
878     if (wild[n] == '[') {
879       n++;
880       while (wild[n] != '\0' &amp;&amp; wild[n] != ']') {
881         if (wild[n] == '\\') {
882           n++;
883           if (wild[n] == '\0')
884             return 0;         }
885         n++;
886       }
887       if (wild[n] == '\0')
888         return 0;     } else if (wild[n] == '\\') {
889       n++;
890       if (wild[n] == '\0')
891         return 0;     } else if (wild[n] == '*')
892       nstars++;
893   }
894   if (nstars == 0)
895     return (is_feral_nabbrev(wild, n, tame) == (int)strlen(tame));
896   else {
897     std::vector&lt;int&gt; staridx;
898     staridx.resize(nstars);
899     std::vector&lt;int&gt; idxA;
900     idxA.resize(nstars + 1);
901     std::vector&lt;int&gt; idxB;
902     idxB.resize(nstars + 1);
903     char *m;
904     int nidx;
905     int i, j;
906     int tail_len;
907     int old_length;
908     for (i = n = 0; wild[n] != '\0'; n++) {
909       if (wild[n] == '[') {
910         do {
911           n++;
912           if (wild[n] == '\\')
913             n++;
914         } while (wild[n] != ']');
915       } else if (wild[n] == '\\')
916         n++;
917       else if (wild[n] == '*')
918         staridx[i++] = n;
919     }
920     for (i = 0; i &lt; nstars &amp;&amp; staridx[i] == i; i++) {
921     } 
922     if (i &gt;= nstars)
923       return 1; 
924     if (i == 0)     {
925       j = is_feral_nabbrev(wild, staridx[0], tame);
926       if (j == 0)
927         return 0; 
928       tame += j; 
929       wild += staridx[0];       n -= staridx[0];
930       for (i = nstars - 1; i &gt;= 0; i--)
931         staridx[i] -= staridx[0];
932     }
933     if (staridx[nstars - 1] &lt; n - 1)     {
934       j = staridx[nstars - 1] + 1;
935       tail_len = feral_strlenn(wild + j, n - j);
936       j = is_feral_nabbrev(wild + j, n - j, tame + (strlen(tame) - tail_len));
937       if (j == 0)
938         return 0;     } else
939       tail_len = 0;
940     nidx = 0;
941     for (i = 1; i &lt; nstars; i++) {
942       idxA[nidx] = staridx[i - 1] + 1;
943       idxB[nidx] = staridx[i];
944       nidx++;
945     }
946     old_length = 0;
947     m = tame;
948     for (i = 0; i &lt; nidx; i++) {
949       idxB[i] -= idxA[i]; 
950       if (idxB[i] == 0)
951         continue; 
952       m = m + old_length;
953       m = feral_strstrn(m, wild + idxA[i], idxB[i]);
954       if (m == NULL)
955         return 0;       old_length = feral_strlenn(wild + idxA[i], idxB[i]);
956     }
957     m = m + old_length;
958     if (strlen(m) &lt; (size_t)tail_len)
959       return 0; 
960     return 1;
961   }
962 }
963 int initialize_string_buffer(struct string_buffer *sb, int maxstr) {
964   if (maxstr &gt; 0) {
965     if ((sb-&gt;strings = (char **)allocate_ptr_array(maxstr)) == NULL)
966       mcell_allocfailed("Failed to allocate buffer of %d strings.", maxstr);
967   }
968   sb-&gt;max_strings = maxstr;
969   sb-&gt;n_strings = 0;
970   return 0;
971 }
972 int destroy_string_buffer(struct string_buffer *sb) {
973   if (sb-&gt;strings) {
974     free_ptr_array((void **)sb-&gt;strings, sb-&gt;max_strings);
975   }
976   sb-&gt;strings = NULL;
977   sb-&gt;max_strings = 0;
978   sb-&gt;n_strings = 0;
979   return 0;
980 }
981 int add_string_to_buffer(struct string_buffer *sb, char *str) {
982   if (sb-&gt;n_strings &gt;= sb-&gt;max_strings) {
983     mcell_internal_error("Attempt to overrun string buffer (max fill is %d).",
984                          sb-&gt;max_strings);
985   }
986   sb-&gt;strings[sb-&gt;n_strings++] = str;
987   return 0;
988 }
989 int pointer_hash_init(struct pointer_hash *ht, int size) {
990   assert(size &gt;= 0);
991   memset(ht, 0, sizeof(struct pointer_hash));
992   if (size == 0) {
993     ++size;
994   }
995   if ((size) &amp; (size - 1)) {
996     size |= (size &gt;&gt; 1);
997     size |= (size &gt;&gt; 2);
998     size |= (size &gt;&gt; 4);
999     size |= (size &gt;&gt; 8);
1000     size |= (size &gt;&gt; 16);
1001     ++size;
1002   }
1003   ht-&gt;num_items = 0;
1004   ht-&gt;table_size = size;
1005   if ((ht-&gt;hashes = (unsigned int *)malloc(sizeof(unsigned int) *size)) ==
1006           NULL ||
1007       (ht-&gt;keys = (void const **)malloc(sizeof(void const *) *size)) == NULL ||
1008       (ht-&gt;values = (void **)malloc(sizeof(void *) * size)) == NULL)
1009     goto failure;
1010   memset(ht-&gt;hashes, 0, sizeof(unsigned int) * size);
1011   memset(ht-&gt;keys, 0, sizeof(void *) * size);
1012   memset(ht-&gt;values, 0, sizeof(void *) * size);
1013   return 0;
1014 failure:
1015   pointer_hash_destroy(ht);
1016   return 1;
1017 }
1018 void pointer_hash_destroy(struct pointer_hash *ht) {
1019   if (ht-&gt;hashes)
1020     free(ht-&gt;hashes);
1021   if (ht-&gt;keys)
1022     free(ht-&gt;keys);
1023   if (ht-&gt;values)
1024     free(ht-&gt;values);
1025   ht-&gt;num_items = 0;
1026   ht-&gt;table_size = 0;
1027   ht-&gt;hashes = NULL;
1028   ht-&gt;keys = NULL;
1029   ht-&gt;values = NULL;
1030 }
1031 int pointer_hash_resize(struct pointer_hash *ht, int new_size) {
1032   if (new_size == ht-&gt;table_size)
1033     return 0;
1034   if (new_size &lt; ht-&gt;num_items)
1035     return 1;
1036   struct pointer_hash old = *ht;
1037   if (pointer_hash_init(ht, new_size)) {
1038     *ht = old;
1039     return 1;
1040   }
1041   for (int old_item_idx = 0; old_item_idx &lt; old.table_size; ++old_item_idx) {
1042     if (old.keys[old_item_idx] == NULL)
1043       continue;
1044     if (pointer_hash_add(ht, old.keys[old_item_idx], old.hashes[old_item_idx],
1045                          old.values[old_item_idx]))
1046       goto failure;
1047   }
1048   pointer_hash_destroy(&amp;old);
1049   return 0;
1050 failure:
1051   pointer_hash_destroy(ht);
1052   *ht = old;
1053   return 1;
1054 }
1055 int pointer_hash_add(struct pointer_hash *ht, void const *key,
1056                      unsigned int keyhash, void *value) {
1057   if (ht-&gt;table_size == 0) {
1058     if (pointer_hash_resize(ht, 2))
1059       return 1;
1060   }
1061   if (ht-&gt;num_items &gt;= (ht-&gt;table_size &gt;&gt; 1)) {
1062     if (pointer_hash_resize(ht, ht-&gt;table_size &lt;&lt; 1))
1063       return 1;
1064   }
1065   unsigned int start_index = keyhash &amp; (ht-&gt;table_size - 1);
1066   for (unsigned int i = 0; i &lt; (unsigned int)ht-&gt;table_size; i++) {
1067     unsigned int cur_index = (start_index + i) &amp; (ht-&gt;table_size - 1);
1068     if (ht-&gt;keys[cur_index] == key) {
1069       ht-&gt;values[cur_index] = value;
1070       return 0;
1071     }
1072     if (ht-&gt;keys[cur_index] == NULL) {
1073       ht-&gt;hashes[cur_index] = keyhash;
1074       ht-&gt;keys[cur_index] = key;
1075       ht-&gt;values[cur_index] = value;
1076       goto done;
1077     }
1078   }
1079   return 1;
1080 done:
1081   ++ht-&gt;num_items;
1082   return 0;
1083 }
1084 void *pointer_hash_lookup_ext(struct pointer_hash const *ht, void const *key,
1085                               unsigned int keyhash, void *default_value) {
1086   if (ht-&gt;table_size == 0)
1087     return default_value;
1088   unsigned int start_index = keyhash &amp; (ht-&gt;table_size - 1);
1089   for (unsigned int i = 0; i &lt; (unsigned int)ht-&gt;table_size; i++) {
1090     unsigned int cur_index = (start_index + i) &amp; (ht-&gt;table_size - 1);
1091     if (ht-&gt;keys[cur_index] == NULL)
1092       return default_value;
1093     if (ht-&gt;keys[cur_index] == key)
1094       return ht-&gt;values[cur_index];
1095   }
1096   return default_value;
1097 }
1098 int pointer_hash_remove(struct pointer_hash *ht, void const *key,
1099                         unsigned int keyhash) {
1100   if (key == NULL)
1101     return 1;
1102   if (ht-&gt;table_size == 0)
1103     return 1;
1104   int start = keyhash &amp; (ht-&gt;table_size - 1);   int next_slot = -1;                         
1105   int cur = start;
1106   do {
1107     if (key != NULL &amp;&amp; ht-&gt;keys[cur] == key) {
1108       ht-&gt;keys[cur] = NULL;
1109       ht-&gt;values[cur] = NULL;
1110       ht-&gt;hashes[cur] = 0;
1111       --ht-&gt;num_items;
1112       if (ht-&gt;table_size &gt; (ht-&gt;num_items &lt;&lt; 2)) {
1113         if (!pointer_hash_resize(ht, ht-&gt;num_items &lt;&lt; 1))
1114           return 0;
1115       }
1116       next_slot = cur;
1117       key = NULL;
1118     }
1119     else if (ht-&gt;keys[cur] == NULL) {
1120       if (key == NULL)
1121         return 0;
1122       else
1123         return 1;
1124     }
1125     else if (next_slot != -1) {
1126       int desiredSlot = ht-&gt;hashes[cur] &amp; (ht-&gt;table_size - 1);
1127       if ((next_slot &lt; cur &amp;&amp;
1128            (desiredSlot &lt;= next_slot || desiredSlot &gt; cur)) ||
1129           (next_slot &gt; cur &amp;&amp;
1130            (desiredSlot &lt;= next_slot &amp;&amp; desiredSlot &gt; cur))) {
1131         ht-&gt;hashes[next_slot] = ht-&gt;hashes[cur];
1132         ht-&gt;keys[next_slot] = ht-&gt;keys[cur];
1133         ht-&gt;values[next_slot] = ht-&gt;values[cur];
1134         ht-&gt;hashes[cur] = 0;
1135         ht-&gt;keys[cur] = NULL;
1136         ht-&gt;values[cur] = NULL;
1137         next_slot = cur;
1138       }
1139     }
1140     if (++cur == ht-&gt;table_size)
1141       cur = 0;
1142   } while (cur != start);
1143   if (key == NULL)
1144     return 0;
1145   else
1146     return 1;
1147 }
1148 int remove_both_duplicates(struct void_list **head) {
1149   struct void_list *curr = *head, *tmp, *prev, *next_Next;
1150   int count = 0;
1151   tmp = curr;
1152   prev = NULL;
1153   while ((tmp != NULL) &amp;&amp; (tmp-&gt;next != NULL)) {
1154     if (tmp-&gt;data == tmp-&gt;next-&gt;data) {
1155       next_Next = tmp-&gt;next-&gt;next;
1156       free(tmp-&gt;next);
1157       free(tmp);
1158       tmp = next_Next;
1159       if (prev != NULL) {
1160         prev-&gt;next = tmp;
1161       } else {
1162         curr = tmp;
1163       }
1164     } else {
1165       prev = tmp;
1166       tmp = tmp-&gt;next;     }
1167   }
1168   *head = curr;
1169   for (tmp = *head; tmp != NULL; tmp = tmp-&gt;next) {
1170     count++;
1171   }
1172   return count;
1173 }
1174 void delete_void_list(struct void_list *head) {
1175   struct void_list *nnext;
1176   while (head != NULL) {
1177     nnext = head-&gt;next;
1178     free(head);
1179     head = nnext;
1180   }
1181 }
1182 int double_cmp(void const *i1, void const *i2) {
1183   double const *d1 = (double const *)i1;
1184   double const *d2 = (double const *)i2;
1185   if (*d1 &lt; *d2)
1186     return -1;
1187   else if (*d1 &gt; *d2)
1188     return 1;
1189   else
1190     return 0;
1191 }
1192 int is_string_present_in_string_array(const char * str, char ** strings, int length)
1193 {
1194   int found = 0, i;
1195   for (i = 0; i &lt; length; i++) {
1196     if (strcmp(str, strings[i]) == 0) {
1197       found = 1;
1198       break;
1199     }
1200   }
1201   return found;
1202 }
1203 double convert_seconds_to_iterations(
1204     long long start_iterations,
1205     double time_step_seconds,
1206     double simulation_start_seconds,
1207     double seconds) {
1208   double delta_iterations =
1209     (seconds - simulation_start_seconds) / time_step_seconds;
1210   return (start_iterations + delta_iterations);
1211 }
1212 double convert_iterations_to_seconds(
1213     long long start_iterations,
1214     double time_step_seconds,
1215     double simulation_start_seconds,
1216     double iterations) {
1217   double delta_time = (iterations - start_iterations) * time_step_seconds;
1218   return (simulation_start_seconds + delta_time);
1219 }
1220 int generate_range(struct num_expr_list_head *list, double start, double end,
1221                    double step) {
1222   list-&gt;value_head = NULL;
1223   list-&gt;value_tail = NULL;
1224   list-&gt;value_count = 0;
1225   list-&gt;shared = 0;
1226   if (step &gt; 0) {
1227     for (double tmp_dbl = start;
1228          tmp_dbl &lt; end || !distinguishable(tmp_dbl, end, EPS_C) ||
1229              fabs(end - tmp_dbl) &lt;= EPS_C;
1230          tmp_dbl += step) {
1231       if (advance_range(list, tmp_dbl))
1232         return 1;
1233     }
1234   } else   {
1235     for (double tmp_dbl = start;
1236          tmp_dbl &gt; end || !distinguishable(tmp_dbl, end, EPS_C) ||
1237              fabs(end - tmp_dbl) &lt;= EPS_C;
1238          tmp_dbl += step) {
1239       if (advance_range(list, tmp_dbl))
1240         return 1;
1241     }
1242   }
1243   list-&gt;start_end_step_set = true;
1244   list-&gt;start = start;
1245   list-&gt;end = end;
1246   list-&gt;step = step;
1247   return 0;
1248 }
1249 int advance_range(struct num_expr_list_head *list, double tmp_dbl) {
1250   struct num_expr_list *nel;
1251   nel = CHECKED_MALLOC_STRUCT(struct num_expr_list, "numeric list");
1252   if (nel == NULL) {
1253     free_numeric_list(list-&gt;value_head);
1254     list-&gt;value_head = list-&gt;value_tail = NULL;
1255     return 1;
1256   }
1257   nel-&gt;value = tmp_dbl;
1258   nel-&gt;next = NULL;
1259   ++list-&gt;value_count;
1260   if (list-&gt;value_tail != NULL)
1261     list-&gt;value_tail-&gt;next = nel;
1262   else
1263     list-&gt;value_head = nel;
1264   list-&gt;value_tail = nel;
1265   return 0;
1266 }
1267 void free_numeric_list(struct num_expr_list *nel) {
1268   while (nel != NULL) {
1269     struct num_expr_list *n = nel;
1270     nel = nel-&gt;next;
1271     free(n);
1272   }
1273 }
1274 #define hashsize(n) ((ub4)1 &lt;&lt; (n))
1275 #define mix(a, b, c)                                                           \
1276   {                                                                            \
1277     a -= b;                                                                    \
1278     a -= c;                                                                    \
1279     a ^= (c &gt;&gt; 13);                                                            \
1280     b -= c;                                                                    \
1281     b -= a;                                                                    \
1282     b ^= (a &lt;&lt; 8);                                                             \
1283     c -= a;                                                                    \
1284     c -= b;                                                                    \
1285     c ^= (b &gt;&gt; 13);                                                            \
1286     a -= b;                                                                    \
1287     a -= c;                                                                    \
1288     a ^= (c &gt;&gt; 12);                                                            \
1289     b -= c;                                                                    \
1290     b -= a;                                                                    \
1291     b ^= (a &lt;&lt; 16);                                                            \
1292     c -= a;                                                                    \
1293     c -= b;                                                                    \
1294     c ^= (b &gt;&gt; 5);                                                             \
1295     a -= b;                                                                    \
1296     a -= c;                                                                    \
1297     a ^= (c &gt;&gt; 3);                                                             \
1298     b -= c;                                                                    \
1299     b -= a;                                                                    \
1300     b ^= (a &lt;&lt; 10);                                                            \
1301     c -= a;                                                                    \
1302     c -= b;                                                                    \
1303     c ^= (b &gt;&gt; 15);                                                            \
1304   }
1305 ub4 jenkins_hash(ub1 *k, ub4 length) {
1306   ub4 a, b, c, len, initval;
1307   initval = 0;
1308   len = length;
1309   a = b = 0x9e3779b9;   c = initval;          length++;
1310   while (len &gt;= 12) {
1311     a += (k[0] + ((ub4)k[1] &lt;&lt; 8) + ((ub4)k[2] &lt;&lt; 16) + ((ub4)k[3] &lt;&lt; 24));
1312     b += (k[4] + ((ub4)k[5] &lt;&lt; 8) + ((ub4)k[6] &lt;&lt; 16) + ((ub4)k[7] &lt;&lt; 24));
1313     c += (k[8] + ((ub4)k[9] &lt;&lt; 8) + ((ub4)k[10] &lt;&lt; 16) + ((ub4)k[11] &lt;&lt; 24));
1314     mix(a, b, c);
1315     k += 12;
1316     len -= 12;
1317   }
1318   c += length;
1319   switch (len)   {
1320   case 11:
1321     c += ((ub4)k[10] &lt;&lt; 24);   case 10:
1322     c += ((ub4)k[9] &lt;&lt; 16);   case 9:
1323     c += ((ub4)k[8] &lt;&lt; 8);   case 8:
1324     b += ((ub4)k[7] &lt;&lt; 24);   case 7:
1325     b += ((ub4)k[6] &lt;&lt; 16);   case 6:
1326     b += ((ub4)k[5] &lt;&lt; 8);   case 5:
1327     b += k[4];   case 4:
1328     a += ((ub4)k[3] &lt;&lt; 24);   case 3:
1329     a += ((ub4)k[2] &lt;&lt; 16);   case 2:
1330     a += ((ub4)k[1] &lt;&lt; 8);   case 1:
1331     a += k[0];   }
1332   mix(a, b, c);
1333   return (c);
1334 }
1335 void reset_rusage(rusage* r) {
1336   r-&gt;ru_utime.tv_sec = 0;
1337   r-&gt;ru_utime.tv_usec = 0;
1338   r-&gt;ru_stime.tv_sec = 0;
1339   r-&gt;ru_stime.tv_usec = 0;
1340 }
1341 #ifdef _MSC_VER
1342 int _win_rename(const char *old, const char *new_name) {
1343   DWORD dwAttrib = GetFileAttributes(new_name);
1344   if (dwAttrib != INVALID_FILE_ATTRIBUTES &amp;&amp;
1345       !(dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY)) {
1346     if (ReplaceFile(new_name, old, NULL, REPLACEFILE_WRITE_THROUGH, NULL, NULL)) {
1347       return 0;
1348     }
1349     errno = EACCES;
1350     return -1;
1351   } else {
1352     return rename(old, new_name);
1353   }
1354 }
1355 #endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
