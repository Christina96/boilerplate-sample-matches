
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-xml.c</h3>
            <pre><code>1  #include &quot;private/autogen/config.h&quot;
2  #include &quot;hwloc.h&quot;
3  #include &quot;private/xml.h&quot;
4  #include &quot;private/private.h&quot;
5  #include &quot;private/misc.h&quot;
6  #include &quot;private/debug.h&quot;
7  #include &lt;math.h&gt;
8  int
9  hwloc__xml_verbose(void)
10  {
11    static int checked = 0;
12    static int verbose = 0;
13    if (!checked) {
14      const char *env = getenv(&quot;HWLOC_XML_VERBOSE&quot;);
15      if (env)
16        verbose = atoi(env);
17      checked = 1;
18    }
19    return verbose;
20  }
21  static int
22  hwloc_nolibxml_import(void)
23  {
24    static int checked = 0;
25    static int nolibxml = 0;
26    if (!checked) {
27      const char *env = getenv(&quot;HWLOC_LIBXML&quot;);
28      if (env) {
29        nolibxml = !atoi(env);
30      } else {
31        env = getenv(&quot;HWLOC_LIBXML_IMPORT&quot;);
32        if (env)
33  	nolibxml = !atoi(env);
34      }
35      checked = 1;
36    }
37    return nolibxml;
38  }
39  static int
40  hwloc_nolibxml_export(void)
41  {
42    static int checked = 0;
43    static int nolibxml = 0;
44    if (!checked) {
45      const char *env = getenv(&quot;HWLOC_LIBXML&quot;);
46      if (env) {
47        nolibxml = !atoi(env);
48      } else {
49        env = getenv(&quot;HWLOC_LIBXML_EXPORT&quot;);
50        if (env)
51  	nolibxml = !atoi(env);
52      }
53      checked = 1;
54    }
55    return nolibxml;
56  }
57  #define BASE64_ENCODED_LENGTH(length) (4*(((length)+2)/3))
58  static struct hwloc_xml_callbacks *hwloc_nolibxml_callbacks = NULL, *hwloc_libxml_callbacks = NULL;
59  void
60  hwloc_xml_callbacks_register(struct hwloc_xml_component *comp)
61  {
62    if (!hwloc_nolibxml_callbacks)
63      hwloc_nolibxml_callbacks = comp-&gt;nolibxml_callbacks;
64    if (!hwloc_libxml_callbacks)
65      hwloc_libxml_callbacks = comp-&gt;libxml_callbacks;
66  }
67  void
68  hwloc_xml_callbacks_reset(void)
69  {
70    hwloc_nolibxml_callbacks = NULL;
71    hwloc_libxml_callbacks = NULL;
72  }
73  #define _HWLOC_OBJ_CACHE_OLD (HWLOC_OBJ_TYPE_MAX+1) &amp;bsol;* temporarily used when importing pre-v2.0 attribute-less cache types */
74  #define _HWLOC_OBJ_FUTURE    (HWLOC_OBJ_TYPE_MAX+2) &amp;bsol;* temporarily used when ignoring future types */
75  static void
76  hwloc__xml_import_object_attr(struct hwloc_topology *topology,
77  			      struct hwloc_xml_backend_data_s *data,
78  			      struct hwloc_obj *obj,
79  			      const char *name, const char *value,
80  			      hwloc__xml_import_state_t state,
81  			      int *ignore)
82  {
83    if (!strcmp(name, &quot;type&quot;)) {
84      return;
85    }
86    else if (!strcmp(name, &quot;os_index&quot;))
87      obj-&gt;os_index = strtoul(value, NULL, 10);
88    else if (!strcmp(name, &quot;gp_index&quot;)) {
89      obj-&gt;gp_index = strtoull(value, NULL, 10);
90      if (!obj-&gt;gp_index &amp;&amp; hwloc__xml_verbose())
91        fprintf(stderr, &quot;%s: unexpected zero gp_index, topology may be invalid\n&quot;, state-&gt;global-&gt;msgprefix);
92      if (obj-&gt;gp_index &gt;= topology-&gt;next_gp_index)
93        topology-&gt;next_gp_index = obj-&gt;gp_index + 1;
94    } else if (!strcmp(name, &quot;id&quot;)) { &amp;bsol;* forward compat */
95      if (!strncmp(value, &quot;obj&quot;, 3)) {
96        obj-&gt;gp_index = strtoull(value+3, NULL, 10);
97        if (!obj-&gt;gp_index &amp;&amp; hwloc__xml_verbose())
98          fprintf(stderr, &quot;%s: unexpected zero id, topology may be invalid\n&quot;, state-&gt;global-&gt;msgprefix);
99        if (obj-&gt;gp_index &gt;= topology-&gt;next_gp_index)
100          topology-&gt;next_gp_index = obj-&gt;gp_index + 1;
101      } else {
102        if (hwloc__xml_verbose())
103          fprintf(stderr, &quot;%s: unexpected id `%s&#x27; not-starting with `obj&#x27;, ignoring\n&quot;, state-&gt;global-&gt;msgprefix, value);
104      }
105    } else if (!strcmp(name, &quot;cpuset&quot;)) {
106      if (!obj-&gt;cpuset)
107        obj-&gt;cpuset = hwloc_bitmap_alloc();
108      hwloc_bitmap_sscanf(obj-&gt;cpuset, value);
109    } else if (!strcmp(name, &quot;complete_cpuset&quot;)) {
110      if (!obj-&gt;complete_cpuset)
111        obj-&gt;complete_cpuset = hwloc_bitmap_alloc();
112      hwloc_bitmap_sscanf(obj-&gt;complete_cpuset, value);
113    } else if (!strcmp(name, &quot;allowed_cpuset&quot;)) {
114      if (!obj-&gt;parent)
115        hwloc_bitmap_sscanf(topology-&gt;allowed_cpuset, value);
116    } else if (!strcmp(name, &quot;nodeset&quot;)) {
117      if (!obj-&gt;nodeset)
118        obj-&gt;nodeset = hwloc_bitmap_alloc();
119      hwloc_bitmap_sscanf(obj-&gt;nodeset, value);
120    } else if (!strcmp(name, &quot;complete_nodeset&quot;)) {
121      if (!obj-&gt;complete_nodeset)
122        obj-&gt;complete_nodeset = hwloc_bitmap_alloc();
123      hwloc_bitmap_sscanf(obj-&gt;complete_nodeset, value);
124    } else if (!strcmp(name, &quot;allowed_nodeset&quot;)) {
125      if (!obj-&gt;parent)
126        hwloc_bitmap_sscanf(topology-&gt;allowed_nodeset, value);
127    } else if (!strcmp(name, &quot;name&quot;)) {
128      if (obj-&gt;name)
129        free(obj-&gt;name);
130      obj-&gt;name = strdup(value);
131    } else if (!strcmp(name, &quot;subtype&quot;)) {
132      if (obj-&gt;subtype)
133        free(obj-&gt;subtype);
134      obj-&gt;subtype = strdup(value);
135    }
136    else if (!strcmp(name, &quot;cache_size&quot;)) {
137      unsigned long long lvalue = strtoull(value, NULL, 10);
138      if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE)
139        obj-&gt;attr-&gt;cache.size = lvalue;
140      else if (hwloc__xml_verbose())
141        fprintf(stderr, &quot;%s: ignoring cache_size attribute for non-cache object type\n&quot;,
142  	      state-&gt;global-&gt;msgprefix);
143    }
144    else if (!strcmp(name, &quot;cache_linesize&quot;)) {
145      unsigned long lvalue = strtoul(value, NULL, 10);
146      if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE)
147        obj-&gt;attr-&gt;cache.linesize = lvalue;
148      else if (hwloc__xml_verbose())
149        fprintf(stderr, &quot;%s: ignoring cache_linesize attribute for non-cache object type\n&quot;,
150  	      state-&gt;global-&gt;msgprefix);
151    }
152    else if (!strcmp(name, &quot;cache_associativity&quot;)) {
153      int lvalue = atoi(value);
154      if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE)
155        obj-&gt;attr-&gt;cache.associativity = lvalue;
156      else if (hwloc__xml_verbose())
157        fprintf(stderr, &quot;%s: ignoring cache_associativity attribute for non-cache object type\n&quot;,
158  	      state-&gt;global-&gt;msgprefix);
159    }
160    else if (!strcmp(name, &quot;cache_type&quot;)) {
161      unsigned long lvalue = strtoul(value, NULL, 10);
162      if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE) {
163        if (lvalue == HWLOC_OBJ_CACHE_UNIFIED
164  	  || lvalue == HWLOC_OBJ_CACHE_DATA
165  	  || lvalue == HWLOC_OBJ_CACHE_INSTRUCTION)
166  	obj-&gt;attr-&gt;cache.type = (hwloc_obj_cache_type_t) lvalue;
167        else
168          if (hwloc__xml_verbose())
169            fprintf(stderr, &quot;%s: ignoring invalid cache_type attribute %lu\n&quot;,
170                    state-&gt;global-&gt;msgprefix, lvalue);
171      } else if (hwloc__xml_verbose())
172        fprintf(stderr, &quot;%s: ignoring cache_type attribute for non-cache object type\n&quot;,
173  	      state-&gt;global-&gt;msgprefix);
174    }
175    else if (!strcmp(name, &quot;local_memory&quot;)) {
176      unsigned long long lvalue = strtoull(value, NULL, 10);
177      if (obj-&gt;type == HWLOC_OBJ_NUMANODE)
178        obj-&gt;attr-&gt;numanode.local_memory = lvalue;
179      else if (!obj-&gt;parent)
180        topology-&gt;machine_memory.local_memory = lvalue;
181      else if (hwloc__xml_verbose())
182        fprintf(stderr, &quot;%s: ignoring local_memory attribute for non-NUMAnode non-root object\n&quot;,
183  	      state-&gt;global-&gt;msgprefix);
184    }
185    else if (!strcmp(name, &quot;depth&quot;)) {
186      unsigned long lvalue = strtoul(value, NULL, 10);
187       if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE) {
188  	obj-&gt;attr-&gt;cache.depth = lvalue;
189       } else if (obj-&gt;type == HWLOC_OBJ_GROUP || obj-&gt;type == HWLOC_OBJ_BRIDGE) {
190       } else if (hwloc__xml_verbose())
191         fprintf(stderr, &quot;%s: ignoring depth attribute for object type without depth\n&quot;,
192  	       state-&gt;global-&gt;msgprefix);
193    }
194    else if (!strcmp(name, &quot;kind&quot;)) {
195      unsigned long lvalue = strtoul(value, NULL, 10);
196      if (obj-&gt;type == HWLOC_OBJ_GROUP)
197        obj-&gt;attr-&gt;group.kind = lvalue;
198      else if (hwloc__xml_verbose())
199        fprintf(stderr, &quot;%s: ignoring kind attribute for non-group object type\n&quot;,
200  	      state-&gt;global-&gt;msgprefix);
201    }
202    else if (!strcmp(name, &quot;subkind&quot;)) {
203      unsigned long lvalue = strtoul(value, NULL, 10);
204      if (obj-&gt;type == HWLOC_OBJ_GROUP)
205        obj-&gt;attr-&gt;group.subkind = lvalue;
206      else if (hwloc__xml_verbose())
207        fprintf(stderr, &quot;%s: ignoring subkind attribute for non-group object type\n&quot;,
208  	      state-&gt;global-&gt;msgprefix);
209    }
210    else if (!strcmp(name, &quot;dont_merge&quot;)) {
211      unsigned long lvalue = strtoul(value, NULL, 10);
212      if (obj-&gt;type == HWLOC_OBJ_GROUP)
213        obj-&gt;attr-&gt;group.dont_merge = (unsigned char) lvalue;
214      else if (hwloc__xml_verbose())
215        fprintf(stderr, &quot;%s: ignoring dont_merge attribute for non-group object type\n&quot;,
216  	      state-&gt;global-&gt;msgprefix);
217    }
218    else if (!strcmp(name, &quot;pci_busid&quot;)) {
219      switch (obj-&gt;type) {
220      case HWLOC_OBJ_PCI_DEVICE:
221      case HWLOC_OBJ_BRIDGE: {
222        unsigned domain, bus, dev, func;
223        if (sscanf(value, &quot;%x:%02x:%02x.%01x&quot;,
224  		 &amp;domain, &amp;bus, &amp;dev, &amp;func) != 4) {
225  	if (hwloc__xml_verbose())
226  	  fprintf(stderr, &quot;%s: ignoring invalid pci_busid format string %s\n&quot;,
227  		  state-&gt;global-&gt;msgprefix, value);
228  	*ignore = 1;
229  #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
230        } else if (domain &gt; 0xffff) {
231  	static int warned = 0;
232  	if (!warned &amp;&amp; HWLOC_SHOW_ALL_ERRORS())
233  	  fprintf(stderr, &quot;hwloc/xml: Ignoring PCI device with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don&#x27;t enable unless really needed).\n&quot;);
234  	warned = 1;
235  	*ignore = 1;
236  #endif
237        } else {
238  	obj-&gt;attr-&gt;pcidev.domain = domain;
239  	obj-&gt;attr-&gt;pcidev.bus = bus;
240  	obj-&gt;attr-&gt;pcidev.dev = dev;
241  	obj-&gt;attr-&gt;pcidev.func = func;
242        }
243        break;
244      }
245      default:
246        if (hwloc__xml_verbose())
247  	fprintf(stderr, &quot;%s: ignoring pci_busid attribute for non-PCI object\n&quot;,
248  		state-&gt;global-&gt;msgprefix);
249        break;
250      }
251    }
252    else if (!strcmp(name, &quot;pci_type&quot;)) {
253      switch (obj-&gt;type) {
254      case HWLOC_OBJ_PCI_DEVICE:
255      case HWLOC_OBJ_BRIDGE: {
256        unsigned classid, vendor, device, subvendor, subdevice, revision;
257        if (sscanf(value, &quot;%x [%04x:%04x] [%04x:%04x] %02x&quot;,
258  		 &amp;classid, &amp;vendor, &amp;device, &amp;subvendor, &amp;subdevice, &amp;revision) != 6) {
259  	if (hwloc__xml_verbose())
260  	  fprintf(stderr, &quot;%s: ignoring invalid pci_type format string %s\n&quot;,
261  		  state-&gt;global-&gt;msgprefix, value);
262        } else {
263  	obj-&gt;attr-&gt;pcidev.class_id = classid;
264  	obj-&gt;attr-&gt;pcidev.vendor_id = vendor;
265  	obj-&gt;attr-&gt;pcidev.device_id = device;
266  	obj-&gt;attr-&gt;pcidev.subvendor_id = subvendor;
267  	obj-&gt;attr-&gt;pcidev.subdevice_id = subdevice;
268  	obj-&gt;attr-&gt;pcidev.revision = revision;
269        }
270        break;
271      }
272      default:
273        if (hwloc__xml_verbose())
274  	fprintf(stderr, &quot;%s: ignoring pci_type attribute for non-PCI object\n&quot;,
275  		state-&gt;global-&gt;msgprefix);
276        break;
277      }
278    }
279    else if (!strcmp(name, &quot;pci_link_speed&quot;)) {
280      switch (obj-&gt;type) {
281      case HWLOC_OBJ_PCI_DEVICE:
282      case HWLOC_OBJ_BRIDGE: {
283        obj-&gt;attr-&gt;pcidev.linkspeed = (float) atof(value);
284        break;
285      }
286      default:
287        if (hwloc__xml_verbose())
288  	fprintf(stderr, &quot;%s: ignoring pci_link_speed attribute for non-PCI object\n&quot;,
289  		state-&gt;global-&gt;msgprefix);
290        break;
291      }
292    }
293    else if (!strcmp(name, &quot;bridge_type&quot;)) {
294      switch (obj-&gt;type) {
295      case HWLOC_OBJ_BRIDGE: {
296        unsigned upstream_type, downstream_type;
297        if (sscanf(value, &quot;%u-%u&quot;, &amp;upstream_type, &amp;downstream_type) != 2) {
298  	if (hwloc__xml_verbose())
299  	  fprintf(stderr, &quot;%s: ignoring invalid bridge_type format string %s\n&quot;,
300  		  state-&gt;global-&gt;msgprefix, value);
301        } else {
302  	obj-&gt;attr-&gt;bridge.upstream_type = (hwloc_obj_bridge_type_t) upstream_type;
303  	obj-&gt;attr-&gt;bridge.downstream_type = (hwloc_obj_bridge_type_t) downstream_type;
304        };
305        break;
306      }
307      default:
308        if (hwloc__xml_verbose())
309  	fprintf(stderr, &quot;%s: ignoring bridge_type attribute for non-bridge object\n&quot;,
310  		state-&gt;global-&gt;msgprefix);
311        break;
312      }
313    }
314    else if (!strcmp(name, &quot;bridge_pci&quot;)) {
315      switch (obj-&gt;type) {
316      case HWLOC_OBJ_BRIDGE: {
317        unsigned domain, secbus, subbus;
318        if (sscanf(value, &quot;%x:[%02x-%02x]&quot;,
319  		 &amp;domain, &amp;secbus, &amp;subbus) != 3) {
320  	if (hwloc__xml_verbose())
321  	  fprintf(stderr, &quot;%s: ignoring invalid bridge_pci format string %s\n&quot;,
322  		  state-&gt;global-&gt;msgprefix, value);
323  	*ignore = 1;
324  #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
325        } else if (domain &gt; 0xffff) {
326  	static int warned = 0;
327  	if (!warned &amp;&amp; HWLOC_SHOW_ALL_ERRORS())
328  	  fprintf(stderr, &quot;hwloc/xml: Ignoring bridge to PCI with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don&#x27;t enable unless really needed).\n&quot;);
329  	warned = 1;
330  	*ignore = 1;
331  #endif
332        } else {
333  	obj-&gt;attr-&gt;bridge.downstream.pci.domain = domain;
334  	obj-&gt;attr-&gt;bridge.downstream.pci.secondary_bus = secbus;
335  	obj-&gt;attr-&gt;bridge.downstream.pci.subordinate_bus = subbus;
336        }
337        break;
338      }
339      default:
340        if (hwloc__xml_verbose())
341  	fprintf(stderr, &quot;%s: ignoring bridge_pci attribute for non-bridge object\n&quot;,
342  		state-&gt;global-&gt;msgprefix);
343        break;
344      }
345    }
346    else if (!strcmp(name, &quot;osdev_type&quot;)) {
347      switch (obj-&gt;type) {
348      case HWLOC_OBJ_OS_DEVICE: {
349        unsigned osdev_type;
350        if (sscanf(value, &quot;%u&quot;, &amp;osdev_type) != 1) {
351  	if (hwloc__xml_verbose())
352  	  fprintf(stderr, &quot;%s: ignoring invalid osdev_type format string %s\n&quot;,
353  		  state-&gt;global-&gt;msgprefix, value);
354        } else
355  	obj-&gt;attr-&gt;osdev.type = (hwloc_obj_osdev_type_t) osdev_type;
356        break;
357      }
358      default:
359        if (hwloc__xml_verbose())
360  	fprintf(stderr, &quot;%s: ignoring osdev_type attribute for non-osdev object\n&quot;,
361  		state-&gt;global-&gt;msgprefix);
362        break;
363      }
364    }
365    else if (data-&gt;version_major &lt; 2) {
366      if (!strcmp(name, &quot;os_level&quot;)
367  	|| !strcmp(name, &quot;online_cpuset&quot;))
368        { &amp;bsol;* ignored */ }
369      else if (!strcmp(name, &quot;dmi_board_vendor&quot;)) {
370        if (value[0])
371  	hwloc_obj_add_info(obj, &quot;DMIBoardVendor&quot;, value);
372      }
373      else if (!strcmp(name, &quot;dmi_board_name&quot;)) {
374        if (value[0])
375  	hwloc_obj_add_info(obj, &quot;DMIBoardName&quot;, value);
376      }
377      else if (data-&gt;version_major &lt; 1) {
378        if (!strcmp(name, &quot;memory_kB&quot;)) {
379  	unsigned long long lvalue = strtoull(value, NULL, 10);
380  	if (obj-&gt;type == _HWLOC_OBJ_CACHE_OLD)
381  	  obj-&gt;attr-&gt;cache.size = lvalue &lt;&lt; 10;
382  	else if (obj-&gt;type == HWLOC_OBJ_NUMANODE)
383  	  obj-&gt;attr-&gt;numanode.local_memory = lvalue &lt;&lt; 10;
384  	else if (!obj-&gt;parent)
385  	  topology-&gt;machine_memory.local_memory = lvalue &lt;&lt; 10;
386  	else if (hwloc__xml_verbose())
387  	  fprintf(stderr, &quot;%s: ignoring memory_kB attribute for non-NUMAnode non-root object\n&quot;,
388  		  state-&gt;global-&gt;msgprefix);
389        }
390        else if (!strcmp(name, &quot;huge_page_size_kB&quot;)) {
391  	unsigned long lvalue = strtoul(value, NULL, 10);
392  	if (obj-&gt;type == HWLOC_OBJ_NUMANODE || !obj-&gt;parent) {
393  	  struct hwloc_numanode_attr_s *memory = obj-&gt;type == HWLOC_OBJ_NUMANODE ? &amp;obj-&gt;attr-&gt;numanode : &amp;topology-&gt;machine_memory;
394  	  if (!memory-&gt;page_types) {
395  	    memory-&gt;page_types = malloc(sizeof(*memory-&gt;page_types));
396  	    memory-&gt;page_types_len = 1;
397  	  }
398  	  assert(memory-&gt;page_types);
399  	  memory-&gt;page_types[0].size = lvalue &lt;&lt; 10;
400  	} else if (hwloc__xml_verbose()) {
401  	  fprintf(stderr, &quot;%s: ignoring huge_page_size_kB attribute for non-NUMAnode non-root object\n&quot;,
402  		  state-&gt;global-&gt;msgprefix);
403  	}
404        }
405        else if (!strcmp(name, &quot;huge_page_free&quot;)) {
406  	unsigned long lvalue = strtoul(value, NULL, 10);
407  	if (obj-&gt;type == HWLOC_OBJ_NUMANODE || !obj-&gt;parent) {
408  	  struct hwloc_numanode_attr_s *memory = obj-&gt;type == HWLOC_OBJ_NUMANODE ? &amp;obj-&gt;attr-&gt;numanode : &amp;topology-&gt;machine_memory;
409  	  if (!memory-&gt;page_types) {
410  	    memory-&gt;page_types = malloc(sizeof(*memory-&gt;page_types));
411  	    memory-&gt;page_types_len = 1;
412  	  }
413  	  assert(memory-&gt;page_types);
414  	  memory-&gt;page_types[0].count = lvalue;
415  	} else if (hwloc__xml_verbose()) {
416  	  fprintf(stderr, &quot;%s: ignoring huge_page_free attribute for non-NUMAnode non-root object\n&quot;,
417  		  state-&gt;global-&gt;msgprefix);
418  	}
419        }
420        else goto unknown;
421      }
422      else goto unknown;
423    }
424    else {
425    unknown:
426      if (hwloc__xml_verbose())
427        fprintf(stderr, &quot;%s: ignoring unknown object attribute %s\n&quot;,
428  	      state-&gt;global-&gt;msgprefix, name);
429    }
430  }
431  static int
432  hwloc___xml_import_info(char **infonamep, char **infovaluep,
433                          hwloc__xml_import_state_t state)
434  {
435    char *infoname = NULL;
436    char *infovalue = NULL;
437    while (1) {
438      char *attrname, *attrvalue;
439      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
440        break;
441      if (!strcmp(attrname, &quot;name&quot;))
442        infoname = attrvalue;
443      else if (!strcmp(attrname, &quot;value&quot;))
444        infovalue = attrvalue;
445      else
446        return -1;
447    }
448    *infonamep = infoname;
449    *infovaluep = infovalue;
450    return state-&gt;global-&gt;close_tag(state);
451  }
452  static int
453  hwloc__xml_import_obj_info(struct hwloc_xml_backend_data_s *data,
454                             hwloc_obj_t obj,
455                             hwloc__xml_import_state_t state)
456  {
457    char *infoname = NULL;
458    char *infovalue = NULL;
459    int err;
460    err = hwloc___xml_import_info(&amp;infoname, &amp;infovalue, state);
461    if (err &lt; 0)
462      return err;
463    if (infoname) {
464      if (data-&gt;version_major &lt; 2 &amp;&amp;
465  	(!strcmp(infoname, &quot;Type&quot;) || !strcmp(infoname, &quot;CoProcType&quot;))) {
466        if (infovalue) {
467  	if (obj-&gt;subtype)
468  	  free(obj-&gt;subtype);
469  	obj-&gt;subtype = strdup(infovalue);
470        }
471      } else {
472        if (infovalue)
473  	hwloc_obj_add_info(obj, infoname, infovalue);
474      }
475    }
476    return err;
477  }
478  static int
479  hwloc__xml_import_pagetype(hwloc_topology_t topology __hwloc_attribute_unused, struct hwloc_numanode_attr_s *memory,
480  			   hwloc__xml_import_state_t state)
481  {
482    uint64_t size = 0, count = 0;
483    while (1) {
484      char *attrname, *attrvalue;
485      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
486        break;
487      if (!strcmp(attrname, &quot;size&quot;))
488        size = strtoull(attrvalue, NULL, 10);
489      else if (!strcmp(attrname, &quot;count&quot;))
490        count = strtoull(attrvalue, NULL, 10);
491      else
492        return -1;
493    }
494    if (size) {
495      unsigned idx = memory-&gt;page_types_len;
496      struct hwloc_memory_page_type_s *tmp;
497      tmp = realloc(memory-&gt;page_types, (idx+1)*sizeof(*memory-&gt;page_types));
498      if (tmp) { &amp;bsol;* if failed to allocate, ignore this page_type entry */
499        memory-&gt;page_types = tmp;
500        memory-&gt;page_types_len = idx+1;
501        memory-&gt;page_types[idx].size = size;
502        memory-&gt;page_types[idx].count = count;
503      }
504    }
505    return state-&gt;global-&gt;close_tag(state);
506  }
507  static int
508  hwloc__xml_v1import_distances(struct hwloc_xml_backend_data_s *data,
509  			      hwloc_obj_t obj,
510  			      hwloc__xml_import_state_t state)
511  {
512    unsigned long reldepth = 0, nbobjs = 0;
513    float latbase = 0;
514    char *tag;
515    int ret;
516    while (1) {
517      char *attrname, *attrvalue;
518      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
519        break;
520      if (!strcmp(attrname, &quot;nbobjs&quot;))
521        nbobjs = strtoul(attrvalue, NULL, 10);
522      else if (!strcmp(attrname, &quot;relative_depth&quot;))
523        reldepth = strtoul(attrvalue, NULL, 10);
524      else if (!strcmp(attrname, &quot;latency_base&quot;))
525        latbase = (float) atof(attrvalue);
526      else
527        return -1;
528    }
529    if (nbobjs &amp;&amp; reldepth &amp;&amp; latbase) {
530      unsigned i;
531      float *matrix;
532      struct hwloc__xml_imported_v1distances_s *v1dist;
533      matrix = malloc(nbobjs*nbobjs*sizeof(float));
534      v1dist = malloc(sizeof(*v1dist));
535      if (!matrix || !v1dist) {
536        if (hwloc__xml_verbose())
537  	fprintf(stderr, &quot;%s: failed to allocate v1distance matrix for %lu objects\n&quot;,
538  		state-&gt;global-&gt;msgprefix, nbobjs);
539        free(v1dist);
540        free(matrix);
541        return -1;
542      }
543      v1dist-&gt;kind = HWLOC_DISTANCES_KIND_FROM_OS|HWLOC_DISTANCES_KIND_MEANS_LATENCY;
544      v1dist-&gt;nbobjs = nbobjs;
545      v1dist-&gt;floats = matrix;
546      for(i=0; i&lt;nbobjs*nbobjs; i++) {
547        struct hwloc__xml_import_state_s childstate;
548        char *attrname, *attrvalue;
549        float val;
550        ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
551        if (ret &lt;= 0 || strcmp(tag, &quot;latency&quot;)) {
552  	free(matrix);
553  	free(v1dist);
554  	return -1;
555        }
556        ret = state-&gt;global-&gt;next_attr(&amp;childstate, &amp;attrname, &amp;attrvalue);
557        if (ret &lt; 0 || strcmp(attrname, &quot;value&quot;)) {
558  	free(matrix);
559  	free(v1dist);
560  	return -1;
561        }
562        val = (float) atof((char *) attrvalue);
563        matrix[i] = val * latbase;
564        ret = state-&gt;global-&gt;close_tag(&amp;childstate);
565        if (ret &lt; 0) {
566  	free(matrix);
567  	free(v1dist);
568  	return -1;
569        }
570        state-&gt;global-&gt;close_child(&amp;childstate);
571      }
572      if (nbobjs &lt; 2) {
573        assert(nbobjs == 1);
574        if (hwloc__xml_verbose())
575  	fprintf(stderr, &quot;%s: ignoring invalid distance matrix with only 1 object\n&quot;,
576  		state-&gt;global-&gt;msgprefix);
577        free(matrix);
578        free(v1dist);
579      } else if (obj-&gt;parent) {
580        free(matrix);
581        free(v1dist);
582      } else {
583        v1dist-&gt;prev = data-&gt;last_v1dist;
584        v1dist-&gt;next = NULL;
585        if (data-&gt;last_v1dist)
586  	data-&gt;last_v1dist-&gt;next = v1dist;
587        else
588  	data-&gt;first_v1dist = v1dist;
589        data-&gt;last_v1dist = v1dist;
590      }
591    }
592    return state-&gt;global-&gt;close_tag(state);
593  }
594  static int
595  hwloc__xml_import_userdata(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj,
596  			   hwloc__xml_import_state_t state)
597  {
598    size_t length = 0;
599    int encoded = 0;
600    char *name = NULL; &amp;bsol;* optional */
601    int ret;
602    while (1) {
603      char *attrname, *attrvalue;
604      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
605        break;
606      if (!strcmp(attrname, &quot;length&quot;))
607        length = strtoul(attrvalue, NULL, 10);
608      else if (!strcmp(attrname, &quot;encoding&quot;))
609        encoded = !strcmp(attrvalue, &quot;base64&quot;);
610      else if (!strcmp(attrname, &quot;name&quot;))
611        name = attrvalue;
612      else
613        return -1;
614    }
615    if (!topology-&gt;userdata_import_cb) {
616      const char *buffer;
617      size_t reallength = encoded ? BASE64_ENCODED_LENGTH(length) : length;
618      ret = state-&gt;global-&gt;get_content(state, &amp;buffer, reallength);
619      if (ret &lt; 0)
620        return -1;
621    } else if (topology-&gt;userdata_not_decoded) {
622        const char *buffer;
623        char *fakename;
624        size_t reallength = encoded ? BASE64_ENCODED_LENGTH(length) : length;
625        ret = state-&gt;global-&gt;get_content(state, &amp;buffer, reallength);
626        if (ret &lt; 0)
627          return -1;
628        fakename = malloc(6 + 1 + (name ? strlen(name) : 4) + 1);
629        if (!fakename)
630  	return -1;
631        sprintf(fakename, encoded ? &quot;base64%c%s&quot; : &quot;normal%c%s&quot;, name ? &#x27;:&#x27; : &#x27;-&#x27;, name ? name : &quot;anon&quot;);
632        topology-&gt;userdata_import_cb(topology, obj, fakename, buffer, length);
633        free(fakename);
634    } else if (encoded &amp;&amp; length) {
635        const char *encoded_buffer;
636        size_t encoded_length = BASE64_ENCODED_LENGTH(length);
637        ret = state-&gt;global-&gt;get_content(state, &amp;encoded_buffer, encoded_length);
638        if (ret &lt; 0)
639          return -1;
640        if (ret) {
641  	char *decoded_buffer = malloc(length+1);
642  	if (!decoded_buffer)
643  	  return -1;
644  	assert(encoded_buffer[encoded_length] == 0);
645  	ret = hwloc_decode_from_base64(encoded_buffer, decoded_buffer, length+1);
646  	if (ret != (int) length) {
647  	  free(decoded_buffer);
648  	  return -1;
649  	}
650  	topology-&gt;userdata_import_cb(topology, obj, name, decoded_buffer, length);
651  	free(decoded_buffer);
652        }
653    } else { &amp;bsol;* always handle length==0 in the non-encoded case */
654        const char *buffer = &quot;&quot;;
655        if (length) {
656  	ret = state-&gt;global-&gt;get_content(state, &amp;buffer, length);
657  	if (ret &lt; 0)
658  	  return -1;
659        }
660        topology-&gt;userdata_import_cb(topology, obj, name, buffer, length);
661    }
662    state-&gt;global-&gt;close_content(state);
663    return state-&gt;global-&gt;close_tag(state);
664  }
665  static void hwloc__xml_import_report_outoforder(hwloc_topology_t topology, hwloc_obj_t new, hwloc_obj_t old)
666  {
667    char *progname = hwloc_progname(topology);
668    const char *origversion = hwloc_obj_get_info_by_name(topology-&gt;levels[0][0], &quot;hwlocVersion&quot;);
669    const char *origprogname = hwloc_obj_get_info_by_name(topology-&gt;levels[0][0], &quot;ProcessName&quot;);
670    char *c1, *cc1, t1[64];
671    char *c2 = NULL, *cc2 = NULL, t2[64];
672    hwloc_bitmap_asprintf(&amp;c1, new-&gt;cpuset);
673    hwloc_bitmap_asprintf(&amp;cc1, new-&gt;complete_cpuset);
674    hwloc_obj_type_snprintf(t1, sizeof(t1), new, 0);
675    if (old-&gt;cpuset)
676      hwloc_bitmap_asprintf(&amp;c2, old-&gt;cpuset);
677    if (old-&gt;complete_cpuset)
678      hwloc_bitmap_asprintf(&amp;cc2, old-&gt;complete_cpuset);
679    hwloc_obj_type_snprintf(t2, sizeof(t2), old, 0);
680    fprintf(stderr, &quot;****************************************************************************\n&quot;);
681    fprintf(stderr, &quot;* hwloc has encountered an out-of-order XML topology load.\n&quot;);
682    fprintf(stderr, &quot;* Object %s cpuset %s complete %s\n&quot;,
683  	  t1, c1, cc1);
684    fprintf(stderr, &quot;* was inserted after object %s with %s and %s.\n&quot;,
685  	  t2, c2 ? c2 : &quot;none&quot;, cc2 ? cc2 : &quot;none&quot;);
686    fprintf(stderr, &quot;* The error occured in hwloc %s inside process `%s&#x27;, while\n&quot;,
687  	  HWLOC_VERSION,
688  	  progname ? progname : &quot;&lt;unknown&gt;&quot;);
689    if (origversion || origprogname)
690      fprintf(stderr, &quot;* the input XML was generated by hwloc %s inside process `%s&#x27;.\n&quot;,
691  	    origversion ? origversion : &quot;(unknown version)&quot;,
692  	    origprogname ? origprogname : &quot;&lt;unknown&gt;&quot;);
693    else
694      fprintf(stderr, &quot;* the input XML was generated by an unspecified ancient hwloc release.\n&quot;);
695    fprintf(stderr, &quot;* Please check that your input topology XML file is valid.\n&quot;);
696    fprintf(stderr, &quot;* Set HWLOC_DEBUG_CHECK=1 in the environment to detect further issues.\n&quot;);
697    fprintf(stderr, &quot;****************************************************************************\n&quot;);
698    free(c1);
699    free(cc1);
700    free(c2);
701    free(cc2);
702    free(progname);
703  }
704  static int
705  hwloc__xml_import_object(hwloc_topology_t topology,
706  			 struct hwloc_xml_backend_data_s *data,
707  			 hwloc_obj_t parent, hwloc_obj_t obj, int *gotignored,
708  			 hwloc__xml_import_state_t state)
709  {
710    int ignored = 0;
711    int childrengotignored = 0;
712    int attribute_less_cache = 0;
713    int numa_was_root = 0;
714    char *tag;
715    struct hwloc__xml_import_state_s childstate;
716    obj-&gt;parent = parent;
717    while (1) {
718      char *attrname, *attrvalue;
719      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
720        break;
721      if (!strcmp(attrname, &quot;type&quot;)) {
722        if (hwloc_type_sscanf(attrvalue, &amp;obj-&gt;type, NULL, 0) &lt; 0) {
723  	if (!strcasecmp(attrvalue, &quot;Cache&quot;)) {
724  	  obj-&gt;type = _HWLOC_OBJ_CACHE_OLD; &amp;bsol;* will be fixed below */
725  	  attribute_less_cache = 1;
726  	} else if (!strcasecmp(attrvalue, &quot;System&quot;)) {
727  	  if (!parent)
728  	    obj-&gt;type = HWLOC_OBJ_MACHINE;
729  	  else {
730  	    if (hwloc__xml_verbose())
731  	      fprintf(stderr, &quot;%s: obsolete System object only allowed at root\n&quot;,
732  		      state-&gt;global-&gt;msgprefix);
733  	    goto error_with_object;
734  	  }
735  	} else if (!strcasecmp(attrvalue, &quot;Tile&quot;)) {
736  	  obj-&gt;type = HWLOC_OBJ_GROUP;
737  	  obj-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_INTEL_TILE;
738  	} else if (!strcasecmp(attrvalue, &quot;Module&quot;)) {
739  	  obj-&gt;type = HWLOC_OBJ_GROUP;
740  	  obj-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_INTEL_MODULE;
741  	} else if (!strcasecmp(attrvalue, &quot;MemCache&quot;)) {
742  	  obj-&gt;type = _HWLOC_OBJ_FUTURE;
743  	  ignored = 1;
744  	  if (hwloc__xml_verbose())
745  	    fprintf(stderr, &quot;%s: %s object not-supported, will be ignored\n&quot;,
746  		    state-&gt;global-&gt;msgprefix, attrvalue);
747  	} else {
748  	  if (hwloc__xml_verbose())
749  	    fprintf(stderr, &quot;%s: unrecognized object type string %s\n&quot;,
750  		    state-&gt;global-&gt;msgprefix, attrvalue);
751  	  goto error_with_object;
752  	}
753        }
754      } else {
755        if (obj-&gt;type == HWLOC_OBJ_TYPE_NONE) {
756  	if (hwloc__xml_verbose())
757  	  fprintf(stderr, &quot;%s: object attribute %s found before type\n&quot;,
758  		  state-&gt;global-&gt;msgprefix,  attrname);
759  	goto error_with_object;
760        }
761        hwloc__xml_import_object_attr(topology, data, obj, attrname, attrvalue, state, &amp;ignored);
762      }
763    }
764    while (1) {
765      int ret;
766      tag = NULL;
767      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
768      if (ret &lt; 0)
769        goto error;
770      if (!ret)
771        break;
772      if (!strcmp(tag, &quot;object&quot;)) {
773        break;
774      } else if (!strcmp(tag, &quot;page_type&quot;)) {
775        if (obj-&gt;type == HWLOC_OBJ_NUMANODE) {
776  	ret = hwloc__xml_import_pagetype(topology, &amp;obj-&gt;attr-&gt;numanode, &amp;childstate);
777        } else if (!parent) {
778  	ret = hwloc__xml_import_pagetype(topology, &amp;topology-&gt;machine_memory, &amp;childstate);
779        } else {
780  	if (hwloc__xml_verbose())
781  	  fprintf(stderr, &quot;%s: invalid non-NUMAnode object child %s\n&quot;,
782  		  state-&gt;global-&gt;msgprefix, tag);
783  	ret = -1;
784        }
785      } else if (!strcmp(tag, &quot;info&quot;)) {
786        ret = hwloc__xml_import_obj_info(data, obj, &amp;childstate);
787      } else if (data-&gt;version_major &lt; 2 &amp;&amp; !strcmp(tag, &quot;distances&quot;)) {
788        ret = hwloc__xml_v1import_distances(data, obj, &amp;childstate);
789      } else if (!strcmp(tag, &quot;userdata&quot;)) {
790        ret = hwloc__xml_import_userdata(topology, obj, &amp;childstate);
791      } else {
792        if (hwloc__xml_verbose())
793  	fprintf(stderr, &quot;%s: invalid special object child %s\n&quot;,
794  		state-&gt;global-&gt;msgprefix, tag);
795        ret = -1;
796      }
797      if (ret &lt; 0)
798        goto error;
799      state-&gt;global-&gt;close_child(&amp;childstate);
800    }
801    if (parent &amp;&amp; obj-&gt;type == HWLOC_OBJ_MACHINE) {
802      obj-&gt;type = HWLOC_OBJ_GROUP;
803    }
804    if (parent &amp;&amp; data-&gt;version_major &gt;= 2) {
805      if (hwloc__obj_type_is_normal(obj-&gt;type)) {
806        if (!hwloc__obj_type_is_normal(parent-&gt;type)) {
807  	if (hwloc__xml_verbose())
808  	  fprintf(stderr, &quot;normal object %s cannot be child of non-normal parent %s\n&quot;,
809  		  hwloc_obj_type_string(obj-&gt;type), hwloc_obj_type_string(parent-&gt;type));
810  	goto error_with_object;
811        }
812      } else if (hwloc__obj_type_is_memory(obj-&gt;type)) {
813        if (hwloc__obj_type_is_io(parent-&gt;type) || HWLOC_OBJ_MISC == parent-&gt;type) {
814  	if (hwloc__xml_verbose())
815  	  fprintf(stderr, &quot;Memory object %s cannot be child of non-normal-or-memory parent %s\n&quot;,
816  		  hwloc_obj_type_string(obj-&gt;type), hwloc_obj_type_string(parent-&gt;type));
817  	goto error_with_object;
818        }
819      } else if (hwloc__obj_type_is_io(obj-&gt;type)) {
820        if (hwloc__obj_type_is_memory(parent-&gt;type) || HWLOC_OBJ_MISC == parent-&gt;type) {
821  	if (hwloc__xml_verbose())
822  	  fprintf(stderr, &quot;I/O object %s cannot be child of non-normal-or-I/O parent %s\n&quot;,
823  		  hwloc_obj_type_string(obj-&gt;type), hwloc_obj_type_string(parent-&gt;type));
824  	goto error_with_object;
825        }
826      }
827    } else if (parent &amp;&amp; data-&gt;version_major &lt; 2) {
828      if (hwloc__obj_type_is_normal(obj-&gt;type) || HWLOC_OBJ_NUMANODE == obj-&gt;type) {
829        if (hwloc__obj_type_is_special(parent-&gt;type)) {
830  	if (hwloc__xml_verbose())
831  	  fprintf(stderr, &quot;v1.x normal v1.x object %s cannot be child of special parent %s\n&quot;,
832  		  hwloc_obj_type_string(obj-&gt;type), hwloc_obj_type_string(parent-&gt;type));
833  	goto error_with_object;
834        }
835      } else if (hwloc__obj_type_is_io(obj-&gt;type)) {
836        if (HWLOC_OBJ_MISC == parent-&gt;type) {
837  	if (hwloc__xml_verbose())
838  	  fprintf(stderr, &quot;I/O object %s cannot be child of Misc parent\n&quot;,
839  		  hwloc_obj_type_string(obj-&gt;type));
840  	goto error_with_object;
841        }
842      }
843    }
844    if (data-&gt;version_major &lt; 2) {
845      if (parent &amp;&amp; parent-&gt;type == HWLOC_OBJ_NUMANODE) {
846        parent = parent-&gt;parent;
847        assert(parent);
848      }
849      if (obj-&gt;type == HWLOC_OBJ_NUMANODE) {
850        if (!parent) {
851  	hwloc_obj_t machine = hwloc_alloc_setup_object(topology, HWLOC_OBJ_MACHINE, HWLOC_UNKNOWN_INDEX);
852  	machine-&gt;cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
853  	machine-&gt;complete_cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
854  	machine-&gt;nodeset = hwloc_bitmap_dup(obj-&gt;nodeset);
855  	machine-&gt;complete_nodeset = hwloc_bitmap_dup(obj-&gt;complete_nodeset);
856  	topology-&gt;levels[0][0] = machine;
857  	parent = machine;
858  	numa_was_root = 1;
859        } else if (!hwloc_bitmap_isequal(obj-&gt;complete_cpuset, parent-&gt;complete_cpuset)) {
860  	int needgroup = 1;
861  	hwloc_obj_t sibling;
862  	sibling = parent-&gt;memory_first_child;
863  	if (sibling &amp;&amp; !sibling-&gt;subtype
864  	    &amp;&amp; !sibling-&gt;next_sibling
865  	    &amp;&amp; obj-&gt;subtype &amp;&amp; !strcmp(obj-&gt;subtype, &quot;MCDRAM&quot;)
866  	    &amp;&amp; hwloc_bitmap_iszero(obj-&gt;complete_cpuset)) {
867  	  needgroup = 0;
868  	}
869  	if (needgroup
870  	    &amp;&amp; hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
871  	  hwloc_obj_t group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
872  	  group-&gt;gp_index = 0; &amp;bsol;* will be initialized at the end of the discovery once we know the max */
873  	  group-&gt;cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
874  	  group-&gt;complete_cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
875  	  group-&gt;nodeset = hwloc_bitmap_dup(obj-&gt;nodeset);
876  	  group-&gt;complete_nodeset = hwloc_bitmap_dup(obj-&gt;complete_nodeset);
877  	  group-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_MEMORY;
878  	  hwloc_insert_object_by_parent(topology, parent, group);
879  	  parent = group;
880  	}
881        }
882      }
883      if (attribute_less_cache) {
884        assert(obj-&gt;type == _HWLOC_OBJ_CACHE_OLD);
885        obj-&gt;type = hwloc_cache_type_by_depth_type(obj-&gt;attr-&gt;cache.depth, obj-&gt;attr-&gt;cache.type);
886      }
887      if (obj-&gt;type == HWLOC_OBJ_MISC &amp;&amp; obj-&gt;cpuset)
888        obj-&gt;type = HWLOC_OBJ_GROUP;
889      if (!obj-&gt;cpuset != !obj-&gt;complete_cpuset) {
890        if (obj-&gt;type == HWLOC_OBJ_GROUP) {
891  	ignored = 1;
892        } else {
893  	if (hwloc__xml_verbose())
894  	  fprintf(stderr, &quot;%s: invalid object %s P#%u with some missing cpusets\n&quot;,
895  		  state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
896  	goto error_with_object;
897        }
898      } else if (!obj-&gt;nodeset != !obj-&gt;complete_nodeset) {
899        if (obj-&gt;type == HWLOC_OBJ_GROUP) {
900  	ignored = 1;
901        } else {
902  	if (hwloc__xml_verbose())
903  	  fprintf(stderr, &quot;%s: invalid object %s P#%u with some missing nodesets\n&quot;,
904  		  state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
905  	goto error_with_object;
906        }
907      } else if (obj-&gt;nodeset &amp;&amp; !obj-&gt;cpuset) {
908        if (obj-&gt;type == HWLOC_OBJ_GROUP) {
909  	ignored = 1;
910        } else {
911  	if (hwloc__xml_verbose())
912  	  fprintf(stderr, &quot;%s: invalid object %s P#%u with either cpuset or nodeset missing\n&quot;,
913  		  state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
914  	goto error_with_object;
915        }
916      }
917    }
918    if (obj-&gt;type == HWLOC_OBJ_GROUP) {
919      if (obj-&gt;attr-&gt;group.kind == HWLOC_GROUP_KIND_INTEL_DIE
920  	|| (obj-&gt;subtype &amp;&amp; !strcmp(obj-&gt;subtype, &quot;Die&quot;)))
921        obj-&gt;type = HWLOC_OBJ_DIE;
922    }
923    if (hwloc__obj_type_is_cache(obj-&gt;type)
924        &amp;&amp; obj-&gt;type != hwloc_cache_type_by_depth_type(obj-&gt;attr-&gt;cache.depth, obj-&gt;attr-&gt;cache.type)) {
925      if (hwloc__xml_verbose())
926        fprintf(stderr, &quot;%s: invalid cache type %s with attribute depth %u and type %d\n&quot;,
927  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;attr-&gt;cache.depth, (int) obj-&gt;attr-&gt;cache.type);
928      goto error_with_object;
929    }
930    if (!obj-&gt;cpuset &amp;&amp; !hwloc__obj_type_is_special(obj-&gt;type)) {
931      if (hwloc__xml_verbose())
932        fprintf(stderr, &quot;%s: invalid normal object %s P#%u without cpuset\n&quot;,
933  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
934      goto error_with_object;
935    }
936    if (obj-&gt;cpuset &amp;&amp; hwloc__obj_type_is_special(obj-&gt;type)) {
937      if (hwloc__xml_verbose())
938        fprintf(stderr, &quot;%s: invalid special object %s with cpuset\n&quot;,
939  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type));
940      goto error_with_object;
941    }
942    if (obj-&gt;cpuset &amp;&amp; parent &amp;&amp; !parent-&gt;cpuset) {
943      if (hwloc__xml_verbose())
944        fprintf(stderr, &quot;%s: invalid object %s P#%u with cpuset while parent has none\n&quot;,
945  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
946      goto error_with_object;
947    }
948    if (obj-&gt;nodeset &amp;&amp; parent &amp;&amp; !parent-&gt;nodeset) {
949      if (hwloc__xml_verbose())
950        fprintf(stderr, &quot;%s: invalid object %s P#%u with nodeset while parent has none\n&quot;,
951  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
952      goto error_with_object;
953    }
954    if (obj-&gt;type == HWLOC_OBJ_NUMANODE) {
955      if (!obj-&gt;nodeset) {
956        if (hwloc__xml_verbose())
957  	fprintf(stderr, &quot;%s: invalid NUMA node object P#%u without nodeset\n&quot;,
958  		state-&gt;global-&gt;msgprefix, obj-&gt;os_index);
959        goto error_with_object;
960      }
961      data-&gt;nbnumanodes++;
962      obj-&gt;prev_cousin = data-&gt;last_numanode;
963      obj-&gt;next_cousin = NULL;
964      if (data-&gt;last_numanode)
965        data-&gt;last_numanode-&gt;next_cousin = obj;
966      else
967        data-&gt;first_numanode = obj;
968      data-&gt;last_numanode = obj;
969    }
970    if (!hwloc_filter_check_keep_object(topology, obj)) {
971      if (parent)
972        ignored = 1;
973    }
974    if (parent &amp;&amp; !ignored) {
975      hwloc_insert_object_by_parent(topology, parent, obj);
976    }
977    while (tag) {
978      int ret;
979      if (!strcmp(tag, &quot;object&quot;)) {
980        hwloc_obj_t childobj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_TYPE_MAX, HWLOC_UNKNOWN_INDEX);
981        childobj-&gt;parent = ignored ? parent : obj;
982        ret = hwloc__xml_import_object(topology, data, ignored ? parent : obj, childobj,
983  				     &amp;childrengotignored,
984  				     &amp;childstate);
985      } else {
986        if (hwloc__xml_verbose())
987  	fprintf(stderr, &quot;%s: invalid special object child %s while looking for objects\n&quot;,
988  		state-&gt;global-&gt;msgprefix, tag);
989        ret = -1;
990      }
991      if (ret &lt; 0) {
992        if (parent &amp;&amp; !ignored)
993          goto error;
994        else
995          goto error_with_object;
996      }
997      state-&gt;global-&gt;close_child(&amp;childstate);
998      tag = NULL;
999      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1000      if (ret &lt; 0) {
1001        if (parent &amp;&amp; !ignored)
1002          goto error;
1003        else
1004          goto error_with_object;
1005      }
1006      if (!ret)
1007        break;
1008    }
1009    if (numa_was_root) {
1010      unsigned i;
1011      for(i=0; i&lt;obj-&gt;infos_count; i++) {
1012        struct hwloc_info_s *info = &amp;obj-&gt;infos[i];
1013        hwloc_obj_add_info(parent, info-&gt;name, info-&gt;value);
1014      }
1015    }
1016    if (ignored) {
1017      hwloc_free_unlinked_object(obj);
1018      *gotignored = 1;
1019    } else if (obj-&gt;first_child) {
1020      hwloc_obj_t cur, next;
1021      for(cur = obj-&gt;first_child, next = cur-&gt;next_sibling;
1022  	next;
1023  	cur = next, next = next-&gt;next_sibling) {
1024        if (hwloc_bitmap_compare_first(next-&gt;complete_cpuset, cur-&gt;complete_cpuset) &lt; 0) {
1025  	if (!childrengotignored) {
1026  	  static int reported = 0;
1027  	  if (!reported &amp;&amp; HWLOC_SHOW_CRITICAL_ERRORS()) {
1028  	    hwloc__xml_import_report_outoforder(topology, next, cur);
1029  	    reported = 1;
1030  	  }
1031  	}
1032  	hwloc__reorder_children(obj);
1033  	break;
1034        }
1035      }
1036    }
1037    return state-&gt;global-&gt;close_tag(state);
1038   error_with_object:
1039    if (parent)
1040      hwloc_free_unlinked_object(obj);
1041   error:
1042    return -1;
1043  }
1044  static int
1045  hwloc__xml_v2import_support(hwloc_topology_t topology,
1046                              hwloc__xml_import_state_t state)
1047  {
1048    char *name = NULL;
1049    int value = 1; &amp;bsol;* value is optional */
1050    while (1) {
1051      char *attrname, *attrvalue;
1052      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1053        break;
1054      if (!strcmp(attrname, &quot;name&quot;))
1055        name = attrvalue;
1056      else if (!strcmp(attrname, &quot;value&quot;))
1057        value = atoi(attrvalue);
1058      else {
1059        if (hwloc__xml_verbose())
1060  	fprintf(stderr, &quot;%s: ignoring unknown support attribute %s\n&quot;,
1061  		state-&gt;global-&gt;msgprefix, attrname);
1062      }
1063    }
1064    if (name &amp;&amp; topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT) {
1065  #ifdef HWLOC_DEBUG
1066      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_support) == 4*sizeof(void*));
1067      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_discovery_support) == 6);
1068      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_cpubind_support) == 11);
1069      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_membind_support) == 15);
1070      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_misc_support) == 1);
1071  #endif
1072  #define DO(_cat,_name) if (!strcmp(#_cat &quot;.&quot; #_name, name)) topology-&gt;support._cat-&gt;_name = value
1073      DO(discovery,pu);
1074      else DO(discovery,numa);
1075      else DO(discovery,numa_memory);
1076      else DO(discovery,disallowed_pu);
1077      else DO(discovery,disallowed_numa);
1078      else DO(discovery,cpukind_efficiency);
1079      else DO(cpubind,set_thisproc_cpubind);
1080      else DO(cpubind,get_thisproc_cpubind);
1081      else DO(cpubind,set_proc_cpubind);
1082      else DO(cpubind,get_proc_cpubind);
1083      else DO(cpubind,set_thisthread_cpubind);
1084      else DO(cpubind,get_thisthread_cpubind);
1085      else DO(cpubind,set_thread_cpubind);
1086      else DO(cpubind,get_thread_cpubind);
1087      else DO(cpubind,get_thisproc_last_cpu_location);
1088      else DO(cpubind,get_proc_last_cpu_location);
1089      else DO(cpubind,get_thisthread_last_cpu_location);
1090      else DO(membind,set_thisproc_membind);
1091      else DO(membind,get_thisproc_membind);
1092      else DO(membind,set_proc_membind);
1093      else DO(membind,get_proc_membind);
1094      else DO(membind,set_thisthread_membind);
1095      else DO(membind,get_thisthread_membind);
1096      else DO(membind,set_area_membind);
1097      else DO(membind,get_area_membind);
1098      else DO(membind,alloc_membind);
1099      else DO(membind,firsttouch_membind);
1100      else DO(membind,bind_membind);
1101      else DO(membind,interleave_membind);
1102      else DO(membind,nexttouch_membind);
1103      else DO(membind,migrate_membind);
1104      else DO(membind,get_area_memlocation);
1105      else if (!strcmp(&quot;custom.exported_support&quot;, name))
1106        topology-&gt;support.misc-&gt;imported_support = 1;
1107  #undef DO
1108    }
1109    return 0;
1110  }
1111  static int
1112  hwloc__xml_v2import_distances(hwloc_topology_t topology,
1113  			      hwloc__xml_import_state_t state,
1114  			      int heterotypes)
1115  {
1116    hwloc_obj_type_t unique_type = HWLOC_OBJ_TYPE_NONE;
1117    hwloc_obj_type_t *different_types = NULL;
1118    unsigned nbobjs = 0;
1119    int indexing = heterotypes;
1120    int os_indexing = 0;
1121    int gp_indexing = heterotypes;
1122    char *name = NULL;
1123    unsigned long kind = 0;
1124    unsigned nr_indexes, nr_u64values;
1125    uint64_t *indexes;
1126    uint64_t *u64values;
1127    int ret;
1128  #define _TAG_NAME (heterotypes ? &quot;distances2hetero&quot; : &quot;distances2&quot;)
1129    while (1) {
1130      char *attrname, *attrvalue;
1131      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1132        break;
1133      if (!strcmp(attrname, &quot;nbobjs&quot;))
1134        nbobjs = strtoul(attrvalue, NULL, 10);
1135      else if (!strcmp(attrname, &quot;type&quot;)) {
1136        if (hwloc_type_sscanf(attrvalue, &amp;unique_type, NULL, 0) &lt; 0) {
1137  	if (hwloc__xml_verbose())
1138  	  fprintf(stderr, &quot;%s: unrecognized %s type %s\n&quot;,
1139  		  state-&gt;global-&gt;msgprefix, _TAG_NAME, attrvalue);
1140  	goto out;
1141        }
1142      }
1143      else if (!strcmp(attrname, &quot;indexing&quot;)) {
1144        indexing = 1;
1145        if (!strcmp(attrvalue, &quot;os&quot;))
1146  	os_indexing = 1;
1147        else if (!strcmp(attrvalue, &quot;gp&quot;))
1148  	gp_indexing = 1;
1149      }
1150      else if (!strcmp(attrname, &quot;kind&quot;)) {
1151        kind = strtoul(attrvalue, NULL, 10);
1152      }
1153      else if (!strcmp(attrname, &quot;name&quot;)) {
1154        name = attrvalue;
1155      }
1156      else {
1157        if (hwloc__xml_verbose())
1158  	fprintf(stderr, &quot;%s: ignoring unknown %s attribute %s\n&quot;,
1159  		state-&gt;global-&gt;msgprefix, _TAG_NAME, attrname);
1160      }
1161    }
1162    if (!nbobjs || (!heterotypes &amp;&amp; unique_type == HWLOC_OBJ_TYPE_NONE) || !indexing || !kind) {
1163      if (hwloc__xml_verbose())
1164        fprintf(stderr, &quot;%s: %s missing some attributes\n&quot;,
1165  	      state-&gt;global-&gt;msgprefix, _TAG_NAME);
1166      goto out;
1167    }
1168    indexes = malloc(nbobjs*sizeof(*indexes));
1169    u64values = malloc(nbobjs*nbobjs*sizeof(*u64values));
1170    if (heterotypes)
1171      different_types = malloc(nbobjs*sizeof(*different_types));
1172    if (!indexes || !u64values || (heterotypes &amp;&amp; !different_types)) {
1173      if (hwloc__xml_verbose())
1174        fprintf(stderr, &quot;%s: failed to allocate %s arrays for %u objects\n&quot;,
<span onclick='openModal()' class='match'>1175  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1176      goto out_with_arrays;
1177    }
1178    nr_indexes = 0;
</span>1179    nr_u64values = 0;
1180    while (1) {
1181      struct hwloc__xml_import_state_s childstate;
1182      char *attrname, *attrvalue, *tag;
1183      const char *buffer;
1184      int length;
1185      int is_index = 0;
1186      int is_u64values = 0;
1187      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1188      if (ret &lt;= 0)
1189        break;
1190      if (!strcmp(tag, &quot;indexes&quot;))
1191        is_index = 1;
1192      else if (!strcmp(tag, &quot;u64values&quot;))
1193        is_u64values = 1;
1194      if (!is_index &amp;&amp; !is_u64values) {
1195        if (hwloc__xml_verbose())
1196  	fprintf(stderr, &quot;%s: %s with unrecognized child %s\n&quot;,
1197  		state-&gt;global-&gt;msgprefix, _TAG_NAME, tag);
1198        goto out_with_arrays;
1199      }
1200      if (state-&gt;global-&gt;next_attr(&amp;childstate, &amp;attrname, &amp;attrvalue) &lt; 0
1201  	|| strcmp(attrname, &quot;length&quot;)) {
1202        if (hwloc__xml_verbose())
1203  	fprintf(stderr, &quot;%s: %s child must have length attribute\n&quot;,
1204  		state-&gt;global-&gt;msgprefix, _TAG_NAME);
1205        goto out_with_arrays;
1206      }
1207      length = atoi(attrvalue);
1208      ret = state-&gt;global-&gt;get_content(&amp;childstate, &amp;buffer, length);
1209      if (ret &lt; 0) {
1210        if (hwloc__xml_verbose())
1211  	fprintf(stderr, &quot;%s: %s child needs content of length %d\n&quot;,
1212  		state-&gt;global-&gt;msgprefix, _TAG_NAME, length);
1213        goto out_with_arrays;
1214      }
1215      if (is_index) {
1216        const char *tmp, *tmp2;
1217        if (nr_indexes &gt;= nbobjs) {
1218  	if (hwloc__xml_verbose())
1219  	  fprintf(stderr, &quot;%s: %s with more than %u indexes\n&quot;,
1220  		  state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1221  	goto out_with_arrays;
1222        }
1223        tmp = buffer;
1224        while (1) {
1225  	char *next;
1226  	unsigned long long u;
1227  	if (heterotypes) {
1228  	  hwloc_obj_type_t t = HWLOC_OBJ_TYPE_NONE;
1229            if (!*tmp)
1230              break;
1231  	  if (hwloc_type_sscanf(tmp, &amp;t, NULL, 0) &lt; 0) {
1232  	    if (hwloc__xml_verbose())
1233  	      fprintf(stderr, &quot;%s: %s with unrecognized heterogeneous type %s\n&quot;,
1234  		      state-&gt;global-&gt;msgprefix, _TAG_NAME, tmp);
1235  	    goto out_with_arrays;
1236  	  }
1237  	  tmp2 = strchr(tmp, &#x27;:&#x27;);
1238  	  if (!tmp2) {
1239  	    if (hwloc__xml_verbose())
1240  	      fprintf(stderr, &quot;%s: %s with missing colon after heterogeneous type %s\n&quot;,
1241  		      state-&gt;global-&gt;msgprefix, _TAG_NAME, tmp);
1242  	    goto out_with_arrays;
1243  	  }
1244  	  tmp = tmp2+1;
1245  	  different_types[nr_indexes] = t;
1246  	}
1247  	u = strtoull(tmp, &amp;next, 0);
1248  	if (next == tmp)
1249  	  break;
1250  	indexes[nr_indexes++] = u;
1251  	if (*next != &#x27; &#x27;)
1252  	  break;
1253  	if (nr_indexes == nbobjs)
1254  	  break;
1255  	tmp = next+1;
1256        }
1257      } else if (is_u64values) {
1258        const char *tmp;
1259        if (nr_u64values &gt;= nbobjs*nbobjs) {
1260  	if (hwloc__xml_verbose())
1261  	  fprintf(stderr, &quot;%s: %s with more than %u u64values\n&quot;,
1262  		  state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs*nbobjs);
1263  	goto out_with_arrays;
1264        }
1265        tmp = buffer;
1266        while (1) {
1267  	char *next;
1268  	unsigned long long u = strtoull(tmp, &amp;next, 0);
1269  	if (next == tmp)
1270  	  break;
1271  	u64values[nr_u64values++] = u;
1272  	if (*next != &#x27; &#x27;)
1273  	  break;
1274  	if (nr_u64values == nbobjs*nbobjs)
1275  	  break;
1276  	tmp = next+1;
1277        }
1278      }
1279      state-&gt;global-&gt;close_content(&amp;childstate);
1280      ret = state-&gt;global-&gt;close_tag(&amp;childstate);
1281      if (ret &lt; 0) {
1282        if (hwloc__xml_verbose())
1283  	fprintf(stderr, &quot;%s: %s with more than %u indexes\n&quot;,
1284  		state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1285        goto out_with_arrays;
1286      }
1287      state-&gt;global-&gt;close_child(&amp;childstate);
1288    }
1289    if (nr_indexes != nbobjs) {
1290      if (hwloc__xml_verbose())
1291        fprintf(stderr, &quot;%s: %s with less than %u indexes\n&quot;,
1292  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1293      goto out_with_arrays;
1294    }
1295    if (nr_u64values != nbobjs*nbobjs) {
1296      if (hwloc__xml_verbose())
1297        fprintf(stderr, &quot;%s: %s with less than %u u64values\n&quot;,
1298  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs*nbobjs);
1299      goto out_with_arrays;
1300    }
1301    if (nbobjs &lt; 2) {
1302      if (hwloc__xml_verbose())
1303        fprintf(stderr, &quot;%s: ignoring %s with only %u objects\n&quot;,
1304  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1305      goto out_ignore;
1306    }
1307    if (unique_type == HWLOC_OBJ_PU || unique_type == HWLOC_OBJ_NUMANODE) {
1308      if (!os_indexing) {
1309        if (hwloc__xml_verbose())
1310  	fprintf(stderr, &quot;%s: ignoring PU or NUMA %s without os_indexing\n&quot;,
1311  		state-&gt;global-&gt;msgprefix, _TAG_NAME);
1312        goto out_ignore;
1313      }
1314    } else {
1315      if (!gp_indexing) {
1316        if (hwloc__xml_verbose())
1317  	fprintf(stderr, &quot;%s: ignoring !PU or !NUMA %s without gp_indexing\n&quot;,
1318  		state-&gt;global-&gt;msgprefix, _TAG_NAME);
1319        goto out_ignore;
1320      }
1321    }
1322    if (topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)
1323      goto out_ignore;
1324    hwloc_internal_distances_add_by_index(topology, name, unique_type, different_types, nbobjs, indexes, u64values, kind, 0 &amp;bsol;* assume grouping was applied when this matrix was discovered before exporting to XML */);
1325    indexes = NULL;
1326    u64values = NULL;
1327    different_types = NULL;
1328   out_ignore:
1329    free(different_types);
1330    free(indexes);
1331    free(u64values);
1332    return state-&gt;global-&gt;close_tag(state);
1333   out_with_arrays:
1334    free(different_types);
1335    free(indexes);
1336    free(u64values);
1337   out:
1338    return -1;
1339  #undef _TAG_NAME
1340  }
1341  static int
1342  hwloc__xml_import_memattr_value(hwloc_topology_t topology,
1343                                  hwloc_memattr_id_t id,
1344                                  unsigned long flags,
1345                                  hwloc__xml_import_state_t state)
1346  {
1347    char *target_obj_gp_index_s = NULL;
1348    char *target_obj_type_s = NULL;
1349    hwloc_uint64_t target_obj_gp_index;
1350    char *value_s = NULL;
1351    hwloc_uint64_t value;
1352    char *initiator_cpuset_s = NULL;
1353    char *initiator_obj_gp_index_s = NULL;
1354    char *initiator_obj_type_s = NULL;
1355    hwloc_obj_type_t target_obj_type = HWLOC_OBJ_TYPE_NONE;
1356    while (1) {
1357      char *attrname, *attrvalue;
1358      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1359        break;
1360      if (!strcmp(attrname, &quot;target_obj_gp_index&quot;))
1361        target_obj_gp_index_s = attrvalue;
1362      else if (!strcmp(attrname, &quot;target_obj_type&quot;))
1363        target_obj_type_s = attrvalue;
1364      else if (!strcmp(attrname, &quot;value&quot;))
1365        value_s = attrvalue;
1366      else if (!strcmp(attrname, &quot;initiator_cpuset&quot;))
1367        initiator_cpuset_s = attrvalue;
1368      else if (!strcmp(attrname, &quot;initiator_obj_gp_index&quot;))
1369        initiator_obj_gp_index_s = attrvalue;
1370      else if (!strcmp(attrname, &quot;initiator_obj_type&quot;))
1371        initiator_obj_type_s = attrvalue;
1372      else {
1373        if (hwloc__xml_verbose())
1374          fprintf(stderr, &quot;%s: ignoring unknown memattr_value attribute %s\n&quot;,
1375                  state-&gt;global-&gt;msgprefix, attrname);
1376        return -1;
1377      }
1378    }
1379    if (!target_obj_type_s) {
1380      if (hwloc__xml_verbose())
1381        fprintf(stderr, &quot;%s: ignoring memattr_value without target_obj_type.\n&quot;,
1382                state-&gt;global-&gt;msgprefix);
1383      return -1;
1384    }
1385    if (hwloc_type_sscanf(target_obj_type_s, &amp;target_obj_type, NULL, 0) &lt; 0) {
1386      if (hwloc__xml_verbose())
1387        fprintf(stderr, &quot;%s: failed to identify memattr_value target object type %s\n&quot;,
1388                state-&gt;global-&gt;msgprefix, target_obj_type_s);
1389      return -1;
1390    }
1391    if (!value_s || !target_obj_gp_index_s) {
1392      if (hwloc__xml_verbose())
1393        fprintf(stderr, &quot;%s: ignoring memattr_value without value and target_obj_gp_index\n&quot;,
1394                state-&gt;global-&gt;msgprefix);
1395      return -1;
1396    }
1397    target_obj_gp_index = strtoull(target_obj_gp_index_s, NULL, 10);
1398    value = strtoull(value_s, NULL, 10);
1399    if (flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
1400      struct hwloc_internal_location_s loc;
1401      if (!initiator_cpuset_s &amp;&amp; (!initiator_obj_gp_index_s || !initiator_obj_type_s)) {
1402        if (hwloc__xml_verbose())
1403          fprintf(stderr, &quot;%s: ignoring memattr_value without initiator attributes\n&quot;,
1404                  state-&gt;global-&gt;msgprefix);
1405        return -1;
1406      }
1407      if (initiator_cpuset_s) {
1408        loc.type = HWLOC_LOCATION_TYPE_CPUSET;
1409        loc.location.cpuset = hwloc_bitmap_alloc();
1410        if (!loc.location.cpuset) {
1411          if (hwloc__xml_verbose())
1412            fprintf(stderr, &quot;%s: failed to allocated memattr_value initiator cpuset\n&quot;,
1413                    state-&gt;global-&gt;msgprefix);
1414          return -1;
1415        }
1416        hwloc_bitmap_sscanf(loc.location.cpuset, initiator_cpuset_s);
1417      } else {
1418        loc.type = HWLOC_LOCATION_TYPE_OBJECT;
1419        loc.location.object.gp_index = strtoull(initiator_obj_gp_index_s, NULL, 10);
1420        if (hwloc_type_sscanf(initiator_obj_type_s, &amp;loc.location.object.type, NULL, 0) &lt; 0) {
1421          if (hwloc__xml_verbose())
1422            fprintf(stderr, &quot;%s: failed to identify memattr_value initiator object type %s\n&quot;,
1423                    state-&gt;global-&gt;msgprefix, initiator_obj_type_s);
1424          return -1;
1425        }
1426      }
1427      hwloc_internal_memattr_set_value(topology, id, target_obj_type, target_obj_gp_index, (unsigned)-1, &amp;loc, value);
1428      if (loc.type == HWLOC_LOCATION_TYPE_CPUSET)
1429        hwloc_bitmap_free(loc.location.cpuset);
1430    } else {
1431      hwloc_internal_memattr_set_value(topology, id, target_obj_type, target_obj_gp_index, (unsigned)-1, NULL, value);
1432    }
1433    return 0;
1434  }
1435  static int
1436  hwloc__xml_import_memattr(hwloc_topology_t topology,
1437                            hwloc__xml_import_state_t state)
1438  {
1439    char *name = NULL;
1440    unsigned long flags = (unsigned long) -1;
1441    hwloc_memattr_id_t id = (hwloc_memattr_id_t) -1;
1442    int ret;
1443    while (1) {
1444      char *attrname, *attrvalue;
1445      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1446        break;
1447      if (!strcmp(attrname, &quot;name&quot;))
1448        name = attrvalue;
1449      else if (!strcmp(attrname, &quot;flags&quot;))
1450        flags = strtoul(attrvalue, NULL, 10);
1451      else {
1452        if (hwloc__xml_verbose())
1453          fprintf(stderr, &quot;%s: ignoring unknown memattr attribute %s\n&quot;,
1454                  state-&gt;global-&gt;msgprefix, attrname);
1455        return -1;
1456      }
1457    }
1458    if (name &amp;&amp; flags != (unsigned long) -1
1459        &amp;&amp; !(topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS)) {
1460      hwloc_memattr_id_t _id;
1461      ret = hwloc_memattr_get_by_name(topology, name, &amp;_id);
1462      if (ret &lt; 0) {
1463        ret = hwloc_memattr_register(topology, name, flags, &amp;_id);
1464        if (!ret)
1465          id = _id;
1466      } else {
1467        unsigned long mflags;
1468        ret = hwloc_memattr_get_flags(topology, _id, &amp;mflags);
1469        if (!ret &amp;&amp; mflags == flags)
1470          id = _id;
1471      }
1472    }
1473    while (1) {
1474      struct hwloc__xml_import_state_s childstate;
1475      char *tag;
1476      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1477      if (ret &lt;= 0)
1478        break;
1479      if (!strcmp(tag, &quot;memattr_value&quot;)) {
1480        ret = hwloc__xml_import_memattr_value(topology, id, flags, &amp;childstate);
1481      } else {
1482        if (hwloc__xml_verbose())
1483          fprintf(stderr, &quot;%s: memattr with unrecognized child %s\n&quot;,
1484                  state-&gt;global-&gt;msgprefix, tag);
1485        ret = -1;
1486      }
1487      if (ret &lt; 0)
1488        goto error;
1489      state-&gt;global-&gt;close_child(&amp;childstate);
1490    }
1491    return state-&gt;global-&gt;close_tag(state);
1492   error:
1493    return -1;
1494  }
1495  static int
1496  hwloc__xml_import_cpukind(hwloc_topology_t topology,
1497                            hwloc__xml_import_state_t state)
1498  {
1499    hwloc_bitmap_t cpuset = NULL;
1500    int forced_efficiency = HWLOC_CPUKIND_EFFICIENCY_UNKNOWN;
1501    unsigned nr_infos = 0;
1502    struct hwloc_info_s *infos = NULL;
1503    int ret;
1504    while (1) {
1505      char *attrname, *attrvalue;
1506      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1507        break;
1508      if (!strcmp(attrname, &quot;cpuset&quot;)) {
1509        if (!cpuset)
1510          cpuset = hwloc_bitmap_alloc();
1511        hwloc_bitmap_sscanf(cpuset, attrvalue);
1512      } else if (!strcmp(attrname, &quot;forced_efficiency&quot;)) {
1513        forced_efficiency = atoi(attrvalue);
1514      } else {
1515        if (hwloc__xml_verbose())
1516          fprintf(stderr, &quot;%s: ignoring unknown cpukind attribute %s\n&quot;,
1517                  state-&gt;global-&gt;msgprefix, attrname);
1518        hwloc_bitmap_free(cpuset);
1519        return -1;
1520      }
1521    }
1522    while (1) {
1523      struct hwloc__xml_import_state_s childstate;
1524      char *tag;
1525      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1526      if (ret &lt;= 0)
1527        break;
1528      if (!strcmp(tag, &quot;info&quot;)) {
1529        char *infoname = NULL;
1530        char *infovalue = NULL;
1531        ret = hwloc___xml_import_info(&amp;infoname, &amp;infovalue, &amp;childstate);
1532        if (!ret &amp;&amp; infoname &amp;&amp; infovalue)
1533          hwloc__add_info(&amp;infos, &amp;nr_infos, infoname, infovalue);
1534      } else {
1535        if (hwloc__xml_verbose())
1536          fprintf(stderr, &quot;%s: cpukind with unrecognized child %s\n&quot;,
1537                  state-&gt;global-&gt;msgprefix, tag);
1538        ret = -1;
1539      }
1540      if (ret &lt; 0)
1541        goto error;
1542      state-&gt;global-&gt;close_child(&amp;childstate);
1543    }
1544    if (!cpuset) {
1545      if (hwloc__xml_verbose())
1546        fprintf(stderr, &quot;%s: ignoring cpukind without cpuset\n&quot;,
1547                state-&gt;global-&gt;msgprefix);
1548      goto error;
1549    }
1550    if (topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS) {
1551      hwloc__free_infos(infos, nr_infos);
1552      hwloc_bitmap_free(cpuset);
1553    } else {
1554      hwloc_internal_cpukinds_register(topology, cpuset, forced_efficiency, infos, nr_infos, HWLOC_CPUKINDS_REGISTER_FLAG_OVERWRITE_FORCED_EFFICIENCY);
1555      hwloc__free_infos(infos, nr_infos);
1556    }
1557    return state-&gt;global-&gt;close_tag(state);
1558   error:
1559    hwloc__free_infos(infos, nr_infos);
1560    hwloc_bitmap_free(cpuset);
1561    return -1;
1562  }
1563  static int
1564  hwloc__xml_import_diff_one(hwloc__xml_import_state_t state,
1565  			   hwloc_topology_diff_t *firstdiffp,
1566  			   hwloc_topology_diff_t *lastdiffp)
1567  {
1568    char *type_s = NULL;
1569    char *obj_depth_s = NULL;
1570    char *obj_index_s = NULL;
1571    char *obj_attr_type_s = NULL;
1572    char *obj_attr_name_s = NULL;
1573    char *obj_attr_oldvalue_s = NULL;
1574    char *obj_attr_newvalue_s = NULL;
1575    while (1) {
1576      char *attrname, *attrvalue;
1577      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1578        break;
1579      if (!strcmp(attrname, &quot;type&quot;))
1580        type_s = attrvalue;
1581      else if (!strcmp(attrname, &quot;obj_depth&quot;))
1582        obj_depth_s = attrvalue;
1583      else if (!strcmp(attrname, &quot;obj_index&quot;))
1584        obj_index_s = attrvalue;
1585      else if (!strcmp(attrname, &quot;obj_attr_type&quot;))
1586        obj_attr_type_s = attrvalue;
1587      else if (!strcmp(attrname, &quot;obj_attr_index&quot;))
1588        { &amp;bsol;* obj_attr_index_s = attrvalue; unused for now */ }
1589      else if (!strcmp(attrname, &quot;obj_attr_name&quot;))
1590        obj_attr_name_s = attrvalue;
1591      else if (!strcmp(attrname, &quot;obj_attr_oldvalue&quot;))
1592        obj_attr_oldvalue_s = attrvalue;
1593      else if (!strcmp(attrname, &quot;obj_attr_newvalue&quot;))
1594        obj_attr_newvalue_s = attrvalue;
1595      else {
1596        if (hwloc__xml_verbose())
1597  	fprintf(stderr, &quot;%s: ignoring unknown diff attribute %s\n&quot;,
1598  		state-&gt;global-&gt;msgprefix, attrname);
1599        return -1;
1600      }
1601    }
1602    if (type_s) {
1603      switch (atoi(type_s)) {
1604      default:
1605        break;
1606      case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR: {
1607        hwloc_topology_diff_obj_attr_type_t obj_attr_type;
1608        hwloc_topology_diff_t diff;
1609        if (!obj_depth_s || !obj_index_s || !obj_attr_type_s) {
1610  	if (hwloc__xml_verbose())
1611  	  fprintf(stderr, &quot;%s: missing mandatory obj attr generic attributes\n&quot;,
1612  		  state-&gt;global-&gt;msgprefix);
1613  	break;
1614        }
1615        if (!obj_attr_oldvalue_s || !obj_attr_newvalue_s) {
1616  	if (hwloc__xml_verbose())
1617  	  fprintf(stderr, &quot;%s: missing mandatory obj attr value attributes\n&quot;,
1618  		  state-&gt;global-&gt;msgprefix);
1619  	break;
1620        }
1621        obj_attr_type = atoi(obj_attr_type_s);
1622        if (obj_attr_type == HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO &amp;&amp; !obj_attr_name_s) {
1623  	if (hwloc__xml_verbose())
1624  	  fprintf(stderr, &quot;%s: missing mandatory obj attr info name attribute\n&quot;,
1625  		  state-&gt;global-&gt;msgprefix);
1626  	break;
1627        }
1628        diff = malloc(sizeof(*diff));
1629        if (!diff)
1630  	return -1;
1631        diff-&gt;obj_attr.type = HWLOC_TOPOLOGY_DIFF_OBJ_ATTR;
1632        diff-&gt;obj_attr.obj_depth = atoi(obj_depth_s);
1633        diff-&gt;obj_attr.obj_index = atoi(obj_index_s);
1634        memset(&amp;diff-&gt;obj_attr.diff, 0, sizeof(diff-&gt;obj_attr.diff));
1635        diff-&gt;obj_attr.diff.generic.type = obj_attr_type;
1636        switch (obj_attr_type) {
1637        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
1638  	diff-&gt;obj_attr.diff.uint64.oldvalue = strtoull(obj_attr_oldvalue_s, NULL, 0);
1639  	diff-&gt;obj_attr.diff.uint64.newvalue = strtoull(obj_attr_newvalue_s, NULL, 0);
1640  	break;
1641        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
1642  	diff-&gt;obj_attr.diff.string.name = strdup(obj_attr_name_s);
1643        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
1644  	diff-&gt;obj_attr.diff.string.oldvalue = strdup(obj_attr_oldvalue_s);
1645  	diff-&gt;obj_attr.diff.string.newvalue = strdup(obj_attr_newvalue_s);
1646  	break;
1647        }
1648        if (*firstdiffp)
1649  	(*lastdiffp)-&gt;generic.next = diff;
1650        else
1651          *firstdiffp = diff;
1652        *lastdiffp = diff;
1653        diff-&gt;generic.next = NULL;
1654      }
1655      }
1656    }
1657    return state-&gt;global-&gt;close_tag(state);
1658  }
1659  int
1660  hwloc__xml_import_diff(hwloc__xml_import_state_t state,
1661  		       hwloc_topology_diff_t *firstdiffp)
1662  {
1663    hwloc_topology_diff_t firstdiff = NULL, lastdiff = NULL;
1664    *firstdiffp = NULL;
1665    while (1) {
1666      struct hwloc__xml_import_state_s childstate;
1667      char *tag;
1668      int ret;
1669      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1670      if (ret &lt; 0)
1671        return -1;
1672      if (!ret)
1673        break;
1674      if (!strcmp(tag, &quot;diff&quot;)) {
1675        ret = hwloc__xml_import_diff_one(&amp;childstate, &amp;firstdiff, &amp;lastdiff);
1676      } else
1677        ret = -1;
1678      if (ret &lt; 0)
1679        return ret;
1680      state-&gt;global-&gt;close_child(&amp;childstate);
1681    }
1682    *firstdiffp = firstdiff;
1683    return 0;
1684  }
1685  static void
1686  hwloc_convert_from_v1dist_floats(hwloc_topology_t topology, unsigned nbobjs, float *floats, uint64_t *u64s)
1687  {
1688    unsigned i;
1689    int is_uint;
1690    char *env;
1691    float scale = 1000.f;
1692    char scalestring[20];
1693    env = getenv(&quot;HWLOC_XML_V1DIST_SCALE&quot;);
1694    if (env) {
1695      scale = (float) atof(env);
1696      goto scale;
1697    }
1698    is_uint = 1;
1699    for(i=0; i&lt;nbobjs*nbobjs; i++) {
1700      float f, iptr, fptr;
1701      f = floats[i];
1702      if (f &lt; 0.f) {
1703        is_uint = 0;
1704        break;
1705      }
1706      fptr = modff(f, &amp;iptr);
1707      if (fptr &gt; .001f &amp;&amp; fptr &lt; .999f) {
1708        is_uint = 0;
1709        break;
1710      }
1711      u64s[i] = (int)(f+.5f);
1712    }
1713    if (is_uint)
1714      return;
1715   scale:
1716    for(i=0; i&lt;nbobjs*nbobjs; i++)
1717      u64s[i] = (uint64_t)(scale * floats[i]);
1718    sprintf(scalestring, &quot;%f&quot;, scale);
1719    hwloc_obj_add_info(hwloc_get_root_obj(topology), &quot;xmlv1DistancesScale&quot;, scalestring);
1720  }
1721  static int
1722  hwloc_look_xml(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
1723  {
1724    struct hwloc_topology *topology = backend-&gt;topology;
1725    struct hwloc_xml_backend_data_s *data = backend-&gt;private_data;
1726    struct hwloc__xml_import_state_s state, childstate;
1727    struct hwloc_obj *root = topology-&gt;levels[0][0];
1728    char *tag;
1729    int gotignored = 0;
1730    hwloc_localeswitch_declare;
1731    int ret;
1732    assert(dstatus-&gt;phase == HWLOC_DISC_PHASE_GLOBAL);
1733    state.global = data;
1734    assert(!root-&gt;cpuset);
1735    hwloc_localeswitch_init();
1736    data-&gt;nbnumanodes = 0;
1737    data-&gt;first_numanode = data-&gt;last_numanode = NULL;
1738    data-&gt;first_v1dist = data-&gt;last_v1dist = NULL;
1739    ret = data-&gt;look_init(data, &amp;state);
1740    if (ret &lt; 0)
1741      goto failed;
1742    if (data-&gt;version_major &gt; 2) {
1743      if (hwloc__xml_verbose())
1744        fprintf(stderr, &quot;%s: cannot import XML version %u.%u &gt; 2\n&quot;,
1745  	      data-&gt;msgprefix, data-&gt;version_major, data-&gt;version_minor);
1746      goto err;
1747    }
1748    ret = state.global-&gt;find_child(&amp;state, &amp;childstate, &amp;tag);
1749    if (ret &lt; 0 || !ret || strcmp(tag, &quot;object&quot;))
1750      goto failed;
1751    ret = hwloc__xml_import_object(topology, data, NULL &amp;bsol;*  no parent */, root,
1752  				 &amp;gotignored,
1753  				 &amp;childstate);
1754    if (ret &lt; 0)
1755      goto failed;
1756    state.global-&gt;close_child(&amp;childstate);
1757    assert(!gotignored);
1758    root = topology-&gt;levels[0][0];
1759    if (data-&gt;version_major &gt;= 2) {
1760      while (1) {
1761        ret = state.global-&gt;find_child(&amp;state, &amp;childstate, &amp;tag);
1762        if (ret &lt; 0)
1763  	goto failed;
1764        if (!ret)
1765  	break;
1766        if (!strcmp(tag, &quot;distances2&quot;)) {
1767  	ret = hwloc__xml_v2import_distances(topology, &amp;childstate, 0);
1768  	if (ret &lt; 0)
1769  	  goto failed;
1770        } else if (!strcmp(tag, &quot;distances2hetero&quot;)) {
1771  	ret = hwloc__xml_v2import_distances(topology, &amp;childstate, 1);
1772  	if (ret &lt; 0)
1773  	  goto failed;
1774        } else if (!strcmp(tag, &quot;support&quot;)) {
1775  	ret = hwloc__xml_v2import_support(topology, &amp;childstate);
1776  	if (ret &lt; 0)
1777  	  goto failed;
1778        } else if (!strcmp(tag, &quot;memattr&quot;)) {
1779          ret = hwloc__xml_import_memattr(topology, &amp;childstate);
1780          if (ret &lt; 0)
1781            goto failed;
1782        } else if (!strcmp(tag, &quot;cpukind&quot;)) {
1783          ret = hwloc__xml_import_cpukind(topology, &amp;childstate);
1784          if (ret &lt; 0)
1785            goto failed;
1786        } else {
1787  	if (hwloc__xml_verbose())
1788  	  fprintf(stderr, &quot;%s: ignoring unknown tag `%s&#x27; after root object.\n&quot;,
1789  		  data-&gt;msgprefix, tag);
1790  	goto done;
1791        }
1792        state.global-&gt;close_child(&amp;childstate);
1793      }
1794    }
1795    state.global-&gt;close_tag(&amp;state);
1796  done:
1797    if (!root-&gt;cpuset) {
1798      if (hwloc__xml_verbose())
1799        fprintf(stderr, &quot;%s: invalid root object without cpuset\n&quot;,
1800  	      data-&gt;msgprefix);
1801      goto err;
1802    }
1803    if (data-&gt;version_major &lt; 2 &amp;&amp; data-&gt;first_numanode) {
1804      hwloc_obj_t node = data-&gt;first_numanode;
1805      do {
1806        if (node-&gt;parent-&gt;type == HWLOC_OBJ_GROUP
1807  	  &amp;&amp; !node-&gt;parent-&gt;gp_index)
1808  	node-&gt;parent-&gt;gp_index = topology-&gt;next_gp_index++;
1809        node = node-&gt;next_cousin;
1810      } while (node);
1811    }
1812    if (data-&gt;version_major &lt; 2 &amp;&amp; data-&gt;first_v1dist) {
1813      struct hwloc__xml_imported_v1distances_s *v1dist, *v1next = data-&gt;first_v1dist;
1814      while ((v1dist = v1next) != NULL) {
1815        unsigned nbobjs = v1dist-&gt;nbobjs;
1816        v1next = v1dist-&gt;next;
1817        if (nbobjs == data-&gt;nbnumanodes
1818            &amp;&amp; !(topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)) {
1819  	hwloc_obj_t *objs = malloc(nbobjs*sizeof(hwloc_obj_t));
1820  	uint64_t *values = malloc(nbobjs*nbobjs*sizeof(*values));
1821          assert(data-&gt;nbnumanodes &gt; 0); &amp;bsol;* v1dist-&gt;nbobjs is &gt;0 after import */
1822          assert(data-&gt;first_numanode);
1823  	if (objs &amp;&amp; values) {
1824  	  hwloc_obj_t node;
1825  	  unsigned i;
1826  	  for(i=0, node = data-&gt;first_numanode;
1827  	      i&lt;nbobjs;
1828  	      i++, node = node-&gt;next_cousin)
1829  	    objs[i] = node;
1830  	  hwloc_convert_from_v1dist_floats(topology, nbobjs, v1dist-&gt;floats, values);
1831  	  hwloc_internal_distances_add(topology, NULL, nbobjs, objs, values, v1dist-&gt;kind, 0);
1832  	} else {
1833  	  free(objs);
1834  	  free(values);
1835  	}
1836        }
1837        free(v1dist-&gt;floats);
1838        free(v1dist);
1839      }
1840      data-&gt;first_v1dist = data-&gt;last_v1dist = NULL;
1841    }
1842    if (data-&gt;version_major &gt;= 2) {
1843      if (!root-&gt;nodeset) {
1844        if (hwloc__xml_verbose())
1845  	fprintf(stderr, &quot;%s: invalid root object without nodeset\n&quot;,
1846  		data-&gt;msgprefix);
1847        goto err;
1848      }
1849      if (hwloc_bitmap_iszero(root-&gt;nodeset)) {
1850        if (hwloc__xml_verbose())
1851  	fprintf(stderr, &quot;%s: invalid root object with empty nodeset\n&quot;,
1852  		data-&gt;msgprefix);
1853        goto err;
1854      }
1855    } else {
1856    }
1857    hwloc_alloc_root_sets(root);
1858    if (!(topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT)) {
1859      topology-&gt;support.discovery-&gt;pu = 1;
1860      topology-&gt;support.discovery-&gt;disallowed_pu = 1;
1861      if (data-&gt;nbnumanodes) {
1862        topology-&gt;support.discovery-&gt;numa = 1;
1863        topology-&gt;support.discovery-&gt;numa_memory = 1; 
1864        topology-&gt;support.discovery-&gt;disallowed_numa = 1;
1865      }
1866    }
1867    if (data-&gt;look_done)
1868      data-&gt;look_done(data, 0);
1869    hwloc_localeswitch_fini();
1870    return 0;
1871   failed:
1872    if (data-&gt;look_done)
1873      data-&gt;look_done(data, -1);
1874    if (hwloc__xml_verbose())
1875      fprintf(stderr, &quot;%s: XML component discovery failed.\n&quot;,
1876  	    data-&gt;msgprefix);
1877   err:
1878    hwloc_free_object_siblings_and_children(root-&gt;first_child);
1879    root-&gt;first_child = NULL;
1880    hwloc_free_object_siblings_and_children(root-&gt;memory_first_child);
1881    root-&gt;memory_first_child = NULL;
1882    hwloc_free_object_siblings_and_children(root-&gt;io_first_child);
1883    root-&gt;io_first_child = NULL;
1884    hwloc_free_object_siblings_and_children(root-&gt;misc_first_child);
1885    root-&gt;misc_first_child = NULL;
1886    if (root-&gt;cpuset)
1887      hwloc_bitmap_zero(root-&gt;cpuset);
1888    if (root-&gt;nodeset)
1889      hwloc_bitmap_zero(root-&gt;nodeset);
1890    hwloc_localeswitch_fini();
1891    return -1;
1892  }
1893  int
1894  hwloc_topology_diff_load_xml(const char *xmlpath,
1895  			     hwloc_topology_diff_t *firstdiffp, char **refnamep)
1896  {
1897    struct hwloc__xml_import_state_s state;
1898    struct hwloc_xml_backend_data_s fakedata; &amp;bsol;* only for storing global info during parsing */
1899    hwloc_localeswitch_declare;
1900    const char *local_basename;
1901    int force_nolibxml;
1902    int ret;
1903    state.global = &amp;fakedata;
1904    local_basename = strrchr(xmlpath, &#x27;/&#x27;);
1905    if (local_basename)
1906      local_basename++;
1907    else
1908      local_basename = xmlpath;
1909    fakedata.msgprefix = strdup(local_basename);
1910    hwloc_components_init();
1911    assert(hwloc_nolibxml_callbacks);
1912    hwloc_localeswitch_init();
1913    *firstdiffp = NULL;
1914    force_nolibxml = hwloc_nolibxml_import();
1915  retry:
1916    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
1917      ret = hwloc_nolibxml_callbacks-&gt;import_diff(&amp;state, xmlpath, NULL, 0, firstdiffp, refnamep);
1918    else {
1919      ret = hwloc_libxml_callbacks-&gt;import_diff(&amp;state, xmlpath, NULL, 0, firstdiffp, refnamep);
1920      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
1921        hwloc_libxml_callbacks = NULL;
1922        goto retry;
1923      }
1924    }
1925    hwloc_localeswitch_fini();
1926    hwloc_components_fini();
1927    free(fakedata.msgprefix);
1928    return ret;
1929  }
1930  int
1931  hwloc_topology_diff_load_xmlbuffer(const char *xmlbuffer, int buflen,
1932  				   hwloc_topology_diff_t *firstdiffp, char **refnamep)
1933  {
1934    struct hwloc__xml_import_state_s state;
1935    struct hwloc_xml_backend_data_s fakedata; &amp;bsol;* only for storing global info during parsing */
1936    hwloc_localeswitch_declare;
1937    int force_nolibxml;
1938    int ret;
1939    state.global = &amp;fakedata;
1940    fakedata.msgprefix = strdup(&quot;xmldiffbuffer&quot;);
1941    hwloc_components_init();
1942    assert(hwloc_nolibxml_callbacks);
1943    hwloc_localeswitch_init();
1944    *firstdiffp = NULL;
1945    force_nolibxml = hwloc_nolibxml_import();
1946   retry:
1947    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
1948      ret = hwloc_nolibxml_callbacks-&gt;import_diff(&amp;state, NULL, xmlbuffer, buflen, firstdiffp, refnamep);
1949    else {
1950      ret = hwloc_libxml_callbacks-&gt;import_diff(&amp;state, NULL, xmlbuffer, buflen, firstdiffp, refnamep);
1951      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
1952        hwloc_libxml_callbacks = NULL;
1953        goto retry;
1954      }
1955    }
1956    hwloc_localeswitch_fini();
1957    hwloc_components_fini();
1958    free(fakedata.msgprefix);
1959    return ret;
1960  }
1961  #define HWLOC_XML_CHAR_VALID(c) (((c) &gt;= 32 &amp;&amp; (c) &lt;= 126) || (c) == &#x27;\t&#x27; || (c) == &#x27;\n&#x27; || (c) == &#x27;\r&#x27;)
1962  static int
1963  hwloc__xml_export_check_buffer(const char *buf, size_t length)
1964  {
1965    unsigned i;
1966    for(i=0; i&lt;length; i++)
1967      if (!HWLOC_XML_CHAR_VALID(buf[i]))
1968        return -1;
1969    return 0;
1970  }
1971  static char*
1972  hwloc__xml_export_safestrdup(const char *old)
1973  {
1974    char *new = malloc(strlen(old)+1);
1975    char *dst = new;
1976    const char *src = old;
1977    if (!new)
1978      return NULL;
1979    while (*src) {
1980      if (HWLOC_XML_CHAR_VALID(*src))
1981        *(dst++) = *src;
1982      src++;
1983    }
1984    *dst = &#x27;\0&#x27;;
1985    return new;
1986  }
1987  static void
1988  hwloc__xml_export_object_contents (hwloc__xml_export_state_t state, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
1989  {
1990    char *setstring = NULL, *setstring2 = NULL;
1991    char tmp[255];
1992    int v1export = flags &amp; HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1;
1993    unsigned i,j;
1994    if (v1export &amp;&amp; obj-&gt;type == HWLOC_OBJ_PACKAGE)
1995      state-&gt;new_prop(state, &quot;type&quot;, &quot;Socket&quot;);
1996    else if (v1export &amp;&amp; obj-&gt;type == HWLOC_OBJ_DIE)
1997      state-&gt;new_prop(state, &quot;type&quot;, &quot;Group&quot;);
1998    else if (v1export &amp;&amp; hwloc__obj_type_is_cache(obj-&gt;type))
1999      state-&gt;new_prop(state, &quot;type&quot;, &quot;Cache&quot;);
2000    else
2001      state-&gt;new_prop(state, &quot;type&quot;, hwloc_obj_type_string(obj-&gt;type));
2002    if (obj-&gt;os_index != HWLOC_UNKNOWN_INDEX) {
2003      sprintf(tmp, &quot;%u&quot;, obj-&gt;os_index);
2004      state-&gt;new_prop(state, &quot;os_index&quot;, tmp);
2005    }
2006    if (obj-&gt;cpuset) {
2007      int empty_cpusets = 0;
2008      if (v1export &amp;&amp; obj-&gt;type == HWLOC_OBJ_NUMANODE) {
2009        hwloc_obj_t parent = obj;
2010        while (!hwloc_obj_type_is_normal(parent-&gt;type)) {
2011  	if (parent-&gt;sibling_rank &gt; 0) {
2012  	  empty_cpusets = 1;
2013  	  break;
2014  	}
2015  	parent = parent-&gt;parent;
2016        }
2017      }
2018      if (empty_cpusets) {
2019        state-&gt;new_prop(state, &quot;cpuset&quot;, &quot;0x0&quot;);
2020        state-&gt;new_prop(state, &quot;online_cpuset&quot;, &quot;0x0&quot;);
2021        state-&gt;new_prop(state, &quot;complete_cpuset&quot;, &quot;0x0&quot;);
2022        state-&gt;new_prop(state, &quot;allowed_cpuset&quot;, &quot;0x0&quot;);
2023      } else {
2024        hwloc_bitmap_asprintf(&amp;setstring, obj-&gt;cpuset);
2025        state-&gt;new_prop(state, &quot;cpuset&quot;, setstring);
2026        hwloc_bitmap_asprintf(&amp;setstring2, obj-&gt;complete_cpuset);
2027        state-&gt;new_prop(state, &quot;complete_cpuset&quot;, setstring2);
2028        free(setstring2);
2029        if (v1export)
2030  	state-&gt;new_prop(state, &quot;online_cpuset&quot;, setstring);
2031        free(setstring);
2032        if (v1export) {
2033  	hwloc_bitmap_t allowed_cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
2034  	hwloc_bitmap_and(allowed_cpuset, allowed_cpuset, topology-&gt;allowed_cpuset);
2035  	hwloc_bitmap_asprintf(&amp;setstring, allowed_cpuset);
2036  	state-&gt;new_prop(state, &quot;allowed_cpuset&quot;, setstring);
2037  	free(setstring);
2038  	hwloc_bitmap_free(allowed_cpuset);
2039        } else if (!obj-&gt;parent) {
2040  	hwloc_bitmap_asprintf(&amp;setstring, topology-&gt;allowed_cpuset);
2041  	state-&gt;new_prop(state, &quot;allowed_cpuset&quot;, setstring);
2042  	free(setstring);
2043        }
2044      }
2045      hwloc_bitmap_asprintf(&amp;setstring, obj-&gt;nodeset);
2046      state-&gt;new_prop(state, &quot;nodeset&quot;, setstring);
2047      free(setstring);
2048      hwloc_bitmap_asprintf(&amp;setstring, obj-&gt;complete_nodeset);
2049      state-&gt;new_prop(state, &quot;complete_nodeset&quot;, setstring);
2050      free(setstring);
2051      if (v1export) {
2052        hwloc_bitmap_t allowed_nodeset = hwloc_bitmap_dup(obj-&gt;nodeset);
2053        hwloc_bitmap_and(allowed_nodeset, allowed_nodeset, topology-&gt;allowed_nodeset);
2054        hwloc_bitmap_asprintf(&amp;setstring, allowed_nodeset);
2055        state-&gt;new_prop(state, &quot;allowed_nodeset&quot;, setstring);
2056        free(setstring);
2057        hwloc_bitmap_free(allowed_nodeset);
2058      } else if (!obj-&gt;parent) {
2059        hwloc_bitmap_asprintf(&amp;setstring, topology-&gt;allowed_nodeset);
2060        state-&gt;new_prop(state, &quot;allowed_nodeset&quot;, setstring);
2061        free(setstring);
2062      }
2063    }
2064    if (!v1export) {
2065      sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;gp_index);
2066      state-&gt;new_prop(state, &quot;gp_index&quot;, tmp);
2067    }
2068    if (obj-&gt;name) {
2069      char *name = hwloc__xml_export_safestrdup(obj-&gt;name);
2070      if (name) {
2071        state-&gt;new_prop(state, &quot;name&quot;, name);
2072        free(name);
2073      }
2074    }
2075    if (!v1export &amp;&amp; obj-&gt;subtype) {
2076      char *subtype = hwloc__xml_export_safestrdup(obj-&gt;subtype);
2077      if (subtype) {
2078        state-&gt;new_prop(state, &quot;subtype&quot;, subtype);
2079        free(subtype);
2080      }
2081    }
2082    switch (obj-&gt;type) {
2083    case HWLOC_OBJ_NUMANODE:
2084      if (obj-&gt;attr-&gt;numanode.local_memory) {
2085        sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;attr-&gt;numanode.local_memory);
2086        state-&gt;new_prop(state, &quot;local_memory&quot;, tmp);
2087      }
2088      for(i=0; i&lt;obj-&gt;attr-&gt;numanode.page_types_len; i++) {
2089        struct hwloc__xml_export_state_s childstate;
2090        state-&gt;new_child(state, &amp;childstate, &quot;page_type&quot;);
2091        sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;attr-&gt;numanode.page_types[i].size);
2092        childstate.new_prop(&amp;childstate, &quot;size&quot;, tmp);
2093        sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;attr-&gt;numanode.page_types[i].count);
2094        childstate.new_prop(&amp;childstate, &quot;count&quot;, tmp);
2095        childstate.end_object(&amp;childstate, &quot;page_type&quot;);
2096      }
2097      break;
2098    case HWLOC_OBJ_L1CACHE:
2099    case HWLOC_OBJ_L2CACHE:
2100    case HWLOC_OBJ_L3CACHE:
2101    case HWLOC_OBJ_L4CACHE:
2102    case HWLOC_OBJ_L5CACHE:
2103    case HWLOC_OBJ_L1ICACHE:
2104    case HWLOC_OBJ_L2ICACHE:
2105    case HWLOC_OBJ_L3ICACHE:
2106    case HWLOC_OBJ_MEMCACHE:
2107      sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;attr-&gt;cache.size);
2108      state-&gt;new_prop(state, &quot;cache_size&quot;, tmp);
2109      sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;cache.depth);
2110      state-&gt;new_prop(state, &quot;depth&quot;, tmp);
2111      sprintf(tmp, &quot;%u&quot;, (unsigned) obj-&gt;attr-&gt;cache.linesize);
2112      state-&gt;new_prop(state, &quot;cache_linesize&quot;, tmp);
2113      sprintf(tmp, &quot;%d&quot;, obj-&gt;attr-&gt;cache.associativity);
2114      state-&gt;new_prop(state, &quot;cache_associativity&quot;, tmp);
2115      sprintf(tmp, &quot;%d&quot;, (int) obj-&gt;attr-&gt;cache.type);
2116      state-&gt;new_prop(state, &quot;cache_type&quot;, tmp);
2117      break;
2118    case HWLOC_OBJ_GROUP:
2119      if (v1export) {
2120        sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;group.depth);
2121        state-&gt;new_prop(state, &quot;depth&quot;, tmp);
2122        if (obj-&gt;attr-&gt;group.dont_merge)
2123          state-&gt;new_prop(state, &quot;dont_merge&quot;, &quot;1&quot;);
2124      } else {
2125        sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;group.kind);
2126        state-&gt;new_prop(state, &quot;kind&quot;, tmp);
2127        sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;group.subkind);
2128        state-&gt;new_prop(state, &quot;subkind&quot;, tmp);
2129        if (obj-&gt;attr-&gt;group.dont_merge)
2130          state-&gt;new_prop(state, &quot;dont_merge&quot;, &quot;1&quot;);
2131      }
2132      break;
2133    case HWLOC_OBJ_BRIDGE:
2134      sprintf(tmp, &quot;%d-%d&quot;, (int) obj-&gt;attr-&gt;bridge.upstream_type, (int) obj-&gt;attr-&gt;bridge.downstream_type);
2135      state-&gt;new_prop(state, &quot;bridge_type&quot;, tmp);
2136      sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;bridge.depth);
2137      state-&gt;new_prop(state, &quot;depth&quot;, tmp);
2138      if (obj-&gt;attr-&gt;bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
2139        sprintf(tmp, &quot;%04x:[%02x-%02x]&quot;,
2140  	      (unsigned) obj-&gt;attr-&gt;bridge.downstream.pci.domain,
2141  	      (unsigned) obj-&gt;attr-&gt;bridge.downstream.pci.secondary_bus,
2142  	      (unsigned) obj-&gt;attr-&gt;bridge.downstream.pci.subordinate_bus);
2143        state-&gt;new_prop(state, &quot;bridge_pci&quot;, tmp);
2144      }
2145      if (obj-&gt;attr-&gt;bridge.upstream_type != HWLOC_OBJ_BRIDGE_PCI)
2146        break;
2147    case HWLOC_OBJ_PCI_DEVICE:
2148      sprintf(tmp, &quot;%04x:%02x:%02x.%01x&quot;,
2149  	    (unsigned) obj-&gt;attr-&gt;pcidev.domain,
2150  	    (unsigned) obj-&gt;attr-&gt;pcidev.bus,
2151  	    (unsigned) obj-&gt;attr-&gt;pcidev.dev,
2152  	    (unsigned) obj-&gt;attr-&gt;pcidev.func);
2153      state-&gt;new_prop(state, &quot;pci_busid&quot;, tmp);
2154      sprintf(tmp, &quot;%04x [%04x:%04x] [%04x:%04x] %02x&quot;,
2155  	    (unsigned) obj-&gt;attr-&gt;pcidev.class_id,
2156  	    (unsigned) obj-&gt;attr-&gt;pcidev.vendor_id, (unsigned) obj-&gt;attr-&gt;pcidev.device_id,
2157  	    (unsigned) obj-&gt;attr-&gt;pcidev.subvendor_id, (unsigned) obj-&gt;attr-&gt;pcidev.subdevice_id,
2158  	    (unsigned) obj-&gt;attr-&gt;pcidev.revision);
2159      state-&gt;new_prop(state, &quot;pci_type&quot;, tmp);
2160      sprintf(tmp, &quot;%f&quot;, obj-&gt;attr-&gt;pcidev.linkspeed);
2161      state-&gt;new_prop(state, &quot;pci_link_speed&quot;, tmp);
2162      break;
2163    case HWLOC_OBJ_OS_DEVICE:
2164      sprintf(tmp, &quot;%d&quot;, (int) obj-&gt;attr-&gt;osdev.type);
2165      state-&gt;new_prop(state, &quot;osdev_type&quot;, tmp);
2166      break;
2167    default:
2168      break;
2169    }
2170    for(i=0; i&lt;obj-&gt;infos_count; i++) {
2171      char *name = hwloc__xml_export_safestrdup(obj-&gt;infos[i].name);
2172      char *value = hwloc__xml_export_safestrdup(obj-&gt;infos[i].value);
2173      if (name &amp;&amp; value) {
2174        struct hwloc__xml_export_state_s childstate;
2175        state-&gt;new_child(state, &amp;childstate, &quot;info&quot;);
2176        childstate.new_prop(&amp;childstate, &quot;name&quot;, name);
2177        childstate.new_prop(&amp;childstate, &quot;value&quot;, value);
2178        childstate.end_object(&amp;childstate, &quot;info&quot;);
2179      }
2180      free(name);
2181      free(value);
2182    }
2183    if (v1export &amp;&amp; obj-&gt;subtype) {
2184      char *subtype = hwloc__xml_export_safestrdup(obj-&gt;subtype);
2185      if (subtype) {
2186        struct hwloc__xml_export_state_s childstate;
2187        int is_coproctype = (obj-&gt;type == HWLOC_OBJ_OS_DEVICE &amp;&amp; obj-&gt;attr-&gt;osdev.type == HWLOC_OBJ_OSDEV_COPROC);
2188        state-&gt;new_child(state, &amp;childstate, &quot;info&quot;);
2189        childstate.new_prop(&amp;childstate, &quot;name&quot;, is_coproctype ? &quot;CoProcType&quot; : &quot;Type&quot;);
2190        childstate.new_prop(&amp;childstate, &quot;value&quot;, subtype);
2191        childstate.end_object(&amp;childstate, &quot;info&quot;);
2192        free(subtype);
2193      }
2194    }
2195    if (v1export &amp;&amp; obj-&gt;type == HWLOC_OBJ_DIE) {
2196      struct hwloc__xml_export_state_s childstate;
2197      state-&gt;new_child(state, &amp;childstate, &quot;info&quot;);
2198      childstate.new_prop(&amp;childstate, &quot;name&quot;, &quot;Type&quot;);
2199      childstate.new_prop(&amp;childstate, &quot;value&quot;, &quot;Die&quot;);
2200      childstate.end_object(&amp;childstate, &quot;info&quot;);
2201    }
2202    if (v1export &amp;&amp; !obj-&gt;parent) {
2203      struct hwloc_internal_distances_s *dist;
2204      hwloc_internal_distances_refresh(topology);
2205      for(dist = topology-&gt;first_dist; dist; dist = dist-&gt;next) {
2206        struct hwloc__xml_export_state_s childstate;
2207        unsigned nbobjs = dist-&gt;nbobjs;
2208        unsigned *logical_to_v2array;
2209        int depth;
2210        if (nbobjs != (unsigned) hwloc_get_nbobjs_by_type(topology, dist-&gt;unique_type))
2211  	continue;
2212        if (!(dist-&gt;kind &amp; HWLOC_DISTANCES_KIND_MEANS_LATENCY))
2213  	continue;
2214        if (dist-&gt;kind &amp; HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES)
2215  	continue;
2216        logical_to_v2array = malloc(nbobjs * sizeof(*logical_to_v2array));
2217        if (!logical_to_v2array) {
2218          if (HWLOC_SHOW_ALL_ERRORS())
2219            fprintf(stderr, &quot;hwloc/xml/export/v1: failed to allocated logical_to_v2array\n&quot;);
2220  	continue;
2221        }
2222        for(i=0; i&lt;nbobjs; i++)
2223  	logical_to_v2array[dist-&gt;objs[i]-&gt;logical_index] = i;
2224        if (dist-&gt;unique_type == HWLOC_OBJ_NUMANODE) {
2225  	depth = -1;
2226  	for(i=0; i&lt;nbobjs; i++) {
2227  	  hwloc_obj_t parent = dist-&gt;objs[i]-&gt;parent;
2228  	  while (hwloc__obj_type_is_memory(parent-&gt;type))
2229  	    parent = parent-&gt;parent;
2230  	  if (parent-&gt;depth+1 &gt; depth)
2231  	    depth = parent-&gt;depth+1;
2232  	}
2233        } else {
2234  	int parent_with_memory = 0;
2235  	for(i=0; i&lt;nbobjs; i++) {
2236  	  hwloc_obj_t parent = dist-&gt;objs[i]-&gt;parent;
2237  	  while (parent) {
2238  	    if (parent-&gt;memory_first_child) {
2239  	      parent_with_memory = 1;
2240  	      goto done;
2241  	    }
2242  	    parent = parent-&gt;parent;
2243  	  }
2244  	}
2245        done:
2246  	depth = hwloc_get_type_depth(topology, dist-&gt;unique_type) + parent_with_memory;
2247        }
2248        state-&gt;new_child(state, &amp;childstate, &quot;distances&quot;);
2249        sprintf(tmp, &quot;%u&quot;, nbobjs);
2250        childstate.new_prop(&amp;childstate, &quot;nbobjs&quot;, tmp);
2251        sprintf(tmp, &quot;%d&quot;, depth);
2252        childstate.new_prop(&amp;childstate, &quot;relative_depth&quot;, tmp);
2253        sprintf(tmp, &quot;%f&quot;, 1.f);
2254        childstate.new_prop(&amp;childstate, &quot;latency_base&quot;, tmp);
2255        for(i=0; i&lt;nbobjs; i++) {
2256          for(j=0; j&lt;nbobjs; j++) {
2257  	  unsigned k = logical_to_v2array[i]*nbobjs+logical_to_v2array[j];
2258  	  struct hwloc__xml_export_state_s greatchildstate;
2259  	  childstate.new_child(&amp;childstate, &amp;greatchildstate, &quot;latency&quot;);
2260  	  sprintf(tmp, &quot;%f&quot;, (float) dist-&gt;values[k]);
2261  	  greatchildstate.new_prop(&amp;greatchildstate, &quot;value&quot;, tmp);
2262  	  greatchildstate.end_object(&amp;greatchildstate, &quot;latency&quot;);
2263  	}
2264        }
2265        childstate.end_object(&amp;childstate, &quot;distances&quot;);
2266        free(logical_to_v2array);
2267      }
2268    }
2269    if (obj-&gt;userdata &amp;&amp; topology-&gt;userdata_export_cb)
2270      topology-&gt;userdata_export_cb((void*) state, topology, obj);
2271  }
2272  static void
2273  hwloc__xml_v2export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2274  {
2275    struct hwloc__xml_export_state_s state;
2276    hwloc_obj_t child;
2277    parentstate-&gt;new_child(parentstate, &amp;state, &quot;object&quot;);
2278    hwloc__xml_export_object_contents(&amp;state, topology, obj, flags);
2279    for_each_memory_child(child, obj)
2280      hwloc__xml_v2export_object (&amp;state, topology, child, flags);
2281    for_each_child(child, obj)
2282      hwloc__xml_v2export_object (&amp;state, topology, child, flags);
2283    for_each_io_child(child, obj)
2284      hwloc__xml_v2export_object (&amp;state, topology, child, flags);
2285    for_each_misc_child(child, obj)
2286      hwloc__xml_v2export_object (&amp;state, topology, child, flags);
2287    state.end_object(&amp;state, &quot;object&quot;);
2288  }
2289  static void
2290  hwloc__xml_v1export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags);
2291  static hwloc_obj_t
2292  hwloc__xml_v1export_object_next_numanode(hwloc_obj_t obj, hwloc_obj_t cur)
2293  {
2294    hwloc_obj_t parent;
2295    if (!cur) {
2296      cur = obj-&gt;memory_first_child;
2297      goto find_first;
2298    }
2299    parent = cur;
2300    while (1) {
2301      if (parent-&gt;next_sibling) {
2302        cur = parent-&gt;next_sibling;
2303        break;
2304      }
2305      parent = parent-&gt;parent;
2306      if (parent == obj)
2307        return NULL;
2308    }
2309   find_first:
2310    while (cur-&gt;type != HWLOC_OBJ_NUMANODE)
2311      cur = cur-&gt;memory_first_child;
2312    assert(cur);
2313    return cur;
2314  }
2315  static unsigned
2316  hwloc__xml_v1export_object_list_numanodes(hwloc_obj_t obj, hwloc_obj_t *first_p, hwloc_obj_t **nodes_p)
2317  {
2318    hwloc_obj_t *nodes, cur;
2319    int nr;
2320    if (!obj-&gt;memory_first_child) {
2321      *first_p = NULL;
2322      *nodes_p = NULL;
2323      return 0;
2324    }
2325    nr = hwloc_bitmap_weight(obj-&gt;nodeset);
2326    assert(nr &gt; 0);
2327    nodes = calloc(nr, sizeof(*nodes));
2328    if (!nodes) {
2329      cur = hwloc__xml_v1export_object_next_numanode(obj, NULL);
2330      assert(cur);
2331      *first_p = cur;
2332      *nodes_p = NULL;
2333      return 1;
2334    }
2335    nr = 0;
2336    cur = NULL;
2337    while (1) {
2338      cur = hwloc__xml_v1export_object_next_numanode(obj, cur);
2339      if (!cur)
2340        break;
2341      nodes[nr++] = cur;
2342    }
2343    *first_p = nodes[0];
2344    *nodes_p = nodes;
2345    return nr;
2346  }
2347  static void
2348  hwloc__xml_v1export_object_with_memory(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2349  {
2350    struct hwloc__xml_export_state_s gstate, mstate, ostate, *state = parentstate;
2351    hwloc_obj_t child;
2352    unsigned nr_numanodes;
2353    hwloc_obj_t *numanodes, first_numanode;
2354    unsigned i;
2355    nr_numanodes = hwloc__xml_v1export_object_list_numanodes(obj, &amp;first_numanode, &amp;numanodes);
2356    if (obj-&gt;parent-&gt;arity &gt; 1 &amp;&amp; nr_numanodes &gt; 1 &amp;&amp; parentstate-&gt;global-&gt;v1_memory_group) {
2357      hwloc_obj_t group = parentstate-&gt;global-&gt;v1_memory_group;
2358      parentstate-&gt;new_child(parentstate, &amp;gstate, &quot;object&quot;);
2359      group-&gt;parent = obj-&gt;parent;
2360      group-&gt;cpuset = obj-&gt;cpuset;
2361      group-&gt;complete_cpuset = obj-&gt;complete_cpuset;
2362      group-&gt;nodeset = obj-&gt;nodeset;
2363      group-&gt;complete_nodeset = obj-&gt;complete_nodeset;
2364      hwloc__xml_export_object_contents (&amp;gstate, topology, group, flags);
2365      group-&gt;cpuset = NULL;
2366      group-&gt;complete_cpuset = NULL;
2367      group-&gt;nodeset = NULL;
2368      group-&gt;complete_nodeset = NULL;
2369      state = &amp;gstate;
2370    }
2371    state-&gt;new_child(state, &amp;mstate, &quot;object&quot;);
2372    hwloc__xml_export_object_contents (&amp;mstate, topology, first_numanode, flags);
2373    mstate.new_child(&amp;mstate, &amp;ostate, &quot;object&quot;);
2374    hwloc__xml_export_object_contents (&amp;ostate, topology, obj, flags);
2375    for_each_child(child, obj)
2376      hwloc__xml_v1export_object (&amp;ostate, topology, child, flags);
2377    for_each_io_child(child, obj)
2378      hwloc__xml_v1export_object (&amp;ostate, topology, child, flags);
2379    for_each_misc_child(child, obj)
2380      hwloc__xml_v1export_object (&amp;ostate, topology, child, flags);
2381    ostate.end_object(&amp;ostate, &quot;object&quot;);
2382    mstate.end_object(&amp;mstate, &quot;object&quot;);
2383    for(i=1; i&lt;nr_numanodes; i++)
2384      hwloc__xml_v1export_object (state, topology, numanodes[i], flags);
2385    free(numanodes);
2386    if (state == &amp;gstate) {
2387      gstate.end_object(&amp;gstate, &quot;object&quot;);
2388    }
2389  }
2390  static void
2391  hwloc__xml_v1export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2392  {
2393    struct hwloc__xml_export_state_s state;
2394    hwloc_obj_t child;
2395    parentstate-&gt;new_child(parentstate, &amp;state, &quot;object&quot;);
2396    hwloc__xml_export_object_contents(&amp;state, topology, obj, flags);
2397    for_each_child(child, obj) {
2398      if (!child-&gt;memory_arity) {
2399        hwloc__xml_v1export_object (&amp;state, topology, child, flags);
2400      } else {
2401        hwloc__xml_v1export_object_with_memory(&amp;state, topology, child, flags);
2402      }
2403    }
2404    for_each_io_child(child, obj)
2405      hwloc__xml_v1export_object (&amp;state, topology, child, flags);
2406    for_each_misc_child(child, obj)
2407      hwloc__xml_v1export_object (&amp;state, topology, child, flags);
2408    state.end_object(&amp;state, &quot;object&quot;);
2409  }
2410  #define EXPORT_ARRAY(state, type, nr, values, tagname, format, maxperline) do { \
2411    unsigned _i = 0; \
2412    while (_i&lt;(nr)) { \
2413      char _tmp[255]; &amp;bsol;* enough for (snprintf(format)+space) x maxperline */ \
2414      char _tmp2[16]; \
2415      size_t _len = 0; \
2416      unsigned _j; \
2417      struct hwloc__xml_export_state_s _childstate; \
2418      (state)-&gt;new_child(state, &amp;_childstate, tagname); \
2419      for(_j=0; \
2420  	_i+_j&lt;(nr) &amp;&amp; _j&lt;maxperline; \
2421  	_j++) \
2422        _len += sprintf(_tmp+_len, format &quot; &quot;, (type) (values)[_i+_j]); \
2423      _i += _j; \
2424      sprintf(_tmp2, &quot;%lu&quot;, (unsigned long) _len); \
2425      _childstate.new_prop(&amp;_childstate, &quot;length&quot;, _tmp2); \
2426      _childstate.add_content(&amp;_childstate, _tmp, _len); \
2427      _childstate.end_object(&amp;_childstate, tagname); \
2428    } \
2429  } while (0)
2430  #define EXPORT_TYPE_GPINDEX_ARRAY(state, nr, objs, tagname, maxperline) do { \
2431    unsigned _i = 0; \
2432    while (_i&lt;(nr)) { \
2433      char _tmp[255]; &amp;bsol;* enough for (snprintf(type+index)+space) x maxperline */ \
2434      char _tmp2[16]; \
2435      size_t _len = 0; \
2436      unsigned _j; \
2437      struct hwloc__xml_export_state_s _childstate; \
2438      (state)-&gt;new_child(state, &amp;_childstate, tagname); \
2439      for(_j=0; \
2440  	_i+_j&lt;(nr) &amp;&amp; _j&lt;maxperline; \
2441  	_j++) \
2442        _len += sprintf(_tmp+_len, &quot;%s:%llu &quot;, hwloc_obj_type_string((objs)[_i+_j]-&gt;type), (unsigned long long) (objs)[_i+_j]-&gt;gp_index); \
2443      _i += _j; \
2444      sprintf(_tmp2, &quot;%lu&quot;, (unsigned long) _len); \
2445      _childstate.new_prop(&amp;_childstate, &quot;length&quot;, _tmp2); \
2446      _childstate.add_content(&amp;_childstate, _tmp, _len); \
2447      _childstate.end_object(&amp;_childstate, tagname); \
2448    } \
2449  } while (0)
2450  static void
2451  hwloc___xml_v2export_distances(hwloc__xml_export_state_t parentstate, struct hwloc_internal_distances_s *dist)
2452  {
2453    char tmp[255];
2454    unsigned nbobjs = dist-&gt;nbobjs;
2455    struct hwloc__xml_export_state_s state;
2456    if (dist-&gt;different_types) {
2457      parentstate-&gt;new_child(parentstate, &amp;state, &quot;distances2hetero&quot;);
2458    } else {
2459      parentstate-&gt;new_child(parentstate, &amp;state, &quot;distances2&quot;);
2460      state.new_prop(&amp;state, &quot;type&quot;, hwloc_obj_type_string(dist-&gt;unique_type));
2461    }
2462    sprintf(tmp, &quot;%u&quot;, nbobjs);
2463    state.new_prop(&amp;state, &quot;nbobjs&quot;, tmp);
2464    sprintf(tmp, &quot;%lu&quot;, dist-&gt;kind);
2465    state.new_prop(&amp;state, &quot;kind&quot;, tmp);
2466    if (dist-&gt;name)
2467      state.new_prop(&amp;state, &quot;name&quot;, dist-&gt;name);
2468    if (!dist-&gt;different_types) {
2469      state.new_prop(&amp;state, &quot;indexing&quot;,
2470  		   HWLOC_DIST_TYPE_USE_OS_INDEX(dist-&gt;unique_type) ? &quot;os&quot; : &quot;gp&quot;);
2471    }
2472    if (dist-&gt;different_types) {
2473      EXPORT_TYPE_GPINDEX_ARRAY(&amp;state, nbobjs, dist-&gt;objs, &quot;indexes&quot;, 10);
2474    } else {
2475      EXPORT_ARRAY(&amp;state, unsigned long long, nbobjs, dist-&gt;indexes, &quot;indexes&quot;, &quot;%llu&quot;, 10);
2476    }
2477    EXPORT_ARRAY(&amp;state, unsigned long long, nbobjs*nbobjs, dist-&gt;values, &quot;u64values&quot;, &quot;%llu&quot;, 10);
2478    state.end_object(&amp;state, dist-&gt;different_types ? &quot;distances2hetero&quot; : &quot;distances2&quot;);
2479  }
2480  static void
2481  hwloc__xml_v2export_distances(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology)
2482  {
2483    struct hwloc_internal_distances_s *dist;
2484    for(dist = topology-&gt;first_dist; dist; dist = dist-&gt;next)
2485      if (!dist-&gt;different_types)
2486        hwloc___xml_v2export_distances(parentstate, dist);
2487    for(dist = topology-&gt;first_dist; dist; dist = dist-&gt;next)
2488      if (dist-&gt;different_types)
2489        hwloc___xml_v2export_distances(parentstate, dist);
2490  }
2491  static void
2492  hwloc__xml_v2export_support(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology)
2493  {
2494    struct hwloc__xml_export_state_s state;
2495    char tmp[11];
2496  #ifdef HWLOC_DEBUG
2497    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_support) == 4*sizeof(void*));
2498    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_discovery_support) == 6);
2499    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_cpubind_support) == 11);
2500    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_membind_support) == 15);
2501    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_misc_support) == 1);
2502  #endif
2503  #define DO(_cat,_name) do {                                     \
2504      if (topology-&gt;support._cat-&gt;_name) {                        \
2505        parentstate-&gt;new_child(parentstate, &amp;state, &quot;support&quot;);   \
2506        state.new_prop(&amp;state, &quot;name&quot;, #_cat &quot;.&quot; #_name);         \
2507        if (topology-&gt;support._cat-&gt;_name != 1) {                 \
2508          sprintf(tmp, &quot;%u&quot;, topology-&gt;support._cat-&gt;_name); \
2509          state.new_prop(&amp;state, &quot;value&quot;, tmp);                   \
2510        }                                                         \
2511        state.end_object(&amp;state, &quot;support&quot;);                      \
2512      }                                                           \
2513    } while (0)
2514    DO(discovery,pu);
2515    DO(discovery,numa);
2516    DO(discovery,numa_memory);
2517    DO(discovery,disallowed_pu);
2518    DO(discovery,disallowed_numa);
2519    DO(discovery,cpukind_efficiency);
2520    DO(cpubind,set_thisproc_cpubind);
2521    DO(cpubind,get_thisproc_cpubind);
2522    DO(cpubind,set_proc_cpubind);
2523    DO(cpubind,get_proc_cpubind);
2524    DO(cpubind,set_thisthread_cpubind);
2525    DO(cpubind,get_thisthread_cpubind);
2526    DO(cpubind,set_thread_cpubind);
2527    DO(cpubind,get_thread_cpubind);
2528    DO(cpubind,get_thisproc_last_cpu_location);
2529    DO(cpubind,get_proc_last_cpu_location);
2530    DO(cpubind,get_thisthread_last_cpu_location);
2531    DO(membind,set_thisproc_membind);
2532    DO(membind,get_thisproc_membind);
2533    DO(membind,set_proc_membind);
2534    DO(membind,get_proc_membind);
2535    DO(membind,set_thisthread_membind);
2536    DO(membind,get_thisthread_membind);
2537    DO(membind,set_area_membind);
2538    DO(membind,get_area_membind);
2539    DO(membind,alloc_membind);
2540    DO(membind,firsttouch_membind);
2541    DO(membind,bind_membind);
2542    DO(membind,interleave_membind);
2543    DO(membind,nexttouch_membind);
2544    DO(membind,migrate_membind);
2545    DO(membind,get_area_memlocation);
2546    parentstate-&gt;new_child(parentstate, &amp;state, &quot;support&quot;);
2547    state.new_prop(&amp;state, &quot;name&quot;, &quot;custom.exported_support&quot;);
2548    state.end_object(&amp;state, &quot;support&quot;);
2549  #undef DO
2550  }
2551  static void
2552  hwloc__xml_export_memattr_target(hwloc__xml_export_state_t state,
2553                                   struct hwloc_internal_memattr_s *imattr,
2554                                   struct hwloc_internal_memattr_target_s *imtg)
2555  {
2556    struct hwloc__xml_export_state_s vstate;
2557    char tmp[255];
2558    if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
2559      unsigned k;
2560      for(k=0; k&lt;imtg-&gt;nr_initiators; k++) {
2561        struct hwloc_internal_memattr_initiator_s *imi = &amp;imtg-&gt;initiators[k];
2562        state-&gt;new_child(state, &amp;vstate, &quot;memattr_value&quot;);
2563        vstate.new_prop(&amp;vstate, &quot;target_obj_type&quot;, hwloc_obj_type_string(imtg-&gt;type));
2564        snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imtg-&gt;gp_index);
2565        vstate.new_prop(&amp;vstate, &quot;target_obj_gp_index&quot;, tmp);
2566        snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imi-&gt;value);
2567        vstate.new_prop(&amp;vstate, &quot;value&quot;, tmp);
2568        switch (imi-&gt;initiator.type) {
2569        case HWLOC_LOCATION_TYPE_OBJECT:
2570          snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imi-&gt;initiator.location.object.gp_index);
2571          vstate.new_prop(&amp;vstate, &quot;initiator_obj_gp_index&quot;, tmp);
2572          vstate.new_prop(&amp;vstate, &quot;initiator_obj_type&quot;, hwloc_obj_type_string(imi-&gt;initiator.location.object.type));
2573          break;
2574        case HWLOC_LOCATION_TYPE_CPUSET: {
2575          char *setstring;
2576          hwloc_bitmap_asprintf(&amp;setstring, imi-&gt;initiator.location.cpuset);
2577          if (setstring)
2578            vstate.new_prop(&amp;vstate, &quot;initiator_cpuset&quot;, setstring);
2579          free(setstring);
2580          break;
2581        }
2582        default:
2583          assert(0);
2584        }
2585        vstate.end_object(&amp;vstate, &quot;memattr_value&quot;);
2586      }
2587    } else {
2588      state-&gt;new_child(state, &amp;vstate, &quot;memattr_value&quot;);
2589      vstate.new_prop(&amp;vstate, &quot;target_obj_type&quot;, hwloc_obj_type_string(imtg-&gt;type));
2590      snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imtg-&gt;gp_index);
2591      vstate.new_prop(&amp;vstate, &quot;target_obj_gp_index&quot;, tmp);
2592      snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imtg-&gt;noinitiator_value);
2593      vstate.new_prop(&amp;vstate, &quot;value&quot;, tmp);
2594      vstate.end_object(&amp;vstate, &quot;memattr_value&quot;);
2595    }
2596  }
2597  static void
2598  hwloc__xml_export_memattrs(hwloc__xml_export_state_t state, hwloc_topology_t topology)
2599  {
2600    unsigned id;
2601    for(id=0; id&lt;topology-&gt;nr_memattrs; id++) {
2602      struct hwloc_internal_memattr_s *imattr;
2603      struct hwloc__xml_export_state_s mstate;
2604      char tmp[255];
2605      unsigned j;
2606      if (id == HWLOC_MEMATTR_ID_CAPACITY || id == HWLOC_MEMATTR_ID_LOCALITY)
2607        continue;
2608      imattr = &amp;topology-&gt;memattrs[id];
2609      if (id &lt; HWLOC_MEMATTR_ID_MAX &amp;&amp; !imattr-&gt;nr_targets)
2610        continue;
2611      state-&gt;new_child(state, &amp;mstate, &quot;memattr&quot;);
2612      mstate.new_prop(&amp;mstate, &quot;name&quot;, imattr-&gt;name);
2613      snprintf(tmp, sizeof(tmp), &quot;%lu&quot;, imattr-&gt;flags);
2614      mstate.new_prop(&amp;mstate, &quot;flags&quot;, tmp);
2615      for(j=0; j&lt;imattr-&gt;nr_targets; j++)
2616        hwloc__xml_export_memattr_target(&amp;mstate, imattr, &amp;imattr-&gt;targets[j]);
2617      mstate.end_object(&amp;mstate, &quot;memattr&quot;);
2618    }
2619  }
2620  static void
2621  hwloc__xml_export_cpukinds(hwloc__xml_export_state_t state, hwloc_topology_t topology)
2622  {
2623    unsigned i;
2624    for(i=0; i&lt;topology-&gt;nr_cpukinds; i++) {
2625      struct hwloc_internal_cpukind_s *kind = &amp;topology-&gt;cpukinds[i];
2626      struct hwloc__xml_export_state_s cstate;
2627      char *setstring;
2628      unsigned j;
2629      state-&gt;new_child(state, &amp;cstate, &quot;cpukind&quot;);
2630      hwloc_bitmap_asprintf(&amp;setstring, kind-&gt;cpuset);
2631      cstate.new_prop(&amp;cstate, &quot;cpuset&quot;, setstring);
2632      free(setstring);
2633      if (kind-&gt;forced_efficiency != HWLOC_CPUKIND_EFFICIENCY_UNKNOWN) {
2634        char tmp[11];
2635        snprintf(tmp, sizeof(tmp), &quot;%d&quot;, kind-&gt;forced_efficiency);
2636        cstate.new_prop(&amp;cstate, &quot;forced_efficiency&quot;, tmp);
2637      }
2638      for(j=0; j&lt;kind-&gt;nr_infos; j++) {
2639        char *name = hwloc__xml_export_safestrdup(kind-&gt;infos[j].name);
2640        char *value = hwloc__xml_export_safestrdup(kind-&gt;infos[j].value);
2641        struct hwloc__xml_export_state_s istate;
2642        cstate.new_child(&amp;cstate, &amp;istate, &quot;info&quot;);
2643        istate.new_prop(&amp;istate, &quot;name&quot;, name);
2644        istate.new_prop(&amp;istate, &quot;value&quot;, value);
2645        istate.end_object(&amp;istate, &quot;info&quot;);
2646        free(name);
2647        free(value);
2648      }
2649      cstate.end_object(&amp;cstate, &quot;cpukind&quot;);
2650    }
2651  }
2652  void
2653  hwloc__xml_export_topology(hwloc__xml_export_state_t state, hwloc_topology_t topology, unsigned long flags)
2654  {
2655    char *env;
2656    hwloc_obj_t root = hwloc_get_root_obj(topology);
2657    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2658      hwloc_obj_t *numanodes, first_numanode;
2659      unsigned nr_numanodes;
2660      nr_numanodes = hwloc__xml_v1export_object_list_numanodes(root, &amp;first_numanode, &amp;numanodes);
2661      if (nr_numanodes) {
2662        struct hwloc__xml_export_state_s rstate, mstate;
2663        hwloc_obj_t child;
2664        unsigned i;
2665        state-&gt;new_child(state, &amp;rstate, &quot;object&quot;);
2666        hwloc__xml_export_object_contents (&amp;rstate, topology, root, flags);
2667        rstate.new_child(&amp;rstate, &amp;mstate, &quot;object&quot;);
2668        hwloc__xml_export_object_contents (&amp;mstate, topology, first_numanode, flags);
2669        for_each_child(child, root)
2670  	hwloc__xml_v1export_object (&amp;mstate, topology, child, flags);
2671        for_each_io_child(child, root)
2672  	hwloc__xml_v1export_object (&amp;mstate, topology, child, flags);
2673        for_each_misc_child(child, root)
2674  	hwloc__xml_v1export_object (&amp;mstate, topology, child, flags);
2675        mstate.end_object(&amp;mstate, &quot;object&quot;);
2676        for(i=1; i&lt;nr_numanodes; i++)
2677  	hwloc__xml_v1export_object (&amp;rstate, topology, numanodes[i], flags);
2678        rstate.end_object(&amp;rstate, &quot;object&quot;);
2679      } else {
2680        hwloc__xml_v1export_object(state, topology, root, flags);
2681      }
2682      free(numanodes);
2683    } else {
2684      hwloc__xml_v2export_object (state, topology, root, flags);
2685      hwloc__xml_v2export_distances (state, topology);
2686      env = getenv(&quot;HWLOC_XML_EXPORT_SUPPORT&quot;);
2687      if (!env || atoi(env))
2688        hwloc__xml_v2export_support(state, topology);
2689      hwloc__xml_export_memattrs(state, topology);
2690      hwloc__xml_export_cpukinds(state, topology);
2691    }
2692  }
2693  void
2694  hwloc__xml_export_diff(hwloc__xml_export_state_t parentstate, hwloc_topology_diff_t diff)
2695  {
2696    while (diff) {
2697      struct hwloc__xml_export_state_s state;
2698      char tmp[255];
2699      parentstate-&gt;new_child(parentstate, &amp;state, &quot;diff&quot;);
2700      sprintf(tmp, &quot;%d&quot;, (int) diff-&gt;generic.type);
2701      state.new_prop(&amp;state, &quot;type&quot;, tmp);
2702      switch (diff-&gt;generic.type) {
2703      case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR:
2704        sprintf(tmp, &quot;%d&quot;, diff-&gt;obj_attr.obj_depth);
2705        state.new_prop(&amp;state, &quot;obj_depth&quot;, tmp);
2706        sprintf(tmp, &quot;%u&quot;, diff-&gt;obj_attr.obj_index);
2707        state.new_prop(&amp;state, &quot;obj_index&quot;, tmp);
2708        sprintf(tmp, &quot;%d&quot;, (int) diff-&gt;obj_attr.diff.generic.type);
2709        state.new_prop(&amp;state, &quot;obj_attr_type&quot;, tmp);
2710        switch (diff-&gt;obj_attr.diff.generic.type) {
2711        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
2712  	sprintf(tmp, &quot;%llu&quot;, (unsigned long long) diff-&gt;obj_attr.diff.uint64.index);
2713  	state.new_prop(&amp;state, &quot;obj_attr_index&quot;, tmp);
2714  	sprintf(tmp, &quot;%llu&quot;, (unsigned long long) diff-&gt;obj_attr.diff.uint64.oldvalue);
2715  	state.new_prop(&amp;state, &quot;obj_attr_oldvalue&quot;, tmp);
2716  	sprintf(tmp, &quot;%llu&quot;, (unsigned long long) diff-&gt;obj_attr.diff.uint64.newvalue);
2717  	state.new_prop(&amp;state, &quot;obj_attr_newvalue&quot;, tmp);
2718  	break;
2719        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
2720        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
2721  	if (diff-&gt;obj_attr.diff.string.name)
2722  	  state.new_prop(&amp;state, &quot;obj_attr_name&quot;, diff-&gt;obj_attr.diff.string.name);
2723  	state.new_prop(&amp;state, &quot;obj_attr_oldvalue&quot;, diff-&gt;obj_attr.diff.string.oldvalue);
2724  	state.new_prop(&amp;state, &quot;obj_attr_newvalue&quot;, diff-&gt;obj_attr.diff.string.newvalue);
2725  	break;
2726        }
2727        break;
2728      default:
2729        assert(0);
2730      }
2731      state.end_object(&amp;state, &quot;diff&quot;);
2732      diff = diff-&gt;generic.next;
2733    }
2734  }
2735  int hwloc_topology_export_xml(hwloc_topology_t topology, const char *filename, unsigned long flags)
2736  {
2737    hwloc_localeswitch_declare;
2738    struct hwloc__xml_export_data_s edata;
2739    int force_nolibxml;
2740    int ret;
2741    if (!topology-&gt;is_loaded) {
2742      errno = EINVAL;
2743      return -1;
2744    }
2745    assert(hwloc_nolibxml_callbacks); &amp;bsol;* the core called components_init() for the topology */
2746    if (flags &amp; ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2747      errno = EINVAL;
2748      return -1;
2749    }
2750    hwloc_internal_distances_refresh(topology);
2751    hwloc_localeswitch_init();
2752    edata.v1_memory_group = NULL;
2753    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1)
2754      edata.v1_memory_group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
2755    force_nolibxml = hwloc_nolibxml_export();
2756  retry:
2757    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2758      ret = hwloc_nolibxml_callbacks-&gt;export_file(topology, &amp;edata, filename, flags);
2759    else {
2760      ret = hwloc_libxml_callbacks-&gt;export_file(topology, &amp;edata, filename, flags);
2761      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
2762        hwloc_libxml_callbacks = NULL;
2763        goto retry;
2764      }
2765    }
2766    if (edata.v1_memory_group)
2767      hwloc_free_unlinked_object(edata.v1_memory_group);
2768    hwloc_localeswitch_fini();
2769    return ret;
2770  }
2771  int hwloc_topology_export_xmlbuffer(hwloc_topology_t topology, char **xmlbuffer, int *buflen, unsigned long flags)
2772  {
2773    hwloc_localeswitch_declare;
2774    struct hwloc__xml_export_data_s edata;
2775    int force_nolibxml;
2776    int ret;
2777    if (!topology-&gt;is_loaded) {
2778      errno = EINVAL;
2779      return -1;
2780    }
2781    assert(hwloc_nolibxml_callbacks); &amp;bsol;* the core called components_init() for the topology */
2782    if (flags &amp; ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2783      errno = EINVAL;
2784      return -1;
2785    }
2786    hwloc_internal_distances_refresh(topology);
2787    hwloc_localeswitch_init();
2788    edata.v1_memory_group = NULL;
2789    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1)
2790      edata.v1_memory_group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
2791    force_nolibxml = hwloc_nolibxml_export();
2792  retry:
2793    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2794      ret = hwloc_nolibxml_callbacks-&gt;export_buffer(topology, &amp;edata, xmlbuffer, buflen, flags);
2795    else {
2796      ret = hwloc_libxml_callbacks-&gt;export_buffer(topology, &amp;edata, xmlbuffer, buflen, flags);
2797      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
2798        hwloc_libxml_callbacks = NULL;
2799        goto retry;
2800      }
2801    }
2802    if (edata.v1_memory_group)
2803      hwloc_free_unlinked_object(edata.v1_memory_group);
2804    hwloc_localeswitch_fini();
2805    return ret;
2806  }
2807  int
2808  hwloc_topology_diff_export_xml(hwloc_topology_diff_t diff, const char *refname,
2809  			       const char *filename)
2810  {
2811    hwloc_localeswitch_declare;
2812    hwloc_topology_diff_t tmpdiff;
2813    int force_nolibxml;
2814    int ret;
2815    tmpdiff = diff;
2816    while (tmpdiff) {
2817      if (tmpdiff-&gt;generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
2818        errno = EINVAL;
2819        return -1;
2820      }
2821      tmpdiff = tmpdiff-&gt;generic.next;
2822    }
2823    hwloc_components_init();
2824    assert(hwloc_nolibxml_callbacks);
2825    hwloc_localeswitch_init();
2826    force_nolibxml = hwloc_nolibxml_export();
2827  retry:
2828    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2829      ret = hwloc_nolibxml_callbacks-&gt;export_diff_file(diff, refname, filename);
2830    else {
2831      ret = hwloc_libxml_callbacks-&gt;export_diff_file(diff, refname, filename);
2832      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
2833        hwloc_libxml_callbacks = NULL;
2834        goto retry;
2835      }
2836    }
2837    hwloc_localeswitch_fini();
2838    hwloc_components_fini();
2839    return ret;
2840  }
2841  int
2842  hwloc_topology_diff_export_xmlbuffer(hwloc_topology_diff_t diff, const char *refname,
2843  				     char **xmlbuffer, int *buflen)
2844  {
2845    hwloc_localeswitch_declare;
2846    hwloc_topology_diff_t tmpdiff;
2847    int force_nolibxml;
2848    int ret;
2849    tmpdiff = diff;
2850    while (tmpdiff) {
2851      if (tmpdiff-&gt;generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
2852        errno = EINVAL;
2853        return -1;
2854      }
2855      tmpdiff = tmpdiff-&gt;generic.next;
2856    }
2857    hwloc_components_init();
2858    assert(hwloc_nolibxml_callbacks);
2859    hwloc_localeswitch_init();
2860    force_nolibxml = hwloc_nolibxml_export();
2861  retry:
2862    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2863      ret = hwloc_nolibxml_callbacks-&gt;export_diff_buffer(diff, refname, xmlbuffer, buflen);
2864    else {
2865      ret = hwloc_libxml_callbacks-&gt;export_diff_buffer(diff, refname, xmlbuffer, buflen);
2866      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
2867        hwloc_libxml_callbacks = NULL;
2868        goto retry;
2869      }
2870    }
2871    hwloc_localeswitch_fini();
2872    hwloc_components_fini();
2873    return ret;
2874  }
2875  void hwloc_free_xmlbuffer(hwloc_topology_t topology __hwloc_attribute_unused, char *xmlbuffer)
2876  {
2877    int force_nolibxml;
2878    assert(hwloc_nolibxml_callbacks); &amp;bsol;* the core called components_init() for the topology */
2879    force_nolibxml = hwloc_nolibxml_export();
2880    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2881      hwloc_nolibxml_callbacks-&gt;free_buffer(xmlbuffer);
2882    else
2883      hwloc_libxml_callbacks-&gt;free_buffer(xmlbuffer);
2884  }
2885  void
2886  hwloc_topology_set_userdata_export_callback(hwloc_topology_t topology,
2887  					    void (*export)(void *reserved, struct hwloc_topology *topology, struct hwloc_obj *obj))
2888  {
2889    topology-&gt;userdata_export_cb = export;
2890  }
2891  static void
2892  hwloc__export_obj_userdata(hwloc__xml_export_state_t parentstate, int encoded,
2893  			   const char *name, size_t length, const void *buffer, size_t encoded_length)
2894  {
2895    struct hwloc__xml_export_state_s state;
2896    char tmp[255];
2897    parentstate-&gt;new_child(parentstate, &amp;state, &quot;userdata&quot;);
2898    if (name)
2899      state.new_prop(&amp;state, &quot;name&quot;, name);
2900    sprintf(tmp, &quot;%lu&quot;, (unsigned long) length);
2901    state.new_prop(&amp;state, &quot;length&quot;, tmp);
2902    if (encoded)
2903      state.new_prop(&amp;state, &quot;encoding&quot;, &quot;base64&quot;);
2904    if (encoded_length)
2905      state.add_content(&amp;state, buffer, encoded ? encoded_length : length);
2906    state.end_object(&amp;state, &quot;userdata&quot;);
2907  }
2908  int
2909  hwloc_export_obj_userdata(void *reserved,
2910  			  struct hwloc_topology *topology, struct hwloc_obj *obj __hwloc_attribute_unused,
2911  			  const char *name, const void *buffer, size_t length)
2912  {
2913    hwloc__xml_export_state_t state = reserved;
2914    if (!buffer) {
2915      errno = EINVAL;
2916      return -1;
2917    }
2918    if ((name &amp;&amp; hwloc__xml_export_check_buffer(name, strlen(name)) &lt; 0)
2919        || hwloc__xml_export_check_buffer(buffer, length) &lt; 0) {
2920      errno = EINVAL;
2921      return -1;
2922    }
2923    if (topology-&gt;userdata_not_decoded) {
2924      int encoded;
2925      size_t encoded_length;
2926      const char *realname;
2927      assert(name);
2928      if (!strncmp(name, &quot;base64&quot;, 6)) {
2929        encoded = 1;
2930        encoded_length = BASE64_ENCODED_LENGTH(length);
2931      } else {
2932        assert(!strncmp(name, &quot;normal&quot;, 6));
2933        encoded = 0;
2934        encoded_length = length;
2935      }
2936      if (name[6] == &#x27;:&#x27;)
2937        realname = name+7;
2938      else {
2939        assert(!strcmp(name+6, &quot;-anon&quot;));
2940        realname = NULL;
2941      }
2942      hwloc__export_obj_userdata(state, encoded, realname, length, buffer, encoded_length);
2943    } else
2944      hwloc__export_obj_userdata(state, 0, name, length, buffer, length);
2945    return 0;
2946  }
2947  int
2948  hwloc_export_obj_userdata_base64(void *reserved,
2949  				 struct hwloc_topology *topology __hwloc_attribute_unused, struct hwloc_obj *obj __hwloc_attribute_unused,
2950  				 const char *name, const void *buffer, size_t length)
2951  {
2952    hwloc__xml_export_state_t state = reserved;
2953    size_t encoded_length;
2954    char *encoded_buffer;
2955    int ret __hwloc_attribute_unused;
2956    if (!buffer) {
2957      errno = EINVAL;
2958      return -1;
2959    }
2960    assert(!topology-&gt;userdata_not_decoded);
2961    if (name &amp;&amp; hwloc__xml_export_check_buffer(name, strlen(name)) &lt; 0) {
2962      errno = EINVAL;
2963      return -1;
2964    }
2965    encoded_length = BASE64_ENCODED_LENGTH(length);
2966    encoded_buffer = malloc(encoded_length+1);
2967    if (!encoded_buffer) {
2968      errno = ENOMEM;
2969      return -1;
2970    }
2971    ret = hwloc_encode_to_base64(buffer, length, encoded_buffer, encoded_length+1);
2972    assert(ret == (int) encoded_length);
2973    hwloc__export_obj_userdata(state, 1, name, length, encoded_buffer, encoded_length);
2974    free(encoded_buffer);
2975    return 0;
2976  }
2977  void
2978  hwloc_topology_set_userdata_import_callback(hwloc_topology_t topology,
2979  					    void (*import)(struct hwloc_topology *topology, struct hwloc_obj *obj, const char *name, const void *buffer, size_t length))
2980  {
2981    topology-&gt;userdata_import_cb = import;
2982  }
2983  static void
2984  hwloc_xml_backend_disable(struct hwloc_backend *backend)
2985  {
2986    struct hwloc_xml_backend_data_s *data = backend-&gt;private_data;
2987    data-&gt;backend_exit(data);
2988    free(data-&gt;msgprefix);
2989    free(data);
2990  }
2991  static struct hwloc_backend *
2992  hwloc_xml_component_instantiate(struct hwloc_topology *topology,
2993  				struct hwloc_disc_component *component,
2994  				unsigned excluded_phases __hwloc_attribute_unused,
2995  				const void *_data1,
2996  				const void *_data2,
2997  				const void *_data3)
2998  {
2999    struct hwloc_xml_backend_data_s *data;
3000    struct hwloc_backend *backend;
3001    const char *env;
3002    int force_nolibxml;
3003    const char * xmlpath = (const char *) _data1;
3004    const char * xmlbuffer = (const char *) _data2;
3005    int xmlbuflen = (int)(uintptr_t) _data3;
3006    const char *local_basename;
3007    int err;
3008    assert(hwloc_nolibxml_callbacks); &amp;bsol;* the core called components_init() for the component&#x27;s topology */
3009    if (!xmlpath &amp;&amp; !xmlbuffer) {
3010      env = getenv(&quot;HWLOC_XMLFILE&quot;);
3011      if (env) {
3012        xmlpath = env;
3013      } else {
3014        errno = EINVAL;
3015        goto out;
3016      }
3017    }
3018    backend = hwloc_backend_alloc(topology, component);
3019    if (!backend)
3020      goto out;
3021    data = malloc(sizeof(*data));
3022    if (!data) {
3023      errno = ENOMEM;
3024      goto out_with_backend;
3025    }
3026    backend-&gt;private_data = data;
3027    backend-&gt;discover = hwloc_look_xml;
3028    backend-&gt;disable = hwloc_xml_backend_disable;
3029    backend-&gt;is_thissystem = 0;
3030    if (xmlpath) {
3031      local_basename = strrchr(xmlpath, &#x27;/&#x27;);
3032      if (local_basename)
3033        local_basename++;
3034      else
3035        local_basename = xmlpath;
3036    } else {
3037      local_basename = &quot;xmlbuffer&quot;;
3038    }
3039    data-&gt;msgprefix = strdup(local_basename);
3040    force_nolibxml = hwloc_nolibxml_import();
3041  retry:
3042    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
3043      err = hwloc_nolibxml_callbacks-&gt;backend_init(data, xmlpath, xmlbuffer, xmlbuflen);
3044    else {
3045      err = hwloc_libxml_callbacks-&gt;backend_init(data, xmlpath, xmlbuffer, xmlbuflen);
3046      if (err &lt; 0 &amp;&amp; errno == ENOSYS) {
3047        hwloc_libxml_callbacks = NULL;
3048        goto retry;
3049      }
3050    }
3051    if (err &lt; 0)
3052      goto out_with_data;
3053    return backend;
3054   out_with_data:
3055    free(data-&gt;msgprefix);
3056    free(data);
3057   out_with_backend:
3058    free(backend);
3059   out:
3060    return NULL;
3061  }
3062  static struct hwloc_disc_component hwloc_xml_disc_component = {
3063    &quot;xml&quot;,
3064    HWLOC_DISC_PHASE_GLOBAL,
3065    ~0,
3066    hwloc_xml_component_instantiate,
3067    30,
3068    1,
3069    NULL
3070  };
3071  const struct hwloc_component hwloc_xml_component = {
3072    HWLOC_COMPONENT_ABI,
3073    NULL, NULL,
3074    HWLOC_COMPONENT_TYPE_DISC,
3075    0,
3076    &amp;hwloc_xml_disc_component
3077  };
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-xml.c</h3>
            <pre><code>1  #include &quot;private/autogen/config.h&quot;
2  #include &quot;hwloc.h&quot;
3  #include &quot;private/xml.h&quot;
4  #include &quot;private/private.h&quot;
5  #include &quot;private/misc.h&quot;
6  #include &quot;private/debug.h&quot;
7  #include &lt;math.h&gt;
8  int
9  hwloc__xml_verbose(void)
10  {
11    static int checked = 0;
12    static int verbose = 0;
13    if (!checked) {
14      const char *env = getenv(&quot;HWLOC_XML_VERBOSE&quot;);
15      if (env)
16        verbose = atoi(env);
17      checked = 1;
18    }
19    return verbose;
20  }
21  static int
22  hwloc_nolibxml_import(void)
23  {
24    static int checked = 0;
25    static int nolibxml = 0;
26    if (!checked) {
27      const char *env = getenv(&quot;HWLOC_LIBXML&quot;);
28      if (env) {
29        nolibxml = !atoi(env);
30      } else {
31        env = getenv(&quot;HWLOC_LIBXML_IMPORT&quot;);
32        if (env)
33  	nolibxml = !atoi(env);
34      }
35      checked = 1;
36    }
37    return nolibxml;
38  }
39  static int
40  hwloc_nolibxml_export(void)
41  {
42    static int checked = 0;
43    static int nolibxml = 0;
44    if (!checked) {
45      const char *env = getenv(&quot;HWLOC_LIBXML&quot;);
46      if (env) {
47        nolibxml = !atoi(env);
48      } else {
49        env = getenv(&quot;HWLOC_LIBXML_EXPORT&quot;);
50        if (env)
51  	nolibxml = !atoi(env);
52      }
53      checked = 1;
54    }
55    return nolibxml;
56  }
57  #define BASE64_ENCODED_LENGTH(length) (4*(((length)+2)/3))
58  static struct hwloc_xml_callbacks *hwloc_nolibxml_callbacks = NULL, *hwloc_libxml_callbacks = NULL;
59  void
60  hwloc_xml_callbacks_register(struct hwloc_xml_component *comp)
61  {
62    if (!hwloc_nolibxml_callbacks)
63      hwloc_nolibxml_callbacks = comp-&gt;nolibxml_callbacks;
64    if (!hwloc_libxml_callbacks)
65      hwloc_libxml_callbacks = comp-&gt;libxml_callbacks;
66  }
67  void
68  hwloc_xml_callbacks_reset(void)
69  {
70    hwloc_nolibxml_callbacks = NULL;
71    hwloc_libxml_callbacks = NULL;
72  }
73  #define _HWLOC_OBJ_CACHE_OLD (HWLOC_OBJ_TYPE_MAX+1) &amp;bsol;* temporarily used when importing pre-v2.0 attribute-less cache types */
74  #define _HWLOC_OBJ_FUTURE    (HWLOC_OBJ_TYPE_MAX+2) &amp;bsol;* temporarily used when ignoring future types */
75  static void
76  hwloc__xml_import_object_attr(struct hwloc_topology *topology,
77  			      struct hwloc_xml_backend_data_s *data,
78  			      struct hwloc_obj *obj,
79  			      const char *name, const char *value,
80  			      hwloc__xml_import_state_t state,
81  			      int *ignore)
82  {
83    if (!strcmp(name, &quot;type&quot;)) {
84      return;
85    }
86    else if (!strcmp(name, &quot;os_index&quot;))
87      obj-&gt;os_index = strtoul(value, NULL, 10);
88    else if (!strcmp(name, &quot;gp_index&quot;)) {
89      obj-&gt;gp_index = strtoull(value, NULL, 10);
90      if (!obj-&gt;gp_index &amp;&amp; hwloc__xml_verbose())
91        fprintf(stderr, &quot;%s: unexpected zero gp_index, topology may be invalid\n&quot;, state-&gt;global-&gt;msgprefix);
92      if (obj-&gt;gp_index &gt;= topology-&gt;next_gp_index)
93        topology-&gt;next_gp_index = obj-&gt;gp_index + 1;
94    } else if (!strcmp(name, &quot;id&quot;)) { &amp;bsol;* forward compat */
95      if (!strncmp(value, &quot;obj&quot;, 3)) {
96        obj-&gt;gp_index = strtoull(value+3, NULL, 10);
97        if (!obj-&gt;gp_index &amp;&amp; hwloc__xml_verbose())
98          fprintf(stderr, &quot;%s: unexpected zero id, topology may be invalid\n&quot;, state-&gt;global-&gt;msgprefix);
99        if (obj-&gt;gp_index &gt;= topology-&gt;next_gp_index)
100          topology-&gt;next_gp_index = obj-&gt;gp_index + 1;
101      } else {
102        if (hwloc__xml_verbose())
103          fprintf(stderr, &quot;%s: unexpected id `%s&#x27; not-starting with `obj&#x27;, ignoring\n&quot;, state-&gt;global-&gt;msgprefix, value);
104      }
105    } else if (!strcmp(name, &quot;cpuset&quot;)) {
106      if (!obj-&gt;cpuset)
107        obj-&gt;cpuset = hwloc_bitmap_alloc();
108      hwloc_bitmap_sscanf(obj-&gt;cpuset, value);
109    } else if (!strcmp(name, &quot;complete_cpuset&quot;)) {
110      if (!obj-&gt;complete_cpuset)
111        obj-&gt;complete_cpuset = hwloc_bitmap_alloc();
112      hwloc_bitmap_sscanf(obj-&gt;complete_cpuset, value);
113    } else if (!strcmp(name, &quot;allowed_cpuset&quot;)) {
114      if (!obj-&gt;parent)
115        hwloc_bitmap_sscanf(topology-&gt;allowed_cpuset, value);
116    } else if (!strcmp(name, &quot;nodeset&quot;)) {
117      if (!obj-&gt;nodeset)
118        obj-&gt;nodeset = hwloc_bitmap_alloc();
119      hwloc_bitmap_sscanf(obj-&gt;nodeset, value);
120    } else if (!strcmp(name, &quot;complete_nodeset&quot;)) {
121      if (!obj-&gt;complete_nodeset)
122        obj-&gt;complete_nodeset = hwloc_bitmap_alloc();
123      hwloc_bitmap_sscanf(obj-&gt;complete_nodeset, value);
124    } else if (!strcmp(name, &quot;allowed_nodeset&quot;)) {
125      if (!obj-&gt;parent)
126        hwloc_bitmap_sscanf(topology-&gt;allowed_nodeset, value);
127    } else if (!strcmp(name, &quot;name&quot;)) {
128      if (obj-&gt;name)
129        free(obj-&gt;name);
130      obj-&gt;name = strdup(value);
131    } else if (!strcmp(name, &quot;subtype&quot;)) {
132      if (obj-&gt;subtype)
133        free(obj-&gt;subtype);
134      obj-&gt;subtype = strdup(value);
135    }
136    else if (!strcmp(name, &quot;cache_size&quot;)) {
137      unsigned long long lvalue = strtoull(value, NULL, 10);
138      if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE)
139        obj-&gt;attr-&gt;cache.size = lvalue;
140      else if (hwloc__xml_verbose())
141        fprintf(stderr, &quot;%s: ignoring cache_size attribute for non-cache object type\n&quot;,
142  	      state-&gt;global-&gt;msgprefix);
143    }
144    else if (!strcmp(name, &quot;cache_linesize&quot;)) {
145      unsigned long lvalue = strtoul(value, NULL, 10);
146      if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE)
147        obj-&gt;attr-&gt;cache.linesize = lvalue;
148      else if (hwloc__xml_verbose())
149        fprintf(stderr, &quot;%s: ignoring cache_linesize attribute for non-cache object type\n&quot;,
150  	      state-&gt;global-&gt;msgprefix);
151    }
152    else if (!strcmp(name, &quot;cache_associativity&quot;)) {
153      int lvalue = atoi(value);
154      if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE)
155        obj-&gt;attr-&gt;cache.associativity = lvalue;
156      else if (hwloc__xml_verbose())
157        fprintf(stderr, &quot;%s: ignoring cache_associativity attribute for non-cache object type\n&quot;,
158  	      state-&gt;global-&gt;msgprefix);
159    }
160    else if (!strcmp(name, &quot;cache_type&quot;)) {
161      unsigned long lvalue = strtoul(value, NULL, 10);
162      if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE) {
163        if (lvalue == HWLOC_OBJ_CACHE_UNIFIED
164  	  || lvalue == HWLOC_OBJ_CACHE_DATA
165  	  || lvalue == HWLOC_OBJ_CACHE_INSTRUCTION)
166  	obj-&gt;attr-&gt;cache.type = (hwloc_obj_cache_type_t) lvalue;
167        else
168          if (hwloc__xml_verbose())
169            fprintf(stderr, &quot;%s: ignoring invalid cache_type attribute %lu\n&quot;,
170                    state-&gt;global-&gt;msgprefix, lvalue);
171      } else if (hwloc__xml_verbose())
172        fprintf(stderr, &quot;%s: ignoring cache_type attribute for non-cache object type\n&quot;,
173  	      state-&gt;global-&gt;msgprefix);
174    }
175    else if (!strcmp(name, &quot;local_memory&quot;)) {
176      unsigned long long lvalue = strtoull(value, NULL, 10);
177      if (obj-&gt;type == HWLOC_OBJ_NUMANODE)
178        obj-&gt;attr-&gt;numanode.local_memory = lvalue;
179      else if (!obj-&gt;parent)
180        topology-&gt;machine_memory.local_memory = lvalue;
181      else if (hwloc__xml_verbose())
182        fprintf(stderr, &quot;%s: ignoring local_memory attribute for non-NUMAnode non-root object\n&quot;,
183  	      state-&gt;global-&gt;msgprefix);
184    }
185    else if (!strcmp(name, &quot;depth&quot;)) {
186      unsigned long lvalue = strtoul(value, NULL, 10);
187       if (hwloc__obj_type_is_cache(obj-&gt;type) || obj-&gt;type == _HWLOC_OBJ_CACHE_OLD || obj-&gt;type == HWLOC_OBJ_MEMCACHE) {
188  	obj-&gt;attr-&gt;cache.depth = lvalue;
189       } else if (obj-&gt;type == HWLOC_OBJ_GROUP || obj-&gt;type == HWLOC_OBJ_BRIDGE) {
190       } else if (hwloc__xml_verbose())
191         fprintf(stderr, &quot;%s: ignoring depth attribute for object type without depth\n&quot;,
192  	       state-&gt;global-&gt;msgprefix);
193    }
194    else if (!strcmp(name, &quot;kind&quot;)) {
195      unsigned long lvalue = strtoul(value, NULL, 10);
196      if (obj-&gt;type == HWLOC_OBJ_GROUP)
197        obj-&gt;attr-&gt;group.kind = lvalue;
198      else if (hwloc__xml_verbose())
199        fprintf(stderr, &quot;%s: ignoring kind attribute for non-group object type\n&quot;,
200  	      state-&gt;global-&gt;msgprefix);
201    }
202    else if (!strcmp(name, &quot;subkind&quot;)) {
203      unsigned long lvalue = strtoul(value, NULL, 10);
204      if (obj-&gt;type == HWLOC_OBJ_GROUP)
205        obj-&gt;attr-&gt;group.subkind = lvalue;
206      else if (hwloc__xml_verbose())
207        fprintf(stderr, &quot;%s: ignoring subkind attribute for non-group object type\n&quot;,
208  	      state-&gt;global-&gt;msgprefix);
209    }
210    else if (!strcmp(name, &quot;dont_merge&quot;)) {
211      unsigned long lvalue = strtoul(value, NULL, 10);
212      if (obj-&gt;type == HWLOC_OBJ_GROUP)
213        obj-&gt;attr-&gt;group.dont_merge = (unsigned char) lvalue;
214      else if (hwloc__xml_verbose())
215        fprintf(stderr, &quot;%s: ignoring dont_merge attribute for non-group object type\n&quot;,
216  	      state-&gt;global-&gt;msgprefix);
217    }
218    else if (!strcmp(name, &quot;pci_busid&quot;)) {
219      switch (obj-&gt;type) {
220      case HWLOC_OBJ_PCI_DEVICE:
221      case HWLOC_OBJ_BRIDGE: {
222        unsigned domain, bus, dev, func;
223        if (sscanf(value, &quot;%x:%02x:%02x.%01x&quot;,
224  		 &amp;domain, &amp;bus, &amp;dev, &amp;func) != 4) {
225  	if (hwloc__xml_verbose())
226  	  fprintf(stderr, &quot;%s: ignoring invalid pci_busid format string %s\n&quot;,
227  		  state-&gt;global-&gt;msgprefix, value);
228  	*ignore = 1;
229  #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
230        } else if (domain &gt; 0xffff) {
231  	static int warned = 0;
232  	if (!warned &amp;&amp; HWLOC_SHOW_ALL_ERRORS())
233  	  fprintf(stderr, &quot;hwloc/xml: Ignoring PCI device with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don&#x27;t enable unless really needed).\n&quot;);
234  	warned = 1;
235  	*ignore = 1;
236  #endif
237        } else {
238  	obj-&gt;attr-&gt;pcidev.domain = domain;
239  	obj-&gt;attr-&gt;pcidev.bus = bus;
240  	obj-&gt;attr-&gt;pcidev.dev = dev;
241  	obj-&gt;attr-&gt;pcidev.func = func;
242        }
243        break;
244      }
245      default:
246        if (hwloc__xml_verbose())
247  	fprintf(stderr, &quot;%s: ignoring pci_busid attribute for non-PCI object\n&quot;,
248  		state-&gt;global-&gt;msgprefix);
249        break;
250      }
251    }
252    else if (!strcmp(name, &quot;pci_type&quot;)) {
253      switch (obj-&gt;type) {
254      case HWLOC_OBJ_PCI_DEVICE:
255      case HWLOC_OBJ_BRIDGE: {
256        unsigned classid, vendor, device, subvendor, subdevice, revision;
257        if (sscanf(value, &quot;%x [%04x:%04x] [%04x:%04x] %02x&quot;,
258  		 &amp;classid, &amp;vendor, &amp;device, &amp;subvendor, &amp;subdevice, &amp;revision) != 6) {
259  	if (hwloc__xml_verbose())
260  	  fprintf(stderr, &quot;%s: ignoring invalid pci_type format string %s\n&quot;,
261  		  state-&gt;global-&gt;msgprefix, value);
262        } else {
263  	obj-&gt;attr-&gt;pcidev.class_id = classid;
264  	obj-&gt;attr-&gt;pcidev.vendor_id = vendor;
265  	obj-&gt;attr-&gt;pcidev.device_id = device;
266  	obj-&gt;attr-&gt;pcidev.subvendor_id = subvendor;
267  	obj-&gt;attr-&gt;pcidev.subdevice_id = subdevice;
268  	obj-&gt;attr-&gt;pcidev.revision = revision;
269        }
270        break;
271      }
272      default:
273        if (hwloc__xml_verbose())
274  	fprintf(stderr, &quot;%s: ignoring pci_type attribute for non-PCI object\n&quot;,
275  		state-&gt;global-&gt;msgprefix);
276        break;
277      }
278    }
279    else if (!strcmp(name, &quot;pci_link_speed&quot;)) {
280      switch (obj-&gt;type) {
281      case HWLOC_OBJ_PCI_DEVICE:
282      case HWLOC_OBJ_BRIDGE: {
283        obj-&gt;attr-&gt;pcidev.linkspeed = (float) atof(value);
284        break;
285      }
286      default:
287        if (hwloc__xml_verbose())
288  	fprintf(stderr, &quot;%s: ignoring pci_link_speed attribute for non-PCI object\n&quot;,
289  		state-&gt;global-&gt;msgprefix);
290        break;
291      }
292    }
293    else if (!strcmp(name, &quot;bridge_type&quot;)) {
294      switch (obj-&gt;type) {
295      case HWLOC_OBJ_BRIDGE: {
296        unsigned upstream_type, downstream_type;
297        if (sscanf(value, &quot;%u-%u&quot;, &amp;upstream_type, &amp;downstream_type) != 2) {
298  	if (hwloc__xml_verbose())
299  	  fprintf(stderr, &quot;%s: ignoring invalid bridge_type format string %s\n&quot;,
300  		  state-&gt;global-&gt;msgprefix, value);
301        } else {
302  	obj-&gt;attr-&gt;bridge.upstream_type = (hwloc_obj_bridge_type_t) upstream_type;
303  	obj-&gt;attr-&gt;bridge.downstream_type = (hwloc_obj_bridge_type_t) downstream_type;
304        };
305        break;
306      }
307      default:
308        if (hwloc__xml_verbose())
309  	fprintf(stderr, &quot;%s: ignoring bridge_type attribute for non-bridge object\n&quot;,
310  		state-&gt;global-&gt;msgprefix);
311        break;
312      }
313    }
314    else if (!strcmp(name, &quot;bridge_pci&quot;)) {
315      switch (obj-&gt;type) {
316      case HWLOC_OBJ_BRIDGE: {
317        unsigned domain, secbus, subbus;
318        if (sscanf(value, &quot;%x:[%02x-%02x]&quot;,
319  		 &amp;domain, &amp;secbus, &amp;subbus) != 3) {
320  	if (hwloc__xml_verbose())
321  	  fprintf(stderr, &quot;%s: ignoring invalid bridge_pci format string %s\n&quot;,
322  		  state-&gt;global-&gt;msgprefix, value);
323  	*ignore = 1;
324  #ifndef HWLOC_HAVE_32BITS_PCI_DOMAIN
325        } else if (domain &gt; 0xffff) {
326  	static int warned = 0;
327  	if (!warned &amp;&amp; HWLOC_SHOW_ALL_ERRORS())
328  	  fprintf(stderr, &quot;hwloc/xml: Ignoring bridge to PCI with non-16bit domain.\nPass --enable-32bits-pci-domain to configure to support such devices\n(warning: it would break the library ABI, don&#x27;t enable unless really needed).\n&quot;);
329  	warned = 1;
330  	*ignore = 1;
331  #endif
332        } else {
333  	obj-&gt;attr-&gt;bridge.downstream.pci.domain = domain;
334  	obj-&gt;attr-&gt;bridge.downstream.pci.secondary_bus = secbus;
335  	obj-&gt;attr-&gt;bridge.downstream.pci.subordinate_bus = subbus;
336        }
337        break;
338      }
339      default:
340        if (hwloc__xml_verbose())
341  	fprintf(stderr, &quot;%s: ignoring bridge_pci attribute for non-bridge object\n&quot;,
342  		state-&gt;global-&gt;msgprefix);
343        break;
344      }
345    }
346    else if (!strcmp(name, &quot;osdev_type&quot;)) {
347      switch (obj-&gt;type) {
348      case HWLOC_OBJ_OS_DEVICE: {
349        unsigned osdev_type;
350        if (sscanf(value, &quot;%u&quot;, &amp;osdev_type) != 1) {
351  	if (hwloc__xml_verbose())
352  	  fprintf(stderr, &quot;%s: ignoring invalid osdev_type format string %s\n&quot;,
353  		  state-&gt;global-&gt;msgprefix, value);
354        } else
355  	obj-&gt;attr-&gt;osdev.type = (hwloc_obj_osdev_type_t) osdev_type;
356        break;
357      }
358      default:
359        if (hwloc__xml_verbose())
360  	fprintf(stderr, &quot;%s: ignoring osdev_type attribute for non-osdev object\n&quot;,
361  		state-&gt;global-&gt;msgprefix);
362        break;
363      }
364    }
365    else if (data-&gt;version_major &lt; 2) {
366      if (!strcmp(name, &quot;os_level&quot;)
367  	|| !strcmp(name, &quot;online_cpuset&quot;))
368        { &amp;bsol;* ignored */ }
369      else if (!strcmp(name, &quot;dmi_board_vendor&quot;)) {
370        if (value[0])
371  	hwloc_obj_add_info(obj, &quot;DMIBoardVendor&quot;, value);
372      }
373      else if (!strcmp(name, &quot;dmi_board_name&quot;)) {
374        if (value[0])
375  	hwloc_obj_add_info(obj, &quot;DMIBoardName&quot;, value);
376      }
377      else if (data-&gt;version_major &lt; 1) {
378        if (!strcmp(name, &quot;memory_kB&quot;)) {
379  	unsigned long long lvalue = strtoull(value, NULL, 10);
380  	if (obj-&gt;type == _HWLOC_OBJ_CACHE_OLD)
381  	  obj-&gt;attr-&gt;cache.size = lvalue &lt;&lt; 10;
382  	else if (obj-&gt;type == HWLOC_OBJ_NUMANODE)
383  	  obj-&gt;attr-&gt;numanode.local_memory = lvalue &lt;&lt; 10;
384  	else if (!obj-&gt;parent)
385  	  topology-&gt;machine_memory.local_memory = lvalue &lt;&lt; 10;
386  	else if (hwloc__xml_verbose())
387  	  fprintf(stderr, &quot;%s: ignoring memory_kB attribute for non-NUMAnode non-root object\n&quot;,
388  		  state-&gt;global-&gt;msgprefix);
389        }
390        else if (!strcmp(name, &quot;huge_page_size_kB&quot;)) {
391  	unsigned long lvalue = strtoul(value, NULL, 10);
392  	if (obj-&gt;type == HWLOC_OBJ_NUMANODE || !obj-&gt;parent) {
393  	  struct hwloc_numanode_attr_s *memory = obj-&gt;type == HWLOC_OBJ_NUMANODE ? &amp;obj-&gt;attr-&gt;numanode : &amp;topology-&gt;machine_memory;
394  	  if (!memory-&gt;page_types) {
395  	    memory-&gt;page_types = malloc(sizeof(*memory-&gt;page_types));
396  	    memory-&gt;page_types_len = 1;
397  	  }
398  	  assert(memory-&gt;page_types);
399  	  memory-&gt;page_types[0].size = lvalue &lt;&lt; 10;
400  	} else if (hwloc__xml_verbose()) {
401  	  fprintf(stderr, &quot;%s: ignoring huge_page_size_kB attribute for non-NUMAnode non-root object\n&quot;,
402  		  state-&gt;global-&gt;msgprefix);
403  	}
404        }
405        else if (!strcmp(name, &quot;huge_page_free&quot;)) {
406  	unsigned long lvalue = strtoul(value, NULL, 10);
407  	if (obj-&gt;type == HWLOC_OBJ_NUMANODE || !obj-&gt;parent) {
408  	  struct hwloc_numanode_attr_s *memory = obj-&gt;type == HWLOC_OBJ_NUMANODE ? &amp;obj-&gt;attr-&gt;numanode : &amp;topology-&gt;machine_memory;
409  	  if (!memory-&gt;page_types) {
410  	    memory-&gt;page_types = malloc(sizeof(*memory-&gt;page_types));
411  	    memory-&gt;page_types_len = 1;
412  	  }
413  	  assert(memory-&gt;page_types);
414  	  memory-&gt;page_types[0].count = lvalue;
415  	} else if (hwloc__xml_verbose()) {
416  	  fprintf(stderr, &quot;%s: ignoring huge_page_free attribute for non-NUMAnode non-root object\n&quot;,
417  		  state-&gt;global-&gt;msgprefix);
418  	}
419        }
420        else goto unknown;
421      }
422      else goto unknown;
423    }
424    else {
425    unknown:
426      if (hwloc__xml_verbose())
427        fprintf(stderr, &quot;%s: ignoring unknown object attribute %s\n&quot;,
428  	      state-&gt;global-&gt;msgprefix, name);
429    }
430  }
431  static int
432  hwloc___xml_import_info(char **infonamep, char **infovaluep,
433                          hwloc__xml_import_state_t state)
434  {
435    char *infoname = NULL;
436    char *infovalue = NULL;
437    while (1) {
438      char *attrname, *attrvalue;
439      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
440        break;
441      if (!strcmp(attrname, &quot;name&quot;))
442        infoname = attrvalue;
443      else if (!strcmp(attrname, &quot;value&quot;))
444        infovalue = attrvalue;
445      else
446        return -1;
447    }
448    *infonamep = infoname;
449    *infovaluep = infovalue;
450    return state-&gt;global-&gt;close_tag(state);
451  }
452  static int
453  hwloc__xml_import_obj_info(struct hwloc_xml_backend_data_s *data,
454                             hwloc_obj_t obj,
455                             hwloc__xml_import_state_t state)
456  {
457    char *infoname = NULL;
458    char *infovalue = NULL;
459    int err;
460    err = hwloc___xml_import_info(&amp;infoname, &amp;infovalue, state);
461    if (err &lt; 0)
462      return err;
463    if (infoname) {
464      if (data-&gt;version_major &lt; 2 &amp;&amp;
465  	(!strcmp(infoname, &quot;Type&quot;) || !strcmp(infoname, &quot;CoProcType&quot;))) {
466        if (infovalue) {
467  	if (obj-&gt;subtype)
468  	  free(obj-&gt;subtype);
469  	obj-&gt;subtype = strdup(infovalue);
470        }
471      } else {
472        if (infovalue)
473  	hwloc_obj_add_info(obj, infoname, infovalue);
474      }
475    }
476    return err;
477  }
478  static int
479  hwloc__xml_import_pagetype(hwloc_topology_t topology __hwloc_attribute_unused, struct hwloc_numanode_attr_s *memory,
480  			   hwloc__xml_import_state_t state)
481  {
482    uint64_t size = 0, count = 0;
483    while (1) {
484      char *attrname, *attrvalue;
485      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
486        break;
487      if (!strcmp(attrname, &quot;size&quot;))
488        size = strtoull(attrvalue, NULL, 10);
489      else if (!strcmp(attrname, &quot;count&quot;))
490        count = strtoull(attrvalue, NULL, 10);
491      else
492        return -1;
493    }
494    if (size) {
495      unsigned idx = memory-&gt;page_types_len;
496      struct hwloc_memory_page_type_s *tmp;
497      tmp = realloc(memory-&gt;page_types, (idx+1)*sizeof(*memory-&gt;page_types));
498      if (tmp) { &amp;bsol;* if failed to allocate, ignore this page_type entry */
499        memory-&gt;page_types = tmp;
500        memory-&gt;page_types_len = idx+1;
501        memory-&gt;page_types[idx].size = size;
502        memory-&gt;page_types[idx].count = count;
503      }
504    }
505    return state-&gt;global-&gt;close_tag(state);
506  }
507  static int
508  hwloc__xml_v1import_distances(struct hwloc_xml_backend_data_s *data,
509  			      hwloc_obj_t obj,
510  			      hwloc__xml_import_state_t state)
511  {
512    unsigned long reldepth = 0, nbobjs = 0;
513    float latbase = 0;
514    char *tag;
515    int ret;
516    while (1) {
517      char *attrname, *attrvalue;
518      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
519        break;
520      if (!strcmp(attrname, &quot;nbobjs&quot;))
521        nbobjs = strtoul(attrvalue, NULL, 10);
522      else if (!strcmp(attrname, &quot;relative_depth&quot;))
523        reldepth = strtoul(attrvalue, NULL, 10);
524      else if (!strcmp(attrname, &quot;latency_base&quot;))
525        latbase = (float) atof(attrvalue);
526      else
527        return -1;
528    }
529    if (nbobjs &amp;&amp; reldepth &amp;&amp; latbase) {
530      unsigned i;
531      float *matrix;
532      struct hwloc__xml_imported_v1distances_s *v1dist;
533      matrix = malloc(nbobjs*nbobjs*sizeof(float));
534      v1dist = malloc(sizeof(*v1dist));
535      if (!matrix || !v1dist) {
536        if (hwloc__xml_verbose())
537  	fprintf(stderr, &quot;%s: failed to allocate v1distance matrix for %lu objects\n&quot;,
538  		state-&gt;global-&gt;msgprefix, nbobjs);
539        free(v1dist);
540        free(matrix);
541        return -1;
542      }
543      v1dist-&gt;kind = HWLOC_DISTANCES_KIND_FROM_OS|HWLOC_DISTANCES_KIND_MEANS_LATENCY;
544      v1dist-&gt;nbobjs = nbobjs;
545      v1dist-&gt;floats = matrix;
546      for(i=0; i&lt;nbobjs*nbobjs; i++) {
547        struct hwloc__xml_import_state_s childstate;
548        char *attrname, *attrvalue;
549        float val;
550        ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
551        if (ret &lt;= 0 || strcmp(tag, &quot;latency&quot;)) {
552  	free(matrix);
553  	free(v1dist);
554  	return -1;
555        }
556        ret = state-&gt;global-&gt;next_attr(&amp;childstate, &amp;attrname, &amp;attrvalue);
557        if (ret &lt; 0 || strcmp(attrname, &quot;value&quot;)) {
558  	free(matrix);
559  	free(v1dist);
560  	return -1;
561        }
562        val = (float) atof((char *) attrvalue);
563        matrix[i] = val * latbase;
564        ret = state-&gt;global-&gt;close_tag(&amp;childstate);
565        if (ret &lt; 0) {
566  	free(matrix);
567  	free(v1dist);
568  	return -1;
569        }
570        state-&gt;global-&gt;close_child(&amp;childstate);
571      }
572      if (nbobjs &lt; 2) {
573        assert(nbobjs == 1);
574        if (hwloc__xml_verbose())
575  	fprintf(stderr, &quot;%s: ignoring invalid distance matrix with only 1 object\n&quot;,
576  		state-&gt;global-&gt;msgprefix);
577        free(matrix);
578        free(v1dist);
579      } else if (obj-&gt;parent) {
580        free(matrix);
581        free(v1dist);
582      } else {
583        v1dist-&gt;prev = data-&gt;last_v1dist;
584        v1dist-&gt;next = NULL;
585        if (data-&gt;last_v1dist)
586  	data-&gt;last_v1dist-&gt;next = v1dist;
587        else
588  	data-&gt;first_v1dist = v1dist;
589        data-&gt;last_v1dist = v1dist;
590      }
591    }
592    return state-&gt;global-&gt;close_tag(state);
593  }
594  static int
595  hwloc__xml_import_userdata(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_obj_t obj,
596  			   hwloc__xml_import_state_t state)
597  {
598    size_t length = 0;
599    int encoded = 0;
600    char *name = NULL; &amp;bsol;* optional */
601    int ret;
602    while (1) {
603      char *attrname, *attrvalue;
604      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
605        break;
606      if (!strcmp(attrname, &quot;length&quot;))
607        length = strtoul(attrvalue, NULL, 10);
608      else if (!strcmp(attrname, &quot;encoding&quot;))
609        encoded = !strcmp(attrvalue, &quot;base64&quot;);
610      else if (!strcmp(attrname, &quot;name&quot;))
611        name = attrvalue;
612      else
613        return -1;
614    }
615    if (!topology-&gt;userdata_import_cb) {
616      const char *buffer;
617      size_t reallength = encoded ? BASE64_ENCODED_LENGTH(length) : length;
618      ret = state-&gt;global-&gt;get_content(state, &amp;buffer, reallength);
619      if (ret &lt; 0)
620        return -1;
621    } else if (topology-&gt;userdata_not_decoded) {
622        const char *buffer;
623        char *fakename;
624        size_t reallength = encoded ? BASE64_ENCODED_LENGTH(length) : length;
625        ret = state-&gt;global-&gt;get_content(state, &amp;buffer, reallength);
626        if (ret &lt; 0)
627          return -1;
628        fakename = malloc(6 + 1 + (name ? strlen(name) : 4) + 1);
629        if (!fakename)
630  	return -1;
631        sprintf(fakename, encoded ? &quot;base64%c%s&quot; : &quot;normal%c%s&quot;, name ? &#x27;:&#x27; : &#x27;-&#x27;, name ? name : &quot;anon&quot;);
632        topology-&gt;userdata_import_cb(topology, obj, fakename, buffer, length);
633        free(fakename);
634    } else if (encoded &amp;&amp; length) {
635        const char *encoded_buffer;
636        size_t encoded_length = BASE64_ENCODED_LENGTH(length);
637        ret = state-&gt;global-&gt;get_content(state, &amp;encoded_buffer, encoded_length);
638        if (ret &lt; 0)
639          return -1;
640        if (ret) {
641  	char *decoded_buffer = malloc(length+1);
642  	if (!decoded_buffer)
643  	  return -1;
644  	assert(encoded_buffer[encoded_length] == 0);
645  	ret = hwloc_decode_from_base64(encoded_buffer, decoded_buffer, length+1);
646  	if (ret != (int) length) {
647  	  free(decoded_buffer);
648  	  return -1;
649  	}
650  	topology-&gt;userdata_import_cb(topology, obj, name, decoded_buffer, length);
651  	free(decoded_buffer);
652        }
653    } else { &amp;bsol;* always handle length==0 in the non-encoded case */
654        const char *buffer = &quot;&quot;;
655        if (length) {
656  	ret = state-&gt;global-&gt;get_content(state, &amp;buffer, length);
657  	if (ret &lt; 0)
658  	  return -1;
659        }
660        topology-&gt;userdata_import_cb(topology, obj, name, buffer, length);
661    }
662    state-&gt;global-&gt;close_content(state);
663    return state-&gt;global-&gt;close_tag(state);
664  }
665  static void hwloc__xml_import_report_outoforder(hwloc_topology_t topology, hwloc_obj_t new, hwloc_obj_t old)
666  {
667    char *progname = hwloc_progname(topology);
668    const char *origversion = hwloc_obj_get_info_by_name(topology-&gt;levels[0][0], &quot;hwlocVersion&quot;);
669    const char *origprogname = hwloc_obj_get_info_by_name(topology-&gt;levels[0][0], &quot;ProcessName&quot;);
670    char *c1, *cc1, t1[64];
671    char *c2 = NULL, *cc2 = NULL, t2[64];
672    hwloc_bitmap_asprintf(&amp;c1, new-&gt;cpuset);
673    hwloc_bitmap_asprintf(&amp;cc1, new-&gt;complete_cpuset);
674    hwloc_obj_type_snprintf(t1, sizeof(t1), new, 0);
675    if (old-&gt;cpuset)
676      hwloc_bitmap_asprintf(&amp;c2, old-&gt;cpuset);
677    if (old-&gt;complete_cpuset)
678      hwloc_bitmap_asprintf(&amp;cc2, old-&gt;complete_cpuset);
679    hwloc_obj_type_snprintf(t2, sizeof(t2), old, 0);
680    fprintf(stderr, &quot;****************************************************************************\n&quot;);
681    fprintf(stderr, &quot;* hwloc has encountered an out-of-order XML topology load.\n&quot;);
682    fprintf(stderr, &quot;* Object %s cpuset %s complete %s\n&quot;,
683  	  t1, c1, cc1);
684    fprintf(stderr, &quot;* was inserted after object %s with %s and %s.\n&quot;,
685  	  t2, c2 ? c2 : &quot;none&quot;, cc2 ? cc2 : &quot;none&quot;);
686    fprintf(stderr, &quot;* The error occured in hwloc %s inside process `%s&#x27;, while\n&quot;,
687  	  HWLOC_VERSION,
688  	  progname ? progname : &quot;&lt;unknown&gt;&quot;);
689    if (origversion || origprogname)
690      fprintf(stderr, &quot;* the input XML was generated by hwloc %s inside process `%s&#x27;.\n&quot;,
691  	    origversion ? origversion : &quot;(unknown version)&quot;,
692  	    origprogname ? origprogname : &quot;&lt;unknown&gt;&quot;);
693    else
694      fprintf(stderr, &quot;* the input XML was generated by an unspecified ancient hwloc release.\n&quot;);
695    fprintf(stderr, &quot;* Please check that your input topology XML file is valid.\n&quot;);
696    fprintf(stderr, &quot;* Set HWLOC_DEBUG_CHECK=1 in the environment to detect further issues.\n&quot;);
697    fprintf(stderr, &quot;****************************************************************************\n&quot;);
698    free(c1);
699    free(cc1);
700    free(c2);
701    free(cc2);
702    free(progname);
703  }
704  static int
705  hwloc__xml_import_object(hwloc_topology_t topology,
706  			 struct hwloc_xml_backend_data_s *data,
707  			 hwloc_obj_t parent, hwloc_obj_t obj, int *gotignored,
708  			 hwloc__xml_import_state_t state)
709  {
710    int ignored = 0;
711    int childrengotignored = 0;
712    int attribute_less_cache = 0;
713    int numa_was_root = 0;
714    char *tag;
715    struct hwloc__xml_import_state_s childstate;
716    obj-&gt;parent = parent;
717    while (1) {
718      char *attrname, *attrvalue;
719      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
720        break;
721      if (!strcmp(attrname, &quot;type&quot;)) {
722        if (hwloc_type_sscanf(attrvalue, &amp;obj-&gt;type, NULL, 0) &lt; 0) {
723  	if (!strcasecmp(attrvalue, &quot;Cache&quot;)) {
724  	  obj-&gt;type = _HWLOC_OBJ_CACHE_OLD; &amp;bsol;* will be fixed below */
725  	  attribute_less_cache = 1;
726  	} else if (!strcasecmp(attrvalue, &quot;System&quot;)) {
727  	  if (!parent)
728  	    obj-&gt;type = HWLOC_OBJ_MACHINE;
729  	  else {
730  	    if (hwloc__xml_verbose())
731  	      fprintf(stderr, &quot;%s: obsolete System object only allowed at root\n&quot;,
732  		      state-&gt;global-&gt;msgprefix);
733  	    goto error_with_object;
734  	  }
735  	} else if (!strcasecmp(attrvalue, &quot;Tile&quot;)) {
736  	  obj-&gt;type = HWLOC_OBJ_GROUP;
737  	  obj-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_INTEL_TILE;
738  	} else if (!strcasecmp(attrvalue, &quot;Module&quot;)) {
739  	  obj-&gt;type = HWLOC_OBJ_GROUP;
740  	  obj-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_INTEL_MODULE;
741  	} else if (!strcasecmp(attrvalue, &quot;MemCache&quot;)) {
742  	  obj-&gt;type = _HWLOC_OBJ_FUTURE;
743  	  ignored = 1;
744  	  if (hwloc__xml_verbose())
745  	    fprintf(stderr, &quot;%s: %s object not-supported, will be ignored\n&quot;,
746  		    state-&gt;global-&gt;msgprefix, attrvalue);
747  	} else {
748  	  if (hwloc__xml_verbose())
749  	    fprintf(stderr, &quot;%s: unrecognized object type string %s\n&quot;,
750  		    state-&gt;global-&gt;msgprefix, attrvalue);
751  	  goto error_with_object;
752  	}
753        }
754      } else {
755        if (obj-&gt;type == HWLOC_OBJ_TYPE_NONE) {
756  	if (hwloc__xml_verbose())
757  	  fprintf(stderr, &quot;%s: object attribute %s found before type\n&quot;,
758  		  state-&gt;global-&gt;msgprefix,  attrname);
759  	goto error_with_object;
760        }
761        hwloc__xml_import_object_attr(topology, data, obj, attrname, attrvalue, state, &amp;ignored);
762      }
763    }
764    while (1) {
765      int ret;
766      tag = NULL;
767      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
768      if (ret &lt; 0)
769        goto error;
770      if (!ret)
771        break;
772      if (!strcmp(tag, &quot;object&quot;)) {
773        break;
774      } else if (!strcmp(tag, &quot;page_type&quot;)) {
775        if (obj-&gt;type == HWLOC_OBJ_NUMANODE) {
776  	ret = hwloc__xml_import_pagetype(topology, &amp;obj-&gt;attr-&gt;numanode, &amp;childstate);
777        } else if (!parent) {
778  	ret = hwloc__xml_import_pagetype(topology, &amp;topology-&gt;machine_memory, &amp;childstate);
779        } else {
780  	if (hwloc__xml_verbose())
781  	  fprintf(stderr, &quot;%s: invalid non-NUMAnode object child %s\n&quot;,
782  		  state-&gt;global-&gt;msgprefix, tag);
783  	ret = -1;
784        }
785      } else if (!strcmp(tag, &quot;info&quot;)) {
786        ret = hwloc__xml_import_obj_info(data, obj, &amp;childstate);
787      } else if (data-&gt;version_major &lt; 2 &amp;&amp; !strcmp(tag, &quot;distances&quot;)) {
788        ret = hwloc__xml_v1import_distances(data, obj, &amp;childstate);
789      } else if (!strcmp(tag, &quot;userdata&quot;)) {
790        ret = hwloc__xml_import_userdata(topology, obj, &amp;childstate);
791      } else {
792        if (hwloc__xml_verbose())
793  	fprintf(stderr, &quot;%s: invalid special object child %s\n&quot;,
794  		state-&gt;global-&gt;msgprefix, tag);
795        ret = -1;
796      }
797      if (ret &lt; 0)
798        goto error;
799      state-&gt;global-&gt;close_child(&amp;childstate);
800    }
801    if (parent &amp;&amp; obj-&gt;type == HWLOC_OBJ_MACHINE) {
802      obj-&gt;type = HWLOC_OBJ_GROUP;
803    }
804    if (parent &amp;&amp; data-&gt;version_major &gt;= 2) {
805      if (hwloc__obj_type_is_normal(obj-&gt;type)) {
806        if (!hwloc__obj_type_is_normal(parent-&gt;type)) {
807  	if (hwloc__xml_verbose())
808  	  fprintf(stderr, &quot;normal object %s cannot be child of non-normal parent %s\n&quot;,
809  		  hwloc_obj_type_string(obj-&gt;type), hwloc_obj_type_string(parent-&gt;type));
810  	goto error_with_object;
811        }
812      } else if (hwloc__obj_type_is_memory(obj-&gt;type)) {
813        if (hwloc__obj_type_is_io(parent-&gt;type) || HWLOC_OBJ_MISC == parent-&gt;type) {
814  	if (hwloc__xml_verbose())
815  	  fprintf(stderr, &quot;Memory object %s cannot be child of non-normal-or-memory parent %s\n&quot;,
816  		  hwloc_obj_type_string(obj-&gt;type), hwloc_obj_type_string(parent-&gt;type));
817  	goto error_with_object;
818        }
819      } else if (hwloc__obj_type_is_io(obj-&gt;type)) {
820        if (hwloc__obj_type_is_memory(parent-&gt;type) || HWLOC_OBJ_MISC == parent-&gt;type) {
821  	if (hwloc__xml_verbose())
822  	  fprintf(stderr, &quot;I/O object %s cannot be child of non-normal-or-I/O parent %s\n&quot;,
823  		  hwloc_obj_type_string(obj-&gt;type), hwloc_obj_type_string(parent-&gt;type));
824  	goto error_with_object;
825        }
826      }
827    } else if (parent &amp;&amp; data-&gt;version_major &lt; 2) {
828      if (hwloc__obj_type_is_normal(obj-&gt;type) || HWLOC_OBJ_NUMANODE == obj-&gt;type) {
829        if (hwloc__obj_type_is_special(parent-&gt;type)) {
830  	if (hwloc__xml_verbose())
831  	  fprintf(stderr, &quot;v1.x normal v1.x object %s cannot be child of special parent %s\n&quot;,
832  		  hwloc_obj_type_string(obj-&gt;type), hwloc_obj_type_string(parent-&gt;type));
833  	goto error_with_object;
834        }
835      } else if (hwloc__obj_type_is_io(obj-&gt;type)) {
836        if (HWLOC_OBJ_MISC == parent-&gt;type) {
837  	if (hwloc__xml_verbose())
838  	  fprintf(stderr, &quot;I/O object %s cannot be child of Misc parent\n&quot;,
839  		  hwloc_obj_type_string(obj-&gt;type));
840  	goto error_with_object;
841        }
842      }
843    }
844    if (data-&gt;version_major &lt; 2) {
845      if (parent &amp;&amp; parent-&gt;type == HWLOC_OBJ_NUMANODE) {
846        parent = parent-&gt;parent;
847        assert(parent);
848      }
849      if (obj-&gt;type == HWLOC_OBJ_NUMANODE) {
850        if (!parent) {
851  	hwloc_obj_t machine = hwloc_alloc_setup_object(topology, HWLOC_OBJ_MACHINE, HWLOC_UNKNOWN_INDEX);
852  	machine-&gt;cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
853  	machine-&gt;complete_cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
854  	machine-&gt;nodeset = hwloc_bitmap_dup(obj-&gt;nodeset);
855  	machine-&gt;complete_nodeset = hwloc_bitmap_dup(obj-&gt;complete_nodeset);
856  	topology-&gt;levels[0][0] = machine;
857  	parent = machine;
858  	numa_was_root = 1;
859        } else if (!hwloc_bitmap_isequal(obj-&gt;complete_cpuset, parent-&gt;complete_cpuset)) {
860  	int needgroup = 1;
861  	hwloc_obj_t sibling;
862  	sibling = parent-&gt;memory_first_child;
863  	if (sibling &amp;&amp; !sibling-&gt;subtype
864  	    &amp;&amp; !sibling-&gt;next_sibling
865  	    &amp;&amp; obj-&gt;subtype &amp;&amp; !strcmp(obj-&gt;subtype, &quot;MCDRAM&quot;)
866  	    &amp;&amp; hwloc_bitmap_iszero(obj-&gt;complete_cpuset)) {
867  	  needgroup = 0;
868  	}
869  	if (needgroup
870  	    &amp;&amp; hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
871  	  hwloc_obj_t group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
872  	  group-&gt;gp_index = 0; &amp;bsol;* will be initialized at the end of the discovery once we know the max */
873  	  group-&gt;cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
874  	  group-&gt;complete_cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
875  	  group-&gt;nodeset = hwloc_bitmap_dup(obj-&gt;nodeset);
876  	  group-&gt;complete_nodeset = hwloc_bitmap_dup(obj-&gt;complete_nodeset);
877  	  group-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_MEMORY;
878  	  hwloc_insert_object_by_parent(topology, parent, group);
879  	  parent = group;
880  	}
881        }
882      }
883      if (attribute_less_cache) {
884        assert(obj-&gt;type == _HWLOC_OBJ_CACHE_OLD);
885        obj-&gt;type = hwloc_cache_type_by_depth_type(obj-&gt;attr-&gt;cache.depth, obj-&gt;attr-&gt;cache.type);
886      }
887      if (obj-&gt;type == HWLOC_OBJ_MISC &amp;&amp; obj-&gt;cpuset)
888        obj-&gt;type = HWLOC_OBJ_GROUP;
889      if (!obj-&gt;cpuset != !obj-&gt;complete_cpuset) {
890        if (obj-&gt;type == HWLOC_OBJ_GROUP) {
891  	ignored = 1;
892        } else {
893  	if (hwloc__xml_verbose())
894  	  fprintf(stderr, &quot;%s: invalid object %s P#%u with some missing cpusets\n&quot;,
895  		  state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
896  	goto error_with_object;
897        }
898      } else if (!obj-&gt;nodeset != !obj-&gt;complete_nodeset) {
899        if (obj-&gt;type == HWLOC_OBJ_GROUP) {
900  	ignored = 1;
901        } else {
902  	if (hwloc__xml_verbose())
903  	  fprintf(stderr, &quot;%s: invalid object %s P#%u with some missing nodesets\n&quot;,
904  		  state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
905  	goto error_with_object;
906        }
907      } else if (obj-&gt;nodeset &amp;&amp; !obj-&gt;cpuset) {
908        if (obj-&gt;type == HWLOC_OBJ_GROUP) {
909  	ignored = 1;
910        } else {
911  	if (hwloc__xml_verbose())
912  	  fprintf(stderr, &quot;%s: invalid object %s P#%u with either cpuset or nodeset missing\n&quot;,
913  		  state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
914  	goto error_with_object;
915        }
916      }
917    }
918    if (obj-&gt;type == HWLOC_OBJ_GROUP) {
919      if (obj-&gt;attr-&gt;group.kind == HWLOC_GROUP_KIND_INTEL_DIE
920  	|| (obj-&gt;subtype &amp;&amp; !strcmp(obj-&gt;subtype, &quot;Die&quot;)))
921        obj-&gt;type = HWLOC_OBJ_DIE;
922    }
923    if (hwloc__obj_type_is_cache(obj-&gt;type)
924        &amp;&amp; obj-&gt;type != hwloc_cache_type_by_depth_type(obj-&gt;attr-&gt;cache.depth, obj-&gt;attr-&gt;cache.type)) {
925      if (hwloc__xml_verbose())
926        fprintf(stderr, &quot;%s: invalid cache type %s with attribute depth %u and type %d\n&quot;,
927  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;attr-&gt;cache.depth, (int) obj-&gt;attr-&gt;cache.type);
928      goto error_with_object;
929    }
930    if (!obj-&gt;cpuset &amp;&amp; !hwloc__obj_type_is_special(obj-&gt;type)) {
931      if (hwloc__xml_verbose())
932        fprintf(stderr, &quot;%s: invalid normal object %s P#%u without cpuset\n&quot;,
933  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
934      goto error_with_object;
935    }
936    if (obj-&gt;cpuset &amp;&amp; hwloc__obj_type_is_special(obj-&gt;type)) {
937      if (hwloc__xml_verbose())
938        fprintf(stderr, &quot;%s: invalid special object %s with cpuset\n&quot;,
939  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type));
940      goto error_with_object;
941    }
942    if (obj-&gt;cpuset &amp;&amp; parent &amp;&amp; !parent-&gt;cpuset) {
943      if (hwloc__xml_verbose())
944        fprintf(stderr, &quot;%s: invalid object %s P#%u with cpuset while parent has none\n&quot;,
945  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
946      goto error_with_object;
947    }
948    if (obj-&gt;nodeset &amp;&amp; parent &amp;&amp; !parent-&gt;nodeset) {
949      if (hwloc__xml_verbose())
950        fprintf(stderr, &quot;%s: invalid object %s P#%u with nodeset while parent has none\n&quot;,
951  	      state-&gt;global-&gt;msgprefix, hwloc_obj_type_string(obj-&gt;type), obj-&gt;os_index);
952      goto error_with_object;
953    }
954    if (obj-&gt;type == HWLOC_OBJ_NUMANODE) {
955      if (!obj-&gt;nodeset) {
956        if (hwloc__xml_verbose())
957  	fprintf(stderr, &quot;%s: invalid NUMA node object P#%u without nodeset\n&quot;,
958  		state-&gt;global-&gt;msgprefix, obj-&gt;os_index);
959        goto error_with_object;
960      }
961      data-&gt;nbnumanodes++;
962      obj-&gt;prev_cousin = data-&gt;last_numanode;
963      obj-&gt;next_cousin = NULL;
964      if (data-&gt;last_numanode)
965        data-&gt;last_numanode-&gt;next_cousin = obj;
966      else
967        data-&gt;first_numanode = obj;
968      data-&gt;last_numanode = obj;
969    }
970    if (!hwloc_filter_check_keep_object(topology, obj)) {
971      if (parent)
972        ignored = 1;
973    }
974    if (parent &amp;&amp; !ignored) {
975      hwloc_insert_object_by_parent(topology, parent, obj);
976    }
977    while (tag) {
978      int ret;
979      if (!strcmp(tag, &quot;object&quot;)) {
980        hwloc_obj_t childobj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_TYPE_MAX, HWLOC_UNKNOWN_INDEX);
981        childobj-&gt;parent = ignored ? parent : obj;
982        ret = hwloc__xml_import_object(topology, data, ignored ? parent : obj, childobj,
983  				     &amp;childrengotignored,
984  				     &amp;childstate);
985      } else {
986        if (hwloc__xml_verbose())
987  	fprintf(stderr, &quot;%s: invalid special object child %s while looking for objects\n&quot;,
988  		state-&gt;global-&gt;msgprefix, tag);
989        ret = -1;
990      }
991      if (ret &lt; 0) {
992        if (parent &amp;&amp; !ignored)
993          goto error;
994        else
995          goto error_with_object;
996      }
997      state-&gt;global-&gt;close_child(&amp;childstate);
998      tag = NULL;
999      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1000      if (ret &lt; 0) {
1001        if (parent &amp;&amp; !ignored)
1002          goto error;
1003        else
1004          goto error_with_object;
1005      }
1006      if (!ret)
1007        break;
1008    }
1009    if (numa_was_root) {
1010      unsigned i;
1011      for(i=0; i&lt;obj-&gt;infos_count; i++) {
1012        struct hwloc_info_s *info = &amp;obj-&gt;infos[i];
1013        hwloc_obj_add_info(parent, info-&gt;name, info-&gt;value);
1014      }
1015    }
1016    if (ignored) {
1017      hwloc_free_unlinked_object(obj);
1018      *gotignored = 1;
1019    } else if (obj-&gt;first_child) {
1020      hwloc_obj_t cur, next;
1021      for(cur = obj-&gt;first_child, next = cur-&gt;next_sibling;
1022  	next;
1023  	cur = next, next = next-&gt;next_sibling) {
1024        if (hwloc_bitmap_compare_first(next-&gt;complete_cpuset, cur-&gt;complete_cpuset) &lt; 0) {
1025  	if (!childrengotignored) {
1026  	  static int reported = 0;
1027  	  if (!reported &amp;&amp; HWLOC_SHOW_CRITICAL_ERRORS()) {
1028  	    hwloc__xml_import_report_outoforder(topology, next, cur);
1029  	    reported = 1;
1030  	  }
1031  	}
1032  	hwloc__reorder_children(obj);
1033  	break;
1034        }
1035      }
1036    }
1037    return state-&gt;global-&gt;close_tag(state);
1038   error_with_object:
1039    if (parent)
1040      hwloc_free_unlinked_object(obj);
1041   error:
1042    return -1;
1043  }
1044  static int
1045  hwloc__xml_v2import_support(hwloc_topology_t topology,
1046                              hwloc__xml_import_state_t state)
1047  {
1048    char *name = NULL;
1049    int value = 1; &amp;bsol;* value is optional */
1050    while (1) {
1051      char *attrname, *attrvalue;
1052      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1053        break;
1054      if (!strcmp(attrname, &quot;name&quot;))
1055        name = attrvalue;
1056      else if (!strcmp(attrname, &quot;value&quot;))
1057        value = atoi(attrvalue);
1058      else {
1059        if (hwloc__xml_verbose())
1060  	fprintf(stderr, &quot;%s: ignoring unknown support attribute %s\n&quot;,
1061  		state-&gt;global-&gt;msgprefix, attrname);
1062      }
1063    }
1064    if (name &amp;&amp; topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT) {
1065  #ifdef HWLOC_DEBUG
1066      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_support) == 4*sizeof(void*));
1067      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_discovery_support) == 6);
1068      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_cpubind_support) == 11);
1069      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_membind_support) == 15);
1070      HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_misc_support) == 1);
1071  #endif
1072  #define DO(_cat,_name) if (!strcmp(#_cat &quot;.&quot; #_name, name)) topology-&gt;support._cat-&gt;_name = value
1073      DO(discovery,pu);
1074      else DO(discovery,numa);
1075      else DO(discovery,numa_memory);
1076      else DO(discovery,disallowed_pu);
1077      else DO(discovery,disallowed_numa);
1078      else DO(discovery,cpukind_efficiency);
1079      else DO(cpubind,set_thisproc_cpubind);
1080      else DO(cpubind,get_thisproc_cpubind);
1081      else DO(cpubind,set_proc_cpubind);
1082      else DO(cpubind,get_proc_cpubind);
1083      else DO(cpubind,set_thisthread_cpubind);
1084      else DO(cpubind,get_thisthread_cpubind);
1085      else DO(cpubind,set_thread_cpubind);
1086      else DO(cpubind,get_thread_cpubind);
1087      else DO(cpubind,get_thisproc_last_cpu_location);
1088      else DO(cpubind,get_proc_last_cpu_location);
1089      else DO(cpubind,get_thisthread_last_cpu_location);
1090      else DO(membind,set_thisproc_membind);
1091      else DO(membind,get_thisproc_membind);
1092      else DO(membind,set_proc_membind);
1093      else DO(membind,get_proc_membind);
1094      else DO(membind,set_thisthread_membind);
1095      else DO(membind,get_thisthread_membind);
1096      else DO(membind,set_area_membind);
1097      else DO(membind,get_area_membind);
1098      else DO(membind,alloc_membind);
1099      else DO(membind,firsttouch_membind);
1100      else DO(membind,bind_membind);
1101      else DO(membind,interleave_membind);
1102      else DO(membind,nexttouch_membind);
1103      else DO(membind,migrate_membind);
1104      else DO(membind,get_area_memlocation);
1105      else if (!strcmp(&quot;custom.exported_support&quot;, name))
1106        topology-&gt;support.misc-&gt;imported_support = 1;
1107  #undef DO
1108    }
1109    return 0;
1110  }
1111  static int
1112  hwloc__xml_v2import_distances(hwloc_topology_t topology,
1113  			      hwloc__xml_import_state_t state,
1114  			      int heterotypes)
1115  {
1116    hwloc_obj_type_t unique_type = HWLOC_OBJ_TYPE_NONE;
1117    hwloc_obj_type_t *different_types = NULL;
1118    unsigned nbobjs = 0;
1119    int indexing = heterotypes;
1120    int os_indexing = 0;
1121    int gp_indexing = heterotypes;
1122    char *name = NULL;
1123    unsigned long kind = 0;
1124    unsigned nr_indexes, nr_u64values;
1125    uint64_t *indexes;
1126    uint64_t *u64values;
1127    int ret;
1128  #define _TAG_NAME (heterotypes ? &quot;distances2hetero&quot; : &quot;distances2&quot;)
1129    while (1) {
1130      char *attrname, *attrvalue;
1131      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1132        break;
1133      if (!strcmp(attrname, &quot;nbobjs&quot;))
1134        nbobjs = strtoul(attrvalue, NULL, 10);
1135      else if (!strcmp(attrname, &quot;type&quot;)) {
1136        if (hwloc_type_sscanf(attrvalue, &amp;unique_type, NULL, 0) &lt; 0) {
1137  	if (hwloc__xml_verbose())
1138  	  fprintf(stderr, &quot;%s: unrecognized %s type %s\n&quot;,
1139  		  state-&gt;global-&gt;msgprefix, _TAG_NAME, attrvalue);
1140  	goto out;
1141        }
1142      }
1143      else if (!strcmp(attrname, &quot;indexing&quot;)) {
1144        indexing = 1;
1145        if (!strcmp(attrvalue, &quot;os&quot;))
1146  	os_indexing = 1;
1147        else if (!strcmp(attrvalue, &quot;gp&quot;))
1148  	gp_indexing = 1;
1149      }
1150      else if (!strcmp(attrname, &quot;kind&quot;)) {
1151        kind = strtoul(attrvalue, NULL, 10);
1152      }
1153      else if (!strcmp(attrname, &quot;name&quot;)) {
1154        name = attrvalue;
1155      }
1156      else {
1157        if (hwloc__xml_verbose())
1158  	fprintf(stderr, &quot;%s: ignoring unknown %s attribute %s\n&quot;,
1159  		state-&gt;global-&gt;msgprefix, _TAG_NAME, attrname);
1160      }
1161    }
1162    if (!nbobjs || (!heterotypes &amp;&amp; unique_type == HWLOC_OBJ_TYPE_NONE) || !indexing || !kind) {
1163      if (hwloc__xml_verbose())
1164        fprintf(stderr, &quot;%s: %s missing some attributes\n&quot;,
1165  	      state-&gt;global-&gt;msgprefix, _TAG_NAME);
1166      goto out;
1167    }
1168    indexes = malloc(nbobjs*sizeof(*indexes));
1169    u64values = malloc(nbobjs*nbobjs*sizeof(*u64values));
1170    if (heterotypes)
1171      different_types = malloc(nbobjs*sizeof(*different_types));
1172    if (!indexes || !u64values || (heterotypes &amp;&amp; !different_types)) {
1173      if (hwloc__xml_verbose())
1174        fprintf(stderr, &quot;%s: failed to allocate %s arrays for %u objects\n&quot;,
1175  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1176      goto out_with_arrays;
1177    }
1178    nr_indexes = 0;
1179    nr_u64values = 0;
1180    while (1) {
1181      struct hwloc__xml_import_state_s childstate;
1182      char *attrname, *attrvalue, *tag;
1183      const char *buffer;
1184      int length;
1185      int is_index = 0;
1186      int is_u64values = 0;
1187      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1188      if (ret &lt;= 0)
1189        break;
1190      if (!strcmp(tag, &quot;indexes&quot;))
1191        is_index = 1;
1192      else if (!strcmp(tag, &quot;u64values&quot;))
1193        is_u64values = 1;
1194      if (!is_index &amp;&amp; !is_u64values) {
1195        if (hwloc__xml_verbose())
1196  	fprintf(stderr, &quot;%s: %s with unrecognized child %s\n&quot;,
1197  		state-&gt;global-&gt;msgprefix, _TAG_NAME, tag);
1198        goto out_with_arrays;
1199      }
1200      if (state-&gt;global-&gt;next_attr(&amp;childstate, &amp;attrname, &amp;attrvalue) &lt; 0
1201  	|| strcmp(attrname, &quot;length&quot;)) {
1202        if (hwloc__xml_verbose())
1203  	fprintf(stderr, &quot;%s: %s child must have length attribute\n&quot;,
1204  		state-&gt;global-&gt;msgprefix, _TAG_NAME);
1205        goto out_with_arrays;
1206      }
1207      length = atoi(attrvalue);
1208      ret = state-&gt;global-&gt;get_content(&amp;childstate, &amp;buffer, length);
1209      if (ret &lt; 0) {
1210        if (hwloc__xml_verbose())
1211  	fprintf(stderr, &quot;%s: %s child needs content of length %d\n&quot;,
1212  		state-&gt;global-&gt;msgprefix, _TAG_NAME, length);
1213        goto out_with_arrays;
1214      }
1215      if (is_index) {
1216        const char *tmp, *tmp2;
1217        if (nr_indexes &gt;= nbobjs) {
1218  	if (hwloc__xml_verbose())
1219  	  fprintf(stderr, &quot;%s: %s with more than %u indexes\n&quot;,
1220  		  state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1221  	goto out_with_arrays;
1222        }
1223        tmp = buffer;
1224        while (1) {
1225  	char *next;
1226  	unsigned long long u;
1227  	if (heterotypes) {
1228  	  hwloc_obj_type_t t = HWLOC_OBJ_TYPE_NONE;
1229            if (!*tmp)
1230              break;
1231  	  if (hwloc_type_sscanf(tmp, &amp;t, NULL, 0) &lt; 0) {
1232  	    if (hwloc__xml_verbose())
1233  	      fprintf(stderr, &quot;%s: %s with unrecognized heterogeneous type %s\n&quot;,
<span onclick='openModal()' class='match'>1234  		      state-&gt;global-&gt;msgprefix, _TAG_NAME, tmp);
1235  	    goto out_with_arrays;
1236  	  }
1237  	  tmp2 = strchr(tmp, &#x27;:&#x27;);
</span>1238  	  if (!tmp2) {
1239  	    if (hwloc__xml_verbose())
1240  	      fprintf(stderr, &quot;%s: %s with missing colon after heterogeneous type %s\n&quot;,
1241  		      state-&gt;global-&gt;msgprefix, _TAG_NAME, tmp);
1242  	    goto out_with_arrays;
1243  	  }
1244  	  tmp = tmp2+1;
1245  	  different_types[nr_indexes] = t;
1246  	}
1247  	u = strtoull(tmp, &amp;next, 0);
1248  	if (next == tmp)
1249  	  break;
1250  	indexes[nr_indexes++] = u;
1251  	if (*next != &#x27; &#x27;)
1252  	  break;
1253  	if (nr_indexes == nbobjs)
1254  	  break;
1255  	tmp = next+1;
1256        }
1257      } else if (is_u64values) {
1258        const char *tmp;
1259        if (nr_u64values &gt;= nbobjs*nbobjs) {
1260  	if (hwloc__xml_verbose())
1261  	  fprintf(stderr, &quot;%s: %s with more than %u u64values\n&quot;,
1262  		  state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs*nbobjs);
1263  	goto out_with_arrays;
1264        }
1265        tmp = buffer;
1266        while (1) {
1267  	char *next;
1268  	unsigned long long u = strtoull(tmp, &amp;next, 0);
1269  	if (next == tmp)
1270  	  break;
1271  	u64values[nr_u64values++] = u;
1272  	if (*next != &#x27; &#x27;)
1273  	  break;
1274  	if (nr_u64values == nbobjs*nbobjs)
1275  	  break;
1276  	tmp = next+1;
1277        }
1278      }
1279      state-&gt;global-&gt;close_content(&amp;childstate);
1280      ret = state-&gt;global-&gt;close_tag(&amp;childstate);
1281      if (ret &lt; 0) {
1282        if (hwloc__xml_verbose())
1283  	fprintf(stderr, &quot;%s: %s with more than %u indexes\n&quot;,
1284  		state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1285        goto out_with_arrays;
1286      }
1287      state-&gt;global-&gt;close_child(&amp;childstate);
1288    }
1289    if (nr_indexes != nbobjs) {
1290      if (hwloc__xml_verbose())
1291        fprintf(stderr, &quot;%s: %s with less than %u indexes\n&quot;,
1292  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1293      goto out_with_arrays;
1294    }
1295    if (nr_u64values != nbobjs*nbobjs) {
1296      if (hwloc__xml_verbose())
1297        fprintf(stderr, &quot;%s: %s with less than %u u64values\n&quot;,
1298  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs*nbobjs);
1299      goto out_with_arrays;
1300    }
1301    if (nbobjs &lt; 2) {
1302      if (hwloc__xml_verbose())
1303        fprintf(stderr, &quot;%s: ignoring %s with only %u objects\n&quot;,
1304  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1305      goto out_ignore;
1306    }
1307    if (unique_type == HWLOC_OBJ_PU || unique_type == HWLOC_OBJ_NUMANODE) {
1308      if (!os_indexing) {
1309        if (hwloc__xml_verbose())
1310  	fprintf(stderr, &quot;%s: ignoring PU or NUMA %s without os_indexing\n&quot;,
1311  		state-&gt;global-&gt;msgprefix, _TAG_NAME);
1312        goto out_ignore;
1313      }
1314    } else {
1315      if (!gp_indexing) {
1316        if (hwloc__xml_verbose())
1317  	fprintf(stderr, &quot;%s: ignoring !PU or !NUMA %s without gp_indexing\n&quot;,
1318  		state-&gt;global-&gt;msgprefix, _TAG_NAME);
1319        goto out_ignore;
1320      }
1321    }
1322    if (topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)
1323      goto out_ignore;
1324    hwloc_internal_distances_add_by_index(topology, name, unique_type, different_types, nbobjs, indexes, u64values, kind, 0 &amp;bsol;* assume grouping was applied when this matrix was discovered before exporting to XML */);
1325    indexes = NULL;
1326    u64values = NULL;
1327    different_types = NULL;
1328   out_ignore:
1329    free(different_types);
1330    free(indexes);
1331    free(u64values);
1332    return state-&gt;global-&gt;close_tag(state);
1333   out_with_arrays:
1334    free(different_types);
1335    free(indexes);
1336    free(u64values);
1337   out:
1338    return -1;
1339  #undef _TAG_NAME
1340  }
1341  static int
1342  hwloc__xml_import_memattr_value(hwloc_topology_t topology,
1343                                  hwloc_memattr_id_t id,
1344                                  unsigned long flags,
1345                                  hwloc__xml_import_state_t state)
1346  {
1347    char *target_obj_gp_index_s = NULL;
1348    char *target_obj_type_s = NULL;
1349    hwloc_uint64_t target_obj_gp_index;
1350    char *value_s = NULL;
1351    hwloc_uint64_t value;
1352    char *initiator_cpuset_s = NULL;
1353    char *initiator_obj_gp_index_s = NULL;
1354    char *initiator_obj_type_s = NULL;
1355    hwloc_obj_type_t target_obj_type = HWLOC_OBJ_TYPE_NONE;
1356    while (1) {
1357      char *attrname, *attrvalue;
1358      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1359        break;
1360      if (!strcmp(attrname, &quot;target_obj_gp_index&quot;))
1361        target_obj_gp_index_s = attrvalue;
1362      else if (!strcmp(attrname, &quot;target_obj_type&quot;))
1363        target_obj_type_s = attrvalue;
1364      else if (!strcmp(attrname, &quot;value&quot;))
1365        value_s = attrvalue;
1366      else if (!strcmp(attrname, &quot;initiator_cpuset&quot;))
1367        initiator_cpuset_s = attrvalue;
1368      else if (!strcmp(attrname, &quot;initiator_obj_gp_index&quot;))
1369        initiator_obj_gp_index_s = attrvalue;
1370      else if (!strcmp(attrname, &quot;initiator_obj_type&quot;))
1371        initiator_obj_type_s = attrvalue;
1372      else {
1373        if (hwloc__xml_verbose())
1374          fprintf(stderr, &quot;%s: ignoring unknown memattr_value attribute %s\n&quot;,
1375                  state-&gt;global-&gt;msgprefix, attrname);
1376        return -1;
1377      }
1378    }
1379    if (!target_obj_type_s) {
1380      if (hwloc__xml_verbose())
1381        fprintf(stderr, &quot;%s: ignoring memattr_value without target_obj_type.\n&quot;,
1382                state-&gt;global-&gt;msgprefix);
1383      return -1;
1384    }
1385    if (hwloc_type_sscanf(target_obj_type_s, &amp;target_obj_type, NULL, 0) &lt; 0) {
1386      if (hwloc__xml_verbose())
1387        fprintf(stderr, &quot;%s: failed to identify memattr_value target object type %s\n&quot;,
1388                state-&gt;global-&gt;msgprefix, target_obj_type_s);
1389      return -1;
1390    }
1391    if (!value_s || !target_obj_gp_index_s) {
1392      if (hwloc__xml_verbose())
1393        fprintf(stderr, &quot;%s: ignoring memattr_value without value and target_obj_gp_index\n&quot;,
1394                state-&gt;global-&gt;msgprefix);
1395      return -1;
1396    }
1397    target_obj_gp_index = strtoull(target_obj_gp_index_s, NULL, 10);
1398    value = strtoull(value_s, NULL, 10);
1399    if (flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
1400      struct hwloc_internal_location_s loc;
1401      if (!initiator_cpuset_s &amp;&amp; (!initiator_obj_gp_index_s || !initiator_obj_type_s)) {
1402        if (hwloc__xml_verbose())
1403          fprintf(stderr, &quot;%s: ignoring memattr_value without initiator attributes\n&quot;,
1404                  state-&gt;global-&gt;msgprefix);
1405        return -1;
1406      }
1407      if (initiator_cpuset_s) {
1408        loc.type = HWLOC_LOCATION_TYPE_CPUSET;
1409        loc.location.cpuset = hwloc_bitmap_alloc();
1410        if (!loc.location.cpuset) {
1411          if (hwloc__xml_verbose())
1412            fprintf(stderr, &quot;%s: failed to allocated memattr_value initiator cpuset\n&quot;,
1413                    state-&gt;global-&gt;msgprefix);
1414          return -1;
1415        }
1416        hwloc_bitmap_sscanf(loc.location.cpuset, initiator_cpuset_s);
1417      } else {
1418        loc.type = HWLOC_LOCATION_TYPE_OBJECT;
1419        loc.location.object.gp_index = strtoull(initiator_obj_gp_index_s, NULL, 10);
1420        if (hwloc_type_sscanf(initiator_obj_type_s, &amp;loc.location.object.type, NULL, 0) &lt; 0) {
1421          if (hwloc__xml_verbose())
1422            fprintf(stderr, &quot;%s: failed to identify memattr_value initiator object type %s\n&quot;,
1423                    state-&gt;global-&gt;msgprefix, initiator_obj_type_s);
1424          return -1;
1425        }
1426      }
1427      hwloc_internal_memattr_set_value(topology, id, target_obj_type, target_obj_gp_index, (unsigned)-1, &amp;loc, value);
1428      if (loc.type == HWLOC_LOCATION_TYPE_CPUSET)
1429        hwloc_bitmap_free(loc.location.cpuset);
1430    } else {
1431      hwloc_internal_memattr_set_value(topology, id, target_obj_type, target_obj_gp_index, (unsigned)-1, NULL, value);
1432    }
1433    return 0;
1434  }
1435  static int
1436  hwloc__xml_import_memattr(hwloc_topology_t topology,
1437                            hwloc__xml_import_state_t state)
1438  {
1439    char *name = NULL;
1440    unsigned long flags = (unsigned long) -1;
1441    hwloc_memattr_id_t id = (hwloc_memattr_id_t) -1;
1442    int ret;
1443    while (1) {
1444      char *attrname, *attrvalue;
1445      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1446        break;
1447      if (!strcmp(attrname, &quot;name&quot;))
1448        name = attrvalue;
1449      else if (!strcmp(attrname, &quot;flags&quot;))
1450        flags = strtoul(attrvalue, NULL, 10);
1451      else {
1452        if (hwloc__xml_verbose())
1453          fprintf(stderr, &quot;%s: ignoring unknown memattr attribute %s\n&quot;,
1454                  state-&gt;global-&gt;msgprefix, attrname);
1455        return -1;
1456      }
1457    }
1458    if (name &amp;&amp; flags != (unsigned long) -1
1459        &amp;&amp; !(topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS)) {
1460      hwloc_memattr_id_t _id;
1461      ret = hwloc_memattr_get_by_name(topology, name, &amp;_id);
1462      if (ret &lt; 0) {
1463        ret = hwloc_memattr_register(topology, name, flags, &amp;_id);
1464        if (!ret)
1465          id = _id;
1466      } else {
1467        unsigned long mflags;
1468        ret = hwloc_memattr_get_flags(topology, _id, &amp;mflags);
1469        if (!ret &amp;&amp; mflags == flags)
1470          id = _id;
1471      }
1472    }
1473    while (1) {
1474      struct hwloc__xml_import_state_s childstate;
1475      char *tag;
1476      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1477      if (ret &lt;= 0)
1478        break;
1479      if (!strcmp(tag, &quot;memattr_value&quot;)) {
1480        ret = hwloc__xml_import_memattr_value(topology, id, flags, &amp;childstate);
1481      } else {
1482        if (hwloc__xml_verbose())
1483          fprintf(stderr, &quot;%s: memattr with unrecognized child %s\n&quot;,
1484                  state-&gt;global-&gt;msgprefix, tag);
1485        ret = -1;
1486      }
1487      if (ret &lt; 0)
1488        goto error;
1489      state-&gt;global-&gt;close_child(&amp;childstate);
1490    }
1491    return state-&gt;global-&gt;close_tag(state);
1492   error:
1493    return -1;
1494  }
1495  static int
1496  hwloc__xml_import_cpukind(hwloc_topology_t topology,
1497                            hwloc__xml_import_state_t state)
1498  {
1499    hwloc_bitmap_t cpuset = NULL;
1500    int forced_efficiency = HWLOC_CPUKIND_EFFICIENCY_UNKNOWN;
1501    unsigned nr_infos = 0;
1502    struct hwloc_info_s *infos = NULL;
1503    int ret;
1504    while (1) {
1505      char *attrname, *attrvalue;
1506      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1507        break;
1508      if (!strcmp(attrname, &quot;cpuset&quot;)) {
1509        if (!cpuset)
1510          cpuset = hwloc_bitmap_alloc();
1511        hwloc_bitmap_sscanf(cpuset, attrvalue);
1512      } else if (!strcmp(attrname, &quot;forced_efficiency&quot;)) {
1513        forced_efficiency = atoi(attrvalue);
1514      } else {
1515        if (hwloc__xml_verbose())
1516          fprintf(stderr, &quot;%s: ignoring unknown cpukind attribute %s\n&quot;,
1517                  state-&gt;global-&gt;msgprefix, attrname);
1518        hwloc_bitmap_free(cpuset);
1519        return -1;
1520      }
1521    }
1522    while (1) {
1523      struct hwloc__xml_import_state_s childstate;
1524      char *tag;
1525      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1526      if (ret &lt;= 0)
1527        break;
1528      if (!strcmp(tag, &quot;info&quot;)) {
1529        char *infoname = NULL;
1530        char *infovalue = NULL;
1531        ret = hwloc___xml_import_info(&amp;infoname, &amp;infovalue, &amp;childstate);
1532        if (!ret &amp;&amp; infoname &amp;&amp; infovalue)
1533          hwloc__add_info(&amp;infos, &amp;nr_infos, infoname, infovalue);
1534      } else {
1535        if (hwloc__xml_verbose())
1536          fprintf(stderr, &quot;%s: cpukind with unrecognized child %s\n&quot;,
1537                  state-&gt;global-&gt;msgprefix, tag);
1538        ret = -1;
1539      }
1540      if (ret &lt; 0)
1541        goto error;
1542      state-&gt;global-&gt;close_child(&amp;childstate);
1543    }
1544    if (!cpuset) {
1545      if (hwloc__xml_verbose())
1546        fprintf(stderr, &quot;%s: ignoring cpukind without cpuset\n&quot;,
1547                state-&gt;global-&gt;msgprefix);
1548      goto error;
1549    }
1550    if (topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS) {
1551      hwloc__free_infos(infos, nr_infos);
1552      hwloc_bitmap_free(cpuset);
1553    } else {
1554      hwloc_internal_cpukinds_register(topology, cpuset, forced_efficiency, infos, nr_infos, HWLOC_CPUKINDS_REGISTER_FLAG_OVERWRITE_FORCED_EFFICIENCY);
1555      hwloc__free_infos(infos, nr_infos);
1556    }
1557    return state-&gt;global-&gt;close_tag(state);
1558   error:
1559    hwloc__free_infos(infos, nr_infos);
1560    hwloc_bitmap_free(cpuset);
1561    return -1;
1562  }
1563  static int
1564  hwloc__xml_import_diff_one(hwloc__xml_import_state_t state,
1565  			   hwloc_topology_diff_t *firstdiffp,
1566  			   hwloc_topology_diff_t *lastdiffp)
1567  {
1568    char *type_s = NULL;
1569    char *obj_depth_s = NULL;
1570    char *obj_index_s = NULL;
1571    char *obj_attr_type_s = NULL;
1572    char *obj_attr_name_s = NULL;
1573    char *obj_attr_oldvalue_s = NULL;
1574    char *obj_attr_newvalue_s = NULL;
1575    while (1) {
1576      char *attrname, *attrvalue;
1577      if (state-&gt;global-&gt;next_attr(state, &amp;attrname, &amp;attrvalue) &lt; 0)
1578        break;
1579      if (!strcmp(attrname, &quot;type&quot;))
1580        type_s = attrvalue;
1581      else if (!strcmp(attrname, &quot;obj_depth&quot;))
1582        obj_depth_s = attrvalue;
1583      else if (!strcmp(attrname, &quot;obj_index&quot;))
1584        obj_index_s = attrvalue;
1585      else if (!strcmp(attrname, &quot;obj_attr_type&quot;))
1586        obj_attr_type_s = attrvalue;
1587      else if (!strcmp(attrname, &quot;obj_attr_index&quot;))
1588        { &amp;bsol;* obj_attr_index_s = attrvalue; unused for now */ }
1589      else if (!strcmp(attrname, &quot;obj_attr_name&quot;))
1590        obj_attr_name_s = attrvalue;
1591      else if (!strcmp(attrname, &quot;obj_attr_oldvalue&quot;))
1592        obj_attr_oldvalue_s = attrvalue;
1593      else if (!strcmp(attrname, &quot;obj_attr_newvalue&quot;))
1594        obj_attr_newvalue_s = attrvalue;
1595      else {
1596        if (hwloc__xml_verbose())
1597  	fprintf(stderr, &quot;%s: ignoring unknown diff attribute %s\n&quot;,
1598  		state-&gt;global-&gt;msgprefix, attrname);
1599        return -1;
1600      }
1601    }
1602    if (type_s) {
1603      switch (atoi(type_s)) {
1604      default:
1605        break;
1606      case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR: {
1607        hwloc_topology_diff_obj_attr_type_t obj_attr_type;
1608        hwloc_topology_diff_t diff;
1609        if (!obj_depth_s || !obj_index_s || !obj_attr_type_s) {
1610  	if (hwloc__xml_verbose())
1611  	  fprintf(stderr, &quot;%s: missing mandatory obj attr generic attributes\n&quot;,
1612  		  state-&gt;global-&gt;msgprefix);
1613  	break;
1614        }
1615        if (!obj_attr_oldvalue_s || !obj_attr_newvalue_s) {
1616  	if (hwloc__xml_verbose())
1617  	  fprintf(stderr, &quot;%s: missing mandatory obj attr value attributes\n&quot;,
1618  		  state-&gt;global-&gt;msgprefix);
1619  	break;
1620        }
1621        obj_attr_type = atoi(obj_attr_type_s);
1622        if (obj_attr_type == HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO &amp;&amp; !obj_attr_name_s) {
1623  	if (hwloc__xml_verbose())
1624  	  fprintf(stderr, &quot;%s: missing mandatory obj attr info name attribute\n&quot;,
1625  		  state-&gt;global-&gt;msgprefix);
1626  	break;
1627        }
1628        diff = malloc(sizeof(*diff));
1629        if (!diff)
1630  	return -1;
1631        diff-&gt;obj_attr.type = HWLOC_TOPOLOGY_DIFF_OBJ_ATTR;
1632        diff-&gt;obj_attr.obj_depth = atoi(obj_depth_s);
1633        diff-&gt;obj_attr.obj_index = atoi(obj_index_s);
1634        memset(&amp;diff-&gt;obj_attr.diff, 0, sizeof(diff-&gt;obj_attr.diff));
1635        diff-&gt;obj_attr.diff.generic.type = obj_attr_type;
1636        switch (obj_attr_type) {
1637        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
1638  	diff-&gt;obj_attr.diff.uint64.oldvalue = strtoull(obj_attr_oldvalue_s, NULL, 0);
1639  	diff-&gt;obj_attr.diff.uint64.newvalue = strtoull(obj_attr_newvalue_s, NULL, 0);
1640  	break;
1641        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
1642  	diff-&gt;obj_attr.diff.string.name = strdup(obj_attr_name_s);
1643        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
1644  	diff-&gt;obj_attr.diff.string.oldvalue = strdup(obj_attr_oldvalue_s);
1645  	diff-&gt;obj_attr.diff.string.newvalue = strdup(obj_attr_newvalue_s);
1646  	break;
1647        }
1648        if (*firstdiffp)
1649  	(*lastdiffp)-&gt;generic.next = diff;
1650        else
1651          *firstdiffp = diff;
1652        *lastdiffp = diff;
1653        diff-&gt;generic.next = NULL;
1654      }
1655      }
1656    }
1657    return state-&gt;global-&gt;close_tag(state);
1658  }
1659  int
1660  hwloc__xml_import_diff(hwloc__xml_import_state_t state,
1661  		       hwloc_topology_diff_t *firstdiffp)
1662  {
1663    hwloc_topology_diff_t firstdiff = NULL, lastdiff = NULL;
1664    *firstdiffp = NULL;
1665    while (1) {
1666      struct hwloc__xml_import_state_s childstate;
1667      char *tag;
1668      int ret;
1669      ret = state-&gt;global-&gt;find_child(state, &amp;childstate, &amp;tag);
1670      if (ret &lt; 0)
1671        return -1;
1672      if (!ret)
1673        break;
1674      if (!strcmp(tag, &quot;diff&quot;)) {
1675        ret = hwloc__xml_import_diff_one(&amp;childstate, &amp;firstdiff, &amp;lastdiff);
1676      } else
1677        ret = -1;
1678      if (ret &lt; 0)
1679        return ret;
1680      state-&gt;global-&gt;close_child(&amp;childstate);
1681    }
1682    *firstdiffp = firstdiff;
1683    return 0;
1684  }
1685  static void
1686  hwloc_convert_from_v1dist_floats(hwloc_topology_t topology, unsigned nbobjs, float *floats, uint64_t *u64s)
1687  {
1688    unsigned i;
1689    int is_uint;
1690    char *env;
1691    float scale = 1000.f;
1692    char scalestring[20];
1693    env = getenv(&quot;HWLOC_XML_V1DIST_SCALE&quot;);
1694    if (env) {
1695      scale = (float) atof(env);
1696      goto scale;
1697    }
1698    is_uint = 1;
1699    for(i=0; i&lt;nbobjs*nbobjs; i++) {
1700      float f, iptr, fptr;
1701      f = floats[i];
1702      if (f &lt; 0.f) {
1703        is_uint = 0;
1704        break;
1705      }
1706      fptr = modff(f, &amp;iptr);
1707      if (fptr &gt; .001f &amp;&amp; fptr &lt; .999f) {
1708        is_uint = 0;
1709        break;
1710      }
1711      u64s[i] = (int)(f+.5f);
1712    }
1713    if (is_uint)
1714      return;
1715   scale:
1716    for(i=0; i&lt;nbobjs*nbobjs; i++)
1717      u64s[i] = (uint64_t)(scale * floats[i]);
1718    sprintf(scalestring, &quot;%f&quot;, scale);
1719    hwloc_obj_add_info(hwloc_get_root_obj(topology), &quot;xmlv1DistancesScale&quot;, scalestring);
1720  }
1721  static int
1722  hwloc_look_xml(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
1723  {
1724    struct hwloc_topology *topology = backend-&gt;topology;
1725    struct hwloc_xml_backend_data_s *data = backend-&gt;private_data;
1726    struct hwloc__xml_import_state_s state, childstate;
1727    struct hwloc_obj *root = topology-&gt;levels[0][0];
1728    char *tag;
1729    int gotignored = 0;
1730    hwloc_localeswitch_declare;
1731    int ret;
1732    assert(dstatus-&gt;phase == HWLOC_DISC_PHASE_GLOBAL);
1733    state.global = data;
1734    assert(!root-&gt;cpuset);
1735    hwloc_localeswitch_init();
1736    data-&gt;nbnumanodes = 0;
1737    data-&gt;first_numanode = data-&gt;last_numanode = NULL;
1738    data-&gt;first_v1dist = data-&gt;last_v1dist = NULL;
1739    ret = data-&gt;look_init(data, &amp;state);
1740    if (ret &lt; 0)
1741      goto failed;
1742    if (data-&gt;version_major &gt; 2) {
1743      if (hwloc__xml_verbose())
1744        fprintf(stderr, &quot;%s: cannot import XML version %u.%u &gt; 2\n&quot;,
1745  	      data-&gt;msgprefix, data-&gt;version_major, data-&gt;version_minor);
1746      goto err;
1747    }
1748    ret = state.global-&gt;find_child(&amp;state, &amp;childstate, &amp;tag);
1749    if (ret &lt; 0 || !ret || strcmp(tag, &quot;object&quot;))
1750      goto failed;
1751    ret = hwloc__xml_import_object(topology, data, NULL &amp;bsol;*  no parent */, root,
1752  				 &amp;gotignored,
1753  				 &amp;childstate);
1754    if (ret &lt; 0)
1755      goto failed;
1756    state.global-&gt;close_child(&amp;childstate);
1757    assert(!gotignored);
1758    root = topology-&gt;levels[0][0];
1759    if (data-&gt;version_major &gt;= 2) {
1760      while (1) {
1761        ret = state.global-&gt;find_child(&amp;state, &amp;childstate, &amp;tag);
1762        if (ret &lt; 0)
1763  	goto failed;
1764        if (!ret)
1765  	break;
1766        if (!strcmp(tag, &quot;distances2&quot;)) {
1767  	ret = hwloc__xml_v2import_distances(topology, &amp;childstate, 0);
1768  	if (ret &lt; 0)
1769  	  goto failed;
1770        } else if (!strcmp(tag, &quot;distances2hetero&quot;)) {
1771  	ret = hwloc__xml_v2import_distances(topology, &amp;childstate, 1);
1772  	if (ret &lt; 0)
1773  	  goto failed;
1774        } else if (!strcmp(tag, &quot;support&quot;)) {
1775  	ret = hwloc__xml_v2import_support(topology, &amp;childstate);
1776  	if (ret &lt; 0)
1777  	  goto failed;
1778        } else if (!strcmp(tag, &quot;memattr&quot;)) {
1779          ret = hwloc__xml_import_memattr(topology, &amp;childstate);
1780          if (ret &lt; 0)
1781            goto failed;
1782        } else if (!strcmp(tag, &quot;cpukind&quot;)) {
1783          ret = hwloc__xml_import_cpukind(topology, &amp;childstate);
1784          if (ret &lt; 0)
1785            goto failed;
1786        } else {
1787  	if (hwloc__xml_verbose())
1788  	  fprintf(stderr, &quot;%s: ignoring unknown tag `%s&#x27; after root object.\n&quot;,
1789  		  data-&gt;msgprefix, tag);
1790  	goto done;
1791        }
1792        state.global-&gt;close_child(&amp;childstate);
1793      }
1794    }
1795    state.global-&gt;close_tag(&amp;state);
1796  done:
1797    if (!root-&gt;cpuset) {
1798      if (hwloc__xml_verbose())
1799        fprintf(stderr, &quot;%s: invalid root object without cpuset\n&quot;,
1800  	      data-&gt;msgprefix);
1801      goto err;
1802    }
1803    if (data-&gt;version_major &lt; 2 &amp;&amp; data-&gt;first_numanode) {
1804      hwloc_obj_t node = data-&gt;first_numanode;
1805      do {
1806        if (node-&gt;parent-&gt;type == HWLOC_OBJ_GROUP
1807  	  &amp;&amp; !node-&gt;parent-&gt;gp_index)
1808  	node-&gt;parent-&gt;gp_index = topology-&gt;next_gp_index++;
1809        node = node-&gt;next_cousin;
1810      } while (node);
1811    }
1812    if (data-&gt;version_major &lt; 2 &amp;&amp; data-&gt;first_v1dist) {
1813      struct hwloc__xml_imported_v1distances_s *v1dist, *v1next = data-&gt;first_v1dist;
1814      while ((v1dist = v1next) != NULL) {
1815        unsigned nbobjs = v1dist-&gt;nbobjs;
1816        v1next = v1dist-&gt;next;
1817        if (nbobjs == data-&gt;nbnumanodes
1818            &amp;&amp; !(topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_DISTANCES)) {
1819  	hwloc_obj_t *objs = malloc(nbobjs*sizeof(hwloc_obj_t));
1820  	uint64_t *values = malloc(nbobjs*nbobjs*sizeof(*values));
1821          assert(data-&gt;nbnumanodes &gt; 0); &amp;bsol;* v1dist-&gt;nbobjs is &gt;0 after import */
1822          assert(data-&gt;first_numanode);
1823  	if (objs &amp;&amp; values) {
1824  	  hwloc_obj_t node;
1825  	  unsigned i;
1826  	  for(i=0, node = data-&gt;first_numanode;
1827  	      i&lt;nbobjs;
1828  	      i++, node = node-&gt;next_cousin)
1829  	    objs[i] = node;
1830  	  hwloc_convert_from_v1dist_floats(topology, nbobjs, v1dist-&gt;floats, values);
1831  	  hwloc_internal_distances_add(topology, NULL, nbobjs, objs, values, v1dist-&gt;kind, 0);
1832  	} else {
1833  	  free(objs);
1834  	  free(values);
1835  	}
1836        }
1837        free(v1dist-&gt;floats);
1838        free(v1dist);
1839      }
1840      data-&gt;first_v1dist = data-&gt;last_v1dist = NULL;
1841    }
1842    if (data-&gt;version_major &gt;= 2) {
1843      if (!root-&gt;nodeset) {
1844        if (hwloc__xml_verbose())
1845  	fprintf(stderr, &quot;%s: invalid root object without nodeset\n&quot;,
1846  		data-&gt;msgprefix);
1847        goto err;
1848      }
1849      if (hwloc_bitmap_iszero(root-&gt;nodeset)) {
1850        if (hwloc__xml_verbose())
1851  	fprintf(stderr, &quot;%s: invalid root object with empty nodeset\n&quot;,
1852  		data-&gt;msgprefix);
1853        goto err;
1854      }
1855    } else {
1856    }
1857    hwloc_alloc_root_sets(root);
1858    if (!(topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT)) {
1859      topology-&gt;support.discovery-&gt;pu = 1;
1860      topology-&gt;support.discovery-&gt;disallowed_pu = 1;
1861      if (data-&gt;nbnumanodes) {
1862        topology-&gt;support.discovery-&gt;numa = 1;
1863        topology-&gt;support.discovery-&gt;numa_memory = 1; 
1864        topology-&gt;support.discovery-&gt;disallowed_numa = 1;
1865      }
1866    }
1867    if (data-&gt;look_done)
1868      data-&gt;look_done(data, 0);
1869    hwloc_localeswitch_fini();
1870    return 0;
1871   failed:
1872    if (data-&gt;look_done)
1873      data-&gt;look_done(data, -1);
1874    if (hwloc__xml_verbose())
1875      fprintf(stderr, &quot;%s: XML component discovery failed.\n&quot;,
1876  	    data-&gt;msgprefix);
1877   err:
1878    hwloc_free_object_siblings_and_children(root-&gt;first_child);
1879    root-&gt;first_child = NULL;
1880    hwloc_free_object_siblings_and_children(root-&gt;memory_first_child);
1881    root-&gt;memory_first_child = NULL;
1882    hwloc_free_object_siblings_and_children(root-&gt;io_first_child);
1883    root-&gt;io_first_child = NULL;
1884    hwloc_free_object_siblings_and_children(root-&gt;misc_first_child);
1885    root-&gt;misc_first_child = NULL;
1886    if (root-&gt;cpuset)
1887      hwloc_bitmap_zero(root-&gt;cpuset);
1888    if (root-&gt;nodeset)
1889      hwloc_bitmap_zero(root-&gt;nodeset);
1890    hwloc_localeswitch_fini();
1891    return -1;
1892  }
1893  int
1894  hwloc_topology_diff_load_xml(const char *xmlpath,
1895  			     hwloc_topology_diff_t *firstdiffp, char **refnamep)
1896  {
1897    struct hwloc__xml_import_state_s state;
1898    struct hwloc_xml_backend_data_s fakedata; &amp;bsol;* only for storing global info during parsing */
1899    hwloc_localeswitch_declare;
1900    const char *local_basename;
1901    int force_nolibxml;
1902    int ret;
1903    state.global = &amp;fakedata;
1904    local_basename = strrchr(xmlpath, &#x27;/&#x27;);
1905    if (local_basename)
1906      local_basename++;
1907    else
1908      local_basename = xmlpath;
1909    fakedata.msgprefix = strdup(local_basename);
1910    hwloc_components_init();
1911    assert(hwloc_nolibxml_callbacks);
1912    hwloc_localeswitch_init();
1913    *firstdiffp = NULL;
1914    force_nolibxml = hwloc_nolibxml_import();
1915  retry:
1916    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
1917      ret = hwloc_nolibxml_callbacks-&gt;import_diff(&amp;state, xmlpath, NULL, 0, firstdiffp, refnamep);
1918    else {
1919      ret = hwloc_libxml_callbacks-&gt;import_diff(&amp;state, xmlpath, NULL, 0, firstdiffp, refnamep);
1920      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
1921        hwloc_libxml_callbacks = NULL;
1922        goto retry;
1923      }
1924    }
1925    hwloc_localeswitch_fini();
1926    hwloc_components_fini();
1927    free(fakedata.msgprefix);
1928    return ret;
1929  }
1930  int
1931  hwloc_topology_diff_load_xmlbuffer(const char *xmlbuffer, int buflen,
1932  				   hwloc_topology_diff_t *firstdiffp, char **refnamep)
1933  {
1934    struct hwloc__xml_import_state_s state;
1935    struct hwloc_xml_backend_data_s fakedata; &amp;bsol;* only for storing global info during parsing */
1936    hwloc_localeswitch_declare;
1937    int force_nolibxml;
1938    int ret;
1939    state.global = &amp;fakedata;
1940    fakedata.msgprefix = strdup(&quot;xmldiffbuffer&quot;);
1941    hwloc_components_init();
1942    assert(hwloc_nolibxml_callbacks);
1943    hwloc_localeswitch_init();
1944    *firstdiffp = NULL;
1945    force_nolibxml = hwloc_nolibxml_import();
1946   retry:
1947    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
1948      ret = hwloc_nolibxml_callbacks-&gt;import_diff(&amp;state, NULL, xmlbuffer, buflen, firstdiffp, refnamep);
1949    else {
1950      ret = hwloc_libxml_callbacks-&gt;import_diff(&amp;state, NULL, xmlbuffer, buflen, firstdiffp, refnamep);
1951      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
1952        hwloc_libxml_callbacks = NULL;
1953        goto retry;
1954      }
1955    }
1956    hwloc_localeswitch_fini();
1957    hwloc_components_fini();
1958    free(fakedata.msgprefix);
1959    return ret;
1960  }
1961  #define HWLOC_XML_CHAR_VALID(c) (((c) &gt;= 32 &amp;&amp; (c) &lt;= 126) || (c) == &#x27;\t&#x27; || (c) == &#x27;\n&#x27; || (c) == &#x27;\r&#x27;)
1962  static int
1963  hwloc__xml_export_check_buffer(const char *buf, size_t length)
1964  {
1965    unsigned i;
1966    for(i=0; i&lt;length; i++)
1967      if (!HWLOC_XML_CHAR_VALID(buf[i]))
1968        return -1;
1969    return 0;
1970  }
1971  static char*
1972  hwloc__xml_export_safestrdup(const char *old)
1973  {
1974    char *new = malloc(strlen(old)+1);
1975    char *dst = new;
1976    const char *src = old;
1977    if (!new)
1978      return NULL;
1979    while (*src) {
1980      if (HWLOC_XML_CHAR_VALID(*src))
1981        *(dst++) = *src;
1982      src++;
1983    }
1984    *dst = &#x27;\0&#x27;;
1985    return new;
1986  }
1987  static void
1988  hwloc__xml_export_object_contents (hwloc__xml_export_state_t state, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
1989  {
1990    char *setstring = NULL, *setstring2 = NULL;
1991    char tmp[255];
1992    int v1export = flags &amp; HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1;
1993    unsigned i,j;
1994    if (v1export &amp;&amp; obj-&gt;type == HWLOC_OBJ_PACKAGE)
1995      state-&gt;new_prop(state, &quot;type&quot;, &quot;Socket&quot;);
1996    else if (v1export &amp;&amp; obj-&gt;type == HWLOC_OBJ_DIE)
1997      state-&gt;new_prop(state, &quot;type&quot;, &quot;Group&quot;);
1998    else if (v1export &amp;&amp; hwloc__obj_type_is_cache(obj-&gt;type))
1999      state-&gt;new_prop(state, &quot;type&quot;, &quot;Cache&quot;);
2000    else
2001      state-&gt;new_prop(state, &quot;type&quot;, hwloc_obj_type_string(obj-&gt;type));
2002    if (obj-&gt;os_index != HWLOC_UNKNOWN_INDEX) {
2003      sprintf(tmp, &quot;%u&quot;, obj-&gt;os_index);
2004      state-&gt;new_prop(state, &quot;os_index&quot;, tmp);
2005    }
2006    if (obj-&gt;cpuset) {
2007      int empty_cpusets = 0;
2008      if (v1export &amp;&amp; obj-&gt;type == HWLOC_OBJ_NUMANODE) {
2009        hwloc_obj_t parent = obj;
2010        while (!hwloc_obj_type_is_normal(parent-&gt;type)) {
2011  	if (parent-&gt;sibling_rank &gt; 0) {
2012  	  empty_cpusets = 1;
2013  	  break;
2014  	}
2015  	parent = parent-&gt;parent;
2016        }
2017      }
2018      if (empty_cpusets) {
2019        state-&gt;new_prop(state, &quot;cpuset&quot;, &quot;0x0&quot;);
2020        state-&gt;new_prop(state, &quot;online_cpuset&quot;, &quot;0x0&quot;);
2021        state-&gt;new_prop(state, &quot;complete_cpuset&quot;, &quot;0x0&quot;);
2022        state-&gt;new_prop(state, &quot;allowed_cpuset&quot;, &quot;0x0&quot;);
2023      } else {
2024        hwloc_bitmap_asprintf(&amp;setstring, obj-&gt;cpuset);
2025        state-&gt;new_prop(state, &quot;cpuset&quot;, setstring);
2026        hwloc_bitmap_asprintf(&amp;setstring2, obj-&gt;complete_cpuset);
2027        state-&gt;new_prop(state, &quot;complete_cpuset&quot;, setstring2);
2028        free(setstring2);
2029        if (v1export)
2030  	state-&gt;new_prop(state, &quot;online_cpuset&quot;, setstring);
2031        free(setstring);
2032        if (v1export) {
2033  	hwloc_bitmap_t allowed_cpuset = hwloc_bitmap_dup(obj-&gt;cpuset);
2034  	hwloc_bitmap_and(allowed_cpuset, allowed_cpuset, topology-&gt;allowed_cpuset);
2035  	hwloc_bitmap_asprintf(&amp;setstring, allowed_cpuset);
2036  	state-&gt;new_prop(state, &quot;allowed_cpuset&quot;, setstring);
2037  	free(setstring);
2038  	hwloc_bitmap_free(allowed_cpuset);
2039        } else if (!obj-&gt;parent) {
2040  	hwloc_bitmap_asprintf(&amp;setstring, topology-&gt;allowed_cpuset);
2041  	state-&gt;new_prop(state, &quot;allowed_cpuset&quot;, setstring);
2042  	free(setstring);
2043        }
2044      }
2045      hwloc_bitmap_asprintf(&amp;setstring, obj-&gt;nodeset);
2046      state-&gt;new_prop(state, &quot;nodeset&quot;, setstring);
2047      free(setstring);
2048      hwloc_bitmap_asprintf(&amp;setstring, obj-&gt;complete_nodeset);
2049      state-&gt;new_prop(state, &quot;complete_nodeset&quot;, setstring);
2050      free(setstring);
2051      if (v1export) {
2052        hwloc_bitmap_t allowed_nodeset = hwloc_bitmap_dup(obj-&gt;nodeset);
2053        hwloc_bitmap_and(allowed_nodeset, allowed_nodeset, topology-&gt;allowed_nodeset);
2054        hwloc_bitmap_asprintf(&amp;setstring, allowed_nodeset);
2055        state-&gt;new_prop(state, &quot;allowed_nodeset&quot;, setstring);
2056        free(setstring);
2057        hwloc_bitmap_free(allowed_nodeset);
2058      } else if (!obj-&gt;parent) {
2059        hwloc_bitmap_asprintf(&amp;setstring, topology-&gt;allowed_nodeset);
2060        state-&gt;new_prop(state, &quot;allowed_nodeset&quot;, setstring);
2061        free(setstring);
2062      }
2063    }
2064    if (!v1export) {
2065      sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;gp_index);
2066      state-&gt;new_prop(state, &quot;gp_index&quot;, tmp);
2067    }
2068    if (obj-&gt;name) {
2069      char *name = hwloc__xml_export_safestrdup(obj-&gt;name);
2070      if (name) {
2071        state-&gt;new_prop(state, &quot;name&quot;, name);
2072        free(name);
2073      }
2074    }
2075    if (!v1export &amp;&amp; obj-&gt;subtype) {
2076      char *subtype = hwloc__xml_export_safestrdup(obj-&gt;subtype);
2077      if (subtype) {
2078        state-&gt;new_prop(state, &quot;subtype&quot;, subtype);
2079        free(subtype);
2080      }
2081    }
2082    switch (obj-&gt;type) {
2083    case HWLOC_OBJ_NUMANODE:
2084      if (obj-&gt;attr-&gt;numanode.local_memory) {
2085        sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;attr-&gt;numanode.local_memory);
2086        state-&gt;new_prop(state, &quot;local_memory&quot;, tmp);
2087      }
2088      for(i=0; i&lt;obj-&gt;attr-&gt;numanode.page_types_len; i++) {
2089        struct hwloc__xml_export_state_s childstate;
2090        state-&gt;new_child(state, &amp;childstate, &quot;page_type&quot;);
2091        sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;attr-&gt;numanode.page_types[i].size);
2092        childstate.new_prop(&amp;childstate, &quot;size&quot;, tmp);
2093        sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;attr-&gt;numanode.page_types[i].count);
2094        childstate.new_prop(&amp;childstate, &quot;count&quot;, tmp);
2095        childstate.end_object(&amp;childstate, &quot;page_type&quot;);
2096      }
2097      break;
2098    case HWLOC_OBJ_L1CACHE:
2099    case HWLOC_OBJ_L2CACHE:
2100    case HWLOC_OBJ_L3CACHE:
2101    case HWLOC_OBJ_L4CACHE:
2102    case HWLOC_OBJ_L5CACHE:
2103    case HWLOC_OBJ_L1ICACHE:
2104    case HWLOC_OBJ_L2ICACHE:
2105    case HWLOC_OBJ_L3ICACHE:
2106    case HWLOC_OBJ_MEMCACHE:
2107      sprintf(tmp, &quot;%llu&quot;, (unsigned long long) obj-&gt;attr-&gt;cache.size);
2108      state-&gt;new_prop(state, &quot;cache_size&quot;, tmp);
2109      sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;cache.depth);
2110      state-&gt;new_prop(state, &quot;depth&quot;, tmp);
2111      sprintf(tmp, &quot;%u&quot;, (unsigned) obj-&gt;attr-&gt;cache.linesize);
2112      state-&gt;new_prop(state, &quot;cache_linesize&quot;, tmp);
2113      sprintf(tmp, &quot;%d&quot;, obj-&gt;attr-&gt;cache.associativity);
2114      state-&gt;new_prop(state, &quot;cache_associativity&quot;, tmp);
2115      sprintf(tmp, &quot;%d&quot;, (int) obj-&gt;attr-&gt;cache.type);
2116      state-&gt;new_prop(state, &quot;cache_type&quot;, tmp);
2117      break;
2118    case HWLOC_OBJ_GROUP:
2119      if (v1export) {
2120        sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;group.depth);
2121        state-&gt;new_prop(state, &quot;depth&quot;, tmp);
2122        if (obj-&gt;attr-&gt;group.dont_merge)
2123          state-&gt;new_prop(state, &quot;dont_merge&quot;, &quot;1&quot;);
2124      } else {
2125        sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;group.kind);
2126        state-&gt;new_prop(state, &quot;kind&quot;, tmp);
2127        sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;group.subkind);
2128        state-&gt;new_prop(state, &quot;subkind&quot;, tmp);
2129        if (obj-&gt;attr-&gt;group.dont_merge)
2130          state-&gt;new_prop(state, &quot;dont_merge&quot;, &quot;1&quot;);
2131      }
2132      break;
2133    case HWLOC_OBJ_BRIDGE:
2134      sprintf(tmp, &quot;%d-%d&quot;, (int) obj-&gt;attr-&gt;bridge.upstream_type, (int) obj-&gt;attr-&gt;bridge.downstream_type);
2135      state-&gt;new_prop(state, &quot;bridge_type&quot;, tmp);
2136      sprintf(tmp, &quot;%u&quot;, obj-&gt;attr-&gt;bridge.depth);
2137      state-&gt;new_prop(state, &quot;depth&quot;, tmp);
2138      if (obj-&gt;attr-&gt;bridge.downstream_type == HWLOC_OBJ_BRIDGE_PCI) {
2139        sprintf(tmp, &quot;%04x:[%02x-%02x]&quot;,
2140  	      (unsigned) obj-&gt;attr-&gt;bridge.downstream.pci.domain,
2141  	      (unsigned) obj-&gt;attr-&gt;bridge.downstream.pci.secondary_bus,
2142  	      (unsigned) obj-&gt;attr-&gt;bridge.downstream.pci.subordinate_bus);
2143        state-&gt;new_prop(state, &quot;bridge_pci&quot;, tmp);
2144      }
2145      if (obj-&gt;attr-&gt;bridge.upstream_type != HWLOC_OBJ_BRIDGE_PCI)
2146        break;
2147    case HWLOC_OBJ_PCI_DEVICE:
2148      sprintf(tmp, &quot;%04x:%02x:%02x.%01x&quot;,
2149  	    (unsigned) obj-&gt;attr-&gt;pcidev.domain,
2150  	    (unsigned) obj-&gt;attr-&gt;pcidev.bus,
2151  	    (unsigned) obj-&gt;attr-&gt;pcidev.dev,
2152  	    (unsigned) obj-&gt;attr-&gt;pcidev.func);
2153      state-&gt;new_prop(state, &quot;pci_busid&quot;, tmp);
2154      sprintf(tmp, &quot;%04x [%04x:%04x] [%04x:%04x] %02x&quot;,
2155  	    (unsigned) obj-&gt;attr-&gt;pcidev.class_id,
2156  	    (unsigned) obj-&gt;attr-&gt;pcidev.vendor_id, (unsigned) obj-&gt;attr-&gt;pcidev.device_id,
2157  	    (unsigned) obj-&gt;attr-&gt;pcidev.subvendor_id, (unsigned) obj-&gt;attr-&gt;pcidev.subdevice_id,
2158  	    (unsigned) obj-&gt;attr-&gt;pcidev.revision);
2159      state-&gt;new_prop(state, &quot;pci_type&quot;, tmp);
2160      sprintf(tmp, &quot;%f&quot;, obj-&gt;attr-&gt;pcidev.linkspeed);
2161      state-&gt;new_prop(state, &quot;pci_link_speed&quot;, tmp);
2162      break;
2163    case HWLOC_OBJ_OS_DEVICE:
2164      sprintf(tmp, &quot;%d&quot;, (int) obj-&gt;attr-&gt;osdev.type);
2165      state-&gt;new_prop(state, &quot;osdev_type&quot;, tmp);
2166      break;
2167    default:
2168      break;
2169    }
2170    for(i=0; i&lt;obj-&gt;infos_count; i++) {
2171      char *name = hwloc__xml_export_safestrdup(obj-&gt;infos[i].name);
2172      char *value = hwloc__xml_export_safestrdup(obj-&gt;infos[i].value);
2173      if (name &amp;&amp; value) {
2174        struct hwloc__xml_export_state_s childstate;
2175        state-&gt;new_child(state, &amp;childstate, &quot;info&quot;);
2176        childstate.new_prop(&amp;childstate, &quot;name&quot;, name);
2177        childstate.new_prop(&amp;childstate, &quot;value&quot;, value);
2178        childstate.end_object(&amp;childstate, &quot;info&quot;);
2179      }
2180      free(name);
2181      free(value);
2182    }
2183    if (v1export &amp;&amp; obj-&gt;subtype) {
2184      char *subtype = hwloc__xml_export_safestrdup(obj-&gt;subtype);
2185      if (subtype) {
2186        struct hwloc__xml_export_state_s childstate;
2187        int is_coproctype = (obj-&gt;type == HWLOC_OBJ_OS_DEVICE &amp;&amp; obj-&gt;attr-&gt;osdev.type == HWLOC_OBJ_OSDEV_COPROC);
2188        state-&gt;new_child(state, &amp;childstate, &quot;info&quot;);
2189        childstate.new_prop(&amp;childstate, &quot;name&quot;, is_coproctype ? &quot;CoProcType&quot; : &quot;Type&quot;);
2190        childstate.new_prop(&amp;childstate, &quot;value&quot;, subtype);
2191        childstate.end_object(&amp;childstate, &quot;info&quot;);
2192        free(subtype);
2193      }
2194    }
2195    if (v1export &amp;&amp; obj-&gt;type == HWLOC_OBJ_DIE) {
2196      struct hwloc__xml_export_state_s childstate;
2197      state-&gt;new_child(state, &amp;childstate, &quot;info&quot;);
2198      childstate.new_prop(&amp;childstate, &quot;name&quot;, &quot;Type&quot;);
2199      childstate.new_prop(&amp;childstate, &quot;value&quot;, &quot;Die&quot;);
2200      childstate.end_object(&amp;childstate, &quot;info&quot;);
2201    }
2202    if (v1export &amp;&amp; !obj-&gt;parent) {
2203      struct hwloc_internal_distances_s *dist;
2204      hwloc_internal_distances_refresh(topology);
2205      for(dist = topology-&gt;first_dist; dist; dist = dist-&gt;next) {
2206        struct hwloc__xml_export_state_s childstate;
2207        unsigned nbobjs = dist-&gt;nbobjs;
2208        unsigned *logical_to_v2array;
2209        int depth;
2210        if (nbobjs != (unsigned) hwloc_get_nbobjs_by_type(topology, dist-&gt;unique_type))
2211  	continue;
2212        if (!(dist-&gt;kind &amp; HWLOC_DISTANCES_KIND_MEANS_LATENCY))
2213  	continue;
2214        if (dist-&gt;kind &amp; HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES)
2215  	continue;
2216        logical_to_v2array = malloc(nbobjs * sizeof(*logical_to_v2array));
2217        if (!logical_to_v2array) {
2218          if (HWLOC_SHOW_ALL_ERRORS())
2219            fprintf(stderr, &quot;hwloc/xml/export/v1: failed to allocated logical_to_v2array\n&quot;);
2220  	continue;
2221        }
2222        for(i=0; i&lt;nbobjs; i++)
2223  	logical_to_v2array[dist-&gt;objs[i]-&gt;logical_index] = i;
2224        if (dist-&gt;unique_type == HWLOC_OBJ_NUMANODE) {
2225  	depth = -1;
2226  	for(i=0; i&lt;nbobjs; i++) {
2227  	  hwloc_obj_t parent = dist-&gt;objs[i]-&gt;parent;
2228  	  while (hwloc__obj_type_is_memory(parent-&gt;type))
2229  	    parent = parent-&gt;parent;
2230  	  if (parent-&gt;depth+1 &gt; depth)
2231  	    depth = parent-&gt;depth+1;
2232  	}
2233        } else {
2234  	int parent_with_memory = 0;
2235  	for(i=0; i&lt;nbobjs; i++) {
2236  	  hwloc_obj_t parent = dist-&gt;objs[i]-&gt;parent;
2237  	  while (parent) {
2238  	    if (parent-&gt;memory_first_child) {
2239  	      parent_with_memory = 1;
2240  	      goto done;
2241  	    }
2242  	    parent = parent-&gt;parent;
2243  	  }
2244  	}
2245        done:
2246  	depth = hwloc_get_type_depth(topology, dist-&gt;unique_type) + parent_with_memory;
2247        }
2248        state-&gt;new_child(state, &amp;childstate, &quot;distances&quot;);
2249        sprintf(tmp, &quot;%u&quot;, nbobjs);
2250        childstate.new_prop(&amp;childstate, &quot;nbobjs&quot;, tmp);
2251        sprintf(tmp, &quot;%d&quot;, depth);
2252        childstate.new_prop(&amp;childstate, &quot;relative_depth&quot;, tmp);
2253        sprintf(tmp, &quot;%f&quot;, 1.f);
2254        childstate.new_prop(&amp;childstate, &quot;latency_base&quot;, tmp);
2255        for(i=0; i&lt;nbobjs; i++) {
2256          for(j=0; j&lt;nbobjs; j++) {
2257  	  unsigned k = logical_to_v2array[i]*nbobjs+logical_to_v2array[j];
2258  	  struct hwloc__xml_export_state_s greatchildstate;
2259  	  childstate.new_child(&amp;childstate, &amp;greatchildstate, &quot;latency&quot;);
2260  	  sprintf(tmp, &quot;%f&quot;, (float) dist-&gt;values[k]);
2261  	  greatchildstate.new_prop(&amp;greatchildstate, &quot;value&quot;, tmp);
2262  	  greatchildstate.end_object(&amp;greatchildstate, &quot;latency&quot;);
2263  	}
2264        }
2265        childstate.end_object(&amp;childstate, &quot;distances&quot;);
2266        free(logical_to_v2array);
2267      }
2268    }
2269    if (obj-&gt;userdata &amp;&amp; topology-&gt;userdata_export_cb)
2270      topology-&gt;userdata_export_cb((void*) state, topology, obj);
2271  }
2272  static void
2273  hwloc__xml_v2export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2274  {
2275    struct hwloc__xml_export_state_s state;
2276    hwloc_obj_t child;
2277    parentstate-&gt;new_child(parentstate, &amp;state, &quot;object&quot;);
2278    hwloc__xml_export_object_contents(&amp;state, topology, obj, flags);
2279    for_each_memory_child(child, obj)
2280      hwloc__xml_v2export_object (&amp;state, topology, child, flags);
2281    for_each_child(child, obj)
2282      hwloc__xml_v2export_object (&amp;state, topology, child, flags);
2283    for_each_io_child(child, obj)
2284      hwloc__xml_v2export_object (&amp;state, topology, child, flags);
2285    for_each_misc_child(child, obj)
2286      hwloc__xml_v2export_object (&amp;state, topology, child, flags);
2287    state.end_object(&amp;state, &quot;object&quot;);
2288  }
2289  static void
2290  hwloc__xml_v1export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags);
2291  static hwloc_obj_t
2292  hwloc__xml_v1export_object_next_numanode(hwloc_obj_t obj, hwloc_obj_t cur)
2293  {
2294    hwloc_obj_t parent;
2295    if (!cur) {
2296      cur = obj-&gt;memory_first_child;
2297      goto find_first;
2298    }
2299    parent = cur;
2300    while (1) {
2301      if (parent-&gt;next_sibling) {
2302        cur = parent-&gt;next_sibling;
2303        break;
2304      }
2305      parent = parent-&gt;parent;
2306      if (parent == obj)
2307        return NULL;
2308    }
2309   find_first:
2310    while (cur-&gt;type != HWLOC_OBJ_NUMANODE)
2311      cur = cur-&gt;memory_first_child;
2312    assert(cur);
2313    return cur;
2314  }
2315  static unsigned
2316  hwloc__xml_v1export_object_list_numanodes(hwloc_obj_t obj, hwloc_obj_t *first_p, hwloc_obj_t **nodes_p)
2317  {
2318    hwloc_obj_t *nodes, cur;
2319    int nr;
2320    if (!obj-&gt;memory_first_child) {
2321      *first_p = NULL;
2322      *nodes_p = NULL;
2323      return 0;
2324    }
2325    nr = hwloc_bitmap_weight(obj-&gt;nodeset);
2326    assert(nr &gt; 0);
2327    nodes = calloc(nr, sizeof(*nodes));
2328    if (!nodes) {
2329      cur = hwloc__xml_v1export_object_next_numanode(obj, NULL);
2330      assert(cur);
2331      *first_p = cur;
2332      *nodes_p = NULL;
2333      return 1;
2334    }
2335    nr = 0;
2336    cur = NULL;
2337    while (1) {
2338      cur = hwloc__xml_v1export_object_next_numanode(obj, cur);
2339      if (!cur)
2340        break;
2341      nodes[nr++] = cur;
2342    }
2343    *first_p = nodes[0];
2344    *nodes_p = nodes;
2345    return nr;
2346  }
2347  static void
2348  hwloc__xml_v1export_object_with_memory(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2349  {
2350    struct hwloc__xml_export_state_s gstate, mstate, ostate, *state = parentstate;
2351    hwloc_obj_t child;
2352    unsigned nr_numanodes;
2353    hwloc_obj_t *numanodes, first_numanode;
2354    unsigned i;
2355    nr_numanodes = hwloc__xml_v1export_object_list_numanodes(obj, &amp;first_numanode, &amp;numanodes);
2356    if (obj-&gt;parent-&gt;arity &gt; 1 &amp;&amp; nr_numanodes &gt; 1 &amp;&amp; parentstate-&gt;global-&gt;v1_memory_group) {
2357      hwloc_obj_t group = parentstate-&gt;global-&gt;v1_memory_group;
2358      parentstate-&gt;new_child(parentstate, &amp;gstate, &quot;object&quot;);
2359      group-&gt;parent = obj-&gt;parent;
2360      group-&gt;cpuset = obj-&gt;cpuset;
2361      group-&gt;complete_cpuset = obj-&gt;complete_cpuset;
2362      group-&gt;nodeset = obj-&gt;nodeset;
2363      group-&gt;complete_nodeset = obj-&gt;complete_nodeset;
2364      hwloc__xml_export_object_contents (&amp;gstate, topology, group, flags);
2365      group-&gt;cpuset = NULL;
2366      group-&gt;complete_cpuset = NULL;
2367      group-&gt;nodeset = NULL;
2368      group-&gt;complete_nodeset = NULL;
2369      state = &amp;gstate;
2370    }
2371    state-&gt;new_child(state, &amp;mstate, &quot;object&quot;);
2372    hwloc__xml_export_object_contents (&amp;mstate, topology, first_numanode, flags);
2373    mstate.new_child(&amp;mstate, &amp;ostate, &quot;object&quot;);
2374    hwloc__xml_export_object_contents (&amp;ostate, topology, obj, flags);
2375    for_each_child(child, obj)
2376      hwloc__xml_v1export_object (&amp;ostate, topology, child, flags);
2377    for_each_io_child(child, obj)
2378      hwloc__xml_v1export_object (&amp;ostate, topology, child, flags);
2379    for_each_misc_child(child, obj)
2380      hwloc__xml_v1export_object (&amp;ostate, topology, child, flags);
2381    ostate.end_object(&amp;ostate, &quot;object&quot;);
2382    mstate.end_object(&amp;mstate, &quot;object&quot;);
2383    for(i=1; i&lt;nr_numanodes; i++)
2384      hwloc__xml_v1export_object (state, topology, numanodes[i], flags);
2385    free(numanodes);
2386    if (state == &amp;gstate) {
2387      gstate.end_object(&amp;gstate, &quot;object&quot;);
2388    }
2389  }
2390  static void
2391  hwloc__xml_v1export_object (hwloc__xml_export_state_t parentstate, hwloc_topology_t topology, hwloc_obj_t obj, unsigned long flags)
2392  {
2393    struct hwloc__xml_export_state_s state;
2394    hwloc_obj_t child;
2395    parentstate-&gt;new_child(parentstate, &amp;state, &quot;object&quot;);
2396    hwloc__xml_export_object_contents(&amp;state, topology, obj, flags);
2397    for_each_child(child, obj) {
2398      if (!child-&gt;memory_arity) {
2399        hwloc__xml_v1export_object (&amp;state, topology, child, flags);
2400      } else {
2401        hwloc__xml_v1export_object_with_memory(&amp;state, topology, child, flags);
2402      }
2403    }
2404    for_each_io_child(child, obj)
2405      hwloc__xml_v1export_object (&amp;state, topology, child, flags);
2406    for_each_misc_child(child, obj)
2407      hwloc__xml_v1export_object (&amp;state, topology, child, flags);
2408    state.end_object(&amp;state, &quot;object&quot;);
2409  }
2410  #define EXPORT_ARRAY(state, type, nr, values, tagname, format, maxperline) do { \
2411    unsigned _i = 0; \
2412    while (_i&lt;(nr)) { \
2413      char _tmp[255]; &amp;bsol;* enough for (snprintf(format)+space) x maxperline */ \
2414      char _tmp2[16]; \
2415      size_t _len = 0; \
2416      unsigned _j; \
2417      struct hwloc__xml_export_state_s _childstate; \
2418      (state)-&gt;new_child(state, &amp;_childstate, tagname); \
2419      for(_j=0; \
2420  	_i+_j&lt;(nr) &amp;&amp; _j&lt;maxperline; \
2421  	_j++) \
2422        _len += sprintf(_tmp+_len, format &quot; &quot;, (type) (values)[_i+_j]); \
2423      _i += _j; \
2424      sprintf(_tmp2, &quot;%lu&quot;, (unsigned long) _len); \
2425      _childstate.new_prop(&amp;_childstate, &quot;length&quot;, _tmp2); \
2426      _childstate.add_content(&amp;_childstate, _tmp, _len); \
2427      _childstate.end_object(&amp;_childstate, tagname); \
2428    } \
2429  } while (0)
2430  #define EXPORT_TYPE_GPINDEX_ARRAY(state, nr, objs, tagname, maxperline) do { \
2431    unsigned _i = 0; \
2432    while (_i&lt;(nr)) { \
2433      char _tmp[255]; &amp;bsol;* enough for (snprintf(type+index)+space) x maxperline */ \
2434      char _tmp2[16]; \
2435      size_t _len = 0; \
2436      unsigned _j; \
2437      struct hwloc__xml_export_state_s _childstate; \
2438      (state)-&gt;new_child(state, &amp;_childstate, tagname); \
2439      for(_j=0; \
2440  	_i+_j&lt;(nr) &amp;&amp; _j&lt;maxperline; \
2441  	_j++) \
2442        _len += sprintf(_tmp+_len, &quot;%s:%llu &quot;, hwloc_obj_type_string((objs)[_i+_j]-&gt;type), (unsigned long long) (objs)[_i+_j]-&gt;gp_index); \
2443      _i += _j; \
2444      sprintf(_tmp2, &quot;%lu&quot;, (unsigned long) _len); \
2445      _childstate.new_prop(&amp;_childstate, &quot;length&quot;, _tmp2); \
2446      _childstate.add_content(&amp;_childstate, _tmp, _len); \
2447      _childstate.end_object(&amp;_childstate, tagname); \
2448    } \
2449  } while (0)
2450  static void
2451  hwloc___xml_v2export_distances(hwloc__xml_export_state_t parentstate, struct hwloc_internal_distances_s *dist)
2452  {
2453    char tmp[255];
2454    unsigned nbobjs = dist-&gt;nbobjs;
2455    struct hwloc__xml_export_state_s state;
2456    if (dist-&gt;different_types) {
2457      parentstate-&gt;new_child(parentstate, &amp;state, &quot;distances2hetero&quot;);
2458    } else {
2459      parentstate-&gt;new_child(parentstate, &amp;state, &quot;distances2&quot;);
2460      state.new_prop(&amp;state, &quot;type&quot;, hwloc_obj_type_string(dist-&gt;unique_type));
2461    }
2462    sprintf(tmp, &quot;%u&quot;, nbobjs);
2463    state.new_prop(&amp;state, &quot;nbobjs&quot;, tmp);
2464    sprintf(tmp, &quot;%lu&quot;, dist-&gt;kind);
2465    state.new_prop(&amp;state, &quot;kind&quot;, tmp);
2466    if (dist-&gt;name)
2467      state.new_prop(&amp;state, &quot;name&quot;, dist-&gt;name);
2468    if (!dist-&gt;different_types) {
2469      state.new_prop(&amp;state, &quot;indexing&quot;,
2470  		   HWLOC_DIST_TYPE_USE_OS_INDEX(dist-&gt;unique_type) ? &quot;os&quot; : &quot;gp&quot;);
2471    }
2472    if (dist-&gt;different_types) {
2473      EXPORT_TYPE_GPINDEX_ARRAY(&amp;state, nbobjs, dist-&gt;objs, &quot;indexes&quot;, 10);
2474    } else {
2475      EXPORT_ARRAY(&amp;state, unsigned long long, nbobjs, dist-&gt;indexes, &quot;indexes&quot;, &quot;%llu&quot;, 10);
2476    }
2477    EXPORT_ARRAY(&amp;state, unsigned long long, nbobjs*nbobjs, dist-&gt;values, &quot;u64values&quot;, &quot;%llu&quot;, 10);
2478    state.end_object(&amp;state, dist-&gt;different_types ? &quot;distances2hetero&quot; : &quot;distances2&quot;);
2479  }
2480  static void
2481  hwloc__xml_v2export_distances(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology)
2482  {
2483    struct hwloc_internal_distances_s *dist;
2484    for(dist = topology-&gt;first_dist; dist; dist = dist-&gt;next)
2485      if (!dist-&gt;different_types)
2486        hwloc___xml_v2export_distances(parentstate, dist);
2487    for(dist = topology-&gt;first_dist; dist; dist = dist-&gt;next)
2488      if (dist-&gt;different_types)
2489        hwloc___xml_v2export_distances(parentstate, dist);
2490  }
2491  static void
2492  hwloc__xml_v2export_support(hwloc__xml_export_state_t parentstate, hwloc_topology_t topology)
2493  {
2494    struct hwloc__xml_export_state_s state;
2495    char tmp[11];
2496  #ifdef HWLOC_DEBUG
2497    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_support) == 4*sizeof(void*));
2498    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_discovery_support) == 6);
2499    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_cpubind_support) == 11);
2500    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_membind_support) == 15);
2501    HWLOC_BUILD_ASSERT(sizeof(struct hwloc_topology_misc_support) == 1);
2502  #endif
2503  #define DO(_cat,_name) do {                                     \
2504      if (topology-&gt;support._cat-&gt;_name) {                        \
2505        parentstate-&gt;new_child(parentstate, &amp;state, &quot;support&quot;);   \
2506        state.new_prop(&amp;state, &quot;name&quot;, #_cat &quot;.&quot; #_name);         \
2507        if (topology-&gt;support._cat-&gt;_name != 1) {                 \
2508          sprintf(tmp, &quot;%u&quot;, topology-&gt;support._cat-&gt;_name); \
2509          state.new_prop(&amp;state, &quot;value&quot;, tmp);                   \
2510        }                                                         \
2511        state.end_object(&amp;state, &quot;support&quot;);                      \
2512      }                                                           \
2513    } while (0)
2514    DO(discovery,pu);
2515    DO(discovery,numa);
2516    DO(discovery,numa_memory);
2517    DO(discovery,disallowed_pu);
2518    DO(discovery,disallowed_numa);
2519    DO(discovery,cpukind_efficiency);
2520    DO(cpubind,set_thisproc_cpubind);
2521    DO(cpubind,get_thisproc_cpubind);
2522    DO(cpubind,set_proc_cpubind);
2523    DO(cpubind,get_proc_cpubind);
2524    DO(cpubind,set_thisthread_cpubind);
2525    DO(cpubind,get_thisthread_cpubind);
2526    DO(cpubind,set_thread_cpubind);
2527    DO(cpubind,get_thread_cpubind);
2528    DO(cpubind,get_thisproc_last_cpu_location);
2529    DO(cpubind,get_proc_last_cpu_location);
2530    DO(cpubind,get_thisthread_last_cpu_location);
2531    DO(membind,set_thisproc_membind);
2532    DO(membind,get_thisproc_membind);
2533    DO(membind,set_proc_membind);
2534    DO(membind,get_proc_membind);
2535    DO(membind,set_thisthread_membind);
2536    DO(membind,get_thisthread_membind);
2537    DO(membind,set_area_membind);
2538    DO(membind,get_area_membind);
2539    DO(membind,alloc_membind);
2540    DO(membind,firsttouch_membind);
2541    DO(membind,bind_membind);
2542    DO(membind,interleave_membind);
2543    DO(membind,nexttouch_membind);
2544    DO(membind,migrate_membind);
2545    DO(membind,get_area_memlocation);
2546    parentstate-&gt;new_child(parentstate, &amp;state, &quot;support&quot;);
2547    state.new_prop(&amp;state, &quot;name&quot;, &quot;custom.exported_support&quot;);
2548    state.end_object(&amp;state, &quot;support&quot;);
2549  #undef DO
2550  }
2551  static void
2552  hwloc__xml_export_memattr_target(hwloc__xml_export_state_t state,
2553                                   struct hwloc_internal_memattr_s *imattr,
2554                                   struct hwloc_internal_memattr_target_s *imtg)
2555  {
2556    struct hwloc__xml_export_state_s vstate;
2557    char tmp[255];
2558    if (imattr-&gt;flags &amp; HWLOC_MEMATTR_FLAG_NEED_INITIATOR) {
2559      unsigned k;
2560      for(k=0; k&lt;imtg-&gt;nr_initiators; k++) {
2561        struct hwloc_internal_memattr_initiator_s *imi = &amp;imtg-&gt;initiators[k];
2562        state-&gt;new_child(state, &amp;vstate, &quot;memattr_value&quot;);
2563        vstate.new_prop(&amp;vstate, &quot;target_obj_type&quot;, hwloc_obj_type_string(imtg-&gt;type));
2564        snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imtg-&gt;gp_index);
2565        vstate.new_prop(&amp;vstate, &quot;target_obj_gp_index&quot;, tmp);
2566        snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imi-&gt;value);
2567        vstate.new_prop(&amp;vstate, &quot;value&quot;, tmp);
2568        switch (imi-&gt;initiator.type) {
2569        case HWLOC_LOCATION_TYPE_OBJECT:
2570          snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imi-&gt;initiator.location.object.gp_index);
2571          vstate.new_prop(&amp;vstate, &quot;initiator_obj_gp_index&quot;, tmp);
2572          vstate.new_prop(&amp;vstate, &quot;initiator_obj_type&quot;, hwloc_obj_type_string(imi-&gt;initiator.location.object.type));
2573          break;
2574        case HWLOC_LOCATION_TYPE_CPUSET: {
2575          char *setstring;
2576          hwloc_bitmap_asprintf(&amp;setstring, imi-&gt;initiator.location.cpuset);
2577          if (setstring)
2578            vstate.new_prop(&amp;vstate, &quot;initiator_cpuset&quot;, setstring);
2579          free(setstring);
2580          break;
2581        }
2582        default:
2583          assert(0);
2584        }
2585        vstate.end_object(&amp;vstate, &quot;memattr_value&quot;);
2586      }
2587    } else {
2588      state-&gt;new_child(state, &amp;vstate, &quot;memattr_value&quot;);
2589      vstate.new_prop(&amp;vstate, &quot;target_obj_type&quot;, hwloc_obj_type_string(imtg-&gt;type));
2590      snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imtg-&gt;gp_index);
2591      vstate.new_prop(&amp;vstate, &quot;target_obj_gp_index&quot;, tmp);
2592      snprintf(tmp, sizeof(tmp), &quot;%llu&quot;, (unsigned long long) imtg-&gt;noinitiator_value);
2593      vstate.new_prop(&amp;vstate, &quot;value&quot;, tmp);
2594      vstate.end_object(&amp;vstate, &quot;memattr_value&quot;);
2595    }
2596  }
2597  static void
2598  hwloc__xml_export_memattrs(hwloc__xml_export_state_t state, hwloc_topology_t topology)
2599  {
2600    unsigned id;
2601    for(id=0; id&lt;topology-&gt;nr_memattrs; id++) {
2602      struct hwloc_internal_memattr_s *imattr;
2603      struct hwloc__xml_export_state_s mstate;
2604      char tmp[255];
2605      unsigned j;
2606      if (id == HWLOC_MEMATTR_ID_CAPACITY || id == HWLOC_MEMATTR_ID_LOCALITY)
2607        continue;
2608      imattr = &amp;topology-&gt;memattrs[id];
2609      if (id &lt; HWLOC_MEMATTR_ID_MAX &amp;&amp; !imattr-&gt;nr_targets)
2610        continue;
2611      state-&gt;new_child(state, &amp;mstate, &quot;memattr&quot;);
2612      mstate.new_prop(&amp;mstate, &quot;name&quot;, imattr-&gt;name);
2613      snprintf(tmp, sizeof(tmp), &quot;%lu&quot;, imattr-&gt;flags);
2614      mstate.new_prop(&amp;mstate, &quot;flags&quot;, tmp);
2615      for(j=0; j&lt;imattr-&gt;nr_targets; j++)
2616        hwloc__xml_export_memattr_target(&amp;mstate, imattr, &amp;imattr-&gt;targets[j]);
2617      mstate.end_object(&amp;mstate, &quot;memattr&quot;);
2618    }
2619  }
2620  static void
2621  hwloc__xml_export_cpukinds(hwloc__xml_export_state_t state, hwloc_topology_t topology)
2622  {
2623    unsigned i;
2624    for(i=0; i&lt;topology-&gt;nr_cpukinds; i++) {
2625      struct hwloc_internal_cpukind_s *kind = &amp;topology-&gt;cpukinds[i];
2626      struct hwloc__xml_export_state_s cstate;
2627      char *setstring;
2628      unsigned j;
2629      state-&gt;new_child(state, &amp;cstate, &quot;cpukind&quot;);
2630      hwloc_bitmap_asprintf(&amp;setstring, kind-&gt;cpuset);
2631      cstate.new_prop(&amp;cstate, &quot;cpuset&quot;, setstring);
2632      free(setstring);
2633      if (kind-&gt;forced_efficiency != HWLOC_CPUKIND_EFFICIENCY_UNKNOWN) {
2634        char tmp[11];
2635        snprintf(tmp, sizeof(tmp), &quot;%d&quot;, kind-&gt;forced_efficiency);
2636        cstate.new_prop(&amp;cstate, &quot;forced_efficiency&quot;, tmp);
2637      }
2638      for(j=0; j&lt;kind-&gt;nr_infos; j++) {
2639        char *name = hwloc__xml_export_safestrdup(kind-&gt;infos[j].name);
2640        char *value = hwloc__xml_export_safestrdup(kind-&gt;infos[j].value);
2641        struct hwloc__xml_export_state_s istate;
2642        cstate.new_child(&amp;cstate, &amp;istate, &quot;info&quot;);
2643        istate.new_prop(&amp;istate, &quot;name&quot;, name);
2644        istate.new_prop(&amp;istate, &quot;value&quot;, value);
2645        istate.end_object(&amp;istate, &quot;info&quot;);
2646        free(name);
2647        free(value);
2648      }
2649      cstate.end_object(&amp;cstate, &quot;cpukind&quot;);
2650    }
2651  }
2652  void
2653  hwloc__xml_export_topology(hwloc__xml_export_state_t state, hwloc_topology_t topology, unsigned long flags)
2654  {
2655    char *env;
2656    hwloc_obj_t root = hwloc_get_root_obj(topology);
2657    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2658      hwloc_obj_t *numanodes, first_numanode;
2659      unsigned nr_numanodes;
2660      nr_numanodes = hwloc__xml_v1export_object_list_numanodes(root, &amp;first_numanode, &amp;numanodes);
2661      if (nr_numanodes) {
2662        struct hwloc__xml_export_state_s rstate, mstate;
2663        hwloc_obj_t child;
2664        unsigned i;
2665        state-&gt;new_child(state, &amp;rstate, &quot;object&quot;);
2666        hwloc__xml_export_object_contents (&amp;rstate, topology, root, flags);
2667        rstate.new_child(&amp;rstate, &amp;mstate, &quot;object&quot;);
2668        hwloc__xml_export_object_contents (&amp;mstate, topology, first_numanode, flags);
2669        for_each_child(child, root)
2670  	hwloc__xml_v1export_object (&amp;mstate, topology, child, flags);
2671        for_each_io_child(child, root)
2672  	hwloc__xml_v1export_object (&amp;mstate, topology, child, flags);
2673        for_each_misc_child(child, root)
2674  	hwloc__xml_v1export_object (&amp;mstate, topology, child, flags);
2675        mstate.end_object(&amp;mstate, &quot;object&quot;);
2676        for(i=1; i&lt;nr_numanodes; i++)
2677  	hwloc__xml_v1export_object (&amp;rstate, topology, numanodes[i], flags);
2678        rstate.end_object(&amp;rstate, &quot;object&quot;);
2679      } else {
2680        hwloc__xml_v1export_object(state, topology, root, flags);
2681      }
2682      free(numanodes);
2683    } else {
2684      hwloc__xml_v2export_object (state, topology, root, flags);
2685      hwloc__xml_v2export_distances (state, topology);
2686      env = getenv(&quot;HWLOC_XML_EXPORT_SUPPORT&quot;);
2687      if (!env || atoi(env))
2688        hwloc__xml_v2export_support(state, topology);
2689      hwloc__xml_export_memattrs(state, topology);
2690      hwloc__xml_export_cpukinds(state, topology);
2691    }
2692  }
2693  void
2694  hwloc__xml_export_diff(hwloc__xml_export_state_t parentstate, hwloc_topology_diff_t diff)
2695  {
2696    while (diff) {
2697      struct hwloc__xml_export_state_s state;
2698      char tmp[255];
2699      parentstate-&gt;new_child(parentstate, &amp;state, &quot;diff&quot;);
2700      sprintf(tmp, &quot;%d&quot;, (int) diff-&gt;generic.type);
2701      state.new_prop(&amp;state, &quot;type&quot;, tmp);
2702      switch (diff-&gt;generic.type) {
2703      case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR:
2704        sprintf(tmp, &quot;%d&quot;, diff-&gt;obj_attr.obj_depth);
2705        state.new_prop(&amp;state, &quot;obj_depth&quot;, tmp);
2706        sprintf(tmp, &quot;%u&quot;, diff-&gt;obj_attr.obj_index);
2707        state.new_prop(&amp;state, &quot;obj_index&quot;, tmp);
2708        sprintf(tmp, &quot;%d&quot;, (int) diff-&gt;obj_attr.diff.generic.type);
2709        state.new_prop(&amp;state, &quot;obj_attr_type&quot;, tmp);
2710        switch (diff-&gt;obj_attr.diff.generic.type) {
2711        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
2712  	sprintf(tmp, &quot;%llu&quot;, (unsigned long long) diff-&gt;obj_attr.diff.uint64.index);
2713  	state.new_prop(&amp;state, &quot;obj_attr_index&quot;, tmp);
2714  	sprintf(tmp, &quot;%llu&quot;, (unsigned long long) diff-&gt;obj_attr.diff.uint64.oldvalue);
2715  	state.new_prop(&amp;state, &quot;obj_attr_oldvalue&quot;, tmp);
2716  	sprintf(tmp, &quot;%llu&quot;, (unsigned long long) diff-&gt;obj_attr.diff.uint64.newvalue);
2717  	state.new_prop(&amp;state, &quot;obj_attr_newvalue&quot;, tmp);
2718  	break;
2719        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
2720        case HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
2721  	if (diff-&gt;obj_attr.diff.string.name)
2722  	  state.new_prop(&amp;state, &quot;obj_attr_name&quot;, diff-&gt;obj_attr.diff.string.name);
2723  	state.new_prop(&amp;state, &quot;obj_attr_oldvalue&quot;, diff-&gt;obj_attr.diff.string.oldvalue);
2724  	state.new_prop(&amp;state, &quot;obj_attr_newvalue&quot;, diff-&gt;obj_attr.diff.string.newvalue);
2725  	break;
2726        }
2727        break;
2728      default:
2729        assert(0);
2730      }
2731      state.end_object(&amp;state, &quot;diff&quot;);
2732      diff = diff-&gt;generic.next;
2733    }
2734  }
2735  int hwloc_topology_export_xml(hwloc_topology_t topology, const char *filename, unsigned long flags)
2736  {
2737    hwloc_localeswitch_declare;
2738    struct hwloc__xml_export_data_s edata;
2739    int force_nolibxml;
2740    int ret;
2741    if (!topology-&gt;is_loaded) {
2742      errno = EINVAL;
2743      return -1;
2744    }
2745    assert(hwloc_nolibxml_callbacks); &amp;bsol;* the core called components_init() for the topology */
2746    if (flags &amp; ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2747      errno = EINVAL;
2748      return -1;
2749    }
2750    hwloc_internal_distances_refresh(topology);
2751    hwloc_localeswitch_init();
2752    edata.v1_memory_group = NULL;
2753    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1)
2754      edata.v1_memory_group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
2755    force_nolibxml = hwloc_nolibxml_export();
2756  retry:
2757    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2758      ret = hwloc_nolibxml_callbacks-&gt;export_file(topology, &amp;edata, filename, flags);
2759    else {
2760      ret = hwloc_libxml_callbacks-&gt;export_file(topology, &amp;edata, filename, flags);
2761      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
2762        hwloc_libxml_callbacks = NULL;
2763        goto retry;
2764      }
2765    }
2766    if (edata.v1_memory_group)
2767      hwloc_free_unlinked_object(edata.v1_memory_group);
2768    hwloc_localeswitch_fini();
2769    return ret;
2770  }
2771  int hwloc_topology_export_xmlbuffer(hwloc_topology_t topology, char **xmlbuffer, int *buflen, unsigned long flags)
2772  {
2773    hwloc_localeswitch_declare;
2774    struct hwloc__xml_export_data_s edata;
2775    int force_nolibxml;
2776    int ret;
2777    if (!topology-&gt;is_loaded) {
2778      errno = EINVAL;
2779      return -1;
2780    }
2781    assert(hwloc_nolibxml_callbacks); &amp;bsol;* the core called components_init() for the topology */
2782    if (flags &amp; ~HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1) {
2783      errno = EINVAL;
2784      return -1;
2785    }
2786    hwloc_internal_distances_refresh(topology);
2787    hwloc_localeswitch_init();
2788    edata.v1_memory_group = NULL;
2789    if (flags &amp; HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1)
2790      edata.v1_memory_group = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, HWLOC_UNKNOWN_INDEX);
2791    force_nolibxml = hwloc_nolibxml_export();
2792  retry:
2793    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2794      ret = hwloc_nolibxml_callbacks-&gt;export_buffer(topology, &amp;edata, xmlbuffer, buflen, flags);
2795    else {
2796      ret = hwloc_libxml_callbacks-&gt;export_buffer(topology, &amp;edata, xmlbuffer, buflen, flags);
2797      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
2798        hwloc_libxml_callbacks = NULL;
2799        goto retry;
2800      }
2801    }
2802    if (edata.v1_memory_group)
2803      hwloc_free_unlinked_object(edata.v1_memory_group);
2804    hwloc_localeswitch_fini();
2805    return ret;
2806  }
2807  int
2808  hwloc_topology_diff_export_xml(hwloc_topology_diff_t diff, const char *refname,
2809  			       const char *filename)
2810  {
2811    hwloc_localeswitch_declare;
2812    hwloc_topology_diff_t tmpdiff;
2813    int force_nolibxml;
2814    int ret;
2815    tmpdiff = diff;
2816    while (tmpdiff) {
2817      if (tmpdiff-&gt;generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
2818        errno = EINVAL;
2819        return -1;
2820      }
2821      tmpdiff = tmpdiff-&gt;generic.next;
2822    }
2823    hwloc_components_init();
2824    assert(hwloc_nolibxml_callbacks);
2825    hwloc_localeswitch_init();
2826    force_nolibxml = hwloc_nolibxml_export();
2827  retry:
2828    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2829      ret = hwloc_nolibxml_callbacks-&gt;export_diff_file(diff, refname, filename);
2830    else {
2831      ret = hwloc_libxml_callbacks-&gt;export_diff_file(diff, refname, filename);
2832      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
2833        hwloc_libxml_callbacks = NULL;
2834        goto retry;
2835      }
2836    }
2837    hwloc_localeswitch_fini();
2838    hwloc_components_fini();
2839    return ret;
2840  }
2841  int
2842  hwloc_topology_diff_export_xmlbuffer(hwloc_topology_diff_t diff, const char *refname,
2843  				     char **xmlbuffer, int *buflen)
2844  {
2845    hwloc_localeswitch_declare;
2846    hwloc_topology_diff_t tmpdiff;
2847    int force_nolibxml;
2848    int ret;
2849    tmpdiff = diff;
2850    while (tmpdiff) {
2851      if (tmpdiff-&gt;generic.type == HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX) {
2852        errno = EINVAL;
2853        return -1;
2854      }
2855      tmpdiff = tmpdiff-&gt;generic.next;
2856    }
2857    hwloc_components_init();
2858    assert(hwloc_nolibxml_callbacks);
2859    hwloc_localeswitch_init();
2860    force_nolibxml = hwloc_nolibxml_export();
2861  retry:
2862    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2863      ret = hwloc_nolibxml_callbacks-&gt;export_diff_buffer(diff, refname, xmlbuffer, buflen);
2864    else {
2865      ret = hwloc_libxml_callbacks-&gt;export_diff_buffer(diff, refname, xmlbuffer, buflen);
2866      if (ret &lt; 0 &amp;&amp; errno == ENOSYS) {
2867        hwloc_libxml_callbacks = NULL;
2868        goto retry;
2869      }
2870    }
2871    hwloc_localeswitch_fini();
2872    hwloc_components_fini();
2873    return ret;
2874  }
2875  void hwloc_free_xmlbuffer(hwloc_topology_t topology __hwloc_attribute_unused, char *xmlbuffer)
2876  {
2877    int force_nolibxml;
2878    assert(hwloc_nolibxml_callbacks); &amp;bsol;* the core called components_init() for the topology */
2879    force_nolibxml = hwloc_nolibxml_export();
2880    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
2881      hwloc_nolibxml_callbacks-&gt;free_buffer(xmlbuffer);
2882    else
2883      hwloc_libxml_callbacks-&gt;free_buffer(xmlbuffer);
2884  }
2885  void
2886  hwloc_topology_set_userdata_export_callback(hwloc_topology_t topology,
2887  					    void (*export)(void *reserved, struct hwloc_topology *topology, struct hwloc_obj *obj))
2888  {
2889    topology-&gt;userdata_export_cb = export;
2890  }
2891  static void
2892  hwloc__export_obj_userdata(hwloc__xml_export_state_t parentstate, int encoded,
2893  			   const char *name, size_t length, const void *buffer, size_t encoded_length)
2894  {
2895    struct hwloc__xml_export_state_s state;
2896    char tmp[255];
2897    parentstate-&gt;new_child(parentstate, &amp;state, &quot;userdata&quot;);
2898    if (name)
2899      state.new_prop(&amp;state, &quot;name&quot;, name);
2900    sprintf(tmp, &quot;%lu&quot;, (unsigned long) length);
2901    state.new_prop(&amp;state, &quot;length&quot;, tmp);
2902    if (encoded)
2903      state.new_prop(&amp;state, &quot;encoding&quot;, &quot;base64&quot;);
2904    if (encoded_length)
2905      state.add_content(&amp;state, buffer, encoded ? encoded_length : length);
2906    state.end_object(&amp;state, &quot;userdata&quot;);
2907  }
2908  int
2909  hwloc_export_obj_userdata(void *reserved,
2910  			  struct hwloc_topology *topology, struct hwloc_obj *obj __hwloc_attribute_unused,
2911  			  const char *name, const void *buffer, size_t length)
2912  {
2913    hwloc__xml_export_state_t state = reserved;
2914    if (!buffer) {
2915      errno = EINVAL;
2916      return -1;
2917    }
2918    if ((name &amp;&amp; hwloc__xml_export_check_buffer(name, strlen(name)) &lt; 0)
2919        || hwloc__xml_export_check_buffer(buffer, length) &lt; 0) {
2920      errno = EINVAL;
2921      return -1;
2922    }
2923    if (topology-&gt;userdata_not_decoded) {
2924      int encoded;
2925      size_t encoded_length;
2926      const char *realname;
2927      assert(name);
2928      if (!strncmp(name, &quot;base64&quot;, 6)) {
2929        encoded = 1;
2930        encoded_length = BASE64_ENCODED_LENGTH(length);
2931      } else {
2932        assert(!strncmp(name, &quot;normal&quot;, 6));
2933        encoded = 0;
2934        encoded_length = length;
2935      }
2936      if (name[6] == &#x27;:&#x27;)
2937        realname = name+7;
2938      else {
2939        assert(!strcmp(name+6, &quot;-anon&quot;));
2940        realname = NULL;
2941      }
2942      hwloc__export_obj_userdata(state, encoded, realname, length, buffer, encoded_length);
2943    } else
2944      hwloc__export_obj_userdata(state, 0, name, length, buffer, length);
2945    return 0;
2946  }
2947  int
2948  hwloc_export_obj_userdata_base64(void *reserved,
2949  				 struct hwloc_topology *topology __hwloc_attribute_unused, struct hwloc_obj *obj __hwloc_attribute_unused,
2950  				 const char *name, const void *buffer, size_t length)
2951  {
2952    hwloc__xml_export_state_t state = reserved;
2953    size_t encoded_length;
2954    char *encoded_buffer;
2955    int ret __hwloc_attribute_unused;
2956    if (!buffer) {
2957      errno = EINVAL;
2958      return -1;
2959    }
2960    assert(!topology-&gt;userdata_not_decoded);
2961    if (name &amp;&amp; hwloc__xml_export_check_buffer(name, strlen(name)) &lt; 0) {
2962      errno = EINVAL;
2963      return -1;
2964    }
2965    encoded_length = BASE64_ENCODED_LENGTH(length);
2966    encoded_buffer = malloc(encoded_length+1);
2967    if (!encoded_buffer) {
2968      errno = ENOMEM;
2969      return -1;
2970    }
2971    ret = hwloc_encode_to_base64(buffer, length, encoded_buffer, encoded_length+1);
2972    assert(ret == (int) encoded_length);
2973    hwloc__export_obj_userdata(state, 1, name, length, encoded_buffer, encoded_length);
2974    free(encoded_buffer);
2975    return 0;
2976  }
2977  void
2978  hwloc_topology_set_userdata_import_callback(hwloc_topology_t topology,
2979  					    void (*import)(struct hwloc_topology *topology, struct hwloc_obj *obj, const char *name, const void *buffer, size_t length))
2980  {
2981    topology-&gt;userdata_import_cb = import;
2982  }
2983  static void
2984  hwloc_xml_backend_disable(struct hwloc_backend *backend)
2985  {
2986    struct hwloc_xml_backend_data_s *data = backend-&gt;private_data;
2987    data-&gt;backend_exit(data);
2988    free(data-&gt;msgprefix);
2989    free(data);
2990  }
2991  static struct hwloc_backend *
2992  hwloc_xml_component_instantiate(struct hwloc_topology *topology,
2993  				struct hwloc_disc_component *component,
2994  				unsigned excluded_phases __hwloc_attribute_unused,
2995  				const void *_data1,
2996  				const void *_data2,
2997  				const void *_data3)
2998  {
2999    struct hwloc_xml_backend_data_s *data;
3000    struct hwloc_backend *backend;
3001    const char *env;
3002    int force_nolibxml;
3003    const char * xmlpath = (const char *) _data1;
3004    const char * xmlbuffer = (const char *) _data2;
3005    int xmlbuflen = (int)(uintptr_t) _data3;
3006    const char *local_basename;
3007    int err;
3008    assert(hwloc_nolibxml_callbacks); &amp;bsol;* the core called components_init() for the component&#x27;s topology */
3009    if (!xmlpath &amp;&amp; !xmlbuffer) {
3010      env = getenv(&quot;HWLOC_XMLFILE&quot;);
3011      if (env) {
3012        xmlpath = env;
3013      } else {
3014        errno = EINVAL;
3015        goto out;
3016      }
3017    }
3018    backend = hwloc_backend_alloc(topology, component);
3019    if (!backend)
3020      goto out;
3021    data = malloc(sizeof(*data));
3022    if (!data) {
3023      errno = ENOMEM;
3024      goto out_with_backend;
3025    }
3026    backend-&gt;private_data = data;
3027    backend-&gt;discover = hwloc_look_xml;
3028    backend-&gt;disable = hwloc_xml_backend_disable;
3029    backend-&gt;is_thissystem = 0;
3030    if (xmlpath) {
3031      local_basename = strrchr(xmlpath, &#x27;/&#x27;);
3032      if (local_basename)
3033        local_basename++;
3034      else
3035        local_basename = xmlpath;
3036    } else {
3037      local_basename = &quot;xmlbuffer&quot;;
3038    }
3039    data-&gt;msgprefix = strdup(local_basename);
3040    force_nolibxml = hwloc_nolibxml_import();
3041  retry:
3042    if (!hwloc_libxml_callbacks || (hwloc_nolibxml_callbacks &amp;&amp; force_nolibxml))
3043      err = hwloc_nolibxml_callbacks-&gt;backend_init(data, xmlpath, xmlbuffer, xmlbuflen);
3044    else {
3045      err = hwloc_libxml_callbacks-&gt;backend_init(data, xmlpath, xmlbuffer, xmlbuflen);
3046      if (err &lt; 0 &amp;&amp; errno == ENOSYS) {
3047        hwloc_libxml_callbacks = NULL;
3048        goto retry;
3049      }
3050    }
3051    if (err &lt; 0)
3052      goto out_with_data;
3053    return backend;
3054   out_with_data:
3055    free(data-&gt;msgprefix);
3056    free(data);
3057   out_with_backend:
3058    free(backend);
3059   out:
3060    return NULL;
3061  }
3062  static struct hwloc_disc_component hwloc_xml_disc_component = {
3063    &quot;xml&quot;,
3064    HWLOC_DISC_PHASE_GLOBAL,
3065    ~0,
3066    hwloc_xml_component_instantiate,
3067    30,
3068    1,
3069    NULL
3070  };
3071  const struct hwloc_component hwloc_xml_component = {
3072    HWLOC_COMPONENT_ABI,
3073    NULL, NULL,
3074    HWLOC_COMPONENT_TYPE_DISC,
3075    0,
3076    &amp;hwloc_xml_disc_component
3077  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-xml.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-xml.c</div>
                </div>
                <div class="column column_space"><pre><code>1175  	      state-&gt;global-&gt;msgprefix, _TAG_NAME, nbobjs);
1176      goto out_with_arrays;
1177    }
1178    nr_indexes = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>1234  		      state-&gt;global-&gt;msgprefix, _TAG_NAME, tmp);
1235  	    goto out_with_arrays;
1236  	  }
1237  	  tmp2 = strchr(tmp, &#x27;:&#x27;);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    