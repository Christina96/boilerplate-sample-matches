
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 33, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format-inl.h</h3>
            <pre><code>1  #ifndef FMT_FORMAT_INL_H_
2  #define FMT_FORMAT_INL_H_
3  #include <cassert>
4  #include <cctype>
5  #include <climits>
6  #include <cmath>
7  #include <cstdarg>
8  #include <cstring>  
9  #include <cwchar>
10  #include <exception>
11  #ifndef FMT_STATIC_THOUSANDS_SEPARATOR
12  #  include <locale>
13  #endif
14  #ifdef _WIN32
15  #  include <io.h>  
16  #endif
17  #include "format.h"
18  inline fmt::detail::null<> strerror_r(int, char*, ...) { return {}; }
19  inline fmt::detail::null<> strerror_s(char*, size_t, ...) { return {}; }
20  FMT_BEGIN_NAMESPACE
21  namespace detail {
22  FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
23    std::fprintf(stderr, "%s:%d: assertion failed: %s", file, line, message);
24    std::terminate();
25  }
26  #ifndef _MSC_VER
27  #  define FMT_SNPRINTF snprintf
28  #else  
29  inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {
30    va_list args;
31    va_start(args, format);
32    int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
33    va_end(args);
34    return result;
35  }
36  #  define FMT_SNPRINTF fmt_snprintf
37  #endif  
38  inline int safe_strerror(int error_code, char*& buffer,
39                           size_t buffer_size) FMT_NOEXCEPT {
40    FMT_ASSERT(buffer != nullptr && buffer_size != 0, "invalid buffer");
41    class dispatcher {
42     private:
43      int error_code_;
44      char*& buffer_;
45      size_t buffer_size_;
46      void operator=(const dispatcher&) {}
47      int handle(int result) {
48        return result == -1 ? errno : result;
49      }
50      FMT_MAYBE_UNUSED
51      int handle(char* message) {
52        if (message == buffer_ && strlen(buffer_) == buffer_size_ - 1)
53          return ERANGE;
54        buffer_ = message;
55        return 0;
56      }
57      FMT_MAYBE_UNUSED
58      int handle(detail::null<>) {
59        return fallback(strerror_s(buffer_, buffer_size_, error_code_));
60      }
61      FMT_MAYBE_UNUSED
62      int fallback(int result) {
63        return result == 0 && strlen(buffer_) == buffer_size_ - 1 ? ERANGE
64                                                                  : result;
65      }
66  #if !FMT_MSC_VER
67      int fallback(detail::null<>) {
68        errno = 0;
69        buffer_ = strerror(error_code_);
70        return errno;
71      }
72  #endif
73     public:
74      dispatcher(int err_code, char*& buf, size_t buf_size)
75          : error_code_(err_code), buffer_(buf), buffer_size_(buf_size) {}
76      int run() { return handle(strerror_r(error_code_, buffer_, buffer_size_)); }
77    };
78    return dispatcher(error_code, buffer, buffer_size).run();
79  }
80  FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
81                                  string_view message) FMT_NOEXCEPT {
82    out.try_resize(0);
83    static const char SEP[] = ": ";
84    static const char ERROR_STR[] = "error ";
85    size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
86    auto abs_value = static_cast<uint32_or_64_or_128_t<int>>(error_code);
87    if (detail::is_negative(error_code)) {
88      abs_value = 0 - abs_value;
89      ++error_code_size;
90    }
91    error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
92    auto it = buffer_appender<char>(out);
93    if (message.size() <= inline_buffer_size - error_code_size)
94      format_to(it, "{}{}", message, SEP);
95    format_to(it, "{}{}", ERROR_STR, error_code);
96    assert(out.size() <= inline_buffer_size);
97  }
98  FMT_FUNC void report_error(format_func func, int error_code,
99                             string_view message) FMT_NOEXCEPT {
100    memory_buffer full_message;
101    func(full_message, error_code, message);
102    (void)std::fwrite(full_message.data(), full_message.size(), 1, stderr);
103    std::fputc('\n', stderr);
104  }
105  inline void fwrite_fully(const void* ptr, size_t size, size_t count,
106                           FILE* stream) {
107    size_t written = std::fwrite(ptr, size, count, stream);
108    if (written < count) FMT_THROW(system_error(errno, "cannot write to file"));
109  }
110  }  
111  #if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
112  namespace detail {
113  template <typename Locale>
114  locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
115    static_assert(std::is_same<Locale, std::locale>::value, "");
116  }
117  template <typename Locale> Locale locale_ref::get() const {
118    static_assert(std::is_same<Locale, std::locale>::value, "");
119    return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();
120  }
121  template <typename Char> FMT_FUNC std::string grouping_impl(locale_ref loc) {
122    return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>()).grouping();
123  }
124  template <typename Char> FMT_FUNC Char thousands_sep_impl(locale_ref loc) {
125    return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
126        .thousands_sep();
127  }
128  template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref loc) {
129    return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
130        .decimal_point();
131  }
132  }  
133  #else
134  template <typename Char>
135  FMT_FUNC std::string detail::grouping_impl(locale_ref) {
136    return "\03";
137  }
138  template <typename Char> FMT_FUNC Char detail::thousands_sep_impl(locale_ref) {
139    return FMT_STATIC_THOUSANDS_SEPARATOR;
140  }
141  template <typename Char> FMT_FUNC Char detail::decimal_point_impl(locale_ref) {
142    return '.';
143  }
144  #endif
145  FMT_API FMT_FUNC format_error::~format_error() FMT_NOEXCEPT = default;
146  FMT_API FMT_FUNC system_error::~system_error() FMT_NOEXCEPT = default;
147  FMT_FUNC void system_error::init(int err_code, string_view format_str,
148                                   format_args args) {
149    error_code_ = err_code;
150    memory_buffer buffer;
151    format_system_error(buffer, err_code, vformat(format_str, args));
152    std::runtime_error& base = *this;
153    base = std::runtime_error(to_string(buffer));
154  }
155  namespace detail {
156  template <> FMT_FUNC int count_digits<4>(detail::fallback_uintptr n) {
157    int i = static_cast<int>(sizeof(void*)) - 1;
158    while (i > 0 && n.value[i] == 0) --i;
159    auto char_digits = std::numeric_limits<unsigned char>::digits / 4;
160    return i >= 0 ? i * char_digits + count_digits<4, unsigned>(n.value[i]) : 1;
161  }
162  template <typename T>
163  const typename basic_data<T>::digit_pair basic_data<T>::digits[] = {
164      {'0', '0'}, {'0', '1'}, {'0', '2'}, {'0', '3'}, {'0', '4'}, {'0', '5'},
165      {'0', '6'}, {'0', '7'}, {'0', '8'}, {'0', '9'}, {'1', '0'}, {'1', '1'},
166      {'1', '2'}, {'1', '3'}, {'1', '4'}, {'1', '5'}, {'1', '6'}, {'1', '7'},
167      {'1', '8'}, {'1', '9'}, {'2', '0'}, {'2', '1'}, {'2', '2'}, {'2', '3'},
168      {'2', '4'}, {'2', '5'}, {'2', '6'}, {'2', '7'}, {'2', '8'}, {'2', '9'},
169      {'3', '0'}, {'3', '1'}, {'3', '2'}, {'3', '3'}, {'3', '4'}, {'3', '5'},
170      {'3', '6'}, {'3', '7'}, {'3', '8'}, {'3', '9'}, {'4', '0'}, {'4', '1'},
171      {'4', '2'}, {'4', '3'}, {'4', '4'}, {'4', '5'}, {'4', '6'}, {'4', '7'},
172      {'4', '8'}, {'4', '9'}, {'5', '0'}, {'5', '1'}, {'5', '2'}, {'5', '3'},
173      {'5', '4'}, {'5', '5'}, {'5', '6'}, {'5', '7'}, {'5', '8'}, {'5', '9'},
174      {'6', '0'}, {'6', '1'}, {'6', '2'}, {'6', '3'}, {'6', '4'}, {'6', '5'},
175      {'6', '6'}, {'6', '7'}, {'6', '8'}, {'6', '9'}, {'7', '0'}, {'7', '1'},
176      {'7', '2'}, {'7', '3'}, {'7', '4'}, {'7', '5'}, {'7', '6'}, {'7', '7'},
177      {'7', '8'}, {'7', '9'}, {'8', '0'}, {'8', '1'}, {'8', '2'}, {'8', '3'},
178      {'8', '4'}, {'8', '5'}, {'8', '6'}, {'8', '7'}, {'8', '8'}, {'8', '9'},
179      {'9', '0'}, {'9', '1'}, {'9', '2'}, {'9', '3'}, {'9', '4'}, {'9', '5'},
180      {'9', '6'}, {'9', '7'}, {'9', '8'}, {'9', '9'}};
181  template <typename T>
182  const char basic_data<T>::hex_digits[] = "0123456789abcdef";
183  #define FMT_POWERS_OF_10(factor)                                             \
184    factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
185        (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
186        (factor)*1000000000
187  template <typename T>
188  const uint64_t basic_data<T>::powers_of_10_64[] = {
189      1, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
190      10000000000000000000ULL};
191  template <typename T>
192  const uint32_t basic_data<T>::zero_or_powers_of_10_32[] = {0, 0,
193                                                             FMT_POWERS_OF_10(1)};
194  template <typename T>
195  const uint64_t basic_data<T>::zero_or_powers_of_10_64[] = {
196      0, 0, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
197      10000000000000000000ULL};
198  template <typename T>
199  const uint64_t basic_data<T>::grisu_pow10_significands[] = {
200      0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,
201      0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,
202      0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,
203      0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,
204      0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
205      0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,
206      0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,
207      0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,
208      0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,
209      0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
210      0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,
211      0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,
212      0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,
213      0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,
214      0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
215      0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,
216      0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,
217      0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,
218      0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,
219      0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
220      0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,
221      0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,
222      0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,
223      0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,
224      0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
225      0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,
226      0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,
227      0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,
228      0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
229  };
230  template <typename T>
231  const int16_t basic_data<T>::grisu_pow10_exponents[] = {
232      -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,
233      -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,
234      -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,
235      -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,
236      -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,
237      242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,
238      534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,
239      827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};
240  template <typename T>
241  const divtest_table_entry<uint32_t> basic_data<T>::divtest_table_for_pow5_32[] =
242      {{0x00000001, 0xffffffff}, {0xcccccccd, 0x33333333},
243       {0xc28f5c29, 0x0a3d70a3}, {0x26e978d5, 0x020c49ba},
244       {0x3afb7e91, 0x0068db8b}, {0x0bcbe61d, 0x0014f8b5},
245       {0x68c26139, 0x000431bd}, {0xae8d46a5, 0x0000d6bf},
246       {0x22e90e21, 0x00002af3}, {0x3a2e9c6d, 0x00000897},
247       {0x3ed61f49, 0x000001b7}};
248  template <typename T>
249  const divtest_table_entry<uint64_t> basic_data<T>::divtest_table_for_pow5_64[] =
250      {{0x0000000000000001, 0xffffffffffffffff},
251       {0xcccccccccccccccd, 0x3333333333333333},
252       {0x8f5c28f5c28f5c29, 0x0a3d70a3d70a3d70},
253       {0x1cac083126e978d5, 0x020c49ba5e353f7c},
254       {0xd288ce703afb7e91, 0x0068db8bac710cb2},
255       {0x5d4e8fb00bcbe61d, 0x0014f8b588e368f0},
256       {0x790fb65668c26139, 0x000431bde82d7b63},
257       {0xe5032477ae8d46a5, 0x0000d6bf94d5e57a},
258       {0xc767074b22e90e21, 0x00002af31dc46118},
259       {0x8e47ce423a2e9c6d, 0x0000089705f4136b},
260       {0x4fa7f60d3ed61f49, 0x000001b7cdfd9d7b},
261       {0x0fee64690c913975, 0x00000057f5ff85e5},
262       {0x3662e0e1cf503eb1, 0x000000119799812d},
263       {0xa47a2cf9f6433fbd, 0x0000000384b84d09},
264       {0x54186f653140a659, 0x00000000b424dc35},
265       {0x7738164770402145, 0x0000000024075f3d},
266       {0xe4a4d1417cd9a041, 0x000000000734aca5},
267       {0xc75429d9e5c5200d, 0x000000000170ef54},
268       {0xc1773b91fac10669, 0x000000000049c977},
269       {0x26b172506559ce15, 0x00000000000ec1e4},
270       {0xd489e3a9addec2d1, 0x000000000002f394},
271       {0x90e860bb892c8d5d, 0x000000000000971d},
272       {0x502e79bf1b6f4f79, 0x0000000000001e39},
273       {0xdcd618596be30fe5, 0x000000000000060b}};
274  template <typename T>
275  const uint64_t basic_data<T>::dragonbox_pow10_significands_64[] = {
276      0x81ceb32c4b43fcf5, 0xa2425ff75e14fc32, 0xcad2f7f5359a3b3f,
277      0xfd87b5f28300ca0e, 0x9e74d1b791e07e49, 0xc612062576589ddb,
278      0xf79687aed3eec552, 0x9abe14cd44753b53, 0xc16d9a0095928a28,
279      0xf1c90080baf72cb2, 0x971da05074da7bef, 0xbce5086492111aeb,
280      0xec1e4a7db69561a6, 0x9392ee8e921d5d08, 0xb877aa3236a4b44a,
281      0xe69594bec44de15c, 0x901d7cf73ab0acda, 0xb424dc35095cd810,
282      0xe12e13424bb40e14, 0x8cbccc096f5088cc, 0xafebff0bcb24aaff,
283      0xdbe6fecebdedd5bf, 0x89705f4136b4a598, 0xabcc77118461cefd,
284      0xd6bf94d5e57a42bd, 0x8637bd05af6c69b6, 0xa7c5ac471b478424,
285      0xd1b71758e219652c, 0x83126e978d4fdf3c, 0xa3d70a3d70a3d70b,
286      0xcccccccccccccccd, 0x8000000000000000, 0xa000000000000000,
287      0xc800000000000000, 0xfa00000000000000, 0x9c40000000000000,
288      0xc350000000000000, 0xf424000000000000, 0x9896800000000000,
289      0xbebc200000000000, 0xee6b280000000000, 0x9502f90000000000,
290      0xba43b74000000000, 0xe8d4a51000000000, 0x9184e72a00000000,
291      0xb5e620f480000000, 0xe35fa931a0000000, 0x8e1bc9bf04000000,
292      0xb1a2bc2ec5000000, 0xde0b6b3a76400000, 0x8ac7230489e80000,
293      0xad78ebc5ac620000, 0xd8d726b7177a8000, 0x878678326eac9000,
294      0xa968163f0a57b400, 0xd3c21bcecceda100, 0x84595161401484a0,
295      0xa56fa5b99019a5c8, 0xcecb8f27f4200f3a, 0x813f3978f8940984,
296      0xa18f07d736b90be5, 0xc9f2c9cd04674ede, 0xfc6f7c4045812296,
297      0x9dc5ada82b70b59d, 0xc5371912364ce305, 0xf684df56c3e01bc6,
298      0x9a130b963a6c115c, 0xc097ce7bc90715b3, 0xf0bdc21abb48db20,
299      0x96769950b50d88f4, 0xbc143fa4e250eb31, 0xeb194f8e1ae525fd,
300      0x92efd1b8d0cf37be, 0xb7abc627050305ad, 0xe596b7b0c643c719,
301      0x8f7e32ce7bea5c6f, 0xb35dbf821ae4f38b, 0xe0352f62a19e306e};
302  template <typename T>
303  const uint128_wrapper basic_data<T>::dragonbox_pow10_significands_128[] = {
304  #if FMT_USE_FULL_CACHE_DRAGONBOX
305      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
306      {0x9faacf3df73609b1, 0x77b191618c54e9ad},
307      {0xc795830d75038c1d, 0xd59df5b9ef6a2418},
308      {0xf97ae3d0d2446f25, 0x4b0573286b44ad1e},
309      {0x9becce62836ac577, 0x4ee367f9430aec33},
310      {0xc2e801fb244576d5, 0x229c41f793cda740},
311      {0xf3a20279ed56d48a, 0x6b43527578c11110},
312      {0x9845418c345644d6, 0x830a13896b78aaaa},
313      {0xbe5691ef416bd60c, 0x23cc986bc656d554},
314      {0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa9},
315      {0x94b3a202eb1c3f39, 0x7bf7d71432f3d6aa},
316      {0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc54},
317      {0xe858ad248f5c22c9, 0xd1b3400f8f9cff69},
318      {0x91376c36d99995be, 0x23100809b9c21fa2},
319      {0xb58547448ffffb2d, 0xabd40a0c2832a78b},
320      {0xe2e69915b3fff9f9, 0x16c90c8f323f516d},
321      {0x8dd01fad907ffc3b, 0xae3da7d97f6792e4},
322      {0xb1442798f49ffb4a, 0x99cd11cfdf41779d},
323      {0xdd95317f31c7fa1d, 0x40405643d711d584},
324      {0x8a7d3eef7f1cfc52, 0x482835ea666b2573},
325      {0xad1c8eab5ee43b66, 0xda3243650005eed0},
326      {0xd863b256369d4a40, 0x90bed43e40076a83},
327      {0x873e4f75e2224e68, 0x5a7744a6e804a292},
328      {0xa90de3535aaae202, 0x711515d0a205cb37},
329      {0xd3515c2831559a83, 0x0d5a5b44ca873e04},
330      {0x8412d9991ed58091, 0xe858790afe9486c3},
331      {0xa5178fff668ae0b6, 0x626e974dbe39a873},
332      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
333      {0x80fa687f881c7f8e, 0x7ce66634bc9d0b9a},
334      {0xa139029f6a239f72, 0x1c1fffc1ebc44e81},
335      {0xc987434744ac874e, 0xa327ffb266b56221},
336      {0xfbe9141915d7a922, 0x4bf1ff9f0062baa9},
337      {0x9d71ac8fada6c9b5, 0x6f773fc3603db4aa},
338      {0xc4ce17b399107c22, 0xcb550fb4384d21d4},
339      {0xf6019da07f549b2b, 0x7e2a53a146606a49},
340      {0x99c102844f94e0fb, 0x2eda7444cbfc426e},
341      {0xc0314325637a1939, 0xfa911155fefb5309},
342      {0xf03d93eebc589f88, 0x793555ab7eba27cb},
343      {0x96267c7535b763b5, 0x4bc1558b2f3458df},
344      {0xbbb01b9283253ca2, 0x9eb1aaedfb016f17},
345      {0xea9c227723ee8bcb, 0x465e15a979c1cadd},
346      {0x92a1958a7675175f, 0x0bfacd89ec191eca},
347      {0xb749faed14125d36, 0xcef980ec671f667c},
348      {0xe51c79a85916f484, 0x82b7e12780e7401b},
349      {0x8f31cc0937ae58d2, 0xd1b2ecb8b0908811},
350      {0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa16},
351      {0xdfbdcece67006ac9, 0x67a791e093e1d49b},
352      {0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e1},
353      {0xaecc49914078536d, 0x58fae9f773886e19},
354      {0xda7f5bf590966848, 0xaf39a475506a899f},
355      {0x888f99797a5e012d, 0x6d8406c952429604},
356      {0xaab37fd7d8f58178, 0xc8e5087ba6d33b84},
357      {0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a65},
358      {0x855c3be0a17fcd26, 0x5cf2eea09a550680},
359      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
360      {0xd0601d8efc57b08b, 0xf13b94daf124da27},
361      {0x823c12795db6ce57, 0x76c53d08d6b70859},
362      {0xa2cb1717b52481ed, 0x54768c4b0c64ca6f},
363      {0xcb7ddcdda26da268, 0xa9942f5dcf7dfd0a},
364      {0xfe5d54150b090b02, 0xd3f93b35435d7c4d},
365      {0x9efa548d26e5a6e1, 0xc47bc5014a1a6db0},
366      {0xc6b8e9b0709f109a, 0x359ab6419ca1091c},
367      {0xf867241c8cc6d4c0, 0xc30163d203c94b63},
368      {0x9b407691d7fc44f8, 0x79e0de63425dcf1e},
369      {0xc21094364dfb5636, 0x985915fc12f542e5},
370      {0xf294b943e17a2bc4, 0x3e6f5b7b17b2939e},
371      {0x979cf3ca6cec5b5a, 0xa705992ceecf9c43},
372      {0xbd8430bd08277231, 0x50c6ff782a838354},
373      {0xece53cec4a314ebd, 0xa4f8bf5635246429},
374      {0x940f4613ae5ed136, 0x871b7795e136be9a},
375      {0xb913179899f68584, 0x28e2557b59846e40},
376      {0xe757dd7ec07426e5, 0x331aeada2fe589d0},
377      {0x9096ea6f3848984f, 0x3ff0d2c85def7622},
378      {0xb4bca50b065abe63, 0x0fed077a756b53aa},
379      {0xe1ebce4dc7f16dfb, 0xd3e8495912c62895},
380      {0x8d3360f09cf6e4bd, 0x64712dd7abbbd95d},
381      {0xb080392cc4349dec, 0xbd8d794d96aacfb4},
382      {0xdca04777f541c567, 0xecf0d7a0fc5583a1},
383      {0x89e42caaf9491b60, 0xf41686c49db57245},
384      {0xac5d37d5b79b6239, 0x311c2875c522ced6},
385      {0xd77485cb25823ac7, 0x7d633293366b828c},
386      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
387      {0xa8530886b54dbdeb, 0xd9f57f830283fdfd},
388      {0xd267caa862a12d66, 0xd072df63c324fd7c},
389      {0x8380dea93da4bc60, 0x4247cb9e59f71e6e},
390      {0xa46116538d0deb78, 0x52d9be85f074e609},
391      {0xcd795be870516656, 0x67902e276c921f8c},
392      {0x806bd9714632dff6, 0x00ba1cd8a3db53b7},
393      {0xa086cfcd97bf97f3, 0x80e8a40eccd228a5},
394      {0xc8a883c0fdaf7df0, 0x6122cd128006b2ce},
395      {0xfad2a4b13d1b5d6c, 0x796b805720085f82},
396      {0x9cc3a6eec6311a63, 0xcbe3303674053bb1},
397      {0xc3f490aa77bd60fc, 0xbedbfc4411068a9d},
398      {0xf4f1b4d515acb93b, 0xee92fb5515482d45},
399      {0x991711052d8bf3c5, 0x751bdd152d4d1c4b},
400      {0xbf5cd54678eef0b6, 0xd262d45a78a0635e},
401      {0xef340a98172aace4, 0x86fb897116c87c35},
402      {0x9580869f0e7aac0e, 0xd45d35e6ae3d4da1},
403      {0xbae0a846d2195712, 0x8974836059cca10a},
404      {0xe998d258869facd7, 0x2bd1a438703fc94c},
405      {0x91ff83775423cc06, 0x7b6306a34627ddd0},
406      {0xb67f6455292cbf08, 0x1a3bc84c17b1d543},
407      {0xe41f3d6a7377eeca, 0x20caba5f1d9e4a94},
408      {0x8e938662882af53e, 0x547eb47b7282ee9d},
409      {0xb23867fb2a35b28d, 0xe99e619a4f23aa44},
410      {0xdec681f9f4c31f31, 0x6405fa00e2ec94d5},
411      {0x8b3c113c38f9f37e, 0xde83bc408dd3dd05},
412      {0xae0b158b4738705e, 0x9624ab50b148d446},
413      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
414      {0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d7},
415      {0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4d},
416      {0xd47487cc8470652b, 0x7647c32000696720},
417      {0x84c8d4dfd2c63f3b, 0x29ecd9f40041e074},
418      {0xa5fb0a17c777cf09, 0xf468107100525891},
419      {0xcf79cc9db955c2cc, 0x7182148d4066eeb5},
420      {0x81ac1fe293d599bf, 0xc6f14cd848405531},
421      {0xa21727db38cb002f, 0xb8ada00e5a506a7d},
422      {0xca9cf1d206fdc03b, 0xa6d90811f0e4851d},
423      {0xfd442e4688bd304a, 0x908f4a166d1da664},
424      {0x9e4a9cec15763e2e, 0x9a598e4e043287ff},
425      {0xc5dd44271ad3cdba, 0x40eff1e1853f29fe},
426      {0xf7549530e188c128, 0xd12bee59e68ef47d},
427      {0x9a94dd3e8cf578b9, 0x82bb74f8301958cf},
428      {0xc13a148e3032d6e7, 0xe36a52363c1faf02},
429      {0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac2},
430      {0x96f5600f15a7b7e5, 0x29ab103a5ef8c0ba},
431      {0xbcb2b812db11a5de, 0x7415d448f6b6f0e8},
432      {0xebdf661791d60f56, 0x111b495b3464ad22},
433      {0x936b9fcebb25c995, 0xcab10dd900beec35},
434      {0xb84687c269ef3bfb, 0x3d5d514f40eea743},
435      {0xe65829b3046b0afa, 0x0cb4a5a3112a5113},
436      {0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ac},
437      {0xb3f4e093db73a093, 0x59ed216765690f57},
438      {0xe0f218b8d25088b8, 0x306869c13ec3532d},
439      {0x8c974f7383725573, 0x1e414218c73a13fc},
440      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
441      {0xdbac6c247d62a583, 0xdf45f746b74abf3a},
442      {0x894bc396ce5da772, 0x6b8bba8c328eb784},
443      {0xab9eb47c81f5114f, 0x066ea92f3f326565},
444      {0xd686619ba27255a2, 0xc80a537b0efefebe},
445      {0x8613fd0145877585, 0xbd06742ce95f5f37},
446      {0xa798fc4196e952e7, 0x2c48113823b73705},
447      {0xd17f3b51fca3a7a0, 0xf75a15862ca504c6},
448      {0x82ef85133de648c4, 0x9a984d73dbe722fc},
449      {0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebbb},
450      {0xcc963fee10b7d1b3, 0x318df905079926a9},
451      {0xffbbcfe994e5c61f, 0xfdf17746497f7053},
452      {0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa634},
453      {0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc1},
454      {0xf9bd690a1b68637b, 0x3dfdce7aa3c673b1},
455      {0x9c1661a651213e2d, 0x06bea10ca65c084f},
456      {0xc31bfa0fe5698db8, 0x486e494fcff30a63},
457      {0xf3e2f893dec3f126, 0x5a89dba3c3efccfb},
458      {0x986ddb5c6b3a76b7, 0xf89629465a75e01d},
459      {0xbe89523386091465, 0xf6bbb397f1135824},
460      {0xee2ba6c0678b597f, 0x746aa07ded582e2d},
461      {0x94db483840b717ef, 0xa8c2a44eb4571cdd},
462      {0xba121a4650e4ddeb, 0x92f34d62616ce414},
463      {0xe896a0d7e51e1566, 0x77b020baf9c81d18},
464      {0x915e2486ef32cd60, 0x0ace1474dc1d122f},
465      {0xb5b5ada8aaff80b8, 0x0d819992132456bb},
466      {0xe3231912d5bf60e6, 0x10e1fff697ed6c6a},
467      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
468      {0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb3},
469      {0xddd0467c64bce4a0, 0xac7cb3f6d05ddbdf},
470      {0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96c},
471      {0xad4ab7112eb3929d, 0x86c16c98d2c953c7},
472      {0xd89d64d57a607744, 0xe871c7bf077ba8b8},
473      {0x87625f056c7c4a8b, 0x11471cd764ad4973},
474      {0xa93af6c6c79b5d2d, 0xd598e40d3dd89bd0},
475      {0xd389b47879823479, 0x4aff1d108d4ec2c4},
476      {0x843610cb4bf160cb, 0xcedf722a585139bb},
477      {0xa54394fe1eedb8fe, 0xc2974eb4ee658829},
478      {0xce947a3da6a9273e, 0x733d226229feea33},
479      {0x811ccc668829b887, 0x0806357d5a3f5260},
480      {0xa163ff802a3426a8, 0xca07c2dcb0cf26f8},
481      {0xc9bcff6034c13052, 0xfc89b393dd02f0b6},
482      {0xfc2c3f3841f17c67, 0xbbac2078d443ace3},
483      {0x9d9ba7832936edc0, 0xd54b944b84aa4c0e},
484      {0xc5029163f384a931, 0x0a9e795e65d4df12},
485      {0xf64335bcf065d37d, 0x4d4617b5ff4a16d6},
486      {0x99ea0196163fa42e, 0x504bced1bf8e4e46},
487      {0xc06481fb9bcf8d39, 0xe45ec2862f71e1d7},
488      {0xf07da27a82c37088, 0x5d767327bb4e5a4d},
489      {0x964e858c91ba2655, 0x3a6a07f8d510f870},
490      {0xbbe226efb628afea, 0x890489f70a55368c},
491      {0xeadab0aba3b2dbe5, 0x2b45ac74ccea842f},
492      {0x92c8ae6b464fc96f, 0x3b0b8bc90012929e},
493      {0xb77ada0617e3bbcb, 0x09ce6ebb40173745},
494      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
495      {0x8f57fa54c2a9eab6, 0x9fa946824a12232e},
496      {0xb32df8e9f3546564, 0x47939822dc96abfa},
497      {0xdff9772470297ebd, 0x59787e2b93bc56f8},
498      {0x8bfbea76c619ef36, 0x57eb4edb3c55b65b},
499      {0xaefae51477a06b03, 0xede622920b6b23f2},
500      {0xdab99e59958885c4, 0xe95fab368e45ecee},
501      {0x88b402f7fd75539b, 0x11dbcb0218ebb415},
502      {0xaae103b5fcd2a881, 0xd652bdc29f26a11a},
503      {0xd59944a37c0752a2, 0x4be76d3346f04960},
504      {0x857fcae62d8493a5, 0x6f70a4400c562ddc},
505      {0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb953},
506      {0xd097ad07a71f26b2, 0x7e2000a41346a7a8},
507      {0x825ecc24c873782f, 0x8ed400668c0c28c9},
508      {0xa2f67f2dfa90563b, 0x728900802f0f32fb},
509      {0xcbb41ef979346bca, 0x4f2b40a03ad2ffba},
510      {0xfea126b7d78186bc, 0xe2f610c84987bfa9},
511      {0x9f24b832e6b0f436, 0x0dd9ca7d2df4d7ca},
512      {0xc6ede63fa05d3143, 0x91503d1c79720dbc},
513      {0xf8a95fcf88747d94, 0x75a44c6397ce912b},
514      {0x9b69dbe1b548ce7c, 0xc986afbe3ee11abb},
515      {0xc24452da229b021b, 0xfbe85badce996169},
516      {0xf2d56790ab41c2a2, 0xfae27299423fb9c4},
517      {0x97c560ba6b0919a5, 0xdccd879fc967d41b},
518      {0xbdb6b8e905cb600f, 0x5400e987bbc1c921},
519      {0xed246723473e3813, 0x290123e9aab23b69},
520      {0x9436c0760c86e30b, 0xf9a0b6720aaf6522},
521      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
522      {0xe7958cb87392c2c2, 0xb60b1d1230b20e05},
523      {0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c3},
524      {0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af4},
525      {0xe2280b6c20dd5232, 0x25c6da63c38de1b1},
526      {0x8d590723948a535f, 0x579c487e5a38ad0f},
527      {0xb0af48ec79ace837, 0x2d835a9df0c6d852},
528      {0xdcdb1b2798182244, 0xf8e431456cf88e66},
529      {0x8a08f0f8bf0f156b, 0x1b8e9ecb641b5900},
530      {0xac8b2d36eed2dac5, 0xe272467e3d222f40},
531      {0xd7adf884aa879177, 0x5b0ed81dcc6abb10},
532      {0x86ccbb52ea94baea, 0x98e947129fc2b4ea},
533      {0xa87fea27a539e9a5, 0x3f2398d747b36225},
534      {0xd29fe4b18e88640e, 0x8eec7f0d19a03aae},
535      {0x83a3eeeef9153e89, 0x1953cf68300424ad},
536      {0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd8},
537      {0xcdb02555653131b6, 0x3792f412cb06794e},
538      {0x808e17555f3ebf11, 0xe2bbd88bbee40bd1},
539      {0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec5},
540      {0xc8de047564d20a8b, 0xf245825a5a445276},
541      {0xfb158592be068d2e, 0xeed6e2f0f0d56713},
542      {0x9ced737bb6c4183d, 0x55464dd69685606c},
543      {0xc428d05aa4751e4c, 0xaa97e14c3c26b887},
544      {0xf53304714d9265df, 0xd53dd99f4b3066a9},
545      {0x993fe2c6d07b7fab, 0xe546a8038efe402a},
546      {0xbf8fdb78849a5f96, 0xde98520472bdd034},
547      {0xef73d256a5c0f77c, 0x963e66858f6d4441},
548      {0x95a8637627989aad, 0xdde7001379a44aa9},
549      {0xbb127c53b17ec159, 0x5560c018580d5d53},
550      {0xe9d71b689dde71af, 0xaab8f01e6e10b4a7},
551      {0x9226712162ab070d, 0xcab3961304ca70e9},
552      {0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d23},
553      {0xe45c10c42a2b3b05, 0x8cb89a7db77c506b},
554      {0x8eb98a7a9a5b04e3, 0x77f3608e92adb243},
555      {0xb267ed1940f1c61c, 0x55f038b237591ed4},
556      {0xdf01e85f912e37a3, 0x6b6c46dec52f6689},
557      {0x8b61313bbabce2c6, 0x2323ac4b3b3da016},
558      {0xae397d8aa96c1b77, 0xabec975e0a0d081b},
559      {0xd9c7dced53c72255, 0x96e7bd358c904a22},
560      {0x881cea14545c7575, 0x7e50d64177da2e55},
561      {0xaa242499697392d2, 0xdde50bd1d5d0b9ea},
562      {0xd4ad2dbfc3d07787, 0x955e4ec64b44e865},
563      {0x84ec3c97da624ab4, 0xbd5af13bef0b113f},
564      {0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58f},
565      {0xcfb11ead453994ba, 0x67de18eda5814af3},
566      {0x81ceb32c4b43fcf4, 0x80eacf948770ced8},
567      {0xa2425ff75e14fc31, 0xa1258379a94d028e},
568      {0xcad2f7f5359a3b3e, 0x096ee45813a04331},
569      {0xfd87b5f28300ca0d, 0x8bca9d6e188853fd},
570      {0x9e74d1b791e07e48, 0x775ea264cf55347e},
571      {0xc612062576589dda, 0x95364afe032a819e},
572      {0xf79687aed3eec551, 0x3a83ddbd83f52205},
573      {0x9abe14cd44753b52, 0xc4926a9672793543},
574      {0xc16d9a0095928a27, 0x75b7053c0f178294},
575      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
576      {0x971da05074da7bee, 0xd3f6fc16ebca5e04},
577      {0xbce5086492111aea, 0x88f4bb1ca6bcf585},
578      {0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6},
579      {0x9392ee8e921d5d07, 0x3aff322e62439fd0},
580      {0xb877aa3236a4b449, 0x09befeb9fad487c3},
581      {0xe69594bec44de15b, 0x4c2ebe687989a9b4},
582      {0x901d7cf73ab0acd9, 0x0f9d37014bf60a11},
583      {0xb424dc35095cd80f, 0x538484c19ef38c95},
584      {0xe12e13424bb40e13, 0x2865a5f206b06fba},
585      {0x8cbccc096f5088cb, 0xf93f87b7442e45d4},
586      {0xafebff0bcb24aafe, 0xf78f69a51539d749},
587      {0xdbe6fecebdedd5be, 0xb573440e5a884d1c},
588      {0x89705f4136b4a597, 0x31680a88f8953031},
589      {0xabcc77118461cefc, 0xfdc20d2b36ba7c3e},
590      {0xd6bf94d5e57a42bc, 0x3d32907604691b4d},
591      {0x8637bd05af6c69b5, 0xa63f9a49c2c1b110},
592      {0xa7c5ac471b478423, 0x0fcf80dc33721d54},
593      {0xd1b71758e219652b, 0xd3c36113404ea4a9},
594      {0x83126e978d4fdf3b, 0x645a1cac083126ea},
595      {0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4},
596      {0xcccccccccccccccc, 0xcccccccccccccccd},
597      {0x8000000000000000, 0x0000000000000000},
598      {0xa000000000000000, 0x0000000000000000},
599      {0xc800000000000000, 0x0000000000000000},
600      {0xfa00000000000000, 0x0000000000000000},
601      {0x9c40000000000000, 0x0000000000000000},
602      {0xc350000000000000, 0x0000000000000000},
603      {0xf424000000000000, 0x0000000000000000},
604      {0x9896800000000000, 0x0000000000000000},
605      {0xbebc200000000000, 0x0000000000000000},
606      {0xee6b280000000000, 0x0000000000000000},
607      {0x9502f90000000000, 0x0000000000000000},
608      {0xba43b74000000000, 0x0000000000000000},
609      {0xe8d4a51000000000, 0x0000000000000000},
610      {0x9184e72a00000000, 0x0000000000000000},
611      {0xb5e620f480000000, 0x0000000000000000},
612      {0xe35fa931a0000000, 0x0000000000000000},
613      {0x8e1bc9bf04000000, 0x0000000000000000},
614      {0xb1a2bc2ec5000000, 0x0000000000000000},
615      {0xde0b6b3a76400000, 0x0000000000000000},
616      {0x8ac7230489e80000, 0x0000000000000000},
617      {0xad78ebc5ac620000, 0x0000000000000000},
618      {0xd8d726b7177a8000, 0x0000000000000000},
619      {0x878678326eac9000, 0x0000000000000000},
620      {0xa968163f0a57b400, 0x0000000000000000},
621      {0xd3c21bcecceda100, 0x0000000000000000},
622      {0x84595161401484a0, 0x0000000000000000},
623      {0xa56fa5b99019a5c8, 0x0000000000000000},
624      {0xcecb8f27f4200f3a, 0x0000000000000000},
625      {0x813f3978f8940984, 0x4000000000000000},
626      {0xa18f07d736b90be5, 0x5000000000000000},
627      {0xc9f2c9cd04674ede, 0xa400000000000000},
628      {0xfc6f7c4045812296, 0x4d00000000000000},
629      {0x9dc5ada82b70b59d, 0xf020000000000000},
630      {0xc5371912364ce305, 0x6c28000000000000},
631      {0xf684df56c3e01bc6, 0xc732000000000000},
632      {0x9a130b963a6c115c, 0x3c7f400000000000},
633      {0xc097ce7bc90715b3, 0x4b9f100000000000},
634      {0xf0bdc21abb48db20, 0x1e86d40000000000},
635      {0x96769950b50d88f4, 0x1314448000000000},
636      {0xbc143fa4e250eb31, 0x17d955a000000000},
637      {0xeb194f8e1ae525fd, 0x5dcfab0800000000},
638      {0x92efd1b8d0cf37be, 0x5aa1cae500000000},
639      {0xb7abc627050305ad, 0xf14a3d9e40000000},
640      {0xe596b7b0c643c719, 0x6d9ccd05d0000000},
641      {0x8f7e32ce7bea5c6f, 0xe4820023a2000000},
642      {0xb35dbf821ae4f38b, 0xdda2802c8a800000},
643      {0xe0352f62a19e306e, 0xd50b2037ad200000},
644      {0x8c213d9da502de45, 0x4526f422cc340000},
645      {0xaf298d050e4395d6, 0x9670b12b7f410000},
646      {0xdaf3f04651d47b4c, 0x3c0cdd765f114000},
647      {0x88d8762bf324cd0f, 0xa5880a69fb6ac800},
648      {0xab0e93b6efee0053, 0x8eea0d047a457a00},
649      {0xd5d238a4abe98068, 0x72a4904598d6d880},
650      {0x85a36366eb71f041, 0x47a6da2b7f864750},
651      {0xa70c3c40a64e6c51, 0x999090b65f67d924},
652      {0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d},
653      {0x82818f1281ed449f, 0xbff8f10e7a8921a4},
654      {0xa321f2d7226895c7, 0xaff72d52192b6a0d},
655      {0xcbea6f8ceb02bb39, 0x9bf4f8a69f764490},
656      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
657      {0x9f4f2726179a2245, 0x01d762422c946590},
658      {0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef5},
659      {0xf8ebad2b84e0d58b, 0xd2e0898765a7deb2},
660      {0x9b934c3b330c8577, 0x63cc55f49f88eb2f},
661      {0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fb},
662      {0xf316271c7fc3908a, 0x8bef464e3945ef7a},
663      {0x97edd871cfda3a56, 0x97758bf0e3cbb5ac},
664      {0xbde94e8e43d0c8ec, 0x3d52eeed1cbea317},
665      {0xed63a231d4c4fb27, 0x4ca7aaa863ee4bdd},
666      {0x945e455f24fb1cf8, 0x8fe8caa93e74ef6a},
667      {0xb975d6b6ee39e436, 0xb3e2fd538e122b44},
668      {0xe7d34c64a9c85d44, 0x60dbbca87196b616},
669      {0x90e40fbeea1d3a4a, 0xbc8955e946fe31cd},
670      {0xb51d13aea4a488dd, 0x6babab6398bdbe41},
671      {0xe264589a4dcdab14, 0xc696963c7eed2dd1},
672      {0x8d7eb76070a08aec, 0xfc1e1de5cf543ca2},
673      {0xb0de65388cc8ada8, 0x3b25a55f43294bcb},
674      {0xdd15fe86affad912, 0x49ef0eb713f39ebe},
675      {0x8a2dbf142dfcc7ab, 0x6e3569326c784337},
676      {0xacb92ed9397bf996, 0x49c2c37f07965404},
677      {0xd7e77a8f87daf7fb, 0xdc33745ec97be906},
678      {0x86f0ac99b4e8dafd, 0x69a028bb3ded71a3},
679      {0xa8acd7c0222311bc, 0xc40832ea0d68ce0c},
680      {0xd2d80db02aabd62b, 0xf50a3fa490c30190},
681      {0x83c7088e1aab65db, 0x792667c6da79e0fa},
682      {0xa4b8cab1a1563f52, 0x577001b891185938},
683      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
684      {0x80b05e5ac60b6178, 0x544f8158315b05b4},
685      {0xa0dc75f1778e39d6, 0x696361ae3db1c721},
686      {0xc913936dd571c84c, 0x03bc3a19cd1e38e9},
687      {0xfb5878494ace3a5f, 0x04ab48a04065c723},
688      {0x9d174b2dcec0e47b, 0x62eb0d64283f9c76},
689      {0xc45d1df942711d9a, 0x3ba5d0bd324f8394},
690      {0xf5746577930d6500, 0xca8f44ec7ee36479},
691      {0x9968bf6abbe85f20, 0x7e998b13cf4e1ecb},
692      {0xbfc2ef456ae276e8, 0x9e3fedd8c321a67e},
693      {0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101e},
694      {0x95d04aee3b80ece5, 0xbba1f1d158724a12},
695      {0xbb445da9ca61281f, 0x2a8a6e45ae8edc97},
696      {0xea1575143cf97226, 0xf52d09d71a3293bd},
697      {0x924d692ca61be758, 0x593c2626705f9c56},
698      {0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836c},
699      {0xe498f455c38b997a, 0x0b6dfb9c0f956447},
700      {0x8edf98b59a373fec, 0x4724bd4189bd5eac},
701      {0xb2977ee300c50fe7, 0x58edec91ec2cb657},
702      {0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ed},
703      {0x8b865b215899f46c, 0xbd79e0d20082ee74},
704      {0xae67f1e9aec07187, 0xecd8590680a3aa11},
705      {0xda01ee641a708de9, 0xe80e6f4820cc9495},
706      {0x884134fe908658b2, 0x3109058d147fdcdd},
707      {0xaa51823e34a7eede, 0xbd4b46f0599fd415},
708      {0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91a},
709      {0x850fadc09923329e, 0x03e2cf6bc604ddb0},
710      {0xa6539930bf6bff45, 0x84db8346b786151c},
711      {0xcfe87f7cef46ff16, 0xe612641865679a63},
712      {0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07e},
713      {0xa26da3999aef7749, 0xe3be5e330f38f09d},
714      {0xcb090c8001ab551c, 0x5cadf5bfd3072cc5},
715      {0xfdcb4fa002162a63, 0x73d9732fc7c8f7f6},
716      {0x9e9f11c4014dda7e, 0x2867e7fddcdd9afa},
717      {0xc646d63501a1511d, 0xb281e1fd541501b8},
718      {0xf7d88bc24209a565, 0x1f225a7ca91a4226},
719      {0x9ae757596946075f, 0x3375788de9b06958},
720      {0xc1a12d2fc3978937, 0x0052d6b1641c83ae},
721      {0xf209787bb47d6b84, 0xc0678c5dbd23a49a},
722      {0x9745eb4d50ce6332, 0xf840b7ba963646e0},
723      {0xbd176620a501fbff, 0xb650e5a93bc3d898},
724      {0xec5d3fa8ce427aff, 0xa3e51f138ab4cebe},
725      {0x93ba47c980e98cdf, 0xc66f336c36b10137},
726      {0xb8a8d9bbe123f017, 0xb80b0047445d4184},
727      {0xe6d3102ad96cec1d, 0xa60dc059157491e5},
728      {0x9043ea1ac7e41392, 0x87c89837ad68db2f},
729      {0xb454e4a179dd1877, 0x29babe4598c311fb},
730      {0xe16a1dc9d8545e94, 0xf4296dd6fef3d67a},
731      {0x8ce2529e2734bb1d, 0x1899e4a65f58660c},
732      {0xb01ae745b101e9e4, 0x5ec05dcff72e7f8f},
733      {0xdc21a1171d42645d, 0x76707543f4fa1f73},
734      {0x899504ae72497eba, 0x6a06494a791c53a8},
735      {0xabfa45da0edbde69, 0x0487db9d17636892},
736      {0xd6f8d7509292d603, 0x45a9d2845d3c42b6},
737      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
738      {0xa7f26836f282b732, 0x8e6cac7768d7141e},
739      {0xd1ef0244af2364ff, 0x3207d795430cd926},
740      {0x8335616aed761f1f, 0x7f44e6bd49e807b8},
741      {0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a6},
742      {0xcd036837130890a1, 0x36dba887c37a8c0f},
743      {0x802221226be55a64, 0xc2494954da2c9789},
744      {0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6c},
745      {0xc83553c5c8965d3d, 0x6f92829494e5acc7},
746      {0xfa42a8b73abbf48c, 0xcb772339ba1f17f9},
747      {0x9c69a97284b578d7, 0xff2a760414536efb},
748      {0xc38413cf25e2d70d, 0xfef5138519684aba},
749      {0xf46518c2ef5b8cd1, 0x7eb258665fc25d69},
750      {0x98bf2f79d5993802, 0xef2f773ffbd97a61},
751      {0xbeeefb584aff8603, 0xaafb550ffacfd8fa},
752      {0xeeaaba2e5dbf6784, 0x95ba2a53f983cf38},
753      {0x952ab45cfa97a0b2, 0xdd945a747bf26183},
754      {0xba756174393d88df, 0x94f971119aeef9e4},
755      {0xe912b9d1478ceb17, 0x7a37cd5601aab85d},
756      {0x91abb422ccb812ee, 0xac62e055c10ab33a},
757      {0xb616a12b7fe617aa, 0x577b986b314d6009},
758      {0xe39c49765fdf9d94, 0xed5a7e85fda0b80b},
759      {0x8e41ade9fbebc27d, 0x14588f13be847307},
760      {0xb1d219647ae6b31c, 0x596eb2d8ae258fc8},
761      {0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bb},
762      {0x8aec23d680043bee, 0x25de7bb9480d5854},
763      {0xada72ccc20054ae9, 0xaf561aa79a10ae6a},
764      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
765      {0x87aa9aff79042286, 0x90fb44d2f05d0842},
766      {0xa99541bf57452b28, 0x353a1607ac744a53},
767      {0xd3fa922f2d1675f2, 0x42889b8997915ce8},
768      {0x847c9b5d7c2e09b7, 0x69956135febada11},
769      {0xa59bc234db398c25, 0x43fab9837e699095},
770      {0xcf02b2c21207ef2e, 0x94f967e45e03f4bb},
771      {0x8161afb94b44f57d, 0x1d1be0eebac278f5},
772      {0xa1ba1ba79e1632dc, 0x6462d92a69731732},
773      {0xca28a291859bbf93, 0x7d7b8f7503cfdcfe},
774      {0xfcb2cb35e702af78, 0x5cda735244c3d43e},
775      {0x9defbf01b061adab, 0x3a0888136afa64a7},
776      {0xc56baec21c7a1916, 0x088aaa1845b8fdd0},
777      {0xf6c69a72a3989f5b, 0x8aad549e57273d45},
778      {0x9a3c2087a63f6399, 0x36ac54e2f678864b},
779      {0xc0cb28a98fcf3c7f, 0x84576a1bb416a7dd},
780      {0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d5},
781      {0x969eb7c47859e743, 0x9f644ae5a4b1b325},
782      {0xbc4665b596706114, 0x873d5d9f0dde1fee},
783      {0xeb57ff22fc0c7959, 0xa90cb506d155a7ea},
784      {0x9316ff75dd87cbd8, 0x09a7f12442d588f2},
785      {0xb7dcbf5354e9bece, 0x0c11ed6d538aeb2f},
786      {0xe5d3ef282a242e81, 0x8f1668c8a86da5fa},
787      {0x8fa475791a569d10, 0xf96e017d694487bc},
788      {0xb38d92d760ec4455, 0x37c981dcc395a9ac},
789      {0xe070f78d3927556a, 0x85bbe253f47b1417},
790      {0x8c469ab843b89562, 0x93956d7478ccec8e},
791      {0xaf58416654a6babb, 0x387ac8d1970027b2},
792      {0xdb2e51bfe9d0696a, 0x06997b05fcc0319e},
793      {0x88fcf317f22241e2, 0x441fece3bdf81f03},
794      {0xab3c2fddeeaad25a, 0xd527e81cad7626c3},
795      {0xd60b3bd56a5586f1, 0x8a71e223d8d3b074},
796      {0x85c7056562757456, 0xf6872d5667844e49},
797      {0xa738c6bebb12d16c, 0xb428f8ac016561db},
798      {0xd106f86e69d785c7, 0xe13336d701beba52},
799      {0x82a45b450226b39c, 0xecc0024661173473},
800      {0xa34d721642b06084, 0x27f002d7f95d0190},
801      {0xcc20ce9bd35c78a5, 0x31ec038df7b441f4},
802      {0xff290242c83396ce, 0x7e67047175a15271},
803      {0x9f79a169bd203e41, 0x0f0062c6e984d386},
804      {0xc75809c42c684dd1, 0x52c07b78a3e60868},
805      {0xf92e0c3537826145, 0xa7709a56ccdf8a82},
806      {0x9bbcc7a142b17ccb, 0x88a66076400bb691},
807      {0xc2abf989935ddbfe, 0x6acff893d00ea435},
808      {0xf356f7ebf83552fe, 0x0583f6b8c4124d43},
809      {0x98165af37b2153de, 0xc3727a337a8b704a},
810      {0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5c},
811      {0xeda2ee1c7064130c, 0x1162def06f79df73},
812      {0x9485d4d1c63e8be7, 0x8addcb5645ac2ba8},
813      {0xb9a74a0637ce2ee1, 0x6d953e2bd7173692},
814      {0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0437},
815      {0x910ab1d4db9914a0, 0x1d9c9892400a22a2},
816      {0xb54d5e4a127f59c8, 0x2503beb6d00cab4b},
817      {0xe2a0b5dc971f303a, 0x2e44ae64840fd61d},
818      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
819      {0xb10d8e1456105dad, 0x7425a83e872c5f47},
820      {0xdd50f1996b947518, 0xd12f124e28f77719},
821      {0x8a5296ffe33cc92f, 0x82bd6b70d99aaa6f},
822      {0xace73cbfdc0bfb7b, 0x636cc64d1001550b},
823      {0xd8210befd30efa5a, 0x3c47f7e05401aa4e},
824      {0x8714a775e3e95c78, 0x65acfaec34810a71},
825      {0xa8d9d1535ce3b396, 0x7f1839a741a14d0d},
826      {0xd31045a8341ca07c, 0x1ede48111209a050},
827      {0x83ea2b892091e44d, 0x934aed0aab460432},
828      {0xa4e4b66b68b65d60, 0xf81da84d5617853f},
829      {0xce1de40642e3f4b9, 0x36251260ab9d668e},
830      {0x80d2ae83e9ce78f3, 0xc1d72b7c6b426019},
831      {0xa1075a24e4421730, 0xb24cf65b8612f81f},
832      {0xc94930ae1d529cfc, 0xdee033f26797b627},
833      {0xfb9b7cd9a4a7443c, 0x169840ef017da3b1},
834      {0x9d412e0806e88aa5, 0x8e1f289560ee864e},
835      {0xc491798a08a2ad4e, 0xf1a6f2bab92a27e2},
836      {0xf5b5d7ec8acb58a2, 0xae10af696774b1db},
837      {0x9991a6f3d6bf1765, 0xacca6da1e0a8ef29},
838      {0xbff610b0cc6edd3f, 0x17fd090a58d32af3},
839      {0xeff394dcff8a948e, 0xddfc4b4cef07f5b0},
840      {0x95f83d0a1fb69cd9, 0x4abdaf101564f98e},
841      {0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f1},
842      {0xea53df5fd18d5513, 0x84c86189216dc5ed},
843      {0x92746b9be2f8552c, 0x32fd3cf5b4e49bb4},
844      {0xb7118682dbb66a77, 0x3fbc8c33221dc2a1},
845      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
846      {0x8f05b1163ba6832d, 0x29cb4d87f2a7400e},
847      {0xb2c71d5bca9023f8, 0x743e20e9ef511012},
848      {0xdf78e4b2bd342cf6, 0x914da9246b255416},
849      {0x8bab8eefb6409c1a, 0x1ad089b6c2f7548e},
850      {0xae9672aba3d0c320, 0xa184ac2473b529b1},
851      {0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741e},
852      {0x8865899617fb1871, 0x7e2fa67c7a658892},
853      {0xaa7eebfb9df9de8d, 0xddbb901b98feeab7},
854      {0xd51ea6fa85785631, 0x552a74227f3ea565},
855      {0x8533285c936b35de, 0xd53a88958f87275f},
856      {0xa67ff273b8460356, 0x8a892abaf368f137},
857      {0xd01fef10a657842c, 0x2d2b7569b0432d85},
858      {0x8213f56a67f6b29b, 0x9c3b29620e29fc73},
859      {0xa298f2c501f45f42, 0x8349f3ba91b47b8f},
860      {0xcb3f2f7642717713, 0x241c70a936219a73},
861      {0xfe0efb53d30dd4d7, 0xed238cd383aa0110},
862      {0x9ec95d1463e8a506, 0xf4363804324a40aa},
863      {0xc67bb4597ce2ce48, 0xb143c6053edcd0d5},
864      {0xf81aa16fdc1b81da, 0xdd94b7868e94050a},
865      {0x9b10a4e5e9913128, 0xca7cf2b4191c8326},
866      {0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f0},
867      {0xf24a01a73cf2dccf, 0xbc633b39673c8cec},
868      {0x976e41088617ca01, 0xd5be0503e085d813},
869      {0xbd49d14aa79dbc82, 0x4b2d8644d8a74e18},
870      {0xec9c459d51852ba2, 0xddf8e7d60ed1219e},
871      {0x93e1ab8252f33b45, 0xcabb90e5c942b503},
872      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
873      {0xe7109bfba19c0c9d, 0x0cc512670a783ad4},
874      {0x906a617d450187e2, 0x27fb2b80668b24c5},
875      {0xb484f9dc9641e9da, 0xb1f9f660802dedf6},
876      {0xe1a63853bbd26451, 0x5e7873f8a0396973},
877      {0x8d07e33455637eb2, 0xdb0b487b6423e1e8},
878      {0xb049dc016abc5e5f, 0x91ce1a9a3d2cda62},
879      {0xdc5c5301c56b75f7, 0x7641a140cc7810fb},
880      {0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9d},
881      {0xac2820d9623bf429, 0x546345fa9fbdcd44},
882      {0xd732290fbacaf133, 0xa97c177947ad4095},
883      {0x867f59a9d4bed6c0, 0x49ed8eabcccc485d},
884      {0xa81f301449ee8c70, 0x5c68f256bfff5a74},
885      {0xd226fc195c6a2f8c, 0x73832eec6fff3111},
886      {0x83585d8fd9c25db7, 0xc831fd53c5ff7eab},
887      {0xa42e74f3d032f525, 0xba3e7ca8b77f5e55},
888      {0xcd3a1230c43fb26f, 0x28ce1bd2e55f35eb},
889      {0x80444b5e7aa7cf85, 0x7980d163cf5b81b3},
890      {0xa0555e361951c366, 0xd7e105bcc332621f},
891      {0xc86ab5c39fa63440, 0x8dd9472bf3fefaa7},
892      {0xfa856334878fc150, 0xb14f98f6f0feb951},
893      {0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d3},
894      {0xc3b8358109e84f07, 0x0a862f80ec4700c8},
895      {0xf4a642e14c6262c8, 0xcd27bb612758c0fa},
896      {0x98e7e9cccfbd7dbd, 0x8038d51cb897789c},
897      {0xbf21e44003acdd2c, 0xe0470a63e6bd56c3},
898      {0xeeea5d5004981478, 0x1858ccfce06cac74},
899      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8},
900      {0xbaa718e68396cffd, 0xd30560258f54e6ba},
901      {0xe950df20247c83fd, 0x47c6b82ef32a2069},
902      {0x91d28b7416cdd27e, 0x4cdc331d57fa5441},
903      {0xb6472e511c81471d, 0xe0133fe4adf8e952},
904      {0xe3d8f9e563a198e5, 0x58180fddd97723a6},
905      {0x8e679c2f5e44ff8f, 0x570f09eaa7ea7648},
906      {0xb201833b35d63f73, 0x2cd2cc6551e513da},
907      {0xde81e40a034bcf4f, 0xf8077f7ea65e58d1},
908      {0x8b112e86420f6191, 0xfb04afaf27faf782},
909      {0xadd57a27d29339f6, 0x79c5db9af1f9b563},
910      {0xd94ad8b1c7380874, 0x18375281ae7822bc},
911      {0x87cec76f1c830548, 0x8f2293910d0b15b5},
912      {0xa9c2794ae3a3c69a, 0xb2eb3875504ddb22},
913      {0xd433179d9c8cb841, 0x5fa60692a46151eb},
914      {0x849feec281d7f328, 0xdbc7c41ba6bcd333},
915      {0xa5c7ea73224deff3, 0x12b9b522906c0800},
916      {0xcf39e50feae16bef, 0xd768226b34870a00},
917      {0x81842f29f2cce375, 0xe6a1158300d46640},
918      {0xa1e53af46f801c53, 0x60495ae3c1097fd0},
919      {0xca5e89b18b602368, 0x385bb19cb14bdfc4},
920      {0xfcf62c1dee382c42, 0x46729e03dd9ed7b5},
921      {0x9e19db92b4e31ba9, 0x6c07a2c26a8346d1},
922      {0xc5a05277621be293, 0xc7098b7305241885},
923      {0xf70867153aa2db38, 0xb8cbee4fc66d1ea7}
924  #else
925      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
926      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
927      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
928      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
929      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
930      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
931      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
932      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
933      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
934      {0x95a8637627989aad, 0xdde7001379a44aa9},
935      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
936      {0xc350000000000000, 0x0000000000000000},
937      {0x9dc5ada82b70b59d, 0xf020000000000000},
938      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
939      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
940      {0xa6539930bf6bff45, 0x84db8346b786151c},
941      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
942      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
943      {0xaf58416654a6babb, 0x387ac8d1970027b2},
944      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
945      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
946      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
947      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8}
948  #endif
949  };
950  #if !FMT_USE_FULL_CACHE_DRAGONBOX
951  template <typename T>
952  const uint64_t basic_data<T>::powers_of_5_64[] = {
953      0x0000000000000001, 0x0000000000000005, 0x0000000000000019,
954      0x000000000000007d, 0x0000000000000271, 0x0000000000000c35,
955      0x0000000000003d09, 0x000000000001312d, 0x000000000005f5e1,
956      0x00000000001dcd65, 0x00000000009502f9, 0x0000000002e90edd,
957      0x000000000e8d4a51, 0x0000000048c27395, 0x000000016bcc41e9,
958      0x000000071afd498d, 0x0000002386f26fc1, 0x000000b1a2bc2ec5,
959      0x000003782dace9d9, 0x00001158e460913d, 0x000056bc75e2d631,
960      0x0001b1ae4d6e2ef5, 0x000878678326eac9, 0x002a5a058fc295ed,
961      0x00d3c21bcecceda1, 0x0422ca8b0a00a425, 0x14adf4b7320334b9};
962  template <typename T>
963  const uint32_t basic_data<T>::dragonbox_pow10_recovery_errors[] = {
964      0x50001400, 0x54044100, 0x54014555, 0x55954415, 0x54115555, 0x00000001,
965      0x50000000, 0x00104000, 0x54010004, 0x05004001, 0x55555544, 0x41545555,
966      0x54040551, 0x15445545, 0x51555514, 0x10000015, 0x00101100, 0x01100015,
967      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04450514, 0x45414110,
968      0x55555145, 0x50544050, 0x15040155, 0x11054140, 0x50111514, 0x11451454,
969      0x00400541, 0x00000000, 0x55555450, 0x10056551, 0x10054011, 0x55551014,
970      0x69514555, 0x05151109, 0x00155555};
971  #endif
972  template <typename T>
973  const char basic_data<T>::foreground_color[] = "\x1b[38;2;";
974  template <typename T>
975  const char basic_data<T>::background_color[] = "\x1b[48;2;";
976  template <typename T> const char basic_data<T>::reset_color[] = "\x1b[0m";
977  template <typename T> const wchar_t basic_data<T>::wreset_color[] = L"\x1b[0m";
978  template <typename T> const char basic_data<T>::signs[] = {0, '-', '+', ' '};
979  template <typename T>
980  const char basic_data<T>::left_padding_shifts[] = {31, 31, 0, 1, 0};
981  template <typename T>
982  const char basic_data<T>::right_padding_shifts[] = {0, 31, 0, 1, 0};
983  template <typename T> struct bits {
984    static FMT_CONSTEXPR_DECL const int value =
985        static_cast<int>(sizeof(T) * std::numeric_limits<unsigned char>::digits);
986  };
987  class fp;
988  template <int SHIFT = 0> fp normalize(fp value);
989  struct boundaries {
990    uint64_t lower;
991    uint64_t upper;
992  };
993  class fp {
994   private:
995    using significand_type = uint64_t;
996    template <typename Float>
997    using is_supported_float = bool_constant<sizeof(Float) == sizeof(uint64_t) ||
998                                             sizeof(Float) == sizeof(uint32_t)>;
999   public:
1000    significand_type f;
1001    int e;
1002    static FMT_CONSTEXPR_DECL const int double_significand_size =
1003        std::numeric_limits<double>::digits - 1;
1004    static FMT_CONSTEXPR_DECL const uint64_t implicit_bit =
1005        1ULL << double_significand_size;
1006    static FMT_CONSTEXPR_DECL const int significand_size =
1007        bits<significand_type>::value;
1008    fp() : f(0), e(0) {}
1009    fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}
1010    template <typename Double> explicit fp(Double d) { assign(d); }
1011    template <typename Float, FMT_ENABLE_IF(is_supported_float<Float>::value)>
1012    bool assign(Float d) {
1013      using limits = std::numeric_limits<Float>;
1014      const int float_significand_size = limits::digits - 1;
1015      const int exponent_size =
1016          bits<Float>::value - float_significand_size - 1;  
1017      const uint64_t float_implicit_bit = 1ULL << float_significand_size;
1018      const uint64_t significand_mask = float_implicit_bit - 1;
1019      const uint64_t exponent_mask = (~0ULL >> 1) & ~significand_mask;
1020      const int exponent_bias = (1 << exponent_size) - limits::max_exponent - 1;
1021      constexpr bool is_double = sizeof(Float) == sizeof(uint64_t);
1022      auto u = bit_cast<conditional_t<is_double, uint64_t, uint32_t>>(d);
1023      f = u & significand_mask;
1024      int biased_e =
1025          static_cast<int>((u & exponent_mask) >> float_significand_size);
1026      bool is_predecessor_closer = f == 0 && biased_e > 1;
1027      if (biased_e != 0)
1028        f += float_implicit_bit;
1029      else
1030        biased_e = 1;  
1031      e = biased_e - exponent_bias - float_significand_size;
1032      return is_predecessor_closer;
1033    }
1034    template <typename Float, FMT_ENABLE_IF(!is_supported_float<Float>::value)>
1035    bool assign(Float) {
1036      *this = fp();
1037      return false;
1038    }
1039  };
1040  template <int SHIFT> fp normalize(fp value) {
1041    const auto shifted_implicit_bit = fp::implicit_bit << SHIFT;
1042    while ((value.f & shifted_implicit_bit) == 0) {
1043      value.f <<= 1;
1044      --value.e;
1045    }
1046    const auto offset =
1047        fp::significand_size - fp::double_significand_size - SHIFT - 1;
1048    value.f <<= offset;
1049    value.e -= offset;
1050    return value;
1051  }
1052  inline bool operator==(fp x, fp y) { return x.f == y.f && x.e == y.e; }
1053  inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
1054  #if FMT_USE_INT128
1055    auto product = static_cast<__uint128_t>(lhs) * rhs;
1056    auto f = static_cast<uint64_t>(product >> 64);
1057    return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
1058  #else
1059    uint64_t mask = (1ULL << 32) - 1;
1060    uint64_t a = lhs >> 32, b = lhs & mask;
1061    uint64_t c = rhs >> 32, d = rhs & mask;
1062    uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
1063    uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
1064    return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
1065  #endif
1066  }
1067  inline fp operator*(fp x, fp y) { return {multiply(x.f, y.f), x.e + y.e + 64}; }
1068  inline fp get_cached_power(int min_exponent, int& pow10_exponent) {
1069    const int shift = 32;
1070    const auto significand = static_cast<int64_t>(data::log10_2_significand);
1071    int index = static_cast<int>(
1072        ((min_exponent + fp::significand_size - 1) * (significand >> shift) +
1073         ((int64_t(1) << shift) - 1))  
1074        >> 32                          
1075    );
1076    const int first_dec_exp = -348;
1077    const int dec_exp_step = 8;
1078    index = (index - first_dec_exp - 1) / dec_exp_step + 1;
1079    pow10_exponent = first_dec_exp + index * dec_exp_step;
1080    return {data::grisu_pow10_significands[index],
1081            data::grisu_pow10_exponents[index]};
1082  }
1083  struct accumulator {
1084    uint64_t lower;
1085    uint64_t upper;
1086    accumulator() : lower(0), upper(0) {}
1087    explicit operator uint32_t() const { return static_cast<uint32_t>(lower); }
1088    void operator+=(uint64_t n) {
1089      lower += n;
1090      if (lower < n) ++upper;
1091    }
1092    void operator>>=(int shift) {
1093      assert(shift == 32);
1094      (void)shift;
1095      lower = (upper << 32) | (lower >> 32);
1096      upper >>= 32;
1097    }
1098  };
1099  class bigint {
1100   private:
1101    using bigit = uint32_t;
1102    using double_bigit = uint64_t;
1103    enum { bigits_capacity = 32 };
1104    basic_memory_buffer<bigit, bigits_capacity> bigits_;
1105    int exp_;
1106    bigit operator[](int index) const { return bigits_[to_unsigned(index)]; }
1107    bigit& operator[](int index) { return bigits_[to_unsigned(index)]; }
1108    static FMT_CONSTEXPR_DECL const int bigit_bits = bits<bigit>::value;
1109    friend struct formatter<bigint>;
1110    void subtract_bigits(int index, bigit other, bigit& borrow) {
1111      auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
1112      (*this)[index] = static_cast<bigit>(result);
1113      borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
1114    }
1115    void remove_leading_zeros() {
1116      int num_bigits = static_cast<int>(bigits_.size()) - 1;
1117      while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
1118      bigits_.resize(to_unsigned(num_bigits + 1));
1119    }
1120    void subtract_aligned(const bigint& other) {
1121      FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
1122      FMT_ASSERT(compare(*this, other) >= 0, "");
1123      bigit borrow = 0;
1124      int i = other.exp_ - exp_;
1125      for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
1126        subtract_bigits(i, other.bigits_[j], borrow);
1127      while (borrow > 0) subtract_bigits(i, 0, borrow);
1128      remove_leading_zeros();
1129    }
1130    void multiply(uint32_t value) {
1131      const double_bigit wide_value = value;
1132      bigit carry = 0;
1133      for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
1134        double_bigit result = bigits_[i] * wide_value + carry;
1135        bigits_[i] = static_cast<bigit>(result);
1136        carry = static_cast<bigit>(result >> bigit_bits);
1137      }
1138      if (carry != 0) bigits_.push_back(carry);
1139    }
1140    void multiply(uint64_t value) {
1141      const bigit mask = ~bigit(0);
1142      const double_bigit lower = value & mask;
1143      const double_bigit upper = value >> bigit_bits;
1144      double_bigit carry = 0;
1145      for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
1146        double_bigit result = bigits_[i] * lower + (carry & mask);
1147        carry =
1148            bigits_[i] * upper + (result >> bigit_bits) + (carry >> bigit_bits);
1149        bigits_[i] = static_cast<bigit>(result);
1150      }
1151      while (carry != 0) {
1152        bigits_.push_back(carry & mask);
1153        carry >>= bigit_bits;
1154      }
1155    }
1156   public:
1157    bigint() : exp_(0) {}
1158    explicit bigint(uint64_t n) { assign(n); }
1159    ~bigint() { assert(bigits_.capacity() <= bigits_capacity); }
1160    bigint(const bigint&) = delete;
1161    void operator=(const bigint&) = delete;
1162    void assign(const bigint& other) {
1163      auto size = other.bigits_.size();
1164      bigits_.resize(size);
1165      auto data = other.bigits_.data();
1166      std::copy(data, data + size, make_checked(bigits_.data(), size));
1167      exp_ = other.exp_;
1168    }
1169    void assign(uint64_t n) {
1170      size_t num_bigits = 0;
1171      do {
1172        bigits_[num_bigits++] = n & ~bigit(0);
1173        n >>= bigit_bits;
1174      } while (n != 0);
1175      bigits_.resize(num_bigits);
1176      exp_ = 0;
1177    }
1178    int num_bigits() const { return static_cast<int>(bigits_.size()) + exp_; }
1179    FMT_NOINLINE bigint& operator<<=(int shift) {
1180      assert(shift >= 0);
1181      exp_ += shift / bigit_bits;
1182      shift %= bigit_bits;
1183      if (shift == 0) return *this;
1184      bigit carry = 0;
1185      for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
1186        bigit c = bigits_[i] >> (bigit_bits - shift);
1187        bigits_[i] = (bigits_[i] << shift) + carry;
1188        carry = c;
1189      }
1190      if (carry != 0) bigits_.push_back(carry);
1191      return *this;
1192    }
1193    template <typename Int> bigint& operator*=(Int value) {
1194      FMT_ASSERT(value > 0, "");
1195      multiply(uint32_or_64_or_128_t<Int>(value));
1196      return *this;
1197    }
1198    friend int compare(const bigint& lhs, const bigint& rhs) {
1199      int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
1200      if (num_lhs_bigits != num_rhs_bigits)
1201        return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
1202      int i = static_cast<int>(lhs.bigits_.size()) - 1;
1203      int j = static_cast<int>(rhs.bigits_.size()) - 1;
1204      int end = i - j;
1205      if (end < 0) end = 0;
1206      for (; i >= end; --i, --j) {
1207        bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
1208        if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
1209      }
1210      if (i != j) return i > j ? 1 : -1;
1211      return 0;
1212    }
1213    friend int add_compare(const bigint& lhs1, const bigint& lhs2,
1214                           const bigint& rhs) {
1215      int max_lhs_bigits = (std::max)(lhs1.num_bigits(), lhs2.num_bigits());
1216      int num_rhs_bigits = rhs.num_bigits();
1217      if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
1218      if (max_lhs_bigits > num_rhs_bigits) return 1;
1219      auto get_bigit = [](const bigint& n, int i) -> bigit {
1220        return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
1221      };
1222      double_bigit borrow = 0;
1223      int min_exp = (std::min)((std::min)(lhs1.exp_, lhs2.exp_), rhs.exp_);
1224      for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
1225        double_bigit sum =
1226            static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
1227        bigit rhs_bigit = get_bigit(rhs, i);
1228        if (sum > rhs_bigit + borrow) return 1;
1229        borrow = rhs_bigit + borrow - sum;
1230        if (borrow > 1) return -1;
1231        borrow <<= bigit_bits;
1232      }
1233      return borrow != 0 ? -1 : 0;
1234    }
1235    void assign_pow10(int exp) {
1236      assert(exp >= 0);
1237      if (exp == 0) return assign(1);
1238      int bitmask = 1;
1239      while (exp >= bitmask) bitmask <<= 1;
1240      bitmask >>= 1;
1241      assign(5);
1242      bitmask >>= 1;
1243      while (bitmask != 0) {
1244        square();
1245        if ((exp & bitmask) != 0) *this *= 5;
1246        bitmask >>= 1;
1247      }
1248      *this <<= exp;  
1249    }
1250    void square() {
1251      basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));
1252      int num_bigits = static_cast<int>(bigits_.size());
1253      int num_result_bigits = 2 * num_bigits;
1254      bigits_.resize(to_unsigned(num_result_bigits));
1255      using accumulator_t = conditional_t<FMT_USE_INT128, uint128_t, accumulator>;
1256      auto sum = accumulator_t();
1257      for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
1258        for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
1259          sum += static_cast<double_bigit>(n[i]) * n[j];
1260        }
1261        (*this)[bigit_index] = static_cast<bigit>(sum);
1262        sum >>= bits<bigit>::value;  
1263      }
1264      for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
1265           ++bigit_index) {
1266        for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
1267          sum += static_cast<double_bigit>(n[i++]) * n[j--];
1268        (*this)[bigit_index] = static_cast<bigit>(sum);
1269        sum >>= bits<bigit>::value;
1270      }
1271      --num_result_bigits;
1272      remove_leading_zeros();
1273      exp_ *= 2;
1274    }
1275    void align(const bigint& other) {
1276      int exp_difference = exp_ - other.exp_;
1277      if (exp_difference <= 0) return;
1278      int num_bigits = static_cast<int>(bigits_.size());
1279      bigits_.resize(to_unsigned(num_bigits + exp_difference));
1280      for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
1281        bigits_[j] = bigits_[i];
1282      std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
1283      exp_ -= exp_difference;
1284    }
1285    int divmod_assign(const bigint& divisor) {
1286      FMT_ASSERT(this != &divisor, "");
1287      if (compare(*this, divisor) < 0) return 0;
1288      FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
1289      align(divisor);
1290      int quotient = 0;
1291      do {
1292        subtract_aligned(divisor);
1293        ++quotient;
1294      } while (compare(*this, divisor) >= 0);
1295      return quotient;
1296    }
1297  };
1298  enum class round_direction { unknown, up, down };
1299  inline round_direction get_round_direction(uint64_t divisor, uint64_t remainder,
1300                                             uint64_t error) {
1301    FMT_ASSERT(remainder < divisor, "");  
1302    FMT_ASSERT(error < divisor, "");      
1303    FMT_ASSERT(error < divisor - error, "");  
1304    if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
1305      return round_direction::down;
1306    if (remainder >= error &&
1307        remainder - error >= divisor - (remainder - error)) {
1308      return round_direction::up;
1309    }
1310    return round_direction::unknown;
1311  }
1312  namespace digits {
1313  enum result {
1314    more,  
1315    done,  
1316    error  
1317  };
1318  }
1319  template <typename Handler>
1320  FMT_ALWAYS_INLINE digits::result grisu_gen_digits(fp value, uint64_t error,
1321                                                    int& exp, Handler& handler) {
1322    const fp one(1ULL << -value.e, value.e);
1323    auto integral = static_cast<uint32_t>(value.f >> -one.e);
1324    FMT_ASSERT(integral != 0, "");
1325    FMT_ASSERT(integral == value.f >> -one.e, "");
1326    uint64_t fractional = value.f & (one.f - 1);
1327    exp = count_digits(integral);  
1328    auto result = handler.on_start(data::powers_of_10_64[exp - 1] << -one.e,
1329                                   value.f / 10, error * 10, exp);
1330    if (result != digits::more) return result;
1331    do {
1332      uint32_t digit = 0;
1333      auto divmod_integral = [&](uint32_t divisor) {
1334        digit = integral / divisor;
1335        integral %= divisor;
1336      };
1337      switch (exp) {
1338      case 10:
1339        divmod_integral(1000000000);
1340        break;
1341      case 9:
1342        divmod_integral(100000000);
1343        break;
1344      case 8:
1345        divmod_integral(10000000);
1346        break;
1347      case 7:
1348        divmod_integral(1000000);
1349        break;
1350      case 6:
1351        divmod_integral(100000);
1352        break;
1353      case 5:
1354        divmod_integral(10000);
1355        break;
1356      case 4:
1357        divmod_integral(1000);
1358        break;
1359      case 3:
1360        divmod_integral(100);
1361        break;
1362      case 2:
1363        divmod_integral(10);
1364        break;
1365      case 1:
1366        digit = integral;
1367        integral = 0;
1368        break;
1369      default:
1370        FMT_ASSERT(false, "invalid number of digits");
1371      }
1372      --exp;
1373      auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
1374      result = handler.on_digit(static_cast<char>('0' + digit),
1375                                data::powers_of_10_64[exp] << -one.e, remainder,
1376                                error, exp, true);
1377      if (result != digits::more) return result;
1378    } while (exp > 0);
1379    for (;;) {
1380      fractional *= 10;
1381      error *= 10;
1382      char digit = static_cast<char>('0' + (fractional >> -one.e));
1383      fractional &= one.f - 1;
1384      --exp;
1385      result = handler.on_digit(digit, one.f, fractional, error, exp, false);
1386      if (result != digits::more) return result;
1387    }
1388  }
1389  struct fixed_handler {
1390    char* buf;
1391    int size;
1392    int precision;
1393    int exp10;
1394    bool fixed;
1395    digits::result on_start(uint64_t divisor, uint64_t remainder, uint64_t error,
1396                            int& exp) {
1397      if (!fixed) return digits::more;
1398      precision += exp + exp10;
1399      if (precision > 0) return digits::more;
1400      if (precision < 0) return digits::done;
1401      auto dir = get_round_direction(divisor, remainder, error);
1402      if (dir == round_direction::unknown) return digits::error;
1403      buf[size++] = dir == round_direction::up ? '1' : '0';
1404      return digits::done;
1405    }
1406    digits::result on_digit(char digit, uint64_t divisor, uint64_t remainder,
1407                            uint64_t error, int, bool integral) {
1408      FMT_ASSERT(remainder < divisor, "");
1409      buf[size++] = digit;
1410      if (!integral && error >= remainder) return digits::error;
1411      if (size < precision) return digits::more;
1412      if (!integral) {
1413        if (error >= divisor || error >= divisor - error) return digits::error;
1414      } else {
1415        FMT_ASSERT(error == 1 && divisor > 2, "");
1416      }
1417      auto dir = get_round_direction(divisor, remainder, error);
1418      if (dir != round_direction::up)
1419        return dir == round_direction::down ? digits::done : digits::error;
1420      ++buf[size - 1];
1421      for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {
1422        buf[i] = '0';
1423        ++buf[i - 1];
1424      }
1425      if (buf[0] > '9') {
1426        buf[0] = '1';
1427        if (fixed) buf[size++] = '0';
1428        else ++exp10;
1429      }
1430      return digits::done;
1431    }
1432  };
1433  namespace dragonbox {
1434  FMT_SAFEBUFFERS inline uint128_wrapper umul128(uint64_t x,
1435                                                 uint64_t y) FMT_NOEXCEPT {
1436  #if FMT_USE_INT128
1437    return static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
1438  #elif defined(_MSC_VER) && defined(_M_X64)
1439    uint128_wrapper result;
1440    result.low_ = _umul128(x, y, &result.high_);
1441    return result;
1442  #else
1443    const uint64_t mask = (uint64_t(1) << 32) - uint64_t(1);
1444    uint64_t a = x >> 32;
1445    uint64_t b = x & mask;
1446    uint64_t c = y >> 32;
1447    uint64_t d = y & mask;
1448    uint64_t ac = a * c;
1449    uint64_t bc = b * c;
1450    uint64_t ad = a * d;
1451    uint64_t bd = b * d;
1452    uint64_t intermediate = (bd >> 32) + (ad & mask) + (bc & mask);
1453    return {ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),
1454            (intermediate << 32) + (bd & mask)};
1455  #endif
1456  }
1457  FMT_SAFEBUFFERS inline uint64_t umul128_upper64(uint64_t x,
1458                                                  uint64_t y) FMT_NOEXCEPT {
1459  #if FMT_USE_INT128
1460    auto p = static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
1461    return static_cast<uint64_t>(p >> 64);
1462  #elif defined(_MSC_VER) && defined(_M_X64)
1463    return __umulh(x, y);
1464  #else
1465    return umul128(x, y).high();
1466  #endif
1467  }
1468  FMT_SAFEBUFFERS inline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y)
1469      FMT_NOEXCEPT {
1470    uint128_wrapper g0 = umul128(x, y.high());
1471    g0 += umul128_upper64(x, y.low());
1472    return g0.high();
1473  }
1474  inline uint32_t umul96_upper32(uint32_t x, uint64_t y) FMT_NOEXCEPT {
1475    return static_cast<uint32_t>(umul128_upper64(x, y));
1476  }
1477  FMT_SAFEBUFFERS inline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y)
1478      FMT_NOEXCEPT {
1479    uint64_t g01 = x * y.high();
1480    uint64_t g10 = umul128_upper64(x, y.low());
1481    return g01 + g10;
1482  }
1483  inline uint64_t umul96_lower64(uint32_t x, uint64_t y) FMT_NOEXCEPT {
1484    return x * y;
1485  }
1486  inline int floor_log10_pow2(int e) FMT_NOEXCEPT {
1487    FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
1488    const int shift = 22;
1489    return (e * static_cast<int>(data::log10_2_significand >> (64 - shift))) >>
1490           shift;
1491  }
1492  inline int floor_log2_pow10(int e) FMT_NOEXCEPT {
1493    FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
1494    const uint64_t log2_10_integer_part = 3;
1495    const uint64_t log2_10_fractional_digits = 0x5269e12f346e2bf9;
1496    const int shift_amount = 19;
1497    return (e * static_cast<int>(
1498                    (log2_10_integer_part << shift_amount) |
1499                    (log2_10_fractional_digits >> (64 - shift_amount)))) >>
1500           shift_amount;
1501  }
1502  inline int floor_log10_pow2_minus_log10_4_over_3(int e) FMT_NOEXCEPT {
1503    FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
1504    const uint64_t log10_4_over_3_fractional_digits = 0x1ffbfc2bbc780375;
1505    const int shift_amount = 22;
1506    return (e * static_cast<int>(data::log10_2_significand >>
1507                                 (64 - shift_amount)) -
1508            static_cast<int>(log10_4_over_3_fractional_digits >>
1509                             (64 - shift_amount))) >>
1510           shift_amount;
1511  }
1512  inline bool divisible_by_power_of_2(uint32_t x, int exp) FMT_NOEXCEPT {
1513    FMT_ASSERT(exp >= 1, "");
1514    FMT_ASSERT(x != 0, "");
1515  #ifdef FMT_BUILTIN_CTZ
1516    return FMT_BUILTIN_CTZ(x) >= exp;
1517  #else
1518    return exp < num_bits<uint32_t>() && x == ((x >> exp) << exp);
1519  #endif
1520  }
1521  inline bool divisible_by_power_of_2(uint64_t x, int exp) FMT_NOEXCEPT {
1522    FMT_ASSERT(exp >= 1, "");
1523    FMT_ASSERT(x != 0, "");
1524  #ifdef FMT_BUILTIN_CTZLL
1525    return FMT_BUILTIN_CTZLL(x) >= exp;
1526  #else
1527    return (exp < num_bits<uint64_t>()) && x == ((x >> exp) << exp);
1528  #endif
1529  }
1530  inline bool divisible_by_power_of_5(uint32_t x, int exp) FMT_NOEXCEPT {
1531    FMT_ASSERT(exp <= 10, "too large exponent");
1532    return x * data::divtest_table_for_pow5_32[exp].mod_inv <=
1533           data::divtest_table_for_pow5_32[exp].max_quotient;
1534  }
1535  inline bool divisible_by_power_of_5(uint64_t x, int exp) FMT_NOEXCEPT {
1536    FMT_ASSERT(exp <= 23, "too large exponent");
1537    return x * data::divtest_table_for_pow5_64[exp].mod_inv <=
1538           data::divtest_table_for_pow5_64[exp].max_quotient;
1539  }
1540  template <int N>
1541  bool check_divisibility_and_divide_by_pow5(uint32_t& n) FMT_NOEXCEPT {
1542    static constexpr struct {
1543      uint32_t magic_number;
1544      int bits_for_comparison;
1545      uint32_t threshold;
1546      int shift_amount;
1547    } infos[] = {{0xcccd, 16, 0x3333, 18}, {0xa429, 8, 0x0a, 20}};
1548    constexpr auto info = infos[N - 1];
1549    n *= info.magic_number;
1550    const uint32_t comparison_mask = (1u << info.bits_for_comparison) - 1;
1551    bool result = (n & comparison_mask) <= info.threshold;
1552    n >>= info.shift_amount;
1553    return result;
1554  }
1555  template <int N> uint32_t small_division_by_pow10(uint32_t n) FMT_NOEXCEPT {
1556    static constexpr struct {
1557      uint32_t magic_number;
1558      int shift_amount;
1559      uint32_t divisor_times_10;
1560    } infos[] = {{0xcccd, 19, 100}, {0xa3d8, 22, 1000}};
1561    constexpr auto info = infos[N - 1];
1562    FMT_ASSERT(n <= info.divisor_times_10, "n is too large");
1563    return n * info.magic_number >> info.shift_amount;
1564  }
1565  inline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) FMT_NOEXCEPT {
1566    return n / float_info<float>::big_divisor;
1567  }
1568  inline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) FMT_NOEXCEPT {
1569    return umul128_upper64(n, 0x83126e978d4fdf3c) >> 9;
1570  }
1571  template <class T> struct cache_accessor;
1572  template <> struct cache_accessor<float> {
1573    using carrier_uint = float_info<float>::carrier_uint;
1574    using cache_entry_type = uint64_t;
1575    static uint64_t get_cached_power(int k) FMT_NOEXCEPT {
1576      FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,
1577                 "k is out of range");
1578      return data::dragonbox_pow10_significands_64[k - float_info<float>::min_k];
1579    }
1580    static carrier_uint compute_mul(carrier_uint u,
1581                                    const cache_entry_type& cache) FMT_NOEXCEPT {
1582      return umul96_upper32(u, cache);
1583    }
1584    static uint32_t compute_delta(const cache_entry_type& cache,
1585                                  int beta_minus_1) FMT_NOEXCEPT {
1586      return static_cast<uint32_t>(cache >> (64 - 1 - beta_minus_1));
1587    }
1588    static bool compute_mul_parity(carrier_uint two_f,
1589                                   const cache_entry_type& cache,
1590                                   int beta_minus_1) FMT_NOEXCEPT {
1591      FMT_ASSERT(beta_minus_1 >= 1, "");
1592      FMT_ASSERT(beta_minus_1 < 64, "");
1593      return ((umul96_lower64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
1594    }
1595    static carrier_uint compute_left_endpoint_for_shorter_interval_case(
1596        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1597      return static_cast<carrier_uint>(
1598          (cache - (cache >> (float_info<float>::significand_bits + 2))) >>
1599          (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
1600    }
1601    static carrier_uint compute_right_endpoint_for_shorter_interval_case(
1602        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1603      return static_cast<carrier_uint>(
1604          (cache + (cache >> (float_info<float>::significand_bits + 1))) >>
1605          (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
1606    }
1607    static carrier_uint compute_round_up_for_shorter_interval_case(
1608        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1609      return (static_cast<carrier_uint>(
1610                  cache >>
1611                  (64 - float_info<float>::significand_bits - 2 - beta_minus_1)) +
1612              1) /
1613             2;
1614    }
1615  };
1616  template <> struct cache_accessor<double> {
1617    using carrier_uint = float_info<double>::carrier_uint;
1618    using cache_entry_type = uint128_wrapper;
1619    static uint128_wrapper get_cached_power(int k) FMT_NOEXCEPT {
1620      FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,
1621                 "k is out of range");
1622  #if FMT_USE_FULL_CACHE_DRAGONBOX
1623      return data::dragonbox_pow10_significands_128[k -
1624                                                    float_info<double>::min_k];
1625  #else
1626      static const int compression_ratio = 27;
1627      int cache_index = (k - float_info<double>::min_k) / compression_ratio;
1628      int kb = cache_index * compression_ratio + float_info<double>::min_k;
1629      int offset = k - kb;
1630      uint128_wrapper base_cache =
1631          data::dragonbox_pow10_significands_128[cache_index];
1632      if (offset == 0) return base_cache;
1633      int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;
1634      FMT_ASSERT(alpha > 0 && alpha < 64, "shifting error detected");
1635      uint64_t pow5 = data::powers_of_5_64[offset];
1636      uint128_wrapper recovered_cache = umul128(base_cache.high(), pow5);
1637      uint128_wrapper middle_low =
1638          umul128(base_cache.low() - (kb < 0 ? 1 : 0), pow5);
1639      recovered_cache += middle_low.high();
1640      uint64_t high_to_middle = recovered_cache.high() << (64 - alpha);
1641      uint64_t middle_to_low = recovered_cache.low() << (64 - alpha);
1642      recovered_cache =
1643          uint128_wrapper{(recovered_cache.low() >> alpha) | high_to_middle,
1644                          ((middle_low.low() >> alpha) | middle_to_low)};
1645      if (kb < 0) recovered_cache += 1;
1646      int error_idx = (k - float_info<double>::min_k) / 16;
1647      uint32_t error = (data::dragonbox_pow10_recovery_errors[error_idx] >>
1648                        ((k - float_info<double>::min_k) % 16) * 2) &
1649                       0x3;
1650      FMT_ASSERT(recovered_cache.low() + error >= recovered_cache.low(), "");
1651      return {recovered_cache.high(), recovered_cache.low() + error};
1652  #endif
1653    }
1654    static carrier_uint compute_mul(carrier_uint u,
1655                                    const cache_entry_type& cache) FMT_NOEXCEPT {
1656      return umul192_upper64(u, cache);
1657    }
1658    static uint32_t compute_delta(cache_entry_type const& cache,
1659                                  int beta_minus_1) FMT_NOEXCEPT {
1660      return static_cast<uint32_t>(cache.high() >> (64 - 1 - beta_minus_1));
1661    }
1662    static bool compute_mul_parity(carrier_uint two_f,
1663                                   const cache_entry_type& cache,
1664                                   int beta_minus_1) FMT_NOEXCEPT {
1665      FMT_ASSERT(beta_minus_1 >= 1, "");
1666      FMT_ASSERT(beta_minus_1 < 64, "");
1667      return ((umul192_middle64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
1668    }
1669    static carrier_uint compute_left_endpoint_for_shorter_interval_case(
1670        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1671      return (cache.high() -
1672              (cache.high() >> (float_info<double>::significand_bits + 2))) >>
1673             (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
1674    }
1675    static carrier_uint compute_right_endpoint_for_shorter_interval_case(
1676        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1677      return (cache.high() +
1678              (cache.high() >> (float_info<double>::significand_bits + 1))) >>
1679             (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
1680    }
1681    static carrier_uint compute_round_up_for_shorter_interval_case(
1682        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1683      return ((cache.high() >>
1684               (64 - float_info<double>::significand_bits - 2 - beta_minus_1)) +
1685              1) /
1686             2;
1687    }
1688  };
1689  template <class T>
1690  bool is_left_endpoint_integer_shorter_interval(int exponent) FMT_NOEXCEPT {
1691    return exponent >=
1692               float_info<
1693                   T>::case_shorter_interval_left_endpoint_lower_threshold &&
1694           exponent <=
1695               float_info<T>::case_shorter_interval_left_endpoint_upper_threshold;
1696  }
1697  template <class T>
1698  bool is_endpoint_integer(typename float_info<T>::carrier_uint two_f,
1699                           int exponent, int minus_k) FMT_NOEXCEPT {
1700    if (exponent < float_info<T>::case_fc_pm_half_lower_threshold) return false;
1701    if (exponent <= float_info<T>::case_fc_pm_half_upper_threshold) return true;
1702    if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
1703    return divisible_by_power_of_5(two_f, minus_k);
1704  }
1705  template <class T>
1706  bool is_center_integer(typename float_info<T>::carrier_uint two_f, int exponent,
1707                         int minus_k) FMT_NOEXCEPT {
1708    if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
1709    if (exponent > float_info<T>::case_fc_upper_threshold)
1710      return divisible_by_power_of_5(two_f, minus_k);
1711    if (exponent >= float_info<T>::case_fc_lower_threshold) return true;
1712    return divisible_by_power_of_2(two_f, minus_k - exponent + 1);
1713  }
<span onclick='openModal()' class='match'>1714  FMT_ALWAYS_INLINE int remove_trailing_zeros(uint32_t& n) FMT_NOEXCEPT {
1715  #ifdef FMT_BUILTIN_CTZ
1716    int t = FMT_BUILTIN_CTZ(n);
1717  #else
1718    int t = ctz(n);
1719  #endif
1720    if (t > float_info<float>::max_trailing_zeros)
</span>1721      t = float_info<float>::max_trailing_zeros;
1722    const uint32_t mod_inv1 = 0xcccccccd;
1723    const uint32_t max_quotient1 = 0x33333333;
1724    const uint32_t mod_inv2 = 0xc28f5c29;
1725    const uint32_t max_quotient2 = 0x0a3d70a3;
1726    int s = 0;
1727    for (; s < t - 1; s += 2) {
1728      if (n * mod_inv2 > max_quotient2) break;
1729      n *= mod_inv2;
1730    }
1731    if (s < t && n * mod_inv1 <= max_quotient1) {
1732      n *= mod_inv1;
1733      ++s;
1734    }
1735    n >>= s;
1736    return s;
1737  }
1738  FMT_ALWAYS_INLINE int remove_trailing_zeros(uint64_t& n) FMT_NOEXCEPT {
1739  #ifdef FMT_BUILTIN_CTZLL
1740    int t = FMT_BUILTIN_CTZLL(n);
1741  #else
1742    int t = ctzll(n);
1743  #endif
1744    if (t > float_info<double>::max_trailing_zeros)
1745      t = float_info<double>::max_trailing_zeros;
1746    const uint32_t mod_inv1 = 0xcccccccd;
1747    const uint32_t max_quotient1 = 0x33333333;
1748    const uint64_t mod_inv8 = 0xc767074b22e90e21;
1749    const uint64_t max_quotient8 = 0x00002af31dc46118;
1750    if (t >= 8) {
1751      auto quotient_candidate = n * mod_inv8;
1752      if (quotient_candidate <= max_quotient8) {
1753        auto quotient = static_cast<uint32_t>(quotient_candidate >> 8);
1754        int s = 8;
1755        for (; s < t; ++s) {
1756          if (quotient * mod_inv1 > max_quotient1) break;
1757          quotient *= mod_inv1;
1758        }
1759        quotient >>= (s - 8);
1760        n = quotient;
1761        return s;
1762      }
1763    }
1764    auto quotient = static_cast<uint32_t>(n / 100000000);
1765    auto remainder = static_cast<uint32_t>(n - 100000000 * quotient);
1766    if (t == 0 || remainder * mod_inv1 > max_quotient1) {
1767      return 0;
1768    }
1769    remainder *= mod_inv1;
1770    if (t == 1 || remainder * mod_inv1 > max_quotient1) {
1771      n = (remainder >> 1) + quotient * 10000000ull;
1772      return 1;
1773    }
1774    remainder *= mod_inv1;
1775    if (t == 2 || remainder * mod_inv1 > max_quotient1) {
1776      n = (remainder >> 2) + quotient * 1000000ull;
1777      return 2;
1778    }
1779    remainder *= mod_inv1;
1780    if (t == 3 || remainder * mod_inv1 > max_quotient1) {
1781      n = (remainder >> 3) + quotient * 100000ull;
1782      return 3;
1783    }
1784    remainder *= mod_inv1;
1785    if (t == 4 || remainder * mod_inv1 > max_quotient1) {
1786      n = (remainder >> 4) + quotient * 10000ull;
1787      return 4;
1788    }
1789    remainder *= mod_inv1;
1790    if (t == 5 || remainder * mod_inv1 > max_quotient1) {
1791      n = (remainder >> 5) + quotient * 1000ull;
1792      return 5;
1793    }
1794    remainder *= mod_inv1;
1795    if (t == 6 || remainder * mod_inv1 > max_quotient1) {
1796      n = (remainder >> 6) + quotient * 100ull;
1797      return 6;
1798    }
1799    remainder *= mod_inv1;
1800    n = (remainder >> 7) + quotient * 10ull;
1801    return 7;
1802  }
1803  template <class T>
1804  FMT_ALWAYS_INLINE FMT_SAFEBUFFERS decimal_fp<T> shorter_interval_case(
1805      int exponent) FMT_NOEXCEPT {
1806    decimal_fp<T> ret_value;
1807    const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);
1808    const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);
1809    using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
1810    const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
1811    auto xi = cache_accessor<T>::compute_left_endpoint_for_shorter_interval_case(
1812        cache, beta_minus_1);
1813    auto zi = cache_accessor<T>::compute_right_endpoint_for_shorter_interval_case(
1814        cache, beta_minus_1);
1815    if (!is_left_endpoint_integer_shorter_interval<T>(exponent)) ++xi;
1816    ret_value.significand = zi / 10;
1817    if (ret_value.significand * 10 >= xi) {
1818      ret_value.exponent = minus_k + 1;
1819      ret_value.exponent += remove_trailing_zeros(ret_value.significand);
1820      return ret_value;
1821    }
1822    ret_value.significand =
1823        cache_accessor<T>::compute_round_up_for_shorter_interval_case(
1824            cache, beta_minus_1);
1825    ret_value.exponent = minus_k;
1826    if (exponent >= float_info<T>::shorter_interval_tie_lower_threshold &&
1827        exponent <= float_info<T>::shorter_interval_tie_upper_threshold) {
1828      ret_value.significand = ret_value.significand % 2 == 0
1829                                  ? ret_value.significand
1830                                  : ret_value.significand - 1;
1831    } else if (ret_value.significand < xi) {
1832      ++ret_value.significand;
1833    }
1834    return ret_value;
1835  }
1836  template <typename T>
1837  FMT_SAFEBUFFERS decimal_fp<T> to_decimal(T x) FMT_NOEXCEPT {
1838    using carrier_uint = typename float_info<T>::carrier_uint;
1839    using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
1840    auto br = bit_cast<carrier_uint>(x);
1841    const carrier_uint significand_mask =
1842        (static_cast<carrier_uint>(1) << float_info<T>::significand_bits) - 1;
1843    carrier_uint significand = (br & significand_mask);
1844    const carrier_uint exponent_mask =
1845        ((static_cast<carrier_uint>(1) << float_info<T>::exponent_bits) - 1)
1846        << float_info<T>::significand_bits;
1847    int exponent =
1848        static_cast<int>((br & exponent_mask) >> float_info<T>::significand_bits);
1849    if (exponent != 0) {  
1850      exponent += float_info<T>::exponent_bias - float_info<T>::significand_bits;
1851      if (significand == 0) return shorter_interval_case<T>(exponent);
1852      significand |=
1853          (static_cast<carrier_uint>(1) << float_info<T>::significand_bits);
1854    } else {
1855      if (significand == 0) return {0, 0};
1856      exponent = float_info<T>::min_exponent - float_info<T>::significand_bits;
1857    }
1858    const bool include_left_endpoint = (significand % 2 == 0);
1859    const bool include_right_endpoint = include_left_endpoint;
1860    const int minus_k = floor_log10_pow2(exponent) - float_info<T>::kappa;
1861    const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
1862    const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);
1863    const uint32_t deltai = cache_accessor<T>::compute_delta(cache, beta_minus_1);
1864    const carrier_uint two_fc = significand << 1;
1865    const carrier_uint two_fr = two_fc | 1;
1866    const carrier_uint zi =
1867        cache_accessor<T>::compute_mul(two_fr << beta_minus_1, cache);
1868    decimal_fp<T> ret_value;
1869    ret_value.significand = divide_by_10_to_kappa_plus_1(zi);
1870    uint32_t r = static_cast<uint32_t>(zi - float_info<T>::big_divisor *
1871                                                ret_value.significand);
1872    if (r > deltai) {
1873      goto small_divisor_case_label;
1874    } else if (r < deltai) {
1875      if (r == 0 && !include_right_endpoint &&
1876          is_endpoint_integer<T>(two_fr, exponent, minus_k)) {
1877        --ret_value.significand;
1878        r = float_info<T>::big_divisor;
1879        goto small_divisor_case_label;
1880      }
1881    } else {
1882      const carrier_uint two_fl = two_fc - 1;
1883      if ((!include_left_endpoint ||
1884           !is_endpoint_integer<T>(two_fl, exponent, minus_k)) &&
1885          !cache_accessor<T>::compute_mul_parity(two_fl, cache, beta_minus_1)) {
1886        goto small_divisor_case_label;
1887      }
1888    }
1889    ret_value.exponent = minus_k + float_info<T>::kappa + 1;
1890    ret_value.exponent += remove_trailing_zeros(ret_value.significand);
1891    return ret_value;
1892  small_divisor_case_label:
1893    ret_value.significand *= 10;
1894    ret_value.exponent = minus_k + float_info<T>::kappa;
1895    const uint32_t mask = (1u << float_info<T>::kappa) - 1;
1896    auto dist = r - (deltai / 2) + (float_info<T>::small_divisor / 2);
1897    if ((dist & mask) == 0) {
1898      const bool approx_y_parity =
1899          ((dist ^ (float_info<T>::small_divisor / 2)) & 1) != 0;
1900      dist >>= float_info<T>::kappa;
1901      if (check_divisibility_and_divide_by_pow5<float_info<T>::kappa>(dist)) {
1902        ret_value.significand += dist;
1903        if (cache_accessor<T>::compute_mul_parity(two_fc, cache, beta_minus_1) !=
1904            approx_y_parity) {
1905          --ret_value.significand;
1906        } else {
1907          if (is_center_integer<T>(two_fc, exponent, minus_k)) {
1908            ret_value.significand = ret_value.significand % 2 == 0
1909                                        ? ret_value.significand
1910                                        : ret_value.significand - 1;
1911          }
1912        }
1913      }
1914      else {
1915        ret_value.significand += dist;
1916      }
1917    }
1918    else {
1919      ret_value.significand +=
1920          small_division_by_pow10<float_info<T>::kappa>(dist);
1921    }
1922    return ret_value;
1923  }
1924  }  
1925  template <typename Double>
1926  void fallback_format(Double d, int num_digits, bool binary32, buffer<char>& buf,
1927                       int& exp10) {
1928    bigint numerator;    
1929    bigint denominator;  
1930    bigint lower;             
1931    bigint upper_store;       
1932    bigint* upper = nullptr;  
1933    fp value;
1934    const bool is_predecessor_closer =
1935        binary32 ? value.assign(static_cast<float>(d)) : value.assign(d);
1936    int shift = is_predecessor_closer ? 2 : 1;
1937    uint64_t significand = value.f << shift;
1938    if (value.e >= 0) {
1939      numerator.assign(significand);
1940      numerator <<= value.e;
1941      lower.assign(1);
1942      lower <<= value.e;
1943      if (shift != 1) {
1944        upper_store.assign(1);
1945        upper_store <<= value.e + 1;
1946        upper = &upper_store;
1947      }
1948      denominator.assign_pow10(exp10);
1949      denominator <<= 1;
1950    } else if (exp10 < 0) {
1951      numerator.assign_pow10(-exp10);
1952      lower.assign(numerator);
1953      if (shift != 1) {
1954        upper_store.assign(numerator);
1955        upper_store <<= 1;
1956        upper = &upper_store;
1957      }
1958      numerator *= significand;
1959      denominator.assign(1);
1960      denominator <<= shift - value.e;
1961    } else {
1962      numerator.assign(significand);
1963      denominator.assign_pow10(exp10);
1964      denominator <<= shift - value.e;
1965      lower.assign(1);
1966      if (shift != 1) {
1967        upper_store.assign(1ULL << 1);
1968        upper = &upper_store;
1969      }
1970    }
1971    if (num_digits < 0) {
1972      if (!upper) upper = &lower;
1973      bool even = (value.f & 1) == 0;
1974      num_digits = 0;
1975      char* data = buf.data();
1976      for (;;) {
1977        int digit = numerator.divmod_assign(denominator);
1978        bool low = compare(numerator, lower) - even < 0;  
1979        bool high = add_compare(numerator, *upper, denominator) + even > 0;
1980        data[num_digits++] = static_cast<char>('0' + digit);
1981        if (low || high) {
1982          if (!low) {
1983            ++data[num_digits - 1];
1984          } else if (high) {
1985            int result = add_compare(numerator, numerator, denominator);
1986            if (result > 0 || (result == 0 && (digit % 2) != 0))
1987              ++data[num_digits - 1];
1988          }
1989          buf.try_resize(to_unsigned(num_digits));
1990          exp10 -= num_digits - 1;
1991          return;
1992        }
1993        numerator *= 10;
1994        lower *= 10;
1995        if (upper != &lower) *upper *= 10;
1996      }
1997    }
1998    exp10 -= num_digits - 1;
1999    if (num_digits == 0) {
2000      buf.try_resize(1);
2001      denominator *= 10;
2002      buf[0] = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
2003      return;
2004    }
2005    buf.try_resize(to_unsigned(num_digits));
2006    for (int i = 0; i < num_digits - 1; ++i) {
2007      int digit = numerator.divmod_assign(denominator);
2008      buf[i] = static_cast<char>('0' + digit);
2009      numerator *= 10;
2010    }
2011    int digit = numerator.divmod_assign(denominator);
2012    auto result = add_compare(numerator, numerator, denominator);
2013    if (result > 0 || (result == 0 && (digit % 2) != 0)) {
2014      if (digit == 9) {
2015        const auto overflow = '0' + 10;
2016        buf[num_digits - 1] = overflow;
2017        for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
2018          buf[i] = '0';
2019          ++buf[i - 1];
2020        }
2021        if (buf[0] == overflow) {
2022          buf[0] = '1';
2023          ++exp10;
2024        }
2025        return;
2026      }
2027      ++digit;
2028    }
2029    buf[num_digits - 1] = static_cast<char>('0' + digit);
2030  }
2031  template <typename T>
2032  int format_float(T value, int precision, float_specs specs, buffer<char>& buf) {
2033    static_assert(!std::is_same<T, float>::value, "");
2034    FMT_ASSERT(value >= 0, "value is negative");
2035    const bool fixed = specs.format == float_format::fixed;
2036    if (value <= 0) {  
2037      if (precision <= 0 || !fixed) {
2038        buf.push_back('0');
2039        return 0;
2040      }
2041      buf.try_resize(to_unsigned(precision));
2042      std::uninitialized_fill_n(buf.data(), precision, '0');
2043      return -precision;
2044    }
2045    if (!specs.use_grisu) return snprintf_float(value, precision, specs, buf);
2046    if (precision < 0) {
2047      if (specs.binary32) {
2048        auto dec = dragonbox::to_decimal(static_cast<float>(value));
2049        write<char>(buffer_appender<char>(buf), dec.significand);
2050        return dec.exponent;
2051      }
2052      auto dec = dragonbox::to_decimal(static_cast<double>(value));
2053      write<char>(buffer_appender<char>(buf), dec.significand);
2054      return dec.exponent;
2055    }
2056    int exp = 0;
2057    const int min_exp = -60;  
2058    int cached_exp10 = 0;     
2059    fp normalized = normalize(fp(value));
2060    const auto cached_pow = get_cached_power(
2061        min_exp - (normalized.e + fp::significand_size), cached_exp10);
2062    normalized = normalized * cached_pow;
2063    const int max_double_digits = 767;
2064    if (precision > max_double_digits) precision = max_double_digits;
2065    fixed_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
2066    if (grisu_gen_digits(normalized, 1, exp, handler) == digits::error) {
2067      exp += handler.size - cached_exp10 - 1;
2068      fallback_format(value, handler.precision, specs.binary32, buf, exp);
2069    } else {
2070      exp += handler.exp10;
2071      buf.try_resize(to_unsigned(handler.size));
2072    }
2073    if (!fixed && !specs.showpoint) {
2074      auto num_digits = buf.size();
2075      while (num_digits > 0 && buf[num_digits - 1] == '0') {
2076        --num_digits;
2077        ++exp;
2078      }
2079      buf.try_resize(num_digits);
2080    }
2081    return exp;
2082  }  
2083  template <typename T>
2084  int snprintf_float(T value, int precision, float_specs specs,
2085                     buffer<char>& buf) {
2086    FMT_ASSERT(buf.capacity() > buf.size(), "empty buffer");
2087    static_assert(!std::is_same<T, float>::value, "");
2088    if (specs.format == float_format::general ||
2089        specs.format == float_format::exp)
2090      precision = (precision >= 0 ? precision : 6) - 1;
2091    enum { max_format_size = 7 };  
2092    char format[max_format_size];
2093    char* format_ptr = format;
2094    *format_ptr++ = '%';
2095    if (specs.showpoint && specs.format == float_format::hex) *format_ptr++ = '#';
2096    if (precision >= 0) {
2097      *format_ptr++ = '.';
2098      *format_ptr++ = '*';
2099    }
2100    if (std::is_same<T, long double>()) *format_ptr++ = 'L';
2101    *format_ptr++ = specs.format != float_format::hex
2102                        ? (specs.format == float_format::fixed ? 'f' : 'e')
2103                        : (specs.upper ? 'A' : 'a');
2104    *format_ptr = '\0';
2105    auto offset = buf.size();
2106    for (;;) {
2107      auto begin = buf.data() + offset;
2108      auto capacity = buf.capacity() - offset;
2109  #ifdef FMT_FUZZ
2110      if (precision > 100000)
2111        throw std::runtime_error(
2112            "fuzz mode - avoid large allocation inside snprintf");
2113  #endif
2114      int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;
2115      int result = precision >= 0
2116                       ? snprintf_ptr(begin, capacity, format, precision, value)
2117                       : snprintf_ptr(begin, capacity, format, value);
2118      if (result < 0) {
2119        buf.try_reserve(buf.capacity() + 1);
2120        continue;
2121      }
2122      auto size = to_unsigned(result);
2123      if (size >= capacity) {
2124        buf.try_reserve(size + offset + 1);  
2125        continue;
2126      }
2127      auto is_digit = [](char c) { return c >= '0' && c <= '9'; };
2128      if (specs.format == float_format::fixed) {
2129        if (precision == 0) {
2130          buf.try_resize(size);
2131          return 0;
2132        }
2133        auto end = begin + size, p = end;
2134        do {
2135          --p;
2136        } while (is_digit(*p));
2137        int fraction_size = static_cast<int>(end - p - 1);
2138        std::memmove(p, p + 1, to_unsigned(fraction_size));
2139        buf.try_resize(size - 1);
2140        return -fraction_size;
2141      }
2142      if (specs.format == float_format::hex) {
2143        buf.try_resize(size + offset);
2144        return 0;
2145      }
2146      auto end = begin + size, exp_pos = end;
2147      do {
2148        --exp_pos;
2149      } while (*exp_pos != 'e');
2150      char sign = exp_pos[1];
2151      assert(sign == '+' || sign == '-');
2152      int exp = 0;
2153      auto p = exp_pos + 2;  
2154      do {
2155        assert(is_digit(*p));
2156        exp = exp * 10 + (*p++ - '0');
2157      } while (p != end);
2158      if (sign == '-') exp = -exp;
2159      int fraction_size = 0;
2160      if (exp_pos != begin + 1) {
2161        auto fraction_end = exp_pos - 1;
2162        while (*fraction_end == '0') --fraction_end;
2163        fraction_size = static_cast<int>(fraction_end - begin - 1);
2164        std::memmove(begin + 1, begin + 2, to_unsigned(fraction_size));
2165      }
2166      buf.try_resize(to_unsigned(fraction_size) + offset + 1);
2167      return exp - fraction_size;
2168    }
2169  }
2170  inline const char* utf8_decode(const char* buf, uint32_t* c, int* e) {
2171    static const char lengths[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
2172                                   1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
2173                                   0, 0, 2, 2, 2, 2, 3, 3, 4, 0};
2174    static const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
2175    static const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};
2176    static const int shiftc[] = {0, 18, 12, 6, 0};
2177    static const int shifte[] = {0, 6, 4, 2, 0};
2178    auto s = reinterpret_cast<const unsigned char*>(buf);
2179    int len = lengths[s[0] >> 3];
2180    const char* next = buf + len + !len;
2181    *c = uint32_t(s[0] & masks[len]) << 18;
2182    *c |= uint32_t(s[1] & 0x3f) << 12;
2183    *c |= uint32_t(s[2] & 0x3f) << 6;
2184    *c |= uint32_t(s[3] & 0x3f) << 0;
2185    *c >>= shiftc[len];
2186    *e = (*c < mins[len]) << 6;       
2187    *e |= ((*c >> 11) == 0x1b) << 7;  
2188    *e |= (*c > 0x10FFFF) << 8;       
2189    *e |= (s[1] & 0xc0) >> 2;
2190    *e |= (s[2] & 0xc0) >> 4;
2191    *e |= (s[3]) >> 6;
2192    *e ^= 0x2a;  
2193    *e >>= shifte[len];
2194    return next;
2195  }
2196  struct stringifier {
2197    template <typename T> FMT_INLINE std::string operator()(T value) const {
2198      return to_string(value);
2199    }
2200    std::string operator()(basic_format_arg<format_context>::handle h) const {
2201      memory_buffer buf;
2202      format_parse_context parse_ctx({});
2203      format_context format_ctx(buffer_appender<char>(buf), {}, {});
2204      h.format(parse_ctx, format_ctx);
2205      return to_string(buf);
2206    }
2207  };
2208  }  
2209  template <> struct formatter<detail::bigint> {
2210    format_parse_context::iterator parse(format_parse_context& ctx) {
2211      return ctx.begin();
2212    }
2213    format_context::iterator format(const detail::bigint& n,
2214                                    format_context& ctx) {
2215      auto out = ctx.out();
2216      bool first = true;
2217      for (auto i = n.bigits_.size(); i > 0; --i) {
2218        auto value = n.bigits_[i - 1u];
2219        if (first) {
2220          out = format_to(out, "{:x}", value);
2221          first = false;
2222          continue;
2223        }
2224        out = format_to(out, "{:08x}", value);
2225      }
2226      if (n.exp_ > 0)
2227        out = format_to(out, "p{}", n.exp_ * detail::bigint::bigit_bits);
2228      return out;
2229    }
2230  };
2231  FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
2232    auto transcode = [this](const char* p) {
2233      auto cp = uint32_t();
2234      auto error = 0;
2235      p = utf8_decode(p, &cp, &error);
2236      if (error != 0) FMT_THROW(std::runtime_error("invalid utf8"));
2237      if (cp <= 0xFFFF) {
2238        buffer_.push_back(static_cast<wchar_t>(cp));
2239      } else {
2240        cp -= 0x10000;
2241        buffer_.push_back(static_cast<wchar_t>(0xD800 + (cp >> 10)));
2242        buffer_.push_back(static_cast<wchar_t>(0xDC00 + (cp & 0x3FF)));
2243      }
2244      return p;
2245    };
2246    auto p = s.data();
2247    const size_t block_size = 4;  
2248    if (s.size() >= block_size) {
2249      for (auto end = p + s.size() - block_size + 1; p < end;) p = transcode(p);
2250    }
2251    if (auto num_chars_left = s.data() + s.size() - p) {
2252      char buf[2 * block_size - 1] = {};
2253      memcpy(buf, p, to_unsigned(num_chars_left));
2254      p = buf;
2255      do {
2256        p = transcode(p);
2257      } while (p - buf < num_chars_left);
2258    }
2259    buffer_.push_back(0);
2260  }
2261  FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
2262                                    string_view message) FMT_NOEXCEPT {
2263    FMT_TRY {
2264      memory_buffer buf;
2265      buf.resize(inline_buffer_size);
2266      for (;;) {
2267        char* system_message = &buf[0];
2268        int result =
2269            detail::safe_strerror(error_code, system_message, buf.size());
2270        if (result == 0) {
2271          format_to(detail::buffer_appender<char>(out), "{}: {}", message,
2272                    system_message);
2273          return;
2274        }
2275        if (result != ERANGE)
2276          break;  
2277        buf.resize(buf.size() * 2);
2278      }
2279    }
2280    FMT_CATCH(...) {}
2281    format_error_code(out, error_code, message);
2282  }
2283  FMT_FUNC void detail::error_handler::on_error(const char* message) {
2284    FMT_THROW(format_error(message));
2285  }
2286  FMT_FUNC void report_system_error(int error_code,
2287                                    fmt::string_view message) FMT_NOEXCEPT {
2288    report_error(format_system_error, error_code, message);
2289  }
2290  FMT_FUNC std::string detail::vformat(string_view format_str, format_args args) {
2291    if (format_str.size() == 2 && equal2(format_str.data(), "{}")) {
2292      auto arg = args.get(0);
2293      if (!arg) error_handler().on_error("argument not found");
2294      return visit_format_arg(stringifier(), arg);
2295    }
2296    memory_buffer buffer;
2297    detail::vformat_to(buffer, format_str, args);
2298    return to_string(buffer);
2299  }
2300  #ifdef _WIN32
2301  namespace detail {
2302  using dword = conditional_t<sizeof(long) == 4, unsigned long, unsigned>;
2303  extern "C" __declspec(dllimport) int __stdcall WriteConsoleW(  
2304      void*, const void*, dword, dword*, void*);
2305  }  
2306  #endif
2307  FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
2308    memory_buffer buffer;
2309    detail::vformat_to(buffer, format_str,
2310                       basic_format_args<buffer_context<char>>(args));
2311  #ifdef _WIN32
2312    auto fd = _fileno(f);
2313    if (_isatty(fd)) {
2314      detail::utf8_to_utf16 u16(string_view(buffer.data(), buffer.size()));
2315      auto written = detail::dword();
2316      if (!detail::WriteConsoleW(reinterpret_cast<void*>(_get_osfhandle(fd)),
2317                                 u16.c_str(), static_cast<uint32_t>(u16.size()),
2318                                 &written, nullptr)) {
2319        FMT_THROW(format_error("failed to write to console"));
2320      }
2321      return;
2322    }
2323  #endif
2324    detail::fwrite_fully(buffer.data(), 1, buffer.size(), f);
2325  }
2326  #ifdef _WIN32
2327  FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
2328                                        format_args args) {
2329    memory_buffer buffer;
2330    detail::vformat_to(buffer, format_str,
2331                       basic_format_args<buffer_context<char>>(args));
2332    fwrite_fully(buffer.data(), 1, buffer.size(), f);
2333  }
2334  #endif
2335  FMT_FUNC void vprint(string_view format_str, format_args args) {
2336    vprint(stdout, format_str, args);
2337  }
2338  FMT_END_NAMESPACE
2339  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format-inl.h</h3>
            <pre><code>1  #ifndef FMT_FORMAT_INL_H_
2  #define FMT_FORMAT_INL_H_
3  #include <cassert>
4  #include <cctype>
5  #include <climits>
6  #include <cmath>
7  #include <cstdarg>
8  #include <cstring>  
9  #include <cwchar>
10  #include <exception>
11  #ifndef FMT_STATIC_THOUSANDS_SEPARATOR
12  #  include <locale>
13  #endif
14  #ifdef _WIN32
15  #  include <io.h>  
16  #endif
17  #include "format.h"
18  inline fmt::detail::null<> strerror_r(int, char*, ...) { return {}; }
19  inline fmt::detail::null<> strerror_s(char*, size_t, ...) { return {}; }
20  FMT_BEGIN_NAMESPACE
21  namespace detail {
22  FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
23    std::fprintf(stderr, "%s:%d: assertion failed: %s", file, line, message);
24    std::terminate();
25  }
26  #ifndef _MSC_VER
27  #  define FMT_SNPRINTF snprintf
28  #else  
29  inline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {
30    va_list args;
31    va_start(args, format);
32    int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
33    va_end(args);
34    return result;
35  }
36  #  define FMT_SNPRINTF fmt_snprintf
37  #endif  
38  inline int safe_strerror(int error_code, char*& buffer,
39                           size_t buffer_size) FMT_NOEXCEPT {
40    FMT_ASSERT(buffer != nullptr && buffer_size != 0, "invalid buffer");
41    class dispatcher {
42     private:
43      int error_code_;
44      char*& buffer_;
45      size_t buffer_size_;
46      void operator=(const dispatcher&) {}
47      int handle(int result) {
48        return result == -1 ? errno : result;
49      }
50      FMT_MAYBE_UNUSED
51      int handle(char* message) {
52        if (message == buffer_ && strlen(buffer_) == buffer_size_ - 1)
53          return ERANGE;
54        buffer_ = message;
55        return 0;
56      }
57      FMT_MAYBE_UNUSED
58      int handle(detail::null<>) {
59        return fallback(strerror_s(buffer_, buffer_size_, error_code_));
60      }
61      FMT_MAYBE_UNUSED
62      int fallback(int result) {
63        return result == 0 && strlen(buffer_) == buffer_size_ - 1 ? ERANGE
64                                                                  : result;
65      }
66  #if !FMT_MSC_VER
67      int fallback(detail::null<>) {
68        errno = 0;
69        buffer_ = strerror(error_code_);
70        return errno;
71      }
72  #endif
73     public:
74      dispatcher(int err_code, char*& buf, size_t buf_size)
75          : error_code_(err_code), buffer_(buf), buffer_size_(buf_size) {}
76      int run() { return handle(strerror_r(error_code_, buffer_, buffer_size_)); }
77    };
78    return dispatcher(error_code, buffer, buffer_size).run();
79  }
80  FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
81                                  string_view message) FMT_NOEXCEPT {
82    out.try_resize(0);
83    static const char SEP[] = ": ";
84    static const char ERROR_STR[] = "error ";
85    size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
86    auto abs_value = static_cast<uint32_or_64_or_128_t<int>>(error_code);
87    if (detail::is_negative(error_code)) {
88      abs_value = 0 - abs_value;
89      ++error_code_size;
90    }
91    error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
92    auto it = buffer_appender<char>(out);
93    if (message.size() <= inline_buffer_size - error_code_size)
94      format_to(it, "{}{}", message, SEP);
95    format_to(it, "{}{}", ERROR_STR, error_code);
96    assert(out.size() <= inline_buffer_size);
97  }
98  FMT_FUNC void report_error(format_func func, int error_code,
99                             string_view message) FMT_NOEXCEPT {
100    memory_buffer full_message;
101    func(full_message, error_code, message);
102    (void)std::fwrite(full_message.data(), full_message.size(), 1, stderr);
103    std::fputc('\n', stderr);
104  }
105  inline void fwrite_fully(const void* ptr, size_t size, size_t count,
106                           FILE* stream) {
107    size_t written = std::fwrite(ptr, size, count, stream);
108    if (written < count) FMT_THROW(system_error(errno, "cannot write to file"));
109  }
110  }  
111  #if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
112  namespace detail {
113  template <typename Locale>
114  locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
115    static_assert(std::is_same<Locale, std::locale>::value, "");
116  }
117  template <typename Locale> Locale locale_ref::get() const {
118    static_assert(std::is_same<Locale, std::locale>::value, "");
119    return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();
120  }
121  template <typename Char> FMT_FUNC std::string grouping_impl(locale_ref loc) {
122    return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>()).grouping();
123  }
124  template <typename Char> FMT_FUNC Char thousands_sep_impl(locale_ref loc) {
125    return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
126        .thousands_sep();
127  }
128  template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref loc) {
129    return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
130        .decimal_point();
131  }
132  }  
133  #else
134  template <typename Char>
135  FMT_FUNC std::string detail::grouping_impl(locale_ref) {
136    return "\03";
137  }
138  template <typename Char> FMT_FUNC Char detail::thousands_sep_impl(locale_ref) {
139    return FMT_STATIC_THOUSANDS_SEPARATOR;
140  }
141  template <typename Char> FMT_FUNC Char detail::decimal_point_impl(locale_ref) {
142    return '.';
143  }
144  #endif
145  FMT_API FMT_FUNC format_error::~format_error() FMT_NOEXCEPT = default;
146  FMT_API FMT_FUNC system_error::~system_error() FMT_NOEXCEPT = default;
147  FMT_FUNC void system_error::init(int err_code, string_view format_str,
148                                   format_args args) {
149    error_code_ = err_code;
150    memory_buffer buffer;
151    format_system_error(buffer, err_code, vformat(format_str, args));
152    std::runtime_error& base = *this;
153    base = std::runtime_error(to_string(buffer));
154  }
155  namespace detail {
156  template <> FMT_FUNC int count_digits<4>(detail::fallback_uintptr n) {
157    int i = static_cast<int>(sizeof(void*)) - 1;
158    while (i > 0 && n.value[i] == 0) --i;
159    auto char_digits = std::numeric_limits<unsigned char>::digits / 4;
160    return i >= 0 ? i * char_digits + count_digits<4, unsigned>(n.value[i]) : 1;
161  }
162  template <typename T>
163  const typename basic_data<T>::digit_pair basic_data<T>::digits[] = {
164      {'0', '0'}, {'0', '1'}, {'0', '2'}, {'0', '3'}, {'0', '4'}, {'0', '5'},
165      {'0', '6'}, {'0', '7'}, {'0', '8'}, {'0', '9'}, {'1', '0'}, {'1', '1'},
166      {'1', '2'}, {'1', '3'}, {'1', '4'}, {'1', '5'}, {'1', '6'}, {'1', '7'},
167      {'1', '8'}, {'1', '9'}, {'2', '0'}, {'2', '1'}, {'2', '2'}, {'2', '3'},
168      {'2', '4'}, {'2', '5'}, {'2', '6'}, {'2', '7'}, {'2', '8'}, {'2', '9'},
169      {'3', '0'}, {'3', '1'}, {'3', '2'}, {'3', '3'}, {'3', '4'}, {'3', '5'},
170      {'3', '6'}, {'3', '7'}, {'3', '8'}, {'3', '9'}, {'4', '0'}, {'4', '1'},
171      {'4', '2'}, {'4', '3'}, {'4', '4'}, {'4', '5'}, {'4', '6'}, {'4', '7'},
172      {'4', '8'}, {'4', '9'}, {'5', '0'}, {'5', '1'}, {'5', '2'}, {'5', '3'},
173      {'5', '4'}, {'5', '5'}, {'5', '6'}, {'5', '7'}, {'5', '8'}, {'5', '9'},
174      {'6', '0'}, {'6', '1'}, {'6', '2'}, {'6', '3'}, {'6', '4'}, {'6', '5'},
175      {'6', '6'}, {'6', '7'}, {'6', '8'}, {'6', '9'}, {'7', '0'}, {'7', '1'},
176      {'7', '2'}, {'7', '3'}, {'7', '4'}, {'7', '5'}, {'7', '6'}, {'7', '7'},
177      {'7', '8'}, {'7', '9'}, {'8', '0'}, {'8', '1'}, {'8', '2'}, {'8', '3'},
178      {'8', '4'}, {'8', '5'}, {'8', '6'}, {'8', '7'}, {'8', '8'}, {'8', '9'},
179      {'9', '0'}, {'9', '1'}, {'9', '2'}, {'9', '3'}, {'9', '4'}, {'9', '5'},
180      {'9', '6'}, {'9', '7'}, {'9', '8'}, {'9', '9'}};
181  template <typename T>
182  const char basic_data<T>::hex_digits[] = "0123456789abcdef";
183  #define FMT_POWERS_OF_10(factor)                                             \
184    factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
185        (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
186        (factor)*1000000000
187  template <typename T>
188  const uint64_t basic_data<T>::powers_of_10_64[] = {
189      1, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
190      10000000000000000000ULL};
191  template <typename T>
192  const uint32_t basic_data<T>::zero_or_powers_of_10_32[] = {0, 0,
193                                                             FMT_POWERS_OF_10(1)};
194  template <typename T>
195  const uint64_t basic_data<T>::zero_or_powers_of_10_64[] = {
196      0, 0, FMT_POWERS_OF_10(1), FMT_POWERS_OF_10(1000000000ULL),
197      10000000000000000000ULL};
198  template <typename T>
199  const uint64_t basic_data<T>::grisu_pow10_significands[] = {
200      0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,
201      0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,
202      0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,
203      0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,
204      0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
205      0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,
206      0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,
207      0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,
208      0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,
209      0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
210      0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,
211      0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,
212      0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,
213      0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,
214      0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
215      0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,
216      0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,
217      0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,
218      0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,
219      0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
220      0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,
221      0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,
222      0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,
223      0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,
224      0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
225      0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,
226      0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,
227      0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,
228      0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
229  };
230  template <typename T>
231  const int16_t basic_data<T>::grisu_pow10_exponents[] = {
232      -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,
233      -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,
234      -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,
235      -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,
236      -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,
237      242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,
238      534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,
239      827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};
240  template <typename T>
241  const divtest_table_entry<uint32_t> basic_data<T>::divtest_table_for_pow5_32[] =
242      {{0x00000001, 0xffffffff}, {0xcccccccd, 0x33333333},
243       {0xc28f5c29, 0x0a3d70a3}, {0x26e978d5, 0x020c49ba},
244       {0x3afb7e91, 0x0068db8b}, {0x0bcbe61d, 0x0014f8b5},
245       {0x68c26139, 0x000431bd}, {0xae8d46a5, 0x0000d6bf},
246       {0x22e90e21, 0x00002af3}, {0x3a2e9c6d, 0x00000897},
247       {0x3ed61f49, 0x000001b7}};
248  template <typename T>
249  const divtest_table_entry<uint64_t> basic_data<T>::divtest_table_for_pow5_64[] =
250      {{0x0000000000000001, 0xffffffffffffffff},
251       {0xcccccccccccccccd, 0x3333333333333333},
252       {0x8f5c28f5c28f5c29, 0x0a3d70a3d70a3d70},
253       {0x1cac083126e978d5, 0x020c49ba5e353f7c},
254       {0xd288ce703afb7e91, 0x0068db8bac710cb2},
255       {0x5d4e8fb00bcbe61d, 0x0014f8b588e368f0},
256       {0x790fb65668c26139, 0x000431bde82d7b63},
257       {0xe5032477ae8d46a5, 0x0000d6bf94d5e57a},
258       {0xc767074b22e90e21, 0x00002af31dc46118},
259       {0x8e47ce423a2e9c6d, 0x0000089705f4136b},
260       {0x4fa7f60d3ed61f49, 0x000001b7cdfd9d7b},
261       {0x0fee64690c913975, 0x00000057f5ff85e5},
262       {0x3662e0e1cf503eb1, 0x000000119799812d},
263       {0xa47a2cf9f6433fbd, 0x0000000384b84d09},
264       {0x54186f653140a659, 0x00000000b424dc35},
265       {0x7738164770402145, 0x0000000024075f3d},
266       {0xe4a4d1417cd9a041, 0x000000000734aca5},
267       {0xc75429d9e5c5200d, 0x000000000170ef54},
268       {0xc1773b91fac10669, 0x000000000049c977},
269       {0x26b172506559ce15, 0x00000000000ec1e4},
270       {0xd489e3a9addec2d1, 0x000000000002f394},
271       {0x90e860bb892c8d5d, 0x000000000000971d},
272       {0x502e79bf1b6f4f79, 0x0000000000001e39},
273       {0xdcd618596be30fe5, 0x000000000000060b}};
274  template <typename T>
275  const uint64_t basic_data<T>::dragonbox_pow10_significands_64[] = {
276      0x81ceb32c4b43fcf5, 0xa2425ff75e14fc32, 0xcad2f7f5359a3b3f,
277      0xfd87b5f28300ca0e, 0x9e74d1b791e07e49, 0xc612062576589ddb,
278      0xf79687aed3eec552, 0x9abe14cd44753b53, 0xc16d9a0095928a28,
279      0xf1c90080baf72cb2, 0x971da05074da7bef, 0xbce5086492111aeb,
280      0xec1e4a7db69561a6, 0x9392ee8e921d5d08, 0xb877aa3236a4b44a,
281      0xe69594bec44de15c, 0x901d7cf73ab0acda, 0xb424dc35095cd810,
282      0xe12e13424bb40e14, 0x8cbccc096f5088cc, 0xafebff0bcb24aaff,
283      0xdbe6fecebdedd5bf, 0x89705f4136b4a598, 0xabcc77118461cefd,
284      0xd6bf94d5e57a42bd, 0x8637bd05af6c69b6, 0xa7c5ac471b478424,
285      0xd1b71758e219652c, 0x83126e978d4fdf3c, 0xa3d70a3d70a3d70b,
286      0xcccccccccccccccd, 0x8000000000000000, 0xa000000000000000,
287      0xc800000000000000, 0xfa00000000000000, 0x9c40000000000000,
288      0xc350000000000000, 0xf424000000000000, 0x9896800000000000,
289      0xbebc200000000000, 0xee6b280000000000, 0x9502f90000000000,
290      0xba43b74000000000, 0xe8d4a51000000000, 0x9184e72a00000000,
291      0xb5e620f480000000, 0xe35fa931a0000000, 0x8e1bc9bf04000000,
292      0xb1a2bc2ec5000000, 0xde0b6b3a76400000, 0x8ac7230489e80000,
293      0xad78ebc5ac620000, 0xd8d726b7177a8000, 0x878678326eac9000,
294      0xa968163f0a57b400, 0xd3c21bcecceda100, 0x84595161401484a0,
295      0xa56fa5b99019a5c8, 0xcecb8f27f4200f3a, 0x813f3978f8940984,
296      0xa18f07d736b90be5, 0xc9f2c9cd04674ede, 0xfc6f7c4045812296,
297      0x9dc5ada82b70b59d, 0xc5371912364ce305, 0xf684df56c3e01bc6,
298      0x9a130b963a6c115c, 0xc097ce7bc90715b3, 0xf0bdc21abb48db20,
299      0x96769950b50d88f4, 0xbc143fa4e250eb31, 0xeb194f8e1ae525fd,
300      0x92efd1b8d0cf37be, 0xb7abc627050305ad, 0xe596b7b0c643c719,
301      0x8f7e32ce7bea5c6f, 0xb35dbf821ae4f38b, 0xe0352f62a19e306e};
302  template <typename T>
303  const uint128_wrapper basic_data<T>::dragonbox_pow10_significands_128[] = {
304  #if FMT_USE_FULL_CACHE_DRAGONBOX
305      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
306      {0x9faacf3df73609b1, 0x77b191618c54e9ad},
307      {0xc795830d75038c1d, 0xd59df5b9ef6a2418},
308      {0xf97ae3d0d2446f25, 0x4b0573286b44ad1e},
309      {0x9becce62836ac577, 0x4ee367f9430aec33},
310      {0xc2e801fb244576d5, 0x229c41f793cda740},
311      {0xf3a20279ed56d48a, 0x6b43527578c11110},
312      {0x9845418c345644d6, 0x830a13896b78aaaa},
313      {0xbe5691ef416bd60c, 0x23cc986bc656d554},
314      {0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa9},
315      {0x94b3a202eb1c3f39, 0x7bf7d71432f3d6aa},
316      {0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc54},
317      {0xe858ad248f5c22c9, 0xd1b3400f8f9cff69},
318      {0x91376c36d99995be, 0x23100809b9c21fa2},
319      {0xb58547448ffffb2d, 0xabd40a0c2832a78b},
320      {0xe2e69915b3fff9f9, 0x16c90c8f323f516d},
321      {0x8dd01fad907ffc3b, 0xae3da7d97f6792e4},
322      {0xb1442798f49ffb4a, 0x99cd11cfdf41779d},
323      {0xdd95317f31c7fa1d, 0x40405643d711d584},
324      {0x8a7d3eef7f1cfc52, 0x482835ea666b2573},
325      {0xad1c8eab5ee43b66, 0xda3243650005eed0},
326      {0xd863b256369d4a40, 0x90bed43e40076a83},
327      {0x873e4f75e2224e68, 0x5a7744a6e804a292},
328      {0xa90de3535aaae202, 0x711515d0a205cb37},
329      {0xd3515c2831559a83, 0x0d5a5b44ca873e04},
330      {0x8412d9991ed58091, 0xe858790afe9486c3},
331      {0xa5178fff668ae0b6, 0x626e974dbe39a873},
332      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
333      {0x80fa687f881c7f8e, 0x7ce66634bc9d0b9a},
334      {0xa139029f6a239f72, 0x1c1fffc1ebc44e81},
335      {0xc987434744ac874e, 0xa327ffb266b56221},
336      {0xfbe9141915d7a922, 0x4bf1ff9f0062baa9},
337      {0x9d71ac8fada6c9b5, 0x6f773fc3603db4aa},
338      {0xc4ce17b399107c22, 0xcb550fb4384d21d4},
339      {0xf6019da07f549b2b, 0x7e2a53a146606a49},
340      {0x99c102844f94e0fb, 0x2eda7444cbfc426e},
341      {0xc0314325637a1939, 0xfa911155fefb5309},
342      {0xf03d93eebc589f88, 0x793555ab7eba27cb},
343      {0x96267c7535b763b5, 0x4bc1558b2f3458df},
344      {0xbbb01b9283253ca2, 0x9eb1aaedfb016f17},
345      {0xea9c227723ee8bcb, 0x465e15a979c1cadd},
346      {0x92a1958a7675175f, 0x0bfacd89ec191eca},
347      {0xb749faed14125d36, 0xcef980ec671f667c},
348      {0xe51c79a85916f484, 0x82b7e12780e7401b},
349      {0x8f31cc0937ae58d2, 0xd1b2ecb8b0908811},
350      {0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa16},
351      {0xdfbdcece67006ac9, 0x67a791e093e1d49b},
352      {0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e1},
353      {0xaecc49914078536d, 0x58fae9f773886e19},
354      {0xda7f5bf590966848, 0xaf39a475506a899f},
355      {0x888f99797a5e012d, 0x6d8406c952429604},
356      {0xaab37fd7d8f58178, 0xc8e5087ba6d33b84},
357      {0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a65},
358      {0x855c3be0a17fcd26, 0x5cf2eea09a550680},
359      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
360      {0xd0601d8efc57b08b, 0xf13b94daf124da27},
361      {0x823c12795db6ce57, 0x76c53d08d6b70859},
362      {0xa2cb1717b52481ed, 0x54768c4b0c64ca6f},
363      {0xcb7ddcdda26da268, 0xa9942f5dcf7dfd0a},
364      {0xfe5d54150b090b02, 0xd3f93b35435d7c4d},
365      {0x9efa548d26e5a6e1, 0xc47bc5014a1a6db0},
366      {0xc6b8e9b0709f109a, 0x359ab6419ca1091c},
367      {0xf867241c8cc6d4c0, 0xc30163d203c94b63},
368      {0x9b407691d7fc44f8, 0x79e0de63425dcf1e},
369      {0xc21094364dfb5636, 0x985915fc12f542e5},
370      {0xf294b943e17a2bc4, 0x3e6f5b7b17b2939e},
371      {0x979cf3ca6cec5b5a, 0xa705992ceecf9c43},
372      {0xbd8430bd08277231, 0x50c6ff782a838354},
373      {0xece53cec4a314ebd, 0xa4f8bf5635246429},
374      {0x940f4613ae5ed136, 0x871b7795e136be9a},
375      {0xb913179899f68584, 0x28e2557b59846e40},
376      {0xe757dd7ec07426e5, 0x331aeada2fe589d0},
377      {0x9096ea6f3848984f, 0x3ff0d2c85def7622},
378      {0xb4bca50b065abe63, 0x0fed077a756b53aa},
379      {0xe1ebce4dc7f16dfb, 0xd3e8495912c62895},
380      {0x8d3360f09cf6e4bd, 0x64712dd7abbbd95d},
381      {0xb080392cc4349dec, 0xbd8d794d96aacfb4},
382      {0xdca04777f541c567, 0xecf0d7a0fc5583a1},
383      {0x89e42caaf9491b60, 0xf41686c49db57245},
384      {0xac5d37d5b79b6239, 0x311c2875c522ced6},
385      {0xd77485cb25823ac7, 0x7d633293366b828c},
386      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
387      {0xa8530886b54dbdeb, 0xd9f57f830283fdfd},
388      {0xd267caa862a12d66, 0xd072df63c324fd7c},
389      {0x8380dea93da4bc60, 0x4247cb9e59f71e6e},
390      {0xa46116538d0deb78, 0x52d9be85f074e609},
391      {0xcd795be870516656, 0x67902e276c921f8c},
392      {0x806bd9714632dff6, 0x00ba1cd8a3db53b7},
393      {0xa086cfcd97bf97f3, 0x80e8a40eccd228a5},
394      {0xc8a883c0fdaf7df0, 0x6122cd128006b2ce},
395      {0xfad2a4b13d1b5d6c, 0x796b805720085f82},
396      {0x9cc3a6eec6311a63, 0xcbe3303674053bb1},
397      {0xc3f490aa77bd60fc, 0xbedbfc4411068a9d},
398      {0xf4f1b4d515acb93b, 0xee92fb5515482d45},
399      {0x991711052d8bf3c5, 0x751bdd152d4d1c4b},
400      {0xbf5cd54678eef0b6, 0xd262d45a78a0635e},
401      {0xef340a98172aace4, 0x86fb897116c87c35},
402      {0x9580869f0e7aac0e, 0xd45d35e6ae3d4da1},
403      {0xbae0a846d2195712, 0x8974836059cca10a},
404      {0xe998d258869facd7, 0x2bd1a438703fc94c},
405      {0x91ff83775423cc06, 0x7b6306a34627ddd0},
406      {0xb67f6455292cbf08, 0x1a3bc84c17b1d543},
407      {0xe41f3d6a7377eeca, 0x20caba5f1d9e4a94},
408      {0x8e938662882af53e, 0x547eb47b7282ee9d},
409      {0xb23867fb2a35b28d, 0xe99e619a4f23aa44},
410      {0xdec681f9f4c31f31, 0x6405fa00e2ec94d5},
411      {0x8b3c113c38f9f37e, 0xde83bc408dd3dd05},
412      {0xae0b158b4738705e, 0x9624ab50b148d446},
413      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
414      {0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d7},
415      {0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4d},
416      {0xd47487cc8470652b, 0x7647c32000696720},
417      {0x84c8d4dfd2c63f3b, 0x29ecd9f40041e074},
418      {0xa5fb0a17c777cf09, 0xf468107100525891},
419      {0xcf79cc9db955c2cc, 0x7182148d4066eeb5},
420      {0x81ac1fe293d599bf, 0xc6f14cd848405531},
421      {0xa21727db38cb002f, 0xb8ada00e5a506a7d},
422      {0xca9cf1d206fdc03b, 0xa6d90811f0e4851d},
423      {0xfd442e4688bd304a, 0x908f4a166d1da664},
424      {0x9e4a9cec15763e2e, 0x9a598e4e043287ff},
425      {0xc5dd44271ad3cdba, 0x40eff1e1853f29fe},
426      {0xf7549530e188c128, 0xd12bee59e68ef47d},
427      {0x9a94dd3e8cf578b9, 0x82bb74f8301958cf},
428      {0xc13a148e3032d6e7, 0xe36a52363c1faf02},
429      {0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac2},
430      {0x96f5600f15a7b7e5, 0x29ab103a5ef8c0ba},
431      {0xbcb2b812db11a5de, 0x7415d448f6b6f0e8},
432      {0xebdf661791d60f56, 0x111b495b3464ad22},
433      {0x936b9fcebb25c995, 0xcab10dd900beec35},
434      {0xb84687c269ef3bfb, 0x3d5d514f40eea743},
435      {0xe65829b3046b0afa, 0x0cb4a5a3112a5113},
436      {0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ac},
437      {0xb3f4e093db73a093, 0x59ed216765690f57},
438      {0xe0f218b8d25088b8, 0x306869c13ec3532d},
439      {0x8c974f7383725573, 0x1e414218c73a13fc},
440      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
441      {0xdbac6c247d62a583, 0xdf45f746b74abf3a},
442      {0x894bc396ce5da772, 0x6b8bba8c328eb784},
443      {0xab9eb47c81f5114f, 0x066ea92f3f326565},
444      {0xd686619ba27255a2, 0xc80a537b0efefebe},
445      {0x8613fd0145877585, 0xbd06742ce95f5f37},
446      {0xa798fc4196e952e7, 0x2c48113823b73705},
447      {0xd17f3b51fca3a7a0, 0xf75a15862ca504c6},
448      {0x82ef85133de648c4, 0x9a984d73dbe722fc},
449      {0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebbb},
450      {0xcc963fee10b7d1b3, 0x318df905079926a9},
451      {0xffbbcfe994e5c61f, 0xfdf17746497f7053},
452      {0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa634},
453      {0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc1},
454      {0xf9bd690a1b68637b, 0x3dfdce7aa3c673b1},
455      {0x9c1661a651213e2d, 0x06bea10ca65c084f},
456      {0xc31bfa0fe5698db8, 0x486e494fcff30a63},
457      {0xf3e2f893dec3f126, 0x5a89dba3c3efccfb},
458      {0x986ddb5c6b3a76b7, 0xf89629465a75e01d},
459      {0xbe89523386091465, 0xf6bbb397f1135824},
460      {0xee2ba6c0678b597f, 0x746aa07ded582e2d},
461      {0x94db483840b717ef, 0xa8c2a44eb4571cdd},
462      {0xba121a4650e4ddeb, 0x92f34d62616ce414},
463      {0xe896a0d7e51e1566, 0x77b020baf9c81d18},
464      {0x915e2486ef32cd60, 0x0ace1474dc1d122f},
465      {0xb5b5ada8aaff80b8, 0x0d819992132456bb},
466      {0xe3231912d5bf60e6, 0x10e1fff697ed6c6a},
467      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
468      {0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb3},
469      {0xddd0467c64bce4a0, 0xac7cb3f6d05ddbdf},
470      {0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96c},
471      {0xad4ab7112eb3929d, 0x86c16c98d2c953c7},
472      {0xd89d64d57a607744, 0xe871c7bf077ba8b8},
473      {0x87625f056c7c4a8b, 0x11471cd764ad4973},
474      {0xa93af6c6c79b5d2d, 0xd598e40d3dd89bd0},
475      {0xd389b47879823479, 0x4aff1d108d4ec2c4},
476      {0x843610cb4bf160cb, 0xcedf722a585139bb},
477      {0xa54394fe1eedb8fe, 0xc2974eb4ee658829},
478      {0xce947a3da6a9273e, 0x733d226229feea33},
479      {0x811ccc668829b887, 0x0806357d5a3f5260},
480      {0xa163ff802a3426a8, 0xca07c2dcb0cf26f8},
481      {0xc9bcff6034c13052, 0xfc89b393dd02f0b6},
482      {0xfc2c3f3841f17c67, 0xbbac2078d443ace3},
483      {0x9d9ba7832936edc0, 0xd54b944b84aa4c0e},
484      {0xc5029163f384a931, 0x0a9e795e65d4df12},
485      {0xf64335bcf065d37d, 0x4d4617b5ff4a16d6},
486      {0x99ea0196163fa42e, 0x504bced1bf8e4e46},
487      {0xc06481fb9bcf8d39, 0xe45ec2862f71e1d7},
488      {0xf07da27a82c37088, 0x5d767327bb4e5a4d},
489      {0x964e858c91ba2655, 0x3a6a07f8d510f870},
490      {0xbbe226efb628afea, 0x890489f70a55368c},
491      {0xeadab0aba3b2dbe5, 0x2b45ac74ccea842f},
492      {0x92c8ae6b464fc96f, 0x3b0b8bc90012929e},
493      {0xb77ada0617e3bbcb, 0x09ce6ebb40173745},
494      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
495      {0x8f57fa54c2a9eab6, 0x9fa946824a12232e},
496      {0xb32df8e9f3546564, 0x47939822dc96abfa},
497      {0xdff9772470297ebd, 0x59787e2b93bc56f8},
498      {0x8bfbea76c619ef36, 0x57eb4edb3c55b65b},
499      {0xaefae51477a06b03, 0xede622920b6b23f2},
500      {0xdab99e59958885c4, 0xe95fab368e45ecee},
501      {0x88b402f7fd75539b, 0x11dbcb0218ebb415},
502      {0xaae103b5fcd2a881, 0xd652bdc29f26a11a},
503      {0xd59944a37c0752a2, 0x4be76d3346f04960},
504      {0x857fcae62d8493a5, 0x6f70a4400c562ddc},
505      {0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb953},
506      {0xd097ad07a71f26b2, 0x7e2000a41346a7a8},
507      {0x825ecc24c873782f, 0x8ed400668c0c28c9},
508      {0xa2f67f2dfa90563b, 0x728900802f0f32fb},
509      {0xcbb41ef979346bca, 0x4f2b40a03ad2ffba},
510      {0xfea126b7d78186bc, 0xe2f610c84987bfa9},
511      {0x9f24b832e6b0f436, 0x0dd9ca7d2df4d7ca},
512      {0xc6ede63fa05d3143, 0x91503d1c79720dbc},
513      {0xf8a95fcf88747d94, 0x75a44c6397ce912b},
514      {0x9b69dbe1b548ce7c, 0xc986afbe3ee11abb},
515      {0xc24452da229b021b, 0xfbe85badce996169},
516      {0xf2d56790ab41c2a2, 0xfae27299423fb9c4},
517      {0x97c560ba6b0919a5, 0xdccd879fc967d41b},
518      {0xbdb6b8e905cb600f, 0x5400e987bbc1c921},
519      {0xed246723473e3813, 0x290123e9aab23b69},
520      {0x9436c0760c86e30b, 0xf9a0b6720aaf6522},
521      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
522      {0xe7958cb87392c2c2, 0xb60b1d1230b20e05},
523      {0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c3},
524      {0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af4},
525      {0xe2280b6c20dd5232, 0x25c6da63c38de1b1},
526      {0x8d590723948a535f, 0x579c487e5a38ad0f},
527      {0xb0af48ec79ace837, 0x2d835a9df0c6d852},
528      {0xdcdb1b2798182244, 0xf8e431456cf88e66},
529      {0x8a08f0f8bf0f156b, 0x1b8e9ecb641b5900},
530      {0xac8b2d36eed2dac5, 0xe272467e3d222f40},
531      {0xd7adf884aa879177, 0x5b0ed81dcc6abb10},
532      {0x86ccbb52ea94baea, 0x98e947129fc2b4ea},
533      {0xa87fea27a539e9a5, 0x3f2398d747b36225},
534      {0xd29fe4b18e88640e, 0x8eec7f0d19a03aae},
535      {0x83a3eeeef9153e89, 0x1953cf68300424ad},
536      {0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd8},
537      {0xcdb02555653131b6, 0x3792f412cb06794e},
538      {0x808e17555f3ebf11, 0xe2bbd88bbee40bd1},
539      {0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec5},
540      {0xc8de047564d20a8b, 0xf245825a5a445276},
541      {0xfb158592be068d2e, 0xeed6e2f0f0d56713},
542      {0x9ced737bb6c4183d, 0x55464dd69685606c},
543      {0xc428d05aa4751e4c, 0xaa97e14c3c26b887},
544      {0xf53304714d9265df, 0xd53dd99f4b3066a9},
545      {0x993fe2c6d07b7fab, 0xe546a8038efe402a},
546      {0xbf8fdb78849a5f96, 0xde98520472bdd034},
547      {0xef73d256a5c0f77c, 0x963e66858f6d4441},
548      {0x95a8637627989aad, 0xdde7001379a44aa9},
549      {0xbb127c53b17ec159, 0x5560c018580d5d53},
550      {0xe9d71b689dde71af, 0xaab8f01e6e10b4a7},
551      {0x9226712162ab070d, 0xcab3961304ca70e9},
552      {0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d23},
553      {0xe45c10c42a2b3b05, 0x8cb89a7db77c506b},
554      {0x8eb98a7a9a5b04e3, 0x77f3608e92adb243},
555      {0xb267ed1940f1c61c, 0x55f038b237591ed4},
556      {0xdf01e85f912e37a3, 0x6b6c46dec52f6689},
557      {0x8b61313bbabce2c6, 0x2323ac4b3b3da016},
558      {0xae397d8aa96c1b77, 0xabec975e0a0d081b},
559      {0xd9c7dced53c72255, 0x96e7bd358c904a22},
560      {0x881cea14545c7575, 0x7e50d64177da2e55},
561      {0xaa242499697392d2, 0xdde50bd1d5d0b9ea},
562      {0xd4ad2dbfc3d07787, 0x955e4ec64b44e865},
563      {0x84ec3c97da624ab4, 0xbd5af13bef0b113f},
564      {0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58f},
565      {0xcfb11ead453994ba, 0x67de18eda5814af3},
566      {0x81ceb32c4b43fcf4, 0x80eacf948770ced8},
567      {0xa2425ff75e14fc31, 0xa1258379a94d028e},
568      {0xcad2f7f5359a3b3e, 0x096ee45813a04331},
569      {0xfd87b5f28300ca0d, 0x8bca9d6e188853fd},
570      {0x9e74d1b791e07e48, 0x775ea264cf55347e},
571      {0xc612062576589dda, 0x95364afe032a819e},
572      {0xf79687aed3eec551, 0x3a83ddbd83f52205},
573      {0x9abe14cd44753b52, 0xc4926a9672793543},
574      {0xc16d9a0095928a27, 0x75b7053c0f178294},
575      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
576      {0x971da05074da7bee, 0xd3f6fc16ebca5e04},
577      {0xbce5086492111aea, 0x88f4bb1ca6bcf585},
578      {0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6},
579      {0x9392ee8e921d5d07, 0x3aff322e62439fd0},
580      {0xb877aa3236a4b449, 0x09befeb9fad487c3},
581      {0xe69594bec44de15b, 0x4c2ebe687989a9b4},
582      {0x901d7cf73ab0acd9, 0x0f9d37014bf60a11},
583      {0xb424dc35095cd80f, 0x538484c19ef38c95},
584      {0xe12e13424bb40e13, 0x2865a5f206b06fba},
585      {0x8cbccc096f5088cb, 0xf93f87b7442e45d4},
586      {0xafebff0bcb24aafe, 0xf78f69a51539d749},
587      {0xdbe6fecebdedd5be, 0xb573440e5a884d1c},
588      {0x89705f4136b4a597, 0x31680a88f8953031},
589      {0xabcc77118461cefc, 0xfdc20d2b36ba7c3e},
590      {0xd6bf94d5e57a42bc, 0x3d32907604691b4d},
591      {0x8637bd05af6c69b5, 0xa63f9a49c2c1b110},
592      {0xa7c5ac471b478423, 0x0fcf80dc33721d54},
593      {0xd1b71758e219652b, 0xd3c36113404ea4a9},
594      {0x83126e978d4fdf3b, 0x645a1cac083126ea},
595      {0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4},
596      {0xcccccccccccccccc, 0xcccccccccccccccd},
597      {0x8000000000000000, 0x0000000000000000},
598      {0xa000000000000000, 0x0000000000000000},
599      {0xc800000000000000, 0x0000000000000000},
600      {0xfa00000000000000, 0x0000000000000000},
601      {0x9c40000000000000, 0x0000000000000000},
602      {0xc350000000000000, 0x0000000000000000},
603      {0xf424000000000000, 0x0000000000000000},
604      {0x9896800000000000, 0x0000000000000000},
605      {0xbebc200000000000, 0x0000000000000000},
606      {0xee6b280000000000, 0x0000000000000000},
607      {0x9502f90000000000, 0x0000000000000000},
608      {0xba43b74000000000, 0x0000000000000000},
609      {0xe8d4a51000000000, 0x0000000000000000},
610      {0x9184e72a00000000, 0x0000000000000000},
611      {0xb5e620f480000000, 0x0000000000000000},
612      {0xe35fa931a0000000, 0x0000000000000000},
613      {0x8e1bc9bf04000000, 0x0000000000000000},
614      {0xb1a2bc2ec5000000, 0x0000000000000000},
615      {0xde0b6b3a76400000, 0x0000000000000000},
616      {0x8ac7230489e80000, 0x0000000000000000},
617      {0xad78ebc5ac620000, 0x0000000000000000},
618      {0xd8d726b7177a8000, 0x0000000000000000},
619      {0x878678326eac9000, 0x0000000000000000},
620      {0xa968163f0a57b400, 0x0000000000000000},
621      {0xd3c21bcecceda100, 0x0000000000000000},
622      {0x84595161401484a0, 0x0000000000000000},
623      {0xa56fa5b99019a5c8, 0x0000000000000000},
624      {0xcecb8f27f4200f3a, 0x0000000000000000},
625      {0x813f3978f8940984, 0x4000000000000000},
626      {0xa18f07d736b90be5, 0x5000000000000000},
627      {0xc9f2c9cd04674ede, 0xa400000000000000},
628      {0xfc6f7c4045812296, 0x4d00000000000000},
629      {0x9dc5ada82b70b59d, 0xf020000000000000},
630      {0xc5371912364ce305, 0x6c28000000000000},
631      {0xf684df56c3e01bc6, 0xc732000000000000},
632      {0x9a130b963a6c115c, 0x3c7f400000000000},
633      {0xc097ce7bc90715b3, 0x4b9f100000000000},
634      {0xf0bdc21abb48db20, 0x1e86d40000000000},
635      {0x96769950b50d88f4, 0x1314448000000000},
636      {0xbc143fa4e250eb31, 0x17d955a000000000},
637      {0xeb194f8e1ae525fd, 0x5dcfab0800000000},
638      {0x92efd1b8d0cf37be, 0x5aa1cae500000000},
639      {0xb7abc627050305ad, 0xf14a3d9e40000000},
640      {0xe596b7b0c643c719, 0x6d9ccd05d0000000},
641      {0x8f7e32ce7bea5c6f, 0xe4820023a2000000},
642      {0xb35dbf821ae4f38b, 0xdda2802c8a800000},
643      {0xe0352f62a19e306e, 0xd50b2037ad200000},
644      {0x8c213d9da502de45, 0x4526f422cc340000},
645      {0xaf298d050e4395d6, 0x9670b12b7f410000},
646      {0xdaf3f04651d47b4c, 0x3c0cdd765f114000},
647      {0x88d8762bf324cd0f, 0xa5880a69fb6ac800},
648      {0xab0e93b6efee0053, 0x8eea0d047a457a00},
649      {0xd5d238a4abe98068, 0x72a4904598d6d880},
650      {0x85a36366eb71f041, 0x47a6da2b7f864750},
651      {0xa70c3c40a64e6c51, 0x999090b65f67d924},
652      {0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d},
653      {0x82818f1281ed449f, 0xbff8f10e7a8921a4},
654      {0xa321f2d7226895c7, 0xaff72d52192b6a0d},
655      {0xcbea6f8ceb02bb39, 0x9bf4f8a69f764490},
656      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
657      {0x9f4f2726179a2245, 0x01d762422c946590},
658      {0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef5},
659      {0xf8ebad2b84e0d58b, 0xd2e0898765a7deb2},
660      {0x9b934c3b330c8577, 0x63cc55f49f88eb2f},
661      {0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fb},
662      {0xf316271c7fc3908a, 0x8bef464e3945ef7a},
663      {0x97edd871cfda3a56, 0x97758bf0e3cbb5ac},
664      {0xbde94e8e43d0c8ec, 0x3d52eeed1cbea317},
665      {0xed63a231d4c4fb27, 0x4ca7aaa863ee4bdd},
666      {0x945e455f24fb1cf8, 0x8fe8caa93e74ef6a},
667      {0xb975d6b6ee39e436, 0xb3e2fd538e122b44},
668      {0xe7d34c64a9c85d44, 0x60dbbca87196b616},
669      {0x90e40fbeea1d3a4a, 0xbc8955e946fe31cd},
670      {0xb51d13aea4a488dd, 0x6babab6398bdbe41},
671      {0xe264589a4dcdab14, 0xc696963c7eed2dd1},
672      {0x8d7eb76070a08aec, 0xfc1e1de5cf543ca2},
673      {0xb0de65388cc8ada8, 0x3b25a55f43294bcb},
674      {0xdd15fe86affad912, 0x49ef0eb713f39ebe},
675      {0x8a2dbf142dfcc7ab, 0x6e3569326c784337},
676      {0xacb92ed9397bf996, 0x49c2c37f07965404},
677      {0xd7e77a8f87daf7fb, 0xdc33745ec97be906},
678      {0x86f0ac99b4e8dafd, 0x69a028bb3ded71a3},
679      {0xa8acd7c0222311bc, 0xc40832ea0d68ce0c},
680      {0xd2d80db02aabd62b, 0xf50a3fa490c30190},
681      {0x83c7088e1aab65db, 0x792667c6da79e0fa},
682      {0xa4b8cab1a1563f52, 0x577001b891185938},
683      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
684      {0x80b05e5ac60b6178, 0x544f8158315b05b4},
685      {0xa0dc75f1778e39d6, 0x696361ae3db1c721},
686      {0xc913936dd571c84c, 0x03bc3a19cd1e38e9},
687      {0xfb5878494ace3a5f, 0x04ab48a04065c723},
688      {0x9d174b2dcec0e47b, 0x62eb0d64283f9c76},
689      {0xc45d1df942711d9a, 0x3ba5d0bd324f8394},
690      {0xf5746577930d6500, 0xca8f44ec7ee36479},
691      {0x9968bf6abbe85f20, 0x7e998b13cf4e1ecb},
692      {0xbfc2ef456ae276e8, 0x9e3fedd8c321a67e},
693      {0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101e},
694      {0x95d04aee3b80ece5, 0xbba1f1d158724a12},
695      {0xbb445da9ca61281f, 0x2a8a6e45ae8edc97},
696      {0xea1575143cf97226, 0xf52d09d71a3293bd},
697      {0x924d692ca61be758, 0x593c2626705f9c56},
698      {0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836c},
699      {0xe498f455c38b997a, 0x0b6dfb9c0f956447},
700      {0x8edf98b59a373fec, 0x4724bd4189bd5eac},
701      {0xb2977ee300c50fe7, 0x58edec91ec2cb657},
702      {0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ed},
703      {0x8b865b215899f46c, 0xbd79e0d20082ee74},
704      {0xae67f1e9aec07187, 0xecd8590680a3aa11},
705      {0xda01ee641a708de9, 0xe80e6f4820cc9495},
706      {0x884134fe908658b2, 0x3109058d147fdcdd},
707      {0xaa51823e34a7eede, 0xbd4b46f0599fd415},
708      {0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91a},
709      {0x850fadc09923329e, 0x03e2cf6bc604ddb0},
710      {0xa6539930bf6bff45, 0x84db8346b786151c},
711      {0xcfe87f7cef46ff16, 0xe612641865679a63},
712      {0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07e},
713      {0xa26da3999aef7749, 0xe3be5e330f38f09d},
714      {0xcb090c8001ab551c, 0x5cadf5bfd3072cc5},
715      {0xfdcb4fa002162a63, 0x73d9732fc7c8f7f6},
716      {0x9e9f11c4014dda7e, 0x2867e7fddcdd9afa},
717      {0xc646d63501a1511d, 0xb281e1fd541501b8},
718      {0xf7d88bc24209a565, 0x1f225a7ca91a4226},
719      {0x9ae757596946075f, 0x3375788de9b06958},
720      {0xc1a12d2fc3978937, 0x0052d6b1641c83ae},
721      {0xf209787bb47d6b84, 0xc0678c5dbd23a49a},
722      {0x9745eb4d50ce6332, 0xf840b7ba963646e0},
723      {0xbd176620a501fbff, 0xb650e5a93bc3d898},
724      {0xec5d3fa8ce427aff, 0xa3e51f138ab4cebe},
725      {0x93ba47c980e98cdf, 0xc66f336c36b10137},
726      {0xb8a8d9bbe123f017, 0xb80b0047445d4184},
727      {0xe6d3102ad96cec1d, 0xa60dc059157491e5},
728      {0x9043ea1ac7e41392, 0x87c89837ad68db2f},
729      {0xb454e4a179dd1877, 0x29babe4598c311fb},
730      {0xe16a1dc9d8545e94, 0xf4296dd6fef3d67a},
731      {0x8ce2529e2734bb1d, 0x1899e4a65f58660c},
732      {0xb01ae745b101e9e4, 0x5ec05dcff72e7f8f},
733      {0xdc21a1171d42645d, 0x76707543f4fa1f73},
734      {0x899504ae72497eba, 0x6a06494a791c53a8},
735      {0xabfa45da0edbde69, 0x0487db9d17636892},
736      {0xd6f8d7509292d603, 0x45a9d2845d3c42b6},
737      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
738      {0xa7f26836f282b732, 0x8e6cac7768d7141e},
739      {0xd1ef0244af2364ff, 0x3207d795430cd926},
740      {0x8335616aed761f1f, 0x7f44e6bd49e807b8},
741      {0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a6},
742      {0xcd036837130890a1, 0x36dba887c37a8c0f},
743      {0x802221226be55a64, 0xc2494954da2c9789},
744      {0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6c},
745      {0xc83553c5c8965d3d, 0x6f92829494e5acc7},
746      {0xfa42a8b73abbf48c, 0xcb772339ba1f17f9},
747      {0x9c69a97284b578d7, 0xff2a760414536efb},
748      {0xc38413cf25e2d70d, 0xfef5138519684aba},
749      {0xf46518c2ef5b8cd1, 0x7eb258665fc25d69},
750      {0x98bf2f79d5993802, 0xef2f773ffbd97a61},
751      {0xbeeefb584aff8603, 0xaafb550ffacfd8fa},
752      {0xeeaaba2e5dbf6784, 0x95ba2a53f983cf38},
753      {0x952ab45cfa97a0b2, 0xdd945a747bf26183},
754      {0xba756174393d88df, 0x94f971119aeef9e4},
755      {0xe912b9d1478ceb17, 0x7a37cd5601aab85d},
756      {0x91abb422ccb812ee, 0xac62e055c10ab33a},
757      {0xb616a12b7fe617aa, 0x577b986b314d6009},
758      {0xe39c49765fdf9d94, 0xed5a7e85fda0b80b},
759      {0x8e41ade9fbebc27d, 0x14588f13be847307},
760      {0xb1d219647ae6b31c, 0x596eb2d8ae258fc8},
761      {0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bb},
762      {0x8aec23d680043bee, 0x25de7bb9480d5854},
763      {0xada72ccc20054ae9, 0xaf561aa79a10ae6a},
764      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
765      {0x87aa9aff79042286, 0x90fb44d2f05d0842},
766      {0xa99541bf57452b28, 0x353a1607ac744a53},
767      {0xd3fa922f2d1675f2, 0x42889b8997915ce8},
768      {0x847c9b5d7c2e09b7, 0x69956135febada11},
769      {0xa59bc234db398c25, 0x43fab9837e699095},
770      {0xcf02b2c21207ef2e, 0x94f967e45e03f4bb},
771      {0x8161afb94b44f57d, 0x1d1be0eebac278f5},
772      {0xa1ba1ba79e1632dc, 0x6462d92a69731732},
773      {0xca28a291859bbf93, 0x7d7b8f7503cfdcfe},
774      {0xfcb2cb35e702af78, 0x5cda735244c3d43e},
775      {0x9defbf01b061adab, 0x3a0888136afa64a7},
776      {0xc56baec21c7a1916, 0x088aaa1845b8fdd0},
777      {0xf6c69a72a3989f5b, 0x8aad549e57273d45},
778      {0x9a3c2087a63f6399, 0x36ac54e2f678864b},
779      {0xc0cb28a98fcf3c7f, 0x84576a1bb416a7dd},
780      {0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d5},
781      {0x969eb7c47859e743, 0x9f644ae5a4b1b325},
782      {0xbc4665b596706114, 0x873d5d9f0dde1fee},
783      {0xeb57ff22fc0c7959, 0xa90cb506d155a7ea},
784      {0x9316ff75dd87cbd8, 0x09a7f12442d588f2},
785      {0xb7dcbf5354e9bece, 0x0c11ed6d538aeb2f},
786      {0xe5d3ef282a242e81, 0x8f1668c8a86da5fa},
787      {0x8fa475791a569d10, 0xf96e017d694487bc},
788      {0xb38d92d760ec4455, 0x37c981dcc395a9ac},
789      {0xe070f78d3927556a, 0x85bbe253f47b1417},
790      {0x8c469ab843b89562, 0x93956d7478ccec8e},
791      {0xaf58416654a6babb, 0x387ac8d1970027b2},
792      {0xdb2e51bfe9d0696a, 0x06997b05fcc0319e},
793      {0x88fcf317f22241e2, 0x441fece3bdf81f03},
794      {0xab3c2fddeeaad25a, 0xd527e81cad7626c3},
795      {0xd60b3bd56a5586f1, 0x8a71e223d8d3b074},
796      {0x85c7056562757456, 0xf6872d5667844e49},
797      {0xa738c6bebb12d16c, 0xb428f8ac016561db},
798      {0xd106f86e69d785c7, 0xe13336d701beba52},
799      {0x82a45b450226b39c, 0xecc0024661173473},
800      {0xa34d721642b06084, 0x27f002d7f95d0190},
801      {0xcc20ce9bd35c78a5, 0x31ec038df7b441f4},
802      {0xff290242c83396ce, 0x7e67047175a15271},
803      {0x9f79a169bd203e41, 0x0f0062c6e984d386},
804      {0xc75809c42c684dd1, 0x52c07b78a3e60868},
805      {0xf92e0c3537826145, 0xa7709a56ccdf8a82},
806      {0x9bbcc7a142b17ccb, 0x88a66076400bb691},
807      {0xc2abf989935ddbfe, 0x6acff893d00ea435},
808      {0xf356f7ebf83552fe, 0x0583f6b8c4124d43},
809      {0x98165af37b2153de, 0xc3727a337a8b704a},
810      {0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5c},
811      {0xeda2ee1c7064130c, 0x1162def06f79df73},
812      {0x9485d4d1c63e8be7, 0x8addcb5645ac2ba8},
813      {0xb9a74a0637ce2ee1, 0x6d953e2bd7173692},
814      {0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0437},
815      {0x910ab1d4db9914a0, 0x1d9c9892400a22a2},
816      {0xb54d5e4a127f59c8, 0x2503beb6d00cab4b},
817      {0xe2a0b5dc971f303a, 0x2e44ae64840fd61d},
818      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
819      {0xb10d8e1456105dad, 0x7425a83e872c5f47},
820      {0xdd50f1996b947518, 0xd12f124e28f77719},
821      {0x8a5296ffe33cc92f, 0x82bd6b70d99aaa6f},
822      {0xace73cbfdc0bfb7b, 0x636cc64d1001550b},
823      {0xd8210befd30efa5a, 0x3c47f7e05401aa4e},
824      {0x8714a775e3e95c78, 0x65acfaec34810a71},
825      {0xa8d9d1535ce3b396, 0x7f1839a741a14d0d},
826      {0xd31045a8341ca07c, 0x1ede48111209a050},
827      {0x83ea2b892091e44d, 0x934aed0aab460432},
828      {0xa4e4b66b68b65d60, 0xf81da84d5617853f},
829      {0xce1de40642e3f4b9, 0x36251260ab9d668e},
830      {0x80d2ae83e9ce78f3, 0xc1d72b7c6b426019},
831      {0xa1075a24e4421730, 0xb24cf65b8612f81f},
832      {0xc94930ae1d529cfc, 0xdee033f26797b627},
833      {0xfb9b7cd9a4a7443c, 0x169840ef017da3b1},
834      {0x9d412e0806e88aa5, 0x8e1f289560ee864e},
835      {0xc491798a08a2ad4e, 0xf1a6f2bab92a27e2},
836      {0xf5b5d7ec8acb58a2, 0xae10af696774b1db},
837      {0x9991a6f3d6bf1765, 0xacca6da1e0a8ef29},
838      {0xbff610b0cc6edd3f, 0x17fd090a58d32af3},
839      {0xeff394dcff8a948e, 0xddfc4b4cef07f5b0},
840      {0x95f83d0a1fb69cd9, 0x4abdaf101564f98e},
841      {0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f1},
842      {0xea53df5fd18d5513, 0x84c86189216dc5ed},
843      {0x92746b9be2f8552c, 0x32fd3cf5b4e49bb4},
844      {0xb7118682dbb66a77, 0x3fbc8c33221dc2a1},
845      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
846      {0x8f05b1163ba6832d, 0x29cb4d87f2a7400e},
847      {0xb2c71d5bca9023f8, 0x743e20e9ef511012},
848      {0xdf78e4b2bd342cf6, 0x914da9246b255416},
849      {0x8bab8eefb6409c1a, 0x1ad089b6c2f7548e},
850      {0xae9672aba3d0c320, 0xa184ac2473b529b1},
851      {0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741e},
852      {0x8865899617fb1871, 0x7e2fa67c7a658892},
853      {0xaa7eebfb9df9de8d, 0xddbb901b98feeab7},
854      {0xd51ea6fa85785631, 0x552a74227f3ea565},
855      {0x8533285c936b35de, 0xd53a88958f87275f},
856      {0xa67ff273b8460356, 0x8a892abaf368f137},
857      {0xd01fef10a657842c, 0x2d2b7569b0432d85},
858      {0x8213f56a67f6b29b, 0x9c3b29620e29fc73},
859      {0xa298f2c501f45f42, 0x8349f3ba91b47b8f},
860      {0xcb3f2f7642717713, 0x241c70a936219a73},
861      {0xfe0efb53d30dd4d7, 0xed238cd383aa0110},
862      {0x9ec95d1463e8a506, 0xf4363804324a40aa},
863      {0xc67bb4597ce2ce48, 0xb143c6053edcd0d5},
864      {0xf81aa16fdc1b81da, 0xdd94b7868e94050a},
865      {0x9b10a4e5e9913128, 0xca7cf2b4191c8326},
866      {0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f0},
867      {0xf24a01a73cf2dccf, 0xbc633b39673c8cec},
868      {0x976e41088617ca01, 0xd5be0503e085d813},
869      {0xbd49d14aa79dbc82, 0x4b2d8644d8a74e18},
870      {0xec9c459d51852ba2, 0xddf8e7d60ed1219e},
871      {0x93e1ab8252f33b45, 0xcabb90e5c942b503},
872      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
873      {0xe7109bfba19c0c9d, 0x0cc512670a783ad4},
874      {0x906a617d450187e2, 0x27fb2b80668b24c5},
875      {0xb484f9dc9641e9da, 0xb1f9f660802dedf6},
876      {0xe1a63853bbd26451, 0x5e7873f8a0396973},
877      {0x8d07e33455637eb2, 0xdb0b487b6423e1e8},
878      {0xb049dc016abc5e5f, 0x91ce1a9a3d2cda62},
879      {0xdc5c5301c56b75f7, 0x7641a140cc7810fb},
880      {0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9d},
881      {0xac2820d9623bf429, 0x546345fa9fbdcd44},
882      {0xd732290fbacaf133, 0xa97c177947ad4095},
883      {0x867f59a9d4bed6c0, 0x49ed8eabcccc485d},
884      {0xa81f301449ee8c70, 0x5c68f256bfff5a74},
885      {0xd226fc195c6a2f8c, 0x73832eec6fff3111},
886      {0x83585d8fd9c25db7, 0xc831fd53c5ff7eab},
887      {0xa42e74f3d032f525, 0xba3e7ca8b77f5e55},
888      {0xcd3a1230c43fb26f, 0x28ce1bd2e55f35eb},
889      {0x80444b5e7aa7cf85, 0x7980d163cf5b81b3},
890      {0xa0555e361951c366, 0xd7e105bcc332621f},
891      {0xc86ab5c39fa63440, 0x8dd9472bf3fefaa7},
892      {0xfa856334878fc150, 0xb14f98f6f0feb951},
893      {0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d3},
894      {0xc3b8358109e84f07, 0x0a862f80ec4700c8},
895      {0xf4a642e14c6262c8, 0xcd27bb612758c0fa},
896      {0x98e7e9cccfbd7dbd, 0x8038d51cb897789c},
897      {0xbf21e44003acdd2c, 0xe0470a63e6bd56c3},
898      {0xeeea5d5004981478, 0x1858ccfce06cac74},
899      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8},
900      {0xbaa718e68396cffd, 0xd30560258f54e6ba},
901      {0xe950df20247c83fd, 0x47c6b82ef32a2069},
902      {0x91d28b7416cdd27e, 0x4cdc331d57fa5441},
903      {0xb6472e511c81471d, 0xe0133fe4adf8e952},
904      {0xe3d8f9e563a198e5, 0x58180fddd97723a6},
905      {0x8e679c2f5e44ff8f, 0x570f09eaa7ea7648},
906      {0xb201833b35d63f73, 0x2cd2cc6551e513da},
907      {0xde81e40a034bcf4f, 0xf8077f7ea65e58d1},
908      {0x8b112e86420f6191, 0xfb04afaf27faf782},
909      {0xadd57a27d29339f6, 0x79c5db9af1f9b563},
910      {0xd94ad8b1c7380874, 0x18375281ae7822bc},
911      {0x87cec76f1c830548, 0x8f2293910d0b15b5},
912      {0xa9c2794ae3a3c69a, 0xb2eb3875504ddb22},
913      {0xd433179d9c8cb841, 0x5fa60692a46151eb},
914      {0x849feec281d7f328, 0xdbc7c41ba6bcd333},
915      {0xa5c7ea73224deff3, 0x12b9b522906c0800},
916      {0xcf39e50feae16bef, 0xd768226b34870a00},
917      {0x81842f29f2cce375, 0xe6a1158300d46640},
918      {0xa1e53af46f801c53, 0x60495ae3c1097fd0},
919      {0xca5e89b18b602368, 0x385bb19cb14bdfc4},
920      {0xfcf62c1dee382c42, 0x46729e03dd9ed7b5},
921      {0x9e19db92b4e31ba9, 0x6c07a2c26a8346d1},
922      {0xc5a05277621be293, 0xc7098b7305241885},
923      {0xf70867153aa2db38, 0xb8cbee4fc66d1ea7}
924  #else
925      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
926      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
927      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
928      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
929      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
930      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
931      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
932      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
933      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
934      {0x95a8637627989aad, 0xdde7001379a44aa9},
935      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
936      {0xc350000000000000, 0x0000000000000000},
937      {0x9dc5ada82b70b59d, 0xf020000000000000},
938      {0xfee50b7025c36a08, 0x02f236d04753d5b4},
939      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},
940      {0xa6539930bf6bff45, 0x84db8346b786151c},
941      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},
942      {0xd910f7ff28069da4, 0x1b2ba1518094da04},
943      {0xaf58416654a6babb, 0x387ac8d1970027b2},
944      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},
945      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},
946      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},
947      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8}
948  #endif
949  };
950  #if !FMT_USE_FULL_CACHE_DRAGONBOX
951  template <typename T>
952  const uint64_t basic_data<T>::powers_of_5_64[] = {
953      0x0000000000000001, 0x0000000000000005, 0x0000000000000019,
954      0x000000000000007d, 0x0000000000000271, 0x0000000000000c35,
955      0x0000000000003d09, 0x000000000001312d, 0x000000000005f5e1,
956      0x00000000001dcd65, 0x00000000009502f9, 0x0000000002e90edd,
957      0x000000000e8d4a51, 0x0000000048c27395, 0x000000016bcc41e9,
958      0x000000071afd498d, 0x0000002386f26fc1, 0x000000b1a2bc2ec5,
959      0x000003782dace9d9, 0x00001158e460913d, 0x000056bc75e2d631,
960      0x0001b1ae4d6e2ef5, 0x000878678326eac9, 0x002a5a058fc295ed,
961      0x00d3c21bcecceda1, 0x0422ca8b0a00a425, 0x14adf4b7320334b9};
962  template <typename T>
963  const uint32_t basic_data<T>::dragonbox_pow10_recovery_errors[] = {
964      0x50001400, 0x54044100, 0x54014555, 0x55954415, 0x54115555, 0x00000001,
965      0x50000000, 0x00104000, 0x54010004, 0x05004001, 0x55555544, 0x41545555,
966      0x54040551, 0x15445545, 0x51555514, 0x10000015, 0x00101100, 0x01100015,
967      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04450514, 0x45414110,
968      0x55555145, 0x50544050, 0x15040155, 0x11054140, 0x50111514, 0x11451454,
969      0x00400541, 0x00000000, 0x55555450, 0x10056551, 0x10054011, 0x55551014,
970      0x69514555, 0x05151109, 0x00155555};
971  #endif
972  template <typename T>
973  const char basic_data<T>::foreground_color[] = "\x1b[38;2;";
974  template <typename T>
975  const char basic_data<T>::background_color[] = "\x1b[48;2;";
976  template <typename T> const char basic_data<T>::reset_color[] = "\x1b[0m";
977  template <typename T> const wchar_t basic_data<T>::wreset_color[] = L"\x1b[0m";
978  template <typename T> const char basic_data<T>::signs[] = {0, '-', '+', ' '};
979  template <typename T>
980  const char basic_data<T>::left_padding_shifts[] = {31, 31, 0, 1, 0};
981  template <typename T>
982  const char basic_data<T>::right_padding_shifts[] = {0, 31, 0, 1, 0};
983  template <typename T> struct bits {
984    static FMT_CONSTEXPR_DECL const int value =
985        static_cast<int>(sizeof(T) * std::numeric_limits<unsigned char>::digits);
986  };
987  class fp;
988  template <int SHIFT = 0> fp normalize(fp value);
989  struct boundaries {
990    uint64_t lower;
991    uint64_t upper;
992  };
993  class fp {
994   private:
995    using significand_type = uint64_t;
996    template <typename Float>
997    using is_supported_float = bool_constant<sizeof(Float) == sizeof(uint64_t) ||
998                                             sizeof(Float) == sizeof(uint32_t)>;
999   public:
1000    significand_type f;
1001    int e;
1002    static FMT_CONSTEXPR_DECL const int double_significand_size =
1003        std::numeric_limits<double>::digits - 1;
1004    static FMT_CONSTEXPR_DECL const uint64_t implicit_bit =
1005        1ULL << double_significand_size;
1006    static FMT_CONSTEXPR_DECL const int significand_size =
1007        bits<significand_type>::value;
1008    fp() : f(0), e(0) {}
1009    fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}
1010    template <typename Double> explicit fp(Double d) { assign(d); }
1011    template <typename Float, FMT_ENABLE_IF(is_supported_float<Float>::value)>
1012    bool assign(Float d) {
1013      using limits = std::numeric_limits<Float>;
1014      const int float_significand_size = limits::digits - 1;
1015      const int exponent_size =
1016          bits<Float>::value - float_significand_size - 1;  
1017      const uint64_t float_implicit_bit = 1ULL << float_significand_size;
1018      const uint64_t significand_mask = float_implicit_bit - 1;
1019      const uint64_t exponent_mask = (~0ULL >> 1) & ~significand_mask;
1020      const int exponent_bias = (1 << exponent_size) - limits::max_exponent - 1;
1021      constexpr bool is_double = sizeof(Float) == sizeof(uint64_t);
1022      auto u = bit_cast<conditional_t<is_double, uint64_t, uint32_t>>(d);
1023      f = u & significand_mask;
1024      int biased_e =
1025          static_cast<int>((u & exponent_mask) >> float_significand_size);
1026      bool is_predecessor_closer = f == 0 && biased_e > 1;
1027      if (biased_e != 0)
1028        f += float_implicit_bit;
1029      else
1030        biased_e = 1;  
1031      e = biased_e - exponent_bias - float_significand_size;
1032      return is_predecessor_closer;
1033    }
1034    template <typename Float, FMT_ENABLE_IF(!is_supported_float<Float>::value)>
1035    bool assign(Float) {
1036      *this = fp();
1037      return false;
1038    }
1039  };
1040  template <int SHIFT> fp normalize(fp value) {
1041    const auto shifted_implicit_bit = fp::implicit_bit << SHIFT;
1042    while ((value.f & shifted_implicit_bit) == 0) {
1043      value.f <<= 1;
1044      --value.e;
1045    }
1046    const auto offset =
1047        fp::significand_size - fp::double_significand_size - SHIFT - 1;
1048    value.f <<= offset;
1049    value.e -= offset;
1050    return value;
1051  }
1052  inline bool operator==(fp x, fp y) { return x.f == y.f && x.e == y.e; }
1053  inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
1054  #if FMT_USE_INT128
1055    auto product = static_cast<__uint128_t>(lhs) * rhs;
1056    auto f = static_cast<uint64_t>(product >> 64);
1057    return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
1058  #else
1059    uint64_t mask = (1ULL << 32) - 1;
1060    uint64_t a = lhs >> 32, b = lhs & mask;
1061    uint64_t c = rhs >> 32, d = rhs & mask;
1062    uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
1063    uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
1064    return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
1065  #endif
1066  }
1067  inline fp operator*(fp x, fp y) { return {multiply(x.f, y.f), x.e + y.e + 64}; }
1068  inline fp get_cached_power(int min_exponent, int& pow10_exponent) {
1069    const int shift = 32;
1070    const auto significand = static_cast<int64_t>(data::log10_2_significand);
1071    int index = static_cast<int>(
1072        ((min_exponent + fp::significand_size - 1) * (significand >> shift) +
1073         ((int64_t(1) << shift) - 1))  
1074        >> 32                          
1075    );
1076    const int first_dec_exp = -348;
1077    const int dec_exp_step = 8;
1078    index = (index - first_dec_exp - 1) / dec_exp_step + 1;
1079    pow10_exponent = first_dec_exp + index * dec_exp_step;
1080    return {data::grisu_pow10_significands[index],
1081            data::grisu_pow10_exponents[index]};
1082  }
1083  struct accumulator {
1084    uint64_t lower;
1085    uint64_t upper;
1086    accumulator() : lower(0), upper(0) {}
1087    explicit operator uint32_t() const { return static_cast<uint32_t>(lower); }
1088    void operator+=(uint64_t n) {
1089      lower += n;
1090      if (lower < n) ++upper;
1091    }
1092    void operator>>=(int shift) {
1093      assert(shift == 32);
1094      (void)shift;
1095      lower = (upper << 32) | (lower >> 32);
1096      upper >>= 32;
1097    }
1098  };
1099  class bigint {
1100   private:
1101    using bigit = uint32_t;
1102    using double_bigit = uint64_t;
1103    enum { bigits_capacity = 32 };
1104    basic_memory_buffer<bigit, bigits_capacity> bigits_;
1105    int exp_;
1106    bigit operator[](int index) const { return bigits_[to_unsigned(index)]; }
1107    bigit& operator[](int index) { return bigits_[to_unsigned(index)]; }
1108    static FMT_CONSTEXPR_DECL const int bigit_bits = bits<bigit>::value;
1109    friend struct formatter<bigint>;
1110    void subtract_bigits(int index, bigit other, bigit& borrow) {
1111      auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
1112      (*this)[index] = static_cast<bigit>(result);
1113      borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
1114    }
1115    void remove_leading_zeros() {
1116      int num_bigits = static_cast<int>(bigits_.size()) - 1;
1117      while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
1118      bigits_.resize(to_unsigned(num_bigits + 1));
1119    }
1120    void subtract_aligned(const bigint& other) {
1121      FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
1122      FMT_ASSERT(compare(*this, other) >= 0, "");
1123      bigit borrow = 0;
1124      int i = other.exp_ - exp_;
1125      for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
1126        subtract_bigits(i, other.bigits_[j], borrow);
1127      while (borrow > 0) subtract_bigits(i, 0, borrow);
1128      remove_leading_zeros();
1129    }
1130    void multiply(uint32_t value) {
1131      const double_bigit wide_value = value;
1132      bigit carry = 0;
1133      for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
1134        double_bigit result = bigits_[i] * wide_value + carry;
1135        bigits_[i] = static_cast<bigit>(result);
1136        carry = static_cast<bigit>(result >> bigit_bits);
1137      }
1138      if (carry != 0) bigits_.push_back(carry);
1139    }
1140    void multiply(uint64_t value) {
1141      const bigit mask = ~bigit(0);
1142      const double_bigit lower = value & mask;
1143      const double_bigit upper = value >> bigit_bits;
1144      double_bigit carry = 0;
1145      for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
1146        double_bigit result = bigits_[i] * lower + (carry & mask);
1147        carry =
1148            bigits_[i] * upper + (result >> bigit_bits) + (carry >> bigit_bits);
1149        bigits_[i] = static_cast<bigit>(result);
1150      }
1151      while (carry != 0) {
1152        bigits_.push_back(carry & mask);
1153        carry >>= bigit_bits;
1154      }
1155    }
1156   public:
1157    bigint() : exp_(0) {}
1158    explicit bigint(uint64_t n) { assign(n); }
1159    ~bigint() { assert(bigits_.capacity() <= bigits_capacity); }
1160    bigint(const bigint&) = delete;
1161    void operator=(const bigint&) = delete;
1162    void assign(const bigint& other) {
1163      auto size = other.bigits_.size();
1164      bigits_.resize(size);
1165      auto data = other.bigits_.data();
1166      std::copy(data, data + size, make_checked(bigits_.data(), size));
1167      exp_ = other.exp_;
1168    }
1169    void assign(uint64_t n) {
1170      size_t num_bigits = 0;
1171      do {
1172        bigits_[num_bigits++] = n & ~bigit(0);
1173        n >>= bigit_bits;
1174      } while (n != 0);
1175      bigits_.resize(num_bigits);
1176      exp_ = 0;
1177    }
1178    int num_bigits() const { return static_cast<int>(bigits_.size()) + exp_; }
1179    FMT_NOINLINE bigint& operator<<=(int shift) {
1180      assert(shift >= 0);
1181      exp_ += shift / bigit_bits;
1182      shift %= bigit_bits;
1183      if (shift == 0) return *this;
1184      bigit carry = 0;
1185      for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
1186        bigit c = bigits_[i] >> (bigit_bits - shift);
1187        bigits_[i] = (bigits_[i] << shift) + carry;
1188        carry = c;
1189      }
1190      if (carry != 0) bigits_.push_back(carry);
1191      return *this;
1192    }
1193    template <typename Int> bigint& operator*=(Int value) {
1194      FMT_ASSERT(value > 0, "");
1195      multiply(uint32_or_64_or_128_t<Int>(value));
1196      return *this;
1197    }
1198    friend int compare(const bigint& lhs, const bigint& rhs) {
1199      int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
1200      if (num_lhs_bigits != num_rhs_bigits)
1201        return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
1202      int i = static_cast<int>(lhs.bigits_.size()) - 1;
1203      int j = static_cast<int>(rhs.bigits_.size()) - 1;
1204      int end = i - j;
1205      if (end < 0) end = 0;
1206      for (; i >= end; --i, --j) {
1207        bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
1208        if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
1209      }
1210      if (i != j) return i > j ? 1 : -1;
1211      return 0;
1212    }
1213    friend int add_compare(const bigint& lhs1, const bigint& lhs2,
1214                           const bigint& rhs) {
1215      int max_lhs_bigits = (std::max)(lhs1.num_bigits(), lhs2.num_bigits());
1216      int num_rhs_bigits = rhs.num_bigits();
1217      if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
1218      if (max_lhs_bigits > num_rhs_bigits) return 1;
1219      auto get_bigit = [](const bigint& n, int i) -> bigit {
1220        return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
1221      };
1222      double_bigit borrow = 0;
1223      int min_exp = (std::min)((std::min)(lhs1.exp_, lhs2.exp_), rhs.exp_);
1224      for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
1225        double_bigit sum =
1226            static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
1227        bigit rhs_bigit = get_bigit(rhs, i);
1228        if (sum > rhs_bigit + borrow) return 1;
1229        borrow = rhs_bigit + borrow - sum;
1230        if (borrow > 1) return -1;
1231        borrow <<= bigit_bits;
1232      }
1233      return borrow != 0 ? -1 : 0;
1234    }
1235    void assign_pow10(int exp) {
1236      assert(exp >= 0);
1237      if (exp == 0) return assign(1);
1238      int bitmask = 1;
1239      while (exp >= bitmask) bitmask <<= 1;
1240      bitmask >>= 1;
1241      assign(5);
1242      bitmask >>= 1;
1243      while (bitmask != 0) {
1244        square();
1245        if ((exp & bitmask) != 0) *this *= 5;
1246        bitmask >>= 1;
1247      }
1248      *this <<= exp;  
1249    }
1250    void square() {
1251      basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));
1252      int num_bigits = static_cast<int>(bigits_.size());
1253      int num_result_bigits = 2 * num_bigits;
1254      bigits_.resize(to_unsigned(num_result_bigits));
1255      using accumulator_t = conditional_t<FMT_USE_INT128, uint128_t, accumulator>;
1256      auto sum = accumulator_t();
1257      for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
1258        for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
1259          sum += static_cast<double_bigit>(n[i]) * n[j];
1260        }
1261        (*this)[bigit_index] = static_cast<bigit>(sum);
1262        sum >>= bits<bigit>::value;  
1263      }
1264      for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
1265           ++bigit_index) {
1266        for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
1267          sum += static_cast<double_bigit>(n[i++]) * n[j--];
1268        (*this)[bigit_index] = static_cast<bigit>(sum);
1269        sum >>= bits<bigit>::value;
1270      }
1271      --num_result_bigits;
1272      remove_leading_zeros();
1273      exp_ *= 2;
1274    }
1275    void align(const bigint& other) {
1276      int exp_difference = exp_ - other.exp_;
1277      if (exp_difference <= 0) return;
1278      int num_bigits = static_cast<int>(bigits_.size());
1279      bigits_.resize(to_unsigned(num_bigits + exp_difference));
1280      for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
1281        bigits_[j] = bigits_[i];
1282      std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
1283      exp_ -= exp_difference;
1284    }
1285    int divmod_assign(const bigint& divisor) {
1286      FMT_ASSERT(this != &divisor, "");
1287      if (compare(*this, divisor) < 0) return 0;
1288      FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
1289      align(divisor);
1290      int quotient = 0;
1291      do {
1292        subtract_aligned(divisor);
1293        ++quotient;
1294      } while (compare(*this, divisor) >= 0);
1295      return quotient;
1296    }
1297  };
1298  enum class round_direction { unknown, up, down };
1299  inline round_direction get_round_direction(uint64_t divisor, uint64_t remainder,
1300                                             uint64_t error) {
1301    FMT_ASSERT(remainder < divisor, "");  
1302    FMT_ASSERT(error < divisor, "");      
1303    FMT_ASSERT(error < divisor - error, "");  
1304    if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
1305      return round_direction::down;
1306    if (remainder >= error &&
1307        remainder - error >= divisor - (remainder - error)) {
1308      return round_direction::up;
1309    }
1310    return round_direction::unknown;
1311  }
1312  namespace digits {
1313  enum result {
1314    more,  
1315    done,  
1316    error  
1317  };
1318  }
1319  template <typename Handler>
1320  FMT_ALWAYS_INLINE digits::result grisu_gen_digits(fp value, uint64_t error,
1321                                                    int& exp, Handler& handler) {
1322    const fp one(1ULL << -value.e, value.e);
1323    auto integral = static_cast<uint32_t>(value.f >> -one.e);
1324    FMT_ASSERT(integral != 0, "");
1325    FMT_ASSERT(integral == value.f >> -one.e, "");
1326    uint64_t fractional = value.f & (one.f - 1);
1327    exp = count_digits(integral);  
1328    auto result = handler.on_start(data::powers_of_10_64[exp - 1] << -one.e,
1329                                   value.f / 10, error * 10, exp);
1330    if (result != digits::more) return result;
1331    do {
1332      uint32_t digit = 0;
1333      auto divmod_integral = [&](uint32_t divisor) {
1334        digit = integral / divisor;
1335        integral %= divisor;
1336      };
1337      switch (exp) {
1338      case 10:
1339        divmod_integral(1000000000);
1340        break;
1341      case 9:
1342        divmod_integral(100000000);
1343        break;
1344      case 8:
1345        divmod_integral(10000000);
1346        break;
1347      case 7:
1348        divmod_integral(1000000);
1349        break;
1350      case 6:
1351        divmod_integral(100000);
1352        break;
1353      case 5:
1354        divmod_integral(10000);
1355        break;
1356      case 4:
1357        divmod_integral(1000);
1358        break;
1359      case 3:
1360        divmod_integral(100);
1361        break;
1362      case 2:
1363        divmod_integral(10);
1364        break;
1365      case 1:
1366        digit = integral;
1367        integral = 0;
1368        break;
1369      default:
1370        FMT_ASSERT(false, "invalid number of digits");
1371      }
1372      --exp;
1373      auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
1374      result = handler.on_digit(static_cast<char>('0' + digit),
1375                                data::powers_of_10_64[exp] << -one.e, remainder,
1376                                error, exp, true);
1377      if (result != digits::more) return result;
1378    } while (exp > 0);
1379    for (;;) {
1380      fractional *= 10;
1381      error *= 10;
1382      char digit = static_cast<char>('0' + (fractional >> -one.e));
1383      fractional &= one.f - 1;
1384      --exp;
1385      result = handler.on_digit(digit, one.f, fractional, error, exp, false);
1386      if (result != digits::more) return result;
1387    }
1388  }
1389  struct fixed_handler {
1390    char* buf;
1391    int size;
1392    int precision;
1393    int exp10;
1394    bool fixed;
1395    digits::result on_start(uint64_t divisor, uint64_t remainder, uint64_t error,
1396                            int& exp) {
1397      if (!fixed) return digits::more;
1398      precision += exp + exp10;
1399      if (precision > 0) return digits::more;
1400      if (precision < 0) return digits::done;
1401      auto dir = get_round_direction(divisor, remainder, error);
1402      if (dir == round_direction::unknown) return digits::error;
1403      buf[size++] = dir == round_direction::up ? '1' : '0';
1404      return digits::done;
1405    }
1406    digits::result on_digit(char digit, uint64_t divisor, uint64_t remainder,
1407                            uint64_t error, int, bool integral) {
1408      FMT_ASSERT(remainder < divisor, "");
1409      buf[size++] = digit;
1410      if (!integral && error >= remainder) return digits::error;
1411      if (size < precision) return digits::more;
1412      if (!integral) {
1413        if (error >= divisor || error >= divisor - error) return digits::error;
1414      } else {
1415        FMT_ASSERT(error == 1 && divisor > 2, "");
1416      }
1417      auto dir = get_round_direction(divisor, remainder, error);
1418      if (dir != round_direction::up)
1419        return dir == round_direction::down ? digits::done : digits::error;
1420      ++buf[size - 1];
1421      for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {
1422        buf[i] = '0';
1423        ++buf[i - 1];
1424      }
1425      if (buf[0] > '9') {
1426        buf[0] = '1';
1427        if (fixed) buf[size++] = '0';
1428        else ++exp10;
1429      }
1430      return digits::done;
1431    }
1432  };
1433  namespace dragonbox {
1434  FMT_SAFEBUFFERS inline uint128_wrapper umul128(uint64_t x,
1435                                                 uint64_t y) FMT_NOEXCEPT {
1436  #if FMT_USE_INT128
1437    return static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
1438  #elif defined(_MSC_VER) && defined(_M_X64)
1439    uint128_wrapper result;
1440    result.low_ = _umul128(x, y, &result.high_);
1441    return result;
1442  #else
1443    const uint64_t mask = (uint64_t(1) << 32) - uint64_t(1);
1444    uint64_t a = x >> 32;
1445    uint64_t b = x & mask;
1446    uint64_t c = y >> 32;
1447    uint64_t d = y & mask;
1448    uint64_t ac = a * c;
1449    uint64_t bc = b * c;
1450    uint64_t ad = a * d;
1451    uint64_t bd = b * d;
1452    uint64_t intermediate = (bd >> 32) + (ad & mask) + (bc & mask);
1453    return {ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),
1454            (intermediate << 32) + (bd & mask)};
1455  #endif
1456  }
1457  FMT_SAFEBUFFERS inline uint64_t umul128_upper64(uint64_t x,
1458                                                  uint64_t y) FMT_NOEXCEPT {
1459  #if FMT_USE_INT128
1460    auto p = static_cast<uint128_t>(x) * static_cast<uint128_t>(y);
1461    return static_cast<uint64_t>(p >> 64);
1462  #elif defined(_MSC_VER) && defined(_M_X64)
1463    return __umulh(x, y);
1464  #else
1465    return umul128(x, y).high();
1466  #endif
1467  }
1468  FMT_SAFEBUFFERS inline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y)
1469      FMT_NOEXCEPT {
1470    uint128_wrapper g0 = umul128(x, y.high());
1471    g0 += umul128_upper64(x, y.low());
1472    return g0.high();
1473  }
1474  inline uint32_t umul96_upper32(uint32_t x, uint64_t y) FMT_NOEXCEPT {
1475    return static_cast<uint32_t>(umul128_upper64(x, y));
1476  }
1477  FMT_SAFEBUFFERS inline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y)
1478      FMT_NOEXCEPT {
1479    uint64_t g01 = x * y.high();
1480    uint64_t g10 = umul128_upper64(x, y.low());
1481    return g01 + g10;
1482  }
1483  inline uint64_t umul96_lower64(uint32_t x, uint64_t y) FMT_NOEXCEPT {
1484    return x * y;
1485  }
1486  inline int floor_log10_pow2(int e) FMT_NOEXCEPT {
1487    FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
1488    const int shift = 22;
1489    return (e * static_cast<int>(data::log10_2_significand >> (64 - shift))) >>
1490           shift;
1491  }
1492  inline int floor_log2_pow10(int e) FMT_NOEXCEPT {
1493    FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
1494    const uint64_t log2_10_integer_part = 3;
1495    const uint64_t log2_10_fractional_digits = 0x5269e12f346e2bf9;
1496    const int shift_amount = 19;
1497    return (e * static_cast<int>(
1498                    (log2_10_integer_part << shift_amount) |
1499                    (log2_10_fractional_digits >> (64 - shift_amount)))) >>
1500           shift_amount;
1501  }
1502  inline int floor_log10_pow2_minus_log10_4_over_3(int e) FMT_NOEXCEPT {
1503    FMT_ASSERT(e <= 1700 && e >= -1700, "too large exponent");
1504    const uint64_t log10_4_over_3_fractional_digits = 0x1ffbfc2bbc780375;
1505    const int shift_amount = 22;
1506    return (e * static_cast<int>(data::log10_2_significand >>
1507                                 (64 - shift_amount)) -
1508            static_cast<int>(log10_4_over_3_fractional_digits >>
1509                             (64 - shift_amount))) >>
1510           shift_amount;
1511  }
1512  inline bool divisible_by_power_of_2(uint32_t x, int exp) FMT_NOEXCEPT {
1513    FMT_ASSERT(exp >= 1, "");
1514    FMT_ASSERT(x != 0, "");
1515  #ifdef FMT_BUILTIN_CTZ
1516    return FMT_BUILTIN_CTZ(x) >= exp;
1517  #else
1518    return exp < num_bits<uint32_t>() && x == ((x >> exp) << exp);
1519  #endif
1520  }
1521  inline bool divisible_by_power_of_2(uint64_t x, int exp) FMT_NOEXCEPT {
1522    FMT_ASSERT(exp >= 1, "");
1523    FMT_ASSERT(x != 0, "");
1524  #ifdef FMT_BUILTIN_CTZLL
1525    return FMT_BUILTIN_CTZLL(x) >= exp;
1526  #else
1527    return (exp < num_bits<uint64_t>()) && x == ((x >> exp) << exp);
1528  #endif
1529  }
1530  inline bool divisible_by_power_of_5(uint32_t x, int exp) FMT_NOEXCEPT {
1531    FMT_ASSERT(exp <= 10, "too large exponent");
1532    return x * data::divtest_table_for_pow5_32[exp].mod_inv <=
1533           data::divtest_table_for_pow5_32[exp].max_quotient;
1534  }
1535  inline bool divisible_by_power_of_5(uint64_t x, int exp) FMT_NOEXCEPT {
1536    FMT_ASSERT(exp <= 23, "too large exponent");
1537    return x * data::divtest_table_for_pow5_64[exp].mod_inv <=
1538           data::divtest_table_for_pow5_64[exp].max_quotient;
1539  }
1540  template <int N>
1541  bool check_divisibility_and_divide_by_pow5(uint32_t& n) FMT_NOEXCEPT {
1542    static constexpr struct {
1543      uint32_t magic_number;
1544      int bits_for_comparison;
1545      uint32_t threshold;
1546      int shift_amount;
1547    } infos[] = {{0xcccd, 16, 0x3333, 18}, {0xa429, 8, 0x0a, 20}};
1548    constexpr auto info = infos[N - 1];
1549    n *= info.magic_number;
1550    const uint32_t comparison_mask = (1u << info.bits_for_comparison) - 1;
1551    bool result = (n & comparison_mask) <= info.threshold;
1552    n >>= info.shift_amount;
1553    return result;
1554  }
1555  template <int N> uint32_t small_division_by_pow10(uint32_t n) FMT_NOEXCEPT {
1556    static constexpr struct {
1557      uint32_t magic_number;
1558      int shift_amount;
1559      uint32_t divisor_times_10;
1560    } infos[] = {{0xcccd, 19, 100}, {0xa3d8, 22, 1000}};
1561    constexpr auto info = infos[N - 1];
1562    FMT_ASSERT(n <= info.divisor_times_10, "n is too large");
1563    return n * info.magic_number >> info.shift_amount;
1564  }
1565  inline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) FMT_NOEXCEPT {
1566    return n / float_info<float>::big_divisor;
1567  }
1568  inline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) FMT_NOEXCEPT {
1569    return umul128_upper64(n, 0x83126e978d4fdf3c) >> 9;
1570  }
1571  template <class T> struct cache_accessor;
1572  template <> struct cache_accessor<float> {
1573    using carrier_uint = float_info<float>::carrier_uint;
1574    using cache_entry_type = uint64_t;
1575    static uint64_t get_cached_power(int k) FMT_NOEXCEPT {
1576      FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,
1577                 "k is out of range");
1578      return data::dragonbox_pow10_significands_64[k - float_info<float>::min_k];
1579    }
1580    static carrier_uint compute_mul(carrier_uint u,
1581                                    const cache_entry_type& cache) FMT_NOEXCEPT {
1582      return umul96_upper32(u, cache);
1583    }
1584    static uint32_t compute_delta(const cache_entry_type& cache,
1585                                  int beta_minus_1) FMT_NOEXCEPT {
1586      return static_cast<uint32_t>(cache >> (64 - 1 - beta_minus_1));
1587    }
1588    static bool compute_mul_parity(carrier_uint two_f,
1589                                   const cache_entry_type& cache,
1590                                   int beta_minus_1) FMT_NOEXCEPT {
1591      FMT_ASSERT(beta_minus_1 >= 1, "");
1592      FMT_ASSERT(beta_minus_1 < 64, "");
1593      return ((umul96_lower64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
1594    }
1595    static carrier_uint compute_left_endpoint_for_shorter_interval_case(
1596        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1597      return static_cast<carrier_uint>(
1598          (cache - (cache >> (float_info<float>::significand_bits + 2))) >>
1599          (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
1600    }
1601    static carrier_uint compute_right_endpoint_for_shorter_interval_case(
1602        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1603      return static_cast<carrier_uint>(
1604          (cache + (cache >> (float_info<float>::significand_bits + 1))) >>
1605          (64 - float_info<float>::significand_bits - 1 - beta_minus_1));
1606    }
1607    static carrier_uint compute_round_up_for_shorter_interval_case(
1608        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1609      return (static_cast<carrier_uint>(
1610                  cache >>
1611                  (64 - float_info<float>::significand_bits - 2 - beta_minus_1)) +
1612              1) /
1613             2;
1614    }
1615  };
1616  template <> struct cache_accessor<double> {
1617    using carrier_uint = float_info<double>::carrier_uint;
1618    using cache_entry_type = uint128_wrapper;
1619    static uint128_wrapper get_cached_power(int k) FMT_NOEXCEPT {
1620      FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,
1621                 "k is out of range");
1622  #if FMT_USE_FULL_CACHE_DRAGONBOX
1623      return data::dragonbox_pow10_significands_128[k -
1624                                                    float_info<double>::min_k];
1625  #else
1626      static const int compression_ratio = 27;
1627      int cache_index = (k - float_info<double>::min_k) / compression_ratio;
1628      int kb = cache_index * compression_ratio + float_info<double>::min_k;
1629      int offset = k - kb;
1630      uint128_wrapper base_cache =
1631          data::dragonbox_pow10_significands_128[cache_index];
1632      if (offset == 0) return base_cache;
1633      int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;
1634      FMT_ASSERT(alpha > 0 && alpha < 64, "shifting error detected");
1635      uint64_t pow5 = data::powers_of_5_64[offset];
1636      uint128_wrapper recovered_cache = umul128(base_cache.high(), pow5);
1637      uint128_wrapper middle_low =
1638          umul128(base_cache.low() - (kb < 0 ? 1 : 0), pow5);
1639      recovered_cache += middle_low.high();
1640      uint64_t high_to_middle = recovered_cache.high() << (64 - alpha);
1641      uint64_t middle_to_low = recovered_cache.low() << (64 - alpha);
1642      recovered_cache =
1643          uint128_wrapper{(recovered_cache.low() >> alpha) | high_to_middle,
1644                          ((middle_low.low() >> alpha) | middle_to_low)};
1645      if (kb < 0) recovered_cache += 1;
1646      int error_idx = (k - float_info<double>::min_k) / 16;
1647      uint32_t error = (data::dragonbox_pow10_recovery_errors[error_idx] >>
1648                        ((k - float_info<double>::min_k) % 16) * 2) &
1649                       0x3;
1650      FMT_ASSERT(recovered_cache.low() + error >= recovered_cache.low(), "");
1651      return {recovered_cache.high(), recovered_cache.low() + error};
1652  #endif
1653    }
1654    static carrier_uint compute_mul(carrier_uint u,
1655                                    const cache_entry_type& cache) FMT_NOEXCEPT {
1656      return umul192_upper64(u, cache);
1657    }
1658    static uint32_t compute_delta(cache_entry_type const& cache,
1659                                  int beta_minus_1) FMT_NOEXCEPT {
1660      return static_cast<uint32_t>(cache.high() >> (64 - 1 - beta_minus_1));
1661    }
1662    static bool compute_mul_parity(carrier_uint two_f,
1663                                   const cache_entry_type& cache,
1664                                   int beta_minus_1) FMT_NOEXCEPT {
1665      FMT_ASSERT(beta_minus_1 >= 1, "");
1666      FMT_ASSERT(beta_minus_1 < 64, "");
1667      return ((umul192_middle64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;
1668    }
1669    static carrier_uint compute_left_endpoint_for_shorter_interval_case(
1670        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1671      return (cache.high() -
1672              (cache.high() >> (float_info<double>::significand_bits + 2))) >>
1673             (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
1674    }
1675    static carrier_uint compute_right_endpoint_for_shorter_interval_case(
1676        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1677      return (cache.high() +
1678              (cache.high() >> (float_info<double>::significand_bits + 1))) >>
1679             (64 - float_info<double>::significand_bits - 1 - beta_minus_1);
1680    }
1681    static carrier_uint compute_round_up_for_shorter_interval_case(
1682        const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {
1683      return ((cache.high() >>
1684               (64 - float_info<double>::significand_bits - 2 - beta_minus_1)) +
1685              1) /
1686             2;
1687    }
1688  };
1689  template <class T>
1690  bool is_left_endpoint_integer_shorter_interval(int exponent) FMT_NOEXCEPT {
1691    return exponent >=
1692               float_info<
1693                   T>::case_shorter_interval_left_endpoint_lower_threshold &&
1694           exponent <=
1695               float_info<T>::case_shorter_interval_left_endpoint_upper_threshold;
1696  }
1697  template <class T>
1698  bool is_endpoint_integer(typename float_info<T>::carrier_uint two_f,
1699                           int exponent, int minus_k) FMT_NOEXCEPT {
1700    if (exponent < float_info<T>::case_fc_pm_half_lower_threshold) return false;
1701    if (exponent <= float_info<T>::case_fc_pm_half_upper_threshold) return true;
1702    if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
1703    return divisible_by_power_of_5(two_f, minus_k);
1704  }
1705  template <class T>
1706  bool is_center_integer(typename float_info<T>::carrier_uint two_f, int exponent,
1707                         int minus_k) FMT_NOEXCEPT {
1708    if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;
1709    if (exponent > float_info<T>::case_fc_upper_threshold)
1710      return divisible_by_power_of_5(two_f, minus_k);
1711    if (exponent >= float_info<T>::case_fc_lower_threshold) return true;
1712    return divisible_by_power_of_2(two_f, minus_k - exponent + 1);
1713  }
1714  FMT_ALWAYS_INLINE int remove_trailing_zeros(uint32_t& n) FMT_NOEXCEPT {
1715  #ifdef FMT_BUILTIN_CTZ
1716    int t = FMT_BUILTIN_CTZ(n);
1717  #else
1718    int t = ctz(n);
1719  #endif
1720    if (t > float_info<float>::max_trailing_zeros)
1721      t = float_info<float>::max_trailing_zeros;
1722    const uint32_t mod_inv1 = 0xcccccccd;
1723    const uint32_t max_quotient1 = 0x33333333;
1724    const uint32_t mod_inv2 = 0xc28f5c29;
1725    const uint32_t max_quotient2 = 0x0a3d70a3;
1726    int s = 0;
1727    for (; s < t - 1; s += 2) {
1728      if (n * mod_inv2 > max_quotient2) break;
1729      n *= mod_inv2;
1730    }
1731    if (s < t && n * mod_inv1 <= max_quotient1) {
1732      n *= mod_inv1;
1733      ++s;
1734    }
1735    n >>= s;
1736    return s;
1737  }
<span onclick='openModal()' class='match'>1738  FMT_ALWAYS_INLINE int remove_trailing_zeros(uint64_t& n) FMT_NOEXCEPT {
1739  #ifdef FMT_BUILTIN_CTZLL
1740    int t = FMT_BUILTIN_CTZLL(n);
1741  #else
1742    int t = ctzll(n);
1743  #endif
1744    if (t > float_info<double>::max_trailing_zeros)
</span>1745      t = float_info<double>::max_trailing_zeros;
1746    const uint32_t mod_inv1 = 0xcccccccd;
1747    const uint32_t max_quotient1 = 0x33333333;
1748    const uint64_t mod_inv8 = 0xc767074b22e90e21;
1749    const uint64_t max_quotient8 = 0x00002af31dc46118;
1750    if (t >= 8) {
1751      auto quotient_candidate = n * mod_inv8;
1752      if (quotient_candidate <= max_quotient8) {
1753        auto quotient = static_cast<uint32_t>(quotient_candidate >> 8);
1754        int s = 8;
1755        for (; s < t; ++s) {
1756          if (quotient * mod_inv1 > max_quotient1) break;
1757          quotient *= mod_inv1;
1758        }
1759        quotient >>= (s - 8);
1760        n = quotient;
1761        return s;
1762      }
1763    }
1764    auto quotient = static_cast<uint32_t>(n / 100000000);
1765    auto remainder = static_cast<uint32_t>(n - 100000000 * quotient);
1766    if (t == 0 || remainder * mod_inv1 > max_quotient1) {
1767      return 0;
1768    }
1769    remainder *= mod_inv1;
1770    if (t == 1 || remainder * mod_inv1 > max_quotient1) {
1771      n = (remainder >> 1) + quotient * 10000000ull;
1772      return 1;
1773    }
1774    remainder *= mod_inv1;
1775    if (t == 2 || remainder * mod_inv1 > max_quotient1) {
1776      n = (remainder >> 2) + quotient * 1000000ull;
1777      return 2;
1778    }
1779    remainder *= mod_inv1;
1780    if (t == 3 || remainder * mod_inv1 > max_quotient1) {
1781      n = (remainder >> 3) + quotient * 100000ull;
1782      return 3;
1783    }
1784    remainder *= mod_inv1;
1785    if (t == 4 || remainder * mod_inv1 > max_quotient1) {
1786      n = (remainder >> 4) + quotient * 10000ull;
1787      return 4;
1788    }
1789    remainder *= mod_inv1;
1790    if (t == 5 || remainder * mod_inv1 > max_quotient1) {
1791      n = (remainder >> 5) + quotient * 1000ull;
1792      return 5;
1793    }
1794    remainder *= mod_inv1;
1795    if (t == 6 || remainder * mod_inv1 > max_quotient1) {
1796      n = (remainder >> 6) + quotient * 100ull;
1797      return 6;
1798    }
1799    remainder *= mod_inv1;
1800    n = (remainder >> 7) + quotient * 10ull;
1801    return 7;
1802  }
1803  template <class T>
1804  FMT_ALWAYS_INLINE FMT_SAFEBUFFERS decimal_fp<T> shorter_interval_case(
1805      int exponent) FMT_NOEXCEPT {
1806    decimal_fp<T> ret_value;
1807    const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);
1808    const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);
1809    using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
1810    const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
1811    auto xi = cache_accessor<T>::compute_left_endpoint_for_shorter_interval_case(
1812        cache, beta_minus_1);
1813    auto zi = cache_accessor<T>::compute_right_endpoint_for_shorter_interval_case(
1814        cache, beta_minus_1);
1815    if (!is_left_endpoint_integer_shorter_interval<T>(exponent)) ++xi;
1816    ret_value.significand = zi / 10;
1817    if (ret_value.significand * 10 >= xi) {
1818      ret_value.exponent = minus_k + 1;
1819      ret_value.exponent += remove_trailing_zeros(ret_value.significand);
1820      return ret_value;
1821    }
1822    ret_value.significand =
1823        cache_accessor<T>::compute_round_up_for_shorter_interval_case(
1824            cache, beta_minus_1);
1825    ret_value.exponent = minus_k;
1826    if (exponent >= float_info<T>::shorter_interval_tie_lower_threshold &&
1827        exponent <= float_info<T>::shorter_interval_tie_upper_threshold) {
1828      ret_value.significand = ret_value.significand % 2 == 0
1829                                  ? ret_value.significand
1830                                  : ret_value.significand - 1;
1831    } else if (ret_value.significand < xi) {
1832      ++ret_value.significand;
1833    }
1834    return ret_value;
1835  }
1836  template <typename T>
1837  FMT_SAFEBUFFERS decimal_fp<T> to_decimal(T x) FMT_NOEXCEPT {
1838    using carrier_uint = typename float_info<T>::carrier_uint;
1839    using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
1840    auto br = bit_cast<carrier_uint>(x);
1841    const carrier_uint significand_mask =
1842        (static_cast<carrier_uint>(1) << float_info<T>::significand_bits) - 1;
1843    carrier_uint significand = (br & significand_mask);
1844    const carrier_uint exponent_mask =
1845        ((static_cast<carrier_uint>(1) << float_info<T>::exponent_bits) - 1)
1846        << float_info<T>::significand_bits;
1847    int exponent =
1848        static_cast<int>((br & exponent_mask) >> float_info<T>::significand_bits);
1849    if (exponent != 0) {  
1850      exponent += float_info<T>::exponent_bias - float_info<T>::significand_bits;
1851      if (significand == 0) return shorter_interval_case<T>(exponent);
1852      significand |=
1853          (static_cast<carrier_uint>(1) << float_info<T>::significand_bits);
1854    } else {
1855      if (significand == 0) return {0, 0};
1856      exponent = float_info<T>::min_exponent - float_info<T>::significand_bits;
1857    }
1858    const bool include_left_endpoint = (significand % 2 == 0);
1859    const bool include_right_endpoint = include_left_endpoint;
1860    const int minus_k = floor_log10_pow2(exponent) - float_info<T>::kappa;
1861    const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
1862    const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);
1863    const uint32_t deltai = cache_accessor<T>::compute_delta(cache, beta_minus_1);
1864    const carrier_uint two_fc = significand << 1;
1865    const carrier_uint two_fr = two_fc | 1;
1866    const carrier_uint zi =
1867        cache_accessor<T>::compute_mul(two_fr << beta_minus_1, cache);
1868    decimal_fp<T> ret_value;
1869    ret_value.significand = divide_by_10_to_kappa_plus_1(zi);
1870    uint32_t r = static_cast<uint32_t>(zi - float_info<T>::big_divisor *
1871                                                ret_value.significand);
1872    if (r > deltai) {
1873      goto small_divisor_case_label;
1874    } else if (r < deltai) {
1875      if (r == 0 && !include_right_endpoint &&
1876          is_endpoint_integer<T>(two_fr, exponent, minus_k)) {
1877        --ret_value.significand;
1878        r = float_info<T>::big_divisor;
1879        goto small_divisor_case_label;
1880      }
1881    } else {
1882      const carrier_uint two_fl = two_fc - 1;
1883      if ((!include_left_endpoint ||
1884           !is_endpoint_integer<T>(two_fl, exponent, minus_k)) &&
1885          !cache_accessor<T>::compute_mul_parity(two_fl, cache, beta_minus_1)) {
1886        goto small_divisor_case_label;
1887      }
1888    }
1889    ret_value.exponent = minus_k + float_info<T>::kappa + 1;
1890    ret_value.exponent += remove_trailing_zeros(ret_value.significand);
1891    return ret_value;
1892  small_divisor_case_label:
1893    ret_value.significand *= 10;
1894    ret_value.exponent = minus_k + float_info<T>::kappa;
1895    const uint32_t mask = (1u << float_info<T>::kappa) - 1;
1896    auto dist = r - (deltai / 2) + (float_info<T>::small_divisor / 2);
1897    if ((dist & mask) == 0) {
1898      const bool approx_y_parity =
1899          ((dist ^ (float_info<T>::small_divisor / 2)) & 1) != 0;
1900      dist >>= float_info<T>::kappa;
1901      if (check_divisibility_and_divide_by_pow5<float_info<T>::kappa>(dist)) {
1902        ret_value.significand += dist;
1903        if (cache_accessor<T>::compute_mul_parity(two_fc, cache, beta_minus_1) !=
1904            approx_y_parity) {
1905          --ret_value.significand;
1906        } else {
1907          if (is_center_integer<T>(two_fc, exponent, minus_k)) {
1908            ret_value.significand = ret_value.significand % 2 == 0
1909                                        ? ret_value.significand
1910                                        : ret_value.significand - 1;
1911          }
1912        }
1913      }
1914      else {
1915        ret_value.significand += dist;
1916      }
1917    }
1918    else {
1919      ret_value.significand +=
1920          small_division_by_pow10<float_info<T>::kappa>(dist);
1921    }
1922    return ret_value;
1923  }
1924  }  
1925  template <typename Double>
1926  void fallback_format(Double d, int num_digits, bool binary32, buffer<char>& buf,
1927                       int& exp10) {
1928    bigint numerator;    
1929    bigint denominator;  
1930    bigint lower;             
1931    bigint upper_store;       
1932    bigint* upper = nullptr;  
1933    fp value;
1934    const bool is_predecessor_closer =
1935        binary32 ? value.assign(static_cast<float>(d)) : value.assign(d);
1936    int shift = is_predecessor_closer ? 2 : 1;
1937    uint64_t significand = value.f << shift;
1938    if (value.e >= 0) {
1939      numerator.assign(significand);
1940      numerator <<= value.e;
1941      lower.assign(1);
1942      lower <<= value.e;
1943      if (shift != 1) {
1944        upper_store.assign(1);
1945        upper_store <<= value.e + 1;
1946        upper = &upper_store;
1947      }
1948      denominator.assign_pow10(exp10);
1949      denominator <<= 1;
1950    } else if (exp10 < 0) {
1951      numerator.assign_pow10(-exp10);
1952      lower.assign(numerator);
1953      if (shift != 1) {
1954        upper_store.assign(numerator);
1955        upper_store <<= 1;
1956        upper = &upper_store;
1957      }
1958      numerator *= significand;
1959      denominator.assign(1);
1960      denominator <<= shift - value.e;
1961    } else {
1962      numerator.assign(significand);
1963      denominator.assign_pow10(exp10);
1964      denominator <<= shift - value.e;
1965      lower.assign(1);
1966      if (shift != 1) {
1967        upper_store.assign(1ULL << 1);
1968        upper = &upper_store;
1969      }
1970    }
1971    if (num_digits < 0) {
1972      if (!upper) upper = &lower;
1973      bool even = (value.f & 1) == 0;
1974      num_digits = 0;
1975      char* data = buf.data();
1976      for (;;) {
1977        int digit = numerator.divmod_assign(denominator);
1978        bool low = compare(numerator, lower) - even < 0;  
1979        bool high = add_compare(numerator, *upper, denominator) + even > 0;
1980        data[num_digits++] = static_cast<char>('0' + digit);
1981        if (low || high) {
1982          if (!low) {
1983            ++data[num_digits - 1];
1984          } else if (high) {
1985            int result = add_compare(numerator, numerator, denominator);
1986            if (result > 0 || (result == 0 && (digit % 2) != 0))
1987              ++data[num_digits - 1];
1988          }
1989          buf.try_resize(to_unsigned(num_digits));
1990          exp10 -= num_digits - 1;
1991          return;
1992        }
1993        numerator *= 10;
1994        lower *= 10;
1995        if (upper != &lower) *upper *= 10;
1996      }
1997    }
1998    exp10 -= num_digits - 1;
1999    if (num_digits == 0) {
2000      buf.try_resize(1);
2001      denominator *= 10;
2002      buf[0] = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
2003      return;
2004    }
2005    buf.try_resize(to_unsigned(num_digits));
2006    for (int i = 0; i < num_digits - 1; ++i) {
2007      int digit = numerator.divmod_assign(denominator);
2008      buf[i] = static_cast<char>('0' + digit);
2009      numerator *= 10;
2010    }
2011    int digit = numerator.divmod_assign(denominator);
2012    auto result = add_compare(numerator, numerator, denominator);
2013    if (result > 0 || (result == 0 && (digit % 2) != 0)) {
2014      if (digit == 9) {
2015        const auto overflow = '0' + 10;
2016        buf[num_digits - 1] = overflow;
2017        for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
2018          buf[i] = '0';
2019          ++buf[i - 1];
2020        }
2021        if (buf[0] == overflow) {
2022          buf[0] = '1';
2023          ++exp10;
2024        }
2025        return;
2026      }
2027      ++digit;
2028    }
2029    buf[num_digits - 1] = static_cast<char>('0' + digit);
2030  }
2031  template <typename T>
2032  int format_float(T value, int precision, float_specs specs, buffer<char>& buf) {
2033    static_assert(!std::is_same<T, float>::value, "");
2034    FMT_ASSERT(value >= 0, "value is negative");
2035    const bool fixed = specs.format == float_format::fixed;
2036    if (value <= 0) {  
2037      if (precision <= 0 || !fixed) {
2038        buf.push_back('0');
2039        return 0;
2040      }
2041      buf.try_resize(to_unsigned(precision));
2042      std::uninitialized_fill_n(buf.data(), precision, '0');
2043      return -precision;
2044    }
2045    if (!specs.use_grisu) return snprintf_float(value, precision, specs, buf);
2046    if (precision < 0) {
2047      if (specs.binary32) {
2048        auto dec = dragonbox::to_decimal(static_cast<float>(value));
2049        write<char>(buffer_appender<char>(buf), dec.significand);
2050        return dec.exponent;
2051      }
2052      auto dec = dragonbox::to_decimal(static_cast<double>(value));
2053      write<char>(buffer_appender<char>(buf), dec.significand);
2054      return dec.exponent;
2055    }
2056    int exp = 0;
2057    const int min_exp = -60;  
2058    int cached_exp10 = 0;     
2059    fp normalized = normalize(fp(value));
2060    const auto cached_pow = get_cached_power(
2061        min_exp - (normalized.e + fp::significand_size), cached_exp10);
2062    normalized = normalized * cached_pow;
2063    const int max_double_digits = 767;
2064    if (precision > max_double_digits) precision = max_double_digits;
2065    fixed_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
2066    if (grisu_gen_digits(normalized, 1, exp, handler) == digits::error) {
2067      exp += handler.size - cached_exp10 - 1;
2068      fallback_format(value, handler.precision, specs.binary32, buf, exp);
2069    } else {
2070      exp += handler.exp10;
2071      buf.try_resize(to_unsigned(handler.size));
2072    }
2073    if (!fixed && !specs.showpoint) {
2074      auto num_digits = buf.size();
2075      while (num_digits > 0 && buf[num_digits - 1] == '0') {
2076        --num_digits;
2077        ++exp;
2078      }
2079      buf.try_resize(num_digits);
2080    }
2081    return exp;
2082  }  
2083  template <typename T>
2084  int snprintf_float(T value, int precision, float_specs specs,
2085                     buffer<char>& buf) {
2086    FMT_ASSERT(buf.capacity() > buf.size(), "empty buffer");
2087    static_assert(!std::is_same<T, float>::value, "");
2088    if (specs.format == float_format::general ||
2089        specs.format == float_format::exp)
2090      precision = (precision >= 0 ? precision : 6) - 1;
2091    enum { max_format_size = 7 };  
2092    char format[max_format_size];
2093    char* format_ptr = format;
2094    *format_ptr++ = '%';
2095    if (specs.showpoint && specs.format == float_format::hex) *format_ptr++ = '#';
2096    if (precision >= 0) {
2097      *format_ptr++ = '.';
2098      *format_ptr++ = '*';
2099    }
2100    if (std::is_same<T, long double>()) *format_ptr++ = 'L';
2101    *format_ptr++ = specs.format != float_format::hex
2102                        ? (specs.format == float_format::fixed ? 'f' : 'e')
2103                        : (specs.upper ? 'A' : 'a');
2104    *format_ptr = '\0';
2105    auto offset = buf.size();
2106    for (;;) {
2107      auto begin = buf.data() + offset;
2108      auto capacity = buf.capacity() - offset;
2109  #ifdef FMT_FUZZ
2110      if (precision > 100000)
2111        throw std::runtime_error(
2112            "fuzz mode - avoid large allocation inside snprintf");
2113  #endif
2114      int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;
2115      int result = precision >= 0
2116                       ? snprintf_ptr(begin, capacity, format, precision, value)
2117                       : snprintf_ptr(begin, capacity, format, value);
2118      if (result < 0) {
2119        buf.try_reserve(buf.capacity() + 1);
2120        continue;
2121      }
2122      auto size = to_unsigned(result);
2123      if (size >= capacity) {
2124        buf.try_reserve(size + offset + 1);  
2125        continue;
2126      }
2127      auto is_digit = [](char c) { return c >= '0' && c <= '9'; };
2128      if (specs.format == float_format::fixed) {
2129        if (precision == 0) {
2130          buf.try_resize(size);
2131          return 0;
2132        }
2133        auto end = begin + size, p = end;
2134        do {
2135          --p;
2136        } while (is_digit(*p));
2137        int fraction_size = static_cast<int>(end - p - 1);
2138        std::memmove(p, p + 1, to_unsigned(fraction_size));
2139        buf.try_resize(size - 1);
2140        return -fraction_size;
2141      }
2142      if (specs.format == float_format::hex) {
2143        buf.try_resize(size + offset);
2144        return 0;
2145      }
2146      auto end = begin + size, exp_pos = end;
2147      do {
2148        --exp_pos;
2149      } while (*exp_pos != 'e');
2150      char sign = exp_pos[1];
2151      assert(sign == '+' || sign == '-');
2152      int exp = 0;
2153      auto p = exp_pos + 2;  
2154      do {
2155        assert(is_digit(*p));
2156        exp = exp * 10 + (*p++ - '0');
2157      } while (p != end);
2158      if (sign == '-') exp = -exp;
2159      int fraction_size = 0;
2160      if (exp_pos != begin + 1) {
2161        auto fraction_end = exp_pos - 1;
2162        while (*fraction_end == '0') --fraction_end;
2163        fraction_size = static_cast<int>(fraction_end - begin - 1);
2164        std::memmove(begin + 1, begin + 2, to_unsigned(fraction_size));
2165      }
2166      buf.try_resize(to_unsigned(fraction_size) + offset + 1);
2167      return exp - fraction_size;
2168    }
2169  }
2170  inline const char* utf8_decode(const char* buf, uint32_t* c, int* e) {
2171    static const char lengths[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
2172                                   1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
2173                                   0, 0, 2, 2, 2, 2, 3, 3, 4, 0};
2174    static const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
2175    static const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};
2176    static const int shiftc[] = {0, 18, 12, 6, 0};
2177    static const int shifte[] = {0, 6, 4, 2, 0};
2178    auto s = reinterpret_cast<const unsigned char*>(buf);
2179    int len = lengths[s[0] >> 3];
2180    const char* next = buf + len + !len;
2181    *c = uint32_t(s[0] & masks[len]) << 18;
2182    *c |= uint32_t(s[1] & 0x3f) << 12;
2183    *c |= uint32_t(s[2] & 0x3f) << 6;
2184    *c |= uint32_t(s[3] & 0x3f) << 0;
2185    *c >>= shiftc[len];
2186    *e = (*c < mins[len]) << 6;       
2187    *e |= ((*c >> 11) == 0x1b) << 7;  
2188    *e |= (*c > 0x10FFFF) << 8;       
2189    *e |= (s[1] & 0xc0) >> 2;
2190    *e |= (s[2] & 0xc0) >> 4;
2191    *e |= (s[3]) >> 6;
2192    *e ^= 0x2a;  
2193    *e >>= shifte[len];
2194    return next;
2195  }
2196  struct stringifier {
2197    template <typename T> FMT_INLINE std::string operator()(T value) const {
2198      return to_string(value);
2199    }
2200    std::string operator()(basic_format_arg<format_context>::handle h) const {
2201      memory_buffer buf;
2202      format_parse_context parse_ctx({});
2203      format_context format_ctx(buffer_appender<char>(buf), {}, {});
2204      h.format(parse_ctx, format_ctx);
2205      return to_string(buf);
2206    }
2207  };
2208  }  
2209  template <> struct formatter<detail::bigint> {
2210    format_parse_context::iterator parse(format_parse_context& ctx) {
2211      return ctx.begin();
2212    }
2213    format_context::iterator format(const detail::bigint& n,
2214                                    format_context& ctx) {
2215      auto out = ctx.out();
2216      bool first = true;
2217      for (auto i = n.bigits_.size(); i > 0; --i) {
2218        auto value = n.bigits_[i - 1u];
2219        if (first) {
2220          out = format_to(out, "{:x}", value);
2221          first = false;
2222          continue;
2223        }
2224        out = format_to(out, "{:08x}", value);
2225      }
2226      if (n.exp_ > 0)
2227        out = format_to(out, "p{}", n.exp_ * detail::bigint::bigit_bits);
2228      return out;
2229    }
2230  };
2231  FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
2232    auto transcode = [this](const char* p) {
2233      auto cp = uint32_t();
2234      auto error = 0;
2235      p = utf8_decode(p, &cp, &error);
2236      if (error != 0) FMT_THROW(std::runtime_error("invalid utf8"));
2237      if (cp <= 0xFFFF) {
2238        buffer_.push_back(static_cast<wchar_t>(cp));
2239      } else {
2240        cp -= 0x10000;
2241        buffer_.push_back(static_cast<wchar_t>(0xD800 + (cp >> 10)));
2242        buffer_.push_back(static_cast<wchar_t>(0xDC00 + (cp & 0x3FF)));
2243      }
2244      return p;
2245    };
2246    auto p = s.data();
2247    const size_t block_size = 4;  
2248    if (s.size() >= block_size) {
2249      for (auto end = p + s.size() - block_size + 1; p < end;) p = transcode(p);
2250    }
2251    if (auto num_chars_left = s.data() + s.size() - p) {
2252      char buf[2 * block_size - 1] = {};
2253      memcpy(buf, p, to_unsigned(num_chars_left));
2254      p = buf;
2255      do {
2256        p = transcode(p);
2257      } while (p - buf < num_chars_left);
2258    }
2259    buffer_.push_back(0);
2260  }
2261  FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
2262                                    string_view message) FMT_NOEXCEPT {
2263    FMT_TRY {
2264      memory_buffer buf;
2265      buf.resize(inline_buffer_size);
2266      for (;;) {
2267        char* system_message = &buf[0];
2268        int result =
2269            detail::safe_strerror(error_code, system_message, buf.size());
2270        if (result == 0) {
2271          format_to(detail::buffer_appender<char>(out), "{}: {}", message,
2272                    system_message);
2273          return;
2274        }
2275        if (result != ERANGE)
2276          break;  
2277        buf.resize(buf.size() * 2);
2278      }
2279    }
2280    FMT_CATCH(...) {}
2281    format_error_code(out, error_code, message);
2282  }
2283  FMT_FUNC void detail::error_handler::on_error(const char* message) {
2284    FMT_THROW(format_error(message));
2285  }
2286  FMT_FUNC void report_system_error(int error_code,
2287                                    fmt::string_view message) FMT_NOEXCEPT {
2288    report_error(format_system_error, error_code, message);
2289  }
2290  FMT_FUNC std::string detail::vformat(string_view format_str, format_args args) {
2291    if (format_str.size() == 2 && equal2(format_str.data(), "{}")) {
2292      auto arg = args.get(0);
2293      if (!arg) error_handler().on_error("argument not found");
2294      return visit_format_arg(stringifier(), arg);
2295    }
2296    memory_buffer buffer;
2297    detail::vformat_to(buffer, format_str, args);
2298    return to_string(buffer);
2299  }
2300  #ifdef _WIN32
2301  namespace detail {
2302  using dword = conditional_t<sizeof(long) == 4, unsigned long, unsigned>;
2303  extern "C" __declspec(dllimport) int __stdcall WriteConsoleW(  
2304      void*, const void*, dword, dword*, void*);
2305  }  
2306  #endif
2307  FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
2308    memory_buffer buffer;
2309    detail::vformat_to(buffer, format_str,
2310                       basic_format_args<buffer_context<char>>(args));
2311  #ifdef _WIN32
2312    auto fd = _fileno(f);
2313    if (_isatty(fd)) {
2314      detail::utf8_to_utf16 u16(string_view(buffer.data(), buffer.size()));
2315      auto written = detail::dword();
2316      if (!detail::WriteConsoleW(reinterpret_cast<void*>(_get_osfhandle(fd)),
2317                                 u16.c_str(), static_cast<uint32_t>(u16.size()),
2318                                 &written, nullptr)) {
2319        FMT_THROW(format_error("failed to write to console"));
2320      }
2321      return;
2322    }
2323  #endif
2324    detail::fwrite_fully(buffer.data(), 1, buffer.size(), f);
2325  }
2326  #ifdef _WIN32
2327  FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
2328                                        format_args args) {
2329    memory_buffer buffer;
2330    detail::vformat_to(buffer, format_str,
2331                       basic_format_args<buffer_context<char>>(args));
2332    fwrite_fully(buffer.data(), 1, buffer.size(), f);
2333  }
2334  #endif
2335  FMT_FUNC void vprint(string_view format_str, format_args args) {
2336    vprint(stdout, format_str, args);
2337  }
2338  FMT_END_NAMESPACE
2339  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format-inl.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-format-inl.h</div>
                </div>
                <div class="column column_space"><pre><code>1714  FMT_ALWAYS_INLINE int remove_trailing_zeros(uint32_t& n) FMT_NOEXCEPT {
1715  #ifdef FMT_BUILTIN_CTZ
1716    int t = FMT_BUILTIN_CTZ(n);
1717  #else
1718    int t = ctz(n);
1719  #endif
1720    if (t > float_info<float>::max_trailing_zeros)
</pre></code></div>
                <div class="column column_space"><pre><code>1738  FMT_ALWAYS_INLINE int remove_trailing_zeros(uint64_t& n) FMT_NOEXCEPT {
1739  #ifdef FMT_BUILTIN_CTZLL
1740    int t = FMT_BUILTIN_CTZLL(n);
1741  #else
1742    int t = ctzll(n);
1743  #endif
1744    if (t > float_info<double>::max_trailing_zeros)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    