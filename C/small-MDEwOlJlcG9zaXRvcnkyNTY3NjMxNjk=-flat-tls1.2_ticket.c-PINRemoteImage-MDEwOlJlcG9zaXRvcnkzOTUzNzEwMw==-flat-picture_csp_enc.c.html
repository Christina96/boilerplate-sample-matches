
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.001044932079415%, Tokens: 8</h2>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-tls1.2_ticket.c</h3>
            <pre><code>1  #include "tls1.2_ticket.h"
2  #include "list.c"
3  typedef struct tls12_ticket_auth_global_data {
4      uint8_t local_client_id[32];
5      List client_data;
6      time_t startup_time;
7  }tls12_ticket_auth_global_data;
8  typedef struct tls12_ticket_auth_local_data {
9      int handshake_status;
10      char *send_buffer;
11      int send_buffer_size;
12      char *recv_buffer;
13      int recv_buffer_size;
14  }tls12_ticket_auth_local_data;
15  void tls12_ticket_auth_local_data_init(tls12_ticket_auth_local_data* local) {
16      local->handshake_status = 0;
17      local->send_buffer = malloc(0);
18      local->send_buffer_size = 0;
19      local->recv_buffer = malloc(0);
20      local->recv_buffer_size = 0;
21  }
22  void * tls12_ticket_auth_init_data() {
23      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)malloc(sizeof(tls12_ticket_auth_global_data));
24      rand_bytes(global->local_client_id, 32);
25      global->client_data = list_init(22);
26      global->startup_time = time(NULL);
27      return global;
28  }
29  obfs * tls12_ticket_auth_new_obfs() {
30      obfs * self = new_obfs();
31      self->l_data = malloc(sizeof(tls12_ticket_auth_local_data));
32      tls12_ticket_auth_local_data_init((tls12_ticket_auth_local_data*)self->l_data);
33      return self;
34  }
35  void tls12_ticket_auth_dispose(obfs *self) {
36      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
37      if (local->send_buffer != NULL) {
38          free(local->send_buffer);
39          local->send_buffer = NULL;
40      }
41      if (local->recv_buffer != NULL) {
42          free(local->recv_buffer);
43          local->recv_buffer = NULL;
44      }
45      free(local);
46      dispose_obfs(self);
47  }
48  int tls12_ticket_pack_auth_data(tls12_ticket_auth_global_data *global, server_info *server, char *outdata) {
49      int out_size = 32;
50      time_t t = time(NULL);
51      outdata[0] = t >> 24;
52      outdata[1] = t >> 16;
53      outdata[2] = t >> 8;
54      outdata[3] = t;
55      rand_bytes((uint8_t*)outdata + 4, 18);
56      uint8_t *key = (uint8_t*)malloc(server->key_len + 32);
57      char hash[ONETIMEAUTH_BYTES * 2];
58      memcpy(key, server->key, server->key_len);
59      memcpy(key + server->key_len, global->local_client_id, 32);
60      ss_sha1_hmac_with_key(hash, outdata, out_size - OBFS_HMAC_SHA1_LEN, key, server->key_len + 32);
61      free(key);
62      memcpy(outdata + out_size - OBFS_HMAC_SHA1_LEN, hash, OBFS_HMAC_SHA1_LEN);
63      return out_size;
64  }
65  void tls12_ticket_auth_pack_data(char *encryptdata, int datalength, int start, int len, char *out_buffer, int outlength) {
66      out_buffer[outlength] = 0x17;
67      out_buffer[outlength + 1] = 0x3;
68      out_buffer[outlength + 2] = 0x3;
69      out_buffer[outlength + 3] = len >> 8;
70      out_buffer[outlength + 4] = len;
71      memcpy(out_buffer + outlength + 5, encryptdata + start, len);
72  }
73  int tls12_ticket_auth_client_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
74      char *encryptdata = *pencryptdata;
75      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
76      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
77      char * out_buffer = NULL;
78      if (local->handshake_status == 8) {
79          if (datalength < 1024) {
80              if (*capacity < datalength + 5) {
81                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + 5) * 2);
82                  encryptdata = *pencryptdata;
83              }
84              memmove(encryptdata + 5, encryptdata, datalength);
85              encryptdata[0] = 0x17;
86              encryptdata[1] = 0x3;
87              encryptdata[2] = 0x3;
88              encryptdata[3] = datalength >> 8;
89              encryptdata[4] = datalength;
90              return datalength + 5;
91          } else {
92              out_buffer = (char*)malloc(datalength + 2048);
93              int start = 0;
94              int outlength = 0;
95              int len;
96              while (datalength - start > 2048) {
97                  len = xorshift128plus() % 4096 + 100;
98                  if (len > datalength - start)
99                      len = datalength - start;
100                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
101                  outlength += len + 5;
102                  start += len;
103              }
104              if (datalength - start > 0) {
105                  len = datalength - start;
106                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
107                  outlength += len + 5;
108              }
109              if (*capacity < outlength) {
110                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
111                  encryptdata = *pencryptdata;
112              }
113              memcpy(encryptdata, out_buffer, outlength);
114              free(out_buffer);
115              return outlength;
116          }
117      }
118      local->send_buffer = (char*)realloc(local->send_buffer, local->send_buffer_size + datalength + 5);
119      memcpy(local->send_buffer + local->send_buffer_size + 5, encryptdata, datalength);
120      local->send_buffer[local->send_buffer_size] = 0x17;
121      local->send_buffer[local->send_buffer_size + 1] = 0x3;
122      local->send_buffer[local->send_buffer_size + 2] = 0x3;
123      local->send_buffer[local->send_buffer_size + 3] = datalength >> 8;
124      local->send_buffer[local->send_buffer_size + 4] = datalength;
125      local->send_buffer_size += datalength + 5;
126      if (local->handshake_status == 0) {
127  #define CSTR_DECL(name, len, str) const char* name = str; const int len = sizeof(str) - 1;
128          CSTR_DECL(tls_data0, tls_data0_len, "\x00\x1c\xc0\x2b\xc0\x2f\xcc\xa9\xcc\xa8\xcc\x14\xcc\x13\xc0\x0a\xc0\x14\xc0\x09\xc0\x13\x00\x9c\x00\x35\x00\x2f\x00\x0a\x01\x00"
129                  );
130          CSTR_DECL(tls_data1, tls_data1_len, "\xff\x01\x00\x01\x00"
131                  );
132          CSTR_DECL(tls_data2, tls_data2_len, "\x00\x17\x00\x00\x00\x23\x00\xd0");
133          CSTR_DECL(tls_data3, tls_data3_len, "\x00\x0d\x00\x16\x00\x14\x06\x01\x06\x03\x05\x01\x05\x03\x04\x01\x04\x03\x03\x01\x03\x03\x02\x01\x02\x03\x00\x05\x00\x05\x01\x00\x00\x00\x00\x00\x12\x00\x00\x75\x50\x00\x00\x00\x0b\x00\x02\x01\x00\x00\x0a\x00\x06\x00\x04\x00\x17\x00\x18"
134                  );
135          uint8_t tls_data[2048];
136          int tls_data_len = 0;
137          memcpy(tls_data, tls_data1, tls_data1_len);
138          tls_data_len += tls_data1_len;
139          char hosts[1024];
140          char * phost[128];
141          int host_num = 0;
142          int pos;
143          char sni[256] = {0};
144          if (self->server.param && strlen(self->server.param) == 0)
145              self->server.param = NULL;
146          strncpy(hosts, self->server.param ? self->server.param : self->server.host, sizeof hosts);
147          phost[host_num++] = hosts;
148          for (pos = 0; hosts[pos]; ++pos) {
149              if (hosts[pos] == ',') {
150                  phost[host_num++] = &hosts[pos + 1];
151              }
152          }
153          host_num = xorshift128plus() % host_num;
154          sprintf(sni, "%s", phost[host_num]);
155          int sni_len = strlen(sni);
156          if (sni_len > 0 && sni[sni_len - 1] >= '0' && sni[sni_len - 1] <= '9')
157              sni_len = 0;
158          tls_data[tls_data_len] = '\0';
159          tls_data[tls_data_len + 1] = '\0';
160          tls_data[tls_data_len + 2] = (sni_len + 5) >> 8;
161          tls_data[tls_data_len + 3] = (sni_len + 5);
162          tls_data[tls_data_len + 4] = (sni_len + 3) >> 8;
163          tls_data[tls_data_len + 5] = (sni_len + 3);
164          tls_data[tls_data_len + 6] = '\0';
165          tls_data[tls_data_len + 7] = sni_len >> 8;
166          tls_data[tls_data_len + 8] = sni_len;
167          memcpy(tls_data + tls_data_len + 9, sni, sni_len);
168          tls_data_len += 9 + sni_len;
169          memcpy(tls_data + tls_data_len, tls_data2, tls_data2_len);
170          tls_data_len += tls_data2_len;
171          rand_bytes(tls_data + tls_data_len, 208);
172          tls_data_len += 208;
173          memcpy(tls_data + tls_data_len, tls_data3, tls_data3_len);
174          tls_data_len += tls_data3_len;
175          datalength = 11 + 32 + 1 + 32 + tls_data0_len + 2 + tls_data_len;
176          out_buffer = (char*)malloc(datalength);
177          char *pdata = out_buffer + datalength - tls_data_len;
178          int len = tls_data_len;
179          memcpy(pdata, tls_data, tls_data_len);
180          pdata[-1] = tls_data_len;
181          pdata[-2] = tls_data_len >> 8;
182          pdata -= 2; len += 2;
183          memcpy(pdata - tls_data0_len, tls_data0, tls_data0_len);
184          pdata -= tls_data0_len; len += tls_data0_len;
185          memcpy(pdata - 32, global->local_client_id, 32);
186          pdata -= 32; len += 32;
187          pdata[-1] = 0x20;
188          pdata -= 1; len += 1;
189          tls12_ticket_pack_auth_data(global, &self->server, pdata - 32);
190          pdata -= 32; len += 32;
191          pdata[-1] = 0x3;
192          pdata[-2] = 0x3; 
193          pdata -= 2; len += 2;
194          pdata[-1] = len;
195          pdata[-2] = len >> 8;
196          pdata[-3] = 0;
197          pdata[-4] = 1;
198          pdata -= 4; len += 4;
199          pdata[-1] = len;
200          pdata[-2] = len >> 8;
201          pdata -= 2; len += 2;
202          pdata[-1] = 0x1;
203          pdata[-2] = 0x3; 
204          pdata -= 2; len += 2;
205          pdata[-1] = 0x16; 
206          pdata -= 1; len += 1;
207          local->handshake_status = 1;
208      } else if (datalength == 0) {
209          datalength = local->send_buffer_size + 43;
210          out_buffer = (char*)malloc(datalength);
211          char *pdata = out_buffer;
212          memcpy(pdata, "\x14\x03\x03\x00\x01\x01", 6);
213          pdata += 6;
214          memcpy(pdata, "\x16\x03\x03\x00\x20", 5);
215          pdata += 5;
216          rand_bytes((uint8_t*)pdata, 22);
217          pdata += 22;
218          uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
219          char hash[ONETIMEAUTH_BYTES * 2];
220          memcpy(key, self->server.key, self->server.key_len);
221          memcpy(key + self->server.key_len, global->local_client_id, 32);
222          ss_sha1_hmac_with_key(hash, out_buffer, pdata - out_buffer, key, self->server.key_len + 32);
223          free(key);
224          memcpy(pdata, hash, OBFS_HMAC_SHA1_LEN);
225          pdata += OBFS_HMAC_SHA1_LEN;
226          memcpy(pdata, local->send_buffer, local->send_buffer_size);
227          free(local->send_buffer);
228          local->send_buffer = NULL;
229          local->handshake_status = 8;
230      } else {
231          return 0;
232      }
233      if (*capacity < datalength) {
234          *pencryptdata = (char*)realloc(*pencryptdata, *capacity = datalength * 2);
235          encryptdata = *pencryptdata;
236      }
237      memmove(encryptdata, out_buffer, datalength);
238      free(out_buffer);
239      return datalength;
240  }
241  int tls12_ticket_auth_server_encode(obfs *self, char **pencryptdata, int datalength, size_t* capacity) {
242      char *encryptdata = *pencryptdata;
243      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
244      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
245      char * out_buffer = NULL;
246      if (local->handshake_status == 8) {
247          if (datalength < 1024) {
248              if (*capacity < datalength + 5) {
249                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + 5) * 2);
250                  encryptdata = *pencryptdata;
251              }
252              memmove(encryptdata + 5, encryptdata, datalength);
253              encryptdata[0] = 0x17;
254              encryptdata[1] = 0x3;
255              encryptdata[2] = 0x3;
256              encryptdata[3] = datalength >> 8;
257              encryptdata[4] = datalength;
258              return datalength + 5;
259          } else {
260              out_buffer = (char*)malloc(datalength + 2048);
261              int start = 0;
262              int outlength = 0;
263              int len;
264              while (datalength - start > 2048) {
265                  len = xorshift128plus() % 4096 + 100;
266                  if (len > datalength - start)
<span onclick='openModal()' class='match'>267                      len = datalength - start;
268                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
269                  outlength += len + 5;
270                  start += len;
271              }
272              if (datalength - start > 0) {
273                  len = datalength - start;
274                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
275                  outlength += len + 5;
</span>276              }
277              if (*capacity < outlength) {
278                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = outlength * 2);
279                  encryptdata = *pencryptdata;
280              }
281              memcpy(encryptdata, out_buffer, outlength);
282              free(out_buffer);
283              return outlength;
284          }
285      }
286      local->handshake_status = 3;
287      out_buffer = (char*)malloc(43 + 86);
288      int data_len = 0;
289      char *p_data = out_buffer + 86;
290      memcpy(p_data - 10, "\xc0\x2f\x00\x00\x05\xff\x01\x00\x01\x00", 10);
291      p_data -= 10;data_len += 10;
292      memcpy(p_data - 32, global->local_client_id, 32);
293      p_data -= 32;data_len += 32;
294      p_data[-1] = 0x20;
295      p_data -= 1;data_len += 1;
296      tls12_ticket_pack_auth_data(global, &self->server, p_data - 32);
297      p_data -= 32;data_len += 32;
298      p_data[-1] = 0x3;
299      p_data[-2] = 0x3; 
300      p_data -= 2;data_len += 2;
301      p_data[-1] = data_len;
302      p_data[-2] = data_len >> 8;
303      p_data[-3] = 0x00;
304      p_data[-4] = 0x02;
305      p_data -= 4; data_len += 4;
306      p_data[-1] = data_len;
307      p_data[-2] = data_len >> 8;
308      p_data[-3] = 0x03;
309      p_data[-4] = 0x03;
310      p_data[-5] = 0x16;
311      p_data -= 5; data_len += 5;
312      memcpy(out_buffer, p_data, data_len);
313      char *pdata = out_buffer + 86;
314      memcpy(pdata, "\x14\x03\x03\x00\x01\x01", 6);
315      pdata += 6;
316      memcpy(pdata, "\x16\x03\x03\x00\x20", 5);
317      pdata += 5;
318      rand_bytes((uint8_t*)pdata, 22);
319      pdata += 22;
320      uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
321      char hash[ONETIMEAUTH_BYTES * 2];
322      memcpy(key, self->server.key, self->server.key_len);
323      memcpy(key + self->server.key_len, global->local_client_id, 32);
324      ss_sha1_hmac_with_key(hash, out_buffer, 43 + 86, key, self->server.key_len + 32);
325      free(key);
326      memcpy(pdata, hash, OBFS_HMAC_SHA1_LEN);
327      memmove(encryptdata, out_buffer, 43 + 86);
328      free(out_buffer);
329      return 43 + 86;
330  }
331  int tls12_ticket_auth_client_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
332      char *encryptdata = *pencryptdata;
333      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
334      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
335      *needsendback = 0;
336      if (local->handshake_status == 8) {
337          local->recv_buffer_size += datalength;
338          local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size);
339          memcpy(local->recv_buffer + local->recv_buffer_size - datalength, encryptdata, datalength);
340          datalength = 0;
341          while (local->recv_buffer_size > 5) {
342              if (local->recv_buffer[0] != 0x17)
343                  return -1;
344              int size = ((int)(unsigned char)local->recv_buffer[3] << 8) + (unsigned char)local->recv_buffer[4];
345              if (size + 5 > local->recv_buffer_size)
346                  break;
347              if (*capacity < datalength + size) {
348                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (datalength + size) * 2);
349                  encryptdata = *pencryptdata;
350              }
351              memcpy(encryptdata + datalength, local->recv_buffer + 5, size);
352              datalength += size;
353              local->recv_buffer_size -= 5 + size;
354              memmove(local->recv_buffer, local->recv_buffer + 5 + size, local->recv_buffer_size);
355          }
356          return datalength;
357      }
358      if (datalength < 11 + 32 + 1 + 32) {
359          return -1;
360      }
361      uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
362      char hash[ONETIMEAUTH_BYTES * 2];
363      memcpy(key, self->server.key, self->server.key_len);
364      memcpy(key + self->server.key_len, global->local_client_id, 32);
365      ss_sha1_hmac_with_key(hash, encryptdata + 11, 22, key, self->server.key_len + 32);
366      free(key);
367      if (memcmp(encryptdata + 33, hash, OBFS_HMAC_SHA1_LEN)) {
368          return -1;
369      }
370      *needsendback = 1;
371      return 0;
372  }
373  int tls12_ticket_auth_server_decode(obfs *self, char **pencryptdata, int datalength, size_t* capacity, int *needsendback) {
374      char *encryptdata = *pencryptdata;
375      tls12_ticket_auth_local_data *local = (tls12_ticket_auth_local_data*)self->l_data;
376      tls12_ticket_auth_global_data *global = (tls12_ticket_auth_global_data*)self->server.g_data;
377      *needsendback = 0;
378      if (local->handshake_status == 8) {
379          if(datalength != 0)
380          {
381              local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size + datalength);
382              memmove(local->recv_buffer + local->recv_buffer_size, encryptdata, datalength);
383              local->recv_buffer_size += datalength;
384          }
385          datalength = 0;
386          while (local->recv_buffer_size > 5) {
387              if (local->recv_buffer[0] != 0x17 || local->recv_buffer[1] != 0x03 || local->recv_buffer[2] != 0x03)
388              {
389                  LOGE("server_decode data error, wrong tls version 3");
390                  return -1;
391              }
392              int size = ((int)(unsigned char)local->recv_buffer[3] << 8) + (unsigned char)local->recv_buffer[4];
393              if (size + 5 > local->recv_buffer_size)
394                  break;
395              if (*capacity < local->recv_buffer_size + size) {
396                  *pencryptdata = (char*)realloc(*pencryptdata, *capacity = (local->recv_buffer_size + size) * 2);
397                  encryptdata = *pencryptdata;
398              }
399              memcpy(encryptdata + datalength, local->recv_buffer + 5, size);
400              datalength += size;
401              local->recv_buffer_size -= 5 + size;
402              memmove(local->recv_buffer, local->recv_buffer + 5 + size, local->recv_buffer_size);
403          }
404          return datalength;
405      }
406      if (local->handshake_status == 3) {
407          char *verify = encryptdata;
408          if(datalength < 43)
409          {
410              LOGE("server_decode data error, too short:%d", (int)datalength);
411              return -1;
412          }
413          if(encryptdata[0] != 0x14 || encryptdata[1] != 0x03 || encryptdata[2] != 0x03 || encryptdata[3] != 0x00 || encryptdata[4] != 0x01 || encryptdata[5] != 0x01)
414          {
415              LOGE("server_decode data error, wrong tls version");
416              return -1;
417          }
418          encryptdata += 6;
419          if(encryptdata[0] != 0x16 || encryptdata[1] != 0x03 || encryptdata[2] != 0x03 || encryptdata[3] != 0x00 || encryptdata[4] != 0x20)
420          {
421              LOGE("server_decode data error, wrong tls version 2");
422              return -1;
423          }
424          uint8_t *key = (uint8_t*)malloc(self->server.key_len + 32);
425          char hash[ONETIMEAUTH_BYTES * 2];
426          memcpy(key, self->server.key, self->server.key_len);
427          memcpy(key + self->server.key_len, global->local_client_id, 32);
428          ss_sha1_hmac_with_key(hash, verify, 33, key, self->server.key_len + 32);
429          free(key);
430          if (memcmp(verify + 33, hash, OBFS_HMAC_SHA1_LEN) != 0) {
431              LOGE("server_decode data error, hash Mismatch %d",(int)memcmp(verify + 33, hash, OBFS_HMAC_SHA1_LEN));
432              return -1;
433          }
434          local->recv_buffer_size = datalength - 43;
435          local->recv_buffer = (char*)realloc(local->recv_buffer, local->recv_buffer_size);
436          memmove(local->recv_buffer, encryptdata + 37, datalength - 43);
437          local->handshake_status = 8;
438          return tls12_ticket_auth_server_decode(self, pencryptdata, 0, capacity, needsendback);
439      }
440      local->handshake_status = 2;
441      if(encryptdata[0] != 0x16 || encryptdata[1] != 0x03 || encryptdata[2] != 0x01)
442      {
443          return -1;
444      }
445      encryptdata += 3;
446      {
447          int size = ((int)(unsigned char)encryptdata[0] << 8) + (unsigned char)encryptdata[1];
448          if(size != datalength - 5)
449          {
450              LOGE("tls_auth wrong tls head size");
451              return -1;
452          }
453      }
454      encryptdata += 2;
455      if(encryptdata[0] != 0x01 || encryptdata[1] != 0x00)
456      {
457          LOGE("tls_auth not client hello message");
458          return -1;
459      }
460      encryptdata += 2;
461      {
462          int size = ((int)(unsigned char)encryptdata[0] << 8) + (unsigned char)encryptdata[1];
463          if(size != datalength - 9)
464          {
465              LOGE("tls_auth wrong message size");
466              return -1;
467          }
468      }
469      encryptdata += 2;
470      if(encryptdata[0] != 0x03 || encryptdata[1] != 0x03)
471      {
472          LOGE("tls_auth wrong tls version");
473          return -1;
474      }
475      encryptdata += 2;
476      char *verifyid = encryptdata;
477      encryptdata += 32;
478      int sessionid_len = encryptdata[0];
479      if(sessionid_len < 32)
480      {
481          LOGE("tls_auth wrong sessionid_len");
482          return -1;
483      }
484      char *sessionid = encryptdata + 1;
485      memcpy(global->local_client_id , sessionid, sessionid_len);
486      uint8_t *key = (uint8_t*)malloc(self->server.key_len + sessionid_len);
487      char hash[ONETIMEAUTH_BYTES * 2];
488      memcpy(key, self->server.key, self->server.key_len);
489      memcpy(key + self->server.key_len, global->local_client_id, sessionid_len);
490      ss_sha1_hmac_with_key(hash, verifyid, 22, key, self->server.key_len + sessionid_len);
491      free(key);
492      encryptdata += (sessionid_len + 1);
493      long utc_time = ((int)(unsigned char)verifyid[0] << 24) + ((int)(unsigned char)verifyid[1] << 16) + ((int)(unsigned char)verifyid[2] << 8) + (unsigned char)verifyid[3];
494      time_t t = time(NULL);
495      if (self->server.param && strlen(self->server.param) == 0)
496      {
497          self->server.param = NULL;
498      }
499      int max_time_dif = 0;
500      int time_dif = utc_time - t;
501      if(self->server.param)
502      {
503          max_time_dif = atoi(self->server.param);
504      }
505      if(max_time_dif > 0 && (time_dif < -max_time_dif || time_dif > max_time_dif || utc_time - global->startup_time < -max_time_dif / 2))
506      {
507          LOGE("tls_auth wrong time");
508          return -1;
509      }
510      if (memcmp(verifyid + 22, hash, OBFS_HMAC_SHA1_LEN)) {
511          LOGE("tls_auth wrong sha1");
512          return -1;
513      }
514      int search_result = global->client_data->have_same_cmp(global->client_data, verifyid);
515      if(search_result != 0)
516      {
517          LOGE("replay attack detect!");
518          return -1;
519      }
520      global->client_data->add_back(global->client_data, verifyid);
521      encryptdata += 48;
522      *needsendback = 1;
523      return 0;
524  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_csp_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <math.h>
4  #include "src/enc/vp8i_enc.h"
5  #include "src/utils/random_utils.h"
6  #include "src/utils/utils.h"
7  #include "src/dsp/dsp.h"
8  #include "src/dsp/lossless.h"
9  #include "src/dsp/yuv.h"
10  #define USE_GAMMA_COMPRESSION
11  #define USE_INVERSE_ALPHA_TABLE
12  #ifdef WORDS_BIGENDIAN
13  #define CHANNEL_OFFSET(i) (i)
14  #else
15  #define CHANNEL_OFFSET(i) (3-(i))
16  #endif
17  #define ALPHA_OFFSET CHANNEL_OFFSET(0)
18  static int CheckNonOpaque(const uint8_t* alpha, int width, int height,
19                            int x_step, int y_step) {
20    if (alpha == NULL) return 0;
21    WebPInitAlphaProcessing();
22    if (x_step == 1) {
23      for (; height-- > 0; alpha += y_step) {
24        if (WebPHasAlpha8b(alpha, width)) return 1;
25      }
26    } else {
27      for (; height-- > 0; alpha += y_step) {
28        if (WebPHasAlpha32b(alpha, width)) return 1;
29      }
30    }
31    return 0;
32  }
33  int WebPPictureHasTransparency(const WebPPicture* picture) {
34    if (picture == NULL) return 0;
35    if (!picture->use_argb) {
36      return CheckNonOpaque(picture->a, picture->width, picture->height,
37                            1, picture->a_stride);
38    } else {
39      const int alpha_offset = ALPHA_OFFSET;
40      return CheckNonOpaque((const uint8_t*)picture->argb + alpha_offset,
41                            picture->width, picture->height,
42                            4, picture->argb_stride * sizeof(*picture->argb));
43    }
44    return 0;
45  }
46  #if defined(USE_GAMMA_COMPRESSION)
47  #define kGamma 0.80      
48  #define kGammaFix 12     
49  #define kGammaScale ((1 << kGammaFix) - 1)
50  #define kGammaTabFix 7   
51  #define kGammaTabScale (1 << kGammaTabFix)
52  #define kGammaTabRounder (kGammaTabScale >> 1)
53  #define kGammaTabSize (1 << (kGammaFix - kGammaTabFix))
54  static int kLinearToGammaTab[kGammaTabSize + 1];
55  static uint16_t kGammaToLinearTab[256];
56  static volatile int kGammaTablesOk = 0;
57  static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTables(void) {
58    if (!kGammaTablesOk) {
59      int v;
60      const double scale = (double)(1 << kGammaTabFix) / kGammaScale;
61      const double norm = 1. / 255.;
62      for (v = 0; v <= 255; ++v) {
63        kGammaToLinearTab[v] =
64            (uint16_t)(pow(norm * v, kGamma) * kGammaScale + .5);
65      }
66      for (v = 0; v <= kGammaTabSize; ++v) {
67        kLinearToGammaTab[v] = (int)(255. * pow(scale * v, 1. / kGamma) + .5);
68      }
69      kGammaTablesOk = 1;
70    }
71  }
72  static WEBP_INLINE uint32_t GammaToLinear(uint8_t v) {
73    return kGammaToLinearTab[v];
74  }
75  static WEBP_INLINE int Interpolate(int v) {
76    const int tab_pos = v >> (kGammaTabFix + 2);    
77    const int x = v & ((kGammaTabScale << 2) - 1);  
78    const int v0 = kLinearToGammaTab[tab_pos];
79    const int v1 = kLinearToGammaTab[tab_pos + 1];
80    const int y = v1 * x + v0 * ((kGammaTabScale << 2) - x);   
81    assert(tab_pos + 1 < kGammaTabSize + 1);
82    return y;
83  }
84  static WEBP_INLINE int LinearToGamma(uint32_t base_value, int shift) {
85    const int y = Interpolate(base_value << shift);   
86    return (y + kGammaTabRounder) >> kGammaTabFix;    
87  }
88  #else
89  static void InitGammaTables(void) {}
90  static WEBP_INLINE uint32_t GammaToLinear(uint8_t v) { return v; }
91  static WEBP_INLINE int LinearToGamma(uint32_t base_value, int shift) {
92    return (int)(base_value << shift);
93  }
94  #endif    
95  static int RGBToY(int r, int g, int b, VP8Random* const rg) {
96    return (rg == NULL) ? VP8RGBToY(r, g, b, YUV_HALF)
97                        : VP8RGBToY(r, g, b, VP8RandomBits(rg, YUV_FIX));
98  }
99  static int RGBToU(int r, int g, int b, VP8Random* const rg) {
100    return (rg == NULL) ? VP8RGBToU(r, g, b, YUV_HALF << 2)
101                        : VP8RGBToU(r, g, b, VP8RandomBits(rg, YUV_FIX + 2));
102  }
103  static int RGBToV(int r, int g, int b, VP8Random* const rg) {
104    return (rg == NULL) ? VP8RGBToV(r, g, b, YUV_HALF << 2)
105                        : VP8RGBToV(r, g, b, VP8RandomBits(rg, YUV_FIX + 2));
106  }
107  static const int kNumIterations = 4;
108  static const int kMinDimensionIterativeConversion = 4;
109  #define SFIX 2                
110  typedef int16_t fixed_t;      
111  typedef uint16_t fixed_y_t;   
112  #define SHALF (1 << SFIX >> 1)
113  #define MAX_Y_T ((256 << SFIX) - 1)
114  #define SROUNDER (1 << (YUV_FIX + SFIX - 1))
115  #if defined(USE_GAMMA_COMPRESSION)
116  #define kGammaF (1./0.45)
117  static uint32_t kLinearToGammaTabS[kGammaTabSize + 2];
118  #define GAMMA_TO_LINEAR_BITS 14
119  static uint32_t kGammaToLinearTabS[MAX_Y_T + 1];   
120  static volatile int kGammaTablesSOk = 0;
121  static WEBP_TSAN_IGNORE_FUNCTION void InitGammaTablesS(void) {
122    assert(2 * GAMMA_TO_LINEAR_BITS < 32);  
123    if (!kGammaTablesSOk) {
124      int v;
125      const double norm = 1. / MAX_Y_T;
126      const double scale = 1. / kGammaTabSize;
127      const double a = 0.09929682680944;
128      const double thresh = 0.018053968510807;
129      const double final_scale = 1 << GAMMA_TO_LINEAR_BITS;
130      for (v = 0; v <= MAX_Y_T; ++v) {
131        const double g = norm * v;
132        double value;
133        if (g <= thresh * 4.5) {
134          value = g / 4.5;
135        } else {
136          const double a_rec = 1. / (1. + a);
137          value = pow(a_rec * (g + a), kGammaF);
138        }
139        kGammaToLinearTabS[v] = (uint32_t)(value * final_scale + .5);
140      }
141      for (v = 0; v <= kGammaTabSize; ++v) {
142        const double g = scale * v;
143        double value;
144        if (g <= thresh) {
145          value = 4.5 * g;
146        } else {
147          value = (1. + a) * pow(g, 1. / kGammaF) - a;
148        }
149        kLinearToGammaTabS[v] =
150            (uint32_t)(MAX_Y_T * value) + (1 << GAMMA_TO_LINEAR_BITS >> 1);
151      }
152      kLinearToGammaTabS[kGammaTabSize + 1] = kLinearToGammaTabS[kGammaTabSize];
153      kGammaTablesSOk = 1;
154    }
155  }
156  static WEBP_INLINE uint32_t GammaToLinearS(int v) {
157    return kGammaToLinearTabS[v];
158  }
159  static WEBP_INLINE uint32_t LinearToGammaS(uint32_t value) {
160    const uint32_t v = value * kGammaTabSize;
161    const uint32_t tab_pos = v >> GAMMA_TO_LINEAR_BITS;
162    const uint32_t x = v - (tab_pos << GAMMA_TO_LINEAR_BITS);  
163    const uint32_t v0 = kLinearToGammaTabS[tab_pos + 0];
164    const uint32_t v1 = kLinearToGammaTabS[tab_pos + 1];
165    const uint32_t v2 = (v1 - v0) * x;    
166    const uint32_t result = v0 + (v2 >> GAMMA_TO_LINEAR_BITS);
167    return result;
168  }
169  #else
170  static void InitGammaTablesS(void) {}
171  static WEBP_INLINE uint32_t GammaToLinearS(int v) {
172    return (v << GAMMA_TO_LINEAR_BITS) / MAX_Y_T;
173  }
174  static WEBP_INLINE uint32_t LinearToGammaS(uint32_t value) {
175    return (MAX_Y_T * value) >> GAMMA_TO_LINEAR_BITS;
176  }
177  #endif    
178  static uint8_t clip_8b(fixed_t v) {
179    return (!(v & ~0xff)) ? (uint8_t)v : (v < 0) ? 0u : 255u;
180  }
181  static fixed_y_t clip_y(int y) {
182    return (!(y & ~MAX_Y_T)) ? (fixed_y_t)y : (y < 0) ? 0 : MAX_Y_T;
183  }
184  static int RGBToGray(int r, int g, int b) {
185    const int luma = 13933 * r + 46871 * g + 4732 * b + YUV_HALF;
186    return (luma >> YUV_FIX);
187  }
188  static uint32_t ScaleDown(int a, int b, int c, int d) {
189    const uint32_t A = GammaToLinearS(a);
190    const uint32_t B = GammaToLinearS(b);
191    const uint32_t C = GammaToLinearS(c);
192    const uint32_t D = GammaToLinearS(d);
193    return LinearToGammaS((A + B + C + D + 2) >> 2);
194  }
195  static WEBP_INLINE void UpdateW(const fixed_y_t* src, fixed_y_t* dst, int w) {
196    int i;
197    for (i = 0; i < w; ++i) {
198      const uint32_t R = GammaToLinearS(src[0 * w + i]);
199      const uint32_t G = GammaToLinearS(src[1 * w + i]);
200      const uint32_t B = GammaToLinearS(src[2 * w + i]);
201      const uint32_t Y = RGBToGray(R, G, B);
202      dst[i] = (fixed_y_t)LinearToGammaS(Y);
203    }
204  }
205  static void UpdateChroma(const fixed_y_t* src1, const fixed_y_t* src2,
206                           fixed_t* dst, int uv_w) {
207    int i;
208    for (i = 0; i < uv_w; ++i) {
209      const int r = ScaleDown(src1[0 * uv_w + 0], src1[0 * uv_w + 1],
210                              src2[0 * uv_w + 0], src2[0 * uv_w + 1]);
211      const int g = ScaleDown(src1[2 * uv_w + 0], src1[2 * uv_w + 1],
212                              src2[2 * uv_w + 0], src2[2 * uv_w + 1]);
213      const int b = ScaleDown(src1[4 * uv_w + 0], src1[4 * uv_w + 1],
214                              src2[4 * uv_w + 0], src2[4 * uv_w + 1]);
215      const int W = RGBToGray(r, g, b);
216      dst[0 * uv_w] = (fixed_t)(r - W);
217      dst[1 * uv_w] = (fixed_t)(g - W);
218      dst[2 * uv_w] = (fixed_t)(b - W);
219      dst  += 1;
220      src1 += 2;
221      src2 += 2;
222    }
223  }
224  static void StoreGray(const fixed_y_t* rgb, fixed_y_t* y, int w) {
225    int i;
226    for (i = 0; i < w; ++i) {
227      y[i] = RGBToGray(rgb[0 * w + i], rgb[1 * w + i], rgb[2 * w + i]);
228    }
229  }
230  static WEBP_INLINE fixed_y_t Filter2(int A, int B, int W0) {
231    const int v0 = (A * 3 + B + 2) >> 2;
232    return clip_y(v0 + W0);
233  }
234  static WEBP_INLINE fixed_y_t UpLift(uint8_t a) {  
235    return ((fixed_y_t)a << SFIX) | SHALF;
236  }
237  static void ImportOneRow(const uint8_t* const r_ptr,
238                           const uint8_t* const g_ptr,
239                           const uint8_t* const b_ptr,
240                           int step,
241                           int pic_width,
242                           fixed_y_t* const dst) {
243    int i;
244    const int w = (pic_width + 1) & ~1;
245    for (i = 0; i < pic_width; ++i) {
246      const int off = i * step;
247      dst[i + 0 * w] = UpLift(r_ptr[off]);
248      dst[i + 1 * w] = UpLift(g_ptr[off]);
249      dst[i + 2 * w] = UpLift(b_ptr[off]);
250    }
251    if (pic_width & 1) {  
252      dst[pic_width + 0 * w] = dst[pic_width + 0 * w - 1];
253      dst[pic_width + 1 * w] = dst[pic_width + 1 * w - 1];
254      dst[pic_width + 2 * w] = dst[pic_width + 2 * w - 1];
255    }
256  }
257  static void InterpolateTwoRows(const fixed_y_t* const best_y,
258                                 const fixed_t* prev_uv,
259                                 const fixed_t* cur_uv,
260                                 const fixed_t* next_uv,
261                                 int w,
262                                 fixed_y_t* out1,
263                                 fixed_y_t* out2) {
264    const int uv_w = w >> 1;
265    const int len = (w - 1) >> 1;   
266    int k = 3;
267    while (k-- > 0) {   
268      out1[0] = Filter2(cur_uv[0], prev_uv[0], best_y[0]);
269      out2[0] = Filter2(cur_uv[0], next_uv[0], best_y[w]);
270      WebPSharpYUVFilterRow(cur_uv, prev_uv, len, best_y + 0 + 1, out1 + 1);
271      WebPSharpYUVFilterRow(cur_uv, next_uv, len, best_y + w + 1, out2 + 1);
272      if (!(w & 1)) {
273        out1[w - 1] = Filter2(cur_uv[uv_w - 1], prev_uv[uv_w - 1],
274                              best_y[w - 1 + 0]);
275        out2[w - 1] = Filter2(cur_uv[uv_w - 1], next_uv[uv_w - 1],
276                              best_y[w - 1 + w]);
277      }
278      out1 += w;
279      out2 += w;
280      prev_uv += uv_w;
281      cur_uv  += uv_w;
282      next_uv += uv_w;
283    }
284  }
285  static WEBP_INLINE uint8_t ConvertRGBToY(int r, int g, int b) {
286    const int luma = 16839 * r + 33059 * g + 6420 * b + SROUNDER;
287    return clip_8b(16 + (luma >> (YUV_FIX + SFIX)));
288  }
289  static WEBP_INLINE uint8_t ConvertRGBToU(int r, int g, int b) {
290    const int u =  -9719 * r - 19081 * g + 28800 * b + SROUNDER;
291    return clip_8b(128 + (u >> (YUV_FIX + SFIX)));
292  }
293  static WEBP_INLINE uint8_t ConvertRGBToV(int r, int g, int b) {
294    const int v = +28800 * r - 24116 * g -  4684 * b + SROUNDER;
295    return clip_8b(128 + (v >> (YUV_FIX + SFIX)));
296  }
297  static int ConvertWRGBToYUV(const fixed_y_t* best_y, const fixed_t* best_uv,
298                              WebPPicture* const picture) {
299    int i, j;
300    uint8_t* dst_y = picture->y;
301    uint8_t* dst_u = picture->u;
302    uint8_t* dst_v = picture->v;
303    const fixed_t* const best_uv_base = best_uv;
304    const int w = (picture->width + 1) & ~1;
305    const int h = (picture->height + 1) & ~1;
306    const int uv_w = w >> 1;
307    const int uv_h = h >> 1;
308    for (best_uv = best_uv_base, j = 0; j < picture->height; ++j) {
309      for (i = 0; i < picture->width; ++i) {
310        const int off = (i >> 1);
311        const int W = best_y[i];
312        const int r = best_uv[off + 0 * uv_w] + W;
313        const int g = best_uv[off + 1 * uv_w] + W;
314        const int b = best_uv[off + 2 * uv_w] + W;
315        dst_y[i] = ConvertRGBToY(r, g, b);
316      }
317      best_y += w;
318      best_uv += (j & 1) * 3 * uv_w;
319      dst_y += picture->y_stride;
320    }
321    for (best_uv = best_uv_base, j = 0; j < uv_h; ++j) {
322      for (i = 0; i < uv_w; ++i) {
323        const int off = i;
324        const int r = best_uv[off + 0 * uv_w];
325        const int g = best_uv[off + 1 * uv_w];
326        const int b = best_uv[off + 2 * uv_w];
327        dst_u[i] = ConvertRGBToU(r, g, b);
328        dst_v[i] = ConvertRGBToV(r, g, b);
329      }
330      best_uv += 3 * uv_w;
331      dst_u += picture->uv_stride;
332      dst_v += picture->uv_stride;
333    }
334    return 1;
335  }
336  #define SAFE_ALLOC(W, H, T) ((T*)WebPSafeMalloc((W) * (H), sizeof(T)))
337  static int PreprocessARGB(const uint8_t* r_ptr,
338                            const uint8_t* g_ptr,
339                            const uint8_t* b_ptr,
340                            int step, int rgb_stride,
341                            WebPPicture* const picture) {
342    const int w = (picture->width + 1) & ~1;
343    const int h = (picture->height + 1) & ~1;
344    const int uv_w = w >> 1;
345    const int uv_h = h >> 1;
346    uint64_t prev_diff_y_sum = ~0;
347    int j, iter;
348    fixed_y_t* const tmp_buffer = SAFE_ALLOC(w * 3, 2, fixed_y_t);   
349    fixed_y_t* const best_y_base = SAFE_ALLOC(w, h, fixed_y_t);
350    fixed_y_t* const target_y_base = SAFE_ALLOC(w, h, fixed_y_t);
351    fixed_y_t* const best_rgb_y = SAFE_ALLOC(w, 2, fixed_y_t);
352    fixed_t* const best_uv_base = SAFE_ALLOC(uv_w * 3, uv_h, fixed_t);
353    fixed_t* const target_uv_base = SAFE_ALLOC(uv_w * 3, uv_h, fixed_t);
354    fixed_t* const best_rgb_uv = SAFE_ALLOC(uv_w * 3, 1, fixed_t);
355    fixed_y_t* best_y = best_y_base;
356    fixed_y_t* target_y = target_y_base;
357    fixed_t* best_uv = best_uv_base;
358    fixed_t* target_uv = target_uv_base;
359    const uint64_t diff_y_threshold = (uint64_t)(3.0 * w * h);
360    int ok;
361    if (best_y_base == NULL || best_uv_base == NULL ||
362        target_y_base == NULL || target_uv_base == NULL ||
363        best_rgb_y == NULL || best_rgb_uv == NULL ||
364        tmp_buffer == NULL) {
365      ok = WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
366      goto End;
367    }
368    assert(picture->width >= kMinDimensionIterativeConversion);
369    assert(picture->height >= kMinDimensionIterativeConversion);
370    WebPInitConvertARGBToYUV();
371    for (j = 0; j < picture->height; j += 2) {
372      const int is_last_row = (j == picture->height - 1);
373      fixed_y_t* const src1 = tmp_buffer + 0 * w;
374      fixed_y_t* const src2 = tmp_buffer + 3 * w;
375      ImportOneRow(r_ptr, g_ptr, b_ptr, step, picture->width, src1);
376      if (!is_last_row) {
377        ImportOneRow(r_ptr + rgb_stride, g_ptr + rgb_stride, b_ptr + rgb_stride,
378                     step, picture->width, src2);
379      } else {
380        memcpy(src2, src1, 3 * w * sizeof(*src2));
381      }
382      StoreGray(src1, best_y + 0, w);
383      StoreGray(src2, best_y + w, w);
384      UpdateW(src1, target_y, w);
385      UpdateW(src2, target_y + w, w);
386      UpdateChroma(src1, src2, target_uv, uv_w);
387      memcpy(best_uv, target_uv, 3 * uv_w * sizeof(*best_uv));
388      best_y += 2 * w;
389      best_uv += 3 * uv_w;
390      target_y += 2 * w;
391      target_uv += 3 * uv_w;
392      r_ptr += 2 * rgb_stride;
393      g_ptr += 2 * rgb_stride;
394      b_ptr += 2 * rgb_stride;
395    }
396    for (iter = 0; iter < kNumIterations; ++iter) {
397      const fixed_t* cur_uv = best_uv_base;
398      const fixed_t* prev_uv = best_uv_base;
399      uint64_t diff_y_sum = 0;
400      best_y = best_y_base;
401      best_uv = best_uv_base;
402      target_y = target_y_base;
403      target_uv = target_uv_base;
404      for (j = 0; j < h; j += 2) {
405        fixed_y_t* const src1 = tmp_buffer + 0 * w;
406        fixed_y_t* const src2 = tmp_buffer + 3 * w;
407        {
408          const fixed_t* const next_uv = cur_uv + ((j < h - 2) ? 3 * uv_w : 0);
409          InterpolateTwoRows(best_y, prev_uv, cur_uv, next_uv, w, src1, src2);
410          prev_uv = cur_uv;
411          cur_uv = next_uv;
412        }
413        UpdateW(src1, best_rgb_y + 0 * w, w);
414        UpdateW(src2, best_rgb_y + 1 * w, w);
415        UpdateChroma(src1, src2, best_rgb_uv, uv_w);
416        diff_y_sum += WebPSharpYUVUpdateY(target_y, best_rgb_y, best_y, 2 * w);
417        WebPSharpYUVUpdateRGB(target_uv, best_rgb_uv, best_uv, 3 * uv_w);
418        best_y += 2 * w;
419        best_uv += 3 * uv_w;
420        target_y += 2 * w;
421        target_uv += 3 * uv_w;
422      }
423      if (iter > 0) {
424        if (diff_y_sum < diff_y_threshold) break;
425        if (diff_y_sum > prev_diff_y_sum) break;
426      }
427      prev_diff_y_sum = diff_y_sum;
428    }
429    ok = ConvertWRGBToYUV(best_y_base, best_uv_base, picture);
430   End:
431    WebPSafeFree(best_y_base);
432    WebPSafeFree(best_uv_base);
433    WebPSafeFree(target_y_base);
434    WebPSafeFree(target_uv_base);
435    WebPSafeFree(best_rgb_y);
436    WebPSafeFree(best_rgb_uv);
437    WebPSafeFree(tmp_buffer);
438    return ok;
439  }
440  #undef SAFE_ALLOC
441  #define SUM4(ptr, step) LinearToGamma(                     \
442      GammaToLinear((ptr)[0]) +                              \
443      GammaToLinear((ptr)[(step)]) +                         \
444      GammaToLinear((ptr)[rgb_stride]) +                     \
445      GammaToLinear((ptr)[rgb_stride + (step)]), 0)          \
446  
447  #define SUM2(ptr) \
448      LinearToGamma(GammaToLinear((ptr)[0]) + GammaToLinear((ptr)[rgb_stride]), 1)
449  #define SUM2ALPHA(ptr) ((ptr)[0] + (ptr)[rgb_stride])
450  #define SUM4ALPHA(ptr) (SUM2ALPHA(ptr) + SUM2ALPHA((ptr) + 4))
451  #if defined(USE_INVERSE_ALPHA_TABLE)
452  static const int kAlphaFix = 19;
453  static const uint32_t kInvAlpha[4 * 0xff + 1] = {
454    0,  &bsol;* alpha = 0 */
455    524288, 262144, 174762, 131072, 104857, 87381, 74898, 65536,
456    58254, 52428, 47662, 43690, 40329, 37449, 34952, 32768,
457    30840, 29127, 27594, 26214, 24966, 23831, 22795, 21845,
458    20971, 20164, 19418, 18724, 18078, 17476, 16912, 16384,
459    15887, 15420, 14979, 14563, 14169, 13797, 13443, 13107,
460    12787, 12483, 12192, 11915, 11650, 11397, 11155, 10922,
461    10699, 10485, 10280, 10082, 9892, 9709, 9532, 9362,
462    9198, 9039, 8886, 8738, 8594, 8456, 8322, 8192,
463    8065, 7943, 7825, 7710, 7598, 7489, 7384, 7281,
464    7182, 7084, 6990, 6898, 6808, 6721, 6636, 6553,
465    6472, 6393, 6316, 6241, 6168, 6096, 6026, 5957,
466    5890, 5825, 5761, 5698, 5637, 5577, 5518, 5461,
467    5405, 5349, 5295, 5242, 5190, 5140, 5090, 5041,
468    4993, 4946, 4899, 4854, 4809, 4766, 4723, 4681,
469    4639, 4599, 4559, 4519, 4481, 4443, 4405, 4369,
470    4332, 4297, 4262, 4228, 4194, 4161, 4128, 4096,
471    4064, 4032, 4002, 3971, 3942, 3912, 3883, 3855,
472    3826, 3799, 3771, 3744, 3718, 3692, 3666, 3640,
473    3615, 3591, 3566, 3542, 3518, 3495, 3472, 3449,
474    3426, 3404, 3382, 3360, 3339, 3318, 3297, 3276,
475    3256, 3236, 3216, 3196, 3177, 3158, 3139, 3120,
476    3102, 3084, 3066, 3048, 3030, 3013, 2995, 2978,
477    2962, 2945, 2928, 2912, 2896, 2880, 2864, 2849,
478    2833, 2818, 2803, 2788, 2774, 2759, 2744, 2730,
479    2716, 2702, 2688, 2674, 2661, 2647, 2634, 2621,
480    2608, 2595, 2582, 2570, 2557, 2545, 2532, 2520,
481    2508, 2496, 2484, 2473, 2461, 2449, 2438, 2427,
482    2416, 2404, 2394, 2383, 2372, 2361, 2351, 2340,
483    2330, 2319, 2309, 2299, 2289, 2279, 2269, 2259,
484    2250, 2240, 2231, 2221, 2212, 2202, 2193, 2184,
485    2175, 2166, 2157, 2148, 2139, 2131, 2122, 2114,
486    2105, 2097, 2088, 2080, 2072, 2064, 2056, 2048,
487    2040, 2032, 2024, 2016, 2008, 2001, 1993, 1985,
488    1978, 1971, 1963, 1956, 1949, 1941, 1934, 1927,
489    1920, 1913, 1906, 1899, 1892, 1885, 1879, 1872,
490    1865, 1859, 1852, 1846, 1839, 1833, 1826, 1820,
491    1814, 1807, 1801, 1795, 1789, 1783, 1777, 1771,
492    1765, 1759, 1753, 1747, 1741, 1736, 1730, 1724,
493    1718, 1713, 1707, 1702, 1696, 1691, 1685, 1680,
494    1675, 1669, 1664, 1659, 1653, 1648, 1643, 1638,
495    1633, 1628, 1623, 1618, 1613, 1608, 1603, 1598,
496    1593, 1588, 1583, 1579, 1574, 1569, 1565, 1560,
497    1555, 1551, 1546, 1542, 1537, 1533, 1528, 1524,
498    1519, 1515, 1510, 1506, 1502, 1497, 1493, 1489,
499    1485, 1481, 1476, 1472, 1468, 1464, 1460, 1456,
500    1452, 1448, 1444, 1440, 1436, 1432, 1428, 1424,
501    1420, 1416, 1413, 1409, 1405, 1401, 1398, 1394,
502    1390, 1387, 1383, 1379, 1376, 1372, 1368, 1365,
503    1361, 1358, 1354, 1351, 1347, 1344, 1340, 1337,
504    1334, 1330, 1327, 1323, 1320, 1317, 1314, 1310,
505    1307, 1304, 1300, 1297, 1294, 1291, 1288, 1285,
506    1281, 1278, 1275, 1272, 1269, 1266, 1263, 1260,
507    1257, 1254, 1251, 1248, 1245, 1242, 1239, 1236,
508    1233, 1230, 1227, 1224, 1222, 1219, 1216, 1213,
509    1210, 1208, 1205, 1202, 1199, 1197, 1194, 1191,
510    1188, 1186, 1183, 1180, 1178, 1175, 1172, 1170,
511    1167, 1165, 1162, 1159, 1157, 1154, 1152, 1149,
512    1147, 1144, 1142, 1139, 1137, 1134, 1132, 1129,
513    1127, 1125, 1122, 1120, 1117, 1115, 1113, 1110,
514    1108, 1106, 1103, 1101, 1099, 1096, 1094, 1092,
515    1089, 1087, 1085, 1083, 1081, 1078, 1076, 1074,
516    1072, 1069, 1067, 1065, 1063, 1061, 1059, 1057,
517    1054, 1052, 1050, 1048, 1046, 1044, 1042, 1040,
518    1038, 1036, 1034, 1032, 1030, 1028, 1026, 1024,
519    1022, 1020, 1018, 1016, 1014, 1012, 1010, 1008,
520    1006, 1004, 1002, 1000, 998, 996, 994, 992,
521    991, 989, 987, 985, 983, 981, 979, 978,
522    976, 974, 972, 970, 969, 967, 965, 963,
523    961, 960, 958, 956, 954, 953, 951, 949,
524    948, 946, 944, 942, 941, 939, 937, 936,
525    934, 932, 931, 929, 927, 926, 924, 923,
526    921, 919, 918, 916, 914, 913, 911, 910,
527    908, 907, 905, 903, 902, 900, 899, 897,
528    896, 894, 893, 891, 890, 888, 887, 885,
529    884, 882, 881, 879, 878, 876, 875, 873,
530    872, 870, 869, 868, 866, 865, 863, 862,
531    860, 859, 858, 856, 855, 853, 852, 851,
532    849, 848, 846, 845, 844, 842, 841, 840,
533    838, 837, 836, 834, 833, 832, 830, 829,
534    828, 826, 825, 824, 823, 821, 820, 819,
535    817, 816, 815, 814, 812, 811, 810, 809,
536    807, 806, 805, 804, 802, 801, 800, 799,
537    798, 796, 795, 794, 793, 791, 790, 789,
538    788, 787, 786, 784, 783, 782, 781, 780,
539    779, 777, 776, 775, 774, 773, 772, 771,
540    769, 768, 767, 766, 765, 764, 763, 762,
541    760, 759, 758, 757, 756, 755, 754, 753,
542    752, 751, 750, 748, 747, 746, 745, 744,
543    743, 742, 741, 740, 739, 738, 737, 736,
544    735, 734, 733, 732, 731, 730, 729, 728,
545    727, 726, 725, 724, 723, 722, 721, 720,
546    719, 718, 717, 716, 715, 714, 713, 712,
547    711, 710, 709, 708, 707, 706, 705, 704,
548    703, 702, 701, 700, 699, 699, 698, 697,
549    696, 695, 694, 693, 692, 691, 690, 689,
550    688, 688, 687, 686, 685, 684, 683, 682,
551    681, 680, 680, 679, 678, 677, 676, 675,
552    674, 673, 673, 672, 671, 670, 669, 668,
553    667, 667, 666, 665, 664, 663, 662, 661,
554    661, 660, 659, 658, 657, 657, 656, 655,
555    654, 653, 652, 652, 651, 650, 649, 648,
556    648, 647, 646, 645, 644, 644, 643, 642,
557    641, 640, 640, 639, 638, 637, 637, 636,
558    635, 634, 633, 633, 632, 631, 630, 630,
559    629, 628, 627, 627, 626, 625, 624, 624,
560    623, 622, 621, 621, 620, 619, 618, 618,
561    617, 616, 616, 615, 614, 613, 613, 612,
562    611, 611, 610, 609, 608, 608, 607, 606,
563    606, 605, 604, 604, 603, 602, 601, 601,
564    600, 599, 599, 598, 597, 597, 596, 595,
565    595, 594, 593, 593, 592, 591, 591, 590,
566    589, 589, 588, 587, 587, 586, 585, 585,
567    584, 583, 583, 582, 581, 581, 580, 579,
568    579, 578, 578, 577, 576, 576, 575, 574,
569    574, 573, 572, 572, 571, 571, 570, 569,
570    569, 568, 568, 567, 566, 566, 565, 564,
571    564, 563, 563, 562, 561, 561, 560, 560,
572    559, 558, 558, 557, 557, 556, 555, 555,
573    554, 554, 553, 553, 552, 551, 551, 550,
574    550, 549, 548, 548, 547, 547, 546, 546,
575    545, 544, 544, 543, 543, 542, 542, 541,
576    541, 540, 539, 539, 538, 538, 537, 537,
577    536, 536, 535, 534, 534, 533, 533, 532,
578    532, 531, 531, 530, 530, 529, 529, 528,
579    527, 527, 526, 526, 525, 525, 524, 524,
580    523, 523, 522, 522, 521, 521, 520, 520,
581    519, 519, 518, 518, 517, 517, 516, 516,
582    515, 515, 514, 514
583  };
584  #define DIVIDE_BY_ALPHA(sum, a)  (((sum) * kInvAlpha[(a)]) >> (kAlphaFix - 2))
585  #else
586  #define DIVIDE_BY_ALPHA(sum, a) (4 * (sum) / (a))
587  #endif  
588  static WEBP_INLINE int LinearToGammaWeighted(const uint8_t* src,
589                                               const uint8_t* a_ptr,
590                                               uint32_t total_a, int step,
591                                               int rgb_stride) {
592    const uint32_t sum =
593        a_ptr[0] * GammaToLinear(src[0]) +
594        a_ptr[step] * GammaToLinear(src[step]) +
595        a_ptr[rgb_stride] * GammaToLinear(src[rgb_stride]) +
596        a_ptr[rgb_stride + step] * GammaToLinear(src[rgb_stride + step]);
597    assert(total_a > 0 && total_a <= 4 * 0xff);
598  #if defined(USE_INVERSE_ALPHA_TABLE)
599    assert((uint64_t)sum * kInvAlpha[total_a] < ((uint64_t)1 << 32));
600  #endif
601    return LinearToGamma(DIVIDE_BY_ALPHA(sum, total_a), 0);
602  }
603  static WEBP_INLINE void ConvertRowToY(const uint8_t* const r_ptr,
604                                        const uint8_t* const g_ptr,
605                                        const uint8_t* const b_ptr,
606                                        int step,
607                                        uint8_t* const dst_y,
608                                        int width,
609                                        VP8Random* const rg) {
610    int i, j;
611    for (i = 0, j = 0; i < width; i += 1, j += step) {
612      dst_y[i] = RGBToY(r_ptr[j], g_ptr[j], b_ptr[j], rg);
613    }
614  }
615  static WEBP_INLINE void AccumulateRGBA(const uint8_t* const r_ptr,
616                                         const uint8_t* const g_ptr,
617                                         const uint8_t* const b_ptr,
618                                         const uint8_t* const a_ptr,
619                                         int rgb_stride,
620                                         uint16_t* dst, int width) {
621    int i, j;
622    for (i = 0, j = 0; i < (width >> 1); i += 1, j += 2 * 4, dst += 4) {
623      const uint32_t a = SUM4ALPHA(a_ptr + j);
624      int r, g, b;
625      if (a == 4 * 0xff || a == 0) {
626        r = SUM4(r_ptr + j, 4);
627        g = SUM4(g_ptr + j, 4);
628        b = SUM4(b_ptr + j, 4);
629      } else {
630        r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 4, rgb_stride);
631        g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 4, rgb_stride);
632        b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 4, rgb_stride);
633      }
634      dst[0] = r;
635      dst[1] = g;
636      dst[2] = b;
637      dst[3] = a;
638    }
639    if (width & 1) {
640      const uint32_t a = 2u * SUM2ALPHA(a_ptr + j);
641      int r, g, b;
642      if (a == 4 * 0xff || a == 0) {
643        r = SUM2(r_ptr + j);
644        g = SUM2(g_ptr + j);
645        b = SUM2(b_ptr + j);
646      } else {
647        r = LinearToGammaWeighted(r_ptr + j, a_ptr + j, a, 0, rgb_stride);
648        g = LinearToGammaWeighted(g_ptr + j, a_ptr + j, a, 0, rgb_stride);
649        b = LinearToGammaWeighted(b_ptr + j, a_ptr + j, a, 0, rgb_stride);
650      }
651      dst[0] = r;
652      dst[1] = g;
653      dst[2] = b;
654      dst[3] = a;
655    }
656  }
657  static WEBP_INLINE void AccumulateRGB(const uint8_t* const r_ptr,
658                                        const uint8_t* const g_ptr,
659                                        const uint8_t* const b_ptr,
660                                        int step, int rgb_stride,
661                                        uint16_t* dst, int width) {
662    int i, j;
663    for (i = 0, j = 0; i < (width >> 1); i += 1, j += 2 * step, dst += 4) {
<span onclick='openModal()' class='match'>664      dst[0] = SUM4(r_ptr + j, step);
665      dst[1] = SUM4(g_ptr + j, step);
666      dst[2] = SUM4(b_ptr + j, step);
667    }
668    if (width & 1) {
669      dst[0] = SUM2(r_ptr + j);
670      dst[1] = SUM2(g_ptr + j);
</span>671      dst[2] = SUM2(b_ptr + j);
672    }
673  }
674  static WEBP_INLINE void ConvertRowsToUV(const uint16_t* rgb,
675                                          uint8_t* const dst_u,
676                                          uint8_t* const dst_v,
677                                          int width,
678                                          VP8Random* const rg) {
679    int i;
680    for (i = 0; i < width; i += 1, rgb += 4) {
681      const int r = rgb[0], g = rgb[1], b = rgb[2];
682      dst_u[i] = RGBToU(r, g, b, rg);
683      dst_v[i] = RGBToV(r, g, b, rg);
684    }
685  }
686  static int ImportYUVAFromRGBA(const uint8_t* r_ptr,
687                                const uint8_t* g_ptr,
688                                const uint8_t* b_ptr,
689                                const uint8_t* a_ptr,
690                                int step,         
691                                int rgb_stride,   
692                                float dithering,
693                                int use_iterative_conversion,
694                                WebPPicture* const picture) {
695    int y;
696    const int width = picture->width;
697    const int height = picture->height;
698    const int has_alpha = CheckNonOpaque(a_ptr, width, height, step, rgb_stride);
699    const int is_rgb = (r_ptr < b_ptr);  
700    picture->colorspace = has_alpha ? WEBP_YUV420A : WEBP_YUV420;
701    picture->use_argb = 0;
702    if (width < kMinDimensionIterativeConversion ||
703        height < kMinDimensionIterativeConversion) {
704      use_iterative_conversion = 0;
705    }
706    if (!WebPPictureAllocYUVA(picture, width, height)) {
707      return 0;
708    }
709    if (has_alpha) {
710      assert(step == 4);
711  #if defined(USE_GAMMA_COMPRESSION) && defined(USE_INVERSE_ALPHA_TABLE)
712      assert(kAlphaFix + kGammaFix <= 31);
713  #endif
714    }
715    if (use_iterative_conversion) {
716      InitGammaTablesS();
717      if (!PreprocessARGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, picture)) {
718        return 0;
719      }
720      if (has_alpha) {
721        WebPExtractAlpha(a_ptr, rgb_stride, width, height,
722                         picture->a, picture->a_stride);
723      }
724    } else {
725      const int uv_width = (width + 1) >> 1;
726      int use_dsp = (step == 3);  
727      uint16_t* const tmp_rgb =
728          (uint16_t*)WebPSafeMalloc(4 * uv_width, sizeof(*tmp_rgb));
729      uint8_t* dst_y = picture->y;
730      uint8_t* dst_u = picture->u;
731      uint8_t* dst_v = picture->v;
732      uint8_t* dst_a = picture->a;
733      VP8Random base_rg;
734      VP8Random* rg = NULL;
735      if (dithering > 0.) {
736        VP8InitRandom(&base_rg, dithering);
737        rg = &base_rg;
738        use_dsp = 0;   
739      }
740      WebPInitConvertARGBToYUV();
741      InitGammaTables();
742      if (tmp_rgb == NULL) return 0;  
743      for (y = 0; y < (height >> 1); ++y) {
744        int rows_have_alpha = has_alpha;
745        if (use_dsp) {
746          if (is_rgb) {
747            WebPConvertRGB24ToY(r_ptr, dst_y, width);
748            WebPConvertRGB24ToY(r_ptr + rgb_stride,
749                                dst_y + picture->y_stride, width);
750          } else {
751            WebPConvertBGR24ToY(b_ptr, dst_y, width);
752            WebPConvertBGR24ToY(b_ptr + rgb_stride,
753                                dst_y + picture->y_stride, width);
754          }
755        } else {
756          ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
757          ConvertRowToY(r_ptr + rgb_stride,
758                        g_ptr + rgb_stride,
759                        b_ptr + rgb_stride, step,
760                        dst_y + picture->y_stride, width, rg);
761        }
762        dst_y += 2 * picture->y_stride;
763        if (has_alpha) {
764          rows_have_alpha &= !WebPExtractAlpha(a_ptr, rgb_stride, width, 2,
765                                               dst_a, picture->a_stride);
766          dst_a += 2 * picture->a_stride;
767        }
768        if (!rows_have_alpha) {
769          AccumulateRGB(r_ptr, g_ptr, b_ptr, step, rgb_stride, tmp_rgb, width);
770        } else {
771          AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, rgb_stride, tmp_rgb, width);
772        }
773        if (rg == NULL) {
774          WebPConvertRGBA32ToUV(tmp_rgb, dst_u, dst_v, uv_width);
775        } else {
776          ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
777        }
778        dst_u += picture->uv_stride;
779        dst_v += picture->uv_stride;
780        r_ptr += 2 * rgb_stride;
781        b_ptr += 2 * rgb_stride;
782        g_ptr += 2 * rgb_stride;
783        if (has_alpha) a_ptr += 2 * rgb_stride;
784      }
785      if (height & 1) {    
786        int row_has_alpha = has_alpha;
787        if (use_dsp) {
788          if (r_ptr < b_ptr) {
789            WebPConvertRGB24ToY(r_ptr, dst_y, width);
790          } else {
791            WebPConvertBGR24ToY(b_ptr, dst_y, width);
792          }
793        } else {
794          ConvertRowToY(r_ptr, g_ptr, b_ptr, step, dst_y, width, rg);
795        }
796        if (row_has_alpha) {
797          row_has_alpha &= !WebPExtractAlpha(a_ptr, 0, width, 1, dst_a, 0);
798        }
799        if (!row_has_alpha) {
800          AccumulateRGB(r_ptr, g_ptr, b_ptr, step, &bsol;* rgb_stride = */ 0,
801                        tmp_rgb, width);
802        } else {
803          AccumulateRGBA(r_ptr, g_ptr, b_ptr, a_ptr, &bsol;* rgb_stride = */ 0,
804                         tmp_rgb, width);
805        }
806        if (rg == NULL) {
807          WebPConvertRGBA32ToUV(tmp_rgb, dst_u, dst_v, uv_width);
808        } else {
809          ConvertRowsToUV(tmp_rgb, dst_u, dst_v, uv_width, rg);
810        }
811      }
812      WebPSafeFree(tmp_rgb);
813    }
814    return 1;
815  }
816  #undef SUM4
817  #undef SUM2
818  #undef SUM4ALPHA
819  #undef SUM2ALPHA
820  static int PictureARGBToYUVA(WebPPicture* picture, WebPEncCSP colorspace,
821                               float dithering, int use_iterative_conversion) {
822    if (picture == NULL) return 0;
823    if (picture->argb == NULL) {
824      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
825    } else if ((colorspace & WEBP_CSP_UV_MASK) != WEBP_YUV420) {
826      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
827    } else {
828      const uint8_t* const argb = (const uint8_t*)picture->argb;
829      const uint8_t* const a = argb + CHANNEL_OFFSET(0);
830      const uint8_t* const r = argb + CHANNEL_OFFSET(1);
831      const uint8_t* const g = argb + CHANNEL_OFFSET(2);
832      const uint8_t* const b = argb + CHANNEL_OFFSET(3);
833      picture->colorspace = WEBP_YUV420;
834      return ImportYUVAFromRGBA(r, g, b, a, 4, 4 * picture->argb_stride,
835                                dithering, use_iterative_conversion, picture);
836    }
837  }
838  int WebPPictureARGBToYUVADithered(WebPPicture* picture, WebPEncCSP colorspace,
839                                    float dithering) {
840    return PictureARGBToYUVA(picture, colorspace, dithering, 0);
841  }
842  int WebPPictureARGBToYUVA(WebPPicture* picture, WebPEncCSP colorspace) {
843    return PictureARGBToYUVA(picture, colorspace, 0.f, 0);
844  }
845  int WebPPictureSharpARGBToYUVA(WebPPicture* picture) {
846    return PictureARGBToYUVA(picture, WEBP_YUV420, 0.f, 1);
847  }
848  int WebPPictureSmartARGBToYUVA(WebPPicture* picture) {
849    return WebPPictureSharpARGBToYUVA(picture);
850  }
851  int WebPPictureYUVAToARGB(WebPPicture* picture) {
852    if (picture == NULL) return 0;
853    if (picture->y == NULL || picture->u == NULL || picture->v == NULL) {
854      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
855    }
856    if ((picture->colorspace & WEBP_CSP_ALPHA_BIT) && picture->a == NULL) {
857      return WebPEncodingSetError(picture, VP8_ENC_ERROR_NULL_PARAMETER);
858    }
859    if ((picture->colorspace & WEBP_CSP_UV_MASK) != WEBP_YUV420) {
860      return WebPEncodingSetError(picture, VP8_ENC_ERROR_INVALID_CONFIGURATION);
861    }
862    if (!WebPPictureAllocARGB(picture, picture->width, picture->height)) return 0;
863    picture->use_argb = 1;
864    {
865      int y;
866      const int width = picture->width;
867      const int height = picture->height;
868      const int argb_stride = 4 * picture->argb_stride;
869      uint8_t* dst = (uint8_t*)picture->argb;
870      const uint8_t* cur_u = picture->u, *cur_v = picture->v, *cur_y = picture->y;
871      WebPUpsampleLinePairFunc upsample =
872          WebPGetLinePairConverter(ALPHA_OFFSET > 0);
873      upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, width);
874      cur_y += picture->y_stride;
875      dst += argb_stride;
876      for (y = 1; y + 1 < height; y += 2) {
877        const uint8_t* const top_u = cur_u;
878        const uint8_t* const top_v = cur_v;
879        cur_u += picture->uv_stride;
880        cur_v += picture->uv_stride;
881        upsample(cur_y, cur_y + picture->y_stride, top_u, top_v, cur_u, cur_v,
882                 dst, dst + argb_stride, width);
883        cur_y += 2 * picture->y_stride;
884        dst += 2 * argb_stride;
885      }
886      if (height > 1 && !(height & 1)) {
887        upsample(cur_y, NULL, cur_u, cur_v, cur_u, cur_v, dst, NULL, width);
888      }
889      if (picture->colorspace & WEBP_CSP_ALPHA_BIT) {
890        for (y = 0; y < height; ++y) {
891          uint32_t* const argb_dst = picture->argb + y * picture->argb_stride;
892          const uint8_t* const src = picture->a + y * picture->a_stride;
893          int x;
894          for (x = 0; x < width; ++x) {
895            argb_dst[x] = (argb_dst[x] & 0x00ffffffu) | ((uint32_t)src[x] << 24);
896          }
897        }
898      }
899    }
900    return 1;
901  }
902  static int Import(WebPPicture* const picture,
903                    const uint8_t* rgb, int rgb_stride,
904                    int step, int swap_rb, int import_alpha) {
905    int y;
906    const uint8_t* r_ptr = rgb + (swap_rb ? 2 : 0);
907    const uint8_t* g_ptr = rgb + 1;
908    const uint8_t* b_ptr = rgb + (swap_rb ? 0 : 2);
909    const int width = picture->width;
910    const int height = picture->height;
911    if (!picture->use_argb) {
912      const uint8_t* a_ptr = import_alpha ? rgb + 3 : NULL;
913      return ImportYUVAFromRGBA(r_ptr, g_ptr, b_ptr, a_ptr, step, rgb_stride,
914                                0.f &bsol;* no dithering */, 0, picture);
915    }
916    if (!WebPPictureAlloc(picture)) return 0;
917    VP8LDspInit();
918    WebPInitAlphaProcessing();
919    if (import_alpha) {
920      uint32_t* dst = picture->argb;
921      const int do_copy = (ALPHA_OFFSET == 3) && swap_rb;
922      assert(step == 4);
923      if (do_copy) {
924        for (y = 0; y < height; ++y) {
925          memcpy(dst, rgb, width * 4);
926          rgb += rgb_stride;
927          dst += picture->argb_stride;
928        }
929      } else {
930        for (y = 0; y < height; ++y) {
931  #ifdef WORDS_BIGENDIAN
932          const uint8_t* a_ptr = rgb + 3;
933          WebPPackARGB(a_ptr, r_ptr, g_ptr, b_ptr, width, dst);
934          r_ptr += rgb_stride;
935          g_ptr += rgb_stride;
936          b_ptr += rgb_stride;
937  #else
938          VP8LConvertBGRAToRGBA((const uint32_t*)rgb, width, (uint8_t*)dst);
939  #endif
940          rgb += rgb_stride;
941          dst += picture->argb_stride;
942        }
943      }
944    } else {
945      uint32_t* dst = picture->argb;
946      assert(step >= 3);
947      for (y = 0; y < height; ++y) {
948        WebPPackRGB(r_ptr, g_ptr, b_ptr, width, step, dst);
949        r_ptr += rgb_stride;
950        g_ptr += rgb_stride;
951        b_ptr += rgb_stride;
952        dst += picture->argb_stride;
953      }
954    }
955    return 1;
956  }
957  #if !defined(WEBP_REDUCE_CSP)
958  int WebPPictureImportBGR(WebPPicture* picture,
959                           const uint8_t* rgb, int rgb_stride) {
960    return (picture != NULL && rgb != NULL)
961               ? Import(picture, rgb, rgb_stride, 3, 1, 0)
962               : 0;
963  }
964  int WebPPictureImportBGRA(WebPPicture* picture,
965                            const uint8_t* rgba, int rgba_stride) {
966    return (picture != NULL && rgba != NULL)
967               ? Import(picture, rgba, rgba_stride, 4, 1, 1)
968               : 0;
969  }
970  int WebPPictureImportBGRX(WebPPicture* picture,
971                            const uint8_t* rgba, int rgba_stride) {
972    return (picture != NULL && rgba != NULL)
973               ? Import(picture, rgba, rgba_stride, 4, 1, 0)
974               : 0;
975  }
976  #endif   
977  int WebPPictureImportRGB(WebPPicture* picture,
978                           const uint8_t* rgb, int rgb_stride) {
979    return (picture != NULL && rgb != NULL)
980               ? Import(picture, rgb, rgb_stride, 3, 0, 0)
981               : 0;
982  }
983  int WebPPictureImportRGBA(WebPPicture* picture,
984                            const uint8_t* rgba, int rgba_stride) {
985    return (picture != NULL && rgba != NULL)
986               ? Import(picture, rgba, rgba_stride, 4, 0, 1)
987               : 0;
988  }
989  int WebPPictureImportRGBX(WebPPicture* picture,
990                            const uint8_t* rgba, int rgba_stride) {
991    return (picture != NULL && rgba != NULL)
992               ? Import(picture, rgba, rgba_stride, 4, 0, 0)
993               : 0;
994  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-tls1.2_ticket.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-picture_csp_enc.c</div>
                <div class="column column_space"><pre><code>267                      len = datalength - start;
268                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
269                  outlength += len + 5;
270                  start += len;
271              }
272              if (datalength - start > 0) {
273                  len = datalength - start;
274                  tls12_ticket_auth_pack_data(encryptdata, datalength, start, len, out_buffer, outlength);
275                  outlength += len + 5;
</pre></code></div>
                <div class="column column_space"><pre><code>664      dst[0] = SUM4(r_ptr + j, step);
665      dst[1] = SUM4(g_ptr + j, step);
666      dst[2] = SUM4(b_ptr + j, step);
667    }
668    if (width & 1) {
669      dst[0] = SUM2(r_ptr + j);
670      dst[1] = SUM2(g_ptr + j);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    