<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mmdblookup.c & mmanon.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mmdblookup.c & mmanon.c
      </h3>
      <h1 align="center">
        5.1%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mmdblookup.c (13.043478%)<TH>mmanon.c (3.1746032%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match2252-0.html#0',2,'match2252-1.html#0',3)" NAME="0">(242-261)<TD><A HREF="javascript:ZweiFrames('match2252-0.html#0',2,'match2252-1.html#0',3)" NAME="0">(228-247)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match2252-0.html#1',2,'match2252-1.html#1',3)" NAME="1">(98-107)<TD><A HREF="javascript:ZweiFrames('match2252-0.html#1',2,'match2252-1.html#1',3)" NAME="1">(124-133)</A><TD ALIGN=center><FONT COLOR="#f00000">17</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match2252-0.html#2',2,'match2252-1.html#2',3)" NAME="2">(77-87)<TD><A HREF="javascript:ZweiFrames('match2252-0.html#2',2,'match2252-1.html#2',3)" NAME="2">(108-116)</A><TD ALIGN=center><FONT COLOR="#b80000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmdblookup.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmdblookup.c
 * Parse ipaddress field of the message into structured data using
 * MaxMindDB.
 *
 * Copyright 2013 Rao Chenlin.
 * Copyright 2017 Rainer Gerhards and Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;pthread.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parserif.h&quot;

#include &quot;maxminddb.h&quot;

#define JSON_IPLOOKUP_NAME &quot;!iplocation&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmdblookup&quot;)


DEF_OMOD_STATIC_DATA

/* config variables */
typedef struct _instanceData {
	char *pszKey;
	char *pszMmdbFile;
	struct {
		int     nmemb;
		char **name;
		char **varname;
	} fieldList;
	sbool reloadOnHup;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	MMDB_s        mmdb;
	pthread_mutex_t mmdbMutex;
} wrkrInstanceData_t;

struct modConfData_s {
<A NAME="2"></A>	/* our overall config object */
	rsconf_t *pConf;
	const char *container;
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match2252-1.html#2',3,'match2252-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

/* modConf ptr to use for the current load process */
static modConfData_t *loadModConf = NULL;
/* modConf ptr to use for the current exec process */
static modConfData_t *runModConf  = NULL;


/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;container&quot;, eCmdHdlrGetWord, 0 },</B></FONT>
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

<A NAME="1"></A>/* tables for interfacing with the v6 config system
 * action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match2252-1.html#1',3,'match2252-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;key&quot;,      eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ &quot;mmdbfile&quot;, eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ &quot;fields&quot;,   eCmdHdlrArray,   CNFPARAM_REQUIRED },
	{ &quot;reloadonhup&quot;, eCmdHdlrBinary, 0 },
};
static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	actpdescr
};</B></FONT>


/* protype functions */
void str_split(char **membuf);

int open_mmdb(const char *file, MMDB_s *mmdb);
void close_mmdb(MMDB_s *mmdb);


int open_mmdb(const char *file, MMDB_s *mmdb) {
	int status = MMDB_open(file, MMDB_MODE_MMAP, mmdb);
	if (MMDB_SUCCESS != status) {
		dbgprintf(&quot;Can't open %s - %s\n&quot;, file, MMDB_strerror(status));
		if (MMDB_IO_ERROR == status) {
			dbgprintf(&quot;  IO error: %s\n&quot;, strerror(errno));
		}
		LogError(0, RS_RET_SUSPENDED, &quot;maxminddb error: cannot open database file&quot;);
	}

	return MMDB_SUCCESS != status;
}

void close_mmdb(MMDB_s *mmdb) {
	MMDB_close(mmdb);
}

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
	free((void*)runModConf-&gt;container);
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	CHKiRet(open_mmdb(pData-&gt;pszMmdbFile, &amp;pWrkrData-&gt;mmdb));
	CHKiConcCtrl(pthread_mutex_init(&amp;pWrkrData-&gt;mmdbMutex, NULL));
finalize_it:
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
	if(pData-&gt;fieldList.name != NULL) {
		for(int i = 0 ; i &lt; pData-&gt;fieldList.nmemb ; ++i) {
			free(pData-&gt;fieldList.name[i]);
			free(pData-&gt;fieldList.varname[i]);
		}
		free(pData-&gt;fieldList.name);
		free(pData-&gt;fieldList.varname);
	}
	free(pData-&gt;pszKey);
	free(pData-&gt;pszMmdbFile);
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	close_mmdb(&amp;pWrkrData-&gt;mmdb);
	pthread_mutex_destroy(&amp;pWrkrData-&gt;mmdbMutex);
ENDfreeWrkrInstance


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	loadModConf-&gt;container = NULL;
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;mmdblookup: error processing module &quot;
						&quot;config parameters missing [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for mmdblookup:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;container&quot;)) {
			loadModConf-&gt;container = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf(&quot;mmdblookup: program error, non-handled &quot;
					  &quot;param '%s' in setModCnf\n&quot;, modpblk.descr[i].name);
		}
	}

	if(loadModConf-&gt;container == NULL) {
		CHKmalloc(loadModConf-&gt;container = strdup(JSON_IPLOOKUP_NAME));
	}

finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;pszKey = NULL;
<A NAME="0"></A>	pData-&gt;pszMmdbFile = NULL;
	pData-&gt;fieldList.nmemb = 0;
	pData-&gt;reloadOnHup = 1;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2252-1.html#0',3,'match2252-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	dbgprintf(&quot;newActInst (mmdblookup)\n&quot;);
	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for (i = 0; i &lt; actpblk.nParams; ++i) {
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(actpblk.descr[i].name, &quot;key&quot;)) {</B></FONT>
			pData-&gt;pszKey = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;mmdbfile&quot;)) {
			pData-&gt;pszMmdbFile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, &quot;fields&quot;)) {
			pData-&gt;fieldList.nmemb = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(pData-&gt;fieldList.name = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
			CHKmalloc(pData-&gt;fieldList.varname = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
			for (int j = 0; j &lt;  pvals[i].val.d.ar-&gt;nmemb; ++j) {
				char *const param = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				char *varname = NULL;
				char *name;
				if(*param == ':') {
					char *b = strchr(param+1, ':');
					if(b == NULL) {
						parser_errmsg(&quot;mmdblookup: missing closing colon: '%s'&quot;, param);
						ABORT_FINALIZE(RS_RET_ERR);
					}
					*b = '\0'; /* split name &amp; varname */
					varname = param+1;
					name = b+1;
				} else {
					name = param;
				}
				if(*name == '!')
					++name;
				CHKmalloc(pData-&gt;fieldList.name[j] = strdup(name));
				char vnamebuf[1024];
				snprintf(vnamebuf, sizeof(vnamebuf),
					&quot;%s!%s&quot;, loadModConf-&gt;container,
					(varname == NULL) ? name : varname);
				CHKmalloc(pData-&gt;fieldList.varname[j] = strdup(vnamebuf));
				free(param);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;reloadonhup&quot;)) {
			pData-&gt;reloadOnHup = pvals[i].val.d.n;
		} else {
			dbgprintf(&quot;mmdblookup: program error, non-handled&quot;
				&quot; param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


void
str_split(char **membuf)
{
	int in_quotes = 0;
	char *buf  = *membuf;
	char tempbuf[strlen(buf)];
	memset(tempbuf, 0, strlen(buf));

	while (*buf++ != '\0') {
		if (in_quotes) {
			if (*buf == '&quot;' &amp;&amp; *(buf - 1) != '\\') {
				in_quotes = !in_quotes;
				strncat(tempbuf, buf, 1);
			} else {
				strncat(tempbuf, buf, 1);
			}
		} else {
			if (*buf == '\n' || *buf == '\t' || *buf == ' ')
				continue;
			if (*buf == '&lt;') {
				char *p = strchr(buf, '&gt;');
				buf = buf + (int)(p - buf);
				strcat(tempbuf, &quot;,&quot;);
			} else if (*buf == '}') {
				strcat(tempbuf, &quot;},&quot;);
			} else if (*buf == ']') {
				strcat(tempbuf, &quot;],&quot;);
			} else if (*buf == '&quot;' &amp;&amp; *(buf - 1) != '\\') {
				in_quotes = !in_quotes;
				strncat(tempbuf, buf, 1);
			} else {
				strncat(tempbuf, buf, 1);
			}
		}
	}

	memcpy(*membuf, tempbuf, strlen(tempbuf)+1);
}


BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg   = ppMsg[0];
	struct json_object *keyjson = NULL;
	const char *pszValue;
	instanceData *const pData = pWrkrData-&gt;pData;
	json_object *total_json = NULL;
	MMDB_entry_data_list_s *entry_data_list = NULL;
CODESTARTdoAction
	/* key is given, so get the property json */
	msgPropDescr_t pProp;
	msgPropDescrFill(&amp;pProp, (uchar*)pData-&gt;pszKey, strlen(pData-&gt;pszKey));
	rsRetVal localRet = msgGetJSONPropJSON(pMsg, &amp;pProp, &amp;keyjson);
	msgPropDescrDestruct(&amp;pProp);

	pthread_mutex_lock(&amp;pWrkrData-&gt;mmdbMutex);
	if (localRet != RS_RET_OK) {
		/* key not found in the message. nothing to do */
		ABORT_FINALIZE(RS_RET_OK);
	}
	/* key found, so get the value */
	pszValue = (char*)json_object_get_string(keyjson);
	if(pszValue == NULL) { /* json null object returns NULL! */
		pszValue = &quot;&quot;;
	}

	int gai_err, mmdb_err;
	MMDB_lookup_result_s result = MMDB_lookup_string(&amp;pWrkrData-&gt;mmdb, pszValue, &amp;gai_err, &amp;mmdb_err);

	if (0 != gai_err) {
		dbgprintf(&quot;Error from call to getaddrinfo for %s - %s\n&quot;, pszValue, gai_strerror(gai_err));
		ABORT_FINALIZE(RS_RET_OK);
	}
	if (MMDB_SUCCESS != mmdb_err) {
		dbgprintf(&quot;Got an error from the maxminddb library: %s\n&quot;, MMDB_strerror(mmdb_err));
		ABORT_FINALIZE(RS_RET_OK);
	}
	if (!result.found_entry) {
		dbgprintf(&quot;No entry found in database for '%s'\n&quot;, pszValue);
		ABORT_FINALIZE(RS_RET_OK);
	}


	int status  = MMDB_get_entry_data_list(&amp;result.entry, &amp;entry_data_list);

	if (MMDB_SUCCESS != status) {
		dbgprintf(&quot;Got an error looking up the entry data - %s\n&quot;, MMDB_strerror(status));
		ABORT_FINALIZE(RS_RET_OK);
	}

	size_t  memlen;
	char   *membuf;
	FILE   *memstream;
	CHKmalloc(memstream = open_memstream(&amp;membuf, &amp;memlen));

	if (entry_data_list != NULL &amp;&amp; memstream != NULL) {
		MMDB_dump_entry_data_list(memstream, entry_data_list, 2);
		fflush(memstream);
		str_split(&amp;membuf);
	}

	DBGPRINTF(&quot;maxmindb returns: '%s'\n&quot;, membuf);
	total_json = json_tokener_parse(membuf);
	fclose(memstream);
	free(membuf);

	/* extract and amend fields (to message) as configured */
	for (int i = 0 ; i &lt;  pData-&gt;fieldList.nmemb; ++i) {
		char *strtok_save;
		char buf[(strlen((char *)(pData-&gt;fieldList.name[i])))+1];
		strcpy(buf, (char *)pData-&gt;fieldList.name[i]);

		json_object *temp_json = total_json;
		json_object *sub_obj   = temp_json;
		int j = 0;
		const char *SEP = &quot;!&quot;;

		/* find lowest level JSON object */
		char *s = strtok_r(buf, SEP, &amp;strtok_save);
		for (; s != NULL; j++) {
			json_object_object_get_ex(temp_json, s, &amp;sub_obj);
			temp_json = sub_obj;
			s = strtok_r(NULL, SEP, &amp;strtok_save);
		}
		/* temp_json now contains the value we want to have, so set it */
		json_object_get(temp_json);
		msgAddJSON(pMsg, (uchar *)pData-&gt;fieldList.varname[i], temp_json, 0, 0);
	}

finalize_it:
	pthread_mutex_unlock(&amp;pWrkrData-&gt;mmdbMutex);
	if(entry_data_list != NULL)
		MMDB_free_entry_data_list(entry_data_list);
	json_object_put(keyjson);
	if(total_json != NULL)
		json_object_put(total_json);
ENDdoAction

// HUP handling for the worker...
BEGINdoHUPWrkr
CODESTARTdoHUPWrkr
	dbgprintf(&quot;mmdblookup: HUP received\n&quot;);
	if (pWrkrData-&gt;pData-&gt;reloadOnHup) {
		// a mutex is needed, as it's the main thread that runs this handler
		pthread_mutex_lock(&amp;pWrkrData-&gt;mmdbMutex);
		LogMsg(0, NO_ERRCODE, LOG_INFO, &quot;mmdblookup: reloading MMDB file&quot;);
		close_mmdb(&amp;pWrkrData-&gt;mmdb);
		iRet = open_mmdb(pWrkrData-&gt;pData-&gt;pszMmdbFile, &amp;pWrkrData-&gt;mmdb);
		pthread_mutex_unlock(&amp;pWrkrData-&gt;mmdbMutex);
	}
ENDdoHUPWrkr


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_doHUPWrkr
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	/* we only support the current interface specification */
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	dbgprintf(&quot;mmdblookup: module compiled with rsyslog version %s.\n&quot;, VERSION);
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmanon.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmanon.c
 * anonnymize IP addresses inside the syslog message part
 *
 * Copyright 2013 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parserif.h&quot;
#include &quot;hashtable.h&quot;



MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmanon&quot;)


DEF_OMOD_STATIC_DATA

/* config variables */

// enumerator for the mode
enum mode {ZERO, RANDOMINT, SIMPLE};

union node {
	struct {
		union node* more;
		union node* less;
	} pointer;
	struct {
		char ip_high[16];
		char ip_low[16];
	} ips;
};

struct ipv6_int {
	unsigned long long high;
	unsigned long long low;
	};
/* define operation modes we have */
#define SIMPLE_MODE 0	 /* just overwrite */
#define REWRITE_MODE 1	 /* rewrite IP address, canoninized */
typedef struct _instanceData {
	struct {
		sbool enable;
		int8_t bits;
		union node* Root;
		int randConsis;
		enum mode mode;
		uchar replaceChar;
	} ipv4;

	struct {
		sbool enable;
		uint8_t bits;
		enum mode anonmode;
		int randConsis;
		struct hashtable* hash;
	} ipv6;

	struct {
		sbool enable;
		uint8_t bits;
		enum mode anonmode;
		int randConsis;
		struct hashtable* hash;
	} embeddedIPv4;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	unsigned randstatus;
} wrkrInstanceData_t;
<A NAME="2"></A>
struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2252-0.html#2',2,'match2252-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */


/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;ipv4.enable&quot;, eCmdHdlrBinary, 0 },</B></FONT>
	{ &quot;ipv4.mode&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;mode&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;ipv4.bits&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;ipv4.replacechar&quot;, eCmdHdlrGetChar, 0},
<A NAME="1"></A>	{ &quot;replacementchar&quot;, eCmdHdlrGetChar, 0},
	{ &quot;ipv6.enable&quot;, eCmdHdlrBinary, 0 },
	{ &quot;ipv6.anonmode&quot;, eCmdHdlrGetWord, 0 },
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2252-0.html#1',2,'match2252-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;ipv6.bits&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;embeddedipv4.enable&quot;, eCmdHdlrBinary, 0 },
	{ &quot;embeddedipv4.anonmode&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;embeddedipv4.bits&quot;, eCmdHdlrPositiveInt, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;randstatus = time(NULL);
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


static void
delTree(union node* node, const int layer)
{
	if(node == NULL){
		return;
	}
	if(layer == 31){
		free(node);
	} else {
		delTree(node-&gt;pointer.more, layer + 1);
		delTree(node-&gt;pointer.less, layer + 1);
		free(node);
	}
}


BEGINfreeInstance
CODESTARTfreeInstance
	delTree(pData-&gt;ipv4.Root, 0);
	if(pData-&gt;ipv6.hash != NULL) {
		hashtable_destroy(pData-&gt;ipv6.hash, 1);
	}
	if(pData-&gt;embeddedIPv4.hash != NULL) {
		hashtable_destroy(pData-&gt;embeddedIPv4.hash, 1);
	}
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


static inline void
setInstParamDefaults(instanceData *pData)
{
		pData-&gt;ipv4.enable = 1;
		pData-&gt;ipv4.bits = 16;
		pData-&gt;ipv4.Root = NULL;
		pData-&gt;ipv4.randConsis = 0;
		pData-&gt;ipv4.mode = ZERO;
		pData-&gt;ipv4.replaceChar = 'x';

		pData-&gt;ipv6.enable = 1;
		pData-&gt;ipv6.bits = 96;
		pData-&gt;ipv6.anonmode = ZERO;
		pData-&gt;ipv6.randConsis = 0;
		pData-&gt;ipv6.hash = NULL;

		pData-&gt;embeddedIPv4.enable = 1;
		pData-&gt;embeddedIPv4.bits = 96;
<A NAME="0"></A>		pData-&gt;embeddedIPv4.anonmode = ZERO;
		pData-&gt;embeddedIPv4.randConsis = 0;
		pData-&gt;embeddedIPv4.hash = NULL;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match2252-0.html#0',2,'match2252-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (mmanon)\n&quot;);
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;ipv4.mode&quot;) || !strcmp(actpblk.descr[i].name, &quot;mode&quot;)) {</B></FONT>
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;zero&quot;,
					 sizeof(&quot;zero&quot;)-1)) {
				pData-&gt;ipv4.mode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random&quot;,
					 sizeof(&quot;random&quot;)-1)) {
				pData-&gt;ipv4.mode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;simple&quot;,
					 sizeof(&quot;simple&quot;)-1) ||
					!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;rewrite&quot;,
					 sizeof(&quot;rewrite&quot;)-1)) {
				pData-&gt;ipv4.mode = SIMPLE;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random-consistent&quot;,
					 sizeof(&quot;random-consistent&quot;)-1)) {
				pData-&gt;ipv4.mode = RANDOMINT;
				pData-&gt;ipv4.randConsis = 1;
			} else {
				parser_errmsg(&quot;mmanon: configuration error, unknown option for ipv4.mode, &quot;
					&quot;will use \&quot;zero\&quot;\n&quot;);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv4.bits&quot;)) {
			if((int8_t) pvals[i].val.d.n &lt;= 32) {
				pData-&gt;ipv4.bits = (int8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;ipv4.bits = 32;
				parser_errmsg(&quot;warning: invalid number of ipv4.bits (%d), corrected &quot;
				&quot;to 32&quot;, (int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv4.enable&quot;)) {
			pData-&gt;ipv4.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv4.replacechar&quot;) || !strcmp(actpblk.descr[i].name,
			&quot;replacementchar&quot;)) {
			uchar* tmp = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
			pData-&gt;ipv4.replaceChar = tmp[0];
			free(tmp);
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv6.enable&quot;)) {
			pData-&gt;ipv6.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv6.bits&quot;)) {
			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
				pData-&gt;ipv6.bits = (uint8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;ipv6.bits = 128;
				parser_errmsg(&quot;warning: invalid number of ipv6.bits (%d), corrected &quot;
				&quot;to 128&quot;, (int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv6.anonmode&quot;)) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;zero&quot;,
					 sizeof(&quot;zero&quot;)-1)) {
				pData-&gt;ipv6.anonmode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random&quot;,
					 sizeof(&quot;random&quot;)-1)) {
				pData-&gt;ipv6.anonmode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random-consistent&quot;,
					 sizeof(&quot;random-consistent&quot;)-1)) {
				pData-&gt;ipv6.anonmode = RANDOMINT;
				pData-&gt;ipv6.randConsis = 1;
			} else {
				parser_errmsg(&quot;mmanon: configuration error, unknown option for &quot;
				&quot;ipv6.anonmode, will use \&quot;zero\&quot;\n&quot;);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;embeddedipv4.enable&quot;)) {
			pData-&gt;embeddedIPv4.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;embeddedipv4.bits&quot;)) {
			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
				pData-&gt;embeddedIPv4.bits = (uint8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;embeddedIPv4.bits = 128;
				parser_errmsg(&quot;warning: invalid number of embeddedipv4.bits (%d), &quot;
					&quot;corrected to 128&quot;, (int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;embeddedipv4.anonmode&quot;)) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;zero&quot;,
					 sizeof(&quot;zero&quot;)-1)) {
				pData-&gt;embeddedIPv4.anonmode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random&quot;,
					 sizeof(&quot;random&quot;)-1)) {
				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random-consistent&quot;,
					 sizeof(&quot;random-consistent&quot;)-1)) {
				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
				pData-&gt;embeddedIPv4.randConsis = 1;
			} else {
				parser_errmsg(&quot;mmanon: configuration error, unknown option for ipv6.anonmode, &quot;
				&quot;will use \&quot;zero\&quot;\n&quot;);
			}
		} else {
			parser_errmsg(&quot;mmanon: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	int bHadBitsErr = 0;
	if(pData-&gt;ipv4.mode == SIMPLE) {
		if(pData-&gt;ipv4.bits &lt; 8 &amp;&amp; pData-&gt;ipv4.bits &gt; -1) {
			pData-&gt;ipv4.bits = 8;
			bHadBitsErr = 1;
		} else if(pData-&gt;ipv4.bits &lt; 16 &amp;&amp; pData-&gt;ipv4.bits &gt; 8) {
			pData-&gt;ipv4.bits = 16;
			bHadBitsErr = 1;
		} else if(pData-&gt;ipv4.bits &lt; 24 &amp;&amp; pData-&gt;ipv4.bits &gt; 16) {
			pData-&gt;ipv4.bits = 24;
			bHadBitsErr = 1;
		} else if((pData-&gt;ipv4.bits != 32 &amp;&amp; pData-&gt;ipv4.bits &gt; 24) || pData-&gt;ipv4.bits &lt; 0) {
			pData-&gt;ipv4.bits = 32;
			bHadBitsErr = 1;
		}
		if(bHadBitsErr) {
			LogError(0, RS_RET_INVLD_ANON_BITS,
				&quot;mmanon: invalid number of ipv4 bits &quot;
				&quot;in simple mode, corrected to %d&quot;,
				pData-&gt;ipv4.bits);
		}
	}

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


static int
getHexVal(char c)
{
	if('0' &lt;= c &amp;&amp; c &lt;= '9') {
		return c - '0';
	} else if('a' &lt;= c &amp;&amp; c &lt;= 'f') {
		return (c - 'a') + 10;
	} else if('A' &lt;= c &amp;&amp; c &lt;= 'F') {
		return (c - 'A') + 10;
	} else {
		return -1;
	}
}


/* returns -1 if no integer found, else integer */
static int64_t
getPosInt(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int64_t val = 0;
	size_t i;
	for(i = 0 ; i &lt; buflen ; i++) {
		if('0' &lt;= buf[i] &amp;&amp; buf[i] &lt;= '9')
			val = val*10 + buf[i]-'0';
		else
			break;
	}
	*nprocessed = i;
	if(i == 0)
		val = -1;
	return val;
}

/* 1 - is IPv4, 0 not */

static int
syntax_ipv4(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int64_t val;
	size_t nproc;
	size_t i;
	int r = 0;

	val = getPosInt(buf, buflen, &amp;i);
	if(val &lt; 0 || val &gt; 255)
		goto done;

	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;

	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;

	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;

	*nprocessed = i;
	r = 1;

done:
	return r;
}


static int
isValidHexNum(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed,
	int handleDot)
{
	size_t idx = 0;
	int cyc = 0;

	while(idx &lt; buflen) {
		switch(buf[idx]) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':

		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':

		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			cyc++;
			(*nprocessed)++;
			if(cyc == 5) {
				goto done;
			}
			break;
		case '.':
			if(handleDot &amp;&amp; cyc == 0) {
				(*nprocessed)++;
				cyc = -2;
			}
			goto done;
		case ':':
			if(cyc == 0) {
				(*nprocessed)++;
				cyc = -1;
			}
			goto done;
		default:
			goto done;
		}
		idx++;
	}
done:
	return cyc;
}


static int
syntax_ipv6(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int lastSep = 0;
	sbool hadAbbrev = 0;
	sbool lastAbbrev = 0;
	int ipParts = 0;
	int numLen;
	int isIP = 0;

	while(*nprocessed &lt; buflen) {
		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 0);
		if(numLen &gt; 0 &amp;&amp; numLen &lt; 5) {  //found a valid num
			if((ipParts == 7 &amp;&amp; hadAbbrev) || ipParts &gt; 7) {
				isIP = 0;
				goto done;
			}
			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
				isIP = 0;
				goto done;
			}
			lastSep = 0;
			lastAbbrev = 0;
			ipParts++;
		} else if (numLen &lt; 0) {  //':'
			if(lastSep) {
				if(hadAbbrev) {
					isIP = 0;
					goto done;
				} else {
					hadAbbrev = 1;
					lastAbbrev = 1;
				}
			}
			lastSep = 1;
		} else if (numLen == 5) {  // maybe truncated with port
			if(hadAbbrev &amp;&amp; ipParts &gt;= 2) {
				isIP = 1;
				/* we need to go back 6 chars:
				 * 5 digits plus leading &quot;:&quot; which designates port!
				 */
				*nprocessed -= 6;
			} else {
				isIP = 0;
				/* nprocessed need not be corrected - it's only used if isIP == 1 */
			}
			goto done;
		} else {  //no valid num
			if(lastSep) {
				if(lastAbbrev &amp;&amp; ipParts &lt; 8) {
					isIP = 1;
					goto done;
				}
				isIP = 0;
				goto done;
			}
			if((ipParts == 8 &amp;&amp; !hadAbbrev) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
				isIP = 1;
				goto done;
			} else {
				isIP = 0;
				goto done;
			}
		}
		if(ipParts == 8 &amp;&amp; !hadAbbrev) {
			isIP = 1;
			goto done;
		}
	}

	if((!lastSep &amp;&amp; (ipParts == 8 &amp;&amp; !hadAbbrev)) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
		isIP = 1;
	}

done:
	return isIP;
}


static unsigned
ipv42num(const char *str)
{
	unsigned num[4] = {0, 0, 0, 0};
	unsigned value = -1;
	size_t len = strlen(str);
	int cyc = 0;
	for(unsigned i = 0 ; i &lt; len ; i++) {
		switch(str[i]) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			num[cyc] = num[cyc]*10+(str[i]-'0');
			break;
		case '.':
			cyc++;
			break;
		}
	}

	value = num[0]*256*256*256+num[1]*256*256+num[2]*256+num[3];
	return(value);
}


static unsigned
code_int(unsigned ip, wrkrInstanceData_t *pWrkrData){
	unsigned random;
	unsigned long long shiftIP_subst = ip;
	// variable needed because shift operation of 32nd bit in unsigned does not work
	switch(pWrkrData-&gt;pData-&gt;ipv4.mode) {
	case ZERO:
		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
		return (unsigned)shiftIP_subst;
	case RANDOMINT:
		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
		// multiply the random number between 0 and 1 with a mask of (2^n)-1:
		random = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*
			((1ull&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits))-1));
		return (unsigned)shiftIP_subst + random;
	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
	default:
		LogError(0, RS_RET_INTERNAL_ERROR, &quot;mmanon: unexpected code path reached in code_int function&quot;);
		return 0;
	}
}


static int
num2ipv4(unsigned num, char *str) {
	int numip[4];
	size_t len;
	for(int i = 0 ; i &lt; 4 ; i++){
		numip[i] = num % 256;
		num = num / 256;
	}
	len = snprintf(str, 16, &quot;%d.%d.%d.%d&quot;, numip[3], numip[2], numip[1], numip[0]);
	return len;
}


static void
getip(uchar *start, size_t end, char *address)
{
	size_t i;

	for(i = 0; i &lt; end; i++){
		address[i] = *(start+i);
	}
	address[i] = '\0';
}

/* in case of error with malloc causing abort of function, the
 * string at the target of address remains the same */
static rsRetVal
findip(char* address, wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	int i;
	unsigned num;
	union node* current;
	union node* Last;
	int MoreLess;
	char* CurrentCharPtr;

	current = pWrkrData-&gt;pData-&gt;ipv4.Root;
	num = ipv42num(address);
	for(i = 0; i &lt; 31; i++){
		if(pWrkrData-&gt;pData-&gt;ipv4.Root == NULL) {
			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
			pWrkrData-&gt;pData-&gt;ipv4.Root = current;
		}
		Last = current;
		if((num &gt;&gt; (31 - i)) &amp; 1){
			current = current-&gt;pointer.more;
			MoreLess = 1;
		} else {
			current = current-&gt;pointer.less;
			MoreLess = 0;
		}
		if(current == NULL){
			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
			if(MoreLess == 1){
				Last-&gt;pointer.more = current;
			} else {
				Last-&gt;pointer.less = current;
			}
		}
	}
	if(num &amp; 1){
		CurrentCharPtr = current-&gt;ips.ip_high;
	} else {
		CurrentCharPtr = current-&gt;ips.ip_low;
	}
	if(CurrentCharPtr[0] != '\0'){
		strcpy(address, CurrentCharPtr);
	} else {
		num = code_int(num, pWrkrData);
		num2ipv4(num, CurrentCharPtr);
		strcpy(address, CurrentCharPtr);
	}
finalize_it:
	RETiRet;
}


static void
process_IPv4 (char* address, wrkrInstanceData_t *pWrkrData)
{
	unsigned num;

	if(pWrkrData-&gt;pData-&gt;ipv4.randConsis){
		findip(address, pWrkrData);
	}else {
		num = ipv42num(address);
		num = code_int(num, pWrkrData);
		num2ipv4(num, address);
	}
}


static void
simpleAnon(wrkrInstanceData_t *const pWrkrData, uchar *const msg, int *const hasChanged, int iplen)
{
	int maxidx = iplen - 1;

	int j = -1;
	for(int i = (pWrkrData-&gt;pData-&gt;ipv4.bits / 8); i &gt; 0; i--) {
		j++;
		while('0' &lt;= msg[maxidx - j] &amp;&amp; msg[maxidx - j] &lt;= '9') {
			if(msg[maxidx - j] != pWrkrData-&gt;pData-&gt;ipv4.replaceChar) {
				msg[maxidx - j] = pWrkrData-&gt;pData-&gt;ipv4.replaceChar;
				*hasChanged = 1;
			}
			j++;
		}
	}
}


static void
anonipv4(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	char address[16];
	char caddress[16];
	int offset = *idx;
	uchar* msgcpy = *msg;
	size_t iplen;
	size_t caddresslen;
	int oldLen = *pLenMsg;

	if(syntax_ipv4((*msg) + offset, *pLenMsg - offset, &amp;iplen)) {
		if(pWrkrData-&gt;pData-&gt;ipv4.mode == SIMPLE) {
			simpleAnon(pWrkrData, *msg + *idx, hasChanged, iplen);
			*idx += iplen;
			return;
		}

		assert(iplen &lt; sizeof(address));
		getip(*msg + offset, iplen, address);
		offset += iplen;
		strcpy(caddress, address);
		process_IPv4(caddress, pWrkrData);
		caddresslen = strlen(caddress);
		*hasChanged = 1;

		if(caddresslen != strlen(address)) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)strlen(address));
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, caddress, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}


static void
code_ipv6_int(struct ipv6_int* ip, wrkrInstanceData_t *pWrkrData, int useEmbedded)
{
	unsigned long long randlow = 0;
	unsigned long long randhigh = 0;
	unsigned tmpRand;
	int fullbits;

	int bits = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.bits : pWrkrData-&gt;pData-&gt;ipv6.bits;
	enum mode anonmode = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.anonmode : pWrkrData-&gt;pData-&gt;ipv6.anonmode;

	if(bits == 128) { //has to be handled separately, since shift
						 //128 bits doesn't work on unsigned long long
		ip-&gt;high = 0;
		ip-&gt;low = 0;
	} else if(bits &gt; 64) {
		ip-&gt;low = 0;
		ip-&gt;high = (ip-&gt;high &gt;&gt; (bits - 64)) &lt;&lt;  (bits - 64);
	} else if(bits == 64) {
		ip-&gt;low = 0;
	} else {
		ip-&gt;low = (ip-&gt;low &gt;&gt; bits) &lt;&lt; bits;
	}
	switch(anonmode) {
	case ZERO:
		break;
	case RANDOMINT:
		if(bits == 128) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;high &lt;&lt;= 8;
				ip-&gt;high |= tmpRand;

				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}
		} else if(bits &gt; 64) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}

			bits -= 64;
			fullbits = bits / 8;
			bits = bits % 8;
			while(fullbits &gt; 0) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				randhigh &lt;&lt;= 8;
				randhigh |= tmpRand;
				fullbits--;
			}
			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
			randhigh &lt;&lt;= bits;
			randhigh |= tmpRand;

			ip-&gt;high |= randhigh;
		} else if(bits == 64) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}
		} else {
			fullbits = bits / 8;
			bits = bits % 8;
			while(fullbits &gt; 0) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				randlow &lt;&lt;= 8;
				randlow |= tmpRand;
				fullbits--;
			}
			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
			randlow &lt;&lt;= bits;
			randlow |= tmpRand;

			ip-&gt;low |= randlow;
		}
		break;
	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
	default:
		LogError(0, RS_RET_INTERNAL_ERROR, &quot;mmanon: unexpected code path reached in code_int function&quot;);
	}
}


//separate function from recognising ipv6, since the recognition might get more
//complex. This function always stays
//the same, since it always gets an valid ipv6 input
static void
ipv62num(char* const address, const size_t iplen, struct ipv6_int* const ip)
{
	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	int cyc = 0;
	int dots = 0;
	int val;
	unsigned i;

	for(i = 0; i &lt; iplen &amp;&amp; dots &lt; 2; i++) {
		val = getHexVal(address[i]);
		if(val == -1) {
			dots++;
			if(dots &lt; 2) {
				cyc++;
			}
		} else {
			num[cyc] = num[cyc] * 16 + val;
			dots = 0;
		}
	}
	if(dots == 2) {
		if(i &lt; iplen - 1) {
			int shift = 0;
			cyc = 7;
			for(unsigned j = iplen - 1; j &gt;= i; j--) {
				val = getHexVal(address[j]);
				if(val == -1) {
					cyc--;
					shift = 0;
				} else {
					val &lt;&lt;= shift;
					shift += 4;
					num[cyc] += val;
				}
			}
		} else {
			while(cyc &lt; 8) {
				num[cyc] = 0;
				cyc++;
			}
		}
	}

	for(i = 0; i &lt; 4; i++) {
		ip-&gt;high &lt;&lt;= 16;
		ip-&gt;high |= num[i];
	}
	while(i &lt; 8) {
		ip-&gt;low &lt;&lt;= 16;
		ip-&gt;low |= num[i];
		i++;
	}
}


static void
num2ipv6 (struct ipv6_int* ip, char* address)
{
	int num[8];
	int i;

	for(i = 7; i &gt; 3; i--) {
		num[i] = ip-&gt;low &amp; 0xffff;
		ip-&gt;low &gt;&gt;= 16;
	}
	while(i &gt; -1) {
		num[i] = ip-&gt;high &amp; 0xffff;
		ip-&gt;high &gt;&gt;= 16;
		i--;
	}

	snprintf(address, 40, &quot;%x:%x:%x:%x:%x:%x:%x:%x&quot;, num[0], num[1], num[2], num[3], num[4], num[5],
		num[6], num[7]);
}


static int
keys_equal_fn(void* key1, void* key2)
{
	struct ipv6_int *const k1 = (struct ipv6_int*) key1;
	struct ipv6_int *const k2 = (struct ipv6_int*) key2;

	return((k1-&gt;high == k2-&gt;high) &amp;&amp; (k1-&gt;low == k2-&gt;low));
}


static unsigned
hash_from_key_fn (void* k)
{
	struct ipv6_int *const key = (struct ipv6_int*) k;
	unsigned hashVal;

	hashVal = (key-&gt;high &amp; 0xFFC00000) | (key-&gt;low &amp; 0x3FFFFF);
	return hashVal;
}


static void
num2embedded (struct ipv6_int* ip, char* address)
{
	int num[8];
	int i;

	for(i = 7; i &gt; 3; i--) {
		num[i] = ip-&gt;low &amp; 0xffff;
		ip-&gt;low &gt;&gt;= 16;
	}
	while(i &gt; -1) {
		num[i] = ip-&gt;high &amp; 0xffff;
		ip-&gt;high &gt;&gt;= 16;
		i--;
	}

	snprintf(address, 46, &quot;%x:%x:%x:%x:%x:%x:%d.%d.%d.%d&quot;, num[0], num[1], num[2], num[3], num[4], num[5],
		(num[6] &amp; 0xff00) &gt;&gt; 8, num[6] &amp; 0xff, (num[7] &amp; 0xff00) &gt;&gt; 8, num[7] &amp; 0xff);
}


static rsRetVal
findIPv6(struct ipv6_int* num, char* address, wrkrInstanceData_t *const pWrkrData, int useEmbedded)
{
	struct ipv6_int* hashKey = NULL;
	DEFiRet;
	struct hashtable* hash = useEmbedded? pWrkrData-&gt;pData-&gt;embeddedIPv4.hash : pWrkrData-&gt;pData-&gt;ipv6.hash;


	if(hash == NULL) {
		CHKmalloc(hash = create_hashtable(512, hash_from_key_fn, keys_equal_fn, NULL));
		if(useEmbedded) {
			pWrkrData-&gt;pData-&gt;embeddedIPv4.hash = hash;
		} else {
			pWrkrData-&gt;pData-&gt;ipv6.hash = hash;
		}
	}

	char* val = (char*)(hashtable_search(hash, num));

	if(val != NULL) {
		strcpy(address, val);
	} else {
		CHKmalloc(hashKey = (struct ipv6_int*) malloc(sizeof(struct ipv6_int)));
		hashKey-&gt;low = num-&gt;low;
		hashKey-&gt;high = num-&gt;high;

		if(useEmbedded) {
			code_ipv6_int(num, pWrkrData, 1);
			num2embedded(num, address);
		} else {
			code_ipv6_int(num, pWrkrData, 0);
			num2ipv6(num, address);
		}
		char* hashString;
		CHKmalloc(hashString = strdup(address));

		if(!hashtable_insert(hash, hashKey, hashString)) {
			DBGPRINTF(&quot;hashtable error: insert to %s-table failed&quot;,
				useEmbedded ? &quot;embedded ipv4&quot; : &quot;ipv6&quot;);
			free(hashString);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		hashKey = NULL;
	}
finalize_it:
	free(hashKey);
	RETiRet;
}


static void
process_IPv6 (char* address, wrkrInstanceData_t *pWrkrData, const size_t iplen)
{
	struct ipv6_int num = {0, 0};

	ipv62num(address, iplen, &amp;num);

	if(pWrkrData-&gt;pData-&gt;ipv6.randConsis) {
		findIPv6(&amp;num, address, pWrkrData, 0);
	} else {
		code_ipv6_int(&amp;num, pWrkrData, 0);
		num2ipv6(&amp;num, address);
	}
}


static void
anonipv6(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	size_t iplen = 0;
	int offset = *idx;
	char address[40];
	uchar* msgcpy = *msg;
	size_t caddresslen;
	size_t oldLen = *pLenMsg;

	int syn = syntax_ipv6(*msg + offset, *pLenMsg - offset, &amp;iplen);
	if(syn) {
		assert(iplen &lt; sizeof(address));  //has to be &lt; instead of &lt;= since address includes space for a '\0'
		getip(*msg + offset, iplen, address);
		offset += iplen;
		process_IPv6(address, pWrkrData, iplen);

		caddresslen = strlen(address);
		*hasChanged = 1;

		if(caddresslen != iplen) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, address, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}


static size_t
findV4Start(const uchar *const __restrict__ buf, size_t dotPos)
{
	while(dotPos &gt; 0) {
		if(buf[dotPos] == ':') {
			return dotPos + 1;
		}
		dotPos--;
	}
	return -1; //should not happen
}


static int
syntax_embedded(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed,
	size_t * v4Start)
{
	int lastSep = 0;
	sbool hadAbbrev = 0;
	int ipParts = 0;
	int numLen;
	int isIP = 0;
	size_t ipv4Len;

	while(*nprocessed &lt; buflen) {
		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 1);
		if(numLen &gt; 0) {  //found a valid num
			if((ipParts == 6 &amp;&amp; hadAbbrev) || ipParts &gt; 6) {  //is 6 since the first part of
									  //IPv4 will also result in a valid hexvalue
				isIP = 0;
				goto done;
			}
			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
				isIP = 0;
				goto done;
			}
			lastSep = 0;
			ipParts++;
		} else if (numLen == -1) {  //':'
			if(lastSep) {
				if(hadAbbrev) {
					isIP = 0;
					goto done;
				} else {
					hadAbbrev = 1;
				}
			}
			lastSep = 1;
		} else if (numLen == -2) {  //'.'
			if (lastSep || (ipParts == 0 &amp;&amp; hadAbbrev) || (ipParts &lt;= 6 &amp;&amp; !hadAbbrev)) {
				isIP = 0;
				goto done;
			}
			*v4Start = findV4Start(buf, (*nprocessed) - 1);
			if(syntax_ipv4(buf + (*v4Start), buflen, &amp;ipv4Len)) {
				*nprocessed += (ipv4Len - ((*nprocessed) - (*v4Start)));
				isIP = 1;
				goto done;
			} else {
				isIP = 0;
				goto done;
			}
		} else {  //no valid num
			isIP = 0;
			goto done;
		}
	}

	isIP = 0;

done:
	return isIP;
}


static void
embedded2num(char* address, size_t v4Start, struct ipv6_int* ip)
{
	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	int cyc = 0;
	int dots = 0;
	int val;
	unsigned i;

	unsigned v4Val = ipv42num(address + v4Start);
	num[7] = v4Val &amp; 0xffff;
	num[6] = (v4Val &amp; 0xffff0000) &gt;&gt; 16;

	for(i = 0; i &lt; v4Start &amp;&amp; dots &lt; 2; i++) {
		val = getHexVal(address[i]);
		if(val == -1) {
			dots++;
			if(dots &lt; 2) {
				cyc++;
			}
		} else {
			num[cyc] = num[cyc] * 16 + val;
			dots = 0;
		}
	}
	if(dots == 2) {
		if(i &lt; v4Start) {
			int shift = 0;
			cyc = 5;
			for(unsigned j = v4Start - 1; j &gt;= i; j--) {
				val = getHexVal(address[j]);
				if(val == -1) {
					cyc--;
					shift = 0;
				} else {
					val &lt;&lt;= shift;
					shift += 4;
					num[cyc] += val;
				}
			}
		} else {
			while(cyc &lt; 6) {
				num[cyc] = 0;
				cyc++;
			}
		}
	}

	for(i = 0; i &lt; 4; i++) {
		ip-&gt;high &lt;&lt;= 16;
		ip-&gt;high |= num[i];
	}
	while(i &lt; 8) {
		ip-&gt;low &lt;&lt;= 16;
		ip-&gt;low |= num[i];
		i++;
	}
}


static void
process_embedded (char* address, wrkrInstanceData_t *pWrkrData, size_t v4Start)
{
	struct ipv6_int num = {0, 0};

	embedded2num(address, v4Start, &amp;num);

	if(pWrkrData-&gt;pData-&gt;embeddedIPv4.randConsis) {
		findIPv6(&amp;num, address, pWrkrData, 1);
	} else {
		code_ipv6_int(&amp;num, pWrkrData, 1);
		num2embedded(&amp;num, address);
	}
}


static void
anonEmbedded(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	size_t iplen = 0;
	int offset = *idx;
	char address[46];
	uchar* msgcpy = *msg;
	unsigned caddresslen;
	size_t oldLen = *pLenMsg;
	size_t v4Start;

	int syn = syntax_embedded(*msg + offset, *pLenMsg - offset, &amp;iplen, &amp;v4Start);
	if(syn) {
		assert(iplen &lt; sizeof(address));
		getip(*msg + offset, iplen, address);
		offset += iplen;
		process_embedded(address, pWrkrData, v4Start);

		caddresslen = strlen(address);
		*hasChanged = 1;

		if(caddresslen != iplen) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, address, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}

BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	uchar *msg;
	int lenMsg;
	int i;
	int hasChanged = 0;
CODESTARTdoAction
	lenMsg = getMSGLen(pMsg);
	msg = (uchar*)strdup((char*)getMSG(pMsg));

	for(i = 0 ; i &lt;= lenMsg - 2 ; i++) {
		if(pWrkrData-&gt;pData-&gt;embeddedIPv4.enable) {
			anonEmbedded(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
		if(pWrkrData-&gt;pData-&gt;ipv4.enable) {
			anonipv4(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
		if(pWrkrData-&gt;pData-&gt;ipv6.enable) {
			anonipv6(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
	}
	if(hasChanged) {
		MsgReplaceMSG(pMsg, msg, lenMsg);
	}
	free(msg);
ENDdoAction


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt



BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;mmanon: module compiled with rsyslog version %s.\n&quot;, VERSION);
ENDmodInit
</PRE>
</div>
  </div>
</body>
</html>
