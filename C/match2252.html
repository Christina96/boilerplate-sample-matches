<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmdblookup.c &amp; mmanon.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmdblookup.c &amp; mmanon.c
      </h3>
<h1 align="center">
        5.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmdblookup.c (13.043478%)<th>mmanon.c (3.1746032%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(242-261)<td><a href="#" name="0">(228-247)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(98-107)<td><a href="#" name="1">(124-133)</a><td align="center"><font color="#f00000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(77-87)<td><a href="#" name="2">(108-116)</a><td align="center"><font color="#b80000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmdblookup.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include &lt;pthread.h&gt;
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "parserif.h"
20 #include "maxminddb.h"
21 #define JSON_IPLOOKUP_NAME "!iplocation"
22 MODULE_TYPE_OUTPUT
23 MODULE_TYPE_NOKEEP
24 MODULE_CNFNAME("mmdblookup")
25 DEF_OMOD_STATIC_DATA
26 typedef struct _instanceData {
27 	char *pszKey;
28 	char *pszMmdbFile;
29 	struct {
30 		int     nmemb;
31 		char **name;
32 		char **varname;
33 	} fieldList;
34 	sbool reloadOnHup;
35 } instanceData;
36 typedef struct wrkrInstanceData {
37 	instanceData *pData;
38 	MMDB_s        mmdb;
39 	pthread_mutex_t mmdbMutex;
40 } wrkrInstanceData_t;
41 struct modConfData_s {
42 <a name="2"></a>		rsconf_t *pConf;
43 	const char *container;
44 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
45 static modConfData_t *loadModConf = NULL;
46 static modConfData_t *runModConf  = NULL;
47 static struct cnfparamdescr modpdescr[] = {
48 	{ "container", eCmdHdlrGetWord, 0 },</b></font>
49 };
50 static struct cnfparamblk modpblk =
51 	{ CNFPARAMBLK_VERSION,
52 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
53 	  modpdescr
54 	};
55 static struct cnfparamdescr actpdescr[] = {
56 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "key",      eCmdHdlrGetWord, CNFPARAM_REQUIRED },
57 	{ "mmdbfile", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
58 	{ "fields",   eCmdHdlrArray,   CNFPARAM_REQUIRED },
59 	{ "reloadonhup", eCmdHdlrBinary, 0 },
60 };
61 static struct cnfparamblk actpblk = {
62 	CNFPARAMBLK_VERSION,
63 	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
64 	actpdescr
65 };</b></font>
66 void str_split(char **membuf);
67 int open_mmdb(const char *file, MMDB_s *mmdb);
68 void close_mmdb(MMDB_s *mmdb);
69 int open_mmdb(const char *file, MMDB_s *mmdb) {
70 	int status = MMDB_open(file, MMDB_MODE_MMAP, mmdb);
71 	if (MMDB_SUCCESS != status) {
72 		dbgprintf("Can't open %s - %s\n", file, MMDB_strerror(status));
73 		if (MMDB_IO_ERROR == status) {
74 			dbgprintf("  IO error: %s\n", strerror(errno));
75 		}
76 		LogError(0, RS_RET_SUSPENDED, "maxminddb error: cannot open database file");
77 	}
78 	return MMDB_SUCCESS != status;
79 }
80 void close_mmdb(MMDB_s *mmdb) {
81 	MMDB_close(mmdb);
82 }
83 BEGINbeginCnfLoad
84 CODESTARTbeginCnfLoad
85 	loadModConf = pModConf;
86 	pModConf-&gt;pConf = pConf;
87 ENDbeginCnfLoad
88 BEGINendCnfLoad
89 CODESTARTendCnfLoad
90 ENDendCnfLoad
91 BEGINcheckCnf
92 CODESTARTcheckCnf
93 ENDcheckCnf
94 BEGINactivateCnf
95 CODESTARTactivateCnf
96 	runModConf = pModConf;
97 ENDactivateCnf
98 BEGINfreeCnf
99 CODESTARTfreeCnf
100 	free((void*)runModConf-&gt;container);
101 ENDfreeCnf
102 BEGINcreateInstance
103 CODESTARTcreateInstance
104 ENDcreateInstance
105 BEGINcreateWrkrInstance
106 CODESTARTcreateWrkrInstance
107 	CHKiRet(open_mmdb(pData-&gt;pszMmdbFile, &amp;pWrkrData-&gt;mmdb));
108 	CHKiConcCtrl(pthread_mutex_init(&amp;pWrkrData-&gt;mmdbMutex, NULL));
109 finalize_it:
110 ENDcreateWrkrInstance
111 BEGINisCompatibleWithFeature
112 CODESTARTisCompatibleWithFeature
113 ENDisCompatibleWithFeature
114 BEGINfreeInstance
115 CODESTARTfreeInstance
116 	if(pData-&gt;fieldList.name != NULL) {
117 		for(int i = 0 ; i &lt; pData-&gt;fieldList.nmemb ; ++i) {
118 			free(pData-&gt;fieldList.name[i]);
119 			free(pData-&gt;fieldList.varname[i]);
120 		}
121 		free(pData-&gt;fieldList.name);
122 		free(pData-&gt;fieldList.varname);
123 	}
124 	free(pData-&gt;pszKey);
125 	free(pData-&gt;pszMmdbFile);
126 ENDfreeInstance
127 BEGINfreeWrkrInstance
128 CODESTARTfreeWrkrInstance
129 	close_mmdb(&amp;pWrkrData-&gt;mmdb);
130 	pthread_mutex_destroy(&amp;pWrkrData-&gt;mmdbMutex);
131 ENDfreeWrkrInstance
132 BEGINsetModCnf
133 	struct cnfparamvals *pvals = NULL;
134 	int i;
135 CODESTARTsetModCnf
136 	loadModConf-&gt;container = NULL;
137 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
138 	if(pvals == NULL) {
139 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmdblookup: error processing module "
140 						"config parameters missing [module(...)]");
141 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
142 	}
143 	if(Debug) {
144 		dbgprintf("module (global) param blk for mmdblookup:\n");
145 		cnfparamsPrint(&amp;modpblk, pvals);
146 	}
147 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
148 		if(!pvals[i].bUsed)
149 			continue;
150 		if(!strcmp(modpblk.descr[i].name, "container")) {
151 			loadModConf-&gt;container = es_str2cstr(pvals[i].val.d.estr, NULL);
152 		} else {
153 			dbgprintf("mmdblookup: program error, non-handled "
154 					  "param '%s' in setModCnf\n", modpblk.descr[i].name);
155 		}
156 	}
157 	if(loadModConf-&gt;container == NULL) {
158 		CHKmalloc(loadModConf-&gt;container = strdup(JSON_IPLOOKUP_NAME));
159 	}
160 finalize_it:
161 	if(pvals != NULL)
162 		cnfparamvalsDestruct(pvals, &amp;modpblk);
163 ENDsetModCnf
164 static inline void
165 setInstParamDefaults(instanceData *pData)
166 {
167 	pData-&gt;pszKey = NULL;
168 <a name="0"></a>	pData-&gt;pszMmdbFile = NULL;
169 	pData-&gt;fieldList.nmemb = 0;
170 	pData-&gt;reloadOnHup = 1;
171 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
172 BEGINnewActInst
173 	struct cnfparamvals *pvals;
174 	int i;
175 CODESTARTnewActInst
176 	dbgprintf("newActInst (mmdblookup)\n");
177 	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
178 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
179 	}
180 	CODE_STD_STRING_REQUESTnewActInst(1)
181 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
182 	CHKiRet(createInstance(&amp;pData));
183 	setInstParamDefaults(pData);
184 	for (i = 0; i &lt; actpblk.nParams; ++i) {
185 		if (!pvals[i].bUsed)
186 			continue;
187 		if (!strcmp(actpblk.descr[i].name, "key")) {</b></font>
188 			pData-&gt;pszKey = es_str2cstr(pvals[i].val.d.estr, NULL);
189 		} else if (!strcmp(actpblk.descr[i].name, "mmdbfile")) {
190 			pData-&gt;pszMmdbFile = es_str2cstr(pvals[i].val.d.estr, NULL);
191 		} else if (!strcmp(actpblk.descr[i].name, "fields")) {
192 			pData-&gt;fieldList.nmemb = pvals[i].val.d.ar-&gt;nmemb;
193 			CHKmalloc(pData-&gt;fieldList.name = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
194 			CHKmalloc(pData-&gt;fieldList.varname = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
195 			for (int j = 0; j &lt;  pvals[i].val.d.ar-&gt;nmemb; ++j) {
196 				char *const param = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
197 				char *varname = NULL;
198 				char *name;
199 				if(*param == ':') {
200 					char *b = strchr(param+1, ':');
201 					if(b == NULL) {
202 						parser_errmsg("mmdblookup: missing closing colon: '%s'", param);
203 						ABORT_FINALIZE(RS_RET_ERR);
204 					}
205 					*b = '\0'; 					varname = param+1;
206 					name = b+1;
207 				} else {
208 					name = param;
209 				}
210 				if(*name == '!')
211 					++name;
212 				CHKmalloc(pData-&gt;fieldList.name[j] = strdup(name));
213 				char vnamebuf[1024];
214 				snprintf(vnamebuf, sizeof(vnamebuf),
215 					"%s!%s", loadModConf-&gt;container,
216 					(varname == NULL) ? name : varname);
217 				CHKmalloc(pData-&gt;fieldList.varname[j] = strdup(vnamebuf));
218 				free(param);
219 			}
220 		} else if(!strcmp(actpblk.descr[i].name, "reloadonhup")) {
221 			pData-&gt;reloadOnHup = pvals[i].val.d.n;
222 		} else {
223 			dbgprintf("mmdblookup: program error, non-handled"
224 				" param '%s'\n", actpblk.descr[i].name);
225 		}
226 	}
227 CODE_STD_FINALIZERnewActInst
228 	cnfparamvalsDestruct(pvals, &amp;actpblk);
229 ENDnewActInst
230 BEGINdbgPrintInstInfo
231 CODESTARTdbgPrintInstInfo
232 ENDdbgPrintInstInfo
233 BEGINtryResume
234 CODESTARTtryResume
235 ENDtryResume
236 void
237 str_split(char **membuf)
238 {
239 	int in_quotes = 0;
240 	char *buf  = *membuf;
241 	char tempbuf[strlen(buf)];
242 	memset(tempbuf, 0, strlen(buf));
243 	while (*buf++ != '\0') {
244 		if (in_quotes) {
245 			if (*buf == '"' &amp;&amp; *(buf - 1) != '\\') {
246 				in_quotes = !in_quotes;
247 				strncat(tempbuf, buf, 1);
248 			} else {
249 				strncat(tempbuf, buf, 1);
250 			}
251 		} else {
252 			if (*buf == '\n' || *buf == '\t' || *buf == ' ')
253 				continue;
254 			if (*buf == '&lt;') {
255 				char *p = strchr(buf, '&gt;');
256 				buf = buf + (int)(p - buf);
257 				strcat(tempbuf, ",");
258 			} else if (*buf == '}') {
259 				strcat(tempbuf, "},");
260 			} else if (*buf == ']') {
261 				strcat(tempbuf, "],");
262 			} else if (*buf == '"' &amp;&amp; *(buf - 1) != '\\') {
263 				in_quotes = !in_quotes;
264 				strncat(tempbuf, buf, 1);
265 			} else {
266 				strncat(tempbuf, buf, 1);
267 			}
268 		}
269 	}
270 	memcpy(*membuf, tempbuf, strlen(tempbuf)+1);
271 }
272 BEGINdoAction_NoStrings
273 	smsg_t **ppMsg = (smsg_t **) pMsgData;
274 	smsg_t *pMsg   = ppMsg[0];
275 	struct json_object *keyjson = NULL;
276 	const char *pszValue;
277 	instanceData *const pData = pWrkrData-&gt;pData;
278 	json_object *total_json = NULL;
279 	MMDB_entry_data_list_s *entry_data_list = NULL;
280 CODESTARTdoAction
281 	msgPropDescr_t pProp;
282 	msgPropDescrFill(&amp;pProp, (uchar*)pData-&gt;pszKey, strlen(pData-&gt;pszKey));
283 	rsRetVal localRet = msgGetJSONPropJSON(pMsg, &amp;pProp, &amp;keyjson);
284 	msgPropDescrDestruct(&amp;pProp);
285 	pthread_mutex_lock(&amp;pWrkrData-&gt;mmdbMutex);
286 	if (localRet != RS_RET_OK) {
287 		ABORT_FINALIZE(RS_RET_OK);
288 	}
289 	pszValue = (char*)json_object_get_string(keyjson);
290 	if(pszValue == NULL) { 		pszValue = "";
291 	}
292 	int gai_err, mmdb_err;
293 	MMDB_lookup_result_s result = MMDB_lookup_string(&amp;pWrkrData-&gt;mmdb, pszValue, &amp;gai_err, &amp;mmdb_err);
294 	if (0 != gai_err) {
295 		dbgprintf("Error from call to getaddrinfo for %s - %s\n", pszValue, gai_strerror(gai_err));
296 		ABORT_FINALIZE(RS_RET_OK);
297 	}
298 	if (MMDB_SUCCESS != mmdb_err) {
299 		dbgprintf("Got an error from the maxminddb library: %s\n", MMDB_strerror(mmdb_err));
300 		ABORT_FINALIZE(RS_RET_OK);
301 	}
302 	if (!result.found_entry) {
303 		dbgprintf("No entry found in database for '%s'\n", pszValue);
304 		ABORT_FINALIZE(RS_RET_OK);
305 	}
306 	int status  = MMDB_get_entry_data_list(&amp;result.entry, &amp;entry_data_list);
307 	if (MMDB_SUCCESS != status) {
308 		dbgprintf("Got an error looking up the entry data - %s\n", MMDB_strerror(status));
309 		ABORT_FINALIZE(RS_RET_OK);
310 	}
311 	size_t  memlen;
312 	char   *membuf;
313 	FILE   *memstream;
314 	CHKmalloc(memstream = open_memstream(&amp;membuf, &amp;memlen));
315 	if (entry_data_list != NULL &amp;&amp; memstream != NULL) {
316 		MMDB_dump_entry_data_list(memstream, entry_data_list, 2);
317 		fflush(memstream);
318 		str_split(&amp;membuf);
319 	}
320 	DBGPRINTF("maxmindb returns: '%s'\n", membuf);
321 	total_json = json_tokener_parse(membuf);
322 	fclose(memstream);
323 	free(membuf);
324 	for (int i = 0 ; i &lt;  pData-&gt;fieldList.nmemb; ++i) {
325 		char *strtok_save;
326 		char buf[(strlen((char *)(pData-&gt;fieldList.name[i])))+1];
327 		strcpy(buf, (char *)pData-&gt;fieldList.name[i]);
328 		json_object *temp_json = total_json;
329 		json_object *sub_obj   = temp_json;
330 		int j = 0;
331 		const char *SEP = "!";
332 		char *s = strtok_r(buf, SEP, &amp;strtok_save);
333 		for (; s != NULL; j++) {
334 			json_object_object_get_ex(temp_json, s, &amp;sub_obj);
335 			temp_json = sub_obj;
336 			s = strtok_r(NULL, SEP, &amp;strtok_save);
337 		}
338 		json_object_get(temp_json);
339 		msgAddJSON(pMsg, (uchar *)pData-&gt;fieldList.varname[i], temp_json, 0, 0);
340 	}
341 finalize_it:
342 	pthread_mutex_unlock(&amp;pWrkrData-&gt;mmdbMutex);
343 	if(entry_data_list != NULL)
344 		MMDB_free_entry_data_list(entry_data_list);
345 	json_object_put(keyjson);
346 	if(total_json != NULL)
347 		json_object_put(total_json);
348 ENDdoAction
349 BEGINdoHUPWrkr
350 CODESTARTdoHUPWrkr
351 	dbgprintf("mmdblookup: HUP received\n");
352 	if (pWrkrData-&gt;pData-&gt;reloadOnHup) {
353 		pthread_mutex_lock(&amp;pWrkrData-&gt;mmdbMutex);
354 		LogMsg(0, NO_ERRCODE, LOG_INFO, "mmdblookup: reloading MMDB file");
355 		close_mmdb(&amp;pWrkrData-&gt;mmdb);
356 		iRet = open_mmdb(pWrkrData-&gt;pData-&gt;pszMmdbFile, &amp;pWrkrData-&gt;mmdb);
357 		pthread_mutex_unlock(&amp;pWrkrData-&gt;mmdbMutex);
358 	}
359 ENDdoHUPWrkr
360 NO_LEGACY_CONF_parseSelectorAct
361 BEGINmodExit
362 CODESTARTmodExit
363 ENDmodExit
364 BEGINqueryEtryPt
365 CODESTARTqueryEtryPt
366 CODEqueryEtryPt_STD_OMOD_QUERIES
367 CODEqueryEtryPt_STD_OMOD8_QUERIES
368 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
369 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
370 CODEqueryEtryPt_STD_CONF2_QUERIES
371 CODEqueryEtryPt_doHUPWrkr
372 ENDqueryEtryPt
373 BEGINmodInit()
374 CODESTARTmodInit
375 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
376 CODEmodInit_QueryRegCFSLineHdlr
377 	dbgprintf("mmdblookup: module compiled with rsyslog version %s.\n", VERSION);
378 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmanon.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include "conf.h"
13 #include "syslogd-types.h"
14 #include "srUtils.h"
15 #include "template.h"
16 #include "module-template.h"
17 #include "errmsg.h"
18 #include "parserif.h"
19 #include "hashtable.h"
20 MODULE_TYPE_OUTPUT
21 MODULE_TYPE_NOKEEP
22 MODULE_CNFNAME("mmanon")
23 DEF_OMOD_STATIC_DATA
24 enum mode {ZERO, RANDOMINT, SIMPLE};
25 union node {
26 	struct {
27 		union node* more;
28 		union node* less;
29 	} pointer;
30 	struct {
31 		char ip_high[16];
32 		char ip_low[16];
33 	} ips;
34 };
35 struct ipv6_int {
36 	unsigned long long high;
37 	unsigned long long low;
38 	};
39 #define SIMPLE_MODE 0	 #define REWRITE_MODE 1	 typedef struct _instanceData {
40 	struct {
41 		sbool enable;
42 		int8_t bits;
43 		union node* Root;
44 		int randConsis;
45 		enum mode mode;
46 		uchar replaceChar;
47 	} ipv4;
48 	struct {
49 		sbool enable;
50 		uint8_t bits;
51 		enum mode anonmode;
52 		int randConsis;
53 		struct hashtable* hash;
54 	} ipv6;
55 	struct {
56 		sbool enable;
57 		uint8_t bits;
58 		enum mode anonmode;
59 		int randConsis;
60 		struct hashtable* hash;
61 	} embeddedIPv4;
62 } instanceData;
63 typedef struct wrkrInstanceData {
64 	instanceData *pData;
65 	unsigned randstatus;
66 } wrkrInstanceData_t;
67 <a name="2"></a>
68 struct modConfData_s {
69 	rsconf_t *pConf;	<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
70 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
71 static struct cnfparamdescr actpdescr[] = {
72 	{ "ipv4.enable", eCmdHdlrBinary, 0 },</b></font>
73 	{ "ipv4.mode", eCmdHdlrGetWord, 0 },
74 	{ "mode", eCmdHdlrGetWord, 0 },
75 	{ "ipv4.bits", eCmdHdlrPositiveInt, 0 },
76 	{ "ipv4.replacechar", eCmdHdlrGetChar, 0},
77 <a name="1"></a>	{ "replacementchar", eCmdHdlrGetChar, 0},
78 	{ "ipv6.enable", eCmdHdlrBinary, 0 },
79 	{ "ipv6.anonmode", eCmdHdlrGetWord, 0 },
80 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "ipv6.bits", eCmdHdlrPositiveInt, 0 },
81 	{ "embeddedipv4.enable", eCmdHdlrBinary, 0 },
82 	{ "embeddedipv4.anonmode", eCmdHdlrGetWord, 0 },
83 	{ "embeddedipv4.bits", eCmdHdlrPositiveInt, 0 }
84 };
85 static struct cnfparamblk actpblk =
86 	{ CNFPARAMBLK_VERSION,
87 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
88 	  actpdescr
89 	};</b></font>
90 BEGINbeginCnfLoad
91 CODESTARTbeginCnfLoad
92 	loadModConf = pModConf;
93 	pModConf-&gt;pConf = pConf;
94 ENDbeginCnfLoad
95 BEGINendCnfLoad
96 CODESTARTendCnfLoad
97 ENDendCnfLoad
98 BEGINcheckCnf
99 CODESTARTcheckCnf
100 ENDcheckCnf
101 BEGINactivateCnf
102 CODESTARTactivateCnf
103 	runModConf = pModConf;
104 ENDactivateCnf
105 BEGINfreeCnf
106 CODESTARTfreeCnf
107 ENDfreeCnf
108 BEGINcreateInstance
109 CODESTARTcreateInstance
110 ENDcreateInstance
111 BEGINcreateWrkrInstance
112 CODESTARTcreateWrkrInstance
113 	pWrkrData-&gt;randstatus = time(NULL);
114 ENDcreateWrkrInstance
115 BEGINisCompatibleWithFeature
116 CODESTARTisCompatibleWithFeature
117 ENDisCompatibleWithFeature
118 static void
119 delTree(union node* node, const int layer)
120 {
121 	if(node == NULL){
122 		return;
123 	}
124 	if(layer == 31){
125 		free(node);
126 	} else {
127 		delTree(node-&gt;pointer.more, layer + 1);
128 		delTree(node-&gt;pointer.less, layer + 1);
129 		free(node);
130 	}
131 }
132 BEGINfreeInstance
133 CODESTARTfreeInstance
134 	delTree(pData-&gt;ipv4.Root, 0);
135 	if(pData-&gt;ipv6.hash != NULL) {
136 		hashtable_destroy(pData-&gt;ipv6.hash, 1);
137 	}
138 	if(pData-&gt;embeddedIPv4.hash != NULL) {
139 		hashtable_destroy(pData-&gt;embeddedIPv4.hash, 1);
140 	}
141 ENDfreeInstance
142 BEGINfreeWrkrInstance
143 CODESTARTfreeWrkrInstance
144 ENDfreeWrkrInstance
145 static inline void
146 setInstParamDefaults(instanceData *pData)
147 {
148 		pData-&gt;ipv4.enable = 1;
149 		pData-&gt;ipv4.bits = 16;
150 		pData-&gt;ipv4.Root = NULL;
151 		pData-&gt;ipv4.randConsis = 0;
152 		pData-&gt;ipv4.mode = ZERO;
153 		pData-&gt;ipv4.replaceChar = 'x';
154 		pData-&gt;ipv6.enable = 1;
155 		pData-&gt;ipv6.bits = 96;
156 		pData-&gt;ipv6.anonmode = ZERO;
157 		pData-&gt;ipv6.randConsis = 0;
158 		pData-&gt;ipv6.hash = NULL;
159 		pData-&gt;embeddedIPv4.enable = 1;
160 		pData-&gt;embeddedIPv4.bits = 96;
161 <a name="0"></a>		pData-&gt;embeddedIPv4.anonmode = ZERO;
162 		pData-&gt;embeddedIPv4.randConsis = 0;
163 		pData-&gt;embeddedIPv4.hash = NULL;
164 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
165 BEGINnewActInst
166 	struct cnfparamvals *pvals;
167 	int i;
168 CODESTARTnewActInst
169 	DBGPRINTF("newActInst (mmanon)\n");
170 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
171 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
172 	}
173 	CODE_STD_STRING_REQUESTnewActInst(1)
174 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
175 	CHKiRet(createInstance(&amp;pData));
176 	setInstParamDefaults(pData);
177 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
178 		if(!pvals[i].bUsed)
179 			continue;
180 		if(!strcmp(actpblk.descr[i].name, "ipv4.mode") || !strcmp(actpblk.descr[i].name, "mode")) {</b></font>
181 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
182 					 sizeof("zero")-1)) {
183 				pData-&gt;ipv4.mode = ZERO;
184 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
185 					 sizeof("random")-1)) {
186 				pData-&gt;ipv4.mode = RANDOMINT;
187 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"simple",
188 					 sizeof("simple")-1) ||
189 					!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rewrite",
190 					 sizeof("rewrite")-1)) {
191 				pData-&gt;ipv4.mode = SIMPLE;
192 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
193 					 sizeof("random-consistent")-1)) {
194 				pData-&gt;ipv4.mode = RANDOMINT;
195 				pData-&gt;ipv4.randConsis = 1;
196 			} else {
197 				parser_errmsg("mmanon: configuration error, unknown option for ipv4.mode, "
198 					"will use \"zero\"\n");
199 			}
200 		} else if(!strcmp(actpblk.descr[i].name, "ipv4.bits")) {
201 			if((int8_t) pvals[i].val.d.n &lt;= 32) {
202 				pData-&gt;ipv4.bits = (int8_t) pvals[i].val.d.n;
203 			} else {
204 				pData-&gt;ipv4.bits = 32;
205 				parser_errmsg("warning: invalid number of ipv4.bits (%d), corrected "
206 				"to 32", (int) pvals[i].val.d.n);
207 			}
208 		} else if(!strcmp(actpblk.descr[i].name, "ipv4.enable")) {
209 			pData-&gt;ipv4.enable = (int) pvals[i].val.d.n;
210 		} else if(!strcmp(actpblk.descr[i].name, "ipv4.replacechar") || !strcmp(actpblk.descr[i].name,
211 			"replacementchar")) {
212 			uchar* tmp = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
213 			pData-&gt;ipv4.replaceChar = tmp[0];
214 			free(tmp);
215 		} else if(!strcmp(actpblk.descr[i].name, "ipv6.enable")) {
216 			pData-&gt;ipv6.enable = (int) pvals[i].val.d.n;
217 		} else if(!strcmp(actpblk.descr[i].name, "ipv6.bits")) {
218 			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
219 				pData-&gt;ipv6.bits = (uint8_t) pvals[i].val.d.n;
220 			} else {
221 				pData-&gt;ipv6.bits = 128;
222 				parser_errmsg("warning: invalid number of ipv6.bits (%d), corrected "
223 				"to 128", (int) pvals[i].val.d.n);
224 			}
225 		} else if(!strcmp(actpblk.descr[i].name, "ipv6.anonmode")) {
226 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
227 					 sizeof("zero")-1)) {
228 				pData-&gt;ipv6.anonmode = ZERO;
229 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
230 					 sizeof("random")-1)) {
231 				pData-&gt;ipv6.anonmode = RANDOMINT;
232 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
233 					 sizeof("random-consistent")-1)) {
234 				pData-&gt;ipv6.anonmode = RANDOMINT;
235 				pData-&gt;ipv6.randConsis = 1;
236 			} else {
237 				parser_errmsg("mmanon: configuration error, unknown option for "
238 				"ipv6.anonmode, will use \"zero\"\n");
239 			}
240 		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.enable")) {
241 			pData-&gt;embeddedIPv4.enable = (int) pvals[i].val.d.n;
242 		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.bits")) {
243 			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
244 				pData-&gt;embeddedIPv4.bits = (uint8_t) pvals[i].val.d.n;
245 			} else {
246 				pData-&gt;embeddedIPv4.bits = 128;
247 				parser_errmsg("warning: invalid number of embeddedipv4.bits (%d), "
248 					"corrected to 128", (int) pvals[i].val.d.n);
249 			}
250 		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.anonmode")) {
251 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
252 					 sizeof("zero")-1)) {
253 				pData-&gt;embeddedIPv4.anonmode = ZERO;
254 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
255 					 sizeof("random")-1)) {
256 				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
257 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
258 					 sizeof("random-consistent")-1)) {
259 				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
260 				pData-&gt;embeddedIPv4.randConsis = 1;
261 			} else {
262 				parser_errmsg("mmanon: configuration error, unknown option for ipv6.anonmode, "
263 				"will use \"zero\"\n");
264 			}
265 		} else {
266 			parser_errmsg("mmanon: program error, non-handled "
267 			  "param '%s'\n", actpblk.descr[i].name);
268 		}
269 	}
270 	int bHadBitsErr = 0;
271 	if(pData-&gt;ipv4.mode == SIMPLE) {
272 		if(pData-&gt;ipv4.bits &lt; 8 &amp;&amp; pData-&gt;ipv4.bits &gt; -1) {
273 			pData-&gt;ipv4.bits = 8;
274 			bHadBitsErr = 1;
275 		} else if(pData-&gt;ipv4.bits &lt; 16 &amp;&amp; pData-&gt;ipv4.bits &gt; 8) {
276 			pData-&gt;ipv4.bits = 16;
277 			bHadBitsErr = 1;
278 		} else if(pData-&gt;ipv4.bits &lt; 24 &amp;&amp; pData-&gt;ipv4.bits &gt; 16) {
279 			pData-&gt;ipv4.bits = 24;
280 			bHadBitsErr = 1;
281 		} else if((pData-&gt;ipv4.bits != 32 &amp;&amp; pData-&gt;ipv4.bits &gt; 24) || pData-&gt;ipv4.bits &lt; 0) {
282 			pData-&gt;ipv4.bits = 32;
283 			bHadBitsErr = 1;
284 		}
285 		if(bHadBitsErr) {
286 			LogError(0, RS_RET_INVLD_ANON_BITS,
287 				"mmanon: invalid number of ipv4 bits "
288 				"in simple mode, corrected to %d",
289 				pData-&gt;ipv4.bits);
290 		}
291 	}
292 CODE_STD_FINALIZERnewActInst
293 	cnfparamvalsDestruct(pvals, &amp;actpblk);
294 ENDnewActInst
295 BEGINdbgPrintInstInfo
296 CODESTARTdbgPrintInstInfo
297 ENDdbgPrintInstInfo
298 BEGINtryResume
299 CODESTARTtryResume
300 ENDtryResume
301 static int
302 getHexVal(char c)
303 {
304 	if('0' &lt;= c &amp;&amp; c &lt;= '9') {
305 		return c - '0';
306 	} else if('a' &lt;= c &amp;&amp; c &lt;= 'f') {
307 		return (c - 'a') + 10;
308 	} else if('A' &lt;= c &amp;&amp; c &lt;= 'F') {
309 		return (c - 'A') + 10;
310 	} else {
311 		return -1;
312 	}
313 }
314 static int64_t
315 getPosInt(const uchar *const __restrict__ buf,
316 	const size_t buflen,
317 	size_t *const __restrict__ nprocessed)
318 {
319 	int64_t val = 0;
320 	size_t i;
321 	for(i = 0 ; i &lt; buflen ; i++) {
322 		if('0' &lt;= buf[i] &amp;&amp; buf[i] &lt;= '9')
323 			val = val*10 + buf[i]-'0';
324 		else
325 			break;
326 	}
327 	*nprocessed = i;
328 	if(i == 0)
329 		val = -1;
330 	return val;
331 }
332 static int
333 syntax_ipv4(const uchar *const __restrict__ buf,
334 	const size_t buflen,
335 	size_t *const __restrict__ nprocessed)
336 {
337 	int64_t val;
338 	size_t nproc;
339 	size_t i;
340 	int r = 0;
341 	val = getPosInt(buf, buflen, &amp;i);
342 	if(val &lt; 0 || val &gt; 255)
343 		goto done;
344 	if(i &gt;= buflen || buf[i] != '.') {
345 		goto done;
346 	}
347 	i++;
348 	val = getPosInt(buf+i, buflen-i, &amp;nproc);
349 	if(val &lt; 0 || val &gt; 255)
350 		goto done;
351 	i += nproc;
352 	if(i &gt;= buflen || buf[i] != '.') {
353 		goto done;
354 	}
355 	i++;
356 	val = getPosInt(buf+i, buflen-i, &amp;nproc);
357 	if(val &lt; 0 || val &gt; 255)
358 		goto done;
359 	i += nproc;
360 	if(i &gt;= buflen || buf[i] != '.') {
361 		goto done;
362 	}
363 	i++;
364 	val = getPosInt(buf+i, buflen-i, &amp;nproc);
365 	if(val &lt; 0 || val &gt; 255)
366 		goto done;
367 	i += nproc;
368 	*nprocessed = i;
369 	r = 1;
370 done:
371 	return r;
372 }
373 static int
374 isValidHexNum(const uchar *const __restrict__ buf,
375 	const size_t buflen,
376 	size_t *const __restrict__ nprocessed,
377 	int handleDot)
378 {
379 	size_t idx = 0;
380 	int cyc = 0;
381 	while(idx &lt; buflen) {
382 		switch(buf[idx]) {
383 		case '0':
384 		case '1':
385 		case '2':
386 		case '3':
387 		case '4':
388 		case '5':
389 		case '6':
390 		case '7':
391 		case '8':
392 		case '9':
393 		case 'a':
394 		case 'b':
395 		case 'c':
396 		case 'd':
397 		case 'e':
398 		case 'f':
399 		case 'A':
400 		case 'B':
401 		case 'C':
402 		case 'D':
403 		case 'E':
404 		case 'F':
405 			cyc++;
406 			(*nprocessed)++;
407 			if(cyc == 5) {
408 				goto done;
409 			}
410 			break;
411 		case '.':
412 			if(handleDot &amp;&amp; cyc == 0) {
413 				(*nprocessed)++;
414 				cyc = -2;
415 			}
416 			goto done;
417 		case ':':
418 			if(cyc == 0) {
419 				(*nprocessed)++;
420 				cyc = -1;
421 			}
422 			goto done;
423 		default:
424 			goto done;
425 		}
426 		idx++;
427 	}
428 done:
429 	return cyc;
430 }
431 static int
432 syntax_ipv6(const uchar *const __restrict__ buf,
433 	const size_t buflen,
434 	size_t *const __restrict__ nprocessed)
435 {
436 	int lastSep = 0;
437 	sbool hadAbbrev = 0;
438 	sbool lastAbbrev = 0;
439 	int ipParts = 0;
440 	int numLen;
441 	int isIP = 0;
442 	while(*nprocessed &lt; buflen) {
443 		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 0);
444 		if(numLen &gt; 0 &amp;&amp; numLen &lt; 5) {  //found a valid num
445 			if((ipParts == 7 &amp;&amp; hadAbbrev) || ipParts &gt; 7) {
446 				isIP = 0;
447 				goto done;
448 			}
449 			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
450 				isIP = 0;
451 				goto done;
452 			}
453 			lastSep = 0;
454 			lastAbbrev = 0;
455 			ipParts++;
456 		} else if (numLen &lt; 0) {  //':'
457 			if(lastSep) {
458 				if(hadAbbrev) {
459 					isIP = 0;
460 					goto done;
461 				} else {
462 					hadAbbrev = 1;
463 					lastAbbrev = 1;
464 				}
465 			}
466 			lastSep = 1;
467 		} else if (numLen == 5) {  			if(hadAbbrev &amp;&amp; ipParts &gt;= 2) {
468 				isIP = 1;
469 				*nprocessed -= 6;
470 			} else {
471 				isIP = 0;
472 			}
473 			goto done;
474 		} else {  //no valid num
475 			if(lastSep) {
476 				if(lastAbbrev &amp;&amp; ipParts &lt; 8) {
477 					isIP = 1;
478 					goto done;
479 				}
480 				isIP = 0;
481 				goto done;
482 			}
483 			if((ipParts == 8 &amp;&amp; !hadAbbrev) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
484 				isIP = 1;
485 				goto done;
486 			} else {
487 				isIP = 0;
488 				goto done;
489 			}
490 		}
491 		if(ipParts == 8 &amp;&amp; !hadAbbrev) {
492 			isIP = 1;
493 			goto done;
494 		}
495 	}
496 	if((!lastSep &amp;&amp; (ipParts == 8 &amp;&amp; !hadAbbrev)) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
497 		isIP = 1;
498 	}
499 done:
500 	return isIP;
501 }
502 static unsigned
503 ipv42num(const char *str)
504 {
505 	unsigned num[4] = {0, 0, 0, 0};
506 	unsigned value = -1;
507 	size_t len = strlen(str);
508 	int cyc = 0;
509 	for(unsigned i = 0 ; i &lt; len ; i++) {
510 		switch(str[i]) {
511 		case '0':
512 		case '1':
513 		case '2':
514 		case '3':
515 		case '4':
516 		case '5':
517 		case '6':
518 		case '7':
519 		case '8':
520 		case '9':
521 			num[cyc] = num[cyc]*10+(str[i]-'0');
522 			break;
523 		case '.':
524 			cyc++;
525 			break;
526 		}
527 	}
528 	value = num[0]*256*256*256+num[1]*256*256+num[2]*256+num[3];
529 	return(value);
530 }
531 static unsigned
532 code_int(unsigned ip, wrkrInstanceData_t *pWrkrData){
533 	unsigned random;
534 	unsigned long long shiftIP_subst = ip;
535 	switch(pWrkrData-&gt;pData-&gt;ipv4.mode) {
536 	case ZERO:
537 		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
538 		return (unsigned)shiftIP_subst;
539 	case RANDOMINT:
540 		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
541 		random = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*
542 			((1ull&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits))-1));
543 		return (unsigned)shiftIP_subst + random;
544 	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
545 	default:
546 		LogError(0, RS_RET_INTERNAL_ERROR, "mmanon: unexpected code path reached in code_int function");
547 		return 0;
548 	}
549 }
550 static int
551 num2ipv4(unsigned num, char *str) {
552 	int numip[4];
553 	size_t len;
554 	for(int i = 0 ; i &lt; 4 ; i++){
555 		numip[i] = num % 256;
556 		num = num / 256;
557 	}
558 	len = snprintf(str, 16, "%d.%d.%d.%d", numip[3], numip[2], numip[1], numip[0]);
559 	return len;
560 }
561 static void
562 getip(uchar *start, size_t end, char *address)
563 {
564 	size_t i;
565 	for(i = 0; i &lt; end; i++){
566 		address[i] = *(start+i);
567 	}
568 	address[i] = '\0';
569 }
570 static rsRetVal
571 findip(char* address, wrkrInstanceData_t *pWrkrData)
572 {
573 	DEFiRet;
574 	int i;
575 	unsigned num;
576 	union node* current;
577 	union node* Last;
578 	int MoreLess;
579 	char* CurrentCharPtr;
580 	current = pWrkrData-&gt;pData-&gt;ipv4.Root;
581 	num = ipv42num(address);
582 	for(i = 0; i &lt; 31; i++){
583 		if(pWrkrData-&gt;pData-&gt;ipv4.Root == NULL) {
584 			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
585 			pWrkrData-&gt;pData-&gt;ipv4.Root = current;
586 		}
587 		Last = current;
588 		if((num &gt;&gt; (31 - i)) &amp; 1){
589 			current = current-&gt;pointer.more;
590 			MoreLess = 1;
591 		} else {
592 			current = current-&gt;pointer.less;
593 			MoreLess = 0;
594 		}
595 		if(current == NULL){
596 			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
597 			if(MoreLess == 1){
598 				Last-&gt;pointer.more = current;
599 			} else {
600 				Last-&gt;pointer.less = current;
601 			}
602 		}
603 	}
604 	if(num &amp; 1){
605 		CurrentCharPtr = current-&gt;ips.ip_high;
606 	} else {
607 		CurrentCharPtr = current-&gt;ips.ip_low;
608 	}
609 	if(CurrentCharPtr[0] != '\0'){
610 		strcpy(address, CurrentCharPtr);
611 	} else {
612 		num = code_int(num, pWrkrData);
613 		num2ipv4(num, CurrentCharPtr);
614 		strcpy(address, CurrentCharPtr);
615 	}
616 finalize_it:
617 	RETiRet;
618 }
619 static void
620 process_IPv4 (char* address, wrkrInstanceData_t *pWrkrData)
621 {
622 	unsigned num;
623 	if(pWrkrData-&gt;pData-&gt;ipv4.randConsis){
624 		findip(address, pWrkrData);
625 	}else {
626 		num = ipv42num(address);
627 		num = code_int(num, pWrkrData);
628 		num2ipv4(num, address);
629 	}
630 }
631 static void
632 simpleAnon(wrkrInstanceData_t *const pWrkrData, uchar *const msg, int *const hasChanged, int iplen)
633 {
634 	int maxidx = iplen - 1;
635 	int j = -1;
636 	for(int i = (pWrkrData-&gt;pData-&gt;ipv4.bits / 8); i &gt; 0; i--) {
637 		j++;
638 		while('0' &lt;= msg[maxidx - j] &amp;&amp; msg[maxidx - j] &lt;= '9') {
639 			if(msg[maxidx - j] != pWrkrData-&gt;pData-&gt;ipv4.replaceChar) {
640 				msg[maxidx - j] = pWrkrData-&gt;pData-&gt;ipv4.replaceChar;
641 				*hasChanged = 1;
642 			}
643 			j++;
644 		}
645 	}
646 }
647 static void
648 anonipv4(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
649 {
650 	char address[16];
651 	char caddress[16];
652 	int offset = *idx;
653 	uchar* msgcpy = *msg;
654 	size_t iplen;
655 	size_t caddresslen;
656 	int oldLen = *pLenMsg;
657 	if(syntax_ipv4((*msg) + offset, *pLenMsg - offset, &amp;iplen)) {
658 		if(pWrkrData-&gt;pData-&gt;ipv4.mode == SIMPLE) {
659 			simpleAnon(pWrkrData, *msg + *idx, hasChanged, iplen);
660 			*idx += iplen;
661 			return;
662 		}
663 		assert(iplen &lt; sizeof(address));
664 		getip(*msg + offset, iplen, address);
665 		offset += iplen;
666 		strcpy(caddress, address);
667 		process_IPv4(caddress, pWrkrData);
668 		caddresslen = strlen(caddress);
669 		*hasChanged = 1;
670 		if(caddresslen != strlen(address)) {
671 			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)strlen(address));
672 			*msg = (uchar*) malloc(*pLenMsg);
673 			memcpy(*msg, msgcpy, *idx);
674 		}
675 		memcpy(*msg + *idx, caddress, caddresslen);
676 		*idx = *idx + caddresslen;
677 		if(*idx &lt; *pLenMsg) {
678 			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
679 		}
680 		if(msgcpy != *msg) {
681 			free(msgcpy);
682 		}
683 	}
684 }
685 static void
686 code_ipv6_int(struct ipv6_int* ip, wrkrInstanceData_t *pWrkrData, int useEmbedded)
687 {
688 	unsigned long long randlow = 0;
689 	unsigned long long randhigh = 0;
690 	unsigned tmpRand;
691 	int fullbits;
692 	int bits = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.bits : pWrkrData-&gt;pData-&gt;ipv6.bits;
693 	enum mode anonmode = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.anonmode : pWrkrData-&gt;pData-&gt;ipv6.anonmode;
694 	if(bits == 128) { //has to be handled separately, since shift
695 		ip-&gt;high = 0;
696 		ip-&gt;low = 0;
697 	} else if(bits &gt; 64) {
698 		ip-&gt;low = 0;
699 		ip-&gt;high = (ip-&gt;high &gt;&gt; (bits - 64)) &lt;&lt;  (bits - 64);
700 	} else if(bits == 64) {
701 		ip-&gt;low = 0;
702 	} else {
703 		ip-&gt;low = (ip-&gt;low &gt;&gt; bits) &lt;&lt; bits;
704 	}
705 	switch(anonmode) {
706 	case ZERO:
707 		break;
708 	case RANDOMINT:
709 		if(bits == 128) {
710 			for(int i = 0; i &lt; 8; i++) {
711 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
712 				ip-&gt;high &lt;&lt;= 8;
713 				ip-&gt;high |= tmpRand;
714 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
715 				ip-&gt;low &lt;&lt;= 8;
716 				ip-&gt;low |= tmpRand;
717 			}
718 		} else if(bits &gt; 64) {
719 			for(int i = 0; i &lt; 8; i++) {
720 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
721 				ip-&gt;low &lt;&lt;= 8;
722 				ip-&gt;low |= tmpRand;
723 			}
724 			bits -= 64;
725 			fullbits = bits / 8;
726 			bits = bits % 8;
727 			while(fullbits &gt; 0) {
728 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
729 				randhigh &lt;&lt;= 8;
730 				randhigh |= tmpRand;
731 				fullbits--;
732 			}
733 			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
734 			randhigh &lt;&lt;= bits;
735 			randhigh |= tmpRand;
736 			ip-&gt;high |= randhigh;
737 		} else if(bits == 64) {
738 			for(int i = 0; i &lt; 8; i++) {
739 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
740 				ip-&gt;low &lt;&lt;= 8;
741 				ip-&gt;low |= tmpRand;
742 			}
743 		} else {
744 			fullbits = bits / 8;
745 			bits = bits % 8;
746 			while(fullbits &gt; 0) {
747 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
748 				randlow &lt;&lt;= 8;
749 				randlow |= tmpRand;
750 				fullbits--;
751 			}
752 			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
753 			randlow &lt;&lt;= bits;
754 			randlow |= tmpRand;
755 			ip-&gt;low |= randlow;
756 		}
757 		break;
758 	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
759 	default:
760 		LogError(0, RS_RET_INTERNAL_ERROR, "mmanon: unexpected code path reached in code_int function");
761 	}
762 }
763 static void
764 ipv62num(char* const address, const size_t iplen, struct ipv6_int* const ip)
765 {
766 	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
767 	int cyc = 0;
768 	int dots = 0;
769 	int val;
770 	unsigned i;
771 	for(i = 0; i &lt; iplen &amp;&amp; dots &lt; 2; i++) {
772 		val = getHexVal(address[i]);
773 		if(val == -1) {
774 			dots++;
775 			if(dots &lt; 2) {
776 				cyc++;
777 			}
778 		} else {
779 			num[cyc] = num[cyc] * 16 + val;
780 			dots = 0;
781 		}
782 	}
783 	if(dots == 2) {
784 		if(i &lt; iplen - 1) {
785 			int shift = 0;
786 			cyc = 7;
787 			for(unsigned j = iplen - 1; j &gt;= i; j--) {
788 				val = getHexVal(address[j]);
789 				if(val == -1) {
790 					cyc--;
791 					shift = 0;
792 				} else {
793 					val &lt;&lt;= shift;
794 					shift += 4;
795 					num[cyc] += val;
796 				}
797 			}
798 		} else {
799 			while(cyc &lt; 8) {
800 				num[cyc] = 0;
801 				cyc++;
802 			}
803 		}
804 	}
805 	for(i = 0; i &lt; 4; i++) {
806 		ip-&gt;high &lt;&lt;= 16;
807 		ip-&gt;high |= num[i];
808 	}
809 	while(i &lt; 8) {
810 		ip-&gt;low &lt;&lt;= 16;
811 		ip-&gt;low |= num[i];
812 		i++;
813 	}
814 }
815 static void
816 num2ipv6 (struct ipv6_int* ip, char* address)
817 {
818 	int num[8];
819 	int i;
820 	for(i = 7; i &gt; 3; i--) {
821 		num[i] = ip-&gt;low &amp; 0xffff;
822 		ip-&gt;low &gt;&gt;= 16;
823 	}
824 	while(i &gt; -1) {
825 		num[i] = ip-&gt;high &amp; 0xffff;
826 		ip-&gt;high &gt;&gt;= 16;
827 		i--;
828 	}
829 	snprintf(address, 40, "%x:%x:%x:%x:%x:%x:%x:%x", num[0], num[1], num[2], num[3], num[4], num[5],
830 		num[6], num[7]);
831 }
832 static int
833 keys_equal_fn(void* key1, void* key2)
834 {
835 	struct ipv6_int *const k1 = (struct ipv6_int*) key1;
836 	struct ipv6_int *const k2 = (struct ipv6_int*) key2;
837 	return((k1-&gt;high == k2-&gt;high) &amp;&amp; (k1-&gt;low == k2-&gt;low));
838 }
839 static unsigned
840 hash_from_key_fn (void* k)
841 {
842 	struct ipv6_int *const key = (struct ipv6_int*) k;
843 	unsigned hashVal;
844 	hashVal = (key-&gt;high &amp; 0xFFC00000) | (key-&gt;low &amp; 0x3FFFFF);
845 	return hashVal;
846 }
847 static void
848 num2embedded (struct ipv6_int* ip, char* address)
849 {
850 	int num[8];
851 	int i;
852 	for(i = 7; i &gt; 3; i--) {
853 		num[i] = ip-&gt;low &amp; 0xffff;
854 		ip-&gt;low &gt;&gt;= 16;
855 	}
856 	while(i &gt; -1) {
857 		num[i] = ip-&gt;high &amp; 0xffff;
858 		ip-&gt;high &gt;&gt;= 16;
859 		i--;
860 	}
861 	snprintf(address, 46, "%x:%x:%x:%x:%x:%x:%d.%d.%d.%d", num[0], num[1], num[2], num[3], num[4], num[5],
862 		(num[6] &amp; 0xff00) &gt;&gt; 8, num[6] &amp; 0xff, (num[7] &amp; 0xff00) &gt;&gt; 8, num[7] &amp; 0xff);
863 }
864 static rsRetVal
865 findIPv6(struct ipv6_int* num, char* address, wrkrInstanceData_t *const pWrkrData, int useEmbedded)
866 {
867 	struct ipv6_int* hashKey = NULL;
868 	DEFiRet;
869 	struct hashtable* hash = useEmbedded? pWrkrData-&gt;pData-&gt;embeddedIPv4.hash : pWrkrData-&gt;pData-&gt;ipv6.hash;
870 	if(hash == NULL) {
871 		CHKmalloc(hash = create_hashtable(512, hash_from_key_fn, keys_equal_fn, NULL));
872 		if(useEmbedded) {
873 			pWrkrData-&gt;pData-&gt;embeddedIPv4.hash = hash;
874 		} else {
875 			pWrkrData-&gt;pData-&gt;ipv6.hash = hash;
876 		}
877 	}
878 	char* val = (char*)(hashtable_search(hash, num));
879 	if(val != NULL) {
880 		strcpy(address, val);
881 	} else {
882 		CHKmalloc(hashKey = (struct ipv6_int*) malloc(sizeof(struct ipv6_int)));
883 		hashKey-&gt;low = num-&gt;low;
884 		hashKey-&gt;high = num-&gt;high;
885 		if(useEmbedded) {
886 			code_ipv6_int(num, pWrkrData, 1);
887 			num2embedded(num, address);
888 		} else {
889 			code_ipv6_int(num, pWrkrData, 0);
890 			num2ipv6(num, address);
891 		}
892 		char* hashString;
893 		CHKmalloc(hashString = strdup(address));
894 		if(!hashtable_insert(hash, hashKey, hashString)) {
895 			DBGPRINTF("hashtable error: insert to %s-table failed",
896 				useEmbedded ? "embedded ipv4" : "ipv6");
897 			free(hashString);
898 			ABORT_FINALIZE(RS_RET_ERR);
899 		}
900 		hashKey = NULL;
901 	}
902 finalize_it:
903 	free(hashKey);
904 	RETiRet;
905 }
906 static void
907 process_IPv6 (char* address, wrkrInstanceData_t *pWrkrData, const size_t iplen)
908 {
909 	struct ipv6_int num = {0, 0};
910 	ipv62num(address, iplen, &amp;num);
911 	if(pWrkrData-&gt;pData-&gt;ipv6.randConsis) {
912 		findIPv6(&amp;num, address, pWrkrData, 0);
913 	} else {
914 		code_ipv6_int(&amp;num, pWrkrData, 0);
915 		num2ipv6(&amp;num, address);
916 	}
917 }
918 static void
919 anonipv6(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
920 {
921 	size_t iplen = 0;
922 	int offset = *idx;
923 	char address[40];
924 	uchar* msgcpy = *msg;
925 	size_t caddresslen;
926 	size_t oldLen = *pLenMsg;
927 	int syn = syntax_ipv6(*msg + offset, *pLenMsg - offset, &amp;iplen);
928 	if(syn) {
929 		assert(iplen &lt; sizeof(address));  //has to be &lt; instead of &lt;= since address includes space for a '\0'
930 		getip(*msg + offset, iplen, address);
931 		offset += iplen;
932 		process_IPv6(address, pWrkrData, iplen);
933 		caddresslen = strlen(address);
934 		*hasChanged = 1;
935 		if(caddresslen != iplen) {
936 			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
937 			*msg = (uchar*) malloc(*pLenMsg);
938 			memcpy(*msg, msgcpy, *idx);
939 		}
940 		memcpy(*msg + *idx, address, caddresslen);
941 		*idx = *idx + caddresslen;
942 		if(*idx &lt; *pLenMsg) {
943 			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
944 		}
945 		if(msgcpy != *msg) {
946 			free(msgcpy);
947 		}
948 	}
949 }
950 static size_t
951 findV4Start(const uchar *const __restrict__ buf, size_t dotPos)
952 {
953 	while(dotPos &gt; 0) {
954 		if(buf[dotPos] == ':') {
955 			return dotPos + 1;
956 		}
957 		dotPos--;
958 	}
959 	return -1; //should not happen
960 }
961 static int
962 syntax_embedded(const uchar *const __restrict__ buf,
963 	const size_t buflen,
964 	size_t *const __restrict__ nprocessed,
965 	size_t * v4Start)
966 {
967 	int lastSep = 0;
968 	sbool hadAbbrev = 0;
969 	int ipParts = 0;
970 	int numLen;
971 	int isIP = 0;
972 	size_t ipv4Len;
973 	while(*nprocessed &lt; buflen) {
974 		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 1);
975 		if(numLen &gt; 0) {  //found a valid num
976 			if((ipParts == 6 &amp;&amp; hadAbbrev) || ipParts &gt; 6) {  //is 6 since the first part of
977 				isIP = 0;
978 				goto done;
979 			}
980 			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
981 				isIP = 0;
982 				goto done;
983 			}
984 			lastSep = 0;
985 			ipParts++;
986 		} else if (numLen == -1) {  //':'
987 			if(lastSep) {
988 				if(hadAbbrev) {
989 					isIP = 0;
990 					goto done;
991 				} else {
992 					hadAbbrev = 1;
993 				}
994 			}
995 			lastSep = 1;
996 		} else if (numLen == -2) {  //'.'
997 			if (lastSep || (ipParts == 0 &amp;&amp; hadAbbrev) || (ipParts &lt;= 6 &amp;&amp; !hadAbbrev)) {
998 				isIP = 0;
999 				goto done;
1000 			}
1001 			*v4Start = findV4Start(buf, (*nprocessed) - 1);
1002 			if(syntax_ipv4(buf + (*v4Start), buflen, &amp;ipv4Len)) {
1003 				*nprocessed += (ipv4Len - ((*nprocessed) - (*v4Start)));
1004 				isIP = 1;
1005 				goto done;
1006 			} else {
1007 				isIP = 0;
1008 				goto done;
1009 			}
1010 		} else {  //no valid num
1011 			isIP = 0;
1012 			goto done;
1013 		}
1014 	}
1015 	isIP = 0;
1016 done:
1017 	return isIP;
1018 }
1019 static void
1020 embedded2num(char* address, size_t v4Start, struct ipv6_int* ip)
1021 {
1022 	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
1023 	int cyc = 0;
1024 	int dots = 0;
1025 	int val;
1026 	unsigned i;
1027 	unsigned v4Val = ipv42num(address + v4Start);
1028 	num[7] = v4Val &amp; 0xffff;
1029 	num[6] = (v4Val &amp; 0xffff0000) &gt;&gt; 16;
1030 	for(i = 0; i &lt; v4Start &amp;&amp; dots &lt; 2; i++) {
1031 		val = getHexVal(address[i]);
1032 		if(val == -1) {
1033 			dots++;
1034 			if(dots &lt; 2) {
1035 				cyc++;
1036 			}
1037 		} else {
1038 			num[cyc] = num[cyc] * 16 + val;
1039 			dots = 0;
1040 		}
1041 	}
1042 	if(dots == 2) {
1043 		if(i &lt; v4Start) {
1044 			int shift = 0;
1045 			cyc = 5;
1046 			for(unsigned j = v4Start - 1; j &gt;= i; j--) {
1047 				val = getHexVal(address[j]);
1048 				if(val == -1) {
1049 					cyc--;
1050 					shift = 0;
1051 				} else {
1052 					val &lt;&lt;= shift;
1053 					shift += 4;
1054 					num[cyc] += val;
1055 				}
1056 			}
1057 		} else {
1058 			while(cyc &lt; 6) {
1059 				num[cyc] = 0;
1060 				cyc++;
1061 			}
1062 		}
1063 	}
1064 	for(i = 0; i &lt; 4; i++) {
1065 		ip-&gt;high &lt;&lt;= 16;
1066 		ip-&gt;high |= num[i];
1067 	}
1068 	while(i &lt; 8) {
1069 		ip-&gt;low &lt;&lt;= 16;
1070 		ip-&gt;low |= num[i];
1071 		i++;
1072 	}
1073 }
1074 static void
1075 process_embedded (char* address, wrkrInstanceData_t *pWrkrData, size_t v4Start)
1076 {
1077 	struct ipv6_int num = {0, 0};
1078 	embedded2num(address, v4Start, &amp;num);
1079 	if(pWrkrData-&gt;pData-&gt;embeddedIPv4.randConsis) {
1080 		findIPv6(&amp;num, address, pWrkrData, 1);
1081 	} else {
1082 		code_ipv6_int(&amp;num, pWrkrData, 1);
1083 		num2embedded(&amp;num, address);
1084 	}
1085 }
1086 static void
1087 anonEmbedded(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
1088 {
1089 	size_t iplen = 0;
1090 	int offset = *idx;
1091 	char address[46];
1092 	uchar* msgcpy = *msg;
1093 	unsigned caddresslen;
1094 	size_t oldLen = *pLenMsg;
1095 	size_t v4Start;
1096 	int syn = syntax_embedded(*msg + offset, *pLenMsg - offset, &amp;iplen, &amp;v4Start);
1097 	if(syn) {
1098 		assert(iplen &lt; sizeof(address));
1099 		getip(*msg + offset, iplen, address);
1100 		offset += iplen;
1101 		process_embedded(address, pWrkrData, v4Start);
1102 		caddresslen = strlen(address);
1103 		*hasChanged = 1;
1104 		if(caddresslen != iplen) {
1105 			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
1106 			*msg = (uchar*) malloc(*pLenMsg);
1107 			memcpy(*msg, msgcpy, *idx);
1108 		}
1109 		memcpy(*msg + *idx, address, caddresslen);
1110 		*idx = *idx + caddresslen;
1111 		if(*idx &lt; *pLenMsg) {
1112 			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
1113 		}
1114 		if(msgcpy != *msg) {
1115 			free(msgcpy);
1116 		}
1117 	}
1118 }
1119 BEGINdoAction_NoStrings
1120 	smsg_t **ppMsg = (smsg_t **) pMsgData;
1121 	smsg_t *pMsg = ppMsg[0];
1122 	uchar *msg;
1123 	int lenMsg;
1124 	int i;
1125 	int hasChanged = 0;
1126 CODESTARTdoAction
1127 	lenMsg = getMSGLen(pMsg);
1128 	msg = (uchar*)strdup((char*)getMSG(pMsg));
1129 	for(i = 0 ; i &lt;= lenMsg - 2 ; i++) {
1130 		if(pWrkrData-&gt;pData-&gt;embeddedIPv4.enable) {
1131 			anonEmbedded(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
1132 		}
1133 		if(pWrkrData-&gt;pData-&gt;ipv4.enable) {
1134 			anonipv4(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
1135 		}
1136 		if(pWrkrData-&gt;pData-&gt;ipv6.enable) {
1137 			anonipv6(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
1138 		}
1139 	}
1140 	if(hasChanged) {
1141 		MsgReplaceMSG(pMsg, msg, lenMsg);
1142 	}
1143 	free(msg);
1144 ENDdoAction
1145 NO_LEGACY_CONF_parseSelectorAct
1146 BEGINmodExit
1147 CODESTARTmodExit
1148 ENDmodExit
1149 BEGINqueryEtryPt
1150 CODESTARTqueryEtryPt
1151 CODEqueryEtryPt_STD_OMOD_QUERIES
1152 CODEqueryEtryPt_STD_OMOD8_QUERIES
1153 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1154 CODEqueryEtryPt_STD_CONF2_QUERIES
1155 ENDqueryEtryPt
1156 BEGINmodInit()
1157 CODESTARTmodInit
1158 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1159 	DBGPRINTF("mmanon: module compiled with rsyslog version %s.\n", VERSION);
1160 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
