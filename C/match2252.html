<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmdblookup.c &amp; mmanon.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmdblookup.c &amp; mmanon.c
      </h3>
<h1 align="center">
        5.1%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmdblookup.c (13.043478%)<th>mmanon.c (3.1746032%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(242-261)<td><a href="#" name="0">(228-247)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(98-107)<td><a href="#" name="1">(124-133)</a><td align="center"><font color="#f00000">17</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(77-87)<td><a href="#" name="2">(108-116)</a><td align="center"><font color="#b80000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmdblookup.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;pthread.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "parserif.h"
#include "maxminddb.h"
#define JSON_IPLOOKUP_NAME "!iplocation"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmdblookup")
DEF_OMOD_STATIC_DATA
typedef struct _instanceData {
	char *pszKey;
	char *pszMmdbFile;
	struct {
		int     nmemb;
		char **name;
		char **varname;
	} fieldList;
	sbool reloadOnHup;
} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	MMDB_s        mmdb;
	pthread_mutex_t mmdbMutex;
} wrkrInstanceData_t;
struct modConfData_s {
<a name="2"></a>		rsconf_t *pConf;
	const char *container;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
static modConfData_t *loadModConf = NULL;
static modConfData_t *runModConf  = NULL;
static struct cnfparamdescr modpdescr[] = {
	{ "container", eCmdHdlrGetWord, 0 },</b></font>
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static struct cnfparamdescr actpdescr[] = {
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "key",      eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ "mmdbfile", eCmdHdlrGetWord, CNFPARAM_REQUIRED },
	{ "fields",   eCmdHdlrArray,   CNFPARAM_REQUIRED },
	{ "reloadonhup", eCmdHdlrBinary, 0 },
};
static struct cnfparamblk actpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	actpdescr
};</b></font>
void str_split(char **membuf);
int open_mmdb(const char *file, MMDB_s *mmdb);
void close_mmdb(MMDB_s *mmdb);
int open_mmdb(const char *file, MMDB_s *mmdb) {
	int status = MMDB_open(file, MMDB_MODE_MMAP, mmdb);
	if (MMDB_SUCCESS != status) {
		dbgprintf("Can't open %s - %s\n", file, MMDB_strerror(status));
		if (MMDB_IO_ERROR == status) {
			dbgprintf("  IO error: %s\n", strerror(errno));
		}
		LogError(0, RS_RET_SUSPENDED, "maxminddb error: cannot open database file");
	}
	return MMDB_SUCCESS != status;
}
void close_mmdb(MMDB_s *mmdb) {
	MMDB_close(mmdb);
}
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad
BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
	free((void*)runModConf-&gt;container);
ENDfreeCnf
BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	CHKiRet(open_mmdb(pData-&gt;pszMmdbFile, &amp;pWrkrData-&gt;mmdb));
	CHKiConcCtrl(pthread_mutex_init(&amp;pWrkrData-&gt;mmdbMutex, NULL));
finalize_it:
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature
BEGINfreeInstance
CODESTARTfreeInstance
	if(pData-&gt;fieldList.name != NULL) {
		for(int i = 0 ; i &lt; pData-&gt;fieldList.nmemb ; ++i) {
			free(pData-&gt;fieldList.name[i]);
			free(pData-&gt;fieldList.varname[i]);
		}
		free(pData-&gt;fieldList.name);
		free(pData-&gt;fieldList.varname);
	}
	free(pData-&gt;pszKey);
	free(pData-&gt;pszMmdbFile);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	close_mmdb(&amp;pWrkrData-&gt;mmdb);
	pthread_mutex_destroy(&amp;pWrkrData-&gt;mmdbMutex);
ENDfreeWrkrInstance
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	loadModConf-&gt;container = NULL;
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmdblookup: error processing module "
						"config parameters missing [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for mmdblookup:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "container")) {
			loadModConf-&gt;container = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("mmdblookup: program error, non-handled "
					  "param '%s' in setModCnf\n", modpblk.descr[i].name);
		}
	}
	if(loadModConf-&gt;container == NULL) {
		CHKmalloc(loadModConf-&gt;container = strdup(JSON_IPLOOKUP_NAME));
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;pszKey = NULL;
<a name="0"></a>	pData-&gt;pszMmdbFile = NULL;
	pData-&gt;fieldList.nmemb = 0;
	pData-&gt;reloadOnHup = 1;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	dbgprintf("newActInst (mmdblookup)\n");
	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for (i = 0; i &lt; actpblk.nParams; ++i) {
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(actpblk.descr[i].name, "key")) {</b></font>
			pData-&gt;pszKey = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "mmdbfile")) {
			pData-&gt;pszMmdbFile = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "fields")) {
			pData-&gt;fieldList.nmemb = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(pData-&gt;fieldList.name = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
			CHKmalloc(pData-&gt;fieldList.varname = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
			for (int j = 0; j &lt;  pvals[i].val.d.ar-&gt;nmemb; ++j) {
				char *const param = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				char *varname = NULL;
				char *name;
				if(*param == ':') {
					char *b = strchr(param+1, ':');
					if(b == NULL) {
						parser_errmsg("mmdblookup: missing closing colon: '%s'", param);
						ABORT_FINALIZE(RS_RET_ERR);
					}
					*b = '\0'; 					varname = param+1;
					name = b+1;
				} else {
					name = param;
				}
				if(*name == '!')
					++name;
				CHKmalloc(pData-&gt;fieldList.name[j] = strdup(name));
				char vnamebuf[1024];
				snprintf(vnamebuf, sizeof(vnamebuf),
					"%s!%s", loadModConf-&gt;container,
					(varname == NULL) ? name : varname);
				CHKmalloc(pData-&gt;fieldList.varname[j] = strdup(vnamebuf));
				free(param);
			}
		} else if(!strcmp(actpblk.descr[i].name, "reloadonhup")) {
			pData-&gt;reloadOnHup = pvals[i].val.d.n;
		} else {
			dbgprintf("mmdblookup: program error, non-handled"
				" param '%s'\n", actpblk.descr[i].name);
		}
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo
BEGINtryResume
CODESTARTtryResume
ENDtryResume
void
str_split(char **membuf)
{
	int in_quotes = 0;
	char *buf  = *membuf;
	char tempbuf[strlen(buf)];
	memset(tempbuf, 0, strlen(buf));
	while (*buf++ != '\0') {
		if (in_quotes) {
			if (*buf == '"' &amp;&amp; *(buf - 1) != '\\') {
				in_quotes = !in_quotes;
				strncat(tempbuf, buf, 1);
			} else {
				strncat(tempbuf, buf, 1);
			}
		} else {
			if (*buf == '\n' || *buf == '\t' || *buf == ' ')
				continue;
			if (*buf == '&lt;') {
				char *p = strchr(buf, '&gt;');
				buf = buf + (int)(p - buf);
				strcat(tempbuf, ",");
			} else if (*buf == '}') {
				strcat(tempbuf, "},");
			} else if (*buf == ']') {
				strcat(tempbuf, "],");
			} else if (*buf == '"' &amp;&amp; *(buf - 1) != '\\') {
				in_quotes = !in_quotes;
				strncat(tempbuf, buf, 1);
			} else {
				strncat(tempbuf, buf, 1);
			}
		}
	}
	memcpy(*membuf, tempbuf, strlen(tempbuf)+1);
}
BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg   = ppMsg[0];
	struct json_object *keyjson = NULL;
	const char *pszValue;
	instanceData *const pData = pWrkrData-&gt;pData;
	json_object *total_json = NULL;
	MMDB_entry_data_list_s *entry_data_list = NULL;
CODESTARTdoAction
	msgPropDescr_t pProp;
	msgPropDescrFill(&amp;pProp, (uchar*)pData-&gt;pszKey, strlen(pData-&gt;pszKey));
	rsRetVal localRet = msgGetJSONPropJSON(pMsg, &amp;pProp, &amp;keyjson);
	msgPropDescrDestruct(&amp;pProp);
	pthread_mutex_lock(&amp;pWrkrData-&gt;mmdbMutex);
	if (localRet != RS_RET_OK) {
		ABORT_FINALIZE(RS_RET_OK);
	}
	pszValue = (char*)json_object_get_string(keyjson);
	if(pszValue == NULL) { 		pszValue = "";
	}
	int gai_err, mmdb_err;
	MMDB_lookup_result_s result = MMDB_lookup_string(&amp;pWrkrData-&gt;mmdb, pszValue, &amp;gai_err, &amp;mmdb_err);
	if (0 != gai_err) {
		dbgprintf("Error from call to getaddrinfo for %s - %s\n", pszValue, gai_strerror(gai_err));
		ABORT_FINALIZE(RS_RET_OK);
	}
	if (MMDB_SUCCESS != mmdb_err) {
		dbgprintf("Got an error from the maxminddb library: %s\n", MMDB_strerror(mmdb_err));
		ABORT_FINALIZE(RS_RET_OK);
	}
	if (!result.found_entry) {
		dbgprintf("No entry found in database for '%s'\n", pszValue);
		ABORT_FINALIZE(RS_RET_OK);
	}
	int status  = MMDB_get_entry_data_list(&amp;result.entry, &amp;entry_data_list);
	if (MMDB_SUCCESS != status) {
		dbgprintf("Got an error looking up the entry data - %s\n", MMDB_strerror(status));
		ABORT_FINALIZE(RS_RET_OK);
	}
	size_t  memlen;
	char   *membuf;
	FILE   *memstream;
	CHKmalloc(memstream = open_memstream(&amp;membuf, &amp;memlen));
	if (entry_data_list != NULL &amp;&amp; memstream != NULL) {
		MMDB_dump_entry_data_list(memstream, entry_data_list, 2);
		fflush(memstream);
		str_split(&amp;membuf);
	}
	DBGPRINTF("maxmindb returns: '%s'\n", membuf);
	total_json = json_tokener_parse(membuf);
	fclose(memstream);
	free(membuf);
	for (int i = 0 ; i &lt;  pData-&gt;fieldList.nmemb; ++i) {
		char *strtok_save;
		char buf[(strlen((char *)(pData-&gt;fieldList.name[i])))+1];
		strcpy(buf, (char *)pData-&gt;fieldList.name[i]);
		json_object *temp_json = total_json;
		json_object *sub_obj   = temp_json;
		int j = 0;
		const char *SEP = "!";
		char *s = strtok_r(buf, SEP, &amp;strtok_save);
		for (; s != NULL; j++) {
			json_object_object_get_ex(temp_json, s, &amp;sub_obj);
			temp_json = sub_obj;
			s = strtok_r(NULL, SEP, &amp;strtok_save);
		}
		json_object_get(temp_json);
		msgAddJSON(pMsg, (uchar *)pData-&gt;fieldList.varname[i], temp_json, 0, 0);
	}
finalize_it:
	pthread_mutex_unlock(&amp;pWrkrData-&gt;mmdbMutex);
	if(entry_data_list != NULL)
		MMDB_free_entry_data_list(entry_data_list);
	json_object_put(keyjson);
	if(total_json != NULL)
		json_object_put(total_json);
ENDdoAction
BEGINdoHUPWrkr
CODESTARTdoHUPWrkr
	dbgprintf("mmdblookup: HUP received\n");
	if (pWrkrData-&gt;pData-&gt;reloadOnHup) {
		pthread_mutex_lock(&amp;pWrkrData-&gt;mmdbMutex);
		LogMsg(0, NO_ERRCODE, LOG_INFO, "mmdblookup: reloading MMDB file");
		close_mmdb(&amp;pWrkrData-&gt;mmdb);
		iRet = open_mmdb(pWrkrData-&gt;pData-&gt;pszMmdbFile, &amp;pWrkrData-&gt;mmdb);
		pthread_mutex_unlock(&amp;pWrkrData-&gt;mmdbMutex);
	}
ENDdoHUPWrkr
NO_LEGACY_CONF_parseSelectorAct
BEGINmodExit
CODESTARTmodExit
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_doHUPWrkr
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	dbgprintf("mmdblookup: module compiled with rsyslog version %s.\n", VERSION);
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmanon.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "parserif.h"
#include "hashtable.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("mmanon")
DEF_OMOD_STATIC_DATA
enum mode {ZERO, RANDOMINT, SIMPLE};
union node {
	struct {
		union node* more;
		union node* less;
	} pointer;
	struct {
		char ip_high[16];
		char ip_low[16];
	} ips;
};
struct ipv6_int {
	unsigned long long high;
	unsigned long long low;
	};
#define SIMPLE_MODE 0	 #define REWRITE_MODE 1	 typedef struct _instanceData {
	struct {
		sbool enable;
		int8_t bits;
		union node* Root;
		int randConsis;
		enum mode mode;
		uchar replaceChar;
	} ipv4;
	struct {
		sbool enable;
		uint8_t bits;
		enum mode anonmode;
		int randConsis;
		struct hashtable* hash;
	} ipv6;
	struct {
		sbool enable;
		uint8_t bits;
		enum mode anonmode;
		int randConsis;
		struct hashtable* hash;
	} embeddedIPv4;
} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	unsigned randstatus;
} wrkrInstanceData_t;
<a name="2"></a>
struct modConfData_s {
	rsconf_t *pConf;	<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
static struct cnfparamdescr actpdescr[] = {
	{ "ipv4.enable", eCmdHdlrBinary, 0 },</b></font>
	{ "ipv4.mode", eCmdHdlrGetWord, 0 },
	{ "mode", eCmdHdlrGetWord, 0 },
	{ "ipv4.bits", eCmdHdlrPositiveInt, 0 },
	{ "ipv4.replacechar", eCmdHdlrGetChar, 0},
<a name="1"></a>	{ "replacementchar", eCmdHdlrGetChar, 0},
	{ "ipv6.enable", eCmdHdlrBinary, 0 },
	{ "ipv6.anonmode", eCmdHdlrGetWord, 0 },
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "ipv6.bits", eCmdHdlrPositiveInt, 0 },
	{ "embeddedipv4.enable", eCmdHdlrBinary, 0 },
	{ "embeddedipv4.anonmode", eCmdHdlrGetWord, 0 },
	{ "embeddedipv4.bits", eCmdHdlrPositiveInt, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</b></font>
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad
BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf
BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;randstatus = time(NULL);
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature
static void
delTree(union node* node, const int layer)
{
	if(node == NULL){
		return;
	}
	if(layer == 31){
		free(node);
	} else {
		delTree(node-&gt;pointer.more, layer + 1);
		delTree(node-&gt;pointer.less, layer + 1);
		free(node);
	}
}
BEGINfreeInstance
CODESTARTfreeInstance
	delTree(pData-&gt;ipv4.Root, 0);
	if(pData-&gt;ipv6.hash != NULL) {
		hashtable_destroy(pData-&gt;ipv6.hash, 1);
	}
	if(pData-&gt;embeddedIPv4.hash != NULL) {
		hashtable_destroy(pData-&gt;embeddedIPv4.hash, 1);
	}
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance
static inline void
setInstParamDefaults(instanceData *pData)
{
		pData-&gt;ipv4.enable = 1;
		pData-&gt;ipv4.bits = 16;
		pData-&gt;ipv4.Root = NULL;
		pData-&gt;ipv4.randConsis = 0;
		pData-&gt;ipv4.mode = ZERO;
		pData-&gt;ipv4.replaceChar = 'x';
		pData-&gt;ipv6.enable = 1;
		pData-&gt;ipv6.bits = 96;
		pData-&gt;ipv6.anonmode = ZERO;
		pData-&gt;ipv6.randConsis = 0;
		pData-&gt;ipv6.hash = NULL;
		pData-&gt;embeddedIPv4.enable = 1;
		pData-&gt;embeddedIPv4.bits = 96;
<a name="0"></a>		pData-&gt;embeddedIPv4.anonmode = ZERO;
		pData-&gt;embeddedIPv4.randConsis = 0;
		pData-&gt;embeddedIPv4.hash = NULL;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF("newActInst (mmanon)\n");
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "ipv4.mode") || !strcmp(actpblk.descr[i].name, "mode")) {</b></font>
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
					 sizeof("zero")-1)) {
				pData-&gt;ipv4.mode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
					 sizeof("random")-1)) {
				pData-&gt;ipv4.mode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"simple",
					 sizeof("simple")-1) ||
					!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rewrite",
					 sizeof("rewrite")-1)) {
				pData-&gt;ipv4.mode = SIMPLE;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
					 sizeof("random-consistent")-1)) {
				pData-&gt;ipv4.mode = RANDOMINT;
				pData-&gt;ipv4.randConsis = 1;
			} else {
				parser_errmsg("mmanon: configuration error, unknown option for ipv4.mode, "
					"will use \"zero\"\n");
			}
		} else if(!strcmp(actpblk.descr[i].name, "ipv4.bits")) {
			if((int8_t) pvals[i].val.d.n &lt;= 32) {
				pData-&gt;ipv4.bits = (int8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;ipv4.bits = 32;
				parser_errmsg("warning: invalid number of ipv4.bits (%d), corrected "
				"to 32", (int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, "ipv4.enable")) {
			pData-&gt;ipv4.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "ipv4.replacechar") || !strcmp(actpblk.descr[i].name,
			"replacementchar")) {
			uchar* tmp = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);
			pData-&gt;ipv4.replaceChar = tmp[0];
			free(tmp);
		} else if(!strcmp(actpblk.descr[i].name, "ipv6.enable")) {
			pData-&gt;ipv6.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "ipv6.bits")) {
			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
				pData-&gt;ipv6.bits = (uint8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;ipv6.bits = 128;
				parser_errmsg("warning: invalid number of ipv6.bits (%d), corrected "
				"to 128", (int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, "ipv6.anonmode")) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
					 sizeof("zero")-1)) {
				pData-&gt;ipv6.anonmode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
					 sizeof("random")-1)) {
				pData-&gt;ipv6.anonmode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
					 sizeof("random-consistent")-1)) {
				pData-&gt;ipv6.anonmode = RANDOMINT;
				pData-&gt;ipv6.randConsis = 1;
			} else {
				parser_errmsg("mmanon: configuration error, unknown option for "
				"ipv6.anonmode, will use \"zero\"\n");
			}
		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.enable")) {
			pData-&gt;embeddedIPv4.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.bits")) {
			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
				pData-&gt;embeddedIPv4.bits = (uint8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;embeddedIPv4.bits = 128;
				parser_errmsg("warning: invalid number of embeddedipv4.bits (%d), "
					"corrected to 128", (int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.anonmode")) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
					 sizeof("zero")-1)) {
				pData-&gt;embeddedIPv4.anonmode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
					 sizeof("random")-1)) {
				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
					 sizeof("random-consistent")-1)) {
				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
				pData-&gt;embeddedIPv4.randConsis = 1;
			} else {
				parser_errmsg("mmanon: configuration error, unknown option for ipv6.anonmode, "
				"will use \"zero\"\n");
			}
		} else {
			parser_errmsg("mmanon: program error, non-handled "
			  "param '%s'\n", actpblk.descr[i].name);
		}
	}
	int bHadBitsErr = 0;
	if(pData-&gt;ipv4.mode == SIMPLE) {
		if(pData-&gt;ipv4.bits &lt; 8 &amp;&amp; pData-&gt;ipv4.bits &gt; -1) {
			pData-&gt;ipv4.bits = 8;
			bHadBitsErr = 1;
		} else if(pData-&gt;ipv4.bits &lt; 16 &amp;&amp; pData-&gt;ipv4.bits &gt; 8) {
			pData-&gt;ipv4.bits = 16;
			bHadBitsErr = 1;
		} else if(pData-&gt;ipv4.bits &lt; 24 &amp;&amp; pData-&gt;ipv4.bits &gt; 16) {
			pData-&gt;ipv4.bits = 24;
			bHadBitsErr = 1;
		} else if((pData-&gt;ipv4.bits != 32 &amp;&amp; pData-&gt;ipv4.bits &gt; 24) || pData-&gt;ipv4.bits &lt; 0) {
			pData-&gt;ipv4.bits = 32;
			bHadBitsErr = 1;
		}
		if(bHadBitsErr) {
			LogError(0, RS_RET_INVLD_ANON_BITS,
				"mmanon: invalid number of ipv4 bits "
				"in simple mode, corrected to %d",
				pData-&gt;ipv4.bits);
		}
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo
BEGINtryResume
CODESTARTtryResume
ENDtryResume
static int
getHexVal(char c)
{
	if('0' &lt;= c &amp;&amp; c &lt;= '9') {
		return c - '0';
	} else if('a' &lt;= c &amp;&amp; c &lt;= 'f') {
		return (c - 'a') + 10;
	} else if('A' &lt;= c &amp;&amp; c &lt;= 'F') {
		return (c - 'A') + 10;
	} else {
		return -1;
	}
}
static int64_t
getPosInt(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int64_t val = 0;
	size_t i;
	for(i = 0 ; i &lt; buflen ; i++) {
		if('0' &lt;= buf[i] &amp;&amp; buf[i] &lt;= '9')
			val = val*10 + buf[i]-'0';
		else
			break;
	}
	*nprocessed = i;
	if(i == 0)
		val = -1;
	return val;
}
static int
syntax_ipv4(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int64_t val;
	size_t nproc;
	size_t i;
	int r = 0;
	val = getPosInt(buf, buflen, &amp;i);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;
	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;
	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;
	*nprocessed = i;
	r = 1;
done:
	return r;
}
static int
isValidHexNum(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed,
	int handleDot)
{
	size_t idx = 0;
	int cyc = 0;
	while(idx &lt; buflen) {
		switch(buf[idx]) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			cyc++;
			(*nprocessed)++;
			if(cyc == 5) {
				goto done;
			}
			break;
		case '.':
			if(handleDot &amp;&amp; cyc == 0) {
				(*nprocessed)++;
				cyc = -2;
			}
			goto done;
		case ':':
			if(cyc == 0) {
				(*nprocessed)++;
				cyc = -1;
			}
			goto done;
		default:
			goto done;
		}
		idx++;
	}
done:
	return cyc;
}
static int
syntax_ipv6(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int lastSep = 0;
	sbool hadAbbrev = 0;
	sbool lastAbbrev = 0;
	int ipParts = 0;
	int numLen;
	int isIP = 0;
	while(*nprocessed &lt; buflen) {
		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 0);
		if(numLen &gt; 0 &amp;&amp; numLen &lt; 5) {  //found a valid num
			if((ipParts == 7 &amp;&amp; hadAbbrev) || ipParts &gt; 7) {
				isIP = 0;
				goto done;
			}
			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
				isIP = 0;
				goto done;
			}
			lastSep = 0;
			lastAbbrev = 0;
			ipParts++;
		} else if (numLen &lt; 0) {  //':'
			if(lastSep) {
				if(hadAbbrev) {
					isIP = 0;
					goto done;
				} else {
					hadAbbrev = 1;
					lastAbbrev = 1;
				}
			}
			lastSep = 1;
		} else if (numLen == 5) {  			if(hadAbbrev &amp;&amp; ipParts &gt;= 2) {
				isIP = 1;
				*nprocessed -= 6;
			} else {
				isIP = 0;
			}
			goto done;
		} else {  //no valid num
			if(lastSep) {
				if(lastAbbrev &amp;&amp; ipParts &lt; 8) {
					isIP = 1;
					goto done;
				}
				isIP = 0;
				goto done;
			}
			if((ipParts == 8 &amp;&amp; !hadAbbrev) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
				isIP = 1;
				goto done;
			} else {
				isIP = 0;
				goto done;
			}
		}
		if(ipParts == 8 &amp;&amp; !hadAbbrev) {
			isIP = 1;
			goto done;
		}
	}
	if((!lastSep &amp;&amp; (ipParts == 8 &amp;&amp; !hadAbbrev)) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
		isIP = 1;
	}
done:
	return isIP;
}
static unsigned
ipv42num(const char *str)
{
	unsigned num[4] = {0, 0, 0, 0};
	unsigned value = -1;
	size_t len = strlen(str);
	int cyc = 0;
	for(unsigned i = 0 ; i &lt; len ; i++) {
		switch(str[i]) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			num[cyc] = num[cyc]*10+(str[i]-'0');
			break;
		case '.':
			cyc++;
			break;
		}
	}
	value = num[0]*256*256*256+num[1]*256*256+num[2]*256+num[3];
	return(value);
}
static unsigned
code_int(unsigned ip, wrkrInstanceData_t *pWrkrData){
	unsigned random;
	unsigned long long shiftIP_subst = ip;
	switch(pWrkrData-&gt;pData-&gt;ipv4.mode) {
	case ZERO:
		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
		return (unsigned)shiftIP_subst;
	case RANDOMINT:
		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
		random = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*
			((1ull&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits))-1));
		return (unsigned)shiftIP_subst + random;
	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
	default:
		LogError(0, RS_RET_INTERNAL_ERROR, "mmanon: unexpected code path reached in code_int function");
		return 0;
	}
}
static int
num2ipv4(unsigned num, char *str) {
	int numip[4];
	size_t len;
	for(int i = 0 ; i &lt; 4 ; i++){
		numip[i] = num % 256;
		num = num / 256;
	}
	len = snprintf(str, 16, "%d.%d.%d.%d", numip[3], numip[2], numip[1], numip[0]);
	return len;
}
static void
getip(uchar *start, size_t end, char *address)
{
	size_t i;
	for(i = 0; i &lt; end; i++){
		address[i] = *(start+i);
	}
	address[i] = '\0';
}
static rsRetVal
findip(char* address, wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	int i;
	unsigned num;
	union node* current;
	union node* Last;
	int MoreLess;
	char* CurrentCharPtr;
	current = pWrkrData-&gt;pData-&gt;ipv4.Root;
	num = ipv42num(address);
	for(i = 0; i &lt; 31; i++){
		if(pWrkrData-&gt;pData-&gt;ipv4.Root == NULL) {
			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
			pWrkrData-&gt;pData-&gt;ipv4.Root = current;
		}
		Last = current;
		if((num &gt;&gt; (31 - i)) &amp; 1){
			current = current-&gt;pointer.more;
			MoreLess = 1;
		} else {
			current = current-&gt;pointer.less;
			MoreLess = 0;
		}
		if(current == NULL){
			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
			if(MoreLess == 1){
				Last-&gt;pointer.more = current;
			} else {
				Last-&gt;pointer.less = current;
			}
		}
	}
	if(num &amp; 1){
		CurrentCharPtr = current-&gt;ips.ip_high;
	} else {
		CurrentCharPtr = current-&gt;ips.ip_low;
	}
	if(CurrentCharPtr[0] != '\0'){
		strcpy(address, CurrentCharPtr);
	} else {
		num = code_int(num, pWrkrData);
		num2ipv4(num, CurrentCharPtr);
		strcpy(address, CurrentCharPtr);
	}
finalize_it:
	RETiRet;
}
static void
process_IPv4 (char* address, wrkrInstanceData_t *pWrkrData)
{
	unsigned num;
	if(pWrkrData-&gt;pData-&gt;ipv4.randConsis){
		findip(address, pWrkrData);
	}else {
		num = ipv42num(address);
		num = code_int(num, pWrkrData);
		num2ipv4(num, address);
	}
}
static void
simpleAnon(wrkrInstanceData_t *const pWrkrData, uchar *const msg, int *const hasChanged, int iplen)
{
	int maxidx = iplen - 1;
	int j = -1;
	for(int i = (pWrkrData-&gt;pData-&gt;ipv4.bits / 8); i &gt; 0; i--) {
		j++;
		while('0' &lt;= msg[maxidx - j] &amp;&amp; msg[maxidx - j] &lt;= '9') {
			if(msg[maxidx - j] != pWrkrData-&gt;pData-&gt;ipv4.replaceChar) {
				msg[maxidx - j] = pWrkrData-&gt;pData-&gt;ipv4.replaceChar;
				*hasChanged = 1;
			}
			j++;
		}
	}
}
static void
anonipv4(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	char address[16];
	char caddress[16];
	int offset = *idx;
	uchar* msgcpy = *msg;
	size_t iplen;
	size_t caddresslen;
	int oldLen = *pLenMsg;
	if(syntax_ipv4((*msg) + offset, *pLenMsg - offset, &amp;iplen)) {
		if(pWrkrData-&gt;pData-&gt;ipv4.mode == SIMPLE) {
			simpleAnon(pWrkrData, *msg + *idx, hasChanged, iplen);
			*idx += iplen;
			return;
		}
		assert(iplen &lt; sizeof(address));
		getip(*msg + offset, iplen, address);
		offset += iplen;
		strcpy(caddress, address);
		process_IPv4(caddress, pWrkrData);
		caddresslen = strlen(caddress);
		*hasChanged = 1;
		if(caddresslen != strlen(address)) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)strlen(address));
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, caddress, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}
static void
code_ipv6_int(struct ipv6_int* ip, wrkrInstanceData_t *pWrkrData, int useEmbedded)
{
	unsigned long long randlow = 0;
	unsigned long long randhigh = 0;
	unsigned tmpRand;
	int fullbits;
	int bits = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.bits : pWrkrData-&gt;pData-&gt;ipv6.bits;
	enum mode anonmode = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.anonmode : pWrkrData-&gt;pData-&gt;ipv6.anonmode;
	if(bits == 128) { //has to be handled separately, since shift
		ip-&gt;high = 0;
		ip-&gt;low = 0;
	} else if(bits &gt; 64) {
		ip-&gt;low = 0;
		ip-&gt;high = (ip-&gt;high &gt;&gt; (bits - 64)) &lt;&lt;  (bits - 64);
	} else if(bits == 64) {
		ip-&gt;low = 0;
	} else {
		ip-&gt;low = (ip-&gt;low &gt;&gt; bits) &lt;&lt; bits;
	}
	switch(anonmode) {
	case ZERO:
		break;
	case RANDOMINT:
		if(bits == 128) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;high &lt;&lt;= 8;
				ip-&gt;high |= tmpRand;
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}
		} else if(bits &gt; 64) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}
			bits -= 64;
			fullbits = bits / 8;
			bits = bits % 8;
			while(fullbits &gt; 0) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				randhigh &lt;&lt;= 8;
				randhigh |= tmpRand;
				fullbits--;
			}
			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
			randhigh &lt;&lt;= bits;
			randhigh |= tmpRand;
			ip-&gt;high |= randhigh;
		} else if(bits == 64) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}
		} else {
			fullbits = bits / 8;
			bits = bits % 8;
			while(fullbits &gt; 0) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				randlow &lt;&lt;= 8;
				randlow |= tmpRand;
				fullbits--;
			}
			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
			randlow &lt;&lt;= bits;
			randlow |= tmpRand;
			ip-&gt;low |= randlow;
		}
		break;
	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
	default:
		LogError(0, RS_RET_INTERNAL_ERROR, "mmanon: unexpected code path reached in code_int function");
	}
}
static void
ipv62num(char* const address, const size_t iplen, struct ipv6_int* const ip)
{
	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	int cyc = 0;
	int dots = 0;
	int val;
	unsigned i;
	for(i = 0; i &lt; iplen &amp;&amp; dots &lt; 2; i++) {
		val = getHexVal(address[i]);
		if(val == -1) {
			dots++;
			if(dots &lt; 2) {
				cyc++;
			}
		} else {
			num[cyc] = num[cyc] * 16 + val;
			dots = 0;
		}
	}
	if(dots == 2) {
		if(i &lt; iplen - 1) {
			int shift = 0;
			cyc = 7;
			for(unsigned j = iplen - 1; j &gt;= i; j--) {
				val = getHexVal(address[j]);
				if(val == -1) {
					cyc--;
					shift = 0;
				} else {
					val &lt;&lt;= shift;
					shift += 4;
					num[cyc] += val;
				}
			}
		} else {
			while(cyc &lt; 8) {
				num[cyc] = 0;
				cyc++;
			}
		}
	}
	for(i = 0; i &lt; 4; i++) {
		ip-&gt;high &lt;&lt;= 16;
		ip-&gt;high |= num[i];
	}
	while(i &lt; 8) {
		ip-&gt;low &lt;&lt;= 16;
		ip-&gt;low |= num[i];
		i++;
	}
}
static void
num2ipv6 (struct ipv6_int* ip, char* address)
{
	int num[8];
	int i;
	for(i = 7; i &gt; 3; i--) {
		num[i] = ip-&gt;low &amp; 0xffff;
		ip-&gt;low &gt;&gt;= 16;
	}
	while(i &gt; -1) {
		num[i] = ip-&gt;high &amp; 0xffff;
		ip-&gt;high &gt;&gt;= 16;
		i--;
	}
	snprintf(address, 40, "%x:%x:%x:%x:%x:%x:%x:%x", num[0], num[1], num[2], num[3], num[4], num[5],
		num[6], num[7]);
}
static int
keys_equal_fn(void* key1, void* key2)
{
	struct ipv6_int *const k1 = (struct ipv6_int*) key1;
	struct ipv6_int *const k2 = (struct ipv6_int*) key2;
	return((k1-&gt;high == k2-&gt;high) &amp;&amp; (k1-&gt;low == k2-&gt;low));
}
static unsigned
hash_from_key_fn (void* k)
{
	struct ipv6_int *const key = (struct ipv6_int*) k;
	unsigned hashVal;
	hashVal = (key-&gt;high &amp; 0xFFC00000) | (key-&gt;low &amp; 0x3FFFFF);
	return hashVal;
}
static void
num2embedded (struct ipv6_int* ip, char* address)
{
	int num[8];
	int i;
	for(i = 7; i &gt; 3; i--) {
		num[i] = ip-&gt;low &amp; 0xffff;
		ip-&gt;low &gt;&gt;= 16;
	}
	while(i &gt; -1) {
		num[i] = ip-&gt;high &amp; 0xffff;
		ip-&gt;high &gt;&gt;= 16;
		i--;
	}
	snprintf(address, 46, "%x:%x:%x:%x:%x:%x:%d.%d.%d.%d", num[0], num[1], num[2], num[3], num[4], num[5],
		(num[6] &amp; 0xff00) &gt;&gt; 8, num[6] &amp; 0xff, (num[7] &amp; 0xff00) &gt;&gt; 8, num[7] &amp; 0xff);
}
static rsRetVal
findIPv6(struct ipv6_int* num, char* address, wrkrInstanceData_t *const pWrkrData, int useEmbedded)
{
	struct ipv6_int* hashKey = NULL;
	DEFiRet;
	struct hashtable* hash = useEmbedded? pWrkrData-&gt;pData-&gt;embeddedIPv4.hash : pWrkrData-&gt;pData-&gt;ipv6.hash;
	if(hash == NULL) {
		CHKmalloc(hash = create_hashtable(512, hash_from_key_fn, keys_equal_fn, NULL));
		if(useEmbedded) {
			pWrkrData-&gt;pData-&gt;embeddedIPv4.hash = hash;
		} else {
			pWrkrData-&gt;pData-&gt;ipv6.hash = hash;
		}
	}
	char* val = (char*)(hashtable_search(hash, num));
	if(val != NULL) {
		strcpy(address, val);
	} else {
		CHKmalloc(hashKey = (struct ipv6_int*) malloc(sizeof(struct ipv6_int)));
		hashKey-&gt;low = num-&gt;low;
		hashKey-&gt;high = num-&gt;high;
		if(useEmbedded) {
			code_ipv6_int(num, pWrkrData, 1);
			num2embedded(num, address);
		} else {
			code_ipv6_int(num, pWrkrData, 0);
			num2ipv6(num, address);
		}
		char* hashString;
		CHKmalloc(hashString = strdup(address));
		if(!hashtable_insert(hash, hashKey, hashString)) {
			DBGPRINTF("hashtable error: insert to %s-table failed",
				useEmbedded ? "embedded ipv4" : "ipv6");
			free(hashString);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		hashKey = NULL;
	}
finalize_it:
	free(hashKey);
	RETiRet;
}
static void
process_IPv6 (char* address, wrkrInstanceData_t *pWrkrData, const size_t iplen)
{
	struct ipv6_int num = {0, 0};
	ipv62num(address, iplen, &amp;num);
	if(pWrkrData-&gt;pData-&gt;ipv6.randConsis) {
		findIPv6(&amp;num, address, pWrkrData, 0);
	} else {
		code_ipv6_int(&amp;num, pWrkrData, 0);
		num2ipv6(&amp;num, address);
	}
}
static void
anonipv6(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	size_t iplen = 0;
	int offset = *idx;
	char address[40];
	uchar* msgcpy = *msg;
	size_t caddresslen;
	size_t oldLen = *pLenMsg;
	int syn = syntax_ipv6(*msg + offset, *pLenMsg - offset, &amp;iplen);
	if(syn) {
		assert(iplen &lt; sizeof(address));  //has to be &lt; instead of &lt;= since address includes space for a '\0'
		getip(*msg + offset, iplen, address);
		offset += iplen;
		process_IPv6(address, pWrkrData, iplen);
		caddresslen = strlen(address);
		*hasChanged = 1;
		if(caddresslen != iplen) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, address, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}
static size_t
findV4Start(const uchar *const __restrict__ buf, size_t dotPos)
{
	while(dotPos &gt; 0) {
		if(buf[dotPos] == ':') {
			return dotPos + 1;
		}
		dotPos--;
	}
	return -1; //should not happen
}
static int
syntax_embedded(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed,
	size_t * v4Start)
{
	int lastSep = 0;
	sbool hadAbbrev = 0;
	int ipParts = 0;
	int numLen;
	int isIP = 0;
	size_t ipv4Len;
	while(*nprocessed &lt; buflen) {
		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 1);
		if(numLen &gt; 0) {  //found a valid num
			if((ipParts == 6 &amp;&amp; hadAbbrev) || ipParts &gt; 6) {  //is 6 since the first part of
				isIP = 0;
				goto done;
			}
			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
				isIP = 0;
				goto done;
			}
			lastSep = 0;
			ipParts++;
		} else if (numLen == -1) {  //':'
			if(lastSep) {
				if(hadAbbrev) {
					isIP = 0;
					goto done;
				} else {
					hadAbbrev = 1;
				}
			}
			lastSep = 1;
		} else if (numLen == -2) {  //'.'
			if (lastSep || (ipParts == 0 &amp;&amp; hadAbbrev) || (ipParts &lt;= 6 &amp;&amp; !hadAbbrev)) {
				isIP = 0;
				goto done;
			}
			*v4Start = findV4Start(buf, (*nprocessed) - 1);
			if(syntax_ipv4(buf + (*v4Start), buflen, &amp;ipv4Len)) {
				*nprocessed += (ipv4Len - ((*nprocessed) - (*v4Start)));
				isIP = 1;
				goto done;
			} else {
				isIP = 0;
				goto done;
			}
		} else {  //no valid num
			isIP = 0;
			goto done;
		}
	}
	isIP = 0;
done:
	return isIP;
}
static void
embedded2num(char* address, size_t v4Start, struct ipv6_int* ip)
{
	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	int cyc = 0;
	int dots = 0;
	int val;
	unsigned i;
	unsigned v4Val = ipv42num(address + v4Start);
	num[7] = v4Val &amp; 0xffff;
	num[6] = (v4Val &amp; 0xffff0000) &gt;&gt; 16;
	for(i = 0; i &lt; v4Start &amp;&amp; dots &lt; 2; i++) {
		val = getHexVal(address[i]);
		if(val == -1) {
			dots++;
			if(dots &lt; 2) {
				cyc++;
			}
		} else {
			num[cyc] = num[cyc] * 16 + val;
			dots = 0;
		}
	}
	if(dots == 2) {
		if(i &lt; v4Start) {
			int shift = 0;
			cyc = 5;
			for(unsigned j = v4Start - 1; j &gt;= i; j--) {
				val = getHexVal(address[j]);
				if(val == -1) {
					cyc--;
					shift = 0;
				} else {
					val &lt;&lt;= shift;
					shift += 4;
					num[cyc] += val;
				}
			}
		} else {
			while(cyc &lt; 6) {
				num[cyc] = 0;
				cyc++;
			}
		}
	}
	for(i = 0; i &lt; 4; i++) {
		ip-&gt;high &lt;&lt;= 16;
		ip-&gt;high |= num[i];
	}
	while(i &lt; 8) {
		ip-&gt;low &lt;&lt;= 16;
		ip-&gt;low |= num[i];
		i++;
	}
}
static void
process_embedded (char* address, wrkrInstanceData_t *pWrkrData, size_t v4Start)
{
	struct ipv6_int num = {0, 0};
	embedded2num(address, v4Start, &amp;num);
	if(pWrkrData-&gt;pData-&gt;embeddedIPv4.randConsis) {
		findIPv6(&amp;num, address, pWrkrData, 1);
	} else {
		code_ipv6_int(&amp;num, pWrkrData, 1);
		num2embedded(&amp;num, address);
	}
}
static void
anonEmbedded(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	size_t iplen = 0;
	int offset = *idx;
	char address[46];
	uchar* msgcpy = *msg;
	unsigned caddresslen;
	size_t oldLen = *pLenMsg;
	size_t v4Start;
	int syn = syntax_embedded(*msg + offset, *pLenMsg - offset, &amp;iplen, &amp;v4Start);
	if(syn) {
		assert(iplen &lt; sizeof(address));
		getip(*msg + offset, iplen, address);
		offset += iplen;
		process_embedded(address, pWrkrData, v4Start);
		caddresslen = strlen(address);
		*hasChanged = 1;
		if(caddresslen != iplen) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, address, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}
BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	uchar *msg;
	int lenMsg;
	int i;
	int hasChanged = 0;
CODESTARTdoAction
	lenMsg = getMSGLen(pMsg);
	msg = (uchar*)strdup((char*)getMSG(pMsg));
	for(i = 0 ; i &lt;= lenMsg - 2 ; i++) {
		if(pWrkrData-&gt;pData-&gt;embeddedIPv4.enable) {
			anonEmbedded(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
		if(pWrkrData-&gt;pData-&gt;ipv4.enable) {
			anonipv4(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
		if(pWrkrData-&gt;pData-&gt;ipv6.enable) {
			anonipv6(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
	}
	if(hasChanged) {
		MsgReplaceMSG(pMsg, msg, lenMsg);
	}
	free(msg);
ENDdoAction
NO_LEGACY_CONF_parseSelectorAct
BEGINmodExit
CODESTARTmodExit
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF("mmanon: module compiled with rsyslog version %s.\n", VERSION);
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
