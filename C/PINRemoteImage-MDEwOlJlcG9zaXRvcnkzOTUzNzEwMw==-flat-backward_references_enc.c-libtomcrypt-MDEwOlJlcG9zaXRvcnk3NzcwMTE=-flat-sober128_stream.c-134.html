
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_enc.c</h3>
            <pre><code>1  #include &lt;assert.h&gt;
2  #include &lt;math.h&gt;
3  #include &quot;src/enc/backward_references_enc.h&quot;
4  #include &quot;src/enc/histogram_enc.h&quot;
5  #include &quot;src/dsp/lossless.h&quot;
6  #include &quot;src/dsp/lossless_common.h&quot;
7  #include &quot;src/dsp/dsp.h&quot;
8  #include &quot;src/utils/color_cache_utils.h&quot;
9  #include &quot;src/utils/utils.h&quot;
10  #define MIN_BLOCK_SIZE 256  
11  #define MAX_ENTROPY    (1e30f)
12  #define WINDOW_SIZE ((1 &lt;&lt; WINDOW_SIZE_BITS) - 120)
13  #define MIN_LENGTH 4
14  static const uint8_t plane_to_code_lut[128] = {
15   96,   73,  55,  39,  23,  13,   5,  1,  255, 255, 255, 255, 255, 255, 255, 255,
16   101,  78,  58,  42,  26,  16,   8,  2,    0,   3,  9,   17,  27,  43,  59,  79,
17   102,  86,  62,  46,  32,  20,  10,  6,    4,   7,  11,  21,  33,  47,  63,  87,
18   105,  90,  70,  52,  37,  28,  18,  14,  12,  15,  19,  29,  38,  53,  71,  91,
19   110,  99,  82,  66,  48,  35,  30,  24,  22,  25,  31,  36,  49,  67,  83, 100,
20   115, 108,  94,  76,  64,  50,  44,  40,  34,  41,  45,  51,  65,  77,  95, 109,
21   118, 113, 103,  92,  80,  68,  60,  56,  54,  57,  61,  69,  81,  93, 104, 114,
22   119, 116, 111, 106,  97,  88,  84,  74,  72,  75,  85,  89,  98, 107, 112, 117
23  };
24  extern int VP8LDistanceToPlaneCode(int xsize, int dist);
25  int VP8LDistanceToPlaneCode(int xsize, int dist) {
26    const int yoffset = dist / xsize;
27    const int xoffset = dist - yoffset * xsize;
28    if (xoffset &lt;= 8 &amp;&amp; yoffset &lt; 8) {
29      return plane_to_code_lut[yoffset * 16 + 8 - xoffset] + 1;
30    } else if (xoffset &gt; xsize - 8 &amp;&amp; yoffset &lt; 7) {
31      return plane_to_code_lut[(yoffset + 1) * 16 + 8 + (xsize - xoffset)] + 1;
32    }
33    return dist + 120;
34  }
35  static WEBP_INLINE int FindMatchLength(const uint32_t* const array1,
36                                         const uint32_t* const array2,
37                                         int best_len_match, int max_limit) {
38    if (array1[best_len_match] != array2[best_len_match]) return 0;
39    return VP8LVectorMismatch(array1, array2, max_limit);
40  }
41  struct PixOrCopyBlock {
42    PixOrCopyBlock* next_;   
43    PixOrCopy* start_;       
44    int size_;               
45  };
46  extern void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs);
47  void VP8LClearBackwardRefs(VP8LBackwardRefs* const refs) {
48    assert(refs != NULL);
49    if (refs-&gt;tail_ != NULL) {
50      *refs-&gt;tail_ = refs-&gt;free_blocks_;  
51    }
52    refs-&gt;free_blocks_ = refs-&gt;refs_;
53    refs-&gt;tail_ = &amp;refs-&gt;refs_;
54    refs-&gt;last_block_ = NULL;
55    refs-&gt;refs_ = NULL;
56  }
57  void VP8LBackwardRefsClear(VP8LBackwardRefs* const refs) {
58    assert(refs != NULL);
59    VP8LClearBackwardRefs(refs);
60    while (refs-&gt;free_blocks_ != NULL) {
61      PixOrCopyBlock* const next = refs-&gt;free_blocks_-&gt;next_;
62      WebPSafeFree(refs-&gt;free_blocks_);
63      refs-&gt;free_blocks_ = next;
64    }
65  }
66  void VP8LBackwardRefsInit(VP8LBackwardRefs* const refs, int block_size) {
67    assert(refs != NULL);
68    memset(refs, 0, sizeof(*refs));
69    refs-&gt;tail_ = &amp;refs-&gt;refs_;
70    refs-&gt;block_size_ =
71        (block_size &lt; MIN_BLOCK_SIZE) ? MIN_BLOCK_SIZE : block_size;
72  }
73  VP8LRefsCursor VP8LRefsCursorInit(const VP8LBackwardRefs* const refs) {
74    VP8LRefsCursor c;
75    c.cur_block_ = refs-&gt;refs_;
76    if (refs-&gt;refs_ != NULL) {
77      c.cur_pos = c.cur_block_-&gt;start_;
78      c.last_pos_ = c.cur_pos + c.cur_block_-&gt;size_;
79    } else {
80      c.cur_pos = NULL;
81      c.last_pos_ = NULL;
82    }
83    return c;
84  }
85  void VP8LRefsCursorNextBlock(VP8LRefsCursor* const c) {
86    PixOrCopyBlock* const b = c-&gt;cur_block_-&gt;next_;
87    c-&gt;cur_pos = (b == NULL) ? NULL : b-&gt;start_;
88    c-&gt;last_pos_ = (b == NULL) ? NULL : b-&gt;start_ + b-&gt;size_;
89    c-&gt;cur_block_ = b;
90  }
91  static PixOrCopyBlock* BackwardRefsNewBlock(VP8LBackwardRefs* const refs) {
92    PixOrCopyBlock* b = refs-&gt;free_blocks_;
93    if (b == NULL) {   
94      const size_t total_size =
95          sizeof(*b) + refs-&gt;block_size_ * sizeof(*b-&gt;start_);
96      b = (PixOrCopyBlock*)WebPSafeMalloc(1ULL, total_size);
97      if (b == NULL) {
98        refs-&gt;error_ |= 1;
99        return NULL;
100      }
101      b-&gt;start_ = (PixOrCopy*)((uint8_t*)b + sizeof(*b));  
102    } else {  
103      refs-&gt;free_blocks_ = b-&gt;next_;
104    }
105    *refs-&gt;tail_ = b;
106    refs-&gt;tail_ = &amp;b-&gt;next_;
107    refs-&gt;last_block_ = b;
108    b-&gt;next_ = NULL;
109    b-&gt;size_ = 0;
110    return b;
111  }
112  extern void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
113                                        const PixOrCopy v);
114  void VP8LBackwardRefsCursorAdd(VP8LBackwardRefs* const refs,
115                                 const PixOrCopy v) {
116    PixOrCopyBlock* b = refs-&gt;last_block_;
117    if (b == NULL || b-&gt;size_ == refs-&gt;block_size_) {
118      b = BackwardRefsNewBlock(refs);
119      if (b == NULL) return;   
120    }
121    b-&gt;start_[b-&gt;size_++] = v;
122  }
123  int VP8LHashChainInit(VP8LHashChain* const p, int size) {
124    assert(p-&gt;size_ == 0);
125    assert(p-&gt;offset_length_ == NULL);
126    assert(size &gt; 0);
127    p-&gt;offset_length_ =
128        (uint32_t*)WebPSafeMalloc(size, sizeof(*p-&gt;offset_length_));
129    if (p-&gt;offset_length_ == NULL) return 0;
130    p-&gt;size_ = size;
131    return 1;
132  }
133  void VP8LHashChainClear(VP8LHashChain* const p) {
134    assert(p != NULL);
135    WebPSafeFree(p-&gt;offset_length_);
136    p-&gt;size_ = 0;
137    p-&gt;offset_length_ = NULL;
138  }
139  static const uint32_t kHashMultiplierHi = 0xc6a4a793u;
140  static const uint32_t kHashMultiplierLo = 0x5bd1e996u;
141  static WEBP_UBSAN_IGNORE_UNSIGNED_OVERFLOW WEBP_INLINE
142  uint32_t GetPixPairHash64(const uint32_t* const argb) {
143    uint32_t key;
144    key  = argb[1] * kHashMultiplierHi;
145    key += argb[0] * kHashMultiplierLo;
146    key = key &gt;&gt; (32 - HASH_BITS);
147    return key;
148  }
149  static int GetMaxItersForQuality(int quality) {
150    return 8 + (quality * quality) / 128;
151  }
152  static int GetWindowSizeForHashChain(int quality, int xsize) {
153    const int max_window_size = (quality &gt; 75) ? WINDOW_SIZE
154                              : (quality &gt; 50) ? (xsize &lt;&lt; 8)
155                              : (quality &gt; 25) ? (xsize &lt;&lt; 6)
156                              : (xsize &lt;&lt; 4);
157    assert(xsize &gt; 0);
158    return (max_window_size &gt; WINDOW_SIZE) ? WINDOW_SIZE : max_window_size;
159  }
160  static WEBP_INLINE int MaxFindCopyLength(int len) {
161    return (len &lt; MAX_LENGTH) ? len : MAX_LENGTH;
162  }
163  int VP8LHashChainFill(VP8LHashChain* const p, int quality,
164                        const uint32_t* const argb, int xsize, int ysize,
165                        int low_effort) {
166    const int size = xsize * ysize;
167    const int iter_max = GetMaxItersForQuality(quality);
168    const uint32_t window_size = GetWindowSizeForHashChain(quality, xsize);
169    int pos;
170    int argb_comp;
171    uint32_t base_position;
172    int32_t* hash_to_first_index;
173    int32_t* chain = (int32_t*)p-&gt;offset_length_;
174    assert(size &gt; 0);
175    assert(p-&gt;size_ != 0);
176    assert(p-&gt;offset_length_ != NULL);
177    if (size &lt;= 2) {
178      p-&gt;offset_length_[0] = p-&gt;offset_length_[size - 1] = 0;
179      return 1;
180    }
181    hash_to_first_index =
182        (int32_t*)WebPSafeMalloc(HASH_SIZE, sizeof(*hash_to_first_index));
183    if (hash_to_first_index == NULL) return 0;
184    memset(hash_to_first_index, 0xff, HASH_SIZE * sizeof(*hash_to_first_index));
185    argb_comp = (argb[0] == argb[1]);
186    for (pos = 0; pos &lt; size - 2;) {
187      uint32_t hash_code;
188      const int argb_comp_next = (argb[pos + 1] == argb[pos + 2]);
189      if (argb_comp &amp;&amp; argb_comp_next) {
190        uint32_t tmp[2];
191        uint32_t len = 1;
192        tmp[0] = argb[pos];
193        while (pos + (int)len + 2 &lt; size &amp;&amp; argb[pos + len + 2] == argb[pos]) {
194          ++len;
195        }
196        if (len &gt; MAX_LENGTH) {
197          memset(chain + pos, 0xff, (len - MAX_LENGTH) * sizeof(*chain));
198          pos += len - MAX_LENGTH;
199          len = MAX_LENGTH;
200        }
201        while (len) {
202          tmp[1] = len--;
203          hash_code = GetPixPairHash64(tmp);
204          chain[pos] = hash_to_first_index[hash_code];
205          hash_to_first_index[hash_code] = pos++;
206        }
207        argb_comp = 0;
208      } else {
209        hash_code = GetPixPairHash64(argb + pos);
210        chain[pos] = hash_to_first_index[hash_code];
211        hash_to_first_index[hash_code] = pos++;
212        argb_comp = argb_comp_next;
213      }
214    }
215    chain[pos] = hash_to_first_index[GetPixPairHash64(argb + pos)];
216    WebPSafeFree(hash_to_first_index);
217    assert(size &gt; 2);
218    p-&gt;offset_length_[0] = p-&gt;offset_length_[size - 1] = 0;
219    for (base_position = size - 2; base_position &gt; 0;) {
220      const int max_len = MaxFindCopyLength(size - 1 - base_position);
221      const uint32_t* const argb_start = argb + base_position;
222      int iter = iter_max;
223      int best_length = 0;
224      uint32_t best_distance = 0;
225      uint32_t best_argb;
226      const int min_pos =
227          (base_position &gt; window_size) ? base_position - window_size : 0;
228      const int length_max = (max_len &lt; 256) ? max_len : 256;
229      uint32_t max_base_position;
230      pos = chain[base_position];
231      if (!low_effort) {
232        int curr_length;
233        if (base_position &gt;= (uint32_t)xsize) {
234          curr_length = FindMatchLength(argb_start - xsize, argb_start,
235                                        best_length, max_len);
236          if (curr_length &gt; best_length) {
237            best_length = curr_length;
238            best_distance = xsize;
239          }
240          --iter;
241        }
242        curr_length =
243            FindMatchLength(argb_start - 1, argb_start, best_length, max_len);
244        if (curr_length &gt; best_length) {
245          best_length = curr_length;
246          best_distance = 1;
247        }
248        --iter;
249        if (best_length == MAX_LENGTH) pos = min_pos - 1;
250      }
251      best_argb = argb_start[best_length];
252      for (; pos &gt;= min_pos &amp;&amp; --iter; pos = chain[pos]) {
253        int curr_length;
254        assert(base_position &gt; (uint32_t)pos);
255        if (argb[pos + best_length] != best_argb) continue;
256        curr_length = VP8LVectorMismatch(argb + pos, argb_start, max_len);
257        if (best_length &lt; curr_length) {
258          best_length = curr_length;
259          best_distance = base_position - pos;
260          best_argb = argb_start[best_length];
261          if (best_length &gt;= length_max) break;
262        }
263      }
264      max_base_position = base_position;
265      while (1) {
266        assert(best_length &lt;= MAX_LENGTH);
267        assert(best_distance &lt;= WINDOW_SIZE);
268        p-&gt;offset_length_[base_position] =
269            (best_distance &lt;&lt; MAX_LENGTH_BITS) | (uint32_t)best_length;
270        --base_position;
271        if (best_distance == 0 || base_position == 0) break;
272        if (base_position &lt; best_distance ||
273            argb[base_position - best_distance] != argb[base_position]) {
274          break;
275        }
276        if (best_length == MAX_LENGTH &amp;&amp; best_distance != 1 &amp;&amp;
277            base_position + MAX_LENGTH &lt; max_base_position) {
278          break;
279        }
280        if (best_length &lt; MAX_LENGTH) {
281          ++best_length;
282          max_base_position = base_position;
283        }
284      }
285    }
286    return 1;
287  }
288  static WEBP_INLINE void AddSingleLiteral(uint32_t pixel, int use_color_cache,
289                                           VP8LColorCache* const hashers,
290                                           VP8LBackwardRefs* const refs) {
291    PixOrCopy v;
292    if (use_color_cache) {
293      const uint32_t key = VP8LColorCacheGetIndex(hashers, pixel);
294      if (VP8LColorCacheLookup(hashers, key) == pixel) {
295        v = PixOrCopyCreateCacheIdx(key);
296      } else {
297        v = PixOrCopyCreateLiteral(pixel);
298        VP8LColorCacheSet(hashers, key, pixel);
299      }
300    } else {
301      v = PixOrCopyCreateLiteral(pixel);
302    }
303    VP8LBackwardRefsCursorAdd(refs, v);
304  }
305  static int BackwardReferencesRle(int xsize, int ysize,
306                                   const uint32_t* const argb,
307                                   int cache_bits, VP8LBackwardRefs* const refs) {
308    const int pix_count = xsize * ysize;
309    int i, k;
310    const int use_color_cache = (cache_bits &gt; 0);
311    VP8LColorCache hashers;
312    if (use_color_cache &amp;&amp; !VP8LColorCacheInit(&amp;hashers, cache_bits)) {
313      return 0;
314    }
315    VP8LClearBackwardRefs(refs);
316    AddSingleLiteral(argb[0], use_color_cache, &amp;hashers, refs);
317    i = 1;
318    while (i &lt; pix_count) {
319      const int max_len = MaxFindCopyLength(pix_count - i);
320      const int rle_len = FindMatchLength(argb + i, argb + i - 1, 0, max_len);
321      const int prev_row_len = (i &lt; xsize) ? 0 :
322          FindMatchLength(argb + i, argb + i - xsize, 0, max_len);
323      if (rle_len &gt;= prev_row_len &amp;&amp; rle_len &gt;= MIN_LENGTH) {
324        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(1, rle_len));
325        i += rle_len;
326      } else if (prev_row_len &gt;= MIN_LENGTH) {
327        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(xsize, prev_row_len));
328        if (use_color_cache) {
329          for (k = 0; k &lt; prev_row_len; ++k) {
330            VP8LColorCacheInsert(&amp;hashers, argb[i + k]);
331          }
332        }
333        i += prev_row_len;
334      } else {
335        AddSingleLiteral(argb[i], use_color_cache, &amp;hashers, refs);
336        i++;
337      }
338    }
339    if (use_color_cache) VP8LColorCacheClear(&amp;hashers);
340    return !refs-&gt;error_;
341  }
342  static int BackwardReferencesLz77(int xsize, int ysize,
343                                    const uint32_t* const argb, int cache_bits,
344                                    const VP8LHashChain* const hash_chain,
345                                    VP8LBackwardRefs* const refs) {
346    int i;
347    int i_last_check = -1;
348    int ok = 0;
349    int cc_init = 0;
350    const int use_color_cache = (cache_bits &gt; 0);
351    const int pix_count = xsize * ysize;
352    VP8LColorCache hashers;
353    if (use_color_cache) {
354      cc_init = VP8LColorCacheInit(&amp;hashers, cache_bits);
355      if (!cc_init) goto Error;
356    }
357    VP8LClearBackwardRefs(refs);
358    for (i = 0; i &lt; pix_count;) {
359      int offset = 0;
360      int len = 0;
361      int j;
362      VP8LHashChainFindCopy(hash_chain, i, &amp;offset, &amp;len);
363      if (len &gt;= MIN_LENGTH) {
364        const int len_ini = len;
365        int max_reach = 0;
366        const int j_max =
367            (i + len_ini &gt;= pix_count) ? pix_count - 1 : i + len_ini;
368        i_last_check = (i &gt; i_last_check) ? i : i_last_check;
369        for (j = i_last_check + 1; j &lt;= j_max; ++j) {
370          const int len_j = VP8LHashChainFindLength(hash_chain, j);
371          const int reach =
372              j + (len_j &gt;= MIN_LENGTH ? len_j : 1);  
373          if (reach &gt; max_reach) {
374            len = j - i;
375            max_reach = reach;
376            if (max_reach &gt;= pix_count) break;
377          }
378        }
379      } else {
380        len = 1;
381      }
382      assert(len &gt; 0);
383      if (len == 1) {
384        AddSingleLiteral(argb[i], use_color_cache, &amp;hashers, refs);
385      } else {
386        VP8LBackwardRefsCursorAdd(refs, PixOrCopyCreateCopy(offset, len));
387        if (use_color_cache) {
388          for (j = i; j &lt; i + len; ++j) VP8LColorCacheInsert(&amp;hashers, argb[j]);
389        }
390      }
391      i += len;
392    }
393    ok = !refs-&gt;error_;
394   Error:
395    if (cc_init) VP8LColorCacheClear(&amp;hashers);
396    return ok;
397  }
398  #define WINDOW_OFFSETS_SIZE_MAX 32
399  static int BackwardReferencesLz77Box(int xsize, int ysize,
400                                       const uint32_t* const argb, int cache_bits,
401                                       const VP8LHashChain* const hash_chain_best,
402                                       VP8LHashChain* hash_chain,
403                                       VP8LBackwardRefs* const refs) {
404    int i;
405    const int pix_count = xsize * ysize;
406    uint16_t* counts;
407    int window_offsets[WINDOW_OFFSETS_SIZE_MAX] = {0};
408    int window_offsets_new[WINDOW_OFFSETS_SIZE_MAX] = {0};
409    int window_offsets_size = 0;
410    int window_offsets_new_size = 0;
411    uint16_t* const counts_ini =
412        (uint16_t*)WebPSafeMalloc(xsize * ysize, sizeof(*counts_ini));
413    int best_offset_prev = -1, best_length_prev = -1;
414    if (counts_ini == NULL) return 0;
415    i = pix_count - 2;
416    counts = counts_ini + i;
417    counts[1] = 1;
418    for (; i &gt;= 0; --i, --counts) {
419      if (argb[i] == argb[i + 1]) {
420        counts[0] = counts[1] + (counts[1] != MAX_LENGTH);
421      } else {
422        counts[0] = 1;
423      }
424    }
425    {
426      int x, y;
427      for (y = 0; y &lt;= 6; ++y) {
428        for (x = -6; x &lt;= 6; ++x) {
429          const int offset = y * xsize + x;
430          int plane_code;
431          if (offset &lt;= 0) continue;
432          plane_code = VP8LDistanceToPlaneCode(xsize, offset) - 1;
433          if (plane_code &gt;= WINDOW_OFFSETS_SIZE_MAX) continue;
434          window_offsets[plane_code] = offset;
435        }
436      }
437      for (i = 0; i &lt; WINDOW_OFFSETS_SIZE_MAX; ++i) {
438        if (window_offsets[i] == 0) continue;
439        window_offsets[window_offsets_size++] = window_offsets[i];
440      }
441      for (i = 0; i &lt; window_offsets_size; ++i) {
442        int j;
443        int is_reachable = 0;
444        for (j = 0; j &lt; window_offsets_size &amp;&amp; !is_reachable; ++j) {
445          is_reachable |= (window_offsets[i] == window_offsets[j] + 1);
446        }
447        if (!is_reachable) {
448          window_offsets_new[window_offsets_new_size] = window_offsets[i];
449          ++window_offsets_new_size;
450        }
451      }
452    }
<span onclick='openModal()' class='match'>453    hash_chain-&gt;offset_length_[0] = 0;
454    for (i = 1; i &lt; pix_count; ++i) {
455      int ind;
</span>456      int best_length = VP8LHashChainFindLength(hash_chain_best, i);
457      int best_offset;
458      int do_compute = 1;
459      if (best_length &gt;= MAX_LENGTH) {
460        best_offset = VP8LHashChainFindOffset(hash_chain_best, i);
461        for (ind = 0; ind &lt; window_offsets_size; ++ind) {
462          if (best_offset == window_offsets[ind]) {
463            do_compute = 0;
464            break;
465          }
466        }
467      }
468      if (do_compute) {
469        const int use_prev =
470            (best_length_prev &gt; 1) &amp;&amp; (best_length_prev &lt; MAX_LENGTH);
471        const int num_ind =
472            use_prev ? window_offsets_new_size : window_offsets_size;
473        best_length = use_prev ? best_length_prev - 1 : 0;
474        best_offset = use_prev ? best_offset_prev : 0;
475        for (ind = 0; ind &lt; num_ind; ++ind) {
476          int curr_length = 0;
477          int j = i;
478          int j_offset =
479              use_prev ? i - window_offsets_new[ind] : i - window_offsets[ind];
480          if (j_offset &lt; 0 || argb[j_offset] != argb[i]) continue;
481          do {
482            const int counts_j_offset = counts_ini[j_offset];
483            const int counts_j = counts_ini[j];
484            if (counts_j_offset != counts_j) {
485              curr_length +=
486                  (counts_j_offset &lt; counts_j) ? counts_j_offset : counts_j;
487              break;
488            }
489            curr_length += counts_j_offset;
490            j_offset += counts_j_offset;
491            j += counts_j_offset;
492          } while (curr_length &lt;= MAX_LENGTH &amp;&amp; j &lt; pix_count &amp;&amp;
493                   argb[j_offset] == argb[j]);
494          if (best_length &lt; curr_length) {
495            best_offset =
496                use_prev ? window_offsets_new[ind] : window_offsets[ind];
497            if (curr_length &gt;= MAX_LENGTH) {
498              best_length = MAX_LENGTH;
499              break;
500            } else {
501              best_length = curr_length;
502            }
503          }
504        }
505      }
506      assert(i + best_length &lt;= pix_count);
507      assert(best_length &lt;= MAX_LENGTH);
508      if (best_length &lt;= MIN_LENGTH) {
509        hash_chain-&gt;offset_length_[i] = 0;
510        best_offset_prev = 0;
511        best_length_prev = 0;
512      } else {
513        hash_chain-&gt;offset_length_[i] =
514            (best_offset &lt;&lt; MAX_LENGTH_BITS) | (uint32_t)best_length;
515        best_offset_prev = best_offset;
516        best_length_prev = best_length;
517      }
518    }
519    hash_chain-&gt;offset_length_[0] = 0;
520    WebPSafeFree(counts_ini);
521    return BackwardReferencesLz77(xsize, ysize, argb, cache_bits, hash_chain,
522                                  refs);
523  }
524  static void BackwardReferences2DLocality(int xsize,
525                                           const VP8LBackwardRefs* const refs) {
526    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
527    while (VP8LRefsCursorOk(&amp;c)) {
528      if (PixOrCopyIsCopy(c.cur_pos)) {
529        const int dist = c.cur_pos-&gt;argb_or_distance;
530        const int transformed_dist = VP8LDistanceToPlaneCode(xsize, dist);
531        c.cur_pos-&gt;argb_or_distance = transformed_dist;
532      }
533      VP8LRefsCursorNext(&amp;c);
534    }
535  }
536  static int CalculateBestCacheSize(const uint32_t* argb, int quality,
537                                    const VP8LBackwardRefs* const refs,
538                                    int* const best_cache_bits) {
539    int i;
540    const int cache_bits_max = (quality &lt;= 25) ? 0 : *best_cache_bits;
541    double entropy_min = MAX_ENTROPY;
542    int cc_init[MAX_COLOR_CACHE_BITS + 1] = { 0 };
543    VP8LColorCache hashers[MAX_COLOR_CACHE_BITS + 1];
544    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
545    VP8LHistogram* histos[MAX_COLOR_CACHE_BITS + 1] = { NULL };
546    int ok = 0;
547    assert(cache_bits_max &gt;= 0 &amp;&amp; cache_bits_max &lt;= MAX_COLOR_CACHE_BITS);
548    if (cache_bits_max == 0) {
549      *best_cache_bits = 0;
550      return 1;
551    }
552    for (i = 0; i &lt;= cache_bits_max; ++i) {
553      histos[i] = VP8LAllocateHistogram(i);
554      if (histos[i] == NULL) goto Error;
555      VP8LHistogramInit(histos[i], i, &amp;bsol;*init_arrays=*/ 1);
556      if (i == 0) continue;
557      cc_init[i] = VP8LColorCacheInit(&amp;hashers[i], i);
558      if (!cc_init[i]) goto Error;
559    }
560    while (VP8LRefsCursorOk(&amp;c)) {
561      const PixOrCopy* const v = c.cur_pos;
562      if (PixOrCopyIsLiteral(v)) {
563        const uint32_t pix = *argb++;
564        const uint32_t a = (pix &gt;&gt; 24) &amp; 0xff;
565        const uint32_t r = (pix &gt;&gt; 16) &amp; 0xff;
566        const uint32_t g = (pix &gt;&gt;  8) &amp; 0xff;
567        const uint32_t b = (pix &gt;&gt;  0) &amp; 0xff;
568        int key = VP8LHashPix(pix, 32 - cache_bits_max);
569        ++histos[0]-&gt;blue_[b];
570        ++histos[0]-&gt;literal_[g];
571        ++histos[0]-&gt;red_[r];
572        ++histos[0]-&gt;alpha_[a];
573        for (i = cache_bits_max; i &gt;= 1; --i, key &gt;&gt;= 1) {
574          if (VP8LColorCacheLookup(&amp;hashers[i], key) == pix) {
575            ++histos[i]-&gt;literal_[NUM_LITERAL_CODES + NUM_LENGTH_CODES + key];
576          } else {
577            VP8LColorCacheSet(&amp;hashers[i], key, pix);
578            ++histos[i]-&gt;blue_[b];
579            ++histos[i]-&gt;literal_[g];
580            ++histos[i]-&gt;red_[r];
581            ++histos[i]-&gt;alpha_[a];
582          }
583        }
584      } else {
585        int len = PixOrCopyLength(v);
586        uint32_t argb_prev = *argb ^ 0xffffffffu;
587        do {
588          if (*argb != argb_prev) {
589            int key = VP8LHashPix(*argb, 32 - cache_bits_max);
590            for (i = cache_bits_max; i &gt;= 1; --i, key &gt;&gt;= 1) {
591              hashers[i].colors_[key] = *argb;
592            }
593            argb_prev = *argb;
594          }
595          argb++;
596        } while (--len != 0);
597      }
598      VP8LRefsCursorNext(&amp;c);
599    }
600    for (i = 0; i &lt;= cache_bits_max; ++i) {
601      const double entropy = VP8LHistogramEstimateBits(histos[i]);
602      if (i == 0 || entropy &lt; entropy_min) {
603        entropy_min = entropy;
604        *best_cache_bits = i;
605      }
606    }
607    ok = 1;
608  Error:
609    for (i = 0; i &lt;= cache_bits_max; ++i) {
610      if (cc_init[i]) VP8LColorCacheClear(&amp;hashers[i]);
611      VP8LFreeHistogram(histos[i]);
612    }
613    return ok;
614  }
615  static int BackwardRefsWithLocalCache(const uint32_t* const argb,
616                                        int cache_bits,
617                                        VP8LBackwardRefs* const refs) {
618    int pixel_index = 0;
619    VP8LColorCache hashers;
620    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
621    if (!VP8LColorCacheInit(&amp;hashers, cache_bits)) return 0;
622    while (VP8LRefsCursorOk(&amp;c)) {
623      PixOrCopy* const v = c.cur_pos;
624      if (PixOrCopyIsLiteral(v)) {
625        const uint32_t argb_literal = v-&gt;argb_or_distance;
626        const int ix = VP8LColorCacheContains(&amp;hashers, argb_literal);
627        if (ix &gt;= 0) {
628          *v = PixOrCopyCreateCacheIdx(ix);
629        } else {
630          VP8LColorCacheInsert(&amp;hashers, argb_literal);
631        }
632        ++pixel_index;
633      } else {
634        int k;
635        assert(PixOrCopyIsCopy(v));
636        for (k = 0; k &lt; v-&gt;len; ++k) {
637          VP8LColorCacheInsert(&amp;hashers, argb[pixel_index++]);
638        }
639      }
640      VP8LRefsCursorNext(&amp;c);
641    }
642    VP8LColorCacheClear(&amp;hashers);
643    return 1;
644  }
645  static VP8LBackwardRefs* GetBackwardReferencesLowEffort(
646      int width, int height, const uint32_t* const argb,
647      int* const cache_bits, const VP8LHashChain* const hash_chain,
648      VP8LBackwardRefs* const refs_lz77) {
649    *cache_bits = 0;
650    if (!BackwardReferencesLz77(width, height, argb, 0, hash_chain, refs_lz77)) {
651      return NULL;
652    }
653    BackwardReferences2DLocality(width, refs_lz77);
654    return refs_lz77;
655  }
656  extern int VP8LBackwardReferencesTraceBackwards(
657      int xsize, int ysize, const uint32_t* const argb, int cache_bits,
658      const VP8LHashChain* const hash_chain,
659      const VP8LBackwardRefs* const refs_src, VP8LBackwardRefs* const refs_dst);
660  static VP8LBackwardRefs* GetBackwardReferences(
661      int width, int height, const uint32_t* const argb, int quality,
662      int lz77_types_to_try, int* const cache_bits,
663      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* best,
664      VP8LBackwardRefs* worst) {
665    const int cache_bits_initial = *cache_bits;
666    double bit_cost_best = -1;
667    VP8LHistogram* histo = NULL;
668    int lz77_type, lz77_type_best = 0;
669    VP8LHashChain hash_chain_box;
670    memset(&amp;hash_chain_box, 0, sizeof(hash_chain_box));
671    histo = VP8LAllocateHistogram(MAX_COLOR_CACHE_BITS);
672    if (histo == NULL) goto Error;
673    for (lz77_type = 1; lz77_types_to_try;
674         lz77_types_to_try &amp;= ~lz77_type, lz77_type &lt;&lt;= 1) {
675      int res = 0;
676      double bit_cost;
677      int cache_bits_tmp = cache_bits_initial;
678      if ((lz77_types_to_try &amp; lz77_type) == 0) continue;
679      switch (lz77_type) {
680        case kLZ77RLE:
681          res = BackwardReferencesRle(width, height, argb, 0, worst);
682          break;
683        case kLZ77Standard:
684          res = BackwardReferencesLz77(width, height, argb, 0, hash_chain, worst);
685          break;
686        case kLZ77Box:
687          if (!VP8LHashChainInit(&amp;hash_chain_box, width * height)) goto Error;
688          res = BackwardReferencesLz77Box(width, height, argb, 0, hash_chain,
689                                          &amp;hash_chain_box, worst);
690          break;
691        default:
692          assert(0);
693      }
694      if (!res) goto Error;
695      if (!CalculateBestCacheSize(argb, quality, worst, &amp;cache_bits_tmp)) {
696        goto Error;
697      }
698      if (cache_bits_tmp &gt; 0) {
699        if (!BackwardRefsWithLocalCache(argb, cache_bits_tmp, worst)) {
700          goto Error;
701        }
702      }
703      VP8LHistogramCreate(histo, worst, cache_bits_tmp);
704      bit_cost = VP8LHistogramEstimateBits(histo);
705      if (lz77_type_best == 0 || bit_cost &lt; bit_cost_best) {
706        VP8LBackwardRefs* const tmp = worst;
707        worst = best;
708        best = tmp;
709        bit_cost_best = bit_cost;
710        *cache_bits = cache_bits_tmp;
711        lz77_type_best = lz77_type;
712      }
713    }
714    assert(lz77_type_best &gt; 0);
715    if ((lz77_type_best == kLZ77Standard || lz77_type_best == kLZ77Box) &amp;&amp;
716        quality &gt;= 25) {
717      const VP8LHashChain* const hash_chain_tmp =
718          (lz77_type_best == kLZ77Standard) ? hash_chain : &amp;hash_chain_box;
719      if (VP8LBackwardReferencesTraceBackwards(width, height, argb, *cache_bits,
720                                               hash_chain_tmp, best, worst)) {
721        double bit_cost_trace;
722        VP8LHistogramCreate(histo, worst, *cache_bits);
723        bit_cost_trace = VP8LHistogramEstimateBits(histo);
724        if (bit_cost_trace &lt; bit_cost_best) best = worst;
725      }
726    }
727    BackwardReferences2DLocality(width, best);
728  Error:
729    VP8LHashChainClear(&amp;hash_chain_box);
730    VP8LFreeHistogram(histo);
731    return best;
732  }
733  VP8LBackwardRefs* VP8LGetBackwardReferences(
734      int width, int height, const uint32_t* const argb, int quality,
735      int low_effort, int lz77_types_to_try, int* const cache_bits,
736      const VP8LHashChain* const hash_chain, VP8LBackwardRefs* const refs_tmp1,
737      VP8LBackwardRefs* const refs_tmp2) {
738    if (low_effort) {
739      return GetBackwardReferencesLowEffort(width, height, argb, cache_bits,
740                                            hash_chain, refs_tmp1);
741    } else {
742      return GetBackwardReferences(width, height, argb, quality,
743                                   lz77_types_to_try, cache_bits, hash_chain,
744                                   refs_tmp1, refs_tmp2);
745    }
746  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sober128_stream.c</h3>
            <pre><code>1  #include &quot;tomcrypt_private.h&quot;
2  #ifdef LTC_SOBER128
3  #define LTC_SOBER128TAB_C
4  #include &quot;sober128tab.c&quot;
5  #define N                        17
6  #define INITKONST        0x6996c53a &amp;bsol;* value of KONST to use during key loading */
7  #define KEYP                     15 &amp;bsol;* where to insert key words */
8  #define FOLDP                     4 &amp;bsol;* where to insert non-linear feedback */
9  static ulong32 BYTE2WORD(const unsigned char *b)
10  {
11     ulong32 t;
12     LOAD32L(t, b);
13     return t;
14  }
15  static void XORWORD(ulong32 w, const unsigned char *in, unsigned char *out)
16  {
17     ulong32 t;
18     LOAD32L(t, in);
19     t ^= w;
20     STORE32L(t, out);
21  }
22  #define OFF(zero, i) (((zero)+(i)) % N)
23  #define STEP(R,z) \
24      R[OFF(z,0)] = R[OFF(z,15)] ^ R[OFF(z,4)] ^ (R[OFF(z,0)] &lt;&lt; 8) ^ Multab[(R[OFF(z,0)] &gt;&gt; 24) &amp; 0xFF];
25  static void cycle(ulong32 *R)
26  {
27      ulong32 t;
28      int     i;
29      STEP(R,0);
30      t = R[0];
31      for (i = 1; i &lt; N; ++i) {
32          R[i-1] = R[i];
33      }
34      R[N-1] = t;
35  }
36  #define NLFUNC(st,z) \
37  { \
38      t = st-&gt;R[OFF(z,0)] + st-&gt;R[OFF(z,16)]; \
39      t ^= Sbox[(t &gt;&gt; 24) &amp; 0xFF]; \
40      t = RORc(t, 8); \
41      t = ((t + st-&gt;R[OFF(z,1)]) ^ st-&gt;konst) + st-&gt;R[OFF(z,6)]; \
42      t ^= Sbox[(t &gt;&gt; 24) &amp; 0xFF]; \
43      t = t + st-&gt;R[OFF(z,13)]; \
44  }
45  static ulong32 nltap(const sober128_state *st)
46  {
47      ulong32 t;
48      NLFUNC(st, 0);
49      return t;
50  }
51  static void s128_savestate(sober128_state *st)
52  {
53      int i;
54      for (i = 0; i &lt; N; ++i) {
55          st-&gt;initR[i] = st-&gt;R[i];
56      }
57  }
58  static void s128_reloadstate(sober128_state *st)
59  {
60      int i;
61      for (i = 0; i &lt; N; ++i) {
62          st-&gt;R[i] = st-&gt;initR[i];
63      }
64  }
65  static void s128_genkonst(sober128_state *st)
66  {
67      ulong32 newkonst;
68      do {
69         cycle(st-&gt;R);
70         newkonst = nltap(st);
71      } while ((newkonst &amp; 0xFF000000) == 0);
72      st-&gt;konst = newkonst;
73  }
74  #define ADDKEY(k) \
75     st-&gt;R[KEYP] += (k);
76  #define XORNL(nl) \
77     st-&gt;R[FOLDP] ^= (nl);
78  #define DROUND(z) STEP(st-&gt;R,z); NLFUNC(st,(z+1)); st-&gt;R[OFF((z+1),FOLDP)] ^= t;
79  static void s128_diffuse(sober128_state *st)
80  {
81      ulong32 t;
82      DROUND(0);
83      DROUND(1);
84      DROUND(2);
85      DROUND(3);
86      DROUND(4);
87      DROUND(5);
88      DROUND(6);
89      DROUND(7);
90      DROUND(8);
91      DROUND(9);
92      DROUND(10);
93      DROUND(11);
94      DROUND(12);
95      DROUND(13);
96      DROUND(14);
97      DROUND(15);
98      DROUND(16);
99  }
100  int sober128_stream_setup(sober128_state *st, const unsigned char *key, unsigned long keylen)
101  {
102     ulong32 i, k;
103     LTC_ARGCHK(st  != NULL);
104     LTC_ARGCHK(key != NULL);
105     LTC_ARGCHK(keylen &gt; 0);
106     if ((keylen &amp; 3) != 0) {
107        return CRYPT_INVALID_KEYSIZE;
108     }
109     st-&gt;R[0] = 1;
<span onclick='openModal()' class='match'>110     st-&gt;R[1] = 1;
111     for (i = 2; i &lt; N; ++i) {
112        st-&gt;R[i] = st-&gt;R[i-1] + st-&gt;R[i-2];
</span>113     }
114     st-&gt;konst = INITKONST;
115     for (i = 0; i &lt; keylen; i += 4) {
116        k = BYTE2WORD((unsigned char *)&amp;key[i]);
117        ADDKEY(k);
118        cycle(st-&gt;R);
119        XORNL(nltap(st));
120     }
121     ADDKEY(keylen);
122     s128_diffuse(st);
123     s128_genkonst(st);
124     s128_savestate(st);
125     st-&gt;nbuf = 0;
126     return CRYPT_OK;
127  }
128  int sober128_stream_setiv(sober128_state *st, const unsigned char *iv, unsigned long ivlen)
129  {
130     ulong32 i, k;
131     LTC_ARGCHK(st != NULL);
132     LTC_ARGCHK(iv != NULL);
133     LTC_ARGCHK(ivlen &gt; 0);
134     s128_reloadstate(st);
135     if ((ivlen &amp; 3) != 0) {
136        return CRYPT_INVALID_KEYSIZE;
137     }
138     for (i = 0; i &lt; ivlen; i += 4) {
139        k = BYTE2WORD((unsigned char *)&amp;iv[i]);
140        ADDKEY(k);
141        cycle(st-&gt;R);
142        XORNL(nltap(st));
143     }
144     ADDKEY(ivlen);
145     s128_diffuse(st);
146     st-&gt;nbuf = 0;
147     return CRYPT_OK;
148  }
149  #define SROUND(z) STEP(st-&gt;R,z); NLFUNC(st,(z+1)); XORWORD(t, in+(z*4), out+(z*4));
150  int sober128_stream_crypt(sober128_state *st, const unsigned char *in, unsigned long inlen, unsigned char *out)
151  {
152     ulong32 t;
153     if (inlen == 0) return CRYPT_OK; &amp;bsol;* nothing to do */
154     LTC_ARGCHK(out != NULL);
155     LTC_ARGCHK(st  != NULL);
156     while (st-&gt;nbuf != 0 &amp;&amp; inlen != 0) {
157        *out++ = *in++ ^ (unsigned char)(st-&gt;sbuf &amp; 0xFF);
158        st-&gt;sbuf &gt;&gt;= 8;
159        st-&gt;nbuf -= 8;
160        --inlen;
161     }
162  #ifndef LTC_SMALL_CODE
163     while (inlen &gt;= N*4) {
164        SROUND(0);
165        SROUND(1);
166        SROUND(2);
167        SROUND(3);
168        SROUND(4);
169        SROUND(5);
170        SROUND(6);
171        SROUND(7);
172        SROUND(8);
173        SROUND(9);
174        SROUND(10);
175        SROUND(11);
176        SROUND(12);
177        SROUND(13);
178        SROUND(14);
179        SROUND(15);
180        SROUND(16);
181        out    += 4*N;
182        in     += 4*N;
183        inlen  -= 4*N;
184     }
185  #endif
186     while (4 &lt;= inlen) {
187        cycle(st-&gt;R);
188        t = nltap(st);
189        XORWORD(t, in, out);
190        out    += 4;
191        in     += 4;
192        inlen  -= 4;
193     }
194     if (inlen != 0) {
195        cycle(st-&gt;R);
196        st-&gt;sbuf = nltap(st);
197        st-&gt;nbuf = 32;
198        while (st-&gt;nbuf != 0 &amp;&amp; inlen != 0) {
199            *out++ = *in++ ^ (unsigned char)(st-&gt;sbuf &amp; 0xFF);
200            st-&gt;sbuf &gt;&gt;= 8;
201            st-&gt;nbuf -= 8;
202            --inlen;
203        }
204     }
205     return CRYPT_OK;
206  }
207  int sober128_stream_keystream(sober128_state *st, unsigned char *out, unsigned long outlen)
208  {
209     if (outlen == 0) return CRYPT_OK; &amp;bsol;* nothing to do */
210     LTC_ARGCHK(out != NULL);
211     XMEMSET(out, 0, outlen);
212     return sober128_stream_crypt(st, out, outlen, out);
213  }
214  int sober128_stream_done(sober128_state *st)
215  {
216     LTC_ARGCHK(st != NULL);
217     zeromem(st, sizeof(sober128_state));
218     return CRYPT_OK;
219  }
220  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-backward_references_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sober128_stream.c</div>
                </div>
                <div class="column column_space"><pre><code>453    hash_chain-&gt;offset_length_[0] = 0;
454    for (i = 1; i &lt; pix_count; ++i) {
455      int ind;
</pre></code></div>
                <div class="column column_space"><pre><code>110     st-&gt;R[1] = 1;
111     for (i = 2; i &lt; N; ++i) {
112        st-&gt;R[i] = st-&gt;R[i-1] + st-&gt;R[i-2];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    