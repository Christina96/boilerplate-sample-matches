
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 35, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2s.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BLAKE2S
3  enum blake2s_constant {
4     BLAKE2S_BLOCKBYTES = 64,
5     BLAKE2S_OUTBYTES = 32,
6     BLAKE2S_KEYBYTES = 32,
7     BLAKE2S_SALTBYTES = 8,
8     BLAKE2S_PERSONALBYTES = 8,
9     BLAKE2S_PARAM_SIZE = 32
10  };
11  enum {
12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 14,
20     O_INNER_LENGTH = 15,
21     O_SALT = 16,
22     O_PERSONAL = 24
23  };
24  const struct ltc_hash_descriptor blake2s_128_desc =
25  {
26      "blake2s-128",
27      21,
28      16,
29      64,
30      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 4 },
31      11,
32      &blake2s_128_init,
33      &blake2s_process,
34      &blake2s_done,
35      &blake2s_128_test,
36      NULL
37  };
38  const struct ltc_hash_descriptor blake2s_160_desc =
39  {
40      "blake2s-160",
41      22,
42      20,
43      64,
44      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 5 },
45      11,
46      &blake2s_160_init,
47      &blake2s_process,
48      &blake2s_done,
49      &blake2s_160_test,
50      NULL
51  };
52  const struct ltc_hash_descriptor blake2s_224_desc =
53  {
54      "blake2s-224",
55      23,
56      28,
57      64,
58      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 7 },
59      11,
60      &blake2s_224_init,
61      &blake2s_process,
62      &blake2s_done,
63      &blake2s_224_test,
64      NULL
65  };
66  const struct ltc_hash_descriptor blake2s_256_desc =
67  {
68      "blake2s-256",
69      24,
70      32,
71      64,
72      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 8 },
73      11,
74      &blake2s_256_init,
75      &blake2s_process,
76      &blake2s_done,
77      &blake2s_256_test,
78      NULL
79  };
80  static const ulong32 blake2s_IV[8] = {
81      0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,
82      0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL
83  };
84  static const unsigned char blake2s_sigma[10][16] = {
85      { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
86      { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
87      { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
88      { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
89      { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
90      { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },
91      { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },
92      { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },
93      { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },
94      { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },
95  };
96  static void s_blake2s_set_lastnode(hash_state *md) { md->blake2s.f[1] = 0xffffffffUL; }
97  static int s_blake2s_is_lastblock(const hash_state *md) { return md->blake2s.f[0] != 0; }
98  static void s_blake2s_set_lastblock(hash_state *md)
99  {
100     if (md->blake2s.last_node) {
101        s_blake2s_set_lastnode(md);
102     }
103     md->blake2s.f[0] = 0xffffffffUL;
104  }
105  static void s_blake2s_increment_counter(hash_state *md, const ulong32 inc)
106  {
<span onclick='openModal()' class='match'>107     md->blake2s.t[0] += inc;
108     if (md->blake2s.t[0] < inc) md->blake2s.t[1]++;
109  }
110  static int s_blake2s_init0(hash_state *md)
</span>111  {
112     int i;
113     XMEMSET(&md->blake2s, 0, sizeof(struct blake2s_state));
114     for (i = 0; i < 8; ++i) {
115        md->blake2s.h[i] = blake2s_IV[i];
116     }
117     return CRYPT_OK;
118  }
119  static int s_blake2s_init_param(hash_state *md, const unsigned char *P)
120  {
121     unsigned long i;
122     s_blake2s_init0(md);
123     for (i = 0; i < 8; ++i) {
124        ulong32 tmp;
125        LOAD32L(tmp, P + i * 4);
126        md->blake2s.h[i] ^= tmp;
127     }
128     md->blake2s.outlen = P[O_DIGEST_LENGTH];
129     return CRYPT_OK;
130  }
131  int blake2s_init(hash_state *md, unsigned long outlen, const unsigned char *key, unsigned long keylen)
132  {
133     unsigned char P[BLAKE2S_PARAM_SIZE];
134     int err;
135     LTC_ARGCHK(md != NULL);
136     if ((!outlen) || (outlen > BLAKE2S_OUTBYTES)) {
137        return CRYPT_INVALID_ARG;
138     }
139     if ((key && !keylen) || (keylen && !key) || (keylen > BLAKE2S_KEYBYTES)) {
140        return CRYPT_INVALID_ARG;
141     }
142     XMEMSET(P, 0, sizeof(P));
143     P[O_DIGEST_LENGTH] = (unsigned char)outlen;
144     P[O_KEY_LENGTH] = (unsigned char)keylen;
145     P[O_FANOUT] = 1;
146     P[O_DEPTH] = 1;
147     err = s_blake2s_init_param(md, P);
148     if (err != CRYPT_OK) return err;
149     if (key) {
150        unsigned char block[BLAKE2S_BLOCKBYTES];
151        XMEMSET(block, 0, BLAKE2S_BLOCKBYTES);
152        XMEMCPY(block, key, keylen);
153        blake2s_process(md, block, BLAKE2S_BLOCKBYTES);
154  #ifdef LTC_CLEAN_STACK
155        zeromem(block, sizeof(block));
156  #endif
157     }
158     return CRYPT_OK;
159  }
160  int blake2s_128_init(hash_state *md) { return blake2s_init(md, 16, NULL, 0); }
161  int blake2s_160_init(hash_state *md) { return blake2s_init(md, 20, NULL, 0); }
162  int blake2s_224_init(hash_state *md) { return blake2s_init(md, 28, NULL, 0); }
163  int blake2s_256_init(hash_state *md) { return blake2s_init(md, 32, NULL, 0); }
164  #define G(r, i, a, b, c, d)                                                                                            \
165     do {                                                                                                                \
166        a = a + b + m[blake2s_sigma[r][2 * i + 0]];                                                                      \
167        d = ROR(d ^ a, 16);                                                                                              \
168        c = c + d;                                                                                                       \
169        b = ROR(b ^ c, 12);                                                                                              \
170        a = a + b + m[blake2s_sigma[r][2 * i + 1]];                                                                      \
171        d = ROR(d ^ a, 8);                                                                                               \
172        c = c + d;                                                                                                       \
173        b = ROR(b ^ c, 7);                                                                                               \
174     } while (0)
175  #define ROUND(r)                                                                                                       \
176     do {                                                                                                                \
177        G(r, 0, v[0], v[4], v[8], v[12]);                                                                                \
178        G(r, 1, v[1], v[5], v[9], v[13]);                                                                                \
179        G(r, 2, v[2], v[6], v[10], v[14]);                                                                               \
180        G(r, 3, v[3], v[7], v[11], v[15]);                                                                               \
181        G(r, 4, v[0], v[5], v[10], v[15]);                                                                               \
182        G(r, 5, v[1], v[6], v[11], v[12]);                                                                               \
183        G(r, 6, v[2], v[7], v[8], v[13]);                                                                                \
184        G(r, 7, v[3], v[4], v[9], v[14]);                                                                                \
185     } while (0)
186  #ifdef LTC_CLEAN_STACK
187  static int ss_blake2s_compress(hash_state *md, const unsigned char *buf)
188  #else
189  static int s_blake2s_compress(hash_state *md, const unsigned char *buf)
190  #endif
191  {
192     unsigned long i;
193     ulong32 m[16];
194     ulong32 v[16];
195     for (i = 0; i < 16; ++i) {
196        LOAD32L(m[i], buf + i * sizeof(m[i]));
197     }
198     for (i = 0; i < 8; ++i) {
199        v[i] = md->blake2s.h[i];
200     }
201     v[8] = blake2s_IV[0];
202     v[9] = blake2s_IV[1];
203     v[10] = blake2s_IV[2];
204     v[11] = blake2s_IV[3];
205     v[12] = md->blake2s.t[0] ^ blake2s_IV[4];
206     v[13] = md->blake2s.t[1] ^ blake2s_IV[5];
207     v[14] = md->blake2s.f[0] ^ blake2s_IV[6];
208     v[15] = md->blake2s.f[1] ^ blake2s_IV[7];
209     ROUND(0);
210     ROUND(1);
211     ROUND(2);
212     ROUND(3);
213     ROUND(4);
214     ROUND(5);
215     ROUND(6);
216     ROUND(7);
217     ROUND(8);
218     ROUND(9);
219     for (i = 0; i < 8; ++i) {
220        md->blake2s.h[i] = md->blake2s.h[i] ^ v[i] ^ v[i + 8];
221     }
222     return CRYPT_OK;
223  }
224  #undef G
225  #undef ROUND
226  #ifdef LTC_CLEAN_STACK
227  static int s_blake2s_compress(hash_state *md, const unsigned char *buf)
228  {
229     int err;
230     err = ss_blake2s_compress(md, buf);
231     burn_stack(sizeof(ulong32) * (32) + sizeof(unsigned long));
232     return err;
233  }
234  #endif
235  int blake2s_process(hash_state *md, const unsigned char *in, unsigned long inlen)
236  {
237     LTC_ARGCHK(md != NULL);
238     LTC_ARGCHK(in != NULL);
239     if (md->blake2s.curlen > sizeof(md->blake2s.buf)) {
240        return CRYPT_INVALID_ARG;
241     }
242     if (inlen > 0) {
243        unsigned long left = md->blake2s.curlen;
244        unsigned long fill = BLAKE2S_BLOCKBYTES - left;
245        if (inlen > fill) {
246           md->blake2s.curlen = 0;
247           XMEMCPY(md->blake2s.buf + (left % sizeof(md->blake2s.buf)), in, fill); &bsol;* Fill buffer */
248           s_blake2s_increment_counter(md, BLAKE2S_BLOCKBYTES);
249           s_blake2s_compress(md, md->blake2s.buf); &bsol;* Compress */
250           in += fill;
251           inlen -= fill;
252           while (inlen > BLAKE2S_BLOCKBYTES) {
253              s_blake2s_increment_counter(md, BLAKE2S_BLOCKBYTES);
254              s_blake2s_compress(md, in);
255              in += BLAKE2S_BLOCKBYTES;
256              inlen -= BLAKE2S_BLOCKBYTES;
257           }
258        }
259        XMEMCPY(md->blake2s.buf + md->blake2s.curlen, in, inlen);
260        md->blake2s.curlen += inlen;
261     }
262     return CRYPT_OK;
263  }
264  int blake2s_done(hash_state *md, unsigned char *out)
265  {
266     unsigned char buffer[BLAKE2S_OUTBYTES] = { 0 };
267     unsigned long i;
268     LTC_ARGCHK(md != NULL);
269     LTC_ARGCHK(out != NULL);
270     if (s_blake2s_is_lastblock(md)) {
271        return CRYPT_ERROR;
272     }
273     s_blake2s_increment_counter(md, md->blake2s.curlen);
274     s_blake2s_set_lastblock(md);
275     XMEMSET(md->blake2s.buf + md->blake2s.curlen, 0, BLAKE2S_BLOCKBYTES - md->blake2s.curlen); &bsol;* Padding */
276     s_blake2s_compress(md, md->blake2s.buf);
277     for (i = 0; i < 8; ++i) { &bsol;* Output full hash to temp buffer */
278        STORE32L(md->blake2s.h[i], buffer + i * 4);
279     }
280     XMEMCPY(out, buffer, md->blake2s.outlen);
281     zeromem(md, sizeof(hash_state));
282  #ifdef LTC_CLEAN_STACK
283     zeromem(buffer, sizeof(buffer));
284  #endif
285     return CRYPT_OK;
286  }
287  int blake2s_256_test(void)
288  {
289  #ifndef LTC_TEST
290     return CRYPT_NOP;
291  #else
292     static const struct {
293        const char *msg;
294        unsigned char hash[32];
295    } tests[] = {
296      { "",
297        { 0x69, 0x21, 0x7a, 0x30, 0x79, 0x90, 0x80, 0x94,
298          0xe1, 0x11, 0x21, 0xd0, 0x42, 0x35, 0x4a, 0x7c,
299          0x1f, 0x55, 0xb6, 0x48, 0x2c, 0xa1, 0xa5, 0x1e,
300          0x1b, 0x25, 0x0d, 0xfd, 0x1e, 0xd0, 0xee, 0xf9 } },
301      { "abc",
302        { 0x50, 0x8c, 0x5e, 0x8c, 0x32, 0x7c, 0x14, 0xe2,
303          0xe1, 0xa7, 0x2b, 0xa3, 0x4e, 0xeb, 0x45, 0x2f,
304          0x37, 0x45, 0x8b, 0x20, 0x9e, 0xd6, 0x3a, 0x29,
305          0x4d, 0x99, 0x9b, 0x4c, 0x86, 0x67, 0x59, 0x82 } },
306      { "12345678901234567890123456789012345678901234567890"
307        "12345678901234567890123456789012345678901234567890"
308        "12345678901234567890123456789012345678901234567890"
309        "12345678901234567890123456789012345678901234567890"
310        "12345678901234567890123456789012345678901234567890"
311        "12345678901234567890123456789012345678901234567890",
312        { 0xa3, 0x78, 0x8b, 0x5b, 0x59, 0xee, 0xe4, 0x41,
313          0x95, 0x23, 0x58, 0x00, 0xa4, 0xf9, 0xfa, 0x41,
314          0x86, 0x0c, 0x7b, 0x1c, 0x35, 0xa2, 0x42, 0x70,
315          0x50, 0x80, 0x79, 0x56, 0xe3, 0xbe, 0x31, 0x74 } },
316      { NULL, { 0 } }
317    };
318     int i;
319     unsigned char tmp[32];
320     hash_state md;
321     for (i = 0; tests[i].msg != NULL; i++) {
322        blake2s_256_init(&md);
323        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
324        blake2s_done(&md, tmp);
325        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_256", i)) {
326           return CRYPT_FAIL_TESTVECTOR;
327        }
328     }
329     return CRYPT_OK;
330  #endif
331  }
332  int blake2s_224_test(void)
333  {
334  #ifndef LTC_TEST
335     return CRYPT_NOP;
336  #else
337     static const struct {
338        const char *msg;
339        unsigned char hash[28];
340    } tests[] = {
341      { "",
342        { 0x1f, 0xa1, 0x29, 0x1e, 0x65, 0x24, 0x8b, 0x37,
343          0xb3, 0x43, 0x34, 0x75, 0xb2, 0xa0, 0xdd, 0x63,
344          0xd5, 0x4a, 0x11, 0xec, 0xc4, 0xe3, 0xe0, 0x34,
345          0xe7, 0xbc, 0x1e, 0xf4 } },
346      { "abc",
347        { 0x0b, 0x03, 0x3f, 0xc2, 0x26, 0xdf, 0x7a, 0xbd,
348          0xe2, 0x9f, 0x67, 0xa0, 0x5d, 0x3d, 0xc6, 0x2c,
349          0xf2, 0x71, 0xef, 0x3d, 0xfe, 0xa4, 0xd3, 0x87,
350          0x40, 0x7f, 0xbd, 0x55 } },
351      { NULL, { 0 } }
352    };
353     int i;
354     unsigned char tmp[28];
355     hash_state md;
356     for (i = 0; tests[i].msg != NULL; i++) {
357        blake2s_224_init(&md);
358        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
359        blake2s_done(&md, tmp);
360        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_224", i)) {
361           return CRYPT_FAIL_TESTVECTOR;
362        }
363     }
364     return CRYPT_OK;
365  #endif
366  }
367  int blake2s_160_test(void)
368  {
369  #ifndef LTC_TEST
370     return CRYPT_NOP;
371  #else
372     static const struct {
373        const char *msg;
374        unsigned char hash[20];
375    } tests[] = {
376      { "",
377        { 0x35, 0x4c, 0x9c, 0x33, 0xf7, 0x35, 0x96, 0x24,
378          0x18, 0xbd, 0xac, 0xb9, 0x47, 0x98, 0x73, 0x42,
379          0x9c, 0x34, 0x91, 0x6f} },
380      { "abc",
381        { 0x5a, 0xe3, 0xb9, 0x9b, 0xe2, 0x9b, 0x01, 0x83,
382          0x4c, 0x3b, 0x50, 0x85, 0x21, 0xed, 0xe6, 0x04,
383          0x38, 0xf8, 0xde, 0x17 } },
384      { NULL, { 0 } }
385    };
386     int i;
387     unsigned char tmp[20];
388     hash_state md;
389     for (i = 0; tests[i].msg != NULL; i++) {
390        blake2s_160_init(&md);
391        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
392        blake2s_done(&md, tmp);
393        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_160", i)) {
394           return CRYPT_FAIL_TESTVECTOR;
395        }
396     }
397     return CRYPT_OK;
398  #endif
399  }
400  int blake2s_128_test(void)
401  {
402  #ifndef LTC_TEST
403     return CRYPT_NOP;
404  #else
405     static const struct {
406        const char *msg;
407        unsigned char hash[16];
408    } tests[] = {
409      { "",
410        { 0x64, 0x55, 0x0d, 0x6f, 0xfe, 0x2c, 0x0a, 0x01,
411          0xa1, 0x4a, 0xba, 0x1e, 0xad, 0xe0, 0x20, 0x0c } },
412      { "abc",
413        { 0xaa, 0x49, 0x38, 0x11, 0x9b, 0x1d, 0xc7, 0xb8,
414          0x7c, 0xba, 0xd0, 0xff, 0xd2, 0x00, 0xd0, 0xae } },
415      { NULL, { 0 } }
416    };
417     int i;
418     unsigned char tmp[16];
419     hash_state md;
420     for (i = 0; tests[i].msg != NULL; i++) {
421        blake2s_128_init(&md);
422        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
423        blake2s_done(&md, tmp);
424        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_128", i)) {
425           return CRYPT_FAIL_TESTVECTOR;
426        }
427     }
428     return CRYPT_OK;
429  #endif
430  }
431  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2s.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_BLAKE2S
3  enum blake2s_constant {
4     BLAKE2S_BLOCKBYTES = 64,
5     BLAKE2S_OUTBYTES = 32,
6     BLAKE2S_KEYBYTES = 32,
7     BLAKE2S_SALTBYTES = 8,
8     BLAKE2S_PERSONALBYTES = 8,
9     BLAKE2S_PARAM_SIZE = 32
10  };
11  enum {
12     O_DIGEST_LENGTH = 0,
13     O_KEY_LENGTH = 1,
14     O_FANOUT = 2,
15     O_DEPTH = 3,
16     O_LEAF_LENGTH = 4,
17     O_NODE_OFFSET = 8,
18     O_XOF_LENGTH = 12,
19     O_NODE_DEPTH = 14,
20     O_INNER_LENGTH = 15,
21     O_SALT = 16,
22     O_PERSONAL = 24
23  };
24  const struct ltc_hash_descriptor blake2s_128_desc =
25  {
26      "blake2s-128",
27      21,
28      16,
29      64,
30      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 4 },
31      11,
32      &blake2s_128_init,
33      &blake2s_process,
34      &blake2s_done,
35      &blake2s_128_test,
36      NULL
37  };
38  const struct ltc_hash_descriptor blake2s_160_desc =
39  {
40      "blake2s-160",
41      22,
42      20,
43      64,
44      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 5 },
45      11,
46      &blake2s_160_init,
47      &blake2s_process,
48      &blake2s_done,
49      &blake2s_160_test,
50      NULL
51  };
52  const struct ltc_hash_descriptor blake2s_224_desc =
53  {
54      "blake2s-224",
55      23,
56      28,
57      64,
58      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 7 },
59      11,
60      &blake2s_224_init,
61      &blake2s_process,
62      &blake2s_done,
63      &blake2s_224_test,
64      NULL
65  };
66  const struct ltc_hash_descriptor blake2s_256_desc =
67  {
68      "blake2s-256",
69      24,
70      32,
71      64,
72      { 1, 3, 6, 1, 4, 1, 1722, 12, 2, 2, 8 },
73      11,
74      &blake2s_256_init,
75      &blake2s_process,
76      &blake2s_done,
77      &blake2s_256_test,
78      NULL
79  };
80  static const ulong32 blake2s_IV[8] = {
81      0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,
82      0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL
83  };
84  static const unsigned char blake2s_sigma[10][16] = {
85      { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
86      { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },
87      { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },
88      { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },
89      { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },
90      { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },
91      { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },
92      { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },
93      { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },
94      { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },
95  };
96  static void s_blake2s_set_lastnode(hash_state *md) { md->blake2s.f[1] = 0xffffffffUL; }
97  static int s_blake2s_is_lastblock(const hash_state *md) { return md->blake2s.f[0] != 0; }
98  static void s_blake2s_set_lastblock(hash_state *md)
99  {
100     if (md->blake2s.last_node) {
101        s_blake2s_set_lastnode(md);
102     }
103     md->blake2s.f[0] = 0xffffffffUL;
104  }
105  static void s_blake2s_increment_counter(hash_state *md, const ulong32 inc)
106  {
<span onclick='openModal()' class='match'>107     md->blake2s.t[0] += inc;
108     if (md->blake2s.t[0] < inc) md->blake2s.t[1]++;
109  }
110  static int s_blake2s_init0(hash_state *md)
</span>111  {
112     int i;
113     XMEMSET(&md->blake2s, 0, sizeof(struct blake2s_state));
114     for (i = 0; i < 8; ++i) {
115        md->blake2s.h[i] = blake2s_IV[i];
116     }
117     return CRYPT_OK;
118  }
119  static int s_blake2s_init_param(hash_state *md, const unsigned char *P)
120  {
121     unsigned long i;
122     s_blake2s_init0(md);
123     for (i = 0; i < 8; ++i) {
124        ulong32 tmp;
125        LOAD32L(tmp, P + i * 4);
126        md->blake2s.h[i] ^= tmp;
127     }
128     md->blake2s.outlen = P[O_DIGEST_LENGTH];
129     return CRYPT_OK;
130  }
131  int blake2s_init(hash_state *md, unsigned long outlen, const unsigned char *key, unsigned long keylen)
132  {
133     unsigned char P[BLAKE2S_PARAM_SIZE];
134     int err;
135     LTC_ARGCHK(md != NULL);
136     if ((!outlen) || (outlen > BLAKE2S_OUTBYTES)) {
137        return CRYPT_INVALID_ARG;
138     }
139     if ((key && !keylen) || (keylen && !key) || (keylen > BLAKE2S_KEYBYTES)) {
140        return CRYPT_INVALID_ARG;
141     }
142     XMEMSET(P, 0, sizeof(P));
143     P[O_DIGEST_LENGTH] = (unsigned char)outlen;
144     P[O_KEY_LENGTH] = (unsigned char)keylen;
145     P[O_FANOUT] = 1;
146     P[O_DEPTH] = 1;
147     err = s_blake2s_init_param(md, P);
148     if (err != CRYPT_OK) return err;
149     if (key) {
150        unsigned char block[BLAKE2S_BLOCKBYTES];
151        XMEMSET(block, 0, BLAKE2S_BLOCKBYTES);
152        XMEMCPY(block, key, keylen);
153        blake2s_process(md, block, BLAKE2S_BLOCKBYTES);
154  #ifdef LTC_CLEAN_STACK
155        zeromem(block, sizeof(block));
156  #endif
157     }
158     return CRYPT_OK;
159  }
160  int blake2s_128_init(hash_state *md) { return blake2s_init(md, 16, NULL, 0); }
161  int blake2s_160_init(hash_state *md) { return blake2s_init(md, 20, NULL, 0); }
162  int blake2s_224_init(hash_state *md) { return blake2s_init(md, 28, NULL, 0); }
163  int blake2s_256_init(hash_state *md) { return blake2s_init(md, 32, NULL, 0); }
164  #define G(r, i, a, b, c, d)                                                                                            \
165     do {                                                                                                                \
166        a = a + b + m[blake2s_sigma[r][2 * i + 0]];                                                                      \
167        d = ROR(d ^ a, 16);                                                                                              \
168        c = c + d;                                                                                                       \
169        b = ROR(b ^ c, 12);                                                                                              \
170        a = a + b + m[blake2s_sigma[r][2 * i + 1]];                                                                      \
171        d = ROR(d ^ a, 8);                                                                                               \
172        c = c + d;                                                                                                       \
173        b = ROR(b ^ c, 7);                                                                                               \
174     } while (0)
175  #define ROUND(r)                                                                                                       \
176     do {                                                                                                                \
177        G(r, 0, v[0], v[4], v[8], v[12]);                                                                                \
178        G(r, 1, v[1], v[5], v[9], v[13]);                                                                                \
179        G(r, 2, v[2], v[6], v[10], v[14]);                                                                               \
180        G(r, 3, v[3], v[7], v[11], v[15]);                                                                               \
181        G(r, 4, v[0], v[5], v[10], v[15]);                                                                               \
182        G(r, 5, v[1], v[6], v[11], v[12]);                                                                               \
183        G(r, 6, v[2], v[7], v[8], v[13]);                                                                                \
184        G(r, 7, v[3], v[4], v[9], v[14]);                                                                                \
185     } while (0)
186  #ifdef LTC_CLEAN_STACK
187  static int ss_blake2s_compress(hash_state *md, const unsigned char *buf)
188  #else
189  static int s_blake2s_compress(hash_state *md, const unsigned char *buf)
190  #endif
191  {
192     unsigned long i;
193     ulong32 m[16];
194     ulong32 v[16];
195     for (i = 0; i < 16; ++i) {
196        LOAD32L(m[i], buf + i * sizeof(m[i]));
197     }
198     for (i = 0; i < 8; ++i) {
199        v[i] = md->blake2s.h[i];
200     }
201     v[8] = blake2s_IV[0];
202     v[9] = blake2s_IV[1];
203     v[10] = blake2s_IV[2];
204     v[11] = blake2s_IV[3];
205     v[12] = md->blake2s.t[0] ^ blake2s_IV[4];
206     v[13] = md->blake2s.t[1] ^ blake2s_IV[5];
207     v[14] = md->blake2s.f[0] ^ blake2s_IV[6];
208     v[15] = md->blake2s.f[1] ^ blake2s_IV[7];
209     ROUND(0);
210     ROUND(1);
211     ROUND(2);
212     ROUND(3);
213     ROUND(4);
214     ROUND(5);
215     ROUND(6);
216     ROUND(7);
217     ROUND(8);
218     ROUND(9);
219     for (i = 0; i < 8; ++i) {
220        md->blake2s.h[i] = md->blake2s.h[i] ^ v[i] ^ v[i + 8];
221     }
222     return CRYPT_OK;
223  }
224  #undef G
225  #undef ROUND
226  #ifdef LTC_CLEAN_STACK
227  static int s_blake2s_compress(hash_state *md, const unsigned char *buf)
228  {
229     int err;
230     err = ss_blake2s_compress(md, buf);
231     burn_stack(sizeof(ulong32) * (32) + sizeof(unsigned long));
232     return err;
233  }
234  #endif
235  int blake2s_process(hash_state *md, const unsigned char *in, unsigned long inlen)
236  {
237     LTC_ARGCHK(md != NULL);
238     LTC_ARGCHK(in != NULL);
239     if (md->blake2s.curlen > sizeof(md->blake2s.buf)) {
240        return CRYPT_INVALID_ARG;
241     }
242     if (inlen > 0) {
243        unsigned long left = md->blake2s.curlen;
244        unsigned long fill = BLAKE2S_BLOCKBYTES - left;
245        if (inlen > fill) {
246           md->blake2s.curlen = 0;
247           XMEMCPY(md->blake2s.buf + (left % sizeof(md->blake2s.buf)), in, fill); &bsol;* Fill buffer */
248           s_blake2s_increment_counter(md, BLAKE2S_BLOCKBYTES);
249           s_blake2s_compress(md, md->blake2s.buf); &bsol;* Compress */
250           in += fill;
251           inlen -= fill;
252           while (inlen > BLAKE2S_BLOCKBYTES) {
253              s_blake2s_increment_counter(md, BLAKE2S_BLOCKBYTES);
254              s_blake2s_compress(md, in);
255              in += BLAKE2S_BLOCKBYTES;
256              inlen -= BLAKE2S_BLOCKBYTES;
257           }
258        }
259        XMEMCPY(md->blake2s.buf + md->blake2s.curlen, in, inlen);
260        md->blake2s.curlen += inlen;
261     }
262     return CRYPT_OK;
263  }
264  int blake2s_done(hash_state *md, unsigned char *out)
265  {
266     unsigned char buffer[BLAKE2S_OUTBYTES] = { 0 };
267     unsigned long i;
268     LTC_ARGCHK(md != NULL);
269     LTC_ARGCHK(out != NULL);
270     if (s_blake2s_is_lastblock(md)) {
271        return CRYPT_ERROR;
272     }
273     s_blake2s_increment_counter(md, md->blake2s.curlen);
274     s_blake2s_set_lastblock(md);
275     XMEMSET(md->blake2s.buf + md->blake2s.curlen, 0, BLAKE2S_BLOCKBYTES - md->blake2s.curlen); &bsol;* Padding */
276     s_blake2s_compress(md, md->blake2s.buf);
277     for (i = 0; i < 8; ++i) { &bsol;* Output full hash to temp buffer */
278        STORE32L(md->blake2s.h[i], buffer + i * 4);
279     }
280     XMEMCPY(out, buffer, md->blake2s.outlen);
281     zeromem(md, sizeof(hash_state));
282  #ifdef LTC_CLEAN_STACK
283     zeromem(buffer, sizeof(buffer));
284  #endif
285     return CRYPT_OK;
286  }
287  int blake2s_256_test(void)
288  {
289  #ifndef LTC_TEST
290     return CRYPT_NOP;
291  #else
292     static const struct {
293        const char *msg;
294        unsigned char hash[32];
295    } tests[] = {
296      { "",
297        { 0x69, 0x21, 0x7a, 0x30, 0x79, 0x90, 0x80, 0x94,
298          0xe1, 0x11, 0x21, 0xd0, 0x42, 0x35, 0x4a, 0x7c,
299          0x1f, 0x55, 0xb6, 0x48, 0x2c, 0xa1, 0xa5, 0x1e,
300          0x1b, 0x25, 0x0d, 0xfd, 0x1e, 0xd0, 0xee, 0xf9 } },
301      { "abc",
302        { 0x50, 0x8c, 0x5e, 0x8c, 0x32, 0x7c, 0x14, 0xe2,
303          0xe1, 0xa7, 0x2b, 0xa3, 0x4e, 0xeb, 0x45, 0x2f,
304          0x37, 0x45, 0x8b, 0x20, 0x9e, 0xd6, 0x3a, 0x29,
305          0x4d, 0x99, 0x9b, 0x4c, 0x86, 0x67, 0x59, 0x82 } },
306      { "12345678901234567890123456789012345678901234567890"
307        "12345678901234567890123456789012345678901234567890"
308        "12345678901234567890123456789012345678901234567890"
309        "12345678901234567890123456789012345678901234567890"
310        "12345678901234567890123456789012345678901234567890"
311        "12345678901234567890123456789012345678901234567890",
312        { 0xa3, 0x78, 0x8b, 0x5b, 0x59, 0xee, 0xe4, 0x41,
313          0x95, 0x23, 0x58, 0x00, 0xa4, 0xf9, 0xfa, 0x41,
314          0x86, 0x0c, 0x7b, 0x1c, 0x35, 0xa2, 0x42, 0x70,
315          0x50, 0x80, 0x79, 0x56, 0xe3, 0xbe, 0x31, 0x74 } },
316      { NULL, { 0 } }
317    };
318     int i;
319     unsigned char tmp[32];
320     hash_state md;
321     for (i = 0; tests[i].msg != NULL; i++) {
322        blake2s_256_init(&md);
323        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
324        blake2s_done(&md, tmp);
325        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_256", i)) {
326           return CRYPT_FAIL_TESTVECTOR;
327        }
328     }
329     return CRYPT_OK;
330  #endif
331  }
332  int blake2s_224_test(void)
333  {
334  #ifndef LTC_TEST
335     return CRYPT_NOP;
336  #else
337     static const struct {
338        const char *msg;
339        unsigned char hash[28];
340    } tests[] = {
341      { "",
342        { 0x1f, 0xa1, 0x29, 0x1e, 0x65, 0x24, 0x8b, 0x37,
343          0xb3, 0x43, 0x34, 0x75, 0xb2, 0xa0, 0xdd, 0x63,
344          0xd5, 0x4a, 0x11, 0xec, 0xc4, 0xe3, 0xe0, 0x34,
345          0xe7, 0xbc, 0x1e, 0xf4 } },
346      { "abc",
347        { 0x0b, 0x03, 0x3f, 0xc2, 0x26, 0xdf, 0x7a, 0xbd,
348          0xe2, 0x9f, 0x67, 0xa0, 0x5d, 0x3d, 0xc6, 0x2c,
349          0xf2, 0x71, 0xef, 0x3d, 0xfe, 0xa4, 0xd3, 0x87,
350          0x40, 0x7f, 0xbd, 0x55 } },
351      { NULL, { 0 } }
352    };
353     int i;
354     unsigned char tmp[28];
355     hash_state md;
356     for (i = 0; tests[i].msg != NULL; i++) {
357        blake2s_224_init(&md);
358        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
359        blake2s_done(&md, tmp);
360        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_224", i)) {
361           return CRYPT_FAIL_TESTVECTOR;
362        }
363     }
364     return CRYPT_OK;
365  #endif
366  }
367  int blake2s_160_test(void)
368  {
369  #ifndef LTC_TEST
370     return CRYPT_NOP;
371  #else
372     static const struct {
373        const char *msg;
374        unsigned char hash[20];
375    } tests[] = {
376      { "",
377        { 0x35, 0x4c, 0x9c, 0x33, 0xf7, 0x35, 0x96, 0x24,
378          0x18, 0xbd, 0xac, 0xb9, 0x47, 0x98, 0x73, 0x42,
379          0x9c, 0x34, 0x91, 0x6f} },
380      { "abc",
381        { 0x5a, 0xe3, 0xb9, 0x9b, 0xe2, 0x9b, 0x01, 0x83,
382          0x4c, 0x3b, 0x50, 0x85, 0x21, 0xed, 0xe6, 0x04,
383          0x38, 0xf8, 0xde, 0x17 } },
384      { NULL, { 0 } }
385    };
386     int i;
387     unsigned char tmp[20];
388     hash_state md;
389     for (i = 0; tests[i].msg != NULL; i++) {
390        blake2s_160_init(&md);
391        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
392        blake2s_done(&md, tmp);
393        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_160", i)) {
394           return CRYPT_FAIL_TESTVECTOR;
395        }
396     }
397     return CRYPT_OK;
398  #endif
399  }
400  int blake2s_128_test(void)
401  {
402  #ifndef LTC_TEST
403     return CRYPT_NOP;
404  #else
405     static const struct {
406        const char *msg;
407        unsigned char hash[16];
408    } tests[] = {
409      { "",
410        { 0x64, 0x55, 0x0d, 0x6f, 0xfe, 0x2c, 0x0a, 0x01,
411          0xa1, 0x4a, 0xba, 0x1e, 0xad, 0xe0, 0x20, 0x0c } },
412      { "abc",
413        { 0xaa, 0x49, 0x38, 0x11, 0x9b, 0x1d, 0xc7, 0xb8,
414          0x7c, 0xba, 0xd0, 0xff, 0xd2, 0x00, 0xd0, 0xae } },
415      { NULL, { 0 } }
416    };
417     int i;
418     unsigned char tmp[16];
419     hash_state md;
420     for (i = 0; tests[i].msg != NULL; i++) {
421        blake2s_128_init(&md);
422        blake2s_process(&md, (unsigned char *)tests[i].msg, (unsigned long)XSTRLEN(tests[i].msg));
423        blake2s_done(&md, tmp);
424        if (compare_testvector(tmp, sizeof(tmp), tests[i].hash, sizeof(tests[i].hash), "BLAKE2S_128", i)) {
425           return CRYPT_FAIL_TESTVECTOR;
426        }
427     }
428     return CRYPT_OK;
429  #endif
430  }
431  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2s.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-blake2s.c</div>
                </div>
                <div class="column column_space"><pre><code>107     md->blake2s.t[0] += inc;
108     if (md->blake2s.t[0] < inc) md->blake2s.t[1]++;
109  }
110  static int s_blake2s_init0(hash_state *md)
</pre></code></div>
                <div class="column column_space"><pre><code>107     md->blake2s.t[0] += inc;
108     if (md->blake2s.t[0] < inc) md->blake2s.t[1]++;
109  }
110  static int s_blake2s_init0(hash_state *md)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    