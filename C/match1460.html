<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for infinoted-log.c &amp; infc-session-proxy.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infinoted-log.c &amp; infc-session-proxy.c
      </h3>
<h1 align="center">
        7.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infinoted-log.c (11.555555%)<th>infc-session-proxy.c (5.54371%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(269-293)<td><a href="#" name="0">(458-483)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(201-230)<td><a href="#" name="1">(1070-1112)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infinoted-log.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:infinoted-log
 * @title: InfinotedLog
 * @short_description: A class to handle logging of messages.
 * @include: infinoted/infinoted-log.h
 * @stability: Unstable
 *
 * #InfinotedLog manages a message log. Messages can be written to the log
 * either as informational, warning and error messages. If the log was
 * successfully opened, also a glib logging handler is installed which
 * redirects glib logging to this class. Log output is always shown on
 * stderr and, optionally, can be duplicated to a file as well.
 **/

#include &lt;infinoted/infinoted-log.h&gt;
#include &lt;infinoted/infinoted-util.h&gt;

#include &lt;libinfinity/inf-i18n.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;

#ifdef LIBINFINITY_HAVE_LIBDAEMON
# include &lt;libdaemon/dlog.h&gt;
#endif

#ifdef G_OS_WIN32
/* Arbitrary; they are not used currently anyway */
# define LOG_ERR 0
# define LOG_WARNING 1
# define LOG_INFO 2
# include &lt;windows.h&gt;
#else
# include &lt;syslog.h&gt;
#endif

typedef struct _InfinotedLogPrivate InfinotedLogPrivate;
struct _InfinotedLogPrivate {
  gchar* file_path;
  FILE* log_file;
  GLogFunc prev_log_handler;
  GRecMutex mutex;

  guint recursion_depth;
};

enum {
  PROP_0,

  /* read only */
  PROP_FILE_PATH
};

enum {
  LOG_MESSAGE,

  LAST_SIGNAL
};

#define INFINOTED_LOG_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFINOTED_TYPE_LOG, InfinotedLogPrivate))

static guint log_signals[LAST_SIGNAL];

G_DEFINE_TYPE_WITH_CODE(InfinotedLog, infinoted_log, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfinotedLog))

static void
infinoted_log_handler(const gchar* log_domain,
                      GLogLevelFlags log_level,
                      const gchar* message,
                      gpointer user_data)
{
  InfinotedLog* log;
  log = INFINOTED_LOG(user_data);

  switch(log_level &amp; G_LOG_LEVEL_MASK)
  {
  case G_LOG_LEVEL_ERROR:
  case G_LOG_LEVEL_CRITICAL:
    if(log_domain)
      infinoted_log_error(log, "%s: %s", log_domain, message);
    else
      infinoted_log_error(log, "%s", message);
    break;
  case G_LOG_LEVEL_WARNING:
    if(log_domain)
      infinoted_log_warning(log, "%s: %s", log_domain, message);
    else
      infinoted_log_warning(log, "%s", message);
    break;
  case G_LOG_LEVEL_MESSAGE:
  case G_LOG_LEVEL_INFO:
  case G_LOG_LEVEL_DEBUG:
    if(log_domain)
      infinoted_log_info(log, "%s: %s", log_domain, message);
    else
      infinoted_log_info(log, "%s", message);
    break;
  }

  if(log_level &amp; G_LOG_FLAG_FATAL)
    abort();
}

static void
infinoted_log_write(InfinotedLog* log,
                    guint prio,
                    guint depth,
                    const gchar* text)
{
  InfinotedLogPrivate* priv;
  time_t cur_time;
  struct tm* cur_tm;
  char time_msg[128];
  gchar* final_text;

  priv = INFINOTED_LOG_PRIVATE(log);

  if(depth == 0)
  {
    cur_time = time(NULL);
    cur_tm = localtime(&amp;cur_time);

    switch(prio)
    {
    case LOG_ERR:
      strftime(time_msg, 128, "[%c]   ERROR", cur_tm);
      break;
    case LOG_WARNING:
      strftime(time_msg, 128, "[%c] WARNING", cur_tm);
      break;
    case LOG_INFO:
      strftime(time_msg, 128, "[%c]    INFO", cur_tm);
      break;
    default:
      g_assert_not_reached();
      break;
    }

    final_text = g_strdup_printf("%s: %s", time_msg, text);
  }
  else
  {
    final_text = g_strdup_printf("\t%s", text);
  }

#ifdef LIBINFINITY_HAVE_LIBDAEMON
  daemon_log(prio, "%s", final_text);
#else
#ifdef G_OS_WIN32
  /* On Windows, convert to the character set of the console */
  gchar* codeset;
  gchar* converted;

  codeset = g_strdup_printf("CP%u", (guint)GetConsoleOutputCP());
  converted = g_convert(final_text, -1, codeset, "UTF-8", NULL, NULL, NULL);
  g_free(codeset);

  fprintf(stderr, "%s\n", converted);
  g_free(converted);
#else
  fprintf(stderr, "%s\n", final_text);
#endif /* !G_OS_WIN32 */
#endif /* !LIBINFINITY_HAVE_LIBDAEMON */

  if(priv-&gt;log_file != NULL)
  {
    fprintf(priv-&gt;log_file, "%s\n", final_text);
    fflush(priv-&gt;log_file);
  }

  g_free(final_text);
}

static void
infinoted_log_entry(InfinotedLog* log,
<a name="1"></a>                    guint prio,
                    const gchar* fmt,
                    va_list args)
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
  /* This is an entry point for the three public functions. */
  InfinotedLogPrivate* priv;
  gchar* text;
  guint depth;

  priv = INFINOTED_LOG_PRIVATE(log);
  text = g_strdup_vprintf(fmt, args);

  g_rec_mutex_lock(&amp;priv-&gt;mutex);

  depth = priv-&gt;recursion_depth++;

  g_signal_emit(log, log_signals[LOG_MESSAGE], 0, prio, depth, text);

  g_assert(priv-&gt;recursion_depth == depth + 1);
  --priv-&gt;recursion_depth;

  g_rec_mutex_unlock(&amp;priv-&gt;mutex);

  g_free(text);
}

static void
infinoted_log_init(InfinotedLog* log)
{
  InfinotedLogPrivate* priv;
  priv = INFINOTED_LOG_PRIVATE(log);

  priv-&gt;file_path = NULL;</b></font>
  priv-&gt;log_file = NULL;
  priv-&gt;prev_log_handler = NULL;
  priv-&gt;recursion_depth = 0;

  g_rec_mutex_init(&amp;priv-&gt;mutex);
}

static void
infinoted_log_finalize(GObject* object)
{
  InfinotedLog* log;
  InfinotedLogPrivate* priv;

  log = INFINOTED_LOG(object);
  priv = INFINOTED_LOG_PRIVATE(log);

  if(priv-&gt;log_file != NULL)
    infinoted_log_close(log);

  g_rec_mutex_clear(&amp;priv-&gt;mutex);

  G_OBJECT_CLASS(infinoted_log_parent_class)-&gt;finalize(object);
}

static void
infinoted_log_set_property(GObject* object,
                           guint prop_id,
                           const GValue* value,
                           GParamSpec* pspec)
{
  InfinotedLog* log;
  InfinotedLogPrivate* priv;

  log = INFINOTED_LOG(object);
  priv = INFINOTED_LOG_PRIVATE(log);
<a name="0"></a>
  switch(prop_id)
  {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case PROP_FILE_PATH:
    /* read only */
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infinoted_log_get_property(GObject* object,
                           guint prop_id,
                           GValue* value,
                           GParamSpec* pspec)
{
  InfinotedLog* log;
  InfinotedLogPrivate* priv;

  log = INFINOTED_LOG(object);
  priv = INFINOTED_LOG_PRIVATE(log);

  switch(prop_id)
  {
  case PROP_FILE_PATH:
    g_value_set_string(value, priv-&gt;file_path);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infinoted_log_log_message(InfinotedLog* log,
                          guint prio,
                          guint depth,
                          const gchar* text)
{
  InfinotedLogPrivate* priv;
  priv = INFINOTED_LOG_PRIVATE(log);

  g_assert(priv-&gt;recursion_depth == depth+1);
  infinoted_log_write(log, prio, depth, text);
}

static void
infinoted_log_class_init(InfinotedLogClass* log_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(log_class);

  object_class-&gt;finalize = infinoted_log_finalize;
  object_class-&gt;set_property = infinoted_log_set_property;
  object_class-&gt;get_property = infinoted_log_get_property;

  log_class-&gt;log_message = infinoted_log_log_message;

  g_object_class_install_property(
    object_class,
    PROP_FILE_PATH,
    g_param_spec_string(
      "file-path",
      "File Path",
      "Path to the log file",
      NULL,
      G_PARAM_READABLE
    )
  );

  /**
   * InfinotedLog::log-message:
   * @log: The #InfinotedLog that is logging a message.
   * @prio: The priority of the logged message.
   * @depth: The recursion depth of the logged message.
   * @text: The logged message text.
   *
   * This signal is emitted when a new line of log message is written to the
   * log.
   */
  log_signals[LOG_MESSAGE] = g_signal_new(
    "log-message",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_FIRST,
    G_STRUCT_OFFSET(InfinotedLogClass, log_message),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    3,
    G_TYPE_UINT,
    G_TYPE_UINT,
    G_TYPE_STRING
  );
}

/**
 * infinoted_log_new: (constructor)
 *
 * Creates a new #InfinotedLog.
 *
 * Returns: (transfer full): A new #InfinotedLog. Free with g_object_unref()
 * when no longer needed.
 */
InfinotedLog*
infinoted_log_new(void)
{
  GObject* object = g_object_new(INFINOTED_TYPE_LOG, NULL);
  return INFINOTED_LOG(object);
}

/**
 * infinoted_log_open:
 * @log: A #InfinotedLog.
 * @path: (type filename) (allow-none): The path to the log file to write,
 * or %NULL.
 * @error: Location to store error information, if any, or %NULL.
 *
 * Attempts to open the log file at the given path. If the log file could not
 * be opened the function returns %FALSE and @error is set. If the log file
 * exists already then new log messages will be appended.
 *
 * If @path is %NULL no log file is opened and logging only occurs to stderr.
 *
 * Returns: %TRUE on success, or %FALSE otherwise.
 */
gboolean
infinoted_log_open(InfinotedLog* log,
                   const gchar* path,
                   GError** error)
{
  InfinotedLogPrivate* priv;

  g_return_val_if_fail(INFINOTED_IS_LOG(log), FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);

  priv = INFINOTED_LOG_PRIVATE(log);
  g_rec_mutex_lock(&amp;priv-&gt;mutex);

  g_assert(priv-&gt;prev_log_handler == NULL);

  if(path != NULL)
  {
    g_assert(priv-&gt;log_file == NULL);
    priv-&gt;log_file = fopen(path, "a");
    if(priv-&gt;log_file == NULL)
    {
      infinoted_util_set_errno_error(error, errno, "Failed to open log file");
      return FALSE;
    }

    g_assert(priv-&gt;file_path == NULL);
    priv-&gt;file_path = g_strdup(path);
  }

  priv-&gt;prev_log_handler = g_log_set_default_handler(
    infinoted_log_handler,
    log
  );

  g_rec_mutex_unlock(&amp;priv-&gt;mutex);

  if(path != NULL)
    g_object_notify(G_OBJECT(log), "file-path");

  return TRUE;
}

/**
 * infinoted_log_close:
 * @log: A #InfinotedLog.
 *
 * Closes a #InfinotedLog object opened with infinoted_log_open(). After the
 * log was closed it can be opened again with a different file. The log is
 * closed automatically on destruction.
 */
void
infinoted_log_close(InfinotedLog* log)
{
  InfinotedLogPrivate* priv;
  
  g_return_if_fail(INFINOTED_IS_LOG(log));
  priv = INFINOTED_LOG_PRIVATE(log);

  g_rec_mutex_lock(&amp;priv-&gt;mutex);
  g_assert(priv-&gt;prev_log_handler != NULL);

  if(priv-&gt;log_file != NULL)
  {
    g_assert(priv-&gt;file_path != NULL);

    fclose(priv-&gt;log_file);
    priv-&gt;log_file = NULL;

    g_free(priv-&gt;file_path);
    priv-&gt;file_path = NULL;
  }

  g_assert(priv-&gt;file_path == NULL);

  g_log_set_default_handler(priv-&gt;prev_log_handler, NULL);
  priv-&gt;prev_log_handler = NULL;
  g_rec_mutex_unlock(&amp;priv-&gt;mutex);

  g_object_notify(G_OBJECT(log), "file-path");
}

/**
 * infinoted_log_log:
 * @log: A #InfinotedLog.
 * @prio: Priority of the logged message.
 * @fmt: A printf-style format string.
 * @...: Format arguments.
 *
 * Logs a message with the given priority. The priority is one of %LOG_ERR,
 * %LOG_WARNING or %LOG_INFO.  If the server is daemonized, log to syslog,
 * otherwise log to stderr. If a logfile is given in the options when @log
 * was created, the logfile is written to as well.
 */
void
infinoted_log_log(InfinotedLog* log,
                  guint prio,
                  const char* fmt,
                  ...)
{
  va_list ap;
  va_start(ap, fmt);
  infinoted_log_entry(log, prio, fmt, ap);
  va_end(ap);
}

/**
 * infinoted_log_error:
 * @log: A #InfinotedLog.
 * @fmt: A printf-style format string.
 * @...: Format arguments.
 *
 * Logs an error message. If the server is daemonized, log to syslog,
 * otherwise log to stderr. If a logfile is given in the options when @log
 * was created, the logfile is written to as well.
 */
void
infinoted_log_error(InfinotedLog* log,
                    const char* fmt,
                    ...)
{
  va_list ap;
  va_start(ap, fmt);
  infinoted_log_entry(log, LOG_ERR, fmt, ap);
  va_end(ap);
}

/**
 * infinoted_log_warning:
 * @log: A #InfinotedLog.
 * @fmt: A printf-style format string.
 * @...: Format arguments.
 *
 * Logs a warning message. If the server is daemonized, log to syslog,
 * otherwise log to stderr. If a logfile is given in the options when @log
 * was created, the logfile is written to as well.
 */
void
infinoted_log_warning(InfinotedLog* log,
                      const char* fmt,
                      ...)
{
  va_list ap;
  va_start(ap, fmt);
  infinoted_log_entry(log, LOG_WARNING, fmt, ap);
  va_end(ap);
}

/**
 * infinoted_log_info:
 * @log: A #InfinotedLog.
 * @fmt: A printf-style format string.
 * @...: Format arguments.
 *
 * Logs an info message. If the server is daemonized, log to syslog,
 * otherwise log to stderr. If a logfile is given in the options when @log
 * was created, the logfile is written to as well.
 */
void
infinoted_log_info(InfinotedLog* log,
                   const char* fmt,
                   ...)
{
  va_list ap;
  va_start(ap, fmt);
  infinoted_log_entry(log, LOG_INFO, fmt, ap);
  va_end(ap);
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-session-proxy.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

/**
 * SECTION:infc-session-proxy
 * @title: InfcSessionProxy
 * @short_description: Client-side session management
 * @include: libinfinity/client/infc-session-proxy.h
 * @see_also: #InfSession
 * @stability: Unstable
 *
 * #InfcSessionProxy is a manager for #InfSession that is specific for the
 * client side. The #InfcSessionProxy manages exactly one #InfSession. It is
 * usually created by #InfcBrowser when a subscription to a node is made.
 *
 * #InfcSessionProxy allows to perform client-specific operations for the
 * session it manages, such as joining a user. In addition it handles requests
 * made by its counterpart, #InfdSessionProxy, for the server side, such as
 * remote user joins and forced session closure.
 *
 * #InfcSessionProxy implements the #InfSessionProxy interface, which can be
 * used to access the underlying #InfSession or to join a user.
 */

#include &lt;libinfinity/client/infc-session-proxy.h&gt;
#include &lt;libinfinity/client/infc-request-manager.h&gt;
#include &lt;libinfinity/common/inf-session-proxy.h&gt;
#include &lt;libinfinity/common/inf-session.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-xml-connection.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;string.h&gt;

typedef struct _InfcSessionProxyPrivate InfcSessionProxyPrivate;
struct _InfcSessionProxyPrivate {
  InfSession* session;
  InfCommunicationJoinedGroup* subscription_group;
  InfXmlConnection* connection;
  InfcRequestManager* request_manager;
};

enum {
  PROP_0,

  PROP_SESSION,
  PROP_SUBSCRIPTION_GROUP,
  PROP_SEQUENCE_ID,
  PROP_CONNECTION
};

#define INFC_SESSION_PROXY_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_SESSION_PROXY, InfcSessionProxyPrivate))

static void infc_session_proxy_communication_object_iface_init(InfCommunicationObjectInterface* iface);
static void infc_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfcSessionProxy, infc_session_proxy, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfcSessionProxy)
  G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, infc_session_proxy_communication_object_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TYPE_SESSION_PROXY, infc_session_proxy_session_proxy_iface_init))

static void
infc_session_proxy_release_connection(InfcSessionProxy* proxy);

static void
infc_session_proxy_unsubscribe_connection(InfcSessionProxy* proxy)
{
  InfcSessionProxyPrivate* priv;
  InfSessionSyncStatus sync_status;
  InfXmlConnectionStatus conn_status;
  xmlNodePtr xml;

  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  g_assert(priv-&gt;connection != NULL);
  g_assert(priv-&gt;session != NULL);

  sync_status = inf_session_get_synchronization_status(
    priv-&gt;session,
    priv-&gt;connection
  );

  g_object_get(G_OBJECT(priv-&gt;connection), "status", &amp;conn_status, NULL);

  /* If synchronization is still in progress, the close default signal
   * handler in InfSession the base class will cancel the synchronization in
   * which case we do not need to send an extra session-unsubscribe
   * message. */

  /* However, in case we are in AWAITING_ACK status we send session
   * unsubscribe because we cannot cancel the synchronization anymore but
   * the server will go into RUNNING state before receiving this message. */

  /* Note that, also, the connection might not be open anymore at this point
   * if a handler for the connection's notify::status signal finalized or
   * closed the session explicitely before our handler was called. Therefore
   * we also check the connection status here. */
  if(conn_status == INF_XML_CONNECTION_OPEN &amp;&amp;
     sync_status != INF_SESSION_SYNC_IN_PROGRESS)
  {
    xml = xmlNewNode(NULL, (const xmlChar*)"session-unsubscribe");

    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      priv-&gt;connection,
      xml
    );
  }

  /* If an error occurs while sending the "session-unsubscribe" message, the
   * connection is released already as a result of the connection status
   * notify handler, so we need another check here. */
  if(priv-&gt;connection != NULL)
    infc_session_proxy_release_connection(proxy);
}

/*
 * Signal handlers
 */

static void
infc_session_proxy_connection_notify_status_cb(InfXmlConnection* connection,
                                               GParamSpec* pspec,
                                               gpointer user_data)
{
  InfcSessionProxy* proxy;
  InfXmlConnectionStatus status;

  proxy = INFC_SESSION_PROXY(user_data);
  g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);

  if(status == INF_XML_CONNECTION_CLOSED ||
     status == INF_XML_CONNECTION_CLOSING)
  {
    /* Reset connection in case of closure */
    infc_session_proxy_release_connection(proxy);
  }
}

static void
infc_session_proxy_session_synchronization_complete_cb(InfSession* session,
                                                       InfXmlConnection* conn,
                                                       gpointer user_data)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  InfSessionStatus status;

  proxy = INFC_SESSION_PROXY(user_data);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  g_object_get(G_OBJECT(session), "status", &amp;status, NULL);

  /* There are actually 4 different situations here, depending on status
   * and priv-&gt;connection:
   *
   * 1) status == SYNCHRONIZING and priv-&gt;connection == NULL
   * This means that someone synchronized its session to us, but we are not
   * subscribed to that session.
   *
   * 2) status == SYNCHRONIZING and priv-&gt;connection != NULL
   * This means that someone synchronized us and we are subscribed to that
   * session.
   *
   * 3) status == RUNNING and priv-&gt;connection == NULL
   * This means that we synchronized our session to someone else but are
   * not subscribed to any session.
   *
   * 4) status == RUNNING and priv-&gt;connection != NULL
   * This means that we synchronized our session to someone else and are
   * subscribed to a session (possibly on another host as the one we
   * synchronized to!). */

  if(status == INF_SESSION_SYNCHRONIZING)
  {
    if(priv-&gt;connection != NULL)
    {
      /* The connection that synchronized the session to us should be the
       * one we subscribed to. */
      g_assert(priv-&gt;connection == conn);
    }
  }
}

static void
infc_session_proxy_session_synchronization_failed_cb(InfSession* session,
                                                     InfXmlConnection* conn,
                                                     const GError* error,
                                                     gpointer user_data)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  InfSessionStatus status;

  proxy = INFC_SESSION_PROXY(user_data);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  g_object_get(G_OBJECT(session), "status", &amp;status, NULL);

  switch(status)
  {
  case INF_SESSION_SYNCHRONIZING:
    /* When the synchronization failed in synchronizing state, the session
     * will close itself anyway which is where we do the cleanup in this
     * case. */
    break;
  case INF_SESSION_RUNNING:
    /* We do not need to send an explicit session-unsubscribe, because the
     * failed synchronization should already let the host know that
     * subscription makes no sense anymore. */

    /* If the synchronization failed because the connection was closed, then
     * the connection might not exist anymore at this point since the
     * notify::status handler ran before this handler. */
    if(priv-&gt;connection != NULL)
      infc_session_proxy_release_connection(proxy);
    break;
  case INF_SESSION_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
}

static void
infc_session_proxy_session_close_cb(InfSession* session,
                                    gpointer user_data)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;

  proxy = INFC_SESSION_PROXY(user_data);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  if(priv-&gt;connection != NULL)
    infc_session_proxy_unsubscribe_connection(proxy);

  /* Don't release session so others can still access */
#if 0
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infc_session_proxy_session_close_cb),
    proxy
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
    proxy
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
    proxy
  );

  g_object_unref(G_OBJECT(priv-&gt;session));
  priv-&gt;session = NULL;
#endif
}

/*
 * Helper functions
 */

static void
infc_session_proxy_release_connection_foreach_user_func(InfUser* user,
                                                        gpointer user_data)
{
  g_object_set(G_OBJECT(user), "status", INF_USER_UNAVAILABLE, NULL);
}

static void
infc_session_proxy_release_connection(InfcSessionProxy* proxy)
{
  InfcSessionProxyPrivate* priv;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  g_assert(priv-&gt;connection != NULL);
  g_assert(priv-&gt;subscription_group != NULL);
  g_assert(priv-&gt;request_manager != NULL);

  /* TODO: Emit failed signal with some "cancelled" error? */
  infc_request_manager_clear(priv-&gt;request_manager);

  g_object_unref(priv-&gt;request_manager);
  priv-&gt;request_manager = NULL;

  /* Set status of all users to unavailable */
  /* TODO: Keep local users available if session is still open. Then make
   * sure when the session is closed everybody is set to unavailable. */
  inf_user_table_foreach_user(
    inf_session_get_user_table(priv-&gt;session),
    infc_session_proxy_release_connection_foreach_user_func,
    NULL
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;connection),
    G_CALLBACK(infc_session_proxy_connection_notify_status_cb),
    proxy
  );

  g_object_unref(priv-&gt;subscription_group);
  priv-&gt;subscription_group = NULL;

  g_object_unref(G_OBJECT(priv-&gt;connection));
  priv-&gt;connection = NULL;

  /* Keep the proxy alive while re-setting the session's subscription group,
   * to be able to announce our status changes afterwards. */
  g_object_ref(proxy);

  inf_session_set_subscription_group(priv-&gt;session, NULL);

  g_object_notify(G_OBJECT(proxy), "connection");
  g_object_notify(G_OBJECT(proxy), "subscription-group");

  g_object_unref(proxy);
}

/* TODO: This function should be moved to InfcRequest */
static xmlNodePtr
infc_session_proxy_request_to_xml(InfcRequest* request)
{
  xmlNodePtr xml;
  gchar* type;
  guint seq;
  gchar seq_buffer[16];

  g_object_get(G_OBJECT(request), "type", &amp;type, "seq", &amp;seq, NULL);
  sprintf(seq_buffer, "%u", seq);

  xml = xmlNewNode(NULL, (const xmlChar*)type);
  xmlNewProp(xml, (const xmlChar*)"seq", (const xmlChar*)seq_buffer);

  g_free(type);
  return xml;
}

/*
 * GObject overrides.
 */

static void
infc_session_proxy_init(InfcSessionProxy* proxy)
{
  InfcSessionProxyPrivate* priv;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  priv-&gt;session = NULL;
  priv-&gt;subscription_group = NULL;
  priv-&gt;connection = NULL;
  priv-&gt;request_manager = NULL;
}

static void
infc_session_proxy_dispose(GObject* object)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;

  proxy = INFC_SESSION_PROXY(object);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  if(priv-&gt;connection)
    infc_session_proxy_unsubscribe_connection(proxy);

  /* Release session */
  if(priv-&gt;session != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;session),
      G_CALLBACK(infc_session_proxy_session_close_cb),
      proxy
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;session),
      G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
      proxy
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;session),
      G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
      proxy
    );

    g_object_unref(G_OBJECT(priv-&gt;session));
    priv-&gt;session = NULL;
  }

  g_assert(priv-&gt;request_manager == NULL);
  G_OBJECT_CLASS(infc_session_proxy_parent_class)-&gt;dispose(object);
}

static void
infc_session_proxy_set_property(GObject* object,
                                guint prop_id,
                                const GValue* value,
                                GParamSpec* pspec)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;

  proxy = INFC_SESSION_PROXY(object);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  switch(prop_id)
  {
  case PROP_SESSION:
    g_assert(priv-&gt;session == NULL); /* construct only */
    priv-&gt;session = INF_SESSION(g_value_dup_object(value));

    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      "close",
      G_CALLBACK(infc_session_proxy_session_close_cb),
      proxy
    );

    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      "synchronization-complete",
      G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
      proxy
    );

    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      "synchronization-failed",
      G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
      proxy
    );
<a name="0"></a>
    break;
  case PROP_SUBSCRIPTION_GROUP:
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case PROP_CONNECTION:
    /* these are read-only because they can only be changed both at once,
     * refer to infc_session_proxy_set_connection(). */
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
infc_session_proxy_get_property(GObject* object,
                                guint prop_id,
                                GValue* value,
                                GParamSpec* pspec)
{
  InfcSessionProxy* session;
  InfcSessionProxyPrivate* priv;

  session = INFC_SESSION_PROXY(object);
  priv = INFC_SESSION_PROXY_PRIVATE(session);

  switch(prop_id)
  {
  case PROP_SESSION:
    g_value_set_object(value, G_OBJECT(priv-&gt;session));
    break;</b></font>
  case PROP_SUBSCRIPTION_GROUP:
    g_value_set_boxed(value, priv-&gt;subscription_group);
    break;
  case PROP_CONNECTION:
    g_value_set_object(value, G_OBJECT(priv-&gt;connection));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static GError*
infc_session_proxy_translate_error_impl(InfcSessionProxy* proxy,
                                        GQuark domain,
                                        guint code)
{
  GError* error;
  const gchar* error_msg;

  if(domain == inf_request_error_quark())
    error_msg = inf_request_strerror(code);
  else if(domain == inf_user_error_quark())
    error_msg = inf_user_strerror(code);
  else
    error_msg = NULL;

  error = NULL;
  if(error_msg != NULL)
  {
    g_set_error_literal(&amp;error, domain, code, error_msg);
  }
  else
  {
    /* TODO: Check whether a human-readable error string was sent (that
     * we cannot translate then, of course). */
    g_set_error(
      &amp;error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_UNKNOWN_DOMAIN,
      _("Error comes from unknown error domain \"%s\" (code %u)"),
      g_quark_to_string(domain),
      (guint)code
    );
  }

  return error;
}

/*
 * Message handling.
 */

static gboolean
infc_session_proxy_handle_user_join(InfcSessionProxy* proxy,
                                    InfXmlConnection* connection,
                                    xmlNodePtr xml,
                                    GError** error)
{
  InfcSessionProxyPrivate* priv;
  InfSessionClass* session_class;
  InfcRequest* request;
  GArray* array;
  InfUser* user;
  GParameter* param;
  gboolean result;
  guint i;

  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);

  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "user-join",
    xml,
    NULL
  );

  array = session_class-&gt;get_xml_user_props(priv-&gt;session, connection, xml);

  /* Set local flag if the join was requested by us. */
  param = inf_session_get_user_property(array, "flags");
  g_assert(!G_IS_VALUE(&amp;param-&gt;value)); /* must not have been set already */

  g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
  if(request != NULL)
    g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
  else
    g_value_set_flags(&amp;param-&gt;value, 0);

  /* Set connection. If none was given, use publisher connection */
  param = inf_session_get_user_property(array, "connection");
  if(!G_IS_VALUE(&amp;param-&gt;value))
  {
    g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
    g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));
  }

  result = session_class-&gt;validate_user_props(
    priv-&gt;session,
    (const GParameter*)array-&gt;data,
    array-&gt;len,
    NULL,
    error
  );

  if(result == TRUE)
  {
    user = inf_session_add_user(
      priv-&gt;session,
      (const GParameter*)array-&gt;data,
      array-&gt;len
    );

    g_assert(user != NULL);
  }

  for(i = 0; i &lt; array-&gt;len; ++ i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);

  if(user != NULL)
  {
    if(request != NULL)
    {
      infc_request_manager_finish_request(
        priv-&gt;request_manager,
        request,
        inf_request_result_make_join_user(INF_SESSION_PROXY(proxy), user)
      );
    }

    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

static gboolean
infc_session_proxy_handle_user_rejoin(InfcSessionProxy* proxy,
                                      InfXmlConnection* connection,
                                      xmlNodePtr xml,
                                      GError** error)
{
  InfcSessionProxyPrivate* priv;
  InfSessionClass* session_class;
  InfcRequest* request;
  GArray* array;
  InfUser* user;
  const GParameter* idparam;
  GParameter* param;
  guint id;
  gboolean result;
  guint i;

  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);

  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "user-join",
    xml,
    NULL
  );

  array = session_class-&gt;get_xml_user_props(priv-&gt;session, connection, xml);

  /* Find rejoining user first */
  idparam = inf_session_lookup_user_property(
    (const GParameter*)array-&gt;data,
    array-&gt;len,
    "id"
  );

  if(idparam == NULL)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _("Request does not contain required attribute \"id\"")
    );

    goto error;
  }

  id = g_value_get_uint(&amp;idparam-&gt;value);
  user = inf_user_table_lookup_user_by_id(
    inf_session_get_user_table(priv-&gt;session),
    id
  );

  if(user == NULL)
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NO_SUCH_USER,
      _("No such user with ID %u"),
      id
    );

    goto error;
  }

  /* Set local flag if the join was requested by us */
  param = inf_session_get_user_property(array, "flags");
  g_assert(!G_IS_VALUE(&amp;param-&gt;value)); /* must not have been set already */

  g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
  if(request != NULL)
    g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
  else
    g_value_set_flags(&amp;param-&gt;value, 0);

  /* Set connection. If none was given, use publisher connection */
  param = inf_session_get_user_property(array, "connection");
  if(!G_IS_VALUE(&amp;param-&gt;value))
  {
    g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
    g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));
  }

  result = session_class-&gt;validate_user_props(
    priv-&gt;session,
    (const GParameter*)array-&gt;data,
    array-&gt;len,
    user,
    error
  );

  if(result == FALSE)
    goto error;

  /* Set properties on the found user object, performing the rejoin */
  g_object_freeze_notify(G_OBJECT(user));

  for(i = 0; i &lt; array-&gt;len; ++ i)
  {
    param = &amp;g_array_index(array, GParameter, i);

    /* Don't set ID because the ID is the same anyway (we did the user lookup
     * by it). The "id" property is construct only anyway. */
    if(strcmp(param-&gt;name, "id") != 0)
      g_object_set_property(G_OBJECT(user), param-&gt;name, &amp;param-&gt;value);
  }

  /* TODO: Set user status to available, if the server did not send the
   * status property? Require the status property being set on a rejoin?
   * Make sure it is not unavailable? */

  g_object_thaw_notify(G_OBJECT(user));
  for(i = 0; i &lt; array-&gt;len; ++ i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);

  if(request != NULL)
  {
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_join_user(INF_SESSION_PROXY(proxy), user)
    );
  }

  return TRUE;

error:
  for(i = 0; i &lt; array-&gt;len; ++ i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);
  return FALSE;
}

static gboolean
infc_session_proxy_handle_request_failed(InfcSessionProxy* proxy,
                                         InfXmlConnection* connection,
                                         xmlNodePtr xml,
                                         GError** error)
{
  InfcSessionProxyPrivate* priv;
  InfcSessionProxyClass* proxy_class;

  xmlChar* domain;
  gboolean has_code;
  guint code;
  GError* req_error;
  InfcRequest* request;

  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  proxy_class = INFC_SESSION_PROXY_GET_CLASS(proxy);

  has_code = inf_xml_util_get_attribute_uint_required(
    xml,
    "code",
    &amp;code,
    error
  );

  if(has_code == FALSE) return FALSE;

  domain = inf_xml_util_get_attribute_required(xml, "domain", error);
  if(domain == NULL) return FALSE;

  req_error = NULL;
  request = infc_request_manager_get_request_by_xml_required(
    priv-&gt;request_manager,
    NULL,
    xml,
    error
  );

  if(request == NULL) return FALSE;

  g_assert(proxy_class-&gt;translate_error != NULL);

  /* TODO: Add a GError* paramater to translate_error so that an error
   * can be reported if the error could not be translated. */
  req_error = proxy_class-&gt;translate_error(
    proxy,
    g_quark_from_string((const gchar*)domain),
    code
  );

  infc_request_manager_fail_request(
    priv-&gt;request_manager,
    request,
    req_error
  );

  g_error_free(req_error);

  xmlFree(domain);
  return TRUE;
}

static gboolean
infc_session_proxy_handle_session_close(InfcSessionProxy* proxy,
                                        InfXmlConnection* connection,
                                        xmlNodePtr xml,
                                        GError** error)
{
  InfcSessionProxyPrivate* priv;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  g_assert(priv-&gt;connection != NULL);
  infc_session_proxy_release_connection(proxy);

  /* Do not call inf_session_close so the session can be reused by
   * reconnecting/synchronizing to another host. */

  return TRUE;
}

/*
 * InfNetObject implementation
 */

static void
infc_session_proxy_communication_object_sent(InfCommunicationObject* object,
                                             InfXmlConnection* connection,
                                             xmlNodePtr node)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;

  proxy = INFC_SESSION_PROXY(object);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  /* TODO: Don't forward for messages the proxy issued */

  g_assert(priv-&gt;session != NULL);

  inf_communication_object_sent(
    INF_COMMUNICATION_OBJECT(priv-&gt;session),
    connection,
    node
  );
}

static void
infc_session_proxy_communication_object_enqueued(InfCommunicationObject* obj,
                                                 InfXmlConnection* connection,
                                                 xmlNodePtr node)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;

  proxy = INFC_SESSION_PROXY(obj);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);

  /* TODO: Don't forward for messages the proxy issued */

  g_assert(priv-&gt;session != NULL);

  inf_communication_object_enqueued(
    INF_COMMUNICATION_OBJECT(priv-&gt;session),
    connection,
    node
  );
}

static InfCommunicationScope
infc_session_proxy_communication_object_received(InfCommunicationObject* obj,
                                                 InfXmlConnection* connection,
                                                 xmlNodePtr node)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  InfcSessionProxyClass* proxy_class;
  InfSessionSyncStatus status;
  GError* local_error;

  InfcRequest* request;
  GError* seq_error;

  proxy = INFC_SESSION_PROXY(obj);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  proxy_class = INFC_SESSION_PROXY_GET_CLASS(proxy);
  status = inf_session_get_synchronization_status(priv-&gt;session, connection);
  local_error = NULL;

  g_assert(status != INF_SESSION_SYNC_NONE || priv-&gt;connection == connection);
  g_assert(inf_session_get_status(priv-&gt;session) != INF_SESSION_CLOSED);

  if(status != INF_SESSION_SYNC_NONE)
  {
    /* Direct delegate during synchronization */
    return inf_communication_object_received(
      INF_COMMUNICATION_OBJECT(priv-&gt;session),
      connection,
      node
    );
  }
  else
  {
    if(strcmp((const char*)node-&gt;name, "user-join") == 0)
    {
      infc_session_proxy_handle_user_join(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else if(strcmp((const char*)node-&gt;name, "user-rejoin") == 0)
    {
      infc_session_proxy_handle_user_rejoin(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else if(strcmp((const char*)node-&gt;name, "request-failed") == 0)
    {
      infc_session_proxy_handle_request_failed(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else if(strcmp((const char*)node-&gt;name, "session-close") == 0)
    {
      infc_session_proxy_handle_session_close(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else
    {
      /* forward to session */
      return inf_communication_object_received(
        INF_COMMUNICATION_OBJECT(priv-&gt;session),
        connection,
        node
      );
    }
  }

  if(local_error != NULL)
  {
    /* If the request had a (valid) seq set, we cancel the corresponding
     * request because the reply could not be processed. */
    request = infc_request_manager_get_request_by_xml(
      priv-&gt;request_manager,
      NULL,
      node,
      NULL
    );

    if(request != NULL)
    {
      /* If the request had a seq set, we cancel the corresponding request
       * because the reply could not be processed. */
      seq_error = NULL;
      g_set_error(
        &amp;seq_error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_REPLY_UNPROCESSED,
        _("Server reply could not be processed: %s"),
        local_error-&gt;message
      );

      infc_request_manager_fail_request(
        priv-&gt;request_manager,
        request,
        seq_error
      );

      g_error_free(seq_error);
    }

    /* TODO: Do we want to emit session's error signal? */
    g_error_free(local_error);
  }

  /* Don't forward any of the handled messages */
  return INF_COMMUNICATION_SCOPE_PTP;
}

/*
 * InfSessionProxy implementation
 */

InfRequest*
infc_session_proxy_session_proxy_join_user(InfSessionProxy* proxy,
                                           guint n_params,
                                           const GParameter* params,
                                           InfRequestFunc func,
                                           gpointer user_data)
{
  InfcSessionProxyPrivate* priv;
  InfSessionClass* session_class;
  InfSessionStatus status;
  InfcRequest* request;
  xmlNodePtr xml;

  g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
  g_return_val_if_fail(n_params == 0 || params != NULL, NULL);

  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_return_val_if_fail(priv-&gt;session != NULL, NULL);

  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);

  /* Make sure we are subscribed */
  g_object_get(G_OBJECT(priv-&gt;session), "status", &amp;status, NULL);
  g_return_val_if_fail(status == INF_SESSION_RUNNING, NULL);
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;request_manager != NULL, NULL);

  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "user-join",
    G_CALLBACK(func),
    user_data,
    NULL
  );

  xml = infc_session_proxy_request_to_xml(INFC_REQUEST(request));

  g_assert(session_class-&gt;set_xml_user_props != NULL);
  session_class-&gt;set_xml_user_props(priv-&gt;session, params, n_params, xml);

  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
    priv-&gt;connection,
    xml
  );

  return INF_REQUEST(request);
}

/*
 * GType registration.
 */
<a name="1"></a>
static void
infc_session_proxy_class_init(InfcSessionProxyClass* proxy_class)
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(proxy_class);

  object_class-&gt;dispose = infc_session_proxy_dispose;
  object_class-&gt;set_property = infc_session_proxy_set_property;
  object_class-&gt;get_property = infc_session_proxy_get_property;

  proxy_class-&gt;translate_error = infc_session_proxy_translate_error_impl;

  g_object_class_install_property(
    object_class,
    PROP_SUBSCRIPTION_GROUP,
    g_param_spec_object(
      "subscription-group",
      "Subscription group",
      "The communication group of subscribed connections",
      INF_COMMUNICATION_TYPE_JOINED_GROUP,
      G_PARAM_READABLE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_CONNECTION,
    g_param_spec_object(
      "connection",
      "Subscription connection",
      "The connection with which the session communicates with the server",
      INF_TYPE_XML_CONNECTION,
      G_PARAM_READABLE
    )
  );

  g_object_class_override_property(object_class, PROP_SESSION, "session");
}

static void
infc_session_proxy_communication_object_iface_init(
  InfCommunicationObjectInterface* iface)
{
  iface-&gt;sent = infc_session_proxy_communication_object_sent;
  iface-&gt;enqueued = infc_session_proxy_communication_object_enqueued;</b></font>
  iface-&gt;received = infc_session_proxy_communication_object_received;
}

static void
infc_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface)
{
  iface-&gt;join_user = infc_session_proxy_session_proxy_join_user;
}

/*
 * Public API.
 */

/**
 * infc_session_proxy_set_connection:
 * @proxy: A #InfcSessionProxy.
 * @group: A #InfCommunicationJoinedGroup of subscribed connections. Ignored
 * if @connection is %NULL.
 * @connection: A #InfXmlConnection.
 * @seq_id: A sequence identifier for @connection. Ignored if @connection
 * is %NULL.
 *
 * Sets the subscription connection for the given session. The subscription
 * connection is the connection through which session requests are transmitted
 * during subscription.
 *
 * The subscription connection might be set even if the session is in
 * SYNCHRONIZING state in which case the session is immediately subscribed
 * after synchronization. Note that no attempt is made to tell the other end
 * about the subscription.
 *
 * @seq_id should be a sequence identifier obtained from the server side. It
 * must be the same number that is used on the corresponding #InfdSessionProxy
 * on the remote side, see infd_session_proxy_subscribe_to(). Normally
 * #InfdDirectory or #InfcBrowser, respectively, take care of passing the
 * correct sequence identifier.
 *
 * When the subscription connection is being closed or replaced (by a
 * subsequent call to this function), all pending requests are dropped and
 * all users are set to be unavailable, but the session will not be closed,
 * so it may be reused by setting another subscription connection. However,
 * the session might not be synchronized again, but it is fully okay to close
 * the session by hand (using inf_session_close) and create a new session
 * that is synchronized.
 **/
void
infc_session_proxy_set_connection(InfcSessionProxy* proxy,
                                  InfCommunicationJoinedGroup* group,
                                  InfXmlConnection* connection,
                                  guint seq_id)
{
  InfcSessionProxyPrivate* priv;
  xmlNodePtr xml;

  g_return_if_fail(INFC_IS_SESSION_PROXY(proxy));
  g_return_if_fail(connection == NULL || INF_IS_XML_CONNECTION(connection));
  g_return_if_fail(
    (group == NULL &amp;&amp; connection == NULL) ||
    (INF_COMMUNICATION_IS_JOINED_GROUP(group) &amp;&amp; connection != NULL)
  );

  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_return_if_fail(priv-&gt;session != NULL);

  g_object_freeze_notify(G_OBJECT(proxy));
  g_object_freeze_notify(G_OBJECT(priv-&gt;session));

  if(priv-&gt;connection != NULL)
  {
    /* Unsubscribe from running session. Always send the unsubscribe request
     * because synchronizations are not cancelled through this call. */
    xml = xmlNewNode(NULL, (const xmlChar*)"session-unsubscribe");

    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      priv-&gt;connection,
      xml
    );

    /* Note that this would cause a notify on the connection property, but
     * notifications have been freezed until the end of this function call.
     * Same with the subscription-group property of priv-&gt;session. */
    infc_session_proxy_release_connection(proxy);
  }

  priv-&gt;connection = connection;

  if(connection != NULL)
  {
    priv-&gt;connection = connection;
    g_object_ref(G_OBJECT(connection));

    g_signal_connect(
      G_OBJECT(connection),
      "notify::status",
      G_CALLBACK(infc_session_proxy_connection_notify_status_cb),
      proxy
    );

    /* Set new group */
    priv-&gt;subscription_group = group;
    g_object_ref(priv-&gt;subscription_group);

    g_assert(priv-&gt;request_manager == NULL);
    priv-&gt;request_manager = infc_request_manager_new(seq_id);
  }

  inf_session_set_subscription_group(
    priv-&gt;session,
    INF_COMMUNICATION_GROUP(priv-&gt;subscription_group)
  );

  g_object_notify(G_OBJECT(proxy), "connection");
  g_object_notify(G_OBJECT(proxy), "subscription-group");
  g_object_thaw_notify(G_OBJECT(priv-&gt;session));
  g_object_thaw_notify(G_OBJECT(proxy));
}

/**
 * infc_session_proxy_get_connection:
 * @proxy: A #InfcSessionProxy.
 *
 * Returns the connection that is used to transmit requests to the publisher
 * of the session, or %NULL if the session is not subscribed.
 *
 * Returns: (transfer none): A #InfXmlConnection, or %NULL.
 **/
InfXmlConnection*
infc_session_proxy_get_connection(InfcSessionProxy* proxy)
{
  g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
  return INFC_SESSION_PROXY_PRIVATE(proxy)-&gt;connection;
}

/**
 * infc_session_proxy_get_subscription_group:
 * @proxy: A #InfcSessionProxy.
 *
 * Returns the group with all subscribed connections to the session, or %NULL
 * if the session is not subscribed.
 *
 * Returns: (transfer none): A #InfCommunicationJoinedGroup, or %NULL.
 **/
InfCommunicationJoinedGroup*
infc_session_proxy_get_subscription_group(InfcSessionProxy* proxy)
{
  g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
  return INFC_SESSION_PROXY_PRIVATE(proxy)-&gt;subscription_group;
}

/* vim:set et sw=2 ts=2: */
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
