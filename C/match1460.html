<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infinoted-log.c &amp; infc-session-proxy.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infinoted-log.c &amp; infc-session-proxy.c
      </h3>
<h1 align="center">
        7.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infinoted-log.c (11.555555%)<th>infc-session-proxy.c (5.54371%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(269-293)<td><a href="#" name="0">(458-483)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(201-230)<td><a href="#" name="1">(1070-1112)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infinoted-log.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;infinoted/infinoted-log.h&gt;
2 #include &lt;infinoted/infinoted-util.h&gt;
3 #include &lt;libinfinity/inf-i18n.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;stdio.h&gt;
6 #include &lt;time.h&gt;
7 #include &lt;errno.h&gt;
8 #ifdef LIBINFINITY_HAVE_LIBDAEMON
9 # include &lt;libdaemon/dlog.h&gt;
10 #endif
11 #ifdef G_OS_WIN32
12 # define LOG_ERR 0
13 # define LOG_WARNING 1
14 # define LOG_INFO 2
15 # include &lt;windows.h&gt;
16 #else
17 # include &lt;syslog.h&gt;
18 #endif
19 typedef struct _InfinotedLogPrivate InfinotedLogPrivate;
20 struct _InfinotedLogPrivate {
21   gchar* file_path;
22   FILE* log_file;
23   GLogFunc prev_log_handler;
24   GRecMutex mutex;
25   guint recursion_depth;
26 };
27 enum {
28   PROP_0,
29   PROP_FILE_PATH
30 };
31 enum {
32   LOG_MESSAGE,
33   LAST_SIGNAL
34 };
35 #define INFINOTED_LOG_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFINOTED_TYPE_LOG, InfinotedLogPrivate))
36 static guint log_signals[LAST_SIGNAL];
37 G_DEFINE_TYPE_WITH_CODE(InfinotedLog, infinoted_log, G_TYPE_OBJECT,
38   G_ADD_PRIVATE(InfinotedLog))
39 static void
40 infinoted_log_handler(const gchar* log_domain,
41                       GLogLevelFlags log_level,
42                       const gchar* message,
43                       gpointer user_data)
44 {
45   InfinotedLog* log;
46   log = INFINOTED_LOG(user_data);
47   switch(log_level &amp; G_LOG_LEVEL_MASK)
48   {
49   case G_LOG_LEVEL_ERROR:
50   case G_LOG_LEVEL_CRITICAL:
51     if(log_domain)
52       infinoted_log_error(log, "%s: %s", log_domain, message);
53     else
54       infinoted_log_error(log, "%s", message);
55     break;
56   case G_LOG_LEVEL_WARNING:
57     if(log_domain)
58       infinoted_log_warning(log, "%s: %s", log_domain, message);
59     else
60       infinoted_log_warning(log, "%s", message);
61     break;
62   case G_LOG_LEVEL_MESSAGE:
63   case G_LOG_LEVEL_INFO:
64   case G_LOG_LEVEL_DEBUG:
65     if(log_domain)
66       infinoted_log_info(log, "%s: %s", log_domain, message);
67     else
68       infinoted_log_info(log, "%s", message);
69     break;
70   }
71   if(log_level &amp; G_LOG_FLAG_FATAL)
72     abort();
73 }
74 static void
75 infinoted_log_write(InfinotedLog* log,
76                     guint prio,
77                     guint depth,
78                     const gchar* text)
79 {
80   InfinotedLogPrivate* priv;
81   time_t cur_time;
82   struct tm* cur_tm;
83   char time_msg[128];
84   gchar* final_text;
85   priv = INFINOTED_LOG_PRIVATE(log);
86   if(depth == 0)
87   {
88     cur_time = time(NULL);
89     cur_tm = localtime(&amp;cur_time);
90     switch(prio)
91     {
92     case LOG_ERR:
93       strftime(time_msg, 128, "[%c]   ERROR", cur_tm);
94       break;
95     case LOG_WARNING:
96       strftime(time_msg, 128, "[%c] WARNING", cur_tm);
97       break;
98     case LOG_INFO:
99       strftime(time_msg, 128, "[%c]    INFO", cur_tm);
100       break;
101     default:
102       g_assert_not_reached();
103       break;
104     }
105     final_text = g_strdup_printf("%s: %s", time_msg, text);
106   }
107   else
108   {
109     final_text = g_strdup_printf("\t%s", text);
110   }
111 #ifdef LIBINFINITY_HAVE_LIBDAEMON
112   daemon_log(prio, "%s", final_text);
113 #else
114 #ifdef G_OS_WIN32
115   gchar* codeset;
116   gchar* converted;
117   codeset = g_strdup_printf("CP%u", (guint)GetConsoleOutputCP());
118   converted = g_convert(final_text, -1, codeset, "UTF-8", NULL, NULL, NULL);
119   g_free(codeset);
120   fprintf(stderr, "%s\n", converted);
121   g_free(converted);
122 #else
123   fprintf(stderr, "%s\n", final_text);
124 #endif #endif 
125   if(priv-&gt;log_file != NULL)
126   {
127     fprintf(priv-&gt;log_file, "%s\n", final_text);
128     fflush(priv-&gt;log_file);
129   }
130   g_free(final_text);
131 }
132 static void
133 infinoted_log_entry(InfinotedLog* log,
134 <a name="1"></a>                    guint prio,
135                     const gchar* fmt,
136                     va_list args)
137 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
138   InfinotedLogPrivate* priv;
139   gchar* text;
140   guint depth;
141   priv = INFINOTED_LOG_PRIVATE(log);
142   text = g_strdup_vprintf(fmt, args);
143   g_rec_mutex_lock(&amp;priv-&gt;mutex);
144   depth = priv-&gt;recursion_depth++;
145   g_signal_emit(log, log_signals[LOG_MESSAGE], 0, prio, depth, text);
146   g_assert(priv-&gt;recursion_depth == depth + 1);
147   --priv-&gt;recursion_depth;
148   g_rec_mutex_unlock(&amp;priv-&gt;mutex);
149   g_free(text);
150 }
151 static void
152 infinoted_log_init(InfinotedLog* log)
153 {
154   InfinotedLogPrivate* priv;
155   priv = INFINOTED_LOG_PRIVATE(log);
156   priv-&gt;file_path = NULL;</b></font>
157   priv-&gt;log_file = NULL;
158   priv-&gt;prev_log_handler = NULL;
159   priv-&gt;recursion_depth = 0;
160   g_rec_mutex_init(&amp;priv-&gt;mutex);
161 }
162 static void
163 infinoted_log_finalize(GObject* object)
164 {
165   InfinotedLog* log;
166   InfinotedLogPrivate* priv;
167   log = INFINOTED_LOG(object);
168   priv = INFINOTED_LOG_PRIVATE(log);
169   if(priv-&gt;log_file != NULL)
170     infinoted_log_close(log);
171   g_rec_mutex_clear(&amp;priv-&gt;mutex);
172   G_OBJECT_CLASS(infinoted_log_parent_class)-&gt;finalize(object);
173 }
174 static void
175 infinoted_log_set_property(GObject* object,
176                            guint prop_id,
177                            const GValue* value,
178                            GParamSpec* pspec)
179 {
180   InfinotedLog* log;
181   InfinotedLogPrivate* priv;
182   log = INFINOTED_LOG(object);
183   priv = INFINOTED_LOG_PRIVATE(log);
184 <a name="0"></a>
185   switch(prop_id)
186   {
187 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case PROP_FILE_PATH:
188   default:
189     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
190     break;
191   }
192 }
193 static void
194 infinoted_log_get_property(GObject* object,
195                            guint prop_id,
196                            GValue* value,
197                            GParamSpec* pspec)
198 {
199   InfinotedLog* log;
200   InfinotedLogPrivate* priv;
201   log = INFINOTED_LOG(object);
202   priv = INFINOTED_LOG_PRIVATE(log);
203   switch(prop_id)
204   {
205   case PROP_FILE_PATH:
206     g_value_set_string(value, priv-&gt;file_path);
207     break;</b></font>
208   default:
209     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
210     break;
211   }
212 }
213 static void
214 infinoted_log_log_message(InfinotedLog* log,
215                           guint prio,
216                           guint depth,
217                           const gchar* text)
218 {
219   InfinotedLogPrivate* priv;
220   priv = INFINOTED_LOG_PRIVATE(log);
221   g_assert(priv-&gt;recursion_depth == depth+1);
222   infinoted_log_write(log, prio, depth, text);
223 }
224 static void
225 infinoted_log_class_init(InfinotedLogClass* log_class)
226 {
227   GObjectClass* object_class;
228   object_class = G_OBJECT_CLASS(log_class);
229   object_class-&gt;finalize = infinoted_log_finalize;
230   object_class-&gt;set_property = infinoted_log_set_property;
231   object_class-&gt;get_property = infinoted_log_get_property;
232   log_class-&gt;log_message = infinoted_log_log_message;
233   g_object_class_install_property(
234     object_class,
235     PROP_FILE_PATH,
236     g_param_spec_string(
237       "file-path",
238       "File Path",
239       "Path to the log file",
240       NULL,
241       G_PARAM_READABLE
242     )
243   );
244   log_signals[LOG_MESSAGE] = g_signal_new(
245     "log-message",
246     G_OBJECT_CLASS_TYPE(object_class),
247     G_SIGNAL_RUN_FIRST,
248     G_STRUCT_OFFSET(InfinotedLogClass, log_message),
249     NULL, NULL,
250     NULL,
251     G_TYPE_NONE,
252     3,
253     G_TYPE_UINT,
254     G_TYPE_UINT,
255     G_TYPE_STRING
256   );
257 }
258 InfinotedLog*
259 infinoted_log_new(void)
260 {
261   GObject* object = g_object_new(INFINOTED_TYPE_LOG, NULL);
262   return INFINOTED_LOG(object);
263 }
264 gboolean
265 infinoted_log_open(InfinotedLog* log,
266                    const gchar* path,
267                    GError** error)
268 {
269   InfinotedLogPrivate* priv;
270   g_return_val_if_fail(INFINOTED_IS_LOG(log), FALSE);
271   g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
272   priv = INFINOTED_LOG_PRIVATE(log);
273   g_rec_mutex_lock(&amp;priv-&gt;mutex);
274   g_assert(priv-&gt;prev_log_handler == NULL);
275   if(path != NULL)
276   {
277     g_assert(priv-&gt;log_file == NULL);
278     priv-&gt;log_file = fopen(path, "a");
279     if(priv-&gt;log_file == NULL)
280     {
281       infinoted_util_set_errno_error(error, errno, "Failed to open log file");
282       return FALSE;
283     }
284     g_assert(priv-&gt;file_path == NULL);
285     priv-&gt;file_path = g_strdup(path);
286   }
287   priv-&gt;prev_log_handler = g_log_set_default_handler(
288     infinoted_log_handler,
289     log
290   );
291   g_rec_mutex_unlock(&amp;priv-&gt;mutex);
292   if(path != NULL)
293     g_object_notify(G_OBJECT(log), "file-path");
294   return TRUE;
295 }
296 void
297 infinoted_log_close(InfinotedLog* log)
298 {
299   InfinotedLogPrivate* priv;
300   g_return_if_fail(INFINOTED_IS_LOG(log));
301   priv = INFINOTED_LOG_PRIVATE(log);
302   g_rec_mutex_lock(&amp;priv-&gt;mutex);
303   g_assert(priv-&gt;prev_log_handler != NULL);
304   if(priv-&gt;log_file != NULL)
305   {
306     g_assert(priv-&gt;file_path != NULL);
307     fclose(priv-&gt;log_file);
308     priv-&gt;log_file = NULL;
309     g_free(priv-&gt;file_path);
310     priv-&gt;file_path = NULL;
311   }
312   g_assert(priv-&gt;file_path == NULL);
313   g_log_set_default_handler(priv-&gt;prev_log_handler, NULL);
314   priv-&gt;prev_log_handler = NULL;
315   g_rec_mutex_unlock(&amp;priv-&gt;mutex);
316   g_object_notify(G_OBJECT(log), "file-path");
317 }
318 void
319 infinoted_log_log(InfinotedLog* log,
320                   guint prio,
321                   const char* fmt,
322                   ...)
323 {
324   va_list ap;
325   va_start(ap, fmt);
326   infinoted_log_entry(log, prio, fmt, ap);
327   va_end(ap);
328 }
329 void
330 infinoted_log_error(InfinotedLog* log,
331                     const char* fmt,
332                     ...)
333 {
334   va_list ap;
335   va_start(ap, fmt);
336   infinoted_log_entry(log, LOG_ERR, fmt, ap);
337   va_end(ap);
338 }
339 void
340 infinoted_log_warning(InfinotedLog* log,
341                       const char* fmt,
342                       ...)
343 {
344   va_list ap;
345   va_start(ap, fmt);
346   infinoted_log_entry(log, LOG_WARNING, fmt, ap);
347   va_end(ap);
348 }
349 void
350 infinoted_log_info(InfinotedLog* log,
351                    const char* fmt,
352                    ...)
353 {
354   va_list ap;
355   va_start(ap, fmt);
356   infinoted_log_entry(log, LOG_INFO, fmt, ap);
357   va_end(ap);
358 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-session-proxy.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/client/infc-session-proxy.h&gt;
2 #include &lt;libinfinity/client/infc-request-manager.h&gt;
3 #include &lt;libinfinity/common/inf-session-proxy.h&gt;
4 #include &lt;libinfinity/common/inf-session.h&gt;
5 #include &lt;libinfinity/common/inf-request-result.h&gt;
6 #include &lt;libinfinity/common/inf-xml-connection.h&gt;
7 #include &lt;libinfinity/common/inf-xml-util.h&gt;
8 #include &lt;libinfinity/common/inf-error.h&gt;
9 #include &lt;libinfinity/inf-i18n.h&gt;
10 #include &lt;libinfinity/inf-signals.h&gt;
11 #include &lt;string.h&gt;
12 typedef struct _InfcSessionProxyPrivate InfcSessionProxyPrivate;
13 struct _InfcSessionProxyPrivate {
14   InfSession* session;
15   InfCommunicationJoinedGroup* subscription_group;
16   InfXmlConnection* connection;
17   InfcRequestManager* request_manager;
18 };
19 enum {
20   PROP_0,
21   PROP_SESSION,
22   PROP_SUBSCRIPTION_GROUP,
23   PROP_SEQUENCE_ID,
24   PROP_CONNECTION
25 };
26 #define INFC_SESSION_PROXY_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_SESSION_PROXY, InfcSessionProxyPrivate))
27 static void infc_session_proxy_communication_object_iface_init(InfCommunicationObjectInterface* iface);
28 static void infc_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface);
29 G_DEFINE_TYPE_WITH_CODE(InfcSessionProxy, infc_session_proxy, G_TYPE_OBJECT,
30   G_ADD_PRIVATE(InfcSessionProxy)
31   G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, infc_session_proxy_communication_object_iface_init)
32   G_IMPLEMENT_INTERFACE(INF_TYPE_SESSION_PROXY, infc_session_proxy_session_proxy_iface_init))
33 static void
34 infc_session_proxy_release_connection(InfcSessionProxy* proxy);
35 static void
36 infc_session_proxy_unsubscribe_connection(InfcSessionProxy* proxy)
37 {
38   InfcSessionProxyPrivate* priv;
39   InfSessionSyncStatus sync_status;
40   InfXmlConnectionStatus conn_status;
41   xmlNodePtr xml;
42   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
43   g_assert(priv-&gt;connection != NULL);
44   g_assert(priv-&gt;session != NULL);
45   sync_status = inf_session_get_synchronization_status(
46     priv-&gt;session,
47     priv-&gt;connection
48   );
49   g_object_get(G_OBJECT(priv-&gt;connection), "status", &amp;conn_status, NULL);
50   if(conn_status == INF_XML_CONNECTION_OPEN &amp;&amp;
51      sync_status != INF_SESSION_SYNC_IN_PROGRESS)
52   {
53     xml = xmlNewNode(NULL, (const xmlChar*)"session-unsubscribe");
54     inf_communication_group_send_message(
55       INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
56       priv-&gt;connection,
57       xml
58     );
59   }
60   if(priv-&gt;connection != NULL)
61     infc_session_proxy_release_connection(proxy);
62 }
63 static void
64 infc_session_proxy_connection_notify_status_cb(InfXmlConnection* connection,
65                                                GParamSpec* pspec,
66                                                gpointer user_data)
67 {
68   InfcSessionProxy* proxy;
69   InfXmlConnectionStatus status;
70   proxy = INFC_SESSION_PROXY(user_data);
71   g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
72   if(status == INF_XML_CONNECTION_CLOSED ||
73      status == INF_XML_CONNECTION_CLOSING)
74   {
75     infc_session_proxy_release_connection(proxy);
76   }
77 }
78 static void
79 infc_session_proxy_session_synchronization_complete_cb(InfSession* session,
80                                                        InfXmlConnection* conn,
81                                                        gpointer user_data)
82 {
83   InfcSessionProxy* proxy;
84   InfcSessionProxyPrivate* priv;
85   InfSessionStatus status;
86   proxy = INFC_SESSION_PROXY(user_data);
87   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
88   g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
89   if(status == INF_SESSION_SYNCHRONIZING)
90   {
91     if(priv-&gt;connection != NULL)
92     {
93       g_assert(priv-&gt;connection == conn);
94     }
95   }
96 }
97 static void
98 infc_session_proxy_session_synchronization_failed_cb(InfSession* session,
99                                                      InfXmlConnection* conn,
100                                                      const GError* error,
101                                                      gpointer user_data)
102 {
103   InfcSessionProxy* proxy;
104   InfcSessionProxyPrivate* priv;
105   InfSessionStatus status;
106   proxy = INFC_SESSION_PROXY(user_data);
107   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
108   g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
109   switch(status)
110   {
111   case INF_SESSION_SYNCHRONIZING:
112     break;
113   case INF_SESSION_RUNNING:
114     if(priv-&gt;connection != NULL)
115       infc_session_proxy_release_connection(proxy);
116     break;
117   case INF_SESSION_CLOSED:
118   default:
119     g_assert_not_reached();
120     break;
121   }
122 }
123 static void
124 infc_session_proxy_session_close_cb(InfSession* session,
125                                     gpointer user_data)
126 {
127   InfcSessionProxy* proxy;
128   InfcSessionProxyPrivate* priv;
129   proxy = INFC_SESSION_PROXY(user_data);
130   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
131   if(priv-&gt;connection != NULL)
132     infc_session_proxy_unsubscribe_connection(proxy);
133 #if 0
134   inf_signal_handlers_disconnect_by_func(
135     G_OBJECT(priv-&gt;session),
136     G_CALLBACK(infc_session_proxy_session_close_cb),
137     proxy
138   );
139   inf_signal_handlers_disconnect_by_func(
140     G_OBJECT(priv-&gt;session),
141     G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
142     proxy
143   );
144   inf_signal_handlers_disconnect_by_func(
145     G_OBJECT(priv-&gt;session),
146     G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
147     proxy
148   );
149   g_object_unref(G_OBJECT(priv-&gt;session));
150   priv-&gt;session = NULL;
151 #endif
152 }
153 static void
154 infc_session_proxy_release_connection_foreach_user_func(InfUser* user,
155                                                         gpointer user_data)
156 {
157   g_object_set(G_OBJECT(user), "status", INF_USER_UNAVAILABLE, NULL);
158 }
159 static void
160 infc_session_proxy_release_connection(InfcSessionProxy* proxy)
161 {
162   InfcSessionProxyPrivate* priv;
163   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
164   g_assert(priv-&gt;connection != NULL);
165   g_assert(priv-&gt;subscription_group != NULL);
166   g_assert(priv-&gt;request_manager != NULL);
167   infc_request_manager_clear(priv-&gt;request_manager);
168   g_object_unref(priv-&gt;request_manager);
169   priv-&gt;request_manager = NULL;
170   inf_user_table_foreach_user(
171     inf_session_get_user_table(priv-&gt;session),
172     infc_session_proxy_release_connection_foreach_user_func,
173     NULL
174   );
175   inf_signal_handlers_disconnect_by_func(
176     G_OBJECT(priv-&gt;connection),
177     G_CALLBACK(infc_session_proxy_connection_notify_status_cb),
178     proxy
179   );
180   g_object_unref(priv-&gt;subscription_group);
181   priv-&gt;subscription_group = NULL;
182   g_object_unref(G_OBJECT(priv-&gt;connection));
183   priv-&gt;connection = NULL;
184   g_object_ref(proxy);
185   inf_session_set_subscription_group(priv-&gt;session, NULL);
186   g_object_notify(G_OBJECT(proxy), "connection");
187   g_object_notify(G_OBJECT(proxy), "subscription-group");
188   g_object_unref(proxy);
189 }
190 static xmlNodePtr
191 infc_session_proxy_request_to_xml(InfcRequest* request)
192 {
193   xmlNodePtr xml;
194   gchar* type;
195   guint seq;
196   gchar seq_buffer[16];
197   g_object_get(G_OBJECT(request), "type", &amp;type, "seq", &amp;seq, NULL);
198   sprintf(seq_buffer, "%u", seq);
199   xml = xmlNewNode(NULL, (const xmlChar*)type);
200   xmlNewProp(xml, (const xmlChar*)"seq", (const xmlChar*)seq_buffer);
201   g_free(type);
202   return xml;
203 }
204 static void
205 infc_session_proxy_init(InfcSessionProxy* proxy)
206 {
207   InfcSessionProxyPrivate* priv;
208   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
209   priv-&gt;session = NULL;
210   priv-&gt;subscription_group = NULL;
211   priv-&gt;connection = NULL;
212   priv-&gt;request_manager = NULL;
213 }
214 static void
215 infc_session_proxy_dispose(GObject* object)
216 {
217   InfcSessionProxy* proxy;
218   InfcSessionProxyPrivate* priv;
219   proxy = INFC_SESSION_PROXY(object);
220   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
221   if(priv-&gt;connection)
222     infc_session_proxy_unsubscribe_connection(proxy);
223   if(priv-&gt;session != NULL)
224   {
225     inf_signal_handlers_disconnect_by_func(
226       G_OBJECT(priv-&gt;session),
227       G_CALLBACK(infc_session_proxy_session_close_cb),
228       proxy
229     );
230     inf_signal_handlers_disconnect_by_func(
231       G_OBJECT(priv-&gt;session),
232       G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
233       proxy
234     );
235     inf_signal_handlers_disconnect_by_func(
236       G_OBJECT(priv-&gt;session),
237       G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
238       proxy
239     );
240     g_object_unref(G_OBJECT(priv-&gt;session));
241     priv-&gt;session = NULL;
242   }
243   g_assert(priv-&gt;request_manager == NULL);
244   G_OBJECT_CLASS(infc_session_proxy_parent_class)-&gt;dispose(object);
245 }
246 static void
247 infc_session_proxy_set_property(GObject* object,
248                                 guint prop_id,
249                                 const GValue* value,
250                                 GParamSpec* pspec)
251 {
252   InfcSessionProxy* proxy;
253   InfcSessionProxyPrivate* priv;
254   proxy = INFC_SESSION_PROXY(object);
255   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
256   switch(prop_id)
257   {
258   case PROP_SESSION:
259     g_assert(priv-&gt;session == NULL);     priv-&gt;session = INF_SESSION(g_value_dup_object(value));
260     g_signal_connect(
261       G_OBJECT(priv-&gt;session),
262       "close",
263       G_CALLBACK(infc_session_proxy_session_close_cb),
264       proxy
265     );
266     g_signal_connect(
267       G_OBJECT(priv-&gt;session),
268       "synchronization-complete",
269       G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
270       proxy
271     );
272     g_signal_connect(
273       G_OBJECT(priv-&gt;session),
274       "synchronization-failed",
275       G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
276       proxy
277     );
278 <a name="0"></a>
279     break;
280   case PROP_SUBSCRIPTION_GROUP:
281 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case PROP_CONNECTION:
282   default:
283     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
284     break;
285   }
286 }
287 static void
288 infc_session_proxy_get_property(GObject* object,
289                                 guint prop_id,
290                                 GValue* value,
291                                 GParamSpec* pspec)
292 {
293   InfcSessionProxy* session;
294   InfcSessionProxyPrivate* priv;
295   session = INFC_SESSION_PROXY(object);
296   priv = INFC_SESSION_PROXY_PRIVATE(session);
297   switch(prop_id)
298   {
299   case PROP_SESSION:
300     g_value_set_object(value, G_OBJECT(priv-&gt;session));
301     break;</b></font>
302   case PROP_SUBSCRIPTION_GROUP:
303     g_value_set_boxed(value, priv-&gt;subscription_group);
304     break;
305   case PROP_CONNECTION:
306     g_value_set_object(value, G_OBJECT(priv-&gt;connection));
307     break;
308   default:
309     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
310     break;
311   }
312 }
313 static GError*
314 infc_session_proxy_translate_error_impl(InfcSessionProxy* proxy,
315                                         GQuark domain,
316                                         guint code)
317 {
318   GError* error;
319   const gchar* error_msg;
320   if(domain == inf_request_error_quark())
321     error_msg = inf_request_strerror(code);
322   else if(domain == inf_user_error_quark())
323     error_msg = inf_user_strerror(code);
324   else
325     error_msg = NULL;
326   error = NULL;
327   if(error_msg != NULL)
328   {
329     g_set_error_literal(&amp;error, domain, code, error_msg);
330   }
331   else
332   {
333     g_set_error(
334       &amp;error,
335       inf_request_error_quark(),
336       INF_REQUEST_ERROR_UNKNOWN_DOMAIN,
337       _("Error comes from unknown error domain \"%s\" (code %u)"),
338       g_quark_to_string(domain),
339       (guint)code
340     );
341   }
342   return error;
343 }
344 static gboolean
345 infc_session_proxy_handle_user_join(InfcSessionProxy* proxy,
346                                     InfXmlConnection* connection,
347                                     xmlNodePtr xml,
348                                     GError** error)
349 {
350   InfcSessionProxyPrivate* priv;
351   InfSessionClass* session_class;
352   InfcRequest* request;
353   GArray* array;
354   InfUser* user;
355   GParameter* param;
356   gboolean result;
357   guint i;
358   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
359   session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
360   request = infc_request_manager_get_request_by_xml(
361     priv-&gt;request_manager,
362     "user-join",
363     xml,
364     NULL
365   );
366   array = session_class-&gt;get_xml_user_props(priv-&gt;session, connection, xml);
367   param = inf_session_get_user_property(array, "flags");
368   g_assert(!G_IS_VALUE(&amp;param-&gt;value)); 
369   g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
370   if(request != NULL)
371     g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
372   else
373     g_value_set_flags(&amp;param-&gt;value, 0);
374   param = inf_session_get_user_property(array, "connection");
375   if(!G_IS_VALUE(&amp;param-&gt;value))
376   {
377     g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
378     g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));
379   }
380   result = session_class-&gt;validate_user_props(
381     priv-&gt;session,
382     (const GParameter*)array-&gt;data,
383     array-&gt;len,
384     NULL,
385     error
386   );
387   if(result == TRUE)
388   {
389     user = inf_session_add_user(
390       priv-&gt;session,
391       (const GParameter*)array-&gt;data,
392       array-&gt;len
393     );
394     g_assert(user != NULL);
395   }
396   for(i = 0; i &lt; array-&gt;len; ++ i)
397     g_value_unset(&amp;g_array_index(array, GParameter, i).value);
398   g_array_free(array, TRUE);
399   if(user != NULL)
400   {
401     if(request != NULL)
402     {
403       infc_request_manager_finish_request(
404         priv-&gt;request_manager,
405         request,
406         inf_request_result_make_join_user(INF_SESSION_PROXY(proxy), user)
407       );
408     }
409     return TRUE;
410   }
411   else
412   {
413     return FALSE;
414   }
415 }
416 static gboolean
417 infc_session_proxy_handle_user_rejoin(InfcSessionProxy* proxy,
418                                       InfXmlConnection* connection,
419                                       xmlNodePtr xml,
420                                       GError** error)
421 {
422   InfcSessionProxyPrivate* priv;
423   InfSessionClass* session_class;
424   InfcRequest* request;
425   GArray* array;
426   InfUser* user;
427   const GParameter* idparam;
428   GParameter* param;
429   guint id;
430   gboolean result;
431   guint i;
432   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
433   session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
434   request = infc_request_manager_get_request_by_xml(
435     priv-&gt;request_manager,
436     "user-join",
437     xml,
438     NULL
439   );
440   array = session_class-&gt;get_xml_user_props(priv-&gt;session, connection, xml);
441   idparam = inf_session_lookup_user_property(
442     (const GParameter*)array-&gt;data,
443     array-&gt;len,
444     "id"
445   );
446   if(idparam == NULL)
447   {
448     g_set_error_literal(
449       error,
450       inf_request_error_quark(),
451       INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
452       _("Request does not contain required attribute \"id\"")
453     );
454     goto error;
455   }
456   id = g_value_get_uint(&amp;idparam-&gt;value);
457   user = inf_user_table_lookup_user_by_id(
458     inf_session_get_user_table(priv-&gt;session),
459     id
460   );
461   if(user == NULL)
462   {
463     g_set_error(
464       error,
465       inf_user_error_quark(),
466       INF_USER_ERROR_NO_SUCH_USER,
467       _("No such user with ID %u"),
468       id
469     );
470     goto error;
471   }
472   param = inf_session_get_user_property(array, "flags");
473   g_assert(!G_IS_VALUE(&amp;param-&gt;value)); 
474   g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
475   if(request != NULL)
476     g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
477   else
478     g_value_set_flags(&amp;param-&gt;value, 0);
479   param = inf_session_get_user_property(array, "connection");
480   if(!G_IS_VALUE(&amp;param-&gt;value))
481   {
482     g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
483     g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));
484   }
485   result = session_class-&gt;validate_user_props(
486     priv-&gt;session,
487     (const GParameter*)array-&gt;data,
488     array-&gt;len,
489     user,
490     error
491   );
492   if(result == FALSE)
493     goto error;
494   g_object_freeze_notify(G_OBJECT(user));
495   for(i = 0; i &lt; array-&gt;len; ++ i)
496   {
497     param = &amp;g_array_index(array, GParameter, i);
498     if(strcmp(param-&gt;name, "id") != 0)
499       g_object_set_property(G_OBJECT(user), param-&gt;name, &amp;param-&gt;value);
500   }
501   g_object_thaw_notify(G_OBJECT(user));
502   for(i = 0; i &lt; array-&gt;len; ++ i)
503     g_value_unset(&amp;g_array_index(array, GParameter, i).value);
504   g_array_free(array, TRUE);
505   if(request != NULL)
506   {
507     infc_request_manager_finish_request(
508       priv-&gt;request_manager,
509       request,
510       inf_request_result_make_join_user(INF_SESSION_PROXY(proxy), user)
511     );
512   }
513   return TRUE;
514 error:
515   for(i = 0; i &lt; array-&gt;len; ++ i)
516     g_value_unset(&amp;g_array_index(array, GParameter, i).value);
517   g_array_free(array, TRUE);
518   return FALSE;
519 }
520 static gboolean
521 infc_session_proxy_handle_request_failed(InfcSessionProxy* proxy,
522                                          InfXmlConnection* connection,
523                                          xmlNodePtr xml,
524                                          GError** error)
525 {
526   InfcSessionProxyPrivate* priv;
527   InfcSessionProxyClass* proxy_class;
528   xmlChar* domain;
529   gboolean has_code;
530   guint code;
531   GError* req_error;
532   InfcRequest* request;
533   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
534   proxy_class = INFC_SESSION_PROXY_GET_CLASS(proxy);
535   has_code = inf_xml_util_get_attribute_uint_required(
536     xml,
537     "code",
538     &amp;code,
539     error
540   );
541   if(has_code == FALSE) return FALSE;
542   domain = inf_xml_util_get_attribute_required(xml, "domain", error);
543   if(domain == NULL) return FALSE;
544   req_error = NULL;
545   request = infc_request_manager_get_request_by_xml_required(
546     priv-&gt;request_manager,
547     NULL,
548     xml,
549     error
550   );
551   if(request == NULL) return FALSE;
552   g_assert(proxy_class-&gt;translate_error != NULL);
553   req_error = proxy_class-&gt;translate_error(
554     proxy,
555     g_quark_from_string((const gchar*)domain),
556     code
557   );
558   infc_request_manager_fail_request(
559     priv-&gt;request_manager,
560     request,
561     req_error
562   );
563   g_error_free(req_error);
564   xmlFree(domain);
565   return TRUE;
566 }
567 static gboolean
568 infc_session_proxy_handle_session_close(InfcSessionProxy* proxy,
569                                         InfXmlConnection* connection,
570                                         xmlNodePtr xml,
571                                         GError** error)
572 {
573   InfcSessionProxyPrivate* priv;
574   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
575   g_assert(priv-&gt;connection != NULL);
576   infc_session_proxy_release_connection(proxy);
577   return TRUE;
578 }
579 static void
580 infc_session_proxy_communication_object_sent(InfCommunicationObject* object,
581                                              InfXmlConnection* connection,
582                                              xmlNodePtr node)
583 {
584   InfcSessionProxy* proxy;
585   InfcSessionProxyPrivate* priv;
586   proxy = INFC_SESSION_PROXY(object);
587   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
588   g_assert(priv-&gt;session != NULL);
589   inf_communication_object_sent(
590     INF_COMMUNICATION_OBJECT(priv-&gt;session),
591     connection,
592     node
593   );
594 }
595 static void
596 infc_session_proxy_communication_object_enqueued(InfCommunicationObject* obj,
597                                                  InfXmlConnection* connection,
598                                                  xmlNodePtr node)
599 {
600   InfcSessionProxy* proxy;
601   InfcSessionProxyPrivate* priv;
602   proxy = INFC_SESSION_PROXY(obj);
603   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
604   g_assert(priv-&gt;session != NULL);
605   inf_communication_object_enqueued(
606     INF_COMMUNICATION_OBJECT(priv-&gt;session),
607     connection,
608     node
609   );
610 }
611 static InfCommunicationScope
612 infc_session_proxy_communication_object_received(InfCommunicationObject* obj,
613                                                  InfXmlConnection* connection,
614                                                  xmlNodePtr node)
615 {
616   InfcSessionProxy* proxy;
617   InfcSessionProxyPrivate* priv;
618   InfcSessionProxyClass* proxy_class;
619   InfSessionSyncStatus status;
620   GError* local_error;
621   InfcRequest* request;
622   GError* seq_error;
623   proxy = INFC_SESSION_PROXY(obj);
624   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
625   proxy_class = INFC_SESSION_PROXY_GET_CLASS(proxy);
626   status = inf_session_get_synchronization_status(priv-&gt;session, connection);
627   local_error = NULL;
628   g_assert(status != INF_SESSION_SYNC_NONE || priv-&gt;connection == connection);
629   g_assert(inf_session_get_status(priv-&gt;session) != INF_SESSION_CLOSED);
630   if(status != INF_SESSION_SYNC_NONE)
631   {
632     return inf_communication_object_received(
633       INF_COMMUNICATION_OBJECT(priv-&gt;session),
634       connection,
635       node
636     );
637   }
638   else
639   {
640     if(strcmp((const char*)node-&gt;name, "user-join") == 0)
641     {
642       infc_session_proxy_handle_user_join(
643         proxy,
644         connection,
645         node,
646         &amp;local_error
647       );
648     }
649     else if(strcmp((const char*)node-&gt;name, "user-rejoin") == 0)
650     {
651       infc_session_proxy_handle_user_rejoin(
652         proxy,
653         connection,
654         node,
655         &amp;local_error
656       );
657     }
658     else if(strcmp((const char*)node-&gt;name, "request-failed") == 0)
659     {
660       infc_session_proxy_handle_request_failed(
661         proxy,
662         connection,
663         node,
664         &amp;local_error
665       );
666     }
667     else if(strcmp((const char*)node-&gt;name, "session-close") == 0)
668     {
669       infc_session_proxy_handle_session_close(
670         proxy,
671         connection,
672         node,
673         &amp;local_error
674       );
675     }
676     else
677     {
678       return inf_communication_object_received(
679         INF_COMMUNICATION_OBJECT(priv-&gt;session),
680         connection,
681         node
682       );
683     }
684   }
685   if(local_error != NULL)
686   {
687     request = infc_request_manager_get_request_by_xml(
688       priv-&gt;request_manager,
689       NULL,
690       node,
691       NULL
692     );
693     if(request != NULL)
694     {
695       seq_error = NULL;
696       g_set_error(
697         &amp;seq_error,
698         inf_request_error_quark(),
699         INF_REQUEST_ERROR_REPLY_UNPROCESSED,
700         _("Server reply could not be processed: %s"),
701         local_error-&gt;message
702       );
703       infc_request_manager_fail_request(
704         priv-&gt;request_manager,
705         request,
706         seq_error
707       );
708       g_error_free(seq_error);
709     }
710     g_error_free(local_error);
711   }
712   return INF_COMMUNICATION_SCOPE_PTP;
713 }
714 InfRequest*
715 infc_session_proxy_session_proxy_join_user(InfSessionProxy* proxy,
716                                            guint n_params,
717                                            const GParameter* params,
718                                            InfRequestFunc func,
719                                            gpointer user_data)
720 {
721   InfcSessionProxyPrivate* priv;
722   InfSessionClass* session_class;
723   InfSessionStatus status;
724   InfcRequest* request;
725   xmlNodePtr xml;
726   g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
727   g_return_val_if_fail(n_params == 0 || params != NULL, NULL);
728   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
729   g_return_val_if_fail(priv-&gt;session != NULL, NULL);
730   session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
731   g_object_get(G_OBJECT(priv-&gt;session), "status", &amp;status, NULL);
732   g_return_val_if_fail(status == INF_SESSION_RUNNING, NULL);
733   g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
734   g_return_val_if_fail(priv-&gt;request_manager != NULL, NULL);
735   request = infc_request_manager_add_request(
736     priv-&gt;request_manager,
737     INFC_TYPE_REQUEST,
738     "user-join",
739     G_CALLBACK(func),
740     user_data,
741     NULL
742   );
743   xml = infc_session_proxy_request_to_xml(INFC_REQUEST(request));
744   g_assert(session_class-&gt;set_xml_user_props != NULL);
745   session_class-&gt;set_xml_user_props(priv-&gt;session, params, n_params, xml);
746   inf_communication_group_send_message(
747     INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
748     priv-&gt;connection,
749     xml
750   );
751   return INF_REQUEST(request);
752 }
753 <a name="1"></a>
754 static void
755 infc_session_proxy_class_init(InfcSessionProxyClass* proxy_class)
756 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
757   GObjectClass* object_class;
758   object_class = G_OBJECT_CLASS(proxy_class);
759   object_class-&gt;dispose = infc_session_proxy_dispose;
760   object_class-&gt;set_property = infc_session_proxy_set_property;
761   object_class-&gt;get_property = infc_session_proxy_get_property;
762   proxy_class-&gt;translate_error = infc_session_proxy_translate_error_impl;
763   g_object_class_install_property(
764     object_class,
765     PROP_SUBSCRIPTION_GROUP,
766     g_param_spec_object(
767       "subscription-group",
768       "Subscription group",
769       "The communication group of subscribed connections",
770       INF_COMMUNICATION_TYPE_JOINED_GROUP,
771       G_PARAM_READABLE
772     )
773   );
774   g_object_class_install_property(
775     object_class,
776     PROP_CONNECTION,
777     g_param_spec_object(
778       "connection",
779       "Subscription connection",
780       "The connection with which the session communicates with the server",
781       INF_TYPE_XML_CONNECTION,
782       G_PARAM_READABLE
783     )
784   );
785   g_object_class_override_property(object_class, PROP_SESSION, "session");
786 }
787 static void
788 infc_session_proxy_communication_object_iface_init(
789   InfCommunicationObjectInterface* iface)
790 {
791   iface-&gt;sent = infc_session_proxy_communication_object_sent;
792   iface-&gt;enqueued = infc_session_proxy_communication_object_enqueued;</b></font>
793   iface-&gt;received = infc_session_proxy_communication_object_received;
794 }
795 static void
796 infc_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface)
797 {
798   iface-&gt;join_user = infc_session_proxy_session_proxy_join_user;
799 }
800 void
801 infc_session_proxy_set_connection(InfcSessionProxy* proxy,
802                                   InfCommunicationJoinedGroup* group,
803                                   InfXmlConnection* connection,
804                                   guint seq_id)
805 {
806   InfcSessionProxyPrivate* priv;
807   xmlNodePtr xml;
808   g_return_if_fail(INFC_IS_SESSION_PROXY(proxy));
809   g_return_if_fail(connection == NULL || INF_IS_XML_CONNECTION(connection));
810   g_return_if_fail(
811     (group == NULL &amp;&amp; connection == NULL) ||
812     (INF_COMMUNICATION_IS_JOINED_GROUP(group) &amp;&amp; connection != NULL)
813   );
814   priv = INFC_SESSION_PROXY_PRIVATE(proxy);
815   g_return_if_fail(priv-&gt;session != NULL);
816   g_object_freeze_notify(G_OBJECT(proxy));
817   g_object_freeze_notify(G_OBJECT(priv-&gt;session));
818   if(priv-&gt;connection != NULL)
819   {
820     xml = xmlNewNode(NULL, (const xmlChar*)"session-unsubscribe");
821     inf_communication_group_send_message(
822       INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
823       priv-&gt;connection,
824       xml
825     );
826     infc_session_proxy_release_connection(proxy);
827   }
828   priv-&gt;connection = connection;
829   if(connection != NULL)
830   {
831     priv-&gt;connection = connection;
832     g_object_ref(G_OBJECT(connection));
833     g_signal_connect(
834       G_OBJECT(connection),
835       "notify::status",
836       G_CALLBACK(infc_session_proxy_connection_notify_status_cb),
837       proxy
838     );
839     priv-&gt;subscription_group = group;
840     g_object_ref(priv-&gt;subscription_group);
841     g_assert(priv-&gt;request_manager == NULL);
842     priv-&gt;request_manager = infc_request_manager_new(seq_id);
843   }
844   inf_session_set_subscription_group(
845     priv-&gt;session,
846     INF_COMMUNICATION_GROUP(priv-&gt;subscription_group)
847   );
848   g_object_notify(G_OBJECT(proxy), "connection");
849   g_object_notify(G_OBJECT(proxy), "subscription-group");
850   g_object_thaw_notify(G_OBJECT(priv-&gt;session));
851   g_object_thaw_notify(G_OBJECT(proxy));
852 }
853 InfXmlConnection*
854 infc_session_proxy_get_connection(InfcSessionProxy* proxy)
855 {
856   g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
857   return INFC_SESSION_PROXY_PRIVATE(proxy)-&gt;connection;
858 }
859 InfCommunicationJoinedGroup*
860 infc_session_proxy_get_subscription_group(InfcSessionProxy* proxy)
861 {
862   g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
863   return INFC_SESSION_PROXY_PRIVATE(proxy)-&gt;subscription_group;
864 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
