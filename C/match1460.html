<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for infinoted-log.c &amp; infc-session-proxy.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for infinoted-log.c &amp; infc-session-proxy.c
      </h3>
<h1 align="center">
        7.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>infinoted-log.c (11.555555%)<th>infc-session-proxy.c (5.54371%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(269-293)<td><a href="#" name="0">(458-483)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(201-230)<td><a href="#" name="1">(1070-1112)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>infinoted-log.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;infinoted/infinoted-log.h&gt;
#include &lt;infinoted/infinoted-util.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;
#ifdef LIBINFINITY_HAVE_LIBDAEMON
# include &lt;libdaemon/dlog.h&gt;
#endif
#ifdef G_OS_WIN32
# define LOG_ERR 0
# define LOG_WARNING 1
# define LOG_INFO 2
# include &lt;windows.h&gt;
#else
# include &lt;syslog.h&gt;
#endif
typedef struct _InfinotedLogPrivate InfinotedLogPrivate;
struct _InfinotedLogPrivate {
  gchar* file_path;
  FILE* log_file;
  GLogFunc prev_log_handler;
  GRecMutex mutex;
  guint recursion_depth;
};
enum {
  PROP_0,
  PROP_FILE_PATH
};
enum {
  LOG_MESSAGE,
  LAST_SIGNAL
};
#define INFINOTED_LOG_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFINOTED_TYPE_LOG, InfinotedLogPrivate))
static guint log_signals[LAST_SIGNAL];
G_DEFINE_TYPE_WITH_CODE(InfinotedLog, infinoted_log, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfinotedLog))
static void
infinoted_log_handler(const gchar* log_domain,
                      GLogLevelFlags log_level,
                      const gchar* message,
                      gpointer user_data)
{
  InfinotedLog* log;
  log = INFINOTED_LOG(user_data);
  switch(log_level &amp; G_LOG_LEVEL_MASK)
  {
  case G_LOG_LEVEL_ERROR:
  case G_LOG_LEVEL_CRITICAL:
    if(log_domain)
      infinoted_log_error(log, "%s: %s", log_domain, message);
    else
      infinoted_log_error(log, "%s", message);
    break;
  case G_LOG_LEVEL_WARNING:
    if(log_domain)
      infinoted_log_warning(log, "%s: %s", log_domain, message);
    else
      infinoted_log_warning(log, "%s", message);
    break;
  case G_LOG_LEVEL_MESSAGE:
  case G_LOG_LEVEL_INFO:
  case G_LOG_LEVEL_DEBUG:
    if(log_domain)
      infinoted_log_info(log, "%s: %s", log_domain, message);
    else
      infinoted_log_info(log, "%s", message);
    break;
  }
  if(log_level &amp; G_LOG_FLAG_FATAL)
    abort();
}
static void
infinoted_log_write(InfinotedLog* log,
                    guint prio,
                    guint depth,
                    const gchar* text)
{
  InfinotedLogPrivate* priv;
  time_t cur_time;
  struct tm* cur_tm;
  char time_msg[128];
  gchar* final_text;
  priv = INFINOTED_LOG_PRIVATE(log);
  if(depth == 0)
  {
    cur_time = time(NULL);
    cur_tm = localtime(&amp;cur_time);
    switch(prio)
    {
    case LOG_ERR:
      strftime(time_msg, 128, "[%c]   ERROR", cur_tm);
      break;
    case LOG_WARNING:
      strftime(time_msg, 128, "[%c] WARNING", cur_tm);
      break;
    case LOG_INFO:
      strftime(time_msg, 128, "[%c]    INFO", cur_tm);
      break;
    default:
      g_assert_not_reached();
      break;
    }
    final_text = g_strdup_printf("%s: %s", time_msg, text);
  }
  else
  {
    final_text = g_strdup_printf("\t%s", text);
  }
#ifdef LIBINFINITY_HAVE_LIBDAEMON
  daemon_log(prio, "%s", final_text);
#else
#ifdef G_OS_WIN32
  gchar* codeset;
  gchar* converted;
  codeset = g_strdup_printf("CP%u", (guint)GetConsoleOutputCP());
  converted = g_convert(final_text, -1, codeset, "UTF-8", NULL, NULL, NULL);
  g_free(codeset);
  fprintf(stderr, "%s\n", converted);
  g_free(converted);
#else
  fprintf(stderr, "%s\n", final_text);
#endif #endif 
  if(priv-&gt;log_file != NULL)
  {
    fprintf(priv-&gt;log_file, "%s\n", final_text);
    fflush(priv-&gt;log_file);
  }
  g_free(final_text);
}
static void
infinoted_log_entry(InfinotedLog* log,
<a name="1"></a>                    guint prio,
                    const gchar* fmt,
                    va_list args)
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
  InfinotedLogPrivate* priv;
  gchar* text;
  guint depth;
  priv = INFINOTED_LOG_PRIVATE(log);
  text = g_strdup_vprintf(fmt, args);
  g_rec_mutex_lock(&amp;priv-&gt;mutex);
  depth = priv-&gt;recursion_depth++;
  g_signal_emit(log, log_signals[LOG_MESSAGE], 0, prio, depth, text);
  g_assert(priv-&gt;recursion_depth == depth + 1);
  --priv-&gt;recursion_depth;
  g_rec_mutex_unlock(&amp;priv-&gt;mutex);
  g_free(text);
}
static void
infinoted_log_init(InfinotedLog* log)
{
  InfinotedLogPrivate* priv;
  priv = INFINOTED_LOG_PRIVATE(log);
  priv-&gt;file_path = NULL;</b></font>
  priv-&gt;log_file = NULL;
  priv-&gt;prev_log_handler = NULL;
  priv-&gt;recursion_depth = 0;
  g_rec_mutex_init(&amp;priv-&gt;mutex);
}
static void
infinoted_log_finalize(GObject* object)
{
  InfinotedLog* log;
  InfinotedLogPrivate* priv;
  log = INFINOTED_LOG(object);
  priv = INFINOTED_LOG_PRIVATE(log);
  if(priv-&gt;log_file != NULL)
    infinoted_log_close(log);
  g_rec_mutex_clear(&amp;priv-&gt;mutex);
  G_OBJECT_CLASS(infinoted_log_parent_class)-&gt;finalize(object);
}
static void
infinoted_log_set_property(GObject* object,
                           guint prop_id,
                           const GValue* value,
                           GParamSpec* pspec)
{
  InfinotedLog* log;
  InfinotedLogPrivate* priv;
  log = INFINOTED_LOG(object);
  priv = INFINOTED_LOG_PRIVATE(log);
<a name="0"></a>
  switch(prop_id)
  {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  case PROP_FILE_PATH:
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infinoted_log_get_property(GObject* object,
                           guint prop_id,
                           GValue* value,
                           GParamSpec* pspec)
{
  InfinotedLog* log;
  InfinotedLogPrivate* priv;
  log = INFINOTED_LOG(object);
  priv = INFINOTED_LOG_PRIVATE(log);
  switch(prop_id)
  {
  case PROP_FILE_PATH:
    g_value_set_string(value, priv-&gt;file_path);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infinoted_log_log_message(InfinotedLog* log,
                          guint prio,
                          guint depth,
                          const gchar* text)
{
  InfinotedLogPrivate* priv;
  priv = INFINOTED_LOG_PRIVATE(log);
  g_assert(priv-&gt;recursion_depth == depth+1);
  infinoted_log_write(log, prio, depth, text);
}
static void
infinoted_log_class_init(InfinotedLogClass* log_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(log_class);
  object_class-&gt;finalize = infinoted_log_finalize;
  object_class-&gt;set_property = infinoted_log_set_property;
  object_class-&gt;get_property = infinoted_log_get_property;
  log_class-&gt;log_message = infinoted_log_log_message;
  g_object_class_install_property(
    object_class,
    PROP_FILE_PATH,
    g_param_spec_string(
      "file-path",
      "File Path",
      "Path to the log file",
      NULL,
      G_PARAM_READABLE
    )
  );
  log_signals[LOG_MESSAGE] = g_signal_new(
    "log-message",
    G_OBJECT_CLASS_TYPE(object_class),
    G_SIGNAL_RUN_FIRST,
    G_STRUCT_OFFSET(InfinotedLogClass, log_message),
    NULL, NULL,
    NULL,
    G_TYPE_NONE,
    3,
    G_TYPE_UINT,
    G_TYPE_UINT,
    G_TYPE_STRING
  );
}
InfinotedLog*
infinoted_log_new(void)
{
  GObject* object = g_object_new(INFINOTED_TYPE_LOG, NULL);
  return INFINOTED_LOG(object);
}
gboolean
infinoted_log_open(InfinotedLog* log,
                   const gchar* path,
                   GError** error)
{
  InfinotedLogPrivate* priv;
  g_return_val_if_fail(INFINOTED_IS_LOG(log), FALSE);
  g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
  priv = INFINOTED_LOG_PRIVATE(log);
  g_rec_mutex_lock(&amp;priv-&gt;mutex);
  g_assert(priv-&gt;prev_log_handler == NULL);
  if(path != NULL)
  {
    g_assert(priv-&gt;log_file == NULL);
    priv-&gt;log_file = fopen(path, "a");
    if(priv-&gt;log_file == NULL)
    {
      infinoted_util_set_errno_error(error, errno, "Failed to open log file");
      return FALSE;
    }
    g_assert(priv-&gt;file_path == NULL);
    priv-&gt;file_path = g_strdup(path);
  }
  priv-&gt;prev_log_handler = g_log_set_default_handler(
    infinoted_log_handler,
    log
  );
  g_rec_mutex_unlock(&amp;priv-&gt;mutex);
  if(path != NULL)
    g_object_notify(G_OBJECT(log), "file-path");
  return TRUE;
}
void
infinoted_log_close(InfinotedLog* log)
{
  InfinotedLogPrivate* priv;
  g_return_if_fail(INFINOTED_IS_LOG(log));
  priv = INFINOTED_LOG_PRIVATE(log);
  g_rec_mutex_lock(&amp;priv-&gt;mutex);
  g_assert(priv-&gt;prev_log_handler != NULL);
  if(priv-&gt;log_file != NULL)
  {
    g_assert(priv-&gt;file_path != NULL);
    fclose(priv-&gt;log_file);
    priv-&gt;log_file = NULL;
    g_free(priv-&gt;file_path);
    priv-&gt;file_path = NULL;
  }
  g_assert(priv-&gt;file_path == NULL);
  g_log_set_default_handler(priv-&gt;prev_log_handler, NULL);
  priv-&gt;prev_log_handler = NULL;
  g_rec_mutex_unlock(&amp;priv-&gt;mutex);
  g_object_notify(G_OBJECT(log), "file-path");
}
void
infinoted_log_log(InfinotedLog* log,
                  guint prio,
                  const char* fmt,
                  ...)
{
  va_list ap;
  va_start(ap, fmt);
  infinoted_log_entry(log, prio, fmt, ap);
  va_end(ap);
}
void
infinoted_log_error(InfinotedLog* log,
                    const char* fmt,
                    ...)
{
  va_list ap;
  va_start(ap, fmt);
  infinoted_log_entry(log, LOG_ERR, fmt, ap);
  va_end(ap);
}
void
infinoted_log_warning(InfinotedLog* log,
                      const char* fmt,
                      ...)
{
  va_list ap;
  va_start(ap, fmt);
  infinoted_log_entry(log, LOG_WARNING, fmt, ap);
  va_end(ap);
}
void
infinoted_log_info(InfinotedLog* log,
                   const char* fmt,
                   ...)
{
  va_list ap;
  va_start(ap, fmt);
  infinoted_log_entry(log, LOG_INFO, fmt, ap);
  va_end(ap);
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>infc-session-proxy.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/client/infc-session-proxy.h&gt;
#include &lt;libinfinity/client/infc-request-manager.h&gt;
#include &lt;libinfinity/common/inf-session-proxy.h&gt;
#include &lt;libinfinity/common/inf-session.h&gt;
#include &lt;libinfinity/common/inf-request-result.h&gt;
#include &lt;libinfinity/common/inf-xml-connection.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;string.h&gt;
typedef struct _InfcSessionProxyPrivate InfcSessionProxyPrivate;
struct _InfcSessionProxyPrivate {
  InfSession* session;
  InfCommunicationJoinedGroup* subscription_group;
  InfXmlConnection* connection;
  InfcRequestManager* request_manager;
};
enum {
  PROP_0,
  PROP_SESSION,
  PROP_SUBSCRIPTION_GROUP,
  PROP_SEQUENCE_ID,
  PROP_CONNECTION
};
#define INFC_SESSION_PROXY_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INFC_TYPE_SESSION_PROXY, InfcSessionProxyPrivate))
static void infc_session_proxy_communication_object_iface_init(InfCommunicationObjectInterface* iface);
static void infc_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfcSessionProxy, infc_session_proxy, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfcSessionProxy)
  G_IMPLEMENT_INTERFACE(INF_COMMUNICATION_TYPE_OBJECT, infc_session_proxy_communication_object_iface_init)
  G_IMPLEMENT_INTERFACE(INF_TYPE_SESSION_PROXY, infc_session_proxy_session_proxy_iface_init))
static void
infc_session_proxy_release_connection(InfcSessionProxy* proxy);
static void
infc_session_proxy_unsubscribe_connection(InfcSessionProxy* proxy)
{
  InfcSessionProxyPrivate* priv;
  InfSessionSyncStatus sync_status;
  InfXmlConnectionStatus conn_status;
  xmlNodePtr xml;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_assert(priv-&gt;connection != NULL);
  g_assert(priv-&gt;session != NULL);
  sync_status = inf_session_get_synchronization_status(
    priv-&gt;session,
    priv-&gt;connection
  );
  g_object_get(G_OBJECT(priv-&gt;connection), "status", &amp;conn_status, NULL);
  if(conn_status == INF_XML_CONNECTION_OPEN &amp;&amp;
     sync_status != INF_SESSION_SYNC_IN_PROGRESS)
  {
    xml = xmlNewNode(NULL, (const xmlChar*)"session-unsubscribe");
    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      priv-&gt;connection,
      xml
    );
  }
  if(priv-&gt;connection != NULL)
    infc_session_proxy_release_connection(proxy);
}
static void
infc_session_proxy_connection_notify_status_cb(InfXmlConnection* connection,
                                               GParamSpec* pspec,
                                               gpointer user_data)
{
  InfcSessionProxy* proxy;
  InfXmlConnectionStatus status;
  proxy = INFC_SESSION_PROXY(user_data);
  g_object_get(G_OBJECT(connection), "status", &amp;status, NULL);
  if(status == INF_XML_CONNECTION_CLOSED ||
     status == INF_XML_CONNECTION_CLOSING)
  {
    infc_session_proxy_release_connection(proxy);
  }
}
static void
infc_session_proxy_session_synchronization_complete_cb(InfSession* session,
                                                       InfXmlConnection* conn,
                                                       gpointer user_data)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  InfSessionStatus status;
  proxy = INFC_SESSION_PROXY(user_data);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
  if(status == INF_SESSION_SYNCHRONIZING)
  {
    if(priv-&gt;connection != NULL)
    {
      g_assert(priv-&gt;connection == conn);
    }
  }
}
static void
infc_session_proxy_session_synchronization_failed_cb(InfSession* session,
                                                     InfXmlConnection* conn,
                                                     const GError* error,
                                                     gpointer user_data)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  InfSessionStatus status;
  proxy = INFC_SESSION_PROXY(user_data);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_object_get(G_OBJECT(session), "status", &amp;status, NULL);
  switch(status)
  {
  case INF_SESSION_SYNCHRONIZING:
    break;
  case INF_SESSION_RUNNING:
    if(priv-&gt;connection != NULL)
      infc_session_proxy_release_connection(proxy);
    break;
  case INF_SESSION_CLOSED:
  default:
    g_assert_not_reached();
    break;
  }
}
static void
infc_session_proxy_session_close_cb(InfSession* session,
                                    gpointer user_data)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  proxy = INFC_SESSION_PROXY(user_data);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  if(priv-&gt;connection != NULL)
    infc_session_proxy_unsubscribe_connection(proxy);
#if 0
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infc_session_proxy_session_close_cb),
    proxy
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
    proxy
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;session),
    G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
    proxy
  );
  g_object_unref(G_OBJECT(priv-&gt;session));
  priv-&gt;session = NULL;
#endif
}
static void
infc_session_proxy_release_connection_foreach_user_func(InfUser* user,
                                                        gpointer user_data)
{
  g_object_set(G_OBJECT(user), "status", INF_USER_UNAVAILABLE, NULL);
}
static void
infc_session_proxy_release_connection(InfcSessionProxy* proxy)
{
  InfcSessionProxyPrivate* priv;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_assert(priv-&gt;connection != NULL);
  g_assert(priv-&gt;subscription_group != NULL);
  g_assert(priv-&gt;request_manager != NULL);
  infc_request_manager_clear(priv-&gt;request_manager);
  g_object_unref(priv-&gt;request_manager);
  priv-&gt;request_manager = NULL;
  inf_user_table_foreach_user(
    inf_session_get_user_table(priv-&gt;session),
    infc_session_proxy_release_connection_foreach_user_func,
    NULL
  );
  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(priv-&gt;connection),
    G_CALLBACK(infc_session_proxy_connection_notify_status_cb),
    proxy
  );
  g_object_unref(priv-&gt;subscription_group);
  priv-&gt;subscription_group = NULL;
  g_object_unref(G_OBJECT(priv-&gt;connection));
  priv-&gt;connection = NULL;
  g_object_ref(proxy);
  inf_session_set_subscription_group(priv-&gt;session, NULL);
  g_object_notify(G_OBJECT(proxy), "connection");
  g_object_notify(G_OBJECT(proxy), "subscription-group");
  g_object_unref(proxy);
}
static xmlNodePtr
infc_session_proxy_request_to_xml(InfcRequest* request)
{
  xmlNodePtr xml;
  gchar* type;
  guint seq;
  gchar seq_buffer[16];
  g_object_get(G_OBJECT(request), "type", &amp;type, "seq", &amp;seq, NULL);
  sprintf(seq_buffer, "%u", seq);
  xml = xmlNewNode(NULL, (const xmlChar*)type);
  xmlNewProp(xml, (const xmlChar*)"seq", (const xmlChar*)seq_buffer);
  g_free(type);
  return xml;
}
static void
infc_session_proxy_init(InfcSessionProxy* proxy)
{
  InfcSessionProxyPrivate* priv;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  priv-&gt;session = NULL;
  priv-&gt;subscription_group = NULL;
  priv-&gt;connection = NULL;
  priv-&gt;request_manager = NULL;
}
static void
infc_session_proxy_dispose(GObject* object)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  proxy = INFC_SESSION_PROXY(object);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  if(priv-&gt;connection)
    infc_session_proxy_unsubscribe_connection(proxy);
  if(priv-&gt;session != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;session),
      G_CALLBACK(infc_session_proxy_session_close_cb),
      proxy
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;session),
      G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
      proxy
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;session),
      G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
      proxy
    );
    g_object_unref(G_OBJECT(priv-&gt;session));
    priv-&gt;session = NULL;
  }
  g_assert(priv-&gt;request_manager == NULL);
  G_OBJECT_CLASS(infc_session_proxy_parent_class)-&gt;dispose(object);
}
static void
infc_session_proxy_set_property(GObject* object,
                                guint prop_id,
                                const GValue* value,
                                GParamSpec* pspec)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  proxy = INFC_SESSION_PROXY(object);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  switch(prop_id)
  {
  case PROP_SESSION:
    g_assert(priv-&gt;session == NULL);     priv-&gt;session = INF_SESSION(g_value_dup_object(value));
    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      "close",
      G_CALLBACK(infc_session_proxy_session_close_cb),
      proxy
    );
    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      "synchronization-complete",
      G_CALLBACK(infc_session_proxy_session_synchronization_complete_cb),
      proxy
    );
    g_signal_connect(
      G_OBJECT(priv-&gt;session),
      "synchronization-failed",
      G_CALLBACK(infc_session_proxy_session_synchronization_failed_cb),
      proxy
    );
<a name="0"></a>
    break;
  case PROP_SUBSCRIPTION_GROUP:
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  case PROP_CONNECTION:
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
infc_session_proxy_get_property(GObject* object,
                                guint prop_id,
                                GValue* value,
                                GParamSpec* pspec)
{
  InfcSessionProxy* session;
  InfcSessionProxyPrivate* priv;
  session = INFC_SESSION_PROXY(object);
  priv = INFC_SESSION_PROXY_PRIVATE(session);
  switch(prop_id)
  {
  case PROP_SESSION:
    g_value_set_object(value, G_OBJECT(priv-&gt;session));
    break;</b></font>
  case PROP_SUBSCRIPTION_GROUP:
    g_value_set_boxed(value, priv-&gt;subscription_group);
    break;
  case PROP_CONNECTION:
    g_value_set_object(value, G_OBJECT(priv-&gt;connection));
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static GError*
infc_session_proxy_translate_error_impl(InfcSessionProxy* proxy,
                                        GQuark domain,
                                        guint code)
{
  GError* error;
  const gchar* error_msg;
  if(domain == inf_request_error_quark())
    error_msg = inf_request_strerror(code);
  else if(domain == inf_user_error_quark())
    error_msg = inf_user_strerror(code);
  else
    error_msg = NULL;
  error = NULL;
  if(error_msg != NULL)
  {
    g_set_error_literal(&amp;error, domain, code, error_msg);
  }
  else
  {
    g_set_error(
      &amp;error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_UNKNOWN_DOMAIN,
      _("Error comes from unknown error domain \"%s\" (code %u)"),
      g_quark_to_string(domain),
      (guint)code
    );
  }
  return error;
}
static gboolean
infc_session_proxy_handle_user_join(InfcSessionProxy* proxy,
                                    InfXmlConnection* connection,
                                    xmlNodePtr xml,
                                    GError** error)
{
  InfcSessionProxyPrivate* priv;
  InfSessionClass* session_class;
  InfcRequest* request;
  GArray* array;
  InfUser* user;
  GParameter* param;
  gboolean result;
  guint i;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "user-join",
    xml,
    NULL
  );
  array = session_class-&gt;get_xml_user_props(priv-&gt;session, connection, xml);
  param = inf_session_get_user_property(array, "flags");
  g_assert(!G_IS_VALUE(&amp;param-&gt;value)); 
  g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
  if(request != NULL)
    g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
  else
    g_value_set_flags(&amp;param-&gt;value, 0);
  param = inf_session_get_user_property(array, "connection");
  if(!G_IS_VALUE(&amp;param-&gt;value))
  {
    g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
    g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));
  }
  result = session_class-&gt;validate_user_props(
    priv-&gt;session,
    (const GParameter*)array-&gt;data,
    array-&gt;len,
    NULL,
    error
  );
  if(result == TRUE)
  {
    user = inf_session_add_user(
      priv-&gt;session,
      (const GParameter*)array-&gt;data,
      array-&gt;len
    );
    g_assert(user != NULL);
  }
  for(i = 0; i &lt; array-&gt;len; ++ i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);
  if(user != NULL)
  {
    if(request != NULL)
    {
      infc_request_manager_finish_request(
        priv-&gt;request_manager,
        request,
        inf_request_result_make_join_user(INF_SESSION_PROXY(proxy), user)
      );
    }
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}
static gboolean
infc_session_proxy_handle_user_rejoin(InfcSessionProxy* proxy,
                                      InfXmlConnection* connection,
                                      xmlNodePtr xml,
                                      GError** error)
{
  InfcSessionProxyPrivate* priv;
  InfSessionClass* session_class;
  InfcRequest* request;
  GArray* array;
  InfUser* user;
  const GParameter* idparam;
  GParameter* param;
  guint id;
  gboolean result;
  guint i;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
  request = infc_request_manager_get_request_by_xml(
    priv-&gt;request_manager,
    "user-join",
    xml,
    NULL
  );
  array = session_class-&gt;get_xml_user_props(priv-&gt;session, connection, xml);
  idparam = inf_session_lookup_user_property(
    (const GParameter*)array-&gt;data,
    array-&gt;len,
    "id"
  );
  if(idparam == NULL)
  {
    g_set_error_literal(
      error,
      inf_request_error_quark(),
      INF_REQUEST_ERROR_NO_SUCH_ATTRIBUTE,
      _("Request does not contain required attribute \"id\"")
    );
    goto error;
  }
  id = g_value_get_uint(&amp;idparam-&gt;value);
  user = inf_user_table_lookup_user_by_id(
    inf_session_get_user_table(priv-&gt;session),
    id
  );
  if(user == NULL)
  {
    g_set_error(
      error,
      inf_user_error_quark(),
      INF_USER_ERROR_NO_SUCH_USER,
      _("No such user with ID %u"),
      id
    );
    goto error;
  }
  param = inf_session_get_user_property(array, "flags");
  g_assert(!G_IS_VALUE(&amp;param-&gt;value)); 
  g_value_init(&amp;param-&gt;value, INF_TYPE_USER_FLAGS);
  if(request != NULL)
    g_value_set_flags(&amp;param-&gt;value, INF_USER_LOCAL);
  else
    g_value_set_flags(&amp;param-&gt;value, 0);
  param = inf_session_get_user_property(array, "connection");
  if(!G_IS_VALUE(&amp;param-&gt;value))
  {
    g_value_init(&amp;param-&gt;value, INF_TYPE_XML_CONNECTION);
    g_value_set_object(&amp;param-&gt;value, G_OBJECT(connection));
  }
  result = session_class-&gt;validate_user_props(
    priv-&gt;session,
    (const GParameter*)array-&gt;data,
    array-&gt;len,
    user,
    error
  );
  if(result == FALSE)
    goto error;
  g_object_freeze_notify(G_OBJECT(user));
  for(i = 0; i &lt; array-&gt;len; ++ i)
  {
    param = &amp;g_array_index(array, GParameter, i);
    if(strcmp(param-&gt;name, "id") != 0)
      g_object_set_property(G_OBJECT(user), param-&gt;name, &amp;param-&gt;value);
  }
  g_object_thaw_notify(G_OBJECT(user));
  for(i = 0; i &lt; array-&gt;len; ++ i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);
  if(request != NULL)
  {
    infc_request_manager_finish_request(
      priv-&gt;request_manager,
      request,
      inf_request_result_make_join_user(INF_SESSION_PROXY(proxy), user)
    );
  }
  return TRUE;
error:
  for(i = 0; i &lt; array-&gt;len; ++ i)
    g_value_unset(&amp;g_array_index(array, GParameter, i).value);
  g_array_free(array, TRUE);
  return FALSE;
}
static gboolean
infc_session_proxy_handle_request_failed(InfcSessionProxy* proxy,
                                         InfXmlConnection* connection,
                                         xmlNodePtr xml,
                                         GError** error)
{
  InfcSessionProxyPrivate* priv;
  InfcSessionProxyClass* proxy_class;
  xmlChar* domain;
  gboolean has_code;
  guint code;
  GError* req_error;
  InfcRequest* request;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  proxy_class = INFC_SESSION_PROXY_GET_CLASS(proxy);
  has_code = inf_xml_util_get_attribute_uint_required(
    xml,
    "code",
    &amp;code,
    error
  );
  if(has_code == FALSE) return FALSE;
  domain = inf_xml_util_get_attribute_required(xml, "domain", error);
  if(domain == NULL) return FALSE;
  req_error = NULL;
  request = infc_request_manager_get_request_by_xml_required(
    priv-&gt;request_manager,
    NULL,
    xml,
    error
  );
  if(request == NULL) return FALSE;
  g_assert(proxy_class-&gt;translate_error != NULL);
  req_error = proxy_class-&gt;translate_error(
    proxy,
    g_quark_from_string((const gchar*)domain),
    code
  );
  infc_request_manager_fail_request(
    priv-&gt;request_manager,
    request,
    req_error
  );
  g_error_free(req_error);
  xmlFree(domain);
  return TRUE;
}
static gboolean
infc_session_proxy_handle_session_close(InfcSessionProxy* proxy,
                                        InfXmlConnection* connection,
                                        xmlNodePtr xml,
                                        GError** error)
{
  InfcSessionProxyPrivate* priv;
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_assert(priv-&gt;connection != NULL);
  infc_session_proxy_release_connection(proxy);
  return TRUE;
}
static void
infc_session_proxy_communication_object_sent(InfCommunicationObject* object,
                                             InfXmlConnection* connection,
                                             xmlNodePtr node)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  proxy = INFC_SESSION_PROXY(object);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_assert(priv-&gt;session != NULL);
  inf_communication_object_sent(
    INF_COMMUNICATION_OBJECT(priv-&gt;session),
    connection,
    node
  );
}
static void
infc_session_proxy_communication_object_enqueued(InfCommunicationObject* obj,
                                                 InfXmlConnection* connection,
                                                 xmlNodePtr node)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  proxy = INFC_SESSION_PROXY(obj);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_assert(priv-&gt;session != NULL);
  inf_communication_object_enqueued(
    INF_COMMUNICATION_OBJECT(priv-&gt;session),
    connection,
    node
  );
}
static InfCommunicationScope
infc_session_proxy_communication_object_received(InfCommunicationObject* obj,
                                                 InfXmlConnection* connection,
                                                 xmlNodePtr node)
{
  InfcSessionProxy* proxy;
  InfcSessionProxyPrivate* priv;
  InfcSessionProxyClass* proxy_class;
  InfSessionSyncStatus status;
  GError* local_error;
  InfcRequest* request;
  GError* seq_error;
  proxy = INFC_SESSION_PROXY(obj);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  proxy_class = INFC_SESSION_PROXY_GET_CLASS(proxy);
  status = inf_session_get_synchronization_status(priv-&gt;session, connection);
  local_error = NULL;
  g_assert(status != INF_SESSION_SYNC_NONE || priv-&gt;connection == connection);
  g_assert(inf_session_get_status(priv-&gt;session) != INF_SESSION_CLOSED);
  if(status != INF_SESSION_SYNC_NONE)
  {
    return inf_communication_object_received(
      INF_COMMUNICATION_OBJECT(priv-&gt;session),
      connection,
      node
    );
  }
  else
  {
    if(strcmp((const char*)node-&gt;name, "user-join") == 0)
    {
      infc_session_proxy_handle_user_join(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else if(strcmp((const char*)node-&gt;name, "user-rejoin") == 0)
    {
      infc_session_proxy_handle_user_rejoin(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else if(strcmp((const char*)node-&gt;name, "request-failed") == 0)
    {
      infc_session_proxy_handle_request_failed(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else if(strcmp((const char*)node-&gt;name, "session-close") == 0)
    {
      infc_session_proxy_handle_session_close(
        proxy,
        connection,
        node,
        &amp;local_error
      );
    }
    else
    {
      return inf_communication_object_received(
        INF_COMMUNICATION_OBJECT(priv-&gt;session),
        connection,
        node
      );
    }
  }
  if(local_error != NULL)
  {
    request = infc_request_manager_get_request_by_xml(
      priv-&gt;request_manager,
      NULL,
      node,
      NULL
    );
    if(request != NULL)
    {
      seq_error = NULL;
      g_set_error(
        &amp;seq_error,
        inf_request_error_quark(),
        INF_REQUEST_ERROR_REPLY_UNPROCESSED,
        _("Server reply could not be processed: %s"),
        local_error-&gt;message
      );
      infc_request_manager_fail_request(
        priv-&gt;request_manager,
        request,
        seq_error
      );
      g_error_free(seq_error);
    }
    g_error_free(local_error);
  }
  return INF_COMMUNICATION_SCOPE_PTP;
}
InfRequest*
infc_session_proxy_session_proxy_join_user(InfSessionProxy* proxy,
                                           guint n_params,
                                           const GParameter* params,
                                           InfRequestFunc func,
                                           gpointer user_data)
{
  InfcSessionProxyPrivate* priv;
  InfSessionClass* session_class;
  InfSessionStatus status;
  InfcRequest* request;
  xmlNodePtr xml;
  g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
  g_return_val_if_fail(n_params == 0 || params != NULL, NULL);
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_return_val_if_fail(priv-&gt;session != NULL, NULL);
  session_class = INF_SESSION_GET_CLASS(priv-&gt;session);
  g_object_get(G_OBJECT(priv-&gt;session), "status", &amp;status, NULL);
  g_return_val_if_fail(status == INF_SESSION_RUNNING, NULL);
  g_return_val_if_fail(priv-&gt;connection != NULL, NULL);
  g_return_val_if_fail(priv-&gt;request_manager != NULL, NULL);
  request = infc_request_manager_add_request(
    priv-&gt;request_manager,
    INFC_TYPE_REQUEST,
    "user-join",
    G_CALLBACK(func),
    user_data,
    NULL
  );
  xml = infc_session_proxy_request_to_xml(INFC_REQUEST(request));
  g_assert(session_class-&gt;set_xml_user_props != NULL);
  session_class-&gt;set_xml_user_props(priv-&gt;session, params, n_params, xml);
  inf_communication_group_send_message(
    INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
    priv-&gt;connection,
    xml
  );
  return INF_REQUEST(request);
}
<a name="1"></a>
static void
infc_session_proxy_class_init(InfcSessionProxyClass* proxy_class)
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(proxy_class);
  object_class-&gt;dispose = infc_session_proxy_dispose;
  object_class-&gt;set_property = infc_session_proxy_set_property;
  object_class-&gt;get_property = infc_session_proxy_get_property;
  proxy_class-&gt;translate_error = infc_session_proxy_translate_error_impl;
  g_object_class_install_property(
    object_class,
    PROP_SUBSCRIPTION_GROUP,
    g_param_spec_object(
      "subscription-group",
      "Subscription group",
      "The communication group of subscribed connections",
      INF_COMMUNICATION_TYPE_JOINED_GROUP,
      G_PARAM_READABLE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CONNECTION,
    g_param_spec_object(
      "connection",
      "Subscription connection",
      "The connection with which the session communicates with the server",
      INF_TYPE_XML_CONNECTION,
      G_PARAM_READABLE
    )
  );
  g_object_class_override_property(object_class, PROP_SESSION, "session");
}
static void
infc_session_proxy_communication_object_iface_init(
  InfCommunicationObjectInterface* iface)
{
  iface-&gt;sent = infc_session_proxy_communication_object_sent;
  iface-&gt;enqueued = infc_session_proxy_communication_object_enqueued;</b></font>
  iface-&gt;received = infc_session_proxy_communication_object_received;
}
static void
infc_session_proxy_session_proxy_iface_init(InfSessionProxyInterface* iface)
{
  iface-&gt;join_user = infc_session_proxy_session_proxy_join_user;
}
void
infc_session_proxy_set_connection(InfcSessionProxy* proxy,
                                  InfCommunicationJoinedGroup* group,
                                  InfXmlConnection* connection,
                                  guint seq_id)
{
  InfcSessionProxyPrivate* priv;
  xmlNodePtr xml;
  g_return_if_fail(INFC_IS_SESSION_PROXY(proxy));
  g_return_if_fail(connection == NULL || INF_IS_XML_CONNECTION(connection));
  g_return_if_fail(
    (group == NULL &amp;&amp; connection == NULL) ||
    (INF_COMMUNICATION_IS_JOINED_GROUP(group) &amp;&amp; connection != NULL)
  );
  priv = INFC_SESSION_PROXY_PRIVATE(proxy);
  g_return_if_fail(priv-&gt;session != NULL);
  g_object_freeze_notify(G_OBJECT(proxy));
  g_object_freeze_notify(G_OBJECT(priv-&gt;session));
  if(priv-&gt;connection != NULL)
  {
    xml = xmlNewNode(NULL, (const xmlChar*)"session-unsubscribe");
    inf_communication_group_send_message(
      INF_COMMUNICATION_GROUP(priv-&gt;subscription_group),
      priv-&gt;connection,
      xml
    );
    infc_session_proxy_release_connection(proxy);
  }
  priv-&gt;connection = connection;
  if(connection != NULL)
  {
    priv-&gt;connection = connection;
    g_object_ref(G_OBJECT(connection));
    g_signal_connect(
      G_OBJECT(connection),
      "notify::status",
      G_CALLBACK(infc_session_proxy_connection_notify_status_cb),
      proxy
    );
    priv-&gt;subscription_group = group;
    g_object_ref(priv-&gt;subscription_group);
    g_assert(priv-&gt;request_manager == NULL);
    priv-&gt;request_manager = infc_request_manager_new(seq_id);
  }
  inf_session_set_subscription_group(
    priv-&gt;session,
    INF_COMMUNICATION_GROUP(priv-&gt;subscription_group)
  );
  g_object_notify(G_OBJECT(proxy), "connection");
  g_object_notify(G_OBJECT(proxy), "subscription-group");
  g_object_thaw_notify(G_OBJECT(priv-&gt;session));
  g_object_thaw_notify(G_OBJECT(proxy));
}
InfXmlConnection*
infc_session_proxy_get_connection(InfcSessionProxy* proxy)
{
  g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
  return INFC_SESSION_PROXY_PRIVATE(proxy)-&gt;connection;
}
InfCommunicationJoinedGroup*
infc_session_proxy_get_subscription_group(InfcSessionProxy* proxy)
{
  g_return_val_if_fail(INFC_IS_SESSION_PROXY(proxy), NULL);
  return INFC_SESSION_PROXY_PRIVATE(proxy)-&gt;subscription_group;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
