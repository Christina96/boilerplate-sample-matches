
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.762891141472014%, Tokens: 9</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_timer.h</h3>
            <pre><code>1  #ifndef NRF_TIMER_H__
2  #define NRF_TIMER_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define TIMER_MAX_SIZE(id)  NRFX_CONCAT_3(TIMER, id, _MAX_SIZE)
8  #define TIMER_BIT_WIDTH_MAX(id, bit_width) \
9      (TIMER_MAX_SIZE(id) == 8   ? (bit_width == NRF_TIMER_BIT_WIDTH_8)  :  \
10      (TIMER_MAX_SIZE(id) == 16  ? (bit_width == NRF_TIMER_BIT_WIDTH_8)  || \
11                                   (bit_width == NRF_TIMER_BIT_WIDTH_16)  : \
12      (TIMER_MAX_SIZE(id) == 24  ? (bit_width == NRF_TIMER_BIT_WIDTH_8)  || \
13                                   (bit_width == NRF_TIMER_BIT_WIDTH_16) || \
14                                   (bit_width == NRF_TIMER_BIT_WIDTH_24) :  \
15      (TIMER_MAX_SIZE(id) == 32  ? (bit_width == NRF_TIMER_BIT_WIDTH_8)  || \
16                                   (bit_width == NRF_TIMER_BIT_WIDTH_16) || \
17                                   (bit_width == NRF_TIMER_BIT_WIDTH_24) || \
18                                   (bit_width == NRF_TIMER_BIT_WIDTH_32) :  \
19      false))))
20  #if (TIMER_COUNT > 3) || defined(__NRFX_DOXYGEN__)
21  #define NRF_TIMER_IS_BIT_WIDTH_VALID(p_reg, bit_width) (                \
22         ((p_reg == NRF_TIMER0) && (TIMER_BIT_WIDTH_MAX(0, bit_width)))   \
23      || ((p_reg == NRF_TIMER1) && (TIMER_BIT_WIDTH_MAX(1, bit_width)))   \
24      || ((p_reg == NRF_TIMER2) && (TIMER_BIT_WIDTH_MAX(2, bit_width)))   \
25      || ((p_reg == NRF_TIMER3) && (TIMER_BIT_WIDTH_MAX(3, bit_width)))   \
26      || ((p_reg == NRF_TIMER4) && (TIMER_BIT_WIDTH_MAX(4, bit_width))) )
27  #else
28  #define NRF_TIMER_IS_BIT_WIDTH_VALID(p_reg, bit_width) (             \
29         ((p_reg == NRF_TIMER0) && TIMER_BIT_WIDTH_MAX(0, bit_width))  \
30      || ((p_reg == NRF_TIMER1) && TIMER_BIT_WIDTH_MAX(1, bit_width))  \
31      || ((p_reg == NRF_TIMER2) && TIMER_BIT_WIDTH_MAX(2, bit_width)) )
32  #endif
33  #define NRF_TIMER_CC_CHANNEL_COUNT(id)  NRFX_CONCAT_3(TIMER, id, _CC_NUM)
34  typedef enum
35  {
36      NRF_TIMER_TASK_START    = offsetof(NRF_TIMER_Type, TASKS_START),      
37      NRF_TIMER_TASK_STOP     = offsetof(NRF_TIMER_Type, TASKS_STOP),       
38      NRF_TIMER_TASK_COUNT    = offsetof(NRF_TIMER_Type, TASKS_COUNT),      
39      NRF_TIMER_TASK_CLEAR    = offsetof(NRF_TIMER_Type, TASKS_CLEAR),      
40      NRF_TIMER_TASK_SHUTDOWN = offsetof(NRF_TIMER_Type, TASKS_SHUTDOWN),   
41      NRF_TIMER_TASK_CAPTURE0 = offsetof(NRF_TIMER_Type, TASKS_CAPTURE[0]), 
42      NRF_TIMER_TASK_CAPTURE1 = offsetof(NRF_TIMER_Type, TASKS_CAPTURE[1]), 
43      NRF_TIMER_TASK_CAPTURE2 = offsetof(NRF_TIMER_Type, TASKS_CAPTURE[2]), 
44      NRF_TIMER_TASK_CAPTURE3 = offsetof(NRF_TIMER_Type, TASKS_CAPTURE[3]), 
45  #if defined(TIMER_INTENSET_COMPARE4_Msk) || defined(__NRFX_DOXYGEN__)
46      NRF_TIMER_TASK_CAPTURE4 = offsetof(NRF_TIMER_Type, TASKS_CAPTURE[4]), 
47  #endif
48  #if defined(TIMER_INTENSET_COMPARE5_Msk) || defined(__NRFX_DOXYGEN__)
49      NRF_TIMER_TASK_CAPTURE5 = offsetof(NRF_TIMER_Type, TASKS_CAPTURE[5]), 
50  #endif
51  #if defined(TIMER_INTENSET_COMPARE6_Msk) || defined(__NRFX_DOXYGEN__)
52      NRF_TIMER_TASK_CAPTURE6 = offsetof(NRF_TIMER_Type, TASKS_CAPTURE[6]), 
53  #endif
54  #if defined(TIMER_INTENSET_COMPARE7_Msk) || defined(__NRFX_DOXYGEN__)
55      NRF_TIMER_TASK_CAPTURE7 = offsetof(NRF_TIMER_Type, TASKS_CAPTURE[7]), 
56  #endif
57  } nrf_timer_task_t;
58  typedef enum
59  {
60      NRF_TIMER_EVENT_COMPARE0 = offsetof(NRF_TIMER_Type, EVENTS_COMPARE[0]), 
61      NRF_TIMER_EVENT_COMPARE1 = offsetof(NRF_TIMER_Type, EVENTS_COMPARE[1]), 
62      NRF_TIMER_EVENT_COMPARE2 = offsetof(NRF_TIMER_Type, EVENTS_COMPARE[2]), 
63      NRF_TIMER_EVENT_COMPARE3 = offsetof(NRF_TIMER_Type, EVENTS_COMPARE[3]), 
64  #if defined(TIMER_INTENSET_COMPARE4_Msk) || defined(__NRFX_DOXYGEN__)
65      NRF_TIMER_EVENT_COMPARE4 = offsetof(NRF_TIMER_Type, EVENTS_COMPARE[4]), 
66  #endif
67  #if defined(TIMER_INTENSET_COMPARE5_Msk) || defined(__NRFX_DOXYGEN__)
68      NRF_TIMER_EVENT_COMPARE5 = offsetof(NRF_TIMER_Type, EVENTS_COMPARE[5]), 
69  #endif
70  #if defined(TIMER_INTENSET_COMPARE6_Msk) || defined(__NRFX_DOXYGEN__)
71      NRF_TIMER_EVENT_COMPARE6 = offsetof(NRF_TIMER_Type, EVENTS_COMPARE[6]), 
72  #endif
73  #if defined(TIMER_INTENSET_COMPARE7_Msk) || defined(__NRFX_DOXYGEN__)
74      NRF_TIMER_EVENT_COMPARE7 = offsetof(NRF_TIMER_Type, EVENTS_COMPARE[7]), 
75  #endif
76  } nrf_timer_event_t;
77  typedef enum
78  {
<span onclick='openModal()' class='match'>79      NRF_TIMER_SHORT_COMPARE0_STOP_MASK = TIMER_SHORTS_COMPARE0_STOP_Msk,   
80      NRF_TIMER_SHORT_COMPARE1_STOP_MASK = TIMER_SHORTS_COMPARE1_STOP_Msk,   
81      NRF_TIMER_SHORT_COMPARE2_STOP_MASK = TIMER_SHORTS_COMPARE2_STOP_Msk,   
82      NRF_TIMER_SHORT_COMPARE3_STOP_MASK = TIMER_SHORTS_COMPARE3_STOP_Msk,   
83  #if defined(TIMER_INTENSET_COMPARE4_Msk) || defined(__NRFX_DOXYGEN__)
84      NRF_TIMER_SHORT_COMPARE4_STOP_MASK = TIMER_SHORTS_COMPARE4_STOP_Msk,   
85  #endif
86  #if defined(TIMER_INTENSET_COMPARE5_Msk) || defined(__NRFX_DOXYGEN__)
87      NRF_TIMER_SHORT_COMPARE5_STOP_MASK = TIMER_SHORTS_COMPARE5_STOP_Msk,   
88  #endif
89      NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK = TIMER_SHORTS_COMPARE0_CLEAR_Msk, 
90      NRF_TIMER_SHORT_COMPARE1_CLEAR_MASK = TIMER_SHORTS_COMPARE1_CLEAR_Msk, 
91      NRF_TIMER_SHORT_COMPARE2_CLEAR_MASK = TIMER_SHORTS_COMPARE2_CLEAR_Msk, 
</span>92      NRF_TIMER_SHORT_COMPARE3_CLEAR_MASK = TIMER_SHORTS_COMPARE3_CLEAR_Msk, 
93  #if defined(TIMER_INTENSET_COMPARE4_Msk) || defined(__NRFX_DOXYGEN__)
94      NRF_TIMER_SHORT_COMPARE4_CLEAR_MASK = TIMER_SHORTS_COMPARE4_CLEAR_Msk, 
95  #endif
96  #if defined(TIMER_INTENSET_COMPARE5_Msk) || defined(__NRFX_DOXYGEN__)
97      NRF_TIMER_SHORT_COMPARE5_CLEAR_MASK = TIMER_SHORTS_COMPARE5_CLEAR_Msk, 
98  #endif
99  } nrf_timer_short_mask_t;
100  typedef enum
101  {
102      NRF_TIMER_MODE_TIMER             = TIMER_MODE_MODE_Timer,           
103      NRF_TIMER_MODE_COUNTER           = TIMER_MODE_MODE_Counter,         
104  #if defined(TIMER_MODE_MODE_LowPowerCounter) || defined(__NRFX_DOXYGEN__)
105      NRF_TIMER_MODE_LOW_POWER_COUNTER = TIMER_MODE_MODE_LowPowerCounter, 
106  #endif
107  } nrf_timer_mode_t;
108  typedef enum
109  {
110      NRF_TIMER_BIT_WIDTH_8  = TIMER_BITMODE_BITMODE_08Bit, 
111      NRF_TIMER_BIT_WIDTH_16 = TIMER_BITMODE_BITMODE_16Bit, 
112      NRF_TIMER_BIT_WIDTH_24 = TIMER_BITMODE_BITMODE_24Bit, 
113      NRF_TIMER_BIT_WIDTH_32 = TIMER_BITMODE_BITMODE_32Bit  
114  } nrf_timer_bit_width_t;
115  typedef enum
116  {
117      NRF_TIMER_FREQ_16MHz = 0, 
118      NRF_TIMER_FREQ_8MHz,      
119      NRF_TIMER_FREQ_4MHz,      
120      NRF_TIMER_FREQ_2MHz,      
121      NRF_TIMER_FREQ_1MHz,      
122      NRF_TIMER_FREQ_500kHz,    
123      NRF_TIMER_FREQ_250kHz,    
124      NRF_TIMER_FREQ_125kHz,    
125      NRF_TIMER_FREQ_62500Hz,   
126      NRF_TIMER_FREQ_31250Hz    
127  } nrf_timer_frequency_t;
128  typedef enum
129  {
130      NRF_TIMER_CC_CHANNEL0 = 0, 
131      NRF_TIMER_CC_CHANNEL1,     
132      NRF_TIMER_CC_CHANNEL2,     
133      NRF_TIMER_CC_CHANNEL3,     
134  #if defined(TIMER_INTENSET_COMPARE4_Msk) || defined(__NRFX_DOXYGEN__)
135      NRF_TIMER_CC_CHANNEL4,     
136  #endif
137  #if defined(TIMER_INTENSET_COMPARE5_Msk) || defined(__NRFX_DOXYGEN__)
138      NRF_TIMER_CC_CHANNEL5,     
139  #endif
140  } nrf_timer_cc_channel_t;
141  typedef enum
142  {
143      NRF_TIMER_INT_COMPARE0_MASK = TIMER_INTENSET_COMPARE0_Msk, 
144      NRF_TIMER_INT_COMPARE1_MASK = TIMER_INTENSET_COMPARE1_Msk, 
145      NRF_TIMER_INT_COMPARE2_MASK = TIMER_INTENSET_COMPARE2_Msk, 
146      NRF_TIMER_INT_COMPARE3_MASK = TIMER_INTENSET_COMPARE3_Msk, 
147  #if defined(TIMER_INTENSET_COMPARE4_Msk) || defined(__NRFX_DOXYGEN__)
148      NRF_TIMER_INT_COMPARE4_MASK = TIMER_INTENSET_COMPARE4_Msk, 
149  #endif
150  #if defined(TIMER_INTENSET_COMPARE5_Msk) || defined(__NRFX_DOXYGEN__)
151      NRF_TIMER_INT_COMPARE5_MASK = TIMER_INTENSET_COMPARE5_Msk, 
152  #endif
153  } nrf_timer_int_mask_t;
154  NRF_STATIC_INLINE void nrf_timer_task_trigger(NRF_TIMER_Type * p_reg,
155                                                nrf_timer_task_t task);
156  NRF_STATIC_INLINE uint32_t nrf_timer_task_address_get(NRF_TIMER_Type const * p_reg,
157                                                        nrf_timer_task_t       task);
158  NRF_STATIC_INLINE void nrf_timer_event_clear(NRF_TIMER_Type *  p_reg,
159                                               nrf_timer_event_t event);
160  NRF_STATIC_INLINE bool nrf_timer_event_check(NRF_TIMER_Type const * p_reg,
161                                               nrf_timer_event_t      event);
162  NRF_STATIC_INLINE uint32_t nrf_timer_event_address_get(NRF_TIMER_Type const * p_reg,
163                                                         nrf_timer_event_t      event);
164  NRF_STATIC_INLINE void nrf_timer_shorts_enable(NRF_TIMER_Type * p_reg,
165                                                 uint32_t         mask);
166  NRF_STATIC_INLINE void nrf_timer_shorts_disable(NRF_TIMER_Type * p_reg,
167                                                  uint32_t         mask);
168  NRF_STATIC_INLINE void nrf_timer_int_enable(NRF_TIMER_Type * p_reg,
169                                              uint32_t         mask);
170  NRF_STATIC_INLINE void nrf_timer_int_disable(NRF_TIMER_Type * p_reg,
171                                               uint32_t         mask);
172  NRF_STATIC_INLINE uint32_t nrf_timer_int_enable_check(NRF_TIMER_Type const * p_reg, uint32_t mask);
173  #if defined(DPPI_PRESENT) || defined(__NRFX_DOXYGEN__)
174  NRF_STATIC_INLINE void nrf_timer_subscribe_set(NRF_TIMER_Type * p_reg,
175                                                 nrf_timer_task_t task,
176                                                 uint8_t          channel);
177  NRF_STATIC_INLINE void nrf_timer_subscribe_clear(NRF_TIMER_Type * p_reg,
178                                                   nrf_timer_task_t task);
179  NRF_STATIC_INLINE void nrf_timer_publish_set(NRF_TIMER_Type *  p_reg,
180                                               nrf_timer_event_t event,
181                                               uint8_t           channel);
182  NRF_STATIC_INLINE void nrf_timer_publish_clear(NRF_TIMER_Type *  p_reg,
183                                                 nrf_timer_event_t event);
184  #endif 
185  NRF_STATIC_INLINE void nrf_timer_mode_set(NRF_TIMER_Type * p_reg,
186                                            nrf_timer_mode_t mode);
187  NRF_STATIC_INLINE nrf_timer_mode_t nrf_timer_mode_get(NRF_TIMER_Type const * p_reg);
188  NRF_STATIC_INLINE void nrf_timer_bit_width_set(NRF_TIMER_Type *      p_reg,
189                                                 nrf_timer_bit_width_t bit_width);
190  NRF_STATIC_INLINE nrf_timer_bit_width_t nrf_timer_bit_width_get(NRF_TIMER_Type const * p_reg);
191  NRF_STATIC_INLINE void nrf_timer_frequency_set(NRF_TIMER_Type *      p_reg,
192                                                 nrf_timer_frequency_t frequency);
193  NRF_STATIC_INLINE nrf_timer_frequency_t nrf_timer_frequency_get(NRF_TIMER_Type const * p_reg);
194  NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
195                                          nrf_timer_cc_channel_t cc_channel,
196                                          uint32_t               cc_value);
197  NRF_STATIC_INLINE uint32_t nrf_timer_cc_get(NRF_TIMER_Type const * p_reg,
198                                              nrf_timer_cc_channel_t cc_channel);
199  NRF_STATIC_INLINE nrf_timer_task_t nrf_timer_capture_task_get(uint32_t channel);
200  NRF_STATIC_INLINE nrf_timer_event_t nrf_timer_compare_event_get(uint32_t channel);
201  NRF_STATIC_INLINE nrf_timer_int_mask_t nrf_timer_compare_int_get(uint32_t channel);
202  NRF_STATIC_INLINE uint32_t nrf_timer_us_to_ticks(uint32_t              time_us,
203                                                   nrf_timer_frequency_t frequency);
204  NRF_STATIC_INLINE uint32_t nrf_timer_ms_to_ticks(uint32_t              time_ms,
205                                                   nrf_timer_frequency_t frequency);
206  #if defined(TIMER_ONESHOTEN_ONESHOTEN_Msk) || defined(__NRFX_DOXYGEN__)
207  NRF_STATIC_INLINE void nrf_timer_one_shot_enable(NRF_TIMER_Type *       p_reg,
208                                                   nrf_timer_cc_channel_t cc_channel);
209  NRF_STATIC_INLINE void nrf_timer_one_shot_disable(NRF_TIMER_Type *       p_reg,
210                                                    nrf_timer_cc_channel_t cc_channel);
211  #endif 
212  #ifndef NRF_DECLARE_ONLY
213  NRF_STATIC_INLINE void nrf_timer_task_trigger(NRF_TIMER_Type * p_reg,
214                                                nrf_timer_task_t task)
215  {
216      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
217  }
218  NRF_STATIC_INLINE uint32_t nrf_timer_task_address_get(NRF_TIMER_Type const * p_reg,
219                                                        nrf_timer_task_t       task)
220  {
221      return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
222  }
223  NRF_STATIC_INLINE void nrf_timer_event_clear(NRF_TIMER_Type *  p_reg,
224                                               nrf_timer_event_t event)
225  {
226      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
227  #if __CORTEX_M == 0x04
228      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
229      (void)dummy;
230  #endif
231  }
232  NRF_STATIC_INLINE bool nrf_timer_event_check(NRF_TIMER_Type const * p_reg,
233                                               nrf_timer_event_t      event)
234  {
235      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
236  }
237  NRF_STATIC_INLINE uint32_t nrf_timer_event_address_get(NRF_TIMER_Type const * p_reg,
238                                                         nrf_timer_event_t      event)
239  {
240      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
241  }
242  NRF_STATIC_INLINE void nrf_timer_shorts_enable(NRF_TIMER_Type * p_reg,
243                                                 uint32_t         mask)
244  {
245      p_reg->SHORTS |= mask;
246  }
247  NRF_STATIC_INLINE void nrf_timer_shorts_disable(NRF_TIMER_Type * p_reg,
248                                                  uint32_t         mask)
249  {
250      p_reg->SHORTS &= ~(mask);
251  }
252  NRF_STATIC_INLINE void nrf_timer_int_enable(NRF_TIMER_Type * p_reg,
253                                              uint32_t         mask)
254  {
255      p_reg->INTENSET = mask;
256  }
257  NRF_STATIC_INLINE void nrf_timer_int_disable(NRF_TIMER_Type * p_reg,
258                                               uint32_t         mask)
259  {
260      p_reg->INTENCLR = mask;
261  }
262  NRF_STATIC_INLINE uint32_t nrf_timer_int_enable_check(NRF_TIMER_Type const * p_reg, uint32_t mask)
263  {
264      return p_reg->INTENSET & mask;
265  }
266  #if defined(DPPI_PRESENT)
267  NRF_STATIC_INLINE void nrf_timer_subscribe_set(NRF_TIMER_Type * p_reg,
268                                                 nrf_timer_task_t task,
269                                                 uint8_t          channel)
270  {
271      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) =
272              ((uint32_t)channel | TIMER_SUBSCRIBE_START_EN_Msk);
273  }
274  NRF_STATIC_INLINE void nrf_timer_subscribe_clear(NRF_TIMER_Type * p_reg,
275                                                   nrf_timer_task_t task)
276  {
277      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) task + 0x80uL)) = 0;
278  }
279  NRF_STATIC_INLINE void nrf_timer_publish_set(NRF_TIMER_Type *  p_reg,
280                                               nrf_timer_event_t event,
281                                               uint8_t           channel)
282  {
283      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) =
284              ((uint32_t)channel | TIMER_PUBLISH_COMPARE_EN_Msk);
285  }
286  NRF_STATIC_INLINE void nrf_timer_publish_clear(NRF_TIMER_Type *  p_reg,
287                                                 nrf_timer_event_t event)
288  {
289      *((volatile uint32_t *) ((uint8_t *) p_reg + (uint32_t) event + 0x80uL)) = 0;
290  }
291  #endif 
292  NRF_STATIC_INLINE void nrf_timer_mode_set(NRF_TIMER_Type * p_reg,
293                                            nrf_timer_mode_t mode)
294  {
295      p_reg->MODE = (p_reg->MODE & ~TIMER_MODE_MODE_Msk) |
296                      ((mode << TIMER_MODE_MODE_Pos) & TIMER_MODE_MODE_Msk);
297  }
298  NRF_STATIC_INLINE nrf_timer_mode_t nrf_timer_mode_get(NRF_TIMER_Type const * p_reg)
299  {
300      return (nrf_timer_mode_t)(p_reg->MODE);
301  }
302  NRF_STATIC_INLINE void nrf_timer_bit_width_set(NRF_TIMER_Type *      p_reg,
303                                                 nrf_timer_bit_width_t bit_width)
304  {
305      p_reg->BITMODE = (p_reg->BITMODE & ~TIMER_BITMODE_BITMODE_Msk) |
306                         ((bit_width << TIMER_BITMODE_BITMODE_Pos) &
307                              TIMER_BITMODE_BITMODE_Msk);
308  }
309  NRF_STATIC_INLINE nrf_timer_bit_width_t nrf_timer_bit_width_get(NRF_TIMER_Type const * p_reg)
310  {
311      return (nrf_timer_bit_width_t)(p_reg->BITMODE);
312  }
313  NRF_STATIC_INLINE void nrf_timer_frequency_set(NRF_TIMER_Type *      p_reg,
314                                                 nrf_timer_frequency_t frequency)
315  {
316      p_reg->PRESCALER = (p_reg->PRESCALER & ~TIMER_PRESCALER_PRESCALER_Msk) |
317                           ((frequency << TIMER_PRESCALER_PRESCALER_Pos) &
318                                TIMER_PRESCALER_PRESCALER_Msk);
319  }
320  NRF_STATIC_INLINE nrf_timer_frequency_t nrf_timer_frequency_get(NRF_TIMER_Type const * p_reg)
321  {
322      return (nrf_timer_frequency_t)(p_reg->PRESCALER);
323  }
324  NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
325                                          nrf_timer_cc_channel_t cc_channel,
326                                          uint32_t               cc_value)
327  {
328      p_reg->CC[cc_channel] = cc_value;
329  }
330  NRF_STATIC_INLINE uint32_t nrf_timer_cc_get(NRF_TIMER_Type const * p_reg,
331                                              nrf_timer_cc_channel_t cc_channel)
332  {
333      return (uint32_t)p_reg->CC[cc_channel];
334  }
335  NRF_STATIC_INLINE nrf_timer_task_t nrf_timer_capture_task_get(uint32_t channel)
336  {
337      return (nrf_timer_task_t)NRFX_OFFSETOF(NRF_TIMER_Type, TASKS_CAPTURE[channel]);
338  }
339  NRF_STATIC_INLINE nrf_timer_event_t nrf_timer_compare_event_get(uint32_t channel)
340  {
341      return (nrf_timer_event_t)NRFX_OFFSETOF(NRF_TIMER_Type, EVENTS_COMPARE[channel]);
342  }
343  NRF_STATIC_INLINE nrf_timer_int_mask_t nrf_timer_compare_int_get(uint32_t channel)
344  {
345      return (nrf_timer_int_mask_t)
346          ((uint32_t)NRF_TIMER_INT_COMPARE0_MASK << channel);
347  }
348  NRF_STATIC_INLINE uint32_t nrf_timer_us_to_ticks(uint32_t              time_us,
349                                                   nrf_timer_frequency_t frequency)
350  {
351      uint32_t prescaler = (uint32_t)frequency;
352      uint64_t ticks = ((time_us * 16ULL) >> prescaler);
353      NRFX_ASSERT(ticks <= UINT32_MAX);
354      return (uint32_t)ticks;
355  }
356  NRF_STATIC_INLINE uint32_t nrf_timer_ms_to_ticks(uint32_t              time_ms,
357                                                   nrf_timer_frequency_t frequency)
358  {
359      uint32_t prescaler = (uint32_t)frequency;
360      uint64_t ticks = ((time_ms * 16000ULL) >> prescaler);
361      NRFX_ASSERT(ticks <= UINT32_MAX);
362      return (uint32_t)ticks;
363  }
364  #if defined(TIMER_ONESHOTEN_ONESHOTEN_Msk)
365  NRF_STATIC_INLINE void nrf_timer_one_shot_enable(NRF_TIMER_Type *       p_reg,
366                                                   nrf_timer_cc_channel_t cc_channel)
367  {
368      p_reg->ONESHOTEN[cc_channel] = TIMER_ONESHOTEN_ONESHOTEN_Msk;
369  }
370  NRF_STATIC_INLINE void nrf_timer_one_shot_disable(NRF_TIMER_Type *       p_reg,
371                                                    nrf_timer_cc_channel_t cc_channel)
372  {
373      p_reg->ONESHOTEN[cc_channel] = 0;
374  }
375  #endif 
376  #endif 
377  #ifdef __cplusplus
378  }
379  #endif
380  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include "src/enc/backward_references_enc.h"
4  #include "src/enc/histogram_enc.h"
5  #include "src/enc/vp8i_enc.h"
6  #include "src/enc/vp8li_enc.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  #include "src/utils/bit_writer_utils.h"
10  #include "src/utils/huffman_encode_utils.h"
11  #include "src/utils/utils.h"
12  #include "src/webp/format_constants.h"
13  #define MAX_HUFF_IMAGE_SIZE       2600
14  static int PaletteCompareColorsForQsort(const void* p1, const void* p2) {
15    const uint32_t a = WebPMemToUint32((uint8_t*)p1);
16    const uint32_t b = WebPMemToUint32((uint8_t*)p2);
17    assert(a != b);
18    return (a < b) ? -1 : 1;
19  }
20  static WEBP_INLINE uint32_t PaletteComponentDistance(uint32_t v) {
21    return (v <= 128) ? v : (256 - v);
22  }
23  static WEBP_INLINE uint32_t PaletteColorDistance(uint32_t col1, uint32_t col2) {
24    const uint32_t diff = VP8LSubPixels(col1, col2);
25    const int kMoreWeightForRGBThanForAlpha = 9;
26    uint32_t score;
27    score =  PaletteComponentDistance((diff >>  0) & 0xff);
28    score += PaletteComponentDistance((diff >>  8) & 0xff);
29    score += PaletteComponentDistance((diff >> 16) & 0xff);
30    score *= kMoreWeightForRGBThanForAlpha;
31    score += PaletteComponentDistance((diff >> 24) & 0xff);
32    return score;
33  }
34  static WEBP_INLINE void SwapColor(uint32_t* const col1, uint32_t* const col2) {
35    const uint32_t tmp = *col1;
36    *col1 = *col2;
37    *col2 = tmp;
38  }
39  static void GreedyMinimizeDeltas(uint32_t palette[], int num_colors) {
40    uint32_t predict = 0x00000000;
41    int i, k;
42    for (i = 0; i < num_colors; ++i) {
43      int best_ix = i;
44      uint32_t best_score = ~0U;
45      for (k = i; k < num_colors; ++k) {
46        const uint32_t cur_score = PaletteColorDistance(palette[k], predict);
47        if (best_score > cur_score) {
48          best_score = cur_score;
49          best_ix = k;
50        }
51      }
52      SwapColor(&palette[best_ix], &palette[i]);
53      predict = palette[i];
54    }
55  }
56  static int PaletteHasNonMonotonousDeltas(uint32_t palette[], int num_colors) {
57    uint32_t predict = 0x000000;
58    int i;
59    uint8_t sign_found = 0x00;
60    for (i = 0; i < num_colors; ++i) {
61      const uint32_t diff = VP8LSubPixels(palette[i], predict);
62      const uint8_t rd = (diff >> 16) & 0xff;
63      const uint8_t gd = (diff >>  8) & 0xff;
64      const uint8_t bd = (diff >>  0) & 0xff;
65      if (rd != 0x00) {
66        sign_found |= (rd < 0x80) ? 1 : 2;
67      }
68      if (gd != 0x00) {
69        sign_found |= (gd < 0x80) ? 8 : 16;
70      }
71      if (bd != 0x00) {
72        sign_found |= (bd < 0x80) ? 64 : 128;
73      }
74      predict = palette[i];
75    }
76    return (sign_found & (sign_found << 1)) != 0;  
77  }
78  static int AnalyzeAndCreatePalette(const WebPPicture* const pic,
79                                     int low_effort,
80                                     uint32_t palette[MAX_PALETTE_SIZE],
81                                     int* const palette_size) {
82    const int num_colors = WebPGetColorPalette(pic, palette);
83    if (num_colors > MAX_PALETTE_SIZE) {
84      *palette_size = 0;
85      return 0;
86    }
87    *palette_size = num_colors;
88    qsort(palette, num_colors, sizeof(*palette), PaletteCompareColorsForQsort);
89    if (!low_effort && PaletteHasNonMonotonousDeltas(palette, num_colors)) {
90      GreedyMinimizeDeltas(palette, num_colors);
91    }
92    return 1;
93  }
94  typedef enum {
95    kDirect = 0,
96    kSpatial = 1,
97    kSubGreen = 2,
98    kSpatialSubGreen = 3,
99    kPalette = 4,
100    kNumEntropyIx = 5
101  } EntropyIx;
102  typedef enum {
103    kHistoAlpha = 0,
104    kHistoAlphaPred,
105    kHistoGreen,
106    kHistoGreenPred,
107    kHistoRed,
108    kHistoRedPred,
109    kHistoBlue,
110    kHistoBluePred,
111    kHistoRedSubGreen,
112    kHistoRedPredSubGreen,
113    kHistoBlueSubGreen,
114    kHistoBluePredSubGreen,
115    kHistoPalette,
116    kHistoTotal  
117  } HistoIx;
118  static void AddSingleSubGreen(int p, uint32_t* const r, uint32_t* const b) {
119    const int green = p >> 8;  
120    ++r[((p >> 16) - green) & 0xff];
121    ++b[((p >>  0) - green) & 0xff];
122  }
123  static void AddSingle(uint32_t p,
124                        uint32_t* const a, uint32_t* const r,
125                        uint32_t* const g, uint32_t* const b) {
126    ++a[(p >> 24) & 0xff];
127    ++r[(p >> 16) & 0xff];
128    ++g[(p >>  8) & 0xff];
129    ++b[(p >>  0) & 0xff];
130  }
131  static WEBP_INLINE uint32_t HashPix(uint32_t pix) {
132    return ((((uint64_t)pix + (pix >> 19)) * 0x39c5fba7ull) & 0xffffffffu) >> 24;
133  }
134  static int AnalyzeEntropy(const uint32_t* argb,
135                            int width, int height, int argb_stride,
136                            int use_palette,
137                            int palette_size, int transform_bits,
138                            EntropyIx* const min_entropy_ix,
139                            int* const red_and_blue_always_zero) {
140    uint32_t* histo;
141    if (use_palette && palette_size <= 16) {
142      *min_entropy_ix = kPalette;
143      *red_and_blue_always_zero = 1;
144      return 1;
145    }
146    histo = (uint32_t*)WebPSafeCalloc(kHistoTotal, sizeof(*histo) * 256);
147    if (histo != NULL) {
148      int i, x, y;
149      const uint32_t* prev_row = NULL;
150      const uint32_t* curr_row = argb;
151      uint32_t pix_prev = argb[0];  
152      for (y = 0; y < height; ++y) {
153        for (x = 0; x < width; ++x) {
154          const uint32_t pix = curr_row[x];
155          const uint32_t pix_diff = VP8LSubPixels(pix, pix_prev);
156          pix_prev = pix;
157          if ((pix_diff == 0) || (prev_row != NULL && pix == prev_row[x])) {
158            continue;
159          }
160          AddSingle(pix,
161                    &histo[kHistoAlpha * 256],
162                    &histo[kHistoRed * 256],
163                    &histo[kHistoGreen * 256],
164                    &histo[kHistoBlue * 256]);
165          AddSingle(pix_diff,
166                    &histo[kHistoAlphaPred * 256],
167                    &histo[kHistoRedPred * 256],
168                    &histo[kHistoGreenPred * 256],
169                    &histo[kHistoBluePred * 256]);
170          AddSingleSubGreen(pix,
171                            &histo[kHistoRedSubGreen * 256],
172                            &histo[kHistoBlueSubGreen * 256]);
173          AddSingleSubGreen(pix_diff,
174                            &histo[kHistoRedPredSubGreen * 256],
175                            &histo[kHistoBluePredSubGreen * 256]);
176          {
177            const uint32_t hash = HashPix(pix);
178            ++histo[kHistoPalette * 256 + hash];
179          }
180        }
181        prev_row = curr_row;
182        curr_row += argb_stride;
183      }
184      {
185        double entropy_comp[kHistoTotal];
186        double entropy[kNumEntropyIx];
187        int k;
188        int last_mode_to_analyze = use_palette ? kPalette : kSpatialSubGreen;
189        int j;
190        ++histo[kHistoRedPredSubGreen * 256];
191        ++histo[kHistoBluePredSubGreen * 256];
192        ++histo[kHistoRedPred * 256];
193        ++histo[kHistoGreenPred * 256];
194        ++histo[kHistoBluePred * 256];
195        ++histo[kHistoAlphaPred * 256];
196        for (j = 0; j < kHistoTotal; ++j) {
197          entropy_comp[j] = VP8LBitsEntropy(&histo[j * 256], 256);
198        }
<span onclick='openModal()' class='match'>199        entropy[kDirect] = entropy_comp[kHistoAlpha] +
200            entropy_comp[kHistoRed] +
201            entropy_comp[kHistoGreen] +
202            entropy_comp[kHistoBlue];
203        entropy[kSpatial] = entropy_comp[kHistoAlphaPred] +
204            entropy_comp[kHistoRedPred] +
205            entropy_comp[kHistoGreenPred] +
206            entropy_comp[kHistoBluePred];
207        entropy[kSubGreen] = entropy_comp[kHistoAlpha] +
208            entropy_comp[kHistoRedSubGreen] +
209            entropy_comp[kHistoGreen] +
210            entropy_comp[kHistoBlueSubGreen];
211        entropy[kSpatialSubGreen] = entropy_comp[kHistoAlphaPred] +
212            entropy_comp[kHistoRedPredSubGreen] +
213            entropy_comp[kHistoGreenPred] +
214            entropy_comp[kHistoBluePredSubGreen];
215        entropy[kPalette] = entropy_comp[kHistoPalette];
216        entropy[kSpatial] += VP8LSubSampleSize(width, transform_bits) *
217                             VP8LSubSampleSize(height, transform_bits) *
218                             VP8LFastLog2(14);
219        entropy[kSpatialSubGreen] += VP8LSubSampleSize(width, transform_bits) *
220                                     VP8LSubSampleSize(height, transform_bits) *
221                                     VP8LFastLog2(24);
222        entropy[kPalette] += palette_size * 8;
223        *min_entropy_ix = kDirect;
</span>224        for (k = kDirect + 1; k <= last_mode_to_analyze; ++k) {
225          if (entropy[*min_entropy_ix] > entropy[k]) {
226            *min_entropy_ix = (EntropyIx)k;
227          }
228        }
229        assert((int)*min_entropy_ix <= last_mode_to_analyze);
230        *red_and_blue_always_zero = 1;
231        {
232          static const uint8_t kHistoPairs[5][2] = {
233            { kHistoRed, kHistoBlue },
234            { kHistoRedPred, kHistoBluePred },
235            { kHistoRedSubGreen, kHistoBlueSubGreen },
236            { kHistoRedPredSubGreen, kHistoBluePredSubGreen },
237            { kHistoRed, kHistoBlue }
238          };
239          const uint32_t* const red_histo =
240              &histo[256 * kHistoPairs[*min_entropy_ix][0]];
241          const uint32_t* const blue_histo =
242              &histo[256 * kHistoPairs[*min_entropy_ix][1]];
243          for (i = 1; i < 256; ++i) {
244            if ((red_histo[i] | blue_histo[i]) != 0) {
245              *red_and_blue_always_zero = 0;
246              break;
247            }
248          }
249        }
250      }
251      WebPSafeFree(histo);
252      return 1;
253    } else {
254      return 0;
255    }
256  }
257  static int GetHistoBits(int method, int use_palette, int width, int height) {
258    int histo_bits = (use_palette ? 9 : 7) - method;
259    while (1) {
260      const int huff_image_size = VP8LSubSampleSize(width, histo_bits) *
261                                  VP8LSubSampleSize(height, histo_bits);
262      if (huff_image_size <= MAX_HUFF_IMAGE_SIZE) break;
263      ++histo_bits;
264    }
265    return (histo_bits < MIN_HUFFMAN_BITS) ? MIN_HUFFMAN_BITS :
266           (histo_bits > MAX_HUFFMAN_BITS) ? MAX_HUFFMAN_BITS : histo_bits;
267  }
268  static int GetTransformBits(int method, int histo_bits) {
269    const int max_transform_bits = (method < 4) ? 6 : (method > 4) ? 4 : 5;
270    const int res =
271        (histo_bits > max_transform_bits) ? max_transform_bits : histo_bits;
272    assert(res <= MAX_TRANSFORM_BITS);
273    return res;
274  }
275  #define CRUNCH_CONFIGS_LZ77_MAX 2
276  typedef struct {
277    int entropy_idx_;
278    int lz77s_types_to_try_[CRUNCH_CONFIGS_LZ77_MAX];
279    int lz77s_types_to_try_size_;
280  } CrunchConfig;
281  #define CRUNCH_CONFIGS_MAX kNumEntropyIx
282  static int EncoderAnalyze(VP8LEncoder* const enc,
283                            CrunchConfig crunch_configs[CRUNCH_CONFIGS_MAX],
284                            int* const crunch_configs_size,
285                            int* const red_and_blue_always_zero) {
286    const WebPPicture* const pic = enc->pic_;
287    const int width = pic->width;
288    const int height = pic->height;
289    const WebPConfig* const config = enc->config_;
290    const int method = config->method;
291    const int low_effort = (config->method == 0);
292    int i;
293    int use_palette;
294    int n_lz77s;
295    assert(pic != NULL && pic->argb != NULL);
296    use_palette =
297        AnalyzeAndCreatePalette(pic, low_effort,
298                                enc->palette_, &enc->palette_size_);
299    enc->histo_bits_ = GetHistoBits(method, use_palette,
300                                    pic->width, pic->height);
301    enc->transform_bits_ = GetTransformBits(method, enc->histo_bits_);
302    if (low_effort) {
303      crunch_configs[0].entropy_idx_ = use_palette ? kPalette : kSpatialSubGreen;
304      n_lz77s = 1;
305      *crunch_configs_size = 1;
306    } else {
307      EntropyIx min_entropy_ix;
308      n_lz77s = (enc->palette_size_ > 0 && enc->palette_size_ <= 16) ? 2 : 1;
309      if (!AnalyzeEntropy(pic->argb, width, height, pic->argb_stride, use_palette,
310                          enc->palette_size_, enc->transform_bits_,
311                          &min_entropy_ix, red_and_blue_always_zero)) {
312        return 0;
313      }
314      if (method == 6 && config->quality == 100) {
315        *crunch_configs_size = 0;
316        for (i = 0; i < kNumEntropyIx; ++i) {
317          if (i != kPalette || use_palette) {
318            assert(*crunch_configs_size < CRUNCH_CONFIGS_MAX);
319            crunch_configs[(*crunch_configs_size)++].entropy_idx_ = i;
320          }
321        }
322      } else {
323        *crunch_configs_size = 1;
324        crunch_configs[0].entropy_idx_ = min_entropy_ix;
325      }
326    }
327    assert(n_lz77s <= CRUNCH_CONFIGS_LZ77_MAX);
328    for (i = 0; i < *crunch_configs_size; ++i) {
329      int j;
330      for (j = 0; j < n_lz77s; ++j) {
331        crunch_configs[i].lz77s_types_to_try_[j] =
332            (j == 0) ? kLZ77Standard | kLZ77RLE : kLZ77Box;
333      }
334      crunch_configs[i].lz77s_types_to_try_size_ = n_lz77s;
335    }
336    return 1;
337  }
338  static int EncoderInit(VP8LEncoder* const enc) {
339    const WebPPicture* const pic = enc->pic_;
340    const int width = pic->width;
341    const int height = pic->height;
342    const int pix_cnt = width * height;
343    const int refs_block_size = (pix_cnt - 1) / MAX_REFS_BLOCK_PER_IMAGE + 1;
344    int i;
345    if (!VP8LHashChainInit(&enc->hash_chain_, pix_cnt)) return 0;
346    for (i = 0; i < 3; ++i) VP8LBackwardRefsInit(&enc->refs_[i], refs_block_size);
347    return 1;
348  }
349  static int GetHuffBitLengthsAndCodes(
350      const VP8LHistogramSet* const histogram_image,
351      HuffmanTreeCode* const huffman_codes) {
352    int i, k;
353    int ok = 0;
354    uint64_t total_length_size = 0;
355    uint8_t* mem_buf = NULL;
356    const int histogram_image_size = histogram_image->size;
357    int max_num_symbols = 0;
358    uint8_t* buf_rle = NULL;
359    HuffmanTree* huff_tree = NULL;
360    for (i = 0; i < histogram_image_size; ++i) {
361      const VP8LHistogram* const histo = histogram_image->histograms[i];
362      HuffmanTreeCode* const codes = &huffman_codes[5 * i];
363      assert(histo != NULL);
364      for (k = 0; k < 5; ++k) {
365        const int num_symbols =
366            (k == 0) ? VP8LHistogramNumCodes(histo->palette_code_bits_) :
367            (k == 4) ? NUM_DISTANCE_CODES : 256;
368        codes[k].num_symbols = num_symbols;
369        total_length_size += num_symbols;
370      }
371    }
372    {
373      uint16_t* codes;
374      uint8_t* lengths;
375      mem_buf = (uint8_t*)WebPSafeCalloc(total_length_size,
376                                         sizeof(*lengths) + sizeof(*codes));
377      if (mem_buf == NULL) goto End;
378      codes = (uint16_t*)mem_buf;
379      lengths = (uint8_t*)&codes[total_length_size];
380      for (i = 0; i < 5 * histogram_image_size; ++i) {
381        const int bit_length = huffman_codes[i].num_symbols;
382        huffman_codes[i].codes = codes;
383        huffman_codes[i].code_lengths = lengths;
384        codes += bit_length;
385        lengths += bit_length;
386        if (max_num_symbols < bit_length) {
387          max_num_symbols = bit_length;
388        }
389      }
390    }
391    buf_rle = (uint8_t*)WebPSafeMalloc(1ULL, max_num_symbols);
392    huff_tree = (HuffmanTree*)WebPSafeMalloc(3ULL * max_num_symbols,
393                                             sizeof(*huff_tree));
394    if (buf_rle == NULL || huff_tree == NULL) goto End;
395    for (i = 0; i < histogram_image_size; ++i) {
396      HuffmanTreeCode* const codes = &huffman_codes[5 * i];
397      VP8LHistogram* const histo = histogram_image->histograms[i];
398      VP8LCreateHuffmanTree(histo->literal_, 15, buf_rle, huff_tree, codes + 0);
399      VP8LCreateHuffmanTree(histo->red_, 15, buf_rle, huff_tree, codes + 1);
400      VP8LCreateHuffmanTree(histo->blue_, 15, buf_rle, huff_tree, codes + 2);
401      VP8LCreateHuffmanTree(histo->alpha_, 15, buf_rle, huff_tree, codes + 3);
402      VP8LCreateHuffmanTree(histo->distance_, 15, buf_rle, huff_tree, codes + 4);
403    }
404    ok = 1;
405   End:
406    WebPSafeFree(huff_tree);
407    WebPSafeFree(buf_rle);
408    if (!ok) {
409      WebPSafeFree(mem_buf);
410      memset(huffman_codes, 0, 5 * histogram_image_size * sizeof(*huffman_codes));
411    }
412    return ok;
413  }
414  static void StoreHuffmanTreeOfHuffmanTreeToBitMask(
415      VP8LBitWriter* const bw, const uint8_t* code_length_bitdepth) {
416    static const uint8_t kStorageOrder[CODE_LENGTH_CODES] = {
417      17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
418    };
419    int i;
420    int codes_to_store = CODE_LENGTH_CODES;
421    for (; codes_to_store > 4; --codes_to_store) {
422      if (code_length_bitdepth[kStorageOrder[codes_to_store - 1]] != 0) {
423        break;
424      }
425    }
426    VP8LPutBits(bw, codes_to_store - 4, 4);
427    for (i = 0; i < codes_to_store; ++i) {
428      VP8LPutBits(bw, code_length_bitdepth[kStorageOrder[i]], 3);
429    }
430  }
431  static void ClearHuffmanTreeIfOnlyOneSymbol(
432      HuffmanTreeCode* const huffman_code) {
433    int k;
434    int count = 0;
435    for (k = 0; k < huffman_code->num_symbols; ++k) {
436      if (huffman_code->code_lengths[k] != 0) {
437        ++count;
438        if (count > 1) return;
439      }
440    }
441    for (k = 0; k < huffman_code->num_symbols; ++k) {
442      huffman_code->code_lengths[k] = 0;
443      huffman_code->codes[k] = 0;
444    }
445  }
446  static void StoreHuffmanTreeToBitMask(
447      VP8LBitWriter* const bw,
448      const HuffmanTreeToken* const tokens, const int num_tokens,
449      const HuffmanTreeCode* const huffman_code) {
450    int i;
451    for (i = 0; i < num_tokens; ++i) {
452      const int ix = tokens[i].code;
453      const int extra_bits = tokens[i].extra_bits;
454      VP8LPutBits(bw, huffman_code->codes[ix], huffman_code->code_lengths[ix]);
455      switch (ix) {
456        case 16:
457          VP8LPutBits(bw, extra_bits, 2);
458          break;
459        case 17:
460          VP8LPutBits(bw, extra_bits, 3);
461          break;
462        case 18:
463          VP8LPutBits(bw, extra_bits, 7);
464          break;
465      }
466    }
467  }
468  static void StoreFullHuffmanCode(VP8LBitWriter* const bw,
469                                   HuffmanTree* const huff_tree,
470                                   HuffmanTreeToken* const tokens,
471                                   const HuffmanTreeCode* const tree) {
472    uint8_t code_length_bitdepth[CODE_LENGTH_CODES] = { 0 };
473    uint16_t code_length_bitdepth_symbols[CODE_LENGTH_CODES] = { 0 };
474    const int max_tokens = tree->num_symbols;
475    int num_tokens;
476    HuffmanTreeCode huffman_code;
477    huffman_code.num_symbols = CODE_LENGTH_CODES;
478    huffman_code.code_lengths = code_length_bitdepth;
479    huffman_code.codes = code_length_bitdepth_symbols;
480    VP8LPutBits(bw, 0, 1);
481    num_tokens = VP8LCreateCompressedHuffmanTree(tree, tokens, max_tokens);
482    {
483      uint32_t histogram[CODE_LENGTH_CODES] = { 0 };
484      uint8_t buf_rle[CODE_LENGTH_CODES] = { 0 };
485      int i;
486      for (i = 0; i < num_tokens; ++i) {
487        ++histogram[tokens[i].code];
488      }
489      VP8LCreateHuffmanTree(histogram, 7, buf_rle, huff_tree, &huffman_code);
490    }
491    StoreHuffmanTreeOfHuffmanTreeToBitMask(bw, code_length_bitdepth);
492    ClearHuffmanTreeIfOnlyOneSymbol(&huffman_code);
493    {
494      int trailing_zero_bits = 0;
495      int trimmed_length = num_tokens;
496      int write_trimmed_length;
497      int length;
498      int i = num_tokens;
499      while (i-- > 0) {
500        const int ix = tokens[i].code;
501        if (ix == 0 || ix == 17 || ix == 18) {
502          --trimmed_length;   
503          trailing_zero_bits += code_length_bitdepth[ix];
504          if (ix == 17) {
505            trailing_zero_bits += 3;
506          } else if (ix == 18) {
507            trailing_zero_bits += 7;
508          }
509        } else {
510          break;
511        }
512      }
513      write_trimmed_length = (trimmed_length > 1 && trailing_zero_bits > 12);
514      length = write_trimmed_length ? trimmed_length : num_tokens;
515      VP8LPutBits(bw, write_trimmed_length, 1);
516      if (write_trimmed_length) {
517        if (trimmed_length == 2) {
518          VP8LPutBits(bw, 0, 3 + 2);     
519        } else {
520          const int nbits = BitsLog2Floor(trimmed_length - 2);
521          const int nbitpairs = nbits / 2 + 1;
522          assert(trimmed_length > 2);
523          assert(nbitpairs - 1 < 8);
524          VP8LPutBits(bw, nbitpairs - 1, 3);
525          VP8LPutBits(bw, trimmed_length - 2, nbitpairs * 2);
526        }
527      }
528      StoreHuffmanTreeToBitMask(bw, tokens, length, &huffman_code);
529    }
530  }
531  static void StoreHuffmanCode(VP8LBitWriter* const bw,
532                               HuffmanTree* const huff_tree,
533                               HuffmanTreeToken* const tokens,
534                               const HuffmanTreeCode* const huffman_code) {
535    int i;
536    int count = 0;
537    int symbols[2] = { 0, 0 };
538    const int kMaxBits = 8;
539    const int kMaxSymbol = 1 << kMaxBits;
540    for (i = 0; i < huffman_code->num_symbols && count < 3; ++i) {
541      if (huffman_code->code_lengths[i] != 0) {
542        if (count < 2) symbols[count] = i;
543        ++count;
544      }
545    }
546    if (count == 0) {   
547      VP8LPutBits(bw, 0x01, 4);
548    } else if (count <= 2 && symbols[0] < kMaxSymbol && symbols[1] < kMaxSymbol) {
549      VP8LPutBits(bw, 1, 1);  
550      VP8LPutBits(bw, count - 1, 1);
551      if (symbols[0] <= 1) {
552        VP8LPutBits(bw, 0, 1);  
553        VP8LPutBits(bw, symbols[0], 1);
554      } else {
555        VP8LPutBits(bw, 1, 1);
556        VP8LPutBits(bw, symbols[0], 8);
557      }
558      if (count == 2) {
559        VP8LPutBits(bw, symbols[1], 8);
560      }
561    } else {
562      StoreFullHuffmanCode(bw, huff_tree, tokens, huffman_code);
563    }
564  }
565  static WEBP_INLINE void WriteHuffmanCode(VP8LBitWriter* const bw,
566                               const HuffmanTreeCode* const code,
567                               int code_index) {
568    const int depth = code->code_lengths[code_index];
569    const int symbol = code->codes[code_index];
570    VP8LPutBits(bw, symbol, depth);
571  }
572  static WEBP_INLINE void WriteHuffmanCodeWithExtraBits(
573      VP8LBitWriter* const bw,
574      const HuffmanTreeCode* const code,
575      int code_index,
576      int bits,
577      int n_bits) {
578    const int depth = code->code_lengths[code_index];
579    const int symbol = code->codes[code_index];
580    VP8LPutBits(bw, (bits << depth) | symbol, depth + n_bits);
581  }
582  static WebPEncodingError StoreImageToBitMask(
583      VP8LBitWriter* const bw, int width, int histo_bits,
584      const VP8LBackwardRefs* const refs,
585      const uint16_t* histogram_symbols,
586      const HuffmanTreeCode* const huffman_codes) {
587    const int histo_xsize = histo_bits ? VP8LSubSampleSize(width, histo_bits) : 1;
588    const int tile_mask = (histo_bits == 0) ? 0 : -(1 << histo_bits);
589    int x = 0;
590    int y = 0;
591    int tile_x = x & tile_mask;
592    int tile_y = y & tile_mask;
593    int histogram_ix = histogram_symbols[0];
594    const HuffmanTreeCode* codes = huffman_codes + 5 * histogram_ix;
595    VP8LRefsCursor c = VP8LRefsCursorInit(refs);
596    while (VP8LRefsCursorOk(&c)) {
597      const PixOrCopy* const v = c.cur_pos;
598      if ((tile_x != (x & tile_mask)) || (tile_y != (y & tile_mask))) {
599        tile_x = x & tile_mask;
600        tile_y = y & tile_mask;
601        histogram_ix = histogram_symbols[(y >> histo_bits) * histo_xsize +
602                                         (x >> histo_bits)];
603        codes = huffman_codes + 5 * histogram_ix;
604      }
605      if (PixOrCopyIsLiteral(v)) {
606        static const uint8_t order[] = { 1, 2, 0, 3 };
607        int k;
608        for (k = 0; k < 4; ++k) {
609          const int code = PixOrCopyLiteral(v, order[k]);
610          WriteHuffmanCode(bw, codes + k, code);
611        }
612      } else if (PixOrCopyIsCacheIdx(v)) {
613        const int code = PixOrCopyCacheIdx(v);
614        const int literal_ix = 256 + NUM_LENGTH_CODES + code;
615        WriteHuffmanCode(bw, codes, literal_ix);
616      } else {
617        int bits, n_bits;
618        int code;
619        const int distance = PixOrCopyDistance(v);
620        VP8LPrefixEncode(v->len, &code, &n_bits, &bits);
621        WriteHuffmanCodeWithExtraBits(bw, codes, 256 + code, bits, n_bits);
622        VP8LPrefixEncode(distance, &code, &n_bits, &bits);
623        WriteHuffmanCode(bw, codes + 4, code);
624        VP8LPutBits(bw, bits, n_bits);
625      }
626      x += PixOrCopyLength(v);
627      while (x >= width) {
628        x -= width;
629        ++y;
630      }
631      VP8LRefsCursorNext(&c);
632    }
633    return bw->error_ ? VP8_ENC_ERROR_OUT_OF_MEMORY : VP8_ENC_OK;
634  }
635  static WebPEncodingError EncodeImageNoHuffman(VP8LBitWriter* const bw,
636                                                const uint32_t* const argb,
637                                                VP8LHashChain* const hash_chain,
638                                                VP8LBackwardRefs* const refs_tmp1,
639                                                VP8LBackwardRefs* const refs_tmp2,
640                                                int width, int height,
641                                                int quality, int low_effort) {
642    int i;
643    int max_tokens = 0;
644    WebPEncodingError err = VP8_ENC_OK;
645    VP8LBackwardRefs* refs;
646    HuffmanTreeToken* tokens = NULL;
647    HuffmanTreeCode huffman_codes[5] = { { 0, NULL, NULL } };
648    const uint16_t histogram_symbols[1] = { 0 };    
649    int cache_bits = 0;
650    VP8LHistogramSet* histogram_image = NULL;
651    HuffmanTree* const huff_tree = (HuffmanTree*)WebPSafeMalloc(
652          3ULL * CODE_LENGTH_CODES, sizeof(*huff_tree));
653    if (huff_tree == NULL) {
654      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
655      goto Error;
656    }
657    if (!VP8LHashChainFill(hash_chain, quality, argb, width, height,
658                           low_effort)) {
659      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
660      goto Error;
661    }
662    refs = VP8LGetBackwardReferences(width, height, argb, quality, 0,
663                                     kLZ77Standard | kLZ77RLE, &cache_bits,
664                                     hash_chain, refs_tmp1, refs_tmp2);
665    if (refs == NULL) {
666      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
667      goto Error;
668    }
669    histogram_image = VP8LAllocateHistogramSet(1, cache_bits);
670    if (histogram_image == NULL) {
671      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
672      goto Error;
673    }
674    VP8LHistogramSetClear(histogram_image);
675    VP8LHistogramStoreRefs(refs, histogram_image->histograms[0]);
676    assert(histogram_image->size == 1);
677    if (!GetHuffBitLengthsAndCodes(histogram_image, huffman_codes)) {
678      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
679      goto Error;
680    }
681    VP8LPutBits(bw, 0, 1);
682    for (i = 0; i < 5; ++i) {
683      HuffmanTreeCode* const codes = &huffman_codes[i];
684      if (max_tokens < codes->num_symbols) {
685        max_tokens = codes->num_symbols;
686      }
687    }
688    tokens = (HuffmanTreeToken*)WebPSafeMalloc(max_tokens, sizeof(*tokens));
689    if (tokens == NULL) {
690      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
691      goto Error;
692    }
693    for (i = 0; i < 5; ++i) {
694      HuffmanTreeCode* const codes = &huffman_codes[i];
695      StoreHuffmanCode(bw, huff_tree, tokens, codes);
696      ClearHuffmanTreeIfOnlyOneSymbol(codes);
697    }
698    err = StoreImageToBitMask(bw, width, 0, refs, histogram_symbols,
699                              huffman_codes);
700   Error:
701    WebPSafeFree(tokens);
702    WebPSafeFree(huff_tree);
703    VP8LFreeHistogramSet(histogram_image);
704    WebPSafeFree(huffman_codes[0].codes);
705    return err;
706  }
707  static WebPEncodingError EncodeImageInternal(
708      VP8LBitWriter* const bw, const uint32_t* const argb,
709      VP8LHashChain* const hash_chain, VP8LBackwardRefs refs_array[3], int width,
710      int height, int quality, int low_effort, int use_cache,
711      const CrunchConfig* const config, int* cache_bits, int histogram_bits,
712      size_t init_byte_position, int* const hdr_size, int* const data_size) {
713    WebPEncodingError err = VP8_ENC_OK;
714    const uint32_t histogram_image_xysize =
715        VP8LSubSampleSize(width, histogram_bits) *
716        VP8LSubSampleSize(height, histogram_bits);
717    VP8LHistogramSet* histogram_image = NULL;
718    VP8LHistogram* tmp_histo = NULL;
719    int histogram_image_size = 0;
720    size_t bit_array_size = 0;
721    HuffmanTree* const huff_tree = (HuffmanTree*)WebPSafeMalloc(
722        3ULL * CODE_LENGTH_CODES, sizeof(*huff_tree));
723    HuffmanTreeToken* tokens = NULL;
724    HuffmanTreeCode* huffman_codes = NULL;
725    VP8LBackwardRefs* refs_best;
726    VP8LBackwardRefs* refs_tmp;
727    uint16_t* const histogram_symbols =
728        (uint16_t*)WebPSafeMalloc(histogram_image_xysize,
729                                  sizeof(*histogram_symbols));
730    int lz77s_idx;
731    VP8LBitWriter bw_init = *bw, bw_best;
732    int hdr_size_tmp;
733    assert(histogram_bits >= MIN_HUFFMAN_BITS);
734    assert(histogram_bits <= MAX_HUFFMAN_BITS);
735    assert(hdr_size != NULL);
736    assert(data_size != NULL);
737    if (histogram_symbols == NULL) {
738      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
739      goto Error;
740    }
741    if (use_cache) {
742      if (*cache_bits == 0) *cache_bits = MAX_COLOR_CACHE_BITS;
743    } else {
744      *cache_bits = 0;
745    }
746    if (huff_tree == NULL ||
747        !VP8LHashChainFill(hash_chain, quality, argb, width, height,
748                           low_effort) ||
749        !VP8LBitWriterInit(&bw_best, 0) ||
750        (config->lz77s_types_to_try_size_ > 1 &&
751         !VP8LBitWriterClone(bw, &bw_best))) {
752      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
753      goto Error;
754    }
755    for (lz77s_idx = 0; lz77s_idx < config->lz77s_types_to_try_size_;
756         ++lz77s_idx) {
757      refs_best = VP8LGetBackwardReferences(
758          width, height, argb, quality, low_effort,
759          config->lz77s_types_to_try_[lz77s_idx], cache_bits, hash_chain,
760          &refs_array[0], &refs_array[1]);
761      if (refs_best == NULL) {
762        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
763        goto Error;
764      }
765      refs_tmp = &refs_array[refs_best == &refs_array[0] ? 1 : 0];
766      histogram_image =
767          VP8LAllocateHistogramSet(histogram_image_xysize, *cache_bits);
768      tmp_histo = VP8LAllocateHistogram(*cache_bits);
769      if (histogram_image == NULL || tmp_histo == NULL) {
770        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
771        goto Error;
772      }
773      if (!VP8LGetHistoImageSymbols(width, height, refs_best, quality, low_effort,
774                                    histogram_bits, *cache_bits, histogram_image,
775                                    tmp_histo, histogram_symbols)) {
776        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
777        goto Error;
778      }
779      histogram_image_size = histogram_image->size;
780      bit_array_size = 5 * histogram_image_size;
781      huffman_codes = (HuffmanTreeCode*)WebPSafeCalloc(bit_array_size,
782                                                       sizeof(*huffman_codes));
783      if (huffman_codes == NULL ||
784          !GetHuffBitLengthsAndCodes(histogram_image, huffman_codes)) {
785        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
786        goto Error;
787      }
788      VP8LFreeHistogramSet(histogram_image);
789      histogram_image = NULL;
790      VP8LFreeHistogram(tmp_histo);
791      tmp_histo = NULL;
792      if (*cache_bits > 0) {
793        VP8LPutBits(bw, 1, 1);
794        VP8LPutBits(bw, *cache_bits, 4);
795      } else {
796        VP8LPutBits(bw, 0, 1);
797      }
798      {
799        const int write_histogram_image = (histogram_image_size > 1);
800        VP8LPutBits(bw, write_histogram_image, 1);
801        if (write_histogram_image) {
802          uint32_t* const histogram_argb =
803              (uint32_t*)WebPSafeMalloc(histogram_image_xysize,
804                                        sizeof(*histogram_argb));
805          int max_index = 0;
806          uint32_t i;
807          if (histogram_argb == NULL) {
808            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
809            goto Error;
810          }
811          for (i = 0; i < histogram_image_xysize; ++i) {
812            const int symbol_index = histogram_symbols[i] & 0xffff;
813            histogram_argb[i] = (symbol_index << 8);
814            if (symbol_index >= max_index) {
815              max_index = symbol_index + 1;
816            }
817          }
818          histogram_image_size = max_index;
819          VP8LPutBits(bw, histogram_bits - 2, 3);
820          err = EncodeImageNoHuffman(
821              bw, histogram_argb, hash_chain, refs_tmp, &refs_array[2],
822              VP8LSubSampleSize(width, histogram_bits),
823              VP8LSubSampleSize(height, histogram_bits), quality, low_effort);
824          WebPSafeFree(histogram_argb);
825          if (err != VP8_ENC_OK) goto Error;
826        }
827      }
828      {
829        int i;
830        int max_tokens = 0;
831        for (i = 0; i < 5 * histogram_image_size; ++i) {
832          HuffmanTreeCode* const codes = &huffman_codes[i];
833          if (max_tokens < codes->num_symbols) {
834            max_tokens = codes->num_symbols;
835          }
836        }
837        tokens = (HuffmanTreeToken*)WebPSafeMalloc(max_tokens, sizeof(*tokens));
838        if (tokens == NULL) {
839          err = VP8_ENC_ERROR_OUT_OF_MEMORY;
840          goto Error;
841        }
842        for (i = 0; i < 5 * histogram_image_size; ++i) {
843          HuffmanTreeCode* const codes = &huffman_codes[i];
844          StoreHuffmanCode(bw, huff_tree, tokens, codes);
845          ClearHuffmanTreeIfOnlyOneSymbol(codes);
846        }
847      }
848      hdr_size_tmp = (int)(VP8LBitWriterNumBytes(bw) - init_byte_position);
849      err = StoreImageToBitMask(bw, width, histogram_bits, refs_best,
850                                histogram_symbols, huffman_codes);
851      if (lz77s_idx == 0 ||
852          VP8LBitWriterNumBytes(bw) < VP8LBitWriterNumBytes(&bw_best)) {
853        *hdr_size = hdr_size_tmp;
854        *data_size =
855            (int)(VP8LBitWriterNumBytes(bw) - init_byte_position - *hdr_size);
856        VP8LBitWriterSwap(bw, &bw_best);
857      }
858      if (config->lz77s_types_to_try_size_ > 1) VP8LBitWriterReset(&bw_init, bw);
859      WebPSafeFree(tokens);
860      tokens = NULL;
861      if (huffman_codes != NULL) {
862        WebPSafeFree(huffman_codes->codes);
863        WebPSafeFree(huffman_codes);
864        huffman_codes = NULL;
865      }
866    }
867    VP8LBitWriterSwap(bw, &bw_best);
868   Error:
869    WebPSafeFree(tokens);
870    WebPSafeFree(huff_tree);
871    VP8LFreeHistogramSet(histogram_image);
872    VP8LFreeHistogram(tmp_histo);
873    if (huffman_codes != NULL) {
874      WebPSafeFree(huffman_codes->codes);
875      WebPSafeFree(huffman_codes);
876    }
877    WebPSafeFree(histogram_symbols);
878    VP8LBitWriterWipeOut(&bw_best);
879    return err;
880  }
881  static void ApplySubtractGreen(VP8LEncoder* const enc, int width, int height,
882                                 VP8LBitWriter* const bw) {
883    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
884    VP8LPutBits(bw, SUBTRACT_GREEN, 2);
885    VP8LSubtractGreenFromBlueAndRed(enc->argb_, width * height);
886  }
887  static WebPEncodingError ApplyPredictFilter(const VP8LEncoder* const enc,
888                                              int width, int height,
889                                              int quality, int low_effort,
890                                              int used_subtract_green,
891                                              VP8LBitWriter* const bw) {
892    const int pred_bits = enc->transform_bits_;
893    const int transform_width = VP8LSubSampleSize(width, pred_bits);
894    const int transform_height = VP8LSubSampleSize(height, pred_bits);
895    const int near_lossless_strength = enc->use_palette_ ? 100
896                                     : enc->config_->near_lossless;
897    VP8LResidualImage(width, height, pred_bits, low_effort, enc->argb_,
898                      enc->argb_scratch_, enc->transform_data_,
899                      near_lossless_strength, enc->config_->exact,
900                      used_subtract_green);
901    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
902    VP8LPutBits(bw, PREDICTOR_TRANSFORM, 2);
903    assert(pred_bits >= 2);
904    VP8LPutBits(bw, pred_bits - 2, 3);
905    return EncodeImageNoHuffman(
906        bw, enc->transform_data_, (VP8LHashChain*)&enc->hash_chain_,
907        (VP8LBackwardRefs*)&enc->refs_[0],  
908        (VP8LBackwardRefs*)&enc->refs_[1], transform_width, transform_height,
909        quality, low_effort);
910  }
911  static WebPEncodingError ApplyCrossColorFilter(const VP8LEncoder* const enc,
912                                                 int width, int height,
913                                                 int quality, int low_effort,
914                                                 VP8LBitWriter* const bw) {
915    const int ccolor_transform_bits = enc->transform_bits_;
916    const int transform_width = VP8LSubSampleSize(width, ccolor_transform_bits);
917    const int transform_height = VP8LSubSampleSize(height, ccolor_transform_bits);
918    VP8LColorSpaceTransform(width, height, ccolor_transform_bits, quality,
919                            enc->argb_, enc->transform_data_);
920    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
921    VP8LPutBits(bw, CROSS_COLOR_TRANSFORM, 2);
922    assert(ccolor_transform_bits >= 2);
923    VP8LPutBits(bw, ccolor_transform_bits - 2, 3);
924    return EncodeImageNoHuffman(
925        bw, enc->transform_data_, (VP8LHashChain*)&enc->hash_chain_,
926        (VP8LBackwardRefs*)&enc->refs_[0],  
927        (VP8LBackwardRefs*)&enc->refs_[1], transform_width, transform_height,
928        quality, low_effort);
929  }
930  static WebPEncodingError WriteRiffHeader(const WebPPicture* const pic,
931                                           size_t riff_size, size_t vp8l_size) {
932    uint8_t riff[RIFF_HEADER_SIZE + CHUNK_HEADER_SIZE + VP8L_SIGNATURE_SIZE] = {
933      'R', 'I', 'F', 'F', 0, 0, 0, 0, 'W', 'E', 'B', 'P',
934      'V', 'P', '8', 'L', 0, 0, 0, 0, VP8L_MAGIC_BYTE,
935    };
936    PutLE32(riff + TAG_SIZE, (uint32_t)riff_size);
937    PutLE32(riff + RIFF_HEADER_SIZE + TAG_SIZE, (uint32_t)vp8l_size);
938    if (!pic->writer(riff, sizeof(riff), pic)) {
939      return VP8_ENC_ERROR_BAD_WRITE;
940    }
941    return VP8_ENC_OK;
942  }
943  static int WriteImageSize(const WebPPicture* const pic,
944                            VP8LBitWriter* const bw) {
945    const int width = pic->width - 1;
946    const int height = pic->height - 1;
947    assert(width < WEBP_MAX_DIMENSION && height < WEBP_MAX_DIMENSION);
948    VP8LPutBits(bw, width, VP8L_IMAGE_SIZE_BITS);
949    VP8LPutBits(bw, height, VP8L_IMAGE_SIZE_BITS);
950    return !bw->error_;
951  }
952  static int WriteRealAlphaAndVersion(VP8LBitWriter* const bw, int has_alpha) {
953    VP8LPutBits(bw, has_alpha, 1);
954    VP8LPutBits(bw, VP8L_VERSION, VP8L_VERSION_BITS);
955    return !bw->error_;
956  }
957  static WebPEncodingError WriteImage(const WebPPicture* const pic,
958                                      VP8LBitWriter* const bw,
959                                      size_t* const coded_size) {
960    WebPEncodingError err = VP8_ENC_OK;
961    const uint8_t* const webpll_data = VP8LBitWriterFinish(bw);
962    const size_t webpll_size = VP8LBitWriterNumBytes(bw);
963    const size_t vp8l_size = VP8L_SIGNATURE_SIZE + webpll_size;
964    const size_t pad = vp8l_size & 1;
965    const size_t riff_size = TAG_SIZE + CHUNK_HEADER_SIZE + vp8l_size + pad;
966    err = WriteRiffHeader(pic, riff_size, vp8l_size);
967    if (err != VP8_ENC_OK) goto Error;
968    if (!pic->writer(webpll_data, webpll_size, pic)) {
969      err = VP8_ENC_ERROR_BAD_WRITE;
970      goto Error;
971    }
972    if (pad) {
973      const uint8_t pad_byte[1] = { 0 };
974      if (!pic->writer(pad_byte, 1, pic)) {
975        err = VP8_ENC_ERROR_BAD_WRITE;
976        goto Error;
977      }
978    }
979    *coded_size = CHUNK_HEADER_SIZE + riff_size;
980    return VP8_ENC_OK;
981   Error:
982    return err;
983  }
984  static void ClearTransformBuffer(VP8LEncoder* const enc) {
985    WebPSafeFree(enc->transform_mem_);
986    enc->transform_mem_ = NULL;
987    enc->transform_mem_size_ = 0;
988  }
989  static WebPEncodingError AllocateTransformBuffer(VP8LEncoder* const enc,
990                                                   int width, int height) {
991    WebPEncodingError err = VP8_ENC_OK;
992    const uint64_t image_size = width * height;
993    const uint64_t argb_scratch_size =
994        enc->use_predict_
995            ? (width + 1) * 2 +
996              (width * 2 + sizeof(uint32_t) - 1) / sizeof(uint32_t)
997            : 0;
998    const uint64_t transform_data_size =
999        (enc->use_predict_ || enc->use_cross_color_)
1000            ? VP8LSubSampleSize(width, enc->transform_bits_) *
1001                  VP8LSubSampleSize(height, enc->transform_bits_)
1002            : 0;
1003    const uint64_t max_alignment_in_words =
1004        (WEBP_ALIGN_CST + sizeof(uint32_t) - 1) / sizeof(uint32_t);
1005    const uint64_t mem_size =
1006        image_size + max_alignment_in_words +
1007        argb_scratch_size + max_alignment_in_words +
1008        transform_data_size;
1009    uint32_t* mem = enc->transform_mem_;
1010    if (mem == NULL || mem_size > enc->transform_mem_size_) {
1011      ClearTransformBuffer(enc);
1012      mem = (uint32_t*)WebPSafeMalloc(mem_size, sizeof(*mem));
1013      if (mem == NULL) {
1014        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1015        goto Error;
1016      }
1017      enc->transform_mem_ = mem;
1018      enc->transform_mem_size_ = (size_t)mem_size;
1019      enc->argb_content_ = kEncoderNone;
1020    }
1021    enc->argb_ = mem;
1022    mem = (uint32_t*)WEBP_ALIGN(mem + image_size);
1023    enc->argb_scratch_ = mem;
1024    mem = (uint32_t*)WEBP_ALIGN(mem + argb_scratch_size);
1025    enc->transform_data_ = mem;
1026    enc->current_width_ = width;
1027   Error:
1028    return err;
1029  }
1030  static WebPEncodingError MakeInputImageCopy(VP8LEncoder* const enc) {
1031    WebPEncodingError err = VP8_ENC_OK;
1032    const WebPPicture* const picture = enc->pic_;
1033    const int width = picture->width;
1034    const int height = picture->height;
1035    err = AllocateTransformBuffer(enc, width, height);
1036    if (err != VP8_ENC_OK) return err;
1037    if (enc->argb_content_ == kEncoderARGB) return VP8_ENC_OK;
1038    {
1039      uint32_t* dst = enc->argb_;
1040      const uint32_t* src = picture->argb;
1041      int y;
1042      for (y = 0; y < height; ++y) {
1043        memcpy(dst, src, width * sizeof(*dst));
1044        dst += width;
1045        src += picture->argb_stride;
1046      }
1047    }
1048    enc->argb_content_ = kEncoderARGB;
1049    assert(enc->current_width_ == width);
1050    return VP8_ENC_OK;
1051  }
1052  static WEBP_INLINE int SearchColorNoIdx(const uint32_t sorted[], uint32_t color,
1053                                          int hi) {
1054    int low = 0;
1055    if (sorted[low] == color) return low;  
1056    while (1) {
1057      const int mid = (low + hi) >> 1;
1058      if (sorted[mid] == color) {
1059        return mid;
1060      } else if (sorted[mid] < color) {
1061        low = mid;
1062      } else {
1063        hi = mid;
1064      }
1065    }
1066  }
1067  #define APPLY_PALETTE_GREEDY_MAX 4
1068  static WEBP_INLINE uint32_t SearchColorGreedy(const uint32_t palette[],
1069                                                int palette_size,
1070                                                uint32_t color) {
1071    (void)palette_size;
1072    assert(palette_size < APPLY_PALETTE_GREEDY_MAX);
1073    assert(3 == APPLY_PALETTE_GREEDY_MAX - 1);
1074    if (color == palette[0]) return 0;
1075    if (color == palette[1]) return 1;
1076    if (color == palette[2]) return 2;
1077    return 3;
1078  }
1079  static WEBP_INLINE uint32_t ApplyPaletteHash0(uint32_t color) {
1080    return (color >> 8) & 0xff;
1081  }
1082  #define PALETTE_INV_SIZE_BITS 11
1083  #define PALETTE_INV_SIZE (1 << PALETTE_INV_SIZE_BITS)
1084  static WEBP_INLINE uint32_t ApplyPaletteHash1(uint32_t color) {
1085    return ((uint32_t)((color & 0x00ffffffu) * 4222244071ull)) >>
1086           (32 - PALETTE_INV_SIZE_BITS);
1087  }
1088  static WEBP_INLINE uint32_t ApplyPaletteHash2(uint32_t color) {
1089    return ((uint32_t)((color & 0x00ffffffu) * ((1ull << 31) - 1))) >>
1090           (32 - PALETTE_INV_SIZE_BITS);
1091  }
1092  static void PrepareMapToPalette(const uint32_t palette[], int num_colors,
1093                                  uint32_t sorted[], uint32_t idx_map[]) {
1094    int i;
1095    memcpy(sorted, palette, num_colors * sizeof(*sorted));
1096    qsort(sorted, num_colors, sizeof(*sorted), PaletteCompareColorsForQsort);
1097    for (i = 0; i < num_colors; ++i) {
1098      idx_map[SearchColorNoIdx(sorted, palette[i], num_colors)] = i;
1099    }
1100  }
1101  #define APPLY_PALETTE_FOR(COLOR_INDEX) do {         \
1102    uint32_t prev_pix = palette[0];                   \
1103    uint32_t prev_idx = 0;                            \
1104    for (y = 0; y < height; ++y) {                    \
1105      for (x = 0; x < width; ++x) {                   \
1106        const uint32_t pix = src[x];                  \
1107        if (pix != prev_pix) {                        \
1108          prev_idx = COLOR_INDEX;                     \
1109          prev_pix = pix;                             \
1110        }                                             \
1111        tmp_row[x] = prev_idx;                        \
1112      }                                               \
1113      VP8LBundleColorMap(tmp_row, width, xbits, dst); \
1114      src += src_stride;                              \
1115      dst += dst_stride;                              \
1116    }                                                 \
1117  } while (0)
1118  static WebPEncodingError ApplyPalette(const uint32_t* src, uint32_t src_stride,
1119                                        uint32_t* dst, uint32_t dst_stride,
1120                                        const uint32_t* palette, int palette_size,
1121                                        int width, int height, int xbits) {
1122    uint8_t* const tmp_row = (uint8_t*)WebPSafeMalloc(width, sizeof(*tmp_row));
1123    int x, y;
1124    if (tmp_row == NULL) return VP8_ENC_ERROR_OUT_OF_MEMORY;
1125    if (palette_size < APPLY_PALETTE_GREEDY_MAX) {
1126      APPLY_PALETTE_FOR(SearchColorGreedy(palette, palette_size, pix));
1127    } else {
1128      int i, j;
1129      uint16_t buffer[PALETTE_INV_SIZE];
1130      uint32_t (*const hash_functions[])(uint32_t) = {
1131          ApplyPaletteHash0, ApplyPaletteHash1, ApplyPaletteHash2
1132      };
1133      for (i = 0; i < 3; ++i) {
1134        int use_LUT = 1;
1135        memset(buffer, 0xff, sizeof(buffer));
1136        for (j = 0; j < palette_size; ++j) {
1137          const uint32_t ind = hash_functions[i](palette[j]);
1138          if (buffer[ind] != 0xffffu) {
1139            use_LUT = 0;
1140            break;
1141          } else {
1142            buffer[ind] = j;
1143          }
1144        }
1145        if (use_LUT) break;
1146      }
1147      if (i == 0) {
1148        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash0(pix)]);
1149      } else if (i == 1) {
1150        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash1(pix)]);
1151      } else if (i == 2) {
1152        APPLY_PALETTE_FOR(buffer[ApplyPaletteHash2(pix)]);
1153      } else {
1154        uint32_t idx_map[MAX_PALETTE_SIZE];
1155        uint32_t palette_sorted[MAX_PALETTE_SIZE];
1156        PrepareMapToPalette(palette, palette_size, palette_sorted, idx_map);
1157        APPLY_PALETTE_FOR(
1158            idx_map[SearchColorNoIdx(palette_sorted, pix, palette_size)]);
1159      }
1160    }
1161    WebPSafeFree(tmp_row);
1162    return VP8_ENC_OK;
1163  }
1164  #undef APPLY_PALETTE_FOR
1165  #undef PALETTE_INV_SIZE_BITS
1166  #undef PALETTE_INV_SIZE
1167  #undef APPLY_PALETTE_GREEDY_MAX
1168  static WebPEncodingError MapImageFromPalette(VP8LEncoder* const enc,
1169                                               int in_place) {
1170    WebPEncodingError err = VP8_ENC_OK;
1171    const WebPPicture* const pic = enc->pic_;
1172    const int width = pic->width;
1173    const int height = pic->height;
1174    const uint32_t* const palette = enc->palette_;
1175    const uint32_t* src = in_place ? enc->argb_ : pic->argb;
1176    const int src_stride = in_place ? enc->current_width_ : pic->argb_stride;
1177    const int palette_size = enc->palette_size_;
1178    int xbits;
1179    if (palette_size <= 4) {
1180      xbits = (palette_size <= 2) ? 3 : 2;
1181    } else {
1182      xbits = (palette_size <= 16) ? 1 : 0;
1183    }
1184    err = AllocateTransformBuffer(enc, VP8LSubSampleSize(width, xbits), height);
1185    if (err != VP8_ENC_OK) return err;
1186    err = ApplyPalette(src, src_stride,
1187                       enc->argb_, enc->current_width_,
1188                       palette, palette_size, width, height, xbits);
1189    enc->argb_content_ = kEncoderPalette;
1190    return err;
1191  }
1192  static WebPEncodingError EncodePalette(VP8LBitWriter* const bw, int low_effort,
1193                                         VP8LEncoder* const enc) {
1194    int i;
1195    uint32_t tmp_palette[MAX_PALETTE_SIZE];
1196    const int palette_size = enc->palette_size_;
1197    const uint32_t* const palette = enc->palette_;
1198    VP8LPutBits(bw, TRANSFORM_PRESENT, 1);
1199    VP8LPutBits(bw, COLOR_INDEXING_TRANSFORM, 2);
1200    assert(palette_size >= 1 && palette_size <= MAX_PALETTE_SIZE);
1201    VP8LPutBits(bw, palette_size - 1, 8);
1202    for (i = palette_size - 1; i >= 1; --i) {
1203      tmp_palette[i] = VP8LSubPixels(palette[i], palette[i - 1]);
1204    }
1205    tmp_palette[0] = palette[0];
1206    return EncodeImageNoHuffman(bw, tmp_palette, &enc->hash_chain_,
1207                                &enc->refs_[0], &enc->refs_[1], palette_size, 1,
1208                                20 &bsol;* quality */, low_effort);
1209  }
1210  static VP8LEncoder* VP8LEncoderNew(const WebPConfig* const config,
1211                                     const WebPPicture* const picture) {
1212    VP8LEncoder* const enc = (VP8LEncoder*)WebPSafeCalloc(1ULL, sizeof(*enc));
1213    if (enc == NULL) {
1214      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
1215      return NULL;
1216    }
1217    enc->config_ = config;
1218    enc->pic_ = picture;
1219    enc->argb_content_ = kEncoderNone;
1220    VP8LEncDspInit();
1221    return enc;
1222  }
1223  static void VP8LEncoderDelete(VP8LEncoder* enc) {
1224    if (enc != NULL) {
1225      int i;
1226      VP8LHashChainClear(&enc->hash_chain_);
1227      for (i = 0; i < 3; ++i) VP8LBackwardRefsClear(&enc->refs_[i]);
1228      ClearTransformBuffer(enc);
1229      WebPSafeFree(enc);
1230    }
1231  }
1232  typedef struct {
1233    const WebPConfig* config_;
1234    const WebPPicture* picture_;
1235    VP8LBitWriter* bw_;
1236    VP8LEncoder* enc_;
1237    int use_cache_;
1238    CrunchConfig crunch_configs_[CRUNCH_CONFIGS_MAX];
1239    int num_crunch_configs_;
1240    int red_and_blue_always_zero_;
1241    WebPEncodingError err_;
1242    WebPAuxStats* stats_;
1243  } StreamEncodeContext;
1244  static int EncodeStreamHook(void* input, void* data2) {
1245    StreamEncodeContext* const params = (StreamEncodeContext*)input;
1246    const WebPConfig* const config = params->config_;
1247    const WebPPicture* const picture = params->picture_;
1248    VP8LBitWriter* const bw = params->bw_;
1249    VP8LEncoder* const enc = params->enc_;
1250    const int use_cache = params->use_cache_;
1251    const CrunchConfig* const crunch_configs = params->crunch_configs_;
1252    const int num_crunch_configs = params->num_crunch_configs_;
1253    const int red_and_blue_always_zero = params->red_and_blue_always_zero_;
1254  #if !defined(WEBP_DISABLE_STATS)
1255    WebPAuxStats* const stats = params->stats_;
1256  #endif
1257    WebPEncodingError err = VP8_ENC_OK;
1258    const int quality = (int)config->quality;
1259    const int low_effort = (config->method == 0);
1260  #if (WEBP_NEAR_LOSSLESS == 1)
1261    const int width = picture->width;
1262  #endif
1263    const int height = picture->height;
1264    const size_t byte_position = VP8LBitWriterNumBytes(bw);
1265  #if (WEBP_NEAR_LOSSLESS == 1)
1266    int use_near_lossless = 0;
1267  #endif
1268    int hdr_size = 0;
1269    int data_size = 0;
1270    int use_delta_palette = 0;
1271    int idx;
1272    size_t best_size = 0;
1273    VP8LBitWriter bw_init = *bw, bw_best;
1274    (void)data2;
1275    if (!VP8LBitWriterInit(&bw_best, 0) ||
1276        (num_crunch_configs > 1 && !VP8LBitWriterClone(bw, &bw_best))) {
1277      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1278      goto Error;
1279    }
1280    for (idx = 0; idx < num_crunch_configs; ++idx) {
1281      const int entropy_idx = crunch_configs[idx].entropy_idx_;
1282      enc->use_palette_ = (entropy_idx == kPalette);
1283      enc->use_subtract_green_ =
1284          (entropy_idx == kSubGreen) || (entropy_idx == kSpatialSubGreen);
1285      enc->use_predict_ =
1286          (entropy_idx == kSpatial) || (entropy_idx == kSpatialSubGreen);
1287      if (low_effort) {
1288        enc->use_cross_color_ = 0;
1289      } else {
1290        enc->use_cross_color_ = red_and_blue_always_zero ? 0 : enc->use_predict_;
1291      }
1292      enc->cache_bits_ = 0;
1293      VP8LBackwardRefsClear(&enc->refs_[0]);
1294      VP8LBackwardRefsClear(&enc->refs_[1]);
1295  #if (WEBP_NEAR_LOSSLESS == 1)
1296      use_near_lossless = (config->near_lossless < 100) && !enc->use_palette_ &&
1297                          !enc->use_predict_;
1298      if (use_near_lossless) {
1299        err = AllocateTransformBuffer(enc, width, height);
1300        if (err != VP8_ENC_OK) goto Error;
1301        if ((enc->argb_content_ != kEncoderNearLossless) &&
1302            !VP8ApplyNearLossless(picture, config->near_lossless, enc->argb_)) {
1303          err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1304          goto Error;
1305        }
1306        enc->argb_content_ = kEncoderNearLossless;
1307      } else {
1308        enc->argb_content_ = kEncoderNone;
1309      }
1310  #else
1311      enc->argb_content_ = kEncoderNone;
1312  #endif
1313      if (enc->use_palette_) {
1314        err = EncodePalette(bw, low_effort, enc);
1315        if (err != VP8_ENC_OK) goto Error;
1316        err = MapImageFromPalette(enc, use_delta_palette);
1317        if (err != VP8_ENC_OK) goto Error;
1318        if (use_cache && enc->palette_size_ < (1 << MAX_COLOR_CACHE_BITS)) {
1319          enc->cache_bits_ = BitsLog2Floor(enc->palette_size_) + 1;
1320        }
1321      }
1322      if (!use_delta_palette) {
1323        if (enc->argb_content_ != kEncoderNearLossless &&
1324            enc->argb_content_ != kEncoderPalette) {
1325          err = MakeInputImageCopy(enc);
1326          if (err != VP8_ENC_OK) goto Error;
1327        }
1328        if (enc->use_subtract_green_) {
1329          ApplySubtractGreen(enc, enc->current_width_, height, bw);
1330        }
1331        if (enc->use_predict_) {
1332          err = ApplyPredictFilter(enc, enc->current_width_, height, quality,
1333                                   low_effort, enc->use_subtract_green_, bw);
1334          if (err != VP8_ENC_OK) goto Error;
1335        }
1336        if (enc->use_cross_color_) {
1337          err = ApplyCrossColorFilter(enc, enc->current_width_, height, quality,
1338                                      low_effort, bw);
1339          if (err != VP8_ENC_OK) goto Error;
1340        }
1341      }
1342      VP8LPutBits(bw, !TRANSFORM_PRESENT, 1);  
1343      err = EncodeImageInternal(bw, enc->argb_, &enc->hash_chain_, enc->refs_,
1344                                enc->current_width_, height, quality, low_effort,
1345                                use_cache, &crunch_configs[idx],
1346                                &enc->cache_bits_, enc->histo_bits_,
1347                                byte_position, &hdr_size, &data_size);
1348      if (err != VP8_ENC_OK) goto Error;
1349      if (idx == 0 || VP8LBitWriterNumBytes(bw) < best_size) {
1350        best_size = VP8LBitWriterNumBytes(bw);
1351        VP8LBitWriterSwap(bw, &bw_best);
1352  #if !defined(WEBP_DISABLE_STATS)
1353        if (stats != NULL) {
1354          stats->lossless_features = 0;
1355          if (enc->use_predict_) stats->lossless_features |= 1;
1356          if (enc->use_cross_color_) stats->lossless_features |= 2;
1357          if (enc->use_subtract_green_) stats->lossless_features |= 4;
1358          if (enc->use_palette_) stats->lossless_features |= 8;
1359          stats->histogram_bits = enc->histo_bits_;
1360          stats->transform_bits = enc->transform_bits_;
1361          stats->cache_bits = enc->cache_bits_;
1362          stats->palette_size = enc->palette_size_;
1363          stats->lossless_size = (int)(best_size - byte_position);
1364          stats->lossless_hdr_size = hdr_size;
1365          stats->lossless_data_size = data_size;
1366        }
1367  #endif
1368      }
1369      if (num_crunch_configs > 1) VP8LBitWriterReset(&bw_init, bw);
1370    }
1371    VP8LBitWriterSwap(&bw_best, bw);
1372  Error:
1373    VP8LBitWriterWipeOut(&bw_best);
1374    params->err_ = err;
1375    return (err == VP8_ENC_OK);
1376  }
1377  WebPEncodingError VP8LEncodeStream(const WebPConfig* const config,
1378                                     const WebPPicture* const picture,
1379                                     VP8LBitWriter* const bw_main,
1380                                     int use_cache) {
1381    WebPEncodingError err = VP8_ENC_OK;
1382    VP8LEncoder* const enc_main = VP8LEncoderNew(config, picture);
1383    VP8LEncoder* enc_side = NULL;
1384    CrunchConfig crunch_configs[CRUNCH_CONFIGS_MAX];
1385    int num_crunch_configs_main, num_crunch_configs_side = 0;
1386    int idx;
1387    int red_and_blue_always_zero = 0;
1388    WebPWorker worker_main, worker_side;
1389    StreamEncodeContext params_main, params_side;
1390    WebPAuxStats stats_side;
1391    VP8LBitWriter bw_side;
1392    const WebPWorkerInterface* const worker_interface = WebPGetWorkerInterface();
1393    int ok_main;
1394    if (enc_main == NULL ||
1395        !EncoderAnalyze(enc_main, crunch_configs, &num_crunch_configs_main,
1396                        &red_and_blue_always_zero) ||
1397        !EncoderInit(enc_main) || !VP8LBitWriterInit(&bw_side, 0)) {
1398      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1399      goto Error;
1400    }
1401    if (config->thread_level > 0) {
1402      num_crunch_configs_side = num_crunch_configs_main / 2;
1403      for (idx = 0; idx < num_crunch_configs_side; ++idx) {
1404        params_side.crunch_configs_[idx] =
1405            crunch_configs[num_crunch_configs_main - num_crunch_configs_side +
1406                           idx];
1407      }
1408      params_side.num_crunch_configs_ = num_crunch_configs_side;
1409    }
1410    num_crunch_configs_main -= num_crunch_configs_side;
1411    for (idx = 0; idx < num_crunch_configs_main; ++idx) {
1412      params_main.crunch_configs_[idx] = crunch_configs[idx];
1413    }
1414    params_main.num_crunch_configs_ = num_crunch_configs_main;
1415    {
1416      const int params_size = (num_crunch_configs_side > 0) ? 2 : 1;
1417      for (idx = 0; idx < params_size; ++idx) {
1418        WebPWorker* const worker = (idx == 0) ? &worker_main : &worker_side;
1419        StreamEncodeContext* const param =
1420            (idx == 0) ? &params_main : &params_side;
1421        param->config_ = config;
1422        param->picture_ = picture;
1423        param->use_cache_ = use_cache;
1424        param->red_and_blue_always_zero_ = red_and_blue_always_zero;
1425        if (idx == 0) {
1426          param->stats_ = picture->stats;
1427          param->bw_ = bw_main;
1428          param->enc_ = enc_main;
1429        } else {
1430          param->stats_ = (picture->stats == NULL) ? NULL : &stats_side;
1431          if (!VP8LBitWriterClone(bw_main, &bw_side)) {
1432            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1433            goto Error;
1434          }
1435          param->bw_ = &bw_side;
1436          enc_side = VP8LEncoderNew(config, picture);
1437          if (enc_side == NULL || !EncoderInit(enc_side)) {
1438            err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1439            goto Error;
1440          }
1441          enc_side->histo_bits_ = enc_main->histo_bits_;
1442          enc_side->transform_bits_ = enc_main->transform_bits_;
1443          enc_side->palette_size_ = enc_main->palette_size_;
1444          memcpy(enc_side->palette_, enc_main->palette_,
1445                 sizeof(enc_main->palette_));
1446          param->enc_ = enc_side;
1447        }
1448        worker_interface->Init(worker);
1449        worker->data1 = param;
1450        worker->data2 = NULL;
1451        worker->hook = EncodeStreamHook;
1452      }
1453    }
1454    if (num_crunch_configs_side != 0) {
1455      if (!worker_interface->Reset(&worker_side)) {
1456        err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1457        goto Error;
1458      }
1459  #if !defined(WEBP_DISABLE_STATS)
1460      if (picture->stats != NULL) {
1461        memcpy(&stats_side, picture->stats, sizeof(stats_side));
1462      }
1463  #endif
1464      params_side.err_ = VP8_ENC_OK;
1465      worker_interface->Launch(&worker_side);
1466    }
1467    worker_interface->Execute(&worker_main);
1468    ok_main = worker_interface->Sync(&worker_main);
1469    worker_interface->End(&worker_main);
1470    if (num_crunch_configs_side != 0) {
1471      const int ok_side = worker_interface->Sync(&worker_side);
1472      worker_interface->End(&worker_side);
1473      if (!ok_main || !ok_side) {
1474        err = ok_main ? params_side.err_ : params_main.err_;
1475        goto Error;
1476      }
1477      if (VP8LBitWriterNumBytes(&bw_side) < VP8LBitWriterNumBytes(bw_main)) {
1478        VP8LBitWriterSwap(bw_main, &bw_side);
1479  #if !defined(WEBP_DISABLE_STATS)
1480        if (picture->stats != NULL) {
1481          memcpy(picture->stats, &stats_side, sizeof(*picture->stats));
1482        }
1483  #endif
1484      }
1485    } else {
1486      if (!ok_main) {
1487        err = params_main.err_;
1488        goto Error;
1489      }
1490    }
1491  Error:
1492    VP8LBitWriterWipeOut(&bw_side);
1493    VP8LEncoderDelete(enc_main);
1494    VP8LEncoderDelete(enc_side);
1495    return err;
1496  }
1497  #undef CRUNCH_CONFIGS_MAX
1498  #undef CRUNCH_CONFIGS_LZ77_MAX
1499  int VP8LEncodeImage(const WebPConfig* const config,
1500                      const WebPPicture* const picture) {
1501    int width, height;
1502    int has_alpha;
1503    size_t coded_size;
1504    int percent = 0;
1505    int initial_size;
1506    WebPEncodingError err = VP8_ENC_OK;
1507    VP8LBitWriter bw;
1508    if (picture == NULL) return 0;
1509    if (config == NULL || picture->argb == NULL) {
1510      err = VP8_ENC_ERROR_NULL_PARAMETER;
1511      WebPEncodingSetError(picture, err);
1512      return 0;
1513    }
1514    width = picture->width;
1515    height = picture->height;
1516    initial_size = (config->image_hint == WEBP_HINT_GRAPH) ?
1517        width * height : width * height * 2;
1518    if (!VP8LBitWriterInit(&bw, initial_size)) {
1519      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1520      goto Error;
1521    }
1522    if (!WebPReportProgress(picture, 1, &percent)) {
1523   UserAbort:
1524      err = VP8_ENC_ERROR_USER_ABORT;
1525      goto Error;
1526    }
1527    if (picture->stats != NULL) {
1528      WebPAuxStats* const stats = picture->stats;
1529      memset(stats, 0, sizeof(*stats));
1530      stats->PSNR[0] = 99.f;
1531      stats->PSNR[1] = 99.f;
1532      stats->PSNR[2] = 99.f;
1533      stats->PSNR[3] = 99.f;
1534      stats->PSNR[4] = 99.f;
1535    }
1536    if (!WriteImageSize(picture, &bw)) {
1537      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1538      goto Error;
1539    }
1540    has_alpha = WebPPictureHasTransparency(picture);
1541    if (!WriteRealAlphaAndVersion(&bw, has_alpha)) {
1542      err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1543      goto Error;
1544    }
1545    if (!WebPReportProgress(picture, 5, &percent)) goto UserAbort;
1546    err = VP8LEncodeStream(config, picture, &bw, 1 &bsol;*use_cache*/);
1547    if (err != VP8_ENC_OK) goto Error;
1548    if (!WebPReportProgress(picture, 90, &percent)) goto UserAbort;
1549    err = WriteImage(picture, &bw, &coded_size);
1550    if (err != VP8_ENC_OK) goto Error;
1551    if (!WebPReportProgress(picture, 100, &percent)) goto UserAbort;
1552  #if !defined(WEBP_DISABLE_STATS)
1553    if (picture->stats != NULL) {
1554      picture->stats->coded_size += (int)coded_size;
1555      picture->stats->lossless_size = (int)coded_size;
1556    }
1557  #endif
1558    if (picture->extra_info != NULL) {
1559      const int mb_w = (width + 15) >> 4;
1560      const int mb_h = (height + 15) >> 4;
1561      memset(picture->extra_info, 0, mb_w * mb_h * sizeof(*picture->extra_info));
1562    }
1563   Error:
1564    if (bw.error_) err = VP8_ENC_ERROR_OUT_OF_MEMORY;
1565    VP8LBitWriterWipeOut(&bw);
1566    if (err != VP8_ENC_OK) {
1567      WebPEncodingSetError(picture, err);
1568      return 0;
1569    }
1570    return 1;
1571  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_timer.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_enc.c</div>
                <div class="column column_space"><pre><code>79      NRF_TIMER_SHORT_COMPARE0_STOP_MASK = TIMER_SHORTS_COMPARE0_STOP_Msk,   
80      NRF_TIMER_SHORT_COMPARE1_STOP_MASK = TIMER_SHORTS_COMPARE1_STOP_Msk,   
81      NRF_TIMER_SHORT_COMPARE2_STOP_MASK = TIMER_SHORTS_COMPARE2_STOP_Msk,   
82      NRF_TIMER_SHORT_COMPARE3_STOP_MASK = TIMER_SHORTS_COMPARE3_STOP_Msk,   
83  #if defined(TIMER_INTENSET_COMPARE4_Msk) || defined(__NRFX_DOXYGEN__)
84      NRF_TIMER_SHORT_COMPARE4_STOP_MASK = TIMER_SHORTS_COMPARE4_STOP_Msk,   
85  #endif
86  #if defined(TIMER_INTENSET_COMPARE5_Msk) || defined(__NRFX_DOXYGEN__)
87      NRF_TIMER_SHORT_COMPARE5_STOP_MASK = TIMER_SHORTS_COMPARE5_STOP_Msk,   
88  #endif
89      NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK = TIMER_SHORTS_COMPARE0_CLEAR_Msk, 
90      NRF_TIMER_SHORT_COMPARE1_CLEAR_MASK = TIMER_SHORTS_COMPARE1_CLEAR_Msk, 
91      NRF_TIMER_SHORT_COMPARE2_CLEAR_MASK = TIMER_SHORTS_COMPARE2_CLEAR_Msk, 
</pre></code></div>
                <div class="column column_space"><pre><code>199        entropy[kDirect] = entropy_comp[kHistoAlpha] +
200            entropy_comp[kHistoRed] +
201            entropy_comp[kHistoGreen] +
202            entropy_comp[kHistoBlue];
203        entropy[kSpatial] = entropy_comp[kHistoAlphaPred] +
204            entropy_comp[kHistoRedPred] +
205            entropy_comp[kHistoGreenPred] +
206            entropy_comp[kHistoBluePred];
207        entropy[kSubGreen] = entropy_comp[kHistoAlpha] +
208            entropy_comp[kHistoRedSubGreen] +
209            entropy_comp[kHistoGreen] +
210            entropy_comp[kHistoBlueSubGreen];
211        entropy[kSpatialSubGreen] = entropy_comp[kHistoAlphaPred] +
212            entropy_comp[kHistoRedPredSubGreen] +
213            entropy_comp[kHistoGreenPred] +
214            entropy_comp[kHistoBluePredSubGreen];
215        entropy[kPalette] = entropy_comp[kHistoPalette];
216        entropy[kSpatial] += VP8LSubSampleSize(width, transform_bits) *
217                             VP8LSubSampleSize(height, transform_bits) *
218                             VP8LFastLog2(14);
219        entropy[kSpatialSubGreen] += VP8LSubSampleSize(width, transform_bits) *
220                                     VP8LSubSampleSize(height, transform_bits) *
221                                     VP8LFastLog2(24);
222        entropy[kPalette] += palette_size * 8;
223        *min_entropy_ix = kDirect;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    