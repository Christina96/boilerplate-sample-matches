
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lbaselib.c</h3>
            <pre><code>1  #include &lt;ctype.h&gt;
2  #include &lt;stdio.h&gt;
3  #include &lt;stdlib.h&gt;
4  #include &lt;string.h&gt;
5  #define lbaselib_c
6  #define LUA_LIB
7  #include &quot;lua.h&quot;
8  #include &quot;lauxlib.h&quot;
9  #include &quot;lualib.h&quot;
10  static int luaB_print (lua_State *L) {
11    int n = lua_gettop(L);  &amp;bsol;* number of arguments */
12    int i;
13    lua_getglobal(L, &quot;tostring&quot;);
14    for (i=1; i&lt;=n; i++) {
15      const char *s;
16      lua_pushvalue(L, -1);  &amp;bsol;* function to be called */
17      lua_pushvalue(L, i);   &amp;bsol;* value to print */
18      lua_call(L, 1, 1);
19      s = lua_tostring(L, -1);  &amp;bsol;* get result */
20      if (s == NULL)
21        return luaL_error(L, LUA_QL(&quot;tostring&quot;) &quot; must return a string to &quot;
22                             LUA_QL(&quot;print&quot;));
23      if (i&gt;1) fputs(&quot;\t&quot;, stdout);
24      fputs(s, stdout);
25      lua_pop(L, 1);  &amp;bsol;* pop result */
26    }
27    fputs(&quot;\n&quot;, stdout);
28    return 0;
29  }
30  static int luaB_tonumber (lua_State *L) {
31    int base = luaL_optint(L, 2, 10);
32    if (base == 10) {  &amp;bsol;* standard conversion */
33      luaL_checkany(L, 1);
34      if (lua_isnumber(L, 1)) {
35        lua_pushnumber(L, lua_tonumber(L, 1));
36        return 1;
37      }
38    }
39    else {
40      const char *s1 = luaL_checkstring(L, 1);
41      char *s2;
42      unsigned long n;
43      luaL_argcheck(L, 2 &lt;= base &amp;&amp; base &lt;= 36, 2, &quot;base out of range&quot;);
44      n = strtoul(s1, &amp;s2, base);
45      if (s1 != s2) {  &amp;bsol;* at least one valid digit? */
46        while (isspace((unsigned char)(*s2))) s2++;  &amp;bsol;* skip trailing spaces */
47        if (*s2 == &#x27;\0&#x27;) {  &amp;bsol;* no invalid trailing characters? */
48          lua_pushnumber(L, (lua_Number)n);
49          return 1;
50        }
51      }
52    }
53    lua_pushnil(L);  &amp;bsol;* else not a number */
54    return 1;
55  }
56  static int luaB_error (lua_State *L) {
57    int level = luaL_optint(L, 2, 1);
58    lua_settop(L, 1);
59    if (lua_isstring(L, 1) &amp;&amp; level &gt; 0) {  &amp;bsol;* add extra information? */
60      luaL_where(L, level);
61      lua_pushvalue(L, 1);
62      lua_concat(L, 2);
63    }
64    return lua_error(L);
65  }
66  static int luaB_getmetatable (lua_State *L) {
67    luaL_checkany(L, 1);
68    if (!lua_getmetatable(L, 1)) {
69      lua_pushnil(L);
70      return 1;  &amp;bsol;* no metatable */
71    }
72    luaL_getmetafield(L, 1, &quot;__metatable&quot;);
73    return 1;  &amp;bsol;* returns either __metatable field (if present) or metatable */
74  }
75  static int luaB_setmetatable (lua_State *L) {
76    int t = lua_type(L, 2);
77    luaL_checktype(L, 1, LUA_TTABLE);
78    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
79                      &quot;nil or table expected&quot;);
80    if (luaL_getmetafield(L, 1, &quot;__metatable&quot;))
81      luaL_error(L, &quot;cannot change a protected metatable&quot;);
82    lua_settop(L, 2);
83    lua_setmetatable(L, 1);
84    return 1;
85  }
86  static void getfunc (lua_State *L, int opt) {
87    if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
88    else {
89      lua_Debug ar;
90      int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);
91      luaL_argcheck(L, level &gt;= 0, 1, &quot;level must be non-negative&quot;);
92      if (lua_getstack(L, level, &amp;ar) == 0)
93        luaL_argerror(L, 1, &quot;invalid level&quot;);
94      lua_getinfo(L, &quot;f&quot;, &amp;ar);
95      if (lua_isnil(L, -1))
96        luaL_error(L, &quot;no function environment for tail call at level %d&quot;,
97                      level);
98    }
99  }
100  static int luaB_getfenv (lua_State *L) {
101    getfunc(L, 1);
102    if (lua_iscfunction(L, -1))  &amp;bsol;* is a C function? */
103      lua_pushvalue(L, LUA_GLOBALSINDEX);  &amp;bsol;* return the thread&#x27;s global env. */
104    else
105      lua_getfenv(L, -1);
106    return 1;
107  }
108  static int luaB_setfenv (lua_State *L) {
109    luaL_checktype(L, 2, LUA_TTABLE);
110    getfunc(L, 0);
111    lua_pushvalue(L, 2);
112    if (lua_isnumber(L, 1) &amp;&amp; lua_tonumber(L, 1) == 0) {
113      lua_pushthread(L);
114      lua_insert(L, -2);
115      lua_setfenv(L, -2);
116      return 0;
117    }
118    else if (lua_iscfunction(L, -2) || lua_setfenv(L, -2) == 0)
119      luaL_error(L,
120            LUA_QL(&quot;setfenv&quot;) &quot; cannot change environment of given object&quot;);
121    return 1;
122  }
123  static int luaB_rawequal (lua_State *L) {
124    luaL_checkany(L, 1);
125    luaL_checkany(L, 2);
126    lua_pushboolean(L, lua_rawequal(L, 1, 2));
127    return 1;
128  }
129  static int luaB_rawget (lua_State *L) {
130    luaL_checktype(L, 1, LUA_TTABLE);
131    luaL_checkany(L, 2);
132    lua_settop(L, 2);
133    lua_rawget(L, 1);
134    return 1;
135  }
136  static int luaB_rawset (lua_State *L) {
137    luaL_checktype(L, 1, LUA_TTABLE);
138    luaL_checkany(L, 2);
139    luaL_checkany(L, 3);
140    lua_settop(L, 3);
141    lua_rawset(L, 1);
142    return 1;
143  }
144  static int luaB_gcinfo (lua_State *L) {
145    lua_pushinteger(L, lua_getgccount(L));
146    return 1;
147  }
148  static int luaB_collectgarbage (lua_State *L) {
149    static const char *const opts[] = {&quot;stop&quot;, &quot;restart&quot;, &quot;collect&quot;,
150      &quot;count&quot;, &quot;step&quot;, &quot;setpause&quot;, &quot;setstepmul&quot;, NULL};
151    static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
152      LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
153    int o = luaL_checkoption(L, 1, &quot;collect&quot;, opts);
154    int ex = luaL_optint(L, 2, 0);
155    int res = lua_gc(L, optsnum[o], ex);
156    switch (optsnum[o]) {
157      case LUA_GCCOUNT: {
158        int b = lua_gc(L, LUA_GCCOUNTB, 0);
159        lua_pushnumber(L, res + ((lua_Number)b/1024));
160        return 1;
161      }
162      case LUA_GCSTEP: {
163        lua_pushboolean(L, res);
164        return 1;
165      }
166      default: {
167        lua_pushnumber(L, res);
168        return 1;
169      }
170    }
171  }
172  static int luaB_type (lua_State *L) {
173    luaL_checkany(L, 1);
174    lua_pushstring(L, luaL_typename(L, 1));
175    return 1;
176  }
177  static int luaB_next (lua_State *L) {
178    luaL_checktype(L, 1, LUA_TTABLE);
179    lua_settop(L, 2);  &amp;bsol;* create a 2nd argument if there isn&#x27;t one */
180    if (lua_next(L, 1))
181      return 2;
182    else {
183      lua_pushnil(L);
184      return 1;
185    }
186  }
187  static int luaB_pairs (lua_State *L) {
188    luaL_checktype(L, 1, LUA_TTABLE);
189    lua_pushvalue(L, lua_upvalueindex(1));  &amp;bsol;* return generator, */
<span onclick='openModal()' class='match'>190    lua_pushvalue(L, 1);  &amp;bsol;* state, */
191    lua_pushnil(L);  &amp;bsol;* and initial value */
</span>192    return 3;
193  }
194  static int ipairsaux (lua_State *L) {
195    int i = luaL_checkint(L, 2);
196    luaL_checktype(L, 1, LUA_TTABLE);
197    i++;  &amp;bsol;* next value */
198    lua_pushinteger(L, i);
199    lua_rawgeti(L, 1, i);
200    return (lua_isnil(L, -1)) ? 0 : 2;
201  }
202  static int luaB_ipairs (lua_State *L) {
203    luaL_checktype(L, 1, LUA_TTABLE);
204    lua_pushvalue(L, lua_upvalueindex(1));  &amp;bsol;* return generator, */
205    lua_pushvalue(L, 1);  &amp;bsol;* state, */
206    lua_pushinteger(L, 0);  &amp;bsol;* and initial value */
207    return 3;
208  }
209  static int load_aux (lua_State *L, int status) {
210    if (status == 0)  &amp;bsol;* OK? */
211      return 1;
212    else {
213      lua_pushnil(L);
214      lua_insert(L, -2);  &amp;bsol;* put before error message */
215      return 2;  &amp;bsol;* return nil plus error message */
216    }
217  }
218  static int luaB_loadstring (lua_State *L) {
219    size_t l;
220    const char *s = luaL_checklstring(L, 1, &amp;l);
221    const char *chunkname = luaL_optstring(L, 2, s);
222    return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
223  }
224  static int luaB_loadfile (lua_State *L) {
225    const char *fname = luaL_optstring(L, 1, NULL);
226    return load_aux(L, luaL_loadfile(L, fname));
227  }
228  static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
229    (void)ud;  &amp;bsol;* to avoid warnings */
230    luaL_checkstack(L, 2, &quot;too many nested functions&quot;);
231    lua_pushvalue(L, 1);  &amp;bsol;* get function */
232    lua_call(L, 0, 1);  &amp;bsol;* call it */
233    if (lua_isnil(L, -1)) {
234      *size = 0;
235      return NULL;
236    }
237    else if (lua_isstring(L, -1)) {
238      lua_replace(L, 3);  &amp;bsol;* save string in a reserved stack slot */
239      return lua_tolstring(L, 3, size);
240    }
241    else luaL_error(L, &quot;reader function must return a string&quot;);
242    return NULL;  &amp;bsol;* to avoid warnings */
243  }
244  static int luaB_load (lua_State *L) {
245    int status;
246    const char *cname = luaL_optstring(L, 2, &quot;=(load)&quot;);
247    luaL_checktype(L, 1, LUA_TFUNCTION);
248    lua_settop(L, 3);  &amp;bsol;* function, eventual name, plus one reserved slot */
249    status = lua_load(L, generic_reader, NULL, cname);
250    return load_aux(L, status);
251  }
252  static int luaB_dofile (lua_State *L) {
253    const char *fname = luaL_optstring(L, 1, NULL);
254    int n = lua_gettop(L);
255    if (luaL_loadfile(L, fname) != 0) lua_error(L);
256    lua_call(L, 0, LUA_MULTRET);
257    return lua_gettop(L) - n;
258  }
259  static int luaB_assert (lua_State *L) {
260    luaL_checkany(L, 1);
261    if (!lua_toboolean(L, 1))
262      return luaL_error(L, &quot;%s&quot;, luaL_optstring(L, 2, &quot;assertion failed!&quot;));
263    return lua_gettop(L);
264  }
265  static int luaB_unpack (lua_State *L) {
266    int i, e, n;
267    luaL_checktype(L, 1, LUA_TTABLE);
268    i = luaL_optint(L, 2, 1);
269    e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
270    if (i &gt; e) return 0;  &amp;bsol;* empty range */
271    n = e - i + 1;  &amp;bsol;* number of elements */
272    if (n &lt;= 0 || !lua_checkstack(L, n))  &amp;bsol;* n &lt;= 0 means arith. overflow */
273      return luaL_error(L, &quot;too many results to unpack&quot;);
274    lua_rawgeti(L, 1, i);  &amp;bsol;* push arg[i] (avoiding overflow problems) */
275    while (i++ &lt; e)  &amp;bsol;* push arg[i + 1...e] */
276      lua_rawgeti(L, 1, i);
277    return n;
278  }
279  static int luaB_select (lua_State *L) {
280    int n = lua_gettop(L);
281    if (lua_type(L, 1) == LUA_TSTRING &amp;&amp; *lua_tostring(L, 1) == &#x27;#&#x27;) {
282      lua_pushinteger(L, n-1);
283      return 1;
284    }
285    else {
286      int i = luaL_checkint(L, 1);
287      if (i &lt; 0) i = n + i;
288      else if (i &gt; n) i = n;
289      luaL_argcheck(L, 1 &lt;= i, 1, &quot;index out of range&quot;);
290      return n - i;
291    }
292  }
293  static int luaB_pcall (lua_State *L) {
294    int status;
295    luaL_checkany(L, 1);
296    status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
297    lua_pushboolean(L, (status == 0));
298    lua_insert(L, 1);
299    return lua_gettop(L);  &amp;bsol;* return status + all results */
300  }
301  static int luaB_xpcall (lua_State *L) {
302    int status;
303    luaL_checkany(L, 2);
304    lua_settop(L, 2);
305    lua_insert(L, 1);  &amp;bsol;* put error function under function to be called */
306    status = lua_pcall(L, 0, LUA_MULTRET, 1);
307    lua_pushboolean(L, (status == 0));
308    lua_replace(L, 1);
309    return lua_gettop(L);  &amp;bsol;* return status + all results */
310  }
311  static int luaB_tostring (lua_State *L) {
312    luaL_checkany(L, 1);
313    if (luaL_callmeta(L, 1, &quot;__tostring&quot;))  &amp;bsol;* is there a metafield? */
314      return 1;  &amp;bsol;* use its value */
315    switch (lua_type(L, 1)) {
316      case LUA_TNUMBER:
317        lua_pushstring(L, lua_tostring(L, 1));
318        break;
319      case LUA_TSTRING:
320        lua_pushvalue(L, 1);
321        break;
322      case LUA_TBOOLEAN:
323        lua_pushstring(L, (lua_toboolean(L, 1) ? &quot;true&quot; : &quot;false&quot;));
324        break;
325      case LUA_TNIL:
326        lua_pushliteral(L, &quot;nil&quot;);
327        break;
328      default:
329        lua_pushfstring(L, &quot;%s: %p&quot;, luaL_typename(L, 1), lua_topointer(L, 1));
330        break;
331    }
332    return 1;
333  }
334  static int luaB_newproxy (lua_State *L) {
335    lua_settop(L, 1);
336    lua_newuserdata(L, 0);  &amp;bsol;* create proxy */
337    if (lua_toboolean(L, 1) == 0)
338      return 1;  &amp;bsol;* no metatable */
339    else if (lua_isboolean(L, 1)) {
340      lua_newtable(L);  &amp;bsol;* create a new metatable `m&#x27; ... */
341      lua_pushvalue(L, -1);  &amp;bsol;* ... and mark `m&#x27; as a valid metatable */
342      lua_pushboolean(L, 1);
343      lua_rawset(L, lua_upvalueindex(1));  &amp;bsol;* weaktable[m] = true */
344    }
345    else {
346      int validproxy = 0;  &amp;bsol;* to check if weaktable[metatable(u)] == true */
347      if (lua_getmetatable(L, 1)) {
348        lua_rawget(L, lua_upvalueindex(1));
349        validproxy = lua_toboolean(L, -1);
350        lua_pop(L, 1);  &amp;bsol;* remove value */
351      }
352      luaL_argcheck(L, validproxy, 1, &quot;boolean or proxy expected&quot;);
353      lua_getmetatable(L, 1);  &amp;bsol;* metatable is valid; get it */
354    }
355    lua_setmetatable(L, 2);
356    return 1;
357  }
358  static const luaL_Reg base_funcs[] = {
359    {&quot;assert&quot;, luaB_assert},
360    {&quot;collectgarbage&quot;, luaB_collectgarbage},
361    {&quot;dofile&quot;, luaB_dofile},
362    {&quot;error&quot;, luaB_error},
363    {&quot;gcinfo&quot;, luaB_gcinfo},
364    {&quot;getfenv&quot;, luaB_getfenv},
365    {&quot;getmetatable&quot;, luaB_getmetatable},
366    {&quot;loadfile&quot;, luaB_loadfile},
367    {&quot;load&quot;, luaB_load},
368    {&quot;loadstring&quot;, luaB_loadstring},
369    {&quot;next&quot;, luaB_next},
370    {&quot;pcall&quot;, luaB_pcall},
371    {&quot;print&quot;, luaB_print},
372    {&quot;rawequal&quot;, luaB_rawequal},
373    {&quot;rawget&quot;, luaB_rawget},
374    {&quot;rawset&quot;, luaB_rawset},
375    {&quot;select&quot;, luaB_select},
376    {&quot;setfenv&quot;, luaB_setfenv},
377    {&quot;setmetatable&quot;, luaB_setmetatable},
378    {&quot;tonumber&quot;, luaB_tonumber},
379    {&quot;tostring&quot;, luaB_tostring},
380    {&quot;type&quot;, luaB_type},
381    {&quot;unpack&quot;, luaB_unpack},
382    {&quot;xpcall&quot;, luaB_xpcall},
383    {NULL, NULL}
384  };
385  #define CO_RUN	0	&amp;bsol;* running */
386  #define CO_SUS	1	&amp;bsol;* suspended */
387  #define CO_NOR	2	&amp;bsol;* &#x27;normal&#x27; (it resumed another coroutine) */
388  #define CO_DEAD	3
389  static const char *const statnames[] =
390      {&quot;running&quot;, &quot;suspended&quot;, &quot;normal&quot;, &quot;dead&quot;};
391  static int costatus (lua_State *L, lua_State *co) {
392    if (L == co) return CO_RUN;
393    switch (lua_status(co)) {
394      case LUA_YIELD:
395        return CO_SUS;
396      case 0: {
397        lua_Debug ar;
398        if (lua_getstack(co, 0, &amp;ar) &gt; 0)  &amp;bsol;* does it have frames? */
399          return CO_NOR;  &amp;bsol;* it is running */
400        else if (lua_gettop(co) == 0)
401            return CO_DEAD;
402        else
403          return CO_SUS;  &amp;bsol;* initial state */
404      }
405      default:  &amp;bsol;* some error occured */
406        return CO_DEAD;
407    }
408  }
409  static int luaB_costatus (lua_State *L) {
410    lua_State *co = lua_tothread(L, 1);
411    luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
412    lua_pushstring(L, statnames[costatus(L, co)]);
413    return 1;
414  }
415  static int auxresume (lua_State *L, lua_State *co, int narg) {
416    int status = costatus(L, co);
417    if (!lua_checkstack(co, narg))
418      luaL_error(L, &quot;too many arguments to resume&quot;);
419    if (status != CO_SUS) {
420      lua_pushfstring(L, &quot;cannot resume %s coroutine&quot;, statnames[status]);
421      return -1;  &amp;bsol;* error flag */
422    }
423    lua_xmove(L, co, narg);
424    lua_setlevel(L, co);
425    status = lua_resume(co, narg);
426    if (status == 0 || status == LUA_YIELD) {
427      int nres = lua_gettop(co);
428      if (!lua_checkstack(L, nres + 1))
429        luaL_error(L, &quot;too many results to resume&quot;);
430      lua_xmove(co, L, nres);  &amp;bsol;* move yielded values */
431      return nres;
432    }
433    else {
434      lua_xmove(co, L, 1);  &amp;bsol;* move error message */
435      return -1;  &amp;bsol;* error flag */
436    }
437  }
438  static int luaB_coresume (lua_State *L) {
439    lua_State *co = lua_tothread(L, 1);
440    int r;
441    luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
442    r = auxresume(L, co, lua_gettop(L) - 1);
443    if (r &lt; 0) {
444      lua_pushboolean(L, 0);
445      lua_insert(L, -2);
446      return 2;  &amp;bsol;* return false + error message */
447    }
448    else {
449      lua_pushboolean(L, 1);
450      lua_insert(L, -(r + 1));
451      return r + 1;  &amp;bsol;* return true + `resume&#x27; returns */
452    }
453  }
454  static int luaB_auxwrap (lua_State *L) {
455    lua_State *co = lua_tothread(L, lua_upvalueindex(1));
456    int r = auxresume(L, co, lua_gettop(L));
457    if (r &lt; 0) {
458      if (lua_isstring(L, -1)) {  &amp;bsol;* error object is a string? */
459        luaL_where(L, 1);  &amp;bsol;* add extra info */
460        lua_insert(L, -2);
461        lua_concat(L, 2);
462      }
463      lua_error(L);  &amp;bsol;* propagate error */
464    }
465    return r;
466  }
467  static int luaB_cocreate (lua_State *L) {
468    lua_State *NL = lua_newthread(L);
469    luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1), 1,
470      &quot;Lua function expected&quot;);
471    lua_pushvalue(L, 1);  &amp;bsol;* move function to top */
472    lua_xmove(L, NL, 1);  &amp;bsol;* move function from L to NL */
473    return 1;
474  }
475  static int luaB_cowrap (lua_State *L) {
476    luaB_cocreate(L);
477    lua_pushcclosure(L, luaB_auxwrap, 1);
478    return 1;
479  }
480  static int luaB_yield (lua_State *L) {
481    return lua_yield(L, lua_gettop(L));
482  }
483  static int luaB_corunning (lua_State *L) {
484    if (lua_pushthread(L))
485      lua_pushnil(L);  &amp;bsol;* main thread is not a coroutine */
486    return 1;
487  }
488  static const luaL_Reg co_funcs[] = {
489    {&quot;create&quot;, luaB_cocreate},
490    {&quot;resume&quot;, luaB_coresume},
491    {&quot;running&quot;, luaB_corunning},
492    {&quot;status&quot;, luaB_costatus},
493    {&quot;wrap&quot;, luaB_cowrap},
494    {&quot;yield&quot;, luaB_yield},
495    {NULL, NULL}
496  };
497  static void auxopen (lua_State *L, const char *name,
498                       lua_CFunction f, lua_CFunction u) {
499    lua_pushcfunction(L, u);
500    lua_pushcclosure(L, f, 1);
501    lua_setfield(L, -2, name);
502  }
503  static void base_open (lua_State *L) {
504    lua_pushvalue(L, LUA_GLOBALSINDEX);
505    lua_setglobal(L, &quot;_G&quot;);
506    luaL_register(L, &quot;_G&quot;, base_funcs);
507    lua_pushliteral(L, LUA_VERSION);
508    lua_setglobal(L, &quot;_VERSION&quot;);  &amp;bsol;* set global _VERSION */
509    auxopen(L, &quot;ipairs&quot;, luaB_ipairs, ipairsaux);
510    auxopen(L, &quot;pairs&quot;, luaB_pairs, luaB_next);
511    lua_createtable(L, 0, 1);  &amp;bsol;* new table `w&#x27; */
512    lua_pushvalue(L, -1);  &amp;bsol;* `w&#x27; will be its own metatable */
513    lua_setmetatable(L, -2);
514    lua_pushliteral(L, &quot;kv&quot;);
515    lua_setfield(L, -2, &quot;__mode&quot;);  &amp;bsol;* metatable(w).__mode = &quot;kv&quot; */
516    lua_pushcclosure(L, luaB_newproxy, 1);
517    lua_setglobal(L, &quot;newproxy&quot;);  &amp;bsol;* set global `newproxy&#x27; */
518  }
519  LUALIB_API int luaopen_base (lua_State *L) {
520    base_open(L);
521    luaL_register(L, LUA_COLIBNAME, co_funcs);
522    return 2;
523  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lbaselib.c</h3>
            <pre><code>1  #include &lt;ctype.h&gt;
2  #include &lt;stdio.h&gt;
3  #include &lt;stdlib.h&gt;
4  #include &lt;string.h&gt;
5  #define lbaselib_c
6  #define LUA_LIB
7  #include &quot;lua.h&quot;
8  #include &quot;lauxlib.h&quot;
9  #include &quot;lualib.h&quot;
10  static int luaB_print (lua_State *L) {
11    int n = lua_gettop(L);  &amp;bsol;* number of arguments */
12    int i;
13    lua_getglobal(L, &quot;tostring&quot;);
14    for (i=1; i&lt;=n; i++) {
15      const char *s;
16      lua_pushvalue(L, -1);  &amp;bsol;* function to be called */
17      lua_pushvalue(L, i);   &amp;bsol;* value to print */
18      lua_call(L, 1, 1);
19      s = lua_tostring(L, -1);  &amp;bsol;* get result */
20      if (s == NULL)
21        return luaL_error(L, LUA_QL(&quot;tostring&quot;) &quot; must return a string to &quot;
22                             LUA_QL(&quot;print&quot;));
23      if (i&gt;1) fputs(&quot;\t&quot;, stdout);
24      fputs(s, stdout);
25      lua_pop(L, 1);  &amp;bsol;* pop result */
26    }
27    fputs(&quot;\n&quot;, stdout);
28    return 0;
29  }
30  static int luaB_tonumber (lua_State *L) {
31    int base = luaL_optint(L, 2, 10);
32    if (base == 10) {  &amp;bsol;* standard conversion */
33      luaL_checkany(L, 1);
34      if (lua_isnumber(L, 1)) {
35        lua_pushnumber(L, lua_tonumber(L, 1));
36        return 1;
37      }
38    }
39    else {
40      const char *s1 = luaL_checkstring(L, 1);
41      char *s2;
42      unsigned long n;
43      luaL_argcheck(L, 2 &lt;= base &amp;&amp; base &lt;= 36, 2, &quot;base out of range&quot;);
44      n = strtoul(s1, &amp;s2, base);
45      if (s1 != s2) {  &amp;bsol;* at least one valid digit? */
46        while (isspace((unsigned char)(*s2))) s2++;  &amp;bsol;* skip trailing spaces */
47        if (*s2 == &#x27;\0&#x27;) {  &amp;bsol;* no invalid trailing characters? */
48          lua_pushnumber(L, (lua_Number)n);
49          return 1;
50        }
51      }
52    }
53    lua_pushnil(L);  &amp;bsol;* else not a number */
54    return 1;
55  }
56  static int luaB_error (lua_State *L) {
57    int level = luaL_optint(L, 2, 1);
58    lua_settop(L, 1);
59    if (lua_isstring(L, 1) &amp;&amp; level &gt; 0) {  &amp;bsol;* add extra information? */
60      luaL_where(L, level);
61      lua_pushvalue(L, 1);
62      lua_concat(L, 2);
63    }
64    return lua_error(L);
65  }
66  static int luaB_getmetatable (lua_State *L) {
67    luaL_checkany(L, 1);
68    if (!lua_getmetatable(L, 1)) {
69      lua_pushnil(L);
70      return 1;  &amp;bsol;* no metatable */
71    }
72    luaL_getmetafield(L, 1, &quot;__metatable&quot;);
73    return 1;  &amp;bsol;* returns either __metatable field (if present) or metatable */
74  }
75  static int luaB_setmetatable (lua_State *L) {
76    int t = lua_type(L, 2);
77    luaL_checktype(L, 1, LUA_TTABLE);
78    luaL_argcheck(L, t == LUA_TNIL || t == LUA_TTABLE, 2,
79                      &quot;nil or table expected&quot;);
80    if (luaL_getmetafield(L, 1, &quot;__metatable&quot;))
81      luaL_error(L, &quot;cannot change a protected metatable&quot;);
82    lua_settop(L, 2);
83    lua_setmetatable(L, 1);
84    return 1;
85  }
86  static void getfunc (lua_State *L, int opt) {
87    if (lua_isfunction(L, 1)) lua_pushvalue(L, 1);
88    else {
89      lua_Debug ar;
90      int level = opt ? luaL_optint(L, 1, 1) : luaL_checkint(L, 1);
91      luaL_argcheck(L, level &gt;= 0, 1, &quot;level must be non-negative&quot;);
92      if (lua_getstack(L, level, &amp;ar) == 0)
93        luaL_argerror(L, 1, &quot;invalid level&quot;);
94      lua_getinfo(L, &quot;f&quot;, &amp;ar);
95      if (lua_isnil(L, -1))
96        luaL_error(L, &quot;no function environment for tail call at level %d&quot;,
97                      level);
98    }
99  }
100  static int luaB_getfenv (lua_State *L) {
101    getfunc(L, 1);
102    if (lua_iscfunction(L, -1))  &amp;bsol;* is a C function? */
103      lua_pushvalue(L, LUA_GLOBALSINDEX);  &amp;bsol;* return the thread&#x27;s global env. */
104    else
105      lua_getfenv(L, -1);
106    return 1;
107  }
108  static int luaB_setfenv (lua_State *L) {
109    luaL_checktype(L, 2, LUA_TTABLE);
110    getfunc(L, 0);
111    lua_pushvalue(L, 2);
112    if (lua_isnumber(L, 1) &amp;&amp; lua_tonumber(L, 1) == 0) {
113      lua_pushthread(L);
114      lua_insert(L, -2);
115      lua_setfenv(L, -2);
116      return 0;
117    }
118    else if (lua_iscfunction(L, -2) || lua_setfenv(L, -2) == 0)
119      luaL_error(L,
120            LUA_QL(&quot;setfenv&quot;) &quot; cannot change environment of given object&quot;);
121    return 1;
122  }
123  static int luaB_rawequal (lua_State *L) {
124    luaL_checkany(L, 1);
125    luaL_checkany(L, 2);
126    lua_pushboolean(L, lua_rawequal(L, 1, 2));
127    return 1;
128  }
129  static int luaB_rawget (lua_State *L) {
130    luaL_checktype(L, 1, LUA_TTABLE);
131    luaL_checkany(L, 2);
132    lua_settop(L, 2);
133    lua_rawget(L, 1);
134    return 1;
135  }
136  static int luaB_rawset (lua_State *L) {
137    luaL_checktype(L, 1, LUA_TTABLE);
138    luaL_checkany(L, 2);
139    luaL_checkany(L, 3);
140    lua_settop(L, 3);
141    lua_rawset(L, 1);
142    return 1;
143  }
144  static int luaB_gcinfo (lua_State *L) {
145    lua_pushinteger(L, lua_getgccount(L));
146    return 1;
147  }
148  static int luaB_collectgarbage (lua_State *L) {
149    static const char *const opts[] = {&quot;stop&quot;, &quot;restart&quot;, &quot;collect&quot;,
150      &quot;count&quot;, &quot;step&quot;, &quot;setpause&quot;, &quot;setstepmul&quot;, NULL};
151    static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
152      LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
153    int o = luaL_checkoption(L, 1, &quot;collect&quot;, opts);
154    int ex = luaL_optint(L, 2, 0);
155    int res = lua_gc(L, optsnum[o], ex);
156    switch (optsnum[o]) {
157      case LUA_GCCOUNT: {
158        int b = lua_gc(L, LUA_GCCOUNTB, 0);
159        lua_pushnumber(L, res + ((lua_Number)b/1024));
160        return 1;
161      }
162      case LUA_GCSTEP: {
163        lua_pushboolean(L, res);
164        return 1;
165      }
166      default: {
167        lua_pushnumber(L, res);
168        return 1;
169      }
170    }
171  }
172  static int luaB_type (lua_State *L) {
173    luaL_checkany(L, 1);
174    lua_pushstring(L, luaL_typename(L, 1));
175    return 1;
176  }
177  static int luaB_next (lua_State *L) {
178    luaL_checktype(L, 1, LUA_TTABLE);
179    lua_settop(L, 2);  &amp;bsol;* create a 2nd argument if there isn&#x27;t one */
180    if (lua_next(L, 1))
181      return 2;
182    else {
183      lua_pushnil(L);
184      return 1;
185    }
186  }
187  static int luaB_pairs (lua_State *L) {
188    luaL_checktype(L, 1, LUA_TTABLE);
189    lua_pushvalue(L, lua_upvalueindex(1));  &amp;bsol;* return generator, */
190    lua_pushvalue(L, 1);  &amp;bsol;* state, */
191    lua_pushnil(L);  &amp;bsol;* and initial value */
192    return 3;
193  }
194  static int ipairsaux (lua_State *L) {
195    int i = luaL_checkint(L, 2);
196    luaL_checktype(L, 1, LUA_TTABLE);
197    i++;  &amp;bsol;* next value */
198    lua_pushinteger(L, i);
199    lua_rawgeti(L, 1, i);
200    return (lua_isnil(L, -1)) ? 0 : 2;
201  }
202  static int luaB_ipairs (lua_State *L) {
203    luaL_checktype(L, 1, LUA_TTABLE);
204    lua_pushvalue(L, lua_upvalueindex(1));  &amp;bsol;* return generator, */
<span onclick='openModal()' class='match'>205    lua_pushvalue(L, 1);  &amp;bsol;* state, */
206    lua_pushinteger(L, 0);  &amp;bsol;* and initial value */
</span>207    return 3;
208  }
209  static int load_aux (lua_State *L, int status) {
210    if (status == 0)  &amp;bsol;* OK? */
211      return 1;
212    else {
213      lua_pushnil(L);
214      lua_insert(L, -2);  &amp;bsol;* put before error message */
215      return 2;  &amp;bsol;* return nil plus error message */
216    }
217  }
218  static int luaB_loadstring (lua_State *L) {
219    size_t l;
220    const char *s = luaL_checklstring(L, 1, &amp;l);
221    const char *chunkname = luaL_optstring(L, 2, s);
222    return load_aux(L, luaL_loadbuffer(L, s, l, chunkname));
223  }
224  static int luaB_loadfile (lua_State *L) {
225    const char *fname = luaL_optstring(L, 1, NULL);
226    return load_aux(L, luaL_loadfile(L, fname));
227  }
228  static const char *generic_reader (lua_State *L, void *ud, size_t *size) {
229    (void)ud;  &amp;bsol;* to avoid warnings */
230    luaL_checkstack(L, 2, &quot;too many nested functions&quot;);
231    lua_pushvalue(L, 1);  &amp;bsol;* get function */
232    lua_call(L, 0, 1);  &amp;bsol;* call it */
233    if (lua_isnil(L, -1)) {
234      *size = 0;
235      return NULL;
236    }
237    else if (lua_isstring(L, -1)) {
238      lua_replace(L, 3);  &amp;bsol;* save string in a reserved stack slot */
239      return lua_tolstring(L, 3, size);
240    }
241    else luaL_error(L, &quot;reader function must return a string&quot;);
242    return NULL;  &amp;bsol;* to avoid warnings */
243  }
244  static int luaB_load (lua_State *L) {
245    int status;
246    const char *cname = luaL_optstring(L, 2, &quot;=(load)&quot;);
247    luaL_checktype(L, 1, LUA_TFUNCTION);
248    lua_settop(L, 3);  &amp;bsol;* function, eventual name, plus one reserved slot */
249    status = lua_load(L, generic_reader, NULL, cname);
250    return load_aux(L, status);
251  }
252  static int luaB_dofile (lua_State *L) {
253    const char *fname = luaL_optstring(L, 1, NULL);
254    int n = lua_gettop(L);
255    if (luaL_loadfile(L, fname) != 0) lua_error(L);
256    lua_call(L, 0, LUA_MULTRET);
257    return lua_gettop(L) - n;
258  }
259  static int luaB_assert (lua_State *L) {
260    luaL_checkany(L, 1);
261    if (!lua_toboolean(L, 1))
262      return luaL_error(L, &quot;%s&quot;, luaL_optstring(L, 2, &quot;assertion failed!&quot;));
263    return lua_gettop(L);
264  }
265  static int luaB_unpack (lua_State *L) {
266    int i, e, n;
267    luaL_checktype(L, 1, LUA_TTABLE);
268    i = luaL_optint(L, 2, 1);
269    e = luaL_opt(L, luaL_checkint, 3, luaL_getn(L, 1));
270    if (i &gt; e) return 0;  &amp;bsol;* empty range */
271    n = e - i + 1;  &amp;bsol;* number of elements */
272    if (n &lt;= 0 || !lua_checkstack(L, n))  &amp;bsol;* n &lt;= 0 means arith. overflow */
273      return luaL_error(L, &quot;too many results to unpack&quot;);
274    lua_rawgeti(L, 1, i);  &amp;bsol;* push arg[i] (avoiding overflow problems) */
275    while (i++ &lt; e)  &amp;bsol;* push arg[i + 1...e] */
276      lua_rawgeti(L, 1, i);
277    return n;
278  }
279  static int luaB_select (lua_State *L) {
280    int n = lua_gettop(L);
281    if (lua_type(L, 1) == LUA_TSTRING &amp;&amp; *lua_tostring(L, 1) == &#x27;#&#x27;) {
282      lua_pushinteger(L, n-1);
283      return 1;
284    }
285    else {
286      int i = luaL_checkint(L, 1);
287      if (i &lt; 0) i = n + i;
288      else if (i &gt; n) i = n;
289      luaL_argcheck(L, 1 &lt;= i, 1, &quot;index out of range&quot;);
290      return n - i;
291    }
292  }
293  static int luaB_pcall (lua_State *L) {
294    int status;
295    luaL_checkany(L, 1);
296    status = lua_pcall(L, lua_gettop(L) - 1, LUA_MULTRET, 0);
297    lua_pushboolean(L, (status == 0));
298    lua_insert(L, 1);
299    return lua_gettop(L);  &amp;bsol;* return status + all results */
300  }
301  static int luaB_xpcall (lua_State *L) {
302    int status;
303    luaL_checkany(L, 2);
304    lua_settop(L, 2);
305    lua_insert(L, 1);  &amp;bsol;* put error function under function to be called */
306    status = lua_pcall(L, 0, LUA_MULTRET, 1);
307    lua_pushboolean(L, (status == 0));
308    lua_replace(L, 1);
309    return lua_gettop(L);  &amp;bsol;* return status + all results */
310  }
311  static int luaB_tostring (lua_State *L) {
312    luaL_checkany(L, 1);
313    if (luaL_callmeta(L, 1, &quot;__tostring&quot;))  &amp;bsol;* is there a metafield? */
314      return 1;  &amp;bsol;* use its value */
315    switch (lua_type(L, 1)) {
316      case LUA_TNUMBER:
317        lua_pushstring(L, lua_tostring(L, 1));
318        break;
319      case LUA_TSTRING:
320        lua_pushvalue(L, 1);
321        break;
322      case LUA_TBOOLEAN:
323        lua_pushstring(L, (lua_toboolean(L, 1) ? &quot;true&quot; : &quot;false&quot;));
324        break;
325      case LUA_TNIL:
326        lua_pushliteral(L, &quot;nil&quot;);
327        break;
328      default:
329        lua_pushfstring(L, &quot;%s: %p&quot;, luaL_typename(L, 1), lua_topointer(L, 1));
330        break;
331    }
332    return 1;
333  }
334  static int luaB_newproxy (lua_State *L) {
335    lua_settop(L, 1);
336    lua_newuserdata(L, 0);  &amp;bsol;* create proxy */
337    if (lua_toboolean(L, 1) == 0)
338      return 1;  &amp;bsol;* no metatable */
339    else if (lua_isboolean(L, 1)) {
340      lua_newtable(L);  &amp;bsol;* create a new metatable `m&#x27; ... */
341      lua_pushvalue(L, -1);  &amp;bsol;* ... and mark `m&#x27; as a valid metatable */
342      lua_pushboolean(L, 1);
343      lua_rawset(L, lua_upvalueindex(1));  &amp;bsol;* weaktable[m] = true */
344    }
345    else {
346      int validproxy = 0;  &amp;bsol;* to check if weaktable[metatable(u)] == true */
347      if (lua_getmetatable(L, 1)) {
348        lua_rawget(L, lua_upvalueindex(1));
349        validproxy = lua_toboolean(L, -1);
350        lua_pop(L, 1);  &amp;bsol;* remove value */
351      }
352      luaL_argcheck(L, validproxy, 1, &quot;boolean or proxy expected&quot;);
353      lua_getmetatable(L, 1);  &amp;bsol;* metatable is valid; get it */
354    }
355    lua_setmetatable(L, 2);
356    return 1;
357  }
358  static const luaL_Reg base_funcs[] = {
359    {&quot;assert&quot;, luaB_assert},
360    {&quot;collectgarbage&quot;, luaB_collectgarbage},
361    {&quot;dofile&quot;, luaB_dofile},
362    {&quot;error&quot;, luaB_error},
363    {&quot;gcinfo&quot;, luaB_gcinfo},
364    {&quot;getfenv&quot;, luaB_getfenv},
365    {&quot;getmetatable&quot;, luaB_getmetatable},
366    {&quot;loadfile&quot;, luaB_loadfile},
367    {&quot;load&quot;, luaB_load},
368    {&quot;loadstring&quot;, luaB_loadstring},
369    {&quot;next&quot;, luaB_next},
370    {&quot;pcall&quot;, luaB_pcall},
371    {&quot;print&quot;, luaB_print},
372    {&quot;rawequal&quot;, luaB_rawequal},
373    {&quot;rawget&quot;, luaB_rawget},
374    {&quot;rawset&quot;, luaB_rawset},
375    {&quot;select&quot;, luaB_select},
376    {&quot;setfenv&quot;, luaB_setfenv},
377    {&quot;setmetatable&quot;, luaB_setmetatable},
378    {&quot;tonumber&quot;, luaB_tonumber},
379    {&quot;tostring&quot;, luaB_tostring},
380    {&quot;type&quot;, luaB_type},
381    {&quot;unpack&quot;, luaB_unpack},
382    {&quot;xpcall&quot;, luaB_xpcall},
383    {NULL, NULL}
384  };
385  #define CO_RUN	0	&amp;bsol;* running */
386  #define CO_SUS	1	&amp;bsol;* suspended */
387  #define CO_NOR	2	&amp;bsol;* &#x27;normal&#x27; (it resumed another coroutine) */
388  #define CO_DEAD	3
389  static const char *const statnames[] =
390      {&quot;running&quot;, &quot;suspended&quot;, &quot;normal&quot;, &quot;dead&quot;};
391  static int costatus (lua_State *L, lua_State *co) {
392    if (L == co) return CO_RUN;
393    switch (lua_status(co)) {
394      case LUA_YIELD:
395        return CO_SUS;
396      case 0: {
397        lua_Debug ar;
398        if (lua_getstack(co, 0, &amp;ar) &gt; 0)  &amp;bsol;* does it have frames? */
399          return CO_NOR;  &amp;bsol;* it is running */
400        else if (lua_gettop(co) == 0)
401            return CO_DEAD;
402        else
403          return CO_SUS;  &amp;bsol;* initial state */
404      }
405      default:  &amp;bsol;* some error occured */
406        return CO_DEAD;
407    }
408  }
409  static int luaB_costatus (lua_State *L) {
410    lua_State *co = lua_tothread(L, 1);
411    luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
412    lua_pushstring(L, statnames[costatus(L, co)]);
413    return 1;
414  }
415  static int auxresume (lua_State *L, lua_State *co, int narg) {
416    int status = costatus(L, co);
417    if (!lua_checkstack(co, narg))
418      luaL_error(L, &quot;too many arguments to resume&quot;);
419    if (status != CO_SUS) {
420      lua_pushfstring(L, &quot;cannot resume %s coroutine&quot;, statnames[status]);
421      return -1;  &amp;bsol;* error flag */
422    }
423    lua_xmove(L, co, narg);
424    lua_setlevel(L, co);
425    status = lua_resume(co, narg);
426    if (status == 0 || status == LUA_YIELD) {
427      int nres = lua_gettop(co);
428      if (!lua_checkstack(L, nres + 1))
429        luaL_error(L, &quot;too many results to resume&quot;);
430      lua_xmove(co, L, nres);  &amp;bsol;* move yielded values */
431      return nres;
432    }
433    else {
434      lua_xmove(co, L, 1);  &amp;bsol;* move error message */
435      return -1;  &amp;bsol;* error flag */
436    }
437  }
438  static int luaB_coresume (lua_State *L) {
439    lua_State *co = lua_tothread(L, 1);
440    int r;
441    luaL_argcheck(L, co, 1, &quot;coroutine expected&quot;);
442    r = auxresume(L, co, lua_gettop(L) - 1);
443    if (r &lt; 0) {
444      lua_pushboolean(L, 0);
445      lua_insert(L, -2);
446      return 2;  &amp;bsol;* return false + error message */
447    }
448    else {
449      lua_pushboolean(L, 1);
450      lua_insert(L, -(r + 1));
451      return r + 1;  &amp;bsol;* return true + `resume&#x27; returns */
452    }
453  }
454  static int luaB_auxwrap (lua_State *L) {
455    lua_State *co = lua_tothread(L, lua_upvalueindex(1));
456    int r = auxresume(L, co, lua_gettop(L));
457    if (r &lt; 0) {
458      if (lua_isstring(L, -1)) {  &amp;bsol;* error object is a string? */
459        luaL_where(L, 1);  &amp;bsol;* add extra info */
460        lua_insert(L, -2);
461        lua_concat(L, 2);
462      }
463      lua_error(L);  &amp;bsol;* propagate error */
464    }
465    return r;
466  }
467  static int luaB_cocreate (lua_State *L) {
468    lua_State *NL = lua_newthread(L);
469    luaL_argcheck(L, lua_isfunction(L, 1) &amp;&amp; !lua_iscfunction(L, 1), 1,
470      &quot;Lua function expected&quot;);
471    lua_pushvalue(L, 1);  &amp;bsol;* move function to top */
472    lua_xmove(L, NL, 1);  &amp;bsol;* move function from L to NL */
473    return 1;
474  }
475  static int luaB_cowrap (lua_State *L) {
476    luaB_cocreate(L);
477    lua_pushcclosure(L, luaB_auxwrap, 1);
478    return 1;
479  }
480  static int luaB_yield (lua_State *L) {
481    return lua_yield(L, lua_gettop(L));
482  }
483  static int luaB_corunning (lua_State *L) {
484    if (lua_pushthread(L))
485      lua_pushnil(L);  &amp;bsol;* main thread is not a coroutine */
486    return 1;
487  }
488  static const luaL_Reg co_funcs[] = {
489    {&quot;create&quot;, luaB_cocreate},
490    {&quot;resume&quot;, luaB_coresume},
491    {&quot;running&quot;, luaB_corunning},
492    {&quot;status&quot;, luaB_costatus},
493    {&quot;wrap&quot;, luaB_cowrap},
494    {&quot;yield&quot;, luaB_yield},
495    {NULL, NULL}
496  };
497  static void auxopen (lua_State *L, const char *name,
498                       lua_CFunction f, lua_CFunction u) {
499    lua_pushcfunction(L, u);
500    lua_pushcclosure(L, f, 1);
501    lua_setfield(L, -2, name);
502  }
503  static void base_open (lua_State *L) {
504    lua_pushvalue(L, LUA_GLOBALSINDEX);
505    lua_setglobal(L, &quot;_G&quot;);
506    luaL_register(L, &quot;_G&quot;, base_funcs);
507    lua_pushliteral(L, LUA_VERSION);
508    lua_setglobal(L, &quot;_VERSION&quot;);  &amp;bsol;* set global _VERSION */
509    auxopen(L, &quot;ipairs&quot;, luaB_ipairs, ipairsaux);
510    auxopen(L, &quot;pairs&quot;, luaB_pairs, luaB_next);
511    lua_createtable(L, 0, 1);  &amp;bsol;* new table `w&#x27; */
512    lua_pushvalue(L, -1);  &amp;bsol;* `w&#x27; will be its own metatable */
513    lua_setmetatable(L, -2);
514    lua_pushliteral(L, &quot;kv&quot;);
515    lua_setfield(L, -2, &quot;__mode&quot;);  &amp;bsol;* metatable(w).__mode = &quot;kv&quot; */
516    lua_pushcclosure(L, luaB_newproxy, 1);
517    lua_setglobal(L, &quot;newproxy&quot;);  &amp;bsol;* set global `newproxy&#x27; */
518  }
519  LUALIB_API int luaopen_base (lua_State *L) {
520    base_open(L);
521    luaL_register(L, LUA_COLIBNAME, co_funcs);
522    return 2;
523  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lbaselib.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lbaselib.c</div>
                </div>
                <div class="column column_space"><pre><code>190    lua_pushvalue(L, 1);  &amp;bsol;* state, */
191    lua_pushnil(L);  &amp;bsol;* and initial value */
</pre></code></div>
                <div class="column column_space"><pre><code>205    lua_pushvalue(L, 1);  &amp;bsol;* state, */
206    lua_pushinteger(L, 0);  &amp;bsol;* and initial value */
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    