
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-emitter.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_EMITTER_H
2  #define JEMALLOC_INTERNAL_EMITTER_H
3  #include "jemalloc/internal/ql.h"
4  typedef enum emitter_output_e emitter_output_t;
5  enum emitter_output_e {
6  	emitter_output_json,
7  	emitter_output_table
8  };
9  typedef enum emitter_justify_e emitter_justify_t;
10  enum emitter_justify_e {
11  	emitter_justify_left,
12  	emitter_justify_right,
13  	emitter_justify_none
14  };
15  typedef enum emitter_type_e emitter_type_t;
16  enum emitter_type_e {
17  	emitter_type_bool,
18  	emitter_type_int,
19  	emitter_type_unsigned,
20  	emitter_type_uint32,
21  	emitter_type_uint64,
22  	emitter_type_size,
23  	emitter_type_ssize,
24  	emitter_type_string,
25  	emitter_type_title,
26  };
27  typedef struct emitter_col_s emitter_col_t;
28  struct emitter_col_s {
29  	emitter_justify_t justify;
30  	int width;
31  	emitter_type_t type;
32  	union {
33  		bool bool_val;
34  		int int_val;
35  		unsigned unsigned_val;
36  		uint32_t uint32_val;
37  		uint32_t uint32_t_val;
<span onclick='openModal()' class='match'>38  		uint64_t uint64_val;
39  		uint64_t uint64_t_val;
40  		size_t size_val;
41  		ssize_t ssize_val;
42  		const char *str_val;
43  	};
</span>44  	ql_elm(emitter_col_t) link;
45  };
46  typedef struct emitter_row_s emitter_row_t;
47  struct emitter_row_s {
48  	ql_head(emitter_col_t) cols;
49  };
50  typedef struct emitter_s emitter_t;
51  struct emitter_s {
52  	emitter_output_t output;
53  	void (*write_cb)(void *, const char *);
54  	void *cbopaque;
55  	int nesting_depth;
56  	bool item_at_depth;
57  	bool emitted_key;
58  };
59  JEMALLOC_FORMAT_PRINTF(2, 3)
60  static inline void
61  emitter_printf(emitter_t *emitter, const char *format, ...) {
62  	va_list ap;
63  	va_start(ap, format);
64  	malloc_vcprintf(emitter->write_cb, emitter->cbopaque, format, ap);
65  	va_end(ap);
66  }
67  static inline const char * JEMALLOC_FORMAT_ARG(3)
68  emitter_gen_fmt(char *out_fmt, size_t out_size, const char *fmt_specifier,
69      emitter_justify_t justify, int width) {
70  	size_t written;
71  	fmt_specifier++;
72  	if (justify == emitter_justify_none) {
73  		written = malloc_snprintf(out_fmt, out_size,
74  		    "%%%s", fmt_specifier);
75  	} else if (justify == emitter_justify_left) {
76  		written = malloc_snprintf(out_fmt, out_size,
77  		    "%%-%d%s", width, fmt_specifier);
78  	} else {
79  		written = malloc_snprintf(out_fmt, out_size,
80  		    "%%%d%s", width, fmt_specifier);
81  	}
82  	assert(written <  out_size);
83  	return out_fmt;
84  }
85  static inline void
86  emitter_print_value(emitter_t *emitter, emitter_justify_t justify, int width,
87      emitter_type_t value_type, const void *value) {
88  	size_t str_written;
89  #define BUF_SIZE 256
90  #define FMT_SIZE 10
91  	char fmt[FMT_SIZE];
92  	char buf[BUF_SIZE];
93  #define EMIT_SIMPLE(type, format)					\
94  	emitter_printf(emitter,						\
95  	    emitter_gen_fmt(fmt, FMT_SIZE, format, justify, width),	\
96  	    *(const type *)value);
97  	switch (value_type) {
98  	case emitter_type_bool:
99  		emitter_printf(emitter, 
100  		    emitter_gen_fmt(fmt, FMT_SIZE, "%s", justify, width),
101  		    *(const bool *)value ?  "true" : "false");
102  		break;
103  	case emitter_type_int:
104  		EMIT_SIMPLE(int, "%d")
105  		break;
106  	case emitter_type_unsigned:
107  		EMIT_SIMPLE(unsigned, "%u")
108  		break;
109  	case emitter_type_ssize:
110  		EMIT_SIMPLE(ssize_t, "%zd")
111  		break;
112  	case emitter_type_size:
113  		EMIT_SIMPLE(size_t, "%zu")
114  		break;
115  	case emitter_type_string:
116  		str_written = malloc_snprintf(buf, BUF_SIZE, "\"%s\"",
117  		    *(const char *const *)value);
118  		assert(str_written < BUF_SIZE);
119  		emitter_printf(emitter, 
120  		    emitter_gen_fmt(fmt, FMT_SIZE, "%s", justify, width), buf);
121  		break;
122  	case emitter_type_uint32:
123  		EMIT_SIMPLE(uint32_t, "%" FMTu32)
124  		break;
125  	case emitter_type_uint64:
126  		EMIT_SIMPLE(uint64_t, "%" FMTu64)
127  		break;
128  	case emitter_type_title:
129  		EMIT_SIMPLE(char *const, "%s");
130  		break;
131  	default:
132  		unreachable();
133  	}
134  #undef BUF_SIZE
135  #undef FMT_SIZE
136  }
137  static inline void
138  emitter_nest_inc(emitter_t *emitter) {
139  	emitter->nesting_depth++;
140  	emitter->item_at_depth = false;
141  }
142  static inline void
143  emitter_nest_dec(emitter_t *emitter) {
144  	emitter->nesting_depth--;
145  	emitter->item_at_depth = true;
146  }
147  static inline void
148  emitter_indent(emitter_t *emitter) {
149  	int amount = emitter->nesting_depth;
150  	const char *indent_str;
151  	if (emitter->output == emitter_output_json) {
152  		indent_str = "\t";
153  	} else {
154  		amount *= 2;
155  		indent_str = " ";
156  	}
157  	for (int i = 0; i < amount; i++) {
158  		emitter_printf(emitter, "%s", indent_str);
159  	}
160  }
161  static inline void
162  emitter_json_key_prefix(emitter_t *emitter) {
163  	if (emitter->emitted_key) {
164  		emitter->emitted_key = false;
165  		return;
166  	}
167  	emitter_printf(emitter, "%s\n", emitter->item_at_depth ? "," : "");
168  	emitter_indent(emitter);
169  }
170  static inline void
171  emitter_init(emitter_t *emitter, emitter_output_t emitter_output,
172      void (*write_cb)(void *, const char *), void *cbopaque) {
173  	emitter->output = emitter_output;
174  	emitter->write_cb = write_cb;
175  	emitter->cbopaque = cbopaque;
176  	emitter->item_at_depth = false;
177  	emitter->emitted_key = false; 
178  	emitter->nesting_depth = 0;
179  }
180  static inline void
181  emitter_json_key(emitter_t *emitter, const char *json_key) {
182  	if (emitter->output == emitter_output_json) {
183  		emitter_json_key_prefix(emitter);
184  		emitter_printf(emitter, "\"%s\": ", json_key);
185  		emitter->emitted_key = true;
186  	}
187  }
188  static inline void
189  emitter_json_value(emitter_t *emitter, emitter_type_t value_type,
190      const void *value) {
191  	if (emitter->output == emitter_output_json) {
192  		emitter_json_key_prefix(emitter);
193  		emitter_print_value(emitter, emitter_justify_none, -1,
194  		    value_type, value);
195  		emitter->item_at_depth = true;
196  	}
197  }
198  static inline void
199  emitter_json_kv(emitter_t *emitter, const char *json_key,
200      emitter_type_t value_type, const void *value) {
201  	emitter_json_key(emitter, json_key);
202  	emitter_json_value(emitter, value_type, value);
203  }
204  static inline void
205  emitter_json_array_begin(emitter_t *emitter) {
206  	if (emitter->output == emitter_output_json) {
207  		emitter_json_key_prefix(emitter);
208  		emitter_printf(emitter, "[");
209  		emitter_nest_inc(emitter);
210  	}
211  }
212  static inline void
213  emitter_json_array_kv_begin(emitter_t *emitter, const char *json_key) {
214  	emitter_json_key(emitter, json_key);
215  	emitter_json_array_begin(emitter);
216  }
217  static inline void
218  emitter_json_array_end(emitter_t *emitter) {
219  	if (emitter->output == emitter_output_json) {
220  		assert(emitter->nesting_depth > 0);
221  		emitter_nest_dec(emitter);
222  		emitter_printf(emitter, "\n");
223  		emitter_indent(emitter);
224  		emitter_printf(emitter, "]");
225  	}
226  }
227  static inline void
228  emitter_json_object_begin(emitter_t *emitter) {
229  	if (emitter->output == emitter_output_json) {
230  		emitter_json_key_prefix(emitter);
231  		emitter_printf(emitter, "{");
232  		emitter_nest_inc(emitter);
233  	}
234  }
235  static inline void
236  emitter_json_object_kv_begin(emitter_t *emitter, const char *json_key) {
237  	emitter_json_key(emitter, json_key);
238  	emitter_json_object_begin(emitter);
239  }
240  static inline void
241  emitter_json_object_end(emitter_t *emitter) {
242  	if (emitter->output == emitter_output_json) {
243  		assert(emitter->nesting_depth > 0);
244  		emitter_nest_dec(emitter);
245  		emitter_printf(emitter, "\n");
246  		emitter_indent(emitter);
247  		emitter_printf(emitter, "}");
248  	}
249  }
250  static inline void
251  emitter_table_dict_begin(emitter_t *emitter, const char *table_key) {
252  	if (emitter->output == emitter_output_table) {
253  		emitter_indent(emitter);
254  		emitter_printf(emitter, "%s\n", table_key);
255  		emitter_nest_inc(emitter);
256  	}
257  }
258  static inline void
259  emitter_table_dict_end(emitter_t *emitter) {
260  	if (emitter->output == emitter_output_table) {
261  		emitter_nest_dec(emitter);
262  	}
263  }
264  static inline void
265  emitter_table_kv_note(emitter_t *emitter, const char *table_key,
266      emitter_type_t value_type, const void *value,
267      const char *table_note_key, emitter_type_t table_note_value_type,
268      const void *table_note_value) {
269  	if (emitter->output == emitter_output_table) {
270  		emitter_indent(emitter);
271  		emitter_printf(emitter, "%s: ", table_key);
272  		emitter_print_value(emitter, emitter_justify_none, -1,
273  		    value_type, value);
274  		if (table_note_key != NULL) {
275  			emitter_printf(emitter, " (%s: ", table_note_key);
276  			emitter_print_value(emitter, emitter_justify_none, -1,
277  			    table_note_value_type, table_note_value);
278  			emitter_printf(emitter, ")");
279  		}
280  		emitter_printf(emitter, "\n");
281  	}
282  	emitter->item_at_depth = true;
283  }
284  static inline void
285  emitter_table_kv(emitter_t *emitter, const char *table_key,
286      emitter_type_t value_type, const void *value) {
287  	emitter_table_kv_note(emitter, table_key, value_type, value, NULL,
288  	    emitter_type_bool, NULL);
289  }
290  JEMALLOC_FORMAT_PRINTF(2, 3)
291  static inline void
292  emitter_table_printf(emitter_t *emitter, const char *format, ...) {
293  	if (emitter->output == emitter_output_table) {
294  		va_list ap;
295  		va_start(ap, format);
296  		malloc_vcprintf(emitter->write_cb, emitter->cbopaque, format, ap);
297  		va_end(ap);
298  	}
299  }
300  static inline void
301  emitter_table_row(emitter_t *emitter, emitter_row_t *row) {
302  	if (emitter->output != emitter_output_table) {
303  		return;
304  	}
305  	emitter_col_t *col;
306  	ql_foreach(col, &row->cols, link) {
307  		emitter_print_value(emitter, col->justify, col->width,
308  		    col->type, (const void *)&col->bool_val);
309  	}
310  	emitter_table_printf(emitter, "\n");
311  }
312  static inline void
313  emitter_row_init(emitter_row_t *row) {
314  	ql_new(&row->cols);
315  }
316  static inline void
317  emitter_col_init(emitter_col_t *col, emitter_row_t *row) {
318  	ql_elm_new(col, link);
319  	ql_tail_insert(&row->cols, col, link);
320  }
321  static inline void
322  emitter_kv_note(emitter_t *emitter, const char *json_key, const char *table_key,
323      emitter_type_t value_type, const void *value,
324      const char *table_note_key, emitter_type_t table_note_value_type,
325      const void *table_note_value) {
326  	if (emitter->output == emitter_output_json) {
327  		emitter_json_key(emitter, json_key);
328  		emitter_json_value(emitter, value_type, value);
329  	} else {
330  		emitter_table_kv_note(emitter, table_key, value_type, value,
331  		    table_note_key, table_note_value_type, table_note_value);
332  	}
333  	emitter->item_at_depth = true;
334  }
335  static inline void
336  emitter_kv(emitter_t *emitter, const char *json_key, const char *table_key,
337      emitter_type_t value_type, const void *value) {
338  	emitter_kv_note(emitter, json_key, table_key, value_type, value, NULL,
339  	    emitter_type_bool, NULL);
340  }
341  static inline void
342  emitter_dict_begin(emitter_t *emitter, const char *json_key,
343      const char *table_header) {
344  	if (emitter->output == emitter_output_json) {
345  		emitter_json_key(emitter, json_key);
346  		emitter_json_object_begin(emitter);
347  	} else {
348  		emitter_table_dict_begin(emitter, table_header);
349  	}
350  }
351  static inline void
352  emitter_dict_end(emitter_t *emitter) {
353  	if (emitter->output == emitter_output_json) {
354  		emitter_json_object_end(emitter);
355  	} else {
356  		emitter_table_dict_end(emitter);
357  	}
358  }
359  static inline void
360  emitter_begin(emitter_t *emitter) {
361  	if (emitter->output == emitter_output_json) {
362  		assert(emitter->nesting_depth == 0);
363  		emitter_printf(emitter, "{");
364  		emitter_nest_inc(emitter);
365  	} else {
366  		emitter_printf(emitter, "%s", "");
367  	}
368  }
369  static inline void
370  emitter_end(emitter_t *emitter) {
371  	if (emitter->output == emitter_output_json) {
372  		assert(emitter->nesting_depth == 1);
373  		emitter_nest_dec(emitter);
374  		emitter_printf(emitter, "\n}\n");
375  	}
376  }
377  #endif &bsol;* JEMALLOC_INTERNAL_EMITTER_H */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-emitter.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_EMITTER_H
2  #define JEMALLOC_INTERNAL_EMITTER_H
3  #include "jemalloc/internal/ql.h"
4  typedef enum emitter_output_e emitter_output_t;
5  enum emitter_output_e {
6  	emitter_output_json,
7  	emitter_output_table
8  };
9  typedef enum emitter_justify_e emitter_justify_t;
10  enum emitter_justify_e {
11  	emitter_justify_left,
12  	emitter_justify_right,
13  	emitter_justify_none
14  };
15  typedef enum emitter_type_e emitter_type_t;
16  enum emitter_type_e {
17  	emitter_type_bool,
18  	emitter_type_int,
19  	emitter_type_unsigned,
20  	emitter_type_uint32,
21  	emitter_type_uint64,
22  	emitter_type_size,
23  	emitter_type_ssize,
24  	emitter_type_string,
25  	emitter_type_title,
26  };
27  typedef struct emitter_col_s emitter_col_t;
28  struct emitter_col_s {
29  	emitter_justify_t justify;
30  	int width;
31  	emitter_type_t type;
32  	union {
33  		bool bool_val;
34  		int int_val;
35  		unsigned unsigned_val;
36  		uint32_t uint32_val;
37  		uint32_t uint32_t_val;
<span onclick='openModal()' class='match'>38  		uint64_t uint64_val;
39  		uint64_t uint64_t_val;
40  		size_t size_val;
41  		ssize_t ssize_val;
42  		const char *str_val;
43  	};
</span>44  	ql_elm(emitter_col_t) link;
45  };
46  typedef struct emitter_row_s emitter_row_t;
47  struct emitter_row_s {
48  	ql_head(emitter_col_t) cols;
49  };
50  typedef struct emitter_s emitter_t;
51  struct emitter_s {
52  	emitter_output_t output;
53  	void (*write_cb)(void *, const char *);
54  	void *cbopaque;
55  	int nesting_depth;
56  	bool item_at_depth;
57  	bool emitted_key;
58  };
59  JEMALLOC_FORMAT_PRINTF(2, 3)
60  static inline void
61  emitter_printf(emitter_t *emitter, const char *format, ...) {
62  	va_list ap;
63  	va_start(ap, format);
64  	malloc_vcprintf(emitter->write_cb, emitter->cbopaque, format, ap);
65  	va_end(ap);
66  }
67  static inline const char * JEMALLOC_FORMAT_ARG(3)
68  emitter_gen_fmt(char *out_fmt, size_t out_size, const char *fmt_specifier,
69      emitter_justify_t justify, int width) {
70  	size_t written;
71  	fmt_specifier++;
72  	if (justify == emitter_justify_none) {
73  		written = malloc_snprintf(out_fmt, out_size,
74  		    "%%%s", fmt_specifier);
75  	} else if (justify == emitter_justify_left) {
76  		written = malloc_snprintf(out_fmt, out_size,
77  		    "%%-%d%s", width, fmt_specifier);
78  	} else {
79  		written = malloc_snprintf(out_fmt, out_size,
80  		    "%%%d%s", width, fmt_specifier);
81  	}
82  	assert(written <  out_size);
83  	return out_fmt;
84  }
85  static inline void
86  emitter_print_value(emitter_t *emitter, emitter_justify_t justify, int width,
87      emitter_type_t value_type, const void *value) {
88  	size_t str_written;
89  #define BUF_SIZE 256
90  #define FMT_SIZE 10
91  	char fmt[FMT_SIZE];
92  	char buf[BUF_SIZE];
93  #define EMIT_SIMPLE(type, format)					\
94  	emitter_printf(emitter,						\
95  	    emitter_gen_fmt(fmt, FMT_SIZE, format, justify, width),	\
96  	    *(const type *)value);
97  	switch (value_type) {
98  	case emitter_type_bool:
99  		emitter_printf(emitter, 
100  		    emitter_gen_fmt(fmt, FMT_SIZE, "%s", justify, width),
101  		    *(const bool *)value ?  "true" : "false");
102  		break;
103  	case emitter_type_int:
104  		EMIT_SIMPLE(int, "%d")
105  		break;
106  	case emitter_type_unsigned:
107  		EMIT_SIMPLE(unsigned, "%u")
108  		break;
109  	case emitter_type_ssize:
110  		EMIT_SIMPLE(ssize_t, "%zd")
111  		break;
112  	case emitter_type_size:
113  		EMIT_SIMPLE(size_t, "%zu")
114  		break;
115  	case emitter_type_string:
116  		str_written = malloc_snprintf(buf, BUF_SIZE, "\"%s\"",
117  		    *(const char *const *)value);
118  		assert(str_written < BUF_SIZE);
119  		emitter_printf(emitter, 
120  		    emitter_gen_fmt(fmt, FMT_SIZE, "%s", justify, width), buf);
121  		break;
122  	case emitter_type_uint32:
123  		EMIT_SIMPLE(uint32_t, "%" FMTu32)
124  		break;
125  	case emitter_type_uint64:
126  		EMIT_SIMPLE(uint64_t, "%" FMTu64)
127  		break;
128  	case emitter_type_title:
129  		EMIT_SIMPLE(char *const, "%s");
130  		break;
131  	default:
132  		unreachable();
133  	}
134  #undef BUF_SIZE
135  #undef FMT_SIZE
136  }
137  static inline void
138  emitter_nest_inc(emitter_t *emitter) {
139  	emitter->nesting_depth++;
140  	emitter->item_at_depth = false;
141  }
142  static inline void
143  emitter_nest_dec(emitter_t *emitter) {
144  	emitter->nesting_depth--;
145  	emitter->item_at_depth = true;
146  }
147  static inline void
148  emitter_indent(emitter_t *emitter) {
149  	int amount = emitter->nesting_depth;
150  	const char *indent_str;
151  	if (emitter->output == emitter_output_json) {
152  		indent_str = "\t";
153  	} else {
154  		amount *= 2;
155  		indent_str = " ";
156  	}
157  	for (int i = 0; i < amount; i++) {
158  		emitter_printf(emitter, "%s", indent_str);
159  	}
160  }
161  static inline void
162  emitter_json_key_prefix(emitter_t *emitter) {
163  	if (emitter->emitted_key) {
164  		emitter->emitted_key = false;
165  		return;
166  	}
167  	emitter_printf(emitter, "%s\n", emitter->item_at_depth ? "," : "");
168  	emitter_indent(emitter);
169  }
170  static inline void
171  emitter_init(emitter_t *emitter, emitter_output_t emitter_output,
172      void (*write_cb)(void *, const char *), void *cbopaque) {
173  	emitter->output = emitter_output;
174  	emitter->write_cb = write_cb;
175  	emitter->cbopaque = cbopaque;
176  	emitter->item_at_depth = false;
177  	emitter->emitted_key = false; 
178  	emitter->nesting_depth = 0;
179  }
180  static inline void
181  emitter_json_key(emitter_t *emitter, const char *json_key) {
182  	if (emitter->output == emitter_output_json) {
183  		emitter_json_key_prefix(emitter);
184  		emitter_printf(emitter, "\"%s\": ", json_key);
185  		emitter->emitted_key = true;
186  	}
187  }
188  static inline void
189  emitter_json_value(emitter_t *emitter, emitter_type_t value_type,
190      const void *value) {
191  	if (emitter->output == emitter_output_json) {
192  		emitter_json_key_prefix(emitter);
193  		emitter_print_value(emitter, emitter_justify_none, -1,
194  		    value_type, value);
195  		emitter->item_at_depth = true;
196  	}
197  }
198  static inline void
199  emitter_json_kv(emitter_t *emitter, const char *json_key,
200      emitter_type_t value_type, const void *value) {
201  	emitter_json_key(emitter, json_key);
202  	emitter_json_value(emitter, value_type, value);
203  }
204  static inline void
205  emitter_json_array_begin(emitter_t *emitter) {
206  	if (emitter->output == emitter_output_json) {
207  		emitter_json_key_prefix(emitter);
208  		emitter_printf(emitter, "[");
209  		emitter_nest_inc(emitter);
210  	}
211  }
212  static inline void
213  emitter_json_array_kv_begin(emitter_t *emitter, const char *json_key) {
214  	emitter_json_key(emitter, json_key);
215  	emitter_json_array_begin(emitter);
216  }
217  static inline void
218  emitter_json_array_end(emitter_t *emitter) {
219  	if (emitter->output == emitter_output_json) {
220  		assert(emitter->nesting_depth > 0);
221  		emitter_nest_dec(emitter);
222  		emitter_printf(emitter, "\n");
223  		emitter_indent(emitter);
224  		emitter_printf(emitter, "]");
225  	}
226  }
227  static inline void
228  emitter_json_object_begin(emitter_t *emitter) {
229  	if (emitter->output == emitter_output_json) {
230  		emitter_json_key_prefix(emitter);
231  		emitter_printf(emitter, "{");
232  		emitter_nest_inc(emitter);
233  	}
234  }
235  static inline void
236  emitter_json_object_kv_begin(emitter_t *emitter, const char *json_key) {
237  	emitter_json_key(emitter, json_key);
238  	emitter_json_object_begin(emitter);
239  }
240  static inline void
241  emitter_json_object_end(emitter_t *emitter) {
242  	if (emitter->output == emitter_output_json) {
243  		assert(emitter->nesting_depth > 0);
244  		emitter_nest_dec(emitter);
245  		emitter_printf(emitter, "\n");
246  		emitter_indent(emitter);
247  		emitter_printf(emitter, "}");
248  	}
249  }
250  static inline void
251  emitter_table_dict_begin(emitter_t *emitter, const char *table_key) {
252  	if (emitter->output == emitter_output_table) {
253  		emitter_indent(emitter);
254  		emitter_printf(emitter, "%s\n", table_key);
255  		emitter_nest_inc(emitter);
256  	}
257  }
258  static inline void
259  emitter_table_dict_end(emitter_t *emitter) {
260  	if (emitter->output == emitter_output_table) {
261  		emitter_nest_dec(emitter);
262  	}
263  }
264  static inline void
265  emitter_table_kv_note(emitter_t *emitter, const char *table_key,
266      emitter_type_t value_type, const void *value,
267      const char *table_note_key, emitter_type_t table_note_value_type,
268      const void *table_note_value) {
269  	if (emitter->output == emitter_output_table) {
270  		emitter_indent(emitter);
271  		emitter_printf(emitter, "%s: ", table_key);
272  		emitter_print_value(emitter, emitter_justify_none, -1,
273  		    value_type, value);
274  		if (table_note_key != NULL) {
275  			emitter_printf(emitter, " (%s: ", table_note_key);
276  			emitter_print_value(emitter, emitter_justify_none, -1,
277  			    table_note_value_type, table_note_value);
278  			emitter_printf(emitter, ")");
279  		}
280  		emitter_printf(emitter, "\n");
281  	}
282  	emitter->item_at_depth = true;
283  }
284  static inline void
285  emitter_table_kv(emitter_t *emitter, const char *table_key,
286      emitter_type_t value_type, const void *value) {
287  	emitter_table_kv_note(emitter, table_key, value_type, value, NULL,
288  	    emitter_type_bool, NULL);
289  }
290  JEMALLOC_FORMAT_PRINTF(2, 3)
291  static inline void
292  emitter_table_printf(emitter_t *emitter, const char *format, ...) {
293  	if (emitter->output == emitter_output_table) {
294  		va_list ap;
295  		va_start(ap, format);
296  		malloc_vcprintf(emitter->write_cb, emitter->cbopaque, format, ap);
297  		va_end(ap);
298  	}
299  }
300  static inline void
301  emitter_table_row(emitter_t *emitter, emitter_row_t *row) {
302  	if (emitter->output != emitter_output_table) {
303  		return;
304  	}
305  	emitter_col_t *col;
306  	ql_foreach(col, &row->cols, link) {
307  		emitter_print_value(emitter, col->justify, col->width,
308  		    col->type, (const void *)&col->bool_val);
309  	}
310  	emitter_table_printf(emitter, "\n");
311  }
312  static inline void
313  emitter_row_init(emitter_row_t *row) {
314  	ql_new(&row->cols);
315  }
316  static inline void
317  emitter_col_init(emitter_col_t *col, emitter_row_t *row) {
318  	ql_elm_new(col, link);
319  	ql_tail_insert(&row->cols, col, link);
320  }
321  static inline void
322  emitter_kv_note(emitter_t *emitter, const char *json_key, const char *table_key,
323      emitter_type_t value_type, const void *value,
324      const char *table_note_key, emitter_type_t table_note_value_type,
325      const void *table_note_value) {
326  	if (emitter->output == emitter_output_json) {
327  		emitter_json_key(emitter, json_key);
328  		emitter_json_value(emitter, value_type, value);
329  	} else {
330  		emitter_table_kv_note(emitter, table_key, value_type, value,
331  		    table_note_key, table_note_value_type, table_note_value);
332  	}
333  	emitter->item_at_depth = true;
334  }
335  static inline void
336  emitter_kv(emitter_t *emitter, const char *json_key, const char *table_key,
337      emitter_type_t value_type, const void *value) {
338  	emitter_kv_note(emitter, json_key, table_key, value_type, value, NULL,
339  	    emitter_type_bool, NULL);
340  }
341  static inline void
342  emitter_dict_begin(emitter_t *emitter, const char *json_key,
343      const char *table_header) {
344  	if (emitter->output == emitter_output_json) {
345  		emitter_json_key(emitter, json_key);
346  		emitter_json_object_begin(emitter);
347  	} else {
348  		emitter_table_dict_begin(emitter, table_header);
349  	}
350  }
351  static inline void
352  emitter_dict_end(emitter_t *emitter) {
353  	if (emitter->output == emitter_output_json) {
354  		emitter_json_object_end(emitter);
355  	} else {
356  		emitter_table_dict_end(emitter);
357  	}
358  }
359  static inline void
360  emitter_begin(emitter_t *emitter) {
361  	if (emitter->output == emitter_output_json) {
362  		assert(emitter->nesting_depth == 0);
363  		emitter_printf(emitter, "{");
364  		emitter_nest_inc(emitter);
365  	} else {
366  		emitter_printf(emitter, "%s", "");
367  	}
368  }
369  static inline void
370  emitter_end(emitter_t *emitter) {
371  	if (emitter->output == emitter_output_json) {
372  		assert(emitter->nesting_depth == 1);
373  		emitter_nest_dec(emitter);
374  		emitter_printf(emitter, "\n}\n");
375  	}
376  }
377  #endif &bsol;* JEMALLOC_INTERNAL_EMITTER_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-emitter.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-emitter.h</div>
                </div>
                <div class="column column_space"><pre><code>38  		uint64_t uint64_val;
39  		uint64_t uint64_t_val;
40  		size_t size_val;
41  		ssize_t ssize_val;
42  		const char *str_val;
43  	};
</pre></code></div>
                <div class="column column_space"><pre><code>38  		uint64_t uint64_val;
39  		uint64_t uint64_t_val;
40  		size_t size_val;
41  		ssize_t ssize_val;
42  		const char *str_val;
43  	};
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    