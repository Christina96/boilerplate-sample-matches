<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for imkafka.c &amp; mmdarwin.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for imkafka.c &amp; mmdarwin.c
      </h3>
<h1 align="center">
        11.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>imkafka.c (11.147012%)<th>mmdarwin.c (10.900474%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(128-150)<td><a href="#" name="0">(105-126)</a><td align="center"><font color="#ff0000">37</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(615-631)<td><a href="#" name="1">(590-609)</a><td align="center"><font color="#820000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(521-538)<td><a href="#" name="2">(641-655)</a><td align="center"><font color="#590000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imkafka.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;fcntl.h&gt;
9 #include &lt;pthread.h&gt;
10 #include &lt;sys/uio.h&gt;
11 #include &lt;librdkafka/rdkafka.h&gt;
12 #include "rsyslog.h"
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "atomic.h"
20 #include "statsobj.h"
21 #include "unicode-helper.h"
22 #include "prop.h"
23 #include "ruleset.h"
24 #include "glbl.h"
25 #include "cfsysline.h"
26 #include "msg.h"
27 #include "dirty.h"
28 MODULE_TYPE_INPUT
29 MODULE_TYPE_NOKEEP
30 MODULE_CNFNAME("imkafka")
31 DEF_IMOD_STATIC_DATA
32 DEFobjCurrIf(prop)
33 DEFobjCurrIf(ruleset)
34 DEFobjCurrIf(glbl)
35 DEFobjCurrIf(statsobj)
36 static void * imkafkawrkr(void *myself);
37 struct kafka_params {
38 	const char *name;
39 	const char *val;
40 };
41 static struct configSettings_s {
42 	uchar *topic;
43 	uchar *consumergroup;
44 	char *brokers;
45 	uchar *pszBindRuleset;
46 	int nConfParams;
47 	struct kafka_params *confParams;
48 } cs;
49 struct instanceConf_s {
50 	uchar *topic;
51 	uchar *consumergroup;
52 	char *brokers;
53 	int64_t offset;
54 	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;			int bReportErrs;
55 	int nConfParams;
56 	struct kafka_params *confParams;
57 	int bIsConnected;
58 	rd_kafka_conf_t *conf;
59 	rd_kafka_t *rk;
60 	rd_kafka_topic_conf_t *topic_conf;
61 	int partition;
62 	int bIsSubscribed;
63 	int nMsgParsingFlags;
64 	struct instanceConf_s *next;
65 };
66 struct modConfData_s {
67 	rsconf_t *pConf;			uchar *topic;
68 	uchar *consumergroup;
69 	char *brokers;
70 	instanceConf_t *root, *tail;
71 	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;		};
72 pthread_attr_t wrkrThrdAttr;	static int activeKafkaworkers = 0;
73 static struct kafkaWrkrInfo_s {
74 	pthread_t tid;			instanceConf_t *inst;	<a name="0"></a>} *kafkaWrkrInfo;
75 static modConfData_t *loadModConf = NULL;<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static modConfData_t *runModConf = NULL;
76 static prop_t *pInputName = NULL;
77 static struct cnfparamdescr modpdescr[] = {
78 	{ "ruleset", eCmdHdlrGetWord, 0 },
79 };
80 static struct cnfparamblk modpblk =
81 	{ CNFPARAMBLK_VERSION,
82 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
83 	  modpdescr
84 	};
85 static struct cnfparamdescr inppdescr[] = {
86 	{ "topic", eCmdHdlrString, CNFPARAM_REQUIRED },
87 	{ "broker", eCmdHdlrArray, 0 },
88 	{ "confparam", eCmdHdlrArray, 0 },
89 	{ "consumergroup", eCmdHdlrString, 0},
90 	{ "ruleset", eCmdHdlrString, 0 },
91 	{ "parsehostname", eCmdHdlrBinary, 0 },</b></font>
92 };
93 static struct cnfparamblk inppblk =
94 	{ CNFPARAMBLK_VERSION,
95 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
96 	  inppdescr
97 	};
98 #include "im-helper.h" 
99 static void
100 kafkaLogger(const rd_kafka_t __attribute__((unused)) *rk, int level,
101 	    const char *fac, const char *buf)
102 {
103 	DBGPRINTF("imkafka: kafka log message [%d,%s]: %s\n",
104 		  level, fac, buf);
105 }
106 static rsRetVal enqMsg(instanceConf_t *const __restrict__ inst,
107 			rd_kafka_message_t *const __restrict__ rkmessage)
108 {
109 	DEFiRet;
110 	smsg_t *pMsg;
111 	if((int)rkmessage-&gt;len == 0) {
112 		FINALIZE;
113 	}
114 DBGPRINTF("imkafka: enqMsg: Msg: %.*s\n", (int)rkmessage-&gt;len, (char *)rkmessage-&gt;payload);
115 	CHKiRet(msgConstruct(&amp;pMsg));
116 	MsgSetInputName(pMsg, pInputName);
117 	MsgSetRawMsg(pMsg, (char*)rkmessage-&gt;payload, (int)rkmessage-&gt;len);
118 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
119 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
120 	pMsg-&gt;msgFlags  = inst-&gt;nMsgParsingFlags;
121 	if (rkmessage-&gt;key_len) {
122 		DBGPRINTF("imkafka: enqMsg: Key: %.*s\n", (int)rkmessage-&gt;key_len, (char *)rkmessage-&gt;key);
123 		MsgSetTAG(pMsg, (const uchar *)rkmessage-&gt;key, (int)rkmessage-&gt;key_len);
124 	}
125 	MsgSetMSGoffs(pMsg, 0);	
126 	CHKiRet(submitMsg2(pMsg));
127 finalize_it:
128 	RETiRet;
129 }
130 static void msgConsume (instanceConf_t *inst) {
131 	rd_kafka_message_t *rkmessage = NULL;
132 	do { 		rkmessage = rd_kafka_consumer_poll(inst-&gt;rk, 1000); 		if(rkmessage == NULL) {
133 			DBGPRINTF("imkafka: msgConsume EMPTY Loop on %s/%s/%s\n",
134 				inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
135 			goto done;
136 		}
137 		if (rkmessage-&gt;err) {
138 			if (rkmessage-&gt;err == RD_KAFKA_RESP_ERR__PARTITION_EOF) {
139 				DBGPRINTF("imkafka: Consumer "
140 					"reached end of topic \"%s\" [%"PRId32"]"
141 					"message queue offset %"PRId64"\n",
142 					rd_kafka_topic_name(rkmessage-&gt;rkt),
143 					rkmessage-&gt;partition,
144 					rkmessage-&gt;offset);
145 				goto done;
146 			}
147 			if (rkmessage-&gt;rkt) {
148 				LogError(0, RS_RET_KAFKA_ERROR,
149 				"imkafka: Consumer error for topic \"%s\" [%"PRId32"]"
150 				"message queue offset %"PRId64": %s\n",
151 					rd_kafka_topic_name(rkmessage-&gt;rkt),
152 					rkmessage-&gt;partition,
153 					rkmessage-&gt;offset,
154 					rd_kafka_message_errstr(rkmessage));
155 			} else {
156 				LogError(0, RS_RET_KAFKA_ERROR,
157 					"imkafka: Consumer error for topic \"%s\": \"%s\"\n",
158 					rd_kafka_err2str(rkmessage-&gt;err),
159 					rd_kafka_message_errstr(rkmessage));
160 			}
161 			goto done;
162 		}
163 		DBGPRINTF("imkafka: msgConsume Loop on %s/%s/%s: [%"PRId32"], "
164 					"offset %"PRId64", %zd bytes):\n",
165 					inst-&gt;consumergroup,
166 					inst-&gt;brokers,
167 					rkmessage-&gt;partition,
168 					rkmessage-&gt;offset,
169 					rkmessage-&gt;len);
170 		enqMsg(inst, rkmessage);
171 		rd_kafka_message_destroy(rkmessage);
172 		rkmessage = NULL;
173 	} while(1); done:
174 	if(rkmessage != NULL) {
175 		rd_kafka_message_destroy(rkmessage);
176 	}
177 	return;
178 }
179 static rsRetVal
180 createInstance(instanceConf_t **pinst)
181 {
182 	instanceConf_t *inst;
183 	DEFiRet;
184 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
185 	inst-&gt;next = NULL;
186 	inst-&gt;brokers = NULL;
187 	inst-&gt;topic = NULL;
188 	inst-&gt;consumergroup = NULL;
189 	inst-&gt;pszBindRuleset = NULL;
190 	inst-&gt;nConfParams = 0;
191 	inst-&gt;confParams = NULL;
192 	inst-&gt;pBindRuleset = NULL;
193 	inst-&gt;bReportErrs = 1; 	inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
194 	inst-&gt;bIsConnected = 0;
195 	inst-&gt;bIsSubscribed = 0;
196 	inst-&gt;conf = NULL;
197 	inst-&gt;rk = NULL;
198 	inst-&gt;topic_conf = NULL;
199 	inst-&gt;partition = RD_KAFKA_PARTITION_UA;
200 	if(loadModConf-&gt;tail == NULL) {
201 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
202 	} else {
203 		loadModConf-&gt;tail-&gt;next = inst;
204 		loadModConf-&gt;tail = inst;
205 	}
206 	*pinst = inst;
207 finalize_it:
208 	RETiRet;
209 }
210 static rsRetVal ATTR_NONNULL()
211 checkInstance(instanceConf_t *const inst)
212 {
213 	DEFiRet;
214 	char kafkaErrMsg[1024];
215 	inst-&gt;conf = rd_kafka_conf_new();
216 	if(inst-&gt;conf == NULL) {
217 		if(inst-&gt;bReportErrs) {
218 			LogError(0, RS_RET_KAFKA_ERROR,
219 				"imkafka: error creating kafka conf obj: %s\n",
220 				rd_kafka_err2str(rd_kafka_last_error()));
221 		}
222 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
223 	}
224 #	ifdef DEBUG
225 	if(rd_kafka_conf_set(inst-&gt;conf, "debug", RD_KAFKA_DEBUG_CONTEXTS,
226 		kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
227 		LogError(0, RS_RET_KAFKA_ERROR, "imkafka: error setting kafka debug option: %s\n", kafkaErrMsg);
228 	}
229 #	endif
230 	for(int i = 0 ; i &lt; inst-&gt;nConfParams ; ++i) {
231 		assert(inst-&gt;confParams+i != NULL); 		DBGPRINTF("imkafka: setting custom configuration parameter: %s:%s\n",
232 			inst-&gt;confParams[i].name,
233 			inst-&gt;confParams[i].val);
234 		if(rd_kafka_conf_set(inst-&gt;conf,
235 			inst-&gt;confParams[i].name,
236 			inst-&gt;confParams[i].val,
237 			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
238 			if(inst-&gt;bReportErrs) {
239 				LogError(0, RS_RET_PARAM_ERROR, "error setting custom configuration "
240 					"parameter '%s=%s': %s",
241 					inst-&gt;confParams[i].name,
242 					inst-&gt;confParams[i].val, kafkaErrMsg);
243 			} else {
244 				DBGPRINTF("imkafka: error setting custom configuration parameter '%s=%s': %s",
245 					inst-&gt;confParams[i].name,
246 					inst-&gt;confParams[i].val, kafkaErrMsg);
247 			}
248 			ABORT_FINALIZE(RS_RET_PARAM_ERROR);
249 		}
250 	}
251 	inst-&gt;topic_conf = rd_kafka_topic_conf_new();
252 	if (inst-&gt;consumergroup != NULL) {
253 		DBGPRINTF("imkafka: setting consumergroup: '%s'\n", inst-&gt;consumergroup);
254 		if (rd_kafka_conf_set(inst-&gt;conf, "group.id", (char*) inst-&gt;consumergroup,
255 			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
256 			if(inst-&gt;bReportErrs) {
257 				LogError(0, RS_RET_KAFKA_ERROR,
258 					"imkafka: error assigning consumergroup %s to "
259 					"kafka config: %s\n", inst-&gt;consumergroup,
260 					kafkaErrMsg);
261 			}
262 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
263 		}
264 		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, "auto.offset.reset",
265 			"smallest", kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
266 			if(inst-&gt;bReportErrs) {
267 				LogError(0, RS_RET_KAFKA_ERROR,
268 					"imkafka: error setting kafka auto.offset.reset on %s: %s\n",
269 					inst-&gt;consumergroup,
270 					kafkaErrMsg);
271 			}
272 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
273 		}
274 		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, "offset.store.method",
275 			"broker", kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
276 			if(inst-&gt;bReportErrs) {
277 				LogError(0, RS_RET_KAFKA_ERROR,
278 					"imkafka: error setting kafka offset.store.method on %s: %s\n",
279 					inst-&gt;consumergroup,
280 					kafkaErrMsg);
281 			}
282 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
283 		}
284 		rd_kafka_conf_set_default_topic_conf(inst-&gt;conf, inst-&gt;topic_conf);
285 	}
286 	#if RD_KAFKA_VERSION &gt;= 0x00090001
287 		rd_kafka_conf_set_log_cb(inst-&gt;conf, kafkaLogger);
288 	#endif
289 	inst-&gt;rk = rd_kafka_new(RD_KAFKA_CONSUMER, inst-&gt;conf,
290 				     kafkaErrMsg, sizeof(kafkaErrMsg));
291 	if(inst-&gt;rk == NULL) {
292 		if(inst-&gt;bReportErrs) {
293 			LogError(0, RS_RET_KAFKA_ERROR,
294 				"imkafka: error creating kafka handle: %s\n", kafkaErrMsg);
295 		}
296 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
297 	}
298 	#if RD_KAFKA_VERSION &lt; 0x00090001
299 		rd_kafka_set_logger(inst-&gt;rk, kafkaLogger);
300 	#endif
301 	DBGPRINTF("imkafka: setting brokers: '%s'\n", inst-&gt;brokers);
302 	if(rd_kafka_brokers_add(inst-&gt;rk, (char*)inst-&gt;brokers) == 0) {
303 		if(inst-&gt;bReportErrs) {
304 			LogError(0, RS_RET_KAFKA_NO_VALID_BROKERS,
305 				"imkafka: no valid brokers specified: %s", inst-&gt;brokers);
306 		}
307 		ABORT_FINALIZE(RS_RET_KAFKA_NO_VALID_BROKERS);
308 	}
309 	inst-&gt;bIsConnected = 1;
310 finalize_it:
311 	if(iRet != RS_RET_OK) {
312 		if(inst-&gt;rk == NULL) {
313 			if(inst-&gt;conf != NULL) {
314 				rd_kafka_conf_destroy(inst-&gt;conf);
315 				inst-&gt;conf = NULL;
316 			}
317 		} else { 			rd_kafka_destroy(inst-&gt;rk);
318 			inst-&gt;rk = NULL;
319 		}
320 	}
321 	RETiRet;
322 }
323 static inline void
324 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
325 {
326 	if(inst-&gt;bReportErrs) {
327 		LogError(0, NO_ERRCODE, "imkafka: ruleset '%s' not found - "
328 			"using default ruleset instead",
329 			inst-&gt;pszBindRuleset);
330 	}
331 }
332 static rsRetVal ATTR_NONNULL(2)
333 addConsumer(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
334 {
335 	DEFiRet;
336 	rd_kafka_resp_err_t err;
337 	assert(inst != NULL);
338 	rd_kafka_topic_partition_list_t *topics = NULL;
339 	DBGPRINTF("imkafka: creating kafka consumer on %s/%s/%s\n",
340 		inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
341 	rd_kafka_poll_set_consumer(inst-&gt;rk);
342 	topics = rd_kafka_topic_partition_list_new(1);
343 	rd_kafka_topic_partition_list_add(topics, (const char*)inst-&gt;topic, inst-&gt;partition);
344 	DBGPRINTF("imkafka: Created topics(%d) for %s)\n",
345 		topics-&gt;cnt, inst-&gt;topic);
346 	if ((err = rd_kafka_subscribe(inst-&gt;rk, topics))) {
347 		inst-&gt;bIsSubscribed = 0;
348 		LogError(0, RS_RET_KAFKA_ERROR, "imkafka: Failed to start consuming "
349 			"topics: %s\n", rd_kafka_err2str(err));
350 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
351 	} else {
352 		DBGPRINTF("imkafka: Successfully subscribed to %s/%s/%s\n",
353 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
354 		inst-&gt;bIsSubscribed = 1;
355 	}
356 finalize_it:
357 	if(topics != NULL)
358 		rd_kafka_topic_partition_list_destroy(topics);
359 	RETiRet;
360 }
361 static rsRetVal ATTR_NONNULL()
362 processKafkaParam(char *const param,
363 	const char **const name,
364 	const char **const paramval)
365 {
366 	DEFiRet;
367 	char *val = strstr(param, "=");
368 	if(val == NULL) {
369 		LogError(0, RS_RET_PARAM_ERROR, "missing equal sign in "
370 <a name="2"></a>				"parameter '%s'", param);
371 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
372 	}
373 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	*val = '\0'; 	++val; 	CHKmalloc(*name = strdup(param));
374 	CHKmalloc(*paramval = strdup(val));
375 finalize_it:
376 	RETiRet;
377 }
378 BEGINnewInpInst
379 	struct cnfparamvals *pvals;
380 	instanceConf_t *inst;
381 	int i;
382 CODESTARTnewInpInst
383 	DBGPRINTF("newInpInst (imkafka)\n");
384 	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
385 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
386 	}</b></font>
387 	if(Debug) {
388 		dbgprintf("input param blk in imkafka:\n");
389 		cnfparamsPrint(&amp;inppblk, pvals);
390 	}
391 	CHKiRet(createInstance(&amp;inst));
392 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
393 		if(!pvals[i].bUsed)
394 			continue;
395 		if(!strcmp(inppblk.descr[i].name, "broker")) {
396 			es_str_t *es = es_newStr(128);
397 			int bNeedComma = 0;
398 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
399 				if(bNeedComma)
400 					es_addChar(&amp;es, ',');
401 				es_addStr(&amp;es, pvals[i].val.d.ar-&gt;arr[j]);
402 				bNeedComma = 1;
403 			}
404 			inst-&gt;brokers = es_str2cstr(es, NULL);
405 			es_deleteStr(es);
406 		} else if(!strcmp(inppblk.descr[i].name, "confparam")) {
407 			inst-&gt;nConfParams = pvals[i].val.d.ar-&gt;nmemb;
408 			CHKmalloc(inst-&gt;confParams = malloc(sizeof(struct kafka_params)*inst-&gt;nConfParams));
409 			for(int j = 0; j &lt; inst-&gt;nConfParams; j++) {
410 				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
411 				CHKiRet(processKafkaParam(cstr, &amp;inst-&gt;confParams[j].name,
412 								&amp;inst-&gt;confParams[j].val));
413 				free(cstr);
414 			}
415 		} else if(!strcmp(inppblk.descr[i].name, "topic")) {
416 			inst-&gt;topic = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
417 		} else if(!strcmp(inppblk.descr[i].name, "consumergroup")) {
418 			inst-&gt;consumergroup = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
419 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
420 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
421 		} else if(!strcmp(inppblk.descr[i].name, "parsehostname")) {
422 			if (pvals[i].val.d.n) {
423 				inst-&gt;nMsgParsingFlags = NEEDS_PARSING | PARSE_HOSTNAME;
424 			} else {
425 				inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
426 			}
427 		} else {
428 			dbgprintf("imkafka: program error, non-handled "
429 			  "param '%s'\n", inppblk.descr[i].name);
430 		}
431 	}
432 	if(inst-&gt;brokers == NULL) {
433 		CHKmalloc(inst-&gt;brokers = strdup("localhost:9092"));
434 		LogMsg(0, NO_ERRCODE, LOG_INFO, "imkafka: \"broker\" parameter not specified "
435 			"using default of localhost:9092 -- this may not be what you want!");
436 	}
437 	DBGPRINTF("imkafka: newInpIns brokers=%s, topic=%s, consumergroup=%s\n",
438 		inst-&gt;brokers, inst-&gt;topic, inst-&gt;consumergroup);
439 finalize_it:
440 CODE_STD_FINALIZERnewInpInst
441 	cnfparamvalsDestruct(pvals, &amp;inppblk);
442 ENDnewInpInst
443 BEGINbeginCnfLoad
444 CODESTARTbeginCnfLoad
445 	loadModConf = pModConf;
446 	pModConf-&gt;pConf = pConf;
447 	pModConf-&gt;pszBindRuleset = NULL;
448 ENDbeginCnfLoad
449 BEGINsetModCnf
450 <a name="1"></a>	struct cnfparamvals *pvals = NULL;
451 	int i;
452 CODESTARTsetModCnf
453 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
454 	if(pvals == NULL) {
455 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imkafka: error processing module "
456 			"config parameters [module(...)]");
457 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
458 	}
459 	if(Debug) {
460 		dbgprintf("module (global) param blk for imkafka:\n");
461 		cnfparamsPrint(&amp;modpblk, pvals);
462 	}
463 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
464 		if(!pvals[i].bUsed)
465 			continue;
466 		if(!strcmp(modpblk.descr[i].name, "ruleset")) {
467 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
468 		} else {
469 			dbgprintf("imkafka: program error, non-handled "
470 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
471 		}
472 	}
473 finalize_it:
474 	if(pvals != NULL)
475 		cnfparamvalsDestruct(pvals, &amp;modpblk);
476 ENDsetModCnf
477 BEGINendCnfLoad
478 CODESTARTendCnfLoad
479 	if(loadModConf-&gt;pszBindRuleset == NULL) {
480 		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
481 			loadModConf-&gt;pszBindRuleset = NULL;
482 		} else {
483 			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
484 		}
485 	}
486 finalize_it:
487 	free(cs.pszBindRuleset);
488 	cs.pszBindRuleset = NULL;
489 	loadModConf = NULL; ENDendCnfLoad
490 BEGINcheckCnf
491 	instanceConf_t *inst;
492 CODESTARTcheckCnf
493 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
494 		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
495 			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
496 		}
497 		std_checkRuleset(pModConf, inst);
498 	}
499 finalize_it:
500 ENDcheckCnf
501 BEGINactivateCnfPrePrivDrop
502 CODESTARTactivateCnfPrePrivDrop
503 	runModConf = pModConf;
504 ENDactivateCnfPrePrivDrop
505 BEGINactivateCnf
506 CODESTARTactivateCnf
507 	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
508 		iRet = checkInstance(inst);
509 	}
510 ENDactivateCnf
511 BEGINfreeCnf
512 	instanceConf_t *inst, *del;
513 CODESTARTfreeCnf
514 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
515 		free(inst-&gt;topic);
516 		free(inst-&gt;consumergroup);
517 		free(inst-&gt;brokers);
518 		free(inst-&gt;pszBindRuleset);
519 		for(int i = 0; i &lt; inst-&gt;nConfParams; i++) {
520 			free((void*)inst-&gt;confParams[i].name);
521 			free((void*)inst-&gt;confParams[i].val);
522 		}
523 		free((void*)inst-&gt;confParams);
524 		del = inst;
525 		inst = inst-&gt;next;
526 		free(del);
527 	}
528 	free(pModConf-&gt;pszBindRuleset);
529 ENDfreeCnf
530 static void
531 shutdownKafkaWorkers(void)
532 {
533 	int i;
534 	instanceConf_t *inst;
535 	assert(kafkaWrkrInfo != NULL);
536 	DBGPRINTF("imkafka: waiting on imkafka workerthread termination\n");
537 	for(i = 0 ; i &lt; activeKafkaworkers ; ++i) {
538 		pthread_join(kafkaWrkrInfo[i].tid, NULL);
539 		DBGPRINTF("imkafka: Stopped worker %d\n", i);
540 	}
541 	free(kafkaWrkrInfo);
542 	kafkaWrkrInfo = NULL;
543 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
544 		DBGPRINTF("imkafka: stop consuming %s/%s/%s\n",
545 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
546 		rd_kafka_consumer_close(inst-&gt;rk); 		rd_kafka_destroy(inst-&gt;rk); 		DBGPRINTF("imkafka: stopped consuming %s/%s/%s\n",
547 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
548 		#if RD_KAFKA_VERSION &lt; 0x00090001
549 		if (rd_kafka_wait_destroyed(10000) &lt; 0)	{
550 			DBGPRINTF("imkafka: error, rd_kafka_destroy did not finish after grace "
551 				"timeout (10s)!\n");
552 		} else {
553 			DBGPRINTF("imkafka: rd_kafka_destroy successfully finished\n");
554 		}
555 		#endif
556 	}
557 }
558 BEGINrunInput
559 	int i;
560 	instanceConf_t *inst;
561 CODESTARTrunInput
562 	DBGPRINTF("imkafka: runInput loop started ...\n");
563 	activeKafkaworkers = 0;
564 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
565 		if(inst-&gt;rk != NULL) {
566 			++activeKafkaworkers;
567 		}
568 	}
569 	if(activeKafkaworkers == 0) {
570 		LogError(0, RS_RET_ERR, "imkafka: no active inputs, input does "
571 			"not run - there should have been additional error "
572 			"messages given previously");
573 		ABORT_FINALIZE(RS_RET_ERR);
574 	}
575 	DBGPRINTF("imkafka: Starting %d imkafka workerthreads\n", activeKafkaworkers);
576 	kafkaWrkrInfo = calloc(activeKafkaworkers, sizeof(struct kafkaWrkrInfo_s));
577 	if (kafkaWrkrInfo == NULL) {
578 		LogError(errno, RS_RET_OUT_OF_MEMORY, "imkafka: worker-info array allocation failed.");
579 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
580 	}
581 	i = 0;
582 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
583 		kafkaWrkrInfo[i].inst = inst; 		pthread_create(&amp;kafkaWrkrInfo[i].tid, &amp;wrkrThrdAttr, imkafkawrkr, &amp;(kafkaWrkrInfo[i]));
584 		i++;
585 	}
586 	while(glbl.GetGlobalInputTermState() == 0) {
587 		if(glbl.GetGlobalInputTermState() == 0)
588 			srSleep(0, 100000);
589 	}
590 	DBGPRINTF("imkafka: terminating upon request of rsyslog core\n");
591 	shutdownKafkaWorkers();
592 finalize_it:
593 ENDrunInput
594 BEGINwillRun
595 CODESTARTwillRun
596 	CHKiRet(prop.Construct(&amp;pInputName));
597 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imkafka"), sizeof("imkafka") - 1));
598 	CHKiRet(prop.ConstructFinalize(pInputName));
599 finalize_it:
600 ENDwillRun
601 BEGINafterRun
602 CODESTARTafterRun
603 	if(pInputName != NULL)
604 		prop.Destruct(&amp;pInputName);
605 ENDafterRun
606 BEGINmodExit
607 CODESTARTmodExit
608 	pthread_attr_destroy(&amp;wrkrThrdAttr);
609 	objRelease(statsobj, CORE_COMPONENT);
610 	objRelease(ruleset, CORE_COMPONENT);
611 	objRelease(glbl, CORE_COMPONENT);
612 	objRelease(prop, CORE_COMPONENT);
613 ENDmodExit
614 BEGINisCompatibleWithFeature
615 CODESTARTisCompatibleWithFeature
616 	if(eFeat == sFEATURENonCancelInputTermination)
617 		iRet = RS_RET_OK;
618 ENDisCompatibleWithFeature
619 BEGINqueryEtryPt
620 CODESTARTqueryEtryPt
621 CODEqueryEtryPt_STD_IMOD_QUERIES
622 CODEqueryEtryPt_STD_CONF2_QUERIES
623 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
624 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
625 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
626 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
627 ENDqueryEtryPt
628 BEGINmodInit()
629 CODESTARTmodInit
630 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
631 CODEmodInit_QueryRegCFSLineHdlr
632 	CHKiRet(objUse(glbl, CORE_COMPONENT));
633 	CHKiRet(objUse(prop, CORE_COMPONENT));
634 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
635 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
636 	pthread_attr_init(&amp;wrkrThrdAttr);
637 	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
638 	DBGPRINTF("imkafka %s using librdkafka version %s, 0x%x\n",
639 		VERSION, rd_kafka_version_str(), rd_kafka_version());
640 ENDmodInit
641 static void *
642 imkafkawrkr(void *myself)
643 {
644 	struct kafkaWrkrInfo_s *me = (struct kafkaWrkrInfo_s*) myself;
645 	DBGPRINTF("imkafka: started kafka consumer workerthread on %s/%s/%s\n",
646 		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
647 	do {
648 		if(glbl.GetGlobalInputTermState() == 1)
649 			break; 
650 		if(me-&gt;inst-&gt;rk == NULL) {
651 			continue;
652 		}
653 		if(me-&gt;inst-&gt;bIsConnected == 1 &amp;&amp; me-&gt;inst-&gt;bIsSubscribed == 0 ) {
654 			addConsumer(runModConf, me-&gt;inst);
655 		}
656 		if(me-&gt;inst-&gt;bIsSubscribed == 1 ) {
657 			msgConsume(me-&gt;inst);
658 		}
659 		if(glbl.GetGlobalInputTermState() == 0)
660 			srSleep(0, 100000);
661 	} while(glbl.GetGlobalInputTermState() == 0);
662 	DBGPRINTF("imkafka: stopped kafka consumer workerthread on %s/%s/%s\n",
663 		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
664 	return NULL;
665 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmdarwin.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include &lt;pthread.h&gt;
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "parserif.h"
20 #include &lt;stdio.h&gt;
21 #include &lt;stdlib.h&gt;
22 #include &lt;string.h&gt;
23 #include &lt;sys/un.h&gt;
24 #include &lt;sys/socket.h&gt;
25 #include &lt;uuid/uuid.h&gt;
26 #include &lt;json.h&gt;
27 #include "protocol.h" 
28 #define JSON_DEFAULT_CONTAINER "!mmdarwin"
29 #define JSON_DARWIN_ID "darwin_id"
30 #define INVLD_SOCK -1
31 #define INITIAL_BUFFER_SIZE 32
32 #define BUFFER_DEFAULT_MAX_SIZE 65536
33 MODULE_TYPE_OUTPUT
34 MODULE_TYPE_NOKEEP
35 MODULE_CNFNAME("mmdarwin")
36 DEFobjCurrIf(glbl)
37 DEF_OMOD_STATIC_DATA
38 typedef struct dyn_buffer_t
39 {
40 	char *buffer;
41 	size_t bufferAllocSize;
42 	size_t bufferMsgSize;
43 	size_t bufferMaxSize;
44 } dyn_buffer;
45 typedef struct _instanceData
46 {
47 	enum darwin_filter_response_type response;		struct
48 	{
49 		int nmemb;
50 		char **name;
51 		char **varname;
52 	} fieldList; 	unsigned int socketMaxUse;
53 	sbool sendPartial;
54 } instanceData;
55 typedef struct wrkrInstanceData
56 {
57 	instanceData *pData;
58 	int sock;				 	struct sockaddr_un addr; 	uint8_t pktSentSocket;
59 	dyn_buffer darwinBody; 	dyn_buffer fieldBuffer;
60 } wrkrInstanceData_t;
61 struct modConfData_s
62 {
63 	rsconf_t *pConf;
64 	const char *container;
65 <a name="0"></a>};
66 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static modConfData_t *loadModConf = NULL;
67 static modConfData_t *runModConf = NULL;
68 static struct cnfparamdescr modpdescr[] = {
69 	{"container", eCmdHdlrGetWord, 0},
70 };
71 static struct cnfparamblk modpblk =
72 	{CNFPARAMBLK_VERSION,
73 	 sizeof(modpdescr) / sizeof(struct cnfparamdescr),
74 	 modpdescr};
75 static struct cnfparamdescr actpdescr[] = {
76 	{"key", eCmdHdlrGetWord, CNFPARAM_REQUIRED},
77 	{"socketpath", eCmdHdlrGetWord, CNFPARAM_REQUIRED},
78 	{"fields", eCmdHdlrArray, CNFPARAM_REQUIRED},
79 	{"filtercode", eCmdHdlrGetWord, 0},				{"response", eCmdHdlrGetWord, 0},				{"send_partial", eCmdHdlrBinary, 0},			{"socket_max_use", eCmdHdlrNonNegInt, 0}, };
80 static struct cnfparamblk actpblk = {
81 	CNFPARAMBLK_VERSION,
82 	sizeof(actpdescr) / sizeof(struct cnfparamdescr),
83 	actpdescr};
84 #define min(a, b) \
85 	({ __typeof__ (a) _a = (a); \
86 	__typeof__ (b) _b = (b); \
87 	_a &lt; _b ? _a : _b; })
88 static rsRetVal openSocket(wrkrInstanceData_t *pWrkrData);
89 static rsRetVal closeSocket(wrkrInstanceData_t *pWrkrData);
90 static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData);
91 static rsRetVal sendMsg(wrkrInstanceData_t *pWrkrData, void *msg, size_t len);
92 static rsRetVal receiveMsg(wrkrInstanceData_t *pWrkrData, void *response, size_t len);
93 const char* get_uuid_object(smsg_t *const pMsg);
94 int get_field(smsg_t *const pMsg, const char *pFieldName, char **ppRetString);
95 int expand_buffer(dyn_buffer *pBody, size_t new_size);
96 int add_field_to_body(dyn_buffer *pBody, const char *field, size_t size);
97 int start_new_line(dyn_buffer *pBody);
98 int end_body(dyn_buffer *pBody);
99 static rsRetVal openSocket(wrkrInstanceData_t *pWrkrData)
100 {
101 	DEFiRet;
102 	assert(pWrkrData-&gt;sock == INVLD_SOCK);
103 	if ((pWrkrData-&gt;sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
104 	{
105 		char errStr[1024];
106 		int eno = errno;
107 		DBGPRINTF("mmdarwin::openSocket:: error %d creating AF_UNIX/SOCK_STREAM: %s.\n",
108 				  eno, rs_strerror_r(eno, errStr, sizeof(errStr)));
109 		pWrkrData-&gt;sock = INVLD_SOCK;
110 		ABORT_FINALIZE(RS_RET_NO_SOCKET);
111 	}
112 	memset(&amp;pWrkrData-&gt;addr, 0, sizeof(struct sockaddr_un));
113 	pWrkrData-&gt;addr.sun_family = AF_UNIX;
114 	strncpy(pWrkrData-&gt;addr.sun_path, (char *)pWrkrData-&gt;pData-&gt;pSockName, sizeof(pWrkrData-&gt;addr.sun_path) - 1);
115 	DBGPRINTF("mmdarwin::openSocket:: connecting to Darwin...\n");
116 	if (connect(pWrkrData-&gt;sock, (struct sockaddr *)&amp;pWrkrData-&gt;addr, sizeof(struct sockaddr_un)) == -1)
117 	{
118 		LogError(errno, RS_RET_NO_SOCKET, "mmdarwin::openSocket:: error connecting to Darwin "
119 										  "via socket '%s'",
120 				 pWrkrData-&gt;pData-&gt;pSockName);
121 		pWrkrData-&gt;sock = INVLD_SOCK;
122 		ABORT_FINALIZE(RS_RET_NO_SOCKET);
123 	}
124 	DBGPRINTF("mmdarwin::openSocket:: connected !\n");
125 finalize_it:
126 	if (iRet != RS_RET_OK)
127 	{
128 		closeSocket(pWrkrData);
129 	}
130 	RETiRet;
131 }
132 static rsRetVal closeSocket(wrkrInstanceData_t *pWrkrData)
133 {
134 	DEFiRet;
135 	if (pWrkrData-&gt;sock != INVLD_SOCK)
136 	{
137 		if (close(pWrkrData-&gt;sock) != 0)
138 		{
139 			char errStr[1024];
140 			int eno = errno;
141 			DBGPRINTF("mmdarwin::closeSocket:: error %d closing the socket: %s.\n",
142 					  eno, rs_strerror_r(eno, errStr, sizeof(errStr)));
143 		}
144 		pWrkrData-&gt;sock = INVLD_SOCK;
145 	}
146 	RETiRet;
147 }
148 static rsRetVal doTryResume(wrkrInstanceData_t *pWrkrData)
149 {
150 	DEFiRet;
151 	DBGPRINTF("mmdarwin::doTryResume:: trying to resume\n");
152 	closeSocket(pWrkrData);
153 	iRet = openSocket(pWrkrData);
154 	if (iRet != RS_RET_OK)
155 	{
156 		iRet = RS_RET_SUSPENDED;
157 	}
158 	RETiRet;
159 }
160 static rsRetVal sendMsg(wrkrInstanceData_t *pWrkrData, void *msg, size_t len)
161 {
162 	DEFiRet;
163 	DBGPRINTF("mmdarwin::sendMsg:: sending message to Darwin...\n");
164 	if (pWrkrData-&gt;sock == INVLD_SOCK)
165 	{
166 		CHKiRet(doTryResume(pWrkrData));
167 	}
168 	if (pWrkrData-&gt;sock != INVLD_SOCK)
169 	{
170 		if (send(pWrkrData-&gt;sock, msg, len, 0) == -1)
171 		{
172 			char errStr[1024];
173 			DBGPRINTF("mmdarwin::sendData:: error while sending data: error[%d] -&gt; %s\n",
174 					  errno, rs_strerror_r(errno, errStr, sizeof(errStr)));
175 			iRet = RS_RET_SUSPENDED;
176 		}
177 	}
178 finalize_it:
179 	RETiRet;
180 }
181 static rsRetVal receiveMsg(wrkrInstanceData_t *pWrkrData, void *response, size_t len)
182 {
183 	DEFiRet;
184 	DBGPRINTF("mmdarwin::receiveMsg:: receiving message from Darwin...\n");
185 	if (pWrkrData-&gt;sock == INVLD_SOCK)
186 	{
187 		CHKiRet(doTryResume(pWrkrData));
188 	}
189 	if (pWrkrData-&gt;sock != INVLD_SOCK)
190 	{
191 		if (recv(pWrkrData-&gt;sock, response, len, MSG_WAITALL) &lt;= 0)
192 		{
193 			char errStr[1024];
194 			DBGPRINTF("mmdarwin::receiveMsg:: error while receiving data: error[%d] -&gt; %s\n",
195 					  errno, rs_strerror_r(errno, errStr, sizeof(errStr)));
196 			iRet = RS_RET_NONE;
197 		}
198 	}
199 finalize_it:
200 	RETiRet;
201 }
202 int get_field(smsg_t *const pMsg, const char *pFieldName, char **ppRetString)
203 {
204 	DBGPRINTF("mmdarwin::get_field:: getting key '%s' in msg\n", pFieldName);
205 	struct json_object *pJson = NULL;
206 	char *pFieldString = NULL;
207 	int retVal = 0;
208 	msgPropDescr_t propDesc;
209 	msgPropDescrFill(&amp;propDesc, (uchar *)pFieldName, strlen(pFieldName));
210 	msgGetJSONPropJSONorString(pMsg, &amp;propDesc, &amp;pJson, (uchar **)&amp;pFieldString);
211 	if (pFieldString)
212 	{
213 		*ppRetString = pFieldString;
214 		DBGPRINTF("mmdarwin::get_field:: got string\n");
215 		retVal = 1;
216 	}
217 	else if (pJson)
218 	{
219 		pFieldString = (char *)json_object_get_string(pJson);
220 		if (pFieldString)
221 		{
222 			*ppRetString = strdup(pFieldString);
223 			retVal = 1;
224 			DBGPRINTF("mmdarwin::get_field:: got string from json\n");
225 			json_object_put(pJson);
226 		}
227 	}
228 	msgPropDescrDestruct(&amp;propDesc);
229 	return retVal;
230 }
231 int expand_buffer(dyn_buffer *pBody, size_t new_size)
232 {
233 	if (new_size &gt; pBody-&gt;bufferMaxSize)
234 		return -1;
235 	while (pBody-&gt;bufferAllocSize &lt; new_size)
236 		pBody-&gt;bufferAllocSize += INITIAL_BUFFER_SIZE;
237 	DBGPRINTF("mmdarwin::expand_buffer:: expanding buffer to %zu\n", pBody-&gt;bufferAllocSize);
238 	char *tmp = realloc(pBody-&gt;buffer, pBody-&gt;bufferAllocSize * sizeof(char));
239 	if (!tmp)
240 	{
241 		DBGPRINTF("mmdarwin::expand_buffer:: could not resize buffer\n");
242 		return -1;
243 	}
244 	pBody-&gt;buffer = tmp;
245 	return 0;
246 }
247 int add_field_to_body(dyn_buffer *pBody, const char *field, size_t size)
248 {
249 	int beginning = (pBody-&gt;bufferMsgSize == 0) ? 2 : 0;
250 	size_t requiredBodySize = pBody-&gt;bufferMsgSize + size + 4 + beginning;
251 	if (requiredBodySize &gt; pBody-&gt;bufferAllocSize)
252 	{
253 		if (expand_buffer(pBody, requiredBodySize) != 0)
254 		{
255 			return -1;
256 		}
257 	}
258 	if (!pBody-&gt;bufferMsgSize)
259 	{
260 		pBody-&gt;buffer[0] = '[';
261 		pBody-&gt;buffer[1] = '[';
262 		pBody-&gt;bufferMsgSize += 2;
263 	}
264 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\"';
265 	memcpy((void *)&amp;pBody-&gt;buffer[pBody-&gt;bufferMsgSize], (const void *)field, size);
266 	pBody-&gt;bufferMsgSize += size;
267 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\"';
268 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ',';
269 	return 0;
270 }
271 int start_new_line(dyn_buffer *pBody)
272 {
273 	if (!pBody-&gt;bufferMsgSize)
274 	{
275 		return -1;
276 	}
277 	DBGPRINTF("mmdarwin::start_new_line:: starting new line entry in body\n");
278 	if (pBody-&gt;bufferAllocSize &lt; pBody-&gt;bufferMsgSize + 2)
279 	{
280 		if (expand_buffer(pBody, pBody-&gt;bufferAllocSize + 2) != 0)
281 		{
282 			return -1;
283 		}
284 	}
285 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize - 1] = ']';
286 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ',';
287 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '[';
288 	return 0;
289 }
290 int end_body(dyn_buffer *pBody)
291 {
292 	if (!pBody-&gt;bufferMsgSize)
293 	{
294 		return -1;
295 	}
296 	DBGPRINTF("mmdarwin::end_body:: finishing body structure\n");
297 	if (pBody-&gt;bufferAllocSize &lt; pBody-&gt;bufferMsgSize + 2)
298 	{
299 		if (expand_buffer(pBody, pBody-&gt;bufferAllocSize + 2) != 0)
300 		{
301 			return -1;
302 		}
303 	}
304 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize - 1] = ']';
305 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = ']';
306 	pBody-&gt;buffer[pBody-&gt;bufferMsgSize++] = '\0';
307 	return 0;
308 }
309 const char* get_uuid_object(smsg_t *const pMsg) {
310 	struct json_object *mmdarwin_object = NULL;
311 	const char *result = NULL, *key = NULL;
312 	msgPropDescr_t propDesc;
313 	msgPropDescrFill(&amp;propDesc, (uchar *)runModConf-&gt;container, strlen(runModConf-&gt;container));
314 	msgGetJSONPropJSON(pMsg, &amp;propDesc, &amp;mmdarwin_object);
315 	if(mmdarwin_object) {
316 		struct json_object_iterator it = json_object_iter_begin(mmdarwin_object);
317 		struct json_object_iterator itEnd = json_object_iter_end(mmdarwin_object);
318 		while(!json_object_iter_equal(&amp;it, &amp;itEnd)) {
319 			key = json_object_iter_peek_name(&amp;it);
320 			if(!strcmp(key, JSON_DARWIN_ID)) {
321 				result = strdup(json_object_get_string(json_object_iter_peek_value(&amp;it)));
322 				break;
323 			}
324 			json_object_iter_next(&amp;it);
325 		}
326 		json_object_put(mmdarwin_object);
327 	}
328 	msgPropDescrDestruct(&amp;propDesc);
329 	return result;
330 }
331 BEGINbeginCnfLoad
332 CODESTARTbeginCnfLoad
333 	loadModConf = pModConf;
334 pModConf-&gt;pConf = pConf;
335 ENDbeginCnfLoad
336 BEGINendCnfLoad
337 CODESTARTendCnfLoad
338 ENDendCnfLoad
339 BEGINcheckCnf
340 CODESTARTcheckCnf
341 ENDcheckCnf
342 BEGINactivateCnf
343 CODESTARTactivateCnf
344 	runModConf = pModConf;
345 ENDactivateCnf
346 BEGINfreeCnf
347 CODESTARTfreeCnf
348 	free((void *)pModConf-&gt;container);
349 ENDfreeCnf
350 BEGINdbgPrintInstInfo
351 CODESTARTdbgPrintInstInfo
352 	DBGPRINTF("%s\n", pData-&gt;pSockName);
353 ENDdbgPrintInstInfo
354 BEGINcreateInstance
355 CODESTARTcreateInstance
356 ENDcreateInstance
357 BEGINcreateWrkrInstance
358 CODESTARTcreateWrkrInstance
359 	pWrkrData-&gt;pktSentSocket = 0;
360 	pWrkrData-&gt;darwinBody.bufferAllocSize = 0;
361 	pWrkrData-&gt;darwinBody.bufferMaxSize = BUFFER_DEFAULT_MAX_SIZE;
362 	pWrkrData-&gt;darwinBody.bufferMsgSize = 0;
363 	pWrkrData-&gt;sock = INVLD_SOCK;
364 ENDcreateWrkrInstance
365 BEGINisCompatibleWithFeature
366 CODESTARTisCompatibleWithFeature
367 ENDisCompatibleWithFeature
368 BEGINfreeInstance
369 CODESTARTfreeInstance
370 	if (pData-&gt;fieldList.name != NULL)
371 	{
372 		for (int i = 0; i &lt; pData-&gt;fieldList.nmemb; ++i)
373 		{
374 			free(pData-&gt;fieldList.name[i]);
375 			free(pData-&gt;fieldList.varname[i]);
376 		}
377 		free(pData-&gt;fieldList.name);
378 		free(pData-&gt;fieldList.varname);
379 	}
380 	free(pData-&gt;pUUIDKey);
381 	free(pData-&gt;pCertitudeKey);
382 	free(pData-&gt;pSockName);
383 ENDfreeInstance
384 BEGINfreeWrkrInstance
385 CODESTARTfreeWrkrInstance
386 	closeSocket(pWrkrData);
387 	free(pWrkrData-&gt;darwinBody.buffer);
388 ENDfreeWrkrInstance
389 BEGINsetModCnf
390 struct cnfparamvals *pvals = NULL;
391 <a name="1"></a>int i;
392 CODESTARTsetModCnf
393 	loadModConf-&gt;container = NULL;
394 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
395 	if (pvals == NULL)
396 	{
397 		LogError(0, RS_RET_MISSING_CNFPARAMS,
398 				"mmdarwin: error processing module config parameters missing [module(...)]");
399 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
400 	}
401 	if (Debug)
402 	{
403 		DBGPRINTF("mmdarwin::setModCnf:: module (global) param blk for mmdarwin:\n");
404 		cnfparamsPrint(&amp;modpblk, pvals);
405 	}
406 	for (i = 0; i &lt; modpblk.nParams; ++i)
407 	{
408 		if (!pvals[i].bUsed)
409 			continue;
410 		if (!strcmp(modpblk.descr[i].name, "container"))
411 		{
412 			loadModConf-&gt;container = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
413 			if(loadModConf-&gt;container[0] != '!' &amp;&amp; loadModConf-&gt;container[0] != '.') {
414 				LogError(0, RS_RET_INVALID_PARAMS, "mmdarwin: container should either"
415 					" begin with '!' or '.'\n");
416 				ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
417 			}
418 		}
419 		else
420 		{
421 			DBGPRINTF("mmdarwin::setModCnf:: program error, non-handled "
422 					"param '%s'\n",
423 					modpblk.descr[i].name);
424 		}
425 	}
426 	if (loadModConf-&gt;container == NULL)
427 	{
428 		CHKmalloc(loadModConf-&gt;container = strdup(JSON_DEFAULT_CONTAINER));
429 	}
430 finalize_it :
431 	if (pvals != NULL)
432 		cnfparamvalsDestruct(pvals, &amp;modpblk);
433 ENDsetModCnf
434 static inline void setInstParamDefaults(instanceData *pData)
435 {
436 	DBGPRINTF("mmdarwin::setInstParamDefaults::\n");
437 	pData-&gt;pUUIDKey = NULL;
438 <a name="2"></a>	pData-&gt;pCertitudeKey = NULL;
439 	pData-&gt;pSockName = NULL;
440 	pData-&gt;fieldList.nmemb = 0;
441 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	pData-&gt;filterCode = DARWIN_FILTER_CODE_NO;
442 	pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
443 	pData-&gt;socketMaxUse = 0;
444 	pData-&gt;sendPartial = 0;
445 }
446 BEGINnewActInst
447 	struct cnfparamvals *pvals;
448 	int i;
449 CODESTARTnewActInst
450 	DBGPRINTF("mmdarwin::newActInst::\n");
451 	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL)
452 	{
453 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
454 	}</b></font>
455 	CODE_STD_STRING_REQUESTnewActInst(1)
456 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
457 	CHKiRet(createInstance(&amp;pData));
458 	setInstParamDefaults(pData);
459 	for (i = 0; i &lt; actpblk.nParams; ++i)
460 	{
461 		if (!pvals[i].bUsed)
462 			continue;
463 		if (!strcmp(actpblk.descr[i].name, "key"))
464 		{
465 			char *key = es_str2cstr(pvals[i].val.d.estr, NULL);
466 			char vnamebuf[1024];
467 			snprintf(vnamebuf, sizeof(vnamebuf), "%s!%s", loadModConf-&gt;container, key);
468 			CHKmalloc(pData-&gt;pCertitudeKey = strdup(vnamebuf));
469 			free(key);
470 			DBGPRINTF("mmdarwin::newActInst:: certitudeKey is %s\n", pData-&gt;pCertitudeKey);
471 		}
472 		else if (!strcmp(actpblk.descr[i].name, "socketpath"))
473 		{
474 			pData-&gt;pSockName = (uchar *)es_str2cstr(pvals[i].val.d.estr, NULL);
475 			DBGPRINTF("mmdarwin::newActInst:: sockName is %s\n", pData-&gt;pSockName);
476 		}
477 		else if (!strcmp(actpblk.descr[i].name, "socket_max_use"))
478 		{
479 			pData-&gt;socketMaxUse = (uint32_t)pvals[i].val.d.n;
480 			DBGPRINTF("mmdarwin::newActInst:: socketMaxUse is %d\n", pData-&gt;socketMaxUse);
481 		}
482 		else if (!strcmp(actpblk.descr[i].name, "send_partial"))
483 		{
484 			pData-&gt;sendPartial = (sbool)pvals[i].val.d.n;
485 			if (pData-&gt;sendPartial)
486 			{
487 				DBGPRINTF("mmdarwin::newActInst:: sending bodies even if fields are missing\n");
488 			}
489 			else
490 			{
491 				DBGPRINTF("mmdarwin::newActInst:: only sending complete bodies\n");
492 			}
493 		}
494 		else if (!strcmp(actpblk.descr[i].name, "response"))
495 		{
496 			char *response = es_str2cstr(pvals[i].val.d.estr, NULL);
497 			if (!strcmp(response, "no"))
498 			{
499 				pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
500 				DBGPRINTF("mmdarwin::newActInst:: response type is 'no'\n");
501 			}
502 			else if (!strcmp(response, "back"))
503 			{
504 				pData-&gt;response = DARWIN_RESPONSE_SEND_BACK;
505 				DBGPRINTF("mmdarwin::newActInst:: response type is 'back'\n");
506 			}
507 			else if (!strcmp(response, "darwin"))
508 			{
509 				pData-&gt;response = DARWIN_RESPONSE_SEND_DARWIN;
510 				DBGPRINTF("mmdarwin::newActInst:: response type is 'darwin'\n");
511 			}
512 			else if (!strcmp(response, "both"))
513 			{
514 				pData-&gt;response = DARWIN_RESPONSE_SEND_BOTH;
515 				DBGPRINTF("mmdarwin::newActInst:: response type is 'both'\n");
516 			}
517 			else
518 			{
519 				DBGPRINTF(
520 					"mmdarwin::newActInst:: invalid 'response' value: %s. 'No response' set.\n",
521 					response);
522 				pData-&gt;response = DARWIN_RESPONSE_SEND_NO;
523 				DBGPRINTF("mmdarwin::newActInst:: response type is 'no'\n");
524 			}
525 			free(response);
526 		}
527 		else if (!strcmp(actpblk.descr[i].name, "filtercode"))
528 		{
529 			char *filterCode = es_str2cstr(pvals[i].val.d.estr, NULL);
530 			pData-&gt;filterCode = strtoull(filterCode, NULL, 16);
531 			free(filterCode);
532 		}
533 		else if (!strcmp(actpblk.descr[i].name, "fields"))
534 		{
535 			pData-&gt;fieldList.nmemb = pvals[i].val.d.ar-&gt;nmemb;
536 			CHKmalloc(pData-&gt;fieldList.name = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
537 			CHKmalloc(pData-&gt;fieldList.varname = calloc(pData-&gt;fieldList.nmemb, sizeof(char *)));
538 			for (int j = 0; j &lt; pData-&gt;fieldList.nmemb; ++j)
539 			{
540 				char *const param = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
541 				char *varname = NULL;
542 				char *name;
543 				if (*param == ':')
544 				{
545 					char *b = strchr(param + 1, ':');
546 					if (b == NULL)
547 					{
548 						parser_errmsg(
549 							"mmdarwin::newActInst:: missing closing colon: '%s'", param);
550 						ABORT_FINALIZE(RS_RET_ERR);
551 					}
552 					*b = '\0'; 					varname = param + 1;
553 					name = b + 1;
554 				}
555 				else
556 				{
557 					name = param;
558 				}
559 				CHKmalloc(pData-&gt;fieldList.name[j] = strdup(name));
560 				char vnamebuf[1024];
561 				snprintf(vnamebuf, sizeof(vnamebuf),
562 						"%s!%s", loadModConf-&gt;container,
563 						(varname == NULL) ? name : varname);
564 				CHKmalloc(pData-&gt;fieldList.varname[j] = strdup(vnamebuf));
565 				free(param);
566 				DBGPRINTF("mmdarwin::newActInst:: will look for field %s\n", pData-&gt;fieldList.name[j]);
567 			}
568 		}
569 		else
570 		{
571 			DBGPRINTF(
572 			"mmdarwin::newActInst:: program error, non-handled param '%s'\n", actpblk.descr[i].name);
573 		}
574 	}
575 	size_t sizeKey = strlen(loadModConf-&gt;container) + strlen(JSON_DARWIN_ID) + 2;
576 	pData-&gt;pUUIDKey = malloc(sizeKey);
577 	snprintf(pData-&gt;pUUIDKey, sizeKey, "%s!%s", loadModConf-&gt;container, JSON_DARWIN_ID);
578 	DBGPRINTF("mmdarwin:: uuid key is %s\n", pData-&gt;pUUIDKey);
579 CODE_STD_FINALIZERnewActInst
580 	cnfparamvalsDestruct(pvals, &amp;actpblk);
581 ENDnewActInst
582 BEGINtryResume
583 CODESTARTtryResume
584 	iRet = doTryResume(pWrkrData);
585 ENDtryResume
586 BEGINdoAction_NoStrings
587 	smsg_t **ppMsg = (smsg_t **)pMsgData; 	smsg_t *pMsg = ppMsg[0]; 	instanceData *pData = pWrkrData-&gt;pData; 	char *pFieldValue = NULL; 	int fieldsNum = 0; 
588 CODESTARTdoAction
589 	DBGPRINTF("mmdarwin::doAction:: beggining action\n");
590 	pWrkrData-&gt;darwinBody.bufferMsgSize = 0;
591 	fieldsNum = 0;
592 	for (int i = 0; i &lt; pData-&gt;fieldList.nmemb; i++)
593 	{
594 		DBGPRINTF("mmdarwin::doAction:: processing field '%s'\n", pData-&gt;fieldList.name[i]);
595 		pFieldValue = NULL;
596 		if (pData-&gt;fieldList.name[i][0] != '!' &amp;&amp; pData-&gt;fieldList.name[i][0] != '.')
597 		{
598 			pFieldValue = strdup(pData-&gt;fieldList.name[i]);
599 		}
600 		else
601 		{
602 			if (!get_field(pMsg, pData-&gt;fieldList.name[i], &amp;pFieldValue))
603 			{
604 				DBGPRINTF("mmdarwin::doAction:: \
605 could not extract field '%s' from message\n", pData-&gt;fieldList.name[i]);
606 				continue;
607 			}
608 		}
609 		DBGPRINTF(
610 			"mmdarwin::doAction:: got value of field '%s': '%s'\n", pData-&gt;fieldList.name[i], pFieldValue);
611 		if (add_field_to_body(&amp;(pWrkrData-&gt;darwinBody), pFieldValue, strlen(pFieldValue)) != 0)
612 		{
613 			DBGPRINTF("mmdarwin::doAction:: could not add field to body, aborting\n");
614 			free(pFieldValue);
615 			ABORT_FINALIZE(RS_RET_ERR);
616 		}
617 		fieldsNum++;
618 		free(pFieldValue);
619 	}
620 	if (fieldsNum)
621 	{
622 		if (!pData-&gt;sendPartial &amp;&amp; fieldsNum != pData-&gt;fieldList.nmemb)
623 		{
624 			DBGPRINTF("mmdarwin::doAction:: not all fields could be retrieved, not sending partial message."
625 	" (if you wish to send partial messages anyway, set 'send_partial' to 'on' in instance parameters)\n");
626 			FINALIZE;
627 		}
628 		if (end_body(&amp;(pWrkrData-&gt;darwinBody)) != 0)
629 			ABORT_FINALIZE(RS_RET_ERR);
630 	}
631 	else
632 	{
633 		DBGPRINTF("mmdarwin::doAction:: no fields retrieved, finalizing\n");
634 		FINALIZE;
635 	}
636 	DBGPRINTF("mmdarwin::doAction:: body to send: '%s'\n", pWrkrData-&gt;darwinBody.buffer);
637 	if (pData-&gt;socketMaxUse)
638 	{
639 		if (!pWrkrData-&gt;pktSentSocket)
640 		{
641 			DBGPRINTF("mmdarwin::doAction:: opening a new connection\n");
642 			CHKiRet(doTryResume(pWrkrData));
643 		}
644 		pWrkrData-&gt;pktSentSocket = (pWrkrData-&gt;pktSentSocket + 1) % pData-&gt;socketMaxUse;
645 	}
646 	darwin_filter_packet_t header = {
647 		.type = DARWIN_PACKET_OTHER,
648 		.response = pData-&gt;response,
649 		.filter_code = pData-&gt;filterCode,
650 		.body_size = pWrkrData-&gt;darwinBody.bufferMsgSize};
651 	const char *uuid = get_uuid_object(pMsg);
652 	if(uuid) {
653 		DBGPRINTF("mmdarwin: using existing UUID = %s\n", uuid);
654 		if(uuid_parse(uuid, header.evt_id))
655 			LogError(0, RS_RET_ERR, "mmdarwin:: failed to parse existing UUID: %s\n", uuid);
656 		free((void*)uuid);
657 	}
658 	else {
659 		uuid_generate(header.evt_id);
660 		char uuidStr[40];
661 		uuid_unparse(header.evt_id, uuidStr);
662 		DBGPRINTF("mmdarwin: generated new UUID = %s\n", uuidStr);
663 		msgAddJSON(pMsg, (uchar *)pData-&gt;pUUIDKey, json_object_new_string(uuidStr), 0, 0);
664 	}
665 	DBGPRINTF("mmdarwin::doAction:: sending header to Darwin\n");
666 	CHKiRet(sendMsg(pWrkrData, &amp;header, sizeof(darwin_filter_packet_t)));
667 	DBGPRINTF("mmdarwin::doAction:: sending body to Darwin\n");
668 	CHKiRet(sendMsg(pWrkrData, (void *)(pWrkrData-&gt;darwinBody.buffer), pWrkrData-&gt;darwinBody.bufferMsgSize));
669 	if (pData-&gt;response == DARWIN_RESPONSE_SEND_NO || pData-&gt;response == DARWIN_RESPONSE_SEND_DARWIN)
670 	{
671 		DBGPRINTF("mmdarwin::doAction:: no response will be sent back "
672 				"(darwin response type is set to 'no' or 'darwin')\n");
673 		goto finalize_it;
674 	}
675 	darwin_filter_packet_t response;
676 	memset(&amp;response, 0, sizeof(response));
677 	DBGPRINTF("mmdarwin::doAction:: receiving from Darwin\n");
678 	CHKiRet(receiveMsg(pWrkrData, &amp;response, sizeof(response)));
679 	unsigned int certitude = response.certitude_list[0];
680 	DBGPRINTF("mmdarwin::doAction:: end of the transaction, certitude is %d\n", certitude);
681 	msgAddJSON(pMsg, (uchar *)pData-&gt;pCertitudeKey, json_object_new_int(certitude), 0, 0);
682 finalize_it :
683 	DBGPRINTF("mmdarwin::doAction:: finished processing log line\n");
684 ENDdoAction
685 NO_LEGACY_CONF_parseSelectorAct
686 BEGINmodExit
687 CODESTARTmodExit
688 	objRelease(glbl, CORE_COMPONENT);
689 ENDmodExit
690 BEGINqueryEtryPt
691 CODESTARTqueryEtryPt
692 CODEqueryEtryPt_STD_OMOD_QUERIES
693 CODEqueryEtryPt_STD_OMOD8_QUERIES
694 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
695 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
696 CODEqueryEtryPt_STD_CONF2_QUERIES
697 ENDqueryEtryPt
698 BEGINmodInit()
699 CODESTARTmodInit
700 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
701 CODEmodInit_QueryRegCFSLineHdlr
702 	DBGPRINTF("mmdarwin::modInit:: module compiled with rsyslog version %s.\n", VERSION);
703 	CHKiRet(objUse(glbl, CORE_COMPONENT));
704 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
