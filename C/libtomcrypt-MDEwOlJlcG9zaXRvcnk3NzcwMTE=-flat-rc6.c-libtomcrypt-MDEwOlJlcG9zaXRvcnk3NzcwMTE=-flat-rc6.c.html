
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rc6.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RC6
3  const struct ltc_cipher_descriptor rc6_desc =
4  {
5      "rc6",
6      3,
7      8, 128, 16, 20,
8      &rc6_setup,
9      &rc6_ecb_encrypt,
10      &rc6_ecb_decrypt,
11      &rc6_test,
12      &rc6_done,
13      &rc6_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  static const ulong32 stab[44] = {
17  0xb7e15163UL, 0x5618cb1cUL, 0xf45044d5UL, 0x9287be8eUL, 0x30bf3847UL, 0xcef6b200UL, 0x6d2e2bb9UL, 0x0b65a572UL,
18  0xa99d1f2bUL, 0x47d498e4UL, 0xe60c129dUL, 0x84438c56UL, 0x227b060fUL, 0xc0b27fc8UL, 0x5ee9f981UL, 0xfd21733aUL,
19  0x9b58ecf3UL, 0x399066acUL, 0xd7c7e065UL, 0x75ff5a1eUL, 0x1436d3d7UL, 0xb26e4d90UL, 0x50a5c749UL, 0xeedd4102UL,
20  0x8d14babbUL, 0x2b4c3474UL, 0xc983ae2dUL, 0x67bb27e6UL, 0x05f2a19fUL, 0xa42a1b58UL, 0x42619511UL, 0xe0990ecaUL,
21  0x7ed08883UL, 0x1d08023cUL, 0xbb3f7bf5UL, 0x5976f5aeUL, 0xf7ae6f67UL, 0x95e5e920UL, 0x341d62d9UL, 0xd254dc92UL,
22  0x708c564bUL, 0x0ec3d004UL, 0xacfb49bdUL, 0x4b32c376UL };
23  #ifdef LTC_CLEAN_STACK
24  static int s_rc6_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
25  #else
26  int rc6_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
27  #endif
28  {
29      ulong32 L[64], S[50], A, B, i, j, v, s, l;
30      LTC_ARGCHK(key != NULL);
31      LTC_ARGCHK(skey != NULL);
32      if (num_rounds != 0 && num_rounds != 20) {
33         return CRYPT_INVALID_ROUNDS;
34      }
35      if (keylen < 8 || keylen > 128) {
36         return CRYPT_INVALID_KEYSIZE;
37      }
38      for (A = i = j = 0; i < (ulong32)keylen; ) {
39          A = (A << 8) | ((ulong32)(key[i++] & 255));
40          if (!(i & 3)) {
41             L[j++] = BSWAP(A);
42             A = 0;
43          }
44      }
45      if (keylen & 3) {
46         A <<= (8 * (4 - (keylen&3)));
47         L[j++] = BSWAP(A);
48      }
49      XMEMCPY(S, stab, 44 * sizeof(stab[0]));
50      s = 3 * MAX(44, j);
51      l = j;
52      for (A = B = i = j = v = 0; v < s; v++) {
53          A = S[i] = ROLc(S[i] + A + B, 3);
54          B = L[j] = ROL(L[j] + A + B, (A+B));
55          if (++i == 44) { i = 0; }
56          if (++j == l)  { j = 0; }
57      }
58      for (i = 0; i < 44; i++) {
59          skey->rc6.K[i] = S[i];
60      }
61      return CRYPT_OK;
62  }
63  #ifdef LTC_CLEAN_STACK
64  int rc6_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
65  {
66     int x;
67     x = s_rc6_setup(key, keylen, num_rounds, skey);
68     burn_stack(sizeof(ulong32) * 122);
69     return x;
70  }
71  #endif
72  #ifdef LTC_CLEAN_STACK
73  static int s_rc6_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
74  #else
75  int rc6_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
76  #endif
77  {
78     ulong32 a,b,c,d,t,u;
79     const ulong32 *K;
80     int r;
81     LTC_ARGCHK(skey != NULL);
82     LTC_ARGCHK(pt   != NULL);
83     LTC_ARGCHK(ct   != NULL);
84     LOAD32L(a,&pt[0]);LOAD32L(b,&pt[4]);LOAD32L(c,&pt[8]);LOAD32L(d,&pt[12]);
85     b += skey->rc6.K[0];
86     d += skey->rc6.K[1];
87  #define RND(a,b,c,d) \
88         t = (b * (b + b + 1)); t = ROLc(t, 5); \
89         u = (d * (d + d + 1)); u = ROLc(u, 5); \
90         a = ROL(a^t,u) + K[0];                \
91         c = ROL(c^u,t) + K[1]; K += 2;
92     K = skey->rc6.K + 2;
93     for (r = 0; r < 20; r += 4) {
94         RND(a,b,c,d);
95         RND(b,c,d,a);
96         RND(c,d,a,b);
97         RND(d,a,b,c);
98     }
99  #undef RND
100     a += skey->rc6.K[42];
101     c += skey->rc6.K[43];
102     STORE32L(a,&ct[0]);STORE32L(b,&ct[4]);STORE32L(c,&ct[8]);STORE32L(d,&ct[12]);
103     return CRYPT_OK;
104  }
105  #ifdef LTC_CLEAN_STACK
106  int rc6_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
107  {
108     int err = s_rc6_ecb_encrypt(pt, ct, skey);
109     burn_stack(sizeof(ulong32) * 6 + sizeof(int));
110     return err;
111  }
112  #endif
113  #ifdef LTC_CLEAN_STACK
114  static int s_rc6_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
115  #else
116  int rc6_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
117  #endif
118  {
119     ulong32 a,b,c,d,t,u;
120     const ulong32 *K;
121     int r;
122     LTC_ARGCHK(skey != NULL);
123     LTC_ARGCHK(pt   != NULL);
124     LTC_ARGCHK(ct   != NULL);
125     LOAD32L(a,&ct[0]);LOAD32L(b,&ct[4]);LOAD32L(c,&ct[8]);LOAD32L(d,&ct[12]);
126     a -= skey->rc6.K[42];
127     c -= skey->rc6.K[43];
128  #define RND(a,b,c,d) \
129         t = (b * (b + b + 1)); t = ROLc(t, 5); \
130         u = (d * (d + d + 1)); u = ROLc(u, 5); \
131         c = ROR(c - K[1], t) ^ u; \
132         a = ROR(a - K[0], u) ^ t; K -= 2;
133     K = skey->rc6.K + 40;
134     for (r = 0; r < 20; r += 4) {
135         RND(d,a,b,c);
136         RND(c,d,a,b);
137         RND(b,c,d,a);
<span onclick='openModal()' class='match'>138         RND(a,b,c,d);
139     }
140  #undef RND
141     b -= skey->rc6.K[0];
</span>142     d -= skey->rc6.K[1];
143     STORE32L(a,&pt[0]);STORE32L(b,&pt[4]);STORE32L(c,&pt[8]);STORE32L(d,&pt[12]);
144     return CRYPT_OK;
145  }
146  #ifdef LTC_CLEAN_STACK
147  int rc6_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
148  {
149     int err = s_rc6_ecb_decrypt(ct, pt, skey);
150     burn_stack(sizeof(ulong32) * 6 + sizeof(int));
151     return err;
152  }
153  #endif
154  int rc6_test(void)
155  {
156   #ifndef LTC_TEST
157      return CRYPT_NOP;
158   #else
159     static const struct {
160         int keylen;
161         unsigned char key[32], pt[16], ct[16];
162     } tests[] = {
163     {
164         16,
165         { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
166           0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,
167           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
168           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
169         { 0x02, 0x13, 0x24, 0x35, 0x46, 0x57, 0x68, 0x79,
170           0x8a, 0x9b, 0xac, 0xbd, 0xce, 0xdf, 0xe0, 0xf1 },
171         { 0x52, 0x4e, 0x19, 0x2f, 0x47, 0x15, 0xc6, 0x23,
172           0x1f, 0x51, 0xf6, 0x36, 0x7e, 0xa4, 0x3f, 0x18 }
173     },
174     {
175         24,
176         { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
177           0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,
178           0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0,
179           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
180         { 0x02, 0x13, 0x24, 0x35, 0x46, 0x57, 0x68, 0x79,
181           0x8a, 0x9b, 0xac, 0xbd, 0xce, 0xdf, 0xe0, 0xf1 },
182         { 0x68, 0x83, 0x29, 0xd0, 0x19, 0xe5, 0x05, 0x04,
183           0x1e, 0x52, 0xe9, 0x2a, 0xf9, 0x52, 0x91, 0xd4 }
184     },
185     {
186         32,
187         { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
188           0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,
189           0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0,
190           0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe },
191         { 0x02, 0x13, 0x24, 0x35, 0x46, 0x57, 0x68, 0x79,
192           0x8a, 0x9b, 0xac, 0xbd, 0xce, 0xdf, 0xe0, 0xf1 },
193         { 0xc8, 0x24, 0x18, 0x16, 0xf0, 0xd7, 0xe4, 0x89,
194           0x20, 0xad, 0x16, 0xa1, 0x67, 0x4e, 0x5d, 0x48 }
195     }
196     };
197     unsigned char tmp[2][16];
198     int x, y, err;
199     symmetric_key key;
200     for (x  = 0; x < (int)(sizeof(tests) / sizeof(tests[0])); x++) {
201        if ((err = rc6_setup(tests[x].key, tests[x].keylen, 0, &key)) != CRYPT_OK) {
202           return err;
203        }
204        rc6_ecb_encrypt(tests[x].pt, tmp[0], &key);
205        rc6_ecb_decrypt(tmp[0], tmp[1], &key);
206        if (compare_testvector(tmp[0], 16, tests[x].ct, 16, "RC6 Encrypt", x) ||
207              compare_testvector(tmp[1], 16, tests[x].pt, 16, "RC6 Decrypt", x)) {
208           return CRYPT_FAIL_TESTVECTOR;
209        }
210        for (y = 0; y < 16; y++) tmp[0][y] = 0;
211        for (y = 0; y < 1000; y++) rc6_ecb_encrypt(tmp[0], tmp[0], &key);
212        for (y = 0; y < 1000; y++) rc6_ecb_decrypt(tmp[0], tmp[0], &key);
213        for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
214     }
215     return CRYPT_OK;
216    #endif
217  }
218  void rc6_done(symmetric_key *skey)
219  {
220    LTC_UNUSED_PARAM(skey);
221  }
222  int rc6_keysize(int *keysize)
223  {
224     LTC_ARGCHK(keysize != NULL);
225     if (*keysize < 8) {
226        return CRYPT_INVALID_KEYSIZE;
227     }
228     if (*keysize > 128) {
229        *keysize = 128;
230     }
231     return CRYPT_OK;
232  }
233  #endif &bsol;*LTC_RC6*/
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rc6.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RC6
3  const struct ltc_cipher_descriptor rc6_desc =
4  {
5      "rc6",
6      3,
7      8, 128, 16, 20,
8      &rc6_setup,
9      &rc6_ecb_encrypt,
10      &rc6_ecb_decrypt,
11      &rc6_test,
12      &rc6_done,
13      &rc6_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  static const ulong32 stab[44] = {
17  0xb7e15163UL, 0x5618cb1cUL, 0xf45044d5UL, 0x9287be8eUL, 0x30bf3847UL, 0xcef6b200UL, 0x6d2e2bb9UL, 0x0b65a572UL,
18  0xa99d1f2bUL, 0x47d498e4UL, 0xe60c129dUL, 0x84438c56UL, 0x227b060fUL, 0xc0b27fc8UL, 0x5ee9f981UL, 0xfd21733aUL,
19  0x9b58ecf3UL, 0x399066acUL, 0xd7c7e065UL, 0x75ff5a1eUL, 0x1436d3d7UL, 0xb26e4d90UL, 0x50a5c749UL, 0xeedd4102UL,
20  0x8d14babbUL, 0x2b4c3474UL, 0xc983ae2dUL, 0x67bb27e6UL, 0x05f2a19fUL, 0xa42a1b58UL, 0x42619511UL, 0xe0990ecaUL,
21  0x7ed08883UL, 0x1d08023cUL, 0xbb3f7bf5UL, 0x5976f5aeUL, 0xf7ae6f67UL, 0x95e5e920UL, 0x341d62d9UL, 0xd254dc92UL,
22  0x708c564bUL, 0x0ec3d004UL, 0xacfb49bdUL, 0x4b32c376UL };
23  #ifdef LTC_CLEAN_STACK
24  static int s_rc6_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
25  #else
26  int rc6_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
27  #endif
28  {
29      ulong32 L[64], S[50], A, B, i, j, v, s, l;
30      LTC_ARGCHK(key != NULL);
31      LTC_ARGCHK(skey != NULL);
32      if (num_rounds != 0 && num_rounds != 20) {
33         return CRYPT_INVALID_ROUNDS;
34      }
35      if (keylen < 8 || keylen > 128) {
36         return CRYPT_INVALID_KEYSIZE;
37      }
38      for (A = i = j = 0; i < (ulong32)keylen; ) {
39          A = (A << 8) | ((ulong32)(key[i++] & 255));
40          if (!(i & 3)) {
41             L[j++] = BSWAP(A);
42             A = 0;
43          }
44      }
45      if (keylen & 3) {
46         A <<= (8 * (4 - (keylen&3)));
47         L[j++] = BSWAP(A);
48      }
49      XMEMCPY(S, stab, 44 * sizeof(stab[0]));
50      s = 3 * MAX(44, j);
51      l = j;
52      for (A = B = i = j = v = 0; v < s; v++) {
53          A = S[i] = ROLc(S[i] + A + B, 3);
54          B = L[j] = ROL(L[j] + A + B, (A+B));
55          if (++i == 44) { i = 0; }
56          if (++j == l)  { j = 0; }
57      }
58      for (i = 0; i < 44; i++) {
59          skey->rc6.K[i] = S[i];
60      }
61      return CRYPT_OK;
62  }
63  #ifdef LTC_CLEAN_STACK
64  int rc6_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
65  {
66     int x;
67     x = s_rc6_setup(key, keylen, num_rounds, skey);
68     burn_stack(sizeof(ulong32) * 122);
69     return x;
70  }
71  #endif
72  #ifdef LTC_CLEAN_STACK
73  static int s_rc6_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
74  #else
75  int rc6_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
76  #endif
77  {
78     ulong32 a,b,c,d,t,u;
79     const ulong32 *K;
80     int r;
81     LTC_ARGCHK(skey != NULL);
82     LTC_ARGCHK(pt   != NULL);
83     LTC_ARGCHK(ct   != NULL);
84     LOAD32L(a,&pt[0]);LOAD32L(b,&pt[4]);LOAD32L(c,&pt[8]);LOAD32L(d,&pt[12]);
85     b += skey->rc6.K[0];
86     d += skey->rc6.K[1];
87  #define RND(a,b,c,d) \
88         t = (b * (b + b + 1)); t = ROLc(t, 5); \
89         u = (d * (d + d + 1)); u = ROLc(u, 5); \
90         a = ROL(a^t,u) + K[0];                \
91         c = ROL(c^u,t) + K[1]; K += 2;
92     K = skey->rc6.K + 2;
93     for (r = 0; r < 20; r += 4) {
94         RND(a,b,c,d);
95         RND(b,c,d,a);
96         RND(c,d,a,b);
<span onclick='openModal()' class='match'>97         RND(d,a,b,c);
98     }
99  #undef RND
100     a += skey->rc6.K[42];
</span>101     c += skey->rc6.K[43];
102     STORE32L(a,&ct[0]);STORE32L(b,&ct[4]);STORE32L(c,&ct[8]);STORE32L(d,&ct[12]);
103     return CRYPT_OK;
104  }
105  #ifdef LTC_CLEAN_STACK
106  int rc6_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
107  {
108     int err = s_rc6_ecb_encrypt(pt, ct, skey);
109     burn_stack(sizeof(ulong32) * 6 + sizeof(int));
110     return err;
111  }
112  #endif
113  #ifdef LTC_CLEAN_STACK
114  static int s_rc6_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
115  #else
116  int rc6_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
117  #endif
118  {
119     ulong32 a,b,c,d,t,u;
120     const ulong32 *K;
121     int r;
122     LTC_ARGCHK(skey != NULL);
123     LTC_ARGCHK(pt   != NULL);
124     LTC_ARGCHK(ct   != NULL);
125     LOAD32L(a,&ct[0]);LOAD32L(b,&ct[4]);LOAD32L(c,&ct[8]);LOAD32L(d,&ct[12]);
126     a -= skey->rc6.K[42];
127     c -= skey->rc6.K[43];
128  #define RND(a,b,c,d) \
129         t = (b * (b + b + 1)); t = ROLc(t, 5); \
130         u = (d * (d + d + 1)); u = ROLc(u, 5); \
131         c = ROR(c - K[1], t) ^ u; \
132         a = ROR(a - K[0], u) ^ t; K -= 2;
133     K = skey->rc6.K + 40;
134     for (r = 0; r < 20; r += 4) {
135         RND(d,a,b,c);
136         RND(c,d,a,b);
137         RND(b,c,d,a);
138         RND(a,b,c,d);
139     }
140  #undef RND
141     b -= skey->rc6.K[0];
142     d -= skey->rc6.K[1];
143     STORE32L(a,&pt[0]);STORE32L(b,&pt[4]);STORE32L(c,&pt[8]);STORE32L(d,&pt[12]);
144     return CRYPT_OK;
145  }
146  #ifdef LTC_CLEAN_STACK
147  int rc6_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
148  {
149     int err = s_rc6_ecb_decrypt(ct, pt, skey);
150     burn_stack(sizeof(ulong32) * 6 + sizeof(int));
151     return err;
152  }
153  #endif
154  int rc6_test(void)
155  {
156   #ifndef LTC_TEST
157      return CRYPT_NOP;
158   #else
159     static const struct {
160         int keylen;
161         unsigned char key[32], pt[16], ct[16];
162     } tests[] = {
163     {
164         16,
165         { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
166           0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,
167           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
168           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
169         { 0x02, 0x13, 0x24, 0x35, 0x46, 0x57, 0x68, 0x79,
170           0x8a, 0x9b, 0xac, 0xbd, 0xce, 0xdf, 0xe0, 0xf1 },
171         { 0x52, 0x4e, 0x19, 0x2f, 0x47, 0x15, 0xc6, 0x23,
172           0x1f, 0x51, 0xf6, 0x36, 0x7e, 0xa4, 0x3f, 0x18 }
173     },
174     {
175         24,
176         { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
177           0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,
178           0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0,
179           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
180         { 0x02, 0x13, 0x24, 0x35, 0x46, 0x57, 0x68, 0x79,
181           0x8a, 0x9b, 0xac, 0xbd, 0xce, 0xdf, 0xe0, 0xf1 },
182         { 0x68, 0x83, 0x29, 0xd0, 0x19, 0xe5, 0x05, 0x04,
183           0x1e, 0x52, 0xe9, 0x2a, 0xf9, 0x52, 0x91, 0xd4 }
184     },
185     {
186         32,
187         { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
188           0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,
189           0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0,
190           0x10, 0x32, 0x54, 0x76, 0x98, 0xba, 0xdc, 0xfe },
191         { 0x02, 0x13, 0x24, 0x35, 0x46, 0x57, 0x68, 0x79,
192           0x8a, 0x9b, 0xac, 0xbd, 0xce, 0xdf, 0xe0, 0xf1 },
193         { 0xc8, 0x24, 0x18, 0x16, 0xf0, 0xd7, 0xe4, 0x89,
194           0x20, 0xad, 0x16, 0xa1, 0x67, 0x4e, 0x5d, 0x48 }
195     }
196     };
197     unsigned char tmp[2][16];
198     int x, y, err;
199     symmetric_key key;
200     for (x  = 0; x < (int)(sizeof(tests) / sizeof(tests[0])); x++) {
201        if ((err = rc6_setup(tests[x].key, tests[x].keylen, 0, &key)) != CRYPT_OK) {
202           return err;
203        }
204        rc6_ecb_encrypt(tests[x].pt, tmp[0], &key);
205        rc6_ecb_decrypt(tmp[0], tmp[1], &key);
206        if (compare_testvector(tmp[0], 16, tests[x].ct, 16, "RC6 Encrypt", x) ||
207              compare_testvector(tmp[1], 16, tests[x].pt, 16, "RC6 Decrypt", x)) {
208           return CRYPT_FAIL_TESTVECTOR;
209        }
210        for (y = 0; y < 16; y++) tmp[0][y] = 0;
211        for (y = 0; y < 1000; y++) rc6_ecb_encrypt(tmp[0], tmp[0], &key);
212        for (y = 0; y < 1000; y++) rc6_ecb_decrypt(tmp[0], tmp[0], &key);
213        for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
214     }
215     return CRYPT_OK;
216    #endif
217  }
218  void rc6_done(symmetric_key *skey)
219  {
220    LTC_UNUSED_PARAM(skey);
221  }
222  int rc6_keysize(int *keysize)
223  {
224     LTC_ARGCHK(keysize != NULL);
225     if (*keysize < 8) {
226        return CRYPT_INVALID_KEYSIZE;
227     }
228     if (*keysize > 128) {
229        *keysize = 128;
230     }
231     return CRYPT_OK;
232  }
233  #endif &bsol;*LTC_RC6*/
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rc6.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rc6.c</div>
                </div>
                <div class="column column_space"><pre><code>138         RND(a,b,c,d);
139     }
140  #undef RND
141     b -= skey->rc6.K[0];
</pre></code></div>
                <div class="column column_space"><pre><code>97         RND(d,a,b,c);
98     }
99  #undef RND
100     a += skey->rc6.K[42];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    