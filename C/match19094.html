<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for bandrank.c &amp; magick7load.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for bandrank.c &amp; magick7load.c
      </h3>
<h1 align="center">
        7.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>bandrank.c (18.487394%)<th>magick7load.c (4.5454545%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(208-234)<td><a href="#" name="0">(800-827)</a><td align="center"><font color="#ff0000">22</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>bandrank.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;math.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include &lt;vips/debug.h&gt;
11 #include "bandary.h"
12 typedef struct _VipsBandrank {
13 	VipsBandary parent_instance;
14 	VipsArrayImage *in;
15 	int index;		} VipsBandrank;
16 typedef VipsBandaryClass VipsBandrankClass;
17 G_DEFINE_TYPE( VipsBandrank, vips_bandrank, VIPS_TYPE_BANDARY );
18 #define FIND_MAX( TYPE ) { \
19 	for( x = 0; x &lt; sz; x++ ) { \
20 		TYPE top = ((TYPE *) p[0])[x]; \
21  		\
22 		for( i = 1; i &lt; bandary-&gt;n; i++ ) { \
23 			TYPE v = ((TYPE *) p[i])[x]; \
24  			\
25 			if( v &gt; top ) \
26 				top = v; \
27 		} \
28  		\
29 		((TYPE *) q)[x] = top; \
30 	} \
31 }
32 #define FIND_MIN( TYPE ) { \
33 	for( x = 0; x &lt; sz; x++ ) { \
34 		TYPE bot = ((TYPE *) p[0])[x]; \
35  		\
36 		for( i = 1; i &lt; bandary-&gt;n; i++ ) { \
37 			TYPE v = ((TYPE *) p[i])[x]; \
38  			\
39 			if( v &lt; bot ) \
40 				bot = v; \
41 		} \
42  		\
43 		((TYPE *) q)[x] = bot; \
44 	} \
45 }
46 #define FIND_RANK( TYPE ) { \
47 	TYPE *sort = (TYPE *) sort_buffer; \
48 	\
49 	for( x = 0; x &lt; sz; x++ ) { \
50 		for( i = 0; i &lt; bandary-&gt;n; i++ ) { \
51 			TYPE v = ((TYPE *) p[i])[x]; \
52 			\
53 			for( j = 0; j &lt; i; j++ ) \
54 				if( sort[j] &gt; v ) \
55 					break; \
56 			\
57 			for( k = i; k &gt; j; k-- ) \
58 				sort[k] = sort[k - 1]; \
59 			\
60 			sort[j] = v; \
61 		} \
62 		\
63 		((TYPE *) q)[x] = sort[bandrank-&gt;index]; \
64 	} \
65 } 
66 #define SWITCH( OPERATION ) \
67 	switch( in[0]-&gt;BandFmt ) { \
68 	case VIPS_FORMAT_UCHAR:		OPERATION( unsigned char ); break; \
69 	case VIPS_FORMAT_CHAR:   	OPERATION( signed char ); break; \
70 	case VIPS_FORMAT_USHORT: 	OPERATION( unsigned short ); break; \
71 	case VIPS_FORMAT_SHORT:  	OPERATION( signed short ); break; \
72 	case VIPS_FORMAT_UINT:   	OPERATION( unsigned int ); break; \
73 	case VIPS_FORMAT_INT:    	OPERATION( signed int ); break; \
74 	case VIPS_FORMAT_FLOAT:  	OPERATION( float ); break; \
75 	case VIPS_FORMAT_DOUBLE: 	OPERATION( double ); break; \
76  	\
77 	default: \
78 		g_assert_not_reached(); \
79 	} 
80 static void
81 vips_bandrank_buffer( VipsBandarySequence *seq, 
82 	VipsPel *q, VipsPel **p, int width )
83 {
84 	VipsBandary *bandary = seq-&gt;bandary;
85 	VipsBandrank *bandrank = (VipsBandrank *) bandary;
86 	VipsImage **in = bandary-&gt;ready;
87 	int sz = width * in[0]-&gt;Bands; 
88 	VipsPel *sort_buffer = seq-&gt;pixels;
89 	int i, j, k;
90 	int x;
91 	if( bandrank-&gt;index == 0 ) 
92 		SWITCH( FIND_MIN )
93 	else if( bandrank-&gt;index == bandary-&gt;n - 1 )
94 		SWITCH( FIND_MAX )
95 	else
96 		SWITCH( FIND_RANK )
97 }
98 static int
99 vips_bandrank_build( VipsObject *object )
100 {
101 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
102 	VipsBandary *bandary = (VipsBandary *) object;
103 	VipsBandrank *bandrank = (VipsBandrank *) object;
104 	if( bandrank-&gt;in ) {
105 		int n;
106 		VipsImage **in = vips_array_image_get( bandrank-&gt;in, &amp;n );
107 		VipsImage **band = (VipsImage **) 
108 			vips_object_local_array( object, n );
109 		int i;
110 		for( i = 0; i &lt; n; i++ ) 
111 			if( vips_check_noncomplex( class-&gt;nickname, in[i] ) )
112 				return( -1 );
113 		if( n == 1 ) {
114 			bandary-&gt;in = in;
115 			bandary-&gt;n = 1;
116 			return( vips_bandary_copy( bandary ) );
117 		}
118 		if( vips__bandalike_vec( class-&gt;nickname, in, band, n, 0 ) )
119 			return( -1 ); 
120 		bandary-&gt;in = band;
121 		bandary-&gt;n = n;
122 		bandary-&gt;out_bands = band[0]-&gt;Bands;
123 <a name="0"></a>
124 		if( bandrank-&gt;index == -1 )
125 			bandrank-&gt;index = bandary-&gt;n / 2; 
126 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	}
127 	if( VIPS_OBJECT_CLASS( vips_bandrank_parent_class )-&gt;build( object ) )
128 		return( -1 );
129 	return( 0 );
130 }
131 static void
132 vips_bandrank_class_init( VipsBandrankClass *class )
133 {
134 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
135 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
136 	VipsBandaryClass *bandary_class = VIPS_BANDARY_CLASS( class );
137 	VIPS_DEBUG_MSG( "vips_bandrank_class_init\n" );
138 	gobject_class-&gt;set_property = vips_object_set_property;
139 	gobject_class-&gt;get_property = vips_object_get_property;
140 	vobject_class-&gt;nickname = "bandrank";
141 	vobject_class-&gt;description = _( "band-wise rank of a set of images" );
142 	vobject_class-&gt;build = vips_bandrank_build;
143 	bandary_class-&gt;process_line = vips_bandrank_buffer;
144 	VIPS_ARG_BOXED( class, "in", 0, </b></font>
145 		_( "Input" ), 
146 		_( "Array of input images" ),
147 		VIPS_ARGUMENT_REQUIRED_INPUT,
148 		G_STRUCT_OFFSET( VipsBandrank, in ),
149 		VIPS_TYPE_ARRAY_IMAGE );
150 	VIPS_ARG_INT( class, "index", 0, 
151 		_( "Index" ), 
152 		_( "Select this band element from sorted list" ),
153 		VIPS_ARGUMENT_OPTIONAL_INPUT,
154 		G_STRUCT_OFFSET( VipsBandrank, index ),
155 		-1, 1000000, -1 ); 
156 }
157 static void
158 vips_bandrank_init( VipsBandrank *bandrank )
159 {
160 	bandrank-&gt;index = -1;
161 }
162 static int
163 vips_bandrankv( VipsImage **in, VipsImage **out, int n, va_list ap )
164 {
165 	VipsArrayImage *array; 
166 	int result;
167 	array = vips_array_image_new( in, n ); 
168 	result = vips_call_split( "bandrank", ap, array, out );
169 	vips_area_unref( VIPS_AREA( array ) );
170 	return( result );
171 }
172 int
173 vips_bandrank( VipsImage **in, VipsImage **out, int n, ... )
174 {
175 	va_list ap;
176 	int result;
177 	va_start( ap, n );
178 	result = vips_bandrankv( in, out, n, ap );
179 	va_end( ap );
180 	return( result );
181 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>magick7load.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/buf.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #ifdef ENABLE_MAGICKLOAD
11 #ifdef HAVE_MAGICK7
12 #include &lt;MagickCore/MagickCore.h&gt;
13 #include "magick.h"
14 typedef struct _VipsForeignLoadMagick7 {
15 	VipsForeignLoad parent_object;
16 	gboolean all_frames;
17 	char *density;				int page;				int n;				
18 	Image *image;
19 	ImageInfo *image_info;
20 	ExceptionInfo *exception;
21 	int n_pages;
22 	int n_frames;				Image **frames;				CacheView **cache_view; 		int frame_height;	
23 	GMutex *lock;
24 } VipsForeignLoadMagick7;
25 typedef VipsForeignLoadClass VipsForeignLoadMagick7Class;
26 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadMagick7, vips_foreign_load_magick7, 
27 	VIPS_TYPE_FOREIGN_LOAD );
28 #ifdef DEBUG
29 static void
30 vips_magick7_print_traits( Image *image ) 
31 {
32 	static const int trait_bits[] = {
33 		CopyPixelTrait,
34 		UpdatePixelTrait,
35 		BlendPixelTrait
36 	};
37 	static const char *trait_names[] = {
38 		"CopyPixelTrait",
39 		"UpdatePixelTrait",
40 		"BlendPixelTrait"
41 	};
42 	int b; 
43 	int i; 
44 	printf( "vips_magick7_print_traits: channel traits:\n" ); 
45 	for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { 
46 		PixelChannel channel = 
47 			GetPixelChannelChannel( image, b ); 
48 		PixelTrait traits = 
49 			GetPixelChannelTraits( image, channel );
50 		printf( "\t%d) ", b ); 
51 		for( i = 0; i &lt; VIPS_NUMBER( trait_bits ); i++ )
52 			if( traits &amp; trait_bits[i] )
53 				printf( "%s ", trait_names[i] ); 
54 		if( traits == 0 )
55 			printf( "undefined" ); 
56 		printf( "\n" ); 
57 	} 
58 }
59 static void
60 vips_magick7_print_channel_names( Image *image )
61 {
62 	static const int pixel_channels[] = {
63 		UndefinedPixelChannel, 
64 		RedPixelChannel, 
65 		CyanPixelChannel, 
66 		GrayPixelChannel, 
67 		LPixelChannel, 
68 		LabelPixelChannel, 
69 		YPixelChannel, 
70 		aPixelChannel, 
71 		GreenPixelChannel, 
72 		MagentaPixelChannel, 
73 		CbPixelChannel, 
74 		bPixelChannel, 
75 		BluePixelChannel, 
76 		YellowPixelChannel, 
77 		CrPixelChannel, 
78 		BlackPixelChannel, 
79 		AlphaPixelChannel, 
80 		IndexPixelChannel, 
81 		ReadMaskPixelChannel, 
82 		WriteMaskPixelChannel, 
83 		MetaPixelChannel, 
84 		IntensityPixelChannel, 
85 		CompositePixelChannel, 
86 		SyncPixelChannel
87 	};
88 	static const char *pixel_channel_names[] = {
89 		"UndefinedPixelChannel", 
90 		"RedPixelChannel", 
91 		"CyanPixelChannel", 
92 		"GrayPixelChannel", 
93 		"LPixelChannel", 
94 		"LabelPixelChannel", 
95 		"YPixelChannel", 
96 		"aPixelChannel", 
97 		"GreenPixelChannel", 
98 		"MagentaPixelChannel", 
99 		"CbPixelChannel", 
100 		"bPixelChannel", 
101 		"BluePixelChannel", 
102 		"YellowPixelChannel", 
103 		"CrPixelChannel", 
104 		"BlackPixelChannel", 
105 		"AlphaPixelChannel", 
106 		"IndexPixelChannel", 
107 		"ReadMaskPixelChannel", 
108 		"WriteMaskPixelChannel", 
109 		"MetaPixelChannel", 
110 		"IntensityPixelChannel", 
111 		"CompositePixelChannel", 
112 		"SyncPixelChannel", 
113 	};
114 	int b; 
115 	int i; 
116 	printf( "vips_magick7_print_channel_names: channel names:\n" ); 
117 	for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { 
118 		PixelChannel channel = 
119 			GetPixelChannelChannel( image, b ); 
120 		printf( "\t%d) ", b ); 
121 		for( i = 0; i &lt; VIPS_NUMBER( pixel_channels ); i++ )
122 			if( channel == pixel_channels[i] ) 
123 				printf( "%s ", pixel_channel_names[i] );
124 		printf( "\n" ); 
125 	} 
126 }
127 static void
128 vips_magick7_print_image_type( Image *image )
129 {
130 	static const int image_types[] = {
131 		UndefinedType,
132 		BilevelType,
133 		GrayscaleType,
134 		GrayscaleAlphaType, 
135 		PaletteType,
136 		PaletteAlphaType,
137 		TrueColorType,
138 		TrueColorAlphaType,
139 		ColorSeparationType,
140 		ColorSeparationAlphaType,
141 		OptimizeType,
142 		PaletteBilevelAlphaType
143 	};
144 	static const char *image_type_names[] = {
145 		"UndefinedType",
146 		"BilevelType",
147 		"GrayscaleType",
148 		"GrayscaleAlphaType", 
149 		"PaletteType",
150 		"PaletteAlphaType",
151 		"TrueColorType",
152 		"TrueColorAlphaType",
153 		"ColorSeparationType",
154 		"ColorSeparationAlphaType",
155 		"OptimizeType",
156 		"PaletteBilevelAlphaType"
157 	};
158 	int i;
159 	for( i = 0; i &lt; VIPS_NUMBER( image_types ); i++ ) 
160 		if( GetImageType( image ) == image_types[i] ) {
161 			printf( "\t%s\n", image_type_names[i] );
162 			break;
163 		}
164 	if( i == VIPS_NUMBER( image_types ) )
165 		printf( "\tunknown GetImageType()\n" ); 
166 }
167 static VipsForeignFlags
168 vips_foreign_load_magick7_get_flags_filename( const char *filename )
169 {
170 	return( VIPS_FOREIGN_PARTIAL );
171 }
172 static VipsForeignFlags
173 vips_foreign_load_magick7_get_flags( VipsForeignLoad *load )
174 {
175 	return( VIPS_FOREIGN_PARTIAL );
176 }
177 static void
178 vips_foreign_load_magick7_dispose( GObject *gobject )
179 {
180 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) gobject;
181 	int i;
182 #ifdef DEBUG
183 	printf( "vips_foreign_load_magick7_dispose: %p\n", gobject ); 
184 	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
185 		VIPS_FREEF( DestroyCacheView, magick7-&gt;cache_view[i] ); 
186 	}
187 	VIPS_FREEF( DestroyImageList, magick7-&gt;image );
188 	VIPS_FREEF( DestroyImageInfo, magick7-&gt;image_info ); 
189 	VIPS_FREE( magick7-&gt;frames );
190 	VIPS_FREE( magick7-&gt;cache_view );
191 	VIPS_FREEF( magick_destroy_exception, magick7-&gt;exception ); 
192 	VIPS_FREEF( vips_g_mutex_free, magick7-&gt;lock );
193 	G_OBJECT_CLASS( vips_foreign_load_magick7_parent_class )-&gt;
194 		dispose( gobject );
195 }
196 static int
197 vips_foreign_load_magick7_build( VipsObject *object )
198 {
199 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) object;
200 #ifdef DEBUG
201 	printf( "vips_foreign_load_magick7_build: %p\n", object ); 
202 	magick_genesis();
203 	magick7-&gt;image_info = CloneImageInfo( NULL );
204 	magick7-&gt;exception = magick_acquire_exception();
205 	magick7-&gt;lock = vips_g_mutex_new();
206 	if( !magick7-&gt;image_info ) 
207 		return( -1 );
208 	if( magick7-&gt;all_frames )
209 		magick7-&gt;n = -1;
210 	VIPS_SETSTR( magick7-&gt;image_info-&gt;density, magick7-&gt;density );
211   	magick_set_image_option( magick7-&gt;image_info, 
212 		"dcm:display-range", "reset" );
213 	if( magick7-&gt;page &gt; 0 ) 
214 		magick_set_number_scenes( magick7-&gt;image_info,
215 			magick7-&gt;page, magick7-&gt;n );
216 	if( VIPS_OBJECT_CLASS( vips_foreign_load_magick7_parent_class )-&gt;
217 		build( object ) )
218 		return( -1 );
219 	return( 0 );
220 }
221 static void
222 vips_foreign_load_magick7_class_init( VipsForeignLoadMagick7Class *class )
223 {
224 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
225 	VipsObjectClass *object_class = (VipsObjectClass *) class;
226 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
227 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
228 	gobject_class-&gt;dispose = vips_foreign_load_magick7_dispose;
229 	gobject_class-&gt;set_property = vips_object_set_property;
230 	gobject_class-&gt;get_property = vips_object_get_property;
231 	object_class-&gt;nickname = "magickload_base";
232 	object_class-&gt;description = _( "load with ImageMagick7" );
233 	object_class-&gt;build = vips_foreign_load_magick7_build;
234 	foreign_class-&gt;priority = -100;
235 	load_class-&gt;get_flags_filename = 
236 		vips_foreign_load_magick7_get_flags_filename;
237 	load_class-&gt;get_flags = vips_foreign_load_magick7_get_flags;
238 	VIPS_ARG_STRING( class, "density", 20,
239 		_( "Density" ),
240 		_( "Canvas resolution for rendering vector formats like SVG" ),
241 		VIPS_ARGUMENT_OPTIONAL_INPUT,
242 		G_STRUCT_OFFSET( VipsForeignLoadMagick7, density ),
243 		NULL );
244 	VIPS_ARG_INT( class, "page", 21,
245 		_( "Page" ),
246 		_( "Load this page from the file" ),
247 		VIPS_ARGUMENT_OPTIONAL_INPUT,
248 		G_STRUCT_OFFSET( VipsForeignLoadMagick7, page ),
249 		0, 100000, 0 );
250 	VIPS_ARG_INT( class, "n", 22,
251 		_( "n" ),
252 		_( "Load this many pages" ),
253 		VIPS_ARGUMENT_OPTIONAL_INPUT,
254 		G_STRUCT_OFFSET( VipsForeignLoadMagick7, n ),
255 		-1, 100000, 1 );
256 	VIPS_ARG_BOOL( class, "all_frames", 23, 
257 		_( "all_frames" ), 
258 		_( "Read all frames from an image" ),
259 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
260 		G_STRUCT_OFFSET( VipsForeignLoadMagick7, all_frames ),
261 		FALSE );
262 }
263 static void
264 vips_foreign_load_magick7_init( VipsForeignLoadMagick7 *magick7 )
265 {
266 	magick7-&gt;n = 1;
267 }
268 static void
269 vips_foreign_load_magick7_error( VipsForeignLoadMagick7 *magick7 )
270 {
271 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( magick7 );
272 	vips_error( class-&gt;nickname, _( "Magick: %s %s" ),
273 		magick7-&gt;exception-&gt;reason, 
274 		magick7-&gt;exception-&gt;description );
275 }
276 static int
277 magick7_get_bands( Image *image )
278 {
279 	int bands;
280 	int i;
281 	bands = 0;
282 	for( i = 0; i &lt; GetPixelChannels( image ); i++ ) { 
283 		PixelChannel channel = GetPixelChannelChannel( image, i ); 
284 		if( channel != IndexPixelChannel ) 
285 			bands += 1;
286 	} 
287 	return( bands );
288 }
289 static int
290 vips_foreign_load_magick7_parse( VipsForeignLoadMagick7 *magick7, 
291 	Image *image, VipsImage *out )
292 {
293 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( magick7 );
294 	const char *key;
295 	Image *p;
296 #ifdef DEBUG
297 	printf( "image-&gt;depth = %zd\n", image-&gt;depth ); 
298 	printf( "GetImageType() = %d\n", GetImageType( image ) );
299 	vips_magick7_print_image_type( image ); 
300 	printf( "GetPixelChannels() = %zd\n", GetPixelChannels( image ) ); 
301 	printf( "image-&gt;columns = %zd\n", image-&gt;columns ); 
302 	printf( "image-&gt;rows = %zd\n", image-&gt;rows ); 
303 	out-&gt;Xsize = image-&gt;columns;
304 	out-&gt;Ysize = image-&gt;rows;
305 	magick7-&gt;frame_height = image-&gt;rows;
306 	out-&gt;Bands = magick7_get_bands( image ); 
307 	if( out-&gt;Xsize &lt;= 0 ||
308 		out-&gt;Ysize &lt;= 0 ||
309 		out-&gt;Bands &lt;= 0 ||
310 		out-&gt;Xsize &gt;= VIPS_MAX_COORD ||
311 		out-&gt;Ysize &gt;= VIPS_MAX_COORD ||
312 		out-&gt;Bands &gt;= VIPS_MAX_COORD ) {
313 		vips_error( class-&gt;nickname, 
314 			_( "bad image dimensions %d x %d pixels, %d bands" ),
315 			out-&gt;Xsize, out-&gt;Ysize, out-&gt;Bands );
316 		return( -1 );
317 	}
318 	out-&gt;BandFmt = -1;
319 	if( image-&gt;depth &gt;= 1 &amp;&amp; image-&gt;depth &lt;= 8 ) 
320 		out-&gt;BandFmt = VIPS_FORMAT_UCHAR;
321 	if( image-&gt;depth &gt;= 9 &amp;&amp; image-&gt;depth &lt;= 16 ) 
322 		out-&gt;BandFmt = VIPS_FORMAT_USHORT;
323 	if( image-&gt;depth == 32 )
324 		out-&gt;BandFmt = VIPS_FORMAT_FLOAT;
325 	if( image-&gt;depth == 64 )
326 		out-&gt;BandFmt = VIPS_FORMAT_DOUBLE;
327 	if( out-&gt;BandFmt == -1 ) {
328 		vips_error( class-&gt;nickname, 
329 			_( "unsupported bit depth %zd" ), image-&gt;depth );
330 		return( -1 );
331 	}
332 	switch( image-&gt;colorspace ) {
333 	case GRAYColorspace:
334 		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
335 			out-&gt;Type = VIPS_INTERPRETATION_GREY16;
336 		else
337 			out-&gt;Type = VIPS_INTERPRETATION_B_W;
338 		break;
339 	case sRGBColorspace:
340 	case RGBColorspace:
341 		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
342 			out-&gt;Type = VIPS_INTERPRETATION_RGB16;
343 		else
344 			out-&gt;Type = VIPS_INTERPRETATION_sRGB;
345 		break;
346 	case CMYKColorspace:
347 		out-&gt;Type = VIPS_INTERPRETATION_CMYK;
348 		break;
349 	default:
350 		vips_error( class-&gt;nickname, 
351 			_( "unsupported colorspace %s" ), 
352 			magick_ColorspaceType2str( image-&gt;colorspace ) );
353 		return( -1 );
354 	}
355 	switch( image-&gt;units ) {
356 	case PixelsPerInchResolution:
357 		out-&gt;Xres = image-&gt;resolution.x / 25.4;
358 		out-&gt;Yres = image-&gt;resolution.y / 25.4;
359 		vips_image_set_string( out, VIPS_META_RESOLUTION_UNIT, "in" );
360 		break;
361 	case PixelsPerCentimeterResolution:
362 		out-&gt;Xres = image-&gt;resolution.x / 10.0;
363 		out-&gt;Yres = image-&gt;resolution.y / 10.0;
364 		vips_image_set_string( out, VIPS_META_RESOLUTION_UNIT, "cm" );
365 		break;
366 	default:
367 		out-&gt;Xres = 1.0;
368 		out-&gt;Yres = 1.0;
369 		break;
370 	}
371 	out-&gt;Coding = VIPS_CODING_NONE;
372 	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_SMALLTILE, NULL ) )
373 		return( -1 );
374 	ResetImagePropertyIterator( image );
375 	while( (key = GetNextImageProperty( image )) ) {
376 		char name_text[256];
377 		VipsBuf name = VIPS_BUF_STATIC( name_text );
378 		const char *value;
379 		value = GetImageProperty( image, key, magick7-&gt;exception );
380 		if( !value ) {
381 			vips_foreign_load_magick7_error( magick7 );
382 			return( -1 ); 
383 		}
384 		vips_buf_appendf( &amp;name, "magick-%s", key );
385 		vips_image_set_string( out, vips_buf_all( &amp;name ), value );
386 	}
387 	if( magick_set_vips_profile( out, image ) )
388 		return( -1 );
389 	magick7-&gt;n_pages = GetImageListLength( GetFirstImageInList( image ) );
390 #ifdef DEBUG
391 	printf( "image has %d pages\n", magick7-&gt;n_pages );
392 	magick7-&gt;n_frames = 0;
393 	for( p = image; p; (p = GetNextImageInList( p )) ) {
394 		if( p-&gt;columns != (unsigned int) out-&gt;Xsize ||
395 			p-&gt;rows != (unsigned int) out-&gt;Ysize ||
396 			magick7_get_bands( p ) != out-&gt;Bands ||
397 			p-&gt;depth != image-&gt;depth ) {
398 #ifdef DEBUG
399 			printf( "frame %d differs\n", magick7-&gt;n_frames );
400 			printf( "%zdx%zd, %d bands\n", 
401 				p-&gt;columns, p-&gt;rows, magick7_get_bands( p ) );
402 			printf( "first frame is %dx%d, %d bands\n", 
403 				out-&gt;Xsize, out-&gt;Ysize, out-&gt;Bands );
404 			break;
405 		}
406 		magick7-&gt;n_frames += 1;
407 	}
408 	if( p ) 
409 		magick7-&gt;n_frames = 1;
410 #ifdef DEBUG
411 	printf( "will read %d frames\n", magick7-&gt;n_frames );
412 	if( magick7-&gt;n != -1 )
413 		magick7-&gt;n_frames = VIPS_MIN( magick7-&gt;n_frames, magick7-&gt;n );
414 	if( vips_object_argument_isset( VIPS_OBJECT( magick7 ), "n" ) ) {
415 		vips_image_set_int( out, VIPS_META_PAGE_HEIGHT, out-&gt;Ysize );
416 		out-&gt;Ysize *= magick7-&gt;n_frames;
417 	}
418 	vips_image_set_int( out, VIPS_META_N_PAGES, magick7-&gt;n_pages );
419 	return( 0 );
420 }
421 #define UNPACK( TYPE ) { \
422 	TYPE * restrict tq = (TYPE *) q; \
423 	int x; \
424 	int b; \
425 	\
426 	for( x = 0; x &lt; r-&gt;width; x++ ) { \
427 		for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { \
428 			PixelChannel channel = \
429 				GetPixelChannelChannel( image, b ); \
430 			\
431 			if( channel != IndexPixelChannel ) \
432 				*tq++ = p[b]; \
433 		} \
434 		\
435 		p += GetPixelChannels( image ); \
436 	} \
437 }
438 static int
439 vips_foreign_load_magick7_fill_region( VipsRegion *or, 
440 	void *seq, void *a, void *b, gboolean *stop )
441 {
442 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) a;
443 	VipsRect *r = &amp;or-&gt;valid;
444 	VipsImage *im = or-&gt;im;
445 	int y;
446 	for( y = 0; y &lt; r-&gt;height; y++ ) {
447 		int top = r-&gt;top + y;
448 		int frame = top / magick7-&gt;frame_height;
449 		int line = top % magick7-&gt;frame_height;
450 		Image *image = magick7-&gt;frames[frame];
451 		Quantum * restrict p;
452 		VipsPel * restrict q;
453 		g_mutex_lock( magick7-&gt;lock );
454 		p = GetCacheViewAuthenticPixels( magick7-&gt;cache_view[frame],
455 			r-&gt;left, line, r-&gt;width, 1, 
456 			magick7-&gt;exception );
457 		g_mutex_unlock( magick7-&gt;lock );
458 		if( !p ) 
459 			continue;
460 		q = VIPS_REGION_ADDR( or, r-&gt;left, top ); 
461 		switch( im-&gt;BandFmt ) {
462 		case VIPS_FORMAT_UCHAR:
463 			UNPACK( unsigned char ); 
464 			break;
465 		case VIPS_FORMAT_USHORT:
466 			UNPACK( unsigned short ); 
467 			break;
468 		case VIPS_FORMAT_FLOAT:
469 			UNPACK( float ); 
470 			break;
471 		case VIPS_FORMAT_DOUBLE:
472 			UNPACK( double ); 
473 			break;
474 		default:
475 			g_assert_not_reached();
476 		}
477 	}
478 	return( 0 );
479 }
480 static int
481 vips_foreign_load_magick7_load( VipsForeignLoadMagick7 *magick7 )
482 {
483 	VipsForeignLoad *load = (VipsForeignLoad *) magick7;
484 	Image *p;
485 	int i;
486 #ifdef DEBUG
487 	printf( "vips_foreign_load_magick7_load: %p\n", magick7 ); 
488 	if( vips_foreign_load_magick7_parse( magick7, 
489 		magick7-&gt;image, load-&gt;out ) )
490 		return( -1 );
491 	g_assert( !magick7-&gt;frames ); 
492 	if( !(magick7-&gt;frames = 
493 		VIPS_ARRAY( NULL, magick7-&gt;n_frames, Image * )) )
494 		return( -1 );
495 	p = magick7-&gt;image;
496 	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
497 		magick7-&gt;frames[i] = p;
498 		p = GetNextImageInList( p );
499 	}
500 	g_assert( !magick7-&gt;cache_view ); 
501 	if( !(magick7-&gt;cache_view = VIPS_ARRAY( NULL, 
502 		magick7-&gt;n_frames, CacheView * )) )
503 		return( -1 );
504 	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
505 		magick7-&gt;cache_view[i] = AcquireAuthenticCacheView( 
506 			magick7-&gt;frames[i], magick7-&gt;exception );
507 	}
508 #ifdef DEBUG
509 	vips_magick7_print_traits( magick7-&gt;frames[0] ); 
510 	vips_magick7_print_channel_names( magick7-&gt;frames[0] );
511 	if( vips_image_generate( load-&gt;out, 
512 		NULL, vips_foreign_load_magick7_fill_region, NULL, 
513 		magick7, NULL ) )
514 		return( -1 );
515 	return( 0 );
516 }
517 typedef struct _VipsForeignLoadMagick7File {
518 	VipsForeignLoadMagick7 parent_object;
519 	char *filename; 
520 } VipsForeignLoadMagick7File;
521 typedef VipsForeignLoadMagick7Class VipsForeignLoadMagick7FileClass;
522 G_DEFINE_TYPE( VipsForeignLoadMagick7File, vips_foreign_load_magick7_file, 
523 	vips_foreign_load_magick7_get_type() );
524 static gboolean
525 ismagick7( const char *filename )
526 {
527 	unsigned char buf[100];
528 	int len;
529 	return( (len = vips__get_bytes( filename, buf, 100 )) &gt; 10 &amp;&amp;
530 		magick_ismagick( buf, len ) );
531 }
532 static int
533 vips_foreign_load_magick7_file_header( VipsForeignLoad *load )
534 {
535 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) load;
536 	VipsForeignLoadMagick7File *file = (VipsForeignLoadMagick7File *) load;
537 #ifdef DEBUG
538 	printf( "vips_foreign_load_magick7_file_header: %p\n", load ); 
539 	vips_strncpy( magick7-&gt;image_info-&gt;filename, file-&gt;filename, 
540 		MagickPathExtent );
541 	magick_sniff_file( magick7-&gt;image_info, file-&gt;filename );
542 	magick7-&gt;image = ReadImage( magick7-&gt;image_info, magick7-&gt;exception );
543 <a name="0"></a>	if( !magick7-&gt;image ) {
544 		vips_foreign_load_magick7_error( magick7 ); 
545 		return( -1 );
546 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	}
547 	if( vips_foreign_load_magick7_load( magick7 ) )
548 		return( -1 );
549 	VIPS_SETSTR( load-&gt;out-&gt;filename, file-&gt;filename );
550 	return( 0 );
551 }
552 static void
553 vips_foreign_load_magick7_file_class_init( 
554 	VipsForeignLoadMagick7FileClass *class )
555 {
556 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
557 	VipsObjectClass *object_class = (VipsObjectClass *) class;
558 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
559 	gobject_class-&gt;set_property = vips_object_set_property;
560 	gobject_class-&gt;get_property = vips_object_get_property;
561 	object_class-&gt;nickname = "magickload";
562 	object_class-&gt;description = _( "load file with ImageMagick7" );
563 	load_class-&gt;is_a = ismagick7;
564 	load_class-&gt;header = vips_foreign_load_magick7_file_header;
565 	VIPS_ARG_STRING( class, "filename", 1, </b></font>
566 		_( "Filename" ),
567 		_( "Filename to load from" ),
568 		VIPS_ARGUMENT_REQUIRED_INPUT, 
569 		G_STRUCT_OFFSET( VipsForeignLoadMagick7File, filename ),
570 		NULL );
571 }
572 static void
573 vips_foreign_load_magick7_file_init( VipsForeignLoadMagick7File *magick7_file )
574 {
575 }
576 typedef struct _VipsForeignLoadMagick7Buffer {
577 	VipsForeignLoadMagick7 parent_object;
578 	VipsArea *buf;
579 } VipsForeignLoadMagick7Buffer;
580 typedef VipsForeignLoadMagick7Class VipsForeignLoadMagick7BufferClass;
581 G_DEFINE_TYPE( VipsForeignLoadMagick7Buffer, vips_foreign_load_magick7_buffer, 
582 	vips_foreign_load_magick7_get_type() );
583 static gboolean
584 vips_foreign_load_magick7_buffer_is_a_buffer( const void *buf, size_t len )
585 {
586 	return( len &gt; 10 &amp;&amp; magick_ismagick( (const unsigned char *) buf, len ) );
587 }
588 static int
589 vips_foreign_load_magick7_buffer_header( VipsForeignLoad *load )
590 {
591 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) load;
592 	VipsForeignLoadMagick7Buffer *magick7_buffer = 
593 		(VipsForeignLoadMagick7Buffer *) load;
594 #ifdef DEBUG
595 	printf( "vips_foreign_load_magick7_buffer_header: %p\n", load ); 
596 	magick_sniff_bytes( magick7-&gt;image_info, 
597 		magick7_buffer-&gt;buf-&gt;data, magick7_buffer-&gt;buf-&gt;length );
598 	magick7-&gt;image = BlobToImage( magick7-&gt;image_info, 
599 		magick7_buffer-&gt;buf-&gt;data, magick7_buffer-&gt;buf-&gt;length,
600 		magick7-&gt;exception );
601 	if( !magick7-&gt;image ) {
602 		vips_foreign_load_magick7_error( magick7 ); 
603 		return( -1 );
604 	}
605 	if( vips_foreign_load_magick7_load( magick7 ) )
606 		return( -1 );
607 	return( 0 );
608 }
609 static void
610 vips_foreign_load_magick7_buffer_class_init( 
611 	VipsForeignLoadMagick7BufferClass *class )
612 {
613 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
614 	VipsObjectClass *object_class = (VipsObjectClass *) class;
615 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
616 	gobject_class-&gt;set_property = vips_object_set_property;
617 	gobject_class-&gt;get_property = vips_object_get_property;
618 	object_class-&gt;nickname = "magickload_buffer";
619 	object_class-&gt;description = _( "load buffer with ImageMagick7" );
620 	load_class-&gt;is_a_buffer = vips_foreign_load_magick7_buffer_is_a_buffer;
621 	load_class-&gt;header = vips_foreign_load_magick7_buffer_header;
622 	VIPS_ARG_BOXED( class, "buffer", 1, 
623 		_( "Buffer" ),
624 		_( "Buffer to load from" ),
625 		VIPS_ARGUMENT_REQUIRED_INPUT, 
626 		G_STRUCT_OFFSET( VipsForeignLoadMagick7Buffer, buf ),
627 		VIPS_TYPE_BLOB );
628 }
629 static void
630 vips_foreign_load_magick7_buffer_init( VipsForeignLoadMagick7Buffer *buffer )
631 {
632 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
