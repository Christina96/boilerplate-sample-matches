
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hash.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_HASH_H
2  #define JEMALLOC_INTERNAL_HASH_H
3  #include "jemalloc/internal/assert.h"
4  static inline uint32_t
5  hash_rotl_32(uint32_t x, int8_t r) {
6  	return ((x << r) | (x >> (32 - r)));
7  }
8  static inline uint64_t
9  hash_rotl_64(uint64_t x, int8_t r) {
10  	return ((x << r) | (x >> (64 - r)));
11  }
12  static inline uint32_t
13  hash_get_block_32(const uint32_t *p, int i) {
14  	if (unlikely((uintptr_t)p & (sizeof(uint32_t)-1)) != 0) {
15  		uint32_t ret;
16  		memcpy(&ret, (uint8_t *)(p + i), sizeof(uint32_t));
17  		return ret;
18  	}
19  	return p[i];
20  }
21  static inline uint64_t
22  hash_get_block_64(const uint64_t *p, int i) {
23  	if (unlikely((uintptr_t)p & (sizeof(uint64_t)-1)) != 0) {
24  		uint64_t ret;
25  		memcpy(&ret, (uint8_t *)(p + i), sizeof(uint64_t));
26  		return ret;
27  	}
28  	return p[i];
29  }
30  static inline uint32_t
31  hash_fmix_32(uint32_t h) {
32  	h ^= h >> 16;
33  	h *= 0x85ebca6b;
<span onclick='openModal()' class='match'>34  	h ^= h >> 13;
35  	h *= 0xc2b2ae35;
36  	h ^= h >> 16;
37  	return h;
</span>38  }
39  static inline uint64_t
40  hash_fmix_64(uint64_t k) {
41  	k ^= k >> 33;
42  	k *= KQU(0xff51afd7ed558ccd);
43  	k ^= k >> 33;
44  	k *= KQU(0xc4ceb9fe1a85ec53);
45  	k ^= k >> 33;
46  	return k;
47  }
48  static inline uint32_t
49  hash_x86_32(const void *key, int len, uint32_t seed) {
50  	const uint8_t *data = (const uint8_t *) key;
51  	const int nblocks = len / 4;
52  	uint32_t h1 = seed;
53  	const uint32_t c1 = 0xcc9e2d51;
54  	const uint32_t c2 = 0x1b873593;
55  	{
56  		const uint32_t *blocks = (const uint32_t *) (data + nblocks*4);
57  		int i;
58  		for (i = -nblocks; i; i++) {
59  			uint32_t k1 = hash_get_block_32(blocks, i);
60  			k1 *= c1;
61  			k1 = hash_rotl_32(k1, 15);
62  			k1 *= c2;
63  			h1 ^= k1;
64  			h1 = hash_rotl_32(h1, 13);
65  			h1 = h1*5 + 0xe6546b64;
66  		}
67  	}
68  	{
69  		const uint8_t *tail = (const uint8_t *) (data + nblocks*4);
70  		uint32_t k1 = 0;
71  		switch (len & 3) {
72  		case 3: k1 ^= tail[2] << 16; JEMALLOC_FALLTHROUGH
73  		case 2: k1 ^= tail[1] << 8; JEMALLOC_FALLTHROUGH
74  		case 1: k1 ^= tail[0]; k1 *= c1; k1 = hash_rotl_32(k1, 15);
75  			k1 *= c2; h1 ^= k1;
76  		}
77  	}
78  	h1 ^= len;
79  	h1 = hash_fmix_32(h1);
80  	return h1;
81  }
82  static inline void
83  hash_x86_128(const void *key, const int len, uint32_t seed,
84      uint64_t r_out[2]) {
85  	const uint8_t * data = (const uint8_t *) key;
86  	const int nblocks = len / 16;
87  	uint32_t h1 = seed;
88  	uint32_t h2 = seed;
89  	uint32_t h3 = seed;
90  	uint32_t h4 = seed;
91  	const uint32_t c1 = 0x239b961b;
92  	const uint32_t c2 = 0xab0e9789;
93  	const uint32_t c3 = 0x38b34ae5;
94  	const uint32_t c4 = 0xa1e38b93;
95  	{
96  		const uint32_t *blocks = (const uint32_t *) (data + nblocks*16);
97  		int i;
98  		for (i = -nblocks; i; i++) {
99  			uint32_t k1 = hash_get_block_32(blocks, i*4 + 0);
100  			uint32_t k2 = hash_get_block_32(blocks, i*4 + 1);
101  			uint32_t k3 = hash_get_block_32(blocks, i*4 + 2);
102  			uint32_t k4 = hash_get_block_32(blocks, i*4 + 3);
103  			k1 *= c1; k1 = hash_rotl_32(k1, 15); k1 *= c2; h1 ^= k1;
104  			h1 = hash_rotl_32(h1, 19); h1 += h2;
105  			h1 = h1*5 + 0x561ccd1b;
106  			k2 *= c2; k2 = hash_rotl_32(k2, 16); k2 *= c3; h2 ^= k2;
107  			h2 = hash_rotl_32(h2, 17); h2 += h3;
108  			h2 = h2*5 + 0x0bcaa747;
109  			k3 *= c3; k3 = hash_rotl_32(k3, 17); k3 *= c4; h3 ^= k3;
110  			h3 = hash_rotl_32(h3, 15); h3 += h4;
111  			h3 = h3*5 + 0x96cd1c35;
112  			k4 *= c4; k4 = hash_rotl_32(k4, 18); k4 *= c1; h4 ^= k4;
113  			h4 = hash_rotl_32(h4, 13); h4 += h1;
114  			h4 = h4*5 + 0x32ac3b17;
115  		}
116  	}
117  	{
118  		const uint8_t *tail = (const uint8_t *) (data + nblocks*16);
119  		uint32_t k1 = 0;
120  		uint32_t k2 = 0;
121  		uint32_t k3 = 0;
122  		uint32_t k4 = 0;
123  		switch (len & 15) {
124  		case 15: k4 ^= tail[14] << 16; JEMALLOC_FALLTHROUGH
125  		case 14: k4 ^= tail[13] << 8; JEMALLOC_FALLTHROUGH
126  		case 13: k4 ^= tail[12] << 0;
127  			k4 *= c4; k4 = hash_rotl_32(k4, 18); k4 *= c1; h4 ^= k4;
128        JEMALLOC_FALLTHROUGH
129  		case 12: k3 ^= tail[11] << 24; JEMALLOC_FALLTHROUGH
130  		case 11: k3 ^= tail[10] << 16; JEMALLOC_FALLTHROUGH
131  		case 10: k3 ^= tail[ 9] << 8; JEMALLOC_FALLTHROUGH
132  		case  9: k3 ^= tail[ 8] << 0;
133  		     k3 *= c3; k3 = hash_rotl_32(k3, 17); k3 *= c4; h3 ^= k3;
134           JEMALLOC_FALLTHROUGH
135  		case  8: k2 ^= tail[ 7] << 24; JEMALLOC_FALLTHROUGH
136  		case  7: k2 ^= tail[ 6] << 16; JEMALLOC_FALLTHROUGH
137  		case  6: k2 ^= tail[ 5] << 8; JEMALLOC_FALLTHROUGH
138  		case  5: k2 ^= tail[ 4] << 0;
139  			k2 *= c2; k2 = hash_rotl_32(k2, 16); k2 *= c3; h2 ^= k2;
140        JEMALLOC_FALLTHROUGH
141  		case  4: k1 ^= tail[ 3] << 24; JEMALLOC_FALLTHROUGH
142  		case  3: k1 ^= tail[ 2] << 16; JEMALLOC_FALLTHROUGH
143  		case  2: k1 ^= tail[ 1] << 8; JEMALLOC_FALLTHROUGH
144  		case  1: k1 ^= tail[ 0] << 0;
145  			k1 *= c1; k1 = hash_rotl_32(k1, 15); k1 *= c2; h1 ^= k1;
146        JEMALLOC_FALLTHROUGH
147  		}
148  	}
149  	h1 ^= len; h2 ^= len; h3 ^= len; h4 ^= len;
150  	h1 += h2; h1 += h3; h1 += h4;
151  	h2 += h1; h3 += h1; h4 += h1;
152  	h1 = hash_fmix_32(h1);
153  	h2 = hash_fmix_32(h2);
154  	h3 = hash_fmix_32(h3);
155  	h4 = hash_fmix_32(h4);
156  	h1 += h2; h1 += h3; h1 += h4;
157  	h2 += h1; h3 += h1; h4 += h1;
158  	r_out[0] = (((uint64_t) h2) << 32) | h1;
159  	r_out[1] = (((uint64_t) h4) << 32) | h3;
160  }
161  static inline void
162  hash_x64_128(const void *key, const int len, const uint32_t seed,
163      uint64_t r_out[2]) {
164  	const uint8_t *data = (const uint8_t *) key;
165  	const int nblocks = len / 16;
166  	uint64_t h1 = seed;
167  	uint64_t h2 = seed;
168  	const uint64_t c1 = KQU(0x87c37b91114253d5);
169  	const uint64_t c2 = KQU(0x4cf5ad432745937f);
170  	{
171  		const uint64_t *blocks = (const uint64_t *) (data);
172  		int i;
173  		for (i = 0; i < nblocks; i++) {
174  			uint64_t k1 = hash_get_block_64(blocks, i*2 + 0);
175  			uint64_t k2 = hash_get_block_64(blocks, i*2 + 1);
176  			k1 *= c1; k1 = hash_rotl_64(k1, 31); k1 *= c2; h1 ^= k1;
177  			h1 = hash_rotl_64(h1, 27); h1 += h2;
178  			h1 = h1*5 + 0x52dce729;
179  			k2 *= c2; k2 = hash_rotl_64(k2, 33); k2 *= c1; h2 ^= k2;
180  			h2 = hash_rotl_64(h2, 31); h2 += h1;
181  			h2 = h2*5 + 0x38495ab5;
182  		}
183  	}
184  	{
185  		const uint8_t *tail = (const uint8_t*)(data + nblocks*16);
186  		uint64_t k1 = 0;
187  		uint64_t k2 = 0;
188  		switch (len & 15) {
189  		case 15: k2 ^= ((uint64_t)(tail[14])) << 48; JEMALLOC_FALLTHROUGH
190  		case 14: k2 ^= ((uint64_t)(tail[13])) << 40; JEMALLOC_FALLTHROUGH
191  		case 13: k2 ^= ((uint64_t)(tail[12])) << 32; JEMALLOC_FALLTHROUGH
192  		case 12: k2 ^= ((uint64_t)(tail[11])) << 24; JEMALLOC_FALLTHROUGH
193  		case 11: k2 ^= ((uint64_t)(tail[10])) << 16; JEMALLOC_FALLTHROUGH
194  		case 10: k2 ^= ((uint64_t)(tail[ 9])) << 8;  JEMALLOC_FALLTHROUGH
195  		case  9: k2 ^= ((uint64_t)(tail[ 8])) << 0;
196  			k2 *= c2; k2 = hash_rotl_64(k2, 33); k2 *= c1; h2 ^= k2;
197  			JEMALLOC_FALLTHROUGH
198  		case  8: k1 ^= ((uint64_t)(tail[ 7])) << 56; JEMALLOC_FALLTHROUGH
199  		case  7: k1 ^= ((uint64_t)(tail[ 6])) << 48; JEMALLOC_FALLTHROUGH
200  		case  6: k1 ^= ((uint64_t)(tail[ 5])) << 40; JEMALLOC_FALLTHROUGH
201  		case  5: k1 ^= ((uint64_t)(tail[ 4])) << 32; JEMALLOC_FALLTHROUGH
202  		case  4: k1 ^= ((uint64_t)(tail[ 3])) << 24; JEMALLOC_FALLTHROUGH
203  		case  3: k1 ^= ((uint64_t)(tail[ 2])) << 16; JEMALLOC_FALLTHROUGH
204  		case  2: k1 ^= ((uint64_t)(tail[ 1])) << 8;  JEMALLOC_FALLTHROUGH
205  		case  1: k1 ^= ((uint64_t)(tail[ 0])) << 0;
206  			k1 *= c1; k1 = hash_rotl_64(k1, 31); k1 *= c2; h1 ^= k1;
207  		}
208  	}
209  	h1 ^= len; h2 ^= len;
210  	h1 += h2;
211  	h2 += h1;
212  	h1 = hash_fmix_64(h1);
213  	h2 = hash_fmix_64(h2);
214  	h1 += h2;
215  	h2 += h1;
216  	r_out[0] = h1;
217  	r_out[1] = h2;
218  }
219  static inline void
220  hash(const void *key, size_t len, const uint32_t seed, size_t r_hash[2]) {
221  	assert(len <= INT_MAX); &bsol;* Unfortunate implementation limitation. */
222  #if (LG_SIZEOF_PTR == 3 && !defined(JEMALLOC_BIG_ENDIAN))
223  	hash_x64_128(key, (int)len, seed, (uint64_t *)r_hash);
224  #else
225  	{
226  		uint64_t hashes[2];
227  		hash_x86_128(key, (int)len, seed, hashes);
228  		r_hash[0] = (size_t)hashes[0];
229  		r_hash[1] = (size_t)hashes[1];
230  	}
231  #endif
232  }
233  #endif &bsol;* JEMALLOC_INTERNAL_HASH_H */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hash.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_HASH_H
2  #define JEMALLOC_INTERNAL_HASH_H
3  #include "jemalloc/internal/assert.h"
4  static inline uint32_t
5  hash_rotl_32(uint32_t x, int8_t r) {
6  	return ((x << r) | (x >> (32 - r)));
7  }
8  static inline uint64_t
9  hash_rotl_64(uint64_t x, int8_t r) {
10  	return ((x << r) | (x >> (64 - r)));
11  }
12  static inline uint32_t
13  hash_get_block_32(const uint32_t *p, int i) {
14  	if (unlikely((uintptr_t)p & (sizeof(uint32_t)-1)) != 0) {
15  		uint32_t ret;
16  		memcpy(&ret, (uint8_t *)(p + i), sizeof(uint32_t));
17  		return ret;
18  	}
19  	return p[i];
20  }
21  static inline uint64_t
22  hash_get_block_64(const uint64_t *p, int i) {
23  	if (unlikely((uintptr_t)p & (sizeof(uint64_t)-1)) != 0) {
24  		uint64_t ret;
25  		memcpy(&ret, (uint8_t *)(p + i), sizeof(uint64_t));
26  		return ret;
27  	}
28  	return p[i];
29  }
30  static inline uint32_t
31  hash_fmix_32(uint32_t h) {
32  	h ^= h >> 16;
33  	h *= 0x85ebca6b;
<span onclick='openModal()' class='match'>34  	h ^= h >> 13;
35  	h *= 0xc2b2ae35;
36  	h ^= h >> 16;
37  	return h;
</span>38  }
39  static inline uint64_t
40  hash_fmix_64(uint64_t k) {
41  	k ^= k >> 33;
42  	k *= KQU(0xff51afd7ed558ccd);
43  	k ^= k >> 33;
44  	k *= KQU(0xc4ceb9fe1a85ec53);
45  	k ^= k >> 33;
46  	return k;
47  }
48  static inline uint32_t
49  hash_x86_32(const void *key, int len, uint32_t seed) {
50  	const uint8_t *data = (const uint8_t *) key;
51  	const int nblocks = len / 4;
52  	uint32_t h1 = seed;
53  	const uint32_t c1 = 0xcc9e2d51;
54  	const uint32_t c2 = 0x1b873593;
55  	{
56  		const uint32_t *blocks = (const uint32_t *) (data + nblocks*4);
57  		int i;
58  		for (i = -nblocks; i; i++) {
59  			uint32_t k1 = hash_get_block_32(blocks, i);
60  			k1 *= c1;
61  			k1 = hash_rotl_32(k1, 15);
62  			k1 *= c2;
63  			h1 ^= k1;
64  			h1 = hash_rotl_32(h1, 13);
65  			h1 = h1*5 + 0xe6546b64;
66  		}
67  	}
68  	{
69  		const uint8_t *tail = (const uint8_t *) (data + nblocks*4);
70  		uint32_t k1 = 0;
71  		switch (len & 3) {
72  		case 3: k1 ^= tail[2] << 16; JEMALLOC_FALLTHROUGH
73  		case 2: k1 ^= tail[1] << 8; JEMALLOC_FALLTHROUGH
74  		case 1: k1 ^= tail[0]; k1 *= c1; k1 = hash_rotl_32(k1, 15);
75  			k1 *= c2; h1 ^= k1;
76  		}
77  	}
78  	h1 ^= len;
79  	h1 = hash_fmix_32(h1);
80  	return h1;
81  }
82  static inline void
83  hash_x86_128(const void *key, const int len, uint32_t seed,
84      uint64_t r_out[2]) {
85  	const uint8_t * data = (const uint8_t *) key;
86  	const int nblocks = len / 16;
87  	uint32_t h1 = seed;
88  	uint32_t h2 = seed;
89  	uint32_t h3 = seed;
90  	uint32_t h4 = seed;
91  	const uint32_t c1 = 0x239b961b;
92  	const uint32_t c2 = 0xab0e9789;
93  	const uint32_t c3 = 0x38b34ae5;
94  	const uint32_t c4 = 0xa1e38b93;
95  	{
96  		const uint32_t *blocks = (const uint32_t *) (data + nblocks*16);
97  		int i;
98  		for (i = -nblocks; i; i++) {
99  			uint32_t k1 = hash_get_block_32(blocks, i*4 + 0);
100  			uint32_t k2 = hash_get_block_32(blocks, i*4 + 1);
101  			uint32_t k3 = hash_get_block_32(blocks, i*4 + 2);
102  			uint32_t k4 = hash_get_block_32(blocks, i*4 + 3);
103  			k1 *= c1; k1 = hash_rotl_32(k1, 15); k1 *= c2; h1 ^= k1;
104  			h1 = hash_rotl_32(h1, 19); h1 += h2;
105  			h1 = h1*5 + 0x561ccd1b;
106  			k2 *= c2; k2 = hash_rotl_32(k2, 16); k2 *= c3; h2 ^= k2;
107  			h2 = hash_rotl_32(h2, 17); h2 += h3;
108  			h2 = h2*5 + 0x0bcaa747;
109  			k3 *= c3; k3 = hash_rotl_32(k3, 17); k3 *= c4; h3 ^= k3;
110  			h3 = hash_rotl_32(h3, 15); h3 += h4;
111  			h3 = h3*5 + 0x96cd1c35;
112  			k4 *= c4; k4 = hash_rotl_32(k4, 18); k4 *= c1; h4 ^= k4;
113  			h4 = hash_rotl_32(h4, 13); h4 += h1;
114  			h4 = h4*5 + 0x32ac3b17;
115  		}
116  	}
117  	{
118  		const uint8_t *tail = (const uint8_t *) (data + nblocks*16);
119  		uint32_t k1 = 0;
120  		uint32_t k2 = 0;
121  		uint32_t k3 = 0;
122  		uint32_t k4 = 0;
123  		switch (len & 15) {
124  		case 15: k4 ^= tail[14] << 16; JEMALLOC_FALLTHROUGH
125  		case 14: k4 ^= tail[13] << 8; JEMALLOC_FALLTHROUGH
126  		case 13: k4 ^= tail[12] << 0;
127  			k4 *= c4; k4 = hash_rotl_32(k4, 18); k4 *= c1; h4 ^= k4;
128        JEMALLOC_FALLTHROUGH
129  		case 12: k3 ^= tail[11] << 24; JEMALLOC_FALLTHROUGH
130  		case 11: k3 ^= tail[10] << 16; JEMALLOC_FALLTHROUGH
131  		case 10: k3 ^= tail[ 9] << 8; JEMALLOC_FALLTHROUGH
132  		case  9: k3 ^= tail[ 8] << 0;
133  		     k3 *= c3; k3 = hash_rotl_32(k3, 17); k3 *= c4; h3 ^= k3;
134           JEMALLOC_FALLTHROUGH
135  		case  8: k2 ^= tail[ 7] << 24; JEMALLOC_FALLTHROUGH
136  		case  7: k2 ^= tail[ 6] << 16; JEMALLOC_FALLTHROUGH
137  		case  6: k2 ^= tail[ 5] << 8; JEMALLOC_FALLTHROUGH
138  		case  5: k2 ^= tail[ 4] << 0;
139  			k2 *= c2; k2 = hash_rotl_32(k2, 16); k2 *= c3; h2 ^= k2;
140        JEMALLOC_FALLTHROUGH
141  		case  4: k1 ^= tail[ 3] << 24; JEMALLOC_FALLTHROUGH
142  		case  3: k1 ^= tail[ 2] << 16; JEMALLOC_FALLTHROUGH
143  		case  2: k1 ^= tail[ 1] << 8; JEMALLOC_FALLTHROUGH
144  		case  1: k1 ^= tail[ 0] << 0;
145  			k1 *= c1; k1 = hash_rotl_32(k1, 15); k1 *= c2; h1 ^= k1;
146        JEMALLOC_FALLTHROUGH
147  		}
148  	}
149  	h1 ^= len; h2 ^= len; h3 ^= len; h4 ^= len;
150  	h1 += h2; h1 += h3; h1 += h4;
151  	h2 += h1; h3 += h1; h4 += h1;
152  	h1 = hash_fmix_32(h1);
153  	h2 = hash_fmix_32(h2);
154  	h3 = hash_fmix_32(h3);
155  	h4 = hash_fmix_32(h4);
156  	h1 += h2; h1 += h3; h1 += h4;
157  	h2 += h1; h3 += h1; h4 += h1;
158  	r_out[0] = (((uint64_t) h2) << 32) | h1;
159  	r_out[1] = (((uint64_t) h4) << 32) | h3;
160  }
161  static inline void
162  hash_x64_128(const void *key, const int len, const uint32_t seed,
163      uint64_t r_out[2]) {
164  	const uint8_t *data = (const uint8_t *) key;
165  	const int nblocks = len / 16;
166  	uint64_t h1 = seed;
167  	uint64_t h2 = seed;
168  	const uint64_t c1 = KQU(0x87c37b91114253d5);
169  	const uint64_t c2 = KQU(0x4cf5ad432745937f);
170  	{
171  		const uint64_t *blocks = (const uint64_t *) (data);
172  		int i;
173  		for (i = 0; i < nblocks; i++) {
174  			uint64_t k1 = hash_get_block_64(blocks, i*2 + 0);
175  			uint64_t k2 = hash_get_block_64(blocks, i*2 + 1);
176  			k1 *= c1; k1 = hash_rotl_64(k1, 31); k1 *= c2; h1 ^= k1;
177  			h1 = hash_rotl_64(h1, 27); h1 += h2;
178  			h1 = h1*5 + 0x52dce729;
179  			k2 *= c2; k2 = hash_rotl_64(k2, 33); k2 *= c1; h2 ^= k2;
180  			h2 = hash_rotl_64(h2, 31); h2 += h1;
181  			h2 = h2*5 + 0x38495ab5;
182  		}
183  	}
184  	{
185  		const uint8_t *tail = (const uint8_t*)(data + nblocks*16);
186  		uint64_t k1 = 0;
187  		uint64_t k2 = 0;
188  		switch (len & 15) {
189  		case 15: k2 ^= ((uint64_t)(tail[14])) << 48; JEMALLOC_FALLTHROUGH
190  		case 14: k2 ^= ((uint64_t)(tail[13])) << 40; JEMALLOC_FALLTHROUGH
191  		case 13: k2 ^= ((uint64_t)(tail[12])) << 32; JEMALLOC_FALLTHROUGH
192  		case 12: k2 ^= ((uint64_t)(tail[11])) << 24; JEMALLOC_FALLTHROUGH
193  		case 11: k2 ^= ((uint64_t)(tail[10])) << 16; JEMALLOC_FALLTHROUGH
194  		case 10: k2 ^= ((uint64_t)(tail[ 9])) << 8;  JEMALLOC_FALLTHROUGH
195  		case  9: k2 ^= ((uint64_t)(tail[ 8])) << 0;
196  			k2 *= c2; k2 = hash_rotl_64(k2, 33); k2 *= c1; h2 ^= k2;
197  			JEMALLOC_FALLTHROUGH
198  		case  8: k1 ^= ((uint64_t)(tail[ 7])) << 56; JEMALLOC_FALLTHROUGH
199  		case  7: k1 ^= ((uint64_t)(tail[ 6])) << 48; JEMALLOC_FALLTHROUGH
200  		case  6: k1 ^= ((uint64_t)(tail[ 5])) << 40; JEMALLOC_FALLTHROUGH
201  		case  5: k1 ^= ((uint64_t)(tail[ 4])) << 32; JEMALLOC_FALLTHROUGH
202  		case  4: k1 ^= ((uint64_t)(tail[ 3])) << 24; JEMALLOC_FALLTHROUGH
203  		case  3: k1 ^= ((uint64_t)(tail[ 2])) << 16; JEMALLOC_FALLTHROUGH
204  		case  2: k1 ^= ((uint64_t)(tail[ 1])) << 8;  JEMALLOC_FALLTHROUGH
205  		case  1: k1 ^= ((uint64_t)(tail[ 0])) << 0;
206  			k1 *= c1; k1 = hash_rotl_64(k1, 31); k1 *= c2; h1 ^= k1;
207  		}
208  	}
209  	h1 ^= len; h2 ^= len;
210  	h1 += h2;
211  	h2 += h1;
212  	h1 = hash_fmix_64(h1);
213  	h2 = hash_fmix_64(h2);
214  	h1 += h2;
215  	h2 += h1;
216  	r_out[0] = h1;
217  	r_out[1] = h2;
218  }
219  static inline void
220  hash(const void *key, size_t len, const uint32_t seed, size_t r_hash[2]) {
221  	assert(len <= INT_MAX); &bsol;* Unfortunate implementation limitation. */
222  #if (LG_SIZEOF_PTR == 3 && !defined(JEMALLOC_BIG_ENDIAN))
223  	hash_x64_128(key, (int)len, seed, (uint64_t *)r_hash);
224  #else
225  	{
226  		uint64_t hashes[2];
227  		hash_x86_128(key, (int)len, seed, hashes);
228  		r_hash[0] = (size_t)hashes[0];
229  		r_hash[1] = (size_t)hashes[1];
230  	}
231  #endif
232  }
233  #endif &bsol;* JEMALLOC_INTERNAL_HASH_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hash.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hash.h</div>
                </div>
                <div class="column column_space"><pre><code>34  	h ^= h >> 13;
35  	h *= 0xc2b2ae35;
36  	h ^= h >> 16;
37  	return h;
</pre></code></div>
                <div class="column column_space"><pre><code>34  	h ^= h >> 13;
35  	h *= 0xc2b2ae35;
36  	h ^= h >> 16;
37  	return h;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    