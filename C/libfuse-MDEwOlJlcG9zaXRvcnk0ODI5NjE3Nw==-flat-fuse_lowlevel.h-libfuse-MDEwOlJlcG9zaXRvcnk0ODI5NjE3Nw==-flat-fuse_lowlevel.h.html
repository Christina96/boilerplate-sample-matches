
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fuse_lowlevel.h</h3>
            <pre><code>1  #ifndef FUSE_LOWLEVEL_H_
2  #define FUSE_LOWLEVEL_H_
3  #ifndef FUSE_USE_VERSION
4  #error FUSE_USE_VERSION not defined
5  #endif
6  #include "fuse_common.h"
7  #include <utime.h>
8  #include <fcntl.h>
9  #include <sys/types.h>
10  #include <sys/stat.h>
11  #include <sys/statvfs.h>
12  #include <sys/uio.h>
13  #ifdef __cplusplus
14  extern "C" {
15  #endif
16  #define FUSE_ROOT_ID 1
17  typedef uint64_t fuse_ino_t;
18  typedef struct fuse_req *fuse_req_t;
19  struct fuse_session;
20  struct fuse_entry_param {
21  	fuse_ino_t ino;
22  	uint64_t generation;
23  	struct stat attr;
24  	double attr_timeout;
25  	double entry_timeout;
26  };
27  struct fuse_ctx {
28  	uid_t uid;
29  	gid_t gid;
30  	pid_t pid;
31  	mode_t umask;
32  };
33  struct fuse_forget_data {
34  	fuse_ino_t ino;
35  	uint64_t nlookup;
36  };
37  struct fuse_custom_io {
38  	ssize_t (*writev)(int fd, struct iovec *iov, int count, void *userdata);
39  	ssize_t (*read)(int fd, void *buf, size_t buf_len, void *userdata);
40  	ssize_t (*splice_receive)(int fdin, off_t *offin, int fdout,
41  					  off_t *offout, size_t len,
42  				  	  unsigned int flags, void *userdata);
43  	ssize_t (*splice_send)(int fdin, off_t *offin, int fdout,
44  				     off_t *offout, size_t len,
45  			           unsigned int flags, void *userdata);
46  };
47  enum fuse_expire_flags {
48  	FUSE_LL_EXPIRE_ONLY	= (1 << 0),
49  };
50  #define FUSE_SET_ATTR_MODE	(1 << 0)
51  #define FUSE_SET_ATTR_UID	(1 << 1)
52  #define FUSE_SET_ATTR_GID	(1 << 2)
53  #define FUSE_SET_ATTR_SIZE	(1 << 3)
54  #define FUSE_SET_ATTR_ATIME	(1 << 4)
55  #define FUSE_SET_ATTR_MTIME	(1 << 5)
56  #define FUSE_SET_ATTR_ATIME_NOW	(1 << 7)
57  #define FUSE_SET_ATTR_MTIME_NOW	(1 << 8)
58  #define FUSE_SET_ATTR_FORCE	(1 << 9)
59  #define FUSE_SET_ATTR_CTIME	(1 << 10)
60  #define FUSE_SET_ATTR_KILL_SUID	(1 << 11)
61  #define FUSE_SET_ATTR_KILL_SGID	(1 << 12)
62  #define FUSE_SET_ATTR_FILE	(1 << 13)
63  #define FUSE_SET_ATTR_KILL_PRIV	(1 << 14)
64  #define FUSE_SET_ATTR_OPEN	(1 << 15)
65  #define FUSE_SET_ATTR_TIMES_SET	(1 << 16)
66  #define FUSE_SET_ATTR_TOUCH	(1 << 17)
67  struct fuse_lowlevel_ops {
68  	void (*init) (void *userdata, struct fuse_conn_info *conn);
69  	void (*destroy) (void *userdata);
70  	void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);
71  	void (*forget) (fuse_req_t req, fuse_ino_t ino, uint64_t nlookup);
72  	void (*getattr) (fuse_req_t req, fuse_ino_t ino,
73  			 struct fuse_file_info *fi);
74  	void (*setattr) (fuse_req_t req, fuse_ino_t ino, struct stat *attr,
75  			 int to_set, struct fuse_file_info *fi);
76  	void (*readlink) (fuse_req_t req, fuse_ino_t ino);
77  	void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
78  		       mode_t mode, dev_t rdev);
79  	void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
80  		       mode_t mode);
81  	void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);
82  	void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);
83  	void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
84  			 const char *name);
85  	void (*rename) (fuse_req_t req, fuse_ino_t parent, const char *name,
86  			fuse_ino_t newparent, const char *newname,
87  			unsigned int flags);
88  	void (*link) (fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
89  		      const char *newname);
90  	void (*open) (fuse_req_t req, fuse_ino_t ino,
91  		      struct fuse_file_info *fi);
92  	void (*read) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
93  		      struct fuse_file_info *fi);
94  	void (*write) (fuse_req_t req, fuse_ino_t ino, const char *buf,
95  		       size_t size, off_t off, struct fuse_file_info *fi);
96  	void (*flush) (fuse_req_t req, fuse_ino_t ino,
97  		       struct fuse_file_info *fi);
98  	void (*release) (fuse_req_t req, fuse_ino_t ino,
99  			 struct fuse_file_info *fi);
100  	void (*fsync) (fuse_req_t req, fuse_ino_t ino, int datasync,
101  		       struct fuse_file_info *fi);
102  	void (*opendir) (fuse_req_t req, fuse_ino_t ino,
103  			 struct fuse_file_info *fi);
104  	void (*readdir) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
105  			 struct fuse_file_info *fi);
106  	void (*releasedir) (fuse_req_t req, fuse_ino_t ino,
107  			    struct fuse_file_info *fi);
108  	void (*fsyncdir) (fuse_req_t req, fuse_ino_t ino, int datasync,
109  			  struct fuse_file_info *fi);
110  	void (*statfs) (fuse_req_t req, fuse_ino_t ino);
111  	void (*setxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
112  			  const char *value, size_t size, int flags);
113  	void (*getxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
114  			  size_t size);
115  	void (*listxattr) (fuse_req_t req, fuse_ino_t ino, size_t size);
116  	void (*removexattr) (fuse_req_t req, fuse_ino_t ino, const char *name);
117  	void (*access) (fuse_req_t req, fuse_ino_t ino, int mask);
118  	void (*create) (fuse_req_t req, fuse_ino_t parent, const char *name,
119  			mode_t mode, struct fuse_file_info *fi);
120  	void (*getlk) (fuse_req_t req, fuse_ino_t ino,
121  		       struct fuse_file_info *fi, struct flock *lock);
122  	void (*setlk) (fuse_req_t req, fuse_ino_t ino,
123  		       struct fuse_file_info *fi,
124  		       struct flock *lock, int sleep);
125  	void (*bmap) (fuse_req_t req, fuse_ino_t ino, size_t blocksize,
126  		      uint64_t idx);
127  #if FUSE_USE_VERSION < 35
128  	void (*ioctl) (fuse_req_t req, fuse_ino_t ino, int cmd,
129  		       void *arg, struct fuse_file_info *fi, unsigned flags,
130  		       const void *in_buf, size_t in_bufsz, size_t out_bufsz);
131  #else
132  	void (*ioctl) (fuse_req_t req, fuse_ino_t ino, unsigned int cmd,
133  		       void *arg, struct fuse_file_info *fi, unsigned flags,
134  		       const void *in_buf, size_t in_bufsz, size_t out_bufsz);
135  #endif
136  	void (*poll) (fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,
137  		      struct fuse_pollhandle *ph);
138  	void (*write_buf) (fuse_req_t req, fuse_ino_t ino,
139  			   struct fuse_bufvec *bufv, off_t off,
140  			   struct fuse_file_info *fi);
141  	void (*retrieve_reply) (fuse_req_t req, void *cookie, fuse_ino_t ino,
142  				off_t offset, struct fuse_bufvec *bufv);
143  	void (*forget_multi) (fuse_req_t req, size_t count,
144  			      struct fuse_forget_data *forgets);
145  	void (*flock) (fuse_req_t req, fuse_ino_t ino,
146  		       struct fuse_file_info *fi, int op);
147  	void (*fallocate) (fuse_req_t req, fuse_ino_t ino, int mode,
148  		       off_t offset, off_t length, struct fuse_file_info *fi);
149  	void (*readdirplus) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
150  			 struct fuse_file_info *fi);
151  	void (*copy_file_range) (fuse_req_t req, fuse_ino_t ino_in,
152  				 off_t off_in, struct fuse_file_info *fi_in,
153  				 fuse_ino_t ino_out, off_t off_out,
154  				 struct fuse_file_info *fi_out, size_t len,
155  				 int flags);
156  	void (*lseek) (fuse_req_t req, fuse_ino_t ino, off_t off, int whence,
157  		       struct fuse_file_info *fi);
158  };
159  int fuse_reply_err(fuse_req_t req, int err);
160  void fuse_reply_none(fuse_req_t req);
161  int fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e);
162  int fuse_reply_create(fuse_req_t req, const struct fuse_entry_param *e,
163  		      const struct fuse_file_info *fi);
164  int fuse_reply_attr(fuse_req_t req, const struct stat *attr,
165  		    double attr_timeout);
166  int fuse_reply_readlink(fuse_req_t req, const char *link);
167  int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *fi);
168  int fuse_reply_write(fuse_req_t req, size_t count);
169  int fuse_reply_buf(fuse_req_t req, const char *buf, size_t size);
170  int fuse_reply_data(fuse_req_t req, struct fuse_bufvec *bufv,
171  		    enum fuse_buf_copy_flags flags);
172  int fuse_reply_iov(fuse_req_t req, const struct iovec *iov, int count);
173  int fuse_reply_statfs(fuse_req_t req, const struct statvfs *stbuf);
174  int fuse_reply_xattr(fuse_req_t req, size_t count);
175  int fuse_reply_lock(fuse_req_t req, const struct flock *lock);
176  int fuse_reply_bmap(fuse_req_t req, uint64_t idx);
177  size_t fuse_add_direntry(fuse_req_t req, char *buf, size_t bufsize,
178  			 const char *name, const struct stat *stbuf,
179  			 off_t off);
180  size_t fuse_add_direntry_plus(fuse_req_t req, char *buf, size_t bufsize,
181  			      const char *name,
182  			      const struct fuse_entry_param *e, off_t off);
<span onclick='openModal()' class='match'>183  int fuse_reply_ioctl_retry(fuse_req_t req,
184  			   const struct iovec *in_iov, size_t in_count,
185  			   const struct iovec *out_iov, size_t out_count);
</span>186  int fuse_reply_ioctl(fuse_req_t req, int result, const void *buf, size_t size);
187  int fuse_reply_ioctl_iov(fuse_req_t req, int result, const struct iovec *iov,
188  			 int count);
189  int fuse_reply_poll(fuse_req_t req, unsigned revents);
190  int fuse_reply_lseek(fuse_req_t req, off_t off);
191  int fuse_lowlevel_notify_poll(struct fuse_pollhandle *ph);
192  int fuse_lowlevel_notify_inval_inode(struct fuse_session *se, fuse_ino_t ino,
193  				     off_t off, off_t len);
194  int fuse_lowlevel_notify_inval_entry(struct fuse_session *se, fuse_ino_t parent,
195  				     const char *name, size_t namelen);
196  int fuse_lowlevel_notify_expire_entry(struct fuse_session *se, fuse_ino_t parent,
197                                        const char *name, size_t namelen,
198                                        enum fuse_expire_flags flags);
199  int fuse_lowlevel_notify_delete(struct fuse_session *se,
200  				fuse_ino_t parent, fuse_ino_t child,
201  				const char *name, size_t namelen);
202  int fuse_lowlevel_notify_store(struct fuse_session *se, fuse_ino_t ino,
203  			       off_t offset, struct fuse_bufvec *bufv,
204  			       enum fuse_buf_copy_flags flags);
205  int fuse_lowlevel_notify_retrieve(struct fuse_session *se, fuse_ino_t ino,
206  				  size_t size, off_t offset, void *cookie);
207  void *fuse_req_userdata(fuse_req_t req);
208  const struct fuse_ctx *fuse_req_ctx(fuse_req_t req);
209  int fuse_req_getgroups(fuse_req_t req, int size, gid_t list[]);
210  typedef void (*fuse_interrupt_func_t)(fuse_req_t req, void *data);
211  void fuse_req_interrupt_func(fuse_req_t req, fuse_interrupt_func_t func,
212  			     void *data);
213  int fuse_req_interrupted(fuse_req_t req);
214  void fuse_lowlevel_version(void);
215  void fuse_lowlevel_help(void);
216  void fuse_cmdline_help(void);
217  struct fuse_cmdline_opts {
218  	int singlethread;
219  	int foreground;
220  	int debug;
221  	int nodefault_subtype;
222  	char *mountpoint;
223  	int show_version;
224  	int show_help;
225  	int clone_fd;
226  	unsigned int max_idle_threads; &bsol;* discouraged, due to thread
227  	                                * destruct overhead */
228  	unsigned int max_threads;
229  };
230  #if (defined(LIBFUSE_BUILT_WITH_VERSIONED_SYMBOLS))
231  int fuse_parse_cmdline(struct fuse_args *args,
232  		       struct fuse_cmdline_opts *opts);
233  #else
234  #if FUSE_USE_VERSION < FUSE_MAKE_VERSION(3, 12)
235  int fuse_parse_cmdline_30(struct fuse_args *args,
236  			   struct fuse_cmdline_opts *opts);
237  #define fuse_parse_cmdline(args, opts) fuse_parse_cmdline_30(args, opts)
238  #else
239  int fuse_parse_cmdline_312(struct fuse_args *args,
240  			   struct fuse_cmdline_opts *opts);
241  #define fuse_parse_cmdline(args, opts) fuse_parse_cmdline_312(args, opts)
242  #endif
243  #endif
244  struct fuse_session *fuse_session_new(struct fuse_args *args,
245  				      const struct fuse_lowlevel_ops *op,
246  				      size_t op_size, void *userdata);
247  int fuse_session_custom_io(struct fuse_session *se,
248  				   const struct fuse_custom_io *io, int fd);
249  int fuse_session_mount(struct fuse_session *se, const char *mountpoint);
250  int fuse_session_loop(struct fuse_session *se);
251  #if FUSE_USE_VERSION < 32
252  	int fuse_session_loop_mt_31(struct fuse_session *se, int clone_fd);
253  	#define fuse_session_loop_mt(se, clone_fd) fuse_session_loop_mt_31(se, clone_fd)
254  #elif FUSE_USE_VERSION < FUSE_MAKE_VERSION(3, 12)
255  	int fuse_session_loop_mt_32(struct fuse_session *se, struct fuse_loop_config *config);
256  	#define fuse_session_loop_mt(se, config) fuse_session_loop_mt_32(se, config)
257  #else
258  	#if (defined(LIBFUSE_BUILT_WITH_VERSIONED_SYMBOLS))
259  		int fuse_session_loop_mt(struct fuse_session *se, struct fuse_loop_config *config);
260  	#else
261  		int fuse_session_loop_mt_312(struct fuse_session *se, struct fuse_loop_config *config);
262  		#define fuse_session_loop_mt(se, config) fuse_session_loop_mt_312(se, config)
263  	#endif
264  #endif
265  void fuse_session_exit(struct fuse_session *se);
266  void fuse_session_reset(struct fuse_session *se);
267  int fuse_session_exited(struct fuse_session *se);
268  void fuse_session_unmount(struct fuse_session *se);
269  void fuse_session_destroy(struct fuse_session *se);
270  int fuse_session_fd(struct fuse_session *se);
271  void fuse_session_process_buf(struct fuse_session *se,
272  			      const struct fuse_buf *buf);
273  int fuse_session_receive_buf(struct fuse_session *se, struct fuse_buf *buf);
274  #ifdef __cplusplus
275  }
276  #endif
277  #endif &bsol;* FUSE_LOWLEVEL_H_ */
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fuse_lowlevel.h</h3>
            <pre><code>1  #ifndef FUSE_LOWLEVEL_H_
2  #define FUSE_LOWLEVEL_H_
3  #ifndef FUSE_USE_VERSION
4  #error FUSE_USE_VERSION not defined
5  #endif
6  #include "fuse_common.h"
7  #include <utime.h>
8  #include <fcntl.h>
9  #include <sys/types.h>
10  #include <sys/stat.h>
11  #include <sys/statvfs.h>
12  #include <sys/uio.h>
13  #ifdef __cplusplus
14  extern "C" {
15  #endif
16  #define FUSE_ROOT_ID 1
17  typedef uint64_t fuse_ino_t;
18  typedef struct fuse_req *fuse_req_t;
19  struct fuse_session;
20  struct fuse_entry_param {
21  	fuse_ino_t ino;
22  	uint64_t generation;
23  	struct stat attr;
24  	double attr_timeout;
25  	double entry_timeout;
26  };
27  struct fuse_ctx {
28  	uid_t uid;
29  	gid_t gid;
30  	pid_t pid;
31  	mode_t umask;
32  };
33  struct fuse_forget_data {
34  	fuse_ino_t ino;
35  	uint64_t nlookup;
36  };
37  struct fuse_custom_io {
38  	ssize_t (*writev)(int fd, struct iovec *iov, int count, void *userdata);
39  	ssize_t (*read)(int fd, void *buf, size_t buf_len, void *userdata);
40  	ssize_t (*splice_receive)(int fdin, off_t *offin, int fdout,
41  					  off_t *offout, size_t len,
42  				  	  unsigned int flags, void *userdata);
43  	ssize_t (*splice_send)(int fdin, off_t *offin, int fdout,
44  				     off_t *offout, size_t len,
45  			           unsigned int flags, void *userdata);
46  };
47  enum fuse_expire_flags {
48  	FUSE_LL_EXPIRE_ONLY	= (1 << 0),
49  };
50  #define FUSE_SET_ATTR_MODE	(1 << 0)
51  #define FUSE_SET_ATTR_UID	(1 << 1)
52  #define FUSE_SET_ATTR_GID	(1 << 2)
53  #define FUSE_SET_ATTR_SIZE	(1 << 3)
54  #define FUSE_SET_ATTR_ATIME	(1 << 4)
55  #define FUSE_SET_ATTR_MTIME	(1 << 5)
56  #define FUSE_SET_ATTR_ATIME_NOW	(1 << 7)
57  #define FUSE_SET_ATTR_MTIME_NOW	(1 << 8)
58  #define FUSE_SET_ATTR_FORCE	(1 << 9)
59  #define FUSE_SET_ATTR_CTIME	(1 << 10)
60  #define FUSE_SET_ATTR_KILL_SUID	(1 << 11)
61  #define FUSE_SET_ATTR_KILL_SGID	(1 << 12)
62  #define FUSE_SET_ATTR_FILE	(1 << 13)
63  #define FUSE_SET_ATTR_KILL_PRIV	(1 << 14)
64  #define FUSE_SET_ATTR_OPEN	(1 << 15)
65  #define FUSE_SET_ATTR_TIMES_SET	(1 << 16)
66  #define FUSE_SET_ATTR_TOUCH	(1 << 17)
67  struct fuse_lowlevel_ops {
68  	void (*init) (void *userdata, struct fuse_conn_info *conn);
69  	void (*destroy) (void *userdata);
70  	void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);
71  	void (*forget) (fuse_req_t req, fuse_ino_t ino, uint64_t nlookup);
72  	void (*getattr) (fuse_req_t req, fuse_ino_t ino,
73  			 struct fuse_file_info *fi);
74  	void (*setattr) (fuse_req_t req, fuse_ino_t ino, struct stat *attr,
75  			 int to_set, struct fuse_file_info *fi);
76  	void (*readlink) (fuse_req_t req, fuse_ino_t ino);
77  	void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
78  		       mode_t mode, dev_t rdev);
79  	void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
80  		       mode_t mode);
81  	void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);
82  	void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);
83  	void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
84  			 const char *name);
85  	void (*rename) (fuse_req_t req, fuse_ino_t parent, const char *name,
86  			fuse_ino_t newparent, const char *newname,
87  			unsigned int flags);
88  	void (*link) (fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
89  		      const char *newname);
90  	void (*open) (fuse_req_t req, fuse_ino_t ino,
91  		      struct fuse_file_info *fi);
92  	void (*read) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
93  		      struct fuse_file_info *fi);
94  	void (*write) (fuse_req_t req, fuse_ino_t ino, const char *buf,
95  		       size_t size, off_t off, struct fuse_file_info *fi);
96  	void (*flush) (fuse_req_t req, fuse_ino_t ino,
97  		       struct fuse_file_info *fi);
98  	void (*release) (fuse_req_t req, fuse_ino_t ino,
99  			 struct fuse_file_info *fi);
100  	void (*fsync) (fuse_req_t req, fuse_ino_t ino, int datasync,
101  		       struct fuse_file_info *fi);
102  	void (*opendir) (fuse_req_t req, fuse_ino_t ino,
103  			 struct fuse_file_info *fi);
104  	void (*readdir) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
105  			 struct fuse_file_info *fi);
106  	void (*releasedir) (fuse_req_t req, fuse_ino_t ino,
107  			    struct fuse_file_info *fi);
108  	void (*fsyncdir) (fuse_req_t req, fuse_ino_t ino, int datasync,
109  			  struct fuse_file_info *fi);
110  	void (*statfs) (fuse_req_t req, fuse_ino_t ino);
111  	void (*setxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
112  			  const char *value, size_t size, int flags);
113  	void (*getxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
114  			  size_t size);
115  	void (*listxattr) (fuse_req_t req, fuse_ino_t ino, size_t size);
116  	void (*removexattr) (fuse_req_t req, fuse_ino_t ino, const char *name);
117  	void (*access) (fuse_req_t req, fuse_ino_t ino, int mask);
118  	void (*create) (fuse_req_t req, fuse_ino_t parent, const char *name,
119  			mode_t mode, struct fuse_file_info *fi);
120  	void (*getlk) (fuse_req_t req, fuse_ino_t ino,
121  		       struct fuse_file_info *fi, struct flock *lock);
122  	void (*setlk) (fuse_req_t req, fuse_ino_t ino,
123  		       struct fuse_file_info *fi,
124  		       struct flock *lock, int sleep);
125  	void (*bmap) (fuse_req_t req, fuse_ino_t ino, size_t blocksize,
126  		      uint64_t idx);
127  #if FUSE_USE_VERSION < 35
128  	void (*ioctl) (fuse_req_t req, fuse_ino_t ino, int cmd,
129  		       void *arg, struct fuse_file_info *fi, unsigned flags,
130  		       const void *in_buf, size_t in_bufsz, size_t out_bufsz);
131  #else
132  	void (*ioctl) (fuse_req_t req, fuse_ino_t ino, unsigned int cmd,
133  		       void *arg, struct fuse_file_info *fi, unsigned flags,
134  		       const void *in_buf, size_t in_bufsz, size_t out_bufsz);
135  #endif
136  	void (*poll) (fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,
137  		      struct fuse_pollhandle *ph);
138  	void (*write_buf) (fuse_req_t req, fuse_ino_t ino,
139  			   struct fuse_bufvec *bufv, off_t off,
140  			   struct fuse_file_info *fi);
141  	void (*retrieve_reply) (fuse_req_t req, void *cookie, fuse_ino_t ino,
142  				off_t offset, struct fuse_bufvec *bufv);
143  	void (*forget_multi) (fuse_req_t req, size_t count,
144  			      struct fuse_forget_data *forgets);
145  	void (*flock) (fuse_req_t req, fuse_ino_t ino,
146  		       struct fuse_file_info *fi, int op);
147  	void (*fallocate) (fuse_req_t req, fuse_ino_t ino, int mode,
148  		       off_t offset, off_t length, struct fuse_file_info *fi);
149  	void (*readdirplus) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
150  			 struct fuse_file_info *fi);
151  	void (*copy_file_range) (fuse_req_t req, fuse_ino_t ino_in,
152  				 off_t off_in, struct fuse_file_info *fi_in,
153  				 fuse_ino_t ino_out, off_t off_out,
154  				 struct fuse_file_info *fi_out, size_t len,
155  				 int flags);
156  	void (*lseek) (fuse_req_t req, fuse_ino_t ino, off_t off, int whence,
157  		       struct fuse_file_info *fi);
158  };
159  int fuse_reply_err(fuse_req_t req, int err);
160  void fuse_reply_none(fuse_req_t req);
161  int fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e);
162  int fuse_reply_create(fuse_req_t req, const struct fuse_entry_param *e,
163  		      const struct fuse_file_info *fi);
164  int fuse_reply_attr(fuse_req_t req, const struct stat *attr,
165  		    double attr_timeout);
166  int fuse_reply_readlink(fuse_req_t req, const char *link);
167  int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *fi);
168  int fuse_reply_write(fuse_req_t req, size_t count);
169  int fuse_reply_buf(fuse_req_t req, const char *buf, size_t size);
170  int fuse_reply_data(fuse_req_t req, struct fuse_bufvec *bufv,
171  		    enum fuse_buf_copy_flags flags);
172  int fuse_reply_iov(fuse_req_t req, const struct iovec *iov, int count);
173  int fuse_reply_statfs(fuse_req_t req, const struct statvfs *stbuf);
174  int fuse_reply_xattr(fuse_req_t req, size_t count);
175  int fuse_reply_lock(fuse_req_t req, const struct flock *lock);
176  int fuse_reply_bmap(fuse_req_t req, uint64_t idx);
177  size_t fuse_add_direntry(fuse_req_t req, char *buf, size_t bufsize,
178  			 const char *name, const struct stat *stbuf,
179  			 off_t off);
180  size_t fuse_add_direntry_plus(fuse_req_t req, char *buf, size_t bufsize,
181  			      const char *name,
182  			      const struct fuse_entry_param *e, off_t off);
<span onclick='openModal()' class='match'>183  int fuse_reply_ioctl_retry(fuse_req_t req,
184  			   const struct iovec *in_iov, size_t in_count,
185  			   const struct iovec *out_iov, size_t out_count);
</span>186  int fuse_reply_ioctl(fuse_req_t req, int result, const void *buf, size_t size);
187  int fuse_reply_ioctl_iov(fuse_req_t req, int result, const struct iovec *iov,
188  			 int count);
189  int fuse_reply_poll(fuse_req_t req, unsigned revents);
190  int fuse_reply_lseek(fuse_req_t req, off_t off);
191  int fuse_lowlevel_notify_poll(struct fuse_pollhandle *ph);
192  int fuse_lowlevel_notify_inval_inode(struct fuse_session *se, fuse_ino_t ino,
193  				     off_t off, off_t len);
194  int fuse_lowlevel_notify_inval_entry(struct fuse_session *se, fuse_ino_t parent,
195  				     const char *name, size_t namelen);
196  int fuse_lowlevel_notify_expire_entry(struct fuse_session *se, fuse_ino_t parent,
197                                        const char *name, size_t namelen,
198                                        enum fuse_expire_flags flags);
199  int fuse_lowlevel_notify_delete(struct fuse_session *se,
200  				fuse_ino_t parent, fuse_ino_t child,
201  				const char *name, size_t namelen);
202  int fuse_lowlevel_notify_store(struct fuse_session *se, fuse_ino_t ino,
203  			       off_t offset, struct fuse_bufvec *bufv,
204  			       enum fuse_buf_copy_flags flags);
205  int fuse_lowlevel_notify_retrieve(struct fuse_session *se, fuse_ino_t ino,
206  				  size_t size, off_t offset, void *cookie);
207  void *fuse_req_userdata(fuse_req_t req);
208  const struct fuse_ctx *fuse_req_ctx(fuse_req_t req);
209  int fuse_req_getgroups(fuse_req_t req, int size, gid_t list[]);
210  typedef void (*fuse_interrupt_func_t)(fuse_req_t req, void *data);
211  void fuse_req_interrupt_func(fuse_req_t req, fuse_interrupt_func_t func,
212  			     void *data);
213  int fuse_req_interrupted(fuse_req_t req);
214  void fuse_lowlevel_version(void);
215  void fuse_lowlevel_help(void);
216  void fuse_cmdline_help(void);
217  struct fuse_cmdline_opts {
218  	int singlethread;
219  	int foreground;
220  	int debug;
221  	int nodefault_subtype;
222  	char *mountpoint;
223  	int show_version;
224  	int show_help;
225  	int clone_fd;
226  	unsigned int max_idle_threads; &bsol;* discouraged, due to thread
227  	                                * destruct overhead */
228  	unsigned int max_threads;
229  };
230  #if (defined(LIBFUSE_BUILT_WITH_VERSIONED_SYMBOLS))
231  int fuse_parse_cmdline(struct fuse_args *args,
232  		       struct fuse_cmdline_opts *opts);
233  #else
234  #if FUSE_USE_VERSION < FUSE_MAKE_VERSION(3, 12)
235  int fuse_parse_cmdline_30(struct fuse_args *args,
236  			   struct fuse_cmdline_opts *opts);
237  #define fuse_parse_cmdline(args, opts) fuse_parse_cmdline_30(args, opts)
238  #else
239  int fuse_parse_cmdline_312(struct fuse_args *args,
240  			   struct fuse_cmdline_opts *opts);
241  #define fuse_parse_cmdline(args, opts) fuse_parse_cmdline_312(args, opts)
242  #endif
243  #endif
244  struct fuse_session *fuse_session_new(struct fuse_args *args,
245  				      const struct fuse_lowlevel_ops *op,
246  				      size_t op_size, void *userdata);
247  int fuse_session_custom_io(struct fuse_session *se,
248  				   const struct fuse_custom_io *io, int fd);
249  int fuse_session_mount(struct fuse_session *se, const char *mountpoint);
250  int fuse_session_loop(struct fuse_session *se);
251  #if FUSE_USE_VERSION < 32
252  	int fuse_session_loop_mt_31(struct fuse_session *se, int clone_fd);
253  	#define fuse_session_loop_mt(se, clone_fd) fuse_session_loop_mt_31(se, clone_fd)
254  #elif FUSE_USE_VERSION < FUSE_MAKE_VERSION(3, 12)
255  	int fuse_session_loop_mt_32(struct fuse_session *se, struct fuse_loop_config *config);
256  	#define fuse_session_loop_mt(se, config) fuse_session_loop_mt_32(se, config)
257  #else
258  	#if (defined(LIBFUSE_BUILT_WITH_VERSIONED_SYMBOLS))
259  		int fuse_session_loop_mt(struct fuse_session *se, struct fuse_loop_config *config);
260  	#else
261  		int fuse_session_loop_mt_312(struct fuse_session *se, struct fuse_loop_config *config);
262  		#define fuse_session_loop_mt(se, config) fuse_session_loop_mt_312(se, config)
263  	#endif
264  #endif
265  void fuse_session_exit(struct fuse_session *se);
266  void fuse_session_reset(struct fuse_session *se);
267  int fuse_session_exited(struct fuse_session *se);
268  void fuse_session_unmount(struct fuse_session *se);
269  void fuse_session_destroy(struct fuse_session *se);
270  int fuse_session_fd(struct fuse_session *se);
271  void fuse_session_process_buf(struct fuse_session *se,
272  			      const struct fuse_buf *buf);
273  int fuse_session_receive_buf(struct fuse_session *se, struct fuse_buf *buf);
274  #ifdef __cplusplus
275  }
276  #endif
277  #endif &bsol;* FUSE_LOWLEVEL_H_ */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fuse_lowlevel.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fuse_lowlevel.h</div>
                </div>
                <div class="column column_space"><pre><code>183  int fuse_reply_ioctl_retry(fuse_req_t req,
184  			   const struct iovec *in_iov, size_t in_count,
185  			   const struct iovec *out_iov, size_t out_count);
</pre></code></div>
                <div class="column column_space"><pre><code>183  int fuse_reply_ioctl_retry(fuse_req_t req,
184  			   const struct iovec *in_iov, size_t in_count,
185  			   const struct iovec *out_iov, size_t out_count);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    