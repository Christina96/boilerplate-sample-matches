
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</h3>
            <pre><code>1  #define _GNU_SOURCE
2  #include &quot;fuse_config.h&quot;
3  #include &lt;stdio.h&gt;
4  #include &lt;stdlib.h&gt;
5  #include &lt;stdarg.h&gt;
6  #include &lt;string.h&gt;
7  #include &lt;unistd.h&gt;
8  #include &lt;fcntl.h&gt;
9  #include &lt;dirent.h&gt;
10  #include &lt;utime.h&gt;
11  #include &lt;errno.h&gt;
12  #include &lt;assert.h&gt;
13  #include &lt;sys/socket.h&gt;
14  #include &lt;sys/types.h&gt;
15  #include &lt;sys/stat.h&gt;
16  #include &lt;sys/un.h&gt;
17  #ifndef ALLPERMS
18  # define ALLPERMS (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)&amp;bsol;* 07777 */
19  #endif
20  static const char *basepath;
21  static const char *basepath_r;
22  static char testfile[1024];
23  static char testfile2[1024];
24  static char testdir[1024];
25  static char testdir2[1024];
26  static char testsock[1024];
27  static char subfile[1280];
28  static char testfile_r[1024];
29  static char testfile2_r[1024];
30  static char testdir_r[1024];
31  static char testdir2_r[1024];
32  static char subfile_r[1280];
33  static char testname[256];
34  static char testdata[] = &quot;abcdefghijklmnopqrstuvwxyz&quot;;
35  static char testdata2[] = &quot;1234567890-=qwertyuiop[]\asdfghjkl;&#x27;zxcvbnm,./&quot;;
36  static const char *testdir_files[] = { &quot;f1&quot;, &quot;f2&quot;, NULL};
37  static long seekdir_offsets[4];
38  static char zerodata[4096];
39  static int testdatalen = sizeof(testdata) - 1;
40  static int testdata2len = sizeof(testdata2) - 1;
41  static unsigned int testnum = 0;
42  static unsigned int select_test = 0;
43  static unsigned int skip_test = 0;
44  static unsigned int unlinked_test = 0;
45  #define MAX_ENTRIES 1024
46  #define MAX_TESTS 100
47  static struct test {
48  	int fd;
49  	struct stat stat;
50  } tests[MAX_TESTS];
51  static void test_perror(const char *func, const char *msg)
52  {
53  	fprintf(stderr, &quot;%s %s() - %s: %s\n&quot;, testname, func, msg,
54  		strerror(errno));
55  }
56  static void test_error(const char *func, const char *msg, ...)
57  	__attribute__ ((format (printf, 2, 3)));
58  static void __start_test(const char *fmt, ...)
59  	__attribute__ ((format (printf, 1, 2)));
60  static void test_error(const char *func, const char *msg, ...)
61  {
62  	va_list ap;
63  	fprintf(stderr, &quot;%s %s() - &quot;, testname, func);
64  	va_start(ap, msg);
65  	vfprintf(stderr, msg, ap);
66  	va_end(ap);
67  	fprintf(stderr, &quot;\n&quot;);
68  }
69  static int is_dot_or_dotdot(const char *name) {
70      return name[0] == &#x27;.&#x27; &amp;&amp;
71             (name[1] == &#x27;\0&#x27; || (name[1] == &#x27;.&#x27; &amp;&amp; name[2] == &#x27;\0&#x27;));
72  }
73  static void success(void)
74  {
75  	fprintf(stderr, &quot;%s OK\n&quot;, testname);
76  }
77  #define this_test (&amp;tests[testnum-1])
78  #define next_test (&amp;tests[testnum])
79  static void __start_test(const char *fmt, ...)
80  {
81  	unsigned int n;
82  	va_list ap;
83  	n = sprintf(testname, &quot;%3i [&quot;, testnum);
84  	va_start(ap, fmt);
85  	n += vsprintf(testname + n, fmt, ap);
86  	va_end(ap);
87  	sprintf(testname + n, &quot;]&quot;);
88  	sprintf(testfile, &quot;%s/testfile.%d&quot;, basepath, testnum);
89  	sprintf(testfile_r, &quot;%s/testfile.%d&quot;, basepath_r, testnum);
90  	if (testnum &gt; MAX_TESTS) {
91  		fprintf(stderr, &quot;%s - too many tests\n&quot;, testname);
92  		exit(1);
93  	}
94  	this_test-&gt;fd = -1;
95  }
96  #define start_test(msg, args...) { \
97  	testnum++; \
98  	if ((select_test &amp;&amp; testnum != select_test) || \
99  	    (testnum == skip_test)) { \
100  		return 0; \
101  	} \
102  	__start_test(msg, ##args);		\
103  }
104  #define PERROR(msg) test_perror(__FUNCTION__, msg)
105  #define ERROR(msg, args...) test_error(__FUNCTION__, msg, ##args)
106  #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
107  static int st_check_size(struct stat *st, int len)
108  {
109  	if (st-&gt;st_size != len) {
110  		ERROR(&quot;length %u instead of %u&quot;, (int) st-&gt;st_size,
111  		      (int) len);
112  		return -1;
113  	}
114  	return 0;
115  }
116  static int check_size(const char *path, int len)
117  {
118  	struct stat stbuf;
119  	int res = stat(path, &amp;stbuf);
120  	if (res == -1) {
121  		PERROR(&quot;stat&quot;);
122  		return -1;
123  	}
124  	return st_check_size(&amp;stbuf, len);
125  }
126  static int check_testfile_size(const char *path, int len)
127  {
128  	this_test-&gt;stat.st_size = len;
129  	return check_size(path, len);
130  }
131  static int st_check_type(struct stat *st, mode_t type)
132  {
133  	if ((st-&gt;st_mode &amp; S_IFMT) != type) {
134  		ERROR(&quot;type 0%o instead of 0%o&quot;, st-&gt;st_mode &amp; S_IFMT, type);
135  		return -1;
136  	}
137  	return 0;
138  }
139  static int check_type(const char *path, mode_t type)
140  {
141  	struct stat stbuf;
142  	int res = lstat(path, &amp;stbuf);
143  	if (res == -1) {
144  		PERROR(&quot;lstat&quot;);
145  		return -1;
146  	}
147  	return st_check_type(&amp;stbuf, type);
148  }
149  static int st_check_mode(struct stat *st, mode_t mode)
150  {
151  	if ((st-&gt;st_mode &amp; ALLPERMS) != mode) {
152  		ERROR(&quot;mode 0%o instead of 0%o&quot;, st-&gt;st_mode &amp; ALLPERMS,
153  		      mode);
154  		return -1;
155  	}
156  	return 0;
157  }
158  static int check_mode(const char *path, mode_t mode)
159  {
160  	struct stat stbuf;
161  	int res = lstat(path, &amp;stbuf);
162  	if (res == -1) {
163  		PERROR(&quot;lstat&quot;);
164  		return -1;
165  	}
166  	return st_check_mode(&amp;stbuf, mode);
167  }
168  static int check_testfile_mode(const char *path, mode_t mode)
169  {
170  	this_test-&gt;stat.st_mode &amp;= ~ALLPERMS;
171  	this_test-&gt;stat.st_mode |= mode;
172  	return check_mode(path, mode);
173  }
174  static int check_times(const char *path, time_t atime, time_t mtime)
175  {
176  	int err = 0;
177  	struct stat stbuf;
178  	int res = lstat(path, &amp;stbuf);
179  	if (res == -1) {
180  		PERROR(&quot;lstat&quot;);
181  		return -1;
182  	}
183  	if (stbuf.st_atime != atime) {
184  		ERROR(&quot;atime %li instead of %li&quot;, stbuf.st_atime, atime);
185  		err--;
186  	}
187  	if (stbuf.st_mtime != mtime) {
188  		ERROR(&quot;mtime %li instead of %li&quot;, stbuf.st_mtime, mtime);
189  		err--;
190  	}
191  	if (err)
192  		return -1;
193  	return 0;
194  }
195  #if 0
196  static int fcheck_times(int fd, time_t atime, time_t mtime)
197  {
198  	int err = 0;
199  	struct stat stbuf;
200  	int res = fstat(fd, &amp;stbuf);
201  	if (res == -1) {
202  		PERROR(&quot;fstat&quot;);
203  		return -1;
204  	}
205  	if (stbuf.st_atime != atime) {
206  		ERROR(&quot;atime %li instead of %li&quot;, stbuf.st_atime, atime);
207  		err--;
208  	}
209  	if (stbuf.st_mtime != mtime) {
210  		ERROR(&quot;mtime %li instead of %li&quot;, stbuf.st_mtime, mtime);
211  		err--;
212  	}
213  	if (err)
214  		return -1;
215  	return 0;
216  }
217  #endif
218  static int st_check_nlink(struct stat *st, nlink_t nlink)
219  {
220  	if (st-&gt;st_nlink != nlink) {
221  		ERROR(&quot;nlink %li instead of %li&quot;, (long) st-&gt;st_nlink,
222  		      (long) nlink);
223  		return -1;
224  	}
225  	return 0;
226  }
227  static int check_nlink(const char *path, nlink_t nlink)
228  {
229  	struct stat stbuf;
230  	int res = lstat(path, &amp;stbuf);
231  	if (res == -1) {
232  		PERROR(&quot;lstat&quot;);
233  		return -1;
234  	}
235  	return st_check_nlink(&amp;stbuf, nlink);
236  }
237  static int fcheck_stat(int fd, int flags, struct stat *st)
238  {
239  	struct stat stbuf;
240  	int res = fstat(fd, &amp;stbuf);
241  	if (res == -1) {
242  		if (flags &amp; O_PATH) {
243  			if (errno == ESTALE || errno == EIO ||
244  			    errno == ENOENT || errno == EBADF)
245  				return 0;
246  		}
247  		PERROR(&quot;fstat&quot;);
248  		return -1;
249  	}
250  	int err = 0;
251  	err += st_check_type(&amp;stbuf, st-&gt;st_mode &amp; S_IFMT);
252  	err += st_check_mode(&amp;stbuf, st-&gt;st_mode &amp; ALLPERMS);
253  	err += st_check_size(&amp;stbuf, st-&gt;st_size);
254  	err += st_check_nlink(&amp;stbuf, st-&gt;st_nlink);
255  	return err;
256  }
257  static int check_nonexist(const char *path)
258  {
259  	struct stat stbuf;
260  	int res = lstat(path, &amp;stbuf);
261  	if (res == 0) {
262  		ERROR(&quot;file should not exist&quot;);
263  		return -1;
264  	}
265  	if (errno != ENOENT) {
266  		ERROR(&quot;file should not exist: %s&quot;, strerror(errno));
267  		return -1;
268  	}
269  	return 0;
270  }
271  static int check_buffer(const char *buf, const char *data, unsigned len)
272  {
273  	if (memcmp(buf, data, len) != 0) {
274  		ERROR(&quot;data mismatch&quot;);
275  		return -1;
276  	}
277  	return 0;
278  }
279  static int check_data(const char *path, const char *data, int offset,
280  		      unsigned len)
281  {
282  	char buf[4096];
283  	int res;
284  	int fd = open(path, O_RDONLY);
285  	if (fd == -1) {
286  		PERROR(&quot;open&quot;);
287  		return -1;
288  	}
289  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
290  		PERROR(&quot;lseek&quot;);
291  		close(fd);
292  		return -1;
293  	}
294  	while (len) {
295  		int rdlen = len &lt; sizeof(buf) ? len : sizeof(buf);
296  		res = read(fd, buf, rdlen);
297  		if (res == -1) {
298  			PERROR(&quot;read&quot;);
299  			close(fd);
300  			return -1;
301  		}
302  		if (res != rdlen) {
303  			ERROR(&quot;short read: %u instead of %u&quot;, res, rdlen);
304  			close(fd);
305  			return -1;
306  		}
307  		if (check_buffer(buf, data, rdlen) != 0) {
308  			close(fd);
309  			return -1;
310  		}
311  		data += rdlen;
312  		len -= rdlen;
313  	}
314  	res = close(fd);
315  	if (res == -1) {
316  		PERROR(&quot;close&quot;);
317  		return -1;
318  	}
319  	return 0;
320  }
321  static int fcheck_data(int fd, const char *data, int offset,
322  		       unsigned len)
323  {
324  	char buf[4096];
325  	int res;
326  	if (lseek(fd, offset, SEEK_SET) == (off_t) -1) {
327  		PERROR(&quot;lseek&quot;);
328  		return -1;
329  	}
330  	while (len) {
331  		int rdlen = len &lt; sizeof(buf) ? len : sizeof(buf);
332  		res = read(fd, buf, rdlen);
333  		if (res == -1) {
334  			PERROR(&quot;read&quot;);
335  			return -1;
336  		}
337  		if (res != rdlen) {
338  			ERROR(&quot;short read: %u instead of %u&quot;, res, rdlen);
339  			return -1;
340  		}
341  		if (check_buffer(buf, data, rdlen) != 0) {
342  			return -1;
343  		}
344  		data += rdlen;
345  		len -= rdlen;
346  	}
347  	return 0;
348  }
349  static int check_dir_contents(const char *path, const char **contents)
350  {
351  	int i;
352  	int res;
353  	int err = 0;
354  	int found[MAX_ENTRIES];
355  	const char *cont[MAX_ENTRIES];
356  	DIR *dp;
357  	for (i = 0; contents[i]; i++) {
358  		assert(i &lt; MAX_ENTRIES - 3);
359  		found[i] = 0;
360  		cont[i] = contents[i];
361  	}
362  	cont[i] = NULL;
363  	dp = opendir(path);
364  	if (dp == NULL) {
365  		PERROR(&quot;opendir&quot;);
366  		return -1;
367  	}
368  	memset(found, 0, sizeof(found));
369  	while(1) {
370  		struct dirent *de;
371  		errno = 0;
372  		de = readdir(dp);
373  		if (de == NULL) {
374  			if (errno) {
375  				PERROR(&quot;readdir&quot;);
376  				closedir(dp);
377  				return -1;
378  			}
379  			break;
380  		}
381  		if (is_dot_or_dotdot(de-&gt;d_name))
382  			continue;
383  		for (i = 0; cont[i] != NULL; i++) {
384  			assert(i &lt; MAX_ENTRIES);
385  			if (strcmp(cont[i], de-&gt;d_name) == 0) {
386  				if (found[i]) {
387  					ERROR(&quot;duplicate entry &lt;%s&gt;&quot;,
388  					      de-&gt;d_name);
389  					err--;
390  				} else
391  					found[i] = 1;
392  				break;
393  			}
394  		}
395  		if (!cont[i]) {
396  			ERROR(&quot;unexpected entry &lt;%s&gt;&quot;, de-&gt;d_name);
397  			err --;
398  		}
399  	}
400  	for (i = 0; cont[i] != NULL; i++) {
401  		if (!found[i]) {
402  			ERROR(&quot;missing entry &lt;%s&gt;&quot;, cont[i]);
403  			err--;
404  		}
405  	}
406  	res = closedir(dp);
407  	if (res == -1) {
408  		PERROR(&quot;closedir&quot;);
409  		return -1;
410  	}
411  	if (err)
412  		return -1;
413  	return 0;
414  }
415  static int create_file(const char *path, const char *data, int len)
416  {
417  	int res;
418  	int fd;
419  	unlink(path);
420  	fd = creat(path, 0644);
421  	if (fd == -1) {
422  		PERROR(&quot;creat&quot;);
423  		return -1;
424  	}
425  	if (len) {
426  		res = write(fd, data, len);
427  		if (res == -1) {
428  			PERROR(&quot;write&quot;);
429  			close(fd);
430  			return -1;
431  		}
432  		if (res != len) {
433  			ERROR(&quot;write is short: %u instead of %u&quot;, res, len);
434  			close(fd);
435  			return -1;
436  		}
437  	}
438  	res = close(fd);
439  	if (res == -1) {
440  		PERROR(&quot;close&quot;);
441  		return -1;
442  	}
443  	res = check_type(path, S_IFREG);
444  	if (res == -1)
445  		return -1;
446  	res = check_mode(path, 0644);
447  	if (res == -1)
448  		return -1;
449  	res = check_nlink(path, 1);
450  	if (res == -1)
451  		return -1;
452  	res = check_size(path, len);
453  	if (res == -1)
454  		return -1;
455  	if (len) {
456  		res = check_data(path, data, 0, len);
457  		if (res == -1)
458  			return -1;
459  	}
460  	return 0;
461  }
462  static int create_path_fd(const char *path, const char *data, int len)
463  {
464  	int path_fd;
465  	int res;
466  	res = create_file(path, data, len);
467  	if (res == -1)
468  		return -1;
469  	path_fd = open(path, O_PATH);
470  	if (path_fd == -1)
471  		PERROR(&quot;open(O_PATH)&quot;);
472  	return path_fd;
473  }
474  static int create_testfile(const char *path, const char *data, int len)
475  {
476  	struct test *t = this_test;
477  	struct stat *st = &amp;t-&gt;stat;
478  	int res, fd;
479  	if (t-&gt;fd &gt; 0) {
480  		ERROR(&quot;testfile already created&quot;);
481  		return -1;
482  	}
483  	fd = create_path_fd(path, data, len);
484  	if (fd == -1)
485  		return -1;
486  	t-&gt;fd = fd;
487  	res = fstat(fd, st);
488  	if (res == -1) {
489  		PERROR(&quot;fstat&quot;);
490  		return -1;
491  	}
492  	return 0;
493  }
494  static int check_unlinked_testfile(int fd)
495  {
496  	struct stat *st = &amp;this_test-&gt;stat;
497  	st-&gt;st_nlink = 0;
498  	return fcheck_stat(fd, O_PATH, st);
499  }
500  static int check_unlinked_testfiles(void)
501  {
502  	int fd;
503  	int res, err = 0;
504  	int num = testnum;
505  	if (!unlinked_test)
506  		return 0;
507  	testnum = 0;
508  	while (testnum &lt; num) {
509  		fd = next_test-&gt;fd;
510  		start_test(&quot;check_unlinked_testfile&quot;);
511  		if (fd == -1)
512  			continue;
513  		err += check_unlinked_testfile(fd);
514  		res = close(fd);
515  		if (res == -1) {
516  			PERROR(&quot;close(test_fd)&quot;);
517  			err--;
518  		}
519  	}
520  	if (err) {
521  		fprintf(stderr, &quot;%i unlinked testfile checks failed\n&quot;, -err);
522  		return 1;
523  	}
524  	return err;
525  }
526  static int cleanup_dir(const char *path, const char **dir_files, int quiet)
527  {
528  	int i;
529  	int err = 0;
530  	for (i = 0; dir_files[i]; i++) {
531  		int res;
532  		char fpath[1280];
533  		sprintf(fpath, &quot;%s/%s&quot;, path, dir_files[i]);
534  		res = unlink(fpath);
535  		if (res == -1 &amp;&amp; !quiet) {
536  			PERROR(&quot;unlink&quot;);
537  			err --;
538  		}
539  	}
540  	if (err)
541  		return -1;
542  	return 0;
543  }
544  static int create_dir(const char *path, const char **dir_files)
545  {
546  	int res;
547  	int i;
548  	rmdir(path);
549  	res = mkdir(path, 0755);
550  	if (res == -1) {
551  		PERROR(&quot;mkdir&quot;);
552  		return -1;
553  	}
554  	res = check_type(path, S_IFDIR);
555  	if (res == -1)
556  		return -1;
557  	res = check_mode(path, 0755);
558  	if (res == -1)
559  		return -1;
560  	for (i = 0; dir_files[i]; i++) {
561  		char fpath[1280];
562  		sprintf(fpath, &quot;%s/%s&quot;, path, dir_files[i]);
563  		res = create_file(fpath, &quot;&quot;, 0);
564  		if (res == -1) {
565  			cleanup_dir(path, dir_files, 1);
566  			return -1;
567  		}
568  	}
569  	res = check_dir_contents(path, dir_files);
570  	if (res == -1) {
571  		cleanup_dir(path, dir_files, 1);
572  		return -1;
573  	}
574  	return 0;
575  }
576  static int test_truncate(int len)
577  {
578  	const char *data = testdata;
579  	int datalen = testdatalen;
580  	int res;
581  	start_test(&quot;truncate(%u)&quot;, (int) len);
582  	res = create_testfile(testfile, data, datalen);
583  	if (res == -1)
584  		return -1;
585  	res = truncate(testfile, len);
586  	if (res == -1) {
587  		PERROR(&quot;truncate&quot;);
588  		return -1;
589  	}
590  	res = check_testfile_size(testfile, len);
591  	if (res == -1)
592  		return -1;
593  	if (len &gt; 0) {
594  		if (len &lt;= datalen) {
595  			res = check_data(testfile, data, 0, len);
596  			if (res == -1)
597  				return -1;
598  		} else {
599  			res = check_data(testfile, data, 0, datalen);
600  			if (res == -1)
601  				return -1;
602  			res = check_data(testfile, zerodata, datalen,
603  					 len - datalen);
604  			if (res == -1)
605  				return -1;
606  		}
607  	}
608  	res = unlink(testfile);
609  	if (res == -1) {
610  		PERROR(&quot;unlink&quot;);
611  		return -1;
612  	}
613  	res = check_nonexist(testfile);
614  	if (res == -1)
615  		return -1;
616  	success();
617  	return 0;
618  }
619  static int test_ftruncate(int len, int mode)
620  {
621  	const char *data = testdata;
622  	int datalen = testdatalen;
623  	int res;
624  	int fd;
625  	start_test(&quot;ftruncate(%u) mode: 0%03o&quot;, len, mode);
626  	res = create_testfile(testfile, data, datalen);
627  	if (res == -1)
628  		return -1;
629  	fd = open(testfile, O_WRONLY);
630  	if (fd == -1) {
631  		PERROR(&quot;open&quot;);
632  		return -1;
633  	}
634  	res = fchmod(fd, mode);
635  	if (res == -1) {
636  		PERROR(&quot;fchmod&quot;);
637  		close(fd);
638  		return -1;
639  	}
640  	res = check_testfile_mode(testfile, mode);
641  	if (res == -1) {
642  		close(fd);
643  		return -1;
644  	}
645  	res = ftruncate(fd, len);
646  	if (res == -1) {
647  		PERROR(&quot;ftruncate&quot;);
648  		close(fd);
649  		return -1;
650  	}
651  	close(fd);
652  	res = check_testfile_size(testfile, len);
653  	if (res == -1)
654  		return -1;
655  	if (len &gt; 0) {
656  		if (len &lt;= datalen) {
657  			res = check_data(testfile, data, 0, len);
658  			if (res == -1)
659  				return -1;
660  		} else {
661  			res = check_data(testfile, data, 0, datalen);
662  			if (res == -1)
663  				return -1;
664  			res = check_data(testfile, zerodata, datalen,
665  					 len - datalen);
666  			if (res == -1)
667  				return -1;
668  		}
669  	}
670  	res = unlink(testfile);
671  	if (res == -1) {
672  		PERROR(&quot;unlink&quot;);
673  		return -1;
674  	}
675  	res = check_nonexist(testfile);
676  	if (res == -1)
677  		return -1;
678  	success();
679  	return 0;
680  }
681  static int test_seekdir(void)
682  {
683  	int i;
684  	int res;
685  	DIR *dp;
686  	struct dirent *de;
687  	start_test(&quot;seekdir&quot;);
688  	res = create_dir(testdir, testdir_files);
689  	if (res == -1)
690  		return res;
691  	dp = opendir(testdir);
692  	if (dp == NULL) {
693  		PERROR(&quot;opendir&quot;);
694  		return -1;
695  	}
696  	for (i = 0; i &lt; ARRAY_SIZE(seekdir_offsets); i++) {
697  		seekdir_offsets[i] = telldir(dp);
698  		errno = 0;
699  		de = readdir(dp);
700  		if (de == NULL) {
701  			if (errno) {
702  				PERROR(&quot;readdir&quot;);
703  				goto fail;
704  			}
705  			break;
706  		}
707  	}
708  	while (de)
709  		de = readdir(dp);
710  	for (i--; i &gt;= 0; i--) {
711  		seekdir(dp, seekdir_offsets[i]);
712  		de = readdir(dp);
713  		if (de == NULL) {
714  			ERROR(&quot;Unexpected end of directory after seekdir()&quot;);
715  			goto fail;
716  		}
717  	}
718  	closedir(dp);
719  	res = cleanup_dir(testdir, testdir_files, 0);
720  	if (!res)
721  		success();
722  	return res;
723  fail:
724  	closedir(dp);
725  	cleanup_dir(testdir, testdir_files, 1);
726  	return -1;
727  }
728  #ifdef HAVE_COPY_FILE_RANGE
729  static int test_copy_file_range(void)
730  {
731  	const char *data = testdata;
732  	int datalen = testdatalen;
733  	int err = 0;
734  	int res;
735  	int fd_in, fd_out;
736  	off_t pos_in = 0, pos_out = 0;
737  	start_test(&quot;copy_file_range&quot;);
738  	unlink(testfile);
<span onclick='openModal()' class='match'>739  	fd_in = open(testfile, O_CREAT | O_RDWR, 0644);
740  	if (fd_in == -1) {
741  		PERROR(&quot;creat&quot;);
</span>742  		return -1;
743  	}
744  	res = write(fd_in, data, datalen);
745  	if (res == -1) {
746  		PERROR(&quot;write&quot;);
747  		close(fd_in);
748  		return -1;
749  	}
750  	if (res != datalen) {
751  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
752  		close(fd_in);
753  		return -1;
754  	}
755  	unlink(testfile2);
756  	fd_out = creat(testfile2, 0644);
757  	if (fd_out == -1) {
758  		PERROR(&quot;creat&quot;);
759  		close(fd_in);
760  		return -1;
761  	}
762  	res = copy_file_range(fd_in, &amp;pos_in, fd_out, &amp;pos_out, datalen, 0);
763  	if (res == -1) {
764  		PERROR(&quot;copy_file_range&quot;);
765  		close(fd_in);
766  		close(fd_out);
767  		return -1;
768  	}
769  	if (res != datalen) {
770  		ERROR(&quot;copy is short: %u instead of %u&quot;, res, datalen);
771  		close(fd_in);
772  		close(fd_out);
773  		return -1;
774  	}
775  	res = close(fd_in);
776  	if (res == -1) {
777  		PERROR(&quot;close&quot;);
778  		close(fd_out);
779  		return -1;
780  	}
781  	res = close(fd_out);
782  	if (res == -1) {
783  		PERROR(&quot;close&quot;);
784  		return -1;
785  	}
786  	err = check_data(testfile2, data, 0, datalen);
787  	res = unlink(testfile);
788  	if (res == -1) {
789  		PERROR(&quot;unlink&quot;);
790  		return -1;
791  	}
792  	res = check_nonexist(testfile);
793  	if (res == -1)
794  		return -1;
795  	if (err)
796  		return -1;
797  	res = unlink(testfile2);
798  	if (res == -1) {
799  		PERROR(&quot;unlink&quot;);
800  		return -1;
801  	}
802  	res = check_nonexist(testfile2);
803  	if (res == -1)
804  		return -1;
805  	if (err)
806  		return -1;
807  	success();
808  	return 0;
809  }
810  #else
811  static int test_copy_file_range(void)
812  {
813  	return 0;
814  }
815  #endif
816  static int test_utime(void)
817  {
818  	struct utimbuf utm;
819  	time_t atime = 987631200;
820  	time_t mtime = 123116400;
821  	int res;
822  	start_test(&quot;utime&quot;);
823  	res = create_testfile(testfile, NULL, 0);
824  	if (res == -1)
825  		return -1;
826  	utm.actime = atime;
827  	utm.modtime = mtime;
828  	res = utime(testfile, &amp;utm);
829  	if (res == -1) {
830  		PERROR(&quot;utime&quot;);
831  		return -1;
832  	}
833  	res = check_times(testfile, atime, mtime);
834  	if (res == -1) {
835  		return -1;
836  	}
837  	res = unlink(testfile);
838  	if (res == -1) {
839  		PERROR(&quot;unlink&quot;);
840  		return -1;
841  	}
842  	res = check_nonexist(testfile);
843  	if (res == -1)
844  		return -1;
845  	success();
846  	return 0;
847  }
848  static int test_create(void)
849  {
850  	const char *data = testdata;
851  	int datalen = testdatalen;
852  	int err = 0;
853  	int res;
854  	int fd;
855  	start_test(&quot;create&quot;);
856  	unlink(testfile);
857  	fd = creat(testfile, 0644);
858  	if (fd == -1) {
859  		PERROR(&quot;creat&quot;);
860  		return -1;
861  	}
862  	res = write(fd, data, datalen);
863  	if (res == -1) {
864  		PERROR(&quot;write&quot;);
865  		close(fd);
866  		return -1;
867  	}
868  	if (res != datalen) {
869  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
870  		close(fd);
871  		return -1;
872  	}
873  	res = close(fd);
874  	if (res == -1) {
875  		PERROR(&quot;close&quot;);
876  		return -1;
877  	}
878  	res = check_type(testfile, S_IFREG);
879  	if (res == -1)
880  		return -1;
881  	err += check_mode(testfile, 0644);
882  	err += check_nlink(testfile, 1);
883  	err += check_size(testfile, datalen);
884  	err += check_data(testfile, data, 0, datalen);
885  	res = unlink(testfile);
886  	if (res == -1) {
887  		PERROR(&quot;unlink&quot;);
888  		return -1;
889  	}
890  	res = check_nonexist(testfile);
891  	if (res == -1)
892  		return -1;
893  	if (err)
894  		return -1;
895  	success();
896  	return 0;
897  }
898  static int test_create_unlink(void)
899  {
900  	const char *data = testdata;
901  	int datalen = testdatalen;
902  	int err = 0;
903  	int res;
904  	int fd;
905  	start_test(&quot;create+unlink&quot;);
906  	unlink(testfile);
907  	fd = open(testfile, O_CREAT | O_RDWR | O_TRUNC, 0644);
908  	if (fd == -1) {
909  		PERROR(&quot;creat&quot;);
910  		return -1;
911  	}
912  	res = unlink(testfile);
913  	if (res == -1) {
914  		PERROR(&quot;unlink&quot;);
915  		close(fd);
916  		return -1;
917  	}
918  	res = check_nonexist(testfile);
919  	if (res == -1) {
920  		close(fd);
921  		return -1;
922  	}
923  	res = write(fd, data, datalen);
924  	if (res == -1) {
925  		PERROR(&quot;write&quot;);
926  		close(fd);
927  		return -1;
928  	}
929  	if (res != datalen) {
930  		ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
931  		close(fd);
932  		return -1;
933  	}
934  	struct stat st = {
935  		.st_mode = S_IFREG | 0644,
936  		.st_size = datalen,
937  	};
938  	err = fcheck_stat(fd, O_RDWR, &amp;st);
939  	err += fcheck_data(fd, data, 0, datalen);
940  	res = close(fd);
941  	if (res == -1) {
942  		PERROR(&quot;close&quot;);
943  		err--;
944  	}
945  	if (err)
946  		return -1;
947  	success();
948  	return 0;
949  }
950  #ifndef __FreeBSD__
951  static int test_mknod(void)
952  {
953  	int err = 0;
954  	int res;
955  	start_test(&quot;mknod&quot;);
956  	unlink(testfile);
957  	res = mknod(testfile, 0644, 0);
958  	if (res == -1) {
959  		PERROR(&quot;mknod&quot;);
960  		return -1;
961  	}
962  	res = check_type(testfile, S_IFREG);
963  	if (res == -1)
964  		return -1;
965  	err += check_mode(testfile, 0644);
966  	err += check_nlink(testfile, 1);
967  	err += check_size(testfile, 0);
968  	res = unlink(testfile);
969  	if (res == -1) {
970  		PERROR(&quot;unlink&quot;);
971  		return -1;
972  	}
973  	res = check_nonexist(testfile);
974  	if (res == -1)
975  		return -1;
976  	if (err)
977  		return -1;
978  	success();
979  	return 0;
980  }
981  #endif
982  #define test_open(exist, flags, mode)  do_test_open(exist, flags, #flags, mode)
983  static int do_test_open(int exist, int flags, const char *flags_str, int mode)
984  {
985  	char buf[4096];
986  	const char *data = testdata;
987  	int datalen = testdatalen;
988  	unsigned currlen = 0;
989  	int err = 0;
990  	int res;
991  	int fd;
992  	off_t off;
993  	start_test(&quot;open(%s, %s, 0%03o)&quot;, exist ? &quot;+&quot; : &quot;-&quot;, flags_str, mode);
994  	unlink(testfile);
995  	if (exist) {
996  		res = create_file(testfile_r, testdata2, testdata2len);
997  		if (res == -1)
998  			return -1;
999  		currlen = testdata2len;
1000  	}
1001  	fd = open(testfile, flags, mode);
1002  	if ((flags &amp; O_CREAT) &amp;&amp; (flags &amp; O_EXCL) &amp;&amp; exist) {
1003  		if (fd != -1) {
1004  			ERROR(&quot;open should have failed&quot;);
1005  			close(fd);
1006  			return -1;
1007  		} else if (errno == EEXIST)
1008  			goto succ;
1009  	}
1010  	if (!(flags &amp; O_CREAT) &amp;&amp; !exist) {
1011  		if (fd != -1) {
1012  			ERROR(&quot;open should have failed&quot;);
1013  			close(fd);
1014  			return -1;
1015  		} else if (errno == ENOENT)
1016  			goto succ;
1017  	}
1018  	if (fd == -1) {
1019  		PERROR(&quot;open&quot;);
1020  		return -1;
1021  	}
1022  	if (flags &amp; O_TRUNC)
1023  		currlen = 0;
1024  	err += check_type(testfile, S_IFREG);
1025  	if (exist)
1026  		err += check_mode(testfile, 0644);
1027  	else
1028  		err += check_mode(testfile, mode);
1029  	err += check_nlink(testfile, 1);
1030  	err += check_size(testfile, currlen);
1031  	if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp; (mode &amp; S_IRUSR))
1032  		err += check_data(testfile, testdata2, 0, testdata2len);
1033  	res = write(fd, data, datalen);
1034  	if ((flags &amp; O_ACCMODE) != O_RDONLY) {
1035  		if (res == -1) {
1036  			PERROR(&quot;write&quot;);
1037  			err --;
1038  		} else if (res != datalen) {
1039  			ERROR(&quot;write is short: %u instead of %u&quot;, res, datalen);
1040  			err --;
1041  		} else {
1042  			if (datalen &gt; (int) currlen)
1043  				currlen = datalen;
1044  			err += check_size(testfile, currlen);
1045  			if (mode &amp; S_IRUSR) {
1046  				err += check_data(testfile, data, 0, datalen);
1047  				if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp;
1048  				    testdata2len &gt; datalen)
1049  					err += check_data(testfile,
1050  							  testdata2 + datalen,
1051  							  datalen,
1052  							  testdata2len - datalen);
1053  			}
1054  		}
1055  	} else {
1056  		if (res != -1) {
1057  			ERROR(&quot;write should have failed&quot;);
1058  			err --;
1059  		} else if (errno != EBADF) {
1060  			PERROR(&quot;write&quot;);
1061  			err --;
1062  		}
1063  	}
1064  	off = lseek(fd, SEEK_SET, 0);
1065  	if (off == (off_t) -1) {
1066  		PERROR(&quot;lseek&quot;);
1067  		err--;
1068  	} else if (off != 0) {
1069  		ERROR(&quot;offset should have returned 0&quot;);
1070  		err --;
1071  	}
1072  	res = read(fd, buf, sizeof(buf));
1073  	if ((flags &amp; O_ACCMODE) != O_WRONLY) {
1074  		if (res == -1) {
1075  			PERROR(&quot;read&quot;);
1076  			err--;
1077  		} else {
1078  			int readsize =
1079  				currlen &lt; sizeof(buf) ? currlen : sizeof(buf);
1080  			if (res != readsize) {
1081  				ERROR(&quot;read is short: %i instead of %u&quot;,
1082  				      res, readsize);
1083  				err--;
1084  			} else {
1085  				if ((flags &amp; O_ACCMODE) != O_RDONLY) {
1086  					err += check_buffer(buf, data, datalen);
1087  					if (exist &amp;&amp; !(flags &amp; O_TRUNC) &amp;&amp;
1088  					    testdata2len &gt; datalen)
1089  						err += check_buffer(buf + datalen,
1090  								    testdata2 + datalen,
1091  								    testdata2len - datalen);
1092  				} else if (exist)
1093  					err += check_buffer(buf, testdata2,
1094  							    testdata2len);
1095  			}
1096  		}
1097  	} else {
1098  		if (res != -1) {
1099  			ERROR(&quot;read should have failed&quot;);
1100  			err --;
1101  		} else if (errno != EBADF) {
1102  			PERROR(&quot;read&quot;);
1103  			err --;
1104  		}
1105  	}
1106  	res = close(fd);
1107  	if (res == -1) {
1108  		PERROR(&quot;close&quot;);
1109  		return -1;
1110  	}
1111  	res = unlink(testfile);
1112  	if (res == -1) {
1113  		PERROR(&quot;unlink&quot;);
1114  		return -1;
1115  	}
1116  	res = check_nonexist(testfile);
1117  	if (res == -1)
1118  		return -1;
1119  	res = check_nonexist(testfile_r);
1120  	if (res == -1)
1121  		return -1;
1122  	if (err)
1123  		return -1;
1124  succ:
1125  	success();
1126  	return 0;
1127  }
1128  #define test_open_acc(flags, mode, err)	 \
1129  	do_test_open_acc(flags, #flags, mode, err)
1130  static int do_test_open_acc(int flags, const char *flags_str, int mode, int err)
1131  {
1132  	const char *data = testdata;
1133  	int datalen = testdatalen;
1134  	int res;
1135  	int fd;
1136  	start_test(&quot;open_acc(%s) mode: 0%03o message: &#x27;%s&#x27;&quot;, flags_str, mode,
1137  		   strerror(err));
1138  	unlink(testfile);
1139  	res = create_testfile(testfile, data, datalen);
1140  	if (res == -1)
1141  		return -1;
1142  	res = chmod(testfile, mode);
1143  	if (res == -1) {
1144  		PERROR(&quot;chmod&quot;);
1145  		return -1;
1146  	}
1147  	res = check_testfile_mode(testfile, mode);
1148  	if (res == -1)
1149  		return -1;
1150  	fd = open(testfile, flags);
1151  	if (fd == -1) {
1152  		if (err != errno) {
1153  			PERROR(&quot;open&quot;);
1154  			return -1;
1155  		}
1156  	} else {
1157  		if (err) {
1158  			ERROR(&quot;open should have failed&quot;);
1159  			close(fd);
1160  			return -1;
1161  		}
1162  		close(fd);
1163  	}
1164  	res = unlink(testfile);
1165  	if (res == -1) {
1166  		PERROR(&quot;unlink&quot;);
1167  		return -1;
1168  	}
1169  	res = check_nonexist(testfile);
1170  	if (res == -1)
1171  		return -1;
1172  	res = check_nonexist(testfile_r);
1173  	if (res == -1)
1174  		return -1;
1175  	success();
1176  	return 0;
1177  }
1178  static int test_symlink(void)
1179  {
1180  	char buf[1024];
1181  	const char *data = testdata;
1182  	int datalen = testdatalen;
1183  	int linklen = strlen(testfile);
1184  	int err = 0;
1185  	int res;
1186  	start_test(&quot;symlink&quot;);
1187  	res = create_testfile(testfile, data, datalen);
1188  	if (res == -1)
1189  		return -1;
1190  	unlink(testfile2);
1191  	res = symlink(testfile, testfile2);
1192  	if (res == -1) {
1193  		PERROR(&quot;symlink&quot;);
1194  		return -1;
1195  	}
1196  	res = check_type(testfile2, S_IFLNK);
1197  	if (res == -1)
1198  		return -1;
1199  	err += check_mode(testfile2, 0777);
1200  	err += check_nlink(testfile2, 1);
1201  	res = readlink(testfile2, buf, sizeof(buf));
1202  	if (res == -1) {
1203  		PERROR(&quot;readlink&quot;);
1204  		err--;
1205  	}
1206  	if (res != linklen) {
1207  		ERROR(&quot;short readlink: %u instead of %u&quot;, res, linklen);
1208  		err--;
1209  	}
1210  	if (memcmp(buf, testfile, linklen) != 0) {
1211  		ERROR(&quot;link mismatch&quot;);
1212  		err--;
1213  	}
1214  	err += check_size(testfile2, datalen);
1215  	err += check_data(testfile2, data, 0, datalen);
1216  	res = unlink(testfile2);
1217  	if (res == -1) {
1218  		PERROR(&quot;unlink&quot;);
1219  		return -1;
1220  	}
1221  	res = check_nonexist(testfile2);
1222  	if (res == -1)
1223  		return -1;
1224  	if (err)
1225  		return -1;
1226  	res = unlink(testfile);
1227  	if (res == -1) {
1228  		PERROR(&quot;unlink&quot;);
1229  		return -1;
1230  	}
1231  	res = check_nonexist(testfile);
1232  	if (res == -1)
1233  		return -1;
1234  	success();
1235  	return 0;
1236  }
1237  static int test_link(void)
1238  {
1239  	const char *data = testdata;
1240  	int datalen = testdatalen;
1241  	int err = 0;
1242  	int res;
1243  	start_test(&quot;link&quot;);
1244  	res = create_testfile(testfile, data, datalen);
1245  	if (res == -1)
1246  		return -1;
1247  	unlink(testfile2);
1248  	res = link(testfile, testfile2);
1249  	if (res == -1) {
1250  		PERROR(&quot;link&quot;);
1251  		return -1;
1252  	}
1253  	res = check_type(testfile2, S_IFREG);
1254  	if (res == -1)
1255  		return -1;
1256  	err += check_mode(testfile2, 0644);
1257  	err += check_nlink(testfile2, 2);
1258  	err += check_size(testfile2, datalen);
1259  	err += check_data(testfile2, data, 0, datalen);
1260  	res = unlink(testfile);
1261  	if (res == -1) {
1262  		PERROR(&quot;unlink&quot;);
1263  		return -1;
1264  	}
1265  	res = check_nonexist(testfile);
1266  	if (res == -1)
1267  		return -1;
1268  	err += check_nlink(testfile2, 1);
1269  	res = unlink(testfile2);
1270  	if (res == -1) {
1271  		PERROR(&quot;unlink&quot;);
1272  		return -1;
1273  	}
1274  	res = check_nonexist(testfile2);
1275  	if (res == -1)
1276  		return -1;
1277  	if (err)
1278  		return -1;
1279  	success();
1280  	return 0;
1281  }
1282  static int test_link2(void)
1283  {
1284  	const char *data = testdata;
1285  	int datalen = testdatalen;
1286  	int err = 0;
1287  	int res;
1288  	start_test(&quot;link-unlink-link&quot;);
1289  	res = create_testfile(testfile, data, datalen);
1290  	if (res == -1)
1291  		return -1;
1292  	unlink(testfile2);
1293  	res = link(testfile, testfile2);
1294  	if (res == -1) {
1295  		PERROR(&quot;link&quot;);
1296  		return -1;
1297  	}
1298  	res = unlink(testfile);
1299  	if (res == -1) {
1300  		PERROR(&quot;unlink&quot;);
1301  		return -1;
1302  	}
1303  	res = check_nonexist(testfile);
1304  	if (res == -1)
1305  		return -1;
1306  	res = link(testfile2, testfile);
1307  	if (res == -1) {
1308  		PERROR(&quot;link&quot;);
1309  	}
1310  	res = check_type(testfile, S_IFREG);
1311  	if (res == -1)
1312  		return -1;
1313  	err += check_mode(testfile, 0644);
1314  	err += check_nlink(testfile, 2);
1315  	err += check_size(testfile, datalen);
1316  	err += check_data(testfile, data, 0, datalen);
1317  	res = unlink(testfile2);
1318  	if (res == -1) {
1319  		PERROR(&quot;unlink&quot;);
1320  		return -1;
1321  	}
1322  	err += check_nlink(testfile, 1);
1323  	res = unlink(testfile);
1324  	if (res == -1) {
1325  		PERROR(&quot;unlink&quot;);
1326  		return -1;
1327  	}
1328  	res = check_nonexist(testfile);
1329  	if (res == -1)
1330  		return -1;
1331  	if (err)
1332  		return -1;
1333  	success();
1334  	return 0;
1335  }
1336  static int test_rename_file(void)
1337  {
1338  	const char *data = testdata;
1339  	int datalen = testdatalen;
1340  	int err = 0;
1341  	int res;
1342  	start_test(&quot;rename file&quot;);
1343  	res = create_testfile(testfile, data, datalen);
1344  	if (res == -1)
1345  		return -1;
1346  	unlink(testfile2);
1347  	res = rename(testfile, testfile2);
1348  	if (res == -1) {
1349  		PERROR(&quot;rename&quot;);
1350  		return -1;
1351  	}
1352  	res = check_nonexist(testfile);
1353  	if (res == -1)
1354  		return -1;
1355  	res = check_type(testfile2, S_IFREG);
1356  	if (res == -1)
1357  		return -1;
1358  	err += check_mode(testfile2, 0644);
1359  	err += check_nlink(testfile2, 1);
1360  	err += check_size(testfile2, datalen);
1361  	err += check_data(testfile2, data, 0, datalen);
1362  	res = unlink(testfile2);
1363  	if (res == -1) {
1364  		PERROR(&quot;unlink&quot;);
1365  		return -1;
1366  	}
1367  	res = check_nonexist(testfile2);
1368  	if (res == -1)
1369  		return -1;
1370  	if (err)
1371  		return -1;
1372  	success();
1373  	return 0;
1374  }
1375  static int test_rename_dir(void)
1376  {
1377  	int err = 0;
1378  	int res;
1379  	start_test(&quot;rename dir&quot;);
1380  	res = create_dir(testdir, testdir_files);
1381  	if (res == -1)
1382  		return -1;
1383  	rmdir(testdir2);
1384  	res = rename(testdir, testdir2);
1385  	if (res == -1) {
1386  		PERROR(&quot;rename&quot;);
1387  		cleanup_dir(testdir, testdir_files, 1);
1388  		return -1;
1389  	}
1390  	res = check_nonexist(testdir);
1391  	if (res == -1) {
1392  		cleanup_dir(testdir, testdir_files, 1);
1393  		return -1;
1394  	}
1395  	res = check_type(testdir2, S_IFDIR);
1396  	if (res == -1) {
1397  		cleanup_dir(testdir2, testdir_files, 1);
1398  		return -1;
1399  	}
1400  	err += check_mode(testdir2, 0755);
1401  	err += check_dir_contents(testdir2, testdir_files);
1402  	err += cleanup_dir(testdir2, testdir_files, 0);
1403  	res = rmdir(testdir2);
1404  	if (res == -1) {
1405  		PERROR(&quot;rmdir&quot;);
1406  		return -1;
1407  	}
1408  	res = check_nonexist(testdir2);
1409  	if (res == -1)
1410  		return -1;
1411  	if (err)
1412  		return -1;
1413  	success();
1414  	return 0;
1415  }
1416  static int test_rename_dir_loop(void)
1417  {
1418  #define PATH(p)		(snprintf(path, sizeof path, &quot;%s/%s&quot;, testdir, p), path)
1419  #define PATH2(p)	(snprintf(path2, sizeof path2, &quot;%s/%s&quot;, testdir, p), path2)
1420  	char path[1280], path2[1280];
1421  	int err = 0;
1422  	int res;
1423  	start_test(&quot;rename dir loop&quot;);
1424  	res = create_dir(testdir, testdir_files);
1425  	if (res == -1)
1426  		return -1;
1427  	res = mkdir(PATH(&quot;a&quot;), 0755);
1428  	if (res == -1) {
1429  		PERROR(&quot;mkdir&quot;);
1430  		goto fail;
1431  	}
1432  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a&quot;));
1433  	if (res == -1) {
1434  		PERROR(&quot;rename&quot;);
1435  		goto fail;
1436  	}
1437  	errno = 0;
1438  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b&quot;));
1439  	if (res == 0 || errno != EINVAL) {
1440  		PERROR(&quot;rename&quot;);
1441  		goto fail;
1442  	}
1443  	res = mkdir(PATH(&quot;a/b&quot;), 0755);
1444  	if (res == -1) {
1445  		PERROR(&quot;mkdir&quot;);
1446  		goto fail;
1447  	}
1448  	res = mkdir(PATH(&quot;a/b/c&quot;), 0755);
1449  	if (res == -1) {
1450  		PERROR(&quot;mkdir&quot;);
1451  		goto fail;
1452  	}
1453  	errno = 0;
1454  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b/c&quot;));
1455  	if (res == 0 || errno != EINVAL) {
1456  		PERROR(&quot;rename&quot;);
1457  		goto fail;
1458  	}
1459  	errno = 0;
1460  	res = rename(PATH(&quot;a&quot;), PATH2(&quot;a/b/c/a&quot;));
1461  	if (res == 0 || errno != EINVAL) {
1462  		PERROR(&quot;rename&quot;);
1463  		goto fail;
1464  	}
1465  	errno = 0;
1466  	res = rename(PATH(&quot;a/b/c&quot;), PATH2(&quot;a&quot;));
1467  	if (res == 0 || errno != ENOTEMPTY) {
1468  		PERROR(&quot;rename&quot;);
1469  		goto fail;
1470  	}
1471  	res = open(PATH(&quot;a/foo&quot;), O_CREAT, 0644);
1472  	if (res == -1) {
1473  		PERROR(&quot;open&quot;);
1474  		goto fail;
1475  	}
1476  	close(res);
1477  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/bar&quot;));
1478  	if (res == -1) {
1479  		PERROR(&quot;rename&quot;);
1480  		goto fail;
1481  	}
1482  	res = rename(PATH(&quot;a/bar&quot;), PATH2(&quot;a/foo&quot;));
1483  	if (res == -1) {
1484  		PERROR(&quot;rename&quot;);
1485  		goto fail;
1486  	}
1487  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/b/bar&quot;));
1488  	if (res == -1) {
1489  		PERROR(&quot;rename&quot;);
1490  		goto fail;
1491  	}
1492  	res = rename(PATH(&quot;a/b/bar&quot;), PATH2(&quot;a/foo&quot;));
1493  	if (res == -1) {
1494  		PERROR(&quot;rename&quot;);
1495  		goto fail;
1496  	}
1497  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/b/c/bar&quot;));
1498  	if (res == -1) {
1499  		PERROR(&quot;rename&quot;);
1500  		goto fail;
1501  	}
1502  	res = rename(PATH(&quot;a/b/c/bar&quot;), PATH2(&quot;a/foo&quot;));
1503  	if (res == -1) {
1504  		PERROR(&quot;rename&quot;);
1505  		goto fail;
1506  	}
1507  	res = open(PATH(&quot;a/bar&quot;), O_CREAT, 0644);
1508  	if (res == -1) {
1509  		PERROR(&quot;open&quot;);
1510  		goto fail;
1511  	}
1512  	close(res);
1513  	res = rename(PATH(&quot;a/foo&quot;), PATH2(&quot;a/bar&quot;));
1514  	if (res == -1) {
1515  		PERROR(&quot;rename&quot;);
1516  		goto fail;
1517  	}
1518  	unlink(PATH(&quot;a/bar&quot;));
1519  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1520  	if (res == -1) {
1521  		PERROR(&quot;rename&quot;);
1522  		goto fail;
1523  	}
1524  	res = rename(PATH(&quot;a/d&quot;), PATH2(&quot;a/b&quot;));
1525  	if (res == -1) {
1526  		PERROR(&quot;rename&quot;);
1527  		goto fail;
1528  	}
1529  	res = mkdir(PATH(&quot;a/d&quot;), 0755);
1530  	if (res == -1) {
1531  		PERROR(&quot;mkdir&quot;);
1532  		goto fail;
1533  	}
1534  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1535  	if (res == -1) {
1536  		PERROR(&quot;rename&quot;);
1537  		goto fail;
1538  	}
1539  	res = rename(PATH(&quot;a/d&quot;), PATH2(&quot;a/b&quot;));
1540  	if (res == -1) {
1541  		PERROR(&quot;rename&quot;);
1542  		goto fail;
1543  	}
1544  	res = mkdir(PATH(&quot;a/d&quot;), 0755);
1545  	if (res == -1) {
1546  		PERROR(&quot;mkdir&quot;);
1547  		goto fail;
1548  	}
1549  	res = mkdir(PATH(&quot;a/d/e&quot;), 0755);
1550  	if (res == -1) {
1551  		PERROR(&quot;mkdir&quot;);
1552  		goto fail;
1553  	}
1554  	errno = 0;
1555  	res = rename(PATH(&quot;a/b&quot;), PATH2(&quot;a/d&quot;));
1556  	if (res == 0 || (errno != ENOTEMPTY &amp;&amp; errno != EEXIST)) {
1557  		PERROR(&quot;rename&quot;);
1558  		goto fail;
1559  	}
1560  	rmdir(PATH(&quot;a/d/e&quot;));
1561  	rmdir(PATH(&quot;a/d&quot;));
1562   	rmdir(PATH(&quot;a/b/c&quot;));
1563  	rmdir(PATH(&quot;a/b&quot;));
1564  	rmdir(PATH(&quot;a&quot;));
1565  	err += cleanup_dir(testdir, testdir_files, 0);
1566  	res = rmdir(testdir);
1567  	if (res == -1) {
1568  		PERROR(&quot;rmdir&quot;);
1569  		goto fail;
1570  	}
1571  	res = check_nonexist(testdir);
1572  	if (res == -1)
1573  		return -1;
1574  	if (err)
1575  		return -1;
1576  	success();
1577  	return 0;
1578  fail:
1579  	unlink(PATH(&quot;a/bar&quot;));
1580  	rmdir(PATH(&quot;a/d/e&quot;));
1581  	rmdir(PATH(&quot;a/d&quot;));
1582   	rmdir(PATH(&quot;a/b/c&quot;));
1583  	rmdir(PATH(&quot;a/b&quot;));
1584  	rmdir(PATH(&quot;a&quot;));
1585  	cleanup_dir(testdir, testdir_files, 1);
1586  	rmdir(testdir);
1587  	return -1;
1588  #undef PATH2
1589  #undef PATH
1590  }
1591  #ifndef __FreeBSD__
1592  static int test_mkfifo(void)
1593  {
1594  	int res;
1595  	int err = 0;
1596  	start_test(&quot;mkfifo&quot;);
1597  	unlink(testfile);
1598  	res = mkfifo(testfile, 0644);
1599  	if (res == -1) {
1600  		PERROR(&quot;mkfifo&quot;);
1601  		return -1;
1602  	}
1603  	res = check_type(testfile, S_IFIFO);
1604  	if (res == -1)
1605  		return -1;
1606  	err += check_mode(testfile, 0644);
1607  	err += check_nlink(testfile, 1);
1608  	res = unlink(testfile);
1609  	if (res == -1) {
1610  		PERROR(&quot;unlink&quot;);
1611  		return -1;
1612  	}
1613  	res = check_nonexist(testfile);
1614  	if (res == -1)
1615  		return -1;
1616  	if (err)
1617  		return -1;
1618  	success();
1619  	return 0;
1620  }
1621  #endif
1622  static int test_mkdir(void)
1623  {
1624  	int res;
1625  	int err = 0;
1626  	const char *dir_contents[] = {NULL};
1627  	start_test(&quot;mkdir&quot;);
1628  	rmdir(testdir);
1629  	res = mkdir(testdir, 0755);
1630  	if (res == -1) {
1631  		PERROR(&quot;mkdir&quot;);
1632  		return -1;
1633  	}
1634  	res = check_type(testdir, S_IFDIR);
1635  	if (res == -1)
1636  		return -1;
1637  	err += check_mode(testdir, 0755);
1638  	err += check_dir_contents(testdir, dir_contents);
1639  	res = rmdir(testdir);
1640  	if (res == -1) {
1641  		PERROR(&quot;rmdir&quot;);
1642  		return -1;
1643  	}
1644  	res = check_nonexist(testdir);
1645  	if (res == -1)
1646  		return -1;
1647  	if (err)
1648  		return -1;
1649  	success();
1650  	return 0;
1651  }
1652  static int test_socket(void)
1653  {
1654  	struct sockaddr_un su;
1655  	int fd;
1656  	int res;
1657  	int err = 0;
1658      const size_t test_sock_len = strlen(testsock) + 1;
1659  	start_test(&quot;socket&quot;);
1660  	if (test_sock_len &gt; sizeof(su.sun_path)) {
1661  		fprintf(stderr, &quot;Need to shorten mount point by %zu chars\n&quot;,
1662  			strlen(testsock) + 1 - sizeof(su.sun_path));
1663  		return -1;
1664  	}
1665  	unlink(testsock);
1666  	fd = socket(AF_UNIX, SOCK_STREAM, 0);
1667  	if (fd &lt; 0) {
1668  		PERROR(&quot;socket&quot;);
1669  		return -1;
1670  	}
1671  	su.sun_family = AF_UNIX;
1672  	strncpy(su.sun_path, testsock, test_sock_len);
1673  	su.sun_path[sizeof(su.sun_path) - 1] = &#x27;\0&#x27;;
1674  	res = bind(fd, (struct sockaddr*)&amp;su, sizeof(su));
1675  	if (res == -1) {
1676  		PERROR(&quot;bind&quot;);
1677  		return -1;
1678  	}
1679  	res = check_type(testsock, S_IFSOCK);
1680  	if (res == -1) {
1681  		close(fd);
1682  		return -1;
1683  	}
1684  	err += check_nlink(testsock, 1);
1685  	close(fd);
1686  	res = unlink(testsock);
1687  	if (res == -1) {
1688  		PERROR(&quot;unlink&quot;);
1689  		return -1;
1690  	}
1691  	res = check_nonexist(testsock);
1692  	if (res == -1)
1693  		return -1;
1694  	if (err)
1695  		return -1;
1696  	success();
1697  	return 0;
1698  }
1699  #define test_create_ro_dir(flags)	 \
1700  	do_test_create_ro_dir(flags, #flags)
1701  static int do_test_create_ro_dir(int flags, const char *flags_str)
1702  {
1703  	int res;
1704  	int err = 0;
1705  	int fd;
1706  	start_test(&quot;open(%s) in read-only directory&quot;, flags_str);
1707  	rmdir(testdir);
1708  	res = mkdir(testdir, 0555);
1709  	if (res == -1) {
1710  		PERROR(&quot;mkdir&quot;);
1711  		return -1;
1712  	}
1713  	fd = open(subfile, flags, 0644);
1714  	if (fd != -1) {
1715  		close(fd);
1716  		unlink(subfile);
1717  		ERROR(&quot;open should have failed&quot;);
1718  		err--;
1719  	} else {
1720  		res = check_nonexist(subfile);
1721  		if (res == -1)
1722  			err--;
1723  	}
1724  	unlink(subfile);
1725  	res = rmdir(testdir);
1726  	if (res == -1) {
1727  		PERROR(&quot;rmdir&quot;);
1728  		return -1;
1729  	}
1730  	res = check_nonexist(testdir);
1731  	if (res == -1)
1732  		return -1;
1733  	if (err)
1734  		return -1;
1735  	success();
1736  	return 0;
1737  }
1738  int main(int argc, char *argv[])
1739  {
1740  	int err = 0;
1741  	int a;
1742  	int is_root;
1743  	umask(0);
1744  	if (argc &lt; 2 || argc &gt; 4) {
1745  		fprintf(stderr, &quot;usage: %s testdir [:realdir] [[-]test#] [-u]\n&quot;, argv[0]);
1746  		return 1;
1747  	}
1748  	basepath = argv[1];
1749  	basepath_r = basepath;
1750  	for (a = 2; a &lt; argc; a++) {
1751  		char *endptr;
1752  		char *arg = argv[a];
1753  		if (arg[0] == &#x27;:&#x27;) {
1754  			basepath_r = arg + 1;
1755  		} else {
1756  			if (arg[0] == &#x27;-&#x27;) {
1757  				arg++;
1758  				if (arg[0] == &#x27;u&#x27;) {
1759  					unlinked_test = 1;
1760  					endptr = arg + 1;
1761  				} else {
1762  					skip_test = strtoul(arg, &amp;endptr, 10);
1763  				}
1764  			} else {
1765  				select_test = strtoul(arg, &amp;endptr, 10);
1766  			}
1767  			if (arg[0] == &#x27;\0&#x27; || *endptr != &#x27;\0&#x27;) {
1768  				fprintf(stderr, &quot;invalid option: &#x27;%s&#x27;\n&quot;, argv[a]);
1769  				return 1;
1770  			}
1771  		}
1772  	}
1773  	assert(strlen(basepath) &lt; 512);
1774  	assert(strlen(basepath_r) &lt; 512);
1775  	if (basepath[0] != &#x27;/&#x27;) {
1776  		fprintf(stderr, &quot;testdir must be an absolute path\n&quot;);
1777  		return 1;
1778  	}
1779  	sprintf(testfile, &quot;%s/testfile&quot;, basepath);
1780  	sprintf(testfile2, &quot;%s/testfile2&quot;, basepath);
1781  	sprintf(testdir, &quot;%s/testdir&quot;, basepath);
1782  	sprintf(testdir2, &quot;%s/testdir2&quot;, basepath);
1783  	sprintf(subfile, &quot;%s/subfile&quot;, testdir2);
1784  	sprintf(testsock, &quot;%s/testsock&quot;, basepath);
1785  	sprintf(testfile_r, &quot;%s/testfile&quot;, basepath_r);
1786  	sprintf(testfile2_r, &quot;%s/testfile2&quot;, basepath_r);
1787  	sprintf(testdir_r, &quot;%s/testdir&quot;, basepath_r);
1788  	sprintf(testdir2_r, &quot;%s/testdir2&quot;, basepath_r);
1789  	sprintf(subfile_r, &quot;%s/subfile&quot;, testdir2_r);
1790  	is_root = (geteuid() == 0);
1791  	err += test_create();
1792  	err += test_create_unlink();
1793  	err += test_symlink();
1794  	err += test_link();
1795  	err += test_link2();
1796  #ifndef __FreeBSD__	
1797  	err += test_mknod();
1798  	err += test_mkfifo();
1799  #endif
1800  	err += test_mkdir();
1801  	err += test_rename_file();
1802  	err += test_rename_dir();
1803  	err += test_rename_dir_loop();
1804  	err += test_seekdir();
1805  	err += test_socket();
1806  	err += test_utime();
1807  	err += test_truncate(0);
1808  	err += test_truncate(testdatalen / 2);
1809  	err += test_truncate(testdatalen);
1810  	err += test_truncate(testdatalen + 100);
1811  	err += test_ftruncate(0, 0600);
1812  	err += test_ftruncate(testdatalen / 2, 0600);
1813  	err += test_ftruncate(testdatalen, 0600);
1814  	err += test_ftruncate(testdatalen + 100, 0600);
1815  	err += test_ftruncate(0, 0400);
1816  	err += test_ftruncate(0, 0200);
1817  	err += test_ftruncate(0, 0000);
1818  	err += test_open(0, O_RDONLY, 0);
1819  	err += test_open(1, O_RDONLY, 0);
1820  	err += test_open(1, O_RDWR, 0);
1821  	err += test_open(1, O_WRONLY, 0);
1822  	err += test_open(0, O_RDWR | O_CREAT, 0600);
1823  	err += test_open(1, O_RDWR | O_CREAT, 0600);
1824  	err += test_open(0, O_RDWR | O_CREAT | O_TRUNC, 0600);
1825  	err += test_open(1, O_RDWR | O_CREAT | O_TRUNC, 0600);
1826  	err += test_open(0, O_RDONLY | O_CREAT, 0600);
1827  	err += test_open(0, O_RDONLY | O_CREAT, 0400);
1828  	err += test_open(0, O_RDONLY | O_CREAT, 0200);
1829  	err += test_open(0, O_RDONLY | O_CREAT, 0000);
1830  	err += test_open(0, O_WRONLY | O_CREAT, 0600);
1831  	err += test_open(0, O_WRONLY | O_CREAT, 0400);
1832  	err += test_open(0, O_WRONLY | O_CREAT, 0200);
1833  	err += test_open(0, O_WRONLY | O_CREAT, 0000);
1834  	err += test_open(0, O_RDWR | O_CREAT, 0400);
1835  	err += test_open(0, O_RDWR | O_CREAT, 0200);
1836  	err += test_open(0, O_RDWR | O_CREAT, 0000);
1837  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0600);
1838  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0600);
1839  	err += test_open(0, O_RDWR | O_CREAT | O_EXCL, 0000);
1840  	err += test_open(1, O_RDWR | O_CREAT | O_EXCL, 0000);
1841  	err += test_open_acc(O_RDONLY, 0600, 0);
1842  	err += test_open_acc(O_WRONLY, 0600, 0);
1843  	err += test_open_acc(O_RDWR,   0600, 0);
1844  	err += test_open_acc(O_RDONLY, 0400, 0);
1845  	err += test_open_acc(O_WRONLY, 0200, 0);
1846  	if(!is_root) {
1847  		err += test_open_acc(O_RDONLY | O_TRUNC, 0400, EACCES);
1848  		err += test_open_acc(O_WRONLY, 0400, EACCES);
1849  		err += test_open_acc(O_RDWR,   0400, EACCES);
1850  		err += test_open_acc(O_RDONLY, 0200, EACCES);
1851  		err += test_open_acc(O_RDWR,   0200, EACCES);
1852  		err += test_open_acc(O_RDONLY, 0000, EACCES);
1853  		err += test_open_acc(O_WRONLY, 0000, EACCES);
1854  		err += test_open_acc(O_RDWR,   0000, EACCES);
1855  	}
1856  	err += test_create_ro_dir(O_CREAT);
1857  	err += test_create_ro_dir(O_CREAT | O_EXCL);
1858  	err += test_create_ro_dir(O_CREAT | O_WRONLY);
1859  	err += test_create_ro_dir(O_CREAT | O_TRUNC);
1860  	err += test_copy_file_range();
1861  	unlink(testfile2);
1862  	unlink(testsock);
1863  	rmdir(testdir);
1864  	rmdir(testdir2);
1865  	if (err) {
1866  		fprintf(stderr, &quot;%i tests failed\n&quot;, -err);
1867  		return 1;
1868  	}
1869  	return check_unlinked_testfiles();
1870  }
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fusermount.c</h3>
            <pre><code>1  #define _GNU_SOURCE &amp;bsol;* for clone and strchrnul */
2  #include &quot;fuse_config.h&quot;
3  #include &quot;mount_util.h&quot;
4  #include &lt;stdio.h&gt;
5  #include &lt;stdlib.h&gt;
6  #include &lt;string.h&gt;
7  #include &lt;ctype.h&gt;
8  #include &lt;unistd.h&gt;
9  #include &lt;getopt.h&gt;
10  #include &lt;errno.h&gt;
11  #include &lt;fcntl.h&gt;
12  #include &lt;pwd.h&gt;
13  #include &lt;paths.h&gt;
14  #include &lt;mntent.h&gt;
15  #include &lt;sys/wait.h&gt;
16  #include &lt;sys/stat.h&gt;
17  #include &quot;fuse_mount_compat.h&quot;
18  #include &lt;sys/fsuid.h&gt;
19  #include &lt;sys/socket.h&gt;
20  #include &lt;sys/utsname.h&gt;
21  #include &lt;sched.h&gt;
22  #include &lt;stdbool.h&gt;
23  #include &lt;sys/vfs.h&gt;
24  #define FUSE_COMMFD_ENV		&quot;_FUSE_COMMFD&quot;
25  #define FUSE_DEV &quot;/dev/fuse&quot;
26  static const char *progname;
27  static int user_allow_other = 0;
28  static int mount_max = 1000;
29  static int auto_unmount = 0;
30  #ifdef GETMNTENT_NEEDS_UNESCAPING
31  static void unescape(char *buf) {
32  	char *src = buf;
33  	char *dest = buf;
34  	while (1) {
35  		char *next_src = strchrnul(src, &#x27;\\&#x27;);
36  		int offset = next_src - src;
37  		memmove(dest, src, offset);
38  		src = next_src;
39  		dest += offset;
40  		if(*src == &#x27;\0&#x27;) {
41  			*dest = *src;
42  			return;
43  		}
44  		src++;
45  		if(&#x27;0&#x27; &lt;= src[0] &amp;&amp; src[0] &lt; &#x27;2&#x27; &amp;&amp;
46  		   &#x27;0&#x27; &lt;= src[1] &amp;&amp; src[1] &lt; &#x27;8&#x27; &amp;&amp;
47  		   &#x27;0&#x27; &lt;= src[2] &amp;&amp; src[2] &lt; &#x27;8&#x27;) {
48  			*dest++ = (src[0] - &#x27;0&#x27;) &lt;&lt; 6
49  			        | (src[1] - &#x27;0&#x27;) &lt;&lt; 3
50  			        | (src[2] - &#x27;0&#x27;) &lt;&lt; 0;
51  			src += 3;
52  		} else if (src[0] == &#x27;\\&#x27;) {
53  			*dest++ = &#x27;\\&#x27;;
54  			src += 1;
55  		} else {
56  			*dest++ = &#x27;\\&#x27;;
57  		}
58  	}
59  }
60  static struct mntent *GETMNTENT(FILE *stream)
61  {
62  	struct mntent *entp = getmntent(stream);
63  	if(entp != NULL) {
64  		unescape(entp-&gt;mnt_fsname);
65  		unescape(entp-&gt;mnt_dir);
66  		unescape(entp-&gt;mnt_type);
67  		unescape(entp-&gt;mnt_opts);
68  	}
69  	return entp;
70  }
71  #else
72  #define GETMNTENT getmntent
73  #endif 
74  static const char *get_user_name(void)
75  {
76  	struct passwd *pw = getpwuid(getuid());
77  	if (pw != NULL &amp;&amp; pw-&gt;pw_name != NULL)
78  		return pw-&gt;pw_name;
79  	else {
80  		fprintf(stderr, &quot;%s: could not determine username\n&quot;, progname);
81  		return NULL;
82  	}
83  }
84  static uid_t oldfsuid;
85  static gid_t oldfsgid;
86  static void drop_privs(void)
87  {
88  	if (getuid() != 0) {
89  		oldfsuid = setfsuid(getuid());
90  		oldfsgid = setfsgid(getgid());
91  	}
92  }
93  static void restore_privs(void)
94  {
95  	if (getuid() != 0) {
96  		setfsuid(oldfsuid);
97  		setfsgid(oldfsgid);
98  	}
99  }
100  #ifndef IGNORE_MTAB
101  static int lock_umount(void)
102  {
103  	const char *mtab_lock = _PATH_MOUNTED &quot;.fuselock&quot;;
104  	int mtablock;
105  	int res;
106  	struct stat mtab_stat;
107  	if (lstat(_PATH_MOUNTED, &amp;mtab_stat) == 0 &amp;&amp; S_ISLNK(mtab_stat.st_mode))
108  		return -1;
<span onclick='openModal()' class='match'>109  	mtablock = open(mtab_lock, O_RDWR | O_CREAT, 0600);
110  	if (mtablock == -1) {
111  		fprintf(stderr, &quot;%s: unable to open fuse lock file: %s\n&quot;,
</span>112  			progname, strerror(errno));
113  		return -1;
114  	}
115  	res = lockf(mtablock, F_LOCK, 0);
116  	if (res &lt; 0) {
117  		fprintf(stderr, &quot;%s: error getting lock: %s\n&quot;, progname,
118  			strerror(errno));
119  		close(mtablock);
120  		return -1;
121  	}
122  	return mtablock;
123  }
124  static void unlock_umount(int mtablock)
125  {
126  	if (mtablock &gt;= 0) {
127  		int res;
128  		res = lockf(mtablock, F_ULOCK, 0);
129  		if (res &lt; 0) {
130  			fprintf(stderr, &quot;%s: error releasing lock: %s\n&quot;,
131  				progname, strerror(errno));
132  		}
133  		close(mtablock);
134  	}
135  }
136  static int add_mount(const char *source, const char *mnt, const char *type,
137  		     const char *opts)
138  {
139  	return fuse_mnt_add_mount(progname, source, mnt, type, opts);
140  }
141  static int may_unmount(const char *mnt, int quiet)
142  {
143  	struct mntent *entp;
144  	FILE *fp;
145  	const char *user = NULL;
146  	char uidstr[32];
147  	unsigned uidlen = 0;
148  	int found;
149  	const char *mtab = _PATH_MOUNTED;
150  	user = get_user_name();
151  	if (user == NULL)
152  		return -1;
153  	fp = setmntent(mtab, &quot;r&quot;);
154  	if (fp == NULL) {
155  		fprintf(stderr, &quot;%s: failed to open %s: %s\n&quot;, progname, mtab,
156  			strerror(errno));
157  		return -1;
158  	}
159  	uidlen = sprintf(uidstr, &quot;%u&quot;, getuid());
160  	found = 0;
161  	while ((entp = GETMNTENT(fp)) != NULL) {
162  		if (!found &amp;&amp; strcmp(entp-&gt;mnt_dir, mnt) == 0 &amp;&amp;
163  		    (strcmp(entp-&gt;mnt_type, &quot;fuse&quot;) == 0 ||
164  		     strcmp(entp-&gt;mnt_type, &quot;fuseblk&quot;) == 0 ||
165  		     strncmp(entp-&gt;mnt_type, &quot;fuse.&quot;, 5) == 0 ||
166  		     strncmp(entp-&gt;mnt_type, &quot;fuseblk.&quot;, 8) == 0)) {
167  			char *p = strstr(entp-&gt;mnt_opts, &quot;user=&quot;);
168  			if (p &amp;&amp;
169  			    (p == entp-&gt;mnt_opts || *(p-1) == &#x27;,&#x27;) &amp;&amp;
170  			    strcmp(p + 5, user) == 0) {
171  				found = 1;
172  				break;
173  			}
174  			else if ((p =
175  				  strstr(entp-&gt;mnt_opts, &quot;user_id=&quot;)) &amp;&amp;
176  				 (p == entp-&gt;mnt_opts ||
177  				  *(p-1) == &#x27;,&#x27;) &amp;&amp;
178  				 strncmp(p + 8, uidstr, uidlen) == 0 &amp;&amp;
179  				 (*(p+8+uidlen) == &#x27;,&#x27; ||
180  				  *(p+8+uidlen) == &#x27;\0&#x27;)) {
181  				found = 1;
182  				break;
183  			}
184  		}
185  	}
186  	endmntent(fp);
187  	if (!found) {
188  		if (!quiet)
189  			fprintf(stderr,
190  				&quot;%s: entry for %s not found in %s\n&quot;,
191  				progname, mnt, mtab);
192  		return -1;
193  	}
194  	return 0;
195  }
196  #endif
197  static int check_is_mount_child(void *p)
198  {
199  	const char **a = p;
200  	const char *last = a[0];
201  	const char *mnt = a[1];
202  	const char *type = a[2];
203  	int res;
204  	const char *procmounts = &quot;/proc/mounts&quot;;
205  	int found;
206  	FILE *fp;
207  	struct mntent *entp;
208  	int count;
209  	res = mount(&quot;&quot;, &quot;/&quot;, &quot;&quot;, MS_PRIVATE | MS_REC, NULL);
210  	if (res == -1) {
211  		fprintf(stderr, &quot;%s: failed to mark mounts private: %s\n&quot;,
212  			progname, strerror(errno));
213  		return 1;
214  	}
215  	fp = setmntent(procmounts, &quot;r&quot;);
216  	if (fp == NULL) {
217  		fprintf(stderr, &quot;%s: failed to open %s: %s\n&quot;, progname,
218  			procmounts, strerror(errno));
219  		return 1;
220  	}
221  	count = 0;
222  	while (GETMNTENT(fp) != NULL)
223  		count++;
224  	endmntent(fp);
225  	fp = setmntent(procmounts, &quot;r&quot;);
226  	if (fp == NULL) {
227  		fprintf(stderr, &quot;%s: failed to open %s: %s\n&quot;, progname,
228  			procmounts, strerror(errno));
229  		return 1;
230  	}
231  	res = mount(&quot;.&quot;, &quot;/&quot;, &quot;&quot;, MS_BIND | MS_REC, NULL);
232  	if (res == -1) {
233  		fprintf(stderr, &quot;%s: failed to bind parent to /: %s\n&quot;,
234  			progname, strerror(errno));
235  		return 1;
236  	}
237  	found = 0;
238  	while ((entp = GETMNTENT(fp)) != NULL) {
239  		if (count &gt; 0) {
240  			count--;
241  			continue;
242  		}
243  		if (entp-&gt;mnt_dir[0] == &#x27;/&#x27; &amp;&amp;
244  		    strcmp(entp-&gt;mnt_dir + 1, last) == 0 &amp;&amp;
245  		    (!type || strcmp(entp-&gt;mnt_type, type) == 0)) {
246  			found = 1;
247  			break;
248  		}
249  	}
250  	endmntent(fp);
251  	if (!found) {
252  		fprintf(stderr, &quot;%s: %s not mounted\n&quot;, progname, mnt);
253  		return 1;
254  	}
255  	return 0;
256  }
257  static pid_t clone_newns(void *a)
258  {
259  	char buf[131072];
260  	char *stack = buf + (sizeof(buf) / 2 - ((size_t) buf &amp; 15));
261  #ifdef __ia64__
262  	extern int __clone2(int (*fn)(void *),
263  			    void *child_stack_base, size_t stack_size,
264  			    int flags, void *arg, pid_t *ptid,
265  			    void *tls, pid_t *ctid);
266  	return __clone2(check_is_mount_child, stack, sizeof(buf) / 2,
267  			CLONE_NEWNS, a, NULL, NULL, NULL);
268  #else
269  	return clone(check_is_mount_child, stack, CLONE_NEWNS, a);
270  #endif
271  }
272  static int check_is_mount(const char *last, const char *mnt, const char *type)
273  {
274  	pid_t pid, p;
275  	int status;
276  	const char *a[3] = { last, mnt, type };
277  	pid = clone_newns((void *) a);
278  	if (pid == (pid_t) -1) {
279  		fprintf(stderr, &quot;%s: failed to clone namespace: %s\n&quot;,
280  			progname, strerror(errno));
281  		return -1;
282  	}
283  	p = waitpid(pid, &amp;status, __WCLONE);
284  	if (p == (pid_t) -1) {
285  		fprintf(stderr, &quot;%s: waitpid failed: %s\n&quot;,
286  			progname, strerror(errno));
287  		return -1;
288  	}
289  	if (!WIFEXITED(status)) {
290  		fprintf(stderr, &quot;%s: child terminated abnormally (status %i)\n&quot;,
291  			progname, status);
292  		return -1;
293  	}
294  	if (WEXITSTATUS(status) != 0)
295  		return -1;
296  	return 0;
297  }
298  static int chdir_to_parent(char *copy, const char **lastp)
299  {
300  	char *tmp;
301  	const char *parent;
302  	char buf[65536];
303  	int res;
304  	tmp = strrchr(copy, &#x27;/&#x27;);
305  	if (tmp == NULL || tmp[1] == &#x27;\0&#x27;) {
306  		fprintf(stderr, &quot;%s: internal error: invalid abs path: &lt;%s&gt;\n&quot;,
307  			progname, copy);
308  		return -1;
309  	}
310  	if (tmp != copy) {
311  		*tmp = &#x27;\0&#x27;;
312  		parent = copy;
313  		*lastp = tmp + 1;
314  	} else if (tmp[1] != &#x27;\0&#x27;) {
315  		*lastp = tmp + 1;
316  		parent = &quot;/&quot;;
317  	} else {
318  		*lastp = &quot;.&quot;;
319  		parent = &quot;/&quot;;
320  	}
321  	res = chdir(parent);
322  	if (res == -1) {
323  		fprintf(stderr, &quot;%s: failed to chdir to %s: %s\n&quot;,
324  			progname, parent, strerror(errno));
325  		return -1;
326  	}
327  	if (getcwd(buf, sizeof(buf)) == NULL) {
328  		fprintf(stderr, &quot;%s: failed to obtain current directory: %s\n&quot;,
329  			progname, strerror(errno));
330  		return -1;
331  	}
332  	if (strcmp(buf, parent) != 0) {
333  		fprintf(stderr, &quot;%s: mountpoint moved (%s -&gt; %s)\n&quot;, progname,
334  			parent, buf);
335  		return -1;
336  	}
337  	return 0;
338  }
339  #ifndef IGNORE_MTAB
340  static int unmount_fuse_locked(const char *mnt, int quiet, int lazy)
341  {
342  	int res;
343  	char *copy;
344  	const char *last;
345  	int umount_flags = (lazy ? UMOUNT_DETACH : 0) | UMOUNT_NOFOLLOW;
346  	if (getuid() != 0) {
347  		res = may_unmount(mnt, quiet);
348  		if (res == -1)
349  			return -1;
350  	}
351  	copy = strdup(mnt);
352  	if (copy == NULL) {
353  		fprintf(stderr, &quot;%s: failed to allocate memory\n&quot;, progname);
354  		return -1;
355  	}
356  	drop_privs();
357  	res = chdir_to_parent(copy, &amp;last);
358  	restore_privs();
359  	if (res == -1)
360  		goto out;
361  	res = umount2(last, umount_flags);
362  	if (res == -1 &amp;&amp; !quiet) {
363  		fprintf(stderr, &quot;%s: failed to unmount %s: %s\n&quot;,
364  			progname, mnt, strerror(errno));
365  	}
366  out:
367  	free(copy);
368  	if (res == -1)
369  		return -1;
370  	res = chdir(&quot;/&quot;);
371  	if (res == -1) {
372  		fprintf(stderr, &quot;%s: failed to chdir to &#x27;/&#x27;\n&quot;, progname);
373  		return -1;
374  	}
375  	return fuse_mnt_remove_mount(progname, mnt);
376  }
377  static int unmount_fuse(const char *mnt, int quiet, int lazy)
378  {
379  	int res;
380  	int mtablock = lock_umount();
381  	res = unmount_fuse_locked(mnt, quiet, lazy);
382  	unlock_umount(mtablock);
383  	return res;
384  }
385  static int count_fuse_fs(void)
386  {
387  	struct mntent *entp;
388  	int count = 0;
389  	const char *mtab = _PATH_MOUNTED;
390  	FILE *fp = setmntent(mtab, &quot;r&quot;);
391  	if (fp == NULL) {
392  		fprintf(stderr, &quot;%s: failed to open %s: %s\n&quot;, progname, mtab,
393  			strerror(errno));
394  		return -1;
395  	}
396  	while ((entp = GETMNTENT(fp)) != NULL) {
397  		if (strcmp(entp-&gt;mnt_type, &quot;fuse&quot;) == 0 ||
398  		    strncmp(entp-&gt;mnt_type, &quot;fuse.&quot;, 5) == 0)
399  			count ++;
400  	}
401  	endmntent(fp);
402  	return count;
403  }
404  #else &amp;bsol;* IGNORE_MTAB */
405  static int count_fuse_fs(void)
406  {
407  	return 0;
408  }
409  static int add_mount(const char *source, const char *mnt, const char *type,
410  		     const char *opts)
411  {
412  	(void) source;
413  	(void) mnt;
414  	(void) type;
415  	(void) opts;
416  	return 0;
417  }
418  static int unmount_fuse(const char *mnt, int quiet, int lazy)
419  {
420  	(void) quiet;
421  	return fuse_mnt_umount(progname, mnt, mnt, lazy);
422  }
423  #endif &amp;bsol;* IGNORE_MTAB */
424  static void strip_line(char *line)
425  {
426  	char *s = strchr(line, &#x27;#&#x27;);
427  	if (s != NULL)
428  		s[0] = &#x27;\0&#x27;;
429  	for (s = line + strlen(line) - 1;
430  	     s &gt;= line &amp;&amp; isspace((unsigned char) *s); s--);
431  	s[1] = &#x27;\0&#x27;;
432  	for (s = line; isspace((unsigned char) *s); s++);
433  	if (s != line)
434  		memmove(line, s, strlen(s)+1);
435  }
436  static void parse_line(char *line, int linenum)
437  {
438  	int tmp;
439  	if (strcmp(line, &quot;user_allow_other&quot;) == 0)
440  		user_allow_other = 1;
441  	else if (sscanf(line, &quot;mount_max = %i&quot;, &amp;tmp) == 1)
442  		mount_max = tmp;
443  	else if(line[0])
444  		fprintf(stderr,
445  			&quot;%s: unknown parameter in %s at line %i: &#x27;%s&#x27;\n&quot;,
446  			progname, FUSE_CONF, linenum, line);
447  }
448  static void read_conf(void)
449  {
450  	FILE *fp = fopen(FUSE_CONF, &quot;r&quot;);
451  	if (fp != NULL) {
452  		int linenum = 1;
453  		char line[256];
454  		int isnewline = 1;
455  		while (fgets(line, sizeof(line), fp) != NULL) {
456  			if (isnewline) {
457  				if (line[strlen(line)-1] == &#x27;\n&#x27;) {
458  					strip_line(line);
459  					parse_line(line, linenum);
460  				} else {
461  					isnewline = 0;
462  				}
463  			} else if(line[strlen(line)-1] == &#x27;\n&#x27;) {
464  				fprintf(stderr, &quot;%s: reading %s: line %i too long\n&quot;, progname, FUSE_CONF, linenum);
465  				isnewline = 1;
466  			}
467  			if (isnewline)
468  				linenum ++;
469  		}
470  		if (!isnewline) {
471  			fprintf(stderr, &quot;%s: reading %s: missing newline at end of file\n&quot;, progname, FUSE_CONF);
472  		}
473  		if (ferror(fp)) {
474  			fprintf(stderr, &quot;%s: reading %s: read failed\n&quot;, progname, FUSE_CONF);
475  			exit(1);
476  		}
477  		fclose(fp);
478  	} else if (errno != ENOENT) {
479  		bool fatal = (errno != EACCES &amp;&amp; errno != ELOOP &amp;&amp;
480  			      errno != ENAMETOOLONG &amp;&amp; errno != ENOTDIR &amp;&amp;
481  			      errno != EOVERFLOW);
482  		fprintf(stderr, &quot;%s: failed to open %s: %s\n&quot;,
483  			progname, FUSE_CONF, strerror(errno));
484  		if (fatal)
485  			exit(1);
486  	}
487  }
488  static int begins_with(const char *s, const char *beg)
489  {
490  	if (strncmp(s, beg, strlen(beg)) == 0)
491  		return 1;
492  	else
493  		return 0;
494  }
495  struct mount_flags {
496  	const char *opt;
497  	unsigned long flag;
498  	int on;
499  	int safe;
500  };
501  static struct mount_flags mount_flags[] = {
502  	{&quot;rw&quot;,	    MS_RDONLY,	    0, 1},
503  	{&quot;ro&quot;,	    MS_RDONLY,	    1, 1},
504  	{&quot;suid&quot;,    MS_NOSUID,	    0, 0},
505  	{&quot;nosuid&quot;,  MS_NOSUID,	    1, 1},
506  	{&quot;dev&quot;,	    MS_NODEV,	    0, 0},
507  	{&quot;nodev&quot;,   MS_NODEV,	    1, 1},
508  	{&quot;exec&quot;,    MS_NOEXEC,	    0, 1},
509  	{&quot;noexec&quot;,  MS_NOEXEC,	    1, 1},
510  	{&quot;async&quot;,   MS_SYNCHRONOUS, 0, 1},
511  	{&quot;sync&quot;,    MS_SYNCHRONOUS, 1, 1},
512  	{&quot;atime&quot;,   MS_NOATIME,	    0, 1},
513  	{&quot;noatime&quot;, MS_NOATIME,	    1, 1},
514  	{&quot;diratime&quot;,        MS_NODIRATIME,  0, 1},
515  	{&quot;nodiratime&quot;,      MS_NODIRATIME,  1, 1},
516  	{&quot;lazytime&quot;,        MS_LAZYTIME,    1, 1},
517  	{&quot;nolazytime&quot;,      MS_LAZYTIME,    0, 1},
518  	{&quot;relatime&quot;,        MS_RELATIME,    1, 1},
519  	{&quot;norelatime&quot;,      MS_RELATIME,    0, 1},
520  	{&quot;strictatime&quot;,     MS_STRICTATIME, 1, 1},
521  	{&quot;nostrictatime&quot;,   MS_STRICTATIME, 0, 1},
522  	{&quot;dirsync&quot;, MS_DIRSYNC,	    1, 1},
523  	{NULL,	    0,		    0, 0}
524  };
525  static int find_mount_flag(const char *s, unsigned len, int *on, int *flag)
526  {
527  	int i;
528  	for (i = 0; mount_flags[i].opt != NULL; i++) {
529  		const char *opt = mount_flags[i].opt;
530  		if (strlen(opt) == len &amp;&amp; strncmp(opt, s, len) == 0) {
531  			*on = mount_flags[i].on;
532  			*flag = mount_flags[i].flag;
533  			if (!mount_flags[i].safe &amp;&amp; getuid() != 0) {
534  				*flag = 0;
535  				fprintf(stderr,
536  					&quot;%s: unsafe option %s ignored\n&quot;,
537  					progname, opt);
538  			}
539  			return 1;
540  		}
541  	}
542  	return 0;
543  }
544  static int add_option(char **optsp, const char *opt, unsigned expand)
545  {
546  	char *newopts;
547  	if (*optsp == NULL)
548  		newopts = strdup(opt);
549  	else {
550  		unsigned oldsize = strlen(*optsp);
551  		unsigned newsize = oldsize + 1 + strlen(opt) + expand + 1;
552  		newopts = (char *) realloc(*optsp, newsize);
553  		if (newopts)
554  			sprintf(newopts + oldsize, &quot;,%s&quot;, opt);
555  	}
556  	if (newopts == NULL) {
557  		fprintf(stderr, &quot;%s: failed to allocate memory\n&quot;, progname);
558  		return -1;
559  	}
560  	*optsp = newopts;
561  	return 0;
562  }
563  static int get_mnt_opts(int flags, char *opts, char **mnt_optsp)
564  {
565  	int i;
566  	int l;
567  	if (!(flags &amp; MS_RDONLY) &amp;&amp; add_option(mnt_optsp, &quot;rw&quot;, 0) == -1)
568  		return -1;
569  	for (i = 0; mount_flags[i].opt != NULL; i++) {
570  		if (mount_flags[i].on &amp;&amp; (flags &amp; mount_flags[i].flag) &amp;&amp;
571  		    add_option(mnt_optsp, mount_flags[i].opt, 0) == -1)
572  			return -1;
573  	}
574  	if (add_option(mnt_optsp, opts, 0) == -1)
575  		return -1;
576  	l = strlen(*mnt_optsp);
577  	if ((*mnt_optsp)[l-1] == &#x27;,&#x27;)
578  		(*mnt_optsp)[l-1] = &#x27;\0&#x27;;
579  	if (getuid() != 0) {
580  		const char *user = get_user_name();
581  		if (user == NULL)
582  			return -1;
583  		if (add_option(mnt_optsp, &quot;user=&quot;, strlen(user)) == -1)
584  			return -1;
585  		strcat(*mnt_optsp, user);
586  	}
587  	return 0;
588  }
589  static int opt_eq(const char *s, unsigned len, const char *opt)
590  {
591  	if(strlen(opt) == len &amp;&amp; strncmp(s, opt, len) == 0)
592  		return 1;
593  	else
594  		return 0;
595  }
596  static int get_string_opt(const char *s, unsigned len, const char *opt,
597  			  char **val)
598  {
599  	int i;
600  	unsigned opt_len = strlen(opt);
601  	char *d;
602  	if (*val)
603  		free(*val);
604  	*val = (char *) malloc(len - opt_len + 1);
605  	if (!*val) {
606  		fprintf(stderr, &quot;%s: failed to allocate memory\n&quot;, progname);
607  		return 0;
608  	}
609  	d = *val;
610  	s += opt_len;
611  	len -= opt_len;
612  	for (i = 0; i &lt; len; i++) {
613  		if (s[i] == &#x27;\\&#x27; &amp;&amp; i + 1 &lt; len)
614  			i++;
615  		*d++ = s[i];
616  	}
617  	*d = &#x27;\0&#x27;;
618  	return 1;
619  }
620  static int mount_notrunc(const char *source, const char *target,
621  			 const char *filesystemtype, unsigned long mountflags,
622  			 const char *data) {
623  	if (strlen(data) &gt; sysconf(_SC_PAGESIZE) - 1) {
624  		fprintf(stderr, &quot;%s: mount options too long\n&quot;, progname);
625  		errno = EINVAL;
626  		return -1;
627  	}
628  	return mount(source, target, filesystemtype, mountflags, data);
629  }
630  static int do_mount(const char *mnt, const char **typep, mode_t rootmode,
631  		    int fd, const char *opts, const char *dev, char **sourcep,
632  		    char **mnt_optsp)
633  {
634  	int res;
635  	int flags = MS_NOSUID | MS_NODEV;
636  	char *optbuf;
637  	char *mnt_opts = NULL;
638  	const char *s;
639  	char *d;
640  	char *fsname = NULL;
641  	char *subtype = NULL;
642  	char *source = NULL;
643  	char *type = NULL;
644  	int blkdev = 0;
645  	optbuf = (char *) malloc(strlen(opts) + 128);
646  	if (!optbuf) {
647  		fprintf(stderr, &quot;%s: failed to allocate memory\n&quot;, progname);
648  		return -1;
649  	}
650  	for (s = opts, d = optbuf; *s;) {
651  		unsigned len;
652  		const char *fsname_str = &quot;fsname=&quot;;
653  		const char *subtype_str = &quot;subtype=&quot;;
654  		bool escape_ok = begins_with(s, fsname_str) ||
655  				 begins_with(s, subtype_str);
656  		for (len = 0; s[len]; len++) {
657  			if (escape_ok &amp;&amp; s[len] == &#x27;\\&#x27; &amp;&amp; s[len + 1])
658  				len++;
659  			else if (s[len] == &#x27;,&#x27;)
660  				break;
661  		}
662  		if (begins_with(s, fsname_str)) {
663  			if (!get_string_opt(s, len, fsname_str, &amp;fsname))
664  				goto err;
665  		} else if (begins_with(s, subtype_str)) {
666  			if (!get_string_opt(s, len, subtype_str, &amp;subtype))
667  				goto err;
668  		} else if (opt_eq(s, len, &quot;blkdev&quot;)) {
669  			if (getuid() != 0) {
670  				fprintf(stderr,
671  					&quot;%s: option blkdev is privileged\n&quot;,
672  					progname);
673  				goto err;
674  			}
675  			blkdev = 1;
676  		} else if (opt_eq(s, len, &quot;auto_unmount&quot;)) {
677  			auto_unmount = 1;
678  		} else if (!opt_eq(s, len, &quot;nonempty&quot;) &amp;&amp;
679  			   !begins_with(s, &quot;fd=&quot;) &amp;&amp;
680  			   !begins_with(s, &quot;rootmode=&quot;) &amp;&amp;
681  			   !begins_with(s, &quot;user_id=&quot;) &amp;&amp;
682  			   !begins_with(s, &quot;group_id=&quot;)) {
683  			int on;
684  			int flag;
685  			int skip_option = 0;
686  			if (opt_eq(s, len, &quot;large_read&quot;)) {
687  				struct utsname utsname;
688  				unsigned kmaj, kmin;
689  				res = uname(&amp;utsname);
690  				if (res == 0 &amp;&amp;
691  				    sscanf(utsname.release, &quot;%u.%u&quot;,
692  					   &amp;kmaj, &amp;kmin) == 2 &amp;&amp;
693  				    (kmaj &gt; 2 || (kmaj == 2 &amp;&amp; kmin &gt; 4))) {
694  					fprintf(stderr, &quot;%s: note: &#x27;large_read&#x27; mount option is deprecated for %i.%i kernels\n&quot;, progname, kmaj, kmin);
695  					skip_option = 1;
696  				}
697  			}
698  			if (getuid() != 0 &amp;&amp; !user_allow_other &amp;&amp;
699  			    (opt_eq(s, len, &quot;allow_other&quot;) ||
700  			     opt_eq(s, len, &quot;allow_root&quot;))) {
701  				fprintf(stderr, &quot;%s: option %.*s only allowed if &#x27;user_allow_other&#x27; is set in %s\n&quot;, progname, len, s, FUSE_CONF);
702  				goto err;
703  			}
704  			if (!skip_option) {
705  				if (find_mount_flag(s, len, &amp;on, &amp;flag)) {
706  					if (on)
707  						flags |= flag;
708  					else
709  						flags  &amp;= ~flag;
710  				} else if (opt_eq(s, len, &quot;default_permissions&quot;) ||
711  					   opt_eq(s, len, &quot;allow_other&quot;) ||
712  					   begins_with(s, &quot;max_read=&quot;) ||
713  					   begins_with(s, &quot;blksize=&quot;)) {
714  					memcpy(d, s, len);
715  					d += len;
716  					*d++ = &#x27;,&#x27;;
717  				} else {
718  					fprintf(stderr, &quot;%s: unknown option &#x27;%.*s&#x27;\n&quot;, progname, len, s);
719  					exit(1);
720  				}
721  			}
722  		}
723  		s += len;
724  		if (*s)
725  			s++;
726  	}
727  	*d = &#x27;\0&#x27;;
728  	res = get_mnt_opts(flags, optbuf, &amp;mnt_opts);
729  	if (res == -1)
730  		goto err;
731  	sprintf(d, &quot;fd=%i,rootmode=%o,user_id=%u,group_id=%u&quot;,
732  		fd, rootmode, getuid(), getgid());
733  	source = malloc((fsname ? strlen(fsname) : 0) +
734  			(subtype ? strlen(subtype) : 0) + strlen(dev) + 32);
735  	type = malloc((subtype ? strlen(subtype) : 0) + 32);
736  	if (!type || !source) {
737  		fprintf(stderr, &quot;%s: failed to allocate memory\n&quot;, progname);
738  		goto err;
739  	}
740  	if (subtype)
741  		sprintf(type, &quot;%s.%s&quot;, blkdev ? &quot;fuseblk&quot; : &quot;fuse&quot;, subtype);
742  	else
743  		strcpy(type, blkdev ? &quot;fuseblk&quot; : &quot;fuse&quot;);
744  	if (fsname)
745  		strcpy(source, fsname);
746  	else
747  		strcpy(source, subtype ? subtype : dev);
748  	res = mount_notrunc(source, mnt, type, flags, optbuf);
749  	if (res == -1 &amp;&amp; errno == ENODEV &amp;&amp; subtype) {
750  		strcpy(type, blkdev ? &quot;fuseblk&quot; : &quot;fuse&quot;);
751  		if (fsname) {
752  			if (!blkdev)
753  				sprintf(source, &quot;%s#%s&quot;, subtype, fsname);
754  		} else {
755  			strcpy(source, type);
756  		}
757  		res = mount_notrunc(source, mnt, type, flags, optbuf);
758  	}
759  	if (res == -1 &amp;&amp; errno == EINVAL) {
760  		sprintf(d, &quot;fd=%i,rootmode=%o,user_id=%u&quot;,
761  			fd, rootmode, getuid());
762  		res = mount_notrunc(source, mnt, type, flags, optbuf);
763  	}
764  	if (res == -1) {
765  		int errno_save = errno;
766  		if (blkdev &amp;&amp; errno == ENODEV &amp;&amp; !fuse_mnt_check_fuseblk())
767  			fprintf(stderr, &quot;%s: &#x27;fuseblk&#x27; support missing\n&quot;,
768  				progname);
769  		else
770  			fprintf(stderr, &quot;%s: mount failed: %s\n&quot;, progname,
771  				strerror(errno_save));
772  		goto err;
773  	}
774  	*sourcep = source;
775  	*typep = type;
776  	*mnt_optsp = mnt_opts;
777  	free(fsname);
778  	free(optbuf);
779  	return 0;
780  err:
781  	free(fsname);
782  	free(subtype);
783  	free(source);
784  	free(type);
785  	free(mnt_opts);
786  	free(optbuf);
787  	return -1;
788  }
789  static int check_perm(const char **mntp, struct stat *stbuf, int *mountpoint_fd)
790  {
791  	int res;
792  	const char *mnt = *mntp;
793  	const char *origmnt = mnt;
794  	struct statfs fs_buf;
795  	size_t i;
796  	res = lstat(mnt, stbuf);
797  	if (res == -1) {
798  		fprintf(stderr, &quot;%s: failed to access mountpoint %s: %s\n&quot;,
799  			progname, mnt, strerror(errno));
800  		return -1;
801  	}
802  	if (getuid() == 0)
803  		return 0;
804  	if (S_ISDIR(stbuf-&gt;st_mode)) {
805  		res = chdir(mnt);
806  		if (res == -1) {
807  			fprintf(stderr,
808  				&quot;%s: failed to chdir to mountpoint: %s\n&quot;,
809  				progname, strerror(errno));
810  			return -1;
811  		}
812  		mnt = *mntp = &quot;.&quot;;
813  		res = lstat(mnt, stbuf);
814  		if (res == -1) {
815  			fprintf(stderr,
816  				&quot;%s: failed to access mountpoint %s: %s\n&quot;,
817  				progname, origmnt, strerror(errno));
818  			return -1;
819  		}
820  		if ((stbuf-&gt;st_mode &amp; S_ISVTX) &amp;&amp; stbuf-&gt;st_uid != getuid()) {
821  			fprintf(stderr, &quot;%s: mountpoint %s not owned by user\n&quot;,
822  				progname, origmnt);
823  			return -1;
824  		}
825  		res = access(mnt, W_OK);
826  		if (res == -1) {
827  			fprintf(stderr, &quot;%s: user has no write access to mountpoint %s\n&quot;,
828  				progname, origmnt);
829  			return -1;
830  		}
831  	} else if (S_ISREG(stbuf-&gt;st_mode)) {
832  		static char procfile[256];
833  		*mountpoint_fd = open(mnt, O_WRONLY);
834  		if (*mountpoint_fd == -1) {
835  			fprintf(stderr, &quot;%s: failed to open %s: %s\n&quot;,
836  				progname, mnt, strerror(errno));
837  			return -1;
838  		}
839  		res = fstat(*mountpoint_fd, stbuf);
840  		if (res == -1) {
841  			fprintf(stderr,
842  				&quot;%s: failed to access mountpoint %s: %s\n&quot;,
843  				progname, mnt, strerror(errno));
844  			return -1;
845  		}
846  		if (!S_ISREG(stbuf-&gt;st_mode)) {
847  			fprintf(stderr,
848  				&quot;%s: mountpoint %s is no longer a regular file\n&quot;,
849  				progname, mnt);
850  			return -1;
851  		}
852  		sprintf(procfile, &quot;/proc/self/fd/%i&quot;, *mountpoint_fd);
853  		*mntp = procfile;
854  	} else {
855  		fprintf(stderr,
856  			&quot;%s: mountpoint %s is not a directory or a regular file\n&quot;,
857  			progname, mnt);
858  		return -1;
859  	}
860  	if (statfs(*mntp, &amp;fs_buf)) {
861  		fprintf(stderr, &quot;%s: failed to access mountpoint %s: %s\n&quot;,
862  			progname, mnt, strerror(errno));
863  		return -1;
864  	}
865  	typeof(fs_buf.f_type) f_type_whitelist[] = {
866  		0x61756673 &amp;bsol;* AUFS_SUPER_MAGIC */,
867  		0x00000187 &amp;bsol;* AUTOFS_SUPER_MAGIC */,
868  		0xCA451A4E &amp;bsol;* BCACHEFS_STATFS_MAGIC */,
869  		0x9123683E &amp;bsol;* BTRFS_SUPER_MAGIC */,
870  		0x00C36400 &amp;bsol;* CEPH_SUPER_MAGIC */,
871  		0xFF534D42 &amp;bsol;* CIFS_MAGIC_NUMBER */,
872  		0x0000F15F &amp;bsol;* ECRYPTFS_SUPER_MAGIC */,
873  		0X2011BAB0 &amp;bsol;* EXFAT_SUPER_MAGIC */,
874  		0x0000EF53 &amp;bsol;* EXT[234]_SUPER_MAGIC */,
875  		0xF2F52010 &amp;bsol;* F2FS_SUPER_MAGIC */,
876  		0x65735546 &amp;bsol;* FUSE_SUPER_MAGIC */,
877  		0x01161970 &amp;bsol;* GFS2_MAGIC */,
878  		0x47504653 &amp;bsol;* GPFS_SUPER_MAGIC */,
879  		0x0000482b &amp;bsol;* HFSPLUS_SUPER_MAGIC */,
880  		0x000072B6 &amp;bsol;* JFFS2_SUPER_MAGIC */,
881  		0x3153464A &amp;bsol;* JFS_SUPER_MAGIC */,
882  		0x0BD00BD0 &amp;bsol;* LL_SUPER_MAGIC */,
883  		0X00004D44 &amp;bsol;* MSDOS_SUPER_MAGIC */,
884  		0x0000564C &amp;bsol;* NCP_SUPER_MAGIC */,
885  		0x00006969 &amp;bsol;* NFS_SUPER_MAGIC */,
886  		0x00003434 &amp;bsol;* NILFS_SUPER_MAGIC */,
887  		0x5346544E &amp;bsol;* NTFS_SB_MAGIC */,
888  		0x5346414f &amp;bsol;* OPENAFS_SUPER_MAGIC */,
889  		0x794C7630 &amp;bsol;* OVERLAYFS_SUPER_MAGIC */,
890  		0x52654973 &amp;bsol;* REISERFS_SUPER_MAGIC */,
891  		0xFE534D42 &amp;bsol;* SMB2_SUPER_MAGIC */,
892  		0x73717368 &amp;bsol;* SQUASHFS_MAGIC */,
893  		0x01021994 &amp;bsol;* TMPFS_MAGIC */,
894  		0x24051905 &amp;bsol;* UBIFS_SUPER_MAGIC */,
895  		0x736675005346544e &amp;bsol;* UFSD */,
896  		0x58465342 &amp;bsol;* XFS_SB_MAGIC */,
897  		0x2FC12FC1 &amp;bsol;* ZFS_SUPER_MAGIC */,
898  	};
899  	for (i = 0; i &lt; sizeof(f_type_whitelist)/sizeof(f_type_whitelist[0]); i++) {
900  		if (f_type_whitelist[i] == fs_buf.f_type)
901  			return 0;
902  	}
903  	fprintf(stderr, &quot;%s: mounting over filesystem type %#010lx is forbidden\n&quot;,
904  		progname, (unsigned long)fs_buf.f_type);
905  	return -1;
906  }
907  static int try_open(const char *dev, char **devp, int silent)
908  {
909  	int fd = open(dev, O_RDWR);
910  	if (fd != -1) {
911  		*devp = strdup(dev);
912  		if (*devp == NULL) {
913  			fprintf(stderr, &quot;%s: failed to allocate memory\n&quot;,
914  				progname);
915  			close(fd);
916  			fd = -1;
917  		}
918  	} else if (errno == ENODEV ||
919  		   errno == ENOENT)&amp;bsol;* check for ENOENT too, for the udev case */
920  		return -2;
921  	else if (!silent) {
922  		fprintf(stderr, &quot;%s: failed to open %s: %s\n&quot;, progname, dev,
923  			strerror(errno));
924  	}
925  	return fd;
926  }
927  static int try_open_fuse_device(char **devp)
928  {
929  	int fd;
930  	drop_privs();
931  	fd = try_open(FUSE_DEV, devp, 0);
932  	restore_privs();
933  	return fd;
934  }
935  static int open_fuse_device(char **devp)
936  {
937  	int fd = try_open_fuse_device(devp);
938  	if (fd &gt;= -1)
939  		return fd;
940  	fprintf(stderr,
941  		&quot;%s: fuse device not found, try &#x27;modprobe fuse&#x27; first\n&quot;,
942  		progname);
943  	return -1;
944  }
945  static int mount_fuse(const char *mnt, const char *opts, const char **type)
946  {
947  	int res;
948  	int fd;
949  	char *dev;
950  	struct stat stbuf;
951  	char *source = NULL;
952  	char *mnt_opts = NULL;
953  	const char *real_mnt = mnt;
954  	int mountpoint_fd = -1;
955  	fd = open_fuse_device(&amp;dev);
956  	if (fd == -1)
957  		return -1;
958  	drop_privs();
959  	read_conf();
960  	if (getuid() != 0 &amp;&amp; mount_max != -1) {
961  		int mount_count = count_fuse_fs();
962  		if (mount_count &gt;= mount_max) {
963  			fprintf(stderr, &quot;%s: too many FUSE filesystems mounted; mount_max=N can be set in %s\n&quot;, progname, FUSE_CONF);
964  			goto fail_close_fd;
965  		}
966  	}
967  	res = check_perm(&amp;real_mnt, &amp;stbuf, &amp;mountpoint_fd);
968  	restore_privs();
969  	if (res != -1)
970  		res = do_mount(real_mnt, type, stbuf.st_mode &amp; S_IFMT,
971  			       fd, opts, dev, &amp;source, &amp;mnt_opts);
972  	if (mountpoint_fd != -1)
973  		close(mountpoint_fd);
974  	if (res == -1)
975  		goto fail_close_fd;
976  	res = chdir(&quot;/&quot;);
977  	if (res == -1) {
978  		fprintf(stderr, &quot;%s: failed to chdir to &#x27;/&#x27;\n&quot;, progname);
979  		goto fail_close_fd;
980  	}
981  	if (geteuid() == 0) {
982  		res = add_mount(source, mnt, *type, mnt_opts);
983  		if (res == -1) {
984  			goto fail_close_fd;
985  		}
986  	}
987  out_free:
988  	free(source);
989  	free(mnt_opts);
990  	free(dev);
991  	return fd;
992  fail_close_fd:
993  	close(fd);
994  	fd = -1;
995  	goto out_free;
996  }
997  static int send_fd(int sock_fd, int fd)
998  {
999  	int retval;
1000  	struct msghdr msg;
1001  	struct cmsghdr *p_cmsg;
1002  	struct iovec vec;
1003  	size_t cmsgbuf[CMSG_SPACE(sizeof(fd)) / sizeof(size_t)];
1004  	int *p_fds;
1005  	char sendchar = 0;
1006  	msg.msg_control = cmsgbuf;
1007  	msg.msg_controllen = sizeof(cmsgbuf);
1008  	p_cmsg = CMSG_FIRSTHDR(&amp;msg);
1009  	p_cmsg-&gt;cmsg_level = SOL_SOCKET;
1010  	p_cmsg-&gt;cmsg_type = SCM_RIGHTS;
1011  	p_cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(fd));
1012  	p_fds = (int *) CMSG_DATA(p_cmsg);
1013  	*p_fds = fd;
1014  	msg.msg_controllen = p_cmsg-&gt;cmsg_len;
1015  	msg.msg_name = NULL;
1016  	msg.msg_namelen = 0;
1017  	msg.msg_iov = &amp;vec;
1018  	msg.msg_iovlen = 1;
1019  	msg.msg_flags = 0;
1020  	vec.iov_base = &amp;sendchar;
1021  	vec.iov_len = sizeof(sendchar);
1022  	while ((retval = sendmsg(sock_fd, &amp;msg, 0)) == -1 &amp;&amp; errno == EINTR);
1023  	if (retval != 1) {
1024  		perror(&quot;sending file descriptor&quot;);
1025  		return -1;
1026  	}
1027  	return 0;
1028  }
1029  static int recheck_ENOTCONN_as_owner(const char *mnt)
1030  {
1031  	int pid = fork();
1032  	if(pid == -1) {
1033  		perror(&quot;fuse: recheck_ENOTCONN_as_owner can&#x27;t fork&quot;);
1034  		_exit(EXIT_FAILURE);
1035  	} else if(pid == 0) {
1036  		uid_t uid = getuid();
1037  		gid_t gid = getgid();
1038  		if(setresgid(gid, gid, gid) == -1) {
1039  			perror(&quot;fuse: can&#x27;t set resgid&quot;);
1040  			_exit(EXIT_FAILURE);
1041  		}
1042  		if(setresuid(uid, uid, uid) == -1) {
1043  			perror(&quot;fuse: can&#x27;t set resuid&quot;);
1044  			_exit(EXIT_FAILURE);
1045  		}
1046  		int fd = open(mnt, O_RDONLY);
1047  		if(fd == -1 &amp;&amp; errno == ENOTCONN)
1048  			_exit(EXIT_SUCCESS);
1049  		else
1050  			_exit(EXIT_FAILURE);
1051  	} else {
1052  		int status;
1053  		int res = waitpid(pid, &amp;status, 0);
1054  		if (res == -1) {
1055  			perror(&quot;fuse: waiting for child failed&quot;);
1056  			_exit(EXIT_FAILURE);
1057  		}
1058  		return WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) == EXIT_SUCCESS;
1059  	}
1060  }
1061  static int should_auto_unmount(const char *mnt, const char *type)
1062  {
1063  	char *copy;
1064  	const char *last;
1065  	int result = 0;
1066  	int fd;
1067  	copy = strdup(mnt);
1068  	if (copy == NULL) {
1069  	fprintf(stderr, &quot;%s: failed to allocate memory\n&quot;, progname);
1070  		return 0;
1071  	}
1072  	if (chdir_to_parent(copy, &amp;last) == -1)
1073  		goto out;
1074  	if (check_is_mount(last, mnt, type) == -1)
1075  		goto out;
1076  	fd = open(mnt, O_RDONLY);
1077  	if (fd != -1) {
1078  		close(fd);
1079  	} else {
1080  		switch(errno) {
1081  		case ENOTCONN:
1082  			result = 1;
1083  			break;
1084  		case EACCES:
1085  			result = recheck_ENOTCONN_as_owner(mnt);
1086  			break;
1087  		default:
1088  			result = 0;
1089  			break;
1090  		}
1091  	}
1092  out:
1093  	free(copy);
1094  	return result;
1095  }
1096  static void usage(void)
1097  {
1098  	printf(&quot;%s: [options] mountpoint\n&quot;
1099  	       &quot;Options:\n&quot;
1100  	       &quot; -h		    print help\n&quot;
1101  	       &quot; -V		    print version\n&quot;
1102  	       &quot; -o opt[,opt...]    mount options\n&quot;
1103  	       &quot; -u		    unmount\n&quot;
1104  	       &quot; -q		    quiet\n&quot;
1105  	       &quot; -z		    lazy unmount\n&quot;,
1106  	       progname);
1107  	exit(1);
1108  }
1109  static void show_version(void)
1110  {
1111  	printf(&quot;fusermount3 version: %s\n&quot;, PACKAGE_VERSION);
1112  	exit(0);
1113  }
1114  int main(int argc, char *argv[])
1115  {
1116  	sigset_t sigset;
1117  	int ch;
1118  	int fd;
1119  	int res;
1120  	char *origmnt;
1121  	char *mnt;
1122  	static int unmount = 0;
1123  	static int lazy = 0;
1124  	static int quiet = 0;
1125  	char *commfd;
1126  	int cfd;
1127  	const char *opts = &quot;&quot;;
1128  	const char *type = NULL;
1129  	int setup_auto_unmount_only = 0;
1130  	static const struct option long_opts[] = {
1131  		{&quot;unmount&quot;, no_argument, NULL, &#x27;u&#x27;},
1132  		{&quot;auto-unmount&quot;, no_argument, NULL, &#x27;U&#x27;},
1133  		{&quot;lazy&quot;,    no_argument, NULL, &#x27;z&#x27;},
1134  		{&quot;quiet&quot;,   no_argument, NULL, &#x27;q&#x27;},
1135  		{&quot;help&quot;,    no_argument, NULL, &#x27;h&#x27;},
1136  		{&quot;version&quot;, no_argument, NULL, &#x27;V&#x27;},
1137  		{&quot;options&quot;, required_argument, NULL, &#x27;o&#x27;},
1138  		{0, 0, 0, 0}};
1139  	progname = strdup(argc &gt; 0 ? argv[0] : &quot;fusermount&quot;);
1140  	if (progname == NULL) {
1141  		fprintf(stderr, &quot;%s: failed to allocate memory\n&quot;, argv[0]);
1142  		exit(1);
1143  	}
1144  	while ((ch = getopt_long(argc, argv, &quot;hVo:uzq&quot;, long_opts,
1145  				 NULL)) != -1) {
1146  		switch (ch) {
1147  		case &#x27;h&#x27;:
1148  			usage();
1149  			break;
1150  		case &#x27;V&#x27;:
1151  			show_version();
1152  			break;
1153  		case &#x27;o&#x27;:
1154  			opts = optarg;
1155  			break;
1156  		case &#x27;u&#x27;:
1157  			unmount = 1;
1158  			break;
1159  		case &#x27;U&#x27;:
1160  			unmount = 1;
1161  			auto_unmount = 1;
1162  			setup_auto_unmount_only = 1;
1163  			break;
1164  		case &#x27;z&#x27;:
1165  			lazy = 1;
1166  			break;
1167  		case &#x27;q&#x27;:
1168  			quiet = 1;
1169  			break;
1170  		default:
1171  			exit(1);
1172  		}
1173  	}
1174  	if (lazy &amp;&amp; !unmount) {
1175  		fprintf(stderr, &quot;%s: -z can only be used with -u\n&quot;, progname);
1176  		exit(1);
1177  	}
1178  	if (optind &gt;= argc) {
1179  		fprintf(stderr, &quot;%s: missing mountpoint argument\n&quot;, progname);
1180  		exit(1);
1181  	} else if (argc &gt; optind + 1) {
1182  		fprintf(stderr, &quot;%s: extra arguments after the mountpoint\n&quot;,
1183  			progname);
1184  		exit(1);
1185  	}
1186  	origmnt = argv[optind];
1187  	drop_privs();
1188  	mnt = fuse_mnt_resolve_path(progname, origmnt);
1189  	if (mnt != NULL) {
1190  		res = chdir(&quot;/&quot;);
1191  		if (res == -1) {
1192  			fprintf(stderr, &quot;%s: failed to chdir to &#x27;/&#x27;\n&quot;, progname);
1193  			goto err_out;
1194  		}
1195  	}
1196  	restore_privs();
1197  	if (mnt == NULL)
1198  		exit(1);
1199  	umask(033);
1200  	if (!setup_auto_unmount_only &amp;&amp; unmount)
1201  		goto do_unmount;
1202  	commfd = getenv(FUSE_COMMFD_ENV);
1203  	if (commfd == NULL) {
1204  		fprintf(stderr, &quot;%s: old style mounting not supported\n&quot;,
1205  			progname);
1206  		goto err_out;
1207  	}
1208  	cfd = atoi(commfd);
1209  	{
1210  		struct stat statbuf;
1211  		fstat(cfd, &amp;statbuf);
1212  		if(!S_ISSOCK(statbuf.st_mode)) {
1213  			fprintf(stderr,
1214  				&quot;%s: file descriptor %i is not a socket, can&#x27;t send fuse fd\n&quot;,
1215  				progname, cfd);
1216  			goto err_out;
1217  		}
1218  	}
1219  	if (setup_auto_unmount_only)
1220  		goto wait_for_auto_unmount;
1221  	fd = mount_fuse(mnt, opts, &amp;type);
1222  	if (fd == -1)
1223  		goto err_out;
1224  	res = send_fd(cfd, fd);
1225  	if (res != 0) {
1226  		umount2(mnt, MNT_DETACH); &amp;bsol;* lazy umount */
1227  		goto err_out;
1228  	}
1229  	close(fd);
1230  	if (!auto_unmount) {
1231  		free(mnt);
1232  		free((void*) type);
1233  		return 0;
1234  	}
1235  wait_for_auto_unmount:
1236  	setsid();
1237  	res = chdir(&quot;/&quot;);
1238  	if (res == -1) {
1239  		fprintf(stderr, &quot;%s: failed to chdir to &#x27;/&#x27;\n&quot;, progname);
1240  		goto err_out;
1241  	}
1242  	sigfillset(&amp;sigset);
1243  	sigprocmask(SIG_BLOCK, &amp;sigset, NULL);
1244  	lazy  = 1;
1245  	quiet = 1;
1246  	while (1) {
1247  		unsigned char buf[16];
1248  		int n = recv(cfd, buf, sizeof(buf), 0);
1249  		if (!n)
1250  			break;
1251  		if (n &lt; 0) {
1252  			if (errno == EINTR)
1253  				continue;
1254  			break;
1255  		}
1256  	}
1257  	if (!should_auto_unmount(mnt, type)) {
1258  		goto success_out;
1259  	}
1260  do_unmount:
1261  	if (geteuid() == 0)
1262  		res = unmount_fuse(mnt, quiet, lazy);
1263  	else {
1264  		res = umount2(mnt, lazy ? UMOUNT_DETACH : 0);
1265  		if (res == -1 &amp;&amp; !quiet)
1266  			fprintf(stderr,
1267  				&quot;%s: failed to unmount %s: %s\n&quot;,
1268  				progname, mnt, strerror(errno));
1269  	}
1270  	if (res == -1)
1271  		goto err_out;
1272  success_out:
1273  	free((void*) type);
1274  	free(mnt);
1275  	return 0;
1276  err_out:
1277  	free((void*) type);
1278  	free(mnt);
1279  	exit(1);
1280  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-test_syscalls.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-fusermount.c</div>
                </div>
                <div class="column column_space"><pre><code>739  	fd_in = open(testfile, O_CREAT | O_RDWR, 0644);
740  	if (fd_in == -1) {
741  		PERROR(&quot;creat&quot;);
</pre></code></div>
                <div class="column column_space"><pre><code>109  	mtablock = open(mtab_lock, O_RDWR | O_CREAT, 0600);
110  	if (mtablock == -1) {
111  		fprintf(stderr, &quot;%s: unable to open fuse lock file: %s\n&quot;,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    