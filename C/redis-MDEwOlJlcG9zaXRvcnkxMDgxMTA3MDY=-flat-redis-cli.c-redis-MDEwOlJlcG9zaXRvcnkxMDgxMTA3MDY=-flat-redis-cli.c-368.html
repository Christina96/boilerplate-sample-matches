
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-cli.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/Win32_Portability.h&quot;
3  #include &quot;Win32_Interop/win32_types.h&quot;
4  #include &quot;Win32_Interop/Win32_Time.h&quot;
5  #include &quot;Win32_Interop/win32fixes.h&quot;
6  #include &quot;Win32_Interop/Win32_PThread.h&quot;
7  #include &quot;Win32_Interop/Win32_Error.h&quot;
8  #endif
9  #include &quot;fmacros.h&quot;
10  #include &quot;version.h&quot;
11  #include &lt;stdio.h&gt;
12  #include &lt;string.h&gt;
13  #include &lt;stdlib.h&gt;
14  #ifndef _WIN32
15  #include &lt;signal.h&gt;
16  #include &lt;unistd.h&gt;
17  #endif
18  #include &lt;time.h&gt;
19  #include &lt;ctype.h&gt;
20  #include &lt;errno.h&gt;
21  #include &lt;sys/stat.h&gt;
22  #ifndef _WIN32
23  #include &lt;sys/time.h&gt;
24  #endif
25  #include &lt;assert.h&gt;
26  #include &lt;fcntl.h&gt;
27  #include &lt;limits.h&gt;
28  #include &lt;math.h&gt;
29  #ifdef _WIN32
30  #ifndef STDIN_FILENO
31  #define STDIN_FILENO (_fileno(stdin))
32  #endif
33  #include &quot;Win32_Interop/win32fixes.h&quot;
34  #include &quot;Win32_Interop/Win32_Signal_Process.h&quot;
35  #include &quot;Win32_Interop/Win32_ANSI.h&quot;
36  #include &lt;windows.h&gt;
37  #define strcasecmp _stricmp
38  #define strncasecmp _strnicmp
39  #define strtoull _strtoui64
40  #endif
41  #include &lt;hiredis.h&gt;
42  #include &lt;sds.h&gt; &amp;bsol;* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */
43  #include &quot;dict.h&quot;
44  #include &quot;adlist.h&quot;
45  #include &quot;zmalloc.h&quot;
46  #include &quot;linenoise.h&quot;
47  #include &quot;help.h&quot;
48  #include &quot;anet.h&quot;
49  #include &quot;ae.h&quot;
50  #define UNUSED(V) ((void) V)
51  #define OUTPUT_STANDARD 0
52  #define OUTPUT_RAW 1
53  #define OUTPUT_CSV 2
54  #define REDIS_CLI_KEEPALIVE_INTERVAL 15 &amp;bsol;* seconds */
55  #define REDIS_CLI_DEFAULT_PIPE_TIMEOUT 30 &amp;bsol;* seconds */
56  #define REDIS_CLI_HISTFILE_ENV &quot;REDISCLI_HISTFILE&quot;
57  #define REDIS_CLI_HISTFILE_DEFAULT &quot;.rediscli_history&quot;
58  #define REDIS_CLI_RCFILE_ENV &quot;REDISCLI_RCFILE&quot;
59  #define REDIS_CLI_RCFILE_DEFAULT &quot;.redisclirc&quot;
60  #define REDIS_CLI_AUTH_ENV &quot;REDISCLI_AUTH&quot;
61  #define REDIS_CLI_CLUSTER_YES_ENV &quot;REDISCLI_CLUSTER_YES&quot;
62  #define CLUSTER_MANAGER_SLOTS               16384
63  #define CLUSTER_MANAGER_MIGRATE_TIMEOUT     60000
64  #define CLUSTER_MANAGER_MIGRATE_PIPELINE    10
65  #define CLUSTER_MANAGER_REBALANCE_THRESHOLD 2
66  #define CLUSTER_MANAGER_INVALID_HOST_ARG \
67      &quot;[ERR] Invalid arguments: you need to pass either a valid &quot; \
68      &quot;address (ie. 120.0.0.1:7000) or space separated IP &quot; \
69      &quot;and port (ie. 120.0.0.1 7000)\n&quot;
70  #define CLUSTER_MANAGER_MODE() (config.cluster_manager_command.name != NULL)
71  #define CLUSTER_MANAGER_MASTERS_COUNT(nodes, replicas) (nodes/(replicas + 1))
72  #define CLUSTER_MANAGER_COMMAND(n,...) \
73          (redisCommand(n-&gt;context, __VA_ARGS__))
74  #define CLUSTER_MANAGER_NODE_ARRAY_FREE(array) zfree(array-&gt;alloc)
75  #define CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err) \
76      clusterManagerLogErr(&quot;Node %s:%d replied with error:\n%s\n&quot;, \
77                           n-&gt;ip, n-&gt;port, err);
78  #define clusterManagerLogInfo(...) \
79      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_INFO,__VA_ARGS__)
80  #define clusterManagerLogErr(...) \
81      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_ERR,__VA_ARGS__)
82  #define clusterManagerLogWarn(...) \
83      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_WARN,__VA_ARGS__)
84  #define clusterManagerLogOk(...) \
85      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_SUCCESS,__VA_ARGS__)
86  #define CLUSTER_MANAGER_FLAG_MYSELF     1 &lt;&lt; 0
87  #define CLUSTER_MANAGER_FLAG_SLAVE      1 &lt;&lt; 1
88  #define CLUSTER_MANAGER_FLAG_FRIEND     1 &lt;&lt; 2
89  #define CLUSTER_MANAGER_FLAG_NOADDR     1 &lt;&lt; 3
90  #define CLUSTER_MANAGER_FLAG_DISCONNECT 1 &lt;&lt; 4
91  #define CLUSTER_MANAGER_FLAG_FAIL       1 &lt;&lt; 5
92  #define CLUSTER_MANAGER_CMD_FLAG_FIX            1 &lt;&lt; 0
93  #define CLUSTER_MANAGER_CMD_FLAG_SLAVE          1 &lt;&lt; 1
94  #define CLUSTER_MANAGER_CMD_FLAG_YES            1 &lt;&lt; 2
95  #define CLUSTER_MANAGER_CMD_FLAG_AUTOWEIGHTS    1 &lt;&lt; 3
96  #define CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER    1 &lt;&lt; 4
97  #define CLUSTER_MANAGER_CMD_FLAG_SIMULATE       1 &lt;&lt; 5
98  #define CLUSTER_MANAGER_CMD_FLAG_REPLACE        1 &lt;&lt; 6
99  #define CLUSTER_MANAGER_CMD_FLAG_COPY           1 &lt;&lt; 7
100  #define CLUSTER_MANAGER_CMD_FLAG_COLOR          1 &lt;&lt; 8
101  #define CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS   1 &lt;&lt; 9
102  #define CLUSTER_MANAGER_OPT_GETFRIENDS  1 &lt;&lt; 0
103  #define CLUSTER_MANAGER_OPT_COLD        1 &lt;&lt; 1
104  #define CLUSTER_MANAGER_OPT_UPDATE      1 &lt;&lt; 2
105  #define CLUSTER_MANAGER_OPT_QUIET       1 &lt;&lt; 6
106  #define CLUSTER_MANAGER_OPT_VERBOSE     1 &lt;&lt; 7
107  #define CLUSTER_MANAGER_LOG_LVL_INFO    1
108  #define CLUSTER_MANAGER_LOG_LVL_WARN    2
109  #define CLUSTER_MANAGER_LOG_LVL_ERR     3
110  #define CLUSTER_MANAGER_LOG_LVL_SUCCESS 4
111  #define LOG_COLOR_BOLD      &quot;29;1m&quot;
112  #define LOG_COLOR_RED       &quot;31;1m&quot;
113  #define LOG_COLOR_GREEN     &quot;32;1m&quot;
114  #define LOG_COLOR_YELLOW    &quot;33;1m&quot;
115  #define LOG_COLOR_RESET     &quot;0m&quot;
116  #define CC_FORCE (1&lt;&lt;0)         &amp;bsol;* Re-connect if already connected. */
117  #define CC_QUIET (1&lt;&lt;1)         &amp;bsol;* Don&#x27;t log connecting errors. */
118  int spectrum_palette_color_size = 19;
119  int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};
120  int spectrum_palette_mono_size = 13;
121  int spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};
122  int *spectrum_palette;
123  int spectrum_palette_size;
124  static uint64_t dictSdsHash(const void *key);
125  static int dictSdsKeyCompare(void *privdata, const void *key1,
126      const void *key2);
127  static void dictSdsDestructor(void *privdata, void *val);
128  static void dictListDestructor(void *privdata, void *val);
129  typedef struct clusterManagerCommand {
130      char *name;
131      int argc;
132      char **argv;
133      int flags;
134      int replicas;
135      char *from;
136      char *to;
137      char **weight;
138      int weight_argc;
139      char *master_id;
140      int slots;
141      int timeout;
142      int pipeline;
143      float threshold;
144  } clusterManagerCommand;
145  static void createClusterManagerCommand(char *cmdname, int argc, char **argv);
146  static redisContext *context;
147  static struct config {
148      char *hostip;
149      int hostport;
150      char *hostsocket;
151      PORT_LONG repeat;
152      PORT_LONG interval;
153      int dbnum;
154      int interactive;
155      int shutdown;
156      int monitor_mode;
157      int pubsub_mode;
158      int latency_mode;
159      int latency_dist_mode;
160      int latency_history;
161      int lru_test_mode;
162      PORT_LONGLONG lru_test_sample_size;
163      int cluster_mode;
164      int cluster_reissue_command;
165      int slave_mode;
166      int pipe_mode;
167      int pipe_timeout;
168      int getrdb_mode;
169      int stat_mode;
170      int scan_mode;
171      int intrinsic_latency_mode;
172      int intrinsic_latency_duration;
173      char *pattern;
174      char *rdb_filename;
175      int bigkeys;
176      int memkeys;
177      unsigned memkeys_samples;
178      int hotkeys;
179      int stdinarg; &amp;bsol;* get last arg from stdin. (-x option) */
180      char *auth;
181      int output; &amp;bsol;* output mode, see OUTPUT_* defines */
182      sds mb_delim;
183      char prompt[128];
184      char *eval;
185      int eval_ldb;
186      int eval_ldb_sync;  &amp;bsol;* Ask for synchronous mode of the Lua debugger. */
187      int eval_ldb_end;   &amp;bsol;* Lua debugging session ended. */
188      int enable_ldb_on_eval; &amp;bsol;* Handle manual SCRIPT DEBUG + EVAL commands. */
189      int last_cmd_type;
190      int verbose;
191      clusterManagerCommand cluster_manager_command;
192      int no_auth_warning;
193  } config;
194  static struct pref {
195      int hints;
196  } pref;
197  static volatile sig_atomic_t force_cancel_loop = 0;
198  static void usage(void);
199  static void slaveMode(void);
200  char *redisGitSHA1(void);
201  char *redisGitDirty(void);
202  static int cliConnect(int force);
203  static char *getInfoField(char *info, char *field);
204  static PORT_LONG getLongInfoField(char *info, char *field);
205  #ifdef _WIN32
206  extern pthread_mutex_t used_memory_mutex;
207  #endif
208  uint16_t crc16(const char *buf, int len);
209  static PORT_LONGLONG ustime(void) {
210  #ifdef _WIN32
211      return GetHighResRelativeTime(1000000);
212  #else
213      struct timeval tv;
214      PORT_LONGLONG ust;
215      gettimeofday(&amp;tv, NULL);
216      ust = ((PORT_LONGLONG) tv.tv_sec) * 1000000;
217      ust += tv.tv_usec;
218      return ust;
219  #endif
220  }
221  static PORT_LONGLONG mstime(void) {
222      return ustime() / 1000;
223  }
224  static void cliRefreshPrompt(void) {
225      if (config.eval_ldb) return;
226      sds prompt = sdsempty();
227      if (config.hostsocket != NULL) {
228          prompt = sdscatfmt(prompt,&quot;redis %s&quot;,config.hostsocket);
229      } else {
230          char addr[256];
231          anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport);
232          prompt = sdscatlen(prompt,addr,strlen(addr));
233      }
234      if (config.dbnum != 0)
235          prompt = sdscatfmt(prompt,&quot;[%i]&quot;,config.dbnum);
236      prompt = sdscatlen(prompt,&quot;&gt; &quot;,2);
237      snprintf(config.prompt,sizeof(config.prompt),&quot;%s&quot;,prompt);
238      sdsfree(prompt);
239  }
240  static sds getDotfilePath(char *envoverride, char *dotfilename) {
241      char *path = NULL;
242      sds dotPath = NULL;
243      path = getenv(envoverride);
244      if (path != NULL &amp;&amp; *path != &#x27;\0&#x27;) {
245          if (!strcmp(&quot;/dev/null&quot;, path)) {
246              return NULL;
247          }
248          dotPath = sdsnew(path);
249      } else {
250  #ifdef _WIN32
251          char *homeDrive = getenv(&quot;HOMEDRIVE&quot;);
252          char *homePath = getenv(&quot;HOMEPATH&quot;);
253          if ((homeDrive != NULL) &amp;&amp; (*homeDrive != &#x27;\0&#x27;)
254              &amp;&amp; (homePath != NULL) &amp;&amp; (*homePath != &#x27;\0&#x27;)) {
255              dotPath = sdscatprintf(sdsempty(), &quot;%s%s\\%s&quot;, homeDrive, homePath, dotfilename);
256          }
257  #else
258          char *home = getenv(&quot;HOME&quot;);
259          if (home != NULL &amp;&amp; *home != &#x27;\0&#x27;) {
260              dotPath = sdscatprintf(sdsempty(), &quot;%s/%s&quot;, home, dotfilename);
261          }
262  #endif
263      }
264      return dotPath;
265  }
266  #define isHexChar(c) (isdigit(c) || (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;))
267  #define decodeHexChar(c) (isdigit(c) ? c - &#x27;0&#x27; : c - &#x27;a&#x27; + 10)
268  #define decodeHex(h, l) ((decodeHexChar(h) &lt;&lt; 4) + decodeHexChar(l))
269  static sds percentDecode(const char *pe, size_t len) {
270      const char *end = pe + len;
271      sds ret = sdsempty();
272      const char *curr = pe;
273      while (curr &lt; end) {
274          if (*curr == &#x27;%&#x27;) {
275              if ((end - curr) &lt; 2) {
276                  fprintf(stderr, &quot;Incomplete URI encoding\n&quot;);
277                  exit(1);
278              }
279              char h = tolower(*(++curr));
280              char l = tolower(*(++curr));
281              if (!isHexChar(h) || !isHexChar(l)) {
282                  fprintf(stderr, &quot;Illegal character in URI encoding\n&quot;);
283                  exit(1);
284              }
285              char c = decodeHex(h, l);
286              ret = sdscatlen(ret, &amp;c, 1);
287              curr++;
288          } else {
289              ret = sdscatlen(ret, curr++, 1);
290          }
291      }
292      return ret;
293  }
294  static void parseRedisUri(const char *uri) {
295      const char *scheme = &quot;redis:&amp;bsol;&amp;bsol;&quot;;
296      const char *curr = uri;
297      const char *end = uri + strlen(uri);
298      const char *userinfo, *username, *port, *host, *path;
299      if (strncasecmp(scheme, curr, strlen(scheme))) {
300          fprintf(stderr,&quot;Invalid URI scheme\n&quot;);
301          exit(1);
302      }
303      curr += strlen(scheme);
304      if (curr == end) return;
305      if ((userinfo = strchr(curr,&#x27;@&#x27;))) {
306          if ((username = strchr(curr, &#x27;:&#x27;)) &amp;&amp; username &lt; userinfo) {
307              curr = username + 1;
308          }
309          config.auth = percentDecode(curr, userinfo - curr);
310          curr = userinfo + 1;
311      }
312      if (curr == end) return;
313      path = strchr(curr, &#x27;/&#x27;);
314      if (*curr != &#x27;/&#x27;) {
315          host = path ? path - 1 : end;
316          if ((port = strchr(curr, &#x27;:&#x27;))) {
317              config.hostport = atoi(port + 1);
318              host = port - 1;
319          }
320          config.hostip = sdsnewlen(curr, host - curr + 1);
321      }
322      curr = path ? path + 1 : end;
323      if (curr == end) return;
324      config.dbnum = atoi(curr);
325  }
326  static uint64_t dictSdsHash(const void *key) {
327      return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
328  }
329  static int dictSdsKeyCompare(void *privdata, const void *key1,
330          const void *key2)
331  {
332      int l1,l2;
333      DICT_NOTUSED(privdata);
334      l1 = sdslen((sds)key1);
335      l2 = sdslen((sds)key2);
336      if (l1 != l2) return 0;
337      return memcmp(key1, key2, l1) == 0;
338  }
339  static void dictSdsDestructor(void *privdata, void *val)
340  {
341      DICT_NOTUSED(privdata);
342      sdsfree(val);
343  }
344  void dictListDestructor(void *privdata, void *val)
345  {
346      DICT_NOTUSED(privdata);
347      listRelease((list*)val);
348  }
349  void _serverAssert(const char *estr, const char *file, int line) {
350      fprintf(stderr, &quot;=== ASSERTION FAILED ===&quot;);
351      fprintf(stderr, &quot;==&gt; %s:%d &#x27;%s&#x27; is not true&quot;,file,line,estr);
352      *((char*)-1) = &#x27;x&#x27;;
353  }
354  #define CLI_HELP_COMMAND 1
355  #define CLI_HELP_GROUP 2
356  typedef struct {
357      int type;
358      int argc;
359      sds *argv;
360      sds full;
361      struct commandHelp *org;
362  } helpEntry;
363  static helpEntry *helpEntries;
364  static int helpEntriesLen;
365  static sds cliVersion(void) {
366      sds version;
367      version = sdscatprintf(sdsempty(), &quot;%s&quot;, REDIS_VERSION);
368      if (strtoll(redisGitSHA1(),NULL,16)) {
369          version = sdscatprintf(version, &quot; (git:%s&quot;, redisGitSHA1());
370          if (strtoll(redisGitDirty(),NULL,10))
371              version = sdscatprintf(version, &quot;-dirty&quot;);
372          version = sdscat(version, &quot;)&quot;);
373      }
374      return version;
375  }
376  static void cliInitHelp(void) {
377      int commandslen = sizeof(commandHelp)/sizeof(struct commandHelp);
378      int groupslen = sizeof(commandGroups)/sizeof(char*);
379      int i, len, pos = 0;
380      helpEntry tmp;
381      helpEntriesLen = len = commandslen+groupslen;
382      helpEntries = zmalloc(sizeof(helpEntry)*len);
383      for (i = 0; i &lt; groupslen; i++) {
384          tmp.argc = 1;
385          tmp.argv = zmalloc(sizeof(sds));
386          tmp.argv[0] = sdscatprintf(sdsempty(),&quot;@%s&quot;,commandGroups[i]);
387          tmp.full = tmp.argv[0];
388          tmp.type = CLI_HELP_GROUP;
389          tmp.org = NULL;
390          helpEntries[pos++] = tmp;
391      }
392      for (i = 0; i &lt; commandslen; i++) {
393          tmp.argv = sdssplitargs(commandHelp[i].name,&amp;tmp.argc);
394          tmp.full = sdsnew(commandHelp[i].name);
395          tmp.type = CLI_HELP_COMMAND;
396          tmp.org = &amp;commandHelp[i];
397          helpEntries[pos++] = tmp;
398      }
399  }
400  static void cliIntegrateHelp(void) {
401      if (cliConnect(CC_QUIET) == REDIS_ERR) return;
402      redisReply *reply = redisCommand(context, &quot;COMMAND&quot;);
403      if(reply == NULL || reply-&gt;type != REDIS_REPLY_ARRAY) return;
404      for (size_t j = 0; j &lt; reply-&gt;elements; j++) {
405          redisReply *entry = reply-&gt;element[j];
406          if (entry-&gt;type != REDIS_REPLY_ARRAY || entry-&gt;elements &lt; 4 ||
407              entry-&gt;element[0]-&gt;type != REDIS_REPLY_STRING ||
408              entry-&gt;element[1]-&gt;type != REDIS_REPLY_INTEGER ||
409              entry-&gt;element[3]-&gt;type != REDIS_REPLY_INTEGER) return;
410          char *cmdname = entry-&gt;element[0]-&gt;str;
411          int i;
412          for (i = 0; i &lt; helpEntriesLen; i++) {
413              helpEntry *he = helpEntries+i;
414              if (!strcasecmp(he-&gt;argv[0],cmdname))
415                  break;
416          }
417          if (i != helpEntriesLen) continue;
418          helpEntriesLen++;
419          helpEntries = zrealloc(helpEntries,sizeof(helpEntry)*helpEntriesLen);
420          helpEntry *new = helpEntries+(helpEntriesLen-1);
421          new-&gt;argc = 1;
422          new-&gt;argv = zmalloc(sizeof(sds));
423          new-&gt;argv[0] = sdsnew(cmdname);
424          new-&gt;full = new-&gt;argv[0];
425          new-&gt;type = CLI_HELP_COMMAND;
426          sdstoupper(new-&gt;argv[0]);
427          struct commandHelp *ch = zmalloc(sizeof(*ch));
428          ch-&gt;name = new-&gt;argv[0];
429          ch-&gt;params = sdsempty();
430          int args = llabs(entry-&gt;element[1]-&gt;integer);
431          args--; &amp;bsol;* Remove the command name itself. */
432          if (entry-&gt;element[3]-&gt;integer == 1) {
433              ch-&gt;params = sdscat(ch-&gt;params,&quot;key &quot;);
434              args--;
435          }
436          while(args-- &gt; 0) ch-&gt;params = sdscat(ch-&gt;params,&quot;arg &quot;);
437          if (entry-&gt;element[1]-&gt;integer &lt; 0)
438              ch-&gt;params = sdscat(ch-&gt;params,&quot;...options...&quot;);
439          ch-&gt;summary = &quot;Help not available&quot;;
440          ch-&gt;group = 0;
441          ch-&gt;since = &quot;not known&quot;;
442          new-&gt;org = ch;
443      }
444      freeReplyObject(reply);
445  }
446  static void cliOutputCommandHelp(struct commandHelp *help, int group) {
447      printf(&quot;\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n&quot;, help-&gt;name, help-&gt;params);
448      printf(&quot;  \x1b[33msummary:\x1b[0m %s\r\n&quot;, help-&gt;summary);
449      printf(&quot;  \x1b[33msince:\x1b[0m %s\r\n&quot;, help-&gt;since);
450      if (group) {
451          printf(&quot;  \x1b[33mgroup:\x1b[0m %s\r\n&quot;, commandGroups[help-&gt;group]);
452      }
453  }
454  static void cliOutputGenericHelp(void) {
455      sds version = cliVersion();
456      printf(
457          &quot;redis-cli %s\n&quot;
458          &quot;To get help about Redis commands type:\n&quot;
459          &quot;      \&quot;help @&lt;group&gt;\&quot; to get a list of commands in &lt;group&gt;\n&quot;
460          &quot;      \&quot;help &lt;command&gt;\&quot; for help on &lt;command&gt;\n&quot;
461          &quot;      \&quot;help &lt;tab&gt;\&quot; to get a list of possible help topics\n&quot;
462          &quot;      \&quot;quit\&quot; to exit\n&quot;
463          &quot;\n&quot;
464          &quot;To set redis-cli preferences:\n&quot;
465          &quot;      \&quot;:set hints\&quot; enable online hints\n&quot;
466          &quot;      \&quot;:set nohints\&quot; disable online hints\n&quot;
467          &quot;Set your preferences in ~/.redisclirc\n&quot;,
468          version
469      );
470      sdsfree(version);
471  }
472  static void cliOutputHelp(int argc, char **argv) {
473      int i, j, len;
474      int group = -1;
475      helpEntry *entry;
476      struct commandHelp *help;
477      if (argc == 0) {
478          cliOutputGenericHelp();
479          return;
480      } else if (argc &gt; 0 &amp;&amp; argv[0][0] == &#x27;@&#x27;) {
481          len = sizeof(commandGroups)/sizeof(char*);
482          for (i = 0; i &lt; len; i++) {
483              if (strcasecmp(argv[0]+1,commandGroups[i]) == 0) {
484                  group = i;
485                  break;
486              }
487          }
488      }
489      assert(argc &gt; 0);
490      for (i = 0; i &lt; helpEntriesLen; i++) {
491          entry = &amp;helpEntries[i];
492          if (entry-&gt;type != CLI_HELP_COMMAND) continue;
493          help = entry-&gt;org;
494          if (group == -1) {
495              if (argc == entry-&gt;argc) {
496                  for (j = 0; j &lt; argc; j++) {
497                      if (strcasecmp(argv[j],entry-&gt;argv[j]) != 0) break;
498                  }
499                  if (j == argc) {
500                      cliOutputCommandHelp(help,1);
501                  }
502              }
503          } else {
504              if (group == help-&gt;group) {
505                  cliOutputCommandHelp(help,0);
506              }
507          }
508      }
509      printf(&quot;\r\n&quot;);
510  }
511  static void completionCallback(const char *buf, linenoiseCompletions *lc) {
512      size_t startpos = 0;
513      int mask;
514      int i;
515      size_t matchlen;
516      sds tmp;
517      if (strncasecmp(buf,&quot;help &quot;,5) == 0) {
518          startpos = 5;
519          while (isspace(buf[startpos])) startpos++;
520          mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;
521      } else {
522          mask = CLI_HELP_COMMAND;
523      }
524      for (i = 0; i &lt; helpEntriesLen; i++) {
525          if (!(helpEntries[i].type &amp; mask)) continue;
526          matchlen = strlen(buf+startpos);
527          if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {
528              tmp = sdsnewlen(buf,startpos);
529              tmp = sdscat(tmp,helpEntries[i].full);
530              linenoiseAddCompletion(lc,tmp);
531              sdsfree(tmp);
532          }
533      }
534  }
535  static char *hintsCallback(const char *buf, int *color, int *bold) {
536      if (!pref.hints) return NULL;
537      int i, argc, buflen = (int)strlen(buf);                                     WIN_PORT_FIX &amp;bsol;* cast int */
538      sds *argv = sdssplitargs(buf,&amp;argc);
539      int endspace = buflen &amp;&amp; isspace(buf[buflen-1]);
540      if (argc == 0) {
541          sdsfreesplitres(argv,argc);
542          return NULL;
543      }
544      for (i = 0; i &lt; helpEntriesLen; i++) {
545          if (!(helpEntries[i].type &amp; CLI_HELP_COMMAND)) continue;
546          if (strcasecmp(argv[0],helpEntries[i].full) == 0)
547          {
548              *color = 90;
549              *bold = 0;
550              sds hint = sdsnew(helpEntries[i].org-&gt;params);
551              int toremove = argc-1;
552              while(toremove &gt; 0 &amp;&amp; sdslen(hint)) {
553                  if (hint[0] == &#x27;[&#x27;) break;
554                  if (hint[0] == &#x27; &#x27;) toremove--;
555                  sdsrange(hint,1,-1);
556              }
557              if (!endspace) {
558                  sds newhint = sdsnewlen(&quot; &quot;,1);
559                  newhint = sdscatsds(newhint,hint);
560                  sdsfree(hint);
561                  hint = newhint;
562              }
563              sdsfreesplitres(argv,argc);
564              return hint;
565          }
566      }
567      sdsfreesplitres(argv,argc);
568      return NULL;
569  }
570  static void freeHintsCallback(void *ptr) {
571      sdsfree(ptr);
572  }
573  static int cliAuth(void) {
574      redisReply *reply;
575      if (config.auth == NULL) return REDIS_OK;
576      reply = redisCommand(context,&quot;AUTH %s&quot;,config.auth);
577      if (reply != NULL) {
578          freeReplyObject(reply);
579          return REDIS_OK;
580      }
581      return REDIS_ERR;
582  }
583  static int cliSelect(void) {
584      redisReply *reply;
585      if (config.dbnum == 0) return REDIS_OK;
586      reply = redisCommand(context,&quot;SELECT %d&quot;,config.dbnum);
587      if (reply != NULL) {
588          int result = REDIS_OK;
589          if (reply-&gt;type == REDIS_REPLY_ERROR) result = REDIS_ERR;
590          freeReplyObject(reply);
591          return result;
592      }
593      return REDIS_ERR;
594  }
595  static int cliConnect(int flags) {
596      if (context == NULL || flags &amp; CC_FORCE) {
597          if (context != NULL) {
598              redisFree(context);
599          }
600          if (config.hostsocket == NULL) {
601              context = redisConnect(config.hostip,config.hostport);
602          } else {
603              context = redisConnectUnix(config.hostsocket);
604          }
605          if (context-&gt;err) {
606              if (!(flags &amp; CC_QUIET)) {
607                  fprintf(stderr,&quot;Could not connect to Redis at &quot;);
608                  if (config.hostsocket == NULL)
609                      fprintf(stderr,&quot;%s:%d: %s\n&quot;,
610                          config.hostip,config.hostport,context-&gt;errstr);
611                  else
612                      fprintf(stderr,&quot;%s: %s\n&quot;,
613                          config.hostsocket,context-&gt;errstr);
614              }
615              redisFree(context);
616              context = NULL;
617              return REDIS_ERR;
618          }
619          anetKeepAlive(NULL, context-&gt;fd, REDIS_CLI_KEEPALIVE_INTERVAL);
620          if (cliAuth() != REDIS_OK)
621              return REDIS_ERR;
622          if (cliSelect() != REDIS_OK)
623              return REDIS_ERR;
624      }
625      return REDIS_OK;
626  }
627  static void cliPrintContextError(void) {
628      if (context == NULL) return;
629      fprintf(stderr,&quot;Error: %s\n&quot;,context-&gt;errstr);
630  }
631  static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
632      sds out = sdsempty();
633      switch (r-&gt;type) {
634      case REDIS_REPLY_ERROR:
635          out = sdscatprintf(out,&quot;(error) %s\n&quot;, r-&gt;str);
636      break;
637      case REDIS_REPLY_STATUS:
638          out = sdscat(out,r-&gt;str);
639          out = sdscat(out,&quot;\n&quot;);
640      break;
641      case REDIS_REPLY_INTEGER:
642          out = sdscatprintf(out,&quot;(integer) %lld\n&quot;,r-&gt;integer);
643      break;
644      case REDIS_REPLY_STRING:
645          out = sdscatrepr(out,r-&gt;str,r-&gt;len);
646          out = sdscat(out,&quot;\n&quot;);
647      break;
648      case REDIS_REPLY_NIL:
649          out = sdscat(out,&quot;(nil)\n&quot;);
650      break;
651      case REDIS_REPLY_ARRAY:
652          if (r-&gt;elements == 0) {
653              out = sdscat(out,&quot;(empty list or set)\n&quot;);
654          } else {
655              unsigned int i, idxlen = 0;
656              char _prefixlen[16];
657              char _prefixfmt[16];
658              sds _prefix;
659              sds tmp;
660              i = r-&gt;elements;
661              do {
662                  idxlen++;
663                  i /= 10;
664              } while(i);
665              memset(_prefixlen,&#x27; &#x27;,idxlen+2);
666              _prefixlen[idxlen+2] = &#x27;\0&#x27;;
667              _prefix = sdscat(sdsnew(prefix),_prefixlen);
668              snprintf(_prefixfmt,sizeof(_prefixfmt),&quot;%%s%%%ud) &quot;,idxlen);
669              for (i = 0; i &lt; r-&gt;elements; i++) {
670                  out = sdscatprintf(out,_prefixfmt,i == 0 ? &quot;&quot; : prefix,i+1);
671                  tmp = cliFormatReplyTTY(r-&gt;element[i],_prefix);
672                  out = sdscatlen(out,tmp,sdslen(tmp));
673                  sdsfree(tmp);
674              }
675              sdsfree(_prefix);
676          }
677      break;
678      default:
679          fprintf(stderr,&quot;Unknown reply type: %d\n&quot;, r-&gt;type);
680          exit(1);
681      }
682      return out;
683  }
684  int isColorTerm(void) {
685      char *t = getenv(&quot;TERM&quot;);
686      return t != NULL &amp;&amp; strstr(t,&quot;xterm&quot;) != NULL;
687  }
688  sds sdscatcolor(sds o, char *s, size_t len, char *color) {
689      if (!isColorTerm()) return sdscatlen(o,s,len);
690      int bold = strstr(color,&quot;bold&quot;) != NULL;
691      int ccode = 37; &amp;bsol;* Defaults to white. */
692      if (strstr(color,&quot;red&quot;)) ccode = 31;
693      else if (strstr(color,&quot;green&quot;)) ccode = 32;
694      else if (strstr(color,&quot;yellow&quot;)) ccode = 33;
695      else if (strstr(color,&quot;blue&quot;)) ccode = 34;
696      else if (strstr(color,&quot;magenta&quot;)) ccode = 35;
697      else if (strstr(color,&quot;cyan&quot;)) ccode = 36;
698      else if (strstr(color,&quot;white&quot;)) ccode = 37;
699      o = sdscatfmt(o,&quot;\033[%i;%i;49m&quot;,bold,ccode);
700      o = sdscatlen(o,s,len);
701      o = sdscat(o,&quot;\033[0m&quot;);
702      return o;
703  }
704  sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
705      char *color = &quot;white&quot;;
706      if (strstr(s,&quot;&lt;debug&gt;&quot;)) color = &quot;bold&quot;;
707      if (strstr(s,&quot;&lt;redis&gt;&quot;)) color = &quot;green&quot;;
708      if (strstr(s,&quot;&lt;reply&gt;&quot;)) color = &quot;cyan&quot;;
709      if (strstr(s,&quot;&lt;error&gt;&quot;)) color = &quot;red&quot;;
710      if (strstr(s,&quot;&lt;hint&gt;&quot;)) color = &quot;bold&quot;;
711      if (strstr(s,&quot;&lt;value&gt;&quot;) || strstr(s,&quot;&lt;retval&gt;&quot;)) color = &quot;magenta&quot;;
712      if (len &gt; 4 &amp;&amp; isdigit(s[3])) {
713          if (s[1] == &#x27;&gt;&#x27;) color = &quot;yellow&quot;; &amp;bsol;* Current line. */
714          else if (s[2] == &#x27;#&#x27;) color = &quot;bold&quot;; &amp;bsol;* Break point. */
715      }
716      return sdscatcolor(o,s,len,color);
717  }
718  static sds cliFormatReplyRaw(redisReply *r) {
719      sds out = sdsempty(), tmp;
720      size_t i;
721      switch (r-&gt;type) {
722      case REDIS_REPLY_NIL:
723          break;
724      case REDIS_REPLY_ERROR:
725          out = sdscatlen(out,r-&gt;str,r-&gt;len);
726          out = sdscatlen(out,&quot;\n&quot;,1);
727          break;
728      case REDIS_REPLY_STATUS:
729      case REDIS_REPLY_STRING:
730          if (r-&gt;type == REDIS_REPLY_STATUS &amp;&amp; config.eval_ldb) {
731              if (strstr(r-&gt;str,&quot;&lt;endsession&gt;&quot;) == r-&gt;str) {
732                  config.enable_ldb_on_eval = 0;
733                  config.eval_ldb = 0;
734                  config.eval_ldb_end = 1; &amp;bsol;* Signal the caller session ended. */
735                  config.output = OUTPUT_STANDARD;
736                  cliRefreshPrompt();
737              } else {
738                  out = sdsCatColorizedLdbReply(out,r-&gt;str,r-&gt;len);
739              }
740          } else {
741              out = sdscatlen(out,r-&gt;str,r-&gt;len);
742          }
743          break;
744      case REDIS_REPLY_INTEGER:
745          out = sdscatprintf(out,&quot;%I64d&quot;,r-&gt;integer);   WIN_PORT_FIX &amp;bsol;* %lld -&gt; %I64d */
746          break;
747      case REDIS_REPLY_ARRAY:
748          for (i = 0; i &lt; r-&gt;elements; i++) {
749              if (i &gt; 0) out = sdscat(out,config.mb_delim);
750              tmp = cliFormatReplyRaw(r-&gt;element[i]);
751              out = sdscatlen(out,tmp,sdslen(tmp));
752              sdsfree(tmp);
753          }
754          break;
755      default:
756          fprintf(stderr,&quot;Unknown reply type: %d\n&quot;, r-&gt;type);
757          exit(1);
758      }
759      return out;
760  }
761  static sds cliFormatReplyCSV(redisReply *r) {
762      unsigned int i;
763      sds out = sdsempty();
764      switch (r-&gt;type) {
765      case REDIS_REPLY_ERROR:
766          out = sdscat(out,&quot;ERROR,&quot;);
767          out = sdscatrepr(out,r-&gt;str,strlen(r-&gt;str));
768      break;
769      case REDIS_REPLY_STATUS:
770          out = sdscatrepr(out,r-&gt;str,r-&gt;len);
771      break;
772      case REDIS_REPLY_INTEGER:
773          out = sdscatprintf(out,&quot;%I64d&quot;,r-&gt;integer);   WIN_PORT_FIX &amp;bsol;* %lld -&gt; %I64d */
774      break;
775      case REDIS_REPLY_STRING:
776          out = sdscatrepr(out,r-&gt;str,r-&gt;len);
777      break;
778      case REDIS_REPLY_NIL:
779          out = sdscat(out,&quot;NIL&quot;);
780      break;
781      case REDIS_REPLY_ARRAY:
782          for (i = 0; i &lt; r-&gt;elements; i++) {
783              sds tmp = cliFormatReplyCSV(r-&gt;element[i]);
784              out = sdscatlen(out,tmp,sdslen(tmp));
785              if (i != r-&gt;elements-1) out = sdscat(out,&quot;,&quot;);
786              sdsfree(tmp);
787          }
788      break;
789      default:
790          fprintf(stderr,&quot;Unknown reply type: %d\n&quot;, r-&gt;type);
791          exit(1);
792      }
793      return out;
794  }
795  static int cliReadReply(int output_raw_strings) {
796      void *_reply;
797      redisReply *reply;
798      sds out = NULL;
799      int output = 1;
800      if (redisGetReply(context,&amp;_reply) != REDIS_OK) {
801          if (config.shutdown) {
802              redisFree(context);
803              context = NULL;
804              return REDIS_OK;
805          }
806          if (config.interactive) {
807              if (context-&gt;err == REDIS_ERR_IO &amp;&amp;
808                  (errno == ECONNRESET || errno == EPIPE))
809                  return REDIS_ERR;
810              if (context-&gt;err == REDIS_ERR_EOF)
811                  return REDIS_ERR;
812          }
813          cliPrintContextError();
814          exit(1);
815          return REDIS_ERR; &amp;bsol;* avoid compiler warning */
816      }
817      reply = (redisReply*)_reply;
818      config.last_cmd_type = reply-&gt;type;
819      if (config.cluster_mode &amp;&amp; reply-&gt;type == REDIS_REPLY_ERROR &amp;&amp;
820          (!strncmp(reply-&gt;str,&quot;MOVED&quot;,5) || !strcmp(reply-&gt;str,&quot;ASK&quot;)))
821      {
822          char *p = reply-&gt;str, *s;
823          int slot;
824          output = 0;
825          s = strchr(p,&#x27; &#x27;);      &amp;bsol;* MOVED[S]3999 127.0.0.1:6381 */
826          p = strchr(s+1,&#x27; &#x27;);    &amp;bsol;* MOVED[S]3999[P]127.0.0.1:6381 */
827          *p = &#x27;\0&#x27;;
828          slot = atoi(s+1);
829          s = strrchr(p+1,&#x27;:&#x27;);    &amp;bsol;* MOVED 3999[P]127.0.0.1[S]6381 */
830          *s = &#x27;\0&#x27;;
831          sdsfree(config.hostip);
832          config.hostip = sdsnew(p+1);
833          config.hostport = atoi(s+1);
834          if (config.interactive)
835              printf(&quot;-&gt; Redirected to slot [%d] located at %s:%d\n&quot;,
836                  slot, config.hostip, config.hostport);
837          config.cluster_reissue_command = 1;
838          cliRefreshPrompt();
839      }
840      if (output) {
841          if (output_raw_strings) {
842              out = cliFormatReplyRaw(reply);
843          } else {
844              if (config.output == OUTPUT_RAW) {
845                  out = cliFormatReplyRaw(reply);
846                  out = sdscat(out,&quot;\n&quot;);
847              } else if (config.output == OUTPUT_STANDARD) {
848                  out = cliFormatReplyTTY(reply,&quot;&quot;);
849              } else if (config.output == OUTPUT_CSV) {
850                  out = cliFormatReplyCSV(reply);
851                  out = sdscat(out,&quot;\n&quot;);
852              }
853          }
854  #ifdef _WIN32
855          fprintf(stdout, &quot;%s&quot;, out);
856  #else
857          fwrite(out,sdslen(out),1,stdout);
858  #endif
859          sdsfree(out);
860      }
861      freeReplyObject(reply);
862      return REDIS_OK;
863  }
864  static int cliSendCommand(int argc, char **argv, PORT_LONG repeat) {
865      char *command = argv[0];
866      size_t *argvlen;
867      int j, output_raw;
868      if (!config.eval_ldb &amp;&amp; &amp;bsol;* In debugging mode, let&#x27;s pass &quot;help&quot; to Redis. */
869          (!strcasecmp(command,&quot;help&quot;) || !strcasecmp(command,&quot;?&quot;))) {
870          cliOutputHelp(--argc, ++argv);
871          return REDIS_OK;
872      }
873      if (context == NULL) return REDIS_ERR;
874      output_raw = 0;
875      if (!strcasecmp(command,&quot;info&quot;) ||
876          !strcasecmp(command,&quot;lolwut&quot;) ||
877          (argc &gt;= 2 &amp;&amp; !strcasecmp(command,&quot;debug&quot;) &amp;&amp;
878                         !strcasecmp(argv[1],&quot;htstats&quot;)) ||
879          (argc &gt;= 2 &amp;&amp; !strcasecmp(command,&quot;debug&quot;) &amp;&amp;
880                         !strcasecmp(argv[1],&quot;htstats-key&quot;)) ||
881          (argc &gt;= 2 &amp;&amp; !strcasecmp(command,&quot;memory&quot;) &amp;&amp;
882                        (!strcasecmp(argv[1],&quot;malloc-stats&quot;) ||
883                         !strcasecmp(argv[1],&quot;doctor&quot;))) ||
884          (argc == 2 &amp;&amp; !strcasecmp(command,&quot;cluster&quot;) &amp;&amp;
885                        (!strcasecmp(argv[1],&quot;nodes&quot;) ||
886                         !strcasecmp(argv[1],&quot;info&quot;))) ||
887          (argc &gt;= 2 &amp;&amp; !strcasecmp(command,&quot;client&quot;) &amp;&amp;
888                         !strcasecmp(argv[1],&quot;list&quot;)) ||
889          (argc == 3 &amp;&amp; !strcasecmp(command,&quot;latency&quot;) &amp;&amp;
890                         !strcasecmp(argv[1],&quot;graph&quot;)) ||
891          (argc == 2 &amp;&amp; !strcasecmp(command,&quot;latency&quot;) &amp;&amp;
892                         !strcasecmp(argv[1],&quot;doctor&quot;)))
893      {
894          output_raw = 1;
895      }
896      if (!strcasecmp(command,&quot;shutdown&quot;)) config.shutdown = 1;
897      if (!strcasecmp(command,&quot;monitor&quot;)) config.monitor_mode = 1;
898      if (!strcasecmp(command,&quot;subscribe&quot;) ||
899          !strcasecmp(command,&quot;psubscribe&quot;)) config.pubsub_mode = 1;
900      if (!strcasecmp(command,&quot;sync&quot;) ||
901          !strcasecmp(command,&quot;psync&quot;)) config.slave_mode = 1;
902      if (argc == 3 &amp;&amp; !strcasecmp(argv[0],&quot;script&quot;) &amp;&amp;
903                       !strcasecmp(argv[1],&quot;debug&quot;))
904      {
905          if (!strcasecmp(argv[2],&quot;yes&quot;) || !strcasecmp(argv[2],&quot;sync&quot;)) {
906              config.enable_ldb_on_eval = 1;
907          } else {
908              config.enable_ldb_on_eval = 0;
909          }
910      }
911      if (!strcasecmp(command,&quot;eval&quot;) &amp;&amp; config.enable_ldb_on_eval) {
912          config.eval_ldb = 1;
913          config.output = OUTPUT_RAW;
914      }
915      argvlen = zmalloc(argc*sizeof(size_t));
916      for (j = 0; j &lt; argc; j++)
917          argvlen[j] = sdslen(argv[j]);
918      while(repeat &lt; 0 || repeat-- &gt; 0) {
919          redisAppendCommandArgv(context,argc,(const char**)argv,argvlen);
920          while (config.monitor_mode) {
921              if (cliReadReply(output_raw) != REDIS_OK) exit(1);
922              fflush(stdout);
923          }
924          if (config.pubsub_mode) {
925              if (config.output != OUTPUT_RAW)
926                  printf(&quot;Reading messages... (press Ctrl-C to quit)\n&quot;);
927              while (1) {
928                  if (cliReadReply(output_raw) != REDIS_OK) exit(1);
929              }
930          }
931          if (config.slave_mode) {
932              printf(&quot;Entering replica output mode...  (press Ctrl-C to quit)\n&quot;);
933              slaveMode();
934              config.slave_mode = 0;
935              zfree(argvlen);
936              return REDIS_ERR;  &amp;bsol;* Error = slaveMode lost connection to master */
937          }
938          if (cliReadReply(output_raw) != REDIS_OK) {
939              zfree(argvlen);
940              return REDIS_ERR;
941          } else {
942              if (!strcasecmp(command,&quot;select&quot;) &amp;&amp; argc == 2 &amp;&amp; config.last_cmd_type != REDIS_REPLY_ERROR) {
943                  config.dbnum = atoi(argv[1]);
944                  cliRefreshPrompt();
945              } else if (!strcasecmp(command,&quot;auth&quot;) &amp;&amp; argc == 2) {
946                  cliSelect();
947              }
948          }
949          if (config.cluster_reissue_command){
950              break;
951          }
952          if (config.interval) usleep(config.interval);
953          fflush(stdout); &amp;bsol;* Make it grep friendly */
954      }
955      zfree(argvlen);
956      return REDIS_OK;
957  }
958  static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
959      redisReply *reply = NULL;
960      int tries = 0;
961      va_list ap;
962      assert(!c-&gt;err);
963      while(reply == NULL) {
964          while (c-&gt;err &amp; (REDIS_ERR_IO | REDIS_ERR_EOF)) {
965              printf(&quot;\r\x1b[0K&quot;); &amp;bsol;* Cursor to left edge + clear line. */
966              printf(&quot;Reconnecting... %d\r&quot;, ++tries);
967              fflush(stdout);
968              redisFree(c);
969              c = redisConnect(config.hostip,config.hostport);
970              usleep(1000000);
971          }
972          va_start(ap,fmt);
973          reply = redisvCommand(c,fmt,ap);
974          va_end(ap);
975          if (c-&gt;err &amp;&amp; !(c-&gt;err &amp; (REDIS_ERR_IO | REDIS_ERR_EOF))) {
976              fprintf(stderr, &quot;Error: %s\n&quot;, c-&gt;errstr);
977              exit(1);
978          } else if (tries &gt; 0) {
979              printf(&quot;\r\x1b[0K&quot;); &amp;bsol;* Cursor to left edge + clear line. */
980          }
981      }
982      context = c;
983      return reply;
984  }
985  static int parseOptions(int argc, char **argv) {
986      int i;
987      for (i = 1; i &lt; argc; i++) {
988          int lastarg = i==argc-1;
989          if (!strcmp(argv[i],&quot;-h&quot;) &amp;&amp; !lastarg) {
990              sdsfree(config.hostip);
991              config.hostip = sdsnew(argv[++i]);
992          } else if (!strcmp(argv[i],&quot;-h&quot;) &amp;&amp; lastarg) {
993              usage();
994          } else if (!strcmp(argv[i],&quot;--help&quot;)) {
995              usage();
996          } else if (!strcmp(argv[i],&quot;-x&quot;)) {
997              config.stdinarg = 1;
998          } else if (!strcmp(argv[i],&quot;-p&quot;) &amp;&amp; !lastarg) {
999              config.hostport = atoi(argv[++i]);
1000          } else if (!strcmp(argv[i],&quot;-s&quot;) &amp;&amp; !lastarg) {
1001              config.hostsocket = argv[++i];
1002          } else if (!strcmp(argv[i],&quot;-r&quot;) &amp;&amp; !lastarg) {
1003              config.repeat = (PORT_LONG)strtoll(argv[++i],NULL,10);
1004          } else if (!strcmp(argv[i],&quot;-i&quot;) &amp;&amp; !lastarg) {
1005              double seconds = atof(argv[++i]);
1006              config.interval = (PORT_LONG)(seconds*1000000);
1007          } else if (!strcmp(argv[i],&quot;-n&quot;) &amp;&amp; !lastarg) {
1008              config.dbnum = atoi(argv[++i]);
1009          } else if (!strcmp(argv[i], &quot;--no-auth-warning&quot;)) {
1010              config.no_auth_warning = 1;
1011          } else if (!strcmp(argv[i],&quot;-a&quot;) &amp;&amp; !lastarg) {
1012              config.auth = argv[++i];
1013          } else if (!strcmp(argv[i],&quot;-u&quot;) &amp;&amp; !lastarg) {
1014              parseRedisUri(argv[++i]);
1015          } else if (!strcmp(argv[i],&quot;--raw&quot;)) {
1016              config.output = OUTPUT_RAW;
1017          } else if (!strcmp(argv[i],&quot;--no-raw&quot;)) {
1018              config.output = OUTPUT_STANDARD;
1019          } else if (!strcmp(argv[i],&quot;--csv&quot;)) {
1020              config.output = OUTPUT_CSV;
1021          } else if (!strcmp(argv[i],&quot;--latency&quot;)) {
1022              config.latency_mode = 1;
1023          } else if (!strcmp(argv[i],&quot;--latency-dist&quot;)) {
1024              config.latency_dist_mode = 1;
1025          } else if (!strcmp(argv[i],&quot;--mono&quot;)) {
1026              spectrum_palette = spectrum_palette_mono;
1027              spectrum_palette_size = spectrum_palette_mono_size;
1028          } else if (!strcmp(argv[i],&quot;--latency-history&quot;)) {
1029              config.latency_mode = 1;
1030              config.latency_history = 1;
1031          } else if (!strcmp(argv[i],&quot;--lru-test&quot;) &amp;&amp; !lastarg) {
1032              config.lru_test_mode = 1;
1033              config.lru_test_sample_size = strtoll(argv[++i],NULL,10);
1034          } else if (!strcmp(argv[i],&quot;--slave&quot;)) {
1035              config.slave_mode = 1;
1036          } else if (!strcmp(argv[i],&quot;--replica&quot;)) {
1037              config.slave_mode = 1;
1038          } else if (!strcmp(argv[i],&quot;--stat&quot;)) {
1039              config.stat_mode = 1;
1040          } else if (!strcmp(argv[i],&quot;--scan&quot;)) {
1041              config.scan_mode = 1;
1042          } else if (!strcmp(argv[i],&quot;--pattern&quot;) &amp;&amp; !lastarg) {
1043              config.pattern = argv[++i];
1044          } else if (!strcmp(argv[i],&quot;--intrinsic-latency&quot;) &amp;&amp; !lastarg) {
1045              config.intrinsic_latency_mode = 1;
1046              config.intrinsic_latency_duration = atoi(argv[++i]);
1047          } else if (!strcmp(argv[i],&quot;--rdb&quot;) &amp;&amp; !lastarg) {
1048              config.getrdb_mode = 1;
1049              config.rdb_filename = argv[++i];
1050          } else if (!strcmp(argv[i],&quot;--pipe&quot;)) {
1051              config.pipe_mode = 1;
1052          } else if (!strcmp(argv[i],&quot;--pipe-timeout&quot;) &amp;&amp; !lastarg) {
1053              config.pipe_timeout = atoi(argv[++i]);
1054          } else if (!strcmp(argv[i],&quot;--bigkeys&quot;)) {
1055              config.bigkeys = 1;
1056          } else if (!strcmp(argv[i],&quot;--memkeys&quot;)) {
1057              config.memkeys = 1;
1058              config.memkeys_samples = 0; &amp;bsol;* use redis default */
1059          } else if (!strcmp(argv[i],&quot;--memkeys-samples&quot;)) {
1060              config.memkeys = 1;
1061              config.memkeys_samples = atoi(argv[++i]);
1062          } else if (!strcmp(argv[i],&quot;--hotkeys&quot;)) {
1063              config.hotkeys = 1;
1064          } else if (!strcmp(argv[i],&quot;--eval&quot;) &amp;&amp; !lastarg) {
1065              config.eval = argv[++i];
1066          } else if (!strcmp(argv[i],&quot;--ldb&quot;)) {
1067              config.eval_ldb = 1;
1068              config.output = OUTPUT_RAW;
1069          } else if (!strcmp(argv[i],&quot;--ldb-sync-mode&quot;)) {
1070              config.eval_ldb = 1;
1071              config.eval_ldb_sync = 1;
1072              config.output = OUTPUT_RAW;
1073          } else if (!strcmp(argv[i],&quot;-c&quot;)) {
1074              config.cluster_mode = 1;
1075          } else if (!strcmp(argv[i],&quot;-d&quot;) &amp;&amp; !lastarg) {
1076              sdsfree(config.mb_delim);
1077              config.mb_delim = sdsnew(argv[++i]);
1078          } else if (!strcmp(argv[i],&quot;--verbose&quot;)) {
1079              config.verbose = 1;
1080          } else if (!strcmp(argv[i],&quot;--cluster&quot;) &amp;&amp; !lastarg) {
1081              if (CLUSTER_MANAGER_MODE()) usage();
1082              char *cmd = argv[++i];
1083              int j = i;
1084              while (j &lt; argc &amp;&amp; argv[j][0] != &#x27;-&#x27;) j++;
1085              if (j &gt; i) j--;
1086              createClusterManagerCommand(cmd, j - i, argv + i + 1);
1087              i = j;
1088          } else if (!strcmp(argv[i],&quot;--cluster&quot;) &amp;&amp; lastarg) {
1089              usage();
1090          } else if (!strcmp(argv[i],&quot;--cluster-replicas&quot;) &amp;&amp; !lastarg) {
1091              config.cluster_manager_command.replicas = atoi(argv[++i]);
1092          } else if (!strcmp(argv[i],&quot;--cluster-master-id&quot;) &amp;&amp; !lastarg) {
1093              config.cluster_manager_command.master_id = argv[++i];
1094          } else if (!strcmp(argv[i],&quot;--cluster-from&quot;) &amp;&amp; !lastarg) {
1095              config.cluster_manager_command.from = argv[++i];
1096          } else if (!strcmp(argv[i],&quot;--cluster-to&quot;) &amp;&amp; !lastarg) {
1097              config.cluster_manager_command.to = argv[++i];
1098          } else if (!strcmp(argv[i],&quot;--cluster-weight&quot;) &amp;&amp; !lastarg) {
1099              if (config.cluster_manager_command.weight != NULL) {
1100                  fprintf(stderr, &quot;WARNING: you cannot use --cluster-weight &quot;
1101                                  &quot;more than once.\n&quot;
1102                                  &quot;You can set more weights by adding them &quot;
1103                                  &quot;as a space-separated list, ie:\n&quot;
1104                                  &quot;--cluster-weight n1=w n2=w\n&quot;);
1105                  exit(1);
1106              }
1107              int widx = i + 1;
1108              char **weight = argv + widx;
1109              int wargc = 0;
1110              for (; widx &lt; argc; widx++) {
1111                  if (strstr(argv[widx], &quot;--&quot;) == argv[widx]) break;
1112                  if (strchr(argv[widx], &#x27;=&#x27;) == NULL) break;
1113                  wargc++;
1114              }
1115              if (wargc &gt; 0) {
1116                  config.cluster_manager_command.weight = weight;
1117                  config.cluster_manager_command.weight_argc = wargc;
1118                  i += wargc;
1119              }
1120          } else if (!strcmp(argv[i],&quot;--cluster-slots&quot;) &amp;&amp; !lastarg) {
1121              config.cluster_manager_command.slots = atoi(argv[++i]);
1122          } else if (!strcmp(argv[i],&quot;--cluster-timeout&quot;) &amp;&amp; !lastarg) {
1123              config.cluster_manager_command.timeout = atoi(argv[++i]);
1124          } else if (!strcmp(argv[i],&quot;--cluster-pipeline&quot;) &amp;&amp; !lastarg) {
1125              config.cluster_manager_command.pipeline = atoi(argv[++i]);
1126          } else if (!strcmp(argv[i],&quot;--cluster-threshold&quot;) &amp;&amp; !lastarg) {
1127              config.cluster_manager_command.threshold = atof(argv[++i]);
1128          } else if (!strcmp(argv[i],&quot;--cluster-yes&quot;)) {
1129              config.cluster_manager_command.flags |=
1130                  CLUSTER_MANAGER_CMD_FLAG_YES;
1131          } else if (!strcmp(argv[i],&quot;--cluster-simulate&quot;)) {
1132              config.cluster_manager_command.flags |=
1133                  CLUSTER_MANAGER_CMD_FLAG_SIMULATE;
1134          } else if (!strcmp(argv[i],&quot;--cluster-replace&quot;)) {
1135              config.cluster_manager_command.flags |=
1136                  CLUSTER_MANAGER_CMD_FLAG_REPLACE;
1137          } else if (!strcmp(argv[i],&quot;--cluster-copy&quot;)) {
1138              config.cluster_manager_command.flags |=
1139                  CLUSTER_MANAGER_CMD_FLAG_COPY;
1140          } else if (!strcmp(argv[i],&quot;--cluster-slave&quot;)) {
1141              config.cluster_manager_command.flags |=
1142                  CLUSTER_MANAGER_CMD_FLAG_SLAVE;
1143          } else if (!strcmp(argv[i],&quot;--cluster-use-empty-masters&quot;)) {
1144              config.cluster_manager_command.flags |=
1145                  CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER;
1146          } else if (!strcmp(argv[i],&quot;--cluster-search-multiple-owners&quot;)) {
1147              config.cluster_manager_command.flags |=
1148                  CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS;
1149          } else if (!strcmp(argv[i],&quot;-v&quot;) || !strcmp(argv[i], &quot;--version&quot;)) {
1150              sds version = cliVersion();
1151              printf(&quot;redis-cli %s\n&quot;, version);
1152              sdsfree(version);
1153              exit(0);
1154          } else if (CLUSTER_MANAGER_MODE() &amp;&amp; argv[i][0] != &#x27;-&#x27;) {
1155              if (config.cluster_manager_command.argc == 0) {
1156                  int j = i + 1;
1157                  while (j &lt; argc &amp;&amp; argv[j][0] != &#x27;-&#x27;) j++;
1158                  int cmd_argc = j - i;
1159                  config.cluster_manager_command.argc = cmd_argc;
1160                  config.cluster_manager_command.argv = argv + i;
1161                  if (cmd_argc &gt; 1) i = j - 1;
1162              }
1163          } else {
1164              if (argv[i][0] == &#x27;-&#x27;) {
1165                  fprintf(stderr,
1166                      &quot;Unrecognized option or bad number of args for: &#x27;%s&#x27;\n&quot;,
1167                      argv[i]);
1168                  exit(1);
1169              } else {
1170                  break;
1171              }
1172          }
1173      }
1174      if (config.eval_ldb &amp;&amp; config.eval == NULL) {
1175          fprintf(stderr,&quot;Options --ldb and --ldb-sync-mode require --eval.\n&quot;);
1176          fprintf(stderr,&quot;Try %s --help for more information.\n&quot;, argv[0]);
1177          exit(1);
1178      }
1179      if (!config.no_auth_warning &amp;&amp; config.auth != NULL) {
1180          fputs(&quot;Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command&quot;
1181                &quot; line interface may not be safe.\n&quot;, stderr);
1182      }
1183      return i;
1184  }
1185  static void parseEnv() {
1186      char *auth = getenv(REDIS_CLI_AUTH_ENV);
1187      if (auth != NULL &amp;&amp; config.auth == NULL) {
1188          config.auth = auth;
1189      }
1190      char *cluster_yes = getenv(REDIS_CLI_CLUSTER_YES_ENV);
1191      if (cluster_yes != NULL &amp;&amp; !strcmp(cluster_yes, &quot;1&quot;)) {
1192          config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
1193      }
1194  }
1195  static sds readArgFromStdin(void) {
1196      char buf[1024];
1197      sds arg = sdsempty();
1198      while(1) {
1199          int nread = (int)read(fileno(stdin),buf,1024);                          WIN_PORT_FIX &amp;bsol;* cast (int) */
1200          if (nread == 0) break;
1201          else if (nread == -1) {
1202              perror(&quot;Reading from standard input&quot;);
1203              exit(1);
1204          }
1205          arg = sdscatlen(arg,buf,nread);
1206      }
1207      return arg;
1208  }
1209  static void usage(void) {
1210      sds version = cliVersion();
1211      fprintf(stderr,
1212  &quot;redis-cli %s\n&quot;
1213  &quot;\n&quot;
1214  &quot;Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\n&quot;
1215  &quot;  -h &lt;hostname&gt;      Server hostname (default: 127.0.0.1).\n&quot;
1216  &quot;  -p &lt;port&gt;          Server port (default: 6379).\n&quot;
1217  &quot;  -s &lt;socket&gt;        Server socket (overrides hostname and port).\n&quot;
1218  &quot;  -a &lt;password&gt;      Password to use when connecting to the server.\n&quot;
1219  &quot;                     You can also use the &quot; REDIS_CLI_AUTH_ENV &quot; environment\n&quot;
1220  &quot;                     variable to pass this password more safely\n&quot;
1221  &quot;                     (if both are used, this argument takes predecence).\n&quot;
1222  &quot;  -u &lt;uri&gt;           Server URI.\n&quot;
1223  &quot;  -r &lt;repeat&gt;        Execute specified command N times.\n&quot;
1224  &quot;  -i &lt;interval&gt;      When -r is used, waits &lt;interval&gt; seconds per command.\n&quot;
1225  &quot;                     It is possible to specify sub-second times like -i 0.1.\n&quot;
1226  &quot;  -n &lt;db&gt;            Database number.\n&quot;
1227  &quot;  -x                 Read last argument from STDIN.\n&quot;
1228  &quot;  -d &lt;delimiter&gt;     Multi-bulk delimiter in for raw formatting (default: \\n).\n&quot;
1229  &quot;  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).\n&quot;
1230  &quot;  --raw              Use raw formatting for replies (default when STDOUT is\n&quot;
1231  &quot;                     not a tty).\n&quot;
1232  &quot;  --no-raw           Force formatted output even when STDOUT is not a tty.\n&quot;
1233  &quot;  --csv              Output in CSV format.\n&quot;
1234  &quot;  --stat             Print rolling stats about server: mem, clients, ...\n&quot;
1235  &quot;  --latency          Enter a special mode continuously sampling latency.\n&quot;
1236  &quot;                     If you use this mode in an interactive session it runs\n&quot;
1237  &quot;                     forever displaying real-time stats. Otherwise if --raw or\n&quot;
1238  &quot;                     --csv is specified, or if you redirect the output to a non\n&quot;
1239  &quot;                     TTY, it samples the latency for 1 second (you can use\n&quot;
1240  &quot;                     -i to change the interval), then produces a single output\n&quot;
1241  &quot;                     and exits.\n&quot;
1242  &quot;  --latency-history  Like --latency but tracking latency changes over time.\n&quot;
1243  &quot;                     Default time interval is 15 sec. Change it using -i.\n&quot;
1244  &quot;  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\n&quot;
1245  &quot;                     Default time interval is 1 sec. Change it using -i.\n&quot;
1246  &quot;  --lru-test &lt;keys&gt;  Simulate a cache workload with an 80-20 distribution.\n&quot;
1247  &quot;  --replica          Simulate a replica showing commands received from the master.\n&quot;
1248  &quot;  --rdb &lt;filename&gt;   Transfer an RDB dump from remote server to local file.\n&quot;
1249  &quot;  --pipe             Transfer raw Redis protocol from stdin to server.\n&quot;
1250  &quot;  --pipe-timeout &lt;n&gt; In --pipe mode, abort with error if after sending all data.\n&quot;
1251  &quot;                     no reply is received within &lt;n&gt; seconds.\n&quot;
1252  &quot;                     Default timeout: %d. Use 0 to wait forever.\n&quot;
1253  &quot;  --bigkeys          Sample Redis keys looking for keys with many elements (complexity).\n&quot;
1254  &quot;  --memkeys          Sample Redis keys looking for keys consuming a lot of memory.\n&quot;
1255  &quot;  --memkeys-samples &lt;n&gt; Sample Redis keys looking for keys consuming a lot of memory.\n&quot;
1256  &quot;                     And define number of key elements to sample\n&quot;
1257  &quot;  --hotkeys          Sample Redis keys looking for hot keys.\n&quot;
1258  &quot;                     only works when maxmemory-policy is *lfu.\n&quot;
1259  &quot;  --scan             List all keys using the SCAN command.\n&quot;
1260  &quot;  --pattern &lt;pat&gt;    Useful with --scan to specify a SCAN pattern.\n&quot;
1261  &quot;  --intrinsic-latency &lt;sec&gt; Run a test to measure intrinsic system latency.\n&quot;
1262  &quot;                     The test will run for the specified amount of seconds.\n&quot;
1263  &quot;  --eval &lt;file&gt;      Send an EVAL command using the Lua script at &lt;file&gt;.\n&quot;
1264  &quot;  --ldb              Used with --eval enable the Redis Lua debugger.\n&quot;
1265  &quot;  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\n&quot;
1266  &quot;                     this mode the server is blocked and script changes are\n&quot;
1267  &quot;                     not rolled back from the server memory.\n&quot;
1268  &quot;  --cluster &lt;command&gt; [args...] [opts...]\n&quot;
1269  &quot;                     Cluster Manager command and arguments (see below).\n&quot;
1270  &quot;  --verbose          Verbose mode.\n&quot;
1271  &quot;  --no-auth-warning  Don&#x27;t show warning message when using password on command\n&quot;
1272  &quot;                     line interface.\n&quot;
1273  &quot;  --help             Output this help and exit.\n&quot;
1274  &quot;  --version          Output version and exit.\n&quot;
1275  &quot;\n&quot;,
1276      version, REDIS_CLI_DEFAULT_PIPE_TIMEOUT);
1277      fprintf(stderr,
1278  &quot;Cluster Manager Commands:\n&quot;
1279  &quot;  Use --cluster help to list all available cluster manager commands.\n&quot;
1280  &quot;\n&quot;
1281  &quot;Examples:\n&quot;
1282  &quot;  cat /etc/passwd | redis-cli -x set mypasswd\n&quot;
1283  &quot;  redis-cli get mypasswd\n&quot;
1284  &quot;  redis-cli -r 100 lpush mylist x\n&quot;
1285  &quot;  redis-cli -r 100 -i 1 info | grep used_memory_human:\n&quot;
1286  &quot;  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\n&quot;
1287  &quot;  redis-cli --scan --pattern &#x27;*:12345*&#x27;\n&quot;
1288  &quot;\n&quot;
1289  &quot;  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\n&quot;
1290  &quot;\n&quot;
1291  &quot;When no command is given, redis-cli starts in interactive mode.\n&quot;
1292  &quot;Type \&quot;help\&quot; in interactive mode for information on available commands\n&quot;
1293  &quot;and settings.\n&quot;
1294  &quot;\n&quot;);
1295      sdsfree(version);
1296      exit(1);
1297  }
1298  static int confirmWithYes(char *msg) {
1299      if (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_YES) {
1300          return 1;
1301      }
1302      printf(&quot;%s (type &#x27;yes&#x27; to accept): &quot;, msg);
1303      fflush(stdout);
1304      char buf[4];
1305      int nread = read(fileno(stdin),buf,4);
1306      buf[3] = &#x27;\0&#x27;;
1307      return (nread != 0 &amp;&amp; !strcmp(&quot;yes&quot;, buf));
1308  }
1309  static char **convertToSds(int count, char** args) {
1310    int j;
1311    char **sds = zmalloc(sizeof(char*)*count);
1312    for(j = 0; j &lt; count; j++)
1313      sds[j] = sdsnew(args[j]);
1314    return sds;
1315  }
1316  static int issueCommandRepeat(int argc, char **argv, PORT_LONG repeat) {
1317      while (1) {
1318          config.cluster_reissue_command = 0;
1319          if (cliSendCommand(argc,argv,(int)repeat) != REDIS_OK) { WIN_PORT_FIX &amp;bsol;* cast (int) */
1320              cliConnect(CC_FORCE);
1321              if (cliSendCommand(argc,argv,(int)repeat) != REDIS_OK) { WIN_PORT_FIX &amp;bsol;* cast (int) */
1322                  cliPrintContextError();
1323                  return REDIS_ERR;
1324              }
1325           }
1326           if (config.cluster_mode &amp;&amp; config.cluster_reissue_command) {
1327              cliConnect(CC_FORCE);
1328           } else {
1329               break;
1330          }
1331      }
1332      return REDIS_OK;
1333  }
1334  static int issueCommand(int argc, char **argv) {
1335      return issueCommandRepeat(argc, argv, config.repeat);
1336  }
1337  static sds *cliSplitArgs(char *line, int *argc) {
1338      if (config.eval_ldb &amp;&amp; (strstr(line,&quot;eval &quot;) == line ||
1339                              strstr(line,&quot;e &quot;) == line))
1340      {
1341          sds *argv = sds_malloc(sizeof(sds)*2);
1342          *argc = 2;
1343          int len = (int) strlen(line);                                            WIN_PORT_FIX &amp;bsol;* cast int */
1344          int elen = line[1] == &#x27; &#x27; ? 2 : 5; &amp;bsol;* &quot;e &quot; or &quot;eval &quot;? */
1345          argv[0] = sdsnewlen(line,elen-1);
1346          argv[1] = sdsnewlen(line+elen,len-elen);
1347          return argv;
1348      } else {
1349          return sdssplitargs(line,argc);
1350      }
1351  }
1352  void cliSetPreferences(char **argv, int argc, int interactive) {
1353      if (!strcasecmp(argv[0],&quot;:set&quot;) &amp;&amp; argc &gt;= 2) {
1354          if (!strcasecmp(argv[1],&quot;hints&quot;)) pref.hints = 1;
1355          else if (!strcasecmp(argv[1],&quot;nohints&quot;)) pref.hints = 0;
1356          else {
1357              printf(&quot;%sunknown redis-cli preference &#x27;%s&#x27;\n&quot;,
1358                  interactive ? &quot;&quot; : &quot;.redisclirc: &quot;,
1359                  argv[1]);
1360          }
1361      } else {
1362          printf(&quot;%sunknown redis-cli internal command &#x27;%s&#x27;\n&quot;,
1363              interactive ? &quot;&quot; : &quot;.redisclirc: &quot;,
1364              argv[0]);
1365      }
1366  }
1367  void cliLoadPreferences(void) {
1368      sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
1369      if (rcfile == NULL) return;
1370      FILE *fp = fopen(rcfile,&quot;r&quot;);
1371      char buf[1024];
1372      if (fp) {
1373          while(fgets(buf,sizeof(buf),fp) != NULL) {
1374              sds *argv;
1375              int argc;
1376              argv = sdssplitargs(buf,&amp;argc);
1377              if (argc &gt; 0) cliSetPreferences(argv,argc,0);
1378              sdsfreesplitres(argv,argc);
1379          }
1380          fclose(fp);
1381      }
1382      sdsfree(rcfile);
1383  }
1384  static void repl(void) {
1385      sds historyfile = NULL;
1386      int history = 0;
1387      char *line;
1388      int argc;
1389      sds *argv;
1390      cliInitHelp();
1391      cliIntegrateHelp();
1392      config.interactive = 1;
1393      linenoiseSetMultiLine(1);
1394      linenoiseSetCompletionCallback(completionCallback);
1395      linenoiseSetHintsCallback(hintsCallback);
1396      linenoiseSetFreeHintsCallback(freeHintsCallback);
1397      if (isatty(fileno(stdin))) {
1398          historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);
1399          history = 1;
1400          if (historyfile != NULL) {
1401              linenoiseHistoryLoad(historyfile);
1402          }
1403          cliLoadPreferences();
1404      }
1405      cliRefreshPrompt();
1406      while((line = linenoise(context ? config.prompt : &quot;not connected&gt; &quot;)) != NULL) {
1407          if (line[0] != &#x27;\0&#x27;) {
1408              PORT_LONG repeat = 1;
1409              int skipargs = 0;
1410              char *endptr = NULL;
1411              argv = cliSplitArgs(line,&amp;argc);
1412              if (argv &amp;&amp; argc &gt; 0) {
1413                  errno = 0;
1414                  repeat = strtol(argv[0], &amp;endptr, 10);
1415                  if (argc &gt; 1 &amp;&amp; *endptr == &#x27;\0&#x27;) {
1416                      if (errno == ERANGE || errno == EINVAL || repeat &lt;= 0) {
1417                          fputs(&quot;Invalid redis-cli repeat command option value.\n&quot;, stdout);
1418                          sdsfreesplitres(argv, argc);
1419                          linenoiseFree(line);
1420                          continue;
1421                      }
1422                      skipargs = 1;
1423                  } else {
1424                      repeat = 1;
1425                  }
1426              }
1427              if (!(argv &amp;&amp; argc &gt; 0 &amp;&amp; !strcasecmp(argv[0+skipargs], &quot;auth&quot;))) {
1428                  if (history) linenoiseHistoryAdd(line);
1429                  if (historyfile) linenoiseHistorySave(historyfile);
1430              }
1431              if (argv == NULL) {
1432                  printf(&quot;Invalid argument(s)\n&quot;);
1433                  linenoiseFree(line);
1434                  continue;
1435              } else if (argc &gt; 0) {
1436                  if (strcasecmp(argv[0],&quot;quit&quot;) == 0 ||
1437                      strcasecmp(argv[0],&quot;exit&quot;) == 0)
1438                  {
1439                      exit(0);
1440                  } else if (argv[0][0] == &#x27;:&#x27;) {
1441                      cliSetPreferences(argv,argc,1);
1442                      sdsfreesplitres(argv,argc);
1443                      linenoiseFree(line);
1444                      continue;
1445                  } else if (strcasecmp(argv[0],&quot;restart&quot;) == 0) {
1446                      if (config.eval) {
1447                          config.eval_ldb = 1;
1448                          config.output = OUTPUT_RAW;
1449                          return; &amp;bsol;* Return to evalMode to restart the session. */
1450                      } else {
1451                          printf(&quot;Use &#x27;restart&#x27; only in Lua debugging mode.&quot;);
1452                      }
1453                  } else if (argc == 3 &amp;&amp; !strcasecmp(argv[0],&quot;connect&quot;)) {
1454                      sdsfree(config.hostip);
1455                      config.hostip = sdsnew(argv[1]);
1456                      config.hostport = atoi(argv[2]);
1457                      cliRefreshPrompt();
1458                      cliConnect(CC_FORCE);
1459                  } else if (argc == 1 &amp;&amp; !strcasecmp(argv[0],&quot;clear&quot;)) {
1460                      linenoiseClearScreen();
1461                  } else {
1462                      PORT_LONGLONG start_time = mstime(), elapsed;
1463                      issueCommandRepeat(argc-skipargs, argv+skipargs, repeat);
1464                      if (config.eval_ldb_end) {
1465                          config.eval_ldb_end = 0;
1466                          cliReadReply(0);
1467                          printf(&quot;\n(Lua debugging session ended%s)\n\n&quot;,
1468                              config.eval_ldb_sync ? &quot;&quot; :
1469                              &quot; -- dataset changes rolled back&quot;);
1470                      }
1471                      elapsed = mstime()-start_time;
1472                      if (elapsed &gt;= 500 &amp;&amp;
1473                          config.output == OUTPUT_STANDARD)
1474                      {
1475                          printf(&quot;(%.2fs)\n&quot;,(double)elapsed/1000);
1476                      }
1477                  }
1478              }
1479              sdsfreesplitres(argv,argc);
1480          }
1481          linenoiseFree(line);
1482      }
1483      exit(0);
1484  }
1485  static int noninteractive(int argc, char **argv) {
1486      int retval = 0;
1487      if (config.stdinarg) {
1488          argv = zrealloc(argv, (argc+1)*sizeof(char*));
1489          argv[argc] = readArgFromStdin();
1490          retval = issueCommand(argc+1, argv);
1491      } else {
1492          retval = issueCommand(argc, argv);
1493      }
1494      return retval;
1495  }
1496  static int evalMode(int argc, char **argv) {
1497      sds script = NULL;
1498      FILE *fp;
1499      char buf[1024];
1500      size_t nread;
1501      char **argv2;
1502      int j, got_comma, keys;
1503      int retval = REDIS_OK;
1504      while(1) {
1505          if (config.eval_ldb) {
1506              printf(
1507              &quot;Lua debugging session started, please use:\n&quot;
1508              &quot;quit    -- End the session.\n&quot;
1509              &quot;restart -- Restart the script in debug mode again.\n&quot;
1510              &quot;help    -- Show Lua script debugging commands.\n\n&quot;
1511              );
1512          }
1513          sdsfree(script);
1514          script = sdsempty();
1515          got_comma = 0;
1516          keys = 0;
1517          fp = fopen(config.eval,&quot;r&quot;);
1518          if (!fp) {
1519              fprintf(stderr,
1520                  &quot;Can&#x27;t open file &#x27;%s&#x27;: %s\n&quot;, config.eval, strerror(errno));
1521              exit(1);
1522          }
1523          while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
1524              script = sdscatlen(script,buf,nread);
1525          }
1526          fclose(fp);
1527          if (config.eval_ldb) {
1528              redisReply *reply = redisCommand(context,
1529                      config.eval_ldb_sync ?
1530                      &quot;SCRIPT DEBUG sync&quot;: &quot;SCRIPT DEBUG yes&quot;);
1531              if (reply) freeReplyObject(reply);
1532          }
1533          argv2 = zmalloc(sizeof(sds)*(argc+3));
1534          argv2[0] = sdsnew(&quot;EVAL&quot;);
1535          argv2[1] = script;
1536          for (j = 0; j &lt; argc; j++) {
1537              if (!got_comma &amp;&amp; argv[j][0] == &#x27;,&#x27; &amp;&amp; argv[j][1] == 0) {
1538                  got_comma = 1;
1539                  continue;
1540              }
1541              argv2[j+3-got_comma] = sdsnew(argv[j]);
1542              if (!got_comma) keys++;
1543          }
1544          argv2[2] = sdscatprintf(sdsempty(),&quot;%d&quot;,keys);
1545          int eval_ldb = config.eval_ldb; &amp;bsol;* Save it, may be reverteed. */
1546          retval = issueCommand(argc+3-got_comma, argv2);
1547          if (eval_ldb) {
1548              if (!config.eval_ldb) {
1549                  printf(&quot;Eval debugging session can&#x27;t start:\n&quot;);
1550                  cliReadReply(0);
1551                  break; &amp;bsol;* Return to the caller. */
1552              } else {
1553                  strncpy(config.prompt,&quot;lua debugger&gt; &quot;,sizeof(config.prompt));
1554                  repl();
1555                  cliConnect(CC_FORCE);
1556                  printf(&quot;\n&quot;);
1557              }
1558          } else {
1559              break; &amp;bsol;* Return to the caller. */
1560          }
1561      }
1562      return retval;
1563  }
1564  static struct clusterManager {
1565      list *nodes;    &amp;bsol;* List of nodes in the configuration. */
1566      list *errors;
1567  } cluster_manager;
1568  dict *clusterManagerUncoveredSlots = NULL;
1569  typedef struct clusterManagerNode {
1570      redisContext *context;
1571      sds name;
1572      char *ip;
1573      int port;
1574      uint64_t current_epoch;
1575      time_t ping_sent;
1576      time_t ping_recv;
1577      int flags;
1578      list *flags_str; &amp;bsol;* Flags string representations */
1579      sds replicate;  &amp;bsol;* Master ID if node is a slave */
1580      int dirty;      &amp;bsol;* Node has changes that can be flushed */
1581      uint8_t slots[CLUSTER_MANAGER_SLOTS];
1582      int slots_count;
1583      int replicas_count;
1584      list *friends;
1585      sds *migrating; &amp;bsol;* An array of sds where even strings are slots and odd
1586                       * strings are the destination node IDs. */
1587      sds *importing; &amp;bsol;* An array of sds where even strings are slots and odd
1588                       * strings are the source node IDs. */
1589      int migrating_count; &amp;bsol;* Length of the migrating array (migrating slots*2) */
1590      int importing_count; &amp;bsol;* Length of the importing array (importing slots*2) */
1591      float weight;   &amp;bsol;* Weight used by rebalance */
1592      int balance;    &amp;bsol;* Used by rebalance */
1593  } clusterManagerNode;
1594  typedef struct clusterManagerNodeArray {
1595      clusterManagerNode **nodes; &amp;bsol;* Actual nodes array */
1596      clusterManagerNode **alloc; &amp;bsol;* Pointer to the allocated memory */
1597      int len;                    &amp;bsol;* Actual length of the array */
1598      int count;                  &amp;bsol;* Non-NULL nodes count */
1599  } clusterManagerNodeArray;
1600  typedef struct clusterManagerReshardTableItem {
1601      clusterManagerNode *source;
1602      int slot;
1603  } clusterManagerReshardTableItem;
1604  static dictType clusterManagerDictType = {
1605      dictSdsHash,               &amp;bsol;* hash function */
1606      NULL,                      &amp;bsol;* key dup */
1607      NULL,                      &amp;bsol;* val dup */
1608      dictSdsKeyCompare,         &amp;bsol;* key compare */
1609      NULL,                      &amp;bsol;* key destructor */
1610      dictSdsDestructor          &amp;bsol;* val destructor */
1611  };
1612  typedef int clusterManagerCommandProc(int argc, char **argv);
1613  typedef int (*clusterManagerOnReplyError)(redisReply *reply, int bulk_idx);
1614  static clusterManagerNode *clusterManagerNewNode(char *ip, int port);
1615  static clusterManagerNode *clusterManagerNodeByName(const char *name);
1616  static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char *n);
1617  static void clusterManagerNodeResetSlots(clusterManagerNode *node);
1618  static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err);
1619  static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
1620                                                     char *err);
1621  static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
1622                                        char **err);
1623  static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts);
1624  static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err);
1625  static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
1626      int ip_count, clusterManagerNode ***offending, int *offending_len);
1627  static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
1628      int ip_count);
1629  static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent);
1630  static void clusterManagerShowNodes(void);
1631  static void clusterManagerShowClusterInfo(void);
1632  static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err);
1633  static void clusterManagerWaitForClusterJoin(void);
1634  static int clusterManagerCheckCluster(int quiet);
1635  static void clusterManagerLog(int level, const char* fmt, ...);
1636  static int clusterManagerIsConfigConsistent(void);
1637  static void clusterManagerOnError(sds err);
1638  static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
1639                                          int len);
1640  static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array);
1641  static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
1642                                           clusterManagerNode **nodeptr);
1643  static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
1644                                         clusterManagerNode *node);
1645  static int clusterManagerCommandCreate(int argc, char **argv);
1646  static int clusterManagerCommandAddNode(int argc, char **argv);
1647  static int clusterManagerCommandDeleteNode(int argc, char **argv);
1648  static int clusterManagerCommandInfo(int argc, char **argv);
1649  static int clusterManagerCommandCheck(int argc, char **argv);
1650  static int clusterManagerCommandFix(int argc, char **argv);
1651  static int clusterManagerCommandReshard(int argc, char **argv);
1652  static int clusterManagerCommandRebalance(int argc, char **argv);
1653  static int clusterManagerCommandSetTimeout(int argc, char **argv);
1654  static int clusterManagerCommandImport(int argc, char **argv);
1655  static int clusterManagerCommandCall(int argc, char **argv);
1656  static int clusterManagerCommandHelp(int argc, char **argv);
1657  typedef struct clusterManagerCommandDef {
1658      char *name;
1659      clusterManagerCommandProc *proc;
1660      int arity;
1661      char *args;
1662      char *options;
1663  } clusterManagerCommandDef;
1664  clusterManagerCommandDef clusterManagerCommands[] = {
1665      {&quot;create&quot;, clusterManagerCommandCreate, -2, &quot;host1:port1 ... hostN:portN&quot;,
1666       &quot;replicas &lt;arg&gt;&quot;},
1667      {&quot;check&quot;, clusterManagerCommandCheck, -1, &quot;host:port&quot;,
1668       &quot;search-multiple-owners&quot;},
1669      {&quot;info&quot;, clusterManagerCommandInfo, -1, &quot;host:port&quot;, NULL},
1670      {&quot;fix&quot;, clusterManagerCommandFix, -1, &quot;host:port&quot;,
1671       &quot;search-multiple-owners&quot;},
1672      {&quot;reshard&quot;, clusterManagerCommandReshard, -1, &quot;host:port&quot;,
1673       &quot;from &lt;arg&gt;,to &lt;arg&gt;,slots &lt;arg&gt;,yes,timeout &lt;arg&gt;,pipeline &lt;arg&gt;,&quot;
1674       &quot;replace&quot;},
1675      {&quot;rebalance&quot;, clusterManagerCommandRebalance, -1, &quot;host:port&quot;,
1676       &quot;weight &lt;node1=w1...nodeN=wN&gt;,use-empty-masters,&quot;
1677       &quot;timeout &lt;arg&gt;,simulate,pipeline &lt;arg&gt;,threshold &lt;arg&gt;,replace&quot;},
1678      {&quot;add-node&quot;, clusterManagerCommandAddNode, 2,
1679       &quot;new_host:new_port existing_host:existing_port&quot;, &quot;slave,master-id &lt;arg&gt;&quot;},
1680      {&quot;del-node&quot;, clusterManagerCommandDeleteNode, 2, &quot;host:port node_id&quot;,NULL},
1681      {&quot;call&quot;, clusterManagerCommandCall, -2,
1682          &quot;host:port command arg arg .. arg&quot;, NULL},
1683      {&quot;set-timeout&quot;, clusterManagerCommandSetTimeout, 2,
1684       &quot;host:port milliseconds&quot;, NULL},
1685      {&quot;import&quot;, clusterManagerCommandImport, 1, &quot;host:port&quot;,
1686       &quot;from &lt;arg&gt;,copy,replace&quot;},
1687      {&quot;help&quot;, clusterManagerCommandHelp, 0, NULL, NULL}
1688  };
1689  static void createClusterManagerCommand(char *cmdname, int argc, char **argv) {
1690      clusterManagerCommand *cmd = &amp;config.cluster_manager_command;
1691      cmd-&gt;name = cmdname;
1692      cmd-&gt;argc = argc;
1693      cmd-&gt;argv = argc ? argv : NULL;
1694      if (isColorTerm()) cmd-&gt;flags |= CLUSTER_MANAGER_CMD_FLAG_COLOR;
1695  }
1696  static clusterManagerCommandProc *validateClusterManagerCommand(void) {
1697      int i, commands_count = sizeof(clusterManagerCommands) /
1698                              sizeof(clusterManagerCommandDef);
1699      clusterManagerCommandProc *proc = NULL;
1700      char *cmdname = config.cluster_manager_command.name;
1701      int argc = config.cluster_manager_command.argc;
1702      for (i = 0; i &lt; commands_count; i++) {
1703          clusterManagerCommandDef cmddef = clusterManagerCommands[i];
1704          if (!strcmp(cmddef.name, cmdname)) {
1705              if ((cmddef.arity &gt; 0 &amp;&amp; argc != cmddef.arity) ||
1706                  (cmddef.arity &lt; 0 &amp;&amp; argc &lt; (cmddef.arity * -1))) {
1707                  fprintf(stderr, &quot;[ERR] Wrong number of arguments for &quot;
1708                                  &quot;specified --cluster sub command\n&quot;);
1709                  return NULL;
1710              }
1711              proc = cmddef.proc;
1712          }
1713      }
1714      if (!proc) fprintf(stderr, &quot;Unknown --cluster subcommand\n&quot;);
1715      return proc;
1716  }
1717  static int getClusterHostFromCmdArgs(int argc, char **argv,
1718                                       char **ip_ptr, int *port_ptr) {
1719      int port = 0;
1720      char *ip = NULL;
1721      if (argc == 1) {
1722          char *addr = argv[0];
1723          char *c = strrchr(addr, &#x27;@&#x27;);
1724          if (c != NULL) *c = &#x27;\0&#x27;;
1725          c = strrchr(addr, &#x27;:&#x27;);
1726          if (c != NULL) {
1727              *c = &#x27;\0&#x27;;
1728              ip = addr;
1729              port = atoi(++c);
1730          } else return 0;
1731      } else {
1732          ip = argv[0];
1733          port = atoi(argv[1]);
1734      }
1735      if (!ip || !port) return 0;
1736      else {
1737          *ip_ptr = ip;
1738          *port_ptr = port;
1739      }
1740      return 1;
1741  }
1742  static void freeClusterManagerNodeFlags(list *flags) {
1743      listIter li;
1744      listNode *ln;
1745      listRewind(flags, &amp;li);
1746      while ((ln = listNext(&amp;li)) != NULL) {
1747          sds flag = ln-&gt;value;
1748          sdsfree(flag);
1749      }
1750      listRelease(flags);
1751  }
1752  static void freeClusterManagerNode(clusterManagerNode *node) {
1753      if (node-&gt;context != NULL) redisFree(node-&gt;context);
1754      if (node-&gt;friends != NULL) {
1755          listIter li;
1756          listNode *ln;
1757          listRewind(node-&gt;friends,&amp;li);
1758          while ((ln = listNext(&amp;li)) != NULL) {
1759              clusterManagerNode *fn = ln-&gt;value;
1760              freeClusterManagerNode(fn);
1761          }
1762          listRelease(node-&gt;friends);
1763          node-&gt;friends = NULL;
1764      }
1765      if (node-&gt;name != NULL) sdsfree(node-&gt;name);
1766      if (node-&gt;replicate != NULL) sdsfree(node-&gt;replicate);
1767      if ((node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_FRIEND) &amp;&amp; node-&gt;ip)
1768          sdsfree(node-&gt;ip);
1769      int i;
1770      if (node-&gt;migrating != NULL) {
1771          for (i = 0; i &lt; node-&gt;migrating_count; i++) sdsfree(node-&gt;migrating[i]);
1772          zfree(node-&gt;migrating);
1773      }
1774      if (node-&gt;importing != NULL) {
1775          for (i = 0; i &lt; node-&gt;importing_count; i++) sdsfree(node-&gt;importing[i]);
1776          zfree(node-&gt;importing);
1777      }
1778      if (node-&gt;flags_str != NULL) {
1779          freeClusterManagerNodeFlags(node-&gt;flags_str);
1780          node-&gt;flags_str = NULL;
1781      }
1782      zfree(node);
1783  }
1784  static void freeClusterManager(void) {
<span onclick='openModal()' class='match'>1785      listIter li;
1786      listNode *ln;
1787      if (cluster_manager.nodes != NULL) {
1788          listRewind(cluster_manager.nodes,&amp;li);
1789          while ((ln = listNext(&amp;li)) != NULL) {
</span>1790              clusterManagerNode *n = ln-&gt;value;
1791              freeClusterManagerNode(n);
1792          }
1793          listRelease(cluster_manager.nodes);
1794          cluster_manager.nodes = NULL;
1795      }
1796      if (cluster_manager.errors != NULL) {
1797          listRewind(cluster_manager.errors,&amp;li);
1798          while ((ln = listNext(&amp;li)) != NULL) {
1799              sds err = ln-&gt;value;
1800              sdsfree(err);
1801          }
1802          listRelease(cluster_manager.errors);
1803          cluster_manager.errors = NULL;
1804      }
1805      if (clusterManagerUncoveredSlots != NULL)
1806          dictRelease(clusterManagerUncoveredSlots);
1807  }
1808  static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
1809      clusterManagerNode *node = zmalloc(sizeof(*node));
1810      node-&gt;context = NULL;
1811      node-&gt;name = NULL;
1812      node-&gt;ip = ip;
1813      node-&gt;port = port;
1814      node-&gt;current_epoch = 0;
1815      node-&gt;ping_sent = 0;
1816      node-&gt;ping_recv = 0;
1817      node-&gt;flags = 0;
1818      node-&gt;flags_str = NULL;
1819      node-&gt;replicate = NULL;
1820      node-&gt;dirty = 0;
1821      node-&gt;friends = NULL;
1822      node-&gt;migrating = NULL;
1823      node-&gt;importing = NULL;
1824      node-&gt;migrating_count = 0;
1825      node-&gt;importing_count = 0;
1826      node-&gt;replicas_count = 0;
1827      node-&gt;weight = 1.0f;
1828      node-&gt;balance = 0;
1829      clusterManagerNodeResetSlots(node);
1830      return node;
1831  }
1832  static int clusterManagerCheckRedisReply(clusterManagerNode *n,
1833                                           redisReply *r, char **err)
1834  {
1835      int is_err = 0;
1836      if (!r || (is_err = (r-&gt;type == REDIS_REPLY_ERROR))) {
1837          if (is_err) {
1838              if (err != NULL) {
1839                  *err = zmalloc((r-&gt;len + 1) * sizeof(char));
1840                  strcpy(*err, r-&gt;str);
1841              } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r-&gt;str);
1842          }
1843          return 0;
1844      }
1845      return 1;
1846  }
1847  static int clusterManagerStartTransaction(clusterManagerNode *node) {
1848      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;MULTI&quot;);
1849      int success = clusterManagerCheckRedisReply(node, reply, NULL);
1850      if (reply) freeReplyObject(reply);
1851      return success;
1852  }
1853  static int clusterManagerExecTransaction(clusterManagerNode *node,
1854                                           clusterManagerOnReplyError onerror)
1855  {
1856      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;EXEC&quot;);
1857      int success = clusterManagerCheckRedisReply(node, reply, NULL);
1858      if (success) {
1859          if (reply-&gt;type != REDIS_REPLY_ARRAY) {
1860              success = 0;
1861              goto cleanup;
1862          }
1863          size_t i;
1864          for (i = 0; i &lt; reply-&gt;elements; i++) {
1865              redisReply *r = reply-&gt;element[i];
1866              char *err = NULL;
1867              success = clusterManagerCheckRedisReply(node, r, &amp;err);
1868              if (!success &amp;&amp; onerror) success = onerror(r, i);
1869              if (err) {
1870                  if (!success)
1871                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
1872                  zfree(err);
1873              }
1874              if (!success) break;
1875          }
1876      }
1877  cleanup:
1878      if (reply) freeReplyObject(reply);
1879      return success;
1880  }
1881  static int clusterManagerNodeConnect(clusterManagerNode *node) {
1882      if (node-&gt;context) redisFree(node-&gt;context);
1883      node-&gt;context = redisConnect(node-&gt;ip, node-&gt;port);
1884      if (node-&gt;context-&gt;err) {
1885          fprintf(stderr,&quot;Could not connect to Redis at &quot;);
1886          fprintf(stderr,&quot;%s:%d: %s\n&quot;, node-&gt;ip, node-&gt;port,
1887                  node-&gt;context-&gt;errstr);
1888          redisFree(node-&gt;context);
1889          node-&gt;context = NULL;
1890          return 0;
1891      }
1892      anetKeepAlive(NULL, node-&gt;context-&gt;fd, REDIS_CLI_KEEPALIVE_INTERVAL);
1893      if (config.auth) {
1894          redisReply *reply = redisCommand(node-&gt;context,&quot;AUTH %s&quot;,config.auth);
1895          int ok = clusterManagerCheckRedisReply(node, reply, NULL);
1896          if (reply != NULL) freeReplyObject(reply);
1897          if (!ok) return 0;
1898      }
1899      return 1;
1900  }
1901  static void clusterManagerRemoveNodeFromList(list *nodelist,
1902                                               clusterManagerNode *node) {
1903      listIter li;
1904      listNode *ln;
1905      listRewind(nodelist, &amp;li);
1906      while ((ln = listNext(&amp;li)) != NULL) {
1907          if (node == ln-&gt;value) {
1908              listDelNode(nodelist, ln);
1909              break;
1910          }
1911      }
1912  }
1913  static clusterManagerNode *clusterManagerNodeByName(const char *name) {
1914      if (cluster_manager.nodes == NULL) return NULL;
1915      clusterManagerNode *found = NULL;
1916      sds lcname = sdsempty();
1917      lcname = sdscpy(lcname, name);
1918      sdstolower(lcname);
1919      listIter li;
1920      listNode *ln;
1921      listRewind(cluster_manager.nodes, &amp;li);
1922      while ((ln = listNext(&amp;li)) != NULL) {
1923          clusterManagerNode *n = ln-&gt;value;
1924          if (n-&gt;name &amp;&amp; !sdscmp(n-&gt;name, lcname)) {
1925              found = n;
1926              break;
1927          }
1928      }
1929      sdsfree(lcname);
1930      return found;
1931  }
1932  static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
1933  {
1934      if (cluster_manager.nodes == NULL) return NULL;
1935      clusterManagerNode *found = NULL;
1936      sds lcname = sdsempty();
1937      lcname = sdscpy(lcname, name);
1938      sdstolower(lcname);
1939      listIter li;
1940      listNode *ln;
1941      listRewind(cluster_manager.nodes, &amp;li);
1942      while ((ln = listNext(&amp;li)) != NULL) {
1943          clusterManagerNode *n = ln-&gt;value;
1944          if (n-&gt;name &amp;&amp;
1945              strstr(n-&gt;name, lcname) == n-&gt;name) {
1946              found = n;
1947              break;
1948          }
1949      }
1950      sdsfree(lcname);
1951      return found;
1952  }
1953  static void clusterManagerNodeResetSlots(clusterManagerNode *node) {
1954      memset(node-&gt;slots, 0, sizeof(node-&gt;slots));
1955      node-&gt;slots_count = 0;
1956  }
1957  static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
1958                                                    char **err)
1959  {
1960      redisReply *info = CLUSTER_MANAGER_COMMAND(node, &quot;INFO&quot;);
1961      if (err != NULL) *err = NULL;
1962      if (info == NULL) return NULL;
1963      if (info-&gt;type == REDIS_REPLY_ERROR) {
1964          if (err != NULL) {
1965              *err = zmalloc((info-&gt;len + 1) * sizeof(char));
1966              strcpy(*err, info-&gt;str);
1967          }
1968          freeReplyObject(info);
1969          return  NULL;
1970      }
1971      return info;
1972  }
1973  static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
1974      redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
1975      if (info == NULL) return 0;
1976      int is_cluster = (int) getLongInfoField(info-&gt;str, &quot;cluster_enabled&quot;);
1977      freeReplyObject(info);
1978      return is_cluster;
1979  }
1980  static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
1981      redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
1982      int is_empty = 1;
1983      if (info == NULL) return 0;
1984      if (strstr(info-&gt;str, &quot;db0:&quot;) != NULL) {
1985          is_empty = 0;
1986          goto result;
1987      }
1988      freeReplyObject(info);
1989      info = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER INFO&quot;);
1990      if (err != NULL) *err = NULL;
1991      if (!clusterManagerCheckRedisReply(node, info, err)) {
1992          is_empty = 0;
1993          goto result;
1994      }
1995      PORT_LONG known_nodes = getLongInfoField(info-&gt;str, &quot;cluster_known_nodes&quot;);
1996      is_empty = (known_nodes == 1);
1997  result:
1998      freeReplyObject(info);
1999      return is_empty;
2000  }
2001  static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
2002      int ip_count, clusterManagerNode ***offending, int *offending_len)
2003  {
2004      int score = 0, i, j;
2005      int node_len = cluster_manager.nodes-&gt;len;
2006      clusterManagerNode **offending_p = NULL;
2007      if (offending != NULL) {
2008          *offending = zcalloc(node_len * sizeof(clusterManagerNode*));
2009          offending_p = *offending;
2010      }
2011      for (i = 0; i &lt; ip_count; i++) {
2012          clusterManagerNodeArray *node_array = &amp;(ipnodes[i]);
2013          dict *related = dictCreate(&amp;clusterManagerDictType, NULL);
2014          char *ip = NULL;
2015          for (j = 0; j &lt; node_array-&gt;len; j++) {
2016              clusterManagerNode *node = node_array-&gt;nodes[j];
2017              if (node == NULL) continue;
2018              if (!ip) ip = node-&gt;ip;
2019              sds types;
2020              sds key = (!node-&gt;replicate ? node-&gt;name : node-&gt;replicate);
2021              assert(key != NULL);
2022              dictEntry *entry = dictFind(related, key);
2023              if (entry) types = sdsdup((sds) dictGetVal(entry));
2024              else types = sdsempty();
2025              if (!node-&gt;replicate) types = sdscatprintf(types, &quot;m%s&quot;, types);
2026              else types = sdscat(types, &quot;s&quot;);
2027              dictReplace(related, key, types);
2028          }
2029          dictIterator *iter = dictGetIterator(related);
2030          dictEntry *entry;
2031          while ((entry = dictNext(iter)) != NULL) {
2032              sds types = (sds) dictGetVal(entry);
2033              sds name = (sds) dictGetKey(entry);
2034              int typeslen = sdslen(types);
2035              if (typeslen &lt; 2) continue;
2036              if (types[0] == &#x27;m&#x27;) score += (10000 * (typeslen - 1));
2037              else score += (1 * typeslen);
2038              if (offending == NULL) continue;
2039              listIter li;
2040              listNode *ln;
2041              listRewind(cluster_manager.nodes, &amp;li);
2042              while ((ln = listNext(&amp;li)) != NULL) {
2043                  clusterManagerNode *n = ln-&gt;value;
2044                  if (n-&gt;replicate == NULL) continue;
2045                  if (!strcmp(n-&gt;replicate, name) &amp;&amp; !strcmp(n-&gt;ip, ip)) {
2046                      *(offending_p++) = n;
2047                      if (offending_len != NULL) (*offending_len)++;
2048                      break;
2049                  }
2050              }
2051          }
2052          dictReleaseIterator(iter);
2053          dictRelease(related);
2054      }
2055      return score;
2056  }
2057  static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
2058      int ip_count)
2059  {
2060      clusterManagerNode **offenders = NULL;
2061      int score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count,
2062                                                     NULL, NULL);
2063      if (score == 0) goto cleanup;
2064      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Trying to optimize slaves allocation &quot;
2065                            &quot;for anti-affinity\n&quot;);
2066      int node_len = cluster_manager.nodes-&gt;len;
2067      int maxiter = 500 * node_len; 
2068      srand(time(NULL));
2069      while (maxiter &gt; 0) {
2070          int offending_len = 0;
2071          if (offenders != NULL) {
2072              zfree(offenders);
2073              offenders = NULL;
2074          }
2075          score = clusterManagerGetAntiAffinityScore(ipnodes,
2076                                                     ip_count,
2077                                                     &amp;offenders,
2078                                                     &amp;offending_len);
2079          if (score == 0) break; 
2080          int rand_idx = rand() % offending_len;
2081          clusterManagerNode *first = offenders[rand_idx],
2082                             *second = NULL;
2083          clusterManagerNode **other_replicas = zcalloc((node_len - 1) *
2084                                                        sizeof(*other_replicas));
2085          int other_replicas_count = 0;
2086          listIter li;
2087          listNode *ln;
2088          listRewind(cluster_manager.nodes, &amp;li);
2089          while ((ln = listNext(&amp;li)) != NULL) {
2090              clusterManagerNode *n = ln-&gt;value;
2091              if (n != first &amp;&amp; n-&gt;replicate != NULL)
2092                  other_replicas[other_replicas_count++] = n;
2093          }
2094          if (other_replicas_count == 0) {
2095              zfree(other_replicas);
2096              break;
2097          }
2098          rand_idx = rand() % other_replicas_count;
2099          second = other_replicas[rand_idx];
2100          char *first_master = first-&gt;replicate,
2101               *second_master = second-&gt;replicate;
2102          first-&gt;replicate = second_master, first-&gt;dirty = 1;
2103          second-&gt;replicate = first_master, second-&gt;dirty = 1;
2104          int new_score = clusterManagerGetAntiAffinityScore(ipnodes,
2105                                                             ip_count,
2106                                                             NULL, NULL);
2107          if (new_score &gt; score) {
2108              first-&gt;replicate = first_master;
2109              second-&gt;replicate = second_master;
2110          }
2111          zfree(other_replicas);
2112          maxiter--;
2113      }
2114      score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count, NULL, NULL);
2115      char *msg;
2116      int perfect = (score == 0);
2117      int log_level = (perfect ? CLUSTER_MANAGER_LOG_LVL_SUCCESS :
2118                                 CLUSTER_MANAGER_LOG_LVL_WARN);
2119      if (perfect) msg = &quot;[OK] Perfect anti-affinity obtained!&quot;;
2120      else if (score &gt;= 10000)
2121          msg = (&quot;[WARNING] Some slaves are in the same host as their master&quot;);
2122      else
2123          msg=(&quot;[WARNING] Some slaves of the same master are in the same host&quot;);
2124      clusterManagerLog(log_level, &quot;%s\n&quot;, msg);
2125  cleanup:
2126      zfree(offenders);
2127  }
2128  static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
2129      sds flags = sdsempty();
2130      if (!node-&gt;flags_str) return flags;
2131      int empty = 1;
2132      listIter li;
2133      listNode *ln;
2134      listRewind(node-&gt;flags_str, &amp;li);
2135      while ((ln = listNext(&amp;li)) != NULL) {
2136          sds flag = ln-&gt;value;
2137          if (strcmp(flag, &quot;myself&quot;) == 0) continue;
2138          if (!empty) flags = sdscat(flags, &quot;,&quot;);
2139          flags = sdscatfmt(flags, &quot;%S&quot;, flag);
2140          empty = 0;
2141      }
2142      return flags;
2143  }
2144  static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
2145      sds slots = sdsempty();
2146      int first_range_idx = -1, last_slot_idx = -1, i;
2147      for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
2148          int has_slot = node-&gt;slots[i];
2149          if (has_slot) {
2150              if (first_range_idx == -1) {
2151                  if (sdslen(slots)) slots = sdscat(slots, &quot;,&quot;);
2152                  first_range_idx = i;
2153                  slots = sdscatfmt(slots, &quot;[%u&quot;, i);
2154              }
2155              last_slot_idx = i;
2156          } else {
2157              if (last_slot_idx &gt;= 0) {
2158                  if (first_range_idx == last_slot_idx)
2159                      slots = sdscat(slots, &quot;]&quot;);
2160                  else slots = sdscatfmt(slots, &quot;-%u]&quot;, last_slot_idx);
2161              }
2162              last_slot_idx = -1;
2163              first_range_idx = -1;
2164          }
2165      }
2166      if (last_slot_idx &gt;= 0) {
2167          if (first_range_idx == last_slot_idx) slots = sdscat(slots, &quot;]&quot;);
2168          else slots = sdscatfmt(slots, &quot;-%u]&quot;, last_slot_idx);
2169      }
2170      return slots;
2171  }
2172  static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
2173      int s, e; &amp;bsol;* start-end indexes of { and } */
2174      for (s = 0; s &lt; keylen; s++)
2175          if (key[s] == &#x27;{&#x27;) break;
2176      if (s == keylen) return crc16(key,keylen) &amp; 0x3FFF;
2177      for (e = s+1; e &lt; keylen; e++)
2178          if (key[e] == &#x27;}&#x27;) break;
2179      if (e == keylen || e == s+1) return crc16(key,keylen) &amp; 0x3FFF;
2180      return crc16(key+s+1,e-s-1) &amp; 0x3FFF;
2181  }
2182  static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
2183      sds info = sdsempty();
2184      sds spaces = sdsempty();
2185      int i;
2186      for (i = 0; i &lt; indent; i++) spaces = sdscat(spaces, &quot; &quot;);
2187      if (indent) info = sdscat(info, spaces);
2188      int is_master = !(node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE);
2189      char *role = (is_master ? &quot;M&quot; : &quot;S&quot;);
2190      sds slots = NULL;
2191      if (node-&gt;dirty &amp;&amp; node-&gt;replicate != NULL)
2192          info = sdscatfmt(info, &quot;S: %S %s:%u&quot;, node-&gt;name, node-&gt;ip, node-&gt;port);
2193      else {
2194          slots = clusterManagerNodeSlotsString(node);
2195          sds flags = clusterManagerNodeFlagString(node);
2196          info = sdscatfmt(info, &quot;%s: %S %s:%u\n&quot;
2197                                 &quot;%s   slots:%S (%u slots) &quot;
2198                                 &quot;%S&quot;,
2199                                 role, node-&gt;name, node-&gt;ip, node-&gt;port, spaces,
2200                                 slots, node-&gt;slots_count, flags);
2201          sdsfree(slots);
2202          sdsfree(flags);
2203      }
2204      if (node-&gt;replicate != NULL)
2205          info = sdscatfmt(info, &quot;\n%s   replicates %S&quot;, spaces, node-&gt;replicate);
2206      else if (node-&gt;replicas_count)
2207          info = sdscatfmt(info, &quot;\n%s   %U additional replica(s)&quot;,
2208                           spaces, node-&gt;replicas_count);
2209      sdsfree(spaces);
2210      return info;
2211  }
2212  static void clusterManagerShowNodes(void) {
2213      listIter li;
2214      listNode *ln;
2215      listRewind(cluster_manager.nodes, &amp;li);
2216      while ((ln = listNext(&amp;li)) != NULL) {
2217          clusterManagerNode *node = ln-&gt;value;
2218          sds info = clusterManagerNodeInfo(node, 0);
2219          printf(&quot;%s\n&quot;, (char *) info);
2220          sdsfree(info);
2221      }
2222  }
2223  static void clusterManagerShowClusterInfo(void) {
2224      int masters = 0;
2225      int keys = 0;
2226      listIter li;
2227      listNode *ln;
2228      listRewind(cluster_manager.nodes, &amp;li);
2229      while ((ln = listNext(&amp;li)) != NULL) {
2230          clusterManagerNode *node = ln-&gt;value;
2231          if (!(node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE)) {
2232              if (!node-&gt;name) continue;
2233              int replicas = 0;
2234              int dbsize = -1;
2235              char name[9];
2236              memcpy(name, node-&gt;name, 8);
2237              name[8] = &#x27;\0&#x27;;
2238              listIter ri;
2239              listNode *rn;
2240              listRewind(cluster_manager.nodes, &amp;ri);
2241              while ((rn = listNext(&amp;ri)) != NULL) {
2242                  clusterManagerNode *n = rn-&gt;value;
2243                  if (n == node || !(n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE))
2244                      continue;
2245                  if (n-&gt;replicate &amp;&amp; !strcmp(n-&gt;replicate, node-&gt;name))
2246                      replicas++;
2247              }
2248              redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;DBSIZE&quot;);
2249              if (reply != NULL || reply-&gt;type == REDIS_REPLY_INTEGER)
2250                  dbsize = reply-&gt;integer;
2251              if (dbsize &lt; 0) {
2252                  char *err = &quot;&quot;;
2253                  if (reply != NULL &amp;&amp; reply-&gt;type == REDIS_REPLY_ERROR)
2254                      err = reply-&gt;str;
2255                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
2256                  if (reply != NULL) freeReplyObject(reply);
2257                  return;
2258              };
2259              if (reply != NULL) freeReplyObject(reply);
2260              printf(&quot;%s:%d (%s...) -&gt; %d keys | %d slots | %d slaves.\n&quot;,
2261                     node-&gt;ip, node-&gt;port, name, dbsize,
2262                     node-&gt;slots_count, replicas);
2263              masters++;
2264              keys += dbsize;
2265          }
2266      }
2267      clusterManagerLogOk(&quot;[OK] %d keys in %d masters.\n&quot;, keys, masters);
2268      float keys_per_slot = keys / (float) CLUSTER_MANAGER_SLOTS;
2269      printf(&quot;%.2f keys per slot on average.\n&quot;, keys_per_slot);
2270  }
2271  static int clusterManagerAddSlots(clusterManagerNode *node, char**err)
2272  {
2273      redisReply *reply = NULL;
2274      void *_reply = NULL;
2275      int success = 1;
2276      int argc = node-&gt;slots_count + 2;
2277      sds *argv = zmalloc(argc * sizeof(*argv));
2278      size_t *argvlen = zmalloc(argc * sizeof(*argvlen));
2279      argv[0] = &quot;CLUSTER&quot;;
2280      argv[1] = &quot;ADDSLOTS&quot;;
2281      argvlen[0] = 7;
2282      argvlen[1] = 8;
2283      *err = NULL;
2284      int i, argv_idx = 2;
2285      for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
2286          if (argv_idx &gt;= argc) break;
2287          if (node-&gt;slots[i]) {
2288              argv[argv_idx] = sdsfromlonglong((PORT_LONGLONG) i);
2289              argvlen[argv_idx] = sdslen(argv[argv_idx]);
2290              argv_idx++;
2291          }
2292      }
2293      if (!argv_idx) {
2294          success = 0;
2295          goto cleanup;
2296      }
2297      redisAppendCommandArgv(node-&gt;context,argc,(const char**)argv,argvlen);
2298      if (redisGetReply(node-&gt;context, &amp;_reply) != REDIS_OK) {
2299          success = 0;
2300          goto cleanup;
2301      }
2302      reply = (redisReply*) _reply;
2303      success = clusterManagerCheckRedisReply(node, reply, err);
2304  cleanup:
2305      zfree(argvlen);
2306      if (argv != NULL) {
2307          for (i = 2; i &lt; argc; i++) sdsfree(argv[i]);
2308          zfree(argv);
2309      }
2310      if (reply != NULL) freeReplyObject(reply);
2311      return success;
2312  }
2313  static int clusterManagerSetSlot(clusterManagerNode *node1,
2314                                   clusterManagerNode *node2,
2315                                   int slot, const char *status, char **err) {
2316      redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, &quot;CLUSTER &quot;
2317                                                  &quot;SETSLOT %d %s %s&quot;,
2318                                                  slot, status,
2319                                                  (char *) node2-&gt;name);
2320      if (err != NULL) *err = NULL;
2321      if (!reply) return 0;
2322      int success = 1;
2323      if (reply-&gt;type == REDIS_REPLY_ERROR) {
2324          success = 0;
2325          if (err != NULL) {
2326              *err = zmalloc((reply-&gt;len + 1) * sizeof(char));
2327              strcpy(*err, reply-&gt;str);
2328          } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(node1, reply-&gt;str);
2329          goto cleanup;
2330      }
2331  cleanup:
2332      freeReplyObject(reply);
2333      return success;
2334  }
2335  static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
2336      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2337          &quot;CLUSTER SETSLOT %d %s&quot;, slot, &quot;STABLE&quot;);
2338      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2339      if (reply) freeReplyObject(reply);
2340      return success;
2341  }
2342  static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
2343                                   int ignore_unassigned_err)
2344  {
2345      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2346          &quot;CLUSTER DELSLOTS %d&quot;, slot);
2347      char *err = NULL;
2348      int success = clusterManagerCheckRedisReply(node, reply, &amp;err);
2349      if (!success &amp;&amp; reply &amp;&amp; reply-&gt;type == REDIS_REPLY_ERROR &amp;&amp;
2350          ignore_unassigned_err &amp;&amp;
2351          strstr(reply-&gt;str, &quot;already unassigned&quot;) != NULL) success = 1;
2352      if (!success &amp;&amp; err != NULL) {
2353          CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
2354          zfree(err);
2355      }
2356      if (reply) freeReplyObject(reply);
2357      return success;
2358  }
2359  static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
2360      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2361          &quot;CLUSTER ADDSLOTS %d&quot;, slot);
2362      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2363      if (reply) freeReplyObject(reply);
2364      return success;
2365  }
2366  static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
2367                                                  int slot)
2368  {
2369      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2370          &quot;CLUSTER COUNTKEYSINSLOT %d&quot;, slot);
2371      int count = -1;
2372      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2373      if (success &amp;&amp; reply-&gt;type == REDIS_REPLY_INTEGER) count = reply-&gt;integer;
2374      if (reply) freeReplyObject(reply);
2375      return count;
2376  }
2377  static int clusterManagerBumpEpoch(clusterManagerNode *node) {
2378      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER BUMPEPOCH&quot;);
2379      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2380      if (reply) freeReplyObject(reply);
2381      return success;
2382  }
2383  static int clusterManagerIgnoreUnassignedErr(redisReply *reply, int bulk_idx) {
2384      if (bulk_idx == 0 &amp;&amp; reply) {
2385          if (reply-&gt;type == REDIS_REPLY_ERROR)
2386              return strstr(reply-&gt;str, &quot;already unassigned&quot;) != NULL;
2387      }
2388      return 0;
2389  }
2390  static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
2391                                        int slot,
2392                                        int do_clear)
2393  {
2394      int success = clusterManagerStartTransaction(owner);
2395      if (!success) return 0;
2396      clusterManagerDelSlot(owner, slot, 1);
2397      clusterManagerAddSlot(owner, slot);
2398      if (do_clear) clusterManagerClearSlotStatus(owner, slot);
2399      clusterManagerBumpEpoch(owner);
2400      success = clusterManagerExecTransaction(owner,
2401          clusterManagerIgnoreUnassignedErr);
2402      return success;
2403  }
2404  static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
2405                                                      clusterManagerNode *target,
2406                                                      redisReply *reply,
2407                                                      int replace, int timeout,
2408                                                      char *dots)
2409  {
2410      redisReply *migrate_reply = NULL;
2411      char **argv = NULL;
2412      size_t *argv_len = NULL;
2413      int c = (replace ? 8 : 7);
2414      if (config.auth) c += 2;
2415      size_t argc = c + reply-&gt;elements;
2416      size_t i, offset = 6; 
2417      argv = zcalloc(argc * sizeof(char *));
2418      argv_len = zcalloc(argc * sizeof(size_t));
2419      char portstr[255];
2420      char timeoutstr[255];
2421      snprintf(portstr, 10, &quot;%d&quot;, target-&gt;port);
2422      snprintf(timeoutstr, 10, &quot;%d&quot;, timeout);
2423      argv[0] = &quot;MIGRATE&quot;;
2424      argv_len[0] = 7;
2425      argv[1] = target-&gt;ip;
2426      argv_len[1] = strlen(target-&gt;ip);
2427      argv[2] = portstr;
2428      argv_len[2] = strlen(portstr);
2429      argv[3] = &quot;&quot;;
2430      argv_len[3] = 0;
2431      argv[4] = &quot;0&quot;;
2432      argv_len[4] = 1;
2433      argv[5] = timeoutstr;
2434      argv_len[5] = strlen(timeoutstr);
2435      if (replace) {
2436          argv[offset] = &quot;REPLACE&quot;;
2437          argv_len[offset] = 7;
2438          offset++;
2439      }
2440      if (config.auth) {
2441          argv[offset] = &quot;AUTH&quot;;
2442          argv_len[offset] = 4;
2443          offset++;
2444          argv[offset] = config.auth;
2445          argv_len[offset] = strlen(config.auth);
2446          offset++;
2447      }
2448      argv[offset] = &quot;KEYS&quot;;
2449      argv_len[offset] = 4;
2450      offset++;
2451      for (i = 0; i &lt; reply-&gt;elements; i++) {
2452          redisReply *entry = reply-&gt;element[i];
2453          size_t idx = i + offset;
2454          assert(entry-&gt;type == REDIS_REPLY_STRING);
2455          argv[idx] = (char *) sdsnew(entry-&gt;str);
2456          argv_len[idx] = entry-&gt;len;
2457          if (dots) dots[i] = &#x27;.&#x27;;
2458      }
2459      if (dots) dots[reply-&gt;elements] = &#x27;\0&#x27;;
2460      void *_reply = NULL;
2461      redisAppendCommandArgv(source-&gt;context,argc,
2462                             (const char**)argv,argv_len);
2463      int success = (redisGetReply(source-&gt;context, &amp;_reply) == REDIS_OK);
2464      for (i = 0; i &lt; reply-&gt;elements; i++) sdsfree(argv[i + offset]);
2465      if (!success) goto cleanup;
2466      migrate_reply = (redisReply *) _reply;
2467  cleanup:
2468      zfree(argv);
2469      zfree(argv_len);
2470      return migrate_reply;
2471  }
2472  static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
2473                                             clusterManagerNode *target,
2474                                             int slot, int timeout,
2475                                             int pipeline, int verbose,
2476                                             char **err)
2477  {
2478      int success = 1;
2479      int replace_existing_keys = (config.cluster_manager_command.flags &amp;
2480              (CLUSTER_MANAGER_CMD_FLAG_FIX | CLUSTER_MANAGER_CMD_FLAG_REPLACE));
2481      while (1) {
2482          char *dots = NULL;
2483          redisReply *reply = NULL, *migrate_reply = NULL;
2484          reply = CLUSTER_MANAGER_COMMAND(source, &quot;CLUSTER &quot;
2485                                          &quot;GETKEYSINSLOT %d %d&quot;, slot,
2486                                          pipeline);
2487          success = (reply != NULL);
2488          if (!success) return 0;
2489          if (reply-&gt;type == REDIS_REPLY_ERROR) {
2490              success = 0;
2491              if (err != NULL) {
2492                  *err = zmalloc((reply-&gt;len + 1) * sizeof(char));
2493                  strcpy(*err, reply-&gt;str);
2494                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(source, *err);
2495              }
2496              goto next;
2497          }
2498          assert(reply-&gt;type == REDIS_REPLY_ARRAY);
2499          size_t count = reply-&gt;elements;
2500          if (count == 0) {
2501              freeReplyObject(reply);
2502              break;
2503          }
2504          if (verbose) dots = zmalloc((count+1) * sizeof(char));
2505          migrate_reply = clusterManagerMigrateKeysInReply(source, target,
2506                                                           reply, 0, timeout,
2507                                                           dots);
2508          if (migrate_reply == NULL) goto next;
2509          if (migrate_reply-&gt;type == REDIS_REPLY_ERROR) {
2510              int is_busy = strstr(migrate_reply-&gt;str, &quot;BUSYKEY&quot;) != NULL;
2511              int not_served = strstr(migrate_reply-&gt;str, &quot;slot not served&quot;) != NULL;
2512              if (replace_existing_keys &amp;&amp; (is_busy || not_served)) {
2513                  if (not_served)
2514                      clusterManagerSetSlot(source, target, slot, &quot;node&quot;, NULL);
2515                  clusterManagerLogWarn(&quot;*** Target key exists. &quot;
2516                                        &quot;Replacing it for FIX.\n&quot;);
2517                  freeReplyObject(migrate_reply);
2518                  migrate_reply = clusterManagerMigrateKeysInReply(source,
2519                                                                   target,
2520                                                                   reply,
2521                                                                   is_busy,
2522                                                                   timeout,
2523                                                                   NULL);
2524                  success = (migrate_reply != NULL &amp;&amp;
2525                             migrate_reply-&gt;type != REDIS_REPLY_ERROR);
2526              } else success = 0;
2527              if (!success) {
2528                  if (migrate_reply != NULL) {
2529                      if (err) {
2530                          *err = zmalloc((migrate_reply-&gt;len + 1) * sizeof(char));
2531                          strcpy(*err, migrate_reply-&gt;str);
2532                      }
2533                      printf(&quot;\n&quot;);
2534                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(source,
2535                                                        migrate_reply-&gt;str);
2536                  }
2537                  goto next;
2538              }
2539          }
2540          if (verbose) {
2541              printf(&quot;%s&quot;, dots);
2542              fflush(stdout);
2543          }
2544  next:
2545          if (reply != NULL) freeReplyObject(reply);
2546          if (migrate_reply != NULL) freeReplyObject(migrate_reply);
2547          if (dots) zfree(dots);
2548          if (!success) break;
2549      }
2550      return success;
2551  }
2552  static int clusterManagerMoveSlot(clusterManagerNode *source,
2553                                    clusterManagerNode *target,
2554                                    int slot, int opts,  char**err)
2555  {
2556      if (!(opts &amp; CLUSTER_MANAGER_OPT_QUIET)) {
2557          printf(&quot;Moving slot %d from %s:%d to %s:%d: &quot;, slot, source-&gt;ip,
2558                 source-&gt;port, target-&gt;ip, target-&gt;port);
2559          fflush(stdout);
2560      }
2561      if (err != NULL) *err = NULL;
2562      int pipeline = config.cluster_manager_command.pipeline,
2563          timeout = config.cluster_manager_command.timeout,
2564          print_dots = (opts &amp; CLUSTER_MANAGER_OPT_VERBOSE),
2565          option_cold = (opts &amp; CLUSTER_MANAGER_OPT_COLD),
2566          success = 1;
2567      if (!option_cold) {
2568          success = clusterManagerSetSlot(target, source, slot,
2569                                          &quot;importing&quot;, err);
2570          if (!success) return 0;
2571          success = clusterManagerSetSlot(source, target, slot,
2572                                          &quot;migrating&quot;, err);
2573          if (!success) return 0;
2574      }
2575      success = clusterManagerMigrateKeysInSlot(source, target, slot, timeout,
2576                                                pipeline, print_dots, err);
2577      if (!(opts &amp; CLUSTER_MANAGER_OPT_QUIET)) printf(&quot;\n&quot;);
2578      if (!success) return 0;
2579      if (!option_cold) {
2580          listIter li;
2581          listNode *ln;
2582          listRewind(cluster_manager.nodes, &amp;li);
2583          while ((ln = listNext(&amp;li)) != NULL) {
2584              clusterManagerNode *n = ln-&gt;value;
2585              if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
2586              redisReply *r = CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER &quot;
2587                                                      &quot;SETSLOT %d %s %s&quot;,
2588                                                      slot, &quot;node&quot;,
2589                                                      target-&gt;name);
2590              success = (r != NULL);
2591              if (!success) return 0;
2592              if (r-&gt;type == REDIS_REPLY_ERROR) {
2593                  success = 0;
2594                  if (err != NULL) {
2595                      *err = zmalloc((r-&gt;len + 1) * sizeof(char));
2596                      strcpy(*err, r-&gt;str);
2597                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, *err);
2598                  }
2599              }
2600              freeReplyObject(r);
2601              if (!success) return 0;
2602          }
2603      }
2604      if (opts &amp; CLUSTER_MANAGER_OPT_UPDATE) {
2605          source-&gt;slots[slot] = 0;
2606          target-&gt;slots[slot] = 1;
2607      }
2608      return 1;
2609  }
2610  static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
2611      if (!node-&gt;dirty) return 0;
2612      redisReply *reply = NULL;
2613      int is_err = 0, success = 1;
2614      if (err != NULL) *err = NULL;
2615      if (node-&gt;replicate != NULL) {
2616          reply = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER REPLICATE %s&quot;,
2617                                          node-&gt;replicate);
2618          if (reply == NULL || (is_err = (reply-&gt;type == REDIS_REPLY_ERROR))) {
2619              if (is_err &amp;&amp; err != NULL) {
2620                  *err = zmalloc((reply-&gt;len + 1) * sizeof(char));
2621                  strcpy(*err, reply-&gt;str);
2622              }
2623              success = 0;
2624              goto cleanup;
2625          }
2626      } else {
2627          int added = clusterManagerAddSlots(node, err);
2628          if (!added || *err != NULL) success = 0;
2629      }
2630      node-&gt;dirty = 0;
2631  cleanup:
2632      if (reply != NULL) freeReplyObject(reply);
2633      return success;
2634  }
2635  static void clusterManagerWaitForClusterJoin(void) {
2636      printf(&quot;Waiting for the cluster to join\n&quot;);
2637      while(!clusterManagerIsConfigConsistent()) {
2638          printf(&quot;.&quot;);
2639          fflush(stdout);
2640          sleep(1);
2641      }
2642      printf(&quot;\n&quot;);
2643  }
2644  static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
2645                                        char **err)
2646  {
2647      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER NODES&quot;);
2648      int success = 1;
2649      *err = NULL;
2650      if (!clusterManagerCheckRedisReply(node, reply, err)) {
2651          success = 0;
2652          goto cleanup;
2653      }
2654      int getfriends = (opts &amp; CLUSTER_MANAGER_OPT_GETFRIENDS);
2655      char *lines = reply-&gt;str, *p, *line;
2656      while ((p = strstr(lines, &quot;\n&quot;)) != NULL) {
2657          *p = &#x27;\0&#x27;;
2658          line = lines;
2659          lines = p + 1;
2660          char *name = NULL, *addr = NULL, *flags = NULL, *master_id = NULL,
2661               *ping_sent = NULL, *ping_recv = NULL, *config_epoch = NULL,
2662               *link_status = NULL;
2663          UNUSED(link_status);
2664          int i = 0;
2665          while ((p = strchr(line, &#x27; &#x27;)) != NULL) {
2666              *p = &#x27;\0&#x27;;
2667              char *token = line;
2668              line = p + 1;
2669              switch(i++){
2670              case 0: name = token; break;
2671              case 1: addr = token; break;
2672              case 2: flags = token; break;
2673              case 3: master_id = token; break;
2674              case 4: ping_sent = token; break;
2675              case 5: ping_recv = token; break;
2676              case 6: config_epoch = token; break;
2677              case 7: link_status = token; break;
2678              }
2679              if (i == 8) break; 
2680          }
2681          if (!flags) {
2682              success = 0;
2683              goto cleanup;
2684          }
2685          int myself = (strstr(flags, &quot;myself&quot;) != NULL);
2686          clusterManagerNode *currentNode = NULL;
2687          if (myself) {
2688              node-&gt;flags |= CLUSTER_MANAGER_FLAG_MYSELF;
2689              currentNode = node;
2690              clusterManagerNodeResetSlots(node);
2691              if (i == 8) {
2692                  int remaining = strlen(line);
2693                  while (remaining &gt; 0) {
2694                      p = strchr(line, &#x27; &#x27;);
2695                      if (p == NULL) p = line + remaining;
2696                      remaining -= (p - line);
2697                      char *slotsdef = line;
2698                      *p = &#x27;\0&#x27;;
2699                      if (remaining) {
2700                          line = p + 1;
2701                          remaining--;
2702                      } else line = p;
2703                      char *dash = NULL;
2704                      if (slotsdef[0] == &#x27;[&#x27;) {
2705                          slotsdef++;
2706                          if ((p = strstr(slotsdef, &quot;-&gt;-&quot;))) { 
2707                              *p = &#x27;\0&#x27;;
2708                              p += 3;
2709                              char *closing_bracket = strchr(p, &#x27;]&#x27;);
2710                              if (closing_bracket) *closing_bracket = &#x27;\0&#x27;;
2711                              sds slot = sdsnew(slotsdef);
2712                              sds dst = sdsnew(p);
2713                              node-&gt;migrating_count += 2;
2714                              node-&gt;migrating = zrealloc(node-&gt;migrating,
2715                                  (node-&gt;migrating_count * sizeof(sds)));
2716                              node-&gt;migrating[node-&gt;migrating_count - 2] =
2717                                  slot;
2718                              node-&gt;migrating[node-&gt;migrating_count - 1] =
2719                                  dst;
2720                          }  else if ((p = strstr(slotsdef, &quot;-&lt;-&quot;))) {
2721                              *p = &#x27;\0&#x27;;
2722                              p += 3;
2723                              char *closing_bracket = strchr(p, &#x27;]&#x27;);
2724                              if (closing_bracket) *closing_bracket = &#x27;\0&#x27;;
2725                              sds slot = sdsnew(slotsdef);
2726                              sds src = sdsnew(p);
2727                              node-&gt;importing_count += 2;
2728                              node-&gt;importing = zrealloc(node-&gt;importing,
2729                                  (node-&gt;importing_count * sizeof(sds)));
2730                              node-&gt;importing[node-&gt;importing_count - 2] =
2731                                  slot;
2732                              node-&gt;importing[node-&gt;importing_count - 1] =
2733                                  src;
2734                          }
2735                      } else if ((dash = strchr(slotsdef, &#x27;-&#x27;)) != NULL) {
2736                          p = dash;
2737                          int start, stop;
2738                          *p = &#x27;\0&#x27;;
2739                          start = atoi(slotsdef);
2740                          stop = atoi(p + 1);
2741                          node-&gt;slots_count += (stop - (start - 1));
2742                          while (start &lt;= stop) node-&gt;slots[start++] = 1;
2743                      } else if (p &gt; slotsdef) {
2744                          node-&gt;slots[atoi(slotsdef)] = 1;
2745                          node-&gt;slots_count++;
2746                      }
2747                  }
2748              }
2749              node-&gt;dirty = 0;
2750          } else if (!getfriends) {
2751              if (!(node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_MYSELF)) continue;
2752              else break;
2753          } else {
2754              if (addr == NULL) {
2755                  fprintf(stderr, &quot;Error: invalid CLUSTER NODES reply\n&quot;);
2756                  success = 0;
2757                  goto cleanup;
2758              }
2759              char *c = strrchr(addr, &#x27;@&#x27;);
2760              if (c != NULL) *c = &#x27;\0&#x27;;
2761              c = strrchr(addr, &#x27;:&#x27;);
2762              if (c == NULL) {
2763                  fprintf(stderr, &quot;Error: invalid CLUSTER NODES reply\n&quot;);
2764                  success = 0;
2765                  goto cleanup;
2766              }
2767              *c = &#x27;\0&#x27;;
2768              int port = atoi(++c);
2769              currentNode = clusterManagerNewNode(sdsnew(addr), port);
2770              currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_FRIEND;
2771              if (node-&gt;friends == NULL) node-&gt;friends = listCreate();
2772              listAddNodeTail(node-&gt;friends, currentNode);
2773          }
2774          if (name != NULL) {
2775              if (currentNode-&gt;name) sdsfree(currentNode-&gt;name);
2776              currentNode-&gt;name = sdsnew(name);
2777          }
2778          if (currentNode-&gt;flags_str != NULL)
2779              freeClusterManagerNodeFlags(currentNode-&gt;flags_str);
2780          currentNode-&gt;flags_str = listCreate();
2781          int flag_len;
2782          while ((flag_len = strlen(flags)) &gt; 0) {
2783              sds flag = NULL;
2784              char *fp = strchr(flags, &#x27;,&#x27;);
2785              if (fp) {
2786                  *fp = &#x27;\0&#x27;;
2787                  flag = sdsnew(flags);
2788                  flags = fp + 1;
2789              } else {
2790                  flag = sdsnew(flags);
2791                  flags += flag_len;
2792              }
2793              if (strcmp(flag, &quot;noaddr&quot;) == 0)
2794                  currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_NOADDR;
2795              else if (strcmp(flag, &quot;disconnected&quot;) == 0)
2796                  currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_DISCONNECT;
2797              else if (strcmp(flag, &quot;fail&quot;) == 0)
2798                  currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_FAIL;
2799              else if (strcmp(flag, &quot;slave&quot;) == 0) {
2800                  currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_SLAVE;
2801                  if (master_id != NULL) {
2802                      if (currentNode-&gt;replicate) sdsfree(currentNode-&gt;replicate);
2803                      currentNode-&gt;replicate = sdsnew(master_id);
2804                  }
2805              }
2806              listAddNodeTail(currentNode-&gt;flags_str, flag);
2807          }
2808          if (config_epoch != NULL)
2809              currentNode-&gt;current_epoch = atoll(config_epoch);
2810          if (ping_sent != NULL) currentNode-&gt;ping_sent = atoll(ping_sent);
2811          if (ping_recv != NULL) currentNode-&gt;ping_recv = atoll(ping_recv);
2812          if (!getfriends &amp;&amp; myself) break;
2813      }
2814  cleanup:
2815      if (reply) freeReplyObject(reply);
2816      return success;
2817  }
2818  static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
2819      if (node-&gt;context == NULL &amp;&amp; !clusterManagerNodeConnect(node)) {
2820          freeClusterManagerNode(node);
2821          return 0;
2822      }
2823      opts |= CLUSTER_MANAGER_OPT_GETFRIENDS;
2824      char *e = NULL;
2825      if (!clusterManagerNodeIsCluster(node, &amp;e)) {
2826          clusterManagerPrintNotClusterNodeError(node, e);
2827          if (e) zfree(e);
2828          freeClusterManagerNode(node);
2829          return 0;
2830      }
2831      e = NULL;
2832      if (!clusterManagerNodeLoadInfo(node, opts, &amp;e)) {
2833          if (e) {
2834              CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, e);
2835              zfree(e);
2836          }
2837          freeClusterManagerNode(node);
2838          return 0;
2839      }
2840      listIter li;
2841      listNode *ln;
2842      if (cluster_manager.nodes != NULL) {
2843          listRewind(cluster_manager.nodes, &amp;li);
2844          while ((ln = listNext(&amp;li)) != NULL)
2845              freeClusterManagerNode((clusterManagerNode *) ln-&gt;value);
2846          listRelease(cluster_manager.nodes);
2847      }
2848      cluster_manager.nodes = listCreate();
2849      listAddNodeTail(cluster_manager.nodes, node);
2850      if (node-&gt;friends != NULL) {
2851          listRewind(node-&gt;friends, &amp;li);
2852          while ((ln = listNext(&amp;li)) != NULL) {
2853              clusterManagerNode *friend = ln-&gt;value;
2854              if (!friend-&gt;ip || !friend-&gt;port) goto invalid_friend;
2855              if (!friend-&gt;context &amp;&amp; !clusterManagerNodeConnect(friend))
2856                  goto invalid_friend;
2857              e = NULL;
2858              if (clusterManagerNodeLoadInfo(friend, 0, &amp;e)) {
2859                  if (friend-&gt;flags &amp; (CLUSTER_MANAGER_FLAG_NOADDR |
2860                                       CLUSTER_MANAGER_FLAG_DISCONNECT |
2861                                       CLUSTER_MANAGER_FLAG_FAIL))
2862                      goto invalid_friend;
2863                  listAddNodeTail(cluster_manager.nodes, friend);
2864              } else {
2865                  clusterManagerLogErr(&quot;[ERR] Unable to load info for &quot;
2866                                       &quot;node %s:%d\n&quot;,
2867                                       friend-&gt;ip, friend-&gt;port);
2868                  goto invalid_friend;
2869              }
2870              continue;
2871  invalid_friend:
2872              freeClusterManagerNode(friend);
2873          }
2874          listRelease(node-&gt;friends);
2875          node-&gt;friends = NULL;
2876      }
2877      listRewind(cluster_manager.nodes, &amp;li);
2878      while ((ln = listNext(&amp;li)) != NULL) {
2879          clusterManagerNode *n = ln-&gt;value;
2880          if (n-&gt;replicate != NULL) {
2881              clusterManagerNode *master = clusterManagerNodeByName(n-&gt;replicate);
2882              if (master == NULL) {
2883                  clusterManagerLogWarn(&quot;*** WARNING: %s:%d claims to be &quot;
2884                                        &quot;slave of unknown node ID %s.\n&quot;,
2885                                        n-&gt;ip, n-&gt;port, n-&gt;replicate);
2886              } else master-&gt;replicas_count++;
2887          }
2888      }
2889      return 1;
2890  }
2891  int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
2892      const char **i1 = (const char **)slot1;
2893      const char **i2 = (const char **)slot2;
2894      return strcmp(*i1, *i2);
2895  }
2896  int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
2897      clusterManagerNode *node1 = *((clusterManagerNode **) n1);
2898      clusterManagerNode *node2 = *((clusterManagerNode **) n2);
2899      return node2-&gt;slots_count - node1-&gt;slots_count;
2900  }
2901  int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
2902      clusterManagerNode *node1 = *((clusterManagerNode **) n1);
2903      clusterManagerNode *node2 = *((clusterManagerNode **) n2);
2904      return node1-&gt;balance - node2-&gt;balance;
2905  }
2906  static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {
2907      sds signature = NULL;
2908      int node_count = 0, i = 0, name_len = 0;
2909      char **node_configs = NULL;
2910      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER NODES&quot;);
2911      if (reply == NULL || reply-&gt;type == REDIS_REPLY_ERROR)
2912          goto cleanup;
2913      char *lines = reply-&gt;str, *p, *line;
2914      while ((p = strstr(lines, &quot;\n&quot;)) != NULL) {
2915          i = 0;
2916          *p = &#x27;\0&#x27;;
2917          line = lines;
2918          lines = p + 1;
2919          char *nodename = NULL;
2920          int tot_size = 0;
2921          while ((p = strchr(line, &#x27; &#x27;)) != NULL) {
2922              *p = &#x27;\0&#x27;;
2923              char *token = line;
2924              line = p + 1;
2925              if (i == 0) {
2926                  nodename = token;
2927                  tot_size = (p - token);
2928                  name_len = tot_size++; 
2929              }
2930              if (++i == 8) break;
2931          }
2932          if (i != 8) continue;
2933          if (nodename == NULL) continue;
2934          int remaining = strlen(line);
2935          if (remaining == 0) continue;
2936          char **slots = NULL;
2937          int c = 0;
2938          while (remaining &gt; 0) {
2939              p = strchr(line, &#x27; &#x27;);
2940              if (p == NULL) p = line + remaining;
2941              int size = (p - line);
2942              remaining -= size;
2943              tot_size += size;
2944              char *slotsdef = line;
2945              *p = &#x27;\0&#x27;;
2946              if (remaining) {
2947                  line = p + 1;
2948                  remaining--;
2949              } else line = p;
2950              if (slotsdef[0] != &#x27;[&#x27;) {
2951                  c++;
2952                  slots = zrealloc(slots, (c * sizeof(char *)));
2953                  slots[c - 1] = slotsdef;
2954              }
2955          }
2956          if (c &gt; 0) {
2957              if (c &gt; 1)
2958                  qsort(slots, c, sizeof(char *), clusterManagerSlotCompare);
2959              node_count++;
2960              node_configs =
2961                  zrealloc(node_configs, (node_count * sizeof(char *)));
2962              tot_size += (sizeof(char) * (c - 1));
2963              char *cfg = zmalloc((sizeof(char) * tot_size) + 1);
2964              memcpy(cfg, nodename, name_len);
2965              char *sp = cfg + name_len;
2966              *(sp++) = &#x27;:&#x27;;
2967              for (i = 0; i &lt; c; i++) {
2968                  if (i &gt; 0) *(sp++) = &#x27;,&#x27;;
2969                  int slen = strlen(slots[i]);
2970                  memcpy(sp, slots[i], slen);
2971                  sp += slen;
2972              }
2973              *(sp++) = &#x27;\0&#x27;;
2974              node_configs[node_count - 1] = cfg;
2975          }
2976          zfree(slots);
2977      }
2978      if (node_count &gt; 0) {
2979          if (node_count &gt; 1) {
2980              qsort(node_configs, node_count, sizeof(char *),
2981                    clusterManagerSlotCompare);
2982          }
2983          signature = sdsempty();
2984          for (i = 0; i &lt; node_count; i++) {
2985              if (i &gt; 0) signature = sdscatprintf(signature, &quot;%c&quot;, &#x27;|&#x27;);
2986              signature = sdscatfmt(signature, &quot;%s&quot;, node_configs[i]);
2987          }
2988      }
2989  cleanup:
2990      if (reply != NULL) freeReplyObject(reply);
2991      if (node_configs != NULL) {
2992          for (i = 0; i &lt; node_count; i++) zfree(node_configs[i]);
2993          zfree(node_configs);
2994      }
2995      return signature;
2996  }
2997  static int clusterManagerIsConfigConsistent(void) {
2998      if (cluster_manager.nodes == NULL) return 0;
2999      int consistent = (listLength(cluster_manager.nodes) &lt;= 1);
3000      if (consistent) return 1;
3001      sds first_cfg = NULL;
3002      listIter li;
3003      listNode *ln;
3004      listRewind(cluster_manager.nodes, &amp;li);
3005      while ((ln = listNext(&amp;li)) != NULL) {
3006          clusterManagerNode *node = ln-&gt;value;
3007          sds cfg = clusterManagerGetConfigSignature(node);
3008          if (cfg == NULL) {
3009              consistent = 0;
3010              break;
3011          }
3012          if (first_cfg == NULL) first_cfg = cfg;
3013          else {
3014              consistent = !sdscmp(first_cfg, cfg);
3015              sdsfree(cfg);
3016              if (!consistent) break;
3017          }
3018      }
3019      if (first_cfg != NULL) sdsfree(first_cfg);
3020      return consistent;
3021  }
3022  static void clusterManagerOnError(sds err) {
3023      if (cluster_manager.errors == NULL)
3024          cluster_manager.errors = listCreate();
3025      listAddNodeTail(cluster_manager.errors, err);
3026      clusterManagerLogErr(&quot;%s\n&quot;, (char *) err);
3027  }
3028  static int clusterManagerGetCoveredSlots(char *all_slots) {
3029      if (cluster_manager.nodes == NULL) return 0;
3030      listIter li;
3031      listNode *ln;
3032      listRewind(cluster_manager.nodes, &amp;li);
3033      int totslots = 0, i;
3034      while ((ln = listNext(&amp;li)) != NULL) {
3035          clusterManagerNode *node = ln-&gt;value;
3036          for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
3037              if (node-&gt;slots[i] &amp;&amp; !all_slots[i]) {
3038                  all_slots[i] = 1;
3039                  totslots++;
3040              }
3041          }
3042      }
3043      return totslots;
3044  }
3045  static void clusterManagerPrintSlotsList(list *slots) {
3046      listIter li;
3047      listNode *ln;
3048      listRewind(slots, &amp;li);
3049      sds first = NULL;
3050      while ((ln = listNext(&amp;li)) != NULL) {
3051          sds slot = ln-&gt;value;
3052          if (!first) first = slot;
3053          else printf(&quot;, &quot;);
3054          printf(&quot;%s&quot;, slot);
3055      }
3056      printf(&quot;\n&quot;);
3057  }
3058  static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
3059                                                                      int slot,
3060                                                                      char **err)
3061  {
3062      clusterManagerNode *node = NULL;
3063      int numkeys = 0;
3064      listIter li;
3065      listNode *ln;
3066      listRewind(nodes, &amp;li);
3067      if (err) *err = NULL;
3068      while ((ln = listNext(&amp;li)) != NULL) {
3069          clusterManagerNode *n = ln-&gt;value;
3070          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE || n-&gt;replicate)
3071              continue;
3072          redisReply *r =
3073              CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER COUNTKEYSINSLOT %d&quot;, slot);
3074          int success = clusterManagerCheckRedisReply(n, r, err);
3075          if (success) {
3076              if (r-&gt;integer &gt; numkeys || node == NULL) {
3077                  numkeys = r-&gt;integer;
3078                  node = n;
3079              }
3080          }
3081          if (r != NULL) freeReplyObject(r);
3082          if (!success) {
3083              if (err != NULL &amp;&amp; *err != NULL)
3084                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err);
3085              node = NULL;
3086              break;
3087          }
3088      }
3089      return node;
3090  }
3091  static clusterManagerNode *clusterManagerNodeWithLeastReplicas() {
3092      clusterManagerNode *node = NULL;
3093      int lowest_count = 0;
3094      listIter li;
3095      listNode *ln;
3096      listRewind(cluster_manager.nodes, &amp;li);
3097      while ((ln = listNext(&amp;li)) != NULL) {
3098          clusterManagerNode *n = ln-&gt;value;
3099          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3100          if (node == NULL || n-&gt;replicas_count &lt; lowest_count) {
3101              node = n;
3102              lowest_count = n-&gt;replicas_count;
3103          }
3104      }
3105      return node;
3106  }
3107  static clusterManagerNode *clusterManagerNodeMasterRandom() {
3108      int master_count = 0;
3109      int idx;
3110      listIter li;
3111      listNode *ln;
3112      listRewind(cluster_manager.nodes, &amp;li);
3113      while ((ln = listNext(&amp;li)) != NULL) {
3114          clusterManagerNode *n = ln-&gt;value;
3115          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3116          master_count++;
3117      }
3118      srand(time(NULL));
3119      idx = rand() % master_count;
3120      listRewind(cluster_manager.nodes, &amp;li);
3121      while ((ln = listNext(&amp;li)) != NULL) {
3122          clusterManagerNode *n = ln-&gt;value;
3123          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3124          if (!idx--) {
3125              return n;
3126          }
3127      }
3128      return NULL;
3129  }
3130  static int clusterManagerFixSlotsCoverage(char *all_slots) {
3131      int i, fixed = 0;
3132      list *none = NULL, *single = NULL, *multi = NULL;
3133      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Fixing slots coverage...\n&quot;);
3134      printf(&quot;List of not covered slots: \n&quot;);
3135      int uncovered_count = 0;
3136      sds log = sdsempty();
3137      for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
3138          int covered = all_slots[i];
3139          if (!covered) {
3140              sds key = sdsfromlonglong((PORT_LONGLONG) i);
3141              if (uncovered_count++ &gt; 0) printf(&quot;,&quot;);
3142              printf(&quot;%s&quot;, (char *) key);
3143              list *slot_nodes = listCreate();
3144              sds slot_nodes_str = sdsempty();
3145              listIter li;
3146              listNode *ln;
3147              listRewind(cluster_manager.nodes, &amp;li);
3148              while ((ln = listNext(&amp;li)) != NULL) {
3149                  clusterManagerNode *n = ln-&gt;value;
3150                  if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE || n-&gt;replicate)
3151                      continue;
3152                  redisReply *reply = CLUSTER_MANAGER_COMMAND(n,
3153                      &quot;CLUSTER GETKEYSINSLOT %d %d&quot;, i, 1);
3154                  if (!clusterManagerCheckRedisReply(n, reply, NULL)) {
3155                      fixed = -1;
3156                      if (reply) freeReplyObject(reply);
3157                      goto cleanup;
3158                  }
3159                  assert(reply-&gt;type == REDIS_REPLY_ARRAY);
3160                  if (reply-&gt;elements &gt; 0) {
3161                      listAddNodeTail(slot_nodes, n);
3162                      if (listLength(slot_nodes) &gt; 1)
3163                          slot_nodes_str = sdscat(slot_nodes_str, &quot;, &quot;);
3164                      slot_nodes_str = sdscatfmt(slot_nodes_str,
3165                                                 &quot;%s:%u&quot;, n-&gt;ip, n-&gt;port);
3166                  }
3167                  freeReplyObject(reply);
3168              }
3169              log = sdscatfmt(log, &quot;\nSlot %S has keys in %u nodes: %S&quot;,
3170                              key, listLength(slot_nodes), slot_nodes_str);
3171              sdsfree(slot_nodes_str);
3172              dictAdd(clusterManagerUncoveredSlots, key, slot_nodes);
3173          }
3174      }
3175      printf(&quot;\n%s\n&quot;, log);
3176      none = listCreate();
3177      single = listCreate();
3178      multi = listCreate();
3179      dictIterator *iter = dictGetIterator(clusterManagerUncoveredSlots);
3180      dictEntry *entry;
3181      while ((entry = dictNext(iter)) != NULL) {
3182          sds slot = (sds) dictGetKey(entry);
3183          list *nodes = (list *) dictGetVal(entry);
3184          switch (listLength(nodes)){
3185          case 0: listAddNodeTail(none, slot); break;
3186          case 1: listAddNodeTail(single, slot); break;
3187          default: listAddNodeTail(multi, slot); break;
3188          }
3189      }
3190      dictReleaseIterator(iter);
3191      if (listLength(none) &gt; 0) {
3192          printf(&quot;The following uncovered slots have no keys &quot;
3193                 &quot;across the cluster:\n&quot;);
3194          clusterManagerPrintSlotsList(none);
3195          if (confirmWithYes(&quot;Fix these slots by covering with a random node?&quot;)){
3196              listIter li;
3197              listNode *ln;
3198              listRewind(none, &amp;li);
3199              while ((ln = listNext(&amp;li)) != NULL) {
3200                  sds slot = ln-&gt;value;
3201                  int s = atoi(slot);
3202                  clusterManagerNode *n = clusterManagerNodeMasterRandom();
3203                  clusterManagerLogInfo(&quot;&gt;&gt;&gt; Covering slot %s with %s:%d\n&quot;,
3204                                        slot, n-&gt;ip, n-&gt;port);
3205                  if (!clusterManagerSetSlotOwner(n, s, 0)) {
3206                      fixed = -1;
3207                      goto cleanup;
3208                  }
3209                  n-&gt;slots[s] = 1;
3210                  fixed++;
3211              }
3212          }
3213      }
3214      if (listLength(single) &gt; 0) {
3215          printf(&quot;The following uncovered slots have keys in just one node:\n&quot;);
3216          clusterManagerPrintSlotsList(single);
3217          if (confirmWithYes(&quot;Fix these slots by covering with those nodes?&quot;)){
3218              listIter li;
3219              listNode *ln;
3220              listRewind(single, &amp;li);
3221              while ((ln = listNext(&amp;li)) != NULL) {
3222                  sds slot = ln-&gt;value;
3223                  int s = atoi(slot);
3224                  dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);
3225                  assert(entry != NULL);
3226                  list *nodes = (list *) dictGetVal(entry);
3227                  listNode *fn = listFirst(nodes);
3228                  assert(fn != NULL);
3229                  clusterManagerNode *n = fn-&gt;value;
3230                  clusterManagerLogInfo(&quot;&gt;&gt;&gt; Covering slot %s with %s:%d\n&quot;,
3231                                        slot, n-&gt;ip, n-&gt;port);
3232                  if (!clusterManagerSetSlotOwner(n, s, 0)) {
3233                      fixed = -1;
3234                      goto cleanup;
3235                  }
3236                  n-&gt;slots[atoi(slot)] = 1;
3237                  fixed++;
3238              }
3239          }
3240      }
3241      if (listLength(multi) &gt; 0) {
3242          printf(&quot;The following uncovered slots have keys in multiple nodes:\n&quot;);
3243          clusterManagerPrintSlotsList(multi);
3244          if (confirmWithYes(&quot;Fix these slots by moving keys &quot;
3245                             &quot;into a single node?&quot;)) {
3246              listIter li;
3247              listNode *ln;
3248              listRewind(multi, &amp;li);
3249              while ((ln = listNext(&amp;li)) != NULL) {
3250                  sds slot = ln-&gt;value;
3251                  dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);
3252                  assert(entry != NULL);
3253                  list *nodes = (list *) dictGetVal(entry);
3254                  int s = atoi(slot);
3255                  clusterManagerNode *target =
3256                      clusterManagerGetNodeWithMostKeysInSlot(nodes, s, NULL);
3257                  if (target == NULL) {
3258                      fixed = -1;
3259                      goto cleanup;
3260                  }
3261                  clusterManagerLogInfo(&quot;&gt;&gt;&gt; Covering slot %s moving keys &quot;
3262                                        &quot;to %s:%d\n&quot;, slot,
3263                                        target-&gt;ip, target-&gt;port);
3264                  if (!clusterManagerSetSlotOwner(target, s, 1)) {
3265                      fixed = -1;
3266                      goto cleanup;
3267                  }
3268                  target-&gt;slots[atoi(slot)] = 1;
3269                  listIter nli;
3270                  listNode *nln;
3271                  listRewind(nodes, &amp;nli);
3272                  while ((nln = listNext(&amp;nli)) != NULL) {
3273                      clusterManagerNode *src = nln-&gt;value;
3274                      if (src == target) continue;
3275                      if (!clusterManagerSetSlot(src, target, s, &quot;NODE&quot;, NULL))
3276                          fixed = -1;
3277                      if (fixed &lt; 0) goto cleanup;
3278                      if (!clusterManagerSetSlot(src, target, s,
3279                                                 &quot;IMPORTING&quot;, NULL)) fixed = -1;
3280                      if (fixed &lt; 0) goto cleanup;
3281                      int opts = CLUSTER_MANAGER_OPT_VERBOSE |
3282                                 CLUSTER_MANAGER_OPT_COLD;
3283                      if (!clusterManagerMoveSlot(src, target, s, opts, NULL)) {
3284                          fixed = -1;
3285                          goto cleanup;
3286                      }
3287                      if (!clusterManagerClearSlotStatus(src, s))
3288                          fixed = -1;
3289                      if (fixed &lt; 0) goto cleanup;
3290                  }
3291                  fixed++;
3292              }
3293          }
3294      }
3295  cleanup:
3296      sdsfree(log);
3297      if (none) listRelease(none);
3298      if (single) listRelease(single);
3299      if (multi) listRelease(multi);
3300      return fixed;
3301  }
3302  static int clusterManagerFixOpenSlot(int slot) {
3303      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Fixing open slot %d\n&quot;, slot);
3304      int success = 1;
3305      list *owners = listCreate();
3306      list *migrating = listCreate();
3307      list *importing = listCreate();
3308      sds migrating_str = sdsempty();
3309      sds importing_str = sdsempty();
3310      clusterManagerNode *owner = NULL;
3311      listIter li;
3312      listNode *ln;
3313      listRewind(cluster_manager.nodes, &amp;li);
3314      while ((ln = listNext(&amp;li)) != NULL) {
3315          clusterManagerNode *n = ln-&gt;value;
3316          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3317          if (n-&gt;slots[slot]) listAddNodeTail(owners, n);
3318          else {
3319              redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3320                  &quot;CLUSTER COUNTKEYSINSLOT %d&quot;, slot);
3321              success = clusterManagerCheckRedisReply(n, r, NULL);
3322              if (success &amp;&amp; r-&gt;integer &gt; 0) {
3323                  clusterManagerLogWarn(&quot;*** Found keys about slot %d &quot;
3324                                        &quot;in non-owner node %s:%d!\n&quot;, slot,
3325                                        n-&gt;ip, n-&gt;port);
3326                  listAddNodeTail(owners, n);
3327              }
3328              if (r) freeReplyObject(r);
3329              if (!success) goto cleanup;
3330          }
3331      }
3332      if (listLength(owners) == 1) owner = listFirst(owners)-&gt;value;
3333      listRewind(cluster_manager.nodes, &amp;li);
3334      while ((ln = listNext(&amp;li)) != NULL) {
3335          clusterManagerNode *n = ln-&gt;value;
3336          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3337          int is_migrating = 0, is_importing = 0;
3338          if (n-&gt;migrating) {
3339              for (int i = 0; i &lt; n-&gt;migrating_count; i += 2) {
3340                  sds migrating_slot = n-&gt;migrating[i];
3341                  if (atoi(migrating_slot) == slot) {
3342                      char *sep = (listLength(migrating) == 0 ? &quot;&quot; : &quot;,&quot;);
3343                      migrating_str = sdscatfmt(migrating_str, &quot;%s%s:%u&quot;,
3344                                                sep, n-&gt;ip, n-&gt;port);
3345                      listAddNodeTail(migrating, n);
3346                      is_migrating = 1;
3347                      break;
3348                  }
3349              }
3350          }
3351          if (!is_migrating &amp;&amp; n-&gt;importing) {
3352              for (int i = 0; i &lt; n-&gt;importing_count; i += 2) {
3353                  sds importing_slot = n-&gt;importing[i];
3354                  if (atoi(importing_slot) == slot) {
3355                      char *sep = (listLength(importing) == 0 ? &quot;&quot; : &quot;,&quot;);
3356                      importing_str = sdscatfmt(importing_str, &quot;%s%s:%u&quot;,
3357                                                sep, n-&gt;ip, n-&gt;port);
3358                      listAddNodeTail(importing, n);
3359                      is_importing = 1;
3360                      break;
3361                  }
3362              }
3363          }
3364          if (!is_migrating &amp;&amp; !is_importing &amp;&amp; n != owner) {
3365              redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3366                  &quot;CLUSTER COUNTKEYSINSLOT %d&quot;, slot);
3367              success = clusterManagerCheckRedisReply(n, r, NULL);
3368              if (success &amp;&amp; r-&gt;integer &gt; 0) {
3369                  clusterManagerLogWarn(&quot;*** Found keys about slot %d &quot;
3370                                        &quot;in node %s:%d!\n&quot;, slot, n-&gt;ip,
3371                                        n-&gt;port);
3372                  char *sep = (listLength(importing) == 0 ? &quot;&quot; : &quot;,&quot;);
3373                  importing_str = sdscatfmt(importing_str, &quot;%s%S:%u&quot;,
3374                                            sep, n-&gt;ip, n-&gt;port);
3375                  listAddNodeTail(importing, n);
3376              }
3377              if (r) freeReplyObject(r);
3378              if (!success) goto cleanup;
3379          }
3380      }
3381      if (sdslen(migrating_str) &gt; 0)
3382          printf(&quot;Set as migrating in: %s\n&quot;, migrating_str);
3383      if (sdslen(importing_str) &gt; 0)
3384          printf(&quot;Set as importing in: %s\n&quot;, importing_str);
3385      if (owner == NULL) {
3386          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Nobody claims ownership, &quot;
3387                                &quot;selecting an owner...\n&quot;);
3388          owner = clusterManagerGetNodeWithMostKeysInSlot(cluster_manager.nodes,
3389                                                          slot, NULL);
3390          if (owner == NULL) {
3391              clusterManagerLogErr(&quot;[ERR] Can&#x27;t select a slot owner. &quot;
3392                                   &quot;Impossible to fix.\n&quot;);
3393              success = 0;
3394              goto cleanup;
3395          }
3396          clusterManagerLogWarn(&quot;*** Configuring %s:%d as the slot owner\n&quot;,
3397                                owner-&gt;ip, owner-&gt;port);
3398          success = clusterManagerClearSlotStatus(owner, slot);
3399          if (!success) goto cleanup;
3400          success = clusterManagerSetSlotOwner(owner, slot, 0);
3401          if (!success) goto cleanup;
3402          owner-&gt;slots[slot] = 1;
3403          success = clusterManagerBumpEpoch(owner);
3404          if (!success) goto cleanup;
3405          clusterManagerRemoveNodeFromList(migrating, owner);
3406          clusterManagerRemoveNodeFromList(importing, owner);
3407      }
3408      if (listLength(owners) &gt; 1) {
3409          assert(owner != NULL);
3410          listRewind(owners, &amp;li);
3411          while ((ln = listNext(&amp;li)) != NULL) {
3412              clusterManagerNode *n = ln-&gt;value;
3413              if (n == owner) continue;
3414              success = clusterManagerDelSlot(n, slot, 1);
3415              if (!success) goto cleanup;
3416              n-&gt;slots[slot] = 0;
3417              success = clusterManagerSetSlot(n, owner, slot, &quot;node&quot;, NULL);
3418              if (!success) goto cleanup;
3419              success = clusterManagerSetSlot(n, owner, slot, &quot;importing&quot;, NULL);
3420              if (!success) goto cleanup;
3421              clusterManagerRemoveNodeFromList(importing, n);
3422              listAddNodeTail(importing, n);
3423              clusterManagerRemoveNodeFromList(migrating, n);
3424          }
3425      }
3426      int move_opts = CLUSTER_MANAGER_OPT_VERBOSE;
3427      if (listLength(migrating) == 1 &amp;&amp; listLength(importing) == 1) {
3428          clusterManagerNode *src = listFirst(migrating)-&gt;value;
3429          clusterManagerNode *dst = listFirst(importing)-&gt;value;
3430          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 1: Moving slot %d from &quot;
3431                                &quot;%s:%d to %s:%d\n&quot;, slot,
3432                                src-&gt;ip, src-&gt;port, dst-&gt;ip, dst-&gt;port);
3433          move_opts |= CLUSTER_MANAGER_OPT_UPDATE;
3434          success = clusterManagerMoveSlot(src, dst, slot, move_opts, NULL);
3435      }
3436      else if (listLength(migrating) == 0 &amp;&amp; listLength(importing) &gt; 0) {
3437          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 2: Moving all the %d slot keys to its &quot;
3438                                &quot;owner %s:%d\n&quot;, slot, owner-&gt;ip, owner-&gt;port);
3439          move_opts |= CLUSTER_MANAGER_OPT_COLD;
3440          listRewind(importing, &amp;li);
3441          while ((ln = listNext(&amp;li)) != NULL) {
3442              clusterManagerNode *n = ln-&gt;value;
3443              if (n == owner) continue;
3444              success = clusterManagerMoveSlot(n, owner, slot, move_opts, NULL);
3445              if (!success) goto cleanup;
3446              clusterManagerLogInfo(&quot;&gt;&gt;&gt; Setting %d as STABLE in &quot;
3447                                    &quot;%s:%d\n&quot;, slot, n-&gt;ip, n-&gt;port);
3448              success = clusterManagerClearSlotStatus(n, slot);
3449              if (!success) goto cleanup;
3450          }
3451          listRewind(cluster_manager.nodes, &amp;li);
3452          while ((ln = listNext(&amp;li)) != NULL) {
3453              clusterManagerNode *n = ln-&gt;value;
3454              if (n == owner) continue;
3455              if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3456              success = clusterManagerSetSlot(n, owner, slot, &quot;NODE&quot;, NULL);
3457              if (!success) goto cleanup;
3458          }
3459      }
3460      else if (listLength(migrating) == 1 &amp;&amp; listLength(importing) &gt; 1) {
3461          int try_to_fix = 1;
3462          clusterManagerNode *src = listFirst(migrating)-&gt;value;
3463          clusterManagerNode *dst = NULL;
3464          sds target_id = NULL;
3465          for (int i = 0; i &lt; src-&gt;migrating_count; i += 2) {
3466              sds migrating_slot = src-&gt;migrating[i];
3467              if (atoi(migrating_slot) == slot) {
3468                  target_id = src-&gt;migrating[i + 1];
3469                  break;
3470              }
3471          }
3472          assert(target_id != NULL);
3473          listIter li;
3474          listNode *ln;
3475          listRewind(importing, &amp;li);
3476          while ((ln = listNext(&amp;li)) != NULL) {
3477              clusterManagerNode *n = ln-&gt;value;
3478              int count = clusterManagerCountKeysInSlot(n, slot);
3479              if (count &gt; 0) {
3480                  try_to_fix = 0;
3481                  break;
3482              }
3483              if (strcmp(n-&gt;name, target_id) == 0) dst = n;
3484          }
3485          if (!try_to_fix) goto unhandled_case;
3486          if (dst != NULL) {
3487              clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 3: Moving slot %d from %s:%d to &quot;
3488                                    &quot;%s:%d and closing it on all the other &quot;
3489                                    &quot;importing nodes.\n&quot;,
3490                                    slot, src-&gt;ip, src-&gt;port,
3491                                    dst-&gt;ip, dst-&gt;port);
3492              success = clusterManagerMoveSlot(src, dst, slot, move_opts, NULL);
3493              if (!success) goto cleanup;
3494              listRewind(importing, &amp;li);
3495              while ((ln = listNext(&amp;li)) != NULL) {
3496                  clusterManagerNode *n = ln-&gt;value;
3497                  if (dst == n) continue;
3498                  success = clusterManagerClearSlotStatus(n, slot);
3499                  if (!success) goto cleanup;
3500              }
3501          } else {
3502              clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 3: Closing slot %d on both &quot;
3503                                    &quot;migrating and importing nodes.\n&quot;, slot);
3504              success = clusterManagerClearSlotStatus(src, slot);
3505              if (!success) goto cleanup;
3506              listRewind(importing, &amp;li);
3507              while ((ln = listNext(&amp;li)) != NULL) {
3508                  clusterManagerNode *n = ln-&gt;value;
3509                  success = clusterManagerClearSlotStatus(n, slot);
3510                  if (!success) goto cleanup;
3511              }
3512          }
3513      } else {
3514          int try_to_close_slot = (listLength(importing) == 0 &amp;&amp;
3515                                   listLength(migrating) == 1);
3516          if (try_to_close_slot) {
3517              clusterManagerNode *n = listFirst(migrating)-&gt;value;
3518              if (!owner || owner != n) {
3519                  redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3520                      &quot;CLUSTER GETKEYSINSLOT %d %d&quot;, slot, 10);
3521                  success = clusterManagerCheckRedisReply(n, r, NULL);
3522                  if (r) {
3523                      if (success) try_to_close_slot = (r-&gt;elements == 0);
3524                      freeReplyObject(r);
3525                  }
3526                  if (!success) goto cleanup;
3527              }
3528          }
3529          if (try_to_close_slot) {
3530              clusterManagerNode *n = listFirst(migrating)-&gt;value;
3531              clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 4: Closing slot %d on %s:%d\n&quot;,
3532                                    slot, n-&gt;ip, n-&gt;port);
3533              redisReply *r = CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER SETSLOT %d %s&quot;,
3534                                                      slot, &quot;STABLE&quot;);
3535              success = clusterManagerCheckRedisReply(n, r, NULL);
3536              if (r) freeReplyObject(r);
3537              if (!success) goto cleanup;
3538          } else {
3539  unhandled_case:
3540              success = 0;
3541              clusterManagerLogErr(&quot;[ERR] Sorry, redis-cli can&#x27;t fix this slot &quot;
3542                                   &quot;yet (work in progress). Slot is set as &quot;
3543                                   &quot;migrating in %s, as importing in %s, &quot;
3544                                   &quot;owner is %s:%d\n&quot;, migrating_str,
3545                                   importing_str, owner-&gt;ip, owner-&gt;port);
3546          }
3547      }
3548  cleanup:
3549      listRelease(owners);
3550      listRelease(migrating);
3551      listRelease(importing);
3552      sdsfree(migrating_str);
3553      sdsfree(importing_str);
3554      return success;
3555  }
3556  static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
3557      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Fixing multiple owners for slot %d...\n&quot;, slot);
3558      int success = 0;
3559      assert(listLength(owners) &gt; 1);
3560      clusterManagerNode *owner = clusterManagerGetNodeWithMostKeysInSlot(owners,
3561                                                                          slot,
3562                                                                          NULL);
3563      if (!owner) owner = listFirst(owners)-&gt;value;
3564      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Setting slot %d owner: %s:%d\n&quot;,
3565                            slot, owner-&gt;ip, owner-&gt;port);
3566      if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
3567      listIter li;
3568      listNode *ln;
3569      listRewind(cluster_manager.nodes, &amp;li);
3570      while ((ln = listNext(&amp;li)) != NULL) {
3571          clusterManagerNode *n = ln-&gt;value;
3572          if (n == owner) continue;
3573          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3574          int count = clusterManagerCountKeysInSlot(n, slot);
3575          success = (count &gt;= 0);
3576          if (!success) break;
3577          clusterManagerDelSlot(n, slot, 1);
3578          if (!clusterManagerSetSlot(n, owner, slot, &quot;node&quot;, NULL)) return 0;
3579          if (count &gt; 0) {
3580              int opts = CLUSTER_MANAGER_OPT_VERBOSE |
3581                         CLUSTER_MANAGER_OPT_COLD;
3582              success = clusterManagerMoveSlot(n, owner, slot, opts, NULL);
3583              if (!success) break;
3584          }
3585      }
3586      return success;
3587  }
3588  static int clusterManagerCheckCluster(int quiet) {
3589      listNode *ln = listFirst(cluster_manager.nodes);
3590      if (!ln) return 0;
3591      clusterManagerNode *node = ln-&gt;value;
3592      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Performing Cluster Check (using node %s:%d)\n&quot;,
3593                            node-&gt;ip, node-&gt;port);
3594      int result = 1, consistent = 0;
3595      int do_fix = config.cluster_manager_command.flags &amp;
3596                   CLUSTER_MANAGER_CMD_FLAG_FIX;
3597      if (!quiet) clusterManagerShowNodes();
3598      consistent = clusterManagerIsConfigConsistent();
3599      if (!consistent) {
3600          sds err = sdsnew(&quot;[ERR] Nodes don&#x27;t agree about configuration!&quot;);
3601          clusterManagerOnError(err);
3602          result = 0;
3603      } else {
3604          clusterManagerLogOk(&quot;[OK] All nodes agree about slots &quot;
3605                              &quot;configuration.\n&quot;);
3606      }
3607      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Check for open slots...\n&quot;);
3608      listIter li;
3609      listRewind(cluster_manager.nodes, &amp;li);
3610      int i;
3611      dict *open_slots = NULL;
3612      while ((ln = listNext(&amp;li)) != NULL) {
3613          clusterManagerNode *n = ln-&gt;value;
3614          if (n-&gt;migrating != NULL) {
3615              if (open_slots == NULL)
3616                  open_slots = dictCreate(&amp;clusterManagerDictType, NULL);
3617              sds errstr = sdsempty();
3618              errstr = sdscatprintf(errstr,
3619                                  &quot;[WARNING] Node %s:%d has slots in &quot;
3620                                  &quot;migrating state &quot;,
3621                                  n-&gt;ip,
3622                                  n-&gt;port);
3623              for (i = 0; i &lt; n-&gt;migrating_count; i += 2) {
3624                  sds slot = n-&gt;migrating[i];
3625                  dictAdd(open_slots, slot, sdsdup(n-&gt;migrating[i + 1]));
3626                  char *fmt = (i &gt; 0 ? &quot;,%S&quot; : &quot;%S&quot;);
3627                  errstr = sdscatfmt(errstr, fmt, slot);
3628              }
3629              errstr = sdscat(errstr, &quot;.&quot;);
3630              clusterManagerOnError(errstr);
3631          }
3632          if (n-&gt;importing != NULL) {
3633              if (open_slots == NULL)
3634                  open_slots = dictCreate(&amp;clusterManagerDictType, NULL);
3635              sds errstr = sdsempty();
3636              errstr = sdscatprintf(errstr,
3637                                  &quot;[WARNING] Node %s:%d has slots in &quot;
3638                                  &quot;importing state &quot;,
3639                                  n-&gt;ip,
3640                                  n-&gt;port);
3641              for (i = 0; i &lt; n-&gt;importing_count; i += 2) {
3642                  sds slot = n-&gt;importing[i];
3643                  dictAdd(open_slots, slot, sdsdup(n-&gt;importing[i + 1]));
3644                  char *fmt = (i &gt; 0 ? &quot;,%S&quot; : &quot;%S&quot;);
3645                  errstr = sdscatfmt(errstr, fmt, slot);
3646              }
3647              errstr = sdscat(errstr, &quot;.&quot;);
3648              clusterManagerOnError(errstr);
3649          }
3650      }
3651      if (open_slots != NULL) {
3652          result = 0;
3653          dictIterator *iter = dictGetIterator(open_slots);
3654          dictEntry *entry;
3655          sds errstr = sdsnew(&quot;[WARNING] The following slots are open: &quot;);
3656          i = 0;
3657          while ((entry = dictNext(iter)) != NULL) {
3658              sds slot = (sds) dictGetKey(entry);
3659              char *fmt = (i++ &gt; 0 ? &quot;,%S&quot; : &quot;%S&quot;);
3660              errstr = sdscatfmt(errstr, fmt, slot);
3661          }
3662          clusterManagerLogErr(&quot;%s.\n&quot;, (char *) errstr);
3663          sdsfree(errstr);
3664          if (do_fix) {
3665              dictReleaseIterator(iter);
3666              iter = dictGetIterator(open_slots);
3667              while ((entry = dictNext(iter)) != NULL) {
3668                  sds slot = (sds) dictGetKey(entry);
3669                  result = clusterManagerFixOpenSlot(atoi(slot));
3670                  if (!result) break;
3671              }
3672          }
3673          dictReleaseIterator(iter);
3674          dictRelease(open_slots);
3675      }
3676      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Check slots coverage...\n&quot;);
3677      char slots[CLUSTER_MANAGER_SLOTS];
3678      memset(slots, 0, CLUSTER_MANAGER_SLOTS);
3679      int coverage = clusterManagerGetCoveredSlots(slots);
3680      if (coverage == CLUSTER_MANAGER_SLOTS) {
3681          clusterManagerLogOk(&quot;[OK] All %d slots covered.\n&quot;,
3682                              CLUSTER_MANAGER_SLOTS);
3683      } else {
3684          sds err = sdsempty();
3685          err = sdscatprintf(err, &quot;[ERR] Not all %d slots are &quot;
3686                                  &quot;covered by nodes.\n&quot;,
3687                                  CLUSTER_MANAGER_SLOTS);
3688          clusterManagerOnError(err);
3689          result = 0;
3690          if (do_fix&amp;bsol;* &amp;&amp; result*/) {
3691              dictType dtype = clusterManagerDictType;
3692              dtype.keyDestructor = dictSdsDestructor;
3693              dtype.valDestructor = dictListDestructor;
3694              clusterManagerUncoveredSlots = dictCreate(&amp;dtype, NULL);
3695              int fixed = clusterManagerFixSlotsCoverage(slots);
3696              if (fixed &gt; 0) result = 1;
3697          }
3698      }
3699      int search_multiple_owners = config.cluster_manager_command.flags &amp;
3700                                   CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS;
3701      if (search_multiple_owners) {
3702          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Check for multiple slot owners...\n&quot;);
3703          int slot = 0;
3704          for (; slot &lt; CLUSTER_MANAGER_SLOTS; slot++) {
3705              listIter li;
3706              listNode *ln;
3707              listRewind(cluster_manager.nodes, &amp;li);
3708              list *owners = listCreate();
3709              while ((ln = listNext(&amp;li)) != NULL) {
3710                  clusterManagerNode *n = ln-&gt;value;
3711                  if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3712                  if (n-&gt;slots[slot]) listAddNodeTail(owners, n);
3713                  else {
3714                      int count = clusterManagerCountKeysInSlot(n, slot);
3715                      if (count &gt; 0) listAddNodeTail(owners, n);
3716                  }
3717              }
3718              if (listLength(owners) &gt; 1) {
3719                  result = 0;
3720                  clusterManagerLogErr(&quot;[WARNING] Slot %d has %d owners:\n&quot;,
3721                                       slot, listLength(owners));
3722                  listRewind(owners, &amp;li);
3723                  while ((ln = listNext(&amp;li)) != NULL) {
3724                      clusterManagerNode *n = ln-&gt;value;
3725                      clusterManagerLogErr(&quot;    %s:%d\n&quot;, n-&gt;ip, n-&gt;port);
3726                  }
3727                  if (do_fix) {
3728                      result = clusterManagerFixMultipleSlotOwners(slot, owners);
3729                      if (!result) {
3730                          clusterManagerLogErr(&quot;Failed to fix multiple owners &quot;
3731                                               &quot;for slot %d\n&quot;, slot);
3732                          listRelease(owners);
3733                          break;
3734                      }
3735                  }
3736              }
3737              listRelease(owners);
3738          }
3739      }
3740      return result;
3741  }
3742  static clusterManagerNode *clusterNodeForResharding(char *id,
3743                                                      clusterManagerNode *target,
3744                                                      int *raise_err)
3745  {
3746      clusterManagerNode *node = NULL;
3747      const char *invalid_node_msg = &quot;*** The specified node (%s) is not known &quot;
3748                                     &quot;or not a master, please retry.\n&quot;;
3749      node = clusterManagerNodeByName(id);
3750      *raise_err = 0;
3751      if (!node || node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) {
3752          clusterManagerLogErr(invalid_node_msg, id);
3753          *raise_err = 1;
3754          return NULL;
3755      } else if (node != NULL &amp;&amp; target != NULL) {
3756          if (!strcmp(node-&gt;name, target-&gt;name)) {
3757              clusterManagerLogErr( &quot;*** It is not possible to use &quot;
3758                                    &quot;the target node as &quot;
3759                                    &quot;source node.\n&quot;);
3760              return NULL;
3761          }
3762      }
3763      return node;
3764  }
3765  static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
3766      list *moved = listCreate();
3767      int src_count = listLength(sources), i = 0, tot_slots = 0, j;
3768      clusterManagerNode **sorted = zmalloc(src_count * sizeof(*sorted));
3769      listIter li;
3770      listNode *ln;
3771      listRewind(sources, &amp;li);
3772      while ((ln = listNext(&amp;li)) != NULL) {
3773          clusterManagerNode *node = ln-&gt;value;
3774          tot_slots += node-&gt;slots_count;
3775          sorted[i++] = node;
3776      }
3777      qsort(sorted, src_count, sizeof(clusterManagerNode *),
3778            clusterManagerSlotCountCompareDesc);
3779      for (i = 0; i &lt; src_count; i++) {
3780          clusterManagerNode *node = sorted[i];
3781          float n = ((float) numslots / tot_slots * node-&gt;slots_count);
3782          if (i == 0) n = ceil(n);
3783          else n = floor(n);
3784          int max = (int) n, count = 0;
3785          for (j = 0; j &lt; CLUSTER_MANAGER_SLOTS; j++) {
3786              int slot = node-&gt;slots[j];
3787              if (!slot) continue;
3788              if (count &gt;= max || (int)listLength(moved) &gt;= numslots) break;
3789              clusterManagerReshardTableItem *item = zmalloc(sizeof(*item));
3790              item-&gt;source = node;
3791              item-&gt;slot = j;
3792              listAddNodeTail(moved, item);
3793              count++;
3794          }
3795      }
3796      zfree(sorted);
3797      return moved;
3798  }
3799  static void clusterManagerShowReshardTable(list *table) {
3800      listIter li;
3801      listNode *ln;
3802      listRewind(table, &amp;li);
3803      while ((ln = listNext(&amp;li)) != NULL) {
3804          clusterManagerReshardTableItem *item = ln-&gt;value;
3805          clusterManagerNode *n = item-&gt;source;
3806          printf(&quot;    Moving slot %d from %s\n&quot;, item-&gt;slot, (char *) n-&gt;name);
3807      }
3808  }
3809  static void clusterManagerReleaseReshardTable(list *table) {
3810      if (table != NULL) {
3811          listIter li;
3812          listNode *ln;
3813          listRewind(table, &amp;li);
3814          while ((ln = listNext(&amp;li)) != NULL) {
3815              clusterManagerReshardTableItem *item = ln-&gt;value;
3816              zfree(item);
3817          }
3818          listRelease(table);
3819      }
3820  }
3821  static void clusterManagerLog(int level, const char* fmt, ...) {
3822      int use_colors =
3823          (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_COLOR);
3824      if (use_colors) {
3825          printf(&quot;\033[&quot;);
3826          switch (level) {
3827          case CLUSTER_MANAGER_LOG_LVL_INFO: printf(LOG_COLOR_BOLD); break;
3828          case CLUSTER_MANAGER_LOG_LVL_WARN: printf(LOG_COLOR_YELLOW); break;
3829          case CLUSTER_MANAGER_LOG_LVL_ERR: printf(LOG_COLOR_RED); break;
3830          case CLUSTER_MANAGER_LOG_LVL_SUCCESS: printf(LOG_COLOR_GREEN); break;
3831          default: printf(LOG_COLOR_RESET); break;
3832          }
3833      }
3834      va_list ap;
3835      va_start(ap, fmt);
3836      vprintf(fmt, ap);
3837      va_end(ap);
3838      if (use_colors) printf(&quot;\033[&quot; LOG_COLOR_RESET);
3839  }
3840  static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
3841                                          int alloc_len)
3842  {
3843      array-&gt;nodes = zcalloc(alloc_len * sizeof(clusterManagerNode*));
3844      array-&gt;alloc = array-&gt;nodes;
3845      array-&gt;len = alloc_len;
3846      array-&gt;count = 0;
3847  }
3848  static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
3849      if (array-&gt;nodes &gt; array-&gt;alloc) {
3850          array-&gt;len = array-&gt;nodes - array-&gt;alloc;
3851          array-&gt;nodes = array-&gt;alloc;
3852          array-&gt;count = 0;
3853          int i = 0;
3854          for(; i &lt; array-&gt;len; i++) {
3855              if (array-&gt;nodes[i] != NULL) array-&gt;count++;
3856          }
3857      }
3858  }
3859  static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
3860                                           clusterManagerNode **nodeptr)
3861  {
3862      assert(array-&gt;nodes &lt; (array-&gt;nodes + array-&gt;len));
3863      if (*array-&gt;nodes != NULL) array-&gt;count--;
3864      *nodeptr = *array-&gt;nodes;
3865      array-&gt;nodes++;
3866      array-&gt;len--;
3867  }
3868  static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
3869                                         clusterManagerNode *node)
3870  {
3871      assert(array-&gt;nodes &lt; (array-&gt;nodes + array-&gt;len));
3872      assert(node != NULL);
3873      assert(array-&gt;count &lt; array-&gt;len);
3874      array-&gt;nodes[array-&gt;count++] = node;
3875  }
3876  static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
3877                                                   char *err)
3878  {
3879      char *msg;
3880      if (err) msg = err;
3881      else {
3882          msg = &quot;is not empty. Either the node already knows other &quot;
3883                &quot;nodes (check with CLUSTER NODES) or contains some &quot;
3884                &quot;key in database 0.&quot;;
3885      }
3886      clusterManagerLogErr(&quot;[ERR] Node %s:%d %s\n&quot;, node-&gt;ip, node-&gt;port, msg);
3887  }
3888  static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
3889                                                     char *err)
3890  {
3891      char *msg = (err ? err : &quot;is not configured as a cluster node.&quot;);
3892      clusterManagerLogErr(&quot;[ERR] Node %s:%d %s\n&quot;, node-&gt;ip, node-&gt;port, msg);
3893  }
3894  static void clusterManagerMode(clusterManagerCommandProc *proc) {
3895      int argc = config.cluster_manager_command.argc;
3896      char **argv = config.cluster_manager_command.argv;
3897      cluster_manager.nodes = NULL;
3898      if (!proc(argc, argv)) goto cluster_manager_err;
3899      freeClusterManager();
3900      exit(0);
3901  cluster_manager_err:
3902      freeClusterManager();
3903      sdsfree(config.hostip);
3904      sdsfree(config.mb_delim);
3905      exit(1);
3906  }
3907  static int clusterManagerCommandCreate(int argc, char **argv) {
3908      int i, j, success = 1;
3909      cluster_manager.nodes = listCreate();
3910      for (i = 0; i &lt; argc; i++) {
3911          char *addr = argv[i];
3912          char *c = strrchr(addr, &#x27;@&#x27;);
3913          if (c != NULL) *c = &#x27;\0&#x27;;
3914          c = strrchr(addr, &#x27;:&#x27;);
3915          if (c == NULL) {
3916              fprintf(stderr, &quot;Invalid address format: %s\n&quot;, addr);
3917              return 0;
3918          }
3919          *c = &#x27;\0&#x27;;
3920          char *ip = addr;
3921          int port = atoi(++c);
3922          clusterManagerNode *node = clusterManagerNewNode(ip, port);
3923          if (!clusterManagerNodeConnect(node)) {
3924              freeClusterManagerNode(node);
3925              return 0;
3926          }
3927          char *err = NULL;
3928          if (!clusterManagerNodeIsCluster(node, &amp;err)) {
3929              clusterManagerPrintNotClusterNodeError(node, err);
3930              if (err) zfree(err);
3931              freeClusterManagerNode(node);
3932              return 0;
3933          }
3934          err = NULL;
3935          if (!clusterManagerNodeLoadInfo(node, 0, &amp;err)) {
3936              if (err) {
3937                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
3938                  zfree(err);
3939              }
3940              freeClusterManagerNode(node);
3941              return 0;
3942          }
3943          err = NULL;
3944          if (!clusterManagerNodeIsEmpty(node, &amp;err)) {
3945              clusterManagerPrintNotEmptyNodeError(node, err);
3946              if (err) zfree(err);
3947              freeClusterManagerNode(node);
3948              return 0;
3949          }
3950          listAddNodeTail(cluster_manager.nodes, node);
3951      }
3952      int node_len = cluster_manager.nodes-&gt;len;
3953      int replicas = config.cluster_manager_command.replicas;
3954      int masters_count = CLUSTER_MANAGER_MASTERS_COUNT(node_len, replicas);
3955      if (masters_count &lt; 3) {
3956          clusterManagerLogErr(
3957              &quot;*** ERROR: Invalid configuration for cluster creation.\n&quot;
3958              &quot;*** Redis Cluster requires at least 3 master nodes.\n&quot;
3959              &quot;*** This is not possible with %d nodes and %d replicas per node.&quot;,
3960              node_len, replicas);
3961          clusterManagerLogErr(&quot;\n*** At least %d nodes are required.\n&quot;,
3962                               3 * (replicas + 1));
3963          return 0;
3964      }
3965      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Performing hash slots allocation &quot;
3966                            &quot;on %d nodes...\n&quot;, node_len);
3967      int interleaved_len = 0, ip_count = 0;
3968      clusterManagerNode **interleaved = zcalloc(node_len*sizeof(**interleaved));
3969      char **ips = zcalloc(node_len * sizeof(char*));
3970      clusterManagerNodeArray *ip_nodes = zcalloc(node_len * sizeof(*ip_nodes));
3971      listIter li;
3972      listNode *ln;
3973      listRewind(cluster_manager.nodes, &amp;li);
3974      while ((ln = listNext(&amp;li)) != NULL) {
3975          clusterManagerNode *n = ln-&gt;value;
3976          int found = 0;
3977          for (i = 0; i &lt; ip_count; i++) {
3978              char *ip = ips[i];
3979              if (!strcmp(ip, n-&gt;ip)) {
3980                  found = 1;
3981                  break;
3982              }
3983          }
3984          if (!found) {
3985              ips[ip_count++] = n-&gt;ip;
3986          }
3987          clusterManagerNodeArray *node_array = &amp;(ip_nodes[i]);
3988          if (node_array-&gt;nodes == NULL)
3989              clusterManagerNodeArrayInit(node_array, node_len);
3990          clusterManagerNodeArrayAdd(node_array, n);
3991      }
3992      while (interleaved_len &lt; node_len) {
3993          for (i = 0; i &lt; ip_count; i++) {
3994              clusterManagerNodeArray *node_array = &amp;(ip_nodes[i]);
3995              if (node_array-&gt;count &gt; 0) {
3996                  clusterManagerNode *n = NULL;
3997                  clusterManagerNodeArrayShift(node_array, &amp;n);
3998                  interleaved[interleaved_len++] = n;
3999              }
4000          }
4001      }
4002      clusterManagerNode **masters = interleaved;
4003      interleaved += masters_count;
4004      interleaved_len -= masters_count;
4005      float slots_per_node = CLUSTER_MANAGER_SLOTS / (float) masters_count;
4006      PORT_LONG first = 0;
4007      float cursor = 0.0f;
4008      for (i = 0; i &lt; masters_count; i++) {
4009          clusterManagerNode *master = masters[i];
4010          PORT_LONG last = lround(cursor + slots_per_node - 1);
4011          if (last &gt; CLUSTER_MANAGER_SLOTS || i == (masters_count - 1))
4012              last = CLUSTER_MANAGER_SLOTS - 1;
4013          if (last &lt; first) last = first;
4014          printf(&quot;Master[%d] -&gt; Slots %lu - %lu\n&quot;, i, first, last);
4015          master-&gt;slots_count = 0;
4016          for (j = first; j &lt;= last; j++) {
4017              master-&gt;slots[j] = 1;
4018              master-&gt;slots_count++;
4019          }
4020          master-&gt;dirty = 1;
4021          first = last + 1;
4022          cursor += slots_per_node;
4023      }
4024      clusterManagerNode *first_node = interleaved[0];
4025      for (i = 0; i &lt; (interleaved_len - 1); i++)
4026          interleaved[i] = interleaved[i + 1];
4027      interleaved[interleaved_len - 1] = first_node;
4028      int assign_unused = 0, available_count = interleaved_len;
4029  assign_replicas:
4030      for (i = 0; i &lt; masters_count; i++) {
4031          clusterManagerNode *master = masters[i];
4032          int assigned_replicas = 0;
4033          while (assigned_replicas &lt; replicas) {
4034              if (available_count == 0) break;
4035              clusterManagerNode *found = NULL, *slave = NULL;
4036              int firstNodeIdx = -1;
4037              for (j = 0; j &lt; interleaved_len; j++) {
4038                  clusterManagerNode *n = interleaved[j];
4039                  if (n == NULL) continue;
4040                  if (strcmp(n-&gt;ip, master-&gt;ip)) {
4041                      found = n;
4042                      interleaved[j] = NULL;
4043                      break;
4044                  }
4045                  if (firstNodeIdx &lt; 0) firstNodeIdx = j;
4046              }
4047              if (found) slave = found;
4048              else if (firstNodeIdx &gt;= 0) {
4049                  slave = interleaved[firstNodeIdx];
4050                  interleaved_len -= (interleaved - (interleaved + firstNodeIdx));
4051                  interleaved += (firstNodeIdx + 1);
4052              }
4053              if (slave != NULL) {
4054                  assigned_replicas++;
4055                  available_count--;
4056                  if (slave-&gt;replicate) sdsfree(slave-&gt;replicate);
4057                  slave-&gt;replicate = sdsnew(master-&gt;name);
4058                  slave-&gt;dirty = 1;
4059              } else break;
4060              printf(&quot;Adding replica %s:%d to %s:%d\n&quot;, slave-&gt;ip, slave-&gt;port,
4061                     master-&gt;ip, master-&gt;port);
4062              if (assign_unused) break;
4063          }
4064      }
4065      if (!assign_unused &amp;&amp; available_count &gt; 0) {
4066          assign_unused = 1;
4067          printf(&quot;Adding extra replicas...\n&quot;);
4068          goto assign_replicas;
4069      }
4070      for (i = 0; i &lt; ip_count; i++) {
4071          clusterManagerNodeArray *node_array = ip_nodes + i;
4072          clusterManagerNodeArrayReset(node_array);
4073      }
4074      clusterManagerOptimizeAntiAffinity(ip_nodes, ip_count);
4075      clusterManagerShowNodes();
4076      if (confirmWithYes(&quot;Can I set the above configuration?&quot;)) {
4077          listRewind(cluster_manager.nodes, &amp;li);
4078          while ((ln = listNext(&amp;li)) != NULL) {
4079              clusterManagerNode *node = ln-&gt;value;
4080              char *err = NULL;
4081              int flushed = clusterManagerFlushNodeConfig(node, &amp;err);
4082              if (!flushed &amp;&amp; node-&gt;dirty &amp;&amp; !node-&gt;replicate) {
4083                  if (err != NULL) {
4084                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
4085                      zfree(err);
4086                  }
4087                  success = 0;
4088                  goto cleanup;
4089              } else if (err != NULL) zfree(err);
4090          }
4091          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Nodes configuration updated\n&quot;);
4092          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Assign a different config epoch to &quot;
4093                                &quot;each node\n&quot;);
4094          int config_epoch = 1;
4095          listRewind(cluster_manager.nodes, &amp;li);
4096          while ((ln = listNext(&amp;li)) != NULL) {
4097              clusterManagerNode *node = ln-&gt;value;
4098              redisReply *reply = NULL;
4099              reply = CLUSTER_MANAGER_COMMAND(node,
4100                                              &quot;cluster set-config-epoch %d&quot;,
4101                                              config_epoch++);
4102              if (reply != NULL) freeReplyObject(reply);
4103          }
4104          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Sending CLUSTER MEET messages to join &quot;
4105                                &quot;the cluster\n&quot;);
4106          clusterManagerNode *first = NULL;
4107          listRewind(cluster_manager.nodes, &amp;li);
4108          while ((ln = listNext(&amp;li)) != NULL) {
4109              clusterManagerNode *node = ln-&gt;value;
4110              if (first == NULL) {
4111                  first = node;
4112                  continue;
4113              }
4114              redisReply *reply = NULL;
4115              reply = CLUSTER_MANAGER_COMMAND(node, &quot;cluster meet %s %d&quot;,
4116                                              first-&gt;ip, first-&gt;port);
4117              int is_err = 0;
4118              if (reply != NULL) {
4119                  if ((is_err = reply-&gt;type == REDIS_REPLY_ERROR))
4120                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, reply-&gt;str);
4121                  freeReplyObject(reply);
4122              } else {
4123                  is_err = 1;
4124                  fprintf(stderr, &quot;Failed to send CLUSTER MEET command.\n&quot;);
4125              }
4126              if (is_err) {
4127                  success = 0;
4128                  goto cleanup;
4129              }
4130          }
4131          sleep(1);
4132          clusterManagerWaitForClusterJoin();
4133          listRewind(cluster_manager.nodes, &amp;li);
4134          while ((ln = listNext(&amp;li)) != NULL) {
4135              clusterManagerNode *node = ln-&gt;value;
4136              if (!node-&gt;dirty) continue;
4137              char *err = NULL;
4138              int flushed = clusterManagerFlushNodeConfig(node, &amp;err);
4139              if (!flushed &amp;&amp; !node-&gt;replicate) {
4140                  if (err != NULL) {
4141                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
4142                      zfree(err);
4143                  }
4144                  success = 0;
4145                  goto cleanup;
4146              }
4147          }
4148          listRewind(cluster_manager.nodes, &amp;li);
4149          clusterManagerNode *first_node = NULL;
4150          while ((ln = listNext(&amp;li)) != NULL) {
4151              clusterManagerNode *node = ln-&gt;value;
4152              if (!first_node) first_node = node;
4153              else freeClusterManagerNode(node);
4154          }
4155          listEmpty(cluster_manager.nodes);
4156          if (!clusterManagerLoadInfoFromNode(first_node, 0)) {
4157              success = 0;
4158              goto cleanup;
4159          }
4160          clusterManagerCheckCluster(0);
4161      }
4162  cleanup:
4163      zfree(masters);
4164      zfree(ips);
4165      for (i = 0; i &lt; node_len; i++) {
4166          clusterManagerNodeArray *node_array = ip_nodes + i;
4167          CLUSTER_MANAGER_NODE_ARRAY_FREE(node_array);
4168      }
4169      zfree(ip_nodes);
4170      return success;
4171  }
4172  static int clusterManagerCommandAddNode(int argc, char **argv) {
4173      int success = 1;
4174      redisReply *reply = NULL;
4175      char *ref_ip = NULL, *ip = NULL;
4176      int ref_port = 0, port = 0;
4177      if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &amp;ref_ip, &amp;ref_port))
4178          goto invalid_args;
4179      if (!getClusterHostFromCmdArgs(1, argv, &amp;ip, &amp;port))
4180          goto invalid_args;
4181      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Adding node %s:%d to cluster %s:%d\n&quot;, ip, port,
4182                            ref_ip, ref_port);
4183      clusterManagerNode *refnode = clusterManagerNewNode(ref_ip, ref_port);
4184      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4185      if (!clusterManagerCheckCluster(0)) return 0;
4186      clusterManagerNode *master_node = NULL;
4187      if (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_SLAVE) {
4188          char *master_id = config.cluster_manager_command.master_id;
4189          if (master_id != NULL) {
4190              master_node = clusterManagerNodeByName(master_id);
4191              if (master_node == NULL) {
4192                  clusterManagerLogErr(&quot;[ERR] No such master ID %s\n&quot;, master_id);
4193                  return 0;
4194              }
4195          } else {
4196              master_node = clusterManagerNodeWithLeastReplicas();
4197              assert(master_node != NULL);
4198              printf(&quot;Automatically selected master %s:%d\n&quot;, master_node-&gt;ip,
4199                     master_node-&gt;port);
4200          }
4201      }
4202      clusterManagerNode *new_node = clusterManagerNewNode(ip, port);
4203      int added = 0;
4204      if (!clusterManagerNodeConnect(new_node)) {
4205          clusterManagerLogErr(&quot;[ERR] Sorry, can&#x27;t connect to node %s:%d\n&quot;,
4206                               ip, port);
4207          success = 0;
4208          goto cleanup;
4209      }
4210      char *err = NULL;
4211      if (!(success = clusterManagerNodeIsCluster(new_node, &amp;err))) {
4212          clusterManagerPrintNotClusterNodeError(new_node, err);
4213          if (err) zfree(err);
4214          goto cleanup;
4215      }
4216      if (!clusterManagerNodeLoadInfo(new_node, 0, &amp;err)) {
4217          if (err) {
4218              CLUSTER_MANAGER_PRINT_REPLY_ERROR(new_node, err);
4219              zfree(err);
4220          }
4221          success = 0;
4222          goto cleanup;
4223      }
4224      if (!(success = clusterManagerNodeIsEmpty(new_node, &amp;err))) {
4225          clusterManagerPrintNotEmptyNodeError(new_node, err);
4226          if (err) zfree(err);
4227          goto cleanup;
4228      }
4229      clusterManagerNode *first = listFirst(cluster_manager.nodes)-&gt;value;
4230      listAddNodeTail(cluster_manager.nodes, new_node);
4231      added = 1;
4232      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Send CLUSTER MEET to node %s:%d to make it &quot;
4233                            &quot;join the cluster.\n&quot;, ip, port);
4234      reply = CLUSTER_MANAGER_COMMAND(new_node, &quot;CLUSTER MEET %s %d&quot;,
4235                                      first-&gt;ip, first-&gt;port);
4236      if (!(success = clusterManagerCheckRedisReply(new_node, reply, NULL)))
4237          goto cleanup;
4238      if (master_node) {
4239          sleep(1);
4240          clusterManagerWaitForClusterJoin();
4241          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Configure node as replica of %s:%d.\n&quot;,
4242                                master_node-&gt;ip, master_node-&gt;port);
4243          freeReplyObject(reply);
4244          reply = CLUSTER_MANAGER_COMMAND(new_node, &quot;CLUSTER REPLICATE %s&quot;,
4245                                          master_node-&gt;name);
4246          if (!(success = clusterManagerCheckRedisReply(new_node, reply, NULL)))
4247              goto cleanup;
4248      }
4249      clusterManagerLogOk(&quot;[OK] New node added correctly.\n&quot;);
4250  cleanup:
4251      if (!added &amp;&amp; new_node) freeClusterManagerNode(new_node);
4252      if (reply) freeReplyObject(reply);
4253      return success;
4254  invalid_args:
4255      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4256      return 0;
4257  }
4258  static int clusterManagerCommandDeleteNode(int argc, char **argv) {
4259      UNUSED(argc);
4260      int success = 1;
4261      int port = 0;
4262      char *ip = NULL;
4263      if (!getClusterHostFromCmdArgs(1, argv, &amp;ip, &amp;port)) goto invalid_args;
4264      char *node_id = argv[1];
4265      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Removing node %s from cluster %s:%d\n&quot;,
4266                            node_id, ip, port);
4267      clusterManagerNode *ref_node = clusterManagerNewNode(ip, port);
4268      clusterManagerNode *node = NULL;
4269      if (!clusterManagerLoadInfoFromNode(ref_node, 0)) return 0;
4270      node = clusterManagerNodeByName(node_id);
4271      if (node == NULL) {
4272          clusterManagerLogErr(&quot;[ERR] No such node ID %s\n&quot;, node_id);
4273          return 0;
4274      }
4275      if (node-&gt;slots_count != 0) {
4276          clusterManagerLogErr(&quot;[ERR] Node %s:%d is not empty! Reshard data &quot;
4277                               &quot;away and try again.\n&quot;, node-&gt;ip, node-&gt;port);
4278          return 0;
4279      }
4280      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Sending CLUSTER FORGET messages to the &quot;
4281                            &quot;cluster...\n&quot;);
4282      listIter li;
4283      listNode *ln;
4284      listRewind(cluster_manager.nodes, &amp;li);
4285      while ((ln = listNext(&amp;li)) != NULL) {
4286          clusterManagerNode *n = ln-&gt;value;
4287          if (n == node) continue;
4288          if (n-&gt;replicate &amp;&amp; !strcasecmp(n-&gt;replicate, node_id)) {
4289              clusterManagerNode *master = clusterManagerNodeWithLeastReplicas();
4290              assert(master != NULL);
4291              clusterManagerLogInfo(&quot;&gt;&gt;&gt; %s:%d as replica of %s:%d\n&quot;,
4292                                    n-&gt;ip, n-&gt;port, master-&gt;ip, master-&gt;port);
4293              redisReply *r = CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER REPLICATE %s&quot;,
4294                                                      master-&gt;name);
4295              success = clusterManagerCheckRedisReply(n, r, NULL);
4296              if (r) freeReplyObject(r);
4297              if (!success) return 0;
4298          }
4299          redisReply *r = CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER FORGET %s&quot;,
4300                                                  node_id);
4301          success = clusterManagerCheckRedisReply(n, r, NULL);
4302          if (r) freeReplyObject(r);
4303          if (!success) return 0;
4304      }
4305      clusterManagerLogInfo(&quot;&gt;&gt;&gt; SHUTDOWN the node.\n&quot;);
4306      redisReply *r = redisCommand(node-&gt;context, &quot;SHUTDOWN&quot;);
4307      success = clusterManagerCheckRedisReply(node, r, NULL);
4308      if (r) freeReplyObject(r);
4309      return success;
4310  invalid_args:
4311      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4312      return 0;
4313  }
4314  static int clusterManagerCommandInfo(int argc, char **argv) {
4315      int port = 0;
4316      char *ip = NULL;
4317      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) goto invalid_args;
4318      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4319      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4320      clusterManagerShowClusterInfo();
4321      return 1;
4322  invalid_args:
4323      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4324      return 0;
4325  }
4326  static int clusterManagerCommandCheck(int argc, char **argv) {
4327      int port = 0;
4328      char *ip = NULL;
4329      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) goto invalid_args;
4330      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4331      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4332      clusterManagerShowClusterInfo();
4333      return clusterManagerCheckCluster(0);
4334  invalid_args:
4335      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4336      return 0;
4337  }
4338  static int clusterManagerCommandFix(int argc, char **argv) {
4339      config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_FIX;
4340      return clusterManagerCommandCheck(argc, argv);
4341  }
4342  static int clusterManagerCommandReshard(int argc, char **argv) {
4343      int port = 0;
4344      char *ip = NULL;
4345      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) goto invalid_args;
4346      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4347      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4348      clusterManagerCheckCluster(0);
4349      if (cluster_manager.errors &amp;&amp; listLength(cluster_manager.errors) &gt; 0) {
4350          fflush(stdout);
4351          fprintf(stderr,
4352                  &quot;*** Please fix your cluster problems before resharding\n&quot;);
4353          return 0;
4354      }
4355      int slots = config.cluster_manager_command.slots;
4356      if (!slots) {
4357          while (slots &lt;= 0 || slots &gt; CLUSTER_MANAGER_SLOTS) {
4358              printf(&quot;How many slots do you want to move (from 1 to %d)? &quot;,
4359                     CLUSTER_MANAGER_SLOTS);
4360              fflush(stdout);
4361              char buf[6];
4362              int nread = read(fileno(stdin),buf,6);
4363              if (nread &lt;= 0) continue;
4364              int last_idx = nread - 1;
4365              if (buf[last_idx] != &#x27;\n&#x27;) {
4366                  int ch;
4367                  while ((ch = getchar()) != &#x27;\n&#x27; &amp;&amp; ch != EOF) {}
4368              }
4369              buf[last_idx] = &#x27;\0&#x27;;
4370              slots = atoi(buf);
4371          }
4372      }
4373      char buf[255];
4374      char *to = config.cluster_manager_command.to,
4375           *from = config.cluster_manager_command.from;
4376      while (to == NULL) {
4377          printf(&quot;What is the receiving node ID? &quot;);
4378          fflush(stdout);
4379          int nread = read(fileno(stdin),buf,255);
4380          if (nread &lt;= 0) continue;
4381          int last_idx = nread - 1;
4382          if (buf[last_idx] != &#x27;\n&#x27;) {
4383              int ch;
4384              while ((ch = getchar()) != &#x27;\n&#x27; &amp;&amp; ch != EOF) {}
4385          }
4386          buf[last_idx] = &#x27;\0&#x27;;
4387          if (strlen(buf) &gt; 0) to = buf;
4388      }
4389      int raise_err = 0;
4390      clusterManagerNode *target = clusterNodeForResharding(to, NULL, &amp;raise_err);
4391      if (target == NULL) return 0;
4392      list *sources = listCreate();
4393      list *table = NULL;
4394      int all = 0, result = 1;
4395      if (from == NULL) {
4396          printf(&quot;Please enter all the source node IDs.\n&quot;);
4397          printf(&quot;  Type &#x27;all&#x27; to use all the nodes as source nodes for &quot;
4398                 &quot;the hash slots.\n&quot;);
4399          printf(&quot;  Type &#x27;done&#x27; once you entered all the source nodes IDs.\n&quot;);
4400          while (1) {
4401              printf(&quot;Source node #%lu: &quot;, listLength(sources) + 1);
4402              fflush(stdout);
4403              int nread = read(fileno(stdin),buf,255);
4404              if (nread &lt;= 0) continue;
4405              int last_idx = nread - 1;
4406              if (buf[last_idx] != &#x27;\n&#x27;) {
4407                  int ch;
4408                  while ((ch = getchar()) != &#x27;\n&#x27; &amp;&amp; ch != EOF) {}
4409              }
4410              buf[last_idx] = &#x27;\0&#x27;;
4411              if (!strcmp(buf, &quot;done&quot;)) break;
4412              else if (!strcmp(buf, &quot;all&quot;)) {
4413                  all = 1;
4414                  break;
4415              } else {
4416                  clusterManagerNode *src =
4417                      clusterNodeForResharding(buf, target, &amp;raise_err);
4418                  if (src != NULL) listAddNodeTail(sources, src);
4419                  else if (raise_err) {
4420                      result = 0;
4421                      goto cleanup;
4422                  }
4423              }
4424          }
4425      } else {
4426          char *p;
4427          while((p = strchr(from, &#x27;,&#x27;)) != NULL) {
4428              *p = &#x27;\0&#x27;;
4429              if (!strcmp(from, &quot;all&quot;)) {
4430                  all = 1;
4431                  break;
4432              } else {
4433                  clusterManagerNode *src =
4434                      clusterNodeForResharding(from, target, &amp;raise_err);
4435                  if (src != NULL) listAddNodeTail(sources, src);
4436                  else if (raise_err) {
4437                      result = 0;
4438                      goto cleanup;
4439                  }
4440              }
4441              from = p + 1;
4442          }
4443          if (!all &amp;&amp; strlen(from) &gt; 0) {
4444              if (!strcmp(from, &quot;all&quot;)) all = 1;
4445              if (!all) {
4446                  clusterManagerNode *src =
4447                      clusterNodeForResharding(from, target, &amp;raise_err);
4448                  if (src != NULL) listAddNodeTail(sources, src);
4449                  else if (raise_err) {
4450                      result = 0;
4451                      goto cleanup;
4452                  }
4453              }
4454          }
4455      }
4456      listIter li;
4457      listNode *ln;
4458      if (all) {
4459          listEmpty(sources);
4460          listRewind(cluster_manager.nodes, &amp;li);
4461          while ((ln = listNext(&amp;li)) != NULL) {
4462              clusterManagerNode *n = ln-&gt;value;
4463              if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE || n-&gt;replicate)
4464                  continue;
4465              if (!sdscmp(n-&gt;name, target-&gt;name)) continue;
4466              listAddNodeTail(sources, n);
4467          }
4468      }
4469      if (listLength(sources) == 0) {
4470          fprintf(stderr, &quot;*** No source nodes given, operation aborted.\n&quot;);
4471          result = 0;
4472          goto cleanup;
4473      }
4474      printf(&quot;\nReady to move %d slots.\n&quot;, slots);
4475      printf(&quot;  Source nodes:\n&quot;);
4476      listRewind(sources, &amp;li);
4477      while ((ln = listNext(&amp;li)) != NULL) {
4478          clusterManagerNode *src = ln-&gt;value;
4479          sds info = clusterManagerNodeInfo(src, 4);
4480          printf(&quot;%s\n&quot;, info);
4481          sdsfree(info);
4482      }
4483      printf(&quot;  Destination node:\n&quot;);
4484      sds info = clusterManagerNodeInfo(target, 4);
4485      printf(&quot;%s\n&quot;, info);
4486      sdsfree(info);
4487      table = clusterManagerComputeReshardTable(sources, slots);
4488      printf(&quot;  Resharding plan:\n&quot;);
4489      clusterManagerShowReshardTable(table);
4490      if (!(config.cluster_manager_command.flags &amp;
4491            CLUSTER_MANAGER_CMD_FLAG_YES))
4492      {
4493          printf(&quot;Do you want to proceed with the proposed &quot;
4494                 &quot;reshard plan (yes/no)? &quot;);
4495          fflush(stdout);
4496          char buf[4];
4497          int nread = read(fileno(stdin),buf,4);
4498          buf[3] = &#x27;\0&#x27;;
4499          if (nread &lt;= 0 || strcmp(&quot;yes&quot;, buf) != 0) {
4500              result = 0;
4501              goto cleanup;
4502          }
4503      }
4504      int opts = CLUSTER_MANAGER_OPT_VERBOSE;
4505      listRewind(table, &amp;li);
4506      while ((ln = listNext(&amp;li)) != NULL) {
4507          clusterManagerReshardTableItem *item = ln-&gt;value;
4508          char *err = NULL;
4509          result = clusterManagerMoveSlot(item-&gt;source, target, item-&gt;slot,
4510                                          opts, &amp;err);
4511          if (!result) {
4512              if (err != NULL) {
4513                  zfree(err);
4514              }
4515              goto cleanup;
4516          }
4517      }
4518  cleanup:
4519      listRelease(sources);
4520      clusterManagerReleaseReshardTable(table);
4521      return result;
4522  invalid_args:
4523      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4524      return 0;
4525  }
4526  static int clusterManagerCommandRebalance(int argc, char **argv) {
4527      int port = 0;
4528      char *ip = NULL;
4529      clusterManagerNode **weightedNodes = NULL;
4530      list *involved = NULL;
4531      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) goto invalid_args;
4532      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4533      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4534      int result = 1, i;
4535      if (config.cluster_manager_command.weight != NULL) {
4536          for (i = 0; i &lt; config.cluster_manager_command.weight_argc; i++) {
4537              char *name = config.cluster_manager_command.weight[i];
4538              char *p = strchr(name, &#x27;=&#x27;);
4539              if (p == NULL) {
4540                  result = 0;
4541                  goto cleanup;
4542              }
4543              *p = &#x27;\0&#x27;;
4544              float w = atof(++p);
4545              clusterManagerNode *n = clusterManagerNodeByAbbreviatedName(name);
4546              if (n == NULL) {
4547                  clusterManagerLogErr(&quot;*** No such master node %s\n&quot;, name);
4548                  result = 0;
4549                  goto cleanup;
4550              }
4551              n-&gt;weight = w;
4552          }
4553      }
4554      float total_weight = 0;
4555      int nodes_involved = 0;
4556      int use_empty = config.cluster_manager_command.flags &amp;
4557                      CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER;
4558      involved = listCreate();
4559      listIter li;
4560      listNode *ln;
4561      listRewind(cluster_manager.nodes, &amp;li);
4562      while ((ln = listNext(&amp;li)) != NULL) {
4563          clusterManagerNode *n = ln-&gt;value;
4564          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE || n-&gt;replicate)
4565              continue;
4566          if (!use_empty &amp;&amp; n-&gt;slots_count == 0) {
4567              n-&gt;weight = 0;
4568              continue;
4569          }
4570          total_weight += n-&gt;weight;
4571          nodes_involved++;
4572          listAddNodeTail(involved, n);
4573      }
4574      weightedNodes = zmalloc(nodes_involved * sizeof(clusterManagerNode *));
4575      if (weightedNodes == NULL) goto cleanup;
4576      clusterManagerCheckCluster(1);
4577      if (cluster_manager.errors &amp;&amp; listLength(cluster_manager.errors) &gt; 0) {
4578          clusterManagerLogErr(&quot;*** Please fix your cluster problems &quot;
4579                               &quot;before rebalancing\n&quot;);
4580          result = 0;
4581          goto cleanup;
4582      }
4583      int threshold_reached = 0, total_balance = 0;
4584      float threshold = config.cluster_manager_command.threshold;
4585      i = 0;
4586      listRewind(involved, &amp;li);
4587      while ((ln = listNext(&amp;li)) != NULL) {
4588          clusterManagerNode *n = ln-&gt;value;
4589          weightedNodes[i++] = n;
4590          int expected = (int) (((float)CLUSTER_MANAGER_SLOTS / total_weight) *
4591                          n-&gt;weight);
4592          n-&gt;balance = n-&gt;slots_count - expected;
4593          total_balance += n-&gt;balance;
4594          int over_threshold = 0;
4595          if (threshold &gt; 0) {
4596              if (n-&gt;slots_count &gt; 0) {
4597                  float err_perc = fabs((100-(100.0*expected/n-&gt;slots_count)));
4598                  if (err_perc &gt; threshold) over_threshold = 1;
4599              } else if (expected &gt; 1) {
4600                  over_threshold = 1;
4601              }
4602          }
4603          if (over_threshold) threshold_reached = 1;
4604      }
4605      if (!threshold_reached) {
4606          clusterManagerLogWarn(&quot;*** No rebalancing needed! &quot;
4607                               &quot;All nodes are within the %.2f%% threshold.\n&quot;,
4608                               config.cluster_manager_command.threshold);
4609          goto cleanup;
4610      }
4611      while (total_balance &gt; 0) {
4612          listRewind(involved, &amp;li);
4613          while ((ln = listNext(&amp;li)) != NULL) {
4614              clusterManagerNode *n = ln-&gt;value;
4615              if (n-&gt;balance &lt;= 0 &amp;&amp; total_balance &gt; 0) {
4616                  n-&gt;balance--;
4617                  total_balance--;
4618              }
4619          }
4620      }
4621      qsort(weightedNodes, nodes_involved, sizeof(clusterManagerNode *),
4622            clusterManagerCompareNodeBalance);
4623      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Rebalancing across %d nodes. &quot;
4624                            &quot;Total weight = %.2f\n&quot;,
4625                            nodes_involved, total_weight);
4626      if (config.verbose) {
4627          for (i = 0; i &lt; nodes_involved; i++) {
4628              clusterManagerNode *n = weightedNodes[i];
4629              printf(&quot;%s:%d balance is %d slots\n&quot;, n-&gt;ip, n-&gt;port, n-&gt;balance);
4630          }
4631      }
4632      int dst_idx = 0;
4633      int src_idx = nodes_involved - 1;
4634      int simulate = config.cluster_manager_command.flags &amp;
4635                     CLUSTER_MANAGER_CMD_FLAG_SIMULATE;
4636      while (dst_idx &lt; src_idx) {
4637          clusterManagerNode *dst = weightedNodes[dst_idx];
4638          clusterManagerNode *src = weightedNodes[src_idx];
4639          int db = abs(dst-&gt;balance);
4640          int sb = abs(src-&gt;balance);
4641          int numslots = (db &lt; sb ? db : sb);
4642          if (numslots &gt; 0) {
4643              printf(&quot;Moving %d slots from %s:%d to %s:%d\n&quot;, numslots,
4644                                                              src-&gt;ip,
4645                                                              src-&gt;port,
4646                                                              dst-&gt;ip,
4647                                                              dst-&gt;port);
4648              list *lsrc = listCreate(), *table = NULL;
4649              listAddNodeTail(lsrc, src);
4650              table = clusterManagerComputeReshardTable(lsrc, numslots);
4651              listRelease(lsrc);
4652              int table_len = (int) listLength(table);
4653              if (!table || table_len != numslots) {
4654                  clusterManagerLogErr(&quot;*** Assertion failed: Reshard table &quot;
4655                                       &quot;!= number of slots&quot;);
4656                  result = 0;
4657                  goto end_move;
4658              }
4659              if (simulate) {
4660                  for (i = 0; i &lt; table_len; i++) printf(&quot;#&quot;);
4661              } else {
4662                  int opts = CLUSTER_MANAGER_OPT_QUIET |
4663                             CLUSTER_MANAGER_OPT_UPDATE;
4664                  listRewind(table, &amp;li);
4665                  while ((ln = listNext(&amp;li)) != NULL) {
4666                      clusterManagerReshardTableItem *item = ln-&gt;value;
4667                      result = clusterManagerMoveSlot(item-&gt;source,
4668                                                      dst,
4669                                                      item-&gt;slot,
4670                                                      opts, NULL);
4671                      if (!result) goto end_move;
4672                      printf(&quot;#&quot;);
4673                      fflush(stdout);
4674                  }
4675              }
4676              printf(&quot;\n&quot;);
4677  end_move:
4678              clusterManagerReleaseReshardTable(table);
4679              if (!result) goto cleanup;
4680          }
4681          dst-&gt;balance += numslots;
4682          src-&gt;balance -= numslots;
4683          if (dst-&gt;balance == 0) dst_idx++;
4684          if (src-&gt;balance == 0) src_idx --;
4685      }
4686  cleanup:
4687      if (involved != NULL) listRelease(involved);
4688      if (weightedNodes != NULL) zfree(weightedNodes);
4689      return result;
4690  invalid_args:
4691      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4692      return 0;
4693  }
4694  static int clusterManagerCommandSetTimeout(int argc, char **argv) {
4695      UNUSED(argc);
4696      int port = 0;
4697      char *ip = NULL;
4698      if (!getClusterHostFromCmdArgs(1, argv, &amp;ip, &amp;port)) goto invalid_args;
4699      int timeout = atoi(argv[1]);
4700      if (timeout &lt; 100) {
4701          fprintf(stderr, &quot;Setting a node timeout of less than 100 &quot;
4702                  &quot;milliseconds is a bad idea.\n&quot;);
4703          return 0;
4704      }
4705      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4706      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4707      int ok_count = 0, err_count = 0;
4708      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Reconfiguring node timeout in every &quot;
4709                            &quot;cluster node...\n&quot;);
4710      listIter li;
4711      listNode *ln;
4712      listRewind(cluster_manager.nodes, &amp;li);
4713      while ((ln = listNext(&amp;li)) != NULL) {
4714          clusterManagerNode *n = ln-&gt;value;
4715          char *err = NULL;
4716          redisReply *reply = CLUSTER_MANAGER_COMMAND(n, &quot;CONFIG %s %s %d&quot;,
4717                                                      &quot;SET&quot;,
4718                                                      &quot;cluster-node-timeout&quot;,
4719                                                      timeout);
4720          if (reply == NULL) goto reply_err;
4721          int ok = clusterManagerCheckRedisReply(n, reply, &amp;err);
4722          freeReplyObject(reply);
4723          if (!ok) goto reply_err;
4724          reply = CLUSTER_MANAGER_COMMAND(n, &quot;CONFIG %s&quot;, &quot;REWRITE&quot;);
4725          if (reply == NULL) goto reply_err;
4726          ok = clusterManagerCheckRedisReply(n, reply, &amp;err);
4727          freeReplyObject(reply);
4728          if (!ok) goto reply_err;
4729          clusterManagerLogWarn(&quot;*** New timeout set for %s:%d\n&quot;, n-&gt;ip,
4730                                n-&gt;port);
4731          ok_count++;
4732          continue;
4733  reply_err:;
4734          int need_free = 0;
4735          if (err == NULL) err = &quot;&quot;;
4736          else need_free = 1;
4737          clusterManagerLogErr(&quot;ERR setting node-timeot for %s:%d: %s\n&quot;, n-&gt;ip,
4738                               n-&gt;port, err);
4739          if (need_free) zfree(err);
4740          err_count++;
4741      }
4742      clusterManagerLogInfo(&quot;&gt;&gt;&gt; New node timeout set. %d OK, %d ERR.\n&quot;,
4743                            ok_count, err_count);
4744      return 1;
4745  invalid_args:
4746      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4747      return 0;
4748  }
4749  static int clusterManagerCommandImport(int argc, char **argv) {
4750      int success = 1;
4751      int port = 0, src_port = 0;
4752      char *ip = NULL, *src_ip = NULL;
4753      char *invalid_args_msg = NULL;
4754      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) {
4755          invalid_args_msg = CLUSTER_MANAGER_INVALID_HOST_ARG;
4756          goto invalid_args;
4757      }
4758      if (config.cluster_manager_command.from == NULL) {
4759          invalid_args_msg = &quot;[ERR] Option &#x27;--cluster-from&#x27; is required for &quot;
4760                             &quot;subcommand &#x27;import&#x27;.\n&quot;;
4761          goto invalid_args;
4762      }
4763      char *src_host[] = {config.cluster_manager_command.from};
4764      if (!getClusterHostFromCmdArgs(1, src_host, &amp;src_ip, &amp;src_port)) {
4765          invalid_args_msg = &quot;[ERR] Invalid --cluster-from host. You need to &quot;
4766                             &quot;pass a valid address (ie. 120.0.0.1:7000).\n&quot;;
4767          goto invalid_args;
4768      }
4769      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Importing data from %s:%d to cluster %s:%d\n&quot;,
4770                            src_ip, src_port, ip, port);
4771      clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
4772      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4773      if (!clusterManagerCheckCluster(0)) return 0;
4774      char *reply_err = NULL;
4775      redisReply *src_reply = NULL;
4776      redisContext *src_ctx = redisConnect(src_ip, src_port);
4777      if (src_ctx-&gt;err) {
4778          success = 0;
4779          fprintf(stderr,&quot;Could not connect to Redis at %s:%d: %s.\n&quot;, src_ip,
4780                  src_port, src_ctx-&gt;errstr);
4781          goto cleanup;
4782      }
4783      src_reply = reconnectingRedisCommand(src_ctx, &quot;INFO&quot;);
4784      if (!src_reply || src_reply-&gt;type == REDIS_REPLY_ERROR) {
4785          if (src_reply &amp;&amp; src_reply-&gt;str) reply_err = src_reply-&gt;str;
4786          success = 0;
4787          goto cleanup;
4788      }
4789      if (getLongInfoField(src_reply-&gt;str, &quot;cluster_enabled&quot;)) {
4790          clusterManagerLogErr(&quot;[ERR] The source node should not be a &quot;
4791                               &quot;cluster node.\n&quot;);
4792          success = 0;
4793          goto cleanup;
4794      }
4795      freeReplyObject(src_reply);
4796      src_reply = reconnectingRedisCommand(src_ctx, &quot;DBSIZE&quot;);
4797      if (!src_reply || src_reply-&gt;type == REDIS_REPLY_ERROR) {
4798          if (src_reply &amp;&amp; src_reply-&gt;str) reply_err = src_reply-&gt;str;
4799          success = 0;
4800          goto cleanup;
4801      }
4802      int size = src_reply-&gt;integer, i;
4803      clusterManagerLogWarn(&quot;*** Importing %d keys from DB 0\n&quot;, size);
4804      clusterManagerNode  *slots_map[CLUSTER_MANAGER_SLOTS];
4805      memset(slots_map, 0, sizeof(slots_map));
4806      listIter li;
4807      listNode *ln;
4808      for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
4809          listRewind(cluster_manager.nodes, &amp;li);
4810          while ((ln = listNext(&amp;li)) != NULL) {
4811              clusterManagerNode *n = ln-&gt;value;
4812              if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
4813              if (n-&gt;slots_count == 0) continue;
4814              if (n-&gt;slots[i]) {
4815                  slots_map[i] = n;
4816                  break;
4817              }
4818          }
4819      }
4820      char cmdfmt[50] = &quot;MIGRATE %s %d %s %d %d&quot;;
4821      if (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_COPY)
4822          strcat(cmdfmt, &quot; %s&quot;);
4823      if (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_REPLACE)
4824          strcat(cmdfmt, &quot; %s&quot;);
4825      int cursor = -999, timeout = config.cluster_manager_command.timeout;
4826      while (cursor != 0) {
4827          if (cursor &lt; 0) cursor = 0;
4828          freeReplyObject(src_reply);
4829          src_reply = reconnectingRedisCommand(src_ctx, &quot;SCAN %d COUNT %d&quot;,
4830                                               cursor, 1000);
4831          if (!src_reply || src_reply-&gt;type == REDIS_REPLY_ERROR) {
4832              if (src_reply &amp;&amp; src_reply-&gt;str) reply_err = src_reply-&gt;str;
4833              success = 0;
4834              goto cleanup;
4835          }
4836          assert(src_reply-&gt;type == REDIS_REPLY_ARRAY);
4837          assert(src_reply-&gt;elements &gt;= 2);
4838          assert(src_reply-&gt;element[1]-&gt;type == REDIS_REPLY_ARRAY);
4839          if (src_reply-&gt;element[0]-&gt;type == REDIS_REPLY_STRING)
4840              cursor = atoi(src_reply-&gt;element[0]-&gt;str);
4841          else if (src_reply-&gt;element[0]-&gt;type == REDIS_REPLY_INTEGER)
4842              cursor = src_reply-&gt;element[0]-&gt;integer;
4843          int keycount = src_reply-&gt;element[1]-&gt;elements;
4844          for (i = 0; i &lt; keycount; i++) {
4845              redisReply *kr = src_reply-&gt;element[1]-&gt;element[i];
4846              assert(kr-&gt;type == REDIS_REPLY_STRING);
4847              char *key = kr-&gt;str;
4848              uint16_t slot = clusterManagerKeyHashSlot(key, kr-&gt;len);
4849              clusterManagerNode *target = slots_map[slot];
4850              printf(&quot;Migrating %s to %s:%d: &quot;, key, target-&gt;ip, target-&gt;port);
4851              redisReply *r = reconnectingRedisCommand(src_ctx, cmdfmt,
4852                                                       target-&gt;ip, target-&gt;port,
4853                                                       key, 0, timeout,
4854                                                       &quot;COPY&quot;, &quot;REPLACE&quot;);
4855              if (!r || r-&gt;type == REDIS_REPLY_ERROR) {
4856                  if (r &amp;&amp; r-&gt;str) {
4857                      clusterManagerLogErr(&quot;Source %s:%d replied with &quot;
4858                                           &quot;error:\n%s\n&quot;, src_ip, src_port,
4859                                           r-&gt;str);
4860                  }
4861                  success = 0;
4862              }
4863              freeReplyObject(r);
4864              if (!success) goto cleanup;
4865              clusterManagerLogOk(&quot;OK\n&quot;);
4866          }
4867      }
4868  cleanup:
4869      if (reply_err)
4870          clusterManagerLogErr(&quot;Source %s:%d replied with error:\n%s\n&quot;,
4871                               src_ip, src_port, reply_err);
4872      if (src_ctx) redisFree(src_ctx);
4873      if (src_reply) freeReplyObject(src_reply);
4874      return success;
4875  invalid_args:
4876      fprintf(stderr, &quot;%s&quot;, invalid_args_msg);
4877      return 0;
4878  }
4879  static int clusterManagerCommandCall(int argc, char **argv) {
4880      int port = 0, i;
4881      char *ip = NULL;
4882      if (!getClusterHostFromCmdArgs(1, argv, &amp;ip, &amp;port)) goto invalid_args;
4883      clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
4884      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4885      argc--;
4886      argv++;
4887      size_t *argvlen = zmalloc(argc*sizeof(size_t));
4888      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Calling&quot;);
4889      for (i = 0; i &lt; argc; i++) {
4890          argvlen[i] = strlen(argv[i]);
4891          printf(&quot; %s&quot;, argv[i]);
4892      }
4893      printf(&quot;\n&quot;);
4894      listIter li;
4895      listNode *ln;
4896      listRewind(cluster_manager.nodes, &amp;li);
4897      while ((ln = listNext(&amp;li)) != NULL) {
4898          clusterManagerNode *n = ln-&gt;value;
4899          if (!n-&gt;context &amp;&amp; !clusterManagerNodeConnect(n)) continue;
4900          redisReply *reply = NULL;
4901          redisAppendCommandArgv(n-&gt;context, argc, (const char **) argv, argvlen);
4902          int status = redisGetReply(n-&gt;context, (void **)(&amp;reply));
4903          if (status != REDIS_OK || reply == NULL )
4904              printf(&quot;%s:%d: Failed!\n&quot;, n-&gt;ip, n-&gt;port);
4905          else {
4906              sds formatted_reply = cliFormatReplyRaw(reply);
4907              printf(&quot;%s:%d: %s\n&quot;, n-&gt;ip, n-&gt;port, (char *) formatted_reply);
4908              sdsfree(formatted_reply);
4909          }
4910          if (reply != NULL) freeReplyObject(reply);
4911      }
4912      zfree(argvlen);
4913      return 1;
4914  invalid_args:
4915      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4916      return 0;
4917  }
4918  static int clusterManagerCommandHelp(int argc, char **argv) {
4919      UNUSED(argc);
4920      UNUSED(argv);
4921      int commands_count = sizeof(clusterManagerCommands) /
4922                           sizeof(clusterManagerCommandDef);
4923      int i = 0, j;
4924      fprintf(stderr, &quot;Cluster Manager Commands:\n&quot;);
4925      int padding = 15;
4926      for (; i &lt; commands_count; i++) {
4927          clusterManagerCommandDef *def = &amp;(clusterManagerCommands[i]);
4928          int namelen = strlen(def-&gt;name), padlen = padding - namelen;
4929          fprintf(stderr, &quot;  %s&quot;, def-&gt;name);
4930          for (j = 0; j &lt; padlen; j++) fprintf(stderr, &quot; &quot;);
4931          fprintf(stderr, &quot;%s\n&quot;, (def-&gt;args ? def-&gt;args : &quot;&quot;));
4932          if (def-&gt;options != NULL) {
4933              int optslen = strlen(def-&gt;options);
4934              char *p = def-&gt;options, *eos = p + optslen;
4935              char *comma = NULL;
4936              while ((comma = strchr(p, &#x27;,&#x27;)) != NULL) {
4937                  int deflen = (int)(comma - p);
4938                  char buf[255];
4939                  memcpy(buf, p, deflen);
4940                  buf[deflen] = &#x27;\0&#x27;;
4941                  for (j = 0; j &lt; padding; j++) fprintf(stderr, &quot; &quot;);
4942                  fprintf(stderr, &quot;  --cluster-%s\n&quot;, buf);
4943                  p = comma + 1;
4944                  if (p &gt;= eos) break;
4945              }
4946              if (p &lt; eos) {
4947                  for (j = 0; j &lt; padding; j++) fprintf(stderr, &quot; &quot;);
4948                  fprintf(stderr, &quot;  --cluster-%s\n&quot;, p);
4949              }
4950          }
4951      }
4952      fprintf(stderr, &quot;\nFor check, fix, reshard, del-node, set-timeout you &quot;
4953                      &quot;can specify the host and port of any working node in &quot;
4954                      &quot;the cluster.\n\n&quot;);
4955      return 0;
4956  }
4957  static void latencyModePrint(PORT_LONGLONG min, PORT_LONGLONG max, double avg, PORT_LONGLONG count) {
4958      if (config.output == OUTPUT_STANDARD) {
4959          printf(&quot;min: %lld, max: %lld, avg: %.2f (%lld samples)&quot;,
4960                  min, max, avg, count);
4961          fflush(stdout);
4962      } else if (config.output == OUTPUT_CSV) {
4963          printf(&quot;%lld,%lld,%.2f,%lld\n&quot;, min, max, avg, count);
4964      } else if (config.output == OUTPUT_RAW) {
4965          printf(&quot;%lld %lld %.2f %lld\n&quot;, min, max, avg, count);
4966      }
4967  }
4968  #define LATENCY_SAMPLE_RATE 10 &amp;bsol;* milliseconds. */
4969  #define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 &amp;bsol;* milliseconds. */
4970  static void latencyMode(void) {
4971      redisReply *reply;
4972      PORT_LONGLONG start, latency, min = 0, max = 0, tot = 0, count = 0;
4973      PORT_LONGLONG history_interval =
4974          config.interval ? config.interval/1000 :
4975                            LATENCY_HISTORY_DEFAULT_INTERVAL;
4976      double avg;
4977      PORT_LONGLONG history_start = mstime();
4978      if (config.interval == 0) {
4979          config.interval = 1000;
4980      } else {
4981          config.interval /= 1000; &amp;bsol;* We need to convert to milliseconds. */
4982      }
4983      if (!context) exit(1);
4984      while(1) {
4985          start = mstime();
4986          reply = reconnectingRedisCommand(context,&quot;PING&quot;);
4987          if (reply == NULL) {
4988              fprintf(stderr,&quot;\nI/O error\n&quot;);
4989              exit(1);
4990          }
4991          latency = mstime()-start;
4992          freeReplyObject(reply);
4993          count++;
4994          if (count == 1) {
4995              min = max = tot = latency;
4996              avg = (double) latency;
4997          } else {
4998              if (latency &lt; min) min = latency;
4999              if (latency &gt; max) max = latency;
5000              tot += latency;
5001              avg = (double) tot/count;
5002          }
5003          if (config.output == OUTPUT_STANDARD) {
5004              printf(&quot;\x1b[0G\x1b[2K&quot;); &amp;bsol;* Clear the line. */
5005              latencyModePrint(min,max,avg,count);
5006          } else {
5007              if (config.latency_history) {
5008                  latencyModePrint(min,max,avg,count);
5009              } else if (mstime()-history_start &gt; config.interval) {
5010                  latencyModePrint(min,max,avg,count);
5011                  exit(0);
5012              }
5013          }
5014          if (config.latency_history &amp;&amp; mstime()-history_start &gt; history_interval)
5015          {
5016              printf(&quot; -- %.2f seconds range\n&quot;, (float)(mstime()-history_start)/1000);
5017              history_start = mstime();
5018              min = max = tot = count = 0;
5019          }
5020          usleep(LATENCY_SAMPLE_RATE * 1000);
5021      }
5022  }
5023  #define LATENCY_DIST_DEFAULT_INTERVAL 1000 &amp;bsol;* milliseconds. */
5024  struct distsamples {
5025      PORT_LONGLONG max;   &amp;bsol;* Max latency to fit into this interval (usec). */
5026      PORT_LONGLONG count; &amp;bsol;* Number of samples in this interval. */
5027      int character;   &amp;bsol;* Associated character in visualization. */
5028  };
5029  void showLatencyDistSamples(struct distsamples *samples, PORT_LONGLONG tot) {
5030      int j;
5031      printf(&quot;\033[38;5;0m&quot;); &amp;bsol;* Set foreground color to black. */
5032      for (j = 0; ; j++) {
5033          int coloridx =
5034              (int) ceil((float) samples[j].count / tot * (spectrum_palette_size-1));  WIN_PORT_FIX &amp;bsol;* cast (int) */
5035          int color = spectrum_palette[coloridx];
5036          printf(&quot;\033[48;5;%dm%c&quot;, (int)color, samples[j].character);
5037          samples[j].count = 0;
5038          if (samples[j].max == 0) break; &amp;bsol;* Last sample. */
5039      }
5040      printf(&quot;\033[0m\n&quot;);
5041      fflush(stdout);
5042  }
5043  void showLatencyDistLegend(void) {
5044      int j;
5045      printf(&quot;---------------------------------------------\n&quot;);
5046      printf(&quot;. - * #          .01 .125 .25 .5 milliseconds\n&quot;);
5047      printf(&quot;1,2,3,...,9      from 1 to 9     milliseconds\n&quot;);
5048      printf(&quot;A,B,C,D,E        10,20,30,40,50  milliseconds\n&quot;);
5049      printf(&quot;F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n&quot;);
5050      printf(&quot;K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,&gt;60 seconds\n&quot;);
5051      printf(&quot;From 0 to 100%%: &quot;);
5052      for (j = 0; j &lt; spectrum_palette_size; j++) {
5053          printf(&quot;\033[48;5;%dm &quot;, spectrum_palette[j]);
5054      }
5055      printf(&quot;\033[0m\n&quot;);
5056      printf(&quot;---------------------------------------------\n&quot;);
5057  }
5058  static void latencyDistMode(void) {
5059      redisReply *reply;
5060      PORT_LONGLONG start, latency, count = 0;
5061      PORT_LONGLONG history_interval =
5062          config.interval ? config.interval/1000 :
5063                            LATENCY_DIST_DEFAULT_INTERVAL;
5064      PORT_LONGLONG history_start = ustime();
5065      int j, outputs = 0;
5066      struct distsamples samples[] = {
5067          {10,0,&#x27;.&#x27;},         &amp;bsol;* 0.01 ms */
5068          {125,0,&#x27;-&#x27;},        &amp;bsol;* 0.125 ms */
5069          {250,0,&#x27;*&#x27;},        &amp;bsol;* 0.25 ms */
5070          {500,0,&#x27;#&#x27;},        &amp;bsol;* 0.5 ms */
5071          {1000,0,&#x27;1&#x27;},       &amp;bsol;* 1 ms */
5072          {2000,0,&#x27;2&#x27;},       &amp;bsol;* 2 ms */
5073          {3000,0,&#x27;3&#x27;},       &amp;bsol;* 3 ms */
5074          {4000,0,&#x27;4&#x27;},       &amp;bsol;* 4 ms */
5075          {5000,0,&#x27;5&#x27;},       &amp;bsol;* 5 ms */
5076          {6000,0,&#x27;6&#x27;},       &amp;bsol;* 6 ms */
5077          {7000,0,&#x27;7&#x27;},       &amp;bsol;* 7 ms */
5078          {8000,0,&#x27;8&#x27;},       &amp;bsol;* 8 ms */
5079          {9000,0,&#x27;9&#x27;},       &amp;bsol;* 9 ms */
5080          {10000,0,&#x27;A&#x27;},      &amp;bsol;* 10 ms */
5081          {20000,0,&#x27;B&#x27;},      &amp;bsol;* 20 ms */
5082          {30000,0,&#x27;C&#x27;},      &amp;bsol;* 30 ms */
5083          {40000,0,&#x27;D&#x27;},      &amp;bsol;* 40 ms */
5084          {50000,0,&#x27;E&#x27;},      &amp;bsol;* 50 ms */
5085          {100000,0,&#x27;F&#x27;},     &amp;bsol;* 0.1 s */
5086          {200000,0,&#x27;G&#x27;},     &amp;bsol;* 0.2 s */
5087          {300000,0,&#x27;H&#x27;},     &amp;bsol;* 0.3 s */
5088          {400000,0,&#x27;I&#x27;},     &amp;bsol;* 0.4 s */
5089          {500000,0,&#x27;J&#x27;},     &amp;bsol;* 0.5 s */
5090          {1000000,0,&#x27;K&#x27;},    &amp;bsol;* 1 s */
5091          {2000000,0,&#x27;L&#x27;},    &amp;bsol;* 2 s */
5092          {4000000,0,&#x27;M&#x27;},    &amp;bsol;* 4 s */
5093          {8000000,0,&#x27;N&#x27;},    &amp;bsol;* 8 s */
5094          {16000000,0,&#x27;O&#x27;},   &amp;bsol;* 16 s */
5095          {30000000,0,&#x27;P&#x27;},   &amp;bsol;* 30 s */
5096          {60000000,0,&#x27;Q&#x27;},   &amp;bsol;* 1 minute */
5097          {0,0,&#x27;?&#x27;},          &amp;bsol;* &gt; 1 minute */
5098      };
5099      if (!context) exit(1);
5100      while(1) {
5101          start = ustime();
5102          reply = reconnectingRedisCommand(context,&quot;PING&quot;);
5103          if (reply == NULL) {
5104              fprintf(stderr,&quot;\nI/O error\n&quot;);
5105              exit(1);
5106          }
5107          latency = ustime()-start;
5108          freeReplyObject(reply);
5109          count++;
5110          for (j = 0; ; j++) {
5111              if (samples[j].max == 0 || latency &lt;= samples[j].max) {
5112                  samples[j].count++;
5113                  break;
5114              }
5115          }
5116          if (count &amp;&amp; (ustime()-history_start)/1000 &gt; history_interval) {
5117              if ((outputs++ % 20) == 0)
5118                  showLatencyDistLegend();
5119              showLatencyDistSamples(samples,count);
5120              history_start = ustime();
5121              count = 0;
5122          }
5123          usleep(LATENCY_SAMPLE_RATE * 1000);
5124      }
5125  }
5126  PORT_ULONGLONG sendSync(int fd) {
5127      char buf[4096], *p;
5128      ssize_t nread;
5129      if (write(fd,&quot;SYNC\r\n&quot;,6) != 6) {
5130          fprintf(stderr,&quot;Error writing to master\n&quot;);
5131          exit(1);
5132      }
5133      p = buf;
5134      while(1) {
5135          nread = read(fd,p,1);
5136          if (nread &lt;= 0) {
5137              fprintf(stderr,&quot;Error reading bulk length while SYNCing\n&quot;);
5138              exit(1);
5139          }
5140          if (*p == &#x27;\n&#x27; &amp;&amp; p != buf) break;
5141          if (*p != &#x27;\n&#x27;) p++;
5142      }
5143      *p = &#x27;\0&#x27;;
5144      if (buf[0] == &#x27;-&#x27;) {
5145          printf(&quot;SYNC with master failed: %s\n&quot;, buf);
5146          exit(1);
5147      }
5148      return strtoull(buf+1,NULL,10);
5149  }
5150  static void slaveMode(void) {
5151      int fd = context-&gt;fd;
5152      PORT_ULONGLONG payload = sendSync(fd);
5153      char buf[1024];
5154      int original_output = config.output;
5155      fprintf(stderr,&quot;SYNC with master, discarding %llu &quot;
5156                     &quot;bytes of bulk transfer...\n&quot;, payload);
5157      while(payload) {
5158          ssize_t nread;
5159          nread = read(fd,buf,(payload &gt; sizeof(buf)) ? sizeof(buf) : payload);
5160          if (nread &lt;= 0) {
5161              fprintf(stderr,&quot;Error reading RDB payload while SYNCing\n&quot;);
5162              exit(1);
5163          }
5164          payload -= nread;
5165      }
5166      fprintf(stderr,&quot;SYNC done. Logging commands from master.\n&quot;);
5167      config.output = OUTPUT_CSV;
5168      while (cliReadReply(0) == REDIS_OK);
5169      config.output = original_output;
5170  }
5171  static void getRDB(void) {
5172      int s = context-&gt;fd;
5173      int fd;
5174      PORT_ULONGLONG payload = sendSync(s);
5175      char buf[4096];
5176      fprintf(stderr,&quot;SYNC sent to master, writing %llu bytes to &#x27;%s&#x27;\n&quot;,
5177          payload, config.rdb_filename);
5178      if (!strcmp(config.rdb_filename,&quot;-&quot;)) {
5179          fd = STDOUT_FILENO;
5180      } else {
5181          fd = open(config.rdb_filename, O_CREAT|O_WRONLY, 0644);
5182          if (fd == -1) {
5183              fprintf(stderr, &quot;Error opening &#x27;%s&#x27;: %s\n&quot;, config.rdb_filename,
5184                  strerror(errno));
5185              exit(1);
5186          }
5187      }
5188      while(payload) {
5189          ssize_t nread, nwritten;
5190          nread = read(s,buf,(payload &gt; sizeof(buf)) ? sizeof(buf) : payload);
5191          if (nread &lt;= 0) {
5192              fprintf(stderr,&quot;I/O Error reading RDB payload from socket\n&quot;);
5193              exit(1);
5194          }
5195          nwritten = write(fd, buf, nread);
5196          if (nwritten != nread) {
5197              fprintf(stderr,&quot;Error writing data to file: %s\n&quot;,
5198                  (nwritten == -1) ? IF_WIN32(wsa_strerror(errno), strerror(errno)) : &quot;short write&quot;);
5199              exit(1);
5200          }
5201          payload -= nread;
5202      }
5203      close(s); &amp;bsol;* Close the file descriptor ASAP as fsync() may take time. */
5204      fsync(fd);
5205      close(fd);
5206      fprintf(stderr,&quot;Transfer finished with success.\n&quot;);
5207      exit(0);
5208  }
5209  #define PIPEMODE_WRITE_LOOP_MAX_BYTES (128*1024)
5210  static void pipeMode(void) {
5211      int fd = (int)context-&gt;fd;
5212      PORT_LONGLONG errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;
5213      char ibuf[1024*16], obuf[1024*16]; &amp;bsol;* Input and output buffers */
5214      char aneterr[ANET_ERR_LEN];
5215      redisReader *reader = redisReaderCreate();
5216      redisReply *reply;
5217      int eof = 0; &amp;bsol;* True once we consumed all the standard input. */
5218      int done = 0;
5219      char magic[20]; &amp;bsol;* Special reply we recognize. */
5220      time_t last_read_time = time(NULL);
5221  #ifdef _WIN32
5222      setmode(STDIN_FILENO, _O_BINARY);
5223  #endif
5224      srand((unsigned int) time(NULL));                                            WIN_PORT_FIX &amp;bsol;* cast unsigned int */
5225      if (anetNonBlock(aneterr,fd) == ANET_ERR) {
5226          fprintf(stderr, &quot;Can&#x27;t set the socket in non blocking mode: %s\n&quot;,
5227              aneterr);
5228          exit(1);
5229      }
5230      while(!done) {
5231          int mask = AE_READABLE;
5232          if (!eof || obuf_len != 0) mask |= AE_WRITABLE;
5233          mask = aeWait(fd,mask,1000);
5234          if (mask &amp; AE_READABLE) {
5235              ssize_t nread;
5236              int read_error = 0;
5237              do {
5238                  nread = read(fd,ibuf,sizeof(ibuf));
5239                  if (nread == -1 &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR) {
5240                      fprintf(stderr, &quot;Error reading from the server: %s\n&quot;,
5241                          strerror(errno));
5242                      read_error = 1;
5243                      break;
5244                  }
5245                  if (nread &gt; 0) {
5246                      redisReaderFeed(reader,ibuf,nread);
5247                      last_read_time = time(NULL);
5248                  }
5249              } while(nread &gt; 0);
5250              do {
5251                  if (redisReaderGetReply(reader,(void**)&amp;reply) == REDIS_ERR) {
5252                      fprintf(stderr, &quot;Error reading replies from server\n&quot;);
5253                      exit(1);
5254                  }
5255                  if (reply) {
5256                      if (reply-&gt;type == REDIS_REPLY_ERROR) {
5257                          fprintf(stderr,&quot;%s\n&quot;, reply-&gt;str);
5258                          errors++;
5259                      } else if (eof &amp;&amp; reply-&gt;type == REDIS_REPLY_STRING &amp;&amp;
5260                                        reply-&gt;len == 20) {
5261                          if (memcmp(reply-&gt;str,magic,20) == 0) {
5262                              printf(&quot;Last reply received from server.\n&quot;);
5263                              done = 1;
5264                              replies--;
5265                          }
5266                      }
5267                      replies++;
5268                      freeReplyObject(reply);
5269                  }
5270              } while(reply);
5271              if (read_error) exit(1);
5272          }
5273          if (mask &amp; AE_WRITABLE) {
5274              ssize_t loop_nwritten = 0;
5275              while(1) {
5276                  if (obuf_len != 0) {
5277                      ssize_t nwritten = write(fd,obuf+obuf_pos,obuf_len);
5278                      if (nwritten == -1) {
5279                          if (errno != EAGAIN &amp;&amp; errno != EINTR) {
5280                              fprintf(stderr, &quot;Error writing to the server: %s\n&quot;,
5281                                  strerror(errno));
5282                              exit(1);
5283                          } else {
5284                              nwritten = 0;
5285                          }
5286                      }
5287                      obuf_len -= nwritten;
5288                      obuf_pos += nwritten;
5289                      loop_nwritten += nwritten;
5290                      if (obuf_len != 0) break; &amp;bsol;* Can&#x27;t accept more data. */
5291                  }
5292                  if (obuf_len == 0 &amp;&amp; !eof) {
5293                      ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));
5294                      if (nread == 0) {
5295                          char echo[] =
5296                          &quot;\r\n*2\r\n$4\r\nECHO\r\n$20\r\n01234567890123456789\r\n&quot;;
5297                          int j;
5298                          eof = 1;
5299                          for (j = 0; j &lt; 20; j++)
5300                              magic[j] = rand() &amp; 0xff;
5301                          memcpy(echo+21,magic,20);
5302                          memcpy(obuf,echo,sizeof(echo)-1);
5303                          obuf_len = sizeof(echo)-1;
5304                          obuf_pos = 0;
5305                          printf(&quot;All data transferred. Waiting for the last reply...\n&quot;);
5306                      } else if (nread == -1) {
5307                          fprintf(stderr, &quot;Error reading from stdin: %s\n&quot;,
5308                              strerror(errno));
5309                          exit(1);
5310                      } else {
5311                          obuf_len = nread;
5312                          obuf_pos = 0;
5313                      }
5314                  }
5315                  if ((obuf_len == 0 &amp;&amp; eof) ||
5316                      loop_nwritten &gt; PIPEMODE_WRITE_LOOP_MAX_BYTES) break;
5317              }
5318          }
5319          if (eof &amp;&amp; config.pipe_timeout &gt; 0 &amp;&amp;
5320              time(NULL)-last_read_time &gt; config.pipe_timeout)
5321          {
5322              fprintf(stderr,&quot;No replies for %d seconds: exiting.\n&quot;,
5323                  config.pipe_timeout);
5324              errors++;
5325              break;
5326          }
5327      }
5328      redisReaderFree(reader);
5329      printf(&quot;errors: %lld, replies: %lld\n&quot;, errors, replies);
5330      if (errors)
5331          exit(1);
5332      else
5333          exit(0);
5334  }
5335  static redisReply *sendScan(PORT_ULONGLONG *it) {
5336      redisReply *reply = redisCommand(context, &quot;SCAN %llu&quot;, *it);
5337      if(reply == NULL) {
5338          fprintf(stderr, &quot;\nI/O error\n&quot;);
5339          exit(1);
5340      } else if(reply-&gt;type == REDIS_REPLY_ERROR) {
5341          fprintf(stderr, &quot;SCAN error: %s\n&quot;, reply-&gt;str);
5342          exit(1);
5343      } else if(reply-&gt;type != REDIS_REPLY_ARRAY) {
5344          fprintf(stderr, &quot;Non ARRAY response from SCAN!\n&quot;);
5345          exit(1);
5346      } else if(reply-&gt;elements != 2) {
5347          fprintf(stderr, &quot;Invalid element count from SCAN!\n&quot;);
5348          exit(1);
5349      }
5350      assert(reply-&gt;element[0]-&gt;type == REDIS_REPLY_STRING);
5351      assert(reply-&gt;element[1]-&gt;type == REDIS_REPLY_ARRAY);
5352      *it = strtoull(reply-&gt;element[0]-&gt;str, NULL, 10);
5353      return reply;
5354  }
5355  static int getDbSize(void) {
5356      redisReply *reply;
5357      int size;
5358      reply = redisCommand(context, &quot;DBSIZE&quot;);
5359      if(reply == NULL || reply-&gt;type != REDIS_REPLY_INTEGER) {
5360          fprintf(stderr, &quot;Couldn&#x27;t determine DBSIZE!\n&quot;);
5361          exit(1);
5362      }
5363      size = reply-&gt;integer;
5364      freeReplyObject(reply);
5365      return size;
5366  }
5367  typedef struct {
5368      char *name;
5369      char *sizecmd;
5370      char *sizeunit;
5371      PORT_ULONGLONG biggest;
5372      PORT_ULONGLONG count;
5373      PORT_ULONGLONG totalsize;
5374      sds biggest_key;
5375  } typeinfo;
5376  typeinfo type_string = { &quot;string&quot;, &quot;STRLEN&quot;, &quot;bytes&quot; };
5377  typeinfo type_list = { &quot;list&quot;, &quot;LLEN&quot;, &quot;items&quot; };
5378  typeinfo type_set = { &quot;set&quot;, &quot;SCARD&quot;, &quot;members&quot; };
5379  typeinfo type_hash = { &quot;hash&quot;, &quot;HLEN&quot;, &quot;fields&quot; };
5380  typeinfo type_zset = { &quot;zset&quot;, &quot;ZCARD&quot;, &quot;members&quot; };
5381  typeinfo type_stream = { &quot;stream&quot;, &quot;XLEN&quot;, &quot;entries&quot; };
5382  typeinfo type_other = { &quot;other&quot;, NULL, &quot;?&quot; };
5383  static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {
5384      typeinfo *info = zmalloc(sizeof(typeinfo));
5385      *info = *type_template;
5386      info-&gt;name = sdsnew(name);
5387      dictAdd(types, info-&gt;name, info);
5388      return info;
5389  }
5390  void type_free(void* priv_data, void* val) {
5391      typeinfo *info = val;
5392      UNUSED(priv_data);
5393      if (info-&gt;biggest_key)
5394          sdsfree(info-&gt;biggest_key);
5395      sdsfree(info-&gt;name);
5396      zfree(info);
5397  }
5398  static dictType typeinfoDictType = {
5399      dictSdsHash,               &amp;bsol;* hash function */
5400      NULL,                      &amp;bsol;* key dup */
5401      NULL,                      &amp;bsol;* val dup */
5402      dictSdsKeyCompare,         &amp;bsol;* key compare */
5403      NULL,                      &amp;bsol;* key destructor (owned by the value)*/
5404      type_free                  &amp;bsol;* val destructor */
5405  };
5406  static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
5407      redisReply *reply;
5408      unsigned int i;
5409      for(i=0;i&lt;keys-&gt;elements;i++) {
5410          redisAppendCommand(context, &quot;TYPE %s&quot;, keys-&gt;element[i]-&gt;str);
5411      }
5412      for(i=0;i&lt;keys-&gt;elements;i++) {
5413          if(redisGetReply(context, (void**)&amp;reply)!=REDIS_OK) {
5414              fprintf(stderr, &quot;Error getting type for key &#x27;%s&#x27; (%d: %s)\n&quot;,
5415                  keys-&gt;element[i]-&gt;str, context-&gt;err, context-&gt;errstr);
5416              exit(1);
5417          } else if(reply-&gt;type != REDIS_REPLY_STATUS) {
5418              if(reply-&gt;type == REDIS_REPLY_ERROR) {
5419                  fprintf(stderr, &quot;TYPE returned an error: %s\n&quot;, reply-&gt;str);
5420              } else {
5421                  fprintf(stderr,
5422                      &quot;Invalid reply type (%d) for TYPE on key &#x27;%s&#x27;!\n&quot;,
5423                      reply-&gt;type, keys-&gt;element[i]-&gt;str);
5424              }
5425              exit(1);
5426          }
5427          sds typereply = sdsnew(reply-&gt;str);
5428          dictEntry *de = dictFind(types_dict, typereply);
5429          sdsfree(typereply);
5430          typeinfo *type = NULL;
5431          if (de)
5432              type = dictGetVal(de);
5433          else if (strcmp(reply-&gt;str, &quot;none&quot;)) &amp;bsol;* create new types for modules, (but not for deleted keys) */
5434              type = typeinfo_add(types_dict, reply-&gt;str, &amp;type_other);
5435          types[i] = type;
5436          freeReplyObject(reply);
5437      }
5438  }
5439  static void getKeySizes(redisReply *keys, typeinfo **types,
5440                          PORT_ULONGLONG *sizes, int memkeys,
5441                          unsigned memkeys_samples)
5442  {
5443      redisReply *reply;
5444      unsigned int i;
5445      for(i=0;i&lt;keys-&gt;elements;i++) {
5446          if(!types[i] || (!types[i]-&gt;sizecmd &amp;&amp; !memkeys))
5447              continue;
5448          if (!memkeys)
5449              redisAppendCommand(context, &quot;%s %s&quot;,
5450                  types[i]-&gt;sizecmd, keys-&gt;element[i]-&gt;str);
5451          else if (memkeys_samples==0)
5452              redisAppendCommand(context, &quot;%s %s %s&quot;,
5453                  &quot;MEMORY&quot;, &quot;USAGE&quot;, keys-&gt;element[i]-&gt;str);
5454          else
5455              redisAppendCommand(context, &quot;%s %s %s SAMPLES %u&quot;,
5456                  &quot;MEMORY&quot;, &quot;USAGE&quot;, keys-&gt;element[i]-&gt;str, memkeys_samples);
5457      }
5458      for(i=0;i&lt;keys-&gt;elements;i++) {
5459          if(!types[i] || (!types[i]-&gt;sizecmd &amp;&amp; !memkeys)) {
5460              sizes[i] = 0;
5461              continue;
5462          }
5463          if(redisGetReply(context, (void**)&amp;reply)!=REDIS_OK) {
5464              fprintf(stderr, &quot;Error getting size for key &#x27;%s&#x27; (%d: %s)\n&quot;,
5465                  keys-&gt;element[i]-&gt;str, context-&gt;err, context-&gt;errstr);
5466              exit(1);
5467          } else if(reply-&gt;type != REDIS_REPLY_INTEGER) {
5468              fprintf(stderr,
5469                  &quot;Warning:  %s on &#x27;%s&#x27; failed (may have changed type)\n&quot;,
5470                  !memkeys? types[i]-&gt;sizecmd: &quot;MEMORY USAGE&quot;,
5471                  keys-&gt;element[i]-&gt;str);
5472              sizes[i] = 0;
5473          } else {
5474              sizes[i] = reply-&gt;integer;
5475          }
5476          freeReplyObject(reply);
5477      }
5478  }
5479  static void findBigKeys(int memkeys, unsigned memkeys_samples) {
5480      PORT_ULONGLONG sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;
5481      redisReply *reply, *keys;
5482      unsigned int arrsize=0, i;
5483      dictIterator *di;
5484      dictEntry *de;
5485      typeinfo **types = NULL;
5486      double pct;
5487      dict *types_dict = dictCreate(&amp;typeinfoDictType, NULL);
5488      typeinfo_add(types_dict, &quot;string&quot;, &amp;type_string);
5489      typeinfo_add(types_dict, &quot;list&quot;, &amp;type_list);
5490      typeinfo_add(types_dict, &quot;set&quot;, &amp;type_set);
5491      typeinfo_add(types_dict, &quot;hash&quot;, &amp;type_hash);
5492      typeinfo_add(types_dict, &quot;zset&quot;, &amp;type_zset);
5493      typeinfo_add(types_dict, &quot;stream&quot;, &amp;type_stream);
5494      total_keys = getDbSize();
5495      printf(&quot;\n# Scanning the entire keyspace to find biggest keys as well as\n&quot;);
5496      printf(&quot;# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n&quot;);
5497      printf(&quot;# per 100 SCAN commands (not usually needed).\n\n&quot;);
5498      do {
5499          pct = 100 * (double)sampled/total_keys;
5500          reply = sendScan(&amp;it);
5501          keys  = reply-&gt;element[1];
5502          if(keys-&gt;elements &gt; arrsize) {
5503              types = zrealloc(types, sizeof(typeinfo*)*keys-&gt;elements);
5504              sizes = zrealloc(sizes, sizeof(PORT_ULONGLONG)*keys-&gt;elements);
5505              if(!types || !sizes) {
5506                  fprintf(stderr, &quot;Failed to allocate storage for keys!\n&quot;);
5507                  exit(1);
5508              }
5509              arrsize = keys-&gt;elements;
5510          }
5511          getKeyTypes(types_dict, keys, types);
5512          getKeySizes(keys, types, sizes, memkeys, memkeys_samples);
5513          for(i=0;i&lt;keys-&gt;elements;i++) {
5514              typeinfo *type = types[i];
5515              if(!type)
5516                  continue;
5517              type-&gt;totalsize += sizes[i];
5518              type-&gt;count++;
5519              totlen += keys-&gt;element[i]-&gt;len;
5520              sampled++;
5521              if(type-&gt;biggest&lt;sizes[i]) {
5522                  printf(
5523                     &quot;[%05.2f%%] Biggest %-6s found so far &#x27;%s&#x27; with %llu %s\n&quot;,
5524                     pct, type-&gt;name, keys-&gt;element[i]-&gt;str, sizes[i],
5525                     !memkeys? type-&gt;sizeunit: &quot;bytes&quot;);
5526                  if (type-&gt;biggest_key)
5527                      sdsfree(type-&gt;biggest_key);
5528                  type-&gt;biggest_key = sdsnew(keys-&gt;element[i]-&gt;str);
5529                  if(!type-&gt;biggest_key) {
5530                      fprintf(stderr, &quot;Failed to allocate memory for key!\n&quot;);
5531                      exit(1);
5532                  }
5533                  type-&gt;biggest = sizes[i];
5534              }
5535              if(sampled % 1000000 == 0) {
5536                  printf(&quot;[%05.2f%%] Sampled %llu keys so far\n&quot;, pct, sampled);
5537              }
5538          }
5539          if(sampled &amp;&amp; (sampled %100) == 0 &amp;&amp; config.interval) {
5540              usleep(config.interval);
5541          }
5542          freeReplyObject(reply);
5543      } while(it != 0);
5544      if(types) zfree(types);
5545      if(sizes) zfree(sizes);
5546      printf(&quot;\n-------- summary -------\n\n&quot;);
5547      printf(&quot;Sampled %llu keys in the keyspace!\n&quot;, sampled);
5548      printf(&quot;Total key length in bytes is %llu (avg len %.2f)\n\n&quot;,
5549         totlen, totlen ? (double)totlen/sampled : 0);
5550      di = dictGetIterator(types_dict);
5551      while ((de = dictNext(di))) {
5552          typeinfo *type = dictGetVal(de);
5553          if(type-&gt;biggest_key) {
5554              printf(&quot;Biggest %6s found &#x27;%s&#x27; has %llu %s\n&quot;, type-&gt;name, type-&gt;biggest_key,
5555                 type-&gt;biggest, !memkeys? type-&gt;sizeunit: &quot;bytes&quot;);
5556          }
5557      }
5558      dictReleaseIterator(di);
5559      printf(&quot;\n&quot;);
5560      di = dictGetIterator(types_dict);
5561      while ((de = dictNext(di))) {
5562          typeinfo *type = dictGetVal(de);
5563          printf(&quot;%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\n&quot;,
5564             type-&gt;count, type-&gt;name, type-&gt;totalsize, !memkeys? type-&gt;sizeunit: &quot;bytes&quot;,
5565             sampled ? 100 * (double)type-&gt;count/sampled : 0,
5566             type-&gt;count ? (double)type-&gt;totalsize/type-&gt;count : 0);
5567      }
5568      dictReleaseIterator(di);
5569      dictRelease(types_dict);
5570      exit(0);
5571  }
5572  static void getKeyFreqs(redisReply *keys, PORT_ULONGLONG *freqs) {
5573      redisReply *reply;
5574      unsigned int i;
5575      for(i=0;i&lt;keys-&gt;elements;i++) {
5576          redisAppendCommand(context, &quot;OBJECT freq %s&quot;, keys-&gt;element[i]-&gt;str);
5577      }
5578      for(i=0;i&lt;keys-&gt;elements;i++) {
5579          if(redisGetReply(context, (void**)&amp;reply)!=REDIS_OK) {
5580              fprintf(stderr, &quot;Error getting freq for key &#x27;%s&#x27; (%d: %s)\n&quot;,
5581                  keys-&gt;element[i]-&gt;str, context-&gt;err, context-&gt;errstr);
5582              exit(1);
5583          } else if(reply-&gt;type != REDIS_REPLY_INTEGER) {
5584              if(reply-&gt;type == REDIS_REPLY_ERROR) {
5585                  fprintf(stderr, &quot;Error: %s\n&quot;, reply-&gt;str);
5586                  exit(1);
5587              } else {
5588                  fprintf(stderr, &quot;Warning: OBJECT freq on &#x27;%s&#x27; failed (may have been deleted)\n&quot;, keys-&gt;element[i]-&gt;str);
5589                  freqs[i] = 0;
5590              }
5591          } else {
5592              freqs[i] = reply-&gt;integer;
5593          }
5594          freeReplyObject(reply);
5595      }
5596  }
5597  #define HOTKEYS_SAMPLE 16
5598  static void findHotKeys(void) {
5599      redisReply *keys, *reply;
5600      PORT_ULONGLONG counters[HOTKEYS_SAMPLE] = {0};
5601      sds hotkeys[HOTKEYS_SAMPLE] = {NULL};
5602      PORT_ULONGLONG sampled = 0, total_keys, *freqs = NULL, it = 0;
5603      unsigned int arrsize = 0, i, k;
5604      double pct;
5605      total_keys = getDbSize();
5606      printf(&quot;\n# Scanning the entire keyspace to find hot keys as well as\n&quot;);
5607      printf(&quot;# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n&quot;);
5608      printf(&quot;# per 100 SCAN commands (not usually needed).\n\n&quot;);
5609      do {
5610          pct = 100 * (double)sampled/total_keys;
5611          reply = sendScan(&amp;it);
5612          keys  = reply-&gt;element[1];
5613          if(keys-&gt;elements &gt; arrsize) {
5614              freqs = zrealloc(freqs, sizeof(PORT_ULONGLONG)*keys-&gt;elements);
5615              if(!freqs) {
5616                  fprintf(stderr, &quot;Failed to allocate storage for keys!\n&quot;);
5617                  exit(1);
5618              }
5619              arrsize = keys-&gt;elements;
5620          }
5621          getKeyFreqs(keys, freqs);
5622          for(i=0;i&lt;keys-&gt;elements;i++) {
5623              sampled++;
5624              if(sampled % 1000000 == 0) {
5625                  printf(&quot;[%05.2f%%] Sampled %llu keys so far\n&quot;, pct, sampled);
5626              }
5627              k = 0;
5628              while (k &lt; HOTKEYS_SAMPLE &amp;&amp; freqs[i] &gt; counters[k]) k++;
5629              if (k == 0) continue;
5630              k--;
5631              if (k == 0 || counters[k] == 0) {
5632                  sdsfree(hotkeys[k]);
5633              } else {
5634                  sdsfree(hotkeys[0]);
5635                  memmove(counters,counters+1,sizeof(counters[0])*k);
5636                  memmove(hotkeys,hotkeys+1,sizeof(hotkeys[0])*k);
5637              }
5638              counters[k] = freqs[i];
5639              hotkeys[k] = sdsnew(keys-&gt;element[i]-&gt;str);
5640              printf(
5641                 &quot;[%05.2f%%] Hot key &#x27;%s&#x27; found so far with counter %llu\n&quot;,
5642                 pct, keys-&gt;element[i]-&gt;str, freqs[i]);
5643          }
5644          if(sampled &amp;&amp; (sampled %100) == 0 &amp;&amp; config.interval) {
5645              usleep(config.interval);
5646          }
5647          freeReplyObject(reply);
5648      } while(it != 0);
5649      if (freqs) zfree(freqs);
5650      printf(&quot;\n-------- summary -------\n\n&quot;);
5651      printf(&quot;Sampled %llu keys in the keyspace!\n&quot;, sampled);
5652      for (i=1; i&lt;= HOTKEYS_SAMPLE; i++) {
5653          k = HOTKEYS_SAMPLE - i;
5654          if(counters[k]&gt;0) {
5655              printf(&quot;hot key found with counter: %llu\tkeyname: %s\n&quot;, counters[k], hotkeys[k]);
5656              sdsfree(hotkeys[k]);
5657          }
5658      }
5659      exit(0);
5660  }
5661  static char *getInfoField(char *info, char *field) {
5662      char *p = strstr(info,field);
5663      char *n1, *n2;
5664      char *result;
5665      if (!p) return NULL;
5666      p += strlen(field)+1;
5667      n1 = strchr(p,&#x27;\r&#x27;);
5668      n2 = strchr(p,&#x27;,&#x27;);
5669      if (n2 &amp;&amp; n2 &lt; n1) n1 = n2;
5670      result = zmalloc(sizeof(char)*(n1-p)+1);
5671      memcpy(result,p,(n1-p));
5672      result[n1-p] = &#x27;\0&#x27;;
5673      return result;
5674  }
5675  static PORT_LONG getLongInfoField(char *info, char *field) {
5676      char *value = getInfoField(info,field);
5677      PORT_LONG l;
5678      if (!value) return PORT_LONG_MIN;
5679      l = strtol(value,NULL,10);
5680      zfree(value);
5681      return l;
5682  }
5683  void bytesToHuman(char *s, PORT_LONGLONG n) {
5684      double d;
5685      if (n &lt; 0) {
5686          *s = &#x27;-&#x27;;
5687          s++;
5688          n = -n;
5689      }
5690      if (n &lt; 1024) {
5691          sprintf(s,&quot;%lldB&quot;,n);
5692          return;
5693      } else if (n &lt; (1024*1024)) {
5694          d = (double)n/(1024);
5695          sprintf(s,&quot;%.2fK&quot;,d);
5696      } else if (n &lt; (1024LL*1024*1024)) {
5697          d = (double)n/((double)1024*1024);
5698          sprintf(s,&quot;%.2fM&quot;,d);
5699      } else if (n &lt; (1024LL*1024*1024*1024)) {
5700          d = (double)n/(1024LL*1024*1024);
5701          sprintf(s,&quot;%.2fG&quot;,d);
5702      }
5703  }
5704  static void statMode(void) {
5705      redisReply *reply;
5706      PORT_LONG aux, requests = 0;
5707      int i = 0;
5708      while(1) {
5709          char buf[64];
5710          int j;
5711          reply = reconnectingRedisCommand(context,&quot;INFO&quot;);
5712          if (reply-&gt;type == REDIS_REPLY_ERROR) {
5713              printf(&quot;ERROR: %s\n&quot;, reply-&gt;str);
5714              exit(1);
5715          }
5716          if ((i++ % 20) == 0) {
5717              printf(
5718  &quot;------- data ------ --------------------- load -------------------- - child -\n&quot;
5719  &quot;keys       mem      clients blocked requests            connections          \n&quot;);
5720          }
5721          aux = 0;
5722          for (j = 0; j &lt; 20; j++) {
5723              PORT_LONG k;
5724              sprintf(buf,&quot;db%d:keys&quot;,j);
5725              k = getLongInfoField(reply-&gt;str,buf);
5726              if (k == PORT_LONG_MIN) continue;
5727              aux += k;
5728          }
5729          sprintf(buf,&quot;%Id&quot;,aux);                                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5730          printf(&quot;%-11s&quot;,buf);
5731          aux = getLongInfoField(reply-&gt;str,&quot;used_memory&quot;);
5732          bytesToHuman(buf,aux);
5733          printf(&quot;%-8s&quot;,buf);
5734          aux = getLongInfoField(reply-&gt;str,&quot;connected_clients&quot;);
5735          sprintf(buf,&quot;%Id&quot;,aux);                                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5736          printf(&quot; %-8s&quot;,buf);
5737          aux = getLongInfoField(reply-&gt;str,&quot;blocked_clients&quot;);
5738          sprintf(buf,&quot;%Id&quot;,aux);                                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5739          printf(&quot;%-8s&quot;,buf);
5740          aux = getLongInfoField(reply-&gt;str,&quot;total_commands_processed&quot;);
5741          sprintf(buf,&quot;%Id (+%Id)&quot;,aux,requests == 0 ? 0 : aux-requests);  WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5742          printf(&quot;%-19s&quot;,buf);
5743          requests = aux;
5744          aux = getLongInfoField(reply-&gt;str,&quot;total_connections_received&quot;);
5745          sprintf(buf,&quot;%Id&quot;,aux);                                       WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5746          printf(&quot; %-12s&quot;,buf);
5747          aux = getLongInfoField(reply-&gt;str,&quot;bgsave_in_progress&quot;);
5748          aux |= getLongInfoField(reply-&gt;str,&quot;aof_rewrite_in_progress&quot;) &lt;&lt; 1;
5749          aux |= getLongInfoField(reply-&gt;str,&quot;loading&quot;) &lt;&lt; 2;
5750          switch(aux) {
5751          case 0: break;
5752          case 1:
5753              printf(&quot;SAVE&quot;);
5754              break;
5755          case 2:
5756              printf(&quot;AOF&quot;);
5757              break;
5758          case 3:
5759              printf(&quot;SAVE+AOF&quot;);
5760              break;
5761          case 4:
5762              printf(&quot;LOAD&quot;);
5763              break;
5764          }
5765          printf(&quot;\n&quot;);
5766          freeReplyObject(reply);
5767          usleep(config.interval);
5768      }
5769  }
5770  static void scanMode(void) {
5771      redisReply *reply;
5772      PORT_ULONGLONG cur = 0;
5773      do {
5774          if (config.pattern)
5775              reply = redisCommand(context,&quot;SCAN %llu MATCH %s&quot;,
5776                  cur,config.pattern);
5777          else
5778              reply = redisCommand(context,&quot;SCAN %llu&quot;,cur);
5779          if (reply == NULL) {
5780              printf(&quot;I/O error\n&quot;);
5781              exit(1);
5782          } else if (reply-&gt;type == REDIS_REPLY_ERROR) {
5783              printf(&quot;ERROR: %s\n&quot;, reply-&gt;str);
5784              exit(1);
5785          } else {
5786              unsigned int j;
5787              cur = strtoull(reply-&gt;element[0]-&gt;str,NULL,10);
5788              for (j = 0; j &lt; reply-&gt;element[1]-&gt;elements; j++)
5789                  printf(&quot;%s\n&quot;, reply-&gt;element[1]-&gt;element[j]-&gt;str);
5790          }
5791          freeReplyObject(reply);
5792      } while(cur != 0);
5793      exit(0);
5794  }
5795  PORT_LONGLONG powerLawRand(PORT_LONGLONG min, PORT_LONGLONG max, double alpha) {
5796      double pl, r;
5797      max += 1;
5798      r = ((double)rand()) / RAND_MAX;
5799      pl = pow(
5800          ((pow((double)max,alpha+1) - pow((double)min,alpha+1))*r + pow((double)min,alpha+1)), WIN_PORT_FIX &amp;bsol;* cast (double) */
5801          (1.0/(alpha+1)));
5802      return (max-1-(PORT_LONGLONG)pl)+min;
5803  }
5804  void LRUTestGenKey(char *buf, size_t buflen) {
5805      snprintf(buf, buflen, &quot;lru:%lld&quot;,
5806          powerLawRand(1, config.lru_test_sample_size, 6.2));
5807  }
5808  #define LRU_CYCLE_PERIOD 1000 &amp;bsol;* 1000 milliseconds. */
5809  #define LRU_CYCLE_PIPELINE_SIZE 250
5810  static void LRUTestMode(void) {
5811      redisReply *reply;
5812      char key[128];
5813      PORT_LONGLONG start_cycle;
5814      int j;
5815      srand((unsigned int)(time(NULL)^getpid()));                                   WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
5816      while(1) {
5817          start_cycle = mstime();
5818          PORT_LONGLONG hits = 0, misses = 0;
5819          while(mstime() - start_cycle &lt; 1000) {
5820              for (j = 0; j &lt; LRU_CYCLE_PIPELINE_SIZE; j++) {
5821                  char val[6];
5822                  val[5] = &#x27;\0&#x27;;
5823                  for (int i = 0; i &lt; 5; i++) val[i] = &#x27;A&#x27;+rand()%(&#x27;z&#x27;-&#x27;A&#x27;);
5824                  LRUTestGenKey(key,sizeof(key));
5825                  redisAppendCommand(context, &quot;SET %s %s&quot;,key,val);
5826              }
5827              for (j = 0; j &lt; LRU_CYCLE_PIPELINE_SIZE; j++)
5828                  redisGetReply(context, (void**)&amp;reply);
5829              for (j = 0; j &lt; LRU_CYCLE_PIPELINE_SIZE; j++) {
5830                  LRUTestGenKey(key,sizeof(key));
5831                  redisAppendCommand(context, &quot;GET %s&quot;,key);
5832              }
5833              for (j = 0; j &lt; LRU_CYCLE_PIPELINE_SIZE; j++) {
5834                  if (redisGetReply(context, (void**)&amp;reply) == REDIS_OK) {
5835                      switch(reply-&gt;type) {
5836                          case REDIS_REPLY_ERROR:
5837                              printf(&quot;%s\n&quot;, reply-&gt;str);
5838                              break;
5839                          case REDIS_REPLY_NIL:
5840                              misses++;
5841                              break;
5842                          default:
5843                              hits++;
5844                              break;
5845                      }
5846                  }
5847              }
5848              if (context-&gt;err) {
5849                  fprintf(stderr,&quot;I/O error during LRU test\n&quot;);
5850                  exit(1);
5851              }
5852          }
5853          printf(
5854              &quot;%lld Gets/sec | Hits: %lld (%.2f%%) | Misses: %lld (%.2f%%)\n&quot;,
5855              hits+misses,
5856              hits, (double)hits/(hits+misses)*100,
5857              misses, (double)misses/(hits+misses)*100);
5858      }
5859      exit(0);
5860  }
5861  PORT_ULONG compute_something_fast(void) {
5862      unsigned char s[256], i, j, t;
5863      int count = 1000, k;
5864      PORT_ULONG output = 0;
5865      for (k = 0; k &lt; 256; k++) s[k] = k;
5866      i = 0;
5867      j = 0;
5868      while(count--) {
5869          i++;
5870          j = j + s[i];
5871          t = s[i];
5872          s[i] = s[j];
5873          s[j] = t;
5874          output += s[(s[i]+s[j])&amp;255];
5875      }
5876      return output;
5877  }
5878  static void intrinsicLatencyModeStop(int s) {
5879      UNUSED(s);
5880      force_cancel_loop = 1;
5881  }
5882  static void intrinsicLatencyMode(void) {
5883      PORT_LONGLONG test_end, run_time, max_latency = 0, runs = 0;
5884      run_time = ((PORT_LONGLONG)config.intrinsic_latency_duration)*1000000;
5885      test_end = ustime() + run_time;
5886      signal(SIGINT, intrinsicLatencyModeStop);
5887      while(1) {
5888          PORT_LONGLONG start, end, latency;
5889          start = ustime();
5890          compute_something_fast();
5891          end = ustime();
5892          latency = end-start;
5893          runs++;
5894          if (latency &lt;= 0) continue;
5895          if (latency &gt; max_latency) {
5896              max_latency = latency;
5897              printf(&quot;Max latency so far: %lld microseconds.\n&quot;, max_latency);
5898          }
5899          double avg_us = (double)run_time/runs;
5900          double avg_ns = avg_us * 1e3;
5901          if (force_cancel_loop || end &gt; test_end) {
5902              printf(&quot;\n%lld total runs &quot;
5903                  &quot;(avg latency: &quot;
5904                  &quot;%.4f microseconds / %.2f nanoseconds per run).\n&quot;,
5905                  runs, avg_us, avg_ns);
5906              printf(&quot;Worst run took %.0fx longer than the average latency.\n&quot;,
5907                  max_latency / avg_us);
5908              exit(0);
5909          }
5910      }
5911  }
5912  int main(int argc, char **argv) {
5913      int firstarg;
5914  #ifdef _WIN32
5915      pthread_mutex_init(&amp;used_memory_mutex, NULL);
5916  #endif
5917      config.hostip = sdsnew(&quot;127.0.0.1&quot;);
5918      config.hostport = 6379;
5919      config.hostsocket = NULL;
5920      config.repeat = 1;
5921      config.interval = 0;
5922      config.dbnum = 0;
5923      config.interactive = 0;
5924      config.shutdown = 0;
5925      config.monitor_mode = 0;
5926      config.pubsub_mode = 0;
5927      config.latency_mode = 0;
5928      config.latency_dist_mode = 0;
5929      config.latency_history = 0;
5930      config.lru_test_mode = 0;
5931      config.lru_test_sample_size = 0;
5932      config.cluster_mode = 0;
5933      config.slave_mode = 0;
5934      config.getrdb_mode = 0;
5935      config.stat_mode = 0;
5936      config.scan_mode = 0;
5937      config.intrinsic_latency_mode = 0;
5938      config.pattern = NULL;
5939      config.rdb_filename = NULL;
5940      config.pipe_mode = 0;
5941      config.pipe_timeout = REDIS_CLI_DEFAULT_PIPE_TIMEOUT;
5942      config.bigkeys = 0;
5943      config.hotkeys = 0;
5944      config.stdinarg = 0;
5945      config.auth = NULL;
5946      config.eval = NULL;
5947      config.eval_ldb = 0;
5948      config.eval_ldb_end = 0;
5949      config.eval_ldb_sync = 0;
5950      config.enable_ldb_on_eval = 0;
5951      config.last_cmd_type = -1;
5952      config.verbose = 0;
5953      config.no_auth_warning = 0;
5954      config.cluster_manager_command.name = NULL;
5955      config.cluster_manager_command.argc = 0;
5956      config.cluster_manager_command.argv = NULL;
5957      config.cluster_manager_command.flags = 0;
5958      config.cluster_manager_command.replicas = 0;
5959      config.cluster_manager_command.from = NULL;
5960      config.cluster_manager_command.to = NULL;
5961      config.cluster_manager_command.weight = NULL;
5962      config.cluster_manager_command.weight_argc = 0;
5963      config.cluster_manager_command.slots = 0;
5964      config.cluster_manager_command.timeout = CLUSTER_MANAGER_MIGRATE_TIMEOUT;
5965      config.cluster_manager_command.pipeline = CLUSTER_MANAGER_MIGRATE_PIPELINE;
5966      config.cluster_manager_command.threshold =
5967          CLUSTER_MANAGER_REBALANCE_THRESHOLD;
5968      pref.hints = 1;
5969      spectrum_palette = spectrum_palette_color;
5970      spectrum_palette_size = spectrum_palette_color_size;
5971      if (!isatty(fileno(stdout)) &amp;&amp; (getenv(&quot;FAKETTY&quot;) == NULL))
5972          config.output = OUTPUT_RAW;
5973      else
5974          config.output = OUTPUT_STANDARD;
5975      config.mb_delim = sdsnew(&quot;\n&quot;);
5976      firstarg = parseOptions(argc,argv);
5977      argc -= firstarg;
5978      argv += firstarg;
5979      parseEnv();
5980      if (CLUSTER_MANAGER_MODE()) {
5981          clusterManagerCommandProc *proc = validateClusterManagerCommand();
5982          if (!proc) {
5983              sdsfree(config.hostip);
5984              sdsfree(config.mb_delim);
5985              exit(1);
5986          }
5987          clusterManagerMode(proc);
5988      }
5989      if (config.latency_mode) {
5990          if (cliConnect(0) == REDIS_ERR) exit(1);
5991          latencyMode();
5992      }
5993      if (config.latency_dist_mode) {
5994          if (cliConnect(0) == REDIS_ERR) exit(1);
5995          latencyDistMode();
5996      }
5997      if (config.slave_mode) {
5998          if (cliConnect(0) == REDIS_ERR) exit(1);
5999          slaveMode();
6000      }
6001      if (config.getrdb_mode) {
6002          if (cliConnect(0) == REDIS_ERR) exit(1);
6003          getRDB();
6004      }
6005      if (config.pipe_mode) {
6006          if (cliConnect(0) == REDIS_ERR) exit(1);
6007          pipeMode();
6008      }
6009      if (config.bigkeys) {
6010          if (cliConnect(0) == REDIS_ERR) exit(1);
6011          findBigKeys(0, 0);
6012      }
6013      if (config.memkeys) {
6014          if (cliConnect(0) == REDIS_ERR) exit(1);
6015          findBigKeys(1, config.memkeys_samples);
6016      }
6017      if (config.hotkeys) {
6018          if (cliConnect(0) == REDIS_ERR) exit(1);
6019          findHotKeys();
6020      }
6021      if (config.stat_mode) {
6022          if (cliConnect(0) == REDIS_ERR) exit(1);
6023          if (config.interval == 0) config.interval = 1000000;
6024          statMode();
6025      }
6026      if (config.scan_mode) {
6027          if (cliConnect(0) == REDIS_ERR) exit(1);
6028          scanMode();
6029      }
6030      if (config.lru_test_mode) {
6031          if (cliConnect(0) == REDIS_ERR) exit(1);
6032          LRUTestMode();
6033      }
6034      if (config.intrinsic_latency_mode) intrinsicLatencyMode();
6035      if (argc == 0 &amp;&amp; !config.eval) {
6036          signal(SIGPIPE, SIG_IGN);
6037          cliConnect(0);
6038          repl();
6039      }
6040      if (cliConnect(0) != REDIS_OK) exit(1);
6041      if (config.eval) {
6042          return evalMode(argc,argv);
6043      } else {
6044          return noninteractive(argc,convertToSds(argc,argv));
6045      }
6046  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-cli.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include &quot;Win32_Interop/Win32_Portability.h&quot;
3  #include &quot;Win32_Interop/win32_types.h&quot;
4  #include &quot;Win32_Interop/Win32_Time.h&quot;
5  #include &quot;Win32_Interop/win32fixes.h&quot;
6  #include &quot;Win32_Interop/Win32_PThread.h&quot;
7  #include &quot;Win32_Interop/Win32_Error.h&quot;
8  #endif
9  #include &quot;fmacros.h&quot;
10  #include &quot;version.h&quot;
11  #include &lt;stdio.h&gt;
12  #include &lt;string.h&gt;
13  #include &lt;stdlib.h&gt;
14  #ifndef _WIN32
15  #include &lt;signal.h&gt;
16  #include &lt;unistd.h&gt;
17  #endif
18  #include &lt;time.h&gt;
19  #include &lt;ctype.h&gt;
20  #include &lt;errno.h&gt;
21  #include &lt;sys/stat.h&gt;
22  #ifndef _WIN32
23  #include &lt;sys/time.h&gt;
24  #endif
25  #include &lt;assert.h&gt;
26  #include &lt;fcntl.h&gt;
27  #include &lt;limits.h&gt;
28  #include &lt;math.h&gt;
29  #ifdef _WIN32
30  #ifndef STDIN_FILENO
31  #define STDIN_FILENO (_fileno(stdin))
32  #endif
33  #include &quot;Win32_Interop/win32fixes.h&quot;
34  #include &quot;Win32_Interop/Win32_Signal_Process.h&quot;
35  #include &quot;Win32_Interop/Win32_ANSI.h&quot;
36  #include &lt;windows.h&gt;
37  #define strcasecmp _stricmp
38  #define strncasecmp _strnicmp
39  #define strtoull _strtoui64
40  #endif
41  #include &lt;hiredis.h&gt;
42  #include &lt;sds.h&gt; &amp;bsol;* use sds.h from hiredis, so that only one set of sds functions will be present in the binary */
43  #include &quot;dict.h&quot;
44  #include &quot;adlist.h&quot;
45  #include &quot;zmalloc.h&quot;
46  #include &quot;linenoise.h&quot;
47  #include &quot;help.h&quot;
48  #include &quot;anet.h&quot;
49  #include &quot;ae.h&quot;
50  #define UNUSED(V) ((void) V)
51  #define OUTPUT_STANDARD 0
52  #define OUTPUT_RAW 1
53  #define OUTPUT_CSV 2
54  #define REDIS_CLI_KEEPALIVE_INTERVAL 15 &amp;bsol;* seconds */
55  #define REDIS_CLI_DEFAULT_PIPE_TIMEOUT 30 &amp;bsol;* seconds */
56  #define REDIS_CLI_HISTFILE_ENV &quot;REDISCLI_HISTFILE&quot;
57  #define REDIS_CLI_HISTFILE_DEFAULT &quot;.rediscli_history&quot;
58  #define REDIS_CLI_RCFILE_ENV &quot;REDISCLI_RCFILE&quot;
59  #define REDIS_CLI_RCFILE_DEFAULT &quot;.redisclirc&quot;
60  #define REDIS_CLI_AUTH_ENV &quot;REDISCLI_AUTH&quot;
61  #define REDIS_CLI_CLUSTER_YES_ENV &quot;REDISCLI_CLUSTER_YES&quot;
62  #define CLUSTER_MANAGER_SLOTS               16384
63  #define CLUSTER_MANAGER_MIGRATE_TIMEOUT     60000
64  #define CLUSTER_MANAGER_MIGRATE_PIPELINE    10
65  #define CLUSTER_MANAGER_REBALANCE_THRESHOLD 2
66  #define CLUSTER_MANAGER_INVALID_HOST_ARG \
67      &quot;[ERR] Invalid arguments: you need to pass either a valid &quot; \
68      &quot;address (ie. 120.0.0.1:7000) or space separated IP &quot; \
69      &quot;and port (ie. 120.0.0.1 7000)\n&quot;
70  #define CLUSTER_MANAGER_MODE() (config.cluster_manager_command.name != NULL)
71  #define CLUSTER_MANAGER_MASTERS_COUNT(nodes, replicas) (nodes/(replicas + 1))
72  #define CLUSTER_MANAGER_COMMAND(n,...) \
73          (redisCommand(n-&gt;context, __VA_ARGS__))
74  #define CLUSTER_MANAGER_NODE_ARRAY_FREE(array) zfree(array-&gt;alloc)
75  #define CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err) \
76      clusterManagerLogErr(&quot;Node %s:%d replied with error:\n%s\n&quot;, \
77                           n-&gt;ip, n-&gt;port, err);
78  #define clusterManagerLogInfo(...) \
79      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_INFO,__VA_ARGS__)
80  #define clusterManagerLogErr(...) \
81      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_ERR,__VA_ARGS__)
82  #define clusterManagerLogWarn(...) \
83      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_WARN,__VA_ARGS__)
84  #define clusterManagerLogOk(...) \
85      clusterManagerLog(CLUSTER_MANAGER_LOG_LVL_SUCCESS,__VA_ARGS__)
86  #define CLUSTER_MANAGER_FLAG_MYSELF     1 &lt;&lt; 0
87  #define CLUSTER_MANAGER_FLAG_SLAVE      1 &lt;&lt; 1
88  #define CLUSTER_MANAGER_FLAG_FRIEND     1 &lt;&lt; 2
89  #define CLUSTER_MANAGER_FLAG_NOADDR     1 &lt;&lt; 3
90  #define CLUSTER_MANAGER_FLAG_DISCONNECT 1 &lt;&lt; 4
91  #define CLUSTER_MANAGER_FLAG_FAIL       1 &lt;&lt; 5
92  #define CLUSTER_MANAGER_CMD_FLAG_FIX            1 &lt;&lt; 0
93  #define CLUSTER_MANAGER_CMD_FLAG_SLAVE          1 &lt;&lt; 1
94  #define CLUSTER_MANAGER_CMD_FLAG_YES            1 &lt;&lt; 2
95  #define CLUSTER_MANAGER_CMD_FLAG_AUTOWEIGHTS    1 &lt;&lt; 3
96  #define CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER    1 &lt;&lt; 4
97  #define CLUSTER_MANAGER_CMD_FLAG_SIMULATE       1 &lt;&lt; 5
98  #define CLUSTER_MANAGER_CMD_FLAG_REPLACE        1 &lt;&lt; 6
99  #define CLUSTER_MANAGER_CMD_FLAG_COPY           1 &lt;&lt; 7
100  #define CLUSTER_MANAGER_CMD_FLAG_COLOR          1 &lt;&lt; 8
101  #define CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS   1 &lt;&lt; 9
102  #define CLUSTER_MANAGER_OPT_GETFRIENDS  1 &lt;&lt; 0
103  #define CLUSTER_MANAGER_OPT_COLD        1 &lt;&lt; 1
104  #define CLUSTER_MANAGER_OPT_UPDATE      1 &lt;&lt; 2
105  #define CLUSTER_MANAGER_OPT_QUIET       1 &lt;&lt; 6
106  #define CLUSTER_MANAGER_OPT_VERBOSE     1 &lt;&lt; 7
107  #define CLUSTER_MANAGER_LOG_LVL_INFO    1
108  #define CLUSTER_MANAGER_LOG_LVL_WARN    2
109  #define CLUSTER_MANAGER_LOG_LVL_ERR     3
110  #define CLUSTER_MANAGER_LOG_LVL_SUCCESS 4
111  #define LOG_COLOR_BOLD      &quot;29;1m&quot;
112  #define LOG_COLOR_RED       &quot;31;1m&quot;
113  #define LOG_COLOR_GREEN     &quot;32;1m&quot;
114  #define LOG_COLOR_YELLOW    &quot;33;1m&quot;
115  #define LOG_COLOR_RESET     &quot;0m&quot;
116  #define CC_FORCE (1&lt;&lt;0)         &amp;bsol;* Re-connect if already connected. */
117  #define CC_QUIET (1&lt;&lt;1)         &amp;bsol;* Don&#x27;t log connecting errors. */
118  int spectrum_palette_color_size = 19;
119  int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};
120  int spectrum_palette_mono_size = 13;
121  int spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};
122  int *spectrum_palette;
123  int spectrum_palette_size;
124  static uint64_t dictSdsHash(const void *key);
125  static int dictSdsKeyCompare(void *privdata, const void *key1,
126      const void *key2);
127  static void dictSdsDestructor(void *privdata, void *val);
128  static void dictListDestructor(void *privdata, void *val);
129  typedef struct clusterManagerCommand {
130      char *name;
131      int argc;
132      char **argv;
133      int flags;
134      int replicas;
135      char *from;
136      char *to;
137      char **weight;
138      int weight_argc;
139      char *master_id;
140      int slots;
141      int timeout;
142      int pipeline;
143      float threshold;
144  } clusterManagerCommand;
145  static void createClusterManagerCommand(char *cmdname, int argc, char **argv);
146  static redisContext *context;
147  static struct config {
148      char *hostip;
149      int hostport;
150      char *hostsocket;
151      PORT_LONG repeat;
152      PORT_LONG interval;
153      int dbnum;
154      int interactive;
155      int shutdown;
156      int monitor_mode;
157      int pubsub_mode;
158      int latency_mode;
159      int latency_dist_mode;
160      int latency_history;
161      int lru_test_mode;
162      PORT_LONGLONG lru_test_sample_size;
163      int cluster_mode;
164      int cluster_reissue_command;
165      int slave_mode;
166      int pipe_mode;
167      int pipe_timeout;
168      int getrdb_mode;
169      int stat_mode;
170      int scan_mode;
171      int intrinsic_latency_mode;
172      int intrinsic_latency_duration;
173      char *pattern;
174      char *rdb_filename;
175      int bigkeys;
176      int memkeys;
177      unsigned memkeys_samples;
178      int hotkeys;
179      int stdinarg; &amp;bsol;* get last arg from stdin. (-x option) */
180      char *auth;
181      int output; &amp;bsol;* output mode, see OUTPUT_* defines */
182      sds mb_delim;
183      char prompt[128];
184      char *eval;
185      int eval_ldb;
186      int eval_ldb_sync;  &amp;bsol;* Ask for synchronous mode of the Lua debugger. */
187      int eval_ldb_end;   &amp;bsol;* Lua debugging session ended. */
188      int enable_ldb_on_eval; &amp;bsol;* Handle manual SCRIPT DEBUG + EVAL commands. */
189      int last_cmd_type;
190      int verbose;
191      clusterManagerCommand cluster_manager_command;
192      int no_auth_warning;
193  } config;
194  static struct pref {
195      int hints;
196  } pref;
197  static volatile sig_atomic_t force_cancel_loop = 0;
198  static void usage(void);
199  static void slaveMode(void);
200  char *redisGitSHA1(void);
201  char *redisGitDirty(void);
202  static int cliConnect(int force);
203  static char *getInfoField(char *info, char *field);
204  static PORT_LONG getLongInfoField(char *info, char *field);
205  #ifdef _WIN32
206  extern pthread_mutex_t used_memory_mutex;
207  #endif
208  uint16_t crc16(const char *buf, int len);
209  static PORT_LONGLONG ustime(void) {
210  #ifdef _WIN32
211      return GetHighResRelativeTime(1000000);
212  #else
213      struct timeval tv;
214      PORT_LONGLONG ust;
215      gettimeofday(&amp;tv, NULL);
216      ust = ((PORT_LONGLONG) tv.tv_sec) * 1000000;
217      ust += tv.tv_usec;
218      return ust;
219  #endif
220  }
221  static PORT_LONGLONG mstime(void) {
222      return ustime() / 1000;
223  }
224  static void cliRefreshPrompt(void) {
225      if (config.eval_ldb) return;
226      sds prompt = sdsempty();
227      if (config.hostsocket != NULL) {
228          prompt = sdscatfmt(prompt,&quot;redis %s&quot;,config.hostsocket);
229      } else {
230          char addr[256];
231          anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport);
232          prompt = sdscatlen(prompt,addr,strlen(addr));
233      }
234      if (config.dbnum != 0)
235          prompt = sdscatfmt(prompt,&quot;[%i]&quot;,config.dbnum);
236      prompt = sdscatlen(prompt,&quot;&gt; &quot;,2);
237      snprintf(config.prompt,sizeof(config.prompt),&quot;%s&quot;,prompt);
238      sdsfree(prompt);
239  }
240  static sds getDotfilePath(char *envoverride, char *dotfilename) {
241      char *path = NULL;
242      sds dotPath = NULL;
243      path = getenv(envoverride);
244      if (path != NULL &amp;&amp; *path != &#x27;\0&#x27;) {
245          if (!strcmp(&quot;/dev/null&quot;, path)) {
246              return NULL;
247          }
248          dotPath = sdsnew(path);
249      } else {
250  #ifdef _WIN32
251          char *homeDrive = getenv(&quot;HOMEDRIVE&quot;);
252          char *homePath = getenv(&quot;HOMEPATH&quot;);
253          if ((homeDrive != NULL) &amp;&amp; (*homeDrive != &#x27;\0&#x27;)
254              &amp;&amp; (homePath != NULL) &amp;&amp; (*homePath != &#x27;\0&#x27;)) {
255              dotPath = sdscatprintf(sdsempty(), &quot;%s%s\\%s&quot;, homeDrive, homePath, dotfilename);
256          }
257  #else
258          char *home = getenv(&quot;HOME&quot;);
259          if (home != NULL &amp;&amp; *home != &#x27;\0&#x27;) {
260              dotPath = sdscatprintf(sdsempty(), &quot;%s/%s&quot;, home, dotfilename);
261          }
262  #endif
263      }
264      return dotPath;
265  }
266  #define isHexChar(c) (isdigit(c) || (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;f&#x27;))
267  #define decodeHexChar(c) (isdigit(c) ? c - &#x27;0&#x27; : c - &#x27;a&#x27; + 10)
268  #define decodeHex(h, l) ((decodeHexChar(h) &lt;&lt; 4) + decodeHexChar(l))
269  static sds percentDecode(const char *pe, size_t len) {
270      const char *end = pe + len;
271      sds ret = sdsempty();
272      const char *curr = pe;
273      while (curr &lt; end) {
274          if (*curr == &#x27;%&#x27;) {
275              if ((end - curr) &lt; 2) {
276                  fprintf(stderr, &quot;Incomplete URI encoding\n&quot;);
277                  exit(1);
278              }
279              char h = tolower(*(++curr));
280              char l = tolower(*(++curr));
281              if (!isHexChar(h) || !isHexChar(l)) {
282                  fprintf(stderr, &quot;Illegal character in URI encoding\n&quot;);
283                  exit(1);
284              }
285              char c = decodeHex(h, l);
286              ret = sdscatlen(ret, &amp;c, 1);
287              curr++;
288          } else {
289              ret = sdscatlen(ret, curr++, 1);
290          }
291      }
292      return ret;
293  }
294  static void parseRedisUri(const char *uri) {
295      const char *scheme = &quot;redis:&amp;bsol;&amp;bsol;&quot;;
296      const char *curr = uri;
297      const char *end = uri + strlen(uri);
298      const char *userinfo, *username, *port, *host, *path;
299      if (strncasecmp(scheme, curr, strlen(scheme))) {
300          fprintf(stderr,&quot;Invalid URI scheme\n&quot;);
301          exit(1);
302      }
303      curr += strlen(scheme);
304      if (curr == end) return;
305      if ((userinfo = strchr(curr,&#x27;@&#x27;))) {
306          if ((username = strchr(curr, &#x27;:&#x27;)) &amp;&amp; username &lt; userinfo) {
307              curr = username + 1;
308          }
309          config.auth = percentDecode(curr, userinfo - curr);
310          curr = userinfo + 1;
311      }
312      if (curr == end) return;
313      path = strchr(curr, &#x27;/&#x27;);
314      if (*curr != &#x27;/&#x27;) {
315          host = path ? path - 1 : end;
316          if ((port = strchr(curr, &#x27;:&#x27;))) {
317              config.hostport = atoi(port + 1);
318              host = port - 1;
319          }
320          config.hostip = sdsnewlen(curr, host - curr + 1);
321      }
322      curr = path ? path + 1 : end;
323      if (curr == end) return;
324      config.dbnum = atoi(curr);
325  }
326  static uint64_t dictSdsHash(const void *key) {
327      return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
328  }
329  static int dictSdsKeyCompare(void *privdata, const void *key1,
330          const void *key2)
331  {
332      int l1,l2;
333      DICT_NOTUSED(privdata);
334      l1 = sdslen((sds)key1);
335      l2 = sdslen((sds)key2);
336      if (l1 != l2) return 0;
337      return memcmp(key1, key2, l1) == 0;
338  }
339  static void dictSdsDestructor(void *privdata, void *val)
340  {
341      DICT_NOTUSED(privdata);
342      sdsfree(val);
343  }
344  void dictListDestructor(void *privdata, void *val)
345  {
346      DICT_NOTUSED(privdata);
347      listRelease((list*)val);
348  }
349  void _serverAssert(const char *estr, const char *file, int line) {
350      fprintf(stderr, &quot;=== ASSERTION FAILED ===&quot;);
351      fprintf(stderr, &quot;==&gt; %s:%d &#x27;%s&#x27; is not true&quot;,file,line,estr);
352      *((char*)-1) = &#x27;x&#x27;;
353  }
354  #define CLI_HELP_COMMAND 1
355  #define CLI_HELP_GROUP 2
356  typedef struct {
357      int type;
358      int argc;
359      sds *argv;
360      sds full;
361      struct commandHelp *org;
362  } helpEntry;
363  static helpEntry *helpEntries;
364  static int helpEntriesLen;
365  static sds cliVersion(void) {
366      sds version;
367      version = sdscatprintf(sdsempty(), &quot;%s&quot;, REDIS_VERSION);
368      if (strtoll(redisGitSHA1(),NULL,16)) {
369          version = sdscatprintf(version, &quot; (git:%s&quot;, redisGitSHA1());
370          if (strtoll(redisGitDirty(),NULL,10))
371              version = sdscatprintf(version, &quot;-dirty&quot;);
372          version = sdscat(version, &quot;)&quot;);
373      }
374      return version;
375  }
376  static void cliInitHelp(void) {
377      int commandslen = sizeof(commandHelp)/sizeof(struct commandHelp);
378      int groupslen = sizeof(commandGroups)/sizeof(char*);
379      int i, len, pos = 0;
380      helpEntry tmp;
381      helpEntriesLen = len = commandslen+groupslen;
382      helpEntries = zmalloc(sizeof(helpEntry)*len);
383      for (i = 0; i &lt; groupslen; i++) {
384          tmp.argc = 1;
385          tmp.argv = zmalloc(sizeof(sds));
386          tmp.argv[0] = sdscatprintf(sdsempty(),&quot;@%s&quot;,commandGroups[i]);
387          tmp.full = tmp.argv[0];
388          tmp.type = CLI_HELP_GROUP;
389          tmp.org = NULL;
390          helpEntries[pos++] = tmp;
391      }
392      for (i = 0; i &lt; commandslen; i++) {
393          tmp.argv = sdssplitargs(commandHelp[i].name,&amp;tmp.argc);
394          tmp.full = sdsnew(commandHelp[i].name);
395          tmp.type = CLI_HELP_COMMAND;
396          tmp.org = &amp;commandHelp[i];
397          helpEntries[pos++] = tmp;
398      }
399  }
400  static void cliIntegrateHelp(void) {
401      if (cliConnect(CC_QUIET) == REDIS_ERR) return;
402      redisReply *reply = redisCommand(context, &quot;COMMAND&quot;);
403      if(reply == NULL || reply-&gt;type != REDIS_REPLY_ARRAY) return;
404      for (size_t j = 0; j &lt; reply-&gt;elements; j++) {
405          redisReply *entry = reply-&gt;element[j];
406          if (entry-&gt;type != REDIS_REPLY_ARRAY || entry-&gt;elements &lt; 4 ||
407              entry-&gt;element[0]-&gt;type != REDIS_REPLY_STRING ||
408              entry-&gt;element[1]-&gt;type != REDIS_REPLY_INTEGER ||
409              entry-&gt;element[3]-&gt;type != REDIS_REPLY_INTEGER) return;
410          char *cmdname = entry-&gt;element[0]-&gt;str;
411          int i;
412          for (i = 0; i &lt; helpEntriesLen; i++) {
413              helpEntry *he = helpEntries+i;
414              if (!strcasecmp(he-&gt;argv[0],cmdname))
415                  break;
416          }
417          if (i != helpEntriesLen) continue;
418          helpEntriesLen++;
419          helpEntries = zrealloc(helpEntries,sizeof(helpEntry)*helpEntriesLen);
420          helpEntry *new = helpEntries+(helpEntriesLen-1);
421          new-&gt;argc = 1;
422          new-&gt;argv = zmalloc(sizeof(sds));
423          new-&gt;argv[0] = sdsnew(cmdname);
424          new-&gt;full = new-&gt;argv[0];
425          new-&gt;type = CLI_HELP_COMMAND;
426          sdstoupper(new-&gt;argv[0]);
427          struct commandHelp *ch = zmalloc(sizeof(*ch));
428          ch-&gt;name = new-&gt;argv[0];
429          ch-&gt;params = sdsempty();
430          int args = llabs(entry-&gt;element[1]-&gt;integer);
431          args--; &amp;bsol;* Remove the command name itself. */
432          if (entry-&gt;element[3]-&gt;integer == 1) {
433              ch-&gt;params = sdscat(ch-&gt;params,&quot;key &quot;);
434              args--;
435          }
436          while(args-- &gt; 0) ch-&gt;params = sdscat(ch-&gt;params,&quot;arg &quot;);
437          if (entry-&gt;element[1]-&gt;integer &lt; 0)
438              ch-&gt;params = sdscat(ch-&gt;params,&quot;...options...&quot;);
439          ch-&gt;summary = &quot;Help not available&quot;;
440          ch-&gt;group = 0;
441          ch-&gt;since = &quot;not known&quot;;
442          new-&gt;org = ch;
443      }
444      freeReplyObject(reply);
445  }
446  static void cliOutputCommandHelp(struct commandHelp *help, int group) {
447      printf(&quot;\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n&quot;, help-&gt;name, help-&gt;params);
448      printf(&quot;  \x1b[33msummary:\x1b[0m %s\r\n&quot;, help-&gt;summary);
449      printf(&quot;  \x1b[33msince:\x1b[0m %s\r\n&quot;, help-&gt;since);
450      if (group) {
451          printf(&quot;  \x1b[33mgroup:\x1b[0m %s\r\n&quot;, commandGroups[help-&gt;group]);
452      }
453  }
454  static void cliOutputGenericHelp(void) {
455      sds version = cliVersion();
456      printf(
457          &quot;redis-cli %s\n&quot;
458          &quot;To get help about Redis commands type:\n&quot;
459          &quot;      \&quot;help @&lt;group&gt;\&quot; to get a list of commands in &lt;group&gt;\n&quot;
460          &quot;      \&quot;help &lt;command&gt;\&quot; for help on &lt;command&gt;\n&quot;
461          &quot;      \&quot;help &lt;tab&gt;\&quot; to get a list of possible help topics\n&quot;
462          &quot;      \&quot;quit\&quot; to exit\n&quot;
463          &quot;\n&quot;
464          &quot;To set redis-cli preferences:\n&quot;
465          &quot;      \&quot;:set hints\&quot; enable online hints\n&quot;
466          &quot;      \&quot;:set nohints\&quot; disable online hints\n&quot;
467          &quot;Set your preferences in ~/.redisclirc\n&quot;,
468          version
469      );
470      sdsfree(version);
471  }
472  static void cliOutputHelp(int argc, char **argv) {
473      int i, j, len;
474      int group = -1;
475      helpEntry *entry;
476      struct commandHelp *help;
477      if (argc == 0) {
478          cliOutputGenericHelp();
479          return;
480      } else if (argc &gt; 0 &amp;&amp; argv[0][0] == &#x27;@&#x27;) {
481          len = sizeof(commandGroups)/sizeof(char*);
482          for (i = 0; i &lt; len; i++) {
483              if (strcasecmp(argv[0]+1,commandGroups[i]) == 0) {
484                  group = i;
485                  break;
486              }
487          }
488      }
489      assert(argc &gt; 0);
490      for (i = 0; i &lt; helpEntriesLen; i++) {
491          entry = &amp;helpEntries[i];
492          if (entry-&gt;type != CLI_HELP_COMMAND) continue;
493          help = entry-&gt;org;
494          if (group == -1) {
495              if (argc == entry-&gt;argc) {
496                  for (j = 0; j &lt; argc; j++) {
497                      if (strcasecmp(argv[j],entry-&gt;argv[j]) != 0) break;
498                  }
499                  if (j == argc) {
500                      cliOutputCommandHelp(help,1);
501                  }
502              }
503          } else {
504              if (group == help-&gt;group) {
505                  cliOutputCommandHelp(help,0);
506              }
507          }
508      }
509      printf(&quot;\r\n&quot;);
510  }
511  static void completionCallback(const char *buf, linenoiseCompletions *lc) {
512      size_t startpos = 0;
513      int mask;
514      int i;
515      size_t matchlen;
516      sds tmp;
517      if (strncasecmp(buf,&quot;help &quot;,5) == 0) {
518          startpos = 5;
519          while (isspace(buf[startpos])) startpos++;
520          mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;
521      } else {
522          mask = CLI_HELP_COMMAND;
523      }
524      for (i = 0; i &lt; helpEntriesLen; i++) {
525          if (!(helpEntries[i].type &amp; mask)) continue;
526          matchlen = strlen(buf+startpos);
527          if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {
528              tmp = sdsnewlen(buf,startpos);
529              tmp = sdscat(tmp,helpEntries[i].full);
530              linenoiseAddCompletion(lc,tmp);
531              sdsfree(tmp);
532          }
533      }
534  }
535  static char *hintsCallback(const char *buf, int *color, int *bold) {
536      if (!pref.hints) return NULL;
537      int i, argc, buflen = (int)strlen(buf);                                     WIN_PORT_FIX &amp;bsol;* cast int */
538      sds *argv = sdssplitargs(buf,&amp;argc);
539      int endspace = buflen &amp;&amp; isspace(buf[buflen-1]);
540      if (argc == 0) {
541          sdsfreesplitres(argv,argc);
542          return NULL;
543      }
544      for (i = 0; i &lt; helpEntriesLen; i++) {
545          if (!(helpEntries[i].type &amp; CLI_HELP_COMMAND)) continue;
546          if (strcasecmp(argv[0],helpEntries[i].full) == 0)
547          {
548              *color = 90;
549              *bold = 0;
550              sds hint = sdsnew(helpEntries[i].org-&gt;params);
551              int toremove = argc-1;
552              while(toremove &gt; 0 &amp;&amp; sdslen(hint)) {
553                  if (hint[0] == &#x27;[&#x27;) break;
554                  if (hint[0] == &#x27; &#x27;) toremove--;
555                  sdsrange(hint,1,-1);
556              }
557              if (!endspace) {
558                  sds newhint = sdsnewlen(&quot; &quot;,1);
559                  newhint = sdscatsds(newhint,hint);
560                  sdsfree(hint);
561                  hint = newhint;
562              }
563              sdsfreesplitres(argv,argc);
564              return hint;
565          }
566      }
567      sdsfreesplitres(argv,argc);
568      return NULL;
569  }
570  static void freeHintsCallback(void *ptr) {
571      sdsfree(ptr);
572  }
573  static int cliAuth(void) {
574      redisReply *reply;
575      if (config.auth == NULL) return REDIS_OK;
576      reply = redisCommand(context,&quot;AUTH %s&quot;,config.auth);
577      if (reply != NULL) {
578          freeReplyObject(reply);
579          return REDIS_OK;
580      }
581      return REDIS_ERR;
582  }
583  static int cliSelect(void) {
584      redisReply *reply;
585      if (config.dbnum == 0) return REDIS_OK;
586      reply = redisCommand(context,&quot;SELECT %d&quot;,config.dbnum);
587      if (reply != NULL) {
588          int result = REDIS_OK;
589          if (reply-&gt;type == REDIS_REPLY_ERROR) result = REDIS_ERR;
590          freeReplyObject(reply);
591          return result;
592      }
593      return REDIS_ERR;
594  }
595  static int cliConnect(int flags) {
596      if (context == NULL || flags &amp; CC_FORCE) {
597          if (context != NULL) {
598              redisFree(context);
599          }
600          if (config.hostsocket == NULL) {
601              context = redisConnect(config.hostip,config.hostport);
602          } else {
603              context = redisConnectUnix(config.hostsocket);
604          }
605          if (context-&gt;err) {
606              if (!(flags &amp; CC_QUIET)) {
607                  fprintf(stderr,&quot;Could not connect to Redis at &quot;);
608                  if (config.hostsocket == NULL)
609                      fprintf(stderr,&quot;%s:%d: %s\n&quot;,
610                          config.hostip,config.hostport,context-&gt;errstr);
611                  else
612                      fprintf(stderr,&quot;%s: %s\n&quot;,
613                          config.hostsocket,context-&gt;errstr);
614              }
615              redisFree(context);
616              context = NULL;
617              return REDIS_ERR;
618          }
619          anetKeepAlive(NULL, context-&gt;fd, REDIS_CLI_KEEPALIVE_INTERVAL);
620          if (cliAuth() != REDIS_OK)
621              return REDIS_ERR;
622          if (cliSelect() != REDIS_OK)
623              return REDIS_ERR;
624      }
625      return REDIS_OK;
626  }
627  static void cliPrintContextError(void) {
628      if (context == NULL) return;
629      fprintf(stderr,&quot;Error: %s\n&quot;,context-&gt;errstr);
630  }
631  static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
632      sds out = sdsempty();
633      switch (r-&gt;type) {
634      case REDIS_REPLY_ERROR:
635          out = sdscatprintf(out,&quot;(error) %s\n&quot;, r-&gt;str);
636      break;
637      case REDIS_REPLY_STATUS:
638          out = sdscat(out,r-&gt;str);
639          out = sdscat(out,&quot;\n&quot;);
640      break;
641      case REDIS_REPLY_INTEGER:
642          out = sdscatprintf(out,&quot;(integer) %lld\n&quot;,r-&gt;integer);
643      break;
644      case REDIS_REPLY_STRING:
645          out = sdscatrepr(out,r-&gt;str,r-&gt;len);
646          out = sdscat(out,&quot;\n&quot;);
647      break;
648      case REDIS_REPLY_NIL:
649          out = sdscat(out,&quot;(nil)\n&quot;);
650      break;
651      case REDIS_REPLY_ARRAY:
652          if (r-&gt;elements == 0) {
653              out = sdscat(out,&quot;(empty list or set)\n&quot;);
654          } else {
655              unsigned int i, idxlen = 0;
656              char _prefixlen[16];
657              char _prefixfmt[16];
658              sds _prefix;
659              sds tmp;
660              i = r-&gt;elements;
661              do {
662                  idxlen++;
663                  i /= 10;
664              } while(i);
665              memset(_prefixlen,&#x27; &#x27;,idxlen+2);
666              _prefixlen[idxlen+2] = &#x27;\0&#x27;;
667              _prefix = sdscat(sdsnew(prefix),_prefixlen);
668              snprintf(_prefixfmt,sizeof(_prefixfmt),&quot;%%s%%%ud) &quot;,idxlen);
669              for (i = 0; i &lt; r-&gt;elements; i++) {
670                  out = sdscatprintf(out,_prefixfmt,i == 0 ? &quot;&quot; : prefix,i+1);
671                  tmp = cliFormatReplyTTY(r-&gt;element[i],_prefix);
672                  out = sdscatlen(out,tmp,sdslen(tmp));
673                  sdsfree(tmp);
674              }
675              sdsfree(_prefix);
676          }
677      break;
678      default:
679          fprintf(stderr,&quot;Unknown reply type: %d\n&quot;, r-&gt;type);
680          exit(1);
681      }
682      return out;
683  }
684  int isColorTerm(void) {
685      char *t = getenv(&quot;TERM&quot;);
686      return t != NULL &amp;&amp; strstr(t,&quot;xterm&quot;) != NULL;
687  }
688  sds sdscatcolor(sds o, char *s, size_t len, char *color) {
689      if (!isColorTerm()) return sdscatlen(o,s,len);
690      int bold = strstr(color,&quot;bold&quot;) != NULL;
691      int ccode = 37; &amp;bsol;* Defaults to white. */
692      if (strstr(color,&quot;red&quot;)) ccode = 31;
693      else if (strstr(color,&quot;green&quot;)) ccode = 32;
694      else if (strstr(color,&quot;yellow&quot;)) ccode = 33;
695      else if (strstr(color,&quot;blue&quot;)) ccode = 34;
696      else if (strstr(color,&quot;magenta&quot;)) ccode = 35;
697      else if (strstr(color,&quot;cyan&quot;)) ccode = 36;
698      else if (strstr(color,&quot;white&quot;)) ccode = 37;
699      o = sdscatfmt(o,&quot;\033[%i;%i;49m&quot;,bold,ccode);
700      o = sdscatlen(o,s,len);
701      o = sdscat(o,&quot;\033[0m&quot;);
702      return o;
703  }
704  sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
705      char *color = &quot;white&quot;;
706      if (strstr(s,&quot;&lt;debug&gt;&quot;)) color = &quot;bold&quot;;
707      if (strstr(s,&quot;&lt;redis&gt;&quot;)) color = &quot;green&quot;;
708      if (strstr(s,&quot;&lt;reply&gt;&quot;)) color = &quot;cyan&quot;;
709      if (strstr(s,&quot;&lt;error&gt;&quot;)) color = &quot;red&quot;;
710      if (strstr(s,&quot;&lt;hint&gt;&quot;)) color = &quot;bold&quot;;
711      if (strstr(s,&quot;&lt;value&gt;&quot;) || strstr(s,&quot;&lt;retval&gt;&quot;)) color = &quot;magenta&quot;;
712      if (len &gt; 4 &amp;&amp; isdigit(s[3])) {
713          if (s[1] == &#x27;&gt;&#x27;) color = &quot;yellow&quot;; &amp;bsol;* Current line. */
714          else if (s[2] == &#x27;#&#x27;) color = &quot;bold&quot;; &amp;bsol;* Break point. */
715      }
716      return sdscatcolor(o,s,len,color);
717  }
718  static sds cliFormatReplyRaw(redisReply *r) {
719      sds out = sdsempty(), tmp;
720      size_t i;
721      switch (r-&gt;type) {
722      case REDIS_REPLY_NIL:
723          break;
724      case REDIS_REPLY_ERROR:
725          out = sdscatlen(out,r-&gt;str,r-&gt;len);
726          out = sdscatlen(out,&quot;\n&quot;,1);
727          break;
728      case REDIS_REPLY_STATUS:
729      case REDIS_REPLY_STRING:
730          if (r-&gt;type == REDIS_REPLY_STATUS &amp;&amp; config.eval_ldb) {
731              if (strstr(r-&gt;str,&quot;&lt;endsession&gt;&quot;) == r-&gt;str) {
732                  config.enable_ldb_on_eval = 0;
733                  config.eval_ldb = 0;
734                  config.eval_ldb_end = 1; &amp;bsol;* Signal the caller session ended. */
735                  config.output = OUTPUT_STANDARD;
736                  cliRefreshPrompt();
737              } else {
738                  out = sdsCatColorizedLdbReply(out,r-&gt;str,r-&gt;len);
739              }
740          } else {
741              out = sdscatlen(out,r-&gt;str,r-&gt;len);
742          }
743          break;
744      case REDIS_REPLY_INTEGER:
745          out = sdscatprintf(out,&quot;%I64d&quot;,r-&gt;integer);   WIN_PORT_FIX &amp;bsol;* %lld -&gt; %I64d */
746          break;
747      case REDIS_REPLY_ARRAY:
748          for (i = 0; i &lt; r-&gt;elements; i++) {
749              if (i &gt; 0) out = sdscat(out,config.mb_delim);
750              tmp = cliFormatReplyRaw(r-&gt;element[i]);
751              out = sdscatlen(out,tmp,sdslen(tmp));
752              sdsfree(tmp);
753          }
754          break;
755      default:
756          fprintf(stderr,&quot;Unknown reply type: %d\n&quot;, r-&gt;type);
757          exit(1);
758      }
759      return out;
760  }
761  static sds cliFormatReplyCSV(redisReply *r) {
762      unsigned int i;
763      sds out = sdsempty();
764      switch (r-&gt;type) {
765      case REDIS_REPLY_ERROR:
766          out = sdscat(out,&quot;ERROR,&quot;);
767          out = sdscatrepr(out,r-&gt;str,strlen(r-&gt;str));
768      break;
769      case REDIS_REPLY_STATUS:
770          out = sdscatrepr(out,r-&gt;str,r-&gt;len);
771      break;
772      case REDIS_REPLY_INTEGER:
773          out = sdscatprintf(out,&quot;%I64d&quot;,r-&gt;integer);   WIN_PORT_FIX &amp;bsol;* %lld -&gt; %I64d */
774      break;
775      case REDIS_REPLY_STRING:
776          out = sdscatrepr(out,r-&gt;str,r-&gt;len);
777      break;
778      case REDIS_REPLY_NIL:
779          out = sdscat(out,&quot;NIL&quot;);
780      break;
781      case REDIS_REPLY_ARRAY:
782          for (i = 0; i &lt; r-&gt;elements; i++) {
783              sds tmp = cliFormatReplyCSV(r-&gt;element[i]);
784              out = sdscatlen(out,tmp,sdslen(tmp));
785              if (i != r-&gt;elements-1) out = sdscat(out,&quot;,&quot;);
786              sdsfree(tmp);
787          }
788      break;
789      default:
790          fprintf(stderr,&quot;Unknown reply type: %d\n&quot;, r-&gt;type);
791          exit(1);
792      }
793      return out;
794  }
795  static int cliReadReply(int output_raw_strings) {
796      void *_reply;
797      redisReply *reply;
798      sds out = NULL;
799      int output = 1;
800      if (redisGetReply(context,&amp;_reply) != REDIS_OK) {
801          if (config.shutdown) {
802              redisFree(context);
803              context = NULL;
804              return REDIS_OK;
805          }
806          if (config.interactive) {
807              if (context-&gt;err == REDIS_ERR_IO &amp;&amp;
808                  (errno == ECONNRESET || errno == EPIPE))
809                  return REDIS_ERR;
810              if (context-&gt;err == REDIS_ERR_EOF)
811                  return REDIS_ERR;
812          }
813          cliPrintContextError();
814          exit(1);
815          return REDIS_ERR; &amp;bsol;* avoid compiler warning */
816      }
817      reply = (redisReply*)_reply;
818      config.last_cmd_type = reply-&gt;type;
819      if (config.cluster_mode &amp;&amp; reply-&gt;type == REDIS_REPLY_ERROR &amp;&amp;
820          (!strncmp(reply-&gt;str,&quot;MOVED&quot;,5) || !strcmp(reply-&gt;str,&quot;ASK&quot;)))
821      {
822          char *p = reply-&gt;str, *s;
823          int slot;
824          output = 0;
825          s = strchr(p,&#x27; &#x27;);      &amp;bsol;* MOVED[S]3999 127.0.0.1:6381 */
826          p = strchr(s+1,&#x27; &#x27;);    &amp;bsol;* MOVED[S]3999[P]127.0.0.1:6381 */
827          *p = &#x27;\0&#x27;;
828          slot = atoi(s+1);
829          s = strrchr(p+1,&#x27;:&#x27;);    &amp;bsol;* MOVED 3999[P]127.0.0.1[S]6381 */
830          *s = &#x27;\0&#x27;;
831          sdsfree(config.hostip);
832          config.hostip = sdsnew(p+1);
833          config.hostport = atoi(s+1);
834          if (config.interactive)
835              printf(&quot;-&gt; Redirected to slot [%d] located at %s:%d\n&quot;,
836                  slot, config.hostip, config.hostport);
837          config.cluster_reissue_command = 1;
838          cliRefreshPrompt();
839      }
840      if (output) {
841          if (output_raw_strings) {
842              out = cliFormatReplyRaw(reply);
843          } else {
844              if (config.output == OUTPUT_RAW) {
845                  out = cliFormatReplyRaw(reply);
846                  out = sdscat(out,&quot;\n&quot;);
847              } else if (config.output == OUTPUT_STANDARD) {
848                  out = cliFormatReplyTTY(reply,&quot;&quot;);
849              } else if (config.output == OUTPUT_CSV) {
850                  out = cliFormatReplyCSV(reply);
851                  out = sdscat(out,&quot;\n&quot;);
852              }
853          }
854  #ifdef _WIN32
855          fprintf(stdout, &quot;%s&quot;, out);
856  #else
857          fwrite(out,sdslen(out),1,stdout);
858  #endif
859          sdsfree(out);
860      }
861      freeReplyObject(reply);
862      return REDIS_OK;
863  }
864  static int cliSendCommand(int argc, char **argv, PORT_LONG repeat) {
865      char *command = argv[0];
866      size_t *argvlen;
867      int j, output_raw;
868      if (!config.eval_ldb &amp;&amp; &amp;bsol;* In debugging mode, let&#x27;s pass &quot;help&quot; to Redis. */
869          (!strcasecmp(command,&quot;help&quot;) || !strcasecmp(command,&quot;?&quot;))) {
870          cliOutputHelp(--argc, ++argv);
871          return REDIS_OK;
872      }
873      if (context == NULL) return REDIS_ERR;
874      output_raw = 0;
875      if (!strcasecmp(command,&quot;info&quot;) ||
876          !strcasecmp(command,&quot;lolwut&quot;) ||
877          (argc &gt;= 2 &amp;&amp; !strcasecmp(command,&quot;debug&quot;) &amp;&amp;
878                         !strcasecmp(argv[1],&quot;htstats&quot;)) ||
879          (argc &gt;= 2 &amp;&amp; !strcasecmp(command,&quot;debug&quot;) &amp;&amp;
880                         !strcasecmp(argv[1],&quot;htstats-key&quot;)) ||
881          (argc &gt;= 2 &amp;&amp; !strcasecmp(command,&quot;memory&quot;) &amp;&amp;
882                        (!strcasecmp(argv[1],&quot;malloc-stats&quot;) ||
883                         !strcasecmp(argv[1],&quot;doctor&quot;))) ||
884          (argc == 2 &amp;&amp; !strcasecmp(command,&quot;cluster&quot;) &amp;&amp;
885                        (!strcasecmp(argv[1],&quot;nodes&quot;) ||
886                         !strcasecmp(argv[1],&quot;info&quot;))) ||
887          (argc &gt;= 2 &amp;&amp; !strcasecmp(command,&quot;client&quot;) &amp;&amp;
888                         !strcasecmp(argv[1],&quot;list&quot;)) ||
889          (argc == 3 &amp;&amp; !strcasecmp(command,&quot;latency&quot;) &amp;&amp;
890                         !strcasecmp(argv[1],&quot;graph&quot;)) ||
891          (argc == 2 &amp;&amp; !strcasecmp(command,&quot;latency&quot;) &amp;&amp;
892                         !strcasecmp(argv[1],&quot;doctor&quot;)))
893      {
894          output_raw = 1;
895      }
896      if (!strcasecmp(command,&quot;shutdown&quot;)) config.shutdown = 1;
897      if (!strcasecmp(command,&quot;monitor&quot;)) config.monitor_mode = 1;
898      if (!strcasecmp(command,&quot;subscribe&quot;) ||
899          !strcasecmp(command,&quot;psubscribe&quot;)) config.pubsub_mode = 1;
900      if (!strcasecmp(command,&quot;sync&quot;) ||
901          !strcasecmp(command,&quot;psync&quot;)) config.slave_mode = 1;
902      if (argc == 3 &amp;&amp; !strcasecmp(argv[0],&quot;script&quot;) &amp;&amp;
903                       !strcasecmp(argv[1],&quot;debug&quot;))
904      {
905          if (!strcasecmp(argv[2],&quot;yes&quot;) || !strcasecmp(argv[2],&quot;sync&quot;)) {
906              config.enable_ldb_on_eval = 1;
907          } else {
908              config.enable_ldb_on_eval = 0;
909          }
910      }
911      if (!strcasecmp(command,&quot;eval&quot;) &amp;&amp; config.enable_ldb_on_eval) {
912          config.eval_ldb = 1;
913          config.output = OUTPUT_RAW;
914      }
915      argvlen = zmalloc(argc*sizeof(size_t));
916      for (j = 0; j &lt; argc; j++)
917          argvlen[j] = sdslen(argv[j]);
918      while(repeat &lt; 0 || repeat-- &gt; 0) {
919          redisAppendCommandArgv(context,argc,(const char**)argv,argvlen);
920          while (config.monitor_mode) {
921              if (cliReadReply(output_raw) != REDIS_OK) exit(1);
922              fflush(stdout);
923          }
924          if (config.pubsub_mode) {
925              if (config.output != OUTPUT_RAW)
926                  printf(&quot;Reading messages... (press Ctrl-C to quit)\n&quot;);
927              while (1) {
928                  if (cliReadReply(output_raw) != REDIS_OK) exit(1);
929              }
930          }
931          if (config.slave_mode) {
932              printf(&quot;Entering replica output mode...  (press Ctrl-C to quit)\n&quot;);
933              slaveMode();
934              config.slave_mode = 0;
935              zfree(argvlen);
936              return REDIS_ERR;  &amp;bsol;* Error = slaveMode lost connection to master */
937          }
938          if (cliReadReply(output_raw) != REDIS_OK) {
939              zfree(argvlen);
940              return REDIS_ERR;
941          } else {
942              if (!strcasecmp(command,&quot;select&quot;) &amp;&amp; argc == 2 &amp;&amp; config.last_cmd_type != REDIS_REPLY_ERROR) {
943                  config.dbnum = atoi(argv[1]);
944                  cliRefreshPrompt();
945              } else if (!strcasecmp(command,&quot;auth&quot;) &amp;&amp; argc == 2) {
946                  cliSelect();
947              }
948          }
949          if (config.cluster_reissue_command){
950              break;
951          }
952          if (config.interval) usleep(config.interval);
953          fflush(stdout); &amp;bsol;* Make it grep friendly */
954      }
955      zfree(argvlen);
956      return REDIS_OK;
957  }
958  static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
959      redisReply *reply = NULL;
960      int tries = 0;
961      va_list ap;
962      assert(!c-&gt;err);
963      while(reply == NULL) {
964          while (c-&gt;err &amp; (REDIS_ERR_IO | REDIS_ERR_EOF)) {
965              printf(&quot;\r\x1b[0K&quot;); &amp;bsol;* Cursor to left edge + clear line. */
966              printf(&quot;Reconnecting... %d\r&quot;, ++tries);
967              fflush(stdout);
968              redisFree(c);
969              c = redisConnect(config.hostip,config.hostport);
970              usleep(1000000);
971          }
972          va_start(ap,fmt);
973          reply = redisvCommand(c,fmt,ap);
974          va_end(ap);
975          if (c-&gt;err &amp;&amp; !(c-&gt;err &amp; (REDIS_ERR_IO | REDIS_ERR_EOF))) {
976              fprintf(stderr, &quot;Error: %s\n&quot;, c-&gt;errstr);
977              exit(1);
978          } else if (tries &gt; 0) {
979              printf(&quot;\r\x1b[0K&quot;); &amp;bsol;* Cursor to left edge + clear line. */
980          }
981      }
982      context = c;
983      return reply;
984  }
985  static int parseOptions(int argc, char **argv) {
986      int i;
987      for (i = 1; i &lt; argc; i++) {
988          int lastarg = i==argc-1;
989          if (!strcmp(argv[i],&quot;-h&quot;) &amp;&amp; !lastarg) {
990              sdsfree(config.hostip);
991              config.hostip = sdsnew(argv[++i]);
992          } else if (!strcmp(argv[i],&quot;-h&quot;) &amp;&amp; lastarg) {
993              usage();
994          } else if (!strcmp(argv[i],&quot;--help&quot;)) {
995              usage();
996          } else if (!strcmp(argv[i],&quot;-x&quot;)) {
997              config.stdinarg = 1;
998          } else if (!strcmp(argv[i],&quot;-p&quot;) &amp;&amp; !lastarg) {
999              config.hostport = atoi(argv[++i]);
1000          } else if (!strcmp(argv[i],&quot;-s&quot;) &amp;&amp; !lastarg) {
1001              config.hostsocket = argv[++i];
1002          } else if (!strcmp(argv[i],&quot;-r&quot;) &amp;&amp; !lastarg) {
1003              config.repeat = (PORT_LONG)strtoll(argv[++i],NULL,10);
1004          } else if (!strcmp(argv[i],&quot;-i&quot;) &amp;&amp; !lastarg) {
1005              double seconds = atof(argv[++i]);
1006              config.interval = (PORT_LONG)(seconds*1000000);
1007          } else if (!strcmp(argv[i],&quot;-n&quot;) &amp;&amp; !lastarg) {
1008              config.dbnum = atoi(argv[++i]);
1009          } else if (!strcmp(argv[i], &quot;--no-auth-warning&quot;)) {
1010              config.no_auth_warning = 1;
1011          } else if (!strcmp(argv[i],&quot;-a&quot;) &amp;&amp; !lastarg) {
1012              config.auth = argv[++i];
1013          } else if (!strcmp(argv[i],&quot;-u&quot;) &amp;&amp; !lastarg) {
1014              parseRedisUri(argv[++i]);
1015          } else if (!strcmp(argv[i],&quot;--raw&quot;)) {
1016              config.output = OUTPUT_RAW;
1017          } else if (!strcmp(argv[i],&quot;--no-raw&quot;)) {
1018              config.output = OUTPUT_STANDARD;
1019          } else if (!strcmp(argv[i],&quot;--csv&quot;)) {
1020              config.output = OUTPUT_CSV;
1021          } else if (!strcmp(argv[i],&quot;--latency&quot;)) {
1022              config.latency_mode = 1;
1023          } else if (!strcmp(argv[i],&quot;--latency-dist&quot;)) {
1024              config.latency_dist_mode = 1;
1025          } else if (!strcmp(argv[i],&quot;--mono&quot;)) {
1026              spectrum_palette = spectrum_palette_mono;
1027              spectrum_palette_size = spectrum_palette_mono_size;
1028          } else if (!strcmp(argv[i],&quot;--latency-history&quot;)) {
1029              config.latency_mode = 1;
1030              config.latency_history = 1;
1031          } else if (!strcmp(argv[i],&quot;--lru-test&quot;) &amp;&amp; !lastarg) {
1032              config.lru_test_mode = 1;
1033              config.lru_test_sample_size = strtoll(argv[++i],NULL,10);
1034          } else if (!strcmp(argv[i],&quot;--slave&quot;)) {
1035              config.slave_mode = 1;
1036          } else if (!strcmp(argv[i],&quot;--replica&quot;)) {
1037              config.slave_mode = 1;
1038          } else if (!strcmp(argv[i],&quot;--stat&quot;)) {
1039              config.stat_mode = 1;
1040          } else if (!strcmp(argv[i],&quot;--scan&quot;)) {
1041              config.scan_mode = 1;
1042          } else if (!strcmp(argv[i],&quot;--pattern&quot;) &amp;&amp; !lastarg) {
1043              config.pattern = argv[++i];
1044          } else if (!strcmp(argv[i],&quot;--intrinsic-latency&quot;) &amp;&amp; !lastarg) {
1045              config.intrinsic_latency_mode = 1;
1046              config.intrinsic_latency_duration = atoi(argv[++i]);
1047          } else if (!strcmp(argv[i],&quot;--rdb&quot;) &amp;&amp; !lastarg) {
1048              config.getrdb_mode = 1;
1049              config.rdb_filename = argv[++i];
1050          } else if (!strcmp(argv[i],&quot;--pipe&quot;)) {
1051              config.pipe_mode = 1;
1052          } else if (!strcmp(argv[i],&quot;--pipe-timeout&quot;) &amp;&amp; !lastarg) {
1053              config.pipe_timeout = atoi(argv[++i]);
1054          } else if (!strcmp(argv[i],&quot;--bigkeys&quot;)) {
1055              config.bigkeys = 1;
1056          } else if (!strcmp(argv[i],&quot;--memkeys&quot;)) {
1057              config.memkeys = 1;
1058              config.memkeys_samples = 0; &amp;bsol;* use redis default */
1059          } else if (!strcmp(argv[i],&quot;--memkeys-samples&quot;)) {
1060              config.memkeys = 1;
1061              config.memkeys_samples = atoi(argv[++i]);
1062          } else if (!strcmp(argv[i],&quot;--hotkeys&quot;)) {
1063              config.hotkeys = 1;
1064          } else if (!strcmp(argv[i],&quot;--eval&quot;) &amp;&amp; !lastarg) {
1065              config.eval = argv[++i];
1066          } else if (!strcmp(argv[i],&quot;--ldb&quot;)) {
1067              config.eval_ldb = 1;
1068              config.output = OUTPUT_RAW;
1069          } else if (!strcmp(argv[i],&quot;--ldb-sync-mode&quot;)) {
1070              config.eval_ldb = 1;
1071              config.eval_ldb_sync = 1;
1072              config.output = OUTPUT_RAW;
1073          } else if (!strcmp(argv[i],&quot;-c&quot;)) {
1074              config.cluster_mode = 1;
1075          } else if (!strcmp(argv[i],&quot;-d&quot;) &amp;&amp; !lastarg) {
1076              sdsfree(config.mb_delim);
1077              config.mb_delim = sdsnew(argv[++i]);
1078          } else if (!strcmp(argv[i],&quot;--verbose&quot;)) {
1079              config.verbose = 1;
1080          } else if (!strcmp(argv[i],&quot;--cluster&quot;) &amp;&amp; !lastarg) {
1081              if (CLUSTER_MANAGER_MODE()) usage();
1082              char *cmd = argv[++i];
1083              int j = i;
1084              while (j &lt; argc &amp;&amp; argv[j][0] != &#x27;-&#x27;) j++;
1085              if (j &gt; i) j--;
1086              createClusterManagerCommand(cmd, j - i, argv + i + 1);
1087              i = j;
1088          } else if (!strcmp(argv[i],&quot;--cluster&quot;) &amp;&amp; lastarg) {
1089              usage();
1090          } else if (!strcmp(argv[i],&quot;--cluster-replicas&quot;) &amp;&amp; !lastarg) {
1091              config.cluster_manager_command.replicas = atoi(argv[++i]);
1092          } else if (!strcmp(argv[i],&quot;--cluster-master-id&quot;) &amp;&amp; !lastarg) {
1093              config.cluster_manager_command.master_id = argv[++i];
1094          } else if (!strcmp(argv[i],&quot;--cluster-from&quot;) &amp;&amp; !lastarg) {
1095              config.cluster_manager_command.from = argv[++i];
1096          } else if (!strcmp(argv[i],&quot;--cluster-to&quot;) &amp;&amp; !lastarg) {
1097              config.cluster_manager_command.to = argv[++i];
1098          } else if (!strcmp(argv[i],&quot;--cluster-weight&quot;) &amp;&amp; !lastarg) {
1099              if (config.cluster_manager_command.weight != NULL) {
1100                  fprintf(stderr, &quot;WARNING: you cannot use --cluster-weight &quot;
1101                                  &quot;more than once.\n&quot;
1102                                  &quot;You can set more weights by adding them &quot;
1103                                  &quot;as a space-separated list, ie:\n&quot;
1104                                  &quot;--cluster-weight n1=w n2=w\n&quot;);
1105                  exit(1);
1106              }
1107              int widx = i + 1;
1108              char **weight = argv + widx;
1109              int wargc = 0;
1110              for (; widx &lt; argc; widx++) {
1111                  if (strstr(argv[widx], &quot;--&quot;) == argv[widx]) break;
1112                  if (strchr(argv[widx], &#x27;=&#x27;) == NULL) break;
1113                  wargc++;
1114              }
1115              if (wargc &gt; 0) {
1116                  config.cluster_manager_command.weight = weight;
1117                  config.cluster_manager_command.weight_argc = wargc;
1118                  i += wargc;
1119              }
1120          } else if (!strcmp(argv[i],&quot;--cluster-slots&quot;) &amp;&amp; !lastarg) {
1121              config.cluster_manager_command.slots = atoi(argv[++i]);
1122          } else if (!strcmp(argv[i],&quot;--cluster-timeout&quot;) &amp;&amp; !lastarg) {
1123              config.cluster_manager_command.timeout = atoi(argv[++i]);
1124          } else if (!strcmp(argv[i],&quot;--cluster-pipeline&quot;) &amp;&amp; !lastarg) {
1125              config.cluster_manager_command.pipeline = atoi(argv[++i]);
1126          } else if (!strcmp(argv[i],&quot;--cluster-threshold&quot;) &amp;&amp; !lastarg) {
1127              config.cluster_manager_command.threshold = atof(argv[++i]);
1128          } else if (!strcmp(argv[i],&quot;--cluster-yes&quot;)) {
1129              config.cluster_manager_command.flags |=
1130                  CLUSTER_MANAGER_CMD_FLAG_YES;
1131          } else if (!strcmp(argv[i],&quot;--cluster-simulate&quot;)) {
1132              config.cluster_manager_command.flags |=
1133                  CLUSTER_MANAGER_CMD_FLAG_SIMULATE;
1134          } else if (!strcmp(argv[i],&quot;--cluster-replace&quot;)) {
1135              config.cluster_manager_command.flags |=
1136                  CLUSTER_MANAGER_CMD_FLAG_REPLACE;
1137          } else if (!strcmp(argv[i],&quot;--cluster-copy&quot;)) {
1138              config.cluster_manager_command.flags |=
1139                  CLUSTER_MANAGER_CMD_FLAG_COPY;
1140          } else if (!strcmp(argv[i],&quot;--cluster-slave&quot;)) {
1141              config.cluster_manager_command.flags |=
1142                  CLUSTER_MANAGER_CMD_FLAG_SLAVE;
1143          } else if (!strcmp(argv[i],&quot;--cluster-use-empty-masters&quot;)) {
1144              config.cluster_manager_command.flags |=
1145                  CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER;
1146          } else if (!strcmp(argv[i],&quot;--cluster-search-multiple-owners&quot;)) {
1147              config.cluster_manager_command.flags |=
1148                  CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS;
1149          } else if (!strcmp(argv[i],&quot;-v&quot;) || !strcmp(argv[i], &quot;--version&quot;)) {
1150              sds version = cliVersion();
1151              printf(&quot;redis-cli %s\n&quot;, version);
1152              sdsfree(version);
1153              exit(0);
1154          } else if (CLUSTER_MANAGER_MODE() &amp;&amp; argv[i][0] != &#x27;-&#x27;) {
1155              if (config.cluster_manager_command.argc == 0) {
1156                  int j = i + 1;
1157                  while (j &lt; argc &amp;&amp; argv[j][0] != &#x27;-&#x27;) j++;
1158                  int cmd_argc = j - i;
1159                  config.cluster_manager_command.argc = cmd_argc;
1160                  config.cluster_manager_command.argv = argv + i;
1161                  if (cmd_argc &gt; 1) i = j - 1;
1162              }
1163          } else {
1164              if (argv[i][0] == &#x27;-&#x27;) {
1165                  fprintf(stderr,
1166                      &quot;Unrecognized option or bad number of args for: &#x27;%s&#x27;\n&quot;,
1167                      argv[i]);
1168                  exit(1);
1169              } else {
1170                  break;
1171              }
1172          }
1173      }
1174      if (config.eval_ldb &amp;&amp; config.eval == NULL) {
1175          fprintf(stderr,&quot;Options --ldb and --ldb-sync-mode require --eval.\n&quot;);
1176          fprintf(stderr,&quot;Try %s --help for more information.\n&quot;, argv[0]);
1177          exit(1);
1178      }
1179      if (!config.no_auth_warning &amp;&amp; config.auth != NULL) {
1180          fputs(&quot;Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command&quot;
1181                &quot; line interface may not be safe.\n&quot;, stderr);
1182      }
1183      return i;
1184  }
1185  static void parseEnv() {
1186      char *auth = getenv(REDIS_CLI_AUTH_ENV);
1187      if (auth != NULL &amp;&amp; config.auth == NULL) {
1188          config.auth = auth;
1189      }
1190      char *cluster_yes = getenv(REDIS_CLI_CLUSTER_YES_ENV);
1191      if (cluster_yes != NULL &amp;&amp; !strcmp(cluster_yes, &quot;1&quot;)) {
1192          config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
1193      }
1194  }
1195  static sds readArgFromStdin(void) {
1196      char buf[1024];
1197      sds arg = sdsempty();
1198      while(1) {
1199          int nread = (int)read(fileno(stdin),buf,1024);                          WIN_PORT_FIX &amp;bsol;* cast (int) */
1200          if (nread == 0) break;
1201          else if (nread == -1) {
1202              perror(&quot;Reading from standard input&quot;);
1203              exit(1);
1204          }
1205          arg = sdscatlen(arg,buf,nread);
1206      }
1207      return arg;
1208  }
1209  static void usage(void) {
1210      sds version = cliVersion();
1211      fprintf(stderr,
1212  &quot;redis-cli %s\n&quot;
1213  &quot;\n&quot;
1214  &quot;Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]\n&quot;
1215  &quot;  -h &lt;hostname&gt;      Server hostname (default: 127.0.0.1).\n&quot;
1216  &quot;  -p &lt;port&gt;          Server port (default: 6379).\n&quot;
1217  &quot;  -s &lt;socket&gt;        Server socket (overrides hostname and port).\n&quot;
1218  &quot;  -a &lt;password&gt;      Password to use when connecting to the server.\n&quot;
1219  &quot;                     You can also use the &quot; REDIS_CLI_AUTH_ENV &quot; environment\n&quot;
1220  &quot;                     variable to pass this password more safely\n&quot;
1221  &quot;                     (if both are used, this argument takes predecence).\n&quot;
1222  &quot;  -u &lt;uri&gt;           Server URI.\n&quot;
1223  &quot;  -r &lt;repeat&gt;        Execute specified command N times.\n&quot;
1224  &quot;  -i &lt;interval&gt;      When -r is used, waits &lt;interval&gt; seconds per command.\n&quot;
1225  &quot;                     It is possible to specify sub-second times like -i 0.1.\n&quot;
1226  &quot;  -n &lt;db&gt;            Database number.\n&quot;
1227  &quot;  -x                 Read last argument from STDIN.\n&quot;
1228  &quot;  -d &lt;delimiter&gt;     Multi-bulk delimiter in for raw formatting (default: \\n).\n&quot;
1229  &quot;  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).\n&quot;
1230  &quot;  --raw              Use raw formatting for replies (default when STDOUT is\n&quot;
1231  &quot;                     not a tty).\n&quot;
1232  &quot;  --no-raw           Force formatted output even when STDOUT is not a tty.\n&quot;
1233  &quot;  --csv              Output in CSV format.\n&quot;
1234  &quot;  --stat             Print rolling stats about server: mem, clients, ...\n&quot;
1235  &quot;  --latency          Enter a special mode continuously sampling latency.\n&quot;
1236  &quot;                     If you use this mode in an interactive session it runs\n&quot;
1237  &quot;                     forever displaying real-time stats. Otherwise if --raw or\n&quot;
1238  &quot;                     --csv is specified, or if you redirect the output to a non\n&quot;
1239  &quot;                     TTY, it samples the latency for 1 second (you can use\n&quot;
1240  &quot;                     -i to change the interval), then produces a single output\n&quot;
1241  &quot;                     and exits.\n&quot;
1242  &quot;  --latency-history  Like --latency but tracking latency changes over time.\n&quot;
1243  &quot;                     Default time interval is 15 sec. Change it using -i.\n&quot;
1244  &quot;  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\n&quot;
1245  &quot;                     Default time interval is 1 sec. Change it using -i.\n&quot;
1246  &quot;  --lru-test &lt;keys&gt;  Simulate a cache workload with an 80-20 distribution.\n&quot;
1247  &quot;  --replica          Simulate a replica showing commands received from the master.\n&quot;
1248  &quot;  --rdb &lt;filename&gt;   Transfer an RDB dump from remote server to local file.\n&quot;
1249  &quot;  --pipe             Transfer raw Redis protocol from stdin to server.\n&quot;
1250  &quot;  --pipe-timeout &lt;n&gt; In --pipe mode, abort with error if after sending all data.\n&quot;
1251  &quot;                     no reply is received within &lt;n&gt; seconds.\n&quot;
1252  &quot;                     Default timeout: %d. Use 0 to wait forever.\n&quot;
1253  &quot;  --bigkeys          Sample Redis keys looking for keys with many elements (complexity).\n&quot;
1254  &quot;  --memkeys          Sample Redis keys looking for keys consuming a lot of memory.\n&quot;
1255  &quot;  --memkeys-samples &lt;n&gt; Sample Redis keys looking for keys consuming a lot of memory.\n&quot;
1256  &quot;                     And define number of key elements to sample\n&quot;
1257  &quot;  --hotkeys          Sample Redis keys looking for hot keys.\n&quot;
1258  &quot;                     only works when maxmemory-policy is *lfu.\n&quot;
1259  &quot;  --scan             List all keys using the SCAN command.\n&quot;
1260  &quot;  --pattern &lt;pat&gt;    Useful with --scan to specify a SCAN pattern.\n&quot;
1261  &quot;  --intrinsic-latency &lt;sec&gt; Run a test to measure intrinsic system latency.\n&quot;
1262  &quot;                     The test will run for the specified amount of seconds.\n&quot;
1263  &quot;  --eval &lt;file&gt;      Send an EVAL command using the Lua script at &lt;file&gt;.\n&quot;
1264  &quot;  --ldb              Used with --eval enable the Redis Lua debugger.\n&quot;
1265  &quot;  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in\n&quot;
1266  &quot;                     this mode the server is blocked and script changes are\n&quot;
1267  &quot;                     not rolled back from the server memory.\n&quot;
1268  &quot;  --cluster &lt;command&gt; [args...] [opts...]\n&quot;
1269  &quot;                     Cluster Manager command and arguments (see below).\n&quot;
1270  &quot;  --verbose          Verbose mode.\n&quot;
1271  &quot;  --no-auth-warning  Don&#x27;t show warning message when using password on command\n&quot;
1272  &quot;                     line interface.\n&quot;
1273  &quot;  --help             Output this help and exit.\n&quot;
1274  &quot;  --version          Output version and exit.\n&quot;
1275  &quot;\n&quot;,
1276      version, REDIS_CLI_DEFAULT_PIPE_TIMEOUT);
1277      fprintf(stderr,
1278  &quot;Cluster Manager Commands:\n&quot;
1279  &quot;  Use --cluster help to list all available cluster manager commands.\n&quot;
1280  &quot;\n&quot;
1281  &quot;Examples:\n&quot;
1282  &quot;  cat /etc/passwd | redis-cli -x set mypasswd\n&quot;
1283  &quot;  redis-cli get mypasswd\n&quot;
1284  &quot;  redis-cli -r 100 lpush mylist x\n&quot;
1285  &quot;  redis-cli -r 100 -i 1 info | grep used_memory_human:\n&quot;
1286  &quot;  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3\n&quot;
1287  &quot;  redis-cli --scan --pattern &#x27;*:12345*&#x27;\n&quot;
1288  &quot;\n&quot;
1289  &quot;  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)\n&quot;
1290  &quot;\n&quot;
1291  &quot;When no command is given, redis-cli starts in interactive mode.\n&quot;
1292  &quot;Type \&quot;help\&quot; in interactive mode for information on available commands\n&quot;
1293  &quot;and settings.\n&quot;
1294  &quot;\n&quot;);
1295      sdsfree(version);
1296      exit(1);
1297  }
1298  static int confirmWithYes(char *msg) {
1299      if (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_YES) {
1300          return 1;
1301      }
1302      printf(&quot;%s (type &#x27;yes&#x27; to accept): &quot;, msg);
1303      fflush(stdout);
1304      char buf[4];
1305      int nread = read(fileno(stdin),buf,4);
1306      buf[3] = &#x27;\0&#x27;;
1307      return (nread != 0 &amp;&amp; !strcmp(&quot;yes&quot;, buf));
1308  }
1309  static char **convertToSds(int count, char** args) {
1310    int j;
1311    char **sds = zmalloc(sizeof(char*)*count);
1312    for(j = 0; j &lt; count; j++)
1313      sds[j] = sdsnew(args[j]);
1314    return sds;
1315  }
1316  static int issueCommandRepeat(int argc, char **argv, PORT_LONG repeat) {
1317      while (1) {
1318          config.cluster_reissue_command = 0;
1319          if (cliSendCommand(argc,argv,(int)repeat) != REDIS_OK) { WIN_PORT_FIX &amp;bsol;* cast (int) */
1320              cliConnect(CC_FORCE);
1321              if (cliSendCommand(argc,argv,(int)repeat) != REDIS_OK) { WIN_PORT_FIX &amp;bsol;* cast (int) */
1322                  cliPrintContextError();
1323                  return REDIS_ERR;
1324              }
1325           }
1326           if (config.cluster_mode &amp;&amp; config.cluster_reissue_command) {
1327              cliConnect(CC_FORCE);
1328           } else {
1329               break;
1330          }
1331      }
1332      return REDIS_OK;
1333  }
1334  static int issueCommand(int argc, char **argv) {
1335      return issueCommandRepeat(argc, argv, config.repeat);
1336  }
1337  static sds *cliSplitArgs(char *line, int *argc) {
1338      if (config.eval_ldb &amp;&amp; (strstr(line,&quot;eval &quot;) == line ||
1339                              strstr(line,&quot;e &quot;) == line))
1340      {
1341          sds *argv = sds_malloc(sizeof(sds)*2);
1342          *argc = 2;
1343          int len = (int) strlen(line);                                            WIN_PORT_FIX &amp;bsol;* cast int */
1344          int elen = line[1] == &#x27; &#x27; ? 2 : 5; &amp;bsol;* &quot;e &quot; or &quot;eval &quot;? */
1345          argv[0] = sdsnewlen(line,elen-1);
1346          argv[1] = sdsnewlen(line+elen,len-elen);
1347          return argv;
1348      } else {
1349          return sdssplitargs(line,argc);
1350      }
1351  }
1352  void cliSetPreferences(char **argv, int argc, int interactive) {
1353      if (!strcasecmp(argv[0],&quot;:set&quot;) &amp;&amp; argc &gt;= 2) {
1354          if (!strcasecmp(argv[1],&quot;hints&quot;)) pref.hints = 1;
1355          else if (!strcasecmp(argv[1],&quot;nohints&quot;)) pref.hints = 0;
1356          else {
1357              printf(&quot;%sunknown redis-cli preference &#x27;%s&#x27;\n&quot;,
1358                  interactive ? &quot;&quot; : &quot;.redisclirc: &quot;,
1359                  argv[1]);
1360          }
1361      } else {
1362          printf(&quot;%sunknown redis-cli internal command &#x27;%s&#x27;\n&quot;,
1363              interactive ? &quot;&quot; : &quot;.redisclirc: &quot;,
1364              argv[0]);
1365      }
1366  }
1367  void cliLoadPreferences(void) {
1368      sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
1369      if (rcfile == NULL) return;
1370      FILE *fp = fopen(rcfile,&quot;r&quot;);
1371      char buf[1024];
1372      if (fp) {
1373          while(fgets(buf,sizeof(buf),fp) != NULL) {
1374              sds *argv;
1375              int argc;
1376              argv = sdssplitargs(buf,&amp;argc);
1377              if (argc &gt; 0) cliSetPreferences(argv,argc,0);
1378              sdsfreesplitres(argv,argc);
1379          }
1380          fclose(fp);
1381      }
1382      sdsfree(rcfile);
1383  }
1384  static void repl(void) {
1385      sds historyfile = NULL;
1386      int history = 0;
1387      char *line;
1388      int argc;
1389      sds *argv;
1390      cliInitHelp();
1391      cliIntegrateHelp();
1392      config.interactive = 1;
1393      linenoiseSetMultiLine(1);
1394      linenoiseSetCompletionCallback(completionCallback);
1395      linenoiseSetHintsCallback(hintsCallback);
1396      linenoiseSetFreeHintsCallback(freeHintsCallback);
1397      if (isatty(fileno(stdin))) {
1398          historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);
1399          history = 1;
1400          if (historyfile != NULL) {
1401              linenoiseHistoryLoad(historyfile);
1402          }
1403          cliLoadPreferences();
1404      }
1405      cliRefreshPrompt();
1406      while((line = linenoise(context ? config.prompt : &quot;not connected&gt; &quot;)) != NULL) {
1407          if (line[0] != &#x27;\0&#x27;) {
1408              PORT_LONG repeat = 1;
1409              int skipargs = 0;
1410              char *endptr = NULL;
1411              argv = cliSplitArgs(line,&amp;argc);
1412              if (argv &amp;&amp; argc &gt; 0) {
1413                  errno = 0;
1414                  repeat = strtol(argv[0], &amp;endptr, 10);
1415                  if (argc &gt; 1 &amp;&amp; *endptr == &#x27;\0&#x27;) {
1416                      if (errno == ERANGE || errno == EINVAL || repeat &lt;= 0) {
1417                          fputs(&quot;Invalid redis-cli repeat command option value.\n&quot;, stdout);
1418                          sdsfreesplitres(argv, argc);
1419                          linenoiseFree(line);
1420                          continue;
1421                      }
1422                      skipargs = 1;
1423                  } else {
1424                      repeat = 1;
1425                  }
1426              }
1427              if (!(argv &amp;&amp; argc &gt; 0 &amp;&amp; !strcasecmp(argv[0+skipargs], &quot;auth&quot;))) {
1428                  if (history) linenoiseHistoryAdd(line);
1429                  if (historyfile) linenoiseHistorySave(historyfile);
1430              }
1431              if (argv == NULL) {
1432                  printf(&quot;Invalid argument(s)\n&quot;);
1433                  linenoiseFree(line);
1434                  continue;
1435              } else if (argc &gt; 0) {
1436                  if (strcasecmp(argv[0],&quot;quit&quot;) == 0 ||
1437                      strcasecmp(argv[0],&quot;exit&quot;) == 0)
1438                  {
1439                      exit(0);
1440                  } else if (argv[0][0] == &#x27;:&#x27;) {
1441                      cliSetPreferences(argv,argc,1);
1442                      sdsfreesplitres(argv,argc);
1443                      linenoiseFree(line);
1444                      continue;
1445                  } else if (strcasecmp(argv[0],&quot;restart&quot;) == 0) {
1446                      if (config.eval) {
1447                          config.eval_ldb = 1;
1448                          config.output = OUTPUT_RAW;
1449                          return; &amp;bsol;* Return to evalMode to restart the session. */
1450                      } else {
1451                          printf(&quot;Use &#x27;restart&#x27; only in Lua debugging mode.&quot;);
1452                      }
1453                  } else if (argc == 3 &amp;&amp; !strcasecmp(argv[0],&quot;connect&quot;)) {
1454                      sdsfree(config.hostip);
1455                      config.hostip = sdsnew(argv[1]);
1456                      config.hostport = atoi(argv[2]);
1457                      cliRefreshPrompt();
1458                      cliConnect(CC_FORCE);
1459                  } else if (argc == 1 &amp;&amp; !strcasecmp(argv[0],&quot;clear&quot;)) {
1460                      linenoiseClearScreen();
1461                  } else {
1462                      PORT_LONGLONG start_time = mstime(), elapsed;
1463                      issueCommandRepeat(argc-skipargs, argv+skipargs, repeat);
1464                      if (config.eval_ldb_end) {
1465                          config.eval_ldb_end = 0;
1466                          cliReadReply(0);
1467                          printf(&quot;\n(Lua debugging session ended%s)\n\n&quot;,
1468                              config.eval_ldb_sync ? &quot;&quot; :
1469                              &quot; -- dataset changes rolled back&quot;);
1470                      }
1471                      elapsed = mstime()-start_time;
1472                      if (elapsed &gt;= 500 &amp;&amp;
1473                          config.output == OUTPUT_STANDARD)
1474                      {
1475                          printf(&quot;(%.2fs)\n&quot;,(double)elapsed/1000);
1476                      }
1477                  }
1478              }
1479              sdsfreesplitres(argv,argc);
1480          }
1481          linenoiseFree(line);
1482      }
1483      exit(0);
1484  }
1485  static int noninteractive(int argc, char **argv) {
1486      int retval = 0;
1487      if (config.stdinarg) {
1488          argv = zrealloc(argv, (argc+1)*sizeof(char*));
1489          argv[argc] = readArgFromStdin();
1490          retval = issueCommand(argc+1, argv);
1491      } else {
1492          retval = issueCommand(argc, argv);
1493      }
1494      return retval;
1495  }
1496  static int evalMode(int argc, char **argv) {
1497      sds script = NULL;
1498      FILE *fp;
1499      char buf[1024];
1500      size_t nread;
1501      char **argv2;
1502      int j, got_comma, keys;
1503      int retval = REDIS_OK;
1504      while(1) {
1505          if (config.eval_ldb) {
1506              printf(
1507              &quot;Lua debugging session started, please use:\n&quot;
1508              &quot;quit    -- End the session.\n&quot;
1509              &quot;restart -- Restart the script in debug mode again.\n&quot;
1510              &quot;help    -- Show Lua script debugging commands.\n\n&quot;
1511              );
1512          }
1513          sdsfree(script);
1514          script = sdsempty();
1515          got_comma = 0;
1516          keys = 0;
1517          fp = fopen(config.eval,&quot;r&quot;);
1518          if (!fp) {
1519              fprintf(stderr,
1520                  &quot;Can&#x27;t open file &#x27;%s&#x27;: %s\n&quot;, config.eval, strerror(errno));
1521              exit(1);
1522          }
1523          while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
1524              script = sdscatlen(script,buf,nread);
1525          }
1526          fclose(fp);
1527          if (config.eval_ldb) {
1528              redisReply *reply = redisCommand(context,
1529                      config.eval_ldb_sync ?
1530                      &quot;SCRIPT DEBUG sync&quot;: &quot;SCRIPT DEBUG yes&quot;);
1531              if (reply) freeReplyObject(reply);
1532          }
1533          argv2 = zmalloc(sizeof(sds)*(argc+3));
1534          argv2[0] = sdsnew(&quot;EVAL&quot;);
1535          argv2[1] = script;
1536          for (j = 0; j &lt; argc; j++) {
1537              if (!got_comma &amp;&amp; argv[j][0] == &#x27;,&#x27; &amp;&amp; argv[j][1] == 0) {
1538                  got_comma = 1;
1539                  continue;
1540              }
1541              argv2[j+3-got_comma] = sdsnew(argv[j]);
1542              if (!got_comma) keys++;
1543          }
1544          argv2[2] = sdscatprintf(sdsempty(),&quot;%d&quot;,keys);
1545          int eval_ldb = config.eval_ldb; &amp;bsol;* Save it, may be reverteed. */
1546          retval = issueCommand(argc+3-got_comma, argv2);
1547          if (eval_ldb) {
1548              if (!config.eval_ldb) {
1549                  printf(&quot;Eval debugging session can&#x27;t start:\n&quot;);
1550                  cliReadReply(0);
1551                  break; &amp;bsol;* Return to the caller. */
1552              } else {
1553                  strncpy(config.prompt,&quot;lua debugger&gt; &quot;,sizeof(config.prompt));
1554                  repl();
1555                  cliConnect(CC_FORCE);
1556                  printf(&quot;\n&quot;);
1557              }
1558          } else {
1559              break; &amp;bsol;* Return to the caller. */
1560          }
1561      }
1562      return retval;
1563  }
1564  static struct clusterManager {
1565      list *nodes;    &amp;bsol;* List of nodes in the configuration. */
1566      list *errors;
1567  } cluster_manager;
1568  dict *clusterManagerUncoveredSlots = NULL;
1569  typedef struct clusterManagerNode {
1570      redisContext *context;
1571      sds name;
1572      char *ip;
1573      int port;
1574      uint64_t current_epoch;
1575      time_t ping_sent;
1576      time_t ping_recv;
1577      int flags;
1578      list *flags_str; &amp;bsol;* Flags string representations */
1579      sds replicate;  &amp;bsol;* Master ID if node is a slave */
1580      int dirty;      &amp;bsol;* Node has changes that can be flushed */
1581      uint8_t slots[CLUSTER_MANAGER_SLOTS];
1582      int slots_count;
1583      int replicas_count;
1584      list *friends;
1585      sds *migrating; &amp;bsol;* An array of sds where even strings are slots and odd
1586                       * strings are the destination node IDs. */
1587      sds *importing; &amp;bsol;* An array of sds where even strings are slots and odd
1588                       * strings are the source node IDs. */
1589      int migrating_count; &amp;bsol;* Length of the migrating array (migrating slots*2) */
1590      int importing_count; &amp;bsol;* Length of the importing array (importing slots*2) */
1591      float weight;   &amp;bsol;* Weight used by rebalance */
1592      int balance;    &amp;bsol;* Used by rebalance */
1593  } clusterManagerNode;
1594  typedef struct clusterManagerNodeArray {
1595      clusterManagerNode **nodes; &amp;bsol;* Actual nodes array */
1596      clusterManagerNode **alloc; &amp;bsol;* Pointer to the allocated memory */
1597      int len;                    &amp;bsol;* Actual length of the array */
1598      int count;                  &amp;bsol;* Non-NULL nodes count */
1599  } clusterManagerNodeArray;
1600  typedef struct clusterManagerReshardTableItem {
1601      clusterManagerNode *source;
1602      int slot;
1603  } clusterManagerReshardTableItem;
1604  static dictType clusterManagerDictType = {
1605      dictSdsHash,               &amp;bsol;* hash function */
1606      NULL,                      &amp;bsol;* key dup */
1607      NULL,                      &amp;bsol;* val dup */
1608      dictSdsKeyCompare,         &amp;bsol;* key compare */
1609      NULL,                      &amp;bsol;* key destructor */
1610      dictSdsDestructor          &amp;bsol;* val destructor */
1611  };
1612  typedef int clusterManagerCommandProc(int argc, char **argv);
1613  typedef int (*clusterManagerOnReplyError)(redisReply *reply, int bulk_idx);
1614  static clusterManagerNode *clusterManagerNewNode(char *ip, int port);
1615  static clusterManagerNode *clusterManagerNodeByName(const char *name);
1616  static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char *n);
1617  static void clusterManagerNodeResetSlots(clusterManagerNode *node);
1618  static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err);
1619  static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
1620                                                     char *err);
1621  static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
1622                                        char **err);
1623  static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts);
1624  static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err);
1625  static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
1626      int ip_count, clusterManagerNode ***offending, int *offending_len);
1627  static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
1628      int ip_count);
1629  static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent);
1630  static void clusterManagerShowNodes(void);
1631  static void clusterManagerShowClusterInfo(void);
1632  static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err);
1633  static void clusterManagerWaitForClusterJoin(void);
1634  static int clusterManagerCheckCluster(int quiet);
1635  static void clusterManagerLog(int level, const char* fmt, ...);
1636  static int clusterManagerIsConfigConsistent(void);
1637  static void clusterManagerOnError(sds err);
1638  static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
1639                                          int len);
1640  static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array);
1641  static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
1642                                           clusterManagerNode **nodeptr);
1643  static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
1644                                         clusterManagerNode *node);
1645  static int clusterManagerCommandCreate(int argc, char **argv);
1646  static int clusterManagerCommandAddNode(int argc, char **argv);
1647  static int clusterManagerCommandDeleteNode(int argc, char **argv);
1648  static int clusterManagerCommandInfo(int argc, char **argv);
1649  static int clusterManagerCommandCheck(int argc, char **argv);
1650  static int clusterManagerCommandFix(int argc, char **argv);
1651  static int clusterManagerCommandReshard(int argc, char **argv);
1652  static int clusterManagerCommandRebalance(int argc, char **argv);
1653  static int clusterManagerCommandSetTimeout(int argc, char **argv);
1654  static int clusterManagerCommandImport(int argc, char **argv);
1655  static int clusterManagerCommandCall(int argc, char **argv);
1656  static int clusterManagerCommandHelp(int argc, char **argv);
1657  typedef struct clusterManagerCommandDef {
1658      char *name;
1659      clusterManagerCommandProc *proc;
1660      int arity;
1661      char *args;
1662      char *options;
1663  } clusterManagerCommandDef;
1664  clusterManagerCommandDef clusterManagerCommands[] = {
1665      {&quot;create&quot;, clusterManagerCommandCreate, -2, &quot;host1:port1 ... hostN:portN&quot;,
1666       &quot;replicas &lt;arg&gt;&quot;},
1667      {&quot;check&quot;, clusterManagerCommandCheck, -1, &quot;host:port&quot;,
1668       &quot;search-multiple-owners&quot;},
1669      {&quot;info&quot;, clusterManagerCommandInfo, -1, &quot;host:port&quot;, NULL},
1670      {&quot;fix&quot;, clusterManagerCommandFix, -1, &quot;host:port&quot;,
1671       &quot;search-multiple-owners&quot;},
1672      {&quot;reshard&quot;, clusterManagerCommandReshard, -1, &quot;host:port&quot;,
1673       &quot;from &lt;arg&gt;,to &lt;arg&gt;,slots &lt;arg&gt;,yes,timeout &lt;arg&gt;,pipeline &lt;arg&gt;,&quot;
1674       &quot;replace&quot;},
1675      {&quot;rebalance&quot;, clusterManagerCommandRebalance, -1, &quot;host:port&quot;,
1676       &quot;weight &lt;node1=w1...nodeN=wN&gt;,use-empty-masters,&quot;
1677       &quot;timeout &lt;arg&gt;,simulate,pipeline &lt;arg&gt;,threshold &lt;arg&gt;,replace&quot;},
1678      {&quot;add-node&quot;, clusterManagerCommandAddNode, 2,
1679       &quot;new_host:new_port existing_host:existing_port&quot;, &quot;slave,master-id &lt;arg&gt;&quot;},
1680      {&quot;del-node&quot;, clusterManagerCommandDeleteNode, 2, &quot;host:port node_id&quot;,NULL},
1681      {&quot;call&quot;, clusterManagerCommandCall, -2,
1682          &quot;host:port command arg arg .. arg&quot;, NULL},
1683      {&quot;set-timeout&quot;, clusterManagerCommandSetTimeout, 2,
1684       &quot;host:port milliseconds&quot;, NULL},
1685      {&quot;import&quot;, clusterManagerCommandImport, 1, &quot;host:port&quot;,
1686       &quot;from &lt;arg&gt;,copy,replace&quot;},
1687      {&quot;help&quot;, clusterManagerCommandHelp, 0, NULL, NULL}
1688  };
1689  static void createClusterManagerCommand(char *cmdname, int argc, char **argv) {
1690      clusterManagerCommand *cmd = &amp;config.cluster_manager_command;
1691      cmd-&gt;name = cmdname;
1692      cmd-&gt;argc = argc;
1693      cmd-&gt;argv = argc ? argv : NULL;
1694      if (isColorTerm()) cmd-&gt;flags |= CLUSTER_MANAGER_CMD_FLAG_COLOR;
1695  }
1696  static clusterManagerCommandProc *validateClusterManagerCommand(void) {
1697      int i, commands_count = sizeof(clusterManagerCommands) /
1698                              sizeof(clusterManagerCommandDef);
1699      clusterManagerCommandProc *proc = NULL;
1700      char *cmdname = config.cluster_manager_command.name;
1701      int argc = config.cluster_manager_command.argc;
1702      for (i = 0; i &lt; commands_count; i++) {
1703          clusterManagerCommandDef cmddef = clusterManagerCommands[i];
1704          if (!strcmp(cmddef.name, cmdname)) {
1705              if ((cmddef.arity &gt; 0 &amp;&amp; argc != cmddef.arity) ||
1706                  (cmddef.arity &lt; 0 &amp;&amp; argc &lt; (cmddef.arity * -1))) {
1707                  fprintf(stderr, &quot;[ERR] Wrong number of arguments for &quot;
1708                                  &quot;specified --cluster sub command\n&quot;);
1709                  return NULL;
1710              }
1711              proc = cmddef.proc;
1712          }
1713      }
1714      if (!proc) fprintf(stderr, &quot;Unknown --cluster subcommand\n&quot;);
1715      return proc;
1716  }
1717  static int getClusterHostFromCmdArgs(int argc, char **argv,
1718                                       char **ip_ptr, int *port_ptr) {
1719      int port = 0;
1720      char *ip = NULL;
1721      if (argc == 1) {
1722          char *addr = argv[0];
1723          char *c = strrchr(addr, &#x27;@&#x27;);
1724          if (c != NULL) *c = &#x27;\0&#x27;;
1725          c = strrchr(addr, &#x27;:&#x27;);
1726          if (c != NULL) {
1727              *c = &#x27;\0&#x27;;
1728              ip = addr;
1729              port = atoi(++c);
1730          } else return 0;
1731      } else {
1732          ip = argv[0];
1733          port = atoi(argv[1]);
1734      }
1735      if (!ip || !port) return 0;
1736      else {
1737          *ip_ptr = ip;
1738          *port_ptr = port;
1739      }
1740      return 1;
1741  }
1742  static void freeClusterManagerNodeFlags(list *flags) {
1743      listIter li;
1744      listNode *ln;
1745      listRewind(flags, &amp;li);
1746      while ((ln = listNext(&amp;li)) != NULL) {
1747          sds flag = ln-&gt;value;
1748          sdsfree(flag);
1749      }
1750      listRelease(flags);
1751  }
1752  static void freeClusterManagerNode(clusterManagerNode *node) {
1753      if (node-&gt;context != NULL) redisFree(node-&gt;context);
1754      if (node-&gt;friends != NULL) {
1755          listIter li;
1756          listNode *ln;
1757          listRewind(node-&gt;friends,&amp;li);
1758          while ((ln = listNext(&amp;li)) != NULL) {
1759              clusterManagerNode *fn = ln-&gt;value;
1760              freeClusterManagerNode(fn);
1761          }
1762          listRelease(node-&gt;friends);
1763          node-&gt;friends = NULL;
1764      }
1765      if (node-&gt;name != NULL) sdsfree(node-&gt;name);
1766      if (node-&gt;replicate != NULL) sdsfree(node-&gt;replicate);
1767      if ((node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_FRIEND) &amp;&amp; node-&gt;ip)
1768          sdsfree(node-&gt;ip);
1769      int i;
1770      if (node-&gt;migrating != NULL) {
1771          for (i = 0; i &lt; node-&gt;migrating_count; i++) sdsfree(node-&gt;migrating[i]);
1772          zfree(node-&gt;migrating);
1773      }
1774      if (node-&gt;importing != NULL) {
1775          for (i = 0; i &lt; node-&gt;importing_count; i++) sdsfree(node-&gt;importing[i]);
1776          zfree(node-&gt;importing);
1777      }
1778      if (node-&gt;flags_str != NULL) {
1779          freeClusterManagerNodeFlags(node-&gt;flags_str);
1780          node-&gt;flags_str = NULL;
1781      }
1782      zfree(node);
1783  }
1784  static void freeClusterManager(void) {
1785      listIter li;
1786      listNode *ln;
1787      if (cluster_manager.nodes != NULL) {
1788          listRewind(cluster_manager.nodes,&amp;li);
1789          while ((ln = listNext(&amp;li)) != NULL) {
1790              clusterManagerNode *n = ln-&gt;value;
1791              freeClusterManagerNode(n);
1792          }
1793          listRelease(cluster_manager.nodes);
1794          cluster_manager.nodes = NULL;
1795      }
1796      if (cluster_manager.errors != NULL) {
1797          listRewind(cluster_manager.errors,&amp;li);
1798          while ((ln = listNext(&amp;li)) != NULL) {
1799              sds err = ln-&gt;value;
1800              sdsfree(err);
1801          }
1802          listRelease(cluster_manager.errors);
1803          cluster_manager.errors = NULL;
1804      }
1805      if (clusterManagerUncoveredSlots != NULL)
1806          dictRelease(clusterManagerUncoveredSlots);
1807  }
1808  static clusterManagerNode *clusterManagerNewNode(char *ip, int port) {
1809      clusterManagerNode *node = zmalloc(sizeof(*node));
1810      node-&gt;context = NULL;
1811      node-&gt;name = NULL;
1812      node-&gt;ip = ip;
1813      node-&gt;port = port;
1814      node-&gt;current_epoch = 0;
1815      node-&gt;ping_sent = 0;
1816      node-&gt;ping_recv = 0;
1817      node-&gt;flags = 0;
1818      node-&gt;flags_str = NULL;
1819      node-&gt;replicate = NULL;
1820      node-&gt;dirty = 0;
1821      node-&gt;friends = NULL;
1822      node-&gt;migrating = NULL;
1823      node-&gt;importing = NULL;
1824      node-&gt;migrating_count = 0;
1825      node-&gt;importing_count = 0;
1826      node-&gt;replicas_count = 0;
1827      node-&gt;weight = 1.0f;
1828      node-&gt;balance = 0;
1829      clusterManagerNodeResetSlots(node);
1830      return node;
1831  }
1832  static int clusterManagerCheckRedisReply(clusterManagerNode *n,
1833                                           redisReply *r, char **err)
1834  {
1835      int is_err = 0;
1836      if (!r || (is_err = (r-&gt;type == REDIS_REPLY_ERROR))) {
1837          if (is_err) {
1838              if (err != NULL) {
1839                  *err = zmalloc((r-&gt;len + 1) * sizeof(char));
1840                  strcpy(*err, r-&gt;str);
1841              } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r-&gt;str);
1842          }
1843          return 0;
1844      }
1845      return 1;
1846  }
1847  static int clusterManagerStartTransaction(clusterManagerNode *node) {
1848      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;MULTI&quot;);
1849      int success = clusterManagerCheckRedisReply(node, reply, NULL);
1850      if (reply) freeReplyObject(reply);
1851      return success;
1852  }
1853  static int clusterManagerExecTransaction(clusterManagerNode *node,
1854                                           clusterManagerOnReplyError onerror)
1855  {
1856      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;EXEC&quot;);
1857      int success = clusterManagerCheckRedisReply(node, reply, NULL);
1858      if (success) {
1859          if (reply-&gt;type != REDIS_REPLY_ARRAY) {
1860              success = 0;
1861              goto cleanup;
1862          }
1863          size_t i;
1864          for (i = 0; i &lt; reply-&gt;elements; i++) {
1865              redisReply *r = reply-&gt;element[i];
1866              char *err = NULL;
1867              success = clusterManagerCheckRedisReply(node, r, &amp;err);
1868              if (!success &amp;&amp; onerror) success = onerror(r, i);
1869              if (err) {
1870                  if (!success)
1871                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
1872                  zfree(err);
1873              }
1874              if (!success) break;
1875          }
1876      }
1877  cleanup:
1878      if (reply) freeReplyObject(reply);
1879      return success;
1880  }
1881  static int clusterManagerNodeConnect(clusterManagerNode *node) {
1882      if (node-&gt;context) redisFree(node-&gt;context);
1883      node-&gt;context = redisConnect(node-&gt;ip, node-&gt;port);
1884      if (node-&gt;context-&gt;err) {
1885          fprintf(stderr,&quot;Could not connect to Redis at &quot;);
1886          fprintf(stderr,&quot;%s:%d: %s\n&quot;, node-&gt;ip, node-&gt;port,
1887                  node-&gt;context-&gt;errstr);
1888          redisFree(node-&gt;context);
1889          node-&gt;context = NULL;
1890          return 0;
1891      }
1892      anetKeepAlive(NULL, node-&gt;context-&gt;fd, REDIS_CLI_KEEPALIVE_INTERVAL);
1893      if (config.auth) {
1894          redisReply *reply = redisCommand(node-&gt;context,&quot;AUTH %s&quot;,config.auth);
1895          int ok = clusterManagerCheckRedisReply(node, reply, NULL);
1896          if (reply != NULL) freeReplyObject(reply);
1897          if (!ok) return 0;
1898      }
1899      return 1;
1900  }
1901  static void clusterManagerRemoveNodeFromList(list *nodelist,
1902                                               clusterManagerNode *node) {
1903      listIter li;
1904      listNode *ln;
1905      listRewind(nodelist, &amp;li);
1906      while ((ln = listNext(&amp;li)) != NULL) {
1907          if (node == ln-&gt;value) {
1908              listDelNode(nodelist, ln);
1909              break;
1910          }
1911      }
1912  }
1913  static clusterManagerNode *clusterManagerNodeByName(const char *name) {
1914      if (cluster_manager.nodes == NULL) return NULL;
1915      clusterManagerNode *found = NULL;
1916      sds lcname = sdsempty();
1917      lcname = sdscpy(lcname, name);
1918      sdstolower(lcname);
1919      listIter li;
1920      listNode *ln;
1921      listRewind(cluster_manager.nodes, &amp;li);
1922      while ((ln = listNext(&amp;li)) != NULL) {
1923          clusterManagerNode *n = ln-&gt;value;
1924          if (n-&gt;name &amp;&amp; !sdscmp(n-&gt;name, lcname)) {
1925              found = n;
1926              break;
1927          }
1928      }
1929      sdsfree(lcname);
1930      return found;
1931  }
1932  static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
1933  {
1934      if (cluster_manager.nodes == NULL) return NULL;
1935      clusterManagerNode *found = NULL;
1936      sds lcname = sdsempty();
1937      lcname = sdscpy(lcname, name);
1938      sdstolower(lcname);
1939      listIter li;
1940      listNode *ln;
1941      listRewind(cluster_manager.nodes, &amp;li);
1942      while ((ln = listNext(&amp;li)) != NULL) {
1943          clusterManagerNode *n = ln-&gt;value;
1944          if (n-&gt;name &amp;&amp;
1945              strstr(n-&gt;name, lcname) == n-&gt;name) {
1946              found = n;
1947              break;
1948          }
1949      }
1950      sdsfree(lcname);
1951      return found;
1952  }
1953  static void clusterManagerNodeResetSlots(clusterManagerNode *node) {
1954      memset(node-&gt;slots, 0, sizeof(node-&gt;slots));
1955      node-&gt;slots_count = 0;
1956  }
1957  static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
1958                                                    char **err)
1959  {
1960      redisReply *info = CLUSTER_MANAGER_COMMAND(node, &quot;INFO&quot;);
1961      if (err != NULL) *err = NULL;
1962      if (info == NULL) return NULL;
1963      if (info-&gt;type == REDIS_REPLY_ERROR) {
1964          if (err != NULL) {
1965              *err = zmalloc((info-&gt;len + 1) * sizeof(char));
1966              strcpy(*err, info-&gt;str);
1967          }
1968          freeReplyObject(info);
1969          return  NULL;
1970      }
1971      return info;
1972  }
1973  static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
1974      redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
1975      if (info == NULL) return 0;
1976      int is_cluster = (int) getLongInfoField(info-&gt;str, &quot;cluster_enabled&quot;);
1977      freeReplyObject(info);
1978      return is_cluster;
1979  }
1980  static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
1981      redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
1982      int is_empty = 1;
1983      if (info == NULL) return 0;
1984      if (strstr(info-&gt;str, &quot;db0:&quot;) != NULL) {
1985          is_empty = 0;
1986          goto result;
1987      }
1988      freeReplyObject(info);
1989      info = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER INFO&quot;);
1990      if (err != NULL) *err = NULL;
1991      if (!clusterManagerCheckRedisReply(node, info, err)) {
1992          is_empty = 0;
1993          goto result;
1994      }
1995      PORT_LONG known_nodes = getLongInfoField(info-&gt;str, &quot;cluster_known_nodes&quot;);
1996      is_empty = (known_nodes == 1);
1997  result:
1998      freeReplyObject(info);
1999      return is_empty;
2000  }
2001  static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
2002      int ip_count, clusterManagerNode ***offending, int *offending_len)
2003  {
2004      int score = 0, i, j;
2005      int node_len = cluster_manager.nodes-&gt;len;
2006      clusterManagerNode **offending_p = NULL;
2007      if (offending != NULL) {
2008          *offending = zcalloc(node_len * sizeof(clusterManagerNode*));
2009          offending_p = *offending;
2010      }
2011      for (i = 0; i &lt; ip_count; i++) {
2012          clusterManagerNodeArray *node_array = &amp;(ipnodes[i]);
2013          dict *related = dictCreate(&amp;clusterManagerDictType, NULL);
2014          char *ip = NULL;
2015          for (j = 0; j &lt; node_array-&gt;len; j++) {
2016              clusterManagerNode *node = node_array-&gt;nodes[j];
2017              if (node == NULL) continue;
2018              if (!ip) ip = node-&gt;ip;
2019              sds types;
2020              sds key = (!node-&gt;replicate ? node-&gt;name : node-&gt;replicate);
2021              assert(key != NULL);
2022              dictEntry *entry = dictFind(related, key);
2023              if (entry) types = sdsdup((sds) dictGetVal(entry));
2024              else types = sdsempty();
2025              if (!node-&gt;replicate) types = sdscatprintf(types, &quot;m%s&quot;, types);
2026              else types = sdscat(types, &quot;s&quot;);
2027              dictReplace(related, key, types);
2028          }
2029          dictIterator *iter = dictGetIterator(related);
2030          dictEntry *entry;
2031          while ((entry = dictNext(iter)) != NULL) {
2032              sds types = (sds) dictGetVal(entry);
2033              sds name = (sds) dictGetKey(entry);
2034              int typeslen = sdslen(types);
2035              if (typeslen &lt; 2) continue;
2036              if (types[0] == &#x27;m&#x27;) score += (10000 * (typeslen - 1));
2037              else score += (1 * typeslen);
2038              if (offending == NULL) continue;
2039              listIter li;
2040              listNode *ln;
2041              listRewind(cluster_manager.nodes, &amp;li);
2042              while ((ln = listNext(&amp;li)) != NULL) {
2043                  clusterManagerNode *n = ln-&gt;value;
2044                  if (n-&gt;replicate == NULL) continue;
2045                  if (!strcmp(n-&gt;replicate, name) &amp;&amp; !strcmp(n-&gt;ip, ip)) {
2046                      *(offending_p++) = n;
2047                      if (offending_len != NULL) (*offending_len)++;
2048                      break;
2049                  }
2050              }
2051          }
2052          dictReleaseIterator(iter);
2053          dictRelease(related);
2054      }
2055      return score;
2056  }
2057  static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
2058      int ip_count)
2059  {
2060      clusterManagerNode **offenders = NULL;
2061      int score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count,
2062                                                     NULL, NULL);
2063      if (score == 0) goto cleanup;
2064      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Trying to optimize slaves allocation &quot;
2065                            &quot;for anti-affinity\n&quot;);
2066      int node_len = cluster_manager.nodes-&gt;len;
2067      int maxiter = 500 * node_len; 
2068      srand(time(NULL));
2069      while (maxiter &gt; 0) {
2070          int offending_len = 0;
2071          if (offenders != NULL) {
2072              zfree(offenders);
2073              offenders = NULL;
2074          }
2075          score = clusterManagerGetAntiAffinityScore(ipnodes,
2076                                                     ip_count,
2077                                                     &amp;offenders,
2078                                                     &amp;offending_len);
2079          if (score == 0) break; 
2080          int rand_idx = rand() % offending_len;
2081          clusterManagerNode *first = offenders[rand_idx],
2082                             *second = NULL;
2083          clusterManagerNode **other_replicas = zcalloc((node_len - 1) *
2084                                                        sizeof(*other_replicas));
2085          int other_replicas_count = 0;
2086          listIter li;
2087          listNode *ln;
2088          listRewind(cluster_manager.nodes, &amp;li);
2089          while ((ln = listNext(&amp;li)) != NULL) {
2090              clusterManagerNode *n = ln-&gt;value;
2091              if (n != first &amp;&amp; n-&gt;replicate != NULL)
2092                  other_replicas[other_replicas_count++] = n;
2093          }
2094          if (other_replicas_count == 0) {
2095              zfree(other_replicas);
2096              break;
2097          }
2098          rand_idx = rand() % other_replicas_count;
2099          second = other_replicas[rand_idx];
2100          char *first_master = first-&gt;replicate,
2101               *second_master = second-&gt;replicate;
2102          first-&gt;replicate = second_master, first-&gt;dirty = 1;
2103          second-&gt;replicate = first_master, second-&gt;dirty = 1;
2104          int new_score = clusterManagerGetAntiAffinityScore(ipnodes,
2105                                                             ip_count,
2106                                                             NULL, NULL);
2107          if (new_score &gt; score) {
2108              first-&gt;replicate = first_master;
2109              second-&gt;replicate = second_master;
2110          }
2111          zfree(other_replicas);
2112          maxiter--;
2113      }
2114      score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count, NULL, NULL);
2115      char *msg;
2116      int perfect = (score == 0);
2117      int log_level = (perfect ? CLUSTER_MANAGER_LOG_LVL_SUCCESS :
2118                                 CLUSTER_MANAGER_LOG_LVL_WARN);
2119      if (perfect) msg = &quot;[OK] Perfect anti-affinity obtained!&quot;;
2120      else if (score &gt;= 10000)
2121          msg = (&quot;[WARNING] Some slaves are in the same host as their master&quot;);
2122      else
2123          msg=(&quot;[WARNING] Some slaves of the same master are in the same host&quot;);
2124      clusterManagerLog(log_level, &quot;%s\n&quot;, msg);
2125  cleanup:
2126      zfree(offenders);
2127  }
2128  static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
2129      sds flags = sdsempty();
2130      if (!node-&gt;flags_str) return flags;
2131      int empty = 1;
2132      listIter li;
2133      listNode *ln;
2134      listRewind(node-&gt;flags_str, &amp;li);
2135      while ((ln = listNext(&amp;li)) != NULL) {
2136          sds flag = ln-&gt;value;
2137          if (strcmp(flag, &quot;myself&quot;) == 0) continue;
2138          if (!empty) flags = sdscat(flags, &quot;,&quot;);
2139          flags = sdscatfmt(flags, &quot;%S&quot;, flag);
2140          empty = 0;
2141      }
2142      return flags;
2143  }
2144  static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
2145      sds slots = sdsempty();
2146      int first_range_idx = -1, last_slot_idx = -1, i;
2147      for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
2148          int has_slot = node-&gt;slots[i];
2149          if (has_slot) {
2150              if (first_range_idx == -1) {
2151                  if (sdslen(slots)) slots = sdscat(slots, &quot;,&quot;);
2152                  first_range_idx = i;
2153                  slots = sdscatfmt(slots, &quot;[%u&quot;, i);
2154              }
2155              last_slot_idx = i;
2156          } else {
2157              if (last_slot_idx &gt;= 0) {
2158                  if (first_range_idx == last_slot_idx)
2159                      slots = sdscat(slots, &quot;]&quot;);
2160                  else slots = sdscatfmt(slots, &quot;-%u]&quot;, last_slot_idx);
2161              }
2162              last_slot_idx = -1;
2163              first_range_idx = -1;
2164          }
2165      }
2166      if (last_slot_idx &gt;= 0) {
2167          if (first_range_idx == last_slot_idx) slots = sdscat(slots, &quot;]&quot;);
2168          else slots = sdscatfmt(slots, &quot;-%u]&quot;, last_slot_idx);
2169      }
2170      return slots;
2171  }
2172  static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
2173      int s, e; &amp;bsol;* start-end indexes of { and } */
2174      for (s = 0; s &lt; keylen; s++)
2175          if (key[s] == &#x27;{&#x27;) break;
2176      if (s == keylen) return crc16(key,keylen) &amp; 0x3FFF;
2177      for (e = s+1; e &lt; keylen; e++)
2178          if (key[e] == &#x27;}&#x27;) break;
2179      if (e == keylen || e == s+1) return crc16(key,keylen) &amp; 0x3FFF;
2180      return crc16(key+s+1,e-s-1) &amp; 0x3FFF;
2181  }
2182  static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
2183      sds info = sdsempty();
2184      sds spaces = sdsempty();
2185      int i;
2186      for (i = 0; i &lt; indent; i++) spaces = sdscat(spaces, &quot; &quot;);
2187      if (indent) info = sdscat(info, spaces);
2188      int is_master = !(node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE);
2189      char *role = (is_master ? &quot;M&quot; : &quot;S&quot;);
2190      sds slots = NULL;
2191      if (node-&gt;dirty &amp;&amp; node-&gt;replicate != NULL)
2192          info = sdscatfmt(info, &quot;S: %S %s:%u&quot;, node-&gt;name, node-&gt;ip, node-&gt;port);
2193      else {
2194          slots = clusterManagerNodeSlotsString(node);
2195          sds flags = clusterManagerNodeFlagString(node);
2196          info = sdscatfmt(info, &quot;%s: %S %s:%u\n&quot;
2197                                 &quot;%s   slots:%S (%u slots) &quot;
2198                                 &quot;%S&quot;,
2199                                 role, node-&gt;name, node-&gt;ip, node-&gt;port, spaces,
2200                                 slots, node-&gt;slots_count, flags);
2201          sdsfree(slots);
2202          sdsfree(flags);
2203      }
2204      if (node-&gt;replicate != NULL)
2205          info = sdscatfmt(info, &quot;\n%s   replicates %S&quot;, spaces, node-&gt;replicate);
2206      else if (node-&gt;replicas_count)
2207          info = sdscatfmt(info, &quot;\n%s   %U additional replica(s)&quot;,
2208                           spaces, node-&gt;replicas_count);
2209      sdsfree(spaces);
2210      return info;
2211  }
2212  static void clusterManagerShowNodes(void) {
2213      listIter li;
2214      listNode *ln;
2215      listRewind(cluster_manager.nodes, &amp;li);
2216      while ((ln = listNext(&amp;li)) != NULL) {
2217          clusterManagerNode *node = ln-&gt;value;
2218          sds info = clusterManagerNodeInfo(node, 0);
2219          printf(&quot;%s\n&quot;, (char *) info);
2220          sdsfree(info);
2221      }
2222  }
2223  static void clusterManagerShowClusterInfo(void) {
2224      int masters = 0;
2225      int keys = 0;
2226      listIter li;
2227      listNode *ln;
2228      listRewind(cluster_manager.nodes, &amp;li);
2229      while ((ln = listNext(&amp;li)) != NULL) {
2230          clusterManagerNode *node = ln-&gt;value;
2231          if (!(node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE)) {
2232              if (!node-&gt;name) continue;
2233              int replicas = 0;
2234              int dbsize = -1;
2235              char name[9];
2236              memcpy(name, node-&gt;name, 8);
2237              name[8] = &#x27;\0&#x27;;
2238              listIter ri;
2239              listNode *rn;
2240              listRewind(cluster_manager.nodes, &amp;ri);
2241              while ((rn = listNext(&amp;ri)) != NULL) {
2242                  clusterManagerNode *n = rn-&gt;value;
2243                  if (n == node || !(n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE))
2244                      continue;
2245                  if (n-&gt;replicate &amp;&amp; !strcmp(n-&gt;replicate, node-&gt;name))
2246                      replicas++;
2247              }
2248              redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;DBSIZE&quot;);
2249              if (reply != NULL || reply-&gt;type == REDIS_REPLY_INTEGER)
2250                  dbsize = reply-&gt;integer;
2251              if (dbsize &lt; 0) {
2252                  char *err = &quot;&quot;;
2253                  if (reply != NULL &amp;&amp; reply-&gt;type == REDIS_REPLY_ERROR)
2254                      err = reply-&gt;str;
2255                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
2256                  if (reply != NULL) freeReplyObject(reply);
2257                  return;
2258              };
2259              if (reply != NULL) freeReplyObject(reply);
2260              printf(&quot;%s:%d (%s...) -&gt; %d keys | %d slots | %d slaves.\n&quot;,
2261                     node-&gt;ip, node-&gt;port, name, dbsize,
2262                     node-&gt;slots_count, replicas);
2263              masters++;
2264              keys += dbsize;
2265          }
2266      }
2267      clusterManagerLogOk(&quot;[OK] %d keys in %d masters.\n&quot;, keys, masters);
2268      float keys_per_slot = keys / (float) CLUSTER_MANAGER_SLOTS;
2269      printf(&quot;%.2f keys per slot on average.\n&quot;, keys_per_slot);
2270  }
2271  static int clusterManagerAddSlots(clusterManagerNode *node, char**err)
2272  {
2273      redisReply *reply = NULL;
2274      void *_reply = NULL;
2275      int success = 1;
2276      int argc = node-&gt;slots_count + 2;
2277      sds *argv = zmalloc(argc * sizeof(*argv));
2278      size_t *argvlen = zmalloc(argc * sizeof(*argvlen));
2279      argv[0] = &quot;CLUSTER&quot;;
2280      argv[1] = &quot;ADDSLOTS&quot;;
2281      argvlen[0] = 7;
2282      argvlen[1] = 8;
2283      *err = NULL;
2284      int i, argv_idx = 2;
2285      for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
2286          if (argv_idx &gt;= argc) break;
2287          if (node-&gt;slots[i]) {
2288              argv[argv_idx] = sdsfromlonglong((PORT_LONGLONG) i);
2289              argvlen[argv_idx] = sdslen(argv[argv_idx]);
2290              argv_idx++;
2291          }
2292      }
2293      if (!argv_idx) {
2294          success = 0;
2295          goto cleanup;
2296      }
2297      redisAppendCommandArgv(node-&gt;context,argc,(const char**)argv,argvlen);
2298      if (redisGetReply(node-&gt;context, &amp;_reply) != REDIS_OK) {
2299          success = 0;
2300          goto cleanup;
2301      }
2302      reply = (redisReply*) _reply;
2303      success = clusterManagerCheckRedisReply(node, reply, err);
2304  cleanup:
2305      zfree(argvlen);
2306      if (argv != NULL) {
2307          for (i = 2; i &lt; argc; i++) sdsfree(argv[i]);
2308          zfree(argv);
2309      }
2310      if (reply != NULL) freeReplyObject(reply);
2311      return success;
2312  }
2313  static int clusterManagerSetSlot(clusterManagerNode *node1,
2314                                   clusterManagerNode *node2,
2315                                   int slot, const char *status, char **err) {
2316      redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, &quot;CLUSTER &quot;
2317                                                  &quot;SETSLOT %d %s %s&quot;,
2318                                                  slot, status,
2319                                                  (char *) node2-&gt;name);
2320      if (err != NULL) *err = NULL;
2321      if (!reply) return 0;
2322      int success = 1;
2323      if (reply-&gt;type == REDIS_REPLY_ERROR) {
2324          success = 0;
2325          if (err != NULL) {
2326              *err = zmalloc((reply-&gt;len + 1) * sizeof(char));
2327              strcpy(*err, reply-&gt;str);
2328          } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(node1, reply-&gt;str);
2329          goto cleanup;
2330      }
2331  cleanup:
2332      freeReplyObject(reply);
2333      return success;
2334  }
2335  static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
2336      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2337          &quot;CLUSTER SETSLOT %d %s&quot;, slot, &quot;STABLE&quot;);
2338      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2339      if (reply) freeReplyObject(reply);
2340      return success;
2341  }
2342  static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
2343                                   int ignore_unassigned_err)
2344  {
2345      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2346          &quot;CLUSTER DELSLOTS %d&quot;, slot);
2347      char *err = NULL;
2348      int success = clusterManagerCheckRedisReply(node, reply, &amp;err);
2349      if (!success &amp;&amp; reply &amp;&amp; reply-&gt;type == REDIS_REPLY_ERROR &amp;&amp;
2350          ignore_unassigned_err &amp;&amp;
2351          strstr(reply-&gt;str, &quot;already unassigned&quot;) != NULL) success = 1;
2352      if (!success &amp;&amp; err != NULL) {
2353          CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
2354          zfree(err);
2355      }
2356      if (reply) freeReplyObject(reply);
2357      return success;
2358  }
2359  static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
2360      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2361          &quot;CLUSTER ADDSLOTS %d&quot;, slot);
2362      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2363      if (reply) freeReplyObject(reply);
2364      return success;
2365  }
2366  static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
2367                                                  int slot)
2368  {
2369      redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
2370          &quot;CLUSTER COUNTKEYSINSLOT %d&quot;, slot);
2371      int count = -1;
2372      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2373      if (success &amp;&amp; reply-&gt;type == REDIS_REPLY_INTEGER) count = reply-&gt;integer;
2374      if (reply) freeReplyObject(reply);
2375      return count;
2376  }
2377  static int clusterManagerBumpEpoch(clusterManagerNode *node) {
2378      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER BUMPEPOCH&quot;);
2379      int success = clusterManagerCheckRedisReply(node, reply, NULL);
2380      if (reply) freeReplyObject(reply);
2381      return success;
2382  }
2383  static int clusterManagerIgnoreUnassignedErr(redisReply *reply, int bulk_idx) {
2384      if (bulk_idx == 0 &amp;&amp; reply) {
2385          if (reply-&gt;type == REDIS_REPLY_ERROR)
2386              return strstr(reply-&gt;str, &quot;already unassigned&quot;) != NULL;
2387      }
2388      return 0;
2389  }
2390  static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
2391                                        int slot,
2392                                        int do_clear)
2393  {
2394      int success = clusterManagerStartTransaction(owner);
2395      if (!success) return 0;
2396      clusterManagerDelSlot(owner, slot, 1);
2397      clusterManagerAddSlot(owner, slot);
2398      if (do_clear) clusterManagerClearSlotStatus(owner, slot);
2399      clusterManagerBumpEpoch(owner);
2400      success = clusterManagerExecTransaction(owner,
2401          clusterManagerIgnoreUnassignedErr);
2402      return success;
2403  }
2404  static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
2405                                                      clusterManagerNode *target,
2406                                                      redisReply *reply,
2407                                                      int replace, int timeout,
2408                                                      char *dots)
2409  {
2410      redisReply *migrate_reply = NULL;
2411      char **argv = NULL;
2412      size_t *argv_len = NULL;
2413      int c = (replace ? 8 : 7);
2414      if (config.auth) c += 2;
2415      size_t argc = c + reply-&gt;elements;
2416      size_t i, offset = 6; 
2417      argv = zcalloc(argc * sizeof(char *));
2418      argv_len = zcalloc(argc * sizeof(size_t));
2419      char portstr[255];
2420      char timeoutstr[255];
2421      snprintf(portstr, 10, &quot;%d&quot;, target-&gt;port);
2422      snprintf(timeoutstr, 10, &quot;%d&quot;, timeout);
2423      argv[0] = &quot;MIGRATE&quot;;
2424      argv_len[0] = 7;
2425      argv[1] = target-&gt;ip;
2426      argv_len[1] = strlen(target-&gt;ip);
2427      argv[2] = portstr;
2428      argv_len[2] = strlen(portstr);
2429      argv[3] = &quot;&quot;;
2430      argv_len[3] = 0;
2431      argv[4] = &quot;0&quot;;
2432      argv_len[4] = 1;
2433      argv[5] = timeoutstr;
2434      argv_len[5] = strlen(timeoutstr);
2435      if (replace) {
2436          argv[offset] = &quot;REPLACE&quot;;
2437          argv_len[offset] = 7;
2438          offset++;
2439      }
2440      if (config.auth) {
2441          argv[offset] = &quot;AUTH&quot;;
2442          argv_len[offset] = 4;
2443          offset++;
2444          argv[offset] = config.auth;
2445          argv_len[offset] = strlen(config.auth);
2446          offset++;
2447      }
2448      argv[offset] = &quot;KEYS&quot;;
2449      argv_len[offset] = 4;
2450      offset++;
2451      for (i = 0; i &lt; reply-&gt;elements; i++) {
2452          redisReply *entry = reply-&gt;element[i];
2453          size_t idx = i + offset;
2454          assert(entry-&gt;type == REDIS_REPLY_STRING);
2455          argv[idx] = (char *) sdsnew(entry-&gt;str);
2456          argv_len[idx] = entry-&gt;len;
2457          if (dots) dots[i] = &#x27;.&#x27;;
2458      }
2459      if (dots) dots[reply-&gt;elements] = &#x27;\0&#x27;;
2460      void *_reply = NULL;
2461      redisAppendCommandArgv(source-&gt;context,argc,
2462                             (const char**)argv,argv_len);
2463      int success = (redisGetReply(source-&gt;context, &amp;_reply) == REDIS_OK);
2464      for (i = 0; i &lt; reply-&gt;elements; i++) sdsfree(argv[i + offset]);
2465      if (!success) goto cleanup;
2466      migrate_reply = (redisReply *) _reply;
2467  cleanup:
2468      zfree(argv);
2469      zfree(argv_len);
2470      return migrate_reply;
2471  }
2472  static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
2473                                             clusterManagerNode *target,
2474                                             int slot, int timeout,
2475                                             int pipeline, int verbose,
2476                                             char **err)
2477  {
2478      int success = 1;
2479      int replace_existing_keys = (config.cluster_manager_command.flags &amp;
2480              (CLUSTER_MANAGER_CMD_FLAG_FIX | CLUSTER_MANAGER_CMD_FLAG_REPLACE));
2481      while (1) {
2482          char *dots = NULL;
2483          redisReply *reply = NULL, *migrate_reply = NULL;
2484          reply = CLUSTER_MANAGER_COMMAND(source, &quot;CLUSTER &quot;
2485                                          &quot;GETKEYSINSLOT %d %d&quot;, slot,
2486                                          pipeline);
2487          success = (reply != NULL);
2488          if (!success) return 0;
2489          if (reply-&gt;type == REDIS_REPLY_ERROR) {
2490              success = 0;
2491              if (err != NULL) {
2492                  *err = zmalloc((reply-&gt;len + 1) * sizeof(char));
2493                  strcpy(*err, reply-&gt;str);
2494                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(source, *err);
2495              }
2496              goto next;
2497          }
2498          assert(reply-&gt;type == REDIS_REPLY_ARRAY);
2499          size_t count = reply-&gt;elements;
2500          if (count == 0) {
2501              freeReplyObject(reply);
2502              break;
2503          }
2504          if (verbose) dots = zmalloc((count+1) * sizeof(char));
2505          migrate_reply = clusterManagerMigrateKeysInReply(source, target,
2506                                                           reply, 0, timeout,
2507                                                           dots);
2508          if (migrate_reply == NULL) goto next;
2509          if (migrate_reply-&gt;type == REDIS_REPLY_ERROR) {
2510              int is_busy = strstr(migrate_reply-&gt;str, &quot;BUSYKEY&quot;) != NULL;
2511              int not_served = strstr(migrate_reply-&gt;str, &quot;slot not served&quot;) != NULL;
2512              if (replace_existing_keys &amp;&amp; (is_busy || not_served)) {
2513                  if (not_served)
2514                      clusterManagerSetSlot(source, target, slot, &quot;node&quot;, NULL);
2515                  clusterManagerLogWarn(&quot;*** Target key exists. &quot;
2516                                        &quot;Replacing it for FIX.\n&quot;);
2517                  freeReplyObject(migrate_reply);
2518                  migrate_reply = clusterManagerMigrateKeysInReply(source,
2519                                                                   target,
2520                                                                   reply,
2521                                                                   is_busy,
2522                                                                   timeout,
2523                                                                   NULL);
2524                  success = (migrate_reply != NULL &amp;&amp;
2525                             migrate_reply-&gt;type != REDIS_REPLY_ERROR);
2526              } else success = 0;
2527              if (!success) {
2528                  if (migrate_reply != NULL) {
2529                      if (err) {
2530                          *err = zmalloc((migrate_reply-&gt;len + 1) * sizeof(char));
2531                          strcpy(*err, migrate_reply-&gt;str);
2532                      }
2533                      printf(&quot;\n&quot;);
2534                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(source,
2535                                                        migrate_reply-&gt;str);
2536                  }
2537                  goto next;
2538              }
2539          }
2540          if (verbose) {
2541              printf(&quot;%s&quot;, dots);
2542              fflush(stdout);
2543          }
2544  next:
2545          if (reply != NULL) freeReplyObject(reply);
2546          if (migrate_reply != NULL) freeReplyObject(migrate_reply);
2547          if (dots) zfree(dots);
2548          if (!success) break;
2549      }
2550      return success;
2551  }
2552  static int clusterManagerMoveSlot(clusterManagerNode *source,
2553                                    clusterManagerNode *target,
2554                                    int slot, int opts,  char**err)
2555  {
2556      if (!(opts &amp; CLUSTER_MANAGER_OPT_QUIET)) {
2557          printf(&quot;Moving slot %d from %s:%d to %s:%d: &quot;, slot, source-&gt;ip,
2558                 source-&gt;port, target-&gt;ip, target-&gt;port);
2559          fflush(stdout);
2560      }
2561      if (err != NULL) *err = NULL;
2562      int pipeline = config.cluster_manager_command.pipeline,
2563          timeout = config.cluster_manager_command.timeout,
2564          print_dots = (opts &amp; CLUSTER_MANAGER_OPT_VERBOSE),
2565          option_cold = (opts &amp; CLUSTER_MANAGER_OPT_COLD),
2566          success = 1;
2567      if (!option_cold) {
2568          success = clusterManagerSetSlot(target, source, slot,
2569                                          &quot;importing&quot;, err);
2570          if (!success) return 0;
2571          success = clusterManagerSetSlot(source, target, slot,
2572                                          &quot;migrating&quot;, err);
2573          if (!success) return 0;
2574      }
2575      success = clusterManagerMigrateKeysInSlot(source, target, slot, timeout,
2576                                                pipeline, print_dots, err);
2577      if (!(opts &amp; CLUSTER_MANAGER_OPT_QUIET)) printf(&quot;\n&quot;);
2578      if (!success) return 0;
2579      if (!option_cold) {
2580          listIter li;
2581          listNode *ln;
2582          listRewind(cluster_manager.nodes, &amp;li);
2583          while ((ln = listNext(&amp;li)) != NULL) {
2584              clusterManagerNode *n = ln-&gt;value;
2585              if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
2586              redisReply *r = CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER &quot;
2587                                                      &quot;SETSLOT %d %s %s&quot;,
2588                                                      slot, &quot;node&quot;,
2589                                                      target-&gt;name);
2590              success = (r != NULL);
2591              if (!success) return 0;
2592              if (r-&gt;type == REDIS_REPLY_ERROR) {
2593                  success = 0;
2594                  if (err != NULL) {
2595                      *err = zmalloc((r-&gt;len + 1) * sizeof(char));
2596                      strcpy(*err, r-&gt;str);
2597                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, *err);
2598                  }
2599              }
2600              freeReplyObject(r);
2601              if (!success) return 0;
2602          }
2603      }
2604      if (opts &amp; CLUSTER_MANAGER_OPT_UPDATE) {
2605          source-&gt;slots[slot] = 0;
2606          target-&gt;slots[slot] = 1;
2607      }
2608      return 1;
2609  }
2610  static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
2611      if (!node-&gt;dirty) return 0;
2612      redisReply *reply = NULL;
2613      int is_err = 0, success = 1;
2614      if (err != NULL) *err = NULL;
2615      if (node-&gt;replicate != NULL) {
2616          reply = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER REPLICATE %s&quot;,
2617                                          node-&gt;replicate);
2618          if (reply == NULL || (is_err = (reply-&gt;type == REDIS_REPLY_ERROR))) {
2619              if (is_err &amp;&amp; err != NULL) {
2620                  *err = zmalloc((reply-&gt;len + 1) * sizeof(char));
2621                  strcpy(*err, reply-&gt;str);
2622              }
2623              success = 0;
2624              goto cleanup;
2625          }
2626      } else {
2627          int added = clusterManagerAddSlots(node, err);
2628          if (!added || *err != NULL) success = 0;
2629      }
2630      node-&gt;dirty = 0;
2631  cleanup:
2632      if (reply != NULL) freeReplyObject(reply);
2633      return success;
2634  }
2635  static void clusterManagerWaitForClusterJoin(void) {
2636      printf(&quot;Waiting for the cluster to join\n&quot;);
2637      while(!clusterManagerIsConfigConsistent()) {
2638          printf(&quot;.&quot;);
2639          fflush(stdout);
2640          sleep(1);
2641      }
2642      printf(&quot;\n&quot;);
2643  }
2644  static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
2645                                        char **err)
2646  {
2647      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER NODES&quot;);
2648      int success = 1;
2649      *err = NULL;
2650      if (!clusterManagerCheckRedisReply(node, reply, err)) {
2651          success = 0;
2652          goto cleanup;
2653      }
2654      int getfriends = (opts &amp; CLUSTER_MANAGER_OPT_GETFRIENDS);
2655      char *lines = reply-&gt;str, *p, *line;
2656      while ((p = strstr(lines, &quot;\n&quot;)) != NULL) {
2657          *p = &#x27;\0&#x27;;
2658          line = lines;
2659          lines = p + 1;
2660          char *name = NULL, *addr = NULL, *flags = NULL, *master_id = NULL,
2661               *ping_sent = NULL, *ping_recv = NULL, *config_epoch = NULL,
2662               *link_status = NULL;
2663          UNUSED(link_status);
2664          int i = 0;
2665          while ((p = strchr(line, &#x27; &#x27;)) != NULL) {
2666              *p = &#x27;\0&#x27;;
2667              char *token = line;
2668              line = p + 1;
2669              switch(i++){
2670              case 0: name = token; break;
2671              case 1: addr = token; break;
2672              case 2: flags = token; break;
2673              case 3: master_id = token; break;
2674              case 4: ping_sent = token; break;
2675              case 5: ping_recv = token; break;
2676              case 6: config_epoch = token; break;
2677              case 7: link_status = token; break;
2678              }
2679              if (i == 8) break; 
2680          }
2681          if (!flags) {
2682              success = 0;
2683              goto cleanup;
2684          }
2685          int myself = (strstr(flags, &quot;myself&quot;) != NULL);
2686          clusterManagerNode *currentNode = NULL;
2687          if (myself) {
2688              node-&gt;flags |= CLUSTER_MANAGER_FLAG_MYSELF;
2689              currentNode = node;
2690              clusterManagerNodeResetSlots(node);
2691              if (i == 8) {
2692                  int remaining = strlen(line);
2693                  while (remaining &gt; 0) {
2694                      p = strchr(line, &#x27; &#x27;);
2695                      if (p == NULL) p = line + remaining;
2696                      remaining -= (p - line);
2697                      char *slotsdef = line;
2698                      *p = &#x27;\0&#x27;;
2699                      if (remaining) {
2700                          line = p + 1;
2701                          remaining--;
2702                      } else line = p;
2703                      char *dash = NULL;
2704                      if (slotsdef[0] == &#x27;[&#x27;) {
2705                          slotsdef++;
2706                          if ((p = strstr(slotsdef, &quot;-&gt;-&quot;))) { 
2707                              *p = &#x27;\0&#x27;;
2708                              p += 3;
2709                              char *closing_bracket = strchr(p, &#x27;]&#x27;);
2710                              if (closing_bracket) *closing_bracket = &#x27;\0&#x27;;
2711                              sds slot = sdsnew(slotsdef);
2712                              sds dst = sdsnew(p);
2713                              node-&gt;migrating_count += 2;
2714                              node-&gt;migrating = zrealloc(node-&gt;migrating,
2715                                  (node-&gt;migrating_count * sizeof(sds)));
2716                              node-&gt;migrating[node-&gt;migrating_count - 2] =
2717                                  slot;
2718                              node-&gt;migrating[node-&gt;migrating_count - 1] =
2719                                  dst;
2720                          }  else if ((p = strstr(slotsdef, &quot;-&lt;-&quot;))) {
2721                              *p = &#x27;\0&#x27;;
2722                              p += 3;
2723                              char *closing_bracket = strchr(p, &#x27;]&#x27;);
2724                              if (closing_bracket) *closing_bracket = &#x27;\0&#x27;;
2725                              sds slot = sdsnew(slotsdef);
2726                              sds src = sdsnew(p);
2727                              node-&gt;importing_count += 2;
2728                              node-&gt;importing = zrealloc(node-&gt;importing,
2729                                  (node-&gt;importing_count * sizeof(sds)));
2730                              node-&gt;importing[node-&gt;importing_count - 2] =
2731                                  slot;
2732                              node-&gt;importing[node-&gt;importing_count - 1] =
2733                                  src;
2734                          }
2735                      } else if ((dash = strchr(slotsdef, &#x27;-&#x27;)) != NULL) {
2736                          p = dash;
2737                          int start, stop;
2738                          *p = &#x27;\0&#x27;;
2739                          start = atoi(slotsdef);
2740                          stop = atoi(p + 1);
2741                          node-&gt;slots_count += (stop - (start - 1));
2742                          while (start &lt;= stop) node-&gt;slots[start++] = 1;
2743                      } else if (p &gt; slotsdef) {
2744                          node-&gt;slots[atoi(slotsdef)] = 1;
2745                          node-&gt;slots_count++;
2746                      }
2747                  }
2748              }
2749              node-&gt;dirty = 0;
2750          } else if (!getfriends) {
2751              if (!(node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_MYSELF)) continue;
2752              else break;
2753          } else {
2754              if (addr == NULL) {
2755                  fprintf(stderr, &quot;Error: invalid CLUSTER NODES reply\n&quot;);
2756                  success = 0;
2757                  goto cleanup;
2758              }
2759              char *c = strrchr(addr, &#x27;@&#x27;);
2760              if (c != NULL) *c = &#x27;\0&#x27;;
2761              c = strrchr(addr, &#x27;:&#x27;);
2762              if (c == NULL) {
2763                  fprintf(stderr, &quot;Error: invalid CLUSTER NODES reply\n&quot;);
2764                  success = 0;
2765                  goto cleanup;
2766              }
2767              *c = &#x27;\0&#x27;;
2768              int port = atoi(++c);
2769              currentNode = clusterManagerNewNode(sdsnew(addr), port);
2770              currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_FRIEND;
2771              if (node-&gt;friends == NULL) node-&gt;friends = listCreate();
2772              listAddNodeTail(node-&gt;friends, currentNode);
2773          }
2774          if (name != NULL) {
2775              if (currentNode-&gt;name) sdsfree(currentNode-&gt;name);
2776              currentNode-&gt;name = sdsnew(name);
2777          }
2778          if (currentNode-&gt;flags_str != NULL)
2779              freeClusterManagerNodeFlags(currentNode-&gt;flags_str);
2780          currentNode-&gt;flags_str = listCreate();
2781          int flag_len;
2782          while ((flag_len = strlen(flags)) &gt; 0) {
2783              sds flag = NULL;
2784              char *fp = strchr(flags, &#x27;,&#x27;);
2785              if (fp) {
2786                  *fp = &#x27;\0&#x27;;
2787                  flag = sdsnew(flags);
2788                  flags = fp + 1;
2789              } else {
2790                  flag = sdsnew(flags);
2791                  flags += flag_len;
2792              }
2793              if (strcmp(flag, &quot;noaddr&quot;) == 0)
2794                  currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_NOADDR;
2795              else if (strcmp(flag, &quot;disconnected&quot;) == 0)
2796                  currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_DISCONNECT;
2797              else if (strcmp(flag, &quot;fail&quot;) == 0)
2798                  currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_FAIL;
2799              else if (strcmp(flag, &quot;slave&quot;) == 0) {
2800                  currentNode-&gt;flags |= CLUSTER_MANAGER_FLAG_SLAVE;
2801                  if (master_id != NULL) {
2802                      if (currentNode-&gt;replicate) sdsfree(currentNode-&gt;replicate);
2803                      currentNode-&gt;replicate = sdsnew(master_id);
2804                  }
2805              }
2806              listAddNodeTail(currentNode-&gt;flags_str, flag);
2807          }
2808          if (config_epoch != NULL)
2809              currentNode-&gt;current_epoch = atoll(config_epoch);
2810          if (ping_sent != NULL) currentNode-&gt;ping_sent = atoll(ping_sent);
2811          if (ping_recv != NULL) currentNode-&gt;ping_recv = atoll(ping_recv);
2812          if (!getfriends &amp;&amp; myself) break;
2813      }
2814  cleanup:
2815      if (reply) freeReplyObject(reply);
2816      return success;
2817  }
2818  static int clusterManagerLoadInfoFromNode(clusterManagerNode *node, int opts) {
2819      if (node-&gt;context == NULL &amp;&amp; !clusterManagerNodeConnect(node)) {
2820          freeClusterManagerNode(node);
2821          return 0;
2822      }
2823      opts |= CLUSTER_MANAGER_OPT_GETFRIENDS;
2824      char *e = NULL;
2825      if (!clusterManagerNodeIsCluster(node, &amp;e)) {
2826          clusterManagerPrintNotClusterNodeError(node, e);
2827          if (e) zfree(e);
2828          freeClusterManagerNode(node);
2829          return 0;
2830      }
2831      e = NULL;
2832      if (!clusterManagerNodeLoadInfo(node, opts, &amp;e)) {
2833          if (e) {
2834              CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, e);
2835              zfree(e);
2836          }
2837          freeClusterManagerNode(node);
2838          return 0;
2839      }
<span onclick='openModal()' class='match'>2840      listIter li;
2841      listNode *ln;
2842      if (cluster_manager.nodes != NULL) {
2843          listRewind(cluster_manager.nodes, &amp;li);
2844          while ((ln = listNext(&amp;li)) != NULL)
2845              freeClusterManagerNode((clusterManagerNode *) ln-&gt;value);
</span>2846          listRelease(cluster_manager.nodes);
2847      }
2848      cluster_manager.nodes = listCreate();
2849      listAddNodeTail(cluster_manager.nodes, node);
2850      if (node-&gt;friends != NULL) {
2851          listRewind(node-&gt;friends, &amp;li);
2852          while ((ln = listNext(&amp;li)) != NULL) {
2853              clusterManagerNode *friend = ln-&gt;value;
2854              if (!friend-&gt;ip || !friend-&gt;port) goto invalid_friend;
2855              if (!friend-&gt;context &amp;&amp; !clusterManagerNodeConnect(friend))
2856                  goto invalid_friend;
2857              e = NULL;
2858              if (clusterManagerNodeLoadInfo(friend, 0, &amp;e)) {
2859                  if (friend-&gt;flags &amp; (CLUSTER_MANAGER_FLAG_NOADDR |
2860                                       CLUSTER_MANAGER_FLAG_DISCONNECT |
2861                                       CLUSTER_MANAGER_FLAG_FAIL))
2862                      goto invalid_friend;
2863                  listAddNodeTail(cluster_manager.nodes, friend);
2864              } else {
2865                  clusterManagerLogErr(&quot;[ERR] Unable to load info for &quot;
2866                                       &quot;node %s:%d\n&quot;,
2867                                       friend-&gt;ip, friend-&gt;port);
2868                  goto invalid_friend;
2869              }
2870              continue;
2871  invalid_friend:
2872              freeClusterManagerNode(friend);
2873          }
2874          listRelease(node-&gt;friends);
2875          node-&gt;friends = NULL;
2876      }
2877      listRewind(cluster_manager.nodes, &amp;li);
2878      while ((ln = listNext(&amp;li)) != NULL) {
2879          clusterManagerNode *n = ln-&gt;value;
2880          if (n-&gt;replicate != NULL) {
2881              clusterManagerNode *master = clusterManagerNodeByName(n-&gt;replicate);
2882              if (master == NULL) {
2883                  clusterManagerLogWarn(&quot;*** WARNING: %s:%d claims to be &quot;
2884                                        &quot;slave of unknown node ID %s.\n&quot;,
2885                                        n-&gt;ip, n-&gt;port, n-&gt;replicate);
2886              } else master-&gt;replicas_count++;
2887          }
2888      }
2889      return 1;
2890  }
2891  int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
2892      const char **i1 = (const char **)slot1;
2893      const char **i2 = (const char **)slot2;
2894      return strcmp(*i1, *i2);
2895  }
2896  int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
2897      clusterManagerNode *node1 = *((clusterManagerNode **) n1);
2898      clusterManagerNode *node2 = *((clusterManagerNode **) n2);
2899      return node2-&gt;slots_count - node1-&gt;slots_count;
2900  }
2901  int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
2902      clusterManagerNode *node1 = *((clusterManagerNode **) n1);
2903      clusterManagerNode *node2 = *((clusterManagerNode **) n2);
2904      return node1-&gt;balance - node2-&gt;balance;
2905  }
2906  static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {
2907      sds signature = NULL;
2908      int node_count = 0, i = 0, name_len = 0;
2909      char **node_configs = NULL;
2910      redisReply *reply = CLUSTER_MANAGER_COMMAND(node, &quot;CLUSTER NODES&quot;);
2911      if (reply == NULL || reply-&gt;type == REDIS_REPLY_ERROR)
2912          goto cleanup;
2913      char *lines = reply-&gt;str, *p, *line;
2914      while ((p = strstr(lines, &quot;\n&quot;)) != NULL) {
2915          i = 0;
2916          *p = &#x27;\0&#x27;;
2917          line = lines;
2918          lines = p + 1;
2919          char *nodename = NULL;
2920          int tot_size = 0;
2921          while ((p = strchr(line, &#x27; &#x27;)) != NULL) {
2922              *p = &#x27;\0&#x27;;
2923              char *token = line;
2924              line = p + 1;
2925              if (i == 0) {
2926                  nodename = token;
2927                  tot_size = (p - token);
2928                  name_len = tot_size++; 
2929              }
2930              if (++i == 8) break;
2931          }
2932          if (i != 8) continue;
2933          if (nodename == NULL) continue;
2934          int remaining = strlen(line);
2935          if (remaining == 0) continue;
2936          char **slots = NULL;
2937          int c = 0;
2938          while (remaining &gt; 0) {
2939              p = strchr(line, &#x27; &#x27;);
2940              if (p == NULL) p = line + remaining;
2941              int size = (p - line);
2942              remaining -= size;
2943              tot_size += size;
2944              char *slotsdef = line;
2945              *p = &#x27;\0&#x27;;
2946              if (remaining) {
2947                  line = p + 1;
2948                  remaining--;
2949              } else line = p;
2950              if (slotsdef[0] != &#x27;[&#x27;) {
2951                  c++;
2952                  slots = zrealloc(slots, (c * sizeof(char *)));
2953                  slots[c - 1] = slotsdef;
2954              }
2955          }
2956          if (c &gt; 0) {
2957              if (c &gt; 1)
2958                  qsort(slots, c, sizeof(char *), clusterManagerSlotCompare);
2959              node_count++;
2960              node_configs =
2961                  zrealloc(node_configs, (node_count * sizeof(char *)));
2962              tot_size += (sizeof(char) * (c - 1));
2963              char *cfg = zmalloc((sizeof(char) * tot_size) + 1);
2964              memcpy(cfg, nodename, name_len);
2965              char *sp = cfg + name_len;
2966              *(sp++) = &#x27;:&#x27;;
2967              for (i = 0; i &lt; c; i++) {
2968                  if (i &gt; 0) *(sp++) = &#x27;,&#x27;;
2969                  int slen = strlen(slots[i]);
2970                  memcpy(sp, slots[i], slen);
2971                  sp += slen;
2972              }
2973              *(sp++) = &#x27;\0&#x27;;
2974              node_configs[node_count - 1] = cfg;
2975          }
2976          zfree(slots);
2977      }
2978      if (node_count &gt; 0) {
2979          if (node_count &gt; 1) {
2980              qsort(node_configs, node_count, sizeof(char *),
2981                    clusterManagerSlotCompare);
2982          }
2983          signature = sdsempty();
2984          for (i = 0; i &lt; node_count; i++) {
2985              if (i &gt; 0) signature = sdscatprintf(signature, &quot;%c&quot;, &#x27;|&#x27;);
2986              signature = sdscatfmt(signature, &quot;%s&quot;, node_configs[i]);
2987          }
2988      }
2989  cleanup:
2990      if (reply != NULL) freeReplyObject(reply);
2991      if (node_configs != NULL) {
2992          for (i = 0; i &lt; node_count; i++) zfree(node_configs[i]);
2993          zfree(node_configs);
2994      }
2995      return signature;
2996  }
2997  static int clusterManagerIsConfigConsistent(void) {
2998      if (cluster_manager.nodes == NULL) return 0;
2999      int consistent = (listLength(cluster_manager.nodes) &lt;= 1);
3000      if (consistent) return 1;
3001      sds first_cfg = NULL;
3002      listIter li;
3003      listNode *ln;
3004      listRewind(cluster_manager.nodes, &amp;li);
3005      while ((ln = listNext(&amp;li)) != NULL) {
3006          clusterManagerNode *node = ln-&gt;value;
3007          sds cfg = clusterManagerGetConfigSignature(node);
3008          if (cfg == NULL) {
3009              consistent = 0;
3010              break;
3011          }
3012          if (first_cfg == NULL) first_cfg = cfg;
3013          else {
3014              consistent = !sdscmp(first_cfg, cfg);
3015              sdsfree(cfg);
3016              if (!consistent) break;
3017          }
3018      }
3019      if (first_cfg != NULL) sdsfree(first_cfg);
3020      return consistent;
3021  }
3022  static void clusterManagerOnError(sds err) {
3023      if (cluster_manager.errors == NULL)
3024          cluster_manager.errors = listCreate();
3025      listAddNodeTail(cluster_manager.errors, err);
3026      clusterManagerLogErr(&quot;%s\n&quot;, (char *) err);
3027  }
3028  static int clusterManagerGetCoveredSlots(char *all_slots) {
3029      if (cluster_manager.nodes == NULL) return 0;
3030      listIter li;
3031      listNode *ln;
3032      listRewind(cluster_manager.nodes, &amp;li);
3033      int totslots = 0, i;
3034      while ((ln = listNext(&amp;li)) != NULL) {
3035          clusterManagerNode *node = ln-&gt;value;
3036          for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
3037              if (node-&gt;slots[i] &amp;&amp; !all_slots[i]) {
3038                  all_slots[i] = 1;
3039                  totslots++;
3040              }
3041          }
3042      }
3043      return totslots;
3044  }
3045  static void clusterManagerPrintSlotsList(list *slots) {
3046      listIter li;
3047      listNode *ln;
3048      listRewind(slots, &amp;li);
3049      sds first = NULL;
3050      while ((ln = listNext(&amp;li)) != NULL) {
3051          sds slot = ln-&gt;value;
3052          if (!first) first = slot;
3053          else printf(&quot;, &quot;);
3054          printf(&quot;%s&quot;, slot);
3055      }
3056      printf(&quot;\n&quot;);
3057  }
3058  static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
3059                                                                      int slot,
3060                                                                      char **err)
3061  {
3062      clusterManagerNode *node = NULL;
3063      int numkeys = 0;
3064      listIter li;
3065      listNode *ln;
3066      listRewind(nodes, &amp;li);
3067      if (err) *err = NULL;
3068      while ((ln = listNext(&amp;li)) != NULL) {
3069          clusterManagerNode *n = ln-&gt;value;
3070          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE || n-&gt;replicate)
3071              continue;
3072          redisReply *r =
3073              CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER COUNTKEYSINSLOT %d&quot;, slot);
3074          int success = clusterManagerCheckRedisReply(n, r, err);
3075          if (success) {
3076              if (r-&gt;integer &gt; numkeys || node == NULL) {
3077                  numkeys = r-&gt;integer;
3078                  node = n;
3079              }
3080          }
3081          if (r != NULL) freeReplyObject(r);
3082          if (!success) {
3083              if (err != NULL &amp;&amp; *err != NULL)
3084                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, err);
3085              node = NULL;
3086              break;
3087          }
3088      }
3089      return node;
3090  }
3091  static clusterManagerNode *clusterManagerNodeWithLeastReplicas() {
3092      clusterManagerNode *node = NULL;
3093      int lowest_count = 0;
3094      listIter li;
3095      listNode *ln;
3096      listRewind(cluster_manager.nodes, &amp;li);
3097      while ((ln = listNext(&amp;li)) != NULL) {
3098          clusterManagerNode *n = ln-&gt;value;
3099          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3100          if (node == NULL || n-&gt;replicas_count &lt; lowest_count) {
3101              node = n;
3102              lowest_count = n-&gt;replicas_count;
3103          }
3104      }
3105      return node;
3106  }
3107  static clusterManagerNode *clusterManagerNodeMasterRandom() {
3108      int master_count = 0;
3109      int idx;
3110      listIter li;
3111      listNode *ln;
3112      listRewind(cluster_manager.nodes, &amp;li);
3113      while ((ln = listNext(&amp;li)) != NULL) {
3114          clusterManagerNode *n = ln-&gt;value;
3115          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3116          master_count++;
3117      }
3118      srand(time(NULL));
3119      idx = rand() % master_count;
3120      listRewind(cluster_manager.nodes, &amp;li);
3121      while ((ln = listNext(&amp;li)) != NULL) {
3122          clusterManagerNode *n = ln-&gt;value;
3123          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3124          if (!idx--) {
3125              return n;
3126          }
3127      }
3128      return NULL;
3129  }
3130  static int clusterManagerFixSlotsCoverage(char *all_slots) {
3131      int i, fixed = 0;
3132      list *none = NULL, *single = NULL, *multi = NULL;
3133      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Fixing slots coverage...\n&quot;);
3134      printf(&quot;List of not covered slots: \n&quot;);
3135      int uncovered_count = 0;
3136      sds log = sdsempty();
3137      for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
3138          int covered = all_slots[i];
3139          if (!covered) {
3140              sds key = sdsfromlonglong((PORT_LONGLONG) i);
3141              if (uncovered_count++ &gt; 0) printf(&quot;,&quot;);
3142              printf(&quot;%s&quot;, (char *) key);
3143              list *slot_nodes = listCreate();
3144              sds slot_nodes_str = sdsempty();
3145              listIter li;
3146              listNode *ln;
3147              listRewind(cluster_manager.nodes, &amp;li);
3148              while ((ln = listNext(&amp;li)) != NULL) {
3149                  clusterManagerNode *n = ln-&gt;value;
3150                  if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE || n-&gt;replicate)
3151                      continue;
3152                  redisReply *reply = CLUSTER_MANAGER_COMMAND(n,
3153                      &quot;CLUSTER GETKEYSINSLOT %d %d&quot;, i, 1);
3154                  if (!clusterManagerCheckRedisReply(n, reply, NULL)) {
3155                      fixed = -1;
3156                      if (reply) freeReplyObject(reply);
3157                      goto cleanup;
3158                  }
3159                  assert(reply-&gt;type == REDIS_REPLY_ARRAY);
3160                  if (reply-&gt;elements &gt; 0) {
3161                      listAddNodeTail(slot_nodes, n);
3162                      if (listLength(slot_nodes) &gt; 1)
3163                          slot_nodes_str = sdscat(slot_nodes_str, &quot;, &quot;);
3164                      slot_nodes_str = sdscatfmt(slot_nodes_str,
3165                                                 &quot;%s:%u&quot;, n-&gt;ip, n-&gt;port);
3166                  }
3167                  freeReplyObject(reply);
3168              }
3169              log = sdscatfmt(log, &quot;\nSlot %S has keys in %u nodes: %S&quot;,
3170                              key, listLength(slot_nodes), slot_nodes_str);
3171              sdsfree(slot_nodes_str);
3172              dictAdd(clusterManagerUncoveredSlots, key, slot_nodes);
3173          }
3174      }
3175      printf(&quot;\n%s\n&quot;, log);
3176      none = listCreate();
3177      single = listCreate();
3178      multi = listCreate();
3179      dictIterator *iter = dictGetIterator(clusterManagerUncoveredSlots);
3180      dictEntry *entry;
3181      while ((entry = dictNext(iter)) != NULL) {
3182          sds slot = (sds) dictGetKey(entry);
3183          list *nodes = (list *) dictGetVal(entry);
3184          switch (listLength(nodes)){
3185          case 0: listAddNodeTail(none, slot); break;
3186          case 1: listAddNodeTail(single, slot); break;
3187          default: listAddNodeTail(multi, slot); break;
3188          }
3189      }
3190      dictReleaseIterator(iter);
3191      if (listLength(none) &gt; 0) {
3192          printf(&quot;The following uncovered slots have no keys &quot;
3193                 &quot;across the cluster:\n&quot;);
3194          clusterManagerPrintSlotsList(none);
3195          if (confirmWithYes(&quot;Fix these slots by covering with a random node?&quot;)){
3196              listIter li;
3197              listNode *ln;
3198              listRewind(none, &amp;li);
3199              while ((ln = listNext(&amp;li)) != NULL) {
3200                  sds slot = ln-&gt;value;
3201                  int s = atoi(slot);
3202                  clusterManagerNode *n = clusterManagerNodeMasterRandom();
3203                  clusterManagerLogInfo(&quot;&gt;&gt;&gt; Covering slot %s with %s:%d\n&quot;,
3204                                        slot, n-&gt;ip, n-&gt;port);
3205                  if (!clusterManagerSetSlotOwner(n, s, 0)) {
3206                      fixed = -1;
3207                      goto cleanup;
3208                  }
3209                  n-&gt;slots[s] = 1;
3210                  fixed++;
3211              }
3212          }
3213      }
3214      if (listLength(single) &gt; 0) {
3215          printf(&quot;The following uncovered slots have keys in just one node:\n&quot;);
3216          clusterManagerPrintSlotsList(single);
3217          if (confirmWithYes(&quot;Fix these slots by covering with those nodes?&quot;)){
3218              listIter li;
3219              listNode *ln;
3220              listRewind(single, &amp;li);
3221              while ((ln = listNext(&amp;li)) != NULL) {
3222                  sds slot = ln-&gt;value;
3223                  int s = atoi(slot);
3224                  dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);
3225                  assert(entry != NULL);
3226                  list *nodes = (list *) dictGetVal(entry);
3227                  listNode *fn = listFirst(nodes);
3228                  assert(fn != NULL);
3229                  clusterManagerNode *n = fn-&gt;value;
3230                  clusterManagerLogInfo(&quot;&gt;&gt;&gt; Covering slot %s with %s:%d\n&quot;,
3231                                        slot, n-&gt;ip, n-&gt;port);
3232                  if (!clusterManagerSetSlotOwner(n, s, 0)) {
3233                      fixed = -1;
3234                      goto cleanup;
3235                  }
3236                  n-&gt;slots[atoi(slot)] = 1;
3237                  fixed++;
3238              }
3239          }
3240      }
3241      if (listLength(multi) &gt; 0) {
3242          printf(&quot;The following uncovered slots have keys in multiple nodes:\n&quot;);
3243          clusterManagerPrintSlotsList(multi);
3244          if (confirmWithYes(&quot;Fix these slots by moving keys &quot;
3245                             &quot;into a single node?&quot;)) {
3246              listIter li;
3247              listNode *ln;
3248              listRewind(multi, &amp;li);
3249              while ((ln = listNext(&amp;li)) != NULL) {
3250                  sds slot = ln-&gt;value;
3251                  dictEntry *entry = dictFind(clusterManagerUncoveredSlots, slot);
3252                  assert(entry != NULL);
3253                  list *nodes = (list *) dictGetVal(entry);
3254                  int s = atoi(slot);
3255                  clusterManagerNode *target =
3256                      clusterManagerGetNodeWithMostKeysInSlot(nodes, s, NULL);
3257                  if (target == NULL) {
3258                      fixed = -1;
3259                      goto cleanup;
3260                  }
3261                  clusterManagerLogInfo(&quot;&gt;&gt;&gt; Covering slot %s moving keys &quot;
3262                                        &quot;to %s:%d\n&quot;, slot,
3263                                        target-&gt;ip, target-&gt;port);
3264                  if (!clusterManagerSetSlotOwner(target, s, 1)) {
3265                      fixed = -1;
3266                      goto cleanup;
3267                  }
3268                  target-&gt;slots[atoi(slot)] = 1;
3269                  listIter nli;
3270                  listNode *nln;
3271                  listRewind(nodes, &amp;nli);
3272                  while ((nln = listNext(&amp;nli)) != NULL) {
3273                      clusterManagerNode *src = nln-&gt;value;
3274                      if (src == target) continue;
3275                      if (!clusterManagerSetSlot(src, target, s, &quot;NODE&quot;, NULL))
3276                          fixed = -1;
3277                      if (fixed &lt; 0) goto cleanup;
3278                      if (!clusterManagerSetSlot(src, target, s,
3279                                                 &quot;IMPORTING&quot;, NULL)) fixed = -1;
3280                      if (fixed &lt; 0) goto cleanup;
3281                      int opts = CLUSTER_MANAGER_OPT_VERBOSE |
3282                                 CLUSTER_MANAGER_OPT_COLD;
3283                      if (!clusterManagerMoveSlot(src, target, s, opts, NULL)) {
3284                          fixed = -1;
3285                          goto cleanup;
3286                      }
3287                      if (!clusterManagerClearSlotStatus(src, s))
3288                          fixed = -1;
3289                      if (fixed &lt; 0) goto cleanup;
3290                  }
3291                  fixed++;
3292              }
3293          }
3294      }
3295  cleanup:
3296      sdsfree(log);
3297      if (none) listRelease(none);
3298      if (single) listRelease(single);
3299      if (multi) listRelease(multi);
3300      return fixed;
3301  }
3302  static int clusterManagerFixOpenSlot(int slot) {
3303      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Fixing open slot %d\n&quot;, slot);
3304      int success = 1;
3305      list *owners = listCreate();
3306      list *migrating = listCreate();
3307      list *importing = listCreate();
3308      sds migrating_str = sdsempty();
3309      sds importing_str = sdsempty();
3310      clusterManagerNode *owner = NULL;
3311      listIter li;
3312      listNode *ln;
3313      listRewind(cluster_manager.nodes, &amp;li);
3314      while ((ln = listNext(&amp;li)) != NULL) {
3315          clusterManagerNode *n = ln-&gt;value;
3316          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3317          if (n-&gt;slots[slot]) listAddNodeTail(owners, n);
3318          else {
3319              redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3320                  &quot;CLUSTER COUNTKEYSINSLOT %d&quot;, slot);
3321              success = clusterManagerCheckRedisReply(n, r, NULL);
3322              if (success &amp;&amp; r-&gt;integer &gt; 0) {
3323                  clusterManagerLogWarn(&quot;*** Found keys about slot %d &quot;
3324                                        &quot;in non-owner node %s:%d!\n&quot;, slot,
3325                                        n-&gt;ip, n-&gt;port);
3326                  listAddNodeTail(owners, n);
3327              }
3328              if (r) freeReplyObject(r);
3329              if (!success) goto cleanup;
3330          }
3331      }
3332      if (listLength(owners) == 1) owner = listFirst(owners)-&gt;value;
3333      listRewind(cluster_manager.nodes, &amp;li);
3334      while ((ln = listNext(&amp;li)) != NULL) {
3335          clusterManagerNode *n = ln-&gt;value;
3336          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3337          int is_migrating = 0, is_importing = 0;
3338          if (n-&gt;migrating) {
3339              for (int i = 0; i &lt; n-&gt;migrating_count; i += 2) {
3340                  sds migrating_slot = n-&gt;migrating[i];
3341                  if (atoi(migrating_slot) == slot) {
3342                      char *sep = (listLength(migrating) == 0 ? &quot;&quot; : &quot;,&quot;);
3343                      migrating_str = sdscatfmt(migrating_str, &quot;%s%s:%u&quot;,
3344                                                sep, n-&gt;ip, n-&gt;port);
3345                      listAddNodeTail(migrating, n);
3346                      is_migrating = 1;
3347                      break;
3348                  }
3349              }
3350          }
3351          if (!is_migrating &amp;&amp; n-&gt;importing) {
3352              for (int i = 0; i &lt; n-&gt;importing_count; i += 2) {
3353                  sds importing_slot = n-&gt;importing[i];
3354                  if (atoi(importing_slot) == slot) {
3355                      char *sep = (listLength(importing) == 0 ? &quot;&quot; : &quot;,&quot;);
3356                      importing_str = sdscatfmt(importing_str, &quot;%s%s:%u&quot;,
3357                                                sep, n-&gt;ip, n-&gt;port);
3358                      listAddNodeTail(importing, n);
3359                      is_importing = 1;
3360                      break;
3361                  }
3362              }
3363          }
3364          if (!is_migrating &amp;&amp; !is_importing &amp;&amp; n != owner) {
3365              redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3366                  &quot;CLUSTER COUNTKEYSINSLOT %d&quot;, slot);
3367              success = clusterManagerCheckRedisReply(n, r, NULL);
3368              if (success &amp;&amp; r-&gt;integer &gt; 0) {
3369                  clusterManagerLogWarn(&quot;*** Found keys about slot %d &quot;
3370                                        &quot;in node %s:%d!\n&quot;, slot, n-&gt;ip,
3371                                        n-&gt;port);
3372                  char *sep = (listLength(importing) == 0 ? &quot;&quot; : &quot;,&quot;);
3373                  importing_str = sdscatfmt(importing_str, &quot;%s%S:%u&quot;,
3374                                            sep, n-&gt;ip, n-&gt;port);
3375                  listAddNodeTail(importing, n);
3376              }
3377              if (r) freeReplyObject(r);
3378              if (!success) goto cleanup;
3379          }
3380      }
3381      if (sdslen(migrating_str) &gt; 0)
3382          printf(&quot;Set as migrating in: %s\n&quot;, migrating_str);
3383      if (sdslen(importing_str) &gt; 0)
3384          printf(&quot;Set as importing in: %s\n&quot;, importing_str);
3385      if (owner == NULL) {
3386          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Nobody claims ownership, &quot;
3387                                &quot;selecting an owner...\n&quot;);
3388          owner = clusterManagerGetNodeWithMostKeysInSlot(cluster_manager.nodes,
3389                                                          slot, NULL);
3390          if (owner == NULL) {
3391              clusterManagerLogErr(&quot;[ERR] Can&#x27;t select a slot owner. &quot;
3392                                   &quot;Impossible to fix.\n&quot;);
3393              success = 0;
3394              goto cleanup;
3395          }
3396          clusterManagerLogWarn(&quot;*** Configuring %s:%d as the slot owner\n&quot;,
3397                                owner-&gt;ip, owner-&gt;port);
3398          success = clusterManagerClearSlotStatus(owner, slot);
3399          if (!success) goto cleanup;
3400          success = clusterManagerSetSlotOwner(owner, slot, 0);
3401          if (!success) goto cleanup;
3402          owner-&gt;slots[slot] = 1;
3403          success = clusterManagerBumpEpoch(owner);
3404          if (!success) goto cleanup;
3405          clusterManagerRemoveNodeFromList(migrating, owner);
3406          clusterManagerRemoveNodeFromList(importing, owner);
3407      }
3408      if (listLength(owners) &gt; 1) {
3409          assert(owner != NULL);
3410          listRewind(owners, &amp;li);
3411          while ((ln = listNext(&amp;li)) != NULL) {
3412              clusterManagerNode *n = ln-&gt;value;
3413              if (n == owner) continue;
3414              success = clusterManagerDelSlot(n, slot, 1);
3415              if (!success) goto cleanup;
3416              n-&gt;slots[slot] = 0;
3417              success = clusterManagerSetSlot(n, owner, slot, &quot;node&quot;, NULL);
3418              if (!success) goto cleanup;
3419              success = clusterManagerSetSlot(n, owner, slot, &quot;importing&quot;, NULL);
3420              if (!success) goto cleanup;
3421              clusterManagerRemoveNodeFromList(importing, n);
3422              listAddNodeTail(importing, n);
3423              clusterManagerRemoveNodeFromList(migrating, n);
3424          }
3425      }
3426      int move_opts = CLUSTER_MANAGER_OPT_VERBOSE;
3427      if (listLength(migrating) == 1 &amp;&amp; listLength(importing) == 1) {
3428          clusterManagerNode *src = listFirst(migrating)-&gt;value;
3429          clusterManagerNode *dst = listFirst(importing)-&gt;value;
3430          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 1: Moving slot %d from &quot;
3431                                &quot;%s:%d to %s:%d\n&quot;, slot,
3432                                src-&gt;ip, src-&gt;port, dst-&gt;ip, dst-&gt;port);
3433          move_opts |= CLUSTER_MANAGER_OPT_UPDATE;
3434          success = clusterManagerMoveSlot(src, dst, slot, move_opts, NULL);
3435      }
3436      else if (listLength(migrating) == 0 &amp;&amp; listLength(importing) &gt; 0) {
3437          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 2: Moving all the %d slot keys to its &quot;
3438                                &quot;owner %s:%d\n&quot;, slot, owner-&gt;ip, owner-&gt;port);
3439          move_opts |= CLUSTER_MANAGER_OPT_COLD;
3440          listRewind(importing, &amp;li);
3441          while ((ln = listNext(&amp;li)) != NULL) {
3442              clusterManagerNode *n = ln-&gt;value;
3443              if (n == owner) continue;
3444              success = clusterManagerMoveSlot(n, owner, slot, move_opts, NULL);
3445              if (!success) goto cleanup;
3446              clusterManagerLogInfo(&quot;&gt;&gt;&gt; Setting %d as STABLE in &quot;
3447                                    &quot;%s:%d\n&quot;, slot, n-&gt;ip, n-&gt;port);
3448              success = clusterManagerClearSlotStatus(n, slot);
3449              if (!success) goto cleanup;
3450          }
3451          listRewind(cluster_manager.nodes, &amp;li);
3452          while ((ln = listNext(&amp;li)) != NULL) {
3453              clusterManagerNode *n = ln-&gt;value;
3454              if (n == owner) continue;
3455              if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3456              success = clusterManagerSetSlot(n, owner, slot, &quot;NODE&quot;, NULL);
3457              if (!success) goto cleanup;
3458          }
3459      }
3460      else if (listLength(migrating) == 1 &amp;&amp; listLength(importing) &gt; 1) {
3461          int try_to_fix = 1;
3462          clusterManagerNode *src = listFirst(migrating)-&gt;value;
3463          clusterManagerNode *dst = NULL;
3464          sds target_id = NULL;
3465          for (int i = 0; i &lt; src-&gt;migrating_count; i += 2) {
3466              sds migrating_slot = src-&gt;migrating[i];
3467              if (atoi(migrating_slot) == slot) {
3468                  target_id = src-&gt;migrating[i + 1];
3469                  break;
3470              }
3471          }
3472          assert(target_id != NULL);
3473          listIter li;
3474          listNode *ln;
3475          listRewind(importing, &amp;li);
3476          while ((ln = listNext(&amp;li)) != NULL) {
3477              clusterManagerNode *n = ln-&gt;value;
3478              int count = clusterManagerCountKeysInSlot(n, slot);
3479              if (count &gt; 0) {
3480                  try_to_fix = 0;
3481                  break;
3482              }
3483              if (strcmp(n-&gt;name, target_id) == 0) dst = n;
3484          }
3485          if (!try_to_fix) goto unhandled_case;
3486          if (dst != NULL) {
3487              clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 3: Moving slot %d from %s:%d to &quot;
3488                                    &quot;%s:%d and closing it on all the other &quot;
3489                                    &quot;importing nodes.\n&quot;,
3490                                    slot, src-&gt;ip, src-&gt;port,
3491                                    dst-&gt;ip, dst-&gt;port);
3492              success = clusterManagerMoveSlot(src, dst, slot, move_opts, NULL);
3493              if (!success) goto cleanup;
3494              listRewind(importing, &amp;li);
3495              while ((ln = listNext(&amp;li)) != NULL) {
3496                  clusterManagerNode *n = ln-&gt;value;
3497                  if (dst == n) continue;
3498                  success = clusterManagerClearSlotStatus(n, slot);
3499                  if (!success) goto cleanup;
3500              }
3501          } else {
3502              clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 3: Closing slot %d on both &quot;
3503                                    &quot;migrating and importing nodes.\n&quot;, slot);
3504              success = clusterManagerClearSlotStatus(src, slot);
3505              if (!success) goto cleanup;
3506              listRewind(importing, &amp;li);
3507              while ((ln = listNext(&amp;li)) != NULL) {
3508                  clusterManagerNode *n = ln-&gt;value;
3509                  success = clusterManagerClearSlotStatus(n, slot);
3510                  if (!success) goto cleanup;
3511              }
3512          }
3513      } else {
3514          int try_to_close_slot = (listLength(importing) == 0 &amp;&amp;
3515                                   listLength(migrating) == 1);
3516          if (try_to_close_slot) {
3517              clusterManagerNode *n = listFirst(migrating)-&gt;value;
3518              if (!owner || owner != n) {
3519                  redisReply *r = CLUSTER_MANAGER_COMMAND(n,
3520                      &quot;CLUSTER GETKEYSINSLOT %d %d&quot;, slot, 10);
3521                  success = clusterManagerCheckRedisReply(n, r, NULL);
3522                  if (r) {
3523                      if (success) try_to_close_slot = (r-&gt;elements == 0);
3524                      freeReplyObject(r);
3525                  }
3526                  if (!success) goto cleanup;
3527              }
3528          }
3529          if (try_to_close_slot) {
3530              clusterManagerNode *n = listFirst(migrating)-&gt;value;
3531              clusterManagerLogInfo(&quot;&gt;&gt;&gt; Case 4: Closing slot %d on %s:%d\n&quot;,
3532                                    slot, n-&gt;ip, n-&gt;port);
3533              redisReply *r = CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER SETSLOT %d %s&quot;,
3534                                                      slot, &quot;STABLE&quot;);
3535              success = clusterManagerCheckRedisReply(n, r, NULL);
3536              if (r) freeReplyObject(r);
3537              if (!success) goto cleanup;
3538          } else {
3539  unhandled_case:
3540              success = 0;
3541              clusterManagerLogErr(&quot;[ERR] Sorry, redis-cli can&#x27;t fix this slot &quot;
3542                                   &quot;yet (work in progress). Slot is set as &quot;
3543                                   &quot;migrating in %s, as importing in %s, &quot;
3544                                   &quot;owner is %s:%d\n&quot;, migrating_str,
3545                                   importing_str, owner-&gt;ip, owner-&gt;port);
3546          }
3547      }
3548  cleanup:
3549      listRelease(owners);
3550      listRelease(migrating);
3551      listRelease(importing);
3552      sdsfree(migrating_str);
3553      sdsfree(importing_str);
3554      return success;
3555  }
3556  static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
3557      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Fixing multiple owners for slot %d...\n&quot;, slot);
3558      int success = 0;
3559      assert(listLength(owners) &gt; 1);
3560      clusterManagerNode *owner = clusterManagerGetNodeWithMostKeysInSlot(owners,
3561                                                                          slot,
3562                                                                          NULL);
3563      if (!owner) owner = listFirst(owners)-&gt;value;
3564      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Setting slot %d owner: %s:%d\n&quot;,
3565                            slot, owner-&gt;ip, owner-&gt;port);
3566      if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
3567      listIter li;
3568      listNode *ln;
3569      listRewind(cluster_manager.nodes, &amp;li);
3570      while ((ln = listNext(&amp;li)) != NULL) {
3571          clusterManagerNode *n = ln-&gt;value;
3572          if (n == owner) continue;
3573          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3574          int count = clusterManagerCountKeysInSlot(n, slot);
3575          success = (count &gt;= 0);
3576          if (!success) break;
3577          clusterManagerDelSlot(n, slot, 1);
3578          if (!clusterManagerSetSlot(n, owner, slot, &quot;node&quot;, NULL)) return 0;
3579          if (count &gt; 0) {
3580              int opts = CLUSTER_MANAGER_OPT_VERBOSE |
3581                         CLUSTER_MANAGER_OPT_COLD;
3582              success = clusterManagerMoveSlot(n, owner, slot, opts, NULL);
3583              if (!success) break;
3584          }
3585      }
3586      return success;
3587  }
3588  static int clusterManagerCheckCluster(int quiet) {
3589      listNode *ln = listFirst(cluster_manager.nodes);
3590      if (!ln) return 0;
3591      clusterManagerNode *node = ln-&gt;value;
3592      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Performing Cluster Check (using node %s:%d)\n&quot;,
3593                            node-&gt;ip, node-&gt;port);
3594      int result = 1, consistent = 0;
3595      int do_fix = config.cluster_manager_command.flags &amp;
3596                   CLUSTER_MANAGER_CMD_FLAG_FIX;
3597      if (!quiet) clusterManagerShowNodes();
3598      consistent = clusterManagerIsConfigConsistent();
3599      if (!consistent) {
3600          sds err = sdsnew(&quot;[ERR] Nodes don&#x27;t agree about configuration!&quot;);
3601          clusterManagerOnError(err);
3602          result = 0;
3603      } else {
3604          clusterManagerLogOk(&quot;[OK] All nodes agree about slots &quot;
3605                              &quot;configuration.\n&quot;);
3606      }
3607      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Check for open slots...\n&quot;);
3608      listIter li;
3609      listRewind(cluster_manager.nodes, &amp;li);
3610      int i;
3611      dict *open_slots = NULL;
3612      while ((ln = listNext(&amp;li)) != NULL) {
3613          clusterManagerNode *n = ln-&gt;value;
3614          if (n-&gt;migrating != NULL) {
3615              if (open_slots == NULL)
3616                  open_slots = dictCreate(&amp;clusterManagerDictType, NULL);
3617              sds errstr = sdsempty();
3618              errstr = sdscatprintf(errstr,
3619                                  &quot;[WARNING] Node %s:%d has slots in &quot;
3620                                  &quot;migrating state &quot;,
3621                                  n-&gt;ip,
3622                                  n-&gt;port);
3623              for (i = 0; i &lt; n-&gt;migrating_count; i += 2) {
3624                  sds slot = n-&gt;migrating[i];
3625                  dictAdd(open_slots, slot, sdsdup(n-&gt;migrating[i + 1]));
3626                  char *fmt = (i &gt; 0 ? &quot;,%S&quot; : &quot;%S&quot;);
3627                  errstr = sdscatfmt(errstr, fmt, slot);
3628              }
3629              errstr = sdscat(errstr, &quot;.&quot;);
3630              clusterManagerOnError(errstr);
3631          }
3632          if (n-&gt;importing != NULL) {
3633              if (open_slots == NULL)
3634                  open_slots = dictCreate(&amp;clusterManagerDictType, NULL);
3635              sds errstr = sdsempty();
3636              errstr = sdscatprintf(errstr,
3637                                  &quot;[WARNING] Node %s:%d has slots in &quot;
3638                                  &quot;importing state &quot;,
3639                                  n-&gt;ip,
3640                                  n-&gt;port);
3641              for (i = 0; i &lt; n-&gt;importing_count; i += 2) {
3642                  sds slot = n-&gt;importing[i];
3643                  dictAdd(open_slots, slot, sdsdup(n-&gt;importing[i + 1]));
3644                  char *fmt = (i &gt; 0 ? &quot;,%S&quot; : &quot;%S&quot;);
3645                  errstr = sdscatfmt(errstr, fmt, slot);
3646              }
3647              errstr = sdscat(errstr, &quot;.&quot;);
3648              clusterManagerOnError(errstr);
3649          }
3650      }
3651      if (open_slots != NULL) {
3652          result = 0;
3653          dictIterator *iter = dictGetIterator(open_slots);
3654          dictEntry *entry;
3655          sds errstr = sdsnew(&quot;[WARNING] The following slots are open: &quot;);
3656          i = 0;
3657          while ((entry = dictNext(iter)) != NULL) {
3658              sds slot = (sds) dictGetKey(entry);
3659              char *fmt = (i++ &gt; 0 ? &quot;,%S&quot; : &quot;%S&quot;);
3660              errstr = sdscatfmt(errstr, fmt, slot);
3661          }
3662          clusterManagerLogErr(&quot;%s.\n&quot;, (char *) errstr);
3663          sdsfree(errstr);
3664          if (do_fix) {
3665              dictReleaseIterator(iter);
3666              iter = dictGetIterator(open_slots);
3667              while ((entry = dictNext(iter)) != NULL) {
3668                  sds slot = (sds) dictGetKey(entry);
3669                  result = clusterManagerFixOpenSlot(atoi(slot));
3670                  if (!result) break;
3671              }
3672          }
3673          dictReleaseIterator(iter);
3674          dictRelease(open_slots);
3675      }
3676      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Check slots coverage...\n&quot;);
3677      char slots[CLUSTER_MANAGER_SLOTS];
3678      memset(slots, 0, CLUSTER_MANAGER_SLOTS);
3679      int coverage = clusterManagerGetCoveredSlots(slots);
3680      if (coverage == CLUSTER_MANAGER_SLOTS) {
3681          clusterManagerLogOk(&quot;[OK] All %d slots covered.\n&quot;,
3682                              CLUSTER_MANAGER_SLOTS);
3683      } else {
3684          sds err = sdsempty();
3685          err = sdscatprintf(err, &quot;[ERR] Not all %d slots are &quot;
3686                                  &quot;covered by nodes.\n&quot;,
3687                                  CLUSTER_MANAGER_SLOTS);
3688          clusterManagerOnError(err);
3689          result = 0;
3690          if (do_fix&amp;bsol;* &amp;&amp; result*/) {
3691              dictType dtype = clusterManagerDictType;
3692              dtype.keyDestructor = dictSdsDestructor;
3693              dtype.valDestructor = dictListDestructor;
3694              clusterManagerUncoveredSlots = dictCreate(&amp;dtype, NULL);
3695              int fixed = clusterManagerFixSlotsCoverage(slots);
3696              if (fixed &gt; 0) result = 1;
3697          }
3698      }
3699      int search_multiple_owners = config.cluster_manager_command.flags &amp;
3700                                   CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS;
3701      if (search_multiple_owners) {
3702          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Check for multiple slot owners...\n&quot;);
3703          int slot = 0;
3704          for (; slot &lt; CLUSTER_MANAGER_SLOTS; slot++) {
3705              listIter li;
3706              listNode *ln;
3707              listRewind(cluster_manager.nodes, &amp;li);
3708              list *owners = listCreate();
3709              while ((ln = listNext(&amp;li)) != NULL) {
3710                  clusterManagerNode *n = ln-&gt;value;
3711                  if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
3712                  if (n-&gt;slots[slot]) listAddNodeTail(owners, n);
3713                  else {
3714                      int count = clusterManagerCountKeysInSlot(n, slot);
3715                      if (count &gt; 0) listAddNodeTail(owners, n);
3716                  }
3717              }
3718              if (listLength(owners) &gt; 1) {
3719                  result = 0;
3720                  clusterManagerLogErr(&quot;[WARNING] Slot %d has %d owners:\n&quot;,
3721                                       slot, listLength(owners));
3722                  listRewind(owners, &amp;li);
3723                  while ((ln = listNext(&amp;li)) != NULL) {
3724                      clusterManagerNode *n = ln-&gt;value;
3725                      clusterManagerLogErr(&quot;    %s:%d\n&quot;, n-&gt;ip, n-&gt;port);
3726                  }
3727                  if (do_fix) {
3728                      result = clusterManagerFixMultipleSlotOwners(slot, owners);
3729                      if (!result) {
3730                          clusterManagerLogErr(&quot;Failed to fix multiple owners &quot;
3731                                               &quot;for slot %d\n&quot;, slot);
3732                          listRelease(owners);
3733                          break;
3734                      }
3735                  }
3736              }
3737              listRelease(owners);
3738          }
3739      }
3740      return result;
3741  }
3742  static clusterManagerNode *clusterNodeForResharding(char *id,
3743                                                      clusterManagerNode *target,
3744                                                      int *raise_err)
3745  {
3746      clusterManagerNode *node = NULL;
3747      const char *invalid_node_msg = &quot;*** The specified node (%s) is not known &quot;
3748                                     &quot;or not a master, please retry.\n&quot;;
3749      node = clusterManagerNodeByName(id);
3750      *raise_err = 0;
3751      if (!node || node-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) {
3752          clusterManagerLogErr(invalid_node_msg, id);
3753          *raise_err = 1;
3754          return NULL;
3755      } else if (node != NULL &amp;&amp; target != NULL) {
3756          if (!strcmp(node-&gt;name, target-&gt;name)) {
3757              clusterManagerLogErr( &quot;*** It is not possible to use &quot;
3758                                    &quot;the target node as &quot;
3759                                    &quot;source node.\n&quot;);
3760              return NULL;
3761          }
3762      }
3763      return node;
3764  }
3765  static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
3766      list *moved = listCreate();
3767      int src_count = listLength(sources), i = 0, tot_slots = 0, j;
3768      clusterManagerNode **sorted = zmalloc(src_count * sizeof(*sorted));
3769      listIter li;
3770      listNode *ln;
3771      listRewind(sources, &amp;li);
3772      while ((ln = listNext(&amp;li)) != NULL) {
3773          clusterManagerNode *node = ln-&gt;value;
3774          tot_slots += node-&gt;slots_count;
3775          sorted[i++] = node;
3776      }
3777      qsort(sorted, src_count, sizeof(clusterManagerNode *),
3778            clusterManagerSlotCountCompareDesc);
3779      for (i = 0; i &lt; src_count; i++) {
3780          clusterManagerNode *node = sorted[i];
3781          float n = ((float) numslots / tot_slots * node-&gt;slots_count);
3782          if (i == 0) n = ceil(n);
3783          else n = floor(n);
3784          int max = (int) n, count = 0;
3785          for (j = 0; j &lt; CLUSTER_MANAGER_SLOTS; j++) {
3786              int slot = node-&gt;slots[j];
3787              if (!slot) continue;
3788              if (count &gt;= max || (int)listLength(moved) &gt;= numslots) break;
3789              clusterManagerReshardTableItem *item = zmalloc(sizeof(*item));
3790              item-&gt;source = node;
3791              item-&gt;slot = j;
3792              listAddNodeTail(moved, item);
3793              count++;
3794          }
3795      }
3796      zfree(sorted);
3797      return moved;
3798  }
3799  static void clusterManagerShowReshardTable(list *table) {
3800      listIter li;
3801      listNode *ln;
3802      listRewind(table, &amp;li);
3803      while ((ln = listNext(&amp;li)) != NULL) {
3804          clusterManagerReshardTableItem *item = ln-&gt;value;
3805          clusterManagerNode *n = item-&gt;source;
3806          printf(&quot;    Moving slot %d from %s\n&quot;, item-&gt;slot, (char *) n-&gt;name);
3807      }
3808  }
3809  static void clusterManagerReleaseReshardTable(list *table) {
3810      if (table != NULL) {
3811          listIter li;
3812          listNode *ln;
3813          listRewind(table, &amp;li);
3814          while ((ln = listNext(&amp;li)) != NULL) {
3815              clusterManagerReshardTableItem *item = ln-&gt;value;
3816              zfree(item);
3817          }
3818          listRelease(table);
3819      }
3820  }
3821  static void clusterManagerLog(int level, const char* fmt, ...) {
3822      int use_colors =
3823          (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_COLOR);
3824      if (use_colors) {
3825          printf(&quot;\033[&quot;);
3826          switch (level) {
3827          case CLUSTER_MANAGER_LOG_LVL_INFO: printf(LOG_COLOR_BOLD); break;
3828          case CLUSTER_MANAGER_LOG_LVL_WARN: printf(LOG_COLOR_YELLOW); break;
3829          case CLUSTER_MANAGER_LOG_LVL_ERR: printf(LOG_COLOR_RED); break;
3830          case CLUSTER_MANAGER_LOG_LVL_SUCCESS: printf(LOG_COLOR_GREEN); break;
3831          default: printf(LOG_COLOR_RESET); break;
3832          }
3833      }
3834      va_list ap;
3835      va_start(ap, fmt);
3836      vprintf(fmt, ap);
3837      va_end(ap);
3838      if (use_colors) printf(&quot;\033[&quot; LOG_COLOR_RESET);
3839  }
3840  static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
3841                                          int alloc_len)
3842  {
3843      array-&gt;nodes = zcalloc(alloc_len * sizeof(clusterManagerNode*));
3844      array-&gt;alloc = array-&gt;nodes;
3845      array-&gt;len = alloc_len;
3846      array-&gt;count = 0;
3847  }
3848  static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
3849      if (array-&gt;nodes &gt; array-&gt;alloc) {
3850          array-&gt;len = array-&gt;nodes - array-&gt;alloc;
3851          array-&gt;nodes = array-&gt;alloc;
3852          array-&gt;count = 0;
3853          int i = 0;
3854          for(; i &lt; array-&gt;len; i++) {
3855              if (array-&gt;nodes[i] != NULL) array-&gt;count++;
3856          }
3857      }
3858  }
3859  static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
3860                                           clusterManagerNode **nodeptr)
3861  {
3862      assert(array-&gt;nodes &lt; (array-&gt;nodes + array-&gt;len));
3863      if (*array-&gt;nodes != NULL) array-&gt;count--;
3864      *nodeptr = *array-&gt;nodes;
3865      array-&gt;nodes++;
3866      array-&gt;len--;
3867  }
3868  static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
3869                                         clusterManagerNode *node)
3870  {
3871      assert(array-&gt;nodes &lt; (array-&gt;nodes + array-&gt;len));
3872      assert(node != NULL);
3873      assert(array-&gt;count &lt; array-&gt;len);
3874      array-&gt;nodes[array-&gt;count++] = node;
3875  }
3876  static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
3877                                                   char *err)
3878  {
3879      char *msg;
3880      if (err) msg = err;
3881      else {
3882          msg = &quot;is not empty. Either the node already knows other &quot;
3883                &quot;nodes (check with CLUSTER NODES) or contains some &quot;
3884                &quot;key in database 0.&quot;;
3885      }
3886      clusterManagerLogErr(&quot;[ERR] Node %s:%d %s\n&quot;, node-&gt;ip, node-&gt;port, msg);
3887  }
3888  static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
3889                                                     char *err)
3890  {
3891      char *msg = (err ? err : &quot;is not configured as a cluster node.&quot;);
3892      clusterManagerLogErr(&quot;[ERR] Node %s:%d %s\n&quot;, node-&gt;ip, node-&gt;port, msg);
3893  }
3894  static void clusterManagerMode(clusterManagerCommandProc *proc) {
3895      int argc = config.cluster_manager_command.argc;
3896      char **argv = config.cluster_manager_command.argv;
3897      cluster_manager.nodes = NULL;
3898      if (!proc(argc, argv)) goto cluster_manager_err;
3899      freeClusterManager();
3900      exit(0);
3901  cluster_manager_err:
3902      freeClusterManager();
3903      sdsfree(config.hostip);
3904      sdsfree(config.mb_delim);
3905      exit(1);
3906  }
3907  static int clusterManagerCommandCreate(int argc, char **argv) {
3908      int i, j, success = 1;
3909      cluster_manager.nodes = listCreate();
3910      for (i = 0; i &lt; argc; i++) {
3911          char *addr = argv[i];
3912          char *c = strrchr(addr, &#x27;@&#x27;);
3913          if (c != NULL) *c = &#x27;\0&#x27;;
3914          c = strrchr(addr, &#x27;:&#x27;);
3915          if (c == NULL) {
3916              fprintf(stderr, &quot;Invalid address format: %s\n&quot;, addr);
3917              return 0;
3918          }
3919          *c = &#x27;\0&#x27;;
3920          char *ip = addr;
3921          int port = atoi(++c);
3922          clusterManagerNode *node = clusterManagerNewNode(ip, port);
3923          if (!clusterManagerNodeConnect(node)) {
3924              freeClusterManagerNode(node);
3925              return 0;
3926          }
3927          char *err = NULL;
3928          if (!clusterManagerNodeIsCluster(node, &amp;err)) {
3929              clusterManagerPrintNotClusterNodeError(node, err);
3930              if (err) zfree(err);
3931              freeClusterManagerNode(node);
3932              return 0;
3933          }
3934          err = NULL;
3935          if (!clusterManagerNodeLoadInfo(node, 0, &amp;err)) {
3936              if (err) {
3937                  CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
3938                  zfree(err);
3939              }
3940              freeClusterManagerNode(node);
3941              return 0;
3942          }
3943          err = NULL;
3944          if (!clusterManagerNodeIsEmpty(node, &amp;err)) {
3945              clusterManagerPrintNotEmptyNodeError(node, err);
3946              if (err) zfree(err);
3947              freeClusterManagerNode(node);
3948              return 0;
3949          }
3950          listAddNodeTail(cluster_manager.nodes, node);
3951      }
3952      int node_len = cluster_manager.nodes-&gt;len;
3953      int replicas = config.cluster_manager_command.replicas;
3954      int masters_count = CLUSTER_MANAGER_MASTERS_COUNT(node_len, replicas);
3955      if (masters_count &lt; 3) {
3956          clusterManagerLogErr(
3957              &quot;*** ERROR: Invalid configuration for cluster creation.\n&quot;
3958              &quot;*** Redis Cluster requires at least 3 master nodes.\n&quot;
3959              &quot;*** This is not possible with %d nodes and %d replicas per node.&quot;,
3960              node_len, replicas);
3961          clusterManagerLogErr(&quot;\n*** At least %d nodes are required.\n&quot;,
3962                               3 * (replicas + 1));
3963          return 0;
3964      }
3965      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Performing hash slots allocation &quot;
3966                            &quot;on %d nodes...\n&quot;, node_len);
3967      int interleaved_len = 0, ip_count = 0;
3968      clusterManagerNode **interleaved = zcalloc(node_len*sizeof(**interleaved));
3969      char **ips = zcalloc(node_len * sizeof(char*));
3970      clusterManagerNodeArray *ip_nodes = zcalloc(node_len * sizeof(*ip_nodes));
3971      listIter li;
3972      listNode *ln;
3973      listRewind(cluster_manager.nodes, &amp;li);
3974      while ((ln = listNext(&amp;li)) != NULL) {
3975          clusterManagerNode *n = ln-&gt;value;
3976          int found = 0;
3977          for (i = 0; i &lt; ip_count; i++) {
3978              char *ip = ips[i];
3979              if (!strcmp(ip, n-&gt;ip)) {
3980                  found = 1;
3981                  break;
3982              }
3983          }
3984          if (!found) {
3985              ips[ip_count++] = n-&gt;ip;
3986          }
3987          clusterManagerNodeArray *node_array = &amp;(ip_nodes[i]);
3988          if (node_array-&gt;nodes == NULL)
3989              clusterManagerNodeArrayInit(node_array, node_len);
3990          clusterManagerNodeArrayAdd(node_array, n);
3991      }
3992      while (interleaved_len &lt; node_len) {
3993          for (i = 0; i &lt; ip_count; i++) {
3994              clusterManagerNodeArray *node_array = &amp;(ip_nodes[i]);
3995              if (node_array-&gt;count &gt; 0) {
3996                  clusterManagerNode *n = NULL;
3997                  clusterManagerNodeArrayShift(node_array, &amp;n);
3998                  interleaved[interleaved_len++] = n;
3999              }
4000          }
4001      }
4002      clusterManagerNode **masters = interleaved;
4003      interleaved += masters_count;
4004      interleaved_len -= masters_count;
4005      float slots_per_node = CLUSTER_MANAGER_SLOTS / (float) masters_count;
4006      PORT_LONG first = 0;
4007      float cursor = 0.0f;
4008      for (i = 0; i &lt; masters_count; i++) {
4009          clusterManagerNode *master = masters[i];
4010          PORT_LONG last = lround(cursor + slots_per_node - 1);
4011          if (last &gt; CLUSTER_MANAGER_SLOTS || i == (masters_count - 1))
4012              last = CLUSTER_MANAGER_SLOTS - 1;
4013          if (last &lt; first) last = first;
4014          printf(&quot;Master[%d] -&gt; Slots %lu - %lu\n&quot;, i, first, last);
4015          master-&gt;slots_count = 0;
4016          for (j = first; j &lt;= last; j++) {
4017              master-&gt;slots[j] = 1;
4018              master-&gt;slots_count++;
4019          }
4020          master-&gt;dirty = 1;
4021          first = last + 1;
4022          cursor += slots_per_node;
4023      }
4024      clusterManagerNode *first_node = interleaved[0];
4025      for (i = 0; i &lt; (interleaved_len - 1); i++)
4026          interleaved[i] = interleaved[i + 1];
4027      interleaved[interleaved_len - 1] = first_node;
4028      int assign_unused = 0, available_count = interleaved_len;
4029  assign_replicas:
4030      for (i = 0; i &lt; masters_count; i++) {
4031          clusterManagerNode *master = masters[i];
4032          int assigned_replicas = 0;
4033          while (assigned_replicas &lt; replicas) {
4034              if (available_count == 0) break;
4035              clusterManagerNode *found = NULL, *slave = NULL;
4036              int firstNodeIdx = -1;
4037              for (j = 0; j &lt; interleaved_len; j++) {
4038                  clusterManagerNode *n = interleaved[j];
4039                  if (n == NULL) continue;
4040                  if (strcmp(n-&gt;ip, master-&gt;ip)) {
4041                      found = n;
4042                      interleaved[j] = NULL;
4043                      break;
4044                  }
4045                  if (firstNodeIdx &lt; 0) firstNodeIdx = j;
4046              }
4047              if (found) slave = found;
4048              else if (firstNodeIdx &gt;= 0) {
4049                  slave = interleaved[firstNodeIdx];
4050                  interleaved_len -= (interleaved - (interleaved + firstNodeIdx));
4051                  interleaved += (firstNodeIdx + 1);
4052              }
4053              if (slave != NULL) {
4054                  assigned_replicas++;
4055                  available_count--;
4056                  if (slave-&gt;replicate) sdsfree(slave-&gt;replicate);
4057                  slave-&gt;replicate = sdsnew(master-&gt;name);
4058                  slave-&gt;dirty = 1;
4059              } else break;
4060              printf(&quot;Adding replica %s:%d to %s:%d\n&quot;, slave-&gt;ip, slave-&gt;port,
4061                     master-&gt;ip, master-&gt;port);
4062              if (assign_unused) break;
4063          }
4064      }
4065      if (!assign_unused &amp;&amp; available_count &gt; 0) {
4066          assign_unused = 1;
4067          printf(&quot;Adding extra replicas...\n&quot;);
4068          goto assign_replicas;
4069      }
4070      for (i = 0; i &lt; ip_count; i++) {
4071          clusterManagerNodeArray *node_array = ip_nodes + i;
4072          clusterManagerNodeArrayReset(node_array);
4073      }
4074      clusterManagerOptimizeAntiAffinity(ip_nodes, ip_count);
4075      clusterManagerShowNodes();
4076      if (confirmWithYes(&quot;Can I set the above configuration?&quot;)) {
4077          listRewind(cluster_manager.nodes, &amp;li);
4078          while ((ln = listNext(&amp;li)) != NULL) {
4079              clusterManagerNode *node = ln-&gt;value;
4080              char *err = NULL;
4081              int flushed = clusterManagerFlushNodeConfig(node, &amp;err);
4082              if (!flushed &amp;&amp; node-&gt;dirty &amp;&amp; !node-&gt;replicate) {
4083                  if (err != NULL) {
4084                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
4085                      zfree(err);
4086                  }
4087                  success = 0;
4088                  goto cleanup;
4089              } else if (err != NULL) zfree(err);
4090          }
4091          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Nodes configuration updated\n&quot;);
4092          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Assign a different config epoch to &quot;
4093                                &quot;each node\n&quot;);
4094          int config_epoch = 1;
4095          listRewind(cluster_manager.nodes, &amp;li);
4096          while ((ln = listNext(&amp;li)) != NULL) {
4097              clusterManagerNode *node = ln-&gt;value;
4098              redisReply *reply = NULL;
4099              reply = CLUSTER_MANAGER_COMMAND(node,
4100                                              &quot;cluster set-config-epoch %d&quot;,
4101                                              config_epoch++);
4102              if (reply != NULL) freeReplyObject(reply);
4103          }
4104          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Sending CLUSTER MEET messages to join &quot;
4105                                &quot;the cluster\n&quot;);
4106          clusterManagerNode *first = NULL;
4107          listRewind(cluster_manager.nodes, &amp;li);
4108          while ((ln = listNext(&amp;li)) != NULL) {
4109              clusterManagerNode *node = ln-&gt;value;
4110              if (first == NULL) {
4111                  first = node;
4112                  continue;
4113              }
4114              redisReply *reply = NULL;
4115              reply = CLUSTER_MANAGER_COMMAND(node, &quot;cluster meet %s %d&quot;,
4116                                              first-&gt;ip, first-&gt;port);
4117              int is_err = 0;
4118              if (reply != NULL) {
4119                  if ((is_err = reply-&gt;type == REDIS_REPLY_ERROR))
4120                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, reply-&gt;str);
4121                  freeReplyObject(reply);
4122              } else {
4123                  is_err = 1;
4124                  fprintf(stderr, &quot;Failed to send CLUSTER MEET command.\n&quot;);
4125              }
4126              if (is_err) {
4127                  success = 0;
4128                  goto cleanup;
4129              }
4130          }
4131          sleep(1);
4132          clusterManagerWaitForClusterJoin();
4133          listRewind(cluster_manager.nodes, &amp;li);
4134          while ((ln = listNext(&amp;li)) != NULL) {
4135              clusterManagerNode *node = ln-&gt;value;
4136              if (!node-&gt;dirty) continue;
4137              char *err = NULL;
4138              int flushed = clusterManagerFlushNodeConfig(node, &amp;err);
4139              if (!flushed &amp;&amp; !node-&gt;replicate) {
4140                  if (err != NULL) {
4141                      CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
4142                      zfree(err);
4143                  }
4144                  success = 0;
4145                  goto cleanup;
4146              }
4147          }
4148          listRewind(cluster_manager.nodes, &amp;li);
4149          clusterManagerNode *first_node = NULL;
4150          while ((ln = listNext(&amp;li)) != NULL) {
4151              clusterManagerNode *node = ln-&gt;value;
4152              if (!first_node) first_node = node;
4153              else freeClusterManagerNode(node);
4154          }
4155          listEmpty(cluster_manager.nodes);
4156          if (!clusterManagerLoadInfoFromNode(first_node, 0)) {
4157              success = 0;
4158              goto cleanup;
4159          }
4160          clusterManagerCheckCluster(0);
4161      }
4162  cleanup:
4163      zfree(masters);
4164      zfree(ips);
4165      for (i = 0; i &lt; node_len; i++) {
4166          clusterManagerNodeArray *node_array = ip_nodes + i;
4167          CLUSTER_MANAGER_NODE_ARRAY_FREE(node_array);
4168      }
4169      zfree(ip_nodes);
4170      return success;
4171  }
4172  static int clusterManagerCommandAddNode(int argc, char **argv) {
4173      int success = 1;
4174      redisReply *reply = NULL;
4175      char *ref_ip = NULL, *ip = NULL;
4176      int ref_port = 0, port = 0;
4177      if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &amp;ref_ip, &amp;ref_port))
4178          goto invalid_args;
4179      if (!getClusterHostFromCmdArgs(1, argv, &amp;ip, &amp;port))
4180          goto invalid_args;
4181      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Adding node %s:%d to cluster %s:%d\n&quot;, ip, port,
4182                            ref_ip, ref_port);
4183      clusterManagerNode *refnode = clusterManagerNewNode(ref_ip, ref_port);
4184      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4185      if (!clusterManagerCheckCluster(0)) return 0;
4186      clusterManagerNode *master_node = NULL;
4187      if (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_SLAVE) {
4188          char *master_id = config.cluster_manager_command.master_id;
4189          if (master_id != NULL) {
4190              master_node = clusterManagerNodeByName(master_id);
4191              if (master_node == NULL) {
4192                  clusterManagerLogErr(&quot;[ERR] No such master ID %s\n&quot;, master_id);
4193                  return 0;
4194              }
4195          } else {
4196              master_node = clusterManagerNodeWithLeastReplicas();
4197              assert(master_node != NULL);
4198              printf(&quot;Automatically selected master %s:%d\n&quot;, master_node-&gt;ip,
4199                     master_node-&gt;port);
4200          }
4201      }
4202      clusterManagerNode *new_node = clusterManagerNewNode(ip, port);
4203      int added = 0;
4204      if (!clusterManagerNodeConnect(new_node)) {
4205          clusterManagerLogErr(&quot;[ERR] Sorry, can&#x27;t connect to node %s:%d\n&quot;,
4206                               ip, port);
4207          success = 0;
4208          goto cleanup;
4209      }
4210      char *err = NULL;
4211      if (!(success = clusterManagerNodeIsCluster(new_node, &amp;err))) {
4212          clusterManagerPrintNotClusterNodeError(new_node, err);
4213          if (err) zfree(err);
4214          goto cleanup;
4215      }
4216      if (!clusterManagerNodeLoadInfo(new_node, 0, &amp;err)) {
4217          if (err) {
4218              CLUSTER_MANAGER_PRINT_REPLY_ERROR(new_node, err);
4219              zfree(err);
4220          }
4221          success = 0;
4222          goto cleanup;
4223      }
4224      if (!(success = clusterManagerNodeIsEmpty(new_node, &amp;err))) {
4225          clusterManagerPrintNotEmptyNodeError(new_node, err);
4226          if (err) zfree(err);
4227          goto cleanup;
4228      }
4229      clusterManagerNode *first = listFirst(cluster_manager.nodes)-&gt;value;
4230      listAddNodeTail(cluster_manager.nodes, new_node);
4231      added = 1;
4232      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Send CLUSTER MEET to node %s:%d to make it &quot;
4233                            &quot;join the cluster.\n&quot;, ip, port);
4234      reply = CLUSTER_MANAGER_COMMAND(new_node, &quot;CLUSTER MEET %s %d&quot;,
4235                                      first-&gt;ip, first-&gt;port);
4236      if (!(success = clusterManagerCheckRedisReply(new_node, reply, NULL)))
4237          goto cleanup;
4238      if (master_node) {
4239          sleep(1);
4240          clusterManagerWaitForClusterJoin();
4241          clusterManagerLogInfo(&quot;&gt;&gt;&gt; Configure node as replica of %s:%d.\n&quot;,
4242                                master_node-&gt;ip, master_node-&gt;port);
4243          freeReplyObject(reply);
4244          reply = CLUSTER_MANAGER_COMMAND(new_node, &quot;CLUSTER REPLICATE %s&quot;,
4245                                          master_node-&gt;name);
4246          if (!(success = clusterManagerCheckRedisReply(new_node, reply, NULL)))
4247              goto cleanup;
4248      }
4249      clusterManagerLogOk(&quot;[OK] New node added correctly.\n&quot;);
4250  cleanup:
4251      if (!added &amp;&amp; new_node) freeClusterManagerNode(new_node);
4252      if (reply) freeReplyObject(reply);
4253      return success;
4254  invalid_args:
4255      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4256      return 0;
4257  }
4258  static int clusterManagerCommandDeleteNode(int argc, char **argv) {
4259      UNUSED(argc);
4260      int success = 1;
4261      int port = 0;
4262      char *ip = NULL;
4263      if (!getClusterHostFromCmdArgs(1, argv, &amp;ip, &amp;port)) goto invalid_args;
4264      char *node_id = argv[1];
4265      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Removing node %s from cluster %s:%d\n&quot;,
4266                            node_id, ip, port);
4267      clusterManagerNode *ref_node = clusterManagerNewNode(ip, port);
4268      clusterManagerNode *node = NULL;
4269      if (!clusterManagerLoadInfoFromNode(ref_node, 0)) return 0;
4270      node = clusterManagerNodeByName(node_id);
4271      if (node == NULL) {
4272          clusterManagerLogErr(&quot;[ERR] No such node ID %s\n&quot;, node_id);
4273          return 0;
4274      }
4275      if (node-&gt;slots_count != 0) {
4276          clusterManagerLogErr(&quot;[ERR] Node %s:%d is not empty! Reshard data &quot;
4277                               &quot;away and try again.\n&quot;, node-&gt;ip, node-&gt;port);
4278          return 0;
4279      }
4280      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Sending CLUSTER FORGET messages to the &quot;
4281                            &quot;cluster...\n&quot;);
4282      listIter li;
4283      listNode *ln;
4284      listRewind(cluster_manager.nodes, &amp;li);
4285      while ((ln = listNext(&amp;li)) != NULL) {
4286          clusterManagerNode *n = ln-&gt;value;
4287          if (n == node) continue;
4288          if (n-&gt;replicate &amp;&amp; !strcasecmp(n-&gt;replicate, node_id)) {
4289              clusterManagerNode *master = clusterManagerNodeWithLeastReplicas();
4290              assert(master != NULL);
4291              clusterManagerLogInfo(&quot;&gt;&gt;&gt; %s:%d as replica of %s:%d\n&quot;,
4292                                    n-&gt;ip, n-&gt;port, master-&gt;ip, master-&gt;port);
4293              redisReply *r = CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER REPLICATE %s&quot;,
4294                                                      master-&gt;name);
4295              success = clusterManagerCheckRedisReply(n, r, NULL);
4296              if (r) freeReplyObject(r);
4297              if (!success) return 0;
4298          }
4299          redisReply *r = CLUSTER_MANAGER_COMMAND(n, &quot;CLUSTER FORGET %s&quot;,
4300                                                  node_id);
4301          success = clusterManagerCheckRedisReply(n, r, NULL);
4302          if (r) freeReplyObject(r);
4303          if (!success) return 0;
4304      }
4305      clusterManagerLogInfo(&quot;&gt;&gt;&gt; SHUTDOWN the node.\n&quot;);
4306      redisReply *r = redisCommand(node-&gt;context, &quot;SHUTDOWN&quot;);
4307      success = clusterManagerCheckRedisReply(node, r, NULL);
4308      if (r) freeReplyObject(r);
4309      return success;
4310  invalid_args:
4311      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4312      return 0;
4313  }
4314  static int clusterManagerCommandInfo(int argc, char **argv) {
4315      int port = 0;
4316      char *ip = NULL;
4317      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) goto invalid_args;
4318      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4319      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4320      clusterManagerShowClusterInfo();
4321      return 1;
4322  invalid_args:
4323      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4324      return 0;
4325  }
4326  static int clusterManagerCommandCheck(int argc, char **argv) {
4327      int port = 0;
4328      char *ip = NULL;
4329      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) goto invalid_args;
4330      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4331      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4332      clusterManagerShowClusterInfo();
4333      return clusterManagerCheckCluster(0);
4334  invalid_args:
4335      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4336      return 0;
4337  }
4338  static int clusterManagerCommandFix(int argc, char **argv) {
4339      config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_FIX;
4340      return clusterManagerCommandCheck(argc, argv);
4341  }
4342  static int clusterManagerCommandReshard(int argc, char **argv) {
4343      int port = 0;
4344      char *ip = NULL;
4345      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) goto invalid_args;
4346      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4347      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4348      clusterManagerCheckCluster(0);
4349      if (cluster_manager.errors &amp;&amp; listLength(cluster_manager.errors) &gt; 0) {
4350          fflush(stdout);
4351          fprintf(stderr,
4352                  &quot;*** Please fix your cluster problems before resharding\n&quot;);
4353          return 0;
4354      }
4355      int slots = config.cluster_manager_command.slots;
4356      if (!slots) {
4357          while (slots &lt;= 0 || slots &gt; CLUSTER_MANAGER_SLOTS) {
4358              printf(&quot;How many slots do you want to move (from 1 to %d)? &quot;,
4359                     CLUSTER_MANAGER_SLOTS);
4360              fflush(stdout);
4361              char buf[6];
4362              int nread = read(fileno(stdin),buf,6);
4363              if (nread &lt;= 0) continue;
4364              int last_idx = nread - 1;
4365              if (buf[last_idx] != &#x27;\n&#x27;) {
4366                  int ch;
4367                  while ((ch = getchar()) != &#x27;\n&#x27; &amp;&amp; ch != EOF) {}
4368              }
4369              buf[last_idx] = &#x27;\0&#x27;;
4370              slots = atoi(buf);
4371          }
4372      }
4373      char buf[255];
4374      char *to = config.cluster_manager_command.to,
4375           *from = config.cluster_manager_command.from;
4376      while (to == NULL) {
4377          printf(&quot;What is the receiving node ID? &quot;);
4378          fflush(stdout);
4379          int nread = read(fileno(stdin),buf,255);
4380          if (nread &lt;= 0) continue;
4381          int last_idx = nread - 1;
4382          if (buf[last_idx] != &#x27;\n&#x27;) {
4383              int ch;
4384              while ((ch = getchar()) != &#x27;\n&#x27; &amp;&amp; ch != EOF) {}
4385          }
4386          buf[last_idx] = &#x27;\0&#x27;;
4387          if (strlen(buf) &gt; 0) to = buf;
4388      }
4389      int raise_err = 0;
4390      clusterManagerNode *target = clusterNodeForResharding(to, NULL, &amp;raise_err);
4391      if (target == NULL) return 0;
4392      list *sources = listCreate();
4393      list *table = NULL;
4394      int all = 0, result = 1;
4395      if (from == NULL) {
4396          printf(&quot;Please enter all the source node IDs.\n&quot;);
4397          printf(&quot;  Type &#x27;all&#x27; to use all the nodes as source nodes for &quot;
4398                 &quot;the hash slots.\n&quot;);
4399          printf(&quot;  Type &#x27;done&#x27; once you entered all the source nodes IDs.\n&quot;);
4400          while (1) {
4401              printf(&quot;Source node #%lu: &quot;, listLength(sources) + 1);
4402              fflush(stdout);
4403              int nread = read(fileno(stdin),buf,255);
4404              if (nread &lt;= 0) continue;
4405              int last_idx = nread - 1;
4406              if (buf[last_idx] != &#x27;\n&#x27;) {
4407                  int ch;
4408                  while ((ch = getchar()) != &#x27;\n&#x27; &amp;&amp; ch != EOF) {}
4409              }
4410              buf[last_idx] = &#x27;\0&#x27;;
4411              if (!strcmp(buf, &quot;done&quot;)) break;
4412              else if (!strcmp(buf, &quot;all&quot;)) {
4413                  all = 1;
4414                  break;
4415              } else {
4416                  clusterManagerNode *src =
4417                      clusterNodeForResharding(buf, target, &amp;raise_err);
4418                  if (src != NULL) listAddNodeTail(sources, src);
4419                  else if (raise_err) {
4420                      result = 0;
4421                      goto cleanup;
4422                  }
4423              }
4424          }
4425      } else {
4426          char *p;
4427          while((p = strchr(from, &#x27;,&#x27;)) != NULL) {
4428              *p = &#x27;\0&#x27;;
4429              if (!strcmp(from, &quot;all&quot;)) {
4430                  all = 1;
4431                  break;
4432              } else {
4433                  clusterManagerNode *src =
4434                      clusterNodeForResharding(from, target, &amp;raise_err);
4435                  if (src != NULL) listAddNodeTail(sources, src);
4436                  else if (raise_err) {
4437                      result = 0;
4438                      goto cleanup;
4439                  }
4440              }
4441              from = p + 1;
4442          }
4443          if (!all &amp;&amp; strlen(from) &gt; 0) {
4444              if (!strcmp(from, &quot;all&quot;)) all = 1;
4445              if (!all) {
4446                  clusterManagerNode *src =
4447                      clusterNodeForResharding(from, target, &amp;raise_err);
4448                  if (src != NULL) listAddNodeTail(sources, src);
4449                  else if (raise_err) {
4450                      result = 0;
4451                      goto cleanup;
4452                  }
4453              }
4454          }
4455      }
4456      listIter li;
4457      listNode *ln;
4458      if (all) {
4459          listEmpty(sources);
4460          listRewind(cluster_manager.nodes, &amp;li);
4461          while ((ln = listNext(&amp;li)) != NULL) {
4462              clusterManagerNode *n = ln-&gt;value;
4463              if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE || n-&gt;replicate)
4464                  continue;
4465              if (!sdscmp(n-&gt;name, target-&gt;name)) continue;
4466              listAddNodeTail(sources, n);
4467          }
4468      }
4469      if (listLength(sources) == 0) {
4470          fprintf(stderr, &quot;*** No source nodes given, operation aborted.\n&quot;);
4471          result = 0;
4472          goto cleanup;
4473      }
4474      printf(&quot;\nReady to move %d slots.\n&quot;, slots);
4475      printf(&quot;  Source nodes:\n&quot;);
4476      listRewind(sources, &amp;li);
4477      while ((ln = listNext(&amp;li)) != NULL) {
4478          clusterManagerNode *src = ln-&gt;value;
4479          sds info = clusterManagerNodeInfo(src, 4);
4480          printf(&quot;%s\n&quot;, info);
4481          sdsfree(info);
4482      }
4483      printf(&quot;  Destination node:\n&quot;);
4484      sds info = clusterManagerNodeInfo(target, 4);
4485      printf(&quot;%s\n&quot;, info);
4486      sdsfree(info);
4487      table = clusterManagerComputeReshardTable(sources, slots);
4488      printf(&quot;  Resharding plan:\n&quot;);
4489      clusterManagerShowReshardTable(table);
4490      if (!(config.cluster_manager_command.flags &amp;
4491            CLUSTER_MANAGER_CMD_FLAG_YES))
4492      {
4493          printf(&quot;Do you want to proceed with the proposed &quot;
4494                 &quot;reshard plan (yes/no)? &quot;);
4495          fflush(stdout);
4496          char buf[4];
4497          int nread = read(fileno(stdin),buf,4);
4498          buf[3] = &#x27;\0&#x27;;
4499          if (nread &lt;= 0 || strcmp(&quot;yes&quot;, buf) != 0) {
4500              result = 0;
4501              goto cleanup;
4502          }
4503      }
4504      int opts = CLUSTER_MANAGER_OPT_VERBOSE;
4505      listRewind(table, &amp;li);
4506      while ((ln = listNext(&amp;li)) != NULL) {
4507          clusterManagerReshardTableItem *item = ln-&gt;value;
4508          char *err = NULL;
4509          result = clusterManagerMoveSlot(item-&gt;source, target, item-&gt;slot,
4510                                          opts, &amp;err);
4511          if (!result) {
4512              if (err != NULL) {
4513                  zfree(err);
4514              }
4515              goto cleanup;
4516          }
4517      }
4518  cleanup:
4519      listRelease(sources);
4520      clusterManagerReleaseReshardTable(table);
4521      return result;
4522  invalid_args:
4523      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4524      return 0;
4525  }
4526  static int clusterManagerCommandRebalance(int argc, char **argv) {
4527      int port = 0;
4528      char *ip = NULL;
4529      clusterManagerNode **weightedNodes = NULL;
4530      list *involved = NULL;
4531      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) goto invalid_args;
4532      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4533      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4534      int result = 1, i;
4535      if (config.cluster_manager_command.weight != NULL) {
4536          for (i = 0; i &lt; config.cluster_manager_command.weight_argc; i++) {
4537              char *name = config.cluster_manager_command.weight[i];
4538              char *p = strchr(name, &#x27;=&#x27;);
4539              if (p == NULL) {
4540                  result = 0;
4541                  goto cleanup;
4542              }
4543              *p = &#x27;\0&#x27;;
4544              float w = atof(++p);
4545              clusterManagerNode *n = clusterManagerNodeByAbbreviatedName(name);
4546              if (n == NULL) {
4547                  clusterManagerLogErr(&quot;*** No such master node %s\n&quot;, name);
4548                  result = 0;
4549                  goto cleanup;
4550              }
4551              n-&gt;weight = w;
4552          }
4553      }
4554      float total_weight = 0;
4555      int nodes_involved = 0;
4556      int use_empty = config.cluster_manager_command.flags &amp;
4557                      CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER;
4558      involved = listCreate();
4559      listIter li;
4560      listNode *ln;
4561      listRewind(cluster_manager.nodes, &amp;li);
4562      while ((ln = listNext(&amp;li)) != NULL) {
4563          clusterManagerNode *n = ln-&gt;value;
4564          if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE || n-&gt;replicate)
4565              continue;
4566          if (!use_empty &amp;&amp; n-&gt;slots_count == 0) {
4567              n-&gt;weight = 0;
4568              continue;
4569          }
4570          total_weight += n-&gt;weight;
4571          nodes_involved++;
4572          listAddNodeTail(involved, n);
4573      }
4574      weightedNodes = zmalloc(nodes_involved * sizeof(clusterManagerNode *));
4575      if (weightedNodes == NULL) goto cleanup;
4576      clusterManagerCheckCluster(1);
4577      if (cluster_manager.errors &amp;&amp; listLength(cluster_manager.errors) &gt; 0) {
4578          clusterManagerLogErr(&quot;*** Please fix your cluster problems &quot;
4579                               &quot;before rebalancing\n&quot;);
4580          result = 0;
4581          goto cleanup;
4582      }
4583      int threshold_reached = 0, total_balance = 0;
4584      float threshold = config.cluster_manager_command.threshold;
4585      i = 0;
4586      listRewind(involved, &amp;li);
4587      while ((ln = listNext(&amp;li)) != NULL) {
4588          clusterManagerNode *n = ln-&gt;value;
4589          weightedNodes[i++] = n;
4590          int expected = (int) (((float)CLUSTER_MANAGER_SLOTS / total_weight) *
4591                          n-&gt;weight);
4592          n-&gt;balance = n-&gt;slots_count - expected;
4593          total_balance += n-&gt;balance;
4594          int over_threshold = 0;
4595          if (threshold &gt; 0) {
4596              if (n-&gt;slots_count &gt; 0) {
4597                  float err_perc = fabs((100-(100.0*expected/n-&gt;slots_count)));
4598                  if (err_perc &gt; threshold) over_threshold = 1;
4599              } else if (expected &gt; 1) {
4600                  over_threshold = 1;
4601              }
4602          }
4603          if (over_threshold) threshold_reached = 1;
4604      }
4605      if (!threshold_reached) {
4606          clusterManagerLogWarn(&quot;*** No rebalancing needed! &quot;
4607                               &quot;All nodes are within the %.2f%% threshold.\n&quot;,
4608                               config.cluster_manager_command.threshold);
4609          goto cleanup;
4610      }
4611      while (total_balance &gt; 0) {
4612          listRewind(involved, &amp;li);
4613          while ((ln = listNext(&amp;li)) != NULL) {
4614              clusterManagerNode *n = ln-&gt;value;
4615              if (n-&gt;balance &lt;= 0 &amp;&amp; total_balance &gt; 0) {
4616                  n-&gt;balance--;
4617                  total_balance--;
4618              }
4619          }
4620      }
4621      qsort(weightedNodes, nodes_involved, sizeof(clusterManagerNode *),
4622            clusterManagerCompareNodeBalance);
4623      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Rebalancing across %d nodes. &quot;
4624                            &quot;Total weight = %.2f\n&quot;,
4625                            nodes_involved, total_weight);
4626      if (config.verbose) {
4627          for (i = 0; i &lt; nodes_involved; i++) {
4628              clusterManagerNode *n = weightedNodes[i];
4629              printf(&quot;%s:%d balance is %d slots\n&quot;, n-&gt;ip, n-&gt;port, n-&gt;balance);
4630          }
4631      }
4632      int dst_idx = 0;
4633      int src_idx = nodes_involved - 1;
4634      int simulate = config.cluster_manager_command.flags &amp;
4635                     CLUSTER_MANAGER_CMD_FLAG_SIMULATE;
4636      while (dst_idx &lt; src_idx) {
4637          clusterManagerNode *dst = weightedNodes[dst_idx];
4638          clusterManagerNode *src = weightedNodes[src_idx];
4639          int db = abs(dst-&gt;balance);
4640          int sb = abs(src-&gt;balance);
4641          int numslots = (db &lt; sb ? db : sb);
4642          if (numslots &gt; 0) {
4643              printf(&quot;Moving %d slots from %s:%d to %s:%d\n&quot;, numslots,
4644                                                              src-&gt;ip,
4645                                                              src-&gt;port,
4646                                                              dst-&gt;ip,
4647                                                              dst-&gt;port);
4648              list *lsrc = listCreate(), *table = NULL;
4649              listAddNodeTail(lsrc, src);
4650              table = clusterManagerComputeReshardTable(lsrc, numslots);
4651              listRelease(lsrc);
4652              int table_len = (int) listLength(table);
4653              if (!table || table_len != numslots) {
4654                  clusterManagerLogErr(&quot;*** Assertion failed: Reshard table &quot;
4655                                       &quot;!= number of slots&quot;);
4656                  result = 0;
4657                  goto end_move;
4658              }
4659              if (simulate) {
4660                  for (i = 0; i &lt; table_len; i++) printf(&quot;#&quot;);
4661              } else {
4662                  int opts = CLUSTER_MANAGER_OPT_QUIET |
4663                             CLUSTER_MANAGER_OPT_UPDATE;
4664                  listRewind(table, &amp;li);
4665                  while ((ln = listNext(&amp;li)) != NULL) {
4666                      clusterManagerReshardTableItem *item = ln-&gt;value;
4667                      result = clusterManagerMoveSlot(item-&gt;source,
4668                                                      dst,
4669                                                      item-&gt;slot,
4670                                                      opts, NULL);
4671                      if (!result) goto end_move;
4672                      printf(&quot;#&quot;);
4673                      fflush(stdout);
4674                  }
4675              }
4676              printf(&quot;\n&quot;);
4677  end_move:
4678              clusterManagerReleaseReshardTable(table);
4679              if (!result) goto cleanup;
4680          }
4681          dst-&gt;balance += numslots;
4682          src-&gt;balance -= numslots;
4683          if (dst-&gt;balance == 0) dst_idx++;
4684          if (src-&gt;balance == 0) src_idx --;
4685      }
4686  cleanup:
4687      if (involved != NULL) listRelease(involved);
4688      if (weightedNodes != NULL) zfree(weightedNodes);
4689      return result;
4690  invalid_args:
4691      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4692      return 0;
4693  }
4694  static int clusterManagerCommandSetTimeout(int argc, char **argv) {
4695      UNUSED(argc);
4696      int port = 0;
4697      char *ip = NULL;
4698      if (!getClusterHostFromCmdArgs(1, argv, &amp;ip, &amp;port)) goto invalid_args;
4699      int timeout = atoi(argv[1]);
4700      if (timeout &lt; 100) {
4701          fprintf(stderr, &quot;Setting a node timeout of less than 100 &quot;
4702                  &quot;milliseconds is a bad idea.\n&quot;);
4703          return 0;
4704      }
4705      clusterManagerNode *node = clusterManagerNewNode(ip, port);
4706      if (!clusterManagerLoadInfoFromNode(node, 0)) return 0;
4707      int ok_count = 0, err_count = 0;
4708      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Reconfiguring node timeout in every &quot;
4709                            &quot;cluster node...\n&quot;);
4710      listIter li;
4711      listNode *ln;
4712      listRewind(cluster_manager.nodes, &amp;li);
4713      while ((ln = listNext(&amp;li)) != NULL) {
4714          clusterManagerNode *n = ln-&gt;value;
4715          char *err = NULL;
4716          redisReply *reply = CLUSTER_MANAGER_COMMAND(n, &quot;CONFIG %s %s %d&quot;,
4717                                                      &quot;SET&quot;,
4718                                                      &quot;cluster-node-timeout&quot;,
4719                                                      timeout);
4720          if (reply == NULL) goto reply_err;
4721          int ok = clusterManagerCheckRedisReply(n, reply, &amp;err);
4722          freeReplyObject(reply);
4723          if (!ok) goto reply_err;
4724          reply = CLUSTER_MANAGER_COMMAND(n, &quot;CONFIG %s&quot;, &quot;REWRITE&quot;);
4725          if (reply == NULL) goto reply_err;
4726          ok = clusterManagerCheckRedisReply(n, reply, &amp;err);
4727          freeReplyObject(reply);
4728          if (!ok) goto reply_err;
4729          clusterManagerLogWarn(&quot;*** New timeout set for %s:%d\n&quot;, n-&gt;ip,
4730                                n-&gt;port);
4731          ok_count++;
4732          continue;
4733  reply_err:;
4734          int need_free = 0;
4735          if (err == NULL) err = &quot;&quot;;
4736          else need_free = 1;
4737          clusterManagerLogErr(&quot;ERR setting node-timeot for %s:%d: %s\n&quot;, n-&gt;ip,
4738                               n-&gt;port, err);
4739          if (need_free) zfree(err);
4740          err_count++;
4741      }
4742      clusterManagerLogInfo(&quot;&gt;&gt;&gt; New node timeout set. %d OK, %d ERR.\n&quot;,
4743                            ok_count, err_count);
4744      return 1;
4745  invalid_args:
4746      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4747      return 0;
4748  }
4749  static int clusterManagerCommandImport(int argc, char **argv) {
4750      int success = 1;
4751      int port = 0, src_port = 0;
4752      char *ip = NULL, *src_ip = NULL;
4753      char *invalid_args_msg = NULL;
4754      if (!getClusterHostFromCmdArgs(argc, argv, &amp;ip, &amp;port)) {
4755          invalid_args_msg = CLUSTER_MANAGER_INVALID_HOST_ARG;
4756          goto invalid_args;
4757      }
4758      if (config.cluster_manager_command.from == NULL) {
4759          invalid_args_msg = &quot;[ERR] Option &#x27;--cluster-from&#x27; is required for &quot;
4760                             &quot;subcommand &#x27;import&#x27;.\n&quot;;
4761          goto invalid_args;
4762      }
4763      char *src_host[] = {config.cluster_manager_command.from};
4764      if (!getClusterHostFromCmdArgs(1, src_host, &amp;src_ip, &amp;src_port)) {
4765          invalid_args_msg = &quot;[ERR] Invalid --cluster-from host. You need to &quot;
4766                             &quot;pass a valid address (ie. 120.0.0.1:7000).\n&quot;;
4767          goto invalid_args;
4768      }
4769      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Importing data from %s:%d to cluster %s:%d\n&quot;,
4770                            src_ip, src_port, ip, port);
4771      clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
4772      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4773      if (!clusterManagerCheckCluster(0)) return 0;
4774      char *reply_err = NULL;
4775      redisReply *src_reply = NULL;
4776      redisContext *src_ctx = redisConnect(src_ip, src_port);
4777      if (src_ctx-&gt;err) {
4778          success = 0;
4779          fprintf(stderr,&quot;Could not connect to Redis at %s:%d: %s.\n&quot;, src_ip,
4780                  src_port, src_ctx-&gt;errstr);
4781          goto cleanup;
4782      }
4783      src_reply = reconnectingRedisCommand(src_ctx, &quot;INFO&quot;);
4784      if (!src_reply || src_reply-&gt;type == REDIS_REPLY_ERROR) {
4785          if (src_reply &amp;&amp; src_reply-&gt;str) reply_err = src_reply-&gt;str;
4786          success = 0;
4787          goto cleanup;
4788      }
4789      if (getLongInfoField(src_reply-&gt;str, &quot;cluster_enabled&quot;)) {
4790          clusterManagerLogErr(&quot;[ERR] The source node should not be a &quot;
4791                               &quot;cluster node.\n&quot;);
4792          success = 0;
4793          goto cleanup;
4794      }
4795      freeReplyObject(src_reply);
4796      src_reply = reconnectingRedisCommand(src_ctx, &quot;DBSIZE&quot;);
4797      if (!src_reply || src_reply-&gt;type == REDIS_REPLY_ERROR) {
4798          if (src_reply &amp;&amp; src_reply-&gt;str) reply_err = src_reply-&gt;str;
4799          success = 0;
4800          goto cleanup;
4801      }
4802      int size = src_reply-&gt;integer, i;
4803      clusterManagerLogWarn(&quot;*** Importing %d keys from DB 0\n&quot;, size);
4804      clusterManagerNode  *slots_map[CLUSTER_MANAGER_SLOTS];
4805      memset(slots_map, 0, sizeof(slots_map));
4806      listIter li;
4807      listNode *ln;
4808      for (i = 0; i &lt; CLUSTER_MANAGER_SLOTS; i++) {
4809          listRewind(cluster_manager.nodes, &amp;li);
4810          while ((ln = listNext(&amp;li)) != NULL) {
4811              clusterManagerNode *n = ln-&gt;value;
4812              if (n-&gt;flags &amp; CLUSTER_MANAGER_FLAG_SLAVE) continue;
4813              if (n-&gt;slots_count == 0) continue;
4814              if (n-&gt;slots[i]) {
4815                  slots_map[i] = n;
4816                  break;
4817              }
4818          }
4819      }
4820      char cmdfmt[50] = &quot;MIGRATE %s %d %s %d %d&quot;;
4821      if (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_COPY)
4822          strcat(cmdfmt, &quot; %s&quot;);
4823      if (config.cluster_manager_command.flags &amp; CLUSTER_MANAGER_CMD_FLAG_REPLACE)
4824          strcat(cmdfmt, &quot; %s&quot;);
4825      int cursor = -999, timeout = config.cluster_manager_command.timeout;
4826      while (cursor != 0) {
4827          if (cursor &lt; 0) cursor = 0;
4828          freeReplyObject(src_reply);
4829          src_reply = reconnectingRedisCommand(src_ctx, &quot;SCAN %d COUNT %d&quot;,
4830                                               cursor, 1000);
4831          if (!src_reply || src_reply-&gt;type == REDIS_REPLY_ERROR) {
4832              if (src_reply &amp;&amp; src_reply-&gt;str) reply_err = src_reply-&gt;str;
4833              success = 0;
4834              goto cleanup;
4835          }
4836          assert(src_reply-&gt;type == REDIS_REPLY_ARRAY);
4837          assert(src_reply-&gt;elements &gt;= 2);
4838          assert(src_reply-&gt;element[1]-&gt;type == REDIS_REPLY_ARRAY);
4839          if (src_reply-&gt;element[0]-&gt;type == REDIS_REPLY_STRING)
4840              cursor = atoi(src_reply-&gt;element[0]-&gt;str);
4841          else if (src_reply-&gt;element[0]-&gt;type == REDIS_REPLY_INTEGER)
4842              cursor = src_reply-&gt;element[0]-&gt;integer;
4843          int keycount = src_reply-&gt;element[1]-&gt;elements;
4844          for (i = 0; i &lt; keycount; i++) {
4845              redisReply *kr = src_reply-&gt;element[1]-&gt;element[i];
4846              assert(kr-&gt;type == REDIS_REPLY_STRING);
4847              char *key = kr-&gt;str;
4848              uint16_t slot = clusterManagerKeyHashSlot(key, kr-&gt;len);
4849              clusterManagerNode *target = slots_map[slot];
4850              printf(&quot;Migrating %s to %s:%d: &quot;, key, target-&gt;ip, target-&gt;port);
4851              redisReply *r = reconnectingRedisCommand(src_ctx, cmdfmt,
4852                                                       target-&gt;ip, target-&gt;port,
4853                                                       key, 0, timeout,
4854                                                       &quot;COPY&quot;, &quot;REPLACE&quot;);
4855              if (!r || r-&gt;type == REDIS_REPLY_ERROR) {
4856                  if (r &amp;&amp; r-&gt;str) {
4857                      clusterManagerLogErr(&quot;Source %s:%d replied with &quot;
4858                                           &quot;error:\n%s\n&quot;, src_ip, src_port,
4859                                           r-&gt;str);
4860                  }
4861                  success = 0;
4862              }
4863              freeReplyObject(r);
4864              if (!success) goto cleanup;
4865              clusterManagerLogOk(&quot;OK\n&quot;);
4866          }
4867      }
4868  cleanup:
4869      if (reply_err)
4870          clusterManagerLogErr(&quot;Source %s:%d replied with error:\n%s\n&quot;,
4871                               src_ip, src_port, reply_err);
4872      if (src_ctx) redisFree(src_ctx);
4873      if (src_reply) freeReplyObject(src_reply);
4874      return success;
4875  invalid_args:
4876      fprintf(stderr, &quot;%s&quot;, invalid_args_msg);
4877      return 0;
4878  }
4879  static int clusterManagerCommandCall(int argc, char **argv) {
4880      int port = 0, i;
4881      char *ip = NULL;
4882      if (!getClusterHostFromCmdArgs(1, argv, &amp;ip, &amp;port)) goto invalid_args;
4883      clusterManagerNode *refnode = clusterManagerNewNode(ip, port);
4884      if (!clusterManagerLoadInfoFromNode(refnode, 0)) return 0;
4885      argc--;
4886      argv++;
4887      size_t *argvlen = zmalloc(argc*sizeof(size_t));
4888      clusterManagerLogInfo(&quot;&gt;&gt;&gt; Calling&quot;);
4889      for (i = 0; i &lt; argc; i++) {
4890          argvlen[i] = strlen(argv[i]);
4891          printf(&quot; %s&quot;, argv[i]);
4892      }
4893      printf(&quot;\n&quot;);
4894      listIter li;
4895      listNode *ln;
4896      listRewind(cluster_manager.nodes, &amp;li);
4897      while ((ln = listNext(&amp;li)) != NULL) {
4898          clusterManagerNode *n = ln-&gt;value;
4899          if (!n-&gt;context &amp;&amp; !clusterManagerNodeConnect(n)) continue;
4900          redisReply *reply = NULL;
4901          redisAppendCommandArgv(n-&gt;context, argc, (const char **) argv, argvlen);
4902          int status = redisGetReply(n-&gt;context, (void **)(&amp;reply));
4903          if (status != REDIS_OK || reply == NULL )
4904              printf(&quot;%s:%d: Failed!\n&quot;, n-&gt;ip, n-&gt;port);
4905          else {
4906              sds formatted_reply = cliFormatReplyRaw(reply);
4907              printf(&quot;%s:%d: %s\n&quot;, n-&gt;ip, n-&gt;port, (char *) formatted_reply);
4908              sdsfree(formatted_reply);
4909          }
4910          if (reply != NULL) freeReplyObject(reply);
4911      }
4912      zfree(argvlen);
4913      return 1;
4914  invalid_args:
4915      fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
4916      return 0;
4917  }
4918  static int clusterManagerCommandHelp(int argc, char **argv) {
4919      UNUSED(argc);
4920      UNUSED(argv);
4921      int commands_count = sizeof(clusterManagerCommands) /
4922                           sizeof(clusterManagerCommandDef);
4923      int i = 0, j;
4924      fprintf(stderr, &quot;Cluster Manager Commands:\n&quot;);
4925      int padding = 15;
4926      for (; i &lt; commands_count; i++) {
4927          clusterManagerCommandDef *def = &amp;(clusterManagerCommands[i]);
4928          int namelen = strlen(def-&gt;name), padlen = padding - namelen;
4929          fprintf(stderr, &quot;  %s&quot;, def-&gt;name);
4930          for (j = 0; j &lt; padlen; j++) fprintf(stderr, &quot; &quot;);
4931          fprintf(stderr, &quot;%s\n&quot;, (def-&gt;args ? def-&gt;args : &quot;&quot;));
4932          if (def-&gt;options != NULL) {
4933              int optslen = strlen(def-&gt;options);
4934              char *p = def-&gt;options, *eos = p + optslen;
4935              char *comma = NULL;
4936              while ((comma = strchr(p, &#x27;,&#x27;)) != NULL) {
4937                  int deflen = (int)(comma - p);
4938                  char buf[255];
4939                  memcpy(buf, p, deflen);
4940                  buf[deflen] = &#x27;\0&#x27;;
4941                  for (j = 0; j &lt; padding; j++) fprintf(stderr, &quot; &quot;);
4942                  fprintf(stderr, &quot;  --cluster-%s\n&quot;, buf);
4943                  p = comma + 1;
4944                  if (p &gt;= eos) break;
4945              }
4946              if (p &lt; eos) {
4947                  for (j = 0; j &lt; padding; j++) fprintf(stderr, &quot; &quot;);
4948                  fprintf(stderr, &quot;  --cluster-%s\n&quot;, p);
4949              }
4950          }
4951      }
4952      fprintf(stderr, &quot;\nFor check, fix, reshard, del-node, set-timeout you &quot;
4953                      &quot;can specify the host and port of any working node in &quot;
4954                      &quot;the cluster.\n\n&quot;);
4955      return 0;
4956  }
4957  static void latencyModePrint(PORT_LONGLONG min, PORT_LONGLONG max, double avg, PORT_LONGLONG count) {
4958      if (config.output == OUTPUT_STANDARD) {
4959          printf(&quot;min: %lld, max: %lld, avg: %.2f (%lld samples)&quot;,
4960                  min, max, avg, count);
4961          fflush(stdout);
4962      } else if (config.output == OUTPUT_CSV) {
4963          printf(&quot;%lld,%lld,%.2f,%lld\n&quot;, min, max, avg, count);
4964      } else if (config.output == OUTPUT_RAW) {
4965          printf(&quot;%lld %lld %.2f %lld\n&quot;, min, max, avg, count);
4966      }
4967  }
4968  #define LATENCY_SAMPLE_RATE 10 &amp;bsol;* milliseconds. */
4969  #define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 &amp;bsol;* milliseconds. */
4970  static void latencyMode(void) {
4971      redisReply *reply;
4972      PORT_LONGLONG start, latency, min = 0, max = 0, tot = 0, count = 0;
4973      PORT_LONGLONG history_interval =
4974          config.interval ? config.interval/1000 :
4975                            LATENCY_HISTORY_DEFAULT_INTERVAL;
4976      double avg;
4977      PORT_LONGLONG history_start = mstime();
4978      if (config.interval == 0) {
4979          config.interval = 1000;
4980      } else {
4981          config.interval /= 1000; &amp;bsol;* We need to convert to milliseconds. */
4982      }
4983      if (!context) exit(1);
4984      while(1) {
4985          start = mstime();
4986          reply = reconnectingRedisCommand(context,&quot;PING&quot;);
4987          if (reply == NULL) {
4988              fprintf(stderr,&quot;\nI/O error\n&quot;);
4989              exit(1);
4990          }
4991          latency = mstime()-start;
4992          freeReplyObject(reply);
4993          count++;
4994          if (count == 1) {
4995              min = max = tot = latency;
4996              avg = (double) latency;
4997          } else {
4998              if (latency &lt; min) min = latency;
4999              if (latency &gt; max) max = latency;
5000              tot += latency;
5001              avg = (double) tot/count;
5002          }
5003          if (config.output == OUTPUT_STANDARD) {
5004              printf(&quot;\x1b[0G\x1b[2K&quot;); &amp;bsol;* Clear the line. */
5005              latencyModePrint(min,max,avg,count);
5006          } else {
5007              if (config.latency_history) {
5008                  latencyModePrint(min,max,avg,count);
5009              } else if (mstime()-history_start &gt; config.interval) {
5010                  latencyModePrint(min,max,avg,count);
5011                  exit(0);
5012              }
5013          }
5014          if (config.latency_history &amp;&amp; mstime()-history_start &gt; history_interval)
5015          {
5016              printf(&quot; -- %.2f seconds range\n&quot;, (float)(mstime()-history_start)/1000);
5017              history_start = mstime();
5018              min = max = tot = count = 0;
5019          }
5020          usleep(LATENCY_SAMPLE_RATE * 1000);
5021      }
5022  }
5023  #define LATENCY_DIST_DEFAULT_INTERVAL 1000 &amp;bsol;* milliseconds. */
5024  struct distsamples {
5025      PORT_LONGLONG max;   &amp;bsol;* Max latency to fit into this interval (usec). */
5026      PORT_LONGLONG count; &amp;bsol;* Number of samples in this interval. */
5027      int character;   &amp;bsol;* Associated character in visualization. */
5028  };
5029  void showLatencyDistSamples(struct distsamples *samples, PORT_LONGLONG tot) {
5030      int j;
5031      printf(&quot;\033[38;5;0m&quot;); &amp;bsol;* Set foreground color to black. */
5032      for (j = 0; ; j++) {
5033          int coloridx =
5034              (int) ceil((float) samples[j].count / tot * (spectrum_palette_size-1));  WIN_PORT_FIX &amp;bsol;* cast (int) */
5035          int color = spectrum_palette[coloridx];
5036          printf(&quot;\033[48;5;%dm%c&quot;, (int)color, samples[j].character);
5037          samples[j].count = 0;
5038          if (samples[j].max == 0) break; &amp;bsol;* Last sample. */
5039      }
5040      printf(&quot;\033[0m\n&quot;);
5041      fflush(stdout);
5042  }
5043  void showLatencyDistLegend(void) {
5044      int j;
5045      printf(&quot;---------------------------------------------\n&quot;);
5046      printf(&quot;. - * #          .01 .125 .25 .5 milliseconds\n&quot;);
5047      printf(&quot;1,2,3,...,9      from 1 to 9     milliseconds\n&quot;);
5048      printf(&quot;A,B,C,D,E        10,20,30,40,50  milliseconds\n&quot;);
5049      printf(&quot;F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n&quot;);
5050      printf(&quot;K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,&gt;60 seconds\n&quot;);
5051      printf(&quot;From 0 to 100%%: &quot;);
5052      for (j = 0; j &lt; spectrum_palette_size; j++) {
5053          printf(&quot;\033[48;5;%dm &quot;, spectrum_palette[j]);
5054      }
5055      printf(&quot;\033[0m\n&quot;);
5056      printf(&quot;---------------------------------------------\n&quot;);
5057  }
5058  static void latencyDistMode(void) {
5059      redisReply *reply;
5060      PORT_LONGLONG start, latency, count = 0;
5061      PORT_LONGLONG history_interval =
5062          config.interval ? config.interval/1000 :
5063                            LATENCY_DIST_DEFAULT_INTERVAL;
5064      PORT_LONGLONG history_start = ustime();
5065      int j, outputs = 0;
5066      struct distsamples samples[] = {
5067          {10,0,&#x27;.&#x27;},         &amp;bsol;* 0.01 ms */
5068          {125,0,&#x27;-&#x27;},        &amp;bsol;* 0.125 ms */
5069          {250,0,&#x27;*&#x27;},        &amp;bsol;* 0.25 ms */
5070          {500,0,&#x27;#&#x27;},        &amp;bsol;* 0.5 ms */
5071          {1000,0,&#x27;1&#x27;},       &amp;bsol;* 1 ms */
5072          {2000,0,&#x27;2&#x27;},       &amp;bsol;* 2 ms */
5073          {3000,0,&#x27;3&#x27;},       &amp;bsol;* 3 ms */
5074          {4000,0,&#x27;4&#x27;},       &amp;bsol;* 4 ms */
5075          {5000,0,&#x27;5&#x27;},       &amp;bsol;* 5 ms */
5076          {6000,0,&#x27;6&#x27;},       &amp;bsol;* 6 ms */
5077          {7000,0,&#x27;7&#x27;},       &amp;bsol;* 7 ms */
5078          {8000,0,&#x27;8&#x27;},       &amp;bsol;* 8 ms */
5079          {9000,0,&#x27;9&#x27;},       &amp;bsol;* 9 ms */
5080          {10000,0,&#x27;A&#x27;},      &amp;bsol;* 10 ms */
5081          {20000,0,&#x27;B&#x27;},      &amp;bsol;* 20 ms */
5082          {30000,0,&#x27;C&#x27;},      &amp;bsol;* 30 ms */
5083          {40000,0,&#x27;D&#x27;},      &amp;bsol;* 40 ms */
5084          {50000,0,&#x27;E&#x27;},      &amp;bsol;* 50 ms */
5085          {100000,0,&#x27;F&#x27;},     &amp;bsol;* 0.1 s */
5086          {200000,0,&#x27;G&#x27;},     &amp;bsol;* 0.2 s */
5087          {300000,0,&#x27;H&#x27;},     &amp;bsol;* 0.3 s */
5088          {400000,0,&#x27;I&#x27;},     &amp;bsol;* 0.4 s */
5089          {500000,0,&#x27;J&#x27;},     &amp;bsol;* 0.5 s */
5090          {1000000,0,&#x27;K&#x27;},    &amp;bsol;* 1 s */
5091          {2000000,0,&#x27;L&#x27;},    &amp;bsol;* 2 s */
5092          {4000000,0,&#x27;M&#x27;},    &amp;bsol;* 4 s */
5093          {8000000,0,&#x27;N&#x27;},    &amp;bsol;* 8 s */
5094          {16000000,0,&#x27;O&#x27;},   &amp;bsol;* 16 s */
5095          {30000000,0,&#x27;P&#x27;},   &amp;bsol;* 30 s */
5096          {60000000,0,&#x27;Q&#x27;},   &amp;bsol;* 1 minute */
5097          {0,0,&#x27;?&#x27;},          &amp;bsol;* &gt; 1 minute */
5098      };
5099      if (!context) exit(1);
5100      while(1) {
5101          start = ustime();
5102          reply = reconnectingRedisCommand(context,&quot;PING&quot;);
5103          if (reply == NULL) {
5104              fprintf(stderr,&quot;\nI/O error\n&quot;);
5105              exit(1);
5106          }
5107          latency = ustime()-start;
5108          freeReplyObject(reply);
5109          count++;
5110          for (j = 0; ; j++) {
5111              if (samples[j].max == 0 || latency &lt;= samples[j].max) {
5112                  samples[j].count++;
5113                  break;
5114              }
5115          }
5116          if (count &amp;&amp; (ustime()-history_start)/1000 &gt; history_interval) {
5117              if ((outputs++ % 20) == 0)
5118                  showLatencyDistLegend();
5119              showLatencyDistSamples(samples,count);
5120              history_start = ustime();
5121              count = 0;
5122          }
5123          usleep(LATENCY_SAMPLE_RATE * 1000);
5124      }
5125  }
5126  PORT_ULONGLONG sendSync(int fd) {
5127      char buf[4096], *p;
5128      ssize_t nread;
5129      if (write(fd,&quot;SYNC\r\n&quot;,6) != 6) {
5130          fprintf(stderr,&quot;Error writing to master\n&quot;);
5131          exit(1);
5132      }
5133      p = buf;
5134      while(1) {
5135          nread = read(fd,p,1);
5136          if (nread &lt;= 0) {
5137              fprintf(stderr,&quot;Error reading bulk length while SYNCing\n&quot;);
5138              exit(1);
5139          }
5140          if (*p == &#x27;\n&#x27; &amp;&amp; p != buf) break;
5141          if (*p != &#x27;\n&#x27;) p++;
5142      }
5143      *p = &#x27;\0&#x27;;
5144      if (buf[0] == &#x27;-&#x27;) {
5145          printf(&quot;SYNC with master failed: %s\n&quot;, buf);
5146          exit(1);
5147      }
5148      return strtoull(buf+1,NULL,10);
5149  }
5150  static void slaveMode(void) {
5151      int fd = context-&gt;fd;
5152      PORT_ULONGLONG payload = sendSync(fd);
5153      char buf[1024];
5154      int original_output = config.output;
5155      fprintf(stderr,&quot;SYNC with master, discarding %llu &quot;
5156                     &quot;bytes of bulk transfer...\n&quot;, payload);
5157      while(payload) {
5158          ssize_t nread;
5159          nread = read(fd,buf,(payload &gt; sizeof(buf)) ? sizeof(buf) : payload);
5160          if (nread &lt;= 0) {
5161              fprintf(stderr,&quot;Error reading RDB payload while SYNCing\n&quot;);
5162              exit(1);
5163          }
5164          payload -= nread;
5165      }
5166      fprintf(stderr,&quot;SYNC done. Logging commands from master.\n&quot;);
5167      config.output = OUTPUT_CSV;
5168      while (cliReadReply(0) == REDIS_OK);
5169      config.output = original_output;
5170  }
5171  static void getRDB(void) {
5172      int s = context-&gt;fd;
5173      int fd;
5174      PORT_ULONGLONG payload = sendSync(s);
5175      char buf[4096];
5176      fprintf(stderr,&quot;SYNC sent to master, writing %llu bytes to &#x27;%s&#x27;\n&quot;,
5177          payload, config.rdb_filename);
5178      if (!strcmp(config.rdb_filename,&quot;-&quot;)) {
5179          fd = STDOUT_FILENO;
5180      } else {
5181          fd = open(config.rdb_filename, O_CREAT|O_WRONLY, 0644);
5182          if (fd == -1) {
5183              fprintf(stderr, &quot;Error opening &#x27;%s&#x27;: %s\n&quot;, config.rdb_filename,
5184                  strerror(errno));
5185              exit(1);
5186          }
5187      }
5188      while(payload) {
5189          ssize_t nread, nwritten;
5190          nread = read(s,buf,(payload &gt; sizeof(buf)) ? sizeof(buf) : payload);
5191          if (nread &lt;= 0) {
5192              fprintf(stderr,&quot;I/O Error reading RDB payload from socket\n&quot;);
5193              exit(1);
5194          }
5195          nwritten = write(fd, buf, nread);
5196          if (nwritten != nread) {
5197              fprintf(stderr,&quot;Error writing data to file: %s\n&quot;,
5198                  (nwritten == -1) ? IF_WIN32(wsa_strerror(errno), strerror(errno)) : &quot;short write&quot;);
5199              exit(1);
5200          }
5201          payload -= nread;
5202      }
5203      close(s); &amp;bsol;* Close the file descriptor ASAP as fsync() may take time. */
5204      fsync(fd);
5205      close(fd);
5206      fprintf(stderr,&quot;Transfer finished with success.\n&quot;);
5207      exit(0);
5208  }
5209  #define PIPEMODE_WRITE_LOOP_MAX_BYTES (128*1024)
5210  static void pipeMode(void) {
5211      int fd = (int)context-&gt;fd;
5212      PORT_LONGLONG errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;
5213      char ibuf[1024*16], obuf[1024*16]; &amp;bsol;* Input and output buffers */
5214      char aneterr[ANET_ERR_LEN];
5215      redisReader *reader = redisReaderCreate();
5216      redisReply *reply;
5217      int eof = 0; &amp;bsol;* True once we consumed all the standard input. */
5218      int done = 0;
5219      char magic[20]; &amp;bsol;* Special reply we recognize. */
5220      time_t last_read_time = time(NULL);
5221  #ifdef _WIN32
5222      setmode(STDIN_FILENO, _O_BINARY);
5223  #endif
5224      srand((unsigned int) time(NULL));                                            WIN_PORT_FIX &amp;bsol;* cast unsigned int */
5225      if (anetNonBlock(aneterr,fd) == ANET_ERR) {
5226          fprintf(stderr, &quot;Can&#x27;t set the socket in non blocking mode: %s\n&quot;,
5227              aneterr);
5228          exit(1);
5229      }
5230      while(!done) {
5231          int mask = AE_READABLE;
5232          if (!eof || obuf_len != 0) mask |= AE_WRITABLE;
5233          mask = aeWait(fd,mask,1000);
5234          if (mask &amp; AE_READABLE) {
5235              ssize_t nread;
5236              int read_error = 0;
5237              do {
5238                  nread = read(fd,ibuf,sizeof(ibuf));
5239                  if (nread == -1 &amp;&amp; errno != EAGAIN &amp;&amp; errno != EINTR) {
5240                      fprintf(stderr, &quot;Error reading from the server: %s\n&quot;,
5241                          strerror(errno));
5242                      read_error = 1;
5243                      break;
5244                  }
5245                  if (nread &gt; 0) {
5246                      redisReaderFeed(reader,ibuf,nread);
5247                      last_read_time = time(NULL);
5248                  }
5249              } while(nread &gt; 0);
5250              do {
5251                  if (redisReaderGetReply(reader,(void**)&amp;reply) == REDIS_ERR) {
5252                      fprintf(stderr, &quot;Error reading replies from server\n&quot;);
5253                      exit(1);
5254                  }
5255                  if (reply) {
5256                      if (reply-&gt;type == REDIS_REPLY_ERROR) {
5257                          fprintf(stderr,&quot;%s\n&quot;, reply-&gt;str);
5258                          errors++;
5259                      } else if (eof &amp;&amp; reply-&gt;type == REDIS_REPLY_STRING &amp;&amp;
5260                                        reply-&gt;len == 20) {
5261                          if (memcmp(reply-&gt;str,magic,20) == 0) {
5262                              printf(&quot;Last reply received from server.\n&quot;);
5263                              done = 1;
5264                              replies--;
5265                          }
5266                      }
5267                      replies++;
5268                      freeReplyObject(reply);
5269                  }
5270              } while(reply);
5271              if (read_error) exit(1);
5272          }
5273          if (mask &amp; AE_WRITABLE) {
5274              ssize_t loop_nwritten = 0;
5275              while(1) {
5276                  if (obuf_len != 0) {
5277                      ssize_t nwritten = write(fd,obuf+obuf_pos,obuf_len);
5278                      if (nwritten == -1) {
5279                          if (errno != EAGAIN &amp;&amp; errno != EINTR) {
5280                              fprintf(stderr, &quot;Error writing to the server: %s\n&quot;,
5281                                  strerror(errno));
5282                              exit(1);
5283                          } else {
5284                              nwritten = 0;
5285                          }
5286                      }
5287                      obuf_len -= nwritten;
5288                      obuf_pos += nwritten;
5289                      loop_nwritten += nwritten;
5290                      if (obuf_len != 0) break; &amp;bsol;* Can&#x27;t accept more data. */
5291                  }
5292                  if (obuf_len == 0 &amp;&amp; !eof) {
5293                      ssize_t nread = read(STDIN_FILENO,obuf,sizeof(obuf));
5294                      if (nread == 0) {
5295                          char echo[] =
5296                          &quot;\r\n*2\r\n$4\r\nECHO\r\n$20\r\n01234567890123456789\r\n&quot;;
5297                          int j;
5298                          eof = 1;
5299                          for (j = 0; j &lt; 20; j++)
5300                              magic[j] = rand() &amp; 0xff;
5301                          memcpy(echo+21,magic,20);
5302                          memcpy(obuf,echo,sizeof(echo)-1);
5303                          obuf_len = sizeof(echo)-1;
5304                          obuf_pos = 0;
5305                          printf(&quot;All data transferred. Waiting for the last reply...\n&quot;);
5306                      } else if (nread == -1) {
5307                          fprintf(stderr, &quot;Error reading from stdin: %s\n&quot;,
5308                              strerror(errno));
5309                          exit(1);
5310                      } else {
5311                          obuf_len = nread;
5312                          obuf_pos = 0;
5313                      }
5314                  }
5315                  if ((obuf_len == 0 &amp;&amp; eof) ||
5316                      loop_nwritten &gt; PIPEMODE_WRITE_LOOP_MAX_BYTES) break;
5317              }
5318          }
5319          if (eof &amp;&amp; config.pipe_timeout &gt; 0 &amp;&amp;
5320              time(NULL)-last_read_time &gt; config.pipe_timeout)
5321          {
5322              fprintf(stderr,&quot;No replies for %d seconds: exiting.\n&quot;,
5323                  config.pipe_timeout);
5324              errors++;
5325              break;
5326          }
5327      }
5328      redisReaderFree(reader);
5329      printf(&quot;errors: %lld, replies: %lld\n&quot;, errors, replies);
5330      if (errors)
5331          exit(1);
5332      else
5333          exit(0);
5334  }
5335  static redisReply *sendScan(PORT_ULONGLONG *it) {
5336      redisReply *reply = redisCommand(context, &quot;SCAN %llu&quot;, *it);
5337      if(reply == NULL) {
5338          fprintf(stderr, &quot;\nI/O error\n&quot;);
5339          exit(1);
5340      } else if(reply-&gt;type == REDIS_REPLY_ERROR) {
5341          fprintf(stderr, &quot;SCAN error: %s\n&quot;, reply-&gt;str);
5342          exit(1);
5343      } else if(reply-&gt;type != REDIS_REPLY_ARRAY) {
5344          fprintf(stderr, &quot;Non ARRAY response from SCAN!\n&quot;);
5345          exit(1);
5346      } else if(reply-&gt;elements != 2) {
5347          fprintf(stderr, &quot;Invalid element count from SCAN!\n&quot;);
5348          exit(1);
5349      }
5350      assert(reply-&gt;element[0]-&gt;type == REDIS_REPLY_STRING);
5351      assert(reply-&gt;element[1]-&gt;type == REDIS_REPLY_ARRAY);
5352      *it = strtoull(reply-&gt;element[0]-&gt;str, NULL, 10);
5353      return reply;
5354  }
5355  static int getDbSize(void) {
5356      redisReply *reply;
5357      int size;
5358      reply = redisCommand(context, &quot;DBSIZE&quot;);
5359      if(reply == NULL || reply-&gt;type != REDIS_REPLY_INTEGER) {
5360          fprintf(stderr, &quot;Couldn&#x27;t determine DBSIZE!\n&quot;);
5361          exit(1);
5362      }
5363      size = reply-&gt;integer;
5364      freeReplyObject(reply);
5365      return size;
5366  }
5367  typedef struct {
5368      char *name;
5369      char *sizecmd;
5370      char *sizeunit;
5371      PORT_ULONGLONG biggest;
5372      PORT_ULONGLONG count;
5373      PORT_ULONGLONG totalsize;
5374      sds biggest_key;
5375  } typeinfo;
5376  typeinfo type_string = { &quot;string&quot;, &quot;STRLEN&quot;, &quot;bytes&quot; };
5377  typeinfo type_list = { &quot;list&quot;, &quot;LLEN&quot;, &quot;items&quot; };
5378  typeinfo type_set = { &quot;set&quot;, &quot;SCARD&quot;, &quot;members&quot; };
5379  typeinfo type_hash = { &quot;hash&quot;, &quot;HLEN&quot;, &quot;fields&quot; };
5380  typeinfo type_zset = { &quot;zset&quot;, &quot;ZCARD&quot;, &quot;members&quot; };
5381  typeinfo type_stream = { &quot;stream&quot;, &quot;XLEN&quot;, &quot;entries&quot; };
5382  typeinfo type_other = { &quot;other&quot;, NULL, &quot;?&quot; };
5383  static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {
5384      typeinfo *info = zmalloc(sizeof(typeinfo));
5385      *info = *type_template;
5386      info-&gt;name = sdsnew(name);
5387      dictAdd(types, info-&gt;name, info);
5388      return info;
5389  }
5390  void type_free(void* priv_data, void* val) {
5391      typeinfo *info = val;
5392      UNUSED(priv_data);
5393      if (info-&gt;biggest_key)
5394          sdsfree(info-&gt;biggest_key);
5395      sdsfree(info-&gt;name);
5396      zfree(info);
5397  }
5398  static dictType typeinfoDictType = {
5399      dictSdsHash,               &amp;bsol;* hash function */
5400      NULL,                      &amp;bsol;* key dup */
5401      NULL,                      &amp;bsol;* val dup */
5402      dictSdsKeyCompare,         &amp;bsol;* key compare */
5403      NULL,                      &amp;bsol;* key destructor (owned by the value)*/
5404      type_free                  &amp;bsol;* val destructor */
5405  };
5406  static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
5407      redisReply *reply;
5408      unsigned int i;
5409      for(i=0;i&lt;keys-&gt;elements;i++) {
5410          redisAppendCommand(context, &quot;TYPE %s&quot;, keys-&gt;element[i]-&gt;str);
5411      }
5412      for(i=0;i&lt;keys-&gt;elements;i++) {
5413          if(redisGetReply(context, (void**)&amp;reply)!=REDIS_OK) {
5414              fprintf(stderr, &quot;Error getting type for key &#x27;%s&#x27; (%d: %s)\n&quot;,
5415                  keys-&gt;element[i]-&gt;str, context-&gt;err, context-&gt;errstr);
5416              exit(1);
5417          } else if(reply-&gt;type != REDIS_REPLY_STATUS) {
5418              if(reply-&gt;type == REDIS_REPLY_ERROR) {
5419                  fprintf(stderr, &quot;TYPE returned an error: %s\n&quot;, reply-&gt;str);
5420              } else {
5421                  fprintf(stderr,
5422                      &quot;Invalid reply type (%d) for TYPE on key &#x27;%s&#x27;!\n&quot;,
5423                      reply-&gt;type, keys-&gt;element[i]-&gt;str);
5424              }
5425              exit(1);
5426          }
5427          sds typereply = sdsnew(reply-&gt;str);
5428          dictEntry *de = dictFind(types_dict, typereply);
5429          sdsfree(typereply);
5430          typeinfo *type = NULL;
5431          if (de)
5432              type = dictGetVal(de);
5433          else if (strcmp(reply-&gt;str, &quot;none&quot;)) &amp;bsol;* create new types for modules, (but not for deleted keys) */
5434              type = typeinfo_add(types_dict, reply-&gt;str, &amp;type_other);
5435          types[i] = type;
5436          freeReplyObject(reply);
5437      }
5438  }
5439  static void getKeySizes(redisReply *keys, typeinfo **types,
5440                          PORT_ULONGLONG *sizes, int memkeys,
5441                          unsigned memkeys_samples)
5442  {
5443      redisReply *reply;
5444      unsigned int i;
5445      for(i=0;i&lt;keys-&gt;elements;i++) {
5446          if(!types[i] || (!types[i]-&gt;sizecmd &amp;&amp; !memkeys))
5447              continue;
5448          if (!memkeys)
5449              redisAppendCommand(context, &quot;%s %s&quot;,
5450                  types[i]-&gt;sizecmd, keys-&gt;element[i]-&gt;str);
5451          else if (memkeys_samples==0)
5452              redisAppendCommand(context, &quot;%s %s %s&quot;,
5453                  &quot;MEMORY&quot;, &quot;USAGE&quot;, keys-&gt;element[i]-&gt;str);
5454          else
5455              redisAppendCommand(context, &quot;%s %s %s SAMPLES %u&quot;,
5456                  &quot;MEMORY&quot;, &quot;USAGE&quot;, keys-&gt;element[i]-&gt;str, memkeys_samples);
5457      }
5458      for(i=0;i&lt;keys-&gt;elements;i++) {
5459          if(!types[i] || (!types[i]-&gt;sizecmd &amp;&amp; !memkeys)) {
5460              sizes[i] = 0;
5461              continue;
5462          }
5463          if(redisGetReply(context, (void**)&amp;reply)!=REDIS_OK) {
5464              fprintf(stderr, &quot;Error getting size for key &#x27;%s&#x27; (%d: %s)\n&quot;,
5465                  keys-&gt;element[i]-&gt;str, context-&gt;err, context-&gt;errstr);
5466              exit(1);
5467          } else if(reply-&gt;type != REDIS_REPLY_INTEGER) {
5468              fprintf(stderr,
5469                  &quot;Warning:  %s on &#x27;%s&#x27; failed (may have changed type)\n&quot;,
5470                  !memkeys? types[i]-&gt;sizecmd: &quot;MEMORY USAGE&quot;,
5471                  keys-&gt;element[i]-&gt;str);
5472              sizes[i] = 0;
5473          } else {
5474              sizes[i] = reply-&gt;integer;
5475          }
5476          freeReplyObject(reply);
5477      }
5478  }
5479  static void findBigKeys(int memkeys, unsigned memkeys_samples) {
5480      PORT_ULONGLONG sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0;
5481      redisReply *reply, *keys;
5482      unsigned int arrsize=0, i;
5483      dictIterator *di;
5484      dictEntry *de;
5485      typeinfo **types = NULL;
5486      double pct;
5487      dict *types_dict = dictCreate(&amp;typeinfoDictType, NULL);
5488      typeinfo_add(types_dict, &quot;string&quot;, &amp;type_string);
5489      typeinfo_add(types_dict, &quot;list&quot;, &amp;type_list);
5490      typeinfo_add(types_dict, &quot;set&quot;, &amp;type_set);
5491      typeinfo_add(types_dict, &quot;hash&quot;, &amp;type_hash);
5492      typeinfo_add(types_dict, &quot;zset&quot;, &amp;type_zset);
5493      typeinfo_add(types_dict, &quot;stream&quot;, &amp;type_stream);
5494      total_keys = getDbSize();
5495      printf(&quot;\n# Scanning the entire keyspace to find biggest keys as well as\n&quot;);
5496      printf(&quot;# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n&quot;);
5497      printf(&quot;# per 100 SCAN commands (not usually needed).\n\n&quot;);
5498      do {
5499          pct = 100 * (double)sampled/total_keys;
5500          reply = sendScan(&amp;it);
5501          keys  = reply-&gt;element[1];
5502          if(keys-&gt;elements &gt; arrsize) {
5503              types = zrealloc(types, sizeof(typeinfo*)*keys-&gt;elements);
5504              sizes = zrealloc(sizes, sizeof(PORT_ULONGLONG)*keys-&gt;elements);
5505              if(!types || !sizes) {
5506                  fprintf(stderr, &quot;Failed to allocate storage for keys!\n&quot;);
5507                  exit(1);
5508              }
5509              arrsize = keys-&gt;elements;
5510          }
5511          getKeyTypes(types_dict, keys, types);
5512          getKeySizes(keys, types, sizes, memkeys, memkeys_samples);
5513          for(i=0;i&lt;keys-&gt;elements;i++) {
5514              typeinfo *type = types[i];
5515              if(!type)
5516                  continue;
5517              type-&gt;totalsize += sizes[i];
5518              type-&gt;count++;
5519              totlen += keys-&gt;element[i]-&gt;len;
5520              sampled++;
5521              if(type-&gt;biggest&lt;sizes[i]) {
5522                  printf(
5523                     &quot;[%05.2f%%] Biggest %-6s found so far &#x27;%s&#x27; with %llu %s\n&quot;,
5524                     pct, type-&gt;name, keys-&gt;element[i]-&gt;str, sizes[i],
5525                     !memkeys? type-&gt;sizeunit: &quot;bytes&quot;);
5526                  if (type-&gt;biggest_key)
5527                      sdsfree(type-&gt;biggest_key);
5528                  type-&gt;biggest_key = sdsnew(keys-&gt;element[i]-&gt;str);
5529                  if(!type-&gt;biggest_key) {
5530                      fprintf(stderr, &quot;Failed to allocate memory for key!\n&quot;);
5531                      exit(1);
5532                  }
5533                  type-&gt;biggest = sizes[i];
5534              }
5535              if(sampled % 1000000 == 0) {
5536                  printf(&quot;[%05.2f%%] Sampled %llu keys so far\n&quot;, pct, sampled);
5537              }
5538          }
5539          if(sampled &amp;&amp; (sampled %100) == 0 &amp;&amp; config.interval) {
5540              usleep(config.interval);
5541          }
5542          freeReplyObject(reply);
5543      } while(it != 0);
5544      if(types) zfree(types);
5545      if(sizes) zfree(sizes);
5546      printf(&quot;\n-------- summary -------\n\n&quot;);
5547      printf(&quot;Sampled %llu keys in the keyspace!\n&quot;, sampled);
5548      printf(&quot;Total key length in bytes is %llu (avg len %.2f)\n\n&quot;,
5549         totlen, totlen ? (double)totlen/sampled : 0);
5550      di = dictGetIterator(types_dict);
5551      while ((de = dictNext(di))) {
5552          typeinfo *type = dictGetVal(de);
5553          if(type-&gt;biggest_key) {
5554              printf(&quot;Biggest %6s found &#x27;%s&#x27; has %llu %s\n&quot;, type-&gt;name, type-&gt;biggest_key,
5555                 type-&gt;biggest, !memkeys? type-&gt;sizeunit: &quot;bytes&quot;);
5556          }
5557      }
5558      dictReleaseIterator(di);
5559      printf(&quot;\n&quot;);
5560      di = dictGetIterator(types_dict);
5561      while ((de = dictNext(di))) {
5562          typeinfo *type = dictGetVal(de);
5563          printf(&quot;%llu %ss with %llu %s (%05.2f%% of keys, avg size %.2f)\n&quot;,
5564             type-&gt;count, type-&gt;name, type-&gt;totalsize, !memkeys? type-&gt;sizeunit: &quot;bytes&quot;,
5565             sampled ? 100 * (double)type-&gt;count/sampled : 0,
5566             type-&gt;count ? (double)type-&gt;totalsize/type-&gt;count : 0);
5567      }
5568      dictReleaseIterator(di);
5569      dictRelease(types_dict);
5570      exit(0);
5571  }
5572  static void getKeyFreqs(redisReply *keys, PORT_ULONGLONG *freqs) {
5573      redisReply *reply;
5574      unsigned int i;
5575      for(i=0;i&lt;keys-&gt;elements;i++) {
5576          redisAppendCommand(context, &quot;OBJECT freq %s&quot;, keys-&gt;element[i]-&gt;str);
5577      }
5578      for(i=0;i&lt;keys-&gt;elements;i++) {
5579          if(redisGetReply(context, (void**)&amp;reply)!=REDIS_OK) {
5580              fprintf(stderr, &quot;Error getting freq for key &#x27;%s&#x27; (%d: %s)\n&quot;,
5581                  keys-&gt;element[i]-&gt;str, context-&gt;err, context-&gt;errstr);
5582              exit(1);
5583          } else if(reply-&gt;type != REDIS_REPLY_INTEGER) {
5584              if(reply-&gt;type == REDIS_REPLY_ERROR) {
5585                  fprintf(stderr, &quot;Error: %s\n&quot;, reply-&gt;str);
5586                  exit(1);
5587              } else {
5588                  fprintf(stderr, &quot;Warning: OBJECT freq on &#x27;%s&#x27; failed (may have been deleted)\n&quot;, keys-&gt;element[i]-&gt;str);
5589                  freqs[i] = 0;
5590              }
5591          } else {
5592              freqs[i] = reply-&gt;integer;
5593          }
5594          freeReplyObject(reply);
5595      }
5596  }
5597  #define HOTKEYS_SAMPLE 16
5598  static void findHotKeys(void) {
5599      redisReply *keys, *reply;
5600      PORT_ULONGLONG counters[HOTKEYS_SAMPLE] = {0};
5601      sds hotkeys[HOTKEYS_SAMPLE] = {NULL};
5602      PORT_ULONGLONG sampled = 0, total_keys, *freqs = NULL, it = 0;
5603      unsigned int arrsize = 0, i, k;
5604      double pct;
5605      total_keys = getDbSize();
5606      printf(&quot;\n# Scanning the entire keyspace to find hot keys as well as\n&quot;);
5607      printf(&quot;# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n&quot;);
5608      printf(&quot;# per 100 SCAN commands (not usually needed).\n\n&quot;);
5609      do {
5610          pct = 100 * (double)sampled/total_keys;
5611          reply = sendScan(&amp;it);
5612          keys  = reply-&gt;element[1];
5613          if(keys-&gt;elements &gt; arrsize) {
5614              freqs = zrealloc(freqs, sizeof(PORT_ULONGLONG)*keys-&gt;elements);
5615              if(!freqs) {
5616                  fprintf(stderr, &quot;Failed to allocate storage for keys!\n&quot;);
5617                  exit(1);
5618              }
5619              arrsize = keys-&gt;elements;
5620          }
5621          getKeyFreqs(keys, freqs);
5622          for(i=0;i&lt;keys-&gt;elements;i++) {
5623              sampled++;
5624              if(sampled % 1000000 == 0) {
5625                  printf(&quot;[%05.2f%%] Sampled %llu keys so far\n&quot;, pct, sampled);
5626              }
5627              k = 0;
5628              while (k &lt; HOTKEYS_SAMPLE &amp;&amp; freqs[i] &gt; counters[k]) k++;
5629              if (k == 0) continue;
5630              k--;
5631              if (k == 0 || counters[k] == 0) {
5632                  sdsfree(hotkeys[k]);
5633              } else {
5634                  sdsfree(hotkeys[0]);
5635                  memmove(counters,counters+1,sizeof(counters[0])*k);
5636                  memmove(hotkeys,hotkeys+1,sizeof(hotkeys[0])*k);
5637              }
5638              counters[k] = freqs[i];
5639              hotkeys[k] = sdsnew(keys-&gt;element[i]-&gt;str);
5640              printf(
5641                 &quot;[%05.2f%%] Hot key &#x27;%s&#x27; found so far with counter %llu\n&quot;,
5642                 pct, keys-&gt;element[i]-&gt;str, freqs[i]);
5643          }
5644          if(sampled &amp;&amp; (sampled %100) == 0 &amp;&amp; config.interval) {
5645              usleep(config.interval);
5646          }
5647          freeReplyObject(reply);
5648      } while(it != 0);
5649      if (freqs) zfree(freqs);
5650      printf(&quot;\n-------- summary -------\n\n&quot;);
5651      printf(&quot;Sampled %llu keys in the keyspace!\n&quot;, sampled);
5652      for (i=1; i&lt;= HOTKEYS_SAMPLE; i++) {
5653          k = HOTKEYS_SAMPLE - i;
5654          if(counters[k]&gt;0) {
5655              printf(&quot;hot key found with counter: %llu\tkeyname: %s\n&quot;, counters[k], hotkeys[k]);
5656              sdsfree(hotkeys[k]);
5657          }
5658      }
5659      exit(0);
5660  }
5661  static char *getInfoField(char *info, char *field) {
5662      char *p = strstr(info,field);
5663      char *n1, *n2;
5664      char *result;
5665      if (!p) return NULL;
5666      p += strlen(field)+1;
5667      n1 = strchr(p,&#x27;\r&#x27;);
5668      n2 = strchr(p,&#x27;,&#x27;);
5669      if (n2 &amp;&amp; n2 &lt; n1) n1 = n2;
5670      result = zmalloc(sizeof(char)*(n1-p)+1);
5671      memcpy(result,p,(n1-p));
5672      result[n1-p] = &#x27;\0&#x27;;
5673      return result;
5674  }
5675  static PORT_LONG getLongInfoField(char *info, char *field) {
5676      char *value = getInfoField(info,field);
5677      PORT_LONG l;
5678      if (!value) return PORT_LONG_MIN;
5679      l = strtol(value,NULL,10);
5680      zfree(value);
5681      return l;
5682  }
5683  void bytesToHuman(char *s, PORT_LONGLONG n) {
5684      double d;
5685      if (n &lt; 0) {
5686          *s = &#x27;-&#x27;;
5687          s++;
5688          n = -n;
5689      }
5690      if (n &lt; 1024) {
5691          sprintf(s,&quot;%lldB&quot;,n);
5692          return;
5693      } else if (n &lt; (1024*1024)) {
5694          d = (double)n/(1024);
5695          sprintf(s,&quot;%.2fK&quot;,d);
5696      } else if (n &lt; (1024LL*1024*1024)) {
5697          d = (double)n/((double)1024*1024);
5698          sprintf(s,&quot;%.2fM&quot;,d);
5699      } else if (n &lt; (1024LL*1024*1024*1024)) {
5700          d = (double)n/(1024LL*1024*1024);
5701          sprintf(s,&quot;%.2fG&quot;,d);
5702      }
5703  }
5704  static void statMode(void) {
5705      redisReply *reply;
5706      PORT_LONG aux, requests = 0;
5707      int i = 0;
5708      while(1) {
5709          char buf[64];
5710          int j;
5711          reply = reconnectingRedisCommand(context,&quot;INFO&quot;);
5712          if (reply-&gt;type == REDIS_REPLY_ERROR) {
5713              printf(&quot;ERROR: %s\n&quot;, reply-&gt;str);
5714              exit(1);
5715          }
5716          if ((i++ % 20) == 0) {
5717              printf(
5718  &quot;------- data ------ --------------------- load -------------------- - child -\n&quot;
5719  &quot;keys       mem      clients blocked requests            connections          \n&quot;);
5720          }
5721          aux = 0;
5722          for (j = 0; j &lt; 20; j++) {
5723              PORT_LONG k;
5724              sprintf(buf,&quot;db%d:keys&quot;,j);
5725              k = getLongInfoField(reply-&gt;str,buf);
5726              if (k == PORT_LONG_MIN) continue;
5727              aux += k;
5728          }
5729          sprintf(buf,&quot;%Id&quot;,aux);                                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5730          printf(&quot;%-11s&quot;,buf);
5731          aux = getLongInfoField(reply-&gt;str,&quot;used_memory&quot;);
5732          bytesToHuman(buf,aux);
5733          printf(&quot;%-8s&quot;,buf);
5734          aux = getLongInfoField(reply-&gt;str,&quot;connected_clients&quot;);
5735          sprintf(buf,&quot;%Id&quot;,aux);                                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5736          printf(&quot; %-8s&quot;,buf);
5737          aux = getLongInfoField(reply-&gt;str,&quot;blocked_clients&quot;);
5738          sprintf(buf,&quot;%Id&quot;,aux);                                      WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5739          printf(&quot;%-8s&quot;,buf);
5740          aux = getLongInfoField(reply-&gt;str,&quot;total_commands_processed&quot;);
5741          sprintf(buf,&quot;%Id (+%Id)&quot;,aux,requests == 0 ? 0 : aux-requests);  WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5742          printf(&quot;%-19s&quot;,buf);
5743          requests = aux;
5744          aux = getLongInfoField(reply-&gt;str,&quot;total_connections_received&quot;);
5745          sprintf(buf,&quot;%Id&quot;,aux);                                       WIN_PORT_FIX &amp;bsol;* %ld -&gt; %Id */
5746          printf(&quot; %-12s&quot;,buf);
5747          aux = getLongInfoField(reply-&gt;str,&quot;bgsave_in_progress&quot;);
5748          aux |= getLongInfoField(reply-&gt;str,&quot;aof_rewrite_in_progress&quot;) &lt;&lt; 1;
5749          aux |= getLongInfoField(reply-&gt;str,&quot;loading&quot;) &lt;&lt; 2;
5750          switch(aux) {
5751          case 0: break;
5752          case 1:
5753              printf(&quot;SAVE&quot;);
5754              break;
5755          case 2:
5756              printf(&quot;AOF&quot;);
5757              break;
5758          case 3:
5759              printf(&quot;SAVE+AOF&quot;);
5760              break;
5761          case 4:
5762              printf(&quot;LOAD&quot;);
5763              break;
5764          }
5765          printf(&quot;\n&quot;);
5766          freeReplyObject(reply);
5767          usleep(config.interval);
5768      }
5769  }
5770  static void scanMode(void) {
5771      redisReply *reply;
5772      PORT_ULONGLONG cur = 0;
5773      do {
5774          if (config.pattern)
5775              reply = redisCommand(context,&quot;SCAN %llu MATCH %s&quot;,
5776                  cur,config.pattern);
5777          else
5778              reply = redisCommand(context,&quot;SCAN %llu&quot;,cur);
5779          if (reply == NULL) {
5780              printf(&quot;I/O error\n&quot;);
5781              exit(1);
5782          } else if (reply-&gt;type == REDIS_REPLY_ERROR) {
5783              printf(&quot;ERROR: %s\n&quot;, reply-&gt;str);
5784              exit(1);
5785          } else {
5786              unsigned int j;
5787              cur = strtoull(reply-&gt;element[0]-&gt;str,NULL,10);
5788              for (j = 0; j &lt; reply-&gt;element[1]-&gt;elements; j++)
5789                  printf(&quot;%s\n&quot;, reply-&gt;element[1]-&gt;element[j]-&gt;str);
5790          }
5791          freeReplyObject(reply);
5792      } while(cur != 0);
5793      exit(0);
5794  }
5795  PORT_LONGLONG powerLawRand(PORT_LONGLONG min, PORT_LONGLONG max, double alpha) {
5796      double pl, r;
5797      max += 1;
5798      r = ((double)rand()) / RAND_MAX;
5799      pl = pow(
5800          ((pow((double)max,alpha+1) - pow((double)min,alpha+1))*r + pow((double)min,alpha+1)), WIN_PORT_FIX &amp;bsol;* cast (double) */
5801          (1.0/(alpha+1)));
5802      return (max-1-(PORT_LONGLONG)pl)+min;
5803  }
5804  void LRUTestGenKey(char *buf, size_t buflen) {
5805      snprintf(buf, buflen, &quot;lru:%lld&quot;,
5806          powerLawRand(1, config.lru_test_sample_size, 6.2));
5807  }
5808  #define LRU_CYCLE_PERIOD 1000 &amp;bsol;* 1000 milliseconds. */
5809  #define LRU_CYCLE_PIPELINE_SIZE 250
5810  static void LRUTestMode(void) {
5811      redisReply *reply;
5812      char key[128];
5813      PORT_LONGLONG start_cycle;
5814      int j;
5815      srand((unsigned int)(time(NULL)^getpid()));                                   WIN_PORT_FIX &amp;bsol;* cast (unsigned int) */
5816      while(1) {
5817          start_cycle = mstime();
5818          PORT_LONGLONG hits = 0, misses = 0;
5819          while(mstime() - start_cycle &lt; 1000) {
5820              for (j = 0; j &lt; LRU_CYCLE_PIPELINE_SIZE; j++) {
5821                  char val[6];
5822                  val[5] = &#x27;\0&#x27;;
5823                  for (int i = 0; i &lt; 5; i++) val[i] = &#x27;A&#x27;+rand()%(&#x27;z&#x27;-&#x27;A&#x27;);
5824                  LRUTestGenKey(key,sizeof(key));
5825                  redisAppendCommand(context, &quot;SET %s %s&quot;,key,val);
5826              }
5827              for (j = 0; j &lt; LRU_CYCLE_PIPELINE_SIZE; j++)
5828                  redisGetReply(context, (void**)&amp;reply);
5829              for (j = 0; j &lt; LRU_CYCLE_PIPELINE_SIZE; j++) {
5830                  LRUTestGenKey(key,sizeof(key));
5831                  redisAppendCommand(context, &quot;GET %s&quot;,key);
5832              }
5833              for (j = 0; j &lt; LRU_CYCLE_PIPELINE_SIZE; j++) {
5834                  if (redisGetReply(context, (void**)&amp;reply) == REDIS_OK) {
5835                      switch(reply-&gt;type) {
5836                          case REDIS_REPLY_ERROR:
5837                              printf(&quot;%s\n&quot;, reply-&gt;str);
5838                              break;
5839                          case REDIS_REPLY_NIL:
5840                              misses++;
5841                              break;
5842                          default:
5843                              hits++;
5844                              break;
5845                      }
5846                  }
5847              }
5848              if (context-&gt;err) {
5849                  fprintf(stderr,&quot;I/O error during LRU test\n&quot;);
5850                  exit(1);
5851              }
5852          }
5853          printf(
5854              &quot;%lld Gets/sec | Hits: %lld (%.2f%%) | Misses: %lld (%.2f%%)\n&quot;,
5855              hits+misses,
5856              hits, (double)hits/(hits+misses)*100,
5857              misses, (double)misses/(hits+misses)*100);
5858      }
5859      exit(0);
5860  }
5861  PORT_ULONG compute_something_fast(void) {
5862      unsigned char s[256], i, j, t;
5863      int count = 1000, k;
5864      PORT_ULONG output = 0;
5865      for (k = 0; k &lt; 256; k++) s[k] = k;
5866      i = 0;
5867      j = 0;
5868      while(count--) {
5869          i++;
5870          j = j + s[i];
5871          t = s[i];
5872          s[i] = s[j];
5873          s[j] = t;
5874          output += s[(s[i]+s[j])&amp;255];
5875      }
5876      return output;
5877  }
5878  static void intrinsicLatencyModeStop(int s) {
5879      UNUSED(s);
5880      force_cancel_loop = 1;
5881  }
5882  static void intrinsicLatencyMode(void) {
5883      PORT_LONGLONG test_end, run_time, max_latency = 0, runs = 0;
5884      run_time = ((PORT_LONGLONG)config.intrinsic_latency_duration)*1000000;
5885      test_end = ustime() + run_time;
5886      signal(SIGINT, intrinsicLatencyModeStop);
5887      while(1) {
5888          PORT_LONGLONG start, end, latency;
5889          start = ustime();
5890          compute_something_fast();
5891          end = ustime();
5892          latency = end-start;
5893          runs++;
5894          if (latency &lt;= 0) continue;
5895          if (latency &gt; max_latency) {
5896              max_latency = latency;
5897              printf(&quot;Max latency so far: %lld microseconds.\n&quot;, max_latency);
5898          }
5899          double avg_us = (double)run_time/runs;
5900          double avg_ns = avg_us * 1e3;
5901          if (force_cancel_loop || end &gt; test_end) {
5902              printf(&quot;\n%lld total runs &quot;
5903                  &quot;(avg latency: &quot;
5904                  &quot;%.4f microseconds / %.2f nanoseconds per run).\n&quot;,
5905                  runs, avg_us, avg_ns);
5906              printf(&quot;Worst run took %.0fx longer than the average latency.\n&quot;,
5907                  max_latency / avg_us);
5908              exit(0);
5909          }
5910      }
5911  }
5912  int main(int argc, char **argv) {
5913      int firstarg;
5914  #ifdef _WIN32
5915      pthread_mutex_init(&amp;used_memory_mutex, NULL);
5916  #endif
5917      config.hostip = sdsnew(&quot;127.0.0.1&quot;);
5918      config.hostport = 6379;
5919      config.hostsocket = NULL;
5920      config.repeat = 1;
5921      config.interval = 0;
5922      config.dbnum = 0;
5923      config.interactive = 0;
5924      config.shutdown = 0;
5925      config.monitor_mode = 0;
5926      config.pubsub_mode = 0;
5927      config.latency_mode = 0;
5928      config.latency_dist_mode = 0;
5929      config.latency_history = 0;
5930      config.lru_test_mode = 0;
5931      config.lru_test_sample_size = 0;
5932      config.cluster_mode = 0;
5933      config.slave_mode = 0;
5934      config.getrdb_mode = 0;
5935      config.stat_mode = 0;
5936      config.scan_mode = 0;
5937      config.intrinsic_latency_mode = 0;
5938      config.pattern = NULL;
5939      config.rdb_filename = NULL;
5940      config.pipe_mode = 0;
5941      config.pipe_timeout = REDIS_CLI_DEFAULT_PIPE_TIMEOUT;
5942      config.bigkeys = 0;
5943      config.hotkeys = 0;
5944      config.stdinarg = 0;
5945      config.auth = NULL;
5946      config.eval = NULL;
5947      config.eval_ldb = 0;
5948      config.eval_ldb_end = 0;
5949      config.eval_ldb_sync = 0;
5950      config.enable_ldb_on_eval = 0;
5951      config.last_cmd_type = -1;
5952      config.verbose = 0;
5953      config.no_auth_warning = 0;
5954      config.cluster_manager_command.name = NULL;
5955      config.cluster_manager_command.argc = 0;
5956      config.cluster_manager_command.argv = NULL;
5957      config.cluster_manager_command.flags = 0;
5958      config.cluster_manager_command.replicas = 0;
5959      config.cluster_manager_command.from = NULL;
5960      config.cluster_manager_command.to = NULL;
5961      config.cluster_manager_command.weight = NULL;
5962      config.cluster_manager_command.weight_argc = 0;
5963      config.cluster_manager_command.slots = 0;
5964      config.cluster_manager_command.timeout = CLUSTER_MANAGER_MIGRATE_TIMEOUT;
5965      config.cluster_manager_command.pipeline = CLUSTER_MANAGER_MIGRATE_PIPELINE;
5966      config.cluster_manager_command.threshold =
5967          CLUSTER_MANAGER_REBALANCE_THRESHOLD;
5968      pref.hints = 1;
5969      spectrum_palette = spectrum_palette_color;
5970      spectrum_palette_size = spectrum_palette_color_size;
5971      if (!isatty(fileno(stdout)) &amp;&amp; (getenv(&quot;FAKETTY&quot;) == NULL))
5972          config.output = OUTPUT_RAW;
5973      else
5974          config.output = OUTPUT_STANDARD;
5975      config.mb_delim = sdsnew(&quot;\n&quot;);
5976      firstarg = parseOptions(argc,argv);
5977      argc -= firstarg;
5978      argv += firstarg;
5979      parseEnv();
5980      if (CLUSTER_MANAGER_MODE()) {
5981          clusterManagerCommandProc *proc = validateClusterManagerCommand();
5982          if (!proc) {
5983              sdsfree(config.hostip);
5984              sdsfree(config.mb_delim);
5985              exit(1);
5986          }
5987          clusterManagerMode(proc);
5988      }
5989      if (config.latency_mode) {
5990          if (cliConnect(0) == REDIS_ERR) exit(1);
5991          latencyMode();
5992      }
5993      if (config.latency_dist_mode) {
5994          if (cliConnect(0) == REDIS_ERR) exit(1);
5995          latencyDistMode();
5996      }
5997      if (config.slave_mode) {
5998          if (cliConnect(0) == REDIS_ERR) exit(1);
5999          slaveMode();
6000      }
6001      if (config.getrdb_mode) {
6002          if (cliConnect(0) == REDIS_ERR) exit(1);
6003          getRDB();
6004      }
6005      if (config.pipe_mode) {
6006          if (cliConnect(0) == REDIS_ERR) exit(1);
6007          pipeMode();
6008      }
6009      if (config.bigkeys) {
6010          if (cliConnect(0) == REDIS_ERR) exit(1);
6011          findBigKeys(0, 0);
6012      }
6013      if (config.memkeys) {
6014          if (cliConnect(0) == REDIS_ERR) exit(1);
6015          findBigKeys(1, config.memkeys_samples);
6016      }
6017      if (config.hotkeys) {
6018          if (cliConnect(0) == REDIS_ERR) exit(1);
6019          findHotKeys();
6020      }
6021      if (config.stat_mode) {
6022          if (cliConnect(0) == REDIS_ERR) exit(1);
6023          if (config.interval == 0) config.interval = 1000000;
6024          statMode();
6025      }
6026      if (config.scan_mode) {
6027          if (cliConnect(0) == REDIS_ERR) exit(1);
6028          scanMode();
6029      }
6030      if (config.lru_test_mode) {
6031          if (cliConnect(0) == REDIS_ERR) exit(1);
6032          LRUTestMode();
6033      }
6034      if (config.intrinsic_latency_mode) intrinsicLatencyMode();
6035      if (argc == 0 &amp;&amp; !config.eval) {
6036          signal(SIGPIPE, SIG_IGN);
6037          cliConnect(0);
6038          repl();
6039      }
6040      if (cliConnect(0) != REDIS_OK) exit(1);
6041      if (config.eval) {
6042          return evalMode(argc,argv);
6043      } else {
6044          return noninteractive(argc,convertToSds(argc,argv));
6045      }
6046  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-cli.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-cli.c</div>
                </div>
                <div class="column column_space"><pre><code>1785      listIter li;
1786      listNode *ln;
1787      if (cluster_manager.nodes != NULL) {
1788          listRewind(cluster_manager.nodes,&amp;li);
1789          while ((ln = listNext(&amp;li)) != NULL) {
</pre></code></div>
                <div class="column column_space"><pre><code>2840      listIter li;
2841      listNode *ln;
2842      if (cluster_manager.nodes != NULL) {
2843          listRewind(cluster_manager.nodes, &amp;li);
2844          while ((ln = listNext(&amp;li)) != NULL)
2845              freeClusterManagerNode((clusterManagerNode *) ln-&gt;value);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    