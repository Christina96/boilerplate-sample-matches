<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for vips2tiff.c &amp; dzsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for vips2tiff.c &amp; dzsave.c
      </h3>
<h1 align="center">
        5.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>vips2tiff.c (6.364429%)<th>dzsave.c (5.559787%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1709-1782)<td><a href="#" name="0">(1735-1818)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1842-1900)<td><a href="#" name="1">(1906-1964)</a><td align="center"><font color="#b90000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1793-1824)<td><a href="#" name="2">(1829-1864)</a><td align="center"><font color="#7b0000">16</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vips2tiff.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#ifdef HAVE_TIFF
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include "pforeign.h"
#include "tiff.h"
#define MAX_ALPHA (64)
#define JP2K_LOSSY 33004
static int wtiff_we_compress[] = {
	JP2K_LOSSY
};
typedef struct _Layer Layer;
typedef struct _Wtiff Wtiff;
struct _Layer {
	Wtiff *wtiff;			
	char *lname;			
	void *buf;
	size_t len;
	int width, height;			int sub;				TIFF *tif;			
	VipsImage *image;
	int y;
	int write_y;
	VipsRegion *strip;			VipsRegion *copy;		
	Layer *below;				Layer *above;			};
struct _Wtiff {
	VipsImage *input;		
	VipsImage *ready;
	char *filename;			
	void **obuf;
	size_t *olen; 
	Layer *layer;				VipsPel *tbuf;				int tls;			
	int compression;			int Q;					int predictor;				int tile;				int tilew, tileh;			int pyramid;				int bitdepth;                   	int miniswhite;			        int resunit;                            double xres;                   	        double yres;                   		const char *profile;			int bigtiff;				int rgbjpeg;				int properties;				int strip;				VipsRegionShrink region_shrink; 	int level;				gboolean lossless;			VipsForeignDzDepth depth;		gboolean subifd;			gboolean premultiply;		
	gboolean toilet_roll;
	int page_height;
	int page_number;
	int n_pages;
	int image_height;
	gboolean we_compress;
};
static int
embed_profile_file( TIFF *tif, const char *profile )
{
	VipsBlob *blob;
	if( vips_profile_load( profile, &amp;blob, NULL ) )
		return( -1 );
	if( blob ) {
		size_t length;
		const void *data = vips_blob_get( blob, &amp;length );
		TIFFSetField( tif, TIFFTAG_ICCPROFILE, length, data );
#ifdef DEBUG
		printf( "vips2tiff: attached profile \"%s\"\n", profile );
		vips_area_unref( (VipsArea *) blob );
	}
	return( 0 );
}
static int
embed_profile_meta( TIFF *tif, VipsImage *im )
{
	const void *data;
	size_t length;
	if( vips_image_get_blob( im, VIPS_META_ICC_NAME, &amp;data, &amp;length ) )
		return( -1 );
	TIFFSetField( tif, TIFFTAG_ICCPROFILE, length, data );
#ifdef DEBUG
	printf( "vips2tiff: attached profile from meta\n" );
	return( 0 );
}
static void
wtiff_layer_init( Wtiff *wtiff, Layer **layer, Layer *above, 
	int width, int height )
{
	if( !*layer ) {
		*layer = VIPS_NEW( wtiff-&gt;ready, Layer );
		(*layer)-&gt;wtiff = wtiff;
		(*layer)-&gt;width = width;
		(*layer)-&gt;height = height; 
		if( !above )
			(*layer)-&gt;sub = 1;	
		else
			(*layer)-&gt;sub = above-&gt;sub * 2;
		(*layer)-&gt;lname = NULL;
		(*layer)-&gt;buf = NULL;
		(*layer)-&gt;len = 0;
		(*layer)-&gt;tif = NULL;
		(*layer)-&gt;image = NULL;
		(*layer)-&gt;write_y = 0;
		(*layer)-&gt;y = 0;
		(*layer)-&gt;strip = NULL;
		(*layer)-&gt;copy = NULL;
		(*layer)-&gt;below = NULL;
		(*layer)-&gt;above = above;
		if( wtiff-&gt;filename ) { 
			if( !above ) 
				(*layer)-&gt;lname = vips_strdup( 
					VIPS_OBJECT( wtiff-&gt;ready ),
					wtiff-&gt;filename );
			else {
				char *lname;
				lname = vips__temp_name( "%s.tif" );
				(*layer)-&gt;lname = vips_strdup( 
					VIPS_OBJECT( wtiff-&gt;ready ),
					lname );
				g_free( lname );
			}
		}
	}
	if( wtiff-&gt;pyramid ) {
		int limitw, limith;
		switch( wtiff-&gt;depth ) {
		case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
			limitw = limith = 1;
			break;
		case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
			limitw = wtiff-&gt;tilew;
			limith = wtiff-&gt;tileh;
			break;
		case VIPS_FOREIGN_DZ_DEPTH_ONE:
			limitw = wtiff-&gt;ready-&gt;Xsize;
			limith = wtiff-&gt;ready-&gt;Ysize;
			break;
		default:
			g_assert_not_reached();
		}
		if( ((*layer)-&gt;width &gt; limitw || 
			(*layer)-&gt;height &gt; limith) &amp;&amp; 
		 	(*layer)-&gt;width &gt; 1 &amp;&amp; 
		 	(*layer)-&gt;height &gt; 1 ) 
			wtiff_layer_init( wtiff, &amp;(*layer)-&gt;below, *layer, 
				width / 2, height / 2 );
	}
}
static int
wtiff_embed_profile( Wtiff *wtiff, TIFF *tif )
{
	if( wtiff-&gt;profile &amp;&amp;
		embed_profile_file( tif, wtiff-&gt;profile ) )
		return( -1 );
	if( !wtiff-&gt;profile &amp;&amp; 
		vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_ICC_NAME ) &amp;&amp;
		embed_profile_meta( tif, wtiff-&gt;ready ) )
		return( -1 );
	return( 0 );
}
static int
wtiff_embed_xmp( Wtiff *wtiff, TIFF *tif )
{
	const void *data;
	size_t size;
	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_XMP_NAME ) )
		return( 0 );
	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_XMP_NAME, 
		&amp;data, &amp;size ) )
		return( -1 );
	TIFFSetField( tif, TIFFTAG_XMLPACKET, size, data );
#ifdef DEBUG
	printf( "vips2tiff: attached XMP from meta\n" );
	return( 0 );
}
static int
wtiff_embed_iptc( Wtiff *wtiff, TIFF *tif )
{
	const void *data;
	size_t size;
	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_IPTC_NAME ) )
		return( 0 );
	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_IPTC_NAME, 
		&amp;data, &amp;size ) )
		return( -1 );
	if( size &amp; 3 ) {
		g_warning( "%s", _( "rounding up IPTC data length" ) );
		size /= 4;
		size += 1;
	}
	else
		size /= 4;
	TIFFSetField( tif, TIFFTAG_RICHTIFFIPTC, size, data );
#ifdef DEBUG
	printf( "vips2tiff: attached IPTC from meta\n" );
	return( 0 );
}
static int
wtiff_embed_photoshop( Wtiff *wtiff, TIFF *tif )
{
	const void *data;
	size_t size;
	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_PHOTOSHOP_NAME ) )
		return( 0 );
	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_PHOTOSHOP_NAME, 
		&amp;data, &amp;size ) )
		return( -1 );
	TIFFSetField( tif, TIFFTAG_PHOTOSHOP, size, data );
#ifdef DEBUG
	printf( "vips2tiff: attached photoshop data from meta\n" );
	return( 0 );
}
static int
wtiff_embed_imagedescription( Wtiff *wtiff, TIFF *tif )
{
	if( wtiff-&gt;properties ) {
		char *doc;
		if( !(doc = vips__xml_properties( wtiff-&gt;ready )) )
			return( -1 );
		TIFFSetField( tif, TIFFTAG_IMAGEDESCRIPTION, doc );
		g_free( doc );
	}
	else {
		const char *imagedescription;
		if( !vips_image_get_typeof( wtiff-&gt;ready,
			VIPS_META_IMAGEDESCRIPTION ) )
			return( 0 );
		if( vips_image_get_string( wtiff-&gt;ready,
			VIPS_META_IMAGEDESCRIPTION, &amp;imagedescription ) )
			return( -1 );
		TIFFSetField( tif, TIFFTAG_IMAGEDESCRIPTION, imagedescription );
	}
#ifdef DEBUG
	printf( "vips2tiff: attached imagedescription from meta\n" );
	return( 0 );
}
static int
wtiff_write_header( Wtiff *wtiff, Layer *layer )
{
	TIFF *tif = layer-&gt;tif;
	int i;
	int orientation; 
#ifdef DEBUG
	printf( "wtiff_write_header: sub %d, width %d, height %d\n",
		layer-&gt;sub, layer-&gt;width, layer-&gt;height );
	TIFFSetField( tif, TIFFTAG_IMAGEWIDTH, layer-&gt;width );
	TIFFSetField( tif, TIFFTAG_IMAGELENGTH, layer-&gt;height );
	TIFFSetField( tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );
	TIFFSetField( tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );
	TIFFSetField( tif, TIFFTAG_COMPRESSION, wtiff-&gt;compression );
	if( wtiff-&gt;compression == COMPRESSION_JPEG ) 
		TIFFSetField( tif, TIFFTAG_JPEGQUALITY, wtiff-&gt;Q );
#ifdef HAVE_TIFF_COMPRESSION_WEBP
	if( wtiff-&gt;compression == COMPRESSION_WEBP ) {
		TIFFSetField( tif, TIFFTAG_WEBP_LEVEL, wtiff-&gt;Q );
		TIFFSetField( tif, TIFFTAG_WEBP_LOSSLESS, wtiff-&gt;lossless );
	}
	if( wtiff-&gt;compression == COMPRESSION_ZSTD ) {
		TIFFSetField( tif, TIFFTAG_ZSTD_LEVEL, wtiff-&gt;level );
		if( wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
			TIFFSetField( tif, 
				TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
	}
	if( (wtiff-&gt;compression == COMPRESSION_ADOBE_DEFLATE ||
		wtiff-&gt;compression == COMPRESSION_LZW) &amp;&amp;
		wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
		TIFFSetField( tif, TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
	for( i = 0; i &lt; VIPS_NUMBER( wtiff_we_compress ); i++ )
		if( wtiff-&gt;compression == wtiff_we_compress[i] ) {
			wtiff-&gt;we_compress = TRUE;
			break;
		}
	TIFFSetField( tif, TIFFTAG_RESOLUTIONUNIT, wtiff-&gt;resunit );
	TIFFSetField( tif, TIFFTAG_XRESOLUTION, 
		VIPS_FCLIP( 0.01, wtiff-&gt;xres, 1000000 ) );
	TIFFSetField( tif, TIFFTAG_YRESOLUTION, 
		VIPS_FCLIP( 0.01, wtiff-&gt;yres, 1000000 ) );
	if( !wtiff-&gt;strip ) 
		if( wtiff_embed_profile( wtiff, tif ) ||
			wtiff_embed_xmp( wtiff, tif ) ||
			wtiff_embed_iptc( wtiff, tif ) ||
			wtiff_embed_photoshop( wtiff, tif ) ||
			wtiff_embed_imagedescription( wtiff, tif ) )
			return( -1 ); 
	if( vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_ORIENTATION ) &amp;&amp;
		!vips_image_get_int( wtiff-&gt;ready, 
			VIPS_META_ORIENTATION, &amp;orientation ) )
		TIFFSetField( tif, TIFFTAG_ORIENTATION, orientation );
	if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ ) {
		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 3 );
		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, 8 );
		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );
	}
	else if( wtiff-&gt;bitdepth == 1 || wtiff-&gt;bitdepth == 2 ||
                 wtiff-&gt;bitdepth == 4 ) {
		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 1 );
		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, wtiff-&gt;bitdepth );
		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC,
			wtiff-&gt;miniswhite ?
				PHOTOMETRIC_MINISWHITE :
				PHOTOMETRIC_MINISBLACK );
	}
	else {
		int photometric;
		int colour_bands;
		int alpha_bands;
		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 
			wtiff-&gt;ready-&gt;Bands );
		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, 
			vips_format_sizeof( wtiff-&gt;ready-&gt;BandFmt ) &lt;&lt; 3 );
		if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_B_W ||
			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_GREY16 ||
			wtiff-&gt;ready-&gt;Bands &lt; 3 ) { 
			photometric = wtiff-&gt;miniswhite ?
				PHOTOMETRIC_MINISWHITE :
				PHOTOMETRIC_MINISBLACK;
			colour_bands = 1;
		}
		else if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LAB || 
			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LABS ) {
			photometric = PHOTOMETRIC_CIELAB;
			colour_bands = 3;
		}
		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ ) { 
			double stonits;
			photometric = PHOTOMETRIC_LOGLUV;
			TIFFSetField( tif, 
				TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT );
			stonits = 1.0;
			if( vips_image_get_typeof( wtiff-&gt;ready, "stonits" ) )
				vips_image_get_double( wtiff-&gt;ready, 
					"stonits", &amp;stonits );
			TIFFSetField( tif, TIFFTAG_STONITS, stonits );
			colour_bands = 3;
		}
		else if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_CMYK &amp;&amp;
			wtiff-&gt;ready-&gt;Bands &gt;= 4 ) {
			photometric = PHOTOMETRIC_SEPARATED;
			TIFFSetField( tif, TIFFTAG_INKSET, INKSET_CMYK );
			colour_bands = 4;
		}
		else if( wtiff-&gt;compression == COMPRESSION_JPEG &amp;&amp;
			wtiff-&gt;ready-&gt;Bands == 3 &amp;&amp;
			wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR &amp;&amp;
			(!wtiff-&gt;rgbjpeg &amp;&amp; wtiff-&gt;Q &lt; 90) ) { 
			photometric = PHOTOMETRIC_YCBCR;
			TIFFSetField( tif, TIFFTAG_JPEGCOLORMODE, 
				JPEGCOLORMODE_RGB );
			colour_bands = 3;
		}
		else {
			photometric = PHOTOMETRIC_RGB;
			colour_bands = 3;
		}
		alpha_bands = VIPS_CLIP( 0, 
			wtiff-&gt;ready-&gt;Bands - colour_bands, MAX_ALPHA );
		if( alpha_bands &gt; 0 ) { 
			uint16 v[MAX_ALPHA];
			int i;
			for( i = 0; i &lt; alpha_bands; i++ )
				v[i] = i == 0 &amp;&amp; wtiff-&gt;premultiply ? 
					EXTRASAMPLE_ASSOCALPHA :
					EXTRASAMPLE_UNASSALPHA;
			TIFFSetField( tif, 
				TIFFTAG_EXTRASAMPLES, alpha_bands, v );
		}
		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC, photometric );
	}
	if( wtiff-&gt;tile ) {
		TIFFSetField( tif, TIFFTAG_TILEWIDTH, wtiff-&gt;tilew );
		TIFFSetField( tif, TIFFTAG_TILELENGTH, wtiff-&gt;tileh );
	}
	else
		TIFFSetField( tif, TIFFTAG_ROWSPERSTRIP, wtiff-&gt;tileh );
	if( layer-&gt;above ) 
		TIFFSetField( tif, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );
	if( wtiff-&gt;toilet_roll ) {
		TIFFSetField( tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE );
		TIFFSetField( tif, TIFFTAG_PAGENUMBER, 
			wtiff-&gt;page_number, wtiff-&gt;n_pages );
	}
	if( wtiff-&gt;input-&gt;Type != VIPS_INTERPRETATION_XYZ ) { 
		int format; 
		format = SAMPLEFORMAT_UINT;
		if( vips_band_format_isuint( wtiff-&gt;ready-&gt;BandFmt ) )
			format = SAMPLEFORMAT_UINT;
		else if( vips_band_format_isint( wtiff-&gt;ready-&gt;BandFmt ) )
			format = SAMPLEFORMAT_INT;
		else if( vips_band_format_isfloat( wtiff-&gt;ready-&gt;BandFmt ) )
			format = SAMPLEFORMAT_IEEEFP;
		else if( vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) )
			format = SAMPLEFORMAT_COMPLEXIEEEFP;
		TIFFSetField( tif, TIFFTAG_SAMPLEFORMAT, format );
	}
	return( 0 );
}
static int
wtiff_layer_rewind( Wtiff *wtiff, Layer *layer )
{
	VipsRect strip_size;
	strip_size.left = 0;
	strip_size.top = 0;
	strip_size.width = layer-&gt;image-&gt;Xsize;
	strip_size.height = wtiff-&gt;tileh;
	if( (strip_size.height &amp; 1) == 1 )
		strip_size.height += 1;
	if( vips_region_buffer( layer-&gt;strip, &amp;strip_size ) ) 
		return( -1 );
	layer-&gt;y = 0;
	layer-&gt;write_y = 0;
	return( 0 );
}
static int
wtiff_allocate_layers( Wtiff *wtiff )
{
	Layer *layer;
	g_assert( wtiff-&gt;layer );
	for( layer = wtiff-&gt;layer; layer; layer = layer-&gt;below ) {
		if( !layer-&gt;image ) {
			layer-&gt;image = vips_image_new();
			if( vips_image_pipelinev( layer-&gt;image, 
				VIPS_DEMAND_STYLE_ANY, wtiff-&gt;ready, NULL ) ) 
				return( -1 );
			layer-&gt;image-&gt;Xsize = layer-&gt;width;
			layer-&gt;image-&gt;Ysize = layer-&gt;height;
			layer-&gt;strip = vips_region_new( layer-&gt;image );
			layer-&gt;copy = vips_region_new( layer-&gt;image );
			vips__region_no_ownership( layer-&gt;strip );
			vips__region_no_ownership( layer-&gt;copy );
			if( layer-&gt;lname ) 
				layer-&gt;tif = vips__tiff_openout( 
					layer-&gt;lname, wtiff-&gt;bigtiff );
			else {
				layer-&gt;tif = vips__tiff_openout_buffer( 
					wtiff-&gt;ready, wtiff-&gt;bigtiff, 
					&amp;layer-&gt;buf, &amp;layer-&gt;len );
			}
			if( !layer-&gt;tif ) 
				return( -1 );
		}
		if( wtiff_layer_rewind( wtiff, layer ) )
			return( -1 ); 
		if( wtiff_write_header( wtiff, layer ) )  
			return( -1 );
	}
	if( !wtiff-&gt;tbuf ) { 
		if( wtiff-&gt;tile ) 
			wtiff-&gt;tbuf = vips_malloc( NULL, 
				TIFFTileSize( wtiff-&gt;layer-&gt;tif ) );
		else
			wtiff-&gt;tbuf = vips_malloc( NULL, 
				TIFFScanlineSize( wtiff-&gt;layer-&gt;tif ) );
		if( !wtiff-&gt;tbuf ) 
			return( -1 );
	}
	return( 0 );
}
static void
wtiff_delete_temps( Wtiff *wtiff )
{
	Layer *layer;
	if( wtiff-&gt;layer &amp;&amp;
		wtiff-&gt;layer-&gt;below )
		for( layer = wtiff-&gt;layer-&gt;below; layer; layer = layer-&gt;below ) 
			if( layer-&gt;lname ) {
#ifndef DEBUG
				unlink( layer-&gt;lname );
				VIPS_FREE( layer-&gt;buf );
#else
				printf( "wtiff_delete_temps: leaving %s\n", 
					layer-&gt;lname );
				layer-&gt;lname = NULL;
			}
}
static void
layer_free( Layer *layer )
{
	VIPS_UNREF( layer-&gt;strip );
	VIPS_UNREF( layer-&gt;copy );
	VIPS_UNREF( layer-&gt;image );
	VIPS_FREE( layer-&gt;buf );
	VIPS_FREEF( TIFFClose, layer-&gt;tif );
}
static void
layer_free_all( Layer *layer )
{
	if( layer-&gt;below ) 
		layer_free_all( layer-&gt;below );
	layer_free( layer );
}
static void
wtiff_free( Wtiff *wtiff )
{
	wtiff_delete_temps( wtiff );
	VIPS_UNREF( wtiff-&gt;ready );
	VIPS_FREE( wtiff-&gt;tbuf );
	VIPS_FREEF( layer_free_all, wtiff-&gt;layer );
	VIPS_FREE( wtiff-&gt;filename );
	VIPS_FREE( wtiff );
}
static int
get_compression( VipsForeignTiffCompression compression )
{
	switch( compression ) {
	case VIPS_FOREIGN_TIFF_COMPRESSION_NONE:
		return( COMPRESSION_NONE );
	case VIPS_FOREIGN_TIFF_COMPRESSION_JPEG:
		return( COMPRESSION_JPEG );
	case VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE:
		return( COMPRESSION_ADOBE_DEFLATE );
	case VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS:
		return( COMPRESSION_PACKBITS );
	case VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4:
		return( COMPRESSION_CCITTFAX4 );
	case VIPS_FOREIGN_TIFF_COMPRESSION_LZW:
		return( COMPRESSION_LZW );
#ifdef HAVE_TIFF_COMPRESSION_WEBP
	case VIPS_FOREIGN_TIFF_COMPRESSION_WEBP:
		return( COMPRESSION_WEBP );
	case VIPS_FOREIGN_TIFF_COMPRESSION_ZSTD:
		return( COMPRESSION_ZSTD );
	case VIPS_FOREIGN_TIFF_COMPRESSION_JP2K:
		return( JP2K_LOSSY );
	default:
		return( COMPRESSION_NONE );
	}
}
static int
get_resunit( VipsForeignTiffResunit resunit )
{
	switch( resunit ) {
	case VIPS_FOREIGN_TIFF_RESUNIT_CM:
		return( RESUNIT_CENTIMETER );
	case VIPS_FOREIGN_TIFF_RESUNIT_INCH:
		return( RESUNIT_INCH );
	default:
		g_assert_not_reached();
	}
	return( -1 );
}
static int
ready_to_write( Wtiff *wtiff )
{
	VipsImage *input;
	VipsImage *x;
	input = wtiff-&gt;input;
	g_object_ref( input );
	if( vips_check_coding_known( "vips2tiff", input ) ) {
		VIPS_UNREF( input );
		return( -1 );
	}
	if( wtiff-&gt;premultiply &amp;&amp;
		vips_image_hasalpha( input ) ) {
		VipsBandFormat start_format = input-&gt;BandFmt;
		if( vips_premultiply( input, &amp;x, NULL ) ) {
			VIPS_UNREF( input );
			return( -1 );
		}
		VIPS_UNREF( input );
		input = x;
		if( vips_cast( input, &amp;x, start_format, NULL ) ) {
			VIPS_UNREF( input );
			return( -1 );
		}
		VIPS_UNREF( input );
		input = x;
	}
	if( wtiff-&gt;bitdepth &amp;&amp;
		input-&gt;Bands == 3 &amp;&amp;
		input-&gt;BandFmt == VIPS_FORMAT_FLOAT &amp;&amp;
		input-&gt;Type == VIPS_INTERPRETATION_LAB ) {
		if( vips_Lab2LabQ( input, &amp;x, NULL ) ) {
			VIPS_UNREF( input );
			return( -1 );
		}
		VIPS_UNREF( input );
		input = x;
	}
	wtiff-&gt;ready = input;
	return( 0 );
}
static Wtiff *
wtiff_new( VipsImage *input, const char *filename, 
	VipsForeignTiffCompression compression, int Q, 
	VipsForeignTiffPredictor predictor,
	const char *profile,
	gboolean tile, int tile_width, int tile_height,
	gboolean pyramid,
	int bitdepth,
	gboolean miniswhite,
	VipsForeignTiffResunit resunit, double xres, double yres,
	gboolean bigtiff,
	gboolean rgbjpeg,
	gboolean properties,
	gboolean strip,
	VipsRegionShrink region_shrink,
	int level, 
	gboolean lossless,
	VipsForeignDzDepth depth, 
	gboolean subifd,
	gboolean premultiply )
{
	Wtiff *wtiff;
	if( !(wtiff = VIPS_NEW( NULL, Wtiff )) )
		return( NULL );
	wtiff-&gt;input = input;
	wtiff-&gt;ready = NULL;
	wtiff-&gt;filename = filename ? vips_strdup( NULL, filename ) : NULL;
	wtiff-&gt;layer = NULL;
	wtiff-&gt;tbuf = NULL;
	wtiff-&gt;compression = get_compression( compression );
	wtiff-&gt;Q = Q;
	wtiff-&gt;predictor = predictor;
	wtiff-&gt;tile = tile;
	wtiff-&gt;tilew = tile_width;
	wtiff-&gt;tileh = tile_height;
	wtiff-&gt;pyramid = pyramid;
	wtiff-&gt;bitdepth = bitdepth;
	wtiff-&gt;miniswhite = miniswhite;
	wtiff-&gt;resunit = get_resunit( resunit );
	wtiff-&gt;xres = xres;
	wtiff-&gt;yres = yres;
	wtiff-&gt;profile = profile;
	wtiff-&gt;bigtiff = bigtiff;
	wtiff-&gt;rgbjpeg = rgbjpeg;
	wtiff-&gt;properties = properties;
	wtiff-&gt;strip = strip;
	wtiff-&gt;region_shrink = region_shrink;
	wtiff-&gt;level = level;
	wtiff-&gt;lossless = lossless;
	wtiff-&gt;depth = depth;
	wtiff-&gt;subifd = subifd;
	wtiff-&gt;premultiply = premultiply;
	wtiff-&gt;toilet_roll = FALSE;
	wtiff-&gt;page_height = vips_image_get_page_height( input );
	wtiff-&gt;page_number = 0;
	wtiff-&gt;n_pages = 1;
	wtiff-&gt;image_height = input-&gt;Ysize;
	if( ready_to_write( wtiff ) ) {
		wtiff_free( wtiff );
		return( NULL );
	}
	if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_XYZ ) 
		wtiff-&gt;compression = COMPRESSION_SGILOG;
	if( wtiff-&gt;page_height &lt; wtiff-&gt;ready-&gt;Ysize ) {
#ifdef DEBUG
		printf( "wtiff_new: detected toilet roll image, "
			"page-height=%d\n", 
			wtiff-&gt;page_height );
		printf( "wtiff_new: pages=%d\n", 
			wtiff-&gt;ready-&gt;Ysize / wtiff-&gt;page_height );
		wtiff-&gt;toilet_roll = TRUE;
		wtiff-&gt;image_height = wtiff-&gt;page_height;
		wtiff-&gt;n_pages = wtiff-&gt;ready-&gt;Ysize / wtiff-&gt;page_height;
	}
	if( wtiff-&gt;pyramid ) {
		if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_NONE &amp;&amp; 
			vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) ) {
			wtiff_free( wtiff );
			vips_error( "vips2tiff", 
				"%s", _( "can only pyramid LABQ and "
				"non-complex images" ) );
			return( NULL );
		}
	}
	if( wtiff-&gt;pyramid &amp;&amp;
		!wtiff-&gt;tile )
		wtiff-&gt;tile = TRUE;
	if( wtiff-&gt;pyramid &amp;&amp;
		wtiff-&gt;toilet_roll )
		wtiff-&gt;subifd = TRUE;
	if( wtiff-&gt;compression == COMPRESSION_NONE &amp;&amp;
		VIPS_IMAGE_SIZEOF_IMAGE( wtiff-&gt;ready ) &gt; UINT_MAX )
		wtiff-&gt;bigtiff = TRUE;
	if( wtiff-&gt;tile ) { 
		if( (wtiff-&gt;tilew &amp; 0xf) != 0 || 
			(wtiff-&gt;tileh &amp; 0xf) != 0 ) {
			wtiff_free( wtiff );
			vips_error( "vips2tiff", 
				"%s", _( "tile size not a multiple of 16" ) );
			return( NULL );
		}
	}
	if( wtiff-&gt;bitdepth &amp;&amp; 
		!(wtiff-&gt;bitdepth == 1 || 
		  wtiff-&gt;bitdepth == 2 || 
		  wtiff-&gt;bitdepth == 4) ) {
		g_warning( "%s",
			_( "bitdepth 1, 2 or 4 only -- disabling bitdepth") );
		wtiff-&gt;bitdepth = 0;
	}
	if( wtiff-&gt;bitdepth &amp;&amp; 
		!(wtiff-&gt;ready-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
		  wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR &amp;&amp; 
		  wtiff-&gt;ready-&gt;Bands == 1) ) { 
		g_warning( "%s",
			( "can only set bitdepth for 1-band uchar and "
                        "3-band float lab -- disabling bitdepth" ) );
		wtiff-&gt;bitdepth = 0;
	}
	if( wtiff-&gt;bitdepth &amp;&amp;
		wtiff-&gt;compression == COMPRESSION_JPEG ) {
		g_warning( "%s", 
			_( "can't have &lt;8 bit JPEG -- disabling JPEG" ) );
		wtiff-&gt;compression = COMPRESSION_NONE;
	}
	if( wtiff-&gt;miniswhite &amp;&amp;
		(wtiff-&gt;ready-&gt;Coding != VIPS_CODING_NONE || 
			vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) ||
			wtiff-&gt;ready-&gt;Bands &gt; 2) ) {
		g_warning( "%s", 
			_( "can only save non-complex greyscale images "
				"as miniswhite -- disabling miniswhite" ) );
		wtiff-&gt;miniswhite = FALSE;
	}
	if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ )
		wtiff-&gt;tls = wtiff-&gt;tilew * 3;
	else if( wtiff-&gt;bitdepth == 1 )
		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 8 ) / 8;
	else if( wtiff-&gt;bitdepth == 2 )
		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 4 ) / 4;
	else if( wtiff-&gt;bitdepth == 4 )
		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 2 ) / 2;
	else
		wtiff-&gt;tls = VIPS_IMAGE_SIZEOF_PEL( wtiff-&gt;ready ) * 
			wtiff-&gt;tilew;
	return( wtiff );
}
static void
LabQ2LabC( VipsPel *q, VipsPel *p, int n )
{
	int x;
	for( x = 0; x &lt; n; x++ ) {
		q[0] = p[0];
		q[1] = p[1];
		q[2] = p[2];
		p += 4;
		q += 3;
	}
}
static void
eightbit2nbit( Wtiff *wtiff, VipsPel *q, VipsPel *p, int n )
{
	VipsPel mask = wtiff-&gt;miniswhite ? 255 : 0;
	int pixel_mask = 8 / wtiff-&gt;bitdepth - 1;
	int shift = 8 - wtiff-&gt;bitdepth;
	VipsPel bits;
        int x;
	bits = 0;
        for( x = 0; x &lt; n; x++ ) {
		bits &lt;&lt;= wtiff-&gt;bitdepth;
		bits |= p[x] &gt;&gt; shift;
		if( (x &amp; pixel_mask) == pixel_mask ) 
			*q++ = bits ^ mask;
        }
	if( (x &amp; pixel_mask) != 0 ) {
		int collected_bits = (x &amp; pixel_mask) &lt;&lt; (wtiff-&gt;bitdepth - 1);
		*q++ = (bits ^ mask) &lt;&lt; (8 - collected_bits);
	}
}
#define GREY_LOOP( TYPE, MAX ) { \
	TYPE *p1; \
	TYPE *q1; \
	\
	p1 = (TYPE *) p; \
	q1 = (TYPE *) q; \
	for( x = 0; x &lt; n; x++ ) { \
		if( invert ) \
			q1[0] = MAX - p1[0]; \
		else \
			q1[0] = p1[0]; \
		\
		for( i = 1; i &lt; im-&gt;Bands; i++ ) \
			q1[i] = p1[i]; \
		\
		q1 += im-&gt;Bands; \
		p1 += im-&gt;Bands; \
	} \
}
static void
invert_band0( Wtiff *wtiff, VipsPel *q, VipsPel *p, int n )
{
	VipsImage *im = wtiff-&gt;ready;
	gboolean invert = wtiff-&gt;miniswhite;
        int x, i;
	switch( im-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
		GREY_LOOP( guchar, UCHAR_MAX ); 
		break;
	case VIPS_FORMAT_SHORT:
		GREY_LOOP( gshort, SHRT_MAX ); 
		break;
	case VIPS_FORMAT_USHORT:
		GREY_LOOP( gushort, USHRT_MAX ); 
		break;
	case VIPS_FORMAT_INT:
		GREY_LOOP( gint, INT_MAX ); 
		break;
	case VIPS_FORMAT_UINT:
		GREY_LOOP( guint, UINT_MAX ); 
		break;
	case VIPS_FORMAT_FLOAT:
		GREY_LOOP( float, 1.0 ); 
		break;
	case VIPS_FORMAT_DOUBLE:
		GREY_LOOP( double, 1.0 ); 
		break;
	default:
		g_assert_not_reached();
	}
}
static void
LabS2Lab16( VipsPel *q, VipsPel *p, int n, int samples_per_pixel )
{
	short *p1 = (short *) p;
	unsigned short *q1 = (unsigned short *) q;
	int x;
        for( x = 0; x &lt; n; x++ ) {
		int i;
                q1[0] = VIPS_LSHIFT_INT( VIPS_MAX( 0, p1[0] ), 1 );
		for( i = 1; i &lt; samples_per_pixel; i++ )
			q1[i] = p1[i];
		q1 += samples_per_pixel;
		p1 += samples_per_pixel;
	}
}
static void
XYZ2tiffxyz( VipsPel *q, VipsPel *p, int n, int samples_per_pixel )
{
	float *p1 = (float *) p;
	float *q1 = (float *) q;
	int x;
        for( x = 0; x &lt; n; x++ ) {
		int i;
                q1[0] = p1[0] / VIPS_D65_X0;
                q1[1] = p1[1] / VIPS_D65_Y0;
                q1[2] = p1[2] / VIPS_D65_Z0;
		for( i = 3; i &lt; samples_per_pixel; i++ )
			q1[i] = p1[i];
		q1 += samples_per_pixel;
		p1 += samples_per_pixel;
	}
}
static void
wtiff_pack2tiff( Wtiff *wtiff, Layer *layer, 
	VipsRegion *in, VipsRect *area, VipsPel *q )
{
	int y;
	if( wtiff-&gt;compression == COMPRESSION_JPEG &amp;&amp;
		(area-&gt;width &lt; wtiff-&gt;tilew || 
		 area-&gt;height &lt; wtiff-&gt;tileh) )
		memset( q, 0, TIFFTileSize( layer-&gt;tif ) );
	for( y = area-&gt;top; y &lt; VIPS_RECT_BOTTOM( area ); y++ ) {
		VipsPel *p = (VipsPel *) VIPS_REGION_ADDR( in, area-&gt;left, y );
		if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ )
			LabQ2LabC( q, p, area-&gt;width );
		else if( wtiff-&gt;bitdepth &gt; 0 )
			eightbit2nbit( wtiff, q, p, area-&gt;width );
		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ )
			XYZ2tiffxyz( q, p, area-&gt;width, in-&gt;im-&gt;Bands );
		else if( (in-&gt;im-&gt;Bands == 1 || in-&gt;im-&gt;Bands == 2) &amp;&amp; 
			wtiff-&gt;miniswhite ) 
			invert_band0( wtiff, q, p, area-&gt;width );
		else if( wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_SHORT &amp;&amp;
			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LABS )
			LabS2Lab16( q, p, area-&gt;width, in-&gt;im-&gt;Bands );
		else
			memcpy( q, p, 
				area-&gt;width * 
					VIPS_IMAGE_SIZEOF_PEL( wtiff-&gt;ready ) );
		q += wtiff-&gt;tls;
	}
}
static int
wtiff_layer_write_tiles( Wtiff *wtiff, Layer *layer, VipsRegion *strip )
{
	VipsImage *im = layer-&gt;image;
	VipsRect *area = &amp;strip-&gt;valid;
	VipsRect image;
	int x;
	image.left = 0;
	image.top = 0;
	image.width = im-&gt;Xsize;
	image.height = im-&gt;Ysize;
	for( x = 0; x &lt; im-&gt;Xsize; x += wtiff-&gt;tilew ) {
		VipsRect tile;
		tile.left = x;
		tile.top = area-&gt;top;
		tile.width = wtiff-&gt;tilew;
		tile.height = wtiff-&gt;tileh;
		vips_rect_intersectrect( &amp;tile, &amp;image, &amp;tile );
#ifdef DEBUG_VERBOSE
		printf( "Writing %dx%d tile at position %dx%d to image %s\n",
			tile.width, tile.height, tile.left, tile.top,
			TIFFFileName( layer-&gt;tif ) );
		if( wtiff-&gt;we_compress ) {
			ttile_t tile_no = TIFFComputeTile( layer-&gt;tif,
				tile.left, tile.top, 0, 0 );
			VipsTarget *target;
			int result;
			unsigned char *buffer;
			size_t length;
			target = vips_target_new_to_memory();
			switch( wtiff-&gt;compression ) {
			case JP2K_LOSSY:
				result = vips__foreign_load_jp2k_compress( 
					strip, &amp;tile, target,
					wtiff-&gt;tilew, wtiff-&gt;tileh,
					!wtiff-&gt;rgbjpeg,
					FALSE,
					wtiff-&gt;lossless, 
					wtiff-&gt;Q );
				break;
			default:
				result = -1;
				g_assert_not_reached();
				break;
			}
			if( result ) {
				g_object_unref( target );
				return( -1 );
			}
			buffer = vips_target_steal( target, &amp;length );
			g_object_unref( target );
			result = TIFFWriteRawTile( layer-&gt;tif, tile_no, 
				buffer, length );
			g_free( buffer );
			if( result &lt; 0 ) {
				vips_error( "vips2tiff", 
					"%s", _( "TIFF write tile failed" ) );
				return( -1 );
			}
		}
		else {
			wtiff_pack2tiff( wtiff, 
				layer, strip, &amp;tile, wtiff-&gt;tbuf );
			if( TIFFWriteTile( layer-&gt;tif, wtiff-&gt;tbuf, 
				tile.left, tile.top, 0, 0 ) &lt; 0 ) {
				vips_error( "vips2tiff", 
					"%s", _( "TIFF write tile failed" ) );
				return( -1 );
			}
		}
	}
	return( 0 );
}
static int
wtiff_layer_write_strip( Wtiff *wtiff, Layer *layer, VipsRegion *strip )
{
	VipsImage *im = layer-&gt;image;
	VipsRect *area = &amp;strip-&gt;valid;
	int height = VIPS_MIN( wtiff-&gt;tileh, area-&gt;height ); 
	int y;
#ifdef DEBUG_VERBOSE
	printf( "Writing %d pixel strip at height %d to image %s\n",
		height, area-&gt;top, TIFFFileName( layer-&gt;tif ) );
	for( y = 0; y &lt; height; y++ ) {
		VipsPel *p = VIPS_REGION_ADDR( strip, 0, area-&gt;top + y );
		if( im-&gt;Coding == VIPS_CODING_LABQ ) {
			LabQ2LabC( wtiff-&gt;tbuf, p, im-&gt;Xsize );
			p = wtiff-&gt;tbuf;
		}
		else if( im-&gt;BandFmt == VIPS_FORMAT_SHORT &amp;&amp;
			im-&gt;Type == VIPS_INTERPRETATION_LABS ) {
			LabS2Lab16( wtiff-&gt;tbuf, p, im-&gt;Xsize, im-&gt;Bands );
			p = wtiff-&gt;tbuf;
		}
		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ ) {
			XYZ2tiffxyz( wtiff-&gt;tbuf, p, im-&gt;Xsize, im-&gt;Bands );
			p = wtiff-&gt;tbuf;
		}
		else if( wtiff-&gt;bitdepth &gt; 0 ) {
			eightbit2nbit( wtiff, wtiff-&gt;tbuf, p, im-&gt;Xsize );
			p = wtiff-&gt;tbuf;
		}
		else if( (im-&gt;Bands == 1 || im-&gt;Bands == 2) &amp;&amp; 
			wtiff-&gt;miniswhite ) {
			invert_band0( wtiff, wtiff-&gt;tbuf, p, im-&gt;Xsize );
			p = wtiff-&gt;tbuf;
		}
		if( TIFFWriteScanline( layer-&gt;tif, p, area-&gt;top + y, 0 ) &lt; 0 ) 
			return( -1 );
	}
	return( 0 );
}
static int layer_strip_arrived( Layer *layer );
<a name="0"></a>static int
layer_strip_shrink( Layer *layer )
{
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	Layer *below = layer-&gt;below;
	VipsRegion *from = layer-&gt;strip;
	VipsRegion *to = below-&gt;strip;
	VipsRect target;
	VipsRect source;
	for(;;) {
		target.left = 0;
		target.top = below-&gt;write_y;
		target.width = below-&gt;image-&gt;Xsize;
		target.height = to-&gt;valid.height;
		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );
		source.left = target.left * 2;
		source.top = target.top * 2;
		source.width = target.width * 2;
		source.height = target.height * 2;
		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );
		target.left = source.left / 2;
		target.top = source.top / 2;
		target.width = source.width / 2;
		target.height = source.height / 2;
		if( vips_rect_isempty( &amp;target ) )
			break;
		(void) vips_region_shrink_method( from, to, &amp;target,
			layer-&gt;wtiff-&gt;region_shrink );
		below-&gt;write_y += target.height;
		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
			below-&gt;write_y == below-&gt;height ) {
			if( layer_strip_arrived( below ) )
				return( -1 );
		}
	}
	return( 0 );
}
static int
layer_strip_arrived( Layer *layer )
{
	Wtiff *wtiff = layer-&gt;wtiff;</b></font>
	int result;
	VipsRect new_strip;
	VipsRect overlap;
	VipsRect image_area;
	if( wtiff-&gt;tile ) 
<a name="2"></a>		result = wtiff_layer_write_tiles( wtiff, layer, layer-&gt;strip );
	else
		result = wtiff_layer_write_strip( wtiff, layer, layer-&gt;strip );
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( result )
		return( -1 );
	if( layer-&gt;below &amp;&amp;
		layer_strip_shrink( layer ) ) 
		return( -1 );
	layer-&gt;y += wtiff-&gt;tileh;
	new_strip.left = 0;
	new_strip.top = layer-&gt;y;
	new_strip.width = layer-&gt;image-&gt;Xsize;
	new_strip.height = wtiff-&gt;tileh;
	image_area.left = 0;
	image_area.top = 0;
	image_area.width = layer-&gt;image-&gt;Xsize;
	image_area.height = layer-&gt;image-&gt;Ysize;
	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 
	if( (new_strip.height &amp; 1) == 1 )
		new_strip.height += 1;
	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
	if( !vips_rect_isempty( &amp;overlap ) ) {</b></font>
		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
			return( -1 );
		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
			&amp;overlap, overlap.left, overlap.top );
	}
	if( !vips_rect_isempty( &amp;new_strip ) ) {
		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) ) 
			return( -1 );
		if( !vips_rect_isempty( &amp;overlap ) ) 
			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
<a name="1"></a>				&amp;overlap, overlap.left, overlap.top );
	}
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
}
static int
write_strip( VipsRegion *region, VipsRect *area, void *a )
{
	Wtiff *wtiff = (Wtiff *) a;
	Layer *layer = wtiff-&gt;layer; 
#ifdef DEBUG_VERBOSE
	printf( "write_strip: strip at %d, height %d\n", 
		area-&gt;top, area-&gt;height );
	for(;;) {
		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
		VipsRect target;
		target.left = 0;
		target.top = layer-&gt;write_y;
		target.width = layer-&gt;image-&gt;Xsize;
		target.height = to-&gt;height;
		vips_rect_intersectrect( &amp;target, to, &amp;target );
		vips_rect_intersectrect( &amp;target, area, &amp;target );
		if( vips_rect_isempty( &amp;target ) ) 
			break;
		vips_region_copy( region, layer-&gt;strip, 
			&amp;target, target.left, target.top );
		layer-&gt;write_y += target.height;
		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
			layer-&gt;write_y == layer-&gt;height ) {
			if( layer_strip_arrived( layer ) ) 
				return( -1 );
		}
	}</b></font>
	return( 0 );
}
#define CopyField( tag, v ) \
	if( TIFFGetField( in, tag, &amp;v ) ) TIFFSetField( out, tag, v )
static int
wtiff_copy_tiles( Wtiff *wtiff, TIFF *out, TIFF *in )
{
	const ttile_t n_tiles = TIFFNumberOfTiles( in );
	tsize_t tile_size;
	tdata_t buf;
	ttile_t i;
	if( wtiff-&gt;compression == COMPRESSION_JPEG ) 
		tile_size = TIFFTileSize( in );
	else 
		tile_size = 2 * wtiff-&gt;tls * wtiff-&gt;tileh;
	buf = vips_malloc( NULL, tile_size );
	for( i = 0; i &lt; n_tiles; i++ ) {
		tsize_t len;
		if( wtiff-&gt;compression == COMPRESSION_JPEG ) {
			len = TIFFReadEncodedTile( in, i, buf, tile_size );
			if( len &lt;= 0 ||
				TIFFWriteEncodedTile( out, i, buf, len ) &lt; 0 ) {
				g_free( buf );
				return( -1 );
			}
		}
		else {
			len = TIFFReadRawTile( in, i, buf, tile_size );
			if( len &lt;= 0 ||
				TIFFWriteRawTile( out, i, buf, len ) &lt; 0 ) {
				g_free( buf );
				return( -1 );
			}
		}
	}
	g_free( buf );
	return( 0 );
}
static int
wtiff_copy_tiff( Wtiff *wtiff, TIFF *out, TIFF *in )
{
	uint32 ui32;
	uint16 ui16;
	uint16 ui16_2;
	float f;
	uint16 *a;
	CopyField( TIFFTAG_IMAGEWIDTH, ui32 );
	CopyField( TIFFTAG_IMAGELENGTH, ui32 );
	CopyField( TIFFTAG_PLANARCONFIG, ui16 );
	CopyField( TIFFTAG_ORIENTATION, ui16 );
	CopyField( TIFFTAG_XRESOLUTION, f );
	CopyField( TIFFTAG_YRESOLUTION, f );
	CopyField( TIFFTAG_RESOLUTIONUNIT, ui16 );
	CopyField( TIFFTAG_COMPRESSION, ui16 );
	CopyField( TIFFTAG_SAMPLESPERPIXEL, ui16 );
	CopyField( TIFFTAG_BITSPERSAMPLE, ui16 );
	CopyField( TIFFTAG_PHOTOMETRIC, ui16 );
	CopyField( TIFFTAG_ORIENTATION, ui16 );
	CopyField( TIFFTAG_TILEWIDTH, ui32 );
	CopyField( TIFFTAG_TILELENGTH, ui32 );
	CopyField( TIFFTAG_ROWSPERSTRIP, ui32 );
	CopyField( TIFFTAG_SUBFILETYPE, ui32 );
	if( TIFFGetField( in, TIFFTAG_EXTRASAMPLES, &amp;ui16, &amp;a ) ) 
		TIFFSetField( out, TIFFTAG_EXTRASAMPLES, ui16, a );
	if( TIFFGetField( in, TIFFTAG_PAGENUMBER, &amp;ui16, &amp;ui16_2 ) ) 
		TIFFSetField( out, TIFFTAG_PAGENUMBER, ui16, ui16_2 );
	if( wtiff-&gt;compression == COMPRESSION_JPEG ) {
		TIFFSetField( out, TIFFTAG_JPEGQUALITY, wtiff-&gt;Q );
		if( wtiff-&gt;ready-&gt;Bands == 3 &amp;&amp;
			wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR ) { 
			if( !wtiff-&gt;rgbjpeg &amp;&amp;
				wtiff-&gt;Q &lt; 90 ) 
				TIFFSetField( out, 
					TIFFTAG_JPEGCOLORMODE, 
						JPEGCOLORMODE_RGB );
			TIFFSetField( in, 
				TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );
		}
	}
#ifdef HAVE_TIFF_COMPRESSION_WEBP
	if( wtiff-&gt;compression == COMPRESSION_WEBP ) {
		TIFFSetField( out, TIFFTAG_WEBP_LEVEL, wtiff-&gt;Q );
		TIFFSetField( out, TIFFTAG_WEBP_LOSSLESS, wtiff-&gt;lossless );
	}
	if( wtiff-&gt;compression == COMPRESSION_ZSTD ) {
		TIFFSetField( out, TIFFTAG_ZSTD_LEVEL, wtiff-&gt;level );
		if( wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
			TIFFSetField( out, 
				TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
	}
	if( (wtiff-&gt;compression == COMPRESSION_ADOBE_DEFLATE ||
		wtiff-&gt;compression == COMPRESSION_LZW) &amp;&amp;
		wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
		TIFFSetField( out, TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
	if( !wtiff-&gt;strip ) 
		if( wtiff_embed_profile( wtiff, out ) ||
			wtiff_embed_xmp( wtiff, out ) ||
			wtiff_embed_iptc( wtiff, out ) ||
			wtiff_embed_photoshop( wtiff, out ) ||
			wtiff_embed_imagedescription( wtiff, out ) )
			return( -1 );
	if( wtiff_copy_tiles( wtiff, out, in ) )
		return( -1 );
	return( 0 );
}
static int
wtiff_gather( Wtiff *wtiff )
{
	Layer *layer;
	if( wtiff-&gt;layer &amp;&amp;
		wtiff-&gt;layer-&gt;below )
		for( layer = wtiff-&gt;layer-&gt;below; layer; 
			layer = layer-&gt;below ) {
			VipsSource *source;
			TIFF *in;
#ifdef DEBUG
			printf( "appending layer %s ...\n", layer-&gt;lname );
			if( layer-&gt;lname ) {
				if( !(source = vips_source_new_from_file( 
					layer-&gt;lname )) ) 
					return( -1 );
			}
			else {
				if( !(source = vips_source_new_from_memory(
					layer-&gt;buf, layer-&gt;len )) )
					return( -1 );
			}
			if( !(in = vips__tiff_openin_source( source )) ) {
				VIPS_UNREF( source );
				return( -1 );
			}
			VIPS_UNREF( source );
			if( wtiff_copy_tiff( wtiff, wtiff-&gt;layer-&gt;tif, in ) ) {
				TIFFClose( in );
				return( -1 );
			}
			TIFFClose( in );
			if( !TIFFWriteDirectory( wtiff-&gt;layer-&gt;tif ) ) 
				return( -1 );
		}
	return( 0 );
}
static int
wtiff_write_page( Wtiff *wtiff, VipsImage *page )
{
#ifdef DEBUG
	printf( "wtiff_write_page:\n" ); 
	wtiff_layer_init( wtiff, &amp;wtiff-&gt;layer, NULL, 
		page-&gt;Xsize, page-&gt;Ysize );
	if( wtiff_allocate_layers( wtiff ) ) 
		return( -1 );
	if( wtiff-&gt;subifd ) {
		int n_layers;
		toff_t *subifd_offsets;
		Layer *p;
#ifdef DEBUG
		printf( "wtiff_write_page: OME pyr mode\n" ); 
		for( n_layers = 0, p = wtiff-&gt;layer-&gt;below; p; p = p-&gt;below )
			n_layers += 1;
		subifd_offsets = VIPS_ARRAY( NULL, n_layers, toff_t );
		memset( subifd_offsets, 0, n_layers * sizeof( toff_t ) );
		TIFFSetField( wtiff-&gt;layer-&gt;tif, TIFFTAG_SUBIFD, 
			n_layers, subifd_offsets );
		g_free( subifd_offsets );
	}
	if( vips_sink_disc( page, write_strip, wtiff ) ) 
		return( -1 );
	if( !TIFFWriteDirectory( wtiff-&gt;layer-&gt;tif ) ) 
		return( -1 );
	if( wtiff-&gt;layer-&gt;below ) {
		layer_free_all( wtiff-&gt;layer-&gt;below );
		if( wtiff_gather( wtiff ) ) 
			return( -1 );
		wtiff_delete_temps( wtiff );
		VIPS_FREEF( layer_free_all, wtiff-&gt;layer-&gt;below );
	}
	return( 0 );
}
static int
wtiff_write_image( Wtiff *wtiff )
{
	int y;
	for( y = 0; y &lt; wtiff-&gt;ready-&gt;Ysize; y += wtiff-&gt;page_height ) {
		VipsImage *page;
#ifdef DEBUG
		printf( "writing page %d ...\n", wtiff-&gt;page_number );
		if( vips_crop( wtiff-&gt;ready, &amp;page, 
			0, y, wtiff-&gt;ready-&gt;Xsize, wtiff-&gt;page_height,
			NULL ) )
			return( -1 ); 
		if( wtiff_write_page( wtiff, page ) ) {
			g_object_unref( page );
			return( -1 );
		}
		g_object_unref( page );
		wtiff-&gt;page_number += 1;
	}
	return( 0 );
}
int 
vips__tiff_write( VipsImage *input, const char *filename, 
	VipsForeignTiffCompression compression, int Q, 
	VipsForeignTiffPredictor predictor,
	const char *profile,
	gboolean tile, int tile_width, int tile_height,
	gboolean pyramid,
	int bitdepth,
	gboolean miniswhite,
	VipsForeignTiffResunit resunit, double xres, double yres,
	gboolean bigtiff,
	gboolean rgbjpeg,
	gboolean properties, gboolean strip,
	VipsRegionShrink region_shrink,
	int level, 
	gboolean lossless,
	VipsForeignDzDepth depth,
	gboolean subifd,
	gboolean premultiply )
{
	Wtiff *wtiff;
#ifdef DEBUG
	printf( "tiff2vips: libtiff version is \"%s\"\n", TIFFGetVersion() );
	vips__tiff_init();
	if( !(wtiff = wtiff_new( input, filename, 
		compression, Q, predictor, profile,
                tile, tile_width, tile_height, pyramid, bitdepth,
		miniswhite, resunit, xres, yres, bigtiff, rgbjpeg, 
		properties, strip, region_shrink, level, lossless, depth,
		subifd, premultiply )) )
		return( -1 );
	if( wtiff_write_image( wtiff ) ) { 
		wtiff_free( wtiff );
		return( -1 );
	}
	wtiff_free( wtiff );
	return( 0 );
}
int 
vips__tiff_write_buf( VipsImage *input, 
	void **obuf, size_t *olen, 
	VipsForeignTiffCompression compression, int Q, 
	VipsForeignTiffPredictor predictor,
	const char *profile,
	gboolean tile, int tile_width, int tile_height,
	gboolean pyramid,
	int bitdepth,
	gboolean miniswhite,
	VipsForeignTiffResunit resunit, double xres, double yres,
	gboolean bigtiff,
	gboolean rgbjpeg,
	gboolean properties, gboolean strip, 
	VipsRegionShrink region_shrink,
	int level, 
	gboolean lossless,
	VipsForeignDzDepth depth,
	gboolean subifd,
	gboolean premultiply )
{
	Wtiff *wtiff;
	vips__tiff_init();
	if( !(wtiff = wtiff_new( input, NULL, 
		compression, Q, predictor, profile,
                tile, tile_width, tile_height, pyramid, bitdepth,
		miniswhite, resunit, xres, yres, bigtiff, rgbjpeg, 
		properties, strip, region_shrink, level, lossless, depth,
		subifd, premultiply )) )
		return( -1 );
	wtiff-&gt;obuf = obuf;
	wtiff-&gt;olen = olen;
	if( wtiff_write_image( wtiff ) ) { 
		wtiff_free( wtiff );
		return( -1 );
	}
	VIPS_FREEF( TIFFClose, wtiff-&gt;layer-&gt;tif );
	*obuf = wtiff-&gt;layer-&gt;buf;
	*olen = wtiff-&gt;layer-&gt;len;
	wtiff-&gt;layer-&gt;buf = NULL;
	wtiff_free( wtiff );
	return( 0 );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dzsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#ifdef HAVE_GSF
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#include &lt;gsf/gsf.h&gt;
#pragma GCC diagnostic pop
typedef struct _VipsGsfDirectory { 
	struct _VipsGsfDirectory *parent;
	char *name;
	GSList *children;
	GsfOutput *out;
        GsfOutput *container;
	size_t file_count;
	size_t filename_lengths;
	gint deflate_level;
} VipsGsfDirectory; 
static void *vips_gsf_tree_close( VipsGsfDirectory *tree );
static void *
vips_gsf_tree_close_cb( void *item, void *a, void *b )
{
	VipsGsfDirectory *tree = (VipsGsfDirectory *) item;
	return( vips_gsf_tree_close( tree ) );
}
static void *
vips_gsf_tree_close( VipsGsfDirectory *tree )
{
	vips_slist_map2( tree-&gt;children, vips_gsf_tree_close_cb, NULL, NULL );
	if( tree-&gt;out ) {
		if( !gsf_output_is_closed( tree-&gt;out ) &amp;&amp;
			!gsf_output_close( tree-&gt;out ) ) {
			vips_error( "vips_gsf", 
				"%s", _( "unable to close stream" ) ); 
			return( tree );
		}
		VIPS_UNREF( tree-&gt;out );
	}
	if( tree-&gt;container ) { 
		if( !gsf_output_is_closed( tree-&gt;container ) &amp;&amp; 
			!gsf_output_close( tree-&gt;container ) ) {
			vips_error( "vips_gsf", 
				"%s", _( "unable to close stream" ) ); 
			return( tree );
		}
		VIPS_UNREF( tree-&gt;container );
	}
	VIPS_FREEF( g_slist_free, tree-&gt;children );
	VIPS_FREE( tree-&gt;name );
	VIPS_FREE( tree );
	return( NULL ); 
}
static VipsGsfDirectory *
vips_gsf_tree_new( GsfOutput *out, gint deflate_level )
{
	VipsGsfDirectory *tree = g_new( VipsGsfDirectory, 1 );
	tree-&gt;parent = NULL;
	tree-&gt;name = NULL;
	tree-&gt;children = NULL;
	tree-&gt;out = out;
	tree-&gt;container = NULL;
	tree-&gt;file_count = 0;
	tree-&gt;filename_lengths = 0;
	tree-&gt;deflate_level = deflate_level;
	return( tree ); 
}
static void *
vips_gsf_child_by_name_sub( VipsGsfDirectory *dir, const char *name, void *b )
{
	if( strcmp( dir-&gt;name, name ) == 0 )
		return( dir );
	return( NULL ); 
}
static VipsGsfDirectory *
vips_gsf_child_by_name( VipsGsfDirectory *dir, const char *name )
{
	return( vips_slist_map2( dir-&gt;children, 
		(VipsSListMap2Fn) vips_gsf_child_by_name_sub, 
		(char *) name, NULL ) );
}
static VipsGsfDirectory *
vips_gsf_dir_new( VipsGsfDirectory *parent, const char *name )
{
	VipsGsfDirectory *dir = g_new( VipsGsfDirectory, 1 );
	g_assert( !vips_gsf_child_by_name( parent, name ) ); 
	dir-&gt;parent = parent;
	dir-&gt;name = g_strdup( name );
	dir-&gt;children = NULL;
	dir-&gt;container = NULL;
	dir-&gt;file_count = 0;
	dir-&gt;filename_lengths = 0;
	dir-&gt;deflate_level = parent-&gt;deflate_level;
	if( GSF_IS_OUTFILE_ZIP( parent-&gt;out ) )
		dir-&gt;out = gsf_outfile_new_child_full( 
			(GsfOutfile *) parent-&gt;out, 
			name, TRUE,
			"compression-level", GSF_ZIP_STORED,
			NULL );
	else
		dir-&gt;out = gsf_outfile_new_child( 
			(GsfOutfile *) parent-&gt;out, 
			name, TRUE ); 
	g_assert( dir-&gt;out ); 
	parent-&gt;children = g_slist_prepend( parent-&gt;children, dir ); 
	return( dir ); 
}
static GsfOutput *
vips_gsf_path( VipsGsfDirectory *tree, const char *name, ... )
{
	va_list ap;
	VipsGsfDirectory *dir;
	VipsGsfDirectory *child;
	char *dir_name;
	GsfOutput *obj;
	tree-&gt;file_count += 1;
	tree-&gt;filename_lengths += 
		strlen( tree-&gt;out-&gt;name ) + strlen( name ) + 1;
	dir = tree; 
	va_start( ap, name );
	while( (dir_name = va_arg( ap, char * )) ) {
		if( (child = vips_gsf_child_by_name( dir, dir_name )) )
			dir = child;
		else 
			dir = vips_gsf_dir_new( dir, dir_name );
		tree-&gt;filename_lengths += strlen( dir_name ) + 1;
	}
	va_end( ap );
	if( GSF_IS_OUTFILE_ZIP( dir-&gt;out ) ) {
		if( dir-&gt;deflate_level == 0 )
			obj = gsf_outfile_new_child_full(
				(GsfOutfile *) dir-&gt;out,
				name, FALSE,
				"compression-level", GSF_ZIP_STORED,
				NULL );
		else if( dir-&gt;deflate_level == -1 )
			obj = gsf_outfile_new_child_full(
				(GsfOutfile *) dir-&gt;out,
				name, FALSE,
				"compression-level", GSF_ZIP_DEFLATED,
				NULL );
		else
			obj = gsf_outfile_new_child_full(
				(GsfOutfile *) dir-&gt;out,
				name, FALSE,
				"compression-level", GSF_ZIP_DEFLATED,
				"deflate-level", dir-&gt;deflate_level,
				NULL );
	}
	else
		obj = gsf_outfile_new_child( (GsfOutfile *) dir-&gt;out,
			name, FALSE ); 
	return( obj ); 
}
typedef struct _VipsForeignSaveDz VipsForeignSaveDz;
typedef struct _Layer Layer;
struct _Layer {
	VipsForeignSaveDz *dz;
	int width;
	int height;
	int tiles_across;
	int tiles_down;
	VipsRect real_pixels; 
	VipsImage *image;
	int y;
	int write_y;
	VipsRegion *strip;			VipsRegion *copy;		
	int sub;				int n;				
	Layer *below;				Layer *above;			};
struct _VipsForeignSaveDz {
	VipsForeignSave parent_object;
	char *suffix;
	int overlap;
	int tile_size;
	VipsForeignDzLayout layout;
	VipsForeignDzDepth depth;
	gboolean centre;
	gboolean properties;
	VipsAngle angle;
	VipsForeignDzContainer container; 
	int compression;
	VipsRegionShrink region_shrink;
	int skip_blanks;
	gboolean no_strip;
	char *id;
	int tile_margin;
	int tile_step;
	Layer *layer;			
	int tile_count;
	VipsGsfDirectory *tree;
	GsfOutput *out;
	char *basename; 
	char *dirname; 
	char *tempdir;
	char *root_name; 
	char *file_suffix;
	size_t bytes_written;
	VipsPel *ink;
};
typedef VipsForeignSaveClass VipsForeignSaveDzClass;
G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveDz, vips_foreign_save_dz, 
	VIPS_TYPE_FOREIGN_SAVE );
static gboolean
iszip( VipsForeignDzContainer container )
{
	switch( container ) {
	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
		return( TRUE );
	default:
		return( FALSE );
	}
}
#define VIPS_ZIP_FIXED_LH_SIZE (30 + 29)
#define VIPS_ZIP_FIXED_CD_SIZE (46 + 9)
#define VIPS_ZIP_EOCD_SIZE 22
#ifndef HAVE_GSF_ZIP64
static size_t
estimate_zip_size( VipsForeignSaveDz *dz )
{
	size_t estimated_zip_size = dz-&gt;bytes_written +
		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_LH_SIZE +
		dz-&gt;tree-&gt;filename_lengths +
		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_CD_SIZE +
		dz-&gt;tree-&gt;filename_lengths +
		VIPS_ZIP_EOCD_SIZE;
#ifdef DEBUG_VERBOSE
	printf( "estimate_zip_size: %zd\n", estimated_zip_size );
	return( estimated_zip_size );
}
static int
write_image( VipsForeignSaveDz *dz,
	GsfOutput *out, VipsImage *image, const char *format )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz );
	VipsImage *t;
	void *buf;
	size_t len;
	if( vips_copy( image, &amp;t, NULL ) ) 
		return( -1 );
	vips_image_set_int( t, "hide-progress", 1 );
	if( vips_image_write_to_buffer( t, format, &amp;buf, &amp;len,
		"strip", !dz-&gt;no_strip,
		NULL ) ) {
		VIPS_UNREF( t );
		return( -1 );
	}
	VIPS_UNREF( t );
	g_mutex_lock( vips__global_lock );
	if( !gsf_output_write( out, len, buf ) ) {
		gsf_output_close( out );
		g_mutex_unlock( vips__global_lock );
		g_free( buf );
		vips_error( class-&gt;nickname,
			"%s", gsf_output_error( out )-&gt;message );
		return( -1 );
	}
	dz-&gt;bytes_written += len;
	gsf_output_close( out );
#ifndef HAVE_GSF_ZIP64
	if( iszip( dz-&gt;container ) ) {
		if( dz-&gt;tree-&gt;file_count + 3 &gt;= (unsigned int) USHRT_MAX ) {
			g_mutex_unlock( vips__global_lock );
			vips_error( class-&gt;nickname,
				"%s", _( "too many files in zip" ) );
			return( -1 );
		}
		if( estimate_zip_size( dz ) &gt; (size_t) UINT_MAX - 16384) {
			g_mutex_unlock( vips__global_lock );
			vips_error( class-&gt;nickname,
				"%s", _( "output file too large" ) ); 
			return( -1 ); 
		}
	}
	g_mutex_unlock( vips__global_lock );
	g_free( buf );
	return( 0 );
}
static void
layer_free( Layer *layer )
{
	VIPS_FREEF( g_object_unref, layer-&gt;strip );
	VIPS_FREEF( g_object_unref, layer-&gt;copy );
	VIPS_FREEF( g_object_unref, layer-&gt;image );
	VIPS_FREEF( layer_free, layer-&gt;below ); 
}
static void
vips_foreign_save_dz_dispose( GObject *gobject )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) gobject;
	VIPS_FREEF( layer_free, dz-&gt;layer );
	VIPS_FREEF( vips_gsf_tree_close,  dz-&gt;tree );
	VIPS_FREEF( g_object_unref, dz-&gt;out );
	VIPS_FREE( dz-&gt;basename );
	VIPS_FREE( dz-&gt;dirname );
	VIPS_FREE( dz-&gt;tempdir );
	VIPS_FREE( dz-&gt;root_name );
	VIPS_FREE( dz-&gt;file_suffix );
	G_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
		dispose( gobject );
}
static Layer *
pyramid_build( VipsForeignSaveDz *dz, Layer *above, 
	int width, int height, VipsRect *real_pixels )
{
	VipsForeignSave *save = VIPS_FOREIGN_SAVE( dz );
	Layer *layer = VIPS_NEW( dz, Layer );
	VipsRect strip;
	int limit; 
	layer-&gt;dz = dz;
	layer-&gt;width = width;
	layer-&gt;height = height;
	layer-&gt;tiles_across = VIPS_ROUND_UP( width, dz-&gt;tile_step ) / 
		dz-&gt;tile_step;
	layer-&gt;tiles_down = VIPS_ROUND_UP( height, dz-&gt;tile_step ) / 
		dz-&gt;tile_step;
	layer-&gt;real_pixels = *real_pixels; 
	layer-&gt;image = NULL;
	layer-&gt;strip = NULL;
	layer-&gt;copy = NULL;
	if( !above )
		layer-&gt;sub = 1;	
	else
		layer-&gt;sub = above-&gt;sub * 2;
	layer-&gt;below = NULL;
	layer-&gt;above = above;
	layer-&gt;image = vips_image_new();
	if( vips_image_pipelinev( layer-&gt;image, 
		VIPS_DEMAND_STYLE_ANY, save-&gt;ready, NULL ) ) {
		layer_free( layer );
		return( NULL );
	}
	layer-&gt;image-&gt;Xsize = width + (width &amp; 1);
	layer-&gt;image-&gt;Ysize = height + (height &amp; 1);
	layer-&gt;strip = vips_region_new( layer-&gt;image );
	layer-&gt;copy = vips_region_new( layer-&gt;image );
	vips__region_no_ownership( layer-&gt;strip );
	vips__region_no_ownership( layer-&gt;copy );
	layer-&gt;y = 0;
	layer-&gt;write_y = 0;
	strip.left = 0;
	strip.top = 0;
	strip.width = layer-&gt;image-&gt;Xsize;
	strip.height = dz-&gt;tile_size + dz-&gt;tile_margin;
	if( (strip.height &amp; 1) == 1 )
		strip.height += 1;
	if( vips_region_buffer( layer-&gt;strip, &amp;strip ) ) {
		layer_free( layer );
		return( NULL );
	}
	switch( dz-&gt;depth ) {
	case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
		limit = 1;
		break;
	case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
		limit = dz-&gt;tile_size;
		break;
	case VIPS_FOREIGN_DZ_DEPTH_ONE:
		limit = VIPS_MAX( width, height );
		break;
	default:
		g_assert_not_reached();
		limit = 1;
	}
	if( width &gt; limit || 
		height &gt; limit ) {
		VipsRect halfrect;
		halfrect.left = real_pixels-&gt;left / 2;
		halfrect.top = real_pixels-&gt;top / 2;
		halfrect.width = (VIPS_RECT_RIGHT( real_pixels ) + 1) / 2 - 
			halfrect.left;
		halfrect.height = (VIPS_RECT_BOTTOM( real_pixels ) + 1) / 2 - 
			halfrect.top;
		if( !(layer-&gt;below = pyramid_build( dz, layer, 
			(width + 1) / 2, (height + 1) / 2,
			&amp;halfrect )) ) { 
			layer_free( layer );
			return( NULL );
		}
		layer-&gt;n = layer-&gt;below-&gt;n + 1;
	}
	else
		layer-&gt;n = 0;
#ifdef DEBUG
	printf( "pyramid_build:\n" );
	printf( "\tn = %d\n", layer-&gt;n );
	printf( "\twidth = %d, height = %d\n", width, height );
	printf( "\tXsize = %d, Ysize = %d\n", 
		layer-&gt;image-&gt;Xsize, layer-&gt;image-&gt;Ysize );
	printf( "\ttiles_across = %d, tiles_down = %d\n", 
		layer-&gt;tiles_across, layer-&gt;tiles_down ); 
	printf( "\treal_pixels.left = %d, real_pixels.top = %d\n", 
		real_pixels-&gt;left, real_pixels-&gt;top ); 
	printf( "\treal_pixels.width = %d, real_pixels.height = %d\n", 
		real_pixels-&gt;width, real_pixels-&gt;height ); 
	return( layer );
}
static int
write_dzi( VipsForeignSaveDz *dz )
{
	GsfOutput *out;
	char buf[VIPS_PATH_MAX];
	char *p;
	vips_snprintf( buf, VIPS_PATH_MAX, "%s.dzi", dz-&gt;basename );
	out = vips_gsf_path( dz-&gt;tree, buf, NULL ); 
	vips_snprintf( buf, VIPS_PATH_MAX, "%s", dz-&gt;suffix + 1 );
	if( (p = (char *) vips__find_rightmost_brackets( buf )) )
		*p = '\0';
	gsf_output_printf( out, "&lt;?xml "
		"version=\"1.0\" encoding=\"UTF-8\"?&gt;\n" ); 
	gsf_output_printf( out, "&lt;Image "
		"xmlns=\"http://schemas.microsoft.com/deepzoom/2008\"\n" );
	gsf_output_printf( out, "  Format=\"%s\"\n", buf );
	gsf_output_printf( out, "  Overlap=\"%d\"\n", dz-&gt;overlap );
	gsf_output_printf( out, "  TileSize=\"%d\"\n", dz-&gt;tile_size );
	gsf_output_printf( out, "  &gt;\n" ); 
	gsf_output_printf( out, "  &lt;Size \n" );
	gsf_output_printf( out, "    Height=\"%d\"\n", dz-&gt;layer-&gt;height );
	gsf_output_printf( out, "    Width=\"%d\"\n", dz-&gt;layer-&gt;width );
	gsf_output_printf( out, "  /&gt;\n" ); 
	gsf_output_printf( out, "&lt;/Image&gt;\n" );
	(void) gsf_output_close( out );
	g_object_unref( out );
	return( 0 );
}
static int
write_properties( VipsForeignSaveDz *dz )
{
	GsfOutput *out;
	out = vips_gsf_path( dz-&gt;tree, "ImageProperties.xml", NULL ); 
	gsf_output_printf( out, "&lt;IMAGE_PROPERTIES "
		"WIDTH=\"%d\" HEIGHT=\"%d\" NUMTILES=\"%d\" "
		"NUMIMAGES=\"1\" VERSION=\"1.8\" TILESIZE=\"%d\" /&gt;\n",
		dz-&gt;layer-&gt;width,
		dz-&gt;layer-&gt;height,
		dz-&gt;tile_count,
		dz-&gt;tile_size );
	(void) gsf_output_close( out );
	g_object_unref( out );
	return( 0 );
}
static int
write_blank( VipsForeignSaveDz *dz )
{
	VipsForeignSave *save = (VipsForeignSave *) dz;
	VipsImage *x, *t;
	int n;
	VipsArea *ones;
	double *d;
	double *bg;
	int i;
	GsfOutput *out; 
	bg = (double *) vips_area_get_data( VIPS_AREA( save-&gt;background ), 
		NULL, &amp;n, NULL, NULL );
	if( vips_black( &amp;x, dz-&gt;tile_size, dz-&gt;tile_size, "bands", n, NULL ) ) 
		return( -1 );
	ones = vips_area_new_array( G_TYPE_DOUBLE, sizeof( double ), n );
	d = (double *) vips_area_get_data( ones, NULL, NULL, NULL, NULL );
	for( i = 0; i &lt; n; i++ )
		d[i] = 1.0; 
	if( vips_linear( x, &amp;t, d, bg, n, NULL ) ) {
		vips_area_unref( ones );
		g_object_unref( x );
		return( -1 );
	}
	vips_area_unref( ones );
	g_object_unref( x );
	x = t;
	out = vips_gsf_path( dz-&gt;tree, "blank.png", NULL ); 
	if( write_image( dz, out, x, ".png" ) ) {
		g_object_unref( out );
		g_object_unref( x );
		return( -1 );
	}
	g_object_unref( out );
	g_object_unref( x );
	return( 0 );
}
static int
write_json( VipsForeignSaveDz *dz )
{
	const char *name = dz-&gt;basename ? dz-&gt;basename : "untitled";
	const char *suffix = dz-&gt;file_suffix[0] == '.' ? 
		dz-&gt;file_suffix + 1 : dz-&gt;file_suffix;
	GsfOutput *out;
	int i;
	out = vips_gsf_path( dz-&gt;tree, "info.json", NULL ); 
	gsf_output_printf( out, 
		"{\n"
		"  \"@context\": \"http://iiif.io/api/image/2/context.json\",\n"
		"  \"@id\": \"%s/%s\",\n" 
		"  \"profile\": [\n"
		"    \"http://iiif.io/api/image/2/level0.json\",\n"
		"    {\n" 
		"      \"formats\": [\n"
		"        \"%s\"\n"
		"      ],\n"
		"      \"qualities\": [\n"
		"        \"default\"\n"
		"      ]\n"
		"    }\n"
		"  ],\n"
		"  \"protocol\": \"http://iiif.io/api/image\",\n", 
		dz-&gt;id ? dz-&gt;id : "https://example.com/iiif",
		name, 
		suffix );
	gsf_output_printf( out, 
		"  \"tiles\": [\n"
		"    {\n"
		"      \"scaleFactors\": [\n" );
	for( i = 0; i &lt; dz-&gt;layer-&gt;n; i++ ) {
		gsf_output_printf( out, 
			"        %d",
				1 &lt;&lt; i );
		if( i != dz-&gt;layer-&gt;n - 1 )
			gsf_output_printf( out, "," );
		gsf_output_printf( out, "\n" );
	}
	gsf_output_printf( out, 
		"      ],\n"
		"      \"width\": %d\n"
		"    }\n"
		"  ],\n", dz-&gt;tile_size );
	gsf_output_printf( out, 
		"  \"width\": %d,\n"
		"  \"height\": %d\n", 
			dz-&gt;layer-&gt;width,
			dz-&gt;layer-&gt;height );
	gsf_output_printf( out, 
		"}\n" );
	(void) gsf_output_close( out );
	g_object_unref( out );
	return( 0 );
}
static int
write_vips_meta( VipsForeignSaveDz *dz )
{
	VipsForeignSave *save = (VipsForeignSave *) dz;
	char *dump;
	GsfOutput *out;
	if( !(dump = vips__xml_properties( save-&gt;ready )) )
                return( -1 );
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
		out = vips_gsf_path( dz-&gt;tree, 
			"vips-properties.xml", dz-&gt;root_name, NULL );
	else
		out = vips_gsf_path( dz-&gt;tree, "vips-properties.xml", NULL );
	gsf_output_write( out, strlen( dump ), (guchar *) dump ); 
	(void) gsf_output_close( out );
	g_object_unref( out );
	g_free( dump );
	return( 0 );
}
static void
build_scan_property( VipsDbuf *dbuf, VipsImage *image, 
	const char *vips_name, const char *szi_name )
{
	const char *str;
	GValue value = { 0 };
	GValue save_value = { 0 };
	GType type;
	if( !vips_image_get_typeof( image, vips_name ) )
		return;
	if( vips_image_get( image, vips_name, &amp;value ) )
		return;
	type = G_VALUE_TYPE( &amp;value );
	if( !g_value_type_transformable( type, VIPS_TYPE_SAVE_STRING ) ) {
		g_value_unset( &amp;value );
		return;
	}
	g_value_init( &amp;save_value, VIPS_TYPE_SAVE_STRING );
	if( !g_value_transform( &amp;value, &amp;save_value ) ) {
		g_value_unset( &amp;value );
		return;
	}
	g_value_unset( &amp;value );
	if( !(str = vips_value_get_save_string( &amp;save_value )) ) {
		g_value_unset( &amp;save_value );
		return;
	}
	if( !g_utf8_validate( str, -1, NULL ) ) {
		g_value_unset( &amp;save_value );
		return;
	}
	vips_dbuf_writef( dbuf, "    &lt;property&gt;\n" );
	vips_dbuf_writef( dbuf, "      &lt;name&gt;" );
	vips_dbuf_write_amp( dbuf, szi_name );
	vips_dbuf_writef( dbuf, "&lt;/name&gt;\n" );
	vips_dbuf_writef( dbuf, "      &lt;value type=\"%s\"&gt;",
		g_type_name( type )  );
	vips_dbuf_write_amp( dbuf, str );
	vips_dbuf_writef( dbuf, "&lt;/value&gt;\n" );
	vips_dbuf_writef( dbuf, "    &lt;/property&gt;\n" );
	g_value_unset( &amp;save_value );
}
static char *scan_property_names[][2] = {
	{ "openslide.vendor", "Vendor" },
	{ "openslide.objective-power", "ObjectiveMagnification" },
	{ "openslide.mpp-x", "MicronsPerPixelX" },
	{ "openslide.mpp-y", "MicronsPerPixelY" },
	{ "width", "ImageWidth" },
	{ "height", "ImageHeight" }
};
char *
build_scan_properties( VipsImage *image )
{
	VipsDbuf dbuf;
	char *date;
	int i;
	date = vips__get_iso8601();
	vips_dbuf_init( &amp;dbuf );
	vips_dbuf_writef( &amp;dbuf, "&lt;?xml version=\"1.0\"?&gt;\n" ); 
	vips_dbuf_writef( &amp;dbuf, "&lt;image xmlns=\"http://www.pathozoom.com/szi\""
		" date=\"%s\" version=\"1.0\"&gt;\n", date );
	vips_dbuf_writef( &amp;dbuf, "  &lt;properties&gt;\n" );  
	g_free( date ); 
	for( i = 0; i &lt; VIPS_NUMBER( scan_property_names ); i++ )
		build_scan_property( &amp;dbuf, image,
			scan_property_names[i][0],
			scan_property_names[i][1] );
	vips_dbuf_writef( &amp;dbuf, "  &lt;/properties&gt;\n" );
	vips_dbuf_writef( &amp;dbuf, "&lt;/image&gt;\n" );
	return( (char *) vips_dbuf_steal( &amp;dbuf, NULL ) ); 
}
static int
write_scan_properties( VipsForeignSaveDz *dz )
{
	VipsForeignSave *save = (VipsForeignSave *) dz;
	char *dump;
	GsfOutput *out;
	if( !(dump = build_scan_properties( save-&gt;ready )) )
                return( -1 );
	out = vips_gsf_path( dz-&gt;tree, "scan-properties.xml", NULL );
	gsf_output_write( out, strlen( dump ), (guchar *) dump );
	(void) gsf_output_close( out );
	g_object_unref( out );
	g_free( dump );
	return( 0 );
}
static void *
write_associated_images( VipsImage *image,
	const char *field, GValue *value, void *a )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
	if( vips_isprefix( "openslide.associated.", field ) ) {
		VipsImage *associated;
		const char *p;
		const char *q;
		GsfOutput *out;
		char buf[VIPS_PATH_MAX];
		p = field + strlen( "openslide.associated." );
		if( (q = strrchr( p, '/' )) )
			p = q + 1;
		if( vips_image_get_image( image, field, &amp;associated ) )
			return( image );
		vips_snprintf( buf, VIPS_PATH_MAX, "%s.jpg", p );
		out = vips_gsf_path( dz-&gt;tree, buf, "associated_images", NULL );
		if( write_image( dz, out, associated, ".jpg" ) ) {
			g_object_unref( out );
			g_object_unref( associated );
			return( image );
		}
		g_object_unref( out );
		g_object_unref( associated );
	}
	return( NULL );
}
static int
write_associated( VipsForeignSaveDz *dz )
{
	VipsForeignSave *save = (VipsForeignSave *) dz;
	if( vips_image_map( save-&gt;ready, write_associated_images, dz ) )
		return( -1 );
	return( 0 );
}
typedef struct _Strip {
	Layer *layer; 
	VipsImage *image;
	int x;
} Strip;
static void
strip_free( Strip *strip )
{
	g_object_unref( strip-&gt;image );
}
static void
strip_init( Strip *strip, Layer *layer )
{
	VipsForeignSaveDz *dz = layer-&gt;dz;
	VipsRect line, image;
	strip-&gt;layer = layer;
	strip-&gt;image = NULL;
	strip-&gt;x = 0;
	image.left = 0;
	image.top = 0;
	image.width = layer-&gt;image-&gt;Xsize;
	image.height = layer-&gt;height;
	line.left = 0;
	line.top = layer-&gt;y;
	line.width = image.width;
	line.height = dz-&gt;tile_size;
	vips_rect_marginadjust( &amp;line, dz-&gt;tile_margin );
	vips_rect_intersectrect( &amp;image, &amp;line, &amp;line );
	if( !(strip-&gt;image = vips_image_new_from_memory( 
		VIPS_REGION_ADDR( layer-&gt;strip, 0, line.top ),
		VIPS_IMAGE_SIZEOF_LINE( layer-&gt;image ) * line.height,
		line.width, line.height, 
		layer-&gt;image-&gt;Bands, layer-&gt;image-&gt;BandFmt )) ) {
		strip_free( strip );
		return;
	}
	if( vips__image_meta_copy( strip-&gt;image, layer-&gt;image ) ) {
		strip_free( strip );
		return;
	}
	strip-&gt;image-&gt;Type = layer-&gt;image-&gt;Type;
}
static int
strip_allocate( VipsThreadState *state, void *a, gboolean *stop )
{
	Strip *strip = (Strip *) a;
	Layer *layer = strip-&gt;layer;
	VipsForeignSaveDz *dz = layer-&gt;dz;
	VipsRect image;
#ifdef DEBUG_VERBOSE
	printf( "strip_allocate\n" );
	if( strip-&gt;x / dz-&gt;tile_step &gt;= layer-&gt;tiles_across ) {
		*stop = TRUE;
#ifdef DEBUG_VERBOSE
		printf( "strip_allocate: done\n" );
		return( 0 );
	}
	image.left = 0;
	image.top = 0;
	image.width = layer-&gt;width;
	image.height = layer-&gt;height;
	state-&gt;pos.left = strip-&gt;x;
	state-&gt;pos.top = layer-&gt;y;
	state-&gt;pos.width = dz-&gt;tile_size;
	state-&gt;pos.height = dz-&gt;tile_size;
	vips_rect_marginadjust( &amp;state-&gt;pos, dz-&gt;tile_margin );
	vips_rect_intersectrect( &amp;image, &amp;state-&gt;pos, &amp;state-&gt;pos );
	state-&gt;x = strip-&gt;x;
	state-&gt;y = layer-&gt;y;
	strip-&gt;x += dz-&gt;tile_step;
	return( 0 );
}
static GsfOutput *
tile_name( Layer *layer, int x, int y )
{
	VipsForeignSaveDz *dz = layer-&gt;dz;
	VipsForeignSave *save = (VipsForeignSave *) dz;
	GsfOutput *out; 
	char name[VIPS_PATH_MAX];
	char dirname[VIPS_PATH_MAX];
	char dirname2[VIPS_PATH_MAX];
	Layer *p;
	int n;
	switch( dz-&gt;layout ) {
	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
		vips_snprintf( name, VIPS_PATH_MAX, 
			"%d_%d%s", x, y, dz-&gt;file_suffix );
		out = vips_gsf_path( dz-&gt;tree, name, 
			dz-&gt;root_name, dirname, NULL );
		break;
	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
		n = 0;
		for( p = layer-&gt;below; p; p = p-&gt;below )
			n += p-&gt;tiles_across * p-&gt;tiles_down;
		n += y * layer-&gt;tiles_across + x;
		vips_snprintf( dirname, VIPS_PATH_MAX, "TileGroup%d", n / 256 );
		vips_snprintf( name, VIPS_PATH_MAX, 
			"%d-%d-%d%s", layer-&gt;n, x, y, dz-&gt;file_suffix );
		dz-&gt;tile_count += 1;
		out = vips_gsf_path( dz-&gt;tree, name, dirname, NULL );
		break;
	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d", y );
		vips_snprintf( name, VIPS_PATH_MAX, 
			"%d%s", x, dz-&gt;file_suffix );
		out = vips_gsf_path( dz-&gt;tree, name, dirname, dirname2, NULL );
		break;
	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
{
		int left = x * dz-&gt;tile_size * layer-&gt;sub;
		int top = y * dz-&gt;tile_size * layer-&gt;sub;
		int width = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
			save-&gt;ready-&gt;Xsize - left );
		int height = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
			save-&gt;ready-&gt;Ysize - top );
		int size = VIPS_MIN( dz-&gt;tile_size, 
			layer-&gt;width - x * dz-&gt;tile_size );
		vips_snprintf( dirname, VIPS_PATH_MAX, "%d,%d,%d,%d",
			left, top, width, height );
		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d,", size );
		vips_snprintf( name, VIPS_PATH_MAX, "default%s", 
			dz-&gt;file_suffix );
		out = vips_gsf_path( dz-&gt;tree, 
			name, dirname, dirname2, "0", NULL );
}
		break;
	default:
		g_assert_not_reached();
		out = NULL;
	}
#ifdef DEBUG_VERBOSE
	printf( "tile_name: writing to %s\n", name );
	return( out );
}
static gboolean
tile_equal( VipsImage *image, int threshold, VipsPel * restrict ink )
{
	const int bytes = VIPS_IMAGE_SIZEOF_PEL( image );
	VipsRect rect;
	VipsRegion *region;
	int x, y, b;
	region = vips_region_new( image ); 
	rect.left = 0;
	rect.top = 0;
	rect.width = image-&gt;Xsize;
	rect.height = image-&gt;Ysize;
	if( vips_region_prepare( region, &amp;rect ) ) {
		g_object_unref( region );
		return( FALSE ); 
	}
	for( y = 0; y &lt; image-&gt;Ysize; y++ ) {
		VipsPel * restrict p = VIPS_REGION_ADDR( region, 0, y ); 
		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
			for( b = 0; b &lt; bytes; b++ ) 
				if( VIPS_ABS( p[b] - ink[b] ) &gt; threshold ) {
					g_object_unref( region );
					return( FALSE ); 
				}
			p += bytes;
		}
	}
	g_object_unref( region );
	return( TRUE );
}
static int
strip_work( VipsThreadState *state, void *a )
{
	Strip *strip = (Strip *) a;
	Layer *layer = strip-&gt;layer;
	VipsForeignSaveDz *dz = layer-&gt;dz;
	VipsForeignSave *save = (VipsForeignSave *) dz;
	VipsImage *x;
	VipsImage *t;
	GsfOutput *out; 
#ifdef DEBUG_VERBOSE
	printf( "strip_work\n" );
	if( dz-&gt;centre ) {
		VipsRect tile; 
		tile.left = state-&gt;x;
		tile.top = state-&gt;y;
		tile.width = dz-&gt;tile_size;
		tile.height = dz-&gt;tile_size;
		if( !vips_rect_overlapsrect( &amp;tile, &amp;layer-&gt;real_pixels ) ) {
#ifdef DEBUG_VERBOSE
			printf( "strip_work: skipping tile %d x %d\n", 
				state-&gt;x / dz-&gt;tile_size, 
				state-&gt;y / dz-&gt;tile_size ); 
			return( 0 ); 
		}
	}
	g_assert( vips_object_sanity( VIPS_OBJECT( strip-&gt;image ) ) );
	if( vips_extract_area( strip-&gt;image, &amp;x, 
		state-&gt;pos.left, 0, 
		state-&gt;pos.width, state-&gt;pos.height, NULL ) ) 
		return( -1 );
	if( dz-&gt;skip_blanks &gt;= 0 &amp;&amp;
		tile_equal( x, dz-&gt;skip_blanks, dz-&gt;ink ) ) { 
		g_object_unref( x );
#ifdef DEBUG_VERBOSE
		printf( "strip_work: skipping blank tile %d x %d\n", 
			state-&gt;x / dz-&gt;tile_size, 
			state-&gt;y / dz-&gt;tile_size ); 
		return( 0 ); 
	}
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
		if( vips_embed( x, &amp;t, 0, 0, dz-&gt;tile_size, dz-&gt;tile_size,
			"background", save-&gt;background,
			NULL ) ) {
			g_object_unref( x );
			return( -1 );
		}
		g_object_unref( x );
		x = t;
	}
	g_mutex_lock( vips__global_lock );
	out = tile_name( layer, 
		state-&gt;x / dz-&gt;tile_step, state-&gt;y / dz-&gt;tile_step );
	g_mutex_unlock( vips__global_lock );
	if( write_image( dz, out, x, dz-&gt;suffix ) ) {
		g_object_unref( out );
		g_object_unref( x );
		return( -1 );
	}
	g_object_unref( out );
	g_object_unref( x );
#ifdef DEBUG_VERBOSE
	printf( "strip_work: success\n" );
	return( 0 );
}
static int
strip_save( Layer *layer )
{
	Strip strip;
#ifdef DEBUG
	printf( "strip_save: n = %d, y = %d\n", layer-&gt;n, layer-&gt;y );
	strip_init( &amp;strip, layer );
	if( vips_threadpool_run( strip.image, 
		vips_thread_state_new, strip_allocate, strip_work, NULL, 
		&amp;strip ) ) {
		strip_free( &amp;strip );
		return( -1 );
	}
	strip_free( &amp;strip );
#ifdef DEBUG
	printf( "strip_save: success\n" ); 
	return( 0 );
}
static void
layer_generate_extras( Layer *layer )
{
	VipsRegion *strip = layer-&gt;strip;
	g_assert( strip-&gt;valid.width == layer-&gt;image-&gt;Xsize );
	if( layer-&gt;width &lt; layer-&gt;image-&gt;Xsize ) {
		int ps = VIPS_IMAGE_SIZEOF_PEL( strip-&gt;im );
		int b, y;
		for( y = 0; y &lt; strip-&gt;valid.height; y++ ) {
			VipsPel *p = VIPS_REGION_ADDR( strip, 
				layer-&gt;width - 1, strip-&gt;valid.top + y );
			VipsPel *q = p + ps;
			for( b = 0; b &lt; ps; b++ )
				q[b] = p[b];
		}
	}
	if( layer-&gt;height &lt; layer-&gt;image-&gt;Ysize ) {
		VipsRect last;
		last.left = 0;
		last.top = layer-&gt;image-&gt;Ysize - 2;
		last.width = layer-&gt;image-&gt;Xsize;
		last.height = 2;
		vips_rect_intersectrect( &amp;last, &amp;strip-&gt;valid, &amp;last );
		if( last.height == 2 ) {
			last.height = 1;
			vips_region_copy( strip, strip, &amp;last, 
				0, last.top + 1 );
		}
	}
}
static int strip_arrived( Layer *layer );
static int
strip_shrink( Layer *layer )
<a name="0"></a>{
	Layer *below = layer-&gt;below;
	VipsRegion *from = layer-&gt;strip;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	VipsRegion *to = below-&gt;strip;
	VipsForeignSaveDz *dz = layer-&gt;dz;
	VipsRegionShrink region_shrink = dz-&gt;region_shrink;
	VipsRect target;
	VipsRect source;
#ifdef DEBUG
	printf( "strip_shrink: %d lines in layer %d to layer %d\n", 
		from-&gt;valid.height, layer-&gt;n, below-&gt;n ); 
	layer_generate_extras( layer );
	for(;;) {
		target.left = 0;
		target.top = below-&gt;write_y;
		target.width = below-&gt;image-&gt;Xsize;
		target.height = to-&gt;valid.height;
		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );
		source.left = target.left * 2;
		source.top = target.top * 2;
		source.width = target.width * 2;
		source.height = target.height * 2;
		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );
		target.left = source.left / 2;
		target.top = source.top / 2;
		target.width = source.width / 2;
		target.height = source.height / 2;
		if( vips_rect_isempty( &amp;target ) )
			break;
		(void) vips_region_shrink_method( from, to, 
			&amp;target, region_shrink );
		below-&gt;write_y += target.height;
		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
			below-&gt;write_y == below-&gt;height ) {
			if( strip_arrived( below ) )
				return( -1 );
		}
	}
	return( 0 );
}
static int
strip_arrived( Layer *layer )
{
	VipsForeignSaveDz *dz = layer-&gt;dz;</b></font>
	VipsRect new_strip;
	VipsRect overlap;
	VipsRect image_area;
#ifdef DEBUG
	printf( "strip_arrived: layer %d, strip at %d, height %d\n", 
<a name="2"></a>		layer-&gt;n, layer-&gt;y, layer-&gt;strip-&gt;valid.height ); 
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( strip_save( layer ) )
		return( -1 );
	if( layer-&gt;below &amp;&amp;
		strip_shrink( layer ) )
		return( -1 );
	layer-&gt;y += dz-&gt;tile_step;
	new_strip.left = 0;
	new_strip.top = layer-&gt;y - dz-&gt;tile_margin;
	new_strip.width = layer-&gt;image-&gt;Xsize;
	new_strip.height = dz-&gt;tile_size + 2 * dz-&gt;tile_margin;
	image_area.left = 0;
	image_area.top = 0;
	image_area.width = layer-&gt;image-&gt;Xsize;
	image_area.height = layer-&gt;image-&gt;Ysize;
	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 
	if( (new_strip.height &amp; 1) == 1 )
		new_strip.height += 1;
	if( VIPS_RECT_BOTTOM( &amp;new_strip ) == layer-&gt;height )</b></font>
		new_strip.height = layer-&gt;image-&gt;Ysize - new_strip.top;
	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
	if( !vips_rect_isempty( &amp;overlap ) ) {
		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
			return( -1 );
		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
			&amp;overlap, overlap.left, overlap.top );
	}
	if( !vips_rect_isempty( &amp;new_strip ) ) {
		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) )
			return( -1 );
		if( !vips_rect_isempty( &amp;overlap ) ) 
			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
				&amp;overlap, overlap.left, overlap.top );
	}
	return( 0 );
}
static int
strip_flush( Layer *layer )
{
	if( layer-&gt;y &lt; layer-&gt;height )
		if( strip_save( layer ) )
			return( -1 );
	if( layer-&gt;below )
<a name="1"></a>		if( strip_flush( layer-&gt;below ) )
			return( -1 );
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}
static int
pyramid_strip( VipsRegion *region, VipsRect *area, void *a )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
	Layer *layer = dz-&gt;layer;
#ifdef DEBUG
	printf( "pyramid_strip: strip at %d, height %d\n", 
		area-&gt;top, area-&gt;height );
	for(;;) {
		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
		VipsRect target;
		target.left = 0;
		target.top = layer-&gt;write_y;
		target.width = layer-&gt;image-&gt;Xsize;
		target.height = to-&gt;height;
		vips_rect_intersectrect( &amp;target, to, &amp;target );
		vips_rect_intersectrect( &amp;target, area, &amp;target );
		if( vips_rect_isempty( &amp;target ) ) 
			break;
		vips_region_copy( region, layer-&gt;strip, 
			&amp;target, target.left, target.top );
		layer-&gt;write_y += target.height;
		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
			layer-&gt;write_y == layer-&gt;height ) {
			if( strip_arrived( layer ) ) 
				return( -1 );
		}
	}</b></font>
	if( layer-&gt;write_y == layer-&gt;height ) {
#ifdef DEBUG
		printf( "pyramid_strip: flushing ..\n" ); 
		if( strip_flush( layer ) )
			return( -1 );
	}
	return( 0 );
}
static int
vips_foreign_save_dz_build( VipsObject *object )
{
	VipsForeignSave *save = (VipsForeignSave *) object;
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz ); 
	VipsRect real_pixels; 
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ||
		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
		if( !vips_object_argument_isset( object, "overlap" ) )
			dz-&gt;overlap = 0;
		if( !vips_object_argument_isset( object, "suffix" ) )
			VIPS_SETSTR( dz-&gt;suffix, ".jpg" );
	}
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
		if( !vips_object_argument_isset( object, "tile_size" ) )
			dz-&gt;tile_size = 256;
	}
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
		if( !vips_object_argument_isset( object, "tile_size" ) )
			dz-&gt;tile_size = 512;
	}
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
		!vips_object_argument_isset( object, "skip_blanks" ) )
		dz-&gt;skip_blanks = 5;
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) { 
		dz-&gt;tile_margin = dz-&gt;overlap;
		dz-&gt;tile_step = dz-&gt;tile_size; 
	}
	else {
		dz-&gt;tile_margin = 0;
		dz-&gt;tile_step = dz-&gt;tile_size - dz-&gt;overlap;
	}
	if( dz-&gt;tile_step &lt;= 0 ) {
		vips_error( "dzsave", "%s", _( "overlap too large" ) );
		return( -1 );
	}
	if( !vips_object_argument_isset( object, "background" ) ) {
		VipsArrayDouble *background; 
		background = vips_array_double_newv( 1, 255.0 );
		g_object_set( object, "background", background, NULL );
		vips_area_unref( VIPS_AREA( background ) ); 
	}
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
		if( !vips_object_argument_isset( object, "depth" ) )
			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL;
	}
	else
		if( !vips_object_argument_isset( object, "depth" ) )
			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONETILE;
	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
		build( object ) )
		return( -1 );
{
	VipsImage *z;
	if( vips_rot( save-&gt;ready, &amp;z, dz-&gt;angle, NULL ) )
		return( -1 );
	VIPS_UNREF( save-&gt;ready );
	save-&gt;ready = z;
}
	if( dz-&gt;skip_blanks &gt;= 0 ) {
		if( !(dz-&gt;ink = vips__vector_to_ink( 
			class-&gt;nickname, save-&gt;ready,
			VIPS_AREA( save-&gt;background )-&gt;data, NULL, 
			VIPS_AREA( save-&gt;background )-&gt;n )) )
			return( -1 );
	}
	real_pixels.left = 0;
	real_pixels.top = 0;
	real_pixels.width = save-&gt;ready-&gt;Xsize;
	real_pixels.height = save-&gt;ready-&gt;Ysize;
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
		dz-&gt;centre ) {
		VipsImage *z;
		Layer *layer;
		int n_layers;
		int size;
		if( !(layer = pyramid_build( dz, NULL, 
			save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize,
			&amp;real_pixels )) )
			return( -1 );
		n_layers = layer-&gt;n;
		g_assert( n_layers &lt; 30 );
		layer_free( layer );
		size = dz-&gt;tile_size * (1 &lt;&lt; n_layers);
		real_pixels.left = (size - save-&gt;ready-&gt;Xsize) / 2;
		real_pixels.top = (size - save-&gt;ready-&gt;Ysize) / 2;
		if( vips_embed( save-&gt;ready, &amp;z, 
			real_pixels.left, real_pixels.top,
			size, size,
			"background", save-&gt;background,
			NULL ) ) 
			return( -1 );
		VIPS_UNREF( save-&gt;ready );
		save-&gt;ready = z;
#ifdef DEBUG
		printf( "centre: centring within a %d x %d image\n", 
			size, size );
	}
#ifdef DEBUG
	printf( "vips_foreign_save_dz_build: tile_size == %d\n", 
		dz-&gt;tile_size );
	printf( "vips_foreign_save_dz_build: overlap == %d\n", 
		dz-&gt;overlap );
	printf( "vips_foreign_save_dz_build: tile_margin == %d\n", 
		dz-&gt;tile_margin );
	printf( "vips_foreign_save_dz_build: tile_step == %d\n", 
		dz-&gt;tile_step );
	if( !(dz-&gt;layer = pyramid_build( dz, NULL, 
		save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize, &amp;real_pixels )) )
		return( -1 );
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
		dz-&gt;root_name = g_strdup_printf( "%s_files", dz-&gt;basename );
	else
		dz-&gt;root_name = g_strdup( dz-&gt;basename );
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	vips__filename_split8( dz-&gt;suffix, filename, option_string );
	dz-&gt;file_suffix = g_strdup( filename ); 
}
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS &amp;&amp;
		dz-&gt;dirname &amp;&amp;
		vips_existsf( "%s/%s_files", dz-&gt;dirname, dz-&gt;basename ) ) {
		vips_error( "dzsave", 
			_( "output directory %s/%s_files exists" ),
			dz-&gt;dirname, dz-&gt;basename );
		return( -1 ); 
	}
	switch( dz-&gt;container ) {
	case VIPS_FOREIGN_DZ_CONTAINER_FS:
		if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
			char name[VIPS_PATH_MAX];
			int fd;
			GsfOutput *out;
			GError *error = NULL;
			vips_snprintf( name, VIPS_PATH_MAX, "%s-XXXXXX", 
				dz-&gt;basename ); 
			dz-&gt;tempdir = g_build_filename( dz-&gt;dirname, 
				name, NULL );
			if( (fd = g_mkstemp( dz-&gt;tempdir )) == -1 ) {
				vips_error(  class-&gt;nickname,
					_( "unable to make temporary file %s" ),
					dz-&gt;tempdir );
				return( -1 );
			}
			close( fd );
			g_unlink( dz-&gt;tempdir );
			if( !(out = (GsfOutput *) 
				gsf_outfile_stdio_new( dz-&gt;tempdir, 
					&amp;error )) ) {
				vips_g_error( &amp;error );
				return( -1 );
			}
			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
		}
		else { 
			GsfOutput *out;
			GError *error = NULL;
			char name[VIPS_PATH_MAX];
			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s", 
				dz-&gt;dirname, dz-&gt;basename ); 
			if( !(out = (GsfOutput *) 
				gsf_outfile_stdio_new( name, &amp;error )) ) {
				vips_g_error( &amp;error );
				return( -1 );
			}
			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
		}
		break;
	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
{
		GsfOutput *zip;
		GsfOutput *out2;
		GError *error = NULL;
		char name[VIPS_PATH_MAX];
		if( dz-&gt;dirname ) { 
			const char *suffix =
				dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI ?
					"szi" : "zip";
			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s.%s",
				dz-&gt;dirname, dz-&gt;basename, suffix );
			if( !(dz-&gt;out =
				gsf_output_stdio_new( name, &amp;error )) ) {
				vips_g_error( &amp;error );
				return( -1 );
			}
		}
		else
			dz-&gt;out = gsf_output_memory_new();
		if( !(zip = (GsfOutput *) 
			gsf_outfile_zip_new( dz-&gt;out, &amp;error )) ) {
			vips_g_error( &amp;error );
			return( -1 );
		}
		out2 = gsf_outfile_new_child_full( (GsfOutfile *) zip, 
			dz-&gt;basename, TRUE,
			"compression-level", GSF_ZIP_STORED, 
			NULL );
#ifndef HAVE_GSF_DEFLATE_LEVEL
		if( dz-&gt;compression &gt; 0 ) {
			g_warning( "%s", 
				_( "deflate-level not supported by libgsf, "
				"using default compression" ) ); 
			dz-&gt;compression = -1;
		}
		dz-&gt;tree = vips_gsf_tree_new( out2, dz-&gt;compression );
		dz-&gt;tree-&gt;container = zip; 
}
		break;
	default:
		g_assert_not_reached();
	}
	if( vips_sink_disc( save-&gt;ready, pyramid_strip, dz ) )
		return( -1 );
	switch( dz-&gt;layout ) {
	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
		if( write_dzi( dz ) )
			return( -1 );
		break;
	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
		if( write_properties( dz ) )
			return( -1 );
		break;
	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
		if( write_blank( dz ) )
			return( -1 );
		break;
	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
		if( write_json( dz ) )
			return( -1 );
		break;
	default:
		g_assert_not_reached();
	}
	if( dz-&gt;properties &amp;&amp;
		write_vips_meta( dz ) )
		return( -1 );
	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
		write_scan_properties( dz ) )
		return( -1 );
	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
		write_associated( dz ) )
		return( -1 );
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS ) { 
		char old_name[VIPS_PATH_MAX];
		char new_name[VIPS_PATH_MAX];
		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s.dzi", 
			dz-&gt;tempdir, dz-&gt;basename );
		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s.dzi", 
			dz-&gt;dirname, dz-&gt;basename );
		if( vips_rename( old_name, new_name ) )
			return( -1 ); 
		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s_files", 
			dz-&gt;tempdir, dz-&gt;basename );
		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s_files", 
			dz-&gt;dirname, dz-&gt;basename );
		if( vips_rename( old_name, new_name ) )
			return( -1 ); 
		if( vips_rmdirf( "%s", dz-&gt;tempdir ) )
			return( -1 ); 
	}
	if( vips_gsf_tree_close( dz-&gt;tree ) )
		return( -1 ); 
	dz-&gt;tree = NULL; 
	if( iszip( dz-&gt;container ) &amp;&amp;
		dz-&gt;dirname != NULL ) 
		VIPS_FREEF( g_object_unref, dz-&gt;out );
	return( 0 );
}
#define UC VIPS_FORMAT_UCHAR
#define C VIPS_FORMAT_CHAR
#define US VIPS_FORMAT_USHORT
#define S VIPS_FORMAT_SHORT
#define UI VIPS_FORMAT_UINT
#define I VIPS_FORMAT_INT
#define F VIPS_FORMAT_FLOAT
#define X VIPS_FORMAT_COMPLEX
#define D VIPS_FORMAT_DOUBLE
#define DX VIPS_FORMAT_DPCOMPLEX
static int bandfmt_dz[10] = {
   UC, C,  US, S,  UI, I,  F,  F,  D,  D
};
static const char *dz_suffs[] = { ".dz", NULL };
static void
vips_foreign_save_dz_class_init( VipsForeignSaveDzClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
	gobject_class-&gt;dispose = vips_foreign_save_dz_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "dzsave_base";
	object_class-&gt;description = _( "save image to deep zoom format" );
	object_class-&gt;build = vips_foreign_save_dz_build;
	foreign_class-&gt;suffs = dz_suffs;
	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
	save_class-&gt;format_table = bandfmt_dz;
	save_class-&gt;coding[VIPS_CODING_LABQ] = TRUE;
	VIPS_ARG_STRING( class, "basename", 2, 
		_( "Base name" ),
		_( "Base name to save to" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, basename ),
		NULL );
	VIPS_ARG_ENUM( class, "layout", 8, 
		_( "Layout" ), 
		_( "Directory layout" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, layout ),
		VIPS_TYPE_FOREIGN_DZ_LAYOUT, VIPS_FOREIGN_DZ_LAYOUT_DZ ); 
	VIPS_ARG_STRING( class, "suffix", 9, 
		_( "suffix" ), 
		_( "Filename suffix for tiles" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, suffix ),
		".jpeg" );
	VIPS_ARG_INT( class, "overlap", 10, 
		_( "Overlap" ), 
		_( "Tile overlap in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, overlap ),
		0, 8192, 1 );
	VIPS_ARG_INT( class, "tile_size", 11, 
		_( "Tile size" ), 
		_( "Tile size in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
		1, 8192, 254 );
	VIPS_ARG_ENUM( class, "depth", 13, 
		_( "Depth" ), 
		_( "Pyramid depth" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, depth ),
		VIPS_TYPE_FOREIGN_DZ_DEPTH, VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ); 
	VIPS_ARG_BOOL( class, "centre", 13, 
		_( "Center" ), 
		_( "Center image in tile" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, centre ),
		FALSE );
	VIPS_ARG_ENUM( class, "angle", 14, 
		_( "Angle" ), 
		_( "Rotate image during save" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, angle ),
		VIPS_TYPE_ANGLE, VIPS_ANGLE_D0 ); 
	VIPS_ARG_ENUM( class, "container", 15, 
		_( "Container" ), 
		_( "Pyramid container type" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, container ),
		VIPS_TYPE_FOREIGN_DZ_CONTAINER, VIPS_FOREIGN_DZ_CONTAINER_FS ); 
	VIPS_ARG_BOOL( class, "properties", 16, 
		_( "Properties" ), 
		_( "Write a properties file to the output directory" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, properties ),
		FALSE );
	VIPS_ARG_INT( class, "compression", 17, 
		_( "Compression" ), 
		_( "ZIP deflate compression level" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, compression ),
		-1, 9, 0 );
	VIPS_ARG_ENUM( class, "region_shrink", 18, 
		_( "Region shrink" ), 
		_( "Method to shrink regions" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, region_shrink ),
		VIPS_TYPE_REGION_SHRINK, VIPS_REGION_SHRINK_MEAN ); 
	VIPS_ARG_INT( class, "skip_blanks", 19, 
		_( "Skip blanks" ), 
		_( "Skip tiles which are nearly equal to the background" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, skip_blanks ),
		-1, 65535, -1 );
	VIPS_ARG_BOOL( class, "no_strip", 20, 
		_( "No strip" ), 
		_( "Don't strip tile metadata" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, no_strip ),
		FALSE );
	VIPS_ARG_STRING( class, "id", 21, 
		_( "id" ), 
		_( "Resource ID" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, id ),
		"https://example.com/iiif" );
	VIPS_ARG_STRING( class, "dirname", 1, 
		_( "Directory name" ),
		_( "Directory name to save to" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignSaveDz, dirname ),
		NULL );
	VIPS_ARG_INT( class, "tile_width", 12, 
		_( "Tile width" ), 
		_( "Tile width in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
		1, 8192, 254 );
	VIPS_ARG_INT( class, "tile_height", 12, 
		_( "Tile height" ), 
		_( "Tile height in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
		1, 8192, 254 );
}
static void
vips_foreign_save_dz_init( VipsForeignSaveDz *dz )
{
	VIPS_SETSTR( dz-&gt;suffix, ".jpeg" );
	dz-&gt;layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; 
	dz-&gt;overlap = 1;
	dz-&gt;tile_size = 254;
	dz-&gt;tile_count = 0;
	dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; 
	dz-&gt;angle = VIPS_ANGLE_D0; 
	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_FS; 
	dz-&gt;compression = 0;
	dz-&gt;region_shrink = VIPS_REGION_SHRINK_MEAN;
	dz-&gt;skip_blanks = -1;
}
typedef struct _VipsForeignSaveDzFile {
	VipsForeignSaveDz parent_object;
	char *filename; 
} VipsForeignSaveDzFile;
typedef VipsForeignSaveDzClass VipsForeignSaveDzFileClass;
G_DEFINE_TYPE( VipsForeignSaveDzFile, vips_foreign_save_dz_file, 
	vips_foreign_save_dz_get_type() );
static int
vips_foreign_save_dz_file_build( VipsObject *object )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
	VipsForeignSaveDzFile *file = (VipsForeignSaveDzFile *) object;
	char *p;
	if( !vips_object_argument_isset( object, "basename" ) ) 
		dz-&gt;basename = g_path_get_basename( file-&gt;filename ); 
	if( !vips_object_argument_isset( object, "dirname" ) ) 
		dz-&gt;dirname = g_path_get_dirname( file-&gt;filename ); 
	if( (p = (char *) vips__find_rightmost_brackets( dz-&gt;basename )) )
		*p = '\0';
	if( (p = strrchr( dz-&gt;basename, '.' )) ) {
		if( !vips_object_argument_isset( object, "container" ) ) {
			if( strcasecmp( p + 1, "zip" ) == 0 )
				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
			if( strcasecmp( p + 1, "szi" ) == 0 ) 
				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_SZI;
		}
		if( g_ascii_strcasecmp( p + 1, "zip" ) == 0 ||
			g_ascii_strcasecmp( p + 1, "szi" ) == 0 || 
			g_ascii_strcasecmp( p + 1, "dz" ) == 0 )
			*p = '\0';
	}
	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_file_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static void
vips_foreign_save_dz_file_class_init( VipsForeignSaveDzFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "dzsave";
	object_class-&gt;description = _( "save image to deepzoom file" );
	object_class-&gt;build = vips_foreign_save_dz_file_build;
	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to save to" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignSaveDzFile, filename ),
		NULL );
}
static void
vips_foreign_save_dz_file_init( VipsForeignSaveDzFile *file )
{
}
typedef struct _VipsForeignSaveDzBuffer {
	VipsForeignSaveDz parent_object;
	VipsArea *buf;
} VipsForeignSaveDzBuffer;
typedef VipsForeignSaveDzClass VipsForeignSaveDzBufferClass;
G_DEFINE_TYPE( VipsForeignSaveDzBuffer, vips_foreign_save_dz_buffer, 
	vips_foreign_save_dz_get_type() );
static int
vips_foreign_save_dz_buffer_build( VipsObject *object )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
	void *obuf;
	size_t olen;
	VipsBlob *blob;
	if( !vips_object_argument_isset( object, "basename" ) ) 
		dz-&gt;basename = g_strdup( "untitled" ); 
	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_buffer_parent_class )-&gt;
		build( object ) )
		return( -1 );
	g_assert( GSF_IS_OUTPUT_MEMORY( dz-&gt;out ) );
	olen = gsf_output_size( GSF_OUTPUT( dz-&gt;out ) ); 
	if( !(obuf = g_try_malloc( olen )) ) {
		vips_error( "vips_tracked", 
			_( "out of memory --- size == %dMB" ), 
			(int) (olen / (1024.0 * 1024.0))  );
		return( -1 );
	}
	memcpy( obuf, 
		gsf_output_memory_get_bytes( GSF_OUTPUT_MEMORY( dz-&gt;out ) ),
		olen ); 
	blob = vips_blob_new( (VipsCallbackFn) vips_area_free_cb, obuf, olen );
	g_object_set( object, "buffer", blob, NULL );
	vips_area_unref( VIPS_AREA( blob ) );
	return( 0 );
}
static void
vips_foreign_save_dz_buffer_class_init( VipsForeignSaveDzBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "dzsave_buffer";
	object_class-&gt;description = _( "save image to dz buffer" );
	object_class-&gt;build = vips_foreign_save_dz_buffer_build;
	VIPS_ARG_BOXED( class, "buffer", 1, 
		_( "Buffer" ),
		_( "Buffer to save to" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
		G_STRUCT_OFFSET( VipsForeignSaveDzBuffer, buf ),
		VIPS_TYPE_BLOB );
}
static void
vips_foreign_save_dz_buffer_init( VipsForeignSaveDzBuffer *buffer )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) buffer;
	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
}
int
vips_dzsave( VipsImage *in, const char *name, ... )
{
	va_list ap;
	int result;
	va_start( ap, name );
	result = vips_call_split( "dzsave", ap, in, name ); 
	va_end( ap );
	return( result );
}
int
vips_dzsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
{
	va_list ap;
	VipsArea *area;
	int result;
	area = NULL; 
	va_start( ap, len );
	result = vips_call_split( "dzsave_buffer", ap, in, &amp;area );
	va_end( ap );
	if( !result &amp;&amp;
		area ) { 
		if( buf ) {
			*buf = area-&gt;data;
			area-&gt;free_fn = NULL;
		}
		if( len ) 
			*len = area-&gt;length;
		vips_area_unref( area );
	}
	return( result );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
