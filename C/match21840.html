<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for vips2tiff.c &amp; dzsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for vips2tiff.c &amp; dzsave.c
      </h3>
<h1 align="center">
        5.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>vips2tiff.c (6.364429%)<th>dzsave.c (5.559787%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1709-1782)<td><a href="#" name="0">(1735-1818)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1842-1900)<td><a href="#" name="1">(1906-1964)</a><td align="center"><font color="#b90000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1793-1824)<td><a href="#" name="2">(1829-1864)</a><td align="center"><font color="#7b0000">16</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vips2tiff.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* TIFF PARTS:
 * Copyright (c) 1988, 1990 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 *
 * MODIFICATION FOR VIPS Copyright 1991, K.Martinez 
 *
 * software may be distributed FREE, with these copyright notices
 * no responsibility/warantee is implied or given
 *
 *
 * Modified and added im_LabQ2LabC() function. It can write IM_TYPE_LABQ image
 * in vips format  to LAB in tiff format.
 *  Copyright 1994 Ahmed Abbood.
 *
 * 19/9/95 JC
 *	- calls TIFFClose() more reliably
 *	- tidied up
 * 12/4/97 JC
 *	- thrown away and rewritten for TIFF 6 lib
 * 22/4/97 JC
 *	- writes a pyramid!
 *	- to separate TIFF files tho'
 * 23/4/97 JC
 *	- does 2nd gather pass to put pyramid into a single TIFF file
 *	- ... and shrinks IM_CODING_LABQ too
 * 26/10/98 JC
 *	- binary open for stupid systems
 * 7/6/99 JC
 *	- 16bit TIFF write too
 * 9/7/99 JC
 *	- ZIP tiff added
 * 11/5/00 JC
 *	- removed TIFFmalloc/TIFFfree
 * 5/8/00 JC
 *	- mode string now part of filename
 * 23/4/01 JC
 *	- HAVE_TIFF turns on TIFFness
 * 19/3/02 ruven
 *	- pyramid stops at tile size, not 64x64
 * 29/4/02 JC
 * 	- write any number of bands (but still with photometric RGB, so not
 * 	  very useful)
 * 10/9/02 JC
 *	- oops, handle TIFF errors better
 *	- now writes CMYK correctly
 * 13/2/03 JC
 *	- tries not to write mad resolutions
 * 7/5/03 JC
 *	- only write CMYK if Type == CMYK
 *	- writes EXTRASAMPLES ALPHA for bands == 2 or 4 (if we're writing RGB)
 * 17/11/03 JC
 *	- write float too
 * 28/11/03 JC
 *	- read via a "p" so we work from mmap window images
 *	- uses threadgroups for speedup
 * 9/3/04 JC
 *	- 1 bit write mode added
 * 5/4/04
 *	- better handling of edge tiles (thanks Ruven)
 * 18/5/04 Andrey Kiselev
 *	- added res_inch/res_cm option
 * 20/5/04 JC
 *	- allow single res number too
 * 19/7/04
 *	- write several scanlines at once, good speed up for some cases
 * 22/9/04
 *	- got rid of wrapper image so nip gets progress feedback 
 * 	- fixed tiny read-beyond-buffer issue for edge tiles
 * 7/10/04
 * 	- added ICC profile embedding
 * 13/12/04
 *	- can now pyramid any non-complex type (thanks Ruven)
 * 27/1/05
 *	- added ccittfax4 as a compression option
 * 9/3/05
 *	- set PHOTOMETRIC_CIELAB for vips TYPE_LAB images ... so we can write
 *	  float LAB as well as float RGB
 *	- also LABS images 
 * 22/6/05
 *	- 16 bit LAB write was broken
 * 9/9/05
 * 	- write any icc profile from meta 
 * 3/3/06
 * 	- raise tile buffer limit (thanks Ruven)
 * 11/11/06
 * 	- set ORIENTATION_TOPLEFT (thanks Josef)
 * 18/7/07 Andrey Kiselev
 * 	- remove "b" option on TIFFOpen()
 * 	- support TIFFTAG_PREDICTOR types for lzw and deflate compression
 * 3/11/07
 * 	- use im_wbuffer() for background writes
 * 15/2/08
 * 	- set TIFFTAG_JPEGQUALITY explicitly when we copy TIFF files, since 
 * 	  libtiff doesn't keep this in the header (thanks Joe)
 * 20/2/08
 * 	- use tiff error handler from im_tiff2vips.c
 * 27/2/08
 * 	- don't try to copy icc profiles when building pyramids (thanks Joe)
 * 9/4/08
 * 	- use IM_META_RESOLUTION_UNIT to set default resunit
 * 17/4/08
 * 	- allow CMYKA (thanks Doron)
 * 5/9/08
 *	- trigger eval callbacks during tile write
 * 4/2/10
 * 	- gtkdoc
 * 26/2/10
 * 	- option to turn on bigtiff output
 * 16/4/10
 * 	- use vips_sink_*() instead of threadgroup and friends
 * 22/6/10
 * 	- make no-owner regions for the tile cache, since we share these
 * 	  between threads
 * 12/7/11
 * 	- use im__temp_name() for intermediates rather than polluting the
 * 	  output directory
 * 5/9/11
 * 	- enable YCbCr compression for jpeg write
 * 23/11/11
 * 	- set reduced-resolution subfile type on pyramid layers
 * 2/12/11
 * 	- make into a simple function call ready to be wrapped as a new-style
 * 	  VipsForeign class
 * 21/3/12
 * 	- bump max layer buffer up
 * 2/6/12
 * 	- copy jpeg pyramid in gather in RGB mode ... tiff4 doesn't do ycbcr
 * 	  mode
 * 7/8/12
 * 	- be more cautious enabling YCbCr mode
 * 24/9/13
 * 	- support many more vips formats, eg. complex, 32-bit int, any number
 * 	  of bands, etc., see the tiff loader
 * 26/1/14
 * 	- add RGB as well as YCbCr write
 * 20/11/14
 * 	- cache input in tile write mode to keep us sequential
 * 3/12/14
 * 	- embed XMP in output
 * 10/12/14
 * 	- zero out edge tile buffers before jpeg wtiff, thanks iwbh15
 * 19/1/15
 * 	- disable chroma subsample if Q &gt;= 90
 * 13/2/15
 * 	- append later layers, don't copy the base image
 * 	- use the nice dzsave pyramid code, much faster and simpler
 * 	- we now allow strip pyramids
 * 27/3/15
 * 	- squash &gt;128 rather than &gt;0, nicer results for shrink
 * 	- add miniswhite option
 * 29/9/15
 * 	- try to write IPTC metadata
 * 	- try to write photoshop metadata
 * 11/11/15
 * 	- better alpha handling, thanks sadaqatullahn
 * 21/12/15
 * 	- write TIFFTAG_IMAGEDESCRIPTION
 * 2/6/16
 * 	- support strip option
 * 4/7/16
 * 	- tag alpha as UNASSALPHA since it's not pre-multiplied, thanks Peter
 * 17/8/16
 * 	- use wchar_t TIFFOpen on Windows
 * 14/10/16
 * 	- add buffer output
 * 29/1/17
 * 	- enable bigtiff automatically for large, uncompressed writes, thanks 
 * 	  AndreasSchmid1 
 * 26/8/17
 * 	- support pyramid creation to buffer, thanks bubba
 * 24/10/17
 * 	- no error on page-height not a factor of image height, just don't
 * 	  write multipage
 * 13/6/18
 * 	- add region_shrink
 * 2/7/18
 * 	- copy EXTRASAMPLES to pyramid layers
 * 21/12/18
 * 	- stop pyr layers if width or height drop to 1
 * 8/7/19
 * 	- add webp and zstd support
 * 	- add @level and @lossless
 * 18/12/19
 * 	- "squash" now squashes 3-band float LAB down to LABQ
 * 26/1/20
 * 	- add "depth" to set pyr depth
 * 27/1/20
 * 	- write XYZ images as logluv
 * 7/2/20 [jclavoie-jive]
 * 	- add PAGENUMBER support
 * 23/5/20
 * 	- add support for subifd pyramid layers
 * 6/6/20 MathemanFlo
 * 	- add bitdepth support for 2 and 4 bit greyscale images
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/* 
#define DEBUG_VERBOSE
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#ifdef HAVE_TIFF

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif /*HAVE_UNISTD_H*/
#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;

#include "pforeign.h"
#include "tiff.h"

/* TODO:
 *
 * - add a flag for plane-separate write
 *
 *   	At the moment, we write bioformats-style TIFFs by splitting bands up,
 *   	making a toilet-roll image and writing out in pages. The TIFFs we make
 *   	are not tagged as plane-separate and do not have (eg.) RGB photometric
 *   	interpretation. Moreover, when working from an RGB source, we'll end
 *   	up reading the input three times.
 *
 *   	A write-plane-separate flag to the TIFF writer could let us set the
 *   	photometric interpretation correctly, and save all planes in a single
 *   	pass before doing a final gather sweep.
 */

/* Max number of alpha channels we allow.
 */
#define MAX_ALPHA (64)

/* Bioformats uses this tag for lossy jp2k compressed tiles.
 */
#define JP2K_LOSSY 33004

/* Compression types we handle ourselves.
 */
static int wtiff_we_compress[] = {
	JP2K_LOSSY
};

typedef struct _Layer Layer;
typedef struct _Wtiff Wtiff;

/* A layer in the pyramid.
 */
struct _Layer {
	Wtiff *wtiff;			/* Main wtiff struct */

	/* The filename for this layer, for file output.
	 */
	char *lname;			

	/* The memory area for this layer, for memory output.
	 */
	void *buf;
	size_t len;

	int width, height;		/* Layer size */
	int sub;			/* Subsample factor for this layer */
	TIFF *tif;			/* TIFF file we write this layer to */

	/* The image we build. We only keep a few scanlines of this around in
	 * @strip. 
	 */
	VipsImage *image;

	/* The y position of strip in image.
	 */
	int y;

	/* The next line we write to in strip. 
	 */
	int write_y;

	VipsRegion *strip;		/* The current strip of pixels */
	VipsRegion *copy;		/* Pixels we copy to the next strip */

	Layer *below;			/* The smaller layer below us */
	Layer *above;			/* The larger layer above */
};

/* A TIFF image in the process of being written.
 */
struct _Wtiff {
	VipsImage *input;		/* Original input image */

	/* Image transformed ready for write.
	 */
	VipsImage *ready;

	/* File to write to, or NULL.
	 */
	char *filename;			/* Name we write to */

	/* Memory area to output, or NULL.
	 */
	void **obuf;
	size_t *olen; 

	Layer *layer;			/* Top of pyramid */
	VipsPel *tbuf;			/* TIFF output buffer */
	int tls;			/* Tile line size */

	int compression;		/* libtiff compression type */
	int Q;				/* JPEG q-factor, webp level */
	int predictor;			/* libtiff predictor type */
	int tile;			/* Tile or not */
	int tilew, tileh;		/* Tile size */
	int pyramid;			/* Wtiff pyramid */
	int bitdepth;                   /* Write as 1, 2 or 4 bit */
	int miniswhite;			/* Wtiff as 0 == white */
        int resunit;                    /* Resolution unit (inches or cm) */
        double xres;                   	/* Resolution in X */
        double yres;                   	/* Resolution in Y */
	const char *profile;		/* Profile to embed */
	int bigtiff;			/* True for bigtiff write */
	int rgbjpeg;			/* True for RGB not YCbCr */
	int properties;			/* Set to save XML props */
	int strip;			/* Don't write metadata */
	VipsRegionShrink region_shrink; /* How to shrink regions */
	int level;			/* zstd compression level */
	gboolean lossless;		/* lossless mode */
	VipsForeignDzDepth depth;	/* Pyr depth */
	gboolean subifd;		/* Write pyr layers into subifds */
	gboolean premultiply;		/* Premultiply alpha */

	/* True if we've detected a toilet-roll image, plus the page height,
	 * which has been checked to be a factor of im-&gt;Ysize. page_number
	 * starts at zero and ticks up as we write each page.
	 */
	gboolean toilet_roll;
	int page_height;
	int page_number;
	int n_pages;

	/* The height of the TIFF we write. Equal to page_height in toilet
	 * roll mode.
	 */
	int image_height;

	/* TRUE if the compression type is not supported by libtiff directly
	 * and we must compress ourselves. 
	 */
	gboolean we_compress;
};

/* Write an ICC Profile from a file into the JPEG stream.
 */
static int
embed_profile_file( TIFF *tif, const char *profile )
{
	VipsBlob *blob;

	if( vips_profile_load( profile, &amp;blob, NULL ) )
		return( -1 );

	if( blob ) {
		size_t length;
		const void *data = vips_blob_get( blob, &amp;length );

		TIFFSetField( tif, TIFFTAG_ICCPROFILE, length, data );

#ifdef DEBUG
		printf( "vips2tiff: attached profile \"%s\"\n", profile );
#endif /*DEBUG*/

		vips_area_unref( (VipsArea *) blob );
	}

	return( 0 );
}

/* Embed an ICC profile from VipsImage metadata.
 */
static int
embed_profile_meta( TIFF *tif, VipsImage *im )
{
	const void *data;
	size_t length;

	if( vips_image_get_blob( im, VIPS_META_ICC_NAME, &amp;data, &amp;length ) )
		return( -1 );
	TIFFSetField( tif, TIFFTAG_ICCPROFILE, length, data );

#ifdef DEBUG
	printf( "vips2tiff: attached profile from meta\n" );
#endif /*DEBUG*/

	return( 0 );
}

static void
wtiff_layer_init( Wtiff *wtiff, Layer **layer, Layer *above, 
	int width, int height )
{
	if( !*layer ) {
		*layer = VIPS_NEW( wtiff-&gt;ready, Layer );
		(*layer)-&gt;wtiff = wtiff;
		(*layer)-&gt;width = width;
		(*layer)-&gt;height = height; 

		if( !above )
			/* Top of pyramid.
			 */
			(*layer)-&gt;sub = 1;	
		else
			(*layer)-&gt;sub = above-&gt;sub * 2;

		(*layer)-&gt;lname = NULL;
		(*layer)-&gt;buf = NULL;
		(*layer)-&gt;len = 0;
		(*layer)-&gt;tif = NULL;
		(*layer)-&gt;image = NULL;
		(*layer)-&gt;write_y = 0;
		(*layer)-&gt;y = 0;
		(*layer)-&gt;strip = NULL;
		(*layer)-&gt;copy = NULL;

		(*layer)-&gt;below = NULL;
		(*layer)-&gt;above = above;

		/* The name for the top layer is the output filename.
		 *
		 * We need lname to be freed automatically: it has to stay 
		 * alive until after wtiff_gather().
		 */
		if( wtiff-&gt;filename ) { 
			if( !above ) 
				(*layer)-&gt;lname = vips_strdup( 
					VIPS_OBJECT( wtiff-&gt;ready ),
					wtiff-&gt;filename );
			else {
				char *lname;

				lname = vips__temp_name( "%s.tif" );
				(*layer)-&gt;lname = vips_strdup( 
					VIPS_OBJECT( wtiff-&gt;ready ),
					lname );
				g_free( lname );
			}
		}

		/*
		printf( "wtiff_layer_init: sub = %d, width = %d, height = %d\n",
			(*layer)-&gt;sub, width, height );
		 */
	}

	if( wtiff-&gt;pyramid ) {
		int limitw, limith;

		switch( wtiff-&gt;depth ) {
		case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
			limitw = limith = 1;
			break;

		case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
			limitw = wtiff-&gt;tilew;
			limith = wtiff-&gt;tileh;
			break;

		case VIPS_FOREIGN_DZ_DEPTH_ONE:
			limitw = wtiff-&gt;ready-&gt;Xsize;
			limith = wtiff-&gt;ready-&gt;Ysize;
			break;

		default:
			g_assert_not_reached();
		}

		/* We make another layer if the image is too large to fit in a
		 * single tile, and if neither axis is greater than 1.
		 *
		 * Very tall or wide images might end up with a smallest layer
		 * larger than one tile.
		 */
		if( ((*layer)-&gt;width &gt; limitw || 
			(*layer)-&gt;height &gt; limith) &amp;&amp; 
		 	(*layer)-&gt;width &gt; 1 &amp;&amp; 
		 	(*layer)-&gt;height &gt; 1 ) 
			wtiff_layer_init( wtiff, &amp;(*layer)-&gt;below, *layer, 
				width / 2, height / 2 );
	}
}

static int
wtiff_embed_profile( Wtiff *wtiff, TIFF *tif )
{
	if( wtiff-&gt;profile &amp;&amp;
		embed_profile_file( tif, wtiff-&gt;profile ) )
		return( -1 );

	if( !wtiff-&gt;profile &amp;&amp; 
		vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_ICC_NAME ) &amp;&amp;
		embed_profile_meta( tif, wtiff-&gt;ready ) )
		return( -1 );

	return( 0 );
}

static int
wtiff_embed_xmp( Wtiff *wtiff, TIFF *tif )
{
	const void *data;
	size_t size;

	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_XMP_NAME ) )
		return( 0 );
	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_XMP_NAME, 
		&amp;data, &amp;size ) )
		return( -1 );
	TIFFSetField( tif, TIFFTAG_XMLPACKET, size, data );

#ifdef DEBUG
	printf( "vips2tiff: attached XMP from meta\n" );
#endif /*DEBUG*/

	return( 0 );
}

static int
wtiff_embed_iptc( Wtiff *wtiff, TIFF *tif )
{
	const void *data;
	size_t size;

	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_IPTC_NAME ) )
		return( 0 );
	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_IPTC_NAME, 
		&amp;data, &amp;size ) )
		return( -1 );

	/* For no very good reason, libtiff stores IPTC as an array of
	 * long, not byte.
	 */
	if( size &amp; 3 ) {
		g_warning( "%s", _( "rounding up IPTC data length" ) );
		size /= 4;
		size += 1;
	}
	else
		size /= 4;

	TIFFSetField( tif, TIFFTAG_RICHTIFFIPTC, size, data );

#ifdef DEBUG
	printf( "vips2tiff: attached IPTC from meta\n" );
#endif /*DEBUG*/

	return( 0 );
}

static int
wtiff_embed_photoshop( Wtiff *wtiff, TIFF *tif )
{
	const void *data;
	size_t size;

	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_PHOTOSHOP_NAME ) )
		return( 0 );
	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_PHOTOSHOP_NAME, 
		&amp;data, &amp;size ) )
		return( -1 );
	TIFFSetField( tif, TIFFTAG_PHOTOSHOP, size, data );

#ifdef DEBUG
	printf( "vips2tiff: attached photoshop data from meta\n" );
#endif /*DEBUG*/

	return( 0 );
}

/* Set IMAGEDESCRIPTION, if it's there.  If @properties is TRUE, set from
 * vips' metadata.
 */
static int
wtiff_embed_imagedescription( Wtiff *wtiff, TIFF *tif )
{
	if( wtiff-&gt;properties ) {
		char *doc;

		if( !(doc = vips__xml_properties( wtiff-&gt;ready )) )
			return( -1 );
		TIFFSetField( tif, TIFFTAG_IMAGEDESCRIPTION, doc );
		g_free( doc );
	}
	else {
		const char *imagedescription;

		if( !vips_image_get_typeof( wtiff-&gt;ready,
			VIPS_META_IMAGEDESCRIPTION ) )
			return( 0 );
		if( vips_image_get_string( wtiff-&gt;ready,
			VIPS_META_IMAGEDESCRIPTION, &amp;imagedescription ) )
			return( -1 );
		TIFFSetField( tif, TIFFTAG_IMAGEDESCRIPTION, imagedescription );
	}

#ifdef DEBUG
	printf( "vips2tiff: attached imagedescription from meta\n" );
#endif /*DEBUG*/

	return( 0 );
}

/* Write a TIFF header for this layer. 
 */
static int
wtiff_write_header( Wtiff *wtiff, Layer *layer )
{
	TIFF *tif = layer-&gt;tif;

	int i;
	int orientation; 

#ifdef DEBUG
	printf( "wtiff_write_header: sub %d, width %d, height %d\n",
		layer-&gt;sub, layer-&gt;width, layer-&gt;height );
#endif /*DEBUG*/

	/* Output base header fields.
	 */
	TIFFSetField( tif, TIFFTAG_IMAGEWIDTH, layer-&gt;width );
	TIFFSetField( tif, TIFFTAG_IMAGELENGTH, layer-&gt;height );
	TIFFSetField( tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );
	TIFFSetField( tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );
	TIFFSetField( tif, TIFFTAG_COMPRESSION, wtiff-&gt;compression );

	if( wtiff-&gt;compression == COMPRESSION_JPEG ) 
		TIFFSetField( tif, TIFFTAG_JPEGQUALITY, wtiff-&gt;Q );

#ifdef HAVE_TIFF_COMPRESSION_WEBP
	if( wtiff-&gt;compression == COMPRESSION_WEBP ) {
		TIFFSetField( tif, TIFFTAG_WEBP_LEVEL, wtiff-&gt;Q );
		TIFFSetField( tif, TIFFTAG_WEBP_LOSSLESS, wtiff-&gt;lossless );
	}
	if( wtiff-&gt;compression == COMPRESSION_ZSTD ) {
		TIFFSetField( tif, TIFFTAG_ZSTD_LEVEL, wtiff-&gt;level );
		if( wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
			TIFFSetField( tif, 
				TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
	}
#endif /*HAVE_TIFF_COMPRESSION_WEBP*/

	if( (wtiff-&gt;compression == COMPRESSION_ADOBE_DEFLATE ||
		wtiff-&gt;compression == COMPRESSION_LZW) &amp;&amp;
		wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
		TIFFSetField( tif, TIFFTAG_PREDICTOR, wtiff-&gt;predictor );

	for( i = 0; i &lt; VIPS_NUMBER( wtiff_we_compress ); i++ )
		if( wtiff-&gt;compression == wtiff_we_compress[i] ) {
			wtiff-&gt;we_compress = TRUE;
			break;
		}

	/* Don't write mad resolutions (eg. zero), it confuses some programs.
	 */
	TIFFSetField( tif, TIFFTAG_RESOLUTIONUNIT, wtiff-&gt;resunit );
	TIFFSetField( tif, TIFFTAG_XRESOLUTION, 
		VIPS_FCLIP( 0.01, wtiff-&gt;xres, 1000000 ) );
	TIFFSetField( tif, TIFFTAG_YRESOLUTION, 
		VIPS_FCLIP( 0.01, wtiff-&gt;yres, 1000000 ) );

	if( !wtiff-&gt;strip ) 
		if( wtiff_embed_profile( wtiff, tif ) ||
			wtiff_embed_xmp( wtiff, tif ) ||
			wtiff_embed_iptc( wtiff, tif ) ||
			wtiff_embed_photoshop( wtiff, tif ) ||
			wtiff_embed_imagedescription( wtiff, tif ) )
			return( -1 ); 

	if( vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_ORIENTATION ) &amp;&amp;
		!vips_image_get_int( wtiff-&gt;ready, 
			VIPS_META_ORIENTATION, &amp;orientation ) )
		TIFFSetField( tif, TIFFTAG_ORIENTATION, orientation );

	/* And colour fields.
	 */
	if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ ) {
		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 3 );
		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, 8 );
		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );
	}
	else if( wtiff-&gt;bitdepth == 1 || wtiff-&gt;bitdepth == 2 ||
                 wtiff-&gt;bitdepth == 4 ) {
		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 1 );
		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, wtiff-&gt;bitdepth );
		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC,
			wtiff-&gt;miniswhite ?
				PHOTOMETRIC_MINISWHITE :
				PHOTOMETRIC_MINISBLACK );
	}
	else {
		int photometric;

		/* Number of bands that have colour in .. other bands are saved
		 * as alpha.
		 */
		int colour_bands;

		int alpha_bands;

		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 
			wtiff-&gt;ready-&gt;Bands );
		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, 
			vips_format_sizeof( wtiff-&gt;ready-&gt;BandFmt ) &lt;&lt; 3 );

		if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_B_W ||
			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_GREY16 ||
			wtiff-&gt;ready-&gt;Bands &lt; 3 ) { 
			/* Mono or mono + alpha.
			 */
			photometric = wtiff-&gt;miniswhite ?
				PHOTOMETRIC_MINISWHITE :
				PHOTOMETRIC_MINISBLACK;
			colour_bands = 1;
		}
		else if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LAB || 
			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LABS ) {
			photometric = PHOTOMETRIC_CIELAB;
			colour_bands = 3;
		}
		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ ) { 
			double stonits;

			photometric = PHOTOMETRIC_LOGLUV;
			/* Tell libtiff we will write as float XYZ.
			 */
			TIFFSetField( tif, 
				TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT );
			stonits = 1.0;
			if( vips_image_get_typeof( wtiff-&gt;ready, "stonits" ) )
				vips_image_get_double( wtiff-&gt;ready, 
					"stonits", &amp;stonits );
			TIFFSetField( tif, TIFFTAG_STONITS, stonits );
			colour_bands = 3;
		}
		else if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_CMYK &amp;&amp;
			wtiff-&gt;ready-&gt;Bands &gt;= 4 ) {
			photometric = PHOTOMETRIC_SEPARATED;
			TIFFSetField( tif, TIFFTAG_INKSET, INKSET_CMYK );
			colour_bands = 4;
		}
		else if( wtiff-&gt;compression == COMPRESSION_JPEG &amp;&amp;
			wtiff-&gt;ready-&gt;Bands == 3 &amp;&amp;
			wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR &amp;&amp;
			(!wtiff-&gt;rgbjpeg &amp;&amp; wtiff-&gt;Q &lt; 90) ) { 
			/* This signals to libjpeg that it can do
			 * YCbCr chrominance subsampling from RGB, not
			 * that we will supply the image as YCbCr.
			 */
			photometric = PHOTOMETRIC_YCBCR;
			TIFFSetField( tif, TIFFTAG_JPEGCOLORMODE, 
				JPEGCOLORMODE_RGB );
			colour_bands = 3;
		}
		else {
			/* Some kind of generic multi-band image with three or
			 * more bands ... save the first three bands as RGB, 
			 * the rest as alpha.
			 */
			photometric = PHOTOMETRIC_RGB;
			colour_bands = 3;
		}

		alpha_bands = VIPS_CLIP( 0, 
			wtiff-&gt;ready-&gt;Bands - colour_bands, MAX_ALPHA );
		if( alpha_bands &gt; 0 ) { 
			uint16 v[MAX_ALPHA];
			int i;

			/* EXTRASAMPLE_UNASSALPHA means generic extra
			 * alpha-like channels. ASSOCALPHA means pre-multipled
			 * alpha only. 
			 *
			 * Make the first channel the premultiplied alpha, if
			 * we are premultiplying.
			 */
			for( i = 0; i &lt; alpha_bands; i++ )
				v[i] = i == 0 &amp;&amp; wtiff-&gt;premultiply ? 
					EXTRASAMPLE_ASSOCALPHA :
					EXTRASAMPLE_UNASSALPHA;
			TIFFSetField( tif, 
				TIFFTAG_EXTRASAMPLES, alpha_bands, v );
		}

		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC, photometric );
	}

	/* Layout.
	 */
	if( wtiff-&gt;tile ) {
		TIFFSetField( tif, TIFFTAG_TILEWIDTH, wtiff-&gt;tilew );
		TIFFSetField( tif, TIFFTAG_TILELENGTH, wtiff-&gt;tileh );
	}
	else
		TIFFSetField( tif, TIFFTAG_ROWSPERSTRIP, wtiff-&gt;tileh );

	if( layer-&gt;above ) 
		/* Pyramid layer.
		 */
		TIFFSetField( tif, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );

	if( wtiff-&gt;toilet_roll ) {
		/* One page of many.
		 */
		TIFFSetField( tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE );

		TIFFSetField( tif, TIFFTAG_PAGENUMBER, 
			wtiff-&gt;page_number, wtiff-&gt;n_pages );
	}

	/* Sample format.
	 *
	 * Don't set for logluv: libtiff does this for us.
	 */
	if( wtiff-&gt;input-&gt;Type != VIPS_INTERPRETATION_XYZ ) { 
		int format; 

		format = SAMPLEFORMAT_UINT;
		if( vips_band_format_isuint( wtiff-&gt;ready-&gt;BandFmt ) )
			format = SAMPLEFORMAT_UINT;
		else if( vips_band_format_isint( wtiff-&gt;ready-&gt;BandFmt ) )
			format = SAMPLEFORMAT_INT;
		else if( vips_band_format_isfloat( wtiff-&gt;ready-&gt;BandFmt ) )
			format = SAMPLEFORMAT_IEEEFP;
		else if( vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) )
			format = SAMPLEFORMAT_COMPLEXIEEEFP;
		TIFFSetField( tif, TIFFTAG_SAMPLEFORMAT, format );
	}

	return( 0 );
}

static int
wtiff_layer_rewind( Wtiff *wtiff, Layer *layer )
{
	VipsRect strip_size;

	/* Build a line of tiles here. 
	 *
	 * Expand the strip if necessary to make sure we have an even 
	 * number of lines. 
	 */
	strip_size.left = 0;
	strip_size.top = 0;
	strip_size.width = layer-&gt;image-&gt;Xsize;
	strip_size.height = wtiff-&gt;tileh;
	if( (strip_size.height &amp; 1) == 1 )
		strip_size.height += 1;
	if( vips_region_buffer( layer-&gt;strip, &amp;strip_size ) ) 
		return( -1 );

	layer-&gt;y = 0;
	layer-&gt;write_y = 0;

	return( 0 );
}

static int
wtiff_allocate_layers( Wtiff *wtiff )
{
	Layer *layer;

	g_assert( wtiff-&gt;layer );

	for( layer = wtiff-&gt;layer; layer; layer = layer-&gt;below ) {
		if( !layer-&gt;image ) {
			layer-&gt;image = vips_image_new();
			if( vips_image_pipelinev( layer-&gt;image, 
				VIPS_DEMAND_STYLE_ANY, wtiff-&gt;ready, NULL ) ) 
				return( -1 );
			layer-&gt;image-&gt;Xsize = layer-&gt;width;
			layer-&gt;image-&gt;Ysize = layer-&gt;height;

			layer-&gt;strip = vips_region_new( layer-&gt;image );
			layer-&gt;copy = vips_region_new( layer-&gt;image );

			/* The regions will get used in the bg thread callback,
			 * so make sure we don't own them.
			 */
			vips__region_no_ownership( layer-&gt;strip );
			vips__region_no_ownership( layer-&gt;copy );

			if( layer-&gt;lname ) 
				layer-&gt;tif = vips__tiff_openout( 
					layer-&gt;lname, wtiff-&gt;bigtiff );
			else {
				layer-&gt;tif = vips__tiff_openout_buffer( 
					wtiff-&gt;ready, wtiff-&gt;bigtiff, 
					&amp;layer-&gt;buf, &amp;layer-&gt;len );
			}
			if( !layer-&gt;tif ) 
				return( -1 );
		}

		if( wtiff_layer_rewind( wtiff, layer ) )
			return( -1 ); 

		if( wtiff_write_header( wtiff, layer ) )  
			return( -1 );
	}

	if( !wtiff-&gt;tbuf ) { 
		if( wtiff-&gt;tile ) 
			wtiff-&gt;tbuf = vips_malloc( NULL, 
				TIFFTileSize( wtiff-&gt;layer-&gt;tif ) );
		else
			wtiff-&gt;tbuf = vips_malloc( NULL, 
				TIFFScanlineSize( wtiff-&gt;layer-&gt;tif ) );
		if( !wtiff-&gt;tbuf ) 
			return( -1 );
	}

	return( 0 );
}

/* Delete any temp files we wrote.
 */
static void
wtiff_delete_temps( Wtiff *wtiff )
{
	Layer *layer;

	/* Don't delete the top layer: that's the output file.
	 */
	if( wtiff-&gt;layer &amp;&amp;
		wtiff-&gt;layer-&gt;below )
		for( layer = wtiff-&gt;layer-&gt;below; layer; layer = layer-&gt;below ) 
			if( layer-&gt;lname ) {
#ifndef DEBUG
				unlink( layer-&gt;lname );
				VIPS_FREE( layer-&gt;buf );
#else
				printf( "wtiff_delete_temps: leaving %s\n", 
					layer-&gt;lname );
#endif /*DEBUG*/

				layer-&gt;lname = NULL;
			}
}

/* Free a single pyramid layer.
 */
static void
layer_free( Layer *layer )
{
	VIPS_UNREF( layer-&gt;strip );
	VIPS_UNREF( layer-&gt;copy );
	VIPS_UNREF( layer-&gt;image );
	VIPS_FREE( layer-&gt;buf );
	VIPS_FREEF( TIFFClose, layer-&gt;tif );
}

/* Free an entire pyramid.
 */
static void
layer_free_all( Layer *layer )
{
	if( layer-&gt;below ) 
		layer_free_all( layer-&gt;below );

	layer_free( layer );
}

static void
wtiff_free( Wtiff *wtiff )
{
	wtiff_delete_temps( wtiff );
	VIPS_UNREF( wtiff-&gt;ready );
	VIPS_FREE( wtiff-&gt;tbuf );
	VIPS_FREEF( layer_free_all, wtiff-&gt;layer );
	VIPS_FREE( wtiff-&gt;filename );
	VIPS_FREE( wtiff );
}

static int
get_compression( VipsForeignTiffCompression compression )
{
	switch( compression ) {
	case VIPS_FOREIGN_TIFF_COMPRESSION_NONE:
		return( COMPRESSION_NONE );
	case VIPS_FOREIGN_TIFF_COMPRESSION_JPEG:
		return( COMPRESSION_JPEG );
	case VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE:
		return( COMPRESSION_ADOBE_DEFLATE );
	case VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS:
		return( COMPRESSION_PACKBITS );
	case VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4:
		return( COMPRESSION_CCITTFAX4 );
	case VIPS_FOREIGN_TIFF_COMPRESSION_LZW:
		return( COMPRESSION_LZW );
#ifdef HAVE_TIFF_COMPRESSION_WEBP
	case VIPS_FOREIGN_TIFF_COMPRESSION_WEBP:
		return( COMPRESSION_WEBP );
	case VIPS_FOREIGN_TIFF_COMPRESSION_ZSTD:
		return( COMPRESSION_ZSTD );
#endif /*HAVE_TIFF_COMPRESSION_WEBP*/
	case VIPS_FOREIGN_TIFF_COMPRESSION_JP2K:
		return( JP2K_LOSSY );
	
	default:
		return( COMPRESSION_NONE );
	}
}

static int
get_resunit( VipsForeignTiffResunit resunit )
{
	switch( resunit ) {
	case VIPS_FOREIGN_TIFF_RESUNIT_CM:
		return( RESUNIT_CENTIMETER );
	case VIPS_FOREIGN_TIFF_RESUNIT_INCH:
		return( RESUNIT_INCH );

	default:
		g_assert_not_reached();
	}

	/* Keep -Wall happy.
	 */
	return( -1 );
}

/* Get the image ready to be written.
 */
static int
ready_to_write( Wtiff *wtiff )
{
	VipsImage *input;
	VipsImage *x;

	input = wtiff-&gt;input;
	g_object_ref( input );

	if( vips_check_coding_known( "vips2tiff", input ) ) {
		VIPS_UNREF( input );
		return( -1 );
	}

	/* Premultiply any alpha, if necessary.
	 */
	if( wtiff-&gt;premultiply &amp;&amp;
		vips_image_hasalpha( input ) ) {
		VipsBandFormat start_format = input-&gt;BandFmt;

		if( vips_premultiply( input, &amp;x, NULL ) ) {
			VIPS_UNREF( input );
			return( -1 );
		}
		VIPS_UNREF( input );
		input = x;

		/* Premultiply always makes a float -- cast back again.
		 */
		if( vips_cast( input, &amp;x, start_format, NULL ) ) {
			VIPS_UNREF( input );
			return( -1 );
		}
		VIPS_UNREF( input );
		input = x;
	}

	/* "squash" float LAB down to LABQ.
	 */
	if( wtiff-&gt;bitdepth &amp;&amp;
		input-&gt;Bands == 3 &amp;&amp;
		input-&gt;BandFmt == VIPS_FORMAT_FLOAT &amp;&amp;
		input-&gt;Type == VIPS_INTERPRETATION_LAB ) {
		if( vips_Lab2LabQ( input, &amp;x, NULL ) ) {
			VIPS_UNREF( input );
			return( -1 );
		}
		VIPS_UNREF( input );
		input = x;
	}

	wtiff-&gt;ready = input;

	return( 0 );
}

static Wtiff *
wtiff_new( VipsImage *input, const char *filename, 
	VipsForeignTiffCompression compression, int Q, 
	VipsForeignTiffPredictor predictor,
	const char *profile,
	gboolean tile, int tile_width, int tile_height,
	gboolean pyramid,
	int bitdepth,
	gboolean miniswhite,
	VipsForeignTiffResunit resunit, double xres, double yres,
	gboolean bigtiff,
	gboolean rgbjpeg,
	gboolean properties,
	gboolean strip,
	VipsRegionShrink region_shrink,
	int level, 
	gboolean lossless,
	VipsForeignDzDepth depth, 
	gboolean subifd,
	gboolean premultiply )
{
	Wtiff *wtiff;

	if( !(wtiff = VIPS_NEW( NULL, Wtiff )) )
		return( NULL );
	wtiff-&gt;input = input;
	wtiff-&gt;ready = NULL;
	wtiff-&gt;filename = filename ? vips_strdup( NULL, filename ) : NULL;
	wtiff-&gt;layer = NULL;
	wtiff-&gt;tbuf = NULL;
	wtiff-&gt;compression = get_compression( compression );
	wtiff-&gt;Q = Q;
	wtiff-&gt;predictor = predictor;
	wtiff-&gt;tile = tile;
	wtiff-&gt;tilew = tile_width;
	wtiff-&gt;tileh = tile_height;
	wtiff-&gt;pyramid = pyramid;
	wtiff-&gt;bitdepth = bitdepth;
	wtiff-&gt;miniswhite = miniswhite;
	wtiff-&gt;resunit = get_resunit( resunit );
	wtiff-&gt;xres = xres;
	wtiff-&gt;yres = yres;
	wtiff-&gt;profile = profile;
	wtiff-&gt;bigtiff = bigtiff;
	wtiff-&gt;rgbjpeg = rgbjpeg;
	wtiff-&gt;properties = properties;
	wtiff-&gt;strip = strip;
	wtiff-&gt;region_shrink = region_shrink;
	wtiff-&gt;level = level;
	wtiff-&gt;lossless = lossless;
	wtiff-&gt;depth = depth;
	wtiff-&gt;subifd = subifd;
	wtiff-&gt;premultiply = premultiply;
	wtiff-&gt;toilet_roll = FALSE;
	wtiff-&gt;page_height = vips_image_get_page_height( input );
	wtiff-&gt;page_number = 0;
	wtiff-&gt;n_pages = 1;
	wtiff-&gt;image_height = input-&gt;Ysize;

	/* Any pre-processing on the image.
	 */
	if( ready_to_write( wtiff ) ) {
		wtiff_free( wtiff );
		return( NULL );
	}

	/* XYZ images are written as libtiff LOGLUV.
	 */
	if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_XYZ ) 
		wtiff-&gt;compression = COMPRESSION_SGILOG;

	/* Multipage image?
	 */
	if( wtiff-&gt;page_height &lt; wtiff-&gt;ready-&gt;Ysize ) {
#ifdef DEBUG
		printf( "wtiff_new: detected toilet roll image, "
			"page-height=%d\n", 
			wtiff-&gt;page_height );
		printf( "wtiff_new: pages=%d\n", 
			wtiff-&gt;ready-&gt;Ysize / wtiff-&gt;page_height );
#endif/*DEBUG*/

		wtiff-&gt;toilet_roll = TRUE;
		wtiff-&gt;image_height = wtiff-&gt;page_height;
		wtiff-&gt;n_pages = wtiff-&gt;ready-&gt;Ysize / wtiff-&gt;page_height;
	}

	/* We can only pyramid LABQ and non-complex images. 
	 */
	if( wtiff-&gt;pyramid ) {
		if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_NONE &amp;&amp; 
			vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) ) {
			wtiff_free( wtiff );
			vips_error( "vips2tiff", 
				"%s", _( "can only pyramid LABQ and "
				"non-complex images" ) );
			return( NULL );
		}
	}

	/* Pyramid images must be tiled.
	 */
	if( wtiff-&gt;pyramid &amp;&amp;
		!wtiff-&gt;tile )
		wtiff-&gt;tile = TRUE;

	/* Multi-page pyramids must be in subifd mode.
	 */
	if( wtiff-&gt;pyramid &amp;&amp;
		wtiff-&gt;toilet_roll )
		wtiff-&gt;subifd = TRUE;

	/* If compression is off and we're writing a &gt;4gb image, automatically
	 * enable bigtiff.
	 *
	 * This won't always work. If the image data is just under 4gb but
	 * there's a lot of metadata, we could be pushed over the 4gb limit.
	 */
	if( wtiff-&gt;compression == COMPRESSION_NONE &amp;&amp;
		VIPS_IMAGE_SIZEOF_IMAGE( wtiff-&gt;ready ) &gt; UINT_MAX )
		wtiff-&gt;bigtiff = TRUE;

	/* In strip mode we use tileh to set rowsperstrip, and that does not
	 * have the multiple-of-16 restriction.
	 */
	if( wtiff-&gt;tile ) { 
		if( (wtiff-&gt;tilew &amp; 0xf) != 0 || 
			(wtiff-&gt;tileh &amp; 0xf) != 0 ) {
			wtiff_free( wtiff );
			vips_error( "vips2tiff", 
				"%s", _( "tile size not a multiple of 16" ) );
			return( NULL );
		}
	}

	/* Depth 8 is handled above.
	 */
	if( wtiff-&gt;bitdepth &amp;&amp; 
		!(wtiff-&gt;bitdepth == 1 || 
		  wtiff-&gt;bitdepth == 2 || 
		  wtiff-&gt;bitdepth == 4) ) {
		g_warning( "%s",
			_( "bitdepth 1, 2 or 4 only -- disabling bitdepth") );
		wtiff-&gt;bitdepth = 0;
	}

	/* Can only have byte fractional bit depths for 8 bit mono.
	 * 3-band float should have been packed above.
	 */
	if( wtiff-&gt;bitdepth &amp;&amp; 
		!(wtiff-&gt;ready-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
		  wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR &amp;&amp; 
		  wtiff-&gt;ready-&gt;Bands == 1) ) { 
		g_warning( "%s",
			( "can only set bitdepth for 1-band uchar and "
                        "3-band float lab -- disabling bitdepth" ) );
		wtiff-&gt;bitdepth = 0;
	}

	if( wtiff-&gt;bitdepth &amp;&amp;
		wtiff-&gt;compression == COMPRESSION_JPEG ) {
		g_warning( "%s", 
			_( "can't have &lt;8 bit JPEG -- disabling JPEG" ) );
		wtiff-&gt;compression = COMPRESSION_NONE;
	}
 
	/* We can only MINISWHITE non-complex images of 1 or 2 bands.
	 */
	if( wtiff-&gt;miniswhite &amp;&amp;
		(wtiff-&gt;ready-&gt;Coding != VIPS_CODING_NONE || 
			vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) ||
			wtiff-&gt;ready-&gt;Bands &gt; 2) ) {
		g_warning( "%s", 
			_( "can only save non-complex greyscale images "
				"as miniswhite -- disabling miniswhite" ) );
		wtiff-&gt;miniswhite = FALSE;
	}

	/* Sizeof a line of bytes in the TIFF tile.
	 */
	if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ )
		wtiff-&gt;tls = wtiff-&gt;tilew * 3;
	else if( wtiff-&gt;bitdepth == 1 )
		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 8 ) / 8;
	else if( wtiff-&gt;bitdepth == 2 )
		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 4 ) / 4;
	else if( wtiff-&gt;bitdepth == 4 )
		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 2 ) / 2;
	else
		wtiff-&gt;tls = VIPS_IMAGE_SIZEOF_PEL( wtiff-&gt;ready ) * 
			wtiff-&gt;tilew;

	return( wtiff );
}

/* Convert VIPS LabQ to TIFF LAB. Just take the first three bands.
 */
static void
LabQ2LabC( VipsPel *q, VipsPel *p, int n )
{
	int x;

	for( x = 0; x &lt; n; x++ ) {
		/* Get most significant 8 bits of lab.
		 */
		q[0] = p[0];
		q[1] = p[1];
		q[2] = p[2];

		p += 4;
		q += 3;
	}
}

/* Pack 8 bit VIPS to N bit TIFF.
 */
static void
eightbit2nbit( Wtiff *wtiff, VipsPel *q, VipsPel *p, int n )
{
	/* Invert in miniswhite mode.
	 */
	VipsPel mask = wtiff-&gt;miniswhite ? 255 : 0;
	int pixel_mask = 8 / wtiff-&gt;bitdepth - 1;
	int shift = 8 - wtiff-&gt;bitdepth;

	VipsPel bits;
        int x;

	bits = 0;
        for( x = 0; x &lt; n; x++ ) {
		bits &lt;&lt;= wtiff-&gt;bitdepth;
		bits |= p[x] &gt;&gt; shift;

		if( (x &amp; pixel_mask) == pixel_mask ) 
			*q++ = bits ^ mask;
        }

	/* Any left-over bits? Need to be left-aligned.
	 */
	if( (x &amp; pixel_mask) != 0 ) {
		/* The number of bits we've collected in bits and must
		 * left-align and flush.
		 */
		int collected_bits = (x &amp; pixel_mask) &lt;&lt; (wtiff-&gt;bitdepth - 1);

		*q++ = (bits ^ mask) &lt;&lt; (8 - collected_bits);
	}
}

/* Swap the sense of the first channel, if necessary. 
 */
#define GREY_LOOP( TYPE, MAX ) { \
	TYPE *p1; \
	TYPE *q1; \
	\
	p1 = (TYPE *) p; \
	q1 = (TYPE *) q; \
	for( x = 0; x &lt; n; x++ ) { \
		if( invert ) \
			q1[0] = MAX - p1[0]; \
		else \
			q1[0] = p1[0]; \
		\
		for( i = 1; i &lt; im-&gt;Bands; i++ ) \
			q1[i] = p1[i]; \
		\
		q1 += im-&gt;Bands; \
		p1 += im-&gt;Bands; \
	} \
}

/* If we're writing a 1 or 2 band image as a greyscale and MINISWHITE, we need
 * to swap the sense of the first band. See tiff2vips.c, greyscale_line() for
 * the opposite conversion.
 */
static void
invert_band0( Wtiff *wtiff, VipsPel *q, VipsPel *p, int n )
{
	VipsImage *im = wtiff-&gt;ready;
	gboolean invert = wtiff-&gt;miniswhite;

        int x, i;

	switch( im-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR:
	case VIPS_FORMAT_CHAR:
		GREY_LOOP( guchar, UCHAR_MAX ); 
		break;

	case VIPS_FORMAT_SHORT:
		GREY_LOOP( gshort, SHRT_MAX ); 
		break;

	case VIPS_FORMAT_USHORT:
		GREY_LOOP( gushort, USHRT_MAX ); 
		break;

	case VIPS_FORMAT_INT:
		GREY_LOOP( gint, INT_MAX ); 
		break;

	case VIPS_FORMAT_UINT:
		GREY_LOOP( guint, UINT_MAX ); 
		break;

	case VIPS_FORMAT_FLOAT:
		GREY_LOOP( float, 1.0 ); 
		break;

	case VIPS_FORMAT_DOUBLE:
		GREY_LOOP( double, 1.0 ); 
		break;

	default:
		g_assert_not_reached();
	}
}

/* Convert VIPS LABS to TIFF 16 bit LAB.
 */
static void
LabS2Lab16( VipsPel *q, VipsPel *p, int n, int samples_per_pixel )
{
	short *p1 = (short *) p;
	unsigned short *q1 = (unsigned short *) q;

	int x;

        for( x = 0; x &lt; n; x++ ) {
		int i;

                /* LABS L can be negative.
                 */
                q1[0] = VIPS_LSHIFT_INT( VIPS_MAX( 0, p1[0] ), 1 );

		for( i = 1; i &lt; samples_per_pixel; i++ )
			q1[i] = p1[i];

		q1 += samples_per_pixel;
		p1 += samples_per_pixel;
	}
}

/* Convert VIPS D65 XYZ to TIFF scaled float illuminant-free xyz.
 */
static void
XYZ2tiffxyz( VipsPel *q, VipsPel *p, int n, int samples_per_pixel )
{
	float *p1 = (float *) p;
	float *q1 = (float *) q;

	int x;

        for( x = 0; x &lt; n; x++ ) {
		int i;

                q1[0] = p1[0] / VIPS_D65_X0;
                q1[1] = p1[1] / VIPS_D65_Y0;
                q1[2] = p1[2] / VIPS_D65_Z0;

		for( i = 3; i &lt; samples_per_pixel; i++ )
			q1[i] = p1[i];

		q1 += samples_per_pixel;
		p1 += samples_per_pixel;
	}
}

/* Pack the pixels in @area from @in into a TIFF tile buffer.
 */
static void
wtiff_pack2tiff( Wtiff *wtiff, Layer *layer, 
	VipsRegion *in, VipsRect *area, VipsPel *q )
{
	int y;

	/* JPEG compression can read outside the pixel area for edge tiles. It
	 * always compresses 8x8 blocks, so if the image width or height is
	 * not a multiple of 8, it can look beyond the pixels we will write.
	 *
	 * Black out the tile first to make sure these edge pixels are always
	 * zero.
	 */
	if( wtiff-&gt;compression == COMPRESSION_JPEG &amp;&amp;
		(area-&gt;width &lt; wtiff-&gt;tilew || 
		 area-&gt;height &lt; wtiff-&gt;tileh) )
		memset( q, 0, TIFFTileSize( layer-&gt;tif ) );

	for( y = area-&gt;top; y &lt; VIPS_RECT_BOTTOM( area ); y++ ) {
		VipsPel *p = (VipsPel *) VIPS_REGION_ADDR( in, area-&gt;left, y );

		if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ )
			LabQ2LabC( q, p, area-&gt;width );
		else if( wtiff-&gt;bitdepth &gt; 0 )
			eightbit2nbit( wtiff, q, p, area-&gt;width );
		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ )
			XYZ2tiffxyz( q, p, area-&gt;width, in-&gt;im-&gt;Bands );
		else if( (in-&gt;im-&gt;Bands == 1 || in-&gt;im-&gt;Bands == 2) &amp;&amp; 
			wtiff-&gt;miniswhite ) 
			invert_band0( wtiff, q, p, area-&gt;width );
		else if( wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_SHORT &amp;&amp;
			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LABS )
			LabS2Lab16( q, p, area-&gt;width, in-&gt;im-&gt;Bands );
		else
			memcpy( q, p, 
				area-&gt;width * 
					VIPS_IMAGE_SIZEOF_PEL( wtiff-&gt;ready ) );

		q += wtiff-&gt;tls;
	}
}

/* Write a set of tiles across the strip.
 */
static int
wtiff_layer_write_tiles( Wtiff *wtiff, Layer *layer, VipsRegion *strip )
{
	VipsImage *im = layer-&gt;image;
	VipsRect *area = &amp;strip-&gt;valid;

	VipsRect image;
	int x;

	image.left = 0;
	image.top = 0;
	image.width = im-&gt;Xsize;
	image.height = im-&gt;Ysize;

	for( x = 0; x &lt; im-&gt;Xsize; x += wtiff-&gt;tilew ) {
		VipsRect tile;

		tile.left = x;
		tile.top = area-&gt;top;
		tile.width = wtiff-&gt;tilew;
		tile.height = wtiff-&gt;tileh;
		vips_rect_intersectrect( &amp;tile, &amp;image, &amp;tile );

#ifdef DEBUG_VERBOSE
		printf( "Writing %dx%d tile at position %dx%d to image %s\n",
			tile.width, tile.height, tile.left, tile.top,
			TIFFFileName( layer-&gt;tif ) );
#endif /*DEBUG_VERBOSE*/

		if( wtiff-&gt;we_compress ) {
			ttile_t tile_no = TIFFComputeTile( layer-&gt;tif,
				tile.left, tile.top, 0, 0 );

			VipsTarget *target;
			int result;
			unsigned char *buffer;
			size_t length;

			target = vips_target_new_to_memory();

			switch( wtiff-&gt;compression ) {
			case JP2K_LOSSY:
				/* Sadly chroma subsample seems not to work
				 * for edge tiles in tiff with jp2k
				 * compression, so we always pass FALSE
				 * instead of:
				 *
				 * 	!wtiff-&gt;rgbjpeg &amp;&amp; wtiff-&gt;Q &lt; 90,
				 *
				 * I've verified that the libvips jp2k
				 * encode and decode subsample operations fill
				 * the comps[i].data arrays correctly, so it
				 * seems to be a openjpeg bug.
				 *
				 * FIXME ... try again with openjpeg 2.5,
				 * when that comes.
				 */
				result = vips__foreign_load_jp2k_compress( 
					strip, &amp;tile, target,
					wtiff-&gt;tilew, wtiff-&gt;tileh,
					!wtiff-&gt;rgbjpeg,
				 	// !wtiff-&gt;rgbjpeg &amp;&amp; wtiff-&gt;Q &lt; 90,
					FALSE,
					wtiff-&gt;lossless, 
					wtiff-&gt;Q );
				break;

			default:
				result = -1;
				g_assert_not_reached();
				break;
			}

			if( result ) {
				g_object_unref( target );
				return( -1 );
			}

			buffer = vips_target_steal( target, &amp;length );

			g_object_unref( target );

			result = TIFFWriteRawTile( layer-&gt;tif, tile_no, 
				buffer, length );

			g_free( buffer );
		
			if( result &lt; 0 ) {
				vips_error( "vips2tiff", 
					"%s", _( "TIFF write tile failed" ) );
				return( -1 );
			}
		}
		else {
			/* Have to repack pixels for libtiff.
			 */
			wtiff_pack2tiff( wtiff, 
				layer, strip, &amp;tile, wtiff-&gt;tbuf );

			if( TIFFWriteTile( layer-&gt;tif, wtiff-&gt;tbuf, 
				tile.left, tile.top, 0, 0 ) &lt; 0 ) {
				vips_error( "vips2tiff", 
					"%s", _( "TIFF write tile failed" ) );
				return( -1 );
			}
		}
	}

	return( 0 );
}

/* Write tileh scanlines, less for the last strip.
 */
static int
wtiff_layer_write_strip( Wtiff *wtiff, Layer *layer, VipsRegion *strip )
{
	VipsImage *im = layer-&gt;image;
	VipsRect *area = &amp;strip-&gt;valid;
	int height = VIPS_MIN( wtiff-&gt;tileh, area-&gt;height ); 

	int y;

#ifdef DEBUG_VERBOSE
	printf( "Writing %d pixel strip at height %d to image %s\n",
		height, area-&gt;top, TIFFFileName( layer-&gt;tif ) );
#endif /*DEBUG_VERBOSE*/

	for( y = 0; y &lt; height; y++ ) {
		VipsPel *p = VIPS_REGION_ADDR( strip, 0, area-&gt;top + y );

		/* Any repacking necessary.
		 */
		if( im-&gt;Coding == VIPS_CODING_LABQ ) {
			LabQ2LabC( wtiff-&gt;tbuf, p, im-&gt;Xsize );
			p = wtiff-&gt;tbuf;
		}
		else if( im-&gt;BandFmt == VIPS_FORMAT_SHORT &amp;&amp;
			im-&gt;Type == VIPS_INTERPRETATION_LABS ) {
			LabS2Lab16( wtiff-&gt;tbuf, p, im-&gt;Xsize, im-&gt;Bands );
			p = wtiff-&gt;tbuf;
		}
		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ ) {
			XYZ2tiffxyz( wtiff-&gt;tbuf, p, im-&gt;Xsize, im-&gt;Bands );
			p = wtiff-&gt;tbuf;
		}
		else if( wtiff-&gt;bitdepth &gt; 0 ) {
			eightbit2nbit( wtiff, wtiff-&gt;tbuf, p, im-&gt;Xsize );
			p = wtiff-&gt;tbuf;
		}
		else if( (im-&gt;Bands == 1 || im-&gt;Bands == 2) &amp;&amp; 
			wtiff-&gt;miniswhite ) {
			invert_band0( wtiff, wtiff-&gt;tbuf, p, im-&gt;Xsize );
			p = wtiff-&gt;tbuf;
		}

		if( TIFFWriteScanline( layer-&gt;tif, p, area-&gt;top + y, 0 ) &lt; 0 ) 
			return( -1 );
	}

	return( 0 );
}

static int layer_strip_arrived( Layer *layer );

/* Shrink what pixels we can from this strip into the layer below. If the
 * strip below fills, recurse.
 */
<a name="0"></a>static int
layer_strip_shrink( Layer *layer )
{
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	Layer *below = layer-&gt;below;
	VipsRegion *from = layer-&gt;strip;
	VipsRegion *to = below-&gt;strip;

	VipsRect target;
	VipsRect source;

	/* Our pixels might cross a strip boundary in the layer below, so we
	 * have to write repeatedly until we run out of pixels.
	 */
	for(;;) {
		/* The pixels the layer below needs.
		 */
		target.left = 0;
		target.top = below-&gt;write_y;
		target.width = below-&gt;image-&gt;Xsize;
		target.height = to-&gt;valid.height;
		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );

		/* Those pixels need this area of this layer. 
		 */
		source.left = target.left * 2;
		source.top = target.top * 2;
		source.width = target.width * 2;
		source.height = target.height * 2;

		/* Of which we have these available.
		 */
		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );

		/* So these are the pixels in the layer below we can provide.
		 */
		target.left = source.left / 2;
		target.top = source.top / 2;
		target.width = source.width / 2;
		target.height = source.height / 2;

		/* None? All done.
		 */
		if( vips_rect_isempty( &amp;target ) )
			break;

		(void) vips_region_shrink_method( from, to, &amp;target,
			layer-&gt;wtiff-&gt;region_shrink );

		below-&gt;write_y += target.height;

		/* If we've filled the strip below, let it know.
		 * We can either fill the region, if it's somewhere half-way
		 * down the image, or, if it's at the bottom, get to the last
		 * real line of pixels.
		 */
		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
			below-&gt;write_y == below-&gt;height ) {
			if( layer_strip_arrived( below ) )
				return( -1 );
		}
	}

	return( 0 );
}

/* A new strip has arrived! The strip has at least enough pixels in to 
 * write a line of tiles or a set of scanlines.  
 *
 * - write a line of tiles / set of scanlines
 * - shrink what we can to the layer below
 * - move our strip down by the tile height
 * - copy the overlap with the previous strip
 */
static int
layer_strip_arrived( Layer *layer )
{
	Wtiff *wtiff = layer-&gt;wtiff;</b></font>

	int result;
	VipsRect new_strip;
	VipsRect overlap;
	VipsRect image_area;

	if( wtiff-&gt;tile ) 
<a name="2"></a>		result = wtiff_layer_write_tiles( wtiff, layer, layer-&gt;strip );
	else
		result = wtiff_layer_write_strip( wtiff, layer, layer-&gt;strip );
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( result )
		return( -1 );

	if( layer-&gt;below &amp;&amp;
		layer_strip_shrink( layer ) ) 
		return( -1 );

	/* Position our strip down the image.  
	 *
	 * Expand the strip if necessary to make sure we have an even 
	 * number of lines. 
	 */
	layer-&gt;y += wtiff-&gt;tileh;
	new_strip.left = 0;
	new_strip.top = layer-&gt;y;
	new_strip.width = layer-&gt;image-&gt;Xsize;
	new_strip.height = wtiff-&gt;tileh;

	image_area.left = 0;
	image_area.top = 0;
	image_area.width = layer-&gt;image-&gt;Xsize;
	image_area.height = layer-&gt;image-&gt;Ysize;
	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 

	if( (new_strip.height &amp; 1) == 1 )
		new_strip.height += 1;

	/* What pixels that we will need do we already have? Save them in 
	 * overlap.
	 */
	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
	if( !vips_rect_isempty( &amp;overlap ) ) {</b></font>
		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
			return( -1 );
		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
			&amp;overlap, overlap.left, overlap.top );
	}

	if( !vips_rect_isempty( &amp;new_strip ) ) {
		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) ) 
			return( -1 );

		/* And copy back again.
		 */
		if( !vips_rect_isempty( &amp;overlap ) ) 
			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
<a name="1"></a>				&amp;overlap, overlap.left, overlap.top );
	}

<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
}

/* Another strip of image pixels from vips_sink_disc(). Write into the top
 * pyramid layer. 
 */
static int
write_strip( VipsRegion *region, VipsRect *area, void *a )
{
	Wtiff *wtiff = (Wtiff *) a;
	Layer *layer = wtiff-&gt;layer; 

#ifdef DEBUG_VERBOSE
	printf( "write_strip: strip at %d, height %d\n", 
		area-&gt;top, area-&gt;height );
#endif/*DEBUG_VERBOSE*/

	for(;;) {
		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
		VipsRect target;

		/* The bit of strip that needs filling.
		 */
		target.left = 0;
		target.top = layer-&gt;write_y;
		target.width = layer-&gt;image-&gt;Xsize;
		target.height = to-&gt;height;
		vips_rect_intersectrect( &amp;target, to, &amp;target );

		/* Clip against what we have available.
		 */
		vips_rect_intersectrect( &amp;target, area, &amp;target );

		/* Are we empty? All done.
		 */
		if( vips_rect_isempty( &amp;target ) ) 
			break;

		/* And copy those pixels in.
		 *
		 * FIXME: If the strip fits inside the region we've just 
		 * received, we could skip the copy. Will this happen very
		 * often? Unclear.
		 */
		vips_region_copy( region, layer-&gt;strip, 
			&amp;target, target.left, target.top );

		layer-&gt;write_y += target.height;

		/* We can either fill the strip, if it's somewhere half-way
		 * down the image, or, if it's at the bottom, get to the last
		 * real line of pixels.
		 */
		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
			layer-&gt;write_y == layer-&gt;height ) {
			if( layer_strip_arrived( layer ) ) 
				return( -1 );
		}
	}</b></font>

	return( 0 );
}

/* Copy fields.
 */
#define CopyField( tag, v ) \
	if( TIFFGetField( in, tag, &amp;v ) ) TIFFSetField( out, tag, v )

static int
wtiff_copy_tiles( Wtiff *wtiff, TIFF *out, TIFF *in )
{
	const ttile_t n_tiles = TIFFNumberOfTiles( in );

	tsize_t tile_size;
	tdata_t buf;
	ttile_t i;

	if( wtiff-&gt;compression == COMPRESSION_JPEG ) 
		tile_size = TIFFTileSize( in );
	else 
		/* If we will be copying raw tiles we need a buffer large 
		 * enough to hold the largest compressed tile in any page.
		 *
		 * Allocate a buffer 2x the uncompressed tile size ... much 
		 * simpler than searching every page for the largest tile with
		 * TIFFTAG_TILEBYTECOUNTS.
		 */
		tile_size = 2 * wtiff-&gt;tls * wtiff-&gt;tileh;
	buf = vips_malloc( NULL, tile_size );

	for( i = 0; i &lt; n_tiles; i++ ) {
		tsize_t len;

		/* If this is a JPEG-compressed TIFF, we need to decompress 
		 * and recompress, since tiles are actually written in several 
		 * places (coefficients go in the tile, huffman tables go 
		 * elsewhere).
		 *
		 * For all other compression types, we can just use 
		 * TIFFReadRawTile()/TIFFWriteRawTile().
		 */
		if( wtiff-&gt;compression == COMPRESSION_JPEG ) {
			len = TIFFReadEncodedTile( in, i, buf, tile_size );
			if( len &lt;= 0 ||
				TIFFWriteEncodedTile( out, i, buf, len ) &lt; 0 ) {
				g_free( buf );
				return( -1 );
			}
		}
		else {
			len = TIFFReadRawTile( in, i, buf, tile_size );
			if( len &lt;= 0 ||
				TIFFWriteRawTile( out, i, buf, len ) &lt; 0 ) {
				g_free( buf );
				return( -1 );
			}
		}
	}

	g_free( buf );

	return( 0 );
}

/* Copy a TIFF file ... we know we wrote it, so just copy the tags we know 
 * we might have set.
 */
static int
wtiff_copy_tiff( Wtiff *wtiff, TIFF *out, TIFF *in )
{
	uint32 ui32;
	uint16 ui16;
	uint16 ui16_2;
	float f;
	uint16 *a;

	/* All the fields we might have set.
	 */
	CopyField( TIFFTAG_IMAGEWIDTH, ui32 );
	CopyField( TIFFTAG_IMAGELENGTH, ui32 );
	CopyField( TIFFTAG_PLANARCONFIG, ui16 );
	CopyField( TIFFTAG_ORIENTATION, ui16 );
	CopyField( TIFFTAG_XRESOLUTION, f );
	CopyField( TIFFTAG_YRESOLUTION, f );
	CopyField( TIFFTAG_RESOLUTIONUNIT, ui16 );
	CopyField( TIFFTAG_COMPRESSION, ui16 );
	CopyField( TIFFTAG_SAMPLESPERPIXEL, ui16 );
	CopyField( TIFFTAG_BITSPERSAMPLE, ui16 );
	CopyField( TIFFTAG_PHOTOMETRIC, ui16 );
	CopyField( TIFFTAG_ORIENTATION, ui16 );
	CopyField( TIFFTAG_TILEWIDTH, ui32 );
	CopyField( TIFFTAG_TILELENGTH, ui32 );
	CopyField( TIFFTAG_ROWSPERSTRIP, ui32 );
	CopyField( TIFFTAG_SUBFILETYPE, ui32 );

	if( TIFFGetField( in, TIFFTAG_EXTRASAMPLES, &amp;ui16, &amp;a ) ) 
		TIFFSetField( out, TIFFTAG_EXTRASAMPLES, ui16, a );

	if( TIFFGetField( in, TIFFTAG_PAGENUMBER, &amp;ui16, &amp;ui16_2 ) ) 
		TIFFSetField( out, TIFFTAG_PAGENUMBER, ui16, ui16_2 );

	/* TIFFTAG_JPEGQUALITY is a pesudo-tag, so we can't copy it.
	 * Set explicitly from Wtiff.
	 */
	if( wtiff-&gt;compression == COMPRESSION_JPEG ) {
		TIFFSetField( out, TIFFTAG_JPEGQUALITY, wtiff-&gt;Q );

		/* Only for three-band, 8-bit images.
		 */
		if( wtiff-&gt;ready-&gt;Bands == 3 &amp;&amp;
			wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR ) { 
			/* Enable rgb-&gt;ycbcr conversion in the jpeg write. 
			 */
			if( !wtiff-&gt;rgbjpeg &amp;&amp;
				wtiff-&gt;Q &lt; 90 ) 
				TIFFSetField( out, 
					TIFFTAG_JPEGCOLORMODE, 
						JPEGCOLORMODE_RGB );

			/* And we want ycbcr expanded to rgb on read. Otherwise
			 * TIFFTileSize() will give us the size of a chrominance
			 * subsampled tile.
			 */
			TIFFSetField( in, 
				TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );
		}
	}

#ifdef HAVE_TIFF_COMPRESSION_WEBP
	/* More pseudotags we can't copy.
	 */
	if( wtiff-&gt;compression == COMPRESSION_WEBP ) {
		TIFFSetField( out, TIFFTAG_WEBP_LEVEL, wtiff-&gt;Q );
		TIFFSetField( out, TIFFTAG_WEBP_LOSSLESS, wtiff-&gt;lossless );
	}
	if( wtiff-&gt;compression == COMPRESSION_ZSTD ) {
		TIFFSetField( out, TIFFTAG_ZSTD_LEVEL, wtiff-&gt;level );
		if( wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
			TIFFSetField( out, 
				TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
	}
#endif /*HAVE_TIFF_COMPRESSION_WEBP*/

	if( (wtiff-&gt;compression == COMPRESSION_ADOBE_DEFLATE ||
		wtiff-&gt;compression == COMPRESSION_LZW) &amp;&amp;
		wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
		TIFFSetField( out, TIFFTAG_PREDICTOR, wtiff-&gt;predictor );

	/* We can't copy profiles or xmp :( Set again from wtiff.
	 */
	if( !wtiff-&gt;strip ) 
		if( wtiff_embed_profile( wtiff, out ) ||
			wtiff_embed_xmp( wtiff, out ) ||
			wtiff_embed_iptc( wtiff, out ) ||
			wtiff_embed_photoshop( wtiff, out ) ||
			wtiff_embed_imagedescription( wtiff, out ) )
			return( -1 );

	if( wtiff_copy_tiles( wtiff, out, in ) )
		return( -1 );

	return( 0 );
}

/* Append all of the layers we wrote to the output.
 */
static int
wtiff_gather( Wtiff *wtiff )
{
	Layer *layer;

	if( wtiff-&gt;layer &amp;&amp;
		wtiff-&gt;layer-&gt;below )
		for( layer = wtiff-&gt;layer-&gt;below; layer; 
			layer = layer-&gt;below ) {
			VipsSource *source;
			TIFF *in;

#ifdef DEBUG
			printf( "appending layer %s ...\n", layer-&gt;lname );
#endif /*DEBUG*/

			if( layer-&gt;lname ) {
				if( !(source = vips_source_new_from_file( 
					layer-&gt;lname )) ) 
					return( -1 );
			}
			else {
				if( !(source = vips_source_new_from_memory(
					layer-&gt;buf, layer-&gt;len )) )
					return( -1 );
			}

			if( !(in = vips__tiff_openin_source( source )) ) {
				VIPS_UNREF( source );
				return( -1 );
			}

			VIPS_UNREF( source );

			if( wtiff_copy_tiff( wtiff, wtiff-&gt;layer-&gt;tif, in ) ) {
				TIFFClose( in );
				return( -1 );
			}

			TIFFClose( in );

			if( !TIFFWriteDirectory( wtiff-&gt;layer-&gt;tif ) ) 
				return( -1 );
		}

	return( 0 );
}

/* Write one page from our input image, optionally pyramiding it.
 */
static int
wtiff_write_page( Wtiff *wtiff, VipsImage *page )
{
#ifdef DEBUG
	printf( "wtiff_write_page:\n" ); 
#endif /*DEBUG*/

	/* Init the pyramid framework for this page. This will just make a 
	 * single layer if we're not pyramiding.
	 */
	wtiff_layer_init( wtiff, &amp;wtiff-&gt;layer, NULL, 
		page-&gt;Xsize, page-&gt;Ysize );

	/* Fill all the layers and write the TIFF headers.
	 */
	if( wtiff_allocate_layers( wtiff ) ) 
		return( -1 );

	/* In ifd mode, we write the pyramid layers as subdirectories of this
	 * page.
	 */
	if( wtiff-&gt;subifd ) {
		int n_layers;
		toff_t *subifd_offsets;
		Layer *p;

#ifdef DEBUG
		printf( "wtiff_write_page: OME pyr mode\n" ); 
#endif /*DEBUG*/

		/* This magic tag makes the n_layers directories we write 
		 * after this one into subdirectories. We set the offsets to 0
		 * and libtiff will fill them in automatically.
		 */
		for( n_layers = 0, p = wtiff-&gt;layer-&gt;below; p; p = p-&gt;below )
			n_layers += 1;
		subifd_offsets = VIPS_ARRAY( NULL, n_layers, toff_t );
		memset( subifd_offsets, 0, n_layers * sizeof( toff_t ) );
		TIFFSetField( wtiff-&gt;layer-&gt;tif, TIFFTAG_SUBIFD, 
			n_layers, subifd_offsets );
		g_free( subifd_offsets );
	}

	if( vips_sink_disc( page, write_strip, wtiff ) ) 
		return( -1 );

	if( !TIFFWriteDirectory( wtiff-&gt;layer-&gt;tif ) ) 
		return( -1 );

	/* Append any pyr layers, if necessary.
	 */
	if( wtiff-&gt;layer-&gt;below ) {
		/* Free any lower pyramid resources ... this will 
		 * TIFFClose() (but not delete) the smaller layers 
		 * ready for us to read from them again.
		 */
		layer_free_all( wtiff-&gt;layer-&gt;below );

		/* Append smaller layers to the main file.
		 */
		if( wtiff_gather( wtiff ) ) 
			return( -1 );

		/* We can delete any temps now ready for the next page.
		 */
		wtiff_delete_temps( wtiff );

		/* And free all lower pyr layers ready to be rebuilt for the
		 * next page.
		 */
		VIPS_FREEF( layer_free_all, wtiff-&gt;layer-&gt;below );
	}

	return( 0 );
}

/* Write all pages.
 */
static int
wtiff_write_image( Wtiff *wtiff )
{
	int y;

	for( y = 0; y &lt; wtiff-&gt;ready-&gt;Ysize; y += wtiff-&gt;page_height ) {
		VipsImage *page;

#ifdef DEBUG
		printf( "writing page %d ...\n", wtiff-&gt;page_number );
#endif /*DEBUG*/

		if( vips_crop( wtiff-&gt;ready, &amp;page, 
			0, y, wtiff-&gt;ready-&gt;Xsize, wtiff-&gt;page_height,
			NULL ) )
			return( -1 ); 
		if( wtiff_write_page( wtiff, page ) ) {
			g_object_unref( page );
			return( -1 );
		}
		g_object_unref( page );

		wtiff-&gt;page_number += 1;
	}

	return( 0 );
}

int 
vips__tiff_write( VipsImage *input, const char *filename, 
	VipsForeignTiffCompression compression, int Q, 
	VipsForeignTiffPredictor predictor,
	const char *profile,
	gboolean tile, int tile_width, int tile_height,
	gboolean pyramid,
	int bitdepth,
	gboolean miniswhite,
	VipsForeignTiffResunit resunit, double xres, double yres,
	gboolean bigtiff,
	gboolean rgbjpeg,
	gboolean properties, gboolean strip,
	VipsRegionShrink region_shrink,
	int level, 
	gboolean lossless,
	VipsForeignDzDepth depth,
	gboolean subifd,
	gboolean premultiply )
{
	Wtiff *wtiff;

#ifdef DEBUG
	printf( "tiff2vips: libtiff version is \"%s\"\n", TIFFGetVersion() );
#endif /*DEBUG*/

	vips__tiff_init();

	if( !(wtiff = wtiff_new( input, filename, 
		compression, Q, predictor, profile,
                tile, tile_width, tile_height, pyramid, bitdepth,
		miniswhite, resunit, xres, yres, bigtiff, rgbjpeg, 
		properties, strip, region_shrink, level, lossless, depth,
		subifd, premultiply )) )
		return( -1 );

	if( wtiff_write_image( wtiff ) ) { 
		wtiff_free( wtiff );
		return( -1 );
	}

	wtiff_free( wtiff );

	return( 0 );
}

int 
vips__tiff_write_buf( VipsImage *input, 
	void **obuf, size_t *olen, 
	VipsForeignTiffCompression compression, int Q, 
	VipsForeignTiffPredictor predictor,
	const char *profile,
	gboolean tile, int tile_width, int tile_height,
	gboolean pyramid,
	int bitdepth,
	gboolean miniswhite,
	VipsForeignTiffResunit resunit, double xres, double yres,
	gboolean bigtiff,
	gboolean rgbjpeg,
	gboolean properties, gboolean strip, 
	VipsRegionShrink region_shrink,
	int level, 
	gboolean lossless,
	VipsForeignDzDepth depth,
	gboolean subifd,
	gboolean premultiply )
{
	Wtiff *wtiff;

	vips__tiff_init();

	if( !(wtiff = wtiff_new( input, NULL, 
		compression, Q, predictor, profile,
                tile, tile_width, tile_height, pyramid, bitdepth,
		miniswhite, resunit, xres, yres, bigtiff, rgbjpeg, 
		properties, strip, region_shrink, level, lossless, depth,
		subifd, premultiply )) )
		return( -1 );

	wtiff-&gt;obuf = obuf;
	wtiff-&gt;olen = olen;

	if( wtiff_write_image( wtiff ) ) { 
		wtiff_free( wtiff );
		return( -1 );
	}

	/* Now close the top layer, and we'll get a pointer we can return
	 * to our caller.
	 */
	VIPS_FREEF( TIFFClose, wtiff-&gt;layer-&gt;tif );

	*obuf = wtiff-&gt;layer-&gt;buf;
	*olen = wtiff-&gt;layer-&gt;len;

	/* Now our caller owns it, we must not free it.
	 */
	wtiff-&gt;layer-&gt;buf = NULL;

	wtiff_free( wtiff );

	return( 0 );
}

#endif /*HAVE_TIFF*/
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dzsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* save to deep zoom format
 *
 * 21/3/12
 * 	- from the tiff pyramid writer
 * 5/7/12 (thanks Alexander Koshman)
 * 	- make tiles down to 1x1 pixels 
 *	- oop make right-hand edge tiles 
 *	- improve overlap handling 
 * 7/7/12
 * 	- threaded write
 * 6/8/12 (thanks to Benjamin Gilbert for pointing out the errors)
 * 	- shrink down to a 1x1 pixel tile, even for very long and thin images
 * 	- round image size up on shrink
 * 	- write a .dzi file with the pyramid params
 * 	- default tile size and overlap now matches the openslide writer
 * 7/8/12 (thanks to Benjamin Gilbert again for more testing)
 * 	- reorganise the directory structure
 * 	- rename to basename and tile_size
 * 	- deprecate tile_width/_height and dirname 
 * 1/10/12
 * 	- did not write low pyramid layers for images with an odd number of
 * 	  scan lines (thanks Martin)
 * 2/10/12
 * 	- remove filename options from format string in .dzi (thanks Martin)
 * 3/10/12
 * 	- add zoomify and google maps output
 * 10/10/12
 * 	- add @background option
 * 1/11/12
 * 	- add @depth option
 * 21/1/13
 * 	- add @centre option
 * 26/2/13
 * 	- fix another corner case, thanks Martin
 * 29/5/13
 * 	- add --angle option
 * 19/6/13
 * 	- faster --centre logic, thanks Kacey
 * 18/4/14
 * 	- use libgsf for output so we can write to .zip etc. as well as the
 * 	  filesystem
 * 8/5/14
 * 	- set Type on strips so we can convert for save correctly, thanks
 * 	  philipgiuliani
 * 25/6/14
 * 	- stop on zip write &gt;4gb, thanks bgilbert
 * 	- save metadata, see https://github.com/libvips/libvips/issues/137
 * 18/8/14
 * 	- use g_ date funcs, helps Windows
 * 14/2/15
 * 	- use vips_region_shrink()
 * 22/2/15
 * 	- use a better temp dir name for fs dz output
 * 8/8/15
 * 	- allow zip &gt; 4gb if we have a recent libgsf
 * 9/9/15
 * 	- better overlap handling, thanks robclouth 
 * 24/11/15
 * 	- don't write almost blank tiles in google mode
 * 25/11/15
 * 	- always strip tile metadata 
 * 16/12/15
 * 	- fix overlap handling again, thanks erdmann
 * 8/6/16 Felix Bünemann
 * 	- add @compression option
 * 5/9/16
 * 	- more overlap changes to help gmaps mode
 * 8/9/16 Felix Bünemann
 * 	- move vips-properties out of subdir for gm and zoomify layouts
 * 15/10/16
 * 	- add dzsave_buffer
 * 11/11/16 Felix Bünemann
 * 	- better &gt;4gb detection for zip output on older libgsfs
 * 18/8/17
 * 	- shut down the output earlier to flush zip output
 * 24/11/17
 * 	- output overlap-only tiles on edges for better deepzoom spec
 * 	  compliance
 * 6/1/18
 * 	- add scan-properties.xml for szi output
 * 	- write all associated images
 * 19/12/18
 * 	- add @skip_blanks
 * 21/10/19
 * 	- add @no_strip
 * 9/11/19
 * 	- add IIIF layout
 * 24/4/20 [IllyaMoskvin]
 * 	- better IIIF tile naming
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*

   This is difficult to test, there are so many options.

   It's failed in the past in these cases. These have layers with strips which 
   exactly align with image edges, or which have orphan scanlines which need 
   adding for the shrink. 

   1.	$ header test.v
	test.v: 14016x16448 uchar, 3 bands, srgb, openin VipsImage (0x11e7060)
	$ time vips dzsave test.v x --overlap 0

	Not all layers written.

   2.	$ header ~/Desktop/leicaimage.scn 
	/home/john/Desktop/leicaimage.scn: 4225x7905 uchar, 4 bands, rgb

	Not all layers written. 

    3.	$ header ~/leicatest1.scn 
	/home/john/leicatest1.scn: 11585x8449 uchar, 4 bands, rgb

	Not all layers written. 

   various combinations of odd and even tile-size and overlap need testing too.

	Overlap handling

   For deepzoom, tile-size == 254 and overlap == 1 means that edge tiles are 
   255 x 255 (though less at the bottom right) and non-edge tiles are 256 x 
   256. Tiles are positioned across the image in tile-size steps. This means 
   (confusingly) that two adjoining tiles will have two pixels in common.

   This has caused bugs in the past. 

 */

/*
#define DEBUG_VERBOSE
#define VIPS_DEBUG
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;

#ifdef HAVE_GSF

/* Disable deprecation warnings from gsf. There are loads, and still not
 * patched as of 12/2020.
 */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#include &lt;gsf/gsf.h&gt;
#pragma GCC diagnostic pop

/* Simple wrapper around libgsf.
 *
 * We need to be able to do scattered writes to structured files. So while
 * building a zip (for example) we need to be able to write to file/a/b.jpg,
 * then to file/c/d.jpg, then back to file/a/e.jpg. This is tricky with the
 * libgsf API which is happier doing writes in order.
 *
 * Put an API over libgsf to track refs to all directories and finish/close
 * them.
 */

/* Need to track the directory tree we are writing, with a ref for each
 * GsfOutput.
 */
typedef struct _VipsGsfDirectory { 
	struct _VipsGsfDirectory *parent;
	char *name;

	/* List of child directories, if any.
	 */
	GSList *children;

	/* The GsfOutput we use for this object.
	 */
	GsfOutput *out;

	/* The root node holds the enclosing zip file or FS root ... finish
	 * this on cleanup.
	 */
        GsfOutput *container;

	/* Track number of files in tree and total length of filenames. We use
	 * this to estimate zip size to spot a &gt;4gb write.
	 */
	size_t file_count;
	size_t filename_lengths;

	/* Set deflate compression level for zip container.
	 */
	gint deflate_level;

} VipsGsfDirectory; 

static void *vips_gsf_tree_close( VipsGsfDirectory *tree );

static void *
vips_gsf_tree_close_cb( void *item, void *a, void *b )
{
	VipsGsfDirectory *tree = (VipsGsfDirectory *) item;

	return( vips_gsf_tree_close( tree ) );
}

/* Close all dirs, non-NULL on error.
 */
static void *
vips_gsf_tree_close( VipsGsfDirectory *tree )
{
	vips_slist_map2( tree-&gt;children, vips_gsf_tree_close_cb, NULL, NULL );

	if( tree-&gt;out ) {
		if( !gsf_output_is_closed( tree-&gt;out ) &amp;&amp;
			!gsf_output_close( tree-&gt;out ) ) {
			vips_error( "vips_gsf", 
				"%s", _( "unable to close stream" ) ); 
			return( tree );
		}

		VIPS_UNREF( tree-&gt;out );
	}

	if( tree-&gt;container ) { 
		if( !gsf_output_is_closed( tree-&gt;container ) &amp;&amp; 
			!gsf_output_close( tree-&gt;container ) ) {
			vips_error( "vips_gsf", 
				"%s", _( "unable to close stream" ) ); 
			return( tree );
		}

		VIPS_UNREF( tree-&gt;container );
	}

	VIPS_FREEF( g_slist_free, tree-&gt;children );
	VIPS_FREE( tree-&gt;name );
	VIPS_FREE( tree );

	return( NULL ); 
}

/* Make a new tree root.
 */
static VipsGsfDirectory *
vips_gsf_tree_new( GsfOutput *out, gint deflate_level )
{
	VipsGsfDirectory *tree = g_new( VipsGsfDirectory, 1 );

	tree-&gt;parent = NULL;
	tree-&gt;name = NULL;
	tree-&gt;children = NULL;
	tree-&gt;out = out;
	tree-&gt;container = NULL;
	tree-&gt;file_count = 0;
	tree-&gt;filename_lengths = 0;
	tree-&gt;deflate_level = deflate_level;

	return( tree ); 
}

static void *
vips_gsf_child_by_name_sub( VipsGsfDirectory *dir, const char *name, void *b )
{
	if( strcmp( dir-&gt;name, name ) == 0 )
		return( dir );

	return( NULL ); 
}

/* Look up a child by name.
 */
static VipsGsfDirectory *
vips_gsf_child_by_name( VipsGsfDirectory *dir, const char *name )
{
	return( vips_slist_map2( dir-&gt;children, 
		(VipsSListMap2Fn) vips_gsf_child_by_name_sub, 
		(char *) name, NULL ) );
}

/* Make a new directory.
 */
static VipsGsfDirectory *
vips_gsf_dir_new( VipsGsfDirectory *parent, const char *name )
{
	VipsGsfDirectory *dir = g_new( VipsGsfDirectory, 1 );

	g_assert( !vips_gsf_child_by_name( parent, name ) ); 

	dir-&gt;parent = parent;
	dir-&gt;name = g_strdup( name );
	dir-&gt;children = NULL;
	dir-&gt;container = NULL;
	dir-&gt;file_count = 0;
	dir-&gt;filename_lengths = 0;
	dir-&gt;deflate_level = parent-&gt;deflate_level;

	if( GSF_IS_OUTFILE_ZIP( parent-&gt;out ) )
		dir-&gt;out = gsf_outfile_new_child_full( 
			(GsfOutfile *) parent-&gt;out, 
			name, TRUE,
			"compression-level", GSF_ZIP_STORED,
			NULL );
	else
		dir-&gt;out = gsf_outfile_new_child( 
			(GsfOutfile *) parent-&gt;out, 
			name, TRUE ); 

	g_assert( dir-&gt;out ); 

	parent-&gt;children = g_slist_prepend( parent-&gt;children, dir ); 

	return( dir ); 
}

/* Return a GsfOutput for writing to a path. Paths are object name first, then
 * path components with least-specific first, NULL-terminated. For example:
 *
 * GsfOutput *obj = vips_gsf_path( tree, "fred.jpg", "a", "b", NULL );
 *
 * Returns an obj you can use to write to a/b/fred.jpg. 
 *
 * You must write, close and unref obj.
 */
static GsfOutput *
vips_gsf_path( VipsGsfDirectory *tree, const char *name, ... )
{
	va_list ap;
	VipsGsfDirectory *dir;
	VipsGsfDirectory *child;
	char *dir_name;
	GsfOutput *obj;

	/* vips_gsf_path() always makes a new file, though it may add to an
	 * existing directory. Note the file, and note the length of the full
	 * path we are creating.
	 */
	tree-&gt;file_count += 1;
	tree-&gt;filename_lengths += 
		strlen( tree-&gt;out-&gt;name ) + strlen( name ) + 1;

	dir = tree; 
	va_start( ap, name );
	while( (dir_name = va_arg( ap, char * )) ) {
		if( (child = vips_gsf_child_by_name( dir, dir_name )) )
			dir = child;
		else 
			dir = vips_gsf_dir_new( dir, dir_name );

		tree-&gt;filename_lengths += strlen( dir_name ) + 1;
	}
	va_end( ap );

	if( GSF_IS_OUTFILE_ZIP( dir-&gt;out ) ) {
		/* Confusingly, libgsf compression-level really means
		 * compression-method. They have a separate deflate-level 
		 * property for the deflate compression level.
		 */
		if( dir-&gt;deflate_level == 0 )
			obj = gsf_outfile_new_child_full(
				(GsfOutfile *) dir-&gt;out,
				name, FALSE,
				"compression-level", GSF_ZIP_STORED,
				NULL );
		else if( dir-&gt;deflate_level == -1 )
			obj = gsf_outfile_new_child_full(
				(GsfOutfile *) dir-&gt;out,
				name, FALSE,
				"compression-level", GSF_ZIP_DEFLATED,
				NULL );
		else
			obj = gsf_outfile_new_child_full(
				(GsfOutfile *) dir-&gt;out,
				name, FALSE,
				"compression-level", GSF_ZIP_DEFLATED,
				"deflate-level", dir-&gt;deflate_level,
				NULL );
	}
	else
		obj = gsf_outfile_new_child( (GsfOutfile *) dir-&gt;out,
			name, FALSE ); 

	return( obj ); 
}

typedef struct _VipsForeignSaveDz VipsForeignSaveDz;
typedef struct _Layer Layer;

/* A layer in the pyramid.
 */
struct _Layer {
	VipsForeignSaveDz *dz;

	/* The real size of the image. image-&gt;Xsize and image-&gt;Ysize are
	 * always even to make x2 shrink easy. The real image may be a 
	 * smaller, odd size, 
	 */
	int width;
	int height;

	/* Number of tiles across and down in this layer. Zoomify needs this
	 * to calculate the directory to put each tile in.
	 */
	int tiles_across;
	int tiles_down;

	/* The rect within width/height that contains real image, as opposed
	 * to background. In centre mode we can have large image borders.
	 */
	VipsRect real_pixels; 

	/* The image we build.
	 */
	VipsImage *image;

	/* The top of this strip of tiles.
	 */
	int y;

	/* The next line we write to in this strip. 
	 */
	int write_y;

	VipsRegion *strip;		/* The current strip of pixels */
	VipsRegion *copy;		/* Pixels we copy to the next strip */

	int sub;			/* Subsample factor for this layer */
	int n;				/* Layer number ... 0 for smallest */

	Layer *below;			/* Tiles go to here */
	Layer *above;			/* Tiles come from here */
};

struct _VipsForeignSaveDz {
	VipsForeignSave parent_object;

	char *suffix;
	int overlap;
	int tile_size;
	VipsForeignDzLayout layout;
	VipsForeignDzDepth depth;
	gboolean centre;
	gboolean properties;
	VipsAngle angle;
	VipsForeignDzContainer container; 
	int compression;
	VipsRegionShrink region_shrink;
	int skip_blanks;
	gboolean no_strip;
	char *id;

	/* Tile and overlap geometry. The members above are the parameters we
	 * accept, this next set are the derived values which are actually 
	 * used in pyramid generation.
	 *
	 * Tiles have a base tile_size. Imagine a square placed at the top left.
	 * This is the size of that square.
	 *
	 * Tiles have a margin. The square from tile_size is expanded outward 
	 * up/down/left/right by this amount. Parts going off the image are 
	 * clipped. 
	 *
	 * Each time we write a new tile, we step the position by tile_step
	 * pixels. 
	 *
	 * We need all three of tile_size, tile_margin and tile_step since
	 * deepzoom and google maps have different meanings for overlap and we
	 * want to be able to support both models.
	 *
	 * For deepzoom:
	 *
	 * 	tile_margin = overlap
	 * 	tile_step = tile_size
	 *
	 * For google maps:
	 *
	 * 	tile_margin = 0
	 *	tile_step = tile_size - overlap
	 */
	int tile_margin;
	int tile_step;

	Layer *layer;			/* x2 shrink pyr layer */

	/* Count zoomify tiles we write.
	 */
	int tile_count;

	/* The tree structure we are writing tiles to. Can be filesystem, a
	 * zipfile, etc. 
	 */
	VipsGsfDirectory *tree;

	/* The actual output object our zip (or whatever) is writing to.
	 */
	GsfOutput *out;

	/* The name to save as, eg. deepzoom tiles go into ${basename}_files.
	 * No suffix, no path at the start. 
	 */
	char *basename; 

	/* The directory we write the output to, or NULL for memory output. 
	 */
	char *dirname; 

	/* For DZ save, we have to write to a temp dir. Track the name here.
	 */
	char *tempdir;

	/* The root directory name ... $basename with perhaps some extra
	 * stuff, eg. $(basename)_files, etc.
	 */
	char *root_name; 

	/* @suffix, but without any options. So @suffix == ".jpg[Q=90]"
	 * becomes ".jpg".
	 */
	char *file_suffix;

	/* libgsf before 1.14.31 can't write zip files larger than 4gb. 
	 * Track bytes written here and try to guess when we'll go over.
	 */
	size_t bytes_written;

	/* save-&gt;background turned into a pixel that matches the image we are
	 * saving .. used to test for blank tiles.
	 */
	VipsPel *ink;

};

typedef VipsForeignSaveClass VipsForeignSaveDzClass;

G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveDz, vips_foreign_save_dz, 
	VIPS_TYPE_FOREIGN_SAVE );

/* ZIP and SZI are both written as zip files.
 */
static gboolean
iszip( VipsForeignDzContainer container )
{
	switch( container ) {
	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
		return( TRUE );

	default:
		return( FALSE );
	}
}

#define VIPS_ZIP_FIXED_LH_SIZE (30 + 29)
#define VIPS_ZIP_FIXED_CD_SIZE (46 + 9)
#define VIPS_ZIP_EOCD_SIZE 22

#ifndef HAVE_GSF_ZIP64
static size_t
estimate_zip_size( VipsForeignSaveDz *dz )
{
	size_t estimated_zip_size = dz-&gt;bytes_written +
		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_LH_SIZE +
		dz-&gt;tree-&gt;filename_lengths +
		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_CD_SIZE +
		dz-&gt;tree-&gt;filename_lengths +
		VIPS_ZIP_EOCD_SIZE;

#ifdef DEBUG_VERBOSE
	printf( "estimate_zip_size: %zd\n", estimated_zip_size );
#endif /*DEBUG_VERBOSE*/

	return( estimated_zip_size );
}
#endif /*HAVE_GSF_ZIP64*/

static int
write_image( VipsForeignSaveDz *dz,
	GsfOutput *out, VipsImage *image, const char *format )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz );

	VipsImage *t;
	void *buf;
	size_t len;

	/* We need to block progress signalling on individual image write, so
	 * we need a copy of the tile in case it's shared (eg. associated
	 * images).
	 */
	if( vips_copy( image, &amp;t, NULL ) ) 
		return( -1 );

	/* We default to stripping all metadata. "no_strip" turns this
	 * off. Most people don't want metadata on every tile.
	 */
	vips_image_set_int( t, "hide-progress", 1 );
	if( vips_image_write_to_buffer( t, format, &amp;buf, &amp;len,
		"strip", !dz-&gt;no_strip,
		NULL ) ) {
		VIPS_UNREF( t );
		return( -1 );
	}
	VIPS_UNREF( t );

	/* gsf doesn't like more than one write active at once.
	 */
	g_mutex_lock( vips__global_lock );

	if( !gsf_output_write( out, len, buf ) ) {
		gsf_output_close( out );
		g_mutex_unlock( vips__global_lock );
		g_free( buf );
		vips_error( class-&gt;nickname,
			"%s", gsf_output_error( out )-&gt;message );

		return( -1 );
	}

	dz-&gt;bytes_written += len;

	gsf_output_close( out );

#ifndef HAVE_GSF_ZIP64
	if( iszip( dz-&gt;container ) ) {
		/* Leave 3 entry headroom for blank.png and metadata files.
		 */
		if( dz-&gt;tree-&gt;file_count + 3 &gt;= (unsigned int) USHRT_MAX ) {
			g_mutex_unlock( vips__global_lock );

			vips_error( class-&gt;nickname,
				"%s", _( "too many files in zip" ) );
			return( -1 );
		}

		/* Leave 16k headroom for blank.png and metadata files. 
		 */
		if( estimate_zip_size( dz ) &gt; (size_t) UINT_MAX - 16384) {
			g_mutex_unlock( vips__global_lock );

			vips_error( class-&gt;nickname,
				"%s", _( "output file too large" ) ); 
			return( -1 ); 
		}
	}
#endif /*HAVE_GSF_ZIP64*/

	g_mutex_unlock( vips__global_lock );

	g_free( buf );

	return( 0 );
}

/* Free a pyramid.
 */
static void
layer_free( Layer *layer )
{
	VIPS_FREEF( g_object_unref, layer-&gt;strip );
	VIPS_FREEF( g_object_unref, layer-&gt;copy );
	VIPS_FREEF( g_object_unref, layer-&gt;image );

	VIPS_FREEF( layer_free, layer-&gt;below ); 
}

static void
vips_foreign_save_dz_dispose( GObject *gobject )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) gobject;

	VIPS_FREEF( layer_free, dz-&gt;layer );
	VIPS_FREEF( vips_gsf_tree_close,  dz-&gt;tree );
	VIPS_FREEF( g_object_unref, dz-&gt;out );
	VIPS_FREE( dz-&gt;basename );
	VIPS_FREE( dz-&gt;dirname );
	VIPS_FREE( dz-&gt;tempdir );
	VIPS_FREE( dz-&gt;root_name );
	VIPS_FREE( dz-&gt;file_suffix );

	G_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
		dispose( gobject );
}

/* Build a pyramid. 
 *
 * width/height is the size of this layer, real_* the subsection of the layer
 * which is real pixels (as opposed to background). 
 */
static Layer *
pyramid_build( VipsForeignSaveDz *dz, Layer *above, 
	int width, int height, VipsRect *real_pixels )
{
	VipsForeignSave *save = VIPS_FOREIGN_SAVE( dz );
	Layer *layer = VIPS_NEW( dz, Layer );

	VipsRect strip;
	int limit; 

	layer-&gt;dz = dz;
	layer-&gt;width = width;
	layer-&gt;height = height;

	/* We need to output all possible tiles, even if they give no new pixels.
	 */
	layer-&gt;tiles_across = VIPS_ROUND_UP( width, dz-&gt;tile_step ) / 
		dz-&gt;tile_step;
	layer-&gt;tiles_down = VIPS_ROUND_UP( height, dz-&gt;tile_step ) / 
		dz-&gt;tile_step;

	layer-&gt;real_pixels = *real_pixels; 

	layer-&gt;image = NULL;
	layer-&gt;strip = NULL;
	layer-&gt;copy = NULL;

	if( !above )
		/* Top of pyramid.
		 */
		layer-&gt;sub = 1;	
	else
		layer-&gt;sub = above-&gt;sub * 2;

	layer-&gt;below = NULL;
	layer-&gt;above = above;

	/* We round the image size up to an even number to make x2 shrink
	 * easy.
	 */
	layer-&gt;image = vips_image_new();
	if( vips_image_pipelinev( layer-&gt;image, 
		VIPS_DEMAND_STYLE_ANY, save-&gt;ready, NULL ) ) {
		layer_free( layer );
		return( NULL );
	}
	layer-&gt;image-&gt;Xsize = width + (width &amp; 1);
	layer-&gt;image-&gt;Ysize = height + (height &amp; 1);

	layer-&gt;strip = vips_region_new( layer-&gt;image );
	layer-&gt;copy = vips_region_new( layer-&gt;image );

	/* The regions will get used in the bg thread callback, so make sure
	 * we don't own them.
	 */
	vips__region_no_ownership( layer-&gt;strip );
	vips__region_no_ownership( layer-&gt;copy );

	/* Build a line of tiles here. 
	 *
	 * Expand the strip if necessary to make sure we have an even 
	 * number of lines. 
	 *
	 * This is just the height of the first row of tiles, so only add 1*
	 * tile_margin.
	 */
	layer-&gt;y = 0;
	layer-&gt;write_y = 0;
	strip.left = 0;
	strip.top = 0;
	strip.width = layer-&gt;image-&gt;Xsize;
	strip.height = dz-&gt;tile_size + dz-&gt;tile_margin;
	if( (strip.height &amp; 1) == 1 )
		strip.height += 1;
	if( vips_region_buffer( layer-&gt;strip, &amp;strip ) ) {
		layer_free( layer );
		return( NULL );
	}

	switch( dz-&gt;depth ) {
	case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
		limit = 1;
		break;

	case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
		limit = dz-&gt;tile_size;
		break;

	case VIPS_FOREIGN_DZ_DEPTH_ONE:
		limit = VIPS_MAX( width, height );
		break;

	default:
		g_assert_not_reached();

		/* Stop compiler warnings.
		 */
		limit = 1;
	}

	if( width &gt; limit || 
		height &gt; limit ) {
		/* Round up, so eg. a 5 pixel wide image becomes 3 a layer
		 * down.
		 *
		 * For the rect, round left/top down, round bottom/right up,
		 * so we get all possible pixels. 
		 */
		VipsRect halfrect;

		halfrect.left = real_pixels-&gt;left / 2;
		halfrect.top = real_pixels-&gt;top / 2;
		halfrect.width = (VIPS_RECT_RIGHT( real_pixels ) + 1) / 2 - 
			halfrect.left;
		halfrect.height = (VIPS_RECT_BOTTOM( real_pixels ) + 1) / 2 - 
			halfrect.top;

		if( !(layer-&gt;below = pyramid_build( dz, layer, 
			(width + 1) / 2, (height + 1) / 2,
			&amp;halfrect )) ) { 
			layer_free( layer );
			return( NULL );
		}
		layer-&gt;n = layer-&gt;below-&gt;n + 1;
	}
	else
		layer-&gt;n = 0;

#ifdef DEBUG
	printf( "pyramid_build:\n" );
	printf( "\tn = %d\n", layer-&gt;n );
	printf( "\twidth = %d, height = %d\n", width, height );
	printf( "\tXsize = %d, Ysize = %d\n", 
		layer-&gt;image-&gt;Xsize, layer-&gt;image-&gt;Ysize );
	printf( "\ttiles_across = %d, tiles_down = %d\n", 
		layer-&gt;tiles_across, layer-&gt;tiles_down ); 
	printf( "\treal_pixels.left = %d, real_pixels.top = %d\n", 
		real_pixels-&gt;left, real_pixels-&gt;top ); 
	printf( "\treal_pixels.width = %d, real_pixels.height = %d\n", 
		real_pixels-&gt;width, real_pixels-&gt;height ); 
#endif /*DEBUG*/

	return( layer );
}

static int
write_dzi( VipsForeignSaveDz *dz )
{
	GsfOutput *out;
	char buf[VIPS_PATH_MAX];
	char *p;

	vips_snprintf( buf, VIPS_PATH_MAX, "%s.dzi", dz-&gt;basename );
	out = vips_gsf_path( dz-&gt;tree, buf, NULL ); 

	vips_snprintf( buf, VIPS_PATH_MAX, "%s", dz-&gt;suffix + 1 );
	if( (p = (char *) vips__find_rightmost_brackets( buf )) )
		*p = '\0';

	gsf_output_printf( out, "&lt;?xml "
		"version=\"1.0\" encoding=\"UTF-8\"?&gt;\n" ); 
	gsf_output_printf( out, "&lt;Image "
		"xmlns=\"http://schemas.microsoft.com/deepzoom/2008\"\n" );
	gsf_output_printf( out, "  Format=\"%s\"\n", buf );
	gsf_output_printf( out, "  Overlap=\"%d\"\n", dz-&gt;overlap );
	gsf_output_printf( out, "  TileSize=\"%d\"\n", dz-&gt;tile_size );
	gsf_output_printf( out, "  &gt;\n" ); 
	gsf_output_printf( out, "  &lt;Size \n" );
	gsf_output_printf( out, "    Height=\"%d\"\n", dz-&gt;layer-&gt;height );
	gsf_output_printf( out, "    Width=\"%d\"\n", dz-&gt;layer-&gt;width );
	gsf_output_printf( out, "  /&gt;\n" ); 
	gsf_output_printf( out, "&lt;/Image&gt;\n" );

	(void) gsf_output_close( out );
	g_object_unref( out );

	return( 0 );
}

static int
write_properties( VipsForeignSaveDz *dz )
{
	GsfOutput *out;

	out = vips_gsf_path( dz-&gt;tree, "ImageProperties.xml", NULL ); 

	gsf_output_printf( out, "&lt;IMAGE_PROPERTIES "
		"WIDTH=\"%d\" HEIGHT=\"%d\" NUMTILES=\"%d\" "
		"NUMIMAGES=\"1\" VERSION=\"1.8\" TILESIZE=\"%d\" /&gt;\n",
		dz-&gt;layer-&gt;width,
		dz-&gt;layer-&gt;height,
		dz-&gt;tile_count,
		dz-&gt;tile_size );

	(void) gsf_output_close( out );
	g_object_unref( out );

	return( 0 );
}

static int
write_blank( VipsForeignSaveDz *dz )
{
	VipsForeignSave *save = (VipsForeignSave *) dz;

	VipsImage *x, *t;
	int n;
	VipsArea *ones;
	double *d;
	double *bg;
	int i;
	GsfOutput *out; 

	/* Number of bands we will end up making. We need to set this in
	 * vips_black() to make sure we set Type correctly, otherwise we can
	 * try saving a B_W image as PNG, with disasterous results.
	 */
	bg = (double *) vips_area_get_data( VIPS_AREA( save-&gt;background ), 
		NULL, &amp;n, NULL, NULL );

	if( vips_black( &amp;x, dz-&gt;tile_size, dz-&gt;tile_size, "bands", n, NULL ) ) 
		return( -1 );

	ones = vips_area_new_array( G_TYPE_DOUBLE, sizeof( double ), n );
	d = (double *) vips_area_get_data( ones, NULL, NULL, NULL, NULL );
	for( i = 0; i &lt; n; i++ )
		d[i] = 1.0; 

	if( vips_linear( x, &amp;t, d, bg, n, NULL ) ) {
		vips_area_unref( ones );
		g_object_unref( x );
		return( -1 );
	}
	vips_area_unref( ones );
	g_object_unref( x );
	x = t;

	out = vips_gsf_path( dz-&gt;tree, "blank.png", NULL ); 

	if( write_image( dz, out, x, ".png" ) ) {
		g_object_unref( out );
		g_object_unref( x );

		return( -1 );
	}

	g_object_unref( out );

	g_object_unref( x );

	return( 0 );
}

/* Write IIIF JSON metadata.
 */
static int
write_json( VipsForeignSaveDz *dz )
{
	/* Can be NULL for memory output.
	 */
	const char *name = dz-&gt;basename ? dz-&gt;basename : "untitled";

	/* dz-&gt;file_suffix has a leading "." character.
	 */
	const char *suffix = dz-&gt;file_suffix[0] == '.' ? 
		dz-&gt;file_suffix + 1 : dz-&gt;file_suffix;

	GsfOutput *out;
	int i;

	out = vips_gsf_path( dz-&gt;tree, "info.json", NULL ); 

	gsf_output_printf( out, 
		"{\n"
		"  \"@context\": \"http://iiif.io/api/image/2/context.json\",\n"
		"  \"@id\": \"%s/%s\",\n" 
		"  \"profile\": [\n"
		"    \"http://iiif.io/api/image/2/level0.json\",\n"
		"    {\n" 
		"      \"formats\": [\n"
		"        \"%s\"\n"
		"      ],\n"
		"      \"qualities\": [\n"
		"        \"default\"\n"
		"      ]\n"
		"    }\n"
		"  ],\n"
		"  \"protocol\": \"http://iiif.io/api/image\",\n", 
		dz-&gt;id ? dz-&gt;id : "https://example.com/iiif",
		name, 
		suffix );

	/* "sizes" is needed for the full/ set of untiled images, which we 
	 * don't yet support. Leave this commented out for now.

	gsf_output_printf( out, 
		"  \"sizes\": [\n" );

	for( i = 0; i &lt; dz-&gt;layer-&gt;n + 5; i++ ) {
		gsf_output_printf( out, 
			"    {\n"
			"      \"width\": %d,\n"
			"      \"height\": \"full\"\n"
			"    }", 
				1 &lt;&lt; (i + 4) );
		if( i != dz-&gt;layer-&gt;n - 4 )
			gsf_output_printf( out, "," );
		gsf_output_printf( out, "\n" );
	}

	gsf_output_printf( out, 
		"  ],\n" );

	 */

	/* The set of pyramid layers we have written.
	 */
	gsf_output_printf( out, 
		"  \"tiles\": [\n"
		"    {\n"
		"      \"scaleFactors\": [\n" );

	for( i = 0; i &lt; dz-&gt;layer-&gt;n; i++ ) {
		gsf_output_printf( out, 
			"        %d",
				1 &lt;&lt; i );
		if( i != dz-&gt;layer-&gt;n - 1 )
			gsf_output_printf( out, "," );
		gsf_output_printf( out, "\n" );
	}

	gsf_output_printf( out, 
		"      ],\n"
		"      \"width\": %d\n"
		"    }\n"
		"  ],\n", dz-&gt;tile_size );

	gsf_output_printf( out, 
		"  \"width\": %d,\n"
		"  \"height\": %d\n", 
			dz-&gt;layer-&gt;width,
			dz-&gt;layer-&gt;height );

	gsf_output_printf( out, 
		"}\n" );

	(void) gsf_output_close( out );
	g_object_unref( out );

	return( 0 );
}

static int
write_vips_meta( VipsForeignSaveDz *dz )
{
	VipsForeignSave *save = (VipsForeignSave *) dz;

	char *dump;
	GsfOutput *out;

	if( !(dump = vips__xml_properties( save-&gt;ready )) )
                return( -1 );

	/* For deepzom the props must go inside the ${name}_files subdir, for
	 * gm and zoomify it can sit in the main folder.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
		out = vips_gsf_path( dz-&gt;tree, 
			"vips-properties.xml", dz-&gt;root_name, NULL );
	else
		out = vips_gsf_path( dz-&gt;tree, "vips-properties.xml", NULL );

	gsf_output_write( out, strlen( dump ), (guchar *) dump ); 
	(void) gsf_output_close( out );
	g_object_unref( out );

	g_free( dump );

	return( 0 );
}

static void
build_scan_property( VipsDbuf *dbuf, VipsImage *image, 
	const char *vips_name, const char *szi_name )
{
	const char *str;
	GValue value = { 0 };
	GValue save_value = { 0 };
	GType type;

	if( !vips_image_get_typeof( image, vips_name ) )
		return;

	if( vips_image_get( image, vips_name, &amp;value ) )
		return;
	type = G_VALUE_TYPE( &amp;value );

	if( !g_value_type_transformable( type, VIPS_TYPE_SAVE_STRING ) ) {
		g_value_unset( &amp;value );
		return;
	}

	g_value_init( &amp;save_value, VIPS_TYPE_SAVE_STRING );
	if( !g_value_transform( &amp;value, &amp;save_value ) ) {
		g_value_unset( &amp;value );
		return;
	}
	g_value_unset( &amp;value );

	if( !(str = vips_value_get_save_string( &amp;save_value )) ) {
		g_value_unset( &amp;save_value );
		return;
	}

	if( !g_utf8_validate( str, -1, NULL ) ) {
		g_value_unset( &amp;save_value );
		return;
	}

	vips_dbuf_writef( dbuf, "    &lt;property&gt;\n" );
	vips_dbuf_writef( dbuf, "      &lt;name&gt;" );
	vips_dbuf_write_amp( dbuf, szi_name );
	vips_dbuf_writef( dbuf, "&lt;/name&gt;\n" );
	vips_dbuf_writef( dbuf, "      &lt;value type=\"%s\"&gt;",
		g_type_name( type )  );
	vips_dbuf_write_amp( dbuf, str );
	vips_dbuf_writef( dbuf, "&lt;/value&gt;\n" );
	vips_dbuf_writef( dbuf, "    &lt;/property&gt;\n" );

	g_value_unset( &amp;save_value );
}

static char *scan_property_names[][2] = {
	{ "openslide.vendor", "Vendor" },
	{ "openslide.objective-power", "ObjectiveMagnification" },
	{ "openslide.mpp-x", "MicronsPerPixelX" },
	{ "openslide.mpp-y", "MicronsPerPixelY" },
	{ "width", "ImageWidth" },
	{ "height", "ImageHeight" }
};

/* Make the xml we write to scan-properties.xml in szi write.
 * Free with g_free().
 */
char *
build_scan_properties( VipsImage *image )
{
	VipsDbuf dbuf;
	char *date;
	int i;

	date = vips__get_iso8601();

	vips_dbuf_init( &amp;dbuf );
	vips_dbuf_writef( &amp;dbuf, "&lt;?xml version=\"1.0\"?&gt;\n" ); 
	vips_dbuf_writef( &amp;dbuf, "&lt;image xmlns=\"http://www.pathozoom.com/szi\""
		" date=\"%s\" version=\"1.0\"&gt;\n", date );
	vips_dbuf_writef( &amp;dbuf, "  &lt;properties&gt;\n" );  

	g_free( date ); 

	for( i = 0; i &lt; VIPS_NUMBER( scan_property_names ); i++ )
		build_scan_property( &amp;dbuf, image,
			scan_property_names[i][0],
			scan_property_names[i][1] );

	vips_dbuf_writef( &amp;dbuf, "  &lt;/properties&gt;\n" );
	vips_dbuf_writef( &amp;dbuf, "&lt;/image&gt;\n" );

	return( (char *) vips_dbuf_steal( &amp;dbuf, NULL ) ); 
}

static int
write_scan_properties( VipsForeignSaveDz *dz )
{
	VipsForeignSave *save = (VipsForeignSave *) dz;

	char *dump;
	GsfOutput *out;

	if( !(dump = build_scan_properties( save-&gt;ready )) )
                return( -1 );

	out = vips_gsf_path( dz-&gt;tree, "scan-properties.xml", NULL );
	gsf_output_write( out, strlen( dump ), (guchar *) dump );
	(void) gsf_output_close( out );
	g_object_unref( out );

	g_free( dump );

	return( 0 );
}

static void *
write_associated_images( VipsImage *image,
	const char *field, GValue *value, void *a )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;

	if( vips_isprefix( "openslide.associated.", field ) ) {
		VipsImage *associated;
		const char *p;
		const char *q;
		GsfOutput *out;
		char buf[VIPS_PATH_MAX];

		p = field + strlen( "openslide.associated." );

		/* Make sure there are no '/' in the filename.
		 */
		if( (q = strrchr( p, '/' )) )
			p = q + 1;

		if( vips_image_get_image( image, field, &amp;associated ) )
			return( image );

		vips_snprintf( buf, VIPS_PATH_MAX, "%s.jpg", p );
		out = vips_gsf_path( dz-&gt;tree, buf, "associated_images", NULL );

		if( write_image( dz, out, associated, ".jpg" ) ) {
			g_object_unref( out );
			g_object_unref( associated );

			return( image );
		}

		g_object_unref( out );

		g_object_unref( associated );
	}

	return( NULL );
}

static int
write_associated( VipsForeignSaveDz *dz )
{
	VipsForeignSave *save = (VipsForeignSave *) dz;

	if( vips_image_map( save-&gt;ready, write_associated_images, dz ) )
		return( -1 );

	return( 0 );
}

/* Our state during a threaded write of a strip.
 */
typedef struct _Strip {
	Layer *layer; 

	VipsImage *image;

	/* Allocate the next tile on this boundary. 
	 */
	int x;
} Strip;

static void
strip_free( Strip *strip )
{
	g_object_unref( strip-&gt;image );
}

static void
strip_init( Strip *strip, Layer *layer )
{
	VipsForeignSaveDz *dz = layer-&gt;dz;

	VipsRect line, image;

	strip-&gt;layer = layer;
	strip-&gt;image = NULL;
	strip-&gt;x = 0;

	/* The image we wrap around our pixel buffer must be the full width,
	 * including any rounding up, since we must have contiguous pixels.
	 * We can trim the height down though.
	 *
	 * When we loop across the strip writing tiles we have to look out for
	 * the smaller width.
	 */
	image.left = 0;
	image.top = 0;
	image.width = layer-&gt;image-&gt;Xsize;
	image.height = layer-&gt;height;

	line.left = 0;
	line.top = layer-&gt;y;
	line.width = image.width;
	line.height = dz-&gt;tile_size;
	vips_rect_marginadjust( &amp;line, dz-&gt;tile_margin );

	vips_rect_intersectrect( &amp;image, &amp;line, &amp;line );

	if( !(strip-&gt;image = vips_image_new_from_memory( 
		VIPS_REGION_ADDR( layer-&gt;strip, 0, line.top ),
		VIPS_IMAGE_SIZEOF_LINE( layer-&gt;image ) * line.height,
		line.width, line.height, 
		layer-&gt;image-&gt;Bands, layer-&gt;image-&gt;BandFmt )) ) {
		strip_free( strip );
		return;
	}

	/* The strip needs to inherit the layer's metadata.
	 */
	if( vips__image_meta_copy( strip-&gt;image, layer-&gt;image ) ) {
		strip_free( strip );
		return;
	}

	/* Type needs to be set so we know how to convert for save correctly.
	 */
	strip-&gt;image-&gt;Type = layer-&gt;image-&gt;Type;
}

static int
strip_allocate( VipsThreadState *state, void *a, gboolean *stop )
{
	Strip *strip = (Strip *) a;
	Layer *layer = strip-&gt;layer;
	VipsForeignSaveDz *dz = layer-&gt;dz;

	VipsRect image;

#ifdef DEBUG_VERBOSE
	printf( "strip_allocate\n" );
#endif /*DEBUG_VERBOSE*/

	/* We can't test for allocated area empty, since it might just have
	 * bits of the left-hand overlap in and no new pixels. Safest to count
	 * tiles across.
	 */
	if( strip-&gt;x / dz-&gt;tile_step &gt;= layer-&gt;tiles_across ) {
		*stop = TRUE;
#ifdef DEBUG_VERBOSE
		printf( "strip_allocate: done\n" );
#endif /*DEBUG_VERBOSE*/

		return( 0 );
	}

	image.left = 0;
	image.top = 0;
	image.width = layer-&gt;width;
	image.height = layer-&gt;height;

	/* Position this tile.
	 */
	state-&gt;pos.left = strip-&gt;x;
	state-&gt;pos.top = layer-&gt;y;
	state-&gt;pos.width = dz-&gt;tile_size;
	state-&gt;pos.height = dz-&gt;tile_size;
	vips_rect_marginadjust( &amp;state-&gt;pos, dz-&gt;tile_margin );

	vips_rect_intersectrect( &amp;image, &amp;state-&gt;pos, &amp;state-&gt;pos );
	state-&gt;x = strip-&gt;x;
	state-&gt;y = layer-&gt;y;

	strip-&gt;x += dz-&gt;tile_step;

	return( 0 );
}

/* Make an output object for a tile in the current layout.
 */
static GsfOutput *
tile_name( Layer *layer, int x, int y )
{
	VipsForeignSaveDz *dz = layer-&gt;dz;
	VipsForeignSave *save = (VipsForeignSave *) dz;

	GsfOutput *out; 
	char name[VIPS_PATH_MAX];
	char dirname[VIPS_PATH_MAX];
	char dirname2[VIPS_PATH_MAX];
	Layer *p;
	int n;

	switch( dz-&gt;layout ) {
	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
		vips_snprintf( name, VIPS_PATH_MAX, 
			"%d_%d%s", x, y, dz-&gt;file_suffix );

		out = vips_gsf_path( dz-&gt;tree, name, 
			dz-&gt;root_name, dirname, NULL );

		break;

	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
		/* We need to work out the tile number so we can calculate the
		 * directory to put this tile in.
		 *
		 * Tiles are numbered from 0 for the most-zoomed-out tile. 
		 */
		n = 0;

		/* Count all tiles in layers below this one. 
		 */
		for( p = layer-&gt;below; p; p = p-&gt;below )
			n += p-&gt;tiles_across * p-&gt;tiles_down;

		/* And count tiles so far in this layer.
		 */
		n += y * layer-&gt;tiles_across + x;

		vips_snprintf( dirname, VIPS_PATH_MAX, "TileGroup%d", n / 256 );
		vips_snprintf( name, VIPS_PATH_MAX, 
			"%d-%d-%d%s", layer-&gt;n, x, y, dz-&gt;file_suffix );

		/* Used at the end in ImageProperties.xml
		 */
		dz-&gt;tile_count += 1;

		out = vips_gsf_path( dz-&gt;tree, name, dirname, NULL );

		break;

	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d", y );
		vips_snprintf( name, VIPS_PATH_MAX, 
			"%d%s", x, dz-&gt;file_suffix );

		out = vips_gsf_path( dz-&gt;tree, name, dirname, dirname2, NULL );

		break;

	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
{
		/* Tiles are addressed in full resolution coordinates, so
		 * scale up by layer-&gt;sub and dz-&gt;tile_size
		 *
		 * We always clip against the full-sized image, not the scaled
		 * up layer.
		 */
		int left = x * dz-&gt;tile_size * layer-&gt;sub;
		int top = y * dz-&gt;tile_size * layer-&gt;sub;
		int width = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
			save-&gt;ready-&gt;Xsize - left );
		int height = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
			save-&gt;ready-&gt;Ysize - top );

		/* IIIF "size" is just real tile width, I think.
		 *
		 * TODO .. .is this right? shouldn't it be the smaller of
		 * width and height?
		 */
		int size = VIPS_MIN( dz-&gt;tile_size, 
			layer-&gt;width - x * dz-&gt;tile_size );

		vips_snprintf( dirname, VIPS_PATH_MAX, "%d,%d,%d,%d",
			left, top, width, height );
		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d,", size );
		vips_snprintf( name, VIPS_PATH_MAX, "default%s", 
			dz-&gt;file_suffix );

		/* "0" is rotation and is always 0.
		 */
		out = vips_gsf_path( dz-&gt;tree, 
			name, dirname, dirname2, "0", NULL );
}

		break;

	default:
		g_assert_not_reached();

		/* Stop compiler warnings.
		 */
		out = NULL;
	}

#ifdef DEBUG_VERBOSE
	printf( "tile_name: writing to %s\n", name );
#endif /*DEBUG_VERBOSE*/

	return( out );
}

/* Test for tile nearly equal to background colour. In google maps mode, we 
 * skip blank background tiles. 
 *
 * Don't use exactly equality since compression artefacts or noise can upset
 * this.
 */
static gboolean
tile_equal( VipsImage *image, int threshold, VipsPel * restrict ink )
{
	const int bytes = VIPS_IMAGE_SIZEOF_PEL( image );

	VipsRect rect;
	VipsRegion *region;
	int x, y, b;

	region = vips_region_new( image ); 

	/* We know @image is part of a memory buffer, so this will be quick.
	 */
	rect.left = 0;
	rect.top = 0;
	rect.width = image-&gt;Xsize;
	rect.height = image-&gt;Ysize;
	if( vips_region_prepare( region, &amp;rect ) ) {
		g_object_unref( region );
		return( FALSE ); 
	}

	for( y = 0; y &lt; image-&gt;Ysize; y++ ) {
		VipsPel * restrict p = VIPS_REGION_ADDR( region, 0, y ); 

		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
			for( b = 0; b &lt; bytes; b++ ) 
				if( VIPS_ABS( p[b] - ink[b] ) &gt; threshold ) {
					g_object_unref( region );
					return( FALSE ); 
				}

			p += bytes;
		}
	}

	g_object_unref( region );

	return( TRUE );
}

static int
strip_work( VipsThreadState *state, void *a )
{
	Strip *strip = (Strip *) a;
	Layer *layer = strip-&gt;layer;
	VipsForeignSaveDz *dz = layer-&gt;dz;
	VipsForeignSave *save = (VipsForeignSave *) dz;

	VipsImage *x;
	VipsImage *t;
	GsfOutput *out; 

#ifdef DEBUG_VERBOSE
	printf( "strip_work\n" );
#endif /*DEBUG_VERBOSE*/

	/* If we are centering we may be outside the real pixels. Skip in 
	 * this case, and the viewer will display blank.png for us. 
	 */
	if( dz-&gt;centre ) {
		VipsRect tile; 

		tile.left = state-&gt;x;
		tile.top = state-&gt;y;
		tile.width = dz-&gt;tile_size;
		tile.height = dz-&gt;tile_size;
		if( !vips_rect_overlapsrect( &amp;tile, &amp;layer-&gt;real_pixels ) ) {
#ifdef DEBUG_VERBOSE
			printf( "strip_work: skipping tile %d x %d\n", 
				state-&gt;x / dz-&gt;tile_size, 
				state-&gt;y / dz-&gt;tile_size ); 
#endif /*DEBUG_VERBOSE*/

			return( 0 ); 
		}
	}

	g_assert( vips_object_sanity( VIPS_OBJECT( strip-&gt;image ) ) );

	/* Extract relative to the strip top-left corner.
	 */
	if( vips_extract_area( strip-&gt;image, &amp;x, 
		state-&gt;pos.left, 0, 
		state-&gt;pos.width, state-&gt;pos.height, NULL ) ) 
		return( -1 );

	if( dz-&gt;skip_blanks &gt;= 0 &amp;&amp;
		tile_equal( x, dz-&gt;skip_blanks, dz-&gt;ink ) ) { 
		g_object_unref( x );

#ifdef DEBUG_VERBOSE
		printf( "strip_work: skipping blank tile %d x %d\n", 
			state-&gt;x / dz-&gt;tile_size, 
			state-&gt;y / dz-&gt;tile_size ); 
#endif /*DEBUG_VERBOSE*/

		return( 0 ); 
	}

	/* Google tiles need to be padded up to tilesize.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
		if( vips_embed( x, &amp;t, 0, 0, dz-&gt;tile_size, dz-&gt;tile_size,
			"background", save-&gt;background,
			NULL ) ) {
			g_object_unref( x );
			return( -1 );
		}
		g_object_unref( x );

		x = t;
	}

	/* we need to single-thread around calls to gsf.
	 */
	g_mutex_lock( vips__global_lock );

	out = tile_name( layer, 
		state-&gt;x / dz-&gt;tile_step, state-&gt;y / dz-&gt;tile_step );

	g_mutex_unlock( vips__global_lock );

	if( write_image( dz, out, x, dz-&gt;suffix ) ) {
		g_object_unref( out );
		g_object_unref( x );

		return( -1 );
	}

	g_object_unref( out );
	g_object_unref( x );

#ifdef DEBUG_VERBOSE
	printf( "strip_work: success\n" );
#endif /*DEBUG_VERBOSE*/

	return( 0 );
}

/* Write a line of tiles with a threadpool. 
 */
static int
strip_save( Layer *layer )
{
	Strip strip;

#ifdef DEBUG
	printf( "strip_save: n = %d, y = %d\n", layer-&gt;n, layer-&gt;y );
#endif /*DEBUG*/

	strip_init( &amp;strip, layer );
	if( vips_threadpool_run( strip.image, 
		vips_thread_state_new, strip_allocate, strip_work, NULL, 
		&amp;strip ) ) {
		strip_free( &amp;strip );
		return( -1 );
	}
	strip_free( &amp;strip );

#ifdef DEBUG
	printf( "strip_save: success\n" ); 
#endif /*DEBUG*/

	return( 0 );
}

/* A strip has filled, but the rightmost column and the bottom-most row may
 * not have been if we've rounded the size up.
 *
 * Fill them, if necessary, by copying the previous row/column.
 */
static void
layer_generate_extras( Layer *layer )
{
	VipsRegion *strip = layer-&gt;strip;

	/* We only work for full-width strips.
	 */
	g_assert( strip-&gt;valid.width == layer-&gt;image-&gt;Xsize );

	if( layer-&gt;width &lt; layer-&gt;image-&gt;Xsize ) {
		int ps = VIPS_IMAGE_SIZEOF_PEL( strip-&gt;im );

		int b, y;

		/* Need to add a right-most column.
		 */
		for( y = 0; y &lt; strip-&gt;valid.height; y++ ) {
			VipsPel *p = VIPS_REGION_ADDR( strip, 
				layer-&gt;width - 1, strip-&gt;valid.top + y );
			VipsPel *q = p + ps;

			for( b = 0; b &lt; ps; b++ )
				q[b] = p[b];
		}
	}

	if( layer-&gt;height &lt; layer-&gt;image-&gt;Ysize ) {
		VipsRect last;

		/* The last two lines of the image.
		 */
		last.left = 0;
		last.top = layer-&gt;image-&gt;Ysize - 2;
		last.width = layer-&gt;image-&gt;Xsize;
		last.height = 2;
	
		/* Do we have them both? Fill the last with the next-to-last.
		 */
		vips_rect_intersectrect( &amp;last, &amp;strip-&gt;valid, &amp;last );
		if( last.height == 2 ) {
			last.height = 1;

			vips_region_copy( strip, strip, &amp;last, 
				0, last.top + 1 );
		}
	}
}

static int strip_arrived( Layer *layer );

/* Shrink what pixels we can from this strip into the layer below. If the
 * strip below fills, recurse.
 */
static int
strip_shrink( Layer *layer )
<a name="0"></a>{
	Layer *below = layer-&gt;below;
	VipsRegion *from = layer-&gt;strip;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	VipsRegion *to = below-&gt;strip;
	VipsForeignSaveDz *dz = layer-&gt;dz;
	VipsRegionShrink region_shrink = dz-&gt;region_shrink;

	VipsRect target;
	VipsRect source;

#ifdef DEBUG
	printf( "strip_shrink: %d lines in layer %d to layer %d\n", 
		from-&gt;valid.height, layer-&gt;n, below-&gt;n ); 
#endif /*DEBUG*/

	/* We may have an extra column of pixels on the right or
	 * bottom that need filling: generate them.
	 */
	layer_generate_extras( layer );

	/* Our pixels might cross a strip boundary in the layer below, so we
	 * have to write repeatedly until we run out of pixels.
	 */
	for(;;) {
		/* The pixels the layer below needs.
		 */
		target.left = 0;
		target.top = below-&gt;write_y;
		target.width = below-&gt;image-&gt;Xsize;
		target.height = to-&gt;valid.height;
		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );

		/* Those pixels need this area of this layer. 
		 */
		source.left = target.left * 2;
		source.top = target.top * 2;
		source.width = target.width * 2;
		source.height = target.height * 2;

		/* Of which we have these available.
		 */
		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );

		/* So these are the pixels in the layer below we can provide.
		 */
		target.left = source.left / 2;
		target.top = source.top / 2;
		target.width = source.width / 2;
		target.height = source.height / 2;

		/* None? All done.
		 */
		if( vips_rect_isempty( &amp;target ) )
			break;

		(void) vips_region_shrink_method( from, to, 
			&amp;target, region_shrink );

		below-&gt;write_y += target.height;

		/* If we've filled the strip below, let it know.
		 * We can either fill the region, if it's somewhere half-way
		 * down the image, or, if it's at the bottom, get to the last
		 * real line of pixels.
		 */
		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
			below-&gt;write_y == below-&gt;height ) {
			if( strip_arrived( below ) )
				return( -1 );
		}
	}

	return( 0 );
}

/* A new strip has arrived! The strip has enough pixels in to write a line of 
 * tiles. 
 *
 * - write a line of tiles
 * - shrink what we can to the layer below
 * - move our strip down by the tile step
 * - copy the overlap with the previous strip
 */
static int
strip_arrived( Layer *layer )
{
	VipsForeignSaveDz *dz = layer-&gt;dz;</b></font>

	VipsRect new_strip;
	VipsRect overlap;
	VipsRect image_area;

#ifdef DEBUG
	printf( "strip_arrived: layer %d, strip at %d, height %d\n", 
<a name="2"></a>		layer-&gt;n, layer-&gt;y, layer-&gt;strip-&gt;valid.height ); 
#endif /*DEBUG*/

<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( strip_save( layer ) )
		return( -1 );

	if( layer-&gt;below &amp;&amp;
		strip_shrink( layer ) )
		return( -1 );

	/* Position our strip down the image.  
	 *
	 * Expand the strip if necessary to make sure we have an even 
	 * number of lines. 
	 */
	layer-&gt;y += dz-&gt;tile_step;
	new_strip.left = 0;
	new_strip.top = layer-&gt;y - dz-&gt;tile_margin;
	new_strip.width = layer-&gt;image-&gt;Xsize;
	new_strip.height = dz-&gt;tile_size + 2 * dz-&gt;tile_margin;

	image_area.left = 0;
	image_area.top = 0;
	image_area.width = layer-&gt;image-&gt;Xsize;
	image_area.height = layer-&gt;image-&gt;Ysize;
	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 

	if( (new_strip.height &amp; 1) == 1 )
		new_strip.height += 1;

	/* We may exactly hit the bottom of the real image (ie. before borders
	 * have been possibly expanded by 1 pixel). In this case, we'll not 
	 * be able to do the expansion in layer_generate_extras(), since the 
	 * region won't be large enough, and we'll not get another chance 
	 * since this is the bottom. 
	 *
	 * Add another scanline if this has happened.
	 */
	if( VIPS_RECT_BOTTOM( &amp;new_strip ) == layer-&gt;height )</b></font>
		new_strip.height = layer-&gt;image-&gt;Ysize - new_strip.top;

	/* What pixels that we will need do we already have? Save them in 
	 * overlap.
	 */
	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
	if( !vips_rect_isempty( &amp;overlap ) ) {
		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
			return( -1 );
		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
			&amp;overlap, overlap.left, overlap.top );
	}

	if( !vips_rect_isempty( &amp;new_strip ) ) {
		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) )
			return( -1 );

		/* And copy back again.
		 */
		if( !vips_rect_isempty( &amp;overlap ) ) 
			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
				&amp;overlap, overlap.left, overlap.top );
	}

	return( 0 );
}

/* The image has been completely written. Flush any strips which might have
 * overlaps in.
 */
static int
strip_flush( Layer *layer )
{
	if( layer-&gt;y &lt; layer-&gt;height )
		if( strip_save( layer ) )
			return( -1 );

	if( layer-&gt;below )
<a name="1"></a>		if( strip_flush( layer-&gt;below ) )
			return( -1 );

<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
}

/* Another strip of image pixels from vips_sink_disc(). Write into the top
 * pyramid layer. 
 */
static int
pyramid_strip( VipsRegion *region, VipsRect *area, void *a )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
	Layer *layer = dz-&gt;layer;

#ifdef DEBUG
	printf( "pyramid_strip: strip at %d, height %d\n", 
		area-&gt;top, area-&gt;height );
#endif /*DEBUG*/

	for(;;) {
		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
		VipsRect target;

		/* The bit of strip that needs filling.
		 */
		target.left = 0;
		target.top = layer-&gt;write_y;
		target.width = layer-&gt;image-&gt;Xsize;
		target.height = to-&gt;height;
		vips_rect_intersectrect( &amp;target, to, &amp;target );

		/* Clip against what we have available.
		 */
		vips_rect_intersectrect( &amp;target, area, &amp;target );

		/* Have we written all the pixels we were given? We are done. 
		 */
		if( vips_rect_isempty( &amp;target ) ) 
			break;

		/* And copy those pixels in.
		 *
		 * FIXME: If the strip fits inside the region we've just 
		 * received, we could skip the copy. Will this happen very
		 * often? Unclear.
		 */
		vips_region_copy( region, layer-&gt;strip, 
			&amp;target, target.left, target.top );

		layer-&gt;write_y += target.height;

		/* We can either fill the strip, if it's somewhere half-way
		 * down the image, or, if it's at the bottom, get to the last
		 * real line of pixels.
		 */
		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
			layer-&gt;write_y == layer-&gt;height ) {
			if( strip_arrived( layer ) ) 
				return( -1 );
		}
	}</b></font>

	/* If we've reached the bottom of the image, we won't get called again.
	 *
	 * However, there may be some unwritten pixels in the pyramid still!
	 * Suppose a layer is exactly a multiple of tile_step in height.
	 * When we finished that last strip, we will have copied the last few
	 * lines of overlap over into the top of the next row. Deepzoom says we
	 * must flush these half-written strips to the output.
	 */
	if( layer-&gt;write_y == layer-&gt;height ) {
#ifdef DEBUG
		printf( "pyramid_strip: flushing ..\n" ); 
#endif /*DEBUG*/

		if( strip_flush( layer ) )
			return( -1 );
	}

	return( 0 );
}

static int
vips_foreign_save_dz_build( VipsObject *object )
{
	VipsForeignSave *save = (VipsForeignSave *) object;
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz ); 
	VipsRect real_pixels; 

	/* Google, zoomify and iiif default to zero overlap, ".jpg".
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ||
		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
		if( !vips_object_argument_isset( object, "overlap" ) )
			dz-&gt;overlap = 0;
		if( !vips_object_argument_isset( object, "suffix" ) )
			VIPS_SETSTR( dz-&gt;suffix, ".jpg" );
	}

	/* Google and zoomify default to 256 pixel tiles.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
		if( !vips_object_argument_isset( object, "tile_size" ) )
			dz-&gt;tile_size = 256;
	}

	/* Some iif writers default to 256, some to 512. We pick 512.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
		if( !vips_object_argument_isset( object, "tile_size" ) )
			dz-&gt;tile_size = 512;
	}

	/* skip_blanks defaults to 5 in google mode.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
		!vips_object_argument_isset( object, "skip_blanks" ) )
		dz-&gt;skip_blanks = 5;

	/* Our tile layout.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) { 
		dz-&gt;tile_margin = dz-&gt;overlap;
		dz-&gt;tile_step = dz-&gt;tile_size; 
	}
	else {
		dz-&gt;tile_margin = 0;
		dz-&gt;tile_step = dz-&gt;tile_size - dz-&gt;overlap;
	}

	if( dz-&gt;tile_step &lt;= 0 ) {
		vips_error( "dzsave", "%s", _( "overlap too large" ) );
		return( -1 );
	}

	/* Default to white background. vips_foreign_save_init() defaults to
	 * black. 
	 */
	if( !vips_object_argument_isset( object, "background" ) ) {
		VipsArrayDouble *background; 

		/* Using g_object_set() to set an input param in build will
		 * change the hash and confuse caching, but we don't cache
		 * savers, so it's fine.
		 */
		background = vips_array_double_newv( 1, 255.0 );
		g_object_set( object, "background", background, NULL );
		vips_area_unref( VIPS_AREA( background ) ); 
	}

	/* DeepZoom stops at 1x1 pixels, others when the image fits within a
	 * tile.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
		if( !vips_object_argument_isset( object, "depth" ) )
			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL;
	}
	else
		if( !vips_object_argument_isset( object, "depth" ) )
			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONETILE;

	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
		build( object ) )
		return( -1 );

	/* Optional rotate.
	 */
{
	VipsImage *z;

	if( vips_rot( save-&gt;ready, &amp;z, dz-&gt;angle, NULL ) )
		return( -1 );

	VIPS_UNREF( save-&gt;ready );
	save-&gt;ready = z;
}

	/* We use ink to check for blank tiles.
	 */
	if( dz-&gt;skip_blanks &gt;= 0 ) {
		if( !(dz-&gt;ink = vips__vector_to_ink( 
			class-&gt;nickname, save-&gt;ready,
			VIPS_AREA( save-&gt;background )-&gt;data, NULL, 
			VIPS_AREA( save-&gt;background )-&gt;n )) )
			return( -1 );
	}

	/* The real pixels we have from our input. This is about to get
	 * expanded with background. 
	 */
	real_pixels.left = 0;
	real_pixels.top = 0;
	real_pixels.width = save-&gt;ready-&gt;Xsize;
	real_pixels.height = save-&gt;ready-&gt;Ysize;

	/* For centred images, imagine shrinking so that the image fits in a
	 * single tile, centering in that tile, then expanding back again.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
		dz-&gt;centre ) {
		VipsImage *z;
		Layer *layer;
		int n_layers;
		int size;

		if( !(layer = pyramid_build( dz, NULL, 
			save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize,
			&amp;real_pixels )) )
			return( -1 );
		n_layers = layer-&gt;n;
		/* This would cause interesting problems.
		 */
		g_assert( n_layers &lt; 30 );
		layer_free( layer );
		size = dz-&gt;tile_size * (1 &lt;&lt; n_layers);

		real_pixels.left = (size - save-&gt;ready-&gt;Xsize) / 2;
		real_pixels.top = (size - save-&gt;ready-&gt;Ysize) / 2;

		if( vips_embed( save-&gt;ready, &amp;z, 
			real_pixels.left, real_pixels.top,
			size, size,
			"background", save-&gt;background,
			NULL ) ) 
			return( -1 );

		VIPS_UNREF( save-&gt;ready );
		save-&gt;ready = z;

#ifdef DEBUG
		printf( "centre: centring within a %d x %d image\n", 
			size, size );
#endif /*DEBUG*/

	}

#ifdef DEBUG
	printf( "vips_foreign_save_dz_build: tile_size == %d\n", 
		dz-&gt;tile_size );
	printf( "vips_foreign_save_dz_build: overlap == %d\n", 
		dz-&gt;overlap );
	printf( "vips_foreign_save_dz_build: tile_margin == %d\n", 
		dz-&gt;tile_margin );
	printf( "vips_foreign_save_dz_build: tile_step == %d\n", 
		dz-&gt;tile_step );
#endif /*DEBUG*/

	/* Build the skeleton of the image pyramid.
	 */
	if( !(dz-&gt;layer = pyramid_build( dz, NULL, 
		save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize, &amp;real_pixels )) )
		return( -1 );

	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
		dz-&gt;root_name = g_strdup_printf( "%s_files", dz-&gt;basename );
	else
		dz-&gt;root_name = g_strdup( dz-&gt;basename );

	/* Drop any options from @suffix.
	 */
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];

	vips__filename_split8( dz-&gt;suffix, filename, option_string );
	dz-&gt;file_suffix = g_strdup( filename ); 
}

	/* If we will be renaming our temp dir to an existing directory or
	 * file, stop now. See vips_rename() use below.
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS &amp;&amp;
		dz-&gt;dirname &amp;&amp;
		vips_existsf( "%s/%s_files", dz-&gt;dirname, dz-&gt;basename ) ) {
		vips_error( "dzsave", 
			_( "output directory %s/%s_files exists" ),
			dz-&gt;dirname, dz-&gt;basename );
		return( -1 ); 
	}

	/* Make the thing we write the tiles into.
	 */
	switch( dz-&gt;container ) {
	case VIPS_FOREIGN_DZ_CONTAINER_FS:
		if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
			/* For deepzoom, we have to rearrange the output
			 * directory after writing it, see the end of this
			 * function. We write to a temporary directory, then
			 * pull ${basename}_files and ${basename}.dzi out into
			 * the current directory and remove the temp. The temp
			 * dir must not clash with another file.
			 */
			char name[VIPS_PATH_MAX];
			int fd;
			GsfOutput *out;
			GError *error = NULL;

			vips_snprintf( name, VIPS_PATH_MAX, "%s-XXXXXX", 
				dz-&gt;basename ); 
			dz-&gt;tempdir = g_build_filename( dz-&gt;dirname, 
				name, NULL );
			if( (fd = g_mkstemp( dz-&gt;tempdir )) == -1 ) {
				vips_error(  class-&gt;nickname,
					_( "unable to make temporary file %s" ),
					dz-&gt;tempdir );
				return( -1 );
			}
			close( fd );
			g_unlink( dz-&gt;tempdir );

			if( !(out = (GsfOutput *) 
				gsf_outfile_stdio_new( dz-&gt;tempdir, 
					&amp;error )) ) {
				vips_g_error( &amp;error );
				return( -1 );
			}
		
			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
		}
		else { 
			GsfOutput *out;
			GError *error = NULL;
			char name[VIPS_PATH_MAX];

			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s", 
				dz-&gt;dirname, dz-&gt;basename ); 
			if( !(out = (GsfOutput *) 
				gsf_outfile_stdio_new( name, &amp;error )) ) {
				vips_g_error( &amp;error );
				return( -1 );
			}
		
			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
		}
		break;

	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
{
		GsfOutput *zip;
		GsfOutput *out2;
		GError *error = NULL;
		char name[VIPS_PATH_MAX];

		/* Output to a file or memory?
		 */
		if( dz-&gt;dirname ) { 
			const char *suffix =
				dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI ?
					"szi" : "zip";

			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s.%s",
				dz-&gt;dirname, dz-&gt;basename, suffix );
			if( !(dz-&gt;out =
				gsf_output_stdio_new( name, &amp;error )) ) {
				vips_g_error( &amp;error );
				return( -1 );
			}
		}
		else
			dz-&gt;out = gsf_output_memory_new();

		if( !(zip = (GsfOutput *) 
			gsf_outfile_zip_new( dz-&gt;out, &amp;error )) ) {
			vips_g_error( &amp;error );
			return( -1 );
		}

		/* Make the base directory inside the zip. All stuff goes into
		 * this. 
		 */
		out2 = gsf_outfile_new_child_full( (GsfOutfile *) zip, 
			dz-&gt;basename, TRUE,
			"compression-level", GSF_ZIP_STORED, 
			NULL );

#ifndef HAVE_GSF_DEFLATE_LEVEL
		if( dz-&gt;compression &gt; 0 ) {
			g_warning( "%s", 
				_( "deflate-level not supported by libgsf, "
				"using default compression" ) ); 
			dz-&gt;compression = -1;
		}
#endif /*HAVE_GSF_DEFLATE_LEVEL*/

		dz-&gt;tree = vips_gsf_tree_new( out2, dz-&gt;compression );

		/* Note the thing that will need closing up on exit.
		 */
		dz-&gt;tree-&gt;container = zip; 
}
		break;

	default:
		g_assert_not_reached();
	}

	if( vips_sink_disc( save-&gt;ready, pyramid_strip, dz ) )
		return( -1 );

	switch( dz-&gt;layout ) {
	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
		if( write_dzi( dz ) )
			return( -1 );
		break;

	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
		if( write_properties( dz ) )
			return( -1 );
		break;

	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
		if( write_blank( dz ) )
			return( -1 );
		break;

	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
		if( write_json( dz ) )
			return( -1 );
		break;

	default:
		g_assert_not_reached();
	}

	if( dz-&gt;properties &amp;&amp;
		write_vips_meta( dz ) )
		return( -1 );

	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
		write_scan_properties( dz ) )
		return( -1 );

	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
		write_associated( dz ) )
		return( -1 );

	/* This is so ugly. In earlier versions of dzsave, we wrote x.dzi and
	 * x_files. Now we write x/x.dzi and x/x_files to make it possible to
	 * create zip files. 
	 *
	 * For compatibility, rearrange the directory tree.
	 *
	 * FIXME have a flag to stop this stupidity
	 */
	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS ) { 
		char old_name[VIPS_PATH_MAX];
		char new_name[VIPS_PATH_MAX];

		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s.dzi", 
			dz-&gt;tempdir, dz-&gt;basename );
		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s.dzi", 
			dz-&gt;dirname, dz-&gt;basename );
		if( vips_rename( old_name, new_name ) )
			return( -1 ); 

		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s_files", 
			dz-&gt;tempdir, dz-&gt;basename );
		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s_files", 
			dz-&gt;dirname, dz-&gt;basename );
		if( vips_rename( old_name, new_name ) )
			return( -1 ); 

		if( vips_rmdirf( "%s", dz-&gt;tempdir ) )
			return( -1 ); 
	}

	/* Shut down the output to flush everything.
	 */
	if( vips_gsf_tree_close( dz-&gt;tree ) )
		return( -1 ); 
	dz-&gt;tree = NULL; 

	/* If we are writing a zip to the filesystem, we must unref out to
	 * force it to disc.
	 */
	if( iszip( dz-&gt;container ) &amp;&amp;
		dz-&gt;dirname != NULL ) 
		VIPS_FREEF( g_object_unref, dz-&gt;out );

	return( 0 );
}

/* Save a bit of typing.
 */
#define UC VIPS_FORMAT_UCHAR
#define C VIPS_FORMAT_CHAR
#define US VIPS_FORMAT_USHORT
#define S VIPS_FORMAT_SHORT
#define UI VIPS_FORMAT_UINT
#define I VIPS_FORMAT_INT
#define F VIPS_FORMAT_FLOAT
#define X VIPS_FORMAT_COMPLEX
#define D VIPS_FORMAT_DOUBLE
#define DX VIPS_FORMAT_DPCOMPLEX

static int bandfmt_dz[10] = {
/* UC  C   US  S   UI  I   F   X   D   DX */
   UC, C,  US, S,  UI, I,  F,  F,  D,  D
};

static const char *dz_suffs[] = { ".dz", NULL };

static void
vips_foreign_save_dz_class_init( VipsForeignSaveDzClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;

	gobject_class-&gt;dispose = vips_foreign_save_dz_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "dzsave_base";
	object_class-&gt;description = _( "save image to deep zoom format" );
	object_class-&gt;build = vips_foreign_save_dz_build;

	foreign_class-&gt;suffs = dz_suffs;

	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
	save_class-&gt;format_table = bandfmt_dz;
	save_class-&gt;coding[VIPS_CODING_LABQ] = TRUE;

	VIPS_ARG_STRING( class, "basename", 2, 
		_( "Base name" ),
		_( "Base name to save to" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, basename ),
		NULL );

	VIPS_ARG_ENUM( class, "layout", 8, 
		_( "Layout" ), 
		_( "Directory layout" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, layout ),
		VIPS_TYPE_FOREIGN_DZ_LAYOUT, VIPS_FOREIGN_DZ_LAYOUT_DZ ); 

	VIPS_ARG_STRING( class, "suffix", 9, 
		_( "suffix" ), 
		_( "Filename suffix for tiles" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, suffix ),
		".jpeg" );

	VIPS_ARG_INT( class, "overlap", 10, 
		_( "Overlap" ), 
		_( "Tile overlap in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, overlap ),
		0, 8192, 1 );

	VIPS_ARG_INT( class, "tile_size", 11, 
		_( "Tile size" ), 
		_( "Tile size in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
		1, 8192, 254 );

	VIPS_ARG_ENUM( class, "depth", 13, 
		_( "Depth" ), 
		_( "Pyramid depth" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, depth ),
		VIPS_TYPE_FOREIGN_DZ_DEPTH, VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ); 

	VIPS_ARG_BOOL( class, "centre", 13, 
		_( "Center" ), 
		_( "Center image in tile" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, centre ),
		FALSE );

	VIPS_ARG_ENUM( class, "angle", 14, 
		_( "Angle" ), 
		_( "Rotate image during save" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, angle ),
		VIPS_TYPE_ANGLE, VIPS_ANGLE_D0 ); 

	VIPS_ARG_ENUM( class, "container", 15, 
		_( "Container" ), 
		_( "Pyramid container type" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, container ),
		VIPS_TYPE_FOREIGN_DZ_CONTAINER, VIPS_FOREIGN_DZ_CONTAINER_FS ); 

	VIPS_ARG_BOOL( class, "properties", 16, 
		_( "Properties" ), 
		_( "Write a properties file to the output directory" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, properties ),
		FALSE );

	VIPS_ARG_INT( class, "compression", 17, 
		_( "Compression" ), 
		_( "ZIP deflate compression level" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, compression ),
		-1, 9, 0 );

	VIPS_ARG_ENUM( class, "region_shrink", 18, 
		_( "Region shrink" ), 
		_( "Method to shrink regions" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, region_shrink ),
		VIPS_TYPE_REGION_SHRINK, VIPS_REGION_SHRINK_MEAN ); 

	VIPS_ARG_INT( class, "skip_blanks", 19, 
		_( "Skip blanks" ), 
		_( "Skip tiles which are nearly equal to the background" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, skip_blanks ),
		-1, 65535, -1 );

	VIPS_ARG_BOOL( class, "no_strip", 20, 
		_( "No strip" ), 
		_( "Don't strip tile metadata" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, no_strip ),
		FALSE );

	VIPS_ARG_STRING( class, "id", 21, 
		_( "id" ), 
		_( "Resource ID" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSaveDz, id ),
		"https://example.com/iiif" );

	/* How annoying. We stupidly had these in earlier versions.
	 */

	VIPS_ARG_STRING( class, "dirname", 1, 
		_( "Directory name" ),
		_( "Directory name to save to" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignSaveDz, dirname ),
		NULL );

	VIPS_ARG_INT( class, "tile_width", 12, 
		_( "Tile width" ), 
		_( "Tile width in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
		1, 8192, 254 );

	VIPS_ARG_INT( class, "tile_height", 12, 
		_( "Tile height" ), 
		_( "Tile height in pixels" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
		1, 8192, 254 );

}

static void
vips_foreign_save_dz_init( VipsForeignSaveDz *dz )
{
	VIPS_SETSTR( dz-&gt;suffix, ".jpeg" );
	dz-&gt;layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; 
	dz-&gt;overlap = 1;
	dz-&gt;tile_size = 254;
	dz-&gt;tile_count = 0;
	dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; 
	dz-&gt;angle = VIPS_ANGLE_D0; 
	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_FS; 
	dz-&gt;compression = 0;
	dz-&gt;region_shrink = VIPS_REGION_SHRINK_MEAN;
	dz-&gt;skip_blanks = -1;
}

typedef struct _VipsForeignSaveDzFile {
	VipsForeignSaveDz parent_object;

	/* Filename for save.
	 */
	char *filename; 

} VipsForeignSaveDzFile;

typedef VipsForeignSaveDzClass VipsForeignSaveDzFileClass;

G_DEFINE_TYPE( VipsForeignSaveDzFile, vips_foreign_save_dz_file, 
	vips_foreign_save_dz_get_type() );

static int
vips_foreign_save_dz_file_build( VipsObject *object )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
	VipsForeignSaveDzFile *file = (VipsForeignSaveDzFile *) object;

	char *p;

	/* Use @filename to set the default values for dirname and basename.
	 */
	if( !vips_object_argument_isset( object, "basename" ) ) 
		dz-&gt;basename = g_path_get_basename( file-&gt;filename ); 
	if( !vips_object_argument_isset( object, "dirname" ) ) 
		dz-&gt;dirname = g_path_get_dirname( file-&gt;filename ); 

	/* Remove any [options] from basename.
	 */
	if( (p = (char *) vips__find_rightmost_brackets( dz-&gt;basename )) )
		*p = '\0';

	/* If we're writing thing.zip or thing.szi, default to zip 
	 * container.
	 */
	if( (p = strrchr( dz-&gt;basename, '.' )) ) {
		if( !vips_object_argument_isset( object, "container" ) ) {
			if( strcasecmp( p + 1, "zip" ) == 0 )
				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
			if( strcasecmp( p + 1, "szi" ) == 0 ) 
				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_SZI;
		}

		/* Remove any legal suffix. We don't remove all suffixes
		 * since we might be writing to a dirname with a dot in.
		 */
		if( g_ascii_strcasecmp( p + 1, "zip" ) == 0 ||
			g_ascii_strcasecmp( p + 1, "szi" ) == 0 || 
			g_ascii_strcasecmp( p + 1, "dz" ) == 0 )
			*p = '\0';
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_file_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_save_dz_file_class_init( VipsForeignSaveDzFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "dzsave";
	object_class-&gt;description = _( "save image to deepzoom file" );
	object_class-&gt;build = vips_foreign_save_dz_file_build;

	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to save to" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignSaveDzFile, filename ),
		NULL );
}

static void
vips_foreign_save_dz_file_init( VipsForeignSaveDzFile *file )
{
}

typedef struct _VipsForeignSaveDzBuffer {
	VipsForeignSaveDz parent_object;

	VipsArea *buf;
} VipsForeignSaveDzBuffer;

typedef VipsForeignSaveDzClass VipsForeignSaveDzBufferClass;

G_DEFINE_TYPE( VipsForeignSaveDzBuffer, vips_foreign_save_dz_buffer, 
	vips_foreign_save_dz_get_type() );

static int
vips_foreign_save_dz_buffer_build( VipsObject *object )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;

	void *obuf;
	size_t olen;
	VipsBlob *blob;

	if( !vips_object_argument_isset( object, "basename" ) ) 
		dz-&gt;basename = g_strdup( "untitled" ); 

	/* Leave dirname NULL to indicate memory output.
	 */

	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_buffer_parent_class )-&gt;
		build( object ) )
		return( -1 );

	g_assert( GSF_IS_OUTPUT_MEMORY( dz-&gt;out ) );

	/* Oh dear, we can't steal gsf's memory, and blob can't unref something
	 * or trigger a notify. We have to copy it.
	 *
	 * Don't use tracked, we want something that can be freed with g_free.
	 *
	 * FIXME ... blob (or area?) needs to support notify or unref.
	 */
	olen = gsf_output_size( GSF_OUTPUT( dz-&gt;out ) ); 
	if( !(obuf = g_try_malloc( olen )) ) {
		vips_error( "vips_tracked", 
			_( "out of memory --- size == %dMB" ), 
			(int) (olen / (1024.0 * 1024.0))  );
		return( -1 );
	}
	memcpy( obuf, 
		gsf_output_memory_get_bytes( GSF_OUTPUT_MEMORY( dz-&gt;out ) ),
		olen ); 

	blob = vips_blob_new( (VipsCallbackFn) vips_area_free_cb, obuf, olen );
	g_object_set( object, "buffer", blob, NULL );
	vips_area_unref( VIPS_AREA( blob ) );

	return( 0 );
}

static void
vips_foreign_save_dz_buffer_class_init( VipsForeignSaveDzBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "dzsave_buffer";
	object_class-&gt;description = _( "save image to dz buffer" );
	object_class-&gt;build = vips_foreign_save_dz_buffer_build;

	VIPS_ARG_BOXED( class, "buffer", 1, 
		_( "Buffer" ),
		_( "Buffer to save to" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
		G_STRUCT_OFFSET( VipsForeignSaveDzBuffer, buf ),
		VIPS_TYPE_BLOB );
}

static void
vips_foreign_save_dz_buffer_init( VipsForeignSaveDzBuffer *buffer )
{
	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) buffer;

	/* zip default for memory output.
	 */
	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
}

#endif /*HAVE_GSF*/

/**
 * vips_dzsave: (method)
 * @in: image to save 
 * @name: name to save to 
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @basename: %gchar base part of name
 * * @layout: #VipsForeignDzLayout directory layout convention
 * * @suffix: %gchar suffix for tiles 
 * * @overlap: %gint set tile overlap 
 * * @tile_size: %gint set tile size 
 * * @background: #VipsArrayDouble background colour
 * * @depth: #VipsForeignDzDepth how deep to make the pyramid
 * * @centre: %gboolean centre the tiles 
 * * @angle: #VipsAngle rotate the image by this much
 * * @container: #VipsForeignDzContainer set container type
 * * @properties: %gboolean write a properties file
 * * @compression: %gint zip deflate compression level
 * * @region_shrink: #VipsRegionShrink how to shrink each 2x2 region
 * * @skip_blanks: %gint skip tiles which are nearly equal to the background
 * * @no_strip: %gboolean don't strip tiles
 * * @id: %gchar id for IIIF properties
 *
 * Save an image as a set of tiles at various resolutions. By default dzsave
 * uses DeepZoom layout -- use @layout to pick other conventions.
 *
 * vips_dzsave() creates a directory called @name to hold the tiles. If @name
 * ends `.zip`, vips_dzsave() will create a zip file called @name to hold the
 * tiles. You can use @container to force zip file output. 
 *
 * Use @basename to set the name of the directory tree we are creating. The
 * default value is set from @name. 
 *
 * You can set @suffix to something like `".jpg[Q=85]"` to control the tile 
 * write options. 
 * 
 * In Google layout mode, edge tiles are expanded to @tile_size by @tile_size 
 * pixels. Normally they are filled with white, but you can set another colour
 * with @background. Images are usually placed at the top-left of the tile,
 * but you can have them centred by turning on @centre. 
 *
 * You can set the size and overlap of tiles with @tile_size and @overlap.
 * They default to the correct settings for the selected @layout. The deepzoom
 * defaults produce 256x256 jpeg files for centre tiles, the most efficient
 * size.
 *
 * Use @depth to control how low the pyramid goes. This defaults to the
 * correct setting for the @layout you select.
 *
 * You can rotate the image during write with the @angle argument. However,
 * this will only work for images which support random access, like openslide,
 * and not for things like JPEG. You'll need to rotate those images
 * yourself with vips_rot(). Note that the `autorotate` option to the loader 
 * may do what you need.
 *
 * If @properties is %TRUE, vips_dzsave() will write a file called
 * `vips-properties.xml` to the output directory. This file lists all of the
 * metadata attached to @in in an obvious manner. It can be useful for viewing
 * programs which wish to use fields from source files loaded via
 * vips_openslideload(). 
 *
 * By default, all tiles are stripped, since very few people want a copy of
 * the metadata on every tile. Set @no_strip if you really want to keep 
 * metadata.
 *
 * If @container is set to `zip`, you can set a compression level from -1
 * (use zlib default), 0 (store, compression disabled) to 9 (max compression).
 * If no value is given, the default is to store files without compression.
 *
 * You can use @region_shrink to control the method for shrinking each 2x2
 * region. This defaults to using the average of the 4 input pixels but you can
 * also use the median in cases where you want to preserve the range of values.
 *
 * If you set @skip_blanks to a value greater than or equal to zero, tiles 
 * which are all within that many pixel values to the background are skipped. 
 * This can save a lot of space for some image types. This option defaults to 
 * 5 in Google layout mode, -1 otherwise.
 *
 * In IIIF layout, you can set the base of the `id` property in `info.json` 
 * with @id. The default is `https://example.com/iiif`.
 * 
 * See also: vips_tiffsave().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_dzsave( VipsImage *in, const char *name, ... )
{
	va_list ap;
	int result;

	va_start( ap, name );
	result = vips_call_split( "dzsave", ap, in, name ); 
	va_end( ap );

	return( result );
}

/**
 * vips_dzsave_buffer: (method)
 * @in: image to save 
 * @buf: (array length=len) (element-type guint8): return output buffer here
 * @len: (type gsize): return output length here
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @basename: %gchar base part of name
 * * @layout: #VipsForeignDzLayout directory layout convention
 * * @suffix: %gchar suffix for tiles 
 * * @overlap: %gint set tile overlap 
 * * @tile_size: %gint set tile size 
 * * @background: #VipsArrayDouble background colour
 * * @depth: #VipsForeignDzDepth how deep to make the pyramid
 * * @centre: %gboolean centre the tiles 
 * * @angle: #VipsAngle rotate the image by this much
 * * @container: #VipsForeignDzContainer set container type
 * * @properties: %gboolean write a properties file
 * * @compression: %gint zip deflate compression level
 * * @region_shrink: #VipsRegionShrink how to shrink each 2x2 region.
 * * @skip_blanks: %gint skip tiles which are nearly equal to the background
 * * @no_strip: %gboolean don't strip tiles
 * * @id: %gchar id for IIIF properties
 *
 * As vips_dzsave(), but save to a memory buffer. 
 *
 * Output is always in a zip container. Use @basename to set the name of the
 * directory that the zip will create when unzipped. 
 *
 * The address of the buffer is returned in @buf, the length of the buffer in
 * @len. You are responsible for freeing the buffer with g_free() when you
 * are done with it.
 *
 * See also: vips_dzsave(), vips_image_write_to_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_dzsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
{
	va_list ap;
	VipsArea *area;
	int result;

	area = NULL; 

	va_start( ap, len );
	result = vips_call_split( "dzsave_buffer", ap, in, &amp;area );
	va_end( ap );

	if( !result &amp;&amp;
		area ) { 
		if( buf ) {
			*buf = area-&gt;data;
			area-&gt;free_fn = NULL;
		}
		if( len ) 
			*len = area-&gt;length;

		vips_area_unref( area );
	}

	return( result );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
