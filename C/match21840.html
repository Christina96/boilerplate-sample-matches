<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for vips2tiff.c &amp; dzsave.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for vips2tiff.c &amp; dzsave.c
      </h3>
<h1 align="center">
        5.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>vips2tiff.c (6.364429%)<th>dzsave.c (5.559787%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1709-1782)<td><a href="#" name="0">(1735-1818)</a><td align="center"><font color="#ff0000">33</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1842-1900)<td><a href="#" name="1">(1906-1964)</a><td align="center"><font color="#b90000">24</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1793-1824)<td><a href="#" name="2">(1829-1864)</a><td align="center"><font color="#7b0000">16</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>vips2tiff.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #ifdef HAVE_TIFF
5 #include &lt;stdio.h&gt;
6 #include &lt;stdlib.h&gt;
7 #ifdef HAVE_UNISTD_H
8 #include &lt;unistd.h&gt;
9 #include &lt;string.h&gt;
10 #include &lt;vips/vips.h&gt;
11 #include &lt;vips/internal.h&gt;
12 #include "pforeign.h"
13 #include "tiff.h"
14 #define MAX_ALPHA (64)
15 #define JP2K_LOSSY 33004
16 static int wtiff_we_compress[] = {
17 	JP2K_LOSSY
18 };
19 typedef struct _Layer Layer;
20 typedef struct _Wtiff Wtiff;
21 struct _Layer {
22 	Wtiff *wtiff;			
23 	char *lname;			
24 	void *buf;
25 	size_t len;
26 	int width, height;			int sub;				TIFF *tif;			
27 	VipsImage *image;
28 	int y;
29 	int write_y;
30 	VipsRegion *strip;			VipsRegion *copy;		
31 	Layer *below;				Layer *above;			};
32 struct _Wtiff {
33 	VipsImage *input;		
34 	VipsImage *ready;
35 	char *filename;			
36 	void **obuf;
37 	size_t *olen; 
38 	Layer *layer;				VipsPel *tbuf;				int tls;			
39 	int compression;			int Q;					int predictor;				int tile;				int tilew, tileh;			int pyramid;				int bitdepth;                   	int miniswhite;			        int resunit;                            double xres;                   	        double yres;                   		const char *profile;			int bigtiff;				int rgbjpeg;				int properties;				int strip;				VipsRegionShrink region_shrink; 	int level;				gboolean lossless;			VipsForeignDzDepth depth;		gboolean subifd;			gboolean premultiply;		
40 	gboolean toilet_roll;
41 	int page_height;
42 	int page_number;
43 	int n_pages;
44 	int image_height;
45 	gboolean we_compress;
46 };
47 static int
48 embed_profile_file( TIFF *tif, const char *profile )
49 {
50 	VipsBlob *blob;
51 	if( vips_profile_load( profile, &amp;blob, NULL ) )
52 		return( -1 );
53 	if( blob ) {
54 		size_t length;
55 		const void *data = vips_blob_get( blob, &amp;length );
56 		TIFFSetField( tif, TIFFTAG_ICCPROFILE, length, data );
57 #ifdef DEBUG
58 		printf( "vips2tiff: attached profile \"%s\"\n", profile );
59 		vips_area_unref( (VipsArea *) blob );
60 	}
61 	return( 0 );
62 }
63 static int
64 embed_profile_meta( TIFF *tif, VipsImage *im )
65 {
66 	const void *data;
67 	size_t length;
68 	if( vips_image_get_blob( im, VIPS_META_ICC_NAME, &amp;data, &amp;length ) )
69 		return( -1 );
70 	TIFFSetField( tif, TIFFTAG_ICCPROFILE, length, data );
71 #ifdef DEBUG
72 	printf( "vips2tiff: attached profile from meta\n" );
73 	return( 0 );
74 }
75 static void
76 wtiff_layer_init( Wtiff *wtiff, Layer **layer, Layer *above, 
77 	int width, int height )
78 {
79 	if( !*layer ) {
80 		*layer = VIPS_NEW( wtiff-&gt;ready, Layer );
81 		(*layer)-&gt;wtiff = wtiff;
82 		(*layer)-&gt;width = width;
83 		(*layer)-&gt;height = height; 
84 		if( !above )
85 			(*layer)-&gt;sub = 1;	
86 		else
87 			(*layer)-&gt;sub = above-&gt;sub * 2;
88 		(*layer)-&gt;lname = NULL;
89 		(*layer)-&gt;buf = NULL;
90 		(*layer)-&gt;len = 0;
91 		(*layer)-&gt;tif = NULL;
92 		(*layer)-&gt;image = NULL;
93 		(*layer)-&gt;write_y = 0;
94 		(*layer)-&gt;y = 0;
95 		(*layer)-&gt;strip = NULL;
96 		(*layer)-&gt;copy = NULL;
97 		(*layer)-&gt;below = NULL;
98 		(*layer)-&gt;above = above;
99 		if( wtiff-&gt;filename ) { 
100 			if( !above ) 
101 				(*layer)-&gt;lname = vips_strdup( 
102 					VIPS_OBJECT( wtiff-&gt;ready ),
103 					wtiff-&gt;filename );
104 			else {
105 				char *lname;
106 				lname = vips__temp_name( "%s.tif" );
107 				(*layer)-&gt;lname = vips_strdup( 
108 					VIPS_OBJECT( wtiff-&gt;ready ),
109 					lname );
110 				g_free( lname );
111 			}
112 		}
113 	}
114 	if( wtiff-&gt;pyramid ) {
115 		int limitw, limith;
116 		switch( wtiff-&gt;depth ) {
117 		case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
118 			limitw = limith = 1;
119 			break;
120 		case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
121 			limitw = wtiff-&gt;tilew;
122 			limith = wtiff-&gt;tileh;
123 			break;
124 		case VIPS_FOREIGN_DZ_DEPTH_ONE:
125 			limitw = wtiff-&gt;ready-&gt;Xsize;
126 			limith = wtiff-&gt;ready-&gt;Ysize;
127 			break;
128 		default:
129 			g_assert_not_reached();
130 		}
131 		if( ((*layer)-&gt;width &gt; limitw || 
132 			(*layer)-&gt;height &gt; limith) &amp;&amp; 
133 		 	(*layer)-&gt;width &gt; 1 &amp;&amp; 
134 		 	(*layer)-&gt;height &gt; 1 ) 
135 			wtiff_layer_init( wtiff, &amp;(*layer)-&gt;below, *layer, 
136 				width / 2, height / 2 );
137 	}
138 }
139 static int
140 wtiff_embed_profile( Wtiff *wtiff, TIFF *tif )
141 {
142 	if( wtiff-&gt;profile &amp;&amp;
143 		embed_profile_file( tif, wtiff-&gt;profile ) )
144 		return( -1 );
145 	if( !wtiff-&gt;profile &amp;&amp; 
146 		vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_ICC_NAME ) &amp;&amp;
147 		embed_profile_meta( tif, wtiff-&gt;ready ) )
148 		return( -1 );
149 	return( 0 );
150 }
151 static int
152 wtiff_embed_xmp( Wtiff *wtiff, TIFF *tif )
153 {
154 	const void *data;
155 	size_t size;
156 	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_XMP_NAME ) )
157 		return( 0 );
158 	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_XMP_NAME, 
159 		&amp;data, &amp;size ) )
160 		return( -1 );
161 	TIFFSetField( tif, TIFFTAG_XMLPACKET, size, data );
162 #ifdef DEBUG
163 	printf( "vips2tiff: attached XMP from meta\n" );
164 	return( 0 );
165 }
166 static int
167 wtiff_embed_iptc( Wtiff *wtiff, TIFF *tif )
168 {
169 	const void *data;
170 	size_t size;
171 	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_IPTC_NAME ) )
172 		return( 0 );
173 	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_IPTC_NAME, 
174 		&amp;data, &amp;size ) )
175 		return( -1 );
176 	if( size &amp; 3 ) {
177 		g_warning( "%s", _( "rounding up IPTC data length" ) );
178 		size /= 4;
179 		size += 1;
180 	}
181 	else
182 		size /= 4;
183 	TIFFSetField( tif, TIFFTAG_RICHTIFFIPTC, size, data );
184 #ifdef DEBUG
185 	printf( "vips2tiff: attached IPTC from meta\n" );
186 	return( 0 );
187 }
188 static int
189 wtiff_embed_photoshop( Wtiff *wtiff, TIFF *tif )
190 {
191 	const void *data;
192 	size_t size;
193 	if( !vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_PHOTOSHOP_NAME ) )
194 		return( 0 );
195 	if( vips_image_get_blob( wtiff-&gt;ready, VIPS_META_PHOTOSHOP_NAME, 
196 		&amp;data, &amp;size ) )
197 		return( -1 );
198 	TIFFSetField( tif, TIFFTAG_PHOTOSHOP, size, data );
199 #ifdef DEBUG
200 	printf( "vips2tiff: attached photoshop data from meta\n" );
201 	return( 0 );
202 }
203 static int
204 wtiff_embed_imagedescription( Wtiff *wtiff, TIFF *tif )
205 {
206 	if( wtiff-&gt;properties ) {
207 		char *doc;
208 		if( !(doc = vips__xml_properties( wtiff-&gt;ready )) )
209 			return( -1 );
210 		TIFFSetField( tif, TIFFTAG_IMAGEDESCRIPTION, doc );
211 		g_free( doc );
212 	}
213 	else {
214 		const char *imagedescription;
215 		if( !vips_image_get_typeof( wtiff-&gt;ready,
216 			VIPS_META_IMAGEDESCRIPTION ) )
217 			return( 0 );
218 		if( vips_image_get_string( wtiff-&gt;ready,
219 			VIPS_META_IMAGEDESCRIPTION, &amp;imagedescription ) )
220 			return( -1 );
221 		TIFFSetField( tif, TIFFTAG_IMAGEDESCRIPTION, imagedescription );
222 	}
223 #ifdef DEBUG
224 	printf( "vips2tiff: attached imagedescription from meta\n" );
225 	return( 0 );
226 }
227 static int
228 wtiff_write_header( Wtiff *wtiff, Layer *layer )
229 {
230 	TIFF *tif = layer-&gt;tif;
231 	int i;
232 	int orientation; 
233 #ifdef DEBUG
234 	printf( "wtiff_write_header: sub %d, width %d, height %d\n",
235 		layer-&gt;sub, layer-&gt;width, layer-&gt;height );
236 	TIFFSetField( tif, TIFFTAG_IMAGEWIDTH, layer-&gt;width );
237 	TIFFSetField( tif, TIFFTAG_IMAGELENGTH, layer-&gt;height );
238 	TIFFSetField( tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );
239 	TIFFSetField( tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT );
240 	TIFFSetField( tif, TIFFTAG_COMPRESSION, wtiff-&gt;compression );
241 	if( wtiff-&gt;compression == COMPRESSION_JPEG ) 
242 		TIFFSetField( tif, TIFFTAG_JPEGQUALITY, wtiff-&gt;Q );
243 #ifdef HAVE_TIFF_COMPRESSION_WEBP
244 	if( wtiff-&gt;compression == COMPRESSION_WEBP ) {
245 		TIFFSetField( tif, TIFFTAG_WEBP_LEVEL, wtiff-&gt;Q );
246 		TIFFSetField( tif, TIFFTAG_WEBP_LOSSLESS, wtiff-&gt;lossless );
247 	}
248 	if( wtiff-&gt;compression == COMPRESSION_ZSTD ) {
249 		TIFFSetField( tif, TIFFTAG_ZSTD_LEVEL, wtiff-&gt;level );
250 		if( wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
251 			TIFFSetField( tif, 
252 				TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
253 	}
254 	if( (wtiff-&gt;compression == COMPRESSION_ADOBE_DEFLATE ||
255 		wtiff-&gt;compression == COMPRESSION_LZW) &amp;&amp;
256 		wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
257 		TIFFSetField( tif, TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
258 	for( i = 0; i &lt; VIPS_NUMBER( wtiff_we_compress ); i++ )
259 		if( wtiff-&gt;compression == wtiff_we_compress[i] ) {
260 			wtiff-&gt;we_compress = TRUE;
261 			break;
262 		}
263 	TIFFSetField( tif, TIFFTAG_RESOLUTIONUNIT, wtiff-&gt;resunit );
264 	TIFFSetField( tif, TIFFTAG_XRESOLUTION, 
265 		VIPS_FCLIP( 0.01, wtiff-&gt;xres, 1000000 ) );
266 	TIFFSetField( tif, TIFFTAG_YRESOLUTION, 
267 		VIPS_FCLIP( 0.01, wtiff-&gt;yres, 1000000 ) );
268 	if( !wtiff-&gt;strip ) 
269 		if( wtiff_embed_profile( wtiff, tif ) ||
270 			wtiff_embed_xmp( wtiff, tif ) ||
271 			wtiff_embed_iptc( wtiff, tif ) ||
272 			wtiff_embed_photoshop( wtiff, tif ) ||
273 			wtiff_embed_imagedescription( wtiff, tif ) )
274 			return( -1 ); 
275 	if( vips_image_get_typeof( wtiff-&gt;ready, VIPS_META_ORIENTATION ) &amp;&amp;
276 		!vips_image_get_int( wtiff-&gt;ready, 
277 			VIPS_META_ORIENTATION, &amp;orientation ) )
278 		TIFFSetField( tif, TIFFTAG_ORIENTATION, orientation );
279 	if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ ) {
280 		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 3 );
281 		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, 8 );
282 		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_CIELAB );
283 	}
284 	else if( wtiff-&gt;bitdepth == 1 || wtiff-&gt;bitdepth == 2 ||
285                  wtiff-&gt;bitdepth == 4 ) {
286 		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 1 );
287 		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, wtiff-&gt;bitdepth );
288 		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC,
289 			wtiff-&gt;miniswhite ?
290 				PHOTOMETRIC_MINISWHITE :
291 				PHOTOMETRIC_MINISBLACK );
292 	}
293 	else {
294 		int photometric;
295 		int colour_bands;
296 		int alpha_bands;
297 		TIFFSetField( tif, TIFFTAG_SAMPLESPERPIXEL, 
298 			wtiff-&gt;ready-&gt;Bands );
299 		TIFFSetField( tif, TIFFTAG_BITSPERSAMPLE, 
300 			vips_format_sizeof( wtiff-&gt;ready-&gt;BandFmt ) &lt;&lt; 3 );
301 		if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_B_W ||
302 			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_GREY16 ||
303 			wtiff-&gt;ready-&gt;Bands &lt; 3 ) { 
304 			photometric = wtiff-&gt;miniswhite ?
305 				PHOTOMETRIC_MINISWHITE :
306 				PHOTOMETRIC_MINISBLACK;
307 			colour_bands = 1;
308 		}
309 		else if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LAB || 
310 			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LABS ) {
311 			photometric = PHOTOMETRIC_CIELAB;
312 			colour_bands = 3;
313 		}
314 		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ ) { 
315 			double stonits;
316 			photometric = PHOTOMETRIC_LOGLUV;
317 			TIFFSetField( tif, 
318 				TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT );
319 			stonits = 1.0;
320 			if( vips_image_get_typeof( wtiff-&gt;ready, "stonits" ) )
321 				vips_image_get_double( wtiff-&gt;ready, 
322 					"stonits", &amp;stonits );
323 			TIFFSetField( tif, TIFFTAG_STONITS, stonits );
324 			colour_bands = 3;
325 		}
326 		else if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_CMYK &amp;&amp;
327 			wtiff-&gt;ready-&gt;Bands &gt;= 4 ) {
328 			photometric = PHOTOMETRIC_SEPARATED;
329 			TIFFSetField( tif, TIFFTAG_INKSET, INKSET_CMYK );
330 			colour_bands = 4;
331 		}
332 		else if( wtiff-&gt;compression == COMPRESSION_JPEG &amp;&amp;
333 			wtiff-&gt;ready-&gt;Bands == 3 &amp;&amp;
334 			wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR &amp;&amp;
335 			(!wtiff-&gt;rgbjpeg &amp;&amp; wtiff-&gt;Q &lt; 90) ) { 
336 			photometric = PHOTOMETRIC_YCBCR;
337 			TIFFSetField( tif, TIFFTAG_JPEGCOLORMODE, 
338 				JPEGCOLORMODE_RGB );
339 			colour_bands = 3;
340 		}
341 		else {
342 			photometric = PHOTOMETRIC_RGB;
343 			colour_bands = 3;
344 		}
345 		alpha_bands = VIPS_CLIP( 0, 
346 			wtiff-&gt;ready-&gt;Bands - colour_bands, MAX_ALPHA );
347 		if( alpha_bands &gt; 0 ) { 
348 			uint16 v[MAX_ALPHA];
349 			int i;
350 			for( i = 0; i &lt; alpha_bands; i++ )
351 				v[i] = i == 0 &amp;&amp; wtiff-&gt;premultiply ? 
352 					EXTRASAMPLE_ASSOCALPHA :
353 					EXTRASAMPLE_UNASSALPHA;
354 			TIFFSetField( tif, 
355 				TIFFTAG_EXTRASAMPLES, alpha_bands, v );
356 		}
357 		TIFFSetField( tif, TIFFTAG_PHOTOMETRIC, photometric );
358 	}
359 	if( wtiff-&gt;tile ) {
360 		TIFFSetField( tif, TIFFTAG_TILEWIDTH, wtiff-&gt;tilew );
361 		TIFFSetField( tif, TIFFTAG_TILELENGTH, wtiff-&gt;tileh );
362 	}
363 	else
364 		TIFFSetField( tif, TIFFTAG_ROWSPERSTRIP, wtiff-&gt;tileh );
365 	if( layer-&gt;above ) 
366 		TIFFSetField( tif, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );
367 	if( wtiff-&gt;toilet_roll ) {
368 		TIFFSetField( tif, TIFFTAG_SUBFILETYPE, FILETYPE_PAGE );
369 		TIFFSetField( tif, TIFFTAG_PAGENUMBER, 
370 			wtiff-&gt;page_number, wtiff-&gt;n_pages );
371 	}
372 	if( wtiff-&gt;input-&gt;Type != VIPS_INTERPRETATION_XYZ ) { 
373 		int format; 
374 		format = SAMPLEFORMAT_UINT;
375 		if( vips_band_format_isuint( wtiff-&gt;ready-&gt;BandFmt ) )
376 			format = SAMPLEFORMAT_UINT;
377 		else if( vips_band_format_isint( wtiff-&gt;ready-&gt;BandFmt ) )
378 			format = SAMPLEFORMAT_INT;
379 		else if( vips_band_format_isfloat( wtiff-&gt;ready-&gt;BandFmt ) )
380 			format = SAMPLEFORMAT_IEEEFP;
381 		else if( vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) )
382 			format = SAMPLEFORMAT_COMPLEXIEEEFP;
383 		TIFFSetField( tif, TIFFTAG_SAMPLEFORMAT, format );
384 	}
385 	return( 0 );
386 }
387 static int
388 wtiff_layer_rewind( Wtiff *wtiff, Layer *layer )
389 {
390 	VipsRect strip_size;
391 	strip_size.left = 0;
392 	strip_size.top = 0;
393 	strip_size.width = layer-&gt;image-&gt;Xsize;
394 	strip_size.height = wtiff-&gt;tileh;
395 	if( (strip_size.height &amp; 1) == 1 )
396 		strip_size.height += 1;
397 	if( vips_region_buffer( layer-&gt;strip, &amp;strip_size ) ) 
398 		return( -1 );
399 	layer-&gt;y = 0;
400 	layer-&gt;write_y = 0;
401 	return( 0 );
402 }
403 static int
404 wtiff_allocate_layers( Wtiff *wtiff )
405 {
406 	Layer *layer;
407 	g_assert( wtiff-&gt;layer );
408 	for( layer = wtiff-&gt;layer; layer; layer = layer-&gt;below ) {
409 		if( !layer-&gt;image ) {
410 			layer-&gt;image = vips_image_new();
411 			if( vips_image_pipelinev( layer-&gt;image, 
412 				VIPS_DEMAND_STYLE_ANY, wtiff-&gt;ready, NULL ) ) 
413 				return( -1 );
414 			layer-&gt;image-&gt;Xsize = layer-&gt;width;
415 			layer-&gt;image-&gt;Ysize = layer-&gt;height;
416 			layer-&gt;strip = vips_region_new( layer-&gt;image );
417 			layer-&gt;copy = vips_region_new( layer-&gt;image );
418 			vips__region_no_ownership( layer-&gt;strip );
419 			vips__region_no_ownership( layer-&gt;copy );
420 			if( layer-&gt;lname ) 
421 				layer-&gt;tif = vips__tiff_openout( 
422 					layer-&gt;lname, wtiff-&gt;bigtiff );
423 			else {
424 				layer-&gt;tif = vips__tiff_openout_buffer( 
425 					wtiff-&gt;ready, wtiff-&gt;bigtiff, 
426 					&amp;layer-&gt;buf, &amp;layer-&gt;len );
427 			}
428 			if( !layer-&gt;tif ) 
429 				return( -1 );
430 		}
431 		if( wtiff_layer_rewind( wtiff, layer ) )
432 			return( -1 ); 
433 		if( wtiff_write_header( wtiff, layer ) )  
434 			return( -1 );
435 	}
436 	if( !wtiff-&gt;tbuf ) { 
437 		if( wtiff-&gt;tile ) 
438 			wtiff-&gt;tbuf = vips_malloc( NULL, 
439 				TIFFTileSize( wtiff-&gt;layer-&gt;tif ) );
440 		else
441 			wtiff-&gt;tbuf = vips_malloc( NULL, 
442 				TIFFScanlineSize( wtiff-&gt;layer-&gt;tif ) );
443 		if( !wtiff-&gt;tbuf ) 
444 			return( -1 );
445 	}
446 	return( 0 );
447 }
448 static void
449 wtiff_delete_temps( Wtiff *wtiff )
450 {
451 	Layer *layer;
452 	if( wtiff-&gt;layer &amp;&amp;
453 		wtiff-&gt;layer-&gt;below )
454 		for( layer = wtiff-&gt;layer-&gt;below; layer; layer = layer-&gt;below ) 
455 			if( layer-&gt;lname ) {
456 #ifndef DEBUG
457 				unlink( layer-&gt;lname );
458 				VIPS_FREE( layer-&gt;buf );
459 #else
460 				printf( "wtiff_delete_temps: leaving %s\n", 
461 					layer-&gt;lname );
462 				layer-&gt;lname = NULL;
463 			}
464 }
465 static void
466 layer_free( Layer *layer )
467 {
468 	VIPS_UNREF( layer-&gt;strip );
469 	VIPS_UNREF( layer-&gt;copy );
470 	VIPS_UNREF( layer-&gt;image );
471 	VIPS_FREE( layer-&gt;buf );
472 	VIPS_FREEF( TIFFClose, layer-&gt;tif );
473 }
474 static void
475 layer_free_all( Layer *layer )
476 {
477 	if( layer-&gt;below ) 
478 		layer_free_all( layer-&gt;below );
479 	layer_free( layer );
480 }
481 static void
482 wtiff_free( Wtiff *wtiff )
483 {
484 	wtiff_delete_temps( wtiff );
485 	VIPS_UNREF( wtiff-&gt;ready );
486 	VIPS_FREE( wtiff-&gt;tbuf );
487 	VIPS_FREEF( layer_free_all, wtiff-&gt;layer );
488 	VIPS_FREE( wtiff-&gt;filename );
489 	VIPS_FREE( wtiff );
490 }
491 static int
492 get_compression( VipsForeignTiffCompression compression )
493 {
494 	switch( compression ) {
495 	case VIPS_FOREIGN_TIFF_COMPRESSION_NONE:
496 		return( COMPRESSION_NONE );
497 	case VIPS_FOREIGN_TIFF_COMPRESSION_JPEG:
498 		return( COMPRESSION_JPEG );
499 	case VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE:
500 		return( COMPRESSION_ADOBE_DEFLATE );
501 	case VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS:
502 		return( COMPRESSION_PACKBITS );
503 	case VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4:
504 		return( COMPRESSION_CCITTFAX4 );
505 	case VIPS_FOREIGN_TIFF_COMPRESSION_LZW:
506 		return( COMPRESSION_LZW );
507 #ifdef HAVE_TIFF_COMPRESSION_WEBP
508 	case VIPS_FOREIGN_TIFF_COMPRESSION_WEBP:
509 		return( COMPRESSION_WEBP );
510 	case VIPS_FOREIGN_TIFF_COMPRESSION_ZSTD:
511 		return( COMPRESSION_ZSTD );
512 	case VIPS_FOREIGN_TIFF_COMPRESSION_JP2K:
513 		return( JP2K_LOSSY );
514 	default:
515 		return( COMPRESSION_NONE );
516 	}
517 }
518 static int
519 get_resunit( VipsForeignTiffResunit resunit )
520 {
521 	switch( resunit ) {
522 	case VIPS_FOREIGN_TIFF_RESUNIT_CM:
523 		return( RESUNIT_CENTIMETER );
524 	case VIPS_FOREIGN_TIFF_RESUNIT_INCH:
525 		return( RESUNIT_INCH );
526 	default:
527 		g_assert_not_reached();
528 	}
529 	return( -1 );
530 }
531 static int
532 ready_to_write( Wtiff *wtiff )
533 {
534 	VipsImage *input;
535 	VipsImage *x;
536 	input = wtiff-&gt;input;
537 	g_object_ref( input );
538 	if( vips_check_coding_known( "vips2tiff", input ) ) {
539 		VIPS_UNREF( input );
540 		return( -1 );
541 	}
542 	if( wtiff-&gt;premultiply &amp;&amp;
543 		vips_image_hasalpha( input ) ) {
544 		VipsBandFormat start_format = input-&gt;BandFmt;
545 		if( vips_premultiply( input, &amp;x, NULL ) ) {
546 			VIPS_UNREF( input );
547 			return( -1 );
548 		}
549 		VIPS_UNREF( input );
550 		input = x;
551 		if( vips_cast( input, &amp;x, start_format, NULL ) ) {
552 			VIPS_UNREF( input );
553 			return( -1 );
554 		}
555 		VIPS_UNREF( input );
556 		input = x;
557 	}
558 	if( wtiff-&gt;bitdepth &amp;&amp;
559 		input-&gt;Bands == 3 &amp;&amp;
560 		input-&gt;BandFmt == VIPS_FORMAT_FLOAT &amp;&amp;
561 		input-&gt;Type == VIPS_INTERPRETATION_LAB ) {
562 		if( vips_Lab2LabQ( input, &amp;x, NULL ) ) {
563 			VIPS_UNREF( input );
564 			return( -1 );
565 		}
566 		VIPS_UNREF( input );
567 		input = x;
568 	}
569 	wtiff-&gt;ready = input;
570 	return( 0 );
571 }
572 static Wtiff *
573 wtiff_new( VipsImage *input, const char *filename, 
574 	VipsForeignTiffCompression compression, int Q, 
575 	VipsForeignTiffPredictor predictor,
576 	const char *profile,
577 	gboolean tile, int tile_width, int tile_height,
578 	gboolean pyramid,
579 	int bitdepth,
580 	gboolean miniswhite,
581 	VipsForeignTiffResunit resunit, double xres, double yres,
582 	gboolean bigtiff,
583 	gboolean rgbjpeg,
584 	gboolean properties,
585 	gboolean strip,
586 	VipsRegionShrink region_shrink,
587 	int level, 
588 	gboolean lossless,
589 	VipsForeignDzDepth depth, 
590 	gboolean subifd,
591 	gboolean premultiply )
592 {
593 	Wtiff *wtiff;
594 	if( !(wtiff = VIPS_NEW( NULL, Wtiff )) )
595 		return( NULL );
596 	wtiff-&gt;input = input;
597 	wtiff-&gt;ready = NULL;
598 	wtiff-&gt;filename = filename ? vips_strdup( NULL, filename ) : NULL;
599 	wtiff-&gt;layer = NULL;
600 	wtiff-&gt;tbuf = NULL;
601 	wtiff-&gt;compression = get_compression( compression );
602 	wtiff-&gt;Q = Q;
603 	wtiff-&gt;predictor = predictor;
604 	wtiff-&gt;tile = tile;
605 	wtiff-&gt;tilew = tile_width;
606 	wtiff-&gt;tileh = tile_height;
607 	wtiff-&gt;pyramid = pyramid;
608 	wtiff-&gt;bitdepth = bitdepth;
609 	wtiff-&gt;miniswhite = miniswhite;
610 	wtiff-&gt;resunit = get_resunit( resunit );
611 	wtiff-&gt;xres = xres;
612 	wtiff-&gt;yres = yres;
613 	wtiff-&gt;profile = profile;
614 	wtiff-&gt;bigtiff = bigtiff;
615 	wtiff-&gt;rgbjpeg = rgbjpeg;
616 	wtiff-&gt;properties = properties;
617 	wtiff-&gt;strip = strip;
618 	wtiff-&gt;region_shrink = region_shrink;
619 	wtiff-&gt;level = level;
620 	wtiff-&gt;lossless = lossless;
621 	wtiff-&gt;depth = depth;
622 	wtiff-&gt;subifd = subifd;
623 	wtiff-&gt;premultiply = premultiply;
624 	wtiff-&gt;toilet_roll = FALSE;
625 	wtiff-&gt;page_height = vips_image_get_page_height( input );
626 	wtiff-&gt;page_number = 0;
627 	wtiff-&gt;n_pages = 1;
628 	wtiff-&gt;image_height = input-&gt;Ysize;
629 	if( ready_to_write( wtiff ) ) {
630 		wtiff_free( wtiff );
631 		return( NULL );
632 	}
633 	if( wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_XYZ ) 
634 		wtiff-&gt;compression = COMPRESSION_SGILOG;
635 	if( wtiff-&gt;page_height &lt; wtiff-&gt;ready-&gt;Ysize ) {
636 #ifdef DEBUG
637 		printf( "wtiff_new: detected toilet roll image, "
638 			"page-height=%d\n", 
639 			wtiff-&gt;page_height );
640 		printf( "wtiff_new: pages=%d\n", 
641 			wtiff-&gt;ready-&gt;Ysize / wtiff-&gt;page_height );
642 		wtiff-&gt;toilet_roll = TRUE;
643 		wtiff-&gt;image_height = wtiff-&gt;page_height;
644 		wtiff-&gt;n_pages = wtiff-&gt;ready-&gt;Ysize / wtiff-&gt;page_height;
645 	}
646 	if( wtiff-&gt;pyramid ) {
647 		if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_NONE &amp;&amp; 
648 			vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) ) {
649 			wtiff_free( wtiff );
650 			vips_error( "vips2tiff", 
651 				"%s", _( "can only pyramid LABQ and "
652 				"non-complex images" ) );
653 			return( NULL );
654 		}
655 	}
656 	if( wtiff-&gt;pyramid &amp;&amp;
657 		!wtiff-&gt;tile )
658 		wtiff-&gt;tile = TRUE;
659 	if( wtiff-&gt;pyramid &amp;&amp;
660 		wtiff-&gt;toilet_roll )
661 		wtiff-&gt;subifd = TRUE;
662 	if( wtiff-&gt;compression == COMPRESSION_NONE &amp;&amp;
663 		VIPS_IMAGE_SIZEOF_IMAGE( wtiff-&gt;ready ) &gt; UINT_MAX )
664 		wtiff-&gt;bigtiff = TRUE;
665 	if( wtiff-&gt;tile ) { 
666 		if( (wtiff-&gt;tilew &amp; 0xf) != 0 || 
667 			(wtiff-&gt;tileh &amp; 0xf) != 0 ) {
668 			wtiff_free( wtiff );
669 			vips_error( "vips2tiff", 
670 				"%s", _( "tile size not a multiple of 16" ) );
671 			return( NULL );
672 		}
673 	}
674 	if( wtiff-&gt;bitdepth &amp;&amp; 
675 		!(wtiff-&gt;bitdepth == 1 || 
676 		  wtiff-&gt;bitdepth == 2 || 
677 		  wtiff-&gt;bitdepth == 4) ) {
678 		g_warning( "%s",
679 			_( "bitdepth 1, 2 or 4 only -- disabling bitdepth") );
680 		wtiff-&gt;bitdepth = 0;
681 	}
682 	if( wtiff-&gt;bitdepth &amp;&amp; 
683 		!(wtiff-&gt;ready-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
684 		  wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR &amp;&amp; 
685 		  wtiff-&gt;ready-&gt;Bands == 1) ) { 
686 		g_warning( "%s",
687 			( "can only set bitdepth for 1-band uchar and "
688                         "3-band float lab -- disabling bitdepth" ) );
689 		wtiff-&gt;bitdepth = 0;
690 	}
691 	if( wtiff-&gt;bitdepth &amp;&amp;
692 		wtiff-&gt;compression == COMPRESSION_JPEG ) {
693 		g_warning( "%s", 
694 			_( "can't have &lt;8 bit JPEG -- disabling JPEG" ) );
695 		wtiff-&gt;compression = COMPRESSION_NONE;
696 	}
697 	if( wtiff-&gt;miniswhite &amp;&amp;
698 		(wtiff-&gt;ready-&gt;Coding != VIPS_CODING_NONE || 
699 			vips_band_format_iscomplex( wtiff-&gt;ready-&gt;BandFmt ) ||
700 			wtiff-&gt;ready-&gt;Bands &gt; 2) ) {
701 		g_warning( "%s", 
702 			_( "can only save non-complex greyscale images "
703 				"as miniswhite -- disabling miniswhite" ) );
704 		wtiff-&gt;miniswhite = FALSE;
705 	}
706 	if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ )
707 		wtiff-&gt;tls = wtiff-&gt;tilew * 3;
708 	else if( wtiff-&gt;bitdepth == 1 )
709 		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 8 ) / 8;
710 	else if( wtiff-&gt;bitdepth == 2 )
711 		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 4 ) / 4;
712 	else if( wtiff-&gt;bitdepth == 4 )
713 		wtiff-&gt;tls = VIPS_ROUND_UP( wtiff-&gt;tilew, 2 ) / 2;
714 	else
715 		wtiff-&gt;tls = VIPS_IMAGE_SIZEOF_PEL( wtiff-&gt;ready ) * 
716 			wtiff-&gt;tilew;
717 	return( wtiff );
718 }
719 static void
720 LabQ2LabC( VipsPel *q, VipsPel *p, int n )
721 {
722 	int x;
723 	for( x = 0; x &lt; n; x++ ) {
724 		q[0] = p[0];
725 		q[1] = p[1];
726 		q[2] = p[2];
727 		p += 4;
728 		q += 3;
729 	}
730 }
731 static void
732 eightbit2nbit( Wtiff *wtiff, VipsPel *q, VipsPel *p, int n )
733 {
734 	VipsPel mask = wtiff-&gt;miniswhite ? 255 : 0;
735 	int pixel_mask = 8 / wtiff-&gt;bitdepth - 1;
736 	int shift = 8 - wtiff-&gt;bitdepth;
737 	VipsPel bits;
738         int x;
739 	bits = 0;
740         for( x = 0; x &lt; n; x++ ) {
741 		bits &lt;&lt;= wtiff-&gt;bitdepth;
742 		bits |= p[x] &gt;&gt; shift;
743 		if( (x &amp; pixel_mask) == pixel_mask ) 
744 			*q++ = bits ^ mask;
745         }
746 	if( (x &amp; pixel_mask) != 0 ) {
747 		int collected_bits = (x &amp; pixel_mask) &lt;&lt; (wtiff-&gt;bitdepth - 1);
748 		*q++ = (bits ^ mask) &lt;&lt; (8 - collected_bits);
749 	}
750 }
751 #define GREY_LOOP( TYPE, MAX ) { \
752 	TYPE *p1; \
753 	TYPE *q1; \
754 	\
755 	p1 = (TYPE *) p; \
756 	q1 = (TYPE *) q; \
757 	for( x = 0; x &lt; n; x++ ) { \
758 		if( invert ) \
759 			q1[0] = MAX - p1[0]; \
760 		else \
761 			q1[0] = p1[0]; \
762 		\
763 		for( i = 1; i &lt; im-&gt;Bands; i++ ) \
764 			q1[i] = p1[i]; \
765 		\
766 		q1 += im-&gt;Bands; \
767 		p1 += im-&gt;Bands; \
768 	} \
769 }
770 static void
771 invert_band0( Wtiff *wtiff, VipsPel *q, VipsPel *p, int n )
772 {
773 	VipsImage *im = wtiff-&gt;ready;
774 	gboolean invert = wtiff-&gt;miniswhite;
775         int x, i;
776 	switch( im-&gt;BandFmt ) {
777 	case VIPS_FORMAT_UCHAR:
778 	case VIPS_FORMAT_CHAR:
779 		GREY_LOOP( guchar, UCHAR_MAX ); 
780 		break;
781 	case VIPS_FORMAT_SHORT:
782 		GREY_LOOP( gshort, SHRT_MAX ); 
783 		break;
784 	case VIPS_FORMAT_USHORT:
785 		GREY_LOOP( gushort, USHRT_MAX ); 
786 		break;
787 	case VIPS_FORMAT_INT:
788 		GREY_LOOP( gint, INT_MAX ); 
789 		break;
790 	case VIPS_FORMAT_UINT:
791 		GREY_LOOP( guint, UINT_MAX ); 
792 		break;
793 	case VIPS_FORMAT_FLOAT:
794 		GREY_LOOP( float, 1.0 ); 
795 		break;
796 	case VIPS_FORMAT_DOUBLE:
797 		GREY_LOOP( double, 1.0 ); 
798 		break;
799 	default:
800 		g_assert_not_reached();
801 	}
802 }
803 static void
804 LabS2Lab16( VipsPel *q, VipsPel *p, int n, int samples_per_pixel )
805 {
806 	short *p1 = (short *) p;
807 	unsigned short *q1 = (unsigned short *) q;
808 	int x;
809         for( x = 0; x &lt; n; x++ ) {
810 		int i;
811                 q1[0] = VIPS_LSHIFT_INT( VIPS_MAX( 0, p1[0] ), 1 );
812 		for( i = 1; i &lt; samples_per_pixel; i++ )
813 			q1[i] = p1[i];
814 		q1 += samples_per_pixel;
815 		p1 += samples_per_pixel;
816 	}
817 }
818 static void
819 XYZ2tiffxyz( VipsPel *q, VipsPel *p, int n, int samples_per_pixel )
820 {
821 	float *p1 = (float *) p;
822 	float *q1 = (float *) q;
823 	int x;
824         for( x = 0; x &lt; n; x++ ) {
825 		int i;
826                 q1[0] = p1[0] / VIPS_D65_X0;
827                 q1[1] = p1[1] / VIPS_D65_Y0;
828                 q1[2] = p1[2] / VIPS_D65_Z0;
829 		for( i = 3; i &lt; samples_per_pixel; i++ )
830 			q1[i] = p1[i];
831 		q1 += samples_per_pixel;
832 		p1 += samples_per_pixel;
833 	}
834 }
835 static void
836 wtiff_pack2tiff( Wtiff *wtiff, Layer *layer, 
837 	VipsRegion *in, VipsRect *area, VipsPel *q )
838 {
839 	int y;
840 	if( wtiff-&gt;compression == COMPRESSION_JPEG &amp;&amp;
841 		(area-&gt;width &lt; wtiff-&gt;tilew || 
842 		 area-&gt;height &lt; wtiff-&gt;tileh) )
843 		memset( q, 0, TIFFTileSize( layer-&gt;tif ) );
844 	for( y = area-&gt;top; y &lt; VIPS_RECT_BOTTOM( area ); y++ ) {
845 		VipsPel *p = (VipsPel *) VIPS_REGION_ADDR( in, area-&gt;left, y );
846 		if( wtiff-&gt;ready-&gt;Coding == VIPS_CODING_LABQ )
847 			LabQ2LabC( q, p, area-&gt;width );
848 		else if( wtiff-&gt;bitdepth &gt; 0 )
849 			eightbit2nbit( wtiff, q, p, area-&gt;width );
850 		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ )
851 			XYZ2tiffxyz( q, p, area-&gt;width, in-&gt;im-&gt;Bands );
852 		else if( (in-&gt;im-&gt;Bands == 1 || in-&gt;im-&gt;Bands == 2) &amp;&amp; 
853 			wtiff-&gt;miniswhite ) 
854 			invert_band0( wtiff, q, p, area-&gt;width );
855 		else if( wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_SHORT &amp;&amp;
856 			wtiff-&gt;ready-&gt;Type == VIPS_INTERPRETATION_LABS )
857 			LabS2Lab16( q, p, area-&gt;width, in-&gt;im-&gt;Bands );
858 		else
859 			memcpy( q, p, 
860 				area-&gt;width * 
861 					VIPS_IMAGE_SIZEOF_PEL( wtiff-&gt;ready ) );
862 		q += wtiff-&gt;tls;
863 	}
864 }
865 static int
866 wtiff_layer_write_tiles( Wtiff *wtiff, Layer *layer, VipsRegion *strip )
867 {
868 	VipsImage *im = layer-&gt;image;
869 	VipsRect *area = &amp;strip-&gt;valid;
870 	VipsRect image;
871 	int x;
872 	image.left = 0;
873 	image.top = 0;
874 	image.width = im-&gt;Xsize;
875 	image.height = im-&gt;Ysize;
876 	for( x = 0; x &lt; im-&gt;Xsize; x += wtiff-&gt;tilew ) {
877 		VipsRect tile;
878 		tile.left = x;
879 		tile.top = area-&gt;top;
880 		tile.width = wtiff-&gt;tilew;
881 		tile.height = wtiff-&gt;tileh;
882 		vips_rect_intersectrect( &amp;tile, &amp;image, &amp;tile );
883 #ifdef DEBUG_VERBOSE
884 		printf( "Writing %dx%d tile at position %dx%d to image %s\n",
885 			tile.width, tile.height, tile.left, tile.top,
886 			TIFFFileName( layer-&gt;tif ) );
887 		if( wtiff-&gt;we_compress ) {
888 			ttile_t tile_no = TIFFComputeTile( layer-&gt;tif,
889 				tile.left, tile.top, 0, 0 );
890 			VipsTarget *target;
891 			int result;
892 			unsigned char *buffer;
893 			size_t length;
894 			target = vips_target_new_to_memory();
895 			switch( wtiff-&gt;compression ) {
896 			case JP2K_LOSSY:
897 				result = vips__foreign_load_jp2k_compress( 
898 					strip, &amp;tile, target,
899 					wtiff-&gt;tilew, wtiff-&gt;tileh,
900 					!wtiff-&gt;rgbjpeg,
901 					FALSE,
902 					wtiff-&gt;lossless, 
903 					wtiff-&gt;Q );
904 				break;
905 			default:
906 				result = -1;
907 				g_assert_not_reached();
908 				break;
909 			}
910 			if( result ) {
911 				g_object_unref( target );
912 				return( -1 );
913 			}
914 			buffer = vips_target_steal( target, &amp;length );
915 			g_object_unref( target );
916 			result = TIFFWriteRawTile( layer-&gt;tif, tile_no, 
917 				buffer, length );
918 			g_free( buffer );
919 			if( result &lt; 0 ) {
920 				vips_error( "vips2tiff", 
921 					"%s", _( "TIFF write tile failed" ) );
922 				return( -1 );
923 			}
924 		}
925 		else {
926 			wtiff_pack2tiff( wtiff, 
927 				layer, strip, &amp;tile, wtiff-&gt;tbuf );
928 			if( TIFFWriteTile( layer-&gt;tif, wtiff-&gt;tbuf, 
929 				tile.left, tile.top, 0, 0 ) &lt; 0 ) {
930 				vips_error( "vips2tiff", 
931 					"%s", _( "TIFF write tile failed" ) );
932 				return( -1 );
933 			}
934 		}
935 	}
936 	return( 0 );
937 }
938 static int
939 wtiff_layer_write_strip( Wtiff *wtiff, Layer *layer, VipsRegion *strip )
940 {
941 	VipsImage *im = layer-&gt;image;
942 	VipsRect *area = &amp;strip-&gt;valid;
943 	int height = VIPS_MIN( wtiff-&gt;tileh, area-&gt;height ); 
944 	int y;
945 #ifdef DEBUG_VERBOSE
946 	printf( "Writing %d pixel strip at height %d to image %s\n",
947 		height, area-&gt;top, TIFFFileName( layer-&gt;tif ) );
948 	for( y = 0; y &lt; height; y++ ) {
949 		VipsPel *p = VIPS_REGION_ADDR( strip, 0, area-&gt;top + y );
950 		if( im-&gt;Coding == VIPS_CODING_LABQ ) {
951 			LabQ2LabC( wtiff-&gt;tbuf, p, im-&gt;Xsize );
952 			p = wtiff-&gt;tbuf;
953 		}
954 		else if( im-&gt;BandFmt == VIPS_FORMAT_SHORT &amp;&amp;
955 			im-&gt;Type == VIPS_INTERPRETATION_LABS ) {
956 			LabS2Lab16( wtiff-&gt;tbuf, p, im-&gt;Xsize, im-&gt;Bands );
957 			p = wtiff-&gt;tbuf;
958 		}
959 		else if( wtiff-&gt;input-&gt;Type == VIPS_INTERPRETATION_XYZ ) {
960 			XYZ2tiffxyz( wtiff-&gt;tbuf, p, im-&gt;Xsize, im-&gt;Bands );
961 			p = wtiff-&gt;tbuf;
962 		}
963 		else if( wtiff-&gt;bitdepth &gt; 0 ) {
964 			eightbit2nbit( wtiff, wtiff-&gt;tbuf, p, im-&gt;Xsize );
965 			p = wtiff-&gt;tbuf;
966 		}
967 		else if( (im-&gt;Bands == 1 || im-&gt;Bands == 2) &amp;&amp; 
968 			wtiff-&gt;miniswhite ) {
969 			invert_band0( wtiff, wtiff-&gt;tbuf, p, im-&gt;Xsize );
970 			p = wtiff-&gt;tbuf;
971 		}
972 		if( TIFFWriteScanline( layer-&gt;tif, p, area-&gt;top + y, 0 ) &lt; 0 ) 
973 			return( -1 );
974 	}
975 	return( 0 );
976 }
977 static int layer_strip_arrived( Layer *layer );
978 <a name="0"></a>static int
979 layer_strip_shrink( Layer *layer )
980 {
981 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	Layer *below = layer-&gt;below;
982 	VipsRegion *from = layer-&gt;strip;
983 	VipsRegion *to = below-&gt;strip;
984 	VipsRect target;
985 	VipsRect source;
986 	for(;;) {
987 		target.left = 0;
988 		target.top = below-&gt;write_y;
989 		target.width = below-&gt;image-&gt;Xsize;
990 		target.height = to-&gt;valid.height;
991 		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );
992 		source.left = target.left * 2;
993 		source.top = target.top * 2;
994 		source.width = target.width * 2;
995 		source.height = target.height * 2;
996 		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );
997 		target.left = source.left / 2;
998 		target.top = source.top / 2;
999 		target.width = source.width / 2;
1000 		target.height = source.height / 2;
1001 		if( vips_rect_isempty( &amp;target ) )
1002 			break;
1003 		(void) vips_region_shrink_method( from, to, &amp;target,
1004 			layer-&gt;wtiff-&gt;region_shrink );
1005 		below-&gt;write_y += target.height;
1006 		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
1007 			below-&gt;write_y == below-&gt;height ) {
1008 			if( layer_strip_arrived( below ) )
1009 				return( -1 );
1010 		}
1011 	}
1012 	return( 0 );
1013 }
1014 static int
1015 layer_strip_arrived( Layer *layer )
1016 {
1017 	Wtiff *wtiff = layer-&gt;wtiff;</b></font>
1018 	int result;
1019 	VipsRect new_strip;
1020 	VipsRect overlap;
1021 	VipsRect image_area;
1022 	if( wtiff-&gt;tile ) 
1023 <a name="2"></a>		result = wtiff_layer_write_tiles( wtiff, layer, layer-&gt;strip );
1024 	else
1025 		result = wtiff_layer_write_strip( wtiff, layer, layer-&gt;strip );
1026 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( result )
1027 		return( -1 );
1028 	if( layer-&gt;below &amp;&amp;
1029 		layer_strip_shrink( layer ) ) 
1030 		return( -1 );
1031 	layer-&gt;y += wtiff-&gt;tileh;
1032 	new_strip.left = 0;
1033 	new_strip.top = layer-&gt;y;
1034 	new_strip.width = layer-&gt;image-&gt;Xsize;
1035 	new_strip.height = wtiff-&gt;tileh;
1036 	image_area.left = 0;
1037 	image_area.top = 0;
1038 	image_area.width = layer-&gt;image-&gt;Xsize;
1039 	image_area.height = layer-&gt;image-&gt;Ysize;
1040 	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 
1041 	if( (new_strip.height &amp; 1) == 1 )
1042 		new_strip.height += 1;
1043 	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
1044 	if( !vips_rect_isempty( &amp;overlap ) ) {</b></font>
1045 		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
1046 			return( -1 );
1047 		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
1048 			&amp;overlap, overlap.left, overlap.top );
1049 	}
1050 	if( !vips_rect_isempty( &amp;new_strip ) ) {
1051 		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) ) 
1052 			return( -1 );
1053 		if( !vips_rect_isempty( &amp;overlap ) ) 
1054 			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
1055 <a name="1"></a>				&amp;overlap, overlap.left, overlap.top );
1056 	}
1057 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
1058 }
1059 static int
1060 write_strip( VipsRegion *region, VipsRect *area, void *a )
1061 {
1062 	Wtiff *wtiff = (Wtiff *) a;
1063 	Layer *layer = wtiff-&gt;layer; 
1064 #ifdef DEBUG_VERBOSE
1065 	printf( "write_strip: strip at %d, height %d\n", 
1066 		area-&gt;top, area-&gt;height );
1067 	for(;;) {
1068 		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
1069 		VipsRect target;
1070 		target.left = 0;
1071 		target.top = layer-&gt;write_y;
1072 		target.width = layer-&gt;image-&gt;Xsize;
1073 		target.height = to-&gt;height;
1074 		vips_rect_intersectrect( &amp;target, to, &amp;target );
1075 		vips_rect_intersectrect( &amp;target, area, &amp;target );
1076 		if( vips_rect_isempty( &amp;target ) ) 
1077 			break;
1078 		vips_region_copy( region, layer-&gt;strip, 
1079 			&amp;target, target.left, target.top );
1080 		layer-&gt;write_y += target.height;
1081 		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
1082 			layer-&gt;write_y == layer-&gt;height ) {
1083 			if( layer_strip_arrived( layer ) ) 
1084 				return( -1 );
1085 		}
1086 	}</b></font>
1087 	return( 0 );
1088 }
1089 #define CopyField( tag, v ) \
1090 	if( TIFFGetField( in, tag, &amp;v ) ) TIFFSetField( out, tag, v )
1091 static int
1092 wtiff_copy_tiles( Wtiff *wtiff, TIFF *out, TIFF *in )
1093 {
1094 	const ttile_t n_tiles = TIFFNumberOfTiles( in );
1095 	tsize_t tile_size;
1096 	tdata_t buf;
1097 	ttile_t i;
1098 	if( wtiff-&gt;compression == COMPRESSION_JPEG ) 
1099 		tile_size = TIFFTileSize( in );
1100 	else 
1101 		tile_size = 2 * wtiff-&gt;tls * wtiff-&gt;tileh;
1102 	buf = vips_malloc( NULL, tile_size );
1103 	for( i = 0; i &lt; n_tiles; i++ ) {
1104 		tsize_t len;
1105 		if( wtiff-&gt;compression == COMPRESSION_JPEG ) {
1106 			len = TIFFReadEncodedTile( in, i, buf, tile_size );
1107 			if( len &lt;= 0 ||
1108 				TIFFWriteEncodedTile( out, i, buf, len ) &lt; 0 ) {
1109 				g_free( buf );
1110 				return( -1 );
1111 			}
1112 		}
1113 		else {
1114 			len = TIFFReadRawTile( in, i, buf, tile_size );
1115 			if( len &lt;= 0 ||
1116 				TIFFWriteRawTile( out, i, buf, len ) &lt; 0 ) {
1117 				g_free( buf );
1118 				return( -1 );
1119 			}
1120 		}
1121 	}
1122 	g_free( buf );
1123 	return( 0 );
1124 }
1125 static int
1126 wtiff_copy_tiff( Wtiff *wtiff, TIFF *out, TIFF *in )
1127 {
1128 	uint32 ui32;
1129 	uint16 ui16;
1130 	uint16 ui16_2;
1131 	float f;
1132 	uint16 *a;
1133 	CopyField( TIFFTAG_IMAGEWIDTH, ui32 );
1134 	CopyField( TIFFTAG_IMAGELENGTH, ui32 );
1135 	CopyField( TIFFTAG_PLANARCONFIG, ui16 );
1136 	CopyField( TIFFTAG_ORIENTATION, ui16 );
1137 	CopyField( TIFFTAG_XRESOLUTION, f );
1138 	CopyField( TIFFTAG_YRESOLUTION, f );
1139 	CopyField( TIFFTAG_RESOLUTIONUNIT, ui16 );
1140 	CopyField( TIFFTAG_COMPRESSION, ui16 );
1141 	CopyField( TIFFTAG_SAMPLESPERPIXEL, ui16 );
1142 	CopyField( TIFFTAG_BITSPERSAMPLE, ui16 );
1143 	CopyField( TIFFTAG_PHOTOMETRIC, ui16 );
1144 	CopyField( TIFFTAG_ORIENTATION, ui16 );
1145 	CopyField( TIFFTAG_TILEWIDTH, ui32 );
1146 	CopyField( TIFFTAG_TILELENGTH, ui32 );
1147 	CopyField( TIFFTAG_ROWSPERSTRIP, ui32 );
1148 	CopyField( TIFFTAG_SUBFILETYPE, ui32 );
1149 	if( TIFFGetField( in, TIFFTAG_EXTRASAMPLES, &amp;ui16, &amp;a ) ) 
1150 		TIFFSetField( out, TIFFTAG_EXTRASAMPLES, ui16, a );
1151 	if( TIFFGetField( in, TIFFTAG_PAGENUMBER, &amp;ui16, &amp;ui16_2 ) ) 
1152 		TIFFSetField( out, TIFFTAG_PAGENUMBER, ui16, ui16_2 );
1153 	if( wtiff-&gt;compression == COMPRESSION_JPEG ) {
1154 		TIFFSetField( out, TIFFTAG_JPEGQUALITY, wtiff-&gt;Q );
1155 		if( wtiff-&gt;ready-&gt;Bands == 3 &amp;&amp;
1156 			wtiff-&gt;ready-&gt;BandFmt == VIPS_FORMAT_UCHAR ) { 
1157 			if( !wtiff-&gt;rgbjpeg &amp;&amp;
1158 				wtiff-&gt;Q &lt; 90 ) 
1159 				TIFFSetField( out, 
1160 					TIFFTAG_JPEGCOLORMODE, 
1161 						JPEGCOLORMODE_RGB );
1162 			TIFFSetField( in, 
1163 				TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );
1164 		}
1165 	}
1166 #ifdef HAVE_TIFF_COMPRESSION_WEBP
1167 	if( wtiff-&gt;compression == COMPRESSION_WEBP ) {
1168 		TIFFSetField( out, TIFFTAG_WEBP_LEVEL, wtiff-&gt;Q );
1169 		TIFFSetField( out, TIFFTAG_WEBP_LOSSLESS, wtiff-&gt;lossless );
1170 	}
1171 	if( wtiff-&gt;compression == COMPRESSION_ZSTD ) {
1172 		TIFFSetField( out, TIFFTAG_ZSTD_LEVEL, wtiff-&gt;level );
1173 		if( wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
1174 			TIFFSetField( out, 
1175 				TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
1176 	}
1177 	if( (wtiff-&gt;compression == COMPRESSION_ADOBE_DEFLATE ||
1178 		wtiff-&gt;compression == COMPRESSION_LZW) &amp;&amp;
1179 		wtiff-&gt;predictor != VIPS_FOREIGN_TIFF_PREDICTOR_NONE ) 
1180 		TIFFSetField( out, TIFFTAG_PREDICTOR, wtiff-&gt;predictor );
1181 	if( !wtiff-&gt;strip ) 
1182 		if( wtiff_embed_profile( wtiff, out ) ||
1183 			wtiff_embed_xmp( wtiff, out ) ||
1184 			wtiff_embed_iptc( wtiff, out ) ||
1185 			wtiff_embed_photoshop( wtiff, out ) ||
1186 			wtiff_embed_imagedescription( wtiff, out ) )
1187 			return( -1 );
1188 	if( wtiff_copy_tiles( wtiff, out, in ) )
1189 		return( -1 );
1190 	return( 0 );
1191 }
1192 static int
1193 wtiff_gather( Wtiff *wtiff )
1194 {
1195 	Layer *layer;
1196 	if( wtiff-&gt;layer &amp;&amp;
1197 		wtiff-&gt;layer-&gt;below )
1198 		for( layer = wtiff-&gt;layer-&gt;below; layer; 
1199 			layer = layer-&gt;below ) {
1200 			VipsSource *source;
1201 			TIFF *in;
1202 #ifdef DEBUG
1203 			printf( "appending layer %s ...\n", layer-&gt;lname );
1204 			if( layer-&gt;lname ) {
1205 				if( !(source = vips_source_new_from_file( 
1206 					layer-&gt;lname )) ) 
1207 					return( -1 );
1208 			}
1209 			else {
1210 				if( !(source = vips_source_new_from_memory(
1211 					layer-&gt;buf, layer-&gt;len )) )
1212 					return( -1 );
1213 			}
1214 			if( !(in = vips__tiff_openin_source( source )) ) {
1215 				VIPS_UNREF( source );
1216 				return( -1 );
1217 			}
1218 			VIPS_UNREF( source );
1219 			if( wtiff_copy_tiff( wtiff, wtiff-&gt;layer-&gt;tif, in ) ) {
1220 				TIFFClose( in );
1221 				return( -1 );
1222 			}
1223 			TIFFClose( in );
1224 			if( !TIFFWriteDirectory( wtiff-&gt;layer-&gt;tif ) ) 
1225 				return( -1 );
1226 		}
1227 	return( 0 );
1228 }
1229 static int
1230 wtiff_write_page( Wtiff *wtiff, VipsImage *page )
1231 {
1232 #ifdef DEBUG
1233 	printf( "wtiff_write_page:\n" ); 
1234 	wtiff_layer_init( wtiff, &amp;wtiff-&gt;layer, NULL, 
1235 		page-&gt;Xsize, page-&gt;Ysize );
1236 	if( wtiff_allocate_layers( wtiff ) ) 
1237 		return( -1 );
1238 	if( wtiff-&gt;subifd ) {
1239 		int n_layers;
1240 		toff_t *subifd_offsets;
1241 		Layer *p;
1242 #ifdef DEBUG
1243 		printf( "wtiff_write_page: OME pyr mode\n" ); 
1244 		for( n_layers = 0, p = wtiff-&gt;layer-&gt;below; p; p = p-&gt;below )
1245 			n_layers += 1;
1246 		subifd_offsets = VIPS_ARRAY( NULL, n_layers, toff_t );
1247 		memset( subifd_offsets, 0, n_layers * sizeof( toff_t ) );
1248 		TIFFSetField( wtiff-&gt;layer-&gt;tif, TIFFTAG_SUBIFD, 
1249 			n_layers, subifd_offsets );
1250 		g_free( subifd_offsets );
1251 	}
1252 	if( vips_sink_disc( page, write_strip, wtiff ) ) 
1253 		return( -1 );
1254 	if( !TIFFWriteDirectory( wtiff-&gt;layer-&gt;tif ) ) 
1255 		return( -1 );
1256 	if( wtiff-&gt;layer-&gt;below ) {
1257 		layer_free_all( wtiff-&gt;layer-&gt;below );
1258 		if( wtiff_gather( wtiff ) ) 
1259 			return( -1 );
1260 		wtiff_delete_temps( wtiff );
1261 		VIPS_FREEF( layer_free_all, wtiff-&gt;layer-&gt;below );
1262 	}
1263 	return( 0 );
1264 }
1265 static int
1266 wtiff_write_image( Wtiff *wtiff )
1267 {
1268 	int y;
1269 	for( y = 0; y &lt; wtiff-&gt;ready-&gt;Ysize; y += wtiff-&gt;page_height ) {
1270 		VipsImage *page;
1271 #ifdef DEBUG
1272 		printf( "writing page %d ...\n", wtiff-&gt;page_number );
1273 		if( vips_crop( wtiff-&gt;ready, &amp;page, 
1274 			0, y, wtiff-&gt;ready-&gt;Xsize, wtiff-&gt;page_height,
1275 			NULL ) )
1276 			return( -1 ); 
1277 		if( wtiff_write_page( wtiff, page ) ) {
1278 			g_object_unref( page );
1279 			return( -1 );
1280 		}
1281 		g_object_unref( page );
1282 		wtiff-&gt;page_number += 1;
1283 	}
1284 	return( 0 );
1285 }
1286 int 
1287 vips__tiff_write( VipsImage *input, const char *filename, 
1288 	VipsForeignTiffCompression compression, int Q, 
1289 	VipsForeignTiffPredictor predictor,
1290 	const char *profile,
1291 	gboolean tile, int tile_width, int tile_height,
1292 	gboolean pyramid,
1293 	int bitdepth,
1294 	gboolean miniswhite,
1295 	VipsForeignTiffResunit resunit, double xres, double yres,
1296 	gboolean bigtiff,
1297 	gboolean rgbjpeg,
1298 	gboolean properties, gboolean strip,
1299 	VipsRegionShrink region_shrink,
1300 	int level, 
1301 	gboolean lossless,
1302 	VipsForeignDzDepth depth,
1303 	gboolean subifd,
1304 	gboolean premultiply )
1305 {
1306 	Wtiff *wtiff;
1307 #ifdef DEBUG
1308 	printf( "tiff2vips: libtiff version is \"%s\"\n", TIFFGetVersion() );
1309 	vips__tiff_init();
1310 	if( !(wtiff = wtiff_new( input, filename, 
1311 		compression, Q, predictor, profile,
1312                 tile, tile_width, tile_height, pyramid, bitdepth,
1313 		miniswhite, resunit, xres, yres, bigtiff, rgbjpeg, 
1314 		properties, strip, region_shrink, level, lossless, depth,
1315 		subifd, premultiply )) )
1316 		return( -1 );
1317 	if( wtiff_write_image( wtiff ) ) { 
1318 		wtiff_free( wtiff );
1319 		return( -1 );
1320 	}
1321 	wtiff_free( wtiff );
1322 	return( 0 );
1323 }
1324 int 
1325 vips__tiff_write_buf( VipsImage *input, 
1326 	void **obuf, size_t *olen, 
1327 	VipsForeignTiffCompression compression, int Q, 
1328 	VipsForeignTiffPredictor predictor,
1329 	const char *profile,
1330 	gboolean tile, int tile_width, int tile_height,
1331 	gboolean pyramid,
1332 	int bitdepth,
1333 	gboolean miniswhite,
1334 	VipsForeignTiffResunit resunit, double xres, double yres,
1335 	gboolean bigtiff,
1336 	gboolean rgbjpeg,
1337 	gboolean properties, gboolean strip, 
1338 	VipsRegionShrink region_shrink,
1339 	int level, 
1340 	gboolean lossless,
1341 	VipsForeignDzDepth depth,
1342 	gboolean subifd,
1343 	gboolean premultiply )
1344 {
1345 	Wtiff *wtiff;
1346 	vips__tiff_init();
1347 	if( !(wtiff = wtiff_new( input, NULL, 
1348 		compression, Q, predictor, profile,
1349                 tile, tile_width, tile_height, pyramid, bitdepth,
1350 		miniswhite, resunit, xres, yres, bigtiff, rgbjpeg, 
1351 		properties, strip, region_shrink, level, lossless, depth,
1352 		subifd, premultiply )) )
1353 		return( -1 );
1354 	wtiff-&gt;obuf = obuf;
1355 	wtiff-&gt;olen = olen;
1356 	if( wtiff_write_image( wtiff ) ) { 
1357 		wtiff_free( wtiff );
1358 		return( -1 );
1359 	}
1360 	VIPS_FREEF( TIFFClose, wtiff-&gt;layer-&gt;tif );
1361 	*obuf = wtiff-&gt;layer-&gt;buf;
1362 	*olen = wtiff-&gt;layer-&gt;len;
1363 	wtiff-&gt;layer-&gt;buf = NULL;
1364 	wtiff_free( wtiff );
1365 	return( 0 );
1366 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dzsave.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/internal.h&gt;
9 #ifdef HAVE_GSF
10 #pragma GCC diagnostic push
11 #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
12 #include &lt;gsf/gsf.h&gt;
13 #pragma GCC diagnostic pop
14 typedef struct _VipsGsfDirectory { 
15 	struct _VipsGsfDirectory *parent;
16 	char *name;
17 	GSList *children;
18 	GsfOutput *out;
19         GsfOutput *container;
20 	size_t file_count;
21 	size_t filename_lengths;
22 	gint deflate_level;
23 } VipsGsfDirectory; 
24 static void *vips_gsf_tree_close( VipsGsfDirectory *tree );
25 static void *
26 vips_gsf_tree_close_cb( void *item, void *a, void *b )
27 {
28 	VipsGsfDirectory *tree = (VipsGsfDirectory *) item;
29 	return( vips_gsf_tree_close( tree ) );
30 }
31 static void *
32 vips_gsf_tree_close( VipsGsfDirectory *tree )
33 {
34 	vips_slist_map2( tree-&gt;children, vips_gsf_tree_close_cb, NULL, NULL );
35 	if( tree-&gt;out ) {
36 		if( !gsf_output_is_closed( tree-&gt;out ) &amp;&amp;
37 			!gsf_output_close( tree-&gt;out ) ) {
38 			vips_error( "vips_gsf", 
39 				"%s", _( "unable to close stream" ) ); 
40 			return( tree );
41 		}
42 		VIPS_UNREF( tree-&gt;out );
43 	}
44 	if( tree-&gt;container ) { 
45 		if( !gsf_output_is_closed( tree-&gt;container ) &amp;&amp; 
46 			!gsf_output_close( tree-&gt;container ) ) {
47 			vips_error( "vips_gsf", 
48 				"%s", _( "unable to close stream" ) ); 
49 			return( tree );
50 		}
51 		VIPS_UNREF( tree-&gt;container );
52 	}
53 	VIPS_FREEF( g_slist_free, tree-&gt;children );
54 	VIPS_FREE( tree-&gt;name );
55 	VIPS_FREE( tree );
56 	return( NULL ); 
57 }
58 static VipsGsfDirectory *
59 vips_gsf_tree_new( GsfOutput *out, gint deflate_level )
60 {
61 	VipsGsfDirectory *tree = g_new( VipsGsfDirectory, 1 );
62 	tree-&gt;parent = NULL;
63 	tree-&gt;name = NULL;
64 	tree-&gt;children = NULL;
65 	tree-&gt;out = out;
66 	tree-&gt;container = NULL;
67 	tree-&gt;file_count = 0;
68 	tree-&gt;filename_lengths = 0;
69 	tree-&gt;deflate_level = deflate_level;
70 	return( tree ); 
71 }
72 static void *
73 vips_gsf_child_by_name_sub( VipsGsfDirectory *dir, const char *name, void *b )
74 {
75 	if( strcmp( dir-&gt;name, name ) == 0 )
76 		return( dir );
77 	return( NULL ); 
78 }
79 static VipsGsfDirectory *
80 vips_gsf_child_by_name( VipsGsfDirectory *dir, const char *name )
81 {
82 	return( vips_slist_map2( dir-&gt;children, 
83 		(VipsSListMap2Fn) vips_gsf_child_by_name_sub, 
84 		(char *) name, NULL ) );
85 }
86 static VipsGsfDirectory *
87 vips_gsf_dir_new( VipsGsfDirectory *parent, const char *name )
88 {
89 	VipsGsfDirectory *dir = g_new( VipsGsfDirectory, 1 );
90 	g_assert( !vips_gsf_child_by_name( parent, name ) ); 
91 	dir-&gt;parent = parent;
92 	dir-&gt;name = g_strdup( name );
93 	dir-&gt;children = NULL;
94 	dir-&gt;container = NULL;
95 	dir-&gt;file_count = 0;
96 	dir-&gt;filename_lengths = 0;
97 	dir-&gt;deflate_level = parent-&gt;deflate_level;
98 	if( GSF_IS_OUTFILE_ZIP( parent-&gt;out ) )
99 		dir-&gt;out = gsf_outfile_new_child_full( 
100 			(GsfOutfile *) parent-&gt;out, 
101 			name, TRUE,
102 			"compression-level", GSF_ZIP_STORED,
103 			NULL );
104 	else
105 		dir-&gt;out = gsf_outfile_new_child( 
106 			(GsfOutfile *) parent-&gt;out, 
107 			name, TRUE ); 
108 	g_assert( dir-&gt;out ); 
109 	parent-&gt;children = g_slist_prepend( parent-&gt;children, dir ); 
110 	return( dir ); 
111 }
112 static GsfOutput *
113 vips_gsf_path( VipsGsfDirectory *tree, const char *name, ... )
114 {
115 	va_list ap;
116 	VipsGsfDirectory *dir;
117 	VipsGsfDirectory *child;
118 	char *dir_name;
119 	GsfOutput *obj;
120 	tree-&gt;file_count += 1;
121 	tree-&gt;filename_lengths += 
122 		strlen( tree-&gt;out-&gt;name ) + strlen( name ) + 1;
123 	dir = tree; 
124 	va_start( ap, name );
125 	while( (dir_name = va_arg( ap, char * )) ) {
126 		if( (child = vips_gsf_child_by_name( dir, dir_name )) )
127 			dir = child;
128 		else 
129 			dir = vips_gsf_dir_new( dir, dir_name );
130 		tree-&gt;filename_lengths += strlen( dir_name ) + 1;
131 	}
132 	va_end( ap );
133 	if( GSF_IS_OUTFILE_ZIP( dir-&gt;out ) ) {
134 		if( dir-&gt;deflate_level == 0 )
135 			obj = gsf_outfile_new_child_full(
136 				(GsfOutfile *) dir-&gt;out,
137 				name, FALSE,
138 				"compression-level", GSF_ZIP_STORED,
139 				NULL );
140 		else if( dir-&gt;deflate_level == -1 )
141 			obj = gsf_outfile_new_child_full(
142 				(GsfOutfile *) dir-&gt;out,
143 				name, FALSE,
144 				"compression-level", GSF_ZIP_DEFLATED,
145 				NULL );
146 		else
147 			obj = gsf_outfile_new_child_full(
148 				(GsfOutfile *) dir-&gt;out,
149 				name, FALSE,
150 				"compression-level", GSF_ZIP_DEFLATED,
151 				"deflate-level", dir-&gt;deflate_level,
152 				NULL );
153 	}
154 	else
155 		obj = gsf_outfile_new_child( (GsfOutfile *) dir-&gt;out,
156 			name, FALSE ); 
157 	return( obj ); 
158 }
159 typedef struct _VipsForeignSaveDz VipsForeignSaveDz;
160 typedef struct _Layer Layer;
161 struct _Layer {
162 	VipsForeignSaveDz *dz;
163 	int width;
164 	int height;
165 	int tiles_across;
166 	int tiles_down;
167 	VipsRect real_pixels; 
168 	VipsImage *image;
169 	int y;
170 	int write_y;
171 	VipsRegion *strip;			VipsRegion *copy;		
172 	int sub;				int n;				
173 	Layer *below;				Layer *above;			};
174 struct _VipsForeignSaveDz {
175 	VipsForeignSave parent_object;
176 	char *suffix;
177 	int overlap;
178 	int tile_size;
179 	VipsForeignDzLayout layout;
180 	VipsForeignDzDepth depth;
181 	gboolean centre;
182 	gboolean properties;
183 	VipsAngle angle;
184 	VipsForeignDzContainer container; 
185 	int compression;
186 	VipsRegionShrink region_shrink;
187 	int skip_blanks;
188 	gboolean no_strip;
189 	char *id;
190 	int tile_margin;
191 	int tile_step;
192 	Layer *layer;			
193 	int tile_count;
194 	VipsGsfDirectory *tree;
195 	GsfOutput *out;
196 	char *basename; 
197 	char *dirname; 
198 	char *tempdir;
199 	char *root_name; 
200 	char *file_suffix;
201 	size_t bytes_written;
202 	VipsPel *ink;
203 };
204 typedef VipsForeignSaveClass VipsForeignSaveDzClass;
205 G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveDz, vips_foreign_save_dz, 
206 	VIPS_TYPE_FOREIGN_SAVE );
207 static gboolean
208 iszip( VipsForeignDzContainer container )
209 {
210 	switch( container ) {
211 	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
212 	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
213 		return( TRUE );
214 	default:
215 		return( FALSE );
216 	}
217 }
218 #define VIPS_ZIP_FIXED_LH_SIZE (30 + 29)
219 #define VIPS_ZIP_FIXED_CD_SIZE (46 + 9)
220 #define VIPS_ZIP_EOCD_SIZE 22
221 #ifndef HAVE_GSF_ZIP64
222 static size_t
223 estimate_zip_size( VipsForeignSaveDz *dz )
224 {
225 	size_t estimated_zip_size = dz-&gt;bytes_written +
226 		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_LH_SIZE +
227 		dz-&gt;tree-&gt;filename_lengths +
228 		dz-&gt;tree-&gt;file_count * VIPS_ZIP_FIXED_CD_SIZE +
229 		dz-&gt;tree-&gt;filename_lengths +
230 		VIPS_ZIP_EOCD_SIZE;
231 #ifdef DEBUG_VERBOSE
232 	printf( "estimate_zip_size: %zd\n", estimated_zip_size );
233 	return( estimated_zip_size );
234 }
235 static int
236 write_image( VipsForeignSaveDz *dz,
237 	GsfOutput *out, VipsImage *image, const char *format )
238 {
239 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz );
240 	VipsImage *t;
241 	void *buf;
242 	size_t len;
243 	if( vips_copy( image, &amp;t, NULL ) ) 
244 		return( -1 );
245 	vips_image_set_int( t, "hide-progress", 1 );
246 	if( vips_image_write_to_buffer( t, format, &amp;buf, &amp;len,
247 		"strip", !dz-&gt;no_strip,
248 		NULL ) ) {
249 		VIPS_UNREF( t );
250 		return( -1 );
251 	}
252 	VIPS_UNREF( t );
253 	g_mutex_lock( vips__global_lock );
254 	if( !gsf_output_write( out, len, buf ) ) {
255 		gsf_output_close( out );
256 		g_mutex_unlock( vips__global_lock );
257 		g_free( buf );
258 		vips_error( class-&gt;nickname,
259 			"%s", gsf_output_error( out )-&gt;message );
260 		return( -1 );
261 	}
262 	dz-&gt;bytes_written += len;
263 	gsf_output_close( out );
264 #ifndef HAVE_GSF_ZIP64
265 	if( iszip( dz-&gt;container ) ) {
266 		if( dz-&gt;tree-&gt;file_count + 3 &gt;= (unsigned int) USHRT_MAX ) {
267 			g_mutex_unlock( vips__global_lock );
268 			vips_error( class-&gt;nickname,
269 				"%s", _( "too many files in zip" ) );
270 			return( -1 );
271 		}
272 		if( estimate_zip_size( dz ) &gt; (size_t) UINT_MAX - 16384) {
273 			g_mutex_unlock( vips__global_lock );
274 			vips_error( class-&gt;nickname,
275 				"%s", _( "output file too large" ) ); 
276 			return( -1 ); 
277 		}
278 	}
279 	g_mutex_unlock( vips__global_lock );
280 	g_free( buf );
281 	return( 0 );
282 }
283 static void
284 layer_free( Layer *layer )
285 {
286 	VIPS_FREEF( g_object_unref, layer-&gt;strip );
287 	VIPS_FREEF( g_object_unref, layer-&gt;copy );
288 	VIPS_FREEF( g_object_unref, layer-&gt;image );
289 	VIPS_FREEF( layer_free, layer-&gt;below ); 
290 }
291 static void
292 vips_foreign_save_dz_dispose( GObject *gobject )
293 {
294 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) gobject;
295 	VIPS_FREEF( layer_free, dz-&gt;layer );
296 	VIPS_FREEF( vips_gsf_tree_close,  dz-&gt;tree );
297 	VIPS_FREEF( g_object_unref, dz-&gt;out );
298 	VIPS_FREE( dz-&gt;basename );
299 	VIPS_FREE( dz-&gt;dirname );
300 	VIPS_FREE( dz-&gt;tempdir );
301 	VIPS_FREE( dz-&gt;root_name );
302 	VIPS_FREE( dz-&gt;file_suffix );
303 	G_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
304 		dispose( gobject );
305 }
306 static Layer *
307 pyramid_build( VipsForeignSaveDz *dz, Layer *above, 
308 	int width, int height, VipsRect *real_pixels )
309 {
310 	VipsForeignSave *save = VIPS_FOREIGN_SAVE( dz );
311 	Layer *layer = VIPS_NEW( dz, Layer );
312 	VipsRect strip;
313 	int limit; 
314 	layer-&gt;dz = dz;
315 	layer-&gt;width = width;
316 	layer-&gt;height = height;
317 	layer-&gt;tiles_across = VIPS_ROUND_UP( width, dz-&gt;tile_step ) / 
318 		dz-&gt;tile_step;
319 	layer-&gt;tiles_down = VIPS_ROUND_UP( height, dz-&gt;tile_step ) / 
320 		dz-&gt;tile_step;
321 	layer-&gt;real_pixels = *real_pixels; 
322 	layer-&gt;image = NULL;
323 	layer-&gt;strip = NULL;
324 	layer-&gt;copy = NULL;
325 	if( !above )
326 		layer-&gt;sub = 1;	
327 	else
328 		layer-&gt;sub = above-&gt;sub * 2;
329 	layer-&gt;below = NULL;
330 	layer-&gt;above = above;
331 	layer-&gt;image = vips_image_new();
332 	if( vips_image_pipelinev( layer-&gt;image, 
333 		VIPS_DEMAND_STYLE_ANY, save-&gt;ready, NULL ) ) {
334 		layer_free( layer );
335 		return( NULL );
336 	}
337 	layer-&gt;image-&gt;Xsize = width + (width &amp; 1);
338 	layer-&gt;image-&gt;Ysize = height + (height &amp; 1);
339 	layer-&gt;strip = vips_region_new( layer-&gt;image );
340 	layer-&gt;copy = vips_region_new( layer-&gt;image );
341 	vips__region_no_ownership( layer-&gt;strip );
342 	vips__region_no_ownership( layer-&gt;copy );
343 	layer-&gt;y = 0;
344 	layer-&gt;write_y = 0;
345 	strip.left = 0;
346 	strip.top = 0;
347 	strip.width = layer-&gt;image-&gt;Xsize;
348 	strip.height = dz-&gt;tile_size + dz-&gt;tile_margin;
349 	if( (strip.height &amp; 1) == 1 )
350 		strip.height += 1;
351 	if( vips_region_buffer( layer-&gt;strip, &amp;strip ) ) {
352 		layer_free( layer );
353 		return( NULL );
354 	}
355 	switch( dz-&gt;depth ) {
356 	case VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL:
357 		limit = 1;
358 		break;
359 	case VIPS_FOREIGN_DZ_DEPTH_ONETILE:
360 		limit = dz-&gt;tile_size;
361 		break;
362 	case VIPS_FOREIGN_DZ_DEPTH_ONE:
363 		limit = VIPS_MAX( width, height );
364 		break;
365 	default:
366 		g_assert_not_reached();
367 		limit = 1;
368 	}
369 	if( width &gt; limit || 
370 		height &gt; limit ) {
371 		VipsRect halfrect;
372 		halfrect.left = real_pixels-&gt;left / 2;
373 		halfrect.top = real_pixels-&gt;top / 2;
374 		halfrect.width = (VIPS_RECT_RIGHT( real_pixels ) + 1) / 2 - 
375 			halfrect.left;
376 		halfrect.height = (VIPS_RECT_BOTTOM( real_pixels ) + 1) / 2 - 
377 			halfrect.top;
378 		if( !(layer-&gt;below = pyramid_build( dz, layer, 
379 			(width + 1) / 2, (height + 1) / 2,
380 			&amp;halfrect )) ) { 
381 			layer_free( layer );
382 			return( NULL );
383 		}
384 		layer-&gt;n = layer-&gt;below-&gt;n + 1;
385 	}
386 	else
387 		layer-&gt;n = 0;
388 #ifdef DEBUG
389 	printf( "pyramid_build:\n" );
390 	printf( "\tn = %d\n", layer-&gt;n );
391 	printf( "\twidth = %d, height = %d\n", width, height );
392 	printf( "\tXsize = %d, Ysize = %d\n", 
393 		layer-&gt;image-&gt;Xsize, layer-&gt;image-&gt;Ysize );
394 	printf( "\ttiles_across = %d, tiles_down = %d\n", 
395 		layer-&gt;tiles_across, layer-&gt;tiles_down ); 
396 	printf( "\treal_pixels.left = %d, real_pixels.top = %d\n", 
397 		real_pixels-&gt;left, real_pixels-&gt;top ); 
398 	printf( "\treal_pixels.width = %d, real_pixels.height = %d\n", 
399 		real_pixels-&gt;width, real_pixels-&gt;height ); 
400 	return( layer );
401 }
402 static int
403 write_dzi( VipsForeignSaveDz *dz )
404 {
405 	GsfOutput *out;
406 	char buf[VIPS_PATH_MAX];
407 	char *p;
408 	vips_snprintf( buf, VIPS_PATH_MAX, "%s.dzi", dz-&gt;basename );
409 	out = vips_gsf_path( dz-&gt;tree, buf, NULL ); 
410 	vips_snprintf( buf, VIPS_PATH_MAX, "%s", dz-&gt;suffix + 1 );
411 	if( (p = (char *) vips__find_rightmost_brackets( buf )) )
412 		*p = '\0';
413 	gsf_output_printf( out, "&lt;?xml "
414 		"version=\"1.0\" encoding=\"UTF-8\"?&gt;\n" ); 
415 	gsf_output_printf( out, "&lt;Image "
416 		"xmlns=\"http://schemas.microsoft.com/deepzoom/2008\"\n" );
417 	gsf_output_printf( out, "  Format=\"%s\"\n", buf );
418 	gsf_output_printf( out, "  Overlap=\"%d\"\n", dz-&gt;overlap );
419 	gsf_output_printf( out, "  TileSize=\"%d\"\n", dz-&gt;tile_size );
420 	gsf_output_printf( out, "  &gt;\n" ); 
421 	gsf_output_printf( out, "  &lt;Size \n" );
422 	gsf_output_printf( out, "    Height=\"%d\"\n", dz-&gt;layer-&gt;height );
423 	gsf_output_printf( out, "    Width=\"%d\"\n", dz-&gt;layer-&gt;width );
424 	gsf_output_printf( out, "  /&gt;\n" ); 
425 	gsf_output_printf( out, "&lt;/Image&gt;\n" );
426 	(void) gsf_output_close( out );
427 	g_object_unref( out );
428 	return( 0 );
429 }
430 static int
431 write_properties( VipsForeignSaveDz *dz )
432 {
433 	GsfOutput *out;
434 	out = vips_gsf_path( dz-&gt;tree, "ImageProperties.xml", NULL ); 
435 	gsf_output_printf( out, "&lt;IMAGE_PROPERTIES "
436 		"WIDTH=\"%d\" HEIGHT=\"%d\" NUMTILES=\"%d\" "
437 		"NUMIMAGES=\"1\" VERSION=\"1.8\" TILESIZE=\"%d\" /&gt;\n",
438 		dz-&gt;layer-&gt;width,
439 		dz-&gt;layer-&gt;height,
440 		dz-&gt;tile_count,
441 		dz-&gt;tile_size );
442 	(void) gsf_output_close( out );
443 	g_object_unref( out );
444 	return( 0 );
445 }
446 static int
447 write_blank( VipsForeignSaveDz *dz )
448 {
449 	VipsForeignSave *save = (VipsForeignSave *) dz;
450 	VipsImage *x, *t;
451 	int n;
452 	VipsArea *ones;
453 	double *d;
454 	double *bg;
455 	int i;
456 	GsfOutput *out; 
457 	bg = (double *) vips_area_get_data( VIPS_AREA( save-&gt;background ), 
458 		NULL, &amp;n, NULL, NULL );
459 	if( vips_black( &amp;x, dz-&gt;tile_size, dz-&gt;tile_size, "bands", n, NULL ) ) 
460 		return( -1 );
461 	ones = vips_area_new_array( G_TYPE_DOUBLE, sizeof( double ), n );
462 	d = (double *) vips_area_get_data( ones, NULL, NULL, NULL, NULL );
463 	for( i = 0; i &lt; n; i++ )
464 		d[i] = 1.0; 
465 	if( vips_linear( x, &amp;t, d, bg, n, NULL ) ) {
466 		vips_area_unref( ones );
467 		g_object_unref( x );
468 		return( -1 );
469 	}
470 	vips_area_unref( ones );
471 	g_object_unref( x );
472 	x = t;
473 	out = vips_gsf_path( dz-&gt;tree, "blank.png", NULL ); 
474 	if( write_image( dz, out, x, ".png" ) ) {
475 		g_object_unref( out );
476 		g_object_unref( x );
477 		return( -1 );
478 	}
479 	g_object_unref( out );
480 	g_object_unref( x );
481 	return( 0 );
482 }
483 static int
484 write_json( VipsForeignSaveDz *dz )
485 {
486 	const char *name = dz-&gt;basename ? dz-&gt;basename : "untitled";
487 	const char *suffix = dz-&gt;file_suffix[0] == '.' ? 
488 		dz-&gt;file_suffix + 1 : dz-&gt;file_suffix;
489 	GsfOutput *out;
490 	int i;
491 	out = vips_gsf_path( dz-&gt;tree, "info.json", NULL ); 
492 	gsf_output_printf( out, 
493 		"{\n"
494 		"  \"@context\": \"http://iiif.io/api/image/2/context.json\",\n"
495 		"  \"@id\": \"%s/%s\",\n" 
496 		"  \"profile\": [\n"
497 		"    \"http://iiif.io/api/image/2/level0.json\",\n"
498 		"    {\n" 
499 		"      \"formats\": [\n"
500 		"        \"%s\"\n"
501 		"      ],\n"
502 		"      \"qualities\": [\n"
503 		"        \"default\"\n"
504 		"      ]\n"
505 		"    }\n"
506 		"  ],\n"
507 		"  \"protocol\": \"http://iiif.io/api/image\",\n", 
508 		dz-&gt;id ? dz-&gt;id : "https://example.com/iiif",
509 		name, 
510 		suffix );
511 	gsf_output_printf( out, 
512 		"  \"tiles\": [\n"
513 		"    {\n"
514 		"      \"scaleFactors\": [\n" );
515 	for( i = 0; i &lt; dz-&gt;layer-&gt;n; i++ ) {
516 		gsf_output_printf( out, 
517 			"        %d",
518 				1 &lt;&lt; i );
519 		if( i != dz-&gt;layer-&gt;n - 1 )
520 			gsf_output_printf( out, "," );
521 		gsf_output_printf( out, "\n" );
522 	}
523 	gsf_output_printf( out, 
524 		"      ],\n"
525 		"      \"width\": %d\n"
526 		"    }\n"
527 		"  ],\n", dz-&gt;tile_size );
528 	gsf_output_printf( out, 
529 		"  \"width\": %d,\n"
530 		"  \"height\": %d\n", 
531 			dz-&gt;layer-&gt;width,
532 			dz-&gt;layer-&gt;height );
533 	gsf_output_printf( out, 
534 		"}\n" );
535 	(void) gsf_output_close( out );
536 	g_object_unref( out );
537 	return( 0 );
538 }
539 static int
540 write_vips_meta( VipsForeignSaveDz *dz )
541 {
542 	VipsForeignSave *save = (VipsForeignSave *) dz;
543 	char *dump;
544 	GsfOutput *out;
545 	if( !(dump = vips__xml_properties( save-&gt;ready )) )
546                 return( -1 );
547 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
548 		out = vips_gsf_path( dz-&gt;tree, 
549 			"vips-properties.xml", dz-&gt;root_name, NULL );
550 	else
551 		out = vips_gsf_path( dz-&gt;tree, "vips-properties.xml", NULL );
552 	gsf_output_write( out, strlen( dump ), (guchar *) dump ); 
553 	(void) gsf_output_close( out );
554 	g_object_unref( out );
555 	g_free( dump );
556 	return( 0 );
557 }
558 static void
559 build_scan_property( VipsDbuf *dbuf, VipsImage *image, 
560 	const char *vips_name, const char *szi_name )
561 {
562 	const char *str;
563 	GValue value = { 0 };
564 	GValue save_value = { 0 };
565 	GType type;
566 	if( !vips_image_get_typeof( image, vips_name ) )
567 		return;
568 	if( vips_image_get( image, vips_name, &amp;value ) )
569 		return;
570 	type = G_VALUE_TYPE( &amp;value );
571 	if( !g_value_type_transformable( type, VIPS_TYPE_SAVE_STRING ) ) {
572 		g_value_unset( &amp;value );
573 		return;
574 	}
575 	g_value_init( &amp;save_value, VIPS_TYPE_SAVE_STRING );
576 	if( !g_value_transform( &amp;value, &amp;save_value ) ) {
577 		g_value_unset( &amp;value );
578 		return;
579 	}
580 	g_value_unset( &amp;value );
581 	if( !(str = vips_value_get_save_string( &amp;save_value )) ) {
582 		g_value_unset( &amp;save_value );
583 		return;
584 	}
585 	if( !g_utf8_validate( str, -1, NULL ) ) {
586 		g_value_unset( &amp;save_value );
587 		return;
588 	}
589 	vips_dbuf_writef( dbuf, "    &lt;property&gt;\n" );
590 	vips_dbuf_writef( dbuf, "      &lt;name&gt;" );
591 	vips_dbuf_write_amp( dbuf, szi_name );
592 	vips_dbuf_writef( dbuf, "&lt;/name&gt;\n" );
593 	vips_dbuf_writef( dbuf, "      &lt;value type=\"%s\"&gt;",
594 		g_type_name( type )  );
595 	vips_dbuf_write_amp( dbuf, str );
596 	vips_dbuf_writef( dbuf, "&lt;/value&gt;\n" );
597 	vips_dbuf_writef( dbuf, "    &lt;/property&gt;\n" );
598 	g_value_unset( &amp;save_value );
599 }
600 static char *scan_property_names[][2] = {
601 	{ "openslide.vendor", "Vendor" },
602 	{ "openslide.objective-power", "ObjectiveMagnification" },
603 	{ "openslide.mpp-x", "MicronsPerPixelX" },
604 	{ "openslide.mpp-y", "MicronsPerPixelY" },
605 	{ "width", "ImageWidth" },
606 	{ "height", "ImageHeight" }
607 };
608 char *
609 build_scan_properties( VipsImage *image )
610 {
611 	VipsDbuf dbuf;
612 	char *date;
613 	int i;
614 	date = vips__get_iso8601();
615 	vips_dbuf_init( &amp;dbuf );
616 	vips_dbuf_writef( &amp;dbuf, "&lt;?xml version=\"1.0\"?&gt;\n" ); 
617 	vips_dbuf_writef( &amp;dbuf, "&lt;image xmlns=\"http://www.pathozoom.com/szi\""
618 		" date=\"%s\" version=\"1.0\"&gt;\n", date );
619 	vips_dbuf_writef( &amp;dbuf, "  &lt;properties&gt;\n" );  
620 	g_free( date ); 
621 	for( i = 0; i &lt; VIPS_NUMBER( scan_property_names ); i++ )
622 		build_scan_property( &amp;dbuf, image,
623 			scan_property_names[i][0],
624 			scan_property_names[i][1] );
625 	vips_dbuf_writef( &amp;dbuf, "  &lt;/properties&gt;\n" );
626 	vips_dbuf_writef( &amp;dbuf, "&lt;/image&gt;\n" );
627 	return( (char *) vips_dbuf_steal( &amp;dbuf, NULL ) ); 
628 }
629 static int
630 write_scan_properties( VipsForeignSaveDz *dz )
631 {
632 	VipsForeignSave *save = (VipsForeignSave *) dz;
633 	char *dump;
634 	GsfOutput *out;
635 	if( !(dump = build_scan_properties( save-&gt;ready )) )
636                 return( -1 );
637 	out = vips_gsf_path( dz-&gt;tree, "scan-properties.xml", NULL );
638 	gsf_output_write( out, strlen( dump ), (guchar *) dump );
639 	(void) gsf_output_close( out );
640 	g_object_unref( out );
641 	g_free( dump );
642 	return( 0 );
643 }
644 static void *
645 write_associated_images( VipsImage *image,
646 	const char *field, GValue *value, void *a )
647 {
648 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
649 	if( vips_isprefix( "openslide.associated.", field ) ) {
650 		VipsImage *associated;
651 		const char *p;
652 		const char *q;
653 		GsfOutput *out;
654 		char buf[VIPS_PATH_MAX];
655 		p = field + strlen( "openslide.associated." );
656 		if( (q = strrchr( p, '/' )) )
657 			p = q + 1;
658 		if( vips_image_get_image( image, field, &amp;associated ) )
659 			return( image );
660 		vips_snprintf( buf, VIPS_PATH_MAX, "%s.jpg", p );
661 		out = vips_gsf_path( dz-&gt;tree, buf, "associated_images", NULL );
662 		if( write_image( dz, out, associated, ".jpg" ) ) {
663 			g_object_unref( out );
664 			g_object_unref( associated );
665 			return( image );
666 		}
667 		g_object_unref( out );
668 		g_object_unref( associated );
669 	}
670 	return( NULL );
671 }
672 static int
673 write_associated( VipsForeignSaveDz *dz )
674 {
675 	VipsForeignSave *save = (VipsForeignSave *) dz;
676 	if( vips_image_map( save-&gt;ready, write_associated_images, dz ) )
677 		return( -1 );
678 	return( 0 );
679 }
680 typedef struct _Strip {
681 	Layer *layer; 
682 	VipsImage *image;
683 	int x;
684 } Strip;
685 static void
686 strip_free( Strip *strip )
687 {
688 	g_object_unref( strip-&gt;image );
689 }
690 static void
691 strip_init( Strip *strip, Layer *layer )
692 {
693 	VipsForeignSaveDz *dz = layer-&gt;dz;
694 	VipsRect line, image;
695 	strip-&gt;layer = layer;
696 	strip-&gt;image = NULL;
697 	strip-&gt;x = 0;
698 	image.left = 0;
699 	image.top = 0;
700 	image.width = layer-&gt;image-&gt;Xsize;
701 	image.height = layer-&gt;height;
702 	line.left = 0;
703 	line.top = layer-&gt;y;
704 	line.width = image.width;
705 	line.height = dz-&gt;tile_size;
706 	vips_rect_marginadjust( &amp;line, dz-&gt;tile_margin );
707 	vips_rect_intersectrect( &amp;image, &amp;line, &amp;line );
708 	if( !(strip-&gt;image = vips_image_new_from_memory( 
709 		VIPS_REGION_ADDR( layer-&gt;strip, 0, line.top ),
710 		VIPS_IMAGE_SIZEOF_LINE( layer-&gt;image ) * line.height,
711 		line.width, line.height, 
712 		layer-&gt;image-&gt;Bands, layer-&gt;image-&gt;BandFmt )) ) {
713 		strip_free( strip );
714 		return;
715 	}
716 	if( vips__image_meta_copy( strip-&gt;image, layer-&gt;image ) ) {
717 		strip_free( strip );
718 		return;
719 	}
720 	strip-&gt;image-&gt;Type = layer-&gt;image-&gt;Type;
721 }
722 static int
723 strip_allocate( VipsThreadState *state, void *a, gboolean *stop )
724 {
725 	Strip *strip = (Strip *) a;
726 	Layer *layer = strip-&gt;layer;
727 	VipsForeignSaveDz *dz = layer-&gt;dz;
728 	VipsRect image;
729 #ifdef DEBUG_VERBOSE
730 	printf( "strip_allocate\n" );
731 	if( strip-&gt;x / dz-&gt;tile_step &gt;= layer-&gt;tiles_across ) {
732 		*stop = TRUE;
733 #ifdef DEBUG_VERBOSE
734 		printf( "strip_allocate: done\n" );
735 		return( 0 );
736 	}
737 	image.left = 0;
738 	image.top = 0;
739 	image.width = layer-&gt;width;
740 	image.height = layer-&gt;height;
741 	state-&gt;pos.left = strip-&gt;x;
742 	state-&gt;pos.top = layer-&gt;y;
743 	state-&gt;pos.width = dz-&gt;tile_size;
744 	state-&gt;pos.height = dz-&gt;tile_size;
745 	vips_rect_marginadjust( &amp;state-&gt;pos, dz-&gt;tile_margin );
746 	vips_rect_intersectrect( &amp;image, &amp;state-&gt;pos, &amp;state-&gt;pos );
747 	state-&gt;x = strip-&gt;x;
748 	state-&gt;y = layer-&gt;y;
749 	strip-&gt;x += dz-&gt;tile_step;
750 	return( 0 );
751 }
752 static GsfOutput *
753 tile_name( Layer *layer, int x, int y )
754 {
755 	VipsForeignSaveDz *dz = layer-&gt;dz;
756 	VipsForeignSave *save = (VipsForeignSave *) dz;
757 	GsfOutput *out; 
758 	char name[VIPS_PATH_MAX];
759 	char dirname[VIPS_PATH_MAX];
760 	char dirname2[VIPS_PATH_MAX];
761 	Layer *p;
762 	int n;
763 	switch( dz-&gt;layout ) {
764 	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
765 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
766 		vips_snprintf( name, VIPS_PATH_MAX, 
767 			"%d_%d%s", x, y, dz-&gt;file_suffix );
768 		out = vips_gsf_path( dz-&gt;tree, name, 
769 			dz-&gt;root_name, dirname, NULL );
770 		break;
771 	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
772 		n = 0;
773 		for( p = layer-&gt;below; p; p = p-&gt;below )
774 			n += p-&gt;tiles_across * p-&gt;tiles_down;
775 		n += y * layer-&gt;tiles_across + x;
776 		vips_snprintf( dirname, VIPS_PATH_MAX, "TileGroup%d", n / 256 );
777 		vips_snprintf( name, VIPS_PATH_MAX, 
778 			"%d-%d-%d%s", layer-&gt;n, x, y, dz-&gt;file_suffix );
779 		dz-&gt;tile_count += 1;
780 		out = vips_gsf_path( dz-&gt;tree, name, dirname, NULL );
781 		break;
782 	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
783 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d", layer-&gt;n );
784 		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d", y );
785 		vips_snprintf( name, VIPS_PATH_MAX, 
786 			"%d%s", x, dz-&gt;file_suffix );
787 		out = vips_gsf_path( dz-&gt;tree, name, dirname, dirname2, NULL );
788 		break;
789 	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
790 {
791 		int left = x * dz-&gt;tile_size * layer-&gt;sub;
792 		int top = y * dz-&gt;tile_size * layer-&gt;sub;
793 		int width = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
794 			save-&gt;ready-&gt;Xsize - left );
795 		int height = VIPS_MIN( dz-&gt;tile_size * layer-&gt;sub, 
796 			save-&gt;ready-&gt;Ysize - top );
797 		int size = VIPS_MIN( dz-&gt;tile_size, 
798 			layer-&gt;width - x * dz-&gt;tile_size );
799 		vips_snprintf( dirname, VIPS_PATH_MAX, "%d,%d,%d,%d",
800 			left, top, width, height );
801 		vips_snprintf( dirname2, VIPS_PATH_MAX, "%d,", size );
802 		vips_snprintf( name, VIPS_PATH_MAX, "default%s", 
803 			dz-&gt;file_suffix );
804 		out = vips_gsf_path( dz-&gt;tree, 
805 			name, dirname, dirname2, "0", NULL );
806 }
807 		break;
808 	default:
809 		g_assert_not_reached();
810 		out = NULL;
811 	}
812 #ifdef DEBUG_VERBOSE
813 	printf( "tile_name: writing to %s\n", name );
814 	return( out );
815 }
816 static gboolean
817 tile_equal( VipsImage *image, int threshold, VipsPel * restrict ink )
818 {
819 	const int bytes = VIPS_IMAGE_SIZEOF_PEL( image );
820 	VipsRect rect;
821 	VipsRegion *region;
822 	int x, y, b;
823 	region = vips_region_new( image ); 
824 	rect.left = 0;
825 	rect.top = 0;
826 	rect.width = image-&gt;Xsize;
827 	rect.height = image-&gt;Ysize;
828 	if( vips_region_prepare( region, &amp;rect ) ) {
829 		g_object_unref( region );
830 		return( FALSE ); 
831 	}
832 	for( y = 0; y &lt; image-&gt;Ysize; y++ ) {
833 		VipsPel * restrict p = VIPS_REGION_ADDR( region, 0, y ); 
834 		for( x = 0; x &lt; image-&gt;Xsize; x++ ) {
835 			for( b = 0; b &lt; bytes; b++ ) 
836 				if( VIPS_ABS( p[b] - ink[b] ) &gt; threshold ) {
837 					g_object_unref( region );
838 					return( FALSE ); 
839 				}
840 			p += bytes;
841 		}
842 	}
843 	g_object_unref( region );
844 	return( TRUE );
845 }
846 static int
847 strip_work( VipsThreadState *state, void *a )
848 {
849 	Strip *strip = (Strip *) a;
850 	Layer *layer = strip-&gt;layer;
851 	VipsForeignSaveDz *dz = layer-&gt;dz;
852 	VipsForeignSave *save = (VipsForeignSave *) dz;
853 	VipsImage *x;
854 	VipsImage *t;
855 	GsfOutput *out; 
856 #ifdef DEBUG_VERBOSE
857 	printf( "strip_work\n" );
858 	if( dz-&gt;centre ) {
859 		VipsRect tile; 
860 		tile.left = state-&gt;x;
861 		tile.top = state-&gt;y;
862 		tile.width = dz-&gt;tile_size;
863 		tile.height = dz-&gt;tile_size;
864 		if( !vips_rect_overlapsrect( &amp;tile, &amp;layer-&gt;real_pixels ) ) {
865 #ifdef DEBUG_VERBOSE
866 			printf( "strip_work: skipping tile %d x %d\n", 
867 				state-&gt;x / dz-&gt;tile_size, 
868 				state-&gt;y / dz-&gt;tile_size ); 
869 			return( 0 ); 
870 		}
871 	}
872 	g_assert( vips_object_sanity( VIPS_OBJECT( strip-&gt;image ) ) );
873 	if( vips_extract_area( strip-&gt;image, &amp;x, 
874 		state-&gt;pos.left, 0, 
875 		state-&gt;pos.width, state-&gt;pos.height, NULL ) ) 
876 		return( -1 );
877 	if( dz-&gt;skip_blanks &gt;= 0 &amp;&amp;
878 		tile_equal( x, dz-&gt;skip_blanks, dz-&gt;ink ) ) { 
879 		g_object_unref( x );
880 #ifdef DEBUG_VERBOSE
881 		printf( "strip_work: skipping blank tile %d x %d\n", 
882 			state-&gt;x / dz-&gt;tile_size, 
883 			state-&gt;y / dz-&gt;tile_size ); 
884 		return( 0 ); 
885 	}
886 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
887 		if( vips_embed( x, &amp;t, 0, 0, dz-&gt;tile_size, dz-&gt;tile_size,
888 			"background", save-&gt;background,
889 			NULL ) ) {
890 			g_object_unref( x );
891 			return( -1 );
892 		}
893 		g_object_unref( x );
894 		x = t;
895 	}
896 	g_mutex_lock( vips__global_lock );
897 	out = tile_name( layer, 
898 		state-&gt;x / dz-&gt;tile_step, state-&gt;y / dz-&gt;tile_step );
899 	g_mutex_unlock( vips__global_lock );
900 	if( write_image( dz, out, x, dz-&gt;suffix ) ) {
901 		g_object_unref( out );
902 		g_object_unref( x );
903 		return( -1 );
904 	}
905 	g_object_unref( out );
906 	g_object_unref( x );
907 #ifdef DEBUG_VERBOSE
908 	printf( "strip_work: success\n" );
909 	return( 0 );
910 }
911 static int
912 strip_save( Layer *layer )
913 {
914 	Strip strip;
915 #ifdef DEBUG
916 	printf( "strip_save: n = %d, y = %d\n", layer-&gt;n, layer-&gt;y );
917 	strip_init( &amp;strip, layer );
918 	if( vips_threadpool_run( strip.image, 
919 		vips_thread_state_new, strip_allocate, strip_work, NULL, 
920 		&amp;strip ) ) {
921 		strip_free( &amp;strip );
922 		return( -1 );
923 	}
924 	strip_free( &amp;strip );
925 #ifdef DEBUG
926 	printf( "strip_save: success\n" ); 
927 	return( 0 );
928 }
929 static void
930 layer_generate_extras( Layer *layer )
931 {
932 	VipsRegion *strip = layer-&gt;strip;
933 	g_assert( strip-&gt;valid.width == layer-&gt;image-&gt;Xsize );
934 	if( layer-&gt;width &lt; layer-&gt;image-&gt;Xsize ) {
935 		int ps = VIPS_IMAGE_SIZEOF_PEL( strip-&gt;im );
936 		int b, y;
937 		for( y = 0; y &lt; strip-&gt;valid.height; y++ ) {
938 			VipsPel *p = VIPS_REGION_ADDR( strip, 
939 				layer-&gt;width - 1, strip-&gt;valid.top + y );
940 			VipsPel *q = p + ps;
941 			for( b = 0; b &lt; ps; b++ )
942 				q[b] = p[b];
943 		}
944 	}
945 	if( layer-&gt;height &lt; layer-&gt;image-&gt;Ysize ) {
946 		VipsRect last;
947 		last.left = 0;
948 		last.top = layer-&gt;image-&gt;Ysize - 2;
949 		last.width = layer-&gt;image-&gt;Xsize;
950 		last.height = 2;
951 		vips_rect_intersectrect( &amp;last, &amp;strip-&gt;valid, &amp;last );
952 		if( last.height == 2 ) {
953 			last.height = 1;
954 			vips_region_copy( strip, strip, &amp;last, 
955 				0, last.top + 1 );
956 		}
957 	}
958 }
959 static int strip_arrived( Layer *layer );
960 static int
961 strip_shrink( Layer *layer )
962 <a name="0"></a>{
963 	Layer *below = layer-&gt;below;
964 	VipsRegion *from = layer-&gt;strip;
965 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	VipsRegion *to = below-&gt;strip;
966 	VipsForeignSaveDz *dz = layer-&gt;dz;
967 	VipsRegionShrink region_shrink = dz-&gt;region_shrink;
968 	VipsRect target;
969 	VipsRect source;
970 #ifdef DEBUG
971 	printf( "strip_shrink: %d lines in layer %d to layer %d\n", 
972 		from-&gt;valid.height, layer-&gt;n, below-&gt;n ); 
973 	layer_generate_extras( layer );
974 	for(;;) {
975 		target.left = 0;
976 		target.top = below-&gt;write_y;
977 		target.width = below-&gt;image-&gt;Xsize;
978 		target.height = to-&gt;valid.height;
979 		vips_rect_intersectrect( &amp;target, &amp;to-&gt;valid, &amp;target );
980 		source.left = target.left * 2;
981 		source.top = target.top * 2;
982 		source.width = target.width * 2;
983 		source.height = target.height * 2;
984 		vips_rect_intersectrect( &amp;source, &amp;from-&gt;valid, &amp;source );
985 		target.left = source.left / 2;
986 		target.top = source.top / 2;
987 		target.width = source.width / 2;
988 		target.height = source.height / 2;
989 		if( vips_rect_isempty( &amp;target ) )
990 			break;
991 		(void) vips_region_shrink_method( from, to, 
992 			&amp;target, region_shrink );
993 		below-&gt;write_y += target.height;
994 		if( below-&gt;write_y == VIPS_RECT_BOTTOM( &amp;to-&gt;valid ) ||
995 			below-&gt;write_y == below-&gt;height ) {
996 			if( strip_arrived( below ) )
997 				return( -1 );
998 		}
999 	}
1000 	return( 0 );
1001 }
1002 static int
1003 strip_arrived( Layer *layer )
1004 {
1005 	VipsForeignSaveDz *dz = layer-&gt;dz;</b></font>
1006 	VipsRect new_strip;
1007 	VipsRect overlap;
1008 	VipsRect image_area;
1009 #ifdef DEBUG
1010 	printf( "strip_arrived: layer %d, strip at %d, height %d\n", 
1011 <a name="2"></a>		layer-&gt;n, layer-&gt;y, layer-&gt;strip-&gt;valid.height ); 
1012 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( strip_save( layer ) )
1013 		return( -1 );
1014 	if( layer-&gt;below &amp;&amp;
1015 		strip_shrink( layer ) )
1016 		return( -1 );
1017 	layer-&gt;y += dz-&gt;tile_step;
1018 	new_strip.left = 0;
1019 	new_strip.top = layer-&gt;y - dz-&gt;tile_margin;
1020 	new_strip.width = layer-&gt;image-&gt;Xsize;
1021 	new_strip.height = dz-&gt;tile_size + 2 * dz-&gt;tile_margin;
1022 	image_area.left = 0;
1023 	image_area.top = 0;
1024 	image_area.width = layer-&gt;image-&gt;Xsize;
1025 	image_area.height = layer-&gt;image-&gt;Ysize;
1026 	vips_rect_intersectrect( &amp;new_strip, &amp;image_area, &amp;new_strip ); 
1027 	if( (new_strip.height &amp; 1) == 1 )
1028 		new_strip.height += 1;
1029 	if( VIPS_RECT_BOTTOM( &amp;new_strip ) == layer-&gt;height )</b></font>
1030 		new_strip.height = layer-&gt;image-&gt;Ysize - new_strip.top;
1031 	vips_rect_intersectrect( &amp;new_strip, &amp;layer-&gt;strip-&gt;valid, &amp;overlap );
1032 	if( !vips_rect_isempty( &amp;overlap ) ) {
1033 		if( vips_region_buffer( layer-&gt;copy, &amp;overlap ) )
1034 			return( -1 );
1035 		vips_region_copy( layer-&gt;strip, layer-&gt;copy, 
1036 			&amp;overlap, overlap.left, overlap.top );
1037 	}
1038 	if( !vips_rect_isempty( &amp;new_strip ) ) {
1039 		if( vips_region_buffer( layer-&gt;strip, &amp;new_strip ) )
1040 			return( -1 );
1041 		if( !vips_rect_isempty( &amp;overlap ) ) 
1042 			vips_region_copy( layer-&gt;copy, layer-&gt;strip, 
1043 				&amp;overlap, overlap.left, overlap.top );
1044 	}
1045 	return( 0 );
1046 }
1047 static int
1048 strip_flush( Layer *layer )
1049 {
1050 	if( layer-&gt;y &lt; layer-&gt;height )
1051 		if( strip_save( layer ) )
1052 			return( -1 );
1053 	if( layer-&gt;below )
1054 <a name="1"></a>		if( strip_flush( layer-&gt;below ) )
1055 			return( -1 );
1056 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
1057 }
1058 static int
1059 pyramid_strip( VipsRegion *region, VipsRect *area, void *a )
1060 {
1061 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) a;
1062 	Layer *layer = dz-&gt;layer;
1063 #ifdef DEBUG
1064 	printf( "pyramid_strip: strip at %d, height %d\n", 
1065 		area-&gt;top, area-&gt;height );
1066 	for(;;) {
1067 		VipsRect *to = &amp;layer-&gt;strip-&gt;valid;
1068 		VipsRect target;
1069 		target.left = 0;
1070 		target.top = layer-&gt;write_y;
1071 		target.width = layer-&gt;image-&gt;Xsize;
1072 		target.height = to-&gt;height;
1073 		vips_rect_intersectrect( &amp;target, to, &amp;target );
1074 		vips_rect_intersectrect( &amp;target, area, &amp;target );
1075 		if( vips_rect_isempty( &amp;target ) ) 
1076 			break;
1077 		vips_region_copy( region, layer-&gt;strip, 
1078 			&amp;target, target.left, target.top );
1079 		layer-&gt;write_y += target.height;
1080 		if( layer-&gt;write_y == VIPS_RECT_BOTTOM( to ) ||
1081 			layer-&gt;write_y == layer-&gt;height ) {
1082 			if( strip_arrived( layer ) ) 
1083 				return( -1 );
1084 		}
1085 	}</b></font>
1086 	if( layer-&gt;write_y == layer-&gt;height ) {
1087 #ifdef DEBUG
1088 		printf( "pyramid_strip: flushing ..\n" ); 
1089 		if( strip_flush( layer ) )
1090 			return( -1 );
1091 	}
1092 	return( 0 );
1093 }
1094 static int
1095 vips_foreign_save_dz_build( VipsObject *object )
1096 {
1097 	VipsForeignSave *save = (VipsForeignSave *) object;
1098 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1099 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( dz ); 
1100 	VipsRect real_pixels; 
1101 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
1102 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ||
1103 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
1104 		if( !vips_object_argument_isset( object, "overlap" ) )
1105 			dz-&gt;overlap = 0;
1106 		if( !vips_object_argument_isset( object, "suffix" ) )
1107 			VIPS_SETSTR( dz-&gt;suffix, ".jpg" );
1108 	}
1109 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY ||
1110 		dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE ) {
1111 		if( !vips_object_argument_isset( object, "tile_size" ) )
1112 			dz-&gt;tile_size = 256;
1113 	}
1114 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_IIIF ) {
1115 		if( !vips_object_argument_isset( object, "tile_size" ) )
1116 			dz-&gt;tile_size = 512;
1117 	}
1118 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
1119 		!vips_object_argument_isset( object, "skip_blanks" ) )
1120 		dz-&gt;skip_blanks = 5;
1121 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) { 
1122 		dz-&gt;tile_margin = dz-&gt;overlap;
1123 		dz-&gt;tile_step = dz-&gt;tile_size; 
1124 	}
1125 	else {
1126 		dz-&gt;tile_margin = 0;
1127 		dz-&gt;tile_step = dz-&gt;tile_size - dz-&gt;overlap;
1128 	}
1129 	if( dz-&gt;tile_step &lt;= 0 ) {
1130 		vips_error( "dzsave", "%s", _( "overlap too large" ) );
1131 		return( -1 );
1132 	}
1133 	if( !vips_object_argument_isset( object, "background" ) ) {
1134 		VipsArrayDouble *background; 
1135 		background = vips_array_double_newv( 1, 255.0 );
1136 		g_object_set( object, "background", background, NULL );
1137 		vips_area_unref( VIPS_AREA( background ) ); 
1138 	}
1139 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
1140 		if( !vips_object_argument_isset( object, "depth" ) )
1141 			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL;
1142 	}
1143 	else
1144 		if( !vips_object_argument_isset( object, "depth" ) )
1145 			dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONETILE;
1146 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_parent_class )-&gt;
1147 		build( object ) )
1148 		return( -1 );
1149 {
1150 	VipsImage *z;
1151 	if( vips_rot( save-&gt;ready, &amp;z, dz-&gt;angle, NULL ) )
1152 		return( -1 );
1153 	VIPS_UNREF( save-&gt;ready );
1154 	save-&gt;ready = z;
1155 }
1156 	if( dz-&gt;skip_blanks &gt;= 0 ) {
1157 		if( !(dz-&gt;ink = vips__vector_to_ink( 
1158 			class-&gt;nickname, save-&gt;ready,
1159 			VIPS_AREA( save-&gt;background )-&gt;data, NULL, 
1160 			VIPS_AREA( save-&gt;background )-&gt;n )) )
1161 			return( -1 );
1162 	}
1163 	real_pixels.left = 0;
1164 	real_pixels.top = 0;
1165 	real_pixels.width = save-&gt;ready-&gt;Xsize;
1166 	real_pixels.height = save-&gt;ready-&gt;Ysize;
1167 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_GOOGLE &amp;&amp;
1168 		dz-&gt;centre ) {
1169 		VipsImage *z;
1170 		Layer *layer;
1171 		int n_layers;
1172 		int size;
1173 		if( !(layer = pyramid_build( dz, NULL, 
1174 			save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize,
1175 			&amp;real_pixels )) )
1176 			return( -1 );
1177 		n_layers = layer-&gt;n;
1178 		g_assert( n_layers &lt; 30 );
1179 		layer_free( layer );
1180 		size = dz-&gt;tile_size * (1 &lt;&lt; n_layers);
1181 		real_pixels.left = (size - save-&gt;ready-&gt;Xsize) / 2;
1182 		real_pixels.top = (size - save-&gt;ready-&gt;Ysize) / 2;
1183 		if( vips_embed( save-&gt;ready, &amp;z, 
1184 			real_pixels.left, real_pixels.top,
1185 			size, size,
1186 			"background", save-&gt;background,
1187 			NULL ) ) 
1188 			return( -1 );
1189 		VIPS_UNREF( save-&gt;ready );
1190 		save-&gt;ready = z;
1191 #ifdef DEBUG
1192 		printf( "centre: centring within a %d x %d image\n", 
1193 			size, size );
1194 	}
1195 #ifdef DEBUG
1196 	printf( "vips_foreign_save_dz_build: tile_size == %d\n", 
1197 		dz-&gt;tile_size );
1198 	printf( "vips_foreign_save_dz_build: overlap == %d\n", 
1199 		dz-&gt;overlap );
1200 	printf( "vips_foreign_save_dz_build: tile_margin == %d\n", 
1201 		dz-&gt;tile_margin );
1202 	printf( "vips_foreign_save_dz_build: tile_step == %d\n", 
1203 		dz-&gt;tile_step );
1204 	if( !(dz-&gt;layer = pyramid_build( dz, NULL, 
1205 		save-&gt;ready-&gt;Xsize, save-&gt;ready-&gt;Ysize, &amp;real_pixels )) )
1206 		return( -1 );
1207 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ )
1208 		dz-&gt;root_name = g_strdup_printf( "%s_files", dz-&gt;basename );
1209 	else
1210 		dz-&gt;root_name = g_strdup( dz-&gt;basename );
1211 {
1212 	char filename[VIPS_PATH_MAX];
1213 	char option_string[VIPS_PATH_MAX];
1214 	vips__filename_split8( dz-&gt;suffix, filename, option_string );
1215 	dz-&gt;file_suffix = g_strdup( filename ); 
1216 }
1217 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
1218 		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS &amp;&amp;
1219 		dz-&gt;dirname &amp;&amp;
1220 		vips_existsf( "%s/%s_files", dz-&gt;dirname, dz-&gt;basename ) ) {
1221 		vips_error( "dzsave", 
1222 			_( "output directory %s/%s_files exists" ),
1223 			dz-&gt;dirname, dz-&gt;basename );
1224 		return( -1 ); 
1225 	}
1226 	switch( dz-&gt;container ) {
1227 	case VIPS_FOREIGN_DZ_CONTAINER_FS:
1228 		if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ ) {
1229 			char name[VIPS_PATH_MAX];
1230 			int fd;
1231 			GsfOutput *out;
1232 			GError *error = NULL;
1233 			vips_snprintf( name, VIPS_PATH_MAX, "%s-XXXXXX", 
1234 				dz-&gt;basename ); 
1235 			dz-&gt;tempdir = g_build_filename( dz-&gt;dirname, 
1236 				name, NULL );
1237 			if( (fd = g_mkstemp( dz-&gt;tempdir )) == -1 ) {
1238 				vips_error(  class-&gt;nickname,
1239 					_( "unable to make temporary file %s" ),
1240 					dz-&gt;tempdir );
1241 				return( -1 );
1242 			}
1243 			close( fd );
1244 			g_unlink( dz-&gt;tempdir );
1245 			if( !(out = (GsfOutput *) 
1246 				gsf_outfile_stdio_new( dz-&gt;tempdir, 
1247 					&amp;error )) ) {
1248 				vips_g_error( &amp;error );
1249 				return( -1 );
1250 			}
1251 			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
1252 		}
1253 		else { 
1254 			GsfOutput *out;
1255 			GError *error = NULL;
1256 			char name[VIPS_PATH_MAX];
1257 			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s", 
1258 				dz-&gt;dirname, dz-&gt;basename ); 
1259 			if( !(out = (GsfOutput *) 
1260 				gsf_outfile_stdio_new( name, &amp;error )) ) {
1261 				vips_g_error( &amp;error );
1262 				return( -1 );
1263 			}
1264 			dz-&gt;tree = vips_gsf_tree_new( out, 0 );
1265 		}
1266 		break;
1267 	case VIPS_FOREIGN_DZ_CONTAINER_ZIP:
1268 	case VIPS_FOREIGN_DZ_CONTAINER_SZI:
1269 {
1270 		GsfOutput *zip;
1271 		GsfOutput *out2;
1272 		GError *error = NULL;
1273 		char name[VIPS_PATH_MAX];
1274 		if( dz-&gt;dirname ) { 
1275 			const char *suffix =
1276 				dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI ?
1277 					"szi" : "zip";
1278 			vips_snprintf( name, VIPS_PATH_MAX, "%s/%s.%s",
1279 				dz-&gt;dirname, dz-&gt;basename, suffix );
1280 			if( !(dz-&gt;out =
1281 				gsf_output_stdio_new( name, &amp;error )) ) {
1282 				vips_g_error( &amp;error );
1283 				return( -1 );
1284 			}
1285 		}
1286 		else
1287 			dz-&gt;out = gsf_output_memory_new();
1288 		if( !(zip = (GsfOutput *) 
1289 			gsf_outfile_zip_new( dz-&gt;out, &amp;error )) ) {
1290 			vips_g_error( &amp;error );
1291 			return( -1 );
1292 		}
1293 		out2 = gsf_outfile_new_child_full( (GsfOutfile *) zip, 
1294 			dz-&gt;basename, TRUE,
1295 			"compression-level", GSF_ZIP_STORED, 
1296 			NULL );
1297 #ifndef HAVE_GSF_DEFLATE_LEVEL
1298 		if( dz-&gt;compression &gt; 0 ) {
1299 			g_warning( "%s", 
1300 				_( "deflate-level not supported by libgsf, "
1301 				"using default compression" ) ); 
1302 			dz-&gt;compression = -1;
1303 		}
1304 		dz-&gt;tree = vips_gsf_tree_new( out2, dz-&gt;compression );
1305 		dz-&gt;tree-&gt;container = zip; 
1306 }
1307 		break;
1308 	default:
1309 		g_assert_not_reached();
1310 	}
1311 	if( vips_sink_disc( save-&gt;ready, pyramid_strip, dz ) )
1312 		return( -1 );
1313 	switch( dz-&gt;layout ) {
1314 	case VIPS_FOREIGN_DZ_LAYOUT_DZ:
1315 		if( write_dzi( dz ) )
1316 			return( -1 );
1317 		break;
1318 	case VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY:
1319 		if( write_properties( dz ) )
1320 			return( -1 );
1321 		break;
1322 	case VIPS_FOREIGN_DZ_LAYOUT_GOOGLE:
1323 		if( write_blank( dz ) )
1324 			return( -1 );
1325 		break;
1326 	case VIPS_FOREIGN_DZ_LAYOUT_IIIF:
1327 		if( write_json( dz ) )
1328 			return( -1 );
1329 		break;
1330 	default:
1331 		g_assert_not_reached();
1332 	}
1333 	if( dz-&gt;properties &amp;&amp;
1334 		write_vips_meta( dz ) )
1335 		return( -1 );
1336 	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
1337 		write_scan_properties( dz ) )
1338 		return( -1 );
1339 	if( dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_SZI &amp;&amp;
1340 		write_associated( dz ) )
1341 		return( -1 );
1342 	if( dz-&gt;layout == VIPS_FOREIGN_DZ_LAYOUT_DZ &amp;&amp;
1343 		dz-&gt;container == VIPS_FOREIGN_DZ_CONTAINER_FS ) { 
1344 		char old_name[VIPS_PATH_MAX];
1345 		char new_name[VIPS_PATH_MAX];
1346 		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s.dzi", 
1347 			dz-&gt;tempdir, dz-&gt;basename );
1348 		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s.dzi", 
1349 			dz-&gt;dirname, dz-&gt;basename );
1350 		if( vips_rename( old_name, new_name ) )
1351 			return( -1 ); 
1352 		vips_snprintf( old_name, VIPS_PATH_MAX, "%s/%s_files", 
1353 			dz-&gt;tempdir, dz-&gt;basename );
1354 		vips_snprintf( new_name, VIPS_PATH_MAX, "%s/%s_files", 
1355 			dz-&gt;dirname, dz-&gt;basename );
1356 		if( vips_rename( old_name, new_name ) )
1357 			return( -1 ); 
1358 		if( vips_rmdirf( "%s", dz-&gt;tempdir ) )
1359 			return( -1 ); 
1360 	}
1361 	if( vips_gsf_tree_close( dz-&gt;tree ) )
1362 		return( -1 ); 
1363 	dz-&gt;tree = NULL; 
1364 	if( iszip( dz-&gt;container ) &amp;&amp;
1365 		dz-&gt;dirname != NULL ) 
1366 		VIPS_FREEF( g_object_unref, dz-&gt;out );
1367 	return( 0 );
1368 }
1369 #define UC VIPS_FORMAT_UCHAR
1370 #define C VIPS_FORMAT_CHAR
1371 #define US VIPS_FORMAT_USHORT
1372 #define S VIPS_FORMAT_SHORT
1373 #define UI VIPS_FORMAT_UINT
1374 #define I VIPS_FORMAT_INT
1375 #define F VIPS_FORMAT_FLOAT
1376 #define X VIPS_FORMAT_COMPLEX
1377 #define D VIPS_FORMAT_DOUBLE
1378 #define DX VIPS_FORMAT_DPCOMPLEX
1379 static int bandfmt_dz[10] = {
1380    UC, C,  US, S,  UI, I,  F,  F,  D,  D
1381 };
1382 static const char *dz_suffs[] = { ".dz", NULL };
1383 static void
1384 vips_foreign_save_dz_class_init( VipsForeignSaveDzClass *class )
1385 {
1386 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1387 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1388 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
1389 	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
1390 	gobject_class-&gt;dispose = vips_foreign_save_dz_dispose;
1391 	gobject_class-&gt;set_property = vips_object_set_property;
1392 	gobject_class-&gt;get_property = vips_object_get_property;
1393 	object_class-&gt;nickname = "dzsave_base";
1394 	object_class-&gt;description = _( "save image to deep zoom format" );
1395 	object_class-&gt;build = vips_foreign_save_dz_build;
1396 	foreign_class-&gt;suffs = dz_suffs;
1397 	save_class-&gt;saveable = VIPS_SAVEABLE_ANY;
1398 	save_class-&gt;format_table = bandfmt_dz;
1399 	save_class-&gt;coding[VIPS_CODING_LABQ] = TRUE;
1400 	VIPS_ARG_STRING( class, "basename", 2, 
1401 		_( "Base name" ),
1402 		_( "Base name to save to" ),
1403 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1404 		G_STRUCT_OFFSET( VipsForeignSaveDz, basename ),
1405 		NULL );
1406 	VIPS_ARG_ENUM( class, "layout", 8, 
1407 		_( "Layout" ), 
1408 		_( "Directory layout" ),
1409 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1410 		G_STRUCT_OFFSET( VipsForeignSaveDz, layout ),
1411 		VIPS_TYPE_FOREIGN_DZ_LAYOUT, VIPS_FOREIGN_DZ_LAYOUT_DZ ); 
1412 	VIPS_ARG_STRING( class, "suffix", 9, 
1413 		_( "suffix" ), 
1414 		_( "Filename suffix for tiles" ),
1415 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1416 		G_STRUCT_OFFSET( VipsForeignSaveDz, suffix ),
1417 		".jpeg" );
1418 	VIPS_ARG_INT( class, "overlap", 10, 
1419 		_( "Overlap" ), 
1420 		_( "Tile overlap in pixels" ),
1421 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1422 		G_STRUCT_OFFSET( VipsForeignSaveDz, overlap ),
1423 		0, 8192, 1 );
1424 	VIPS_ARG_INT( class, "tile_size", 11, 
1425 		_( "Tile size" ), 
1426 		_( "Tile size in pixels" ),
1427 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1428 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1429 		1, 8192, 254 );
1430 	VIPS_ARG_ENUM( class, "depth", 13, 
1431 		_( "Depth" ), 
1432 		_( "Pyramid depth" ),
1433 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1434 		G_STRUCT_OFFSET( VipsForeignSaveDz, depth ),
1435 		VIPS_TYPE_FOREIGN_DZ_DEPTH, VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ); 
1436 	VIPS_ARG_BOOL( class, "centre", 13, 
1437 		_( "Center" ), 
1438 		_( "Center image in tile" ),
1439 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1440 		G_STRUCT_OFFSET( VipsForeignSaveDz, centre ),
1441 		FALSE );
1442 	VIPS_ARG_ENUM( class, "angle", 14, 
1443 		_( "Angle" ), 
1444 		_( "Rotate image during save" ),
1445 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1446 		G_STRUCT_OFFSET( VipsForeignSaveDz, angle ),
1447 		VIPS_TYPE_ANGLE, VIPS_ANGLE_D0 ); 
1448 	VIPS_ARG_ENUM( class, "container", 15, 
1449 		_( "Container" ), 
1450 		_( "Pyramid container type" ),
1451 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1452 		G_STRUCT_OFFSET( VipsForeignSaveDz, container ),
1453 		VIPS_TYPE_FOREIGN_DZ_CONTAINER, VIPS_FOREIGN_DZ_CONTAINER_FS ); 
1454 	VIPS_ARG_BOOL( class, "properties", 16, 
1455 		_( "Properties" ), 
1456 		_( "Write a properties file to the output directory" ),
1457 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1458 		G_STRUCT_OFFSET( VipsForeignSaveDz, properties ),
1459 		FALSE );
1460 	VIPS_ARG_INT( class, "compression", 17, 
1461 		_( "Compression" ), 
1462 		_( "ZIP deflate compression level" ),
1463 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1464 		G_STRUCT_OFFSET( VipsForeignSaveDz, compression ),
1465 		-1, 9, 0 );
1466 	VIPS_ARG_ENUM( class, "region_shrink", 18, 
1467 		_( "Region shrink" ), 
1468 		_( "Method to shrink regions" ),
1469 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1470 		G_STRUCT_OFFSET( VipsForeignSaveDz, region_shrink ),
1471 		VIPS_TYPE_REGION_SHRINK, VIPS_REGION_SHRINK_MEAN ); 
1472 	VIPS_ARG_INT( class, "skip_blanks", 19, 
1473 		_( "Skip blanks" ), 
1474 		_( "Skip tiles which are nearly equal to the background" ),
1475 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1476 		G_STRUCT_OFFSET( VipsForeignSaveDz, skip_blanks ),
1477 		-1, 65535, -1 );
1478 	VIPS_ARG_BOOL( class, "no_strip", 20, 
1479 		_( "No strip" ), 
1480 		_( "Don't strip tile metadata" ),
1481 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1482 		G_STRUCT_OFFSET( VipsForeignSaveDz, no_strip ),
1483 		FALSE );
1484 	VIPS_ARG_STRING( class, "id", 21, 
1485 		_( "id" ), 
1486 		_( "Resource ID" ),
1487 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1488 		G_STRUCT_OFFSET( VipsForeignSaveDz, id ),
1489 		"https://example.com/iiif" );
1490 	VIPS_ARG_STRING( class, "dirname", 1, 
1491 		_( "Directory name" ),
1492 		_( "Directory name to save to" ),
1493 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1494 		G_STRUCT_OFFSET( VipsForeignSaveDz, dirname ),
1495 		NULL );
1496 	VIPS_ARG_INT( class, "tile_width", 12, 
1497 		_( "Tile width" ), 
1498 		_( "Tile width in pixels" ),
1499 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1500 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1501 		1, 8192, 254 );
1502 	VIPS_ARG_INT( class, "tile_height", 12, 
1503 		_( "Tile height" ), 
1504 		_( "Tile height in pixels" ),
1505 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
1506 		G_STRUCT_OFFSET( VipsForeignSaveDz, tile_size ),
1507 		1, 8192, 254 );
1508 }
1509 static void
1510 vips_foreign_save_dz_init( VipsForeignSaveDz *dz )
1511 {
1512 	VIPS_SETSTR( dz-&gt;suffix, ".jpeg" );
1513 	dz-&gt;layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; 
1514 	dz-&gt;overlap = 1;
1515 	dz-&gt;tile_size = 254;
1516 	dz-&gt;tile_count = 0;
1517 	dz-&gt;depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; 
1518 	dz-&gt;angle = VIPS_ANGLE_D0; 
1519 	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_FS; 
1520 	dz-&gt;compression = 0;
1521 	dz-&gt;region_shrink = VIPS_REGION_SHRINK_MEAN;
1522 	dz-&gt;skip_blanks = -1;
1523 }
1524 typedef struct _VipsForeignSaveDzFile {
1525 	VipsForeignSaveDz parent_object;
1526 	char *filename; 
1527 } VipsForeignSaveDzFile;
1528 typedef VipsForeignSaveDzClass VipsForeignSaveDzFileClass;
1529 G_DEFINE_TYPE( VipsForeignSaveDzFile, vips_foreign_save_dz_file, 
1530 	vips_foreign_save_dz_get_type() );
1531 static int
1532 vips_foreign_save_dz_file_build( VipsObject *object )
1533 {
1534 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1535 	VipsForeignSaveDzFile *file = (VipsForeignSaveDzFile *) object;
1536 	char *p;
1537 	if( !vips_object_argument_isset( object, "basename" ) ) 
1538 		dz-&gt;basename = g_path_get_basename( file-&gt;filename ); 
1539 	if( !vips_object_argument_isset( object, "dirname" ) ) 
1540 		dz-&gt;dirname = g_path_get_dirname( file-&gt;filename ); 
1541 	if( (p = (char *) vips__find_rightmost_brackets( dz-&gt;basename )) )
1542 		*p = '\0';
1543 	if( (p = strrchr( dz-&gt;basename, '.' )) ) {
1544 		if( !vips_object_argument_isset( object, "container" ) ) {
1545 			if( strcasecmp( p + 1, "zip" ) == 0 )
1546 				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
1547 			if( strcasecmp( p + 1, "szi" ) == 0 ) 
1548 				dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_SZI;
1549 		}
1550 		if( g_ascii_strcasecmp( p + 1, "zip" ) == 0 ||
1551 			g_ascii_strcasecmp( p + 1, "szi" ) == 0 || 
1552 			g_ascii_strcasecmp( p + 1, "dz" ) == 0 )
1553 			*p = '\0';
1554 	}
1555 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_file_parent_class )-&gt;
1556 		build( object ) )
1557 		return( -1 );
1558 	return( 0 );
1559 }
1560 static void
1561 vips_foreign_save_dz_file_class_init( VipsForeignSaveDzFileClass *class )
1562 {
1563 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1564 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1565 	gobject_class-&gt;set_property = vips_object_set_property;
1566 	gobject_class-&gt;get_property = vips_object_get_property;
1567 	object_class-&gt;nickname = "dzsave";
1568 	object_class-&gt;description = _( "save image to deepzoom file" );
1569 	object_class-&gt;build = vips_foreign_save_dz_file_build;
1570 	VIPS_ARG_STRING( class, "filename", 1, 
1571 		_( "Filename" ),
1572 		_( "Filename to save to" ),
1573 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1574 		G_STRUCT_OFFSET( VipsForeignSaveDzFile, filename ),
1575 		NULL );
1576 }
1577 static void
1578 vips_foreign_save_dz_file_init( VipsForeignSaveDzFile *file )
1579 {
1580 }
1581 typedef struct _VipsForeignSaveDzBuffer {
1582 	VipsForeignSaveDz parent_object;
1583 	VipsArea *buf;
1584 } VipsForeignSaveDzBuffer;
1585 typedef VipsForeignSaveDzClass VipsForeignSaveDzBufferClass;
1586 G_DEFINE_TYPE( VipsForeignSaveDzBuffer, vips_foreign_save_dz_buffer, 
1587 	vips_foreign_save_dz_get_type() );
1588 static int
1589 vips_foreign_save_dz_buffer_build( VipsObject *object )
1590 {
1591 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) object;
1592 	void *obuf;
1593 	size_t olen;
1594 	VipsBlob *blob;
1595 	if( !vips_object_argument_isset( object, "basename" ) ) 
1596 		dz-&gt;basename = g_strdup( "untitled" ); 
1597 	if( VIPS_OBJECT_CLASS( vips_foreign_save_dz_buffer_parent_class )-&gt;
1598 		build( object ) )
1599 		return( -1 );
1600 	g_assert( GSF_IS_OUTPUT_MEMORY( dz-&gt;out ) );
1601 	olen = gsf_output_size( GSF_OUTPUT( dz-&gt;out ) ); 
1602 	if( !(obuf = g_try_malloc( olen )) ) {
1603 		vips_error( "vips_tracked", 
1604 			_( "out of memory --- size == %dMB" ), 
1605 			(int) (olen / (1024.0 * 1024.0))  );
1606 		return( -1 );
1607 	}
1608 	memcpy( obuf, 
1609 		gsf_output_memory_get_bytes( GSF_OUTPUT_MEMORY( dz-&gt;out ) ),
1610 		olen ); 
1611 	blob = vips_blob_new( (VipsCallbackFn) vips_area_free_cb, obuf, olen );
1612 	g_object_set( object, "buffer", blob, NULL );
1613 	vips_area_unref( VIPS_AREA( blob ) );
1614 	return( 0 );
1615 }
1616 static void
1617 vips_foreign_save_dz_buffer_class_init( VipsForeignSaveDzBufferClass *class )
1618 {
1619 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1620 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1621 	gobject_class-&gt;set_property = vips_object_set_property;
1622 	gobject_class-&gt;get_property = vips_object_get_property;
1623 	object_class-&gt;nickname = "dzsave_buffer";
1624 	object_class-&gt;description = _( "save image to dz buffer" );
1625 	object_class-&gt;build = vips_foreign_save_dz_buffer_build;
1626 	VIPS_ARG_BOXED( class, "buffer", 1, 
1627 		_( "Buffer" ),
1628 		_( "Buffer to save to" ),
1629 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
1630 		G_STRUCT_OFFSET( VipsForeignSaveDzBuffer, buf ),
1631 		VIPS_TYPE_BLOB );
1632 }
1633 static void
1634 vips_foreign_save_dz_buffer_init( VipsForeignSaveDzBuffer *buffer )
1635 {
1636 	VipsForeignSaveDz *dz = (VipsForeignSaveDz *) buffer;
1637 	dz-&gt;container = VIPS_FOREIGN_DZ_CONTAINER_ZIP;
1638 }
1639 int
1640 vips_dzsave( VipsImage *in, const char *name, ... )
1641 {
1642 	va_list ap;
1643 	int result;
1644 	va_start( ap, name );
1645 	result = vips_call_split( "dzsave", ap, in, name ); 
1646 	va_end( ap );
1647 	return( result );
1648 }
1649 int
1650 vips_dzsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
1651 {
1652 	va_list ap;
1653 	VipsArea *area;
1654 	int result;
1655 	area = NULL; 
1656 	va_start( ap, len );
1657 	result = vips_call_split( "dzsave_buffer", ap, in, &amp;area );
1658 	va_end( ap );
1659 	if( !result &amp;&amp;
1660 		area ) { 
1661 		if( buf ) {
1662 			*buf = area-&gt;data;
1663 			area-&gt;free_fn = NULL;
1664 		}
1665 		if( len ) 
1666 			*len = area-&gt;length;
1667 		vips_area_unref( area );
1668 	}
1669 	return( result );
1670 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
