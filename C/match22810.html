<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for smartcrop.c &amp; webpload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for smartcrop.c &amp; webpload.c
      </h3>
<h1 align="center">
        5.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>smartcrop.c (5.533597%)<th>webpload.c (5.3846154%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(403-442)<td><a href="#" name="0">(171-215)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>smartcrop.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* crop an image down to a specified size by removing boring parts
 *
 * Adapted from sharp's smartcrop feature, with kind permission.
 *
 * 1/3/17
 * 	- first version, from sharp
 * 14/3/17
 * 	- revised attention smartcrop
 * 8/6/17
 * 	- revised again
 * 15/9/18 lovell
 * 	- move shrink to start of processing
 * 22/9/18 jcupitt
 * 	- add low and high
 * 19/3/20 jcupitt
 * 	- add all
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/debug.h&gt;

#include "pconversion.h"

#include "bandary.h"

typedef struct _VipsSmartcrop {
	VipsConversion parent_instance;

	VipsImage *in;
	int width;
	int height;
	VipsInteresting interesting;

} VipsSmartcrop;

typedef VipsConversionClass VipsSmartcropClass;

G_DEFINE_TYPE( VipsSmartcrop, vips_smartcrop, VIPS_TYPE_CONVERSION );

static int
vips_smartcrop_score( VipsSmartcrop *smartcrop, VipsImage *in, 
	int left, int top, int width, int height, double *score )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( smartcrop ), 2 );

	if( vips_extract_area( in, &amp;t[0], left, top, width, height, NULL ) ||
		vips_hist_find( t[0], &amp;t[1], NULL ) ||
		vips_hist_entropy( t[1], score, NULL ) )
		return( -1 );

	return( 0 );
}

/* Entropy-style smartcrop. Repeatedly discard low interest areas. This should
 * be faster for very large images. 
 */
static int
vips_smartcrop_entropy( VipsSmartcrop *smartcrop, 
	VipsImage *in, int *left, int *top )
{
	int max_slice_size;
	int width;
	int height;

	*left = 0;
	*top = 0;
	width = in-&gt;Xsize;
	height = in-&gt;Ysize;

	/* How much do we trim by each iteration? Aim for 8 steps in the axis
	 * that needs trimming most.
	 */
	max_slice_size = VIPS_MAX( 
		ceil( (width - smartcrop-&gt;width) / 8.0 ),
		ceil( (height - smartcrop-&gt;height) / 8.0 ) );

	/* Repeatedly take a slice off width and height until we 
	 * reach the target.
	 */
	while( width &gt; smartcrop-&gt;width || 
		height &gt; smartcrop-&gt;height ) {
		const int slice_width = 
			VIPS_MIN( width - smartcrop-&gt;width, max_slice_size );
		const int slice_height = 
			VIPS_MIN( height - smartcrop-&gt;height, max_slice_size );

		if( slice_width &gt; 0 ) { 
			double left_score;
			double right_score;

			if( vips_smartcrop_score( smartcrop, in, 
				*left, *top, 
				slice_width, height, &amp;left_score ) )
				return( -1 );

			if( vips_smartcrop_score( smartcrop, in, 
				*left + width - slice_width, *top, 
				slice_width, height, &amp;right_score ) )
				return( -1 ); 

			width -= slice_width;
			if( left_score &lt; right_score ) 
				*left += slice_width;
		}

		if( slice_height &gt; 0 ) { 
			double top_score;
			double bottom_score;

			if( vips_smartcrop_score( smartcrop, in, 
				*left, *top, 
				width, slice_height, &amp;top_score ) )
				return( -1 );

			if( vips_smartcrop_score( smartcrop, in, 
				*left, *top + height - slice_height, 
				width, slice_height, &amp;bottom_score ) )
				return( -1 ); 

			height -= slice_height;
			if( top_score &lt; bottom_score ) 
				*top += slice_height;
		}
	}

	return( 0 );
}

/* Calculate sqrt(b1^2 + b2^2 ...)
 */
static int
pythagoras( VipsSmartcrop *smartcrop, VipsImage *in, VipsImage **out )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( smartcrop ), 
			2 * in-&gt;Bands + 1 );

	int i;

	for( i = 0; i &lt; in-&gt;Bands; i++ ) 
		if( vips_extract_band( in, &amp;t[i], i, NULL ) )
			return( -1 );

	for( i = 0; i &lt; in-&gt;Bands; i++ ) 
		if( vips_multiply( t[i], t[i], &amp;t[i + in-&gt;Bands], NULL ) )
			return( -1 );

	if( vips_sum( &amp;t[in-&gt;Bands], &amp;t[2 * in-&gt;Bands], in-&gt;Bands, NULL ) ||
		vips_pow_const1( t[2 * in-&gt;Bands], out, 0.5, NULL ) )
		return( -1 );

	return( 0 );
}

static int
vips_smartcrop_attention( VipsSmartcrop *smartcrop, 
	VipsImage *in, int *left, int *top )
{
	/* From smartcrop.js.
	 */
	static double skin_vector[] = {-0.78, -0.57, -0.44};
	static double ones[] = {1.0, 1.0, 1.0};

	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( smartcrop ), 24 );

	double hscale;
	double vscale;
	double sigma;
	double max;
	int x_pos;
	int y_pos;

	/* The size we shrink to gives the precision with which we can place
	 * the crop
	 */
	hscale = 32.0 / in-&gt;Xsize;
	vscale = 32.0 / in-&gt;Ysize;
	sigma = VIPS_MAX( sqrt( pow( smartcrop-&gt;width * hscale, 2 ) +
		pow( smartcrop-&gt;height * vscale, 2 ) ) / 10, 1.0 );
	if ( vips_resize( in, &amp;t[17], hscale,
		"vscale", vscale,
		NULL ) )
		return( -1 );

	/* Simple edge detect.
	 */
	if( !(t[21] = vips_image_new_matrixv( 3, 3,
		 0.0, -1.0,  0.0, 
		-1.0,  4.0, -1.0, 
		 0.0, -1.0,  0.0 )) )
		return( -1 );

	/* Convert to XYZ and just use the first three bands.
	 */
	if( vips_colourspace( t[17], &amp;t[0], VIPS_INTERPRETATION_XYZ, NULL ) ||
		vips_extract_band( t[0], &amp;t[1], 0, "n", 3, NULL ) )
		return( -1 );

	/* Edge detect on Y. 
	 */
	if( vips_extract_band( t[1], &amp;t[2], 1, NULL ) ||
		vips_conv( t[2], &amp;t[3], t[21], 
			"precision", VIPS_PRECISION_INTEGER,
			NULL ) ||
		vips_linear1( t[3], &amp;t[4], 5.0, 0.0, NULL ) ||
		vips_abs( t[4], &amp;t[14], NULL ) )
		return( -1 );

	/* Look for skin colours. Taken from smartcrop.js.
	 */
	if( 
		/* Normalise to magnitude of colour in XYZ.
		 */
		pythagoras( smartcrop, t[1], &amp;t[5] ) ||
		vips_divide( t[1], t[5], &amp;t[6], NULL ) ||

		/* Distance from skin point.
		 */
		vips_linear( t[6], &amp;t[7], ones, skin_vector, 3, NULL ) ||
		pythagoras( smartcrop, t[7], &amp;t[8] ) ||

		/* Rescale to 100 - 0 score.
		 */
		vips_linear1( t[8], &amp;t[9], -100.0, 100.0, NULL ) ||

		/* Ignore dark areas.
		 */
		vips_more_const1( t[2], &amp;t[10], 5.0, NULL ) ||
		!(t[11] = vips_image_new_from_image1( t[10], 0.0 )) ||
		vips_ifthenelse( t[10], t[9], t[11], &amp;t[15], NULL ) )
		return( -1 );

	/* Look for saturated areas.
	 */
	if( vips_colourspace( t[1], &amp;t[12], 
		VIPS_INTERPRETATION_LAB, NULL ) ||
		vips_extract_band( t[12], &amp;t[13], 1, NULL ) ||
		vips_ifthenelse( t[10], t[13], t[11], &amp;t[16], NULL ) )
		return( -1 );

	/* Sum, blur and find maxpos.
	 *
	 * The amount of blur is related to the size of the crop
	 * area: how large an area we want to consider for the scoring
	 * function.
	 */

	if( vips_sum( &amp;t[14], &amp;t[18], 3, NULL ) ||
		vips_gaussblur( t[18], &amp;t[19], sigma, NULL ) ||
		vips_max( t[19], &amp;max, "x", &amp;x_pos, "y", &amp;y_pos, NULL ) )
		return( -1 ); 

	/* Centre the crop over the max.
	 */
	*left = VIPS_CLIP( 0, 
		x_pos / hscale - smartcrop-&gt;width / 2, 
		in-&gt;Xsize - smartcrop-&gt;width );
	*top = VIPS_CLIP( 0, 
		y_pos / vscale - smartcrop-&gt;height / 2, 
		in-&gt;Ysize - smartcrop-&gt;height ); 

	return( 0 ); 
}

static int
vips_smartcrop_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsConversion *conversion = VIPS_CONVERSION( object );
	VipsSmartcrop *smartcrop = (VipsSmartcrop *) object;
	VipsImage **t = (VipsImage **) vips_object_local_array( object, 2 );

	VipsImage *in;
	int left;
	int top;

	if( VIPS_OBJECT_CLASS( vips_smartcrop_parent_class )-&gt;
		build( object ) )
		return( -1 );

	if( smartcrop-&gt;width &gt; smartcrop-&gt;in-&gt;Xsize ||
		smartcrop-&gt;height &gt; smartcrop-&gt;in-&gt;Ysize ||
		smartcrop-&gt;width &lt;= 0 || smartcrop-&gt;height &lt;= 0 ) {
		vips_error( class-&gt;nickname, "%s", _( "bad extract area" ) );
		return( -1 );
	}

	in = smartcrop-&gt;in;

	/* If there's an alpha, we have to premultiply before searching for
	 * content. There could be stuff in transparent areas which we don't
	 * want to consider. 
	 */
	if( vips_image_hasalpha( in ) ) { 
		if( vips_premultiply( in, &amp;t[0], NULL ) ) 
			return( -1 );
		in = t[0];
	}

	switch( smartcrop-&gt;interesting ) {
	case VIPS_INTERESTING_NONE:
	case VIPS_INTERESTING_LOW:
		left = 0;
		top = 0;
		break;

	case VIPS_INTERESTING_CENTRE:
		left = (in-&gt;Xsize - smartcrop-&gt;width) / 2;
		top = (in-&gt;Ysize - smartcrop-&gt;height) / 2;
		break;

	case VIPS_INTERESTING_ENTROPY:
		if( vips_smartcrop_entropy( smartcrop, in, &amp;left, &amp;top ) )
			return( -1 );
		break;

	case VIPS_INTERESTING_ATTENTION:
		if( vips_smartcrop_attention( smartcrop, in, &amp;left, &amp;top ) )
			return( -1 );
		break;

	case VIPS_INTERESTING_HIGH:
		left = in-&gt;Xsize - smartcrop-&gt;width;
		top = in-&gt;Ysize - smartcrop-&gt;height;
		break;

	case VIPS_INTERESTING_ALL:
		left = 0;
		top = 0;
		smartcrop-&gt;width = in-&gt;Xsize;
		smartcrop-&gt;height = in-&gt;Ysize;
		break;

	default:
		g_assert_not_reached();

		/* Stop a compiler warning.
		 */
		left = 0;
		top = 0;
		break;
	}

	if( vips_extract_area( smartcrop-&gt;in, &amp;t[1], 
			left, top, 
			smartcrop-&gt;width, smartcrop-&gt;height, NULL ) ||
		vips_image_write( t[1], conversion-&gt;out ) )
		return( -1 ); 

	return( 0 );
}

static void
vips_smartcrop_class_init( VipsSmartcropClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
<a name="0"></a>
	VIPS_DEBUG_MSG( "vips_smartcrop_class_init\n" );

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	vobject_class-&gt;nickname = "smartcrop";
	vobject_class-&gt;description = _( "extract an area from an image" );
	vobject_class-&gt;build = vips_smartcrop_build;

	VIPS_ARG_IMAGE( class, "input", 0, 
		_( "Input" ), 
		_( "Input image" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsSmartcrop, in ) );

	VIPS_ARG_INT( class, "width", 4, 
		_( "Width" ), 
		_( "Width of extract area" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsSmartcrop, width ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_INT( class, "height", 5, 
		_( "Height" ), 
		_( "Height of extract area" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsSmartcrop, height ),
		1, VIPS_MAX_COORD, 1 );

	VIPS_ARG_ENUM( class, "interesting", 6, 
		_( "Interesting" ), 
		_( "How to measure interestingness" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsSmartcrop, interesting ),
		VIPS_TYPE_INTERESTING, VIPS_INTERESTING_ATTENTION );

}

static void
vips_smartcrop_init( VipsSmartcrop *smartcrop )
{
	smartcrop-&gt;interesting = VIPS_INTERESTING_ATTENTION;</b></font>
}

/**
 * vips_smartcrop: (method)
 * @in: input image
 * @out: (out): output image
 * @width: width of area to extract
 * @height: height of area to extract
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @interesting: #VipsInteresting to use to find interesting areas (default: #VIPS_INTERESTING_ATTENTION)
 *
 * Crop an image down to a specified width and height by removing boring parts. 
 *
 * Use @interesting to pick the method vips uses to decide which bits of the
 * image should be kept.
 *
 * You can test xoffset / yoffset on @out to find the location of the crop
 * within the input image.
 *
 * See also: vips_extract_area().
 * 
 * Returns: 0 on success, -1 on error.
 */
int
vips_smartcrop( VipsImage *in, VipsImage **out, int width, int height, ... )
{
	va_list ap;
	int result;

	va_start( ap, height );
	result = vips_call_split( "smartcrop", ap, in, out, width, height );
	va_end( ap );

	return( result );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>webpload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* load webp images
 *
 * 6/8/13
 * 	- from pngload.c
 * 28/2/16
 * 	- add @shrink
 * 1/11/18
 * 	- add @page, @n
 * 30/4/19
 * 	- deprecate @shrink, use @scale instead
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG_VERBOSE
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;

#include "pforeign.h"

#ifdef HAVE_LIBWEBP

typedef struct _VipsForeignLoadWebp {
	VipsForeignLoad parent_object;

	/* Set by subclasses.
	 */
	VipsSource *source;

	/* Load this page (frame number).
	 */
	int page;

	/* Load this many pages.
	 */
	int n;

	/* Scale by this much during load.
	 */
	double scale; 

	/* Old and deprecated scaling path.
	 */
	int shrink;
} VipsForeignLoadWebp;

typedef VipsForeignLoadClass VipsForeignLoadWebpClass;

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadWebp, vips_foreign_load_webp, 
	VIPS_TYPE_FOREIGN_LOAD );

static void
vips_foreign_load_webp_dispose( GObject *gobject )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) gobject;

	VIPS_UNREF( webp-&gt;source );

	G_OBJECT_CLASS( vips_foreign_load_webp_parent_class )-&gt;
		dispose( gobject );
}

static int
vips_foreign_load_webp_build( VipsObject *object )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;

	/* BC for the old API.
	 */
	if( !vips_object_argument_isset( VIPS_OBJECT( webp ), "scale" ) &amp;&amp;
		vips_object_argument_isset( VIPS_OBJECT( webp ), "shrink" ) &amp;&amp;
		webp-&gt;shrink != 0 )
		webp-&gt;scale = 1.0 / webp-&gt;shrink;

	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static VipsForeignFlags
vips_foreign_load_webp_get_flags( VipsForeignLoad *load )
{
	return( 0 );
}

static VipsForeignFlags
vips_foreign_load_webp_get_flags_filename( const char *filename )
{
	return( 0 );
}

static int
vips_foreign_load_webp_header( VipsForeignLoad *load )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) load;

	if( vips__webp_read_header_source( webp-&gt;source, load-&gt;out, 
		webp-&gt;page, webp-&gt;n, webp-&gt;scale ) ) 
		return( -1 );

	return( 0 );
}

static int
vips_foreign_load_webp_load( VipsForeignLoad *load )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) load;

	if( vips__webp_read_source( webp-&gt;source, load-&gt;real, 
		webp-&gt;page, webp-&gt;n, webp-&gt;scale ) ) 
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_webp_class_init( VipsForeignLoadWebpClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;dispose = vips_foreign_load_webp_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "webpload_base";
	object_class-&gt;description = _( "load webp" );
	object_class-&gt;build = vips_foreign_load_webp_build;
<a name="0"></a>
	/* is_a() is not that quick ... lower the priority.
	 */
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	foreign_class-&gt;priority = -50;

	load_class-&gt;get_flags_filename = 
		vips_foreign_load_webp_get_flags_filename;
	load_class-&gt;get_flags = vips_foreign_load_webp_get_flags;
	load_class-&gt;header = vips_foreign_load_webp_header;
	load_class-&gt;load = vips_foreign_load_webp_load;

	VIPS_ARG_INT( class, "page", 20,
		_( "Page" ),
		_( "Load this page from the file" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadWebp, page ),
		0, 100000, 0 );

	VIPS_ARG_INT( class, "n", 21,
		_( "n" ),
		_( "Load this many pages" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadWebp, n ),
		-1, 100000, 1 );

	VIPS_ARG_DOUBLE( class, "scale", 22, 
		_( "Scale" ), 
		_( "Scale factor on load" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadWebp, scale ),
		0.0, 1024.0, 1.0 );

	/* Old and deprecated scaling API. A float param lets do
	 * shrink-on-load for thumbnail faster and more accurately.
	 */
	VIPS_ARG_INT( class, "shrink", 23, 
		_( "Shrink" ), 
		_( "Shrink factor on load" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignLoadWebp, shrink ),
		1, 1024, 1 );

}

static void
vips_foreign_load_webp_init( VipsForeignLoadWebp *webp )
{
	webp-&gt;n = 1;</b></font>
	webp-&gt;shrink = 1;
	webp-&gt;scale = 1.0;
}

typedef struct _VipsForeignLoadWebpSource {
	VipsForeignLoadWebp parent_object;

	VipsSource *source;

} VipsForeignLoadWebpSource;

typedef VipsForeignLoadWebpClass VipsForeignLoadWebpSourceClass;

G_DEFINE_TYPE( VipsForeignLoadWebpSource, vips_foreign_load_webp_source, 
	vips_foreign_load_webp_get_type() );

static int
vips_foreign_load_webp_source_build( VipsObject *object )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
	VipsForeignLoadWebpSource *source = 
		(VipsForeignLoadWebpSource *) object;

	if( source-&gt;source ) {
		webp-&gt;source = source-&gt;source;
		g_object_ref( webp-&gt;source );
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_source_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_webp_source_class_init( 
	VipsForeignLoadWebpSourceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "webpload_source";
	object_class-&gt;description = _( "load webp from source" );
	object_class-&gt;build = vips_foreign_load_webp_source_build;

	load_class-&gt;is_a_source = vips__iswebp_source; 

	VIPS_ARG_OBJECT( class, "source", 1,
		_( "Source" ),
		_( "Source to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadWebpSource, source ),
		VIPS_TYPE_SOURCE );

}

static void
vips_foreign_load_webp_source_init( VipsForeignLoadWebpSource *buffer )
{
}

typedef struct _VipsForeignLoadWebpFile {
	VipsForeignLoadWebp parent_object;

	/* Filename for load.
	 */
	char *filename; 

} VipsForeignLoadWebpFile;

typedef VipsForeignLoadWebpClass VipsForeignLoadWebpFileClass;

G_DEFINE_TYPE( VipsForeignLoadWebpFile, vips_foreign_load_webp_file, 
	vips_foreign_load_webp_get_type() );

static int
vips_foreign_load_webp_file_build( VipsObject *object )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
	VipsForeignLoadWebpFile *file = (VipsForeignLoadWebpFile *) object;

	if( file-&gt;filename &amp;&amp;
		!(webp-&gt;source = 
			vips_source_new_from_file( file-&gt;filename )) )
		return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_file_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static gboolean
vips_foreign_load_webp_file_is_a( const char *filename )
{
	VipsSource *source;
	gboolean result;

	if( !(source = vips_source_new_from_file( filename )) )
		return( FALSE );
	result = vips__iswebp_source( source );
	VIPS_UNREF( source );

	return( result );
}

const char *vips__webp_suffs[] = { ".webp", NULL };

static void
vips_foreign_load_webp_file_class_init( VipsForeignLoadWebpFileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "webpload";
	object_class-&gt;description = _( "load webp from file" );
	object_class-&gt;build = vips_foreign_load_webp_file_build;

	foreign_class-&gt;suffs = vips__webp_suffs;

	load_class-&gt;is_a = vips_foreign_load_webp_file_is_a;

	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadWebpFile, filename ),
		NULL );
}

static void
vips_foreign_load_webp_file_init( VipsForeignLoadWebpFile *file )
{
}

typedef struct _VipsForeignLoadWebpBuffer {
	VipsForeignLoadWebp parent_object;

	/* Load from a buffer.
	 */
	VipsBlob *blob;

} VipsForeignLoadWebpBuffer;

typedef VipsForeignLoadWebpClass VipsForeignLoadWebpBufferClass;

G_DEFINE_TYPE( VipsForeignLoadWebpBuffer, vips_foreign_load_webp_buffer, 
	vips_foreign_load_webp_get_type() );

static int
vips_foreign_load_webp_buffer_build( VipsObject *object )
{
	VipsForeignLoadWebp *webp = (VipsForeignLoadWebp *) object;
	VipsForeignLoadWebpBuffer *buffer = 
		(VipsForeignLoadWebpBuffer *) object;

	if( buffer-&gt;blob &amp;&amp;
		!(webp-&gt;source = vips_source_new_from_memory( 
			VIPS_AREA( buffer-&gt;blob )-&gt;data, 
			VIPS_AREA( buffer-&gt;blob )-&gt;length )) )
		return( -1 );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_webp_buffer_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static gboolean
vips_foreign_load_webp_buffer_is_a_buffer( const void *buf, size_t len )
{
	VipsSource *source;
	gboolean result;

	if( !(source = vips_source_new_from_memory( buf, len )) )
		return( FALSE );
	result = vips__iswebp_source( source );
	VIPS_UNREF( source );

	return( result );
}

static void
vips_foreign_load_webp_buffer_class_init( 
	VipsForeignLoadWebpBufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "webpload_buffer";
	object_class-&gt;description = _( "load webp from buffer" );
	object_class-&gt;build = vips_foreign_load_webp_buffer_build;

	load_class-&gt;is_a_buffer = vips_foreign_load_webp_buffer_is_a_buffer; 

	VIPS_ARG_BOXED( class, "buffer", 1, 
		_( "Buffer" ),
		_( "Buffer to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadWebpBuffer, blob ),
		VIPS_TYPE_BLOB );
}

static void
vips_foreign_load_webp_buffer_init( VipsForeignLoadWebpBuffer *buffer )
{
}

#endif /*HAVE_LIBWEBP*/

/**
 * vips_webpload:
 * @filename: file to load
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (frame) to read
 * * @n: %gint, load this many pages
 * * @scale: %gdouble, scale by this much on load
 *
 * Read a WebP file into a VIPS image. 
 *
 * Use @page to select a page to render, numbering from zero.
 *
 * Use @n to select the number of pages to render. The default is 1. Pages are
 * rendered in a vertical column, with each individual page aligned to the
 * left. Set to -1 to mean "until the end of the document". Use vips_grid() 
 * to change page layout.
 *
 * Use @scale to specify a scale-on-load factor. For example, 2.0 to double
 * the size on load.
 *
 * The loader supports ICC, EXIF and XMP metadata. 
 *
 * See also: vips_image_new_from_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_webpload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( "webpload", ap, filename, out );
	va_end( ap );

	return( result );
}

/**
 * vips_webpload_buffer:
 * @buf: (array length=len) (element-type guint8): memory area to load
 * @len: (type gsize): size of memory area
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (frame) to read
 * * @n: %gint, load this many pages
 * * @scale: %gdouble, scale by this much on load
 *
 * Read a WebP-formatted memory block into a VIPS image. Exactly as
 * vips_webpload(), but read from a memory buffer. 
 *
 * You must not free the buffer while @out is active. The 
 * #VipsObject::postclose signal on @out is a good place to free. 
 *
 * See also: vips_webpload()
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_webpload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;

	/* We don't take a copy of the data or free it.
	 */
	blob = vips_blob_new( NULL, buf, len );

	va_start( ap, out );
	result = vips_call_split( "webpload_buffer", ap, blob, out );
	va_end( ap );

	vips_area_unref( VIPS_AREA( blob ) );

	return( result );
}

/**
 * vips_webpload_source:
 * @source: source to load from
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (frame) to read
 * * @n: %gint, load this many pages
 * * @scale: %gdouble, scale by this much on load
 *
 * Exactly as vips_webpload(), but read from a source. 
 *
 * See also: vips_webpload()
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_webpload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( "webpload_source", ap, source, out );
	va_end( ap );

	return( result );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
