<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for XYZ2CMYK.c &amp; pdfiumload.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for XYZ2CMYK.c &amp; pdfiumload.c
      </h3>
<h1 align="center">
        11.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>XYZ2CMYK.c (25.714285%)<th>pdfiumload.c (7.1713147%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(94-115)<td><a href="#" name="0">(838-861)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(177-192)<td><a href="#" name="1">(912-927)</a><td align="center"><font color="#cc0000">16</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>XYZ2CMYK.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;vips/vips.h&gt;
5 #include &lt;stdio.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/internal.h&gt;
8 #include "pcolour.h"
9 #include "profiles.h"
10 #ifdef HAVE_LCMS2
11 typedef struct _VipsXYZ2CMYK {
12 	VipsOperation parent_instance;
13 	VipsImage *in;
14 	VipsImage *out;
15 } VipsXYZ2CMYK;
16 typedef VipsColourCodeClass VipsXYZ2CMYKClass;
17 G_DEFINE_TYPE( VipsXYZ2CMYK, vips_XYZ2CMYK, VIPS_TYPE_OPERATION );
18 static int
19 vips_XYZ2CMYK_process( VipsImage *in, VipsImage **out, ... )
20 {
21 	return( vips_icc_export( in, out,
22 		"pcs", VIPS_PCS_XYZ,
23 		NULL ) );
24 }
25 static int
26 vips_XYZ2CMYK_build( VipsObject *object )
27 {
28 	VipsXYZ2CMYK *XYZ2CMYK = (VipsXYZ2CMYK *) object;
29 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 2 );
30 	VipsImage *out; 
31 	if( VIPS_OBJECT_CLASS( vips_XYZ2CMYK_parent_class )-&gt;build( object ) )
32 		return( -1 );
33 	out = vips_image_new();
34 	g_object_set( object, "out", out, NULL ); 
35 	if( vips_copy( XYZ2CMYK-&gt;in, &amp;t[0], NULL ) ||
36 		vips__profile_set( t[0], "cmyk" ) ||
37 <a name="0"></a>		vips__colourspace_process_n( "XYZ2CMYK", 
38 			t[0], &amp;t[1], 3, vips_XYZ2CMYK_process ) ||
39 		vips_image_write( t[1], out ) )
40 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		return( -1 );
41 	return( 0 );
42 }
43 static void
44 vips_XYZ2CMYK_class_init( VipsXYZ2CMYKClass *class )
45 {
46 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
47 	VipsObjectClass *object_class = (VipsObjectClass *) class;
48 	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );
49 	gobject_class-&gt;set_property = vips_object_set_property;
50 	gobject_class-&gt;get_property = vips_object_get_property;
51 	object_class-&gt;nickname = "XYZ2CMYK";
52 	object_class-&gt;description = _( "transform XYZ to CMYK" );
53 	object_class-&gt;build = vips_XYZ2CMYK_build;
54 	operation_class-&gt;flags = VIPS_OPERATION_SEQUENTIAL;
55 	VIPS_ARG_IMAGE( class, "in", 1,</b></font>
56 		_( "Input" ),
57 		_( "Input image" ),
58 		VIPS_ARGUMENT_REQUIRED_INPUT,
59 		G_STRUCT_OFFSET( VipsXYZ2CMYK, in ) );
60 	VIPS_ARG_IMAGE( class, "out", 100,
61 		_( "Output" ),
62 		_( "Output image" ),
63 		VIPS_ARGUMENT_REQUIRED_OUTPUT,
64 		G_STRUCT_OFFSET( VipsXYZ2CMYK, out ) );
65 }
66 static void
67 vips_XYZ2CMYK_init( VipsXYZ2CMYK *XYZ2CMYK )
68 {
69 }
70 typedef VipsColourCode VipsXYZ2CMYK;
71 typedef VipsColourCodeClass VipsXYZ2CMYKClass;
72 G_DEFINE_TYPE(VipsXYZ2CMYK, vips_XYZ2CMYK, VIPS_TYPE_COLOUR_CODE);
73 void
74 vips_XYZ2CMYK_line( VipsColour *colour, VipsPel *out, VipsPel **in, int width )
75 {
76 	float *p = (float *) in[0];
77 	unsigned char *q = (unsigned char *) out;
78 	const float epsilon = 0.00001;
79 	int i;
80 	for( i = 0; i &lt; width; i++ ) {
81 		float r = p[0] / VIPS_D65_X0;
82 		float g = p[1] / VIPS_D65_Y0;
83 		float b = p[2] / VIPS_D65_Z0;
84 		float c = 1.0 - r;
85 		float m = 1.0 - g;
86 		float y = 1.0 - b;
87 		float k = VIPS_MIN( c, VIPS_MIN( m, y ) );
88 		float ik = 1.0 - k;
89 		if( ik &lt; epsilon ) {
90 			q[0] = 255;
91 			q[1] = 255;
92 			q[2] = 255;
93 			q[3] = 255;
94 		}
95 		else {
96 			q[0] = VIPS_CLIP( 0, 255 * (c - k) / ik, 255 );
97 			q[1] = VIPS_CLIP( 0, 255 * (m - k) / ik, 255 );
98 			q[2] = VIPS_CLIP( 0, 255 * (y - k) / ik, 255 );
99 			q[3] = VIPS_CLIP( 0, 255 * k, 255 );
100 		}
101 <a name="1"></a>		p += 3;
102 		q += 4;
103 	}
104 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
105 static void
106 vips_XYZ2CMYK_class_init( VipsXYZ2CMYKClass *class )
107 {
108 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
109 	VipsObjectClass *object_class = (VipsObjectClass *) class;
110 	VipsColourClass *colour_class = VIPS_COLOUR_CLASS( class );
111 	gobject_class-&gt;set_property = vips_object_set_property;
112 	gobject_class-&gt;get_property = vips_object_get_property;
113 	object_class-&gt;nickname = "XYZ2CMYK";
114 	object_class-&gt;description = _( "transform XYZ to CMYK" );
115 	colour_class-&gt;process_line = vips_XYZ2CMYK_line;</b></font>
116 }
117 static void
118 vips_XYZ2CMYK_init( VipsXYZ2CMYK *XYZ2CMYK )
119 {
120 	VipsColour *colour = VIPS_COLOUR( XYZ2CMYK );
121 	VipsColourCode *code = VIPS_COLOUR_CODE( XYZ2CMYK );
122 	colour-&gt;interpretation = VIPS_INTERPRETATION_CMYK;
123 	colour-&gt;format = VIPS_FORMAT_UCHAR;
124 	colour-&gt;bands = 4;
125 	colour-&gt;input_bands = 3;
126 	code-&gt;input_coding = VIPS_CODING_NONE;
127 	code-&gt;input_format = VIPS_FORMAT_FLOAT;
128 	code-&gt;input_interpretation = VIPS_INTERPRETATION_XYZ;
129 }
130 int
131 vips_XYZ2CMYK( VipsImage *in, VipsImage **out, ... )
132 {
133 	va_list ap;
134 	int result;
135 	va_start( ap, out );
136 	result = vips_call_split( "XYZ2CMYK", ap, in, out );
137 	va_end( ap );
138 	return( result );
139 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>pdfiumload.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/buf.h&gt;
10 #include &lt;vips/internal.h&gt;
11 #include "pforeign.h"
12 #ifdef HAVE_PDFIUM
13 #include &lt;fpdfview.h&gt;
14 #include &lt;fpdf_doc.h&gt;
15 typedef struct _VipsForeignLoadPdf {
16 	VipsForeignLoad parent_object;
17 	VipsSource *source;
18 	int page_no;
19 	int n; 
20 	double dpi;
21 	double scale;
22 	VipsArrayDouble *background;
23 	FPDF_FILEACCESS file_access;
24 	FPDF_DOCUMENT doc;
25 	FPDF_PAGE page;
26 	int current_page;
27 	int n_pages;
28 	VipsRect image;
29 	VipsRect *pages;
30 	VipsPel *ink;
31 } VipsForeignLoadPdf;
32 typedef VipsForeignLoadClass VipsForeignLoadPdfClass;
33 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadPdf, vips_foreign_load_pdf, 
34 	VIPS_TYPE_FOREIGN_LOAD );
35 static char *vips_pdfium_errors[] = {
36 	"no error",
37 	"unknown error",
38 	"file not found or could not be opened",
39 	"file not in PDF format or corrupted",
40 	"password required or incorrect password",
41 	"unsupported security scheme",
42 	"page not found or content error"
43 };
44 static GMutex *vips_pdfium_mutex = NULL;
45 static void
46 vips_pdfium_error( void )
47 {
48 	int err = FPDF_GetLastError();
49 	if( err &gt;= 0 &amp;&amp; 
50 		err &lt; VIPS_NUMBER( vips_pdfium_errors ) )
51 		vips_error( "pdfload", "%s", _( vips_pdfium_errors[err] ) );
52 	else
53 		vips_error( "pdfload", "%s", _( "unknown error" ) ); 
54 }
55 static void
56 vips_foreign_load_pdf_close( VipsForeignLoadPdf *pdf )
57 {
58 	g_mutex_lock( vips_pdfium_mutex );
59 	VIPS_FREEF( FPDF_ClosePage, pdf-&gt;page ); 
60 	VIPS_FREEF( FPDF_CloseDocument, pdf-&gt;doc ); 
61 	VIPS_UNREF( pdf-&gt;source );
62 	g_mutex_unlock( vips_pdfium_mutex );
63 }
64 static void
65 vips_foreign_load_pdf_dispose( GObject *gobject )
66 {
67 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) gobject;
68 	vips_foreign_load_pdf_close( pdf ); 
69 	G_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )-&gt;
70 		dispose( gobject );
71 }
72 static void *
73 vips_pdfium_init_cb( void *dummy )
74 {
75 	FPDF_LIBRARY_CONFIG config;
76 	config.version = 2;
77 	config.m_pUserFontPaths = NULL;
78 	config.m_pIsolate = NULL;
79 	config.m_v8EmbedderSlot = 0;
80 	FPDF_InitLibraryWithConfig( &amp;config );
81 	return( NULL );
82 }
83 static gboolean
84 vips_pdfium_GetBlock( void *param, 
85 	unsigned long position, unsigned char *pBuf, unsigned long size )
86 {
87 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) param;
88 	g_assert( size &gt; 0 );
89 	g_assert( position &gt;= 0 );
90 	g_assert( position + size &lt;= pdf-&gt;file_access.m_FileLen );
91 	if( vips_source_seek( pdf-&gt;source, position, SEEK_SET ) &lt; 0 )
92 		return( FALSE );
93 	while( size &gt; 0 ) {
94 		size_t n_read;
95 		if( (n_read = vips_source_read( pdf-&gt;source, pBuf, size )) &lt; 0 )
96 			return( FALSE );
97 		pBuf += n_read;
98 		size -= n_read;
99 	}
100 	return( TRUE );
101 }
102 static int
103 vips_foreign_load_pdf_build( VipsObject *object )
104 {
105 	static GOnce once = G_ONCE_INIT;
106 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
107 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );
108 	gint64 length;
109 	VIPS_ONCE( &amp;once, vips_pdfium_init_cb, NULL );
110 	if( !vips_object_argument_isset( object, "scale" ) )
111 		pdf-&gt;scale = pdf-&gt;dpi / 72.0;
112 	if( pdf-&gt;source ) { 
113 		if( (length = vips_source_length( pdf-&gt;source )) &lt;= 0 )
114 			return( -1 );
115 		if( length &gt; 1 &lt;&lt; 30 ) {
116 			vips_error( class-&gt;nickname, 
117 				_( "%s: too large for pdfium" ),
118 				vips_connection_nick( 
119 					VIPS_CONNECTION( pdf-&gt;source ) ) );
120 			return( -1 );
121 		}
122 		pdf-&gt;file_access.m_FileLen = length;
123 		pdf-&gt;file_access.m_GetBlock = vips_pdfium_GetBlock;
124 		pdf-&gt;file_access.m_Param = pdf;
125 		g_mutex_lock( vips_pdfium_mutex );
126 		if( !(pdf-&gt;doc = FPDF_LoadCustomDocument( &amp;pdf-&gt;file_access, 
127 			NULL )) ) {
128 			g_mutex_unlock( vips_pdfium_mutex );
129 			vips_pdfium_error();
130 			vips_error( "pdfload", 
131 				_( "%s: unable to load" ), 
132 				vips_connection_nick( 
133 					VIPS_CONNECTION( pdf-&gt;source ) ) );
134 			return( -1 ); 
135 		}
136 		g_mutex_unlock( vips_pdfium_mutex );
137 	}
138 	if( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_parent_class )-&gt;
139 		build( object ) )
140 		return( -1 );
141 	return( 0 );
142 }
143 static VipsForeignFlags
144 vips_foreign_load_pdf_get_flags_filename( const char *filename )
145 {
146 	return( VIPS_FOREIGN_PARTIAL );
147 }
148 static VipsForeignFlags
149 vips_foreign_load_pdf_get_flags( VipsForeignLoad *load )
150 {
151 	return( VIPS_FOREIGN_PARTIAL );
152 }
153 static int
154 vips_foreign_load_pdf_get_page( VipsForeignLoadPdf *pdf, int page_no )
155 {
156 	if( pdf-&gt;current_page != page_no ) { 
157 		VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( pdf );
158 		g_mutex_lock( vips_pdfium_mutex );
159 		VIPS_FREEF( FPDF_ClosePage, pdf-&gt;page ); 
160 		pdf-&gt;current_page = -1;
161 #ifdef DEBUG
162 		printf( "vips_foreign_load_pdf_get_page: %d\n", page_no );
163 		if( !(pdf-&gt;page = FPDF_LoadPage( pdf-&gt;doc, page_no )) ) {
164 			g_mutex_unlock( vips_pdfium_mutex );
165 			vips_pdfium_error();
166 			vips_error( class-&gt;nickname, 
167 				_( "unable to load page %d" ), page_no );
168 			return( -1 ); 
169 		}
170 		pdf-&gt;current_page = page_no;
171 		g_mutex_unlock( vips_pdfium_mutex );
172 	}
173 	return( 0 );
174 }
175 typedef struct _VipsForeignLoadPdfMetadata {
176 	char *tag;			char *field;		} VipsForeignLoadPdfMetadata;
177 static VipsForeignLoadPdfMetadata vips_foreign_load_pdf_metadata[] = {
178 	{ "Title", "pdf-title" },
179 	{ "Author", "pdf-author" },
180 	{ "Subject", "pdf-subject" },
181 	{ "Keywords", "pdf-keywords" },
182 	{ "Creator", "pdf-creator" },
183 	{ "Producer", "pdf-producer" },
184 };
185 static int n_metadata = VIPS_NUMBER( vips_foreign_load_pdf_metadata );
186 static int
187 vips_foreign_load_pdf_set_image( VipsForeignLoadPdf *pdf, VipsImage *out )
188 {
189 	int i;
190 	double res;
191 #ifdef DEBUG
192 	printf( "vips_foreign_load_pdf_set_image: %p\n", pdf );
193         if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_FATSTRIP, NULL ) )
194 		return( -1 );
195 	vips_image_set_int( out, "pdf-n_pages", pdf-&gt;n_pages ); 
196 	vips_image_set_int( out, VIPS_META_N_PAGES, pdf-&gt;n_pages ); 
197 	g_mutex_lock( vips_pdfium_mutex );
198 	for( i = 0; i &lt; n_metadata; i++ ) {
199 		VipsForeignLoadPdfMetadata *metadata = 
200 			&amp;vips_foreign_load_pdf_metadata[i];
201 		char text[1024];
202 		int len;
203 		len = FPDF_GetMetaText( pdf-&gt;doc, metadata-&gt;tag, text, 1024 );
204 		if( len &gt; 0 ) { 
205 			char *str;
206 			if( (str = g_utf16_to_utf8( (gunichar2 *) text, len, 
207 				NULL, NULL, NULL )) ) {
208 				vips_image_set_string( out, 
209 					metadata-&gt;field, str ); 
210 				g_free( str );
211 			}
212 		}
213 	}
214 	g_mutex_unlock( vips_pdfium_mutex );
215 	res = pdf-&gt;dpi / 25.4;
216 	vips_image_init_fields( out, 
217 		pdf-&gt;image.width, pdf-&gt;image.height, 
218 		4, VIPS_FORMAT_UCHAR,
219 		VIPS_CODING_NONE, VIPS_INTERPRETATION_sRGB, res, res );
220 	return( 0 );
221 }
222 static int
223 vips_foreign_load_pdf_header( VipsForeignLoad *load )
224 {
225 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( load );
226 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
227 	int top;
228 	int i;
229 #ifdef DEBUG
230 	printf( "vips_foreign_load_pdf_header: %p\n", pdf );
231 	g_mutex_lock( vips_pdfium_mutex );
232 	pdf-&gt;n_pages = FPDF_GetPageCount( pdf-&gt;doc );
233 	g_mutex_unlock( vips_pdfium_mutex );
234 	if( pdf-&gt;n == -1 )
235 		pdf-&gt;n = pdf-&gt;n_pages - pdf-&gt;page_no;
236 	if( pdf-&gt;page_no + pdf-&gt;n &gt; pdf-&gt;n_pages ||
237 		pdf-&gt;page_no &lt; 0 ||
238 		pdf-&gt;n &lt;= 0 ) {
239 		vips_error( class-&gt;nickname, "%s", _( "pages out of range" ) );
240 		return( -1 ); 
241 	}
242 	if( !(pdf-&gt;pages = VIPS_ARRAY( pdf, pdf-&gt;n, VipsRect )) )
243 		return( -1 ); 
244 	top = 0;
245 	pdf-&gt;image.left = 0;
246 	pdf-&gt;image.top = 0;
247 	pdf-&gt;image.width = 0;
248 	pdf-&gt;image.height = 0;
249 	for( i = 0; i &lt; pdf-&gt;n; i++ ) {
250 		if( vips_foreign_load_pdf_get_page( pdf, pdf-&gt;page_no + i ) )
251 			return( -1 );
252 		pdf-&gt;pages[i].left = 0;
253 		pdf-&gt;pages[i].top = top;
254 		pdf-&gt;pages[i].width = VIPS_RINT( 
255 			FPDF_GetPageWidth( pdf-&gt;page ) * pdf-&gt;scale );
256 		pdf-&gt;pages[i].height = VIPS_RINT( 
257 			FPDF_GetPageHeight( pdf-&gt;page ) * pdf-&gt;scale );
258 		if( pdf-&gt;pages[i].width &gt; pdf-&gt;image.width )
259 			pdf-&gt;image.width = pdf-&gt;pages[i].width;
260 		pdf-&gt;image.height += pdf-&gt;pages[i].height;
261 		top += pdf-&gt;pages[i].height;
262 	}
263 	for( i = 1; i &lt; pdf-&gt;n; i++ ) 
264 		if( pdf-&gt;pages[i].height != pdf-&gt;pages[0].height )
265 			break;
266 	if( vips_object_argument_isset( VIPS_OBJECT( pdf ), "n" ) )
267 		vips_image_set_int( load-&gt;out, 
268 			VIPS_META_PAGE_HEIGHT, pdf-&gt;pages[0].height );
269 	vips_foreign_load_pdf_set_image( pdf, load-&gt;out ); 
270 	if( !(pdf-&gt;ink = vips__vector_to_ink( class-&gt;nickname, 
271 		load-&gt;out, 
272 		VIPS_AREA( pdf-&gt;background )-&gt;data, NULL, 
273 		VIPS_AREA( pdf-&gt;background )-&gt;n )) )
274 		return( -1 );
275 	return( 0 );
276 }
277 static void
278 vips_foreign_load_pdf_minimise( VipsObject *object, VipsForeignLoadPdf *pdf )
279 {
280 	vips_source_minimise( pdf-&gt;source );
281 }
282 static int
283 vips_foreign_load_pdf_generate( VipsRegion *or, 
284 	void *seq, void *a, void *b, gboolean *stop )
285 {
286 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) a;
287 	VipsRect *r = &amp;or-&gt;valid;
288 	int top;
289 	int i;
290 	int y;
291 	vips_region_paint_pel( or, r, pdf-&gt;ink ); 
292 	for( i = 0; i &lt; pdf-&gt;n; i++ )
293 		if( VIPS_RECT_BOTTOM( &amp;pdf-&gt;pages[i] ) &gt; r-&gt;top )
294 			break;
295 	top = r-&gt;top; 
296 	while( top &lt; VIPS_RECT_BOTTOM( r ) ) {
297 		VipsRect rect;
298 		FPDF_BITMAP bitmap;
299 		vips_rect_intersectrect( r, &amp;pdf-&gt;pages[i], &amp;rect );
300 		if( vips_foreign_load_pdf_get_page( pdf, pdf-&gt;page_no + i ) )
301 			return( -1 ); 
302 		g_mutex_lock( vips_pdfium_mutex );
303 		bitmap = FPDFBitmap_CreateEx( rect.width, rect.height, 4, 
304 			VIPS_REGION_ADDR( or, rect.left, rect.top ), 
305 			VIPS_REGION_LSKIP( or ) );  
306 		FPDF_RenderPageBitmap( bitmap, pdf-&gt;page, 
307 			0, 0, rect.width, rect.height,
308 			0, 0 ); 
309 		FPDFBitmap_Destroy( bitmap ); 
310 		g_mutex_unlock( vips_pdfium_mutex );
311 		top += rect.height;
312 		i += 1;
313 	}
314 	for( y = 0; y &lt; r-&gt;height; y++ )
315 		vips__bgra2rgba( 
316 			(guint32 *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ),
317 			r-&gt;width );
318 	return( 0 ); 
319 }
320 static int
321 vips_foreign_load_pdf_load( VipsForeignLoad *load )
322 {
323 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) load;
324 	VipsImage **t = (VipsImage **) 
325 		vips_object_local_array( (VipsObject *) load, 2 );
326 #ifdef DEBUG
327 	printf( "vips_foreign_load_pdf_load: %p\n", pdf );
328 	t[0] = vips_image_new(); 
329 	g_signal_connect( t[0], "minimise", 
330 		G_CALLBACK( vips_foreign_load_pdf_minimise ), pdf ); 
331 	vips_foreign_load_pdf_set_image( pdf, t[0] ); 
332 	if( vips_image_generate( t[0], 
333 		NULL, vips_foreign_load_pdf_generate, NULL, pdf, NULL ) )
334 		return( -1 );
335 	if( vips_linecache( t[0], &amp;t[1],
336 		"tile_height", pdf-&gt;pages[0].height, 
337 		NULL ) ) 
338 		return( -1 );
339 	if( vips_image_write( t[1], load-&gt;real ) ) 
340 		return( -1 );
341 	return( 0 );
342 }
343 static void *
344 vips_foreign_load_pdf_once_init( void *client )
345 {
346 	vips_pdfium_mutex = vips_g_mutex_new();
347 	return( NULL );
348 }
349 static void
350 vips_foreign_load_pdf_class_init( VipsForeignLoadPdfClass *class )
351 {
352 	static GOnce once = G_ONCE_INIT;
353 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
354 	VipsObjectClass *object_class = (VipsObjectClass *) class;
355 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
356 	VIPS_ONCE( &amp;once, vips_foreign_load_pdf_once_init, NULL );
357 	gobject_class-&gt;dispose = vips_foreign_load_pdf_dispose;
358 	gobject_class-&gt;set_property = vips_object_set_property;
359 	gobject_class-&gt;get_property = vips_object_get_property;
360 	object_class-&gt;nickname = "pdfload_base";
361 	object_class-&gt;description = _( "load PDF with PDFium" );
362 	object_class-&gt;build = vips_foreign_load_pdf_build;
363 	load_class-&gt;get_flags_filename = 
364 		vips_foreign_load_pdf_get_flags_filename;
365 	load_class-&gt;get_flags = vips_foreign_load_pdf_get_flags;
366 	load_class-&gt;header = vips_foreign_load_pdf_header;
367 	load_class-&gt;load = vips_foreign_load_pdf_load;
368 	VIPS_ARG_INT( class, "page", 10,
369 		_( "Page" ),
370 		_( "Load this page from the file" ),
371 		VIPS_ARGUMENT_OPTIONAL_INPUT,
372 		G_STRUCT_OFFSET( VipsForeignLoadPdf, page_no ),
373 		0, 100000, 0 );
374 	VIPS_ARG_INT( class, "n", 11,
375 		_( "n" ),
376 		_( "Load this many pages" ),
377 		VIPS_ARGUMENT_OPTIONAL_INPUT,
378 		G_STRUCT_OFFSET( VipsForeignLoadPdf, n ),
379 		-1, 100000, 1 );
380 	VIPS_ARG_DOUBLE( class, "dpi", 12,
381 		_( "DPI" ),
382 		_( "Render at this DPI" ),
383 		VIPS_ARGUMENT_OPTIONAL_INPUT,
384 		G_STRUCT_OFFSET( VipsForeignLoadPdf, dpi ),
385 		0.001, 100000.0, 72.0 );
386 	VIPS_ARG_DOUBLE( class, "scale", 13,
387 		_( "Scale" ),
388 		_( "Scale output by this factor" ),
389 		VIPS_ARGUMENT_OPTIONAL_INPUT,
390 		G_STRUCT_OFFSET( VipsForeignLoadPdf, scale ),
391 		0.001, 100000.0, 1.0 );
392 	VIPS_ARG_BOXED( class, "background", 14, 
393 		_( "Background" ), 
394 		_( "Background value" ),
395 		VIPS_ARGUMENT_OPTIONAL_INPUT,
396 		G_STRUCT_OFFSET( VipsForeignLoadPdf, background ),
397 		VIPS_TYPE_ARRAY_DOUBLE );
398 }
399 static void
400 vips_foreign_load_pdf_init( VipsForeignLoadPdf *pdf )
401 {
402 	pdf-&gt;dpi = 72.0;
403 	pdf-&gt;scale = 1.0;
404 	pdf-&gt;n = 1;
405 	pdf-&gt;current_page = -1;
406 	pdf-&gt;background = vips_array_double_newv( 1, 255.0 );
407 }
408 typedef struct _VipsForeignLoadPdfFile {
409 	VipsForeignLoadPdf parent_object;
410 	char *filename; 
411 } VipsForeignLoadPdfFile;
412 typedef VipsForeignLoadPdfClass VipsForeignLoadPdfFileClass;
413 G_DEFINE_TYPE( VipsForeignLoadPdfFile, vips_foreign_load_pdf_file, 
414 	vips_foreign_load_pdf_get_type() );
415 static int
416 vips_foreign_load_pdf_file_header( VipsForeignLoad *load )
417 {
418 	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) load;
419 	VIPS_SETSTR( load-&gt;out-&gt;filename, file-&gt;filename );
420 	return( VIPS_FOREIGN_LOAD_CLASS(
421 		vips_foreign_load_pdf_file_parent_class )-&gt;header( load ) );
422 }
423 static const char *vips_foreign_pdf_suffs[] = {
424 	".pdf",
425 	NULL
426 };
427 static int
428 vips_foreign_load_pdf_file_build( VipsObject *object )
429 {
430 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
431 	VipsForeignLoadPdfFile *file = (VipsForeignLoadPdfFile *) pdf;
432 #ifdef DEBUG
433 	printf( "vips_foreign_load_pdf_file_build: %s\n", file-&gt;filename );
434 	if( file-&gt;filename &amp;&amp;
435 		!(pdf-&gt;source = vips_source_new_from_file( file-&gt;filename )) )
436 		return( -1 );
437 	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_file_parent_class )-&gt;
438 		build( object ) );
439 }
440 static gboolean
441 vips_foreign_load_pdf_is_a_buffer( const void *buf, size_t len )
442 {
443 	const guchar *str = (const guchar *) buf;
444 	if( len &gt;= 4 &amp;&amp;
445 		str[0] == '%' &amp;&amp; 
446 		str[1] == 'P' &amp;&amp;
447 		str[2] == 'D' &amp;&amp;
448 		str[3] == 'F' )
449 		return( 1 );
450 	return( 0 );
451 }
452 static gboolean
453 vips_foreign_load_pdf_is_a( const char *filename )
454 {
455 	unsigned char buf[4];
456 	if( vips__get_bytes( filename, buf, 4 ) == 4 &amp;&amp;
457 		vips_foreign_load_pdf_is_a_buffer( buf, 4 ) )
458 		return( 1 );
459 	return( 0 );
460 }
461 static void
462 vips_foreign_load_pdf_file_class_init( 
463 	VipsForeignLoadPdfFileClass *class )
464 {
465 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
466 	VipsObjectClass *object_class = (VipsObjectClass *) class;
467 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
468 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
469 	gobject_class-&gt;set_property = vips_object_set_property;
470 	gobject_class-&gt;get_property = vips_object_get_property;
471 	object_class-&gt;nickname = "pdfload";
472 	object_class-&gt;description = _( "load PDF from file" );
473 	object_class-&gt;build = vips_foreign_load_pdf_file_build;
474 	foreign_class-&gt;suffs = vips_foreign_pdf_suffs;
475 	load_class-&gt;is_a = vips_foreign_load_pdf_is_a;
476 	load_class-&gt;header = vips_foreign_load_pdf_file_header;
477 	VIPS_ARG_STRING( class, "filename", 1, 
478 		_( "Filename" ),
479 		_( "Filename to load from" ),
480 		VIPS_ARGUMENT_REQUIRED_INPUT, 
481 		G_STRUCT_OFFSET( VipsForeignLoadPdfFile, filename ),
482 		NULL );
483 }
484 static void
485 vips_foreign_load_pdf_file_init( VipsForeignLoadPdfFile *file )
486 {
487 }
488 typedef struct _VipsForeignLoadPdfBuffer {
489 	VipsForeignLoadPdf parent_object;
490 	VipsArea *buf;
491 } VipsForeignLoadPdfBuffer;
492 typedef VipsForeignLoadPdfClass VipsForeignLoadPdfBufferClass;
493 G_DEFINE_TYPE( VipsForeignLoadPdfBuffer, vips_foreign_load_pdf_buffer, 
494 	vips_foreign_load_pdf_get_type() );
495 static int
496 vips_foreign_load_pdf_buffer_build( VipsObject *object )
497 {
498 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
499 	VipsForeignLoadPdfBuffer *buffer = (VipsForeignLoadPdfBuffer *) pdf;
500 	if( buffer-&gt;buf &amp;&amp;
501 <a name="0"></a>		!(pdf-&gt;source = vips_source_new_from_memory( 
502 			VIPS_AREA( buffer-&gt;buf )-&gt;data, 
503 			VIPS_AREA( buffer-&gt;buf )-&gt;length )) )
504 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		return( -1 );
505 	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_buffer_parent_class )-&gt;
506 		build( object ) );
507 }
508 static void
509 vips_foreign_load_pdf_buffer_class_init( 
510 	VipsForeignLoadPdfBufferClass *class )
511 {
512 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
513 	VipsObjectClass *object_class = (VipsObjectClass *) class;
514 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
515 	gobject_class-&gt;set_property = vips_object_set_property;
516 	gobject_class-&gt;get_property = vips_object_get_property;
517 	object_class-&gt;nickname = "pdfload_buffer";
518 	object_class-&gt;description = _( "load PDF from buffer" );
519 	object_class-&gt;build = vips_foreign_load_pdf_buffer_build;
520 	load_class-&gt;is_a_buffer = vips_foreign_load_pdf_is_a_buffer;
521 	VIPS_ARG_BOXED( class, "buffer", 1, </b></font>
522 		_( "Buffer" ),
523 		_( "Buffer to load from" ),
524 		VIPS_ARGUMENT_REQUIRED_INPUT, 
525 		G_STRUCT_OFFSET( VipsForeignLoadPdfBuffer, buf ),
526 		VIPS_TYPE_BLOB );
527 }
528 static void
529 vips_foreign_load_pdf_buffer_init( VipsForeignLoadPdfBuffer *buffer )
530 {
531 }
532 typedef struct _VipsForeignLoadPdfSource {
533 	VipsForeignLoadPdf parent_object;
534 	VipsSource *source;
535 } VipsForeignLoadPdfSource;
536 typedef VipsForeignLoadPdfClass VipsForeignLoadPdfSourceClass;
537 G_DEFINE_TYPE( VipsForeignLoadPdfSource, vips_foreign_load_pdf_source, 
538 	vips_foreign_load_pdf_get_type() );
539 static int
540 vips_foreign_load_pdf_source_build( VipsObject *object )
541 {
542 	VipsForeignLoadPdf *pdf = (VipsForeignLoadPdf *) object;
543 	VipsForeignLoadPdfSource *source = (VipsForeignLoadPdfSource *) pdf;
544 	if( source-&gt;source ) {
545 		pdf-&gt;source = source-&gt;source;
546 		g_object_ref( pdf-&gt;source );
547 	}
548 	return( VIPS_OBJECT_CLASS( vips_foreign_load_pdf_source_parent_class )-&gt;
549 		build( object ) );
550 }
551 static gboolean
552 vips_foreign_load_pdf_source_is_a_source( VipsSource *source )
553 {
554 	const unsigned char *p;
555 	return( (p = vips_source_sniff( source, 4 )) &amp;&amp;
556 		p[0] == '%' &amp;&amp; 
557 <a name="1"></a>		p[1] == 'P' &amp;&amp;
558 		p[2] == 'D' &amp;&amp;
559 		p[3] == 'F' );
560 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
561 static void
562 vips_foreign_load_pdf_source_class_init( 
563 	VipsForeignLoadPdfSourceClass *class )
564 {
565 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
566 	VipsObjectClass *object_class = (VipsObjectClass *) class;
567 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
568 	gobject_class-&gt;set_property = vips_object_set_property;
569 	gobject_class-&gt;get_property = vips_object_get_property;
570 	object_class-&gt;nickname = "pdfload_source";
571 	object_class-&gt;description = _( "load PDF from source" );
572 	object_class-&gt;build = vips_foreign_load_pdf_source_build;</b></font>
573 	load_class-&gt;is_a_source = vips_foreign_load_pdf_source_is_a_source;
574 	VIPS_ARG_OBJECT( class, "source", 1,
575 		_( "Source" ),
576 		_( "Source to load from" ),
577 		VIPS_ARGUMENT_REQUIRED_INPUT, 
578 		G_STRUCT_OFFSET( VipsForeignLoadPdfSource, source ),
579 		VIPS_TYPE_SOURCE );
580 }
581 static void
582 vips_foreign_load_pdf_source_init( VipsForeignLoadPdfSource *source )
583 {
584 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
