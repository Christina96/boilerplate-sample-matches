<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for convasep.c &amp; tiff2vips.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for convasep.c &amp; tiff2vips.c
      </h3>
<h1 align="center">
        2.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>convasep.c (4.9079757%)<th>tiff2vips.c (1.5686275%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(620-712)<td><a href="#" name="0">(1792-1808)</a><td align="center"><font color="#ff0000">12</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(105-129)<td><a href="#" name="1">(273-312)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>convasep.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* convasep ... separable approximate convolution
 *
 * This operation does an approximate, seperable convolution. 
 *
 * Author: John Cupitt &amp; Nicolas Robidoux
 * Written on: 31/5/11
 * Modified on: 
 * 31/5/11
 *      - from im_conv()
 * 5/7/16
 * 	- redone as a class
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*

  See:

	http://incubator.quasimondo.com/processing/stackblur.pde

  This thing is a little like stackblur, but generalised to any separable 
  mask.

 */

/*

  TODO

	- how about making a cumulative image and then subtracting points in 
	  that, rather than keeping a set of running totals

	  faster?

	  we could then use orc to write a bit of code to implement this set 
	  of lines

	  stackoverflow has an algorithm for cumulativization using SIMD and 
	  threads, see that font rasterization with rust piece on medium by 
	  ralph levien

 */

/*
#define DEBUG
#define VIPS_DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
#include &lt;math.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vector.h&gt;
#include &lt;vips/debug.h&gt;
#include &lt;vips/internal.h&gt;

#include "pconvolution.h"

/* Maximum number of lines we can break the mask into.
 */
#define MAX_LINES (1000)

/* Euclid's algorithm. Use this to common up mults.
 */
static int
gcd( int a, int b )
{
	if( b == 0 )
<a name="1"></a>		return( abs( a ) );
	else
		return( gcd( b, a % b ) );
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

typedef struct {
	VipsConvolution parent_instance;

	int layers;

	int divisor;
	int rounding;
	int offset;

	/* The "width" of the mask, ie. n for our 1xn or nx1 argument, plus 
	 * an int version of our mask. 
	 */
	int width;
	VipsImage *iM;

	/* The mask broken into a set of lines.
	 *
	 * Start is the left-most pixel in the line, end is one beyond the
	 * right-most pixel.
	 */
	int n_lines;
	int start[MAX_LINES];
	int end[MAX_LINES];</b></font>
	int factor[MAX_LINES];
} VipsConvasep;

typedef VipsConvolutionClass VipsConvasepClass;

G_DEFINE_TYPE( VipsConvasep, vips_convasep, VIPS_TYPE_CONVOLUTION );

static void
vips_convasep_line_start( VipsConvasep *convasep, int x, int factor )
{
	convasep-&gt;start[convasep-&gt;n_lines] = x;
	convasep-&gt;factor[convasep-&gt;n_lines] = factor;
}

static int
vips_convasep_line_end( VipsConvasep *convasep, int x )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( convasep );

	convasep-&gt;end[convasep-&gt;n_lines] = x;

	if( convasep-&gt;n_lines &gt;= MAX_LINES - 1 ) {
		vips_error( class-&gt;nickname, "%s", _( "mask too complex" ) );
		return( -1 );
	}
	convasep-&gt;n_lines += 1;

	return( 0 );
}

/* Break a mask into lines.
 */
static int
vips_convasep_decompose( VipsConvasep *convasep )
{
	VipsImage *iM = convasep-&gt;iM;
	double *coeff = (double *) VIPS_IMAGE_ADDR( iM, 0, 0 );
	double scale = vips_image_get_scale( iM ); 
	double offset = vips_image_get_offset( iM ); 

	double max;
	double min;
	double depth;
	double sum;
	double area;
	int layers;
	int layers_above;
	int layers_below;
	int z, n, x;

	VIPS_DEBUG_MSG( "vips_convasep_decompose: "
		"breaking into %d layers ...\n", convasep-&gt;layers );

	/* Find mask range. We must always include the zero axis in the mask.
	 */
	max = 0;
	min = 0;
	for( x = 0; x &lt; convasep-&gt;width; x++ ) {
		if( coeff[x] &gt; max )
			max = coeff[x];
		if( coeff[x] &lt; min )
			min = coeff[x];
	}

	/* The zero axis must fall on a layer boundary. Estimate the
	 * depth, find n-lines-above-zero, get exact depth, then calculate a
	 * fixed n-lines which includes any negative parts.
	 */
	depth = (max - min) / convasep-&gt;layers;
	layers_above = ceil( max / depth );
	depth = max / layers_above;
	layers_below = floor( min / depth );
	layers = layers_above - layers_below;

	VIPS_DEBUG_MSG( "depth = %g, layers = %d\n", depth, layers );

	/* For each layer, generate a set of lines which are inside the
	 * perimeter. Work down from the top.
	 */
	for( z = 0; z &lt; layers; z++ ) {
		double y = max - (1 + z) * depth;

		/* y plus half depth ... ie. the layer midpoint.
		 */
		double y_ph = y + depth / 2;

		/* Odd, but we must avoid rounding errors that make us miss 0
		 * in the line above.
		 */
		int y_positive = z &lt; layers_above;

		int inside;

		/* Start outside the perimeter.
		 */
		inside = 0;

		for( x = 0; x &lt; convasep-&gt;width; x++ ) {
			/* The vertical line from mask[z] to 0 is inside. Is
			 * our current square (x, y) part of that line?
			 */
			if( (y_positive &amp;&amp; coeff[x] &gt;= y_ph) ||
				(!y_positive &amp;&amp; coeff[x] &lt;= y_ph) ) {
				if( !inside ) {
					vips_convasep_line_start( convasep, x, 
						y_positive ? 1 : -1 );
					inside = 1;
				}
			}
			else if( inside ) {
				if( vips_convasep_line_end( convasep, x ) )
					return( -1 );
				inside = 0;
			}
		}

		if( inside &amp;&amp; 
			vips_convasep_line_end( convasep, convasep-&gt;width ) )
			return( -1 );
	}

	/* Can we common up any lines? Search for lines with identical
	 * start/end.
	 */
	for( z = 0; z &lt; convasep-&gt;n_lines; z++ ) {
		for( n = z + 1; n &lt; convasep-&gt;n_lines; n++ ) {
			if( convasep-&gt;start[z] == convasep-&gt;start[n] &amp;&amp;
				convasep-&gt;end[z] == convasep-&gt;end[n] ) {
				convasep-&gt;factor[z] += convasep-&gt;factor[n];

				/* n can be deleted. Do this in a separate
				 * pass below.
				 */
				convasep-&gt;factor[n] = 0;
			}
		}
	}

	/* Now we can remove all factor 0 lines.
	 */
	for( z = 0; z &lt; convasep-&gt;n_lines; z++ ) {
		if( convasep-&gt;factor[z] == 0 ) {
			for( x = z; x &lt; convasep-&gt;n_lines; x++ ) {
				convasep-&gt;start[x] = convasep-&gt;start[x + 1];
				convasep-&gt;end[x] = convasep-&gt;end[x + 1];
				convasep-&gt;factor[x] = convasep-&gt;factor[x + 1];
			}
			convasep-&gt;n_lines -= 1;
		}
	}

	/* Find the area of the lines.
	 */
	area = 0;
	for( z = 0; z &lt; convasep-&gt;n_lines; z++ ) 
		area += convasep-&gt;factor[z] * 
			(convasep-&gt;end[z] - convasep-&gt;start[z]);

	/* Strength reduction: if all lines are divisible by n, we can move
	 * that n out into the -&gt;area factor. The aim is to produce as many
	 * factor 1 lines as we can and to reduce the chance of overflow.
	 */
	x = convasep-&gt;factor[0];
	for( z = 1; z &lt; convasep-&gt;n_lines; z++ ) 
		x = gcd( x, convasep-&gt;factor[z] );
	for( z = 0; z &lt; convasep-&gt;n_lines; z++ ) 
		convasep-&gt;factor[z] /= x;
	area *= x;

	/* Find the area of the original mask.
	 */
	sum = 0;
	for( z = 0; z &lt; convasep-&gt;width; z++ ) 
		sum += coeff[z];

	convasep-&gt;divisor = VIPS_RINT( sum * area / scale );
	if( convasep-&gt;divisor == 0 )
		convasep-&gt;divisor = 1;
	convasep-&gt;rounding = (convasep-&gt;divisor + 1) / 2;
	convasep-&gt;offset = offset;

#ifdef DEBUG
	/* ASCII-art layer drawing.
	 */
	printf( "lines:\n" );
	for( z = 0; z &lt; convasep-&gt;n_lines; z++ ) {
		printf( "%3d - %2d x ", z, convasep-&gt;factor[z] );
		for( x = 0; x &lt; 55; x++ ) {
			int rx = x * (convasep-&gt;width + 1) / 55;

			if( rx &gt;= convasep-&gt;start[z] &amp;&amp; rx &lt; convasep-&gt;end[z] )
				printf( "#" );
			else
				printf( " " );
		}
		printf( " %3d .. %3d\n", convasep-&gt;start[z], convasep-&gt;end[z] );
	}
	printf( "divisor = %d\n", convasep-&gt;divisor );
	printf( "rounding = %d\n", convasep-&gt;rounding );
	printf( "offset = %d\n", convasep-&gt;offset );
#endif /*DEBUG*/

	return( 0 );
}

/* Our sequence value.
 */
typedef struct {
	VipsConvasep *convasep;

	VipsRegion *ir;		/* Input region */

	int *start;		/* Offsets for start and stop */
	int *end;

	/* The sums for each line. int for integer types, double for floating
	 * point types.
	 */
	int *isum;		
	double *dsum;		

	int last_stride;	/* Avoid recalcing offsets, if we can */
} VipsConvasepSeq;

/* Free a sequence value.
 */
static int
vips_convasep_stop( void *vseq, void *a, void *b )
{
	VipsConvasepSeq *seq = (VipsConvasepSeq *) vseq;

	VIPS_UNREF( seq-&gt;ir );
	VIPS_FREE( seq-&gt;start );
	VIPS_FREE( seq-&gt;end );
	VIPS_FREE( seq-&gt;isum );
	VIPS_FREE( seq-&gt;dsum );

	return( 0 );
}

/* Convolution start function.
 */
static void *
vips_convasep_start( VipsImage *out, void *a, void *b )
{
	VipsImage *in = (VipsImage *) a;
	VipsConvasep *convasep = (VipsConvasep *) b;

	VipsConvasepSeq *seq;

	if( !(seq = VIPS_NEW( out, VipsConvasepSeq )) )
		return( NULL );

	/* Init!
	 */
	seq-&gt;convasep = convasep;
	seq-&gt;ir = vips_region_new( in );
	seq-&gt;start = VIPS_ARRAY( NULL, convasep-&gt;n_lines, int );
	seq-&gt;end = VIPS_ARRAY( NULL, convasep-&gt;n_lines, int );
	seq-&gt;isum = NULL;
	seq-&gt;dsum = NULL;
	if( vips_band_format_isint( out-&gt;BandFmt ) )
		seq-&gt;isum = VIPS_ARRAY( NULL, convasep-&gt;n_lines, int );
	else
		seq-&gt;dsum = VIPS_ARRAY( NULL, convasep-&gt;n_lines, double );
	seq-&gt;last_stride = -1;

	if( !seq-&gt;ir || 
		!seq-&gt;start || 
		!seq-&gt;end || 
		(!seq-&gt;isum &amp;&amp; !seq-&gt;dsum) ) {
		vips_convasep_stop( seq, in, convasep );
		return( NULL );
	}

	return( seq );
}

#define CLIP_UCHAR( V ) \
G_STMT_START { \
	if( (V) &lt; 0 ) \
		(V) = 0; \
	else if( (V) &gt; UCHAR_MAX ) \
		(V) = UCHAR_MAX; \
} G_STMT_END

#define CLIP_CHAR( V ) \
G_STMT_START { \
	if( (V) &lt; SCHAR_MIN ) \
		(V) = SCHAR_MIN; \
	else if( (V) &gt; SCHAR_MAX ) \
		(V) = SCHAR_MAX; \
} G_STMT_END

#define CLIP_USHORT( V ) \
G_STMT_START { \
	if( (V) &lt; 0 ) \
		(V) = 0; \
	else if( (V) &gt; USHRT_MAX ) \
		(V) = USHRT_MAX; \
} G_STMT_END

#define CLIP_SHORT( V ) \
G_STMT_START { \
	if( (V) &lt; SHRT_MIN ) \
		(V) = SHRT_MIN; \
	else if( (V) &gt; SHRT_MAX ) \
		(V) = SHRT_MAX; \
} G_STMT_END

#define CLIP_NONE( V ) {}

/* The h and v loops are very similar, but also annoyingly different. Keep
 * them separate for easy debugging.
 */

#define HCONV_INT( TYPE, CLIP ) { \
	for( i = 0; i &lt; bands; i++ ) { \
		int *isum = seq-&gt;isum; \
		\
		TYPE *q; \
		TYPE *p; \
		int sum; \
		\
		p = i + (TYPE *) VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y ); \
		q = i + (TYPE *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ); \
		\
		sum = 0; \
		for( z = 0; z &lt; n_lines; z++ ) { \
			isum[z] = 0; \
			for( x = seq-&gt;start[z]; x &lt; seq-&gt;end[z]; x += istride ) \
				isum[z] += p[x]; \
			sum += convasep-&gt;factor[z] * isum[z]; \
		} \
		\
		/* Don't add offset ... we only want to do that once, do it on \
		 * the vertical pass. \
		 */ \
		sum = (sum + convasep-&gt;rounding) / convasep-&gt;divisor; \
		CLIP( sum ); \
		*q = sum; \
		q += ostride; \
		\
		for( x = 1; x &lt; r-&gt;width; x++ ) {  \
			sum = 0; \
			for( z = 0; z &lt; n_lines; z++ ) { \
				isum[z] += p[seq-&gt;end[z]]; \
				isum[z] -= p[seq-&gt;start[z]]; \
				sum += convasep-&gt;factor[z] * isum[z]; \
			} \
			p += istride; \
			sum = (sum + convasep-&gt;rounding) / convasep-&gt;divisor; \
			CLIP( sum ); \
			*q = sum; \
			q += ostride; \
		} \
	} \
}

#define HCONV_FLOAT( TYPE ) { \
	for( i = 0; i &lt; bands; i++ ) { \
		double *dsum = seq-&gt;dsum; \
		\
		TYPE *q; \
		TYPE *p; \
		double sum; \
		\
		p = i + (TYPE *) VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y ); \
		q = i + (TYPE *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y ); \
		\
		sum = 0; \
		for( z = 0; z &lt; n_lines; z++ ) { \
			dsum[z] = 0; \
			for( x = seq-&gt;start[z]; x &lt; seq-&gt;end[z]; x += istride ) \
				dsum[z] += p[x]; \
			sum += convasep-&gt;factor[z] * dsum[z]; \
		} \
		\
		/* Don't add offset ... we only want to do that once, do it on \
		 * the vertical pass. \
		 */ \
		sum = sum / convasep-&gt;divisor; \
		*q = sum; \
		q += ostride; \
		\
		for( x = 1; x &lt; r-&gt;width; x++ ) {  \
			sum = 0; \
			for( z = 0; z &lt; n_lines; z++ ) { \
				dsum[z] += p[seq-&gt;end[z]]; \
				dsum[z] -= p[seq-&gt;start[z]]; \
				sum += convasep-&gt;factor[z] * dsum[z]; \
			} \
			p += istride; \
			sum = sum / convasep-&gt;divisor; \
			*q = sum; \
			q += ostride; \
		} \
	} \
}

/* Do horizontal masks ... we scan the mask along scanlines.
 */
static int
vips_convasep_generate_horizontal( VipsRegion *or, 
	void *vseq, void *a, void *b, gboolean *stop )
{
	VipsConvasepSeq *seq = (VipsConvasepSeq *) vseq;
	VipsImage *in = (VipsImage *) a;
	VipsConvasep *convasep = (VipsConvasep *) b;
	VipsConvolution *convolution = (VipsConvolution *) convasep;

	VipsRegion *ir = seq-&gt;ir;
	const int n_lines = convasep-&gt;n_lines;
	VipsRect *r = &amp;or-&gt;valid;

	/* Double the bands (notionally) for complex.
	 */
	int bands = vips_band_format_iscomplex( in-&gt;BandFmt ) ? 
		2 * in-&gt;Bands : in-&gt;Bands;

	VipsRect s;
	int x, y, z, i;
	int istride;
	int ostride;

	/* Prepare the section of the input image we need. A little larger
	 * than the section of the output image we are producing.
	 */
	s = *r;
	s.width += convasep-&gt;width - 1;
	if( vips_region_prepare( ir, &amp;s ) )
		return( -1 );

	/* Stride can be different for the vertical case, keep this here for
	 * ease of direction change.
	 */
	istride = VIPS_IMAGE_SIZEOF_PEL( in ) / 
		VIPS_IMAGE_SIZEOF_ELEMENT( in );
	ostride = VIPS_IMAGE_SIZEOF_PEL( convolution-&gt;out ) / 
		VIPS_IMAGE_SIZEOF_ELEMENT( convolution-&gt;out );

        /* Init offset array. 
	 */
	if( seq-&gt;last_stride != istride ) {
		seq-&gt;last_stride = istride;

		for( z = 0; z &lt; n_lines; z++ ) {
			seq-&gt;start[z] = convasep-&gt;start[z] * istride;
			seq-&gt;end[z] = convasep-&gt;end[z] * istride;
		}
	}

	for( y = 0; y &lt; r-&gt;height; y++ ) { 
		switch( in-&gt;BandFmt ) {
		case VIPS_FORMAT_UCHAR: 	
			HCONV_INT( unsigned char, CLIP_UCHAR );
			break;

		case VIPS_FORMAT_CHAR: 	
			HCONV_INT( signed char, CLIP_CHAR );
			break;

		case VIPS_FORMAT_USHORT: 	
			HCONV_INT( unsigned short, CLIP_USHORT );
			break;

		case VIPS_FORMAT_SHORT: 	
			HCONV_INT( signed short, CLIP_SHORT );
			break;

		case VIPS_FORMAT_UINT: 	
			HCONV_INT( unsigned int, CLIP_NONE );
			break;

		case VIPS_FORMAT_INT: 	
			HCONV_INT( signed int, CLIP_NONE );
			break;

		case VIPS_FORMAT_FLOAT: 	
		case VIPS_FORMAT_COMPLEX: 	
			HCONV_FLOAT( float );
			break;

		case VIPS_FORMAT_DOUBLE: 	
		case VIPS_FORMAT_DPCOMPLEX: 	
			HCONV_FLOAT( double );
			break;
<a name="0"></a>
		default:
			g_assert_not_reached();
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		}
	}

	return( 0 );
}

#define VCONV_INT( TYPE, CLIP ) { \
	for( x = 0; x &lt; sz; x++ ) { \
		int *isum = seq-&gt;isum; \
		\
		TYPE *q; \
		TYPE *p; \
		int sum; \
		\
		p = x + (TYPE *) VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top ); \
		q = x + (TYPE *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top ); \
		\
		sum = 0; \
		for( z = 0; z &lt; n_lines; z++ ) { \
			isum[z] = 0; \
			for( y = seq-&gt;start[z]; y &lt; seq-&gt;end[z]; y += istride ) \
				isum[z] += p[y]; \
			sum += convasep-&gt;factor[z] * isum[z]; \
		} \
		sum = (sum + convasep-&gt;rounding) / convasep-&gt;divisor + \
			convasep-&gt;offset; \
		CLIP( sum ); \
		*q = sum; \
		q += ostride; \
		\
		for( y = 1; y &lt; r-&gt;height; y++ ) { \
			sum = 0; \
			for( z = 0; z &lt; n_lines; z++ ) { \
				isum[z] += p[seq-&gt;end[z]]; \
				isum[z] -= p[seq-&gt;start[z]]; \
				sum += convasep-&gt;factor[z] * isum[z]; \
			} \
			p += istride; \
			sum = (sum + convasep-&gt;rounding) / convasep-&gt;divisor + \
				convasep-&gt;offset; \
			CLIP( sum ); \
			*q = sum; \
			q += ostride; \
		} \
	} \
}

#define VCONV_FLOAT( TYPE ) { \
	for( x = 0; x &lt; sz; x++ ) { \
		double *dsum = seq-&gt;dsum; \
		\
		TYPE *q; \
		TYPE *p; \
		double sum; \
		\
		p = x + (TYPE *) VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top ); \
		q = x + (TYPE *) VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top ); \
		\
		sum = 0; \
		for( z = 0; z &lt; n_lines; z++ ) { \
			dsum[z] = 0; \
			for( y = seq-&gt;start[z]; y &lt; seq-&gt;end[z]; y += istride ) \
				dsum[z] += p[y]; \
			sum += convasep-&gt;factor[z] * dsum[z]; \
		} \
		sum = sum / convasep-&gt;divisor + convasep-&gt;offset; \
		*q = sum; \
		q += ostride; \
		\
		for( y = 1; y &lt; r-&gt;height; y++ ) { \
			sum = 0; \
			for( z = 0; z &lt; n_lines; z++ ) { \
				dsum[z] += p[seq-&gt;end[z]]; \
				dsum[z] -= p[seq-&gt;start[z]]; \
				sum += convasep-&gt;factor[z] * dsum[z]; \
			} \
			p += istride; \
			sum = sum / convasep-&gt;divisor + convasep-&gt;offset; \
			*q = sum; \
			q += ostride; \
		} \
	} \
}

/* Do vertical masks ... we scan the mask down columns of pixels. Copy-paste
 * from above with small changes.
 */
static int
vips_convasep_generate_vertical( VipsRegion *or, 
	void *vseq, void *a, void *b, gboolean *stop )
{
	VipsConvasepSeq *seq = (VipsConvasepSeq *) vseq;
	VipsImage *in = (VipsImage *) a;</b></font>
	VipsConvasep *convasep = (VipsConvasep *) b;
	VipsConvolution *convolution = (VipsConvolution *) convasep;

	VipsRegion *ir = seq-&gt;ir;
	const int n_lines = convasep-&gt;n_lines;
	VipsRect *r = &amp;or-&gt;valid;

	/* Double the width (notionally) for complex.
	 */
	int sz = vips_band_format_iscomplex( in-&gt;BandFmt ) ? 
		2 * VIPS_REGION_N_ELEMENTS( or ) : VIPS_REGION_N_ELEMENTS( or );

	VipsRect s;
	int x, y, z;
	int istride;
	int ostride;

	/* Prepare the section of the input image we need. A little larger
	 * than the section of the output image we are producing.
	 */
	s = *r;
	s.height += convasep-&gt;width - 1;
	if( vips_region_prepare( ir, &amp;s ) )
		return( -1 );

	/* Stride can be different for the vertical case, keep this here for
	 * ease of direction change.
	 */
	istride = VIPS_REGION_LSKIP( ir ) / VIPS_IMAGE_SIZEOF_ELEMENT( in );
	ostride = VIPS_REGION_LSKIP( or ) / 
		VIPS_IMAGE_SIZEOF_ELEMENT( convolution-&gt;out );

        /* Init offset array. 
	 */
	if( seq-&gt;last_stride != istride ) {
		seq-&gt;last_stride = istride;

		for( z = 0; z &lt; n_lines; z++ ) {
			seq-&gt;start[z] = convasep-&gt;start[z] * istride;
			seq-&gt;end[z] = convasep-&gt;end[z] * istride;
		}
	}

	switch( in-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR: 	
		VCONV_INT( unsigned char, CLIP_UCHAR );
		break;

	case VIPS_FORMAT_CHAR: 	
		VCONV_INT( signed char, CLIP_CHAR );
		break;

	case VIPS_FORMAT_USHORT: 	
		VCONV_INT( unsigned short, CLIP_USHORT );
		break;

	case VIPS_FORMAT_SHORT: 	
		VCONV_INT( signed short, CLIP_SHORT );
		break;

	case VIPS_FORMAT_UINT: 	
		VCONV_INT( unsigned int, CLIP_NONE );
		break;

	case VIPS_FORMAT_INT: 	
		VCONV_INT( signed int, CLIP_NONE );
		break;

	case VIPS_FORMAT_FLOAT: 	
	case VIPS_FORMAT_COMPLEX: 	
		VCONV_FLOAT( float );
		break;

	case VIPS_FORMAT_DOUBLE: 	
	case VIPS_FORMAT_DPCOMPLEX: 	
		VCONV_FLOAT( double );
		break;

	default:
		g_assert_not_reached();
	}

	return( 0 );
}

static int
vips_convasep_pass( VipsConvasep *convasep, 
	VipsImage *in, VipsImage **out, VipsDirection direction )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( convasep );

	VipsGenerateFn gen;

	*out = vips_image_new(); 
	if( vips_image_pipelinev( *out, 
		VIPS_DEMAND_STYLE_SMALLTILE, in, NULL ) )
		return( -1 );

	if( direction == VIPS_DIRECTION_HORIZONTAL ) { 
		(*out)-&gt;Xsize -= convasep-&gt;width - 1;
		gen = vips_convasep_generate_horizontal;
	}
	else {
		(*out)-&gt;Ysize -= convasep-&gt;width - 1;
		gen = vips_convasep_generate_vertical;
	}

	if( (*out)-&gt;Xsize &lt;= 0 || 
		(*out)-&gt;Ysize &lt;= 0 ) {
		vips_error( class-&gt;nickname, 
			"%s", _( "image too small for mask" ) );
		return( -1 );
	}

	if( vips_image_generate( *out, 
		vips_convasep_start, gen, vips_convasep_stop, in, convasep ) )
		return( -1 );

	return( 0 );
}

static int 
vips_convasep_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsConvolution *convolution = (VipsConvolution *) object;
	VipsConvasep *convasep = (VipsConvasep *) object;
	VipsImage **t = (VipsImage **) vips_object_local_array( object, 4 );

	VipsImage *in;

	if( VIPS_OBJECT_CLASS( vips_convasep_parent_class )-&gt;build( object ) )
		return( -1 );

	if( vips_check_separable( class-&gt;nickname, convolution-&gt;M ) ) 
                return( -1 );

	/* An int version of our mask.
	 */
	if( vips__image_intize( convolution-&gt;M, &amp;t[3] ) )
		return( -1 );
	convasep-&gt;iM = t[3]; 
	convasep-&gt;width = convasep-&gt;iM-&gt;Xsize * convasep-&gt;iM-&gt;Ysize;
	in = convolution-&gt;in;

	if( vips_convasep_decompose( convasep ) )
		return( -1 ); 

	g_object_set( convasep, "out", vips_image_new(), NULL ); 
	if( 
		vips_embed( in, &amp;t[0], 
			convasep-&gt;width / 2, 
			convasep-&gt;width / 2, 
			in-&gt;Xsize + convasep-&gt;width - 1, 
			in-&gt;Ysize + convasep-&gt;width - 1,
			"extend", VIPS_EXTEND_COPY,
			NULL ) ||
		vips_convasep_pass( convasep, 
			t[0], &amp;t[1], VIPS_DIRECTION_HORIZONTAL ) ||
		vips_convasep_pass( convasep, 
			t[1], &amp;t[2], VIPS_DIRECTION_VERTICAL ) ||
		vips_image_write( t[2], convolution-&gt;out ) )
		return( -1 );

	convolution-&gt;out-&gt;Xoffset = 0;
	convolution-&gt;out-&gt;Yoffset = 0;

	vips_reorder_margin_hint( convolution-&gt;out,
		convolution-&gt;M-&gt;Xsize * convolution-&gt;M-&gt;Ysize );

	return( 0 );
}

static void
vips_convasep_class_init( VipsConvasepClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = "convasep";
	object_class-&gt;description = 
		_( "approximate separable integer convolution" );
	object_class-&gt;build = vips_convasep_build;

	VIPS_ARG_INT( class, "layers", 104, 
		_( "Layers" ), 
		_( "Use this many layers in approximation" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT, 
		G_STRUCT_OFFSET( VipsConvasep, layers ), 
		1, 1000, 5 ); 

}

static void
vips_convasep_init( VipsConvasep *convasep )
{
        convasep-&gt;layers = 5;
	convasep-&gt;n_lines = 0;
}

/**
 * vips_convasep: (method)
 * @in: input image
 * @out: (out): output image
 * @mask: convolve with this mask
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @layers: %gint, number of layers for approximation
 *
 * Approximate separable integer convolution. This is a low-level operation, see 
 * vips_convsep() for something more convenient. 
 *
 * The image is convolved twice: once with @mask and then again with @mask 
 * rotated by 90 degrees. 
 * @mask must be 1xn or nx1 elements. 
 * Elements of @mask are converted to
 * integers before convolution.
 *
 * Larger values for @layers give more accurate
 * results, but are slower. As @layers approaches the mask radius, the
 * accuracy will become close to exact convolution and the speed will drop to 
 * match. For many large masks, such as Gaussian, @layers need be only 10% of
 * this value and accuracy will still be good.
 *
 * The output image 
 * always has the same #VipsBandFormat as the input image. 
 *
 * See also: vips_convsep().
 *
 * Returns: 0 on success, -1 on error
 */
int 
vips_convasep( VipsImage *in, VipsImage **out, VipsImage *mask, ... )
{
	va_list ap;
	int result;

	va_start( ap, mask );
	result = vips_call_split( "convasep", ap, in, out, mask );
	va_end( ap );

	return( result );
}

</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tiff2vips.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* TIFF parts: Copyright (c) 1988, 1990 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 * -----------------------------
 * Modifications for VIPS:  Kirk Martinez 1994
 * 22/11/94 JC
 *	- more general
 *	- memory leaks fixed
 * 20/3/95 JC
 *	- TIFF error handler added
 *	- read errors detected correctly
 *
 * Modified to handle LAB in tiff format.
 * It convert LAB-tiff format to VIPS_INTERPRETATION_LABQ in vips format.
 *  Copyright July-1995 Ahmed Abbood.
 *
 *
 * 19/9/95 JC
 *	- now calls TIFFClose ... stupid
 * 25/1/96 JC
 *	- typo on MINISBLACK ...
 * 7/4/97 JC
 *	- completely redone for TIFF 6
 *	- now full baseline TIFF 6 reader, and does CIELAB as well
 * 11/4/97 JC
 *	- added partial read for tiled images
 * 23/4/97 JC
 *	- extra subsample parameter
 *	- im_istiffpyramid() added
 * 5/12/97 JC
 *	- if loading YCbCr, convert to VIPS_CODING_LABQ
 * 1/5/98 JC
 *	- now reads 16-bit greyscale and RGB
 * 26/10/98 JC
 *	- now used "rb" mode on systems that need binary open
 * 12/11/98 JC
 *	- no sub-sampling if sub == 1
 * 26/2/99 JC
 *	- ooops, else missing for subsample stuff above
 * 2/10/99 JC
 *	- tiled 16-bit greyscale read was broken
 *	- added mutex for TIFFReadTile() calls
 * 11/5/00 JC
 *	- removed TIFFmalloc/TIFFfree usage
 * 23/4/01 JC
 *	- HAVE_TIFF turns on TIFF goodness
 * 24/5/01 JC
 *	- im_tiff2vips_header() added
 * 11/7/01 JC
 *	- subsample now in input filename
 *	- ... and it's a page number (from 0) instead
 * 21/8/02 JC
 *	- now reads CMYK
 *	- hmm, dpi -&gt; ppm conversion was wrong!
 * 10/9/02 JC
 *	- oops, handle TIFF errors better
 * 2/12/02 JC
 *	- reads 8-bit RGBA
 * 12/12/02 JC
 *	- reads 16-bit LAB
 * 13/2/03 JC
 *	- pixels/cm res read was wrong
 * 17/11/03 Andrey Kiselev
 *	- read 32-bit float greyscale and rgb
 * 5/4/04
 *	- better handling of edge tiles (thanks Ruven)
 * 16/4/04
 *	- cleanup
 *	- added broken tile read mode
 * 18/5/04 Andrey Kiselev
 *	- better no resolution diagnostic
 * 26/5/04
 *	- reads 16 bit RGBA
 * 28/7/04
 *	- arrg, 16bit RGB was broken, thanks haida
 * 26/11/04
 *	- add a TIFF warning handler, stops occasional libMagick exceptions
 * 9/3/05
 *	- load 32-bit float LAB
 * 8/4/05
 *	- onebit read no longer reads one byte too many on multiple of 8 wide
 *	  images
 * 22/6/05
 *	- 16 bit LAB read was broken
 * 9/9/05
 * 	- read any ICCPROFILE tag
 * 8/5/06
 * 	- set RGB16 and GREY16 Type
 * 21/5/06
 * 	- use external im_tile_cache() operation for great code shrinkage
 * 	- less RAM usage too, esp. with &gt;1 CPU
 * 	- should be slightly faster
 * 	- removed 'broken' read option
 * 18/7/07 Andrey Kiselev
 * 	- remove "b" option on TIFFOpen()
 * 9/4/08
 * 	- set VIPS_META_RESOLUTION_UNIT
 * 17/4/08
 * 	- allow CMYKA (thanks Doron)
 * 17/7/08
 * 	- convert YCbCr to RGB on read (thanks Ole)
 * 15/8/08
 * 	- reorganise for image format system
 * 20/12/08
 * 	- dont read with mmap: no performance advantage with libtiff, chews up 
 * 	  VM wastefully
 * 13/1/09
 * 	- read strip-wise, not scanline-wise ... works with more compression /
 * 	  subsampling schemes (esp. subsampled YCbCr), and it's a bit quicker
 * 4/2/10
 * 	- gtkdoc
 * 12/12/10
 * 	- oops, we can just memcpy() now heh
 * 	- avoid unpacking via buffers if we can: either read a tile directly
 * 	  into the output region, or writeline directly from the tiff buffer
 * 4/4/11
 * 	- argh int/uint mixup for rows_per_strip, thanks Bubba
 * 21/4/11
 * 	- palette read can do 1,2,4,8 bits per sample
 * 	- palette read can do mono images
 * 5/12/11
 * 	- make into a simple function call ready to be wrapped as a new-style
 * 	  VipsForeign class
 * 18/2/12
 * 	- switch to sequential read
 * 	- remove the lock ... tilecache does this for us
 * 3/6/12
 * 	- always offer THINSTRIP ... later stages can ask for something more
 * 	  relaxed if they wish
 * 7/6/12
 * 	- clip rows_per_strip down to image height to avoid overflows for huge
 * 	  values (thanks Nicolas)
 * 	- better error msg for not PLANARCONFIG_CONTIG images
 * 16/9/13
 * 	- support alpha for 8, 16 and 32-bit greyscale images, thanks Robert
 * 17/9/13
 * 	- support separate planes for strip read
 * 	- big cleanup
 * 	- support for many more formats, eg. 32-bit int etc. 
 * 11/4/14
 * 	- support 16 bits per sample palette images
 * 	- palette images can have an alpha
 * 22/4/14
 * 	- add read from buffer
 * 30/4/14
 * 	- 1/2/4 bit palette images can have alpha
 * 27/10/14 Lovell
 * 	- better istiff detector spots bigtiff
 * 3/12/14
 * 	- read any XMP metadata
 * 19/1/15
 * 	- try to handle 8-bit colormaps
 * 26/2/15
 * 	- close the read down early for a header read ... this saves an
 * 	  fd during file read, handy for large numbers of input images 
 * 29/9/15
 * 	- load IPTC metadata
 * 	- load photoshop metadata
 * 21/12/15
 * 	- load TIFFTAG_IMAGEDESCRIPTION
 * 11/4/16
 * 	- non-int RGB images are tagged as scRGB ... matches photoshop
 * 	  convention
 * 26/5/16
 * 	- add autorotate support
 * 17/11/16
 * 	- add multi-page read 
 * 17/1/17
 * 	- invalidate operation on read error
 * 27/1/17
 * 	- if rows_per_strip is large, read with scanline API instead
 * 9/5/17
 * 	- remove missing res warning
 * 19/5/17
 * 	- page &gt; 0 could break edge tiles or strips
 * 26/4/18
 * 	- add n-pages metadata item
 * 21/7/18
 * 	- check for non-byte-multiple bits_per_sample [HongxuChen]
 * 16/8/18
 * 	- shut down the input file as soon as we can [kleisauke]
 * 28/3/19 omira-sch
 * 	- better buffer sizing 
 * 	- ban chroma-subsampled, non-jpg compressed images
 * 7/6/19
 * 	- istiff reads the first directory rather than just testing the magic
 * 	  number, so it ignores more TIFF-like, but not TIFF images
 * 17/10/19
 * 	- switch to source input
 * 18/11/19
 * 	- support ASSOCALPHA in any alpha band
 * 27/1/20
 * 	- read logluv images as XYZ
 * 11/4/20 petoor 
 * 	- better handling of aligned reads in multipage tiffs
 * 28/5/20
 * 	- add subifd
 * 6/6/20 MathemanFlo
 * 	- support 2 and 4 bit greyscale load
 * 27/3/21
 * 	- add jp2k decompresion
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/* 
#define DEBUG_VERBOSE
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#ifdef HAVE_TIFF

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/thread.h&gt;

#include "pforeign.h"
#include "tiff.h"

/* Aperio TIFFs (svs) use these compression types for jp2k-compressed tiles.
 */
#define JP2K_YCC 33003
#define JP2K_RGB 33005

/* Bioformats uses this tag for jp2k compressed tiles.
 */
#define JP2K_LOSSY 33004

/* Compression types we handle ourselves.
 */
static int rtiff_we_decompress[] = {
<a name="1"></a>	JP2K_YCC,
	JP2K_RGB,
	JP2K_LOSSY
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>};

/* What we read from the tiff dir to set our read strategy. For multipage
 * read, we need to read and compare lots of these, so it needs to be broken
 * out as a separate thing.
 */
typedef struct _RtiffHeader {
	uint32 width;
	uint32 height;
	int samples_per_pixel;
	int bits_per_sample;
	int photometric_interpretation;
	int inkset;
	int sample_format;
	gboolean separate; 
	int orientation; 

	/* If there's a premultiplied alpha, the band we need to 
	 * unpremultiply with. -1 for no unpremultiplication.
	 */
	int alpha_band;
	uint16 compression;

	/* Is this directory tiled.
	 */
	gboolean tiled;

	/* Fields for tiled images, as returned by libtiff.
	 */
	uint32 tile_width;
	uint32 tile_height;		
	tsize_t tile_size;
	tsize_t tile_row_size;

	/* Fields for strip images, as returned by libtiff.
	 */
	uint32 rows_per_strip;
	tsize_t strip_size;
	tsize_t scanline_size;
	int number_of_strips;</b></font>

	/* If read_scanlinewise is TRUE, the strips are too large to read in a
	 * single lump and we will use the scanline API.
	 */
	gboolean read_scanlinewise;

	/* Strip read geometry. Number of lines we read at once (whole strip
	 * or 1) and size of the buffer we read to (a scanline, or a strip in
	 * size).
	 */
	uint32 read_height;
	tsize_t read_size;

	/* Scale factor to get absolute cd/m2 from XYZ.
	 */
	double stonits;

	/* Number of subifds, 0 for none.
	 */
	int subifd_count;

	/* Optional IMAGEDESCRIPTION.
	 */
	char *image_description;

	/* TRUE if the compression type is not supported by libtiff directly
	 * and we must read the raw data and decompress ourselves.
	 */
	gboolean we_decompress;

} RtiffHeader;

/* Scanline-type process function.
 */
struct _Rtiff;
typedef void (*scanline_process_fn)( struct _Rtiff *, 
	VipsPel *q, VipsPel *p, int n, void *client );

/* Stuff we track during a read.
 */
typedef struct _Rtiff {
	/* Parameters.
	 */
	VipsSource *source;
	VipsImage *out;
	int page;
	int n;
	gboolean autorotate;
	int subifd;

	/* The TIFF we read.
	 */
	TIFF *tiff;

	/* Number of pages (directories) in image.
	 */
	int n_pages;

	/* The current page we have set.
	 */
	int current_page;

	/* Process for this image type.
	 */
	scanline_process_fn sfn;
	void *client;

	/* Set this is the processfn is just doing a memcpy.
	 */
	gboolean memcpy;

	/* Geometry as read from the TIFF header. This is read for the first
	 * page, and equal for all other pages. 
	 */
	RtiffHeader header; 

	/* Hold a single strip or tile, possibly just an image plane.
	 */
	tdata_t plane_buf;

	/* Hold a plane-assembled strip or tile ... a set of samples_per_pixel 
	 * strips or tiles interleaved. 
	 */
	tdata_t contig_buf;

	/* If we are decompressing, we need a buffer to read the raw tile to
	 * before running the decompressor.
	 */
	tdata_t compressed_buf;
	tsize_t compressed_buf_length;

	/* The Y we are reading at. Used to verify strip read is sequential.
	 */
	int y_pos;
} Rtiff;

/* Test for field exists.
 */
static int
tfexists( TIFF *tif, ttag_t tag )
{
	uint32 a, b;

	if( TIFFGetField( tif, tag, &amp;a, &amp;b ) ) 
		return( 1 );
	else 
		return( 0 );
}

/* Get a uint32 field. 
 */
static int
tfget32( TIFF *tif, ttag_t tag, uint32 *out )
{
	uint32 fld;

	if( !TIFFGetFieldDefaulted( tif, tag, &amp;fld ) ) {
		vips_error( "tiff2vips", 
			_( "required field %d missing" ), tag );
		return( 0 );
	}

	*out = fld;

	return( 1 );
}

/* Get a uint16 field.
 */
static int
tfget16( TIFF *tif, ttag_t tag, int *out )
{
	uint16 fld;

	if( !TIFFGetFieldDefaulted( tif, tag, &amp;fld ) ) {
		vips_error( "tiff2vips", 
			_( "required field %d missing" ), tag );
		return( 0 );
	}

	*out = fld;

	return( 1 );
}

static int
get_resolution( TIFF *tiff, VipsImage *out )
{
	float x, y;
	int ru;

	if( TIFFGetFieldDefaulted( tiff, TIFFTAG_XRESOLUTION, &amp;x ) &amp;&amp;
		TIFFGetFieldDefaulted( tiff, TIFFTAG_YRESOLUTION, &amp;y ) &amp;&amp;
		tfget16( tiff, TIFFTAG_RESOLUTIONUNIT, &amp;ru ) ) {
		switch( ru ) {
		case RESUNIT_NONE:
			break;

		case RESUNIT_INCH:
			/* In pixels-per-inch ... convert to mm.
			 */
			x /= 10.0 * 2.54;
			y /= 10.0 * 2.54;
			vips_image_set_string( out, 
				VIPS_META_RESOLUTION_UNIT, "in" );
			break;

		case RESUNIT_CENTIMETER:
			/* In pixels-per-centimetre ... convert to mm.
			 */
			x /= 10.0;
			y /= 10.0;
			vips_image_set_string( out, 
				VIPS_META_RESOLUTION_UNIT, "cm" );
			break;

		default:
			vips_error( "tiff2vips", 
				"%s", _( "unknown resolution unit" ) );
			return( -1 );
		}
	}
	else {
		/* We used to warn about missing res data, but it happens so
		 * often and is so harmless, why bother.
		 */
		x = 1.0;
		y = 1.0;
	}

	out-&gt;Xres = x;
	out-&gt;Yres = y;

	return( 0 );
}

static int
get_sample_format( TIFF *tiff )
{
	int sample_format;
	uint16 v;

	sample_format = SAMPLEFORMAT_INT;

	if( TIFFGetFieldDefaulted( tiff, TIFFTAG_SAMPLEFORMAT, &amp;v ) ) {
		/* Some images have this set to void, bizarre.
		 */
		if( v == SAMPLEFORMAT_VOID )
			v = SAMPLEFORMAT_UINT;

		sample_format = v;
	}

	return( sample_format ); 
}

static int
get_orientation( TIFF *tiff )
{
	int orientation;
	uint16 v;

	orientation = ORIENTATION_TOPLEFT;

	if( TIFFGetFieldDefaulted( tiff, TIFFTAG_ORIENTATION, &amp;v ) ) 
		/* Can have mad values. 
		 */
		orientation = VIPS_CLIP( 1, v, 8 );

	return( orientation );
}

/* Can be called many times.
 */
static void
rtiff_free( Rtiff *rtiff )
{
	VIPS_FREEF( TIFFClose, rtiff-&gt;tiff );
	VIPS_UNREF( rtiff-&gt;source );
}

static void
rtiff_close_cb( VipsImage *image, Rtiff *rtiff )
{
	rtiff_free( rtiff ); 
}

static void
rtiff_minimise_cb( VipsImage *image, Rtiff *rtiff )
{
	/* We must not minimised tiled images. These can be read from many
	 * threads, and this minimise handler is not inside the lock that our
	 * tilecache is using to guarantee single-threaded access to our
	 * source.
	 */
	if( !rtiff-&gt;header.tiled &amp;&amp;
		rtiff-&gt;source )
		vips_source_minimise( rtiff-&gt;source );
}

static Rtiff *
rtiff_new( VipsSource *source, VipsImage *out, 
	int page, int n, gboolean autorotate, int subifd )
{
	Rtiff *rtiff;

	if( !(rtiff = VIPS_NEW( out, Rtiff )) )
		return( NULL );

	g_object_ref( source );
	rtiff-&gt;source = source;
	rtiff-&gt;out = out;
	rtiff-&gt;page = page;
	rtiff-&gt;n = n;
	rtiff-&gt;autorotate = autorotate;
	rtiff-&gt;subifd = subifd;
	rtiff-&gt;tiff = NULL;
	rtiff-&gt;n_pages = 0;
	rtiff-&gt;current_page = -1;
	rtiff-&gt;sfn = NULL;
	rtiff-&gt;client = NULL;
	rtiff-&gt;memcpy = FALSE;
	rtiff-&gt;plane_buf = NULL;
	rtiff-&gt;contig_buf = NULL;
	rtiff-&gt;y_pos = 0;

	g_signal_connect( out, "close", 
		G_CALLBACK( rtiff_close_cb ), rtiff ); 
	g_signal_connect( out, "minimise",
		G_CALLBACK( rtiff_minimise_cb ), rtiff ); 

	if( rtiff-&gt;page &lt; 0 || 
		rtiff-&gt;page &gt; 1000000 ) {
		vips_error( "tiff2vips", _( "bad page number %d" ),
			rtiff-&gt;page );
		return( NULL );
	}

	/* We allow n == -1, meaning all pages. It gets swapped for a real n
	 * value when we open the TIFF.
	 */
	if( rtiff-&gt;n != -1 &amp;&amp;
		(rtiff-&gt;n &lt; 1 || rtiff-&gt;n &gt; 1000000) ) {
		vips_error( "tiff2vips", _( "bad number of pages %d" ),
			rtiff-&gt;n );
		return( NULL );
	}

	if( !(rtiff-&gt;tiff = vips__tiff_openin_source( source )) )
		return( NULL );

	return( rtiff );
}

static int
rtiff_strip_read( Rtiff *rtiff, int strip, tdata_t buf )
{
	tsize_t length;

#ifdef DEBUG_VERBOSE
	printf( "rtiff_strip_read: reading strip %d\n", strip ); 
#endif /*DEBUG_VERBOSE*/

	if( rtiff-&gt;header.read_scanlinewise )  
		length = TIFFReadScanline( rtiff-&gt;tiff, 
			buf, strip, (tsample_t) 0 );
	else 
		length = TIFFReadEncodedStrip( rtiff-&gt;tiff, 
			strip, buf, (tsize_t) -1 );

	if( length == -1 ) {
		vips_foreign_load_invalidate( rtiff-&gt;out );
		vips_error( "tiff2vips", "%s", _( "read error" ) );
		return( -1 );
	}

	return( 0 );
}

/* We need to hint to libtiff what format we'd like pixels in.
 */
static void
rtiff_set_decode_format( Rtiff *rtiff )
{
	/* Ask for YCbCr-&gt;RGB for jpg data.
	 */
	if( rtiff-&gt;header.compression == COMPRESSION_JPEG )
		TIFFSetField( rtiff-&gt;tiff, 
			TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB );

	/* Ask for SGI LOGLUV as 3xfloat.
	 */
	if( rtiff-&gt;header.photometric_interpretation == 
		PHOTOMETRIC_LOGLUV ) 
		TIFFSetField( rtiff-&gt;tiff, 
			TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_FLOAT );
}

static int
rtiff_set_page( Rtiff *rtiff, int page )
{
	if( rtiff-&gt;current_page != page ) {
#ifdef DEBUG
		printf( "rtiff_set_page: selecting page %d, subifd %d\n", 
			page, rtiff-&gt;subifd ); 
#endif /*DEBUG*/

		if( !TIFFSetDirectory( rtiff-&gt;tiff, page ) ) {
			vips_error( "tiff2vips", 
				_( "TIFF does not contain page %d" ), page );
			return( -1 );
		}

		if( rtiff-&gt;subifd &gt;= 0 ) {
			uint16 subifd_count;
			toff_t *subifd_offsets;

			if( !TIFFGetField( rtiff-&gt;tiff, TIFFTAG_SUBIFD, 
				&amp;subifd_count, &amp;subifd_offsets ) ) {
				vips_error( "tiff2vips", 
					"%s", _( "no SUBIFD tag" ) );
				return( -1 );
			}

			if( rtiff-&gt;subifd &gt;= subifd_count ) {
				vips_error( "tiff2vips", 
					_( "subifd %d out of range, "
						"only 0-%d available" ),
					rtiff-&gt;subifd,
					subifd_count - 1 );
				return( -1 );
			}

			if( !TIFFSetSubDirectory( rtiff-&gt;tiff, 
				subifd_offsets[rtiff-&gt;subifd] ) ) { 
				vips_error( "tiff2vips", 
					"%s", _( "subdirectory unreadable" ) );
				return( -1 );
			}
		}

		rtiff-&gt;current_page = page;

		/* These can get unset when we change directories. Make sure
		 * they are set again.
		 */
		rtiff_set_decode_format( rtiff );
	}

	return( 0 );
}

static int
rtiff_n_pages( Rtiff *rtiff )
{
	int n;

	(void) TIFFSetDirectory( rtiff-&gt;tiff, 0 );

	for( n = 1; TIFFReadDirectory( rtiff-&gt;tiff ); n++ )
		;

	/* Make sure the nest set_page() will set the directory.
	 */
	rtiff-&gt;current_page = -1;

#ifdef DEBUG
	printf( "rtiff_n_pages: found %d pages\n", n ); 
#endif /*DEBUG*/

	return( n );
}

static int
rtiff_check_samples( Rtiff *rtiff, int samples_per_pixel )
{
	if( rtiff-&gt;header.samples_per_pixel != samples_per_pixel ) { 
		vips_error( "tiff2vips", 
			_( "not %d bands" ), samples_per_pixel ); 
		return( -1 );
	}

	return( 0 );
}

/* Check n and n+1 so we can have an alpha.
 */
static int
rtiff_check_min_samples( Rtiff *rtiff, int samples_per_pixel )
{
	if( rtiff-&gt;header.samples_per_pixel &lt; samples_per_pixel ) { 
		vips_error( "tiff2vips", 
			_( "not at least %d samples per pixel" ), 
			samples_per_pixel ); 
		return( -1 );
	}

	return( 0 );
}

/* Only allow samples which are whole bytes in size.  
 */
static int
rtiff_non_fractional( Rtiff *rtiff )
{
	if( rtiff-&gt;header.bits_per_sample % 8 != 0 ||
		rtiff-&gt;header.bits_per_sample == 0 ) {
		vips_error( "tiff2vips", "%s", _( "samples_per_pixel "
			"not a whole number of bytes" ) );
		return( -1 );
	}

	return( 0 );
}

static int
rtiff_check_interpretation( Rtiff *rtiff, int photometric_interpretation )
{
	if( rtiff-&gt;header.photometric_interpretation != 
		photometric_interpretation ) { 
		vips_error( "tiff2vips", 
			_( "not photometric interpretation %d" ), 
			photometric_interpretation ); 
		return( -1 );
	}

	return( 0 );
}

static int
rtiff_check_bits( Rtiff *rtiff, int bits_per_sample )
{
	if( rtiff-&gt;header.bits_per_sample != bits_per_sample ) { 
		vips_error( "tiff2vips", 
			_( "not %d bits per sample" ), bits_per_sample );
		return( -1 );
	}

	return( 0 );
}

static int
rtiff_check_bits_palette( Rtiff *rtiff )
{
	if( rtiff-&gt;header.bits_per_sample != 16 &amp;&amp; 
		rtiff-&gt;header.bits_per_sample != 8 &amp;&amp; 
		rtiff-&gt;header.bits_per_sample != 4 &amp;&amp; 
		rtiff-&gt;header.bits_per_sample != 2 &amp;&amp; 
		rtiff-&gt;header.bits_per_sample != 1 ) {
		vips_error( "tiff2vips", 
			_( "%d bits per sample palette image not supported" ),
			rtiff-&gt;header.bits_per_sample );
		return( -1 );
	}

	return( 0 );
}

static VipsBandFormat
rtiff_guess_format( Rtiff *rtiff )
{
	int bits_per_sample = rtiff-&gt;header.bits_per_sample;
	int sample_format = rtiff-&gt;header.sample_format;

	switch( bits_per_sample ) {
	case 1:
	case 2:
	case 4:
	case 8:
		if( sample_format == SAMPLEFORMAT_INT )
			return( VIPS_FORMAT_CHAR );
		if( sample_format == SAMPLEFORMAT_UINT )
			return( VIPS_FORMAT_UCHAR );
		break;

	case 16:
		if( sample_format == SAMPLEFORMAT_INT )
			return( VIPS_FORMAT_SHORT );
		if( sample_format == SAMPLEFORMAT_UINT )
			return( VIPS_FORMAT_USHORT );
		break;

	case 32:
		if( sample_format == SAMPLEFORMAT_INT )
			return( VIPS_FORMAT_INT );
		if( sample_format == SAMPLEFORMAT_UINT )
			return( VIPS_FORMAT_UINT );
		if( sample_format == SAMPLEFORMAT_IEEEFP )
			return( VIPS_FORMAT_FLOAT );
		break;

	case 64:
		if( sample_format == SAMPLEFORMAT_IEEEFP )
			return( VIPS_FORMAT_DOUBLE );
		if( sample_format == SAMPLEFORMAT_COMPLEXIEEEFP )
			return( VIPS_FORMAT_COMPLEX );
		break;

	case 128:
		if( sample_format == SAMPLEFORMAT_COMPLEXIEEEFP )
			return( VIPS_FORMAT_DPCOMPLEX );
		break;

	default:
		break;
	}

	vips_error( "tiff2vips", "%s", _( "unsupported tiff image type\n" ) ); 

	return( VIPS_FORMAT_NOTSET ); 
}

/* Per-scanline process function for VIPS_CODING_LABQ.
 */
static void
rtiff_labpack_line( Rtiff *rtiff, VipsPel *q, VipsPel *p, int n, void *dummy )
{
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;

	int x;

	for( x = 0; x &lt; n; x++ ) {
		q[0] = p[0];
		q[1] = p[1];
		q[2] = p[2];
		q[3] = 0;

		q += 4;
		p += samples_per_pixel;
	}
}

/* Read an 8-bit LAB image.
 */
static int
rtiff_parse_labpack( Rtiff *rtiff, VipsImage *out )
{
	if( rtiff_check_min_samples( rtiff, 3 ) ||
		rtiff_check_bits( rtiff, 8 ) ||
		rtiff_check_interpretation( rtiff, PHOTOMETRIC_CIELAB ) )
		return( -1 );

	out-&gt;Bands = 4; 
	out-&gt;BandFmt = VIPS_FORMAT_UCHAR; 
	out-&gt;Coding = VIPS_CODING_LABQ; 
	out-&gt;Type = VIPS_INTERPRETATION_LAB; 

	rtiff-&gt;sfn = rtiff_labpack_line;

	return( 0 );
}


/* Per-scanline process function for 8-bit VIPS_CODING_LAB to 16-bit LabS with
 * alpha.
 */
static void
rtiff_lab_with_alpha_line( Rtiff *rtiff,
	VipsPel *q, VipsPel *p, int n, void *dummy )
{
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;

	unsigned char *p1;
	short *q1;
	int x;

	p1 = (unsigned char *) p;
	q1 = (short *) q;
	for( x = 0; x &lt; n; x++ ) {
		int i;

		q1[0] = ((unsigned int) p1[0]) * 32767 / 255;
		q1[1] = ((short) p1[1]) &lt;&lt; 8;
		q1[2] = ((short) p1[2]) &lt;&lt; 8;

		for( i = 3; i &lt; samples_per_pixel; i++ )
			q1[i] = (p1[i] &lt;&lt; 8) + p1[i];

		q1 += samples_per_pixel;
		p1 += samples_per_pixel;
	}
}

/* Read an 8-bit LAB image with alpha bands into 16-bit LabS.
 */
static int
rtiff_parse_lab_with_alpha( Rtiff *rtiff, VipsImage *out )
{
	if( rtiff_check_min_samples( rtiff, 4 ) ||
		rtiff_check_bits( rtiff, 8 ) ||
		rtiff_check_interpretation( rtiff, PHOTOMETRIC_CIELAB ) )
		return( -1 );

	out-&gt;Bands = rtiff-&gt;header.samples_per_pixel;
	out-&gt;BandFmt = VIPS_FORMAT_SHORT;
	out-&gt;Coding = VIPS_CODING_NONE;
	out-&gt;Type = VIPS_INTERPRETATION_LABS;

	rtiff-&gt;sfn = rtiff_lab_with_alpha_line;

	return( 0 );
}

/* Per-scanline process function for LABS.
 */
static void
rtiff_labs_line( Rtiff *rtiff, VipsPel *q, VipsPel *p, int n, void *dummy )
{
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;

	unsigned short *p1;
	short *q1;
	int x;
	int i; 

	p1 = (unsigned short *) p;
	q1 = (short *) q;
	for( x = 0; x &lt; n; x++ ) {
		/* We use signed int16 for L.
		 */
		q1[0] = p1[0] &gt;&gt; 1;

		for( i = 1; i &lt; samples_per_pixel; i++ ) 
			q1[i] = p1[i];

		q1 += samples_per_pixel;
		p1 += samples_per_pixel;
	}
}

/* Read a 16-bit LAB image.
 */
static int
rtiff_parse_labs( Rtiff *rtiff, VipsImage *out )
{
	if( rtiff_check_min_samples( rtiff, 3 ) ||
		rtiff_check_bits( rtiff, 16 ) ||
		rtiff_check_interpretation( rtiff, PHOTOMETRIC_CIELAB ) )
		return( -1 );

	out-&gt;Bands = rtiff-&gt;header.samples_per_pixel; 
	out-&gt;BandFmt = VIPS_FORMAT_SHORT; 
	out-&gt;Coding = VIPS_CODING_NONE; 
	out-&gt;Type = VIPS_INTERPRETATION_LABS; 

	rtiff-&gt;sfn = rtiff_labs_line;

	return( 0 );
}

/* libtiff delivers logluv as illuminant-free 0-1 XYZ in 3 x float.
 */
static void
rtiff_logluv_line( Rtiff *rtiff, VipsPel *q, VipsPel *p, int n, void *dummy )
{
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;

	float *p1;
	float *q1;
	int x;
	int i; 

	p1 = (float *) p;
	q1 = (float *) q;
	for( x = 0; x &lt; n; x++ ) {
		q1[0] = VIPS_D65_X0 * p1[0];
		q1[1] = VIPS_D65_Y0 * p1[1];
		q1[2] = VIPS_D65_Z0 * p1[2];

		for( i = 3; i &lt; samples_per_pixel; i++ ) 
			q1[i] = p1[i];

		q1 += samples_per_pixel;
		p1 += samples_per_pixel;
	}
}

/* LOGLUV images arrive from libtiff as float xyz.
 */
static int
rtiff_parse_logluv( Rtiff *rtiff, VipsImage *out )
{
	if( rtiff_check_min_samples( rtiff, 3 ) ||
		rtiff_check_interpretation( rtiff, PHOTOMETRIC_LOGLUV ) )
		return( -1 );

	out-&gt;Bands = rtiff-&gt;header.samples_per_pixel; 
	out-&gt;BandFmt = VIPS_FORMAT_FLOAT; 
	out-&gt;Coding = VIPS_CODING_NONE; 
	out-&gt;Type = VIPS_INTERPRETATION_XYZ; 

	rtiff-&gt;sfn = rtiff_logluv_line;

	return( 0 );
}

/* Make a N-bit scanline process function. We pass in the code to expand the
 * bits down the byte since this does not generalize well.
 */
#define NBIT_LINE( N, EXPAND ) \
static void \
rtiff_ ## N ## bit_line( Rtiff *rtiff, \
	VipsPel *q, VipsPel *p, int n, void *flg ) \
{ \
	int photometric = rtiff-&gt;header.photometric_interpretation; \
	int mask = photometric == PHOTOMETRIC_MINISBLACK ?  0 : 0xff; \
	int bps = rtiff-&gt;header.bits_per_sample; \
	int load = 8 / bps - 1; \
	\
	int x; \
	VipsPel bits; \
	\
	/* Stop a compiler warning. \
	 */ \
	bits = 0; \
	\
	for( x = 0; x &lt; n; x++ ) { \
		if( (x &amp; load) == 0 ) \
			/* Flip the bits for miniswhite. \
			 */ \
			bits = *p++ ^ mask; \
	 	\
		EXPAND( q[x], bits ); \
		\
		bits &lt;&lt;= bps; \
	} \
}

/* Expand the top bit down a byte. Use a sign-extending shift.
 */
#define EXPAND1( Q, BITS ) G_STMT_START { \
	(Q) = (((signed char) (BITS &amp; 128)) &gt;&gt; 7); \
} G_STMT_END

/* Expand the top two bits down a byte. Shift down, then expand up.
 */
#define EXPAND2( Q, BITS ) G_STMT_START { \
	VipsPel twobits = BITS &gt;&gt; 6; \
	VipsPel fourbits = twobits | (twobits &lt;&lt; 2); \
	Q = fourbits | (fourbits &lt;&lt; 4); \
} G_STMT_END

/* Expand the top four bits down a byte. 
 */
#define EXPAND4( Q, BITS ) G_STMT_START { \
	Q = (BITS &amp; 0xf0) | (BITS &gt;&gt; 4); \
} G_STMT_END

NBIT_LINE( 1, EXPAND1 )
NBIT_LINE( 2, EXPAND2 )
NBIT_LINE( 4, EXPAND4 )

/* Read a 1-bit TIFF image. 
 */
static int
rtiff_parse_onebit( Rtiff *rtiff, VipsImage *out )
{
	if( rtiff_check_samples( rtiff, 1 ) ||
		rtiff_check_bits( rtiff, 1 ) )
		return( -1 );

	out-&gt;Bands = 1; 
	out-&gt;BandFmt = VIPS_FORMAT_UCHAR; 
	out-&gt;Coding = VIPS_CODING_NONE; 
	out-&gt;Type = VIPS_INTERPRETATION_B_W; 

	rtiff-&gt;sfn = rtiff_1bit_line;

	return( 0 );
}

/* Read a 2-bit TIFF image. 
 */
static int
rtiff_parse_twobit( Rtiff *rtiff, VipsImage *out )
{
	if( rtiff_check_samples( rtiff, 1 ) ||
		rtiff_check_bits( rtiff, 2 ) )
		return( -1 );

	out-&gt;Bands = 1; 
	out-&gt;BandFmt = VIPS_FORMAT_UCHAR; 
	out-&gt;Coding = VIPS_CODING_NONE; 
	out-&gt;Type = VIPS_INTERPRETATION_B_W; 

	rtiff-&gt;sfn = rtiff_2bit_line;

	return( 0 );
}

/* Read a 4-bit TIFF image. 
 */
static int
rtiff_parse_fourbit( Rtiff *rtiff, VipsImage *out )
{
	if( rtiff_check_samples( rtiff, 1 ) ||
		rtiff_check_bits( rtiff, 4 ) )
		return( -1 );

	out-&gt;Bands = 1; 
	out-&gt;BandFmt = VIPS_FORMAT_UCHAR; 
	out-&gt;Coding = VIPS_CODING_NONE; 
	out-&gt;Type = VIPS_INTERPRETATION_B_W; 

	rtiff-&gt;sfn = rtiff_4bit_line;

	return( 0 );
}

/* Swap the sense of the first channel, if necessary. 
 */
#define GREY_LOOP( TYPE, MAX ) { \
	TYPE *p1; \
	TYPE *q1; \
	\
	p1 = (TYPE *) p; \
	q1 = (TYPE *) q; \
	for( x = 0; x &lt; n; x++ ) { \
		if( invert ) \
			q1[0] = MAX - p1[0]; \
		else \
			q1[0] = p1[0]; \
		\
		for( i = 1; i &lt; samples_per_pixel; i++ ) \
			q1[i] = p1[i]; \
		\
		q1 += samples_per_pixel; \
		p1 += samples_per_pixel; \
	} \
}

/* Per-scanline process function for greyscale images.
 */
static void
rtiff_greyscale_line( Rtiff *rtiff, 
	VipsPel *q, VipsPel *p, int n, void *client )
{
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;
	int photometric_interpretation = 
		rtiff-&gt;header.photometric_interpretation;
	VipsBandFormat format = rtiff_guess_format( rtiff ); 

	/* Swapping black and white doesn't make sense for the signed formats.
	 */
	gboolean invert = 
		photometric_interpretation == PHOTOMETRIC_MINISWHITE &amp;&amp;
		vips_band_format_isuint( format );

	int x, i;

	switch( format ) {
	case VIPS_FORMAT_CHAR:
		GREY_LOOP( guchar, 0 ); 
		break;

	case VIPS_FORMAT_UCHAR:
		GREY_LOOP( guchar, UCHAR_MAX ); 
		break;

	case VIPS_FORMAT_SHORT:
		GREY_LOOP( gshort, 0 ); 
		break;

	case VIPS_FORMAT_USHORT:
		GREY_LOOP( gushort, USHRT_MAX ); 
		break;

	case VIPS_FORMAT_INT:
		GREY_LOOP( gint, 0 ); 
		break;

	case VIPS_FORMAT_UINT:
		GREY_LOOP( guint, UINT_MAX ); 
		break;

	case VIPS_FORMAT_FLOAT:
		GREY_LOOP( float, 1.0 ); 
		break;

	case VIPS_FORMAT_DOUBLE:
		GREY_LOOP( double, 1.0 ); 
		break;

	default:
		g_assert_not_reached();
	}
}

/* Read a grey-scale TIFF image. We have to invert the first band if
 * PHOTOMETRIC_MINISBLACK is set. 
 */
static int
rtiff_parse_greyscale( Rtiff *rtiff, VipsImage *out )
{
	if( rtiff_check_min_samples( rtiff, 1 ) ||
		rtiff_non_fractional( rtiff ) )
		return( -1 );

	out-&gt;Bands = rtiff-&gt;header.samples_per_pixel; 
	out-&gt;BandFmt = rtiff_guess_format( rtiff );
	if( out-&gt;BandFmt == VIPS_FORMAT_NOTSET )
		return( -1 ); 
	out-&gt;Coding = VIPS_CODING_NONE; 

	if( rtiff-&gt;header.bits_per_sample == 16 )
		out-&gt;Type = VIPS_INTERPRETATION_GREY16; 
	else
		out-&gt;Type = VIPS_INTERPRETATION_B_W; 

	/* rtiff_greyscale_line() doesn't do complex.
	 */
	if( vips_check_noncomplex( "tiff2vips", out ) )
		return( -1 ); 

	rtiff-&gt;sfn = rtiff_greyscale_line;

	return( 0 );
}

typedef struct {
	/* LUTs mapping image indexes to RGB.
	 */
	VipsPel *red8;
	VipsPel *green8;
	VipsPel *blue8;

	guint16 *red16;
	guint16 *green16;
	guint16 *blue16;

	/* All maps equal, so we write mono.
	 */
	gboolean mono;
} PaletteRead;

/* 1/2/4 bit samples with an 8-bit palette.
 */
static void
rtiff_palette_line_bit( Rtiff *rtiff, 
	VipsPel *q, VipsPel *p, int n, void *client )
{
	PaletteRead *read = (PaletteRead *) client;
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;
	int bits_per_sample = rtiff-&gt;header.bits_per_sample;

	int bit;
	VipsPel data;
	int x;

	bit = 0;
	data = 0;
	for( x = 0; x &lt; n * samples_per_pixel; x++ ) {
		int i;

		if( bit &lt;= 0 ) {
			data = *p++;
			bit = 8;
		}

		i = data &gt;&gt; (8 - bits_per_sample);
		data &lt;&lt;= bits_per_sample;
		bit -= bits_per_sample;

		/* The first band goes through the LUT, subsequent bands are
		 * left-justified and copied.
		 */
		if( x % samples_per_pixel == 0 ) { 
			if( read-&gt;mono ) 
				*q++ = read-&gt;red8[i];
			else {
				q[0] = read-&gt;red8[i];
				q[1] = read-&gt;green8[i];
				q[2] = read-&gt;blue8[i];
				q += 3;
			}
		}
		else 
			*q++ = VIPS_LSHIFT_INT( i, 8 - bits_per_sample );
	}
}

/* 8-bit samples with an 8-bit palette.
 */
static void
rtiff_palette_line8( Rtiff *rtiff, VipsPel *q, VipsPel *p, int n, 
	void *client )
{
	PaletteRead *read = (PaletteRead *) client;
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;

	int x;
	int s;

	for( x = 0; x &lt; n; x++ ) {
		int i = p[0];

		if( read-&gt;mono ) 
			q[0] = read-&gt;red8[i];
		else {
			q[0] = read-&gt;red8[i];
			q[1] = read-&gt;green8[i];
			q[2] = read-&gt;blue8[i];
			q += 2;
		}

		for( s = 1; s &lt; samples_per_pixel; s++ )
			q[s] = p[s]; 

		q += samples_per_pixel; 
		p += samples_per_pixel; 
	}
}

/* 16-bit samples with 16-bit data in the palette. 
 */
static void
rtiff_palette_line16( Rtiff *rtiff, VipsPel *q, VipsPel *p, int n, 
	void *client )
{
	PaletteRead *read = (PaletteRead *) client;
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;

	guint16 *p16, *q16;
	int x;
	int s;

	q16 = (guint16 *) q;
	p16 = (guint16 *) p;

	for( x = 0; x &lt; n; x++ ) {
		int i = p16[0];

		if( read-&gt;mono ) 
			q16[0] = read-&gt;red16[i];
		else {
			q16[0] = read-&gt;red16[i];
			q16[1] = read-&gt;green16[i];
			q16[2] = read-&gt;blue16[i];
			q16 += 2;
		}

		for( s = 1; s &lt; samples_per_pixel; s++ )
			q16[s] = p16[s]; 

		q16 += samples_per_pixel; 
		p16 += samples_per_pixel; 
	}
}

/* Read a palette-ised TIFF image. 
 */
static int
rtiff_parse_palette( Rtiff *rtiff, VipsImage *out )
{
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;
	int bits_per_sample = rtiff-&gt;header.bits_per_sample;

	int len;
	PaletteRead *read;
	int i;

	if( rtiff_check_bits_palette( rtiff ) ||
		rtiff_check_min_samples( rtiff, 1 ) )
		return( -1 ); 
	len = 1 &lt;&lt; bits_per_sample;

	if( !(read = VIPS_NEW( out, PaletteRead )) ||
		!(read-&gt;red8 = VIPS_ARRAY( out, len, VipsPel )) ||
		!(read-&gt;green8 = VIPS_ARRAY( out, len, VipsPel )) ||
		!(read-&gt;blue8 = VIPS_ARRAY( out, len, VipsPel )) )
		return( -1 );

	/* Get maps, convert to 8-bit data.
	 */
	if( !TIFFGetField( rtiff-&gt;tiff, 
		TIFFTAG_COLORMAP, 
		&amp;read-&gt;red16, &amp;read-&gt;green16, &amp;read-&gt;blue16 ) ) {
		vips_error( "tiff2vips", "%s", _( "bad colormap" ) );
		return( -1 );
	}

	/* Old-style colourmaps were 8-bit. If all the top bytes are zero,
	 * assume we have one of these.
	 *
	 * See: https://github.com/libvips/libvips/issues/220
	 */
	for( i = 0; i &lt; len; i++ ) 
		if( (read-&gt;red16[i] &gt;&gt; 8) | 
			(read-&gt;green16[i] &gt;&gt; 8) | 
			(read-&gt;blue16[i] &gt;&gt; 8) )
			break;
	if( i &lt; len ) 
		for( i = 0; i &lt; len; i++ ) {
			read-&gt;red8[i] = read-&gt;red16[i] &gt;&gt; 8;
			read-&gt;green8[i] = read-&gt;green16[i] &gt;&gt; 8;
			read-&gt;blue8[i] = read-&gt;blue16[i] &gt;&gt; 8;
		}
	else {
		g_warning( "%s", _( "assuming 8-bit palette" ) );

		for( i = 0; i &lt; len; i++ ) {
			read-&gt;red8[i] = read-&gt;red16[i] &amp; 0xff;
			read-&gt;green8[i] = read-&gt;green16[i] &amp; 0xff;
			read-&gt;blue8[i] = read-&gt;blue16[i] &amp; 0xff;
		}
	}

	/* Are all the maps equal? We have a mono image.
	 */
	read-&gt;mono = TRUE;
	for( i = 0; i &lt; len; i++ ) 
		if( read-&gt;red16[i] != read-&gt;green16[i] ||
			read-&gt;green16[i] != read-&gt;blue16[i] ) {
			read-&gt;mono = FALSE;
			break;
		}

	/* There's a TIFF extension, INDEXED, that is the preferred way to
	 * encode mono palette images, but few applications support it. So we
	 * just search the colormap.
	 */

	if( bits_per_sample &lt;= 8 )
		out-&gt;BandFmt = VIPS_FORMAT_UCHAR; 
	else
		out-&gt;BandFmt = VIPS_FORMAT_USHORT; 
	out-&gt;Coding = VIPS_CODING_NONE; 

	if( read-&gt;mono ) {
		out-&gt;Bands = samples_per_pixel; 
		if( bits_per_sample &lt;= 8 )
			out-&gt;Type = VIPS_INTERPRETATION_B_W; 
		else
			out-&gt;Type = VIPS_INTERPRETATION_GREY16; 
	}
	else {
		out-&gt;Bands = samples_per_pixel + 2; 
		if( bits_per_sample &lt;= 8 )
			out-&gt;Type = VIPS_INTERPRETATION_sRGB; 
		else
			out-&gt;Type = VIPS_INTERPRETATION_RGB16; 
	}

	rtiff-&gt;client = read;
	if( bits_per_sample &lt; 8 )
		rtiff-&gt;sfn = rtiff_palette_line_bit;
	else if( bits_per_sample == 8 )
		rtiff-&gt;sfn = rtiff_palette_line8;
	else if( bits_per_sample == 16 )
		rtiff-&gt;sfn = rtiff_palette_line16;
	else
		g_assert_not_reached(); 

	return( 0 );
}

/* Per-scanline process function when we just need to copy.
 */
static void
rtiff_memcpy_line( Rtiff *rtiff, VipsPel *q, VipsPel *p, int n, void *client )
{
	VipsImage *im = (VipsImage *) client;
	size_t len = n * VIPS_IMAGE_SIZEOF_PEL( im );

	memcpy( q, p, len ); 
}

/* Read a regular multiband image where we can just copy pixels from the tiff
 * buffer.
 */
static int
rtiff_parse_copy( Rtiff *rtiff, VipsImage *out )
{
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;
	int photometric_interpretation = 
		rtiff-&gt;header.photometric_interpretation;
	int inkset = rtiff-&gt;header.inkset;

	if( rtiff_non_fractional( rtiff ) )
		return( -1 );

	out-&gt;Bands = samples_per_pixel; 
	out-&gt;BandFmt = rtiff_guess_format( rtiff );
	if( out-&gt;BandFmt == VIPS_FORMAT_NOTSET )
		return( -1 ); 
	out-&gt;Coding = VIPS_CODING_NONE; 

	if( samples_per_pixel &gt;= 3 &amp;&amp;
		(photometric_interpretation == PHOTOMETRIC_RGB ||
		 photometric_interpretation == PHOTOMETRIC_YCBCR) ) {
		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
			out-&gt;Type = VIPS_INTERPRETATION_RGB16; 
		else if( !vips_band_format_isint( out-&gt;BandFmt ) )
			/* Most float images use 0 - 1 for black - white.
			 * Photoshop uses 0 - 1 and no gamma. 
			 */
			out-&gt;Type = VIPS_INTERPRETATION_scRGB; 
		else
			out-&gt;Type = VIPS_INTERPRETATION_sRGB; 
	}
	else if( samples_per_pixel &gt;= 3 &amp;&amp;
		photometric_interpretation == PHOTOMETRIC_CIELAB )
		out-&gt;Type = VIPS_INTERPRETATION_LAB; 
	else if( photometric_interpretation == PHOTOMETRIC_SEPARATED &amp;&amp;
		samples_per_pixel &gt;= 4 &amp;&amp;
		inkset == INKSET_CMYK )
		out-&gt;Type = VIPS_INTERPRETATION_CMYK; 
	else
		out-&gt;Type = VIPS_INTERPRETATION_MULTIBAND;

	rtiff-&gt;sfn = rtiff_memcpy_line;
	rtiff-&gt;client = out;

	/* We expand YCBCR images to RGB using JPEGCOLORMODE_RGB, and this
	 * means we need a slightly larger read buffer for the edge pixels. In
	 * turn, this means we can't just memcpy to libvips regions.
	 */
	rtiff-&gt;memcpy = photometric_interpretation != PHOTOMETRIC_YCBCR;

	return( 0 );
}

typedef int (*reader_fn)( Rtiff *rtiff, VipsImage *out );

/* We have a range of output paths. Look at the tiff header and try to
 * route the input image to the best output path.
 */
static reader_fn
rtiff_pick_reader( Rtiff *rtiff )
{
	int bits_per_sample = rtiff-&gt;header.bits_per_sample;
	int photometric_interpretation = 
		rtiff-&gt;header.photometric_interpretation;
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;

	if( photometric_interpretation == PHOTOMETRIC_CIELAB ) {
		if( bits_per_sample == 8 ) {
			if( samples_per_pixel &gt; 3 )
				return( rtiff_parse_lab_with_alpha );
			else
				return( rtiff_parse_labpack );
		}
		if( bits_per_sample == 16 )
			return( rtiff_parse_labs );
	}

	if( photometric_interpretation == PHOTOMETRIC_LOGLUV ) 
		return( rtiff_parse_logluv );

	if( photometric_interpretation == PHOTOMETRIC_MINISWHITE ||
		photometric_interpretation == PHOTOMETRIC_MINISBLACK ) {

		if( bits_per_sample == 1)
			return ( rtiff_parse_onebit );
		else if ( bits_per_sample == 2 )
			return ( rtiff_parse_twobit);
		else if ( bits_per_sample == 4 )
			return ( rtiff_parse_fourbit);
		else
			return( rtiff_parse_greyscale ); 
	}

	if( photometric_interpretation == PHOTOMETRIC_PALETTE ) 
		return( rtiff_parse_palette ); 

	return( rtiff_parse_copy );
}

/* Set the header on @out from our rtiff. rtiff_header_read() has already been
 * called. 
 */
static int
rtiff_set_header( Rtiff *rtiff, VipsImage *out )
{
	uint32 data_length;
	void *data;

	rtiff_set_decode_format( rtiff );

	if( rtiff-&gt;header.photometric_interpretation == PHOTOMETRIC_LOGLUV )
		vips_image_set_double( out, "stonits", rtiff-&gt;header.stonits );

	out-&gt;Xsize = rtiff-&gt;header.width;
	out-&gt;Ysize = rtiff-&gt;header.height * rtiff-&gt;n;

	VIPS_SETSTR( out-&gt;filename, 
		vips_connection_filename( VIPS_CONNECTION( rtiff-&gt;source ) ) );

	if( rtiff-&gt;n &gt; 1 ) 
		vips_image_set_int( out, 
			VIPS_META_PAGE_HEIGHT, rtiff-&gt;header.height );

	if( rtiff-&gt;header.subifd_count &gt; 0 ) 
		vips_image_set_int( out, 
			VIPS_META_N_SUBIFDS, rtiff-&gt;header.subifd_count );

	vips_image_set_int( out, VIPS_META_N_PAGES, rtiff-&gt;n_pages );

	/* Even though we could end up serving tiled data, always hint
	 * THINSTRIP, since we're quite happy doing that too, and it could need
	 * a lot less memory.
	 */
        vips_image_pipelinev( out, VIPS_DEMAND_STYLE_THINSTRIP, NULL );

	/* We have a range of output paths. Look at the tiff header and try to
	 * route the input image to the best output path.
	 */
	if( rtiff_pick_reader( rtiff )( rtiff, out ) ) 
		return( -1 ); 

	/* Read any ICC profile.
	 */
	if( TIFFGetField( rtiff-&gt;tiff, 
		TIFFTAG_ICCPROFILE, &amp;data_length, &amp;data ) ) 
		vips_image_set_blob_copy( out, 
			VIPS_META_ICC_NAME, data, data_length );

	/* Read any XMP metadata.
	 */
	if( TIFFGetField( rtiff-&gt;tiff, 
		TIFFTAG_XMLPACKET, &amp;data_length, &amp;data ) ) 
		vips_image_set_blob_copy( out, 
			VIPS_META_XMP_NAME, data, data_length );

	/* Read any IPTC metadata.
	 */
	if( TIFFGetField( rtiff-&gt;tiff, 
		TIFFTAG_RICHTIFFIPTC, &amp;data_length, &amp;data ) ) {
		vips_image_set_blob_copy( out, 
			VIPS_META_IPTC_NAME, data, data_length );

		/* Older versions of libvips used this misspelt name :-( attach 
		 * under this name too for compatibility.
		 */
		vips_image_set_blob_copy( out, "ipct-data", data, data_length );
	}

	/* Read any photoshop metadata.
	 */
	if( TIFFGetField( rtiff-&gt;tiff, 
		TIFFTAG_PHOTOSHOP, &amp;data_length, &amp;data ) ) 
		vips_image_set_blob_copy( out, 
			VIPS_META_PHOTOSHOP_NAME, data, data_length );

	if( rtiff-&gt;header.image_description )
		vips_image_set_string( out, VIPS_META_IMAGEDESCRIPTION, 
			rtiff-&gt;header.image_description );

	if( get_resolution( rtiff-&gt;tiff, out ) )
		return( -1 );

	/* Set the "orientation" tag. This is picked up later by autorot, if
	 * requested.
	 */
	vips_image_set_int( out, 
		VIPS_META_ORIENTATION, rtiff-&gt;header.orientation );

	return( 0 );
}

/* Allocate a tile buffer. Have one of these for each thread so we can unpack
 * to vips in parallel.
 */
static void *
rtiff_seq_start( VipsImage *out, void *a, void *b )
{
	Rtiff *rtiff = (Rtiff *) a;
	tdata_t *buf;

	if( !(buf = vips_malloc( NULL, rtiff-&gt;header.tile_size )) )
		return( NULL );

	return( (void *) buf );
}

static int
rtiff_read_tile( Rtiff *rtiff, tdata_t *buf, int x, int y )
{
#ifdef DEBUG_VERBOSE
	printf( "rtiff_read_tile: x = %d, y = %d, we_decompress = %d\n", 
		x, y, rtiff-&gt;header.we_decompress ); 
#endif /*DEBUG_VERBOSE*/

	if( rtiff-&gt;header.we_decompress ) {
		ttile_t tile_no = TIFFComputeTile( rtiff-&gt;tiff, x, y, 0, 0 );

		tsize_t size;

		size = TIFFReadRawTile( rtiff-&gt;tiff, tile_no, 
			rtiff-&gt;compressed_buf, rtiff-&gt;compressed_buf_length );
		if( size &lt;= 0 ) {
			vips_foreign_load_invalidate( rtiff-&gt;out );
			return( -1 ); 
		}

		switch( rtiff-&gt;header.compression ) {
		case JP2K_YCC:
		case JP2K_RGB:
		case JP2K_LOSSY:
			if( vips__foreign_load_jp2k_decompress( 
				rtiff-&gt;out, 
				rtiff-&gt;header.tile_width, 
				rtiff-&gt;header.tile_height,
				TRUE,
				rtiff-&gt;compressed_buf, size,
				buf, rtiff-&gt;header.tile_size ) ) 
				return( -1 );
			break;

		default:
			g_assert_not_reached();
			break;
		}

	}
	else {
<a name="0"></a>		if( TIFFReadTile( rtiff-&gt;tiff, buf, x, y, 0, 0 ) &lt; 0 ) { 
			vips_foreign_load_invalidate( rtiff-&gt;out );
			return( -1 ); 
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		}
	}

	return( 0 ); 
}

/* Paint a tile from the file. This is a
 * special-case for when a region is exactly a tiff tile, and pixels need no
 * conversion. In this case, libtiff can read tiles directly to our output
 * region.
 */
static int
rtiff_fill_region_aligned( VipsRegion *out, 
	void *seq, void *a, void *b, gboolean *stop )
{
	Rtiff *rtiff = (Rtiff *) a;
	VipsRect *r = &amp;out-&gt;valid;</b></font>
	int page_height = rtiff-&gt;header.height;
	int page_no = r-&gt;top / page_height;
	int page_y = r-&gt;top % page_height;

	g_assert( (r-&gt;left % rtiff-&gt;header.tile_width) == 0 );
	g_assert( (r-&gt;top % rtiff-&gt;header.tile_height) == 0 );
	g_assert( r-&gt;width == rtiff-&gt;header.tile_width );
	g_assert( r-&gt;height == rtiff-&gt;header.tile_height );
	g_assert( VIPS_REGION_LSKIP( out ) == VIPS_REGION_SIZEOF_LINE( out ) );

#ifdef DEBUG_VERBOSE
	printf( "rtiff_fill_region_aligned:\n" ); 
#endif /*DEBUG_VERBOSE*/

	/* Read that tile directly into the vips tile.
	 */
	if( rtiff_set_page( rtiff, rtiff-&gt;page + page_no ) ||
		rtiff_read_tile( rtiff,
			(tdata_t *) VIPS_REGION_ADDR( out, r-&gt;left, r-&gt;top ), 
		r-&gt;left, page_y ) ) 
		return( -1 );

	return( 0 );
}

/* Loop over the output region, painting in tiles from the file.
 */
static int
rtiff_fill_region_unaligned( VipsRegion *out, 
	void *seq, void *a, void *b, gboolean *stop )
{
	tdata_t *buf = (tdata_t *) seq;
	Rtiff *rtiff = (Rtiff *) a;
	int tile_width = rtiff-&gt;header.tile_width;
	int tile_height = rtiff-&gt;header.tile_height;
	int page_height = rtiff-&gt;header.height;
	int tile_row_size = rtiff-&gt;header.tile_row_size;
	VipsRect *r = &amp;out-&gt;valid;

	int x, y, z;

#ifdef DEBUG_VERBOSE
	printf( "rtiff_fill_region_unaligned:\n" ); 
#endif /*DEBUG_VERBOSE*/

	y = 0;
	while( y &lt; r-&gt;height ) {
		VipsRect tile, page, hit;

		/* Not necessary, but it stops static analyzers complaining
		 * about a used-before-set.
		 */
		hit.height = 0;

		x = 0;
		while( x &lt; r-&gt;width ) { 
			/* page_no is within this toilet roll image, not tiff
			 * file page number ... add the number of the start
			 * page to get that.
			 */
			int page_no = (r-&gt;top + y) / page_height;
			int page_y = (r-&gt;top + y) % page_height;

			/* Coordinate of the tile on this page that xy falls in.
			 */
			int xs = ((r-&gt;left + x) / tile_width) * tile_width;
			int ys = (page_y / tile_height) * tile_height;

			if( rtiff_set_page( rtiff, rtiff-&gt;page + page_no ) ||
				rtiff_read_tile( rtiff, buf, xs, ys ) )  
				return( -1 );

			/* Position of tile on the page. 
			 */
			tile.left = xs;
			tile.top = ys;
			tile.width = tile_width;
			tile.height = tile_height;

			/* It'll be clipped by this page.
			 */
			page.left = 0;
			page.top = 0;
			page.width = rtiff-&gt;header.width;
			page.height = rtiff-&gt;header.height;
			vips_rect_intersectrect( &amp;tile, &amp;page, &amp;tile );

			/* To image coordinates.
			 */
			tile.top += page_no * page_height;

			/* And clip again by this region.
			 */
			vips_rect_intersectrect( &amp;tile, r, &amp;hit );

			/* We are inside a tilecache, so requests will always
			 * be aligned left-right to tile boundaries.
			 *
			 * this is not true vertically for toilet-roll images.
			 */
			g_assert( hit.left == tile.left );

			/* Unpack to VIPS format. 
			 * Just unpack the section of the tile we need.
			 */
			for( z = 0; z &lt; hit.height; z++ ) {
				VipsPel *p = (VipsPel *) buf +
					(hit.top - tile.top + z) * 
					tile_row_size;
				VipsPel *q = VIPS_REGION_ADDR( out, 
					hit.left, hit.top + z );

				rtiff-&gt;sfn( rtiff,
					q, p, hit.width, rtiff-&gt;client );
			}

			x += hit.width;
		}

		/* This will be the same for all tiles in the row we've just
		 * done.
		 */
		y += hit.height;
	}

	return( 0 );
}

/* Loop over the output region, painting in tiles from the file.
 */
static int
rtiff_fill_region( VipsRegion *out, 
	void *seq, void *a, void *b, gboolean *stop )
{
	Rtiff *rtiff = (Rtiff *) a;
	int tile_width = rtiff-&gt;header.tile_width;
	int tile_height = rtiff-&gt;header.tile_height;
	int page_width = rtiff-&gt;header.width;
	int page_height = rtiff-&gt;header.height;
	VipsRect *r = &amp;out-&gt;valid;
	int page_no = r-&gt;top / page_height;
	int page_y = r-&gt;top % page_height;

	VipsGenerateFn generate;

#ifdef DEBUG_VERBOSE
	printf( "rtiff_fill_region: left = %d, top = %d, "
		"width = %d, height = %d\n", 
		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height ); 
#endif /*DEBUG_VERBOSE*/

	/* Special case: we are filling a single cache tile exactly sized to 
	 * match the tiff tile, and we have no repacking to do for this format.
	 *
	 * If we are not on the first page, pages must be a multiple of the 
	 * tile size of we'll miss alignment.
	 */
	if( (page_no == 0 || page_height % tile_height == 0) &amp;&amp;
		r-&gt;left % tile_width == 0 &amp;&amp;
		r-&gt;top % tile_height == 0 &amp;&amp;
		r-&gt;width == tile_width &amp;&amp;
		r-&gt;height == tile_height &amp;&amp;
		r-&gt;left + tile_width &lt;= page_width &amp;&amp;
		page_y + tile_height &lt;= page_height &amp;&amp;
		VIPS_REGION_LSKIP( out ) == VIPS_REGION_SIZEOF_LINE( out ) )
		generate = rtiff_fill_region_aligned;
	else
		generate = rtiff_fill_region_unaligned;

	VIPS_GATE_START( "rtiff_fill_region: work" ); 

	if( generate( out, seq, a, b, stop ) ) {
		VIPS_GATE_STOP( "rtiff_fill_region: work" ); 
		return( -1 );
	}

	VIPS_GATE_STOP( "rtiff_fill_region: work" ); 

	return( 0 );
}

static int
rtiff_seq_stop( void *seq, void *a, void *b )
{
	g_free( seq );

	return( 0 );
}

/* Unpremultiply associative alpha, if any.
 */
static int
rtiff_unpremultiply( Rtiff *rtiff, VipsImage *in, VipsImage **out )
{
	if( rtiff-&gt;header.alpha_band != -1 ) {
		VipsImage *x;

		if( 
			vips_unpremultiply( in, &amp;x, 
				"alpha_band", rtiff-&gt;header.alpha_band,
				NULL ) ||
			vips_cast( x, out, in-&gt;BandFmt, NULL ) ) {
			g_object_unref( x );
			return( -1 );
		}
		g_object_unref( x );
	}
	else {
		*out = in;
		g_object_ref( in );
	}

	return( 0 );
}

/* Tile-type TIFF reader core - pass in a per-tile transform. Generate into
 * the im and do it all partially.
 */
static int
rtiff_read_tilewise( Rtiff *rtiff, VipsImage *out )
{
	int tile_width = rtiff-&gt;header.tile_width;
	int tile_height = rtiff-&gt;header.tile_height;
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( out ), 4 );

	VipsImage *in;

#ifdef DEBUG
	printf( "tiff2vips: rtiff_read_tilewise\n" );
#endif /*DEBUG*/

	/* I don't have a sample images for tiled + separate, ban it for now.
	 */
	if( rtiff-&gt;header.separate ) {
		vips_error( "tiff2vips", 
			"%s", _( "tiled separate planes not supported" ) ); 
		return( -1 );
	}

	/* If we will be decompressing, we need a buffer large enough to hold
	 * the largest compressed tile in any page.
	 *
	 * Allocate a buffer 2x the uncompressed tile size ... much simpler
	 * than searching every page for the largest tile with
	 * TIFFTAG_TILEBYTECOUNTS.
	 */
	if( rtiff-&gt;header.we_decompress ) {
		rtiff-&gt;compressed_buf_length = 2 * rtiff-&gt;header.tile_size;
		if( !(rtiff-&gt;compressed_buf = vips_malloc( VIPS_OBJECT( out ), 
			rtiff-&gt;compressed_buf_length )) )
			return( -1 );
	}

	/* Read to this image, then cache to out, see below.
	 */
	t[0] = vips_image_new(); 

	if( rtiff_set_header( rtiff, t[0] ) )
		return( -1 );

	/* Double check: in memcpy mode, the vips tilesize should exactly
	 * match the tifftile size.
	 */
	if( rtiff-&gt;memcpy ) {
		size_t vips_tile_size = VIPS_IMAGE_SIZEOF_PEL( t[0] ) * 
			tile_width * tile_height; 

		if( rtiff-&gt;header.tile_size != vips_tile_size ) { 
			vips_error( "tiff2vips", 
				"%s", _( "unsupported tiff image type" ) );
			return( -1 );
		}
	}

	/* Even though this is a tiled reader, we hint thinstrip since with
	 * the cache we are quite happy serving that if anything downstream 
	 * would like it.
	 */
        vips_image_pipelinev( t[0], VIPS_DEMAND_STYLE_THINSTRIP, NULL );

	/* Generate to out, adding a cache. Enough tiles for two complete rows.
	 */
	if( 
		vips_image_generate( t[0], 
			rtiff_seq_start, rtiff_fill_region, rtiff_seq_stop, 
			rtiff, NULL ) ||
		vips_tilecache( t[0], &amp;t[1],
			"tile_width", tile_width,
			"tile_height", tile_height,
			"max_tiles", 2 * (1 + t[0]-&gt;Xsize / tile_width),
			NULL ) ||
		rtiff_unpremultiply( rtiff, t[1], &amp;t[2] ) )
		return( -1 );
	in = t[2];

	/* Only do this if we have to.
	 */
	if( rtiff-&gt;autorotate &amp;&amp;
		vips_image_get_orientation( in ) != 1 ) {
		if( vips_autorot( in, &amp;t[3], NULL ) )
			return( -1 );
		in = t[3];
	}

	if( vips_image_write( in, out ) )
		return( -1 );

	return( 0 );
}

/* Read a strip. If the image is in separate planes, read each plane and
 * interleave to the output.
 *
 * strip is the number of this strip in this page. 
 */
static int
rtiff_strip_read_interleaved( Rtiff *rtiff, tstrip_t strip, tdata_t buf )
{
	int samples_per_pixel = rtiff-&gt;header.samples_per_pixel;
	int read_height = rtiff-&gt;header.read_height;
	int bits_per_sample = rtiff-&gt;header.bits_per_sample;
	int strip_y = strip * read_height;

	if( rtiff-&gt;header.separate ) {
		int page_width = rtiff-&gt;header.width;
		int page_height = rtiff-&gt;header.height;
		int strips_per_plane = 1 + (page_height - 1) / read_height;
		int strip_height = VIPS_MIN( read_height, 
			page_height - strip_y ); 
		int pels_per_strip = page_width * strip_height;
		int bytes_per_sample = bits_per_sample &gt;&gt; 3; 

		int i, j, k;

		for( i = 0; i &lt; samples_per_pixel; i++ ) { 
			VipsPel *p;
			VipsPel *q;

			if( rtiff_strip_read( rtiff,
				strips_per_plane * i + strip, 
				rtiff-&gt;plane_buf ) )
				return( -1 );

			p = (VipsPel *) rtiff-&gt;plane_buf;
			q = i * bytes_per_sample + (VipsPel *) buf;
			for( j = 0; j &lt; pels_per_strip; j++ ) {
				for( k = 0; k &lt; bytes_per_sample; k++ ) 
					q[k] = p[k];

				p += bytes_per_sample;
				q += bytes_per_sample * samples_per_pixel;
			}
		}
	}
	else { 
		if( rtiff_strip_read( rtiff, strip, buf ) )
			return( -1 );
	}

	return( 0 ); 
}

static int
rtiff_stripwise_generate( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsImage *out = or-&gt;im;
	Rtiff *rtiff = (Rtiff *) a;
	int read_height = rtiff-&gt;header.read_height;
	int page_height = rtiff-&gt;header.height;
	tsize_t scanline_size = rtiff-&gt;header.scanline_size;
        VipsRect *r = &amp;or-&gt;valid;

	int y;

#ifdef DEBUG_VERBOSE
	printf( "rtiff_stripwise_generate: top = %d, height = %d\n",
		r-&gt;top, r-&gt;height );
	printf( "rtiff_stripwise_generate: y_top = %d\n", rtiff-&gt;y_pos );
#endif /*DEBUG_VERBOSE*/

	/* We're inside a tilecache where tiles are the full image width, so
	 * this should always be true.
	 */
	g_assert( r-&gt;left == 0 );
	g_assert( r-&gt;width == or-&gt;im-&gt;Xsize );
	g_assert( VIPS_RECT_BOTTOM( r ) &lt;= or-&gt;im-&gt;Ysize );

	/* If we're reading more than one page, tiles won't fall on strip
	 * boundaries.
	 */

	/* Tiles should always be a strip in height, unless it's the final
	 * strip in the image.
	 */
	g_assert( r-&gt;height == 
		VIPS_MIN( read_height, or-&gt;im-&gt;Ysize - r-&gt;top ) ); 

	/* And check that y_pos is correct. It should be, since we are inside
	 * a vips_sequential().
	 */
	if( r-&gt;top != rtiff-&gt;y_pos ) {
		vips_error( "tiff2vips", 
			_( "out of order read -- at line %d, "
			"but line %d requested" ), rtiff-&gt;y_pos, r-&gt;top );
		return( -1 );
	}

	VIPS_GATE_START( "rtiff_stripwise_generate: work" ); 

	y = 0;
	while( y &lt; r-&gt;height ) { 
		/* page_no is within this toilet roll image, not tiff
		 * file page number ... add the number of the start
		 * page to get that.
		 */
		int page_no = (r-&gt;top + y) / page_height;
		int y_page = (r-&gt;top + y) % page_height;

		/* Strip number.
		 */
		tstrip_t strip_no = y_page / read_height;

		VipsRect image, page, strip, hit;

		/* Our four (including the output region) rects, all in 
		 * output image coordinates.
		 */
		image.left = 0;
		image.top = 0;
		image.width = out-&gt;Xsize;
		image.height = out-&gt;Ysize;

		page.left = 0;
		page.top = page_height * ((r-&gt;top + y) / page_height);
		page.width = out-&gt;Xsize;
		page.height = page_height;

		strip.left = 0;
		strip.top = page.top + strip_no * read_height;
		strip.width = out-&gt;Xsize;
		strip.height = read_height;

		/* Clip strip against page and image ... the final strip will 
		 * be smaller.
		 */
		vips_rect_intersectrect( &amp;strip, &amp;image, &amp;strip );
		vips_rect_intersectrect( &amp;strip, &amp;page, &amp;strip );

		/* Now the bit that overlaps with the region we are filling.
		 */
		vips_rect_intersectrect( &amp;strip, r, &amp;hit );

		g_assert( hit.height &gt; 0 ); 

		if( rtiff_set_page( rtiff, rtiff-&gt;page + page_no ) ) {
			VIPS_GATE_STOP( "rtiff_stripwise_generate: work" ); 
			return( -1 );
		}

		/* Read directly into the image if we can. Otherwise, we must 
		 * read to a temp buffer then unpack into the image.
		 *
		 * We need to read via a buffer if we need to reformat pixels,
		 * or if this strip is not aligned on a tile boundary.
		 */
		if( rtiff-&gt;memcpy &amp;&amp;
			hit.top == strip.top &amp;&amp;
			hit.height == strip.height ) {
			if( rtiff_strip_read_interleaved( rtiff, strip_no, 
				VIPS_REGION_ADDR( or, 0, r-&gt;top + y ) ) ) {
				VIPS_GATE_STOP( 
					"rtiff_stripwise_generate: work" ); 
				return( -1 ); 
			}
		}
		else {
			VipsPel *p;
			VipsPel *q;
			int z;

			/* Read and interleave the entire strip.
			 */
			if( rtiff_strip_read_interleaved( rtiff, strip_no, 
				rtiff-&gt;contig_buf ) ) {
				VIPS_GATE_STOP( 
					"rtiff_stripwise_generate: work" ); 
				return( -1 ); 
			}

			/* Do any repacking to generate pixels in vips layout.
			 */
			p = (VipsPel *) rtiff-&gt;contig_buf + 
				(hit.top - strip.top) * scanline_size;
			q = VIPS_REGION_ADDR( or, 0, r-&gt;top + y );
			for( z = 0; z &lt; hit.height; z++ ) { 
				rtiff-&gt;sfn( rtiff, 
					q, p, or-&gt;im-&gt;Xsize, rtiff-&gt;client );

				p += scanline_size;
				q += VIPS_REGION_LSKIP( or ); 
			}
		}

		y += hit.height;
		rtiff-&gt;y_pos += hit.height;
	}

	VIPS_GATE_STOP( "rtiff_stripwise_generate: work" ); 

	return( 0 );
}

/* Stripwise reading.
 *
 * We could potentially read strips in any order, but this would give
 * catastrophic performance for operations like 90 degress rotate on a 
 * large image. Only offer sequential read.
 */
static int
rtiff_read_stripwise( Rtiff *rtiff, VipsImage *out )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( out ), 4 );

	VipsImage *in;

#ifdef DEBUG
	printf( "tiff2vips: rtiff_read_stripwise\n" );
#endif /*DEBUG*/

	t[0] = vips_image_new();
	if( rtiff_set_header( rtiff, t[0] ) )
		return( -1 );

        vips_image_pipelinev( t[0], VIPS_DEMAND_STYLE_THINSTRIP, NULL );

	/* Double check: in memcpy mode, the vips linesize should exactly
	 * match the tiff line size.
	 */
	if( rtiff-&gt;memcpy ) { 
		size_t vips_line_size;

		/* Lines are smaller in plane-separated mode.
		 */
		if( rtiff-&gt;header.separate )
			vips_line_size = VIPS_IMAGE_SIZEOF_ELEMENT( t[0] ) * 
				t[0]-&gt;Xsize; 
		else
			vips_line_size = VIPS_IMAGE_SIZEOF_LINE( t[0] );

		if( vips_line_size != rtiff-&gt;header.scanline_size ) { 
			vips_error( "tiff2vips", 
				"%s", _( "unsupported tiff image type" ) );
			return( -1 );
		}
	}

	/* If we have separate image planes, we must read to a plane buffer,
	 * then interleave to the output.
	 *
	 * We don't need a separate buffer per thread since the _generate()
	 * function runs inside the cache lock. 
	 */
	if( rtiff-&gt;header.separate ) {
		if( !(rtiff-&gt;plane_buf = vips_malloc( VIPS_OBJECT( out ), 
			rtiff-&gt;header.read_size )) ) 
			return( -1 );
	}

	/* If we need to manipulate pixels, we must read to an interleaved
	 * plane buffer before repacking to the output.
	 *
	 * If we are doing a multi-page read, we need a strip buffer, since
	 * strips may not be aligned on tile boundaries.
	 *
	 * We don't need a separate buffer per thread since the _generate()
	 * function runs inside the cache lock. 
	 */
	if( !rtiff-&gt;memcpy ||
		rtiff-&gt;n &gt; 1 ) { 
		tsize_t size;

		size = rtiff-&gt;header.read_size;
		if( rtiff-&gt;header.separate )
			size *= rtiff-&gt;header.samples_per_pixel;

		if( !(rtiff-&gt;contig_buf = 
			vips_malloc( VIPS_OBJECT( out ), size )) ) 
			return( -1 );
	}

	/* rows_per_strip can be very large if this is a separate plane image,
	 * beware.
	 */
	if( 
		vips_image_generate( t[0], 
			NULL, rtiff_stripwise_generate, NULL, 
			rtiff, NULL ) ||
		vips_sequential( t[0], &amp;t[1], 
			"tile_height", rtiff-&gt;header.read_height,
			NULL ) ||
		rtiff_unpremultiply( rtiff, t[1], &amp;t[2] ) )
		return( -1 );
	in = t[2];

	/* Only do this if we have to.
	 */
	if( rtiff-&gt;autorotate &amp;&amp;
		vips_image_get_orientation( in ) != 1 ) {
		if( vips_autorot( in, &amp;t[3], NULL ) )
			return( -1 );
		in = t[3];
	}

	if( vips_image_write( in, out ) )
		return( -1 );

	return( 0 );
}

/* Load from a tiff dir into one of our tiff header structs.
 */
static int
rtiff_header_read( Rtiff *rtiff, RtiffHeader *header )
{
	int i;
	uint16 extra_samples_count;
	uint16 *extra_samples_types;
	uint16 subifd_count;
	toff_t *subifd_offsets;
	char *image_description;

	if( !tfget32( rtiff-&gt;tiff, TIFFTAG_IMAGEWIDTH, 
			&amp;header-&gt;width ) ||
		!tfget32( rtiff-&gt;tiff, TIFFTAG_IMAGELENGTH, 
			&amp;header-&gt;height ) ||
		!tfget16( rtiff-&gt;tiff, TIFFTAG_SAMPLESPERPIXEL, 
			&amp;header-&gt;samples_per_pixel ) ||
		!tfget16( rtiff-&gt;tiff, TIFFTAG_BITSPERSAMPLE, 
			&amp;header-&gt;bits_per_sample ) ||
		!tfget16( rtiff-&gt;tiff, TIFFTAG_PHOTOMETRIC, 
			&amp;header-&gt;photometric_interpretation ) ||
		!tfget16( rtiff-&gt;tiff, TIFFTAG_INKSET, 
			&amp;header-&gt;inkset ) )
		return( -1 );

	TIFFGetFieldDefaulted( rtiff-&gt;tiff, 
		TIFFTAG_COMPRESSION, &amp;header-&gt;compression );

	/* One of the types we decompress?
	 */
	for( i = 0; i &lt; VIPS_NUMBER( rtiff_we_decompress ); i++ )
		if( header-&gt;compression == rtiff_we_decompress[i] ) {
#ifdef DEBUG
			printf( "rtiff_header_read: "
				"compression %d handled by us\n", 
				header-&gt;compression );
#endif /*DEBUG*/
			header-&gt;we_decompress = TRUE;
			break;
		}

	/* We must set this here since it'll change the value of scanline_size.
	 */
	rtiff_set_decode_format( rtiff );

	/* Request YCbCr expansion. libtiff complains if you do this for
	 * non-jpg images. We must set this here since it changes the result
	 * of scanline_size.
	 */
	if( header-&gt;compression != COMPRESSION_JPEG &amp;&amp;
		header-&gt;photometric_interpretation == PHOTOMETRIC_YCBCR ) {
		/* We rely on the jpg decompressor to upsample chroma
		 * subsampled images. If there is chroma subsampling but
		 * no jpg compression, we have to give up.
		 *
		 * tiffcp fails for images like this too.
		 */
                uint16 hsub, vsub;

                TIFFGetFieldDefaulted( rtiff-&gt;tiff, 
			TIFFTAG_YCBCRSUBSAMPLING, &amp;hsub, &amp;vsub );
                if( hsub != 1 || 
			vsub != 1 ) {
			vips_error( "tiff2vips",
				"%s", _( "subsampled images not supported" ) );
			return( -1 );
                }
        }

	if( header-&gt;photometric_interpretation == PHOTOMETRIC_LOGLUV ) {
		if( header-&gt;compression != COMPRESSION_SGILOG &amp;&amp;
			header-&gt;compression != COMPRESSION_SGILOG24 ) {
			vips_error( "tiff2vips",
				"%s", _( "not SGI-compressed LOGLUV" ) );
			return( -1 );
		}
	}

	/* For logluv, the calibration factor to get to absolute luminance.
	 */
	if( !TIFFGetField( rtiff-&gt;tiff, TIFFTAG_STONITS, &amp;header-&gt;stonits ) )
		header-&gt;stonits = 1.0;

	/* Arbitrary sanity-checking limits.
	 */
	if( header-&gt;width &lt;= 0 ||
		header-&gt;width &gt;= VIPS_MAX_COORD ||
		header-&gt;height &lt;= 0 ||
		header-&gt;height &gt;= VIPS_MAX_COORD ) {
		vips_error( "tiff2vips",
			"%s", _( "width/height out of range" ) );
		return( -1 );
	}

	if( header-&gt;samples_per_pixel &lt;= 0 || 
		header-&gt;samples_per_pixel &gt; 10000 || 
		header-&gt;bits_per_sample &lt;= 0 || 
		header-&gt;bits_per_sample &gt; 32 ) {
		vips_error( "tiff2vips", 
			"%s", _( "samples out of range" ) );
		return( -1 );
	}

	header-&gt;sample_format = get_sample_format( rtiff-&gt;tiff );
	header-&gt;orientation = get_orientation( rtiff-&gt;tiff );

	header-&gt;separate = FALSE; 
	if( tfexists( rtiff-&gt;tiff, TIFFTAG_PLANARCONFIG ) ) {
		int v; 

		if( !tfget16( rtiff-&gt;tiff, TIFFTAG_PLANARCONFIG, &amp;v ) )
			return( -1 );
		if( v == PLANARCONFIG_SEPARATE )
			header-&gt;separate = TRUE; 
	}

	/* TIFFGetField needs a uint16 to write count to.
	 */
	if( TIFFGetField( rtiff-&gt;tiff, TIFFTAG_SUBIFD, 
		&amp;subifd_count, &amp;subifd_offsets ) )
		header-&gt;subifd_count = subifd_count;

	/* IMAGEDESCRIPTION often has useful metadata. libtiff makes sure 
	 * that data is null-terminated and contains no embedded null 
	 * characters.
	 */
	if( TIFFGetField( rtiff-&gt;tiff, 
		TIFFTAG_IMAGEDESCRIPTION, &amp;image_description ) )
		header-&gt;image_description = 
			vips_strdup( VIPS_OBJECT( rtiff-&gt;out ), 
				image_description );

	/* Tiles and strip images have slightly different fields.
	 */
	header-&gt;tiled = TIFFIsTiled( rtiff-&gt;tiff );

#ifdef DEBUG
	printf( "rtiff_header_read: header.width = %d\n", 
		header-&gt;width );
	printf( "rtiff_header_read: header.height = %d\n", 
		header-&gt;height );
	printf( "rtiff_header_read: header.samples_per_pixel = %d\n", 
		header-&gt;samples_per_pixel );
	printf( "rtiff_header_read: header.bits_per_sample = %d\n", 
		header-&gt;bits_per_sample );
	printf( "rtiff_header_read: header.sample_format = %d\n", 
		header-&gt;sample_format );
	printf( "rtiff_header_read: header.orientation = %d\n", 
		header-&gt;orientation );
	printf( "rtiff_header_read: header.tiled = %d\n", 
		header-&gt;tiled );
#endif /*DEBUG*/

	if( header-&gt;tiled ) {
		if( !tfget32( rtiff-&gt;tiff, 
			TIFFTAG_TILEWIDTH, &amp;header-&gt;tile_width ) ||
			!tfget32( rtiff-&gt;tiff, 
				TIFFTAG_TILELENGTH, &amp;header-&gt;tile_height ) )
			return( -1 );

#ifdef DEBUG
		printf( "rtiff_header_read: header.tile_width = %d\n", 
			header-&gt;tile_width );
		printf( "rtiff_header_read: header.tile_height = %d\n", 
			header-&gt;tile_height );
#endif /*DEBUG*/

		/* Arbitrary sanity-checking limits.
		 */
		if( header-&gt;tile_width &lt;= 0 ||
			header-&gt;tile_width &gt; 10000 ||
			header-&gt;tile_height &lt;= 0 ||
			header-&gt;tile_height &gt; 10000 ) {
			vips_error( "tiff2vips",
				"%s", _( "tile size out of range" ) );
			return( -1 );
		}

		header-&gt;tile_size = TIFFTileSize( rtiff-&gt;tiff );
		header-&gt;tile_row_size = TIFFTileRowSize( rtiff-&gt;tiff );

#ifdef DEBUG
		printf( "rtiff_header_read: header.tile_size = %zd\n", 
			header-&gt;tile_size );
		printf( "rtiff_header_read: header.tile_row_size = %zd\n", 
			header-&gt;tile_row_size );
#endif /*DEBUG*/

		/* Fuzzed TIFFs can give crazy values for tile_size. Sanity
		 * check at 100mb per tile.
		 */
		if( header-&gt;tile_size &lt;= 0 ||
			header-&gt;tile_size &gt; 100 * 1000 * 1000 ||
			header-&gt;tile_row_size &lt;= 0 ||
			header-&gt;tile_row_size &gt; 100 * 1000 * 1000 ) {
			vips_error( "tiff2vips",
				"%s", _( "tile size out of range" ) );
			return( -1 );
		}

		/* Stop some compiler warnings.
		 */
		header-&gt;rows_per_strip = 0; 
		header-&gt;strip_size = 0; 
		header-&gt;number_of_strips = 0; 
		header-&gt;read_height = 0;
		header-&gt;read_size = 0;
	}
	else {
		if( !tfget32( rtiff-&gt;tiff, 
			TIFFTAG_ROWSPERSTRIP, &amp;header-&gt;rows_per_strip ) )
			return( -1 );
		header-&gt;strip_size = TIFFStripSize( rtiff-&gt;tiff );
		header-&gt;scanline_size = TIFFScanlineSize( rtiff-&gt;tiff );
		header-&gt;number_of_strips = TIFFNumberOfStrips( rtiff-&gt;tiff );

#ifdef DEBUG
		printf( "rtiff_header_read: header.rows_per_strip = %d\n", 
			header-&gt;rows_per_strip );
		printf( "rtiff_header_read: header.strip_size = %zd\n", 
			header-&gt;strip_size );
		printf( "rtiff_header_read: header.scanline_size = %zd\n", 
			header-&gt;scanline_size );
		printf( "rtiff_header_read: header.number_of_strips = %d\n", 
			header-&gt;number_of_strips );
#endif /*DEBUG*/

		/* libtiff has two strip-wise readers. TIFFReadEncodedStrip()
		 * decompresses an entire strip to memory. It's fast, but it
		 * will need a lot of ram if the strip is large.
		 * TIFFReadScanline() reads a single scanline. It's slower, but
		 * will save a lot of memory if strips are large.
		 *
		 * If this image has a strip size of over 128 lines, fall back
		 * to TIFFReadScanline(), otherwise use TIFFReadEncodedStrip().
		 *
		 * Don't do this in plane-separate mode. TIFFReadScanline() is
		 * too fiddly to use in this case.
		 *
		 * Don't try scanline reading for YCbCr images.
		 * TIFFScanlineSize() will not work in this case due to
		 * chroma subsampling.
		 */
		if( header-&gt;rows_per_strip &gt; 128 &amp;&amp;
			!header-&gt;separate &amp;&amp;
			header-&gt;photometric_interpretation != 
				PHOTOMETRIC_YCBCR ) {
			header-&gt;read_scanlinewise = TRUE;
			header-&gt;read_height = 1;
			header-&gt;read_size = rtiff-&gt;header.scanline_size;
		}
		else {
			header-&gt;read_scanlinewise = FALSE;

			/* rows_per_strip can be 2 ** 32 - 1, meaning the 
			 * whole image. Clip this down to height to avoid 
			 * confusing vips. 
			 *
			 * And it musn't be zero.
			 */
			header-&gt;read_height = VIPS_CLIP( 1, 
				header-&gt;rows_per_strip, header-&gt;height );
			header-&gt;read_size = header-&gt;strip_size;
		}

#ifdef DEBUG
		printf( "rtiff_header_read: header.read_scanlinewise = %d\n", 
			header-&gt;read_scanlinewise );
		printf( "rtiff_header_read: header.read_height = %d\n", 
			header-&gt;read_height );
		printf( "rtiff_header_read: header.read_size = %zd\n", 
			header-&gt;read_size );
#endif /*DEBUG*/

		/* Stop some compiler warnings.
		 */
		header-&gt;tile_width = 0;
		header-&gt;tile_height = 0;
		header-&gt;tile_size = 0;
		header-&gt;tile_row_size = 0;
	}

	TIFFGetFieldDefaulted( rtiff-&gt;tiff, TIFFTAG_EXTRASAMPLES,
		&amp;extra_samples_count, &amp;extra_samples_types );

	header-&gt;alpha_band = -1;
	if( extra_samples_count &gt; 0 ) {
		/* There must be exactly one band which is 
		 * EXTRASAMPLE_ASSOCALPHA. Note which one it is so we can 
		 * unpremultiply with the right channel.
		 */
		int i;

		for( i = 0; i &lt; extra_samples_count; i++ ) 
			if( extra_samples_types[i] == EXTRASAMPLE_ASSOCALPHA ) {
				if( header-&gt;alpha_band != -1 )
					g_warning( "%s", _( "more than one "
						"alpha -- ignoring" ) );

				header-&gt;alpha_band = header-&gt;samples_per_pixel -
					extra_samples_count + i;
			}
	}

	return( 0 );
}

static int
rtiff_header_equal( RtiffHeader *h1, RtiffHeader *h2 )
{
	if( h1-&gt;width != h2-&gt;width ||
		h1-&gt;height != h2-&gt;height ||
		h1-&gt;samples_per_pixel != h2-&gt;samples_per_pixel ||
		h1-&gt;bits_per_sample != h2-&gt;bits_per_sample ||
		h1-&gt;photometric_interpretation != 
			h2-&gt;photometric_interpretation ||
		h1-&gt;sample_format != h2-&gt;sample_format ||
		h1-&gt;compression != h2-&gt;compression ||
		h1-&gt;separate != h2-&gt;separate ||
		h1-&gt;tiled != h2-&gt;tiled ||
		h1-&gt;orientation != h2-&gt;orientation )
		return( 0 );

	if( h1-&gt;tiled ) {
		if( h1-&gt;tile_width != h2-&gt;tile_width ||
			h1-&gt;tile_height != h2-&gt;tile_height )
			return( 0 );
	}
	else {
		if( h1-&gt;read_height != h2-&gt;read_height ||
			h1-&gt;read_size != h2-&gt;read_size ||
			h1-&gt;number_of_strips != h2-&gt;number_of_strips )
			return( 0 );
	}

	return( 1 );
}

static int
rtiff_header_read_all( Rtiff *rtiff )
{
#ifdef DEBUG
	printf( "rtiff_header_read_all: "
		"reading header for page %d ...\n", rtiff-&gt;page );
#endif /*DEBUG*/

	/* -1 means "to the end". 
	 *
	 * We must count pages before selecting and reading the header of the 
	 * first page, since scanning a TIFF can change the value of libtiff's 
	 * internal header fields in strange ways, especially if the TIFF is 
	 * corrupt.  
	 */
	rtiff-&gt;n_pages = rtiff_n_pages( rtiff );

	if( rtiff_set_page( rtiff, rtiff-&gt;page ) ||
		rtiff_header_read( rtiff, &amp;rtiff-&gt;header ) )
		return( -1 ); 

	/* If we're to read many pages, verify that they are all identical. 
	 */
	if( rtiff-&gt;n == -1 )
		rtiff-&gt;n = rtiff-&gt;n_pages - rtiff-&gt;page;
	if( rtiff-&gt;n &gt; 1 ) {
		int i;

		for( i = 1; i &lt; rtiff-&gt;n; i++ ) {
			RtiffHeader header;

#ifdef DEBUG
			printf( "rtiff_header_read_all: "
				"verifying header for page %d ...\n",
				rtiff-&gt;page + i );
#endif /*DEBUG*/

			if( rtiff_set_page( rtiff, rtiff-&gt;page + i ) ||
				rtiff_header_read( rtiff, &amp;header ) )
				return( -1 );

			if( !rtiff_header_equal( &amp;rtiff-&gt;header, &amp;header ) ) {
				vips_error( "tiff2vips",
					_( "page %d differs from page %d" ),
					rtiff-&gt;page + i, rtiff-&gt;page );
				return( -1 );
			}
		}

		/* Make sure the next set_page() will reread the directory.
		 */
		rtiff-&gt;current_page = -1;
	}

	return( 0 );
}

typedef gboolean (*TiffPropertyFn)( TIFF *tif );

static gboolean
vips__testtiff_source( VipsSource *source, TiffPropertyFn fn )
{
	TIFF *tif;
	gboolean property;

	vips__tiff_init();

	if( !(tif = vips__tiff_openin_source( source )) ) {
		vips_error_clear();
		return( FALSE );
	}

	property = fn ? fn( tif ) : TRUE;

	TIFFClose( tif );

	return( property );
}

gboolean
vips__istiff_source( VipsSource *source )
{
	return( vips__testtiff_source( source, NULL ) ); 
}

gboolean
vips__istifftiled_source( VipsSource *source )
{
	return( vips__testtiff_source( source, TIFFIsTiled ) ); 
}

int
vips__tiff_read_header_source( VipsSource *source, VipsImage *out, 
	int page, int n, gboolean autorotate, int subifd )
{
	Rtiff *rtiff;

	vips__tiff_init();

	if( !(rtiff = rtiff_new( source, out, page, n, autorotate, subifd )) ||
		rtiff_header_read_all( rtiff ) )
		return( -1 );

	if( rtiff_set_header( rtiff, out ) )
		return( -1 );

	if( rtiff-&gt;autorotate &amp;&amp;
		vips_image_get_orientation_swap( out ) ) {
		VIPS_SWAP( int, out-&gt;Xsize, out-&gt;Ysize );
		vips_autorot_remove_angle( out );
	}

	/* We never call vips_source_decode() since we need to be able to
	 * seek() the whole way through the file. Just minimise instead,
	 */
	vips_source_minimise( source );

	return( 0 );
}

int
vips__tiff_read_source( VipsSource *source, VipsImage *out, 
	int page, int n, gboolean autorotate, int subifd )
{
	Rtiff *rtiff;

#ifdef DEBUG
	printf( "tiff2vips: libtiff version is \"%s\"\n", TIFFGetVersion() );
#endif /*DEBUG*/

	vips__tiff_init();

	if( !(rtiff = rtiff_new( source, out, page, n, autorotate, subifd )) ||
		rtiff_header_read_all( rtiff ) )
		return( -1 );

	if( rtiff-&gt;header.tiled ) {
		if( rtiff_read_tilewise( rtiff, out ) )
			return( -1 );
	}
	else {
		if( rtiff_read_stripwise( rtiff, out ) )
			return( -1 );
	}

	/* We never call vips_source_decode() since we need to be able to
	 * seek() the whole way through the file. Just minimise instead,
	 */
	vips_source_minimise( source );

	return( 0 );
}

#endif /*HAVE_TIFF*/
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
