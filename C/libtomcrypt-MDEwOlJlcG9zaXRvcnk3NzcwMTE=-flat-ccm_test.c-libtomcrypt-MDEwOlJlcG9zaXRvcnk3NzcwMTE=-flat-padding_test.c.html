
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 22.0125786163522%, Tokens: 11</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_CCM_MODE
3  int ccm_test(void)
4  {
5  #ifndef LTC_TEST
6     return CRYPT_NOP;
7  #else
8     static const struct {
9         unsigned char key[16];
10         unsigned char nonce[16];
11         int           noncelen;
12         unsigned char header[64];
13         int           headerlen;
14         unsigned char pt[64];
15         int           ptlen;
16         unsigned char ct[64];
17         unsigned char tag[16];
18         unsigned long taglen;
19     } tests[] = {
20  {
21     { 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
22       0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF },
23     { 0x00, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0xA0,
24       0xA1, 0xA2, 0xA3, 0xA4, 0xA5 },
25     13,
26     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
27     8,
28     { 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
29       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
30       0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E },
31     23,
32     { 0x58, 0x8C, 0x97, 0x9A, 0x61, 0xC6, 0x63, 0xD2,
33       0xF0, 0x66, 0xD0, 0xC2, 0xC0, 0xF9, 0x89, 0x80,
34       0x6D, 0x5F, 0x6B, 0x61, 0xDA, 0xC3, 0x84 },
35     { 0x17, 0xe8, 0xd1, 0x2c, 0xfd, 0xf9, 0x26, 0xe0 },
36     8
37  },
38  {
39     { 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
40       0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF },
41     { 0x00, 0x00, 0x00, 0x06, 0x05, 0x04, 0x03, 0xA0,
42       0xA1, 0xA2, 0xA3, 0xA4, 0xA5 },
43     13,
44     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
45       0x08, 0x09, 0x0A, 0x0B },
46     12,
47     { 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,
48       0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B,
49       0x1C, 0x1D, 0x1E },
50     19,
51     { 0xA2, 0x8C, 0x68, 0x65, 0x93, 0x9A, 0x9A, 0x79,
52       0xFA, 0xAA, 0x5C, 0x4C, 0x2A, 0x9D, 0x4A, 0x91,
53       0xCD, 0xAC, 0x8C },
54     { 0x96, 0xC8, 0x61, 0xB9, 0xC9, 0xE6, 0x1E, 0xF1 },
55     8
56  },
57  {
58     { 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
59       0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f },
60     { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16  },
61     7,
62     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
63     8,
64     { 0x20, 0x21, 0x22, 0x23 },
65     4,
66     { 0x71, 0x62, 0x01, 0x5b },
67     { 0x4d, 0xac, 0x25, 0x5d },
68     4
69  },
70  {
71     { 0xc9, 0x7c, 0x1f, 0x67, 0xce, 0x37, 0x11, 0x85,
72       0x51, 0x4a, 0x8a, 0x19, 0xf2, 0xbd, 0xd5, 0x2f },
73     { 0x00, 0x50, 0x30, 0xf1, 0x84, 0x44, 0x08, 0xb5,
74       0x03, 0x97, 0x76, 0xe7, 0x0c },
75     13,
76     { 0x08, 0x40, 0x0f, 0xd2, 0xe1, 0x28, 0xa5, 0x7c,
77       0x50, 0x30, 0xf1, 0x84, 0x44, 0x08, 0xab, 0xae,
78       0xa5, 0xb8, 0xfc, 0xba, 0x00, 0x00 },
79     22,
80     { 0xf8, 0xba, 0x1a, 0x55, 0xd0, 0x2f, 0x85, 0xae,
81       0x96, 0x7b, 0xb6, 0x2f, 0xb6, 0xcd, 0xa8, 0xeb,
82       0x7e, 0x78, 0xa0, 0x50 },
83     20,
84     { 0xf3, 0xd0, 0xa2, 0xfe, 0x9a, 0x3d, 0xbf, 0x23,
85       0x42, 0xa6, 0x43, 0xe4, 0x32, 0x46, 0xe8, 0x0c,
86       0x3c, 0x04, 0xd0, 0x19 },
87     { 0x78, 0x45, 0xce, 0x0b, 0x16, 0xf9, 0x76, 0x23 },
88     8
89  },
90  };
91     unsigned long taglen, x, y;
92     unsigned char buf[64], buf2[64], tag[16], tag2[16], tag3[16], zero[64];
93     int           err, idx;
94     symmetric_key skey;
95     ccm_state ccm;
96     zeromem(zero, 64);
97     idx = find_cipher("aes");
98     if (idx == -1) {
99        idx = find_cipher("rijndael");
100        if (idx == -1) {
101           return CRYPT_NOP;
102        }
103     }
104     for (x = 0; x < (sizeof(tests)/sizeof(tests[0])); x++) {
105        for (y = 0; y < 2; y++) {
106           taglen = tests[x].taglen;
107           if (y == 0) {
108              if ((err = cipher_descriptor[idx].setup(tests[x].key, 16, 0, &skey)) != CRYPT_OK) {
109                 return err;
110              }
111              if ((err = ccm_memory(idx,
112                                    tests[x].key, 16,
113                                    &skey,
114                                    tests[x].nonce, tests[x].noncelen,
115                                    tests[x].header, tests[x].headerlen,
116                                    (unsigned char*)tests[x].pt, tests[x].ptlen,
117                                    buf,
118                                    tag, &taglen, 0)) != CRYPT_OK) {
119                 return err;
120              }
121              if ((err = ccm_memory(idx,
122                                    tests[x].key, 16,
123                                    &skey,
124                                    tests[x].nonce, tests[x].noncelen,
125                                    tests[x].header, tests[x].headerlen,
126                                    (unsigned char*)tests[x].pt, tests[x].ptlen,
127                                    buf,
128                                    tag, &taglen, 0)) != CRYPT_OK) {
129                 return err;
130              }
131           } else {
132              if ((err = ccm_init(&ccm, idx, tests[x].key, 16, tests[x].ptlen, tests[x].taglen, tests[x].headerlen)) != CRYPT_OK) {
133                 return err;
134              }
135              if ((err = ccm_add_nonce(&ccm, tests[x].nonce, tests[x].noncelen)) != CRYPT_OK) {
136                 return err;
137              }
138              if ((err = ccm_add_aad(&ccm, tests[x].header, tests[x].headerlen)) != CRYPT_OK) {
139                 return err;
140              }
141              if ((err = ccm_process(&ccm, (unsigned char*)tests[x].pt, tests[x].ptlen, buf, CCM_ENCRYPT)) != CRYPT_OK) {
142                 return err;
143              }
144              if ((err = ccm_done(&ccm, tag, &taglen)) != CRYPT_OK) {
145                 return err;
146              }
147           }
148           if (compare_testvector(buf, tests[x].ptlen, tests[x].ct, tests[x].ptlen, "CCM encrypt data", x)) {
149              return CRYPT_FAIL_TESTVECTOR;
150           }
151           if (compare_testvector(tag, taglen, tests[x].tag, tests[x].taglen, "CCM encrypt tag", x)) {
152              return CRYPT_FAIL_TESTVECTOR;
153           }
154           if (y == 0) {
155              XMEMCPY(tag3, tests[x].tag, tests[x].taglen);
156              taglen = tests[x].taglen;
157              if ((err = ccm_memory(idx,
158                                    tests[x].key, 16,
159                                    NULL,
160                                    tests[x].nonce, tests[x].noncelen,
161                                    tests[x].header, tests[x].headerlen,
162                                    buf2, tests[x].ptlen,
163                                    buf,
164                                    tag3, &taglen, 1   )) != CRYPT_OK) {
165                 return err;
166              }
167           } else {
168              if ((err = ccm_init(&ccm, idx, tests[x].key, 16, tests[x].ptlen, tests[x].taglen, tests[x].headerlen)) != CRYPT_OK) {
169                 return err;
170              }
171              if ((err = ccm_add_nonce(&ccm, tests[x].nonce, tests[x].noncelen)) != CRYPT_OK) {
172                 return err;
173              }
174              if ((err = ccm_add_aad(&ccm, tests[x].header, tests[x].headerlen)) != CRYPT_OK) {
175                 return err;
176              }
177              if ((err = ccm_process(&ccm, buf2, tests[x].ptlen, buf, CCM_DECRYPT)) != CRYPT_OK) {
178                 return err;
179              }
180              if ((err = ccm_done(&ccm, tag2, &taglen)) != CRYPT_OK) {
181                 return err;
182              }
183           }
184           if (compare_testvector(buf2, tests[x].ptlen, tests[x].pt, tests[x].ptlen, "CCM decrypt data", x)) {
185              return CRYPT_FAIL_TESTVECTOR;
186           }
187           if (y == 0) {
188              XMEMCPY(tag3, tests[x].tag, tests[x].taglen);
189              tag3[0] ^= 0xff; &bsol;* set the tag to the wrong value */
190              taglen = tests[x].taglen;
191              if ((err = ccm_memory(idx,
192                                    tests[x].key, 16,
193                                    NULL,
194                                    tests[x].nonce, tests[x].noncelen,
195                                    tests[x].header, tests[x].headerlen,
196                                    buf2, tests[x].ptlen,
197                                    buf,
198                                    tag3, &taglen, 1   )) != CRYPT_ERROR) {
199                 return CRYPT_FAIL_TESTVECTOR;
200              }
201              if (compare_testvector(buf2, tests[x].ptlen, zero, tests[x].ptlen, "CCM decrypt wrong tag", x)) {
202                 return CRYPT_FAIL_TESTVECTOR;
203              }
204           } else {
205              if (compare_testvector(tag2, taglen, tests[x].tag, tests[x].taglen, "CCM decrypt tag", x)) {
206                 return CRYPT_FAIL_TESTVECTOR;
207              }
208           }
209           if (y == 0) {
210              cipher_descriptor[idx].done(&skey);
211           }
<span onclick='openModal()' class='match'>212        }
213     }
214     {
215        unsigned char key[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };
216        unsigned char iv[]  = { 0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51 };
</span>217        unsigned char valid_tag[]   = { 0x23,0x1a,0x2d,0x8f };
218        unsigned char invalid_tag[] = { 0x23,0x1a,0x2d,0x8f,0x6a };
219        unsigned char msg[] = { 0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f };
220        unsigned char ct[]  = { 0xd3,0xda,0xb1,0xee,0x49,0x4c,0xc2,0x29,0x09,0x9d,0x6c,0xac,0x7d,0xf1,0x4a,0xdd };
221        unsigned char pt[20] = { 0 };
222        taglen = sizeof(valid_tag);
223        err = ccm_memory(idx, key, sizeof(key), NULL, iv, sizeof(iv), NULL, 0,
224                         pt, sizeof(ct), ct, valid_tag, &taglen, CCM_DECRYPT);
225        if ((err != CRYPT_OK) || (XMEMCMP(msg, pt, sizeof(msg)) != 0)) {
226           return CRYPT_FAIL_TESTVECTOR;
227        }
228        taglen = sizeof(invalid_tag);
229        err = ccm_memory(idx, key, sizeof(key), NULL, iv, sizeof(iv), NULL, 0,
230                         pt, sizeof(ct), ct, invalid_tag, &taglen, CCM_DECRYPT);
231        if (err == CRYPT_OK) {
232           return CRYPT_FAIL_TESTVECTOR; &bsol;* should fail */
233        }
234     }
235     return CRYPT_OK;
236  #endif
237  }
238  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-padding_test.c</h3>
            <pre><code>1  #include  <tomcrypt_test.h>
2  #ifdef LTC_PADDING
3  typedef struct padding_testcase_ padding_testcase;
4  typedef int (*cmp_padding_testcase)(const padding_testcase*, const unsigned char*, unsigned long);
5  struct padding_testcase_ {
6     unsigned long is, should, max, mode;
7     const char* name;
8     cmp_padding_testcase cmp;
9  };
10  #define EQ(a, b) s_eq((a), (b), #a, #b)
11  static int s_eq(unsigned long a, unsigned long b, const char* s_a, const char* s_b)
12  {
13     if (a == b) return CRYPT_OK;
14  #if defined(LTC_TEST) && defined(LTC_TEST_DBG)
15     else fprintf(stderr, "'%s == %s' failed, %lu is not equal to %lu\n", s_a, s_b, a, b);
16  #else
17     LTC_UNUSED_PARAM(s_a);
18     LTC_UNUSED_PARAM(s_b);
19  #endif
20     return CRYPT_FAIL_TESTVECTOR;
21  }
22  static int s_cmp_pkcs7(const padding_testcase* t, const unsigned char* p, unsigned long len)
23  {
24     unsigned long n, diff = len - t->is;
25     DOX(EQ(len, t->should), t->name);
26     for (n = len - diff; n < len; ++n) {
27        DOX(EQ(p[n], diff), t->name);
28     }
29     return CRYPT_OK;
30  }
31  #ifdef LTC_RNG_GET_BYTES
32  static int s_cmp_iso_10126(const padding_testcase* t, const unsigned char* p, unsigned long len)
33  {
34     LTC_UNUSED_PARAM(p);
35     if (len < t->should || len > t->max) {
36  #if defined(LTC_TEST) && defined(LTC_TEST_DBG)
37        fprintf(stderr, "(%lu < %lu || %lu > %lu) failed, %s\n", len, t->should, len, t->max, t->name);
38  #endif
39        return CRYPT_FAIL_TESTVECTOR;
40     }
41     DOX(EQ(p[len - 1], len - t->is), t->name);
42     return CRYPT_OK;
43  }
44  #endif
45  static int s_cmp_x923(const padding_testcase* t, const unsigned char* p, unsigned long len)
46  {
47     unsigned long n, diff = len - t->is;
48     DOX(EQ(len, t->should), t->name);
49     for (n = len - diff; n < len - 1; ++n) {
50        DOX(EQ(p[n], 0x0), t->name);
51     }
52     DOX(EQ(p[len - 1], diff), t->name);
53     return CRYPT_OK;
54  }
55  static int s_cmp_oaz(const padding_testcase* t, const unsigned char* p, unsigned long len)
56  {
57     unsigned long n, diff = len - t->is;
58     DOX(EQ(len, t->should), t->name);
59     n = len - diff;
60     DOX(EQ(p[n], 0x80), t->name);
61     n++;
62     for (; n < len; ++n) {
63        DOX(EQ(p[n], 0x0), t->name);
64     }
65     return CRYPT_OK;
66  }
67  static int s_cmp_zero(const padding_testcase* t, const unsigned char* p, unsigned long len)
68  {
69     unsigned long n, diff = len - t->is;
70     DOX(EQ(len, t->should), t->name);
71     for (n = len - diff; n < len; ++n) {
72        DOX(EQ(p[n], 0x0), t->name);
73     }
74     return CRYPT_OK;
75  }
76  static int s_cmp_ssh(const padding_testcase* t, const unsigned char* p, unsigned long len)
77  {
78     unsigned long n, diff = len - t->is;
79     unsigned char pad = 0x1;
80     DOX(EQ(len, t->should), t->name);
81     for (n = len - diff; n < len; ++n) {
82        DOX(EQ(p[n], pad), t->name);
83        pad++;
84     }
85     return CRYPT_OK;
86  }
87  static int s_padding_testrun(const padding_testcase* t)
88  {
89     unsigned long len;
90     unsigned char buf[1024];
91     len = sizeof(buf);
92     XMEMSET(buf, 0xAA, t->is);
93     DO(padding_pad(buf, t->is, &len, t->mode));
94     DO(t->cmp(t, buf, len));
95     DO(padding_depad(buf, &len, t->mode));
96     DO(EQ(len, t->is));
97     return CRYPT_OK;
98  }
99  int padding_test(void)
100  {
101     const padding_testcase cases[] = {
102                               {   0,  16,   0, LTC_PAD_PKCS7 | 16, "0-pkcs7",     s_cmp_pkcs7 },
103                               {   1,  16,   0, LTC_PAD_PKCS7 | 16, "1-pkcs7",     s_cmp_pkcs7 },
104                               {  15,  16,   0, LTC_PAD_PKCS7 | 16, "15-pkcs7",    s_cmp_pkcs7 },
105                               {  16,  32,   0, LTC_PAD_PKCS7 | 16, "16-pkcs7",    s_cmp_pkcs7 },
106                               { 255, 256,   0, LTC_PAD_PKCS7 | 16, "255-pkcs7",   s_cmp_pkcs7 },
107                               { 256, 272,   0, LTC_PAD_PKCS7 | 16, "256-pkcs7",   s_cmp_pkcs7 },
108  #ifdef LTC_RNG_GET_BYTES
109                               {   0,  16, 256, LTC_PAD_ISO_10126 | 16, "0-rand",     s_cmp_iso_10126 },
110                               {   1,  16, 272, LTC_PAD_ISO_10126 | 16, "1-rand",     s_cmp_iso_10126 },
111                               {  15,  16, 272, LTC_PAD_ISO_10126 | 16, "15-rand",    s_cmp_iso_10126 },
112                               {  16,  32, 288, LTC_PAD_ISO_10126 | 16, "16-rand",    s_cmp_iso_10126 },
113                               { 255, 256, 512, LTC_PAD_ISO_10126 | 16, "255-rand",   s_cmp_iso_10126 },
114                               { 256, 272, 528, LTC_PAD_ISO_10126 | 16, "256-rand",   s_cmp_iso_10126 },
115  #endif
116                               {   0,  16,   0, LTC_PAD_ANSI_X923 | 16, "0-x923",   s_cmp_x923 },
117                               {   1,  16,   0, LTC_PAD_ANSI_X923 | 16, "1-x923",   s_cmp_x923 },
118                               {  15,  16,   0, LTC_PAD_ANSI_X923 | 16, "15-x923",  s_cmp_x923 },
119                               {  16,  32,   0, LTC_PAD_ANSI_X923 | 16, "16-x923",  s_cmp_x923 },
120                               { 255, 256,   0, LTC_PAD_ANSI_X923 | 16, "255-x923", s_cmp_x923 },
121                               { 256, 272,   0, LTC_PAD_ANSI_X923 | 16, "256-x923", s_cmp_x923 },
122                               {   0,  16,   0, LTC_PAD_SSH | 16, "0-ssh",   s_cmp_ssh },
123                               {   1,  16,   0, LTC_PAD_SSH | 16, "1-ssh",   s_cmp_ssh },
124                               {  15,  16,   0, LTC_PAD_SSH | 16, "15-ssh",  s_cmp_ssh },
125                               {  16,  32,   0, LTC_PAD_SSH | 16, "16-ssh",  s_cmp_ssh },
126                               { 255, 256,   0, LTC_PAD_SSH | 16, "255-ssh", s_cmp_ssh },
127                               { 256, 272,   0, LTC_PAD_SSH | 16, "256-ssh", s_cmp_ssh },
128                               {   0,  16,   0, LTC_PAD_ONE_AND_ZERO | 16, "0-one-and-zero",   s_cmp_oaz },
129                               {   1,  16,   0, LTC_PAD_ONE_AND_ZERO | 16, "1-one-and-zero",   s_cmp_oaz },
130                               {  15,  16,   0, LTC_PAD_ONE_AND_ZERO | 16, "15-one-and-zero",  s_cmp_oaz },
131                               {  16,  32,   0, LTC_PAD_ONE_AND_ZERO | 16, "16-one-and-zero",  s_cmp_oaz },
132                               { 255, 256,   0, LTC_PAD_ONE_AND_ZERO | 16, "255-one-and-zero", s_cmp_oaz },
133                               { 256, 272,   0, LTC_PAD_ONE_AND_ZERO | 16, "256-one-and-zero", s_cmp_oaz },
134                               {   0,   0,   0, LTC_PAD_ZERO | 16, "0-zero",   s_cmp_zero },
135                               {   1,  16,   0, LTC_PAD_ZERO | 16, "1-zero",   s_cmp_zero },
136                               {  15,  16,   0, LTC_PAD_ZERO | 16, "15-zero",  s_cmp_zero },
137                               {  16,  16,   0, LTC_PAD_ZERO | 16, "16-zero",  s_cmp_zero },
138                               { 255, 256,   0, LTC_PAD_ZERO | 16, "255-zero", s_cmp_zero },
139                               { 256, 256,   0, LTC_PAD_ZERO | 16, "256-zero", s_cmp_zero },
140                               {   0,  16,   0, LTC_PAD_ZERO_ALWAYS | 16, "0-zero-always",   s_cmp_zero },
141                               {   1,  16,   0, LTC_PAD_ZERO_ALWAYS | 16, "1-zero-always",   s_cmp_zero },
142                               {  15,  16,   0, LTC_PAD_ZERO_ALWAYS | 16, "15-zero-always",  s_cmp_zero },
143                               {  16,  32,   0, LTC_PAD_ZERO_ALWAYS | 16, "16-zero-always",  s_cmp_zero },
144                               { 255, 256,   0, LTC_PAD_ZERO_ALWAYS | 16, "255-zero-always", s_cmp_zero },
145                               { 256, 272,   0, LTC_PAD_ZERO_ALWAYS | 16, "256-zero-always", s_cmp_zero },
146     };
147     unsigned i;
148     const struct {
149        unsigned char data[16];
150        unsigned long len;
151        unsigned long mode;
152     } tv[] = {
153        { { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x04, 0x04, 0x04, 0x04 }, 12, LTC_PAD_PKCS7 | 16 },
154        { { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x00, 0x00, 0x00, 0x04 }, 12, LTC_PAD_ANSI_X923 | 16 },
155  #ifdef LTC_RNG_GET_BYTES
156        { { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x81, 0xA6, 0x23, 0x04 }, 12, LTC_PAD_ISO_10126 | 16 },
157  #endif
158        { { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x80, 0x00, 0x00, 0x00 }, 12, LTC_PAD_ONE_AND_ZERO | 16 },
159        { { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x80 }, 15, LTC_PAD_ONE_AND_ZERO | 16 },
160        { { 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0x00, 0x00, 0x00, 0x00 }, 12, LTC_PAD_ZERO | 16 },
161     };
162     unsigned char buf[256 + 16];
163     unsigned long l;
164     for (i = 0; i < sizeof(cases)/sizeof(cases[0]); ++i) {
165        DOX(s_padding_testrun(&cases[i]), cases[i].name);
166     }
167     for (i = 0; i < sizeof(tv)/sizeof(tv[0]); ++i) {
168        XMEMCPY(buf, tv[i].data, sizeof(tv[i].data));
169        l = sizeof(tv[i].data);
170        DO(padding_depad(buf, &l, tv[i].mode));
171        XMEMSET(buf, 0xDD, 16);
172        l = sizeof(buf);
173        DO(padding_pad(buf, tv[i].len, &l, tv[i].mode));
174  #ifdef LTC_RNG_GET_BYTES
175        if ((tv[i].mode & LTC_PAD_MASK) != LTC_PAD_ISO_10126)
176  #endif
177        {
178           COMPARE_TESTVECTOR(tv[i].data, sizeof(tv[i].data), buf, l, "padding fixed TV", i);
<span onclick='openModal()' class='match'>179        }
180     }
181     {
182        unsigned char data[] = { 0x47,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
183        unsigned long len = sizeof(data);
</span>184        SHOULD_FAIL(padding_depad(data, &len, (LTC_PAD_PKCS7 | 16)));
185     }
186     return CRYPT_OK;
187  }
188  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_test.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-padding_test.c</div>
                </div>
                <div class="column column_space"><pre><code>212        }
213     }
214     {
215        unsigned char key[] = { 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };
216        unsigned char iv[]  = { 0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51 };
</pre></code></div>
                <div class="column column_space"><pre><code>179        }
180     }
181     {
182        unsigned char data[] = { 0x47,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
183        unsigned long len = sizeof(data);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    