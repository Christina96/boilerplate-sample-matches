
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.54794520547945%, Tokens: 8</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_QFork_impl.c</h3>
            <pre><code>1  #include "..\server.h"
2  #include "Win32_Portability.h"
3  void SetupRedisGlobals(LPVOID redisData, size_t redisDataSize, uint8_t *dictHashSeed, LPVOID redisModules)
4  {
5  #ifndef NO_QFORKIMPL
6      memcpy(&server, redisData, redisDataSize);
7      dictSetHashFunctionSeed(dictHashSeed);
8      modules = (dict*) redisModules;
9  #endif
10  }
11  int do_rdbSave(char* filename)
12  {
13  #ifndef NO_QFORKIMPL
14      server.rdb_child_pid = GetCurrentProcessId();
15      rdbSaveInfo rsi, *rsiptr;
16      rsiptr = rdbPopulateSaveInfo(&rsi);
17      if( rdbSave(filename, rsiptr) != C_OK ) {
18          serverLog(LL_WARNING,"rdbSave failed in qfork: %s", strerror(errno));
19          return C_ERR;
20      }
21  #endif
22      return C_OK;
23  }
<span onclick='openModal()' class='match'>24  int do_aofSave(char* filename, int aof_pipe_read_ack, int aof_pipe_read_data, int aof_pipe_write_ack)
25  {
26  #ifndef NO_QFORKIMPL
27      int rewriteAppendOnlyFile(char *filename);
28      server.aof_child_pid = GetCurrentProcessId();
29      server.aof_pipe_write_ack_to_parent = aof_pipe_write_ack;
</span>30      server.aof_pipe_read_ack_from_parent = aof_pipe_read_ack;
31      server.aof_pipe_read_data_from_parent = aof_pipe_read_data;
32      server.aof_pipe_read_ack_from_child = -1;
33      server.aof_pipe_write_ack_to_child = -1;
34      server.aof_pipe_write_data_to_child = -1;
35      if (rewriteAppendOnlyFile(filename) != C_OK) {
36          serverLog(LL_WARNING, "rewriteAppendOnlyFile failed in qfork: %s", strerror(errno));
37          return C_ERR;
38      }
39  #endif
40      return C_OK;
41  }
42  int rdbSaveRioWithEOFMark(rio *rdb, int *error);
43  int do_rdbSaveToSlavesSockets(int *fds, int numfds, uint64_t *clientids)
44  {
45  #ifndef NO_QFORKIMPL
46      int retval;
47      rio slave_sockets;
48      server.rdb_child_pid = GetCurrentProcessId();
49      rioInitWithFdset(&slave_sockets,fds,numfds);
50      POSIX_ONLY(zfree(fds););
51      POSIX_ONLY(closeListeningSockets(0);)
52      redisSetProcTitle("redis-rdb-to-slaves");
53      retval = rdbSaveRioWithEOFMark(&slave_sockets,NULL);
54      if (retval == C_OK && rioFlush(&slave_sockets) == 0)
55          retval = C_ERR;
56      if (retval == C_OK) {
57          size_t private_dirty = zmalloc_get_private_dirty(-1);
58          if (private_dirty) {
59              serverLog(LL_NOTICE,
60                  "RDB: %Iu MB of memory used by copy-on-write",                  WIN_PORT_FIX &bsol;* %zu -> %Iu */
61                  private_dirty/(1024*1024));
62          }
63          void *msg = zmalloc(sizeof(uint64_t)*(1+2*numfds));
64          uint64_t *len = msg;
65          uint64_t *ids = len+1;
66          int j, msglen;
67          *len = numfds;
68          for (j = 0; j < numfds; j++) {
69              *ids++ = clientids[j];
70              *ids++ = slave_sockets.io.fdset.state[j];
71          }
72          msglen = sizeof(uint64_t)*(1+2*numfds);
73          if (*len == 0 ||
74              write(server.rdb_pipe_write_result_to_parent,msg,msglen)
75              != msglen)
76          {
77              retval = C_ERR;
78          }
79      }
80      return retval;
81  #endif
82      return C_OK;
83  }
84  int do_socketSave(int *fds, int numfds, uint64_t *clientids, int pipe_write_fd)
85  {
86      server.rdb_pipe_write_result_to_parent = pipe_write_fd;
87      return do_rdbSaveToSlavesSockets(fds, numfds, clientids);
88  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-check-aof.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/win32_types.h"
4  #include "Win32_Interop/Win32_Error.h"
5  #include "Win32_Interop/win32fixes.h"
6  #endif
7  #include "server.h"
8  #include <sys/stat.h>
9  #ifdef _WIN32
10  #define strcasecmp _stricmp
11  #define strncasecmp _strnicmp
12  #endif
13  #define ERROR(...) { \
14      char __buf[1024]; \
15      snprintf(__buf, sizeof(__buf), __VA_ARGS__); \
16      snprintf(error, sizeof(error), "0x%16llx: %s", (PORT_LONGLONG)epos, __buf); \
17  }
18  static char error[1044];
19  static off_t epos;
20  int consumeNewline(char *buf) {
21      if (strncmp(buf,"\r\n",2) != 0) {
22          ERROR("Expected \\r\\n, got: %02x%02x",buf[0],buf[1]);
23          return 0;
24      }
25      return 1;
26  }
27  int readLong(FILE *fp, char prefix, PORT_LONG *target) {
28      char buf[128], *eptr;
29      epos = ftello(fp);
30      if (fgets(buf,sizeof(buf),fp) == NULL) {
31          return 0;
32      }
33      if (buf[0] != prefix) {
34          ERROR("Expected prefix '%c', got: '%c'",prefix,buf[0]);
35          return 0;
36      }
37      *target = strtol(buf+1,&eptr,10);
38      return consumeNewline(eptr);
39  }
40  int readBytes(FILE *fp, char *target, PORT_LONG length) {
41      PORT_LONG real;
42      epos = ftello(fp);
43      real = (PORT_LONG)fread(target,1,length,fp);
44      if (real != length) {
45          ERROR("Expected to read %Id bytes, got %Id bytes",length,real);                        WIN_PORT_FIX &bsol;* %ld -> %Id */
46          return 0;
47      }
48      return 1;
49  }
50  int readString(FILE *fp, char** target) {
51      PORT_LONG len;
52      *target = NULL;
53      if (!readLong(fp,'$',&len)) {
54          return 0;
55      }
56      len += 2;
57      *target = (char*)zmalloc(len);
58      if (!readBytes(fp,*target,len)) {
59          return 0;
60      }
61      if (!consumeNewline(*target+len-2)) {
62          return 0;
63      }
64      (*target)[len-2] = '\0';
65      return 1;
66  }
67  int readArgc(FILE *fp, PORT_LONG *target) {
68      return readLong(fp,'*',target);
69  }
70  off_t process(FILE *fp) {
71      PORT_LONG argc;
72      off_t pos = 0;
73      int i, multi = 0;
74      char *str;
75      while(1) {
76          if (!multi) pos = ftello(fp);
77          if (!readArgc(fp, &argc)) break;
78          for (i = 0; i < argc; i++) {
79              if (!readString(fp,&str)) break;
80              if (i == 0) {
81                  if (strcasecmp(str, "multi") == 0) {
82                      if (multi++) {
83                          ERROR("Unexpected MULTI");
84                          break;
85                      }
86                  } else if (strcasecmp(str, "exec") == 0) {
87                      if (--multi) {
88                          ERROR("Unexpected EXEC");
89                          break;
90                      }
91                  }
92              }
93              zfree(str);
94          }
95          if (i < argc) {
96              if (str) zfree(str);
97              break;
98          }
99      }
100      if (feof(fp) && multi && strlen(error) == 0) {
101          ERROR("Reached EOF before reading EXEC for MULTI");
102      }
103      if (strlen(error) > 0) {
104          printf("%s\n", error);
105      }
106      return pos;
107  }
<span onclick='openModal()' class='match'>108  int redis_check_aof_main(int argc, char **argv) {
109      char *filename;
110      int fix = 0;
111  #ifdef _WIN32
112      _fmode = _O_BINARY;
</span>113      setmode(_fileno(stdin), _O_BINARY);
114      setmode(_fileno(stdout), _O_BINARY);
115      setmode(_fileno(stderr), _O_BINARY);
116  #endif
117      if (argc < 2) {
118          printf("Usage: %s [--fix] <file.aof>\n", argv[0]);
119          exit(1);
120      } else if (argc == 2) {
121          filename = argv[1];
122      } else if (argc == 3) {
123          if (strcmp(argv[1],"--fix") != 0) {
124              printf("Invalid argument: %s\n", argv[1]);
125              exit(1);
126          }
127          filename = argv[2];
128          fix = 1;
129      } else {
130          printf("Invalid arguments\n");
131          exit(1);
132      }
133      FILE *fp = fopen(filename, IF_WIN32("r+b", "r+"));
134      if (fp == NULL) {
135          printf("Cannot open file: %s\n", filename);
136          exit(1);
137      }
138      struct redis_stat sb;
139      if (redis_fstat(fileno(fp),&sb) == -1) {
140          printf("Cannot stat file: %s\n", filename);
141          exit(1);
142      }
143      off_t size = sb.st_size;
144      if (size == 0) {
145          printf("Empty file: %s\n", filename);
146          exit(1);
147      }
148      if (size >= 8) {    &bsol;* There must be at least room for the RDB header. */
149          char sig[5];
150          int has_preamble = fread(sig,sizeof(sig),1,fp) == 1 &&
151                              memcmp(sig,"REDIS",sizeof(sig)) == 0;
152          rewind(fp);
153          if (has_preamble) {
154              printf("The AOF appears to start with an RDB preamble.\n"
155                     "Checking the RDB preamble to start:\n");
156              if (redis_check_rdb_main(argc,argv,fp) == C_ERR) {
157                  printf("RDB preamble of AOF file is not sane, aborting.\n");
158                  exit(1);
159              } else {
160                  printf("RDB preamble is OK, proceeding with AOF tail...\n");
161              }
162          }
163      }
164      off_t pos = process(fp);
165      off_t diff = size-pos;
166      printf("AOF analyzed: size=%lld, ok_up_to=%lld, diff=%lld\n",
167          (PORT_LONGLONG) size, (PORT_LONGLONG) pos, (PORT_LONGLONG) diff);
168      if (diff > 0) {
169          if (fix) {
170              char buf[2];
171              printf("This will shrink the AOF from %lld bytes, with %lld bytes, to %lld bytes\n", (PORT_LONGLONG)size, (PORT_LONGLONG)diff, (PORT_LONGLONG)pos);
172              printf("Continue? [y/N]: ");
173              if (fgets(buf,sizeof(buf),stdin) == NULL ||
174                  strncasecmp(buf,"y",1) != 0) {
175                      printf("Aborting...\n");
176                      exit(1);
177              }
178              if (ftruncate(fileno(fp), pos) == -1) {
179                  printf("Failed to truncate AOF\n");
180                  exit(1);
181              } else {
182                  printf("Successfully truncated AOF\n");
183              }
184          } else {
185              printf("AOF is not valid. "
186                     "Use the --fix option to try fixing it.\n");
187              exit(1);
188          }
189      } else {
190          printf("AOF is valid\n");
191      }
192      fclose(fp);
193      exit(0);
194  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_QFork_impl.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-redis-check-aof.c</div>
                <div class="column column_space"><pre><code>24  int do_aofSave(char* filename, int aof_pipe_read_ack, int aof_pipe_read_data, int aof_pipe_write_ack)
25  {
26  #ifndef NO_QFORKIMPL
27      int rewriteAppendOnlyFile(char *filename);
28      server.aof_child_pid = GetCurrentProcessId();
29      server.aof_pipe_write_ack_to_parent = aof_pipe_write_ack;
</pre></code></div>
                <div class="column column_space"><pre><code>108  int redis_check_aof_main(int argc, char **argv) {
109      char *filename;
110      int fix = 0;
111  #ifdef _WIN32
112      _fmode = _O_BINARY;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    