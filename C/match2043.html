<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-fixline-buffer.c &amp; inf-gtk-permissions-dialog.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-fixline-buffer.c &amp; inf-gtk-permissions-dialog.c
      </h3>
<h1 align="center">
        4.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-fixline-buffer.c (6.439854%)<th>inf-gtk-permissions-dialog.c (4.039634%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1018-1042)<td><a href="#" name="0">(2781-2804)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(956-982)<td><a href="#" name="1">(2747-2770)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(44-77)<td><a href="#" name="2">(59-119)</a><td align="center"><font color="#ec0000">13</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1718-1773)<td><a href="#" name="3">(2808-2949)</a><td align="center"><font color="#da0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-fixline-buffer.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftext/inf-text-fixline-buffer.h&gt;
2 #include &lt;libinftext/inf-text-user.h&gt;
3 #include &lt;libinftext/inf-text-move-operation.h&gt;
4 #include &lt;libinfinity/common/inf-buffer.h&gt;
5 #include &lt;libinfinity/inf-signals.h&gt;
6 <a name="2"></a>
7 #include &lt;string.h&gt;
8 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>struct _InfTextBufferIter {
9   InfTextBufferIter* base_iter;
10   guint keep_begin;
11   guint keep_end;
12 };
13 typedef struct _InfTextFixlineBufferPrivate InfTextFixlineBufferPrivate;
14 struct _InfTextFixlineBufferPrivate {
15   InfIo* io;
16   InfTextBuffer* buffer;
17   guint lines;
18   guint* keep;
19   gint n_keep;
20   InfIoDispatch* dispatch;
21 };
22 enum {
23   PROP_0,
24   PROP_MODIFIED,
25   PROP_IO,
26   PROP_BUFFER,
27   PROP_LINES
28 };
29 #define INF_TEXT_FIXLINE_BUFFER_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_TYPE_FIXLINE_BUFFER, InfTextFixlineBufferPrivate))
30 static void inf_text_fixline_buffer_buffer_iface_init(InfBufferInterface* iface);</b></font>
31 static void inf_text_fixline_buffer_text_buffer_iface_init(InfTextBufferInterface* iface);
32 G_DEFINE_TYPE_WITH_CODE(InfTextFixlineBuffer, inf_text_fixline_buffer, G_TYPE_OBJECT,
33   G_ADD_PRIVATE(InfTextFixlineBuffer)
34   G_IMPLEMENT_INTERFACE(INF_TYPE_BUFFER, inf_text_fixline_buffer_buffer_iface_init)
35   G_IMPLEMENT_INTERFACE(INF_TEXT_TYPE_BUFFER, inf_text_fixline_buffer_text_buffer_iface_init))
36 static gboolean
37 inf_text_fixline_buffer_chunk_only_newlines(InfTextChunk* chunk)
38 {
39   const gchar* text;
40   gsize bytes;
41   const gchar* end;
42   gunichar c;
43   g_assert(strcmp(inf_text_chunk_get_encoding(chunk), "UTF-8") == 0);
44   text = inf_text_chunk_get_text(chunk, &amp;bytes);
45   end = text + bytes;
46   while(text != end)
47   {
48     c = g_utf8_get_char(text);
49     if(c != '\n') return FALSE;
50     text = g_utf8_next_char(text);
51   }
52   return TRUE;
53 }
54 static void
55 inf_text_fixline_buffer_newlines_to_chunk(InfTextChunk* chunk,
56                                           guint chunk_pos,
57                                           guint len,
58                                           guint user_id)
59 {
60   gchar stext[16];
61   gchar* text;
62   guint i;
63   if(len &gt; sizeof(stext))
64     text = g_malloc(len * sizeof(gchar));
65   else
66     text = stext;
67   for(i = 0; i &lt; len; ++i)
68     text[i] = '\n';
69   g_assert(strcmp(inf_text_chunk_get_encoding(chunk), "UTF-8") == 0);
70   inf_text_chunk_insert_text(chunk, chunk_pos, text, len, len, user_id);
71   if(text != stext)
72     g_free(text);
73 }
74 static guint
75 inf_text_fixline_buffer_buffer_count_trailing_newlines(InfTextBuffer* buffer,
76                                                        guint min_check)
77 {
78   InfTextBufferIter* iter;
79   guint cur_pos;
80   gchar* text;
81   gchar* text_pos;
82   gunichar c;
83   g_assert(strcmp(inf_text_buffer_get_encoding(buffer), "UTF-8") == 0);
84   iter = inf_text_buffer_create_end_iter(buffer);
85   if(iter == NULL) return 0;
86   cur_pos = inf_text_buffer_get_length(buffer);
87   text = inf_text_buffer_iter_get_text(buffer, iter);
88   text_pos = text + inf_text_buffer_iter_get_bytes(buffer, iter);
89   for(cur_pos = inf_text_buffer_get_length(buffer);
90       cur_pos &gt; min_check;
91       --cur_pos)
92   {
93     if(text_pos == text)
94     {
95       g_free(text);
96       inf_text_buffer_iter_prev(buffer, iter);
97       text = inf_text_buffer_iter_get_text(buffer, iter);
98       text_pos = text + inf_text_buffer_iter_get_bytes(buffer, iter);
99     }
100     g_assert(text_pos &gt; text);
101     text_pos = g_utf8_prev_char(text_pos);
102     c = g_utf8_get_char(text_pos);
103     if(c != '\n') break;
104   }
105   g_free(text);
106   inf_text_buffer_destroy_iter(buffer, iter);
107   return inf_text_buffer_get_length(buffer) - cur_pos;
108 }
109 static gboolean
110 inf_text_fixline_buffer_buffer_only_newlines_after(InfTextBuffer* buffer,
111                                                    guint pos)
112 {
113   guint new_lines;
114   new_lines = inf_text_fixline_buffer_buffer_count_trailing_newlines(
115     buffer,
116     pos
117   );
118   if(inf_text_buffer_get_length(buffer) - new_lines &lt;= pos) return TRUE;
119   return FALSE;
120 }
121 static guint
122 inf_text_fixline_buffer_keep_next(const guint* keep,
123                                   guint n_keep,
124                                   guint pos)
125 {
126   guint new_author;
127   g_assert(pos &lt; n_keep);
128   new_author = keep[pos++];
129   while(pos &lt; n_keep &amp;&amp; keep[pos] == new_author)
130     ++pos;
131   return pos;
132 }
133 static guint
134 inf_text_fixline_buffer_keep_prev(const guint* keep,
135                                   guint n_keep,
136                                   guint pos)
137 {
138   guint new_author;
139   g_assert(pos &gt; 0);
140   new_author = keep[--pos];
141   while(pos &gt; 0 &amp;&amp; keep[pos-1] == new_author)
142     --pos;
143   return pos;
144 }
145 static void
146 inf_text_fixline_buffer_chunk_to_keep(InfTextFixlineBuffer* fixline_buffer,
147                                       InfTextChunk* chunk,
148                                       guint chunk_pos,
149                                       guint keep_pos,
150                                       guint len)
151 {
152   InfTextFixlineBufferPrivate* priv;
153   InfTextChunkIter iter;
154   gboolean result;
155   guint offset;
156   guint i;
157   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
158   g_assert(priv-&gt;n_keep &gt; 0);
159   g_assert(keep_pos + len &lt;= (guint)priv-&gt;n_keep);
160   g_assert(chunk_pos + len &lt;= inf_text_chunk_get_length(chunk));
161   g_assert(chunk_pos == 0); 
162   offset = 0;
163   result = inf_text_chunk_iter_init_begin(chunk, &amp;iter);
164   g_assert(result == TRUE || len == 0);
165   for(i = 0; i &lt; len; ++i)
166   {
167     g_assert(i - offset &lt;= inf_text_chunk_iter_get_length(&amp;iter));
168     if(i - offset == inf_text_chunk_iter_get_length(&amp;iter))
169     {
170       offset = i;
171       result = inf_text_chunk_iter_next(&amp;iter);
172       g_assert(result == TRUE);
173     }
174     g_assert(inf_text_chunk_iter_get_length(&amp;iter) &gt; 0);
175     priv-&gt;keep[keep_pos + i] = inf_text_chunk_iter_get_author(&amp;iter);
176   }
177 }
178 static void
179 inf_text_fixline_buffer_keep_to_chunk(InfTextFixlineBuffer* fixline_buffer,
180                                       InfTextChunk* chunk,
181                                       guint chunk_pos,
182                                       guint keep_pos,
183                                       guint len)
184 {
185   InfTextFixlineBufferPrivate* priv;
186   guint i;
187   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
188   g_assert(priv-&gt;n_keep &gt; 0);
189   g_assert(keep_pos + len &lt;= (guint)priv-&gt;n_keep);
190   g_assert(chunk_pos &lt;= inf_text_chunk_get_length(chunk));
191   g_assert(strcmp(inf_text_chunk_get_encoding(chunk), "UTF-8") == 0);
192   for(i = 0; i &lt; len; ++i)
193   {
194     inf_text_chunk_insert_text(
195       chunk,
196       chunk_pos + i,
197       "\n",
198       1,
199       1,
200       priv-&gt;keep[keep_pos + i]
201     );
202   }
203 }
204 static void
205 inf_text_fixline_buffer_text_inserted_cb(InfTextBuffer* buffer,
206                                          guint pos,
207                                          InfTextChunk* chunk,
208                                          InfUser* user,
209                                          gpointer user_data);
210 static void
211 inf_text_fixline_buffer_text_erased_cb(InfTextBuffer* buffer,
212                                        guint pos,
213                                        InfTextChunk* chunk,
214                                        InfUser* user,
215                                        gpointer user_data);
216 static void
217 inf_text_fixline_buffer_keep_to_base(InfTextFixlineBuffer* fixline_buffer,
218                                      guint len)
219 {
220   InfTextFixlineBufferPrivate* priv;
221   InfTextChunk* chunk;
222   guint keep_len;
223   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
224   chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(priv-&gt;buffer));
225   if(priv-&gt;n_keep &gt; 0)
226   {
227     keep_len = MIN( (guint)priv-&gt;n_keep, len);
228     inf_text_fixline_buffer_keep_to_chunk(
229       fixline_buffer,
230       chunk,
231       0,
232       0,
233       keep_len
234     );
235     if(keep_len &lt; priv-&gt;n_keep)
236     {
237       g_memmove(
238         priv-&gt;keep,
239         priv-&gt;keep + keep_len,
240         (priv-&gt;n_keep - keep_len) * sizeof(guint)
241       );
242       priv-&gt;keep = g_realloc(
243         priv-&gt;keep,
244         (priv-&gt;n_keep - keep_len) * sizeof(guint)
245       );
246     }
247     else
248     {
249       g_free(priv-&gt;keep);
250       priv-&gt;keep = NULL;
251     }
252     priv-&gt;n_keep -= keep_len;
253     len -= keep_len;
254   }
255   if(len &gt; 0)
256   {
257     g_assert(priv-&gt;n_keep &lt;= 0);
258     inf_text_fixline_buffer_newlines_to_chunk(
259       chunk,
260       inf_text_chunk_get_length(chunk),
261       len,
262       0
263     );
264     priv-&gt;n_keep -= (gint)len;
265   }
266   inf_signal_handlers_block_by_func(
267     priv-&gt;buffer,
268     G_CALLBACK(inf_text_fixline_buffer_text_inserted_cb),
269     fixline_buffer
270   );
271   inf_text_buffer_insert_chunk(
272     priv-&gt;buffer,
273     inf_text_buffer_get_length(priv-&gt;buffer),
274     chunk,
275     NULL
276   );
277   inf_signal_handlers_unblock_by_func(
278     priv-&gt;buffer,
279     G_CALLBACK(inf_text_fixline_buffer_text_inserted_cb),
280     fixline_buffer
281   );
282   inf_text_chunk_free(chunk);
283 }
284 static void
285 inf_text_fixline_buffer_base_to_keep(InfTextFixlineBuffer* fixline_buffer,
286                                      guint len)
287 {
288   InfTextFixlineBufferPrivate* priv;
289   guint use_keep;
290   guint remaining_len;
291   InfTextBufferIter* iter;
292   guint iter_offset;
293   guint iter_pos;
294   gboolean iter_result;
295   guint keep_len;
296   guint keep_index;
297   guint keep_author;
298   guint i;
299   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
300   g_assert(inf_text_buffer_get_length(priv-&gt;buffer) &gt;= len);
301   if(priv-&gt;n_keep &lt; 0)
302   {
303     use_keep = MIN( (guint)(-priv-&gt;n_keep), len);
304     priv-&gt;n_keep = -(gint)((guint)(-priv-&gt;n_keep) - use_keep);
305     remaining_len = len - use_keep;
306   }
307   else
308   {
309     remaining_len = len;
310   }
311   if(remaining_len &gt; 0)
312   {
313     g_assert(priv-&gt;n_keep &gt;= 0);
314     iter = inf_text_buffer_create_end_iter(priv-&gt;buffer);
315     g_assert(iter != NULL);
316     iter_pos = 0;
317     iter_offset = inf_text_buffer_iter_get_length(priv-&gt;buffer, iter);
318     while(iter_pos &lt; len - remaining_len)
319     {
320       if(iter_offset &lt;= len - remaining_len)
321       {
322         iter_pos = iter_offset;
323         iter_result = inf_text_buffer_iter_prev(priv-&gt;buffer, iter);
324         g_assert(iter_result == TRUE);
325         iter_offset += inf_text_buffer_iter_get_length(priv-&gt;buffer, iter);
326       }
327       else
328       {
329         iter_pos = (len - remaining_len);
330       }
331     }
332     priv-&gt;keep = g_realloc(
333       priv-&gt;keep,
334       (priv-&gt;n_keep + remaining_len) * sizeof(guint)
335     );
336     g_memmove(
337       priv-&gt;keep + remaining_len,
338       priv-&gt;keep,
339       priv-&gt;n_keep * sizeof(guint)
340     );
341     while(iter_pos &lt; len)
342     {
343       keep_author = inf_text_buffer_iter_get_author(priv-&gt;buffer, iter);
344       keep_index = len - iter_pos;
345       if(iter_offset &lt;= len)
346       {
347         keep_len = iter_offset - iter_pos;
348         iter_pos = iter_offset;
349         iter_result = inf_text_buffer_iter_prev(priv-&gt;buffer, iter);
350         g_assert(iter_result == TRUE);
351         iter_offset += inf_text_buffer_iter_get_length(priv-&gt;buffer, iter);
352       }
353       else
354       {
355         keep_len = len - iter_pos;
356         iter_pos = len;
357       }
358       for(i = 0; i &lt; keep_len; ++i)
359         priv-&gt;keep[keep_index - 1 - i] = keep_author;
360     }
361     inf_text_buffer_destroy_iter(priv-&gt;buffer, iter);
362     priv-&gt;n_keep += remaining_len;
363   }
364   inf_signal_handlers_block_by_func(
365     priv-&gt;buffer,
366     G_CALLBACK(inf_text_fixline_buffer_text_erased_cb),
367     fixline_buffer
368   );
369   inf_text_buffer_erase_text(
370     priv-&gt;buffer,
371     inf_text_buffer_get_length(priv-&gt;buffer) - len,
372     len,
373     NULL
374   );
375   inf_signal_handlers_unblock_by_func(
376     priv-&gt;buffer,
377     G_CALLBACK(inf_text_fixline_buffer_text_erased_cb),
378     fixline_buffer
379   );
380 }
381 static void
382 inf_text_fixline_buffer_fix_lines(InfTextFixlineBuffer* fixline_buffer)
383 {
384   InfTextFixlineBufferPrivate* priv;
385   guint count;
386   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
387   count = inf_text_fixline_buffer_buffer_count_trailing_newlines(
388     priv-&gt;buffer,
389     0
390   );
391   if(count &lt; priv-&gt;lines)
392   {
393     inf_text_fixline_buffer_keep_to_base(fixline_buffer, priv-&gt;lines - count);
394   }
395   else if(count &gt; priv-&gt;lines)
396   {
397     inf_text_fixline_buffer_base_to_keep(fixline_buffer, count - priv-&gt;lines);
398   }
399 }
400 static void
401 inf_text_fixline_buffer_dispatch_func(gpointer user_data)
402 {
403   InfTextFixlineBuffer* fixline_buffer;
404   InfTextFixlineBufferPrivate* priv;
405   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(user_data);
406   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
407   g_assert(priv-&gt;dispatch != NULL);
408   priv-&gt;dispatch = NULL;
409   inf_text_fixline_buffer_fix_lines(fixline_buffer);
410 }
411 static void
412 inf_text_fixline_buffer_text_inserted_cb(InfTextBuffer* buffer,
413                                          guint pos,
414                                          InfTextChunk* chunk,
415                                          InfUser* user,
416                                          gpointer user_data)
417 {
418   InfTextFixlineBufferPrivate* priv;
419   guint chunk_length;
420   guint buffer_length;
421   guint end;
422   guint user_pos;
423   gint user_len;
424   InfTextChunk* new_chunk;
425   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(user_data);
426   chunk_length = inf_text_chunk_get_length(chunk);
427   g_assert(inf_text_buffer_get_length(buffer) &gt;= chunk_length);
428   buffer_length = inf_text_buffer_get_length(buffer) - chunk_length;
429   g_assert(priv-&gt;n_keep &gt; 0 || buffer_length &gt;= (guint)(-priv-&gt;n_keep));
430   end = buffer_length + priv-&gt;n_keep;
431   if(inf_text_fixline_buffer_chunk_only_newlines(chunk) &amp;&amp;
432      inf_text_fixline_buffer_buffer_only_newlines_after(buffer, pos + chunk_length))
433   {
434 #if 0
435     for(i = 0; i &lt; inf_text_buffer_get_length(buffer) - inf_text_chunk_get_length(chunk) - pos; ++i)
436       author(i + pos) = author(i + pos + inf_text_chunk_get_length(chunk))
437     if(priv-&gt;n_keep &gt; 0)
438       for(i = 0; i &lt; priv-&gt;n_keep &amp;&amp; i &lt; inf_text_chunk_get_length(chunk); ++i)
439         author(i + pos + inf_text_chunk_get_length(chunk)) = priv-&gt;keep[i];
440 #endif
441     if(priv-&gt;n_keep &gt; 0 &amp;&amp; inf_text_chunk_get_length(chunk) &gt; (guint)priv-&gt;n_keep)
442       priv-&gt;n_keep = -(int)(inf_text_chunk_get_length(chunk) - priv-&gt;n_keep);
443     else
444       priv-&gt;n_keep = priv-&gt;n_keep - inf_text_chunk_get_length(chunk);
445     if(priv-&gt;n_keep &gt; 0)
446     {
447       g_memmove(
448         priv-&gt;keep,
449         priv-&gt;keep + inf_text_chunk_get_length(chunk),
450         priv-&gt;n_keep * sizeof(guint)
451       );
452       priv-&gt;keep = g_realloc(priv-&gt;keep, priv-&gt;n_keep * sizeof(guint));
453     }
454     else
455     {
456       g_free(priv-&gt;keep);
457       priv-&gt;keep = NULL;
458     }
459     user_pos = inf_text_user_get_caret_position(INF_TEXT_USER(user));
460     user_len = inf_text_user_get_selection_length(INF_TEXT_USER(user));
461     inf_text_move_operation_transform_insert(
462       pos,
463       chunk_length,
464       &amp;user_pos,
465       &amp;user_len,
466       FALSE
467     );
468     inf_text_user_set_selection(
469       INF_TEXT_USER(user),
470       user_pos,
471       user_len,
472       TRUE
473     );
474   }
475   else
476   {
477     if(pos &gt; end)
478     {
479       g_assert(priv-&gt;n_keep &lt; 0);
480       g_assert((guint)(-priv-&gt;n_keep) &gt;= pos - end);
481       priv-&gt;n_keep += (pos - end);
482       new_chunk = inf_text_chunk_copy(chunk);
483       inf_text_fixline_buffer_newlines_to_chunk(
484         new_chunk,
485         0,
486         pos - end,
487         user == NULL ? 0 : inf_user_get_id(user)
488       );
489       inf_text_buffer_text_inserted(
490         INF_TEXT_BUFFER(user_data),
491         end,
492         new_chunk,
493         user
494       );
495       inf_text_chunk_free(new_chunk);
496     }
497     else
498     {
499       inf_text_buffer_text_inserted(
500         INF_TEXT_BUFFER(user_data),
501         pos,
502         chunk,
503         user
504       );
505     }
506   }
507   if(priv-&gt;dispatch == NULL)
508   {
509     priv-&gt;dispatch = inf_io_add_dispatch(
510       priv-&gt;io,
511       inf_text_fixline_buffer_dispatch_func,
512       user_data,
513       NULL
514     );
515   }
516 }
517 static void
518 inf_text_fixline_buffer_text_erased_cb(InfTextBuffer* buffer,
519                                        guint pos,
520                                        InfTextChunk* chunk,
521                                        InfUser* user,
522                                        gpointer user_data)
523 {
524   InfTextFixlineBufferPrivate* priv;
525   guint chunk_length;
526   guint buffer_length;
527   guint end;
528   guint use_keep;
529   InfTextChunk* new_chunk;
530   guint user_pos;
531   gint user_len;
532   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(user_data);
533   chunk_length = inf_text_chunk_get_length(chunk);
534   buffer_length = inf_text_buffer_get_length(buffer) + chunk_length;
535   g_assert(priv-&gt;n_keep &gt; 0 || buffer_length &gt;= (guint)(-priv-&gt;n_keep));
536   end = buffer_length + priv-&gt;n_keep;
537   if(inf_text_fixline_buffer_chunk_only_newlines(chunk) &amp;&amp;
538      inf_text_fixline_buffer_buffer_only_newlines_after(buffer, pos))
539   {
540 #if 0
541     for(i = pos; i &lt; inf_text_buffer_get_length(buffer); ++i)
542       rebrand(i);
543 #endif
544     if(priv-&gt;n_keep &gt; 0)
545       use_keep = inf_text_chunk_get_length(chunk);
546     else if((guint)(-priv-&gt;n_keep) &lt; inf_text_chunk_get_length(chunk))
547       use_keep = inf_text_chunk_get_length(chunk) - (guint)(-priv-&gt;n_keep);
548     else
549       use_keep = 0;
550     priv-&gt;n_keep += inf_text_chunk_get_length(chunk);
551     if(priv-&gt;n_keep &gt; 0)
552     {
553       g_assert(
554         priv-&gt;keep == NULL ||
555         (guint)priv-&gt;n_keep &gt; inf_text_chunk_get_length(chunk)
556       );
557       priv-&gt;keep = g_realloc(priv-&gt;keep, priv-&gt;n_keep * sizeof(guint));
558       if((guint)priv-&gt;n_keep &gt; inf_text_chunk_get_length(chunk))
559       {
560         g_memmove(
561           priv-&gt;keep + inf_text_chunk_get_length(chunk),
562           priv-&gt;keep,
563           (priv-&gt;n_keep - inf_text_chunk_get_length(chunk)) * sizeof(guint)
564         );
565       }
566       inf_text_fixline_buffer_chunk_to_keep(
567         INF_TEXT_FIXLINE_BUFFER(user_data),
568         chunk,
569         0,
570         0,
571         use_keep
572       );
573     }
574     user_pos = inf_text_user_get_caret_position(INF_TEXT_USER(user));
575     user_len = inf_text_user_get_selection_length(INF_TEXT_USER(user));
576     inf_text_move_operation_transform_delete(
577       pos,
578       chunk_length,
579       &amp;user_pos,
580       &amp;user_len
581     );
582     inf_text_user_set_selection(
583       INF_TEXT_USER(user),
584       user_pos,
585       user_len,
586       TRUE
587     );
588   }
589   else
590   {
591     if(pos &gt; end)
592     {
593       g_assert(priv-&gt;n_keep &lt; 0);
594       g_assert_not_reached();
595     }
596     else if(pos + chunk_length &gt; end)
597     {
598       g_assert(priv-&gt;n_keep &lt; 0);
599       g_assert(chunk_length - (end - pos) &lt;= (guint)(-priv-&gt;n_keep));
600       priv-&gt;n_keep += (chunk_length - (end - pos));
601       new_chunk = inf_text_chunk_copy(chunk);
602       inf_text_chunk_erase(new_chunk, end - pos, chunk_length - (end - pos));
603       inf_text_buffer_text_erased(
604         INF_TEXT_BUFFER(user_data),
605         pos,
606         new_chunk,
607         user
608       );
609       inf_text_chunk_free(new_chunk);
610     }
611     else
612     {
613       inf_text_buffer_text_erased(
614         INF_TEXT_BUFFER(user_data),
615         pos,
616         chunk,
617         user
618       );
619     }
620   }
621   g_assert(
622     priv-&gt;n_keep &gt; 0 ||
623     inf_text_buffer_get_length(buffer) &gt;= (guint)(-priv-&gt;n_keep)
624   );
625   if(priv-&gt;dispatch == NULL)
626   {
627     priv-&gt;dispatch = inf_io_add_dispatch(
628       priv-&gt;io,
629       inf_text_fixline_buffer_dispatch_func,
630       user_data,
631       NULL
632     );
633   }
634 }
635 static void
636 inf_text_fixline_buffer_init(InfTextFixlineBuffer* fixline_buffer)
637 {
638   InfTextFixlineBufferPrivate* priv;
639   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
640   priv-&gt;io = NULL;
641   priv-&gt;buffer = NULL;
642   priv-&gt;lines = 0;
643   priv-&gt;keep = NULL;
644   priv-&gt;n_keep = 0;
645   priv-&gt;dispatch = NULL;
646 }
647 static void
648 inf_text_fixline_buffer_constructed(GObject* object)
649 {
650   InfTextFixlineBuffer* fixline_buffer;
651   InfTextFixlineBufferPrivate* priv;
652   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(object);
653   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
654   inf_text_fixline_buffer_fix_lines(fixline_buffer);
655 }
656 static void
657 inf_text_fixline_buffer_dispose(GObject* object)
658 {
659   InfTextFixlineBuffer* fixline_buffer;
660   InfTextFixlineBufferPrivate* priv;
661   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(object);
662   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
663   if(priv-&gt;buffer != NULL)
664   {
665     inf_signal_handlers_disconnect_by_func(
666       G_OBJECT(priv-&gt;buffer),
667       G_CALLBACK(inf_text_fixline_buffer_text_inserted_cb),
668       fixline_buffer
669     );
670     inf_signal_handlers_disconnect_by_func(
671       G_OBJECT(priv-&gt;buffer),
672       G_CALLBACK(inf_text_fixline_buffer_text_erased_cb),
673       fixline_buffer
674     );
675     g_object_unref(priv-&gt;buffer);
676     priv-&gt;buffer = NULL;
677   }
678   if(priv-&gt;io != NULL)
679   {
680     if(priv-&gt;dispatch != NULL)
681     {
682       inf_io_remove_dispatch(priv-&gt;io, priv-&gt;dispatch);
683       priv-&gt;dispatch = NULL;
684     }
685     g_object_unref(priv-&gt;io);
686     priv-&gt;io = NULL;
687   }
688   G_OBJECT_CLASS(inf_text_fixline_buffer_parent_class)-&gt;dispose(object);
689 }
690 static void
691 inf_text_fixline_buffer_finalize(GObject* object)
692 {
693 <a name="1"></a>  InfTextFixlineBuffer* fixline_buffer;
694   InfTextFixlineBufferPrivate* priv;
695 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  fixline_buffer = INF_TEXT_FIXLINE_BUFFER(object);
696   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
697   g_free(priv-&gt;keep);
698   G_OBJECT_CLASS(inf_text_fixline_buffer_parent_class)-&gt;finalize(object);
699 }
700 static void
701 inf_text_fixline_buffer_set_property(GObject* object,
702                                      guint prop_id,
703                                      const GValue* value,
704                                      GParamSpec* pspec)
705 {
706   InfTextFixlineBuffer* fixline_buffer;
707   InfTextFixlineBufferPrivate* priv;
708   gboolean modified;
709   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(object);
710   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
711   switch(prop_id)
712   {
713   case PROP_IO:
714     g_assert(priv-&gt;io == NULL);
715     priv-&gt;io = INF_IO(g_value_dup_object(value));</b></font>
716     break;
717   case PROP_BUFFER:
718     g_assert(priv-&gt;buffer == NULL);
719     priv-&gt;buffer = INF_TEXT_BUFFER(g_value_dup_object(value));
720     g_signal_connect(
721       G_OBJECT(priv-&gt;buffer),
722       "text-inserted",
723       G_CALLBACK(inf_text_fixline_buffer_text_inserted_cb),
724       fixline_buffer
725     );
726     g_signal_connect(
727       G_OBJECT(priv-&gt;buffer),
728       "text-erased",
729       G_CALLBACK(inf_text_fixline_buffer_text_erased_cb),
730       fixline_buffer
731     );
732     break;
733   case PROP_LINES:
734     g_assert(priv-&gt;lines == 0);
735     priv-&gt;lines = g_value_get_uint(value);
736     break;
737   case PROP_MODIFIED:
738     inf_buffer_set_modified(
739       INF_BUFFER(priv-&gt;buffer),
740       g_value_get_boolean(value)
741     );
742 <a name="0"></a>    break;
743   fixline:
744     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
745 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
746   }
747 }
748 static void
749 inf_text_fixline_buffer_get_property(GObject* object,
750                                      guint prop_id,
751                                      GValue* value,
752                                      GParamSpec* pspec)
753 {
754   InfTextFixlineBuffer* fixline_buffer;
755   InfTextFixlineBufferPrivate* priv;
756   gboolean modified;
757   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(object);
758   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
759   switch(prop_id)
760   {
761   case PROP_IO:
762     g_value_set_object(value, priv-&gt;io);
763     break;
764   case PROP_BUFFER:
765     g_value_set_object(value, priv-&gt;buffer);
766     break;</b></font>
767   case PROP_LINES:
768     g_value_set_uint(value, priv-&gt;lines);
769     break;
770   case PROP_MODIFIED:
771     g_value_set_boolean(
772       value,
773       inf_buffer_get_modified(INF_BUFFER(priv-&gt;buffer))
774     );
775     break;
776   fixline:
777     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
778     break;
779   }
780 }
781 static gboolean
782 inf_text_fixline_buffer_buffer_get_modified(InfBuffer* buffer)
783 {
784   InfTextFixlineBuffer* fixline_buffer;
785   InfTextFixlineBufferPrivate* priv;
786   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
787   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
788   return inf_buffer_get_modified(INF_BUFFER(priv-&gt;buffer));
789 }
790 static void
791 inf_text_fixline_buffer_buffer_set_modified(InfBuffer* buffer,
792                                             gboolean modified)
793 {
794   InfTextFixlineBuffer* fixline_buffer;
795   InfTextFixlineBufferPrivate* priv;
796   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
797   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
798   inf_buffer_set_modified(INF_BUFFER(priv-&gt;buffer), modified);
799 }
800 static const gchar*
801 inf_text_fixline_buffer_buffer_get_encoding(InfTextBuffer* buffer)
802 {
803   InfTextFixlineBuffer* fixline_buffer;
804   InfTextFixlineBufferPrivate* priv;
805   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
806   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
807   return inf_text_buffer_get_encoding(priv-&gt;buffer);
808 }
809 static guint
810 inf_text_fixline_buffer_get_length(InfTextBuffer* buffer)
811 {
812   InfTextFixlineBuffer* fixline_buffer;
813   InfTextFixlineBufferPrivate* priv;
814   guint buf_len;
815   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
816   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
817   buf_len = inf_text_buffer_get_length(priv-&gt;buffer);
818   g_assert(priv-&gt;n_keep &gt; 0 || buf_len &gt;= (guint)(-priv-&gt;n_keep));
819   return buf_len + priv-&gt;n_keep;
820 }
821 static InfTextChunk*
822 inf_text_fixline_buffer_buffer_get_slice(InfTextBuffer* buffer,
823                                          guint pos,
824                                          guint len)
825 {
826   InfTextFixlineBuffer* fixline_buffer;
827   InfTextFixlineBufferPrivate* priv;
828   guint buf_len;
829   guint keep_begin;
830   InfTextChunk* chunk;
831   guint i;
832   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
833   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
834   buf_len = inf_text_buffer_get_length(priv-&gt;buffer);
835   if(pos + len &gt; buf_len)
836   {
837     g_assert(priv-&gt;n_keep &gt; 0);
838     if(pos &lt; buf_len)
839     {
840       chunk = inf_text_buffer_get_slice(priv-&gt;buffer, pos, buf_len - pos);
841       inf_text_fixline_buffer_keep_to_chunk(
842         fixline_buffer,
843         chunk,
844         inf_text_chunk_get_length(chunk),
845         0,
846         pos + len - buf_len
847       );
848     }
849     else
850     {
851       chunk = inf_text_chunk_new(inf_text_buffer_get_encoding(priv-&gt;buffer));
852       inf_text_fixline_buffer_keep_to_chunk(
853         fixline_buffer,
854         chunk,
855         0,
856         pos - buf_len,
857         len
858       );
859     }
860   }
861   else
862   {
863     chunk = inf_text_buffer_get_slice(priv-&gt;buffer, pos, len);
864   }
865   return chunk;
866 }
867 static void
868 inf_text_fixline_buffer_buffer_insert_text(InfTextBuffer* buffer,
869                                            guint pos,
870                                            InfTextChunk* chunk,
871                                            InfUser* user)
872 {
873   InfTextFixlineBuffer* fixline_buffer;
874   InfTextFixlineBufferPrivate* priv;
875   guint buf_len;
876   InfTextChunk* new_chunk;
877   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
878   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
879   buf_len = inf_text_buffer_get_length(priv-&gt;buffer);
880   inf_signal_handlers_block_by_func(
881     priv-&gt;buffer,
882     G_CALLBACK(inf_text_fixline_buffer_text_inserted_cb),
883     fixline_buffer
884   );
885   if(pos &gt;= buf_len &amp;&amp; inf_text_fixline_buffer_chunk_only_newlines(chunk))
886   {
887     g_assert(priv-&gt;n_keep &gt;= 0);
888     g_assert(pos - buf_len &lt;= (guint)priv-&gt;n_keep);
889     priv-&gt;keep = g_realloc(
890       priv-&gt;keep,
891       (priv-&gt;n_keep + inf_text_chunk_get_length(chunk)) * sizeof(guint)
892     );
893     if(pos - buf_len &lt; priv-&gt;n_keep)
894     {
895       g_memmove(
896         priv-&gt;keep + (pos - buf_len + inf_text_chunk_get_length(chunk)),
897         priv-&gt;keep + (pos - buf_len),
898         priv-&gt;n_keep - (pos - buf_len)
899       );
900     }
901     priv-&gt;n_keep += inf_text_chunk_get_length(chunk);
902     inf_text_fixline_buffer_chunk_to_keep(
903       fixline_buffer,
904       chunk,
905       0,
906       pos - buf_len,
907       inf_text_chunk_get_length(chunk)
908     );
909   }
910   else if(pos &gt; buf_len)
911   {
912     g_assert(priv-&gt;n_keep &gt; 0);
913     g_assert((guint)priv-&gt;n_keep &gt;= pos - buf_len);
914     new_chunk = inf_text_chunk_copy(chunk);
915     inf_text_fixline_buffer_keep_to_chunk(
916       fixline_buffer,
917       new_chunk,
918       0,
919       0,
920       pos - buf_len
921     );
922     g_memmove(
923       priv-&gt;keep,
924       priv-&gt;keep + (pos - buf_len),
925       ((guint)priv-&gt;n_keep - (pos - buf_len)) * sizeof(guint)
926     );
927     priv-&gt;keep = g_realloc(
928       priv-&gt;keep,
929       ((guint)priv-&gt;n_keep - (pos - buf_len)) * sizeof(guint)
930     );
931     priv-&gt;n_keep -= (pos - buf_len);
932     inf_text_buffer_insert_chunk(priv-&gt;buffer, buf_len, new_chunk, user);
933     inf_text_chunk_free(new_chunk);
934   }
935   else
936   {
937     inf_text_buffer_insert_chunk(priv-&gt;buffer, pos, chunk, user);
938   }
939   inf_signal_handlers_unblock_by_func(
940     priv-&gt;buffer,
941     G_CALLBACK(inf_text_fixline_buffer_text_inserted_cb),
942     fixline_buffer
943   );
944   inf_text_buffer_text_inserted(buffer, pos, chunk, user);
945   inf_text_fixline_buffer_fix_lines(fixline_buffer);
946 }
947 static void
948 inf_text_fixline_buffer_buffer_erase_text(InfTextBuffer* buffer,
949                                           guint pos,
950                                           guint len,
951                                           InfUser* user)
952 {
953   InfTextFixlineBuffer* fixline_buffer;
954   InfTextFixlineBufferPrivate* priv;
955   InfTextChunk* erased_content;
956   guint buf_len;
957   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
958   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
959   buf_len = inf_text_buffer_get_length(priv-&gt;buffer);
960   inf_signal_handlers_block_by_func(
961     priv-&gt;buffer,
962     G_CALLBACK(inf_text_fixline_buffer_text_erased_cb),
963     fixline_buffer
964   );
965   erased_content = inf_text_buffer_get_slice(buffer, pos, len);
966   if(pos + len &gt; buf_len)
967   {
968     if(pos &gt; buf_len)
969     {
970       g_assert(priv-&gt;n_keep &gt; 0);
971       g_assert((guint)priv-&gt;n_keep &gt;= len);
972       g_assert(pos + len - buf_len &lt;= (guint)priv-&gt;n_keep);
973       if(pos + len - buf_len &lt; (guint)priv-&gt;n_keep)
974       {
975         g_memmove(
976           priv-&gt;keep + (pos - buf_len),
977           priv-&gt;keep + (pos + len - buf_len),
978           (priv-&gt;n_keep - (pos + len - buf_len)) * sizeof(guint)
979         );
980       }
981       priv-&gt;keep = g_realloc(
982         priv-&gt;keep,
983         (priv-&gt;n_keep - len) * sizeof(guint)
984       );
985       priv-&gt;n_keep -= len;
986     }
987     else
988     {
989       g_assert(priv-&gt;n_keep &gt; 0);
990       g_assert(pos + len - buf_len &lt;= (guint)priv-&gt;n_keep);
991       if(pos + len - buf_len &lt; (guint)priv-&gt;n_keep)
992       {
993         g_memmove(
994           priv-&gt;keep,
995           priv-&gt;keep + (pos + len - buf_len),
996           (priv-&gt;n_keep - (pos + len - buf_len)) * sizeof(guint)
997         );
998       }
999       priv-&gt;keep = g_realloc(
1000         priv-&gt;keep,
1001         (priv-&gt;n_keep - (pos + len - buf_len)) * sizeof(guint)
1002       );
1003       priv-&gt;n_keep -= (pos + len - buf_len);
1004       inf_text_buffer_erase_text(priv-&gt;buffer, pos, buf_len - pos, user);
1005     }
1006   }
1007   else
1008   {
1009     inf_text_buffer_erase_text(priv-&gt;buffer, pos, len, user);
1010   }
1011   inf_signal_handlers_unblock_by_func(
1012     priv-&gt;buffer,
1013     G_CALLBACK(inf_text_fixline_buffer_text_erased_cb),
1014     fixline_buffer
1015   );
1016   inf_text_buffer_text_erased(buffer, pos, erased_content, user);
1017   inf_text_chunk_free(erased_content);
1018   inf_text_fixline_buffer_fix_lines(fixline_buffer);
1019 }
1020 static InfTextBufferIter*
1021 inf_text_fixline_buffer_buffer_create_begin_iter(InfTextBuffer* buffer)
1022 {
1023   InfTextFixlineBuffer* fixline_buffer;
1024   InfTextFixlineBufferPrivate* priv;
1025   InfTextBufferIter* base_iter;
1026   InfTextBufferIter* iter;
1027   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1028   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1029   if(priv-&gt;n_keep &lt;= 0 &amp;&amp;
1030      inf_text_buffer_get_length(priv-&gt;buffer) == (guint)(-priv-&gt;n_keep))
1031   {
1032     return NULL;
1033   }
1034   base_iter = inf_text_buffer_create_begin_iter(priv-&gt;buffer);
1035   if(base_iter == NULL)
1036   {
1037     g_assert(priv-&gt;n_keep &gt; 0);
1038     iter = g_slice_new(InfTextBufferIter);
1039     iter-&gt;base_iter = NULL;
1040     iter-&gt;keep_begin = 0;
1041     iter-&gt;keep_end = inf_text_fixline_buffer_keep_next(
1042       priv-&gt;keep,
1043       priv-&gt;n_keep,
1044       0
1045     );
1046   }
1047   else
1048   {
1049     iter = g_slice_new(InfTextBufferIter);
1050     iter-&gt;base_iter = base_iter;
1051   }
1052   return iter;
1053 }
1054 static InfTextBufferIter*
1055 inf_text_fixline_buffer_buffer_create_end_iter(InfTextBuffer* buffer)
1056 {
1057   InfTextFixlineBuffer* fixline_buffer;
1058   InfTextFixlineBufferPrivate* priv;
1059   InfTextBufferIter* iter;
1060   InfTextBufferIter* base_iter;
1061   guint buf_len;
1062   gboolean result;
1063   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1064   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1065   buf_len = inf_text_buffer_get_length(priv-&gt;buffer);
1066   if(priv-&gt;n_keep &gt; 0)
1067   {
1068     iter = g_slice_new(InfTextBufferIter);
1069     iter-&gt;base_iter = NULL;
1070     iter-&gt;keep_end = priv-&gt;n_keep;
1071     iter-&gt;keep_begin = inf_text_fixline_buffer_keep_prev(
1072       priv-&gt;keep,
1073       priv-&gt;n_keep,
1074       priv-&gt;n_keep
1075     );
1076   }
1077   else
1078   {
1079     if(buf_len == (guint)(-priv-&gt;n_keep))
1080       return NULL;
1081     base_iter = inf_text_buffer_create_end_iter(priv-&gt;buffer);
1082     g_assert(base_iter != NULL);
1083     while(inf_text_buffer_iter_get_offset(priv-&gt;buffer, base_iter) &gt;=
1084           buf_len - (guint)(-priv-&gt;n_keep))
1085     {
1086       result = inf_text_buffer_iter_prev(priv-&gt;buffer, base_iter);
1087       g_assert(result == TRUE);
1088     }
1089     iter = g_slice_new(InfTextBufferIter);
1090     iter-&gt;base_iter = base_iter;
1091   }
1092   return iter;
1093 }
1094 static void
1095 inf_text_fixline_buffer_buffer_destroy_iter(InfTextBuffer* buffer,
1096                                             InfTextBufferIter* iter)
1097 {
1098   InfTextFixlineBuffer* fixline_buffer;
1099   InfTextFixlineBufferPrivate* priv;
1100   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1101   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1102   if(iter-&gt;base_iter != NULL)
1103     inf_text_buffer_destroy_iter(priv-&gt;buffer, iter-&gt;base_iter);
1104   g_slice_free(InfTextBufferIter, iter);
1105 }
1106 static gboolean
1107 inf_text_fixline_buffer_buffer_iter_next(InfTextBuffer* buffer,
1108                                          InfTextBufferIter* iter)
1109 {
1110   InfTextFixlineBuffer* fixline_buffer;
1111   InfTextFixlineBufferPrivate* priv;
1112   guint offset;
1113   guint length;
1114   guint buf_len;
1115   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1116   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1117   if(iter-&gt;base_iter == NULL)
1118   {
1119     g_assert(priv-&gt;n_keep &gt; 0);
1120     if(iter-&gt;keep_end == priv-&gt;n_keep)
1121       return FALSE;
1122     iter-&gt;keep_begin = iter-&gt;keep_end;
1123     iter-&gt;keep_end = inf_text_fixline_buffer_keep_next(
1124       priv-&gt;keep,
1125       priv-&gt;n_keep,
1126       iter-&gt;keep_end
1127     );
1128     return TRUE;
1129   }
1130   else if(priv-&gt;n_keep &gt; 0)
1131   {
1132     if(inf_text_buffer_iter_next(priv-&gt;buffer, iter-&gt;base_iter) == TRUE)
1133       return TRUE;
1134     inf_text_buffer_destroy_iter(priv-&gt;buffer, iter-&gt;base_iter);
1135     iter-&gt;base_iter = NULL;
1136     iter-&gt;keep_begin = 0;
1137     iter-&gt;keep_end = inf_text_fixline_buffer_keep_next(
1138       priv-&gt;keep,
1139       priv-&gt;n_keep,
1140       0
1141     );
1142     return TRUE;
1143   }
1144   else
1145   {
1146     offset = inf_text_buffer_iter_get_offset(priv-&gt;buffer, iter-&gt;base_iter);
1147     length = inf_text_buffer_iter_get_length(priv-&gt;buffer, iter-&gt;base_iter);
1148     buf_len = inf_text_buffer_get_length(priv-&gt;buffer);
1149     if(offset + length &gt;= buf_len - (guint)(-priv-&gt;n_keep))
1150       return FALSE;
1151     return inf_text_buffer_iter_next(priv-&gt;buffer, iter-&gt;base_iter);
1152   }
1153 }
1154 static gboolean
1155 inf_text_fixline_buffer_buffer_iter_prev(InfTextBuffer* buffer,
1156                                          InfTextBufferIter* iter)
1157 {
1158   InfTextFixlineBuffer* fixline_buffer;
1159   InfTextFixlineBufferPrivate* priv;
1160   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1161   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1162   if(iter-&gt;base_iter == NULL)
1163   {
1164     g_assert(priv-&gt;n_keep &gt; 0);
1165     if(iter-&gt;keep_begin == 0)
1166     {
1167       iter-&gt;base_iter = inf_text_buffer_create_end_iter(priv-&gt;buffer);
1168       if(iter-&gt;base_iter == NULL)
1169         return FALSE;
1170       return TRUE;
1171     }
1172     else
1173     {
1174       iter-&gt;keep_end = iter-&gt;keep_begin;
1175       iter-&gt;keep_begin = inf_text_fixline_buffer_keep_next(
1176         priv-&gt;keep,
1177         priv-&gt;n_keep,
1178         iter-&gt;keep_begin
1179       );
1180       return TRUE;
1181     }
1182   }
1183   else
1184   {
1185     return inf_text_buffer_iter_prev(priv-&gt;buffer, iter-&gt;base_iter);
1186   }
1187 }
1188 static gpointer
1189 inf_text_fixline_buffer_buffer_iter_get_text(InfTextBuffer* buffer,
1190                                              InfTextBufferIter* iter)
1191 {
1192   InfTextFixlineBuffer* fixline_buffer;
1193   InfTextFixlineBufferPrivate* priv;
1194   gpointer text;
1195   guint i;
1196   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1197   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1198   if(iter-&gt;base_iter == NULL)
1199   {
1200     g_assert(iter-&gt;keep_end &gt; iter-&gt;keep_begin);
1201     text = g_malloc(iter-&gt;keep_end - iter-&gt;keep_begin);
1202     for(i = 0; i &lt; iter-&gt;keep_end - iter-&gt;keep_begin; ++i)
1203       ((gchar*)text)[i] = '\n';
1204     return text;
1205   }
1206   else
1207   {
1208     text = inf_text_buffer_iter_get_text(priv-&gt;buffer, iter-&gt;base_iter);
1209     return text;
1210   }
1211 }
1212 static guint
1213 inf_text_fixline_buffer_buffer_iter_get_offset(InfTextBuffer* buffer,
1214                                                InfTextBufferIter* iter)
1215 {
1216   InfTextFixlineBuffer* fixline_buffer;
1217   InfTextFixlineBufferPrivate* priv;
1218   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1219   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1220   if(iter-&gt;base_iter == NULL)
1221   {
1222     return inf_text_buffer_get_length(priv-&gt;buffer) + iter-&gt;keep_begin;
1223   }
1224   else
1225   {
1226     return inf_text_buffer_iter_get_offset(priv-&gt;buffer, iter-&gt;base_iter);
1227   }
1228 }
1229 static guint
1230 inf_text_fixline_buffer_buffer_iter_get_length(InfTextBuffer* buffer,
1231                                                InfTextBufferIter* iter)
1232 {
1233   InfTextFixlineBuffer* fixline_buffer;
1234   InfTextFixlineBufferPrivate* priv;
1235   guint length;
1236   guint offset;
1237   guint buf_len;
1238   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1239   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1240   if(iter-&gt;base_iter == NULL)
1241   {
1242     return iter-&gt;keep_end - iter-&gt;keep_begin;
1243   }
1244   else
1245   {
1246     length = inf_text_buffer_iter_get_length(priv-&gt;buffer, iter-&gt;base_iter);
1247     if(priv-&gt;n_keep &gt;= 0)
1248       return length;
1249     buf_len = inf_text_buffer_get_length(priv-&gt;buffer);
1250     offset = inf_text_buffer_iter_get_offset(priv-&gt;buffer, iter-&gt;base_iter);
1251     g_assert(offset + length &lt;= buf_len);
1252     if(offset + length &gt; buf_len - (guint)(-priv-&gt;n_keep))
1253     {
1254       return length - (buf_len - (guint)(-priv-&gt;n_keep) - offset);
1255     }
1256     else
1257     {
1258       return length;
1259     }
1260   }
1261 }
1262 static gsize
1263 inf_text_fixline_buffer_buffer_iter_get_bytes(InfTextBuffer* buffer,
1264                                               InfTextBufferIter* iter)
1265 {
1266   InfTextFixlineBuffer* fixline_buffer;
1267   InfTextFixlineBufferPrivate* priv;
1268   gsize bytes;
1269   guint length;
1270   guint offset;
1271   guint buf_len;
1272   guint extra_chars;
1273   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1274   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1275   if(iter-&gt;base_iter == NULL)
1276   {
1277     return iter-&gt;keep_end - iter-&gt;keep_begin;
1278   }
1279   else
1280   {
1281     bytes = inf_text_buffer_iter_get_bytes(priv-&gt;buffer, iter-&gt;base_iter);
1282     if(priv-&gt;n_keep &gt;= 0)
1283       return bytes;
1284     length = inf_text_buffer_iter_get_length(priv-&gt;buffer, iter-&gt;base_iter);
1285     offset = inf_text_buffer_iter_get_offset(priv-&gt;buffer, iter-&gt;base_iter);
1286     buf_len = inf_text_buffer_get_length(priv-&gt;buffer);
1287     g_assert(offset + length &lt;= buf_len);
1288     if(offset + length &gt; buf_len - (guint)(-priv-&gt;n_keep))
1289     {
1290       extra_chars = (buf_len - (guint)(-priv-&gt;n_keep) - offset);
1291       return bytes - extra_chars;
1292     }
1293     else
1294     {
1295       return bytes;
1296     }
1297   }
1298 }
1299 static guint
1300 inf_text_fixline_buffer_buffer_iter_get_author(InfTextBuffer* buffer,
1301                                                InfTextBufferIter* iter)
1302 {
1303   InfTextFixlineBuffer* fixline_buffer;
1304   InfTextFixlineBufferPrivate* priv;
1305   gsize bytes;
1306   guint length;
1307   guint offset;
1308   guint buf_len;
1309   guint extra_chars;
1310   fixline_buffer = INF_TEXT_FIXLINE_BUFFER(buffer);
1311   priv = INF_TEXT_FIXLINE_BUFFER_PRIVATE(fixline_buffer);
1312   if(iter-&gt;base_iter == NULL)
1313   {
1314     g_assert(priv-&gt;n_keep &gt; 0);
1315     g_assert(iter-&gt;keep_begin &lt; (guint)priv-&gt;n_keep);
1316     return priv-&gt;keep[iter-&gt;keep_begin];
1317   }
1318 <a name="3"></a>  else
1319   {
1320     return inf_text_buffer_iter_get_author(priv-&gt;buffer, iter-&gt;base_iter);
1321 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  }
1322 }
1323 static void
1324 inf_text_fixline_buffer_class_init(
1325   InfTextFixlineBufferClass* fixline_buffer_class)
1326 {
1327   GObjectClass* object_class;
1328   object_class = G_OBJECT_CLASS(fixline_buffer_class);
1329   object_class-&gt;constructed = inf_text_fixline_buffer_constructed;
1330   object_class-&gt;dispose = inf_text_fixline_buffer_dispose;
1331   object_class-&gt;finalize = inf_text_fixline_buffer_finalize;
1332   object_class-&gt;set_property = inf_text_fixline_buffer_set_property;
1333   object_class-&gt;get_property = inf_text_fixline_buffer_get_property;
1334   g_object_class_override_property(object_class, PROP_MODIFIED, "modified");
1335   g_object_class_install_property(
1336     object_class,
1337     PROP_IO,
1338     g_param_spec_object(
1339       "io",
1340       "IO",
1341       "The I/O object used to schedule line keeping",
1342       INF_TYPE_IO,
1343       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1344     )
1345   );
1346   g_object_class_install_property(
1347     object_class,
1348     PROP_BUFFER,
1349     g_param_spec_object(
1350       "buffer",
1351       "Buffer",
1352       "The buffer for which to keep a fixed line count",
1353       INF_TEXT_TYPE_BUFFER,
1354       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1355     )
1356   );
1357   g_object_class_install_property(
1358     object_class,
1359     PROP_LINES,
1360     g_param_spec_uint(
1361       "lines",
1362       "lines",
1363       "The number of lines to keep in the underlying buffer",
1364       0,
1365       G_MAXUINT,
1366       0,
1367       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1368     )
1369   );
1370 }</b></font>
1371 static void
1372 inf_text_fixline_buffer_buffer_iface_init(InfBufferInterface* iface)
1373 {
1374   iface-&gt;get_modified = inf_text_fixline_buffer_buffer_get_modified;
1375   iface-&gt;set_modified = inf_text_fixline_buffer_buffer_set_modified;
1376 }
1377 static void
1378 inf_text_fixline_buffer_text_buffer_iface_init(InfTextBufferInterface* iface)
1379 {
1380   iface-&gt;get_encoding = inf_text_fixline_buffer_buffer_get_encoding;
1381   iface-&gt;get_length = inf_text_fixline_buffer_get_length;
1382   iface-&gt;get_slice = inf_text_fixline_buffer_buffer_get_slice;
1383   iface-&gt;insert_text = inf_text_fixline_buffer_buffer_insert_text;
1384   iface-&gt;erase_text = inf_text_fixline_buffer_buffer_erase_text;
1385   iface-&gt;create_begin_iter = inf_text_fixline_buffer_buffer_create_begin_iter;
1386   iface-&gt;create_end_iter = inf_text_fixline_buffer_buffer_create_end_iter;
1387   iface-&gt;destroy_iter = inf_text_fixline_buffer_buffer_destroy_iter;
1388   iface-&gt;iter_next = inf_text_fixline_buffer_buffer_iter_next;
1389   iface-&gt;iter_prev = inf_text_fixline_buffer_buffer_iter_prev;
1390   iface-&gt;iter_get_text = inf_text_fixline_buffer_buffer_iter_get_text;
1391   iface-&gt;iter_get_offset = inf_text_fixline_buffer_buffer_iter_get_offset;
1392   iface-&gt;iter_get_length = inf_text_fixline_buffer_buffer_iter_get_length;
1393   iface-&gt;iter_get_bytes = inf_text_fixline_buffer_buffer_iter_get_bytes;
1394   iface-&gt;iter_get_author = inf_text_fixline_buffer_buffer_iter_get_author;
1395   iface-&gt;text_inserted = NULL;
1396   iface-&gt;text_erased = NULL;
1397 }
1398 InfTextFixlineBuffer*
1399 inf_text_fixline_buffer_new(InfIo* io,
1400                             InfTextBuffer* buffer,
1401                             guint n_lines)
1402 {
1403   GObject* object;
1404   object = g_object_new(
1405     INF_TEXT_TYPE_FIXLINE_BUFFER,
1406     "io", io,
1407     "buffer", buffer,
1408     "lines", n_lines,
1409     NULL
1410   );
1411   return INF_TEXT_FIXLINE_BUFFER(object);
1412 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-permissions-dialog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfgtk/inf-gtk-permissions-dialog.h&gt;
2 #include &lt;libinfgtk/inf-gtk-acl-sheet-view.h&gt;
3 #include &lt;libinfinity/common/inf-request-result.h&gt;
4 #include &lt;libinfinity/common/inf-error.h&gt;
5 #include &lt;libinfinity/inf-i18n.h&gt;
6 #include &lt;libinfinity/inf-signals.h&gt;
7 #include &lt;gdk/gdkkeysyms.h&gt;
8 #include &lt;string.h&gt;
9 enum {
10   INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID = 0,
11   INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME = 1
12 };
13 <a name="2"></a>
14 typedef struct _InfGtkPermissionsDialogPendingSheet
15   InfGtkPermissionsDialogPendingSheet;
16 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>struct _InfGtkPermissionsDialogPendingSheet {
17   InfGtkPermissionsDialog* dialog;
18   GtkTreeRowReference* row;
19   InfAclSheet sheet;
20   InfAclAccountId last_combo_changed_id;
21   InfRequest* lookup_request;
22 };
23 typedef struct _InfGtkPermissionsDialogPrivate InfGtkPermissionsDialogPrivate;
24 struct _InfGtkPermissionsDialogPrivate {
25   InfBrowser* browser;
26   InfBrowserIter browser_iter;
27   GtkListStore* account_store;
28   InfRequest* query_acl_account_list_request;
29   gboolean account_list_queried;
30   InfAclAccount* accounts;
31   guint n_accounts;
32   InfRequest* query_acl_request;
33   GSList* set_acl_requests;
34   GSList* remove_acl_account_requests;
35   GSList* lookup_acl_account_requests;
36   GSList* pending_sheets;
37   GtkMenu* popup_menu;
38   InfAclAccountId popup_account;
39   GtkWidget* status_text;
40   GtkWidget* tree_view;
41   GtkWidget* sheet_view;
42   GtkWidget* add_button;
43   GtkWidget* remove_button;
44   GtkCellRenderer* renderer;
45 };
46 enum {
47   PROP_0,
48   PROP_BROWSER,
49   PROP_BROWSER_ITER
50 };
51 #define INF_GTK_PERMISSIONS_DIALOG_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_PERMISSIONS_DIALOG, InfGtkPermissionsDialogPrivate))
52 G_DEFINE_TYPE_WITH_CODE(InfGtkPermissionsDialog, inf_gtk_permissions_dialog, GTK_TYPE_DIALOG,
53   G_ADD_PRIVATE(InfGtkPermissionsDialog))
54 static void</b></font>
55 inf_gtk_permissions_dialog_update(InfGtkPermissionsDialog* dialog,
56                                   const GError* error);
57 static void
58 inf_gtk_permissions_dialog_update_sheet(InfGtkPermissionsDialog* dialog);
59 static gboolean
60 inf_gtk_permissions_dialog_find_account(InfGtkPermissionsDialog* dialog,
61                                         InfAclAccountId account,
62                                         GtkTreeIter* out_iter)
63 {
64   InfGtkPermissionsDialogPrivate* priv;
65   gpointer row_account_id;
66   GtkTreeModel* model;
67   GtkTreeIter iter;
68   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
69   model = GTK_TREE_MODEL(priv-&gt;account_store);
70   if(gtk_tree_model_get_iter_first(model, &amp;iter))
71   {
72     do
73     {
74       gtk_tree_model_get(
75         model,
76         &amp;iter,
77         INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
78         &amp;row_account_id,
79         -1
80       );
81       if(row_account_id == INF_ACL_ACCOUNT_ID_TO_POINTER(account))
82       {
83         if(out_iter != NULL)
84           *out_iter = iter;
85         return TRUE;
86       }
87     } while(gtk_tree_model_iter_next(model, &amp;iter));
88   }
89   return FALSE;
90 }
91 static InfGtkPermissionsDialogPendingSheet*
92 inf_gtk_permissions_dialog_find_pending_sheet(InfGtkPermissionsDialog* dialog,
93                                               GtkTreeIter* iter)
94 {
95   InfGtkPermissionsDialogPrivate* priv;
96   GtkTreeModel* model;
97   GtkTreePath* path;
98   GSList* item;
99   InfGtkPermissionsDialogPendingSheet* pending;
100   GtkTreePath* pending_path;
101   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
102   model = GTK_TREE_MODEL(priv-&gt;account_store);
103   path = gtk_tree_model_get_path(model, iter);
104   for(item = priv-&gt;pending_sheets; item != NULL; item = item-&gt;next)
105   {
106     pending = (InfGtkPermissionsDialogPendingSheet*)item-&gt;data;
107     pending_path = gtk_tree_row_reference_get_path(pending-&gt;row);
108     g_assert(pending_path != NULL);
109     if(gtk_tree_path_compare(path, pending_path) == 0)
110     {
111       gtk_tree_path_free(path);
112       gtk_tree_path_free(pending_path);
113       return pending;
114     }
115     gtk_tree_path_free(pending_path);
116   }
117   gtk_tree_path_free(path);
118   return NULL;
119 }
120 static void
121 inf_gtk_permissions_dialog_set_acl_finished_cb(InfRequest* request,
122                                                const InfRequestResult* result,
123                                                const GError* error,
124                                                gpointer user_data)
125 {
126   InfGtkPermissionsDialog* dialog;
127   InfGtkPermissionsDialogPrivate* priv;
128   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
129   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
130   if(error != NULL)
131   {
132     inf_gtk_permissions_dialog_update(dialog, error);
133     inf_gtk_permissions_dialog_update_sheet(dialog);
134   }
135   if(g_slist_find(priv-&gt;set_acl_requests, request) != NULL)
136   {
137     priv-&gt;set_acl_requests = g_slist_remove(priv-&gt;set_acl_requests, request);
138     g_object_unref(request);
139   }
140 }
141 static void
142 inf_gtk_permissions_dialog_selection_changed_cb(GtkTreeSelection* selection,
143                                                 gpointer user_data)
144 {
145   InfGtkPermissionsDialog* dialog;
146   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
147   inf_gtk_permissions_dialog_update_sheet(dialog);
148   inf_gtk_permissions_dialog_update(dialog, NULL);
149 }
150 static void
151 inf_gtk_permissions_dialog_sheet_changed_cb(InfGtkAclSheetView* sheet_view,
152                                             gpointer user_data)
153 {
154   InfGtkPermissionsDialog* dialog;
155   InfGtkPermissionsDialogPrivate* priv;
156   const InfAclSheet* sheet;
157   InfAclSheetSet sheet_set;
158   InfRequest* request;
159   GtkTreeSelection* selection;
160   gboolean has_selection;
161   GtkTreeIter iter;
162   InfGtkPermissionsDialogPendingSheet* pending;
163   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
164   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
165   sheet = inf_gtk_acl_sheet_view_get_sheet(
166     INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view)
167   );
168   if(sheet != NULL)
169   {
170     if(sheet-&gt;account != 0)
171     {
172       sheet_set.own_sheets = NULL;
173       sheet_set.sheets = sheet;
174       sheet_set.n_sheets = 1;
175       request = inf_browser_set_acl(
176         priv-&gt;browser,
177         &amp;priv-&gt;browser_iter,
178         &amp;sheet_set,
179         inf_gtk_permissions_dialog_set_acl_finished_cb,
180         dialog
181       );
182       if(request != NULL)
183       {
184         priv-&gt;set_acl_requests =
185           g_slist_prepend(priv-&gt;set_acl_requests, request);
186         g_object_ref(request);
187       }
188     }
189     else
190     {
191       selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
192       has_selection = gtk_tree_selection_get_selected(selection, NULL, &amp;iter);
193       g_assert(has_selection);
194       pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
195       g_assert(pending != NULL);
196       pending-&gt;sheet = *sheet;
197     }
198   }
199 }
200 static int
201 inf_gtk_permissions_dialog_account_sort_func(GtkTreeModel* model,
202                                              GtkTreeIter* a,
203                                              GtkTreeIter* b,
204                                              gpointer user_data)
205 {
206   InfGtkPermissionsDialog* dialog;
207   InfGtkPermissionsDialogPrivate* priv;
208   InfAclAccountId default_id;
209   gpointer account_a_id_ptr;
210   gpointer account_b_id_ptr;
211   InfAclAccountId account_a_id;
212   InfAclAccountId account_b_id;
213   const gchar* account_a_id_str;
214   const gchar* account_b_id_str;
215   gchar* account_a_name;
216   gchar* account_b_name;
217   int result;
218   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
219   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
220   gtk_tree_model_get(
221     model,
222     a,
223     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_a_id_ptr,
224     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_a_name,
225     -1
226   );
227   gtk_tree_model_get(
228     model,
229     b,
230     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_b_id_ptr,
231     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_b_name,
232     -1
233   );
234   account_a_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_a_id_ptr);
235   account_b_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_b_id_ptr);
236   account_a_id_str = inf_acl_account_id_to_string(account_a_id);
237   account_b_id_str = inf_acl_account_id_to_string(account_b_id);
238   default_id = inf_acl_account_id_from_string("default");
239   if(account_a_id == default_id)
240   {
241     if(account_b_id == default_id)
242       result = 0;
243     else
244       result = -1;
245   }
246   else if(account_b_id == default_id)
247   {
248     result = 1;
249   }
250   else if(account_a_name != NULL &amp;&amp; account_a_id != 0)
251   {
252     if(account_b_name != NULL &amp;&amp; account_b_id != 0)
253       result = g_utf8_collate(account_a_name, account_b_name);
254     else
255       result = -1;
256   }
257   else if(account_b_name != NULL &amp;&amp; account_b_id != 0)
258   {
259     result = 1;
260   }
261   else if(account_a_name == NULL &amp;&amp; account_a_id != 0)
262   {
263     if(account_b_name == NULL &amp;&amp; account_b_id != 0)
264       result = g_utf8_collate(account_a_id_str, account_b_id_str);
265     else
266       result = -1;
267   }
268   else if(account_b_name == NULL &amp;&amp; account_b_id != 0)
269   {
270     result = 1;
271   }
272   else if(account_a_name != NULL &amp;&amp; account_a_id == 0)
273   {
274     if(account_b_name != NULL &amp;&amp; account_b_id == 0)
275       result = g_utf8_collate(account_a_name, account_b_name);
276     else
277       result = -1;
278   }
279   else if(account_b_name != NULL &amp;&amp; account_b_id == 0)
280   {
281     result = 1;
282   }
283   else
284   {
285     g_assert_not_reached();
286     result = 0;
287   }
288   g_free(account_a_name);
289   g_free(account_b_name);
290   return result;
291 }
292 static void
293 inf_gtk_permissions_dialog_lookup_by_name_finished_cb(
294   InfRequest* request,
295   const InfRequestResult* result,
296   const GError* error,
297   gpointer user_data);
298 static void
299 inf_gtk_permissions_dialog_remove_pending_sheet(
300   InfGtkPermissionsDialog* dialog,
301   InfGtkPermissionsDialogPendingSheet* pending)
302 {
303   InfGtkPermissionsDialogPrivate* priv;
304   GtkTreePath* path;
305   GtkTreeIter iter;
306   gboolean has_iter;
307   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
308   if(pending-&gt;lookup_request != NULL)
309   {
310     inf_signal_handlers_disconnect_by_func(
311       G_OBJECT(pending-&gt;lookup_request),
312       G_CALLBACK(inf_gtk_permissions_dialog_lookup_by_name_finished_cb),
313       pending
314     );
315     g_object_unref(pending-&gt;lookup_request);
316   }
317   priv-&gt;pending_sheets = g_slist_remove(priv-&gt;pending_sheets, pending);
318   if(pending-&gt;row != NULL)
319   {
320     path = gtk_tree_row_reference_get_path(pending-&gt;row);
321     g_assert(path != NULL);
322     has_iter = gtk_tree_model_get_iter(
323       GTK_TREE_MODEL(priv-&gt;account_store),
324       &amp;iter,
325       path
326     );
327     g_assert(has_iter == TRUE);
328     gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
329     gtk_tree_path_free(path);
330     gtk_tree_row_reference_free(pending-&gt;row);
331   }
332   g_slice_free(InfGtkPermissionsDialogPendingSheet, pending);
333 }
334 static void
335 inf_gtk_permissions_dialog_realize_pending_sheet(
336   InfGtkPermissionsDialog* dialog,
337   InfGtkPermissionsDialogPendingSheet* pending,
338   InfAclAccountId id,
339   const gchar* name)
340 {
341   InfGtkPermissionsDialogPrivate* priv;
342   GtkTreeIter iter;
343   GtkTreePath* path;
344   gboolean has_iter;
345   InfAclSheet pending_sheet;
346   InfAclSheetSet sheet_set;
347   InfRequest* request;
348   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
349   pending_sheet = pending-&gt;sheet;
350   pending_sheet.account = id;
351   if(inf_gtk_permissions_dialog_find_account(dialog, id, &amp;iter))
352   {
353     path = gtk_tree_model_get_path(
354       GTK_TREE_MODEL(priv-&gt;account_store),
355       &amp;iter
356     );
357     inf_signal_handlers_block_by_func(
358       G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view))),
359       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
360       dialog
361     );
362     gtk_tree_view_set_cursor(
363       GTK_TREE_VIEW(priv-&gt;tree_view),
364       path,
365       gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
366       FALSE
367     );
368     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
369     inf_signal_handlers_unblock_by_func(
370       G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view))),
371       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
372       dialog
373     );
374     gtk_tree_path_free(path);
375     inf_gtk_permissions_dialog_update_sheet(dialog);
376   }
377   else
378   {
379     path = gtk_tree_row_reference_get_path(pending-&gt;row);
380     g_assert(path != NULL);
381     has_iter  = gtk_tree_model_get_iter(
382       GTK_TREE_MODEL(priv-&gt;account_store),
383       &amp;iter,
384       path
385     );
386     g_assert(has_iter == TRUE);
387     gtk_list_store_set(
388       priv-&gt;account_store,
389       &amp;iter,
390       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, INF_ACL_ACCOUNT_ID_TO_POINTER(id),
391       INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, name,
392       -1
393     );
394     gtk_tree_row_reference_free(pending-&gt;row);
395     pending-&gt;row = NULL;
396     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
397     inf_signal_handlers_block_by_func(
398       G_OBJECT(priv-&gt;sheet_view),
399       G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
400       dialog
401     );
402     inf_gtk_acl_sheet_view_set_sheet(
403       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
404       &amp;pending_sheet
405     );
406     inf_signal_handlers_unblock_by_func(
407       G_OBJECT(priv-&gt;sheet_view),
408       G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
409       dialog
410     );
411     if(!inf_acl_mask_empty(&amp;pending_sheet.mask))
412     {
413       sheet_set.own_sheets = NULL;
414       sheet_set.sheets = &amp;pending_sheet;
415       sheet_set.n_sheets = 1;
416       request = inf_browser_set_acl(
417         priv-&gt;browser,
418         &amp;priv-&gt;browser_iter,
419         &amp;sheet_set,
420         inf_gtk_permissions_dialog_set_acl_finished_cb,
421         dialog
422       );
423       if(request != NULL)
424       {
425         priv-&gt;set_acl_requests =
426           g_slist_prepend(priv-&gt;set_acl_requests, request);
427         g_object_ref(request);
428       }
429     }
430     inf_gtk_permissions_dialog_update(dialog, NULL);
431   }
432 }
433 static void
434 inf_gtk_permissions_dialog_lookup_by_name_finished_cb(
435   InfRequest* request,
436   const InfRequestResult* result,
437   const GError* error,
438   gpointer user_data)
439 {
440   InfGtkPermissionsDialogPendingSheet* pending;
441   InfGtkPermissionsDialog* dialog;
442   InfGtkPermissionsDialogPrivate* priv;
443   const InfAclAccount* accounts;
444   guint n_accounts;
445   pending = (InfGtkPermissionsDialogPendingSheet*)user_data;
446   dialog = pending-&gt;dialog;
447   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
448   if(pending-&gt;lookup_request != NULL)
449   {
450     g_object_unref(pending-&gt;lookup_request);
451     pending-&gt;lookup_request = NULL;
452   }
453   if(error != NULL)
454   {
455     g_warning("Failed to reverse lookup: %s", error-&gt;message);
456     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
457   }
458   else
459   {
460     inf_request_result_get_lookup_acl_accounts(
461       result,
462       NULL,
463       &amp;accounts,
464       &amp;n_accounts
465     );
466     if(n_accounts &gt; 0)
467     {
468       if(n_accounts &gt; 1)
469       {
470         g_warning(
471           "Multiple accounts with the same name \"%s\"",
472           accounts[0].name
473         );
474       }
475       inf_gtk_permissions_dialog_realize_pending_sheet(
476         dialog,
477         pending,
478         accounts[0].id,
479         accounts[0].name
480       );
481     }
482     else
483     {
484       inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
485     }
486   }
487 }
488 static void
489 inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb(
490   InfRequest* request,
491   const InfRequestResult* result,
492   const GError* error,
493   gpointer user_data);
494 static void
495 inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
496   InfGtkPermissionsDialog* dialog,
497   InfRequest* request)
498 {
499   InfGtkPermissionsDialogPrivate* priv;
500   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
501   inf_signal_handlers_disconnect_by_func(
502     request,
503     G_CALLBACK(inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb),
504     dialog
505   );
506   if(g_slist_find(priv-&gt;lookup_acl_account_requests, request) != NULL)
507   {
508     priv-&gt;lookup_acl_account_requests =
509       g_slist_remove(priv-&gt;lookup_acl_account_requests, request);
510     g_object_unref(request);
511   }
512 }
513 static void
514 inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb(
515   InfRequest* request,
516   const InfRequestResult* result,
517   const GError* error,
518   gpointer user_data)
519 {
520   InfGtkPermissionsDialog* dialog;
521   InfGtkPermissionsDialogPrivate* priv;
522   const InfAclAccount* accounts;
523   guint n_accounts;
524   guint i;
525   GtkTreeIter iter;
526   InfAclAccountId account_id;
527   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
528   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
529   if(error != NULL)
530   {
531     g_warning("Failed to look up accounts: %s\n", error-&gt;message);
532   }
533   else
534   {
535     inf_request_result_get_lookup_acl_accounts(
536       result,
537       NULL,
538       &amp;accounts,
539       &amp;n_accounts
540     );
541     for(i = 0; i &lt; n_accounts; ++i)
542     {
543       if(accounts[i].name != NULL)
544       {
545         account_id = accounts[i].id;
546         if(inf_gtk_permissions_dialog_find_account(dialog, account_id, &amp;iter))
547         {
548           gtk_list_store_set(
549             GTK_LIST_STORE(priv-&gt;account_store),
550             &amp;iter,
551             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
552             accounts[i].name,
553             -1
554           );
555         }
556       }
557     }
558   }
559   inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
560     dialog,
561     request
562   );
563 }
564 static void
565 inf_gtk_permissions_dialog_fill_account_list(InfGtkPermissionsDialog* dialog,
566                                              const InfAclAccountId* ids,
567                                              guint n_ids)
568 {
569   InfGtkPermissionsDialogPrivate* priv;
570   GtkTreeModel* model;
571   gboolean* have_accounts;
572   GtkTreeIter iter;
573   gpointer account_id_ptr;
574   InfAclAccountId account_id;
575   gboolean has_row;
576   guint i, j;
577   InfAclAccountId* lookup_ids;
578   guint n_lookup_ids;
579   guint lookup_index;
580   const gchar* new_account_name;
581   InfAclMask perms;
582   const InfAclAccount* default_account;
583   const InfAclAccount* local_account;
584   InfRequest* request;
585   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
586   model = GTK_TREE_MODEL(priv-&gt;account_store);
587   have_accounts = g_malloc(n_ids * sizeof(gboolean));
588   for(i = 0; i &lt; n_ids; ++i)
589     have_accounts[i] = FALSE;
590   n_lookup_ids = n_ids;
591   has_row = gtk_tree_model_get_iter_first(model, &amp;iter);
592   while(has_row)
593   {
594     gtk_tree_model_get(
595       model,
596       &amp;iter,
597       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
598       &amp;account_id_ptr,
599       -1
600     );
601     account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
602     if(account_id == 0)
603     {
604       has_row = gtk_tree_model_iter_next(model, &amp;iter);
605     }
606     else
607     {
608       for(i = 0; i &lt; n_ids; ++i)
609         if(account_id == ids[i])
610           break;
611       if(i &lt; n_ids)
612       {
613         have_accounts[i] = TRUE;
614         has_row = gtk_tree_model_iter_next(model, &amp;iter);
615         g_assert(n_lookup_ids &gt; 0);
616         --n_lookup_ids;
617       }
618       else
619       {
620         inf_signal_handlers_block_by_func(
621           gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
622           G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
623           dialog
624         );
625         has_row = gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
626         inf_signal_handlers_unblock_by_func(
627           gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
628           G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
629           dialog
630         );
631       }
632     }
633   }
634   if(n_lookup_ids &gt; 0)
635     lookup_ids = g_malloc(sizeof(InfAclAccountId) * n_lookup_ids);
636   lookup_index = 0;
637   default_account = inf_browser_get_acl_default_account(priv-&gt;browser);
638   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
639   for(i = 0; i &lt; n_ids; ++i)
640   {
641     if(!have_accounts[i])
642     {
643       if(ids[i] == default_account-&gt;id)
644       {
645         new_account_name = default_account-&gt;name;
646       }
647       else if(local_account != NULL &amp;&amp; ids[i] == local_account-&gt;id)
648       {
649         new_account_name = local_account-&gt;name;
650       }
651       else
652       {
653         new_account_name = NULL;
654         for(j = 0; j &lt; priv-&gt;n_accounts; ++j)
655         {
656           if(priv-&gt;accounts[j].id == ids[i])
657           {
658             new_account_name = priv-&gt;accounts[j].name;
659             break;
660           }
661         }
662       }
663       gtk_list_store_insert_with_values(
664         priv-&gt;account_store,
665         NULL,
666         -1,
667         INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
668         INF_ACL_ACCOUNT_ID_TO_POINTER(ids[i]),
669         INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
670         new_account_name,
671         -1
672       );
673       if(new_account_name == NULL &amp;&amp; ids[i] != default_account-&gt;id)
674         lookup_ids[lookup_index++] = ids[i];
675     }
676   }
677   if(lookup_index &gt; 0)
678   {
679     g_assert(lookup_index &lt;= n_lookup_ids);
680     inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
681     inf_browser_check_acl(
682       priv-&gt;browser,
683       &amp;priv-&gt;browser_iter,
684       local_account ? local_account-&gt;id : 0,
685       &amp;perms,
686       &amp;perms
687     );
688     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST))
689     {
690       request = inf_browser_lookup_acl_accounts(
691         priv-&gt;browser,
692         lookup_ids,
693         lookup_index,
694         inf_gtk_permissions_dialog_lookup_acl_accounts_finished_cb,
695         dialog
696       );
697       if(request != NULL)
698       {
699         g_object_ref(request);
700         priv-&gt;lookup_acl_account_requests = g_slist_prepend(
701           priv-&gt;lookup_acl_account_requests,
702           request
703         );
704       }
705     }
706   }
707   if(n_lookup_ids &gt; 0)
708     g_free(lookup_ids);
709   g_free(have_accounts);
710 }
711 static void
712 inf_gtk_permissions_dialog_update_sheet(InfGtkPermissionsDialog* dialog)
713 {
714   InfGtkPermissionsDialogPrivate* priv;
715   GtkTreeSelection* selection;
716   GtkTreeModel* model;
717   GtkTreeIter iter;
718   gpointer account_id_ptr;
719   InfAclAccountId account_id;
720   InfAclAccountId default_id;
721   const InfAclSheetSet* sheet_set;
722   const InfAclSheet* sheet;
723   InfAclSheet default_sheet;
724   InfAclMask show_mask;
725   InfAclMask neg_mask;
726   InfGtkPermissionsDialogPendingSheet* pending;
727   InfBrowserIter test_iter;
728   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
729   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
730   inf_signal_handlers_block_by_func(
731     G_OBJECT(priv-&gt;sheet_view),
732     G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
733     dialog
734   );
735   if(!gtk_tree_selection_get_selected(selection, &amp;model, &amp;iter))
736   {
737     inf_gtk_acl_sheet_view_set_sheet(
738       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
739       NULL
740     );
741     account_id = 0;
742   }
743   else
744   {
745     gtk_tree_model_get(
746       model,
747       &amp;iter,
748       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
749       &amp;account_id_ptr,
750       -1
751     );
752     account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
753     if(account_id != 0)
754     {
755       sheet = NULL;
756       sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
757       if(sheet_set != NULL)
758       {
759         sheet = inf_acl_sheet_set_find_const_sheet(sheet_set, account_id);
760       }
761     }
762     else
763     {
764       pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
765       g_assert(pending != NULL);
766       sheet = &amp;pending-&gt;sheet;
767     }
768     if(sheet != NULL)
769     {
770       inf_gtk_acl_sheet_view_set_sheet(
771         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
772         sheet
773       );
774     }
775     else
776     {
777       default_sheet.account = account_id;
778       inf_acl_mask_clear(&amp;default_sheet.mask);
779       inf_acl_mask_clear(&amp;default_sheet.perms);
780       inf_gtk_acl_sheet_view_set_sheet(
781         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
782         &amp;default_sheet
783       );
784     }
785   }
786   test_iter = priv-&gt;browser_iter;
787   show_mask = INF_ACL_MASK_ALL;
788   if(!inf_browser_get_parent(priv-&gt;browser, &amp;test_iter))
789   {
790     default_id = inf_acl_account_id_from_string("default");
791     if(account_id == default_id)
792     {
793       inf_gtk_acl_sheet_view_set_show_default(
794         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
795         FALSE
796       );
797     }
798     else
799     {
800       inf_gtk_acl_sheet_view_set_show_default(
801         INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
802         TRUE
803       );
804     }
805   }
806   else
807   {
808     inf_gtk_acl_sheet_view_set_show_default(
809       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
810       TRUE
811     );
812     inf_acl_mask_neg(&amp;INF_ACL_MASK_ROOT, &amp;neg_mask);
813     inf_acl_mask_and(&amp;show_mask, &amp;neg_mask, &amp;show_mask);
814   }
815   if(!inf_browser_is_subdirectory(priv-&gt;browser, &amp;priv-&gt;browser_iter))
816   {
817     inf_acl_mask_neg(&amp;INF_ACL_MASK_SUBDIRECTORY, &amp;neg_mask);
818     inf_acl_mask_and(&amp;show_mask, &amp;neg_mask, &amp;show_mask);
819   }
820   inf_gtk_acl_sheet_view_set_permission_mask(
821     INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
822     &amp;show_mask
823   );
824   inf_signal_handlers_unblock_by_func(
825     G_OBJECT(priv-&gt;sheet_view),
826     G_CALLBACK(inf_gtk_permissions_dialog_sheet_changed_cb),
827     dialog
828   );
829 }
830 static void
831 inf_gtk_permissions_dialog_node_removed_cb(InfBrowser* browser,
832                                            const InfBrowserIter* iter,
833                                            InfRequest* request,
834                                            gpointer user_data)
835 {
836   InfGtkPermissionsDialog* dialog;
837   InfGtkPermissionsDialogPrivate* priv;
838   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
839   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
840   if(inf_browser_is_ancestor(browser, iter, &amp;priv-&gt;browser_iter))
841     inf_gtk_permissions_dialog_set_node(dialog, NULL, NULL);
842 }
843 static void
844 inf_gtk_permissions_dialog_acl_account_added_cb(InfBrowser* browser,
845                                                 const InfAclAccount* account,
846                                                 InfRequest* request,
847                                                 gpointer user_data)
848 {
849   InfGtkPermissionsDialog* dialog;
850   InfGtkPermissionsDialogPrivate* priv;
851   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
852   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
853   if(account-&gt;id != 0 &amp;&amp; account-&gt;name != NULL &amp;&amp; priv-&gt;accounts != NULL)
854   {
855     priv-&gt;accounts = g_realloc(
856       priv-&gt;accounts,
857       (priv-&gt;n_accounts + 1) * sizeof(InfAclAccount)
858     );
859     priv-&gt;accounts[priv-&gt;n_accounts].id = account-&gt;id;
860     priv-&gt;accounts[priv-&gt;n_accounts].name = g_strdup(account-&gt;name);
861     ++priv-&gt;n_accounts;
862     inf_gtk_permissions_dialog_update(dialog, NULL);
863   }
864 }
865 static void
866 inf_gtk_permissions_dialog_acl_account_removed_cb(InfBrowser* browser,
867                                                   const InfAclAccount* account,
868                                                   InfRequest* request,
869                                                   gpointer user_data)
870 {
871   InfGtkPermissionsDialog* dialog;
872   InfGtkPermissionsDialogPrivate* priv;
873   gboolean have_account;
874   GtkTreeIter iter;
875   guint i;
876   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
877   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
878   g_assert(account-&gt;id != 0);
879   if(priv-&gt;popup_menu != NULL &amp;&amp; account-&gt;id == priv-&gt;popup_account)
880     gtk_menu_popdown(priv-&gt;popup_menu);
881   g_assert(priv-&gt;popup_menu == NULL);
882   g_assert(priv-&gt;popup_account == 0);
883   have_account =
884     inf_gtk_permissions_dialog_find_account(dialog, account-&gt;id, &amp;iter);
885   if(have_account == TRUE)
886   {
887     inf_signal_handlers_block_by_func(
888       gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
889       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
890       dialog
891     );
892     gtk_list_store_remove(priv-&gt;account_store, &amp;iter);
893     inf_signal_handlers_unblock_by_func(
894       gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
895       G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
896       dialog
897     );
898     inf_gtk_permissions_dialog_update_sheet(dialog);
899   }
900   if(priv-&gt;accounts != NULL)
901   {
902     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
903     {
904       if(priv-&gt;accounts[i].id == account-&gt;id)
905       {
906         priv-&gt;accounts[i] = priv-&gt;accounts[priv-&gt;n_accounts - 1];
907         --priv-&gt;n_accounts;
908         priv-&gt;accounts = g_realloc(
909           priv-&gt;accounts,
910           sizeof(InfAclAccount) * priv-&gt;n_accounts
911         );
912         break;
913       }
914     }
915   }
916   inf_gtk_permissions_dialog_update(dialog, NULL);
917 }
918 static void
919 inf_gtk_permissions_dialog_acl_changed_cb(InfBrowser* browser,
920                                           const InfBrowserIter* iter,
921                                           const InfAclSheetSet* sheet_set,
922                                           InfRequest* request,
923                                           gpointer user_data)
924 {
925   InfGtkPermissionsDialog* dialog;
926   InfGtkPermissionsDialogPrivate* priv;
927   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
928   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
929   if(iter-&gt;node == priv-&gt;browser_iter.node)
930     inf_gtk_permissions_dialog_update_sheet(dialog);
931   if(inf_browser_is_ancestor(browser, iter, &amp;priv-&gt;browser_iter))
932     inf_gtk_permissions_dialog_update(dialog, NULL);
933 }
934 static void
935 inf_gtk_permissions_dialog_renderer_editing_started_cb(GtkCellRenderer* r,
936                                                        GtkCellEditable* edit,
937                                                        const gchar* path,
938                                                        gpointer user_data)
939 {
940   g_object_set_data_full(
941     G_OBJECT(r),
942     "inf-gtk-permissions-dialog-path",
943     g_strdup(path),
944     g_free
945   );
946 }
947 static void
948 inf_gtk_permissions_dialog_renderer_editing_canceled_cb(GtkCellRenderer* r,
949                                                         gpointer user_data)
950 {
951   InfGtkPermissionsDialog* dialog;
952   InfGtkPermissionsDialogPrivate* priv;
953   gchar* path_str;
954   GtkTreePath* path;
955   GtkTreeIter iter;
956   gboolean has_selected;
957   InfGtkPermissionsDialogPendingSheet* pending;
958   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
959   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
960   g_object_set(
961     G_OBJECT(priv-&gt;renderer),
962     "model", NULL,
963     "editable", FALSE,
964     NULL
965   );
966   path_str = g_object_steal_data(
967     G_OBJECT(r),
968     "inf-gtk-permissions-dialog-path"
969   );
970   path = gtk_tree_path_new_from_string(path_str);
971   g_free(path_str);
972   has_selected = gtk_tree_model_get_iter(
973     GTK_TREE_MODEL(priv-&gt;account_store),
974     &amp;iter,
975     path
976   );
977   g_assert(has_selected == TRUE);
978   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;iter);
979   g_assert(pending != NULL);
980   inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
981 }
982 static void
983 inf_gtk_permissions_dialog_renderer_changed_cb(GtkCellRendererCombo* combo,
984                                                const gchar* path_str,
985                                                GtkTreeIter* combo_iter,
986                                                gpointer user_data)
987 {
988   InfGtkPermissionsDialog* dialog;
989   InfGtkPermissionsDialogPrivate* priv;
990   GtkTreePath* path;
991   GtkTreeIter view_iter;
992   gboolean has_path;
993   InfGtkPermissionsDialogPendingSheet* pending;
994   GtkTreeModel* model;
995   gpointer id_ptr;
996   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
997   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
998   path = gtk_tree_path_new_from_string(path_str);
999   has_path = gtk_tree_model_get_iter(
1000     GTK_TREE_MODEL(priv-&gt;account_store),
1001     &amp;view_iter,
1002     path
1003   );
1004   g_assert(has_path);
1005   gtk_tree_path_free(path);
1006   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;view_iter);
1007   g_assert(pending != NULL);
1008   g_object_get(G_OBJECT(combo), "model", &amp;model, NULL);
1009   g_assert(model != NULL);
1010   gtk_tree_model_get(
1011     model,
1012     combo_iter,
1013     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1014     &amp;id_ptr,
1015     -1
1016   );
1017   pending-&gt;last_combo_changed_id = INF_ACL_ACCOUNT_POINTER_TO_ID(id_ptr);
1018   g_object_unref(model);
1019 }
1020 static void
1021 inf_gtk_permissions_dialog_renderer_edited_cb(GtkCellRendererCombo* renderer,
1022                                               const gchar* path_str,
1023                                               const gchar* text,
1024                                               gpointer user_data)
1025 {
1026   InfGtkPermissionsDialog* dialog;
1027   InfGtkPermissionsDialogPrivate* priv;
1028   gchar* path_str_obj;
1029   GtkTreePath* path;
1030   gboolean has_path;
1031   GtkTreeIter view_iter;
1032   InfGtkPermissionsDialogPendingSheet* pending;
1033   GtkTreeModel* model;
1034   InfRequest* request;
1035   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1036   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1037   path_str_obj = g_object_steal_data(
1038     G_OBJECT(renderer),
1039     "inf-gtk-permissions-dialog-path"
1040   );
1041   g_assert(strcmp(path_str_obj, path_str) == 0);
1042   g_free(path_str_obj);
1043   path = gtk_tree_path_new_from_string(path_str);
1044   has_path = gtk_tree_model_get_iter(
1045     GTK_TREE_MODEL(priv-&gt;account_store),
1046     &amp;view_iter,
1047     path
1048   );
1049   g_assert(has_path);
1050   gtk_tree_path_free(path);
1051   pending = inf_gtk_permissions_dialog_find_pending_sheet(dialog, &amp;view_iter);
1052   g_assert(pending != NULL);
1053   g_object_get(G_OBJECT(renderer), "model", &amp;model, NULL);
1054   g_object_set(
1055     G_OBJECT(priv-&gt;renderer),
1056     "model", NULL,
1057     "editable", FALSE,
1058     NULL
1059   );
1060   g_assert(model != NULL);
1061   if(gtk_tree_model_iter_n_children(model, NULL) &gt; 0)
1062   {
1063     g_assert(pending-&gt;last_combo_changed_id != 0);
1064     inf_gtk_permissions_dialog_realize_pending_sheet(
1065       dialog,
1066       pending,
1067       pending-&gt;last_combo_changed_id,
1068       text
1069     );
1070   }
1071   else
1072   {
1073     gtk_list_store_set(
1074       priv-&gt;account_store,
1075       &amp;view_iter,
1076       INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1077       text,
1078       -1
1079     );
1080     request = inf_browser_lookup_acl_account_by_name(
1081       priv-&gt;browser,
1082       text,
1083       inf_gtk_permissions_dialog_lookup_by_name_finished_cb,
1084       pending
1085     );
1086     if(request != NULL)
1087     {
1088       pending-&gt;lookup_request = request;
1089       g_object_ref(request);
1090     }
1091   }
1092   g_object_unref(model);
1093 }
1094 static void
1095 inf_gtk_permissions_dialog_add_clicked_cb(GtkButton* button,
1096                                           gpointer user_data)
1097 {
1098   InfGtkPermissionsDialog* dialog;
1099   InfGtkPermissionsDialogPrivate* priv;
1100   GtkTreeIter new_iter;
1101   GtkTreePath* new_path;
1102   InfGtkPermissionsDialogPendingSheet* pending;
1103   GtkListStore* store;
1104   const InfAclSheetSet* sheet_set;
1105   const InfAclSheet* sheet;
1106   guint i;
1107   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1108   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1109   gtk_cell_renderer_stop_editing(priv-&gt;renderer, TRUE);
1110   gtk_list_store_insert_with_values(
1111     priv-&gt;account_store,
1112     &amp;new_iter,
1113     -1,
1114     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1115     0,
1116     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1117     NULL,
1118     -1
1119   );
1120   new_path = gtk_tree_model_get_path(
1121     GTK_TREE_MODEL(priv-&gt;account_store),
1122     &amp;new_iter
1123   );
1124   pending = g_slice_new(InfGtkPermissionsDialogPendingSheet);
1125   pending-&gt;dialog = dialog;
1126   pending-&gt;row = gtk_tree_row_reference_new(
1127     GTK_TREE_MODEL(priv-&gt;account_store),
1128     new_path
1129   );
1130   pending-&gt;sheet.account = 0;
1131   inf_acl_mask_clear(&amp;pending-&gt;sheet.mask);
1132   inf_acl_mask_clear(&amp;pending-&gt;sheet.perms);
1133   pending-&gt;last_combo_changed_id = 0;
1134   pending-&gt;lookup_request = NULL;
1135   priv-&gt;pending_sheets = g_slist_prepend(priv-&gt;pending_sheets, pending);
1136   store = gtk_list_store_new(2, G_TYPE_POINTER, G_TYPE_STRING);
1137   g_object_set(
1138     G_OBJECT(priv-&gt;renderer),
1139     "model", store,
1140     "editable", TRUE,
1141     "text-column", INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1142     NULL
1143   );
1144   if(priv-&gt;accounts != NULL)
1145   {
1146     g_object_set(G_OBJECT(priv-&gt;renderer), "has-entry", FALSE, NULL);
1147     sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1148     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
1149     {
1150       if(priv-&gt;accounts[i].name != NULL)
1151       {
1152         sheet = NULL;
1153         if(sheet_set != NULL)
1154         {
1155           sheet = inf_acl_sheet_set_find_const_sheet(
1156             sheet_set,
1157             priv-&gt;accounts[i].id
1158           );
1159         }
1160         if(sheet == NULL)
1161         {
1162           gtk_list_store_insert_with_values(
1163             store,
1164             NULL,
1165             -1,
1166             INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1167             priv-&gt;accounts[i].id,
1168             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1169             priv-&gt;accounts[i].name,
1170             -1
1171           );
1172         }
1173       }
1174     }
1175     g_assert(gtk_tree_model_iter_n_children(GTK_TREE_MODEL(store), NULL) &gt; 0);
1176   }
1177   else
1178   {
1179     g_object_set(G_OBJECT(priv-&gt;renderer), "has-entry", TRUE, NULL);
1180   }
1181   gtk_tree_sortable_set_sort_column_id(
1182     GTK_TREE_SORTABLE(store),
1183     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1184     GTK_SORT_ASCENDING
1185   );
1186   gtk_tree_sortable_set_sort_func(
1187     GTK_TREE_SORTABLE(store),
1188     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1189     inf_gtk_permissions_dialog_account_sort_func,
1190     dialog,
1191     NULL
1192   );
1193   g_object_unref(store);
1194   gtk_tree_selection_select_path(
1195     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
1196     new_path
1197   );
1198   gtk_tree_path_free(new_path);
1199   new_path = gtk_tree_row_reference_get_path(pending-&gt;row);
1200   gtk_tree_view_set_cursor(
1201     GTK_TREE_VIEW(priv-&gt;tree_view),
1202     new_path,
1203     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
1204     TRUE
1205   );
1206   gtk_tree_path_free(new_path);
1207 }
1208 static void
1209 inf_gtk_permissions_dialog_remove_clicked_cb(GtkButton* button,
1210                                              gpointer user_data)
1211 {
1212   InfGtkPermissionsDialog* dialog;
1213   InfGtkPermissionsDialogPrivate* priv;
1214   GtkTreeSelection* selection;
1215   GtkTreeIter selected_iter;
1216   gpointer selected_id_ptr;
1217   InfAclAccountId selected_id;
1218   InfGtkPermissionsDialogPendingSheet* pending;
1219   const InfAclSheetSet* sheet_set;
1220   InfAclSheet set_sheet;
1221   InfAclSheetSet set_sheet_set;
1222   guint i;
1223   InfRequest* request;
1224   GtkTreeIter move_iter;
1225   gboolean could_move;
1226   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1227   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1228   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1229   if(!gtk_tree_selection_get_selected(selection, NULL, &amp;selected_iter))
1230     return;
1231   gtk_tree_model_get(
1232     GTK_TREE_MODEL(priv-&gt;account_store),
1233     &amp;selected_iter,
1234     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1235     &amp;selected_id_ptr,
1236     -1
1237   );
1238   selected_id = INF_ACL_ACCOUNT_POINTER_TO_ID(selected_id_ptr);
1239   sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1240   if(selected_id == 0)
1241   {
1242     pending = inf_gtk_permissions_dialog_find_pending_sheet(
1243       dialog,
1244       &amp;selected_iter
1245     );
1246     g_assert(pending != NULL);
1247     inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
1248   }
1249   else if(sheet_set == NULL || sheet_set-&gt;n_sheets == 0)
1250   {
1251     gtk_list_store_remove(priv-&gt;account_store, &amp;selected_iter);
1252   }
1253   else
1254   {
1255     set_sheet.account = selected_id;
1256     inf_acl_mask_clear(&amp;set_sheet.mask);
1257     inf_acl_mask_clear(&amp;set_sheet.perms);
1258     set_sheet_set.n_sheets = 1;
1259     set_sheet_set.own_sheets = NULL;
1260     set_sheet_set.sheets = &amp;set_sheet;
1261     request = inf_browser_set_acl(
1262       priv-&gt;browser,
1263       &amp;priv-&gt;browser_iter,
1264       &amp;set_sheet_set,
1265       inf_gtk_permissions_dialog_set_acl_finished_cb,
1266       dialog
1267     );
1268     if(request != NULL)
1269     {
1270       priv-&gt;set_acl_requests =
1271         g_slist_prepend(priv-&gt;set_acl_requests, request);
1272       g_object_ref(request);
1273     }
1274     move_iter = selected_iter;
1275     could_move = gtk_tree_model_iter_next(
1276       GTK_TREE_MODEL(priv-&gt;account_store),
1277       &amp;move_iter
1278     );
1279     if(!could_move)
1280     {
1281       move_iter = selected_iter;
1282       could_move = gtk_tree_model_iter_previous(
1283         GTK_TREE_MODEL(priv-&gt;account_store),
1284         &amp;move_iter
1285       );
1286     }
1287     g_assert(could_move);
1288     gtk_tree_selection_select_iter(
1289       GTK_TREE_SELECTION(selection),
1290       &amp;move_iter
1291     );
1292   }
1293 }
1294 static void
1295 inf_gtk_permissions_dialog_remove_acl_account_finished_cb(
1296   InfRequest* request,
1297   const InfRequestResult* result,
1298   const GError* error,
1299   gpointer user_data);
1300 static void
1301 inf_gtk_permissions_dialog_remove_remove_acl_account_request(
1302   InfGtkPermissionsDialog* dialog,
1303   InfRequest* request)
1304 {
1305   InfGtkPermissionsDialogPrivate* priv;
1306   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1307   g_assert(g_slist_find(priv-&gt;remove_acl_account_requests, request) != NULL);
1308   g_signal_handlers_disconnect_by_func(
1309     request,
1310     G_CALLBACK(inf_gtk_permissions_dialog_remove_acl_account_finished_cb),
1311     dialog
1312   );
1313   priv-&gt;remove_acl_account_requests =
1314     g_slist_remove(priv-&gt;remove_acl_account_requests, request);
1315   g_object_unref(request);
1316 }
1317 static void
1318 inf_gtk_permissions_dialog_remove_acl_account_finished_cb(
1319   InfRequest* request,
1320   const InfRequestResult* result,
1321   const GError* error,
1322   gpointer user_data)
1323 {
1324   InfGtkPermissionsDialog* dialog;
1325   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1326   if(error != NULL)
1327   {
1328     g_warning("Failed to remove account: %s\n", error-&gt;message);
1329   }
1330   inf_gtk_permissions_dialog_remove_remove_acl_account_request(
1331     dialog,
1332     request
1333   );
1334 }
1335 static void
1336 inf_gtk_permissions_dialog_popup_delete_account_cb(GtkMenuItem* item,
1337                                                    gpointer user_data)
1338 {
1339   InfGtkPermissionsDialog* dialog;
1340   InfGtkPermissionsDialogPrivate* priv;
1341   InfRequest* request;
1342   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1343   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1344   g_assert(priv-&gt;popup_menu != NULL);
1345   g_assert(priv-&gt;popup_account != 0);
1346   request = inf_browser_remove_acl_account(
1347     priv-&gt;browser,
1348     priv-&gt;popup_account,
1349     inf_gtk_permissions_dialog_remove_acl_account_finished_cb,
1350     dialog
1351   );
1352   if(request != NULL)
1353   {
1354     g_object_ref(request);
1355     priv-&gt;remove_acl_account_requests = g_slist_prepend(
1356       priv-&gt;remove_acl_account_requests,
1357       request
1358     );
1359   }
1360 }
1361 static gboolean
1362 inf_gtk_permissions_dialog_populate_popup(InfGtkPermissionsDialog* dialog,
1363                                           GtkMenu* menu)
1364 {
1365   InfGtkPermissionsDialogPrivate* priv;
1366   GtkWidget* item;
1367   InfBrowserIter root;
1368   InfAclMask perms;
1369   guint n_accounts;
1370   InfAclAccountId default_id;
1371   const InfAclAccount* local_account;
1372   const InfAclAccount** accounts;
1373   gpointer account_id_ptr;
1374   InfAclAccountId account_id;
1375   GtkTreeSelection* selection;
1376   GtkTreeIter iter;
1377   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1378   g_assert(priv-&gt;popup_menu == NULL);
1379   inf_browser_get_root(priv-&gt;browser, &amp;root);
1380   inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_REMOVE_ACCOUNT);
1381   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
1382   inf_browser_check_acl(
1383     priv-&gt;browser,
1384     &amp;root,
1385     local_account ? local_account-&gt;id : 0,
1386     &amp;perms,
1387     &amp;perms
1388   );
1389   if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_REMOVE_ACCOUNT))
1390     return FALSE;
1391   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1392   if(!gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
1393     return FALSE;
1394   gtk_tree_model_get(
1395     GTK_TREE_MODEL(priv-&gt;account_store),
1396     &amp;iter,
1397     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1398     &amp;account_id_ptr,
1399     -1
1400   );
1401   account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
1402   default_id = inf_acl_account_id_from_string("default");
1403   if(account_id == 0 || account_id == default_id)
1404     return FALSE;
1405   item = gtk_menu_item_new_with_mnemonic(_("_Delete Account"));
1406   g_signal_connect(
1407     G_OBJECT(item),
1408     "activate",
1409     G_CALLBACK(inf_gtk_permissions_dialog_popup_delete_account_cb),
1410     dialog
1411   );
1412   gtk_widget_show(item);
1413   gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
1414   priv-&gt;popup_menu = menu;
1415   priv-&gt;popup_account = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id);
1416   return TRUE;
1417 }
1418 static void
1419 inf_gtk_permissions_dialog_popup_menu_detach_func(GtkWidget* attach_widget,
1420                                                   GtkMenu* menu)
1421 {
1422 }
1423 static void
1424 inf_gtk_permissions_dialog_popup_menu_position_func(GtkMenu* menu,
1425                                                     gint* x,
1426                                                     gint* y,
1427                                                     gboolean* push_in,
1428                                                     gpointer user_data)
1429 {
1430   InfGtkPermissionsDialog* dialog;
1431   InfGtkPermissionsDialogPrivate* priv;
1432   GdkWindow* bin_window;
1433   GdkScreen* screen;
1434   GtkRequisition menu_req;
1435   GdkRectangle monitor;
1436   gint monitor_num;
1437   gint orig_x;
1438   gint orig_y;
1439   gint height;
1440   GtkTreeSelection* selection;
1441   GtkTreeModel* model;
1442   GtkTreeIter selected_iter;
1443   GtkTreePath* selected_path;
1444   GdkRectangle cell_area;
1445   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1446   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1447   bin_window = gtk_tree_view_get_bin_window(GTK_TREE_VIEW(priv-&gt;tree_view));
1448   gdk_window_get_origin(bin_window, &amp;orig_x, &amp;orig_y);
1449   screen = gtk_widget_get_screen(GTK_WIDGET(priv-&gt;tree_view));
1450   monitor_num = gdk_screen_get_monitor_at_window(screen, bin_window);
1451   if(monitor_num &lt; 0) monitor_num = 0;
1452   gtk_menu_set_monitor(menu, monitor_num);
1453   gdk_screen_get_monitor_geometry(screen, monitor_num, &amp;monitor);
1454   gtk_widget_get_preferred_size(GTK_WIDGET(menu), NULL, &amp;menu_req);
1455   height = gdk_window_get_height(bin_window);
1456   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1457   gtk_tree_selection_get_selected(selection, &amp;model, &amp;selected_iter);
1458   selected_path = gtk_tree_model_get_path(model, &amp;selected_iter);
1459   gtk_tree_view_get_cell_area(
1460     GTK_TREE_VIEW(priv-&gt;tree_view),
1461     selected_path,
1462     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
1463     &amp;cell_area
1464   );
1465   gtk_tree_path_free(selected_path);
1466   g_assert(cell_area.height &gt; 0);
1467   if(gtk_widget_get_direction(GTK_WIDGET(priv-&gt;tree_view)) ==
1468      GTK_TEXT_DIR_LTR)
1469   {
1470     *x = orig_x + cell_area.x + cell_area.width - menu_req.width;
1471   }
1472   else
1473   {
1474     *x = orig_x + cell_area.x;
1475   }
1476   *y = orig_y + cell_area.y + cell_area.height;
1477   if(*y &lt; orig_y)
1478     *y = orig_y;
1479   if(*y &gt; orig_y + height)
1480     *y = orig_y + height;
1481   if(*y + menu_req.height &gt; monitor.y + monitor.height)
1482     *y = monitor.y + monitor.height - menu_req.height;
1483   if(*y &lt; monitor.y)
1484     *y = monitor.y;
1485   *push_in = FALSE;
1486 }
1487 static void
1488 inf_gtk_permissions_dialog_popup_selection_done_cb(GtkMenu* menu,
1489                                                    gpointer user_data)
1490 {
1491   InfGtkPermissionsDialog* dialog;
1492   InfGtkPermissionsDialogPrivate* priv;
1493   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1494   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1495   g_assert(priv-&gt;popup_menu != NULL);
1496   priv-&gt;popup_menu = NULL;
1497   priv-&gt;popup_account = 0;
1498 }
1499 static gboolean
1500 inf_gtk_permissions_dialog_show_popup(InfGtkPermissionsDialog* dialog,
1501                                       guint button,                                       guint32 time)
1502 {
1503   InfGtkPermissionsDialogPrivate* priv;
1504   GtkWidget* menu;
1505   gboolean result;
1506   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1507   menu = gtk_menu_new();
1508   g_signal_connect(
1509     G_OBJECT(menu),
1510     "selection-done",
1511     G_CALLBACK(inf_gtk_permissions_dialog_popup_selection_done_cb),
1512     dialog
1513   );
1514   gtk_menu_attach_to_widget(
1515     GTK_MENU(menu),
1516     GTK_WIDGET(priv-&gt;tree_view),
1517     inf_gtk_permissions_dialog_popup_menu_detach_func
1518   );
1519   if(inf_gtk_permissions_dialog_populate_popup(dialog, GTK_MENU(menu)))
1520   {
1521     result = TRUE;
1522     if(button)
1523     {
1524       gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, button, time);
1525     }
1526     else
1527     {
1528       gtk_menu_popup(
1529         GTK_MENU(menu),
1530         NULL,
1531         NULL,
1532         inf_gtk_permissions_dialog_popup_menu_position_func,
1533         priv-&gt;tree_view,
1534         button,
1535         time
1536       );
1537       gtk_menu_shell_select_first(GTK_MENU_SHELL(menu), FALSE);
1538     }
1539   }
1540   else
1541   {
1542     result = FALSE;
1543     gtk_widget_destroy(menu);
1544   }
1545   return result;
1546 }
1547 static gboolean
1548 inf_gtk_permissions_dialog_button_press_event_cb(GtkWidget* treeview,
1549                                                  GdkEventButton* event,
1550                                                  gpointer user_data)
1551 {
1552   InfGtkPermissionsDialog* dialog;
1553   GtkTreePath* path;
1554   gboolean has_path;
1555   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1556   if(event-&gt;button == 3 &amp;&amp;
1557      event-&gt;window == gtk_tree_view_get_bin_window(GTK_TREE_VIEW(treeview)))
1558   {
1559     has_path = gtk_tree_view_get_path_at_pos(
1560       GTK_TREE_VIEW(treeview),
1561       event-&gt;x,
1562       event-&gt;y,
1563       &amp;path,
1564       NULL,
1565       NULL,
1566       NULL
1567     );
1568     if(has_path)
1569     {
1570       gtk_tree_selection_select_path(
1571         gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview)),
1572         path
1573       );
1574       gtk_tree_path_free(path);
1575       return inf_gtk_permissions_dialog_show_popup(
1576         dialog,
1577         event-&gt;button,
1578         event-&gt;time
1579       );
1580     }
1581   }
1582   return FALSE;
1583 }
1584 static gboolean
1585 inf_gtk_permissions_dialog_key_press_event_cb(GtkWidget* treeview,
1586                                               GdkEventKey* event,
1587                                               gpointer user_data)
1588 {
1589   InfGtkPermissionsDialog* dialog;
1590   GtkTreeSelection* selection;
1591   GtkTreeIter iter;
1592   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1593   if(event-&gt;keyval == GDK_KEY_Menu)
1594   {
1595     selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(treeview));
1596     if(gtk_tree_selection_get_selected(selection, NULL, &amp;iter))
1597     {
1598       return inf_gtk_permissions_dialog_show_popup(dialog, 0, event-&gt;time);
1599     }
1600   }
1601   return FALSE;
1602 }
1603 static void
1604 inf_gtk_permissions_dialog_name_data_func(GtkTreeViewColumn* column,
1605                                           GtkCellRenderer* cell,
1606                                           GtkTreeModel* model,
1607                                           GtkTreeIter* iter,
1608                                           gpointer user_data)
1609 {
1610   gpointer account_id_ptr;
1611   InfAclAccountId account_id;
1612   const gchar* account_id_str;
1613   InfAclAccountId default_id;
1614   gchar* account_name;
1615   gchar* str;
1616   gtk_tree_model_get(
1617     model,
1618     iter,
1619     INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID, &amp;account_id_ptr,
1620     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME, &amp;account_name,
1621     -1
1622   );
1623   account_id = INF_ACL_ACCOUNT_POINTER_TO_ID(account_id_ptr);
1624   account_id_str = inf_acl_account_id_to_string(account_id);
1625   if(account_name != NULL)
1626   {
1627     g_object_set(G_OBJECT(cell), "text", account_name, NULL);
1628   }
1629   else if(account_id_str != NULL)
1630   {
1631     str = g_strdup_printf("&lt;%s&gt;", account_id_str);
1632     g_object_set(G_OBJECT(cell), "text", str, NULL);
1633     g_free(str);
1634   }
1635   else
1636   {
1637     g_object_set(G_OBJECT(cell), "text", "", NULL);
1638   }
1639   default_id = inf_acl_account_id_from_string("default");
1640   if( (account_id == 0 || account_name == NULL) &amp;&amp; account_id != default_id)
1641     g_object_set(G_OBJECT(cell), "foreground", "red", NULL);
1642   else
1643     g_object_set(G_OBJECT(cell), "foreground-set", FALSE, NULL);
1644   g_free(account_name);
1645 }
1646 static void
1647 inf_gtk_permissions_dialog_query_acl_account_list_finished_cb(
1648   InfRequest* request,
1649   const InfRequestResult* res,
1650   const GError* error,
1651   gpointer user_data)
1652 {
1653   InfGtkPermissionsDialog* dialog;
1654   InfGtkPermissionsDialogPrivate* priv;
1655   const InfAclAccount* accounts;
1656   guint n_accounts;
1657   guint i;
1658   InfAclAccountId account_id;
1659   GtkTreeIter iter;
1660   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1661   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1662   priv-&gt;query_acl_account_list_request = NULL;
1663   priv-&gt;account_list_queried = TRUE;
1664   if(error != NULL)
1665   {
1666     if(error-&gt;domain != inf_directory_error_quark() ||
1667        error-&gt;code != INF_DIRECTORY_ERROR_OPERATION_UNSUPPORTED)
1668     {
1669       g_warning("Error while querying account list: %s\n", error-&gt;message);
1670     }
1671   }
1672   else
1673   {
1674     inf_request_result_get_query_acl_account_list(
1675       res,
1676       NULL,
1677       &amp;accounts,
1678       &amp;n_accounts,
1679       NULL
1680     );
1681     for(i = 0; i &lt; n_accounts; ++i)
1682     {
1683       if(accounts[i].name != NULL)
1684       {
1685         account_id = accounts[i].id;
1686         if(inf_gtk_permissions_dialog_find_account(dialog, account_id, &amp;iter))
1687         {
1688           gtk_list_store_set(
1689             GTK_LIST_STORE(priv-&gt;account_store),
1690             &amp;iter,
1691             INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
1692             accounts[i].name,
1693             -1
1694           );
1695         }
1696       }
1697     }
1698     for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
1699       g_free(priv-&gt;accounts[i].name);
1700     priv-&gt;accounts = g_realloc(
1701       priv-&gt;accounts,
1702       n_accounts * sizeof(InfAclAccount)
1703     );
1704     for(i = 0; i &lt; n_accounts; ++i)
1705     {
1706       priv-&gt;accounts[i].id = accounts[i].id;
1707       priv-&gt;accounts[i].name = g_strdup(accounts[i].name);
1708     }
1709     priv-&gt;n_accounts = n_accounts;
1710   }
1711 }
1712 static void
1713 inf_gtk_permissions_dialog_query_acl_finished_cb(InfRequest* request,
1714                                                  const InfRequestResult* res,
1715                                                  const GError* error,
1716                                                  gpointer user_data)
1717 {
1718   InfGtkPermissionsDialog* dialog;
1719   InfGtkPermissionsDialogPrivate* priv;
1720   dialog = INF_GTK_PERMISSIONS_DIALOG(user_data);
1721   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1722   priv-&gt;query_acl_request = NULL;
1723   inf_gtk_permissions_dialog_update(dialog, error);
1724 }
1725 static void
1726 inf_gtk_permissions_dialog_update(InfGtkPermissionsDialog* dialog,
1727                                   const GError* error)
1728 {
1729   InfGtkPermissionsDialogPrivate* priv;
1730   gchar* path;
1731   gchar* title;
1732   InfAclMask perms;
1733   GArray* accounts;
1734   const InfAclAccount* local_account;
1735   const InfAclSheetSet* sheet_set;
1736   gboolean has_default;
1737   InfAclAccountId default_id;
1738   guint i;
1739   GtkTreeSelection* selection;
1740   GtkTreeIter selected_iter;
1741   gpointer selected_id_ptr;
1742   GtkTreePath* selected_path;
1743   InfAclAccountId selected_id;
1744   gboolean has_selected;
1745   GSList* item;
1746   InfGtkPermissionsDialogPendingSheet* pending;
1747   GtkTreePath* pending_path;
1748   const gchar* query_acl_str;
1749   const gchar* set_acl_str;
1750   gchar* error_str;
1751   gchar* str;
1752   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1753   if(priv-&gt;browser == NULL)
1754   {
1755     gtk_list_store_clear(priv-&gt;account_store);
1756     gtk_label_set_text(GTK_LABEL(priv-&gt;status_text), _("No node selected"));
1757     return;
1758   }
1759   path = inf_browser_get_path(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1760   title = g_strdup_printf(_("Permissions for %s"), path);
1761   gtk_window_set_title(GTK_WINDOW(dialog), title);
1762   g_free(path);
1763   g_free(title);
1764   inf_acl_mask_set1(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST);
1765   inf_acl_mask_or1(&amp;perms, INF_ACL_CAN_QUERY_ACL);
1766   inf_acl_mask_or1(&amp;perms, INF_ACL_CAN_SET_ACL);
1767   local_account = inf_browser_get_acl_local_account(priv-&gt;browser);
1768   inf_browser_check_acl(
1769     priv-&gt;browser,
1770     &amp;priv-&gt;browser_iter,
1771     local_account ? local_account-&gt;id : 0,
1772     &amp;perms,
1773     &amp;perms
1774   );
1775   if(priv-&gt;query_acl_account_list_request == NULL &amp;&amp;
1776      priv-&gt;account_list_queried == FALSE)
1777   {
1778     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACCOUNT_LIST) &amp;&amp;
1779        inf_acl_mask_has(&amp;perms, INF_ACL_CAN_SET_ACL))
1780     {
1781       priv-&gt;query_acl_account_list_request = inf_browser_get_pending_request(
1782         priv-&gt;browser,
1783         NULL,
1784         "query-acl-account-list"
1785       );
1786       if(priv-&gt;query_acl_account_list_request == NULL)
1787       {
1788         priv-&gt;query_acl_account_list_request =
1789           inf_browser_query_acl_account_list(
1790             priv-&gt;browser,
1791             inf_gtk_permissions_dialog_query_acl_account_list_finished_cb,
1792             dialog
1793           );
1794       }
1795       else
1796       {
1797         g_signal_connect(
1798           G_OBJECT(priv-&gt;query_acl_account_list_request),
1799           "finished",
1800           G_CALLBACK(
1801             inf_gtk_permissions_dialog_query_acl_account_list_finished_cb
1802           ),
1803           dialog
1804         );
1805       }
1806     }
1807   }
1808   if(!inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1809   {
1810     if(inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACL) &amp;&amp;
1811        priv-&gt;query_acl_request == NULL &amp;&amp; error == NULL)
1812     {
1813       priv-&gt;query_acl_request = inf_browser_get_pending_request(
1814         priv-&gt;browser,
1815         &amp;priv-&gt;browser_iter,
1816         "query-acl"
1817       );
1818       if(priv-&gt;query_acl_request == NULL)
1819       {
1820         priv-&gt;query_acl_request = inf_browser_query_acl(
1821           priv-&gt;browser,
1822           &amp;priv-&gt;browser_iter,
1823           inf_gtk_permissions_dialog_query_acl_finished_cb,
1824           dialog
1825         );
1826       }
1827       else
1828       {
1829         g_signal_connect(
1830           G_OBJECT(priv-&gt;query_acl_request),
1831           "finished",
1832           G_CALLBACK(inf_gtk_permissions_dialog_query_acl_finished_cb),
1833           dialog
1834         );
1835       }
1836     }
1837   }
1838   accounts = g_array_new(FALSE, FALSE, sizeof(InfAclAccountId));
1839   sheet_set = inf_browser_get_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter);
1840   default_id = inf_acl_account_id_from_string("default");
1841   selected_id = 0;
1842   selected_path = NULL;
1843   selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view));
1844   if(gtk_tree_selection_get_selected(selection, NULL, &amp;selected_iter))
1845   {
1846     gtk_tree_model_get(
1847       GTK_TREE_MODEL(priv-&gt;account_store),
1848       &amp;selected_iter,
1849       INF_GTK_PERMISSIONS_DIALOG_COLUMN_ID,
1850       &amp;selected_id_ptr,
1851       -1
1852     );
1853     selected_id = INF_ACL_ACCOUNT_POINTER_TO_ID(selected_id_ptr);
1854     selected_path = gtk_tree_model_get_path(
1855       GTK_TREE_MODEL(priv-&gt;account_store),
1856       &amp;selected_iter
1857     );
1858   }
1859   has_default = FALSE;
1860   has_selected = FALSE;
1861   if(sheet_set != NULL)
1862   {
1863     for(i = 0; i &lt; sheet_set-&gt;n_sheets; ++i)
1864     {
1865       g_array_append_val(accounts, sheet_set-&gt;sheets[i].account);
1866       if(sheet_set-&gt;sheets[i].account == default_id)
1867         has_default = TRUE;
1868       if(sheet_set-&gt;sheets[i].account == selected_id)
1869         has_selected = TRUE;
1870     }
1871   }
1872   if(has_default == FALSE)
1873     g_array_append_val(accounts, default_id);
1874   if(selected_id != 0 &amp;&amp; selected_id != default_id &amp;&amp; has_selected == FALSE)
1875     g_array_append_val(accounts, selected_id);
1876   for(item = priv-&gt;pending_sheets; item != NULL; item = item-&gt;next)
1877   {
1878     pending = (InfGtkPermissionsDialogPendingSheet*)item-&gt;data;
1879     if(inf_acl_mask_empty(&amp;pending-&gt;sheet.mask))
1880     {
1881       pending_path = gtk_tree_row_reference_get_path(pending-&gt;row);
1882       g_assert(pending_path != NULL);
1883       if(selected_path == NULL ||
1884          gtk_tree_path_compare(pending_path, selected_path) != 0)
1885       {
1886         gtk_tree_path_free(pending_path);
1887         inf_gtk_permissions_dialog_remove_pending_sheet(dialog, pending);
1888         break;
1889       }
1890       gtk_tree_path_free(pending_path);
1891     }
1892   }
1893   if(selected_path != NULL)
1894     gtk_tree_path_free(selected_path);
1895   inf_gtk_permissions_dialog_fill_account_list(
1896     dialog,
1897     (InfAclAccountId*)accounts-&gt;data,
1898     accounts-&gt;len
1899   );
1900   if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_SET_ACL) ||
1901      !inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1902   {
1903     inf_gtk_acl_sheet_view_set_editable(
1904       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
1905       FALSE
1906     );
1907     gtk_widget_set_sensitive(priv-&gt;add_button, FALSE);
1908     gtk_widget_set_sensitive(priv-&gt;remove_button, FALSE);
1909     set_acl_str = _("Permission is &lt;b&gt;not granted&lt;/b&gt; to modify the permission list. It is read-only.");
1910   }
1911   else
1912   {
1913     inf_gtk_acl_sheet_view_set_editable(
1914       INF_GTK_ACL_SHEET_VIEW(priv-&gt;sheet_view),
1915       TRUE
1916     );
1917     if(priv-&gt;accounts == NULL || accounts-&gt;len &lt; priv-&gt;n_accounts)
1918       gtk_widget_set_sensitive(priv-&gt;add_button, TRUE);
1919     else
1920       gtk_widget_set_sensitive(priv-&gt;add_button, FALSE);
1921     if(selected_id != default_id)
1922       gtk_widget_set_sensitive(priv-&gt;remove_button, TRUE);
1923     else
1924       gtk_widget_set_sensitive(priv-&gt;remove_button, FALSE);
1925     set_acl_str = _("Permission is &lt;b&gt;granted&lt;/b&gt; to modify the permission list.");
1926   }
1927   g_array_free(accounts, TRUE);
1928   error_str = NULL;
1929   if(error != NULL)
1930   {
1931     error_str = g_markup_printf_escaped(
1932       _("&lt;b&gt;Server Error:&lt;/b&gt; %s"),
1933       error-&gt;message
1934     );
1935     query_acl_str = error_str;
1936   }
1937   else if(priv-&gt;query_acl_request != NULL)
1938   {
1939     query_acl_str = _("Querying current permissions for "
1940                       "this node from the server...");
1941   }
1942   else if(!inf_acl_mask_has(&amp;perms, INF_ACL_CAN_QUERY_ACL) &amp;&amp;
1943           !inf_browser_has_acl(priv-&gt;browser, &amp;priv-&gt;browser_iter, 0))
1944   {
1945     query_acl_str = _("Permission is &lt;b&gt;not granted&lt;/b&gt; to query the "
1946                       "permission list for this node from the server. "
1947                       "Showing only default permissions and permissions "
1948                       "for the own account.");
1949   }
1950   else
1951   {
1952     query_acl_str = _("Permissions are &lt;b&gt;granted&lt;/b&gt; to query the full "
1953                       "permission list from the server. "
1954                       "Showing all permissions.");
1955   }
1956   str = g_strdup_printf("%s\n\n%s", query_acl_str, set_acl_str);
1957   g_free(error_str);
1958   gtk_label_set_markup(GTK_LABEL(priv-&gt;status_text), str);
1959   g_free(str);
1960 }
1961 static void
1962 inf_gtk_permissions_dialog_register(InfGtkPermissionsDialog* dialog)
1963 {
1964   InfGtkPermissionsDialogPrivate* priv;
1965   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1966   g_assert(priv-&gt;browser != NULL);
1967   g_signal_connect(
1968     priv-&gt;browser,
1969     "node-removed",
1970     G_CALLBACK(inf_gtk_permissions_dialog_node_removed_cb),
1971     dialog
1972   );
1973   g_signal_connect(
1974     priv-&gt;browser,
1975     "acl-account-added",
1976     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_added_cb),
1977     dialog
1978   );
1979   g_signal_connect(
1980     priv-&gt;browser,
1981     "acl-account-removed",
1982     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_removed_cb),
1983     dialog
1984   );
1985   g_signal_connect(
1986     priv-&gt;browser,
1987     "acl-changed",
1988     G_CALLBACK(inf_gtk_permissions_dialog_acl_changed_cb),
1989     dialog
1990   );
1991 }
1992 static void
1993 inf_gtk_permissions_dialog_unregister(InfGtkPermissionsDialog* dialog)
1994 {
1995   InfGtkPermissionsDialogPrivate* priv;
1996   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
1997   g_assert(priv-&gt;browser != NULL);
1998   inf_signal_handlers_disconnect_by_func(
1999     priv-&gt;browser,
2000     G_CALLBACK(inf_gtk_permissions_dialog_node_removed_cb),
2001     dialog
2002   );
2003   inf_signal_handlers_disconnect_by_func(
2004     priv-&gt;browser,
2005     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_added_cb),
2006     dialog
2007   );
2008   inf_signal_handlers_disconnect_by_func(
2009     priv-&gt;browser,
2010     G_CALLBACK(inf_gtk_permissions_dialog_acl_account_removed_cb),
2011     dialog
2012   );
2013   inf_signal_handlers_disconnect_by_func(
2014     priv-&gt;browser,
2015     G_CALLBACK(inf_gtk_permissions_dialog_acl_changed_cb),
2016     dialog
2017   );
2018 }
2019 static void
2020 inf_gtk_permissions_dialog_init(InfGtkPermissionsDialog* dialog)
2021 {
2022   InfGtkPermissionsDialogPrivate* priv;
2023   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2024   priv-&gt;query_acl_account_list_request = NULL;
2025   priv-&gt;account_list_queried = FALSE;
2026   priv-&gt;accounts = NULL;
2027   priv-&gt;n_accounts = 0;
2028   priv-&gt;query_acl_request = NULL;
2029   priv-&gt;set_acl_requests = NULL;
2030   priv-&gt;remove_acl_account_requests = NULL;
2031   priv-&gt;lookup_acl_account_requests = NULL;
2032   priv-&gt;pending_sheets = NULL;
2033   priv-&gt;popup_menu = NULL;
2034   priv-&gt;popup_account = 0;
2035   gtk_widget_init_template(GTK_WIDGET(dialog));
2036   gtk_tree_sortable_set_sort_column_id(
2037     GTK_TREE_SORTABLE(priv-&gt;account_store),
2038     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
2039     GTK_SORT_ASCENDING
2040   );
2041   gtk_tree_sortable_set_sort_func(
2042     GTK_TREE_SORTABLE(priv-&gt;account_store),
2043     INF_GTK_PERMISSIONS_DIALOG_COLUMN_NAME,
2044     inf_gtk_permissions_dialog_account_sort_func,
2045     dialog,
2046     NULL
2047   );
2048   gtk_tree_view_column_set_cell_data_func(
2049     gtk_tree_view_get_column(GTK_TREE_VIEW(priv-&gt;tree_view), 0),
2050     priv-&gt;renderer,
2051     inf_gtk_permissions_dialog_name_data_func,
2052     NULL,
2053     NULL
2054   );
2055 }
2056 static void
2057 inf_gtk_permissions_dialog_constructed(GObject* object)
2058 {
2059   InfGtkPermissionsDialogPrivate* priv;
2060   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;constructed(
2061     object
2062   );
2063   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(object);
2064   inf_gtk_permissions_dialog_update(
2065     INF_GTK_PERMISSIONS_DIALOG(object),
2066     NULL
2067   );
2068 }
2069 static void
2070 inf_gtk_permissions_dialog_dispose(GObject* object)
2071 {
2072   InfGtkPermissionsDialog* dialog;
2073   InfGtkPermissionsDialogPrivate* priv;
2074   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2075   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2076   while(priv-&gt;remove_acl_account_requests != NULL)
2077   {
2078     inf_gtk_permissions_dialog_remove_remove_acl_account_request(
2079       dialog,
2080       priv-&gt;remove_acl_account_requests-&gt;data
2081     );
2082   }
2083   while(priv-&gt;lookup_acl_account_requests != NULL)
2084   {
2085     inf_gtk_permissions_dialog_remove_lookup_acl_accounts_request(
2086       dialog,
2087       priv-&gt;lookup_acl_account_requests-&gt;data
2088     );
2089   }
2090   if(priv-&gt;browser != NULL)
2091   {
2092     inf_gtk_permissions_dialog_set_node(dialog, NULL, NULL);
2093   }
2094   g_assert(priv-&gt;set_acl_requests == NULL);
2095   g_assert(priv-&gt;pending_sheets == NULL);
2096   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;dispose(object);
2097 }
2098 static void
2099 inf_gtk_permissions_dialog_finalize(GObject* object)
2100 {
2101   InfGtkPermissionsDialog* dialog;
2102   InfGtkPermissionsDialogPrivate* priv;
2103   guint i;
2104 <a name="1"></a>  dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2105   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2106 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
2107     g_free(priv-&gt;accounts[i].name);
2108   g_free(priv-&gt;accounts);
2109   G_OBJECT_CLASS(inf_gtk_permissions_dialog_parent_class)-&gt;finalize(object);
2110 }
2111 static void
2112 inf_gtk_permissions_dialog_set_property(GObject* object,
2113                                         guint prop_id,
2114                                         const GValue* value,
2115                                         GParamSpec* pspec)
2116 {
2117   InfGtkPermissionsDialog* dialog;
2118   InfGtkPermissionsDialogPrivate* priv;
2119   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2120   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2121   switch(prop_id)
2122   {
2123   case PROP_BROWSER:
2124     g_assert(priv-&gt;browser == NULL);     priv-&gt;browser = INF_BROWSER(g_value_dup_object(value));</b></font>
2125     if(priv-&gt;browser != NULL)
2126       inf_gtk_permissions_dialog_register(dialog);
2127     break;
2128   case PROP_BROWSER_ITER:
2129     priv-&gt;browser_iter = *(InfBrowserIter*)g_value_get_boxed(value);
2130 <a name="0"></a>    break;
2131   default:
2132     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
2133 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
2134   }
2135 }
2136 static void
2137 inf_gtk_permissions_dialog_get_property(GObject* object,
2138                                         guint prop_id,
2139                                         GValue* value,
2140                                         GParamSpec* pspec)
2141 {
2142   InfGtkPermissionsDialog* dialog;
2143   InfGtkPermissionsDialogPrivate* priv;
2144   dialog = INF_GTK_PERMISSIONS_DIALOG(object);
2145   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2146   switch(prop_id)
2147   {
2148   case PROP_BROWSER:
2149     g_value_set_object(value, priv-&gt;browser);
2150     break;
2151   case PROP_BROWSER_ITER:
2152     g_value_set_boxed(value, &amp;priv-&gt;browser_iter);
2153     break;</b></font>
2154 <a name="3"></a>  default:
2155     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
2156     break;
2157 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  }
2158 }
2159 static void
2160 inf_gtk_permissions_dialog_class_init(
2161   InfGtkPermissionsDialogClass* permissions_dialog_class)
2162 {
2163   GObjectClass* object_class;
2164   object_class = G_OBJECT_CLASS(permissions_dialog_class);
2165   object_class-&gt;constructed = inf_gtk_permissions_dialog_constructed;
2166   object_class-&gt;dispose = inf_gtk_permissions_dialog_dispose;
2167   object_class-&gt;finalize = inf_gtk_permissions_dialog_finalize;
2168   object_class-&gt;set_property = inf_gtk_permissions_dialog_set_property;
2169   object_class-&gt;get_property = inf_gtk_permissions_dialog_get_property;
2170   gtk_widget_class_set_template_from_resource(
2171     GTK_WIDGET_CLASS(object_class),
2172     "/de/0x539/libinfgtk/ui/infgtkpermissionsdialog.ui"
2173   );
2174   gtk_widget_class_bind_template_child_private(
2175     GTK_WIDGET_CLASS(object_class),
2176     InfGtkPermissionsDialog,
2177     account_store
2178   );
2179   gtk_widget_class_bind_template_child_private(
2180     GTK_WIDGET_CLASS(object_class),
2181     InfGtkPermissionsDialog,
2182     status_text
2183   );
2184   gtk_widget_class_bind_template_child_private(
2185     GTK_WIDGET_CLASS(object_class),
2186     InfGtkPermissionsDialog,
2187     tree_view
2188   );
2189   gtk_widget_class_bind_template_child_private(
2190     GTK_WIDGET_CLASS(object_class),
2191     InfGtkPermissionsDialog,
2192     sheet_view
2193   );
2194   gtk_widget_class_bind_template_child_private(
2195     GTK_WIDGET_CLASS(object_class),
2196     InfGtkPermissionsDialog,
2197     add_button
2198   );
2199   gtk_widget_class_bind_template_child_private(
2200     GTK_WIDGET_CLASS(object_class),
2201     InfGtkPermissionsDialog,
2202     remove_button
2203   );
2204   gtk_widget_class_bind_template_child_private(
2205     GTK_WIDGET_CLASS(object_class),
2206     InfGtkPermissionsDialog,
2207     renderer
2208   );
2209   gtk_widget_class_bind_template_callback(
2210     GTK_WIDGET_CLASS(object_class),
2211     inf_gtk_permissions_dialog_key_press_event_cb
2212   );
2213   gtk_widget_class_bind_template_callback(
2214     GTK_WIDGET_CLASS(object_class),
2215     inf_gtk_permissions_dialog_button_press_event_cb
2216   );
2217   gtk_widget_class_bind_template_callback(
2218     GTK_WIDGET_CLASS(object_class),
2219     inf_gtk_permissions_dialog_selection_changed_cb
2220   );
2221   gtk_widget_class_bind_template_callback(
2222     GTK_WIDGET_CLASS(object_class),
2223     inf_gtk_permissions_dialog_renderer_editing_started_cb
2224   );
2225   gtk_widget_class_bind_template_callback(
2226     GTK_WIDGET_CLASS(object_class),
2227     inf_gtk_permissions_dialog_renderer_editing_canceled_cb
2228   );
2229   gtk_widget_class_bind_template_callback(
2230     GTK_WIDGET_CLASS(object_class),
2231     inf_gtk_permissions_dialog_renderer_edited_cb
2232   );
2233   gtk_widget_class_bind_template_callback(
2234     GTK_WIDGET_CLASS(object_class),
2235     inf_gtk_permissions_dialog_renderer_changed_cb
2236   );
2237   gtk_widget_class_bind_template_callback(
2238     GTK_WIDGET_CLASS(object_class),
2239     inf_gtk_permissions_dialog_add_clicked_cb
2240   );
2241   gtk_widget_class_bind_template_callback(
2242     GTK_WIDGET_CLASS(object_class),
2243     inf_gtk_permissions_dialog_remove_clicked_cb
2244   );
2245   gtk_widget_class_bind_template_callback(
2246     GTK_WIDGET_CLASS(object_class),
2247     inf_gtk_permissions_dialog_sheet_changed_cb
2248   );
2249   g_object_class_install_property(
2250     object_class,
2251     PROP_BROWSER,
2252     g_param_spec_object(
2253       "browser",
2254       "Browser",
2255       "The browser with the node for which to show the permissions",
2256       INF_TYPE_BROWSER,
2257       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
2258     )
2259   );
2260   g_object_class_install_property(
2261     object_class,
2262     PROP_BROWSER_ITER,
2263     g_param_spec_boxed(
2264       "browser-iter",
2265       "Browser Iter",
2266       "An iterator pointing to the node inside the browser for which to show "
2267       "the permissions",
2268       INF_TYPE_BROWSER_ITER,
2269       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
2270     )
2271   );
2272 }</b></font>
2273 InfGtkPermissionsDialog*
2274 inf_gtk_permissions_dialog_new(GtkWindow* parent,
2275                                GtkDialogFlags dialog_flags,
2276                                InfBrowser* browser,
2277                                const InfBrowserIter* iter)
2278 {
2279   GObject* object;
2280   g_return_val_if_fail(parent == NULL || GTK_IS_WINDOW(parent), NULL);
2281   g_return_val_if_fail(browser == NULL || INF_IS_BROWSER(browser), NULL);
2282   g_return_val_if_fail(browser == NULL || iter != NULL, NULL);
2283   object = g_object_new(
2284     INF_GTK_TYPE_PERMISSIONS_DIALOG,
2285     "browser", browser,
2286     "browser-iter", iter,
2287     NULL
2288   );
2289   if(dialog_flags &amp; GTK_DIALOG_MODAL)
2290     gtk_window_set_modal(GTK_WINDOW(object), TRUE);
2291   if(dialog_flags &amp; GTK_DIALOG_DESTROY_WITH_PARENT)
2292     gtk_window_set_destroy_with_parent(GTK_WINDOW(object), TRUE);
2293   gtk_window_set_transient_for(GTK_WINDOW(object), parent);
2294   return INF_GTK_PERMISSIONS_DIALOG(object);
2295 }
2296 void
2297 inf_gtk_permissions_dialog_set_node(InfGtkPermissionsDialog* dialog,
2298                                     InfBrowser* browser,
2299                                     const InfBrowserIter* iter)
2300 {
2301   InfGtkPermissionsDialogPrivate* priv;
2302   GSList* item;
2303   guint i;
2304   g_return_if_fail(INF_GTK_IS_PERMISSIONS_DIALOG(dialog));
2305   g_return_if_fail(browser == NULL || INF_IS_BROWSER(browser));
2306   g_return_if_fail((browser == NULL) == (iter == NULL));
2307   priv = INF_GTK_PERMISSIONS_DIALOG_PRIVATE(dialog);
2308   if(priv-&gt;popup_menu != NULL)
2309     gtk_menu_popdown(priv-&gt;popup_menu);
2310   if(priv-&gt;browser != NULL)
2311   {
2312     if(priv-&gt;query_acl_account_list_request != NULL)
2313     {
2314       inf_signal_handlers_disconnect_by_func(
2315         priv-&gt;query_acl_account_list_request,
2316         G_CALLBACK(
2317           inf_gtk_permissions_dialog_query_acl_account_list_finished_cb
2318         ),
2319         dialog
2320       );
2321       priv-&gt;query_acl_account_list_request = NULL;
2322     }
2323     if(priv-&gt;query_acl_request != NULL)
2324     {
2325       inf_signal_handlers_disconnect_by_func(
2326         priv-&gt;query_acl_request,
2327         G_CALLBACK(inf_gtk_permissions_dialog_query_acl_finished_cb),
2328         dialog
2329       );
2330       priv-&gt;query_acl_request = NULL;
2331     }
2332     for(item = priv-&gt;set_acl_requests; item != NULL; item = item-&gt;next)
2333     {
2334       inf_signal_handlers_disconnect_by_func(
2335         G_OBJECT(item-&gt;data),
2336         G_CALLBACK(inf_gtk_permissions_dialog_set_acl_finished_cb),
2337         dialog
2338       );
2339       g_object_unref(item-&gt;data);
2340     }
2341     g_slist_free(priv-&gt;set_acl_requests);
2342     priv-&gt;set_acl_requests = NULL;
2343     while(priv-&gt;pending_sheets != NULL)
2344     {
2345       inf_gtk_permissions_dialog_remove_pending_sheet(
2346         dialog,
2347         priv-&gt;pending_sheets-&gt;data
2348       );
2349     }
2350   }
2351   for(i = 0; i &lt; priv-&gt;n_accounts; ++i)
2352     g_free(priv-&gt;accounts[i].name);
2353   g_free(priv-&gt;accounts);
2354   priv-&gt;accounts = NULL;
2355   priv-&gt;n_accounts = 0;
2356   inf_signal_handlers_block_by_func(
2357     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
2358     G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
2359     dialog
2360   );
2361   gtk_list_store_clear(priv-&gt;account_store);
2362   inf_signal_handlers_unblock_by_func(
2363     gtk_tree_view_get_selection(GTK_TREE_VIEW(priv-&gt;tree_view)),
2364     G_CALLBACK(inf_gtk_permissions_dialog_selection_changed_cb),
2365     dialog
2366   );
2367   if(priv-&gt;browser != browser)
2368   {
2369     if(priv-&gt;browser != NULL)
2370     {
2371       inf_gtk_permissions_dialog_unregister(dialog);
2372       g_object_unref(priv-&gt;browser);
2373     }
2374     priv-&gt;browser = browser;
2375     if(iter != NULL)
2376       priv-&gt;browser_iter = *iter;
2377     if(priv-&gt;browser != NULL)
2378     {
2379       g_object_ref(priv-&gt;browser);
2380       inf_gtk_permissions_dialog_register(dialog);
2381     }
2382     g_object_notify(G_OBJECT(dialog), "browser");
2383     g_object_notify(G_OBJECT(dialog), "browser-iter");
2384   }
2385   inf_gtk_permissions_dialog_update(dialog, NULL);
2386 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
