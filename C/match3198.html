<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mmanon.c &amp; omstdout.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mmanon.c &amp; omstdout.c
      </h3>
<h1 align="center">
        2.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mmanon.c (1.6534392%)<th>omstdout.c (12.254902%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(126-133)<td><a href="#" name="0">(80-87)</a><td align="center"><font color="#ff0000">13</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(275-279)<td><a href="#" name="1">(265-268)</a><td align="center"><font color="#eb0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmanon.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include &lt;stdint.h&gt;
12 #include "conf.h"
13 #include "syslogd-types.h"
14 #include "srUtils.h"
15 #include "template.h"
16 #include "module-template.h"
17 #include "errmsg.h"
18 #include "parserif.h"
19 #include "hashtable.h"
20 MODULE_TYPE_OUTPUT
21 MODULE_TYPE_NOKEEP
22 MODULE_CNFNAME("mmanon")
23 DEF_OMOD_STATIC_DATA
24 enum mode {ZERO, RANDOMINT, SIMPLE};
25 union node {
26 	struct {
27 		union node* more;
28 		union node* less;
29 	} pointer;
30 	struct {
31 		char ip_high[16];
32 		char ip_low[16];
33 	} ips;
34 };
35 struct ipv6_int {
36 	unsigned long long high;
37 	unsigned long long low;
38 	};
39 #define SIMPLE_MODE 0	 #define REWRITE_MODE 1	 typedef struct _instanceData {
40 	struct {
41 		sbool enable;
42 		int8_t bits;
43 		union node* Root;
44 		int randConsis;
45 		enum mode mode;
46 		uchar replaceChar;
47 	} ipv4;
48 	struct {
49 		sbool enable;
50 		uint8_t bits;
51 		enum mode anonmode;
52 		int randConsis;
53 		struct hashtable* hash;
54 	} ipv6;
55 	struct {
56 		sbool enable;
57 		uint8_t bits;
58 		enum mode anonmode;
59 		int randConsis;
60 		struct hashtable* hash;
61 	} embeddedIPv4;
62 } instanceData;
63 typedef struct wrkrInstanceData {
64 	instanceData *pData;
65 	unsigned randstatus;
66 } wrkrInstanceData_t;
67 struct modConfData_s {
68 	rsconf_t *pConf;	};
69 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
70 static struct cnfparamdescr actpdescr[] = {
71 	{ "ipv4.enable", eCmdHdlrBinary, 0 },
72 	{ "ipv4.mode", eCmdHdlrGetWord, 0 },
73 	{ "mode", eCmdHdlrGetWord, 0 },
74 	{ "ipv4.bits", eCmdHdlrPositiveInt, 0 },
75 	{ "ipv4.replacechar", eCmdHdlrGetChar, 0},
76 	{ "replacementchar", eCmdHdlrGetChar, 0},
77 	{ "ipv6.enable", eCmdHdlrBinary, 0 },
78 <a name="0"></a>	{ "ipv6.anonmode", eCmdHdlrGetWord, 0 },
79 	{ "ipv6.bits", eCmdHdlrPositiveInt, 0 },
80 	{ "embeddedipv4.enable", eCmdHdlrBinary, 0 },
81 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "embeddedipv4.anonmode", eCmdHdlrGetWord, 0 },
82 	{ "embeddedipv4.bits", eCmdHdlrPositiveInt, 0 }
83 };
84 static struct cnfparamblk actpblk =
85 	{ CNFPARAMBLK_VERSION,
86 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
87 	  actpdescr
88 	};</b></font>
89 BEGINbeginCnfLoad
90 CODESTARTbeginCnfLoad
91 	loadModConf = pModConf;
92 	pModConf-&gt;pConf = pConf;
93 ENDbeginCnfLoad
94 BEGINendCnfLoad
95 CODESTARTendCnfLoad
96 ENDendCnfLoad
97 BEGINcheckCnf
98 CODESTARTcheckCnf
99 ENDcheckCnf
100 BEGINactivateCnf
101 CODESTARTactivateCnf
102 	runModConf = pModConf;
103 ENDactivateCnf
104 BEGINfreeCnf
105 CODESTARTfreeCnf
106 ENDfreeCnf
107 BEGINcreateInstance
108 CODESTARTcreateInstance
109 ENDcreateInstance
110 BEGINcreateWrkrInstance
111 CODESTARTcreateWrkrInstance
112 	pWrkrData-&gt;randstatus = time(NULL);
113 ENDcreateWrkrInstance
114 BEGINisCompatibleWithFeature
115 CODESTARTisCompatibleWithFeature
116 ENDisCompatibleWithFeature
117 static void
118 delTree(union node* node, const int layer)
119 {
120 	if(node == NULL){
121 		return;
122 	}
123 	if(layer == 31){
124 		free(node);
125 	} else {
126 		delTree(node-&gt;pointer.more, layer + 1);
127 		delTree(node-&gt;pointer.less, layer + 1);
128 		free(node);
129 	}
130 }
131 BEGINfreeInstance
132 CODESTARTfreeInstance
133 	delTree(pData-&gt;ipv4.Root, 0);
134 	if(pData-&gt;ipv6.hash != NULL) {
135 		hashtable_destroy(pData-&gt;ipv6.hash, 1);
136 	}
137 	if(pData-&gt;embeddedIPv4.hash != NULL) {
138 		hashtable_destroy(pData-&gt;embeddedIPv4.hash, 1);
139 	}
140 ENDfreeInstance
141 BEGINfreeWrkrInstance
142 CODESTARTfreeWrkrInstance
143 ENDfreeWrkrInstance
144 static inline void
145 setInstParamDefaults(instanceData *pData)
146 {
147 		pData-&gt;ipv4.enable = 1;
148 		pData-&gt;ipv4.bits = 16;
149 		pData-&gt;ipv4.Root = NULL;
150 		pData-&gt;ipv4.randConsis = 0;
151 		pData-&gt;ipv4.mode = ZERO;
152 		pData-&gt;ipv4.replaceChar = 'x';
153 		pData-&gt;ipv6.enable = 1;
154 		pData-&gt;ipv6.bits = 96;
155 		pData-&gt;ipv6.anonmode = ZERO;
156 		pData-&gt;ipv6.randConsis = 0;
157 		pData-&gt;ipv6.hash = NULL;
158 		pData-&gt;embeddedIPv4.enable = 1;
159 		pData-&gt;embeddedIPv4.bits = 96;
160 		pData-&gt;embeddedIPv4.anonmode = ZERO;
161 		pData-&gt;embeddedIPv4.randConsis = 0;
162 		pData-&gt;embeddedIPv4.hash = NULL;
163 }
164 BEGINnewActInst
165 	struct cnfparamvals *pvals;
166 	int i;
167 CODESTARTnewActInst
168 	DBGPRINTF("newActInst (mmanon)\n");
169 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
170 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
171 	}
172 	CODE_STD_STRING_REQUESTnewActInst(1)
173 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
174 	CHKiRet(createInstance(&amp;pData));
175 	setInstParamDefaults(pData);
176 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
177 		if(!pvals[i].bUsed)
178 			continue;
179 		if(!strcmp(actpblk.descr[i].name, "ipv4.mode") || !strcmp(actpblk.descr[i].name, "mode")) {
180 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
181 					 sizeof("zero")-1)) {
182 				pData-&gt;ipv4.mode = ZERO;
183 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
184 					 sizeof("random")-1)) {
185 				pData-&gt;ipv4.mode = RANDOMINT;
186 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"simple",
187 					 sizeof("simple")-1) ||
188 					!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"rewrite",
189 					 sizeof("rewrite")-1)) {
190 				pData-&gt;ipv4.mode = SIMPLE;
191 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
192 					 sizeof("random-consistent")-1)) {
193 				pData-&gt;ipv4.mode = RANDOMINT;
194 				pData-&gt;ipv4.randConsis = 1;
195 			} else {
196 				parser_errmsg("mmanon: configuration error, unknown option for ipv4.mode, "
197 					"will use \"zero\"\n");
198 			}
199 		} else if(!strcmp(actpblk.descr[i].name, "ipv4.bits")) {
200 			if((int8_t) pvals[i].val.d.n &lt;= 32) {
201 				pData-&gt;ipv4.bits = (int8_t) pvals[i].val.d.n;
202 			} else {
203 				pData-&gt;ipv4.bits = 32;
204 <a name="1"></a>				parser_errmsg("warning: invalid number of ipv4.bits (%d), corrected "
205 				"to 32", (int) pvals[i].val.d.n);
206 			}
207 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "ipv4.enable")) {
208 			pData-&gt;ipv4.enable = (int) pvals[i].val.d.n;
209 		} else if(!strcmp(actpblk.descr[i].name, "ipv4.replacechar") || !strcmp(actpblk.descr[i].name,
210 			"replacementchar")) {
211 			uchar* tmp = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
212 			pData-&gt;ipv4.replaceChar = tmp[0];
213 			free(tmp);
214 		} else if(!strcmp(actpblk.descr[i].name, "ipv6.enable")) {
215 			pData-&gt;ipv6.enable = (int) pvals[i].val.d.n;
216 		} else if(!strcmp(actpblk.descr[i].name, "ipv6.bits")) {
217 			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
218 				pData-&gt;ipv6.bits = (uint8_t) pvals[i].val.d.n;
219 			} else {
220 				pData-&gt;ipv6.bits = 128;
221 				parser_errmsg("warning: invalid number of ipv6.bits (%d), corrected "
222 				"to 128", (int) pvals[i].val.d.n);
223 			}
224 		} else if(!strcmp(actpblk.descr[i].name, "ipv6.anonmode")) {
225 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
226 					 sizeof("zero")-1)) {
227 				pData-&gt;ipv6.anonmode = ZERO;
228 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
229 					 sizeof("random")-1)) {
230 				pData-&gt;ipv6.anonmode = RANDOMINT;
231 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
232 					 sizeof("random-consistent")-1)) {
233 				pData-&gt;ipv6.anonmode = RANDOMINT;
234 				pData-&gt;ipv6.randConsis = 1;
235 			} else {
236 				parser_errmsg("mmanon: configuration error, unknown option for "
237 				"ipv6.anonmode, will use \"zero\"\n");
238 			}
239 		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.enable")) {
240 			pData-&gt;embeddedIPv4.enable = (int) pvals[i].val.d.n;
241 		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.bits")) {
242 			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
243 				pData-&gt;embeddedIPv4.bits = (uint8_t) pvals[i].val.d.n;
244 			} else {
245 				pData-&gt;embeddedIPv4.bits = 128;
246 				parser_errmsg("warning: invalid number of embeddedipv4.bits (%d), "
247 					"corrected to 128", (int) pvals[i].val.d.n);
248 			}
249 		} else if(!strcmp(actpblk.descr[i].name, "embeddedipv4.anonmode")) {
250 			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"zero",
251 					 sizeof("zero")-1)) {
252 				pData-&gt;embeddedIPv4.anonmode = ZERO;
253 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random",
254 					 sizeof("random")-1)) {
255 				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
256 			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)"random-consistent",
257 					 sizeof("random-consistent")-1)) {
258 				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
259 				pData-&gt;embeddedIPv4.randConsis = 1;
260 			} else {
261 				parser_errmsg("mmanon: configuration error, unknown option for ipv6.anonmode, "
262 				"will use \"zero\"\n");
263 			}
264 		} else {
265 			parser_errmsg("mmanon: program error, non-handled "
266 			  "param '%s'\n", actpblk.descr[i].name);
267 		}
268 	}
269 	int bHadBitsErr = 0;
270 	if(pData-&gt;ipv4.mode == SIMPLE) {
271 		if(pData-&gt;ipv4.bits &lt; 8 &amp;&amp; pData-&gt;ipv4.bits &gt; -1) {
272 			pData-&gt;ipv4.bits = 8;
273 			bHadBitsErr = 1;
274 		} else if(pData-&gt;ipv4.bits &lt; 16 &amp;&amp; pData-&gt;ipv4.bits &gt; 8) {
275 			pData-&gt;ipv4.bits = 16;
276 			bHadBitsErr = 1;
277 		} else if(pData-&gt;ipv4.bits &lt; 24 &amp;&amp; pData-&gt;ipv4.bits &gt; 16) {
278 			pData-&gt;ipv4.bits = 24;
279 			bHadBitsErr = 1;
280 		} else if((pData-&gt;ipv4.bits != 32 &amp;&amp; pData-&gt;ipv4.bits &gt; 24) || pData-&gt;ipv4.bits &lt; 0) {
281 			pData-&gt;ipv4.bits = 32;
282 			bHadBitsErr = 1;
283 		}
284 		if(bHadBitsErr) {
285 			LogError(0, RS_RET_INVLD_ANON_BITS,
286 				"mmanon: invalid number of ipv4 bits "
287 				"in simple mode, corrected to %d",
288 				pData-&gt;ipv4.bits);
289 		}
290 	}
291 CODE_STD_FINALIZERnewActInst
292 	cnfparamvalsDestruct(pvals, &amp;actpblk);
293 ENDnewActInst
294 BEGINdbgPrintInstInfo
295 CODESTARTdbgPrintInstInfo
296 ENDdbgPrintInstInfo
297 BEGINtryResume
298 CODESTARTtryResume
299 ENDtryResume
300 static int
301 getHexVal(char c)
302 {
303 	if('0' &lt;= c &amp;&amp; c &lt;= '9') {
304 		return c - '0';
305 	} else if('a' &lt;= c &amp;&amp; c &lt;= 'f') {
306 		return (c - 'a') + 10;
307 	} else if('A' &lt;= c &amp;&amp; c &lt;= 'F') {
308 		return (c - 'A') + 10;
309 	} else {
310 		return -1;
311 	}
312 }
313 static int64_t
314 getPosInt(const uchar *const __restrict__ buf,
315 	const size_t buflen,
316 	size_t *const __restrict__ nprocessed)
317 {
318 	int64_t val = 0;
319 	size_t i;
320 	for(i = 0 ; i &lt; buflen ; i++) {
321 		if('0' &lt;= buf[i] &amp;&amp; buf[i] &lt;= '9')
322 			val = val*10 + buf[i]-'0';
323 		else
324 			break;
325 	}
326 	*nprocessed = i;
327 	if(i == 0)
328 		val = -1;
329 	return val;
330 }
331 static int
332 syntax_ipv4(const uchar *const __restrict__ buf,
333 	const size_t buflen,
334 	size_t *const __restrict__ nprocessed)
335 {
336 	int64_t val;
337 	size_t nproc;
338 	size_t i;
339 	int r = 0;
340 	val = getPosInt(buf, buflen, &amp;i);
341 	if(val &lt; 0 || val &gt; 255)
342 		goto done;
343 	if(i &gt;= buflen || buf[i] != '.') {
344 		goto done;
345 	}
346 	i++;
347 	val = getPosInt(buf+i, buflen-i, &amp;nproc);
348 	if(val &lt; 0 || val &gt; 255)
349 		goto done;
350 	i += nproc;
351 	if(i &gt;= buflen || buf[i] != '.') {
352 		goto done;
353 	}
354 	i++;
355 	val = getPosInt(buf+i, buflen-i, &amp;nproc);
356 	if(val &lt; 0 || val &gt; 255)
357 		goto done;
358 	i += nproc;
359 	if(i &gt;= buflen || buf[i] != '.') {
360 		goto done;
361 	}
362 	i++;
363 	val = getPosInt(buf+i, buflen-i, &amp;nproc);
364 	if(val &lt; 0 || val &gt; 255)
365 		goto done;
366 	i += nproc;
367 	*nprocessed = i;
368 	r = 1;
369 done:
370 	return r;
371 }
372 static int
373 isValidHexNum(const uchar *const __restrict__ buf,
374 	const size_t buflen,
375 	size_t *const __restrict__ nprocessed,
376 	int handleDot)
377 {
378 	size_t idx = 0;
379 	int cyc = 0;
380 	while(idx &lt; buflen) {
381 		switch(buf[idx]) {
382 		case '0':
383 		case '1':
384 		case '2':
385 		case '3':
386 		case '4':
387 		case '5':
388 		case '6':
389 		case '7':
390 		case '8':
391 		case '9':
392 		case 'a':
393 		case 'b':
394 		case 'c':
395 		case 'd':
396 		case 'e':
397 		case 'f':
398 		case 'A':
399 		case 'B':
400 		case 'C':
401 		case 'D':
402 		case 'E':
403 		case 'F':
404 			cyc++;
405 			(*nprocessed)++;
406 			if(cyc == 5) {
407 				goto done;
408 			}
409 			break;
410 		case '.':
411 			if(handleDot &amp;&amp; cyc == 0) {
412 				(*nprocessed)++;
413 				cyc = -2;
414 			}
415 			goto done;
416 		case ':':
417 			if(cyc == 0) {
418 				(*nprocessed)++;
419 				cyc = -1;
420 			}
421 			goto done;
422 		default:
423 			goto done;
424 		}
425 		idx++;
426 	}
427 done:
428 	return cyc;
429 }
430 static int
431 syntax_ipv6(const uchar *const __restrict__ buf,
432 	const size_t buflen,
433 	size_t *const __restrict__ nprocessed)
434 {
435 	int lastSep = 0;
436 	sbool hadAbbrev = 0;
437 	sbool lastAbbrev = 0;
438 	int ipParts = 0;
439 	int numLen;
440 	int isIP = 0;
441 	while(*nprocessed &lt; buflen) {
442 		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 0);
443 		if(numLen &gt; 0 &amp;&amp; numLen &lt; 5) {  //found a valid num
444 			if((ipParts == 7 &amp;&amp; hadAbbrev) || ipParts &gt; 7) {
445 				isIP = 0;
446 				goto done;
447 			}
448 			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
449 				isIP = 0;
450 				goto done;
451 			}
452 			lastSep = 0;
453 			lastAbbrev = 0;
454 			ipParts++;
455 		} else if (numLen &lt; 0) {  //':'
456 			if(lastSep) {
457 				if(hadAbbrev) {
458 					isIP = 0;
459 					goto done;
460 				} else {
461 					hadAbbrev = 1;
462 					lastAbbrev = 1;
463 				}
464 			}
465 			lastSep = 1;
466 		} else if (numLen == 5) {  			if(hadAbbrev &amp;&amp; ipParts &gt;= 2) {
467 				isIP = 1;
468 				*nprocessed -= 6;
469 			} else {
470 				isIP = 0;
471 			}
472 			goto done;
473 		} else {  //no valid num
474 			if(lastSep) {
475 				if(lastAbbrev &amp;&amp; ipParts &lt; 8) {
476 					isIP = 1;
477 					goto done;
478 				}
479 				isIP = 0;
480 				goto done;
481 			}
482 			if((ipParts == 8 &amp;&amp; !hadAbbrev) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
483 				isIP = 1;
484 				goto done;
485 			} else {
486 				isIP = 0;
487 				goto done;
488 			}
489 		}
490 		if(ipParts == 8 &amp;&amp; !hadAbbrev) {
491 			isIP = 1;
492 			goto done;
493 		}
494 	}
495 	if((!lastSep &amp;&amp; (ipParts == 8 &amp;&amp; !hadAbbrev)) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
496 		isIP = 1;
497 	}
498 done:
499 	return isIP;
500 }
501 static unsigned
502 ipv42num(const char *str)
503 {
504 	unsigned num[4] = {0, 0, 0, 0};
505 	unsigned value = -1;
506 	size_t len = strlen(str);
507 	int cyc = 0;
508 	for(unsigned i = 0 ; i &lt; len ; i++) {
509 		switch(str[i]) {
510 		case '0':
511 		case '1':
512 		case '2':
513 		case '3':
514 		case '4':
515 		case '5':
516 		case '6':
517 		case '7':
518 		case '8':
519 		case '9':
520 			num[cyc] = num[cyc]*10+(str[i]-'0');
521 			break;
522 		case '.':
523 			cyc++;
524 			break;
525 		}
526 	}
527 	value = num[0]*256*256*256+num[1]*256*256+num[2]*256+num[3];
528 	return(value);
529 }
530 static unsigned
531 code_int(unsigned ip, wrkrInstanceData_t *pWrkrData){
532 	unsigned random;
533 	unsigned long long shiftIP_subst = ip;
534 	switch(pWrkrData-&gt;pData-&gt;ipv4.mode) {
535 	case ZERO:
536 		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
537 		return (unsigned)shiftIP_subst;
538 	case RANDOMINT:
539 		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
540 		random = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*
541 			((1ull&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits))-1));
542 		return (unsigned)shiftIP_subst + random;
543 	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
544 	default:
545 		LogError(0, RS_RET_INTERNAL_ERROR, "mmanon: unexpected code path reached in code_int function");
546 		return 0;
547 	}
548 }
549 static int
550 num2ipv4(unsigned num, char *str) {
551 	int numip[4];
552 	size_t len;
553 	for(int i = 0 ; i &lt; 4 ; i++){
554 		numip[i] = num % 256;
555 		num = num / 256;
556 	}
557 	len = snprintf(str, 16, "%d.%d.%d.%d", numip[3], numip[2], numip[1], numip[0]);
558 	return len;
559 }
560 static void
561 getip(uchar *start, size_t end, char *address)
562 {
563 	size_t i;
564 	for(i = 0; i &lt; end; i++){
565 		address[i] = *(start+i);
566 	}
567 	address[i] = '\0';
568 }
569 static rsRetVal
570 findip(char* address, wrkrInstanceData_t *pWrkrData)
571 {
572 	DEFiRet;
573 	int i;
574 	unsigned num;
575 	union node* current;
576 	union node* Last;
577 	int MoreLess;
578 	char* CurrentCharPtr;
579 	current = pWrkrData-&gt;pData-&gt;ipv4.Root;
580 	num = ipv42num(address);
581 	for(i = 0; i &lt; 31; i++){
582 		if(pWrkrData-&gt;pData-&gt;ipv4.Root == NULL) {
583 			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
584 			pWrkrData-&gt;pData-&gt;ipv4.Root = current;
585 		}
586 		Last = current;
587 		if((num &gt;&gt; (31 - i)) &amp; 1){
588 			current = current-&gt;pointer.more;
589 			MoreLess = 1;
590 		} else {
591 			current = current-&gt;pointer.less;
592 			MoreLess = 0;
593 		}
594 		if(current == NULL){
595 			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
596 			if(MoreLess == 1){
597 				Last-&gt;pointer.more = current;
598 			} else {
599 				Last-&gt;pointer.less = current;
600 			}
601 		}
602 	}
603 	if(num &amp; 1){
604 		CurrentCharPtr = current-&gt;ips.ip_high;
605 	} else {
606 		CurrentCharPtr = current-&gt;ips.ip_low;
607 	}
608 	if(CurrentCharPtr[0] != '\0'){
609 		strcpy(address, CurrentCharPtr);
610 	} else {
611 		num = code_int(num, pWrkrData);
612 		num2ipv4(num, CurrentCharPtr);
613 		strcpy(address, CurrentCharPtr);
614 	}
615 finalize_it:
616 	RETiRet;
617 }
618 static void
619 process_IPv4 (char* address, wrkrInstanceData_t *pWrkrData)
620 {
621 	unsigned num;
622 	if(pWrkrData-&gt;pData-&gt;ipv4.randConsis){
623 		findip(address, pWrkrData);
624 	}else {
625 		num = ipv42num(address);
626 		num = code_int(num, pWrkrData);
627 		num2ipv4(num, address);
628 	}
629 }
630 static void
631 simpleAnon(wrkrInstanceData_t *const pWrkrData, uchar *const msg, int *const hasChanged, int iplen)
632 {
633 	int maxidx = iplen - 1;
634 	int j = -1;
635 	for(int i = (pWrkrData-&gt;pData-&gt;ipv4.bits / 8); i &gt; 0; i--) {
636 		j++;
637 		while('0' &lt;= msg[maxidx - j] &amp;&amp; msg[maxidx - j] &lt;= '9') {
638 			if(msg[maxidx - j] != pWrkrData-&gt;pData-&gt;ipv4.replaceChar) {
639 				msg[maxidx - j] = pWrkrData-&gt;pData-&gt;ipv4.replaceChar;
640 				*hasChanged = 1;
641 			}
642 			j++;
643 		}
644 	}
645 }
646 static void
647 anonipv4(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
648 {
649 	char address[16];
650 	char caddress[16];
651 	int offset = *idx;
652 	uchar* msgcpy = *msg;
653 	size_t iplen;
654 	size_t caddresslen;
655 	int oldLen = *pLenMsg;
656 	if(syntax_ipv4((*msg) + offset, *pLenMsg - offset, &amp;iplen)) {
657 		if(pWrkrData-&gt;pData-&gt;ipv4.mode == SIMPLE) {
658 			simpleAnon(pWrkrData, *msg + *idx, hasChanged, iplen);
659 			*idx += iplen;
660 			return;
661 		}
662 		assert(iplen &lt; sizeof(address));
663 		getip(*msg + offset, iplen, address);
664 		offset += iplen;
665 		strcpy(caddress, address);
666 		process_IPv4(caddress, pWrkrData);
667 		caddresslen = strlen(caddress);
668 		*hasChanged = 1;
669 		if(caddresslen != strlen(address)) {
670 			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)strlen(address));
671 			*msg = (uchar*) malloc(*pLenMsg);
672 			memcpy(*msg, msgcpy, *idx);
673 		}
674 		memcpy(*msg + *idx, caddress, caddresslen);
675 		*idx = *idx + caddresslen;
676 		if(*idx &lt; *pLenMsg) {
677 			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
678 		}
679 		if(msgcpy != *msg) {
680 			free(msgcpy);
681 		}
682 	}
683 }
684 static void
685 code_ipv6_int(struct ipv6_int* ip, wrkrInstanceData_t *pWrkrData, int useEmbedded)
686 {
687 	unsigned long long randlow = 0;
688 	unsigned long long randhigh = 0;
689 	unsigned tmpRand;
690 	int fullbits;
691 	int bits = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.bits : pWrkrData-&gt;pData-&gt;ipv6.bits;
692 	enum mode anonmode = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.anonmode : pWrkrData-&gt;pData-&gt;ipv6.anonmode;
693 	if(bits == 128) { //has to be handled separately, since shift
694 		ip-&gt;high = 0;
695 		ip-&gt;low = 0;
696 	} else if(bits &gt; 64) {
697 		ip-&gt;low = 0;
698 		ip-&gt;high = (ip-&gt;high &gt;&gt; (bits - 64)) &lt;&lt;  (bits - 64);
699 	} else if(bits == 64) {
700 		ip-&gt;low = 0;
701 	} else {
702 		ip-&gt;low = (ip-&gt;low &gt;&gt; bits) &lt;&lt; bits;
703 	}
704 	switch(anonmode) {
705 	case ZERO:
706 		break;
707 	case RANDOMINT:
708 		if(bits == 128) {
709 			for(int i = 0; i &lt; 8; i++) {
710 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
711 				ip-&gt;high &lt;&lt;= 8;
712 				ip-&gt;high |= tmpRand;
713 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
714 				ip-&gt;low &lt;&lt;= 8;
715 				ip-&gt;low |= tmpRand;
716 			}
717 		} else if(bits &gt; 64) {
718 			for(int i = 0; i &lt; 8; i++) {
719 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
720 				ip-&gt;low &lt;&lt;= 8;
721 				ip-&gt;low |= tmpRand;
722 			}
723 			bits -= 64;
724 			fullbits = bits / 8;
725 			bits = bits % 8;
726 			while(fullbits &gt; 0) {
727 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
728 				randhigh &lt;&lt;= 8;
729 				randhigh |= tmpRand;
730 				fullbits--;
731 			}
732 			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
733 			randhigh &lt;&lt;= bits;
734 			randhigh |= tmpRand;
735 			ip-&gt;high |= randhigh;
736 		} else if(bits == 64) {
737 			for(int i = 0; i &lt; 8; i++) {
738 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
739 				ip-&gt;low &lt;&lt;= 8;
740 				ip-&gt;low |= tmpRand;
741 			}
742 		} else {
743 			fullbits = bits / 8;
744 			bits = bits % 8;
745 			while(fullbits &gt; 0) {
746 				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
747 				randlow &lt;&lt;= 8;
748 				randlow |= tmpRand;
749 				fullbits--;
750 			}
751 			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
752 			randlow &lt;&lt;= bits;
753 			randlow |= tmpRand;
754 			ip-&gt;low |= randlow;
755 		}
756 		break;
757 	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
758 	default:
759 		LogError(0, RS_RET_INTERNAL_ERROR, "mmanon: unexpected code path reached in code_int function");
760 	}
761 }
762 static void
763 ipv62num(char* const address, const size_t iplen, struct ipv6_int* const ip)
764 {
765 	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
766 	int cyc = 0;
767 	int dots = 0;
768 	int val;
769 	unsigned i;
770 	for(i = 0; i &lt; iplen &amp;&amp; dots &lt; 2; i++) {
771 		val = getHexVal(address[i]);
772 		if(val == -1) {
773 			dots++;
774 			if(dots &lt; 2) {
775 				cyc++;
776 			}
777 		} else {
778 			num[cyc] = num[cyc] * 16 + val;
779 			dots = 0;
780 		}
781 	}
782 	if(dots == 2) {
783 		if(i &lt; iplen - 1) {
784 			int shift = 0;
785 			cyc = 7;
786 			for(unsigned j = iplen - 1; j &gt;= i; j--) {
787 				val = getHexVal(address[j]);
788 				if(val == -1) {
789 					cyc--;
790 					shift = 0;
791 				} else {
792 					val &lt;&lt;= shift;
793 					shift += 4;
794 					num[cyc] += val;
795 				}
796 			}
797 		} else {
798 			while(cyc &lt; 8) {
799 				num[cyc] = 0;
800 				cyc++;
801 			}
802 		}
803 	}
804 	for(i = 0; i &lt; 4; i++) {
805 		ip-&gt;high &lt;&lt;= 16;
806 		ip-&gt;high |= num[i];
807 	}
808 	while(i &lt; 8) {
809 		ip-&gt;low &lt;&lt;= 16;
810 		ip-&gt;low |= num[i];
811 		i++;
812 	}
813 }
814 static void
815 num2ipv6 (struct ipv6_int* ip, char* address)
816 {
817 	int num[8];
818 	int i;
819 	for(i = 7; i &gt; 3; i--) {
820 		num[i] = ip-&gt;low &amp; 0xffff;
821 		ip-&gt;low &gt;&gt;= 16;
822 	}
823 	while(i &gt; -1) {
824 		num[i] = ip-&gt;high &amp; 0xffff;
825 		ip-&gt;high &gt;&gt;= 16;
826 		i--;
827 	}
828 	snprintf(address, 40, "%x:%x:%x:%x:%x:%x:%x:%x", num[0], num[1], num[2], num[3], num[4], num[5],
829 		num[6], num[7]);
830 }
831 static int
832 keys_equal_fn(void* key1, void* key2)
833 {
834 	struct ipv6_int *const k1 = (struct ipv6_int*) key1;
835 	struct ipv6_int *const k2 = (struct ipv6_int*) key2;
836 	return((k1-&gt;high == k2-&gt;high) &amp;&amp; (k1-&gt;low == k2-&gt;low));
837 }
838 static unsigned
839 hash_from_key_fn (void* k)
840 {
841 	struct ipv6_int *const key = (struct ipv6_int*) k;
842 	unsigned hashVal;
843 	hashVal = (key-&gt;high &amp; 0xFFC00000) | (key-&gt;low &amp; 0x3FFFFF);
844 	return hashVal;
845 }
846 static void
847 num2embedded (struct ipv6_int* ip, char* address)
848 {
849 	int num[8];
850 	int i;
851 	for(i = 7; i &gt; 3; i--) {
852 		num[i] = ip-&gt;low &amp; 0xffff;
853 		ip-&gt;low &gt;&gt;= 16;
854 	}
855 	while(i &gt; -1) {
856 		num[i] = ip-&gt;high &amp; 0xffff;
857 		ip-&gt;high &gt;&gt;= 16;
858 		i--;
859 	}
860 	snprintf(address, 46, "%x:%x:%x:%x:%x:%x:%d.%d.%d.%d", num[0], num[1], num[2], num[3], num[4], num[5],
861 		(num[6] &amp; 0xff00) &gt;&gt; 8, num[6] &amp; 0xff, (num[7] &amp; 0xff00) &gt;&gt; 8, num[7] &amp; 0xff);
862 }
863 static rsRetVal
864 findIPv6(struct ipv6_int* num, char* address, wrkrInstanceData_t *const pWrkrData, int useEmbedded)
865 {
866 	struct ipv6_int* hashKey = NULL;
867 	DEFiRet;
868 	struct hashtable* hash = useEmbedded? pWrkrData-&gt;pData-&gt;embeddedIPv4.hash : pWrkrData-&gt;pData-&gt;ipv6.hash;
869 	if(hash == NULL) {
870 		CHKmalloc(hash = create_hashtable(512, hash_from_key_fn, keys_equal_fn, NULL));
871 		if(useEmbedded) {
872 			pWrkrData-&gt;pData-&gt;embeddedIPv4.hash = hash;
873 		} else {
874 			pWrkrData-&gt;pData-&gt;ipv6.hash = hash;
875 		}
876 	}
877 	char* val = (char*)(hashtable_search(hash, num));
878 	if(val != NULL) {
879 		strcpy(address, val);
880 	} else {
881 		CHKmalloc(hashKey = (struct ipv6_int*) malloc(sizeof(struct ipv6_int)));
882 		hashKey-&gt;low = num-&gt;low;
883 		hashKey-&gt;high = num-&gt;high;
884 		if(useEmbedded) {
885 			code_ipv6_int(num, pWrkrData, 1);
886 			num2embedded(num, address);
887 		} else {
888 			code_ipv6_int(num, pWrkrData, 0);
889 			num2ipv6(num, address);
890 		}
891 		char* hashString;
892 		CHKmalloc(hashString = strdup(address));
893 		if(!hashtable_insert(hash, hashKey, hashString)) {
894 			DBGPRINTF("hashtable error: insert to %s-table failed",
895 				useEmbedded ? "embedded ipv4" : "ipv6");
896 			free(hashString);
897 			ABORT_FINALIZE(RS_RET_ERR);
898 		}
899 		hashKey = NULL;
900 	}
901 finalize_it:
902 	free(hashKey);
903 	RETiRet;
904 }
905 static void
906 process_IPv6 (char* address, wrkrInstanceData_t *pWrkrData, const size_t iplen)
907 {
908 	struct ipv6_int num = {0, 0};
909 	ipv62num(address, iplen, &amp;num);
910 	if(pWrkrData-&gt;pData-&gt;ipv6.randConsis) {
911 		findIPv6(&amp;num, address, pWrkrData, 0);
912 	} else {
913 		code_ipv6_int(&amp;num, pWrkrData, 0);
914 		num2ipv6(&amp;num, address);
915 	}
916 }
917 static void
918 anonipv6(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
919 {
920 	size_t iplen = 0;
921 	int offset = *idx;
922 	char address[40];
923 	uchar* msgcpy = *msg;
924 	size_t caddresslen;
925 	size_t oldLen = *pLenMsg;
926 	int syn = syntax_ipv6(*msg + offset, *pLenMsg - offset, &amp;iplen);
927 	if(syn) {
928 		assert(iplen &lt; sizeof(address));  //has to be &lt; instead of &lt;= since address includes space for a '\0'
929 		getip(*msg + offset, iplen, address);
930 		offset += iplen;
931 		process_IPv6(address, pWrkrData, iplen);
932 		caddresslen = strlen(address);
933 		*hasChanged = 1;
934 		if(caddresslen != iplen) {
935 			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
936 			*msg = (uchar*) malloc(*pLenMsg);
937 			memcpy(*msg, msgcpy, *idx);
938 		}
939 		memcpy(*msg + *idx, address, caddresslen);
940 		*idx = *idx + caddresslen;
941 		if(*idx &lt; *pLenMsg) {
942 			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
943 		}
944 		if(msgcpy != *msg) {
945 			free(msgcpy);
946 		}
947 	}
948 }
949 static size_t
950 findV4Start(const uchar *const __restrict__ buf, size_t dotPos)
951 {
952 	while(dotPos &gt; 0) {
953 		if(buf[dotPos] == ':') {
954 			return dotPos + 1;
955 		}
956 		dotPos--;
957 	}
958 	return -1; //should not happen
959 }
960 static int
961 syntax_embedded(const uchar *const __restrict__ buf,
962 	const size_t buflen,
963 	size_t *const __restrict__ nprocessed,
964 	size_t * v4Start)
965 {
966 	int lastSep = 0;
967 	sbool hadAbbrev = 0;
968 	int ipParts = 0;
969 	int numLen;
970 	int isIP = 0;
971 	size_t ipv4Len;
972 	while(*nprocessed &lt; buflen) {
973 		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 1);
974 		if(numLen &gt; 0) {  //found a valid num
975 			if((ipParts == 6 &amp;&amp; hadAbbrev) || ipParts &gt; 6) {  //is 6 since the first part of
976 				isIP = 0;
977 				goto done;
978 			}
979 			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
980 				isIP = 0;
981 				goto done;
982 			}
983 			lastSep = 0;
984 			ipParts++;
985 		} else if (numLen == -1) {  //':'
986 			if(lastSep) {
987 				if(hadAbbrev) {
988 					isIP = 0;
989 					goto done;
990 				} else {
991 					hadAbbrev = 1;
992 				}
993 			}
994 			lastSep = 1;
995 		} else if (numLen == -2) {  //'.'
996 			if (lastSep || (ipParts == 0 &amp;&amp; hadAbbrev) || (ipParts &lt;= 6 &amp;&amp; !hadAbbrev)) {
997 				isIP = 0;
998 				goto done;
999 			}
1000 			*v4Start = findV4Start(buf, (*nprocessed) - 1);
1001 			if(syntax_ipv4(buf + (*v4Start), buflen, &amp;ipv4Len)) {
1002 				*nprocessed += (ipv4Len - ((*nprocessed) - (*v4Start)));
1003 				isIP = 1;
1004 				goto done;
1005 			} else {
1006 				isIP = 0;
1007 				goto done;
1008 			}
1009 		} else {  //no valid num
1010 			isIP = 0;
1011 			goto done;
1012 		}
1013 	}
1014 	isIP = 0;
1015 done:
1016 	return isIP;
1017 }
1018 static void
1019 embedded2num(char* address, size_t v4Start, struct ipv6_int* ip)
1020 {
1021 	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
1022 	int cyc = 0;
1023 	int dots = 0;
1024 	int val;
1025 	unsigned i;
1026 	unsigned v4Val = ipv42num(address + v4Start);
1027 	num[7] = v4Val &amp; 0xffff;
1028 	num[6] = (v4Val &amp; 0xffff0000) &gt;&gt; 16;
1029 	for(i = 0; i &lt; v4Start &amp;&amp; dots &lt; 2; i++) {
1030 		val = getHexVal(address[i]);
1031 		if(val == -1) {
1032 			dots++;
1033 			if(dots &lt; 2) {
1034 				cyc++;
1035 			}
1036 		} else {
1037 			num[cyc] = num[cyc] * 16 + val;
1038 			dots = 0;
1039 		}
1040 	}
1041 	if(dots == 2) {
1042 		if(i &lt; v4Start) {
1043 			int shift = 0;
1044 			cyc = 5;
1045 			for(unsigned j = v4Start - 1; j &gt;= i; j--) {
1046 				val = getHexVal(address[j]);
1047 				if(val == -1) {
1048 					cyc--;
1049 					shift = 0;
1050 				} else {
1051 					val &lt;&lt;= shift;
1052 					shift += 4;
1053 					num[cyc] += val;
1054 				}
1055 			}
1056 		} else {
1057 			while(cyc &lt; 6) {
1058 				num[cyc] = 0;
1059 				cyc++;
1060 			}
1061 		}
1062 	}
1063 	for(i = 0; i &lt; 4; i++) {
1064 		ip-&gt;high &lt;&lt;= 16;
1065 		ip-&gt;high |= num[i];
1066 	}
1067 	while(i &lt; 8) {
1068 		ip-&gt;low &lt;&lt;= 16;
1069 		ip-&gt;low |= num[i];
1070 		i++;
1071 	}
1072 }
1073 static void
1074 process_embedded (char* address, wrkrInstanceData_t *pWrkrData, size_t v4Start)
1075 {
1076 	struct ipv6_int num = {0, 0};
1077 	embedded2num(address, v4Start, &amp;num);
1078 	if(pWrkrData-&gt;pData-&gt;embeddedIPv4.randConsis) {
1079 		findIPv6(&amp;num, address, pWrkrData, 1);
1080 	} else {
1081 		code_ipv6_int(&amp;num, pWrkrData, 1);
1082 		num2embedded(&amp;num, address);
1083 	}
1084 }
1085 static void
1086 anonEmbedded(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
1087 {
1088 	size_t iplen = 0;
1089 	int offset = *idx;
1090 	char address[46];
1091 	uchar* msgcpy = *msg;
1092 	unsigned caddresslen;
1093 	size_t oldLen = *pLenMsg;
1094 	size_t v4Start;
1095 	int syn = syntax_embedded(*msg + offset, *pLenMsg - offset, &amp;iplen, &amp;v4Start);
1096 	if(syn) {
1097 		assert(iplen &lt; sizeof(address));
1098 		getip(*msg + offset, iplen, address);
1099 		offset += iplen;
1100 		process_embedded(address, pWrkrData, v4Start);
1101 		caddresslen = strlen(address);
1102 		*hasChanged = 1;
1103 		if(caddresslen != iplen) {
1104 			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
1105 			*msg = (uchar*) malloc(*pLenMsg);
1106 			memcpy(*msg, msgcpy, *idx);
1107 		}
1108 		memcpy(*msg + *idx, address, caddresslen);
1109 		*idx = *idx + caddresslen;
1110 		if(*idx &lt; *pLenMsg) {
1111 			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
1112 		}
1113 		if(msgcpy != *msg) {
1114 			free(msgcpy);
1115 		}
1116 	}
1117 }
1118 BEGINdoAction_NoStrings
1119 	smsg_t **ppMsg = (smsg_t **) pMsgData;
1120 	smsg_t *pMsg = ppMsg[0];
1121 	uchar *msg;
1122 	int lenMsg;
1123 	int i;
1124 	int hasChanged = 0;
1125 CODESTARTdoAction
1126 	lenMsg = getMSGLen(pMsg);
1127 	msg = (uchar*)strdup((char*)getMSG(pMsg));
1128 	for(i = 0 ; i &lt;= lenMsg - 2 ; i++) {
1129 		if(pWrkrData-&gt;pData-&gt;embeddedIPv4.enable) {
1130 			anonEmbedded(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
1131 		}
1132 		if(pWrkrData-&gt;pData-&gt;ipv4.enable) {
1133 			anonipv4(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
1134 		}
1135 		if(pWrkrData-&gt;pData-&gt;ipv6.enable) {
1136 			anonipv6(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
1137 		}
1138 	}
1139 	if(hasChanged) {
1140 		MsgReplaceMSG(pMsg, msg, lenMsg);
1141 	}
1142 	free(msg);
1143 ENDdoAction
1144 NO_LEGACY_CONF_parseSelectorAct
1145 BEGINmodExit
1146 CODESTARTmodExit
1147 ENDmodExit
1148 BEGINqueryEtryPt
1149 CODESTARTqueryEtryPt
1150 CODEqueryEtryPt_STD_OMOD_QUERIES
1151 CODEqueryEtryPt_STD_OMOD8_QUERIES
1152 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1153 CODEqueryEtryPt_STD_CONF2_QUERIES
1154 ENDqueryEtryPt
1155 BEGINmodInit()
1156 CODESTARTmodInit
1157 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1158 	DBGPRINTF("mmanon: module compiled with rsyslog version %s.\n", VERSION);
1159 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omstdout.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;unistd.h&gt;
11 #include "conf.h"
12 #include "syslogd-types.h"
13 #include "srUtils.h"
14 #include "template.h"
15 #include "module-template.h"
16 #include "errmsg.h"
17 #include "cfsysline.h"
18 MODULE_TYPE_OUTPUT
19 MODULE_TYPE_NOKEEP
20 MODULE_CNFNAME("omstdout")
21 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
22 DEF_OMOD_STATIC_DATA
23 typedef struct _instanceData {
24 	uchar *templateName;
25 } instanceData;
26 typedef struct wrkrInstanceData {
27 	instanceData *pData;
28 } wrkrInstanceData_t;
29 typedef struct configSettings_s {
30 	int bUseArrayInterface;			int bEnsureLFEnding;
31 	int templateName;
32 } configSettings_t;
33 static configSettings_t cs;
34 <a name="0"></a>static struct cnfparamdescr actpdescr[] = {
35 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "ensurelfending", eCmdHdlrBinary, 0 },
36 	{ "template", eCmdHdlrGetWord, 0 }
37 };
38 static struct cnfparamblk actpblk =
39 	{ CNFPARAMBLK_VERSION,
40 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
41 	  actpdescr
42 	};</b></font>
43 struct modConfData_s {
44 	rsconf_t *pConf;	};
45 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
46 BEGINinitConfVars		CODESTARTinitConfVars
47 	resetConfigVariables(NULL, NULL);
48 ENDinitConfVars
49 BEGINcreateInstance
50 CODESTARTcreateInstance
51 ENDcreateInstance
52 BEGINcreateWrkrInstance
53 CODESTARTcreateWrkrInstance
54 ENDcreateWrkrInstance
55 BEGINbeginCnfLoad
56 CODESTARTbeginCnfLoad
57 	loadModConf = pModConf;
58 	pModConf-&gt;pConf = pConf;
59 ENDbeginCnfLoad
60 BEGINendCnfLoad
61 CODESTARTendCnfLoad
62 	loadModConf = NULL; ENDendCnfLoad
63 BEGINcheckCnf
64 CODESTARTcheckCnf
65 ENDcheckCnf
66 BEGINactivateCnf
67 CODESTARTactivateCnf
68 	runModConf = pModConf;
69 ENDactivateCnf
70 BEGINfreeCnf
71 CODESTARTfreeCnf
72 ENDfreeCnf
73 BEGINisCompatibleWithFeature
74 CODESTARTisCompatibleWithFeature
75 	if(eFeat == sFEATURERepeatedMsgReduction)
76 		iRet = RS_RET_OK;
77 ENDisCompatibleWithFeature
78 BEGINfreeInstance
79 CODESTARTfreeInstance
80 ENDfreeInstance
81 BEGINfreeWrkrInstance
82 CODESTARTfreeWrkrInstance
83 ENDfreeWrkrInstance
84 BEGINdbgPrintInstInfo
85 CODESTARTdbgPrintInstInfo
86 	dbgprintf("omstdout\n");
87 	dbgprintf("\tensureLFEnding='%d'\n", pData-&gt;bEnsureLFEnding);
88 	dbgprintf("\ttemplate='%s'\n", pData-&gt;templateName);
89 ENDdbgPrintInstInfo
90 BEGINtryResume
91 CODESTARTtryResume
92 ENDtryResume
93 BEGINdoAction
94 	char **szParams;
95 	char *toWrite;
96 	int iParamVal;
97 	int iParam;
98 	int iBuf;
99 	char szBuf[65564];
100 	size_t len;
101 	int r;
102 CODESTARTdoAction
103 dbgprintf("omstdout: in doAction\n");
104 	if(pWrkrData-&gt;pData-&gt;bUseArrayInterface) {
105 dbgprintf("omstdout: in ArrayInterface\n");
106 		szParams = (char**)(void*) (ppString[0]);
107 		iParam = 0;
108 		iBuf = 0;
109 		while(szParams[iParam] != NULL &amp;&amp; iBuf &lt; (int)sizeof(szBuf)-1) {
110 			if(iParam &gt; 0)
111 				szBuf[iBuf++] = ','; 			iParamVal = 0;
112 			while(szParams[iParam][iParamVal] != '\0' &amp;&amp; iBuf &lt; (int) sizeof(szBuf)-1) {
113 				szBuf[iBuf++] = szParams[iParam][iParamVal++];
114 			}
115 			++iParam;
116 		}
117 		szBuf[iBuf] = '\0';
118 		toWrite = szBuf;
119 	} else {
120 dbgprintf("omstdout: in else\n");
121 		toWrite = (char*) ppString[0];
122 	}
123 	len = strlen(toWrite);
124 dbgprintf("omstdout: len: %d, toWrite: %s\n", (int) len, toWrite);
125 	if((r = write(1, toWrite, len)) != (int) len) { 		DBGPRINTF("omstdout: error %d writing to stdout[%zd]: %s\n",
126 			r, len, toWrite);
127 	}
128 	if(pWrkrData-&gt;pData-&gt;bEnsureLFEnding &amp;&amp; toWrite[len-1] != '\n') {
129 		if((r = write(1, "\n", 1)) != 1) { 			DBGPRINTF("omstdout: error %d writing \\n to stdout\n",
130 				r);
131 		}
132 	}
133 ENDdoAction
134 static void
135 setInstParamDefaults(instanceData *pData)
136 {
137 	pData-&gt;bEnsureLFEnding = 1;
138 	pData-&gt;templateName = (uchar*) "RSYSLOG_FileFormat";
139 	pData-&gt;bUseArrayInterface = 0;
140 }
141 BEGINnewActInst
142 	struct cnfparamvals *pvals;
143 	int i;
144 	int bDestructPValsOnExit;
145 	uchar *tplToUse;
146 CODESTARTnewActInst
147 	DBGPRINTF("newActInst (omstdout)\n");
148 	bDestructPValsOnExit = 0;
149 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
150 	if(pvals == NULL) {
151 		LogError(0, RS_RET_MISSING_CNFPARAMS, "omstdout: error reading "
152 				"config parameters");
153 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
154 	}
155 	bDestructPValsOnExit = 1;
156 	if(Debug) {
157 		dbgprintf("action param blk in omstdout:\n");
158 		cnfparamsPrint(&amp;actpblk, pvals);
159 	}
160 	CHKiRet(createInstance(&amp;pData));
161 	setInstParamDefaults(pData);
162 <a name="1"></a>	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
163 		if(!pvals[i].bUsed) {
164 			continue;
165 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(actpblk.descr[i].name, "ensurelfending")) {
166 			pData-&gt;bEnsureLFEnding = (int) pvals[i].val.d.n;
167 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
168 			pData-&gt;templateName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
169 		} else {
170 			DBGPRINTF("omstdout: program error, non-handled "
171 			  "param '%s'\n", actpblk.descr[i].name);
172 		}
173 	}
174 	CODE_STD_STRING_REQUESTnewActInst(1)
175 	tplToUse = (uchar*) strdup((pData-&gt;templateName == NULL) ? "RSYSLOG_FileFormat" : (char *)pData-&gt;templateName);
176 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
177 CODE_STD_FINALIZERnewActInst
178 	if(bDestructPValsOnExit)
179 		cnfparamvalsDestruct(pvals, &amp;actpblk);
180 ENDnewActInst
181 BEGINparseSelectorAct
182 	int iTplOpts;
183 CODESTARTparseSelectorAct
184 CODE_STD_STRING_REQUESTparseSelectorAct(1)
185 	if(strncmp((char*) p, ":omstdout:", sizeof(":omstdout:") - 1)) {
186 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
187 	}
188 	p += sizeof(":omstdout:") - 1; 	CHKiRet(createInstance(&amp;pData));
189 	if(*(p-1) == ';')
190 		--p;
191 	iTplOpts = (cs.bUseArrayInterface == 0) ? 0 : OMSR_TPL_AS_ARRAY;
192 	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, iTplOpts, (uchar*) "RSYSLOG_FileFormat"));
193 	pData-&gt;bUseArrayInterface = cs.bUseArrayInterface;
194 	pData-&gt;bEnsureLFEnding = cs.bEnsureLFEnding;
195 CODE_STD_FINALIZERparseSelectorAct
196 ENDparseSelectorAct
197 BEGINmodExit
198 CODESTARTmodExit
199 ENDmodExit
200 BEGINqueryEtryPt
201 CODESTARTqueryEtryPt
202 CODEqueryEtryPt_STD_OMOD_QUERIES
203 CODEqueryEtryPt_STD_OMOD8_QUERIES
204 CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
205 CODEqueryEtryPt_STD_CONF2_QUERIES
206 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
207 ENDqueryEtryPt
208 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
209 {
210 	DEFiRet;
211 	cs.bUseArrayInterface = 0;
212 	cs.bEnsureLFEnding = 1;
213 	RETiRet;
214 }
215 BEGINmodInit()
216 	rsRetVal localRet;
217 	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
218 	unsigned long opts;
219 	int bArrayPassingSupported;		CODESTARTmodInit
220 INITLegCnfVars
221 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
222 	bArrayPassingSupported = 0;
223 	localRet = pHostQueryEtryPt((uchar*)"OMSRgetSupportedTplOpts", &amp;pomsrGetSupportedTplOpts);
224 	if(localRet == RS_RET_OK) {
225 		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
226 		if(opts &amp; OMSR_TPL_AS_ARRAY)
227 			bArrayPassingSupported = 1;
228 	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
229 		ABORT_FINALIZE(localRet); 	}
230 	DBGPRINTF("omstdout: array-passing is %ssupported by rsyslog core.\n", bArrayPassingSupported ? "" : "not ");
231 	if(bArrayPassingSupported) {
232 		CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionomstdoutarrayinterface", 0, eCmdHdlrBinary, NULL,
233 			                   &amp;cs.bUseArrayInterface, STD_LOADABLE_MODULE_ID));
234 	}
235 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionomstdoutensurelfending", 0, eCmdHdlrBinary, NULL,
236 				   &amp;cs.bEnsureLFEnding, STD_LOADABLE_MODULE_ID));
237 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
238 				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
239 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
