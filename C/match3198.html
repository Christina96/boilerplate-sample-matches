<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mmanon.c & omstdout.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mmanon.c & omstdout.c
      </h3>
      <h1 align="center">
        2.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mmanon.c (1.6534392%)<TH>omstdout.c (12.254902%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match3198-0.html#0',2,'match3198-1.html#0',3)" NAME="0">(126-133)<TD><A HREF="javascript:ZweiFrames('match3198-0.html#0',2,'match3198-1.html#0',3)" NAME="0">(80-87)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match3198-0.html#1',2,'match3198-1.html#1',3)" NAME="1">(275-279)<TD><A HREF="javascript:ZweiFrames('match3198-0.html#1',2,'match3198-1.html#1',3)" NAME="1">(265-268)</A><TD ALIGN=center><FONT COLOR="#eb0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmanon.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* mmanon.c
 * anonnymize IP addresses inside the syslog message part
 *
 * Copyright 2013 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;parserif.h&quot;
#include &quot;hashtable.h&quot;



MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;mmanon&quot;)


DEF_OMOD_STATIC_DATA

/* config variables */

// enumerator for the mode
enum mode {ZERO, RANDOMINT, SIMPLE};

union node {
	struct {
		union node* more;
		union node* less;
	} pointer;
	struct {
		char ip_high[16];
		char ip_low[16];
	} ips;
};

struct ipv6_int {
	unsigned long long high;
	unsigned long long low;
	};
/* define operation modes we have */
#define SIMPLE_MODE 0	 /* just overwrite */
#define REWRITE_MODE 1	 /* rewrite IP address, canoninized */
typedef struct _instanceData {
	struct {
		sbool enable;
		int8_t bits;
		union node* Root;
		int randConsis;
		enum mode mode;
		uchar replaceChar;
	} ipv4;

	struct {
		sbool enable;
		uint8_t bits;
		enum mode anonmode;
		int randConsis;
		struct hashtable* hash;
	} ipv6;

	struct {
		sbool enable;
		uint8_t bits;
		enum mode anonmode;
		int randConsis;
		struct hashtable* hash;
	} embeddedIPv4;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
	unsigned randstatus;
} wrkrInstanceData_t;

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};
static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */


/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ &quot;ipv4.enable&quot;, eCmdHdlrBinary, 0 },
	{ &quot;ipv4.mode&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;mode&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;ipv4.bits&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;ipv4.replacechar&quot;, eCmdHdlrGetChar, 0},
	{ &quot;replacementchar&quot;, eCmdHdlrGetChar, 0},
	{ &quot;ipv6.enable&quot;, eCmdHdlrBinary, 0 },
<A NAME="0"></A>	{ &quot;ipv6.anonmode&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;ipv6.bits&quot;, eCmdHdlrPositiveInt, 0 },
	{ &quot;embeddedipv4.enable&quot;, eCmdHdlrBinary, 0 },
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3198-1.html#0',3,'match3198-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;embeddedipv4.anonmode&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;embeddedipv4.bits&quot;, eCmdHdlrPositiveInt, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;randstatus = time(NULL);
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature


static void
delTree(union node* node, const int layer)
{
	if(node == NULL){
		return;
	}
	if(layer == 31){
		free(node);
	} else {
		delTree(node-&gt;pointer.more, layer + 1);
		delTree(node-&gt;pointer.less, layer + 1);
		free(node);
	}
}


BEGINfreeInstance
CODESTARTfreeInstance
	delTree(pData-&gt;ipv4.Root, 0);
	if(pData-&gt;ipv6.hash != NULL) {
		hashtable_destroy(pData-&gt;ipv6.hash, 1);
	}
	if(pData-&gt;embeddedIPv4.hash != NULL) {
		hashtable_destroy(pData-&gt;embeddedIPv4.hash, 1);
	}
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


static inline void
setInstParamDefaults(instanceData *pData)
{
		pData-&gt;ipv4.enable = 1;
		pData-&gt;ipv4.bits = 16;
		pData-&gt;ipv4.Root = NULL;
		pData-&gt;ipv4.randConsis = 0;
		pData-&gt;ipv4.mode = ZERO;
		pData-&gt;ipv4.replaceChar = 'x';

		pData-&gt;ipv6.enable = 1;
		pData-&gt;ipv6.bits = 96;
		pData-&gt;ipv6.anonmode = ZERO;
		pData-&gt;ipv6.randConsis = 0;
		pData-&gt;ipv6.hash = NULL;

		pData-&gt;embeddedIPv4.enable = 1;
		pData-&gt;embeddedIPv4.bits = 96;
		pData-&gt;embeddedIPv4.anonmode = ZERO;
		pData-&gt;embeddedIPv4.randConsis = 0;
		pData-&gt;embeddedIPv4.hash = NULL;
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (mmanon)\n&quot;);
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, &quot;ipv4.mode&quot;) || !strcmp(actpblk.descr[i].name, &quot;mode&quot;)) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;zero&quot;,
					 sizeof(&quot;zero&quot;)-1)) {
				pData-&gt;ipv4.mode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random&quot;,
					 sizeof(&quot;random&quot;)-1)) {
				pData-&gt;ipv4.mode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;simple&quot;,
					 sizeof(&quot;simple&quot;)-1) ||
					!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;rewrite&quot;,
					 sizeof(&quot;rewrite&quot;)-1)) {
				pData-&gt;ipv4.mode = SIMPLE;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random-consistent&quot;,
					 sizeof(&quot;random-consistent&quot;)-1)) {
				pData-&gt;ipv4.mode = RANDOMINT;
				pData-&gt;ipv4.randConsis = 1;
			} else {
				parser_errmsg(&quot;mmanon: configuration error, unknown option for ipv4.mode, &quot;
					&quot;will use \&quot;zero\&quot;\n&quot;);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv4.bits&quot;)) {
			if((int8_t) pvals[i].val.d.n &lt;= 32) {
				pData-&gt;ipv4.bits = (int8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;ipv4.bits = 32;
<A NAME="1"></A>				parser_errmsg(&quot;warning: invalid number of ipv4.bits (%d), corrected &quot;
				&quot;to 32&quot;, (int) pvals[i].val.d.n);
			}
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match3198-1.html#1',3,'match3198-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv4.enable&quot;)) {
			pData-&gt;ipv4.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv4.replacechar&quot;) || !strcmp(actpblk.descr[i].name,
			&quot;replacementchar&quot;)) {
			uchar* tmp = (uchar*) es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
			pData-&gt;ipv4.replaceChar = tmp[0];
			free(tmp);
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv6.enable&quot;)) {
			pData-&gt;ipv6.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv6.bits&quot;)) {
			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
				pData-&gt;ipv6.bits = (uint8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;ipv6.bits = 128;
				parser_errmsg(&quot;warning: invalid number of ipv6.bits (%d), corrected &quot;
				&quot;to 128&quot;, (int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;ipv6.anonmode&quot;)) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;zero&quot;,
					 sizeof(&quot;zero&quot;)-1)) {
				pData-&gt;ipv6.anonmode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random&quot;,
					 sizeof(&quot;random&quot;)-1)) {
				pData-&gt;ipv6.anonmode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random-consistent&quot;,
					 sizeof(&quot;random-consistent&quot;)-1)) {
				pData-&gt;ipv6.anonmode = RANDOMINT;
				pData-&gt;ipv6.randConsis = 1;
			} else {
				parser_errmsg(&quot;mmanon: configuration error, unknown option for &quot;
				&quot;ipv6.anonmode, will use \&quot;zero\&quot;\n&quot;);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;embeddedipv4.enable&quot;)) {
			pData-&gt;embeddedIPv4.enable = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;embeddedipv4.bits&quot;)) {
			if((uint8_t) pvals[i].val.d.n &lt;= 128) {
				pData-&gt;embeddedIPv4.bits = (uint8_t) pvals[i].val.d.n;
			} else {
				pData-&gt;embeddedIPv4.bits = 128;
				parser_errmsg(&quot;warning: invalid number of embeddedipv4.bits (%d), &quot;
					&quot;corrected to 128&quot;, (int) pvals[i].val.d.n);
			}
		} else if(!strcmp(actpblk.descr[i].name, &quot;embeddedipv4.anonmode&quot;)) {
			if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;zero&quot;,
					 sizeof(&quot;zero&quot;)-1)) {
				pData-&gt;embeddedIPv4.anonmode = ZERO;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random&quot;,
					 sizeof(&quot;random&quot;)-1)) {
				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
			} else if(!es_strbufcmp(pvals[i].val.d.estr, (uchar*)&quot;random-consistent&quot;,
					 sizeof(&quot;random-consistent&quot;)-1)) {
				pData-&gt;embeddedIPv4.anonmode = RANDOMINT;
				pData-&gt;embeddedIPv4.randConsis = 1;
			} else {
				parser_errmsg(&quot;mmanon: configuration error, unknown option for ipv6.anonmode, &quot;
				&quot;will use \&quot;zero\&quot;\n&quot;);
			}
		} else {
			parser_errmsg(&quot;mmanon: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}

	int bHadBitsErr = 0;
	if(pData-&gt;ipv4.mode == SIMPLE) {
		if(pData-&gt;ipv4.bits &lt; 8 &amp;&amp; pData-&gt;ipv4.bits &gt; -1) {
			pData-&gt;ipv4.bits = 8;
			bHadBitsErr = 1;
		} else if(pData-&gt;ipv4.bits &lt; 16 &amp;&amp; pData-&gt;ipv4.bits &gt; 8) {
			pData-&gt;ipv4.bits = 16;
			bHadBitsErr = 1;
		} else if(pData-&gt;ipv4.bits &lt; 24 &amp;&amp; pData-&gt;ipv4.bits &gt; 16) {
			pData-&gt;ipv4.bits = 24;
			bHadBitsErr = 1;
		} else if((pData-&gt;ipv4.bits != 32 &amp;&amp; pData-&gt;ipv4.bits &gt; 24) || pData-&gt;ipv4.bits &lt; 0) {
			pData-&gt;ipv4.bits = 32;
			bHadBitsErr = 1;
		}
		if(bHadBitsErr) {
			LogError(0, RS_RET_INVLD_ANON_BITS,
				&quot;mmanon: invalid number of ipv4 bits &quot;
				&quot;in simple mode, corrected to %d&quot;,
				pData-&gt;ipv4.bits);
		}
	}

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume


static int
getHexVal(char c)
{
	if('0' &lt;= c &amp;&amp; c &lt;= '9') {
		return c - '0';
	} else if('a' &lt;= c &amp;&amp; c &lt;= 'f') {
		return (c - 'a') + 10;
	} else if('A' &lt;= c &amp;&amp; c &lt;= 'F') {
		return (c - 'A') + 10;
	} else {
		return -1;
	}
}


/* returns -1 if no integer found, else integer */
static int64_t
getPosInt(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int64_t val = 0;
	size_t i;
	for(i = 0 ; i &lt; buflen ; i++) {
		if('0' &lt;= buf[i] &amp;&amp; buf[i] &lt;= '9')
			val = val*10 + buf[i]-'0';
		else
			break;
	}
	*nprocessed = i;
	if(i == 0)
		val = -1;
	return val;
}

/* 1 - is IPv4, 0 not */

static int
syntax_ipv4(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int64_t val;
	size_t nproc;
	size_t i;
	int r = 0;

	val = getPosInt(buf, buflen, &amp;i);
	if(val &lt; 0 || val &gt; 255)
		goto done;

	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;

	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;

	if(i &gt;= buflen || buf[i] != '.') {
		goto done;
	}
	i++;
	val = getPosInt(buf+i, buflen-i, &amp;nproc);
	if(val &lt; 0 || val &gt; 255)
		goto done;
	i += nproc;

	*nprocessed = i;
	r = 1;

done:
	return r;
}


static int
isValidHexNum(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed,
	int handleDot)
{
	size_t idx = 0;
	int cyc = 0;

	while(idx &lt; buflen) {
		switch(buf[idx]) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':

		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':

		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
			cyc++;
			(*nprocessed)++;
			if(cyc == 5) {
				goto done;
			}
			break;
		case '.':
			if(handleDot &amp;&amp; cyc == 0) {
				(*nprocessed)++;
				cyc = -2;
			}
			goto done;
		case ':':
			if(cyc == 0) {
				(*nprocessed)++;
				cyc = -1;
			}
			goto done;
		default:
			goto done;
		}
		idx++;
	}
done:
	return cyc;
}


static int
syntax_ipv6(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed)
{
	int lastSep = 0;
	sbool hadAbbrev = 0;
	sbool lastAbbrev = 0;
	int ipParts = 0;
	int numLen;
	int isIP = 0;

	while(*nprocessed &lt; buflen) {
		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 0);
		if(numLen &gt; 0 &amp;&amp; numLen &lt; 5) {  //found a valid num
			if((ipParts == 7 &amp;&amp; hadAbbrev) || ipParts &gt; 7) {
				isIP = 0;
				goto done;
			}
			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
				isIP = 0;
				goto done;
			}
			lastSep = 0;
			lastAbbrev = 0;
			ipParts++;
		} else if (numLen &lt; 0) {  //':'
			if(lastSep) {
				if(hadAbbrev) {
					isIP = 0;
					goto done;
				} else {
					hadAbbrev = 1;
					lastAbbrev = 1;
				}
			}
			lastSep = 1;
		} else if (numLen == 5) {  // maybe truncated with port
			if(hadAbbrev &amp;&amp; ipParts &gt;= 2) {
				isIP = 1;
				/* we need to go back 6 chars:
				 * 5 digits plus leading &quot;:&quot; which designates port!
				 */
				*nprocessed -= 6;
			} else {
				isIP = 0;
				/* nprocessed need not be corrected - it's only used if isIP == 1 */
			}
			goto done;
		} else {  //no valid num
			if(lastSep) {
				if(lastAbbrev &amp;&amp; ipParts &lt; 8) {
					isIP = 1;
					goto done;
				}
				isIP = 0;
				goto done;
			}
			if((ipParts == 8 &amp;&amp; !hadAbbrev) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
				isIP = 1;
				goto done;
			} else {
				isIP = 0;
				goto done;
			}
		}
		if(ipParts == 8 &amp;&amp; !hadAbbrev) {
			isIP = 1;
			goto done;
		}
	}

	if((!lastSep &amp;&amp; (ipParts == 8 &amp;&amp; !hadAbbrev)) || (ipParts &lt; 8 &amp;&amp; hadAbbrev)) {
		isIP = 1;
	}

done:
	return isIP;
}


static unsigned
ipv42num(const char *str)
{
	unsigned num[4] = {0, 0, 0, 0};
	unsigned value = -1;
	size_t len = strlen(str);
	int cyc = 0;
	for(unsigned i = 0 ; i &lt; len ; i++) {
		switch(str[i]) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			num[cyc] = num[cyc]*10+(str[i]-'0');
			break;
		case '.':
			cyc++;
			break;
		}
	}

	value = num[0]*256*256*256+num[1]*256*256+num[2]*256+num[3];
	return(value);
}


static unsigned
code_int(unsigned ip, wrkrInstanceData_t *pWrkrData){
	unsigned random;
	unsigned long long shiftIP_subst = ip;
	// variable needed because shift operation of 32nd bit in unsigned does not work
	switch(pWrkrData-&gt;pData-&gt;ipv4.mode) {
	case ZERO:
		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
		return (unsigned)shiftIP_subst;
	case RANDOMINT:
		shiftIP_subst = ((shiftIP_subst&gt;&gt;(pWrkrData-&gt;pData-&gt;ipv4.bits))&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits));
		// multiply the random number between 0 and 1 with a mask of (2^n)-1:
		random = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*
			((1ull&lt;&lt;(pWrkrData-&gt;pData-&gt;ipv4.bits))-1));
		return (unsigned)shiftIP_subst + random;
	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
	default:
		LogError(0, RS_RET_INTERNAL_ERROR, &quot;mmanon: unexpected code path reached in code_int function&quot;);
		return 0;
	}
}


static int
num2ipv4(unsigned num, char *str) {
	int numip[4];
	size_t len;
	for(int i = 0 ; i &lt; 4 ; i++){
		numip[i] = num % 256;
		num = num / 256;
	}
	len = snprintf(str, 16, &quot;%d.%d.%d.%d&quot;, numip[3], numip[2], numip[1], numip[0]);
	return len;
}


static void
getip(uchar *start, size_t end, char *address)
{
	size_t i;

	for(i = 0; i &lt; end; i++){
		address[i] = *(start+i);
	}
	address[i] = '\0';
}

/* in case of error with malloc causing abort of function, the
 * string at the target of address remains the same */
static rsRetVal
findip(char* address, wrkrInstanceData_t *pWrkrData)
{
	DEFiRet;
	int i;
	unsigned num;
	union node* current;
	union node* Last;
	int MoreLess;
	char* CurrentCharPtr;

	current = pWrkrData-&gt;pData-&gt;ipv4.Root;
	num = ipv42num(address);
	for(i = 0; i &lt; 31; i++){
		if(pWrkrData-&gt;pData-&gt;ipv4.Root == NULL) {
			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
			pWrkrData-&gt;pData-&gt;ipv4.Root = current;
		}
		Last = current;
		if((num &gt;&gt; (31 - i)) &amp; 1){
			current = current-&gt;pointer.more;
			MoreLess = 1;
		} else {
			current = current-&gt;pointer.less;
			MoreLess = 0;
		}
		if(current == NULL){
			CHKmalloc(current = (union node*)calloc(1, sizeof(union node)));
			if(MoreLess == 1){
				Last-&gt;pointer.more = current;
			} else {
				Last-&gt;pointer.less = current;
			}
		}
	}
	if(num &amp; 1){
		CurrentCharPtr = current-&gt;ips.ip_high;
	} else {
		CurrentCharPtr = current-&gt;ips.ip_low;
	}
	if(CurrentCharPtr[0] != '\0'){
		strcpy(address, CurrentCharPtr);
	} else {
		num = code_int(num, pWrkrData);
		num2ipv4(num, CurrentCharPtr);
		strcpy(address, CurrentCharPtr);
	}
finalize_it:
	RETiRet;
}


static void
process_IPv4 (char* address, wrkrInstanceData_t *pWrkrData)
{
	unsigned num;

	if(pWrkrData-&gt;pData-&gt;ipv4.randConsis){
		findip(address, pWrkrData);
	}else {
		num = ipv42num(address);
		num = code_int(num, pWrkrData);
		num2ipv4(num, address);
	}
}


static void
simpleAnon(wrkrInstanceData_t *const pWrkrData, uchar *const msg, int *const hasChanged, int iplen)
{
	int maxidx = iplen - 1;

	int j = -1;
	for(int i = (pWrkrData-&gt;pData-&gt;ipv4.bits / 8); i &gt; 0; i--) {
		j++;
		while('0' &lt;= msg[maxidx - j] &amp;&amp; msg[maxidx - j] &lt;= '9') {
			if(msg[maxidx - j] != pWrkrData-&gt;pData-&gt;ipv4.replaceChar) {
				msg[maxidx - j] = pWrkrData-&gt;pData-&gt;ipv4.replaceChar;
				*hasChanged = 1;
			}
			j++;
		}
	}
}


static void
anonipv4(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	char address[16];
	char caddress[16];
	int offset = *idx;
	uchar* msgcpy = *msg;
	size_t iplen;
	size_t caddresslen;
	int oldLen = *pLenMsg;

	if(syntax_ipv4((*msg) + offset, *pLenMsg - offset, &amp;iplen)) {
		if(pWrkrData-&gt;pData-&gt;ipv4.mode == SIMPLE) {
			simpleAnon(pWrkrData, *msg + *idx, hasChanged, iplen);
			*idx += iplen;
			return;
		}

		assert(iplen &lt; sizeof(address));
		getip(*msg + offset, iplen, address);
		offset += iplen;
		strcpy(caddress, address);
		process_IPv4(caddress, pWrkrData);
		caddresslen = strlen(caddress);
		*hasChanged = 1;

		if(caddresslen != strlen(address)) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)strlen(address));
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, caddress, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}


static void
code_ipv6_int(struct ipv6_int* ip, wrkrInstanceData_t *pWrkrData, int useEmbedded)
{
	unsigned long long randlow = 0;
	unsigned long long randhigh = 0;
	unsigned tmpRand;
	int fullbits;

	int bits = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.bits : pWrkrData-&gt;pData-&gt;ipv6.bits;
	enum mode anonmode = useEmbedded ? pWrkrData-&gt;pData-&gt;embeddedIPv4.anonmode : pWrkrData-&gt;pData-&gt;ipv6.anonmode;

	if(bits == 128) { //has to be handled separately, since shift
						 //128 bits doesn't work on unsigned long long
		ip-&gt;high = 0;
		ip-&gt;low = 0;
	} else if(bits &gt; 64) {
		ip-&gt;low = 0;
		ip-&gt;high = (ip-&gt;high &gt;&gt; (bits - 64)) &lt;&lt;  (bits - 64);
	} else if(bits == 64) {
		ip-&gt;low = 0;
	} else {
		ip-&gt;low = (ip-&gt;low &gt;&gt; bits) &lt;&lt; bits;
	}
	switch(anonmode) {
	case ZERO:
		break;
	case RANDOMINT:
		if(bits == 128) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;high &lt;&lt;= 8;
				ip-&gt;high |= tmpRand;

				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}
		} else if(bits &gt; 64) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}

			bits -= 64;
			fullbits = bits / 8;
			bits = bits % 8;
			while(fullbits &gt; 0) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				randhigh &lt;&lt;= 8;
				randhigh |= tmpRand;
				fullbits--;
			}
			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
			randhigh &lt;&lt;= bits;
			randhigh |= tmpRand;

			ip-&gt;high |= randhigh;
		} else if(bits == 64) {
			for(int i = 0; i &lt; 8; i++) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				ip-&gt;low &lt;&lt;= 8;
				ip-&gt;low |= tmpRand;
			}
		} else {
			fullbits = bits / 8;
			bits = bits % 8;
			while(fullbits &gt; 0) {
				tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*0xff);
				randlow &lt;&lt;= 8;
				randlow |= tmpRand;
				fullbits--;
			}
			tmpRand = (unsigned)((rand_r(&amp;(pWrkrData-&gt;randstatus))/(double)RAND_MAX)*((1 &lt;&lt; bits) - 1));
			randlow &lt;&lt;= bits;
			randlow |= tmpRand;

			ip-&gt;low |= randlow;
		}
		break;
	case SIMPLE:  //can't happen, since this case is caught at the start of anonipv4()
	default:
		LogError(0, RS_RET_INTERNAL_ERROR, &quot;mmanon: unexpected code path reached in code_int function&quot;);
	}
}


//separate function from recognising ipv6, since the recognition might get more
//complex. This function always stays
//the same, since it always gets an valid ipv6 input
static void
ipv62num(char* const address, const size_t iplen, struct ipv6_int* const ip)
{
	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	int cyc = 0;
	int dots = 0;
	int val;
	unsigned i;

	for(i = 0; i &lt; iplen &amp;&amp; dots &lt; 2; i++) {
		val = getHexVal(address[i]);
		if(val == -1) {
			dots++;
			if(dots &lt; 2) {
				cyc++;
			}
		} else {
			num[cyc] = num[cyc] * 16 + val;
			dots = 0;
		}
	}
	if(dots == 2) {
		if(i &lt; iplen - 1) {
			int shift = 0;
			cyc = 7;
			for(unsigned j = iplen - 1; j &gt;= i; j--) {
				val = getHexVal(address[j]);
				if(val == -1) {
					cyc--;
					shift = 0;
				} else {
					val &lt;&lt;= shift;
					shift += 4;
					num[cyc] += val;
				}
			}
		} else {
			while(cyc &lt; 8) {
				num[cyc] = 0;
				cyc++;
			}
		}
	}

	for(i = 0; i &lt; 4; i++) {
		ip-&gt;high &lt;&lt;= 16;
		ip-&gt;high |= num[i];
	}
	while(i &lt; 8) {
		ip-&gt;low &lt;&lt;= 16;
		ip-&gt;low |= num[i];
		i++;
	}
}


static void
num2ipv6 (struct ipv6_int* ip, char* address)
{
	int num[8];
	int i;

	for(i = 7; i &gt; 3; i--) {
		num[i] = ip-&gt;low &amp; 0xffff;
		ip-&gt;low &gt;&gt;= 16;
	}
	while(i &gt; -1) {
		num[i] = ip-&gt;high &amp; 0xffff;
		ip-&gt;high &gt;&gt;= 16;
		i--;
	}

	snprintf(address, 40, &quot;%x:%x:%x:%x:%x:%x:%x:%x&quot;, num[0], num[1], num[2], num[3], num[4], num[5],
		num[6], num[7]);
}


static int
keys_equal_fn(void* key1, void* key2)
{
	struct ipv6_int *const k1 = (struct ipv6_int*) key1;
	struct ipv6_int *const k2 = (struct ipv6_int*) key2;

	return((k1-&gt;high == k2-&gt;high) &amp;&amp; (k1-&gt;low == k2-&gt;low));
}


static unsigned
hash_from_key_fn (void* k)
{
	struct ipv6_int *const key = (struct ipv6_int*) k;
	unsigned hashVal;

	hashVal = (key-&gt;high &amp; 0xFFC00000) | (key-&gt;low &amp; 0x3FFFFF);
	return hashVal;
}


static void
num2embedded (struct ipv6_int* ip, char* address)
{
	int num[8];
	int i;

	for(i = 7; i &gt; 3; i--) {
		num[i] = ip-&gt;low &amp; 0xffff;
		ip-&gt;low &gt;&gt;= 16;
	}
	while(i &gt; -1) {
		num[i] = ip-&gt;high &amp; 0xffff;
		ip-&gt;high &gt;&gt;= 16;
		i--;
	}

	snprintf(address, 46, &quot;%x:%x:%x:%x:%x:%x:%d.%d.%d.%d&quot;, num[0], num[1], num[2], num[3], num[4], num[5],
		(num[6] &amp; 0xff00) &gt;&gt; 8, num[6] &amp; 0xff, (num[7] &amp; 0xff00) &gt;&gt; 8, num[7] &amp; 0xff);
}


static rsRetVal
findIPv6(struct ipv6_int* num, char* address, wrkrInstanceData_t *const pWrkrData, int useEmbedded)
{
	struct ipv6_int* hashKey = NULL;
	DEFiRet;
	struct hashtable* hash = useEmbedded? pWrkrData-&gt;pData-&gt;embeddedIPv4.hash : pWrkrData-&gt;pData-&gt;ipv6.hash;


	if(hash == NULL) {
		CHKmalloc(hash = create_hashtable(512, hash_from_key_fn, keys_equal_fn, NULL));
		if(useEmbedded) {
			pWrkrData-&gt;pData-&gt;embeddedIPv4.hash = hash;
		} else {
			pWrkrData-&gt;pData-&gt;ipv6.hash = hash;
		}
	}

	char* val = (char*)(hashtable_search(hash, num));

	if(val != NULL) {
		strcpy(address, val);
	} else {
		CHKmalloc(hashKey = (struct ipv6_int*) malloc(sizeof(struct ipv6_int)));
		hashKey-&gt;low = num-&gt;low;
		hashKey-&gt;high = num-&gt;high;

		if(useEmbedded) {
			code_ipv6_int(num, pWrkrData, 1);
			num2embedded(num, address);
		} else {
			code_ipv6_int(num, pWrkrData, 0);
			num2ipv6(num, address);
		}
		char* hashString;
		CHKmalloc(hashString = strdup(address));

		if(!hashtable_insert(hash, hashKey, hashString)) {
			DBGPRINTF(&quot;hashtable error: insert to %s-table failed&quot;,
				useEmbedded ? &quot;embedded ipv4&quot; : &quot;ipv6&quot;);
			free(hashString);
			ABORT_FINALIZE(RS_RET_ERR);
		}
		hashKey = NULL;
	}
finalize_it:
	free(hashKey);
	RETiRet;
}


static void
process_IPv6 (char* address, wrkrInstanceData_t *pWrkrData, const size_t iplen)
{
	struct ipv6_int num = {0, 0};

	ipv62num(address, iplen, &amp;num);

	if(pWrkrData-&gt;pData-&gt;ipv6.randConsis) {
		findIPv6(&amp;num, address, pWrkrData, 0);
	} else {
		code_ipv6_int(&amp;num, pWrkrData, 0);
		num2ipv6(&amp;num, address);
	}
}


static void
anonipv6(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	size_t iplen = 0;
	int offset = *idx;
	char address[40];
	uchar* msgcpy = *msg;
	size_t caddresslen;
	size_t oldLen = *pLenMsg;

	int syn = syntax_ipv6(*msg + offset, *pLenMsg - offset, &amp;iplen);
	if(syn) {
		assert(iplen &lt; sizeof(address));  //has to be &lt; instead of &lt;= since address includes space for a '\0'
		getip(*msg + offset, iplen, address);
		offset += iplen;
		process_IPv6(address, pWrkrData, iplen);

		caddresslen = strlen(address);
		*hasChanged = 1;

		if(caddresslen != iplen) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, address, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}


static size_t
findV4Start(const uchar *const __restrict__ buf, size_t dotPos)
{
	while(dotPos &gt; 0) {
		if(buf[dotPos] == ':') {
			return dotPos + 1;
		}
		dotPos--;
	}
	return -1; //should not happen
}


static int
syntax_embedded(const uchar *const __restrict__ buf,
	const size_t buflen,
	size_t *const __restrict__ nprocessed,
	size_t * v4Start)
{
	int lastSep = 0;
	sbool hadAbbrev = 0;
	int ipParts = 0;
	int numLen;
	int isIP = 0;
	size_t ipv4Len;

	while(*nprocessed &lt; buflen) {
		numLen = isValidHexNum(buf + *nprocessed, buflen - *nprocessed, nprocessed, 1);
		if(numLen &gt; 0) {  //found a valid num
			if((ipParts == 6 &amp;&amp; hadAbbrev) || ipParts &gt; 6) {  //is 6 since the first part of
									  //IPv4 will also result in a valid hexvalue
				isIP = 0;
				goto done;
			}
			if (ipParts == 0 &amp;&amp; lastSep &amp;&amp; !hadAbbrev) {
				isIP = 0;
				goto done;
			}
			lastSep = 0;
			ipParts++;
		} else if (numLen == -1) {  //':'
			if(lastSep) {
				if(hadAbbrev) {
					isIP = 0;
					goto done;
				} else {
					hadAbbrev = 1;
				}
			}
			lastSep = 1;
		} else if (numLen == -2) {  //'.'
			if (lastSep || (ipParts == 0 &amp;&amp; hadAbbrev) || (ipParts &lt;= 6 &amp;&amp; !hadAbbrev)) {
				isIP = 0;
				goto done;
			}
			*v4Start = findV4Start(buf, (*nprocessed) - 1);
			if(syntax_ipv4(buf + (*v4Start), buflen, &amp;ipv4Len)) {
				*nprocessed += (ipv4Len - ((*nprocessed) - (*v4Start)));
				isIP = 1;
				goto done;
			} else {
				isIP = 0;
				goto done;
			}
		} else {  //no valid num
			isIP = 0;
			goto done;
		}
	}

	isIP = 0;

done:
	return isIP;
}


static void
embedded2num(char* address, size_t v4Start, struct ipv6_int* ip)
{
	int num[8] = {0, 0, 0, 0, 0, 0, 0, 0};
	int cyc = 0;
	int dots = 0;
	int val;
	unsigned i;

	unsigned v4Val = ipv42num(address + v4Start);
	num[7] = v4Val &amp; 0xffff;
	num[6] = (v4Val &amp; 0xffff0000) &gt;&gt; 16;

	for(i = 0; i &lt; v4Start &amp;&amp; dots &lt; 2; i++) {
		val = getHexVal(address[i]);
		if(val == -1) {
			dots++;
			if(dots &lt; 2) {
				cyc++;
			}
		} else {
			num[cyc] = num[cyc] * 16 + val;
			dots = 0;
		}
	}
	if(dots == 2) {
		if(i &lt; v4Start) {
			int shift = 0;
			cyc = 5;
			for(unsigned j = v4Start - 1; j &gt;= i; j--) {
				val = getHexVal(address[j]);
				if(val == -1) {
					cyc--;
					shift = 0;
				} else {
					val &lt;&lt;= shift;
					shift += 4;
					num[cyc] += val;
				}
			}
		} else {
			while(cyc &lt; 6) {
				num[cyc] = 0;
				cyc++;
			}
		}
	}

	for(i = 0; i &lt; 4; i++) {
		ip-&gt;high &lt;&lt;= 16;
		ip-&gt;high |= num[i];
	}
	while(i &lt; 8) {
		ip-&gt;low &lt;&lt;= 16;
		ip-&gt;low |= num[i];
		i++;
	}
}


static void
process_embedded (char* address, wrkrInstanceData_t *pWrkrData, size_t v4Start)
{
	struct ipv6_int num = {0, 0};

	embedded2num(address, v4Start, &amp;num);

	if(pWrkrData-&gt;pData-&gt;embeddedIPv4.randConsis) {
		findIPv6(&amp;num, address, pWrkrData, 1);
	} else {
		code_ipv6_int(&amp;num, pWrkrData, 1);
		num2embedded(&amp;num, address);
	}
}


static void
anonEmbedded(wrkrInstanceData_t *pWrkrData, uchar **msg, int *pLenMsg, int *idx, int *hasChanged)
{
	size_t iplen = 0;
	int offset = *idx;
	char address[46];
	uchar* msgcpy = *msg;
	unsigned caddresslen;
	size_t oldLen = *pLenMsg;
	size_t v4Start;

	int syn = syntax_embedded(*msg + offset, *pLenMsg - offset, &amp;iplen, &amp;v4Start);
	if(syn) {
		assert(iplen &lt; sizeof(address));
		getip(*msg + offset, iplen, address);
		offset += iplen;
		process_embedded(address, pWrkrData, v4Start);

		caddresslen = strlen(address);
		*hasChanged = 1;

		if(caddresslen != iplen) {
			*pLenMsg = *pLenMsg + ((int)caddresslen - (int)iplen);
			*msg = (uchar*) malloc(*pLenMsg);
			memcpy(*msg, msgcpy, *idx);
		}
		memcpy(*msg + *idx, address, caddresslen);
		*idx = *idx + caddresslen;
		if(*idx &lt; *pLenMsg) {
			memcpy(*msg + *idx, msgcpy + offset, oldLen - offset);
		}
		if(msgcpy != *msg) {
			free(msgcpy);
		}
	}
}

BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
	uchar *msg;
	int lenMsg;
	int i;
	int hasChanged = 0;
CODESTARTdoAction
	lenMsg = getMSGLen(pMsg);
	msg = (uchar*)strdup((char*)getMSG(pMsg));

	for(i = 0 ; i &lt;= lenMsg - 2 ; i++) {
		if(pWrkrData-&gt;pData-&gt;embeddedIPv4.enable) {
			anonEmbedded(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
		if(pWrkrData-&gt;pData-&gt;ipv4.enable) {
			anonipv4(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
		if(pWrkrData-&gt;pData-&gt;ipv6.enable) {
			anonipv6(pWrkrData, &amp;msg, &amp;lenMsg, &amp;i, &amp;hasChanged);
		}
	}
	if(hasChanged) {
		MsgReplaceMSG(pMsg, msg, lenMsg);
	}
	free(msg);
ENDdoAction


NO_LEGACY_CONF_parseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt



BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF(&quot;mmanon: module compiled with rsyslog version %s.\n&quot;, VERSION);
ENDmodInit
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>omstdout.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* omstdout.c
 * send all output to stdout - this is primarily a test driver (but may
 * be used for weired use cases). Not tested for robustness!
 *
 * NOTE: read comments in module-template.h for more specifics!
 *
 * File begun on 2009-03-19 by RGerhards
 *
 * Copyright 2009-2017 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &quot;rsyslog.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;omstdout&quot;)

static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);

/* static data */

/* internal structures
 */
DEF_OMOD_STATIC_DATA

/* config variables */

typedef struct _instanceData {
	int bUseArrayInterface;		/* uses action use array instead of string template interface? */
	int bEnsureLFEnding;		/* ensure that a linefeed is written at the end of EACH
					record (test aid for nettester) */
	uchar *templateName;
} instanceData;

typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;

typedef struct configSettings_s {
	int bUseArrayInterface;		/* shall action use array instead of string template interface? */
	int bEnsureLFEnding;
	int templateName;
} configSettings_t;
static configSettings_t cs;

<A NAME="0"></A>/* tables for interfacing with the v6 config system */
/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3198-0.html#0',2,'match3198-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;ensurelfending&quot;, eCmdHdlrBinary, 0 },
	{ &quot;template&quot;, eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</B></FONT>

struct modConfData_s {
	rsconf_t *pConf;	/* our overall config object */
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current exec process */



BEGINinitConfVars		/* (re)set config variables to default values */
CODESTARTinitConfVars
	resetConfigVariables(NULL, NULL);
ENDinitConfVars

BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance


BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad


BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; /* done loading */
ENDendCnfLoad

BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf

BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf

BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINfreeInstance
CODESTARTfreeInstance
ENDfreeInstance


BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance


BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf(&quot;omstdout\n&quot;);
	dbgprintf(&quot;\tensureLFEnding='%d'\n&quot;, pData-&gt;bEnsureLFEnding);
	dbgprintf(&quot;\ttemplate='%s'\n&quot;, pData-&gt;templateName);
ENDdbgPrintInstInfo


BEGINtryResume
CODESTARTtryResume
ENDtryResume

BEGINdoAction
	char **szParams;
	char *toWrite;
	int iParamVal;
	int iParam;
	int iBuf;
	char szBuf[65564];
	size_t len;
	int r;
CODESTARTdoAction
dbgprintf(&quot;omstdout: in doAction\n&quot;);
	if(pWrkrData-&gt;pData-&gt;bUseArrayInterface) {
dbgprintf(&quot;omstdout: in ArrayInterface\n&quot;);
		/* if we use array passing, we need to put together a string
		 * ourselves. At this point, please keep in mind that omstdout is
		 * primarily a testing aid. Other modules may do different processing
		 * if they would like to support downlevel versions which do not support
		 * array-passing, but also use that interface on cores who do...
		 * So this code here is also more or less an example of how to do that.
		 * rgerhards, 2009-04-03
		 */
		szParams = (char**)(void*) (ppString[0]);
		/* In array-passing mode, ppString[] contains a NULL-terminated array
		 * of char *pointers.
		 */
		iParam = 0;
		iBuf = 0;
		while(szParams[iParam] != NULL &amp;&amp; iBuf &lt; (int)sizeof(szBuf)-1) {
			if(iParam &gt; 0)
				szBuf[iBuf++] = ','; /* all but first need a delimiter */
			iParamVal = 0;
			while(szParams[iParam][iParamVal] != '\0' &amp;&amp; iBuf &lt; (int) sizeof(szBuf)-1) {
				szBuf[iBuf++] = szParams[iParam][iParamVal++];
			}
			++iParam;
		}
		szBuf[iBuf] = '\0';
		toWrite = szBuf;
	} else {
dbgprintf(&quot;omstdout: in else\n&quot;);
		toWrite = (char*) ppString[0];
	}
	len = strlen(toWrite);
	/* the following if's are just to silence compiler warnings. If someone
	 * actually intends to use this module in production (why???), this code
	 * needs to be more solid. -- rgerhards, 2012-11-28
	 */
dbgprintf(&quot;omstdout: len: %d, toWrite: %s\n&quot;, (int) len, toWrite);
	if((r = write(1, toWrite, len)) != (int) len) { /* 1 is stdout! */
		DBGPRINTF(&quot;omstdout: error %d writing to stdout[%zd]: %s\n&quot;,
			r, len, toWrite);
	}
	if(pWrkrData-&gt;pData-&gt;bEnsureLFEnding &amp;&amp; toWrite[len-1] != '\n') {
		if((r = write(1, &quot;\n&quot;, 1)) != 1) { /* write missing LF */
			DBGPRINTF(&quot;omstdout: error %d writing \\n to stdout\n&quot;,
				r);
		}
	}
ENDdoAction

static void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;bEnsureLFEnding = 1;
	pData-&gt;templateName = (uchar*) &quot;RSYSLOG_FileFormat&quot;;
	pData-&gt;bUseArrayInterface = 0;
}


BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
	int bDestructPValsOnExit;
	uchar *tplToUse;
CODESTARTnewActInst
	DBGPRINTF(&quot;newActInst (omstdout)\n&quot;);

	bDestructPValsOnExit = 0;
	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;omstdout: error reading &quot;
				&quot;config parameters&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	bDestructPValsOnExit = 1;

	if(Debug) {
		dbgprintf(&quot;action param blk in omstdout:\n&quot;);
		cnfparamsPrint(&amp;actpblk, pvals);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

<A NAME="1"></A>	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3198-0.html#1',2,'match3198-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(actpblk.descr[i].name, &quot;ensurelfending&quot;)) {
			pData-&gt;bEnsureLFEnding = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, &quot;template&quot;)) {
			pData-&gt;templateName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
		} else {
			DBGPRINTF(&quot;omstdout: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, actpblk.descr[i].name);
		}
	}


	CODE_STD_STRING_REQUESTnewActInst(1)
	//TODO: make the template a parameter
	tplToUse = (uchar*) strdup((pData-&gt;templateName == NULL) ? &quot;RSYSLOG_FileFormat&quot; : (char *)pData-&gt;templateName);
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
CODE_STD_FINALIZERnewActInst
	if(bDestructPValsOnExit)
		cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst



BEGINparseSelectorAct
	int iTplOpts;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us */
	if(strncmp((char*) p, &quot;:omstdout:&quot;, sizeof(&quot;:omstdout:&quot;) - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}

	/* ok, if we reach this point, we have something for us */
	p += sizeof(&quot;:omstdout:&quot;) - 1; /* eat indicator sequence  (-1 because of '\0'!) */
	CHKiRet(createInstance(&amp;pData));

	/* check if a non-standard template is to be applied */
	if(*(p-1) == ';')
		--p;
	iTplOpts = (cs.bUseArrayInterface == 0) ? 0 : OMSR_TPL_AS_ARRAY;
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, iTplOpts, (uchar*) &quot;RSYSLOG_FileFormat&quot;));
	pData-&gt;bUseArrayInterface = cs.bUseArrayInterface;
	pData-&gt;bEnsureLFEnding = cs.bEnsureLFEnding;
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct


BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_CNFNAME_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt



/* Reset config variables for this module to default values.
 */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	cs.bUseArrayInterface = 0;
	cs.bEnsureLFEnding = 1;
	RETiRet;
}


BEGINmodInit()
	rsRetVal localRet;
	rsRetVal (*pomsrGetSupportedTplOpts)(unsigned long *pOpts);
	unsigned long opts;
	int bArrayPassingSupported;		/* does core support template passing as an array? */
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	/* check if the rsyslog core supports parameter passing code */
	bArrayPassingSupported = 0;
	localRet = pHostQueryEtryPt((uchar*)&quot;OMSRgetSupportedTplOpts&quot;, &amp;pomsrGetSupportedTplOpts);
	if(localRet == RS_RET_OK) {
		/* found entry point, so let's see if core supports array passing */
		CHKiRet((*pomsrGetSupportedTplOpts)(&amp;opts));
		if(opts &amp; OMSR_TPL_AS_ARRAY)
			bArrayPassingSupported = 1;
	} else if(localRet != RS_RET_ENTRY_POINT_NOT_FOUND) {
		ABORT_FINALIZE(localRet); /* Something else went wrong, what is not acceptable */
	}
	DBGPRINTF(&quot;omstdout: array-passing is %ssupported by rsyslog core.\n&quot;, bArrayPassingSupported ? &quot;&quot; : &quot;not &quot;);

	if(bArrayPassingSupported) {
		/* enable config comand only if core supports it */
		CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionomstdoutarrayinterface&quot;, 0, eCmdHdlrBinary, NULL,
			                   &amp;cs.bUseArrayInterface, STD_LOADABLE_MODULE_ID));
	}
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;actionomstdoutensurelfending&quot;, 0, eCmdHdlrBinary, NULL,
				   &amp;cs.bEnsureLFEnding, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
				    resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit

/* vi:set ai:
 */
</PRE>
</div>
  </div>
</body>
</html>
