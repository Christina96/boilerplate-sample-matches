
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 44, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_monero.h</h3>
            <pre><code>1  #ifndef XMRIG_CRYPTONIGHT_MONERO_H
2  #define XMRIG_CRYPTONIGHT_MONERO_H
3  #include <fenv.h>
4  #include <math.h>
5  #ifndef XMRIG_ARM
6  #   define VARIANT1_INIT(part) \
7      uint64_t tweak1_2_##part = 0; \
8      if (BASE == Algorithm::CN_1) { \
9          tweak1_2_##part = (*reinterpret_cast<const uint64_t*>(input + 35 + part * size) ^ \
10                            *(reinterpret_cast<const uint64_t*>(ctx[part]->state) + 24)); \
11      }
12  #else
13  #   define VARIANT1_INIT(part) \
14      uint64_t tweak1_2_##part = 0; \
15      if (BASE == Algorithm::CN_1) { \
16          memcpy(&tweak1_2_##part, input + 35 + part * size, sizeof tweak1_2_##part); \
17          tweak1_2_##part ^= *(reinterpret_cast<const uint64_t*>(ctx[part]->state) + 24); \
18      }
19  #endif
20  #define VARIANT1_1(p) \
21      if (BASE == Algorithm::CN_1) { \
22          const uint8_t tmp = reinterpret_cast<const uint8_t*>(p)[11]; \
23          static const uint32_t table = 0x75310; \
24          const uint8_t index = (((tmp >> 3) & 6) | (tmp & 1)) << 1; \
25          ((uint8_t*)(p))[11] = tmp ^ ((table >> index) & 0x30); \
26      }
27  #define VARIANT1_2(p, part) \
28      if (BASE == Algorithm::CN_1) { \
29          (p) ^= tweak1_2_##part; \
30      }
31  #ifndef XMRIG_ARM
32  #   define VARIANT2_INIT(part) \
33      __m128i division_result_xmm_##part = _mm_cvtsi64_si128(static_cast<int64_t>(h##part[12])); \
34      __m128i sqrt_result_xmm_##part     = _mm_cvtsi64_si128(static_cast<int64_t>(h##part[13]));
35  #ifdef _MSC_VER
36  #   define VARIANT2_SET_ROUNDING_MODE() if (BASE == Algorithm::CN_2) { _control87(RC_DOWN, MCW_RC); }
37  #   define RESTORE_ROUNDING_MODE() _control87(RC_NEAR, MCW_RC);
38  #else
39  #   define VARIANT2_SET_ROUNDING_MODE() if (BASE == Algorithm::CN_2) { fesetround(FE_DOWNWARD); }
40  #   define RESTORE_ROUNDING_MODE() fesetround(FE_TONEAREST);
41  #endif
42  #   define VARIANT2_INTEGER_MATH(part, cl, cx) \
43      do { \
44          const uint64_t sqrt_result = static_cast<uint64_t>(_mm_cvtsi128_si64(sqrt_result_xmm_##part)); \
45          const uint64_t cx_0 = _mm_cvtsi128_si64(cx); \
46          cl ^= static_cast<uint64_t>(_mm_cvtsi128_si64(division_result_xmm_##part)) ^ (sqrt_result << 32); \
47          const uint32_t d = static_cast<uint32_t>(cx_0 + (sqrt_result << 1)) | 0x80000001UL; \
48          const uint64_t cx_1 = _mm_cvtsi128_si64(_mm_srli_si128(cx, 8)); \
49          const uint64_t division_result = static_cast<uint32_t>(cx_1 / d) + ((cx_1 % d) << 32); \
50          division_result_xmm_##part = _mm_cvtsi64_si128(static_cast<int64_t>(division_result)); \
51          sqrt_result_xmm_##part = int_sqrt_v2(cx_0 + division_result); \
52      } while (0)
53  #   define VARIANT2_SHUFFLE(base_ptr, offset, _a, _b, _b1, _c, reverse) \
54      do { \
55          const __m128i chunk1 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ (reverse ? 0x30 : 0x10)))); \
56          const __m128i chunk2 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20))); \
57          const __m128i chunk3 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ (reverse ? 0x10 : 0x30)))); \
58          _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk3, _b1)); \
59          _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk1, _b)); \
60          _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); \
61          if (ALGO == Algorithm::CN_R) { \
62              _c = _mm_xor_si128(_mm_xor_si128(_c, chunk3), _mm_xor_si128(chunk1, chunk2)); \
63          } \
64      } while (0)
65  #   define VARIANT2_SHUFFLE2(base_ptr, offset, _a, _b, _b1, hi, lo, reverse) \
66      do { \
67          const __m128i chunk1 = _mm_xor_si128(_mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10))), _mm_set_epi64x(lo, hi)); \
68          const __m128i chunk2 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20))); \
69          hi ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[0]; \
70          lo ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[1]; \
71          const __m128i chunk3 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30))); \
72          if (reverse) { \
73              _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk1, _b1)); \
74              _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk3, _b)); \
75          } else { \
76              _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk3, _b1)); \
77              _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk1, _b)); \
78          } \
79          _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); \
80      } while (0)
81  #else
82  #   define VARIANT2_INIT(part) \
83      uint64_t division_result_##part = h##part[12]; \
84      uint64_t sqrt_result_##part = h##part[13];
85  #   define VARIANT2_INTEGER_MATH(part, cl, cx) \
86      do { \
87          const uint64_t cx_0 = _mm_cvtsi128_si64(cx); \
88          cl ^= division_result_##part ^ (sqrt_result_##part << 32); \
89          const uint32_t d = static_cast<uint32_t>(cx_0 + (sqrt_result_##part << 1)) | 0x80000001UL; \
90          const uint64_t cx_1 = _mm_cvtsi128_si64(_mm_srli_si128(cx, 8)); \
91          division_result_##part = static_cast<uint32_t>(cx_1 / d) + ((cx_1 % d) << 32); \
92          const uint64_t sqrt_input = cx_0 + division_result_##part; \
93          sqrt_result_##part = sqrt(sqrt_input + 18446744073709551616.0) * 2.0 - 8589934592.0; \
94          const uint64_t s = sqrt_result_##part >> 1; \
95          const uint64_t b = sqrt_result_##part & 1; \
96          const uint64_t r2 = (uint64_t)(s) * (s + b) + (sqrt_result_##part << 32); \
97          sqrt_result_##part += ((r2 + b > sqrt_input) ? -1 : 0) + ((r2 + (1ULL << 32) < sqrt_input - s) ? 1 : 0); \
98      } while (0)
99  #   define VARIANT2_SHUFFLE(base_ptr, offset, _a, _b, _b1, _c, reverse) \
100      do { \
101          const uint64x2_t chunk1 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ (reverse ? 0x30 : 0x10)))); \
102          const uint64x2_t chunk2 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20))); \
103          const uint64x2_t chunk3 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ (reverse ? 0x10 : 0x30)))); \
104          vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1))); \
105          vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b))); \
106          vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30)), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a))); \
107          if (ALGO == Algorithm::CN_R) { \
108              _c = veorq_u64(veorq_u64(_c, chunk3), veorq_u64(chunk1, chunk2)); \
109          } \
110      } while (0)
111  #   define VARIANT2_SHUFFLE2(base_ptr, offset, _a, _b, _b1, hi, lo, reverse) \
112      do { \
113          const uint64x2_t chunk1 = veorq_u64(vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10))), vcombine_u64(vcreate_u64(hi), vcreate_u64(lo))); \
114          const uint64x2_t chunk2 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20))); \
115          hi ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[0]; \
116          lo ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[1]; \
117          const uint64x2_t chunk3 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30))); \
118          if (reverse) { \
119              vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b1))); \
120              vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b))); \
121          } else { \
122              vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1))); \
123              vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b))); \
124          } \
125          vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30)), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a))); \
126      } while (0)
127  #endif
128  #define SWAP32LE(x) x
129  #define SWAP64LE(x) x
130  #define hash_extra_blake(data, length, hash) blake256_hash((uint8_t*)(hash), (uint8_t*)(data), (length))
131  #ifndef NOINLINE
132  #ifdef __GNUC__
133  #define NOINLINE __attribute__ ((noinline))
134  #elif _MSC_VER
135  #define NOINLINE __declspec(noinline)
136  #else
137  #define NOINLINE
138  #endif
139  #endif
140  #include "crypto/cn/r/variant4_random_math.h"
141  #define VARIANT4_RANDOM_MATH_INIT(part) \
142    uint32_t r##part[9]; \
143    struct V4_Instruction code##part[256]; \
144    if (props.isR()) { \
145      r##part[0] = static_cast<uint32_t>(h##part[12]); \
146      r##part[1] = static_cast<uint32_t>(h##part[12] >> 32); \
<span onclick='openModal()' class='match'>147      r##part[2] = static_cast<uint32_t>(h##part[13]); \
148      r##part[3] = static_cast<uint32_t>(h##part[13] >> 32); \
149      v4_random_math_init<ALGO>(code##part, height); \
</span>150    }
151  #define VARIANT4_RANDOM_MATH(part, al, ah, cl, bx0, bx1) \
152    if (props.isR()) { \
153      cl ^= (r##part[0] + r##part[1]) | (static_cast<uint64_t>(r##part[2] + r##part[3]) << 32); \
154      r##part[4] = static_cast<uint32_t>(al); \
155      r##part[5] = static_cast<uint32_t>(ah); \
156      r##part[6] = static_cast<uint32_t>(_mm_cvtsi128_si32(bx0)); \
157      r##part[7] = static_cast<uint32_t>(_mm_cvtsi128_si32(bx1)); \
158      r##part[8] = static_cast<uint32_t>(_mm_cvtsi128_si32(_mm_srli_si128(bx1, 8))); \
159      v4_random_math(code##part, r##part); \
160    }
161  extern bool cn_sse41_enabled;
162  extern bool cn_vaes_enabled;
163  #endif &bsol;* XMRIG_CRYPTONIGHT_MONERO_H */
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_monero.h</h3>
            <pre><code>1  #ifndef XMRIG_CRYPTONIGHT_MONERO_H
2  #define XMRIG_CRYPTONIGHT_MONERO_H
3  #include <fenv.h>
4  #include <math.h>
5  #ifndef XMRIG_ARM
6  #   define VARIANT1_INIT(part) \
7      uint64_t tweak1_2_##part = 0; \
8      if (BASE == Algorithm::CN_1) { \
9          tweak1_2_##part = (*reinterpret_cast<const uint64_t*>(input + 35 + part * size) ^ \
10                            *(reinterpret_cast<const uint64_t*>(ctx[part]->state) + 24)); \
11      }
12  #else
13  #   define VARIANT1_INIT(part) \
14      uint64_t tweak1_2_##part = 0; \
15      if (BASE == Algorithm::CN_1) { \
16          memcpy(&tweak1_2_##part, input + 35 + part * size, sizeof tweak1_2_##part); \
17          tweak1_2_##part ^= *(reinterpret_cast<const uint64_t*>(ctx[part]->state) + 24); \
18      }
19  #endif
20  #define VARIANT1_1(p) \
21      if (BASE == Algorithm::CN_1) { \
22          const uint8_t tmp = reinterpret_cast<const uint8_t*>(p)[11]; \
23          static const uint32_t table = 0x75310; \
24          const uint8_t index = (((tmp >> 3) & 6) | (tmp & 1)) << 1; \
25          ((uint8_t*)(p))[11] = tmp ^ ((table >> index) & 0x30); \
26      }
27  #define VARIANT1_2(p, part) \
28      if (BASE == Algorithm::CN_1) { \
29          (p) ^= tweak1_2_##part; \
30      }
31  #ifndef XMRIG_ARM
32  #   define VARIANT2_INIT(part) \
33      __m128i division_result_xmm_##part = _mm_cvtsi64_si128(static_cast<int64_t>(h##part[12])); \
34      __m128i sqrt_result_xmm_##part     = _mm_cvtsi64_si128(static_cast<int64_t>(h##part[13]));
35  #ifdef _MSC_VER
36  #   define VARIANT2_SET_ROUNDING_MODE() if (BASE == Algorithm::CN_2) { _control87(RC_DOWN, MCW_RC); }
37  #   define RESTORE_ROUNDING_MODE() _control87(RC_NEAR, MCW_RC);
38  #else
39  #   define VARIANT2_SET_ROUNDING_MODE() if (BASE == Algorithm::CN_2) { fesetround(FE_DOWNWARD); }
40  #   define RESTORE_ROUNDING_MODE() fesetround(FE_TONEAREST);
41  #endif
42  #   define VARIANT2_INTEGER_MATH(part, cl, cx) \
43      do { \
44          const uint64_t sqrt_result = static_cast<uint64_t>(_mm_cvtsi128_si64(sqrt_result_xmm_##part)); \
45          const uint64_t cx_0 = _mm_cvtsi128_si64(cx); \
46          cl ^= static_cast<uint64_t>(_mm_cvtsi128_si64(division_result_xmm_##part)) ^ (sqrt_result << 32); \
47          const uint32_t d = static_cast<uint32_t>(cx_0 + (sqrt_result << 1)) | 0x80000001UL; \
48          const uint64_t cx_1 = _mm_cvtsi128_si64(_mm_srli_si128(cx, 8)); \
49          const uint64_t division_result = static_cast<uint32_t>(cx_1 / d) + ((cx_1 % d) << 32); \
50          division_result_xmm_##part = _mm_cvtsi64_si128(static_cast<int64_t>(division_result)); \
51          sqrt_result_xmm_##part = int_sqrt_v2(cx_0 + division_result); \
52      } while (0)
53  #   define VARIANT2_SHUFFLE(base_ptr, offset, _a, _b, _b1, _c, reverse) \
54      do { \
55          const __m128i chunk1 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ (reverse ? 0x30 : 0x10)))); \
56          const __m128i chunk2 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20))); \
57          const __m128i chunk3 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ (reverse ? 0x10 : 0x30)))); \
58          _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk3, _b1)); \
59          _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk1, _b)); \
60          _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); \
61          if (ALGO == Algorithm::CN_R) { \
62              _c = _mm_xor_si128(_mm_xor_si128(_c, chunk3), _mm_xor_si128(chunk1, chunk2)); \
63          } \
64      } while (0)
65  #   define VARIANT2_SHUFFLE2(base_ptr, offset, _a, _b, _b1, hi, lo, reverse) \
66      do { \
67          const __m128i chunk1 = _mm_xor_si128(_mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10))), _mm_set_epi64x(lo, hi)); \
68          const __m128i chunk2 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20))); \
69          hi ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[0]; \
70          lo ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[1]; \
71          const __m128i chunk3 = _mm_load_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30))); \
72          if (reverse) { \
73              _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk1, _b1)); \
74              _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk3, _b)); \
75          } else { \
76              _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x10)), _mm_add_epi64(chunk3, _b1)); \
77              _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x20)), _mm_add_epi64(chunk1, _b)); \
78          } \
79          _mm_store_si128((__m128i *)((base_ptr) + ((offset) ^ 0x30)), _mm_add_epi64(chunk2, _a)); \
80      } while (0)
81  #else
82  #   define VARIANT2_INIT(part) \
83      uint64_t division_result_##part = h##part[12]; \
84      uint64_t sqrt_result_##part = h##part[13];
85  #   define VARIANT2_INTEGER_MATH(part, cl, cx) \
86      do { \
87          const uint64_t cx_0 = _mm_cvtsi128_si64(cx); \
88          cl ^= division_result_##part ^ (sqrt_result_##part << 32); \
89          const uint32_t d = static_cast<uint32_t>(cx_0 + (sqrt_result_##part << 1)) | 0x80000001UL; \
90          const uint64_t cx_1 = _mm_cvtsi128_si64(_mm_srli_si128(cx, 8)); \
91          division_result_##part = static_cast<uint32_t>(cx_1 / d) + ((cx_1 % d) << 32); \
92          const uint64_t sqrt_input = cx_0 + division_result_##part; \
93          sqrt_result_##part = sqrt(sqrt_input + 18446744073709551616.0) * 2.0 - 8589934592.0; \
94          const uint64_t s = sqrt_result_##part >> 1; \
95          const uint64_t b = sqrt_result_##part & 1; \
96          const uint64_t r2 = (uint64_t)(s) * (s + b) + (sqrt_result_##part << 32); \
97          sqrt_result_##part += ((r2 + b > sqrt_input) ? -1 : 0) + ((r2 + (1ULL << 32) < sqrt_input - s) ? 1 : 0); \
98      } while (0)
99  #   define VARIANT2_SHUFFLE(base_ptr, offset, _a, _b, _b1, _c, reverse) \
100      do { \
101          const uint64x2_t chunk1 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ (reverse ? 0x30 : 0x10)))); \
102          const uint64x2_t chunk2 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20))); \
103          const uint64x2_t chunk3 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ (reverse ? 0x10 : 0x30)))); \
104          vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1))); \
105          vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b))); \
106          vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30)), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a))); \
107          if (ALGO == Algorithm::CN_R) { \
108              _c = veorq_u64(veorq_u64(_c, chunk3), veorq_u64(chunk1, chunk2)); \
109          } \
110      } while (0)
111  #   define VARIANT2_SHUFFLE2(base_ptr, offset, _a, _b, _b1, hi, lo, reverse) \
112      do { \
113          const uint64x2_t chunk1 = veorq_u64(vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10))), vcombine_u64(vcreate_u64(hi), vcreate_u64(lo))); \
114          const uint64x2_t chunk2 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20))); \
115          hi ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[0]; \
116          lo ^= ((uint64_t*)((base_ptr) + ((offset) ^ 0x20)))[1]; \
117          const uint64x2_t chunk3 = vld1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30))); \
118          if (reverse) { \
119              vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b1))); \
120              vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b))); \
121          } else { \
122              vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x10)), vaddq_u64(chunk3, vreinterpretq_u64_u8(_b1))); \
123              vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x20)), vaddq_u64(chunk1, vreinterpretq_u64_u8(_b))); \
124          } \
125          vst1q_u64((uint64_t*)((base_ptr) + ((offset) ^ 0x30)), vaddq_u64(chunk2, vreinterpretq_u64_u8(_a))); \
126      } while (0)
127  #endif
128  #define SWAP32LE(x) x
129  #define SWAP64LE(x) x
130  #define hash_extra_blake(data, length, hash) blake256_hash((uint8_t*)(hash), (uint8_t*)(data), (length))
131  #ifndef NOINLINE
132  #ifdef __GNUC__
133  #define NOINLINE __attribute__ ((noinline))
134  #elif _MSC_VER
135  #define NOINLINE __declspec(noinline)
136  #else
137  #define NOINLINE
138  #endif
139  #endif
140  #include "crypto/cn/r/variant4_random_math.h"
141  #define VARIANT4_RANDOM_MATH_INIT(part) \
142    uint32_t r##part[9]; \
143    struct V4_Instruction code##part[256]; \
144    if (props.isR()) { \
145      r##part[0] = static_cast<uint32_t>(h##part[12]); \
146      r##part[1] = static_cast<uint32_t>(h##part[12] >> 32); \
<span onclick='openModal()' class='match'>147      r##part[2] = static_cast<uint32_t>(h##part[13]); \
148      r##part[3] = static_cast<uint32_t>(h##part[13] >> 32); \
149      v4_random_math_init<ALGO>(code##part, height); \
</span>150    }
151  #define VARIANT4_RANDOM_MATH(part, al, ah, cl, bx0, bx1) \
152    if (props.isR()) { \
153      cl ^= (r##part[0] + r##part[1]) | (static_cast<uint64_t>(r##part[2] + r##part[3]) << 32); \
154      r##part[4] = static_cast<uint32_t>(al); \
155      r##part[5] = static_cast<uint32_t>(ah); \
156      r##part[6] = static_cast<uint32_t>(_mm_cvtsi128_si32(bx0)); \
157      r##part[7] = static_cast<uint32_t>(_mm_cvtsi128_si32(bx1)); \
158      r##part[8] = static_cast<uint32_t>(_mm_cvtsi128_si32(_mm_srli_si128(bx1, 8))); \
159      v4_random_math(code##part, r##part); \
160    }
161  extern bool cn_sse41_enabled;
162  extern bool cn_vaes_enabled;
163  #endif &bsol;* XMRIG_CRYPTONIGHT_MONERO_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_monero.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-CryptoNight_monero.h</div>
                </div>
                <div class="column column_space"><pre><code>147      r##part[2] = static_cast<uint32_t>(h##part[13]); \
148      r##part[3] = static_cast<uint32_t>(h##part[13] >> 32); \
149      v4_random_math_init<ALGO>(code##part, height); \
</pre></code></div>
                <div class="column column_space"><pre><code>147      r##part[2] = static_cast<uint32_t>(h##part[13]); \
148      r##part[3] = static_cast<uint32_t>(h##part[13] >> 32); \
149      v4_random_math_init<ALGO>(code##part, height); \
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    