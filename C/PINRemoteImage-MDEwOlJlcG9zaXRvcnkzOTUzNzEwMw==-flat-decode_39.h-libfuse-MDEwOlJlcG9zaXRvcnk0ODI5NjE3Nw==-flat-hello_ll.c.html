
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.390243902439024%, Tokens: 9</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-decode_39.h</h3>
            <pre><code>1  #ifndef WEBP_WEBP_DECODE_H_
2  #define WEBP_WEBP_DECODE_H_
3  #include "./types.h"
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #define WEBP_DECODER_ABI_VERSION 0x0209    
8  typedef struct WebPRGBABuffer WebPRGBABuffer;
9  typedef struct WebPYUVABuffer WebPYUVABuffer;
10  typedef struct WebPDecBuffer WebPDecBuffer;
11  typedef struct WebPIDecoder WebPIDecoder;
12  typedef struct WebPBitstreamFeatures WebPBitstreamFeatures;
13  typedef struct WebPDecoderOptions WebPDecoderOptions;
14  typedef struct WebPDecoderConfig WebPDecoderConfig;
15  WEBP_EXTERN int WebPGetDecoderVersion(void);
16  WEBP_EXTERN int WebPGetInfo(const uint8_t* data, size_t data_size,
17                              int* width, int* height);
18  WEBP_EXTERN uint8_t* WebPDecodeRGBA(const uint8_t* data, size_t data_size,
19                                      int* width, int* height);
20  WEBP_EXTERN uint8_t* WebPDecodeARGB(const uint8_t* data, size_t data_size,
21                                      int* width, int* height);
22  WEBP_EXTERN uint8_t* WebPDecodeBGRA(const uint8_t* data, size_t data_size,
23                                      int* width, int* height);
24  WEBP_EXTERN uint8_t* WebPDecodeRGB(const uint8_t* data, size_t data_size,
25                                     int* width, int* height);
26  WEBP_EXTERN uint8_t* WebPDecodeBGR(const uint8_t* data, size_t data_size,
27                                     int* width, int* height);
28  WEBP_EXTERN uint8_t* WebPDecodeYUV(const uint8_t* data, size_t data_size,
29                                     int* width, int* height,
30                                     uint8_t** u, uint8_t** v,
31                                     int* stride, int* uv_stride);
32  WEBP_EXTERN uint8_t* WebPDecodeRGBAInto(
33      const uint8_t* data, size_t data_size,
34      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
35  WEBP_EXTERN uint8_t* WebPDecodeARGBInto(
36      const uint8_t* data, size_t data_size,
37      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
38  WEBP_EXTERN uint8_t* WebPDecodeBGRAInto(
39      const uint8_t* data, size_t data_size,
40      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
41  WEBP_EXTERN uint8_t* WebPDecodeRGBInto(
42      const uint8_t* data, size_t data_size,
43      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
44  WEBP_EXTERN uint8_t* WebPDecodeBGRInto(
45      const uint8_t* data, size_t data_size,
46      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
47  WEBP_EXTERN uint8_t* WebPDecodeYUVInto(
48      const uint8_t* data, size_t data_size,
49      uint8_t* luma, size_t luma_size, int luma_stride,
50      uint8_t* u, size_t u_size, int u_stride,
51      uint8_t* v, size_t v_size, int v_stride);
<span onclick='openModal()' class='match'>52  typedef enum WEBP_CSP_MODE {
53    MODE_RGB = 0, MODE_RGBA = 1,
54    MODE_BGR = 2, MODE_BGRA = 3,
55    MODE_ARGB = 4, MODE_RGBA_4444 = 5,
56    MODE_RGB_565 = 6,
57    MODE_rgbA = 7,
</span>58    MODE_bgrA = 8,
59    MODE_Argb = 9,
60    MODE_rgbA_4444 = 10,
61    MODE_YUV = 11, MODE_YUVA = 12,  
62    MODE_LAST = 13
63  } WEBP_CSP_MODE;
64  static WEBP_INLINE int WebPIsPremultipliedMode(WEBP_CSP_MODE mode) {
65    return (mode == MODE_rgbA || mode == MODE_bgrA || mode == MODE_Argb ||
66            mode == MODE_rgbA_4444);
67  }
68  static WEBP_INLINE int WebPIsAlphaMode(WEBP_CSP_MODE mode) {
69    return (mode == MODE_RGBA || mode == MODE_BGRA || mode == MODE_ARGB ||
70            mode == MODE_RGBA_4444 || mode == MODE_YUVA ||
71            WebPIsPremultipliedMode(mode));
72  }
73  static WEBP_INLINE int WebPIsRGBMode(WEBP_CSP_MODE mode) {
74    return (mode < MODE_YUV);
75  }
76  struct WebPRGBABuffer {    
77    uint8_t* rgba;    
78    int stride;       
79    size_t size;      
80  };
81  struct WebPYUVABuffer {              
82    uint8_t* y, *u, *v, *a;     
83    int y_stride;               
84    int u_stride, v_stride;     
85    int a_stride;               
86    size_t y_size;              
87    size_t u_size, v_size;      
88    size_t a_size;              
89  };
90  struct WebPDecBuffer {
91    WEBP_CSP_MODE colorspace;  
92    int width, height;         
93    int is_external_memory;    
94    union {
95      WebPRGBABuffer RGBA;
96      WebPYUVABuffer YUVA;
97    } u;                       
98    uint32_t       pad[4];     
99    uint8_t* private_memory;   
100  };
101  WEBP_EXTERN int WebPInitDecBufferInternal(WebPDecBuffer*, int);
102  static WEBP_INLINE int WebPInitDecBuffer(WebPDecBuffer* buffer) {
103    return WebPInitDecBufferInternal(buffer, WEBP_DECODER_ABI_VERSION);
104  }
105  WEBP_EXTERN void WebPFreeDecBuffer(WebPDecBuffer* buffer);
106  typedef enum VP8StatusCode {
107    VP8_STATUS_OK = 0,
108    VP8_STATUS_OUT_OF_MEMORY,
109    VP8_STATUS_INVALID_PARAM,
110    VP8_STATUS_BITSTREAM_ERROR,
111    VP8_STATUS_UNSUPPORTED_FEATURE,
112    VP8_STATUS_SUSPENDED,
113    VP8_STATUS_USER_ABORT,
114    VP8_STATUS_NOT_ENOUGH_DATA
115  } VP8StatusCode;
116  WEBP_EXTERN WebPIDecoder* WebPINewDecoder(WebPDecBuffer* output_buffer);
117  WEBP_EXTERN WebPIDecoder* WebPINewRGB(
118      WEBP_CSP_MODE csp,
119      uint8_t* output_buffer, size_t output_buffer_size, int output_stride);
120  WEBP_EXTERN WebPIDecoder* WebPINewYUVA(
121      uint8_t* luma, size_t luma_size, int luma_stride,
122      uint8_t* u, size_t u_size, int u_stride,
123      uint8_t* v, size_t v_size, int v_stride,
124      uint8_t* a, size_t a_size, int a_stride);
125  WEBP_EXTERN WebPIDecoder* WebPINewYUV(
126      uint8_t* luma, size_t luma_size, int luma_stride,
127      uint8_t* u, size_t u_size, int u_stride,
128      uint8_t* v, size_t v_size, int v_stride);
129  WEBP_EXTERN void WebPIDelete(WebPIDecoder* idec);
130  WEBP_EXTERN VP8StatusCode WebPIAppend(
131      WebPIDecoder* idec, const uint8_t* data, size_t data_size);
132  WEBP_EXTERN VP8StatusCode WebPIUpdate(
133      WebPIDecoder* idec, const uint8_t* data, size_t data_size);
134  WEBP_EXTERN uint8_t* WebPIDecGetRGB(
135      const WebPIDecoder* idec, int* last_y,
136      int* width, int* height, int* stride);
137  WEBP_EXTERN uint8_t* WebPIDecGetYUVA(
138      const WebPIDecoder* idec, int* last_y,
139      uint8_t** u, uint8_t** v, uint8_t** a,
140      int* width, int* height, int* stride, int* uv_stride, int* a_stride);
141  static WEBP_INLINE uint8_t* WebPIDecGetYUV(
142      const WebPIDecoder* idec, int* last_y, uint8_t** u, uint8_t** v,
143      int* width, int* height, int* stride, int* uv_stride) {
144    return WebPIDecGetYUVA(idec, last_y, u, v, NULL, width, height,
145                           stride, uv_stride, NULL);
146  }
147  WEBP_EXTERN const WebPDecBuffer* WebPIDecodedArea(
148      const WebPIDecoder* idec, int* left, int* top, int* width, int* height);
149  struct WebPBitstreamFeatures {
150    int width;          
151    int height;         
152    int has_alpha;      
153    int has_animation;  
154    int format;         
155    uint32_t pad[5];    
156  };
157  WEBP_EXTERN VP8StatusCode WebPGetFeaturesInternal(
158      const uint8_t*, size_t, WebPBitstreamFeatures*, int);
159  static WEBP_INLINE VP8StatusCode WebPGetFeatures(
160      const uint8_t* data, size_t data_size,
161      WebPBitstreamFeatures* features) {
162    return WebPGetFeaturesInternal(data, data_size, features,
163                                   WEBP_DECODER_ABI_VERSION);
164  }
165  struct WebPDecoderOptions {
166    int bypass_filtering;               
167    int no_fancy_upsampling;            
168    int use_cropping;                   
169    int crop_left, crop_top;            
170    int crop_width, crop_height;        
171    int use_scaling;                    
172    int scaled_width, scaled_height;    
173    int use_threads;                    
174    int dithering_strength;             
175    int flip;                           
176    int alpha_dithering_strength;       
177    uint32_t pad[5];                    
178  };
179  struct WebPDecoderConfig {
180    WebPBitstreamFeatures input;  
181    WebPDecBuffer output;         
182    WebPDecoderOptions options;   
183  };
184  WEBP_EXTERN int WebPInitDecoderConfigInternal(WebPDecoderConfig*, int);
185  static WEBP_INLINE int WebPInitDecoderConfig(WebPDecoderConfig* config) {
186    return WebPInitDecoderConfigInternal(config, WEBP_DECODER_ABI_VERSION);
187  }
188  WEBP_EXTERN WebPIDecoder* WebPIDecode(const uint8_t* data, size_t data_size,
189                                        WebPDecoderConfig* config);
190  WEBP_EXTERN VP8StatusCode WebPDecode(const uint8_t* data, size_t data_size,
191                                       WebPDecoderConfig* config);
192  #ifdef __cplusplus
193  }    
194  #endif
195  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-hello_ll.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 34
2  #include <fuse_lowlevel.h>
3  #include <stdio.h>
4  #include <stdlib.h>
5  #include <string.h>
6  #include <errno.h>
7  #include <fcntl.h>
8  #include <unistd.h>
9  #include <assert.h>
10  static const char *hello_str = "Hello World!\n";
11  static const char *hello_name = "hello";
12  static int hello_stat(fuse_ino_t ino, struct stat *stbuf)
13  {
14  	stbuf->st_ino = ino;
15  	switch (ino) {
16  	case 1:
17  		stbuf->st_mode = S_IFDIR | 0755;
18  		stbuf->st_nlink = 2;
19  		break;
20  	case 2:
21  		stbuf->st_mode = S_IFREG | 0444;
22  		stbuf->st_nlink = 1;
23  		stbuf->st_size = strlen(hello_str);
24  		break;
25  	default:
26  		return -1;
27  	}
28  	return 0;
29  }
30  static void hello_ll_getattr(fuse_req_t req, fuse_ino_t ino,
31  			     struct fuse_file_info *fi)
32  {
33  	struct stat stbuf;
34  	(void) fi;
35  	memset(&stbuf, 0, sizeof(stbuf));
36  	if (hello_stat(ino, &stbuf) == -1)
37  		fuse_reply_err(req, ENOENT);
38  	else
39  		fuse_reply_attr(req, &stbuf, 1.0);
40  }
41  static void hello_ll_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)
42  {
43  	struct fuse_entry_param e;
44  	if (parent != 1 || strcmp(name, hello_name) != 0)
45  		fuse_reply_err(req, ENOENT);
46  	else {
47  		memset(&e, 0, sizeof(e));
48  		e.ino = 2;
49  		e.attr_timeout = 1.0;
50  		e.entry_timeout = 1.0;
51  		hello_stat(e.ino, &e.attr);
52  		fuse_reply_entry(req, &e);
53  	}
54  }
55  struct dirbuf {
56  	char *p;
57  	size_t size;
58  };
59  static void dirbuf_add(fuse_req_t req, struct dirbuf *b, const char *name,
60  		       fuse_ino_t ino)
61  {
62  	struct stat stbuf;
63  	size_t oldsize = b->size;
64  	b->size += fuse_add_direntry(req, NULL, 0, name, NULL, 0);
65  	b->p = (char *) realloc(b->p, b->size);
66  	memset(&stbuf, 0, sizeof(stbuf));
67  	stbuf.st_ino = ino;
68  	fuse_add_direntry(req, b->p + oldsize, b->size - oldsize, name, &stbuf,
69  			  b->size);
70  }
71  #define min(x, y) ((x) < (y) ? (x) : (y))
72  static int reply_buf_limited(fuse_req_t req, const char *buf, size_t bufsize,
73  			     off_t off, size_t maxsize)
74  {
75  	if (off < bufsize)
76  		return fuse_reply_buf(req, buf + off,
77  				      min(bufsize - off, maxsize));
78  	else
79  		return fuse_reply_buf(req, NULL, 0);
80  }
81  static void hello_ll_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,
82  			     off_t off, struct fuse_file_info *fi)
83  {
84  	(void) fi;
85  	if (ino != 1)
86  		fuse_reply_err(req, ENOTDIR);
87  	else {
88  		struct dirbuf b;
89  		memset(&b, 0, sizeof(b));
90  		dirbuf_add(req, &b, ".", 1);
91  		dirbuf_add(req, &b, "..", 1);
92  		dirbuf_add(req, &b, hello_name, 2);
93  		reply_buf_limited(req, b.p, b.size, off, size);
94  		free(b.p);
95  	}
96  }
97  static void hello_ll_open(fuse_req_t req, fuse_ino_t ino,
98  			  struct fuse_file_info *fi)
99  {
100  	if (ino != 2)
101  		fuse_reply_err(req, EISDIR);
102  	else if ((fi->flags & O_ACCMODE) != O_RDONLY)
103  		fuse_reply_err(req, EACCES);
104  	else
105  		fuse_reply_open(req, fi);
106  }
107  static void hello_ll_read(fuse_req_t req, fuse_ino_t ino, size_t size,
108  			  off_t off, struct fuse_file_info *fi)
109  {
110  	(void) fi;
111  	assert(ino == 2);
112  	reply_buf_limited(req, hello_str, strlen(hello_str), off, size);
113  }
114  static void hello_ll_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,
115  							  size_t size)
116  {
117  	(void)size;
118  	assert(ino == 2);
119  	if (strcmp(name, "hello_ll_getxattr_name") == 0)
120  	{
121  		const char *buf = "hello_ll_getxattr_value";
122  		fuse_reply_buf(req, buf, strlen(buf));
123  	}
124  	else
125  	{
126  		fuse_reply_err(req, ENOTSUP);
127  	}
128  }
129  static void hello_ll_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,
130  							  const char *value, size_t size, int flags)
131  {
132  	(void)flags;
133  	(void)size;
134  	assert(ino == 2);
135  	const char* exp_val = "hello_ll_setxattr_value";
136  	if (strcmp(name, "hello_ll_setxattr_name") == 0 &&
137  	    strlen(exp_val) == size &&
138  	    strncmp(value, exp_val, size) == 0)
139  	{
140  		fuse_reply_err(req, 0);
141  	}
142  	else
143  	{
144  		fuse_reply_err(req, ENOTSUP);
145  	}
146  }
147  static void hello_ll_removexattr(fuse_req_t req, fuse_ino_t ino, const char *name)
148  {
149  	assert(ino == 2);
150  	if (strcmp(name, "hello_ll_removexattr_name") == 0)
151  	{
152  		fuse_reply_err(req, 0);
153  	}
154  	else
155  	{
156  		fuse_reply_err(req, ENOTSUP);
157  	}
158  }
<span onclick='openModal()' class='match'>159  static const struct fuse_lowlevel_ops hello_ll_oper = {
160  	.lookup = hello_ll_lookup,
161  	.getattr = hello_ll_getattr,
162  	.readdir = hello_ll_readdir,
163  	.open = hello_ll_open,
164  	.read = hello_ll_read,
165  	.setxattr = hello_ll_setxattr,
166  	.getxattr = hello_ll_getxattr,
167  	.removexattr = hello_ll_removexattr,
</span>168  };
169  int main(int argc, char *argv[])
170  {
171  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
172  	struct fuse_session *se;
173  	struct fuse_cmdline_opts opts;
174  	struct fuse_loop_config config;
175  	int ret = -1;
176  	if (fuse_parse_cmdline(&args, &opts) != 0)
177  		return 1;
178  	if (opts.show_help) {
179  		printf("usage: %s [options] <mountpoint>\n\n", argv[0]);
180  		fuse_cmdline_help();
181  		fuse_lowlevel_help();
182  		ret = 0;
183  		goto err_out1;
184  	} else if (opts.show_version) {
185  		printf("FUSE library version %s\n", fuse_pkgversion());
186  		fuse_lowlevel_version();
187  		ret = 0;
188  		goto err_out1;
189  	}
190  	if(opts.mountpoint == NULL) {
191  		printf("usage: %s [options] <mountpoint>\n", argv[0]);
192  		printf("       %s --help\n", argv[0]);
193  		ret = 1;
194  		goto err_out1;
195  	}
196  	se = fuse_session_new(&args, &hello_ll_oper,
197  			      sizeof(hello_ll_oper), NULL);
198  	if (se == NULL)
199  	    goto err_out1;
200  	if (fuse_set_signal_handlers(se) != 0)
201  	    goto err_out2;
202  	if (fuse_session_mount(se, opts.mountpoint) != 0)
203  	    goto err_out3;
204  	fuse_daemonize(opts.foreground);
205  	if (opts.singlethread)
206  		ret = fuse_session_loop(se);
207  	else {
208  		config.clone_fd = opts.clone_fd;
209  		config.max_idle_threads = opts.max_idle_threads;
210  		ret = fuse_session_loop_mt(se, &config);
211  	}
212  	fuse_session_unmount(se);
213  err_out3:
214  	fuse_remove_signal_handlers(se);
215  err_out2:
216  	fuse_session_destroy(se);
217  err_out1:
218  	free(opts.mountpoint);
219  	fuse_opt_free_args(&args);
220  	return ret ? 1 : 0;
221  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-decode_39.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-hello_ll.c</div>
                <div class="column column_space"><pre><code>52  typedef enum WEBP_CSP_MODE {
53    MODE_RGB = 0, MODE_RGBA = 1,
54    MODE_BGR = 2, MODE_BGRA = 3,
55    MODE_ARGB = 4, MODE_RGBA_4444 = 5,
56    MODE_RGB_565 = 6,
57    MODE_rgbA = 7,
</pre></code></div>
                <div class="column column_space"><pre><code>159  static const struct fuse_lowlevel_ops hello_ll_oper = {
160  	.lookup = hello_ll_lookup,
161  	.getattr = hello_ll_getattr,
162  	.readdir = hello_ll_readdir,
163  	.open = hello_ll_open,
164  	.read = hello_ll_read,
165  	.setxattr = hello_ll_setxattr,
166  	.getxattr = hello_ll_getxattr,
167  	.removexattr = hello_ll_removexattr,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    