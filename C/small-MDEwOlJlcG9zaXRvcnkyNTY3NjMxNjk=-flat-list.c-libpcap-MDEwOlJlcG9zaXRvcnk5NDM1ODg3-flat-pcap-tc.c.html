
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.0217186024551466%, Tokens: 16</h2>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-list.c</h3>
            <pre><code>1  #include "list.h"
2  void swap_data(Node n1, Node n2);
3  List list_init(unsigned int data_size)
4  {
5      List list = (List) malloc(sizeof(struct clist));
6      if(list != NULL)                                        
7      {
8          list->head = (Node) malloc(sizeof(node));           
9          if(list->head)          
10          {
11              list->head->data = NULL;      
<span onclick='openModal()' class='match'>12              list->head->next = NULL;
13              list->data_size  = data_size;
14              list->tail = list->head;
15              list->size = 0;
16              list->add_back  = list_add_back;   
17              list->add_front  = list_add_front;
18              list->delete_node = list_delete_node;
19              list->delete_at  = list_delete_at;
20              list->modify_at  = list_modify_at;
21              list->have_same  = list_have_same;
22              list->have_same_cmp  = list_have_same_cmp;
23              list->foreach  = list_foreach;
24              list->clear   = list_clear;
25              list->sort   = list_sort;
26              list->destroy  = list_destroy;
</span>27          }
28      }
29      return list;
30  }
31  int  list_add_back(List l, void *data)
32  {
33      Node new_node = (Node) malloc(sizeof(node));
34      if(l != NULL && new_node != NULL)  
35      {
36          new_node->data = malloc(l->data_size);
37          memcpy(new_node->data, data, l->data_size);
38          new_node->next = NULL;
39          l->tail->next = new_node;   
40          l->tail = new_node;     
41          l->size ++;       
42          return 1;
43      }
44      return 0;
45  }
46  int list_add_front(List l, void *data)
47  {
48      Node new_node = (Node) malloc(sizeof(node));
49      if(l != NULL && new_node != NULL)
50      {
51          new_node->data = malloc(l->data_size);
52          memcpy(new_node->data, data, l->data_size);
53          new_node->next = l->head->next;
54          l->head->next = new_node;
55          if(!l->size)        
56              l->tail = new_node;
57          l->size ++;
58          return 1;
59      }
60      return 0;
61  }
62  int  list_delete_node(List l, void *data, int (*pfunc)(void *ndata, void *data))
63  {
64      if(l != NULL)
65      {
66          Node prev = l->head;      
67          Node curr = l->head->next;     
68          while(curr != NULL)
69          {
70              if(pfunc(curr->data, data))    
71              {
72                  if(curr == l->tail)     
73                   l->tail = prev;
74                  prev->next = prev->next->next;  
75                  free(curr->data);     
76                  free(curr);       
77                  l->size--;       
78                  return 1;       
79              }
80              prev = prev->next;      
81              curr = curr->next;
82          }
83      }
84   return 0;         
85  }
86  int list_delete_at(List l, unsigned int index)
87  {
88      unsigned int cindex = 0;
89      if(l != NULL && index >= 0 && index < l->size)
90      {
91          Node prev = l->head;      
92          Node curr = l->head->next;     
93          while(cindex != index)
94          {
95              prev = prev->next;
96              curr = curr->next;
97              cindex ++;
98          }
99          if(index == (l->size) - 1)
100              l->tail = prev;
101          prev->next = prev->next->next;
102          free(curr->data);
103          free(curr);
104          l->size --;
105          return 1;
106      }
107      return 0;
108  }
109  int list_modify_at(List l, unsigned int index, void *new_data)
110  {
111      unsigned int cindex = 0;
112      if(l != NULL && index >= 0 && index < l->size )  
113      {
114          Node curr = l->head->next;
115          while(cindex != index)
116          {
117              curr = curr->next;
118              cindex ++;
119          }
120          memcpy(curr->data, new_data, l->data_size);
121          return 1;
122      }
123      return 0;
124  }
125  void list_sort(List l, compare pfunc)
126  {
127      if(l != NULL)
128      {
129          Node min, icurr, jcurr;
130          icurr = l->head->next;
131          while(icurr)
132          {
133              min = icurr;        
134              jcurr = icurr->next;      
135              while(jcurr)
136              {
137                  if(pfunc(min->data, jcurr->data))  
138                      min = jcurr;      
139                  jcurr = jcurr->next;
140              }
141              if(min != icurr)       
142              {
143                  swap_data(min, icurr);     
144              }
145              icurr = icurr->next;
146          }
147      }
148  }
149  void swap_data(Node n1, Node n2)
150  {
151      void *temp;
152      temp = n2->data;
153      n2->data = n1->data;
154      n1->data = temp;
155  }
156  int list_have_same(List l, void *data, int (*pfunc)(void *ndata, void *data))
157  {
158      if(l != NULL)
159      {
160          Node curr;
161          for(curr = l->head->next; curr != NULL; curr = curr->next)
162          {
163              if(pfunc(curr->data, data))
164              {
165                  return 1;
166              }
167          }
168      }
169      return 0;
170  }
171  int list_have_same_cmp(List l, void *data)
172  {
173      if(l != NULL)
174      {
175          Node curr;
176          for(curr = l->head->next; curr != NULL; curr = curr->next)
177          {
178              if(memcmp(curr->data, data, l->data_size))
179              {
180                  return 1;
181              }
182          }
183      }
184      return 0;
185  }
186  void list_foreach(List l, dofunc doit)
187  {
188      if(l != NULL)
189      {
190          Node curr;
191          for(curr = l->head->next; curr != NULL; curr = curr->next)
192          {
193              doit(curr->data);
194          }
195      }
196  }
197  void list_clear(List l)
198  {
199      if(l != NULL)
200      {
201          Node temp;
202          Node curr = l->head->next;
203          while(curr != NULL)
204          {
205              temp = curr->next;
206              free(curr->data);    
207              free(curr);
208              curr = temp;
209          }
210          l->size = 0;      
211          l->head->next = NULL;
212          l->tail = l->head;
213      }
214  }
215  List list_destroy(List l)
216  {
217      if(l != NULL)
218      {
219          Node temp;
220          while(l->head)
221          {
222              temp = l->head->next;
223              if(l->head->data != NULL)   
224              free(l->head->data);   
225              free(l->head);      
226              l->head = temp;
227          }
228          free(l);        
229          l = NULL;
230      }
231      return l;
232  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-tc.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <pcap.h>
5  #include <pcap-int.h>
6  #include "pcap-tc.h"
7  #include <malloc.h>
8  #include <memory.h>
9  #include <string.h>
10  #include <errno.h>
11  #ifdef _WIN32
12  #include <tchar.h>
13  #endif
14  typedef TC_STATUS	(TC_CALLCONV *TcFcnQueryPortList)			(PTC_PORT *ppPorts, PULONG pLength);
15  typedef TC_STATUS	(TC_CALLCONV *TcFcnFreePortList)			(TC_PORT *pPorts);
16  typedef PCHAR		(TC_CALLCONV *TcFcnStatusGetString)			(TC_STATUS status);
17  typedef PCHAR		(TC_CALLCONV *TcFcnPortGetName)				(TC_PORT port);
18  typedef PCHAR		(TC_CALLCONV *TcFcnPortGetDescription)		(TC_PORT port);
19  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceOpenByName)		(PCHAR name, PTC_INSTANCE pInstance);
20  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceClose)			(TC_INSTANCE instance);
21  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceSetFeature)		(TC_INSTANCE instance, ULONG feature, ULONG value);
22  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceQueryFeature)	(TC_INSTANCE instance, ULONG feature, PULONG pValue);
23  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceReceivePackets)	(TC_INSTANCE instance, PTC_PACKETS_BUFFER pBuffer);
24  typedef HANDLE		(TC_CALLCONV *TcFcnInstanceGetReceiveWaitHandle) (TC_INSTANCE instance);
25  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceTransmitPackets)	(TC_INSTANCE instance, TC_PACKETS_BUFFER pBuffer);
26  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceQueryStatistics)	(TC_INSTANCE instance, PTC_STATISTICS pStatistics);
27  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferCreate)		(ULONG size, PTC_PACKETS_BUFFER pBuffer);
28  typedef VOID		(TC_CALLCONV *TcFcnPacketsBufferDestroy)	(TC_PACKETS_BUFFER buffer);
29  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferQueryNextPacket)(TC_PACKETS_BUFFER buffer, PTC_PACKET_HEADER pHeader, PVOID *ppData);
30  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferCommitNextPacket)(TC_PACKETS_BUFFER buffer, PTC_PACKET_HEADER pHeader, PVOID pData);
31  typedef VOID		(TC_CALLCONV *TcFcnStatisticsDestroy)		(TC_STATISTICS statistics);
32  typedef TC_STATUS	(TC_CALLCONV *TcFcnStatisticsUpdate)		(TC_STATISTICS statistics);
33  typedef TC_STATUS	(TC_CALLCONV *TcFcnStatisticsQueryValue)	(TC_STATISTICS statistics, ULONG counterId, PULONGLONG pValue);
34  typedef enum LONG
35  {
36  	TC_API_UNLOADED = 0,
37  	TC_API_LOADED,
38  	TC_API_CANNOT_LOAD,
39  	TC_API_LOADING
40  }
41  	TC_API_LOAD_STATUS;
42  typedef struct _TC_FUNCTIONS
43  {
44  	TC_API_LOAD_STATUS			LoadStatus;
45  #ifdef _WIN32
46  	HMODULE						hTcApiDllHandle;
47  #endif
48  	TcFcnQueryPortList			QueryPortList;
49  	TcFcnFreePortList			FreePortList;
50  	TcFcnStatusGetString		StatusGetString;
51  	TcFcnPortGetName			PortGetName;
52  	TcFcnPortGetDescription		PortGetDescription;
53  	TcFcnInstanceOpenByName		InstanceOpenByName;
54  	TcFcnInstanceClose			InstanceClose;
55  	TcFcnInstanceSetFeature		InstanceSetFeature;
56  	TcFcnInstanceQueryFeature	InstanceQueryFeature;
57  	TcFcnInstanceReceivePackets	InstanceReceivePackets;
58  #ifdef _WIN32
59  	TcFcnInstanceGetReceiveWaitHandle InstanceGetReceiveWaitHandle;
60  #endif
61  	TcFcnInstanceTransmitPackets InstanceTransmitPackets;
62  	TcFcnInstanceQueryStatistics InstanceQueryStatistics;
63  	TcFcnPacketsBufferCreate	PacketsBufferCreate;
64  	TcFcnPacketsBufferDestroy	PacketsBufferDestroy;
65  	TcFcnPacketsBufferQueryNextPacket	PacketsBufferQueryNextPacket;
66  	TcFcnPacketsBufferCommitNextPacket  PacketsBufferCommitNextPacket;
67  	TcFcnStatisticsDestroy		StatisticsDestroy;
68  	TcFcnStatisticsUpdate		StatisticsUpdate;
69  	TcFcnStatisticsQueryValue	StatisticsQueryValue;
70  }
71  	TC_FUNCTIONS;
72  static pcap_if_t* TcCreatePcapIfFromPort(TC_PORT port);
73  static int TcSetDatalink(pcap_t *p, int dlt);
74  static int TcGetNonBlock(pcap_t *p);
75  static int TcSetNonBlock(pcap_t *p, int nonblock);
76  static void TcCleanup(pcap_t *p);
77  static int TcInject(pcap_t *p, const void *buf, int size);
78  static int TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user);
79  static int TcStats(pcap_t *p, struct pcap_stat *ps);
80  #ifdef _WIN32
81  static struct pcap_stat *TcStatsEx(pcap_t *p, int *pcap_stat_size);
82  static int TcSetBuff(pcap_t *p, int dim);
83  static int TcSetMode(pcap_t *p, int mode);
84  static int TcSetMinToCopy(pcap_t *p, int size);
85  static HANDLE TcGetReceiveWaitHandle(pcap_t *p);
86  static int TcOidGetRequest(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp);
87  static int TcOidSetRequest(pcap_t *p, bpf_u_int32 oid, const void *data, size_t *lenp);
88  static u_int TcSendqueueTransmit(pcap_t *p, pcap_send_queue *queue, int sync);
89  static int TcSetUserBuffer(pcap_t *p, int size);
90  static int TcLiveDump(pcap_t *p, char *filename, int maxsize, int maxpacks);
91  static int TcLiveDumpEnded(pcap_t *p, int sync);
92  static PAirpcapHandle TcGetAirPcapHandle(pcap_t *p);
93  #endif
94  #ifdef _WIN32
95  TC_FUNCTIONS g_TcFunctions =
96  {
97  	TC_API_UNLOADED, &bsol;* LoadStatus */
98  	NULL,  &bsol;* hTcApiDllHandle */
99  	NULL,  &bsol;* QueryPortList */
100  	NULL,  &bsol;* FreePortList */
101  	NULL,  &bsol;* StatusGetString */
102  	NULL,  &bsol;* PortGetName */
103  	NULL,  &bsol;* PortGetDescription */
104  	NULL,  &bsol;* InstanceOpenByName */
105  	NULL,  &bsol;* InstanceClose */
106  	NULL,  &bsol;* InstanceSetFeature */
107  	NULL,  &bsol;* InstanceQueryFeature */
108  	NULL,  &bsol;* InstanceReceivePackets */
109  	NULL,  &bsol;* InstanceGetReceiveWaitHandle */
110  	NULL,  &bsol;* InstanceTransmitPackets */
111  	NULL,  &bsol;* InstanceQueryStatistics */
112  	NULL,  &bsol;* PacketsBufferCreate */
113  	NULL,  &bsol;* PacketsBufferDestroy */
114  	NULL,  &bsol;* PacketsBufferQueryNextPacket */
115  	NULL,  &bsol;* PacketsBufferCommitNextPacket */
116  	NULL,  &bsol;* StatisticsDestroy */
117  	NULL,  &bsol;* StatisticsUpdate */
118  	NULL  &bsol;* StatisticsQueryValue */
119  };
120  #else
121  TC_FUNCTIONS g_TcFunctions =
122  {
123  	TC_API_LOADED, &bsol;* LoadStatus */
124  	TcQueryPortList,
125  	TcFreePortList,
126  	TcStatusGetString,
127  	TcPortGetName,
128  	TcPortGetDescription,
129  	TcInstanceOpenByName,
130  	TcInstanceClose,
131  	TcInstanceSetFeature,
132  	TcInstanceQueryFeature,
133  	TcInstanceReceivePackets,
134  #ifdef _WIN32
135  	TcInstanceGetReceiveWaitHandle,
136  #endif
137  	TcInstanceTransmitPackets,
138  	TcInstanceQueryStatistics,
139  	TcPacketsBufferCreate,
140  	TcPacketsBufferDestroy,
141  	TcPacketsBufferQueryNextPacket,
142  	TcPacketsBufferCommitNextPacket,
143  	TcStatisticsDestroy,
144  	TcStatisticsUpdate,
145  	TcStatisticsQueryValue,
146  };
147  #endif
148  #define MAX_TC_PACKET_SIZE	9500
149  #pragma pack(push, 1)
150  #define PPH_PH_FLAG_PADDING	((UCHAR)0x01)
151  #define PPH_PH_VERSION		((UCHAR)0x00)
152  typedef struct _PPI_PACKET_HEADER
153  {
154  	UCHAR	PphVersion;
155  	UCHAR	PphFlags;
156  	USHORT	PphLength;
157  	ULONG	PphDlt;
158  }
159  	PPI_PACKET_HEADER, *PPPI_PACKET_HEADER;
160  typedef struct _PPI_FIELD_HEADER
161  {
162  	USHORT PfhType;
163  	USHORT PfhLength;
164  }
165  	PPI_FIELD_HEADER, *PPPI_FIELD_HEADER;
166  #define		PPI_FIELD_TYPE_AGGREGATION_EXTENSION	((UCHAR)0x08)
167  typedef struct _PPI_FIELD_AGGREGATION_EXTENSION
168  {
169  	ULONG		InterfaceId;
170  }
171  	PPI_FIELD_AGGREGATION_EXTENSION, *PPPI_FIELD_AGGREGATION_EXTENSION;
172  #define		PPI_FIELD_TYPE_802_3_EXTENSION			((UCHAR)0x09)
173  #define PPI_FLD_802_3_EXT_FLAG_FCS_PRESENT			((ULONG)0x00000001)
174  typedef struct _PPI_FIELD_802_3_EXTENSION
175  {
176  	ULONG		Flags;
177  	ULONG		Errors;
178  }
179  	PPI_FIELD_802_3_EXTENSION, *PPPI_FIELD_802_3_EXTENSION;
180  typedef struct _PPI_HEADER
181  {
182  	PPI_PACKET_HEADER PacketHeader;
183  	PPI_FIELD_HEADER  AggregationFieldHeader;
184  	PPI_FIELD_AGGREGATION_EXTENSION AggregationField;
185  	PPI_FIELD_HEADER  Dot3FieldHeader;
186  	PPI_FIELD_802_3_EXTENSION Dot3Field;
187  }
188  	PPI_HEADER, *PPPI_HEADER;
189  #pragma pack(pop)
190  #ifdef _WIN32
191  TC_API_LOAD_STATUS LoadTcFunctions(void)
192  {
193  	TC_API_LOAD_STATUS currentStatus;
194  	do
195  	{
196  		currentStatus = InterlockedCompareExchange((LONG*)&g_TcFunctions.LoadStatus, TC_API_LOADING, TC_API_UNLOADED);
197  		while(currentStatus == TC_API_LOADING)
198  		{
199  			currentStatus = InterlockedCompareExchange((LONG*)&g_TcFunctions.LoadStatus, TC_API_LOADING, TC_API_LOADING);
200  			Sleep(10);
201  		}
202  		if(currentStatus  == TC_API_LOADED)
203  		{
204  			return TC_API_LOADED;
205  		}
206  		if (currentStatus == TC_API_CANNOT_LOAD)
207  		{
208  			return TC_API_CANNOT_LOAD;
209  		}
210  		currentStatus = TC_API_CANNOT_LOAD;
211  		g_TcFunctions.hTcApiDllHandle = pcap_load_code("TcApi.dll");
212  		if (g_TcFunctions.hTcApiDllHandle == NULL)	break;
213  		g_TcFunctions.QueryPortList			= (TcFcnQueryPortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcQueryPortList");
214  		g_TcFunctions.FreePortList			= (TcFcnFreePortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcFreePortList");
215  		g_TcFunctions.StatusGetString			= (TcFcnStatusGetString)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatusGetString");
216  		g_TcFunctions.PortGetName			= (TcFcnPortGetName)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetName");
217  		g_TcFunctions.PortGetDescription		= (TcFcnPortGetDescription)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetDescription");
218  		g_TcFunctions.InstanceOpenByName		= (TcFcnInstanceOpenByName)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceOpenByName");
219  		g_TcFunctions.InstanceClose			= (TcFcnInstanceClose)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceClose");
220  		g_TcFunctions.InstanceSetFeature		= (TcFcnInstanceSetFeature)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceSetFeature");
221  		g_TcFunctions.InstanceQueryFeature		= (TcFcnInstanceQueryFeature)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryFeature");
222  		g_TcFunctions.InstanceReceivePackets		= (TcFcnInstanceReceivePackets)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceReceivePackets");
223  		g_TcFunctions.InstanceGetReceiveWaitHandle	= (TcFcnInstanceGetReceiveWaitHandle)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceGetReceiveWaitHandle");
224  		g_TcFunctions.InstanceTransmitPackets		= (TcFcnInstanceTransmitPackets)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceTransmitPackets");
225  		g_TcFunctions.InstanceQueryStatistics		= (TcFcnInstanceQueryStatistics)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryStatistics");
226  		g_TcFunctions.PacketsBufferCreate		= (TcFcnPacketsBufferCreate)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCreate");
227  		g_TcFunctions.PacketsBufferDestroy		= (TcFcnPacketsBufferDestroy)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferDestroy");
228  		g_TcFunctions.PacketsBufferQueryNextPacket	= (TcFcnPacketsBufferQueryNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferQueryNextPacket");
229  		g_TcFunctions.PacketsBufferCommitNextPacket	= (TcFcnPacketsBufferCommitNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCommitNextPacket");
230  		g_TcFunctions.StatisticsDestroy			= (TcFcnStatisticsDestroy)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsDestroy");
231  		g_TcFunctions.StatisticsUpdate			= (TcFcnStatisticsUpdate)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsUpdate");
232  		g_TcFunctions.StatisticsQueryValue		= (TcFcnStatisticsQueryValue)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsQueryValue");
233  		if (   g_TcFunctions.QueryPortList == NULL
234  			|| g_TcFunctions.FreePortList == NULL
235  			|| g_TcFunctions.StatusGetString == NULL
236  			|| g_TcFunctions.PortGetName == NULL
237  			|| g_TcFunctions.PortGetDescription == NULL
238  			|| g_TcFunctions.InstanceOpenByName == NULL
239  			|| g_TcFunctions.InstanceClose == NULL
240  			|| g_TcFunctions.InstanceSetFeature	 == NULL
241  			|| g_TcFunctions.InstanceQueryFeature == NULL
242  			|| g_TcFunctions.InstanceReceivePackets == NULL
243  			|| g_TcFunctions.InstanceGetReceiveWaitHandle == NULL
244  			|| g_TcFunctions.InstanceTransmitPackets == NULL
245  			|| g_TcFunctions.InstanceQueryStatistics == NULL
246  			|| g_TcFunctions.PacketsBufferCreate == NULL
247  			|| g_TcFunctions.PacketsBufferDestroy == NULL
248  			|| g_TcFunctions.PacketsBufferQueryNextPacket == NULL
249  			|| g_TcFunctions.PacketsBufferCommitNextPacket == NULL
250  			|| g_TcFunctions.StatisticsDestroy == NULL
251  			|| g_TcFunctions.StatisticsUpdate == NULL
252  			|| g_TcFunctions.StatisticsQueryValue == NULL
253  		)
254  		{
255  			break;
256  		}
257  		currentStatus = TC_API_LOADED;
258  	}while(FALSE);
259  	if (currentStatus != TC_API_LOADED)
260  	{
261  		if (g_TcFunctions.hTcApiDllHandle != NULL)
262  		{
263  			FreeLibrary(g_TcFunctions.hTcApiDllHandle);
264  			g_TcFunctions.hTcApiDllHandle = NULL;
265  		}
266  	}
267  	InterlockedExchange((LONG*)&g_TcFunctions.LoadStatus, currentStatus);
268  	return currentStatus;
269  }
270  #else
271  TC_API_LOAD_STATUS LoadTcFunctions(void)
272  {
273  	return TC_API_LOADED;
274  }
275  #endif
276  struct pcap_tc {
277  	TC_INSTANCE TcInstance;
278  	TC_PACKETS_BUFFER TcPacketsBuffer;
279  	ULONG TcAcceptedCount;
280  	u_char *PpiPacket;
281  };
282  int
283  TcFindAllDevs(pcap_if_list_t *devlist, char *errbuf)
284  {
285  	TC_API_LOAD_STATUS loadStatus;
286  	ULONG numPorts;
287  	PTC_PORT pPorts = NULL;
288  	TC_STATUS status;
289  	int result = 0;
290  	pcap_if_t *dev;
291  	ULONG i;
292  	do
293  	{
294  		loadStatus = LoadTcFunctions();
295  		if (loadStatus != TC_API_LOADED)
296  		{
297  			result = 0;
298  			break;
299  		}
300  		status = g_TcFunctions.QueryPortList(&pPorts, &numPorts);
301  		if (status != TC_SUCCESS)
302  		{
303  			result = 0;
304  			break;
305  		}
306  		for (i = 0; i < numPorts; i++)
307  		{
308  			dev = TcCreatePcapIfFromPort(pPorts[i]);
309  			if (dev != NULL)
310  				pcap_add_dev(devlist, dev->name, dev->flags, dev->description, errbuf);
311  		}
312  		if (numPorts > 0)
313  		{
314  			status = g_TcFunctions.FreePortList(pPorts);
315  		}
316  	}while(FALSE);
317  	return result;
318  }
319  static pcap_if_t* TcCreatePcapIfFromPort(TC_PORT port)
320  {
321  	CHAR *name;
322  	CHAR *description;
323  	pcap_if_t *newIf = NULL;
324  	newIf = (pcap_if_t*)malloc(sizeof(*newIf));
325  	if (newIf == NULL)
326  	{
327  		return NULL;
328  	}
329  	memset(newIf, 0, sizeof(*newIf));
330  	name = g_TcFunctions.PortGetName(port);
331  	description = g_TcFunctions.PortGetDescription(port);
332  	newIf->name = (char*)malloc(strlen(name) + 1);
333  	if (newIf->name == NULL)
334  	{
335  		free(newIf);
336  		return NULL;
337  	}
338  	newIf->description = (char*)malloc(strlen(description) + 1);
339  	if (newIf->description == NULL)
340  	{
341  		free(newIf->name);
342  		free(newIf);
343  		return NULL;
344  	}
345  	strcpy(newIf->name, name);
346  	strcpy(newIf->description, description);
347  	newIf->addresses = NULL;
348  	newIf->next = NULL;
349  	newIf->flags = 0;
350  	return newIf;
351  }
352  static int
353  TcActivate(pcap_t *p)
354  {
355  	struct pcap_tc *pt = p->priv;
356  	TC_STATUS status;
357  	ULONG timeout;
358  	PPPI_HEADER pPpiHeader;
359  	if (p->opt.rfmon)
360  	{
361  		return PCAP_ERROR_RFMON_NOTSUP;
362  	}
363  	pt->PpiPacket = malloc(sizeof(PPI_HEADER) + MAX_TC_PACKET_SIZE);
364  	if (pt->PpiPacket == NULL)
365  	{
366  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Error allocating memory");
367  		return PCAP_ERROR;
368  	}
369  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
370  		p->snapshot = MAXIMUM_SNAPLEN;
371  	pPpiHeader = (PPPI_HEADER)pt->PpiPacket;
372  	pPpiHeader->PacketHeader.PphDlt = DLT_EN10MB;
373  	pPpiHeader->PacketHeader.PphLength = sizeof(PPI_HEADER);
374  	pPpiHeader->PacketHeader.PphFlags = 0;
375  	pPpiHeader->PacketHeader.PphVersion = 0;
376  	pPpiHeader->AggregationFieldHeader.PfhLength = sizeof(PPI_FIELD_AGGREGATION_EXTENSION);
377  	pPpiHeader->AggregationFieldHeader.PfhType = PPI_FIELD_TYPE_AGGREGATION_EXTENSION;
378  	pPpiHeader->Dot3FieldHeader.PfhLength = sizeof(PPI_FIELD_802_3_EXTENSION);
379  	pPpiHeader->Dot3FieldHeader.PfhType = PPI_FIELD_TYPE_802_3_EXTENSION;
380  	status = g_TcFunctions.InstanceOpenByName(p->opt.device, &pt->TcInstance);
381  	if (status != TC_SUCCESS)
382  	{
383  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Error opening TurboCap adapter: %s", g_TcFunctions.StatusGetString(status));
384  		return PCAP_ERROR;
385  	}
386  	p->linktype = DLT_EN10MB;
387  	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
388  	if (p->dlt_list != NULL) {
389  		p->dlt_list[0] = DLT_EN10MB;
390  		p->dlt_list[1] = DLT_PPI;
391  		p->dlt_count = 2;
392  	}
393  	status = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_RX_STATUS, 1);
394  	if (status != TC_SUCCESS)
395  	{
396  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,"Error enabling reception on a TurboCap instance: %s", g_TcFunctions.StatusGetString(status));
397  		goto bad;
398  	}
399  	status = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_TX_STATUS, 1);
400  	p->inject_op = TcInject;
401  	if (p->opt.timeout == 0)
402  	{
403  		timeout = 0xFFFFFFFF;
404  	}
405  	else
406  	if (p->opt.timeout < 0)
407  	{
408  		timeout = 10;
409  	}
410  	else
411  	{
412  		timeout = p->opt.timeout;
413  	}
414  	status = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_READ_TIMEOUT, timeout);
415  	if (status != TC_SUCCESS)
416  	{
417  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,"Error setting the read timeout a TurboCap instance: %s", g_TcFunctions.StatusGetString(status));
418  		goto bad;
419  	}
420  	p->read_op = TcRead;
421  	p->setfilter_op = pcap_install_bpf_program;
<span onclick='openModal()' class='match'>422  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
423  	p->set_datalink_op = TcSetDatalink;
424  	p->getnonblock_op = TcGetNonBlock;
425  	p->setnonblock_op = TcSetNonBlock;
426  	p->stats_op = TcStats;
427  #ifdef _WIN32
428  	p->stats_ex_op = TcStatsEx;
429  	p->setbuff_op = TcSetBuff;
430  	p->setmode_op = TcSetMode;
431  	p->setmintocopy_op = TcSetMinToCopy;
432  	p->getevent_op = TcGetReceiveWaitHandle;
433  	p->oid_get_request_op = TcOidGetRequest;
434  	p->oid_set_request_op = TcOidSetRequest;
435  	p->sendqueue_transmit_op = TcSendqueueTransmit;
436  	p->setuserbuffer_op = TcSetUserBuffer;
437  	p->live_dump_op = TcLiveDump;
</span>438  	p->live_dump_ended_op = TcLiveDumpEnded;
439  	p->get_airpcap_handle_op = TcGetAirPcapHandle;
440  #else
441  	p->selectable_fd = -1;
442  #endif
443  	p->cleanup_op = TcCleanup;
444  	return 0;
445  bad:
446  	TcCleanup(p);
447  	return PCAP_ERROR;
448  }
449  pcap_t *
450  TcCreate(const char *device, char *ebuf, int *is_ours)
451  {
452  	ULONG numPorts;
453  	PTC_PORT pPorts = NULL;
454  	TC_STATUS status;
455  	int is_tc;
456  	ULONG i;
457  	pcap_t *p;
458  	if (LoadTcFunctions() != TC_API_LOADED)
459  	{
460  		*is_ours = 0;
461  		return NULL;
462  	}
463  	status = g_TcFunctions.QueryPortList(&pPorts, &numPorts);
464  	if (status != TC_SUCCESS)
465  	{
466  		*is_ours = 0;
467  		return NULL;
468  	}
469  	is_tc = FALSE;
470  	for (i = 0; i < numPorts; i++)
471  	{
472  		if (strcmp(g_TcFunctions.PortGetName(pPorts[i]), device) == 0)
473  		{
474  			is_tc = TRUE;
475  			break;
476  		}
477  	}
478  	if (numPorts > 0)
479  	{
480  		(void)g_TcFunctions.FreePortList(pPorts);
481  	}
482  	if (!is_tc)
483  	{
484  		*is_ours = 0;
485  		return NULL;
486  	}
487  	*is_ours = 1;
488  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_tc);
489  	if (p == NULL)
490  		return NULL;
491  	p->activate_op = TcActivate;
492  	p->getnonblock_op = TcGetNonBlock;
493  	p->setnonblock_op = TcSetNonBlock;
494  	return p;
495  }
496  static int TcSetDatalink(pcap_t *p, int dlt)
497  {
498  	return 0;
499  }
500  static int TcGetNonBlock(pcap_t *p)
501  {
502  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
503  	    "Non-blocking mode isn't supported for TurboCap ports");
504  	return -1;
505  }
506  static int TcSetNonBlock(pcap_t *p, int nonblock)
507  {
508  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
509  	    "Non-blocking mode isn't supported for TurboCap ports");
510  	return -1;
511  }
512  static void TcCleanup(pcap_t *p)
513  {
514  	struct pcap_tc *pt = p->priv;
515  	if (pt->TcPacketsBuffer != NULL)
516  	{
517  		g_TcFunctions.PacketsBufferDestroy(pt->TcPacketsBuffer);
518  		pt->TcPacketsBuffer = NULL;
519  	}
520  	if (pt->TcInstance != NULL)
521  	{
522  		g_TcFunctions.InstanceClose(pt->TcInstance);
523  		pt->TcInstance = NULL;
524  	}
525  	if (pt->PpiPacket != NULL)
526  	{
527  		free(pt->PpiPacket);
528  		pt->PpiPacket = NULL;
529  	}
530  	pcap_cleanup_live_common(p);
531  }
532  static int TcInject(pcap_t *p, const void *buf, int size)
533  {
534  	struct pcap_tc *pt = p->priv;
535  	TC_STATUS status;
536  	TC_PACKETS_BUFFER buffer;
537  	TC_PACKET_HEADER header;
538  	if (size >= 0xFFFF)
539  	{
540  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "send error: the TurboCap API does not support packets larger than 64k");
541  		return -1;
542  	}
543  	status = g_TcFunctions.PacketsBufferCreate(sizeof(TC_PACKET_HEADER) + TC_ALIGN_USHORT_TO_64BIT((USHORT)size), &buffer);
544  	if (status != TC_SUCCESS)
545  	{
546  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "send error: TcPacketsBufferCreate failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
547  		return -1;
548  	}
549  	memset(&header, 0, sizeof(header));
550  	header.Length = (USHORT)size;
551  	header.CapturedLength = header.Length;
552  	status = g_TcFunctions.PacketsBufferCommitNextPacket(buffer, &header, (PVOID)buf);
553  	if (status == TC_SUCCESS)
554  	{
555  		status = g_TcFunctions.InstanceTransmitPackets(pt->TcInstance, buffer);
556  		if (status != TC_SUCCESS)
557  		{
558  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "send error: TcInstanceTransmitPackets failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
559  		}
560  	}
561  	else
562  	{
563  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "send error: TcPacketsBufferCommitNextPacket failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
564  	}
565  	g_TcFunctions.PacketsBufferDestroy(buffer);
566  	if (status != TC_SUCCESS)
567  	{
568  		return -1;
569  	}
570  	else
571  	{
572  		return 0;
573  	}
574  }
575  static int TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
576  {
577  	struct pcap_tc *pt = p->priv;
578  	TC_STATUS status;
579  	int n = 0;
580  	if (p->break_loop)
581  	{
582  		p->break_loop = 0;
583  		return -2;
584  	}
585  	if (pt->TcPacketsBuffer == NULL)
586  	{
587  		status = g_TcFunctions.InstanceReceivePackets(pt->TcInstance, &pt->TcPacketsBuffer);
588  		if (status != TC_SUCCESS)
589  		{
590  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "read error, TcInstanceReceivePackets failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
591  			return -1;
592  		}
593  	}
594  	while (TRUE)
595  	{
596  		struct pcap_pkthdr hdr;
597  		TC_PACKET_HEADER tcHeader;
598  		PVOID data;
599  		ULONG filterResult;
600  		if (p->break_loop)
601  		{
602  			if (n == 0)
603  			{
604  				p->break_loop = 0;
605  				return -2;
606  			}
607  			else
608  			{
609  				return n;
610  			}
611  		}
612  		if (pt->TcPacketsBuffer == NULL)
613  		{
614  			break;
615  		}
616  		status = g_TcFunctions.PacketsBufferQueryNextPacket(pt->TcPacketsBuffer, &tcHeader, &data);
617  		if (status == TC_ERROR_END_OF_BUFFER)
618  		{
619  			g_TcFunctions.PacketsBufferDestroy(pt->TcPacketsBuffer);
620  			pt->TcPacketsBuffer = NULL;
621  			break;
622  		}
623  		if (status != TC_SUCCESS)
624  		{
625  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "read error, TcPacketsBufferQueryNextPacket failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
626  			return -1;
627  		}
628  		if (p->fcode.bf_insns)
629  		{
630  			filterResult = pcap_filter(p->fcode.bf_insns, data, tcHeader.Length, tcHeader.CapturedLength);
631  			if (filterResult == 0)
632  			{
633  				continue;
634  			}
635  			if (filterResult > tcHeader.CapturedLength)
636  			{
637  				filterResult = tcHeader.CapturedLength;
638  			}
639  		}
640  		else
641  		{
642  			filterResult = tcHeader.CapturedLength;
643  		}
644  		pt->TcAcceptedCount ++;
645  		hdr.ts.tv_sec = (bpf_u_int32)(tcHeader.Timestamp / (ULONGLONG)(1000  * 1000 * 1000));
646  		hdr.ts.tv_usec = (bpf_u_int32)((tcHeader.Timestamp % (ULONGLONG)(1000  * 1000 * 1000)) / 1000);
647  		if (p->linktype == DLT_EN10MB)
648  		{
649  			hdr.caplen = filterResult;
650  			hdr.len = tcHeader.Length;
651  			(*callback)(user, &hdr, data);
652  		}
653  		else
654  		{
655  			PPPI_HEADER pPpiHeader = (PPPI_HEADER)pt->PpiPacket;
656  			PVOID data2 = pPpiHeader + 1;
657  			pPpiHeader->AggregationField.InterfaceId = TC_PH_FLAGS_RX_PORT_ID(tcHeader.Flags);
658  			pPpiHeader->Dot3Field.Errors = tcHeader.Errors;
659  			if (tcHeader.Flags & TC_PH_FLAGS_CHECKSUM)
660  			{
661  				pPpiHeader->Dot3Field.Flags = PPI_FLD_802_3_EXT_FLAG_FCS_PRESENT;
662  			}
663  			else
664  			{
665  				pPpiHeader->Dot3Field.Flags = 0;
666  			}
667  			if (filterResult <= MAX_TC_PACKET_SIZE)
668  			{
669  				memcpy(data2, data, filterResult);
670  				hdr.caplen = sizeof(PPI_HEADER) + filterResult;
671  				hdr.len = sizeof(PPI_HEADER) + tcHeader.Length;
672  			}
673  			else
674  			{
675  				memcpy(data2, data, MAX_TC_PACKET_SIZE);
676  				hdr.caplen = sizeof(PPI_HEADER) + MAX_TC_PACKET_SIZE;
677  				hdr.len = sizeof(PPI_HEADER) + tcHeader.Length;
678  			}
679  			(*callback)(user, &hdr, pt->PpiPacket);
680  		}
681  		if (++n >= cnt && cnt > 0)
682  		{
683  			return n;
684  		}
685  	}
686  	return n;
687  }
688  static int
689  TcStats(pcap_t *p, struct pcap_stat *ps)
690  {
691  	struct pcap_tc *pt = p->priv;
692  	TC_STATISTICS statistics;
693  	TC_STATUS status;
694  	ULONGLONG counter;
695  	struct pcap_stat s;
696  	status = g_TcFunctions.InstanceQueryStatistics(pt->TcInstance, &statistics);
697  	if (status != TC_SUCCESS)
698  	{
699  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcInstanceQueryStatistics: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
700  		return -1;
701  	}
702  	memset(&s, 0, sizeof(s));
703  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_TOTAL_RX_PACKETS, &counter);
704  	if (status != TC_SUCCESS)
705  	{
706  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcStatisticsQueryValue: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
707  		return -1;
708  	}
709  	if (counter <= (ULONGLONG)0xFFFFFFFF)
710  	{
711  		s.ps_recv = (ULONG)counter;
712  	}
713  	else
714  	{
715  		s.ps_recv = 0xFFFFFFFF;
716  	}
717  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_RX_DROPPED_PACKETS, &counter);
718  	if (status != TC_SUCCESS)
719  	{
720  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcStatisticsQueryValue: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
721  		return -1;
722  	}
723  	if (counter <= (ULONGLONG)0xFFFFFFFF)
724  	{
725  		s.ps_ifdrop = (ULONG)counter;
726  		s.ps_drop = (ULONG)counter;
727  	}
728  	else
729  	{
730  		s.ps_ifdrop = 0xFFFFFFFF;
731  		s.ps_drop = 0xFFFFFFFF;
732  	}
733  #if defined(_WIN32) && defined(ENABLE_REMOTE)
734  	s.ps_capt = pt->TcAcceptedCount;
735  #endif
736  	*ps = s;
737  	return 0;
738  }
739  #ifdef _WIN32
740  static struct pcap_stat *
741  TcStatsEx(pcap_t *p, int *pcap_stat_size)
742  {
743  	struct pcap_tc *pt = p->priv;
744  	TC_STATISTICS statistics;
745  	TC_STATUS status;
746  	ULONGLONG counter;
747  	*pcap_stat_size = sizeof (p->stat);
748  	status = g_TcFunctions.InstanceQueryStatistics(pt->TcInstance, &statistics);
749  	if (status != TC_SUCCESS)
750  	{
751  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcInstanceQueryStatistics: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
752  		return NULL;
753  	}
754  	memset(&p->stat, 0, sizeof(p->stat));
755  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_TOTAL_RX_PACKETS, &counter);
756  	if (status != TC_SUCCESS)
757  	{
758  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcStatisticsQueryValue: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
759  		return NULL;
760  	}
761  	if (counter <= (ULONGLONG)0xFFFFFFFF)
762  	{
763  		p->stat.ps_recv = (ULONG)counter;
764  	}
765  	else
766  	{
767  		p->stat.ps_recv = 0xFFFFFFFF;
768  	}
769  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_RX_DROPPED_PACKETS, &counter);
770  	if (status != TC_SUCCESS)
771  	{
772  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcStatisticsQueryValue: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
773  		return NULL;
774  	}
775  	if (counter <= (ULONGLONG)0xFFFFFFFF)
776  	{
777  		p->stat.ps_ifdrop = (ULONG)counter;
778  		p->stat.ps_drop = (ULONG)counter;
779  	}
780  	else
781  	{
782  		p->stat.ps_ifdrop = 0xFFFFFFFF;
783  		p->stat.ps_drop = 0xFFFFFFFF;
784  	}
785  #if defined(_WIN32) && defined(ENABLE_REMOTE)
786  	p->stat.ps_capt = pt->TcAcceptedCount;
787  #endif
788  	return &p->stat;
789  }
790  static int
791  TcSetBuff(pcap_t *p, int dim)
792  {
793  	return 0;
794  }
795  static int
796  TcSetMode(pcap_t *p, int mode)
797  {
798  	if (mode != MODE_CAPT)
799  	{
800  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Mode %d not supported by TurboCap devices. TurboCap only supports capture.", mode);
801  		return -1;
802  	}
803  	return 0;
804  }
805  static int
806  TcSetMinToCopy(pcap_t *p, int size)
807  {
808  	struct pcap_tc *pt = p->priv;
809  	TC_STATUS status;
810  	if (size < 0)
811  	{
812  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Mintocopy cannot be less than 0.");
813  		return -1;
814  	}
815  	status = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_MINTOCOPY, (ULONG)size);
816  	if (status != TC_SUCCESS)
817  	{
818  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error setting the mintocopy: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
819  	}
820  	return 0;
821  }
822  static HANDLE
823  TcGetReceiveWaitHandle(pcap_t *p)
824  {
825  	struct pcap_tc *pt = p->priv;
826  	return g_TcFunctions.InstanceGetReceiveWaitHandle(pt->TcInstance);
827  }
828  static int
829  TcOidGetRequest(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_, size_t *lenp _U_)
830  {
831  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
832  	    "An OID get request cannot be performed on a TurboCap device");
833  	return PCAP_ERROR;
834  }
835  static int
836  TcOidSetRequest(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
837      size_t *lenp _U_)
838  {
839  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
840  	    "An OID set request cannot be performed on a TurboCap device");
841  	return PCAP_ERROR;
842  }
843  static u_int
844  TcSendqueueTransmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
845  {
846  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
847  	    "Packets cannot be bulk transmitted on a TurboCap device");
848  	return 0;
849  }
850  static int
851  TcSetUserBuffer(pcap_t *p, int size _U_)
852  {
853  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
854  	    "The user buffer cannot be set on a TurboCap device");
855  	return -1;
856  }
857  static int
858  TcLiveDump(pcap_t *p, char *filename _U_, int maxsize _U_, int maxpacks _U_)
859  {
860  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
861  	    "Live packet dumping cannot be performed on a TurboCap device");
862  	return -1;
863  }
864  static int
865  TcLiveDumpEnded(pcap_t *p, int sync _U_)
866  {
867  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
868  	    "Live packet dumping cannot be performed on a TurboCap device");
869  	return -1;
870  }
871  static PAirpcapHandle
872  TcGetAirPcapHandle(pcap_t *p _U_)
873  {
874  	return NULL;
875  }
876  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-list.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-tc.c</div>
                </div>
                <div class="column column_space"><pre><code>12              list->head->next = NULL;
13              list->data_size  = data_size;
14              list->tail = list->head;
15              list->size = 0;
16              list->add_back  = list_add_back;   
17              list->add_front  = list_add_front;
18              list->delete_node = list_delete_node;
19              list->delete_at  = list_delete_at;
20              list->modify_at  = list_modify_at;
21              list->have_same  = list_have_same;
22              list->have_same_cmp  = list_have_same_cmp;
23              list->foreach  = list_foreach;
24              list->clear   = list_clear;
25              list->sort   = list_sort;
26              list->destroy  = list_destroy;
</pre></code></div>
                <div class="column column_space"><pre><code>422  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
423  	p->set_datalink_op = TcSetDatalink;
424  	p->getnonblock_op = TcGetNonBlock;
425  	p->setnonblock_op = TcSetNonBlock;
426  	p->stats_op = TcStats;
427  #ifdef _WIN32
428  	p->stats_ex_op = TcStatsEx;
429  	p->setbuff_op = TcSetBuff;
430  	p->setmode_op = TcSetMode;
431  	p->setmintocopy_op = TcSetMinToCopy;
432  	p->getevent_op = TcGetReceiveWaitHandle;
433  	p->oid_get_request_op = TcOidGetRequest;
434  	p->oid_set_request_op = TcOidSetRequest;
435  	p->sendqueue_transmit_op = TcSendqueueTransmit;
436  	p->setuserbuffer_op = TcSetUserBuffer;
437  	p->live_dump_op = TcLiveDump;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    