
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_dec.c</h3>
            <pre><code>1  #include &lt;stdlib.h&gt;
2  #include &quot;src/dec/alphai_dec.h&quot;
3  #include &quot;src/dec/vp8li_dec.h&quot;
4  #include &quot;src/dsp/dsp.h&quot;
5  #include &quot;src/dsp/lossless.h&quot;
6  #include &quot;src/dsp/lossless_common.h&quot;
7  #include &quot;src/dsp/yuv.h&quot;
8  #include &quot;src/utils/endian_inl_utils.h&quot;
9  #include &quot;src/utils/huffman_utils.h&quot;
10  #include &quot;src/utils/utils.h&quot;
11  #define NUM_ARGB_CACHE_ROWS          16
12  static const int kCodeLengthLiterals = 16;
13  static const int kCodeLengthRepeatCode = 16;
14  static const uint8_t kCodeLengthExtraBits[3] = { 2, 3, 7 };
15  static const uint8_t kCodeLengthRepeatOffsets[3] = { 3, 3, 11 };
16  typedef enum {
17    GREEN = 0,
18    RED   = 1,
19    BLUE  = 2,
20    ALPHA = 3,
21    DIST  = 4
22  } HuffIndex;
23  static const uint16_t kAlphabetSize[HUFFMAN_CODES_PER_META_CODE] = {
24    NUM_LITERAL_CODES + NUM_LENGTH_CODES,
25    NUM_LITERAL_CODES, NUM_LITERAL_CODES, NUM_LITERAL_CODES,
26    NUM_DISTANCE_CODES
27  };
28  static const uint8_t kLiteralMap[HUFFMAN_CODES_PER_META_CODE] = {
29    0, 1, 1, 1, 0
30  };
31  #define NUM_CODE_LENGTH_CODES       19
32  static const uint8_t kCodeLengthCodeOrder[NUM_CODE_LENGTH_CODES] = {
33    17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
34  };
35  #define CODE_TO_PLANE_CODES        120
36  static const uint8_t kCodeToPlane[CODE_TO_PLANE_CODES] = {
37    0x18, 0x07, 0x17, 0x19, 0x28, 0x06, 0x27, 0x29, 0x16, 0x1a,
38    0x26, 0x2a, 0x38, 0x05, 0x37, 0x39, 0x15, 0x1b, 0x36, 0x3a,
39    0x25, 0x2b, 0x48, 0x04, 0x47, 0x49, 0x14, 0x1c, 0x35, 0x3b,
40    0x46, 0x4a, 0x24, 0x2c, 0x58, 0x45, 0x4b, 0x34, 0x3c, 0x03,
41    0x57, 0x59, 0x13, 0x1d, 0x56, 0x5a, 0x23, 0x2d, 0x44, 0x4c,
42    0x55, 0x5b, 0x33, 0x3d, 0x68, 0x02, 0x67, 0x69, 0x12, 0x1e,
43    0x66, 0x6a, 0x22, 0x2e, 0x54, 0x5c, 0x43, 0x4d, 0x65, 0x6b,
44    0x32, 0x3e, 0x78, 0x01, 0x77, 0x79, 0x53, 0x5d, 0x11, 0x1f,
45    0x64, 0x6c, 0x42, 0x4e, 0x76, 0x7a, 0x21, 0x2f, 0x75, 0x7b,
46    0x31, 0x3f, 0x63, 0x6d, 0x52, 0x5e, 0x00, 0x74, 0x7c, 0x41,
47    0x4f, 0x10, 0x20, 0x62, 0x6e, 0x30, 0x73, 0x7d, 0x51, 0x5f,
48    0x40, 0x72, 0x7e, 0x61, 0x6f, 0x50, 0x71, 0x7f, 0x60, 0x70
49  };
50  #define FIXED_TABLE_SIZE (630 * 3 + 410)
51  static const uint16_t kTableSize[12] = {
52    FIXED_TABLE_SIZE + 654,
53    FIXED_TABLE_SIZE + 656,
54    FIXED_TABLE_SIZE + 658,
55    FIXED_TABLE_SIZE + 662,
56    FIXED_TABLE_SIZE + 670,
57    FIXED_TABLE_SIZE + 686,
58    FIXED_TABLE_SIZE + 718,
59    FIXED_TABLE_SIZE + 782,
60    FIXED_TABLE_SIZE + 912,
61    FIXED_TABLE_SIZE + 1168,
62    FIXED_TABLE_SIZE + 1680,
63    FIXED_TABLE_SIZE + 2704
64  };
65  static int DecodeImageStream(int xsize, int ysize,
66                               int is_level0,
67                               VP8LDecoder* const dec,
68                               uint32_t** const decoded_data);
69  int VP8LCheckSignature(const uint8_t* const data, size_t size) {
70    return (size &gt;= VP8L_FRAME_HEADER_SIZE &amp;&amp;
71            data[0] == VP8L_MAGIC_BYTE &amp;&amp;
72            (data[4] &gt;&gt; 5) == 0);  
73  }
74  static int ReadImageInfo(VP8LBitReader* const br,
75                           int* const width, int* const height,
76                           int* const has_alpha) {
77    if (VP8LReadBits(br, 8) != VP8L_MAGIC_BYTE) return 0;
78    *width = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;
79    *height = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;
80    *has_alpha = VP8LReadBits(br, 1);
81    if (VP8LReadBits(br, VP8L_VERSION_BITS) != 0) return 0;
82    return !br-&gt;eos_;
83  }
84  int VP8LGetInfo(const uint8_t* data, size_t data_size,
85                  int* const width, int* const height, int* const has_alpha) {
86    if (data == NULL || data_size &lt; VP8L_FRAME_HEADER_SIZE) {
87      return 0;         
88    } else if (!VP8LCheckSignature(data, data_size)) {
89      return 0;         
90    } else {
91      int w, h, a;
92      VP8LBitReader br;
93      VP8LInitBitReader(&amp;br, data, data_size);
94      if (!ReadImageInfo(&amp;br, &amp;w, &amp;h, &amp;a)) {
95        return 0;
96      }
97      if (width != NULL) *width = w;
98      if (height != NULL) *height = h;
99      if (has_alpha != NULL) *has_alpha = a;
100      return 1;
101    }
102  }
103  static WEBP_INLINE int GetCopyDistance(int distance_symbol,
104                                         VP8LBitReader* const br) {
105    int extra_bits, offset;
106    if (distance_symbol &lt; 4) {
107      return distance_symbol + 1;
108    }
109    extra_bits = (distance_symbol - 2) &gt;&gt; 1;
110    offset = (2 + (distance_symbol &amp; 1)) &lt;&lt; extra_bits;
111    return offset + VP8LReadBits(br, extra_bits) + 1;
112  }
113  static WEBP_INLINE int GetCopyLength(int length_symbol,
114                                       VP8LBitReader* const br) {
115    return GetCopyDistance(length_symbol, br);
116  }
117  static WEBP_INLINE int PlaneCodeToDistance(int xsize, int plane_code) {
118    if (plane_code &gt; CODE_TO_PLANE_CODES) {
119      return plane_code - CODE_TO_PLANE_CODES;
120    } else {
121      const int dist_code = kCodeToPlane[plane_code - 1];
122      const int yoffset = dist_code &gt;&gt; 4;
123      const int xoffset = 8 - (dist_code &amp; 0xf);
124      const int dist = yoffset * xsize + xoffset;
125      return (dist &gt;= 1) ? dist : 1;  
126    }
127  }
128  static WEBP_INLINE int ReadSymbol(const HuffmanCode* table,
129                                    VP8LBitReader* const br) {
130    int nbits;
131    uint32_t val = VP8LPrefetchBits(br);
132    table += val &amp; HUFFMAN_TABLE_MASK;
133    nbits = table-&gt;bits - HUFFMAN_TABLE_BITS;
134    if (nbits &gt; 0) {
135      VP8LSetBitPos(br, br-&gt;bit_pos_ + HUFFMAN_TABLE_BITS);
136      val = VP8LPrefetchBits(br);
137      table += table-&gt;value;
138      table += val &amp; ((1 &lt;&lt; nbits) - 1);
139    }
140    VP8LSetBitPos(br, br-&gt;bit_pos_ + table-&gt;bits);
141    return table-&gt;value;
142  }
143  #define BITS_SPECIAL_MARKER 0x100  
144  #define PACKED_NON_LITERAL_CODE 0  
145  static WEBP_INLINE int ReadPackedSymbols(const HTreeGroup* group,
146                                           VP8LBitReader* const br,
147                                           uint32_t* const dst) {
148    const uint32_t val = VP8LPrefetchBits(br) &amp; (HUFFMAN_PACKED_TABLE_SIZE - 1);
149    const HuffmanCode32 code = group-&gt;packed_table[val];
150    assert(group-&gt;use_packed_table);
151    if (code.bits &lt; BITS_SPECIAL_MARKER) {
152      VP8LSetBitPos(br, br-&gt;bit_pos_ + code.bits);
153      *dst = code.value;
154      return PACKED_NON_LITERAL_CODE;
155    } else {
156      VP8LSetBitPos(br, br-&gt;bit_pos_ + code.bits - BITS_SPECIAL_MARKER);
157      assert(code.value &gt;= NUM_LITERAL_CODES);
158      return code.value;
159    }
160  }
161  static int AccumulateHCode(HuffmanCode hcode, int shift,
162                             HuffmanCode32* const huff) {
163    huff-&gt;bits += hcode.bits;
164    huff-&gt;value |= (uint32_t)hcode.value &lt;&lt; shift;
165    assert(huff-&gt;bits &lt;= HUFFMAN_TABLE_BITS);
166    return hcode.bits;
167  }
168  static void BuildPackedTable(HTreeGroup* const htree_group) {
169    uint32_t code;
170    for (code = 0; code &lt; HUFFMAN_PACKED_TABLE_SIZE; ++code) {
171      uint32_t bits = code;
172      HuffmanCode32* const huff = &amp;htree_group-&gt;packed_table[bits];
173      HuffmanCode hcode = htree_group-&gt;htrees[GREEN][bits];
174      if (hcode.value &gt;= NUM_LITERAL_CODES) {
175        huff-&gt;bits = hcode.bits + BITS_SPECIAL_MARKER;
176        huff-&gt;value = hcode.value;
177      } else {
178        huff-&gt;bits = 0;
179        huff-&gt;value = 0;
180        bits &gt;&gt;= AccumulateHCode(hcode, 8, huff);
181        bits &gt;&gt;= AccumulateHCode(htree_group-&gt;htrees[RED][bits], 16, huff);
182        bits &gt;&gt;= AccumulateHCode(htree_group-&gt;htrees[BLUE][bits], 0, huff);
183        bits &gt;&gt;= AccumulateHCode(htree_group-&gt;htrees[ALPHA][bits], 24, huff);
184        (void)bits;
185      }
186    }
187  }
188  static int ReadHuffmanCodeLengths(
189      VP8LDecoder* const dec, const int* const code_length_code_lengths,
190      int num_symbols, int* const code_lengths) {
191    int ok = 0;
192    VP8LBitReader* const br = &amp;dec-&gt;br_;
193    int symbol;
194    int max_symbol;
195    int prev_code_len = DEFAULT_CODE_LENGTH;
196    HuffmanCode table[1 &lt;&lt; LENGTHS_TABLE_BITS];
197    if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,
198                               code_length_code_lengths,
199                               NUM_CODE_LENGTH_CODES)) {
200      goto End;
201    }
202    if (VP8LReadBits(br, 1)) {    
203      const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);
204      max_symbol = 2 + VP8LReadBits(br, length_nbits);
205      if (max_symbol &gt; num_symbols) {
206        goto End;
207      }
208    } else {
209      max_symbol = num_symbols;
210    }
211    symbol = 0;
212    while (symbol &lt; num_symbols) {
213      const HuffmanCode* p;
214      int code_len;
215      if (max_symbol-- == 0) break;
216      VP8LFillBitWindow(br);
217      p = &amp;table[VP8LPrefetchBits(br) &amp; LENGTHS_TABLE_MASK];
218      VP8LSetBitPos(br, br-&gt;bit_pos_ + p-&gt;bits);
219      code_len = p-&gt;value;
220      if (code_len &lt; kCodeLengthLiterals) {
221        code_lengths[symbol++] = code_len;
222        if (code_len != 0) prev_code_len = code_len;
223      } else {
224        const int use_prev = (code_len == kCodeLengthRepeatCode);
225        const int slot = code_len - kCodeLengthLiterals;
226        const int extra_bits = kCodeLengthExtraBits[slot];
227        const int repeat_offset = kCodeLengthRepeatOffsets[slot];
228        int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;
229        if (symbol + repeat &gt; num_symbols) {
230          goto End;
231        } else {
232          const int length = use_prev ? prev_code_len : 0;
233          while (repeat-- &gt; 0) code_lengths[symbol++] = length;
234        }
235      }
236    }
237    ok = 1;
238   End:
239    if (!ok) dec-&gt;status_ = VP8_STATUS_BITSTREAM_ERROR;
240    return ok;
241  }
242  static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,
243                             int* const code_lengths, HuffmanCode* const table) {
244    int ok = 0;
245    int size = 0;
246    VP8LBitReader* const br = &amp;dec-&gt;br_;
247    const int simple_code = VP8LReadBits(br, 1);
248    memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));
249    if (simple_code) {  
250      const int num_symbols = VP8LReadBits(br, 1) + 1;
251      const int first_symbol_len_code = VP8LReadBits(br, 1);
252      int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);
253      code_lengths[symbol] = 1;
254      if (num_symbols == 2) {
255        symbol = VP8LReadBits(br, 8);
256        code_lengths[symbol] = 1;
257      }
258      ok = 1;
259    } else {  
260      int i;
261      int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };
262      const int num_codes = VP8LReadBits(br, 4) + 4;
263      if (num_codes &gt; NUM_CODE_LENGTH_CODES) {
264        dec-&gt;status_ = VP8_STATUS_BITSTREAM_ERROR;
265        return 0;
266      }
267      for (i = 0; i &lt; num_codes; ++i) {
268        code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);
269      }
270      ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,
271                                  code_lengths);
272    }
273    ok = ok &amp;&amp; !br-&gt;eos_;
274    if (ok) {
275      size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,
276                                   code_lengths, alphabet_size);
277    }
278    if (!ok || size == 0) {
279      dec-&gt;status_ = VP8_STATUS_BITSTREAM_ERROR;
280      return 0;
281    }
282    return size;
283  }
284  static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,
285                              int color_cache_bits, int allow_recursion) {
286    int i, j;
287    VP8LBitReader* const br = &amp;dec-&gt;br_;
288    VP8LMetadata* const hdr = &amp;dec-&gt;hdr_;
289    uint32_t* huffman_image = NULL;
290    HTreeGroup* htree_groups = NULL;
291    HuffmanCode* huffman_tables = NULL;
292    HuffmanCode* huffman_table = NULL;
293    int num_htree_groups = 1;
294    int num_htree_groups_max = 1;
295    int max_alphabet_size = 0;
296    int* code_lengths = NULL;
297    const int table_size = kTableSize[color_cache_bits];
298    int* mapping = NULL;
299    int ok = 0;
300    if (allow_recursion &amp;&amp; VP8LReadBits(br, 1)) {
301      const int huffman_precision = VP8LReadBits(br, 3) + 2;
302      const int huffman_xsize = VP8LSubSampleSize(xsize, huffman_precision);
303      const int huffman_ysize = VP8LSubSampleSize(ysize, huffman_precision);
304      const int huffman_pixs = huffman_xsize * huffman_ysize;
305      if (!DecodeImageStream(huffman_xsize, huffman_ysize, 0, dec,
306                             &amp;huffman_image)) {
307        goto Error;
308      }
309      hdr-&gt;huffman_subsample_bits_ = huffman_precision;
310      for (i = 0; i &lt; huffman_pixs; ++i) {
311        const int group = (huffman_image[i] &gt;&gt; 8) &amp; 0xffff;
312        huffman_image[i] = group;
313        if (group &gt;= num_htree_groups_max) {
314          num_htree_groups_max = group + 1;
315        }
316      }
317      if (num_htree_groups_max &gt; 1000 || num_htree_groups_max &gt; xsize * ysize) {
318        mapping = (int*)WebPSafeMalloc(num_htree_groups_max, sizeof(*mapping));
319        if (mapping == NULL) {
320          dec-&gt;status_ = VP8_STATUS_OUT_OF_MEMORY;
321          goto Error;
322        }
323        memset(mapping, 0xff, num_htree_groups_max * sizeof(*mapping));
324        for (num_htree_groups = 0, i = 0; i &lt; huffman_pixs; ++i) {
325          int* const mapped_group = &amp;mapping[huffman_image[i]];
326          if (*mapped_group == -1) *mapped_group = num_htree_groups++;
327          huffman_image[i] = *mapped_group;
328        }
329      } else {
330        num_htree_groups = num_htree_groups_max;
331      }
332    }
333    if (br-&gt;eos_) goto Error;
334    for (j = 0; j &lt; HUFFMAN_CODES_PER_META_CODE; ++j) {
335      int alphabet_size = kAlphabetSize[j];
336      if (j == 0 &amp;&amp; color_cache_bits &gt; 0) {
337        alphabet_size += 1 &lt;&lt; color_cache_bits;
338      }
339      if (max_alphabet_size &lt; alphabet_size) {
340        max_alphabet_size = alphabet_size;
341      }
342    }
343    code_lengths = (int*)WebPSafeCalloc((uint64_t)max_alphabet_size,
344                                        sizeof(*code_lengths));
345    huffman_tables = (HuffmanCode*)WebPSafeMalloc(num_htree_groups * table_size,
346                                                  sizeof(*huffman_tables));
347    htree_groups = VP8LHtreeGroupsNew(num_htree_groups);
348    if (htree_groups == NULL || code_lengths == NULL || huffman_tables == NULL) {
349      dec-&gt;status_ = VP8_STATUS_OUT_OF_MEMORY;
350      goto Error;
351    }
352    huffman_table = huffman_tables;
353    for (i = 0; i &lt; num_htree_groups_max; ++i) {
354      if (mapping != NULL &amp;&amp; mapping[i] == -1) {
355        for (j = 0; j &lt; HUFFMAN_CODES_PER_META_CODE; ++j) {
356          int alphabet_size = kAlphabetSize[j];
357          if (j == 0 &amp;&amp; color_cache_bits &gt; 0) {
358            alphabet_size += (1 &lt;&lt; color_cache_bits);
359          }
360          if (!ReadHuffmanCode(alphabet_size, dec, code_lengths, NULL)) {
361            goto Error;
362          }
363        }
364      } else {
365        HTreeGroup* const htree_group =
366            &amp;htree_groups[(mapping == NULL) ? i : mapping[i]];
367        HuffmanCode** const htrees = htree_group-&gt;htrees;
368        int size;
369        int total_size = 0;
370        int is_trivial_literal = 1;
371        int max_bits = 0;
372        for (j = 0; j &lt; HUFFMAN_CODES_PER_META_CODE; ++j) {
373          int alphabet_size = kAlphabetSize[j];
374          htrees[j] = huffman_table;
375          if (j == 0 &amp;&amp; color_cache_bits &gt; 0) {
376            alphabet_size += (1 &lt;&lt; color_cache_bits);
377          }
378          size = ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_table);
379          if (size == 0) {
380            goto Error;
381          }
382          if (is_trivial_literal &amp;&amp; kLiteralMap[j] == 1) {
383            is_trivial_literal = (huffman_table-&gt;bits == 0);
384          }
385          total_size += huffman_table-&gt;bits;
386          huffman_table += size;
387          if (j &lt;= ALPHA) {
388            int local_max_bits = code_lengths[0];
389            int k;
390            for (k = 1; k &lt; alphabet_size; ++k) {
391              if (code_lengths[k] &gt; local_max_bits) {
392                local_max_bits = code_lengths[k];
393              }
394            }
395            max_bits += local_max_bits;
396          }
397        }
398        htree_group-&gt;is_trivial_literal = is_trivial_literal;
399        htree_group-&gt;is_trivial_code = 0;
400        if (is_trivial_literal) {
401          const int red = htrees[RED][0].value;
402          const int blue = htrees[BLUE][0].value;
403          const int alpha = htrees[ALPHA][0].value;
404          htree_group-&gt;literal_arb = ((uint32_t)alpha &lt;&lt; 24) | (red &lt;&lt; 16) | blue;
405          if (total_size == 0 &amp;&amp; htrees[GREEN][0].value &lt; NUM_LITERAL_CODES) {
406            htree_group-&gt;is_trivial_code = 1;
407            htree_group-&gt;literal_arb |= htrees[GREEN][0].value &lt;&lt; 8;
408          }
409        }
410        htree_group-&gt;use_packed_table =
411            !htree_group-&gt;is_trivial_code &amp;&amp; (max_bits &lt; HUFFMAN_PACKED_BITS);
412        if (htree_group-&gt;use_packed_table) BuildPackedTable(htree_group);
413      }
414    }
415    ok = 1;
416    hdr-&gt;huffman_image_ = huffman_image;
417    hdr-&gt;num_htree_groups_ = num_htree_groups;
418    hdr-&gt;htree_groups_ = htree_groups;
419    hdr-&gt;huffman_tables_ = huffman_tables;
420   Error:
421    WebPSafeFree(code_lengths);
422    WebPSafeFree(mapping);
423    if (!ok) {
424      WebPSafeFree(huffman_image);
425      WebPSafeFree(huffman_tables);
<span onclick='openModal()' class='match'>426      VP8LHtreeGroupsFree(htree_groups);
427    }
428    return ok;
429  }
430  #if !defined(WEBP_REDUCE_SIZE)
431  static int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {
</span>432    const int num_channels = 4;
433    const int in_width = io-&gt;mb_w;
434    const int out_width = io-&gt;scaled_width;
435    const int in_height = io-&gt;mb_h;
436    const int out_height = io-&gt;scaled_height;
437    const uint64_t work_size = 2 * num_channels * (uint64_t)out_width;
438    rescaler_t* work;        
439    const uint64_t scaled_data_size = (uint64_t)out_width;
440    uint32_t* scaled_data;  
441    const uint64_t memory_size = sizeof(*dec-&gt;rescaler) +
442                                 work_size * sizeof(*work) +
443                                 scaled_data_size * sizeof(*scaled_data);
444    uint8_t* memory = (uint8_t*)WebPSafeMalloc(memory_size, sizeof(*memory));
445    if (memory == NULL) {
446      dec-&gt;status_ = VP8_STATUS_OUT_OF_MEMORY;
447      return 0;
448    }
449    assert(dec-&gt;rescaler_memory == NULL);
450    dec-&gt;rescaler_memory = memory;
451    dec-&gt;rescaler = (WebPRescaler*)memory;
452    memory += sizeof(*dec-&gt;rescaler);
453    work = (rescaler_t*)memory;
454    memory += work_size * sizeof(*work);
455    scaled_data = (uint32_t*)memory;
456    WebPRescalerInit(dec-&gt;rescaler, in_width, in_height, (uint8_t*)scaled_data,
457                     out_width, out_height, 0, num_channels, work);
458    return 1;
459  }
460  #endif   
461  #if !defined(WEBP_REDUCE_SIZE)
462  static int Export(WebPRescaler* const rescaler, WEBP_CSP_MODE colorspace,
463                    int rgba_stride, uint8_t* const rgba) {
464    uint32_t* const src = (uint32_t*)rescaler-&gt;dst;
465    const int dst_width = rescaler-&gt;dst_width;
466    int num_lines_out = 0;
467    while (WebPRescalerHasPendingOutput(rescaler)) {
468      uint8_t* const dst = rgba + num_lines_out * rgba_stride;
469      WebPRescalerExportRow(rescaler);
470      WebPMultARGBRow(src, dst_width, 1);
471      VP8LConvertFromBGRA(src, dst_width, colorspace, dst);
472      ++num_lines_out;
473    }
474    return num_lines_out;
475  }
476  static int EmitRescaledRowsRGBA(const VP8LDecoder* const dec,
477                                  uint8_t* in, int in_stride, int mb_h,
478                                  uint8_t* const out, int out_stride) {
479    const WEBP_CSP_MODE colorspace = dec-&gt;output_-&gt;colorspace;
480    int num_lines_in = 0;
481    int num_lines_out = 0;
482    while (num_lines_in &lt; mb_h) {
483      uint8_t* const row_in = in + num_lines_in * in_stride;
484      uint8_t* const row_out = out + num_lines_out * out_stride;
485      const int lines_left = mb_h - num_lines_in;
486      const int needed_lines = WebPRescaleNeededLines(dec-&gt;rescaler, lines_left);
487      int lines_imported;
488      assert(needed_lines &gt; 0 &amp;&amp; needed_lines &lt;= lines_left);
489      WebPMultARGBRows(row_in, in_stride,
490                       dec-&gt;rescaler-&gt;src_width, needed_lines, 0);
491      lines_imported =
492          WebPRescalerImport(dec-&gt;rescaler, lines_left, row_in, in_stride);
493      assert(lines_imported == needed_lines);
494      num_lines_in += lines_imported;
495      num_lines_out += Export(dec-&gt;rescaler, colorspace, out_stride, row_out);
496    }
497    return num_lines_out;
498  }
499  #endif   
500  static int EmitRows(WEBP_CSP_MODE colorspace,
501                      const uint8_t* row_in, int in_stride,
502                      int mb_w, int mb_h,
503                      uint8_t* const out, int out_stride) {
504    int lines = mb_h;
505    uint8_t* row_out = out;
506    while (lines-- &gt; 0) {
507      VP8LConvertFromBGRA((const uint32_t*)row_in, mb_w, colorspace, row_out);
508      row_in += in_stride;
509      row_out += out_stride;
510    }
511    return mb_h;  
512  }
513  static void ConvertToYUVA(const uint32_t* const src, int width, int y_pos,
514                            const WebPDecBuffer* const output) {
515    const WebPYUVABuffer* const buf = &amp;output-&gt;u.YUVA;
516    WebPConvertARGBToY(src, buf-&gt;y + y_pos * buf-&gt;y_stride, width);
517    {
518      uint8_t* const u = buf-&gt;u + (y_pos &gt;&gt; 1) * buf-&gt;u_stride;
519      uint8_t* const v = buf-&gt;v + (y_pos &gt;&gt; 1) * buf-&gt;v_stride;
520      WebPConvertARGBToUV(src, u, v, width, !(y_pos &amp; 1));
521    }
522    if (buf-&gt;a != NULL) {
523      uint8_t* const a = buf-&gt;a + y_pos * buf-&gt;a_stride;
524  #if defined(WORDS_BIGENDIAN)
525      WebPExtractAlpha((uint8_t*)src + 0, 0, width, 1, a, 0);
526  #else
527      WebPExtractAlpha((uint8_t*)src + 3, 0, width, 1, a, 0);
528  #endif
529    }
530  }
531  static int ExportYUVA(const VP8LDecoder* const dec, int y_pos) {
532    WebPRescaler* const rescaler = dec-&gt;rescaler;
533    uint32_t* const src = (uint32_t*)rescaler-&gt;dst;
534    const int dst_width = rescaler-&gt;dst_width;
535    int num_lines_out = 0;
536    while (WebPRescalerHasPendingOutput(rescaler)) {
537      WebPRescalerExportRow(rescaler);
538      WebPMultARGBRow(src, dst_width, 1);
539      ConvertToYUVA(src, dst_width, y_pos, dec-&gt;output_);
540      ++y_pos;
541      ++num_lines_out;
542    }
543    return num_lines_out;
544  }
545  static int EmitRescaledRowsYUVA(const VP8LDecoder* const dec,
546                                  uint8_t* in, int in_stride, int mb_h) {
547    int num_lines_in = 0;
548    int y_pos = dec-&gt;last_out_row_;
549    while (num_lines_in &lt; mb_h) {
550      const int lines_left = mb_h - num_lines_in;
551      const int needed_lines = WebPRescaleNeededLines(dec-&gt;rescaler, lines_left);
552      int lines_imported;
553      WebPMultARGBRows(in, in_stride, dec-&gt;rescaler-&gt;src_width, needed_lines, 0);
554      lines_imported =
555          WebPRescalerImport(dec-&gt;rescaler, lines_left, in, in_stride);
556      assert(lines_imported == needed_lines);
557      num_lines_in += lines_imported;
558      in += needed_lines * in_stride;
559      y_pos += ExportYUVA(dec, y_pos);
560    }
561    return y_pos;
562  }
563  static int EmitRowsYUVA(const VP8LDecoder* const dec,
564                          const uint8_t* in, int in_stride,
565                          int mb_w, int num_rows) {
566    int y_pos = dec-&gt;last_out_row_;
567    while (num_rows-- &gt; 0) {
568      ConvertToYUVA((const uint32_t*)in, mb_w, y_pos, dec-&gt;output_);
569      in += in_stride;
570      ++y_pos;
571    }
572    return y_pos;
573  }
574  static int SetCropWindow(VP8Io* const io, int y_start, int y_end,
575                           uint8_t** const in_data, int pixel_stride) {
576    assert(y_start &lt; y_end);
577    assert(io-&gt;crop_left &lt; io-&gt;crop_right);
578    if (y_end &gt; io-&gt;crop_bottom) {
579      y_end = io-&gt;crop_bottom;  
580    }
581    if (y_start &lt; io-&gt;crop_top) {
582      const int delta = io-&gt;crop_top - y_start;
583      y_start = io-&gt;crop_top;
584      *in_data += delta * pixel_stride;
585    }
586    if (y_start &gt;= y_end) return 0;  
587    *in_data += io-&gt;crop_left * sizeof(uint32_t);
588    io-&gt;mb_y = y_start - io-&gt;crop_top;
589    io-&gt;mb_w = io-&gt;crop_right - io-&gt;crop_left;
590    io-&gt;mb_h = y_end - y_start;
591    return 1;  
592  }
593  static WEBP_INLINE int GetMetaIndex(
594      const uint32_t* const image, int xsize, int bits, int x, int y) {
595    if (bits == 0) return 0;
596    return image[xsize * (y &gt;&gt; bits) + (x &gt;&gt; bits)];
597  }
598  static WEBP_INLINE HTreeGroup* GetHtreeGroupForPos(VP8LMetadata* const hdr,
599                                                     int x, int y) {
600    const int meta_index = GetMetaIndex(hdr-&gt;huffman_image_, hdr-&gt;huffman_xsize_,
601                                        hdr-&gt;huffman_subsample_bits_, x, y);
602    assert(meta_index &lt; hdr-&gt;num_htree_groups_);
603    return hdr-&gt;htree_groups_ + meta_index;
604  }
605  typedef void (*ProcessRowsFunc)(VP8LDecoder* const dec, int row);
606  static void ApplyInverseTransforms(VP8LDecoder* const dec,
607                                     int start_row, int num_rows,
608                                     const uint32_t* const rows) {
609    int n = dec-&gt;next_transform_;
610    const int cache_pixs = dec-&gt;width_ * num_rows;
611    const int end_row = start_row + num_rows;
612    const uint32_t* rows_in = rows;
613    uint32_t* const rows_out = dec-&gt;argb_cache_;
614    while (n-- &gt; 0) {
615      VP8LTransform* const transform = &amp;dec-&gt;transforms_[n];
616      VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);
617      rows_in = rows_out;
618    }
619    if (rows_in != rows_out) {
620      memcpy(rows_out, rows_in, cache_pixs * sizeof(*rows_out));
621    }
622  }
623  static void ProcessRows(VP8LDecoder* const dec, int row) {
624    const uint32_t* const rows = dec-&gt;pixels_ + dec-&gt;width_ * dec-&gt;last_row_;
625    const int num_rows = row - dec-&gt;last_row_;
626    assert(row &lt;= dec-&gt;io_-&gt;crop_bottom);
627    assert(num_rows &lt;= NUM_ARGB_CACHE_ROWS);
628    if (num_rows &gt; 0) {    
629      VP8Io* const io = dec-&gt;io_;
630      uint8_t* rows_data = (uint8_t*)dec-&gt;argb_cache_;
631      const int in_stride = io-&gt;width * sizeof(uint32_t);  
632      ApplyInverseTransforms(dec, dec-&gt;last_row_, num_rows, rows);
633      if (!SetCropWindow(io, dec-&gt;last_row_, row, &amp;rows_data, in_stride)) {
634      } else {
635        const WebPDecBuffer* const output = dec-&gt;output_;
636        if (WebPIsRGBMode(output-&gt;colorspace)) {  
637          const WebPRGBABuffer* const buf = &amp;output-&gt;u.RGBA;
638          uint8_t* const rgba = buf-&gt;rgba + dec-&gt;last_out_row_ * buf-&gt;stride;
639          const int num_rows_out =
640  #if !defined(WEBP_REDUCE_SIZE)
641           io-&gt;use_scaling ?
642              EmitRescaledRowsRGBA(dec, rows_data, in_stride, io-&gt;mb_h,
643                                   rgba, buf-&gt;stride) :
644  #endif  
645              EmitRows(output-&gt;colorspace, rows_data, in_stride,
646                       io-&gt;mb_w, io-&gt;mb_h, rgba, buf-&gt;stride);
647          dec-&gt;last_out_row_ += num_rows_out;
648        } else {                              
649          dec-&gt;last_out_row_ = io-&gt;use_scaling ?
650              EmitRescaledRowsYUVA(dec, rows_data, in_stride, io-&gt;mb_h) :
651              EmitRowsYUVA(dec, rows_data, in_stride, io-&gt;mb_w, io-&gt;mb_h);
652        }
653        assert(dec-&gt;last_out_row_ &lt;= output-&gt;height);
654      }
655    }
656    dec-&gt;last_row_ = row;
657    assert(dec-&gt;last_row_ &lt;= dec-&gt;height_);
658  }
659  static int Is8bOptimizable(const VP8LMetadata* const hdr) {
660    int i;
661    if (hdr-&gt;color_cache_size_ &gt; 0) return 0;
662    for (i = 0; i &lt; hdr-&gt;num_htree_groups_; ++i) {
663      HuffmanCode** const htrees = hdr-&gt;htree_groups_[i].htrees;
664      if (htrees[RED][0].bits &gt; 0) return 0;
665      if (htrees[BLUE][0].bits &gt; 0) return 0;
666      if (htrees[ALPHA][0].bits &gt; 0) return 0;
667    }
668    return 1;
669  }
670  static void AlphaApplyFilter(ALPHDecoder* const alph_dec,
671                               int first_row, int last_row,
672                               uint8_t* out, int stride) {
673    if (alph_dec-&gt;filter_ != WEBP_FILTER_NONE) {
674      int y;
675      const uint8_t* prev_line = alph_dec-&gt;prev_line_;
676      assert(WebPUnfilters[alph_dec-&gt;filter_] != NULL);
677      for (y = first_row; y &lt; last_row; ++y) {
678        WebPUnfilters[alph_dec-&gt;filter_](prev_line, out, out, stride);
679        prev_line = out;
680        out += stride;
681      }
682      alph_dec-&gt;prev_line_ = prev_line;
683    }
684  }
685  static void ExtractPalettedAlphaRows(VP8LDecoder* const dec, int last_row) {
686    ALPHDecoder* const alph_dec = (ALPHDecoder*)dec-&gt;io_-&gt;opaque;
687    const int top_row =
688        (alph_dec-&gt;filter_ == WEBP_FILTER_NONE ||
689         alph_dec-&gt;filter_ == WEBP_FILTER_HORIZONTAL) ? dec-&gt;io_-&gt;crop_top
690                                                      : dec-&gt;last_row_;
691    const int first_row = (dec-&gt;last_row_ &lt; top_row) ? top_row : dec-&gt;last_row_;
692    assert(last_row &lt;= dec-&gt;io_-&gt;crop_bottom);
693    if (last_row &gt; first_row) {
694      const int width = dec-&gt;io_-&gt;width;
695      uint8_t* out = alph_dec-&gt;output_ + width * first_row;
696      const uint8_t* const in =
697        (uint8_t*)dec-&gt;pixels_ + dec-&gt;width_ * first_row;
698      VP8LTransform* const transform = &amp;dec-&gt;transforms_[0];
699      assert(dec-&gt;next_transform_ == 1);
700      assert(transform-&gt;type_ == COLOR_INDEXING_TRANSFORM);
701      VP8LColorIndexInverseTransformAlpha(transform, first_row, last_row,
702                                          in, out);
703      AlphaApplyFilter(alph_dec, first_row, last_row, out, width);
704    }
705    dec-&gt;last_row_ = dec-&gt;last_out_row_ = last_row;
706  }
707  static WEBP_INLINE uint32_t Rotate8b(uint32_t V) {
708  #if defined(WORDS_BIGENDIAN)
709    return ((V &amp; 0xff000000u) &gt;&gt; 24) | (V &lt;&lt; 8);
710  #else
711    return ((V &amp; 0xffu) &lt;&lt; 24) | (V &gt;&gt; 8);
712  #endif
713  }
714  static WEBP_INLINE void CopySmallPattern8b(const uint8_t* src, uint8_t* dst,
715                                             int length, uint32_t pattern) {
716    int i;
717    while ((uintptr_t)dst &amp; 3) {
718      *dst++ = *src++;
719      pattern = Rotate8b(pattern);
720      --length;
721    }
722    for (i = 0; i &lt; (length &gt;&gt; 2); ++i) {
723      ((uint32_t*)dst)[i] = pattern;
724    }
725    for (i &lt;&lt;= 2; i &lt; length; ++i) {
726      dst[i] = src[i];
727    }
728  }
729  static WEBP_INLINE void CopyBlock8b(uint8_t* const dst, int dist, int length) {
730    const uint8_t* src = dst - dist;
731    if (length &gt;= 8) {
732      uint32_t pattern = 0;
733      switch (dist) {
734        case 1:
735          pattern = src[0];
736  #if defined(__arm__) || defined(_M_ARM)   
737          pattern |= pattern &lt;&lt; 8;
738          pattern |= pattern &lt;&lt; 16;
739  #elif defined(WEBP_USE_MIPS_DSP_R2)
740          __asm__ volatile (&quot;replv.qb %0, %0&quot; : &quot;+r&quot;(pattern));
741  #else
742          pattern = 0x01010101u * pattern;
743  #endif
744          break;
745        case 2:
746  #if !defined(WORDS_BIGENDIAN)
747          memcpy(&amp;pattern, src, sizeof(uint16_t));
748  #else
749          pattern = ((uint32_t)src[0] &lt;&lt; 8) | src[1];
750  #endif
751  #if defined(__arm__) || defined(_M_ARM)
752          pattern |= pattern &lt;&lt; 16;
753  #elif defined(WEBP_USE_MIPS_DSP_R2)
754          __asm__ volatile (&quot;replv.ph %0, %0&quot; : &quot;+r&quot;(pattern));
755  #else
756          pattern = 0x00010001u * pattern;
757  #endif
758          break;
759        case 4:
760          memcpy(&amp;pattern, src, sizeof(uint32_t));
761          break;
762        default:
763          goto Copy;
764          break;
765      }
766      CopySmallPattern8b(src, dst, length, pattern);
767      return;
768    }
769   Copy:
770    if (dist &gt;= length) {  
771      memcpy(dst, src, length * sizeof(*dst));
772    } else {
773      int i;
774      for (i = 0; i &lt; length; ++i) dst[i] = src[i];
775    }
776  }
777  static WEBP_INLINE void CopySmallPattern32b(const uint32_t* src,
778                                              uint32_t* dst,
779                                              int length, uint64_t pattern) {
780    int i;
781    if ((uintptr_t)dst &amp; 4) {           
782      *dst++ = *src++;
783      pattern = (pattern &gt;&gt; 32) | (pattern &lt;&lt; 32);
784      --length;
785    }
786    assert(0 == ((uintptr_t)dst &amp; 7));
787    for (i = 0; i &lt; (length &gt;&gt; 1); ++i) {
788      ((uint64_t*)dst)[i] = pattern;    
789    }
790    if (length &amp; 1) {                   
791      dst[i &lt;&lt; 1] = src[i &lt;&lt; 1];
792    }
793  }
794  static WEBP_INLINE void CopyBlock32b(uint32_t* const dst,
795                                       int dist, int length) {
796    const uint32_t* const src = dst - dist;
797    if (dist &lt;= 2 &amp;&amp; length &gt;= 4 &amp;&amp; ((uintptr_t)dst &amp; 3) == 0) {
798      uint64_t pattern;
799      if (dist == 1) {
800        pattern = (uint64_t)src[0];
801        pattern |= pattern &lt;&lt; 32;
802      } else {
803        memcpy(&amp;pattern, src, sizeof(pattern));
804      }
805      CopySmallPattern32b(src, dst, length, pattern);
806    } else if (dist &gt;= length) {  
807      memcpy(dst, src, length * sizeof(*dst));
808    } else {
809      int i;
810      for (i = 0; i &lt; length; ++i) dst[i] = src[i];
811    }
812  }
813  static int DecodeAlphaData(VP8LDecoder* const dec, uint8_t* const data,
814                             int width, int height, int last_row) {
815    int ok = 1;
816    int row = dec-&gt;last_pixel_ / width;
817    int col = dec-&gt;last_pixel_ % width;
818    VP8LBitReader* const br = &amp;dec-&gt;br_;
819    VP8LMetadata* const hdr = &amp;dec-&gt;hdr_;
820    int pos = dec-&gt;last_pixel_;         
821    const int end = width * height;     
822    const int last = width * last_row;  
823    const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;
824    const int mask = hdr-&gt;huffman_mask_;
825    const HTreeGroup* htree_group =
826        (pos &lt; last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;
827    assert(pos &lt;= end);
828    assert(last_row &lt;= height);
829    assert(Is8bOptimizable(hdr));
830    while (!br-&gt;eos_ &amp;&amp; pos &lt; last) {
831      int code;
832      if ((col &amp; mask) == 0) {
833        htree_group = GetHtreeGroupForPos(hdr, col, row);
834      }
835      assert(htree_group != NULL);
836      VP8LFillBitWindow(br);
837      code = ReadSymbol(htree_group-&gt;htrees[GREEN], br);
838      if (code &lt; NUM_LITERAL_CODES) {  
839        data[pos] = code;
840        ++pos;
841        ++col;
842        if (col &gt;= width) {
843          col = 0;
844          ++row;
845          if (row &lt;= last_row &amp;&amp; (row % NUM_ARGB_CACHE_ROWS == 0)) {
846            ExtractPalettedAlphaRows(dec, row);
847          }
848        }
849      } else if (code &lt; len_code_limit) {  
850        int dist_code, dist;
851        const int length_sym = code - NUM_LITERAL_CODES;
852        const int length = GetCopyLength(length_sym, br);
853        const int dist_symbol = ReadSymbol(htree_group-&gt;htrees[DIST], br);
854        VP8LFillBitWindow(br);
855        dist_code = GetCopyDistance(dist_symbol, br);
856        dist = PlaneCodeToDistance(width, dist_code);
857        if (pos &gt;= dist &amp;&amp; end - pos &gt;= length) {
858          CopyBlock8b(data + pos, dist, length);
859        } else {
860          ok = 0;
861          goto End;
862        }
863        pos += length;
864        col += length;
865        while (col &gt;= width) {
866          col -= width;
867          ++row;
868          if (row &lt;= last_row &amp;&amp; (row % NUM_ARGB_CACHE_ROWS == 0)) {
869            ExtractPalettedAlphaRows(dec, row);
870          }
871        }
872        if (pos &lt; last &amp;&amp; (col &amp; mask)) {
873          htree_group = GetHtreeGroupForPos(hdr, col, row);
874        }
875      } else {  
876        ok = 0;
877        goto End;
878      }
879      br-&gt;eos_ = VP8LIsEndOfStream(br);
880    }
881    ExtractPalettedAlphaRows(dec, row &gt; last_row ? last_row : row);
882   End:
883    br-&gt;eos_ = VP8LIsEndOfStream(br);
884    if (!ok || (br-&gt;eos_ &amp;&amp; pos &lt; end)) {
885      ok = 0;
886      dec-&gt;status_ = br-&gt;eos_ ? VP8_STATUS_SUSPENDED
887                              : VP8_STATUS_BITSTREAM_ERROR;
888    } else {
889      dec-&gt;last_pixel_ = pos;
890    }
891    return ok;
892  }
893  static void SaveState(VP8LDecoder* const dec, int last_pixel) {
894    assert(dec-&gt;incremental_);
895    dec-&gt;saved_br_ = dec-&gt;br_;
896    dec-&gt;saved_last_pixel_ = last_pixel;
897    if (dec-&gt;hdr_.color_cache_size_ &gt; 0) {
898      VP8LColorCacheCopy(&amp;dec-&gt;hdr_.color_cache_, &amp;dec-&gt;hdr_.saved_color_cache_);
899    }
900  }
901  static void RestoreState(VP8LDecoder* const dec) {
902    assert(dec-&gt;br_.eos_);
903    dec-&gt;status_ = VP8_STATUS_SUSPENDED;
904    dec-&gt;br_ = dec-&gt;saved_br_;
905    dec-&gt;last_pixel_ = dec-&gt;saved_last_pixel_;
906    if (dec-&gt;hdr_.color_cache_size_ &gt; 0) {
907      VP8LColorCacheCopy(&amp;dec-&gt;hdr_.saved_color_cache_, &amp;dec-&gt;hdr_.color_cache_);
908    }
909  }
910  #define SYNC_EVERY_N_ROWS 8  
911  static int DecodeImageData(VP8LDecoder* const dec, uint32_t* const data,
912                             int width, int height, int last_row,
913                             ProcessRowsFunc process_func) {
914    int row = dec-&gt;last_pixel_ / width;
915    int col = dec-&gt;last_pixel_ % width;
916    VP8LBitReader* const br = &amp;dec-&gt;br_;
917    VP8LMetadata* const hdr = &amp;dec-&gt;hdr_;
918    uint32_t* src = data + dec-&gt;last_pixel_;
919    uint32_t* last_cached = src;
920    uint32_t* const src_end = data + width * height;     
921    uint32_t* const src_last = data + width * last_row;  
922    const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;
923    const int color_cache_limit = len_code_limit + hdr-&gt;color_cache_size_;
924    int next_sync_row = dec-&gt;incremental_ ? row : 1 &lt;&lt; 24;
925    VP8LColorCache* const color_cache =
926        (hdr-&gt;color_cache_size_ &gt; 0) ? &amp;hdr-&gt;color_cache_ : NULL;
927    const int mask = hdr-&gt;huffman_mask_;
928    const HTreeGroup* htree_group =
929        (src &lt; src_last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;
930    assert(dec-&gt;last_row_ &lt; last_row);
931    assert(src_last &lt;= src_end);
932    while (src &lt; src_last) {
933      int code;
934      if (row &gt;= next_sync_row) {
935        SaveState(dec, (int)(src - data));
936        next_sync_row = row + SYNC_EVERY_N_ROWS;
937      }
938      if ((col &amp; mask) == 0) {
939        htree_group = GetHtreeGroupForPos(hdr, col, row);
940      }
941      assert(htree_group != NULL);
942      if (htree_group-&gt;is_trivial_code) {
943        *src = htree_group-&gt;literal_arb;
944        goto AdvanceByOne;
945      }
946      VP8LFillBitWindow(br);
947      if (htree_group-&gt;use_packed_table) {
948        code = ReadPackedSymbols(htree_group, br, src);
949        if (VP8LIsEndOfStream(br)) break;
950        if (code == PACKED_NON_LITERAL_CODE) goto AdvanceByOne;
951      } else {
952        code = ReadSymbol(htree_group-&gt;htrees[GREEN], br);
953      }
954      if (VP8LIsEndOfStream(br)) break;
955      if (code &lt; NUM_LITERAL_CODES) {  
956        if (htree_group-&gt;is_trivial_literal) {
957          *src = htree_group-&gt;literal_arb | (code &lt;&lt; 8);
958        } else {
959          int red, blue, alpha;
960          red = ReadSymbol(htree_group-&gt;htrees[RED], br);
961          VP8LFillBitWindow(br);
962          blue = ReadSymbol(htree_group-&gt;htrees[BLUE], br);
963          alpha = ReadSymbol(htree_group-&gt;htrees[ALPHA], br);
964          if (VP8LIsEndOfStream(br)) break;
965          *src = ((uint32_t)alpha &lt;&lt; 24) | (red &lt;&lt; 16) | (code &lt;&lt; 8) | blue;
966        }
967      AdvanceByOne:
968        ++src;
969        ++col;
970        if (col &gt;= width) {
971          col = 0;
972          ++row;
973          if (process_func != NULL) {
974            if (row &lt;= last_row &amp;&amp; (row % NUM_ARGB_CACHE_ROWS == 0)) {
975              process_func(dec, row);
976            }
977          }
978          if (color_cache != NULL) {
979            while (last_cached &lt; src) {
980              VP8LColorCacheInsert(color_cache, *last_cached++);
981            }
982          }
983        }
984      } else if (code &lt; len_code_limit) {  
985        int dist_code, dist;
986        const int length_sym = code - NUM_LITERAL_CODES;
987        const int length = GetCopyLength(length_sym, br);
988        const int dist_symbol = ReadSymbol(htree_group-&gt;htrees[DIST], br);
989        VP8LFillBitWindow(br);
990        dist_code = GetCopyDistance(dist_symbol, br);
991        dist = PlaneCodeToDistance(width, dist_code);
992        if (VP8LIsEndOfStream(br)) break;
993        if (src - data &lt; (ptrdiff_t)dist || src_end - src &lt; (ptrdiff_t)length) {
994          goto Error;
995        } else {
996          CopyBlock32b(src, dist, length);
997        }
998        src += length;
999        col += length;
1000        while (col &gt;= width) {
1001          col -= width;
1002          ++row;
1003          if (process_func != NULL) {
1004            if (row &lt;= last_row &amp;&amp; (row % NUM_ARGB_CACHE_ROWS == 0)) {
1005              process_func(dec, row);
1006            }
1007          }
1008        }
1009        assert(src &lt;= src_end);
1010        if (col &amp; mask) htree_group = GetHtreeGroupForPos(hdr, col, row);
1011        if (color_cache != NULL) {
1012          while (last_cached &lt; src) {
1013            VP8LColorCacheInsert(color_cache, *last_cached++);
1014          }
1015        }
1016      } else if (code &lt; color_cache_limit) {  
1017        const int key = code - len_code_limit;
1018        assert(color_cache != NULL);
1019        while (last_cached &lt; src) {
1020          VP8LColorCacheInsert(color_cache, *last_cached++);
1021        }
1022        *src = VP8LColorCacheLookup(color_cache, key);
1023        goto AdvanceByOne;
1024      } else {  
1025        goto Error;
1026      }
1027    }
1028    br-&gt;eos_ = VP8LIsEndOfStream(br);
1029    if (dec-&gt;incremental_ &amp;&amp; br-&gt;eos_ &amp;&amp; src &lt; src_end) {
1030      RestoreState(dec);
1031    } else if (!br-&gt;eos_) {
1032      if (process_func != NULL) {
1033        process_func(dec, row &gt; last_row ? last_row : row);
1034      }
1035      dec-&gt;status_ = VP8_STATUS_OK;
1036      dec-&gt;last_pixel_ = (int)(src - data);  
1037    } else {
1038      goto Error;
1039    }
1040    return 1;
1041   Error:
1042    dec-&gt;status_ = VP8_STATUS_BITSTREAM_ERROR;
1043    return 0;
1044  }
1045  static void ClearTransform(VP8LTransform* const transform) {
1046    WebPSafeFree(transform-&gt;data_);
1047    transform-&gt;data_ = NULL;
1048  }
1049  static int ExpandColorMap(int num_colors, VP8LTransform* const transform) {
1050    int i;
1051    const int final_num_colors = 1 &lt;&lt; (8 &gt;&gt; transform-&gt;bits_);
1052    uint32_t* const new_color_map =
1053        (uint32_t*)WebPSafeMalloc((uint64_t)final_num_colors,
1054                                  sizeof(*new_color_map));
1055    if (new_color_map == NULL) {
1056      return 0;
1057    } else {
1058      uint8_t* const data = (uint8_t*)transform-&gt;data_;
1059      uint8_t* const new_data = (uint8_t*)new_color_map;
1060      new_color_map[0] = transform-&gt;data_[0];
1061      for (i = 4; i &lt; 4 * num_colors; ++i) {
1062        new_data[i] = (data[i] + new_data[i - 4]) &amp; 0xff;
1063      }
1064      for (; i &lt; 4 * final_num_colors; ++i) {
1065        new_data[i] = 0;  
1066      }
1067      WebPSafeFree(transform-&gt;data_);
1068      transform-&gt;data_ = new_color_map;
1069    }
1070    return 1;
1071  }
1072  static int ReadTransform(int* const xsize, int const* ysize,
1073                           VP8LDecoder* const dec) {
1074    int ok = 1;
1075    VP8LBitReader* const br = &amp;dec-&gt;br_;
1076    VP8LTransform* transform = &amp;dec-&gt;transforms_[dec-&gt;next_transform_];
1077    const VP8LImageTransformType type =
1078        (VP8LImageTransformType)VP8LReadBits(br, 2);
1079    if (dec-&gt;transforms_seen_ &amp; (1U &lt;&lt; type)) {
1080      return 0;  
1081    }
1082    dec-&gt;transforms_seen_ |= (1U &lt;&lt; type);
1083    transform-&gt;type_ = type;
1084    transform-&gt;xsize_ = *xsize;
1085    transform-&gt;ysize_ = *ysize;
1086    transform-&gt;data_ = NULL;
1087    ++dec-&gt;next_transform_;
1088    assert(dec-&gt;next_transform_ &lt;= NUM_TRANSFORMS);
1089    switch (type) {
1090      case PREDICTOR_TRANSFORM:
1091      case CROSS_COLOR_TRANSFORM:
1092        transform-&gt;bits_ = VP8LReadBits(br, 3) + 2;
1093        ok = DecodeImageStream(VP8LSubSampleSize(transform-&gt;xsize_,
1094                                                 transform-&gt;bits_),
1095                               VP8LSubSampleSize(transform-&gt;ysize_,
1096                                                 transform-&gt;bits_),
1097                               0, dec, &amp;transform-&gt;data_);
1098        break;
1099      case COLOR_INDEXING_TRANSFORM: {
1100         const int num_colors = VP8LReadBits(br, 8) + 1;
1101         const int bits = (num_colors &gt; 16) ? 0
1102                        : (num_colors &gt; 4) ? 1
1103                        : (num_colors &gt; 2) ? 2
1104                        : 3;
1105         *xsize = VP8LSubSampleSize(transform-&gt;xsize_, bits);
1106         transform-&gt;bits_ = bits;
1107         ok = DecodeImageStream(num_colors, 1, 0, dec, &amp;transform-&gt;data_);
1108         ok = ok &amp;&amp; ExpandColorMap(num_colors, transform);
1109        break;
1110      }
1111      case SUBTRACT_GREEN:
1112        break;
1113      default:
1114        assert(0);    
1115        break;
1116    }
1117    return ok;
1118  }
1119  static void InitMetadata(VP8LMetadata* const hdr) {
1120    assert(hdr != NULL);
1121    memset(hdr, 0, sizeof(*hdr));
1122  }
1123  static void ClearMetadata(VP8LMetadata* const hdr) {
1124    assert(hdr != NULL);
1125    WebPSafeFree(hdr-&gt;huffman_image_);
1126    WebPSafeFree(hdr-&gt;huffman_tables_);
1127    VP8LHtreeGroupsFree(hdr-&gt;htree_groups_);
1128    VP8LColorCacheClear(&amp;hdr-&gt;color_cache_);
1129    VP8LColorCacheClear(&amp;hdr-&gt;saved_color_cache_);
1130    InitMetadata(hdr);
1131  }
1132  VP8LDecoder* VP8LNew(void) {
1133    VP8LDecoder* const dec = (VP8LDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
1134    if (dec == NULL) return NULL;
1135    dec-&gt;status_ = VP8_STATUS_OK;
1136    dec-&gt;state_ = READ_DIM;
1137    VP8LDspInit();  
1138    return dec;
1139  }
1140  void VP8LClear(VP8LDecoder* const dec) {
1141    int i;
1142    if (dec == NULL) return;
1143    ClearMetadata(&amp;dec-&gt;hdr_);
1144    WebPSafeFree(dec-&gt;pixels_);
1145    dec-&gt;pixels_ = NULL;
1146    for (i = 0; i &lt; dec-&gt;next_transform_; ++i) {
1147      ClearTransform(&amp;dec-&gt;transforms_[i]);
1148    }
1149    dec-&gt;next_transform_ = 0;
1150    dec-&gt;transforms_seen_ = 0;
1151    WebPSafeFree(dec-&gt;rescaler_memory);
1152    dec-&gt;rescaler_memory = NULL;
1153    dec-&gt;output_ = NULL;   
1154  }
1155  void VP8LDelete(VP8LDecoder* const dec) {
1156    if (dec != NULL) {
1157      VP8LClear(dec);
1158      WebPSafeFree(dec);
1159    }
1160  }
1161  static void UpdateDecoder(VP8LDecoder* const dec, int width, int height) {
1162    VP8LMetadata* const hdr = &amp;dec-&gt;hdr_;
1163    const int num_bits = hdr-&gt;huffman_subsample_bits_;
1164    dec-&gt;width_ = width;
1165    dec-&gt;height_ = height;
1166    hdr-&gt;huffman_xsize_ = VP8LSubSampleSize(width, num_bits);
1167    hdr-&gt;huffman_mask_ = (num_bits == 0) ? ~0 : (1 &lt;&lt; num_bits) - 1;
1168  }
1169  static int DecodeImageStream(int xsize, int ysize,
1170                               int is_level0,
1171                               VP8LDecoder* const dec,
1172                               uint32_t** const decoded_data) {
1173    int ok = 1;
1174    int transform_xsize = xsize;
1175    int transform_ysize = ysize;
1176    VP8LBitReader* const br = &amp;dec-&gt;br_;
1177    VP8LMetadata* const hdr = &amp;dec-&gt;hdr_;
1178    uint32_t* data = NULL;
1179    int color_cache_bits = 0;
1180    if (is_level0) {
1181      while (ok &amp;&amp; VP8LReadBits(br, 1)) {
1182        ok = ReadTransform(&amp;transform_xsize, &amp;transform_ysize, dec);
1183      }
1184    }
1185    if (ok &amp;&amp; VP8LReadBits(br, 1)) {
1186      color_cache_bits = VP8LReadBits(br, 4);
1187      ok = (color_cache_bits &gt;= 1 &amp;&amp; color_cache_bits &lt;= MAX_CACHE_BITS);
1188      if (!ok) {
1189        dec-&gt;status_ = VP8_STATUS_BITSTREAM_ERROR;
1190        goto End;
1191      }
1192    }
1193    ok = ok &amp;&amp; ReadHuffmanCodes(dec, transform_xsize, transform_ysize,
1194                                color_cache_bits, is_level0);
1195    if (!ok) {
1196      dec-&gt;status_ = VP8_STATUS_BITSTREAM_ERROR;
1197      goto End;
1198    }
1199    if (color_cache_bits &gt; 0) {
1200      hdr-&gt;color_cache_size_ = 1 &lt;&lt; color_cache_bits;
1201      if (!VP8LColorCacheInit(&amp;hdr-&gt;color_cache_, color_cache_bits)) {
1202        dec-&gt;status_ = VP8_STATUS_OUT_OF_MEMORY;
1203        ok = 0;
1204        goto End;
1205      }
1206    } else {
1207      hdr-&gt;color_cache_size_ = 0;
1208    }
1209    UpdateDecoder(dec, transform_xsize, transform_ysize);
1210    if (is_level0) {   
1211      dec-&gt;state_ = READ_HDR;
1212      goto End;
1213    }
1214    {
1215      const uint64_t total_size = (uint64_t)transform_xsize * transform_ysize;
1216      data = (uint32_t*)WebPSafeMalloc(total_size, sizeof(*data));
1217      if (data == NULL) {
1218        dec-&gt;status_ = VP8_STATUS_OUT_OF_MEMORY;
1219        ok = 0;
1220        goto End;
1221      }
1222    }
1223    ok = DecodeImageData(dec, data, transform_xsize, transform_ysize,
1224                         transform_ysize, NULL);
1225    ok = ok &amp;&amp; !br-&gt;eos_;
1226   End:
1227    if (!ok) {
1228      WebPSafeFree(data);
1229      ClearMetadata(hdr);
1230    } else {
1231      if (decoded_data != NULL) {
1232        *decoded_data = data;
1233      } else {
1234        assert(data == NULL);
1235        assert(is_level0);
1236      }
1237      dec-&gt;last_pixel_ = 0;  
1238      if (!is_level0) ClearMetadata(hdr);  
1239    }
1240    return ok;
1241  }
1242  static int AllocateInternalBuffers32b(VP8LDecoder* const dec, int final_width) {
1243    const uint64_t num_pixels = (uint64_t)dec-&gt;width_ * dec-&gt;height_;
1244    const uint64_t cache_top_pixels = (uint16_t)final_width;
1245    const uint64_t cache_pixels = (uint64_t)final_width * NUM_ARGB_CACHE_ROWS;
1246    const uint64_t total_num_pixels =
1247        num_pixels + cache_top_pixels + cache_pixels;
1248    assert(dec-&gt;width_ &lt;= final_width);
1249    dec-&gt;pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint32_t));
1250    if (dec-&gt;pixels_ == NULL) {
1251      dec-&gt;argb_cache_ = NULL;    
1252      dec-&gt;status_ = VP8_STATUS_OUT_OF_MEMORY;
1253      return 0;
1254    }
1255    dec-&gt;argb_cache_ = dec-&gt;pixels_ + num_pixels + cache_top_pixels;
1256    return 1;
1257  }
1258  static int AllocateInternalBuffers8b(VP8LDecoder* const dec) {
1259    const uint64_t total_num_pixels = (uint64_t)dec-&gt;width_ * dec-&gt;height_;
1260    dec-&gt;argb_cache_ = NULL;    
1261    dec-&gt;pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint8_t));
1262    if (dec-&gt;pixels_ == NULL) {
1263      dec-&gt;status_ = VP8_STATUS_OUT_OF_MEMORY;
1264      return 0;
1265    }
1266    return 1;
1267  }
1268  static void ExtractAlphaRows(VP8LDecoder* const dec, int last_row) {
1269    int cur_row = dec-&gt;last_row_;
1270    int num_rows = last_row - cur_row;
1271    const uint32_t* in = dec-&gt;pixels_ + dec-&gt;width_ * cur_row;
1272    assert(last_row &lt;= dec-&gt;io_-&gt;crop_bottom);
1273    while (num_rows &gt; 0) {
1274      const int num_rows_to_process =
1275          (num_rows &gt; NUM_ARGB_CACHE_ROWS) ? NUM_ARGB_CACHE_ROWS : num_rows;
1276      ALPHDecoder* const alph_dec = (ALPHDecoder*)dec-&gt;io_-&gt;opaque;
1277      uint8_t* const output = alph_dec-&gt;output_;
1278      const int width = dec-&gt;io_-&gt;width;      
1279      const int cache_pixs = width * num_rows_to_process;
1280      uint8_t* const dst = output + width * cur_row;
1281      const uint32_t* const src = dec-&gt;argb_cache_;
1282      ApplyInverseTransforms(dec, cur_row, num_rows_to_process, in);
1283      WebPExtractGreen(src, dst, cache_pixs);
1284      AlphaApplyFilter(alph_dec,
1285                       cur_row, cur_row + num_rows_to_process, dst, width);
1286      num_rows -= num_rows_to_process;
1287      in += num_rows_to_process * dec-&gt;width_;
1288      cur_row += num_rows_to_process;
1289    }
1290    assert(cur_row == last_row);
1291    dec-&gt;last_row_ = dec-&gt;last_out_row_ = last_row;
1292  }
1293  int VP8LDecodeAlphaHeader(ALPHDecoder* const alph_dec,
1294                            const uint8_t* const data, size_t data_size) {
1295    int ok = 0;
1296    VP8LDecoder* dec = VP8LNew();
1297    if (dec == NULL) return 0;
1298    assert(alph_dec != NULL);
1299    dec-&gt;width_ = alph_dec-&gt;width_;
1300    dec-&gt;height_ = alph_dec-&gt;height_;
1301    dec-&gt;io_ = &amp;alph_dec-&gt;io_;
1302    dec-&gt;io_-&gt;opaque = alph_dec;
1303    dec-&gt;io_-&gt;width = alph_dec-&gt;width_;
1304    dec-&gt;io_-&gt;height = alph_dec-&gt;height_;
1305    dec-&gt;status_ = VP8_STATUS_OK;
1306    VP8LInitBitReader(&amp;dec-&gt;br_, data, data_size);
1307    if (!DecodeImageStream(alph_dec-&gt;width_, alph_dec-&gt;height_, 1, dec, NULL)) {
1308      goto Err;
1309    }
1310    if (dec-&gt;next_transform_ == 1 &amp;&amp;
1311        dec-&gt;transforms_[0].type_ == COLOR_INDEXING_TRANSFORM &amp;&amp;
1312        Is8bOptimizable(&amp;dec-&gt;hdr_)) {
1313      alph_dec-&gt;use_8b_decode_ = 1;
1314      ok = AllocateInternalBuffers8b(dec);
1315    } else {
1316      alph_dec-&gt;use_8b_decode_ = 0;
1317      ok = AllocateInternalBuffers32b(dec, alph_dec-&gt;width_);
1318    }
1319    if (!ok) goto Err;
1320    alph_dec-&gt;vp8l_dec_ = dec;
1321    return 1;
1322   Err:
1323    VP8LDelete(dec);
1324    return 0;
1325  }
1326  int VP8LDecodeAlphaImageStream(ALPHDecoder* const alph_dec, int last_row) {
1327    VP8LDecoder* const dec = alph_dec-&gt;vp8l_dec_;
1328    assert(dec != NULL);
1329    assert(last_row &lt;= dec-&gt;height_);
1330    if (dec-&gt;last_row_ &gt;= last_row) {
1331      return 1;  
1332    }
1333    if (!alph_dec-&gt;use_8b_decode_) WebPInitAlphaProcessing();
1334    return alph_dec-&gt;use_8b_decode_ ?
1335        DecodeAlphaData(dec, (uint8_t*)dec-&gt;pixels_, dec-&gt;width_, dec-&gt;height_,
1336                        last_row) :
1337        DecodeImageData(dec, dec-&gt;pixels_, dec-&gt;width_, dec-&gt;height_,
1338                        last_row, ExtractAlphaRows);
1339  }
1340  int VP8LDecodeHeader(VP8LDecoder* const dec, VP8Io* const io) {
1341    int width, height, has_alpha;
1342    if (dec == NULL) return 0;
1343    if (io == NULL) {
1344      dec-&gt;status_ = VP8_STATUS_INVALID_PARAM;
1345      return 0;
1346    }
1347    dec-&gt;io_ = io;
1348    dec-&gt;status_ = VP8_STATUS_OK;
1349    VP8LInitBitReader(&amp;dec-&gt;br_, io-&gt;data, io-&gt;data_size);
1350    if (!ReadImageInfo(&amp;dec-&gt;br_, &amp;width, &amp;height, &amp;has_alpha)) {
1351      dec-&gt;status_ = VP8_STATUS_BITSTREAM_ERROR;
1352      goto Error;
1353    }
1354    dec-&gt;state_ = READ_DIM;
1355    io-&gt;width = width;
1356    io-&gt;height = height;
1357    if (!DecodeImageStream(width, height, 1, dec, NULL)) goto Error;
1358    return 1;
1359   Error:
1360    VP8LClear(dec);
1361    assert(dec-&gt;status_ != VP8_STATUS_OK);
1362    return 0;
1363  }
1364  int VP8LDecodeImage(VP8LDecoder* const dec) {
1365    VP8Io* io = NULL;
1366    WebPDecParams* params = NULL;
1367    if (dec == NULL) return 0;
1368    assert(dec-&gt;hdr_.huffman_tables_ != NULL);
1369    assert(dec-&gt;hdr_.htree_groups_ != NULL);
1370    assert(dec-&gt;hdr_.num_htree_groups_ &gt; 0);
1371    io = dec-&gt;io_;
1372    assert(io != NULL);
1373    params = (WebPDecParams*)io-&gt;opaque;
1374    assert(params != NULL);
1375    if (dec-&gt;state_ != READ_DATA) {
1376      dec-&gt;output_ = params-&gt;output;
1377      assert(dec-&gt;output_ != NULL);
1378      if (!WebPIoInitFromOptions(params-&gt;options, io, MODE_BGRA)) {
1379        dec-&gt;status_ = VP8_STATUS_INVALID_PARAM;
1380        goto Err;
1381      }
1382      if (!AllocateInternalBuffers32b(dec, io-&gt;width)) goto Err;
1383  #if !defined(WEBP_REDUCE_SIZE)
1384      if (io-&gt;use_scaling &amp;&amp; !AllocateAndInitRescaler(dec, io)) goto Err;
1385  #else
1386      if (io-&gt;use_scaling) {
1387        dec-&gt;status_ = VP8_STATUS_INVALID_PARAM;
1388        goto Err;
1389      }
1390  #endif
1391      if (io-&gt;use_scaling || WebPIsPremultipliedMode(dec-&gt;output_-&gt;colorspace)) {
1392        WebPInitAlphaProcessing();
1393      }
1394      if (!WebPIsRGBMode(dec-&gt;output_-&gt;colorspace)) {
1395        WebPInitConvertARGBToYUV();
1396        if (dec-&gt;output_-&gt;u.YUVA.a != NULL) WebPInitAlphaProcessing();
1397      }
1398      if (dec-&gt;incremental_) {
1399        if (dec-&gt;hdr_.color_cache_size_ &gt; 0 &amp;&amp;
1400            dec-&gt;hdr_.saved_color_cache_.colors_ == NULL) {
1401          if (!VP8LColorCacheInit(&amp;dec-&gt;hdr_.saved_color_cache_,
1402                                  dec-&gt;hdr_.color_cache_.hash_bits_)) {
1403            dec-&gt;status_ = VP8_STATUS_OUT_OF_MEMORY;
1404            goto Err;
1405          }
1406        }
1407      }
1408      dec-&gt;state_ = READ_DATA;
1409    }
1410    if (!DecodeImageData(dec, dec-&gt;pixels_, dec-&gt;width_, dec-&gt;height_,
1411                         io-&gt;crop_bottom, ProcessRows)) {
1412      goto Err;
1413    }
1414    params-&gt;last_y = dec-&gt;last_out_row_;
1415    return 1;
1416   Err:
1417    VP8LClear(dec);
1418    assert(dec-&gt;status_ != VP8_STATUS_OK);
1419    return 0;
1420  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</h3>
            <pre><code>1  #include &lt;assert.h&gt;
2  #include &lt;stdlib.h&gt;
3  #include &lt;string.h&gt;
4  #include &lt;math.h&gt;
5  #include &quot;src/enc/cost_enc.h&quot;
6  #include &quot;src/enc/vp8i_enc.h&quot;
7  #include &quot;src/enc/vp8li_enc.h&quot;
8  #include &quot;src/utils/utils.h&quot;
9  #ifdef PRINT_MEMORY_INFO
10  #include &lt;stdio.h&gt;
11  #endif
12  int WebPGetEncoderVersion(void) {
13    return (ENC_MAJ_VERSION &lt;&lt; 16) | (ENC_MIN_VERSION &lt;&lt; 8) | ENC_REV_VERSION;
14  }
15  static void ResetSegmentHeader(VP8Encoder* const enc) {
16    VP8EncSegmentHeader* const hdr = &amp;enc-&gt;segment_hdr_;
17    hdr-&gt;num_segments_ = enc-&gt;config_-&gt;segments;
18    hdr-&gt;update_map_  = (hdr-&gt;num_segments_ &gt; 1);
19    hdr-&gt;size_ = 0;
20  }
21  static void ResetFilterHeader(VP8Encoder* const enc) {
22    VP8EncFilterHeader* const hdr = &amp;enc-&gt;filter_hdr_;
23    hdr-&gt;simple_ = 1;
24    hdr-&gt;level_ = 0;
25    hdr-&gt;sharpness_ = 0;
26    hdr-&gt;i4x4_lf_delta_ = 0;
27  }
28  static void ResetBoundaryPredictions(VP8Encoder* const enc) {
29    int i;
30    uint8_t* const top = enc-&gt;preds_ - enc-&gt;preds_w_;
31    uint8_t* const left = enc-&gt;preds_ - 1;
32    for (i = -1; i &lt; 4 * enc-&gt;mb_w_; ++i) {
33      top[i] = B_DC_PRED;
34    }
35    for (i = 0; i &lt; 4 * enc-&gt;mb_h_; ++i) {
36      left[i * enc-&gt;preds_w_] = B_DC_PRED;
37    }
38    enc-&gt;nz_[-1] = 0;   
39  }
40  static void MapConfigToTools(VP8Encoder* const enc) {
41    const WebPConfig* const config = enc-&gt;config_;
42    const int method = config-&gt;method;
43    const int limit = 100 - config-&gt;partition_limit;
44    enc-&gt;method_ = method;
45    enc-&gt;rd_opt_level_ = (method &gt;= 6) ? RD_OPT_TRELLIS_ALL
46                       : (method &gt;= 5) ? RD_OPT_TRELLIS
47                       : (method &gt;= 3) ? RD_OPT_BASIC
48                       : RD_OPT_NONE;
49    enc-&gt;max_i4_header_bits_ =
50        256 * 16 * 16 *                 
51        (limit * limit) / (100 * 100);  
52    enc-&gt;mb_header_limit_ =
53        (score_t)256 * 510 * 8 * 1024 / (enc-&gt;mb_w_ * enc-&gt;mb_h_);
54    enc-&gt;thread_level_ = config-&gt;thread_level;
55    enc-&gt;do_search_ = (config-&gt;target_size &gt; 0 || config-&gt;target_PSNR &gt; 0);
56    if (!config-&gt;low_memory) {
57  #if !defined(DISABLE_TOKEN_BUFFER)
58      enc-&gt;use_tokens_ = (enc-&gt;rd_opt_level_ &gt;= RD_OPT_BASIC);  
59  #endif
60      if (enc-&gt;use_tokens_) {
61        enc-&gt;num_parts_ = 1;   
62      }
63    }
64  }
65  static VP8Encoder* InitVP8Encoder(const WebPConfig* const config,
66                                    WebPPicture* const picture) {
67    VP8Encoder* enc;
68    const int use_filter =
69        (config-&gt;filter_strength &gt; 0) || (config-&gt;autofilter &gt; 0);
70    const int mb_w = (picture-&gt;width + 15) &gt;&gt; 4;
71    const int mb_h = (picture-&gt;height + 15) &gt;&gt; 4;
72    const int preds_w = 4 * mb_w + 1;
73    const int preds_h = 4 * mb_h + 1;
74    const size_t preds_size = preds_w * preds_h * sizeof(*enc-&gt;preds_);
75    const int top_stride = mb_w * 16;
76    const size_t nz_size = (mb_w + 1) * sizeof(*enc-&gt;nz_) + WEBP_ALIGN_CST;
77    const size_t info_size = mb_w * mb_h * sizeof(*enc-&gt;mb_info_);
78    const size_t samples_size =
79        2 * top_stride * sizeof(*enc-&gt;y_top_)  
80        + WEBP_ALIGN_CST;                      
81    const size_t lf_stats_size =
82        config-&gt;autofilter ? sizeof(*enc-&gt;lf_stats_) + WEBP_ALIGN_CST : 0;
83    const size_t top_derr_size =
84        (config-&gt;quality &lt;= ERROR_DIFFUSION_QUALITY || config-&gt;pass &gt; 1) ?
85            mb_w * sizeof(*enc-&gt;top_derr_) : 0;
86    uint8_t* mem;
87    const uint64_t size = (uint64_t)sizeof(*enc)   
88                        + WEBP_ALIGN_CST           
89                        + info_size                
90                        + preds_size               
91                        + samples_size             
92                        + top_derr_size            
93                        + nz_size                  
94                        + lf_stats_size;           
95  #ifdef PRINT_MEMORY_INFO
96    printf(&quot;===================================\n&quot;);
97    printf(&quot;Memory used:\n&quot;
98           &quot;             encoder: %ld\n&quot;
99           &quot;                info: %ld\n&quot;
100           &quot;               preds: %ld\n&quot;
101           &quot;         top samples: %ld\n&quot;
102           &quot;       top diffusion: %ld\n&quot;
103           &quot;            non-zero: %ld\n&quot;
104           &quot;            lf-stats: %ld\n&quot;
105           &quot;               total: %ld\n&quot;,
106           sizeof(*enc) + WEBP_ALIGN_CST, info_size,
107           preds_size, samples_size, top_derr_size, nz_size, lf_stats_size, size);
108    printf(&quot;Transient object sizes:\n&quot;
109           &quot;      VP8EncIterator: %ld\n&quot;
110           &quot;        VP8ModeScore: %ld\n&quot;
111           &quot;      VP8SegmentInfo: %ld\n&quot;
112           &quot;         VP8EncProba: %ld\n&quot;
113           &quot;             LFStats: %ld\n&quot;,
114           sizeof(VP8EncIterator), sizeof(VP8ModeScore),
115           sizeof(VP8SegmentInfo), sizeof(VP8EncProba),
116           sizeof(LFStats));
117    printf(&quot;Picture size (yuv): %ld\n&quot;,
118           mb_w * mb_h * 384 * sizeof(uint8_t));
119    printf(&quot;===================================\n&quot;);
120  #endif
121    mem = (uint8_t*)WebPSafeMalloc(size, sizeof(*mem));
122    if (mem == NULL) {
123      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
124      return NULL;
125    }
126    enc = (VP8Encoder*)mem;
127    mem = (uint8_t*)WEBP_ALIGN(mem + sizeof(*enc));
128    memset(enc, 0, sizeof(*enc));
129    enc-&gt;num_parts_ = 1 &lt;&lt; config-&gt;partitions;
130    enc-&gt;mb_w_ = mb_w;
131    enc-&gt;mb_h_ = mb_h;
132    enc-&gt;preds_w_ = preds_w;
133    enc-&gt;mb_info_ = (VP8MBInfo*)mem;
134    mem += info_size;
135    enc-&gt;preds_ = mem + 1 + enc-&gt;preds_w_;
136    mem += preds_size;
137    enc-&gt;nz_ = 1 + (uint32_t*)WEBP_ALIGN(mem);
138    mem += nz_size;
139    enc-&gt;lf_stats_ = lf_stats_size ? (LFStats*)WEBP_ALIGN(mem) : NULL;
140    mem += lf_stats_size;
141    mem = (uint8_t*)WEBP_ALIGN(mem);
142    enc-&gt;y_top_ = mem;
143    enc-&gt;uv_top_ = enc-&gt;y_top_ + top_stride;
144    mem += 2 * top_stride;
145    enc-&gt;top_derr_ = top_derr_size ? (DError*)mem : NULL;
146    mem += top_derr_size;
147    assert(mem &lt;= (uint8_t*)enc + size);
148    enc-&gt;config_ = config;
149    enc-&gt;profile_ = use_filter ? ((config-&gt;filter_type == 1) ? 0 : 1) : 2;
150    enc-&gt;pic_ = picture;
151    enc-&gt;percent_ = 0;
152    MapConfigToTools(enc);
153    VP8EncDspInit();
154    VP8DefaultProbas(enc);
155    ResetSegmentHeader(enc);
156    ResetFilterHeader(enc);
157    ResetBoundaryPredictions(enc);
158    VP8EncDspCostInit();
159    VP8EncInitAlpha(enc);
160    {
161      const float scale = 1.f + config-&gt;quality * 5.f / 100.f;  
162      VP8TBufferInit(&amp;enc-&gt;tokens_, (int)(mb_w * mb_h * 4 * scale));
163    }
164    return enc;
165  }
166  static int DeleteVP8Encoder(VP8Encoder* enc) {
167    int ok = 1;
168    if (enc != NULL) {
169      ok = VP8EncDeleteAlpha(enc);
170      VP8TBufferClear(&amp;enc-&gt;tokens_);
<span onclick='openModal()' class='match'>171      WebPSafeFree(enc);
172    }
173    return ok;
174  }
175  #if !defined(WEBP_DISABLE_STATS)
176  static double GetPSNR(uint64_t err, uint64_t size) {
</span>177    return (err &gt; 0 &amp;&amp; size &gt; 0) ? 10. * log10(255. * 255. * size / err) : 99.;
178  }
179  static void FinalizePSNR(const VP8Encoder* const enc) {
180    WebPAuxStats* stats = enc-&gt;pic_-&gt;stats;
181    const uint64_t size = enc-&gt;sse_count_;
182    const uint64_t* const sse = enc-&gt;sse_;
183    stats-&gt;PSNR[0] = (float)GetPSNR(sse[0], size);
184    stats-&gt;PSNR[1] = (float)GetPSNR(sse[1], size / 4);
185    stats-&gt;PSNR[2] = (float)GetPSNR(sse[2], size / 4);
186    stats-&gt;PSNR[3] = (float)GetPSNR(sse[0] + sse[1] + sse[2], size * 3 / 2);
187    stats-&gt;PSNR[4] = (float)GetPSNR(sse[3], size);
188  }
189  #endif  
190  static void StoreStats(VP8Encoder* const enc) {
191  #if !defined(WEBP_DISABLE_STATS)
192    WebPAuxStats* const stats = enc-&gt;pic_-&gt;stats;
193    if (stats != NULL) {
194      int i, s;
195      for (i = 0; i &lt; NUM_MB_SEGMENTS; ++i) {
196        stats-&gt;segment_level[i] = enc-&gt;dqm_[i].fstrength_;
197        stats-&gt;segment_quant[i] = enc-&gt;dqm_[i].quant_;
198        for (s = 0; s &lt;= 2; ++s) {
199          stats-&gt;residual_bytes[s][i] = enc-&gt;residual_bytes_[s][i];
200        }
201      }
202      FinalizePSNR(enc);
203      stats-&gt;coded_size = enc-&gt;coded_size_;
204      for (i = 0; i &lt; 3; ++i) {
205        stats-&gt;block_count[i] = enc-&gt;block_count_[i];
206      }
207    }
208  #else  
209    WebPReportProgress(enc-&gt;pic_, 100, &amp;enc-&gt;percent_);  
210  #endif  
211  }
212  int WebPEncodingSetError(const WebPPicture* const pic,
213                           WebPEncodingError error) {
214    assert((int)error &lt; VP8_ENC_ERROR_LAST);
215    assert((int)error &gt;= VP8_ENC_OK);
216    ((WebPPicture*)pic)-&gt;error_code = error;
217    return 0;
218  }
219  int WebPReportProgress(const WebPPicture* const pic,
220                         int percent, int* const percent_store) {
221    if (percent_store != NULL &amp;&amp; percent != *percent_store) {
222      *percent_store = percent;
223      if (pic-&gt;progress_hook &amp;&amp; !pic-&gt;progress_hook(percent, pic)) {
224        WebPEncodingSetError(pic, VP8_ENC_ERROR_USER_ABORT);
225        return 0;
226      }
227    }
228    return 1;  
229  }
230  int WebPEncode(const WebPConfig* config, WebPPicture* pic) {
231    int ok = 0;
232    if (pic == NULL) return 0;
233    WebPEncodingSetError(pic, VP8_ENC_OK);  
234    if (config == NULL) {  
235      return WebPEncodingSetError(pic, VP8_ENC_ERROR_NULL_PARAMETER);
236    }
237    if (!WebPValidateConfig(config)) {
238      return WebPEncodingSetError(pic, VP8_ENC_ERROR_INVALID_CONFIGURATION);
239    }
240    if (pic-&gt;width &lt;= 0 || pic-&gt;height &lt;= 0) {
241      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
242    }
243    if (pic-&gt;width &gt; WEBP_MAX_DIMENSION || pic-&gt;height &gt; WEBP_MAX_DIMENSION) {
244      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
245    }
246    if (pic-&gt;stats != NULL) memset(pic-&gt;stats, 0, sizeof(*pic-&gt;stats));
247    if (!config-&gt;lossless) {
248      VP8Encoder* enc = NULL;
249      if (pic-&gt;use_argb || pic-&gt;y == NULL || pic-&gt;u == NULL || pic-&gt;v == NULL) {
250        if (config-&gt;use_sharp_yuv || (config-&gt;preprocessing &amp; 4)) {
251          if (!WebPPictureSharpARGBToYUVA(pic)) {
252            return 0;
253          }
254        } else {
255          float dithering = 0.f;
256          if (config-&gt;preprocessing &amp; 2) {
257            const float x = config-&gt;quality / 100.f;
258            const float x2 = x * x;
259            dithering = 1.0f + (0.5f - 1.0f) * x2 * x2;
260          }
261          if (!WebPPictureARGBToYUVADithered(pic, WEBP_YUV420, dithering)) {
262            return 0;
263          }
264        }
265      }
266      if (!config-&gt;exact) {
267        WebPCleanupTransparentArea(pic);
268      }
269      enc = InitVP8Encoder(config, pic);
270      if (enc == NULL) return 0;  
271      ok = VP8EncAnalyze(enc);
272      ok = ok &amp;&amp; VP8EncStartAlpha(enc);   
273      if (!enc-&gt;use_tokens_) {
274        ok = ok &amp;&amp; VP8EncLoop(enc);
275      } else {
276        ok = ok &amp;&amp; VP8EncTokenLoop(enc);
277      }
278      ok = ok &amp;&amp; VP8EncFinishAlpha(enc);
279      ok = ok &amp;&amp; VP8EncWrite(enc);
280      StoreStats(enc);
281      if (!ok) {
282        VP8EncFreeBitWriters(enc);
283      }
284      ok &amp;= DeleteVP8Encoder(enc);  
285    } else {
286      if (pic-&gt;argb == NULL &amp;&amp; !WebPPictureYUVAToARGB(pic)) {
287        return 0;
288      }
289      if (!config-&gt;exact) {
290        WebPCleanupTransparentAreaLossless(pic);
291      }
292      ok = VP8LEncodeImage(config, pic);  
293    }
294    return ok;
295  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_dec.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>426      VP8LHtreeGroupsFree(htree_groups);
427    }
428    return ok;
429  }
430  #if !defined(WEBP_REDUCE_SIZE)
431  static int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {
</pre></code></div>
                <div class="column column_space"><pre><code>171      WebPSafeFree(enc);
172    }
173    return ok;
174  }
175  #if !defined(WEBP_DISABLE_STATS)
176  static double GetPSNR(uint64_t err, uint64_t size) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    