
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.215456674473068%, Tokens: 9</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ocb3_add_aad.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_OCB3_MODE
3  static int s_ocb3_int_aad_add_block(ocb3_state *ocb, const unsigned char *aad_block)
4  {
5     unsigned char tmp[MAXBLOCKSIZE];
6     int err;
7     ocb3_int_xor_blocks(ocb->aOffset_current, ocb->aOffset_current, ocb->L_[ocb3_int_ntz(ocb->ablock_index)], ocb->block_len);
8     ocb3_int_xor_blocks(tmp, aad_block, ocb->aOffset_current, ocb->block_len);
9     if ((err = cipher_descriptor[ocb->cipher].ecb_encrypt(tmp, tmp, &ocb->key)) != CRYPT_OK) {
10       return err;
11     }
12     ocb3_int_xor_blocks(ocb->aSum_current, ocb->aSum_current, tmp, ocb->block_len);
<span onclick='openModal()' class='match'>13     ocb->ablock_index++;
14     return CRYPT_OK;
15  }
16  int ocb3_add_aad(ocb3_state *ocb, const unsigned char *aad, unsigned long aadlen)
</span>17  {
18     int err, x, full_blocks, full_blocks_len, last_block_len;
19     unsigned char *data;
20     unsigned long datalen, l;
21     LTC_ARGCHK(ocb != NULL);
22     if (aadlen == 0) return CRYPT_OK;
23     LTC_ARGCHK(aad != NULL);
24     if (ocb->adata_buffer_bytes > 0) {
25       l = ocb->block_len - ocb->adata_buffer_bytes;
26       if (l > aadlen) l = aadlen;
27       XMEMCPY(ocb->adata_buffer+ocb->adata_buffer_bytes, aad, l);
28       ocb->adata_buffer_bytes += l;
29       if (ocb->adata_buffer_bytes == ocb->block_len) {
30         if ((err = s_ocb3_int_aad_add_block(ocb, ocb->adata_buffer)) != CRYPT_OK) {
31           return err;
32         }
33         ocb->adata_buffer_bytes = 0;
34       }
35       data = (unsigned char *)aad + l;
36       datalen = aadlen - l;
37     }
38     else {
39       data = (unsigned char *)aad;
40       datalen = aadlen;
41     }
42     if (datalen == 0) return CRYPT_OK;
43     full_blocks = datalen/ocb->block_len;
44     full_blocks_len = full_blocks * ocb->block_len;
45     last_block_len = datalen - full_blocks_len;
46     for (x=0; x<full_blocks; x++) {
47       if ((err = s_ocb3_int_aad_add_block(ocb, data+x*ocb->block_len)) != CRYPT_OK) {
48         return err;
49       }
50     }
51     if (last_block_len>0) {
52       XMEMCPY(ocb->adata_buffer, data+full_blocks_len, last_block_len);
53       ocb->adata_buffer_bytes = last_block_len;
54     }
55     return CRYPT_OK;
56  }
57  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rc5.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RC5
3  const struct ltc_cipher_descriptor rc5_desc =
4  {
5      "rc5",
6      2,
7      8, 128, 8, 12,
8      &rc5_setup,
9      &rc5_ecb_encrypt,
10      &rc5_ecb_decrypt,
11      &rc5_test,
12      &rc5_done,
13      &rc5_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  static const ulong32 stab[50] = {
17  0xb7e15163UL, 0x5618cb1cUL, 0xf45044d5UL, 0x9287be8eUL, 0x30bf3847UL, 0xcef6b200UL, 0x6d2e2bb9UL, 0x0b65a572UL,
18  0xa99d1f2bUL, 0x47d498e4UL, 0xe60c129dUL, 0x84438c56UL, 0x227b060fUL, 0xc0b27fc8UL, 0x5ee9f981UL, 0xfd21733aUL,
19  0x9b58ecf3UL, 0x399066acUL, 0xd7c7e065UL, 0x75ff5a1eUL, 0x1436d3d7UL, 0xb26e4d90UL, 0x50a5c749UL, 0xeedd4102UL,
20  0x8d14babbUL, 0x2b4c3474UL, 0xc983ae2dUL, 0x67bb27e6UL, 0x05f2a19fUL, 0xa42a1b58UL, 0x42619511UL, 0xe0990ecaUL,
21  0x7ed08883UL, 0x1d08023cUL, 0xbb3f7bf5UL, 0x5976f5aeUL, 0xf7ae6f67UL, 0x95e5e920UL, 0x341d62d9UL, 0xd254dc92UL,
22  0x708c564bUL, 0x0ec3d004UL, 0xacfb49bdUL, 0x4b32c376UL, 0xe96a3d2fUL, 0x87a1b6e8UL, 0x25d930a1UL, 0xc410aa5aUL,
23  0x62482413UL, 0x007f9dccUL
24  };
25  #ifdef LTC_CLEAN_STACK
26  static int s_rc5_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
27  #else
28  int rc5_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
29  #endif
30  {
31      ulong32 L[64], *S, A, B, i, j, v, s, t, l;
32      LTC_ARGCHK(skey != NULL);
33      LTC_ARGCHK(key  != NULL);
34      if (num_rounds == 0) {
35         num_rounds = rc5_desc.default_rounds;
36      }
37      if (num_rounds < 12 || num_rounds > 24) {
38         return CRYPT_INVALID_ROUNDS;
39      }
40      if (keylen < 8 || keylen > 128) {
41         return CRYPT_INVALID_KEYSIZE;
42      }
43      skey->rc5.rounds = num_rounds;
44      S = skey->rc5.K;
45      for (A = i = j = 0; i < (ulong32)keylen; ) {
46          A = (A << 8) | ((ulong32)(key[i++] & 255));
47          if ((i & 3) == 0) {
48             L[j++] = BSWAP(A);
49             A = 0;
50          }
51      }
52      if ((keylen & 3) != 0) {
53         A <<= (ulong32)((8 * (4 - (keylen&3))));
54         L[j++] = BSWAP(A);
55      }
56      t = (ulong32)(2 * (num_rounds + 1));
57      XMEMCPY(S, stab, t * sizeof(*S));
58      s = 3 * MAX(t, j);
59      l = j;
60      for (A = B = i = j = v = 0; v < s; v++) {
61          A = S[i] = ROLc(S[i] + A + B, 3);
62          B = L[j] = ROL(L[j] + A + B, (A+B));
63          if (++i == t) { i = 0; }
64          if (++j == l) { j = 0; }
65      }
66      return CRYPT_OK;
67  }
68  #ifdef LTC_CLEAN_STACK
69  int rc5_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
70  {
71     int x;
72     x = s_rc5_setup(key, keylen, num_rounds, skey);
73     burn_stack(sizeof(ulong32) * 122 + sizeof(int));
74     return x;
75  }
76  #endif
77  #ifdef LTC_CLEAN_STACK
78  static int s_rc5_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
79  #else
80  int rc5_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
81  #endif
82  {
83     ulong32 A, B;
84     const ulong32 *K;
85     int r;
86     LTC_ARGCHK(skey != NULL);
87     LTC_ARGCHK(pt   != NULL);
88     LTC_ARGCHK(ct   != NULL);
89     if (skey->rc5.rounds < 12 || skey->rc5.rounds > 24) {
90        return CRYPT_INVALID_ROUNDS;
91     }
92     LOAD32L(A, &pt[0]);
93     LOAD32L(B, &pt[4]);
94     A += skey->rc5.K[0];
95     B += skey->rc5.K[1];
96     K  = skey->rc5.K + 2;
97     if ((skey->rc5.rounds & 1) == 0) {
98        for (r = 0; r < skey->rc5.rounds; r += 2) {
99            A = ROL(A ^ B, B) + K[0];
100            B = ROL(B ^ A, A) + K[1];
101            A = ROL(A ^ B, B) + K[2];
102            B = ROL(B ^ A, A) + K[3];
103            K += 4;
104        }
105     } else {
106        for (r = 0; r < skey->rc5.rounds; r++) {
107            A = ROL(A ^ B, B) + K[0];
108            B = ROL(B ^ A, A) + K[1];
109            K += 2;
110        }
111     }
112     STORE32L(A, &ct[0]);
113     STORE32L(B, &ct[4]);
114     return CRYPT_OK;
115  }
116  #ifdef LTC_CLEAN_STACK
117  int rc5_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
118  {
119     int err = s_rc5_ecb_encrypt(pt, ct, skey);
120     burn_stack(sizeof(ulong32) * 2 + sizeof(int));
121     return err;
122  }
123  #endif
124  #ifdef LTC_CLEAN_STACK
125  static int s_rc5_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
126  #else
127  int rc5_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
128  #endif
129  {
130     ulong32 A, B;
131     const ulong32 *K;
132     int r;
133     LTC_ARGCHK(skey != NULL);
134     LTC_ARGCHK(pt   != NULL);
135     LTC_ARGCHK(ct   != NULL);
136     if (skey->rc5.rounds < 12 || skey->rc5.rounds > 24) {
137        return CRYPT_INVALID_ROUNDS;
138     }
139     LOAD32L(A, &ct[0]);
140     LOAD32L(B, &ct[4]);
141     K = skey->rc5.K + (skey->rc5.rounds << 1);
142     if ((skey->rc5.rounds & 1) == 0) {
143         K -= 2;
144         for (r = skey->rc5.rounds - 1; r >= 0; r -= 2) {
145            B = ROR(B - K[3], A) ^ A;
146            A = ROR(A - K[2], B) ^ B;
147            B = ROR(B - K[1], A) ^ A;
148            A = ROR(A - K[0], B) ^ B;
149            K -= 4;
150          }
151     } else {
152        for (r = skey->rc5.rounds - 1; r >= 0; r--) {
153            B = ROR(B - K[1], A) ^ A;
154            A = ROR(A - K[0], B) ^ B;
155            K -= 2;
156        }
157     }
158     A -= skey->rc5.K[0];
<span onclick='openModal()' class='match'>159     B -= skey->rc5.K[1];
160     STORE32L(A, &pt[0]);
161     STORE32L(B, &pt[4]);
162     return CRYPT_OK;
163  }
164  #ifdef LTC_CLEAN_STACK
165  int rc5_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
</span>166  {
167     int err = s_rc5_ecb_decrypt(ct, pt, skey);
168     burn_stack(sizeof(ulong32) * 2 + sizeof(int));
169     return err;
170  }
171  #endif
172  int rc5_test(void)
173  {
174   #ifndef LTC_TEST
175      return CRYPT_NOP;
176   #else
177     static const struct {
178         unsigned char key[16], pt[8], ct[8];
179     } tests[] = {
180     {
181         { 0x91, 0x5f, 0x46, 0x19, 0xbe, 0x41, 0xb2, 0x51,
182           0x63, 0x55, 0xa5, 0x01, 0x10, 0xa9, 0xce, 0x91 },
183         { 0x21, 0xa5, 0xdb, 0xee, 0x15, 0x4b, 0x8f, 0x6d },
184         { 0xf7, 0xc0, 0x13, 0xac, 0x5b, 0x2b, 0x89, 0x52 }
185     },
186     {
187         { 0x78, 0x33, 0x48, 0xe7, 0x5a, 0xeb, 0x0f, 0x2f,
188           0xd7, 0xb1, 0x69, 0xbb, 0x8d, 0xc1, 0x67, 0x87 },
189         { 0xF7, 0xC0, 0x13, 0xAC, 0x5B, 0x2B, 0x89, 0x52 },
190         { 0x2F, 0x42, 0xB3, 0xB7, 0x03, 0x69, 0xFC, 0x92 }
191     },
192     {
193         { 0xDC, 0x49, 0xdb, 0x13, 0x75, 0xa5, 0x58, 0x4f,
194           0x64, 0x85, 0xb4, 0x13, 0xb5, 0xf1, 0x2b, 0xaf },
195         { 0x2F, 0x42, 0xB3, 0xB7, 0x03, 0x69, 0xFC, 0x92 },
196         { 0x65, 0xc1, 0x78, 0xb2, 0x84, 0xd1, 0x97, 0xcc }
197     }
198     };
199     unsigned char tmp[2][8];
200     int x, y, err;
201     symmetric_key key;
202     for (x = 0; x < (int)(sizeof(tests) / sizeof(tests[0])); x++) {
203        if ((err = rc5_setup(tests[x].key, 16, 12, &key)) != CRYPT_OK) {
204           return err;
205        }
206        rc5_ecb_encrypt(tests[x].pt, tmp[0], &key);
207        rc5_ecb_decrypt(tmp[0], tmp[1], &key);
208        if (compare_testvector(tmp[0], 8, tests[x].ct, 8, "RC5 Encrypt", x) != 0 ||
209              compare_testvector(tmp[1], 8, tests[x].pt, 8, "RC5 Decrypt", x) != 0) {
210           return CRYPT_FAIL_TESTVECTOR;
211        }
212        for (y = 0; y < 8; y++) tmp[0][y] = 0;
213        for (y = 0; y < 1000; y++) rc5_ecb_encrypt(tmp[0], tmp[0], &key);
214        for (y = 0; y < 1000; y++) rc5_ecb_decrypt(tmp[0], tmp[0], &key);
215        for (y = 0; y < 8; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
216     }
217     return CRYPT_OK;
218    #endif
219  }
220  void rc5_done(symmetric_key *skey)
221  {
222    LTC_UNUSED_PARAM(skey);
223  }
224  int rc5_keysize(int *keysize)
225  {
226     LTC_ARGCHK(keysize != NULL);
227     if (*keysize < 8) {
228        return CRYPT_INVALID_KEYSIZE;
229     }
230     if (*keysize > 128) {
231        *keysize = 128;
232     }
233     return CRYPT_OK;
234  }
235  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ocb3_add_aad.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-rc5.c</div>
                <div class="column column_space"><pre><code>13     ocb->ablock_index++;
14     return CRYPT_OK;
15  }
16  int ocb3_add_aad(ocb3_state *ocb, const unsigned char *aad, unsigned long aadlen)
</pre></code></div>
                <div class="column column_space"><pre><code>159     B -= skey->rc5.K[1];
160     STORE32L(A, &pt[0]);
161     STORE32L(B, &pt[4]);
162     return CRYPT_OK;
163  }
164  #ifdef LTC_CLEAN_STACK
165  int rc5_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    