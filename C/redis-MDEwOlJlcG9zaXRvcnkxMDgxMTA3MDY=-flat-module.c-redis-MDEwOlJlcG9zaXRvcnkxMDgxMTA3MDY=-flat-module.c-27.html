
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-module.c</h3>
            <pre><code>1  #include &quot;server.h&quot;
2  #include &quot;cluster.h&quot;
3  #include &quot;rdb.h&quot;
4  #ifndef _WIN32
5  #include &lt;dlfcn.h&gt;
6  #else
7  #include &quot;Win32_Interop/dlfcn.h&quot;
8  #include &quot;Win32_Interop/Win32_PThread.h&quot;
9  #include &quot;Win32_Interop/Win32_Error.h&quot;
10  #endif
11  #define REDISMODULE_CORE 1
12  #include &quot;redismodule.h&quot;
13  struct RedisModule {
14      void *handle;   &amp;bsol;* Module dlopen() handle. */
15      char *name;     &amp;bsol;* Module name. */
16      int ver;        &amp;bsol;* Module version. We use just progressive integers. */
17      int apiver;     &amp;bsol;* Module API version as requested during initialization.*/
18      list *types;    &amp;bsol;* Module data types. */
19      list *usedby;   &amp;bsol;* List of modules using APIs from this one. */
20      list *using;    &amp;bsol;* List of modules we use some APIs of. */
21      list *filters;  &amp;bsol;* List of filters the module has registered. */
22      int in_call;    &amp;bsol;* RM_Call() nesting level */
23  };
24  typedef struct RedisModule RedisModule;
25  struct RedisModuleSharedAPI {
26      void *func;
27      RedisModule *module;
28  };
29  typedef struct RedisModuleSharedAPI RedisModuleSharedAPI;
30  #ifndef _WIN32
31  static dict *modules; &amp;bsol;* Hash table of modules. SDS -&gt; RedisModule ptr.*/
32  #endif
33  struct AutoMemEntry {
34      void *ptr;
35      int type;
36  };
37  #define REDISMODULE_AM_KEY 0
38  #define REDISMODULE_AM_STRING 1
39  #define REDISMODULE_AM_REPLY 2
40  #define REDISMODULE_AM_FREED 3 &amp;bsol;* Explicitly freed by user already. */
41  #define REDISMODULE_AM_DICT 4
42  #define REDISMODULE_POOL_ALLOC_MIN_SIZE (1024*8)
43  #define REDISMODULE_POOL_ALLOC_ALIGN (sizeof(void*))
44  typedef struct RedisModulePoolAllocBlock {
45      uint32_t size;
46      uint32_t used;
47      struct RedisModulePoolAllocBlock *next;
48      char memory[];
49  } RedisModulePoolAllocBlock;
50  struct RedisModuleBlockedClient;
51  struct RedisModuleCtx {
52      void *getapifuncptr;            &amp;bsol;* NOTE: Must be the first field. */
53      struct RedisModule *module;     &amp;bsol;* Module reference. */
54      client *client;                 &amp;bsol;* Client calling a command. */
55      struct RedisModuleBlockedClient *blocked_client; &amp;bsol;* Blocked client for
56                                                          thread safe context. */
57      struct AutoMemEntry *amqueue;   &amp;bsol;* Auto memory queue of objects to free. */
58      int amqueue_len;                &amp;bsol;* Number of slots in amqueue. */
59      int amqueue_used;               &amp;bsol;* Number of used slots in amqueue. */
60      int flags;                      &amp;bsol;* REDISMODULE_CTX_... flags. */
61      void **postponed_arrays;        &amp;bsol;* To set with RM_ReplySetArrayLength(). */
62      int postponed_arrays_count;     &amp;bsol;* Number of entries in postponed_arrays. */
63      void *blocked_privdata;         &amp;bsol;* Privdata set when unblocking a client. */
64      int *keys_pos;
65      int keys_count;
66      struct RedisModulePoolAllocBlock *pa_head;
67      redisOpArray saved_oparray;    &amp;bsol;* When propagating commands in a callback
68                                        we reallocate the &quot;also propagate&quot; op
69                                        array. Here we save the old one to
70                                        restore it later. */
71  };
72  typedef struct RedisModuleCtx RedisModuleCtx;
73  #define REDISMODULE_CTX_INIT {(void*)(PORT_ULONG)&amp;RM_GetApi, NULL, NULL, NULL, NULL, 0, 0, 0, NULL, 0, NULL, NULL, 0, NULL, {0}}
74  #define REDISMODULE_CTX_MULTI_EMITTED (1&lt;&lt;0)
75  #define REDISMODULE_CTX_AUTO_MEMORY (1&lt;&lt;1)
76  #define REDISMODULE_CTX_KEYS_POS_REQUEST (1&lt;&lt;2)
77  #define REDISMODULE_CTX_BLOCKED_REPLY (1&lt;&lt;3)
78  #define REDISMODULE_CTX_BLOCKED_TIMEOUT (1&lt;&lt;4)
79  #define REDISMODULE_CTX_THREAD_SAFE (1&lt;&lt;5)
80  #define REDISMODULE_CTX_BLOCKED_DISCONNECTED (1&lt;&lt;6)
81  #define REDISMODULE_CTX_MODULE_COMMAND_CALL (1&lt;&lt;7)
82  struct RedisModuleKey {
83      RedisModuleCtx *ctx;
84      redisDb *db;
85      robj *key;      &amp;bsol;* Key name object. */
86      robj *value;    &amp;bsol;* Value object, or NULL if the key was not found. */
87      void *iter;     &amp;bsol;* Iterator. */
88      int mode;       &amp;bsol;* Opening mode. */
89      uint32_t ztype;         &amp;bsol;* REDISMODULE_ZSET_RANGE_* */
90      zrangespec zrs;         &amp;bsol;* Score range. */
91      zlexrangespec zlrs;     &amp;bsol;* Lex range. */
92      uint32_t zstart;        &amp;bsol;* Start pos for positional ranges. */
93      uint32_t zend;          &amp;bsol;* End pos for positional ranges. */
94      void *zcurrent;         &amp;bsol;* Zset iterator current node. */
95      int zer;                &amp;bsol;* Zset iterator end reached flag
96                                 (true if end was reached). */
97  };
98  typedef struct RedisModuleKey RedisModuleKey;
99  #define REDISMODULE_ZSET_RANGE_NONE 0       &amp;bsol;* This must always be 0. */
100  #define REDISMODULE_ZSET_RANGE_LEX 1
101  #define REDISMODULE_ZSET_RANGE_SCORE 2
102  #define REDISMODULE_ZSET_RANGE_POS 3
103  struct RedisModuleBlockedClient;
104  typedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);
105  typedef void (*RedisModuleDisconnectFunc) (RedisModuleCtx *ctx, struct RedisModuleBlockedClient *bc);
106  struct RedisModuleCommandProxy {
107      struct RedisModule *module;
108      RedisModuleCmdFunc func;
109      struct redisCommand *rediscmd;
110  };
111  typedef struct RedisModuleCommandProxy RedisModuleCommandProxy;
112  #define REDISMODULE_REPLYFLAG_NONE 0
113  #define REDISMODULE_REPLYFLAG_TOPARSE (1&lt;&lt;0) &amp;bsol;* Protocol must be parsed. */
114  #define REDISMODULE_REPLYFLAG_NESTED (1&lt;&lt;1)  &amp;bsol;* Nested reply object. No proto
115                                                  or struct free. */
116  typedef struct RedisModuleCallReply {
117      RedisModuleCtx *ctx;
118      int type;       &amp;bsol;* REDISMODULE_REPLY_... */
119      int flags;      &amp;bsol;* REDISMODULE_REPLYFLAG_...  */
120      size_t len;     &amp;bsol;* Len of strings or num of elements of arrays. */
121      char *proto;    &amp;bsol;* Raw reply protocol. An SDS string at top-level object. */
122      size_t protolen;&amp;bsol;* Length of protocol. */
123      union {
124          const char *str; &amp;bsol;* String pointer for string and error replies. This
125                              does not need to be freed, always points inside
126                              a reply-&gt;proto buffer of the reply object or, in
127                              case of array elements, of parent reply objects. */
128          PORT_LONGLONG ll;    &amp;bsol;* Reply value for integer reply. */
129          struct RedisModuleCallReply *array; &amp;bsol;* Array of sub-reply elements. */
130      } val;
131  } RedisModuleCallReply;
132  typedef struct RedisModuleBlockedClient {
133      client *client;  &amp;bsol;* Pointer to the blocked client. or NULL if the client
134                          was destroyed during the life of this object. */
135      RedisModule *module;    &amp;bsol;* Module blocking the client. */
136      RedisModuleCmdFunc reply_callback; &amp;bsol;* Reply callback on normal completion.*/
137      RedisModuleCmdFunc timeout_callback; &amp;bsol;* Reply callback on timeout. */
138      RedisModuleDisconnectFunc disconnect_callback; &amp;bsol;* Called on disconnection.*/
139      void (*free_privdata)(RedisModuleCtx*,void*);&amp;bsol;* privdata cleanup callback.*/
140      void *privdata;     &amp;bsol;* Module private data that may be used by the reply
141                             or timeout callback. It is set via the
142                             RedisModule_UnblockClient() API. */
143      client *reply_client;           &amp;bsol;* Fake client used to accumulate replies
144                                         in thread safe contexts. */
145      int dbid;           &amp;bsol;* Database number selected by the original client. */
146  } RedisModuleBlockedClient;
147  #ifndef _WIN32
148  static pthread_mutex_t moduleUnblockedClientsMutex = PTHREAD_MUTEX_INITIALIZER;
149  #else
150  pthread_mutex_t moduleUnblockedClientsMutex;
151  #endif
152  static list *moduleUnblockedClients;
153  #ifndef _WIN32
154  static pthread_mutex_t moduleGIL = PTHREAD_MUTEX_INITIALIZER;
155  #else
156  pthread_mutex_t moduleGIL;
157  #endif
158  typedef int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);
159  typedef struct RedisModuleKeyspaceSubscriber {
160      RedisModule *module;
161      RedisModuleNotificationFunc notify_callback;
162      int event_mask;
163      int active;
164  } RedisModuleKeyspaceSubscriber;
165  static list *moduleKeyspaceSubscribers;
166  static client *moduleFreeContextReusedClient;
167  typedef struct RedisModuleDict {
168      rax *rax;                       &amp;bsol;* The radix tree. */
169  } RedisModuleDict;
170  typedef struct RedisModuleDictIter {
171      RedisModuleDict *dict;
172      raxIterator ri;
173  } RedisModuleDictIter;
174  typedef struct RedisModuleCommandFilterCtx {
175      RedisModuleString **argv;
176      int argc;
177  } RedisModuleCommandFilterCtx;
178  typedef void (*RedisModuleCommandFilterFunc) (RedisModuleCommandFilterCtx *filter);
179  typedef struct RedisModuleCommandFilter {
180      RedisModule *module;
181      RedisModuleCommandFilterFunc callback;
182      int flags;
183  } RedisModuleCommandFilter;
184  static list *moduleCommandFilters;
185  #define REDISMODULE_ARGV_REPLICATE (1&lt;&lt;0)
186  #define REDISMODULE_ARGV_NO_AOF (1&lt;&lt;1)
187  #define REDISMODULE_ARGV_NO_REPLICAS (1&lt;&lt;2)
188  void RM_FreeCallReply(RedisModuleCallReply *reply);
189  void RM_CloseKey(RedisModuleKey *key);
190  void autoMemoryCollect(RedisModuleCtx *ctx);
191  robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap);
192  void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx);
193  void RM_ZsetRangeStop(RedisModuleKey *kp);
194  static void zsetKeyReset(RedisModuleKey *key);
195  void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d);
196  void *RM_Alloc(size_t bytes) {
197      return zmalloc(bytes);
198  }
199  void *RM_Calloc(size_t nmemb, size_t size) {
200      return zcalloc(nmemb*size);
201  }
202  void* RM_Realloc(void *ptr, size_t bytes) {
203      return zrealloc(ptr,bytes);
204  }
205  void RM_Free(void *ptr) {
206      zfree(ptr);
207  }
208  char *RM_Strdup(const char *str) {
209      return zstrdup(str);
210  }
211  void poolAllocRelease(RedisModuleCtx *ctx) {
212      RedisModulePoolAllocBlock *head = ctx-&gt;pa_head, *next;
213      while(head != NULL) {
214          next = head-&gt;next;
215          zfree(head);
216          head = next;
217      }
218      ctx-&gt;pa_head = NULL;
219  }
220  void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
221      if (bytes == 0) return NULL;
222      RedisModulePoolAllocBlock *b = ctx-&gt;pa_head;
223      size_t left = b ? b-&gt;size - b-&gt;used : 0;
224      if (left &gt;= bytes) {
225          size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;
226          while (bytes &lt; alignment &amp;&amp; alignment/2 &gt;= bytes) alignment /= 2;
227          if (b-&gt;used % alignment)
228              b-&gt;used += alignment - (b-&gt;used % alignment);
229          left = (b-&gt;used &gt; b-&gt;size) ? 0 : b-&gt;size - b-&gt;used;
230      }
231      if (left &lt; bytes) {
232          size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;
233          if (blocksize &lt; bytes) blocksize = bytes;
234          b = zmalloc(sizeof(*b) + blocksize);
235          b-&gt;size = blocksize;
236          b-&gt;used = 0;
237          b-&gt;next = ctx-&gt;pa_head;
238          ctx-&gt;pa_head = b;
239      }
240      char *retval = b-&gt;memory + b-&gt;used;
241      b-&gt;used += bytes;
242      return retval;
243  }
244  int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
245      robj *obj;
246      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;value)
247          return REDISMODULE_ERR;
248      switch(type) {
249      case REDISMODULE_KEYTYPE_LIST:
250          obj = createQuicklistObject();
251          quicklistSetOptions(obj-&gt;ptr, server.list_max_ziplist_size,
252                              server.list_compress_depth);
253          break;
254      case REDISMODULE_KEYTYPE_ZSET:
255          obj = createZsetZiplistObject();
256          break;
257      case REDISMODULE_KEYTYPE_HASH:
258          obj = createHashObject();
259          break;
260      default: return REDISMODULE_ERR;
261      }
262      dbAdd(key-&gt;db,key-&gt;key,obj);
263      key-&gt;value = obj;
264      return REDISMODULE_OK;
265  }
266  int moduleDelKeyIfEmpty(RedisModuleKey *key) {
267      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;value == NULL) return 0;
268      int isempty;
269      robj *o = key-&gt;value;
270      switch(o-&gt;type) {
271      case OBJ_LIST: isempty = listTypeLength(o) == 0; break;
272      case OBJ_SET: isempty = setTypeSize(o) == 0; break;
273      case OBJ_ZSET: isempty = zsetLength(o) == 0; break;
274      case OBJ_HASH: isempty = hashTypeLength(o) == 0; break;
275      case OBJ_STREAM: isempty = streamLength(o) == 0; break;
276      default: isempty = 0;
277      }
278      if (isempty) {
279          dbDelete(key-&gt;db,key-&gt;key);
280          key-&gt;value = NULL;
281          return 1;
282      } else {
283          return 0;
284      }
285  }
286  int RM_GetApi(const char *funcname, void **targetPtrPtr) {
287      dictEntry *he = dictFind(server.moduleapi, funcname);
288      if (!he) return REDISMODULE_ERR;
289      *targetPtrPtr = dictGetVal(he);
290      return REDISMODULE_OK;
291  }
292  void moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {
293      client *c = ctx-&gt;client;
294      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_MULTI_EMITTED)) return;
295      if (c-&gt;flags &amp; CLIENT_LUA) return;
296      robj *propargv[1];
297      propargv[0] = createStringObject(&quot;EXEC&quot;,4);
298      alsoPropagate(server.execCommand,c-&gt;db-&gt;id,propargv,1,
299          PROPAGATE_AOF|PROPAGATE_REPL);
300      decrRefCount(propargv[0]);
301      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_MODULE_COMMAND_CALL) &amp;&amp;
302          server.also_propagate.numops)
303      {
304          for (int j = 0; j &lt; server.also_propagate.numops; j++) {
305              redisOp *rop = &amp;server.also_propagate.ops[j];
306              int target = rop-&gt;target;
307              if (target)
308                  propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);
309          }
310          redisOpArrayFree(&amp;server.also_propagate);
311          server.also_propagate = ctx-&gt;saved_oparray;
312          redisOpArrayInit(&amp;ctx-&gt;saved_oparray);
313      }
314  }
315  void moduleFreeContext(RedisModuleCtx *ctx) {
316      moduleHandlePropagationAfterCommandCallback(ctx);
317      autoMemoryCollect(ctx);
318      poolAllocRelease(ctx);
319      if (ctx-&gt;postponed_arrays) {
320          zfree(ctx-&gt;postponed_arrays);
321          ctx-&gt;postponed_arrays_count = 0;
322          serverLog(LL_WARNING,
323              &quot;API misuse detected in module %s: &quot;
324              &quot;RedisModule_ReplyWithArray(REDISMODULE_POSTPONED_ARRAY_LEN) &quot;
325              &quot;not matched by the same number of RedisModule_SetReplyArrayLen() &quot;
326              &quot;calls.&quot;,
327              ctx-&gt;module-&gt;name);
328      }
329      if (ctx-&gt;flags &amp; REDISMODULE_CTX_THREAD_SAFE) freeClient(ctx-&gt;client);
330  }
331  void RedisModuleCommandDispatcher(client *c) {
332      RedisModuleCommandProxy *cp = (void*) (PORT_ULONG)c-&gt;cmd-&gt;getkeys_proc;
333      RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
334      ctx.flags |= REDISMODULE_CTX_MODULE_COMMAND_CALL;
335      ctx.module = cp-&gt;module;
336      ctx.client = c;
337      cp-&gt;func(&amp;ctx,(void**)c-&gt;argv,c-&gt;argc);
338      moduleFreeContext(&amp;ctx);
339      for (int i = 0; i &lt; c-&gt;argc; i++) {
340          if (c-&gt;argv[i]-&gt;refcount &gt; 1)
341              trimStringObjectIfNeeded(c-&gt;argv[i]);
342      }
343  }
344  int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
345      RedisModuleCommandProxy *cp = (void*) (PORT_ULONG)cmd-&gt;getkeys_proc;
346      RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
347      ctx.module = cp-&gt;module;
348      ctx.client = NULL;
349      ctx.flags |= REDISMODULE_CTX_KEYS_POS_REQUEST;
350      cp-&gt;func(&amp;ctx,(void**)argv,argc);
351      int *res = ctx.keys_pos;
352      if (numkeys) *numkeys = ctx.keys_count;
353      moduleFreeContext(&amp;ctx);
354      return res;
355  }
356  int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
357      return (ctx-&gt;flags &amp; REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;
358  }
359  void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {
360      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_KEYS_POS_REQUEST)) return;
361      if (pos &lt;= 0) return;
362      ctx-&gt;keys_pos = zrealloc(ctx-&gt;keys_pos,sizeof(int)*((PORT_ULONG)ctx-&gt;keys_count+1));  WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
363      ctx-&gt;keys_pos[ctx-&gt;keys_count++] = pos;
364  }
365  int64_t commandFlagsFromString(char *s) {
366      int count, j;
367      int64_t flags = 0;
368      sds *tokens = sdssplitlen(s,strlen(s),&quot; &quot;,1,&amp;count);
369      for (j = 0; j &lt; count; j++) {
370          char *t = tokens[j];
371          if (!strcasecmp(t,&quot;write&quot;)) flags |= CMD_WRITE;
372          else if (!strcasecmp(t,&quot;readonly&quot;)) flags |= CMD_READONLY;
373          else if (!strcasecmp(t,&quot;admin&quot;)) flags |= CMD_ADMIN;
374          else if (!strcasecmp(t,&quot;deny-oom&quot;)) flags |= CMD_DENYOOM;
375          else if (!strcasecmp(t,&quot;deny-script&quot;)) flags |= CMD_NOSCRIPT;
376          else if (!strcasecmp(t,&quot;allow-loading&quot;)) flags |= CMD_LOADING;
377          else if (!strcasecmp(t,&quot;pubsub&quot;)) flags |= CMD_PUBSUB;
378          else if (!strcasecmp(t,&quot;random&quot;)) flags |= CMD_RANDOM;
379          else if (!strcasecmp(t,&quot;allow-stale&quot;)) flags |= CMD_STALE;
380          else if (!strcasecmp(t,&quot;no-monitor&quot;)) flags |= CMD_SKIP_MONITOR;
381          else if (!strcasecmp(t,&quot;fast&quot;)) flags |= CMD_FAST;
382          else if (!strcasecmp(t,&quot;getkeys-api&quot;)) flags |= CMD_MODULE_GETKEYS;
383          else if (!strcasecmp(t,&quot;no-cluster&quot;)) flags |= CMD_MODULE_NO_CLUSTER;
384          else break;
385      }
386      sdsfreesplitres(tokens,count);
387      if (j != count) return -1; &amp;bsol;* Some token not processed correctly. */
388      return flags;
389  }
390  int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
391      int64_t flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
392      if (flags == -1) return REDISMODULE_ERR;
393      if ((flags &amp; CMD_MODULE_NO_CLUSTER) &amp;&amp; server.cluster_enabled)
394          return REDISMODULE_ERR;
395      struct redisCommand *rediscmd;
396      RedisModuleCommandProxy *cp;
397      sds cmdname = sdsnew(name);
398      if (lookupCommand(cmdname) != NULL) {
399          sdsfree(cmdname);
400          return REDISMODULE_ERR;
401      }
402      cp = zmalloc(sizeof(*cp));
403      cp-&gt;module = ctx-&gt;module;
404      cp-&gt;func = cmdfunc;
405      cp-&gt;rediscmd = zmalloc(sizeof(*rediscmd));
406      cp-&gt;rediscmd-&gt;name = cmdname;
407      cp-&gt;rediscmd-&gt;proc = RedisModuleCommandDispatcher;
408      cp-&gt;rediscmd-&gt;arity = -1;
409      cp-&gt;rediscmd-&gt;flags = flags | CMD_MODULE;
410      cp-&gt;rediscmd-&gt;getkeys_proc = (redisGetKeysProc*) (PORT_ULONG)cp;
411      cp-&gt;rediscmd-&gt;firstkey = firstkey;
412      cp-&gt;rediscmd-&gt;lastkey = lastkey;
413      cp-&gt;rediscmd-&gt;keystep = keystep;
414      cp-&gt;rediscmd-&gt;microseconds = 0;
415      cp-&gt;rediscmd-&gt;calls = 0;
416      dictAdd(server.commands,sdsdup(cmdname),cp-&gt;rediscmd);
417      dictAdd(server.orig_commands,sdsdup(cmdname),cp-&gt;rediscmd);
418      return REDISMODULE_OK;
419  }
420  void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
421      RedisModule *module;
422      if (ctx-&gt;module != NULL) return;
423      module = zmalloc(sizeof(*module));
424      module-&gt;name = sdsnew((char*)name);
425      module-&gt;ver = ver;
426      module-&gt;apiver = apiver;
427      module-&gt;types = listCreate();
428      module-&gt;usedby = listCreate();
429      module-&gt;using = listCreate();
430      module-&gt;filters = listCreate();
431      module-&gt;in_call = 0;
432      ctx-&gt;module = module;
433  }
434  int RM_IsModuleNameBusy(const char *name) {
435      sds modulename = sdsnew(name);
436      dictEntry *de = dictFind(modules,modulename);
437      sdsfree(modulename);
438      return de != NULL;
439  }
440  PORT_LONGLONG RM_Milliseconds(void) {
441      return mstime();
442  }
443  void RM_AutoMemory(RedisModuleCtx *ctx) {
444      ctx-&gt;flags |= REDISMODULE_CTX_AUTO_MEMORY;
445  }
446  void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
447      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_AUTO_MEMORY)) return;
448      if (ctx-&gt;amqueue_used == ctx-&gt;amqueue_len) {
449          ctx-&gt;amqueue_len *= 2;
450          if (ctx-&gt;amqueue_len &lt; 16) ctx-&gt;amqueue_len = 16;
451          ctx-&gt;amqueue = zrealloc(ctx-&gt;amqueue,sizeof(struct AutoMemEntry)*ctx-&gt;amqueue_len);
452      }
453      ctx-&gt;amqueue[ctx-&gt;amqueue_used].type = type;
454      ctx-&gt;amqueue[ctx-&gt;amqueue_used].ptr = ptr;
455      ctx-&gt;amqueue_used++;
456  }
457  int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
458      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_AUTO_MEMORY)) return 0;
459      int count = (ctx-&gt;amqueue_used+1)/2;
460      for (int j = 0; j &lt; count; j++) {
461          for (int side = 0; side &lt; 2; side++) {
462              int i = (side == 0) ? (ctx-&gt;amqueue_used - 1 - j) : j;
463              if (ctx-&gt;amqueue[i].type == type &amp;&amp;
464                  ctx-&gt;amqueue[i].ptr == ptr)
465              {
466                  ctx-&gt;amqueue[i].type = REDISMODULE_AM_FREED;
467                  if (i != ctx-&gt;amqueue_used-1) {
468                      ctx-&gt;amqueue[i] = ctx-&gt;amqueue[ctx-&gt;amqueue_used-1];
469                  }
470                  ctx-&gt;amqueue_used--;
471                  return 1;
472              }
473          }
474      }
475      return 0;
476  }
477  void autoMemoryCollect(RedisModuleCtx *ctx) {
478      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_AUTO_MEMORY)) return;
479      ctx-&gt;flags &amp;= ~REDISMODULE_CTX_AUTO_MEMORY;
480      int j;
481      for (j = 0; j &lt; ctx-&gt;amqueue_used; j++) {
482          void *ptr = ctx-&gt;amqueue[j].ptr;
483          switch(ctx-&gt;amqueue[j].type) {
484          case REDISMODULE_AM_STRING: decrRefCount(ptr); break;
485          case REDISMODULE_AM_REPLY: RM_FreeCallReply(ptr); break;
486          case REDISMODULE_AM_KEY: RM_CloseKey(ptr); break;
487          case REDISMODULE_AM_DICT: RM_FreeDict(NULL,ptr); break;
488          }
489      }
490      ctx-&gt;flags |= REDISMODULE_CTX_AUTO_MEMORY;
491      zfree(ctx-&gt;amqueue);
492      ctx-&gt;amqueue = NULL;
493      ctx-&gt;amqueue_len = 0;
494      ctx-&gt;amqueue_used = 0;
495  }
496  RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {
497      RedisModuleString *o = createStringObject(ptr,len);
498      if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
499      return o;
500  }
501  RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {
502      sds s = sdsempty();
503      va_list ap;
504      va_start(ap, fmt);
505      s = sdscatvprintf(s, fmt, ap);
506      va_end(ap);
507      RedisModuleString *o = createObject(OBJ_STRING, s);
508      if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
509      return o;
510  }
511  RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, PORT_LONGLONG ll) {
512      char buf[LONG_STR_SIZE];
513      size_t len = ll2string(buf,sizeof(buf),ll);
514      return RM_CreateString(ctx,buf,len);
515  }
516  RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {
517      RedisModuleString *o = dupStringObject(str);
518      if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
519      return o;
520  }
521  void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {
522      decrRefCount(str);
523      if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);
524  }
525  void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {
526      if (ctx == NULL || !autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {
527          incrRefCount(str);
528      }
529  }
530  const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
531      if (str == NULL) {
532          const char *errmsg = &quot;(NULL string reply referenced in module)&quot;;
533          if (len) *len = strlen(errmsg);
534          return errmsg;
535      }
536      if (len) *len = sdslen(str-&gt;ptr);
537      return str-&gt;ptr;
538  }
539  int RM_StringToLongLong(const RedisModuleString *str, PORT_LONGLONG *ll) {
540      return string2ll(str-&gt;ptr,sdslen(str-&gt;ptr),ll) ? REDISMODULE_OK :
541                                                       REDISMODULE_ERR;
542  }
543  int RM_StringToDouble(const RedisModuleString *str, double *d) {
544      int retval = getDoubleFromObject(str,d);
545      return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
546  }
547  int RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {
548      return compareStringObjects(a,b);
549  }
550  RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
551      if (str-&gt;refcount != 1) {
552          serverLog(LL_WARNING,
553              &quot;Module attempted to use an in-place string modify operation &quot;
554              &quot;with a string referenced multiple times. Please check the code &quot;
555              &quot;for API usage correctness.&quot;);
556          return NULL;
557      }
558      if (str-&gt;encoding == OBJ_ENCODING_EMBSTR) {
559          str-&gt;ptr = sdsnewlen(str-&gt;ptr,sdslen(str-&gt;ptr));
560          str-&gt;encoding = OBJ_ENCODING_RAW;
561      } else if (str-&gt;encoding == OBJ_ENCODING_INT) {
562          str-&gt;ptr = sdsfromlonglong((PORT_LONG)str-&gt;ptr);
563          str-&gt;encoding = OBJ_ENCODING_RAW;
564      }
565      return str;
566  }
567  int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {
568      UNUSED(ctx);
569      str = moduleAssertUnsharedString(str);
570      if (str == NULL) return REDISMODULE_ERR;
571      str-&gt;ptr = sdscatlen(str-&gt;ptr,buf,len);
572      return REDISMODULE_OK;
573  }
574  int RM_WrongArity(RedisModuleCtx *ctx) {
575      addReplyErrorFormat(ctx-&gt;client,
576          &quot;wrong number of arguments for &#x27;%s&#x27; command&quot;,
577          (char*)ctx-&gt;client-&gt;argv[0]-&gt;ptr);
578      return REDISMODULE_OK;
579  }
580  client *moduleGetReplyClient(RedisModuleCtx *ctx) {
581      if (ctx-&gt;flags &amp; REDISMODULE_CTX_THREAD_SAFE) {
582          if (ctx-&gt;blocked_client)
583              return ctx-&gt;blocked_client-&gt;reply_client;
584          else
585              return NULL;
586      } else {
587          return ctx-&gt;client;
588      }
589  }
590  int RM_ReplyWithLongLong(RedisModuleCtx *ctx, PORT_LONGLONG ll) {
591      client *c = moduleGetReplyClient(ctx);
592      if (c == NULL) return REDISMODULE_OK;
593      addReplyLongLong(c,ll);
594      return REDISMODULE_OK;
595  }
596  int replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {
597      client *c = moduleGetReplyClient(ctx);
598      if (c == NULL) return REDISMODULE_OK;
599      sds strmsg = sdsnewlen(prefix,1);
600      strmsg = sdscat(strmsg,msg);
601      strmsg = sdscatlen(strmsg,&quot;\r\n&quot;,2);
602      addReplySds(c,strmsg);
603      return REDISMODULE_OK;
604  }
605  int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
606      return replyWithStatus(ctx,err,&quot;-&quot;);
607  }
608  int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
609      return replyWithStatus(ctx,msg,&quot;+&quot;);
610  }
611  int RM_ReplyWithArray(RedisModuleCtx *ctx, PORT_LONG len) {
612      client *c = moduleGetReplyClient(ctx);
613      if (c == NULL) return REDISMODULE_OK;
614      if (len == REDISMODULE_POSTPONED_ARRAY_LEN) {
615          ctx-&gt;postponed_arrays = zrealloc(ctx-&gt;postponed_arrays,sizeof(void*)*
616                  ((PORT_ULONG)ctx-&gt;postponed_arrays_count+1));  WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
617          ctx-&gt;postponed_arrays[ctx-&gt;postponed_arrays_count] =
618              addDeferredMultiBulkLength(c);
619          ctx-&gt;postponed_arrays_count++;
620      } else {
621          addReplyMultiBulkLen(c,len);
622      }
623      return REDISMODULE_OK;
624  }
625  void RM_ReplySetArrayLength(RedisModuleCtx *ctx, PORT_LONG len) {
626      client *c = moduleGetReplyClient(ctx);
627      if (c == NULL) return;
628      if (ctx-&gt;postponed_arrays_count == 0) {
629          serverLog(LL_WARNING,
630              &quot;API misuse detected in module %s: &quot;
631              &quot;RedisModule_ReplySetArrayLength() called without previous &quot;
632              &quot;RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN) &quot;
633              &quot;call.&quot;, ctx-&gt;module-&gt;name);
634              return;
635      }
636      ctx-&gt;postponed_arrays_count--;
637      setDeferredMultiBulkLength(c,
638              ctx-&gt;postponed_arrays[ctx-&gt;postponed_arrays_count],
639              len);
640      if (ctx-&gt;postponed_arrays_count == 0) {
641          zfree(ctx-&gt;postponed_arrays);
642          ctx-&gt;postponed_arrays = NULL;
643      }
644  }
645  int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
646      client *c = moduleGetReplyClient(ctx);
647      if (c == NULL) return REDISMODULE_OK;
648      addReplyBulkCBuffer(c,(char*)buf,len);
649      return REDISMODULE_OK;
650  }
651  int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
652      client *c = moduleGetReplyClient(ctx);
653      if (c == NULL) return REDISMODULE_OK;
654      addReplyBulkCString(c,(char*)buf);
655      return REDISMODULE_OK;
656  }
657  int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
658      client *c = moduleGetReplyClient(ctx);
659      if (c == NULL) return REDISMODULE_OK;
660      addReplyBulk(c,str);
661      return REDISMODULE_OK;
662  }
663  int RM_ReplyWithNull(RedisModuleCtx *ctx) {
664      client *c = moduleGetReplyClient(ctx);
665      if (c == NULL) return REDISMODULE_OK;
666      addReply(c,shared.nullbulk);
667      return REDISMODULE_OK;
668  }
669  int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
670      client *c = moduleGetReplyClient(ctx);
671      if (c == NULL) return REDISMODULE_OK;
672      sds proto = sdsnewlen(reply-&gt;proto, reply-&gt;protolen);
673      addReplySds(c,proto);
674      return REDISMODULE_OK;
675  }
676  int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
677      client *c = moduleGetReplyClient(ctx);
678      if (c == NULL) return REDISMODULE_OK;
679      addReplyDouble(c,d);
680      return REDISMODULE_OK;
681  }
682  void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {
683      if (ctx-&gt;client-&gt;flags &amp; (CLIENT_MULTI|CLIENT_LUA)) return;
684      if (ctx-&gt;flags &amp; REDISMODULE_CTX_MULTI_EMITTED) return;
685      if (ctx-&gt;flags &amp; REDISMODULE_CTX_THREAD_SAFE) return;
686      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_MODULE_COMMAND_CALL)) {
687          ctx-&gt;saved_oparray = server.also_propagate;
688          redisOpArrayInit(&amp;server.also_propagate);
689      }
690      execCommandPropagateMulti(ctx-&gt;client);
691      ctx-&gt;flags |= REDISMODULE_CTX_MULTI_EMITTED;
692  }
693  int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
694      struct redisCommand *cmd;
695      robj **argv = NULL;
696      int argc = 0, flags = 0, j;
697      va_list ap;
698      cmd = lookupCommandByCString((char*)cmdname);
699      if (!cmd) return REDISMODULE_ERR;
700      va_start(ap, fmt);
701      argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&amp;argc,&amp;flags,ap);
702      va_end(ap);
703      if (argv == NULL) return REDISMODULE_ERR;
704      int target = 0;
705      if (!(flags &amp; REDISMODULE_ARGV_NO_AOF)) target |= PROPAGATE_AOF;
706      if (!(flags &amp; REDISMODULE_ARGV_NO_REPLICAS)) target |= PROPAGATE_REPL;
707      if (ctx-&gt;flags &amp; REDISMODULE_CTX_THREAD_SAFE) {
708          propagate(cmd,ctx-&gt;client-&gt;db-&gt;id,argv,argc,target);
709      } else {
710          moduleReplicateMultiIfNeeded(ctx);
711          alsoPropagate(cmd,ctx-&gt;client-&gt;db-&gt;id,argv,argc,target);
712      }
713      for (j = 0; j &lt; argc; j++) decrRefCount(argv[j]);
714      zfree(argv);
715      server.dirty++;
716      return REDISMODULE_OK;
717  }
718  int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
719      alsoPropagate(ctx-&gt;client-&gt;cmd,ctx-&gt;client-&gt;db-&gt;id,
720          ctx-&gt;client-&gt;argv,ctx-&gt;client-&gt;argc,
721          PROPAGATE_AOF|PROPAGATE_REPL);
722      server.dirty++;
723      return REDISMODULE_OK;
724  }
725  PORT_ULONGLONG RM_GetClientId(RedisModuleCtx *ctx) {
726      if (ctx-&gt;client == NULL) return 0;
727      return ctx-&gt;client-&gt;id;
728  }
729  int RM_GetSelectedDb(RedisModuleCtx *ctx) {
730      return ctx-&gt;client-&gt;db-&gt;id;
731  }
732  int RM_GetContextFlags(RedisModuleCtx *ctx) {
733      int flags = 0;
734      if (ctx-&gt;client) {
735          if (ctx-&gt;client-&gt;flags &amp; CLIENT_LUA)
736           flags |= REDISMODULE_CTX_FLAGS_LUA;
737          if (ctx-&gt;client-&gt;flags &amp; CLIENT_MULTI)
738           flags |= REDISMODULE_CTX_FLAGS_MULTI;
739          if (ctx-&gt;client-&gt;flags &amp; CLIENT_MASTER)
740           flags |= REDISMODULE_CTX_FLAGS_REPLICATED;
741      }
742      if (server.cluster_enabled)
743          flags |= REDISMODULE_CTX_FLAGS_CLUSTER;
744      if (server.loading)
745          flags |= REDISMODULE_CTX_FLAGS_LOADING;
746      if (server.maxmemory &gt; 0) {
747          flags |= REDISMODULE_CTX_FLAGS_MAXMEMORY;
748          if (server.maxmemory_policy != MAXMEMORY_NO_EVICTION)
749              flags |= REDISMODULE_CTX_FLAGS_EVICT;
750      }
751      if (server.aof_state != AOF_OFF)
752          flags |= REDISMODULE_CTX_FLAGS_AOF;
753      if (server.saveparamslen &gt; 0)
754          flags |= REDISMODULE_CTX_FLAGS_RDB;
755      if (server.masterhost == NULL) {
756          flags |= REDISMODULE_CTX_FLAGS_MASTER;
757      } else {
758          flags |= REDISMODULE_CTX_FLAGS_SLAVE;
759          if (server.repl_slave_ro)
760              flags |= REDISMODULE_CTX_FLAGS_READONLY;
761          if (server.repl_state == REPL_STATE_CONNECT ||
762              server.repl_state == REPL_STATE_CONNECTING)
763          {
764              flags |= REDISMODULE_CTX_FLAGS_REPLICA_IS_CONNECTING;
765          } else if (server.repl_state == REPL_STATE_TRANSFER) {
766              flags |= REDISMODULE_CTX_FLAGS_REPLICA_IS_TRANSFERRING;
767          } else if (server.repl_state == REPL_STATE_CONNECTED) {
768              flags |= REDISMODULE_CTX_FLAGS_REPLICA_IS_ONLINE;
769          }
770          if (server.repl_state != REPL_STATE_CONNECTED)
771              flags |= REDISMODULE_CTX_FLAGS_REPLICA_IS_STALE;
772      }
773      float level;
774      int retval = getMaxmemoryState(NULL,NULL,NULL,&amp;level);
775      if (retval == C_ERR) flags |= REDISMODULE_CTX_FLAGS_OOM;
776      if (level &gt; 0.75) flags |= REDISMODULE_CTX_FLAGS_OOM_WARNING;
777      if (hasActiveChildProcess()) flags |= REDISMODULE_CTX_FLAGS_ACTIVE_CHILD;
778      return flags;
779  }
780  int RM_SelectDb(RedisModuleCtx *ctx, int newid) {
781      int retval = selectDb(ctx-&gt;client,newid);
782      return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
783  }
784  void *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {
785      RedisModuleKey *kp;
786      robj *value;
787      if (mode &amp; REDISMODULE_WRITE) {
788          value = lookupKeyWrite(ctx-&gt;client-&gt;db,keyname);
789      } else {
790          value = lookupKeyRead(ctx-&gt;client-&gt;db,keyname);
791          if (value == NULL) {
792              return NULL;
793          }
794      }
795      kp = zmalloc(sizeof(*kp));
796      kp-&gt;ctx = ctx;
797      kp-&gt;db = ctx-&gt;client-&gt;db;
798      kp-&gt;key = keyname;
799      incrRefCount(keyname);
800      kp-&gt;value = value;
801      kp-&gt;iter = NULL;
802      kp-&gt;mode = mode;
803      zsetKeyReset(kp);
804      autoMemoryAdd(ctx,REDISMODULE_AM_KEY,kp);
805      return (void*)kp;
806  }
807  void RM_CloseKey(RedisModuleKey *key) {
808      if (key == NULL) return;
809      if (key-&gt;mode &amp; REDISMODULE_WRITE) signalModifiedKey(key-&gt;db,key-&gt;key);
810      RM_ZsetRangeStop(key);
811      decrRefCount(key-&gt;key);
812      autoMemoryFreed(key-&gt;ctx,REDISMODULE_AM_KEY,key);
813      zfree(key);
814  }
815  int RM_KeyType(RedisModuleKey *key) {
816      if (key == NULL || key-&gt;value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;
817      switch(key-&gt;value-&gt;type) {
818      case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;
819      case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;
820      case OBJ_SET: return REDISMODULE_KEYTYPE_SET;
821      case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;
822      case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;
823      case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;
824      default: return 0;
825      }
826  }
827  size_t RM_ValueLength(RedisModuleKey *key) {
828      if (key == NULL || key-&gt;value == NULL) return 0;
829      switch(key-&gt;value-&gt;type) {
830      case OBJ_STRING: return stringObjectLen(key-&gt;value);
831      case OBJ_LIST: return listTypeLength(key-&gt;value);
832      case OBJ_SET: return setTypeSize(key-&gt;value);
833      case OBJ_ZSET: return zsetLength(key-&gt;value);
834      case OBJ_HASH: return hashTypeLength(key-&gt;value);
835      case OBJ_STREAM: return streamLength(key-&gt;value);
836      default: return 0;
837      }
838  }
839  int RM_DeleteKey(RedisModuleKey *key) {
840      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
841      if (key-&gt;value) {
842          dbDelete(key-&gt;db,key-&gt;key);
843          key-&gt;value = NULL;
844      }
845      return REDISMODULE_OK;
846  }
847  int RM_UnlinkKey(RedisModuleKey *key) {
848      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
849      if (key-&gt;value) {
850          dbAsyncDelete(key-&gt;db,key-&gt;key);
851          key-&gt;value = NULL;
852      }
853      return REDISMODULE_OK;
854  }
855  mstime_t RM_GetExpire(RedisModuleKey *key) {
856      mstime_t expire = getExpire(key-&gt;db,key-&gt;key);
857      if (expire == -1 || key-&gt;value == NULL) return -1;
858      expire -= mstime();
859      return expire &gt;= 0 ? expire : 0;
860  }
861  int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
862      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;value == NULL)
863          return REDISMODULE_ERR;
864      if (expire != REDISMODULE_NO_EXPIRE) {
865          expire += mstime();
866          setExpire(key-&gt;ctx-&gt;client,key-&gt;db,key-&gt;key,expire);
867      } else {
868          removeExpire(key-&gt;db,key-&gt;key);
869      }
870      return REDISMODULE_OK;
871  }
872  int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {
873      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;iter) return REDISMODULE_ERR;
874      RM_DeleteKey(key);
875      setKey(key-&gt;db,key-&gt;key,str);
876      key-&gt;value = str;
877      return REDISMODULE_OK;
878  }
879  char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
880      char *emptystring = &quot;&lt;dma-empty-string&gt;&quot;;
881      if (key-&gt;value == NULL) {
882          *len = 0;
883          return emptystring;
884      }
885      if (key-&gt;value-&gt;type != OBJ_STRING) return NULL;
886      if ((mode &amp; REDISMODULE_WRITE) || key-&gt;value-&gt;encoding != OBJ_ENCODING_RAW)
887          key-&gt;value = dbUnshareStringValue(key-&gt;db, key-&gt;key, key-&gt;value);
888      *len = sdslen(key-&gt;value-&gt;ptr);
889      return key-&gt;value-&gt;ptr;
890  }
891  int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
892      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
893      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_STRING) return REDISMODULE_ERR;
894      if (newlen &gt; 512*1024*1024) return REDISMODULE_ERR;
895      if (key-&gt;value == NULL &amp;&amp; newlen == 0) return REDISMODULE_OK;
896      if (key-&gt;value == NULL) {
897          robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));
898          setKey(key-&gt;db,key-&gt;key,o);
899          key-&gt;value = o;
900          decrRefCount(o);
901      } else {
902          key-&gt;value = dbUnshareStringValue(key-&gt;db, key-&gt;key, key-&gt;value);
903          size_t curlen = sdslen(key-&gt;value-&gt;ptr);
904          if (newlen &gt; curlen) {
905              key-&gt;value-&gt;ptr = sdsgrowzero(key-&gt;value-&gt;ptr,newlen);
906          } else if (newlen &lt; curlen) {
907              sdsrange(key-&gt;value-&gt;ptr,0,newlen-1);
908              if (sdslen(key-&gt;value-&gt;ptr) &lt; sdsavail(key-&gt;value-&gt;ptr))
909                  key-&gt;value-&gt;ptr = sdsRemoveFreeSpace(key-&gt;value-&gt;ptr);
910          }
911      }
912      return REDISMODULE_OK;
913  }
914  int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
915      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
916      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_LIST) return REDISMODULE_ERR;
917      if (key-&gt;value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);
918      listTypePush(key-&gt;value, ele,
919          (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);
920      return REDISMODULE_OK;
921  }
922  RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {
923      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) ||
924          key-&gt;value == NULL ||
925          key-&gt;value-&gt;type != OBJ_LIST) return NULL;
926      robj *ele = listTypePop(key-&gt;value,
927          (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);
928      robj *decoded = getDecodedObject(ele);
929      decrRefCount(ele);
930      moduleDelKeyIfEmpty(key);
931      autoMemoryAdd(key-&gt;ctx,REDISMODULE_AM_STRING,decoded);
932      return decoded;
933  }
934  int RM_ZsetAddFlagsToCoreFlags(int flags) {
935      int retflags = 0;
936      if (flags &amp; REDISMODULE_ZADD_XX) retflags |= ZADD_XX;
937      if (flags &amp; REDISMODULE_ZADD_NX) retflags |= ZADD_NX;
938      return retflags;
939  }
940  int RM_ZsetAddFlagsFromCoreFlags(int flags) {
941      int retflags = 0;
942      if (flags &amp; ZADD_ADDED) retflags |= REDISMODULE_ZADD_ADDED;
943      if (flags &amp; ZADD_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;
944      if (flags &amp; ZADD_NOP) retflags |= REDISMODULE_ZADD_NOP;
945      return retflags;
946  }
947  int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {
948      int flags = 0;
949      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
950      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
951      if (key-&gt;value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
952      if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);
953      if (zsetAdd(key-&gt;value,score,ele-&gt;ptr,&amp;flags,NULL) == 0) {
954          if (flagsptr) *flagsptr = 0;
955          return REDISMODULE_ERR;
956      }
957      if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);
958      return REDISMODULE_OK;
959  }
960  int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {
961      int flags = 0;
962      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
963      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
964      if (key-&gt;value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
965      if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);
966      flags |= ZADD_INCR;
967      if (zsetAdd(key-&gt;value,score,ele-&gt;ptr,&amp;flags,newscore) == 0) {
968          if (flagsptr) *flagsptr = 0;
969          return REDISMODULE_ERR;
970      }
971      if (flagsptr &amp;&amp; (*flagsptr &amp; ZADD_NAN)) {
972          *flagsptr = 0;
973          return REDISMODULE_ERR;
974      }
975      if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);
976      return REDISMODULE_OK;
977  }
978  int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
979      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
980      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
981      if (key-&gt;value != NULL &amp;&amp; zsetDel(key-&gt;value,ele-&gt;ptr)) {
982          if (deleted) *deleted = 1;
983      } else {
984          if (deleted) *deleted = 0;
985      }
986      return REDISMODULE_OK;
987  }
988  int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {
989      if (key-&gt;value == NULL) return REDISMODULE_ERR;
990      if (key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
991      if (zsetScore(key-&gt;value,ele-&gt;ptr,score) == C_ERR) return REDISMODULE_ERR;
992      return REDISMODULE_OK;
993  }
994  void zsetKeyReset(RedisModuleKey *key) {
995      key-&gt;ztype = REDISMODULE_ZSET_RANGE_NONE;
996      key-&gt;zcurrent = NULL;
997      key-&gt;zer = 1;
998  }
999  void RM_ZsetRangeStop(RedisModuleKey *key) {
1000      if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX)
1001          zslFreeLexRange(&amp;key-&gt;zlrs);
1002      zsetKeyReset(key);
1003  }
1004  int RM_ZsetRangeEndReached(RedisModuleKey *key) {
1005      return key-&gt;zer;
1006  }
1007  int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {
1008      if (!key-&gt;value || key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
1009      RM_ZsetRangeStop(key);
1010      key-&gt;ztype = REDISMODULE_ZSET_RANGE_SCORE;
1011      key-&gt;zer = 0;
1012      zrangespec *zrs = &amp;key-&gt;zrs;
1013      zrs-&gt;min = min;
1014      zrs-&gt;max = max;
1015      zrs-&gt;minex = minex;
1016      zrs-&gt;maxex = maxex;
1017      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1018          key-&gt;zcurrent = first ? zzlFirstInRange(key-&gt;value-&gt;ptr,zrs) :
1019                                  zzlLastInRange(key-&gt;value-&gt;ptr,zrs);
1020      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1021          zset *zs = key-&gt;value-&gt;ptr;
1022          zskiplist *zsl = zs-&gt;zsl;
1023          key-&gt;zcurrent = first ? zslFirstInRange(zsl,zrs) :
1024                                  zslLastInRange(zsl,zrs);
1025      } else {
1026          serverPanic(&quot;Unsupported zset encoding&quot;);
1027      }
1028      if (key-&gt;zcurrent == NULL) key-&gt;zer = 1;
1029      return REDISMODULE_OK;
1030  }
1031  int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
1032      return zsetInitScoreRange(key,min,max,minex,maxex,1);
1033  }
1034  int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
1035      return zsetInitScoreRange(key,min,max,minex,maxex,0);
1036  }
1037  int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {
1038      if (!key-&gt;value || key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
1039      RM_ZsetRangeStop(key);
1040      key-&gt;zer = 0;
1041      zlexrangespec *zlrs = &amp;key-&gt;zlrs;
1042      if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;
1043      key-&gt;ztype = REDISMODULE_ZSET_RANGE_LEX;
1044      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1045          key-&gt;zcurrent = first ? zzlFirstInLexRange(key-&gt;value-&gt;ptr,zlrs) :
1046                                  zzlLastInLexRange(key-&gt;value-&gt;ptr,zlrs);
1047      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1048          zset *zs = key-&gt;value-&gt;ptr;
1049          zskiplist *zsl = zs-&gt;zsl;
1050          key-&gt;zcurrent = first ? zslFirstInLexRange(zsl,zlrs) :
1051                                  zslLastInLexRange(zsl,zlrs);
1052      } else {
1053          serverPanic(&quot;Unsupported zset encoding&quot;);
1054      }
1055      if (key-&gt;zcurrent == NULL) key-&gt;zer = 1;
1056      return REDISMODULE_OK;
1057  }
1058  int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
1059      return zsetInitLexRange(key,min,max,1);
1060  }
1061  int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
1062      return zsetInitLexRange(key,min,max,0);
1063  }
1064  RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {
1065      RedisModuleString *str;
1066      if (key-&gt;zcurrent == NULL) return NULL;
1067      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1068          unsigned char *eptr, *sptr;
1069          eptr = key-&gt;zcurrent;
1070          sds ele = ziplistGetObject(eptr);
1071          if (score) {
1072              sptr = ziplistNext(key-&gt;value-&gt;ptr,eptr);
1073              *score = zzlGetScore(sptr);
1074          }
1075          str = createObject(OBJ_STRING,ele);
1076      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1077          zskiplistNode *ln = key-&gt;zcurrent;
1078          if (score) *score = ln-&gt;score;
1079          str = createStringObject(ln-&gt;ele,sdslen(ln-&gt;ele));
1080      } else {
1081          serverPanic(&quot;Unsupported zset encoding&quot;);
1082      }
1083      autoMemoryAdd(key-&gt;ctx,REDISMODULE_AM_STRING,str);
1084      return str;
1085  }
1086  int RM_ZsetRangeNext(RedisModuleKey *key) {
1087      if (!key-&gt;ztype || !key-&gt;zcurrent) return 0; &amp;bsol;* No active iterator. */
1088      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1089          unsigned char *zl = key-&gt;value-&gt;ptr;
1090          unsigned char *eptr = key-&gt;zcurrent;
1091          unsigned char *next;
1092          next = ziplistNext(zl,eptr); &amp;bsol;* Skip element. */
1093          if (next) next = ziplistNext(zl,next); &amp;bsol;* Skip score. */
1094          if (next == NULL) {
1095              key-&gt;zer = 1;
1096              return 0;
1097          } else {
1098              if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_SCORE) {
1099                  unsigned char *saved_next = next;
1100                  next = ziplistNext(zl,next); &amp;bsol;* Skip next element. */
1101                  double score = zzlGetScore(next); &amp;bsol;* Obtain the next score. */
1102                  if (!zslValueLteMax(score,&amp;key-&gt;zrs)) {
1103                      key-&gt;zer = 1;
1104                      return 0;
1105                  }
1106                  next = saved_next;
1107              } else if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX) {
1108                  if (!zzlLexValueLteMax(next,&amp;key-&gt;zlrs)) {
1109                      key-&gt;zer = 1;
1110                      return 0;
1111                  }
1112              }
<span onclick='openModal()' class='match'>1113              key-&gt;zcurrent = next;
1114              return 1;
1115          }
1116      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1117          zskiplistNode *ln = key-&gt;zcurrent, *next = ln-&gt;level[0].forward;
</span>1118          if (next == NULL) {
1119              key-&gt;zer = 1;
1120              return 0;
1121          } else {
1122              if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_SCORE &amp;&amp;
1123                  !zslValueLteMax(next-&gt;score,&amp;key-&gt;zrs))
1124              {
1125                  key-&gt;zer = 1;
1126                  return 0;
1127              } else if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX) {
1128                  if (!zslLexValueLteMax(next-&gt;ele,&amp;key-&gt;zlrs)) {
1129                      key-&gt;zer = 1;
1130                      return 0;
1131                  }
1132              }
1133              key-&gt;zcurrent = next;
1134              return 1;
1135          }
1136      } else {
1137          serverPanic(&quot;Unsupported zset encoding&quot;);
1138      }
1139  }
1140  int RM_ZsetRangePrev(RedisModuleKey *key) {
1141      if (!key-&gt;ztype || !key-&gt;zcurrent) return 0; &amp;bsol;* No active iterator. */
1142      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1143          unsigned char *zl = key-&gt;value-&gt;ptr;
1144          unsigned char *eptr = key-&gt;zcurrent;
1145          unsigned char *prev;
1146          prev = ziplistPrev(zl,eptr); &amp;bsol;* Go back to previous score. */
1147          if (prev) prev = ziplistPrev(zl,prev); &amp;bsol;* Back to previous ele. */
1148          if (prev == NULL) {
1149              key-&gt;zer = 1;
1150              return 0;
1151          } else {
1152              if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_SCORE) {
1153                  unsigned char *saved_prev = prev;
1154                  prev = ziplistNext(zl,prev); &amp;bsol;* Skip element to get the score.*/
1155                  double score = zzlGetScore(prev); &amp;bsol;* Obtain the prev score. */
1156                  if (!zslValueGteMin(score,&amp;key-&gt;zrs)) {
1157                      key-&gt;zer = 1;
1158                      return 0;
1159                  }
1160                  prev = saved_prev;
1161              } else if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX) {
1162                  if (!zzlLexValueGteMin(prev,&amp;key-&gt;zlrs)) {
1163                      key-&gt;zer = 1;
1164                      return 0;
1165                  }
1166              }
1167              key-&gt;zcurrent = prev;
1168              return 1;
1169          }
1170      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1171          zskiplistNode *ln = key-&gt;zcurrent, *prev = ln-&gt;backward;
1172          if (prev == NULL) {
1173              key-&gt;zer = 1;
1174              return 0;
1175          } else {
1176              if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_SCORE &amp;&amp;
1177                  !zslValueGteMin(prev-&gt;score,&amp;key-&gt;zrs))
1178              {
1179                  key-&gt;zer = 1;
1180                  return 0;
1181              } else if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX) {
1182                  if (!zslLexValueGteMin(prev-&gt;ele,&amp;key-&gt;zlrs)) {
1183                      key-&gt;zer = 1;
1184                      return 0;
1185                  }
1186              }
1187              key-&gt;zcurrent = prev;
1188              return 1;
1189          }
1190      } else {
1191          serverPanic(&quot;Unsupported zset encoding&quot;);
1192      }
1193  }
1194  int RM_HashSet(RedisModuleKey *key, int flags, ...) {
1195      va_list ap;
1196      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return 0;
1197      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_HASH) return 0;
1198      if (key-&gt;value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);
1199      int updated = 0;
1200      va_start(ap, flags);
1201      while(1) {
1202          RedisModuleString *field, *value;
1203          if (flags &amp; REDISMODULE_HASH_CFIELDS) {
1204              char *cfield = va_arg(ap,char*);
1205              if (cfield == NULL) break;
1206              field = createRawStringObject(cfield,strlen(cfield));
1207          } else {
1208              field = va_arg(ap,RedisModuleString*);
1209              if (field == NULL) break;
1210          }
1211          value = va_arg(ap,RedisModuleString*);
1212          if (flags &amp; (REDISMODULE_HASH_XX|REDISMODULE_HASH_NX)) {
1213              int exists = hashTypeExists(key-&gt;value, field-&gt;ptr);
1214              if (((flags &amp; REDISMODULE_HASH_XX) &amp;&amp; !exists) ||
1215                  ((flags &amp; REDISMODULE_HASH_NX) &amp;&amp; exists))
1216              {
1217                  if (flags &amp; REDISMODULE_HASH_CFIELDS) decrRefCount(field);
1218                  continue;
1219              }
1220          }
1221          if (value == REDISMODULE_HASH_DELETE) {
1222              updated += hashTypeDelete(key-&gt;value, field-&gt;ptr);
1223              if (flags &amp; REDISMODULE_HASH_CFIELDS) decrRefCount(field);
1224              continue;
1225          }
1226          int low_flags = HASH_SET_COPY;
1227          if (flags &amp; REDISMODULE_HASH_CFIELDS)
1228              low_flags |= HASH_SET_TAKE_FIELD;
1229          robj *argv[2] = {field,value};
1230          hashTypeTryConversion(key-&gt;value,argv,0,1);
1231          updated += hashTypeSet(key-&gt;value, field-&gt;ptr, value-&gt;ptr, low_flags);
1232          if (flags &amp; REDISMODULE_HASH_CFIELDS) {
1233             field-&gt;ptr = NULL; &amp;bsol;* Prevent the SDS string from being freed. */
1234             decrRefCount(field);
1235          }
1236      }
1237      va_end(ap);
1238      moduleDelKeyIfEmpty(key);
1239      return updated;
1240  }
1241  int RM_HashGet(RedisModuleKey *key, int flags, ...) {
1242      va_list ap;
1243      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_HASH) return REDISMODULE_ERR;
1244      va_start(ap, flags);
1245      while(1) {
1246          RedisModuleString *field, **valueptr;
1247          int *existsptr;
1248          if (flags &amp; REDISMODULE_HASH_CFIELDS) {
1249              char *cfield = va_arg(ap,char*);
1250              if (cfield == NULL) break;
1251              field = createRawStringObject(cfield,strlen(cfield));
1252          } else {
1253              field = va_arg(ap,RedisModuleString*);
1254              if (field == NULL) break;
1255          }
1256          if (flags &amp; REDISMODULE_HASH_EXISTS) {
1257              existsptr = va_arg(ap,int*);
1258              if (key-&gt;value)
1259                  *existsptr = hashTypeExists(key-&gt;value,field-&gt;ptr);
1260              else
1261                  *existsptr = 0;
1262          } else {
1263              valueptr = va_arg(ap,RedisModuleString**);
1264              if (key-&gt;value) {
1265                  *valueptr = hashTypeGetValueObject(key-&gt;value,field-&gt;ptr);
1266                  if (*valueptr) {
1267                      robj *decoded = getDecodedObject(*valueptr);
1268                      decrRefCount(*valueptr);
1269                      *valueptr = decoded;
1270                  }
1271                  if (*valueptr)
1272                      autoMemoryAdd(key-&gt;ctx,REDISMODULE_AM_STRING,*valueptr);
1273              } else {
1274                  *valueptr = NULL;
1275              }
1276          }
1277          if (flags &amp; REDISMODULE_HASH_CFIELDS) decrRefCount(field);
1278      }
1279      va_end(ap);
1280      return REDISMODULE_OK;
1281  }
1282  RedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds proto) {
1283      RedisModuleCallReply *reply = zmalloc(sizeof(*reply));
1284      reply-&gt;ctx = ctx;
1285      reply-&gt;proto = proto;
1286      reply-&gt;protolen = sdslen(proto);
1287      reply-&gt;flags = REDISMODULE_REPLYFLAG_TOPARSE; &amp;bsol;* Lazy parsing. */
1288      switch(proto[0]) {
1289      case &#x27;$&#x27;:
1290      case &#x27;+&#x27;: reply-&gt;type = REDISMODULE_REPLY_STRING; break;
1291      case &#x27;-&#x27;: reply-&gt;type = REDISMODULE_REPLY_ERROR; break;
1292      case &#x27;:&#x27;: reply-&gt;type = REDISMODULE_REPLY_INTEGER; break;
1293      case &#x27;*&#x27;: reply-&gt;type = REDISMODULE_REPLY_ARRAY; break;
1294      default: reply-&gt;type = REDISMODULE_REPLY_UNKNOWN; break;
1295      }
1296      if ((proto[0] == &#x27;*&#x27; || proto[0] == &#x27;$&#x27;) &amp;&amp; proto[1] == &#x27;-&#x27;)
1297          reply-&gt;type = REDISMODULE_REPLY_NULL;
1298      return reply;
1299  }
1300  void moduleParseCallReply_Int(RedisModuleCallReply *reply);
1301  void moduleParseCallReply_BulkString(RedisModuleCallReply *reply);
1302  void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply);
1303  void moduleParseCallReply_Array(RedisModuleCallReply *reply);
1304  void moduleParseCallReply(RedisModuleCallReply *reply) {
1305      if (!(reply-&gt;flags &amp; REDISMODULE_REPLYFLAG_TOPARSE)) return;
1306      reply-&gt;flags &amp;= ~REDISMODULE_REPLYFLAG_TOPARSE;
1307      switch(reply-&gt;proto[0]) {
1308      case &#x27;:&#x27;: moduleParseCallReply_Int(reply); break;
1309      case &#x27;$&#x27;: moduleParseCallReply_BulkString(reply); break;
1310      case &#x27;-&#x27;: &amp;bsol;* handled by next item. */
1311      case &#x27;+&#x27;: moduleParseCallReply_SimpleString(reply); break;
1312      case &#x27;*&#x27;: moduleParseCallReply_Array(reply); break;
1313      }
1314  }
1315  void moduleParseCallReply_Int(RedisModuleCallReply *reply) {
1316      char *proto = reply-&gt;proto;
1317      char *p = strchr(proto+1,&#x27;\r&#x27;);
1318      string2ll(proto+1,p-proto-1,&amp;reply-&gt;val.ll);
1319      reply-&gt;protolen = p-proto+2;
1320      reply-&gt;type = REDISMODULE_REPLY_INTEGER;
1321  }
1322  void moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {
1323      char *proto = reply-&gt;proto;
1324      char *p = strchr(proto+1,&#x27;\r&#x27;);
1325      PORT_LONGLONG bulklen;
1326      string2ll(proto+1,p-proto-1,&amp;bulklen);
1327      if (bulklen == -1) {
1328          reply-&gt;protolen = p-proto+2;
1329          reply-&gt;type = REDISMODULE_REPLY_NULL;
1330      } else {
1331          reply-&gt;val.str = p+2;
1332          reply-&gt;len = bulklen;
1333          reply-&gt;protolen = p-proto+2+bulklen+2;
1334          reply-&gt;type = REDISMODULE_REPLY_STRING;
1335      }
1336  }
1337  void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {
1338      char *proto = reply-&gt;proto;
1339      char *p = strchr(proto+1,&#x27;\r&#x27;);
1340      reply-&gt;val.str = proto+1;
1341      reply-&gt;len = p-proto-1;
1342      reply-&gt;protolen = p-proto+2;
1343      reply-&gt;type = proto[0] == &#x27;+&#x27; ? REDISMODULE_REPLY_STRING :
1344                                      REDISMODULE_REPLY_ERROR;
1345  }
1346  void moduleParseCallReply_Array(RedisModuleCallReply *reply) {
1347      char *proto = reply-&gt;proto;
1348      char *p = strchr(proto+1,&#x27;\r&#x27;);
1349      PORT_LONGLONG arraylen, j;
1350      string2ll(proto+1,p-proto-1,&amp;arraylen);
1351      p += 2;
1352      if (arraylen == -1) {
1353          reply-&gt;protolen = p-proto;
1354          reply-&gt;type = REDISMODULE_REPLY_NULL;
1355          return;
1356      }
1357      reply-&gt;val.array = zmalloc(sizeof(RedisModuleCallReply)*arraylen);
1358      reply-&gt;len = arraylen;
1359      for (j = 0; j &lt; arraylen; j++) {
1360          RedisModuleCallReply *ele = reply-&gt;val.array+j;
1361          ele-&gt;flags = REDISMODULE_REPLYFLAG_NESTED |
1362                       REDISMODULE_REPLYFLAG_TOPARSE;
1363          ele-&gt;proto = p;
1364          ele-&gt;ctx = reply-&gt;ctx;
1365          moduleParseCallReply(ele);
1366          p += ele-&gt;protolen;
1367      }
1368      reply-&gt;protolen = p-proto;
1369      reply-&gt;type = REDISMODULE_REPLY_ARRAY;
1370  }
1371  void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){
1372      if (!freenested &amp;&amp; reply-&gt;flags &amp; REDISMODULE_REPLYFLAG_NESTED) return;
1373      if (!(reply-&gt;flags &amp; REDISMODULE_REPLYFLAG_TOPARSE)) {
1374          if (reply-&gt;type == REDISMODULE_REPLY_ARRAY) {
1375              size_t j;
1376              for (j = 0; j &lt; reply-&gt;len; j++)
1377                  RM_FreeCallReply_Rec(reply-&gt;val.array+j,1);
1378              zfree(reply-&gt;val.array);
1379          }
1380      }
1381      if (!(reply-&gt;flags &amp; REDISMODULE_REPLYFLAG_NESTED)) {
1382          if (reply-&gt;proto) sdsfree(reply-&gt;proto);
1383          zfree(reply);
1384      }
1385  }
1386  void RM_FreeCallReply(RedisModuleCallReply *reply) {
1387      RedisModuleCtx *ctx = reply-&gt;ctx;
1388      RM_FreeCallReply_Rec(reply,0);
1389      autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);
1390  }
1391  int RM_CallReplyType(RedisModuleCallReply *reply) {
1392      if (!reply) return REDISMODULE_REPLY_UNKNOWN;
1393      return reply-&gt;type;
1394  }
1395  size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
1396      moduleParseCallReply(reply);
1397      switch(reply-&gt;type) {
1398      case REDISMODULE_REPLY_STRING:
1399      case REDISMODULE_REPLY_ERROR:
1400      case REDISMODULE_REPLY_ARRAY:
1401          return reply-&gt;len;
1402      default:
1403          return 0;
1404      }
1405  }
1406  RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {
1407      moduleParseCallReply(reply);
1408      if (reply-&gt;type != REDISMODULE_REPLY_ARRAY) return NULL;
1409      if (idx &gt;= reply-&gt;len) return NULL;
1410      return reply-&gt;val.array+idx;
1411  }
1412  PORT_LONGLONG RM_CallReplyInteger(RedisModuleCallReply *reply) {
1413      moduleParseCallReply(reply);
1414      if (reply-&gt;type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;
1415      return reply-&gt;val.ll;
1416  }
1417  const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {
1418      moduleParseCallReply(reply);
1419      if (reply-&gt;type != REDISMODULE_REPLY_STRING &amp;&amp;
1420          reply-&gt;type != REDISMODULE_REPLY_ERROR) return NULL;
1421      if (len) *len = reply-&gt;len;
1422      return reply-&gt;val.str;
1423  }
1424  RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {
1425      moduleParseCallReply(reply);
1426      switch(reply-&gt;type) {
1427      case REDISMODULE_REPLY_STRING:
1428      case REDISMODULE_REPLY_ERROR:
1429          return RM_CreateString(reply-&gt;ctx,reply-&gt;val.str,reply-&gt;len);
1430      case REDISMODULE_REPLY_INTEGER: {
1431          char buf[64];
1432          int len = ll2string(buf,sizeof(buf),reply-&gt;val.ll);
1433          return RM_CreateString(reply-&gt;ctx,buf,len);
1434          }
1435      default: return NULL;
1436      }
1437  }
1438  robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {
1439      int argc = 0, argv_size, j;
1440      robj **argv = NULL;
1441      argv_size = strlen(fmt)+1; &amp;bsol;* +1 because of the command name. */
1442      argv = zrealloc(argv,sizeof(robj*)*argv_size);
1443      argv[0] = createStringObject(cmdname,strlen(cmdname));
1444      argc++;
1445      const char *p = fmt;
1446      while(*p) {
1447          if (*p == &#x27;c&#x27;) {
1448              char *cstr = va_arg(ap,char*);
1449              argv[argc++] = createStringObject(cstr,strlen(cstr));
1450          } else if (*p == &#x27;s&#x27;) {
1451              robj *obj = va_arg(ap,void*);
1452              argv[argc++] = obj;
1453              incrRefCount(obj);
1454          } else if (*p == &#x27;b&#x27;) {
1455              char *buf = va_arg(ap,char*);
1456              size_t len = va_arg(ap,size_t);
1457              argv[argc++] = createStringObject(buf,len);
1458          } else if (*p == &#x27;l&#x27;) {
1459              PORT_LONG ll = va_arg(ap,PORT_LONGLONG);
1460              argv[argc++] = createObject(OBJ_STRING,sdsfromlonglong(ll));
1461          } else if (*p == &#x27;v&#x27;) {
1462               robj **v = va_arg(ap, void*);
1463               size_t vlen = va_arg(ap, size_t);
1464               argv_size += vlen-1;
1465               argv = zrealloc(argv,sizeof(robj*)*argv_size);
1466               size_t i = 0;
1467               for (i = 0; i &lt; vlen; i++) {
1468                   incrRefCount(v[i]);
1469                   argv[argc++] = v[i];
1470               }
1471          } else if (*p == &#x27;!&#x27;) {
1472              if (flags) (*flags) |= REDISMODULE_ARGV_REPLICATE;
1473          } else if (*p == &#x27;A&#x27;) {
1474              if (flags) (*flags) |= REDISMODULE_ARGV_NO_AOF;
1475          } else if (*p == &#x27;R&#x27;) {
1476              if (flags) (*flags) |= REDISMODULE_ARGV_NO_REPLICAS;
1477          } else {
1478              goto fmterr;
1479          }
1480          p++;
1481      }
1482      *argcp = argc;
1483      return argv;
1484  fmterr:
1485      for (j = 0; j &lt; argc; j++)
1486          decrRefCount(argv[j]);
1487      zfree(argv);
1488      return NULL;
1489  }
1490  RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
1491      struct redisCommand *cmd;
1492      client *c = NULL;
1493      robj **argv = NULL;
1494      int argc = 0, flags = 0;
1495      va_list ap;
1496      RedisModuleCallReply *reply = NULL;
1497      int replicate = 0; &amp;bsol;* Replicate this command? */
1498      va_start(ap, fmt);
1499      c = createClient(-1);
1500      argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&amp;argc,&amp;flags,ap);
1501      replicate = flags &amp; REDISMODULE_ARGV_REPLICATE;
1502      va_end(ap);
1503      c-&gt;flags |= CLIENT_MODULE;
1504      c-&gt;db = ctx-&gt;client-&gt;db;
1505      c-&gt;argv = argv;
1506      c-&gt;argc = argc;
1507      if (ctx-&gt;module) ctx-&gt;module-&gt;in_call++;
1508      if (argv == NULL) goto cleanup;
1509      moduleCallCommandFilters(c);
1510      cmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);
1511      if (!cmd) {
1512          errno = EINVAL;
1513          goto cleanup;
1514      }
1515      c-&gt;cmd = c-&gt;lastcmd = cmd;
1516      if ((cmd-&gt;arity &gt; 0 &amp;&amp; cmd-&gt;arity != argc) || (argc &lt; -cmd-&gt;arity)) {
1517          errno = EINVAL;
1518          goto cleanup;
1519      }
1520      if (server.cluster_enabled &amp;&amp; !(ctx-&gt;client-&gt;flags &amp; CLIENT_MASTER)) {
1521          c-&gt;flags &amp;= ~(CLIENT_READONLY|CLIENT_ASKING);
1522          c-&gt;flags |= ctx-&gt;client-&gt;flags &amp; (CLIENT_READONLY|CLIENT_ASKING);
1523          if (getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,NULL,NULL) !=
1524                             server.cluster-&gt;myself)
1525          {
1526              errno = EPERM;
1527              goto cleanup;
1528          }
1529      }
1530      if (replicate) moduleReplicateMultiIfNeeded(ctx);
1531      int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;
1532      if (replicate) {
1533          if (!(flags &amp; REDISMODULE_ARGV_NO_AOF))
1534              call_flags |= CMD_CALL_PROPAGATE_AOF;
1535          if (!(flags &amp; REDISMODULE_ARGV_NO_REPLICAS))
1536              call_flags |= CMD_CALL_PROPAGATE_REPL;
1537      }
1538      call(c,call_flags);
1539      sds proto = sdsnewlen(c-&gt;buf,c-&gt;bufpos);
1540      c-&gt;bufpos = 0;
1541      while(listLength(c-&gt;reply)) {
1542          clientReplyBlock *o = listNodeValue(listFirst(c-&gt;reply));
1543          proto = sdscatlen(proto,o-&gt;buf,o-&gt;used);
1544          listDelNode(c-&gt;reply,listFirst(c-&gt;reply));
1545      }
1546      reply = moduleCreateCallReplyFromProto(ctx,proto);
1547      autoMemoryAdd(ctx,REDISMODULE_AM_REPLY,reply);
1548  cleanup:
1549      if (ctx-&gt;module) ctx-&gt;module-&gt;in_call--;
1550      freeClient(c);
1551      return reply;
1552  }
1553  const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {
1554      if (reply-&gt;proto) *len = sdslen(reply-&gt;proto);
1555      return reply-&gt;proto;
1556  }
1557  const char *ModuleTypeNameCharSet =
1558               &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
1559               &quot;abcdefghijklmnopqrstuvwxyz&quot;
1560               &quot;0123456789-_&quot;;
1561  uint64_t moduleTypeEncodeId(const char *name, int encver) {
1562      const char *cset = ModuleTypeNameCharSet;
1563      if (strlen(name) != 9) return 0;
1564      if (encver &lt; 0 || encver &gt; 1023) return 0;
1565      uint64_t id = 0;
1566      for (int j = 0; j &lt; 9; j++) {
1567          char *p = strchr(cset,name[j]);
1568          if (!p) return 0;
1569          PORT_ULONG pos = p-cset;
1570          id = (id &lt;&lt; 6) | pos;
1571      }
1572      id = (id &lt;&lt; 10) | encver;
1573      return id;
1574  }
1575  moduleType *moduleTypeLookupModuleByName(const char *name) {
1576      dictIterator *di = dictGetIterator(modules);
1577      dictEntry *de;
1578      while ((de = dictNext(di)) != NULL) {
1579          struct RedisModule *module = dictGetVal(de);
1580          listIter li;
1581          listNode *ln;
1582          listRewind(module-&gt;types,&amp;li);
1583          while((ln = listNext(&amp;li))) {
1584              moduleType *mt = ln-&gt;value;
1585              if (memcmp(name,mt-&gt;name,sizeof(mt-&gt;name)) == 0) {
1586                  dictReleaseIterator(di);
1587                  return mt;
1588              }
1589          }
1590      }
1591      dictReleaseIterator(di);
1592      return NULL;
1593  }
1594  #define MODULE_LOOKUP_CACHE_SIZE 3
1595  moduleType *moduleTypeLookupModuleByID(uint64_t id) {
1596      static struct {
1597          uint64_t id;
1598          moduleType *mt;
1599      } cache[MODULE_LOOKUP_CACHE_SIZE];
1600      int j;
1601      for (j = 0; j &lt; MODULE_LOOKUP_CACHE_SIZE &amp;&amp; cache[j].mt != NULL; j++)
1602          if (cache[j].id == id) return cache[j].mt;
1603      moduleType *mt = NULL;
1604      dictIterator *di = dictGetIterator(modules);
1605      dictEntry *de;
1606      while ((de = dictNext(di)) != NULL &amp;&amp; mt == NULL) {
1607          struct RedisModule *module = dictGetVal(de);
1608          listIter li;
1609          listNode *ln;
1610          listRewind(module-&gt;types,&amp;li);
1611          while((ln = listNext(&amp;li))) {
1612              moduleType *this_mt = ln-&gt;value;
1613              if (this_mt-&gt;id &gt;&gt; 10 == id &gt;&gt; 10) {
1614                  mt = this_mt;
1615                  break;
1616              }
1617          }
1618      }
1619      dictReleaseIterator(di);
1620      if (mt &amp;&amp; j &lt; MODULE_LOOKUP_CACHE_SIZE) {
1621          cache[j].id = id;
1622          cache[j].mt = mt;
1623      }
1624      return mt;
1625  }
1626  void moduleTypeNameByID(char *name, uint64_t moduleid) {
1627      const char *cset = ModuleTypeNameCharSet;
1628      name[9] = &#x27;\0&#x27;;
1629      char *p = name+8;
1630      moduleid &gt;&gt;= 10;
1631      for (int j = 0; j &lt; 9; j++) {
1632          *p-- = cset[moduleid &amp; 63];
1633          moduleid &gt;&gt;= 6;
1634      }
1635  }
1636  moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {
1637      uint64_t id = moduleTypeEncodeId(name,encver);
1638      if (id == 0) return NULL;
1639      if (moduleTypeLookupModuleByName(name) != NULL) return NULL;
1640      PORT_LONG typemethods_version = ((PORT_LONG*)typemethods_ptr)[0];
1641      if (typemethods_version == 0) return NULL;
1642      struct typemethods {
1643          uint64_t version;
1644          moduleTypeLoadFunc rdb_load;
1645          moduleTypeSaveFunc rdb_save;
1646          moduleTypeRewriteFunc aof_rewrite;
1647          moduleTypeMemUsageFunc mem_usage;
1648          moduleTypeDigestFunc digest;
1649          moduleTypeFreeFunc free;
1650          struct {
1651              moduleTypeAuxLoadFunc aux_load;
1652              moduleTypeAuxSaveFunc aux_save;
1653              int aux_save_triggers;
1654          } v2;
1655      } *tms = (struct typemethods*) typemethods_ptr;
1656      moduleType *mt = zcalloc(sizeof(*mt));
1657      mt-&gt;id = id;
1658      mt-&gt;module = ctx-&gt;module;
1659      mt-&gt;rdb_load = tms-&gt;rdb_load;
1660      mt-&gt;rdb_save = tms-&gt;rdb_save;
1661      mt-&gt;aof_rewrite = tms-&gt;aof_rewrite;
1662      mt-&gt;mem_usage = tms-&gt;mem_usage;
1663      mt-&gt;digest = tms-&gt;digest;
1664      mt-&gt;free = tms-&gt;free;
1665      if (tms-&gt;version &gt;= 2) {
1666          mt-&gt;aux_load = tms-&gt;v2.aux_load;
1667          mt-&gt;aux_save = tms-&gt;v2.aux_save;
1668          mt-&gt;aux_save_triggers = tms-&gt;v2.aux_save_triggers;
1669      }
1670      memcpy(mt-&gt;name,name,sizeof(mt-&gt;name));
1671      listAddNodeTail(ctx-&gt;module-&gt;types,mt);
1672      return mt;
1673  }
1674  int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
1675      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;iter) return REDISMODULE_ERR;
1676      RM_DeleteKey(key);
1677      robj *o = createModuleObject(mt,value);
1678      setKey(key-&gt;db,key-&gt;key,o);
1679      decrRefCount(o);
1680      key-&gt;value = o;
1681      return REDISMODULE_OK;
1682  }
1683  moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
1684      if (key == NULL ||
1685          key-&gt;value == NULL ||
1686          RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
1687      moduleValue *mv = key-&gt;value-&gt;ptr;
1688      return mv-&gt;type;
1689  }
1690  void *RM_ModuleTypeGetValue(RedisModuleKey *key) {
1691      if (key == NULL ||
1692          key-&gt;value == NULL ||
1693          RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
1694      moduleValue *mv = key-&gt;value-&gt;ptr;
1695      return mv-&gt;value;
1696  }
1697  void moduleRDBLoadError(RedisModuleIO *io) {
1698      serverLog(LL_WARNING,
1699          &quot;Error loading data from RDB (short read or EOF). &quot;
1700          &quot;Read performed by module &#x27;%s&#x27; about type &#x27;%s&#x27; &quot;
1701          &quot;after reading &#x27;%llu&#x27; bytes of a value.&quot;,
1702          io-&gt;type-&gt;module-&gt;name,
1703          io-&gt;type-&gt;name,
1704          (PORT_ULONGLONG)io-&gt;bytes);
1705      exit(1);
1706  }
1707  void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
1708      if (io-&gt;error) return;
1709      int retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_UINT);
1710      if (retval == -1) goto saveerr;
1711      io-&gt;bytes += retval;
1712      retval = rdbSaveLen(io-&gt;rio, value);
1713      if (retval == -1) goto saveerr;
1714      io-&gt;bytes += retval;
1715      return;
1716  saveerr:
1717      io-&gt;error = 1;
1718  }
1719  uint64_t RM_LoadUnsigned(RedisModuleIO *io) {
1720      if (io-&gt;ver == 2) {
1721          uint64_t opcode = rdbLoadLen(io-&gt;rio,NULL);
1722          if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;
1723      }
1724      uint64_t value;
1725      int retval = rdbLoadLenByRef(io-&gt;rio, NULL, &amp;value);
1726      if (retval == -1) goto loaderr;
1727      return value;
1728  loaderr:
1729      moduleRDBLoadError(io);
1730      return 0; &amp;bsol;* Never reached. */
1731  }
1732  void RM_SaveSigned(RedisModuleIO *io, int64_t value) {
1733      union {uint64_t u; int64_t i;} conv;
1734      conv.i = value;
1735      RM_SaveUnsigned(io,conv.u);
1736  }
1737  int64_t RM_LoadSigned(RedisModuleIO *io) {
1738      union {uint64_t u; int64_t i;} conv;
1739      conv.u = RM_LoadUnsigned(io);
1740      return conv.i;
1741  }
1742  void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
1743      if (io-&gt;error) return;
1744      ssize_t retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_STRING);
1745      if (retval == -1) goto saveerr;
1746      io-&gt;bytes += retval;
1747      retval = rdbSaveStringObject(io-&gt;rio, s);
1748      if (retval == -1) goto saveerr;
1749      io-&gt;bytes += retval;
1750      return;
1751  saveerr:
1752      io-&gt;error = 1;
1753  }
1754  void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
1755      if (io-&gt;error) return;
1756      ssize_t retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_STRING);
1757      if (retval == -1) goto saveerr;
1758      io-&gt;bytes += retval;
1759      retval = rdbSaveRawString(io-&gt;rio, (unsigned char*)str,len);
1760      if (retval == -1) goto saveerr;
1761      io-&gt;bytes += retval;
1762      return;
1763  saveerr:
1764      io-&gt;error = 1;
1765  }
1766  void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {
1767      if (io-&gt;ver == 2) {
1768          uint64_t opcode = rdbLoadLen(io-&gt;rio,NULL);
1769          if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;
1770      }
1771      void *s = rdbGenericLoadStringObject(io-&gt;rio,
1772                plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);
1773      if (s == NULL) goto loaderr;
1774      return s;
1775  loaderr:
1776      moduleRDBLoadError(io);
1777      return NULL; &amp;bsol;* Never reached. */
1778  }
1779  RedisModuleString *RM_LoadString(RedisModuleIO *io) {
1780      return moduleLoadString(io,0,NULL);
1781  }
1782  char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
1783      return moduleLoadString(io,1,lenptr);
1784  }
1785  void RM_SaveDouble(RedisModuleIO *io, double value) {
1786      if (io-&gt;error) return;
1787      int retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_DOUBLE);
1788      if (retval == -1) goto saveerr;
1789      io-&gt;bytes += retval;
1790      retval = rdbSaveBinaryDoubleValue(io-&gt;rio, value);
1791      if (retval == -1) goto saveerr;
1792      io-&gt;bytes += retval;
1793      return;
1794  saveerr:
1795      io-&gt;error = 1;
1796  }
1797  double RM_LoadDouble(RedisModuleIO *io) {
1798      if (io-&gt;ver == 2) {
1799          uint64_t opcode = rdbLoadLen(io-&gt;rio,NULL);
1800          if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;
1801      }
1802      double value;
1803      int retval = rdbLoadBinaryDoubleValue(io-&gt;rio, &amp;value);
1804      if (retval == -1) goto loaderr;
1805      return value;
1806  loaderr:
1807      moduleRDBLoadError(io);
1808      return 0; &amp;bsol;* Never reached. */
1809  }
1810  void RM_SaveFloat(RedisModuleIO *io, float value) {
1811      if (io-&gt;error) return;
1812      int retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_FLOAT);
1813      if (retval == -1) goto saveerr;
1814      io-&gt;bytes += retval;
1815      retval = rdbSaveBinaryFloatValue(io-&gt;rio, value);
1816      if (retval == -1) goto saveerr;
1817      io-&gt;bytes += retval;
1818      return;
1819  saveerr:
1820      io-&gt;error = 1;
1821  }
1822  float RM_LoadFloat(RedisModuleIO *io) {
1823      if (io-&gt;ver == 2) {
1824          uint64_t opcode = rdbLoadLen(io-&gt;rio,NULL);
1825          if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;
1826      }
1827      float value;
1828      int retval = rdbLoadBinaryFloatValue(io-&gt;rio, &amp;value);
1829      if (retval == -1) goto loaderr;
1830      return value;
1831  loaderr:
1832      moduleRDBLoadError(io);
1833      return 0; &amp;bsol;* Never reached. */
1834  }
1835  ssize_t rdbSaveModulesAux(rio *rdb, int when) {
1836      size_t total_written = 0;
1837      dictIterator *di = dictGetIterator(modules);
1838      dictEntry *de;
1839      while ((de = dictNext(di)) != NULL) {
1840          struct RedisModule *module = dictGetVal(de);
1841          listIter li;
1842          listNode *ln;
1843          listRewind(module-&gt;types,&amp;li);
1844          while((ln = listNext(&amp;li))) {
1845              moduleType *mt = ln-&gt;value;
1846              if (!mt-&gt;aux_save || !(mt-&gt;aux_save_triggers &amp; when))
1847                  continue;
1848              ssize_t ret = rdbSaveSingleModuleAux(rdb, when, mt);
1849              if (ret==-1) {
1850                  dictReleaseIterator(di);
1851                  return -1;
1852              }
1853              total_written += ret;
1854          }
1855      }
1856      dictReleaseIterator(di);
1857      return total_written;
1858  }
1859  void RM_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len) {
1860      mixDigest(md-&gt;o,ele,len);
1861  }
1862  void RM_DigestAddLongLong(RedisModuleDigest *md, PORT_LONGLONG ll) {
1863      char buf[LONG_STR_SIZE];
1864      size_t len = ll2string(buf,sizeof(buf),ll);
1865      mixDigest(md-&gt;o,buf,len);
1866  }
1867  void RM_DigestEndSequence(RedisModuleDigest *md) {
1868      xorDigest(md-&gt;x,md-&gt;o,sizeof(md-&gt;o));
1869      memset(md-&gt;o,0,sizeof(md-&gt;o));
1870  }
1871  void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
1872      if (io-&gt;error) return;
1873      struct redisCommand *cmd;
1874      robj **argv = NULL;
1875      int argc = 0, flags = 0, j;
1876      va_list ap;
1877      cmd = lookupCommandByCString((char*)cmdname);
1878      if (!cmd) {
1879          serverLog(LL_WARNING,
1880              &quot;Fatal: AOF method for module data type &#x27;%s&#x27; tried to &quot;
1881              &quot;emit unknown command &#x27;%s&#x27;&quot;,
1882              io-&gt;type-&gt;name, cmdname);
1883          io-&gt;error = 1;
1884          errno = EINVAL;
1885          return;
1886      }
1887      va_start(ap, fmt);
1888      argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&amp;argc,&amp;flags,ap);
1889      va_end(ap);
1890      if (argv == NULL) {
1891          serverLog(LL_WARNING,
1892              &quot;Fatal: AOF method for module data type &#x27;%s&#x27; tried to &quot;
1893              &quot;call RedisModule_EmitAOF() with wrong format specifiers &#x27;%s&#x27;&quot;,
1894              io-&gt;type-&gt;name, fmt);
1895          io-&gt;error = 1;
1896          errno = EINVAL;
1897          return;
1898      }
1899      if (!io-&gt;error &amp;&amp; rioWriteBulkCount(io-&gt;rio,&#x27;*&#x27;,argc) == 0)
1900          io-&gt;error = 1;
1901      for (j = 0; j &lt; argc; j++) {
1902          if (!io-&gt;error &amp;&amp; rioWriteBulkObject(io-&gt;rio,argv[j]) == 0)
1903              io-&gt;error = 1;
1904          decrRefCount(argv[j]);
1905      }
1906      zfree(argv);
1907      return;
1908  }
1909  RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
1910      if (io-&gt;ctx) return io-&gt;ctx; &amp;bsol;* Can&#x27;t have more than one... */
1911      RedisModuleCtx ctxtemplate = REDISMODULE_CTX_INIT;
1912      io-&gt;ctx = zmalloc(sizeof(RedisModuleCtx));
1913      *(io-&gt;ctx) = ctxtemplate;
1914      io-&gt;ctx-&gt;module = io-&gt;type-&gt;module;
1915      io-&gt;ctx-&gt;client = NULL;
1916      return io-&gt;ctx;
1917  }
1918  const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {
1919      return io-&gt;key;
1920  }
1921  void RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {
1922      char msg[LOG_MAX_LEN];
1923      size_t name_len;
1924      int level;
1925      if (!strcasecmp(levelstr,&quot;debug&quot;)) level = LL_DEBUG;
1926      else if (!strcasecmp(levelstr,&quot;verbose&quot;)) level = LL_VERBOSE;
1927      else if (!strcasecmp(levelstr,&quot;notice&quot;)) level = LL_NOTICE;
1928      else if (!strcasecmp(levelstr,&quot;warning&quot;)) level = LL_WARNING;
1929      else level = LL_VERBOSE; &amp;bsol;* Default. */
1930      if (level &lt; server.verbosity) return;
1931      name_len = snprintf(msg, sizeof(msg),&quot;&lt;%s&gt; &quot;, module? module-&gt;name: &quot;module&quot;);
1932      vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);
1933      serverLogRaw(level,msg);
1934  }
1935  void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {
1936      va_list ap;
1937      va_start(ap, fmt);
1938      RM_LogRaw(ctx? ctx-&gt;module: NULL,levelstr,fmt,ap);
1939      va_end(ap);
1940  }
1941  void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {
1942      va_list ap;
1943      va_start(ap, fmt);
1944      RM_LogRaw(io-&gt;type-&gt;module,levelstr,fmt,ap);
1945      va_end(ap);
1946  }
1947  void moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
1948      UNUSED(el);
1949      UNUSED(fd);
1950      UNUSED(mask);
1951      UNUSED(privdata);
1952  }
1953  void unblockClientFromModule(client *c) {
1954      RedisModuleBlockedClient *bc = c-&gt;bpop.module_blocked_handle;
1955      if (bc-&gt;disconnect_callback) {
1956          RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
1957          ctx.blocked_privdata = bc-&gt;privdata;
1958          ctx.module = bc-&gt;module;
1959          ctx.client = bc-&gt;client;
1960          bc-&gt;disconnect_callback(&amp;ctx,bc);
1961          moduleFreeContext(&amp;ctx);
1962      }
1963      bc-&gt;client = NULL;
1964      resetClient(c);
1965  }
1966  RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), PORT_LONGLONG timeout_ms) {
1967      client *c = ctx-&gt;client;
1968      int islua = c-&gt;flags &amp; CLIENT_LUA;
1969      int ismulti = c-&gt;flags &amp; CLIENT_MULTI;
1970      c-&gt;bpop.module_blocked_handle = zmalloc(sizeof(RedisModuleBlockedClient));
1971      RedisModuleBlockedClient *bc = c-&gt;bpop.module_blocked_handle;
1972      bc-&gt;client = (islua || ismulti) ? NULL : c;
1973      bc-&gt;module = ctx-&gt;module;
1974      bc-&gt;reply_callback = reply_callback;
1975      bc-&gt;timeout_callback = timeout_callback;
1976      bc-&gt;disconnect_callback = NULL; &amp;bsol;* Set by RM_SetDisconnectCallback() */
1977      bc-&gt;free_privdata = free_privdata;
1978      bc-&gt;privdata = NULL;
1979      bc-&gt;reply_client = createClient(-1);
1980      bc-&gt;reply_client-&gt;flags |= CLIENT_MODULE;
1981      bc-&gt;dbid = c-&gt;db-&gt;id;
1982      c-&gt;bpop.timeout = timeout_ms ? (mstime()+timeout_ms) : 0;
1983      if (islua || ismulti) {
1984          c-&gt;bpop.module_blocked_handle = NULL;
1985          addReplyError(c, islua ?
1986              &quot;Blocking module command called from Lua script&quot; :
1987              &quot;Blocking module command called from transaction&quot;);
1988      } else {
1989          blockClient(c,BLOCKED_MODULE);
1990      }
1991      return bc;
1992  }
1993  int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
1994      pthread_mutex_lock(&amp;moduleUnblockedClientsMutex);
1995      bc-&gt;privdata = privdata;
1996      listAddNodeTail(moduleUnblockedClients,bc);
1997      if (write(server.module_blocked_pipe[1],&quot;A&quot;,1) != 1) {
1998      }
1999      pthread_mutex_unlock(&amp;moduleUnblockedClientsMutex);
2000      return REDISMODULE_OK;
2001  }
2002  int RM_AbortBlock(RedisModuleBlockedClient *bc) {
2003      bc-&gt;reply_callback = NULL;
2004      bc-&gt;disconnect_callback = NULL;
2005      return RM_UnblockClient(bc,NULL);
2006  }
2007  void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {
2008      bc-&gt;disconnect_callback = callback;
2009  }
2010  void moduleHandleBlockedClients(void) {
2011      listNode *ln;
2012      RedisModuleBlockedClient *bc;
2013      pthread_mutex_lock(&amp;moduleUnblockedClientsMutex);
2014      char buf[1];
2015      while (read(server.module_blocked_pipe[0],buf,1) == 1);
2016      while (listLength(moduleUnblockedClients)) {
2017          ln = listFirst(moduleUnblockedClients);
2018          bc = ln-&gt;value;
2019          client *c = bc-&gt;client;
2020          listDelNode(moduleUnblockedClients,ln);
2021          pthread_mutex_unlock(&amp;moduleUnblockedClientsMutex);
2022          if (c &amp;&amp; bc-&gt;reply_callback) {
2023              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2024              ctx.flags |= REDISMODULE_CTX_BLOCKED_REPLY;
2025              ctx.blocked_privdata = bc-&gt;privdata;
2026              ctx.module = bc-&gt;module;
2027              ctx.client = bc-&gt;client;
2028              ctx.blocked_client = bc;
2029              bc-&gt;reply_callback(&amp;ctx,(void**)c-&gt;argv,c-&gt;argc);
2030              moduleFreeContext(&amp;ctx);
2031          }
2032          if (bc-&gt;privdata &amp;&amp; bc-&gt;free_privdata) {
2033              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2034              if (c == NULL)
2035                  ctx.flags |= REDISMODULE_CTX_BLOCKED_DISCONNECTED;
2036              ctx.blocked_privdata = bc-&gt;privdata;
2037              ctx.module = bc-&gt;module;
2038              ctx.client = bc-&gt;client;
2039              bc-&gt;free_privdata(&amp;ctx,bc-&gt;privdata);
2040              moduleFreeContext(&amp;ctx);
2041          }
2042          if (c) AddReplyFromClient(c, bc-&gt;reply_client);
2043          freeClient(bc-&gt;reply_client);
2044          if (c != NULL) {
2045              bc-&gt;disconnect_callback = NULL;
2046              unblockClient(c);
2047              if (clientHasPendingReplies(c) &amp;&amp;
2048                  !(c-&gt;flags &amp; CLIENT_PENDING_WRITE))
2049              {
2050                  c-&gt;flags |= CLIENT_PENDING_WRITE;
2051                  listAddNodeHead(server.clients_pending_write,c);
2052              }
2053          }
2054          zfree(bc);
2055          pthread_mutex_lock(&amp;moduleUnblockedClientsMutex);
2056      }
2057      pthread_mutex_unlock(&amp;moduleUnblockedClientsMutex);
2058  }
2059  void moduleBlockedClientTimedOut(client *c) {
2060      RedisModuleBlockedClient *bc = c-&gt;bpop.module_blocked_handle;
2061      RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2062      ctx.flags |= REDISMODULE_CTX_BLOCKED_TIMEOUT;
2063      ctx.module = bc-&gt;module;
2064      ctx.client = bc-&gt;client;
2065      ctx.blocked_client = bc;
2066      bc-&gt;timeout_callback(&amp;ctx,(void**)c-&gt;argv,c-&gt;argc);
2067      moduleFreeContext(&amp;ctx);
2068      bc-&gt;disconnect_callback = NULL;
2069  }
2070  int RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {
2071      return (ctx-&gt;flags &amp; REDISMODULE_CTX_BLOCKED_REPLY) != 0;
2072  }
2073  int RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {
2074      return (ctx-&gt;flags &amp; REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;
2075  }
2076  void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
2077      return ctx-&gt;blocked_privdata;
2078  }
2079  RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
2080      return ctx-&gt;blocked_client;
2081  }
2082  int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {
2083      return (ctx-&gt;flags &amp; REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;
2084  }
2085  RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
2086      RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));
2087      RedisModuleCtx empty = REDISMODULE_CTX_INIT;
2088      memcpy(ctx,&amp;empty,sizeof(empty));
2089      if (bc) {
2090          ctx-&gt;blocked_client = bc;
2091          ctx-&gt;module = bc-&gt;module;
2092      }
2093      ctx-&gt;flags |= REDISMODULE_CTX_THREAD_SAFE;
2094      ctx-&gt;client = createClient(-1);
2095      if (bc) {
2096          selectDb(ctx-&gt;client,bc-&gt;dbid);
2097          if (bc-&gt;client) ctx-&gt;client-&gt;id = bc-&gt;client-&gt;id;
2098      }
2099      return ctx;
2100  }
2101  void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {
2102      moduleFreeContext(ctx);
2103      zfree(ctx);
2104  }
2105  void RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {
2106      UNUSED(ctx);
2107      moduleAcquireGIL();
2108  }
2109  void RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {
2110      UNUSED(ctx);
2111      moduleReleaseGIL();
2112  }
2113  void moduleAcquireGIL(void) {
2114      pthread_mutex_lock(&amp;moduleGIL);
2115  }
2116  void moduleReleaseGIL(void) {
2117      pthread_mutex_unlock(&amp;moduleGIL);
2118  }
2119  int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {
2120      RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));
2121      sub-&gt;module = ctx-&gt;module;
2122      sub-&gt;event_mask = types;
2123      sub-&gt;notify_callback = callback;
2124      sub-&gt;active = 0;
2125      listAddNodeTail(moduleKeyspaceSubscribers, sub);
2126      return REDISMODULE_OK;
2127  }
2128  void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {
2129      if (listLength(moduleKeyspaceSubscribers) == 0) return;
2130      listIter li;
2131      listNode *ln;
2132      listRewind(moduleKeyspaceSubscribers,&amp;li);
2133      type &amp;= ~(NOTIFY_KEYEVENT | NOTIFY_KEYSPACE);
2134      while((ln = listNext(&amp;li))) {
2135          RedisModuleKeyspaceSubscriber *sub = ln-&gt;value;
2136          if ((sub-&gt;event_mask &amp; type) &amp;&amp; sub-&gt;active == 0) {
2137              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2138              ctx.module = sub-&gt;module;
2139              ctx.client = moduleFreeContextReusedClient;
2140              selectDb(ctx.client, dbid);
2141              sub-&gt;active = 1;
2142              sub-&gt;notify_callback(&amp;ctx, type, event, key);
2143              sub-&gt;active = 0;
2144              moduleFreeContext(&amp;ctx);
2145          }
2146      }
2147  }
2148  void moduleUnsubscribeNotifications(RedisModule *module) {
2149      listIter li;
2150      listNode *ln;
2151      listRewind(moduleKeyspaceSubscribers,&amp;li);
2152      while((ln = listNext(&amp;li))) {
2153          RedisModuleKeyspaceSubscriber *sub = ln-&gt;value;
2154          if (sub-&gt;module == module) {
2155              listDelNode(moduleKeyspaceSubscribers, ln);
2156              zfree(sub);
2157          }
2158      }
2159  }
2160  typedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);
2161  typedef struct moduleClusterReceiver {
2162      uint64_t module_id;
2163      RedisModuleClusterMessageReceiver callback;
2164      struct RedisModule *module;
2165      struct moduleClusterReceiver *next;
2166  } moduleClusterReceiver;
2167  typedef struct moduleClusterNodeInfo {
2168      int flags;
2169      char ip[NET_IP_STR_LEN];
2170      int port;
2171      char master_id[40]; &amp;bsol;* Only if flags &amp; REDISMODULE_NODE_MASTER is true. */
2172  } mdouleClusterNodeInfo;
2173  static moduleClusterReceiver *clusterReceivers[UINT8_MAX];
2174  void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len) {
2175      moduleClusterReceiver *r = clusterReceivers[type];
2176      while(r) {
2177          if (r-&gt;module_id == module_id) {
2178              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2179              ctx.module = r-&gt;module;
2180              ctx.client = moduleFreeContextReusedClient;
2181              selectDb(ctx.client, 0);
2182              r-&gt;callback(&amp;ctx,sender_id,type,payload,len);
2183              moduleFreeContext(&amp;ctx);
2184              return;
2185          }
2186          r = r-&gt;next;
2187      }
2188  }
2189  void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {
2190      if (!server.cluster_enabled) return;
2191      uint64_t module_id = moduleTypeEncodeId(ctx-&gt;module-&gt;name,0);
2192      moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;
2193      while(r) {
2194          if (r-&gt;module_id == module_id) {
2195              if (callback) {
2196                  r-&gt;callback = callback;
2197              } else {
2198                  if (prev)
2199                      prev-&gt;next = r-&gt;next;
2200                  else
2201                      clusterReceivers[type]-&gt;next = r-&gt;next;
2202                  zfree(r);
2203              }
2204              return;
2205          }
2206          prev = r;
2207          r = r-&gt;next;
2208      }
2209      if (callback) {
2210          r = zmalloc(sizeof(*r));
2211          r-&gt;module_id = module_id;
2212          r-&gt;module = ctx-&gt;module;
2213          r-&gt;callback = callback;
2214          r-&gt;next = clusterReceivers[type];
2215          clusterReceivers[type] = r;
2216      }
2217  }
2218  int RM_SendClusterMessage(RedisModuleCtx *ctx, char *target_id, uint8_t type, unsigned char *msg, uint32_t len) {
2219      if (!server.cluster_enabled) return REDISMODULE_ERR;
2220      uint64_t module_id = moduleTypeEncodeId(ctx-&gt;module-&gt;name,0);
2221      if (clusterSendModuleMessageToTarget(target_id,module_id,type,msg,len) == C_OK)
2222          return REDISMODULE_OK;
2223      else
2224          return REDISMODULE_ERR;
2225  }
2226  char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
2227      UNUSED(ctx);
2228      if (!server.cluster_enabled) return NULL;
2229      size_t count = dictSize(server.cluster-&gt;nodes);
2230      char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);
2231      dictIterator *di = dictGetIterator(server.cluster-&gt;nodes);
2232      dictEntry *de;
2233      int j = 0;
2234      while((de = dictNext(di)) != NULL) {
2235          clusterNode *node = dictGetVal(de);
2236          if (node-&gt;flags &amp; (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) continue;
2237          ids[j] = zmalloc(REDISMODULE_NODE_ID_LEN);
2238          memcpy(ids[j],node-&gt;name,REDISMODULE_NODE_ID_LEN);
2239          j++;
2240      }
2241      *numnodes = j;
2242      ids[j] = NULL; &amp;bsol;* Null term so that FreeClusterNodesList does not need
2243                      * to also get the count argument. */
2244      dictReleaseIterator(di);
2245      return ids;
2246  }
2247  void RM_FreeClusterNodesList(char **ids) {
2248      if (ids == NULL) return;
2249      for (int j = 0; ids[j]; j++) zfree(ids[j]);
2250      zfree(ids);
2251  }
2252  const char *RM_GetMyClusterID(void) {
2253      if (!server.cluster_enabled) return NULL;
2254      return server.cluster-&gt;myself-&gt;name;
2255  }
2256  size_t RM_GetClusterSize(void) {
2257      if (!server.cluster_enabled) return 0;
2258      return dictSize(server.cluster-&gt;nodes);
2259  }
2260  clusterNode *clusterLookupNode(const char *name); &amp;bsol;* We need access to internals */
2261  int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {
2262      UNUSED(ctx);
2263      clusterNode *node = clusterLookupNode(id);
2264      if (node == NULL ||
2265          node-&gt;flags &amp; (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
2266      {
2267          return REDISMODULE_ERR;
2268      }
2269      if (ip) strncpy(ip,node-&gt;ip,NET_IP_STR_LEN);
2270      if (master_id) {
2271          if (node-&gt;flags &amp; CLUSTER_NODE_MASTER &amp;&amp; node-&gt;slaveof)
2272              memcpy(master_id,node-&gt;slaveof-&gt;name,REDISMODULE_NODE_ID_LEN);
2273          else
2274              memset(master_id,0,REDISMODULE_NODE_ID_LEN);
2275      }
2276      if (port) *port = node-&gt;port;
2277      if (flags) {
2278          *flags = 0;
2279          if (node-&gt;flags &amp; CLUSTER_NODE_MYSELF) *flags |= REDISMODULE_NODE_MYSELF;
2280          if (node-&gt;flags &amp; CLUSTER_NODE_MASTER) *flags |= REDISMODULE_NODE_MASTER;
2281          if (node-&gt;flags &amp; CLUSTER_NODE_SLAVE) *flags |= REDISMODULE_NODE_SLAVE;
2282          if (node-&gt;flags &amp; CLUSTER_NODE_PFAIL) *flags |= REDISMODULE_NODE_PFAIL;
2283          if (node-&gt;flags &amp; CLUSTER_NODE_FAIL) *flags |= REDISMODULE_NODE_FAIL;
2284          if (node-&gt;flags &amp; CLUSTER_NODE_NOFAILOVER) *flags |= REDISMODULE_NODE_NOFAILOVER;
2285      }
2286      return REDISMODULE_OK;
2287  }
2288  void RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {
2289      UNUSED(ctx);
2290      if (flags &amp; REDISMODULE_CLUSTER_FLAG_NO_FAILOVER)
2291          server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_FAILOVER;
2292      if (flags &amp; REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION)
2293          server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_REDIRECTION;
2294  }
2295  static rax *Timers;     &amp;bsol;* The radix tree of all the timers sorted by expire. */
2296  PORT_LONGLONG aeTimer = -1; &amp;bsol;* Main event loop (ae.c) timer identifier. */
2297  typedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);
2298  typedef struct RedisModuleTimer {
2299      RedisModule *module;                &amp;bsol;* Module reference. */
2300      RedisModuleTimerProc callback;      &amp;bsol;* The callback to invoke on expire. */
2301      void *data;                         &amp;bsol;* Private data for the callback. */
2302      int dbid;                           &amp;bsol;* Database number selected by the original client. */
2303  } RedisModuleTimer;
2304  int moduleTimerHandler(struct aeEventLoop *eventLoop, PORT_LONGLONG id, void *clientData) {
2305      UNUSED(eventLoop);
2306      UNUSED(id);
2307      UNUSED(clientData);
2308      raxIterator ri;
2309      raxStart(&amp;ri,Timers);
2310      uint64_t now = ustime();
2311      PORT_LONGLONG next_period = 0;
2312      while(1) {
2313          raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
2314          if (!raxNext(&amp;ri)) break;
2315          uint64_t expiretime;
2316          memcpy(&amp;expiretime,ri.key,sizeof(expiretime));
2317          expiretime = ntohu64(expiretime);
2318          if (now &gt;= expiretime) {
2319              RedisModuleTimer *timer = ri.data;
2320              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2321              ctx.module = timer-&gt;module;
2322              ctx.client = moduleFreeContextReusedClient;
2323              selectDb(ctx.client, timer-&gt;dbid);
2324              timer-&gt;callback(&amp;ctx,timer-&gt;data);
2325              moduleFreeContext(&amp;ctx);
2326              raxRemove(Timers,(unsigned char*)ri.key,ri.key_len,NULL);
2327              zfree(timer);
2328          } else {
2329              next_period = (expiretime-now)/1000; &amp;bsol;* Scale to milliseconds. */
2330              break;
2331          }
2332      }
2333      raxStop(&amp;ri);
2334      if (next_period &lt;= 0) next_period = 1;
2335      return (raxSize(Timers) &gt; 0) ? next_period : AE_NOMORE;
2336  }
2337  RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {
2338      RedisModuleTimer *timer = zmalloc(sizeof(*timer));
2339      timer-&gt;module = ctx-&gt;module;
2340      timer-&gt;callback = callback;
2341      timer-&gt;data = data;
2342      timer-&gt;dbid = ctx-&gt;client-&gt;db-&gt;id;
2343      uint64_t expiretime = ustime()+period*1000;
2344      uint64_t key;
2345      while(1) {
2346          key = htonu64(expiretime);
2347          if (raxFind(Timers, (unsigned char*)&amp;key,sizeof(key)) == raxNotFound) {
2348              raxInsert(Timers,(unsigned char*)&amp;key,sizeof(key),timer,NULL);
2349              break;
2350          } else {
2351              expiretime++;
2352          }
2353      }
2354      if (aeTimer != -1) {
2355          raxIterator ri;
2356          raxStart(&amp;ri,Timers);
2357          raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
2358          raxNext(&amp;ri);
2359          if (memcmp(ri.key,&amp;key,sizeof(key)) == 0) {
2360              aeDeleteTimeEvent(server.el,aeTimer);
2361              aeTimer = -1;
2362          }
2363          raxStop(&amp;ri);
2364      }
2365      if (aeTimer == -1)
2366          aeTimer = aeCreateTimeEvent(server.el,period,moduleTimerHandler,NULL,NULL);
2367      return key;
2368  }
2369  int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
2370      RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&amp;id,sizeof(id));
2371      if (timer == raxNotFound || timer-&gt;module != ctx-&gt;module)
2372          return REDISMODULE_ERR;
2373      if (data) *data = timer-&gt;data;
2374      raxRemove(Timers,(unsigned char*)&amp;id,sizeof(id),NULL);
2375      zfree(timer);
2376      return REDISMODULE_OK;
2377  }
2378  int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {
2379      RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&amp;id,sizeof(id));
2380      if (timer == raxNotFound || timer-&gt;module != ctx-&gt;module)
2381          return REDISMODULE_ERR;
2382      if (remaining) {
2383          int64_t rem = ntohu64(id)-ustime();
2384          if (rem &lt; 0) rem = 0;
2385          *remaining = rem/1000; &amp;bsol;* Scale to milliseconds. */
2386      }
2387      if (data) *data = timer-&gt;data;
2388      return REDISMODULE_OK;
2389  }
2390  RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {
2391      struct RedisModuleDict *d = zmalloc(sizeof(*d));
2392      d-&gt;rax = raxNew();
2393      if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);
2394      return d;
2395  }
2396  void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {
2397      if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_DICT,d);
2398      raxFree(d-&gt;rax);
2399      zfree(d);
2400  }
2401  uint64_t RM_DictSize(RedisModuleDict *d) {
2402      return raxSize(d-&gt;rax);
2403  }
2404  int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
2405      int retval = raxTryInsert(d-&gt;rax,key,keylen,ptr,NULL);
2406      return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
2407  }
2408  int RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
2409      int retval = raxInsert(d-&gt;rax,key,keylen,ptr,NULL);
2410      return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
2411  }
2412  int RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
2413      return RM_DictSetC(d,key-&gt;ptr,sdslen(key-&gt;ptr),ptr);
2414  }
2415  int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
2416      return RM_DictReplaceC(d,key-&gt;ptr,sdslen(key-&gt;ptr),ptr);
2417  }
2418  void *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {
2419      void *res = raxFind(d-&gt;rax,key,keylen);
2420      if (nokey) *nokey = (res == raxNotFound);
2421      return (res == raxNotFound) ? NULL : res;
2422  }
2423  void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
2424      return RM_DictGetC(d,key-&gt;ptr,sdslen(key-&gt;ptr),nokey);
2425  }
2426  int RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {
2427      int retval = raxRemove(d-&gt;rax,key,keylen,oldval);
2428      return retval ? REDISMODULE_OK : REDISMODULE_ERR;
2429  }
2430  int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {
2431      return RM_DictDelC(d,key-&gt;ptr,sdslen(key-&gt;ptr),oldval);
2432  }
2433  RedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {
2434      RedisModuleDictIter *di = zmalloc(sizeof(*di));
2435      di-&gt;dict = d;
2436      raxStart(&amp;di-&gt;ri,d-&gt;rax);
2437      raxSeek(&amp;di-&gt;ri,op,key,keylen);
2438      return di;
2439  }
2440  RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {
2441      return RM_DictIteratorStartC(d,op,key-&gt;ptr,sdslen(key-&gt;ptr));
2442  }
2443  void RM_DictIteratorStop(RedisModuleDictIter *di) {
2444      raxStop(&amp;di-&gt;ri);
2445      zfree(di);
2446  }
2447  int RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
2448      return raxSeek(&amp;di-&gt;ri,op,key,keylen);
2449  }
2450  int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
2451      return RM_DictIteratorReseekC(di,op,key-&gt;ptr,sdslen(key-&gt;ptr));
2452  }
2453  void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
2454      if (!raxNext(&amp;di-&gt;ri)) return NULL;
2455      if (keylen) *keylen = di-&gt;ri.key_len;
2456      if (dataptr) *dataptr = di-&gt;ri.data;
2457      return di-&gt;ri.key;
2458  }
2459  void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
2460      if (!raxPrev(&amp;di-&gt;ri)) return NULL;
2461      if (keylen) *keylen = di-&gt;ri.key_len;
2462      if (dataptr) *dataptr = di-&gt;ri.data;
2463      return di-&gt;ri.key;
2464  }
2465  RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
2466      size_t keylen;
2467      void *key = RM_DictNextC(di,&amp;keylen,dataptr);
2468      if (key == NULL) return NULL;
2469      return RM_CreateString(ctx,key,keylen);
2470  }
2471  RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
2472      size_t keylen;
2473      void *key = RM_DictPrevC(di,&amp;keylen,dataptr);
2474      if (key == NULL) return NULL;
2475      return RM_CreateString(ctx,key,keylen);
2476  }
2477  int RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
2478      if (raxEOF(&amp;di-&gt;ri)) return REDISMODULE_ERR;
2479      int res = raxCompare(&amp;di-&gt;ri,op,key,keylen);
2480      return res ? REDISMODULE_OK : REDISMODULE_ERR;
2481  }
2482  int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
2483      if (raxEOF(&amp;di-&gt;ri)) return REDISMODULE_ERR;
2484      int res = raxCompare(&amp;di-&gt;ri,op,key-&gt;ptr,sdslen(key-&gt;ptr));
2485      return res ? REDISMODULE_OK : REDISMODULE_ERR;
2486  }
2487  void RM_GetRandomBytes(unsigned char *dst, size_t len) {
2488      getRandomBytes(dst,len);
2489  }
2490  void RM_GetRandomHexChars(char *dst, size_t len) {
2491      getRandomHexChars(dst,len);
2492  }
2493  int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
2494      RedisModuleSharedAPI *sapi = zmalloc(sizeof(*sapi));
2495      sapi-&gt;module = ctx-&gt;module;
2496      sapi-&gt;func = func;
2497      if (dictAdd(server.sharedapi, (char*)apiname, sapi) != DICT_OK) {
2498          zfree(sapi);
2499          return REDISMODULE_ERR;
2500      }
2501      return REDISMODULE_OK;
2502  }
2503  void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {
2504      dictEntry *de = dictFind(server.sharedapi, apiname);
2505      if (de == NULL) return NULL;
2506      RedisModuleSharedAPI *sapi = dictGetVal(de);
2507      if (listSearchKey(sapi-&gt;module-&gt;usedby,ctx-&gt;module) == NULL) {
2508          listAddNodeTail(sapi-&gt;module-&gt;usedby,ctx-&gt;module);
2509          listAddNodeTail(ctx-&gt;module-&gt;using,sapi-&gt;module);
2510      }
2511      return sapi-&gt;func;
2512  }
2513  int moduleUnregisterSharedAPI(RedisModule *module) {
2514      int count = 0;
2515      dictIterator *di = dictGetSafeIterator(server.sharedapi);
2516      dictEntry *de;
2517      while ((de = dictNext(di)) != NULL) {
2518          const char *apiname = dictGetKey(de);
2519          RedisModuleSharedAPI *sapi = dictGetVal(de);
2520          if (sapi-&gt;module == module) {
2521              dictDelete(server.sharedapi,apiname);
2522              zfree(sapi);
2523              count++;
2524          }
2525      }
2526      dictReleaseIterator(di);
2527      return count;
2528  }
2529  int moduleUnregisterUsedAPI(RedisModule *module) {
2530      listIter li;
2531      listNode *ln;
2532      int count = 0;
2533      listRewind(module-&gt;using,&amp;li);
2534      while((ln = listNext(&amp;li))) {
2535          RedisModule *used = ln-&gt;value;
2536          listNode *ln = listSearchKey(used-&gt;usedby,module);
2537          if (ln) {
2538              listDelNode(module-&gt;using,ln);
2539              count++;
2540          }
2541      }
2542      return count;
2543  }
2544  int moduleUnregisterFilters(RedisModule *module) {
2545      listIter li;
2546      listNode *ln;
2547      int count = 0;
2548      listRewind(module-&gt;filters,&amp;li);
2549      while((ln = listNext(&amp;li))) {
2550          RedisModuleCommandFilter *filter = ln-&gt;value;
2551          listNode *ln = listSearchKey(moduleCommandFilters,filter);
2552          if (ln) {
2553              listDelNode(moduleCommandFilters,ln);
2554              count++;
2555          }
2556          zfree(filter);
2557      }
2558      return count;
2559  }
2560  RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, int flags) {
2561      RedisModuleCommandFilter *filter = zmalloc(sizeof(*filter));
2562      filter-&gt;module = ctx-&gt;module;
2563      filter-&gt;callback = callback;
2564      filter-&gt;flags = flags;
2565      listAddNodeTail(moduleCommandFilters, filter);
2566      listAddNodeTail(ctx-&gt;module-&gt;filters, filter);
2567      return filter;
2568  }
2569  int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) {
2570      listNode *ln;
2571      if (filter-&gt;module != ctx-&gt;module) return REDISMODULE_ERR;
2572      ln = listSearchKey(moduleCommandFilters,filter);
2573      if (!ln) return REDISMODULE_ERR;
2574      listDelNode(moduleCommandFilters,ln);
2575      ln = listSearchKey(ctx-&gt;module-&gt;filters,filter);
2576      if (!ln) return REDISMODULE_ERR;    &amp;bsol;* Shouldn&#x27;t happen */
2577      listDelNode(ctx-&gt;module-&gt;filters,ln);
2578      return REDISMODULE_OK;
2579  }
2580  void moduleCallCommandFilters(client *c) {
2581      if (listLength(moduleCommandFilters) == 0) return;
2582      listIter li;
2583      listNode *ln;
2584      listRewind(moduleCommandFilters,&amp;li);
2585      RedisModuleCommandFilterCtx filter = {
2586          .argv = c-&gt;argv,
2587          .argc = c-&gt;argc
2588      };
2589      while((ln = listNext(&amp;li))) {
2590          RedisModuleCommandFilter *f = ln-&gt;value;
2591          if ((f-&gt;flags &amp; REDISMODULE_CMDFILTER_NOSELF) &amp;&amp; f-&gt;module-&gt;in_call) continue;
2592          f-&gt;callback(&amp;filter);
2593      }
2594      c-&gt;argv = filter.argv;
2595      c-&gt;argc = filter.argc;
2596  }
2597  int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
2598  {
2599      return fctx-&gt;argc;
2600  }
2601  const RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx, int pos)
2602  {
2603      if (pos &lt; 0 || pos &gt;= fctx-&gt;argc) return NULL;
2604      return fctx-&gt;argv[pos];
2605  }
2606  int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
2607  {
2608      int i;
2609      if (pos &lt; 0 || pos &gt; fctx-&gt;argc) return REDISMODULE_ERR;
2610      fctx-&gt;argv = zrealloc(fctx-&gt;argv, (fctx-&gt;argc+1)*sizeof(RedisModuleString *));
2611      for (i = fctx-&gt;argc; i &gt; pos; i--) {
2612          fctx-&gt;argv[i] = fctx-&gt;argv[i-1];
2613      }
2614      fctx-&gt;argv[pos] = arg;
2615      fctx-&gt;argc++;
2616      return REDISMODULE_OK;
2617  }
2618  int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
2619  {
2620      if (pos &lt; 0 || pos &gt;= fctx-&gt;argc) return REDISMODULE_ERR;
2621      decrRefCount(fctx-&gt;argv[pos]);
2622      fctx-&gt;argv[pos] = arg;
2623      return REDISMODULE_OK;
2624  }
2625  int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
2626  {
2627      int i;
2628      if (pos &lt; 0 || pos &gt;= fctx-&gt;argc) return REDISMODULE_ERR;
2629      decrRefCount(fctx-&gt;argv[pos]);
2630      for (i = pos; i &lt; fctx-&gt;argc-1; i++) {
2631          fctx-&gt;argv[i] = fctx-&gt;argv[i+1];
2632      }
2633      fctx-&gt;argc--;
2634      return REDISMODULE_OK;
2635  }
2636  uint64_t dictCStringKeyHash(const void *key) {
2637      return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
2638  }
2639  int dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {
2640      UNUSED(privdata);
2641      return strcmp(key1,key2) == 0;
2642  }
2643  dictType moduleAPIDictType = {
2644      dictCStringKeyHash,        &amp;bsol;* hash function */
2645      NULL,                      &amp;bsol;* key dup */
2646      NULL,                      &amp;bsol;* val dup */
2647      dictCStringKeyCompare,     &amp;bsol;* key compare */
2648      NULL,                      &amp;bsol;* key destructor */
2649      NULL                       &amp;bsol;* val destructor */
2650  };
2651  int moduleRegisterApi(const char *funcname, void *funcptr) {
2652      return dictAdd(server.moduleapi, (char*)funcname, funcptr);
2653  }
2654  #define REGISTER_API(name) \
2655      moduleRegisterApi(&quot;RedisModule_&quot; #name, (void *)(PORT_ULONG)RM_ ## name)
2656  void moduleRegisterCoreAPI(void);
2657  void moduleInitModulesSystem(void) {
2658      moduleUnblockedClients = listCreate();
2659      server.loadmodule_queue = listCreate();
2660      modules = dictCreate(&amp;modulesDictType,NULL);
2661      moduleKeyspaceSubscribers = listCreate();
2662      moduleFreeContextReusedClient = createClient(-1);
2663      moduleFreeContextReusedClient-&gt;flags |= CLIENT_MODULE;
2664      moduleCommandFilters = listCreate();
2665      moduleRegisterCoreAPI();
2666      if (IF_WIN32(FDAPI_pipe_for_modules,pipe)(server.module_blocked_pipe) == -1) {
2667          serverLog(LL_WARNING,
2668              &quot;Can&#x27;t create the pipe for module blocking commands: %s&quot;,
2669              IF_WIN32(wsa_strerror(errno), strerror(errno)));
2670          exit(1);
2671      }
2672      anetNonBlock(NULL,server.module_blocked_pipe[0]);
2673      anetNonBlock(NULL,server.module_blocked_pipe[1]);
2674      Timers = raxNew();
2675      pthread_mutex_lock(&amp;moduleGIL);
2676  }
2677  void moduleLoadFromQueue(void) {
2678      listIter li;
2679      listNode *ln;
2680      listRewind(server.loadmodule_queue,&amp;li);
2681      while((ln = listNext(&amp;li))) {
2682          struct moduleLoadQueueEntry *loadmod = ln-&gt;value;
2683          if (moduleLoad(loadmod-&gt;path,(void **)loadmod-&gt;argv,loadmod-&gt;argc)
2684              == C_ERR)
2685          {
2686              serverLog(LL_WARNING,
2687                  &quot;Can&#x27;t load module from %s: server aborting&quot;,
2688                  loadmod-&gt;path);
2689              exit(1);
2690          }
2691      }
2692  }
2693  void moduleFreeModuleStructure(struct RedisModule *module) {
2694      listRelease(module-&gt;types);
2695      listRelease(module-&gt;filters);
2696      sdsfree(module-&gt;name);
2697      zfree(module);
2698  }
2699  void moduleUnregisterCommands(struct RedisModule *module) {
2700      dictIterator *di = dictGetSafeIterator(server.commands);
2701      dictEntry *de;
2702      while ((de = dictNext(di)) != NULL) {
2703          struct redisCommand *cmd = dictGetVal(de);
2704          if (cmd-&gt;proc == RedisModuleCommandDispatcher) {
2705              RedisModuleCommandProxy *cp =
2706                  (void*)(PORT_ULONG)cmd-&gt;getkeys_proc;
2707              sds cmdname = cp-&gt;rediscmd-&gt;name;
2708              if (cp-&gt;module == module) {
2709                  dictDelete(server.commands,cmdname);
2710                  dictDelete(server.orig_commands,cmdname);
2711                  sdsfree(cmdname);
2712                  zfree(cp-&gt;rediscmd);
2713                  zfree(cp);
2714              }
2715          }
2716      }
2717      dictReleaseIterator(di);
2718  }
2719  int moduleLoad(const char *path, void **module_argv, int module_argc) {
2720      int (*onload)(void *, void **, int);
2721      void *handle;
2722      RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2723      handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);
2724      if (handle == NULL) {
2725          serverLog(LL_WARNING, &quot;Module %s failed to load: %s&quot;, path, dlerror());
2726          return C_ERR;
2727      }
2728      onload = (int (*)(void *, void **, int))(PORT_ULONG) dlsym(handle,&quot;RedisModule_OnLoad&quot;);
2729      if (onload == NULL) {
2730          dlclose(handle);
2731          serverLog(LL_WARNING,
2732              &quot;Module %s does not export RedisModule_OnLoad() &quot;
2733              &quot;symbol. Module not loaded.&quot;,path);
2734          return C_ERR;
2735      }
2736      if (onload((void*)&amp;ctx,module_argv,module_argc) == REDISMODULE_ERR) {
2737          if (ctx.module) {
2738              moduleUnregisterCommands(ctx.module);
2739              moduleUnregisterSharedAPI(ctx.module);
2740              moduleUnregisterUsedAPI(ctx.module);
2741              moduleFreeModuleStructure(ctx.module);
2742          }
2743          dlclose(handle);
2744          serverLog(LL_WARNING,
2745              &quot;Module %s initialization failed. Module not loaded&quot;,path);
2746          return C_ERR;
2747      }
2748  #ifdef _WIN32
2749  #pragma warning(push)
2750  #pragma warning(disable: 6011)
2751  #endif
2752      dictAdd(modules,ctx.module-&gt;name,ctx.module);
2753  #ifdef _WIN32
2754  #pragma warning(pop)
2755  #endif
2756      ctx.module-&gt;handle = handle;
2757      serverLog(LL_NOTICE,&quot;Module &#x27;%s&#x27; loaded from %s&quot;,ctx.module-&gt;name,path);
2758      moduleFreeContext(&amp;ctx);
2759      return C_OK;
2760  }
2761  int moduleUnload(sds name) {
2762      struct RedisModule *module = dictFetchValue(modules,name);
2763      if (module == NULL) {
2764          errno = ENOENT;
2765          return REDISMODULE_ERR;
2766      } else if (listLength(module-&gt;types)) {
2767          errno = EBUSY;
2768          return REDISMODULE_ERR;
2769      } else if (listLength(module-&gt;usedby)) {
2770          errno = EPERM;
2771          return REDISMODULE_ERR;
2772      }
2773      moduleUnregisterCommands(module);
2774      moduleUnregisterSharedAPI(module);
2775      moduleUnregisterUsedAPI(module);
2776      moduleUnregisterFilters(module);
2777      moduleUnsubscribeNotifications(module);
2778      if (dlclose(module-&gt;handle) == -1) {
2779          char *error = dlerror();
2780          if (error == NULL) error = &quot;Unknown error&quot;;
2781          serverLog(LL_WARNING,&quot;Error when trying to close the %s module: %s&quot;,
2782              module-&gt;name, error);
2783      }
2784      serverLog(LL_NOTICE,&quot;Module %s unloaded&quot;,module-&gt;name);
2785      dictDelete(modules,module-&gt;name);
2786      module-&gt;name = NULL; &amp;bsol;* The name was already freed by dictDelete(). */
2787      moduleFreeModuleStructure(module);
2788      return REDISMODULE_OK;
2789  }
2790  void moduleCommand(client *c) {
2791      char *subcmd = c-&gt;argv[1]-&gt;ptr;
2792      if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(subcmd,&quot;help&quot;)) {
2793          const char *help[] = {
2794  &quot;LIST -- Return a list of loaded modules.&quot;,
2795  &quot;LOAD &lt;path&gt; [arg ...] -- Load a module library from &lt;path&gt;.&quot;,
2796  &quot;UNLOAD &lt;name&gt; -- Unload a module.&quot;,
2797  NULL
2798          };
2799          addReplyHelp(c, help);
2800      } else
2801      if (!strcasecmp(subcmd,&quot;load&quot;) &amp;&amp; c-&gt;argc &gt;= 3) {
2802          robj **argv = NULL;
2803          int argc = 0;
2804          if (c-&gt;argc &gt; 3) {
2805              argc = c-&gt;argc - 3;
2806              argv = &amp;c-&gt;argv[3];
2807          }
2808          if (moduleLoad(c-&gt;argv[2]-&gt;ptr,(void **)argv,argc) == C_OK)
2809              addReply(c,shared.ok);
2810          else
2811              addReplyError(c,
2812                  &quot;Error loading the extension. Please check the server logs.&quot;);
2813      } else if (!strcasecmp(subcmd,&quot;unload&quot;) &amp;&amp; c-&gt;argc == 3) {
2814          if (moduleUnload(c-&gt;argv[2]-&gt;ptr) == C_OK)
2815              addReply(c,shared.ok);
2816          else {
2817              char *errmsg;
2818              switch(errno) {
2819              case ENOENT:
2820                  errmsg = &quot;no such module with that name&quot;;
2821                  break;
2822              case EBUSY:
2823                  errmsg = &quot;the module exports one or more module-side data &quot;
2824                           &quot;types, can&#x27;t unload&quot;;
2825                  break;
2826              case EPERM:
2827                  errmsg = &quot;the module exports APIs used by other modules. &quot;
2828                           &quot;Please unload them first and try again&quot;;
2829                  break;
2830              default:
2831                  errmsg = &quot;operation not possible.&quot;;
2832                  break;
2833              }
2834              addReplyErrorFormat(c,&quot;Error unloading module: %s&quot;,errmsg);
2835          }
2836      } else if (!strcasecmp(subcmd,&quot;list&quot;) &amp;&amp; c-&gt;argc == 2) {
2837          dictIterator *di = dictGetIterator(modules);
2838          dictEntry *de;
2839          addReplyMultiBulkLen(c,dictSize(modules));
2840          while ((de = dictNext(di)) != NULL) {
2841              sds name = dictGetKey(de);
2842              struct RedisModule *module = dictGetVal(de);
2843              addReplyMultiBulkLen(c,4);
2844              addReplyBulkCString(c,&quot;name&quot;);
2845              addReplyBulkCBuffer(c,name,sdslen(name));
2846              addReplyBulkCString(c,&quot;ver&quot;);
2847              addReplyLongLong(c,module-&gt;ver);
2848          }
2849          dictReleaseIterator(di);
2850      } else {
2851          addReplySubcommandSyntaxError(c);
2852          return;
2853      }
2854  }
2855  size_t moduleCount(void) {
2856      return dictSize(modules);
2857  }
2858  void moduleRegisterCoreAPI(void) {
2859      server.moduleapi = dictCreate(&amp;moduleAPIDictType,NULL);
2860      server.sharedapi = dictCreate(&amp;moduleAPIDictType,NULL);
2861      REGISTER_API(Alloc);
2862      REGISTER_API(Calloc);
2863      REGISTER_API(Realloc);
2864      REGISTER_API(Free);
2865      REGISTER_API(Strdup);
2866      REGISTER_API(CreateCommand);
2867      REGISTER_API(SetModuleAttribs);
2868      REGISTER_API(IsModuleNameBusy);
2869      REGISTER_API(WrongArity);
2870      REGISTER_API(ReplyWithLongLong);
2871      REGISTER_API(ReplyWithError);
2872      REGISTER_API(ReplyWithSimpleString);
2873      REGISTER_API(ReplyWithArray);
2874      REGISTER_API(ReplySetArrayLength);
2875      REGISTER_API(ReplyWithString);
2876      REGISTER_API(ReplyWithStringBuffer);
2877      REGISTER_API(ReplyWithCString);
2878      REGISTER_API(ReplyWithNull);
2879      REGISTER_API(ReplyWithCallReply);
2880      REGISTER_API(ReplyWithDouble);
2881      REGISTER_API(GetSelectedDb);
2882      REGISTER_API(SelectDb);
2883      REGISTER_API(OpenKey);
2884      REGISTER_API(CloseKey);
2885      REGISTER_API(KeyType);
2886      REGISTER_API(ValueLength);
2887      REGISTER_API(ListPush);
2888      REGISTER_API(ListPop);
2889      REGISTER_API(StringToLongLong);
2890      REGISTER_API(StringToDouble);
2891      REGISTER_API(Call);
2892      REGISTER_API(CallReplyProto);
2893      REGISTER_API(FreeCallReply);
2894      REGISTER_API(CallReplyInteger);
2895      REGISTER_API(CallReplyType);
2896      REGISTER_API(CallReplyLength);
2897      REGISTER_API(CallReplyArrayElement);
2898      REGISTER_API(CallReplyStringPtr);
2899      REGISTER_API(CreateStringFromCallReply);
2900      REGISTER_API(CreateString);
2901      REGISTER_API(CreateStringFromLongLong);
2902      REGISTER_API(CreateStringFromString);
2903      REGISTER_API(CreateStringPrintf);
2904      REGISTER_API(FreeString);
2905      REGISTER_API(StringPtrLen);
2906      REGISTER_API(AutoMemory);
2907      REGISTER_API(Replicate);
2908      REGISTER_API(ReplicateVerbatim);
2909      REGISTER_API(DeleteKey);
2910      REGISTER_API(UnlinkKey);
2911      REGISTER_API(StringSet);
2912      REGISTER_API(StringDMA);
2913      REGISTER_API(StringTruncate);
2914      REGISTER_API(SetExpire);
2915      REGISTER_API(GetExpire);
2916      REGISTER_API(ZsetAdd);
2917      REGISTER_API(ZsetIncrby);
2918      REGISTER_API(ZsetScore);
2919      REGISTER_API(ZsetRem);
2920      REGISTER_API(ZsetRangeStop);
2921      REGISTER_API(ZsetFirstInScoreRange);
2922      REGISTER_API(ZsetLastInScoreRange);
2923      REGISTER_API(ZsetFirstInLexRange);
2924      REGISTER_API(ZsetLastInLexRange);
2925      REGISTER_API(ZsetRangeCurrentElement);
2926      REGISTER_API(ZsetRangeNext);
2927      REGISTER_API(ZsetRangePrev);
2928      REGISTER_API(ZsetRangeEndReached);
2929      REGISTER_API(HashSet);
2930      REGISTER_API(HashGet);
2931      REGISTER_API(IsKeysPositionRequest);
2932      REGISTER_API(KeyAtPos);
2933      REGISTER_API(GetClientId);
2934      REGISTER_API(GetContextFlags);
2935      REGISTER_API(PoolAlloc);
2936      REGISTER_API(CreateDataType);
2937      REGISTER_API(ModuleTypeSetValue);
2938      REGISTER_API(ModuleTypeGetType);
2939      REGISTER_API(ModuleTypeGetValue);
2940      REGISTER_API(SaveUnsigned);
2941      REGISTER_API(LoadUnsigned);
2942      REGISTER_API(SaveSigned);
2943      REGISTER_API(LoadSigned);
2944      REGISTER_API(SaveString);
2945      REGISTER_API(SaveStringBuffer);
2946      REGISTER_API(LoadString);
2947      REGISTER_API(LoadStringBuffer);
2948      REGISTER_API(SaveDouble);
2949      REGISTER_API(LoadDouble);
2950      REGISTER_API(SaveFloat);
2951      REGISTER_API(LoadFloat);
2952      REGISTER_API(EmitAOF);
2953      REGISTER_API(Log);
2954      REGISTER_API(LogIOError);
2955      REGISTER_API(StringAppendBuffer);
2956      REGISTER_API(RetainString);
2957      REGISTER_API(StringCompare);
2958      REGISTER_API(GetContextFromIO);
2959      REGISTER_API(GetKeyNameFromIO);
2960      REGISTER_API(BlockClient);
2961      REGISTER_API(UnblockClient);
2962      REGISTER_API(IsBlockedReplyRequest);
2963      REGISTER_API(IsBlockedTimeoutRequest);
2964      REGISTER_API(GetBlockedClientPrivateData);
2965      REGISTER_API(AbortBlock);
2966      REGISTER_API(Milliseconds);
2967      REGISTER_API(GetThreadSafeContext);
2968      REGISTER_API(FreeThreadSafeContext);
2969      REGISTER_API(ThreadSafeContextLock);
2970      REGISTER_API(ThreadSafeContextUnlock);
2971      REGISTER_API(DigestAddStringBuffer);
2972      REGISTER_API(DigestAddLongLong);
2973      REGISTER_API(DigestEndSequence);
2974      REGISTER_API(SubscribeToKeyspaceEvents);
2975      REGISTER_API(RegisterClusterMessageReceiver);
2976      REGISTER_API(SendClusterMessage);
2977      REGISTER_API(GetClusterNodeInfo);
2978      REGISTER_API(GetClusterNodesList);
2979      REGISTER_API(FreeClusterNodesList);
2980      REGISTER_API(CreateTimer);
2981      REGISTER_API(StopTimer);
2982      REGISTER_API(GetTimerInfo);
2983      REGISTER_API(GetMyClusterID);
2984      REGISTER_API(GetClusterSize);
2985      REGISTER_API(GetRandomBytes);
2986      REGISTER_API(GetRandomHexChars);
2987      REGISTER_API(BlockedClientDisconnected);
2988      REGISTER_API(SetDisconnectCallback);
2989      REGISTER_API(GetBlockedClientHandle);
2990      REGISTER_API(SetClusterFlags);
2991      REGISTER_API(CreateDict);
2992      REGISTER_API(FreeDict);
2993      REGISTER_API(DictSize);
2994      REGISTER_API(DictSetC);
2995      REGISTER_API(DictReplaceC);
2996      REGISTER_API(DictSet);
2997      REGISTER_API(DictReplace);
2998      REGISTER_API(DictGetC);
2999      REGISTER_API(DictGet);
3000      REGISTER_API(DictDelC);
3001      REGISTER_API(DictDel);
3002      REGISTER_API(DictIteratorStartC);
3003      REGISTER_API(DictIteratorStart);
3004      REGISTER_API(DictIteratorStop);
3005      REGISTER_API(DictIteratorReseekC);
3006      REGISTER_API(DictIteratorReseek);
3007      REGISTER_API(DictNextC);
3008      REGISTER_API(DictPrevC);
3009      REGISTER_API(DictNext);
3010      REGISTER_API(DictPrev);
3011      REGISTER_API(DictCompareC);
3012      REGISTER_API(DictCompare);
3013      REGISTER_API(ExportSharedAPI);
3014      REGISTER_API(GetSharedAPI);
3015      REGISTER_API(RegisterCommandFilter);
3016      REGISTER_API(UnregisterCommandFilter);
3017      REGISTER_API(CommandFilterArgsCount);
3018      REGISTER_API(CommandFilterArgGet);
3019      REGISTER_API(CommandFilterArgInsert);
3020      REGISTER_API(CommandFilterArgReplace);
3021      REGISTER_API(CommandFilterArgDelete);
3022  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-module.c</h3>
            <pre><code>1  #include &quot;server.h&quot;
2  #include &quot;cluster.h&quot;
3  #include &quot;rdb.h&quot;
4  #ifndef _WIN32
5  #include &lt;dlfcn.h&gt;
6  #else
7  #include &quot;Win32_Interop/dlfcn.h&quot;
8  #include &quot;Win32_Interop/Win32_PThread.h&quot;
9  #include &quot;Win32_Interop/Win32_Error.h&quot;
10  #endif
11  #define REDISMODULE_CORE 1
12  #include &quot;redismodule.h&quot;
13  struct RedisModule {
14      void *handle;   &amp;bsol;* Module dlopen() handle. */
15      char *name;     &amp;bsol;* Module name. */
16      int ver;        &amp;bsol;* Module version. We use just progressive integers. */
17      int apiver;     &amp;bsol;* Module API version as requested during initialization.*/
18      list *types;    &amp;bsol;* Module data types. */
19      list *usedby;   &amp;bsol;* List of modules using APIs from this one. */
20      list *using;    &amp;bsol;* List of modules we use some APIs of. */
21      list *filters;  &amp;bsol;* List of filters the module has registered. */
22      int in_call;    &amp;bsol;* RM_Call() nesting level */
23  };
24  typedef struct RedisModule RedisModule;
25  struct RedisModuleSharedAPI {
26      void *func;
27      RedisModule *module;
28  };
29  typedef struct RedisModuleSharedAPI RedisModuleSharedAPI;
30  #ifndef _WIN32
31  static dict *modules; &amp;bsol;* Hash table of modules. SDS -&gt; RedisModule ptr.*/
32  #endif
33  struct AutoMemEntry {
34      void *ptr;
35      int type;
36  };
37  #define REDISMODULE_AM_KEY 0
38  #define REDISMODULE_AM_STRING 1
39  #define REDISMODULE_AM_REPLY 2
40  #define REDISMODULE_AM_FREED 3 &amp;bsol;* Explicitly freed by user already. */
41  #define REDISMODULE_AM_DICT 4
42  #define REDISMODULE_POOL_ALLOC_MIN_SIZE (1024*8)
43  #define REDISMODULE_POOL_ALLOC_ALIGN (sizeof(void*))
44  typedef struct RedisModulePoolAllocBlock {
45      uint32_t size;
46      uint32_t used;
47      struct RedisModulePoolAllocBlock *next;
48      char memory[];
49  } RedisModulePoolAllocBlock;
50  struct RedisModuleBlockedClient;
51  struct RedisModuleCtx {
52      void *getapifuncptr;            &amp;bsol;* NOTE: Must be the first field. */
53      struct RedisModule *module;     &amp;bsol;* Module reference. */
54      client *client;                 &amp;bsol;* Client calling a command. */
55      struct RedisModuleBlockedClient *blocked_client; &amp;bsol;* Blocked client for
56                                                          thread safe context. */
57      struct AutoMemEntry *amqueue;   &amp;bsol;* Auto memory queue of objects to free. */
58      int amqueue_len;                &amp;bsol;* Number of slots in amqueue. */
59      int amqueue_used;               &amp;bsol;* Number of used slots in amqueue. */
60      int flags;                      &amp;bsol;* REDISMODULE_CTX_... flags. */
61      void **postponed_arrays;        &amp;bsol;* To set with RM_ReplySetArrayLength(). */
62      int postponed_arrays_count;     &amp;bsol;* Number of entries in postponed_arrays. */
63      void *blocked_privdata;         &amp;bsol;* Privdata set when unblocking a client. */
64      int *keys_pos;
65      int keys_count;
66      struct RedisModulePoolAllocBlock *pa_head;
67      redisOpArray saved_oparray;    &amp;bsol;* When propagating commands in a callback
68                                        we reallocate the &quot;also propagate&quot; op
69                                        array. Here we save the old one to
70                                        restore it later. */
71  };
72  typedef struct RedisModuleCtx RedisModuleCtx;
73  #define REDISMODULE_CTX_INIT {(void*)(PORT_ULONG)&amp;RM_GetApi, NULL, NULL, NULL, NULL, 0, 0, 0, NULL, 0, NULL, NULL, 0, NULL, {0}}
74  #define REDISMODULE_CTX_MULTI_EMITTED (1&lt;&lt;0)
75  #define REDISMODULE_CTX_AUTO_MEMORY (1&lt;&lt;1)
76  #define REDISMODULE_CTX_KEYS_POS_REQUEST (1&lt;&lt;2)
77  #define REDISMODULE_CTX_BLOCKED_REPLY (1&lt;&lt;3)
78  #define REDISMODULE_CTX_BLOCKED_TIMEOUT (1&lt;&lt;4)
79  #define REDISMODULE_CTX_THREAD_SAFE (1&lt;&lt;5)
80  #define REDISMODULE_CTX_BLOCKED_DISCONNECTED (1&lt;&lt;6)
81  #define REDISMODULE_CTX_MODULE_COMMAND_CALL (1&lt;&lt;7)
82  struct RedisModuleKey {
83      RedisModuleCtx *ctx;
84      redisDb *db;
85      robj *key;      &amp;bsol;* Key name object. */
86      robj *value;    &amp;bsol;* Value object, or NULL if the key was not found. */
87      void *iter;     &amp;bsol;* Iterator. */
88      int mode;       &amp;bsol;* Opening mode. */
89      uint32_t ztype;         &amp;bsol;* REDISMODULE_ZSET_RANGE_* */
90      zrangespec zrs;         &amp;bsol;* Score range. */
91      zlexrangespec zlrs;     &amp;bsol;* Lex range. */
92      uint32_t zstart;        &amp;bsol;* Start pos for positional ranges. */
93      uint32_t zend;          &amp;bsol;* End pos for positional ranges. */
94      void *zcurrent;         &amp;bsol;* Zset iterator current node. */
95      int zer;                &amp;bsol;* Zset iterator end reached flag
96                                 (true if end was reached). */
97  };
98  typedef struct RedisModuleKey RedisModuleKey;
99  #define REDISMODULE_ZSET_RANGE_NONE 0       &amp;bsol;* This must always be 0. */
100  #define REDISMODULE_ZSET_RANGE_LEX 1
101  #define REDISMODULE_ZSET_RANGE_SCORE 2
102  #define REDISMODULE_ZSET_RANGE_POS 3
103  struct RedisModuleBlockedClient;
104  typedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);
105  typedef void (*RedisModuleDisconnectFunc) (RedisModuleCtx *ctx, struct RedisModuleBlockedClient *bc);
106  struct RedisModuleCommandProxy {
107      struct RedisModule *module;
108      RedisModuleCmdFunc func;
109      struct redisCommand *rediscmd;
110  };
111  typedef struct RedisModuleCommandProxy RedisModuleCommandProxy;
112  #define REDISMODULE_REPLYFLAG_NONE 0
113  #define REDISMODULE_REPLYFLAG_TOPARSE (1&lt;&lt;0) &amp;bsol;* Protocol must be parsed. */
114  #define REDISMODULE_REPLYFLAG_NESTED (1&lt;&lt;1)  &amp;bsol;* Nested reply object. No proto
115                                                  or struct free. */
116  typedef struct RedisModuleCallReply {
117      RedisModuleCtx *ctx;
118      int type;       &amp;bsol;* REDISMODULE_REPLY_... */
119      int flags;      &amp;bsol;* REDISMODULE_REPLYFLAG_...  */
120      size_t len;     &amp;bsol;* Len of strings or num of elements of arrays. */
121      char *proto;    &amp;bsol;* Raw reply protocol. An SDS string at top-level object. */
122      size_t protolen;&amp;bsol;* Length of protocol. */
123      union {
124          const char *str; &amp;bsol;* String pointer for string and error replies. This
125                              does not need to be freed, always points inside
126                              a reply-&gt;proto buffer of the reply object or, in
127                              case of array elements, of parent reply objects. */
128          PORT_LONGLONG ll;    &amp;bsol;* Reply value for integer reply. */
129          struct RedisModuleCallReply *array; &amp;bsol;* Array of sub-reply elements. */
130      } val;
131  } RedisModuleCallReply;
132  typedef struct RedisModuleBlockedClient {
133      client *client;  &amp;bsol;* Pointer to the blocked client. or NULL if the client
134                          was destroyed during the life of this object. */
135      RedisModule *module;    &amp;bsol;* Module blocking the client. */
136      RedisModuleCmdFunc reply_callback; &amp;bsol;* Reply callback on normal completion.*/
137      RedisModuleCmdFunc timeout_callback; &amp;bsol;* Reply callback on timeout. */
138      RedisModuleDisconnectFunc disconnect_callback; &amp;bsol;* Called on disconnection.*/
139      void (*free_privdata)(RedisModuleCtx*,void*);&amp;bsol;* privdata cleanup callback.*/
140      void *privdata;     &amp;bsol;* Module private data that may be used by the reply
141                             or timeout callback. It is set via the
142                             RedisModule_UnblockClient() API. */
143      client *reply_client;           &amp;bsol;* Fake client used to accumulate replies
144                                         in thread safe contexts. */
145      int dbid;           &amp;bsol;* Database number selected by the original client. */
146  } RedisModuleBlockedClient;
147  #ifndef _WIN32
148  static pthread_mutex_t moduleUnblockedClientsMutex = PTHREAD_MUTEX_INITIALIZER;
149  #else
150  pthread_mutex_t moduleUnblockedClientsMutex;
151  #endif
152  static list *moduleUnblockedClients;
153  #ifndef _WIN32
154  static pthread_mutex_t moduleGIL = PTHREAD_MUTEX_INITIALIZER;
155  #else
156  pthread_mutex_t moduleGIL;
157  #endif
158  typedef int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);
159  typedef struct RedisModuleKeyspaceSubscriber {
160      RedisModule *module;
161      RedisModuleNotificationFunc notify_callback;
162      int event_mask;
163      int active;
164  } RedisModuleKeyspaceSubscriber;
165  static list *moduleKeyspaceSubscribers;
166  static client *moduleFreeContextReusedClient;
167  typedef struct RedisModuleDict {
168      rax *rax;                       &amp;bsol;* The radix tree. */
169  } RedisModuleDict;
170  typedef struct RedisModuleDictIter {
171      RedisModuleDict *dict;
172      raxIterator ri;
173  } RedisModuleDictIter;
174  typedef struct RedisModuleCommandFilterCtx {
175      RedisModuleString **argv;
176      int argc;
177  } RedisModuleCommandFilterCtx;
178  typedef void (*RedisModuleCommandFilterFunc) (RedisModuleCommandFilterCtx *filter);
179  typedef struct RedisModuleCommandFilter {
180      RedisModule *module;
181      RedisModuleCommandFilterFunc callback;
182      int flags;
183  } RedisModuleCommandFilter;
184  static list *moduleCommandFilters;
185  #define REDISMODULE_ARGV_REPLICATE (1&lt;&lt;0)
186  #define REDISMODULE_ARGV_NO_AOF (1&lt;&lt;1)
187  #define REDISMODULE_ARGV_NO_REPLICAS (1&lt;&lt;2)
188  void RM_FreeCallReply(RedisModuleCallReply *reply);
189  void RM_CloseKey(RedisModuleKey *key);
190  void autoMemoryCollect(RedisModuleCtx *ctx);
191  robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap);
192  void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx);
193  void RM_ZsetRangeStop(RedisModuleKey *kp);
194  static void zsetKeyReset(RedisModuleKey *key);
195  void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d);
196  void *RM_Alloc(size_t bytes) {
197      return zmalloc(bytes);
198  }
199  void *RM_Calloc(size_t nmemb, size_t size) {
200      return zcalloc(nmemb*size);
201  }
202  void* RM_Realloc(void *ptr, size_t bytes) {
203      return zrealloc(ptr,bytes);
204  }
205  void RM_Free(void *ptr) {
206      zfree(ptr);
207  }
208  char *RM_Strdup(const char *str) {
209      return zstrdup(str);
210  }
211  void poolAllocRelease(RedisModuleCtx *ctx) {
212      RedisModulePoolAllocBlock *head = ctx-&gt;pa_head, *next;
213      while(head != NULL) {
214          next = head-&gt;next;
215          zfree(head);
216          head = next;
217      }
218      ctx-&gt;pa_head = NULL;
219  }
220  void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
221      if (bytes == 0) return NULL;
222      RedisModulePoolAllocBlock *b = ctx-&gt;pa_head;
223      size_t left = b ? b-&gt;size - b-&gt;used : 0;
224      if (left &gt;= bytes) {
225          size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;
226          while (bytes &lt; alignment &amp;&amp; alignment/2 &gt;= bytes) alignment /= 2;
227          if (b-&gt;used % alignment)
228              b-&gt;used += alignment - (b-&gt;used % alignment);
229          left = (b-&gt;used &gt; b-&gt;size) ? 0 : b-&gt;size - b-&gt;used;
230      }
231      if (left &lt; bytes) {
232          size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;
233          if (blocksize &lt; bytes) blocksize = bytes;
234          b = zmalloc(sizeof(*b) + blocksize);
235          b-&gt;size = blocksize;
236          b-&gt;used = 0;
237          b-&gt;next = ctx-&gt;pa_head;
238          ctx-&gt;pa_head = b;
239      }
240      char *retval = b-&gt;memory + b-&gt;used;
241      b-&gt;used += bytes;
242      return retval;
243  }
244  int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
245      robj *obj;
246      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;value)
247          return REDISMODULE_ERR;
248      switch(type) {
249      case REDISMODULE_KEYTYPE_LIST:
250          obj = createQuicklistObject();
251          quicklistSetOptions(obj-&gt;ptr, server.list_max_ziplist_size,
252                              server.list_compress_depth);
253          break;
254      case REDISMODULE_KEYTYPE_ZSET:
255          obj = createZsetZiplistObject();
256          break;
257      case REDISMODULE_KEYTYPE_HASH:
258          obj = createHashObject();
259          break;
260      default: return REDISMODULE_ERR;
261      }
262      dbAdd(key-&gt;db,key-&gt;key,obj);
263      key-&gt;value = obj;
264      return REDISMODULE_OK;
265  }
266  int moduleDelKeyIfEmpty(RedisModuleKey *key) {
267      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;value == NULL) return 0;
268      int isempty;
269      robj *o = key-&gt;value;
270      switch(o-&gt;type) {
271      case OBJ_LIST: isempty = listTypeLength(o) == 0; break;
272      case OBJ_SET: isempty = setTypeSize(o) == 0; break;
273      case OBJ_ZSET: isempty = zsetLength(o) == 0; break;
274      case OBJ_HASH: isempty = hashTypeLength(o) == 0; break;
275      case OBJ_STREAM: isempty = streamLength(o) == 0; break;
276      default: isempty = 0;
277      }
278      if (isempty) {
279          dbDelete(key-&gt;db,key-&gt;key);
280          key-&gt;value = NULL;
281          return 1;
282      } else {
283          return 0;
284      }
285  }
286  int RM_GetApi(const char *funcname, void **targetPtrPtr) {
287      dictEntry *he = dictFind(server.moduleapi, funcname);
288      if (!he) return REDISMODULE_ERR;
289      *targetPtrPtr = dictGetVal(he);
290      return REDISMODULE_OK;
291  }
292  void moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {
293      client *c = ctx-&gt;client;
294      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_MULTI_EMITTED)) return;
295      if (c-&gt;flags &amp; CLIENT_LUA) return;
296      robj *propargv[1];
297      propargv[0] = createStringObject(&quot;EXEC&quot;,4);
298      alsoPropagate(server.execCommand,c-&gt;db-&gt;id,propargv,1,
299          PROPAGATE_AOF|PROPAGATE_REPL);
300      decrRefCount(propargv[0]);
301      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_MODULE_COMMAND_CALL) &amp;&amp;
302          server.also_propagate.numops)
303      {
304          for (int j = 0; j &lt; server.also_propagate.numops; j++) {
305              redisOp *rop = &amp;server.also_propagate.ops[j];
306              int target = rop-&gt;target;
307              if (target)
308                  propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);
309          }
310          redisOpArrayFree(&amp;server.also_propagate);
311          server.also_propagate = ctx-&gt;saved_oparray;
312          redisOpArrayInit(&amp;ctx-&gt;saved_oparray);
313      }
314  }
315  void moduleFreeContext(RedisModuleCtx *ctx) {
316      moduleHandlePropagationAfterCommandCallback(ctx);
317      autoMemoryCollect(ctx);
318      poolAllocRelease(ctx);
319      if (ctx-&gt;postponed_arrays) {
320          zfree(ctx-&gt;postponed_arrays);
321          ctx-&gt;postponed_arrays_count = 0;
322          serverLog(LL_WARNING,
323              &quot;API misuse detected in module %s: &quot;
324              &quot;RedisModule_ReplyWithArray(REDISMODULE_POSTPONED_ARRAY_LEN) &quot;
325              &quot;not matched by the same number of RedisModule_SetReplyArrayLen() &quot;
326              &quot;calls.&quot;,
327              ctx-&gt;module-&gt;name);
328      }
329      if (ctx-&gt;flags &amp; REDISMODULE_CTX_THREAD_SAFE) freeClient(ctx-&gt;client);
330  }
331  void RedisModuleCommandDispatcher(client *c) {
332      RedisModuleCommandProxy *cp = (void*) (PORT_ULONG)c-&gt;cmd-&gt;getkeys_proc;
333      RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
334      ctx.flags |= REDISMODULE_CTX_MODULE_COMMAND_CALL;
335      ctx.module = cp-&gt;module;
336      ctx.client = c;
337      cp-&gt;func(&amp;ctx,(void**)c-&gt;argv,c-&gt;argc);
338      moduleFreeContext(&amp;ctx);
339      for (int i = 0; i &lt; c-&gt;argc; i++) {
340          if (c-&gt;argv[i]-&gt;refcount &gt; 1)
341              trimStringObjectIfNeeded(c-&gt;argv[i]);
342      }
343  }
344  int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
345      RedisModuleCommandProxy *cp = (void*) (PORT_ULONG)cmd-&gt;getkeys_proc;
346      RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
347      ctx.module = cp-&gt;module;
348      ctx.client = NULL;
349      ctx.flags |= REDISMODULE_CTX_KEYS_POS_REQUEST;
350      cp-&gt;func(&amp;ctx,(void**)argv,argc);
351      int *res = ctx.keys_pos;
352      if (numkeys) *numkeys = ctx.keys_count;
353      moduleFreeContext(&amp;ctx);
354      return res;
355  }
356  int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
357      return (ctx-&gt;flags &amp; REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;
358  }
359  void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {
360      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_KEYS_POS_REQUEST)) return;
361      if (pos &lt;= 0) return;
362      ctx-&gt;keys_pos = zrealloc(ctx-&gt;keys_pos,sizeof(int)*((PORT_ULONG)ctx-&gt;keys_count+1));  WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
363      ctx-&gt;keys_pos[ctx-&gt;keys_count++] = pos;
364  }
365  int64_t commandFlagsFromString(char *s) {
366      int count, j;
367      int64_t flags = 0;
368      sds *tokens = sdssplitlen(s,strlen(s),&quot; &quot;,1,&amp;count);
369      for (j = 0; j &lt; count; j++) {
370          char *t = tokens[j];
371          if (!strcasecmp(t,&quot;write&quot;)) flags |= CMD_WRITE;
372          else if (!strcasecmp(t,&quot;readonly&quot;)) flags |= CMD_READONLY;
373          else if (!strcasecmp(t,&quot;admin&quot;)) flags |= CMD_ADMIN;
374          else if (!strcasecmp(t,&quot;deny-oom&quot;)) flags |= CMD_DENYOOM;
375          else if (!strcasecmp(t,&quot;deny-script&quot;)) flags |= CMD_NOSCRIPT;
376          else if (!strcasecmp(t,&quot;allow-loading&quot;)) flags |= CMD_LOADING;
377          else if (!strcasecmp(t,&quot;pubsub&quot;)) flags |= CMD_PUBSUB;
378          else if (!strcasecmp(t,&quot;random&quot;)) flags |= CMD_RANDOM;
379          else if (!strcasecmp(t,&quot;allow-stale&quot;)) flags |= CMD_STALE;
380          else if (!strcasecmp(t,&quot;no-monitor&quot;)) flags |= CMD_SKIP_MONITOR;
381          else if (!strcasecmp(t,&quot;fast&quot;)) flags |= CMD_FAST;
382          else if (!strcasecmp(t,&quot;getkeys-api&quot;)) flags |= CMD_MODULE_GETKEYS;
383          else if (!strcasecmp(t,&quot;no-cluster&quot;)) flags |= CMD_MODULE_NO_CLUSTER;
384          else break;
385      }
386      sdsfreesplitres(tokens,count);
387      if (j != count) return -1; &amp;bsol;* Some token not processed correctly. */
388      return flags;
389  }
390  int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
391      int64_t flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
392      if (flags == -1) return REDISMODULE_ERR;
393      if ((flags &amp; CMD_MODULE_NO_CLUSTER) &amp;&amp; server.cluster_enabled)
394          return REDISMODULE_ERR;
395      struct redisCommand *rediscmd;
396      RedisModuleCommandProxy *cp;
397      sds cmdname = sdsnew(name);
398      if (lookupCommand(cmdname) != NULL) {
399          sdsfree(cmdname);
400          return REDISMODULE_ERR;
401      }
402      cp = zmalloc(sizeof(*cp));
403      cp-&gt;module = ctx-&gt;module;
404      cp-&gt;func = cmdfunc;
405      cp-&gt;rediscmd = zmalloc(sizeof(*rediscmd));
406      cp-&gt;rediscmd-&gt;name = cmdname;
407      cp-&gt;rediscmd-&gt;proc = RedisModuleCommandDispatcher;
408      cp-&gt;rediscmd-&gt;arity = -1;
409      cp-&gt;rediscmd-&gt;flags = flags | CMD_MODULE;
410      cp-&gt;rediscmd-&gt;getkeys_proc = (redisGetKeysProc*) (PORT_ULONG)cp;
411      cp-&gt;rediscmd-&gt;firstkey = firstkey;
412      cp-&gt;rediscmd-&gt;lastkey = lastkey;
413      cp-&gt;rediscmd-&gt;keystep = keystep;
414      cp-&gt;rediscmd-&gt;microseconds = 0;
415      cp-&gt;rediscmd-&gt;calls = 0;
416      dictAdd(server.commands,sdsdup(cmdname),cp-&gt;rediscmd);
417      dictAdd(server.orig_commands,sdsdup(cmdname),cp-&gt;rediscmd);
418      return REDISMODULE_OK;
419  }
420  void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
421      RedisModule *module;
422      if (ctx-&gt;module != NULL) return;
423      module = zmalloc(sizeof(*module));
424      module-&gt;name = sdsnew((char*)name);
425      module-&gt;ver = ver;
426      module-&gt;apiver = apiver;
427      module-&gt;types = listCreate();
428      module-&gt;usedby = listCreate();
429      module-&gt;using = listCreate();
430      module-&gt;filters = listCreate();
431      module-&gt;in_call = 0;
432      ctx-&gt;module = module;
433  }
434  int RM_IsModuleNameBusy(const char *name) {
435      sds modulename = sdsnew(name);
436      dictEntry *de = dictFind(modules,modulename);
437      sdsfree(modulename);
438      return de != NULL;
439  }
440  PORT_LONGLONG RM_Milliseconds(void) {
441      return mstime();
442  }
443  void RM_AutoMemory(RedisModuleCtx *ctx) {
444      ctx-&gt;flags |= REDISMODULE_CTX_AUTO_MEMORY;
445  }
446  void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
447      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_AUTO_MEMORY)) return;
448      if (ctx-&gt;amqueue_used == ctx-&gt;amqueue_len) {
449          ctx-&gt;amqueue_len *= 2;
450          if (ctx-&gt;amqueue_len &lt; 16) ctx-&gt;amqueue_len = 16;
451          ctx-&gt;amqueue = zrealloc(ctx-&gt;amqueue,sizeof(struct AutoMemEntry)*ctx-&gt;amqueue_len);
452      }
453      ctx-&gt;amqueue[ctx-&gt;amqueue_used].type = type;
454      ctx-&gt;amqueue[ctx-&gt;amqueue_used].ptr = ptr;
455      ctx-&gt;amqueue_used++;
456  }
457  int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
458      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_AUTO_MEMORY)) return 0;
459      int count = (ctx-&gt;amqueue_used+1)/2;
460      for (int j = 0; j &lt; count; j++) {
461          for (int side = 0; side &lt; 2; side++) {
462              int i = (side == 0) ? (ctx-&gt;amqueue_used - 1 - j) : j;
463              if (ctx-&gt;amqueue[i].type == type &amp;&amp;
464                  ctx-&gt;amqueue[i].ptr == ptr)
465              {
466                  ctx-&gt;amqueue[i].type = REDISMODULE_AM_FREED;
467                  if (i != ctx-&gt;amqueue_used-1) {
468                      ctx-&gt;amqueue[i] = ctx-&gt;amqueue[ctx-&gt;amqueue_used-1];
469                  }
470                  ctx-&gt;amqueue_used--;
471                  return 1;
472              }
473          }
474      }
475      return 0;
476  }
477  void autoMemoryCollect(RedisModuleCtx *ctx) {
478      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_AUTO_MEMORY)) return;
479      ctx-&gt;flags &amp;= ~REDISMODULE_CTX_AUTO_MEMORY;
480      int j;
481      for (j = 0; j &lt; ctx-&gt;amqueue_used; j++) {
482          void *ptr = ctx-&gt;amqueue[j].ptr;
483          switch(ctx-&gt;amqueue[j].type) {
484          case REDISMODULE_AM_STRING: decrRefCount(ptr); break;
485          case REDISMODULE_AM_REPLY: RM_FreeCallReply(ptr); break;
486          case REDISMODULE_AM_KEY: RM_CloseKey(ptr); break;
487          case REDISMODULE_AM_DICT: RM_FreeDict(NULL,ptr); break;
488          }
489      }
490      ctx-&gt;flags |= REDISMODULE_CTX_AUTO_MEMORY;
491      zfree(ctx-&gt;amqueue);
492      ctx-&gt;amqueue = NULL;
493      ctx-&gt;amqueue_len = 0;
494      ctx-&gt;amqueue_used = 0;
495  }
496  RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {
497      RedisModuleString *o = createStringObject(ptr,len);
498      if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
499      return o;
500  }
501  RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {
502      sds s = sdsempty();
503      va_list ap;
504      va_start(ap, fmt);
505      s = sdscatvprintf(s, fmt, ap);
506      va_end(ap);
507      RedisModuleString *o = createObject(OBJ_STRING, s);
508      if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
509      return o;
510  }
511  RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, PORT_LONGLONG ll) {
512      char buf[LONG_STR_SIZE];
513      size_t len = ll2string(buf,sizeof(buf),ll);
514      return RM_CreateString(ctx,buf,len);
515  }
516  RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {
517      RedisModuleString *o = dupStringObject(str);
518      if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
519      return o;
520  }
521  void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {
522      decrRefCount(str);
523      if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);
524  }
525  void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {
526      if (ctx == NULL || !autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {
527          incrRefCount(str);
528      }
529  }
530  const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
531      if (str == NULL) {
532          const char *errmsg = &quot;(NULL string reply referenced in module)&quot;;
533          if (len) *len = strlen(errmsg);
534          return errmsg;
535      }
536      if (len) *len = sdslen(str-&gt;ptr);
537      return str-&gt;ptr;
538  }
539  int RM_StringToLongLong(const RedisModuleString *str, PORT_LONGLONG *ll) {
540      return string2ll(str-&gt;ptr,sdslen(str-&gt;ptr),ll) ? REDISMODULE_OK :
541                                                       REDISMODULE_ERR;
542  }
543  int RM_StringToDouble(const RedisModuleString *str, double *d) {
544      int retval = getDoubleFromObject(str,d);
545      return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
546  }
547  int RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {
548      return compareStringObjects(a,b);
549  }
550  RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
551      if (str-&gt;refcount != 1) {
552          serverLog(LL_WARNING,
553              &quot;Module attempted to use an in-place string modify operation &quot;
554              &quot;with a string referenced multiple times. Please check the code &quot;
555              &quot;for API usage correctness.&quot;);
556          return NULL;
557      }
558      if (str-&gt;encoding == OBJ_ENCODING_EMBSTR) {
559          str-&gt;ptr = sdsnewlen(str-&gt;ptr,sdslen(str-&gt;ptr));
560          str-&gt;encoding = OBJ_ENCODING_RAW;
561      } else if (str-&gt;encoding == OBJ_ENCODING_INT) {
562          str-&gt;ptr = sdsfromlonglong((PORT_LONG)str-&gt;ptr);
563          str-&gt;encoding = OBJ_ENCODING_RAW;
564      }
565      return str;
566  }
567  int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {
568      UNUSED(ctx);
569      str = moduleAssertUnsharedString(str);
570      if (str == NULL) return REDISMODULE_ERR;
571      str-&gt;ptr = sdscatlen(str-&gt;ptr,buf,len);
572      return REDISMODULE_OK;
573  }
574  int RM_WrongArity(RedisModuleCtx *ctx) {
575      addReplyErrorFormat(ctx-&gt;client,
576          &quot;wrong number of arguments for &#x27;%s&#x27; command&quot;,
577          (char*)ctx-&gt;client-&gt;argv[0]-&gt;ptr);
578      return REDISMODULE_OK;
579  }
580  client *moduleGetReplyClient(RedisModuleCtx *ctx) {
581      if (ctx-&gt;flags &amp; REDISMODULE_CTX_THREAD_SAFE) {
582          if (ctx-&gt;blocked_client)
583              return ctx-&gt;blocked_client-&gt;reply_client;
584          else
585              return NULL;
586      } else {
587          return ctx-&gt;client;
588      }
589  }
590  int RM_ReplyWithLongLong(RedisModuleCtx *ctx, PORT_LONGLONG ll) {
591      client *c = moduleGetReplyClient(ctx);
592      if (c == NULL) return REDISMODULE_OK;
593      addReplyLongLong(c,ll);
594      return REDISMODULE_OK;
595  }
596  int replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {
597      client *c = moduleGetReplyClient(ctx);
598      if (c == NULL) return REDISMODULE_OK;
599      sds strmsg = sdsnewlen(prefix,1);
600      strmsg = sdscat(strmsg,msg);
601      strmsg = sdscatlen(strmsg,&quot;\r\n&quot;,2);
602      addReplySds(c,strmsg);
603      return REDISMODULE_OK;
604  }
605  int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
606      return replyWithStatus(ctx,err,&quot;-&quot;);
607  }
608  int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
609      return replyWithStatus(ctx,msg,&quot;+&quot;);
610  }
611  int RM_ReplyWithArray(RedisModuleCtx *ctx, PORT_LONG len) {
612      client *c = moduleGetReplyClient(ctx);
613      if (c == NULL) return REDISMODULE_OK;
614      if (len == REDISMODULE_POSTPONED_ARRAY_LEN) {
615          ctx-&gt;postponed_arrays = zrealloc(ctx-&gt;postponed_arrays,sizeof(void*)*
616                  ((PORT_ULONG)ctx-&gt;postponed_arrays_count+1));  WIN_PORT_FIX &amp;bsol;* cast (PORT_ULONG) */
617          ctx-&gt;postponed_arrays[ctx-&gt;postponed_arrays_count] =
618              addDeferredMultiBulkLength(c);
619          ctx-&gt;postponed_arrays_count++;
620      } else {
621          addReplyMultiBulkLen(c,len);
622      }
623      return REDISMODULE_OK;
624  }
625  void RM_ReplySetArrayLength(RedisModuleCtx *ctx, PORT_LONG len) {
626      client *c = moduleGetReplyClient(ctx);
627      if (c == NULL) return;
628      if (ctx-&gt;postponed_arrays_count == 0) {
629          serverLog(LL_WARNING,
630              &quot;API misuse detected in module %s: &quot;
631              &quot;RedisModule_ReplySetArrayLength() called without previous &quot;
632              &quot;RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN) &quot;
633              &quot;call.&quot;, ctx-&gt;module-&gt;name);
634              return;
635      }
636      ctx-&gt;postponed_arrays_count--;
637      setDeferredMultiBulkLength(c,
638              ctx-&gt;postponed_arrays[ctx-&gt;postponed_arrays_count],
639              len);
640      if (ctx-&gt;postponed_arrays_count == 0) {
641          zfree(ctx-&gt;postponed_arrays);
642          ctx-&gt;postponed_arrays = NULL;
643      }
644  }
645  int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
646      client *c = moduleGetReplyClient(ctx);
647      if (c == NULL) return REDISMODULE_OK;
648      addReplyBulkCBuffer(c,(char*)buf,len);
649      return REDISMODULE_OK;
650  }
651  int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
652      client *c = moduleGetReplyClient(ctx);
653      if (c == NULL) return REDISMODULE_OK;
654      addReplyBulkCString(c,(char*)buf);
655      return REDISMODULE_OK;
656  }
657  int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
658      client *c = moduleGetReplyClient(ctx);
659      if (c == NULL) return REDISMODULE_OK;
660      addReplyBulk(c,str);
661      return REDISMODULE_OK;
662  }
663  int RM_ReplyWithNull(RedisModuleCtx *ctx) {
664      client *c = moduleGetReplyClient(ctx);
665      if (c == NULL) return REDISMODULE_OK;
666      addReply(c,shared.nullbulk);
667      return REDISMODULE_OK;
668  }
669  int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
670      client *c = moduleGetReplyClient(ctx);
671      if (c == NULL) return REDISMODULE_OK;
672      sds proto = sdsnewlen(reply-&gt;proto, reply-&gt;protolen);
673      addReplySds(c,proto);
674      return REDISMODULE_OK;
675  }
676  int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
677      client *c = moduleGetReplyClient(ctx);
678      if (c == NULL) return REDISMODULE_OK;
679      addReplyDouble(c,d);
680      return REDISMODULE_OK;
681  }
682  void moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {
683      if (ctx-&gt;client-&gt;flags &amp; (CLIENT_MULTI|CLIENT_LUA)) return;
684      if (ctx-&gt;flags &amp; REDISMODULE_CTX_MULTI_EMITTED) return;
685      if (ctx-&gt;flags &amp; REDISMODULE_CTX_THREAD_SAFE) return;
686      if (!(ctx-&gt;flags &amp; REDISMODULE_CTX_MODULE_COMMAND_CALL)) {
687          ctx-&gt;saved_oparray = server.also_propagate;
688          redisOpArrayInit(&amp;server.also_propagate);
689      }
690      execCommandPropagateMulti(ctx-&gt;client);
691      ctx-&gt;flags |= REDISMODULE_CTX_MULTI_EMITTED;
692  }
693  int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
694      struct redisCommand *cmd;
695      robj **argv = NULL;
696      int argc = 0, flags = 0, j;
697      va_list ap;
698      cmd = lookupCommandByCString((char*)cmdname);
699      if (!cmd) return REDISMODULE_ERR;
700      va_start(ap, fmt);
701      argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&amp;argc,&amp;flags,ap);
702      va_end(ap);
703      if (argv == NULL) return REDISMODULE_ERR;
704      int target = 0;
705      if (!(flags &amp; REDISMODULE_ARGV_NO_AOF)) target |= PROPAGATE_AOF;
706      if (!(flags &amp; REDISMODULE_ARGV_NO_REPLICAS)) target |= PROPAGATE_REPL;
707      if (ctx-&gt;flags &amp; REDISMODULE_CTX_THREAD_SAFE) {
708          propagate(cmd,ctx-&gt;client-&gt;db-&gt;id,argv,argc,target);
709      } else {
710          moduleReplicateMultiIfNeeded(ctx);
711          alsoPropagate(cmd,ctx-&gt;client-&gt;db-&gt;id,argv,argc,target);
712      }
713      for (j = 0; j &lt; argc; j++) decrRefCount(argv[j]);
714      zfree(argv);
715      server.dirty++;
716      return REDISMODULE_OK;
717  }
718  int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
719      alsoPropagate(ctx-&gt;client-&gt;cmd,ctx-&gt;client-&gt;db-&gt;id,
720          ctx-&gt;client-&gt;argv,ctx-&gt;client-&gt;argc,
721          PROPAGATE_AOF|PROPAGATE_REPL);
722      server.dirty++;
723      return REDISMODULE_OK;
724  }
725  PORT_ULONGLONG RM_GetClientId(RedisModuleCtx *ctx) {
726      if (ctx-&gt;client == NULL) return 0;
727      return ctx-&gt;client-&gt;id;
728  }
729  int RM_GetSelectedDb(RedisModuleCtx *ctx) {
730      return ctx-&gt;client-&gt;db-&gt;id;
731  }
732  int RM_GetContextFlags(RedisModuleCtx *ctx) {
733      int flags = 0;
734      if (ctx-&gt;client) {
735          if (ctx-&gt;client-&gt;flags &amp; CLIENT_LUA)
736           flags |= REDISMODULE_CTX_FLAGS_LUA;
737          if (ctx-&gt;client-&gt;flags &amp; CLIENT_MULTI)
738           flags |= REDISMODULE_CTX_FLAGS_MULTI;
739          if (ctx-&gt;client-&gt;flags &amp; CLIENT_MASTER)
740           flags |= REDISMODULE_CTX_FLAGS_REPLICATED;
741      }
742      if (server.cluster_enabled)
743          flags |= REDISMODULE_CTX_FLAGS_CLUSTER;
744      if (server.loading)
745          flags |= REDISMODULE_CTX_FLAGS_LOADING;
746      if (server.maxmemory &gt; 0) {
747          flags |= REDISMODULE_CTX_FLAGS_MAXMEMORY;
748          if (server.maxmemory_policy != MAXMEMORY_NO_EVICTION)
749              flags |= REDISMODULE_CTX_FLAGS_EVICT;
750      }
751      if (server.aof_state != AOF_OFF)
752          flags |= REDISMODULE_CTX_FLAGS_AOF;
753      if (server.saveparamslen &gt; 0)
754          flags |= REDISMODULE_CTX_FLAGS_RDB;
755      if (server.masterhost == NULL) {
756          flags |= REDISMODULE_CTX_FLAGS_MASTER;
757      } else {
758          flags |= REDISMODULE_CTX_FLAGS_SLAVE;
759          if (server.repl_slave_ro)
760              flags |= REDISMODULE_CTX_FLAGS_READONLY;
761          if (server.repl_state == REPL_STATE_CONNECT ||
762              server.repl_state == REPL_STATE_CONNECTING)
763          {
764              flags |= REDISMODULE_CTX_FLAGS_REPLICA_IS_CONNECTING;
765          } else if (server.repl_state == REPL_STATE_TRANSFER) {
766              flags |= REDISMODULE_CTX_FLAGS_REPLICA_IS_TRANSFERRING;
767          } else if (server.repl_state == REPL_STATE_CONNECTED) {
768              flags |= REDISMODULE_CTX_FLAGS_REPLICA_IS_ONLINE;
769          }
770          if (server.repl_state != REPL_STATE_CONNECTED)
771              flags |= REDISMODULE_CTX_FLAGS_REPLICA_IS_STALE;
772      }
773      float level;
774      int retval = getMaxmemoryState(NULL,NULL,NULL,&amp;level);
775      if (retval == C_ERR) flags |= REDISMODULE_CTX_FLAGS_OOM;
776      if (level &gt; 0.75) flags |= REDISMODULE_CTX_FLAGS_OOM_WARNING;
777      if (hasActiveChildProcess()) flags |= REDISMODULE_CTX_FLAGS_ACTIVE_CHILD;
778      return flags;
779  }
780  int RM_SelectDb(RedisModuleCtx *ctx, int newid) {
781      int retval = selectDb(ctx-&gt;client,newid);
782      return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
783  }
784  void *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {
785      RedisModuleKey *kp;
786      robj *value;
787      if (mode &amp; REDISMODULE_WRITE) {
788          value = lookupKeyWrite(ctx-&gt;client-&gt;db,keyname);
789      } else {
790          value = lookupKeyRead(ctx-&gt;client-&gt;db,keyname);
791          if (value == NULL) {
792              return NULL;
793          }
794      }
795      kp = zmalloc(sizeof(*kp));
796      kp-&gt;ctx = ctx;
797      kp-&gt;db = ctx-&gt;client-&gt;db;
798      kp-&gt;key = keyname;
799      incrRefCount(keyname);
800      kp-&gt;value = value;
801      kp-&gt;iter = NULL;
802      kp-&gt;mode = mode;
803      zsetKeyReset(kp);
804      autoMemoryAdd(ctx,REDISMODULE_AM_KEY,kp);
805      return (void*)kp;
806  }
807  void RM_CloseKey(RedisModuleKey *key) {
808      if (key == NULL) return;
809      if (key-&gt;mode &amp; REDISMODULE_WRITE) signalModifiedKey(key-&gt;db,key-&gt;key);
810      RM_ZsetRangeStop(key);
811      decrRefCount(key-&gt;key);
812      autoMemoryFreed(key-&gt;ctx,REDISMODULE_AM_KEY,key);
813      zfree(key);
814  }
815  int RM_KeyType(RedisModuleKey *key) {
816      if (key == NULL || key-&gt;value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;
817      switch(key-&gt;value-&gt;type) {
818      case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;
819      case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;
820      case OBJ_SET: return REDISMODULE_KEYTYPE_SET;
821      case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;
822      case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;
823      case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;
824      default: return 0;
825      }
826  }
827  size_t RM_ValueLength(RedisModuleKey *key) {
828      if (key == NULL || key-&gt;value == NULL) return 0;
829      switch(key-&gt;value-&gt;type) {
830      case OBJ_STRING: return stringObjectLen(key-&gt;value);
831      case OBJ_LIST: return listTypeLength(key-&gt;value);
832      case OBJ_SET: return setTypeSize(key-&gt;value);
833      case OBJ_ZSET: return zsetLength(key-&gt;value);
834      case OBJ_HASH: return hashTypeLength(key-&gt;value);
835      case OBJ_STREAM: return streamLength(key-&gt;value);
836      default: return 0;
837      }
838  }
839  int RM_DeleteKey(RedisModuleKey *key) {
840      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
841      if (key-&gt;value) {
842          dbDelete(key-&gt;db,key-&gt;key);
843          key-&gt;value = NULL;
844      }
845      return REDISMODULE_OK;
846  }
847  int RM_UnlinkKey(RedisModuleKey *key) {
848      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
849      if (key-&gt;value) {
850          dbAsyncDelete(key-&gt;db,key-&gt;key);
851          key-&gt;value = NULL;
852      }
853      return REDISMODULE_OK;
854  }
855  mstime_t RM_GetExpire(RedisModuleKey *key) {
856      mstime_t expire = getExpire(key-&gt;db,key-&gt;key);
857      if (expire == -1 || key-&gt;value == NULL) return -1;
858      expire -= mstime();
859      return expire &gt;= 0 ? expire : 0;
860  }
861  int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
862      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;value == NULL)
863          return REDISMODULE_ERR;
864      if (expire != REDISMODULE_NO_EXPIRE) {
865          expire += mstime();
866          setExpire(key-&gt;ctx-&gt;client,key-&gt;db,key-&gt;key,expire);
867      } else {
868          removeExpire(key-&gt;db,key-&gt;key);
869      }
870      return REDISMODULE_OK;
871  }
872  int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {
873      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;iter) return REDISMODULE_ERR;
874      RM_DeleteKey(key);
875      setKey(key-&gt;db,key-&gt;key,str);
876      key-&gt;value = str;
877      return REDISMODULE_OK;
878  }
879  char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
880      char *emptystring = &quot;&lt;dma-empty-string&gt;&quot;;
881      if (key-&gt;value == NULL) {
882          *len = 0;
883          return emptystring;
884      }
885      if (key-&gt;value-&gt;type != OBJ_STRING) return NULL;
886      if ((mode &amp; REDISMODULE_WRITE) || key-&gt;value-&gt;encoding != OBJ_ENCODING_RAW)
887          key-&gt;value = dbUnshareStringValue(key-&gt;db, key-&gt;key, key-&gt;value);
888      *len = sdslen(key-&gt;value-&gt;ptr);
889      return key-&gt;value-&gt;ptr;
890  }
891  int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
892      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
893      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_STRING) return REDISMODULE_ERR;
894      if (newlen &gt; 512*1024*1024) return REDISMODULE_ERR;
895      if (key-&gt;value == NULL &amp;&amp; newlen == 0) return REDISMODULE_OK;
896      if (key-&gt;value == NULL) {
897          robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));
898          setKey(key-&gt;db,key-&gt;key,o);
899          key-&gt;value = o;
900          decrRefCount(o);
901      } else {
902          key-&gt;value = dbUnshareStringValue(key-&gt;db, key-&gt;key, key-&gt;value);
903          size_t curlen = sdslen(key-&gt;value-&gt;ptr);
904          if (newlen &gt; curlen) {
905              key-&gt;value-&gt;ptr = sdsgrowzero(key-&gt;value-&gt;ptr,newlen);
906          } else if (newlen &lt; curlen) {
907              sdsrange(key-&gt;value-&gt;ptr,0,newlen-1);
908              if (sdslen(key-&gt;value-&gt;ptr) &lt; sdsavail(key-&gt;value-&gt;ptr))
909                  key-&gt;value-&gt;ptr = sdsRemoveFreeSpace(key-&gt;value-&gt;ptr);
910          }
911      }
912      return REDISMODULE_OK;
913  }
914  int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
915      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
916      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_LIST) return REDISMODULE_ERR;
917      if (key-&gt;value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);
918      listTypePush(key-&gt;value, ele,
919          (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);
920      return REDISMODULE_OK;
921  }
922  RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {
923      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) ||
924          key-&gt;value == NULL ||
925          key-&gt;value-&gt;type != OBJ_LIST) return NULL;
926      robj *ele = listTypePop(key-&gt;value,
927          (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);
928      robj *decoded = getDecodedObject(ele);
929      decrRefCount(ele);
930      moduleDelKeyIfEmpty(key);
931      autoMemoryAdd(key-&gt;ctx,REDISMODULE_AM_STRING,decoded);
932      return decoded;
933  }
934  int RM_ZsetAddFlagsToCoreFlags(int flags) {
935      int retflags = 0;
936      if (flags &amp; REDISMODULE_ZADD_XX) retflags |= ZADD_XX;
937      if (flags &amp; REDISMODULE_ZADD_NX) retflags |= ZADD_NX;
938      return retflags;
939  }
940  int RM_ZsetAddFlagsFromCoreFlags(int flags) {
941      int retflags = 0;
942      if (flags &amp; ZADD_ADDED) retflags |= REDISMODULE_ZADD_ADDED;
943      if (flags &amp; ZADD_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;
944      if (flags &amp; ZADD_NOP) retflags |= REDISMODULE_ZADD_NOP;
945      return retflags;
946  }
947  int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {
948      int flags = 0;
949      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
950      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
951      if (key-&gt;value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
952      if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);
953      if (zsetAdd(key-&gt;value,score,ele-&gt;ptr,&amp;flags,NULL) == 0) {
954          if (flagsptr) *flagsptr = 0;
955          return REDISMODULE_ERR;
956      }
957      if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);
958      return REDISMODULE_OK;
959  }
960  int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {
961      int flags = 0;
962      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
963      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
964      if (key-&gt;value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
965      if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);
966      flags |= ZADD_INCR;
967      if (zsetAdd(key-&gt;value,score,ele-&gt;ptr,&amp;flags,newscore) == 0) {
968          if (flagsptr) *flagsptr = 0;
969          return REDISMODULE_ERR;
970      }
971      if (flagsptr &amp;&amp; (*flagsptr &amp; ZADD_NAN)) {
972          *flagsptr = 0;
973          return REDISMODULE_ERR;
974      }
975      if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);
976      return REDISMODULE_OK;
977  }
978  int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
979      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return REDISMODULE_ERR;
980      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
981      if (key-&gt;value != NULL &amp;&amp; zsetDel(key-&gt;value,ele-&gt;ptr)) {
982          if (deleted) *deleted = 1;
983      } else {
984          if (deleted) *deleted = 0;
985      }
986      return REDISMODULE_OK;
987  }
988  int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {
989      if (key-&gt;value == NULL) return REDISMODULE_ERR;
990      if (key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
991      if (zsetScore(key-&gt;value,ele-&gt;ptr,score) == C_ERR) return REDISMODULE_ERR;
992      return REDISMODULE_OK;
993  }
994  void zsetKeyReset(RedisModuleKey *key) {
995      key-&gt;ztype = REDISMODULE_ZSET_RANGE_NONE;
996      key-&gt;zcurrent = NULL;
997      key-&gt;zer = 1;
998  }
999  void RM_ZsetRangeStop(RedisModuleKey *key) {
1000      if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX)
1001          zslFreeLexRange(&amp;key-&gt;zlrs);
1002      zsetKeyReset(key);
1003  }
1004  int RM_ZsetRangeEndReached(RedisModuleKey *key) {
1005      return key-&gt;zer;
1006  }
1007  int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {
1008      if (!key-&gt;value || key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
1009      RM_ZsetRangeStop(key);
1010      key-&gt;ztype = REDISMODULE_ZSET_RANGE_SCORE;
1011      key-&gt;zer = 0;
1012      zrangespec *zrs = &amp;key-&gt;zrs;
1013      zrs-&gt;min = min;
1014      zrs-&gt;max = max;
1015      zrs-&gt;minex = minex;
1016      zrs-&gt;maxex = maxex;
1017      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1018          key-&gt;zcurrent = first ? zzlFirstInRange(key-&gt;value-&gt;ptr,zrs) :
1019                                  zzlLastInRange(key-&gt;value-&gt;ptr,zrs);
1020      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1021          zset *zs = key-&gt;value-&gt;ptr;
1022          zskiplist *zsl = zs-&gt;zsl;
1023          key-&gt;zcurrent = first ? zslFirstInRange(zsl,zrs) :
1024                                  zslLastInRange(zsl,zrs);
1025      } else {
1026          serverPanic(&quot;Unsupported zset encoding&quot;);
1027      }
1028      if (key-&gt;zcurrent == NULL) key-&gt;zer = 1;
1029      return REDISMODULE_OK;
1030  }
1031  int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
1032      return zsetInitScoreRange(key,min,max,minex,maxex,1);
1033  }
1034  int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
1035      return zsetInitScoreRange(key,min,max,minex,maxex,0);
1036  }
1037  int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {
1038      if (!key-&gt;value || key-&gt;value-&gt;type != OBJ_ZSET) return REDISMODULE_ERR;
1039      RM_ZsetRangeStop(key);
1040      key-&gt;zer = 0;
1041      zlexrangespec *zlrs = &amp;key-&gt;zlrs;
1042      if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;
1043      key-&gt;ztype = REDISMODULE_ZSET_RANGE_LEX;
1044      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1045          key-&gt;zcurrent = first ? zzlFirstInLexRange(key-&gt;value-&gt;ptr,zlrs) :
1046                                  zzlLastInLexRange(key-&gt;value-&gt;ptr,zlrs);
1047      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1048          zset *zs = key-&gt;value-&gt;ptr;
1049          zskiplist *zsl = zs-&gt;zsl;
1050          key-&gt;zcurrent = first ? zslFirstInLexRange(zsl,zlrs) :
1051                                  zslLastInLexRange(zsl,zlrs);
1052      } else {
1053          serverPanic(&quot;Unsupported zset encoding&quot;);
1054      }
1055      if (key-&gt;zcurrent == NULL) key-&gt;zer = 1;
1056      return REDISMODULE_OK;
1057  }
1058  int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
1059      return zsetInitLexRange(key,min,max,1);
1060  }
1061  int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
1062      return zsetInitLexRange(key,min,max,0);
1063  }
1064  RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {
1065      RedisModuleString *str;
1066      if (key-&gt;zcurrent == NULL) return NULL;
1067      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1068          unsigned char *eptr, *sptr;
1069          eptr = key-&gt;zcurrent;
1070          sds ele = ziplistGetObject(eptr);
1071          if (score) {
1072              sptr = ziplistNext(key-&gt;value-&gt;ptr,eptr);
1073              *score = zzlGetScore(sptr);
1074          }
1075          str = createObject(OBJ_STRING,ele);
1076      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1077          zskiplistNode *ln = key-&gt;zcurrent;
1078          if (score) *score = ln-&gt;score;
1079          str = createStringObject(ln-&gt;ele,sdslen(ln-&gt;ele));
1080      } else {
1081          serverPanic(&quot;Unsupported zset encoding&quot;);
1082      }
1083      autoMemoryAdd(key-&gt;ctx,REDISMODULE_AM_STRING,str);
1084      return str;
1085  }
1086  int RM_ZsetRangeNext(RedisModuleKey *key) {
1087      if (!key-&gt;ztype || !key-&gt;zcurrent) return 0; &amp;bsol;* No active iterator. */
1088      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1089          unsigned char *zl = key-&gt;value-&gt;ptr;
1090          unsigned char *eptr = key-&gt;zcurrent;
1091          unsigned char *next;
1092          next = ziplistNext(zl,eptr); &amp;bsol;* Skip element. */
1093          if (next) next = ziplistNext(zl,next); &amp;bsol;* Skip score. */
1094          if (next == NULL) {
1095              key-&gt;zer = 1;
1096              return 0;
1097          } else {
1098              if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_SCORE) {
1099                  unsigned char *saved_next = next;
1100                  next = ziplistNext(zl,next); &amp;bsol;* Skip next element. */
1101                  double score = zzlGetScore(next); &amp;bsol;* Obtain the next score. */
1102                  if (!zslValueLteMax(score,&amp;key-&gt;zrs)) {
1103                      key-&gt;zer = 1;
1104                      return 0;
1105                  }
1106                  next = saved_next;
1107              } else if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX) {
1108                  if (!zzlLexValueLteMax(next,&amp;key-&gt;zlrs)) {
1109                      key-&gt;zer = 1;
1110                      return 0;
1111                  }
1112              }
1113              key-&gt;zcurrent = next;
1114              return 1;
1115          }
1116      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1117          zskiplistNode *ln = key-&gt;zcurrent, *next = ln-&gt;level[0].forward;
1118          if (next == NULL) {
1119              key-&gt;zer = 1;
1120              return 0;
1121          } else {
1122              if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_SCORE &amp;&amp;
1123                  !zslValueLteMax(next-&gt;score,&amp;key-&gt;zrs))
1124              {
1125                  key-&gt;zer = 1;
1126                  return 0;
1127              } else if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX) {
1128                  if (!zslLexValueLteMax(next-&gt;ele,&amp;key-&gt;zlrs)) {
1129                      key-&gt;zer = 1;
1130                      return 0;
1131                  }
1132              }
1133              key-&gt;zcurrent = next;
1134              return 1;
1135          }
1136      } else {
1137          serverPanic(&quot;Unsupported zset encoding&quot;);
1138      }
1139  }
1140  int RM_ZsetRangePrev(RedisModuleKey *key) {
1141      if (!key-&gt;ztype || !key-&gt;zcurrent) return 0; &amp;bsol;* No active iterator. */
1142      if (key-&gt;value-&gt;encoding == OBJ_ENCODING_ZIPLIST) {
1143          unsigned char *zl = key-&gt;value-&gt;ptr;
1144          unsigned char *eptr = key-&gt;zcurrent;
1145          unsigned char *prev;
1146          prev = ziplistPrev(zl,eptr); &amp;bsol;* Go back to previous score. */
1147          if (prev) prev = ziplistPrev(zl,prev); &amp;bsol;* Back to previous ele. */
1148          if (prev == NULL) {
1149              key-&gt;zer = 1;
1150              return 0;
1151          } else {
1152              if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_SCORE) {
1153                  unsigned char *saved_prev = prev;
1154                  prev = ziplistNext(zl,prev); &amp;bsol;* Skip element to get the score.*/
1155                  double score = zzlGetScore(prev); &amp;bsol;* Obtain the prev score. */
1156                  if (!zslValueGteMin(score,&amp;key-&gt;zrs)) {
1157                      key-&gt;zer = 1;
1158                      return 0;
1159                  }
1160                  prev = saved_prev;
1161              } else if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX) {
1162                  if (!zzlLexValueGteMin(prev,&amp;key-&gt;zlrs)) {
1163                      key-&gt;zer = 1;
1164                      return 0;
1165                  }
1166              }
<span onclick='openModal()' class='match'>1167              key-&gt;zcurrent = prev;
1168              return 1;
1169          }
1170      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1171          zskiplistNode *ln = key-&gt;zcurrent, *prev = ln-&gt;backward;
</span>1172          if (prev == NULL) {
1173              key-&gt;zer = 1;
1174              return 0;
1175          } else {
1176              if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_SCORE &amp;&amp;
1177                  !zslValueGteMin(prev-&gt;score,&amp;key-&gt;zrs))
1178              {
1179                  key-&gt;zer = 1;
1180                  return 0;
1181              } else if (key-&gt;ztype == REDISMODULE_ZSET_RANGE_LEX) {
1182                  if (!zslLexValueGteMin(prev-&gt;ele,&amp;key-&gt;zlrs)) {
1183                      key-&gt;zer = 1;
1184                      return 0;
1185                  }
1186              }
1187              key-&gt;zcurrent = prev;
1188              return 1;
1189          }
1190      } else {
1191          serverPanic(&quot;Unsupported zset encoding&quot;);
1192      }
1193  }
1194  int RM_HashSet(RedisModuleKey *key, int flags, ...) {
1195      va_list ap;
1196      if (!(key-&gt;mode &amp; REDISMODULE_WRITE)) return 0;
1197      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_HASH) return 0;
1198      if (key-&gt;value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);
1199      int updated = 0;
1200      va_start(ap, flags);
1201      while(1) {
1202          RedisModuleString *field, *value;
1203          if (flags &amp; REDISMODULE_HASH_CFIELDS) {
1204              char *cfield = va_arg(ap,char*);
1205              if (cfield == NULL) break;
1206              field = createRawStringObject(cfield,strlen(cfield));
1207          } else {
1208              field = va_arg(ap,RedisModuleString*);
1209              if (field == NULL) break;
1210          }
1211          value = va_arg(ap,RedisModuleString*);
1212          if (flags &amp; (REDISMODULE_HASH_XX|REDISMODULE_HASH_NX)) {
1213              int exists = hashTypeExists(key-&gt;value, field-&gt;ptr);
1214              if (((flags &amp; REDISMODULE_HASH_XX) &amp;&amp; !exists) ||
1215                  ((flags &amp; REDISMODULE_HASH_NX) &amp;&amp; exists))
1216              {
1217                  if (flags &amp; REDISMODULE_HASH_CFIELDS) decrRefCount(field);
1218                  continue;
1219              }
1220          }
1221          if (value == REDISMODULE_HASH_DELETE) {
1222              updated += hashTypeDelete(key-&gt;value, field-&gt;ptr);
1223              if (flags &amp; REDISMODULE_HASH_CFIELDS) decrRefCount(field);
1224              continue;
1225          }
1226          int low_flags = HASH_SET_COPY;
1227          if (flags &amp; REDISMODULE_HASH_CFIELDS)
1228              low_flags |= HASH_SET_TAKE_FIELD;
1229          robj *argv[2] = {field,value};
1230          hashTypeTryConversion(key-&gt;value,argv,0,1);
1231          updated += hashTypeSet(key-&gt;value, field-&gt;ptr, value-&gt;ptr, low_flags);
1232          if (flags &amp; REDISMODULE_HASH_CFIELDS) {
1233             field-&gt;ptr = NULL; &amp;bsol;* Prevent the SDS string from being freed. */
1234             decrRefCount(field);
1235          }
1236      }
1237      va_end(ap);
1238      moduleDelKeyIfEmpty(key);
1239      return updated;
1240  }
1241  int RM_HashGet(RedisModuleKey *key, int flags, ...) {
1242      va_list ap;
1243      if (key-&gt;value &amp;&amp; key-&gt;value-&gt;type != OBJ_HASH) return REDISMODULE_ERR;
1244      va_start(ap, flags);
1245      while(1) {
1246          RedisModuleString *field, **valueptr;
1247          int *existsptr;
1248          if (flags &amp; REDISMODULE_HASH_CFIELDS) {
1249              char *cfield = va_arg(ap,char*);
1250              if (cfield == NULL) break;
1251              field = createRawStringObject(cfield,strlen(cfield));
1252          } else {
1253              field = va_arg(ap,RedisModuleString*);
1254              if (field == NULL) break;
1255          }
1256          if (flags &amp; REDISMODULE_HASH_EXISTS) {
1257              existsptr = va_arg(ap,int*);
1258              if (key-&gt;value)
1259                  *existsptr = hashTypeExists(key-&gt;value,field-&gt;ptr);
1260              else
1261                  *existsptr = 0;
1262          } else {
1263              valueptr = va_arg(ap,RedisModuleString**);
1264              if (key-&gt;value) {
1265                  *valueptr = hashTypeGetValueObject(key-&gt;value,field-&gt;ptr);
1266                  if (*valueptr) {
1267                      robj *decoded = getDecodedObject(*valueptr);
1268                      decrRefCount(*valueptr);
1269                      *valueptr = decoded;
1270                  }
1271                  if (*valueptr)
1272                      autoMemoryAdd(key-&gt;ctx,REDISMODULE_AM_STRING,*valueptr);
1273              } else {
1274                  *valueptr = NULL;
1275              }
1276          }
1277          if (flags &amp; REDISMODULE_HASH_CFIELDS) decrRefCount(field);
1278      }
1279      va_end(ap);
1280      return REDISMODULE_OK;
1281  }
1282  RedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds proto) {
1283      RedisModuleCallReply *reply = zmalloc(sizeof(*reply));
1284      reply-&gt;ctx = ctx;
1285      reply-&gt;proto = proto;
1286      reply-&gt;protolen = sdslen(proto);
1287      reply-&gt;flags = REDISMODULE_REPLYFLAG_TOPARSE; &amp;bsol;* Lazy parsing. */
1288      switch(proto[0]) {
1289      case &#x27;$&#x27;:
1290      case &#x27;+&#x27;: reply-&gt;type = REDISMODULE_REPLY_STRING; break;
1291      case &#x27;-&#x27;: reply-&gt;type = REDISMODULE_REPLY_ERROR; break;
1292      case &#x27;:&#x27;: reply-&gt;type = REDISMODULE_REPLY_INTEGER; break;
1293      case &#x27;*&#x27;: reply-&gt;type = REDISMODULE_REPLY_ARRAY; break;
1294      default: reply-&gt;type = REDISMODULE_REPLY_UNKNOWN; break;
1295      }
1296      if ((proto[0] == &#x27;*&#x27; || proto[0] == &#x27;$&#x27;) &amp;&amp; proto[1] == &#x27;-&#x27;)
1297          reply-&gt;type = REDISMODULE_REPLY_NULL;
1298      return reply;
1299  }
1300  void moduleParseCallReply_Int(RedisModuleCallReply *reply);
1301  void moduleParseCallReply_BulkString(RedisModuleCallReply *reply);
1302  void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply);
1303  void moduleParseCallReply_Array(RedisModuleCallReply *reply);
1304  void moduleParseCallReply(RedisModuleCallReply *reply) {
1305      if (!(reply-&gt;flags &amp; REDISMODULE_REPLYFLAG_TOPARSE)) return;
1306      reply-&gt;flags &amp;= ~REDISMODULE_REPLYFLAG_TOPARSE;
1307      switch(reply-&gt;proto[0]) {
1308      case &#x27;:&#x27;: moduleParseCallReply_Int(reply); break;
1309      case &#x27;$&#x27;: moduleParseCallReply_BulkString(reply); break;
1310      case &#x27;-&#x27;: &amp;bsol;* handled by next item. */
1311      case &#x27;+&#x27;: moduleParseCallReply_SimpleString(reply); break;
1312      case &#x27;*&#x27;: moduleParseCallReply_Array(reply); break;
1313      }
1314  }
1315  void moduleParseCallReply_Int(RedisModuleCallReply *reply) {
1316      char *proto = reply-&gt;proto;
1317      char *p = strchr(proto+1,&#x27;\r&#x27;);
1318      string2ll(proto+1,p-proto-1,&amp;reply-&gt;val.ll);
1319      reply-&gt;protolen = p-proto+2;
1320      reply-&gt;type = REDISMODULE_REPLY_INTEGER;
1321  }
1322  void moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {
1323      char *proto = reply-&gt;proto;
1324      char *p = strchr(proto+1,&#x27;\r&#x27;);
1325      PORT_LONGLONG bulklen;
1326      string2ll(proto+1,p-proto-1,&amp;bulklen);
1327      if (bulklen == -1) {
1328          reply-&gt;protolen = p-proto+2;
1329          reply-&gt;type = REDISMODULE_REPLY_NULL;
1330      } else {
1331          reply-&gt;val.str = p+2;
1332          reply-&gt;len = bulklen;
1333          reply-&gt;protolen = p-proto+2+bulklen+2;
1334          reply-&gt;type = REDISMODULE_REPLY_STRING;
1335      }
1336  }
1337  void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {
1338      char *proto = reply-&gt;proto;
1339      char *p = strchr(proto+1,&#x27;\r&#x27;);
1340      reply-&gt;val.str = proto+1;
1341      reply-&gt;len = p-proto-1;
1342      reply-&gt;protolen = p-proto+2;
1343      reply-&gt;type = proto[0] == &#x27;+&#x27; ? REDISMODULE_REPLY_STRING :
1344                                      REDISMODULE_REPLY_ERROR;
1345  }
1346  void moduleParseCallReply_Array(RedisModuleCallReply *reply) {
1347      char *proto = reply-&gt;proto;
1348      char *p = strchr(proto+1,&#x27;\r&#x27;);
1349      PORT_LONGLONG arraylen, j;
1350      string2ll(proto+1,p-proto-1,&amp;arraylen);
1351      p += 2;
1352      if (arraylen == -1) {
1353          reply-&gt;protolen = p-proto;
1354          reply-&gt;type = REDISMODULE_REPLY_NULL;
1355          return;
1356      }
1357      reply-&gt;val.array = zmalloc(sizeof(RedisModuleCallReply)*arraylen);
1358      reply-&gt;len = arraylen;
1359      for (j = 0; j &lt; arraylen; j++) {
1360          RedisModuleCallReply *ele = reply-&gt;val.array+j;
1361          ele-&gt;flags = REDISMODULE_REPLYFLAG_NESTED |
1362                       REDISMODULE_REPLYFLAG_TOPARSE;
1363          ele-&gt;proto = p;
1364          ele-&gt;ctx = reply-&gt;ctx;
1365          moduleParseCallReply(ele);
1366          p += ele-&gt;protolen;
1367      }
1368      reply-&gt;protolen = p-proto;
1369      reply-&gt;type = REDISMODULE_REPLY_ARRAY;
1370  }
1371  void RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){
1372      if (!freenested &amp;&amp; reply-&gt;flags &amp; REDISMODULE_REPLYFLAG_NESTED) return;
1373      if (!(reply-&gt;flags &amp; REDISMODULE_REPLYFLAG_TOPARSE)) {
1374          if (reply-&gt;type == REDISMODULE_REPLY_ARRAY) {
1375              size_t j;
1376              for (j = 0; j &lt; reply-&gt;len; j++)
1377                  RM_FreeCallReply_Rec(reply-&gt;val.array+j,1);
1378              zfree(reply-&gt;val.array);
1379          }
1380      }
1381      if (!(reply-&gt;flags &amp; REDISMODULE_REPLYFLAG_NESTED)) {
1382          if (reply-&gt;proto) sdsfree(reply-&gt;proto);
1383          zfree(reply);
1384      }
1385  }
1386  void RM_FreeCallReply(RedisModuleCallReply *reply) {
1387      RedisModuleCtx *ctx = reply-&gt;ctx;
1388      RM_FreeCallReply_Rec(reply,0);
1389      autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);
1390  }
1391  int RM_CallReplyType(RedisModuleCallReply *reply) {
1392      if (!reply) return REDISMODULE_REPLY_UNKNOWN;
1393      return reply-&gt;type;
1394  }
1395  size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
1396      moduleParseCallReply(reply);
1397      switch(reply-&gt;type) {
1398      case REDISMODULE_REPLY_STRING:
1399      case REDISMODULE_REPLY_ERROR:
1400      case REDISMODULE_REPLY_ARRAY:
1401          return reply-&gt;len;
1402      default:
1403          return 0;
1404      }
1405  }
1406  RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {
1407      moduleParseCallReply(reply);
1408      if (reply-&gt;type != REDISMODULE_REPLY_ARRAY) return NULL;
1409      if (idx &gt;= reply-&gt;len) return NULL;
1410      return reply-&gt;val.array+idx;
1411  }
1412  PORT_LONGLONG RM_CallReplyInteger(RedisModuleCallReply *reply) {
1413      moduleParseCallReply(reply);
1414      if (reply-&gt;type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;
1415      return reply-&gt;val.ll;
1416  }
1417  const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {
1418      moduleParseCallReply(reply);
1419      if (reply-&gt;type != REDISMODULE_REPLY_STRING &amp;&amp;
1420          reply-&gt;type != REDISMODULE_REPLY_ERROR) return NULL;
1421      if (len) *len = reply-&gt;len;
1422      return reply-&gt;val.str;
1423  }
1424  RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {
1425      moduleParseCallReply(reply);
1426      switch(reply-&gt;type) {
1427      case REDISMODULE_REPLY_STRING:
1428      case REDISMODULE_REPLY_ERROR:
1429          return RM_CreateString(reply-&gt;ctx,reply-&gt;val.str,reply-&gt;len);
1430      case REDISMODULE_REPLY_INTEGER: {
1431          char buf[64];
1432          int len = ll2string(buf,sizeof(buf),reply-&gt;val.ll);
1433          return RM_CreateString(reply-&gt;ctx,buf,len);
1434          }
1435      default: return NULL;
1436      }
1437  }
1438  robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {
1439      int argc = 0, argv_size, j;
1440      robj **argv = NULL;
1441      argv_size = strlen(fmt)+1; &amp;bsol;* +1 because of the command name. */
1442      argv = zrealloc(argv,sizeof(robj*)*argv_size);
1443      argv[0] = createStringObject(cmdname,strlen(cmdname));
1444      argc++;
1445      const char *p = fmt;
1446      while(*p) {
1447          if (*p == &#x27;c&#x27;) {
1448              char *cstr = va_arg(ap,char*);
1449              argv[argc++] = createStringObject(cstr,strlen(cstr));
1450          } else if (*p == &#x27;s&#x27;) {
1451              robj *obj = va_arg(ap,void*);
1452              argv[argc++] = obj;
1453              incrRefCount(obj);
1454          } else if (*p == &#x27;b&#x27;) {
1455              char *buf = va_arg(ap,char*);
1456              size_t len = va_arg(ap,size_t);
1457              argv[argc++] = createStringObject(buf,len);
1458          } else if (*p == &#x27;l&#x27;) {
1459              PORT_LONG ll = va_arg(ap,PORT_LONGLONG);
1460              argv[argc++] = createObject(OBJ_STRING,sdsfromlonglong(ll));
1461          } else if (*p == &#x27;v&#x27;) {
1462               robj **v = va_arg(ap, void*);
1463               size_t vlen = va_arg(ap, size_t);
1464               argv_size += vlen-1;
1465               argv = zrealloc(argv,sizeof(robj*)*argv_size);
1466               size_t i = 0;
1467               for (i = 0; i &lt; vlen; i++) {
1468                   incrRefCount(v[i]);
1469                   argv[argc++] = v[i];
1470               }
1471          } else if (*p == &#x27;!&#x27;) {
1472              if (flags) (*flags) |= REDISMODULE_ARGV_REPLICATE;
1473          } else if (*p == &#x27;A&#x27;) {
1474              if (flags) (*flags) |= REDISMODULE_ARGV_NO_AOF;
1475          } else if (*p == &#x27;R&#x27;) {
1476              if (flags) (*flags) |= REDISMODULE_ARGV_NO_REPLICAS;
1477          } else {
1478              goto fmterr;
1479          }
1480          p++;
1481      }
1482      *argcp = argc;
1483      return argv;
1484  fmterr:
1485      for (j = 0; j &lt; argc; j++)
1486          decrRefCount(argv[j]);
1487      zfree(argv);
1488      return NULL;
1489  }
1490  RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
1491      struct redisCommand *cmd;
1492      client *c = NULL;
1493      robj **argv = NULL;
1494      int argc = 0, flags = 0;
1495      va_list ap;
1496      RedisModuleCallReply *reply = NULL;
1497      int replicate = 0; &amp;bsol;* Replicate this command? */
1498      va_start(ap, fmt);
1499      c = createClient(-1);
1500      argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&amp;argc,&amp;flags,ap);
1501      replicate = flags &amp; REDISMODULE_ARGV_REPLICATE;
1502      va_end(ap);
1503      c-&gt;flags |= CLIENT_MODULE;
1504      c-&gt;db = ctx-&gt;client-&gt;db;
1505      c-&gt;argv = argv;
1506      c-&gt;argc = argc;
1507      if (ctx-&gt;module) ctx-&gt;module-&gt;in_call++;
1508      if (argv == NULL) goto cleanup;
1509      moduleCallCommandFilters(c);
1510      cmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);
1511      if (!cmd) {
1512          errno = EINVAL;
1513          goto cleanup;
1514      }
1515      c-&gt;cmd = c-&gt;lastcmd = cmd;
1516      if ((cmd-&gt;arity &gt; 0 &amp;&amp; cmd-&gt;arity != argc) || (argc &lt; -cmd-&gt;arity)) {
1517          errno = EINVAL;
1518          goto cleanup;
1519      }
1520      if (server.cluster_enabled &amp;&amp; !(ctx-&gt;client-&gt;flags &amp; CLIENT_MASTER)) {
1521          c-&gt;flags &amp;= ~(CLIENT_READONLY|CLIENT_ASKING);
1522          c-&gt;flags |= ctx-&gt;client-&gt;flags &amp; (CLIENT_READONLY|CLIENT_ASKING);
1523          if (getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,NULL,NULL) !=
1524                             server.cluster-&gt;myself)
1525          {
1526              errno = EPERM;
1527              goto cleanup;
1528          }
1529      }
1530      if (replicate) moduleReplicateMultiIfNeeded(ctx);
1531      int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;
1532      if (replicate) {
1533          if (!(flags &amp; REDISMODULE_ARGV_NO_AOF))
1534              call_flags |= CMD_CALL_PROPAGATE_AOF;
1535          if (!(flags &amp; REDISMODULE_ARGV_NO_REPLICAS))
1536              call_flags |= CMD_CALL_PROPAGATE_REPL;
1537      }
1538      call(c,call_flags);
1539      sds proto = sdsnewlen(c-&gt;buf,c-&gt;bufpos);
1540      c-&gt;bufpos = 0;
1541      while(listLength(c-&gt;reply)) {
1542          clientReplyBlock *o = listNodeValue(listFirst(c-&gt;reply));
1543          proto = sdscatlen(proto,o-&gt;buf,o-&gt;used);
1544          listDelNode(c-&gt;reply,listFirst(c-&gt;reply));
1545      }
1546      reply = moduleCreateCallReplyFromProto(ctx,proto);
1547      autoMemoryAdd(ctx,REDISMODULE_AM_REPLY,reply);
1548  cleanup:
1549      if (ctx-&gt;module) ctx-&gt;module-&gt;in_call--;
1550      freeClient(c);
1551      return reply;
1552  }
1553  const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {
1554      if (reply-&gt;proto) *len = sdslen(reply-&gt;proto);
1555      return reply-&gt;proto;
1556  }
1557  const char *ModuleTypeNameCharSet =
1558               &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
1559               &quot;abcdefghijklmnopqrstuvwxyz&quot;
1560               &quot;0123456789-_&quot;;
1561  uint64_t moduleTypeEncodeId(const char *name, int encver) {
1562      const char *cset = ModuleTypeNameCharSet;
1563      if (strlen(name) != 9) return 0;
1564      if (encver &lt; 0 || encver &gt; 1023) return 0;
1565      uint64_t id = 0;
1566      for (int j = 0; j &lt; 9; j++) {
1567          char *p = strchr(cset,name[j]);
1568          if (!p) return 0;
1569          PORT_ULONG pos = p-cset;
1570          id = (id &lt;&lt; 6) | pos;
1571      }
1572      id = (id &lt;&lt; 10) | encver;
1573      return id;
1574  }
1575  moduleType *moduleTypeLookupModuleByName(const char *name) {
1576      dictIterator *di = dictGetIterator(modules);
1577      dictEntry *de;
1578      while ((de = dictNext(di)) != NULL) {
1579          struct RedisModule *module = dictGetVal(de);
1580          listIter li;
1581          listNode *ln;
1582          listRewind(module-&gt;types,&amp;li);
1583          while((ln = listNext(&amp;li))) {
1584              moduleType *mt = ln-&gt;value;
1585              if (memcmp(name,mt-&gt;name,sizeof(mt-&gt;name)) == 0) {
1586                  dictReleaseIterator(di);
1587                  return mt;
1588              }
1589          }
1590      }
1591      dictReleaseIterator(di);
1592      return NULL;
1593  }
1594  #define MODULE_LOOKUP_CACHE_SIZE 3
1595  moduleType *moduleTypeLookupModuleByID(uint64_t id) {
1596      static struct {
1597          uint64_t id;
1598          moduleType *mt;
1599      } cache[MODULE_LOOKUP_CACHE_SIZE];
1600      int j;
1601      for (j = 0; j &lt; MODULE_LOOKUP_CACHE_SIZE &amp;&amp; cache[j].mt != NULL; j++)
1602          if (cache[j].id == id) return cache[j].mt;
1603      moduleType *mt = NULL;
1604      dictIterator *di = dictGetIterator(modules);
1605      dictEntry *de;
1606      while ((de = dictNext(di)) != NULL &amp;&amp; mt == NULL) {
1607          struct RedisModule *module = dictGetVal(de);
1608          listIter li;
1609          listNode *ln;
1610          listRewind(module-&gt;types,&amp;li);
1611          while((ln = listNext(&amp;li))) {
1612              moduleType *this_mt = ln-&gt;value;
1613              if (this_mt-&gt;id &gt;&gt; 10 == id &gt;&gt; 10) {
1614                  mt = this_mt;
1615                  break;
1616              }
1617          }
1618      }
1619      dictReleaseIterator(di);
1620      if (mt &amp;&amp; j &lt; MODULE_LOOKUP_CACHE_SIZE) {
1621          cache[j].id = id;
1622          cache[j].mt = mt;
1623      }
1624      return mt;
1625  }
1626  void moduleTypeNameByID(char *name, uint64_t moduleid) {
1627      const char *cset = ModuleTypeNameCharSet;
1628      name[9] = &#x27;\0&#x27;;
1629      char *p = name+8;
1630      moduleid &gt;&gt;= 10;
1631      for (int j = 0; j &lt; 9; j++) {
1632          *p-- = cset[moduleid &amp; 63];
1633          moduleid &gt;&gt;= 6;
1634      }
1635  }
1636  moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {
1637      uint64_t id = moduleTypeEncodeId(name,encver);
1638      if (id == 0) return NULL;
1639      if (moduleTypeLookupModuleByName(name) != NULL) return NULL;
1640      PORT_LONG typemethods_version = ((PORT_LONG*)typemethods_ptr)[0];
1641      if (typemethods_version == 0) return NULL;
1642      struct typemethods {
1643          uint64_t version;
1644          moduleTypeLoadFunc rdb_load;
1645          moduleTypeSaveFunc rdb_save;
1646          moduleTypeRewriteFunc aof_rewrite;
1647          moduleTypeMemUsageFunc mem_usage;
1648          moduleTypeDigestFunc digest;
1649          moduleTypeFreeFunc free;
1650          struct {
1651              moduleTypeAuxLoadFunc aux_load;
1652              moduleTypeAuxSaveFunc aux_save;
1653              int aux_save_triggers;
1654          } v2;
1655      } *tms = (struct typemethods*) typemethods_ptr;
1656      moduleType *mt = zcalloc(sizeof(*mt));
1657      mt-&gt;id = id;
1658      mt-&gt;module = ctx-&gt;module;
1659      mt-&gt;rdb_load = tms-&gt;rdb_load;
1660      mt-&gt;rdb_save = tms-&gt;rdb_save;
1661      mt-&gt;aof_rewrite = tms-&gt;aof_rewrite;
1662      mt-&gt;mem_usage = tms-&gt;mem_usage;
1663      mt-&gt;digest = tms-&gt;digest;
1664      mt-&gt;free = tms-&gt;free;
1665      if (tms-&gt;version &gt;= 2) {
1666          mt-&gt;aux_load = tms-&gt;v2.aux_load;
1667          mt-&gt;aux_save = tms-&gt;v2.aux_save;
1668          mt-&gt;aux_save_triggers = tms-&gt;v2.aux_save_triggers;
1669      }
1670      memcpy(mt-&gt;name,name,sizeof(mt-&gt;name));
1671      listAddNodeTail(ctx-&gt;module-&gt;types,mt);
1672      return mt;
1673  }
1674  int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
1675      if (!(key-&gt;mode &amp; REDISMODULE_WRITE) || key-&gt;iter) return REDISMODULE_ERR;
1676      RM_DeleteKey(key);
1677      robj *o = createModuleObject(mt,value);
1678      setKey(key-&gt;db,key-&gt;key,o);
1679      decrRefCount(o);
1680      key-&gt;value = o;
1681      return REDISMODULE_OK;
1682  }
1683  moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
1684      if (key == NULL ||
1685          key-&gt;value == NULL ||
1686          RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
1687      moduleValue *mv = key-&gt;value-&gt;ptr;
1688      return mv-&gt;type;
1689  }
1690  void *RM_ModuleTypeGetValue(RedisModuleKey *key) {
1691      if (key == NULL ||
1692          key-&gt;value == NULL ||
1693          RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
1694      moduleValue *mv = key-&gt;value-&gt;ptr;
1695      return mv-&gt;value;
1696  }
1697  void moduleRDBLoadError(RedisModuleIO *io) {
1698      serverLog(LL_WARNING,
1699          &quot;Error loading data from RDB (short read or EOF). &quot;
1700          &quot;Read performed by module &#x27;%s&#x27; about type &#x27;%s&#x27; &quot;
1701          &quot;after reading &#x27;%llu&#x27; bytes of a value.&quot;,
1702          io-&gt;type-&gt;module-&gt;name,
1703          io-&gt;type-&gt;name,
1704          (PORT_ULONGLONG)io-&gt;bytes);
1705      exit(1);
1706  }
1707  void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
1708      if (io-&gt;error) return;
1709      int retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_UINT);
1710      if (retval == -1) goto saveerr;
1711      io-&gt;bytes += retval;
1712      retval = rdbSaveLen(io-&gt;rio, value);
1713      if (retval == -1) goto saveerr;
1714      io-&gt;bytes += retval;
1715      return;
1716  saveerr:
1717      io-&gt;error = 1;
1718  }
1719  uint64_t RM_LoadUnsigned(RedisModuleIO *io) {
1720      if (io-&gt;ver == 2) {
1721          uint64_t opcode = rdbLoadLen(io-&gt;rio,NULL);
1722          if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;
1723      }
1724      uint64_t value;
1725      int retval = rdbLoadLenByRef(io-&gt;rio, NULL, &amp;value);
1726      if (retval == -1) goto loaderr;
1727      return value;
1728  loaderr:
1729      moduleRDBLoadError(io);
1730      return 0; &amp;bsol;* Never reached. */
1731  }
1732  void RM_SaveSigned(RedisModuleIO *io, int64_t value) {
1733      union {uint64_t u; int64_t i;} conv;
1734      conv.i = value;
1735      RM_SaveUnsigned(io,conv.u);
1736  }
1737  int64_t RM_LoadSigned(RedisModuleIO *io) {
1738      union {uint64_t u; int64_t i;} conv;
1739      conv.u = RM_LoadUnsigned(io);
1740      return conv.i;
1741  }
1742  void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
1743      if (io-&gt;error) return;
1744      ssize_t retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_STRING);
1745      if (retval == -1) goto saveerr;
1746      io-&gt;bytes += retval;
1747      retval = rdbSaveStringObject(io-&gt;rio, s);
1748      if (retval == -1) goto saveerr;
1749      io-&gt;bytes += retval;
1750      return;
1751  saveerr:
1752      io-&gt;error = 1;
1753  }
1754  void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
1755      if (io-&gt;error) return;
1756      ssize_t retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_STRING);
1757      if (retval == -1) goto saveerr;
1758      io-&gt;bytes += retval;
1759      retval = rdbSaveRawString(io-&gt;rio, (unsigned char*)str,len);
1760      if (retval == -1) goto saveerr;
1761      io-&gt;bytes += retval;
1762      return;
1763  saveerr:
1764      io-&gt;error = 1;
1765  }
1766  void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {
1767      if (io-&gt;ver == 2) {
1768          uint64_t opcode = rdbLoadLen(io-&gt;rio,NULL);
1769          if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;
1770      }
1771      void *s = rdbGenericLoadStringObject(io-&gt;rio,
1772                plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);
1773      if (s == NULL) goto loaderr;
1774      return s;
1775  loaderr:
1776      moduleRDBLoadError(io);
1777      return NULL; &amp;bsol;* Never reached. */
1778  }
1779  RedisModuleString *RM_LoadString(RedisModuleIO *io) {
1780      return moduleLoadString(io,0,NULL);
1781  }
1782  char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
1783      return moduleLoadString(io,1,lenptr);
1784  }
1785  void RM_SaveDouble(RedisModuleIO *io, double value) {
1786      if (io-&gt;error) return;
1787      int retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_DOUBLE);
1788      if (retval == -1) goto saveerr;
1789      io-&gt;bytes += retval;
1790      retval = rdbSaveBinaryDoubleValue(io-&gt;rio, value);
1791      if (retval == -1) goto saveerr;
1792      io-&gt;bytes += retval;
1793      return;
1794  saveerr:
1795      io-&gt;error = 1;
1796  }
1797  double RM_LoadDouble(RedisModuleIO *io) {
1798      if (io-&gt;ver == 2) {
1799          uint64_t opcode = rdbLoadLen(io-&gt;rio,NULL);
1800          if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;
1801      }
1802      double value;
1803      int retval = rdbLoadBinaryDoubleValue(io-&gt;rio, &amp;value);
1804      if (retval == -1) goto loaderr;
1805      return value;
1806  loaderr:
1807      moduleRDBLoadError(io);
1808      return 0; &amp;bsol;* Never reached. */
1809  }
1810  void RM_SaveFloat(RedisModuleIO *io, float value) {
1811      if (io-&gt;error) return;
1812      int retval = rdbSaveLen(io-&gt;rio, RDB_MODULE_OPCODE_FLOAT);
1813      if (retval == -1) goto saveerr;
1814      io-&gt;bytes += retval;
1815      retval = rdbSaveBinaryFloatValue(io-&gt;rio, value);
1816      if (retval == -1) goto saveerr;
1817      io-&gt;bytes += retval;
1818      return;
1819  saveerr:
1820      io-&gt;error = 1;
1821  }
1822  float RM_LoadFloat(RedisModuleIO *io) {
1823      if (io-&gt;ver == 2) {
1824          uint64_t opcode = rdbLoadLen(io-&gt;rio,NULL);
1825          if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;
1826      }
1827      float value;
1828      int retval = rdbLoadBinaryFloatValue(io-&gt;rio, &amp;value);
1829      if (retval == -1) goto loaderr;
1830      return value;
1831  loaderr:
1832      moduleRDBLoadError(io);
1833      return 0; &amp;bsol;* Never reached. */
1834  }
1835  ssize_t rdbSaveModulesAux(rio *rdb, int when) {
1836      size_t total_written = 0;
1837      dictIterator *di = dictGetIterator(modules);
1838      dictEntry *de;
1839      while ((de = dictNext(di)) != NULL) {
1840          struct RedisModule *module = dictGetVal(de);
1841          listIter li;
1842          listNode *ln;
1843          listRewind(module-&gt;types,&amp;li);
1844          while((ln = listNext(&amp;li))) {
1845              moduleType *mt = ln-&gt;value;
1846              if (!mt-&gt;aux_save || !(mt-&gt;aux_save_triggers &amp; when))
1847                  continue;
1848              ssize_t ret = rdbSaveSingleModuleAux(rdb, when, mt);
1849              if (ret==-1) {
1850                  dictReleaseIterator(di);
1851                  return -1;
1852              }
1853              total_written += ret;
1854          }
1855      }
1856      dictReleaseIterator(di);
1857      return total_written;
1858  }
1859  void RM_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len) {
1860      mixDigest(md-&gt;o,ele,len);
1861  }
1862  void RM_DigestAddLongLong(RedisModuleDigest *md, PORT_LONGLONG ll) {
1863      char buf[LONG_STR_SIZE];
1864      size_t len = ll2string(buf,sizeof(buf),ll);
1865      mixDigest(md-&gt;o,buf,len);
1866  }
1867  void RM_DigestEndSequence(RedisModuleDigest *md) {
1868      xorDigest(md-&gt;x,md-&gt;o,sizeof(md-&gt;o));
1869      memset(md-&gt;o,0,sizeof(md-&gt;o));
1870  }
1871  void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
1872      if (io-&gt;error) return;
1873      struct redisCommand *cmd;
1874      robj **argv = NULL;
1875      int argc = 0, flags = 0, j;
1876      va_list ap;
1877      cmd = lookupCommandByCString((char*)cmdname);
1878      if (!cmd) {
1879          serverLog(LL_WARNING,
1880              &quot;Fatal: AOF method for module data type &#x27;%s&#x27; tried to &quot;
1881              &quot;emit unknown command &#x27;%s&#x27;&quot;,
1882              io-&gt;type-&gt;name, cmdname);
1883          io-&gt;error = 1;
1884          errno = EINVAL;
1885          return;
1886      }
1887      va_start(ap, fmt);
1888      argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&amp;argc,&amp;flags,ap);
1889      va_end(ap);
1890      if (argv == NULL) {
1891          serverLog(LL_WARNING,
1892              &quot;Fatal: AOF method for module data type &#x27;%s&#x27; tried to &quot;
1893              &quot;call RedisModule_EmitAOF() with wrong format specifiers &#x27;%s&#x27;&quot;,
1894              io-&gt;type-&gt;name, fmt);
1895          io-&gt;error = 1;
1896          errno = EINVAL;
1897          return;
1898      }
1899      if (!io-&gt;error &amp;&amp; rioWriteBulkCount(io-&gt;rio,&#x27;*&#x27;,argc) == 0)
1900          io-&gt;error = 1;
1901      for (j = 0; j &lt; argc; j++) {
1902          if (!io-&gt;error &amp;&amp; rioWriteBulkObject(io-&gt;rio,argv[j]) == 0)
1903              io-&gt;error = 1;
1904          decrRefCount(argv[j]);
1905      }
1906      zfree(argv);
1907      return;
1908  }
1909  RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
1910      if (io-&gt;ctx) return io-&gt;ctx; &amp;bsol;* Can&#x27;t have more than one... */
1911      RedisModuleCtx ctxtemplate = REDISMODULE_CTX_INIT;
1912      io-&gt;ctx = zmalloc(sizeof(RedisModuleCtx));
1913      *(io-&gt;ctx) = ctxtemplate;
1914      io-&gt;ctx-&gt;module = io-&gt;type-&gt;module;
1915      io-&gt;ctx-&gt;client = NULL;
1916      return io-&gt;ctx;
1917  }
1918  const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {
1919      return io-&gt;key;
1920  }
1921  void RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {
1922      char msg[LOG_MAX_LEN];
1923      size_t name_len;
1924      int level;
1925      if (!strcasecmp(levelstr,&quot;debug&quot;)) level = LL_DEBUG;
1926      else if (!strcasecmp(levelstr,&quot;verbose&quot;)) level = LL_VERBOSE;
1927      else if (!strcasecmp(levelstr,&quot;notice&quot;)) level = LL_NOTICE;
1928      else if (!strcasecmp(levelstr,&quot;warning&quot;)) level = LL_WARNING;
1929      else level = LL_VERBOSE; &amp;bsol;* Default. */
1930      if (level &lt; server.verbosity) return;
1931      name_len = snprintf(msg, sizeof(msg),&quot;&lt;%s&gt; &quot;, module? module-&gt;name: &quot;module&quot;);
1932      vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);
1933      serverLogRaw(level,msg);
1934  }
1935  void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {
1936      va_list ap;
1937      va_start(ap, fmt);
1938      RM_LogRaw(ctx? ctx-&gt;module: NULL,levelstr,fmt,ap);
1939      va_end(ap);
1940  }
1941  void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {
1942      va_list ap;
1943      va_start(ap, fmt);
1944      RM_LogRaw(io-&gt;type-&gt;module,levelstr,fmt,ap);
1945      va_end(ap);
1946  }
1947  void moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
1948      UNUSED(el);
1949      UNUSED(fd);
1950      UNUSED(mask);
1951      UNUSED(privdata);
1952  }
1953  void unblockClientFromModule(client *c) {
1954      RedisModuleBlockedClient *bc = c-&gt;bpop.module_blocked_handle;
1955      if (bc-&gt;disconnect_callback) {
1956          RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
1957          ctx.blocked_privdata = bc-&gt;privdata;
1958          ctx.module = bc-&gt;module;
1959          ctx.client = bc-&gt;client;
1960          bc-&gt;disconnect_callback(&amp;ctx,bc);
1961          moduleFreeContext(&amp;ctx);
1962      }
1963      bc-&gt;client = NULL;
1964      resetClient(c);
1965  }
1966  RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), PORT_LONGLONG timeout_ms) {
1967      client *c = ctx-&gt;client;
1968      int islua = c-&gt;flags &amp; CLIENT_LUA;
1969      int ismulti = c-&gt;flags &amp; CLIENT_MULTI;
1970      c-&gt;bpop.module_blocked_handle = zmalloc(sizeof(RedisModuleBlockedClient));
1971      RedisModuleBlockedClient *bc = c-&gt;bpop.module_blocked_handle;
1972      bc-&gt;client = (islua || ismulti) ? NULL : c;
1973      bc-&gt;module = ctx-&gt;module;
1974      bc-&gt;reply_callback = reply_callback;
1975      bc-&gt;timeout_callback = timeout_callback;
1976      bc-&gt;disconnect_callback = NULL; &amp;bsol;* Set by RM_SetDisconnectCallback() */
1977      bc-&gt;free_privdata = free_privdata;
1978      bc-&gt;privdata = NULL;
1979      bc-&gt;reply_client = createClient(-1);
1980      bc-&gt;reply_client-&gt;flags |= CLIENT_MODULE;
1981      bc-&gt;dbid = c-&gt;db-&gt;id;
1982      c-&gt;bpop.timeout = timeout_ms ? (mstime()+timeout_ms) : 0;
1983      if (islua || ismulti) {
1984          c-&gt;bpop.module_blocked_handle = NULL;
1985          addReplyError(c, islua ?
1986              &quot;Blocking module command called from Lua script&quot; :
1987              &quot;Blocking module command called from transaction&quot;);
1988      } else {
1989          blockClient(c,BLOCKED_MODULE);
1990      }
1991      return bc;
1992  }
1993  int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
1994      pthread_mutex_lock(&amp;moduleUnblockedClientsMutex);
1995      bc-&gt;privdata = privdata;
1996      listAddNodeTail(moduleUnblockedClients,bc);
1997      if (write(server.module_blocked_pipe[1],&quot;A&quot;,1) != 1) {
1998      }
1999      pthread_mutex_unlock(&amp;moduleUnblockedClientsMutex);
2000      return REDISMODULE_OK;
2001  }
2002  int RM_AbortBlock(RedisModuleBlockedClient *bc) {
2003      bc-&gt;reply_callback = NULL;
2004      bc-&gt;disconnect_callback = NULL;
2005      return RM_UnblockClient(bc,NULL);
2006  }
2007  void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {
2008      bc-&gt;disconnect_callback = callback;
2009  }
2010  void moduleHandleBlockedClients(void) {
2011      listNode *ln;
2012      RedisModuleBlockedClient *bc;
2013      pthread_mutex_lock(&amp;moduleUnblockedClientsMutex);
2014      char buf[1];
2015      while (read(server.module_blocked_pipe[0],buf,1) == 1);
2016      while (listLength(moduleUnblockedClients)) {
2017          ln = listFirst(moduleUnblockedClients);
2018          bc = ln-&gt;value;
2019          client *c = bc-&gt;client;
2020          listDelNode(moduleUnblockedClients,ln);
2021          pthread_mutex_unlock(&amp;moduleUnblockedClientsMutex);
2022          if (c &amp;&amp; bc-&gt;reply_callback) {
2023              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2024              ctx.flags |= REDISMODULE_CTX_BLOCKED_REPLY;
2025              ctx.blocked_privdata = bc-&gt;privdata;
2026              ctx.module = bc-&gt;module;
2027              ctx.client = bc-&gt;client;
2028              ctx.blocked_client = bc;
2029              bc-&gt;reply_callback(&amp;ctx,(void**)c-&gt;argv,c-&gt;argc);
2030              moduleFreeContext(&amp;ctx);
2031          }
2032          if (bc-&gt;privdata &amp;&amp; bc-&gt;free_privdata) {
2033              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2034              if (c == NULL)
2035                  ctx.flags |= REDISMODULE_CTX_BLOCKED_DISCONNECTED;
2036              ctx.blocked_privdata = bc-&gt;privdata;
2037              ctx.module = bc-&gt;module;
2038              ctx.client = bc-&gt;client;
2039              bc-&gt;free_privdata(&amp;ctx,bc-&gt;privdata);
2040              moduleFreeContext(&amp;ctx);
2041          }
2042          if (c) AddReplyFromClient(c, bc-&gt;reply_client);
2043          freeClient(bc-&gt;reply_client);
2044          if (c != NULL) {
2045              bc-&gt;disconnect_callback = NULL;
2046              unblockClient(c);
2047              if (clientHasPendingReplies(c) &amp;&amp;
2048                  !(c-&gt;flags &amp; CLIENT_PENDING_WRITE))
2049              {
2050                  c-&gt;flags |= CLIENT_PENDING_WRITE;
2051                  listAddNodeHead(server.clients_pending_write,c);
2052              }
2053          }
2054          zfree(bc);
2055          pthread_mutex_lock(&amp;moduleUnblockedClientsMutex);
2056      }
2057      pthread_mutex_unlock(&amp;moduleUnblockedClientsMutex);
2058  }
2059  void moduleBlockedClientTimedOut(client *c) {
2060      RedisModuleBlockedClient *bc = c-&gt;bpop.module_blocked_handle;
2061      RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2062      ctx.flags |= REDISMODULE_CTX_BLOCKED_TIMEOUT;
2063      ctx.module = bc-&gt;module;
2064      ctx.client = bc-&gt;client;
2065      ctx.blocked_client = bc;
2066      bc-&gt;timeout_callback(&amp;ctx,(void**)c-&gt;argv,c-&gt;argc);
2067      moduleFreeContext(&amp;ctx);
2068      bc-&gt;disconnect_callback = NULL;
2069  }
2070  int RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {
2071      return (ctx-&gt;flags &amp; REDISMODULE_CTX_BLOCKED_REPLY) != 0;
2072  }
2073  int RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {
2074      return (ctx-&gt;flags &amp; REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;
2075  }
2076  void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
2077      return ctx-&gt;blocked_privdata;
2078  }
2079  RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
2080      return ctx-&gt;blocked_client;
2081  }
2082  int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {
2083      return (ctx-&gt;flags &amp; REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;
2084  }
2085  RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
2086      RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));
2087      RedisModuleCtx empty = REDISMODULE_CTX_INIT;
2088      memcpy(ctx,&amp;empty,sizeof(empty));
2089      if (bc) {
2090          ctx-&gt;blocked_client = bc;
2091          ctx-&gt;module = bc-&gt;module;
2092      }
2093      ctx-&gt;flags |= REDISMODULE_CTX_THREAD_SAFE;
2094      ctx-&gt;client = createClient(-1);
2095      if (bc) {
2096          selectDb(ctx-&gt;client,bc-&gt;dbid);
2097          if (bc-&gt;client) ctx-&gt;client-&gt;id = bc-&gt;client-&gt;id;
2098      }
2099      return ctx;
2100  }
2101  void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {
2102      moduleFreeContext(ctx);
2103      zfree(ctx);
2104  }
2105  void RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {
2106      UNUSED(ctx);
2107      moduleAcquireGIL();
2108  }
2109  void RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {
2110      UNUSED(ctx);
2111      moduleReleaseGIL();
2112  }
2113  void moduleAcquireGIL(void) {
2114      pthread_mutex_lock(&amp;moduleGIL);
2115  }
2116  void moduleReleaseGIL(void) {
2117      pthread_mutex_unlock(&amp;moduleGIL);
2118  }
2119  int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {
2120      RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));
2121      sub-&gt;module = ctx-&gt;module;
2122      sub-&gt;event_mask = types;
2123      sub-&gt;notify_callback = callback;
2124      sub-&gt;active = 0;
2125      listAddNodeTail(moduleKeyspaceSubscribers, sub);
2126      return REDISMODULE_OK;
2127  }
2128  void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {
2129      if (listLength(moduleKeyspaceSubscribers) == 0) return;
2130      listIter li;
2131      listNode *ln;
2132      listRewind(moduleKeyspaceSubscribers,&amp;li);
2133      type &amp;= ~(NOTIFY_KEYEVENT | NOTIFY_KEYSPACE);
2134      while((ln = listNext(&amp;li))) {
2135          RedisModuleKeyspaceSubscriber *sub = ln-&gt;value;
2136          if ((sub-&gt;event_mask &amp; type) &amp;&amp; sub-&gt;active == 0) {
2137              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2138              ctx.module = sub-&gt;module;
2139              ctx.client = moduleFreeContextReusedClient;
2140              selectDb(ctx.client, dbid);
2141              sub-&gt;active = 1;
2142              sub-&gt;notify_callback(&amp;ctx, type, event, key);
2143              sub-&gt;active = 0;
2144              moduleFreeContext(&amp;ctx);
2145          }
2146      }
2147  }
2148  void moduleUnsubscribeNotifications(RedisModule *module) {
2149      listIter li;
2150      listNode *ln;
2151      listRewind(moduleKeyspaceSubscribers,&amp;li);
2152      while((ln = listNext(&amp;li))) {
2153          RedisModuleKeyspaceSubscriber *sub = ln-&gt;value;
2154          if (sub-&gt;module == module) {
2155              listDelNode(moduleKeyspaceSubscribers, ln);
2156              zfree(sub);
2157          }
2158      }
2159  }
2160  typedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);
2161  typedef struct moduleClusterReceiver {
2162      uint64_t module_id;
2163      RedisModuleClusterMessageReceiver callback;
2164      struct RedisModule *module;
2165      struct moduleClusterReceiver *next;
2166  } moduleClusterReceiver;
2167  typedef struct moduleClusterNodeInfo {
2168      int flags;
2169      char ip[NET_IP_STR_LEN];
2170      int port;
2171      char master_id[40]; &amp;bsol;* Only if flags &amp; REDISMODULE_NODE_MASTER is true. */
2172  } mdouleClusterNodeInfo;
2173  static moduleClusterReceiver *clusterReceivers[UINT8_MAX];
2174  void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len) {
2175      moduleClusterReceiver *r = clusterReceivers[type];
2176      while(r) {
2177          if (r-&gt;module_id == module_id) {
2178              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2179              ctx.module = r-&gt;module;
2180              ctx.client = moduleFreeContextReusedClient;
2181              selectDb(ctx.client, 0);
2182              r-&gt;callback(&amp;ctx,sender_id,type,payload,len);
2183              moduleFreeContext(&amp;ctx);
2184              return;
2185          }
2186          r = r-&gt;next;
2187      }
2188  }
2189  void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {
2190      if (!server.cluster_enabled) return;
2191      uint64_t module_id = moduleTypeEncodeId(ctx-&gt;module-&gt;name,0);
2192      moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;
2193      while(r) {
2194          if (r-&gt;module_id == module_id) {
2195              if (callback) {
2196                  r-&gt;callback = callback;
2197              } else {
2198                  if (prev)
2199                      prev-&gt;next = r-&gt;next;
2200                  else
2201                      clusterReceivers[type]-&gt;next = r-&gt;next;
2202                  zfree(r);
2203              }
2204              return;
2205          }
2206          prev = r;
2207          r = r-&gt;next;
2208      }
2209      if (callback) {
2210          r = zmalloc(sizeof(*r));
2211          r-&gt;module_id = module_id;
2212          r-&gt;module = ctx-&gt;module;
2213          r-&gt;callback = callback;
2214          r-&gt;next = clusterReceivers[type];
2215          clusterReceivers[type] = r;
2216      }
2217  }
2218  int RM_SendClusterMessage(RedisModuleCtx *ctx, char *target_id, uint8_t type, unsigned char *msg, uint32_t len) {
2219      if (!server.cluster_enabled) return REDISMODULE_ERR;
2220      uint64_t module_id = moduleTypeEncodeId(ctx-&gt;module-&gt;name,0);
2221      if (clusterSendModuleMessageToTarget(target_id,module_id,type,msg,len) == C_OK)
2222          return REDISMODULE_OK;
2223      else
2224          return REDISMODULE_ERR;
2225  }
2226  char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
2227      UNUSED(ctx);
2228      if (!server.cluster_enabled) return NULL;
2229      size_t count = dictSize(server.cluster-&gt;nodes);
2230      char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);
2231      dictIterator *di = dictGetIterator(server.cluster-&gt;nodes);
2232      dictEntry *de;
2233      int j = 0;
2234      while((de = dictNext(di)) != NULL) {
2235          clusterNode *node = dictGetVal(de);
2236          if (node-&gt;flags &amp; (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) continue;
2237          ids[j] = zmalloc(REDISMODULE_NODE_ID_LEN);
2238          memcpy(ids[j],node-&gt;name,REDISMODULE_NODE_ID_LEN);
2239          j++;
2240      }
2241      *numnodes = j;
2242      ids[j] = NULL; &amp;bsol;* Null term so that FreeClusterNodesList does not need
2243                      * to also get the count argument. */
2244      dictReleaseIterator(di);
2245      return ids;
2246  }
2247  void RM_FreeClusterNodesList(char **ids) {
2248      if (ids == NULL) return;
2249      for (int j = 0; ids[j]; j++) zfree(ids[j]);
2250      zfree(ids);
2251  }
2252  const char *RM_GetMyClusterID(void) {
2253      if (!server.cluster_enabled) return NULL;
2254      return server.cluster-&gt;myself-&gt;name;
2255  }
2256  size_t RM_GetClusterSize(void) {
2257      if (!server.cluster_enabled) return 0;
2258      return dictSize(server.cluster-&gt;nodes);
2259  }
2260  clusterNode *clusterLookupNode(const char *name); &amp;bsol;* We need access to internals */
2261  int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {
2262      UNUSED(ctx);
2263      clusterNode *node = clusterLookupNode(id);
2264      if (node == NULL ||
2265          node-&gt;flags &amp; (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
2266      {
2267          return REDISMODULE_ERR;
2268      }
2269      if (ip) strncpy(ip,node-&gt;ip,NET_IP_STR_LEN);
2270      if (master_id) {
2271          if (node-&gt;flags &amp; CLUSTER_NODE_MASTER &amp;&amp; node-&gt;slaveof)
2272              memcpy(master_id,node-&gt;slaveof-&gt;name,REDISMODULE_NODE_ID_LEN);
2273          else
2274              memset(master_id,0,REDISMODULE_NODE_ID_LEN);
2275      }
2276      if (port) *port = node-&gt;port;
2277      if (flags) {
2278          *flags = 0;
2279          if (node-&gt;flags &amp; CLUSTER_NODE_MYSELF) *flags |= REDISMODULE_NODE_MYSELF;
2280          if (node-&gt;flags &amp; CLUSTER_NODE_MASTER) *flags |= REDISMODULE_NODE_MASTER;
2281          if (node-&gt;flags &amp; CLUSTER_NODE_SLAVE) *flags |= REDISMODULE_NODE_SLAVE;
2282          if (node-&gt;flags &amp; CLUSTER_NODE_PFAIL) *flags |= REDISMODULE_NODE_PFAIL;
2283          if (node-&gt;flags &amp; CLUSTER_NODE_FAIL) *flags |= REDISMODULE_NODE_FAIL;
2284          if (node-&gt;flags &amp; CLUSTER_NODE_NOFAILOVER) *flags |= REDISMODULE_NODE_NOFAILOVER;
2285      }
2286      return REDISMODULE_OK;
2287  }
2288  void RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {
2289      UNUSED(ctx);
2290      if (flags &amp; REDISMODULE_CLUSTER_FLAG_NO_FAILOVER)
2291          server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_FAILOVER;
2292      if (flags &amp; REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION)
2293          server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_REDIRECTION;
2294  }
2295  static rax *Timers;     &amp;bsol;* The radix tree of all the timers sorted by expire. */
2296  PORT_LONGLONG aeTimer = -1; &amp;bsol;* Main event loop (ae.c) timer identifier. */
2297  typedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);
2298  typedef struct RedisModuleTimer {
2299      RedisModule *module;                &amp;bsol;* Module reference. */
2300      RedisModuleTimerProc callback;      &amp;bsol;* The callback to invoke on expire. */
2301      void *data;                         &amp;bsol;* Private data for the callback. */
2302      int dbid;                           &amp;bsol;* Database number selected by the original client. */
2303  } RedisModuleTimer;
2304  int moduleTimerHandler(struct aeEventLoop *eventLoop, PORT_LONGLONG id, void *clientData) {
2305      UNUSED(eventLoop);
2306      UNUSED(id);
2307      UNUSED(clientData);
2308      raxIterator ri;
2309      raxStart(&amp;ri,Timers);
2310      uint64_t now = ustime();
2311      PORT_LONGLONG next_period = 0;
2312      while(1) {
2313          raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
2314          if (!raxNext(&amp;ri)) break;
2315          uint64_t expiretime;
2316          memcpy(&amp;expiretime,ri.key,sizeof(expiretime));
2317          expiretime = ntohu64(expiretime);
2318          if (now &gt;= expiretime) {
2319              RedisModuleTimer *timer = ri.data;
2320              RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2321              ctx.module = timer-&gt;module;
2322              ctx.client = moduleFreeContextReusedClient;
2323              selectDb(ctx.client, timer-&gt;dbid);
2324              timer-&gt;callback(&amp;ctx,timer-&gt;data);
2325              moduleFreeContext(&amp;ctx);
2326              raxRemove(Timers,(unsigned char*)ri.key,ri.key_len,NULL);
2327              zfree(timer);
2328          } else {
2329              next_period = (expiretime-now)/1000; &amp;bsol;* Scale to milliseconds. */
2330              break;
2331          }
2332      }
2333      raxStop(&amp;ri);
2334      if (next_period &lt;= 0) next_period = 1;
2335      return (raxSize(Timers) &gt; 0) ? next_period : AE_NOMORE;
2336  }
2337  RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {
2338      RedisModuleTimer *timer = zmalloc(sizeof(*timer));
2339      timer-&gt;module = ctx-&gt;module;
2340      timer-&gt;callback = callback;
2341      timer-&gt;data = data;
2342      timer-&gt;dbid = ctx-&gt;client-&gt;db-&gt;id;
2343      uint64_t expiretime = ustime()+period*1000;
2344      uint64_t key;
2345      while(1) {
2346          key = htonu64(expiretime);
2347          if (raxFind(Timers, (unsigned char*)&amp;key,sizeof(key)) == raxNotFound) {
2348              raxInsert(Timers,(unsigned char*)&amp;key,sizeof(key),timer,NULL);
2349              break;
2350          } else {
2351              expiretime++;
2352          }
2353      }
2354      if (aeTimer != -1) {
2355          raxIterator ri;
2356          raxStart(&amp;ri,Timers);
2357          raxSeek(&amp;ri,&quot;^&quot;,NULL,0);
2358          raxNext(&amp;ri);
2359          if (memcmp(ri.key,&amp;key,sizeof(key)) == 0) {
2360              aeDeleteTimeEvent(server.el,aeTimer);
2361              aeTimer = -1;
2362          }
2363          raxStop(&amp;ri);
2364      }
2365      if (aeTimer == -1)
2366          aeTimer = aeCreateTimeEvent(server.el,period,moduleTimerHandler,NULL,NULL);
2367      return key;
2368  }
2369  int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
2370      RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&amp;id,sizeof(id));
2371      if (timer == raxNotFound || timer-&gt;module != ctx-&gt;module)
2372          return REDISMODULE_ERR;
2373      if (data) *data = timer-&gt;data;
2374      raxRemove(Timers,(unsigned char*)&amp;id,sizeof(id),NULL);
2375      zfree(timer);
2376      return REDISMODULE_OK;
2377  }
2378  int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {
2379      RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&amp;id,sizeof(id));
2380      if (timer == raxNotFound || timer-&gt;module != ctx-&gt;module)
2381          return REDISMODULE_ERR;
2382      if (remaining) {
2383          int64_t rem = ntohu64(id)-ustime();
2384          if (rem &lt; 0) rem = 0;
2385          *remaining = rem/1000; &amp;bsol;* Scale to milliseconds. */
2386      }
2387      if (data) *data = timer-&gt;data;
2388      return REDISMODULE_OK;
2389  }
2390  RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {
2391      struct RedisModuleDict *d = zmalloc(sizeof(*d));
2392      d-&gt;rax = raxNew();
2393      if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);
2394      return d;
2395  }
2396  void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {
2397      if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_DICT,d);
2398      raxFree(d-&gt;rax);
2399      zfree(d);
2400  }
2401  uint64_t RM_DictSize(RedisModuleDict *d) {
2402      return raxSize(d-&gt;rax);
2403  }
2404  int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
2405      int retval = raxTryInsert(d-&gt;rax,key,keylen,ptr,NULL);
2406      return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
2407  }
2408  int RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
2409      int retval = raxInsert(d-&gt;rax,key,keylen,ptr,NULL);
2410      return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
2411  }
2412  int RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
2413      return RM_DictSetC(d,key-&gt;ptr,sdslen(key-&gt;ptr),ptr);
2414  }
2415  int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
2416      return RM_DictReplaceC(d,key-&gt;ptr,sdslen(key-&gt;ptr),ptr);
2417  }
2418  void *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {
2419      void *res = raxFind(d-&gt;rax,key,keylen);
2420      if (nokey) *nokey = (res == raxNotFound);
2421      return (res == raxNotFound) ? NULL : res;
2422  }
2423  void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
2424      return RM_DictGetC(d,key-&gt;ptr,sdslen(key-&gt;ptr),nokey);
2425  }
2426  int RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {
2427      int retval = raxRemove(d-&gt;rax,key,keylen,oldval);
2428      return retval ? REDISMODULE_OK : REDISMODULE_ERR;
2429  }
2430  int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {
2431      return RM_DictDelC(d,key-&gt;ptr,sdslen(key-&gt;ptr),oldval);
2432  }
2433  RedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {
2434      RedisModuleDictIter *di = zmalloc(sizeof(*di));
2435      di-&gt;dict = d;
2436      raxStart(&amp;di-&gt;ri,d-&gt;rax);
2437      raxSeek(&amp;di-&gt;ri,op,key,keylen);
2438      return di;
2439  }
2440  RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {
2441      return RM_DictIteratorStartC(d,op,key-&gt;ptr,sdslen(key-&gt;ptr));
2442  }
2443  void RM_DictIteratorStop(RedisModuleDictIter *di) {
2444      raxStop(&amp;di-&gt;ri);
2445      zfree(di);
2446  }
2447  int RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
2448      return raxSeek(&amp;di-&gt;ri,op,key,keylen);
2449  }
2450  int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
2451      return RM_DictIteratorReseekC(di,op,key-&gt;ptr,sdslen(key-&gt;ptr));
2452  }
2453  void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
2454      if (!raxNext(&amp;di-&gt;ri)) return NULL;
2455      if (keylen) *keylen = di-&gt;ri.key_len;
2456      if (dataptr) *dataptr = di-&gt;ri.data;
2457      return di-&gt;ri.key;
2458  }
2459  void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
2460      if (!raxPrev(&amp;di-&gt;ri)) return NULL;
2461      if (keylen) *keylen = di-&gt;ri.key_len;
2462      if (dataptr) *dataptr = di-&gt;ri.data;
2463      return di-&gt;ri.key;
2464  }
2465  RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
2466      size_t keylen;
2467      void *key = RM_DictNextC(di,&amp;keylen,dataptr);
2468      if (key == NULL) return NULL;
2469      return RM_CreateString(ctx,key,keylen);
2470  }
2471  RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
2472      size_t keylen;
2473      void *key = RM_DictPrevC(di,&amp;keylen,dataptr);
2474      if (key == NULL) return NULL;
2475      return RM_CreateString(ctx,key,keylen);
2476  }
2477  int RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
2478      if (raxEOF(&amp;di-&gt;ri)) return REDISMODULE_ERR;
2479      int res = raxCompare(&amp;di-&gt;ri,op,key,keylen);
2480      return res ? REDISMODULE_OK : REDISMODULE_ERR;
2481  }
2482  int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
2483      if (raxEOF(&amp;di-&gt;ri)) return REDISMODULE_ERR;
2484      int res = raxCompare(&amp;di-&gt;ri,op,key-&gt;ptr,sdslen(key-&gt;ptr));
2485      return res ? REDISMODULE_OK : REDISMODULE_ERR;
2486  }
2487  void RM_GetRandomBytes(unsigned char *dst, size_t len) {
2488      getRandomBytes(dst,len);
2489  }
2490  void RM_GetRandomHexChars(char *dst, size_t len) {
2491      getRandomHexChars(dst,len);
2492  }
2493  int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
2494      RedisModuleSharedAPI *sapi = zmalloc(sizeof(*sapi));
2495      sapi-&gt;module = ctx-&gt;module;
2496      sapi-&gt;func = func;
2497      if (dictAdd(server.sharedapi, (char*)apiname, sapi) != DICT_OK) {
2498          zfree(sapi);
2499          return REDISMODULE_ERR;
2500      }
2501      return REDISMODULE_OK;
2502  }
2503  void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {
2504      dictEntry *de = dictFind(server.sharedapi, apiname);
2505      if (de == NULL) return NULL;
2506      RedisModuleSharedAPI *sapi = dictGetVal(de);
2507      if (listSearchKey(sapi-&gt;module-&gt;usedby,ctx-&gt;module) == NULL) {
2508          listAddNodeTail(sapi-&gt;module-&gt;usedby,ctx-&gt;module);
2509          listAddNodeTail(ctx-&gt;module-&gt;using,sapi-&gt;module);
2510      }
2511      return sapi-&gt;func;
2512  }
2513  int moduleUnregisterSharedAPI(RedisModule *module) {
2514      int count = 0;
2515      dictIterator *di = dictGetSafeIterator(server.sharedapi);
2516      dictEntry *de;
2517      while ((de = dictNext(di)) != NULL) {
2518          const char *apiname = dictGetKey(de);
2519          RedisModuleSharedAPI *sapi = dictGetVal(de);
2520          if (sapi-&gt;module == module) {
2521              dictDelete(server.sharedapi,apiname);
2522              zfree(sapi);
2523              count++;
2524          }
2525      }
2526      dictReleaseIterator(di);
2527      return count;
2528  }
2529  int moduleUnregisterUsedAPI(RedisModule *module) {
2530      listIter li;
2531      listNode *ln;
2532      int count = 0;
2533      listRewind(module-&gt;using,&amp;li);
2534      while((ln = listNext(&amp;li))) {
2535          RedisModule *used = ln-&gt;value;
2536          listNode *ln = listSearchKey(used-&gt;usedby,module);
2537          if (ln) {
2538              listDelNode(module-&gt;using,ln);
2539              count++;
2540          }
2541      }
2542      return count;
2543  }
2544  int moduleUnregisterFilters(RedisModule *module) {
2545      listIter li;
2546      listNode *ln;
2547      int count = 0;
2548      listRewind(module-&gt;filters,&amp;li);
2549      while((ln = listNext(&amp;li))) {
2550          RedisModuleCommandFilter *filter = ln-&gt;value;
2551          listNode *ln = listSearchKey(moduleCommandFilters,filter);
2552          if (ln) {
2553              listDelNode(moduleCommandFilters,ln);
2554              count++;
2555          }
2556          zfree(filter);
2557      }
2558      return count;
2559  }
2560  RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, int flags) {
2561      RedisModuleCommandFilter *filter = zmalloc(sizeof(*filter));
2562      filter-&gt;module = ctx-&gt;module;
2563      filter-&gt;callback = callback;
2564      filter-&gt;flags = flags;
2565      listAddNodeTail(moduleCommandFilters, filter);
2566      listAddNodeTail(ctx-&gt;module-&gt;filters, filter);
2567      return filter;
2568  }
2569  int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) {
2570      listNode *ln;
2571      if (filter-&gt;module != ctx-&gt;module) return REDISMODULE_ERR;
2572      ln = listSearchKey(moduleCommandFilters,filter);
2573      if (!ln) return REDISMODULE_ERR;
2574      listDelNode(moduleCommandFilters,ln);
2575      ln = listSearchKey(ctx-&gt;module-&gt;filters,filter);
2576      if (!ln) return REDISMODULE_ERR;    &amp;bsol;* Shouldn&#x27;t happen */
2577      listDelNode(ctx-&gt;module-&gt;filters,ln);
2578      return REDISMODULE_OK;
2579  }
2580  void moduleCallCommandFilters(client *c) {
2581      if (listLength(moduleCommandFilters) == 0) return;
2582      listIter li;
2583      listNode *ln;
2584      listRewind(moduleCommandFilters,&amp;li);
2585      RedisModuleCommandFilterCtx filter = {
2586          .argv = c-&gt;argv,
2587          .argc = c-&gt;argc
2588      };
2589      while((ln = listNext(&amp;li))) {
2590          RedisModuleCommandFilter *f = ln-&gt;value;
2591          if ((f-&gt;flags &amp; REDISMODULE_CMDFILTER_NOSELF) &amp;&amp; f-&gt;module-&gt;in_call) continue;
2592          f-&gt;callback(&amp;filter);
2593      }
2594      c-&gt;argv = filter.argv;
2595      c-&gt;argc = filter.argc;
2596  }
2597  int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
2598  {
2599      return fctx-&gt;argc;
2600  }
2601  const RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx, int pos)
2602  {
2603      if (pos &lt; 0 || pos &gt;= fctx-&gt;argc) return NULL;
2604      return fctx-&gt;argv[pos];
2605  }
2606  int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
2607  {
2608      int i;
2609      if (pos &lt; 0 || pos &gt; fctx-&gt;argc) return REDISMODULE_ERR;
2610      fctx-&gt;argv = zrealloc(fctx-&gt;argv, (fctx-&gt;argc+1)*sizeof(RedisModuleString *));
2611      for (i = fctx-&gt;argc; i &gt; pos; i--) {
2612          fctx-&gt;argv[i] = fctx-&gt;argv[i-1];
2613      }
2614      fctx-&gt;argv[pos] = arg;
2615      fctx-&gt;argc++;
2616      return REDISMODULE_OK;
2617  }
2618  int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
2619  {
2620      if (pos &lt; 0 || pos &gt;= fctx-&gt;argc) return REDISMODULE_ERR;
2621      decrRefCount(fctx-&gt;argv[pos]);
2622      fctx-&gt;argv[pos] = arg;
2623      return REDISMODULE_OK;
2624  }
2625  int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
2626  {
2627      int i;
2628      if (pos &lt; 0 || pos &gt;= fctx-&gt;argc) return REDISMODULE_ERR;
2629      decrRefCount(fctx-&gt;argv[pos]);
2630      for (i = pos; i &lt; fctx-&gt;argc-1; i++) {
2631          fctx-&gt;argv[i] = fctx-&gt;argv[i+1];
2632      }
2633      fctx-&gt;argc--;
2634      return REDISMODULE_OK;
2635  }
2636  uint64_t dictCStringKeyHash(const void *key) {
2637      return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
2638  }
2639  int dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {
2640      UNUSED(privdata);
2641      return strcmp(key1,key2) == 0;
2642  }
2643  dictType moduleAPIDictType = {
2644      dictCStringKeyHash,        &amp;bsol;* hash function */
2645      NULL,                      &amp;bsol;* key dup */
2646      NULL,                      &amp;bsol;* val dup */
2647      dictCStringKeyCompare,     &amp;bsol;* key compare */
2648      NULL,                      &amp;bsol;* key destructor */
2649      NULL                       &amp;bsol;* val destructor */
2650  };
2651  int moduleRegisterApi(const char *funcname, void *funcptr) {
2652      return dictAdd(server.moduleapi, (char*)funcname, funcptr);
2653  }
2654  #define REGISTER_API(name) \
2655      moduleRegisterApi(&quot;RedisModule_&quot; #name, (void *)(PORT_ULONG)RM_ ## name)
2656  void moduleRegisterCoreAPI(void);
2657  void moduleInitModulesSystem(void) {
2658      moduleUnblockedClients = listCreate();
2659      server.loadmodule_queue = listCreate();
2660      modules = dictCreate(&amp;modulesDictType,NULL);
2661      moduleKeyspaceSubscribers = listCreate();
2662      moduleFreeContextReusedClient = createClient(-1);
2663      moduleFreeContextReusedClient-&gt;flags |= CLIENT_MODULE;
2664      moduleCommandFilters = listCreate();
2665      moduleRegisterCoreAPI();
2666      if (IF_WIN32(FDAPI_pipe_for_modules,pipe)(server.module_blocked_pipe) == -1) {
2667          serverLog(LL_WARNING,
2668              &quot;Can&#x27;t create the pipe for module blocking commands: %s&quot;,
2669              IF_WIN32(wsa_strerror(errno), strerror(errno)));
2670          exit(1);
2671      }
2672      anetNonBlock(NULL,server.module_blocked_pipe[0]);
2673      anetNonBlock(NULL,server.module_blocked_pipe[1]);
2674      Timers = raxNew();
2675      pthread_mutex_lock(&amp;moduleGIL);
2676  }
2677  void moduleLoadFromQueue(void) {
2678      listIter li;
2679      listNode *ln;
2680      listRewind(server.loadmodule_queue,&amp;li);
2681      while((ln = listNext(&amp;li))) {
2682          struct moduleLoadQueueEntry *loadmod = ln-&gt;value;
2683          if (moduleLoad(loadmod-&gt;path,(void **)loadmod-&gt;argv,loadmod-&gt;argc)
2684              == C_ERR)
2685          {
2686              serverLog(LL_WARNING,
2687                  &quot;Can&#x27;t load module from %s: server aborting&quot;,
2688                  loadmod-&gt;path);
2689              exit(1);
2690          }
2691      }
2692  }
2693  void moduleFreeModuleStructure(struct RedisModule *module) {
2694      listRelease(module-&gt;types);
2695      listRelease(module-&gt;filters);
2696      sdsfree(module-&gt;name);
2697      zfree(module);
2698  }
2699  void moduleUnregisterCommands(struct RedisModule *module) {
2700      dictIterator *di = dictGetSafeIterator(server.commands);
2701      dictEntry *de;
2702      while ((de = dictNext(di)) != NULL) {
2703          struct redisCommand *cmd = dictGetVal(de);
2704          if (cmd-&gt;proc == RedisModuleCommandDispatcher) {
2705              RedisModuleCommandProxy *cp =
2706                  (void*)(PORT_ULONG)cmd-&gt;getkeys_proc;
2707              sds cmdname = cp-&gt;rediscmd-&gt;name;
2708              if (cp-&gt;module == module) {
2709                  dictDelete(server.commands,cmdname);
2710                  dictDelete(server.orig_commands,cmdname);
2711                  sdsfree(cmdname);
2712                  zfree(cp-&gt;rediscmd);
2713                  zfree(cp);
2714              }
2715          }
2716      }
2717      dictReleaseIterator(di);
2718  }
2719  int moduleLoad(const char *path, void **module_argv, int module_argc) {
2720      int (*onload)(void *, void **, int);
2721      void *handle;
2722      RedisModuleCtx ctx = REDISMODULE_CTX_INIT;
2723      handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);
2724      if (handle == NULL) {
2725          serverLog(LL_WARNING, &quot;Module %s failed to load: %s&quot;, path, dlerror());
2726          return C_ERR;
2727      }
2728      onload = (int (*)(void *, void **, int))(PORT_ULONG) dlsym(handle,&quot;RedisModule_OnLoad&quot;);
2729      if (onload == NULL) {
2730          dlclose(handle);
2731          serverLog(LL_WARNING,
2732              &quot;Module %s does not export RedisModule_OnLoad() &quot;
2733              &quot;symbol. Module not loaded.&quot;,path);
2734          return C_ERR;
2735      }
2736      if (onload((void*)&amp;ctx,module_argv,module_argc) == REDISMODULE_ERR) {
2737          if (ctx.module) {
2738              moduleUnregisterCommands(ctx.module);
2739              moduleUnregisterSharedAPI(ctx.module);
2740              moduleUnregisterUsedAPI(ctx.module);
2741              moduleFreeModuleStructure(ctx.module);
2742          }
2743          dlclose(handle);
2744          serverLog(LL_WARNING,
2745              &quot;Module %s initialization failed. Module not loaded&quot;,path);
2746          return C_ERR;
2747      }
2748  #ifdef _WIN32
2749  #pragma warning(push)
2750  #pragma warning(disable: 6011)
2751  #endif
2752      dictAdd(modules,ctx.module-&gt;name,ctx.module);
2753  #ifdef _WIN32
2754  #pragma warning(pop)
2755  #endif
2756      ctx.module-&gt;handle = handle;
2757      serverLog(LL_NOTICE,&quot;Module &#x27;%s&#x27; loaded from %s&quot;,ctx.module-&gt;name,path);
2758      moduleFreeContext(&amp;ctx);
2759      return C_OK;
2760  }
2761  int moduleUnload(sds name) {
2762      struct RedisModule *module = dictFetchValue(modules,name);
2763      if (module == NULL) {
2764          errno = ENOENT;
2765          return REDISMODULE_ERR;
2766      } else if (listLength(module-&gt;types)) {
2767          errno = EBUSY;
2768          return REDISMODULE_ERR;
2769      } else if (listLength(module-&gt;usedby)) {
2770          errno = EPERM;
2771          return REDISMODULE_ERR;
2772      }
2773      moduleUnregisterCommands(module);
2774      moduleUnregisterSharedAPI(module);
2775      moduleUnregisterUsedAPI(module);
2776      moduleUnregisterFilters(module);
2777      moduleUnsubscribeNotifications(module);
2778      if (dlclose(module-&gt;handle) == -1) {
2779          char *error = dlerror();
2780          if (error == NULL) error = &quot;Unknown error&quot;;
2781          serverLog(LL_WARNING,&quot;Error when trying to close the %s module: %s&quot;,
2782              module-&gt;name, error);
2783      }
2784      serverLog(LL_NOTICE,&quot;Module %s unloaded&quot;,module-&gt;name);
2785      dictDelete(modules,module-&gt;name);
2786      module-&gt;name = NULL; &amp;bsol;* The name was already freed by dictDelete(). */
2787      moduleFreeModuleStructure(module);
2788      return REDISMODULE_OK;
2789  }
2790  void moduleCommand(client *c) {
2791      char *subcmd = c-&gt;argv[1]-&gt;ptr;
2792      if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(subcmd,&quot;help&quot;)) {
2793          const char *help[] = {
2794  &quot;LIST -- Return a list of loaded modules.&quot;,
2795  &quot;LOAD &lt;path&gt; [arg ...] -- Load a module library from &lt;path&gt;.&quot;,
2796  &quot;UNLOAD &lt;name&gt; -- Unload a module.&quot;,
2797  NULL
2798          };
2799          addReplyHelp(c, help);
2800      } else
2801      if (!strcasecmp(subcmd,&quot;load&quot;) &amp;&amp; c-&gt;argc &gt;= 3) {
2802          robj **argv = NULL;
2803          int argc = 0;
2804          if (c-&gt;argc &gt; 3) {
2805              argc = c-&gt;argc - 3;
2806              argv = &amp;c-&gt;argv[3];
2807          }
2808          if (moduleLoad(c-&gt;argv[2]-&gt;ptr,(void **)argv,argc) == C_OK)
2809              addReply(c,shared.ok);
2810          else
2811              addReplyError(c,
2812                  &quot;Error loading the extension. Please check the server logs.&quot;);
2813      } else if (!strcasecmp(subcmd,&quot;unload&quot;) &amp;&amp; c-&gt;argc == 3) {
2814          if (moduleUnload(c-&gt;argv[2]-&gt;ptr) == C_OK)
2815              addReply(c,shared.ok);
2816          else {
2817              char *errmsg;
2818              switch(errno) {
2819              case ENOENT:
2820                  errmsg = &quot;no such module with that name&quot;;
2821                  break;
2822              case EBUSY:
2823                  errmsg = &quot;the module exports one or more module-side data &quot;
2824                           &quot;types, can&#x27;t unload&quot;;
2825                  break;
2826              case EPERM:
2827                  errmsg = &quot;the module exports APIs used by other modules. &quot;
2828                           &quot;Please unload them first and try again&quot;;
2829                  break;
2830              default:
2831                  errmsg = &quot;operation not possible.&quot;;
2832                  break;
2833              }
2834              addReplyErrorFormat(c,&quot;Error unloading module: %s&quot;,errmsg);
2835          }
2836      } else if (!strcasecmp(subcmd,&quot;list&quot;) &amp;&amp; c-&gt;argc == 2) {
2837          dictIterator *di = dictGetIterator(modules);
2838          dictEntry *de;
2839          addReplyMultiBulkLen(c,dictSize(modules));
2840          while ((de = dictNext(di)) != NULL) {
2841              sds name = dictGetKey(de);
2842              struct RedisModule *module = dictGetVal(de);
2843              addReplyMultiBulkLen(c,4);
2844              addReplyBulkCString(c,&quot;name&quot;);
2845              addReplyBulkCBuffer(c,name,sdslen(name));
2846              addReplyBulkCString(c,&quot;ver&quot;);
2847              addReplyLongLong(c,module-&gt;ver);
2848          }
2849          dictReleaseIterator(di);
2850      } else {
2851          addReplySubcommandSyntaxError(c);
2852          return;
2853      }
2854  }
2855  size_t moduleCount(void) {
2856      return dictSize(modules);
2857  }
2858  void moduleRegisterCoreAPI(void) {
2859      server.moduleapi = dictCreate(&amp;moduleAPIDictType,NULL);
2860      server.sharedapi = dictCreate(&amp;moduleAPIDictType,NULL);
2861      REGISTER_API(Alloc);
2862      REGISTER_API(Calloc);
2863      REGISTER_API(Realloc);
2864      REGISTER_API(Free);
2865      REGISTER_API(Strdup);
2866      REGISTER_API(CreateCommand);
2867      REGISTER_API(SetModuleAttribs);
2868      REGISTER_API(IsModuleNameBusy);
2869      REGISTER_API(WrongArity);
2870      REGISTER_API(ReplyWithLongLong);
2871      REGISTER_API(ReplyWithError);
2872      REGISTER_API(ReplyWithSimpleString);
2873      REGISTER_API(ReplyWithArray);
2874      REGISTER_API(ReplySetArrayLength);
2875      REGISTER_API(ReplyWithString);
2876      REGISTER_API(ReplyWithStringBuffer);
2877      REGISTER_API(ReplyWithCString);
2878      REGISTER_API(ReplyWithNull);
2879      REGISTER_API(ReplyWithCallReply);
2880      REGISTER_API(ReplyWithDouble);
2881      REGISTER_API(GetSelectedDb);
2882      REGISTER_API(SelectDb);
2883      REGISTER_API(OpenKey);
2884      REGISTER_API(CloseKey);
2885      REGISTER_API(KeyType);
2886      REGISTER_API(ValueLength);
2887      REGISTER_API(ListPush);
2888      REGISTER_API(ListPop);
2889      REGISTER_API(StringToLongLong);
2890      REGISTER_API(StringToDouble);
2891      REGISTER_API(Call);
2892      REGISTER_API(CallReplyProto);
2893      REGISTER_API(FreeCallReply);
2894      REGISTER_API(CallReplyInteger);
2895      REGISTER_API(CallReplyType);
2896      REGISTER_API(CallReplyLength);
2897      REGISTER_API(CallReplyArrayElement);
2898      REGISTER_API(CallReplyStringPtr);
2899      REGISTER_API(CreateStringFromCallReply);
2900      REGISTER_API(CreateString);
2901      REGISTER_API(CreateStringFromLongLong);
2902      REGISTER_API(CreateStringFromString);
2903      REGISTER_API(CreateStringPrintf);
2904      REGISTER_API(FreeString);
2905      REGISTER_API(StringPtrLen);
2906      REGISTER_API(AutoMemory);
2907      REGISTER_API(Replicate);
2908      REGISTER_API(ReplicateVerbatim);
2909      REGISTER_API(DeleteKey);
2910      REGISTER_API(UnlinkKey);
2911      REGISTER_API(StringSet);
2912      REGISTER_API(StringDMA);
2913      REGISTER_API(StringTruncate);
2914      REGISTER_API(SetExpire);
2915      REGISTER_API(GetExpire);
2916      REGISTER_API(ZsetAdd);
2917      REGISTER_API(ZsetIncrby);
2918      REGISTER_API(ZsetScore);
2919      REGISTER_API(ZsetRem);
2920      REGISTER_API(ZsetRangeStop);
2921      REGISTER_API(ZsetFirstInScoreRange);
2922      REGISTER_API(ZsetLastInScoreRange);
2923      REGISTER_API(ZsetFirstInLexRange);
2924      REGISTER_API(ZsetLastInLexRange);
2925      REGISTER_API(ZsetRangeCurrentElement);
2926      REGISTER_API(ZsetRangeNext);
2927      REGISTER_API(ZsetRangePrev);
2928      REGISTER_API(ZsetRangeEndReached);
2929      REGISTER_API(HashSet);
2930      REGISTER_API(HashGet);
2931      REGISTER_API(IsKeysPositionRequest);
2932      REGISTER_API(KeyAtPos);
2933      REGISTER_API(GetClientId);
2934      REGISTER_API(GetContextFlags);
2935      REGISTER_API(PoolAlloc);
2936      REGISTER_API(CreateDataType);
2937      REGISTER_API(ModuleTypeSetValue);
2938      REGISTER_API(ModuleTypeGetType);
2939      REGISTER_API(ModuleTypeGetValue);
2940      REGISTER_API(SaveUnsigned);
2941      REGISTER_API(LoadUnsigned);
2942      REGISTER_API(SaveSigned);
2943      REGISTER_API(LoadSigned);
2944      REGISTER_API(SaveString);
2945      REGISTER_API(SaveStringBuffer);
2946      REGISTER_API(LoadString);
2947      REGISTER_API(LoadStringBuffer);
2948      REGISTER_API(SaveDouble);
2949      REGISTER_API(LoadDouble);
2950      REGISTER_API(SaveFloat);
2951      REGISTER_API(LoadFloat);
2952      REGISTER_API(EmitAOF);
2953      REGISTER_API(Log);
2954      REGISTER_API(LogIOError);
2955      REGISTER_API(StringAppendBuffer);
2956      REGISTER_API(RetainString);
2957      REGISTER_API(StringCompare);
2958      REGISTER_API(GetContextFromIO);
2959      REGISTER_API(GetKeyNameFromIO);
2960      REGISTER_API(BlockClient);
2961      REGISTER_API(UnblockClient);
2962      REGISTER_API(IsBlockedReplyRequest);
2963      REGISTER_API(IsBlockedTimeoutRequest);
2964      REGISTER_API(GetBlockedClientPrivateData);
2965      REGISTER_API(AbortBlock);
2966      REGISTER_API(Milliseconds);
2967      REGISTER_API(GetThreadSafeContext);
2968      REGISTER_API(FreeThreadSafeContext);
2969      REGISTER_API(ThreadSafeContextLock);
2970      REGISTER_API(ThreadSafeContextUnlock);
2971      REGISTER_API(DigestAddStringBuffer);
2972      REGISTER_API(DigestAddLongLong);
2973      REGISTER_API(DigestEndSequence);
2974      REGISTER_API(SubscribeToKeyspaceEvents);
2975      REGISTER_API(RegisterClusterMessageReceiver);
2976      REGISTER_API(SendClusterMessage);
2977      REGISTER_API(GetClusterNodeInfo);
2978      REGISTER_API(GetClusterNodesList);
2979      REGISTER_API(FreeClusterNodesList);
2980      REGISTER_API(CreateTimer);
2981      REGISTER_API(StopTimer);
2982      REGISTER_API(GetTimerInfo);
2983      REGISTER_API(GetMyClusterID);
2984      REGISTER_API(GetClusterSize);
2985      REGISTER_API(GetRandomBytes);
2986      REGISTER_API(GetRandomHexChars);
2987      REGISTER_API(BlockedClientDisconnected);
2988      REGISTER_API(SetDisconnectCallback);
2989      REGISTER_API(GetBlockedClientHandle);
2990      REGISTER_API(SetClusterFlags);
2991      REGISTER_API(CreateDict);
2992      REGISTER_API(FreeDict);
2993      REGISTER_API(DictSize);
2994      REGISTER_API(DictSetC);
2995      REGISTER_API(DictReplaceC);
2996      REGISTER_API(DictSet);
2997      REGISTER_API(DictReplace);
2998      REGISTER_API(DictGetC);
2999      REGISTER_API(DictGet);
3000      REGISTER_API(DictDelC);
3001      REGISTER_API(DictDel);
3002      REGISTER_API(DictIteratorStartC);
3003      REGISTER_API(DictIteratorStart);
3004      REGISTER_API(DictIteratorStop);
3005      REGISTER_API(DictIteratorReseekC);
3006      REGISTER_API(DictIteratorReseek);
3007      REGISTER_API(DictNextC);
3008      REGISTER_API(DictPrevC);
3009      REGISTER_API(DictNext);
3010      REGISTER_API(DictPrev);
3011      REGISTER_API(DictCompareC);
3012      REGISTER_API(DictCompare);
3013      REGISTER_API(ExportSharedAPI);
3014      REGISTER_API(GetSharedAPI);
3015      REGISTER_API(RegisterCommandFilter);
3016      REGISTER_API(UnregisterCommandFilter);
3017      REGISTER_API(CommandFilterArgsCount);
3018      REGISTER_API(CommandFilterArgGet);
3019      REGISTER_API(CommandFilterArgInsert);
3020      REGISTER_API(CommandFilterArgReplace);
3021      REGISTER_API(CommandFilterArgDelete);
3022  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-module.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-module.c</div>
                </div>
                <div class="column column_space"><pre><code>1113              key-&gt;zcurrent = next;
1114              return 1;
1115          }
1116      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1117          zskiplistNode *ln = key-&gt;zcurrent, *next = ln-&gt;level[0].forward;
</pre></code></div>
                <div class="column column_space"><pre><code>1167              key-&gt;zcurrent = prev;
1168              return 1;
1169          }
1170      } else if (key-&gt;value-&gt;encoding == OBJ_ENCODING_SKIPLIST) {
1171          zskiplistNode *ln = key-&gt;zcurrent, *prev = ln-&gt;backward;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    