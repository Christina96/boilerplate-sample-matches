<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for magick7load.c &amp; foreign.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for magick7load.c &amp; foreign.c
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>magick7load.c (6.6115704%)<th>foreign.c (2.3774145%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(807-825)<td><a href="#" name="0">(1138-1154)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(390-408)<td><a href="#" name="1">(1247-1276)</a><td align="center"><font color="#c60000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>magick7load.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/buf.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #ifdef ENABLE_MAGICKLOAD
11 #ifdef HAVE_MAGICK7
12 #include &lt;MagickCore/MagickCore.h&gt;
13 #include "magick.h"
14 typedef struct _VipsForeignLoadMagick7 {
15 	VipsForeignLoad parent_object;
16 	gboolean all_frames;
17 	char *density;				int page;				int n;				
18 	Image *image;
19 	ImageInfo *image_info;
20 	ExceptionInfo *exception;
21 	int n_pages;
22 	int n_frames;				Image **frames;				CacheView **cache_view; 		int frame_height;	
23 	GMutex *lock;
24 } VipsForeignLoadMagick7;
25 typedef VipsForeignLoadClass VipsForeignLoadMagick7Class;
26 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadMagick7, vips_foreign_load_magick7, 
27 	VIPS_TYPE_FOREIGN_LOAD );
28 #ifdef DEBUG
29 static void
30 vips_magick7_print_traits( Image *image ) 
31 {
32 	static const int trait_bits[] = {
33 		CopyPixelTrait,
34 		UpdatePixelTrait,
35 		BlendPixelTrait
36 	};
37 	static const char *trait_names[] = {
38 		"CopyPixelTrait",
39 		"UpdatePixelTrait",
40 		"BlendPixelTrait"
41 	};
42 	int b; 
43 	int i; 
44 	printf( "vips_magick7_print_traits: channel traits:\n" ); 
45 	for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { 
46 		PixelChannel channel = 
47 			GetPixelChannelChannel( image, b ); 
48 		PixelTrait traits = 
49 			GetPixelChannelTraits( image, channel );
50 		printf( "\t%d) ", b ); 
51 		for( i = 0; i &lt; VIPS_NUMBER( trait_bits ); i++ )
52 			if( traits &amp; trait_bits[i] )
53 				printf( "%s ", trait_names[i] ); 
54 		if( traits == 0 )
55 			printf( "undefined" ); 
56 		printf( "\n" ); 
57 	} 
58 }
59 static void
60 vips_magick7_print_channel_names( Image *image )
61 {
62 	static const int pixel_channels[] = {
63 		UndefinedPixelChannel, 
64 		RedPixelChannel, 
65 		CyanPixelChannel, 
66 		GrayPixelChannel, 
67 		LPixelChannel, 
68 		LabelPixelChannel, 
69 		YPixelChannel, 
70 		aPixelChannel, 
71 		GreenPixelChannel, 
72 		MagentaPixelChannel, 
73 		CbPixelChannel, 
74 		bPixelChannel, 
75 		BluePixelChannel, 
76 		YellowPixelChannel, 
77 		CrPixelChannel, 
78 		BlackPixelChannel, 
79 		AlphaPixelChannel, 
80 		IndexPixelChannel, 
81 		ReadMaskPixelChannel, 
82 		WriteMaskPixelChannel, 
83 		MetaPixelChannel, 
84 		IntensityPixelChannel, 
85 		CompositePixelChannel, 
86 		SyncPixelChannel
87 	};
88 	static const char *pixel_channel_names[] = {
89 		"UndefinedPixelChannel", 
90 		"RedPixelChannel", 
91 		"CyanPixelChannel", 
92 		"GrayPixelChannel", 
93 		"LPixelChannel", 
94 		"LabelPixelChannel", 
95 		"YPixelChannel", 
96 		"aPixelChannel", 
97 		"GreenPixelChannel", 
98 		"MagentaPixelChannel", 
99 		"CbPixelChannel", 
100 		"bPixelChannel", 
101 		"BluePixelChannel", 
102 		"YellowPixelChannel", 
103 		"CrPixelChannel", 
104 		"BlackPixelChannel", 
105 		"AlphaPixelChannel", 
106 		"IndexPixelChannel", 
107 		"ReadMaskPixelChannel", 
108 		"WriteMaskPixelChannel", 
109 		"MetaPixelChannel", 
110 		"IntensityPixelChannel", 
111 		"CompositePixelChannel", 
112 		"SyncPixelChannel", 
113 	};
114 	int b; 
115 	int i; 
116 	printf( "vips_magick7_print_channel_names: channel names:\n" ); 
117 	for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { 
118 		PixelChannel channel = 
119 			GetPixelChannelChannel( image, b ); 
120 		printf( "\t%d) ", b ); 
121 		for( i = 0; i &lt; VIPS_NUMBER( pixel_channels ); i++ )
122 			if( channel == pixel_channels[i] ) 
123 				printf( "%s ", pixel_channel_names[i] );
124 		printf( "\n" ); 
125 	} 
126 }
127 static void
128 vips_magick7_print_image_type( Image *image )
129 {
130 	static const int image_types[] = {
131 		UndefinedType,
132 		BilevelType,
133 		GrayscaleType,
134 		GrayscaleAlphaType, 
135 		PaletteType,
136 		PaletteAlphaType,
137 		TrueColorType,
138 		TrueColorAlphaType,
139 		ColorSeparationType,
140 		ColorSeparationAlphaType,
141 		OptimizeType,
142 		PaletteBilevelAlphaType
143 	};
144 	static const char *image_type_names[] = {
145 		"UndefinedType",
146 		"BilevelType",
147 		"GrayscaleType",
148 		"GrayscaleAlphaType", 
149 		"PaletteType",
150 		"PaletteAlphaType",
151 		"TrueColorType",
152 		"TrueColorAlphaType",
153 		"ColorSeparationType",
154 		"ColorSeparationAlphaType",
155 		"OptimizeType",
156 		"PaletteBilevelAlphaType"
157 	};
158 	int i;
159 	for( i = 0; i &lt; VIPS_NUMBER( image_types ); i++ ) 
160 		if( GetImageType( image ) == image_types[i] ) {
161 			printf( "\t%s\n", image_type_names[i] );
162 			break;
163 		}
164 	if( i == VIPS_NUMBER( image_types ) )
165 		printf( "\tunknown GetImageType()\n" ); 
166 }
167 static VipsForeignFlags
168 vips_foreign_load_magick7_get_flags_filename( const char *filename )
169 {
170 	return( VIPS_FOREIGN_PARTIAL );
171 }
172 static VipsForeignFlags
173 vips_foreign_load_magick7_get_flags( VipsForeignLoad *load )
174 {
175 	return( VIPS_FOREIGN_PARTIAL );
176 }
177 static void
178 vips_foreign_load_magick7_dispose( GObject *gobject )
179 {
180 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) gobject;
181 	int i;
182 #ifdef DEBUG
183 	printf( "vips_foreign_load_magick7_dispose: %p\n", gobject ); 
184 	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
185 		VIPS_FREEF( DestroyCacheView, magick7-&gt;cache_view[i] ); 
186 	}
187 	VIPS_FREEF( DestroyImageList, magick7-&gt;image );
188 	VIPS_FREEF( DestroyImageInfo, magick7-&gt;image_info ); 
189 	VIPS_FREE( magick7-&gt;frames );
190 	VIPS_FREE( magick7-&gt;cache_view );
191 	VIPS_FREEF( magick_destroy_exception, magick7-&gt;exception ); 
192 	VIPS_FREEF( vips_g_mutex_free, magick7-&gt;lock );
193 	G_OBJECT_CLASS( vips_foreign_load_magick7_parent_class )-&gt;
194 		dispose( gobject );
195 }
196 static int
197 vips_foreign_load_magick7_build( VipsObject *object )
198 {
199 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) object;
200 #ifdef DEBUG
201 	printf( "vips_foreign_load_magick7_build: %p\n", object ); 
202 	magick_genesis();
203 	magick7-&gt;image_info = CloneImageInfo( NULL );
204 	magick7-&gt;exception = magick_acquire_exception();
205 	magick7-&gt;lock = vips_g_mutex_new();
206 	if( !magick7-&gt;image_info ) 
207 		return( -1 );
208 	if( magick7-&gt;all_frames )
209 		magick7-&gt;n = -1;
210 	VIPS_SETSTR( magick7-&gt;image_info-&gt;density, magick7-&gt;density );
211   	magick_set_image_option( magick7-&gt;image_info, 
212 		"dcm:display-range", "reset" );
213 	if( magick7-&gt;page &gt; 0 ) 
214 		magick_set_number_scenes( magick7-&gt;image_info,
215 			magick7-&gt;page, magick7-&gt;n );
216 	if( VIPS_OBJECT_CLASS( vips_foreign_load_magick7_parent_class )-&gt;
217 		build( object ) )
218 		return( -1 );
219 	return( 0 );
220 }
221 static void
222 vips_foreign_load_magick7_class_init( VipsForeignLoadMagick7Class *class )
223 {
224 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
225 	VipsObjectClass *object_class = (VipsObjectClass *) class;
226 	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
227 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
228 	gobject_class-&gt;dispose = vips_foreign_load_magick7_dispose;
229 	gobject_class-&gt;set_property = vips_object_set_property;
230 	gobject_class-&gt;get_property = vips_object_get_property;
231 	object_class-&gt;nickname = "magickload_base";
232 	object_class-&gt;description = _( "load with ImageMagick7" );
233 	object_class-&gt;build = vips_foreign_load_magick7_build;
234 	foreign_class-&gt;priority = -100;
235 	load_class-&gt;get_flags_filename = 
236 		vips_foreign_load_magick7_get_flags_filename;
237 	load_class-&gt;get_flags = vips_foreign_load_magick7_get_flags;
238 	VIPS_ARG_STRING( class, "density", 20,
239 		_( "Density" ),
240 		_( "Canvas resolution for rendering vector formats like SVG" ),
241 		VIPS_ARGUMENT_OPTIONAL_INPUT,
242 		G_STRUCT_OFFSET( VipsForeignLoadMagick7, density ),
243 		NULL );
244 	VIPS_ARG_INT( class, "page", 21,
245 		_( "Page" ),
246 		_( "Load this page from the file" ),
247 		VIPS_ARGUMENT_OPTIONAL_INPUT,
248 		G_STRUCT_OFFSET( VipsForeignLoadMagick7, page ),
249 		0, 100000, 0 );
250 	VIPS_ARG_INT( class, "n", 22,
251 		_( "n" ),
252 		_( "Load this many pages" ),
253 		VIPS_ARGUMENT_OPTIONAL_INPUT,
254 		G_STRUCT_OFFSET( VipsForeignLoadMagick7, n ),
255 		-1, 100000, 1 );
256 	VIPS_ARG_BOOL( class, "all_frames", 23, 
257 		_( "all_frames" ), 
258 		_( "Read all frames from an image" ),
259 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
260 <a name="1"></a>		G_STRUCT_OFFSET( VipsForeignLoadMagick7, all_frames ),
261 		FALSE );
262 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
263 static void
264 vips_foreign_load_magick7_init( VipsForeignLoadMagick7 *magick7 )
265 {
266 	magick7-&gt;n = 1;
267 }
268 static void
269 vips_foreign_load_magick7_error( VipsForeignLoadMagick7 *magick7 )
270 {
271 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( magick7 );
272 	vips_error( class-&gt;nickname, _( "Magick: %s %s" ),
273 		magick7-&gt;exception-&gt;reason, 
274 		magick7-&gt;exception-&gt;description );
275 }
276 static int</b></font>
277 magick7_get_bands( Image *image )
278 {
279 	int bands;
280 	int i;
281 	bands = 0;
282 	for( i = 0; i &lt; GetPixelChannels( image ); i++ ) { 
283 		PixelChannel channel = GetPixelChannelChannel( image, i ); 
284 		if( channel != IndexPixelChannel ) 
285 			bands += 1;
286 	} 
287 	return( bands );
288 }
289 static int
290 vips_foreign_load_magick7_parse( VipsForeignLoadMagick7 *magick7, 
291 	Image *image, VipsImage *out )
292 {
293 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( magick7 );
294 	const char *key;
295 	Image *p;
296 #ifdef DEBUG
297 	printf( "image-&gt;depth = %zd\n", image-&gt;depth ); 
298 	printf( "GetImageType() = %d\n", GetImageType( image ) );
299 	vips_magick7_print_image_type( image ); 
300 	printf( "GetPixelChannels() = %zd\n", GetPixelChannels( image ) ); 
301 	printf( "image-&gt;columns = %zd\n", image-&gt;columns ); 
302 	printf( "image-&gt;rows = %zd\n", image-&gt;rows ); 
303 	out-&gt;Xsize = image-&gt;columns;
304 	out-&gt;Ysize = image-&gt;rows;
305 	magick7-&gt;frame_height = image-&gt;rows;
306 	out-&gt;Bands = magick7_get_bands( image ); 
307 	if( out-&gt;Xsize &lt;= 0 ||
308 		out-&gt;Ysize &lt;= 0 ||
309 		out-&gt;Bands &lt;= 0 ||
310 		out-&gt;Xsize &gt;= VIPS_MAX_COORD ||
311 		out-&gt;Ysize &gt;= VIPS_MAX_COORD ||
312 		out-&gt;Bands &gt;= VIPS_MAX_COORD ) {
313 		vips_error( class-&gt;nickname, 
314 			_( "bad image dimensions %d x %d pixels, %d bands" ),
315 			out-&gt;Xsize, out-&gt;Ysize, out-&gt;Bands );
316 		return( -1 );
317 	}
318 	out-&gt;BandFmt = -1;
319 	if( image-&gt;depth &gt;= 1 &amp;&amp; image-&gt;depth &lt;= 8 ) 
320 		out-&gt;BandFmt = VIPS_FORMAT_UCHAR;
321 	if( image-&gt;depth &gt;= 9 &amp;&amp; image-&gt;depth &lt;= 16 ) 
322 		out-&gt;BandFmt = VIPS_FORMAT_USHORT;
323 	if( image-&gt;depth == 32 )
324 		out-&gt;BandFmt = VIPS_FORMAT_FLOAT;
325 	if( image-&gt;depth == 64 )
326 		out-&gt;BandFmt = VIPS_FORMAT_DOUBLE;
327 	if( out-&gt;BandFmt == -1 ) {
328 		vips_error( class-&gt;nickname, 
329 			_( "unsupported bit depth %zd" ), image-&gt;depth );
330 		return( -1 );
331 	}
332 	switch( image-&gt;colorspace ) {
333 	case GRAYColorspace:
334 		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
335 			out-&gt;Type = VIPS_INTERPRETATION_GREY16;
336 		else
337 			out-&gt;Type = VIPS_INTERPRETATION_B_W;
338 		break;
339 	case sRGBColorspace:
340 	case RGBColorspace:
341 		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
342 			out-&gt;Type = VIPS_INTERPRETATION_RGB16;
343 		else
344 			out-&gt;Type = VIPS_INTERPRETATION_sRGB;
345 		break;
346 	case CMYKColorspace:
347 		out-&gt;Type = VIPS_INTERPRETATION_CMYK;
348 		break;
349 	default:
350 		vips_error( class-&gt;nickname, 
351 			_( "unsupported colorspace %s" ), 
352 			magick_ColorspaceType2str( image-&gt;colorspace ) );
353 		return( -1 );
354 	}
355 	switch( image-&gt;units ) {
356 	case PixelsPerInchResolution:
357 		out-&gt;Xres = image-&gt;resolution.x / 25.4;
358 		out-&gt;Yres = image-&gt;resolution.y / 25.4;
359 		vips_image_set_string( out, VIPS_META_RESOLUTION_UNIT, "in" );
360 		break;
361 	case PixelsPerCentimeterResolution:
362 		out-&gt;Xres = image-&gt;resolution.x / 10.0;
363 		out-&gt;Yres = image-&gt;resolution.y / 10.0;
364 		vips_image_set_string( out, VIPS_META_RESOLUTION_UNIT, "cm" );
365 		break;
366 	default:
367 		out-&gt;Xres = 1.0;
368 		out-&gt;Yres = 1.0;
369 		break;
370 	}
371 	out-&gt;Coding = VIPS_CODING_NONE;
372 	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_SMALLTILE, NULL ) )
373 		return( -1 );
374 	ResetImagePropertyIterator( image );
375 	while( (key = GetNextImageProperty( image )) ) {
376 		char name_text[256];
377 		VipsBuf name = VIPS_BUF_STATIC( name_text );
378 		const char *value;
379 		value = GetImageProperty( image, key, magick7-&gt;exception );
380 		if( !value ) {
381 			vips_foreign_load_magick7_error( magick7 );
382 			return( -1 ); 
383 		}
384 		vips_buf_appendf( &amp;name, "magick-%s", key );
385 		vips_image_set_string( out, vips_buf_all( &amp;name ), value );
386 	}
387 	if( magick_set_vips_profile( out, image ) )
388 		return( -1 );
389 	magick7-&gt;n_pages = GetImageListLength( GetFirstImageInList( image ) );
390 #ifdef DEBUG
391 	printf( "image has %d pages\n", magick7-&gt;n_pages );
392 	magick7-&gt;n_frames = 0;
393 	for( p = image; p; (p = GetNextImageInList( p )) ) {
394 		if( p-&gt;columns != (unsigned int) out-&gt;Xsize ||
395 			p-&gt;rows != (unsigned int) out-&gt;Ysize ||
396 			magick7_get_bands( p ) != out-&gt;Bands ||
397 			p-&gt;depth != image-&gt;depth ) {
398 #ifdef DEBUG
399 			printf( "frame %d differs\n", magick7-&gt;n_frames );
400 			printf( "%zdx%zd, %d bands\n", 
401 				p-&gt;columns, p-&gt;rows, magick7_get_bands( p ) );
402 			printf( "first frame is %dx%d, %d bands\n", 
403 				out-&gt;Xsize, out-&gt;Ysize, out-&gt;Bands );
404 			break;
405 		}
406 		magick7-&gt;n_frames += 1;
407 	}
408 	if( p ) 
409 		magick7-&gt;n_frames = 1;
410 #ifdef DEBUG
411 	printf( "will read %d frames\n", magick7-&gt;n_frames );
412 	if( magick7-&gt;n != -1 )
413 		magick7-&gt;n_frames = VIPS_MIN( magick7-&gt;n_frames, magick7-&gt;n );
414 	if( vips_object_argument_isset( VIPS_OBJECT( magick7 ), "n" ) ) {
415 		vips_image_set_int( out, VIPS_META_PAGE_HEIGHT, out-&gt;Ysize );
416 		out-&gt;Ysize *= magick7-&gt;n_frames;
417 	}
418 	vips_image_set_int( out, VIPS_META_N_PAGES, magick7-&gt;n_pages );
419 	return( 0 );
420 }
421 #define UNPACK( TYPE ) { \
422 	TYPE * restrict tq = (TYPE *) q; \
423 	int x; \
424 	int b; \
425 	\
426 	for( x = 0; x &lt; r-&gt;width; x++ ) { \
427 		for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { \
428 			PixelChannel channel = \
429 				GetPixelChannelChannel( image, b ); \
430 			\
431 			if( channel != IndexPixelChannel ) \
432 				*tq++ = p[b]; \
433 		} \
434 		\
435 		p += GetPixelChannels( image ); \
436 	} \
437 }
438 static int
439 vips_foreign_load_magick7_fill_region( VipsRegion *or, 
440 	void *seq, void *a, void *b, gboolean *stop )
441 {
442 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) a;
443 	VipsRect *r = &amp;or-&gt;valid;
444 	VipsImage *im = or-&gt;im;
445 	int y;
446 	for( y = 0; y &lt; r-&gt;height; y++ ) {
447 		int top = r-&gt;top + y;
448 		int frame = top / magick7-&gt;frame_height;
449 		int line = top % magick7-&gt;frame_height;
450 		Image *image = magick7-&gt;frames[frame];
451 		Quantum * restrict p;
452 		VipsPel * restrict q;
453 		g_mutex_lock( magick7-&gt;lock );
454 		p = GetCacheViewAuthenticPixels( magick7-&gt;cache_view[frame],
455 			r-&gt;left, line, r-&gt;width, 1, 
456 			magick7-&gt;exception );
457 		g_mutex_unlock( magick7-&gt;lock );
458 		if( !p ) 
459 			continue;
460 		q = VIPS_REGION_ADDR( or, r-&gt;left, top ); 
461 		switch( im-&gt;BandFmt ) {
462 		case VIPS_FORMAT_UCHAR:
463 			UNPACK( unsigned char ); 
464 			break;
465 		case VIPS_FORMAT_USHORT:
466 			UNPACK( unsigned short ); 
467 			break;
468 		case VIPS_FORMAT_FLOAT:
469 			UNPACK( float ); 
470 			break;
471 		case VIPS_FORMAT_DOUBLE:
472 			UNPACK( double ); 
473 			break;
474 		default:
475 			g_assert_not_reached();
476 		}
477 	}
478 	return( 0 );
479 }
480 static int
481 vips_foreign_load_magick7_load( VipsForeignLoadMagick7 *magick7 )
482 {
483 	VipsForeignLoad *load = (VipsForeignLoad *) magick7;
484 	Image *p;
485 	int i;
486 #ifdef DEBUG
487 	printf( "vips_foreign_load_magick7_load: %p\n", magick7 ); 
488 	if( vips_foreign_load_magick7_parse( magick7, 
489 		magick7-&gt;image, load-&gt;out ) )
490 		return( -1 );
491 	g_assert( !magick7-&gt;frames ); 
492 	if( !(magick7-&gt;frames = 
493 		VIPS_ARRAY( NULL, magick7-&gt;n_frames, Image * )) )
494 		return( -1 );
495 	p = magick7-&gt;image;
496 	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
497 		magick7-&gt;frames[i] = p;
498 		p = GetNextImageInList( p );
499 	}
500 	g_assert( !magick7-&gt;cache_view ); 
501 	if( !(magick7-&gt;cache_view = VIPS_ARRAY( NULL, 
502 		magick7-&gt;n_frames, CacheView * )) )
503 		return( -1 );
504 	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
505 		magick7-&gt;cache_view[i] = AcquireAuthenticCacheView( 
506 			magick7-&gt;frames[i], magick7-&gt;exception );
507 	}
508 #ifdef DEBUG
509 	vips_magick7_print_traits( magick7-&gt;frames[0] ); 
510 	vips_magick7_print_channel_names( magick7-&gt;frames[0] );
511 	if( vips_image_generate( load-&gt;out, 
512 		NULL, vips_foreign_load_magick7_fill_region, NULL, 
513 		magick7, NULL ) )
514 		return( -1 );
515 	return( 0 );
516 }
517 typedef struct _VipsForeignLoadMagick7File {
518 	VipsForeignLoadMagick7 parent_object;
519 	char *filename; 
520 } VipsForeignLoadMagick7File;
521 typedef VipsForeignLoadMagick7Class VipsForeignLoadMagick7FileClass;
522 G_DEFINE_TYPE( VipsForeignLoadMagick7File, vips_foreign_load_magick7_file, 
523 	vips_foreign_load_magick7_get_type() );
524 static gboolean
525 ismagick7( const char *filename )
526 {
527 	unsigned char buf[100];
528 	int len;
529 	return( (len = vips__get_bytes( filename, buf, 100 )) &gt; 10 &amp;&amp;
530 		magick_ismagick( buf, len ) );
531 }
532 static int
533 vips_foreign_load_magick7_file_header( VipsForeignLoad *load )
534 {
535 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) load;
536 	VipsForeignLoadMagick7File *file = (VipsForeignLoadMagick7File *) load;
537 #ifdef DEBUG
538 	printf( "vips_foreign_load_magick7_file_header: %p\n", load ); 
539 	vips_strncpy( magick7-&gt;image_info-&gt;filename, file-&gt;filename, 
540 		MagickPathExtent );
541 	magick_sniff_file( magick7-&gt;image_info, file-&gt;filename );
542 	magick7-&gt;image = ReadImage( magick7-&gt;image_info, magick7-&gt;exception );
543 	if( !magick7-&gt;image ) {
544 		vips_foreign_load_magick7_error( magick7 ); 
545 		return( -1 );
546 	}
547 	if( vips_foreign_load_magick7_load( magick7 ) )
548 		return( -1 );
549 <a name="0"></a>
550 	VIPS_SETSTR( load-&gt;out-&gt;filename, file-&gt;filename );
551 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
552 }
553 static void
554 vips_foreign_load_magick7_file_class_init( 
555 	VipsForeignLoadMagick7FileClass *class )
556 {
557 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
558 	VipsObjectClass *object_class = (VipsObjectClass *) class;
559 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
560 	gobject_class-&gt;set_property = vips_object_set_property;
561 	gobject_class-&gt;get_property = vips_object_get_property;
562 	object_class-&gt;nickname = "magickload";
563 	object_class-&gt;description = _( "load file with ImageMagick7" );
564 	load_class-&gt;is_a = ismagick7;
565 	load_class-&gt;header = vips_foreign_load_magick7_file_header;</b></font>
566 	VIPS_ARG_STRING( class, "filename", 1, 
567 		_( "Filename" ),
568 		_( "Filename to load from" ),
569 		VIPS_ARGUMENT_REQUIRED_INPUT, 
570 		G_STRUCT_OFFSET( VipsForeignLoadMagick7File, filename ),
571 		NULL );
572 }
573 static void
574 vips_foreign_load_magick7_file_init( VipsForeignLoadMagick7File *magick7_file )
575 {
576 }
577 typedef struct _VipsForeignLoadMagick7Buffer {
578 	VipsForeignLoadMagick7 parent_object;
579 	VipsArea *buf;
580 } VipsForeignLoadMagick7Buffer;
581 typedef VipsForeignLoadMagick7Class VipsForeignLoadMagick7BufferClass;
582 G_DEFINE_TYPE( VipsForeignLoadMagick7Buffer, vips_foreign_load_magick7_buffer, 
583 	vips_foreign_load_magick7_get_type() );
584 static gboolean
585 vips_foreign_load_magick7_buffer_is_a_buffer( const void *buf, size_t len )
586 {
587 	return( len &gt; 10 &amp;&amp; magick_ismagick( (const unsigned char *) buf, len ) );
588 }
589 static int
590 vips_foreign_load_magick7_buffer_header( VipsForeignLoad *load )
591 {
592 	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) load;
593 	VipsForeignLoadMagick7Buffer *magick7_buffer = 
594 		(VipsForeignLoadMagick7Buffer *) load;
595 #ifdef DEBUG
596 	printf( "vips_foreign_load_magick7_buffer_header: %p\n", load ); 
597 	magick_sniff_bytes( magick7-&gt;image_info, 
598 		magick7_buffer-&gt;buf-&gt;data, magick7_buffer-&gt;buf-&gt;length );
599 	magick7-&gt;image = BlobToImage( magick7-&gt;image_info, 
600 		magick7_buffer-&gt;buf-&gt;data, magick7_buffer-&gt;buf-&gt;length,
601 		magick7-&gt;exception );
602 	if( !magick7-&gt;image ) {
603 		vips_foreign_load_magick7_error( magick7 ); 
604 		return( -1 );
605 	}
606 	if( vips_foreign_load_magick7_load( magick7 ) )
607 		return( -1 );
608 	return( 0 );
609 }
610 static void
611 vips_foreign_load_magick7_buffer_class_init( 
612 	VipsForeignLoadMagick7BufferClass *class )
613 {
614 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
615 	VipsObjectClass *object_class = (VipsObjectClass *) class;
616 	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
617 	gobject_class-&gt;set_property = vips_object_set_property;
618 	gobject_class-&gt;get_property = vips_object_get_property;
619 	object_class-&gt;nickname = "magickload_buffer";
620 	object_class-&gt;description = _( "load buffer with ImageMagick7" );
621 	load_class-&gt;is_a_buffer = vips_foreign_load_magick7_buffer_is_a_buffer;
622 	load_class-&gt;header = vips_foreign_load_magick7_buffer_header;
623 	VIPS_ARG_BOXED( class, "buffer", 1, 
624 		_( "Buffer" ),
625 		_( "Buffer to load from" ),
626 		VIPS_ARGUMENT_REQUIRED_INPUT, 
627 		G_STRUCT_OFFSET( VipsForeignLoadMagick7Buffer, buf ),
628 		VIPS_TYPE_BLOB );
629 }
630 static void
631 vips_foreign_load_magick7_buffer_init( VipsForeignLoadMagick7Buffer *buffer )
632 {
633 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>foreign.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/internal.h&gt;
8 #include &lt;vips/debug.h&gt;
9 #include "pforeign.h"
10 static GQuark vips__foreign_load_operation = 0; 
11 G_DEFINE_ABSTRACT_TYPE( VipsForeign, vips_foreign, VIPS_TYPE_OPERATION );
12 static void
13 vips_foreign_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
14 {
15 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( object_class );
16 	VIPS_OBJECT_CLASS( vips_foreign_parent_class )-&gt;
17 		summary_class( object_class, buf );
18 	if( class-&gt;suffs ) {
19 		const char **p;
20 		vips_buf_appends( buf, " (" );
21 		for( p = class-&gt;suffs; *p; p++ ) {
22 			vips_buf_appendf( buf, "%s", *p );
23 			if( p[1] )
24 				vips_buf_appends( buf, ", " );
25 		}
26 		vips_buf_appends( buf, ")" );
27 	}
28 	vips_buf_appendf( buf, ", priority=%d", class-&gt;priority );
29 }
30 static void
31 vips_foreign_class_init( VipsForeignClass *class )
32 {
33 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
34 	VipsObjectClass *object_class = (VipsObjectClass *) class;
35 	gobject_class-&gt;set_property = vips_object_set_property;
36 	gobject_class-&gt;get_property = vips_object_get_property;
37 	object_class-&gt;nickname = "foreign";
38 	object_class-&gt;description = _( "load and save image files" );
39 	object_class-&gt;summary_class = vips_foreign_summary_class;
40 }
41 static void
42 vips_foreign_init( VipsForeign *object )
43 {
44 }
45 static void *
46 file_add_class( VipsForeignClass *class, GSList **files )
47 {
48 	if( !vips_isprefix( "rawload", VIPS_OBJECT_CLASS( class )-&gt;nickname ) ) 
49 		*files = g_slist_append( *files, class );
50 	return( NULL );
51 }
52 static gint
53 file_compare( VipsForeignClass *a, VipsForeignClass *b, void *user_data )
54 {
55         return( b-&gt;priority - a-&gt;priority );
56 }
57 void *
58 vips_foreign_map( const char *base, VipsSListMap2Fn fn, void *a, void *b )
59 {
60 	GSList *files;
61 	void *result;
62 	files = NULL;
63 	(void) vips_class_map_all( g_type_from_name( base ), 
64 		(VipsClassMapFn) file_add_class, (void *) &amp;files );
65 	files = g_slist_sort( files, (GCompareFunc) file_compare );
66 #ifdef DEBUG
67 {
68 	GSList *p;
69 	printf( "vips_foreign_map: search order\n" );
70 	for( p = files; p; p = p-&gt;next ) {
71 		VipsForeignClass *class = (VipsForeignClass *) p-&gt;data;
72 		printf( "\t%s\n", VIPS_OBJECT_CLASS( class )-&gt;nickname );
73 	}
74 }
75 	result = vips_slist_map2( files, fn, a, b );
76 	g_slist_free( files );
77 	return( result );
78 }
79 G_DEFINE_ABSTRACT_TYPE( VipsForeignLoad, vips_foreign_load, VIPS_TYPE_FOREIGN );
80 static void
81 vips_foreign_load_dispose( GObject *gobject )
82 {
83 	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( gobject );
84 	VIPS_UNREF( load-&gt;real );
85 	G_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;dispose( gobject );
86 }
87 static void
88 vips_foreign_load_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
89 {
90 	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_CLASS( object_class );
91 	VIPS_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;
92 		summary_class( object_class, buf );
93 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) ) {
94 		if( class-&gt;is_a )
95 			vips_buf_appends( buf, ", is_a" );
96 		if( class-&gt;is_a_buffer )
97 			vips_buf_appends( buf, ", is_a_buffer" );
98 		if( class-&gt;is_a_source )
99 			vips_buf_appends( buf, ", is_a_source" );
100 		if( class-&gt;get_flags )
101 			vips_buf_appends( buf, ", get_flags" );
102 		if( class-&gt;get_flags_filename )
103 			vips_buf_appends( buf, ", get_flags_filename" );
104 		if( class-&gt;header )
105 			vips_buf_appends( buf, ", header" );
106 		if( class-&gt;load )
107 			vips_buf_appends( buf, ", load" );
108 		g_assert( class-&gt;header );
109 	}
110 }
111 static void *
112 vips_foreign_find_load_sub( VipsForeignLoadClass *load_class, 
113 	const char *filename, void *b )
114 {
115 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( load_class );
116 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( load_class );
117 	if( vips_ispostfix( object_class-&gt;nickname, "_buffer" ) ||
118 		vips_ispostfix( object_class-&gt;nickname, "_source" ) ) 
119 		return( NULL );
120 #ifdef DEBUG
121 	printf( "vips_foreign_find_load_sub: %s\n", 
122 		VIPS_OBJECT_CLASS( class )-&gt;nickname );
123 	if( load_class-&gt;is_a ) {
124 		if( load_class-&gt;is_a( filename ) ) 
125 			return( load_class );
126 #ifdef DEBUG
127 		printf( "vips_foreign_find_load_sub: is_a failed\n" ); 
128 	}
129 	else if( class-&gt;suffs ) {
130 		if( vips_filename_suffix_match( filename, class-&gt;suffs ) )
131 			return( load_class );
132 	}
133 	else 
134 		g_warning( "loader %s has no is_a method and no suffix list", 
135 			object_class-&gt;nickname );
136 	return( NULL );
137 }
138 const char *
139 vips_foreign_find_load( const char *name )
140 {
141 	char filename[VIPS_PATH_MAX];
142 	char option_string[VIPS_PATH_MAX];
143 	VipsForeignLoadClass *load_class;
144 	vips__filename_split8( name, filename, option_string );
145 	if( !vips_existsf( "%s", filename ) ) {
146 		vips_error( "VipsForeignLoad", 
147 			_( "file \"%s\" does not exist" ), name );
148 		return( NULL );
149 	}
150 	if( vips_isdirf( "%s", filename ) ) {
151 		vips_error( "VipsForeignLoad", 
152 			_( "\"%s\" is a directory" ), name );
153 		return( NULL );
154 	}
155 	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
156 		"VipsForeignLoad",
157 		(VipsSListMap2Fn) vips_foreign_find_load_sub, 
158 		(void *) filename, NULL )) ) {
159 		vips_error( "VipsForeignLoad", 
160 			_( "\"%s\" is not a known file format" ), name );
161 		return( NULL );
162 	}
163 #ifdef DEBUG
164 	printf( "vips_foreign_find_load: selected %s\n", 
165 		VIPS_OBJECT_CLASS( load_class )-&gt;nickname );
166 	return( G_OBJECT_CLASS_NAME( load_class ) );
167 }
168 int
169 vips_foreign_load( const char *name, VipsImage **out, ... )
170 {
171 	char filename[VIPS_PATH_MAX];
172 	char option_string[VIPS_PATH_MAX];
173 	const char *operation_name;
174 	va_list ap;
175 	int result;
176 	vips__filename_split8( name, filename, option_string );
177 	if( !(operation_name = vips_foreign_find_load( filename )) )
178 		return( -1 );
179 	va_start( ap, out );
180 	result = vips_call_split_option_string( operation_name, option_string, 
181 		ap, filename, out );
182 	va_end( ap );
183 	return( result );
184 }
185 static void *
186 vips_foreign_find_load_buffer_sub( VipsForeignLoadClass *load_class, 
187 	const void **buf, size_t *len )
188 {
189 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( load_class );
190 	if( !vips_ispostfix( object_class-&gt;nickname, "_buffer" ) )
191 		return( NULL );
192 	if( load_class-&gt;is_a_buffer ) {
193 		if( load_class-&gt;is_a_buffer( *buf, *len ) ) 
194 			return( load_class );
195 	}
196 	else
197 		g_warning( "loader %s has no is_a_buffer method", 
198 			object_class-&gt;nickname );
199 	return( NULL );
200 }
201 const char *
202 vips_foreign_find_load_buffer( const void *data, size_t size )
203 {
204 	VipsForeignLoadClass *load_class;
205 	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
206 		"VipsForeignLoad",
207 		(VipsSListMap2Fn) vips_foreign_find_load_buffer_sub, 
208 		&amp;data, &amp;size )) ) {
209 		vips_error( "VipsForeignLoad", 
210 			"%s", _( "buffer is not in a known format" ) ); 
211 		return( NULL );
212 	}
213 	return( G_OBJECT_CLASS_NAME( load_class ) );
214 }
215 static void *
216 vips_foreign_find_load_source_sub( void *item, void *a, void *b )
217 {
218 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( item );
219 	VipsForeignLoadClass *load_class = VIPS_FOREIGN_LOAD_CLASS( item );
220 	VipsSource *source = VIPS_SOURCE( a );
221 	if( !vips_ispostfix( object_class-&gt;nickname, "_source" ) )
222 		return( NULL );
223 	if( load_class-&gt;is_a_source ) {
224 		(void) vips_source_rewind( source );
225 		if( load_class-&gt;is_a_source( source ) ) 
226 			return( load_class );
227 	}
228 	else 
229 		g_warning( "loader %s has no is_a_source method", 
230 			object_class-&gt;nickname );
231 	return( NULL );
232 }
233 const char *
234 vips_foreign_find_load_source( VipsSource *source )
235 {
236 	VipsForeignLoadClass *load_class;
237 	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
238 		"VipsForeignLoad",
239 		vips_foreign_find_load_source_sub, 
240 		source, NULL )) ) {
241 		vips_error( "VipsForeignLoad", 
242 			"%s", _( "source is not in a known format" ) ); 
243 		return( NULL );
244 	}
245 	return( G_OBJECT_CLASS_NAME( load_class ) );
246 }
247 gboolean 
248 vips_foreign_is_a( const char *loader, const char *filename )
249 {
250 	const VipsObjectClass *class;
251 	VipsForeignLoadClass *load_class;
252 	if( !(class = vips_class_find( "VipsForeignLoad", loader )) ) 
253 		return( FALSE );
254 	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
255 	if( load_class-&gt;is_a &amp;&amp;
256 		load_class-&gt;is_a( filename ) ) 
257 		return( TRUE );
258 	return( FALSE );
259 }
260 gboolean
261 vips_foreign_is_a_buffer( const char *loader, const void *data, size_t size )
262 {
263 	const VipsObjectClass *class;
264 	VipsForeignLoadClass *load_class;
265 	if( !(class = vips_class_find( "VipsForeignLoad", loader )) )
266 		return( FALSE );
267 	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
268 	if( load_class-&gt;is_a_buffer &amp;&amp;
269 		load_class-&gt;is_a_buffer( data, size ) )
270 		return( TRUE );
271 	return( FALSE );
272 }
273 gboolean
274 vips_foreign_is_a_source( const char *loader, VipsSource *source )
275 {
276 	const VipsObjectClass *class;
277 	VipsForeignLoadClass *load_class;
278 	if( !(class = vips_class_find( "VipsForeignLoad", loader )) )
279 		return( FALSE );
280 	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
281 	if( load_class-&gt;is_a_source &amp;&amp;
282 		load_class-&gt;is_a_source( source ) )
283 		return( TRUE );
284 	return( FALSE );
285 }
286 VipsForeignFlags 
287 vips_foreign_flags( const char *loader, const char *filename )
288 {
289 	const VipsObjectClass *class;
290 	if( (class = vips_class_find( "VipsForeignLoad", loader )) ) {
291 		VipsForeignLoadClass *load_class = 
292 			VIPS_FOREIGN_LOAD_CLASS( class );
293 		if( load_class-&gt;get_flags_filename ) 
294 			return( load_class-&gt;get_flags_filename( filename ) );
295 	}
296 	return( 0 );
297 }
298 static VipsObject *
299 vips_foreign_load_new_from_string( const char *string )
300 {
301 	const char *file_op;
302 	GType type;
303 	VipsForeignLoad *load;
304 	if( !(file_op = vips_foreign_find_load( string )) )
305 		return( NULL );
306 	type = g_type_from_name( file_op );
307 	g_assert( type ); 
308 	load = VIPS_FOREIGN_LOAD( g_object_new( type, NULL ) );
309 	g_object_set( load,
310 		"filename", string,
311 		NULL );
312 	return( VIPS_OBJECT( load ) );
313 }
314 static VipsImage *
315 vips_foreign_load_temp( VipsForeignLoad *load )
316 {
317 	const guint64 disc_threshold = vips_get_disc_threshold();
318 	const guint64 image_size = VIPS_IMAGE_SIZEOF_IMAGE( load-&gt;out );
319 	if( !load-&gt;disc )
320 		load-&gt;memory = TRUE;
321 	if( load-&gt;memory ) {
322 #ifdef DEBUG
323 		printf( "vips_foreign_load_temp: forced memory temp\n" );
324 		return( vips_image_new_memory() );
325 	}
326 	if( load-&gt;flags &amp; VIPS_FOREIGN_PARTIAL ) {
327 #ifdef DEBUG
328 		printf( "vips_foreign_load_temp: partial temp\n" );
329 		return( vips_image_new() );
330 	}
331 	if( (load-&gt;flags &amp; VIPS_FOREIGN_SEQUENTIAL) &amp;&amp; 
332 		load-&gt;access != VIPS_ACCESS_RANDOM ) {
333 #ifdef DEBUG
334 		printf( "vips_foreign_load_temp: partial sequential temp\n" );
335 		return( vips_image_new() );
336 	}
337 	if( image_size &gt; disc_threshold ) {
338 #ifdef DEBUG
339 		printf( "vips_foreign_load_temp: disc temp\n" );
340 		return( vips_image_new_temp_file( "%s.v" ) );
341 	}
342 #ifdef DEBUG
343 	printf( "vips_foreign_load_temp: fallback memory temp\n" );
344 	return( vips_image_new_memory() );
345 }
346 static gboolean
347 vips_foreign_load_iscompat( VipsImage *a, VipsImage *b )
348 {
349 	if( a-&gt;Xsize != b-&gt;Xsize ||
350 		a-&gt;Ysize != b-&gt;Ysize ||
351 		a-&gt;Bands != b-&gt;Bands ||
352 		a-&gt;Coding != b-&gt;Coding ||
353 		a-&gt;BandFmt != b-&gt;BandFmt ) {
354 		vips_error( "VipsForeignLoad",
355 			"%s", _( "images do not match" ) ); 
356 		return( FALSE );
357 	}
358 	return( TRUE );
359 }
360 static void *
361 vips_foreign_load_start( VipsImage *out, void *a, void *b )
362 {
363 	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );
364 	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );
365 	if( load-&gt;error )
366 		return( NULL );
367 	if( !load-&gt;real ) {
368 		if( !(load-&gt;real = vips_foreign_load_temp( load )) )
369 			return( NULL );
370 #ifdef DEBUG
371 		printf( "vips_foreign_load_start: triggering -&gt;load()\n" );
372 		load-&gt;real-&gt;progress_signal = load-&gt;out;
373 		g_object_set_qdata( G_OBJECT( load-&gt;real ), 
374 			vips__foreign_load_operation, load ); 
375 		if( class-&gt;load( load ) ||
376 			vips_image_pio_input( load-&gt;real ) || 
377 			!vips_foreign_load_iscompat( load-&gt;real, out ) ) {
378 			vips_operation_invalidate( VIPS_OPERATION( load ) ); 
379 			load-&gt;error = TRUE;
380 			return( NULL );
381 		}
382 		if( vips_image_pipelinev( load-&gt;out, load-&gt;out-&gt;dhint, 
383 			load-&gt;real, NULL ) )
384 			return( NULL );
385 	}
386 	return( vips_region_new( load-&gt;real ) );
387 }
388 static int
389 vips_foreign_load_generate( VipsRegion *or, 
390 	void *seq, void *a, void *b, gboolean *stop )
391 {
392 	VipsRegion *ir = (VipsRegion *) seq;
393         VipsRect *r = &amp;or-&gt;valid;
394         if( vips_region_prepare( ir, r ) )
395                 return( -1 );
396         if( vips_region_region( or, ir, r, r-&gt;left, r-&gt;top ) )
397                 return( -1 );
398         return( 0 );
399 }
400 static int
401 vips_foreign_load_build( VipsObject *object )
402 {
403 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
404 	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( object );
405 	VipsForeignLoadClass *fclass = VIPS_FOREIGN_LOAD_GET_CLASS( object );
406 	VipsForeignFlags flags;
407 	gboolean sequential;
408 #ifdef DEBUG
409 	printf( "vips_foreign_load_build:\n" );
410 	flags = 0;
411 	if( fclass-&gt;get_flags )
412 		flags |= fclass-&gt;get_flags( load );
413 	if( (flags &amp; VIPS_FOREIGN_PARTIAL) &amp;&amp;
414 		(flags &amp; VIPS_FOREIGN_SEQUENTIAL) ) {
415 		g_warning( "%s", 
416 			_( "VIPS_FOREIGN_PARTIAL and VIPS_FOREIGN_SEQUENTIAL "
417 				"both set -- using SEQUENTIAL" ) );
418 		flags ^= VIPS_FOREIGN_PARTIAL;
419 	}
420 	g_object_set( load, "flags", flags, NULL );
421 	sequential = (load-&gt;flags &amp; VIPS_FOREIGN_SEQUENTIAL) &amp;&amp; 
422 		load-&gt;access != VIPS_ACCESS_RANDOM;
423 	if( sequential )
424 		load-&gt;nocache = TRUE;
425 	if( VIPS_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;
426 		build( object ) )
427 		return( -1 );
428 	if( load-&gt;sequential ) 
429 		g_warning( "%s", 
430 			_( "ignoring deprecated \"sequential\" mode -- "
431 				"please use \"access\" instead" ) ); 
432 	g_object_set( object, "out", vips_image_new(), NULL ); 
433 	vips_image_set_string( load-&gt;out, 
434 		VIPS_META_LOADER, class-&gt;nickname );
435 #ifdef DEBUG
436 	printf( "vips_foreign_load_build: triggering -&gt;header()\n" );
437 	if( fclass-&gt;header &amp;&amp;
438 		fclass-&gt;header( load ) ) 
439 		return( -1 );
440 	if( fclass-&gt;load ) {
441 #ifdef DEBUG
442 		printf( "vips_foreign_load_build: delaying read ...\n" );
443 		if( vips_image_pipelinev( load-&gt;out, load-&gt;out-&gt;dhint, NULL ) )
444 			return( -1 );
445 		if( vips_image_generate( load-&gt;out, 
446 			vips_foreign_load_start, 
447 			vips_foreign_load_generate, 
448 			vips_stop_one, 
449 			NULL, load ) ) 
450 			return( -1 );
451 	}
452 	if( sequential ) 
453 		vips_image_set_area( load-&gt;out, 
454 			VIPS_META_SEQUENTIAL, NULL, NULL ); 
455 	return( 0 );
456 }
457 static VipsOperationFlags 
458 vips_foreign_load_operation_get_flags( VipsOperation *operation )
459 {
460 	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( operation );
461 	VipsOperationFlags flags;
462 	flags = VIPS_OPERATION_CLASS( vips_foreign_load_parent_class )-&gt;
463 		get_flags( operation );
464 <a name="0"></a>	if( load-&gt;nocache )
465 		flags |= VIPS_OPERATION_NOCACHE;
466 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( flags );
467 }
468 static void
469 vips_foreign_load_class_init( VipsForeignLoadClass *class )
470 {
471 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
472 	VipsObjectClass *object_class = (VipsObjectClass *) class;
473 	VipsOperationClass *operation_class = (VipsOperationClass *) class;
474 	gobject_class-&gt;dispose = vips_foreign_load_dispose;
475 	gobject_class-&gt;set_property = vips_object_set_property;
476 	gobject_class-&gt;get_property = vips_object_get_property;
477 	object_class-&gt;build = vips_foreign_load_build;
478 	object_class-&gt;summary_class = vips_foreign_load_summary_class;
479 	object_class-&gt;new_from_string = vips_foreign_load_new_from_string;</b></font>
480 	object_class-&gt;nickname = "fileload";
481 	object_class-&gt;description = _( "file loaders" );
482 	operation_class-&gt;get_flags = vips_foreign_load_operation_get_flags;
483 	VIPS_ARG_IMAGE( class, "out", 2, 
484 		_( "Output" ), 
485 		_( "Output image" ),
486 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
487 		G_STRUCT_OFFSET( VipsForeignLoad, out ) );
488 	VIPS_ARG_FLAGS( class, "flags", 106, 
489 		_( "Flags" ), 
490 		_( "Flags for this file" ),
491 		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
492 		G_STRUCT_OFFSET( VipsForeignLoad, flags ),
493 		VIPS_TYPE_FOREIGN_FLAGS, VIPS_FOREIGN_NONE ); 
494 	VIPS_ARG_BOOL( class, "memory", 107, 
495 		_( "Memory" ), 
496 		_( "Force open via memory" ),
497 		VIPS_ARGUMENT_OPTIONAL_INPUT,
498 		G_STRUCT_OFFSET( VipsForeignLoad, memory ),
499 		FALSE );
500 	VIPS_ARG_ENUM( class, "access", 108, 
501 		_( "Access" ), 
502 		_( "Required access pattern for this file" ),
503 		VIPS_ARGUMENT_OPTIONAL_INPUT,
504 		G_STRUCT_OFFSET( VipsForeignLoad, access ),
505 		VIPS_TYPE_ACCESS, VIPS_ACCESS_RANDOM ); 
506 	VIPS_ARG_BOOL( class, "sequential", 109, 
507 		_( "Sequential" ), 
508 		_( "Sequential read only" ),
509 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
510 		G_STRUCT_OFFSET( VipsForeignLoad, sequential ),
511 		FALSE );
512 	VIPS_ARG_BOOL( class, "fail", 110, 
513 		_( "Fail" ), 
514 		_( "Fail on first error" ),
515 		VIPS_ARGUMENT_OPTIONAL_INPUT,
516 		G_STRUCT_OFFSET( VipsForeignLoad, fail ),
517 		FALSE );
518 	VIPS_ARG_BOOL( class, "disc", 111, 
519 		_( "Disc" ), 
520 		_( "Open to disc" ),
521 		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
522 		G_STRUCT_OFFSET( VipsForeignLoad, disc ),
523 		TRUE );
524 }
525 static void
526 vips_foreign_load_init( VipsForeignLoad *load )
527 {
528 	load-&gt;disc = TRUE;
529 	load-&gt;access = VIPS_ACCESS_RANDOM;
530 }
531 void
532 vips_foreign_load_invalidate( VipsImage *image )
533 {
534 	VipsOperation *operation; 
535 #ifdef DEBUG
536 	printf( "vips_foreign_load_invalidate: %p\n", image ); 
537 	if( (operation = g_object_get_qdata( G_OBJECT( image ), 
538 <a name="1"></a>		vips__foreign_load_operation )) ) {
539 		vips_operation_invalidate( operation ); 
540 	}
541 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
542 G_DEFINE_ABSTRACT_TYPE( VipsForeignSave, vips_foreign_save, VIPS_TYPE_FOREIGN );
543 static void
544 vips_foreign_save_dispose( GObject *gobject )
545 {
546 	VipsForeignSave *save = VIPS_FOREIGN_SAVE( gobject );
547 	VIPS_UNREF( save-&gt;ready );
548 	G_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;dispose( gobject );
549 }
550 static void
551 vips_foreign_save_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
552 {
553 	VipsForeignSaveClass *class = VIPS_FOREIGN_SAVE_CLASS( object_class );
554 	VIPS_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;
555 		summary_class( object_class, buf );
556 	vips_buf_appendf( buf, ", %s", 
557 		vips_enum_nick( VIPS_TYPE_SAVEABLE, class-&gt;saveable ) );
558 }
559 static VipsObject *</b></font>
560 vips_foreign_save_new_from_string( const char *string )
561 {
562 	const char *file_op;
563 	GType type;
564 	VipsForeignSave *save;
565 	if( !(file_op = vips_foreign_find_save( string )) )
566 		return( NULL );
567 	type = g_type_from_name( file_op );
568 	g_assert( type ); 
569 	save = VIPS_FOREIGN_SAVE( g_object_new( type, NULL ) );
570 	g_object_set( save,
571 		"filename", string,
572 		NULL );
573 	return( VIPS_OBJECT( save ) );
574 }
575 int
576 vips__foreign_convert_saveable( VipsImage *in, VipsImage **ready,
577 	VipsSaveable saveable, VipsBandFormat *format, VipsCoding *coding,
578 	VipsArrayDouble *background )
579 {
580 	g_object_ref( in );
581 	if( in-&gt;Coding != VIPS_CODING_NONE &amp;&amp;
582 		coding[in-&gt;Coding] ) {
583 		*ready = in;
584 		return( 0 );
585 	}
586 	if( in-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
587 	        saveable == VIPS_SAVEABLE_ANY &amp;&amp;
588 		format[in-&gt;BandFmt] == in-&gt;BandFmt ) {
589 		*ready = in;
590 		return( 0 );
591 	}
592 	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
593 		VipsImage *out;
594 		if( vips_LabQ2sRGB( in, &amp;out, NULL ) ) {
595 			g_object_unref( in );
596 			return( -1 );
597 		}
598 		g_object_unref( in );
599 		in = out;
600 	}
601 	if( in-&gt;Coding == VIPS_CODING_RAD ) {
602 		VipsImage *out;
603 		if( vips_rad2float( in, &amp;out, NULL ) ) {
604 			g_object_unref( in );
605 			return( -1 );
606 		}
607 		g_object_unref( in );
608 		in = out;
609 	}
610 	if( coding[VIPS_CODING_RAD] ) {
611 		if( in-&gt;Type != VIPS_INTERPRETATION_scRGB &amp;&amp;
612 			in-&gt;Type != VIPS_INTERPRETATION_XYZ ) {
613 			VipsImage *out;
614 			if( vips_colourspace( in, &amp;out, 
615 				VIPS_INTERPRETATION_scRGB, NULL ) ) {
616 				g_object_unref( in );
617 				return( -1 );
618 			}
619 			g_object_unref( in );
620 			in = out;
621 		}
622 	}
623 	if( in-&gt;Type == VIPS_INTERPRETATION_CMYK &amp;&amp;
624 		in-&gt;Bands &gt;= 4 &amp;&amp;
625 		(saveable == VIPS_SAVEABLE_RGB ||
626 		 saveable == VIPS_SAVEABLE_RGBA ||
627 		 saveable == VIPS_SAVEABLE_RGBA_ONLY) ) { 
628 		VipsImage *out;
629 		if( vips_icc_import( in, &amp;out, 
630 			"pcs", VIPS_PCS_XYZ,
631 			"embedded", TRUE,
632 			"input_profile", "cmyk",
633 			NULL ) ) {
634 			g_object_unref( in );
635 			return( -1 );
636 		}
637 		g_object_unref( in );
638 		in = out;
639 	}
640 	if( !coding[VIPS_CODING_RAD] &amp;&amp;
641 		in-&gt;Bands &gt;= 3 &amp;&amp;
642 		in-&gt;Type != VIPS_INTERPRETATION_CMYK &amp;&amp;
643 		in-&gt;Type != VIPS_INTERPRETATION_sRGB &amp;&amp;
644 		in-&gt;Type != VIPS_INTERPRETATION_RGB16 &amp;&amp;
645 		in-&gt;Type != VIPS_INTERPRETATION_scRGB &amp;&amp;
646 		vips_colourspace_issupported( in ) &amp;&amp;
647 		(saveable == VIPS_SAVEABLE_RGB ||
648 		 saveable == VIPS_SAVEABLE_RGBA ||
649 		 saveable == VIPS_SAVEABLE_RGBA_ONLY ||
650 		 saveable == VIPS_SAVEABLE_RGB_CMYK) ) { 
651 		VipsImage *out;
652 		VipsInterpretation interpretation;
653 		if( vips_band_format_is8bit( format[in-&gt;BandFmt] ) )
654 			interpretation = VIPS_INTERPRETATION_sRGB;
655 		else
656 			interpretation = VIPS_INTERPRETATION_RGB16;
657 		if( vips_colourspace( in, &amp;out, interpretation, NULL ) ) {
658 			g_object_unref( in );
659 			return( -1 );
660 		}
661 		g_object_unref( in );
662 		in = out;
663 	}
664 	if( !coding[VIPS_CODING_RAD] &amp;&amp;
665 		in-&gt;Bands &lt; 3 &amp;&amp;
666 		vips_colourspace_issupported( in ) &amp;&amp;
667 		saveable == VIPS_SAVEABLE_RGBA_ONLY ) { 
668 		VipsImage *out;
669 		VipsInterpretation interpretation;
670 		if( vips_band_format_is8bit( format[in-&gt;BandFmt] ) )
671 			interpretation = VIPS_INTERPRETATION_sRGB;
672 		else
673 			interpretation = VIPS_INTERPRETATION_RGB16;
674 		if( vips_colourspace( in, &amp;out, interpretation, NULL ) ) {
675 			g_object_unref( in );
676 			return( -1 );
677 		}
678 		g_object_unref( in );
679 		in = out;
680 	}
681 	if( in-&gt;Coding == VIPS_CODING_NONE ) {
682 		if( (in-&gt;Bands == 2 ||
683 			(in-&gt;Bands == 4 &amp;&amp; 
684 			 in-&gt;Type != VIPS_INTERPRETATION_CMYK)) &amp;&amp;
685 			(saveable == VIPS_SAVEABLE_MONO ||
686 			 saveable == VIPS_SAVEABLE_RGB ||
687 			 saveable == VIPS_SAVEABLE_RGB_CMYK) ) {
688 			VipsImage *out;
689 			if( vips_flatten( in, &amp;out, 
690 				"background", background,
691 				NULL ) ) {
692 				g_object_unref( in );
693 				return( -1 );
694 			}
695 			g_object_unref( in );
696 			in = out;
697 		}
698 		else if( in-&gt;Bands &gt; 3 &amp;&amp; 
699 			(saveable == VIPS_SAVEABLE_RGB ||
700 			 (saveable == VIPS_SAVEABLE_RGB_CMYK &amp;&amp;
701 			  in-&gt;Type != VIPS_INTERPRETATION_CMYK)) ) { 
702 			VipsImage *out;
703 			if( vips_extract_band( in, &amp;out, 0, 
704 				"n", 3,
705 				NULL ) ) {
706 				g_object_unref( in );
707 				return( -1 );
708 			}
709 			g_object_unref( in );
710 			in = out;
711 		}
712 		else if( in-&gt;Bands &gt; 4 &amp;&amp; 
713 			((saveable == VIPS_SAVEABLE_RGB_CMYK &amp;&amp;
714 			  in-&gt;Type == VIPS_INTERPRETATION_CMYK) ||
715 			 saveable == VIPS_SAVEABLE_RGBA ||
716 			 saveable == VIPS_SAVEABLE_RGBA_ONLY) ) {
717 			VipsImage *out;
718 			if( vips_extract_band( in, &amp;out, 0, 
719 				"n", 4,
720 				NULL ) ) {
721 				g_object_unref( in );
722 				return( -1 );
723 			}
724 			g_object_unref( in );
725 			in = out;
726 		}
727 		else if( in-&gt;Bands &gt; 1 &amp;&amp; 
728 			saveable == VIPS_SAVEABLE_MONO ) {
729 			VipsImage *out;
730 			if( vips_extract_band( in, &amp;out, 0, NULL ) ) {
731 				g_object_unref( in );
732 				return( -1 );
733 			}
734 			g_object_unref( in );
735 			in = out;
736 		}
737 	}
738 	if( (in-&gt;Type == VIPS_INTERPRETATION_RGB16 ||
739 		 in-&gt;Type == VIPS_INTERPRETATION_GREY16) &amp;&amp;
740 		!vips_band_format_is8bit( in-&gt;BandFmt ) ) {
741 		if( format[VIPS_FORMAT_USHORT] == VIPS_FORMAT_USHORT ) {
742 			VipsImage *out;
743 			if( vips_cast( in, &amp;out, VIPS_FORMAT_USHORT, NULL ) ) {
744 				g_object_unref( in );
745 				return( -1 );
746 			}
747 			g_object_unref( in );
748 			in = out;
749 		}
750 		else {
751 			VipsImage *out;
752 			if( vips_rshift_const1( in, &amp;out, 8, NULL ) ) { 
753 				g_object_unref( in );
754 				return( -1 );
755 			}
756 			g_object_unref( in );
757 			in = out;
758 			if( vips_cast( in, &amp;out, VIPS_FORMAT_UCHAR, NULL ) ) {
759 				g_object_unref( in );
760 				return( -1 );
761 			}
762 			g_object_unref( in );
763 			in = out;
764 		}
765 	}
766 	{
767 		VipsImage *out;
768 		if( vips_cast( in, &amp;out, format[in-&gt;BandFmt], NULL ) ) {
769 			g_object_unref( in );
770 			return( -1 );
771 		}
772 		g_object_unref( in );
773 		in = out;
774 	}
775 	if( coding[VIPS_CODING_NONE] ) {
776 	}
777 	else if( coding[VIPS_CODING_LABQ] ) {
778 		VipsImage *out;
779 		if( vips_Lab2LabQ( in, &amp;out, NULL ) ) {
780 			g_object_unref( in );
781 			return( -1 );
782 		}
783 		g_object_unref( in );
784 		in = out;
785 	}
786 	else if( coding[VIPS_CODING_RAD] ) {
787 		VipsImage *out;
788 		if( vips_float2rad( in, &amp;out, NULL ) ) {
789 			g_object_unref( in );
790 			return( -1 );
791 		}
792 		g_object_unref( in );
793 		in = out;
794 	}
795 	if( vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ) {
796 		const void *data;
797 		size_t length;
798 		if( !vips_image_get_blob( in, VIPS_META_ICC_NAME, 
799 			&amp;data, &amp;length ) &amp;&amp;
800 			!vips_icc_is_compatible_profile( in, data, length ) ) {
801 			VipsImage *out;
802 			if( vips_copy( in, &amp;out, NULL ) ) {
803 				g_object_unref( in );
804 				return( -1 );
805 			}
806 			g_object_unref( in );
807 			in = out;
808 			vips_image_remove( in, VIPS_META_ICC_NAME );
809 		}
810 	}
811 	*ready = in;
812 	return( 0 );
813 }
814 static int
815 vips_foreign_save_build( VipsObject *object )
816 {
817 	VipsForeignSave *save = VIPS_FOREIGN_SAVE( object );
818 	if( save-&gt;in ) {
819 		VipsForeignSaveClass *class = 
820 			VIPS_FOREIGN_SAVE_GET_CLASS( save );
821 		VipsImage *ready;
822 		if( vips__foreign_convert_saveable( save-&gt;in, &amp;ready,
823 			class-&gt;saveable, class-&gt;format_table, class-&gt;coding,
824 			save-&gt;background ) )
825 			return( -1 );
826 		if( save-&gt;page_height ) {
827 			VipsImage *x;
828 			if( vips_copy( ready, &amp;x, NULL ) ) {
829 				VIPS_UNREF( ready );
830 				return( -1 );
831 			}
832 			VIPS_UNREF( ready );
833 			ready = x;
834 			vips_image_set_int( ready, 
835 				VIPS_META_PAGE_HEIGHT, save-&gt;page_height );
836 		}
837 		VIPS_UNREF( save-&gt;ready );
838 		save-&gt;ready = ready;
839 	}
840 	if( VIPS_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;
841 		build( object ) )
842 		return( -1 );
843 	return( 0 );
844 }
845 #define UC VIPS_FORMAT_UCHAR
846 #define C VIPS_FORMAT_CHAR
847 #define US VIPS_FORMAT_USHORT
848 #define S VIPS_FORMAT_SHORT
849 #define UI VIPS_FORMAT_UINT
850 #define I VIPS_FORMAT_INT
851 #define F VIPS_FORMAT_FLOAT
852 #define X VIPS_FORMAT_COMPLEX
853 #define D VIPS_FORMAT_DOUBLE
854 #define DX VIPS_FORMAT_DPCOMPLEX
855 static int vips_foreign_save_format_table[10] = {
856    UC, C,  US, S,  UI, I, F, X, D, DX
857 };
858 static void
859 vips_foreign_save_class_init( VipsForeignSaveClass *class )
860 {
861 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
862 	VipsObjectClass *object_class = (VipsObjectClass *) class;
863 	VipsOperationClass *operation_class = (VipsOperationClass *) class;
864 	int i;
865 	gobject_class-&gt;dispose = vips_foreign_save_dispose;
866 	gobject_class-&gt;set_property = vips_object_set_property;
867 	gobject_class-&gt;get_property = vips_object_get_property;
868 	object_class-&gt;build = vips_foreign_save_build;
869 	object_class-&gt;summary_class = vips_foreign_save_summary_class;
870 	object_class-&gt;new_from_string = vips_foreign_save_new_from_string;
871 	object_class-&gt;nickname = "filesave";
872 	object_class-&gt;description = _( "file savers" );
873 	operation_class-&gt;flags |= VIPS_OPERATION_SEQUENTIAL;
874 	operation_class-&gt;flags |= VIPS_OPERATION_NOCACHE;
875 	for( i = 0; i &lt; VIPS_CODING_LAST; i++ )
876 		class-&gt;coding[i] = FALSE;
877 	class-&gt;coding[VIPS_CODING_NONE] = TRUE;
878 	class-&gt;format_table = vips_foreign_save_format_table; 
879 	VIPS_ARG_IMAGE( class, "in", 0, 
880 		_( "Input" ), 
881 		_( "Image to save" ),
882 		VIPS_ARGUMENT_REQUIRED_INPUT,
883 		G_STRUCT_OFFSET( VipsForeignSave, in ) );
884 	VIPS_ARG_BOOL( class, "strip", 100,
885 		_( "Strip" ),
886 		_( "Strip all metadata from image" ),
887 		VIPS_ARGUMENT_OPTIONAL_INPUT,
888 		G_STRUCT_OFFSET( VipsForeignSave, strip ),
889 		FALSE );
890 	VIPS_ARG_BOXED( class, "background", 101, 
891 		_( "Background" ), 
892 		_( "Background value" ),
893 		VIPS_ARGUMENT_OPTIONAL_INPUT,
894 		G_STRUCT_OFFSET( VipsForeignSave, background ),
895 		VIPS_TYPE_ARRAY_DOUBLE );
896 	VIPS_ARG_INT( class, "page_height", 102, 
897 		_( "Page height" ), 
898 		_( "Set page height for multipage save" ),
899 		VIPS_ARGUMENT_OPTIONAL_INPUT,
900 		G_STRUCT_OFFSET( VipsForeignSave, page_height ),
901 		0, VIPS_MAX_COORD, 0 ); 
902 }
903 static void
904 vips_foreign_save_init( VipsForeignSave *save )
905 {
906 	save-&gt;background = vips_array_double_newv( 1, 0.0 );
907 }
908 static void *
909 vips_foreign_find_save_sub( VipsForeignSaveClass *save_class, 
910 	const char *filename, void *b )
911 {
912 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
913 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
914 	const char **p;
915 	if( !class-&gt;suffs )
916 		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
917 	if( vips_ispostfix( object_class-&gt;nickname, "_buffer" ) ||
918 		vips_ispostfix( object_class-&gt;nickname, "_target" ) )
919 		return( NULL );
920 	for( p = class-&gt;suffs; *p; p++ ) 
921 		if( vips_iscasepostfix( filename, *p ) ) 
922 			return( save_class );
923 	return( NULL );
924 }
925 const char *
926 vips_foreign_find_save( const char *name )
927 {
928 	char filename[VIPS_PATH_MAX];
929 	char option_string[VIPS_PATH_MAX];
930 	VipsForeignSaveClass *save_class;
931 	vips__filename_split8( name, filename, option_string );
932 	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
933 		"VipsForeignSave",
934 		(VipsSListMap2Fn) vips_foreign_find_save_sub, 
935 		(void *) filename, NULL )) ) {
936 		vips_error( "VipsForeignSave",
937 			_( "\"%s\" is not a known file format" ), name );
938 		return( NULL );
939 	}
940 	return( G_OBJECT_CLASS_NAME( save_class ) );
941 }
942 static void *
943 vips_foreign_get_suffixes_count_cb( VipsForeignSaveClass *save_class, 
944 	void *a, void *b )
945 {
946 	VipsForeignClass *foreign_class = VIPS_FOREIGN_CLASS( save_class );
947 	int *n_fields = (int *) a;
948 	int i;
949 	if( foreign_class-&gt;suffs )
950 		for( i = 0; foreign_class-&gt;suffs[i]; i++ )
951 			*n_fields += 1;
952 	return( NULL ); 
953 }
954 static void *
955 vips_foreign_get_suffixes_add_cb( VipsForeignSaveClass *save_class, 
956 	void *a, void *b )
957 {
958 	VipsForeignClass *foreign_class = VIPS_FOREIGN_CLASS( save_class );
959 	gchar ***p = (gchar ***) a;
960 	int i;
961 	if( foreign_class-&gt;suffs )
962 		for( i = 0; foreign_class-&gt;suffs[i]; i++ ) {
963 			**p = g_strdup( foreign_class-&gt;suffs[i] ); 
964 			*p += 1;
965 		}
966 	return( NULL ); 
967 }
968 gchar ** 
969 vips_foreign_get_suffixes( void )
970 {
971 	int n_suffs;
972 	gchar **suffs;
973 	gchar **p;
974 	n_suffs = 0;
975 	(void) vips_foreign_map( 
976 		"VipsForeignSave",
977 		(VipsSListMap2Fn) vips_foreign_get_suffixes_count_cb, 
978 		&amp;n_suffs, NULL );
979 	suffs = g_new0( gchar *, n_suffs + 1 ); 
980 	p = suffs;
981 	(void) vips_foreign_map( 
982 		"VipsForeignSave",
983 		(VipsSListMap2Fn) vips_foreign_get_suffixes_add_cb, 
984 		&amp;p, NULL );
985 	return( suffs ); 
986 }
987 int
988 vips_foreign_save( VipsImage *in, const char *name, ... )
989 {
990 	char filename[VIPS_PATH_MAX];
991 	char option_string[VIPS_PATH_MAX];
992 	const char *operation_name;
993 	va_list ap;
994 	int result;
995 	vips__filename_split8( name, filename, option_string );
996 	if( !(operation_name = vips_foreign_find_save( filename )) )
997 		return( -1 );
998 	va_start( ap, name );
999 	result = vips_call_split_option_string( operation_name, option_string, 
1000 		ap, in, filename );
1001 	va_end( ap );
1002 	return( result );
1003 }
1004 static void *
1005 vips_foreign_find_save_target_sub( VipsForeignSaveClass *save_class, 
1006 	const char *suffix, void *b )
1007 {
1008 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
1009 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
1010 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
1011 		!class-&gt;suffs )
1012 		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
1013 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
1014 		class-&gt;suffs &amp;&amp;
1015 		vips_ispostfix( object_class-&gt;nickname, "_target" ) &amp;&amp;
1016 		vips_filename_suffix_match( suffix, class-&gt;suffs ) )
1017 		return( save_class );
1018 	return( NULL );
1019 }
1020 const char *
1021 vips_foreign_find_save_target( const char *name )
1022 {
1023 	char suffix[VIPS_PATH_MAX];
1024 	char option_string[VIPS_PATH_MAX];
1025 	VipsForeignSaveClass *save_class;
1026 	vips__filename_split8( name, suffix, option_string );
1027 	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
1028 		"VipsForeignSave",
1029 		(VipsSListMap2Fn) vips_foreign_find_save_target_sub, 
1030 		(void *) suffix, NULL )) ) {
1031 		vips_error( "VipsForeignSave",
1032 			_( "\"%s\" is not a known target format" ), name );
1033 		return( NULL );
1034 	}
1035 	return( G_OBJECT_CLASS_NAME( save_class ) );
1036 }
1037 static void *
1038 vips_foreign_find_save_buffer_sub( VipsForeignSaveClass *save_class, 
1039 	const char *suffix, void *b )
1040 {
1041 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
1042 	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
1043 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
1044 		!class-&gt;suffs )
1045 		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
1046 	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
1047 		class-&gt;suffs &amp;&amp;
1048 		vips_ispostfix( object_class-&gt;nickname, "_buffer" ) &amp;&amp;
1049 		vips_filename_suffix_match( suffix, class-&gt;suffs ) )
1050 		return( save_class );
1051 	return( NULL );
1052 }
1053 const char *
1054 vips_foreign_find_save_buffer( const char *name )
1055 {
1056 	char suffix[VIPS_PATH_MAX];
1057 	char option_string[VIPS_PATH_MAX];
1058 	VipsForeignSaveClass *save_class;
1059 	vips__filename_split8( name, suffix, option_string );
1060 	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
1061 		"VipsForeignSave",
1062 		(VipsSListMap2Fn) vips_foreign_find_save_buffer_sub, 
1063 		(void *) suffix, NULL )) ) {
1064 		vips_error( "VipsForeignSave",
1065 			_( "\"%s\" is not a known buffer format" ), name );
1066 		return( NULL );
1067 	}
1068 	return( G_OBJECT_CLASS_NAME( save_class ) );
1069 }
1070 int
1071 vips_heifload( const char *filename, VipsImage **out, ... )
1072 {
1073 	va_list ap;
1074 	int result;
1075 	va_start( ap, out );
1076 	result = vips_call_split( "heifload", ap, filename, out );
1077 	va_end( ap );
1078 	return( result );
1079 }
1080 int
1081 vips_heifload_buffer( void *buf, size_t len, VipsImage **out, ... )
1082 {
1083 	va_list ap;
1084 	VipsBlob *blob;
1085 	int result;
1086 	blob = vips_blob_new( NULL, buf, len );
1087 	va_start( ap, out );
1088 	result = vips_call_split( "heifload_buffer", ap, blob, out );
1089 	va_end( ap );
1090 	vips_area_unref( VIPS_AREA( blob ) );
1091 	return( result );
1092 }
1093 int
1094 vips_heifload_source( VipsSource *source, VipsImage **out, ... )
1095 {
1096 	va_list ap;
1097 	int result;
1098 	va_start( ap, out );
1099 	result = vips_call_split( "heifload_source", ap, source, out );
1100 	va_end( ap );
1101 	return( result );
1102 }
1103 int
1104 vips_heifsave( VipsImage *in, const char *filename, ... )
1105 {
1106 	va_list ap;
1107 	int result;
1108 	va_start( ap, filename );
1109 	result = vips_call_split( "heifsave", ap, in, filename );
1110 	va_end( ap );
1111 	return( result );
1112 }
1113 int
1114 vips_heifsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
1115 {
1116 	va_list ap;
1117 	VipsArea *area;
1118 	int result;
1119 	area = NULL; 
1120 	va_start( ap, len );
1121 	result = vips_call_split( "heifsave_buffer", ap, in, &amp;area );
1122 	va_end( ap );
1123 	if( !result &amp;&amp;
1124 		area ) { 
1125 		if( buf ) {
1126 			*buf = area-&gt;data;
1127 			area-&gt;free_fn = NULL;
1128 		}
1129 		if( len ) 
1130 			*len = area-&gt;length;
1131 		vips_area_unref( area );
1132 	}
1133 	return( result );
1134 }
1135 int
1136 vips_heifsave_target( VipsImage *in, VipsTarget *target, ... )
1137 {
1138 	va_list ap;
1139 	int result;
1140 	va_start( ap, target );
1141 	result = vips_call_split( "heifsave_target", ap, in, target );
1142 	va_end( ap );
1143 	return( result );
1144 }
1145 int
1146 vips_jxlload( const char *filename, VipsImage **out, ... )
1147 {
1148 	va_list ap;
1149 	int result;
1150 	va_start( ap, out );
1151 	result = vips_call_split( "jxlload", ap, filename, out );
1152 	va_end( ap );
1153 	return( result );
1154 }
1155 int
1156 vips_jxlload_buffer( void *buf, size_t len, VipsImage **out, ... )
1157 {
1158 	va_list ap;
1159 	VipsBlob *blob;
1160 	int result;
1161 	blob = vips_blob_new( NULL, buf, len );
1162 	va_start( ap, out );
1163 	result = vips_call_split( "jxlload_buffer", ap, blob, out );
1164 	va_end( ap );
1165 	vips_area_unref( VIPS_AREA( blob ) );
1166 	return( result );
1167 }
1168 int
1169 vips_jxlload_source( VipsSource *source, VipsImage **out, ... )
1170 {
1171 	va_list ap;
1172 	int result;
1173 	va_start( ap, out );
1174 	result = vips_call_split( "jxlload_source", ap, source, out );
1175 	va_end( ap );
1176 	return( result );
1177 }
1178 int
1179 vips_jxlsave( VipsImage *in, const char *filename, ... )
1180 {
1181 	va_list ap;
1182 	int result;
1183 	va_start( ap, filename );
1184 	result = vips_call_split( "jxlsave", ap, in, filename );
1185 	va_end( ap );
1186 	return( result );
1187 }
1188 int
1189 vips_jxlsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
1190 {
1191 	va_list ap;
1192 	VipsArea *area;
1193 	int result;
1194 	area = NULL; 
1195 	va_start( ap, len );
1196 	result = vips_call_split( "jxlsave_buffer", ap, in, &amp;area );
1197 	va_end( ap );
1198 	if( !result &amp;&amp;
1199 		area ) { 
1200 		if( buf ) {
1201 			*buf = area-&gt;data;
1202 			area-&gt;free_fn = NULL;
1203 		}
1204 		if( len ) 
1205 			*len = area-&gt;length;
1206 		vips_area_unref( area );
1207 	}
1208 	return( result );
1209 }
1210 int
1211 vips_jxlsave_target( VipsImage *in, VipsTarget *target, ... )
1212 {
1213 	va_list ap;
1214 	int result;
1215 	va_start( ap, target );
1216 	result = vips_call_split( "jxlsave_target", ap, in, target );
1217 	va_end( ap );
1218 	return( result );
1219 }
1220 int
1221 vips_pdfload( const char *filename, VipsImage **out, ... )
1222 {
1223 	va_list ap;
1224 	int result;
1225 	va_start( ap, out );
1226 	result = vips_call_split( "pdfload", ap, filename, out );
1227 	va_end( ap );
1228 	return( result );
1229 }
1230 int
1231 vips_pdfload_buffer( void *buf, size_t len, VipsImage **out, ... )
1232 {
1233 	va_list ap;
1234 	VipsBlob *blob;
1235 	int result;
1236 	blob = vips_blob_new( NULL, buf, len );
1237 	va_start( ap, out );
1238 	result = vips_call_split( "pdfload_buffer", ap, blob, out );
1239 	va_end( ap );
1240 	vips_area_unref( VIPS_AREA( blob ) );
1241 	return( result );
1242 }
1243 int
1244 vips_pdfload_source( VipsSource *source, VipsImage **out, ... )
1245 {
1246 	va_list ap;
1247 	int result;
1248 	va_start( ap, out );
1249 	result = vips_call_split( "pdfload_source", ap, source, out );
1250 	va_end( ap );
1251 	return( result );
1252 }
1253 int
1254 vips_openslideload( const char *filename, VipsImage **out, ... )
1255 {
1256 	va_list ap;
1257 	int result;
1258 	va_start( ap, out );
1259 	result = vips_call_split( "openslideload", ap, filename, out );
1260 	va_end( ap );
1261 	return( result );
1262 }
1263 int
1264 vips_openslideload_source( VipsSource *source, VipsImage **out, ... )
1265 {
1266 	va_list ap;
1267 	int result;
1268 	va_start( ap, out );
1269 	result = vips_call_split( "openslideload_source", ap, source, out );
1270 	va_end( ap );
1271 	return( result );
1272 }
1273 void
1274 vips_foreign_operation_init( void )
1275 {
1276 	extern GType vips_foreign_load_rad_file_get_type( void ); 
1277 	extern GType vips_foreign_load_rad_buffer_get_type( void ); 
1278 	extern GType vips_foreign_load_rad_source_get_type( void ); 
1279 	extern GType vips_foreign_save_rad_file_get_type( void ); 
1280 	extern GType vips_foreign_save_rad_buffer_get_type( void ); 
1281 	extern GType vips_foreign_save_rad_target_get_type( void ); 
1282 	extern GType vips_foreign_load_mat_get_type( void ); 
1283 	extern GType vips_foreign_load_ppm_file_get_type( void ); 
1284 	extern GType vips_foreign_load_ppm_source_get_type( void ); 
1285 	extern GType vips_foreign_save_ppm_file_get_type( void ); 
1286 	extern GType vips_foreign_save_ppm_target_get_type( void ); 
1287 	extern GType vips_foreign_load_png_file_get_type( void ); 
1288 	extern GType vips_foreign_load_png_buffer_get_type( void ); 
1289 	extern GType vips_foreign_load_png_source_get_type( void ); 
1290 	extern GType vips_foreign_save_png_file_get_type( void ); 
1291 	extern GType vips_foreign_save_png_buffer_get_type( void ); 
1292 	extern GType vips_foreign_save_png_target_get_type( void ); 
1293 	extern GType vips_foreign_load_csv_file_get_type( void ); 
1294 	extern GType vips_foreign_load_csv_source_get_type( void ); 
1295 	extern GType vips_foreign_save_csv_file_get_type( void ); 
1296 	extern GType vips_foreign_save_csv_target_get_type( void ); 
1297 	extern GType vips_foreign_load_matrix_file_get_type( void ); 
1298 	extern GType vips_foreign_load_matrix_source_get_type( void ); 
1299 	extern GType vips_foreign_save_matrix_file_get_type( void ); 
1300 	extern GType vips_foreign_save_matrix_target_get_type( void ); 
1301 	extern GType vips_foreign_print_matrix_get_type( void ); 
1302 	extern GType vips_foreign_load_fits_file_get_type( void ); 
1303 	extern GType vips_foreign_load_fits_source_get_type( void ); 
1304 	extern GType vips_foreign_save_fits_get_type( void ); 
1305 	extern GType vips_foreign_load_analyze_get_type( void ); 
1306 	extern GType vips_foreign_load_openexr_get_type( void ); 
1307 	extern GType vips_foreign_load_openslide_file_get_type( void ); 
1308 	extern GType vips_foreign_load_openslide_source_get_type( void ); 
1309 	extern GType vips_foreign_load_vips_file_get_type( void ); 
1310 	extern GType vips_foreign_load_vips_source_get_type( void ); 
1311 	extern GType vips_foreign_save_vips_file_get_type( void ); 
1312 	extern GType vips_foreign_save_vips_target_get_type( void ); 
1313 	extern GType vips_foreign_load_jpeg_file_get_type( void ); 
1314 	extern GType vips_foreign_load_jpeg_buffer_get_type( void ); 
1315 	extern GType vips_foreign_load_jpeg_source_get_type( void ); 
1316 	extern GType vips_foreign_save_jpeg_file_get_type( void ); 
1317 	extern GType vips_foreign_save_jpeg_buffer_get_type( void ); 
1318 	extern GType vips_foreign_save_jpeg_target_get_type( void ); 
1319 	extern GType vips_foreign_save_jpeg_mime_get_type( void ); 
1320 	extern GType vips_foreign_load_tiff_file_get_type( void ); 
1321 	extern GType vips_foreign_load_tiff_buffer_get_type( void ); 
1322 	extern GType vips_foreign_load_tiff_source_get_type( void ); 
1323 	extern GType vips_foreign_save_tiff_file_get_type( void ); 
1324 	extern GType vips_foreign_save_tiff_buffer_get_type( void ); 
1325 	extern GType vips_foreign_load_raw_get_type( void ); 
1326 	extern GType vips_foreign_save_raw_get_type( void ); 
1327 	extern GType vips_foreign_save_raw_fd_get_type( void ); 
1328 	extern GType vips_foreign_load_magick_file_get_type( void ); 
1329 	extern GType vips_foreign_load_magick_buffer_get_type( void ); 
1330 	extern GType vips_foreign_load_magick7_file_get_type( void ); 
1331 	extern GType vips_foreign_load_magick7_buffer_get_type( void ); 
1332 	extern GType vips_foreign_save_magick_file_get_type( void );
1333 	extern GType vips_foreign_save_magick_buffer_get_type( void );
1334 	extern GType vips_foreign_save_dz_file_get_type( void ); 
1335 	extern GType vips_foreign_save_dz_buffer_get_type( void ); 
1336 	extern GType vips_foreign_load_webp_file_get_type( void ); 
1337 	extern GType vips_foreign_load_webp_buffer_get_type( void ); 
1338 	extern GType vips_foreign_load_webp_source_get_type( void ); 
1339 	extern GType vips_foreign_save_webp_file_get_type( void ); 
1340 	extern GType vips_foreign_save_webp_buffer_get_type( void ); 
1341 	extern GType vips_foreign_save_webp_target_get_type( void ); 
1342 	extern GType vips_foreign_load_pdf_file_get_type( void ); 
1343 	extern GType vips_foreign_load_pdf_buffer_get_type( void ); 
1344 	extern GType vips_foreign_load_pdf_source_get_type( void ); 
1345 	extern GType vips_foreign_load_svg_file_get_type( void ); 
1346 	extern GType vips_foreign_load_svg_buffer_get_type( void ); 
1347 	extern GType vips_foreign_load_svg_source_get_type( void ); 
1348 	extern GType vips_foreign_load_jp2k_file_get_type( void ); 
1349 	extern GType vips_foreign_load_jp2k_buffer_get_type( void ); 
1350 	extern GType vips_foreign_load_jp2k_source_get_type( void ); 
1351 	extern GType vips_foreign_save_jp2k_file_get_type( void ); 
1352 	extern GType vips_foreign_save_jp2k_buffer_get_type( void ); 
1353 	extern GType vips_foreign_save_jp2k_target_get_type( void ); 
1354 	extern GType vips_foreign_load_jxl_file_get_type( void ); 
1355 	extern GType vips_foreign_load_jxl_buffer_get_type( void ); 
1356 	extern GType vips_foreign_load_jxl_source_get_type( void ); 
1357 	extern GType vips_foreign_save_jxl_file_get_type( void ); 
1358 	extern GType vips_foreign_save_jxl_buffer_get_type( void ); 
1359 	extern GType vips_foreign_save_jxl_target_get_type( void ); 
1360 	extern GType vips_foreign_load_heif_file_get_type( void ); 
1361 	extern GType vips_foreign_load_heif_buffer_get_type( void ); 
1362 	extern GType vips_foreign_load_heif_source_get_type( void ); 
1363 	extern GType vips_foreign_save_heif_file_get_type( void ); 
1364 	extern GType vips_foreign_save_heif_buffer_get_type( void ); 
1365 	extern GType vips_foreign_save_heif_target_get_type( void ); 
1366 	extern GType vips_foreign_load_nifti_file_get_type( void ); 
1367 	extern GType vips_foreign_load_nifti_source_get_type( void ); 
1368 	extern GType vips_foreign_save_nifti_get_type( void ); 
1369 	extern GType vips_foreign_load_nsgif_file_get_type( void ); 
1370 	extern GType vips_foreign_load_nsgif_buffer_get_type( void ); 
1371 	extern GType vips_foreign_load_nsgif_source_get_type( void ); 
1372 	extern GType vips_foreign_save_cgif_file_get_type( void );
1373 	extern GType vips_foreign_save_cgif_buffer_get_type( void );
1374 	extern GType vips_foreign_save_cgif_target_get_type( void );
1375 	vips_foreign_load_csv_file_get_type(); 
1376 	vips_foreign_load_csv_source_get_type(); 
1377 	vips_foreign_save_csv_file_get_type(); 
1378 	vips_foreign_save_csv_target_get_type(); 
1379 	vips_foreign_load_matrix_file_get_type(); 
1380 	vips_foreign_load_matrix_source_get_type(); 
1381 	vips_foreign_save_matrix_file_get_type(); 
1382 	vips_foreign_save_matrix_target_get_type(); 
1383 	vips_foreign_print_matrix_get_type(); 
1384 	vips_foreign_load_raw_get_type(); 
1385 	vips_foreign_save_raw_get_type(); 
1386 	vips_foreign_save_raw_fd_get_type(); 
1387 	vips_foreign_load_vips_file_get_type(); 
1388 	vips_foreign_load_vips_source_get_type(); 
1389 	vips_foreign_save_vips_file_get_type(); 
1390 	vips_foreign_save_vips_target_get_type(); 
1391 #ifdef HAVE_ANALYZE
1392 	vips_foreign_load_analyze_get_type(); 
1393 #ifdef HAVE_PPM
1394 	vips_foreign_load_ppm_file_get_type(); 
1395 	vips_foreign_load_ppm_source_get_type(); 
1396 	vips_foreign_save_ppm_file_get_type(); 
1397 	vips_foreign_save_ppm_target_get_type(); 
1398 #ifdef HAVE_RADIANCE
1399 	vips_foreign_load_rad_file_get_type(); 
1400 	vips_foreign_load_rad_buffer_get_type(); 
1401 	vips_foreign_load_rad_source_get_type(); 
1402 	vips_foreign_save_rad_file_get_type(); 
1403 	vips_foreign_save_rad_buffer_get_type(); 
1404 	vips_foreign_save_rad_target_get_type(); 
1405 #if defined(HAVE_POPPLER) &amp;&amp; !defined(POPPLER_MODULE)
1406 	vips_foreign_load_pdf_file_get_type(); 
1407 	vips_foreign_load_pdf_buffer_get_type(); 
1408 	vips_foreign_load_pdf_source_get_type(); 
1409 #ifdef HAVE_PDFIUM
1410 	vips_foreign_load_pdf_file_get_type(); 
1411 	vips_foreign_load_pdf_buffer_get_type(); 
1412 	vips_foreign_load_pdf_source_get_type(); 
1413 #ifdef HAVE_RSVG
1414 	vips_foreign_load_svg_file_get_type(); 
1415 	vips_foreign_load_svg_buffer_get_type(); 
1416 	vips_foreign_load_svg_source_get_type(); 
1417 #if defined(HAVE_LIBJXL) &amp;&amp; !defined(LIBJXL_MODULE)
1418 	vips_foreign_load_jxl_file_get_type(); 
1419 	vips_foreign_load_jxl_buffer_get_type(); 
1420 	vips_foreign_load_jxl_source_get_type(); 
1421 	vips_foreign_save_jxl_file_get_type(); 
1422 	vips_foreign_save_jxl_buffer_get_type(); 
1423 	vips_foreign_save_jxl_target_get_type(); 
1424 #ifdef HAVE_LIBOPENJP2
1425 	vips_foreign_load_jp2k_file_get_type(); 
1426 	vips_foreign_load_jp2k_buffer_get_type(); 
1427 	vips_foreign_load_jp2k_source_get_type(); 
1428 	vips_foreign_save_jp2k_file_get_type(); 
1429 	vips_foreign_save_jp2k_buffer_get_type(); 
1430 	vips_foreign_save_jp2k_target_get_type(); 
1431 #ifdef HAVE_NSGIF
1432 	vips_foreign_load_nsgif_file_get_type();
1433 	vips_foreign_load_nsgif_buffer_get_type(); 
1434 	vips_foreign_load_nsgif_source_get_type(); 
1435 #ifdef HAVE_CGIF
1436 	vips_foreign_save_cgif_file_get_type();
1437 	vips_foreign_save_cgif_buffer_get_type();
1438 	vips_foreign_save_cgif_target_get_type();
1439 #ifdef HAVE_GSF
1440 	vips_foreign_save_dz_file_get_type(); 
1441 	vips_foreign_save_dz_buffer_get_type(); 
1442 #ifdef HAVE_PNG
1443 	vips_foreign_load_png_file_get_type(); 
1444 	vips_foreign_load_png_buffer_get_type(); 
1445 	vips_foreign_load_png_source_get_type(); 
1446 	vips_foreign_save_png_file_get_type(); 
1447 	vips_foreign_save_png_buffer_get_type(); 
1448 	vips_foreign_save_png_target_get_type(); 
1449 #ifdef HAVE_SPNG
1450 	vips_foreign_load_png_file_get_type(); 
1451 	vips_foreign_load_png_buffer_get_type(); 
1452 	vips_foreign_load_png_source_get_type(); 
1453 #ifdef HAVE_MATIO
1454 	vips_foreign_load_mat_get_type(); 
1455 #ifdef HAVE_JPEG
1456 	vips_foreign_load_jpeg_file_get_type(); 
1457 	vips_foreign_load_jpeg_buffer_get_type(); 
1458 	vips_foreign_load_jpeg_source_get_type(); 
1459 	vips_foreign_save_jpeg_file_get_type(); 
1460 	vips_foreign_save_jpeg_buffer_get_type(); 
1461 	vips_foreign_save_jpeg_target_get_type(); 
1462 	vips_foreign_save_jpeg_mime_get_type(); 
1463 #ifdef HAVE_LIBWEBP
1464 	vips_foreign_load_webp_file_get_type(); 
1465 	vips_foreign_load_webp_buffer_get_type(); 
1466 	vips_foreign_load_webp_source_get_type(); 
1467 	vips_foreign_save_webp_file_get_type(); 
1468 	vips_foreign_save_webp_buffer_get_type(); 
1469 	vips_foreign_save_webp_target_get_type(); 
1470 #ifdef HAVE_TIFF
1471 	vips_foreign_load_tiff_file_get_type(); 
1472 	vips_foreign_load_tiff_buffer_get_type(); 
1473 	vips_foreign_load_tiff_source_get_type(); 
1474 	vips_foreign_save_tiff_file_get_type(); 
1475 	vips_foreign_save_tiff_buffer_get_type(); 
1476 #if defined(HAVE_OPENSLIDE) &amp;&amp; !defined(OPENSLIDE_MODULE)
1477 	vips_foreign_load_openslide_file_get_type(); 
1478 	vips_foreign_load_openslide_source_get_type(); 
1479 #if defined(ENABLE_MAGICKLOAD) &amp;&amp; !defined(MAGICK_MODULE)
1480 #ifdef HAVE_MAGICK6
1481 	vips_foreign_load_magick_file_get_type();
1482 	vips_foreign_load_magick_buffer_get_type();
1483 #ifdef HAVE_MAGICK7
1484 	vips_foreign_load_magick7_file_get_type();
1485 	vips_foreign_load_magick7_buffer_get_type();
1486 #if defined(ENABLE_MAGICKSAVE) &amp;&amp; !defined(MAGICK_MODULE)
1487 	vips_foreign_save_magick_file_get_type();
1488 	vips_foreign_save_magick_buffer_get_type();
1489 #ifdef HAVE_CFITSIO
1490 	vips_foreign_load_fits_file_get_type(); 
1491 	vips_foreign_load_fits_source_get_type(); 
1492 	vips_foreign_save_fits_get_type(); 
1493 #ifdef HAVE_OPENEXR
1494 	vips_foreign_load_openexr_get_type(); 
1495 #ifdef HAVE_NIFTI
1496 	vips_foreign_load_nifti_file_get_type(); 
1497 	vips_foreign_load_nifti_source_get_type(); 
1498 	vips_foreign_save_nifti_get_type(); 
1499 #if defined(HAVE_HEIF_DECODER) &amp;&amp; !defined(HEIF_MODULE)
1500 	vips_foreign_load_heif_file_get_type(); 
1501 	vips_foreign_load_heif_buffer_get_type(); 
1502 	vips_foreign_load_heif_source_get_type(); 
1503 #if defined(HAVE_HEIF_ENCODER) &amp;&amp; !defined(HEIF_MODULE)
1504 	vips_foreign_save_heif_file_get_type(); 
1505 	vips_foreign_save_heif_buffer_get_type(); 
1506 	vips_foreign_save_heif_target_get_type(); 
1507 	vips__foreign_load_operation = 
1508 		g_quark_from_static_string( "vips-foreign-load-operation" ); 
1509 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
