<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for magick7load.c &amp; foreign.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for magick7load.c &amp; foreign.c
      </h3>
<h1 align="center">
        3.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>magick7load.c (6.6115704%)<th>foreign.c (2.3774145%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(807-825)<td><a href="#" name="0">(1138-1154)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(390-408)<td><a href="#" name="1">(1247-1276)</a><td align="center"><font color="#c60000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>magick7load.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/buf.h&gt;
#include &lt;vips/internal.h&gt;
#ifdef ENABLE_MAGICKLOAD
#ifdef HAVE_MAGICK7
#include &lt;MagickCore/MagickCore.h&gt;
#include "magick.h"
typedef struct _VipsForeignLoadMagick7 {
	VipsForeignLoad parent_object;
	gboolean all_frames;
	char *density;				int page;				int n;				
	Image *image;
	ImageInfo *image_info;
	ExceptionInfo *exception;
	int n_pages;
	int n_frames;				Image **frames;				CacheView **cache_view; 		int frame_height;	
	GMutex *lock;
} VipsForeignLoadMagick7;
typedef VipsForeignLoadClass VipsForeignLoadMagick7Class;
G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadMagick7, vips_foreign_load_magick7, 
	VIPS_TYPE_FOREIGN_LOAD );
#ifdef DEBUG
static void
vips_magick7_print_traits( Image *image ) 
{
	static const int trait_bits[] = {
		CopyPixelTrait,
		UpdatePixelTrait,
		BlendPixelTrait
	};
	static const char *trait_names[] = {
		"CopyPixelTrait",
		"UpdatePixelTrait",
		"BlendPixelTrait"
	};
	int b; 
	int i; 
	printf( "vips_magick7_print_traits: channel traits:\n" ); 
	for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { 
		PixelChannel channel = 
			GetPixelChannelChannel( image, b ); 
		PixelTrait traits = 
			GetPixelChannelTraits( image, channel );
		printf( "\t%d) ", b ); 
		for( i = 0; i &lt; VIPS_NUMBER( trait_bits ); i++ )
			if( traits &amp; trait_bits[i] )
				printf( "%s ", trait_names[i] ); 
		if( traits == 0 )
			printf( "undefined" ); 
		printf( "\n" ); 
	} 
}
static void
vips_magick7_print_channel_names( Image *image )
{
	static const int pixel_channels[] = {
		UndefinedPixelChannel, 
		RedPixelChannel, 
		CyanPixelChannel, 
		GrayPixelChannel, 
		LPixelChannel, 
		LabelPixelChannel, 
		YPixelChannel, 
		aPixelChannel, 
		GreenPixelChannel, 
		MagentaPixelChannel, 
		CbPixelChannel, 
		bPixelChannel, 
		BluePixelChannel, 
		YellowPixelChannel, 
		CrPixelChannel, 
		BlackPixelChannel, 
		AlphaPixelChannel, 
		IndexPixelChannel, 
		ReadMaskPixelChannel, 
		WriteMaskPixelChannel, 
		MetaPixelChannel, 
		IntensityPixelChannel, 
		CompositePixelChannel, 
		SyncPixelChannel
	};
	static const char *pixel_channel_names[] = {
		"UndefinedPixelChannel", 
		"RedPixelChannel", 
		"CyanPixelChannel", 
		"GrayPixelChannel", 
		"LPixelChannel", 
		"LabelPixelChannel", 
		"YPixelChannel", 
		"aPixelChannel", 
		"GreenPixelChannel", 
		"MagentaPixelChannel", 
		"CbPixelChannel", 
		"bPixelChannel", 
		"BluePixelChannel", 
		"YellowPixelChannel", 
		"CrPixelChannel", 
		"BlackPixelChannel", 
		"AlphaPixelChannel", 
		"IndexPixelChannel", 
		"ReadMaskPixelChannel", 
		"WriteMaskPixelChannel", 
		"MetaPixelChannel", 
		"IntensityPixelChannel", 
		"CompositePixelChannel", 
		"SyncPixelChannel", 
	};
	int b; 
	int i; 
	printf( "vips_magick7_print_channel_names: channel names:\n" ); 
	for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { 
		PixelChannel channel = 
			GetPixelChannelChannel( image, b ); 
		printf( "\t%d) ", b ); 
		for( i = 0; i &lt; VIPS_NUMBER( pixel_channels ); i++ )
			if( channel == pixel_channels[i] ) 
				printf( "%s ", pixel_channel_names[i] );
		printf( "\n" ); 
	} 
}
static void
vips_magick7_print_image_type( Image *image )
{
	static const int image_types[] = {
		UndefinedType,
		BilevelType,
		GrayscaleType,
		GrayscaleAlphaType, 
		PaletteType,
		PaletteAlphaType,
		TrueColorType,
		TrueColorAlphaType,
		ColorSeparationType,
		ColorSeparationAlphaType,
		OptimizeType,
		PaletteBilevelAlphaType
	};
	static const char *image_type_names[] = {
		"UndefinedType",
		"BilevelType",
		"GrayscaleType",
		"GrayscaleAlphaType", 
		"PaletteType",
		"PaletteAlphaType",
		"TrueColorType",
		"TrueColorAlphaType",
		"ColorSeparationType",
		"ColorSeparationAlphaType",
		"OptimizeType",
		"PaletteBilevelAlphaType"
	};
	int i;
	for( i = 0; i &lt; VIPS_NUMBER( image_types ); i++ ) 
		if( GetImageType( image ) == image_types[i] ) {
			printf( "\t%s\n", image_type_names[i] );
			break;
		}
	if( i == VIPS_NUMBER( image_types ) )
		printf( "\tunknown GetImageType()\n" ); 
}
static VipsForeignFlags
vips_foreign_load_magick7_get_flags_filename( const char *filename )
{
	return( VIPS_FOREIGN_PARTIAL );
}
static VipsForeignFlags
vips_foreign_load_magick7_get_flags( VipsForeignLoad *load )
{
	return( VIPS_FOREIGN_PARTIAL );
}
static void
vips_foreign_load_magick7_dispose( GObject *gobject )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) gobject;
	int i;
#ifdef DEBUG
	printf( "vips_foreign_load_magick7_dispose: %p\n", gobject ); 
	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
		VIPS_FREEF( DestroyCacheView, magick7-&gt;cache_view[i] ); 
	}
	VIPS_FREEF( DestroyImageList, magick7-&gt;image );
	VIPS_FREEF( DestroyImageInfo, magick7-&gt;image_info ); 
	VIPS_FREE( magick7-&gt;frames );
	VIPS_FREE( magick7-&gt;cache_view );
	VIPS_FREEF( magick_destroy_exception, magick7-&gt;exception ); 
	VIPS_FREEF( vips_g_mutex_free, magick7-&gt;lock );
	G_OBJECT_CLASS( vips_foreign_load_magick7_parent_class )-&gt;
		dispose( gobject );
}
static int
vips_foreign_load_magick7_build( VipsObject *object )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) object;
#ifdef DEBUG
	printf( "vips_foreign_load_magick7_build: %p\n", object ); 
	magick_genesis();
	magick7-&gt;image_info = CloneImageInfo( NULL );
	magick7-&gt;exception = magick_acquire_exception();
	magick7-&gt;lock = vips_g_mutex_new();
	if( !magick7-&gt;image_info ) 
		return( -1 );
	if( magick7-&gt;all_frames )
		magick7-&gt;n = -1;
	VIPS_SETSTR( magick7-&gt;image_info-&gt;density, magick7-&gt;density );
  	magick_set_image_option( magick7-&gt;image_info, 
		"dcm:display-range", "reset" );
	if( magick7-&gt;page &gt; 0 ) 
		magick_set_number_scenes( magick7-&gt;image_info,
			magick7-&gt;page, magick7-&gt;n );
	if( VIPS_OBJECT_CLASS( vips_foreign_load_magick7_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
static void
vips_foreign_load_magick7_class_init( VipsForeignLoadMagick7Class *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;dispose = vips_foreign_load_magick7_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "magickload_base";
	object_class-&gt;description = _( "load with ImageMagick7" );
	object_class-&gt;build = vips_foreign_load_magick7_build;
	foreign_class-&gt;priority = -100;
	load_class-&gt;get_flags_filename = 
		vips_foreign_load_magick7_get_flags_filename;
	load_class-&gt;get_flags = vips_foreign_load_magick7_get_flags;
	VIPS_ARG_STRING( class, "density", 20,
		_( "Density" ),
		_( "Canvas resolution for rendering vector formats like SVG" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadMagick7, density ),
		NULL );
	VIPS_ARG_INT( class, "page", 21,
		_( "Page" ),
		_( "Load this page from the file" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadMagick7, page ),
		0, 100000, 0 );
	VIPS_ARG_INT( class, "n", 22,
		_( "n" ),
		_( "Load this many pages" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadMagick7, n ),
		-1, 100000, 1 );
	VIPS_ARG_BOOL( class, "all_frames", 23, 
		_( "all_frames" ), 
		_( "Read all frames from an image" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
<a name="1"></a>		G_STRUCT_OFFSET( VipsForeignLoadMagick7, all_frames ),
		FALSE );
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
static void
vips_foreign_load_magick7_init( VipsForeignLoadMagick7 *magick7 )
{
	magick7-&gt;n = 1;
}
static void
vips_foreign_load_magick7_error( VipsForeignLoadMagick7 *magick7 )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( magick7 );
	vips_error( class-&gt;nickname, _( "Magick: %s %s" ),
		magick7-&gt;exception-&gt;reason, 
		magick7-&gt;exception-&gt;description );
}
static int</b></font>
magick7_get_bands( Image *image )
{
	int bands;
	int i;
	bands = 0;
	for( i = 0; i &lt; GetPixelChannels( image ); i++ ) { 
		PixelChannel channel = GetPixelChannelChannel( image, i ); 
		if( channel != IndexPixelChannel ) 
			bands += 1;
	} 
	return( bands );
}
static int
vips_foreign_load_magick7_parse( VipsForeignLoadMagick7 *magick7, 
	Image *image, VipsImage *out )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( magick7 );
	const char *key;
	Image *p;
#ifdef DEBUG
	printf( "image-&gt;depth = %zd\n", image-&gt;depth ); 
	printf( "GetImageType() = %d\n", GetImageType( image ) );
	vips_magick7_print_image_type( image ); 
	printf( "GetPixelChannels() = %zd\n", GetPixelChannels( image ) ); 
	printf( "image-&gt;columns = %zd\n", image-&gt;columns ); 
	printf( "image-&gt;rows = %zd\n", image-&gt;rows ); 
	out-&gt;Xsize = image-&gt;columns;
	out-&gt;Ysize = image-&gt;rows;
	magick7-&gt;frame_height = image-&gt;rows;
	out-&gt;Bands = magick7_get_bands( image ); 
	if( out-&gt;Xsize &lt;= 0 ||
		out-&gt;Ysize &lt;= 0 ||
		out-&gt;Bands &lt;= 0 ||
		out-&gt;Xsize &gt;= VIPS_MAX_COORD ||
		out-&gt;Ysize &gt;= VIPS_MAX_COORD ||
		out-&gt;Bands &gt;= VIPS_MAX_COORD ) {
		vips_error( class-&gt;nickname, 
			_( "bad image dimensions %d x %d pixels, %d bands" ),
			out-&gt;Xsize, out-&gt;Ysize, out-&gt;Bands );
		return( -1 );
	}
	out-&gt;BandFmt = -1;
	if( image-&gt;depth &gt;= 1 &amp;&amp; image-&gt;depth &lt;= 8 ) 
		out-&gt;BandFmt = VIPS_FORMAT_UCHAR;
	if( image-&gt;depth &gt;= 9 &amp;&amp; image-&gt;depth &lt;= 16 ) 
		out-&gt;BandFmt = VIPS_FORMAT_USHORT;
	if( image-&gt;depth == 32 )
		out-&gt;BandFmt = VIPS_FORMAT_FLOAT;
	if( image-&gt;depth == 64 )
		out-&gt;BandFmt = VIPS_FORMAT_DOUBLE;
	if( out-&gt;BandFmt == -1 ) {
		vips_error( class-&gt;nickname, 
			_( "unsupported bit depth %zd" ), image-&gt;depth );
		return( -1 );
	}
	switch( image-&gt;colorspace ) {
	case GRAYColorspace:
		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
			out-&gt;Type = VIPS_INTERPRETATION_GREY16;
		else
			out-&gt;Type = VIPS_INTERPRETATION_B_W;
		break;
	case sRGBColorspace:
	case RGBColorspace:
		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
			out-&gt;Type = VIPS_INTERPRETATION_RGB16;
		else
			out-&gt;Type = VIPS_INTERPRETATION_sRGB;
		break;
	case CMYKColorspace:
		out-&gt;Type = VIPS_INTERPRETATION_CMYK;
		break;
	default:
		vips_error( class-&gt;nickname, 
			_( "unsupported colorspace %s" ), 
			magick_ColorspaceType2str( image-&gt;colorspace ) );
		return( -1 );
	}
	switch( image-&gt;units ) {
	case PixelsPerInchResolution:
		out-&gt;Xres = image-&gt;resolution.x / 25.4;
		out-&gt;Yres = image-&gt;resolution.y / 25.4;
		vips_image_set_string( out, VIPS_META_RESOLUTION_UNIT, "in" );
		break;
	case PixelsPerCentimeterResolution:
		out-&gt;Xres = image-&gt;resolution.x / 10.0;
		out-&gt;Yres = image-&gt;resolution.y / 10.0;
		vips_image_set_string( out, VIPS_META_RESOLUTION_UNIT, "cm" );
		break;
	default:
		out-&gt;Xres = 1.0;
		out-&gt;Yres = 1.0;
		break;
	}
	out-&gt;Coding = VIPS_CODING_NONE;
	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_SMALLTILE, NULL ) )
		return( -1 );
	ResetImagePropertyIterator( image );
	while( (key = GetNextImageProperty( image )) ) {
		char name_text[256];
		VipsBuf name = VIPS_BUF_STATIC( name_text );
		const char *value;
		value = GetImageProperty( image, key, magick7-&gt;exception );
		if( !value ) {
			vips_foreign_load_magick7_error( magick7 );
			return( -1 ); 
		}
		vips_buf_appendf( &amp;name, "magick-%s", key );
		vips_image_set_string( out, vips_buf_all( &amp;name ), value );
	}
	if( magick_set_vips_profile( out, image ) )
		return( -1 );
	magick7-&gt;n_pages = GetImageListLength( GetFirstImageInList( image ) );
#ifdef DEBUG
	printf( "image has %d pages\n", magick7-&gt;n_pages );
	magick7-&gt;n_frames = 0;
	for( p = image; p; (p = GetNextImageInList( p )) ) {
		if( p-&gt;columns != (unsigned int) out-&gt;Xsize ||
			p-&gt;rows != (unsigned int) out-&gt;Ysize ||
			magick7_get_bands( p ) != out-&gt;Bands ||
			p-&gt;depth != image-&gt;depth ) {
#ifdef DEBUG
			printf( "frame %d differs\n", magick7-&gt;n_frames );
			printf( "%zdx%zd, %d bands\n", 
				p-&gt;columns, p-&gt;rows, magick7_get_bands( p ) );
			printf( "first frame is %dx%d, %d bands\n", 
				out-&gt;Xsize, out-&gt;Ysize, out-&gt;Bands );
			break;
		}
		magick7-&gt;n_frames += 1;
	}
	if( p ) 
		magick7-&gt;n_frames = 1;
#ifdef DEBUG
	printf( "will read %d frames\n", magick7-&gt;n_frames );
	if( magick7-&gt;n != -1 )
		magick7-&gt;n_frames = VIPS_MIN( magick7-&gt;n_frames, magick7-&gt;n );
	if( vips_object_argument_isset( VIPS_OBJECT( magick7 ), "n" ) ) {
		vips_image_set_int( out, VIPS_META_PAGE_HEIGHT, out-&gt;Ysize );
		out-&gt;Ysize *= magick7-&gt;n_frames;
	}
	vips_image_set_int( out, VIPS_META_N_PAGES, magick7-&gt;n_pages );
	return( 0 );
}
#define UNPACK( TYPE ) { \
	TYPE * restrict tq = (TYPE *) q; \
	int x; \
	int b; \
	\
	for( x = 0; x &lt; r-&gt;width; x++ ) { \
		for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { \
			PixelChannel channel = \
				GetPixelChannelChannel( image, b ); \
			\
			if( channel != IndexPixelChannel ) \
				*tq++ = p[b]; \
		} \
		\
		p += GetPixelChannels( image ); \
	} \
}
static int
vips_foreign_load_magick7_fill_region( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) a;
	VipsRect *r = &amp;or-&gt;valid;
	VipsImage *im = or-&gt;im;
	int y;
	for( y = 0; y &lt; r-&gt;height; y++ ) {
		int top = r-&gt;top + y;
		int frame = top / magick7-&gt;frame_height;
		int line = top % magick7-&gt;frame_height;
		Image *image = magick7-&gt;frames[frame];
		Quantum * restrict p;
		VipsPel * restrict q;
		g_mutex_lock( magick7-&gt;lock );
		p = GetCacheViewAuthenticPixels( magick7-&gt;cache_view[frame],
			r-&gt;left, line, r-&gt;width, 1, 
			magick7-&gt;exception );
		g_mutex_unlock( magick7-&gt;lock );
		if( !p ) 
			continue;
		q = VIPS_REGION_ADDR( or, r-&gt;left, top ); 
		switch( im-&gt;BandFmt ) {
		case VIPS_FORMAT_UCHAR:
			UNPACK( unsigned char ); 
			break;
		case VIPS_FORMAT_USHORT:
			UNPACK( unsigned short ); 
			break;
		case VIPS_FORMAT_FLOAT:
			UNPACK( float ); 
			break;
		case VIPS_FORMAT_DOUBLE:
			UNPACK( double ); 
			break;
		default:
			g_assert_not_reached();
		}
	}
	return( 0 );
}
static int
vips_foreign_load_magick7_load( VipsForeignLoadMagick7 *magick7 )
{
	VipsForeignLoad *load = (VipsForeignLoad *) magick7;
	Image *p;
	int i;
#ifdef DEBUG
	printf( "vips_foreign_load_magick7_load: %p\n", magick7 ); 
	if( vips_foreign_load_magick7_parse( magick7, 
		magick7-&gt;image, load-&gt;out ) )
		return( -1 );
	g_assert( !magick7-&gt;frames ); 
	if( !(magick7-&gt;frames = 
		VIPS_ARRAY( NULL, magick7-&gt;n_frames, Image * )) )
		return( -1 );
	p = magick7-&gt;image;
	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
		magick7-&gt;frames[i] = p;
		p = GetNextImageInList( p );
	}
	g_assert( !magick7-&gt;cache_view ); 
	if( !(magick7-&gt;cache_view = VIPS_ARRAY( NULL, 
		magick7-&gt;n_frames, CacheView * )) )
		return( -1 );
	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
		magick7-&gt;cache_view[i] = AcquireAuthenticCacheView( 
			magick7-&gt;frames[i], magick7-&gt;exception );
	}
#ifdef DEBUG
	vips_magick7_print_traits( magick7-&gt;frames[0] ); 
	vips_magick7_print_channel_names( magick7-&gt;frames[0] );
	if( vips_image_generate( load-&gt;out, 
		NULL, vips_foreign_load_magick7_fill_region, NULL, 
		magick7, NULL ) )
		return( -1 );
	return( 0 );
}
typedef struct _VipsForeignLoadMagick7File {
	VipsForeignLoadMagick7 parent_object;
	char *filename; 
} VipsForeignLoadMagick7File;
typedef VipsForeignLoadMagick7Class VipsForeignLoadMagick7FileClass;
G_DEFINE_TYPE( VipsForeignLoadMagick7File, vips_foreign_load_magick7_file, 
	vips_foreign_load_magick7_get_type() );
static gboolean
ismagick7( const char *filename )
{
	unsigned char buf[100];
	int len;
	return( (len = vips__get_bytes( filename, buf, 100 )) &gt; 10 &amp;&amp;
		magick_ismagick( buf, len ) );
}
static int
vips_foreign_load_magick7_file_header( VipsForeignLoad *load )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) load;
	VipsForeignLoadMagick7File *file = (VipsForeignLoadMagick7File *) load;
#ifdef DEBUG
	printf( "vips_foreign_load_magick7_file_header: %p\n", load ); 
	vips_strncpy( magick7-&gt;image_info-&gt;filename, file-&gt;filename, 
		MagickPathExtent );
	magick_sniff_file( magick7-&gt;image_info, file-&gt;filename );
	magick7-&gt;image = ReadImage( magick7-&gt;image_info, magick7-&gt;exception );
	if( !magick7-&gt;image ) {
		vips_foreign_load_magick7_error( magick7 ); 
		return( -1 );
	}
	if( vips_foreign_load_magick7_load( magick7 ) )
		return( -1 );
<a name="0"></a>
	VIPS_SETSTR( load-&gt;out-&gt;filename, file-&gt;filename );
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
}
static void
vips_foreign_load_magick7_file_class_init( 
	VipsForeignLoadMagick7FileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "magickload";
	object_class-&gt;description = _( "load file with ImageMagick7" );
	load_class-&gt;is_a = ismagick7;
	load_class-&gt;header = vips_foreign_load_magick7_file_header;</b></font>
	VIPS_ARG_STRING( class, "filename", 1, 
		_( "Filename" ),
		_( "Filename to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadMagick7File, filename ),
		NULL );
}
static void
vips_foreign_load_magick7_file_init( VipsForeignLoadMagick7File *magick7_file )
{
}
typedef struct _VipsForeignLoadMagick7Buffer {
	VipsForeignLoadMagick7 parent_object;
	VipsArea *buf;
} VipsForeignLoadMagick7Buffer;
typedef VipsForeignLoadMagick7Class VipsForeignLoadMagick7BufferClass;
G_DEFINE_TYPE( VipsForeignLoadMagick7Buffer, vips_foreign_load_magick7_buffer, 
	vips_foreign_load_magick7_get_type() );
static gboolean
vips_foreign_load_magick7_buffer_is_a_buffer( const void *buf, size_t len )
{
	return( len &gt; 10 &amp;&amp; magick_ismagick( (const unsigned char *) buf, len ) );
}
static int
vips_foreign_load_magick7_buffer_header( VipsForeignLoad *load )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) load;
	VipsForeignLoadMagick7Buffer *magick7_buffer = 
		(VipsForeignLoadMagick7Buffer *) load;
#ifdef DEBUG
	printf( "vips_foreign_load_magick7_buffer_header: %p\n", load ); 
	magick_sniff_bytes( magick7-&gt;image_info, 
		magick7_buffer-&gt;buf-&gt;data, magick7_buffer-&gt;buf-&gt;length );
	magick7-&gt;image = BlobToImage( magick7-&gt;image_info, 
		magick7_buffer-&gt;buf-&gt;data, magick7_buffer-&gt;buf-&gt;length,
		magick7-&gt;exception );
	if( !magick7-&gt;image ) {
		vips_foreign_load_magick7_error( magick7 ); 
		return( -1 );
	}
	if( vips_foreign_load_magick7_load( magick7 ) )
		return( -1 );
	return( 0 );
}
static void
vips_foreign_load_magick7_buffer_class_init( 
	VipsForeignLoadMagick7BufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "magickload_buffer";
	object_class-&gt;description = _( "load buffer with ImageMagick7" );
	load_class-&gt;is_a_buffer = vips_foreign_load_magick7_buffer_is_a_buffer;
	load_class-&gt;header = vips_foreign_load_magick7_buffer_header;
	VIPS_ARG_BOXED( class, "buffer", 1, 
		_( "Buffer" ),
		_( "Buffer to load from" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadMagick7Buffer, buf ),
		VIPS_TYPE_BLOB );
}
static void
vips_foreign_load_magick7_buffer_init( VipsForeignLoadMagick7Buffer *buffer )
{
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>foreign.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;
#include "pforeign.h"
static GQuark vips__foreign_load_operation = 0; 
G_DEFINE_ABSTRACT_TYPE( VipsForeign, vips_foreign, VIPS_TYPE_OPERATION );
static void
vips_foreign_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
{
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( object_class );
	VIPS_OBJECT_CLASS( vips_foreign_parent_class )-&gt;
		summary_class( object_class, buf );
	if( class-&gt;suffs ) {
		const char **p;
		vips_buf_appends( buf, " (" );
		for( p = class-&gt;suffs; *p; p++ ) {
			vips_buf_appendf( buf, "%s", *p );
			if( p[1] )
				vips_buf_appends( buf, ", " );
		}
		vips_buf_appends( buf, ")" );
	}
	vips_buf_appendf( buf, ", priority=%d", class-&gt;priority );
}
static void
vips_foreign_class_init( VipsForeignClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "foreign";
	object_class-&gt;description = _( "load and save image files" );
	object_class-&gt;summary_class = vips_foreign_summary_class;
}
static void
vips_foreign_init( VipsForeign *object )
{
}
static void *
file_add_class( VipsForeignClass *class, GSList **files )
{
	if( !vips_isprefix( "rawload", VIPS_OBJECT_CLASS( class )-&gt;nickname ) ) 
		*files = g_slist_append( *files, class );
	return( NULL );
}
static gint
file_compare( VipsForeignClass *a, VipsForeignClass *b, void *user_data )
{
        return( b-&gt;priority - a-&gt;priority );
}
void *
vips_foreign_map( const char *base, VipsSListMap2Fn fn, void *a, void *b )
{
	GSList *files;
	void *result;
	files = NULL;
	(void) vips_class_map_all( g_type_from_name( base ), 
		(VipsClassMapFn) file_add_class, (void *) &amp;files );
	files = g_slist_sort( files, (GCompareFunc) file_compare );
#ifdef DEBUG
{
	GSList *p;
	printf( "vips_foreign_map: search order\n" );
	for( p = files; p; p = p-&gt;next ) {
		VipsForeignClass *class = (VipsForeignClass *) p-&gt;data;
		printf( "\t%s\n", VIPS_OBJECT_CLASS( class )-&gt;nickname );
	}
}
	result = vips_slist_map2( files, fn, a, b );
	g_slist_free( files );
	return( result );
}
G_DEFINE_ABSTRACT_TYPE( VipsForeignLoad, vips_foreign_load, VIPS_TYPE_FOREIGN );
static void
vips_foreign_load_dispose( GObject *gobject )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( gobject );
	VIPS_UNREF( load-&gt;real );
	G_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;dispose( gobject );
}
static void
vips_foreign_load_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
{
	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_CLASS( object_class );
	VIPS_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;
		summary_class( object_class, buf );
	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) ) {
		if( class-&gt;is_a )
			vips_buf_appends( buf, ", is_a" );
		if( class-&gt;is_a_buffer )
			vips_buf_appends( buf, ", is_a_buffer" );
		if( class-&gt;is_a_source )
			vips_buf_appends( buf, ", is_a_source" );
		if( class-&gt;get_flags )
			vips_buf_appends( buf, ", get_flags" );
		if( class-&gt;get_flags_filename )
			vips_buf_appends( buf, ", get_flags_filename" );
		if( class-&gt;header )
			vips_buf_appends( buf, ", header" );
		if( class-&gt;load )
			vips_buf_appends( buf, ", load" );
		g_assert( class-&gt;header );
	}
}
static void *
vips_foreign_find_load_sub( VipsForeignLoadClass *load_class, 
	const char *filename, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( load_class );
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( load_class );
	if( vips_ispostfix( object_class-&gt;nickname, "_buffer" ) ||
		vips_ispostfix( object_class-&gt;nickname, "_source" ) ) 
		return( NULL );
#ifdef DEBUG
	printf( "vips_foreign_find_load_sub: %s\n", 
		VIPS_OBJECT_CLASS( class )-&gt;nickname );
	if( load_class-&gt;is_a ) {
		if( load_class-&gt;is_a( filename ) ) 
			return( load_class );
#ifdef DEBUG
		printf( "vips_foreign_find_load_sub: is_a failed\n" ); 
	}
	else if( class-&gt;suffs ) {
		if( vips_filename_suffix_match( filename, class-&gt;suffs ) )
			return( load_class );
	}
	else 
		g_warning( "loader %s has no is_a method and no suffix list", 
			object_class-&gt;nickname );
	return( NULL );
}
const char *
vips_foreign_find_load( const char *name )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	VipsForeignLoadClass *load_class;
	vips__filename_split8( name, filename, option_string );
	if( !vips_existsf( "%s", filename ) ) {
		vips_error( "VipsForeignLoad", 
			_( "file \"%s\" does not exist" ), name );
		return( NULL );
	}
	if( vips_isdirf( "%s", filename ) ) {
		vips_error( "VipsForeignLoad", 
			_( "\"%s\" is a directory" ), name );
		return( NULL );
	}
	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
		"VipsForeignLoad",
		(VipsSListMap2Fn) vips_foreign_find_load_sub, 
		(void *) filename, NULL )) ) {
		vips_error( "VipsForeignLoad", 
			_( "\"%s\" is not a known file format" ), name );
		return( NULL );
	}
#ifdef DEBUG
	printf( "vips_foreign_find_load: selected %s\n", 
		VIPS_OBJECT_CLASS( load_class )-&gt;nickname );
	return( G_OBJECT_CLASS_NAME( load_class ) );
}
int
vips_foreign_load( const char *name, VipsImage **out, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;
	vips__filename_split8( name, filename, option_string );
	if( !(operation_name = vips_foreign_find_load( filename )) )
		return( -1 );
	va_start( ap, out );
	result = vips_call_split_option_string( operation_name, option_string, 
		ap, filename, out );
	va_end( ap );
	return( result );
}
static void *
vips_foreign_find_load_buffer_sub( VipsForeignLoadClass *load_class, 
	const void **buf, size_t *len )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( load_class );
	if( !vips_ispostfix( object_class-&gt;nickname, "_buffer" ) )
		return( NULL );
	if( load_class-&gt;is_a_buffer ) {
		if( load_class-&gt;is_a_buffer( *buf, *len ) ) 
			return( load_class );
	}
	else
		g_warning( "loader %s has no is_a_buffer method", 
			object_class-&gt;nickname );
	return( NULL );
}
const char *
vips_foreign_find_load_buffer( const void *data, size_t size )
{
	VipsForeignLoadClass *load_class;
	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
		"VipsForeignLoad",
		(VipsSListMap2Fn) vips_foreign_find_load_buffer_sub, 
		&amp;data, &amp;size )) ) {
		vips_error( "VipsForeignLoad", 
			"%s", _( "buffer is not in a known format" ) ); 
		return( NULL );
	}
	return( G_OBJECT_CLASS_NAME( load_class ) );
}
static void *
vips_foreign_find_load_source_sub( void *item, void *a, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( item );
	VipsForeignLoadClass *load_class = VIPS_FOREIGN_LOAD_CLASS( item );
	VipsSource *source = VIPS_SOURCE( a );
	if( !vips_ispostfix( object_class-&gt;nickname, "_source" ) )
		return( NULL );
	if( load_class-&gt;is_a_source ) {
		(void) vips_source_rewind( source );
		if( load_class-&gt;is_a_source( source ) ) 
			return( load_class );
	}
	else 
		g_warning( "loader %s has no is_a_source method", 
			object_class-&gt;nickname );
	return( NULL );
}
const char *
vips_foreign_find_load_source( VipsSource *source )
{
	VipsForeignLoadClass *load_class;
	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
		"VipsForeignLoad",
		vips_foreign_find_load_source_sub, 
		source, NULL )) ) {
		vips_error( "VipsForeignLoad", 
			"%s", _( "source is not in a known format" ) ); 
		return( NULL );
	}
	return( G_OBJECT_CLASS_NAME( load_class ) );
}
gboolean 
vips_foreign_is_a( const char *loader, const char *filename )
{
	const VipsObjectClass *class;
	VipsForeignLoadClass *load_class;
	if( !(class = vips_class_find( "VipsForeignLoad", loader )) ) 
		return( FALSE );
	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
	if( load_class-&gt;is_a &amp;&amp;
		load_class-&gt;is_a( filename ) ) 
		return( TRUE );
	return( FALSE );
}
gboolean
vips_foreign_is_a_buffer( const char *loader, const void *data, size_t size )
{
	const VipsObjectClass *class;
	VipsForeignLoadClass *load_class;
	if( !(class = vips_class_find( "VipsForeignLoad", loader )) )
		return( FALSE );
	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
	if( load_class-&gt;is_a_buffer &amp;&amp;
		load_class-&gt;is_a_buffer( data, size ) )
		return( TRUE );
	return( FALSE );
}
gboolean
vips_foreign_is_a_source( const char *loader, VipsSource *source )
{
	const VipsObjectClass *class;
	VipsForeignLoadClass *load_class;
	if( !(class = vips_class_find( "VipsForeignLoad", loader )) )
		return( FALSE );
	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
	if( load_class-&gt;is_a_source &amp;&amp;
		load_class-&gt;is_a_source( source ) )
		return( TRUE );
	return( FALSE );
}
VipsForeignFlags 
vips_foreign_flags( const char *loader, const char *filename )
{
	const VipsObjectClass *class;
	if( (class = vips_class_find( "VipsForeignLoad", loader )) ) {
		VipsForeignLoadClass *load_class = 
			VIPS_FOREIGN_LOAD_CLASS( class );
		if( load_class-&gt;get_flags_filename ) 
			return( load_class-&gt;get_flags_filename( filename ) );
	}
	return( 0 );
}
static VipsObject *
vips_foreign_load_new_from_string( const char *string )
{
	const char *file_op;
	GType type;
	VipsForeignLoad *load;
	if( !(file_op = vips_foreign_find_load( string )) )
		return( NULL );
	type = g_type_from_name( file_op );
	g_assert( type ); 
	load = VIPS_FOREIGN_LOAD( g_object_new( type, NULL ) );
	g_object_set( load,
		"filename", string,
		NULL );
	return( VIPS_OBJECT( load ) );
}
static VipsImage *
vips_foreign_load_temp( VipsForeignLoad *load )
{
	const guint64 disc_threshold = vips_get_disc_threshold();
	const guint64 image_size = VIPS_IMAGE_SIZEOF_IMAGE( load-&gt;out );
	if( !load-&gt;disc )
		load-&gt;memory = TRUE;
	if( load-&gt;memory ) {
#ifdef DEBUG
		printf( "vips_foreign_load_temp: forced memory temp\n" );
		return( vips_image_new_memory() );
	}
	if( load-&gt;flags &amp; VIPS_FOREIGN_PARTIAL ) {
#ifdef DEBUG
		printf( "vips_foreign_load_temp: partial temp\n" );
		return( vips_image_new() );
	}
	if( (load-&gt;flags &amp; VIPS_FOREIGN_SEQUENTIAL) &amp;&amp; 
		load-&gt;access != VIPS_ACCESS_RANDOM ) {
#ifdef DEBUG
		printf( "vips_foreign_load_temp: partial sequential temp\n" );
		return( vips_image_new() );
	}
	if( image_size &gt; disc_threshold ) {
#ifdef DEBUG
		printf( "vips_foreign_load_temp: disc temp\n" );
		return( vips_image_new_temp_file( "%s.v" ) );
	}
#ifdef DEBUG
	printf( "vips_foreign_load_temp: fallback memory temp\n" );
	return( vips_image_new_memory() );
}
static gboolean
vips_foreign_load_iscompat( VipsImage *a, VipsImage *b )
{
	if( a-&gt;Xsize != b-&gt;Xsize ||
		a-&gt;Ysize != b-&gt;Ysize ||
		a-&gt;Bands != b-&gt;Bands ||
		a-&gt;Coding != b-&gt;Coding ||
		a-&gt;BandFmt != b-&gt;BandFmt ) {
		vips_error( "VipsForeignLoad",
			"%s", _( "images do not match" ) ); 
		return( FALSE );
	}
	return( TRUE );
}
static void *
vips_foreign_load_start( VipsImage *out, void *a, void *b )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );
	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );
	if( load-&gt;error )
		return( NULL );
	if( !load-&gt;real ) {
		if( !(load-&gt;real = vips_foreign_load_temp( load )) )
			return( NULL );
#ifdef DEBUG
		printf( "vips_foreign_load_start: triggering -&gt;load()\n" );
		load-&gt;real-&gt;progress_signal = load-&gt;out;
		g_object_set_qdata( G_OBJECT( load-&gt;real ), 
			vips__foreign_load_operation, load ); 
		if( class-&gt;load( load ) ||
			vips_image_pio_input( load-&gt;real ) || 
			!vips_foreign_load_iscompat( load-&gt;real, out ) ) {
			vips_operation_invalidate( VIPS_OPERATION( load ) ); 
			load-&gt;error = TRUE;
			return( NULL );
		}
		if( vips_image_pipelinev( load-&gt;out, load-&gt;out-&gt;dhint, 
			load-&gt;real, NULL ) )
			return( NULL );
	}
	return( vips_region_new( load-&gt;real ) );
}
static int
vips_foreign_load_generate( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsRegion *ir = (VipsRegion *) seq;
        VipsRect *r = &amp;or-&gt;valid;
        if( vips_region_prepare( ir, r ) )
                return( -1 );
        if( vips_region_region( or, ir, r, r-&gt;left, r-&gt;top ) )
                return( -1 );
        return( 0 );
}
static int
vips_foreign_load_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( object );
	VipsForeignLoadClass *fclass = VIPS_FOREIGN_LOAD_GET_CLASS( object );
	VipsForeignFlags flags;
	gboolean sequential;
#ifdef DEBUG
	printf( "vips_foreign_load_build:\n" );
	flags = 0;
	if( fclass-&gt;get_flags )
		flags |= fclass-&gt;get_flags( load );
	if( (flags &amp; VIPS_FOREIGN_PARTIAL) &amp;&amp;
		(flags &amp; VIPS_FOREIGN_SEQUENTIAL) ) {
		g_warning( "%s", 
			_( "VIPS_FOREIGN_PARTIAL and VIPS_FOREIGN_SEQUENTIAL "
				"both set -- using SEQUENTIAL" ) );
		flags ^= VIPS_FOREIGN_PARTIAL;
	}
	g_object_set( load, "flags", flags, NULL );
	sequential = (load-&gt;flags &amp; VIPS_FOREIGN_SEQUENTIAL) &amp;&amp; 
		load-&gt;access != VIPS_ACCESS_RANDOM;
	if( sequential )
		load-&gt;nocache = TRUE;
	if( VIPS_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;
		build( object ) )
		return( -1 );
	if( load-&gt;sequential ) 
		g_warning( "%s", 
			_( "ignoring deprecated \"sequential\" mode -- "
				"please use \"access\" instead" ) ); 
	g_object_set( object, "out", vips_image_new(), NULL ); 
	vips_image_set_string( load-&gt;out, 
		VIPS_META_LOADER, class-&gt;nickname );
#ifdef DEBUG
	printf( "vips_foreign_load_build: triggering -&gt;header()\n" );
	if( fclass-&gt;header &amp;&amp;
		fclass-&gt;header( load ) ) 
		return( -1 );
	if( fclass-&gt;load ) {
#ifdef DEBUG
		printf( "vips_foreign_load_build: delaying read ...\n" );
		if( vips_image_pipelinev( load-&gt;out, load-&gt;out-&gt;dhint, NULL ) )
			return( -1 );
		if( vips_image_generate( load-&gt;out, 
			vips_foreign_load_start, 
			vips_foreign_load_generate, 
			vips_stop_one, 
			NULL, load ) ) 
			return( -1 );
	}
	if( sequential ) 
		vips_image_set_area( load-&gt;out, 
			VIPS_META_SEQUENTIAL, NULL, NULL ); 
	return( 0 );
}
static VipsOperationFlags 
vips_foreign_load_operation_get_flags( VipsOperation *operation )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( operation );
	VipsOperationFlags flags;
	flags = VIPS_OPERATION_CLASS( vips_foreign_load_parent_class )-&gt;
		get_flags( operation );
<a name="0"></a>	if( load-&gt;nocache )
		flags |= VIPS_OPERATION_NOCACHE;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( flags );
}
static void
vips_foreign_load_class_init( VipsForeignLoadClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsOperationClass *operation_class = (VipsOperationClass *) class;
	gobject_class-&gt;dispose = vips_foreign_load_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;build = vips_foreign_load_build;
	object_class-&gt;summary_class = vips_foreign_load_summary_class;
	object_class-&gt;new_from_string = vips_foreign_load_new_from_string;</b></font>
	object_class-&gt;nickname = "fileload";
	object_class-&gt;description = _( "file loaders" );
	operation_class-&gt;get_flags = vips_foreign_load_operation_get_flags;
	VIPS_ARG_IMAGE( class, "out", 2, 
		_( "Output" ), 
		_( "Output image" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
		G_STRUCT_OFFSET( VipsForeignLoad, out ) );
	VIPS_ARG_FLAGS( class, "flags", 106, 
		_( "Flags" ), 
		_( "Flags for this file" ),
		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
		G_STRUCT_OFFSET( VipsForeignLoad, flags ),
		VIPS_TYPE_FOREIGN_FLAGS, VIPS_FOREIGN_NONE ); 
	VIPS_ARG_BOOL( class, "memory", 107, 
		_( "Memory" ), 
		_( "Force open via memory" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoad, memory ),
		FALSE );
	VIPS_ARG_ENUM( class, "access", 108, 
		_( "Access" ), 
		_( "Required access pattern for this file" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoad, access ),
		VIPS_TYPE_ACCESS, VIPS_ACCESS_RANDOM ); 
	VIPS_ARG_BOOL( class, "sequential", 109, 
		_( "Sequential" ), 
		_( "Sequential read only" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignLoad, sequential ),
		FALSE );
	VIPS_ARG_BOOL( class, "fail", 110, 
		_( "Fail" ), 
		_( "Fail on first error" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoad, fail ),
		FALSE );
	VIPS_ARG_BOOL( class, "disc", 111, 
		_( "Disc" ), 
		_( "Open to disc" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignLoad, disc ),
		TRUE );
}
static void
vips_foreign_load_init( VipsForeignLoad *load )
{
	load-&gt;disc = TRUE;
	load-&gt;access = VIPS_ACCESS_RANDOM;
}
void
vips_foreign_load_invalidate( VipsImage *image )
{
	VipsOperation *operation; 
#ifdef DEBUG
	printf( "vips_foreign_load_invalidate: %p\n", image ); 
	if( (operation = g_object_get_qdata( G_OBJECT( image ), 
<a name="1"></a>		vips__foreign_load_operation )) ) {
		vips_operation_invalidate( operation ); 
	}
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
G_DEFINE_ABSTRACT_TYPE( VipsForeignSave, vips_foreign_save, VIPS_TYPE_FOREIGN );
static void
vips_foreign_save_dispose( GObject *gobject )
{
	VipsForeignSave *save = VIPS_FOREIGN_SAVE( gobject );
	VIPS_UNREF( save-&gt;ready );
	G_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;dispose( gobject );
}
static void
vips_foreign_save_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
{
	VipsForeignSaveClass *class = VIPS_FOREIGN_SAVE_CLASS( object_class );
	VIPS_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;
		summary_class( object_class, buf );
	vips_buf_appendf( buf, ", %s", 
		vips_enum_nick( VIPS_TYPE_SAVEABLE, class-&gt;saveable ) );
}
static VipsObject *</b></font>
vips_foreign_save_new_from_string( const char *string )
{
	const char *file_op;
	GType type;
	VipsForeignSave *save;
	if( !(file_op = vips_foreign_find_save( string )) )
		return( NULL );
	type = g_type_from_name( file_op );
	g_assert( type ); 
	save = VIPS_FOREIGN_SAVE( g_object_new( type, NULL ) );
	g_object_set( save,
		"filename", string,
		NULL );
	return( VIPS_OBJECT( save ) );
}
int
vips__foreign_convert_saveable( VipsImage *in, VipsImage **ready,
	VipsSaveable saveable, VipsBandFormat *format, VipsCoding *coding,
	VipsArrayDouble *background )
{
	g_object_ref( in );
	if( in-&gt;Coding != VIPS_CODING_NONE &amp;&amp;
		coding[in-&gt;Coding] ) {
		*ready = in;
		return( 0 );
	}
	if( in-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
	        saveable == VIPS_SAVEABLE_ANY &amp;&amp;
		format[in-&gt;BandFmt] == in-&gt;BandFmt ) {
		*ready = in;
		return( 0 );
	}
	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
		VipsImage *out;
		if( vips_LabQ2sRGB( in, &amp;out, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );
		in = out;
	}
	if( in-&gt;Coding == VIPS_CODING_RAD ) {
		VipsImage *out;
		if( vips_rad2float( in, &amp;out, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );
		in = out;
	}
	if( coding[VIPS_CODING_RAD] ) {
		if( in-&gt;Type != VIPS_INTERPRETATION_scRGB &amp;&amp;
			in-&gt;Type != VIPS_INTERPRETATION_XYZ ) {
			VipsImage *out;
			if( vips_colourspace( in, &amp;out, 
				VIPS_INTERPRETATION_scRGB, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
		}
	}
	if( in-&gt;Type == VIPS_INTERPRETATION_CMYK &amp;&amp;
		in-&gt;Bands &gt;= 4 &amp;&amp;
		(saveable == VIPS_SAVEABLE_RGB ||
		 saveable == VIPS_SAVEABLE_RGBA ||
		 saveable == VIPS_SAVEABLE_RGBA_ONLY) ) { 
		VipsImage *out;
		if( vips_icc_import( in, &amp;out, 
			"pcs", VIPS_PCS_XYZ,
			"embedded", TRUE,
			"input_profile", "cmyk",
			NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );
		in = out;
	}
	if( !coding[VIPS_CODING_RAD] &amp;&amp;
		in-&gt;Bands &gt;= 3 &amp;&amp;
		in-&gt;Type != VIPS_INTERPRETATION_CMYK &amp;&amp;
		in-&gt;Type != VIPS_INTERPRETATION_sRGB &amp;&amp;
		in-&gt;Type != VIPS_INTERPRETATION_RGB16 &amp;&amp;
		in-&gt;Type != VIPS_INTERPRETATION_scRGB &amp;&amp;
		vips_colourspace_issupported( in ) &amp;&amp;
		(saveable == VIPS_SAVEABLE_RGB ||
		 saveable == VIPS_SAVEABLE_RGBA ||
		 saveable == VIPS_SAVEABLE_RGBA_ONLY ||
		 saveable == VIPS_SAVEABLE_RGB_CMYK) ) { 
		VipsImage *out;
		VipsInterpretation interpretation;
		if( vips_band_format_is8bit( format[in-&gt;BandFmt] ) )
			interpretation = VIPS_INTERPRETATION_sRGB;
		else
			interpretation = VIPS_INTERPRETATION_RGB16;
		if( vips_colourspace( in, &amp;out, interpretation, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );
		in = out;
	}
	if( !coding[VIPS_CODING_RAD] &amp;&amp;
		in-&gt;Bands &lt; 3 &amp;&amp;
		vips_colourspace_issupported( in ) &amp;&amp;
		saveable == VIPS_SAVEABLE_RGBA_ONLY ) { 
		VipsImage *out;
		VipsInterpretation interpretation;
		if( vips_band_format_is8bit( format[in-&gt;BandFmt] ) )
			interpretation = VIPS_INTERPRETATION_sRGB;
		else
			interpretation = VIPS_INTERPRETATION_RGB16;
		if( vips_colourspace( in, &amp;out, interpretation, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );
		in = out;
	}
	if( in-&gt;Coding == VIPS_CODING_NONE ) {
		if( (in-&gt;Bands == 2 ||
			(in-&gt;Bands == 4 &amp;&amp; 
			 in-&gt;Type != VIPS_INTERPRETATION_CMYK)) &amp;&amp;
			(saveable == VIPS_SAVEABLE_MONO ||
			 saveable == VIPS_SAVEABLE_RGB ||
			 saveable == VIPS_SAVEABLE_RGB_CMYK) ) {
			VipsImage *out;
			if( vips_flatten( in, &amp;out, 
				"background", background,
				NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
		}
		else if( in-&gt;Bands &gt; 3 &amp;&amp; 
			(saveable == VIPS_SAVEABLE_RGB ||
			 (saveable == VIPS_SAVEABLE_RGB_CMYK &amp;&amp;
			  in-&gt;Type != VIPS_INTERPRETATION_CMYK)) ) { 
			VipsImage *out;
			if( vips_extract_band( in, &amp;out, 0, 
				"n", 3,
				NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
		}
		else if( in-&gt;Bands &gt; 4 &amp;&amp; 
			((saveable == VIPS_SAVEABLE_RGB_CMYK &amp;&amp;
			  in-&gt;Type == VIPS_INTERPRETATION_CMYK) ||
			 saveable == VIPS_SAVEABLE_RGBA ||
			 saveable == VIPS_SAVEABLE_RGBA_ONLY) ) {
			VipsImage *out;
			if( vips_extract_band( in, &amp;out, 0, 
				"n", 4,
				NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
		}
		else if( in-&gt;Bands &gt; 1 &amp;&amp; 
			saveable == VIPS_SAVEABLE_MONO ) {
			VipsImage *out;
			if( vips_extract_band( in, &amp;out, 0, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
		}
	}
	if( (in-&gt;Type == VIPS_INTERPRETATION_RGB16 ||
		 in-&gt;Type == VIPS_INTERPRETATION_GREY16) &amp;&amp;
		!vips_band_format_is8bit( in-&gt;BandFmt ) ) {
		if( format[VIPS_FORMAT_USHORT] == VIPS_FORMAT_USHORT ) {
			VipsImage *out;
			if( vips_cast( in, &amp;out, VIPS_FORMAT_USHORT, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
		}
		else {
			VipsImage *out;
			if( vips_rshift_const1( in, &amp;out, 8, NULL ) ) { 
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
			if( vips_cast( in, &amp;out, VIPS_FORMAT_UCHAR, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
		}
	}
	{
		VipsImage *out;
		if( vips_cast( in, &amp;out, format[in-&gt;BandFmt], NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );
		in = out;
	}
	if( coding[VIPS_CODING_NONE] ) {
	}
	else if( coding[VIPS_CODING_LABQ] ) {
		VipsImage *out;
		if( vips_Lab2LabQ( in, &amp;out, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );
		in = out;
	}
	else if( coding[VIPS_CODING_RAD] ) {
		VipsImage *out;
		if( vips_float2rad( in, &amp;out, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );
		in = out;
	}
	if( vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ) {
		const void *data;
		size_t length;
		if( !vips_image_get_blob( in, VIPS_META_ICC_NAME, 
			&amp;data, &amp;length ) &amp;&amp;
			!vips_icc_is_compatible_profile( in, data, length ) ) {
			VipsImage *out;
			if( vips_copy( in, &amp;out, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );
			in = out;
			vips_image_remove( in, VIPS_META_ICC_NAME );
		}
	}
	*ready = in;
	return( 0 );
}
static int
vips_foreign_save_build( VipsObject *object )
{
	VipsForeignSave *save = VIPS_FOREIGN_SAVE( object );
	if( save-&gt;in ) {
		VipsForeignSaveClass *class = 
			VIPS_FOREIGN_SAVE_GET_CLASS( save );
		VipsImage *ready;
		if( vips__foreign_convert_saveable( save-&gt;in, &amp;ready,
			class-&gt;saveable, class-&gt;format_table, class-&gt;coding,
			save-&gt;background ) )
			return( -1 );
		if( save-&gt;page_height ) {
			VipsImage *x;
			if( vips_copy( ready, &amp;x, NULL ) ) {
				VIPS_UNREF( ready );
				return( -1 );
			}
			VIPS_UNREF( ready );
			ready = x;
			vips_image_set_int( ready, 
				VIPS_META_PAGE_HEIGHT, save-&gt;page_height );
		}
		VIPS_UNREF( save-&gt;ready );
		save-&gt;ready = ready;
	}
	if( VIPS_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;
		build( object ) )
		return( -1 );
	return( 0 );
}
#define UC VIPS_FORMAT_UCHAR
#define C VIPS_FORMAT_CHAR
#define US VIPS_FORMAT_USHORT
#define S VIPS_FORMAT_SHORT
#define UI VIPS_FORMAT_UINT
#define I VIPS_FORMAT_INT
#define F VIPS_FORMAT_FLOAT
#define X VIPS_FORMAT_COMPLEX
#define D VIPS_FORMAT_DOUBLE
#define DX VIPS_FORMAT_DPCOMPLEX
static int vips_foreign_save_format_table[10] = {
   UC, C,  US, S,  UI, I, F, X, D, DX
};
static void
vips_foreign_save_class_init( VipsForeignSaveClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsOperationClass *operation_class = (VipsOperationClass *) class;
	int i;
	gobject_class-&gt;dispose = vips_foreign_save_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;build = vips_foreign_save_build;
	object_class-&gt;summary_class = vips_foreign_save_summary_class;
	object_class-&gt;new_from_string = vips_foreign_save_new_from_string;
	object_class-&gt;nickname = "filesave";
	object_class-&gt;description = _( "file savers" );
	operation_class-&gt;flags |= VIPS_OPERATION_SEQUENTIAL;
	operation_class-&gt;flags |= VIPS_OPERATION_NOCACHE;
	for( i = 0; i &lt; VIPS_CODING_LAST; i++ )
		class-&gt;coding[i] = FALSE;
	class-&gt;coding[VIPS_CODING_NONE] = TRUE;
	class-&gt;format_table = vips_foreign_save_format_table; 
	VIPS_ARG_IMAGE( class, "in", 0, 
		_( "Input" ), 
		_( "Image to save" ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsForeignSave, in ) );
	VIPS_ARG_BOOL( class, "strip", 100,
		_( "Strip" ),
		_( "Strip all metadata from image" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSave, strip ),
		FALSE );
	VIPS_ARG_BOXED( class, "background", 101, 
		_( "Background" ), 
		_( "Background value" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSave, background ),
		VIPS_TYPE_ARRAY_DOUBLE );
	VIPS_ARG_INT( class, "page_height", 102, 
		_( "Page height" ), 
		_( "Set page height for multipage save" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSave, page_height ),
		0, VIPS_MAX_COORD, 0 ); 
}
static void
vips_foreign_save_init( VipsForeignSave *save )
{
	save-&gt;background = vips_array_double_newv( 1, 0.0 );
}
static void *
vips_foreign_find_save_sub( VipsForeignSaveClass *save_class, 
	const char *filename, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
	const char **p;
	if( !class-&gt;suffs )
		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
	if( vips_ispostfix( object_class-&gt;nickname, "_buffer" ) ||
		vips_ispostfix( object_class-&gt;nickname, "_target" ) )
		return( NULL );
	for( p = class-&gt;suffs; *p; p++ ) 
		if( vips_iscasepostfix( filename, *p ) ) 
			return( save_class );
	return( NULL );
}
const char *
vips_foreign_find_save( const char *name )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	VipsForeignSaveClass *save_class;
	vips__filename_split8( name, filename, option_string );
	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
		"VipsForeignSave",
		(VipsSListMap2Fn) vips_foreign_find_save_sub, 
		(void *) filename, NULL )) ) {
		vips_error( "VipsForeignSave",
			_( "\"%s\" is not a known file format" ), name );
		return( NULL );
	}
	return( G_OBJECT_CLASS_NAME( save_class ) );
}
static void *
vips_foreign_get_suffixes_count_cb( VipsForeignSaveClass *save_class, 
	void *a, void *b )
{
	VipsForeignClass *foreign_class = VIPS_FOREIGN_CLASS( save_class );
	int *n_fields = (int *) a;
	int i;
	if( foreign_class-&gt;suffs )
		for( i = 0; foreign_class-&gt;suffs[i]; i++ )
			*n_fields += 1;
	return( NULL ); 
}
static void *
vips_foreign_get_suffixes_add_cb( VipsForeignSaveClass *save_class, 
	void *a, void *b )
{
	VipsForeignClass *foreign_class = VIPS_FOREIGN_CLASS( save_class );
	gchar ***p = (gchar ***) a;
	int i;
	if( foreign_class-&gt;suffs )
		for( i = 0; foreign_class-&gt;suffs[i]; i++ ) {
			**p = g_strdup( foreign_class-&gt;suffs[i] ); 
			*p += 1;
		}
	return( NULL ); 
}
gchar ** 
vips_foreign_get_suffixes( void )
{
	int n_suffs;
	gchar **suffs;
	gchar **p;
	n_suffs = 0;
	(void) vips_foreign_map( 
		"VipsForeignSave",
		(VipsSListMap2Fn) vips_foreign_get_suffixes_count_cb, 
		&amp;n_suffs, NULL );
	suffs = g_new0( gchar *, n_suffs + 1 ); 
	p = suffs;
	(void) vips_foreign_map( 
		"VipsForeignSave",
		(VipsSListMap2Fn) vips_foreign_get_suffixes_add_cb, 
		&amp;p, NULL );
	return( suffs ); 
}
int
vips_foreign_save( VipsImage *in, const char *name, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;
	vips__filename_split8( name, filename, option_string );
	if( !(operation_name = vips_foreign_find_save( filename )) )
		return( -1 );
	va_start( ap, name );
	result = vips_call_split_option_string( operation_name, option_string, 
		ap, in, filename );
	va_end( ap );
	return( result );
}
static void *
vips_foreign_find_save_target_sub( VipsForeignSaveClass *save_class, 
	const char *suffix, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
		!class-&gt;suffs )
		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
		class-&gt;suffs &amp;&amp;
		vips_ispostfix( object_class-&gt;nickname, "_target" ) &amp;&amp;
		vips_filename_suffix_match( suffix, class-&gt;suffs ) )
		return( save_class );
	return( NULL );
}
const char *
vips_foreign_find_save_target( const char *name )
{
	char suffix[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	VipsForeignSaveClass *save_class;
	vips__filename_split8( name, suffix, option_string );
	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
		"VipsForeignSave",
		(VipsSListMap2Fn) vips_foreign_find_save_target_sub, 
		(void *) suffix, NULL )) ) {
		vips_error( "VipsForeignSave",
			_( "\"%s\" is not a known target format" ), name );
		return( NULL );
	}
	return( G_OBJECT_CLASS_NAME( save_class ) );
}
static void *
vips_foreign_find_save_buffer_sub( VipsForeignSaveClass *save_class, 
	const char *suffix, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );
	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
		!class-&gt;suffs )
		g_warning( "no suffix defined for %s", object_class-&gt;nickname );
	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
		class-&gt;suffs &amp;&amp;
		vips_ispostfix( object_class-&gt;nickname, "_buffer" ) &amp;&amp;
		vips_filename_suffix_match( suffix, class-&gt;suffs ) )
		return( save_class );
	return( NULL );
}
const char *
vips_foreign_find_save_buffer( const char *name )
{
	char suffix[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	VipsForeignSaveClass *save_class;
	vips__filename_split8( name, suffix, option_string );
	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
		"VipsForeignSave",
		(VipsSListMap2Fn) vips_foreign_find_save_buffer_sub, 
		(void *) suffix, NULL )) ) {
		vips_error( "VipsForeignSave",
			_( "\"%s\" is not a known buffer format" ), name );
		return( NULL );
	}
	return( G_OBJECT_CLASS_NAME( save_class ) );
}
int
vips_heifload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "heifload", ap, filename, out );
	va_end( ap );
	return( result );
}
int
vips_heifload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;
	blob = vips_blob_new( NULL, buf, len );
	va_start( ap, out );
	result = vips_call_split( "heifload_buffer", ap, blob, out );
	va_end( ap );
	vips_area_unref( VIPS_AREA( blob ) );
	return( result );
}
int
vips_heifload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "heifload_source", ap, source, out );
	va_end( ap );
	return( result );
}
int
vips_heifsave( VipsImage *in, const char *filename, ... )
{
	va_list ap;
	int result;
	va_start( ap, filename );
	result = vips_call_split( "heifsave", ap, in, filename );
	va_end( ap );
	return( result );
}
int
vips_heifsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
{
	va_list ap;
	VipsArea *area;
	int result;
	area = NULL; 
	va_start( ap, len );
	result = vips_call_split( "heifsave_buffer", ap, in, &amp;area );
	va_end( ap );
	if( !result &amp;&amp;
		area ) { 
		if( buf ) {
			*buf = area-&gt;data;
			area-&gt;free_fn = NULL;
		}
		if( len ) 
			*len = area-&gt;length;
		vips_area_unref( area );
	}
	return( result );
}
int
vips_heifsave_target( VipsImage *in, VipsTarget *target, ... )
{
	va_list ap;
	int result;
	va_start( ap, target );
	result = vips_call_split( "heifsave_target", ap, in, target );
	va_end( ap );
	return( result );
}
int
vips_jxlload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "jxlload", ap, filename, out );
	va_end( ap );
	return( result );
}
int
vips_jxlload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;
	blob = vips_blob_new( NULL, buf, len );
	va_start( ap, out );
	result = vips_call_split( "jxlload_buffer", ap, blob, out );
	va_end( ap );
	vips_area_unref( VIPS_AREA( blob ) );
	return( result );
}
int
vips_jxlload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "jxlload_source", ap, source, out );
	va_end( ap );
	return( result );
}
int
vips_jxlsave( VipsImage *in, const char *filename, ... )
{
	va_list ap;
	int result;
	va_start( ap, filename );
	result = vips_call_split( "jxlsave", ap, in, filename );
	va_end( ap );
	return( result );
}
int
vips_jxlsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
{
	va_list ap;
	VipsArea *area;
	int result;
	area = NULL; 
	va_start( ap, len );
	result = vips_call_split( "jxlsave_buffer", ap, in, &amp;area );
	va_end( ap );
	if( !result &amp;&amp;
		area ) { 
		if( buf ) {
			*buf = area-&gt;data;
			area-&gt;free_fn = NULL;
		}
		if( len ) 
			*len = area-&gt;length;
		vips_area_unref( area );
	}
	return( result );
}
int
vips_jxlsave_target( VipsImage *in, VipsTarget *target, ... )
{
	va_list ap;
	int result;
	va_start( ap, target );
	result = vips_call_split( "jxlsave_target", ap, in, target );
	va_end( ap );
	return( result );
}
int
vips_pdfload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "pdfload", ap, filename, out );
	va_end( ap );
	return( result );
}
int
vips_pdfload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;
	blob = vips_blob_new( NULL, buf, len );
	va_start( ap, out );
	result = vips_call_split( "pdfload_buffer", ap, blob, out );
	va_end( ap );
	vips_area_unref( VIPS_AREA( blob ) );
	return( result );
}
int
vips_pdfload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "pdfload_source", ap, source, out );
	va_end( ap );
	return( result );
}
int
vips_openslideload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "openslideload", ap, filename, out );
	va_end( ap );
	return( result );
}
int
vips_openslideload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "openslideload_source", ap, source, out );
	va_end( ap );
	return( result );
}
void
vips_foreign_operation_init( void )
{
	extern GType vips_foreign_load_rad_file_get_type( void ); 
	extern GType vips_foreign_load_rad_buffer_get_type( void ); 
	extern GType vips_foreign_load_rad_source_get_type( void ); 
	extern GType vips_foreign_save_rad_file_get_type( void ); 
	extern GType vips_foreign_save_rad_buffer_get_type( void ); 
	extern GType vips_foreign_save_rad_target_get_type( void ); 
	extern GType vips_foreign_load_mat_get_type( void ); 
	extern GType vips_foreign_load_ppm_file_get_type( void ); 
	extern GType vips_foreign_load_ppm_source_get_type( void ); 
	extern GType vips_foreign_save_ppm_file_get_type( void ); 
	extern GType vips_foreign_save_ppm_target_get_type( void ); 
	extern GType vips_foreign_load_png_file_get_type( void ); 
	extern GType vips_foreign_load_png_buffer_get_type( void ); 
	extern GType vips_foreign_load_png_source_get_type( void ); 
	extern GType vips_foreign_save_png_file_get_type( void ); 
	extern GType vips_foreign_save_png_buffer_get_type( void ); 
	extern GType vips_foreign_save_png_target_get_type( void ); 
	extern GType vips_foreign_load_csv_file_get_type( void ); 
	extern GType vips_foreign_load_csv_source_get_type( void ); 
	extern GType vips_foreign_save_csv_file_get_type( void ); 
	extern GType vips_foreign_save_csv_target_get_type( void ); 
	extern GType vips_foreign_load_matrix_file_get_type( void ); 
	extern GType vips_foreign_load_matrix_source_get_type( void ); 
	extern GType vips_foreign_save_matrix_file_get_type( void ); 
	extern GType vips_foreign_save_matrix_target_get_type( void ); 
	extern GType vips_foreign_print_matrix_get_type( void ); 
	extern GType vips_foreign_load_fits_file_get_type( void ); 
	extern GType vips_foreign_load_fits_source_get_type( void ); 
	extern GType vips_foreign_save_fits_get_type( void ); 
	extern GType vips_foreign_load_analyze_get_type( void ); 
	extern GType vips_foreign_load_openexr_get_type( void ); 
	extern GType vips_foreign_load_openslide_file_get_type( void ); 
	extern GType vips_foreign_load_openslide_source_get_type( void ); 
	extern GType vips_foreign_load_vips_file_get_type( void ); 
	extern GType vips_foreign_load_vips_source_get_type( void ); 
	extern GType vips_foreign_save_vips_file_get_type( void ); 
	extern GType vips_foreign_save_vips_target_get_type( void ); 
	extern GType vips_foreign_load_jpeg_file_get_type( void ); 
	extern GType vips_foreign_load_jpeg_buffer_get_type( void ); 
	extern GType vips_foreign_load_jpeg_source_get_type( void ); 
	extern GType vips_foreign_save_jpeg_file_get_type( void ); 
	extern GType vips_foreign_save_jpeg_buffer_get_type( void ); 
	extern GType vips_foreign_save_jpeg_target_get_type( void ); 
	extern GType vips_foreign_save_jpeg_mime_get_type( void ); 
	extern GType vips_foreign_load_tiff_file_get_type( void ); 
	extern GType vips_foreign_load_tiff_buffer_get_type( void ); 
	extern GType vips_foreign_load_tiff_source_get_type( void ); 
	extern GType vips_foreign_save_tiff_file_get_type( void ); 
	extern GType vips_foreign_save_tiff_buffer_get_type( void ); 
	extern GType vips_foreign_load_raw_get_type( void ); 
	extern GType vips_foreign_save_raw_get_type( void ); 
	extern GType vips_foreign_save_raw_fd_get_type( void ); 
	extern GType vips_foreign_load_magick_file_get_type( void ); 
	extern GType vips_foreign_load_magick_buffer_get_type( void ); 
	extern GType vips_foreign_load_magick7_file_get_type( void ); 
	extern GType vips_foreign_load_magick7_buffer_get_type( void ); 
	extern GType vips_foreign_save_magick_file_get_type( void );
	extern GType vips_foreign_save_magick_buffer_get_type( void );
	extern GType vips_foreign_save_dz_file_get_type( void ); 
	extern GType vips_foreign_save_dz_buffer_get_type( void ); 
	extern GType vips_foreign_load_webp_file_get_type( void ); 
	extern GType vips_foreign_load_webp_buffer_get_type( void ); 
	extern GType vips_foreign_load_webp_source_get_type( void ); 
	extern GType vips_foreign_save_webp_file_get_type( void ); 
	extern GType vips_foreign_save_webp_buffer_get_type( void ); 
	extern GType vips_foreign_save_webp_target_get_type( void ); 
	extern GType vips_foreign_load_pdf_file_get_type( void ); 
	extern GType vips_foreign_load_pdf_buffer_get_type( void ); 
	extern GType vips_foreign_load_pdf_source_get_type( void ); 
	extern GType vips_foreign_load_svg_file_get_type( void ); 
	extern GType vips_foreign_load_svg_buffer_get_type( void ); 
	extern GType vips_foreign_load_svg_source_get_type( void ); 
	extern GType vips_foreign_load_jp2k_file_get_type( void ); 
	extern GType vips_foreign_load_jp2k_buffer_get_type( void ); 
	extern GType vips_foreign_load_jp2k_source_get_type( void ); 
	extern GType vips_foreign_save_jp2k_file_get_type( void ); 
	extern GType vips_foreign_save_jp2k_buffer_get_type( void ); 
	extern GType vips_foreign_save_jp2k_target_get_type( void ); 
	extern GType vips_foreign_load_jxl_file_get_type( void ); 
	extern GType vips_foreign_load_jxl_buffer_get_type( void ); 
	extern GType vips_foreign_load_jxl_source_get_type( void ); 
	extern GType vips_foreign_save_jxl_file_get_type( void ); 
	extern GType vips_foreign_save_jxl_buffer_get_type( void ); 
	extern GType vips_foreign_save_jxl_target_get_type( void ); 
	extern GType vips_foreign_load_heif_file_get_type( void ); 
	extern GType vips_foreign_load_heif_buffer_get_type( void ); 
	extern GType vips_foreign_load_heif_source_get_type( void ); 
	extern GType vips_foreign_save_heif_file_get_type( void ); 
	extern GType vips_foreign_save_heif_buffer_get_type( void ); 
	extern GType vips_foreign_save_heif_target_get_type( void ); 
	extern GType vips_foreign_load_nifti_file_get_type( void ); 
	extern GType vips_foreign_load_nifti_source_get_type( void ); 
	extern GType vips_foreign_save_nifti_get_type( void ); 
	extern GType vips_foreign_load_nsgif_file_get_type( void ); 
	extern GType vips_foreign_load_nsgif_buffer_get_type( void ); 
	extern GType vips_foreign_load_nsgif_source_get_type( void ); 
	extern GType vips_foreign_save_cgif_file_get_type( void );
	extern GType vips_foreign_save_cgif_buffer_get_type( void );
	extern GType vips_foreign_save_cgif_target_get_type( void );
	vips_foreign_load_csv_file_get_type(); 
	vips_foreign_load_csv_source_get_type(); 
	vips_foreign_save_csv_file_get_type(); 
	vips_foreign_save_csv_target_get_type(); 
	vips_foreign_load_matrix_file_get_type(); 
	vips_foreign_load_matrix_source_get_type(); 
	vips_foreign_save_matrix_file_get_type(); 
	vips_foreign_save_matrix_target_get_type(); 
	vips_foreign_print_matrix_get_type(); 
	vips_foreign_load_raw_get_type(); 
	vips_foreign_save_raw_get_type(); 
	vips_foreign_save_raw_fd_get_type(); 
	vips_foreign_load_vips_file_get_type(); 
	vips_foreign_load_vips_source_get_type(); 
	vips_foreign_save_vips_file_get_type(); 
	vips_foreign_save_vips_target_get_type(); 
#ifdef HAVE_ANALYZE
	vips_foreign_load_analyze_get_type(); 
#ifdef HAVE_PPM
	vips_foreign_load_ppm_file_get_type(); 
	vips_foreign_load_ppm_source_get_type(); 
	vips_foreign_save_ppm_file_get_type(); 
	vips_foreign_save_ppm_target_get_type(); 
#ifdef HAVE_RADIANCE
	vips_foreign_load_rad_file_get_type(); 
	vips_foreign_load_rad_buffer_get_type(); 
	vips_foreign_load_rad_source_get_type(); 
	vips_foreign_save_rad_file_get_type(); 
	vips_foreign_save_rad_buffer_get_type(); 
	vips_foreign_save_rad_target_get_type(); 
#if defined(HAVE_POPPLER) &amp;&amp; !defined(POPPLER_MODULE)
	vips_foreign_load_pdf_file_get_type(); 
	vips_foreign_load_pdf_buffer_get_type(); 
	vips_foreign_load_pdf_source_get_type(); 
#ifdef HAVE_PDFIUM
	vips_foreign_load_pdf_file_get_type(); 
	vips_foreign_load_pdf_buffer_get_type(); 
	vips_foreign_load_pdf_source_get_type(); 
#ifdef HAVE_RSVG
	vips_foreign_load_svg_file_get_type(); 
	vips_foreign_load_svg_buffer_get_type(); 
	vips_foreign_load_svg_source_get_type(); 
#if defined(HAVE_LIBJXL) &amp;&amp; !defined(LIBJXL_MODULE)
	vips_foreign_load_jxl_file_get_type(); 
	vips_foreign_load_jxl_buffer_get_type(); 
	vips_foreign_load_jxl_source_get_type(); 
	vips_foreign_save_jxl_file_get_type(); 
	vips_foreign_save_jxl_buffer_get_type(); 
	vips_foreign_save_jxl_target_get_type(); 
#ifdef HAVE_LIBOPENJP2
	vips_foreign_load_jp2k_file_get_type(); 
	vips_foreign_load_jp2k_buffer_get_type(); 
	vips_foreign_load_jp2k_source_get_type(); 
	vips_foreign_save_jp2k_file_get_type(); 
	vips_foreign_save_jp2k_buffer_get_type(); 
	vips_foreign_save_jp2k_target_get_type(); 
#ifdef HAVE_NSGIF
	vips_foreign_load_nsgif_file_get_type();
	vips_foreign_load_nsgif_buffer_get_type(); 
	vips_foreign_load_nsgif_source_get_type(); 
#ifdef HAVE_CGIF
	vips_foreign_save_cgif_file_get_type();
	vips_foreign_save_cgif_buffer_get_type();
	vips_foreign_save_cgif_target_get_type();
#ifdef HAVE_GSF
	vips_foreign_save_dz_file_get_type(); 
	vips_foreign_save_dz_buffer_get_type(); 
#ifdef HAVE_PNG
	vips_foreign_load_png_file_get_type(); 
	vips_foreign_load_png_buffer_get_type(); 
	vips_foreign_load_png_source_get_type(); 
	vips_foreign_save_png_file_get_type(); 
	vips_foreign_save_png_buffer_get_type(); 
	vips_foreign_save_png_target_get_type(); 
#ifdef HAVE_SPNG
	vips_foreign_load_png_file_get_type(); 
	vips_foreign_load_png_buffer_get_type(); 
	vips_foreign_load_png_source_get_type(); 
#ifdef HAVE_MATIO
	vips_foreign_load_mat_get_type(); 
#ifdef HAVE_JPEG
	vips_foreign_load_jpeg_file_get_type(); 
	vips_foreign_load_jpeg_buffer_get_type(); 
	vips_foreign_load_jpeg_source_get_type(); 
	vips_foreign_save_jpeg_file_get_type(); 
	vips_foreign_save_jpeg_buffer_get_type(); 
	vips_foreign_save_jpeg_target_get_type(); 
	vips_foreign_save_jpeg_mime_get_type(); 
#ifdef HAVE_LIBWEBP
	vips_foreign_load_webp_file_get_type(); 
	vips_foreign_load_webp_buffer_get_type(); 
	vips_foreign_load_webp_source_get_type(); 
	vips_foreign_save_webp_file_get_type(); 
	vips_foreign_save_webp_buffer_get_type(); 
	vips_foreign_save_webp_target_get_type(); 
#ifdef HAVE_TIFF
	vips_foreign_load_tiff_file_get_type(); 
	vips_foreign_load_tiff_buffer_get_type(); 
	vips_foreign_load_tiff_source_get_type(); 
	vips_foreign_save_tiff_file_get_type(); 
	vips_foreign_save_tiff_buffer_get_type(); 
#if defined(HAVE_OPENSLIDE) &amp;&amp; !defined(OPENSLIDE_MODULE)
	vips_foreign_load_openslide_file_get_type(); 
	vips_foreign_load_openslide_source_get_type(); 
#if defined(ENABLE_MAGICKLOAD) &amp;&amp; !defined(MAGICK_MODULE)
#ifdef HAVE_MAGICK6
	vips_foreign_load_magick_file_get_type();
	vips_foreign_load_magick_buffer_get_type();
#ifdef HAVE_MAGICK7
	vips_foreign_load_magick7_file_get_type();
	vips_foreign_load_magick7_buffer_get_type();
#if defined(ENABLE_MAGICKSAVE) &amp;&amp; !defined(MAGICK_MODULE)
	vips_foreign_save_magick_file_get_type();
	vips_foreign_save_magick_buffer_get_type();
#ifdef HAVE_CFITSIO
	vips_foreign_load_fits_file_get_type(); 
	vips_foreign_load_fits_source_get_type(); 
	vips_foreign_save_fits_get_type(); 
#ifdef HAVE_OPENEXR
	vips_foreign_load_openexr_get_type(); 
#ifdef HAVE_NIFTI
	vips_foreign_load_nifti_file_get_type(); 
	vips_foreign_load_nifti_source_get_type(); 
	vips_foreign_save_nifti_get_type(); 
#if defined(HAVE_HEIF_DECODER) &amp;&amp; !defined(HEIF_MODULE)
	vips_foreign_load_heif_file_get_type(); 
	vips_foreign_load_heif_buffer_get_type(); 
	vips_foreign_load_heif_source_get_type(); 
#if defined(HAVE_HEIF_ENCODER) &amp;&amp; !defined(HEIF_MODULE)
	vips_foreign_save_heif_file_get_type(); 
	vips_foreign_save_heif_buffer_get_type(); 
	vips_foreign_save_heif_target_get_type(); 
	vips__foreign_load_operation = 
		g_quark_from_static_string( "vips-foreign-load-operation" ); 
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
