<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for magick7load.c & foreign.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for magick7load.c & foreign.c
      </h3>
      <h1 align="center">
        3.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>magick7load.c (6.6115704%)<TH>foreign.c (2.3774145%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match26322-0.html#0',2,'match26322-1.html#0',3)" NAME="0">(807-825)<TD><A HREF="javascript:ZweiFrames('match26322-0.html#0',2,'match26322-1.html#0',3)" NAME="0">(1138-1154)</A><TD ALIGN=center><FONT COLOR="#ff0000">18</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match26322-0.html#1',2,'match26322-1.html#1',3)" NAME="1">(390-408)<TD><A HREF="javascript:ZweiFrames('match26322-0.html#1',2,'match26322-1.html#1',3)" NAME="1">(1247-1276)</A><TD ALIGN=center><FONT COLOR="#c60000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>magick7load.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* load with libMagick7
 *
 * 8/7/16
 * 	- from magickload
 * 25/11/16
 * 	- add @n, deprecate @all_frames (just sets n = -1)
 * 24/7/18
 * 	- sniff extra filetypes
 * 4/2/19
 * 	- add profile (xmp, ipct, etc.) read
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/buf.h&gt;
#include &lt;vips/internal.h&gt;

#ifdef ENABLE_MAGICKLOAD

#ifdef HAVE_MAGICK7

#include &lt;MagickCore/MagickCore.h&gt;

#include &quot;magick.h&quot;

typedef struct _VipsForeignLoadMagick7 {
	VipsForeignLoad parent_object;

	/* Deprecated. Just sets n = -1.
	 */
	gboolean all_frames;

	char *density;			/* Load at this resolution */
	int page;			/* Load this page (frame) */
	int n;				/* Load this many pages */

	Image *image;
	ImageInfo *image_info;
	ExceptionInfo *exception;

	/* Number of pages in image.
	 */
	int n_pages;

	int n_frames;			/* Number of frames we will read */
	Image **frames;			/* An Image* for each frame */
	CacheView **cache_view; 	/* A CacheView for each frame */
	int frame_height;	

	/* Mutex to serialise calls to libMagick during threaded read.
	 */
	GMutex *lock;

} VipsForeignLoadMagick7;

typedef VipsForeignLoadClass VipsForeignLoadMagick7Class;

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoadMagick7, vips_foreign_load_magick7, 
	VIPS_TYPE_FOREIGN_LOAD );

#ifdef DEBUG
static void
vips_magick7_print_traits( Image *image ) 
{
	static const int trait_bits[] = {
		CopyPixelTrait,
		UpdatePixelTrait,
		BlendPixelTrait
	};
	static const char *trait_names[] = {
		&quot;CopyPixelTrait&quot;,
		&quot;UpdatePixelTrait&quot;,
		&quot;BlendPixelTrait&quot;
	};

	int b; 
	int i; 

	printf( &quot;vips_magick7_print_traits: channel traits:\n&quot; ); 
	for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { 
		PixelChannel channel = 
			GetPixelChannelChannel( image, b ); 
		PixelTrait traits = 
			GetPixelChannelTraits( image, channel );
		
		printf( &quot;\t%d) &quot;, b ); 
		for( i = 0; i &lt; VIPS_NUMBER( trait_bits ); i++ )
			if( traits &amp; trait_bits[i] )
				printf( &quot;%s &quot;, trait_names[i] ); 
		if( traits == 0 )
			printf( &quot;undefined&quot; ); 
		printf( &quot;\n&quot; ); 
	} 
}

static void
vips_magick7_print_channel_names( Image *image )
{
	static const int pixel_channels[] = {
		UndefinedPixelChannel, 
		RedPixelChannel, 
		CyanPixelChannel, 
		GrayPixelChannel, 
		LPixelChannel, 
		LabelPixelChannel, 
		YPixelChannel, 
		aPixelChannel, 
		GreenPixelChannel, 
		MagentaPixelChannel, 
		CbPixelChannel, 
		bPixelChannel, 
		BluePixelChannel, 
		YellowPixelChannel, 
		CrPixelChannel, 
		BlackPixelChannel, 
		AlphaPixelChannel, 
		IndexPixelChannel, 
		ReadMaskPixelChannel, 
		WriteMaskPixelChannel, 
		MetaPixelChannel, 
		IntensityPixelChannel, 
		CompositePixelChannel, 
		SyncPixelChannel
	};
	static const char *pixel_channel_names[] = {
		&quot;UndefinedPixelChannel&quot;, 
		&quot;RedPixelChannel&quot;, 
		&quot;CyanPixelChannel&quot;, 
		&quot;GrayPixelChannel&quot;, 
		&quot;LPixelChannel&quot;, 
		&quot;LabelPixelChannel&quot;, 
		&quot;YPixelChannel&quot;, 
		&quot;aPixelChannel&quot;, 
		&quot;GreenPixelChannel&quot;, 
		&quot;MagentaPixelChannel&quot;, 
		&quot;CbPixelChannel&quot;, 
		&quot;bPixelChannel&quot;, 
		&quot;BluePixelChannel&quot;, 
		&quot;YellowPixelChannel&quot;, 
		&quot;CrPixelChannel&quot;, 
		&quot;BlackPixelChannel&quot;, 
		&quot;AlphaPixelChannel&quot;, 
		&quot;IndexPixelChannel&quot;, 
		&quot;ReadMaskPixelChannel&quot;, 
		&quot;WriteMaskPixelChannel&quot;, 
		&quot;MetaPixelChannel&quot;, 
		&quot;IntensityPixelChannel&quot;, 
		&quot;CompositePixelChannel&quot;, 
		&quot;SyncPixelChannel&quot;, 
	};

	int b; 
	int i; 

	printf( &quot;vips_magick7_print_channel_names: channel names:\n&quot; ); 
	for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { 
		PixelChannel channel = 
			GetPixelChannelChannel( image, b ); 
		
		printf( &quot;\t%d) &quot;, b ); 
		for( i = 0; i &lt; VIPS_NUMBER( pixel_channels ); i++ )
			/* Don't break on found, many channel names repeat.
			 */
			if( channel == pixel_channels[i] ) 
				printf( &quot;%s &quot;, pixel_channel_names[i] );
		printf( &quot;\n&quot; ); 
	} 
}

static void
vips_magick7_print_image_type( Image *image )
{
	static const int image_types[] = {
		UndefinedType,
		BilevelType,
		GrayscaleType,
		GrayscaleAlphaType, 
		PaletteType,
		PaletteAlphaType,
		TrueColorType,
		TrueColorAlphaType,
		ColorSeparationType,
		ColorSeparationAlphaType,
		OptimizeType,
		PaletteBilevelAlphaType
	};

	static const char *image_type_names[] = {
		&quot;UndefinedType&quot;,
		&quot;BilevelType&quot;,
		&quot;GrayscaleType&quot;,
		&quot;GrayscaleAlphaType&quot;, 
		&quot;PaletteType&quot;,
		&quot;PaletteAlphaType&quot;,
		&quot;TrueColorType&quot;,
		&quot;TrueColorAlphaType&quot;,
		&quot;ColorSeparationType&quot;,
		&quot;ColorSeparationAlphaType&quot;,
		&quot;OptimizeType&quot;,
		&quot;PaletteBilevelAlphaType&quot;
	};

	int i;

	for( i = 0; i &lt; VIPS_NUMBER( image_types ); i++ ) 
		if( GetImageType( image ) == image_types[i] ) {
			printf( &quot;\t%s\n&quot;, image_type_names[i] );
			break;
		}
	if( i == VIPS_NUMBER( image_types ) )
		printf( &quot;\tunknown GetImageType()\n&quot; ); 
}
#endif /*DEBUG*/

static VipsForeignFlags
vips_foreign_load_magick7_get_flags_filename( const char *filename )
{
	return( VIPS_FOREIGN_PARTIAL );
}

static VipsForeignFlags
vips_foreign_load_magick7_get_flags( VipsForeignLoad *load )
{
	return( VIPS_FOREIGN_PARTIAL );
}

static void
vips_foreign_load_magick7_dispose( GObject *gobject )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) gobject;

	int i;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_magick7_dispose: %p\n&quot;, gobject ); 
#endif /*DEBUG*/

	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
		VIPS_FREEF( DestroyCacheView, magick7-&gt;cache_view[i] ); 
	}
	VIPS_FREEF( DestroyImageList, magick7-&gt;image );
	VIPS_FREEF( DestroyImageInfo, magick7-&gt;image_info ); 
	VIPS_FREE( magick7-&gt;frames );
	VIPS_FREE( magick7-&gt;cache_view );
	VIPS_FREEF( magick_destroy_exception, magick7-&gt;exception ); 
	VIPS_FREEF( vips_g_mutex_free, magick7-&gt;lock );

	G_OBJECT_CLASS( vips_foreign_load_magick7_parent_class )-&gt;
		dispose( gobject );
}

static int
vips_foreign_load_magick7_build( VipsObject *object )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) object;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_magick7_build: %p\n&quot;, object ); 
#endif /*DEBUG*/

	magick_genesis();

	magick7-&gt;image_info = CloneImageInfo( NULL );
	magick7-&gt;exception = magick_acquire_exception();
	magick7-&gt;lock = vips_g_mutex_new();

	if( !magick7-&gt;image_info ) 
		return( -1 );

	if( magick7-&gt;all_frames )
		magick7-&gt;n = -1;

	/* Canvas resolution for rendering vector formats like SVG.
	 */
	VIPS_SETSTR( magick7-&gt;image_info-&gt;density, magick7-&gt;density );

	/* When reading DICOM images, we want to ignore any
	 * window_center/_width setting, since it may put pixels outside the
	 * 0-65535 range and lose data. 
	 *
	 * These window settings are attached as vips metadata, so our caller
	 * can interpret them if it wants.
	 */
  	magick_set_image_option( magick7-&gt;image_info, 
		&quot;dcm:display-range&quot;, &quot;reset&quot; );

	if( magick7-&gt;page &gt; 0 ) 
		magick_set_number_scenes( magick7-&gt;image_info,
			magick7-&gt;page, magick7-&gt;n );

	if( VIPS_OBJECT_CLASS( vips_foreign_load_magick7_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_magick7_class_init( VipsForeignLoadMagick7Class *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;dispose = vips_foreign_load_magick7_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;magickload_base&quot;;
	object_class-&gt;description = _( &quot;load with ImageMagick7&quot; );
	object_class-&gt;build = vips_foreign_load_magick7_build;

	/* We need to be well to the back of the queue since vips's
	 * dedicated loaders are usually preferable.
	 */
	foreign_class-&gt;priority = -100;

	load_class-&gt;get_flags_filename = 
		vips_foreign_load_magick7_get_flags_filename;
	load_class-&gt;get_flags = vips_foreign_load_magick7_get_flags;

	VIPS_ARG_STRING( class, &quot;density&quot;, 20,
		_( &quot;Density&quot; ),
		_( &quot;Canvas resolution for rendering vector formats like SVG&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadMagick7, density ),
		NULL );

	VIPS_ARG_INT( class, &quot;page&quot;, 21,
		_( &quot;Page&quot; ),
		_( &quot;Load this page from the file&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadMagick7, page ),
		0, 100000, 0 );

	VIPS_ARG_INT( class, &quot;n&quot;, 22,
		_( &quot;n&quot; ),
		_( &quot;Load this many pages&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoadMagick7, n ),
		-1, 100000, 1 );

	VIPS_ARG_BOOL( class, &quot;all_frames&quot;, 23, 
		_( &quot;all_frames&quot; ), 
		_( &quot;Read all frames from an image&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
<A NAME="1"></A>		G_STRUCT_OFFSET( VipsForeignLoadMagick7, all_frames ),
		FALSE );

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match26322-1.html#1',3,'match26322-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

static void
vips_foreign_load_magick7_init( VipsForeignLoadMagick7 *magick7 )
{
	magick7-&gt;n = 1;
}

static void
vips_foreign_load_magick7_error( VipsForeignLoadMagick7 *magick7 )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( magick7 );

	vips_error( class-&gt;nickname, _( &quot;Magick: %s %s&quot; ),
		magick7-&gt;exception-&gt;reason, 
		magick7-&gt;exception-&gt;description );
}

static int</B></FONT>
magick7_get_bands( Image *image )
{
	int bands;
	int i;

	/* We skip all index channels. Lots of images can have these, it's not
	 * just the palette ones.
	 */
	bands = 0;
	for( i = 0; i &lt; GetPixelChannels( image ); i++ ) { 
		PixelChannel channel = GetPixelChannelChannel( image, i ); 

		if( channel != IndexPixelChannel ) 
			bands += 1;
	} 

	return( bands );
}

static int
vips_foreign_load_magick7_parse( VipsForeignLoadMagick7 *magick7, 
	Image *image, VipsImage *out )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( magick7 );

	const char *key;
	Image *p;

#ifdef DEBUG
	printf( &quot;image-&gt;depth = %zd\n&quot;, image-&gt;depth ); 
	printf( &quot;GetImageType() = %d\n&quot;, GetImageType( image ) );
	vips_magick7_print_image_type( image ); 
	printf( &quot;GetPixelChannels() = %zd\n&quot;, GetPixelChannels( image ) ); 
	printf( &quot;image-&gt;columns = %zd\n&quot;, image-&gt;columns ); 
	printf( &quot;image-&gt;rows = %zd\n&quot;, image-&gt;rows ); 
#endif /*DEBUG*/

	/* Ysize updated below once we have worked out how many frames to load.
	 */
	out-&gt;Xsize = image-&gt;columns;
	out-&gt;Ysize = image-&gt;rows;
	magick7-&gt;frame_height = image-&gt;rows;
	out-&gt;Bands = magick7_get_bands( image ); 
	if( out-&gt;Xsize &lt;= 0 ||
		out-&gt;Ysize &lt;= 0 ||
		out-&gt;Bands &lt;= 0 ||
		out-&gt;Xsize &gt;= VIPS_MAX_COORD ||
		out-&gt;Ysize &gt;= VIPS_MAX_COORD ||
		out-&gt;Bands &gt;= VIPS_MAX_COORD ) {
		vips_error( class-&gt;nickname, 
			_( &quot;bad image dimensions %d x %d pixels, %d bands&quot; ),
			out-&gt;Xsize, out-&gt;Ysize, out-&gt;Bands );
		return( -1 );
	}

	/* Depth can be 'fractional'. You'd think we should use
	 * GetImageDepth() but that seems to compute something very complex. 
	 */
	out-&gt;BandFmt = -1;
	if( image-&gt;depth &gt;= 1 &amp;&amp; image-&gt;depth &lt;= 8 ) 
		out-&gt;BandFmt = VIPS_FORMAT_UCHAR;
	if( image-&gt;depth &gt;= 9 &amp;&amp; image-&gt;depth &lt;= 16 ) 
		out-&gt;BandFmt = VIPS_FORMAT_USHORT;
	if( image-&gt;depth == 32 )
		out-&gt;BandFmt = VIPS_FORMAT_FLOAT;
	if( image-&gt;depth == 64 )
		out-&gt;BandFmt = VIPS_FORMAT_DOUBLE;

	if( out-&gt;BandFmt == -1 ) {
		vips_error( class-&gt;nickname, 
			_( &quot;unsupported bit depth %zd&quot; ), image-&gt;depth );
		return( -1 );
	}

	switch( image-&gt;colorspace ) {
	case GRAYColorspace:
		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
			out-&gt;Type = VIPS_INTERPRETATION_GREY16;
		else
			out-&gt;Type = VIPS_INTERPRETATION_B_W;
		break;

	case sRGBColorspace:
	case RGBColorspace:
		if( out-&gt;BandFmt == VIPS_FORMAT_USHORT )
			out-&gt;Type = VIPS_INTERPRETATION_RGB16;
		else
			out-&gt;Type = VIPS_INTERPRETATION_sRGB;
		break;

	case CMYKColorspace:
		out-&gt;Type = VIPS_INTERPRETATION_CMYK;
		break;

	default:
		vips_error( class-&gt;nickname, 
			_( &quot;unsupported colorspace %s&quot; ), 
			magick_ColorspaceType2str( image-&gt;colorspace ) );
		return( -1 );
	}

	switch( image-&gt;units ) {
	case PixelsPerInchResolution:
		out-&gt;Xres = image-&gt;resolution.x / 25.4;
		out-&gt;Yres = image-&gt;resolution.y / 25.4;
		vips_image_set_string( out, VIPS_META_RESOLUTION_UNIT, &quot;in&quot; );
		break;

	case PixelsPerCentimeterResolution:
		out-&gt;Xres = image-&gt;resolution.x / 10.0;
		out-&gt;Yres = image-&gt;resolution.y / 10.0;
		vips_image_set_string( out, VIPS_META_RESOLUTION_UNIT, &quot;cm&quot; );
		break;

	default:
		/* Things like GIF have no resolution info.
		 */
		out-&gt;Xres = 1.0;
		out-&gt;Yres = 1.0;
		break;
	}

	/* Other fields.
	 */
	out-&gt;Coding = VIPS_CODING_NONE;

	if( vips_image_pipelinev( out, VIPS_DEMAND_STYLE_SMALLTILE, NULL ) )
		return( -1 );

	/* Get all the string metadata.
	 */
	ResetImagePropertyIterator( image );
	while( (key = GetNextImageProperty( image )) ) {
		char name_text[256];
		VipsBuf name = VIPS_BUF_STATIC( name_text );
		const char *value;

		value = GetImageProperty( image, key, magick7-&gt;exception );
		if( !value ) {
			vips_foreign_load_magick7_error( magick7 );
			return( -1 ); 
		}
		vips_buf_appendf( &amp;name, &quot;magick-%s&quot;, key );
		vips_image_set_string( out, vips_buf_all( &amp;name ), value );
	}

	/* Set vips metadata from ImageMagick profiles.
	 */
	if( magick_set_vips_profile( out, image ) )
		return( -1 );

	magick7-&gt;n_pages = GetImageListLength( GetFirstImageInList( image ) );
#ifdef DEBUG
	printf( &quot;image has %d pages\n&quot;, magick7-&gt;n_pages );
#endif /*DEBUG*/

	/* Do we have a set of equal-sized frames? Append them.

	   	FIXME ... there must be an attribute somewhere from dicom read 
		which says this is a volumetric image

	 */
	magick7-&gt;n_frames = 0;
	for( p = image; p; (p = GetNextImageInList( p )) ) {
		if( p-&gt;columns != (unsigned int) out-&gt;Xsize ||
			p-&gt;rows != (unsigned int) out-&gt;Ysize ||
			magick7_get_bands( p ) != out-&gt;Bands ||
			p-&gt;depth != image-&gt;depth ) {
#ifdef DEBUG
			printf( &quot;frame %d differs\n&quot;, magick7-&gt;n_frames );
			printf( &quot;%zdx%zd, %d bands\n&quot;, 
				p-&gt;columns, p-&gt;rows, magick7_get_bands( p ) );
			printf( &quot;first frame is %dx%d, %d bands\n&quot;, 
				out-&gt;Xsize, out-&gt;Ysize, out-&gt;Bands );
#endif /*DEBUG*/

			break;
		}

		magick7-&gt;n_frames += 1;
	}
	if( p ) 
		/* Nope ... just do the first image in the list.
		 */
		magick7-&gt;n_frames = 1;

#ifdef DEBUG
	printf( &quot;will read %d frames\n&quot;, magick7-&gt;n_frames );
#endif /*DEBUG*/

	if( magick7-&gt;n != -1 )
		magick7-&gt;n_frames = VIPS_MIN( magick7-&gt;n_frames, magick7-&gt;n );

	/* So we can finally set the height.
	 */
	if( vips_object_argument_isset( VIPS_OBJECT( magick7 ), &quot;n&quot; ) ) {
		vips_image_set_int( out, VIPS_META_PAGE_HEIGHT, out-&gt;Ysize );
		out-&gt;Ysize *= magick7-&gt;n_frames;
	}

	vips_image_set_int( out, VIPS_META_N_PAGES, magick7-&gt;n_pages );

	return( 0 );
}

/* We don't bother with GetPixelReadMask(), assume it's everywhere. Don't
 * bother with traits, assume that's always updated.
 *
 * We do skip index channels. Palette images add extra index channels
 * containing the index value from the file before colourmap lookup.
 */
#define UNPACK( TYPE ) { \
	TYPE * restrict tq = (TYPE *) q; \
	int x; \
	int b; \
	\
	for( x = 0; x &lt; r-&gt;width; x++ ) { \
		for( b = 0; b &lt; GetPixelChannels( image ); b++ ) { \
			PixelChannel channel = \
				GetPixelChannelChannel( image, b ); \
			\
			if( channel != IndexPixelChannel ) \
				*tq++ = p[b]; \
		} \
		\
		p += GetPixelChannels( image ); \
	} \
}

static int
vips_foreign_load_magick7_fill_region( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) a;
	VipsRect *r = &amp;or-&gt;valid;
	VipsImage *im = or-&gt;im;

	int y;

	for( y = 0; y &lt; r-&gt;height; y++ ) {
		int top = r-&gt;top + y;
		int frame = top / magick7-&gt;frame_height;
		int line = top % magick7-&gt;frame_height;
		Image *image = magick7-&gt;frames[frame];

		Quantum * restrict p;
		VipsPel * restrict q;

		g_mutex_lock( magick7-&gt;lock );
		p = GetCacheViewAuthenticPixels( magick7-&gt;cache_view[frame],
			r-&gt;left, line, r-&gt;width, 1, 
			magick7-&gt;exception );
		g_mutex_unlock( magick7-&gt;lock );

		if( !p ) 
			/* This can happen if, for example, some frames of a
			 * gif are shorter than others. It's not always
			 * an error.
			 */
			continue;

		q = VIPS_REGION_ADDR( or, r-&gt;left, top ); 

		switch( im-&gt;BandFmt ) {
		case VIPS_FORMAT_UCHAR:
			UNPACK( unsigned char ); 
			break;

		case VIPS_FORMAT_USHORT:
			UNPACK( unsigned short ); 
			break;

		case VIPS_FORMAT_FLOAT:
			UNPACK( float ); 
			break;

		case VIPS_FORMAT_DOUBLE:
			UNPACK( double ); 
			break;

		default:
			g_assert_not_reached();
		}
	}

	return( 0 );
}

static int
vips_foreign_load_magick7_load( VipsForeignLoadMagick7 *magick7 )
{
	VipsForeignLoad *load = (VipsForeignLoad *) magick7;

	Image *p;
	int i;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_magick7_load: %p\n&quot;, magick7 ); 
#endif /*DEBUG*/

	if( vips_foreign_load_magick7_parse( magick7, 
		magick7-&gt;image, load-&gt;out ) )
		return( -1 );

	/* Record frame pointers.
	 */
	g_assert( !magick7-&gt;frames ); 
	if( !(magick7-&gt;frames = 
		VIPS_ARRAY( NULL, magick7-&gt;n_frames, Image * )) )
		return( -1 );
	p = magick7-&gt;image;
	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
		magick7-&gt;frames[i] = p;
		p = GetNextImageInList( p );
	}

	/* And a cache_view for each frame.
	 */
	g_assert( !magick7-&gt;cache_view ); 
	if( !(magick7-&gt;cache_view = VIPS_ARRAY( NULL, 
		magick7-&gt;n_frames, CacheView * )) )
		return( -1 );
	for( i = 0; i &lt; magick7-&gt;n_frames; i++ ) {
		magick7-&gt;cache_view[i] = AcquireAuthenticCacheView( 
			magick7-&gt;frames[i], magick7-&gt;exception );
	}

#ifdef DEBUG
	/* Only display the traits from frame0, they should all be the same.
	 */
	vips_magick7_print_traits( magick7-&gt;frames[0] ); 
	vips_magick7_print_channel_names( magick7-&gt;frames[0] );
#endif /*DEBUG*/

	if( vips_image_generate( load-&gt;out, 
		NULL, vips_foreign_load_magick7_fill_region, NULL, 
		magick7, NULL ) )
		return( -1 );

	return( 0 );
}

typedef struct _VipsForeignLoadMagick7File {
	VipsForeignLoadMagick7 parent_object;

	char *filename; 

} VipsForeignLoadMagick7File;

typedef VipsForeignLoadMagick7Class VipsForeignLoadMagick7FileClass;

G_DEFINE_TYPE( VipsForeignLoadMagick7File, vips_foreign_load_magick7_file, 
	vips_foreign_load_magick7_get_type() );

static gboolean
ismagick7( const char *filename )
{
	/* Fetch up to the first 100 bytes. Hopefully that'll be enough.
	 */
	unsigned char buf[100];
	int len;

	return( (len = vips__get_bytes( filename, buf, 100 )) &gt; 10 &amp;&amp;
		magick_ismagick( buf, len ) );
}

static int
vips_foreign_load_magick7_file_header( VipsForeignLoad *load )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) load;
	VipsForeignLoadMagick7File *file = (VipsForeignLoadMagick7File *) load;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_magick7_file_header: %p\n&quot;, load ); 
#endif /*DEBUG*/

	vips_strncpy( magick7-&gt;image_info-&gt;filename, file-&gt;filename, 
		MagickPathExtent );

	magick_sniff_file( magick7-&gt;image_info, file-&gt;filename );

	/* It would be great if we could PingImage and just read the header,
	 * but sadly many IM coders do not support ping. The critical one for
	 * us is DICOM.
	 * 
	 * We have to read the whole image in _header.
	 */
	magick7-&gt;image = ReadImage( magick7-&gt;image_info, magick7-&gt;exception );
	if( !magick7-&gt;image ) {
		vips_foreign_load_magick7_error( magick7 ); 
		return( -1 );
	}

	if( vips_foreign_load_magick7_load( magick7 ) )
		return( -1 );
<A NAME="0"></A>
	VIPS_SETSTR( load-&gt;out-&gt;filename, file-&gt;filename );

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match26322-1.html#0',3,'match26322-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( 0 );
}

static void
vips_foreign_load_magick7_file_class_init( 
	VipsForeignLoadMagick7FileClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;magickload&quot;;
	object_class-&gt;description = _( &quot;load file with ImageMagick7&quot; );

	load_class-&gt;is_a = ismagick7;
	load_class-&gt;header = vips_foreign_load_magick7_file_header;</B></FONT>

	VIPS_ARG_STRING( class, &quot;filename&quot;, 1, 
		_( &quot;Filename&quot; ),
		_( &quot;Filename to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadMagick7File, filename ),
		NULL );

}

static void
vips_foreign_load_magick7_file_init( VipsForeignLoadMagick7File *magick7_file )
{
}

typedef struct _VipsForeignLoadMagick7Buffer {
	VipsForeignLoadMagick7 parent_object;

	VipsArea *buf;

} VipsForeignLoadMagick7Buffer;

typedef VipsForeignLoadMagick7Class VipsForeignLoadMagick7BufferClass;

G_DEFINE_TYPE( VipsForeignLoadMagick7Buffer, vips_foreign_load_magick7_buffer, 
	vips_foreign_load_magick7_get_type() );

static gboolean
vips_foreign_load_magick7_buffer_is_a_buffer( const void *buf, size_t len )
{
	return( len &gt; 10 &amp;&amp; magick_ismagick( (const unsigned char *) buf, len ) );
}

static int
vips_foreign_load_magick7_buffer_header( VipsForeignLoad *load )
{
	VipsForeignLoadMagick7 *magick7 = (VipsForeignLoadMagick7 *) load;
	VipsForeignLoadMagick7Buffer *magick7_buffer = 
		(VipsForeignLoadMagick7Buffer *) load;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_magick7_buffer_header: %p\n&quot;, load ); 
#endif /*DEBUG*/

	/* It would be great if we could PingBlob and just read the header,
	 * but sadly many IM coders do not support ping. The critical one for
	 * us is DICOM.
	 * 
	 * We have to read the whole image in _header.
	 */
	magick_sniff_bytes( magick7-&gt;image_info, 
		magick7_buffer-&gt;buf-&gt;data, magick7_buffer-&gt;buf-&gt;length );
	magick7-&gt;image = BlobToImage( magick7-&gt;image_info, 
		magick7_buffer-&gt;buf-&gt;data, magick7_buffer-&gt;buf-&gt;length,
		magick7-&gt;exception );
	if( !magick7-&gt;image ) {
		vips_foreign_load_magick7_error( magick7 ); 
		return( -1 );
	}

	if( vips_foreign_load_magick7_load( magick7 ) )
		return( -1 );

	return( 0 );
}

static void
vips_foreign_load_magick7_buffer_class_init( 
	VipsForeignLoadMagick7BufferClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;magickload_buffer&quot;;
	object_class-&gt;description = _( &quot;load buffer with ImageMagick7&quot; );

	load_class-&gt;is_a_buffer = vips_foreign_load_magick7_buffer_is_a_buffer;
	load_class-&gt;header = vips_foreign_load_magick7_buffer_header;

	VIPS_ARG_BOXED( class, &quot;buffer&quot;, 1, 
		_( &quot;Buffer&quot; ),
		_( &quot;Buffer to load from&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsForeignLoadMagick7Buffer, buf ),
		VIPS_TYPE_BLOB );

}

static void
vips_foreign_load_magick7_buffer_init( VipsForeignLoadMagick7Buffer *buffer )
{
}

#endif /*HAVE_MAGICK7*/

#endif /*ENABLE_MAGICKLOAD*/
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>foreign.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* foreign file formats base class
 *
 * 7/2/12
 * 	- add support for sequential reads
 * 18/6/12
 * 	- flatten alpha with vips_flatten()
 * 28/5/13
 * 	- auto rshift down to 8 bits during save
 * 19/1/14
 * 	- pack and unpack rad to scrgb
 * 18/8/14
 * 	- fix conversion to 16-bit RGB, thanks John
 * 18/6/15
 * 	- forward progress signals from load
 * 23/5/16
 * 	- remove max-alpha stuff, this is now automatic
 * 12/6/17
 * 	- transform cmyk-&gt;rgb if there's an embedded profile
 * 16/6/17
 * 	- add page_height
 * 1/1/18
 * 	- META_SEQ support moved here
 * 5/3/18
 * 	- block _start if one start fails, see #893
 * 1/4/18
 * 	- drop incompatible ICC profiles before save
 */

/*

    This file is part of VIPS.

    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

/*
#define DEBUG
 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/debug.h&gt;

#include &quot;pforeign.h&quot;

/**
 * SECTION: foreign
 * @short_description: load and save images in a variety of formats
 * @stability: Stable
 * @see_also: &lt;link linkend=&quot;libvips-image&quot;&gt;image&lt;/link&gt;
 * @include: vips/vips.h
 * @title: VipsForeign
 *
 * This set of operations load and save images in a variety of formats. 
 *
 * The operations share a base class that offers a simple way to search for a
 * subclass of #VipsForeign which can load a certain file (see
 * vips_foreign_find_load()) or buffer (see vips_foreign_find_load_buffer()), 
 * or which could be used to save an image to a
 * certain file type (see vips_foreign_find_save() and
 * vips_foreign_find_save_buffer()). You can then run these
 * operations using vips_call() and friends to perform the load or save.
 *
 * vips_image_write_to_file() and vips_image_new_from_file() and friends use
 * these functions to automate file load and save. 
 *
 * You can also invoke the operations directly, for example:
 *
 * |[
 * vips_tiffsave (my_image, &quot;frank.anything&quot;, 
 *     &quot;compression&quot;, VIPS_FOREIGN_TIFF_COMPRESSION_JPEG,
 *     NULL);
 * ]|
 *
 * To add support for a new file format to vips, simply define a new subclass
 * of #VipsForeignLoad or #VipsForeignSave. 
 *
 * If you define a new operation which is a subclass of #VipsForeign, support 
 * for it automatically appears in all VIPS user-interfaces. It will also be
 * transparently supported by vips_image_new_from_file() and friends.
 *
 * VIPS comes with VipsForeign for TIFF, JPEG, PNG, Analyze, PPM, OpenEXR, CSV,
 * Matlab, Radiance, RAW, FITS, WebP, SVG, PDF, GIF and VIPS. It also includes 
 * import filters which can load with libMagick and with OpenSlide. 
 *
 * ## Writing a new loader
 *
 * Add a new loader to VIPS by subclassing #VipsForeignLoad. Subclasses need to 
 * implement at least @header().
 *
 * @header() must set at least the header fields of @out. @load(), if defined,
 * must load the pixels to @real.
 *
 * The suffix list is used to select a format to save a file in, and to pick a
 * loader if you don't define is_a().
 *
 * You should also define @nickname and @description in #VipsObject. 
 *
 * As a complete example, here's code for a PNG loader, minus the actual
 * calls to libpng.
 *
 * |[
 * typedef struct _VipsForeignLoadPng {
 *   VipsForeignLoad parent_object;
 * 
 *   char *filename; 
 * } VipsForeignLoadPng;
 * 
 * typedef VipsForeignLoadClass VipsForeignLoadPngClass;
 * 
 * G_DEFINE_TYPE( VipsForeignLoadPng, vips_foreign_load_png, 
 *   VIPS_TYPE_FOREIGN_LOAD );
 * 
 * static VipsForeignFlags
 * vips_foreign_load_png_get_flags_filename( const char *filename )
 * {
 *   VipsForeignFlags flags;
 * 
 *   flags = 0;
 *   if( vips__png_isinterlaced( filename ) )
 *   	flags = VIPS_FOREIGN_PARTIAL;
 *   else
 *   	flags = VIPS_FOREIGN_SEQUENTIAL;
 * 
 *   return( flags );
 * }
 * 
 * static VipsForeignFlags
 * vips_foreign_load_png_get_flags( VipsForeignLoad *load )
 * {
 *   VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
 * 
 *   return( vips_foreign_load_png_get_flags_filename( png-&gt;filename ) );
 * }
 * 
 * static int
 * vips_foreign_load_png_header( VipsForeignLoad *load )
 * {
 *   VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
 * 
 *   if( vips__png_header( png-&gt;filename, load-&gt;out ) )
 *   	return( -1 );
 * 
 *   return( 0 );
 * }
 * 
 * static int
 * vips_foreign_load_png_load( VipsForeignLoad *load )
 * {
 *   VipsForeignLoadPng *png = (VipsForeignLoadPng *) load;
 * 
 *   if( vips__png_read( png-&gt;filename, load-&gt;real ) )
 *   	return( -1 );
 * 
 *   return( 0 );
 * }
 * 
 * static void
 * vips_foreign_load_png_class_init( VipsForeignLoadPngClass *class )
 * {
 *   GObjectClass *gobject_class = G_OBJECT_CLASS( class );
 *   VipsObjectClass *object_class = (VipsObjectClass *) class;
 *   VipsForeignClass *foreign_class = (VipsForeignClass *) class;
 *   VipsForeignLoadClass *load_class = (VipsForeignLoadClass *) class;
 * 
 *   gobject_class-&gt;set_property = vips_object_set_property;
 *   gobject_class-&gt;get_property = vips_object_get_property;
 * 
 *   object_class-&gt;nickname = &quot;pngload&quot;;
 *   object_class-&gt;description = _( &quot;load png from file&quot; );
 * 
 *   foreign_class-&gt;suffs = vips__png_suffs;
 * 
 *   load_class-&gt;is_a = vips__png_ispng;
 *   load_class-&gt;get_flags_filename = 
 *   	vips_foreign_load_png_get_flags_filename;
 *   load_class-&gt;get_flags = vips_foreign_load_png_get_flags;
 *   load_class-&gt;header = vips_foreign_load_png_header;
 *   load_class-&gt;load = vips_foreign_load_png_load;
 * 
 *   VIPS_ARG_STRING( class, &quot;filename&quot;, 1, 
 *   	_( &quot;Filename&quot; ),
 *   	_( &quot;Filename to load from&quot; ),
 *   	VIPS_ARGUMENT_REQUIRED_INPUT, 
 *   	G_STRUCT_OFFSET( VipsForeignLoadPng, filename ),
 *   	NULL );
 * }
 * 
 * static void
 * vips_foreign_load_png_init( VipsForeignLoadPng *png )
 * {
 * }
 * ]|
 * 
 * ## Writing a new saver
 *
 * Call your saver in the class' @build() method after chaining up. The
 * prepared image should be ready for you to save in @ready.  
 *
 * As a complete example, here's the code for the CSV saver, minus the calls
 * to the actual save routines.
 *
 * |[
 * typedef struct _VipsForeignSaveCsv {
 *   VipsForeignSave parent_object;
 * 
 *   char *filename; 
 *   const char *separator;
 * } VipsForeignSaveCsv;
 * 
 * typedef VipsForeignSaveClass VipsForeignSaveCsvClass;
 * 
 * G_DEFINE_TYPE( VipsForeignSaveCsv, vips_foreign_save_csv, 
 *   VIPS_TYPE_FOREIGN_SAVE );
 * 
 * static int
 * vips_foreign_save_csv_build( VipsObject *object )
 * {
 *   VipsForeignSave *save = (VipsForeignSave *) object;
 *   VipsForeignSaveCsv *csv = (VipsForeignSaveCsv *) object;
 * 
 *   if( VIPS_OBJECT_CLASS( vips_foreign_save_csv_parent_class )-&gt;
 *   	build( object ) )
 *   	return( -1 );
 * 
 *   if( vips__csv_write( save-&gt;ready, csv-&gt;filename, csv-&gt;separator ) )
 *   	return( -1 );
 * 
 *   return( 0 );
 * }
 * 
 * static void
 * vips_foreign_save_csv_class_init( VipsForeignSaveCsvClass *class )
 * {
 *   GObjectClass *gobject_class = G_OBJECT_CLASS( class );
 *   VipsObjectClass *object_class = (VipsObjectClass *) class;
 *   VipsForeignClass *foreign_class = (VipsForeignClass *) class;
 *   VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
 * 
 *   gobject_class-&gt;set_property = vips_object_set_property;
 *   gobject_class-&gt;get_property = vips_object_get_property;
 * 
 *   object_class-&gt;nickname = &quot;csvsave&quot;;
 *   object_class-&gt;description = _( &quot;save image to csv file&quot; );
 *   object_class-&gt;build = vips_foreign_save_csv_build;
 * 
 *   foreign_class-&gt;suffs = vips__foreign_csv_suffs;
 * 
 *   save_class-&gt;saveable = VIPS_SAVEABLE_MONO;
 *   // no need to define -&gt;format_table, we don't want the input 
 *   // cast for us
 * 
 *   VIPS_ARG_STRING( class, &quot;filename&quot;, 1, 
 *   	_( &quot;Filename&quot; ),
 *   	_( &quot;Filename to save to&quot; ),
 *   	VIPS_ARGUMENT_REQUIRED_INPUT, 
 *   	G_STRUCT_OFFSET( VipsForeignSaveCsv, filename ),
 *   	NULL );
 * 
 *   VIPS_ARG_STRING( class, &quot;separator&quot;, 13, 
 *   	_( &quot;Separator&quot; ), 
 *   	_( &quot;Separator characters&quot; ),
 *   	VIPS_ARGUMENT_OPTIONAL_INPUT,
 *   	G_STRUCT_OFFSET( VipsForeignSaveCsv, separator ),
 *   	&quot;\t&quot; ); 
 * }
 * 
 * static void
 * vips_foreign_save_csv_init( VipsForeignSaveCsv *csv )
 * {
 *   csv-&gt;separator = g_strdup( &quot;\t&quot; );
 * }
 * ]|
 */

/* Use this to link images to the load operation that made them. 
 */
static GQuark vips__foreign_load_operation = 0; 

/**
 * VipsForeignFlags: 
 * @VIPS_FOREIGN_NONE: no flags set
 * @VIPS_FOREIGN_PARTIAL: the image may be read lazilly
 * @VIPS_FOREIGN_BIGENDIAN: image pixels are most-significant byte first
 * @VIPS_FOREIGN_SEQUENTIAL: top-to-bottom lazy reading
 *
 * Some hints about the image loader.
 *
 * #VIPS_FOREIGN_PARTIAL means that the image can be read directly from the
 * file without needing to be unpacked to a temporary image first. 
 *
 * #VIPS_FOREIGN_SEQUENTIAL means that the loader supports lazy reading, but
 * only top-to-bottom (sequential) access. Formats like PNG can read sets of
 * scanlines, for example, but only in order. 
 *
 * If neither PARTIAL or SEQUENTIAL is set, the loader only supports whole
 * image read. Setting both PARTIAL and SEQUENTIAL is an error.
 *
 * #VIPS_FOREIGN_BIGENDIAN means that image pixels are most-significant byte
 * first. Depending on the native byte order of the host machine, you may
 * need to swap bytes. See vips_copy().
 */

G_DEFINE_ABSTRACT_TYPE( VipsForeign, vips_foreign, VIPS_TYPE_OPERATION );

static void
vips_foreign_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
{
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( object_class );

	VIPS_OBJECT_CLASS( vips_foreign_parent_class )-&gt;
		summary_class( object_class, buf );

	if( class-&gt;suffs ) {
		const char **p;

		vips_buf_appends( buf, &quot; (&quot; );
		for( p = class-&gt;suffs; *p; p++ ) {
			vips_buf_appendf( buf, &quot;%s&quot;, *p );
			if( p[1] )
				vips_buf_appends( buf, &quot;, &quot; );
		}
		vips_buf_appends( buf, &quot;)&quot; );
	}

	vips_buf_appendf( buf, &quot;, priority=%d&quot;, class-&gt;priority );

}

static void
vips_foreign_class_init( VipsForeignClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;

	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;nickname = &quot;foreign&quot;;
	object_class-&gt;description = _( &quot;load and save image files&quot; );
	object_class-&gt;summary_class = vips_foreign_summary_class;
}

static void
vips_foreign_init( VipsForeign *object )
{
}

/* To iterate over supported files we build a temp list of subclasses of 
 * VipsForeign, sort by priority, iterate, and free.
 */

static void *
file_add_class( VipsForeignClass *class, GSList **files )
{
	/* We exclude &quot;rawload&quot; as it has a different API.
	 */
	if( !vips_isprefix( &quot;rawload&quot;, VIPS_OBJECT_CLASS( class )-&gt;nickname ) ) 
		/* Append so we don't reverse the list of files. Sort will 
		 * not reorder items of equal priority. 
		 */
		*files = g_slist_append( *files, class );

	return( NULL );
}

static gint
file_compare( VipsForeignClass *a, VipsForeignClass *b, void *user_data )
{
        return( b-&gt;priority - a-&gt;priority );
}

/**
 * vips_foreign_map:
 * @base: base class to search below (eg. &quot;VipsForeignLoad&quot;)
 * @fn: (scope call): function to apply to each #VipsForeignClass
 * @a: user data
 * @b: user data
 *
 * Apply a function to every #VipsForeignClass that VIPS knows about. Foreigns
 * are presented to the function in priority order. 
 *
 * Like all VIPS map functions, if @fn returns %NULL, iteration continues. If
 * it returns non-%NULL, iteration terminates and that value is returned. The
 * map function returns %NULL if all calls return %NULL.
 *
 * See also: vips_slist_map().
 *
 * Returns: (transfer none): the result of iteration
 */
void *
vips_foreign_map( const char *base, VipsSListMap2Fn fn, void *a, void *b )
{
	GSList *files;
	void *result;

	files = NULL;
	(void) vips_class_map_all( g_type_from_name( base ), 
		(VipsClassMapFn) file_add_class, (void *) &amp;files );

	files = g_slist_sort( files, (GCompareFunc) file_compare );
#ifdef DEBUG
{
	GSList *p;

	printf( &quot;vips_foreign_map: search order\n&quot; );
	for( p = files; p; p = p-&gt;next ) {
		VipsForeignClass *class = (VipsForeignClass *) p-&gt;data;

		printf( &quot;\t%s\n&quot;, VIPS_OBJECT_CLASS( class )-&gt;nickname );
	}
}
#endif /*DEBUG*/
	result = vips_slist_map2( files, fn, a, b );

	g_slist_free( files );

	return( result );
}

/* Abstract base class for image load.
 */

G_DEFINE_ABSTRACT_TYPE( VipsForeignLoad, vips_foreign_load, VIPS_TYPE_FOREIGN );

static void
vips_foreign_load_dispose( GObject *gobject )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( gobject );

	VIPS_UNREF( load-&gt;real );

	G_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;dispose( gobject );
}

static void
vips_foreign_load_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
{
	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_CLASS( object_class );

	VIPS_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;
		summary_class( object_class, buf );

	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) ) {
		if( class-&gt;is_a )
			vips_buf_appends( buf, &quot;, is_a&quot; );
		if( class-&gt;is_a_buffer )
			vips_buf_appends( buf, &quot;, is_a_buffer&quot; );
		if( class-&gt;is_a_source )
			vips_buf_appends( buf, &quot;, is_a_source&quot; );
		if( class-&gt;get_flags )
			vips_buf_appends( buf, &quot;, get_flags&quot; );
		if( class-&gt;get_flags_filename )
			vips_buf_appends( buf, &quot;, get_flags_filename&quot; );
		if( class-&gt;header )
			vips_buf_appends( buf, &quot;, header&quot; );
		if( class-&gt;load )
			vips_buf_appends( buf, &quot;, load&quot; );

		/* You can omit -&gt;load(), you must not omit -&gt;header().
		 */
		g_assert( class-&gt;header );
	}
}

/* Can this VipsForeign open this file?
 */
static void *
vips_foreign_find_load_sub( VipsForeignLoadClass *load_class, 
	const char *filename, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( load_class );
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( load_class );

	/* Ignore the buffer and source loaders.
	 */
	if( vips_ispostfix( object_class-&gt;nickname, &quot;_buffer&quot; ) ||
		vips_ispostfix( object_class-&gt;nickname, &quot;_source&quot; ) ) 
		return( NULL );

#ifdef DEBUG
	printf( &quot;vips_foreign_find_load_sub: %s\n&quot;, 
		VIPS_OBJECT_CLASS( class )-&gt;nickname );
#endif /*DEBUG*/

	/* Try to sniff the filetype from the first few bytes, if we can,
	 * otherwise fall back to checking the filename suffix.
	 */
	if( load_class-&gt;is_a ) {
		if( load_class-&gt;is_a( filename ) ) 
			return( load_class );

#ifdef DEBUG
		printf( &quot;vips_foreign_find_load_sub: is_a failed\n&quot; ); 
#endif /*DEBUG*/
	}
	else if( class-&gt;suffs ) {
		if( vips_filename_suffix_match( filename, class-&gt;suffs ) )
			return( load_class );
	}
	else 
		g_warning( &quot;loader %s has no is_a method and no suffix list&quot;, 
			object_class-&gt;nickname );

	return( NULL );
}

/**
 * vips_foreign_find_load:
 * @filename: file to find a loader for
 *
 * Searches for an operation you could use to load @filename. Any trailing
 * options on @filename are stripped and ignored. 
 *
 * See also: vips_foreign_find_load_buffer(), vips_image_new_from_file().
 *
 * Returns: the name of an operation on success, %NULL on error
 */
const char *
vips_foreign_find_load( const char *name )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	VipsForeignLoadClass *load_class;

	vips__filename_split8( name, filename, option_string );

	/* Very common, so make a better error message for this case.
	 */
	if( !vips_existsf( &quot;%s&quot;, filename ) ) {
		vips_error( &quot;VipsForeignLoad&quot;, 
			_( &quot;file \&quot;%s\&quot; does not exist&quot; ), name );
		return( NULL );
	}
	if( vips_isdirf( &quot;%s&quot;, filename ) ) {
		vips_error( &quot;VipsForeignLoad&quot;, 
			_( &quot;\&quot;%s\&quot; is a directory&quot; ), name );
		return( NULL );
	}

	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
		&quot;VipsForeignLoad&quot;,
		(VipsSListMap2Fn) vips_foreign_find_load_sub, 
		(void *) filename, NULL )) ) {
		vips_error( &quot;VipsForeignLoad&quot;, 
			_( &quot;\&quot;%s\&quot; is not a known file format&quot; ), name );
		return( NULL );
	}

#ifdef DEBUG
	printf( &quot;vips_foreign_find_load: selected %s\n&quot;, 
		VIPS_OBJECT_CLASS( load_class )-&gt;nickname );
#endif /*DEBUG*/

	return( G_OBJECT_CLASS_NAME( load_class ) );
}

/* Kept for compat with earlier version of the vip8 API. Use
 * vips_image_new_from_file() now. 
 */

int
vips_foreign_load( const char *name, VipsImage **out, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;

	vips__filename_split8( name, filename, option_string );
	if( !(operation_name = vips_foreign_find_load( filename )) )
		return( -1 );

	va_start( ap, out );
	result = vips_call_split_option_string( operation_name, option_string, 
		ap, filename, out );
	va_end( ap );

	return( result );
}

/* Can this VipsForeign open this buffer?
 */
static void *
vips_foreign_find_load_buffer_sub( VipsForeignLoadClass *load_class, 
	const void **buf, size_t *len )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( load_class );

	/* Skip non-buffer loaders.
	 */
	if( !vips_ispostfix( object_class-&gt;nickname, &quot;_buffer&quot; ) )
		return( NULL );

	if( load_class-&gt;is_a_buffer ) {
		if( load_class-&gt;is_a_buffer( *buf, *len ) ) 
			return( load_class );
	}
	else
		g_warning( &quot;loader %s has no is_a_buffer method&quot;, 
			object_class-&gt;nickname );

	return( NULL );
}

/**
 * vips_foreign_find_load_buffer:
 * @data: (array length=size) (element-type guint8) (transfer none): start of 
 * memory buffer
 * @size: (type gsize): number of bytes in @data
 *
 * Searches for an operation you could use to load a memory buffer. To see the
 * range of buffer loaders supported by your vips, try something like:
 * 
 * 	vips -l | grep load_buffer
 *
 * See also: vips_image_new_from_buffer().
 *
 * Returns: (transfer none): the name of an operation on success, %NULL on 
 * error.
 */
const char *
vips_foreign_find_load_buffer( const void *data, size_t size )
{
	VipsForeignLoadClass *load_class;

	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
		&quot;VipsForeignLoad&quot;,
		(VipsSListMap2Fn) vips_foreign_find_load_buffer_sub, 
		&amp;data, &amp;size )) ) {
		vips_error( &quot;VipsForeignLoad&quot;, 
			&quot;%s&quot;, _( &quot;buffer is not in a known format&quot; ) ); 
		return( NULL );
	}

	return( G_OBJECT_CLASS_NAME( load_class ) );
}

/* Can this VipsForeign open this source?
 */
static void *
vips_foreign_find_load_source_sub( void *item, void *a, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( item );
	VipsForeignLoadClass *load_class = VIPS_FOREIGN_LOAD_CLASS( item );
	VipsSource *source = VIPS_SOURCE( a );

	/* Skip non-source loaders.
	 */
	if( !vips_ispostfix( object_class-&gt;nickname, &quot;_source&quot; ) )
		return( NULL );

	if( load_class-&gt;is_a_source ) {
		/* We may have done a _read() rather than a _sniff() in one of
		 * the is_a testers. Always rewind.
		 */
		(void) vips_source_rewind( source );

		if( load_class-&gt;is_a_source( source ) ) 
			return( load_class );
	}
	else 
		g_warning( &quot;loader %s has no is_a_source method&quot;, 
			object_class-&gt;nickname );

	return( NULL );
}

/**
 * vips_foreign_find_load_source:
 * @source: source to load from
 *
 * Searches for an operation you could use to load a source. To see the
 * range of source loaders supported by your vips, try something like:
 * 
 * 	vips -l | grep load_source
 *
 * See also: vips_image_new_from_source().
 *
 * Returns: (transfer none): the name of an operation on success, %NULL on 
 * error.
 */
const char *
vips_foreign_find_load_source( VipsSource *source )
{
	VipsForeignLoadClass *load_class;

	if( !(load_class = (VipsForeignLoadClass *) vips_foreign_map( 
		&quot;VipsForeignLoad&quot;,
		vips_foreign_find_load_source_sub, 
		source, NULL )) ) {
		vips_error( &quot;VipsForeignLoad&quot;, 
			&quot;%s&quot;, _( &quot;source is not in a known format&quot; ) ); 
		return( NULL );
	}

	return( G_OBJECT_CLASS_NAME( load_class ) );
}

/**
 * vips_foreign_is_a:
 * @loader: name of loader to use for test
 * @filename: file to test
 *
 * Return %TRUE if @filename can be loaded by @loader. @loader is something
 * like &quot;tiffload&quot; or &quot;VipsForeignLoadTiff&quot;.
 *
 * Returns: %TRUE if @filename can be loaded by @loader.
 */
gboolean 
vips_foreign_is_a( const char *loader, const char *filename )
{
	const VipsObjectClass *class;
	VipsForeignLoadClass *load_class;

	if( !(class = vips_class_find( &quot;VipsForeignLoad&quot;, loader )) ) 
		return( FALSE );
	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
	if( load_class-&gt;is_a &amp;&amp;
		load_class-&gt;is_a( filename ) ) 
		return( TRUE );

	return( FALSE );
}

/**
 * vips_foreign_is_a_buffer:
 * @loader: name of loader to use for test
 * @data: (array length=size) (element-type guint8): pointer to the buffer to test
 * @size: (type gsize): size of the buffer to test
 *
 * Return %TRUE if @data can be loaded by @loader. @loader is something
 * like &quot;tiffload_buffer&quot; or &quot;VipsForeignLoadTiffBuffer&quot;.
 *
 * Returns: %TRUE if @data can be loaded by @loader.
 */
gboolean
vips_foreign_is_a_buffer( const char *loader, const void *data, size_t size )
{
	const VipsObjectClass *class;
	VipsForeignLoadClass *load_class;

	if( !(class = vips_class_find( &quot;VipsForeignLoad&quot;, loader )) )
		return( FALSE );
	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
	if( load_class-&gt;is_a_buffer &amp;&amp;
		load_class-&gt;is_a_buffer( data, size ) )
		return( TRUE );

	return( FALSE );
}

/**
 * vips_foreign_is_a_source:
 * @loader: name of loader to use for test
 * @source: source to test
 *
 * Return %TRUE if @source can be loaded by @loader. @loader is something
 * like &quot;tiffload_source&quot; or &quot;VipsForeignLoadTiffSource&quot;.
 *
 * Returns: %TRUE if @data can be loaded by @source.
 */
gboolean
vips_foreign_is_a_source( const char *loader, VipsSource *source )
{
	const VipsObjectClass *class;
	VipsForeignLoadClass *load_class;

	if( !(class = vips_class_find( &quot;VipsForeignLoad&quot;, loader )) )
		return( FALSE );
	load_class = VIPS_FOREIGN_LOAD_CLASS( class );
	if( load_class-&gt;is_a_source &amp;&amp;
		load_class-&gt;is_a_source( source ) )
		return( TRUE );

	return( FALSE );
}

/**
 * vips_foreign_flags:
 * @loader: name of loader to use for test
 * @filename: file to test
 *
 * Return the flags for @filename using @loader. 
 * @loader is something like &quot;tiffload&quot; or &quot;VipsForeignLoadTiff&quot;.
 *
 * Returns: the flags for @filename.
 */
VipsForeignFlags 
vips_foreign_flags( const char *loader, const char *filename )
{
	const VipsObjectClass *class;

	if( (class = vips_class_find( &quot;VipsForeignLoad&quot;, loader )) ) {
		VipsForeignLoadClass *load_class = 
			VIPS_FOREIGN_LOAD_CLASS( class );

		if( load_class-&gt;get_flags_filename ) 
			return( load_class-&gt;get_flags_filename( filename ) );
	}

	return( 0 );
}

static VipsObject *
vips_foreign_load_new_from_string( const char *string )
{
	const char *file_op;
	GType type;
	VipsForeignLoad *load;

	if( !(file_op = vips_foreign_find_load( string )) )
		return( NULL );
	type = g_type_from_name( file_op );
	g_assert( type ); 

	load = VIPS_FOREIGN_LOAD( g_object_new( type, NULL ) );
	g_object_set( load,
		&quot;filename&quot;, string,
		NULL );

	return( VIPS_OBJECT( load ) );
}

static VipsImage *
vips_foreign_load_temp( VipsForeignLoad *load )
{
	const guint64 disc_threshold = vips_get_disc_threshold();
	const guint64 image_size = VIPS_IMAGE_SIZEOF_IMAGE( load-&gt;out );

	/* -&gt;memory used to be called -&gt;disc and default TRUE. If it's been
	 * forced FALSE, set memory TRUE.
	 */
	if( !load-&gt;disc )
		load-&gt;memory = TRUE;

	if( load-&gt;memory ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_temp: forced memory temp\n&quot; );
#endif /*DEBUG*/

		return( vips_image_new_memory() );
	}

	/* If this is a partial operation, we can open directly.
	 */
	if( load-&gt;flags &amp; VIPS_FOREIGN_PARTIAL ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_temp: partial temp\n&quot; );
#endif /*DEBUG*/

		return( vips_image_new() );
	}

	/* If it can do sequential access and it's been requested, we can open
	 * directly.
	 */
	if( (load-&gt;flags &amp; VIPS_FOREIGN_SEQUENTIAL) &amp;&amp; 
		load-&gt;access != VIPS_ACCESS_RANDOM ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_temp: partial sequential temp\n&quot; );
#endif /*DEBUG*/

		return( vips_image_new() );
	}

	/* We open via disc if the uncompressed image will be larger than 
	 * vips_get_disc_threshold()
	 */
	if( image_size &gt; disc_threshold ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_temp: disc temp\n&quot; );
#endif /*DEBUG*/

		return( vips_image_new_temp_file( &quot;%s.v&quot; ) );
	}

#ifdef DEBUG
	printf( &quot;vips_foreign_load_temp: fallback memory temp\n&quot; );
#endif /*DEBUG*/

	/* Otherwise, fall back to a memory buffer.
	 */
	return( vips_image_new_memory() );

}

/* Check two images for compatibility: their geometries need to match.
 */
static gboolean
vips_foreign_load_iscompat( VipsImage *a, VipsImage *b )
{
	if( a-&gt;Xsize != b-&gt;Xsize ||
		a-&gt;Ysize != b-&gt;Ysize ||
		a-&gt;Bands != b-&gt;Bands ||
		a-&gt;Coding != b-&gt;Coding ||
		a-&gt;BandFmt != b-&gt;BandFmt ) {
		vips_error( &quot;VipsForeignLoad&quot;,
			&quot;%s&quot;, _( &quot;images do not match&quot; ) ); 
		return( FALSE );
	}

	return( TRUE );
}

/* Our start function ... do the lazy open, if necessary, and return a region
 * on the new image.
 */
static void *
vips_foreign_load_start( VipsImage *out, void *a, void *b )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );
	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );

	/* If this start has failed before in another thread, we can fail now.
	 */
	if( load-&gt;error )
		return( NULL );

	if( !load-&gt;real ) {
		if( !(load-&gt;real = vips_foreign_load_temp( load )) )
			return( NULL );

#ifdef DEBUG
		printf( &quot;vips_foreign_load_start: triggering -&gt;load()\n&quot; );
#endif /*DEBUG*/

		/* Read the image in. This may involve a long computation and
		 * will finish with load-&gt;real holding the decompressed image. 
		 *
		 * We want our caller to be able to see this computation on
		 * @out, so eval signals on -&gt;real need to appear on -&gt;out.
		 */
		load-&gt;real-&gt;progress_signal = load-&gt;out;

		/* Note the load object on the image. Loaders can use 
		 * this to signal invalidate if they hit a load error. See
		 * vips_foreign_load_invalidate() below.
		 */
		g_object_set_qdata( G_OBJECT( load-&gt;real ), 
			vips__foreign_load_operation, load ); 

		/* Load the image and check the result.
		 *
		 * -&gt;header() read the header into @out, load will read the
		 * image into @real. They must match exactly in size, bands,
		 * format and coding for the copy to work.  
		 *
		 * Some versions of ImageMagick give different results between
		 * Ping and Load for some formats, for example.
		 *
		 * If the load fails, we need to stop
		 */
		if( class-&gt;load( load ) ||
			vips_image_pio_input( load-&gt;real ) || 
			!vips_foreign_load_iscompat( load-&gt;real, out ) ) {
			vips_operation_invalidate( VIPS_OPERATION( load ) ); 
			load-&gt;error = TRUE;

			return( NULL );
		}

		/* We have to tell vips that out depends on real. We've set
		 * the demand hint below, but not given an input there.
		 */
		if( vips_image_pipelinev( load-&gt;out, load-&gt;out-&gt;dhint, 
			load-&gt;real, NULL ) )
			return( NULL );
	}

	return( vips_region_new( load-&gt;real ) );
}

/* Just pointer-copy.
 */
static int
vips_foreign_load_generate( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	VipsRegion *ir = (VipsRegion *) seq;

        VipsRect *r = &amp;or-&gt;valid;

        /* Ask for input we need.
         */
        if( vips_region_prepare( ir, r ) )
                return( -1 );

        /* Attach output region to that.
         */
        if( vips_region_region( or, ir, r, r-&gt;left, r-&gt;top ) )
                return( -1 );

        return( 0 );
}

static int
vips_foreign_load_build( VipsObject *object )
{
	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object );
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( object );
	VipsForeignLoadClass *fclass = VIPS_FOREIGN_LOAD_GET_CLASS( object );

	VipsForeignFlags flags;
	gboolean sequential;

#ifdef DEBUG
	printf( &quot;vips_foreign_load_build:\n&quot; );
#endif /*DEBUG*/

	flags = 0;
	if( fclass-&gt;get_flags )
		flags |= fclass-&gt;get_flags( load );

	if( (flags &amp; VIPS_FOREIGN_PARTIAL) &amp;&amp;
		(flags &amp; VIPS_FOREIGN_SEQUENTIAL) ) {
		g_warning( &quot;%s&quot;, 
			_( &quot;VIPS_FOREIGN_PARTIAL and VIPS_FOREIGN_SEQUENTIAL &quot;
				&quot;both set -- using SEQUENTIAL&quot; ) );
		flags ^= VIPS_FOREIGN_PARTIAL;
	}

	g_object_set( load, &quot;flags&quot;, flags, NULL );

	/* Seq access has been requested and the loader supports seq.
	 */
	sequential = (load-&gt;flags &amp; VIPS_FOREIGN_SEQUENTIAL) &amp;&amp; 
		load-&gt;access != VIPS_ACCESS_RANDOM;

	/* We must block caching of seq loads.
	 */
	if( sequential )
		load-&gt;nocache = TRUE;

	if( VIPS_OBJECT_CLASS( vips_foreign_load_parent_class )-&gt;
		build( object ) )
		return( -1 );

	if( load-&gt;sequential ) 
		g_warning( &quot;%s&quot;, 
			_( &quot;ignoring deprecated \&quot;sequential\&quot; mode -- &quot;
				&quot;please use \&quot;access\&quot; instead&quot; ) ); 

	g_object_set( object, &quot;out&quot;, vips_image_new(), NULL ); 

	vips_image_set_string( load-&gt;out, 
		VIPS_META_LOADER, class-&gt;nickname );

#ifdef DEBUG
	printf( &quot;vips_foreign_load_build: triggering -&gt;header()\n&quot; );
#endif /*DEBUG*/

	/* Read the header into @out.
	 */
	if( fclass-&gt;header &amp;&amp;
		fclass-&gt;header( load ) ) 
		return( -1 );

	/* If there's no -&gt;load() method then the header read has done
	 * everything. Otherwise, it's just set fields and we must also
	 * load pixels.
	 *
	 * Delay the load until the first pixel is requested by doing the work
	 * in the start function of the copy.
	 */
	if( fclass-&gt;load ) {
#ifdef DEBUG
		printf( &quot;vips_foreign_load_build: delaying read ...\n&quot; );
#endif /*DEBUG*/

		/* -&gt;header() should set the dhint. It'll default to the safe
		 * SMALLTILE if header() did not set it.
		 */
		if( vips_image_pipelinev( load-&gt;out, load-&gt;out-&gt;dhint, NULL ) )
			return( -1 );

		/* Then 'start' creates the real image and 'gen' fetches 
		 * pixels for @out from @real on demand.
		 */
		if( vips_image_generate( load-&gt;out, 
			vips_foreign_load_start, 
			vips_foreign_load_generate, 
			vips_stop_one, 
			NULL, load ) ) 
			return( -1 );
	}

	/* Tell downstream if we are reading sequentially.
	 */
	if( sequential ) 
		vips_image_set_area( load-&gt;out, 
			VIPS_META_SEQUENTIAL, NULL, NULL ); 

	return( 0 );
}

static VipsOperationFlags 
vips_foreign_load_operation_get_flags( VipsOperation *operation )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( operation );

	VipsOperationFlags flags;

	flags = VIPS_OPERATION_CLASS( vips_foreign_load_parent_class )-&gt;
		get_flags( operation );
<A NAME="0"></A>	if( load-&gt;nocache )
		flags |= VIPS_OPERATION_NOCACHE;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match26322-0.html#0',2,'match26322-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( flags );
}

static void
vips_foreign_load_class_init( VipsForeignLoadClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsOperationClass *operation_class = (VipsOperationClass *) class;

	gobject_class-&gt;dispose = vips_foreign_load_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;build = vips_foreign_load_build;
	object_class-&gt;summary_class = vips_foreign_load_summary_class;
	object_class-&gt;new_from_string = vips_foreign_load_new_from_string;</B></FONT>
	object_class-&gt;nickname = &quot;fileload&quot;;
	object_class-&gt;description = _( &quot;file loaders&quot; );

	operation_class-&gt;get_flags = vips_foreign_load_operation_get_flags;

	VIPS_ARG_IMAGE( class, &quot;out&quot;, 2, 
		_( &quot;Output&quot; ), 
		_( &quot;Output image&quot; ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
		G_STRUCT_OFFSET( VipsForeignLoad, out ) );

	VIPS_ARG_FLAGS( class, &quot;flags&quot;, 106, 
		_( &quot;Flags&quot; ), 
		_( &quot;Flags for this file&quot; ),
		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
		G_STRUCT_OFFSET( VipsForeignLoad, flags ),
		VIPS_TYPE_FOREIGN_FLAGS, VIPS_FOREIGN_NONE ); 

	VIPS_ARG_BOOL( class, &quot;memory&quot;, 107, 
		_( &quot;Memory&quot; ), 
		_( &quot;Force open via memory&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoad, memory ),
		FALSE );

	VIPS_ARG_ENUM( class, &quot;access&quot;, 108, 
		_( &quot;Access&quot; ), 
		_( &quot;Required access pattern for this file&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoad, access ),
		VIPS_TYPE_ACCESS, VIPS_ACCESS_RANDOM ); 

	VIPS_ARG_BOOL( class, &quot;sequential&quot;, 109, 
		_( &quot;Sequential&quot; ), 
		_( &quot;Sequential read only&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignLoad, sequential ),
		FALSE );

	VIPS_ARG_BOOL( class, &quot;fail&quot;, 110, 
		_( &quot;Fail&quot; ), 
		_( &quot;Fail on first error&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignLoad, fail ),
		FALSE );

	VIPS_ARG_BOOL( class, &quot;disc&quot;, 111, 
		_( &quot;Disc&quot; ), 
		_( &quot;Open to disc&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
		G_STRUCT_OFFSET( VipsForeignLoad, disc ),
		TRUE );

}

static void
vips_foreign_load_init( VipsForeignLoad *load )
{
	load-&gt;disc = TRUE;
	load-&gt;access = VIPS_ACCESS_RANDOM;
}

/*
 * Loaders can call this
 */

/**
 * vips_foreign_load_invalidate: (method)
 * @image: image to invalidate
 *
 * Loaders can call this on the image they are making if they see a read error
 * from the load library. It signals &quot;invalidate&quot; on the load operation and
 * will cause it to be dropped from cache. 
 *
 * If we know a file will cause a read error, we don't want to cache the
 * failing operation, we want to make sure the image will really be opened 
 * again if our caller tries again. For example, a broken file might be 
 * replaced by a working one. 
 */
void
vips_foreign_load_invalidate( VipsImage *image )
{
	VipsOperation *operation; 

#ifdef DEBUG
	printf( &quot;vips_foreign_load_invalidate: %p\n&quot;, image ); 
#endif /*DEBUG*/

	if( (operation = g_object_get_qdata( G_OBJECT( image ), 
<A NAME="1"></A>		vips__foreign_load_operation )) ) {
		vips_operation_invalidate( operation ); 
	}
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match26322-0.html#1',2,'match26322-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Abstract base class for image savers.
 */

G_DEFINE_ABSTRACT_TYPE( VipsForeignSave, vips_foreign_save, VIPS_TYPE_FOREIGN );

static void
vips_foreign_save_dispose( GObject *gobject )
{
	VipsForeignSave *save = VIPS_FOREIGN_SAVE( gobject );

	VIPS_UNREF( save-&gt;ready );

	G_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;dispose( gobject );
}

static void
vips_foreign_save_summary_class( VipsObjectClass *object_class, VipsBuf *buf )
{
	VipsForeignSaveClass *class = VIPS_FOREIGN_SAVE_CLASS( object_class );

	VIPS_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;
		summary_class( object_class, buf );

	vips_buf_appendf( buf, &quot;, %s&quot;, 
		vips_enum_nick( VIPS_TYPE_SAVEABLE, class-&gt;saveable ) );
}

static VipsObject *</B></FONT>
vips_foreign_save_new_from_string( const char *string )
{
	const char *file_op;
	GType type;
	VipsForeignSave *save;

	if( !(file_op = vips_foreign_find_save( string )) )
		return( NULL );
	type = g_type_from_name( file_op );
	g_assert( type ); 

	save = VIPS_FOREIGN_SAVE( g_object_new( type, NULL ) );
	g_object_set( save,
		&quot;filename&quot;, string,
		NULL );

	return( VIPS_OBJECT( save ) );
}

/* Convert an image for saving. 
 */
int
vips__foreign_convert_saveable( VipsImage *in, VipsImage **ready,
	VipsSaveable saveable, VipsBandFormat *format, VipsCoding *coding,
	VipsArrayDouble *background )
{
	/* in holds a reference to the output of our chain as we build it.
	 */
	g_object_ref( in );

	/* For coded images, can this class save the coding we are in now? 
	 * Nothing to do.
	 */
	if( in-&gt;Coding != VIPS_CODING_NONE &amp;&amp;
		coding[in-&gt;Coding] ) {
		*ready = in;
		return( 0 );
	}

	/* For uncoded images, if this saver supports ANY bands and this 
	 * format we have nothing to do.
	 */
	if( in-&gt;Coding == VIPS_CODING_NONE &amp;&amp;
	        saveable == VIPS_SAVEABLE_ANY &amp;&amp;
		format[in-&gt;BandFmt] == in-&gt;BandFmt ) {
		*ready = in;
		return( 0 );
	}

	/* Otherwise ... we need to decode and then (possibly) recode at the
	 * end.
	 */

	/* If this is an VIPS_CODING_LABQ, we can go straight to RGB.
	 */
	if( in-&gt;Coding == VIPS_CODING_LABQ ) {
		VipsImage *out;

		if( vips_LabQ2sRGB( in, &amp;out, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );

		in = out;
	}

	/* If this is an VIPS_CODING_RAD, we unpack to float. This could be
	 * scRGB or XYZ. 
	 */
	if( in-&gt;Coding == VIPS_CODING_RAD ) {
		VipsImage *out;

		if( vips_rad2float( in, &amp;out, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );

		in = out;
	}

	/* If the saver supports RAD, we need to go to scRGB or XYZ. 
	 */
	if( coding[VIPS_CODING_RAD] ) {
		if( in-&gt;Type != VIPS_INTERPRETATION_scRGB &amp;&amp;
			in-&gt;Type != VIPS_INTERPRETATION_XYZ ) {
			VipsImage *out;

			if( vips_colourspace( in, &amp;out, 
				VIPS_INTERPRETATION_scRGB, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;
		}
	}

	/* If this image is CMYK and the saver is RGB-only, use lcms to try to
	 * import to XYZ. 
	 */
	if( in-&gt;Type == VIPS_INTERPRETATION_CMYK &amp;&amp;
		in-&gt;Bands &gt;= 4 &amp;&amp;
		(saveable == VIPS_SAVEABLE_RGB ||
		 saveable == VIPS_SAVEABLE_RGBA ||
		 saveable == VIPS_SAVEABLE_RGBA_ONLY) ) { 
		VipsImage *out;

		if( vips_icc_import( in, &amp;out, 
			&quot;pcs&quot;, VIPS_PCS_XYZ,
			&quot;embedded&quot;, TRUE,
			&quot;input_profile&quot;, &quot;cmyk&quot;,
			NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );

		in = out;
	}

	/* If this is something other than CMYK or RAD, and it's not already
	 * an RGB image, eg. maybe a LAB image, we need to transform 
	 * to RGB.
	 */
	if( !coding[VIPS_CODING_RAD] &amp;&amp;
		in-&gt;Bands &gt;= 3 &amp;&amp;
		in-&gt;Type != VIPS_INTERPRETATION_CMYK &amp;&amp;
		in-&gt;Type != VIPS_INTERPRETATION_sRGB &amp;&amp;
		in-&gt;Type != VIPS_INTERPRETATION_RGB16 &amp;&amp;
		in-&gt;Type != VIPS_INTERPRETATION_scRGB &amp;&amp;
		vips_colourspace_issupported( in ) &amp;&amp;
		(saveable == VIPS_SAVEABLE_RGB ||
		 saveable == VIPS_SAVEABLE_RGBA ||
		 saveable == VIPS_SAVEABLE_RGBA_ONLY ||
		 saveable == VIPS_SAVEABLE_RGB_CMYK) ) { 
		VipsImage *out;
		VipsInterpretation interpretation;

		/* Do we make RGB or RGB16? We don't want to squash a 16-bit
		 * RGB down to 8 bits if the saver supports 16. 
		 */
		if( vips_band_format_is8bit( format[in-&gt;BandFmt] ) )
			interpretation = VIPS_INTERPRETATION_sRGB;
		else
			interpretation = VIPS_INTERPRETATION_RGB16;

		if( vips_colourspace( in, &amp;out, interpretation, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );

		in = out;
	}

	/* VIPS_SAVEABLE_RGBA_ONLY does not support mono types ... convert 
	 * to sRGB. 
	 */
	if( !coding[VIPS_CODING_RAD] &amp;&amp;
		in-&gt;Bands &lt; 3 &amp;&amp;
		vips_colourspace_issupported( in ) &amp;&amp;
		saveable == VIPS_SAVEABLE_RGBA_ONLY ) { 
		VipsImage *out;
		VipsInterpretation interpretation;

		/* Do we make RGB or RGB16? We don't want to squash a 16-bit
		 * RGB down to 8 bits if the saver supports 16. 
		 */
		if( vips_band_format_is8bit( format[in-&gt;BandFmt] ) )
			interpretation = VIPS_INTERPRETATION_sRGB;
		else
			interpretation = VIPS_INTERPRETATION_RGB16;

		if( vips_colourspace( in, &amp;out, interpretation, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );

		in = out;
	}

	/* Get the bands right. We must do this after all colourspace
	 * transforms, since they can change the number of bands. 
	 */
	if( in-&gt;Coding == VIPS_CODING_NONE ) {
		/* Do we need to flatten out an alpha channel? There needs to
		 * be an alpha there now, and this writer needs to not support
		 * alpha.
		 */
		if( (in-&gt;Bands == 2 ||
			(in-&gt;Bands == 4 &amp;&amp; 
			 in-&gt;Type != VIPS_INTERPRETATION_CMYK)) &amp;&amp;
			(saveable == VIPS_SAVEABLE_MONO ||
			 saveable == VIPS_SAVEABLE_RGB ||
			 saveable == VIPS_SAVEABLE_RGB_CMYK) ) {
			VipsImage *out;

			if( vips_flatten( in, &amp;out, 
				&quot;background&quot;, background,
				NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;
		}

		/* Other alpha removal strategies ... just drop the extra
		 * bands.
		 */

		else if( in-&gt;Bands &gt; 3 &amp;&amp; 
			(saveable == VIPS_SAVEABLE_RGB ||
			 (saveable == VIPS_SAVEABLE_RGB_CMYK &amp;&amp;
			  in-&gt;Type != VIPS_INTERPRETATION_CMYK)) ) { 
			VipsImage *out;

			/* Don't let 4 bands though unless the image really is
			 * a CMYK.
			 *
			 * Consider a RGBA png being saved as JPG. We can
			 * write CMYK jpg, but we mustn't do that for RGBA
			 * images.
			 */
			if( vips_extract_band( in, &amp;out, 0, 
				&quot;n&quot;, 3,
				NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;
		}
		else if( in-&gt;Bands &gt; 4 &amp;&amp; 
			((saveable == VIPS_SAVEABLE_RGB_CMYK &amp;&amp;
			  in-&gt;Type == VIPS_INTERPRETATION_CMYK) ||
			 saveable == VIPS_SAVEABLE_RGBA ||
			 saveable == VIPS_SAVEABLE_RGBA_ONLY) ) {
			VipsImage *out;

			if( vips_extract_band( in, &amp;out, 0, 
				&quot;n&quot;, 4,
				NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;
		}
		else if( in-&gt;Bands &gt; 1 &amp;&amp; 
			saveable == VIPS_SAVEABLE_MONO ) {
			VipsImage *out;

			if( vips_extract_band( in, &amp;out, 0, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;
		}

		/* Else we have VIPS_SAVEABLE_ANY and we don't chop bands down.
		 */
	}

	/* Handle the ushort interpretations.
	 *
	 * RGB16 and GREY16 use 0-65535 for black-white. If we have an image
	 * tagged like this, and it has more than 8 bits (we leave crazy uchar
	 * images tagged as RGB16 alone), we'll need to get it ready for the
	 * saver.
	 */
	if( (in-&gt;Type == VIPS_INTERPRETATION_RGB16 ||
		 in-&gt;Type == VIPS_INTERPRETATION_GREY16) &amp;&amp;
		!vips_band_format_is8bit( in-&gt;BandFmt ) ) {
		/* If the saver supports ushort, cast to ushort. It may be
		 * float at the moment, for example.
		 *
		 * If the saver does not support ushort, automatically shift
		 * it down. This is the behaviour we want for saving an RGB16
		 * image as JPG, for example.
		 */
		if( format[VIPS_FORMAT_USHORT] == VIPS_FORMAT_USHORT ) {
			VipsImage *out;

			if( vips_cast( in, &amp;out, VIPS_FORMAT_USHORT, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;
		}
		else {
			VipsImage *out;

			if( vips_rshift_const1( in, &amp;out, 8, NULL ) ) { 
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;

			/* That could have produced an int image ... make sure 
			 * we are now uchar.
			 */
			if( vips_cast( in, &amp;out, VIPS_FORMAT_UCHAR, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;
		}
	}

	/* Cast to the output format.
	 */
	{
		VipsImage *out;

		if( vips_cast( in, &amp;out, format[in-&gt;BandFmt], NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );

		in = out;
	}

	/* Does this class want a coded image? Search the coding table for the
	 * first one.
	 */
	if( coding[VIPS_CODING_NONE] ) {
		/* Already NONE, nothing to do.
		 */
	}
	else if( coding[VIPS_CODING_LABQ] ) {
		VipsImage *out;

		if( vips_Lab2LabQ( in, &amp;out, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );

		in = out;
	}
	else if( coding[VIPS_CODING_RAD] ) {
		VipsImage *out;

		if( vips_float2rad( in, &amp;out, NULL ) ) {
			g_object_unref( in );
			return( -1 );
		}
		g_object_unref( in );

		in = out;
	}

	/* Some format libraries, like libpng, will throw a hard error if the 
	 * profile is inappropriate for this image type. With profiles inherited
	 * from a source image, this can happen all the time, so we 
	 * want to silently drop the profile in this case.
	 */
	if( vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ) {
		const void *data;
		size_t length;

		if( !vips_image_get_blob( in, VIPS_META_ICC_NAME, 
			&amp;data, &amp;length ) &amp;&amp;
			!vips_icc_is_compatible_profile( in, data, length ) ) {
			VipsImage *out;

			if( vips_copy( in, &amp;out, NULL ) ) {
				g_object_unref( in );
				return( -1 );
			}
			g_object_unref( in );

			in = out;

			vips_image_remove( in, VIPS_META_ICC_NAME );
		}
	}

	*ready = in;

	return( 0 );
}

static int
vips_foreign_save_build( VipsObject *object )
{
	VipsForeignSave *save = VIPS_FOREIGN_SAVE( object );

	if( save-&gt;in ) {
		VipsForeignSaveClass *class = 
			VIPS_FOREIGN_SAVE_GET_CLASS( save );
		VipsImage *ready;

		if( vips__foreign_convert_saveable( save-&gt;in, &amp;ready,
			class-&gt;saveable, class-&gt;format_table, class-&gt;coding,
			save-&gt;background ) )
			return( -1 );

		if( save-&gt;page_height ) {
			VipsImage *x;

			if( vips_copy( ready, &amp;x, NULL ) ) {
				VIPS_UNREF( ready );
				return( -1 );
			}
			VIPS_UNREF( ready );
			ready = x;

			vips_image_set_int( ready, 
				VIPS_META_PAGE_HEIGHT, save-&gt;page_height );
		}

		VIPS_UNREF( save-&gt;ready );
		save-&gt;ready = ready;
	}

	if( VIPS_OBJECT_CLASS( vips_foreign_save_parent_class )-&gt;
		build( object ) )
		return( -1 );

	return( 0 );
}

#define UC VIPS_FORMAT_UCHAR
#define C VIPS_FORMAT_CHAR
#define US VIPS_FORMAT_USHORT
#define S VIPS_FORMAT_SHORT
#define UI VIPS_FORMAT_UINT
#define I VIPS_FORMAT_INT
#define F VIPS_FORMAT_FLOAT
#define X VIPS_FORMAT_COMPLEX
#define D VIPS_FORMAT_DOUBLE
#define DX VIPS_FORMAT_DPCOMPLEX

static int vips_foreign_save_format_table[10] = {
// UC  C   US  S   UI  I  F  X  D  DX 
   UC, C,  US, S,  UI, I, F, X, D, DX
};

static void
vips_foreign_save_class_init( VipsForeignSaveClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	VipsOperationClass *operation_class = (VipsOperationClass *) class;

	int i;

	gobject_class-&gt;dispose = vips_foreign_save_dispose;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;

	object_class-&gt;build = vips_foreign_save_build;
	object_class-&gt;summary_class = vips_foreign_save_summary_class;
	object_class-&gt;new_from_string = vips_foreign_save_new_from_string;
	object_class-&gt;nickname = &quot;filesave&quot;;
	object_class-&gt;description = _( &quot;file savers&quot; );

	/* All savers are sequential by definition. Things like tiled tiff 
	 * write and interlaced png write, which are not, add extra caches 
	 * on their input. 
	 */
	operation_class-&gt;flags |= VIPS_OPERATION_SEQUENTIAL;

	/* Must not cache savers.
	 */
	operation_class-&gt;flags |= VIPS_OPERATION_NOCACHE;

	/* Default to no coding allowed.
	 */
	for( i = 0; i &lt; VIPS_CODING_LAST; i++ )
		class-&gt;coding[i] = FALSE;
	class-&gt;coding[VIPS_CODING_NONE] = TRUE;

	/* Default to no cast on save.
	 */
	class-&gt;format_table = vips_foreign_save_format_table; 

	VIPS_ARG_IMAGE( class, &quot;in&quot;, 0, 
		_( &quot;Input&quot; ), 
		_( &quot;Image to save&quot; ),
		VIPS_ARGUMENT_REQUIRED_INPUT,
		G_STRUCT_OFFSET( VipsForeignSave, in ) );

	VIPS_ARG_BOOL( class, &quot;strip&quot;, 100,
		_( &quot;Strip&quot; ),
		_( &quot;Strip all metadata from image&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSave, strip ),
		FALSE );

	VIPS_ARG_BOXED( class, &quot;background&quot;, 101, 
		_( &quot;Background&quot; ), 
		_( &quot;Background value&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSave, background ),
		VIPS_TYPE_ARRAY_DOUBLE );

	VIPS_ARG_INT( class, &quot;page_height&quot;, 102, 
		_( &quot;Page height&quot; ), 
		_( &quot;Set page height for multipage save&quot; ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsForeignSave, page_height ),
		0, VIPS_MAX_COORD, 0 ); 
}

static void
vips_foreign_save_init( VipsForeignSave *save )
{
	save-&gt;background = vips_array_double_newv( 1, 0.0 );
}

/* Can we write this filename with this class? 
 */
static void *
vips_foreign_find_save_sub( VipsForeignSaveClass *save_class, 
	const char *filename, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );

	const char **p;

	/* All savers needs suffs defined since we use the suff to pick the 
	 * saver.
	 */
	if( !class-&gt;suffs )
		g_warning( &quot;no suffix defined for %s&quot;, object_class-&gt;nickname );

	/* Skip non-file savers.
	 */
	if( vips_ispostfix( object_class-&gt;nickname, &quot;_buffer&quot; ) ||
		vips_ispostfix( object_class-&gt;nickname, &quot;_target&quot; ) )
		return( NULL );

	/* vips_foreign_find_save() has already removed any options from the
	 * end of the filename, so we can test directly against the suffix.
	 */
	for( p = class-&gt;suffs; *p; p++ ) 
		if( vips_iscasepostfix( filename, *p ) ) 
			return( save_class );

	return( NULL );
}

/**
 * vips_foreign_find_save:
 * @filename: name to find a saver for
 *
 * Searches for an operation you could use to write to @filename.
 * Any trailing options on @filename are stripped and ignored. 
 *
 * See also: vips_foreign_find_save_buffer(), vips_image_write_to_file().
 *
 * Returns: the name of an operation on success, %NULL on error
 */
const char *
vips_foreign_find_save( const char *name )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	VipsForeignSaveClass *save_class;

	vips__filename_split8( name, filename, option_string );

	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
		&quot;VipsForeignSave&quot;,
		(VipsSListMap2Fn) vips_foreign_find_save_sub, 
		(void *) filename, NULL )) ) {
		vips_error( &quot;VipsForeignSave&quot;,
			_( &quot;\&quot;%s\&quot; is not a known file format&quot; ), name );

		return( NULL );
	}

	return( G_OBJECT_CLASS_NAME( save_class ) );
}

static void *
vips_foreign_get_suffixes_count_cb( VipsForeignSaveClass *save_class, 
	void *a, void *b )
{
	VipsForeignClass *foreign_class = VIPS_FOREIGN_CLASS( save_class );
	int *n_fields = (int *) a;

	int i;

	if( foreign_class-&gt;suffs )
		for( i = 0; foreign_class-&gt;suffs[i]; i++ )
			*n_fields += 1;

	return( NULL ); 
}

static void *
vips_foreign_get_suffixes_add_cb( VipsForeignSaveClass *save_class, 
	void *a, void *b )
{
	VipsForeignClass *foreign_class = VIPS_FOREIGN_CLASS( save_class );
	gchar ***p = (gchar ***) a;

	int i;

	if( foreign_class-&gt;suffs )
		for( i = 0; foreign_class-&gt;suffs[i]; i++ ) {
			**p = g_strdup( foreign_class-&gt;suffs[i] ); 
			*p += 1;
		}

	return( NULL ); 
}

/**
 * vips_foreign_get_suffixes: (method)
 *
 * Get a %NULL-terminated array listing all the supported suffixes. 
 *
 * This is not the same as all the supported file types, since libvips 
 * detects image format for load by testing the first few bytes. 
 *
 * Use vips_foreign_find_load() to detect type for a specific file.
 *
 * Free the return result with g_strfreev().
 *
 * Returns: (transfer full): all supported file extensions, as a 
 * %NULL-terminated array. 
 */
gchar ** 
vips_foreign_get_suffixes( void )
{
	int n_suffs;
	gchar **suffs;
	gchar **p;

	n_suffs = 0;
	(void) vips_foreign_map( 
		&quot;VipsForeignSave&quot;,
		(VipsSListMap2Fn) vips_foreign_get_suffixes_count_cb, 
		&amp;n_suffs, NULL );

	suffs = g_new0( gchar *, n_suffs + 1 ); 
	p = suffs;
	(void) vips_foreign_map( 
		&quot;VipsForeignSave&quot;,
		(VipsSListMap2Fn) vips_foreign_get_suffixes_add_cb, 
		&amp;p, NULL );

	return( suffs ); 
}

/* Kept for early vips8 API compat.
 */

int
vips_foreign_save( VipsImage *in, const char *name, ... )
{
	char filename[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	const char *operation_name;
	va_list ap;
	int result;

	vips__filename_split8( name, filename, option_string );

	if( !(operation_name = vips_foreign_find_save( filename )) )
		return( -1 );

	va_start( ap, name );
	result = vips_call_split_option_string( operation_name, option_string, 
		ap, in, filename );
	va_end( ap );

	return( result );
}

/* Can this class write this filetype to a target?
 */
static void *
vips_foreign_find_save_target_sub( VipsForeignSaveClass *save_class, 
	const char *suffix, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );

	/* All concrete savers needs suffs, since we use the suff to pick the 
	 * saver.
	 */
	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
		!class-&gt;suffs )
		g_warning( &quot;no suffix defined for %s&quot;, object_class-&gt;nickname );

	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
		class-&gt;suffs &amp;&amp;
		vips_ispostfix( object_class-&gt;nickname, &quot;_target&quot; ) &amp;&amp;
		vips_filename_suffix_match( suffix, class-&gt;suffs ) )
		return( save_class );

	return( NULL );
}

/**
 * vips_foreign_find_save_target:
 * @suffix: format to find a saver for
 *
 * Searches for an operation you could use to write to a target in @suffix
 * format. 
 *
 * See also: vips_image_write_to_buffer().
 *
 * Returns: the name of an operation on success, %NULL on error
 */
const char *
vips_foreign_find_save_target( const char *name )
{
	char suffix[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	VipsForeignSaveClass *save_class;

	vips__filename_split8( name, suffix, option_string );

	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
		&quot;VipsForeignSave&quot;,
		(VipsSListMap2Fn) vips_foreign_find_save_target_sub, 
		(void *) suffix, NULL )) ) {
		vips_error( &quot;VipsForeignSave&quot;,
			_( &quot;\&quot;%s\&quot; is not a known target format&quot; ), name );

		return( NULL );
	}

	return( G_OBJECT_CLASS_NAME( save_class ) );
}

/* Can we write this buffer with this file type?
 */
static void *
vips_foreign_find_save_buffer_sub( VipsForeignSaveClass *save_class, 
	const char *suffix, void *b )
{
	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( save_class );
	VipsForeignClass *class = VIPS_FOREIGN_CLASS( save_class );

	/* All concrete savers needs suffs, since we use the suff to pick the 
	 * saver.
	 */
	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
		!class-&gt;suffs )
		g_warning( &quot;no suffix defined for %s&quot;, object_class-&gt;nickname );

	if( !G_TYPE_IS_ABSTRACT( G_TYPE_FROM_CLASS( class ) ) &amp;&amp;
		class-&gt;suffs &amp;&amp;
		vips_ispostfix( object_class-&gt;nickname, &quot;_buffer&quot; ) &amp;&amp;
		vips_filename_suffix_match( suffix, class-&gt;suffs ) )
		return( save_class );

	return( NULL );
}

/**
 * vips_foreign_find_save_buffer:
 * @suffix: name to find a saver for
 *
 * Searches for an operation you could use to write to a buffer in @suffix
 * format. 
 *
 * See also: vips_image_write_to_buffer().
 *
 * Returns: the name of an operation on success, %NULL on error
 */
const char *
vips_foreign_find_save_buffer( const char *name )
{
	char suffix[VIPS_PATH_MAX];
	char option_string[VIPS_PATH_MAX];
	VipsForeignSaveClass *save_class;

	vips__filename_split8( name, suffix, option_string );

	if( !(save_class = (VipsForeignSaveClass *) vips_foreign_map( 
		&quot;VipsForeignSave&quot;,
		(VipsSListMap2Fn) vips_foreign_find_save_buffer_sub, 
		(void *) suffix, NULL )) ) {
		vips_error( &quot;VipsForeignSave&quot;,
			_( &quot;\&quot;%s\&quot; is not a known buffer format&quot; ), name );

		return( NULL );
	}

	return( G_OBJECT_CLASS_NAME( save_class ) );
}

/* C API wrappers for loadable modules go here.
 */

/**
 * vips_heifload:
 * @filename: file to load
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (top-level image number) to read
 * * @n: %gint, load this many pages
 * * @thumbnail: %gboolean, fetch thumbnail instead of image
 *
 * Read a HEIF image file into a VIPS image. 
 *
 * Use @page to select a page to render, numbering from zero. If neither @n
 * nor @page are set, @page defaults to the primary page, otherwise to 0.
 *
 * Use @n to select the number of pages to render. The default is 1. Pages are
 * rendered in a vertical column. Set to -1 to mean &quot;until the end of the 
 * document&quot;. Use vips_grid() to reorganise pages.
 *
 * HEIF images have a primary image. The metadata item `heif-primary` gives 
 * the page number of the primary.
 *
 * If @thumbnail is %TRUE, then fetch a stored thumbnail rather than the
 * image.
 *
 * See also: vips_image_new_from_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_heifload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;heifload&quot;, ap, filename, out );
	va_end( ap );

	return( result );
}

/**
 * vips_heifload_buffer:
 * @buf: (array length=len) (element-type guint8): memory area to load
 * @len: (type gsize): size of memory area
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (top-level image number) to read
 * * @n: %gint, load this many pages
 * * @thumbnail: %gboolean, fetch thumbnail instead of image
 *
 * Read a HEIF image file into a VIPS image. 
 * Exactly as vips_heifload(), but read from a memory buffer. 
 *
 * You must not free the buffer while @out is active. The 
 * #VipsObject::postclose signal on @out is a good place to free. 
 *
 * See also: vips_heifload().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_heifload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;

	/* We don't take a copy of the data or free it.
	 */
	blob = vips_blob_new( NULL, buf, len );

	va_start( ap, out );
	result = vips_call_split( &quot;heifload_buffer&quot;, ap, blob, out );
	va_end( ap );

	vips_area_unref( VIPS_AREA( blob ) );

	return( result );
}

/**
 * vips_heifload_source:
 * @source: source to load from
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, page (top-level image number) to read
 * * @n: %gint, load this many pages
 * * @thumbnail: %gboolean, fetch thumbnail instead of image
 *
 * Exactly as vips_heifload(), but read from a source. 
 *
 * See also: vips_heifload().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_heifload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;heifload_source&quot;, ap, source, out );
	va_end( ap );

	return( result );
}

/**
 * vips_heifsave: (method)
 * @in: image to save 
 * @filename: file to write to 
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @Q: %gint, quality factor
 * * @lossless: %gboolean, enable lossless encoding
 * * @compression: #VipsForeignHeifCompression, write with this compression
 * * @effort: %gint, encoding effort
 * * @subsample_mode: #VipsForeignSubsample, chroma subsampling mode
 *
 * Write a VIPS image to a file in HEIF format. 
 *
 * Use @Q to set the compression factor. Default 50, which seems to be roughly
 * what the iphone uses. Q 30 gives about the same quality as JPEG Q 75.
 *
 * Set @lossless %TRUE to switch to lossless compression.
 *
 * Use @compression to set the encoder e.g. HEVC, AVC, AV1. It defaults to AV1
 * if the target filename ends with &quot;.avif&quot;, otherwise HEVC.
 *
 * Use @effort to control the CPU effort spent improving compression.
 * This is currently only applicable to AV1 encoders. Defaults to 4, 0 is
 * fastest, 9 is slowest.
 *
 * Chroma subsampling is normally automatically disabled for Q &gt;= 90. You can
 * force the subsampling mode with @subsample_mode.
 *
 * See also: vips_image_write_to_file(), vips_heifload().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_heifsave( VipsImage *in, const char *filename, ... )
{
	va_list ap;
	int result;

	va_start( ap, filename );
	result = vips_call_split( &quot;heifsave&quot;, ap, in, filename );
	va_end( ap );

	return( result );
}

/**
 * vips_heifsave_buffer: (method)
 * @in: image to save 
 * @buf: (array length=len) (element-type guint8): return output buffer here
 * @len: (type gsize): return output length here
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @Q: %gint, quality factor
 * * @lossless: %gboolean, enable lossless encoding
 * * @compression: #VipsForeignHeifCompression, write with this compression
 * * @effort: %gint, encoding effort
 * * @subsample_mode: #VipsForeignSubsample, chroma subsampling mode
 *
 * As vips_heifsave(), but save to a memory buffer. 
 *
 * The address of the buffer is returned in @obuf, the length of the buffer in
 * @olen. You are responsible for freeing the buffer with g_free() when you
 * are done with it.
 *
 * See also: vips_heifsave(), vips_image_write_to_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_heifsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
{
	va_list ap;
	VipsArea *area;
	int result;

	area = NULL; 

	va_start( ap, len );
	result = vips_call_split( &quot;heifsave_buffer&quot;, ap, in, &amp;area );
	va_end( ap );

	if( !result &amp;&amp;
		area ) { 
		if( buf ) {
			*buf = area-&gt;data;
			area-&gt;free_fn = NULL;
		}
		if( len ) 
			*len = area-&gt;length;

		vips_area_unref( area );
	}

	return( result );
}

/**
 * vips_heifsave_target: (method)
 * @in: image to save 
 * @target: save image to this target
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @Q: %gint, quality factor
 * * @lossless: %gboolean, enable lossless encoding
 * * @compression: #VipsForeignHeifCompression, write with this compression
 * * @effort: %gint, encoding effort
 * * @subsample_mode: #VipsForeignSubsample, chroma subsampling mode
 *
 * As vips_heifsave(), but save to a target.
 *
 * See also: vips_heifsave(), vips_image_write_to_target().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_heifsave_target( VipsImage *in, VipsTarget *target, ... )
{
	va_list ap;
	int result;

	va_start( ap, target );
	result = vips_call_split( &quot;heifsave_target&quot;, ap, in, target );
	va_end( ap );

	return( result );
}

/**
 * vips_jxlload:
 * @filename: file to load
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Read a JPEG-XL image. 
 *
 * The JPEG-XL loader and saver are experimental features and may change
 * in future libvips versions.
 *
 * See also: vips_image_new_from_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_jxlload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;jxlload&quot;, ap, filename, out );
	va_end( ap );

	return( result );
}

/**
 * vips_jxlload_buffer:
 * @buf: (array length=len) (element-type guint8): memory area to load
 * @len: (type gsize): size of memory area
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Exactly as vips_jxlload(), but read from a buffer. 
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_jxlload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;

	/* We don't take a copy of the data or free it.
	 */
	blob = vips_blob_new( NULL, buf, len );

	va_start( ap, out );
	result = vips_call_split( &quot;jxlload_buffer&quot;, ap, blob, out );
	va_end( ap );

	vips_area_unref( VIPS_AREA( blob ) );

	return( result );
}

/**
 * vips_jxlload_source:
 * @source: source to load from
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Exactly as vips_jxlload(), but read from a source. 
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_jxlload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;jxlload_source&quot;, ap, source, out );
	va_end( ap );

	return( result );
}

/**
 * vips_jxlsave: (method)
 * @in: image to save 
 * @filename: file to write to 
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @tier: %gint, decode speed tier
 * * @distance: %gdouble, maximum encoding error
 * * @effort: %gint, encoding effort
 * * @lossless: %gboolean, enables lossless compression
 * * @Q: %gint, quality setting
 *
 * Write a VIPS image to a file in JPEG-XL format. 
 *
 * The JPEG-XL loader and saver are experimental features and may change
 * in future libvips versions.
 *
 * @tier sets the overall decode speed the encoder will target. Minimum is 0 
 * (highest quality), and maximum is 4 (lowest quality). Default is 0.
 *
 * @distance sets the target maximum encoding error. Minimum is 0 
 * (highest quality), and maximum is 15 (lowest quality). Default is 1.0
 * (visually lossless). 
 *
 * As a convenience, you can also use @Q to set @distance. @Q uses
 * approximately the same scale as regular JPEG.
 *
 * Set @lossless to enable lossless compresion.
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_jxlsave( VipsImage *in, const char *filename, ... )
{
	va_list ap;
	int result;

	va_start( ap, filename );
	result = vips_call_split( &quot;jxlsave&quot;, ap, in, filename );
	va_end( ap );

	return( result );
}

/**
 * vips_jxlsave_buffer: (method)
 * @in: image to save 
 * @buf: (array length=len) (element-type guint8): return output buffer here
 * @len: (type gsize): return output length here
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @tier: %gint, decode speed tier
 * * @distance: %gdouble, maximum encoding error
 * * @effort: %gint, encoding effort
 * * @lossless: %gboolean, enables lossless compression
 * * @Q: %gint, quality setting
 *
 * As vips_jxlsave(), but save to a memory buffer.
 *
 * See also: vips_jxlsave(), vips_image_write_to_target().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_jxlsave_buffer( VipsImage *in, void **buf, size_t *len, ... )
{
	va_list ap;
	VipsArea *area;
	int result;

	area = NULL; 

	va_start( ap, len );
	result = vips_call_split( &quot;jxlsave_buffer&quot;, ap, in, &amp;area );
	va_end( ap );

	if( !result &amp;&amp;
		area ) { 
		if( buf ) {
			*buf = area-&gt;data;
			area-&gt;free_fn = NULL;
		}
		if( len ) 
			*len = area-&gt;length;

		vips_area_unref( area );
	}

	return( result );
}

/**
 * vips_jxlsave_target: (method)
 * @in: image to save 
 * @target: save image to this target
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @tier: %gint, decode speed tier
 * * @distance: %gdouble, maximum encoding error
 * * @effort: %gint, encoding effort
 * * @lossless: %gboolean, enables lossless compression
 * * @Q: %gint, quality setting
 *
 * As vips_jxlsave(), but save to a target.
 *
 * See also: vips_jxlsave(), vips_image_write_to_target().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_jxlsave_target( VipsImage *in, VipsTarget *target, ... )
{
	va_list ap;
	int result;

	va_start( ap, target );
	result = vips_call_split( &quot;jxlsave_target&quot;, ap, in, target );
	va_end( ap );

	return( result );
}

/**
 * vips_pdfload:
 * @filename: file to load
 * @out: (out): output image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, load this page, numbered from zero
 * * @n: %gint, load this many pages
 * * @dpi: %gdouble, render at this DPI
 * * @scale: %gdouble, scale render by this factor
 * * @background: #VipsArrayDouble background colour
 *
 * Render a PDF file into a VIPS image. 
 *
 * The output image is always RGBA --- CMYK PDFs will be
 * converted. If you need CMYK bitmaps, you should use vips_magickload()
 * instead.
 *
 * Use @page to select a page to render, numbering from zero.
 *
 * Use @n to select the number of pages to render. The default is 1. Pages are
 * rendered in a vertical column, with each individual page aligned to the
 * left. Set to -1 to mean &quot;until the end of the document&quot;. Use vips_grid() 
 * to change page layout.
 *
 * Use @dpi to set the rendering resolution. The default is 72. Additionally,
 * you can scale by setting @scale. If you set both, they combine.
 *
 * Use @background to set the background RGBA colour. The default is 255 
 * (solid white), use eg. 0 for a transparent background.
 *
 * The operation fills a number of header fields with metadata, for example
 * &quot;pdf-author&quot;. They may be useful. 
 *
 * This function only reads the image header and does not render any pixel
 * data. Rendering occurs when pixels are accessed.
 *
 * See also: vips_image_new_from_file(), vips_magickload().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_pdfload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;pdfload&quot;, ap, filename, out );
	va_end( ap );

	return( result );
}

/**
 * vips_pdfload_buffer:
 * @buf: (array length=len) (element-type guint8): memory area to load
 * @len: (type gsize): size of memory area
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, load this page, numbered from zero
 * * @n: %gint, load this many pages
 * * @dpi: %gdouble, render at this DPI
 * * @scale: %gdouble, scale render by this factor
 * * @background: #VipsArrayDouble background colour
 *
 * Read a PDF-formatted memory buffer into a VIPS image. Exactly as
 * vips_pdfload(), but read from memory. 
 *
 * You must not free the buffer while @out is active. The 
 * #VipsObject::postclose signal on @out is a good place to free. 
 *
 * See also: vips_pdfload().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_pdfload_buffer( void *buf, size_t len, VipsImage **out, ... )
{
	va_list ap;
	VipsBlob *blob;
	int result;

	/* We don't take a copy of the data or free it.
	 */
	blob = vips_blob_new( NULL, buf, len );

	va_start( ap, out );
	result = vips_call_split( &quot;pdfload_buffer&quot;, ap, blob, out );
	va_end( ap );

	vips_area_unref( VIPS_AREA( blob ) );

	return( result );
}

/**
 * vips_pdfload_source:
 * @source: source to load from
 * @out: (out): image to write
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @page: %gint, load this page, numbered from zero
 * * @n: %gint, load this many pages
 * * @dpi: %gdouble, render at this DPI
 * * @scale: %gdouble, scale render by this factor
 * * @background: #VipsArrayDouble background colour
 *
 * Exactly as vips_pdfload(), but read from a source. 
 *
 * See also: vips_pdfload()
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_pdfload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;pdfload_source&quot;, ap, source, out );
	va_end( ap );

	return( result );
}

/**
 * vips_openslideload:
 * @filename: file to load
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @level: %gint, load this level
 * * @associated: %gchararray, load this associated image
 * * @attach_associated: %gboolean, attach all associated images as metadata
 * * @autocrop: %gboolean, crop to image bounds
 *
 * Read a virtual slide supported by the OpenSlide library into a VIPS image.
 * OpenSlide supports images in Aperio, Hamamatsu, MIRAX, Sakura, Trestle,
 * and Ventana formats.
 *
 * To facilitate zooming, virtual slide formats include multiple scaled-down
 * versions of the high-resolution image.  These are typically called
 * &quot;levels&quot;.  By default, vips_openslideload() reads the highest-resolution
 * level (level 0).  Set @level to the level number you want.
 *
 * In addition to the slide image itself, virtual slide formats sometimes
 * include additional images, such as a scan of the slide's barcode.
 * OpenSlide calls these &quot;associated images&quot;.  To read an associated image,
 * set @associated to the image's name.
 * A slide's associated images are listed in the
 * &quot;slide-associated-images&quot; metadata item.
 *
 * If you set @attach_associated, then all associated images are attached as
 * metadata items. Use vips_image_get_image() on @out to retrieve them. Images
 * are attached as &quot;openslide-associated-XXXXX&quot;, where XXXXX is the name of the
 * associated image.
 *
 * The output of this operator is always RGBA.
 *
 * See also: vips_image_new_from_file().
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_openslideload( const char *filename, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;openslideload&quot;, ap, filename, out );
	va_end( ap );

	return( result );
}

/**
 * vips_openslideload_source:
 * @source: source to load from
 * @out: (out): decompressed image
 * @...: %NULL-terminated list of optional named arguments
 *
 * Optional arguments:
 *
 * * @level: %gint, load this level
 * * @associated: %gchararray, load this associated image
 * * @attach_associated: %gboolean, attach all associated images as metadata
 * * @autocrop: %gboolean, crop to image bounds
 *
 * Exactly as vips_openslideload(), but read from a source. 
 *
 * Returns: 0 on success, -1 on error.
 */
int
vips_openslideload_source( VipsSource *source, VipsImage **out, ... )
{
	va_list ap;
	int result;

	va_start( ap, out );
	result = vips_call_split( &quot;openslideload_source&quot;, ap, source, out );
	va_end( ap );

	return( result );
}

/* Called from iofuncs to init all operations in this dir. Use a plugin system
 * instead?
 */
void
vips_foreign_operation_init( void )
{
	extern GType vips_foreign_load_rad_file_get_type( void ); 
	extern GType vips_foreign_load_rad_buffer_get_type( void ); 
	extern GType vips_foreign_load_rad_source_get_type( void ); 
	extern GType vips_foreign_save_rad_file_get_type( void ); 
	extern GType vips_foreign_save_rad_buffer_get_type( void ); 
	extern GType vips_foreign_save_rad_target_get_type( void ); 

	extern GType vips_foreign_load_mat_get_type( void ); 

	extern GType vips_foreign_load_ppm_file_get_type( void ); 
	extern GType vips_foreign_load_ppm_source_get_type( void ); 
	extern GType vips_foreign_save_ppm_file_get_type( void ); 
	extern GType vips_foreign_save_ppm_target_get_type( void ); 

	extern GType vips_foreign_load_png_file_get_type( void ); 
	extern GType vips_foreign_load_png_buffer_get_type( void ); 
	extern GType vips_foreign_load_png_source_get_type( void ); 
	extern GType vips_foreign_save_png_file_get_type( void ); 
	extern GType vips_foreign_save_png_buffer_get_type( void ); 
	extern GType vips_foreign_save_png_target_get_type( void ); 

	extern GType vips_foreign_load_csv_file_get_type( void ); 
	extern GType vips_foreign_load_csv_source_get_type( void ); 
	extern GType vips_foreign_save_csv_file_get_type( void ); 
	extern GType vips_foreign_save_csv_target_get_type( void ); 

	extern GType vips_foreign_load_matrix_file_get_type( void ); 
	extern GType vips_foreign_load_matrix_source_get_type( void ); 
	extern GType vips_foreign_save_matrix_file_get_type( void ); 
	extern GType vips_foreign_save_matrix_target_get_type( void ); 
	extern GType vips_foreign_print_matrix_get_type( void ); 

	extern GType vips_foreign_load_fits_file_get_type( void ); 
	extern GType vips_foreign_load_fits_source_get_type( void ); 
	extern GType vips_foreign_save_fits_get_type( void ); 

	extern GType vips_foreign_load_analyze_get_type( void ); 

	extern GType vips_foreign_load_openexr_get_type( void ); 

	extern GType vips_foreign_load_openslide_file_get_type( void ); 
	extern GType vips_foreign_load_openslide_source_get_type( void ); 

	extern GType vips_foreign_load_vips_file_get_type( void ); 
	extern GType vips_foreign_load_vips_source_get_type( void ); 
	extern GType vips_foreign_save_vips_file_get_type( void ); 
	extern GType vips_foreign_save_vips_target_get_type( void ); 

	extern GType vips_foreign_load_jpeg_file_get_type( void ); 
	extern GType vips_foreign_load_jpeg_buffer_get_type( void ); 
	extern GType vips_foreign_load_jpeg_source_get_type( void ); 
	extern GType vips_foreign_save_jpeg_file_get_type( void ); 
	extern GType vips_foreign_save_jpeg_buffer_get_type( void ); 
	extern GType vips_foreign_save_jpeg_target_get_type( void ); 
	extern GType vips_foreign_save_jpeg_mime_get_type( void ); 

	extern GType vips_foreign_load_tiff_file_get_type( void ); 
	extern GType vips_foreign_load_tiff_buffer_get_type( void ); 
	extern GType vips_foreign_load_tiff_source_get_type( void ); 
	extern GType vips_foreign_save_tiff_file_get_type( void ); 
	extern GType vips_foreign_save_tiff_buffer_get_type( void ); 

	extern GType vips_foreign_load_raw_get_type( void ); 
	extern GType vips_foreign_save_raw_get_type( void ); 
	extern GType vips_foreign_save_raw_fd_get_type( void ); 

	extern GType vips_foreign_load_magick_file_get_type( void ); 
	extern GType vips_foreign_load_magick_buffer_get_type( void ); 
	extern GType vips_foreign_load_magick7_file_get_type( void ); 
	extern GType vips_foreign_load_magick7_buffer_get_type( void ); 
	extern GType vips_foreign_save_magick_file_get_type( void );
	extern GType vips_foreign_save_magick_buffer_get_type( void );

	extern GType vips_foreign_save_dz_file_get_type( void ); 
	extern GType vips_foreign_save_dz_buffer_get_type( void ); 

	extern GType vips_foreign_load_webp_file_get_type( void ); 
	extern GType vips_foreign_load_webp_buffer_get_type( void ); 
	extern GType vips_foreign_load_webp_source_get_type( void ); 
	extern GType vips_foreign_save_webp_file_get_type( void ); 
	extern GType vips_foreign_save_webp_buffer_get_type( void ); 
	extern GType vips_foreign_save_webp_target_get_type( void ); 

	extern GType vips_foreign_load_pdf_file_get_type( void ); 
	extern GType vips_foreign_load_pdf_buffer_get_type( void ); 
	extern GType vips_foreign_load_pdf_source_get_type( void ); 

	extern GType vips_foreign_load_svg_file_get_type( void ); 
	extern GType vips_foreign_load_svg_buffer_get_type( void ); 
	extern GType vips_foreign_load_svg_source_get_type( void ); 

	extern GType vips_foreign_load_jp2k_file_get_type( void ); 
	extern GType vips_foreign_load_jp2k_buffer_get_type( void ); 
	extern GType vips_foreign_load_jp2k_source_get_type( void ); 
	extern GType vips_foreign_save_jp2k_file_get_type( void ); 
	extern GType vips_foreign_save_jp2k_buffer_get_type( void ); 
	extern GType vips_foreign_save_jp2k_target_get_type( void ); 

	extern GType vips_foreign_load_jxl_file_get_type( void ); 
	extern GType vips_foreign_load_jxl_buffer_get_type( void ); 
	extern GType vips_foreign_load_jxl_source_get_type( void ); 
	extern GType vips_foreign_save_jxl_file_get_type( void ); 
	extern GType vips_foreign_save_jxl_buffer_get_type( void ); 
	extern GType vips_foreign_save_jxl_target_get_type( void ); 

	extern GType vips_foreign_load_heif_file_get_type( void ); 
	extern GType vips_foreign_load_heif_buffer_get_type( void ); 
	extern GType vips_foreign_load_heif_source_get_type( void ); 
	extern GType vips_foreign_save_heif_file_get_type( void ); 
	extern GType vips_foreign_save_heif_buffer_get_type( void ); 
	extern GType vips_foreign_save_heif_target_get_type( void ); 

	extern GType vips_foreign_load_nifti_file_get_type( void ); 
	extern GType vips_foreign_load_nifti_source_get_type( void ); 
	extern GType vips_foreign_save_nifti_get_type( void ); 

	extern GType vips_foreign_load_nsgif_file_get_type( void ); 
	extern GType vips_foreign_load_nsgif_buffer_get_type( void ); 
	extern GType vips_foreign_load_nsgif_source_get_type( void ); 

	extern GType vips_foreign_save_cgif_file_get_type( void );
	extern GType vips_foreign_save_cgif_buffer_get_type( void );
	extern GType vips_foreign_save_cgif_target_get_type( void );

	vips_foreign_load_csv_file_get_type(); 
	vips_foreign_load_csv_source_get_type(); 
	vips_foreign_save_csv_file_get_type(); 
	vips_foreign_save_csv_target_get_type(); 

	vips_foreign_load_matrix_file_get_type(); 
	vips_foreign_load_matrix_source_get_type(); 
	vips_foreign_save_matrix_file_get_type(); 
	vips_foreign_save_matrix_target_get_type(); 
	vips_foreign_print_matrix_get_type(); 

	vips_foreign_load_raw_get_type(); 
	vips_foreign_save_raw_get_type(); 
	vips_foreign_save_raw_fd_get_type(); 

	vips_foreign_load_vips_file_get_type(); 
	vips_foreign_load_vips_source_get_type(); 
	vips_foreign_save_vips_file_get_type(); 
	vips_foreign_save_vips_target_get_type(); 

#ifdef HAVE_ANALYZE
	vips_foreign_load_analyze_get_type(); 
#endif /*HAVE_ANALYZE*/

#ifdef HAVE_PPM
	vips_foreign_load_ppm_file_get_type(); 
	vips_foreign_load_ppm_source_get_type(); 
	vips_foreign_save_ppm_file_get_type(); 
	vips_foreign_save_ppm_target_get_type(); 
#endif /*HAVE_PPM*/

#ifdef HAVE_RADIANCE
	vips_foreign_load_rad_file_get_type(); 
	vips_foreign_load_rad_buffer_get_type(); 
	vips_foreign_load_rad_source_get_type(); 
	vips_foreign_save_rad_file_get_type(); 
	vips_foreign_save_rad_buffer_get_type(); 
	vips_foreign_save_rad_target_get_type(); 
#endif /*HAVE_RADIANCE*/

#if defined(HAVE_POPPLER) &amp;&amp; !defined(POPPLER_MODULE)
	vips_foreign_load_pdf_file_get_type(); 
	vips_foreign_load_pdf_buffer_get_type(); 
	vips_foreign_load_pdf_source_get_type(); 
#endif /*defined(HAVE_POPPLER) &amp;&amp; !defined(POPPLER_MODULE)*/

#ifdef HAVE_PDFIUM
	vips_foreign_load_pdf_file_get_type(); 
	vips_foreign_load_pdf_buffer_get_type(); 
	vips_foreign_load_pdf_source_get_type(); 
#endif /*HAVE_PDFIUM*/

#ifdef HAVE_RSVG
	vips_foreign_load_svg_file_get_type(); 
	vips_foreign_load_svg_buffer_get_type(); 
	vips_foreign_load_svg_source_get_type(); 
#endif /*HAVE_RSVG*/

#if defined(HAVE_LIBJXL) &amp;&amp; !defined(LIBJXL_MODULE)
	vips_foreign_load_jxl_file_get_type(); 
	vips_foreign_load_jxl_buffer_get_type(); 
	vips_foreign_load_jxl_source_get_type(); 
	vips_foreign_save_jxl_file_get_type(); 
	vips_foreign_save_jxl_buffer_get_type(); 
	vips_foreign_save_jxl_target_get_type(); 
#endif /*defined(HAVE_LIBJXL) &amp;&amp; !defined(LIBJXL_MODULE)*/

#ifdef HAVE_LIBOPENJP2
	vips_foreign_load_jp2k_file_get_type(); 
	vips_foreign_load_jp2k_buffer_get_type(); 
	vips_foreign_load_jp2k_source_get_type(); 
	vips_foreign_save_jp2k_file_get_type(); 
	vips_foreign_save_jp2k_buffer_get_type(); 
	vips_foreign_save_jp2k_target_get_type(); 
#endif /*HAVE_LIBOPENJP2*/

#ifdef HAVE_NSGIF
	vips_foreign_load_nsgif_file_get_type();
	vips_foreign_load_nsgif_buffer_get_type(); 
	vips_foreign_load_nsgif_source_get_type(); 
#endif /*HAVE_NSGIF*/

#ifdef HAVE_CGIF
	vips_foreign_save_cgif_file_get_type();
	vips_foreign_save_cgif_buffer_get_type();
	vips_foreign_save_cgif_target_get_type();
#endif /*HAVE_CGIF*/

#ifdef HAVE_GSF
	vips_foreign_save_dz_file_get_type(); 
	vips_foreign_save_dz_buffer_get_type(); 
#endif /*HAVE_GSF*/

#ifdef HAVE_PNG
	vips_foreign_load_png_file_get_type(); 
	vips_foreign_load_png_buffer_get_type(); 
	vips_foreign_load_png_source_get_type(); 
	vips_foreign_save_png_file_get_type(); 
	vips_foreign_save_png_buffer_get_type(); 
	vips_foreign_save_png_target_get_type(); 
#endif /*HAVE_PNG*/

#ifdef HAVE_SPNG
	vips_foreign_load_png_file_get_type(); 
	vips_foreign_load_png_buffer_get_type(); 
	vips_foreign_load_png_source_get_type(); 
#endif /*HAVE_SPNG*/

#ifdef HAVE_MATIO
	vips_foreign_load_mat_get_type(); 
#endif /*HAVE_MATIO*/

#ifdef HAVE_JPEG
	vips_foreign_load_jpeg_file_get_type(); 
	vips_foreign_load_jpeg_buffer_get_type(); 
	vips_foreign_load_jpeg_source_get_type(); 
	vips_foreign_save_jpeg_file_get_type(); 
	vips_foreign_save_jpeg_buffer_get_type(); 
	vips_foreign_save_jpeg_target_get_type(); 
	vips_foreign_save_jpeg_mime_get_type(); 
#endif /*HAVE_JPEG*/

#ifdef HAVE_LIBWEBP
	vips_foreign_load_webp_file_get_type(); 
	vips_foreign_load_webp_buffer_get_type(); 
	vips_foreign_load_webp_source_get_type(); 
	vips_foreign_save_webp_file_get_type(); 
	vips_foreign_save_webp_buffer_get_type(); 
	vips_foreign_save_webp_target_get_type(); 
#endif /*HAVE_LIBWEBP*/

#ifdef HAVE_TIFF
	vips_foreign_load_tiff_file_get_type(); 
	vips_foreign_load_tiff_buffer_get_type(); 
	vips_foreign_load_tiff_source_get_type(); 
	vips_foreign_save_tiff_file_get_type(); 
	vips_foreign_save_tiff_buffer_get_type(); 
#endif /*HAVE_TIFF*/

#if defined(HAVE_OPENSLIDE) &amp;&amp; !defined(OPENSLIDE_MODULE)
	vips_foreign_load_openslide_file_get_type(); 
	vips_foreign_load_openslide_source_get_type(); 
#endif /*defined(HAVE_OPENSLIDE) &amp;&amp; !defined(OPENSLIDE_MODULE)*/

#if defined(ENABLE_MAGICKLOAD) &amp;&amp; !defined(MAGICK_MODULE)
#ifdef HAVE_MAGICK6
	vips_foreign_load_magick_file_get_type();
	vips_foreign_load_magick_buffer_get_type();
#endif /*HAVE_MAGICK6*/

#ifdef HAVE_MAGICK7
	vips_foreign_load_magick7_file_get_type();
	vips_foreign_load_magick7_buffer_get_type();
#endif /*HAVE_MAGICK7*/
#endif /*defined(ENABLE_MAGICKLOAD) &amp;&amp; !defined(MAGICK_MODULE)*/

#if defined(ENABLE_MAGICKSAVE) &amp;&amp; !defined(MAGICK_MODULE)
	vips_foreign_save_magick_file_get_type();
	vips_foreign_save_magick_buffer_get_type();
#endif /*defined(ENABLE_MAGICKSAVE) &amp;&amp; !defined(MAGICK_MODULE)*/

#ifdef HAVE_CFITSIO
	vips_foreign_load_fits_file_get_type(); 
	vips_foreign_load_fits_source_get_type(); 
	vips_foreign_save_fits_get_type(); 
#endif /*HAVE_CFITSIO*/

#ifdef HAVE_OPENEXR
	vips_foreign_load_openexr_get_type(); 
#endif /*HAVE_OPENEXR*/

#ifdef HAVE_NIFTI
	vips_foreign_load_nifti_file_get_type(); 
	vips_foreign_load_nifti_source_get_type(); 
	vips_foreign_save_nifti_get_type(); 
#endif /*HAVE_NIFTI*/

#if defined(HAVE_HEIF_DECODER) &amp;&amp; !defined(HEIF_MODULE)
	vips_foreign_load_heif_file_get_type(); 
	vips_foreign_load_heif_buffer_get_type(); 
	vips_foreign_load_heif_source_get_type(); 
#endif /*defined(HAVE_HEIF_DECODER) &amp;&amp; !defined(HEIF_MODULE)*/

#if defined(HAVE_HEIF_ENCODER) &amp;&amp; !defined(HEIF_MODULE)
	vips_foreign_save_heif_file_get_type(); 
	vips_foreign_save_heif_buffer_get_type(); 
	vips_foreign_save_heif_target_get_type(); 
#endif /*defined(HAVE_HEIF_ENCODER) &amp;&amp; !defined(HEIF_MODULE)*/

	vips__foreign_load_operation = 
		g_quark_from_static_string( &quot;vips-foreign-load-operation&quot; ); 
}
</PRE>
</div>
  </div>
</body>
</html>
