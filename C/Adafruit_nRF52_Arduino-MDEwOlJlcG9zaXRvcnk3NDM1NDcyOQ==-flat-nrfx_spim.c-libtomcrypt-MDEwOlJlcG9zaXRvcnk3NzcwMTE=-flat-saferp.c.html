
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.320754716981133%, Tokens: 8</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_spim.c</h3>
            <pre><code>1  #include <nrfx.h>
2  #if NRFX_CHECK(NRFX_SPIM_ENABLED)
3  #if !(NRFX_CHECK(NRFX_SPIM0_ENABLED) || NRFX_CHECK(NRFX_SPIM1_ENABLED) || \
4        NRFX_CHECK(NRFX_SPIM2_ENABLED) || NRFX_CHECK(NRFX_SPIM3_ENABLED) || \
5        NRFX_CHECK(NRFX_SPIM4_ENABLED))
6  #error "No enabled SPIM instances. Check <nrfx_config.h>."
7  #endif
8  #include <nrfx_spim.h>
9  #include "prs/nrfx_prs.h"
10  #include <hal/nrf_gpio.h>
11  #define NRFX_LOG_MODULE SPIM
12  #include <nrfx_log.h>
13  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED) && \
14      ((!NRF_SPIM_HW_CSN_PRESENT) || !(NRF_SPIM_DCX_PRESENT) || !(NRF_SPIM_RXDELAY_PRESENT))
15  #error "Extended options are not available in the SoC currently in use."
16  #endif
17  #define SPIMX_LENGTH_VALIDATE(peripheral, drv_inst_idx, rx_len, tx_len) \
18      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
19       NRFX_EASYDMA_LENGTH_VALIDATE(peripheral, rx_len, tx_len))
20  #define SPIMX_HW_CSN_PRESENT_VALIDATE(peripheral, drv_inst_idx)         \
21      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
22       NRFX_CONCAT_2(peripheral, _FEATURE_HARDWARE_CSN_PRESENT))
23  #define SPIMX_DCX_PRESENT_VALIDATE(peripheral, drv_inst_idx)            \
24      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
25      NRFX_CONCAT_2(peripheral, _FEATURE_DCX_PRESENT))
26  #define SPIMX_SUPPORTED_FREQ_VALIDATE(peripheral, drv_inst_idx, freq)                            \
27      (                                                                                            \
28      ((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) &&                           \
29      (                                                                                            \
30          (((freq) != NRF_SPIM_FREQ_16M) && ((freq) != NRF_SPIM_FREQ_32M)) ||                      \
31          (((freq) == NRF_SPIM_FREQ_16M) && ((NRFX_CONCAT_2(peripheral, _MAX_DATARATE) >= 16))) || \
32          (((freq) == NRF_SPIM_FREQ_32M) && ((NRFX_CONCAT_2(peripheral, _MAX_DATARATE) >= 32)))    \
33      )                                                                                            \
34      )
35  #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
36  #define SPIM0_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM0, __VA_ARGS__)
37  #define SPIM0_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM0, __VA_ARGS__)
38  #define SPIM0_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM0, __VA_ARGS__)
39  #define SPIM0_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM0, __VA_ARGS__)
40  #else
41  #define SPIM0_LENGTH_VALIDATE(...)          0
42  #define SPIM0_HW_CSN_PRESENT_VALIDATE(...)  0
43  #define SPIM0_DCX_PRESENT_VALIDATE(...)     0
44  #define SPIM0_SUPPORTED_FREQ_VALIDATE(...)  0
45  #endif
46  #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
47  #define SPIM1_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM1, __VA_ARGS__)
48  #define SPIM1_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM1, __VA_ARGS__)
49  #define SPIM1_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM1, __VA_ARGS__)
50  #define SPIM1_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM1, __VA_ARGS__)
51  #else
52  #define SPIM1_LENGTH_VALIDATE(...)          0
53  #define SPIM1_HW_CSN_PRESENT_VALIDATE(...)  0
54  #define SPIM1_DCX_PRESENT_VALIDATE(...)     0
55  #define SPIM1_SUPPORTED_FREQ_VALIDATE(...)  0
56  #endif
57  #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
58  #define SPIM2_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM2, __VA_ARGS__)
59  #define SPIM2_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM2, __VA_ARGS__)
60  #define SPIM2_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM2, __VA_ARGS__)
61  #define SPIM2_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM2, __VA_ARGS__)
62  #else
63  #define SPIM2_LENGTH_VALIDATE(...)          0
64  #define SPIM2_HW_CSN_PRESENT_VALIDATE(...)  0
65  #define SPIM2_DCX_PRESENT_VALIDATE(...)     0
66  #define SPIM2_SUPPORTED_FREQ_VALIDATE(...)  0
67  #endif
68  #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
69  #define SPIM3_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM3, __VA_ARGS__)
70  #define SPIM3_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM3, __VA_ARGS__)
71  #define SPIM3_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM3, __VA_ARGS__)
72  #define SPIM3_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM3, __VA_ARGS__)
73  #else
74  #define SPIM3_LENGTH_VALIDATE(...)          0
75  #define SPIM3_HW_CSN_PRESENT_VALIDATE(...)  0
76  #define SPIM3_DCX_PRESENT_VALIDATE(...)     0
77  #define SPIM3_SUPPORTED_FREQ_VALIDATE(...)  0
78  #endif
79  #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
80  #define SPIM4_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM4, __VA_ARGS__)
81  #define SPIM4_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM4, __VA_ARGS__)
82  #define SPIM4_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM4, __VA_ARGS__)
83  #define SPIM4_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM4, __VA_ARGS__)
84  #else
85  #define SPIM4_LENGTH_VALIDATE(...)          0
86  #define SPIM4_HW_CSN_PRESENT_VALIDATE(...)  0
87  #define SPIM4_DCX_PRESENT_VALIDATE(...)     0
88  #define SPIM4_SUPPORTED_FREQ_VALIDATE(...)  0
89  #endif
90  #define SPIM_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len)  \
91      (SPIM0_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
92       SPIM1_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
93       SPIM2_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
94       SPIM3_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
95       SPIM4_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len))
96  #define SPIM_HW_CSN_PRESENT_VALIDATE(drv_inst_idx)  \
97      (SPIM0_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
98       SPIM1_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
99       SPIM2_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
100       SPIM3_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
101       SPIM4_HW_CSN_PRESENT_VALIDATE(drv_inst_idx))
102  #define SPIM_DCX_PRESENT_VALIDATE(drv_inst_idx)  \
103      (SPIM0_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
104       SPIM1_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
105       SPIM2_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
106       SPIM3_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
107       SPIM4_DCX_PRESENT_VALIDATE(drv_inst_idx))
108  #define SPIM_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq)  \
109      (SPIM0_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
110       SPIM1_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
111       SPIM2_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
112       SPIM3_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
113       SPIM4_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq))
114  #if defined(NRF52840_XXAA) && (NRFX_CHECK(NRFX_SPIM3_ENABLED))
115  #define USE_WORKAROUND_FOR_ANOMALY_195
116  #endif
117  typedef struct
118  {
119      nrfx_spim_evt_handler_t handler;
120      void *                  p_context;
121      nrfx_spim_evt_t         evt;  
122      nrfx_drv_state_t        state;
123      volatile bool           transfer_in_progress;
124  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
125      bool                    use_hw_ss;
126  #endif
127      bool            ss_active_high;
128      uint8_t         ss_pin;
129      uint8_t         miso_pin;
130      uint8_t         orc;
131  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
132      size_t          tx_length;
133      size_t          rx_length;
134  #endif
135  } spim_control_block_t;
136  static spim_control_block_t m_cb[NRFX_SPIM_ENABLED_COUNT];
137  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
138  static uint32_t m_anomaly_198_preserved_value;
139  static void anomaly_198_enable(uint8_t const * p_buffer, size_t buf_len)
140  {
141      m_anomaly_198_preserved_value = *((volatile uint32_t *)0x40000E00);
<span onclick='openModal()' class='match'>142      if (buf_len == 0)
143      {
144          return;
145      }
146      uint32_t buffer_end_addr = ((uint32_t)p_buffer) + buf_len;
147      uint32_t block_addr      = ((uint32_t)p_buffer) & ~0x1FFF;
148      uint32_t block_flag      = (1UL << ((block_addr >> 13) & 0xFFFF));
149      uint32_t occupied_blocks = 0;
</span>150      if (block_addr >= 0x20010000)
151      {
152          occupied_blocks = (1UL << 8);
153      }
154      else
155      {
156          do {
157              occupied_blocks |= block_flag;
158              block_flag <<= 1;
159              block_addr  += 0x2000;
160          } while ((block_addr < buffer_end_addr) && (block_addr < 0x20012000));
161      }
162      *((volatile uint32_t *)0x40000E00) = occupied_blocks;
163  }
164  static void anomaly_198_disable(void)
165  {
166      *((volatile uint32_t *)0x40000E00) = m_anomaly_198_preserved_value;
167  }
168  #endif 
169  nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
170                            nrfx_spim_config_t const * p_config,
171                            nrfx_spim_evt_handler_t    handler,
172                            void *                     p_context)
173  {
174      NRFX_ASSERT(p_config);
175      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
176      nrfx_err_t err_code;
177      if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
178      {
179          err_code = NRFX_ERROR_INVALID_STATE;
180          NRFX_LOG_WARNING("Function: %s, error code: %s.",
181                           __func__,
182                           NRFX_LOG_ERROR_STRING_GET(err_code));
183          return err_code;
184      }
185  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
186      if (
187          (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
188          ((p_config->use_hw_ss) &&
189           !SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx)) ||
190          ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
191           !SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
192          )
193      {
194          err_code = NRFX_ERROR_NOT_SUPPORTED;
195          NRFX_LOG_WARNING("Function: %s, error code: %s.",
196                           __func__,
197                           NRFX_LOG_ERROR_STRING_GET(err_code));
198          return err_code;
199      }
200  #endif
201      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
202  #if NRFX_CHECK(NRFX_PRS_ENABLED)
203      static nrfx_irq_handler_t const irq_handlers[NRFX_SPIM_ENABLED_COUNT] = {
204          #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
205          nrfx_spim_0_irq_handler,
206          #endif
207          #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
208          nrfx_spim_1_irq_handler,
209          #endif
210          #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
211          nrfx_spim_2_irq_handler,
212          #endif
213          #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
214          nrfx_spim_3_irq_handler,
215          #endif
216          #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
217          nrfx_spim_4_irq_handler,
218          #endif
219      };
220      if (nrfx_prs_acquire(p_instance->p_reg,
221              irq_handlers[p_instance->drv_inst_idx]) != NRFX_SUCCESS)
222      {
223          err_code = NRFX_ERROR_BUSY;
224          NRFX_LOG_WARNING("Function: %s, error code: %s.",
225                           __func__,
226                           NRFX_LOG_ERROR_STRING_GET(err_code));
227          return err_code;
228      }
229  #endif 
230      p_cb->handler = handler;
231      p_cb->p_context = p_context;
232      uint32_t mosi_pin;
233      uint32_t miso_pin;
234      if (p_config->mode <= NRF_SPIM_MODE_1)
235      {
236          nrf_gpio_pin_clear(p_config->sck_pin);
237      }
238      else
239      {
240          nrf_gpio_pin_set(p_config->sck_pin);
241      }
242      nrf_gpio_cfg(p_config->sck_pin,
243                   NRF_GPIO_PIN_DIR_OUTPUT,
244                   NRF_GPIO_PIN_INPUT_CONNECT,
245                   NRF_GPIO_PIN_NOPULL,
246                   NRF_GPIO_PIN_S0S1,
247                   NRF_GPIO_PIN_NOSENSE);
248      if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
249      {
250          mosi_pin = p_config->mosi_pin;
251          nrf_gpio_pin_clear(mosi_pin);
252          nrf_gpio_cfg_output(mosi_pin);
253      }
254      else
255      {
256          mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
257      }
258      if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
259      {
260          miso_pin = p_config->miso_pin;
261          nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
262      }
263      else
264      {
265          miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
266      }
267      p_cb->miso_pin = p_config->miso_pin;
268      p_cb->ss_pin = p_config->ss_pin;
269      if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
270      {
271          if (p_config->ss_active_high)
272          {
273              nrf_gpio_pin_clear(p_config->ss_pin);
274          }
275          else
276          {
277              nrf_gpio_pin_set(p_config->ss_pin);
278          }
279          nrf_gpio_cfg_output(p_config->ss_pin);
280  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
281          if (p_config->use_hw_ss)
282          {
283              p_cb->use_hw_ss = p_config->use_hw_ss;
284              nrf_spim_csn_configure(p_spim,
285                                     p_config->ss_pin,
286                                     (p_config->ss_active_high == true ?
287                                          NRF_SPIM_CSN_POL_HIGH : NRF_SPIM_CSN_POL_LOW),
288                                     p_config->ss_duration);
289          }
290  #endif
291          p_cb->ss_active_high = p_config->ss_active_high;
292      }
293  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
294      if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
295      {
296          nrf_gpio_pin_set(p_config->dcx_pin);
297          nrf_gpio_cfg_output(p_config->dcx_pin);
298          nrf_spim_dcx_pin_set(p_spim, p_config->dcx_pin);
299      }
300      nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
301  #endif
302      nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
303      nrf_spim_frequency_set(p_spim, p_config->frequency);
304      nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
305      nrf_spim_orc_set(p_spim, p_config->orc);
306      if (p_cb->handler)
307      {
308          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_END_MASK);
309      }
310      nrf_spim_enable(p_spim);
311      if (p_cb->handler)
312      {
313          NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
314              p_config->irq_priority);
315          NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
316      }
317      p_cb->transfer_in_progress = false;
318      p_cb->state = NRFX_DRV_STATE_INITIALIZED;
319      err_code = NRFX_SUCCESS;
320      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
321      return err_code;
322  }
323  void nrfx_spim_uninit(nrfx_spim_t const * p_instance)
324  {
325      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
326      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
327      if (p_cb->handler)
328      {
329          NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
330      }
331      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
332      if (p_cb->handler)
333      {
334          nrf_spim_int_disable(p_spim, NRF_SPIM_ALL_INTS_MASK);
335          if (p_cb->transfer_in_progress)
336          {
337              nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_STOP);
338              while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED))
339              {}
340              p_cb->transfer_in_progress = false;
341          }
342      }
343      if (p_cb->miso_pin != NRFX_SPIM_PIN_NOT_USED)
344      {
345          nrf_gpio_cfg_default(p_cb->miso_pin);
346      }
347      nrf_spim_disable(p_spim);
348  #ifdef USE_WORKAROUND_FOR_ANOMALY_195
349      if (p_spim == NRF_SPIM3)
350      {
351          *(volatile uint32_t *)0x4002F004 = 1;
352      }
353  #endif
354  #if NRFX_CHECK(NRFX_PRS_ENABLED)
355      nrfx_prs_release(p_instance->p_reg);
356  #endif
357      p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
358  }
359  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
360  nrfx_err_t nrfx_spim_xfer_dcx(nrfx_spim_t const *           p_instance,
361                                nrfx_spim_xfer_desc_t const * p_xfer_desc,
362                                uint32_t                      flags,
363                                uint8_t                       cmd_length)
364  {
365      NRFX_ASSERT(cmd_length <= NRF_SPIM_DCX_CNT_ALL_CMD);
366      nrf_spim_dcx_cnt_set((NRF_SPIM_Type *)p_instance->p_reg, cmd_length);
367      return nrfx_spim_xfer(p_instance, p_xfer_desc, 0);
368  }
369  #endif
370  static void finish_transfer(spim_control_block_t * p_cb)
371  {
372      if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
373      {
374  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
375          if (!p_cb->use_hw_ss)
376  #endif
377          {
378              if (p_cb->ss_active_high)
379              {
380                  nrf_gpio_pin_clear(p_cb->ss_pin);
381              }
382              else
383              {
384                  nrf_gpio_pin_set(p_cb->ss_pin);
385              }
386          }
387      }
388      p_cb->transfer_in_progress = false;
389      p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
390      p_cb->handler(&p_cb->evt, p_cb->p_context);
391  }
392  static void spim_int_enable(NRF_SPIM_Type * p_spim, bool enable)
393  {
394      if (!enable)
395      {
396          nrf_spim_int_disable(p_spim, NRF_SPIM_INT_END_MASK);
397      }
398      else
399      {
400          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_END_MASK);
401      }
402  }
403  static void spim_list_enable_handle(NRF_SPIM_Type * p_spim, uint32_t flags)
404  {
405      if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
406      {
407          nrf_spim_tx_list_enable(p_spim);
408      }
409      else
410      {
411          nrf_spim_tx_list_disable(p_spim);
412      }
413      if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
414      {
415          nrf_spim_rx_list_enable(p_spim);
416      }
417      else
418      {
419          nrf_spim_rx_list_disable(p_spim);
420      }
421  }
422  static nrfx_err_t spim_xfer(NRF_SPIM_Type               * p_spim,
423                              spim_control_block_t        * p_cb,
424                              nrfx_spim_xfer_desc_t const * p_xfer_desc,
425                              uint32_t                      flags)
426  {
427      nrfx_err_t err_code;
428      if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
429          (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
430      {
431          p_cb->transfer_in_progress = false;
432          err_code = NRFX_ERROR_INVALID_ADDR;
433          NRFX_LOG_WARNING("Function: %s, error code: %s.",
434                           __func__,
435                           NRFX_LOG_ERROR_STRING_GET(err_code));
436          return err_code;
437      }
438  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
439      p_cb->tx_length = 0;
440      p_cb->rx_length = 0;
441  #endif
442      nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
443      nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
444  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
445      if (p_spim == NRF_SPIM3)
446      {
447          anomaly_198_enable(p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
448      }
449  #endif
450      nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
451      spim_list_enable_handle(p_spim, flags);
452      if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
453      {
454          nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
455      }
456  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
457      if (flags & NRFX_SPIM_FLAG_HOLD_XFER)
458      {
459          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_STARTED);
460          p_cb->tx_length = p_xfer_desc->tx_length;
461          p_cb->rx_length = p_xfer_desc->rx_length;
462          nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, 0);
463          nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, 0);
464          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_STARTED_MASK);
465      }
466  #endif
467      if (!p_cb->handler)
468      {
469          while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END)){}
470  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
471          if (p_spim == NRF_SPIM3)
472          {
473              anomaly_198_disable();
474          }
475  #endif
476          if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
477          {
478  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
479              if (!p_cb->use_hw_ss)
480  #endif
481              {
482                  if (p_cb->ss_active_high)
483                  {
484                      nrf_gpio_pin_clear(p_cb->ss_pin);
485                  }
486                  else
487                  {
488                      nrf_gpio_pin_set(p_cb->ss_pin);
489                  }
490              }
491          }
492      }
493      else
494      {
495          spim_int_enable(p_spim, !(flags & NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER));
496      }
497      err_code = NRFX_SUCCESS;
498      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
499      return err_code;
500  }
501  nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
502                            nrfx_spim_xfer_desc_t const * p_xfer_desc,
503                            uint32_t                      flags)
504  {
505      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
506      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
507      NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
508      NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
509      NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
510                                       p_xfer_desc->rx_length,
511                                       p_xfer_desc->tx_length));
512      nrfx_err_t err_code = NRFX_SUCCESS;
513      if (p_cb->transfer_in_progress)
514      {
515          err_code = NRFX_ERROR_BUSY;
516          NRFX_LOG_WARNING("Function: %s, error code: %s.",
517                           __func__,
518                           NRFX_LOG_ERROR_STRING_GET(err_code));
519          return err_code;
520      }
521      else
522      {
523          if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
524                                          NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
525          {
526              p_cb->transfer_in_progress = true;
527          }
528      }
529      p_cb->evt.xfer_desc = *p_xfer_desc;
530      if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
531      {
532  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
533          if (!p_cb->use_hw_ss)
534  #endif
535          {
536              if (p_cb->ss_active_high)
537              {
538                  nrf_gpio_pin_set(p_cb->ss_pin);
539              }
540              else
541              {
542                  nrf_gpio_pin_clear(p_cb->ss_pin);
543              }
544          }
545      }
546      return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
547  }
548  void nrfx_spim_abort(nrfx_spim_t const * p_instance)
549  {
550      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
551      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
552      nrf_spim_task_trigger(p_instance->p_reg, NRF_SPIM_TASK_STOP);
553      while (!nrf_spim_event_check(p_instance->p_reg, NRF_SPIM_EVENT_STOPPED))
554      {}
555      p_cb->transfer_in_progress = false;
556  }
557  uint32_t nrfx_spim_start_task_get(nrfx_spim_t const * p_instance)
558  {
559      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
560      return nrf_spim_task_address_get(p_spim, NRF_SPIM_TASK_START);
561  }
562  uint32_t nrfx_spim_end_event_get(nrfx_spim_t const * p_instance)
563  {
564      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
565      return nrf_spim_event_address_get(p_spim, NRF_SPIM_EVENT_END);
566  }
567  static void irq_handler(NRF_SPIM_Type * p_spim, spim_control_block_t * p_cb)
568  {
569  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
570      if ((nrf_spim_int_enable_check(p_spim, NRF_SPIM_INT_STARTED_MASK)) &&
571          (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STARTED)) )
572      {
573          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_STARTED);
574          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
575          NRFX_ASSERT(p_spim->TXD.MAXCNT == 0);
576          p_spim->TXD.MAXCNT = p_cb->tx_length;
577          NRFX_ASSERT(p_spim->RXD.MAXCNT == 0);
578          p_spim->RXD.MAXCNT = p_cb->rx_length;
579          nrf_spim_int_disable(p_spim, NRF_SPIM_INT_STARTED_MASK);
580          nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
581          return;
582      }
583  #endif
584      if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
585      {
586  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
587          if (p_spim == NRF_SPIM3)
588          {
589              anomaly_198_disable();
590          }
591  #endif
592          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
593          NRFX_ASSERT(p_cb->handler);
594          NRFX_LOG_DEBUG("Event: NRF_SPIM_EVENT_END.");
595          finish_transfer(p_cb);
596      }
597  }
598  #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
599  void nrfx_spim_0_irq_handler(void)
600  {
601      irq_handler(NRF_SPIM0, &m_cb[NRFX_SPIM0_INST_IDX]);
602  }
603  #endif
604  #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
605  void nrfx_spim_1_irq_handler(void)
606  {
607      irq_handler(NRF_SPIM1, &m_cb[NRFX_SPIM1_INST_IDX]);
608  }
609  #endif
610  #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
611  void nrfx_spim_2_irq_handler(void)
612  {
613      irq_handler(NRF_SPIM2, &m_cb[NRFX_SPIM2_INST_IDX]);
614  }
615  #endif
616  #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
617  void nrfx_spim_3_irq_handler(void)
618  {
619      irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
620  }
621  #endif
622  #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
623  void nrfx_spim_4_irq_handler(void)
624  {
625      irq_handler(NRF_SPIM4, &m_cb[NRFX_SPIM4_INST_IDX]);
626  }
627  #endif
628  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-saferp.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SAFERP
3  #define LTC_SAFER_TAB_C
4  #include "safer_tab.c"
5  const struct ltc_cipher_descriptor saferp_desc =
6  {
7      "safer+",
8      4,
9      16, 32, 16, 8,
10      &saferp_setup,
11      &saferp_ecb_encrypt,
12      &saferp_ecb_decrypt,
13      &saferp_test,
14      &saferp_done,
15      &saferp_keysize,
16      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
17  };
18  #define ROUND(b, i) do {                                                                         \
19      b[0]  = (safer_ebox[(b[0] ^ skey->saferp.K[i][0]) & 255] + skey->saferp.K[i+1][0]) & 255;    \
20      b[1]  = safer_lbox[(b[1] + skey->saferp.K[i][1]) & 255] ^ skey->saferp.K[i+1][1];            \
21      b[2]  = safer_lbox[(b[2] + skey->saferp.K[i][2]) & 255] ^ skey->saferp.K[i+1][2];            \
22      b[3]  = (safer_ebox[(b[3] ^ skey->saferp.K[i][3]) & 255] + skey->saferp.K[i+1][3]) & 255;    \
23      b[4]  = (safer_ebox[(b[4] ^ skey->saferp.K[i][4]) & 255] + skey->saferp.K[i+1][4]) & 255;    \
24      b[5]  = safer_lbox[(b[5] + skey->saferp.K[i][5]) & 255] ^ skey->saferp.K[i+1][5];            \
25      b[6]  = safer_lbox[(b[6] + skey->saferp.K[i][6]) & 255] ^ skey->saferp.K[i+1][6];            \
26      b[7]  = (safer_ebox[(b[7] ^ skey->saferp.K[i][7]) & 255] + skey->saferp.K[i+1][7]) & 255;    \
27      b[8]  = (safer_ebox[(b[8] ^ skey->saferp.K[i][8]) & 255] + skey->saferp.K[i+1][8]) & 255;    \
28      b[9]  = safer_lbox[(b[9] + skey->saferp.K[i][9]) & 255] ^ skey->saferp.K[i+1][9];            \
29      b[10] = safer_lbox[(b[10] + skey->saferp.K[i][10]) & 255] ^ skey->saferp.K[i+1][10];         \
30      b[11] = (safer_ebox[(b[11] ^ skey->saferp.K[i][11]) & 255] + skey->saferp.K[i+1][11]) & 255; \
31      b[12] = (safer_ebox[(b[12] ^ skey->saferp.K[i][12]) & 255] + skey->saferp.K[i+1][12]) & 255; \
32      b[13] = safer_lbox[(b[13] + skey->saferp.K[i][13]) & 255] ^ skey->saferp.K[i+1][13];         \
33      b[14] = safer_lbox[(b[14] + skey->saferp.K[i][14]) & 255] ^ skey->saferp.K[i+1][14];         \
34      b[15] = (safer_ebox[(b[15] ^ skey->saferp.K[i][15]) & 255] + skey->saferp.K[i+1][15]) & 255; \
35  } while (0)
36  #define iROUND(b, i) do {                                                                        \
37      b[0]  = safer_lbox[(b[0] - skey->saferp.K[i+1][0]) & 255] ^ skey->saferp.K[i][0];            \
38      b[1]  = (safer_ebox[(b[1] ^ skey->saferp.K[i+1][1]) & 255] - skey->saferp.K[i][1]) & 255;    \
39      b[2]  = (safer_ebox[(b[2] ^ skey->saferp.K[i+1][2]) & 255] - skey->saferp.K[i][2]) & 255;    \
40      b[3]  = safer_lbox[(b[3] - skey->saferp.K[i+1][3]) & 255] ^ skey->saferp.K[i][3];            \
41      b[4]  = safer_lbox[(b[4] - skey->saferp.K[i+1][4]) & 255] ^ skey->saferp.K[i][4];            \
42      b[5]  = (safer_ebox[(b[5] ^ skey->saferp.K[i+1][5]) & 255] - skey->saferp.K[i][5]) & 255;    \
43      b[6]  = (safer_ebox[(b[6] ^ skey->saferp.K[i+1][6]) & 255] - skey->saferp.K[i][6]) & 255;    \
44      b[7]  = safer_lbox[(b[7] - skey->saferp.K[i+1][7]) & 255] ^ skey->saferp.K[i][7];            \
45      b[8]  = safer_lbox[(b[8] - skey->saferp.K[i+1][8]) & 255] ^ skey->saferp.K[i][8];            \
46      b[9]  = (safer_ebox[(b[9] ^ skey->saferp.K[i+1][9]) & 255] - skey->saferp.K[i][9]) & 255;    \
47      b[10] = (safer_ebox[(b[10] ^ skey->saferp.K[i+1][10]) & 255] - skey->saferp.K[i][10]) & 255; \
48      b[11] = safer_lbox[(b[11] - skey->saferp.K[i+1][11]) & 255] ^ skey->saferp.K[i][11];         \
49      b[12] = safer_lbox[(b[12] - skey->saferp.K[i+1][12]) & 255] ^ skey->saferp.K[i][12];         \
50      b[13] = (safer_ebox[(b[13] ^ skey->saferp.K[i+1][13]) & 255] - skey->saferp.K[i][13]) & 255; \
51      b[14] = (safer_ebox[(b[14] ^ skey->saferp.K[i+1][14]) & 255] - skey->saferp.K[i][14]) & 255; \
52      b[15] = safer_lbox[(b[15] - skey->saferp.K[i+1][15]) & 255] ^ skey->saferp.K[i][15];         \
53  } while (0)
54  #define PHT(b) do {                                          \
55      b[0]  = (b[0] + (b[1] = (b[0] + b[1]) & 255)) & 255;     \
56      b[2]  = (b[2] + (b[3] = (b[3] + b[2]) & 255)) & 255;     \
57      b[4]  = (b[4] + (b[5] = (b[5] + b[4]) & 255)) & 255;     \
58      b[6]  = (b[6] + (b[7] = (b[7] + b[6]) & 255)) & 255;     \
59      b[8]  = (b[8] + (b[9] = (b[9] + b[8]) & 255)) & 255;     \
60      b[10] = (b[10] + (b[11] = (b[11] + b[10]) & 255)) & 255; \
61      b[12] = (b[12] + (b[13] = (b[13] + b[12]) & 255)) & 255; \
62      b[14] = (b[14] + (b[15] = (b[15] + b[14]) & 255)) & 255; \
63  } while (0)
64  #define iPHT(b) do {                                          \
65      b[15] = (b[15] - (b[14] = (b[14] - b[15]) & 255)) & 255;  \
66      b[13] = (b[13] - (b[12] = (b[12] - b[13]) & 255)) & 255;  \
67      b[11] = (b[11] - (b[10] = (b[10] - b[11]) & 255)) & 255;  \
68      b[9]  = (b[9] - (b[8] = (b[8] - b[9]) & 255)) & 255;      \
69      b[7]  = (b[7] - (b[6] = (b[6] - b[7]) & 255)) & 255;      \
70      b[5]  = (b[5] - (b[4] = (b[4] - b[5]) & 255)) & 255;      \
71      b[3]  = (b[3] - (b[2] = (b[2] - b[3]) & 255)) & 255;      \
72      b[1]  = (b[1] - (b[0] = (b[0] - b[1]) & 255)) & 255;      \
73   } while (0)
74  #define SHUF(b, b2) do {                                         \
75      b2[0] = b[8]; b2[1] = b[11]; b2[2] = b[12]; b2[3] = b[15];   \
76      b2[4] = b[2]; b2[5] = b[1]; b2[6] = b[6]; b2[7] = b[5];      \
77      b2[8] = b[10]; b2[9] = b[9]; b2[10] = b[14]; b2[11] = b[13]; \
78      b2[12] = b[0]; b2[13] = b[7]; b2[14] = b[4]; b2[15] = b[3];  \
79  } while (0)
80  #define iSHUF(b, b2) do {                                          \
81      b2[0] = b[12]; b2[1] = b[5]; b2[2] = b[4]; b2[3] = b[15];      \
82      b2[4] = b[14]; b2[5] = b[7]; b2[6] = b[6]; b2[7] = b[13];      \
83      b2[8] = b[0]; b2[9] = b[9]; b2[10] = b[8]; b2[11] = b[1];      \
84      b2[12] = b[2]; b2[13] = b[11]; b2[14] = b[10]; b2[15] = b[3];  \
85  } while (0)
86  #define LT(b, b2) do {        \
87      PHT(b);  SHUF(b, b2);     \
88      PHT(b2); SHUF(b2, b);     \
89      PHT(b);  SHUF(b, b2);     \
90      PHT(b2);                  \
91  } while (0)
92  #define iLT(b, b2) do {       \
93      iPHT(b);                  \
94      iSHUF(b, b2); iPHT(b2);   \
95      iSHUF(b2, b); iPHT(b);    \
96      iSHUF(b, b2); iPHT(b2);   \
97  } while (0)
98  #ifdef LTC_SMALL_CODE
99  static void s_round(unsigned char *b, int i, const symmetric_key *skey)
100  {
101     ROUND(b, i);
102  }
103  static void s_iround(unsigned char *b, int i, const symmetric_key *skey)
104  {
105     iROUND(b, i);
106  }
107  static void s_lt(unsigned char *b, unsigned char *b2)
108  {
109     LT(b, b2);
110  }
111  static void s_ilt(unsigned char *b, unsigned char *b2)
112  {
113     iLT(b, b2);
114  }
115  #undef ROUND
116  #define ROUND(b, i) s_round(b, i, skey)
117  #undef iROUND
118  #define iROUND(b, i) s_iround(b, i, skey)
119  #undef LT
120  #define LT(b, b2) s_lt(b, b2)
121  #undef iLT
122  #define iLT(b, b2) s_ilt(b, b2)
123  #endif
124  static const unsigned char safer_bias[33][16] = {
125  {  70, 151, 177, 186, 163, 183,  16,  10, 197,  55, 179, 201,  90,  40, 172, 100},
126  { 236, 171, 170, 198, 103, 149,  88,  13, 248, 154, 246, 110, 102, 220,   5,  61},
127  { 138, 195, 216, 137, 106, 233,  54,  73,  67, 191, 235, 212, 150, 155, 104, 160},
128  {  93,  87, 146,  31, 213, 113,  92, 187,  34, 193, 190, 123, 188, 153,  99, 148},
129  {  42,  97, 184,  52,  50,  25, 253, 251,  23,  64, 230,  81,  29,  65,  68, 143},
130  { 221,   4, 128, 222, 231,  49, 214, 127,   1, 162, 247,  57, 218, 111,  35, 202},
131  {  58, 208,  28, 209,  48,  62,  18, 161, 205,  15, 224, 168, 175, 130,  89,  44},
132  { 125, 173, 178, 239, 194, 135, 206, 117,   6,  19,   2, 144,  79,  46, 114,  51},
133  { 192, 141, 207, 169, 129, 226, 196,  39,  47, 108, 122, 159,  82, 225,  21,  56},
134  { 252,  32,  66, 199,   8, 228,   9,  85,  94, 140,  20, 118,  96, 255, 223, 215},
135  { 250,  11,  33,   0,  26, 249, 166, 185, 232, 158,  98,  76, 217, 145,  80, 210},
136  {  24, 180,   7, 132, 234,  91, 164, 200,  14, 203,  72, 105,  75,  78, 156,  53},
137  {  69,  77,  84, 229,  37,  60,  12,  74, 139,  63, 204, 167, 219, 107, 174, 244},
138  {  45, 243, 124, 109, 157, 181,  38, 116, 242, 147,  83, 176, 240,  17, 237, 131},
139  { 182,   3,  22, 115,  59,  30, 142, 112, 189, 134,  27,  71, 126,  36,  86, 241},
140  { 136,  70, 151, 177, 186, 163, 183,  16,  10, 197,  55, 179, 201,  90,  40, 172},
141  { 220, 134, 119, 215, 166,  17, 251, 244, 186, 146, 145, 100, 131, 241,  51, 239},
142  {  44, 181, 178,  43, 136, 209, 153, 203, 140, 132,  29,  20, 129, 151, 113, 202},
143  { 163, 139,  87,  60, 130, 196,  82,  92,  28, 232, 160,   4, 180, 133,  74, 246},
144  {  84, 182, 223,  12,  26, 142, 222, 224,  57, 252,  32, 155,  36,  78, 169, 152},
145  { 171, 242,  96, 208, 108, 234, 250, 199, 217,   0, 212,  31, 110,  67, 188, 236},
146  { 137, 254, 122,  93,  73, 201,  50, 194, 249, 154, 248, 109,  22, 219,  89, 150},
147  { 233, 205, 230,  70,  66, 143,  10, 193, 204, 185, 101, 176, 210, 198, 172,  30},
148  {  98,  41,  46,  14, 116,  80,   2,  90, 195,  37, 123, 138,  42,  91, 240,   6},
149  {  71, 111, 112, 157, 126,  16, 206,  18,  39, 213,  76,  79, 214, 121,  48, 104},
150  { 117, 125, 228, 237, 128, 106, 144,  55, 162,  94, 118, 170, 197, 127,  61, 175},
151  { 229,  25,  97, 253,  77, 124, 183,  11, 238, 173,  75,  34, 245, 231, 115,  35},
152  { 200,   5, 225, 102, 221, 179,  88, 105,  99,  86,  15, 161,  49, 149,  23,   7},
153  {  40,   1,  45, 226, 147, 190,  69,  21, 174, 120,   3, 135, 164, 184,  56, 207},
154  {   8, 103,   9, 148, 235,  38, 168, 107, 189,  24,  52,  27, 187, 191, 114, 247},
155  {  53,  72, 156,  81,  47,  59,  85, 227, 192, 159, 216, 211, 243, 141, 177, 255},
156  {  62, 220, 134, 119, 215, 166,  17, 251, 244, 186, 146, 145, 100, 131, 241,  51}};
157  int saferp_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
158  {
159     unsigned x, y, z;
160     unsigned char t[33];
161     static const int rounds[3] = { 8, 12, 16 };
162     LTC_ARGCHK(key  != NULL);
163     LTC_ARGCHK(skey != NULL);
164     if (keylen != 16 && keylen != 24 && keylen != 32) {
165        return CRYPT_INVALID_KEYSIZE;
166     }
167     if (num_rounds != 0 && num_rounds != rounds[(keylen/8)-2]) {
168        return CRYPT_INVALID_ROUNDS;
169     }
170     if (keylen == 16) {
171         for (x = y = 0; x < 16; x++) {
172             t[x] = key[x];
173             y ^= key[x];
174         }
175         t[16] = y;
176         for (x = 0; x < 16; x++) {
177             skey->saferp.K[0][x] = t[x];
178         }
179         for (x = 1; x < 17; x++) {
180             for (y = 0; y < 17; y++) {
181                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
182             }
183             z = x;
184             for (y = 0; y < 16; y++) {
185                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
186                 if (++z == 17) { z = 0; }
187             }
188         }
189         skey->saferp.rounds = 8;
190     } else if (keylen == 24) {
191         for (x = y = 0; x < 24; x++) {
192             t[x] = key[x];
193             y ^= key[x];
194         }
195         t[24] = y;
196         for (x = 0; x < 16; x++) {
197             skey->saferp.K[0][x] = t[x];
198         }
199         for (x = 1; x < 25; x++) {
200             for (y = 0; y < 25; y++) {
201                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
202             }
203             z = x;
204             for (y = 0; y < 16; y++) {
205                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
206                 if (++z == 25) { z = 0; }
207             }
208         }
209         skey->saferp.rounds = 12;
210     } else {
211         for (x = y = 0; x < 32; x++) {
212             t[x] = key[x];
213             y ^= key[x];
214         }
215         t[32] = y;
216         for (x = 0; x < 16; x++) {
217             skey->saferp.K[0][x] = t[x];
218         }
219         for (x = 1; x < 33; x++) {
220             for (y = 0; y < 33; y++) {
221                 t[y] = ((t[y]<<3)|(t[y]>>5)) & 255;
222             }
223             z = x;
224             for (y = 0; y < 16; y++) {
225                 skey->saferp.K[x][y] = (t[z] + safer_bias[x-1][y]) & 255;
226                 if (++z == 33) { z = 0; }
227             }
228         }
229         skey->saferp.rounds = 16;
230     }
231  #ifdef LTC_CLEAN_STACK
232     zeromem(t, sizeof(t));
233  #endif
234     return CRYPT_OK;
235  }
236  int saferp_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
237  {
238     unsigned char b[16];
239     int x;
240     LTC_ARGCHK(pt   != NULL);
241     LTC_ARGCHK(ct   != NULL);
242     LTC_ARGCHK(skey != NULL);
243     if (skey->saferp.rounds < 8 || skey->saferp.rounds > 16) {
244         return CRYPT_INVALID_ROUNDS;
245     }
246     for (x = 0; x < 16; x++) {
247         b[x] = pt[x];
248     }
249     ROUND(b,  0);  LT(b, ct);
250     ROUND(ct, 2);  LT(ct, b);
251     ROUND(b,  4);  LT(b, ct);
252     ROUND(ct, 6);  LT(ct, b);
253     ROUND(b,  8);  LT(b, ct);
254     ROUND(ct, 10); LT(ct, b);
255     ROUND(b,  12); LT(b, ct);
256     ROUND(ct, 14); LT(ct, b);
257     if (skey->saferp.rounds > 8) {
258        ROUND(b, 16);  LT(b, ct);
259        ROUND(ct, 18); LT(ct, b);
260        ROUND(b, 20);  LT(b, ct);
261        ROUND(ct, 22); LT(ct, b);
262     }
263     if (skey->saferp.rounds > 12) {
264        ROUND(b, 24);  LT(b, ct);
265        ROUND(ct, 26); LT(ct, b);
266        ROUND(b, 28);  LT(b, ct);
267        ROUND(ct, 30); LT(ct, b);
268     }
269     ct[0] = b[0] ^ skey->saferp.K[skey->saferp.rounds*2][0];
270     ct[1] = (b[1] + skey->saferp.K[skey->saferp.rounds*2][1]) & 255;
271     ct[2] = (b[2] + skey->saferp.K[skey->saferp.rounds*2][2]) & 255;
272     ct[3] = b[3] ^ skey->saferp.K[skey->saferp.rounds*2][3];
273     ct[4] = b[4] ^ skey->saferp.K[skey->saferp.rounds*2][4];
274     ct[5] = (b[5] + skey->saferp.K[skey->saferp.rounds*2][5]) & 255;
275     ct[6] = (b[6] + skey->saferp.K[skey->saferp.rounds*2][6]) & 255;
276     ct[7] = b[7] ^ skey->saferp.K[skey->saferp.rounds*2][7];
277     ct[8] = b[8] ^ skey->saferp.K[skey->saferp.rounds*2][8];
278     ct[9] = (b[9] + skey->saferp.K[skey->saferp.rounds*2][9]) & 255;
279     ct[10] = (b[10] + skey->saferp.K[skey->saferp.rounds*2][10]) & 255;
280     ct[11] = b[11] ^ skey->saferp.K[skey->saferp.rounds*2][11];
281     ct[12] = b[12] ^ skey->saferp.K[skey->saferp.rounds*2][12];
282     ct[13] = (b[13] + skey->saferp.K[skey->saferp.rounds*2][13]) & 255;
283     ct[14] = (b[14] + skey->saferp.K[skey->saferp.rounds*2][14]) & 255;
284     ct[15] = b[15] ^ skey->saferp.K[skey->saferp.rounds*2][15];
285  #ifdef LTC_CLEAN_STACK
286     zeromem(b, sizeof(b));
287  #endif
288     return CRYPT_OK;
289  }
290  int saferp_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
291  {
292     unsigned char b[16];
293     int x;
294     LTC_ARGCHK(pt   != NULL);
295     LTC_ARGCHK(ct   != NULL);
296     LTC_ARGCHK(skey != NULL);
<span onclick='openModal()' class='match'>297     if (skey->saferp.rounds < 8 || skey->saferp.rounds > 16) {
298         return CRYPT_INVALID_ROUNDS;
299     }
300     b[0] = ct[0] ^ skey->saferp.K[skey->saferp.rounds*2][0];
301     b[1] = (ct[1] - skey->saferp.K[skey->saferp.rounds*2][1]) & 255;
302     b[2] = (ct[2] - skey->saferp.K[skey->saferp.rounds*2][2]) & 255;
303     b[3] = ct[3] ^ skey->saferp.K[skey->saferp.rounds*2][3];
</span>304     b[4] = ct[4] ^ skey->saferp.K[skey->saferp.rounds*2][4];
305     b[5] = (ct[5] - skey->saferp.K[skey->saferp.rounds*2][5]) & 255;
306     b[6] = (ct[6] - skey->saferp.K[skey->saferp.rounds*2][6]) & 255;
307     b[7] = ct[7] ^ skey->saferp.K[skey->saferp.rounds*2][7];
308     b[8] = ct[8] ^ skey->saferp.K[skey->saferp.rounds*2][8];
309     b[9] = (ct[9] - skey->saferp.K[skey->saferp.rounds*2][9]) & 255;
310     b[10] = (ct[10] - skey->saferp.K[skey->saferp.rounds*2][10]) & 255;
311     b[11] = ct[11] ^ skey->saferp.K[skey->saferp.rounds*2][11];
312     b[12] = ct[12] ^ skey->saferp.K[skey->saferp.rounds*2][12];
313     b[13] = (ct[13] - skey->saferp.K[skey->saferp.rounds*2][13]) & 255;
314     b[14] = (ct[14] - skey->saferp.K[skey->saferp.rounds*2][14]) & 255;
315     b[15] = ct[15] ^ skey->saferp.K[skey->saferp.rounds*2][15];
316     if (skey->saferp.rounds > 12) {
317        iLT(b, pt); iROUND(pt, 30);
318        iLT(pt, b); iROUND(b, 28);
319        iLT(b, pt); iROUND(pt, 26);
320        iLT(pt, b); iROUND(b, 24);
321     }
322     if (skey->saferp.rounds > 8) {
323        iLT(b, pt); iROUND(pt, 22);
324        iLT(pt, b); iROUND(b, 20);
325        iLT(b, pt); iROUND(pt, 18);
326        iLT(pt, b); iROUND(b, 16);
327     }
328     iLT(b, pt); iROUND(pt, 14);
329     iLT(pt, b); iROUND(b, 12);
330     iLT(b, pt); iROUND(pt,10);
331     iLT(pt, b); iROUND(b, 8);
332     iLT(b, pt); iROUND(pt,6);
333     iLT(pt, b); iROUND(b, 4);
334     iLT(b, pt); iROUND(pt,2);
335     iLT(pt, b); iROUND(b, 0);
336     for (x = 0; x < 16; x++) {
337         pt[x] = b[x];
338     }
339  #ifdef LTC_CLEAN_STACK
340     zeromem(b, sizeof(b));
341  #endif
342     return CRYPT_OK;
343  }
344  int saferp_test(void)
345  {
346   #ifndef LTC_TEST
347      return CRYPT_NOP;
348   #else
349     static const struct {
350         int keylen;
351         unsigned char key[32], pt[16], ct[16];
352     } tests[] = {
353         {
354             16,
355             { 41, 35, 190, 132, 225, 108, 214, 174,
356               82, 144, 73, 241, 241, 187, 233, 235 },
357             { 179, 166, 219, 60, 135, 12, 62, 153,
358               36, 94, 13, 28, 6, 183, 71, 222 },
359             { 224, 31, 182, 10, 12, 255, 84, 70,
360               127, 13, 89, 249, 9, 57, 165, 220 }
361         }, {
362             24,
363             { 72, 211, 143, 117, 230, 217, 29, 42,
364               229, 192, 247, 43, 120, 129, 135, 68,
365               14, 95, 80, 0, 212, 97, 141, 190 },
366             { 123, 5, 21, 7, 59, 51, 130, 31,
367               24, 112, 146, 218, 100, 84, 206, 177 },
368             { 92, 136, 4, 63, 57, 95, 100, 0,
369               150, 130, 130, 16, 193, 111, 219, 133 }
370         }, {
371             32,
372             { 243, 168, 141, 254, 190, 242, 235, 113,
373               255, 160, 208, 59, 117, 6, 140, 126,
374               135, 120, 115, 77, 208, 190, 130, 190,
375               219, 194, 70, 65, 43, 140, 250, 48 },
376             { 127, 112, 240, 167, 84, 134, 50, 149,
377               170, 91, 104, 19, 11, 230, 252, 245 },
378             { 88, 11, 25, 36, 172, 229, 202, 213,
379               170, 65, 105, 153, 220, 104, 153, 138 }
380         }
381      };
382     unsigned char tmp[2][16];
383     symmetric_key skey;
384     int err, i, y;
385     for (i = 0; i < (int)(sizeof(tests) / sizeof(tests[0])); i++) {
386        if ((err = saferp_setup(tests[i].key, tests[i].keylen, 0, &skey)) != CRYPT_OK)  {
387           return err;
388        }
389        saferp_ecb_encrypt(tests[i].pt, tmp[0], &skey);
390        saferp_ecb_decrypt(tmp[0], tmp[1], &skey);
391        if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "Safer+ Encrypt", i) ||
392              compare_testvector(tmp[1], 16, tests[i].pt, 16, "Safer+ Decrypt", i)) {
393           return CRYPT_FAIL_TESTVECTOR;
394        }
395        for (y = 0; y < 16; y++) tmp[0][y] = 0;
396        for (y = 0; y < 1000; y++) saferp_ecb_encrypt(tmp[0], tmp[0], &skey);
397        for (y = 0; y < 1000; y++) saferp_ecb_decrypt(tmp[0], tmp[0], &skey);
398        for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
399     }
400     return CRYPT_OK;
401   #endif
402  }
403  void saferp_done(symmetric_key *skey)
404  {
405    LTC_UNUSED_PARAM(skey);
406  }
407  int saferp_keysize(int *keysize)
408  {
409     LTC_ARGCHK(keysize != NULL);
410     if (*keysize < 16) {
411        return CRYPT_INVALID_KEYSIZE;
412     }
413     if (*keysize < 24) {
414        *keysize = 16;
415     } else if (*keysize < 32) {
416        *keysize = 24;
417     } else {
418        *keysize = 32;
419     }
420     return CRYPT_OK;
421  }
422  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_spim.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-saferp.c</div>
                <div class="column column_space"><pre><code>142      if (buf_len == 0)
143      {
144          return;
145      }
146      uint32_t buffer_end_addr = ((uint32_t)p_buffer) + buf_len;
147      uint32_t block_addr      = ((uint32_t)p_buffer) & ~0x1FFF;
148      uint32_t block_flag      = (1UL << ((block_addr >> 13) & 0xFFFF));
149      uint32_t occupied_blocks = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>297     if (skey->saferp.rounds < 8 || skey->saferp.rounds > 16) {
298         return CRYPT_INVALID_ROUNDS;
299     }
300     b[0] = ct[0] ^ skey->saferp.K[skey->saferp.rounds*2][0];
301     b[1] = (ct[1] - skey->saferp.K[skey->saferp.rounds*2][1]) & 255;
302     b[2] = (ct[2] - skey->saferp.K[skey->saferp.rounds*2][2]) & 255;
303     b[3] = ct[3] ^ skey->saferp.K[skey->saferp.rounds*2][3];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    