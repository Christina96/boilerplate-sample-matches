
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.653385163589245%, Tokens: 9</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_sse2.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #if defined(WEBP_USE_SSE2)
3  #if !defined(USE_TRANSFORM_AC3)
4  #define USE_TRANSFORM_AC3 0   
5  #endif
6  #include <emmintrin.h>
7  #include "src/dsp/common_sse2.h"
8  #include "src/dec/vp8i_dec.h"
9  #include "src/utils/utils.h"
10  static void Transform_SSE2(const int16_t* in, uint8_t* dst, int do_two) {
11    const __m128i k1 = _mm_set1_epi16(20091);
12    const __m128i k2 = _mm_set1_epi16(-30068);
13    __m128i T0, T1, T2, T3;
14    __m128i in0, in1, in2, in3;
15    {
16      in0 = _mm_loadl_epi64((const __m128i*)&in[0]);
17      in1 = _mm_loadl_epi64((const __m128i*)&in[4]);
18      in2 = _mm_loadl_epi64((const __m128i*)&in[8]);
19      in3 = _mm_loadl_epi64((const __m128i*)&in[12]);
20      if (do_two) {
21        const __m128i inB0 = _mm_loadl_epi64((const __m128i*)&in[16]);
22        const __m128i inB1 = _mm_loadl_epi64((const __m128i*)&in[20]);
23        const __m128i inB2 = _mm_loadl_epi64((const __m128i*)&in[24]);
24        const __m128i inB3 = _mm_loadl_epi64((const __m128i*)&in[28]);
25        in0 = _mm_unpacklo_epi64(in0, inB0);
26        in1 = _mm_unpacklo_epi64(in1, inB1);
27        in2 = _mm_unpacklo_epi64(in2, inB2);
28        in3 = _mm_unpacklo_epi64(in3, inB3);
29      }
30    }
31    {
32      const __m128i a = _mm_add_epi16(in0, in2);
33      const __m128i b = _mm_sub_epi16(in0, in2);
34      const __m128i c1 = _mm_mulhi_epi16(in1, k2);
35      const __m128i c2 = _mm_mulhi_epi16(in3, k1);
36      const __m128i c3 = _mm_sub_epi16(in1, in3);
<span onclick='openModal()' class='match'>37      const __m128i c4 = _mm_sub_epi16(c1, c2);
38      const __m128i c = _mm_add_epi16(c3, c4);
39      const __m128i d1 = _mm_mulhi_epi16(in1, k1);
40      const __m128i d2 = _mm_mulhi_epi16(in3, k2);
41      const __m128i d3 = _mm_add_epi16(in1, in3);
</span>42      const __m128i d4 = _mm_add_epi16(d1, d2);
43      const __m128i d = _mm_add_epi16(d3, d4);
44      const __m128i tmp0 = _mm_add_epi16(a, d);
45      const __m128i tmp1 = _mm_add_epi16(b, c);
46      const __m128i tmp2 = _mm_sub_epi16(b, c);
47      const __m128i tmp3 = _mm_sub_epi16(a, d);
48      VP8Transpose_2_4x4_16b(&tmp0, &tmp1, &tmp2, &tmp3, &T0, &T1, &T2, &T3);
49    }
50    {
51      const __m128i four = _mm_set1_epi16(4);
52      const __m128i dc = _mm_add_epi16(T0, four);
53      const __m128i a =  _mm_add_epi16(dc, T2);
54      const __m128i b =  _mm_sub_epi16(dc, T2);
55      const __m128i c1 = _mm_mulhi_epi16(T1, k2);
56      const __m128i c2 = _mm_mulhi_epi16(T3, k1);
57      const __m128i c3 = _mm_sub_epi16(T1, T3);
58      const __m128i c4 = _mm_sub_epi16(c1, c2);
59      const __m128i c = _mm_add_epi16(c3, c4);
60      const __m128i d1 = _mm_mulhi_epi16(T1, k1);
61      const __m128i d2 = _mm_mulhi_epi16(T3, k2);
62      const __m128i d3 = _mm_add_epi16(T1, T3);
63      const __m128i d4 = _mm_add_epi16(d1, d2);
64      const __m128i d = _mm_add_epi16(d3, d4);
65      const __m128i tmp0 = _mm_add_epi16(a, d);
66      const __m128i tmp1 = _mm_add_epi16(b, c);
67      const __m128i tmp2 = _mm_sub_epi16(b, c);
68      const __m128i tmp3 = _mm_sub_epi16(a, d);
69      const __m128i shifted0 = _mm_srai_epi16(tmp0, 3);
70      const __m128i shifted1 = _mm_srai_epi16(tmp1, 3);
71      const __m128i shifted2 = _mm_srai_epi16(tmp2, 3);
72      const __m128i shifted3 = _mm_srai_epi16(tmp3, 3);
73      VP8Transpose_2_4x4_16b(&shifted0, &shifted1, &shifted2, &shifted3, &T0, &T1,
74                             &T2, &T3);
75    }
76    {
77      const __m128i zero = _mm_setzero_si128();
78      __m128i dst0, dst1, dst2, dst3;
79      if (do_two) {
80        dst0 = _mm_loadl_epi64((__m128i*)(dst + 0 * BPS));
81        dst1 = _mm_loadl_epi64((__m128i*)(dst + 1 * BPS));
82        dst2 = _mm_loadl_epi64((__m128i*)(dst + 2 * BPS));
83        dst3 = _mm_loadl_epi64((__m128i*)(dst + 3 * BPS));
84      } else {
85        dst0 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 0 * BPS));
86        dst1 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 1 * BPS));
87        dst2 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 2 * BPS));
88        dst3 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 3 * BPS));
89      }
90      dst0 = _mm_unpacklo_epi8(dst0, zero);
91      dst1 = _mm_unpacklo_epi8(dst1, zero);
92      dst2 = _mm_unpacklo_epi8(dst2, zero);
93      dst3 = _mm_unpacklo_epi8(dst3, zero);
94      dst0 = _mm_add_epi16(dst0, T0);
95      dst1 = _mm_add_epi16(dst1, T1);
96      dst2 = _mm_add_epi16(dst2, T2);
97      dst3 = _mm_add_epi16(dst3, T3);
98      dst0 = _mm_packus_epi16(dst0, dst0);
99      dst1 = _mm_packus_epi16(dst1, dst1);
100      dst2 = _mm_packus_epi16(dst2, dst2);
101      dst3 = _mm_packus_epi16(dst3, dst3);
102      if (do_two) {
103        _mm_storel_epi64((__m128i*)(dst + 0 * BPS), dst0);
104        _mm_storel_epi64((__m128i*)(dst + 1 * BPS), dst1);
105        _mm_storel_epi64((__m128i*)(dst + 2 * BPS), dst2);
106        _mm_storel_epi64((__m128i*)(dst + 3 * BPS), dst3);
107      } else {
108        WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(dst0));
109        WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(dst1));
110        WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(dst2));
111        WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(dst3));
112      }
113    }
114  }
115  #if (USE_TRANSFORM_AC3 == 1)
116  #define MUL(a, b) (((a) * (b)) >> 16)
117  static void TransformAC3(const int16_t* in, uint8_t* dst) {
118    static const int kC1 = 20091 + (1 << 16);
119    static const int kC2 = 35468;
120    const __m128i A = _mm_set1_epi16(in[0] + 4);
121    const __m128i c4 = _mm_set1_epi16(MUL(in[4], kC2));
122    const __m128i d4 = _mm_set1_epi16(MUL(in[4], kC1));
123    const int c1 = MUL(in[1], kC2);
124    const int d1 = MUL(in[1], kC1);
125    const __m128i CD = _mm_set_epi16(0, 0, 0, 0, -d1, -c1, c1, d1);
126    const __m128i B = _mm_adds_epi16(A, CD);
127    const __m128i m0 = _mm_adds_epi16(B, d4);
128    const __m128i m1 = _mm_adds_epi16(B, c4);
129    const __m128i m2 = _mm_subs_epi16(B, c4);
130    const __m128i m3 = _mm_subs_epi16(B, d4);
131    const __m128i zero = _mm_setzero_si128();
132    __m128i dst0 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 0 * BPS));
133    __m128i dst1 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 1 * BPS));
134    __m128i dst2 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 2 * BPS));
135    __m128i dst3 = _mm_cvtsi32_si128(WebPMemToUint32(dst + 3 * BPS));
136    dst0 = _mm_unpacklo_epi8(dst0, zero);
137    dst1 = _mm_unpacklo_epi8(dst1, zero);
138    dst2 = _mm_unpacklo_epi8(dst2, zero);
139    dst3 = _mm_unpacklo_epi8(dst3, zero);
140    dst0 = _mm_adds_epi16(dst0, _mm_srai_epi16(m0, 3));
141    dst1 = _mm_adds_epi16(dst1, _mm_srai_epi16(m1, 3));
142    dst2 = _mm_adds_epi16(dst2, _mm_srai_epi16(m2, 3));
143    dst3 = _mm_adds_epi16(dst3, _mm_srai_epi16(m3, 3));
144    dst0 = _mm_packus_epi16(dst0, dst0);
145    dst1 = _mm_packus_epi16(dst1, dst1);
146    dst2 = _mm_packus_epi16(dst2, dst2);
147    dst3 = _mm_packus_epi16(dst3, dst3);
148    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(dst0));
149    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(dst1));
150    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(dst2));
151    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(dst3));
152  }
153  #undef MUL
154  #endif   
155  #define MM_ABS(p, q)  _mm_or_si128(                                            \
156      _mm_subs_epu8((q), (p)),                                                   \
157      _mm_subs_epu8((p), (q)))
158  static WEBP_INLINE void SignedShift8b_SSE2(__m128i* const x) {
159    const __m128i zero = _mm_setzero_si128();
160    const __m128i lo_0 = _mm_unpacklo_epi8(zero, *x);
161    const __m128i hi_0 = _mm_unpackhi_epi8(zero, *x);
162    const __m128i lo_1 = _mm_srai_epi16(lo_0, 3 + 8);
163    const __m128i hi_1 = _mm_srai_epi16(hi_0, 3 + 8);
164    *x = _mm_packs_epi16(lo_1, hi_1);
165  }
166  #define FLIP_SIGN_BIT2(a, b) {                                                 \
167    (a) = _mm_xor_si128(a, sign_bit);                                            \
168    (b) = _mm_xor_si128(b, sign_bit);                                            \
169  }
170  #define FLIP_SIGN_BIT4(a, b, c, d) {                                           \
171    FLIP_SIGN_BIT2(a, b);                                                        \
172    FLIP_SIGN_BIT2(c, d);                                                        \
173  }
174  static WEBP_INLINE void GetNotHEV_SSE2(const __m128i* const p1,
175                                         const __m128i* const p0,
176                                         const __m128i* const q0,
177                                         const __m128i* const q1,
178                                         int hev_thresh, __m128i* const not_hev) {
179    const __m128i zero = _mm_setzero_si128();
180    const __m128i t_1 = MM_ABS(*p1, *p0);
181    const __m128i t_2 = MM_ABS(*q1, *q0);
182    const __m128i h = _mm_set1_epi8(hev_thresh);
183    const __m128i t_max = _mm_max_epu8(t_1, t_2);
184    const __m128i t_max_h = _mm_subs_epu8(t_max, h);
185    *not_hev = _mm_cmpeq_epi8(t_max_h, zero);  
186  }
187  static WEBP_INLINE void GetBaseDelta_SSE2(const __m128i* const p1,
188                                            const __m128i* const p0,
189                                            const __m128i* const q0,
190                                            const __m128i* const q1,
191                                            __m128i* const delta) {
192    const __m128i p1_q1 = _mm_subs_epi8(*p1, *q1);   
193    const __m128i q0_p0 = _mm_subs_epi8(*q0, *p0);   
194    const __m128i s1 = _mm_adds_epi8(p1_q1, q0_p0);  
195    const __m128i s2 = _mm_adds_epi8(q0_p0, s1);     
196    const __m128i s3 = _mm_adds_epi8(q0_p0, s2);     
197    *delta = s3;
198  }
199  static WEBP_INLINE void DoSimpleFilter_SSE2(__m128i* const p0,
200                                              __m128i* const q0,
201                                              const __m128i* const fl) {
202    const __m128i k3 = _mm_set1_epi8(3);
203    const __m128i k4 = _mm_set1_epi8(4);
204    __m128i v3 = _mm_adds_epi8(*fl, k3);
205    __m128i v4 = _mm_adds_epi8(*fl, k4);
206    SignedShift8b_SSE2(&v4);             
207    SignedShift8b_SSE2(&v3);             
208    *q0 = _mm_subs_epi8(*q0, v4);        
209    *p0 = _mm_adds_epi8(*p0, v3);        
210  }
211  static WEBP_INLINE void Update2Pixels_SSE2(__m128i* const pi, __m128i* const qi,
212                                             const __m128i* const a0_lo,
213                                             const __m128i* const a0_hi) {
214    const __m128i a1_lo = _mm_srai_epi16(*a0_lo, 7);
215    const __m128i a1_hi = _mm_srai_epi16(*a0_hi, 7);
216    const __m128i delta = _mm_packs_epi16(a1_lo, a1_hi);
217    const __m128i sign_bit = _mm_set1_epi8((char)0x80);
218    *pi = _mm_adds_epi8(*pi, delta);
219    *qi = _mm_subs_epi8(*qi, delta);
220    FLIP_SIGN_BIT2(*pi, *qi);
221  }
222  static WEBP_INLINE void NeedsFilter_SSE2(const __m128i* const p1,
223                                           const __m128i* const p0,
224                                           const __m128i* const q0,
225                                           const __m128i* const q1,
226                                           int thresh, __m128i* const mask) {
227    const __m128i m_thresh = _mm_set1_epi8((char)thresh);
228    const __m128i t1 = MM_ABS(*p1, *q1);        
229    const __m128i kFE = _mm_set1_epi8((char)0xFE);
230    const __m128i t2 = _mm_and_si128(t1, kFE);  
231    const __m128i t3 = _mm_srli_epi16(t2, 1);   
232    const __m128i t4 = MM_ABS(*p0, *q0);        
233    const __m128i t5 = _mm_adds_epu8(t4, t4);   
234    const __m128i t6 = _mm_adds_epu8(t5, t3);   
235    const __m128i t7 = _mm_subs_epu8(t6, m_thresh);  
236    *mask = _mm_cmpeq_epi8(t7, _mm_setzero_si128());
237  }
238  static WEBP_INLINE void DoFilter2_SSE2(__m128i* const p1, __m128i* const p0,
239                                         __m128i* const q0, __m128i* const q1,
240                                         int thresh) {
241    __m128i a, mask;
242    const __m128i sign_bit = _mm_set1_epi8((char)0x80);
243    const __m128i p1s = _mm_xor_si128(*p1, sign_bit);
244    const __m128i q1s = _mm_xor_si128(*q1, sign_bit);
245    NeedsFilter_SSE2(p1, p0, q0, q1, thresh, &mask);
246    FLIP_SIGN_BIT2(*p0, *q0);
247    GetBaseDelta_SSE2(&p1s, p0, q0, &q1s, &a);
248    a = _mm_and_si128(a, mask);     
249    DoSimpleFilter_SSE2(p0, q0, &a);
250    FLIP_SIGN_BIT2(*p0, *q0);
251  }
252  static WEBP_INLINE void DoFilter4_SSE2(__m128i* const p1, __m128i* const p0,
253                                         __m128i* const q0, __m128i* const q1,
254                                         const __m128i* const mask,
255                                         int hev_thresh) {
256    const __m128i zero = _mm_setzero_si128();
257    const __m128i sign_bit = _mm_set1_epi8((char)0x80);
258    const __m128i k64 = _mm_set1_epi8(64);
259    const __m128i k3 = _mm_set1_epi8(3);
260    const __m128i k4 = _mm_set1_epi8(4);
261    __m128i not_hev;
262    __m128i t1, t2, t3;
263    GetNotHEV_SSE2(p1, p0, q0, q1, hev_thresh, &not_hev);
264    FLIP_SIGN_BIT4(*p1, *p0, *q0, *q1);
265    t1 = _mm_subs_epi8(*p1, *q1);        
266    t1 = _mm_andnot_si128(not_hev, t1);  
267    t2 = _mm_subs_epi8(*q0, *p0);        
268    t1 = _mm_adds_epi8(t1, t2);          
269    t1 = _mm_adds_epi8(t1, t2);          
270    t1 = _mm_adds_epi8(t1, t2);          
271    t1 = _mm_and_si128(t1, *mask);       
272    t2 = _mm_adds_epi8(t1, k3);        
273    t3 = _mm_adds_epi8(t1, k4);        
274    SignedShift8b_SSE2(&t2);           
275    SignedShift8b_SSE2(&t3);           
276    *p0 = _mm_adds_epi8(*p0, t2);      
277    *q0 = _mm_subs_epi8(*q0, t3);      
278    FLIP_SIGN_BIT2(*p0, *q0);
279    t2 = _mm_add_epi8(t3, sign_bit);
280    t3 = _mm_avg_epu8(t2, zero);
281    t3 = _mm_sub_epi8(t3, k64);
282    t3 = _mm_and_si128(not_hev, t3);   
283    *q1 = _mm_subs_epi8(*q1, t3);      
284    *p1 = _mm_adds_epi8(*p1, t3);      
285    FLIP_SIGN_BIT2(*p1, *q1);
286  }
287  static WEBP_INLINE void DoFilter6_SSE2(__m128i* const p2, __m128i* const p1,
288                                         __m128i* const p0, __m128i* const q0,
289                                         __m128i* const q1, __m128i* const q2,
290                                         const __m128i* const mask,
291                                         int hev_thresh) {
292    const __m128i zero = _mm_setzero_si128();
293    const __m128i sign_bit = _mm_set1_epi8((char)0x80);
294    __m128i a, not_hev;
295    GetNotHEV_SSE2(p1, p0, q0, q1, hev_thresh, &not_hev);
296    FLIP_SIGN_BIT4(*p1, *p0, *q0, *q1);
297    FLIP_SIGN_BIT2(*p2, *q2);
298    GetBaseDelta_SSE2(p1, p0, q0, q1, &a);
299    { 
300      const __m128i m = _mm_andnot_si128(not_hev, *mask);
301      const __m128i f = _mm_and_si128(a, m);
302      DoSimpleFilter_SSE2(p0, q0, &f);
303    }
304    { 
305      const __m128i k9 = _mm_set1_epi16(0x0900);
306      const __m128i k63 = _mm_set1_epi16(63);
307      const __m128i m = _mm_and_si128(not_hev, *mask);
308      const __m128i f = _mm_and_si128(a, m);
309      const __m128i f_lo = _mm_unpacklo_epi8(zero, f);
310      const __m128i f_hi = _mm_unpackhi_epi8(zero, f);
311      const __m128i f9_lo = _mm_mulhi_epi16(f_lo, k9);    
312      const __m128i f9_hi = _mm_mulhi_epi16(f_hi, k9);    
313      const __m128i a2_lo = _mm_add_epi16(f9_lo, k63);    
314      const __m128i a2_hi = _mm_add_epi16(f9_hi, k63);    
315      const __m128i a1_lo = _mm_add_epi16(a2_lo, f9_lo);  
316      const __m128i a1_hi = _mm_add_epi16(a2_hi, f9_hi);  
317      const __m128i a0_lo = _mm_add_epi16(a1_lo, f9_lo);  
318      const __m128i a0_hi = _mm_add_epi16(a1_hi, f9_hi);  
319      Update2Pixels_SSE2(p2, q2, &a2_lo, &a2_hi);
320      Update2Pixels_SSE2(p1, q1, &a1_lo, &a1_hi);
321      Update2Pixels_SSE2(p0, q0, &a0_lo, &a0_hi);
322    }
323  }
324  static WEBP_INLINE void Load8x4_SSE2(const uint8_t* const b, int stride,
325                                       __m128i* const p, __m128i* const q) {
326    const __m128i A0 = _mm_set_epi32(
327        WebPMemToUint32(&b[6 * stride]), WebPMemToUint32(&b[2 * stride]),
328        WebPMemToUint32(&b[4 * stride]), WebPMemToUint32(&b[0 * stride]));
329    const __m128i A1 = _mm_set_epi32(
330        WebPMemToUint32(&b[7 * stride]), WebPMemToUint32(&b[3 * stride]),
331        WebPMemToUint32(&b[5 * stride]), WebPMemToUint32(&b[1 * stride]));
332    const __m128i B0 = _mm_unpacklo_epi8(A0, A1);
333    const __m128i B1 = _mm_unpackhi_epi8(A0, A1);
334    const __m128i C0 = _mm_unpacklo_epi16(B0, B1);
335    const __m128i C1 = _mm_unpackhi_epi16(B0, B1);
336    *p = _mm_unpacklo_epi32(C0, C1);
337    *q = _mm_unpackhi_epi32(C0, C1);
338  }
339  static WEBP_INLINE void Load16x4_SSE2(const uint8_t* const r0,
340                                        const uint8_t* const r8,
341                                        int stride,
342                                        __m128i* const p1, __m128i* const p0,
343                                        __m128i* const q0, __m128i* const q1) {
344    Load8x4_SSE2(r0, stride, p1, q0);
345    Load8x4_SSE2(r8, stride, p0, q1);
346    {
347      const __m128i t1 = *p1;
348      const __m128i t2 = *q0;
349      *p1 = _mm_unpacklo_epi64(t1, *p0);
350      *p0 = _mm_unpackhi_epi64(t1, *p0);
351      *q0 = _mm_unpacklo_epi64(t2, *q1);
352      *q1 = _mm_unpackhi_epi64(t2, *q1);
353    }
354  }
355  static WEBP_INLINE void Store4x4_SSE2(__m128i* const x,
356                                        uint8_t* dst, int stride) {
357    int i;
358    for (i = 0; i < 4; ++i, dst += stride) {
359      WebPUint32ToMem(dst, _mm_cvtsi128_si32(*x));
360      *x = _mm_srli_si128(*x, 4);
361    }
362  }
363  static WEBP_INLINE void Store16x4_SSE2(const __m128i* const p1,
364                                         const __m128i* const p0,
365                                         const __m128i* const q0,
366                                         const __m128i* const q1,
367                                         uint8_t* r0, uint8_t* r8,
368                                         int stride) {
369    __m128i t1, p1_s, p0_s, q0_s, q1_s;
370    t1 = *p0;
371    p0_s = _mm_unpacklo_epi8(*p1, t1);
372    p1_s = _mm_unpackhi_epi8(*p1, t1);
373    t1 = *q0;
374    q0_s = _mm_unpacklo_epi8(t1, *q1);
375    q1_s = _mm_unpackhi_epi8(t1, *q1);
376    t1 = p0_s;
377    p0_s = _mm_unpacklo_epi16(t1, q0_s);
378    q0_s = _mm_unpackhi_epi16(t1, q0_s);
379    t1 = p1_s;
380    p1_s = _mm_unpacklo_epi16(t1, q1_s);
381    q1_s = _mm_unpackhi_epi16(t1, q1_s);
382    Store4x4_SSE2(&p0_s, r0, stride);
383    r0 += 4 * stride;
384    Store4x4_SSE2(&q0_s, r0, stride);
385    Store4x4_SSE2(&p1_s, r8, stride);
386    r8 += 4 * stride;
387    Store4x4_SSE2(&q1_s, r8, stride);
388  }
389  static void SimpleVFilter16_SSE2(uint8_t* p, int stride, int thresh) {
390    __m128i p1 = _mm_loadu_si128((__m128i*)&p[-2 * stride]);
391    __m128i p0 = _mm_loadu_si128((__m128i*)&p[-stride]);
392    __m128i q0 = _mm_loadu_si128((__m128i*)&p[0]);
393    __m128i q1 = _mm_loadu_si128((__m128i*)&p[stride]);
394    DoFilter2_SSE2(&p1, &p0, &q0, &q1, thresh);
395    _mm_storeu_si128((__m128i*)&p[-stride], p0);
396    _mm_storeu_si128((__m128i*)&p[0], q0);
397  }
398  static void SimpleHFilter16_SSE2(uint8_t* p, int stride, int thresh) {
399    __m128i p1, p0, q0, q1;
400    p -= 2;  
401    Load16x4_SSE2(p, p + 8 * stride, stride, &p1, &p0, &q0, &q1);
402    DoFilter2_SSE2(&p1, &p0, &q0, &q1, thresh);
403    Store16x4_SSE2(&p1, &p0, &q0, &q1, p, p + 8 * stride, stride);
404  }
405  static void SimpleVFilter16i_SSE2(uint8_t* p, int stride, int thresh) {
406    int k;
407    for (k = 3; k > 0; --k) {
408      p += 4 * stride;
409      SimpleVFilter16_SSE2(p, stride, thresh);
410    }
411  }
412  static void SimpleHFilter16i_SSE2(uint8_t* p, int stride, int thresh) {
413    int k;
414    for (k = 3; k > 0; --k) {
415      p += 4;
416      SimpleHFilter16_SSE2(p, stride, thresh);
417    }
418  }
419  #define MAX_DIFF1(p3, p2, p1, p0, m) do {                                      \
420    (m) = MM_ABS(p1, p0);                                                        \
421    (m) = _mm_max_epu8(m, MM_ABS(p3, p2));                                       \
422    (m) = _mm_max_epu8(m, MM_ABS(p2, p1));                                       \
423  } while (0)
424  #define MAX_DIFF2(p3, p2, p1, p0, m) do {                                      \
425    (m) = _mm_max_epu8(m, MM_ABS(p1, p0));                                       \
426    (m) = _mm_max_epu8(m, MM_ABS(p3, p2));                                       \
427    (m) = _mm_max_epu8(m, MM_ABS(p2, p1));                                       \
428  } while (0)
429  #define LOAD_H_EDGES4(p, stride, e1, e2, e3, e4) {                             \
430    (e1) = _mm_loadu_si128((__m128i*)&(p)[0 * (stride)]);                        \
431    (e2) = _mm_loadu_si128((__m128i*)&(p)[1 * (stride)]);                        \
432    (e3) = _mm_loadu_si128((__m128i*)&(p)[2 * (stride)]);                        \
433    (e4) = _mm_loadu_si128((__m128i*)&(p)[3 * (stride)]);                        \
434  }
435  #define LOADUV_H_EDGE(p, u, v, stride) do {                                    \
436    const __m128i U = _mm_loadl_epi64((__m128i*)&(u)[(stride)]);                 \
437    const __m128i V = _mm_loadl_epi64((__m128i*)&(v)[(stride)]);                 \
438    (p) = _mm_unpacklo_epi64(U, V);                                              \
439  } while (0)
440  #define LOADUV_H_EDGES4(u, v, stride, e1, e2, e3, e4) {                        \
441    LOADUV_H_EDGE(e1, u, v, 0 * (stride));                                       \
442    LOADUV_H_EDGE(e2, u, v, 1 * (stride));                                       \
443    LOADUV_H_EDGE(e3, u, v, 2 * (stride));                                       \
444    LOADUV_H_EDGE(e4, u, v, 3 * (stride));                                       \
445  }
446  #define STOREUV(p, u, v, stride) {                                             \
447    _mm_storel_epi64((__m128i*)&(u)[(stride)], p);                               \
448    (p) = _mm_srli_si128(p, 8);                                                  \
449    _mm_storel_epi64((__m128i*)&(v)[(stride)], p);                               \
450  }
451  static WEBP_INLINE void ComplexMask_SSE2(const __m128i* const p1,
452                                           const __m128i* const p0,
453                                           const __m128i* const q0,
454                                           const __m128i* const q1,
455                                           int thresh, int ithresh,
456                                           __m128i* const mask) {
457    const __m128i it = _mm_set1_epi8(ithresh);
458    const __m128i diff = _mm_subs_epu8(*mask, it);
459    const __m128i thresh_mask = _mm_cmpeq_epi8(diff, _mm_setzero_si128());
460    __m128i filter_mask;
461    NeedsFilter_SSE2(p1, p0, q0, q1, thresh, &filter_mask);
462    *mask = _mm_and_si128(thresh_mask, filter_mask);
463  }
464  static void VFilter16_SSE2(uint8_t* p, int stride,
465                             int thresh, int ithresh, int hev_thresh) {
466    __m128i t1;
467    __m128i mask;
468    __m128i p2, p1, p0, q0, q1, q2;
469    LOAD_H_EDGES4(p - 4 * stride, stride, t1, p2, p1, p0);
470    MAX_DIFF1(t1, p2, p1, p0, mask);
471    LOAD_H_EDGES4(p, stride, q0, q1, q2, t1);
472    MAX_DIFF2(t1, q2, q1, q0, mask);
473    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
474    DoFilter6_SSE2(&p2, &p1, &p0, &q0, &q1, &q2, &mask, hev_thresh);
475    _mm_storeu_si128((__m128i*)&p[-3 * stride], p2);
476    _mm_storeu_si128((__m128i*)&p[-2 * stride], p1);
477    _mm_storeu_si128((__m128i*)&p[-1 * stride], p0);
478    _mm_storeu_si128((__m128i*)&p[+0 * stride], q0);
479    _mm_storeu_si128((__m128i*)&p[+1 * stride], q1);
480    _mm_storeu_si128((__m128i*)&p[+2 * stride], q2);
481  }
482  static void HFilter16_SSE2(uint8_t* p, int stride,
483                             int thresh, int ithresh, int hev_thresh) {
484    __m128i mask;
485    __m128i p3, p2, p1, p0, q0, q1, q2, q3;
486    uint8_t* const b = p - 4;
487    Load16x4_SSE2(b, b + 8 * stride, stride, &p3, &p2, &p1, &p0);
488    MAX_DIFF1(p3, p2, p1, p0, mask);
489    Load16x4_SSE2(p, p + 8 * stride, stride, &q0, &q1, &q2, &q3);
490    MAX_DIFF2(q3, q2, q1, q0, mask);
491    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
492    DoFilter6_SSE2(&p2, &p1, &p0, &q0, &q1, &q2, &mask, hev_thresh);
493    Store16x4_SSE2(&p3, &p2, &p1, &p0, b, b + 8 * stride, stride);
494    Store16x4_SSE2(&q0, &q1, &q2, &q3, p, p + 8 * stride, stride);
495  }
496  static void VFilter16i_SSE2(uint8_t* p, int stride,
497                              int thresh, int ithresh, int hev_thresh) {
498    int k;
499    __m128i p3, p2, p1, p0;   
500    LOAD_H_EDGES4(p, stride, p3, p2, p1, p0);  
501    for (k = 3; k > 0; --k) {
502      __m128i mask, tmp1, tmp2;
503      uint8_t* const b = p + 2 * stride;   
504      p += 4 * stride;
505      MAX_DIFF1(p3, p2, p1, p0, mask);   
506      LOAD_H_EDGES4(p, stride, p3, p2, tmp1, tmp2);
507      MAX_DIFF2(p3, p2, tmp1, tmp2, mask);
508      ComplexMask_SSE2(&p1, &p0, &p3, &p2, thresh, ithresh, &mask);
509      DoFilter4_SSE2(&p1, &p0, &p3, &p2, &mask, hev_thresh);
510      _mm_storeu_si128((__m128i*)&b[0 * stride], p1);
511      _mm_storeu_si128((__m128i*)&b[1 * stride], p0);
512      _mm_storeu_si128((__m128i*)&b[2 * stride], p3);
513      _mm_storeu_si128((__m128i*)&b[3 * stride], p2);
514      p1 = tmp1;
515      p0 = tmp2;
516    }
517  }
518  static void HFilter16i_SSE2(uint8_t* p, int stride,
519                              int thresh, int ithresh, int hev_thresh) {
520    int k;
521    __m128i p3, p2, p1, p0;   
522    Load16x4_SSE2(p, p + 8 * stride, stride, &p3, &p2, &p1, &p0);  
523    for (k = 3; k > 0; --k) {
524      __m128i mask, tmp1, tmp2;
525      uint8_t* const b = p + 2;   
526      p += 4;  
527      MAX_DIFF1(p3, p2, p1, p0, mask);   
528      Load16x4_SSE2(p, p + 8 * stride, stride, &p3, &p2, &tmp1, &tmp2);
529      MAX_DIFF2(p3, p2, tmp1, tmp2, mask);
530      ComplexMask_SSE2(&p1, &p0, &p3, &p2, thresh, ithresh, &mask);
531      DoFilter4_SSE2(&p1, &p0, &p3, &p2, &mask, hev_thresh);
532      Store16x4_SSE2(&p1, &p0, &p3, &p2, b, b + 8 * stride, stride);
533      p1 = tmp1;
534      p0 = tmp2;
535    }
536  }
537  static void VFilter8_SSE2(uint8_t* u, uint8_t* v, int stride,
538                            int thresh, int ithresh, int hev_thresh) {
539    __m128i mask;
540    __m128i t1, p2, p1, p0, q0, q1, q2;
541    LOADUV_H_EDGES4(u - 4 * stride, v - 4 * stride, stride, t1, p2, p1, p0);
542    MAX_DIFF1(t1, p2, p1, p0, mask);
543    LOADUV_H_EDGES4(u, v, stride, q0, q1, q2, t1);
544    MAX_DIFF2(t1, q2, q1, q0, mask);
545    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
546    DoFilter6_SSE2(&p2, &p1, &p0, &q0, &q1, &q2, &mask, hev_thresh);
547    STOREUV(p2, u, v, -3 * stride);
548    STOREUV(p1, u, v, -2 * stride);
549    STOREUV(p0, u, v, -1 * stride);
550    STOREUV(q0, u, v, 0 * stride);
551    STOREUV(q1, u, v, 1 * stride);
552    STOREUV(q2, u, v, 2 * stride);
553  }
554  static void HFilter8_SSE2(uint8_t* u, uint8_t* v, int stride,
555                            int thresh, int ithresh, int hev_thresh) {
556    __m128i mask;
557    __m128i p3, p2, p1, p0, q0, q1, q2, q3;
558    uint8_t* const tu = u - 4;
559    uint8_t* const tv = v - 4;
560    Load16x4_SSE2(tu, tv, stride, &p3, &p2, &p1, &p0);
561    MAX_DIFF1(p3, p2, p1, p0, mask);
562    Load16x4_SSE2(u, v, stride, &q0, &q1, &q2, &q3);
563    MAX_DIFF2(q3, q2, q1, q0, mask);
564    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
565    DoFilter6_SSE2(&p2, &p1, &p0, &q0, &q1, &q2, &mask, hev_thresh);
566    Store16x4_SSE2(&p3, &p2, &p1, &p0, tu, tv, stride);
567    Store16x4_SSE2(&q0, &q1, &q2, &q3, u, v, stride);
568  }
569  static void VFilter8i_SSE2(uint8_t* u, uint8_t* v, int stride,
570                             int thresh, int ithresh, int hev_thresh) {
571    __m128i mask;
572    __m128i t1, t2, p1, p0, q0, q1;
573    LOADUV_H_EDGES4(u, v, stride, t2, t1, p1, p0);
574    MAX_DIFF1(t2, t1, p1, p0, mask);
575    u += 4 * stride;
576    v += 4 * stride;
577    LOADUV_H_EDGES4(u, v, stride, q0, q1, t1, t2);
578    MAX_DIFF2(t2, t1, q1, q0, mask);
579    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
580    DoFilter4_SSE2(&p1, &p0, &q0, &q1, &mask, hev_thresh);
581    STOREUV(p1, u, v, -2 * stride);
582    STOREUV(p0, u, v, -1 * stride);
583    STOREUV(q0, u, v, 0 * stride);
584    STOREUV(q1, u, v, 1 * stride);
585  }
586  static void HFilter8i_SSE2(uint8_t* u, uint8_t* v, int stride,
587                             int thresh, int ithresh, int hev_thresh) {
588    __m128i mask;
589    __m128i t1, t2, p1, p0, q0, q1;
590    Load16x4_SSE2(u, v, stride, &t2, &t1, &p1, &p0);   
591    MAX_DIFF1(t2, t1, p1, p0, mask);
592    u += 4;  
593    v += 4;
594    Load16x4_SSE2(u, v, stride, &q0, &q1, &t1, &t2);  
595    MAX_DIFF2(t2, t1, q1, q0, mask);
596    ComplexMask_SSE2(&p1, &p0, &q0, &q1, thresh, ithresh, &mask);
597    DoFilter4_SSE2(&p1, &p0, &q0, &q1, &mask, hev_thresh);
598    u -= 2;  
599    v -= 2;
600    Store16x4_SSE2(&p1, &p0, &q0, &q1, u, v, stride);
601  }
602  #define DST(x, y) dst[(x) + (y) * BPS]
603  #define AVG3(a, b, c) (((a) + 2 * (b) + (c) + 2) >> 2)
604  static void VE4_SSE2(uint8_t* dst) {    
605    const __m128i one = _mm_set1_epi8(1);
606    const __m128i ABCDEFGH = _mm_loadl_epi64((__m128i*)(dst - BPS - 1));
607    const __m128i BCDEFGH0 = _mm_srli_si128(ABCDEFGH, 1);
608    const __m128i CDEFGH00 = _mm_srli_si128(ABCDEFGH, 2);
609    const __m128i a = _mm_avg_epu8(ABCDEFGH, CDEFGH00);
610    const __m128i lsb = _mm_and_si128(_mm_xor_si128(ABCDEFGH, CDEFGH00), one);
611    const __m128i b = _mm_subs_epu8(a, lsb);
612    const __m128i avg = _mm_avg_epu8(b, BCDEFGH0);
613    const uint32_t vals = _mm_cvtsi128_si32(avg);
614    int i;
615    for (i = 0; i < 4; ++i) {
616      WebPUint32ToMem(dst + i * BPS, vals);
617    }
618  }
619  static void LD4_SSE2(uint8_t* dst) {   
620    const __m128i one = _mm_set1_epi8(1);
621    const __m128i ABCDEFGH = _mm_loadl_epi64((__m128i*)(dst - BPS));
622    const __m128i BCDEFGH0 = _mm_srli_si128(ABCDEFGH, 1);
623    const __m128i CDEFGH00 = _mm_srli_si128(ABCDEFGH, 2);
624    const __m128i CDEFGHH0 = _mm_insert_epi16(CDEFGH00, dst[-BPS + 7], 3);
625    const __m128i avg1 = _mm_avg_epu8(ABCDEFGH, CDEFGHH0);
626    const __m128i lsb = _mm_and_si128(_mm_xor_si128(ABCDEFGH, CDEFGHH0), one);
627    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
628    const __m128i abcdefg = _mm_avg_epu8(avg2, BCDEFGH0);
629    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               abcdefg    ));
630    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 1)));
631    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 2)));
632    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 3)));
633  }
634  static void VR4_SSE2(uint8_t* dst) {   
635    const __m128i one = _mm_set1_epi8(1);
636    const int I = dst[-1 + 0 * BPS];
637    const int J = dst[-1 + 1 * BPS];
638    const int K = dst[-1 + 2 * BPS];
639    const int X = dst[-1 - BPS];
640    const __m128i XABCD = _mm_loadl_epi64((__m128i*)(dst - BPS - 1));
641    const __m128i ABCD0 = _mm_srli_si128(XABCD, 1);
642    const __m128i abcd = _mm_avg_epu8(XABCD, ABCD0);
643    const __m128i _XABCD = _mm_slli_si128(XABCD, 1);
644    const __m128i IXABCD = _mm_insert_epi16(_XABCD, (short)(I | (X << 8)), 0);
645    const __m128i avg1 = _mm_avg_epu8(IXABCD, ABCD0);
646    const __m128i lsb = _mm_and_si128(_mm_xor_si128(IXABCD, ABCD0), one);
647    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
648    const __m128i efgh = _mm_avg_epu8(avg2, XABCD);
649    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               abcd    ));
650    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(               efgh    ));
651    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_slli_si128(abcd, 1)));
652    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_slli_si128(efgh, 1)));
653    DST(0, 2) = AVG3(J, I, X);
654    DST(0, 3) = AVG3(K, J, I);
655  }
656  static void VL4_SSE2(uint8_t* dst) {   
657    const __m128i one = _mm_set1_epi8(1);
658    const __m128i ABCDEFGH = _mm_loadl_epi64((__m128i*)(dst - BPS));
659    const __m128i BCDEFGH_ = _mm_srli_si128(ABCDEFGH, 1);
660    const __m128i CDEFGH__ = _mm_srli_si128(ABCDEFGH, 2);
661    const __m128i avg1 = _mm_avg_epu8(ABCDEFGH, BCDEFGH_);
662    const __m128i avg2 = _mm_avg_epu8(CDEFGH__, BCDEFGH_);
663    const __m128i avg3 = _mm_avg_epu8(avg1, avg2);
664    const __m128i lsb1 = _mm_and_si128(_mm_xor_si128(avg1, avg2), one);
665    const __m128i ab = _mm_xor_si128(ABCDEFGH, BCDEFGH_);
666    const __m128i bc = _mm_xor_si128(CDEFGH__, BCDEFGH_);
667    const __m128i abbc = _mm_or_si128(ab, bc);
668    const __m128i lsb2 = _mm_and_si128(abbc, lsb1);
669    const __m128i avg4 = _mm_subs_epu8(avg3, lsb2);
670    const uint32_t extra_out = _mm_cvtsi128_si32(_mm_srli_si128(avg4, 4));
671    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(               avg1    ));
672    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(               avg4    ));
673    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(avg1, 1)));
674    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(avg4, 1)));
675    DST(3, 2) = (extra_out >> 0) & 0xff;
676    DST(3, 3) = (extra_out >> 8) & 0xff;
677  }
678  static void RD4_SSE2(uint8_t* dst) {   
679    const __m128i one = _mm_set1_epi8(1);
680    const __m128i XABCD = _mm_loadl_epi64((__m128i*)(dst - BPS - 1));
681    const __m128i ____XABCD = _mm_slli_si128(XABCD, 4);
682    const uint32_t I = dst[-1 + 0 * BPS];
683    const uint32_t J = dst[-1 + 1 * BPS];
684    const uint32_t K = dst[-1 + 2 * BPS];
685    const uint32_t L = dst[-1 + 3 * BPS];
686    const __m128i LKJI_____ =
687        _mm_cvtsi32_si128(L | (K << 8) | (J << 16) | (I << 24));
688    const __m128i LKJIXABCD = _mm_or_si128(LKJI_____, ____XABCD);
689    const __m128i KJIXABCD_ = _mm_srli_si128(LKJIXABCD, 1);
690    const __m128i JIXABCD__ = _mm_srli_si128(LKJIXABCD, 2);
691    const __m128i avg1 = _mm_avg_epu8(JIXABCD__, LKJIXABCD);
692    const __m128i lsb = _mm_and_si128(_mm_xor_si128(JIXABCD__, LKJIXABCD), one);
693    const __m128i avg2 = _mm_subs_epu8(avg1, lsb);
694    const __m128i abcdefg = _mm_avg_epu8(avg2, KJIXABCD_);
695    WebPUint32ToMem(dst + 3 * BPS, _mm_cvtsi128_si32(               abcdefg    ));
696    WebPUint32ToMem(dst + 2 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 1)));
697    WebPUint32ToMem(dst + 1 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 2)));
698    WebPUint32ToMem(dst + 0 * BPS, _mm_cvtsi128_si32(_mm_srli_si128(abcdefg, 3)));
699  }
700  #undef DST
701  #undef AVG3
702  static WEBP_INLINE void TrueMotion_SSE2(uint8_t* dst, int size) {
703    const uint8_t* top = dst - BPS;
704    const __m128i zero = _mm_setzero_si128();
705    int y;
706    if (size == 4) {
707      const __m128i top_values = _mm_cvtsi32_si128(WebPMemToUint32(top));
708      const __m128i top_base = _mm_unpacklo_epi8(top_values, zero);
709      for (y = 0; y < 4; ++y, dst += BPS) {
710        const int val = dst[-1] - top[-1];
711        const __m128i base = _mm_set1_epi16(val);
712        const __m128i out = _mm_packus_epi16(_mm_add_epi16(base, top_base), zero);
713        WebPUint32ToMem(dst, _mm_cvtsi128_si32(out));
714      }
715    } else if (size == 8) {
716      const __m128i top_values = _mm_loadl_epi64((const __m128i*)top);
717      const __m128i top_base = _mm_unpacklo_epi8(top_values, zero);
718      for (y = 0; y < 8; ++y, dst += BPS) {
719        const int val = dst[-1] - top[-1];
720        const __m128i base = _mm_set1_epi16(val);
721        const __m128i out = _mm_packus_epi16(_mm_add_epi16(base, top_base), zero);
722        _mm_storel_epi64((__m128i*)dst, out);
723      }
724    } else {
725      const __m128i top_values = _mm_loadu_si128((const __m128i*)top);
726      const __m128i top_base_0 = _mm_unpacklo_epi8(top_values, zero);
727      const __m128i top_base_1 = _mm_unpackhi_epi8(top_values, zero);
728      for (y = 0; y < 16; ++y, dst += BPS) {
729        const int val = dst[-1] - top[-1];
730        const __m128i base = _mm_set1_epi16(val);
731        const __m128i out_0 = _mm_add_epi16(base, top_base_0);
732        const __m128i out_1 = _mm_add_epi16(base, top_base_1);
733        const __m128i out = _mm_packus_epi16(out_0, out_1);
734        _mm_storeu_si128((__m128i*)dst, out);
735      }
736    }
737  }
738  static void TM4_SSE2(uint8_t* dst)   { TrueMotion_SSE2(dst, 4); }
739  static void TM8uv_SSE2(uint8_t* dst) { TrueMotion_SSE2(dst, 8); }
740  static void TM16_SSE2(uint8_t* dst)  { TrueMotion_SSE2(dst, 16); }
741  static void VE16_SSE2(uint8_t* dst) {
742    const __m128i top = _mm_loadu_si128((const __m128i*)(dst - BPS));
743    int j;
744    for (j = 0; j < 16; ++j) {
745      _mm_storeu_si128((__m128i*)(dst + j * BPS), top);
746    }
747  }
748  static void HE16_SSE2(uint8_t* dst) {     
749    int j;
750    for (j = 16; j > 0; --j) {
751      const __m128i values = _mm_set1_epi8(dst[-1]);
752      _mm_storeu_si128((__m128i*)dst, values);
753      dst += BPS;
754    }
755  }
756  static WEBP_INLINE void Put16_SSE2(uint8_t v, uint8_t* dst) {
757    int j;
758    const __m128i values = _mm_set1_epi8(v);
759    for (j = 0; j < 16; ++j) {
760      _mm_storeu_si128((__m128i*)(dst + j * BPS), values);
761    }
762  }
763  static void DC16_SSE2(uint8_t* dst) {  
764    const __m128i zero = _mm_setzero_si128();
765    const __m128i top = _mm_loadu_si128((const __m128i*)(dst - BPS));
766    const __m128i sad8x2 = _mm_sad_epu8(top, zero);
767    const __m128i sum = _mm_add_epi16(sad8x2, _mm_shuffle_epi32(sad8x2, 2));
768    int left = 0;
769    int j;
770    for (j = 0; j < 16; ++j) {
771      left += dst[-1 + j * BPS];
772    }
773    {
774      const int DC = _mm_cvtsi128_si32(sum) + left + 16;
775      Put16_SSE2(DC >> 5, dst);
776    }
777  }
778  static void DC16NoTop_SSE2(uint8_t* dst) {  
779    int DC = 8;
780    int j;
781    for (j = 0; j < 16; ++j) {
782      DC += dst[-1 + j * BPS];
783    }
784    Put16_SSE2(DC >> 4, dst);
785  }
786  static void DC16NoLeft_SSE2(uint8_t* dst) {  
787    const __m128i zero = _mm_setzero_si128();
788    const __m128i top = _mm_loadu_si128((const __m128i*)(dst - BPS));
789    const __m128i sad8x2 = _mm_sad_epu8(top, zero);
790    const __m128i sum = _mm_add_epi16(sad8x2, _mm_shuffle_epi32(sad8x2, 2));
791    const int DC = _mm_cvtsi128_si32(sum) + 8;
792    Put16_SSE2(DC >> 4, dst);
793  }
794  static void DC16NoTopLeft_SSE2(uint8_t* dst) {  
795    Put16_SSE2(0x80, dst);
796  }
797  static void VE8uv_SSE2(uint8_t* dst) {    
798    int j;
799    const __m128i top = _mm_loadl_epi64((const __m128i*)(dst - BPS));
800    for (j = 0; j < 8; ++j) {
801      _mm_storel_epi64((__m128i*)(dst + j * BPS), top);
802    }
803  }
804  static WEBP_INLINE void Put8x8uv_SSE2(uint8_t v, uint8_t* dst) {
805    int j;
806    const __m128i values = _mm_set1_epi8(v);
807    for (j = 0; j < 8; ++j) {
808      _mm_storel_epi64((__m128i*)(dst + j * BPS), values);
809    }
810  }
811  static void DC8uv_SSE2(uint8_t* dst) {     
812    const __m128i zero = _mm_setzero_si128();
813    const __m128i top = _mm_loadl_epi64((const __m128i*)(dst - BPS));
814    const __m128i sum = _mm_sad_epu8(top, zero);
815    int left = 0;
816    int j;
817    for (j = 0; j < 8; ++j) {
818      left += dst[-1 + j * BPS];
819    }
820    {
821      const int DC = _mm_cvtsi128_si32(sum) + left + 8;
822      Put8x8uv_SSE2(DC >> 4, dst);
823    }
824  }
825  static void DC8uvNoLeft_SSE2(uint8_t* dst) {   
826    const __m128i zero = _mm_setzero_si128();
827    const __m128i top = _mm_loadl_epi64((const __m128i*)(dst - BPS));
828    const __m128i sum = _mm_sad_epu8(top, zero);
829    const int DC = _mm_cvtsi128_si32(sum) + 4;
830    Put8x8uv_SSE2(DC >> 3, dst);
831  }
832  static void DC8uvNoTop_SSE2(uint8_t* dst) {  
833    int dc0 = 4;
834    int i;
835    for (i = 0; i < 8; ++i) {
836      dc0 += dst[-1 + i * BPS];
837    }
838    Put8x8uv_SSE2(dc0 >> 3, dst);
839  }
840  static void DC8uvNoTopLeft_SSE2(uint8_t* dst) {    
841    Put8x8uv_SSE2(0x80, dst);
842  }
843  extern void VP8DspInitSSE2(void);
844  WEBP_TSAN_IGNORE_FUNCTION void VP8DspInitSSE2(void) {
845    VP8Transform = Transform_SSE2;
846  #if (USE_TRANSFORM_AC3 == 1)
847    VP8TransformAC3 = TransformAC3_SSE2;
848  #endif
849    VP8VFilter16 = VFilter16_SSE2;
850    VP8HFilter16 = HFilter16_SSE2;
851    VP8VFilter8 = VFilter8_SSE2;
852    VP8HFilter8 = HFilter8_SSE2;
853    VP8VFilter16i = VFilter16i_SSE2;
854    VP8HFilter16i = HFilter16i_SSE2;
855    VP8VFilter8i = VFilter8i_SSE2;
856    VP8HFilter8i = HFilter8i_SSE2;
857    VP8SimpleVFilter16 = SimpleVFilter16_SSE2;
858    VP8SimpleHFilter16 = SimpleHFilter16_SSE2;
859    VP8SimpleVFilter16i = SimpleVFilter16i_SSE2;
860    VP8SimpleHFilter16i = SimpleHFilter16i_SSE2;
861    VP8PredLuma4[1] = TM4_SSE2;
862    VP8PredLuma4[2] = VE4_SSE2;
863    VP8PredLuma4[4] = RD4_SSE2;
864    VP8PredLuma4[5] = VR4_SSE2;
865    VP8PredLuma4[6] = LD4_SSE2;
866    VP8PredLuma4[7] = VL4_SSE2;
867    VP8PredLuma16[0] = DC16_SSE2;
868    VP8PredLuma16[1] = TM16_SSE2;
869    VP8PredLuma16[2] = VE16_SSE2;
870    VP8PredLuma16[3] = HE16_SSE2;
871    VP8PredLuma16[4] = DC16NoTop_SSE2;
872    VP8PredLuma16[5] = DC16NoLeft_SSE2;
873    VP8PredLuma16[6] = DC16NoTopLeft_SSE2;
874    VP8PredChroma8[0] = DC8uv_SSE2;
875    VP8PredChroma8[1] = TM8uv_SSE2;
876    VP8PredChroma8[2] = VE8uv_SSE2;
877    VP8PredChroma8[4] = DC8uvNoTop_SSE2;
878    VP8PredChroma8[5] = DC8uvNoLeft_SSE2;
879    VP8PredChroma8[6] = DC8uvNoTopLeft_SSE2;
880  }
881  #else  
882  WEBP_DSP_INIT_STUB(VP8DspInitSSE2)
883  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-reader.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_READER_H_
2  #define RAPIDJSON_READER_H_
3  #include "allocators.h"
4  #include "stream.h"
5  #include "encodedstream.h"
6  #include "internal/clzll.h"
7  #include "internal/meta.h"
8  #include "internal/stack.h"
9  #include "internal/strtod.h"
10  #include <limits>
11  #if defined(RAPIDJSON_SIMD) && defined(_MSC_VER)
12  #include <intrin.h>
13  #pragma intrinsic(_BitScanForward)
14  #endif
15  #ifdef RAPIDJSON_SSE42
16  #include <nmmintrin.h>
17  #elif defined(RAPIDJSON_SSE2)
18  #include <emmintrin.h>
19  #elif defined(RAPIDJSON_NEON)
20  #include <arm_neon.h>
21  #endif
22  #ifdef __clang__
23  RAPIDJSON_DIAG_PUSH
24  RAPIDJSON_DIAG_OFF(old-style-cast)
25  RAPIDJSON_DIAG_OFF(padded)
26  RAPIDJSON_DIAG_OFF(switch-enum)
27  #elif defined(_MSC_VER)
28  RAPIDJSON_DIAG_PUSH
29  RAPIDJSON_DIAG_OFF(4127)  
30  RAPIDJSON_DIAG_OFF(4702)  
31  #endif
32  #ifdef __GNUC__
33  RAPIDJSON_DIAG_PUSH
34  RAPIDJSON_DIAG_OFF(effc++)
35  #endif
36  #define RAPIDJSON_NOTHING &bsol;* deliberately empty */
37  #ifndef RAPIDJSON_PARSE_ERROR_EARLY_RETURN
38  #define RAPIDJSON_PARSE_ERROR_EARLY_RETURN(value) \
39      RAPIDJSON_MULTILINEMACRO_BEGIN \
40      if (RAPIDJSON_UNLIKELY(HasParseError())) { return value; } \
41      RAPIDJSON_MULTILINEMACRO_END
42  #endif
43  #define RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID \
44      RAPIDJSON_PARSE_ERROR_EARLY_RETURN(RAPIDJSON_NOTHING)
45  #ifndef RAPIDJSON_PARSE_ERROR_NORETURN
46  #define RAPIDJSON_PARSE_ERROR_NORETURN(parseErrorCode, offset) \
47      RAPIDJSON_MULTILINEMACRO_BEGIN \
48      RAPIDJSON_ASSERT(!HasParseError()); &bsol;* Error can only be assigned once */ \
49      SetParseError(parseErrorCode, offset); \
50      RAPIDJSON_MULTILINEMACRO_END
51  #endif
52  #ifndef RAPIDJSON_PARSE_ERROR
53  #define RAPIDJSON_PARSE_ERROR(parseErrorCode, offset) \
54      RAPIDJSON_MULTILINEMACRO_BEGIN \
55      RAPIDJSON_PARSE_ERROR_NORETURN(parseErrorCode, offset); \
56      RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID; \
57      RAPIDJSON_MULTILINEMACRO_END
58  #endif
59  #include "error/error.h" 
60  RAPIDJSON_NAMESPACE_BEGIN
61  #ifndef RAPIDJSON_PARSE_DEFAULT_FLAGS
62  #define RAPIDJSON_PARSE_DEFAULT_FLAGS kParseNoFlags
63  #endif
64  enum ParseFlag {
65      kParseNoFlags = 0,              
66      kParseInsituFlag = 1,           
67      kParseValidateEncodingFlag = 2, 
68      kParseIterativeFlag = 4,        
69      kParseStopWhenDoneFlag = 8,     
70      kParseFullPrecisionFlag = 16,   
71      kParseCommentsFlag = 32,        
72      kParseNumbersAsStringsFlag = 64,    
73      kParseTrailingCommasFlag = 128, 
74      kParseNanAndInfFlag = 256,      
75      kParseEscapedApostropheFlag = 512,  
76      kParseDefaultFlags = RAPIDJSON_PARSE_DEFAULT_FLAGS  
77  };
78  template<typename Encoding = UTF8<>, typename Derived = void>
79  struct BaseReaderHandler {
80      typedef typename Encoding::Ch Ch;
81      typedef typename internal::SelectIf<internal::IsSame<Derived, void>, BaseReaderHandler, Derived>::Type Override;
82      bool Default() { return true; }
83      bool Null() { return static_cast<Override&>(*this).Default(); }
84      bool Bool(bool) { return static_cast<Override&>(*this).Default(); }
85      bool Int(int) { return static_cast<Override&>(*this).Default(); }
86      bool Uint(unsigned) { return static_cast<Override&>(*this).Default(); }
87      bool Int64(int64_t) { return static_cast<Override&>(*this).Default(); }
88      bool Uint64(uint64_t) { return static_cast<Override&>(*this).Default(); }
89      bool Double(double) { return static_cast<Override&>(*this).Default(); }
90      bool RawNumber(const Ch* str, SizeType len, bool copy) { return static_cast<Override&>(*this).String(str, len, copy); }
91      bool String(const Ch*, SizeType, bool) { return static_cast<Override&>(*this).Default(); }
92      bool StartObject() { return static_cast<Override&>(*this).Default(); }
93      bool Key(const Ch* str, SizeType len, bool copy) { return static_cast<Override&>(*this).String(str, len, copy); }
94      bool EndObject(SizeType) { return static_cast<Override&>(*this).Default(); }
95      bool StartArray() { return static_cast<Override&>(*this).Default(); }
96      bool EndArray(SizeType) { return static_cast<Override&>(*this).Default(); }
97  };
98  namespace internal {
99  template<typename Stream, int = StreamTraits<Stream>::copyOptimization>
100  class StreamLocalCopy;
101  template<typename Stream>
102  class StreamLocalCopy<Stream, 1> {
103  public:
104      StreamLocalCopy(Stream& original) : s(original), original_(original) {}
105      ~StreamLocalCopy() { original_ = s; }
106      Stream s;
107  private:
108      StreamLocalCopy& operator=(const StreamLocalCopy&) &bsol;* = delete */;
109      Stream& original_;
110  };
111  template<typename Stream>
112  class StreamLocalCopy<Stream, 0> {
113  public:
114      StreamLocalCopy(Stream& original) : s(original) {}
115      Stream& s;
116  private:
117      StreamLocalCopy& operator=(const StreamLocalCopy&) &bsol;* = delete */;
118  };
119  } 
120  template<typename InputStream>
121  void SkipWhitespace(InputStream& is) {
122      internal::StreamLocalCopy<InputStream> copy(is);
123      InputStream& s(copy.s);
124      typename InputStream::Ch c;
125      while ((c = s.Peek()) == ' ' || c == '\n' || c == '\r' || c == '\t')
126          s.Take();
127  }
128  inline const char* SkipWhitespace(const char* p, const char* end) {
129      while (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
130          ++p;
131      return p;
132  }
133  #ifdef RAPIDJSON_SSE42
134  inline const char *SkipWhitespace_SIMD(const char* p) {
135      if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
136          ++p;
137      else
138          return p;
139      const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
140      while (p != nextAligned)
141          if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
142              ++p;
143          else
144              return p;
145      static const char whitespace[16] = " \n\r\t";
146      const __m128i w = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespace[0]));
147      for (;; p += 16) {
148          const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
149          const int r = _mm_cmpistri(w, s, _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_ANY | _SIDD_LEAST_SIGNIFICANT | _SIDD_NEGATIVE_POLARITY);
150          if (r != 16)    
151              return p + r;
152      }
153  }
154  inline const char *SkipWhitespace_SIMD(const char* p, const char* end) {
155      if (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
156          ++p;
157      else
158          return p;
159      static const char whitespace[16] = " \n\r\t";
160      const __m128i w = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespace[0]));
161      for (; p <= end - 16; p += 16) {
162          const __m128i s = _mm_loadu_si128(reinterpret_cast<const __m128i *>(p));
163          const int r = _mm_cmpistri(w, s, _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_ANY | _SIDD_LEAST_SIGNIFICANT | _SIDD_NEGATIVE_POLARITY);
164          if (r != 16)    
165              return p + r;
166      }
167      return SkipWhitespace(p, end);
168  }
169  #elif defined(RAPIDJSON_SSE2)
170  inline const char *SkipWhitespace_SIMD(const char* p) {
171      if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
172          ++p;
173      else
174          return p;
175      const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
176      while (p != nextAligned)
177          if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
178              ++p;
179          else
180              return p;
181      #define C16(c) { c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c }
182      static const char whitespaces[4][16] = { C16(' '), C16('\n'), C16('\r'), C16('\t') };
183      #undef C16
184      const __m128i w0 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[0][0]));
185      const __m128i w1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[1][0]));
186      const __m128i w2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[2][0]));
187      const __m128i w3 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[3][0]));
188      for (;; p += 16) {
189          const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
190          __m128i x = _mm_cmpeq_epi8(s, w0);
191          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w1));
192          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w2));
193          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w3));
194          unsigned short r = static_cast<unsigned short>(~_mm_movemask_epi8(x));
195          if (r != 0) {   
196  #ifdef _MSC_VER         
197              unsigned long offset;
198              _BitScanForward(&offset, r);
199              return p + offset;
200  #else
201              return p + __builtin_ffs(r) - 1;
202  #endif
203          }
204      }
205  }
206  inline const char *SkipWhitespace_SIMD(const char* p, const char* end) {
207      if (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
208          ++p;
209      else
210          return p;
211      #define C16(c) { c, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c }
212      static const char whitespaces[4][16] = { C16(' '), C16('\n'), C16('\r'), C16('\t') };
213      #undef C16
214      const __m128i w0 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[0][0]));
215      const __m128i w1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[1][0]));
216      const __m128i w2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[2][0]));
217      const __m128i w3 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&whitespaces[3][0]));
218      for (; p <= end - 16; p += 16) {
219          const __m128i s = _mm_loadu_si128(reinterpret_cast<const __m128i *>(p));
220          __m128i x = _mm_cmpeq_epi8(s, w0);
221          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w1));
222          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w2));
223          x = _mm_or_si128(x, _mm_cmpeq_epi8(s, w3));
224          unsigned short r = static_cast<unsigned short>(~_mm_movemask_epi8(x));
225          if (r != 0) {   
226  #ifdef _MSC_VER         
227              unsigned long offset;
228              _BitScanForward(&offset, r);
229              return p + offset;
230  #else
231              return p + __builtin_ffs(r) - 1;
232  #endif
233          }
234      }
235      return SkipWhitespace(p, end);
236  }
237  #elif defined(RAPIDJSON_NEON)
238  inline const char *SkipWhitespace_SIMD(const char* p) {
239      if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
240          ++p;
241      else
242          return p;
243      const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
244      while (p != nextAligned)
245          if (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t')
246              ++p;
247          else
248              return p;
249      const uint8x16_t w0 = vmovq_n_u8(' ');
250      const uint8x16_t w1 = vmovq_n_u8('\n');
251      const uint8x16_t w2 = vmovq_n_u8('\r');
252      const uint8x16_t w3 = vmovq_n_u8('\t');
253      for (;; p += 16) {
254          const uint8x16_t s = vld1q_u8(reinterpret_cast<const uint8_t *>(p));
255          uint8x16_t x = vceqq_u8(s, w0);
256          x = vorrq_u8(x, vceqq_u8(s, w1));
257          x = vorrq_u8(x, vceqq_u8(s, w2));
258          x = vorrq_u8(x, vceqq_u8(s, w3));
259          x = vmvnq_u8(x);                       
260          x = vrev64q_u8(x);                     
261          uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
262          uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
263          if (low == 0) {
264              if (high != 0) {
265                  uint32_t lz = internal::clzll(high);
266                  return p + 8 + (lz >> 3);
267              }
268          } else {
269              uint32_t lz = internal::clzll(low);
270              return p + (lz >> 3);
271          }
272      }
273  }
274  inline const char *SkipWhitespace_SIMD(const char* p, const char* end) {
275      if (p != end && (*p == ' ' || *p == '\n' || *p == '\r' || *p == '\t'))
276          ++p;
277      else
278          return p;
279      const uint8x16_t w0 = vmovq_n_u8(' ');
280      const uint8x16_t w1 = vmovq_n_u8('\n');
281      const uint8x16_t w2 = vmovq_n_u8('\r');
282      const uint8x16_t w3 = vmovq_n_u8('\t');
283      for (; p <= end - 16; p += 16) {
284          const uint8x16_t s = vld1q_u8(reinterpret_cast<const uint8_t *>(p));
285          uint8x16_t x = vceqq_u8(s, w0);
286          x = vorrq_u8(x, vceqq_u8(s, w1));
287          x = vorrq_u8(x, vceqq_u8(s, w2));
288          x = vorrq_u8(x, vceqq_u8(s, w3));
289          x = vmvnq_u8(x);                       
290          x = vrev64q_u8(x);                     
291          uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
292          uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
293          if (low == 0) {
294              if (high != 0) {
295                  uint32_t lz = internal::clzll(high);
296                  return p + 8 + (lz >> 3);
297              }
298          } else {
299              uint32_t lz = internal::clzll(low);
300              return p + (lz >> 3);
301          }
302      }
303      return SkipWhitespace(p, end);
304  }
305  #endif 
306  #ifdef RAPIDJSON_SIMD
307  template<> inline void SkipWhitespace(InsituStringStream& is) {
308      is.src_ = const_cast<char*>(SkipWhitespace_SIMD(is.src_));
309  }
310  template<> inline void SkipWhitespace(StringStream& is) {
311      is.src_ = SkipWhitespace_SIMD(is.src_);
312  }
313  template<> inline void SkipWhitespace(EncodedInputStream<UTF8<>, MemoryStream>& is) {
314      is.is_.src_ = SkipWhitespace_SIMD(is.is_.src_, is.is_.end_);
315  }
316  #endif 
317  template <typename SourceEncoding, typename TargetEncoding, typename StackAllocator = CrtAllocator>
318  class GenericReader {
319  public:
320      typedef typename SourceEncoding::Ch Ch; 
321      GenericReader(StackAllocator* stackAllocator = 0, size_t stackCapacity = kDefaultStackCapacity) :
322          stack_(stackAllocator, stackCapacity), parseResult_(), state_(IterativeParsingStartState) {}
323      template <unsigned parseFlags, typename InputStream, typename Handler>
324      ParseResult Parse(InputStream& is, Handler& handler) {
325          if (parseFlags & kParseIterativeFlag)
326              return IterativeParse<parseFlags>(is, handler);
327          parseResult_.Clear();
328          ClearStackOnExit scope(*this);
329          SkipWhitespaceAndComments<parseFlags>(is);
330          RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
331          if (RAPIDJSON_UNLIKELY(is.Peek() == '\0')) {
332              RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorDocumentEmpty, is.Tell());
333              RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
334          }
335          else {
336              ParseValue<parseFlags>(is, handler);
337              RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
338              if (!(parseFlags & kParseStopWhenDoneFlag)) {
339                  SkipWhitespaceAndComments<parseFlags>(is);
340                  RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
341                  if (RAPIDJSON_UNLIKELY(is.Peek() != '\0')) {
342                      RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorDocumentRootNotSingular, is.Tell());
343                      RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
344                  }
345              }
346          }
347          return parseResult_;
348      }
349      template <typename InputStream, typename Handler>
350      ParseResult Parse(InputStream& is, Handler& handler) {
351          return Parse<kParseDefaultFlags>(is, handler);
352      }
353      void IterativeParseInit() {
354          parseResult_.Clear();
355          state_ = IterativeParsingStartState;
356      }
357      template <unsigned parseFlags, typename InputStream, typename Handler>
358      bool IterativeParseNext(InputStream& is, Handler& handler) {
359          while (RAPIDJSON_LIKELY(is.Peek() != '\0')) {
360              SkipWhitespaceAndComments<parseFlags>(is);
361              Token t = Tokenize(is.Peek());
362              IterativeParsingState n = Predict(state_, t);
363              IterativeParsingState d = Transit<parseFlags>(state_, t, n, is, handler);
364              if (RAPIDJSON_UNLIKELY(IsIterativeParsingCompleteState(d))) {
365                  if (d == IterativeParsingErrorState) {
366                      HandleError(state_, is);
367                      return false;
368                  }
369                  RAPIDJSON_ASSERT(d == IterativeParsingFinishState);
370                  state_ = d;
371                  if (!(parseFlags & kParseStopWhenDoneFlag)) {
372                      SkipWhitespaceAndComments<parseFlags>(is);
373                      if (is.Peek() != '\0') {
374                          HandleError(state_, is);
375                          return false;
376                      }
377                  }
378                  return true;
379              }
380              state_ = d;
381              if (!IsIterativeParsingDelimiterState(n))
382                  return true;
383          }
384          stack_.Clear();
385          if (state_ != IterativeParsingFinishState) {
386              HandleError(state_, is);
387              return false;
388          }
389          return true;
390      }
391      RAPIDJSON_FORCEINLINE bool IterativeParseComplete() const {
392          return IsIterativeParsingCompleteState(state_);
393      }
394      bool HasParseError() const { return parseResult_.IsError(); }
395      ParseErrorCode GetParseErrorCode() const { return parseResult_.Code(); }
396      size_t GetErrorOffset() const { return parseResult_.Offset(); }
397  protected:
398      void SetParseError(ParseErrorCode code, size_t offset) { parseResult_.Set(code, offset); }
399  private:
400      GenericReader(const GenericReader&);
401      GenericReader& operator=(const GenericReader&);
402      void ClearStack() { stack_.Clear(); }
403      struct ClearStackOnExit {
404          explicit ClearStackOnExit(GenericReader& r) : r_(r) {}
405          ~ClearStackOnExit() { r_.ClearStack(); }
406      private:
407          GenericReader& r_;
408          ClearStackOnExit(const ClearStackOnExit&);
409          ClearStackOnExit& operator=(const ClearStackOnExit&);
410      };
411      template<unsigned parseFlags, typename InputStream>
412      void SkipWhitespaceAndComments(InputStream& is) {
413          SkipWhitespace(is);
414          if (parseFlags & kParseCommentsFlag) {
415              while (RAPIDJSON_UNLIKELY(Consume(is, '/'))) {
416                  if (Consume(is, '*')) {
417                      while (true) {
418                          if (RAPIDJSON_UNLIKELY(is.Peek() == '\0'))
419                              RAPIDJSON_PARSE_ERROR(kParseErrorUnspecificSyntaxError, is.Tell());
420                          else if (Consume(is, '*')) {
421                              if (Consume(is, '/'))
422                                  break;
423                          }
424                          else
425                              is.Take();
426                      }
427                  }
428                  else if (RAPIDJSON_LIKELY(Consume(is, '/')))
429                      while (is.Peek() != '\0' && is.Take() != '\n') {}
430                  else
431                      RAPIDJSON_PARSE_ERROR(kParseErrorUnspecificSyntaxError, is.Tell());
432                  SkipWhitespace(is);
433              }
434          }
435      }
436      template<unsigned parseFlags, typename InputStream, typename Handler>
437      void ParseObject(InputStream& is, Handler& handler) {
438          RAPIDJSON_ASSERT(is.Peek() == '{');
439          is.Take();  
440          if (RAPIDJSON_UNLIKELY(!handler.StartObject()))
441              RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
442          SkipWhitespaceAndComments<parseFlags>(is);
443          RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
444          if (Consume(is, '}')) {
445              if (RAPIDJSON_UNLIKELY(!handler.EndObject(0)))  
446                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
447              return;
448          }
449          for (SizeType memberCount = 0;;) {
450              if (RAPIDJSON_UNLIKELY(is.Peek() != '"'))
451                  RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissName, is.Tell());
452              ParseString<parseFlags>(is, handler, true);
453              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
454              SkipWhitespaceAndComments<parseFlags>(is);
455              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
456              if (RAPIDJSON_UNLIKELY(!Consume(is, ':')))
457                  RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissColon, is.Tell());
458              SkipWhitespaceAndComments<parseFlags>(is);
459              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
460              ParseValue<parseFlags>(is, handler);
461              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
462              SkipWhitespaceAndComments<parseFlags>(is);
463              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
464              ++memberCount;
465              switch (is.Peek()) {
466                  case ',':
467                      is.Take();
468                      SkipWhitespaceAndComments<parseFlags>(is);
469                      RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
470                      break;
471                  case '}':
472                      is.Take();
473                      if (RAPIDJSON_UNLIKELY(!handler.EndObject(memberCount)))
474                          RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
475                      return;
476                  default:
477                      RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissCommaOrCurlyBracket, is.Tell()); break; 
478              }
479              if (parseFlags & kParseTrailingCommasFlag) {
480                  if (is.Peek() == '}') {
481                      if (RAPIDJSON_UNLIKELY(!handler.EndObject(memberCount)))
482                          RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
483                      is.Take();
484                      return;
485                  }
486              }
487          }
488      }
489      template<unsigned parseFlags, typename InputStream, typename Handler>
490      void ParseArray(InputStream& is, Handler& handler) {
491          RAPIDJSON_ASSERT(is.Peek() == '[');
492          is.Take();  
493          if (RAPIDJSON_UNLIKELY(!handler.StartArray()))
494              RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
495          SkipWhitespaceAndComments<parseFlags>(is);
496          RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
497          if (Consume(is, ']')) {
498              if (RAPIDJSON_UNLIKELY(!handler.EndArray(0))) 
499                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
500              return;
501          }
502          for (SizeType elementCount = 0;;) {
503              ParseValue<parseFlags>(is, handler);
504              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
505              ++elementCount;
506              SkipWhitespaceAndComments<parseFlags>(is);
507              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
508              if (Consume(is, ',')) {
509                  SkipWhitespaceAndComments<parseFlags>(is);
510                  RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
511              }
512              else if (Consume(is, ']')) {
513                  if (RAPIDJSON_UNLIKELY(!handler.EndArray(elementCount)))
514                      RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
515                  return;
516              }
517              else
518                  RAPIDJSON_PARSE_ERROR(kParseErrorArrayMissCommaOrSquareBracket, is.Tell());
519              if (parseFlags & kParseTrailingCommasFlag) {
520                  if (is.Peek() == ']') {
521                      if (RAPIDJSON_UNLIKELY(!handler.EndArray(elementCount)))
522                          RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
523                      is.Take();
524                      return;
525                  }
526              }
527          }
528      }
529      template<unsigned parseFlags, typename InputStream, typename Handler>
530      void ParseNull(InputStream& is, Handler& handler) {
531          RAPIDJSON_ASSERT(is.Peek() == 'n');
532          is.Take();
533          if (RAPIDJSON_LIKELY(Consume(is, 'u') && Consume(is, 'l') && Consume(is, 'l'))) {
534              if (RAPIDJSON_UNLIKELY(!handler.Null()))
535                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
536          }
537          else
538              RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, is.Tell());
539      }
540      template<unsigned parseFlags, typename InputStream, typename Handler>
541      void ParseTrue(InputStream& is, Handler& handler) {
542          RAPIDJSON_ASSERT(is.Peek() == 't');
543          is.Take();
544          if (RAPIDJSON_LIKELY(Consume(is, 'r') && Consume(is, 'u') && Consume(is, 'e'))) {
545              if (RAPIDJSON_UNLIKELY(!handler.Bool(true)))
546                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
547          }
548          else
549              RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, is.Tell());
550      }
551      template<unsigned parseFlags, typename InputStream, typename Handler>
552      void ParseFalse(InputStream& is, Handler& handler) {
553          RAPIDJSON_ASSERT(is.Peek() == 'f');
554          is.Take();
555          if (RAPIDJSON_LIKELY(Consume(is, 'a') && Consume(is, 'l') && Consume(is, 's') && Consume(is, 'e'))) {
556              if (RAPIDJSON_UNLIKELY(!handler.Bool(false)))
557                  RAPIDJSON_PARSE_ERROR(kParseErrorTermination, is.Tell());
558          }
559          else
560              RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, is.Tell());
561      }
562      template<typename InputStream>
563      RAPIDJSON_FORCEINLINE static bool Consume(InputStream& is, typename InputStream::Ch expect) {
564          if (RAPIDJSON_LIKELY(is.Peek() == expect)) {
565              is.Take();
566              return true;
567          }
568          else
569              return false;
570      }
571      template<typename InputStream>
572      unsigned ParseHex4(InputStream& is, size_t escapeOffset) {
573          unsigned codepoint = 0;
574          for (int i = 0; i < 4; i++) {
575              Ch c = is.Peek();
576              codepoint <<= 4;
577              codepoint += static_cast<unsigned>(c);
578              if (c >= '0' && c <= '9')
579                  codepoint -= '0';
580              else if (c >= 'A' && c <= 'F')
581                  codepoint -= 'A' - 10;
582              else if (c >= 'a' && c <= 'f')
583                  codepoint -= 'a' - 10;
584              else {
585                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorStringUnicodeEscapeInvalidHex, escapeOffset);
586                  RAPIDJSON_PARSE_ERROR_EARLY_RETURN(0);
587              }
588              is.Take();
589          }
590          return codepoint;
591      }
592      template <typename CharType>
593      class StackStream {
594      public:
595          typedef CharType Ch;
596          StackStream(internal::Stack<StackAllocator>& stack) : stack_(stack), length_(0) {}
597          RAPIDJSON_FORCEINLINE void Put(Ch c) {
598              *stack_.template Push<Ch>() = c;
599              ++length_;
600          }
601          RAPIDJSON_FORCEINLINE void* Push(SizeType count) {
602              length_ += count;
603              return stack_.template Push<Ch>(count);
604          }
605          size_t Length() const { return length_; }
606          Ch* Pop() {
607              return stack_.template Pop<Ch>(length_);
608          }
609      private:
610          StackStream(const StackStream&);
611          StackStream& operator=(const StackStream&);
612          internal::Stack<StackAllocator>& stack_;
613          SizeType length_;
614      };
615      template<unsigned parseFlags, typename InputStream, typename Handler>
616      void ParseString(InputStream& is, Handler& handler, bool isKey = false) {
617          internal::StreamLocalCopy<InputStream> copy(is);
618          InputStream& s(copy.s);
619          RAPIDJSON_ASSERT(s.Peek() == '\"');
620          s.Take();  
621          bool success = false;
622          if (parseFlags & kParseInsituFlag) {
623              typename InputStream::Ch *head = s.PutBegin();
624              ParseStringToStream<parseFlags, SourceEncoding, SourceEncoding>(s, s);
625              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
626              size_t length = s.PutEnd(head) - 1;
627              RAPIDJSON_ASSERT(length <= 0xFFFFFFFF);
628              const typename TargetEncoding::Ch* const str = reinterpret_cast<typename TargetEncoding::Ch*>(head);
629              success = (isKey ? handler.Key(str, SizeType(length), false) : handler.String(str, SizeType(length), false));
630          }
631          else {
632              StackStream<typename TargetEncoding::Ch> stackStream(stack_);
633              ParseStringToStream<parseFlags, SourceEncoding, TargetEncoding>(s, stackStream);
634              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
635              SizeType length = static_cast<SizeType>(stackStream.Length()) - 1;
636              const typename TargetEncoding::Ch* const str = stackStream.Pop();
637              success = (isKey ? handler.Key(str, length, true) : handler.String(str, length, true));
638          }
639          if (RAPIDJSON_UNLIKELY(!success))
640              RAPIDJSON_PARSE_ERROR(kParseErrorTermination, s.Tell());
641      }
642      template<unsigned parseFlags, typename SEncoding, typename TEncoding, typename InputStream, typename OutputStream>
643      RAPIDJSON_FORCEINLINE void ParseStringToStream(InputStream& is, OutputStream& os) {
644  #define Z16 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
645          static const char escape[256] = {
646              Z16, Z16, 0, 0,'\"', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '/',
647              Z16, Z16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
648              0, 0,'\b', 0, 0, 0,'\f', 0, 0, 0, 0, 0, 0, 0,'\n', 0,
649              0, 0,'\r', 0,'\t', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
650              Z16, Z16, Z16, Z16, Z16, Z16, Z16, Z16
651          };
652  #undef Z16
653          for (;;) {
654              if (!(parseFlags & kParseValidateEncodingFlag))
655                  ScanCopyUnescapedString(is, os);
656              Ch c = is.Peek();
657              if (RAPIDJSON_UNLIKELY(c == '\\')) {    
658                  size_t escapeOffset = is.Tell();    
659                  is.Take();
660                  Ch e = is.Peek();
661                  if ((sizeof(Ch) == 1 || unsigned(e) < 256) && RAPIDJSON_LIKELY(escape[static_cast<unsigned char>(e)])) {
662                      is.Take();
663                      os.Put(static_cast<typename TEncoding::Ch>(escape[static_cast<unsigned char>(e)]));
664                  }
665                  else if ((parseFlags & kParseEscapedApostropheFlag) && RAPIDJSON_LIKELY(e == '\'')) { 
666                      is.Take();
667                      os.Put('\'');
668                  }
669                  else if (RAPIDJSON_LIKELY(e == 'u')) {    
670                      is.Take();
671                      unsigned codepoint = ParseHex4(is, escapeOffset);
672                      RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
673                      if (RAPIDJSON_UNLIKELY(codepoint >= 0xD800 && codepoint <= 0xDFFF)) {
674                          if (RAPIDJSON_LIKELY(codepoint <= 0xDBFF)) {
675                              if (RAPIDJSON_UNLIKELY(!Consume(is, '\\') || !Consume(is, 'u')))
676                                  RAPIDJSON_PARSE_ERROR(kParseErrorStringUnicodeSurrogateInvalid, escapeOffset);
677                              unsigned codepoint2 = ParseHex4(is, escapeOffset);
678                              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;
679                              if (RAPIDJSON_UNLIKELY(codepoint2 < 0xDC00 || codepoint2 > 0xDFFF))
680                                  RAPIDJSON_PARSE_ERROR(kParseErrorStringUnicodeSurrogateInvalid, escapeOffset);
681                              codepoint = (((codepoint - 0xD800) << 10) | (codepoint2 - 0xDC00)) + 0x10000;
682                          }
683                          else
684                          {
685                              RAPIDJSON_PARSE_ERROR(kParseErrorStringUnicodeSurrogateInvalid, escapeOffset);
686                          }
687                      }
688                      TEncoding::Encode(os, codepoint);
689                  }
690                  else
691                      RAPIDJSON_PARSE_ERROR(kParseErrorStringEscapeInvalid, escapeOffset);
692              }
693              else if (RAPIDJSON_UNLIKELY(c == '"')) {    
694                  is.Take();
695                  os.Put('\0');   
696                  return;
697              }
698              else if (RAPIDJSON_UNLIKELY(static_cast<unsigned>(c) < 0x20)) { 
699                  if (c == '\0')
700                      RAPIDJSON_PARSE_ERROR(kParseErrorStringMissQuotationMark, is.Tell());
701                  else
702                      RAPIDJSON_PARSE_ERROR(kParseErrorStringInvalidEncoding, is.Tell());
703              }
704              else {
705                  size_t offset = is.Tell();
706                  if (RAPIDJSON_UNLIKELY((parseFlags & kParseValidateEncodingFlag ?
707                      !Transcoder<SEncoding, TEncoding>::Validate(is, os) :
708                      !Transcoder<SEncoding, TEncoding>::Transcode(is, os))))
709                      RAPIDJSON_PARSE_ERROR(kParseErrorStringInvalidEncoding, offset);
710              }
711          }
712      }
713      template<typename InputStream, typename OutputStream>
714      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InputStream&, OutputStream&) {
715      }
716  #if defined(RAPIDJSON_SSE2) || defined(RAPIDJSON_SSE42)
717      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(StringStream& is, StackStream<char>& os) {
718          const char* p = is.src_;
719          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
720          while (p != nextAligned)
721              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
722                  is.src_ = p;
723                  return;
724              }
725              else
726                  os.Put(*p++);
727          static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
728          static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
729          static const char space[16]  = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
730          const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
731          const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
732          const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
733          for (;; p += 16) {
734              const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
735              const __m128i t1 = _mm_cmpeq_epi8(s, dq);
736              const __m128i t2 = _mm_cmpeq_epi8(s, bs);
737              const __m128i t3 = _mm_cmpeq_epi8(_mm_max_epu8(s, sp), sp); 
738              const __m128i x = _mm_or_si128(_mm_or_si128(t1, t2), t3);
739              unsigned short r = static_cast<unsigned short>(_mm_movemask_epi8(x));
740              if (RAPIDJSON_UNLIKELY(r != 0)) {   
741                  SizeType length;
742      #ifdef _MSC_VER         
743                  unsigned long offset;
744                  _BitScanForward(&offset, r);
745                  length = offset;
746      #else
747                  length = static_cast<SizeType>(__builtin_ffs(r) - 1);
748      #endif
749                  if (length != 0) {
750                      char* q = reinterpret_cast<char*>(os.Push(length));
751                      for (size_t i = 0; i < length; i++)
752                          q[i] = p[i];
753                      p += length;
754                  }
755                  break;
756              }
757              _mm_storeu_si128(reinterpret_cast<__m128i *>(os.Push(16)), s);
758          }
759          is.src_ = p;
760      }
761      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InsituStringStream& is, InsituStringStream& os) {
762          RAPIDJSON_ASSERT(&is == &os);
763          (void)os;
764          if (is.src_ == is.dst_) {
765              SkipUnescapedString(is);
766              return;
767          }
768          char* p = is.src_;
769          char *q = is.dst_;
770          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
771          while (p != nextAligned)
772              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
773                  is.src_ = p;
774                  is.dst_ = q;
775                  return;
776              }
777              else
778                  *q++ = *p++;
779          static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
780          static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
781          static const char space[16] = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
782          const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
783          const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
784          const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
785          for (;; p += 16, q += 16) {
786              const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
787              const __m128i t1 = _mm_cmpeq_epi8(s, dq);
788              const __m128i t2 = _mm_cmpeq_epi8(s, bs);
789              const __m128i t3 = _mm_cmpeq_epi8(_mm_max_epu8(s, sp), sp); 
790              const __m128i x = _mm_or_si128(_mm_or_si128(t1, t2), t3);
791              unsigned short r = static_cast<unsigned short>(_mm_movemask_epi8(x));
792              if (RAPIDJSON_UNLIKELY(r != 0)) {   
793                  size_t length;
794  #ifdef _MSC_VER         
795                  unsigned long offset;
796                  _BitScanForward(&offset, r);
797                  length = offset;
798  #else
799                  length = static_cast<size_t>(__builtin_ffs(r) - 1);
800  #endif
801                  for (const char* pend = p + length; p != pend; )
802                      *q++ = *p++;
803                  break;
804              }
805              _mm_storeu_si128(reinterpret_cast<__m128i *>(q), s);
806          }
807          is.src_ = p;
808          is.dst_ = q;
809      }
810      static RAPIDJSON_FORCEINLINE void SkipUnescapedString(InsituStringStream& is) {
811          RAPIDJSON_ASSERT(is.src_ == is.dst_);
812          char* p = is.src_;
813          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
814          for (; p != nextAligned; p++)
815              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
816                  is.src_ = is.dst_ = p;
817                  return;
818              }
819          static const char dquote[16] = { '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"', '\"' };
820          static const char bslash[16] = { '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\', '\\' };
821          static const char space[16] = { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F };
822          const __m128i dq = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&dquote[0]));
823          const __m128i bs = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&bslash[0]));
824          const __m128i sp = _mm_loadu_si128(reinterpret_cast<const __m128i *>(&space[0]));
825          for (;; p += 16) {
826              const __m128i s = _mm_load_si128(reinterpret_cast<const __m128i *>(p));
827              const __m128i t1 = _mm_cmpeq_epi8(s, dq);
828              const __m128i t2 = _mm_cmpeq_epi8(s, bs);
829              const __m128i t3 = _mm_cmpeq_epi8(_mm_max_epu8(s, sp), sp); 
830              const __m128i x = _mm_or_si128(_mm_or_si128(t1, t2), t3);
831              unsigned short r = static_cast<unsigned short>(_mm_movemask_epi8(x));
832              if (RAPIDJSON_UNLIKELY(r != 0)) {   
833                  size_t length;
834  #ifdef _MSC_VER         
835                  unsigned long offset;
836                  _BitScanForward(&offset, r);
837                  length = offset;
838  #else
839                  length = static_cast<size_t>(__builtin_ffs(r) - 1);
840  #endif
841                  p += length;
842                  break;
843              }
844          }
845          is.src_ = is.dst_ = p;
846      }
847  #elif defined(RAPIDJSON_NEON)
848      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(StringStream& is, StackStream<char>& os) {
849          const char* p = is.src_;
850          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
851          while (p != nextAligned)
852              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
853                  is.src_ = p;
854                  return;
855              }
856              else
857                  os.Put(*p++);
858          const uint8x16_t s0 = vmovq_n_u8('"');
859          const uint8x16_t s1 = vmovq_n_u8('\\');
860          const uint8x16_t s2 = vmovq_n_u8('\b');
861          const uint8x16_t s3 = vmovq_n_u8(32);
862          for (;; p += 16) {
863              const uint8x16_t s = vld1q_u8(reinterpret_cast<const uint8_t *>(p));
864              uint8x16_t x = vceqq_u8(s, s0);
865              x = vorrq_u8(x, vceqq_u8(s, s1));
866              x = vorrq_u8(x, vceqq_u8(s, s2));
867              x = vorrq_u8(x, vcltq_u8(s, s3));
868              x = vrev64q_u8(x);                     
869              uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
870              uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
871              SizeType length = 0;
872              bool escaped = false;
873              if (low == 0) {
874                  if (high != 0) {
875                      uint32_t lz = internal::clzll(high);
876                      length = 8 + (lz >> 3);
877                      escaped = true;
878                  }
879              } else {
880                  uint32_t lz = internal::clzll(low);
881                  length = lz >> 3;
882                  escaped = true;
883              }
884              if (RAPIDJSON_UNLIKELY(escaped)) {   
885                  if (length != 0) {
886                      char* q = reinterpret_cast<char*>(os.Push(length));
887                      for (size_t i = 0; i < length; i++)
888                          q[i] = p[i];
889                      p += length;
890                  }
891                  break;
892              }
893              vst1q_u8(reinterpret_cast<uint8_t *>(os.Push(16)), s);
894          }
895          is.src_ = p;
896      }
897      static RAPIDJSON_FORCEINLINE void ScanCopyUnescapedString(InsituStringStream& is, InsituStringStream& os) {
898          RAPIDJSON_ASSERT(&is == &os);
899          (void)os;
900          if (is.src_ == is.dst_) {
901              SkipUnescapedString(is);
902              return;
903          }
904          char* p = is.src_;
905          char *q = is.dst_;
906          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
907          while (p != nextAligned)
908              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
909                  is.src_ = p;
910                  is.dst_ = q;
911                  return;
912              }
913              else
<span onclick='openModal()' class='match'>914                  *q++ = *p++;
915          const uint8x16_t s0 = vmovq_n_u8('"');
916          const uint8x16_t s1 = vmovq_n_u8('\\');
917          const uint8x16_t s2 = vmovq_n_u8('\b');
918          const uint8x16_t s3 = vmovq_n_u8(32);
</span>919          for (;; p += 16, q += 16) {
920              const uint8x16_t s = vld1q_u8(reinterpret_cast<uint8_t *>(p));
921              uint8x16_t x = vceqq_u8(s, s0);
922              x = vorrq_u8(x, vceqq_u8(s, s1));
923              x = vorrq_u8(x, vceqq_u8(s, s2));
924              x = vorrq_u8(x, vcltq_u8(s, s3));
925              x = vrev64q_u8(x);                     
926              uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
927              uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
928              SizeType length = 0;
929              bool escaped = false;
930              if (low == 0) {
931                  if (high != 0) {
932                      uint32_t lz = internal::clzll(high);
933                      length = 8 + (lz >> 3);
934                      escaped = true;
935                  }
936              } else {
937                  uint32_t lz = internal::clzll(low);
938                  length = lz >> 3;
939                  escaped = true;
940              }
941              if (RAPIDJSON_UNLIKELY(escaped)) {   
942                  for (const char* pend = p + length; p != pend; ) {
943                      *q++ = *p++;
944                  }
945                  break;
946              }
947              vst1q_u8(reinterpret_cast<uint8_t *>(q), s);
948          }
949          is.src_ = p;
950          is.dst_ = q;
951      }
952      static RAPIDJSON_FORCEINLINE void SkipUnescapedString(InsituStringStream& is) {
953          RAPIDJSON_ASSERT(is.src_ == is.dst_);
954          char* p = is.src_;
955          const char* nextAligned = reinterpret_cast<const char*>((reinterpret_cast<size_t>(p) + 15) & static_cast<size_t>(~15));
956          for (; p != nextAligned; p++)
957              if (RAPIDJSON_UNLIKELY(*p == '\"') || RAPIDJSON_UNLIKELY(*p == '\\') || RAPIDJSON_UNLIKELY(static_cast<unsigned>(*p) < 0x20)) {
958                  is.src_ = is.dst_ = p;
959                  return;
960              }
961          const uint8x16_t s0 = vmovq_n_u8('"');
962          const uint8x16_t s1 = vmovq_n_u8('\\');
963          const uint8x16_t s2 = vmovq_n_u8('\b');
964          const uint8x16_t s3 = vmovq_n_u8(32);
965          for (;; p += 16) {
966              const uint8x16_t s = vld1q_u8(reinterpret_cast<uint8_t *>(p));
967              uint8x16_t x = vceqq_u8(s, s0);
968              x = vorrq_u8(x, vceqq_u8(s, s1));
969              x = vorrq_u8(x, vceqq_u8(s, s2));
970              x = vorrq_u8(x, vcltq_u8(s, s3));
971              x = vrev64q_u8(x);                     
972              uint64_t low = vgetq_lane_u64(vreinterpretq_u64_u8(x), 0);   
973              uint64_t high = vgetq_lane_u64(vreinterpretq_u64_u8(x), 1);  
974              if (low == 0) {
975                  if (high != 0) {
976                      uint32_t lz = internal::clzll(high);
977                      p += 8 + (lz >> 3);
978                      break;
979                  }
980              } else {
981                  uint32_t lz = internal::clzll(low);
982                  p += lz >> 3;
983                  break;
984              }
985          }
986          is.src_ = is.dst_ = p;
987      }
988  #endif 
989      template<typename InputStream, typename StackCharacter, bool backup, bool pushOnTake>
990      class NumberStream;
991      template<typename InputStream, typename StackCharacter>
992      class NumberStream<InputStream, StackCharacter, false, false> {
993      public:
994          typedef typename InputStream::Ch Ch;
995          NumberStream(GenericReader& reader, InputStream& s) : is(s) { (void)reader;  }
996          RAPIDJSON_FORCEINLINE Ch Peek() const { return is.Peek(); }
997          RAPIDJSON_FORCEINLINE Ch TakePush() { return is.Take(); }
998          RAPIDJSON_FORCEINLINE Ch Take() { return is.Take(); }
999          RAPIDJSON_FORCEINLINE void Push(char) {}
1000          size_t Tell() { return is.Tell(); }
1001          size_t Length() { return 0; }
1002          const StackCharacter* Pop() { return 0; }
1003      protected:
1004          NumberStream& operator=(const NumberStream&);
1005          InputStream& is;
1006      };
1007      template<typename InputStream, typename StackCharacter>
1008      class NumberStream<InputStream, StackCharacter, true, false> : public NumberStream<InputStream, StackCharacter, false, false> {
1009          typedef NumberStream<InputStream, StackCharacter, false, false> Base;
1010      public:
1011          NumberStream(GenericReader& reader, InputStream& is) : Base(reader, is), stackStream(reader.stack_) {}
1012          RAPIDJSON_FORCEINLINE Ch TakePush() {
1013              stackStream.Put(static_cast<StackCharacter>(Base::is.Peek()));
1014              return Base::is.Take();
1015          }
1016          RAPIDJSON_FORCEINLINE void Push(StackCharacter c) {
1017              stackStream.Put(c);
1018          }
1019          size_t Length() { return stackStream.Length(); }
1020          const StackCharacter* Pop() {
1021              stackStream.Put('\0');
1022              return stackStream.Pop();
1023          }
1024      private:
1025          StackStream<StackCharacter> stackStream;
1026      };
1027      template<typename InputStream, typename StackCharacter>
1028      class NumberStream<InputStream, StackCharacter, true, true> : public NumberStream<InputStream, StackCharacter, true, false> {
1029          typedef NumberStream<InputStream, StackCharacter, true, false> Base;
1030      public:
1031          NumberStream(GenericReader& reader, InputStream& is) : Base(reader, is) {}
1032          RAPIDJSON_FORCEINLINE Ch Take() { return Base::TakePush(); }
1033      };
1034      template<unsigned parseFlags, typename InputStream, typename Handler>
1035      void ParseNumber(InputStream& is, Handler& handler) {
1036          typedef typename internal::SelectIf<internal::BoolType<(parseFlags & kParseNumbersAsStringsFlag) != 0>, typename TargetEncoding::Ch, char>::Type NumberCharacter;
1037          internal::StreamLocalCopy<InputStream> copy(is);
1038          NumberStream<InputStream, NumberCharacter,
1039              ((parseFlags & kParseNumbersAsStringsFlag) != 0) ?
1040                  ((parseFlags & kParseInsituFlag) == 0) :
1041                  ((parseFlags & kParseFullPrecisionFlag) != 0),
1042              (parseFlags & kParseNumbersAsStringsFlag) != 0 &&
1043                  (parseFlags & kParseInsituFlag) == 0> s(*this, copy.s);
1044          size_t startOffset = s.Tell();
1045          double d = 0.0;
1046          bool useNanOrInf = false;
1047          bool minus = Consume(s, '-');
1048          unsigned i = 0;
1049          uint64_t i64 = 0;
1050          bool use64bit = false;
1051          int significandDigit = 0;
1052          if (RAPIDJSON_UNLIKELY(s.Peek() == '0')) {
1053              i = 0;
1054              s.TakePush();
1055          }
1056          else if (RAPIDJSON_LIKELY(s.Peek() >= '1' && s.Peek() <= '9')) {
1057              i = static_cast<unsigned>(s.TakePush() - '0');
1058              if (minus)
1059                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1060                      if (RAPIDJSON_UNLIKELY(i >= 214748364)) { 
1061                          if (RAPIDJSON_LIKELY(i != 214748364 || s.Peek() > '8')) {
1062                              i64 = i;
1063                              use64bit = true;
1064                              break;
1065                          }
1066                      }
1067                      i = i * 10 + static_cast<unsigned>(s.TakePush() - '0');
1068                      significandDigit++;
1069                  }
1070              else
1071                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1072                      if (RAPIDJSON_UNLIKELY(i >= 429496729)) { 
1073                          if (RAPIDJSON_LIKELY(i != 429496729 || s.Peek() > '5')) {
1074                              i64 = i;
1075                              use64bit = true;
1076                              break;
1077                          }
1078                      }
1079                      i = i * 10 + static_cast<unsigned>(s.TakePush() - '0');
1080                      significandDigit++;
1081                  }
1082          }
1083          else if ((parseFlags & kParseNanAndInfFlag) && RAPIDJSON_LIKELY((s.Peek() == 'I' || s.Peek() == 'N'))) {
1084              if (Consume(s, 'N')) {
1085                  if (Consume(s, 'a') && Consume(s, 'N')) {
1086                      d = std::numeric_limits<double>::quiet_NaN();
1087                      useNanOrInf = true;
1088                  }
1089              }
1090              else if (RAPIDJSON_LIKELY(Consume(s, 'I'))) {
1091                  if (Consume(s, 'n') && Consume(s, 'f')) {
1092                      d = (minus ? -std::numeric_limits<double>::infinity() : std::numeric_limits<double>::infinity());
1093                      useNanOrInf = true;
1094                      if (RAPIDJSON_UNLIKELY(s.Peek() == 'i' && !(Consume(s, 'i') && Consume(s, 'n')
1095                                                                  && Consume(s, 'i') && Consume(s, 't') && Consume(s, 'y')))) {
1096                          RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, s.Tell());
1097                      }
1098                  }
1099              }
1100              if (RAPIDJSON_UNLIKELY(!useNanOrInf)) {
1101                  RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, s.Tell());
1102              }
1103          }
1104          else
1105              RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, s.Tell());
1106          bool useDouble = false;
1107          if (use64bit) {
1108              if (minus)
1109                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1110                       if (RAPIDJSON_UNLIKELY(i64 >= RAPIDJSON_UINT64_C2(0x0CCCCCCC, 0xCCCCCCCC))) 
1111                          if (RAPIDJSON_LIKELY(i64 != RAPIDJSON_UINT64_C2(0x0CCCCCCC, 0xCCCCCCCC) || s.Peek() > '8')) {
1112                              d = static_cast<double>(i64);
1113                              useDouble = true;
1114                              break;
1115                          }
1116                      i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
1117                      significandDigit++;
1118                  }
1119              else
1120                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1121                      if (RAPIDJSON_UNLIKELY(i64 >= RAPIDJSON_UINT64_C2(0x19999999, 0x99999999))) 
1122                          if (RAPIDJSON_LIKELY(i64 != RAPIDJSON_UINT64_C2(0x19999999, 0x99999999) || s.Peek() > '5')) {
1123                              d = static_cast<double>(i64);
1124                              useDouble = true;
1125                              break;
1126                          }
1127                      i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
1128                      significandDigit++;
1129                  }
1130          }
1131          if (useDouble) {
1132              while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1133                  d = d * 10 + (s.TakePush() - '0');
1134              }
1135          }
1136          int expFrac = 0;
1137          size_t decimalPosition;
1138          if (Consume(s, '.')) {
1139              decimalPosition = s.Length();
1140              if (RAPIDJSON_UNLIKELY(!(s.Peek() >= '0' && s.Peek() <= '9')))
1141                  RAPIDJSON_PARSE_ERROR(kParseErrorNumberMissFraction, s.Tell());
1142              if (!useDouble) {
1143  #if RAPIDJSON_64BIT
1144                  if (!use64bit)
1145                      i64 = i;
1146                  while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1147                      if (i64 > RAPIDJSON_UINT64_C2(0x1FFFFF, 0xFFFFFFFF)) 
1148                          break;
1149                      else {
1150                          i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');
1151                          --expFrac;
1152                          if (i64 != 0)
1153                              significandDigit++;
1154                      }
1155                  }
1156                  d = static_cast<double>(i64);
1157  #else
1158                  d = static_cast<double>(use64bit ? i64 : i);
1159  #endif
1160                  useDouble = true;
1161              }
1162              while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1163                  if (significandDigit < 17) {
1164                      d = d * 10.0 + (s.TakePush() - '0');
1165                      --expFrac;
1166                      if (RAPIDJSON_LIKELY(d > 0.0))
1167                          significandDigit++;
1168                  }
1169                  else
1170                      s.TakePush();
1171              }
1172          }
1173          else
1174              decimalPosition = s.Length(); 
1175          int exp = 0;
1176          if (Consume(s, 'e') || Consume(s, 'E')) {
1177              if (!useDouble) {
1178                  d = static_cast<double>(use64bit ? i64 : i);
1179                  useDouble = true;
1180              }
1181              bool expMinus = false;
1182              if (Consume(s, '+'))
1183                  ;
1184              else if (Consume(s, '-'))
1185                  expMinus = true;
1186              if (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1187                  exp = static_cast<int>(s.Take() - '0');
1188                  if (expMinus) {
1189                      RAPIDJSON_ASSERT(expFrac <= 0);
1190                      int maxExp = (expFrac + 2147483639) / 10;
1191                      while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1192                          exp = exp * 10 + static_cast<int>(s.Take() - '0');
1193                          if (RAPIDJSON_UNLIKELY(exp > maxExp)) {
1194                              while (RAPIDJSON_UNLIKELY(s.Peek() >= '0' && s.Peek() <= '9'))  
1195                                  s.Take();
1196                          }
1197                      }
1198                  }
1199                  else {  
1200                      int maxExp = 308 - expFrac;
1201                      while (RAPIDJSON_LIKELY(s.Peek() >= '0' && s.Peek() <= '9')) {
1202                          exp = exp * 10 + static_cast<int>(s.Take() - '0');
1203                          if (RAPIDJSON_UNLIKELY(exp > maxExp))
1204                              RAPIDJSON_PARSE_ERROR(kParseErrorNumberTooBig, startOffset);
1205                      }
1206                  }
1207              }
1208              else
1209                  RAPIDJSON_PARSE_ERROR(kParseErrorNumberMissExponent, s.Tell());
1210              if (expMinus)
1211                  exp = -exp;
1212          }
1213          bool cont = true;
1214          if (parseFlags & kParseNumbersAsStringsFlag) {
1215              if (parseFlags & kParseInsituFlag) {
1216                  s.Pop();  
1217                  typename InputStream::Ch* head = is.PutBegin();
1218                  const size_t length = s.Tell() - startOffset;
1219                  RAPIDJSON_ASSERT(length <= 0xFFFFFFFF);
1220                  const typename TargetEncoding::Ch* const str = reinterpret_cast<typename TargetEncoding::Ch*>(head);
1221                  cont = handler.RawNumber(str, SizeType(length), false);
1222              }
1223              else {
1224                  SizeType numCharsToCopy = static_cast<SizeType>(s.Length());
1225                  GenericStringStream<UTF8<NumberCharacter>> srcStream(s.Pop());
1226                  StackStream<typename TargetEncoding::Ch> dstStream(stack_);
1227                  while (numCharsToCopy--) {
1228                      Transcoder<UTF8<typename TargetEncoding::Ch>, TargetEncoding>::Transcode(srcStream, dstStream);
1229                  }
1230                  dstStream.Put('\0');
1231                  const typename TargetEncoding::Ch* str = dstStream.Pop();
1232                  const SizeType length = static_cast<SizeType>(dstStream.Length()) - 1;
1233                  cont = handler.RawNumber(str, SizeType(length), true);
1234              }
1235          }
1236          else {
1237             size_t length = s.Length();
1238             const NumberCharacter* decimal = s.Pop();  
1239             if (useDouble) {
1240                 int p = exp + expFrac;
1241                 if (parseFlags & kParseFullPrecisionFlag)
1242                     d = internal::StrtodFullPrecision(d, p, decimal, length, decimalPosition, exp);
1243                 else
1244                     d = internal::StrtodNormalPrecision(d, p);
1245                 if (d > (std::numeric_limits<double>::max)()) {
1246                     RAPIDJSON_PARSE_ERROR(kParseErrorNumberTooBig, startOffset);
1247                 }
1248                 cont = handler.Double(minus ? -d : d);
1249             }
1250             else if (useNanOrInf) {
1251                 cont = handler.Double(d);
1252             }
1253             else {
1254                 if (use64bit) {
1255                     if (minus)
1256                         cont = handler.Int64(static_cast<int64_t>(~i64 + 1));
1257                     else
1258                         cont = handler.Uint64(i64);
1259                 }
1260                 else {
1261                     if (minus)
1262                         cont = handler.Int(static_cast<int32_t>(~i + 1));
1263                     else
1264                         cont = handler.Uint(i);
1265                 }
1266             }
1267          }
1268          if (RAPIDJSON_UNLIKELY(!cont))
1269              RAPIDJSON_PARSE_ERROR(kParseErrorTermination, startOffset);
1270      }
1271      template<unsigned parseFlags, typename InputStream, typename Handler>
1272      void ParseValue(InputStream& is, Handler& handler) {
1273          switch (is.Peek()) {
1274              case 'n': ParseNull  <parseFlags>(is, handler); break;
1275              case 't': ParseTrue  <parseFlags>(is, handler); break;
1276              case 'f': ParseFalse <parseFlags>(is, handler); break;
1277              case '"': ParseString<parseFlags>(is, handler); break;
1278              case '{': ParseObject<parseFlags>(is, handler); break;
1279              case '[': ParseArray <parseFlags>(is, handler); break;
1280              default :
1281                        ParseNumber<parseFlags>(is, handler);
1282                        break;
1283          }
1284      }
1285      enum IterativeParsingState {
1286          IterativeParsingFinishState = 0, 
1287          IterativeParsingErrorState,      
1288          IterativeParsingStartState,
1289          IterativeParsingObjectInitialState,
1290          IterativeParsingMemberKeyState,
1291          IterativeParsingMemberValueState,
1292          IterativeParsingObjectFinishState,
1293          IterativeParsingArrayInitialState,
1294          IterativeParsingElementState,
1295          IterativeParsingArrayFinishState,
1296          IterativeParsingValueState,
1297          IterativeParsingElementDelimiterState,
1298          IterativeParsingMemberDelimiterState,
1299          IterativeParsingKeyValueDelimiterState,
1300          cIterativeParsingStateCount
1301      };
1302      enum Token {
1303          LeftBracketToken = 0,
1304          RightBracketToken,
1305          LeftCurlyBracketToken,
1306          RightCurlyBracketToken,
1307          CommaToken,
1308          ColonToken,
1309          StringToken,
1310          FalseToken,
1311          TrueToken,
1312          NullToken,
1313          NumberToken,
1314          kTokenCount
1315      };
1316      RAPIDJSON_FORCEINLINE Token Tokenize(Ch c) const {
1317  #define N NumberToken
1318  #define N16 N,N,N,N,N,N,N,N,N,N,N,N,N,N,N,N
1319          static const unsigned char tokenMap[256] = {
1320              N16, 
1321              N16, 
1322              N, N, StringToken, N, N, N, N, N, N, N, N, N, CommaToken, N, N, N, 
1323              N, N, N, N, N, N, N, N, N, N, ColonToken, N, N, N, N, N, 
1324              N16, 
1325              N, N, N, N, N, N, N, N, N, N, N, LeftBracketToken, N, RightBracketToken, N, N, 
1326              N, N, N, N, N, N, FalseToken, N, N, N, N, N, N, N, NullToken, N, 
1327              N, N, N, N, TrueToken, N, N, N, N, N, N, LeftCurlyBracketToken, N, RightCurlyBracketToken, N, N, 
1328              N16, N16, N16, N16, N16, N16, N16, N16 
1329          };
1330  #undef N
1331  #undef N16
1332          if (sizeof(Ch) == 1 || static_cast<unsigned>(c) < 256)
1333              return static_cast<Token>(tokenMap[static_cast<unsigned char>(c)]);
1334          else
1335              return NumberToken;
1336      }
1337      RAPIDJSON_FORCEINLINE IterativeParsingState Predict(IterativeParsingState state, Token token) const {
1338          static const char G[cIterativeParsingStateCount][kTokenCount] = {
1339              {
1340                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1341                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1342                  IterativeParsingErrorState
1343              },
1344              {
1345                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1346                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1347                  IterativeParsingErrorState
1348              },
1349              {
1350                  IterativeParsingArrayInitialState,  
1351                  IterativeParsingErrorState,         
1352                  IterativeParsingObjectInitialState, 
1353                  IterativeParsingErrorState,         
1354                  IterativeParsingErrorState,         
1355                  IterativeParsingErrorState,         
1356                  IterativeParsingValueState,         
1357                  IterativeParsingValueState,         
1358                  IterativeParsingValueState,         
1359                  IterativeParsingValueState,         
1360                  IterativeParsingValueState          
1361              },
1362              {
1363                  IterativeParsingErrorState,         
1364                  IterativeParsingErrorState,         
1365                  IterativeParsingErrorState,         
1366                  IterativeParsingObjectFinishState,  
1367                  IterativeParsingErrorState,         
1368                  IterativeParsingErrorState,         
1369                  IterativeParsingMemberKeyState,     
1370                  IterativeParsingErrorState,         
1371                  IterativeParsingErrorState,         
1372                  IterativeParsingErrorState,         
1373                  IterativeParsingErrorState          
1374              },
1375              {
1376                  IterativeParsingErrorState,             
1377                  IterativeParsingErrorState,             
1378                  IterativeParsingErrorState,             
1379                  IterativeParsingErrorState,             
1380                  IterativeParsingErrorState,             
1381                  IterativeParsingKeyValueDelimiterState, 
1382                  IterativeParsingErrorState,             
1383                  IterativeParsingErrorState,             
1384                  IterativeParsingErrorState,             
1385                  IterativeParsingErrorState,             
1386                  IterativeParsingErrorState              
1387              },
1388              {
1389                  IterativeParsingErrorState,             
1390                  IterativeParsingErrorState,             
1391                  IterativeParsingErrorState,             
1392                  IterativeParsingObjectFinishState,      
1393                  IterativeParsingMemberDelimiterState,   
1394                  IterativeParsingErrorState,             
1395                  IterativeParsingErrorState,             
1396                  IterativeParsingErrorState,             
1397                  IterativeParsingErrorState,             
1398                  IterativeParsingErrorState,             
1399                  IterativeParsingErrorState              
1400              },
1401              {
1402                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1403                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1404                  IterativeParsingErrorState
1405              },
1406              {
1407                  IterativeParsingArrayInitialState,      
1408                  IterativeParsingArrayFinishState,       
1409                  IterativeParsingObjectInitialState,     
1410                  IterativeParsingErrorState,             
1411                  IterativeParsingErrorState,             
1412                  IterativeParsingErrorState,             
1413                  IterativeParsingElementState,           
1414                  IterativeParsingElementState,           
1415                  IterativeParsingElementState,           
1416                  IterativeParsingElementState,           
1417                  IterativeParsingElementState            
1418              },
1419              {
1420                  IterativeParsingErrorState,             
1421                  IterativeParsingArrayFinishState,       
1422                  IterativeParsingErrorState,             
1423                  IterativeParsingErrorState,             
1424                  IterativeParsingElementDelimiterState,  
1425                  IterativeParsingErrorState,             
1426                  IterativeParsingErrorState,             
1427                  IterativeParsingErrorState,             
1428                  IterativeParsingErrorState,             
1429                  IterativeParsingErrorState,             
1430                  IterativeParsingErrorState              
1431              },
1432              {
1433                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1434                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1435                  IterativeParsingErrorState
1436              },
1437              {
1438                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1439                  IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState, IterativeParsingErrorState,
1440                  IterativeParsingErrorState
1441              },
1442              {
1443                  IterativeParsingArrayInitialState,      
1444                  IterativeParsingArrayFinishState,       
1445                  IterativeParsingObjectInitialState,     
1446                  IterativeParsingErrorState,             
1447                  IterativeParsingErrorState,             
1448                  IterativeParsingErrorState,             
1449                  IterativeParsingElementState,           
1450                  IterativeParsingElementState,           
1451                  IterativeParsingElementState,           
1452                  IterativeParsingElementState,           
1453                  IterativeParsingElementState            
1454              },
1455              {
1456                  IterativeParsingErrorState,         
1457                  IterativeParsingErrorState,         
1458                  IterativeParsingErrorState,         
1459                  IterativeParsingObjectFinishState,  
1460                  IterativeParsingErrorState,         
1461                  IterativeParsingErrorState,         
1462                  IterativeParsingMemberKeyState,     
1463                  IterativeParsingErrorState,         
1464                  IterativeParsingErrorState,         
1465                  IterativeParsingErrorState,         
1466                  IterativeParsingErrorState          
1467              },
1468              {
1469                  IterativeParsingArrayInitialState,      
1470                  IterativeParsingErrorState,             
1471                  IterativeParsingObjectInitialState,     
1472                  IterativeParsingErrorState,             
1473                  IterativeParsingErrorState,             
1474                  IterativeParsingErrorState,             
1475                  IterativeParsingMemberValueState,       
1476                  IterativeParsingMemberValueState,       
1477                  IterativeParsingMemberValueState,       
1478                  IterativeParsingMemberValueState,       
1479                  IterativeParsingMemberValueState        
1480              },
1481          }; 
1482          return static_cast<IterativeParsingState>(G[state][token]);
1483      }
1484      template <unsigned parseFlags, typename InputStream, typename Handler>
1485      RAPIDJSON_FORCEINLINE IterativeParsingState Transit(IterativeParsingState src, Token token, IterativeParsingState dst, InputStream& is, Handler& handler) {
1486          (void)token;
1487          switch (dst) {
1488          case IterativeParsingErrorState:
1489              return dst;
1490          case IterativeParsingObjectInitialState:
1491          case IterativeParsingArrayInitialState:
1492          {
1493              IterativeParsingState n = src;
1494              if (src == IterativeParsingArrayInitialState || src == IterativeParsingElementDelimiterState)
1495                  n = IterativeParsingElementState;
1496              else if (src == IterativeParsingKeyValueDelimiterState)
1497                  n = IterativeParsingMemberValueState;
1498              *stack_.template Push<SizeType>(1) = n;
1499              *stack_.template Push<SizeType>(1) = 0;
1500              bool hr = (dst == IterativeParsingObjectInitialState) ? handler.StartObject() : handler.StartArray();
1501              if (!hr) {
1502                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorTermination, is.Tell());
1503                  return IterativeParsingErrorState;
1504              }
1505              else {
1506                  is.Take();
1507                  return dst;
1508              }
1509          }
1510          case IterativeParsingMemberKeyState:
1511              ParseString<parseFlags>(is, handler, true);
1512              if (HasParseError())
1513                  return IterativeParsingErrorState;
1514              else
1515                  return dst;
1516          case IterativeParsingKeyValueDelimiterState:
1517              RAPIDJSON_ASSERT(token == ColonToken);
1518              is.Take();
1519              return dst;
1520          case IterativeParsingMemberValueState:
1521              ParseValue<parseFlags>(is, handler);
1522              if (HasParseError()) {
1523                  return IterativeParsingErrorState;
1524              }
1525              return dst;
1526          case IterativeParsingElementState:
1527              ParseValue<parseFlags>(is, handler);
1528              if (HasParseError()) {
1529                  return IterativeParsingErrorState;
1530              }
1531              return dst;
1532          case IterativeParsingMemberDelimiterState:
1533          case IterativeParsingElementDelimiterState:
1534              is.Take();
1535              *stack_.template Top<SizeType>() = *stack_.template Top<SizeType>() + 1;
1536              return dst;
1537          case IterativeParsingObjectFinishState:
1538          {
1539              if (!(parseFlags & kParseTrailingCommasFlag) && src == IterativeParsingMemberDelimiterState) {
1540                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorObjectMissName, is.Tell());
1541                  return IterativeParsingErrorState;
1542              }
1543              SizeType c = *stack_.template Pop<SizeType>(1);
1544              if (src == IterativeParsingMemberValueState)
1545                  ++c;
1546              IterativeParsingState n = static_cast<IterativeParsingState>(*stack_.template Pop<SizeType>(1));
1547              if (n == IterativeParsingStartState)
1548                  n = IterativeParsingFinishState;
1549              bool hr = handler.EndObject(c);
1550              if (!hr) {
1551                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorTermination, is.Tell());
1552                  return IterativeParsingErrorState;
1553              }
1554              else {
1555                  is.Take();
1556                  return n;
1557              }
1558          }
1559          case IterativeParsingArrayFinishState:
1560          {
1561              if (!(parseFlags & kParseTrailingCommasFlag) && src == IterativeParsingElementDelimiterState) {
1562                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorValueInvalid, is.Tell());
1563                  return IterativeParsingErrorState;
1564              }
1565              SizeType c = *stack_.template Pop<SizeType>(1);
1566              if (src == IterativeParsingElementState)
1567                  ++c;
1568              IterativeParsingState n = static_cast<IterativeParsingState>(*stack_.template Pop<SizeType>(1));
1569              if (n == IterativeParsingStartState)
1570                  n = IterativeParsingFinishState;
1571              bool hr = handler.EndArray(c);
1572              if (!hr) {
1573                  RAPIDJSON_PARSE_ERROR_NORETURN(kParseErrorTermination, is.Tell());
1574                  return IterativeParsingErrorState;
1575              }
1576              else {
1577                  is.Take();
1578                  return n;
1579              }
1580          }
1581          default:
1582              RAPIDJSON_ASSERT(dst == IterativeParsingValueState);
1583              ParseValue<parseFlags>(is, handler);
1584              if (HasParseError()) {
1585                  return IterativeParsingErrorState;
1586              }
1587              return IterativeParsingFinishState;
1588          }
1589      }
1590      template <typename InputStream>
1591      void HandleError(IterativeParsingState src, InputStream& is) {
1592          if (HasParseError()) {
1593              return;
1594          }
1595          switch (src) {
1596          case IterativeParsingStartState:            RAPIDJSON_PARSE_ERROR(kParseErrorDocumentEmpty, is.Tell()); return;
1597          case IterativeParsingFinishState:           RAPIDJSON_PARSE_ERROR(kParseErrorDocumentRootNotSingular, is.Tell()); return;
1598          case IterativeParsingObjectInitialState:
1599          case IterativeParsingMemberDelimiterState:  RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissName, is.Tell()); return;
1600          case IterativeParsingMemberKeyState:        RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissColon, is.Tell()); return;
1601          case IterativeParsingMemberValueState:      RAPIDJSON_PARSE_ERROR(kParseErrorObjectMissCommaOrCurlyBracket, is.Tell()); return;
1602          case IterativeParsingKeyValueDelimiterState:
1603          case IterativeParsingArrayInitialState:
1604          case IterativeParsingElementDelimiterState: RAPIDJSON_PARSE_ERROR(kParseErrorValueInvalid, is.Tell()); return;
1605          default: RAPIDJSON_ASSERT(src == IterativeParsingElementState); RAPIDJSON_PARSE_ERROR(kParseErrorArrayMissCommaOrSquareBracket, is.Tell()); return;
1606          }
1607      }
1608      RAPIDJSON_FORCEINLINE bool IsIterativeParsingDelimiterState(IterativeParsingState s) const {
1609          return s >= IterativeParsingElementDelimiterState;
1610      }
1611      RAPIDJSON_FORCEINLINE bool IsIterativeParsingCompleteState(IterativeParsingState s) const {
1612          return s <= IterativeParsingErrorState;
1613      }
1614      template <unsigned parseFlags, typename InputStream, typename Handler>
1615      ParseResult IterativeParse(InputStream& is, Handler& handler) {
1616          parseResult_.Clear();
1617          ClearStackOnExit scope(*this);
1618          IterativeParsingState state = IterativeParsingStartState;
1619          SkipWhitespaceAndComments<parseFlags>(is);
1620          RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
1621          while (is.Peek() != '\0') {
1622              Token t = Tokenize(is.Peek());
1623              IterativeParsingState n = Predict(state, t);
1624              IterativeParsingState d = Transit<parseFlags>(state, t, n, is, handler);
1625              if (d == IterativeParsingErrorState) {
1626                  HandleError(state, is);
1627                  break;
1628              }
1629              state = d;
1630              if ((parseFlags & kParseStopWhenDoneFlag) && state == IterativeParsingFinishState)
1631                  break;
1632              SkipWhitespaceAndComments<parseFlags>(is);
1633              RAPIDJSON_PARSE_ERROR_EARLY_RETURN(parseResult_);
1634          }
1635          if (state != IterativeParsingFinishState)
1636              HandleError(state, is);
1637          return parseResult_;
1638      }
1639      static const size_t kDefaultStackCapacity = 256;    
1640      internal::Stack<StackAllocator> stack_;  
1641      ParseResult parseResult_;
1642      IterativeParsingState state_;
1643  }; 
1644  typedef GenericReader<UTF8<>, UTF8<> > Reader;
1645  RAPIDJSON_NAMESPACE_END
1646  #if defined(__clang__) || defined(_MSC_VER)
1647  RAPIDJSON_DIAG_POP
1648  #endif
1649  #ifdef __GNUC__
1650  RAPIDJSON_DIAG_POP
1651  #endif
1652  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-dec_sse2.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-reader.h</div>
                <div class="column column_space"><pre><code>37      const __m128i c4 = _mm_sub_epi16(c1, c2);
38      const __m128i c = _mm_add_epi16(c3, c4);
39      const __m128i d1 = _mm_mulhi_epi16(in1, k1);
40      const __m128i d2 = _mm_mulhi_epi16(in3, k2);
41      const __m128i d3 = _mm_add_epi16(in1, in3);
</pre></code></div>
                <div class="column column_space"><pre><code>914                  *q++ = *p++;
915          const uint8x16_t s0 = vmovq_n_u8('"');
916          const uint8x16_t s1 = vmovq_n_u8('\\');
917          const uint8x16_t s2 = vmovq_n_u8('\b');
918          const uint8x16_t s3 = vmovq_n_u8(32);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    