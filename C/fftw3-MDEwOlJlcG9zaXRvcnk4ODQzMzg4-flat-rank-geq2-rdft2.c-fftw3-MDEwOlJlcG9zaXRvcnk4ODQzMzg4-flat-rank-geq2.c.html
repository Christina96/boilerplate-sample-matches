
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 199, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2-rdft2.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  #include "dft/dft.h"
3  typedef struct {
4       solver super;
5       int spltrnk;
6       const int *buddies;
7       size_t nbuddies;
8  } S;
9  typedef struct {
10       plan_dft super;
11       plan *cldr, *cldc;
12       const S *solver;
13  } P;
14  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
15  {
16       const P *ego = (const P *) ego_;
17       {
18  	  plan_rdft2 *cldr = (plan_rdft2 *) ego->cldr;
19  	  cldr->apply((plan *) cldr, r0, r1, cr, ci);
20       }
21       {
22  	  plan_dft *cldc = (plan_dft *) ego->cldc;
23  	  cldc->apply((plan *) cldc, cr, ci, cr, ci);
24       }
25  }
26  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
27  {
28       const P *ego = (const P *) ego_;
29       {
30  	  plan_dft *cldc = (plan_dft *) ego->cldc;
31  	  cldc->apply((plan *) cldc, ci, cr, ci, cr);
32       }
33       {
34  	  plan_rdft2 *cldr = (plan_rdft2 *) ego->cldr;
35  	  cldr->apply((plan *) cldr, r0, r1, cr, ci);
36       }
37  }
38  static void awake(plan *ego_, enum wakefulness wakefulness)
39  {
40       P *ego = (P *) ego_;
41       X(plan_awake)(ego->cldr, wakefulness);
42       X(plan_awake)(ego->cldc, wakefulness);
43  }
44  static void destroy(plan *ego_)
45  {
46       P *ego = (P *) ego_;
47       X(plan_destroy_internal)(ego->cldr);
48       X(plan_destroy_internal)(ego->cldc);
49  }
50  static void print(const plan *ego_, printer *p)
51  {
52       const P *ego = (const P *) ego_;
53       const S *s = ego->solver;
54       p->print(p, "(rdft2-rank>=2/%d%(%p%)%(%p%))", 
55  	      s->spltrnk, ego->cldr, ego->cldc);
56  }
57  static int picksplit(const S *ego, const tensor *sz, int *rp)
58  {
59       A(sz->rnk > 1); &bsol;* cannot split rnk <= 1 */
60       if (!X(pickdim)(ego->spltrnk, ego->buddies, ego->nbuddies, sz, 1, rp))
61            return 0;
62       *rp += 1; &bsol;* convert from dim. index to rank */
63       if (*rp >= sz->rnk) &bsol;* split must reduce rank */
64            return 0;
65       return 1;
66  }
67  static int applicable0(const solver *ego_, const problem *p_, int *rp,
68  		       const planner *plnr)
69  {
70       const problem_rdft2 *p = (const problem_rdft2 *) p_;
71       const S *ego = (const S *)ego_;
72       return (1
73  	     && FINITE_RNK(p->sz->rnk) && FINITE_RNK(p->vecsz->rnk)
74  	     && (p->kind == R2HC || p->kind == HC2R)
75  	     && p->sz->rnk >= 2
76  	     && picksplit(ego, p->sz, rp)
77  	     && (0
78  		 || (p->r0 != p->cr && 
79  		     (p->kind == R2HC || !NO_DESTROY_INPUTP(plnr)))
80  		 || (p->r0 == p->cr))
81  	  );
82  }
83  static int applicable(const solver *ego_, const problem *p_, 
84  		      const planner *plnr, int *rp)
85  {
86       const S *ego = (const S *)ego_;
87       if (!applicable0(ego_, p_, rp, plnr)) return 0;
88       if (NO_RANK_SPLITSP(plnr) && (ego->spltrnk != ego->buddies[0]))
89            return 0;
90       if (NO_UGLYP(plnr)) {
91  	  const problem_rdft2 *p = (const problem_rdft2 *) p_;
92  	  if (p->vecsz->rnk > 0 &&
93  	      X(tensor_min_stride)(p->vecsz) 
94  	      > X(rdft2_tensor_max_index)(p->sz, p->kind))
95  	       return 0;
96       }
97       return 1;
98  }
99  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
100  {
101       const S *ego = (const S *) ego_;
102       const problem_rdft2 *p;
103       P *pln;
104       plan *cldr = 0, *cldc = 0;
105       tensor *sz1, *sz2, *vecszi, *sz2i;
106       int spltrnk;
107       inplace_kind k;
108       problem *cldp;
109       static const plan_adt padt = {
110  	  X(rdft2_solve), awake, print, destroy
111       };
112       if (!applicable(ego_, p_, plnr, &spltrnk))
113            return (plan *) 0;
114       p = (const problem_rdft2 *) p_;
115       X(tensor_split)(p->sz, &sz1, spltrnk, &sz2);
116       k = p->kind == R2HC ? INPLACE_OS : INPLACE_IS;
117       vecszi = X(tensor_copy_inplace)(p->vecsz, k);
118       sz2i = X(tensor_copy_inplace)(sz2, k);
119       sz2i->dims[sz2i->rnk - 1].n = sz2i->dims[sz2i->rnk - 1].n/2 + 1;
120       cldr = X(mkplan_d)(plnr, 
121  		       X(mkproblem_rdft2_d)(X(tensor_copy)(sz2),
122  					    X(tensor_append)(p->vecsz, sz1),
123  					    p->r0, p->r1,
124  					    p->cr, p->ci, p->kind));
125       if (!cldr) goto nada;
126       if (p->kind == R2HC)
127  	  cldp = X(mkproblem_dft_d)(X(tensor_copy_inplace)(sz1, k),
128  				    X(tensor_append)(vecszi, sz2i),
129  				    p->cr, p->ci, p->cr, p->ci);
130       else &bsol;* HC2R must swap re/im parts to get IDFT */
131  	  cldp = X(mkproblem_dft_d)(X(tensor_copy_inplace)(sz1, k),
132  				    X(tensor_append)(vecszi, sz2i),
133  				    p->ci, p->cr, p->ci, p->cr);
134       cldc = X(mkplan_d)(plnr, cldp);
135       if (!cldc) goto nada;
136       pln = MKPLAN_RDFT2(P, &padt, p->kind == R2HC ? apply_r2hc : apply_hc2r);
137       pln->cldr = cldr;
138       pln->cldc = cldc;
139       pln->solver = ego;
140       X(ops_add)(&cldr->ops, &cldc->ops, &pln->super.super.ops);
<span onclick='openModal()' class='match'>141       X(tensor_destroy4)(sz2i, vecszi, sz2, sz1);
142       return &(pln->super.super);
143   nada:
144       X(plan_destroy_internal)(cldr);
145       X(plan_destroy_internal)(cldc);
146       X(tensor_destroy4)(sz2i, vecszi, sz2, sz1);
147       return (plan *) 0;
148  }
149  static solver *mksolver(int spltrnk, const int *buddies, size_t nbuddies)
150  {
151       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
152       S *slv = MKSOLVER(S, &sadt);
153       slv->spltrnk = spltrnk;
154       slv->buddies = buddies;
155       slv->nbuddies = nbuddies;
156       return &(slv->super);
157  }
158  void X(rdft2_rank_geq2_register)(planner *p)
159  {
160       static const int buddies[] = { 1, 0, -2 };
161       size_t i;
162       for (i = 0; i < NELEM(buddies); ++i)
163            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
164  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2.c</h3>
            <pre><code>1  #include "dft/dft.h"
2  typedef struct {
3       solver super;
4       int spltrnk;
5       const int *buddies;
6       size_t nbuddies;
7  } S;
8  typedef struct {
9       plan_dft super;
10       plan *cld1, *cld2;
11       const S *solver;
12  } P;
13  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
14  {
15       const P *ego = (const P *) ego_;
16       plan_dft *cld1, *cld2;
17       cld1 = (plan_dft *) ego->cld1;
18       cld1->apply(ego->cld1, ri, ii, ro, io);
19       cld2 = (plan_dft *) ego->cld2;
20       cld2->apply(ego->cld2, ro, io, ro, io);
21  }
22  static void awake(plan *ego_, enum wakefulness wakefulness)
23  {
24       P *ego = (P *) ego_;
25       X(plan_awake)(ego->cld1, wakefulness);
26       X(plan_awake)(ego->cld2, wakefulness);
27  }
28  static void destroy(plan *ego_)
29  {
30       P *ego = (P *) ego_;
31       X(plan_destroy_internal)(ego->cld2);
32       X(plan_destroy_internal)(ego->cld1);
33  }
34  static void print(const plan *ego_, printer *p)
35  {
36       const P *ego = (const P *) ego_;
37       const S *s = ego->solver;
38       p->print(p, "(dft-rank>=2/%d%(%p%)%(%p%))",
39  	      s->spltrnk, ego->cld1, ego->cld2);
40  }
41  static int picksplit(const S *ego, const tensor *sz, int *rp)
42  {
43       A(sz->rnk > 1); &bsol;* cannot split rnk <= 1 */
44       if (!X(pickdim)(ego->spltrnk, ego->buddies, ego->nbuddies, sz, 1, rp))
45  	  return 0;
46       *rp += 1; &bsol;* convert from dim. index to rank */
47       if (*rp >= sz->rnk) &bsol;* split must reduce rank */
48  	  return 0;
49       return 1;
50  }
51  static int applicable0(const solver *ego_, const problem *p_, int *rp)
52  {
53       const problem_dft *p = (const problem_dft *) p_;
54       const S *ego = (const S *)ego_;
55       return (1
56  	     && FINITE_RNK(p->sz->rnk) && FINITE_RNK(p->vecsz->rnk)
57  	     && p->sz->rnk >= 2
58  	     && picksplit(ego, p->sz, rp)
59  	  );
60  }
61  static int applicable(const solver *ego_, const problem *p_, 
62  		      const planner *plnr, int *rp)
63  {
64       const S *ego = (const S *)ego_;
65       const problem_dft *p = (const problem_dft *) p_;
66       if (!applicable0(ego_, p_, rp)) return 0;
67       if (NO_RANK_SPLITSP(plnr) && (ego->spltrnk != ego->buddies[0])) return 0;
68       if (NO_UGLYP(plnr))
69  	  if (p->vecsz->rnk > 0 &&
70  	      X(tensor_min_stride)(p->vecsz) > X(tensor_max_index)(p->sz))
71  	       return 0;
72       return 1;
73  }
74  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
75  {
76       const S *ego = (const S *) ego_;
77       const problem_dft *p;
78       P *pln;
79       plan *cld1 = 0, *cld2 = 0;
80       tensor *sz1, *sz2, *vecszi, *sz2i;
81       int spltrnk;
82       static const plan_adt padt = {
83  	  X(dft_solve), awake, print, destroy
84       };
85       if (!applicable(ego_, p_, plnr, &spltrnk))
86            return (plan *) 0;
87       p = (const problem_dft *) p_;
88       X(tensor_split)(p->sz, &sz1, spltrnk, &sz2);
89       vecszi = X(tensor_copy_inplace)(p->vecsz, INPLACE_OS);
90       sz2i = X(tensor_copy_inplace)(sz2, INPLACE_OS);
91       cld1 = X(mkplan_d)(plnr, 
92  			X(mkproblem_dft_d)(X(tensor_copy)(sz2),
93  					   X(tensor_append)(p->vecsz, sz1),
94  					   p->ri, p->ii, p->ro, p->io));
95       if (!cld1) goto nada;
96       cld2 = X(mkplan_d)(plnr, 
97  			X(mkproblem_dft_d)(
98  			     X(tensor_copy_inplace)(sz1, INPLACE_OS),
99  			     X(tensor_append)(vecszi, sz2i),
100  			     p->ro, p->io, p->ro, p->io));
101       if (!cld2) goto nada;
102       pln = MKPLAN_DFT(P, &padt, apply);
103       pln->cld1 = cld1;
104       pln->cld2 = cld2;
105       pln->solver = ego;
106       X(ops_add)(&cld1->ops, &cld2->ops, &pln->super.super.ops);
<span onclick='openModal()' class='match'>107       X(tensor_destroy4)(sz1, sz2, vecszi, sz2i);
108       return &(pln->super.super);
109   nada:
110       X(plan_destroy_internal)(cld2);
111       X(plan_destroy_internal)(cld1);
112       X(tensor_destroy4)(sz1, sz2, vecszi, sz2i);
113       return (plan *) 0;
114  }
115  static solver *mksolver(int spltrnk, const int *buddies, size_t nbuddies)
116  {
117       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
118       S *slv = MKSOLVER(S, &sadt);
119       slv->spltrnk = spltrnk;
120       slv->buddies = buddies;
121       slv->nbuddies = nbuddies;
122       return &(slv->super);
123  }
124  void X(dft_rank_geq2_register)(planner *p)
125  {
126       static const int buddies[] = { 1, 0, -2 };
127       size_t i;
128       for (i = 0; i < NELEM(buddies); ++i)
129            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
130  }
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2-rdft2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2.c</div>
                </div>
                <div class="column column_space"><pre><code>141       X(tensor_destroy4)(sz2i, vecszi, sz2, sz1);
142       return &(pln->super.super);
143   nada:
144       X(plan_destroy_internal)(cldr);
145       X(plan_destroy_internal)(cldc);
146       X(tensor_destroy4)(sz2i, vecszi, sz2, sz1);
147       return (plan *) 0;
148  }
149  static solver *mksolver(int spltrnk, const int *buddies, size_t nbuddies)
150  {
151       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
152       S *slv = MKSOLVER(S, &sadt);
153       slv->spltrnk = spltrnk;
154       slv->buddies = buddies;
155       slv->nbuddies = nbuddies;
156       return &(slv->super);
157  }
158  void X(rdft2_rank_geq2_register)(planner *p)
159  {
160       static const int buddies[] = { 1, 0, -2 };
161       size_t i;
162       for (i = 0; i < NELEM(buddies); ++i)
163            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
164  }
</pre></code></div>
                <div class="column column_space"><pre><code>107       X(tensor_destroy4)(sz1, sz2, vecszi, sz2i);
108       return &(pln->super.super);
109   nada:
110       X(plan_destroy_internal)(cld2);
111       X(plan_destroy_internal)(cld1);
112       X(tensor_destroy4)(sz1, sz2, vecszi, sz2i);
113       return (plan *) 0;
114  }
115  static solver *mksolver(int spltrnk, const int *buddies, size_t nbuddies)
116  {
117       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
118       S *slv = MKSOLVER(S, &sadt);
119       slv->spltrnk = spltrnk;
120       slv->buddies = buddies;
121       slv->nbuddies = nbuddies;
122       return &(slv->super);
123  }
124  void X(dft_rank_geq2_register)(planner *p)
125  {
126       static const int buddies[] = { 1, 0, -2 };
127       size_t i;
128       for (i = 0; i < NELEM(buddies); ++i)
129            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
130  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    