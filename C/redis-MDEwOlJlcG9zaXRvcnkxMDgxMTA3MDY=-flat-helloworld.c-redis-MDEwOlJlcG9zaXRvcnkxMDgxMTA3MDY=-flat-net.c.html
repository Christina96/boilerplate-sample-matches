
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.097902097902098%, Tokens: 9</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-helloworld.c</h3>
            <pre><code>1  #include "../redismodule.h"
2  #include <stdio.h>
3  #include <stdlib.h>
4  #include <ctype.h>
5  #include <string.h>
6  #ifdef _WIN32
7  #include "../Win32_Interop/win32_types_hiredis.h"
8  #endif
9  int HelloSimple_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
10      REDISMODULE_NOT_USED(argv);
11      REDISMODULE_NOT_USED(argc);
12      RedisModule_ReplyWithLongLong(ctx,RedisModule_GetSelectedDb(ctx));
13      return REDISMODULE_OK;
14  }
15  int HelloPushNative_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
16  {
17      if (argc != 3) return RedisModule_WrongArity(ctx);
18      RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
19          REDISMODULE_READ|REDISMODULE_WRITE);
20      RedisModule_ListPush(key,REDISMODULE_LIST_TAIL,argv[2]);
21      size_t newlen = RedisModule_ValueLength(key);
22      RedisModule_CloseKey(key);
23      RedisModule_ReplyWithLongLong(ctx,newlen);
24      return REDISMODULE_OK;
25  }
26  int HelloPushCall_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
27  {
28      if (argc != 3) return RedisModule_WrongArity(ctx);
29      RedisModuleCallReply *reply;
30      reply = RedisModule_Call(ctx,"RPUSH","ss",argv[1],argv[2]);
31      PORT_LONGLONG len = RedisModule_CallReplyInteger(reply);
32      RedisModule_FreeCallReply(reply);
33      RedisModule_ReplyWithLongLong(ctx,len);
34      return REDISMODULE_OK;
35  }
36  int HelloPushCall2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
37  {
38      if (argc != 3) return RedisModule_WrongArity(ctx);
39      RedisModuleCallReply *reply;
40      reply = RedisModule_Call(ctx,"RPUSH","ss",argv[1],argv[2]);
41      RedisModule_ReplyWithCallReply(ctx,reply);
42      RedisModule_FreeCallReply(reply);
43      return REDISMODULE_OK;
44  }
45  int HelloListSumLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
46  {
47      if (argc != 2) return RedisModule_WrongArity(ctx);
48      RedisModuleCallReply *reply;
49      reply = RedisModule_Call(ctx,"LRANGE","sll",argv[1],(PORT_LONGLONG)0,(PORT_LONGLONG)-1);
50      size_t strlen = 0;
51      size_t items = RedisModule_CallReplyLength(reply);
52      size_t j;
53      for (j = 0; j < items; j++) {
54          RedisModuleCallReply *ele = RedisModule_CallReplyArrayElement(reply,j);
55          strlen += RedisModule_CallReplyLength(ele);
56      }
57      RedisModule_FreeCallReply(reply);
58      RedisModule_ReplyWithLongLong(ctx,strlen);
59      return REDISMODULE_OK;
60  }
61  int HelloListSplice_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
62      if (argc != 4) return RedisModule_WrongArity(ctx);
63      RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
64          REDISMODULE_READ|REDISMODULE_WRITE);
<span onclick='openModal()' class='match'>65      RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
66          REDISMODULE_READ|REDISMODULE_WRITE);
67      if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
68           RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
69          (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
70           RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
71      {
72          RedisModule_CloseKey(srckey);
73          RedisModule_CloseKey(dstkey);
74          return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
75      }
76      PORT_LONGLONG count;
77      if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
78          (count < 0)) {
79          RedisModule_CloseKey(srckey);
80          RedisModule_CloseKey(dstkey);
81          return RedisModule_ReplyWithError(ctx,"ERR invalid count");
82      }
</span>83      while(count-- > 0) {
84          RedisModuleString *ele;
85          ele = RedisModule_ListPop(srckey,REDISMODULE_LIST_TAIL);
86          if (ele == NULL) break;
87          RedisModule_ListPush(dstkey,REDISMODULE_LIST_HEAD,ele);
88          RedisModule_FreeString(ctx,ele);
89      }
90      size_t len = RedisModule_ValueLength(srckey);
91      RedisModule_CloseKey(srckey);
92      RedisModule_CloseKey(dstkey);
93      RedisModule_ReplyWithLongLong(ctx,len);
94      return REDISMODULE_OK;
95  }
96  int HelloListSpliceAuto_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
97      if (argc != 4) return RedisModule_WrongArity(ctx);
98      RedisModule_AutoMemory(ctx);
99      RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
100          REDISMODULE_READ|REDISMODULE_WRITE);
101      RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
102          REDISMODULE_READ|REDISMODULE_WRITE);
103      if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
104           RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
105          (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
106           RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
107      {
108          return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
109      }
110      PORT_LONGLONG count;
111      if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
112          (count < 0))
113      {
114          return RedisModule_ReplyWithError(ctx,"ERR invalid count");
115      }
116      while(count-- > 0) {
117          RedisModuleString *ele;
118          ele = RedisModule_ListPop(srckey,REDISMODULE_LIST_TAIL);
119          if (ele == NULL) break;
120          RedisModule_ListPush(dstkey,REDISMODULE_LIST_HEAD,ele);
121      }
122      size_t len = RedisModule_ValueLength(srckey);
123      RedisModule_ReplyWithLongLong(ctx,len);
124      return REDISMODULE_OK;
125  }
126  int HelloRandArray_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
127      if (argc != 2) return RedisModule_WrongArity(ctx);
128      PORT_LONGLONG count;
129      if (RedisModule_StringToLongLong(argv[1],&count) != REDISMODULE_OK ||
130          count < 0)
131          return RedisModule_ReplyWithError(ctx,"ERR invalid count");
132      RedisModule_ReplyWithArray(ctx,count);
133      while(count--) RedisModule_ReplyWithLongLong(ctx,rand());
134      return REDISMODULE_OK;
135  }
136  int HelloRepl1_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
137  {
138      REDISMODULE_NOT_USED(argv);
139      REDISMODULE_NOT_USED(argc);
140      RedisModule_AutoMemory(ctx);
141      RedisModule_Replicate(ctx,"ECHO","c","foo");
142      RedisModule_Call(ctx,"INCR","c!","foo");
143      RedisModule_Call(ctx,"INCR","c!","bar");
144      RedisModule_ReplyWithLongLong(ctx,0);
145      return REDISMODULE_OK;
146  }
147  int HelloRepl2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
148      if (argc != 2) return RedisModule_WrongArity(ctx);
149      RedisModule_AutoMemory(ctx); &bsol;* Use automatic memory management. */
150      RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
151          REDISMODULE_READ|REDISMODULE_WRITE);
152      if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_LIST)
153          return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
154      size_t listlen = RedisModule_ValueLength(key);
155      PORT_LONGLONG sum = 0;
156      while(listlen--) {
157          RedisModuleString *ele = RedisModule_ListPop(key,REDISMODULE_LIST_TAIL);
158          PORT_LONGLONG val;
159          if (RedisModule_StringToLongLong(ele,&val) != REDISMODULE_OK) val = 0;
160          val++;
161          sum += val;
162          RedisModuleString *newele = RedisModule_CreateStringFromLongLong(ctx,val);
163          RedisModule_ListPush(key,REDISMODULE_LIST_HEAD,newele);
164      }
165      RedisModule_ReplyWithLongLong(ctx,sum);
166      RedisModule_ReplicateVerbatim(ctx);
167      return REDISMODULE_OK;
168  }
169  int HelloToggleCase_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
170      if (argc != 2) return RedisModule_WrongArity(ctx);
171      RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
172          REDISMODULE_READ|REDISMODULE_WRITE);
173      int keytype = RedisModule_KeyType(key);
174      if (keytype != REDISMODULE_KEYTYPE_STRING &&
175          keytype != REDISMODULE_KEYTYPE_EMPTY)
176      {
177          RedisModule_CloseKey(key);
178          return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
179      }
180      if (keytype == REDISMODULE_KEYTYPE_STRING) {
181          size_t len, j;
182          char *s = RedisModule_StringDMA(key,&len,REDISMODULE_WRITE);
183          for (j = 0; j < len; j++) {
184              if (isupper(s[j])) {
185                  s[j] = tolower(s[j]);
186              } else {
187                  s[j] = toupper(s[j]);
188              }
189          }
190      }
191      RedisModule_CloseKey(key);
192      RedisModule_ReplyWithSimpleString(ctx,"OK");
193      RedisModule_ReplicateVerbatim(ctx);
194      return REDISMODULE_OK;
195  }
196  int HelloMoreExpire_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
197      RedisModule_AutoMemory(ctx); &bsol;* Use automatic memory management. */
198      if (argc != 3) return RedisModule_WrongArity(ctx);
199      mstime_t addms, expire;
200      if (RedisModule_StringToLongLong(argv[2],&addms) != REDISMODULE_OK)
201          return RedisModule_ReplyWithError(ctx,"ERR invalid expire time");
202      RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
203          REDISMODULE_READ|REDISMODULE_WRITE);
204      expire = RedisModule_GetExpire(key);
205      if (expire != REDISMODULE_NO_EXPIRE) {
206          expire += addms;
207          RedisModule_SetExpire(key,expire);
208      }
209      return RedisModule_ReplyWithSimpleString(ctx,"OK");
210  }
211  int HelloZsumRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
212      double score_start, score_end;
213      if (argc != 4) return RedisModule_WrongArity(ctx);
214      if (RedisModule_StringToDouble(argv[2],&score_start) != REDISMODULE_OK ||
215          RedisModule_StringToDouble(argv[3],&score_end) != REDISMODULE_OK)
216      {
217          return RedisModule_ReplyWithError(ctx,"ERR invalid range");
218      }
219      RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
220          REDISMODULE_READ|REDISMODULE_WRITE);
221      if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {
222          return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
223      }
224      double scoresum_a = 0;
225      double scoresum_b = 0;
226      RedisModule_ZsetFirstInScoreRange(key,score_start,score_end,0,0);
227      while(!RedisModule_ZsetRangeEndReached(key)) {
228          double score;
229          RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
230          RedisModule_FreeString(ctx,ele);
231          scoresum_a += score;
232          RedisModule_ZsetRangeNext(key);
233      }
234      RedisModule_ZsetRangeStop(key);
235      RedisModule_ZsetLastInScoreRange(key,score_start,score_end,0,0);
236      while(!RedisModule_ZsetRangeEndReached(key)) {
237          double score;
238          RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
239          RedisModule_FreeString(ctx,ele);
240          scoresum_b += score;
241          RedisModule_ZsetRangePrev(key);
242      }
243      RedisModule_ZsetRangeStop(key);
244      RedisModule_CloseKey(key);
245      RedisModule_ReplyWithArray(ctx,2);
246      RedisModule_ReplyWithDouble(ctx,scoresum_a);
247      RedisModule_ReplyWithDouble(ctx,scoresum_b);
248      return REDISMODULE_OK;
249  }
250  int HelloLexRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
251      RedisModule_AutoMemory(ctx); &bsol;* Use automatic memory management. */
252      if (argc != 6) return RedisModule_WrongArity(ctx);
253      RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
254          REDISMODULE_READ|REDISMODULE_WRITE);
255      if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {
256          return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
257      }
258      if (RedisModule_ZsetFirstInLexRange(key,argv[2],argv[3]) != REDISMODULE_OK) {
259          return RedisModule_ReplyWithError(ctx,"invalid range");
260      }
261      int arraylen = 0;
262      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);
263      while(!RedisModule_ZsetRangeEndReached(key)) {
264          double score;
265          RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
266          RedisModule_ReplyWithString(ctx,ele);
267          RedisModule_FreeString(ctx,ele);
268          RedisModule_ZsetRangeNext(key);
269          arraylen++;
270      }
271      RedisModule_ZsetRangeStop(key);
272      RedisModule_ReplySetArrayLength(ctx,arraylen);
273      RedisModule_CloseKey(key);
274      return REDISMODULE_OK;
275  }
276  int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
277      RedisModule_AutoMemory(ctx); &bsol;* Use automatic memory management. */
278      if (argc != 4) return RedisModule_WrongArity(ctx);
279      RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
280          REDISMODULE_READ|REDISMODULE_WRITE);
281      int type = RedisModule_KeyType(key);
282      if (type != REDISMODULE_KEYTYPE_HASH &&
283          type != REDISMODULE_KEYTYPE_EMPTY)
284      {
285          return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
286      }
287      RedisModuleString *oldval;
288      RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],&oldval,NULL);
289      if (oldval) {
290          RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);
291      }
292      RedisModule_ReplyWithLongLong(ctx,oldval != NULL);
293      return REDISMODULE_OK;
294  }
295  int HelloLeftPad_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
296      RedisModule_AutoMemory(ctx); &bsol;* Use automatic memory management. */
297      PORT_LONGLONG padlen;
298      if (argc != 4) return RedisModule_WrongArity(ctx);
299      if ((RedisModule_StringToLongLong(argv[2],&padlen) != REDISMODULE_OK) ||
300          (padlen< 0)) {
301          return RedisModule_ReplyWithError(ctx,"ERR invalid padding length");
302      }
303      size_t strlen, chlen;
304      const char *str = RedisModule_StringPtrLen(argv[1], &strlen);
305      const char *ch = RedisModule_StringPtrLen(argv[3], &chlen);
306      if (strlen >= (size_t)padlen)
307          return RedisModule_ReplyWithString(ctx,argv[1]);
308      if (chlen != 1)
309          return RedisModule_ReplyWithError(ctx,
310              "ERR padding must be a single char");
311      padlen -= strlen;
312      char *buf = RedisModule_PoolAlloc(ctx,padlen+strlen);
313      for (PORT_LONGLONG j = 0; j < padlen; j++) buf[j] = *ch;
314      memcpy(buf+padlen,str,strlen);
315      RedisModule_ReplyWithStringBuffer(ctx,buf,padlen+strlen);
316      return REDISMODULE_OK;
317  }
318  int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
319      if (RedisModule_Init(ctx,"helloworld",1,REDISMODULE_APIVER_1)
320          == REDISMODULE_ERR) return REDISMODULE_ERR;
321      for (int j = 0; j < argc; j++) {
322          const char *s = RedisModule_StringPtrLen(argv[j],NULL);
323          printf("Module loaded with ARGV[%d] = %s\n", j, s);
324      }
325      if (RedisModule_CreateCommand(ctx,"hello.simple",
326          HelloSimple_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR)
327          return REDISMODULE_ERR;
328      if (RedisModule_CreateCommand(ctx,"hello.push.native",
329          HelloPushNative_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
330          return REDISMODULE_ERR;
331      if (RedisModule_CreateCommand(ctx,"hello.push.call",
332          HelloPushCall_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
333          return REDISMODULE_ERR;
334      if (RedisModule_CreateCommand(ctx,"hello.push.call2",
335          HelloPushCall2_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
336          return REDISMODULE_ERR;
337      if (RedisModule_CreateCommand(ctx,"hello.list.sum.len",
338          HelloListSumLen_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
339          return REDISMODULE_ERR;
340      if (RedisModule_CreateCommand(ctx,"hello.list.splice",
341          HelloListSplice_RedisCommand,"write deny-oom",1,2,1) == REDISMODULE_ERR)
342          return REDISMODULE_ERR;
343      if (RedisModule_CreateCommand(ctx,"hello.list.splice.auto",
344          HelloListSpliceAuto_RedisCommand,
345          "write deny-oom",1,2,1) == REDISMODULE_ERR)
346          return REDISMODULE_ERR;
347      if (RedisModule_CreateCommand(ctx,"hello.rand.array",
348          HelloRandArray_RedisCommand,"readonly",0,0,0) == REDISMODULE_ERR)
349          return REDISMODULE_ERR;
350      if (RedisModule_CreateCommand(ctx,"hello.repl1",
351          HelloRepl1_RedisCommand,"write",0,0,0) == REDISMODULE_ERR)
352          return REDISMODULE_ERR;
353      if (RedisModule_CreateCommand(ctx,"hello.repl2",
354          HelloRepl2_RedisCommand,"write",1,1,1) == REDISMODULE_ERR)
355          return REDISMODULE_ERR;
356      if (RedisModule_CreateCommand(ctx,"hello.toggle.case",
357          HelloToggleCase_RedisCommand,"write",1,1,1) == REDISMODULE_ERR)
358          return REDISMODULE_ERR;
359      if (RedisModule_CreateCommand(ctx,"hello.more.expire",
360          HelloMoreExpire_RedisCommand,"write",1,1,1) == REDISMODULE_ERR)
361          return REDISMODULE_ERR;
362      if (RedisModule_CreateCommand(ctx,"hello.zsumrange",
363          HelloZsumRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
364          return REDISMODULE_ERR;
365      if (RedisModule_CreateCommand(ctx,"hello.lexrange",
366          HelloLexRange_RedisCommand,"readonly",1,1,1) == REDISMODULE_ERR)
367          return REDISMODULE_ERR;
368      if (RedisModule_CreateCommand(ctx,"hello.hcopy",
369          HelloHCopy_RedisCommand,"write deny-oom",1,1,1) == REDISMODULE_ERR)
370          return REDISMODULE_ERR;
371      if (RedisModule_CreateCommand(ctx,"hello.leftpad",
372          HelloLeftPad_RedisCommand,"",1,1,1) == REDISMODULE_ERR)
373          return REDISMODULE_ERR;
374      return REDISMODULE_OK;
375  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-net.c</h3>
            <pre><code>1  #include "fmacros.h"
2  #include <sys/types.h>
3  #ifndef _WIN32
4  #include <sys/socket.h>
5  #include <sys/select.h>
6  #include <sys/un.h>
7  #include <netinet/in.h>
8  #include <netinet/tcp.h>
9  #include <arpa/inet.h>
10  #include <unistd.h>
11  #include <netdb.h>
12  #endif
13  #include <fcntl.h>
14  #include <string.h>
15  #ifndef _WIN32
16  #include <netdb.h>
17  #endif
18  #include <errno.h>
19  #include <stdarg.h>
20  #include <stdio.h>
21  #ifndef _WIN32
22  #include <poll.h>
23  #endif
24  #include <limits.h>
25  #include "net.h"
26  #include "sds.h"
27  #ifdef _WIN32
28  #include "win32_hiredis.h"
29  #include "mstcpip.h"
30  #endif
31  void __redisSetError(redisContext *c, int type, const char *str);
32  static void redisContextCloseFd(redisContext *c) {
33  	if (c && c->fd >= 0) {
34  		close(c->fd);
35  		c->fd = -1;
36  	}
37  }
38  static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {
39  	char buf[128] = { 0 };
40  	size_t len = 0;
41  	if (prefix != NULL)
42  		len = snprintf(buf, sizeof(buf), "%s: ", prefix);
43  	__redis_strerror_r(errno, (char *)(buf + len), sizeof(buf) - len);
44  	__redisSetError(c, type, buf);
45  }
46  static int redisSetReuseAddr(redisContext *c) {
47  	int on = 1;
48  	if (setsockopt(c->fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
49  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
50  		redisContextCloseFd(c);
51  		return REDIS_ERR;
52  	}
53  	return REDIS_OK;
54  }
55  static int redisCreateSocket(redisContext *c, int type) {
56  	int s;
57  	if ((s = socket(type, SOCK_STREAM, 0)) == -1) {
58  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
59  		return REDIS_ERR;
60  	}
61  	c->fd = s;
62  	if (type == AF_INET) {
63  		if (redisSetReuseAddr(c) == REDIS_ERR) {
64  			return REDIS_ERR;
65  		}
66  	}
67  	return REDIS_OK;
68  }
69  static int redisSetBlocking(redisContext *c, int blocking) {
70  	int flags;
71  	if ((flags = fcntl(c->fd, F_GETFL, 0)) == -1) {
72  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "fcntl(F_GETFL)");
73  		redisContextCloseFd(c);
74  		return REDIS_ERR;
75  	}
76  	if (blocking)
77  		flags &= ~O_NONBLOCK;
78  	else
79  		flags |= O_NONBLOCK;
80  	if (fcntl(c->fd, F_SETFL, flags) == -1) {
81  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "fcntl(F_SETFL)");
82  		redisContextCloseFd(c);
83  		return REDIS_ERR;
84  	}
85  	return REDIS_OK;
86  }
87  int redisKeepAlive(redisContext *c, int interval) {
88  	int val = 1;
89  	int fd = c->fd;
90  	if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1) {
91  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
92  		return REDIS_ERR;
93  	}
94  	val = interval;
95  #ifdef _OSX
96  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &val, sizeof(val)) < 0) {
97  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
98  		return REDIS_ERR;
99  	}
100  #else
101  #ifndef __sun
102  #ifdef _WIN32
103  	{
104  		struct tcp_keepalive settings;
105  		DWORD bytesReturned;
106  		WSAOVERLAPPED overlapped;
107  		settings.onoff = 1;
108  		settings.keepalivetime = interval * 1000;
109  		settings.keepaliveinterval = interval * 1000 / 3;
110  		overlapped.hEvent = NULL;
111  		FDAPI_WSAIoctl(fd,
112  			SIO_KEEPALIVE_VALS,
113  			&settings,
114  			sizeof(struct tcp_keepalive),
115  			NULL,
116  			0,
117  			&bytesReturned,
118  			&overlapped,
119  			NULL);
120  	}
121  #else
122  	val = interval;
123  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {
124  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
125  		return REDIS_ERR;
126  	}
127  	val = interval / 3;
128  	if (val == 0) val = 1;
129  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &val, sizeof(val)) < 0) {
130  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
131  		return REDIS_ERR;
132  	}
133  	val = 3;
134  	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &val, sizeof(val)) < 0) {
135  		__redisSetError(c, REDIS_ERR_OTHER, strerror(errno));
136  		return REDIS_ERR;
137  	}
138  #endif
139  #endif
140  #endif
141  	return REDIS_OK;
142  }
143  static int redisSetTcpNoDelay(redisContext *c) {
144  	int yes = 1;
145  	if (setsockopt(c->fd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes)) == -1) {
146  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(TCP_NODELAY)");
147  		redisContextCloseFd(c);
148  		return REDIS_ERR;
149  	}
150  	return REDIS_OK;
151  }
152  #define __MAX_MSEC (((LONG_MAX) - 999) / 1000)
153  static int redisContextTimeoutMsec(redisContext *c, PORT_LONG *result)
154  {
155  	const struct timeval *timeout = c->timeout;
156  	PORT_LONG msec = -1;
157  	if (timeout != NULL) {
158  		if (timeout->tv_usec > 1000000 || timeout->tv_sec > __MAX_MSEC) {
159  			*result = msec;
160  			return REDIS_ERR;
161  		}
162  		msec = (timeout->tv_sec * 1000) + ((timeout->tv_usec + 999) / 1000);
163  		if (msec < 0 || msec > INT_MAX) {
164  			msec = INT_MAX;
165  		}
166  	}
167  	*result = msec;
168  	return REDIS_OK;
169  }
170  static int redisContextWaitReady(redisContext *c, PORT_LONG msec) {
171  	struct pollfd   wfd[1];
172  	wfd[0].fd = c->fd;
173  	wfd[0].events = POLLOUT;
174  	if (errno == EINPROGRESS) {
175  		int res;
176  		if ((res = poll(wfd, 1, (int)msec)) == -1) {
177  			WIN_PORT_FIX &bsol;* cast (int) */
178  				__redisSetErrorFromErrno(c, REDIS_ERR_IO, "poll(2)");
179  			redisContextCloseFd(c);
180  			return REDIS_ERR;
181  		}
182  		else if (res == 0) {
183  			errno = ETIMEDOUT;
184  			__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
185  			redisContextCloseFd(c);
186  			return REDIS_ERR;
187  		}
188  		if (redisCheckSocketError(c) != REDIS_OK)
189  			return REDIS_ERR;
190  		return REDIS_OK;
191  	}
192  	__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
193  	redisContextCloseFd(c);
194  	return REDIS_ERR;
195  }
196  int redisCheckSocketError(redisContext *c) {
197  	int err = 0;
198  	socklen_t errlen = sizeof(err);
199  	if (getsockopt(c->fd, SOL_SOCKET, SO_ERROR, &err, &errlen) == -1) {
200  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "getsockopt(SO_ERROR)");
201  		return REDIS_ERR;
202  	}
203  	if (err) {
204  		errno = err;
205  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
206  		return REDIS_ERR;
207  	}
208  	return REDIS_OK;
209  }
210  int redisContextSetTimeout(redisContext *c, const struct timeval tv) {
211  	if (setsockopt(c->fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
212  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(SO_RCVTIMEO)");
213  		return REDIS_ERR;
214  	}
215  	if (setsockopt(c->fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
216  		__redisSetErrorFromErrno(c, REDIS_ERR_IO, "setsockopt(SO_SNDTIMEO)");
217  		return REDIS_ERR;
218  	}
219  	return REDIS_OK;
220  }
221  #ifdef _WIN32
222  int redisContextPreConnectTcp(
223  	redisContext *c,
224  	const char *addr,
225  	int port,
226  	struct timeval *timeout,
227  	SOCKADDR_STORAGE* ss) {
<span onclick='openModal()' class='match'>228  	int blocking = (c->flags & REDIS_BLOCK);
229  	if (ParseStorageAddress(addr, port, ss) == FALSE) {
230  		return REDIS_ERR;
231  	}
232  	if (REDIS_OK != redisCreateSocket(c, ss->ss_family)) {
233  		return REDIS_ERR;
234  	}
</span>235  	if (redisSetTcpNoDelay(c) != REDIS_OK)
236  		return REDIS_ERR;
237  	if (blocking == 0) {
238  		if (redisSetBlocking(c, 0) != REDIS_OK)
239  			return REDIS_ERR;
240  	}
241  	return REDIS_OK;
242  }
243  #endif
244  static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
245  	const struct timeval *timeout,
246  	const char *source_addr) {
247  	int s, rv, n;
248  	char _port[6];  &bsol;* strlen("65535"); */
249  	struct addrinfo hints, *servinfo, *bservinfo, *p, *b;
250  	int blocking = (c->flags & REDIS_BLOCK);
251  	int reuseaddr = (c->flags & REDIS_REUSEADDR);
252  	int reuses = 0;
253  	PORT_LONG timeout_msec = -1;
254  	servinfo = NULL;
255  	c->connection_type = REDIS_CONN_TCP;
256  	c->tcp.port = port;
257  	if (c->tcp.host != addr) {
258  		if (c->tcp.host)
259  			free(c->tcp.host);
260  		c->tcp.host = strdup(addr);
261  	}
262  	if (timeout) {
263  		if (c->timeout != timeout) {
264  			if (c->timeout == NULL)
265  				c->timeout = malloc(sizeof(struct timeval));
266  			memcpy(c->timeout, timeout, sizeof(struct timeval));
267  		}
268  	}
269  	else {
270  		if (c->timeout)
271  			free(c->timeout);
272  		c->timeout = NULL;
273  	}
274  	if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) {
275  		__redisSetError(c, REDIS_ERR_IO, "Invalid timeout specified");
276  		goto error;
277  	}
278  	if (source_addr == NULL) {
279  		free(c->tcp.source_addr);
280  		c->tcp.source_addr = NULL;
281  	}
282  	else if (c->tcp.source_addr != source_addr) {
283  		free(c->tcp.source_addr);
284  		c->tcp.source_addr = strdup(source_addr);
285  	}
286  	snprintf(_port, 6, "%d", port);
287  	memset(&hints, 0, sizeof(hints));
288  	hints.ai_family = AF_INET;
289  	hints.ai_socktype = SOCK_STREAM;
290  	if ((rv = getaddrinfo(c->tcp.host, _port, &hints, &servinfo)) != 0) {
291  		hints.ai_family = AF_INET6;
292  		if ((rv = getaddrinfo(addr, _port, &hints, &servinfo)) != 0) {
293  			__redisSetError(c, REDIS_ERR_OTHER, gai_strerror(rv));
294  			return REDIS_ERR;
295  		}
296  	}
297  	for (p = servinfo; p != NULL; p = p->ai_next) {
298  	addrretry:
299  		if ((s = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1)
300  			continue;
301  		c->fd = s;
302  		if (redisSetBlocking(c, 0) != REDIS_OK)
303  			goto error;
304  		if (c->tcp.source_addr) {
305  			int bound = 0;
306  			if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {
307  				char buf[128];
308  				snprintf(buf, sizeof(buf), "Can't get addr: %s", gai_strerror(rv));
309  				__redisSetError(c, REDIS_ERR_OTHER, buf);
310  				goto error;
311  			}
312  			if (reuseaddr) {
313  				n = 1;
314  				if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*)&n,
315  					sizeof(n)) < 0) {
316  					goto error;
317  				}
318  			}
319  			for (b = bservinfo; b != NULL; b = b->ai_next) {
320  				if (bind(s, b->ai_addr, b->ai_addrlen) != -1) {
321  					bound = 1;
322  					break;
323  				}
324  			}
325  			freeaddrinfo(bservinfo);
326  			if (!bound) {
327  				char buf[128];
328  				snprintf(buf, sizeof(buf), "Can't bind socket: %s", strerror(errno));
329  				__redisSetError(c, REDIS_ERR_OTHER, buf);
330  				goto error;
331  			}
332  		}
333  		if (connect(s, p->ai_addr, p->ai_addrlen) == -1) {
334  			if (errno == EHOSTUNREACH) {
335  				redisContextCloseFd(c);
336  				continue;
337  			}
338  			else if (errno == EINPROGRESS && !blocking) {
339  			}
340  			else if (errno == EADDRNOTAVAIL && reuseaddr) {
341  				if (++reuses >= REDIS_CONNECT_RETRIES) {
342  					goto error;
343  				}
344  				else {
345  					redisContextCloseFd(c);
346  					goto addrretry;
347  				}
348  			}
349  			else {
350  				if (redisContextWaitReady(c, timeout_msec) != REDIS_OK)
351  					goto error;
352  			}
353  		}
354  		if (blocking && redisSetBlocking(c, 1) != REDIS_OK)
355  			goto error;
356  		if (redisSetTcpNoDelay(c) != REDIS_OK)
357  			goto error;
358  		c->flags |= REDIS_CONNECTED;
359  		rv = REDIS_OK;
360  		goto end;
361  	}
362  	if (p == NULL) {
363  		char buf[128];
364  		snprintf(buf, sizeof(buf), "Can't create socket: %s", strerror(errno));
365  		__redisSetError(c, REDIS_ERR_OTHER, buf);
366  		goto error;
367  	}
368  error:
369  	rv = REDIS_ERR;
370  end:
371  	freeaddrinfo(servinfo);
372  	return rv;  
373  }
374  int redisContextConnectTcp(redisContext *c, const char *addr, int port,
375  	const struct timeval *timeout) {
376  	return _redisContextConnectTcp(c, addr, port, timeout, NULL);
377  }
378  int redisContextConnectBindTcp(redisContext *c, const char *addr, int port,
379  	const struct timeval *timeout,
380  	const char *source_addr) {
381  	return _redisContextConnectTcp(c, addr, port, timeout, source_addr);
382  }
383  #ifdef _WIN32
384  int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {
385  	(void)timeout;
386  	__redisSetError(c, REDIS_ERR_IO,
387  		sdscatprintf(sdsempty(), "Unix sockets are not suported on Windows platform. (%s)\n", path));
388  	return REDIS_ERR;
389  }
390  #else
391  int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {
392  	int blocking = (c->flags & REDIS_BLOCK);
393  	struct sockaddr_un sa;
394  	PORT_LONG timeout_msec = -1;
395  	if (redisCreateSocket(c, AF_LOCAL) < 0)
396  		return REDIS_ERR;
397  	if (redisSetBlocking(c, 0) != REDIS_OK)
398  		return REDIS_ERR;
399  	c->connection_type = REDIS_CONN_UNIX;
400  	if (c->unix_sock.path != path)
401  		c->unix_sock.path = strdup(path);
402  	if (timeout) {
403  		if (c->timeout != timeout) {
404  			if (c->timeout == NULL)
405  				c->timeout = malloc(sizeof(struct timeval));
406  			memcpy(c->timeout, timeout, sizeof(struct timeval));
407  		}
408  	}
409  	else {
410  		if (c->timeout)
411  			free(c->timeout);
412  		c->timeout = NULL;
413  	}
414  	if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK)
415  		return REDIS_ERR;
416  	sa.sun_family = AF_LOCAL;
417  	strncpy(sa.sun_path, path, sizeof(sa.sun_path) - 1);
418  	if (connect(c->fd, (struct sockaddr*)&sa, sizeof(sa)) == -1) {
419  		if (errno == EINPROGRESS && !blocking) {
420  		}
421  		else {
422  			if (redisContextWaitReady(c, timeout_msec) != REDIS_OK)
423  				return REDIS_ERR;
424  		}
425  	}
426  	if (blocking && redisSetBlocking(c, 1) != REDIS_OK)
427  		return REDIS_ERR;
428  	c->flags |= REDIS_CONNECTED;
429  	return REDIS_OK;
430  }
431  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-helloworld.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-net.c</div>
                </div>
                <div class="column column_space"><pre><code>65      RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
66          REDISMODULE_READ|REDISMODULE_WRITE);
67      if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
68           RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
69          (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
70           RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
71      {
72          RedisModule_CloseKey(srckey);
73          RedisModule_CloseKey(dstkey);
74          return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
75      }
76      PORT_LONGLONG count;
77      if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
78          (count < 0)) {
79          RedisModule_CloseKey(srckey);
80          RedisModule_CloseKey(dstkey);
81          return RedisModule_ReplyWithError(ctx,"ERR invalid count");
82      }
</pre></code></div>
                <div class="column column_space"><pre><code>228  	int blocking = (c->flags & REDIS_BLOCK);
229  	if (ParseStorageAddress(addr, port, ss) == FALSE) {
230  		return REDIS_ERR;
231  	}
232  	if (REDIS_OK != redisCreateSocket(c, ss->ss_family)) {
233  		return REDIS_ERR;
234  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    