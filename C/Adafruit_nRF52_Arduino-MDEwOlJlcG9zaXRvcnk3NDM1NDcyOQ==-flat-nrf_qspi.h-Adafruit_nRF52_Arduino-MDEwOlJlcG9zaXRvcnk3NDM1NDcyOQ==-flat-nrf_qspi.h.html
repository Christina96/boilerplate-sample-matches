
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_qspi.h</h3>
            <pre><code>1  #ifndef NRF_QSPI_H__
2  #define NRF_QSPI_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(QSPI_XIPEN_XIPEN_Msk) || defined(__NRFX_DOXYGEN__)
8  #define NRF_QSPI_HAS_XIPEN 1
9  #else
10  #define NRF_QSPI_HAS_XIPEN 0
11  #endif
12  #if defined(QSPI_XIP_ENC_ENABLE_ENABLE_Msk) || defined(__NRFX_DOXYGEN__)
13  #define NRF_QSPI_HAS_XIP_ENC 1
14  #else
15  #define NRF_QSPI_HAS_XIP_ENC 0
16  #endif
17  #if defined(QSPI_DMA_ENC_ENABLE_ENABLE_Msk) || defined(__NRFX_DOXYGEN__)
18  #define NRF_QSPI_HAS_DMA_ENC 1
19  #else
20  #define NRF_QSPI_HAS_DMA_ENC 0
21  #endif
22  #if defined(NRF53_SERIES) || defined(__NRFX_DOXYGEN__)
23  #define NRF_QSPI_BASE_CLOCK_FREQ 96000000uL
24  #else
25  #define NRF_QSPI_BASE_CLOCK_FREQ 32000000uL
26  #endif
27  #define NRF_QSPI_PIN_NOT_CONNECTED 0xFF
28  #define NRF_QSPI_PIN_VAL(pin) (pin) == NRF_QSPI_PIN_NOT_CONNECTED ? 0xFFFFFFFF : (pin)
29  typedef enum
30  {
31      NRF_QSPI_TASK_ACTIVATE   = offsetof(NRF_QSPI_Type, TASKS_ACTIVATE),   &bsol;**< Activate the QSPI interface. */
32      NRF_QSPI_TASK_READSTART  = offsetof(NRF_QSPI_Type, TASKS_READSTART),  &bsol;**< Start transfer from external flash memory to internal RAM. */
33      NRF_QSPI_TASK_WRITESTART = offsetof(NRF_QSPI_Type, TASKS_WRITESTART), &bsol;**< Start transfer from internal RAM to external flash memory. */
34      NRF_QSPI_TASK_ERASESTART = offsetof(NRF_QSPI_Type, TASKS_ERASESTART), &bsol;**< Start external flash memory erase operation. */
35      NRF_QSPI_TASK_DEACTIVATE = offsetof(NRF_QSPI_Type, TASKS_DEACTIVATE), &bsol;**< Deactivate the QSPI interface. */
36  } nrf_qspi_task_t;
37  typedef enum
38  {
39      NRF_QSPI_EVENT_READY = offsetof(NRF_QSPI_Type, EVENTS_READY) &bsol;**< QSPI peripheral is ready after it executes any task. */
40  } nrf_qspi_event_t;
41  typedef enum
42  {
43      NRF_QSPI_INT_READY_MASK = QSPI_INTENSET_READY_Msk &bsol;**< Interrupt on READY event. */
44  } nrf_qspi_int_mask_t;
45  typedef enum
46  {
47      NRF_QSPI_FREQ_DIV1,  &bsol;**< Divide by 1. */
48      NRF_QSPI_FREQ_DIV2,  &bsol;**< Divide by 2. */
49      NRF_QSPI_FREQ_DIV3,  &bsol;**< Divide by 3. */
50      NRF_QSPI_FREQ_DIV4,  &bsol;**< Divide by 4. */
51      NRF_QSPI_FREQ_DIV5,  &bsol;**< Divide by 5. */
52      NRF_QSPI_FREQ_DIV6,  &bsol;**< Divide by 6. */
53      NRF_QSPI_FREQ_DIV7,  &bsol;**< Divide by 7. */
54      NRF_QSPI_FREQ_DIV8,  &bsol;**< Divide by 8. */
55      NRF_QSPI_FREQ_DIV9,  &bsol;**< Divide by 9. */
56      NRF_QSPI_FREQ_DIV10, &bsol;**< Divide by 10. */
57      NRF_QSPI_FREQ_DIV11, &bsol;**< Divide by 11. */
58      NRF_QSPI_FREQ_DIV12, &bsol;**< Divide by 12. */
59      NRF_QSPI_FREQ_DIV13, &bsol;**< Divide by 13. */
60      NRF_QSPI_FREQ_DIV14, &bsol;**< Divide by 14. */
61      NRF_QSPI_FREQ_DIV15, &bsol;**< Divide by 15. */
62      NRF_QSPI_FREQ_DIV16, &bsol;**< Divide by 16. */
63  } nrf_qspi_frequency_t;
64  #if defined(NRF52_SERIES)
65  #define NRF_QSPI_FREQ_32MDIV1  NRF_QSPI_FREQ_DIV1
66  #define NRF_QSPI_FREQ_32MDIV2  NRF_QSPI_FREQ_DIV2
67  #define NRF_QSPI_FREQ_32MDIV3  NRF_QSPI_FREQ_DIV3
68  #define NRF_QSPI_FREQ_32MDIV4  NRF_QSPI_FREQ_DIV4
69  #define NRF_QSPI_FREQ_32MDIV5  NRF_QSPI_FREQ_DIV5
70  #define NRF_QSPI_FREQ_32MDIV6  NRF_QSPI_FREQ_DIV6
71  #define NRF_QSPI_FREQ_32MDIV7  NRF_QSPI_FREQ_DIV7
72  #define NRF_QSPI_FREQ_32MDIV8  NRF_QSPI_FREQ_DIV8
73  #define NRF_QSPI_FREQ_32MDIV9  NRF_QSPI_FREQ_DIV9
74  #define NRF_QSPI_FREQ_32MDIV10 NRF_QSPI_FREQ_DIV10
75  #define NRF_QSPI_FREQ_32MDIV11 NRF_QSPI_FREQ_DIV11
76  #define NRF_QSPI_FREQ_32MDIV12 NRF_QSPI_FREQ_DIV12
77  #define NRF_QSPI_FREQ_32MDIV13 NRF_QSPI_FREQ_DIV13
78  #define NRF_QSPI_FREQ_32MDIV14 NRF_QSPI_FREQ_DIV14
79  #define NRF_QSPI_FREQ_32MDIV15 NRF_QSPI_FREQ_DIV15
80  #define NRF_QSPI_FREQ_32MDIV16 NRF_QSPI_FREQ_DIV16
81  #endif
82  typedef enum
83  {
84      NRF_QSPI_READOC_FASTREAD = QSPI_IFCONFIG0_READOC_FASTREAD, &bsol;**< Single data line SPI. FAST_READ (opcode 0x0B). */
85      NRF_QSPI_READOC_READ2O   = QSPI_IFCONFIG0_READOC_READ2O,   &bsol;**< Dual data line SPI. READ2O (opcode 0x3B). */
86      NRF_QSPI_READOC_READ2IO  = QSPI_IFCONFIG0_READOC_READ2IO,  &bsol;**< Dual data line SPI. READ2IO (opcode 0xBB). */
87      NRF_QSPI_READOC_READ4O   = QSPI_IFCONFIG0_READOC_READ4O,   &bsol;**< Quad data line SPI. READ4O (opcode 0x6B). */
88      NRF_QSPI_READOC_READ4IO  = QSPI_IFCONFIG0_READOC_READ4IO   &bsol;**< Quad data line SPI. READ4IO (opcode 0xEB). */
89  } nrf_qspi_readoc_t;
90  typedef enum
91  {
92      NRF_QSPI_WRITEOC_PP    = QSPI_IFCONFIG0_WRITEOC_PP,    &bsol;**< Single data line SPI. PP (opcode 0x02). */
93      NRF_QSPI_WRITEOC_PP2O  = QSPI_IFCONFIG0_WRITEOC_PP2O,  &bsol;**< Dual data line SPI. PP2O (opcode 0xA2). */
94      NRF_QSPI_WRITEOC_PP4O  = QSPI_IFCONFIG0_WRITEOC_PP4O,  &bsol;**< Quad data line SPI. PP4O (opcode 0x32). */
95      NRF_QSPI_WRITEOC_PP4IO = QSPI_IFCONFIG0_WRITEOC_PP4IO, &bsol;**< Quad data line SPI. READ4O (opcode 0x38). */
96  } nrf_qspi_writeoc_t;
97  typedef enum
98  {
99      NRF_QSPI_ADDRMODE_24BIT = QSPI_IFCONFIG0_ADDRMODE_24BIT, &bsol;**< 24-bit addressing. */
100      NRF_QSPI_ADDRMODE_32BIT = QSPI_IFCONFIG0_ADDRMODE_32BIT  &bsol;**< 32-bit addressing. */
101  } nrf_qspi_addrmode_t;
102  typedef enum
103  {
104      NRF_QSPI_MODE_0 = QSPI_IFCONFIG1_SPIMODE_MODE0, &bsol;**< Mode 0 (CPOL=0, CPHA=0). */
105      NRF_QSPI_MODE_1 = QSPI_IFCONFIG1_SPIMODE_MODE3  &bsol;**< Mode 1 (CPOL=1, CPHA=1). */
106  } nrf_qspi_spi_mode_t;
107  typedef enum
108  {
109      NRF_QSPI_ADDRCONF_MODE_NOINSTR = QSPI_ADDRCONF_MODE_NoInstr, &bsol;**< Do not send any instruction. */
110      NRF_QSPI_ADDRCONF_MODE_OPCODE  = QSPI_ADDRCONF_MODE_Opcode,  &bsol;**< Send opcode. */
111      NRF_QSPI_ADDRCONF_MODE_OPBYTE0 = QSPI_ADDRCONF_MODE_OpByte0, &bsol;**< Send opcode, byte0. */
112      NRF_QSPI_ADDRCONF_MODE_ALL     = QSPI_ADDRCONF_MODE_All      &bsol;**< Send opcode, byte0, byte1. */
113  } nrf_qspi_addrconfig_mode_t;
114  typedef enum
115  {
116      NRF_QSPI_ERASE_LEN_4KB  = QSPI_ERASE_LEN_LEN_4KB,  &bsol;**< Erase 4 kB block (flash command 0x20). */
117      NRF_QSPI_ERASE_LEN_64KB = QSPI_ERASE_LEN_LEN_64KB, &bsol;**< Erase 64 kB block (flash command 0xD8). */
118      NRF_QSPI_ERASE_LEN_ALL  = QSPI_ERASE_LEN_LEN_All   &bsol;**< Erase all (flash command 0xC7). */
119  } nrf_qspi_erase_len_t;
120  typedef enum
121  {
122      NRF_QSPI_CINSTR_LEN_1B = QSPI_CINSTRCONF_LENGTH_1B, &bsol;**< Send opcode only. */
123      NRF_QSPI_CINSTR_LEN_2B = QSPI_CINSTRCONF_LENGTH_2B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0. */
124      NRF_QSPI_CINSTR_LEN_3B = QSPI_CINSTRCONF_LENGTH_3B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT0.BYTE1. */
125      NRF_QSPI_CINSTR_LEN_4B = QSPI_CINSTRCONF_LENGTH_4B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT0.BYTE2. */
126      NRF_QSPI_CINSTR_LEN_5B = QSPI_CINSTRCONF_LENGTH_5B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT0.BYTE3. */
127      NRF_QSPI_CINSTR_LEN_6B = QSPI_CINSTRCONF_LENGTH_6B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT1.BYTE4. */
128      NRF_QSPI_CINSTR_LEN_7B = QSPI_CINSTRCONF_LENGTH_7B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT1.BYTE5. */
129      NRF_QSPI_CINSTR_LEN_8B = QSPI_CINSTRCONF_LENGTH_8B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT1.BYTE6. */
130      NRF_QSPI_CINSTR_LEN_9B = QSPI_CINSTRCONF_LENGTH_9B  &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT1.BYTE7. */
131  } nrf_qspi_cinstr_len_t;
132  typedef struct
133  {
134      uint8_t sck_pin; &bsol;**< SCK pin number. */
135      uint8_t csn_pin; &bsol;**< Chip select pin number. */
136      uint8_t io0_pin; &bsol;**< IO0/MOSI pin number. */
137      uint8_t io1_pin; &bsol;**< IO1/MISO pin number. */
138      uint8_t io2_pin; &bsol;**< IO2 pin number (optional).
139                        *   Set to @ref NRF_QSPI_PIN_NOT_CONNECTED if this signal is not needed.
140                        */
141      uint8_t io3_pin; &bsol;**< IO3 pin number (optional).
142                        *   Set to @ref NRF_QSPI_PIN_NOT_CONNECTED if this signal is not needed.
143                        */
144  } nrf_qspi_pins_t;
145  typedef struct
146  {
147      uint8_t               opcode;    &bsol;**< Opcode used in custom instruction transmission. */
148      nrf_qspi_cinstr_len_t length;    &bsol;**< Length of the custom instruction data. */
149      bool                  io2_level; &bsol;**< I/O line level during transmission. */
150      bool                  io3_level; &bsol;**< I/O line level during transmission. */
151      bool                  wipwait;   &bsol;**< Wait if a Wait in Progress bit is set in the memory status byte. */
152      bool                  wren;      &bsol;**< Send write enable before instruction. */
153  } nrf_qspi_cinstr_conf_t;
154  typedef struct
155  {
156      uint8_t                    opcode;  &bsol;**< Opcode used to enter the proper addressing mode. */
157      uint8_t                    byte0;   &bsol;**< Byte following the opcode. */
158      uint8_t                    byte1;   &bsol;**< Byte following byte0. */
159      nrf_qspi_addrconfig_mode_t mode;    &bsol;**< Extended addresing mode. */
160      bool                       wipwait; &bsol;**< Enable or disable waiting for complete operation execution. */
161      bool                       wren;    &bsol;**< Send write enable before instruction. */
162  } nrf_qspi_addrconfig_conf_t;
163  typedef struct
164  {
165      nrf_qspi_readoc_t   readoc;    &bsol;**< Read operation code. */
166      nrf_qspi_writeoc_t  writeoc;   &bsol;**< Write operation code. */
167      nrf_qspi_addrmode_t addrmode;  &bsol;**< Addresing mode (24-bit or 32-bit). */
168      bool                dpmconfig; &bsol;**< Enable the Deep Power-down Mode (DPM) feature. */
169  } nrf_qspi_prot_conf_t;
170  typedef struct
171  {
172      uint8_t              sck_delay; &bsol;**< tSHSL, tWHSL, and tSHWL in number of 16 MHz periods (62.5ns). */
173      bool                 dpmen;     &bsol;**< Enable the DPM feature. */
174      nrf_qspi_spi_mode_t  spi_mode;  &bsol;**< SPI phase and polarization. */
175      nrf_qspi_frequency_t sck_freq;  &bsol;**< SCK frequency given as QSPI base clock frequency divider.
176                                       *   To calculate @p sck_freq value corresponding to chosen frequency,
177                                       *   use the following equation:
178                                       *
179                                       *   sck_freq = (NRF_QSPI_BASE_CLOCK_FREQ / frequency) - 1
180                                       *
181                                       *   @note Achievable frequencies are determined by available
182                                       *         divider values and QSPI base clock frequency.
183                                       */
184  } nrf_qspi_phy_conf_t;
185  #if NRF_QSPI_HAS_XIP_ENC || NRF_QSPI_HAS_DMA_ENC
186  typedef struct
187  {
188      uint32_t key[4];   &bsol;**< AES 128-bit key, stored on 4 32-bit words. */
189      uint32_t nonce[3]; &bsol;**< AES 96-bit nonce, stored on 3 32-bit words. */
190  } nrf_qspi_encryption_t;
191  #endif
192  NRF_STATIC_INLINE void nrf_qspi_task_trigger(NRF_QSPI_Type * p_reg, nrf_qspi_task_t task);
193  NRF_STATIC_INLINE uint32_t nrf_qspi_task_address_get(NRF_QSPI_Type const * p_reg,
194                                                       nrf_qspi_task_t       task);
195  NRF_STATIC_INLINE void nrf_qspi_event_clear(NRF_QSPI_Type * p_reg, nrf_qspi_event_t event);
196  NRF_STATIC_INLINE bool nrf_qspi_event_check(NRF_QSPI_Type const * p_reg, nrf_qspi_event_t event);
197  NRF_STATIC_INLINE uint32_t nrf_qspi_event_address_get(NRF_QSPI_Type const * p_reg,
198                                                        nrf_qspi_event_t      event);
199  NRF_STATIC_INLINE void nrf_qspi_int_enable(NRF_QSPI_Type * p_reg, uint32_t mask);
200  NRF_STATIC_INLINE void nrf_qspi_int_disable(NRF_QSPI_Type * p_reg, uint32_t mask);
201  NRF_STATIC_INLINE uint32_t nrf_qspi_int_enable_check(NRF_QSPI_Type const * p_reg, uint32_t mask);
202  NRF_STATIC_INLINE void nrf_qspi_enable(NRF_QSPI_Type * p_reg);
203  NRF_STATIC_INLINE void nrf_qspi_disable(NRF_QSPI_Type * p_reg);
204  NRF_STATIC_INLINE void nrf_qspi_pins_set(NRF_QSPI_Type *         p_reg,
205                                           nrf_qspi_pins_t const * p_pins);
206  NRF_STATIC_INLINE void nrf_qspi_xip_offset_set(NRF_QSPI_Type * p_reg,
207                                                 uint32_t        xip_offset);
208  NRF_STATIC_INLINE void nrf_qspi_ifconfig0_set(NRF_QSPI_Type *              p_reg,
209                                                nrf_qspi_prot_conf_t const * p_config);
210  NRF_STATIC_INLINE void nrf_qspi_ifconfig1_set(NRF_QSPI_Type *             p_reg,
211                                                nrf_qspi_phy_conf_t const * p_config);
212  NRF_STATIC_INLINE void nrf_qspi_addrconfig_set(NRF_QSPI_Type *                    p_reg,
213                                                 nrf_qspi_addrconfig_conf_t const * p_config);
214  NRF_STATIC_INLINE void nrf_qspi_write_buffer_set(NRF_QSPI_Type * p_reg,
215                                                   void const *    p_buffer,
216                                                   uint32_t        length,
217                                                   uint32_t        dest_addr);
218  NRF_STATIC_INLINE void nrf_qspi_read_buffer_set(NRF_QSPI_Type * p_reg,
219                                                  void *          p_buffer,
220                                                  uint32_t        length,
221                                                  uint32_t        src_addr);
222  NRF_STATIC_INLINE void nrf_qspi_erase_ptr_set(NRF_QSPI_Type *      p_reg,
223                                                uint32_t             erase_addr,
224                                                nrf_qspi_erase_len_t len);
225  NRF_STATIC_INLINE uint32_t nrf_qspi_status_reg_get(NRF_QSPI_Type const * p_reg);
226  NRF_STATIC_INLINE uint8_t nrf_qspi_sreg_get(NRF_QSPI_Type const * p_reg);
227  NRF_STATIC_INLINE bool nrf_qspi_busy_check(NRF_QSPI_Type const * p_reg);
228  NRF_STATIC_INLINE void nrf_qspi_cinstrdata_set(NRF_QSPI_Type *       p_reg,
229                                                 nrf_qspi_cinstr_len_t length,
230                                                 void const *          p_tx_data);
231  NRF_STATIC_INLINE void nrf_qspi_cinstrdata_get(NRF_QSPI_Type const * p_reg,
232                                                 nrf_qspi_cinstr_len_t length,
233                                                 void *                p_rx_data);
234  NRF_STATIC_INLINE void nrf_qspi_cinstr_transfer_start(NRF_QSPI_Type *                p_reg,
235                                                        nrf_qspi_cinstr_conf_t const * p_config);
236  NRF_STATIC_INLINE void nrf_qspi_cinstr_long_transfer_start(NRF_QSPI_Type *                p_reg,
237                                                             nrf_qspi_cinstr_conf_t const * p_config);
238  NRF_STATIC_INLINE bool nrf_qspi_cinstr_long_transfer_is_ongoing(NRF_QSPI_Type const * p_reg);
239  NRF_STATIC_INLINE void nrf_qspi_cinstr_long_transfer_continue(NRF_QSPI_Type *       p_reg,
240                                                                nrf_qspi_cinstr_len_t length,
241                                                                bool                  finalize);
242  #if NRF_QSPI_HAS_XIPEN
243  NRF_STATIC_INLINE void nrf_qspi_xip_set(NRF_QSPI_Type * p_reg, bool enable);
244  #endif
245  #if NRF_QSPI_HAS_XIP_ENC
246  NRF_STATIC_INLINE void nrf_qspi_xip_encryption_configure(NRF_QSPI_Type *               p_reg,
247                                                           nrf_qspi_encryption_t const * p_cfg);
248  NRF_STATIC_INLINE void nrf_qspi_xip_encryption_set(NRF_QSPI_Type * p_reg, bool enable);
249  #endif
250  #if NRF_QSPI_HAS_DMA_ENC
251  NRF_STATIC_INLINE void nrf_qspi_dma_encryption_configure(NRF_QSPI_Type *               p_reg,
252                                                           nrf_qspi_encryption_t const * p_cfg);
253  NRF_STATIC_INLINE void nrf_qspi_dma_encryption_set(NRF_QSPI_Type * p_reg, bool enable);
254  #endif
255  #ifndef NRF_DECLARE_ONLY
256  NRF_STATIC_INLINE void nrf_qspi_task_trigger(NRF_QSPI_Type * p_reg, nrf_qspi_task_t task)
257  {
258      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
259  }
260  NRF_STATIC_INLINE uint32_t nrf_qspi_task_address_get(NRF_QSPI_Type const * p_reg,
261                                                       nrf_qspi_task_t       task)
262  {
263      return ((uint32_t)p_reg + (uint32_t)task);
264  }
265  NRF_STATIC_INLINE void nrf_qspi_event_clear(NRF_QSPI_Type * p_reg, nrf_qspi_event_t event)
266  {
267      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
268  }
269  NRF_STATIC_INLINE bool nrf_qspi_event_check(NRF_QSPI_Type const * p_reg, nrf_qspi_event_t event)
270  {
271      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
272  }
273  NRF_STATIC_INLINE uint32_t nrf_qspi_event_address_get(NRF_QSPI_Type const * p_reg,
274                                                        nrf_qspi_event_t      event)
275  {
276      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
277  }
278  NRF_STATIC_INLINE void nrf_qspi_int_enable(NRF_QSPI_Type * p_reg, uint32_t mask)
279  {
280      p_reg->INTENSET = mask;
281  }
282  NRF_STATIC_INLINE void nrf_qspi_int_disable(NRF_QSPI_Type * p_reg, uint32_t mask)
283  {
284      p_reg->INTENCLR = mask;
285  }
286  NRF_STATIC_INLINE uint32_t nrf_qspi_int_enable_check(NRF_QSPI_Type const * p_reg, uint32_t mask)
287  {
288      return p_reg->INTENSET & mask;
289  }
290  NRF_STATIC_INLINE void nrf_qspi_enable(NRF_QSPI_Type * p_reg)
291  {
292      p_reg->ENABLE = (QSPI_ENABLE_ENABLE_Enabled << QSPI_ENABLE_ENABLE_Pos);
293  }
294  NRF_STATIC_INLINE void nrf_qspi_disable(NRF_QSPI_Type * p_reg)
295  {
296      *(volatile uint32_t *)0x40029054ul = 1ul;
297      p_reg->ENABLE = (QSPI_ENABLE_ENABLE_Disabled << QSPI_ENABLE_ENABLE_Pos);
298  }
299  NRF_STATIC_INLINE void nrf_qspi_pins_set(NRF_QSPI_Type * p_reg, nrf_qspi_pins_t const * p_pins)
300  {
301      p_reg->PSEL.SCK = NRF_QSPI_PIN_VAL(p_pins->sck_pin);
302      p_reg->PSEL.CSN = NRF_QSPI_PIN_VAL(p_pins->csn_pin);
303      p_reg->PSEL.IO0 = NRF_QSPI_PIN_VAL(p_pins->io0_pin);
304      p_reg->PSEL.IO1 = NRF_QSPI_PIN_VAL(p_pins->io1_pin);
305      p_reg->PSEL.IO2 = NRF_QSPI_PIN_VAL(p_pins->io2_pin);
306      p_reg->PSEL.IO3 = NRF_QSPI_PIN_VAL(p_pins->io3_pin);
307  }
308  NRF_STATIC_INLINE void nrf_qspi_xip_offset_set(NRF_QSPI_Type * p_reg,
309                                                 uint32_t        xip_offset)
310  {
311      p_reg->XIPOFFSET = xip_offset;
312  }
313  NRF_STATIC_INLINE void nrf_qspi_ifconfig0_set(NRF_QSPI_Type *              p_reg,
314                                                nrf_qspi_prot_conf_t const * p_config)
315  {
316      uint32_t config = p_config->readoc;
317      config |= ((uint32_t)p_config->writeoc)    << QSPI_IFCONFIG0_WRITEOC_Pos;
318      config |= ((uint32_t)p_config->addrmode)   << QSPI_IFCONFIG0_ADDRMODE_Pos;
319      config |= (p_config->dpmconfig ? 1U : 0U ) << QSPI_IFCONFIG0_DPMENABLE_Pos;
320      p_reg->IFCONFIG0 = config;
321  }
322  NRF_STATIC_INLINE void nrf_qspi_ifconfig1_set(NRF_QSPI_Type *             p_reg,
323                                                nrf_qspi_phy_conf_t const * p_config)
324  {
325      uint32_t config = p_reg->IFCONFIG1 & 0x00FFFF00;
326      config |= p_config->sck_delay;
327      config |= (p_config->dpmen ? 1U : 0U)      << QSPI_IFCONFIG1_DPMEN_Pos;
328      config |= ((uint32_t)(p_config->spi_mode)) << QSPI_IFCONFIG1_SPIMODE_Pos;
329      config |= ((uint32_t)(p_config->sck_freq)) << QSPI_IFCONFIG1_SCKFREQ_Pos;
330      p_reg->IFCONFIG1 = config;
331  }
332  NRF_STATIC_INLINE void nrf_qspi_addrconfig_set(NRF_QSPI_Type *                    p_reg,
333                                                 nrf_qspi_addrconfig_conf_t const * p_config)
334  {
335      uint32_t config = p_config->opcode;
336      config |= ((uint32_t)p_config->byte0)   << QSPI_ADDRCONF_BYTE0_Pos;
337      config |= ((uint32_t)p_config->byte1)   << QSPI_ADDRCONF_BYTE1_Pos;
338      config |= ((uint32_t)(p_config->mode))  << QSPI_ADDRCONF_MODE_Pos;
339      config |= (p_config->wipwait ? 1U : 0U) << QSPI_ADDRCONF_WIPWAIT_Pos;
340      config |= (p_config->wren    ? 1U : 0U) << QSPI_ADDRCONF_WREN_Pos;
341      p_reg->ADDRCONF = config;
342  }
343  NRF_STATIC_INLINE void nrf_qspi_write_buffer_set(NRF_QSPI_Type * p_reg,
344                                                   void const    * p_buffer,
345                                                   uint32_t        length,
346                                                   uint32_t        dest_addr)
347  {
348      p_reg->WRITE.DST = dest_addr;
349      p_reg->WRITE.SRC = (uint32_t) p_buffer;
350      p_reg->WRITE.CNT = length;
351  }
352  NRF_STATIC_INLINE void nrf_qspi_read_buffer_set(NRF_QSPI_Type * p_reg,
353                                                  void          * p_buffer,
354                                                  uint32_t        length,
355                                                  uint32_t        src_addr)
356  {
357      p_reg->READ.SRC = src_addr;
358      p_reg->READ.DST = (uint32_t) p_buffer;
359      p_reg->READ.CNT = length;
360  }
361  NRF_STATIC_INLINE void nrf_qspi_erase_ptr_set(NRF_QSPI_Type *      p_reg,
362                                                uint32_t             erase_addr,
363                                                nrf_qspi_erase_len_t len)
364  {
365      p_reg->ERASE.PTR = erase_addr;
366      p_reg->ERASE.LEN = len;
367  }
368  NRF_STATIC_INLINE uint32_t nrf_qspi_status_reg_get(NRF_QSPI_Type const * p_reg)
369  {
370      return p_reg->STATUS;
371  }
372  NRF_STATIC_INLINE uint8_t nrf_qspi_sreg_get(NRF_QSPI_Type const * p_reg)
373  {
374      return (uint8_t)(p_reg->STATUS & QSPI_STATUS_SREG_Msk) >> QSPI_STATUS_SREG_Pos;
375  }
376  NRF_STATIC_INLINE bool nrf_qspi_busy_check(NRF_QSPI_Type const * p_reg)
377  {
378      return ((p_reg->STATUS & QSPI_STATUS_READY_Msk) >>
379              QSPI_STATUS_READY_Pos) == QSPI_STATUS_READY_BUSY;
380  }
381  NRF_STATIC_INLINE void nrf_qspi_cinstrdata_set(NRF_QSPI_Type *       p_reg,
382                                                 nrf_qspi_cinstr_len_t length,
383                                                 void const *          p_tx_data)
384  {
385      uint32_t reg = 0;
386      uint8_t const *p_tx_data_8 = (uint8_t const *) p_tx_data;
387      switch (length)
388      {
389          case NRF_QSPI_CINSTR_LEN_9B:
390              reg |= ((uint32_t)p_tx_data_8[7]) << QSPI_CINSTRDAT1_BYTE7_Pos;
391          case NRF_QSPI_CINSTR_LEN_8B:
392              reg |= ((uint32_t)p_tx_data_8[6]) << QSPI_CINSTRDAT1_BYTE6_Pos;
393          case NRF_QSPI_CINSTR_LEN_7B:
394              reg |= ((uint32_t)p_tx_data_8[5]) << QSPI_CINSTRDAT1_BYTE5_Pos;
395          case NRF_QSPI_CINSTR_LEN_6B:
396              reg |= ((uint32_t)p_tx_data_8[4]);
397              p_reg->CINSTRDAT1 = reg;
398              reg = 0;
399          case NRF_QSPI_CINSTR_LEN_5B:
400              reg |= ((uint32_t)p_tx_data_8[3]) << QSPI_CINSTRDAT0_BYTE3_Pos;
401          case NRF_QSPI_CINSTR_LEN_4B:
402              reg |= ((uint32_t)p_tx_data_8[2]) << QSPI_CINSTRDAT0_BYTE2_Pos;
403          case NRF_QSPI_CINSTR_LEN_3B:
404              reg |= ((uint32_t)p_tx_data_8[1]) << QSPI_CINSTRDAT0_BYTE1_Pos;
405          case NRF_QSPI_CINSTR_LEN_2B:
406              reg |= ((uint32_t)p_tx_data_8[0]);
407              p_reg->CINSTRDAT0 = reg;
408          case NRF_QSPI_CINSTR_LEN_1B:
409              break;
410          default:
411              break;
412      }
413  }
414  NRF_STATIC_INLINE void nrf_qspi_cinstrdata_get(NRF_QSPI_Type const * p_reg,
415                                                 nrf_qspi_cinstr_len_t length,
416                                                 void *                p_rx_data)
417  {
418      uint8_t *p_rx_data_8 = (uint8_t *) p_rx_data;
419      uint32_t reg1 = p_reg->CINSTRDAT1;
420      uint32_t reg0 = p_reg->CINSTRDAT0;
421      switch (length)
422      {
423          case NRF_QSPI_CINSTR_LEN_9B:
424              p_rx_data_8[7] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE7_Pos);
425          case NRF_QSPI_CINSTR_LEN_8B:
426              p_rx_data_8[6] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE6_Pos);
427          case NRF_QSPI_CINSTR_LEN_7B:
428              p_rx_data_8[5] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE5_Pos);
429          case NRF_QSPI_CINSTR_LEN_6B:
430              p_rx_data_8[4] = (uint8_t)(reg1);
431          case NRF_QSPI_CINSTR_LEN_5B:
432              p_rx_data_8[3] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE3_Pos);
433          case NRF_QSPI_CINSTR_LEN_4B:
434              p_rx_data_8[2] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE2_Pos);
435          case NRF_QSPI_CINSTR_LEN_3B:
436              p_rx_data_8[1] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE1_Pos);
437          case NRF_QSPI_CINSTR_LEN_2B:
438              p_rx_data_8[0] = (uint8_t)(reg0);
439          case NRF_QSPI_CINSTR_LEN_1B:
440              break;
441          default:
442              break;
443      }
444  }
445  NRF_STATIC_INLINE void nrf_qspi_cinstr_transfer_start(NRF_QSPI_Type *                p_reg,
446                                                        nrf_qspi_cinstr_conf_t const * p_config)
447  {
448      p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
449                           ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
450                           ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
451                           ((uint32_t)p_config->io3_level << QSPI_CINSTRCONF_LIO3_Pos) |
452                           ((uint32_t)p_config->wipwait   << QSPI_CINSTRCONF_WIPWAIT_Pos) |
453                           ((uint32_t)p_config->wren      << QSPI_CINSTRCONF_WREN_Pos));
454  }
455  NRF_STATIC_INLINE void nrf_qspi_cinstr_long_transfer_start(NRF_QSPI_Type *                p_reg,
456                                                             nrf_qspi_cinstr_conf_t const * p_config)
457  {
458      p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
459                           ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
460                           ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
461                           ((uint32_t)p_config->io3_level << QSPI_CINSTRCONF_LIO3_Pos) |
462                           ((uint32_t)p_config->wipwait   << QSPI_CINSTRCONF_WIPWAIT_Pos) |
463                           ((uint32_t)p_config->wren      << QSPI_CINSTRCONF_WREN_Pos) |
464                           (QSPI_CINSTRCONF_LFEN_Msk));
465  }
466  NRF_STATIC_INLINE bool nrf_qspi_cinstr_long_transfer_is_ongoing(NRF_QSPI_Type const * p_reg)
467  {
468      return (bool)((p_reg->CINSTRCONF & (QSPI_CINSTRCONF_LFEN_Msk | QSPI_CINSTRCONF_LFSTOP_Msk))
469                     == QSPI_CINSTRCONF_LFEN_Msk);
470  }
471  NRF_STATIC_INLINE void nrf_qspi_cinstr_long_transfer_continue(NRF_QSPI_Type *       p_reg,
472                                                                nrf_qspi_cinstr_len_t length,
473                                                                bool                  finalize)
474  {
475      uint32_t mask = (((uint32_t)length << QSPI_CINSTRCONF_LENGTH_Pos) | (QSPI_CINSTRCONF_LFEN_Msk));
476      mask |= (finalize ? QSPI_CINSTRCONF_LFSTOP_Msk : 0);
477      p_reg->CINSTRCONF = mask;
478  }
479  #if NRF_QSPI_HAS_XIPEN
480  NRF_STATIC_INLINE void nrf_qspi_xip_set(NRF_QSPI_Type * p_reg, bool enable)
481  {
482      p_reg->XIPEN = (enable ? QSPI_XIPEN_XIPEN_Enable << QSPI_XIPEN_XIPEN_Pos
483                             : QSPI_XIPEN_XIPEN_Disable << QSPI_XIPEN_XIPEN_Pos);
484  }
485  #endif
486  #if NRF_QSPI_HAS_XIP_ENC
487  NRF_STATIC_INLINE void nrf_qspi_xip_encryption_configure(NRF_QSPI_Type *               p_reg,
488                                                           nrf_qspi_encryption_t const * p_cfg)
489  {
490      p_reg->XIP_ENC.KEY0 = p_cfg->key[0];
491      p_reg->XIP_ENC.KEY1 = p_cfg->key[1];
492      p_reg->XIP_ENC.KEY2 = p_cfg->key[2];
493      p_reg->XIP_ENC.KEY3 = p_cfg->key[3];
494      p_reg->XIP_ENC.NONCE0 = p_cfg->nonce[0];
495      p_reg->XIP_ENC.NONCE1 = p_cfg->nonce[1];
496      p_reg->XIP_ENC.NONCE2 = p_cfg->nonce[2];
497  }
498  NRF_STATIC_INLINE void nrf_qspi_xip_encryption_set(NRF_QSPI_Type * p_reg, bool enable)
499  {
500      p_reg->XIP_ENC.ENABLE =
501          (enable ? QSPI_XIP_ENC_ENABLE_ENABLE_Enabled << QSPI_XIP_ENC_ENABLE_ENABLE_Pos
502                  : QSPI_XIP_ENC_ENABLE_ENABLE_Disabled << QSPI_XIP_ENC_ENABLE_ENABLE_Pos);
503  }
504  #endif
505  #if NRF_QSPI_HAS_DMA_ENC
506  NRF_STATIC_INLINE void nrf_qspi_dma_encryption_configure(NRF_QSPI_Type *               p_reg,
507                                                           nrf_qspi_encryption_t const * p_cfg)
508  {
509      p_reg->DMA_ENC.KEY0 = p_cfg->key[0];
510      p_reg->DMA_ENC.KEY1 = p_cfg->key[1];
511      p_reg->DMA_ENC.KEY2 = p_cfg->key[2];
512      p_reg->DMA_ENC.KEY3 = p_cfg->key[3];
513      p_reg->DMA_ENC.NONCE0 = p_cfg->nonce[0];
<span onclick='openModal()' class='match'>514      p_reg->DMA_ENC.NONCE1 = p_cfg->nonce[1];
515      p_reg->DMA_ENC.NONCE2 = p_cfg->nonce[2];
516  }
</span>517  NRF_STATIC_INLINE void nrf_qspi_dma_encryption_set(NRF_QSPI_Type * p_reg, bool enable)
518  {
519      p_reg->DMA_ENC.ENABLE =
520          (enable ? QSPI_DMA_ENC_ENABLE_ENABLE_Enabled << QSPI_DMA_ENC_ENABLE_ENABLE_Pos
521                  : QSPI_DMA_ENC_ENABLE_ENABLE_Disabled << QSPI_DMA_ENC_ENABLE_ENABLE_Pos);
522  }
523  #endif
524  #endif 
525  #ifdef __cplusplus
526  }
527  #endif
528  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_qspi.h</h3>
            <pre><code>1  #ifndef NRF_QSPI_H__
2  #define NRF_QSPI_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  #if defined(QSPI_XIPEN_XIPEN_Msk) || defined(__NRFX_DOXYGEN__)
8  #define NRF_QSPI_HAS_XIPEN 1
9  #else
10  #define NRF_QSPI_HAS_XIPEN 0
11  #endif
12  #if defined(QSPI_XIP_ENC_ENABLE_ENABLE_Msk) || defined(__NRFX_DOXYGEN__)
13  #define NRF_QSPI_HAS_XIP_ENC 1
14  #else
15  #define NRF_QSPI_HAS_XIP_ENC 0
16  #endif
17  #if defined(QSPI_DMA_ENC_ENABLE_ENABLE_Msk) || defined(__NRFX_DOXYGEN__)
18  #define NRF_QSPI_HAS_DMA_ENC 1
19  #else
20  #define NRF_QSPI_HAS_DMA_ENC 0
21  #endif
22  #if defined(NRF53_SERIES) || defined(__NRFX_DOXYGEN__)
23  #define NRF_QSPI_BASE_CLOCK_FREQ 96000000uL
24  #else
25  #define NRF_QSPI_BASE_CLOCK_FREQ 32000000uL
26  #endif
27  #define NRF_QSPI_PIN_NOT_CONNECTED 0xFF
28  #define NRF_QSPI_PIN_VAL(pin) (pin) == NRF_QSPI_PIN_NOT_CONNECTED ? 0xFFFFFFFF : (pin)
29  typedef enum
30  {
31      NRF_QSPI_TASK_ACTIVATE   = offsetof(NRF_QSPI_Type, TASKS_ACTIVATE),   &bsol;**< Activate the QSPI interface. */
32      NRF_QSPI_TASK_READSTART  = offsetof(NRF_QSPI_Type, TASKS_READSTART),  &bsol;**< Start transfer from external flash memory to internal RAM. */
33      NRF_QSPI_TASK_WRITESTART = offsetof(NRF_QSPI_Type, TASKS_WRITESTART), &bsol;**< Start transfer from internal RAM to external flash memory. */
34      NRF_QSPI_TASK_ERASESTART = offsetof(NRF_QSPI_Type, TASKS_ERASESTART), &bsol;**< Start external flash memory erase operation. */
35      NRF_QSPI_TASK_DEACTIVATE = offsetof(NRF_QSPI_Type, TASKS_DEACTIVATE), &bsol;**< Deactivate the QSPI interface. */
36  } nrf_qspi_task_t;
37  typedef enum
38  {
39      NRF_QSPI_EVENT_READY = offsetof(NRF_QSPI_Type, EVENTS_READY) &bsol;**< QSPI peripheral is ready after it executes any task. */
40  } nrf_qspi_event_t;
41  typedef enum
42  {
43      NRF_QSPI_INT_READY_MASK = QSPI_INTENSET_READY_Msk &bsol;**< Interrupt on READY event. */
44  } nrf_qspi_int_mask_t;
45  typedef enum
46  {
47      NRF_QSPI_FREQ_DIV1,  &bsol;**< Divide by 1. */
48      NRF_QSPI_FREQ_DIV2,  &bsol;**< Divide by 2. */
49      NRF_QSPI_FREQ_DIV3,  &bsol;**< Divide by 3. */
50      NRF_QSPI_FREQ_DIV4,  &bsol;**< Divide by 4. */
51      NRF_QSPI_FREQ_DIV5,  &bsol;**< Divide by 5. */
52      NRF_QSPI_FREQ_DIV6,  &bsol;**< Divide by 6. */
53      NRF_QSPI_FREQ_DIV7,  &bsol;**< Divide by 7. */
54      NRF_QSPI_FREQ_DIV8,  &bsol;**< Divide by 8. */
55      NRF_QSPI_FREQ_DIV9,  &bsol;**< Divide by 9. */
56      NRF_QSPI_FREQ_DIV10, &bsol;**< Divide by 10. */
57      NRF_QSPI_FREQ_DIV11, &bsol;**< Divide by 11. */
58      NRF_QSPI_FREQ_DIV12, &bsol;**< Divide by 12. */
59      NRF_QSPI_FREQ_DIV13, &bsol;**< Divide by 13. */
60      NRF_QSPI_FREQ_DIV14, &bsol;**< Divide by 14. */
61      NRF_QSPI_FREQ_DIV15, &bsol;**< Divide by 15. */
62      NRF_QSPI_FREQ_DIV16, &bsol;**< Divide by 16. */
63  } nrf_qspi_frequency_t;
64  #if defined(NRF52_SERIES)
65  #define NRF_QSPI_FREQ_32MDIV1  NRF_QSPI_FREQ_DIV1
66  #define NRF_QSPI_FREQ_32MDIV2  NRF_QSPI_FREQ_DIV2
67  #define NRF_QSPI_FREQ_32MDIV3  NRF_QSPI_FREQ_DIV3
68  #define NRF_QSPI_FREQ_32MDIV4  NRF_QSPI_FREQ_DIV4
69  #define NRF_QSPI_FREQ_32MDIV5  NRF_QSPI_FREQ_DIV5
70  #define NRF_QSPI_FREQ_32MDIV6  NRF_QSPI_FREQ_DIV6
71  #define NRF_QSPI_FREQ_32MDIV7  NRF_QSPI_FREQ_DIV7
72  #define NRF_QSPI_FREQ_32MDIV8  NRF_QSPI_FREQ_DIV8
73  #define NRF_QSPI_FREQ_32MDIV9  NRF_QSPI_FREQ_DIV9
74  #define NRF_QSPI_FREQ_32MDIV10 NRF_QSPI_FREQ_DIV10
75  #define NRF_QSPI_FREQ_32MDIV11 NRF_QSPI_FREQ_DIV11
76  #define NRF_QSPI_FREQ_32MDIV12 NRF_QSPI_FREQ_DIV12
77  #define NRF_QSPI_FREQ_32MDIV13 NRF_QSPI_FREQ_DIV13
78  #define NRF_QSPI_FREQ_32MDIV14 NRF_QSPI_FREQ_DIV14
79  #define NRF_QSPI_FREQ_32MDIV15 NRF_QSPI_FREQ_DIV15
80  #define NRF_QSPI_FREQ_32MDIV16 NRF_QSPI_FREQ_DIV16
81  #endif
82  typedef enum
83  {
84      NRF_QSPI_READOC_FASTREAD = QSPI_IFCONFIG0_READOC_FASTREAD, &bsol;**< Single data line SPI. FAST_READ (opcode 0x0B). */
85      NRF_QSPI_READOC_READ2O   = QSPI_IFCONFIG0_READOC_READ2O,   &bsol;**< Dual data line SPI. READ2O (opcode 0x3B). */
86      NRF_QSPI_READOC_READ2IO  = QSPI_IFCONFIG0_READOC_READ2IO,  &bsol;**< Dual data line SPI. READ2IO (opcode 0xBB). */
87      NRF_QSPI_READOC_READ4O   = QSPI_IFCONFIG0_READOC_READ4O,   &bsol;**< Quad data line SPI. READ4O (opcode 0x6B). */
88      NRF_QSPI_READOC_READ4IO  = QSPI_IFCONFIG0_READOC_READ4IO   &bsol;**< Quad data line SPI. READ4IO (opcode 0xEB). */
89  } nrf_qspi_readoc_t;
90  typedef enum
91  {
92      NRF_QSPI_WRITEOC_PP    = QSPI_IFCONFIG0_WRITEOC_PP,    &bsol;**< Single data line SPI. PP (opcode 0x02). */
93      NRF_QSPI_WRITEOC_PP2O  = QSPI_IFCONFIG0_WRITEOC_PP2O,  &bsol;**< Dual data line SPI. PP2O (opcode 0xA2). */
94      NRF_QSPI_WRITEOC_PP4O  = QSPI_IFCONFIG0_WRITEOC_PP4O,  &bsol;**< Quad data line SPI. PP4O (opcode 0x32). */
95      NRF_QSPI_WRITEOC_PP4IO = QSPI_IFCONFIG0_WRITEOC_PP4IO, &bsol;**< Quad data line SPI. READ4O (opcode 0x38). */
96  } nrf_qspi_writeoc_t;
97  typedef enum
98  {
99      NRF_QSPI_ADDRMODE_24BIT = QSPI_IFCONFIG0_ADDRMODE_24BIT, &bsol;**< 24-bit addressing. */
100      NRF_QSPI_ADDRMODE_32BIT = QSPI_IFCONFIG0_ADDRMODE_32BIT  &bsol;**< 32-bit addressing. */
101  } nrf_qspi_addrmode_t;
102  typedef enum
103  {
104      NRF_QSPI_MODE_0 = QSPI_IFCONFIG1_SPIMODE_MODE0, &bsol;**< Mode 0 (CPOL=0, CPHA=0). */
105      NRF_QSPI_MODE_1 = QSPI_IFCONFIG1_SPIMODE_MODE3  &bsol;**< Mode 1 (CPOL=1, CPHA=1). */
106  } nrf_qspi_spi_mode_t;
107  typedef enum
108  {
109      NRF_QSPI_ADDRCONF_MODE_NOINSTR = QSPI_ADDRCONF_MODE_NoInstr, &bsol;**< Do not send any instruction. */
110      NRF_QSPI_ADDRCONF_MODE_OPCODE  = QSPI_ADDRCONF_MODE_Opcode,  &bsol;**< Send opcode. */
111      NRF_QSPI_ADDRCONF_MODE_OPBYTE0 = QSPI_ADDRCONF_MODE_OpByte0, &bsol;**< Send opcode, byte0. */
112      NRF_QSPI_ADDRCONF_MODE_ALL     = QSPI_ADDRCONF_MODE_All      &bsol;**< Send opcode, byte0, byte1. */
113  } nrf_qspi_addrconfig_mode_t;
114  typedef enum
115  {
116      NRF_QSPI_ERASE_LEN_4KB  = QSPI_ERASE_LEN_LEN_4KB,  &bsol;**< Erase 4 kB block (flash command 0x20). */
117      NRF_QSPI_ERASE_LEN_64KB = QSPI_ERASE_LEN_LEN_64KB, &bsol;**< Erase 64 kB block (flash command 0xD8). */
118      NRF_QSPI_ERASE_LEN_ALL  = QSPI_ERASE_LEN_LEN_All   &bsol;**< Erase all (flash command 0xC7). */
119  } nrf_qspi_erase_len_t;
120  typedef enum
121  {
122      NRF_QSPI_CINSTR_LEN_1B = QSPI_CINSTRCONF_LENGTH_1B, &bsol;**< Send opcode only. */
123      NRF_QSPI_CINSTR_LEN_2B = QSPI_CINSTRCONF_LENGTH_2B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0. */
124      NRF_QSPI_CINSTR_LEN_3B = QSPI_CINSTRCONF_LENGTH_3B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT0.BYTE1. */
125      NRF_QSPI_CINSTR_LEN_4B = QSPI_CINSTRCONF_LENGTH_4B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT0.BYTE2. */
126      NRF_QSPI_CINSTR_LEN_5B = QSPI_CINSTRCONF_LENGTH_5B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT0.BYTE3. */
127      NRF_QSPI_CINSTR_LEN_6B = QSPI_CINSTRCONF_LENGTH_6B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT1.BYTE4. */
128      NRF_QSPI_CINSTR_LEN_7B = QSPI_CINSTRCONF_LENGTH_7B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT1.BYTE5. */
129      NRF_QSPI_CINSTR_LEN_8B = QSPI_CINSTRCONF_LENGTH_8B, &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT1.BYTE6. */
130      NRF_QSPI_CINSTR_LEN_9B = QSPI_CINSTRCONF_LENGTH_9B  &bsol;**< Send opcode, CINSTRDAT0.BYTE0 -> CINSTRDAT1.BYTE7. */
131  } nrf_qspi_cinstr_len_t;
132  typedef struct
133  {
134      uint8_t sck_pin; &bsol;**< SCK pin number. */
135      uint8_t csn_pin; &bsol;**< Chip select pin number. */
136      uint8_t io0_pin; &bsol;**< IO0/MOSI pin number. */
137      uint8_t io1_pin; &bsol;**< IO1/MISO pin number. */
138      uint8_t io2_pin; &bsol;**< IO2 pin number (optional).
139                        *   Set to @ref NRF_QSPI_PIN_NOT_CONNECTED if this signal is not needed.
140                        */
141      uint8_t io3_pin; &bsol;**< IO3 pin number (optional).
142                        *   Set to @ref NRF_QSPI_PIN_NOT_CONNECTED if this signal is not needed.
143                        */
144  } nrf_qspi_pins_t;
145  typedef struct
146  {
147      uint8_t               opcode;    &bsol;**< Opcode used in custom instruction transmission. */
148      nrf_qspi_cinstr_len_t length;    &bsol;**< Length of the custom instruction data. */
149      bool                  io2_level; &bsol;**< I/O line level during transmission. */
150      bool                  io3_level; &bsol;**< I/O line level during transmission. */
151      bool                  wipwait;   &bsol;**< Wait if a Wait in Progress bit is set in the memory status byte. */
152      bool                  wren;      &bsol;**< Send write enable before instruction. */
153  } nrf_qspi_cinstr_conf_t;
154  typedef struct
155  {
156      uint8_t                    opcode;  &bsol;**< Opcode used to enter the proper addressing mode. */
157      uint8_t                    byte0;   &bsol;**< Byte following the opcode. */
158      uint8_t                    byte1;   &bsol;**< Byte following byte0. */
159      nrf_qspi_addrconfig_mode_t mode;    &bsol;**< Extended addresing mode. */
160      bool                       wipwait; &bsol;**< Enable or disable waiting for complete operation execution. */
161      bool                       wren;    &bsol;**< Send write enable before instruction. */
162  } nrf_qspi_addrconfig_conf_t;
163  typedef struct
164  {
165      nrf_qspi_readoc_t   readoc;    &bsol;**< Read operation code. */
166      nrf_qspi_writeoc_t  writeoc;   &bsol;**< Write operation code. */
167      nrf_qspi_addrmode_t addrmode;  &bsol;**< Addresing mode (24-bit or 32-bit). */
168      bool                dpmconfig; &bsol;**< Enable the Deep Power-down Mode (DPM) feature. */
169  } nrf_qspi_prot_conf_t;
170  typedef struct
171  {
172      uint8_t              sck_delay; &bsol;**< tSHSL, tWHSL, and tSHWL in number of 16 MHz periods (62.5ns). */
173      bool                 dpmen;     &bsol;**< Enable the DPM feature. */
174      nrf_qspi_spi_mode_t  spi_mode;  &bsol;**< SPI phase and polarization. */
175      nrf_qspi_frequency_t sck_freq;  &bsol;**< SCK frequency given as QSPI base clock frequency divider.
176                                       *   To calculate @p sck_freq value corresponding to chosen frequency,
177                                       *   use the following equation:
178                                       *
179                                       *   sck_freq = (NRF_QSPI_BASE_CLOCK_FREQ / frequency) - 1
180                                       *
181                                       *   @note Achievable frequencies are determined by available
182                                       *         divider values and QSPI base clock frequency.
183                                       */
184  } nrf_qspi_phy_conf_t;
185  #if NRF_QSPI_HAS_XIP_ENC || NRF_QSPI_HAS_DMA_ENC
186  typedef struct
187  {
188      uint32_t key[4];   &bsol;**< AES 128-bit key, stored on 4 32-bit words. */
189      uint32_t nonce[3]; &bsol;**< AES 96-bit nonce, stored on 3 32-bit words. */
190  } nrf_qspi_encryption_t;
191  #endif
192  NRF_STATIC_INLINE void nrf_qspi_task_trigger(NRF_QSPI_Type * p_reg, nrf_qspi_task_t task);
193  NRF_STATIC_INLINE uint32_t nrf_qspi_task_address_get(NRF_QSPI_Type const * p_reg,
194                                                       nrf_qspi_task_t       task);
195  NRF_STATIC_INLINE void nrf_qspi_event_clear(NRF_QSPI_Type * p_reg, nrf_qspi_event_t event);
196  NRF_STATIC_INLINE bool nrf_qspi_event_check(NRF_QSPI_Type const * p_reg, nrf_qspi_event_t event);
197  NRF_STATIC_INLINE uint32_t nrf_qspi_event_address_get(NRF_QSPI_Type const * p_reg,
198                                                        nrf_qspi_event_t      event);
199  NRF_STATIC_INLINE void nrf_qspi_int_enable(NRF_QSPI_Type * p_reg, uint32_t mask);
200  NRF_STATIC_INLINE void nrf_qspi_int_disable(NRF_QSPI_Type * p_reg, uint32_t mask);
201  NRF_STATIC_INLINE uint32_t nrf_qspi_int_enable_check(NRF_QSPI_Type const * p_reg, uint32_t mask);
202  NRF_STATIC_INLINE void nrf_qspi_enable(NRF_QSPI_Type * p_reg);
203  NRF_STATIC_INLINE void nrf_qspi_disable(NRF_QSPI_Type * p_reg);
204  NRF_STATIC_INLINE void nrf_qspi_pins_set(NRF_QSPI_Type *         p_reg,
205                                           nrf_qspi_pins_t const * p_pins);
206  NRF_STATIC_INLINE void nrf_qspi_xip_offset_set(NRF_QSPI_Type * p_reg,
207                                                 uint32_t        xip_offset);
208  NRF_STATIC_INLINE void nrf_qspi_ifconfig0_set(NRF_QSPI_Type *              p_reg,
209                                                nrf_qspi_prot_conf_t const * p_config);
210  NRF_STATIC_INLINE void nrf_qspi_ifconfig1_set(NRF_QSPI_Type *             p_reg,
211                                                nrf_qspi_phy_conf_t const * p_config);
212  NRF_STATIC_INLINE void nrf_qspi_addrconfig_set(NRF_QSPI_Type *                    p_reg,
213                                                 nrf_qspi_addrconfig_conf_t const * p_config);
214  NRF_STATIC_INLINE void nrf_qspi_write_buffer_set(NRF_QSPI_Type * p_reg,
215                                                   void const *    p_buffer,
216                                                   uint32_t        length,
217                                                   uint32_t        dest_addr);
218  NRF_STATIC_INLINE void nrf_qspi_read_buffer_set(NRF_QSPI_Type * p_reg,
219                                                  void *          p_buffer,
220                                                  uint32_t        length,
221                                                  uint32_t        src_addr);
222  NRF_STATIC_INLINE void nrf_qspi_erase_ptr_set(NRF_QSPI_Type *      p_reg,
223                                                uint32_t             erase_addr,
224                                                nrf_qspi_erase_len_t len);
225  NRF_STATIC_INLINE uint32_t nrf_qspi_status_reg_get(NRF_QSPI_Type const * p_reg);
226  NRF_STATIC_INLINE uint8_t nrf_qspi_sreg_get(NRF_QSPI_Type const * p_reg);
227  NRF_STATIC_INLINE bool nrf_qspi_busy_check(NRF_QSPI_Type const * p_reg);
228  NRF_STATIC_INLINE void nrf_qspi_cinstrdata_set(NRF_QSPI_Type *       p_reg,
229                                                 nrf_qspi_cinstr_len_t length,
230                                                 void const *          p_tx_data);
231  NRF_STATIC_INLINE void nrf_qspi_cinstrdata_get(NRF_QSPI_Type const * p_reg,
232                                                 nrf_qspi_cinstr_len_t length,
233                                                 void *                p_rx_data);
234  NRF_STATIC_INLINE void nrf_qspi_cinstr_transfer_start(NRF_QSPI_Type *                p_reg,
235                                                        nrf_qspi_cinstr_conf_t const * p_config);
236  NRF_STATIC_INLINE void nrf_qspi_cinstr_long_transfer_start(NRF_QSPI_Type *                p_reg,
237                                                             nrf_qspi_cinstr_conf_t const * p_config);
238  NRF_STATIC_INLINE bool nrf_qspi_cinstr_long_transfer_is_ongoing(NRF_QSPI_Type const * p_reg);
239  NRF_STATIC_INLINE void nrf_qspi_cinstr_long_transfer_continue(NRF_QSPI_Type *       p_reg,
240                                                                nrf_qspi_cinstr_len_t length,
241                                                                bool                  finalize);
242  #if NRF_QSPI_HAS_XIPEN
243  NRF_STATIC_INLINE void nrf_qspi_xip_set(NRF_QSPI_Type * p_reg, bool enable);
244  #endif
245  #if NRF_QSPI_HAS_XIP_ENC
246  NRF_STATIC_INLINE void nrf_qspi_xip_encryption_configure(NRF_QSPI_Type *               p_reg,
247                                                           nrf_qspi_encryption_t const * p_cfg);
248  NRF_STATIC_INLINE void nrf_qspi_xip_encryption_set(NRF_QSPI_Type * p_reg, bool enable);
249  #endif
250  #if NRF_QSPI_HAS_DMA_ENC
251  NRF_STATIC_INLINE void nrf_qspi_dma_encryption_configure(NRF_QSPI_Type *               p_reg,
252                                                           nrf_qspi_encryption_t const * p_cfg);
253  NRF_STATIC_INLINE void nrf_qspi_dma_encryption_set(NRF_QSPI_Type * p_reg, bool enable);
254  #endif
255  #ifndef NRF_DECLARE_ONLY
256  NRF_STATIC_INLINE void nrf_qspi_task_trigger(NRF_QSPI_Type * p_reg, nrf_qspi_task_t task)
257  {
258      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
259  }
260  NRF_STATIC_INLINE uint32_t nrf_qspi_task_address_get(NRF_QSPI_Type const * p_reg,
261                                                       nrf_qspi_task_t       task)
262  {
263      return ((uint32_t)p_reg + (uint32_t)task);
264  }
265  NRF_STATIC_INLINE void nrf_qspi_event_clear(NRF_QSPI_Type * p_reg, nrf_qspi_event_t event)
266  {
267      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
268  }
269  NRF_STATIC_INLINE bool nrf_qspi_event_check(NRF_QSPI_Type const * p_reg, nrf_qspi_event_t event)
270  {
271      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
272  }
273  NRF_STATIC_INLINE uint32_t nrf_qspi_event_address_get(NRF_QSPI_Type const * p_reg,
274                                                        nrf_qspi_event_t      event)
275  {
276      return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
277  }
278  NRF_STATIC_INLINE void nrf_qspi_int_enable(NRF_QSPI_Type * p_reg, uint32_t mask)
279  {
280      p_reg->INTENSET = mask;
281  }
282  NRF_STATIC_INLINE void nrf_qspi_int_disable(NRF_QSPI_Type * p_reg, uint32_t mask)
283  {
284      p_reg->INTENCLR = mask;
285  }
286  NRF_STATIC_INLINE uint32_t nrf_qspi_int_enable_check(NRF_QSPI_Type const * p_reg, uint32_t mask)
287  {
288      return p_reg->INTENSET & mask;
289  }
290  NRF_STATIC_INLINE void nrf_qspi_enable(NRF_QSPI_Type * p_reg)
291  {
292      p_reg->ENABLE = (QSPI_ENABLE_ENABLE_Enabled << QSPI_ENABLE_ENABLE_Pos);
293  }
294  NRF_STATIC_INLINE void nrf_qspi_disable(NRF_QSPI_Type * p_reg)
295  {
296      *(volatile uint32_t *)0x40029054ul = 1ul;
297      p_reg->ENABLE = (QSPI_ENABLE_ENABLE_Disabled << QSPI_ENABLE_ENABLE_Pos);
298  }
299  NRF_STATIC_INLINE void nrf_qspi_pins_set(NRF_QSPI_Type * p_reg, nrf_qspi_pins_t const * p_pins)
300  {
301      p_reg->PSEL.SCK = NRF_QSPI_PIN_VAL(p_pins->sck_pin);
302      p_reg->PSEL.CSN = NRF_QSPI_PIN_VAL(p_pins->csn_pin);
303      p_reg->PSEL.IO0 = NRF_QSPI_PIN_VAL(p_pins->io0_pin);
304      p_reg->PSEL.IO1 = NRF_QSPI_PIN_VAL(p_pins->io1_pin);
305      p_reg->PSEL.IO2 = NRF_QSPI_PIN_VAL(p_pins->io2_pin);
306      p_reg->PSEL.IO3 = NRF_QSPI_PIN_VAL(p_pins->io3_pin);
307  }
308  NRF_STATIC_INLINE void nrf_qspi_xip_offset_set(NRF_QSPI_Type * p_reg,
309                                                 uint32_t        xip_offset)
310  {
311      p_reg->XIPOFFSET = xip_offset;
312  }
313  NRF_STATIC_INLINE void nrf_qspi_ifconfig0_set(NRF_QSPI_Type *              p_reg,
314                                                nrf_qspi_prot_conf_t const * p_config)
315  {
316      uint32_t config = p_config->readoc;
317      config |= ((uint32_t)p_config->writeoc)    << QSPI_IFCONFIG0_WRITEOC_Pos;
318      config |= ((uint32_t)p_config->addrmode)   << QSPI_IFCONFIG0_ADDRMODE_Pos;
319      config |= (p_config->dpmconfig ? 1U : 0U ) << QSPI_IFCONFIG0_DPMENABLE_Pos;
320      p_reg->IFCONFIG0 = config;
321  }
322  NRF_STATIC_INLINE void nrf_qspi_ifconfig1_set(NRF_QSPI_Type *             p_reg,
323                                                nrf_qspi_phy_conf_t const * p_config)
324  {
325      uint32_t config = p_reg->IFCONFIG1 & 0x00FFFF00;
326      config |= p_config->sck_delay;
327      config |= (p_config->dpmen ? 1U : 0U)      << QSPI_IFCONFIG1_DPMEN_Pos;
328      config |= ((uint32_t)(p_config->spi_mode)) << QSPI_IFCONFIG1_SPIMODE_Pos;
329      config |= ((uint32_t)(p_config->sck_freq)) << QSPI_IFCONFIG1_SCKFREQ_Pos;
330      p_reg->IFCONFIG1 = config;
331  }
332  NRF_STATIC_INLINE void nrf_qspi_addrconfig_set(NRF_QSPI_Type *                    p_reg,
333                                                 nrf_qspi_addrconfig_conf_t const * p_config)
334  {
335      uint32_t config = p_config->opcode;
336      config |= ((uint32_t)p_config->byte0)   << QSPI_ADDRCONF_BYTE0_Pos;
337      config |= ((uint32_t)p_config->byte1)   << QSPI_ADDRCONF_BYTE1_Pos;
338      config |= ((uint32_t)(p_config->mode))  << QSPI_ADDRCONF_MODE_Pos;
339      config |= (p_config->wipwait ? 1U : 0U) << QSPI_ADDRCONF_WIPWAIT_Pos;
340      config |= (p_config->wren    ? 1U : 0U) << QSPI_ADDRCONF_WREN_Pos;
341      p_reg->ADDRCONF = config;
342  }
343  NRF_STATIC_INLINE void nrf_qspi_write_buffer_set(NRF_QSPI_Type * p_reg,
344                                                   void const    * p_buffer,
345                                                   uint32_t        length,
346                                                   uint32_t        dest_addr)
347  {
348      p_reg->WRITE.DST = dest_addr;
349      p_reg->WRITE.SRC = (uint32_t) p_buffer;
350      p_reg->WRITE.CNT = length;
351  }
352  NRF_STATIC_INLINE void nrf_qspi_read_buffer_set(NRF_QSPI_Type * p_reg,
353                                                  void          * p_buffer,
354                                                  uint32_t        length,
355                                                  uint32_t        src_addr)
356  {
357      p_reg->READ.SRC = src_addr;
358      p_reg->READ.DST = (uint32_t) p_buffer;
359      p_reg->READ.CNT = length;
360  }
361  NRF_STATIC_INLINE void nrf_qspi_erase_ptr_set(NRF_QSPI_Type *      p_reg,
362                                                uint32_t             erase_addr,
363                                                nrf_qspi_erase_len_t len)
364  {
365      p_reg->ERASE.PTR = erase_addr;
366      p_reg->ERASE.LEN = len;
367  }
368  NRF_STATIC_INLINE uint32_t nrf_qspi_status_reg_get(NRF_QSPI_Type const * p_reg)
369  {
370      return p_reg->STATUS;
371  }
372  NRF_STATIC_INLINE uint8_t nrf_qspi_sreg_get(NRF_QSPI_Type const * p_reg)
373  {
374      return (uint8_t)(p_reg->STATUS & QSPI_STATUS_SREG_Msk) >> QSPI_STATUS_SREG_Pos;
375  }
376  NRF_STATIC_INLINE bool nrf_qspi_busy_check(NRF_QSPI_Type const * p_reg)
377  {
378      return ((p_reg->STATUS & QSPI_STATUS_READY_Msk) >>
379              QSPI_STATUS_READY_Pos) == QSPI_STATUS_READY_BUSY;
380  }
381  NRF_STATIC_INLINE void nrf_qspi_cinstrdata_set(NRF_QSPI_Type *       p_reg,
382                                                 nrf_qspi_cinstr_len_t length,
383                                                 void const *          p_tx_data)
384  {
385      uint32_t reg = 0;
386      uint8_t const *p_tx_data_8 = (uint8_t const *) p_tx_data;
387      switch (length)
388      {
389          case NRF_QSPI_CINSTR_LEN_9B:
390              reg |= ((uint32_t)p_tx_data_8[7]) << QSPI_CINSTRDAT1_BYTE7_Pos;
391          case NRF_QSPI_CINSTR_LEN_8B:
392              reg |= ((uint32_t)p_tx_data_8[6]) << QSPI_CINSTRDAT1_BYTE6_Pos;
393          case NRF_QSPI_CINSTR_LEN_7B:
394              reg |= ((uint32_t)p_tx_data_8[5]) << QSPI_CINSTRDAT1_BYTE5_Pos;
395          case NRF_QSPI_CINSTR_LEN_6B:
396              reg |= ((uint32_t)p_tx_data_8[4]);
397              p_reg->CINSTRDAT1 = reg;
398              reg = 0;
399          case NRF_QSPI_CINSTR_LEN_5B:
400              reg |= ((uint32_t)p_tx_data_8[3]) << QSPI_CINSTRDAT0_BYTE3_Pos;
401          case NRF_QSPI_CINSTR_LEN_4B:
402              reg |= ((uint32_t)p_tx_data_8[2]) << QSPI_CINSTRDAT0_BYTE2_Pos;
403          case NRF_QSPI_CINSTR_LEN_3B:
404              reg |= ((uint32_t)p_tx_data_8[1]) << QSPI_CINSTRDAT0_BYTE1_Pos;
405          case NRF_QSPI_CINSTR_LEN_2B:
406              reg |= ((uint32_t)p_tx_data_8[0]);
407              p_reg->CINSTRDAT0 = reg;
408          case NRF_QSPI_CINSTR_LEN_1B:
409              break;
410          default:
411              break;
412      }
413  }
414  NRF_STATIC_INLINE void nrf_qspi_cinstrdata_get(NRF_QSPI_Type const * p_reg,
415                                                 nrf_qspi_cinstr_len_t length,
416                                                 void *                p_rx_data)
417  {
418      uint8_t *p_rx_data_8 = (uint8_t *) p_rx_data;
419      uint32_t reg1 = p_reg->CINSTRDAT1;
420      uint32_t reg0 = p_reg->CINSTRDAT0;
421      switch (length)
422      {
423          case NRF_QSPI_CINSTR_LEN_9B:
424              p_rx_data_8[7] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE7_Pos);
425          case NRF_QSPI_CINSTR_LEN_8B:
426              p_rx_data_8[6] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE6_Pos);
427          case NRF_QSPI_CINSTR_LEN_7B:
428              p_rx_data_8[5] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE5_Pos);
429          case NRF_QSPI_CINSTR_LEN_6B:
430              p_rx_data_8[4] = (uint8_t)(reg1);
431          case NRF_QSPI_CINSTR_LEN_5B:
432              p_rx_data_8[3] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE3_Pos);
433          case NRF_QSPI_CINSTR_LEN_4B:
434              p_rx_data_8[2] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE2_Pos);
435          case NRF_QSPI_CINSTR_LEN_3B:
436              p_rx_data_8[1] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE1_Pos);
437          case NRF_QSPI_CINSTR_LEN_2B:
438              p_rx_data_8[0] = (uint8_t)(reg0);
439          case NRF_QSPI_CINSTR_LEN_1B:
440              break;
441          default:
442              break;
443      }
444  }
445  NRF_STATIC_INLINE void nrf_qspi_cinstr_transfer_start(NRF_QSPI_Type *                p_reg,
446                                                        nrf_qspi_cinstr_conf_t const * p_config)
447  {
448      p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
449                           ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
450                           ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
451                           ((uint32_t)p_config->io3_level << QSPI_CINSTRCONF_LIO3_Pos) |
452                           ((uint32_t)p_config->wipwait   << QSPI_CINSTRCONF_WIPWAIT_Pos) |
453                           ((uint32_t)p_config->wren      << QSPI_CINSTRCONF_WREN_Pos));
454  }
455  NRF_STATIC_INLINE void nrf_qspi_cinstr_long_transfer_start(NRF_QSPI_Type *                p_reg,
456                                                             nrf_qspi_cinstr_conf_t const * p_config)
457  {
458      p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
459                           ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
460                           ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
461                           ((uint32_t)p_config->io3_level << QSPI_CINSTRCONF_LIO3_Pos) |
462                           ((uint32_t)p_config->wipwait   << QSPI_CINSTRCONF_WIPWAIT_Pos) |
463                           ((uint32_t)p_config->wren      << QSPI_CINSTRCONF_WREN_Pos) |
464                           (QSPI_CINSTRCONF_LFEN_Msk));
465  }
466  NRF_STATIC_INLINE bool nrf_qspi_cinstr_long_transfer_is_ongoing(NRF_QSPI_Type const * p_reg)
467  {
468      return (bool)((p_reg->CINSTRCONF & (QSPI_CINSTRCONF_LFEN_Msk | QSPI_CINSTRCONF_LFSTOP_Msk))
469                     == QSPI_CINSTRCONF_LFEN_Msk);
470  }
471  NRF_STATIC_INLINE void nrf_qspi_cinstr_long_transfer_continue(NRF_QSPI_Type *       p_reg,
472                                                                nrf_qspi_cinstr_len_t length,
473                                                                bool                  finalize)
474  {
475      uint32_t mask = (((uint32_t)length << QSPI_CINSTRCONF_LENGTH_Pos) | (QSPI_CINSTRCONF_LFEN_Msk));
476      mask |= (finalize ? QSPI_CINSTRCONF_LFSTOP_Msk : 0);
477      p_reg->CINSTRCONF = mask;
478  }
479  #if NRF_QSPI_HAS_XIPEN
480  NRF_STATIC_INLINE void nrf_qspi_xip_set(NRF_QSPI_Type * p_reg, bool enable)
481  {
482      p_reg->XIPEN = (enable ? QSPI_XIPEN_XIPEN_Enable << QSPI_XIPEN_XIPEN_Pos
483                             : QSPI_XIPEN_XIPEN_Disable << QSPI_XIPEN_XIPEN_Pos);
484  }
485  #endif
486  #if NRF_QSPI_HAS_XIP_ENC
487  NRF_STATIC_INLINE void nrf_qspi_xip_encryption_configure(NRF_QSPI_Type *               p_reg,
488                                                           nrf_qspi_encryption_t const * p_cfg)
489  {
490      p_reg->XIP_ENC.KEY0 = p_cfg->key[0];
491      p_reg->XIP_ENC.KEY1 = p_cfg->key[1];
492      p_reg->XIP_ENC.KEY2 = p_cfg->key[2];
493      p_reg->XIP_ENC.KEY3 = p_cfg->key[3];
<span onclick='openModal()' class='match'>494      p_reg->XIP_ENC.NONCE0 = p_cfg->nonce[0];
495      p_reg->XIP_ENC.NONCE1 = p_cfg->nonce[1];
496      p_reg->XIP_ENC.NONCE2 = p_cfg->nonce[2];
</span>497  }
498  NRF_STATIC_INLINE void nrf_qspi_xip_encryption_set(NRF_QSPI_Type * p_reg, bool enable)
499  {
500      p_reg->XIP_ENC.ENABLE =
501          (enable ? QSPI_XIP_ENC_ENABLE_ENABLE_Enabled << QSPI_XIP_ENC_ENABLE_ENABLE_Pos
502                  : QSPI_XIP_ENC_ENABLE_ENABLE_Disabled << QSPI_XIP_ENC_ENABLE_ENABLE_Pos);
503  }
504  #endif
505  #if NRF_QSPI_HAS_DMA_ENC
506  NRF_STATIC_INLINE void nrf_qspi_dma_encryption_configure(NRF_QSPI_Type *               p_reg,
507                                                           nrf_qspi_encryption_t const * p_cfg)
508  {
509      p_reg->DMA_ENC.KEY0 = p_cfg->key[0];
510      p_reg->DMA_ENC.KEY1 = p_cfg->key[1];
511      p_reg->DMA_ENC.KEY2 = p_cfg->key[2];
512      p_reg->DMA_ENC.KEY3 = p_cfg->key[3];
513      p_reg->DMA_ENC.NONCE0 = p_cfg->nonce[0];
514      p_reg->DMA_ENC.NONCE1 = p_cfg->nonce[1];
515      p_reg->DMA_ENC.NONCE2 = p_cfg->nonce[2];
516  }
517  NRF_STATIC_INLINE void nrf_qspi_dma_encryption_set(NRF_QSPI_Type * p_reg, bool enable)
518  {
519      p_reg->DMA_ENC.ENABLE =
520          (enable ? QSPI_DMA_ENC_ENABLE_ENABLE_Enabled << QSPI_DMA_ENC_ENABLE_ENABLE_Pos
521                  : QSPI_DMA_ENC_ENABLE_ENABLE_Disabled << QSPI_DMA_ENC_ENABLE_ENABLE_Pos);
522  }
523  #endif
524  #endif 
525  #ifdef __cplusplus
526  }
527  #endif
528  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_qspi.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_qspi.h</div>
                </div>
                <div class="column column_space"><pre><code>514      p_reg->DMA_ENC.NONCE1 = p_cfg->nonce[1];
515      p_reg->DMA_ENC.NONCE2 = p_cfg->nonce[2];
516  }
</pre></code></div>
                <div class="column column_space"><pre><code>494      p_reg->XIP_ENC.NONCE0 = p_cfg->nonce[0];
495      p_reg->XIP_ENC.NONCE1 = p_cfg->nonce[1];
496      p_reg->XIP_ENC.NONCE2 = p_cfg->nonce[2];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    