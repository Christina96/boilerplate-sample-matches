
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.898550724637681%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pkcs_1_i2osp.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_PKCS_1
<span onclick='openModal()' class='match'>3  int pkcs_1_i2osp(void *n, unsigned long modulus_len, unsigned char *out)
4  {
5     unsigned long size;
</span>6     size = mp_unsigned_bin_size(n);
7     if (size > modulus_len) {
8        return CRYPT_BUFFER_OVERFLOW;
9     }
10     zeromem(out, modulus_len);
11     return mp_to_unsigned_bin(n, out+(modulus_len-size));
12  }
13  #endif &bsol;* LTC_PKCS_1 */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_sequence_flexi.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  static int s_new_element(ltc_asn1_list **l)
4  {
5     if (*l == NULL) {
6        *l = XCALLOC(1, sizeof(ltc_asn1_list));
7        if (*l == NULL) {
8           return CRYPT_MEM;
9        }
10     } else {
11        (*l)->next = XCALLOC(1, sizeof(ltc_asn1_list));
12        if ((*l)->next == NULL) {
13           return CRYPT_MEM;
14        }
15        (*l)->next->prev = *l;
16        *l = (*l)->next;
17     }
18     return CRYPT_OK;
19  }
<span onclick='openModal()' class='match'>20  static int s_der_decode_sequence_flexi(const unsigned char *in, unsigned long *inlen, ltc_asn1_list **out, unsigned long depth)
21  {
22     ltc_asn1_list *l;
23     unsigned long err, identifier, len, totlen, data_offset, id_len, len_len;
</span>24     void          *realloc_tmp;
25     LTC_ARGCHK(in    != NULL);
26     LTC_ARGCHK(inlen != NULL);
27     LTC_ARGCHK(out   != NULL);
28     l = NULL;
29     totlen = 0;
30     if (*inlen == 0) {
31        if ((err = s_new_element(&l)) != CRYPT_OK) {
32           goto error;
33        }
34     }
35     while (*inlen) {
36        if ((err = s_new_element(&l)) != CRYPT_OK) {
37           goto error;
38        }
39        id_len = *inlen;
40        if ((err = der_decode_asn1_identifier(in, &id_len, l)) != CRYPT_OK) {
41           goto error;
42        }
43        identifier = *in;
44        if (l->type != LTC_ASN1_EOL) {
45           len_len = *inlen - id_len;
46  #if defined(LTC_TEST_DBG)
47           data_offset = 666;
48           len = 0;
49  #endif
50           if ((err = der_decode_asn1_length(&in[id_len], &len_len, &len)) != CRYPT_OK) {
51  #if defined(LTC_TEST_DBG)
52              fprintf(stderr, "E1 %02lx: hl=%4lu l=%4lu - %s (%s)\n", identifier, data_offset, len, der_asn1_tag_to_string_map[l->tag], error_to_string(err));
53  #endif
54              goto error;
55           } else if (len > (*inlen - id_len - len_len)) {
56              err = CRYPT_INVALID_PACKET;
57  #if defined(LTC_TEST_DBG)
58              fprintf(stderr, "E2 %02lx: hl=%4lu l=%4lu - %s (%s)\n", identifier, data_offset, len, der_asn1_tag_to_string_map[l->tag], error_to_string(err));
59  #endif
60              goto error;
61           }
62           data_offset = id_len + len_len;
63  #if defined(LTC_TEST_DBG) && LTC_TEST_DBG > 1
64           if (l->type == LTC_ASN1_CUSTOM_TYPE && l->klass == LTC_ASN1_CL_CONTEXT_SPECIFIC) {
65              fprintf(stderr, "OK %02lx: hl=%4lu l=%4lu - Context Specific[%s %llu]\n", identifier, data_offset, len, der_asn1_pc_to_string_map[l->pc], l->tag);
66           } else {
67              fprintf(stderr, "OK %02lx: hl=%4lu l=%4lu - %s\n", identifier, data_offset, len, der_asn1_tag_to_string_map[l->tag]);
68           }
69  #endif
70           len += data_offset;
71           if (l->type == LTC_ASN1_CUSTOM_TYPE) {
72              l->used = identifier;
73              if (l->pc == LTC_ASN1_PC_CONSTRUCTED) {
74                 identifier = 0x20;
75              } else {
76                 identifier = 0x80;
77              }
78           }
79        } else {
80           data_offset = 0;
81           len = 0;
82        }
83        switch (identifier) {
84           case 0x01: &bsol;* BOOLEAN */
85              if (l->type != LTC_ASN1_BOOLEAN) {
86                 err = CRYPT_PK_ASN1_ERROR;
87                 goto error;
88              }
89              l->size = 1;
90              l->data = XCALLOC(1, sizeof(int));
91              if ((err = der_decode_boolean(in, *inlen, l->data)) != CRYPT_OK) {
92                 goto error;
93              }
94              if ((err = der_length_boolean(&len)) != CRYPT_OK) {
95                 goto error;
96              }
97              break;
98           case 0x02: &bsol;* INTEGER */
99               if (l->type != LTC_ASN1_INTEGER) {
100                  err = CRYPT_PK_ASN1_ERROR;
101                  goto error;
102               }
103               l->size = 1;
104               if ((err = mp_init(&l->data)) != CRYPT_OK) {
105                   goto error;
106               }
107               if ((err = der_decode_integer(in, *inlen, l->data)) != CRYPT_OK) {
108                   goto error;
109               }
110               if ((err = der_length_integer(l->data, &len)) != CRYPT_OK) {
111                   goto error;
112               }
113               break;
114           case 0x03: &bsol;* BIT */
115              if (l->type != LTC_ASN1_BIT_STRING) {
116                 err = CRYPT_PK_ASN1_ERROR;
117                 goto error;
118              }
119              l->size = len * 8; &bsol;* *8 because we store decoded bits one per char and they are encoded 8 per char.  */
120              if ((l->data = XCALLOC(1, l->size)) == NULL) {
121                 err = CRYPT_MEM;
122                 goto error;
123              }
124              if ((err = der_decode_bit_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
125                 goto error;
126              }
127              if ((err = der_length_bit_string(l->size, &len)) != CRYPT_OK) {
128                 goto error;
129              }
130              break;
131           case 0x04: &bsol;* OCTET */
132              if (l->type != LTC_ASN1_OCTET_STRING) {
133                 err = CRYPT_PK_ASN1_ERROR;
134                 goto error;
135              }
136              l->size = len;
137              if ((l->data = XCALLOC(1, l->size)) == NULL) {
138                 err = CRYPT_MEM;
139                 goto error;
140              }
141              if ((err = der_decode_octet_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
142                 goto error;
143              }
144              if ((err = der_length_octet_string(l->size, &len)) != CRYPT_OK) {
145                 goto error;
146              }
147              break;
148           case 0x05: &bsol;* NULL */
149              if (l->type != LTC_ASN1_NULL) {
150                 err = CRYPT_PK_ASN1_ERROR;
151                 goto error;
152              }
153              if (in[0] != 0x05 || in[1] != 0x00) {
154                 err = CRYPT_INVALID_PACKET;
155                 goto error;
156              }
157              l->data = NULL;
158              l->size = 0;
159              len     = 2;
160              break;
161           case 0x06: &bsol;* OID */
162              if (l->type != LTC_ASN1_OBJECT_IDENTIFIER) {
163                 err = CRYPT_PK_ASN1_ERROR;
164                 goto error;
165              }
166              l->size = len;
167              if ((l->data = XCALLOC(len, sizeof(unsigned long))) == NULL) {
168                 err = CRYPT_MEM;
169                 goto error;
170              }
171              if ((err = der_decode_object_identifier(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
172                 goto error;
173              }
174              if ((err = der_length_object_identifier(l->data, l->size, &len)) != CRYPT_OK) {
175                 goto error;
176              }
177              if ((realloc_tmp = XREALLOC(l->data, l->size * sizeof(unsigned long))) == NULL) {
178                 break;
179              }
180              l->data = realloc_tmp;
181              break;
182           case 0x0C: &bsol;* UTF8 */
183              if (l->type != LTC_ASN1_UTF8_STRING) {
184                 err = CRYPT_PK_ASN1_ERROR;
185                 goto error;
186              }
187              l->size = len;
188              if ((l->data = XCALLOC(sizeof(wchar_t), l->size)) == NULL) {
189                 err = CRYPT_MEM;
190                 goto error;
191              }
192              if ((err = der_decode_utf8_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
193                 goto error;
194              }
195              if ((err = der_length_utf8_string(l->data, l->size, &len)) != CRYPT_OK) {
196                 goto error;
197              }
198              break;
199           case 0x13: &bsol;* PRINTABLE */
200              if (l->type != LTC_ASN1_PRINTABLE_STRING) {
201                 err = CRYPT_PK_ASN1_ERROR;
202                 goto error;
203              }
204              l->size = len;
205              if ((l->data = XCALLOC(1, l->size)) == NULL) {
206                 err = CRYPT_MEM;
207                 goto error;
208              }
209              if ((err = der_decode_printable_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
210                 goto error;
211              }
212              if ((err = der_length_printable_string(l->data, l->size, &len)) != CRYPT_OK) {
213                 goto error;
214              }
215              break;
216           case 0x14: &bsol;* TELETEXT */
217              if (l->type != LTC_ASN1_TELETEX_STRING) {
218                 err = CRYPT_PK_ASN1_ERROR;
219                 goto error;
220              }
221              l->size = len;
222              if ((l->data = XCALLOC(1, l->size)) == NULL) {
223                 err = CRYPT_MEM;
224                 goto error;
225              }
226              if ((err = der_decode_teletex_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
227                 goto error;
228              }
229              if ((err = der_length_teletex_string(l->data, l->size, &len)) != CRYPT_OK) {
230                 goto error;
231              }
232              break;
233           case 0x16: &bsol;* IA5 */
234              if (l->type != LTC_ASN1_IA5_STRING) {
235                 err = CRYPT_PK_ASN1_ERROR;
236                 goto error;
237              }
238              l->size = len;
239              if ((l->data = XCALLOC(1, l->size)) == NULL) {
240                 err = CRYPT_MEM;
241                 goto error;
242              }
243              if ((err = der_decode_ia5_string(in, *inlen, l->data, &l->size)) != CRYPT_OK) {
244                 goto error;
245              }
246              if ((err = der_length_ia5_string(l->data, l->size, &len)) != CRYPT_OK) {
247                 goto error;
248              }
249              break;
250           case 0x17: &bsol;* UTC TIME */
251              if (l->type != LTC_ASN1_UTCTIME) {
252                 err = CRYPT_PK_ASN1_ERROR;
253                 goto error;
254              }
255              l->size = 1;
256              if ((l->data = XCALLOC(1, sizeof(ltc_utctime))) == NULL) {
257                 err = CRYPT_MEM;
258                 goto error;
259              }
260              len = *inlen;
261              if ((err = der_decode_utctime(in, &len, l->data)) != CRYPT_OK) {
262                 goto error;
263              }
264              if ((err = der_length_utctime(l->data, &len)) != CRYPT_OK) {
265                 goto error;
266              }
267              break;
268           case 0x18:
269              if (l->type != LTC_ASN1_GENERALIZEDTIME) {
270                 err = CRYPT_PK_ASN1_ERROR;
271                 goto error;
272              }
273              l->size = len;
274              if ((l->data = XCALLOC(1, sizeof(ltc_generalizedtime))) == NULL) {
275                 err = CRYPT_MEM;
276                 goto error;
277              }
278              if ((err = der_decode_generalizedtime(in, &len, l->data)) != CRYPT_OK) {
279                 goto error;
280              }
281              if ((err = der_length_generalizedtime(l->data, &len)) != CRYPT_OK) {
282                 goto error;
283              }
284              break;
285           case 0x20: &bsol;* Any CONSTRUCTED element that is neither SEQUENCE nor SET */
286           case 0x30: &bsol;* SEQUENCE */
287           case 0x31: &bsol;* SET */
288               if (identifier == 0x20) {
289                 if (l->type != LTC_ASN1_CUSTOM_TYPE) {
290                    err = CRYPT_PK_ASN1_ERROR;
291                    goto error;
292                 }
293               }
294               else if (identifier == 0x30) {
295                 if (l->type != LTC_ASN1_SEQUENCE) {
296                    err = CRYPT_PK_ASN1_ERROR;
297                    goto error;
298                 }
299               }
300               else {
301                 if (l->type != LTC_ASN1_SET) {
302                    err = CRYPT_PK_ASN1_ERROR;
303                    goto error;
304                 }
305               }
306               if (depth > LTC_DER_MAX_RECURSION) {
307                  err = CRYPT_PK_ASN1_ERROR;
308                  goto error;
309               }
310               if ((l->data = XMALLOC(len)) == NULL) {
311                  err = CRYPT_MEM;
312                  goto error;
313               }
314               XMEMCPY(l->data, in, len);
315               l->size = len;
316               in     += data_offset;
317               *inlen -= data_offset;
318               len    -= data_offset;
319               len_len = len;
320               if ((err = s_der_decode_sequence_flexi(in, &len, &(l->child), depth+1)) != CRYPT_OK) {
321                  goto error;
322               }
323               if (len_len != len) {
324                  err = CRYPT_PK_ASN1_ERROR;
325                  goto error;
326               }
327               totlen += data_offset;
328               if (l->child) {
329                  l->child->parent = l;
330               }
331               break;
332           case 0x80: &bsol;* Context-specific */
333               if (l->type != LTC_ASN1_CUSTOM_TYPE) {
334                  err = CRYPT_PK_ASN1_ERROR;
335                  goto error;
336               }
337               if ((l->data = XCALLOC(1, len - data_offset)) == NULL) {
338                  err = CRYPT_MEM;
339                  goto error;
340               }
341               XMEMCPY(l->data, in + data_offset, len - data_offset);
342               l->size = len - data_offset;
343               break;
344           default:
345             if (l->prev) {
346                l       = l->prev;
347                XFREE(l->next);
348                l->next = NULL;
349             }
350             goto outside;
351        }
352        totlen  += len;
353        in      += len;
354        *inlen  -= len;
355     }
356  outside:
357     if (totlen) {
358        while (l->prev != NULL || l->parent != NULL) {
359           if (l->parent != NULL) {
360              l = l->parent;
361           } else {
362              l = l->prev;
363           }
364        }
365     }
366     *out   = l;
367     *inlen = totlen;
368     return CRYPT_OK;
369  error:
370     der_sequence_free(l);
371     return err;
372  }
373  int der_decode_sequence_flexi(const unsigned char *in, unsigned long *inlen, ltc_asn1_list **out)
374  {
375     return s_der_decode_sequence_flexi(in, inlen, out, 0);
376  }
377  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pkcs_1_i2osp.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_sequence_flexi.c</div>
                </div>
                <div class="column column_space"><pre><code>3  int pkcs_1_i2osp(void *n, unsigned long modulus_len, unsigned char *out)
4  {
5     unsigned long size;
</pre></code></div>
                <div class="column column_space"><pre><code>20  static int s_der_decode_sequence_flexi(const unsigned char *in, unsigned long *inlen, ltc_asn1_list **out, unsigned long depth)
21  {
22     ltc_asn1_list *l;
23     unsigned long err, identifier, len, totlen, data_offset, id_len, len_len;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    