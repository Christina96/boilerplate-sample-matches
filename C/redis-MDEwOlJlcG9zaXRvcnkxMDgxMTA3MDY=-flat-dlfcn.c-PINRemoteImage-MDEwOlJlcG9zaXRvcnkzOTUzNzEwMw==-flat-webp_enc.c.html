
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.4024024024024024%, Tokens: 8</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-dlfcn.c</h3>
            <pre><code>1  #ifdef _DEBUG
2  #define _CRTDBG_MAP_ALLOC
3  #include <stdlib.h>
4  #include <crtdbg.h>
5  #endif
6  #define PSAPI_VERSION 1
7  #include <windows.h>
8  #include <psapi.h>
9  #include <stdio.h>
10  #ifdef SHARED
11  #define DLFCN_WIN32_EXPORTS
12  #endif
13  #include "dlfcn.h"
14  #if ((defined(_WIN32) || defined(WIN32)) && (defined(_MSC_VER)) )
15  #define snprintf sprintf_s
16  #endif
17  #ifdef UNICODE
18  #include <wchar.h>
19  #define CHAR	wchar_t
20  #define UNICODE_L(s)	L##s
21  #else
22  #define CHAR	char
23  #define UNICODE_L(s)	s
24  #endif
25  typedef struct global_object {
26      HMODULE hModule;
27      struct global_object *previous;
28      struct global_object *next;
29  } global_object;
30  static global_object first_object;
31  static global_object first_automatic_object;
32  static int auto_ref_count = 0;
33  static global_object *global_search( global_object *start, HMODULE hModule )
34  {
35      global_object *pobject;
36      if( hModule == NULL )
37          return NULL;
38      for( pobject = start; pobject; pobject = pobject->next )
39          if( pobject->hModule == hModule )
40              return pobject;
41      return NULL;
42  }
43  static void global_add( global_object *start, HMODULE hModule )
44  {
45      global_object *pobject;
46      global_object *nobject;
47      if( hModule == NULL )
48          return;
49      pobject = global_search( start, hModule );
50      if( pobject )
51          return;
52      if( start == &first_automatic_object )
53      {
54          pobject = global_search( &first_object, hModule );
55          if( pobject )
56              return;
57      }
58      for( pobject = start; pobject->next; pobject = pobject->next );
59      nobject = (global_object*) malloc( sizeof( global_object ) );
60      if( !nobject )
61          return;
62      pobject->next = nobject;
63      nobject->next = NULL;
64      nobject->previous = pobject;
65      nobject->hModule = hModule;
66  }
67  static void global_rem( global_object *start, HMODULE hModule )
68  {
69      global_object *pobject;
70      if( hModule == NULL )
71          return;
72      pobject = global_search( start, hModule );
73      if( !pobject )
74          return;
75      if( pobject->next )
76          pobject->next->previous = pobject->previous;
77      if( pobject->previous )
78          pobject->previous->next = pobject->next;
79      free( pobject );
80  }
81  static CHAR error_buffer[65535];
82  static CHAR *current_error;
83  static char dlerror_buffer[65536];
84  static int copy_string( CHAR *dest, int dest_size, const CHAR *src )
85  {
86      int i = 0;
87      if( !src || !dest )
88          return 0;
89      for( i = 0 ; i < dest_size-1 ; i++ )
90      {
91          if( !src[i] )
92              break;
93          else
94              dest[i] = src[i];
95      }
96      dest[i] = '\0';
97      return i;
98  }
99  static void save_err_str( const CHAR *str )
100  {
101      DWORD dwMessageId;
102      DWORD pos;
103      dwMessageId = GetLastError( );
104      if( dwMessageId == 0 )
105          return;
106      pos  = copy_string( error_buffer,     sizeof(error_buffer),     UNICODE_L("\"") );
107      pos += copy_string( error_buffer+pos, sizeof(error_buffer)-pos, str );
108      pos += copy_string( error_buffer+pos, sizeof(error_buffer)-pos, UNICODE_L("\": ") );
109      pos += FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwMessageId,
110          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
111          error_buffer+pos, sizeof(error_buffer)-pos, NULL );
112      if( pos > 1 )
113      {
114          if( error_buffer[pos-2] == '\r' && error_buffer[pos-1] == '\n' )
115              error_buffer[pos-2] = '\0';
116      }
117      current_error = error_buffer;
118  }
119  static void save_err_ptr_str( const void *ptr )
120  {
121      CHAR ptr_buf[19]; &bsol;* 0x<pointer> up to 64 bits. */
122  #ifdef UNICODE
123  #	if ((defined(_WIN32) || defined(WIN32)) && (defined(_MSC_VER)) )
124      swprintf_s( ptr_buf, 19, UNICODE_L("0x%p"), ptr );
125  #	else
126      swprintf(ptr_buf, 19, UNICODE_L("0x%p"), ptr);
127  #	endif
128  #else
129      snprintf( ptr_buf, 19, "0x%p", ptr );
130  #endif
131      save_err_str( ptr_buf );
132  }
133  void *dlopen( const char *file, int mode )
134  {
135      HMODULE hModule;
136      UINT uMode;
137      current_error = NULL;
138      uMode = SetErrorMode( SEM_FAILCRITICALERRORS );
139      if( file == 0 )
140      {
141          HMODULE hAddtnlMods[1024]; 
142          HANDLE hCurrentProc = GetCurrentProcess( );
143          DWORD cbNeeded;
144          hModule = GetModuleHandle( NULL );
145          if( !hModule )
146              save_err_ptr_str( file );
147          if( EnumProcessModules( hCurrentProc, hAddtnlMods,
148              sizeof( hAddtnlMods ), &cbNeeded ) != 0 )
149          {
150              DWORD i;
151              for( i = 0; i < cbNeeded / sizeof( HMODULE ); i++ )
152              {
153                  global_add( &first_automatic_object, hAddtnlMods[i] );
154              }
155          }
156          auto_ref_count++;
157      }
158      else
159      {
160          CHAR lpFileName[MAX_PATH];
161          int i;
162          for( i = 0 ; i < sizeof(lpFileName) - 1 ; i ++ )
163          {
164              if( !file[i] )
165                  break;
166              else if( file[i] == '/' )
167                  lpFileName[i] = '\\';
168              else
169                  lpFileName[i] = file[i];
170          }
171          lpFileName[i] = '\0';
172          hModule = LoadLibraryEx(lpFileName, NULL, 
173                                  LOAD_WITH_ALTERED_SEARCH_PATH );
174          if( !hModule )
175              save_err_str( lpFileName );
176          else if( (mode & RTLD_GLOBAL) )
177              global_add( &first_object, hModule );
178      }
179      SetErrorMode( uMode );
180      return (void *) hModule;
181  }
182  static void free_auto( )
183  {
184      global_object *pobject = first_automatic_object.next;
185      if( pobject )
186      {
187          global_object *next;
188          for ( ; pobject; pobject = next )
189          {
190              next = pobject->next;
191              free( pobject );
192          }
193          first_automatic_object.next = NULL;
194      }
195  }
196  int dlclose( void *handle )
197  {
198      HMODULE hModule = (HMODULE) handle;
199      BOOL ret;
200      current_error = NULL;
201      ret = FreeLibrary( hModule );
202      if( ret )
203      {
204          HMODULE cur = GetModuleHandle( NULL );
205          global_rem( &first_object, hModule );
206          if( hModule == cur )
207          {
208              auto_ref_count--;
209              if( auto_ref_count < 0 )
210                  auto_ref_count = 0;
211              if( !auto_ref_count )
212                  free_auto( );
213          }
214      }
215      else
216          save_err_ptr_str( handle );
217      ret = !ret;
218      return (int) ret;
219  }
220  void *dlsym( void *handle, const char *name )
221  {
222      FARPROC symbol;
223      HMODULE hModule;
224  #ifdef UNICODE
225      wchar_t namew[MAX_PATH];
226      wmemset(namew, 0, MAX_PATH);
227  #endif
228      current_error = NULL;
229      symbol = GetProcAddress( (HMODULE) handle, name );
230      if( symbol != NULL )
231          goto end;
232      hModule = GetModuleHandle( NULL );
233      if( hModule == handle )
234      {
235          global_object *pobject;
236          for( pobject = &first_object; pobject; pobject = pobject->next )
237          {
238              if( pobject->hModule )
239              {
240                  symbol = GetProcAddress( pobject->hModule, name );
241                  if( symbol != NULL )
242                      goto end;
243              }
244          }
245          for( pobject = &first_automatic_object; pobject; pobject = pobject->next )
246          {
247              if( pobject->hModule )
248              {
249                  symbol = GetProcAddress( pobject->hModule, name );
250                  if( symbol != NULL )
251                      goto end;
252              }
253          }
254      }
255  end:
256      if( symbol == NULL )
257      {
258  #ifdef UNICODE
259          size_t converted_chars;
260          size_t str_len = strlen(name) + 1;
261  #if ((defined(_WIN32) || defined(WIN32)) && (defined(_MSC_VER)) )
262          errno_t err = mbstowcs_s(&converted_chars, namew, str_len, name, str_len);
263          if (err != 0)
264              return NULL;
265  #else
266          mbstowcs(namew, name, str_len);
267  #endif
268          save_err_str( namew );
269  #else
270          save_err_str( name );
271  #endif
272      }
273  #ifdef _MSC_VER
274  #pragma warning( suppress: 4054 )
275  #endif
276      return (void*) symbol;
277  }
278  char *dlerror( void )
279  {
280      char *error_pointer = dlerror_buffer;
<span onclick='openModal()' class='match'>281      if (current_error == NULL)
282      {
283          return NULL;
284      }
285  #ifdef UNICODE
286      errno_t err = 0;
287      size_t converted_chars = 0;
</span>288      size_t str_len = wcslen(current_error) + 1;
289      memset(error_pointer, 0, 65535);
290  #	if ((defined(_WIN32) || defined(WIN32)) && (defined(_MSC_VER)) )
291      err = wcstombs_s(&converted_chars, 
292          error_pointer, str_len * sizeof(char),
293          current_error, str_len * sizeof(wchar_t));
294      if (err != 0)
295          return NULL;
296  #	else
297      wcstombs(error_pointer, current_error, str_len);
298  #	endif
299  #else
300      memcpy(error_pointer, current_error, strlen(current_error) + 1);
301  #endif
302      current_error = NULL;
303      return error_pointer;
304  }
305  #ifdef SHARED
306  BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
307  {
308      (void) hinstDLL;
309      if( fdwReason == DLL_PROCESS_DETACH && !lpvReserved )
310      {
311          auto_ref_count = 0;
312          free_auto( );
313      }
314      return TRUE;
315  }
316  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include <math.h>
5  #include "src/enc/cost_enc.h"
6  #include "src/enc/vp8i_enc.h"
7  #include "src/enc/vp8li_enc.h"
8  #include "src/utils/utils.h"
9  #ifdef PRINT_MEMORY_INFO
10  #include <stdio.h>
11  #endif
12  int WebPGetEncoderVersion(void) {
13    return (ENC_MAJ_VERSION << 16) | (ENC_MIN_VERSION << 8) | ENC_REV_VERSION;
14  }
15  static void ResetSegmentHeader(VP8Encoder* const enc) {
16    VP8EncSegmentHeader* const hdr = &enc->segment_hdr_;
17    hdr->num_segments_ = enc->config_->segments;
18    hdr->update_map_  = (hdr->num_segments_ > 1);
19    hdr->size_ = 0;
20  }
21  static void ResetFilterHeader(VP8Encoder* const enc) {
22    VP8EncFilterHeader* const hdr = &enc->filter_hdr_;
23    hdr->simple_ = 1;
24    hdr->level_ = 0;
25    hdr->sharpness_ = 0;
26    hdr->i4x4_lf_delta_ = 0;
27  }
28  static void ResetBoundaryPredictions(VP8Encoder* const enc) {
29    int i;
30    uint8_t* const top = enc->preds_ - enc->preds_w_;
31    uint8_t* const left = enc->preds_ - 1;
32    for (i = -1; i < 4 * enc->mb_w_; ++i) {
33      top[i] = B_DC_PRED;
34    }
35    for (i = 0; i < 4 * enc->mb_h_; ++i) {
36      left[i * enc->preds_w_] = B_DC_PRED;
37    }
38    enc->nz_[-1] = 0;   
39  }
40  static void MapConfigToTools(VP8Encoder* const enc) {
41    const WebPConfig* const config = enc->config_;
42    const int method = config->method;
43    const int limit = 100 - config->partition_limit;
44    enc->method_ = method;
45    enc->rd_opt_level_ = (method >= 6) ? RD_OPT_TRELLIS_ALL
46                       : (method >= 5) ? RD_OPT_TRELLIS
47                       : (method >= 3) ? RD_OPT_BASIC
48                       : RD_OPT_NONE;
49    enc->max_i4_header_bits_ =
50        256 * 16 * 16 *                 
51        (limit * limit) / (100 * 100);  
52    enc->mb_header_limit_ =
53        (score_t)256 * 510 * 8 * 1024 / (enc->mb_w_ * enc->mb_h_);
54    enc->thread_level_ = config->thread_level;
55    enc->do_search_ = (config->target_size > 0 || config->target_PSNR > 0);
56    if (!config->low_memory) {
57  #if !defined(DISABLE_TOKEN_BUFFER)
58      enc->use_tokens_ = (enc->rd_opt_level_ >= RD_OPT_BASIC);  
59  #endif
60      if (enc->use_tokens_) {
61        enc->num_parts_ = 1;   
62      }
63    }
64  }
65  static VP8Encoder* InitVP8Encoder(const WebPConfig* const config,
66                                    WebPPicture* const picture) {
67    VP8Encoder* enc;
68    const int use_filter =
69        (config->filter_strength > 0) || (config->autofilter > 0);
70    const int mb_w = (picture->width + 15) >> 4;
71    const int mb_h = (picture->height + 15) >> 4;
72    const int preds_w = 4 * mb_w + 1;
73    const int preds_h = 4 * mb_h + 1;
74    const size_t preds_size = preds_w * preds_h * sizeof(*enc->preds_);
75    const int top_stride = mb_w * 16;
76    const size_t nz_size = (mb_w + 1) * sizeof(*enc->nz_) + WEBP_ALIGN_CST;
77    const size_t info_size = mb_w * mb_h * sizeof(*enc->mb_info_);
78    const size_t samples_size =
79        2 * top_stride * sizeof(*enc->y_top_)  
80        + WEBP_ALIGN_CST;                      
81    const size_t lf_stats_size =
82        config->autofilter ? sizeof(*enc->lf_stats_) + WEBP_ALIGN_CST : 0;
83    const size_t top_derr_size =
84        (config->quality <= ERROR_DIFFUSION_QUALITY || config->pass > 1) ?
85            mb_w * sizeof(*enc->top_derr_) : 0;
86    uint8_t* mem;
87    const uint64_t size = (uint64_t)sizeof(*enc)   
88                        + WEBP_ALIGN_CST           
89                        + info_size                
90                        + preds_size               
91                        + samples_size             
92                        + top_derr_size            
93                        + nz_size                  
94                        + lf_stats_size;           
95  #ifdef PRINT_MEMORY_INFO
96    printf("===================================\n");
97    printf("Memory used:\n"
98           "             encoder: %ld\n"
99           "                info: %ld\n"
100           "               preds: %ld\n"
101           "         top samples: %ld\n"
102           "       top diffusion: %ld\n"
103           "            non-zero: %ld\n"
104           "            lf-stats: %ld\n"
105           "               total: %ld\n",
106           sizeof(*enc) + WEBP_ALIGN_CST, info_size,
107           preds_size, samples_size, top_derr_size, nz_size, lf_stats_size, size);
108    printf("Transient object sizes:\n"
109           "      VP8EncIterator: %ld\n"
110           "        VP8ModeScore: %ld\n"
111           "      VP8SegmentInfo: %ld\n"
112           "         VP8EncProba: %ld\n"
113           "             LFStats: %ld\n",
114           sizeof(VP8EncIterator), sizeof(VP8ModeScore),
115           sizeof(VP8SegmentInfo), sizeof(VP8EncProba),
116           sizeof(LFStats));
117    printf("Picture size (yuv): %ld\n",
118           mb_w * mb_h * 384 * sizeof(uint8_t));
119    printf("===================================\n");
120  #endif
121    mem = (uint8_t*)WebPSafeMalloc(size, sizeof(*mem));
<span onclick='openModal()' class='match'>122    if (mem == NULL) {
123      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
124      return NULL;
125    }
126    enc = (VP8Encoder*)mem;
127    mem = (uint8_t*)WEBP_ALIGN(mem + sizeof(*enc));
</span>128    memset(enc, 0, sizeof(*enc));
129    enc->num_parts_ = 1 << config->partitions;
130    enc->mb_w_ = mb_w;
131    enc->mb_h_ = mb_h;
132    enc->preds_w_ = preds_w;
133    enc->mb_info_ = (VP8MBInfo*)mem;
134    mem += info_size;
135    enc->preds_ = mem + 1 + enc->preds_w_;
136    mem += preds_size;
137    enc->nz_ = 1 + (uint32_t*)WEBP_ALIGN(mem);
138    mem += nz_size;
139    enc->lf_stats_ = lf_stats_size ? (LFStats*)WEBP_ALIGN(mem) : NULL;
140    mem += lf_stats_size;
141    mem = (uint8_t*)WEBP_ALIGN(mem);
142    enc->y_top_ = mem;
143    enc->uv_top_ = enc->y_top_ + top_stride;
144    mem += 2 * top_stride;
145    enc->top_derr_ = top_derr_size ? (DError*)mem : NULL;
146    mem += top_derr_size;
147    assert(mem <= (uint8_t*)enc + size);
148    enc->config_ = config;
149    enc->profile_ = use_filter ? ((config->filter_type == 1) ? 0 : 1) : 2;
150    enc->pic_ = picture;
151    enc->percent_ = 0;
152    MapConfigToTools(enc);
153    VP8EncDspInit();
154    VP8DefaultProbas(enc);
155    ResetSegmentHeader(enc);
156    ResetFilterHeader(enc);
157    ResetBoundaryPredictions(enc);
158    VP8EncDspCostInit();
159    VP8EncInitAlpha(enc);
160    {
161      const float scale = 1.f + config->quality * 5.f / 100.f;  
162      VP8TBufferInit(&enc->tokens_, (int)(mb_w * mb_h * 4 * scale));
163    }
164    return enc;
165  }
166  static int DeleteVP8Encoder(VP8Encoder* enc) {
167    int ok = 1;
168    if (enc != NULL) {
169      ok = VP8EncDeleteAlpha(enc);
170      VP8TBufferClear(&enc->tokens_);
171      WebPSafeFree(enc);
172    }
173    return ok;
174  }
175  #if !defined(WEBP_DISABLE_STATS)
176  static double GetPSNR(uint64_t err, uint64_t size) {
177    return (err > 0 && size > 0) ? 10. * log10(255. * 255. * size / err) : 99.;
178  }
179  static void FinalizePSNR(const VP8Encoder* const enc) {
180    WebPAuxStats* stats = enc->pic_->stats;
181    const uint64_t size = enc->sse_count_;
182    const uint64_t* const sse = enc->sse_;
183    stats->PSNR[0] = (float)GetPSNR(sse[0], size);
184    stats->PSNR[1] = (float)GetPSNR(sse[1], size / 4);
185    stats->PSNR[2] = (float)GetPSNR(sse[2], size / 4);
186    stats->PSNR[3] = (float)GetPSNR(sse[0] + sse[1] + sse[2], size * 3 / 2);
187    stats->PSNR[4] = (float)GetPSNR(sse[3], size);
188  }
189  #endif  
190  static void StoreStats(VP8Encoder* const enc) {
191  #if !defined(WEBP_DISABLE_STATS)
192    WebPAuxStats* const stats = enc->pic_->stats;
193    if (stats != NULL) {
194      int i, s;
195      for (i = 0; i < NUM_MB_SEGMENTS; ++i) {
196        stats->segment_level[i] = enc->dqm_[i].fstrength_;
197        stats->segment_quant[i] = enc->dqm_[i].quant_;
198        for (s = 0; s <= 2; ++s) {
199          stats->residual_bytes[s][i] = enc->residual_bytes_[s][i];
200        }
201      }
202      FinalizePSNR(enc);
203      stats->coded_size = enc->coded_size_;
204      for (i = 0; i < 3; ++i) {
205        stats->block_count[i] = enc->block_count_[i];
206      }
207    }
208  #else  
209    WebPReportProgress(enc->pic_, 100, &enc->percent_);  
210  #endif  
211  }
212  int WebPEncodingSetError(const WebPPicture* const pic,
213                           WebPEncodingError error) {
214    assert((int)error < VP8_ENC_ERROR_LAST);
215    assert((int)error >= VP8_ENC_OK);
216    ((WebPPicture*)pic)->error_code = error;
217    return 0;
218  }
219  int WebPReportProgress(const WebPPicture* const pic,
220                         int percent, int* const percent_store) {
221    if (percent_store != NULL && percent != *percent_store) {
222      *percent_store = percent;
223      if (pic->progress_hook && !pic->progress_hook(percent, pic)) {
224        WebPEncodingSetError(pic, VP8_ENC_ERROR_USER_ABORT);
225        return 0;
226      }
227    }
228    return 1;  
229  }
230  int WebPEncode(const WebPConfig* config, WebPPicture* pic) {
231    int ok = 0;
232    if (pic == NULL) return 0;
233    WebPEncodingSetError(pic, VP8_ENC_OK);  
234    if (config == NULL) {  
235      return WebPEncodingSetError(pic, VP8_ENC_ERROR_NULL_PARAMETER);
236    }
237    if (!WebPValidateConfig(config)) {
238      return WebPEncodingSetError(pic, VP8_ENC_ERROR_INVALID_CONFIGURATION);
239    }
240    if (pic->width <= 0 || pic->height <= 0) {
241      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
242    }
243    if (pic->width > WEBP_MAX_DIMENSION || pic->height > WEBP_MAX_DIMENSION) {
244      return WebPEncodingSetError(pic, VP8_ENC_ERROR_BAD_DIMENSION);
245    }
246    if (pic->stats != NULL) memset(pic->stats, 0, sizeof(*pic->stats));
247    if (!config->lossless) {
248      VP8Encoder* enc = NULL;
249      if (pic->use_argb || pic->y == NULL || pic->u == NULL || pic->v == NULL) {
250        if (config->use_sharp_yuv || (config->preprocessing & 4)) {
251          if (!WebPPictureSharpARGBToYUVA(pic)) {
252            return 0;
253          }
254        } else {
255          float dithering = 0.f;
256          if (config->preprocessing & 2) {
257            const float x = config->quality / 100.f;
258            const float x2 = x * x;
259            dithering = 1.0f + (0.5f - 1.0f) * x2 * x2;
260          }
261          if (!WebPPictureARGBToYUVADithered(pic, WEBP_YUV420, dithering)) {
262            return 0;
263          }
264        }
265      }
266      if (!config->exact) {
267        WebPCleanupTransparentArea(pic);
268      }
269      enc = InitVP8Encoder(config, pic);
270      if (enc == NULL) return 0;  
271      ok = VP8EncAnalyze(enc);
272      ok = ok && VP8EncStartAlpha(enc);   
273      if (!enc->use_tokens_) {
274        ok = ok && VP8EncLoop(enc);
275      } else {
276        ok = ok && VP8EncTokenLoop(enc);
277      }
278      ok = ok && VP8EncFinishAlpha(enc);
279      ok = ok && VP8EncWrite(enc);
280      StoreStats(enc);
281      if (!ok) {
282        VP8EncFreeBitWriters(enc);
283      }
284      ok &= DeleteVP8Encoder(enc);  
285    } else {
286      if (pic->argb == NULL && !WebPPictureYUVAToARGB(pic)) {
287        return 0;
288      }
289      if (!config->exact) {
290        WebPCleanupTransparentAreaLossless(pic);
291      }
292      ok = VP8LEncodeImage(config, pic);  
293    }
294    return ok;
295  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-dlfcn.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_enc.c</div>
                </div>
                <div class="column column_space"><pre><code>281      if (current_error == NULL)
282      {
283          return NULL;
284      }
285  #ifdef UNICODE
286      errno_t err = 0;
287      size_t converted_chars = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>122    if (mem == NULL) {
123      WebPEncodingSetError(picture, VP8_ENC_ERROR_OUT_OF_MEMORY);
124      return NULL;
125    }
126    enc = (VP8Encoder*)mem;
127    mem = (uint8_t*)WEBP_ALIGN(mem + sizeof(*enc));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    