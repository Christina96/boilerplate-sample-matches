
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.298013245033113%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_process.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_CCM_MODE
3  int ccm_process(ccm_state *ccm,
4                  unsigned char *pt,     unsigned long ptlen,
5                  unsigned char *ct,
6                  int direction)
7  {
8     unsigned char z, b;
9     unsigned long y;
10     int err;
11     LTC_ARGCHK(ccm != NULL);
<span onclick='openModal()' class='match'>12     if (ccm->aadlen != ccm->current_aadlen) {
13        return CRYPT_ERROR;
14     }
15     if (ccm->ptlen < ccm->current_ptlen + ptlen) {
16        return CRYPT_ERROR;
17     }
</span>18     ccm->current_ptlen += ptlen;
19     if (ptlen > 0) {
20        LTC_ARGCHK(pt != NULL);
21        LTC_ARGCHK(ct != NULL);
22        for (y = 0; y < ptlen; y++) {
23           if (ccm->CTRlen == 16) {
24              for (z = 15; z > 15-ccm->L; z--) {
25                 ccm->ctr[z] = (ccm->ctr[z] + 1) & 255;
26                 if (ccm->ctr[z]) break;
27              }
28              if ((err = cipher_descriptor[ccm->cipher].ecb_encrypt(ccm->ctr, ccm->CTRPAD, &ccm->K)) != CRYPT_OK) {
29                 return err;
30              }
31              ccm->CTRlen = 0;
32           }
33           if (direction == CCM_ENCRYPT) {
34              b     = pt[y];
35              ct[y] = b ^ ccm->CTRPAD[ccm->CTRlen++];
36           } else {
37              b     = ct[y] ^ ccm->CTRPAD[ccm->CTRlen++];
38              pt[y] = b;
39           }
40           if (ccm->x == 16) {
41              if ((err = cipher_descriptor[ccm->cipher].ecb_encrypt(ccm->PAD, ccm->PAD, &ccm->K)) != CRYPT_OK) {
42                 return err;
43              }
44              ccm->x = 0;
45           }
46           ccm->PAD[ccm->x++] ^= b;
47        }
48     }
49     return CRYPT_OK;
50  }
51  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-utils.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include "config.h"
3  #endif
4  #include <stdlib.h>
5  #include <unistd.h>
6  #include <string.h>
7  #include <errno.h>
8  #include <ctype.h>
9  #ifndef __MINGW32__
10  #include <pwd.h>
11  #include <grp.h>
12  #endif
13  #include <sys/types.h>
14  #include <sys/stat.h>
15  #include "utils.h"
16  #ifdef HAVE_SETRLIMIT
17  #include <sys/time.h>
18  #include <sys/resource.h>
19  #endif
20  #define INT_DIGITS 19           &bsol;* enough for 64 bit integer */
21  #ifdef LIB_ONLY
22  FILE *logfile;
23  #endif
24  #ifdef HAS_SYSLOG
25  int use_syslog = 0;
26  #endif
27  #ifndef __MINGW32__
28  void
29  ERROR(const char *s)
30  {
31      char *msg = strerror(errno);
32      LOGE("%s: %s", s, msg);
33  }
34  #endif
35  int use_tty = 1;
36  char *
37  ss_itoa(int i)
38  {
39      static char buf[INT_DIGITS + 2];
40      char *p = buf + INT_DIGITS + 1;     &bsol;* points to terminating '\0' */
41      if (i >= 0) {
42          do {
43              *--p = '0' + (i % 10);
44              i   /= 10;
45          } while (i != 0);
46          return p;
47      } else {                     &bsol;* i < 0 */
48          do {
49              *--p = '0' - (i % 10);
50              i   /= 10;
51          } while (i != 0);
52          *--p = '-';
53      }
54      return p;
55  }
56  int
57  ss_isnumeric(const char *s) {
58      if (!s || !*s)
59          return 0;
60      while (isdigit(*s))
61          ++s;
62      return *s == '\0';
63  }
64  int
65  run_as(const char *user)
66  {
67  #ifndef __MINGW32__
68      if (user[0]) {
69          long uid = -1;
70          if (ss_isnumeric(user)) {
71              errno = 0;
72              char *endptr;
73              uid = strtol(user, &endptr, 10);
74              if (errno || endptr == user)
75                  uid = -1;
76          }
77  #ifdef HAVE_GETPWNAM_R
78          struct passwd pwdbuf, *pwd;
79          memset(&pwdbuf, 0, sizeof(struct passwd));
80          size_t buflen;
81          int err;
82          for (buflen = 128;; buflen *= 2) {
83              char buf[buflen];  &bsol;* variable length array */
84              err = uid >= 0 ? getpwuid_r((uid_t)uid, &pwdbuf, buf, buflen, &pwd)
85                  : getpwnam_r(user, &pwdbuf, buf, buflen, &pwd);
86              if (err == 0 && pwd) {
<span onclick='openModal()' class='match'>87                  if (setgid(pwd->pw_gid) != 0) {
88                      LOGE(
89                          "Could not change group id to that of run_as user '%s': %s",
90                          pwd->pw_name, strerror(errno));
91                      return 0;
92                  }
93                  if (initgroups(pwd->pw_name, pwd->pw_gid) == -1) {
94                      LOGE("Could not change supplementary groups for user '%s'.", pwd->pw_name);
95                      return 0;
96                  }
</span>97                  if (setuid(pwd->pw_uid) != 0) {
98                      LOGE(
99                          "Could not change user id to that of run_as user '%s': %s",
100                          pwd->pw_name, strerror(errno));
101                      return 0;
102                  }
103                  break;
104              } else if (err != ERANGE) {
105                  if (err) {
106                      LOGE("run_as user '%s' could not be found: %s", user,
107                              strerror(err));
108                  } else {
109                      LOGE("run_as user '%s' could not be found.", user);
110                  }
111                  return 0;
112              } else if (buflen >= 16 * 1024) {
113                  LOGE(
114                      "getpwnam_r() requires more than %u bytes of buffer space.",
115                      (unsigned)buflen);
116                  return 0;
117              }
118          }
119  #else
120          struct passwd *pwd;
121          if (!(pwd = uid >=0 ? getpwuid((uid_t)uid) : getpwnam(user))) {
122              LOGE("run_as user %s could not be found.", user);
123              return 0;
124          }
125          if (setgid(pwd->pw_gid) != 0) {
126              LOGE("Could not change group id to that of run_as user '%s': %s",
127                   pwd->pw_name, strerror(errno));
128              return 0;
129          }
130          if (initgroups(pwd->pw_name, pwd->pw_gid) == -1) {
131              LOGE("Could not change supplementary groups for user '%s'.", pwd->pw_name);
132              return 0;
133          }
134          if (setuid(pwd->pw_uid) != 0) {
135              LOGE("Could not change user id to that of run_as user '%s': %s",
136                   pwd->pw_name, strerror(errno));
137              return 0;
138          }
139  #endif
140      }
141  #endif 
142      return 1;
143  }
144  char *
145  ss_strndup(const char *s, size_t n)
146  {
147      size_t len = strlen(s);
148      char *ret;
149      if (len <= n) {
150          return strdup(s);
151      }
152      ret = ss_malloc(n + 1);
153      strncpy(ret, s, n);
154      ret[n] = '\0';
155      return ret;
156  }
157  void
158  FATAL(const char *msg)
159  {
160      LOGE("%s", msg);
161      exit(-1);
162  }
163  void *
164  ss_malloc(size_t size)
165  {
166      void *tmp = malloc(size);
167      if (tmp == NULL)
168          exit(EXIT_FAILURE);
169      return tmp;
170  }
171  void *
172  ss_realloc(void *ptr, size_t new_size)
173  {
174      void *new = realloc(ptr, new_size);
175      if (new == NULL) {
176          free(ptr);
177          ptr = NULL;
178          exit(EXIT_FAILURE);
179      }
180      return new;
181  }
182  void
183  usage()
184  {
185      printf("\n");
186      printf("shadowsocks-libev %s with %s\n\n", VERSION, USING_CRYPTO);
187      printf(
188          "  maintained by Max Lv <max.c.lv@gmail.com> and Linus Yang <laokongzi@gmail.com>\n\n");
189      printf("  usage:\n\n");
190  #ifdef MODULE_LOCAL
191      printf("    ss-local\n");
192  #elif MODULE_REMOTE
193      printf("    ss-server\n");
194  #elif MODULE_TUNNEL
195      printf("    ss-tunnel\n");
196  #elif MODULE_REDIR
197      printf("    ss-redir\n");
198  #elif MODULE_MANAGER
199      printf("    ss-manager\n");
200  #endif
201      printf("\n");
202      printf(
203          "       -s <server_host>           Host name or IP address of your remote server.\n");
204      printf(
205          "       -p <server_port>           Port number of your remote server.\n");
206      printf(
207          "       -l <local_port>            Port number of your local server.\n");
208      printf(
209          "       -k <password>              Password of your remote server.\n");
210      printf(
211          "       -m <encrypt_method>        Encrypt method: table, rc4, rc4-md5,\n");
212      printf(
213          "                                  aes-128-cfb, aes-192-cfb, aes-256-cfb,\n");
214      printf(
215          "                                  aes-128-ctr, aes-192-ctr, aes-256-ctr,\n");
216      printf(
217          "                                  bf-cfb, camellia-128-cfb, camellia-192-cfb,\n");
218      printf(
219          "                                  camellia-256-cfb, cast5-cfb, des-cfb,\n");
220      printf(
221          "                                  idea-cfb, rc2-cfb, seed-cfb, salsa20,\n");
222      printf(
223          "                                  chacha20 and chacha20-ietf.\n");
224      printf(
225          "                                  The default cipher is rc4-md5.\n");
226      printf("\n");
227      printf(
228          "       [-a <user>]                Run as another user.\n");
229      printf(
230          "       [-f <pid_file>]            The file path to store pid.\n");
231      printf(
232          "       [-t <timeout>]             Socket timeout in seconds.\n");
233      printf(
234          "       [-c <config_file>]         The path to config file.\n");
235  #ifdef HAVE_SETRLIMIT
236      printf(
237          "       [-n <number>]              Max number of open files.\n");
238  #endif
239  #ifndef MODULE_REDIR
240      printf(
241          "       [-i <interface>]           Network interface to bind.\n");
242  #endif
243      printf(
244          "       [-b <local_address>]       Local address to bind.\n");
245      printf("\n");
246      printf(
247          "       [-u]                       Enable UDP relay.\n");
248  #ifdef MODULE_REDIR
249      printf(
250          "                                  TPROXY is required in redir mode.\n");
251  #endif
252      printf(
253          "       [-U]                       Enable UDP relay and disable TCP relay.\n");
254      printf(
255          "       [-A]                       Enable onetime authentication.\n");
256  #ifdef MODULE_REMOTE
257      printf(
258          "       [-6]                       Resovle hostname to IPv6 address first.\n");
259  #endif
260      printf("\n");
261  #ifdef MODULE_TUNNEL
262      printf(
263          "       [-L <addr>:<port>]         Destination server address and port\n");
264      printf(
265          "                                  for local port forwarding.\n");
266  #endif
267  #ifdef MODULE_REMOTE
268      printf(
269          "       [-d <addr>]                Name servers for internal DNS resolver.\n");
270  #endif
271  #if defined(MODULE_REMOTE) || defined(MODULE_LOCAL)
272      printf(
273          "       [--fast-open]              Enable TCP fast open.\n");
274      printf(
275          "                                  with Linux kernel > 3.7.0.\n");
276      printf(
277          "       [--acl <acl_file>]         Path to ACL (Access Control List).\n");
278  #endif
279  #if defined(MODULE_REMOTE) || defined(MODULE_MANAGER)
280      printf(
281          "       [--manager-address <addr>] UNIX domain socket address.\n");
282  #endif
283  #ifdef MODULE_MANAGER
284      printf(
285          "       [--executable <path>]      Path to the executable of ss-server.\n");
286  #endif
287      printf(
288          "       [--mtu <MTU>]              MTU of your network interface.\n");
289  #ifdef __linux__
290      printf(
291          "       [--mptcp]                  Enable Multipath TCP on MPTCP Kernel.\n");
292  #ifdef MODULE_REMOTE
293      printf(
294          "       [--firewall]               Setup firewall rules for auto blocking.\n");
295  #endif
296  #endif
297      printf("\n");
298      printf(
299          "       [-v]                       Verbose mode.\n");
300      printf(
301          "       [-h, --help]               Print this message.\n");
302      printf("\n");
303  }
304  void
305  daemonize(const char *path)
306  {
307  #ifndef __MINGW32__
308      pid_t pid, sid;
309      pid = fork();
310      if (pid < 0) {
311          exit(EXIT_FAILURE);
312      }
313      if (pid > 0) {
314          FILE *file = fopen(path, "w");
315          if (file == NULL) {
316              FATAL("Invalid pid file\n");
317          }
318          fprintf(file, "%d", (int)pid);
319          fclose(file);
320          exit(EXIT_SUCCESS);
321      }
322      umask(0);
323      sid = setsid();
324      if (sid < 0) {
325          exit(EXIT_FAILURE);
326      }
327      if ((chdir("/")) < 0) {
328          exit(EXIT_FAILURE);
329      }
330      close(STDIN_FILENO);
331      close(STDOUT_FILENO);
332      close(STDERR_FILENO);
333  #endif
334  }
335  #ifdef HAVE_SETRLIMIT
336  int
337  set_nofile(int nofile)
338  {
339      struct rlimit limit = { nofile, nofile }; &bsol;* set both soft and hard limit */
340      if (nofile <= 0) {
341          FATAL("nofile must be greater than 0\n");
342      }
343      if (setrlimit(RLIMIT_NOFILE, &limit) < 0) {
344          if (errno == EPERM) {
345              LOGE(
346                  "insufficient permission to change NOFILE, not starting as root?");
347              return -1;
348          } else if (errno == EINVAL) {
349              LOGE("invalid nofile, decrease nofile and try again");
350              return -1;
351          } else {
352              LOGE("setrlimit failed: %s", strerror(errno));
353              return -1;
354          }
355      }
356      return 0;
357  }
358  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ccm_process.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from small-MDEwOlJlcG9zaXRvcnkyNTY3NjMxNjk=-flat-utils.c</div>
                </div>
                <div class="column column_space"><pre><code>12     if (ccm->aadlen != ccm->current_aadlen) {
13        return CRYPT_ERROR;
14     }
15     if (ccm->ptlen < ccm->current_ptlen + ptlen) {
16        return CRYPT_ERROR;
17     }
</pre></code></div>
                <div class="column column_space"><pre><code>87                  if (setgid(pwd->pw_gid) != 0) {
88                      LOGE(
89                          "Could not change group id to that of run_as user '%s': %s",
90                          pwd->pw_name, strerror(errno));
91                      return 0;
92                  }
93                  if (initgroups(pwd->pw_name, pwd->pw_gid) == -1) {
94                      LOGE("Could not change supplementary groups for user '%s'.", pwd->pw_name);
95                      return 0;
96                  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    