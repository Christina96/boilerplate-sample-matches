
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.224191866527633%, Tokens: 9</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-SFMT_1.c</h3>
            <pre><code>1  #define SFMT_C_
2  #include "test/jemalloc_test.h"
3  #include "test/SFMT-params.h"
4  #if defined(JEMALLOC_BIG_ENDIAN) && !defined(BIG_ENDIAN64)
5  #define BIG_ENDIAN64 1
6  #endif
7  #if defined(__BIG_ENDIAN__) && !defined(__amd64) && !defined(BIG_ENDIAN64)
8  #define BIG_ENDIAN64 1
9  #endif
10  #if defined(HAVE_ALTIVEC) && !defined(BIG_ENDIAN64)
11  #define BIG_ENDIAN64 1
12  #endif
13  #if defined(ONLY64) && !defined(BIG_ENDIAN64)
14    #if defined(__GNUC__)
15      #error "-DONLY64 must be specified with -DBIG_ENDIAN64"
16    #endif
17  #undef ONLY64
18  #endif
19  #if defined(HAVE_ALTIVEC)
20  union W128_T {
21      vector unsigned int s;
22      uint32_t u[4];
23  };
24  typedef union W128_T w128_t;
25  #elif defined(HAVE_SSE2)
26  union W128_T {
27      __m128i si;
28      uint32_t u[4];
29  };
30  typedef union W128_T w128_t;
31  #else
32  struct W128_T {
33      uint32_t u[4];
34  };
35  typedef struct W128_T w128_t;
36  #endif
37  struct sfmt_s {
38      w128_t sfmt[N];
39      int idx;
40      int initialized;
41  };
42  static uint32_t parity[4] = {PARITY1, PARITY2, PARITY3, PARITY4};
43  static inline int idxof(int i);
44  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
45  static inline void rshift128(w128_t *out,  w128_t const *in, int shift);
46  static inline void lshift128(w128_t *out,  w128_t const *in, int shift);
47  #endif
48  static inline void gen_rand_all(sfmt_t *ctx);
49  static inline void gen_rand_array(sfmt_t *ctx, w128_t *array, int size);
50  static inline uint32_t func1(uint32_t x);
51  static inline uint32_t func2(uint32_t x);
52  static void period_certification(sfmt_t *ctx);
53  #if defined(BIG_ENDIAN64) && !defined(ONLY64)
54  static inline void swap(w128_t *array, int size);
55  #endif
56  #if defined(HAVE_ALTIVEC)
57    #include "test/SFMT-alti.h"
58  #elif defined(HAVE_SSE2)
59    #include "test/SFMT-sse2.h"
60  #endif
61  #ifdef ONLY64
62  static inline int idxof(int i) {
63      return i ^ 1;
64  }
65  #else
66  static inline int idxof(int i) {
67      return i;
68  }
69  #endif
70  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
71  #ifdef ONLY64
72  static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
73      uint64_t th, tl, oh, ol;
74      th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
75      tl = ((uint64_t)in->u[0] << 32) | ((uint64_t)in->u[1]);
76      oh = th >> (shift * 8);
77      ol = tl >> (shift * 8);
78      ol |= th << (64 - shift * 8);
79      out->u[0] = (uint32_t)(ol >> 32);
80      out->u[1] = (uint32_t)ol;
81      out->u[2] = (uint32_t)(oh >> 32);
82      out->u[3] = (uint32_t)oh;
83  }
84  #else
85  static inline void rshift128(w128_t *out, w128_t const *in, int shift) {
86      uint64_t th, tl, oh, ol;
87      th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
88      tl = ((uint64_t)in->u[1] << 32) | ((uint64_t)in->u[0]);
89      oh = th >> (shift * 8);
90      ol = tl >> (shift * 8);
91      ol |= th << (64 - shift * 8);
92      out->u[1] = (uint32_t)(ol >> 32);
93      out->u[0] = (uint32_t)ol;
94      out->u[3] = (uint32_t)(oh >> 32);
95      out->u[2] = (uint32_t)oh;
96  }
97  #endif
98  #ifdef ONLY64
99  static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
100      uint64_t th, tl, oh, ol;
101      th = ((uint64_t)in->u[2] << 32) | ((uint64_t)in->u[3]);
102      tl = ((uint64_t)in->u[0] << 32) | ((uint64_t)in->u[1]);
103      oh = th << (shift * 8);
104      ol = tl << (shift * 8);
105      oh |= tl >> (64 - shift * 8);
106      out->u[0] = (uint32_t)(ol >> 32);
107      out->u[1] = (uint32_t)ol;
108      out->u[2] = (uint32_t)(oh >> 32);
109      out->u[3] = (uint32_t)oh;
110  }
111  #else
112  static inline void lshift128(w128_t *out, w128_t const *in, int shift) {
113      uint64_t th, tl, oh, ol;
114      th = ((uint64_t)in->u[3] << 32) | ((uint64_t)in->u[2]);
115      tl = ((uint64_t)in->u[1] << 32) | ((uint64_t)in->u[0]);
116      oh = th << (shift * 8);
117      ol = tl << (shift * 8);
118      oh |= tl >> (64 - shift * 8);
119      out->u[1] = (uint32_t)(ol >> 32);
120      out->u[0] = (uint32_t)ol;
121      out->u[3] = (uint32_t)(oh >> 32);
122      out->u[2] = (uint32_t)oh;
123  }
124  #endif
125  #endif
126  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
127  #ifdef ONLY64
128  static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
129  				w128_t *d) {
130      w128_t x;
131      w128_t y;
132      lshift128(&x, a, SL2);
133      rshift128(&y, c, SR2);
134      r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> SR1) & MSK2) ^ y.u[0]
135  	^ (d->u[0] << SL1);
136      r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> SR1) & MSK1) ^ y.u[1]
137  	^ (d->u[1] << SL1);
138      r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> SR1) & MSK4) ^ y.u[2]
139  	^ (d->u[2] << SL1);
140      r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK3) ^ y.u[3]
141  	^ (d->u[3] << SL1);
142  }
143  #else
144  static inline void do_recursion(w128_t *r, w128_t *a, w128_t *b, w128_t *c,
145  				w128_t *d) {
146      w128_t x;
147      w128_t y;
148      lshift128(&x, a, SL2);
149      rshift128(&y, c, SR2);
150      r->u[0] = a->u[0] ^ x.u[0] ^ ((b->u[0] >> SR1) & MSK1) ^ y.u[0]
151  	^ (d->u[0] << SL1);
152      r->u[1] = a->u[1] ^ x.u[1] ^ ((b->u[1] >> SR1) & MSK2) ^ y.u[1]
153  	^ (d->u[1] << SL1);
154      r->u[2] = a->u[2] ^ x.u[2] ^ ((b->u[2] >> SR1) & MSK3) ^ y.u[2]
155  	^ (d->u[2] << SL1);
156      r->u[3] = a->u[3] ^ x.u[3] ^ ((b->u[3] >> SR1) & MSK4) ^ y.u[3]
157  	^ (d->u[3] << SL1);
158  }
159  #endif
160  #endif
161  #if (!defined(HAVE_ALTIVEC)) && (!defined(HAVE_SSE2))
162  static inline void gen_rand_all(sfmt_t *ctx) {
163      int i;
164      w128_t *r1, *r2;
165      r1 = &ctx->sfmt[N - 2];
166      r2 = &ctx->sfmt[N - 1];
167      for (i = 0; i < N - POS1; i++) {
168  	do_recursion(&ctx->sfmt[i], &ctx->sfmt[i], &ctx->sfmt[i + POS1], r1,
169  	  r2);
170  	r1 = r2;
171  	r2 = &ctx->sfmt[i];
172      }
173      for (; i < N; i++) {
174  	do_recursion(&ctx->sfmt[i], &ctx->sfmt[i], &ctx->sfmt[i + POS1 - N], r1,
175  	  r2);
176  	r1 = r2;
177  	r2 = &ctx->sfmt[i];
178      }
179  }
180  static inline void gen_rand_array(sfmt_t *ctx, w128_t *array, int size) {
181      int i, j;
182      w128_t *r1, *r2;
183      r1 = &ctx->sfmt[N - 2];
184      r2 = &ctx->sfmt[N - 1];
185      for (i = 0; i < N - POS1; i++) {
186  	do_recursion(&array[i], &ctx->sfmt[i], &ctx->sfmt[i + POS1], r1, r2);
187  	r1 = r2;
188  	r2 = &array[i];
189      }
190      for (; i < N; i++) {
191  	do_recursion(&array[i], &ctx->sfmt[i], &array[i + POS1 - N], r1, r2);
192  	r1 = r2;
193  	r2 = &array[i];
194      }
195      for (; i < size - N; i++) {
196  	do_recursion(&array[i], &array[i - N], &array[i + POS1 - N], r1, r2);
197  	r1 = r2;
198  	r2 = &array[i];
199      }
200      for (j = 0; j < 2 * N - size; j++) {
201  	ctx->sfmt[j] = array[j + size - N];
202      }
203      for (; i < size; i++, j++) {
204  	do_recursion(&array[i], &array[i - N], &array[i + POS1 - N], r1, r2);
205  	r1 = r2;
206  	r2 = &array[i];
207  	ctx->sfmt[j] = array[i];
208      }
209  }
210  #endif
211  #if defined(BIG_ENDIAN64) && !defined(ONLY64) && !defined(HAVE_ALTIVEC)
212  static inline void swap(w128_t *array, int size) {
213      int i;
214      uint32_t x, y;
215      for (i = 0; i < size; i++) {
216  	x = array[i].u[0];
217  	y = array[i].u[2];
218  	array[i].u[0] = array[i].u[1];
219  	array[i].u[2] = array[i].u[3];
220  	array[i].u[1] = x;
221  	array[i].u[3] = y;
222      }
223  }
224  #endif
225  static uint32_t func1(uint32_t x) {
226      return (x ^ (x >> 27)) * (uint32_t)1664525UL;
227  }
228  static uint32_t func2(uint32_t x) {
229      return (x ^ (x >> 27)) * (uint32_t)1566083941UL;
230  }
231  static void period_certification(sfmt_t *ctx) {
232      int inner = 0;
233      int i, j;
234      uint32_t work;
235      uint32_t *psfmt32 = &ctx->sfmt[0].u[0];
236      for (i = 0; i < 4; i++)
237  	inner ^= psfmt32[idxof(i)] & parity[i];
238      for (i = 16; i > 0; i >>= 1)
239  	inner ^= inner >> i;
240      inner &= 1;
241      if (inner == 1) {
242  	return;
243      }
244      for (i = 0; i < 4; i++) {
245  	work = 1;
246  	for (j = 0; j < 32; j++) {
247  	    if ((work & parity[i]) != 0) {
248  		psfmt32[idxof(i)] ^= work;
249  		return;
250  	    }
251  	    work = work << 1;
252  	}
253      }
254  }
255  const char *get_idstring(void) {
256      return IDSTR;
257  }
258  int get_min_array_size32(void) {
259      return N32;
260  }
261  int get_min_array_size64(void) {
262      return N64;
263  }
264  #ifndef ONLY64
265  uint32_t gen_rand32(sfmt_t *ctx) {
266      uint32_t r;
267      uint32_t *psfmt32 = &ctx->sfmt[0].u[0];
268      assert(ctx->initialized);
269      if (ctx->idx >= N32) {
270  	gen_rand_all(ctx);
271  	ctx->idx = 0;
272      }
273      r = psfmt32[ctx->idx++];
274      return r;
275  }
276  uint32_t gen_rand32_range(sfmt_t *ctx, uint32_t limit) {
277      uint32_t ret, above;
278      above = 0xffffffffU - (0xffffffffU % limit);
279      while (1) {
280  	ret = gen_rand32(ctx);
281  	if (ret < above) {
282  	    ret %= limit;
283  	    break;
284  	}
285      }
286      return ret;
287  }
288  #endif
289  uint64_t gen_rand64(sfmt_t *ctx) {
290  #if defined(BIG_ENDIAN64) && !defined(ONLY64)
291      uint32_t r1, r2;
292      uint32_t *psfmt32 = &ctx->sfmt[0].u[0];
293  #else
294      uint64_t r;
295      uint64_t *psfmt64 = (uint64_t *)&ctx->sfmt[0].u[0];
296  #endif
297      assert(ctx->initialized);
298      assert(ctx->idx % 2 == 0);
299      if (ctx->idx >= N32) {
300  	gen_rand_all(ctx);
301  	ctx->idx = 0;
302      }
303  #if defined(BIG_ENDIAN64) && !defined(ONLY64)
304      r1 = psfmt32[ctx->idx];
305      r2 = psfmt32[ctx->idx + 1];
306      ctx->idx += 2;
307      return ((uint64_t)r2 << 32) | r1;
308  #else
309      r = psfmt64[ctx->idx / 2];
310      ctx->idx += 2;
311      return r;
312  #endif
313  }
314  uint64_t gen_rand64_range(sfmt_t *ctx, uint64_t limit) {
315      uint64_t ret, above;
316      above = KQU(0xffffffffffffffff) - (KQU(0xffffffffffffffff) % limit);
317      while (1) {
318  	ret = gen_rand64(ctx);
319  	if (ret < above) {
320  	    ret %= limit;
321  	    break;
322  	}
323      }
324      return ret;
325  }
326  #ifndef ONLY64
327  void fill_array32(sfmt_t *ctx, uint32_t *array, int size) {
328      assert(ctx->initialized);
329      assert(ctx->idx == N32);
330      assert(size % 4 == 0);
331      assert(size >= N32);
332      gen_rand_array(ctx, (w128_t *)array, size / 4);
333      ctx->idx = N32;
334  }
335  #endif
336  void fill_array64(sfmt_t *ctx, uint64_t *array, int size) {
337      assert(ctx->initialized);
338      assert(ctx->idx == N32);
339      assert(size % 2 == 0);
340      assert(size >= N64);
341      gen_rand_array(ctx, (w128_t *)array, size / 2);
342      ctx->idx = N32;
343  #if defined(BIG_ENDIAN64) && !defined(ONLY64)
344      swap((w128_t *)array, size /2);
345  #endif
346  }
347  sfmt_t *init_gen_rand(uint32_t seed) {
348      void *p;
349      sfmt_t *ctx;
350      int i;
351      uint32_t *psfmt32;
352      if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {
353  	return NULL;
354      }
355      ctx = (sfmt_t *)p;
356      psfmt32 = &ctx->sfmt[0].u[0];
357      psfmt32[idxof(0)] = seed;
358      for (i = 1; i < N32; i++) {
359  	psfmt32[idxof(i)] = 1812433253UL * (psfmt32[idxof(i - 1)]
360  					    ^ (psfmt32[idxof(i - 1)] >> 30))
361  	    + i;
362      }
363      ctx->idx = N32;
364      period_certification(ctx);
365      ctx->initialized = 1;
366      return ctx;
367  }
368  sfmt_t *init_by_array(uint32_t *init_key, int key_length) {
369      void *p;
370      sfmt_t *ctx;
371      int i, j, count;
372      uint32_t r;
373      int lag;
374      int mid;
375      int size = N * 4;
376      uint32_t *psfmt32;
377      if (posix_memalign(&p, sizeof(w128_t), sizeof(sfmt_t)) != 0) {
378  	return NULL;
379      }
380      ctx = (sfmt_t *)p;
381      psfmt32 = &ctx->sfmt[0].u[0];
382      if (size >= 623) {
383  	lag = 11;
384      } else if (size >= 68) {
385  	lag = 7;
386      } else if (size >= 39) {
387  	lag = 5;
388      } else {
389  	lag = 3;
390      }
391      mid = (size - lag) / 2;
392      memset(ctx->sfmt, 0x8b, sizeof(ctx->sfmt));
393      if (key_length + 1 > N32) {
394  	count = key_length + 1;
395      } else {
396  	count = N32;
397      }
398      r = func1(psfmt32[idxof(0)] ^ psfmt32[idxof(mid)]
399  	      ^ psfmt32[idxof(N32 - 1)]);
400      psfmt32[idxof(mid)] += r;
401      r += key_length;
402      psfmt32[idxof(mid + lag)] += r;
403      psfmt32[idxof(0)] = r;
404      count--;
405      for (i = 1, j = 0; (j < count) && (j < key_length); j++) {
406  	r = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % N32)]
407  		  ^ psfmt32[idxof((i + N32 - 1) % N32)]);
408  	psfmt32[idxof((i + mid) % N32)] += r;
409  	r += init_key[j] + i;
410  	psfmt32[idxof((i + mid + lag) % N32)] += r;
411  	psfmt32[idxof(i)] = r;
412  	i = (i + 1) % N32;
413      }
414      for (; j < count; j++) {
415  	r = func1(psfmt32[idxof(i)] ^ psfmt32[idxof((i + mid) % N32)]
416  		  ^ psfmt32[idxof((i + N32 - 1) % N32)]);
417  	psfmt32[idxof((i + mid) % N32)] += r;
418  	r += i;
419  	psfmt32[idxof((i + mid + lag) % N32)] += r;
420  	psfmt32[idxof(i)] = r;
421  	i = (i + 1) % N32;
422      }
<span onclick='openModal()' class='match'>423      for (j = 0; j < N32; j++) {
424  	r = func2(psfmt32[idxof(i)] + psfmt32[idxof((i + mid) % N32)]
425  		  + psfmt32[idxof((i + N32 - 1) % N32)]);
426  	psfmt32[idxof((i + mid) % N32)] ^= r;
427  	r -= i;
428  	psfmt32[idxof((i + mid + lag) % N32)] ^= r;
429  	psfmt32[idxof(i)] = r;
</span>430  	i = (i + 1) % N32;
431      }
432      ctx->idx = N32;
433      period_certification(ctx);
434      ctx->initialized = 1;
435      return ctx;
436  }
437  void fini_gen_rand(sfmt_t *ctx) {
438      assert(ctx != NULL);
439      ctx->initialized = 0;
440      free(ctx);
441  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-aes.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_RIJNDAEL
3  #ifndef ENCRYPT_ONLY
4  #define SETUP    rijndael_setup
5  #define ECB_ENC  rijndael_ecb_encrypt
6  #define ECB_DEC  rijndael_ecb_decrypt
7  #define ECB_DONE rijndael_done
8  #define ECB_TEST rijndael_test
9  #define ECB_KS   rijndael_keysize
10  const struct ltc_cipher_descriptor rijndael_desc =
11  {
12      "rijndael",
13      6,
14      16, 32, 16, 10,
15      SETUP, ECB_ENC, ECB_DEC, ECB_TEST, ECB_DONE, ECB_KS,
16      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
17  };
18  const struct ltc_cipher_descriptor aes_desc =
19  {
20      "aes",
21      6,
22      16, 32, 16, 10,
23      SETUP, ECB_ENC, ECB_DEC, ECB_TEST, ECB_DONE, ECB_KS,
24      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
25  };
26  #else
27  #define SETUP    rijndael_enc_setup
28  #define ECB_ENC  rijndael_enc_ecb_encrypt
29  #define ECB_KS   rijndael_enc_keysize
30  #define ECB_DONE rijndael_enc_done
31  const struct ltc_cipher_descriptor rijndael_enc_desc =
32  {
33      "rijndael",
34      6,
35      16, 32, 16, 10,
36      SETUP, ECB_ENC, NULL, NULL, ECB_DONE, ECB_KS,
37      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
38  };
39  const struct ltc_cipher_descriptor aes_enc_desc =
40  {
41      "aes",
42      6,
43      16, 32, 16, 10,
44      SETUP, ECB_ENC, NULL, NULL, ECB_DONE, ECB_KS,
45      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
46  };
47  #endif
48  #define LTC_AES_TAB_C
49  #include "aes_tab.c"
50  static ulong32 setup_mix(ulong32 temp)
51  {
52     return (Te4_3[LTC_BYTE(temp, 2)]) ^
53            (Te4_2[LTC_BYTE(temp, 1)]) ^
54            (Te4_1[LTC_BYTE(temp, 0)]) ^
55            (Te4_0[LTC_BYTE(temp, 3)]);
56  }
57  #ifndef ENCRYPT_ONLY
58  #ifdef LTC_SMALL_CODE
59  static ulong32 setup_mix2(ulong32 temp)
60  {
61     return Td0(255 & Te4[LTC_BYTE(temp, 3)]) ^
62            Td1(255 & Te4[LTC_BYTE(temp, 2)]) ^
63            Td2(255 & Te4[LTC_BYTE(temp, 1)]) ^
64            Td3(255 & Te4[LTC_BYTE(temp, 0)]);
65  }
66  #endif
67  #endif
68  int SETUP(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
69  {
70      int i;
71      ulong32 temp, *rk;
72  #ifndef ENCRYPT_ONLY
73      ulong32 *rrk;
74  #endif
75      LTC_ARGCHK(key  != NULL);
76      LTC_ARGCHK(skey != NULL);
77      if (keylen != 16 && keylen != 24 && keylen != 32) {
78         return CRYPT_INVALID_KEYSIZE;
79      }
80      if (num_rounds != 0 && num_rounds != (10 + ((keylen/8)-2)*2)) {
81         return CRYPT_INVALID_ROUNDS;
82      }
83      skey->rijndael.Nr = 10 + ((keylen/8)-2)*2;
84      i                 = 0;
85      rk                = skey->rijndael.eK;
86      LOAD32H(rk[0], key     );
87      LOAD32H(rk[1], key +  4);
88      LOAD32H(rk[2], key +  8);
89      LOAD32H(rk[3], key + 12);
90      if (keylen == 16) {
91          for (;;) {
92              temp  = rk[3];
93              rk[4] = rk[0] ^ setup_mix(temp) ^ rcon[i];
94              rk[5] = rk[1] ^ rk[4];
95              rk[6] = rk[2] ^ rk[5];
96              rk[7] = rk[3] ^ rk[6];
97              if (++i == 10) {
98                 break;
99              }
100              rk += 4;
101          }
102      } else if (keylen == 24) {
103          LOAD32H(rk[4], key + 16);
104          LOAD32H(rk[5], key + 20);
105          for (;;) {
106          #ifdef _MSC_VER
107              temp = skey->rijndael.eK[rk - skey->rijndael.eK + 5];
108          #else
109              temp = rk[5];
110          #endif
111              rk[ 6] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
112              rk[ 7] = rk[ 1] ^ rk[ 6];
113              rk[ 8] = rk[ 2] ^ rk[ 7];
114              rk[ 9] = rk[ 3] ^ rk[ 8];
115              if (++i == 8) {
116                  break;
117              }
118              rk[10] = rk[ 4] ^ rk[ 9];
119              rk[11] = rk[ 5] ^ rk[10];
120              rk += 6;
121          }
122      } else if (keylen == 32) {
123          LOAD32H(rk[4], key + 16);
124          LOAD32H(rk[5], key + 20);
125          LOAD32H(rk[6], key + 24);
126          LOAD32H(rk[7], key + 28);
127          for (;;) {
128          #ifdef _MSC_VER
129              temp = skey->rijndael.eK[rk - skey->rijndael.eK + 7];
130          #else
131              temp = rk[7];
132          #endif
133              rk[ 8] = rk[ 0] ^ setup_mix(temp) ^ rcon[i];
134              rk[ 9] = rk[ 1] ^ rk[ 8];
135              rk[10] = rk[ 2] ^ rk[ 9];
136              rk[11] = rk[ 3] ^ rk[10];
137              if (++i == 7) {
138                  break;
139              }
140              temp = rk[11];
141              rk[12] = rk[ 4] ^ setup_mix(RORc(temp, 8));
142              rk[13] = rk[ 5] ^ rk[12];
143              rk[14] = rk[ 6] ^ rk[13];
144              rk[15] = rk[ 7] ^ rk[14];
145              rk += 8;
146          }
147      } else {
148         return CRYPT_ERROR;
149      }
150  #ifndef ENCRYPT_ONLY
151      rk   = skey->rijndael.dK;
152      rrk  = skey->rijndael.eK + (28 + keylen) - 4;
153      *rk++ = *rrk++;
154      *rk++ = *rrk++;
155      *rk++ = *rrk++;
156      *rk   = *rrk;
157      rk -= 3; rrk -= 3;
158      for (i = 1; i < skey->rijndael.Nr; i++) {
159          rrk -= 4;
160          rk  += 4;
161      #ifdef LTC_SMALL_CODE
162          temp = rrk[0];
163          rk[0] = setup_mix2(temp);
164          temp = rrk[1];
165          rk[1] = setup_mix2(temp);
166          temp = rrk[2];
167          rk[2] = setup_mix2(temp);
168          temp = rrk[3];
169          rk[3] = setup_mix2(temp);
170       #else
171          temp = rrk[0];
172          rk[0] =
173              Tks0[LTC_BYTE(temp, 3)] ^
174              Tks1[LTC_BYTE(temp, 2)] ^
175              Tks2[LTC_BYTE(temp, 1)] ^
176              Tks3[LTC_BYTE(temp, 0)];
177          temp = rrk[1];
178          rk[1] =
179              Tks0[LTC_BYTE(temp, 3)] ^
180              Tks1[LTC_BYTE(temp, 2)] ^
181              Tks2[LTC_BYTE(temp, 1)] ^
182              Tks3[LTC_BYTE(temp, 0)];
183          temp = rrk[2];
184          rk[2] =
185              Tks0[LTC_BYTE(temp, 3)] ^
186              Tks1[LTC_BYTE(temp, 2)] ^
187              Tks2[LTC_BYTE(temp, 1)] ^
188              Tks3[LTC_BYTE(temp, 0)];
189          temp = rrk[3];
190          rk[3] =
191              Tks0[LTC_BYTE(temp, 3)] ^
192              Tks1[LTC_BYTE(temp, 2)] ^
193              Tks2[LTC_BYTE(temp, 1)] ^
194              Tks3[LTC_BYTE(temp, 0)];
195        #endif
196      }
197      rrk -= 4;
198      rk  += 4;
199      *rk++ = *rrk++;
200      *rk++ = *rrk++;
201      *rk++ = *rrk++;
202      *rk   = *rrk;
203  #endif &bsol;* ENCRYPT_ONLY */
204      return CRYPT_OK;
205  }
206  #ifdef LTC_CLEAN_STACK
207  static int s_rijndael_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
208  #else
209  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
210  #endif
211  {
212      ulong32 s0, s1, s2, s3, t0, t1, t2, t3;
213      const ulong32 *rk;
214      int Nr, r;
215      LTC_ARGCHK(pt != NULL);
216      LTC_ARGCHK(ct != NULL);
217      LTC_ARGCHK(skey != NULL);
218      Nr = skey->rijndael.Nr;
219      if (Nr < 2 || Nr > 16)
220          return CRYPT_INVALID_ROUNDS;
221      rk = skey->rijndael.eK;
222      LOAD32H(s0, pt      ); s0 ^= rk[0];
223      LOAD32H(s1, pt  +  4); s1 ^= rk[1];
224      LOAD32H(s2, pt  +  8); s2 ^= rk[2];
225      LOAD32H(s3, pt  + 12); s3 ^= rk[3];
226  #ifdef LTC_SMALL_CODE
227      for (r = 0; ; r++) {
228          rk += 4;
229          t0 =
230              Te0(LTC_BYTE(s0, 3)) ^
231              Te1(LTC_BYTE(s1, 2)) ^
232              Te2(LTC_BYTE(s2, 1)) ^
233              Te3(LTC_BYTE(s3, 0)) ^
234              rk[0];
235          t1 =
236              Te0(LTC_BYTE(s1, 3)) ^
237              Te1(LTC_BYTE(s2, 2)) ^
238              Te2(LTC_BYTE(s3, 1)) ^
239              Te3(LTC_BYTE(s0, 0)) ^
240              rk[1];
241          t2 =
242              Te0(LTC_BYTE(s2, 3)) ^
243              Te1(LTC_BYTE(s3, 2)) ^
244              Te2(LTC_BYTE(s0, 1)) ^
245              Te3(LTC_BYTE(s1, 0)) ^
246              rk[2];
247          t3 =
248              Te0(LTC_BYTE(s3, 3)) ^
249              Te1(LTC_BYTE(s0, 2)) ^
250              Te2(LTC_BYTE(s1, 1)) ^
251              Te3(LTC_BYTE(s2, 0)) ^
252              rk[3];
253          if (r == Nr-2) {
254             break;
255          }
256          s0 = t0; s1 = t1; s2 = t2; s3 = t3;
257      }
258      rk += 4;
259  #else
260      r = Nr >> 1;
261      for (;;) {
262          t0 =
263              Te0(LTC_BYTE(s0, 3)) ^
264              Te1(LTC_BYTE(s1, 2)) ^
265              Te2(LTC_BYTE(s2, 1)) ^
266              Te3(LTC_BYTE(s3, 0)) ^
267              rk[4];
268          t1 =
269              Te0(LTC_BYTE(s1, 3)) ^
270              Te1(LTC_BYTE(s2, 2)) ^
271              Te2(LTC_BYTE(s3, 1)) ^
272              Te3(LTC_BYTE(s0, 0)) ^
273              rk[5];
274          t2 =
275              Te0(LTC_BYTE(s2, 3)) ^
276              Te1(LTC_BYTE(s3, 2)) ^
277              Te2(LTC_BYTE(s0, 1)) ^
278              Te3(LTC_BYTE(s1, 0)) ^
279              rk[6];
280          t3 =
281              Te0(LTC_BYTE(s3, 3)) ^
282              Te1(LTC_BYTE(s0, 2)) ^
283              Te2(LTC_BYTE(s1, 1)) ^
284              Te3(LTC_BYTE(s2, 0)) ^
285              rk[7];
286          rk += 8;
287          if (--r == 0) {
288              break;
289          }
290          s0 =
291              Te0(LTC_BYTE(t0, 3)) ^
292              Te1(LTC_BYTE(t1, 2)) ^
293              Te2(LTC_BYTE(t2, 1)) ^
294              Te3(LTC_BYTE(t3, 0)) ^
295              rk[0];
296          s1 =
297              Te0(LTC_BYTE(t1, 3)) ^
298              Te1(LTC_BYTE(t2, 2)) ^
299              Te2(LTC_BYTE(t3, 1)) ^
300              Te3(LTC_BYTE(t0, 0)) ^
301              rk[1];
302          s2 =
303              Te0(LTC_BYTE(t2, 3)) ^
304              Te1(LTC_BYTE(t3, 2)) ^
305              Te2(LTC_BYTE(t0, 1)) ^
306              Te3(LTC_BYTE(t1, 0)) ^
307              rk[2];
308          s3 =
309              Te0(LTC_BYTE(t3, 3)) ^
310              Te1(LTC_BYTE(t0, 2)) ^
311              Te2(LTC_BYTE(t1, 1)) ^
312              Te3(LTC_BYTE(t2, 0)) ^
313              rk[3];
314      }
315  #endif
316      s0 =
317          (Te4_3[LTC_BYTE(t0, 3)]) ^
318          (Te4_2[LTC_BYTE(t1, 2)]) ^
319          (Te4_1[LTC_BYTE(t2, 1)]) ^
320          (Te4_0[LTC_BYTE(t3, 0)]) ^
321          rk[0];
322      STORE32H(s0, ct);
323      s1 =
324          (Te4_3[LTC_BYTE(t1, 3)]) ^
325          (Te4_2[LTC_BYTE(t2, 2)]) ^
326          (Te4_1[LTC_BYTE(t3, 1)]) ^
327          (Te4_0[LTC_BYTE(t0, 0)]) ^
328          rk[1];
329      STORE32H(s1, ct+4);
330      s2 =
331          (Te4_3[LTC_BYTE(t2, 3)]) ^
332          (Te4_2[LTC_BYTE(t3, 2)]) ^
333          (Te4_1[LTC_BYTE(t0, 1)]) ^
334          (Te4_0[LTC_BYTE(t1, 0)]) ^
335          rk[2];
336      STORE32H(s2, ct+8);
337      s3 =
338          (Te4_3[LTC_BYTE(t3, 3)]) ^
339          (Te4_2[LTC_BYTE(t0, 2)]) ^
340          (Te4_1[LTC_BYTE(t1, 1)]) ^
341          (Te4_0[LTC_BYTE(t2, 0)]) ^
342          rk[3];
343      STORE32H(s3, ct+12);
344      return CRYPT_OK;
345  }
346  #ifdef LTC_CLEAN_STACK
347  int ECB_ENC(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
348  {
349     int err = s_rijndael_ecb_encrypt(pt, ct, skey);
350     burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
351     return err;
352  }
353  #endif
354  #ifndef ENCRYPT_ONLY
355  #ifdef LTC_CLEAN_STACK
356  static int s_rijndael_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
357  #else
358  int ECB_DEC(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
359  #endif
360  {
361      ulong32 s0, s1, s2, s3, t0, t1, t2, t3;
362      const ulong32 *rk;
363      int Nr, r;
364      LTC_ARGCHK(pt != NULL);
365      LTC_ARGCHK(ct != NULL);
366      LTC_ARGCHK(skey != NULL);
367      Nr = skey->rijndael.Nr;
368      if (Nr < 2 || Nr > 16)
369          return CRYPT_INVALID_ROUNDS;
370      rk = skey->rijndael.dK;
371      LOAD32H(s0, ct      ); s0 ^= rk[0];
372      LOAD32H(s1, ct  +  4); s1 ^= rk[1];
373      LOAD32H(s2, ct  +  8); s2 ^= rk[2];
374      LOAD32H(s3, ct  + 12); s3 ^= rk[3];
375  #ifdef LTC_SMALL_CODE
<span onclick='openModal()' class='match'>376      for (r = 0; ; r++) {
377          rk += 4;
378          t0 =
379              Td0(LTC_BYTE(s0, 3)) ^
380              Td1(LTC_BYTE(s3, 2)) ^
381              Td2(LTC_BYTE(s2, 1)) ^
382              Td3(LTC_BYTE(s1, 0)) ^
383              rk[0];
384          t1 =
385              Td0(LTC_BYTE(s1, 3)) ^
386              Td1(LTC_BYTE(s0, 2)) ^
387              Td2(LTC_BYTE(s3, 1)) ^
388              Td3(LTC_BYTE(s2, 0)) ^
389              rk[1];
390          t2 =
391              Td0(LTC_BYTE(s2, 3)) ^
392              Td1(LTC_BYTE(s1, 2)) ^
393              Td2(LTC_BYTE(s0, 1)) ^
394              Td3(LTC_BYTE(s3, 0)) ^
395              rk[2];
396          t3 =
</span>397              Td0(LTC_BYTE(s3, 3)) ^
398              Td1(LTC_BYTE(s2, 2)) ^
399              Td2(LTC_BYTE(s1, 1)) ^
400              Td3(LTC_BYTE(s0, 0)) ^
401              rk[3];
402          if (r == Nr-2) {
403             break;
404          }
405          s0 = t0; s1 = t1; s2 = t2; s3 = t3;
406      }
407      rk += 4;
408  #else
409      r = Nr >> 1;
410      for (;;) {
411          t0 =
412              Td0(LTC_BYTE(s0, 3)) ^
413              Td1(LTC_BYTE(s3, 2)) ^
414              Td2(LTC_BYTE(s2, 1)) ^
415              Td3(LTC_BYTE(s1, 0)) ^
416              rk[4];
417          t1 =
418              Td0(LTC_BYTE(s1, 3)) ^
419              Td1(LTC_BYTE(s0, 2)) ^
420              Td2(LTC_BYTE(s3, 1)) ^
421              Td3(LTC_BYTE(s2, 0)) ^
422              rk[5];
423          t2 =
424              Td0(LTC_BYTE(s2, 3)) ^
425              Td1(LTC_BYTE(s1, 2)) ^
426              Td2(LTC_BYTE(s0, 1)) ^
427              Td3(LTC_BYTE(s3, 0)) ^
428              rk[6];
429          t3 =
430              Td0(LTC_BYTE(s3, 3)) ^
431              Td1(LTC_BYTE(s2, 2)) ^
432              Td2(LTC_BYTE(s1, 1)) ^
433              Td3(LTC_BYTE(s0, 0)) ^
434              rk[7];
435          rk += 8;
436          if (--r == 0) {
437              break;
438          }
439          s0 =
440              Td0(LTC_BYTE(t0, 3)) ^
441              Td1(LTC_BYTE(t3, 2)) ^
442              Td2(LTC_BYTE(t2, 1)) ^
443              Td3(LTC_BYTE(t1, 0)) ^
444              rk[0];
445          s1 =
446              Td0(LTC_BYTE(t1, 3)) ^
447              Td1(LTC_BYTE(t0, 2)) ^
448              Td2(LTC_BYTE(t3, 1)) ^
449              Td3(LTC_BYTE(t2, 0)) ^
450              rk[1];
451          s2 =
452              Td0(LTC_BYTE(t2, 3)) ^
453              Td1(LTC_BYTE(t1, 2)) ^
454              Td2(LTC_BYTE(t0, 1)) ^
455              Td3(LTC_BYTE(t3, 0)) ^
456              rk[2];
457          s3 =
458              Td0(LTC_BYTE(t3, 3)) ^
459              Td1(LTC_BYTE(t2, 2)) ^
460              Td2(LTC_BYTE(t1, 1)) ^
461              Td3(LTC_BYTE(t0, 0)) ^
462              rk[3];
463      }
464  #endif
465      s0 =
466          (Td4[LTC_BYTE(t0, 3)] & 0xff000000) ^
467          (Td4[LTC_BYTE(t3, 2)] & 0x00ff0000) ^
468          (Td4[LTC_BYTE(t2, 1)] & 0x0000ff00) ^
469          (Td4[LTC_BYTE(t1, 0)] & 0x000000ff) ^
470          rk[0];
471      STORE32H(s0, pt);
472      s1 =
473          (Td4[LTC_BYTE(t1, 3)] & 0xff000000) ^
474          (Td4[LTC_BYTE(t0, 2)] & 0x00ff0000) ^
475          (Td4[LTC_BYTE(t3, 1)] & 0x0000ff00) ^
476          (Td4[LTC_BYTE(t2, 0)] & 0x000000ff) ^
477          rk[1];
478      STORE32H(s1, pt+4);
479      s2 =
480          (Td4[LTC_BYTE(t2, 3)] & 0xff000000) ^
481          (Td4[LTC_BYTE(t1, 2)] & 0x00ff0000) ^
482          (Td4[LTC_BYTE(t0, 1)] & 0x0000ff00) ^
483          (Td4[LTC_BYTE(t3, 0)] & 0x000000ff) ^
484          rk[2];
485      STORE32H(s2, pt+8);
486      s3 =
487          (Td4[LTC_BYTE(t3, 3)] & 0xff000000) ^
488          (Td4[LTC_BYTE(t2, 2)] & 0x00ff0000) ^
489          (Td4[LTC_BYTE(t1, 1)] & 0x0000ff00) ^
490          (Td4[LTC_BYTE(t0, 0)] & 0x000000ff) ^
491          rk[3];
492      STORE32H(s3, pt+12);
493      return CRYPT_OK;
494  }
495  #ifdef LTC_CLEAN_STACK
496  int ECB_DEC(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
497  {
498     int err = s_rijndael_ecb_decrypt(ct, pt, skey);
499     burn_stack(sizeof(unsigned long)*8 + sizeof(unsigned long*) + sizeof(int)*2);
500     return err;
501  }
502  #endif
503  int ECB_TEST(void)
504  {
505   #ifndef LTC_TEST
506      return CRYPT_NOP;
507   #else
508   int err;
509   static const struct {
510       int keylen;
511       unsigned char key[32], pt[16], ct[16];
512   } tests[] = {
513      { 16,
514        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
515          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
516        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
517          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
518        { 0x69, 0xc4, 0xe0, 0xd8, 0x6a, 0x7b, 0x04, 0x30,
519          0xd8, 0xcd, 0xb7, 0x80, 0x70, 0xb4, 0xc5, 0x5a }
520      }, {
521        24,
522        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
523          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
524          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 },
525        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
526          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
527        { 0xdd, 0xa9, 0x7c, 0xa4, 0x86, 0x4c, 0xdf, 0xe0,
528          0x6e, 0xaf, 0x70, 0xa0, 0xec, 0x0d, 0x71, 0x91 }
529      }, {
530        32,
531        { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
532          0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
533          0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
534          0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f },
535        { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
536          0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
537        { 0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf,
538          0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89 }
539      }
540   };
541    symmetric_key key;
542    unsigned char tmp[2][16];
543    int i, y;
544    for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
545      zeromem(&key, sizeof(key));
546      if ((err = rijndael_setup(tests[i].key, tests[i].keylen, 0, &key)) != CRYPT_OK) {
547         return err;
548      }
549      rijndael_ecb_encrypt(tests[i].pt, tmp[0], &key);
550      rijndael_ecb_decrypt(tmp[0], tmp[1], &key);
551      if (compare_testvector(tmp[0], 16, tests[i].ct, 16, "AES Encrypt", i) ||
552            compare_testvector(tmp[1], 16, tests[i].pt, 16, "AES Decrypt", i)) {
553          return CRYPT_FAIL_TESTVECTOR;
554      }
555      for (y = 0; y < 16; y++) tmp[0][y] = 0;
556      for (y = 0; y < 1000; y++) rijndael_ecb_encrypt(tmp[0], tmp[0], &key);
557      for (y = 0; y < 1000; y++) rijndael_ecb_decrypt(tmp[0], tmp[0], &key);
558      for (y = 0; y < 16; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
559    }
560    return CRYPT_OK;
561   #endif
562  }
563  #endif &bsol;* ENCRYPT_ONLY */
564  void ECB_DONE(symmetric_key *skey)
565  {
566    LTC_UNUSED_PARAM(skey);
567  }
568  int ECB_KS(int *keysize)
569  {
570     LTC_ARGCHK(keysize != NULL);
571     if (*keysize < 16) {
572        return CRYPT_INVALID_KEYSIZE;
573     }
574     if (*keysize < 24) {
575        *keysize = 16;
576        return CRYPT_OK;
577     }
578     if (*keysize < 32) {
579        *keysize = 24;
580        return CRYPT_OK;
581     }
582     *keysize = 32;
583     return CRYPT_OK;
584  }
585  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-SFMT_1.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-aes.c</div>
                </div>
                <div class="column column_space"><pre><code>423      for (j = 0; j < N32; j++) {
424  	r = func2(psfmt32[idxof(i)] + psfmt32[idxof((i + mid) % N32)]
425  		  + psfmt32[idxof((i + N32 - 1) % N32)]);
426  	psfmt32[idxof((i + mid) % N32)] ^= r;
427  	r -= i;
428  	psfmt32[idxof((i + mid + lag) % N32)] ^= r;
429  	psfmt32[idxof(i)] = r;
</pre></code></div>
                <div class="column column_space"><pre><code>376      for (r = 0; ; r++) {
377          rk += 4;
378          t0 =
379              Td0(LTC_BYTE(s0, 3)) ^
380              Td1(LTC_BYTE(s3, 2)) ^
381              Td2(LTC_BYTE(s2, 1)) ^
382              Td3(LTC_BYTE(s1, 0)) ^
383              rk[0];
384          t1 =
385              Td0(LTC_BYTE(s1, 3)) ^
386              Td1(LTC_BYTE(s0, 2)) ^
387              Td2(LTC_BYTE(s3, 1)) ^
388              Td3(LTC_BYTE(s2, 0)) ^
389              rk[1];
390          t2 =
391              Td0(LTC_BYTE(s2, 3)) ^
392              Td1(LTC_BYTE(s1, 2)) ^
393              Td2(LTC_BYTE(s0, 1)) ^
394              Td3(LTC_BYTE(s3, 0)) ^
395              rk[2];
396          t3 =
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    