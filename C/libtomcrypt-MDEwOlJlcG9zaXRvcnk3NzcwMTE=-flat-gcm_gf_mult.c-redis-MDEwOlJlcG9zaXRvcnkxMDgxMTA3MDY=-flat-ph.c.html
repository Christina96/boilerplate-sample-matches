
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.6036036036036037%, Tokens: 8</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-gcm_gf_mult.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #if defined(LTC_GCM_TABLES) || defined(LTC_LRW_TABLES) || (defined(LTC_GCM_MODE) && defined(LTC_FAST))
3  const unsigned char gcm_shift_table[256*2] = {
4  0x00, 0x00, 0x01, 0xc2, 0x03, 0x84, 0x02, 0x46, 0x07, 0x08, 0x06, 0xca, 0x04, 0x8c, 0x05, 0x4e,
5  0x0e, 0x10, 0x0f, 0xd2, 0x0d, 0x94, 0x0c, 0x56, 0x09, 0x18, 0x08, 0xda, 0x0a, 0x9c, 0x0b, 0x5e,
6  0x1c, 0x20, 0x1d, 0xe2, 0x1f, 0xa4, 0x1e, 0x66, 0x1b, 0x28, 0x1a, 0xea, 0x18, 0xac, 0x19, 0x6e,
7  0x12, 0x30, 0x13, 0xf2, 0x11, 0xb4, 0x10, 0x76, 0x15, 0x38, 0x14, 0xfa, 0x16, 0xbc, 0x17, 0x7e,
8  0x38, 0x40, 0x39, 0x82, 0x3b, 0xc4, 0x3a, 0x06, 0x3f, 0x48, 0x3e, 0x8a, 0x3c, 0xcc, 0x3d, 0x0e,
9  0x36, 0x50, 0x37, 0x92, 0x35, 0xd4, 0x34, 0x16, 0x31, 0x58, 0x30, 0x9a, 0x32, 0xdc, 0x33, 0x1e,
10  0x24, 0x60, 0x25, 0xa2, 0x27, 0xe4, 0x26, 0x26, 0x23, 0x68, 0x22, 0xaa, 0x20, 0xec, 0x21, 0x2e,
11  0x2a, 0x70, 0x2b, 0xb2, 0x29, 0xf4, 0x28, 0x36, 0x2d, 0x78, 0x2c, 0xba, 0x2e, 0xfc, 0x2f, 0x3e,
12  0x70, 0x80, 0x71, 0x42, 0x73, 0x04, 0x72, 0xc6, 0x77, 0x88, 0x76, 0x4a, 0x74, 0x0c, 0x75, 0xce,
13  0x7e, 0x90, 0x7f, 0x52, 0x7d, 0x14, 0x7c, 0xd6, 0x79, 0x98, 0x78, 0x5a, 0x7a, 0x1c, 0x7b, 0xde,
14  0x6c, 0xa0, 0x6d, 0x62, 0x6f, 0x24, 0x6e, 0xe6, 0x6b, 0xa8, 0x6a, 0x6a, 0x68, 0x2c, 0x69, 0xee,
15  0x62, 0xb0, 0x63, 0x72, 0x61, 0x34, 0x60, 0xf6, 0x65, 0xb8, 0x64, 0x7a, 0x66, 0x3c, 0x67, 0xfe,
16  0x48, 0xc0, 0x49, 0x02, 0x4b, 0x44, 0x4a, 0x86, 0x4f, 0xc8, 0x4e, 0x0a, 0x4c, 0x4c, 0x4d, 0x8e,
17  0x46, 0xd0, 0x47, 0x12, 0x45, 0x54, 0x44, 0x96, 0x41, 0xd8, 0x40, 0x1a, 0x42, 0x5c, 0x43, 0x9e,
18  0x54, 0xe0, 0x55, 0x22, 0x57, 0x64, 0x56, 0xa6, 0x53, 0xe8, 0x52, 0x2a, 0x50, 0x6c, 0x51, 0xae,
19  0x5a, 0xf0, 0x5b, 0x32, 0x59, 0x74, 0x58, 0xb6, 0x5d, 0xf8, 0x5c, 0x3a, 0x5e, 0x7c, 0x5f, 0xbe,
20  0xe1, 0x00, 0xe0, 0xc2, 0xe2, 0x84, 0xe3, 0x46, 0xe6, 0x08, 0xe7, 0xca, 0xe5, 0x8c, 0xe4, 0x4e,
21  0xef, 0x10, 0xee, 0xd2, 0xec, 0x94, 0xed, 0x56, 0xe8, 0x18, 0xe9, 0xda, 0xeb, 0x9c, 0xea, 0x5e,
22  0xfd, 0x20, 0xfc, 0xe2, 0xfe, 0xa4, 0xff, 0x66, 0xfa, 0x28, 0xfb, 0xea, 0xf9, 0xac, 0xf8, 0x6e,
23  0xf3, 0x30, 0xf2, 0xf2, 0xf0, 0xb4, 0xf1, 0x76, 0xf4, 0x38, 0xf5, 0xfa, 0xf7, 0xbc, 0xf6, 0x7e,
24  0xd9, 0x40, 0xd8, 0x82, 0xda, 0xc4, 0xdb, 0x06, 0xde, 0x48, 0xdf, 0x8a, 0xdd, 0xcc, 0xdc, 0x0e,
25  0xd7, 0x50, 0xd6, 0x92, 0xd4, 0xd4, 0xd5, 0x16, 0xd0, 0x58, 0xd1, 0x9a, 0xd3, 0xdc, 0xd2, 0x1e,
26  0xc5, 0x60, 0xc4, 0xa2, 0xc6, 0xe4, 0xc7, 0x26, 0xc2, 0x68, 0xc3, 0xaa, 0xc1, 0xec, 0xc0, 0x2e,
27  0xcb, 0x70, 0xca, 0xb2, 0xc8, 0xf4, 0xc9, 0x36, 0xcc, 0x78, 0xcd, 0xba, 0xcf, 0xfc, 0xce, 0x3e,
28  0x91, 0x80, 0x90, 0x42, 0x92, 0x04, 0x93, 0xc6, 0x96, 0x88, 0x97, 0x4a, 0x95, 0x0c, 0x94, 0xce,
29  0x9f, 0x90, 0x9e, 0x52, 0x9c, 0x14, 0x9d, 0xd6, 0x98, 0x98, 0x99, 0x5a, 0x9b, 0x1c, 0x9a, 0xde,
30  0x8d, 0xa0, 0x8c, 0x62, 0x8e, 0x24, 0x8f, 0xe6, 0x8a, 0xa8, 0x8b, 0x6a, 0x89, 0x2c, 0x88, 0xee,
31  0x83, 0xb0, 0x82, 0x72, 0x80, 0x34, 0x81, 0xf6, 0x84, 0xb8, 0x85, 0x7a, 0x87, 0x3c, 0x86, 0xfe,
32  0xa9, 0xc0, 0xa8, 0x02, 0xaa, 0x44, 0xab, 0x86, 0xae, 0xc8, 0xaf, 0x0a, 0xad, 0x4c, 0xac, 0x8e,
33  0xa7, 0xd0, 0xa6, 0x12, 0xa4, 0x54, 0xa5, 0x96, 0xa0, 0xd8, 0xa1, 0x1a, 0xa3, 0x5c, 0xa2, 0x9e,
34  0xb5, 0xe0, 0xb4, 0x22, 0xb6, 0x64, 0xb7, 0xa6, 0xb2, 0xe8, 0xb3, 0x2a, 0xb1, 0x6c, 0xb0, 0xae,
35  0xbb, 0xf0, 0xba, 0x32, 0xb8, 0x74, 0xb9, 0xb6, 0xbc, 0xf8, 0xbd, 0x3a, 0xbf, 0x7c, 0xbe, 0xbe };
36  #endif
37  #if defined(LTC_GCM_MODE) || defined(LRW_MODE)
38  #ifndef LTC_FAST
39  static void s_gcm_rightshift(unsigned char *a)
40  {
41     int x;
42     for (x = 15; x > 0; x--) {
43         a[x] = (a[x]>>1) | ((a[x-1]<<7)&0x80);
44     }
45     a[0] >>= 1;
46  }
47  static const unsigned char mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
48  static const unsigned char poly[] = { 0x00, 0xE1 };
49  void gcm_gf_mult(const unsigned char *a, const unsigned char *b, unsigned char *c)
50  {
51     unsigned char Z[16], V[16];
52     unsigned char x, y, z;
53     zeromem(Z, 16);
54     XMEMCPY(V, a, 16);
55     for (x = 0; x < 128; x++) {
56         if (b[x>>3] & mask[x&7]) {
57            for (y = 0; y < 16; y++) {
58                Z[y] ^= V[y];
59            }
60         }
61         z     = V[15] & 0x01;
62         s_gcm_rightshift(V);
63         V[0] ^= poly[z];
64     }
65     XMEMCPY(c, Z, 16);
66  }
67  #else
68  #define M(x) ( ((x&8)>>3) | ((x&4)>>1) | ((x&2)<<1) | ((x&1)<<3) )
69  #define BPD (sizeof(LTC_FAST_TYPE) * 8)
70  #define WPV (1 + (16 / sizeof(LTC_FAST_TYPE)))
71  void gcm_gf_mult(const unsigned char *a, const unsigned char *b, unsigned char *c)
72  {
73     int i, j, k, u;
74     LTC_FAST_TYPE B[16][WPV], tmp[32 / sizeof(LTC_FAST_TYPE)], pB[16 / sizeof(LTC_FAST_TYPE)], zz, z;
75     unsigned char pTmp[32];
76     zeromem(B[0],       sizeof(B[0]));
77     zeromem(B[M(1)],    sizeof(B[M(1)]));
78  #ifdef ENDIAN_32BITWORD
79     for (i = 0; i < 4; i++) {
80         LOAD32H(B[M(1)][i], a + (i<<2));
81         LOAD32L(pB[i],      b + (i<<2));
82     }
83  #else
84     for (i = 0; i < 2; i++) {
85         LOAD64H(B[M(1)][i], a + (i<<3));
86         LOAD64L(pB[i],      b + (i<<3));
87     }
88  #endif
89     B[M(2)][0] = B[M(1)][0] >> 1;
90     B[M(4)][0] = B[M(1)][0] >> 2;
91     B[M(8)][0] = B[M(1)][0] >> 3;
92     for (i = 1; i < (int)WPV; i++) {
93        B[M(2)][i] = (B[M(1)][i-1] << (BPD-1)) | (B[M(1)][i] >> 1);
94        B[M(4)][i] = (B[M(1)][i-1] << (BPD-2)) | (B[M(1)][i] >> 2);
95        B[M(8)][i] = (B[M(1)][i-1] << (BPD-3)) | (B[M(1)][i] >> 3);
96     }
97     for (i = 0; i < (int)WPV; i++) {
98        B[M(3)][i]  = B[M(1)][i] ^ B[M(2)][i];
99        B[M(5)][i]  = B[M(1)][i] ^ B[M(4)][i];
100        B[M(6)][i]  = B[M(2)][i] ^ B[M(4)][i];
101        B[M(9)][i]  = B[M(1)][i] ^ B[M(8)][i];
102        B[M(10)][i] = B[M(2)][i] ^ B[M(8)][i];
103        B[M(12)][i] = B[M(8)][i] ^ B[M(4)][i];
104        B[M(7)][i]  = B[M(3)][i] ^ B[M(4)][i];
105        B[M(11)][i] = B[M(3)][i] ^ B[M(8)][i];
106        B[M(13)][i] = B[M(1)][i] ^ B[M(12)][i];
107        B[M(14)][i] = B[M(6)][i] ^ B[M(8)][i];
108        B[M(15)][i] = B[M(7)][i] ^ B[M(8)][i];
109     }
110     zeromem(tmp, sizeof(tmp));
111     for (i = (BPD/4)-1; i >= 0; i--) {
112         for (j = 0; j < (int)(WPV-1); j++) {
<span onclick='openModal()' class='match'>113             u = (pB[j] >> ((i^1)<<2)) & 15;
114             for (k = 0; k < (int)WPV; k++) {
115                 tmp[k+j] ^= B[u][k];
116             }
</span>117         }
118         if (i != 0) {
119            for (z = j = 0; j < (int)(32 / sizeof(LTC_FAST_TYPE)); j++) {
120                zz = tmp[j] << (BPD-4);
121                tmp[j] = (tmp[j] >> 4) | z;
122                z = zz;
123            }
124         }
125     }
126  #ifdef ENDIAN_32BITWORD
127     for (i = 0; i < 8; i++) {
128         STORE32H(tmp[i], pTmp + (i<<2));
129     }
130  #else
131     for (i = 0; i < 4; i++) {
132         STORE64H(tmp[i], pTmp + (i<<3));
133     }
134  #endif
135     for (i = 31; i >= 16; i--) {
136         pTmp[i-16] ^= gcm_shift_table[((unsigned)pTmp[i]<<1)];
137         pTmp[i-15] ^= gcm_shift_table[((unsigned)pTmp[i]<<1)+1];
138     }
139     for (i = 0; i < 16; i++) {
140         c[i] = pTmp[i];
141     }
142  }
143  #endif
144  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ph.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/ph.h"
3  typedef struct node_s node_t;
4  struct node_s {
5  #define NODE_MAGIC 0x9823af7e
6  	uint32_t magic;
7  	phn(node_t) link;
8  	uint64_t key;
9  };
10  static int
11  node_cmp(const node_t *a, const node_t *b) {
12  	int ret;
13  	ret = (a->key > b->key) - (a->key < b->key);
14  	if (ret == 0) {
15  		ret = (((uintptr_t)a) > ((uintptr_t)b))
16  		    - (((uintptr_t)a) < ((uintptr_t)b));
17  	}
18  	return ret;
19  }
20  static int
21  node_cmp_magic(const node_t *a, const node_t *b) {
22  	assert_u32_eq(a->magic, NODE_MAGIC, "Bad magic");
23  	assert_u32_eq(b->magic, NODE_MAGIC, "Bad magic");
24  	return node_cmp(a, b);
25  }
26  typedef ph(node_t) heap_t;
27  ph_gen(static, heap_, heap_t, node_t, link, node_cmp_magic);
28  static void
29  node_print(const node_t *node, unsigned depth) {
30  	unsigned i;
31  	node_t *leftmost_child, *sibling;
32  	for (i = 0; i < depth; i++) {
33  		malloc_printf("\t");
34  	}
35  	malloc_printf("%2"FMTu64"\n", node->key);
36  	leftmost_child = phn_lchild_get(node_t, link, node);
37  	if (leftmost_child == NULL) {
38  		return;
39  	}
40  	node_print(leftmost_child, depth + 1);
41  	for (sibling = phn_next_get(node_t, link, leftmost_child); sibling !=
42  	    NULL; sibling = phn_next_get(node_t, link, sibling)) {
43  		node_print(sibling, depth + 1);
44  	}
45  }
46  static void
47  heap_print(const heap_t *heap) {
48  	node_t *auxelm;
49  	malloc_printf("vvv heap %p vvv\n", heap);
50  	if (heap->ph_root == NULL) {
51  		goto label_return;
52  	}
53  	node_print(heap->ph_root, 0);
54  	for (auxelm = phn_next_get(node_t, link, heap->ph_root); auxelm != NULL;
55  	    auxelm = phn_next_get(node_t, link, auxelm)) {
56  		assert_ptr_eq(phn_next_get(node_t, link, phn_prev_get(node_t,
57  		    link, auxelm)), auxelm,
58  		    "auxelm's prev doesn't link to auxelm");
59  		node_print(auxelm, 0);
60  	}
61  label_return:
62  	malloc_printf("^^^ heap %p ^^^\n", heap);
63  }
64  static unsigned
65  node_validate(const node_t *node, const node_t *parent) {
66  	unsigned nnodes = 1;
67  	node_t *leftmost_child, *sibling;
68  	if (parent != NULL) {
69  		assert_d_ge(node_cmp_magic(node, parent), 0,
70  		    "Child is less than parent");
71  	}
72  	leftmost_child = phn_lchild_get(node_t, link, node);
73  	if (leftmost_child == NULL) {
74  		return nnodes;
75  	}
76  	assert_ptr_eq((void *)phn_prev_get(node_t, link, leftmost_child),
77  	    (void *)node, "Leftmost child does not link to node");
<span onclick='openModal()' class='match'>78  	nnodes += node_validate(leftmost_child, node);
79  	for (sibling = phn_next_get(node_t, link, leftmost_child); sibling !=
80  	    NULL; sibling = phn_next_get(node_t, link, sibling)) {
81  		assert_ptr_eq(phn_next_get(node_t, link, phn_prev_get(node_t,
82  		    link, sibling)), sibling,
83  		    "sibling's prev doesn't link to sibling");
84  		nnodes += node_validate(sibling, node);
85  	}
</span>86  	return nnodes;
87  }
88  static unsigned
89  heap_validate(const heap_t *heap) {
90  	unsigned nnodes = 0;
91  	node_t *auxelm;
92  	if (heap->ph_root == NULL) {
93  		goto label_return;
94  	}
95  	nnodes += node_validate(heap->ph_root, NULL);
96  	for (auxelm = phn_next_get(node_t, link, heap->ph_root); auxelm != NULL;
97  	    auxelm = phn_next_get(node_t, link, auxelm)) {
98  		assert_ptr_eq(phn_next_get(node_t, link, phn_prev_get(node_t,
99  		    link, auxelm)), auxelm,
100  		    "auxelm's prev doesn't link to auxelm");
101  		nnodes += node_validate(auxelm, NULL);
102  	}
103  label_return:
104  	if (false) {
105  		heap_print(heap);
106  	}
107  	return nnodes;
108  }
109  TEST_BEGIN(test_ph_empty) {
110  	heap_t heap;
111  	heap_new(&heap);
112  	assert_true(heap_empty(&heap), "Heap should be empty");
113  	assert_ptr_null(heap_first(&heap), "Unexpected node");
114  	assert_ptr_null(heap_any(&heap), "Unexpected node");
115  }
116  TEST_END
117  static void
118  node_remove(heap_t *heap, node_t *node) {
119  	heap_remove(heap, node);
120  	node->magic = 0;
121  }
122  static node_t *
123  node_remove_first(heap_t *heap) {
124  	node_t *node = heap_remove_first(heap);
125  	node->magic = 0;
126  	return node;
127  }
128  static node_t *
129  node_remove_any(heap_t *heap) {
130  	node_t *node = heap_remove_any(heap);
131  	node->magic = 0;
132  	return node;
133  }
134  TEST_BEGIN(test_ph_random) {
135  #define NNODES 25
136  #define NBAGS 250
137  #define SEED 42
138  	sfmt_t *sfmt;
139  	uint64_t bag[NNODES];
140  	heap_t heap;
141  	node_t nodes[NNODES];
142  	unsigned i, j, k;
143  	sfmt = init_gen_rand(SEED);
144  	for (i = 0; i < NBAGS; i++) {
145  		switch (i) {
146  		case 0:
147  			for (j = 0; j < NNODES; j++) {
148  				bag[j] = j;
149  			}
150  			break;
151  		case 1:
152  			for (j = 0; j < NNODES; j++) {
153  				bag[j] = NNODES - j - 1;
154  			}
155  			break;
156  		default:
157  			for (j = 0; j < NNODES; j++) {
158  				bag[j] = gen_rand64_range(sfmt, NNODES);
159  			}
160  		}
161  		for (j = 1; j <= NNODES; j++) {
162  			heap_new(&heap);
163  			assert_u_eq(heap_validate(&heap), 0,
164  			    "Incorrect node count");
165  			for (k = 0; k < j; k++) {
166  				nodes[k].magic = NODE_MAGIC;
167  				nodes[k].key = bag[k];
168  			}
169  			for (k = 0; k < j; k++) {
170  				heap_insert(&heap, &nodes[k]);
171  				if (i % 13 == 12) {
172  					assert_ptr_not_null(heap_any(&heap),
173  					    "Heap should not be empty");
174  					assert_ptr_not_null(heap_first(&heap),
175  					    "Heap should not be empty");
176  				}
177  				assert_u_eq(heap_validate(&heap), k + 1,
178  				    "Incorrect node count");
179  			}
180  			assert_false(heap_empty(&heap),
181  			    "Heap should not be empty");
182  			switch (i % 6) {
183  			case 0:
184  				for (k = 0; k < j; k++) {
185  					assert_u_eq(heap_validate(&heap), j - k,
186  					    "Incorrect node count");
187  					node_remove(&heap, &nodes[k]);
188  					assert_u_eq(heap_validate(&heap), j - k
189  					    - 1, "Incorrect node count");
190  				}
191  				break;
192  			case 1:
193  				for (k = j; k > 0; k--) {
194  					node_remove(&heap, &nodes[k-1]);
195  					assert_u_eq(heap_validate(&heap), k - 1,
196  					    "Incorrect node count");
197  				}
198  				break;
199  			case 2: {
200  				node_t *prev = NULL;
201  				for (k = 0; k < j; k++) {
202  					node_t *node = node_remove_first(&heap);
203  					assert_u_eq(heap_validate(&heap), j - k
204  					    - 1, "Incorrect node count");
205  					if (prev != NULL) {
206  						assert_d_ge(node_cmp(node,
207  						    prev), 0,
208  						    "Bad removal order");
209  					}
210  					prev = node;
211  				}
212  				break;
213  			} case 3: {
214  				node_t *prev = NULL;
215  				for (k = 0; k < j; k++) {
216  					node_t *node = heap_first(&heap);
217  					assert_u_eq(heap_validate(&heap), j - k,
218  					    "Incorrect node count");
219  					if (prev != NULL) {
220  						assert_d_ge(node_cmp(node,
221  						    prev), 0,
222  						    "Bad removal order");
223  					}
224  					node_remove(&heap, node);
225  					assert_u_eq(heap_validate(&heap), j - k
226  					    - 1, "Incorrect node count");
227  					prev = node;
228  				}
229  				break;
230  			} case 4: {
231  				for (k = 0; k < j; k++) {
232  					node_remove_any(&heap);
233  					assert_u_eq(heap_validate(&heap), j - k
234  					    - 1, "Incorrect node count");
235  				}
236  				break;
237  			} case 5: {
238  				for (k = 0; k < j; k++) {
239  					node_t *node = heap_any(&heap);
240  					assert_u_eq(heap_validate(&heap), j - k,
241  					    "Incorrect node count");
242  					node_remove(&heap, node);
243  					assert_u_eq(heap_validate(&heap), j - k
244  					    - 1, "Incorrect node count");
245  				}
246  				break;
247  			} default:
248  				not_reached();
249  			}
250  			assert_ptr_null(heap_first(&heap),
251  			    "Heap should be empty");
252  			assert_ptr_null(heap_any(&heap),
253  			    "Heap should be empty");
254  			assert_true(heap_empty(&heap), "Heap should be empty");
255  		}
256  	}
257  	fini_gen_rand(sfmt);
258  #undef NNODES
259  #undef SEED
260  }
261  TEST_END
262  int
263  main(void) {
264  	return test(
265  	    test_ph_empty,
266  	    test_ph_random);
267  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-gcm_gf_mult.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ph.c</div>
                </div>
                <div class="column column_space"><pre><code>113             u = (pB[j] >> ((i^1)<<2)) & 15;
114             for (k = 0; k < (int)WPV; k++) {
115                 tmp[k+j] ^= B[u][k];
116             }
</pre></code></div>
                <div class="column column_space"><pre><code>78  	nnodes += node_validate(leftmost_child, node);
79  	for (sibling = phn_next_get(node_t, link, leftmost_child); sibling !=
80  	    NULL; sibling = phn_next_get(node_t, link, sibling)) {
81  		assert_ptr_eq(phn_next_get(node_t, link, phn_prev_get(node_t,
82  		    link, sibling)), sibling,
83  		    "sibling's prev doesn't link to sibling");
84  		nnodes += node_validate(sibling, node);
85  	}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    