
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-generic.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef ct_solver S;
3  typedef struct {
4       plan_dftw super;
5       INT r, rs, m, mb, me, ms, v, vs;
6       plan *cld;
7       twid *td;
8       const S *slv;
9       int dec;
10  } P;
11  static void mktwiddle(P *ego, enum wakefulness wakefulness)
12  {
13       static const tw_instr tw[] = { { TW_FULL, 0, 0 }, { TW_NEXT, 1, 0 } };
14       X(twiddle_awake)(wakefulness, &ego->td, tw,
15  		      ego->r * ego->m, ego->m, ego->r);
16  }
17  static void bytwiddle(const P *ego, R *rio, R *iio)
18  {
19       INT iv, ir, im;
20       INT r = ego->r, rs = ego->rs;
21       INT m = ego->m, mb = ego->mb, me = ego->me, ms = ego->ms;
22       INT v = ego->v, vs = ego->vs;
23       const R *W = ego->td->W;
24       mb += (mb == 0); &bsol;* skip m=0 iteration */
25       for (iv = 0; iv < v; ++iv) {
26  	  for (ir = 1; ir < r; ++ir) {
27  	       for (im = mb; im < me; ++im) {
28  		    R *pr = rio + ms * im + rs * ir;
29  		    R *pi = iio + ms * im + rs * ir;
30  		    E xr = *pr;
31  		    E xi = *pi;
32  		    E wr = W[2 * im + (2 * (m-1)) * ir - 2];
33  		    E wi = W[2 * im + (2 * (m-1)) * ir - 1];
34  		    *pr = xr * wr + xi * wi;
35  		    *pi = xi * wr - xr * wi;
36  	       }
37  	  }
38  	  rio += vs;
39  	  iio += vs;
40       }
41  }
42  static int applicable(INT irs, INT ors, INT ivs, INT ovs,
43  		      const planner *plnr)
44  {
45       return (1
46  	     && irs == ors
47  	     && ivs == ovs
48  	     && !NO_SLOWP(plnr)
49  	  );
50  }
51  static void apply_dit(const plan *ego_, R *rio, R *iio)
52  {
53       const P *ego = (const P *) ego_;
54       plan_dft *cld;
55       INT dm = ego->ms * ego->mb;
56       bytwiddle(ego, rio, iio);
57       cld = (plan_dft *) ego->cld;
58       cld->apply(ego->cld, rio + dm, iio + dm, rio + dm, iio + dm);
59  }
60  static void apply_dif(const plan *ego_, R *rio, R *iio)
61  {
62       const P *ego = (const P *) ego_;
63       plan_dft *cld;
64       INT dm = ego->ms * ego->mb;
65       cld = (plan_dft *) ego->cld;
66       cld->apply(ego->cld, rio + dm, iio + dm, rio + dm, iio + dm);
67       bytwiddle(ego, rio, iio);
68  }
69  static void awake(plan *ego_, enum wakefulness wakefulness)
70  {
71       P *ego = (P *) ego_;
72       X(plan_awake)(ego->cld, wakefulness);
73       mktwiddle(ego, wakefulness);
74  }
75  static void destroy(plan *ego_)
76  {
77       P *ego = (P *) ego_;
78       X(plan_destroy_internal)(ego->cld);
79  }
80  static void print(const plan *ego_, printer *p)
81  {
82       const P *ego = (const P *) ego_;
83       p->print(p, "(dftw-generic-%s-%D-%D%v%(%p%))",
84  	      ego->dec == DECDIT ? "dit" : "dif",
85  	      ego->r, ego->m, ego->v, ego->cld);
86  }
<span onclick='openModal()' class='match'>87  static plan *mkcldw(const ct_solver *ego_,
88  		    INT r, INT irs, INT ors,
89  		    INT m, INT ms,
90  		    INT v, INT ivs, INT ovs,
</span>91  		    INT mstart, INT mcount,
92  		    R *rio, R *iio,
93  		    planner *plnr)
94  {
95       const S *ego = (const S *)ego_;
96       P *pln;
97       plan *cld = 0;
98       INT dm = ms * mstart;
99       static const plan_adt padt = {
100  	  0, awake, print, destroy
101       };
102       A(mstart >= 0 && mstart + mcount <= m);
103       if (!applicable(irs, ors, ivs, ovs, plnr))
104            return (plan *)0;
105       cld = X(mkplan_d)(plnr,
106  			X(mkproblem_dft_d)(
107  			     X(mktensor_1d)(r, irs, irs),
108  			     X(mktensor_2d)(mcount, ms, ms, v, ivs, ivs),
109  			     rio + dm, iio + dm, rio + dm, iio + dm)
110  			);
111       if (!cld) goto nada;
112       pln = MKPLAN_DFTW(P, &padt, ego->dec == DECDIT ? apply_dit : apply_dif);
113       pln->slv = ego;
114       pln->cld = cld;
115       pln->r = r;
116       pln->rs = irs;
117       pln->m = m;
118       pln->ms = ms;
119       pln->v = v;
120       pln->vs = ivs;
121       pln->mb = mstart;
122       pln->me = mstart + mcount;
123       pln->dec = ego->dec;
124       pln->td = 0;
125       {
126  	  double n0 = (r - 1) * (mcount - 1) * v;
127  	  pln->super.super.ops = cld->ops;
128  	  pln->super.super.ops.mul += 8 * n0;
129  	  pln->super.super.ops.add += 4 * n0;
130  	  pln->super.super.ops.other += 8 * n0;
131       }
132       return &(pln->super.super);
133   nada:
134       X(plan_destroy_internal)(cld);
135       return (plan *) 0;
136  }
137  static void regsolver(planner *plnr, INT r, int dec)
138  {
139       S *slv = (S *)X(mksolver_ct)(sizeof(S), r, dec, mkcldw, 0);
140       REGISTER_SOLVER(plnr, &(slv->super));
141       if (X(mksolver_ct_hook)) {
142  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), r, dec, mkcldw, 0);
143  	  REGISTER_SOLVER(plnr, &(slv->super));
144       }
145  }
146  void X(ct_generic_register)(planner *p)
147  {
148       regsolver(p, 0, DECDIT);
149       regsolver(p, 0, DECDIF);
150  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-directsq.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef struct {
3       ct_solver super;
4       const ct_desc *desc;
5       kdftwsq k;
6  } S;
7  typedef struct {
8       plan_dftw super;
9       kdftwsq k;
10       INT r;
11       stride rs, vs;
12       INT m, ms, v, mb, me;
13       twid *td;
14       const S *slv;
15  } P;
16  static void apply(const plan *ego_, R *rio, R *iio)
17  {
18       const P *ego = (const P *) ego_;
19       INT mb = ego->mb, ms = ego->ms;
20       ego->k(rio + mb*ms, iio + mb*ms, ego->td->W, ego->rs, ego->vs,
21  	    mb, ego->me, ms);
22  }
23  static void awake(plan *ego_, enum wakefulness wakefulness)
24  {
25       P *ego = (P *) ego_;
26       X(twiddle_awake)(wakefulness, &ego->td, ego->slv->desc->tw,
27  		      ego->r * ego->m, ego->r, ego->m);
28  }
29  static void destroy(plan *ego_)
30  {
31       P *ego = (P *) ego_;
32       X(stride_destroy)(ego->rs);
33       X(stride_destroy)(ego->vs);
34  }
35  static void print(const plan *ego_, printer *p)
36  {
37       const P *ego = (const P *) ego_;
38       const S *slv = ego->slv;
39       const ct_desc *e = slv->desc;
40       p->print(p, "(dftw-directsq-%D/%D%v \"%s\")",
41  	      ego->r, X(twiddle_length)(ego->r, e->tw), ego->v, e->nam);
42  }
43  static int applicable(const S *ego,
44  		      INT r, INT irs, INT ors,
45  		      INT m, INT ms,
46  		      INT v, INT ivs, INT ovs,
47  		      INT mb, INT me,
48  		      R *rio, R *iio,
49  		      const planner *plnr)
50  {
51       const ct_desc *e = ego->desc;
52       UNUSED(v);
53       return (
54  	  1
55  	  && r == e->radix
56  	  && r == v
57  	  && irs == ovs
58  	  && ivs == ors
59  	  && e->genus->okp(e, rio, iio, irs, ivs, m, mb, me, ms, plnr)
60  	  );
61  }
<span onclick='openModal()' class='match'>62  static plan *mkcldw(const ct_solver *ego_,
63  		    INT r, INT irs, INT ors,
64  		    INT m, INT ms,
65  		    INT v, INT ivs, INT ovs,
</span>66  		    INT mstart, INT mcount,
67  		    R *rio, R *iio,
68  		    planner *plnr)
69  {
70       const S *ego = (const S *) ego_;
71       P *pln;
72       const ct_desc *e = ego->desc;
73       static const plan_adt padt = {
74  	  0, awake, print, destroy
75       };
76       A(mstart >= 0 && mstart + mcount <= m);
77       if (!applicable(ego,
78  		     r, irs, ors, m, ms, v, ivs, ovs, mstart, mstart + mcount,
79  		     rio, iio, plnr))
80            return (plan *)0;
81       pln = MKPLAN_DFTW(P, &padt, apply);
82       pln->k = ego->k;
83       pln->rs = X(mkstride)(r, irs);
84       pln->vs = X(mkstride)(v, ivs);
85       pln->td = 0;
86       pln->r = r;
87       pln->m = m;
88       pln->ms = ms;
89       pln->v = v;
90       pln->mb = mstart;
91       pln->me = mstart + mcount;
92       pln->slv = ego;
93       X(ops_zero)(&pln->super.super.ops);
94       X(ops_madd2)(mcount/e->genus->vl, &e->ops, &pln->super.super.ops);
95       return &(pln->super.super);
96  }
97  static void regone(planner *plnr, kdftwsq codelet,
98  		   const ct_desc *desc, int dec)
99  {
100       S *slv = (S *)X(mksolver_ct)(sizeof(S), desc->radix, dec, mkcldw, 0);
101       slv->k = codelet;
102       slv->desc = desc;
103       REGISTER_SOLVER(plnr, &(slv->super.super));
104       if (X(mksolver_ct_hook)) {
105  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), desc->radix, dec,
106  					 mkcldw, 0);
107  	  slv->k = codelet;
108  	  slv->desc = desc;
109  	  REGISTER_SOLVER(plnr, &(slv->super.super));
110       }
111  }
112  void X(regsolver_ct_directwsq)(planner *plnr, kdftwsq codelet,
113  			       const ct_desc *desc, int dec)
114  {
115       regone(plnr, codelet, desc, dec+TRANSPOSE);
116  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-generic.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-directsq.c</div>
                </div>
                <div class="column column_space"><pre><code>87  static plan *mkcldw(const ct_solver *ego_,
88  		    INT r, INT irs, INT ors,
89  		    INT m, INT ms,
90  		    INT v, INT ivs, INT ovs,
</pre></code></div>
                <div class="column column_space"><pre><code>62  static plan *mkcldw(const ct_solver *ego_,
63  		    INT r, INT irs, INT ors,
64  		    INT m, INT ms,
65  		    INT v, INT ivs, INT ovs,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    