
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.920792079207921%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-OclLaunchData.h</h3>
            <pre><code>1  #ifndef XMRIG_OCLLAUNCHDATA_H
2  #define XMRIG_OCLLAUNCHDATA_H
3  #include "backend/opencl/OclThread.h"
4  #include "backend/opencl/runners/tools/OclSharedData.h"
5  #include "backend/opencl/wrappers/OclDevice.h"
6  #include "backend/opencl/wrappers/OclPlatform.h"
7  #include "base/crypto/Algorithm.h"
8  #include "crypto/common/Nonce.h"
9  using cl_context = struct _cl_context *;
10  namespace xmrig {
11  class OclConfig;
12  class Miner;
13  class OclLaunchData
14  {
15  public:
<span onclick='openModal()' class='match'>16      OclLaunchData(const Miner *miner, const Algorithm &algorithm, const OclConfig &config, const OclPlatform &platform, const OclThread &thread, const OclDevice &device, int64_t affinity);
17      bool isEqual(const OclLaunchData &other) const;
</span>18      inline constexpr static Nonce::Backend backend() { return Nonce::OPENCL; }
19      inline bool operator!=(const OclLaunchData &other) const    { return !isEqual(other); }
20      inline bool operator==(const OclLaunchData &other) const    { return isEqual(other); }
21      static const char *tag();
22      cl_context ctx = nullptr;
23      const Algorithm algorithm;
24      const bool cache;
25      const int64_t affinity;
26      const Miner *miner;
27      const OclDevice device;
28      const OclPlatform platform;
29      const OclThread thread;
30      const uint32_t benchSize = 0;
31  };
32  } 
33  #endif &bsol;* XMRIG_OCLLAUNCHDATA_H */
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ccm.h</h3>
            <pre><code>1  #ifndef NRF_CCM_H__
2  #define NRF_CCM_H__
3  #include <nrfx.h>
4  #ifdef __cplusplus
5  extern "C" {
6  #endif
7  typedef enum
8  {
9      NRF_CCM_TASK_KSGEN        = offsetof(NRF_CCM_Type, TASKS_KSGEN),        
10      NRF_CCM_TASK_CRYPT        = offsetof(NRF_CCM_Type, TASKS_CRYPT),        
11      NRF_CCM_TASK_STOP         = offsetof(NRF_CCM_Type, TASKS_STOP),         
12  #if defined(CCM_RATEOVERRIDE_RATEOVERRIDE_Pos) || defined(__NRFX_DOXYGEN__)
13      NRF_CCM_TASK_RATEOVERRIDE = offsetof(NRF_CCM_Type, TASKS_RATEOVERRIDE), 
14  #endif
15  } nrf_ccm_task_t;
16  typedef enum
17  {
18      NRF_CCM_EVENT_ENDKSGEN = offsetof(NRF_CCM_Type, EVENTS_ENDKSGEN), 
19      NRF_CCM_EVENT_ENDCRYPT = offsetof(NRF_CCM_Type, EVENTS_ENDCRYPT), 
20      NRF_CCM_EVENT_ERROR    = offsetof(NRF_CCM_Type, EVENTS_ERROR),    
21  } nrf_ccm_event_t;
22  typedef enum
23  {
24      NRF_CCM_INT_ENDKSGEN_MASK  = CCM_INTENSET_ENDKSGEN_Msk, 
25      NRF_CCM_INT_ENDCRYPT_MASK  = CCM_INTENSET_ENDCRYPT_Msk, 
26      NRF_CCM_INT_ERROR_MASK     = CCM_INTENSET_ERROR_Msk,    
27  } nrf_ccm_int_mask_t;
28  typedef enum
29  {
30      NRF_CCM_MODE_ENCRYPTION = CCM_MODE_MODE_Encryption, 
31      NRF_CCM_MODE_DECRYPTION = CCM_MODE_MODE_Decryption, 
32  } nrf_ccm_mode_t;
33  #if defined(CCM_MODE_DATARATE_Pos) || defined(__NRFX_DOXYGEN__)
34  typedef enum
35  {
36      NRF_CCM_DATARATE_1M   = CCM_MODE_DATARATE_1Mbit,   
37      NRF_CCM_DATARATE_2M   = CCM_MODE_DATARATE_2Mbit,   
38  #if defined(CCM_MODE_DATARATE_125Kbps) || defined(__NRFX_DOXYGEN__)
39      NRF_CCM_DATARATE_125K = CCM_MODE_DATARATE_125Kbps, 
40  #endif
41  #if defined(CCM_MODE_DATARATE_500Kbps) || defined(__NRFX_DOXYGEN__)
42      NRF_CCM_DATARATE_500K = CCM_MODE_DATARATE_500Kbps, 
43  #endif
44  } nrf_ccm_datarate_t;
45  #endif 
46  #if defined(CCM_MODE_LENGTH_Pos) || defined(__NRFX_DOXYGEN__)
47  typedef enum
48  {
49      NRF_CCM_LENGTH_DEFAULT  = CCM_MODE_LENGTH_Default,  
50      NRF_CCM_LENGTH_EXTENDED = CCM_MODE_LENGTH_Extended, 
51  } nrf_ccm_length_t;
52  #endif 
53  typedef struct {
54      nrf_ccm_mode_t     mode;     
55  #if defined(CCM_MODE_DATARATE_Pos) || defined(__NRFX_DOXYGEN__)
56      nrf_ccm_datarate_t datarate; 
57  #endif
58  #if defined(CCM_MODE_LENGTH_Pos) || defined(__NRFX_DOXYGEN__)
59      nrf_ccm_length_t   length;   
60  #endif
61  } nrf_ccm_config_t;
62  NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
63                                              nrf_ccm_task_t task);
<span onclick='openModal()' class='match'>64  NRF_STATIC_INLINE uint32_t nrf_ccm_task_address_get(NRF_CCM_Type const * p_reg,
65                                                      nrf_ccm_task_t       task);
66  NRF_STATIC_INLINE void nrf_ccm_event_clear(NRF_CCM_Type *  p_reg,
67                                             nrf_ccm_event_t event);
68  NRF_STATIC_INLINE bool nrf_ccm_event_check(NRF_CCM_Type const * p_reg,
69                                             nrf_ccm_event_t      event);
70  NRF_STATIC_INLINE uint32_t nrf_ccm_event_address_get(NRF_CCM_Type const * p_reg,
71                                                       nrf_ccm_event_t      event);
72  NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask);
73  NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask);
74  NRF_STATIC_INLINE uint32_t nrf_ccm_int_enable_check(NRF_CCM_Type const * p_reg, uint32_t mask);
75  NRF_STATIC_INLINE void nrf_ccm_enable(NRF_CCM_Type * p_reg);
76  NRF_STATIC_INLINE void nrf_ccm_disable(NRF_CCM_Type * p_reg);
77  NRF_STATIC_INLINE void nrf_ccm_configure(NRF_CCM_Type *           p_reg,
78                                           nrf_ccm_config_t const * p_config);
79  #if defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos) || defined(__NRFX_DOXYGEN__)
80  NRF_STATIC_INLINE void nrf_ccm_maxpacketsize_set(NRF_CCM_Type * p_reg,
81                                                   uint8_t        size);
82  #endif 
83  NRF_STATIC_INLINE bool nrf_ccm_micstatus_get(NRF_CCM_Type const * p_reg);
84  NRF_STATIC_INLINE void nrf_ccm_cnfptr_set(NRF_CCM_Type *   p_reg,
85                                            uint32_t const * p_data);
86  NRF_STATIC_INLINE uint32_t * nrf_ccm_cnfptr_get(NRF_CCM_Type const * p_reg);
</span>87  NRF_STATIC_INLINE void nrf_ccm_inptr_set(NRF_CCM_Type *   p_reg,
88                                           uint32_t const * p_data);
89  NRF_STATIC_INLINE uint32_t * nrf_ccm_inptr_get(NRF_CCM_Type const * p_reg);
90  NRF_STATIC_INLINE void nrf_ccm_outptr_set(NRF_CCM_Type *   p_reg,
91                                            uint32_t const * p_data);
92  NRF_STATIC_INLINE uint32_t * nrf_ccm_outptr_get(NRF_CCM_Type const * p_reg);
93  NRF_STATIC_INLINE void nrf_ccm_scratchptr_set(NRF_CCM_Type *   p_reg,
94                                                uint32_t const * p_area);
95  NRF_STATIC_INLINE uint32_t * nrf_ccm_stratchptr_get(NRF_CCM_Type const * p_reg);
96  #if defined(CCM_RATEOVERRIDE_RATEOVERRIDE_Pos) || defined(__NRFX_DOXYGEN__)
97  NRF_STATIC_INLINE void nrf_ccm_datarate_override_set(NRF_CCM_Type *     p_reg,
98                                                       nrf_ccm_datarate_t datarate);
99  #endif 
100  #ifndef NRF_DECLARE_ONLY
101  NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
102                                              nrf_ccm_task_t task)
103  {
104      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
105  }
106  NRF_STATIC_INLINE uint32_t nrf_ccm_task_address_get(NRF_CCM_Type const * p_reg,
107                                                      nrf_ccm_task_t       task)
108  {
109      return ((uint32_t)p_reg + (uint32_t)task);
110  }
111  NRF_STATIC_INLINE void nrf_ccm_event_clear(NRF_CCM_Type *  p_reg,
112                                             nrf_ccm_event_t event)
113  {
114      *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
115  #if __CORTEX_M == 0x04
116      volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
117      (void)dummy;
118  #endif
119  }
120  NRF_STATIC_INLINE bool nrf_ccm_event_check(NRF_CCM_Type const * p_reg,
121                                             nrf_ccm_event_t      event)
122  {
123      return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
124  }
125  NRF_STATIC_INLINE uint32_t nrf_ccm_event_address_get(NRF_CCM_Type const * p_reg,
126                                                       nrf_ccm_event_t      event)
127  {
128      return ((uint32_t)p_reg + (uint32_t)event);
129  }
130  NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask)
131  {
132      p_reg->INTENSET = mask;
133  }
134  NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask)
135  {
136      p_reg->INTENCLR = mask;
137  }
138  NRF_STATIC_INLINE uint32_t nrf_ccm_int_enable_check(NRF_CCM_Type const * p_reg, uint32_t mask)
139  {
140      return p_reg->INTENSET & mask;
141  }
142  NRF_STATIC_INLINE void nrf_ccm_enable(NRF_CCM_Type * p_reg)
143  {
144      p_reg->ENABLE = (CCM_ENABLE_ENABLE_Enabled << CCM_ENABLE_ENABLE_Pos);
145  }
146  NRF_STATIC_INLINE void nrf_ccm_disable(NRF_CCM_Type * p_reg)
147  {
148      p_reg->ENABLE = (CCM_ENABLE_ENABLE_Disabled << CCM_ENABLE_ENABLE_Pos);
149  }
150  NRF_STATIC_INLINE void nrf_ccm_configure(NRF_CCM_Type *           p_reg,
151                                           nrf_ccm_config_t const * p_config)
152  {
153      p_reg->MODE = (((uint32_t)p_config->mode     << CCM_MODE_MODE_Pos) |
154  #if defined(CCM_MODE_DATARATE_Pos)
155                     ((uint32_t)p_config->datarate << CCM_MODE_DATARATE_Pos) |
156  #endif
157  #if defined(CCM_MODE_LENGTH_Pos)
158                     ((uint32_t)p_config->length   << CCM_MODE_LENGTH_Pos) |
159  #endif
160                     0);
161  }
162  #if defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos)
163  NRF_STATIC_INLINE void nrf_ccm_maxpacketsize_set(NRF_CCM_Type * p_reg,
164                                                   uint8_t        size)
165  {
166      NRFX_ASSERT((size >= 0x1B) && (size <= 0xFB));
167      p_reg->MAXPACKETSIZE = size;
168  }
169  #endif 
170  NRF_STATIC_INLINE bool nrf_ccm_micstatus_get(NRF_CCM_Type const * p_reg)
171  {
172      return (bool)(p_reg->MICSTATUS);
173  }
174  NRF_STATIC_INLINE void nrf_ccm_cnfptr_set(NRF_CCM_Type *   p_reg,
175                                            uint32_t const * p_data)
176  {
177      p_reg->CNFPTR = (uint32_t)p_data;
178  }
179  NRF_STATIC_INLINE uint32_t * nrf_ccm_cnfptr_get(NRF_CCM_Type const * p_reg)
180  {
181  #if defined(NRF5340_XXAA_NETWORK)
182      return (uint32_t *)(p_reg->CNFPTR | 0x01000000);
183  #else
184      return (uint32_t *)(p_reg->CNFPTR);
185  #endif
186  }
187  NRF_STATIC_INLINE void nrf_ccm_inptr_set(NRF_CCM_Type *   p_reg,
188                                           uint32_t const * p_data)
189  {
190      p_reg->INPTR = (uint32_t)p_data;
191  }
192  NRF_STATIC_INLINE uint32_t * nrf_ccm_inptr_get(NRF_CCM_Type const * p_reg)
193  {
194  #if defined(NRF5340_XXAA_NETWORK)
195      return (uint32_t *)(p_reg->INPTR | 0x01000000);
196  #else
197      return (uint32_t *)(p_reg->INPTR);
198  #endif
199  }
200  NRF_STATIC_INLINE void nrf_ccm_outptr_set(NRF_CCM_Type *   p_reg,
201                                            uint32_t const * p_data)
202  {
203      p_reg->OUTPTR = (uint32_t)p_data;
204  }
205  NRF_STATIC_INLINE uint32_t * nrf_ccm_outptr_get(NRF_CCM_Type const * p_reg)
206  {
207  #if defined(NRF5340_XXAA_NETWORK)
208      return (uint32_t *)(p_reg->OUTPTR | 0x01000000);
209  #else
210      return (uint32_t *)(p_reg->OUTPTR);
211  #endif
212  }
213  NRF_STATIC_INLINE void nrf_ccm_scratchptr_set(NRF_CCM_Type *   p_reg,
214                                                uint32_t const * p_area)
215  {
216      p_reg->SCRATCHPTR = (uint32_t)p_area;
217  }
218  NRF_STATIC_INLINE uint32_t * nrf_ccm_stratchptr_get(NRF_CCM_Type const * p_reg)
219  {
220  #if defined(NRF5340_XXAA_NETWORK)
221      return (uint32_t *)(p_reg->SCRATCHPTR | 0x01000000);
222  #else
223      return (uint32_t *)(p_reg->SCRATCHPTR);
224  #endif
225  }
226  #if defined(CCM_RATEOVERRIDE_RATEOVERRIDE_Pos)
227  NRF_STATIC_INLINE void nrf_ccm_datarate_override_set(NRF_CCM_Type *     p_reg,
228                                                       nrf_ccm_datarate_t datarate)
229  {
230      p_reg->RATEOVERRIDE = ((uint32_t)datarate << CCM_RATEOVERRIDE_RATEOVERRIDE_Pos);
231  }
232  #endif
233  #endif 
234  #ifdef __cplusplus
235  }
236  #endif
237  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-OclLaunchData.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrf_ccm.h</div>
                </div>
                <div class="column column_space"><pre><code>16      OclLaunchData(const Miner *miner, const Algorithm &algorithm, const OclConfig &config, const OclPlatform &platform, const OclThread &thread, const OclDevice &device, int64_t affinity);
17      bool isEqual(const OclLaunchData &other) const;
</pre></code></div>
                <div class="column column_space"><pre><code>64  NRF_STATIC_INLINE uint32_t nrf_ccm_task_address_get(NRF_CCM_Type const * p_reg,
65                                                      nrf_ccm_task_t       task);
66  NRF_STATIC_INLINE void nrf_ccm_event_clear(NRF_CCM_Type *  p_reg,
67                                             nrf_ccm_event_t event);
68  NRF_STATIC_INLINE bool nrf_ccm_event_check(NRF_CCM_Type const * p_reg,
69                                             nrf_ccm_event_t      event);
70  NRF_STATIC_INLINE uint32_t nrf_ccm_event_address_get(NRF_CCM_Type const * p_reg,
71                                                       nrf_ccm_event_t      event);
72  NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask);
73  NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask);
74  NRF_STATIC_INLINE uint32_t nrf_ccm_int_enable_check(NRF_CCM_Type const * p_reg, uint32_t mask);
75  NRF_STATIC_INLINE void nrf_ccm_enable(NRF_CCM_Type * p_reg);
76  NRF_STATIC_INLINE void nrf_ccm_disable(NRF_CCM_Type * p_reg);
77  NRF_STATIC_INLINE void nrf_ccm_configure(NRF_CCM_Type *           p_reg,
78                                           nrf_ccm_config_t const * p_config);
79  #if defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos) || defined(__NRFX_DOXYGEN__)
80  NRF_STATIC_INLINE void nrf_ccm_maxpacketsize_set(NRF_CCM_Type * p_reg,
81                                                   uint8_t        size);
82  #endif 
83  NRF_STATIC_INLINE bool nrf_ccm_micstatus_get(NRF_CCM_Type const * p_reg);
84  NRF_STATIC_INLINE void nrf_ccm_cnfptr_set(NRF_CCM_Type *   p_reg,
85                                            uint32_t const * p_data);
86  NRF_STATIC_INLINE uint32_t * nrf_ccm_cnfptr_get(NRF_CCM_Type const * p_reg);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    