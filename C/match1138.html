<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for mosaicing_dispatch.c &amp; arith_dispatch.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for mosaicing_dispatch.c &amp; arith_dispatch.c
      </h3>
<h1 align="center">
        31.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>mosaicing_dispatch.c (32.44147%)<th>arith_dispatch.c (29.709036%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(660-708)<td><a href="#" name="0">(233-296)</a><td align="center"><font color="#ff0000">30</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(610-645)<td><a href="#" name="1">(1046-1084)</a><td align="center"><font color="#aa0000">20</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(47-115)<td><a href="#" name="2">(45-77)</a><td align="center"><font color="#a10000">19</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(116-121)<td><a href="#" name="3">(881-887)</a><td align="center"><font color="#990000">18</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(220-250)<td><a href="#" name="4">(769-798)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(150-193)<td><a href="#" name="5">(176-206)</a><td align="center"><font color="#880000">16</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(549-586)<td><a href="#" name="6">(366-393)</a><td align="center"><font color="#6e0000">13</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(499-537)<td><a href="#" name="7">(299-325)</a><td align="center"><font color="#6e0000">13</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(388-419)<td><a href="#" name="8">(143-172)</a><td align="center"><font color="#6e0000">13</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(716-756)<td><a href="#" name="9">(1205-1275)</a><td align="center"><font color="#660000">12</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(456-489)<td><a href="#" name="10">(398-424)</a><td align="center"><font color="#660000">12</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(318-352)<td><a href="#" name="11">(704-729)</a><td align="center"><font color="#660000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mosaicing_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include &lt;vips/vips7compat.h&gt;
7 #include &lt;vips/internal.h&gt;
8 #include &lt;vips/transform.h&gt;
9 <a name="2"></a>
10 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static im_arg_desc merge_args[] = {
11 	IM_INPUT_IMAGE( "ref" ),
12 	IM_INPUT_IMAGE( "sec" ),
13 	IM_OUTPUT_IMAGE( "out" ),
14 	IM_INPUT_INT( "dx" ),
15 	IM_INPUT_INT( "dy" ),
16 	IM_INPUT_INT( "mwidth" )
17 };
18 static im_arg_desc merge1_args[] = {
19 	IM_INPUT_IMAGE( "ref" ),
20 	IM_INPUT_IMAGE( "sec" ),
21 	IM_OUTPUT_IMAGE( "out" ),
22 	IM_INPUT_INT( "xr1" ),
23 	IM_INPUT_INT( "yr1" ),
24 	IM_INPUT_INT( "xs1" ),
25 	IM_INPUT_INT( "ys1" ),
26 	IM_INPUT_INT( "xr2" ),
27 	IM_INPUT_INT( "yr2" ),
28 	IM_INPUT_INT( "xs2" ),
29 	IM_INPUT_INT( "ys2" ),
30 	IM_INPUT_INT( "mwidth" )
31 };
32 static im_arg_desc mosaic_args[] = {
33 	IM_INPUT_IMAGE( "ref" ),
34 	IM_INPUT_IMAGE( "sec" ),
35 	IM_OUTPUT_IMAGE( "out" ),
36 	IM_INPUT_INT( "bandno" ),
37 	IM_INPUT_INT( "xr" ),
38 	IM_INPUT_INT( "yr" ),
39 	IM_INPUT_INT( "xs" ),
40 	IM_INPUT_INT( "ys" ),
41 	IM_INPUT_INT( "halfcorrelation" ),
42 	IM_INPUT_INT( "halfarea" ),
43 	IM_INPUT_INT( "balancetype" ),
44 	IM_INPUT_INT( "mwidth" )
45 };
46 static im_arg_desc mosaic1_args[] = {
47 	IM_INPUT_IMAGE( "ref" ),
48 	IM_INPUT_IMAGE( "sec" ),
49 	IM_OUTPUT_IMAGE( "out" ),
50 	IM_INPUT_INT( "bandno" ),
51 	IM_INPUT_INT( "xr1" ),
52 	IM_INPUT_INT( "yr1" ),
53 	IM_INPUT_INT( "xs1" ),
54 	IM_INPUT_INT( "ys1" ),
55 	IM_INPUT_INT( "xr2" ),
56 	IM_INPUT_INT( "yr2" ),
57 	IM_INPUT_INT( "xs2" ),
58 	IM_INPUT_INT( "ys2" ),
59 	IM_INPUT_INT( "halfcorrelation" ),
60 	IM_INPUT_INT( "halfarea" ),
61 	IM_INPUT_INT( "balancetype" ),
62 	IM_INPUT_INT( "mwidth" )
63 };
64 <a name="3"></a>static int
65 lrmosaic_vec( im_object *argv )
66 {</b></font>
67 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int bandno = *((int *) argv[3]);
68 	int xr = *((int *) argv[4]);
69 	int yr = *((int *) argv[5]);
70 	int xs = *((int *) argv[6]);
71 	int ys = *((int *) argv[7]);
72 	int halfcorrelation = *((int *) argv[8]);</b></font>
73 	int halfarea = *((int *) argv[9]);
74 	int balancetype = *((int *) argv[10]);
75 	int mwidth = *((int *) argv[11]);
76 	return( vips__lrmosaic( argv[0], argv[1], argv[2], 
77 		bandno, 
78 		xr, yr, xs, ys, 
79 		halfcorrelation, halfarea,
80 		balancetype, mwidth ) );
81 }
82 static int
83 lrmosaic1_vec( im_object *argv )
84 {
85 	int bandno = *((int *) argv[3]);
86 	int xr1 = *((int *) argv[4]);
87 	int yr1 = *((int *) argv[5]);
88 	int xs1 = *((int *) argv[6]);
89 	int ys1 = *((int *) argv[7]);
90 	int xr2 = *((int *) argv[8]);
91 	int yr2 = *((int *) argv[9]);
92 	int xs2 = *((int *) argv[10]);
93 	int ys2 = *((int *) argv[11]);
94 <a name="5"></a>	int halfcorrelation = *((int *) argv[12]);
95 	int halfarea = *((int *) argv[13]);
96 	int balancetype = *((int *) argv[14]);
97 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int mwidth = *((int *) argv[15]);
98 	return( im_lrmosaic1( argv[0], argv[1], argv[2], 
99 		bandno, 
100 		xr1, yr1, xs1, ys1, 
101 		xr2, yr2, xs2, ys2, 
102 		halfcorrelation, halfarea,
103 		balancetype, mwidth ) );
104 }
105 static im_function lrmosaic_desc = {
106 	"im_lrmosaic", 				"left-right mosaic of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		lrmosaic_vec, 				IM_NUMBER( mosaic_args ), 			mosaic_args 			};
107 static im_arg_desc find_overlap_args[] = {
108 	IM_INPUT_IMAGE( "ref" ),
109 	IM_INPUT_IMAGE( "sec" ),
110 	IM_INPUT_INT( "bandno" ),
111 	IM_INPUT_INT( "xr" ),
112 	IM_INPUT_INT( "yr" ),
113 	IM_INPUT_INT( "xs" ),
114 	IM_INPUT_INT( "ys" ),
115 	IM_INPUT_INT( "halfcorrelation" ),
116 	IM_INPUT_INT( "halfarea" ),
117 	IM_OUTPUT_INT( "dx0" ),
118 	IM_OUTPUT_INT( "dy0" ),
119 	IM_OUTPUT_DOUBLE( "scale1" ),
120 	IM_OUTPUT_DOUBLE( "angle1" ),
121 	IM_OUTPUT_DOUBLE( "dx1" ),
122 	IM_OUTPUT_DOUBLE( "dy1" )
123 };
124 static int
125 find_lroverlap_vec( im_object *argv )
126 {</b></font>
127 	int bandno = *((int *) argv[2]);
128 	int xr = *((int *) argv[3]);
129 	int yr = *((int *) argv[4]);
130 	int xs = *((int *) argv[5]);
131 	int ys = *((int *) argv[6]);
132 	int halfcorrelation = *((int *) argv[7]);
133 	int halfarea = *((int *) argv[8]);
134 	int *dx0 = (int *) argv[9];
135 	int *dy0 = (int *) argv[10];
136 	double *scale1 = (double *) argv[11];
137 	double *angle1 = (double *) argv[12];
138 	double *dx1 = (double *) argv[13];
139 	double *dy1 = (double *) argv[14];
140 	IMAGE *t;
141 	int result;
142 	if( !(t = im_open( "find_lroverlap_vec", "p" )) )
143 		return( -1 );
144 	result = vips__find_lroverlap( argv[0], argv[1], t, 
145 		bandno, 
146 		xr, yr, xs, ys, 
147 		halfcorrelation, halfarea,
148 <a name="4"></a>		dx0, dy0, scale1, angle1, dx1, dy1 );
149 	im_close( t );
150 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( result );
151 }
152 static im_function find_lroverlap_desc = {
153 	"im__find_lroverlap",			"search for left-right overlap of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		find_lroverlap_vec, 			IM_NUMBER( find_overlap_args ),		find_overlap_args 		};
154 static im_function lrmosaic1_desc = {
155 	"im_lrmosaic1",				"first-order left-right mosaic of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		lrmosaic1_vec, 				IM_NUMBER( mosaic1_args ), 		mosaic1_args 			};
156 static int
157 tbmosaic_vec( im_object *argv )
158 {
159 	int bandno = *((int *) argv[3]);</b></font>
160 	int x1 = *((int *) argv[4]);
161 	int y1 = *((int *) argv[5]);
162 	int x2 = *((int *) argv[6]);
163 	int y2 = *((int *) argv[7]);
164 	int halfcorrelation = *((int *) argv[8]);
165 	int halfarea = *((int *) argv[9]);
166 	int balancetype = *((int *) argv[10]);
167 	int mwidth = *((int *) argv[11]);
168 	return( vips__tbmosaic( argv[0], argv[1], argv[2], 
169 		bandno, 
170 		x1, y1, x2, y2, 
171 		halfcorrelation, halfarea,
172 		balancetype, mwidth ) );
173 }
174 static int
175 tbmosaic1_vec( im_object *argv )
176 {
177 	int bandno = *((int *) argv[3]);
178 	int xr1 = *((int *) argv[4]);
179 	int yr1 = *((int *) argv[5]);
180 	int xs1 = *((int *) argv[6]);
181 	int ys1 = *((int *) argv[7]);
182 	int xr2 = *((int *) argv[8]);
183 	int yr2 = *((int *) argv[9]);
184 	int xs2 = *((int *) argv[10]);
185 	int ys2 = *((int *) argv[11]);
186 	int halfcorrelation = *((int *) argv[12]);
187 	int halfarea = *((int *) argv[13]);
188 	int balancetype = *((int *) argv[14]);
189 	int mwidth = *((int *) argv[15]);
190 	return( im_tbmosaic1( argv[0], argv[1], argv[2], 
191 		bandno, 
192 		xr1, yr1, xs1, ys1, 
193 		xr2, yr2, xs2, ys2, 
194 		halfcorrelation, halfarea,
195 		balancetype, mwidth ) );
196 }
197 static int
198 find_tboverlap_vec( im_object *argv )
199 {
200 	int bandno = *((int *) argv[2]);
201 	int xr = *((int *) argv[3]);
202 	int yr = *((int *) argv[4]);
203 	int xs = *((int *) argv[5]);
204 	int ys = *((int *) argv[6]);
205 	int halfcorrelation = *((int *) argv[7]);
206 	int halfarea = *((int *) argv[8]);
207 	int *dx0 = (int *) argv[9];
208 	int *dy0 = (int *) argv[10];
209 	double *scale1 = (double *) argv[11];
210 	double *angle1 = (double *) argv[12];
211 	double *dx1 = (double *) argv[13];
212 	double *dy1 = (double *) argv[14];
213 	IMAGE *t;
214 	int result;
215 <a name="11"></a>
216 	if( !(t = im_open( "find_tboverlap_vec", "p" )) )
217 		return( -1 );
218 <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	result = vips__find_tboverlap( argv[0], argv[1], t, 
219 		bandno, 
220 		xr, yr, xs, ys, 
221 		halfcorrelation, halfarea,
222 		dx0, dy0, scale1, angle1, dx1, dy1 );
223 	im_close( t );
224 	return( result );
225 }
226 static im_function find_tboverlap_desc = {
227 	"im__find_tboverlap",			"search for top-bottom overlap of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		find_tboverlap_vec, 			IM_NUMBER( find_overlap_args ),		find_overlap_args 		};
228 static im_function tbmosaic_desc = {
229 	"im_tbmosaic", 				"top-bottom mosaic of in1 and in2",	IM_FN_TRANSFORM | IM_FN_PIO,		tbmosaic_vec, 				IM_NUMBER( mosaic_args ), 			mosaic_args 			};
230 static im_function tbmosaic1_desc = {</b></font>
231 	"im_tbmosaic1",				"first-order top-bottom mosaic of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		tbmosaic1_vec, 				IM_NUMBER( mosaic1_args ), 		mosaic1_args 			};
232 static int
233 lrmerge_vec( im_object *argv )
234 {
235 	int dx = *((int *) argv[3]);
236 	int dy = *((int *) argv[4]);
237 	int mwidth = *((int *) argv[5]);
238 	return( im_lrmerge( argv[0], argv[1], argv[2], dx, dy, mwidth ) );
239 }
240 static int
241 lrmerge1_vec( im_object *argv )
242 {
243 	int xr1 = *((int *) argv[3]);
244 	int yr1 = *((int *) argv[4]);
245 	int xs1 = *((int *) argv[5]);
246 	int ys1 = *((int *) argv[6]);
247 	int xr2 = *((int *) argv[7]);
248 	int yr2 = *((int *) argv[8]);
249 	int xs2 = *((int *) argv[9]);
250 <a name="8"></a>	int ys2 = *((int *) argv[10]);
251 	int mwidth = *((int *) argv[11]);
252 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_lrmerge1( argv[0], argv[1], argv[2], 
253 		xr1, yr1, xs1, ys1, 
254 		xr2, yr2, xs2, ys2, mwidth ) ); 
255 }
256 static im_function lrmerge_desc = {
257 	"im_lrmerge", 				"left-right merge of in1 and in2",	IM_FN_TRANSFORM | IM_FN_PIO,		lrmerge_vec, 				IM_NUMBER( merge_args ), 			merge_args 			};
258 static im_function lrmerge1_desc = {
259 	"im_lrmerge1", 				"first-order left-right merge of ref and sec",	IM_FN_TRANSFORM | IM_FN_PIO,		lrmerge1_vec, 				IM_NUMBER( merge1_args ), 			merge1_args 			};
260 static int
261 tbmerge_vec( im_object *argv )
262 {</b></font>
263 	int dx = *((int *) argv[3]);
264 	int dy = *((int *) argv[4]);
265 	int mwidth = *((int *) argv[5]);
266 	return( im_tbmerge( argv[0], argv[1], argv[2], dx, dy, mwidth ) );
267 }
268 static int
269 tbmerge1_vec( im_object *argv )
270 {
271 	int xr1 = *((int *) argv[3]);
272 	int yr1 = *((int *) argv[4]);
273 	int xs1 = *((int *) argv[5]);
274 	int ys1 = *((int *) argv[6]);
275 	int xr2 = *((int *) argv[7]);
276 	int yr2 = *((int *) argv[8]);
277 	int xs2 = *((int *) argv[9]);
278 	int ys2 = *((int *) argv[10]);
279 	int mwidth = *((int *) argv[11]);
280 	return( im_tbmerge1( argv[0], argv[1], argv[2], 
281 		xr1, yr1, xs1, ys1, 
282 		xr2, yr2, xs2, ys2, mwidth ) ); 
283 }
284 static im_function tbmerge_desc = {
285 	"im_tbmerge", 				"top-bottom merge of in1 and in2",	IM_FN_TRANSFORM | IM_FN_PIO,	<a name="10"></a>	tbmerge_vec, 				IM_NUMBER( merge_args ), 			merge_args 			<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
286 static im_function tbmerge1_desc = {
287 	"im_tbmerge1", 				"first-order top-bottom merge of in1 and in2",	IM_FN_TRANSFORM | IM_FN_PIO,		tbmerge1_vec, 				IM_NUMBER( merge1_args ), 			merge1_args 			};
288 static im_arg_desc match_linear_args[] = {
289 	IM_INPUT_IMAGE( "ref" ),
290 	IM_INPUT_IMAGE( "sec" ),
291 	IM_OUTPUT_IMAGE( "out" ),
292 	IM_INPUT_INT( "xref1" ),
293 	IM_INPUT_INT( "yref1" ),
294 	IM_INPUT_INT( "xsec1" ),
295 	IM_INPUT_INT( "ysec1" ),
296 	IM_INPUT_INT( "xref2" ),
297 	IM_INPUT_INT( "yref2" ),
298 	IM_INPUT_INT( "xsec2" ),
299 	IM_INPUT_INT( "ysec2" )
300 };
301 static int
302 match_linear_vec( im_object *argv )
303 {</b></font>
304 	int xref1 = *((int *) argv[3]);
305 	int yref1 = *((int *) argv[4]);
306 	int xsec1 = *((int *) argv[5]);
307 	int ysec1 = *((int *) argv[6]);
308 	int xref2 = *((int *) argv[7]);
309 	int yref2 = *((int *) argv[8]);
310 <a name="7"></a>	int xsec2 = *((int *) argv[9]);
311 	int ysec2 = *((int *) argv[10]);
312 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_match_linear( argv[0], argv[1], argv[2],
313 		xref1, yref1, xsec1, ysec1, 
314 		xref2, yref2, xsec2, ysec2 ) );
315 }
316 static im_function match_linear_desc = {
317 	"im_match_linear", 			"resample ref so that tie-points match",
318 	IM_FN_PIO,				match_linear_vec, 			IM_NUMBER( match_linear_args ), 		match_linear_args 		};
319 static im_arg_desc match_linear_search_args[] = {
320 	IM_INPUT_IMAGE( "ref" ),
321 	IM_INPUT_IMAGE( "sec" ),
322 	IM_OUTPUT_IMAGE( "out" ),
323 	IM_INPUT_INT( "xref1" ),
324 	IM_INPUT_INT( "yref1" ),
325 	IM_INPUT_INT( "xsec1" ),
326 	IM_INPUT_INT( "ysec1" ),
327 	IM_INPUT_INT( "xref2" ),
328 	IM_INPUT_INT( "yref2" ),
329 	IM_INPUT_INT( "xsec2" ),
330 	IM_INPUT_INT( "ysec2" ),
331 	IM_INPUT_INT( "hwindowsize" ),
332 	IM_INPUT_INT( "hsearchsize" )
333 };
334 static int
335 match_linear_search_vec( im_object *argv )
336 {</b></font>
337 	int xref1 = *((int *) argv[3]);
338 	int yref1 = *((int *) argv[4]);
339 	int xsec1 = *((int *) argv[5]);
340 	int ysec1 = *((int *) argv[6]);
341 	int xref2 = *((int *) argv[7]);
342 	int yref2 = *((int *) argv[8]);
343 	int xsec2 = *((int *) argv[9]);
344 	int ysec2 = *((int *) argv[10]);
345 <a name="6"></a>	int hwin = *((int *) argv[11]);
346 	int hsrch = *((int *) argv[12]);
347 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_match_linear_search( argv[0], argv[1], argv[2],
348 		xref1, yref1, xsec1, ysec1, 
349 		xref2, yref2, xsec2, ysec2,
350 		hwin, hsrch ) );
351 }
352 static im_function match_linear_search_desc = {
353 	"im_match_linear_search", 		"search sec, then resample so that tie-points match",
354 	IM_FN_PIO,				match_linear_search_vec, 		IM_NUMBER( match_linear_search_args ),	match_linear_search_args 	};
355 static im_arg_desc correl_args[] = {
356 	IM_INPUT_IMAGE( "ref" ),
357 	IM_INPUT_IMAGE( "sec" ),
358 	IM_INPUT_INT( "xref" ),
359 	IM_INPUT_INT( "yref" ),
360 	IM_INPUT_INT( "xsec" ),
361 	IM_INPUT_INT( "ysec" ),
362 	IM_INPUT_INT( "hwindowsize" ),
363 	IM_INPUT_INT( "hsearchsize" ),
364 	IM_OUTPUT_DOUBLE( "correlation" ),
365 	IM_OUTPUT_INT( "x" ),
366 	IM_OUTPUT_INT( "y" )
367 };
368 static int
369 correl_vec( im_object *argv )
370 {</b></font>
371 	int xref = *((int *) argv[2]);
372 	int yref = *((int *) argv[3]);
373 	int xsec = *((int *) argv[4]);
374 	int ysec = *((int *) argv[5]);
375 	int cor = *((int *) argv[6]);
376 	int area = *((int *) argv[7]);
377 	int *x = (int *) argv[8];
378 	int *y = (int *) argv[9];
379 	double *correlation = (double *) argv[10];
380 	return( vips__correl( argv[0], argv[1], 
381 		xref, yref, xsec, ysec, cor, area, correlation, x, y ) );
382 }
383 static im_function correl_desc = {
384 	"im_correl", 				"search area around sec for match for area around ref",
385 	IM_FN_PIO,			<a name="1"></a>	correl_vec, 				IM_NUMBER( correl_args ), 			correl_args 			<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
386 static im_arg_desc global_balance_args[] = {
387 	IM_INPUT_IMAGE( "in" ),
388 	IM_OUTPUT_IMAGE( "out" ),
389 	IM_INPUT_DOUBLE( "gamma" )
390 };
391 static int
392 global_balance_vec( im_object *argv )
393 {
394 	double gamma = *((double *) argv[2]);
395 	return( im_global_balance( argv[0], argv[1], gamma ) );
396 }
397 static im_function global_balance_desc = {
398 	"im_global_balance",			"automatically rebuild mosaic with balancing",
399 	IM_FN_TRANSFORM | IM_FN_PIO,		global_balance_vec, 			IM_NUMBER( global_balance_args ),		global_balance_args 		};
400 static int
401 global_balancef_vec( im_object *argv )
402 {</b></font>
403 	double gamma = *((double *) argv[2]);
404 	return( im_global_balancef( argv[0], argv[1], gamma ) );
405 }
406 static im_function global_balancef_desc = {
407 	"im_global_balancef",			"automatically rebuild mosaic with balancing, float output",
408 	IM_FN_TRANSFORM | IM_FN_PIO,	<a name="0"></a>	global_balancef_vec, 			IM_NUMBER( global_balance_args ),		global_balance_args 		<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
409 static im_arg_desc remosaic_args[] = {
410 	IM_INPUT_IMAGE( "in" ),
411 	IM_OUTPUT_IMAGE( "out" ),
412 	IM_INPUT_STRING( "old_str" ),
413 	IM_INPUT_STRING( "new_str" )
414 };
415 static int
416 remosaic_vec( im_object *argv )
417 {
418 	return( im_remosaic( argv[0], argv[1], argv[2], argv[3] ) );
419 }
420 static im_function remosaic_desc = {
421 	"im_remosaic",			"automatically rebuild mosaic with new files",
422 	IM_FN_TRANSFORM | IM_FN_PIO,		remosaic_vec, 			IM_NUMBER( remosaic_args ),	remosaic_args 		};
423 static int align_bands_vec( im_object *argv ){
424   return im_align_bands( (IMAGE*)argv[0], (IMAGE*)argv[1] );
425 }
426 static im_arg_desc align_bands_arg_types[]= {
427   IM_INPUT_IMAGE( "in" ),
428   IM_OUTPUT_IMAGE( "out" )
429 };
430 static im_function align_bands_desc= {
431   "im_align_bands",
432   "align the bands of an image",
433   0,
434   align_bands_vec,
435   IM_NUMBER( align_bands_arg_types ),
436   align_bands_arg_types
437 };
438 static int maxpos_subpel_vec( im_object *argv ){</b></font>
439   return im_maxpos_subpel( (IMAGE*)argv[0], (double*)argv[1], (double*)argv[2] );
440 }
441 static im_arg_desc maxpos_subpel_arg_types[]= {
442 <a name="9"></a>  IM_INPUT_IMAGE( "im" ),
443   IM_OUTPUT_DOUBLE( "x" ),
444   IM_OUTPUT_DOUBLE( "y" )
445 <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
446 static im_function maxpos_subpel_desc= {
447   "im_maxpos_subpel",
448   "subpixel position of maximum of (phase correlation) image",
449   IM_FN_PIO,
450   maxpos_subpel_vec,
451   IM_NUMBER( maxpos_subpel_arg_types ),
452   maxpos_subpel_arg_types
453 };
454 static im_function *mos_list[] = {
455         &amp;align_bands_desc,
456 	&amp;correl_desc,
457 	&amp;find_lroverlap_desc,
458 	&amp;find_tboverlap_desc,
459 	&amp;global_balance_desc,
460 	&amp;global_balancef_desc,
461 	&amp;lrmerge_desc,
462 	&amp;lrmerge1_desc,
463 	&amp;lrmosaic_desc,
464 	&amp;lrmosaic1_desc,
465 	&amp;match_linear_desc,
466 	&amp;match_linear_search_desc,
467         &amp;maxpos_subpel_desc,
468 	&amp;remosaic_desc,
469 	&amp;tbmerge_desc,
470 	&amp;tbmerge1_desc,
471 	&amp;tbmosaic_desc,
472 	&amp;tbmosaic1_desc
473 };
474 im_package im__mosaicing = {
475 	"mosaicing",
476 	IM_NUMBER( mos_list ),
477 	mos_list
478 };</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>arith_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include &lt;vips/vips7compat.h&gt;
7 <a name="2"></a>
8 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static im_arg_desc one_in_one_out[] = {
9 	IM_INPUT_IMAGE( "in" ),
10 	IM_OUTPUT_IMAGE( "out" )
11 };
12 static im_arg_desc two_in_one_out[] = {
13 	IM_INPUT_IMAGE( "in1" ),
14 	IM_INPUT_IMAGE( "in2" ),
15 	IM_OUTPUT_IMAGE( "out" )
16 };
17 static im_arg_desc image_in_num_out[] = {
18 	IM_INPUT_IMAGE( "in" ),
19 	IM_OUTPUT_DOUBLE( "value" )
20 };
21 static im_arg_desc recomb_args[] = {
22 	IM_INPUT_IMAGE( "in" ),
23 	IM_OUTPUT_IMAGE( "out" ),
24 	IM_INPUT_DMASK( "matrix" )
25 };
26 static int
27 recomb_vec( im_object *argv )
28 {</b></font>
29 	im_mask_object *mo = argv[2];
30 	return( im_recomb( argv[0], argv[1], mo-&gt;mask ) );
31 }
32 static im_function recomb_desc = {
33 	"im_recomb", 				"linear recombination with mask",
34 	IM_FN_PIO,				recomb_vec, 				IM_NUMBER( recomb_args ), 		recomb_args 			};
35 static int
36 abs_vec( im_object *argv )
37 {
38 	return( im_abs( argv[0], argv[1] ) );
39 }
40 static im_function abs_desc = {
41 	"im_abs", 				N_( "absolute value" ),			IM_FN_PIO | IM_FN_PTOP,			abs_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
42 static int
43 add_vec( im_object *argv )
44 {
45 	return( im_add( argv[0], argv[1], argv[2] ) );
46 }
47 static im_function add_desc = {
48 	"im_add", 				N_( "add two images" ),			IM_FN_PIO | IM_FN_PTOP,			add_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
49 static int
50 avg_vec( im_object *argv )
51 {
52 	double f;
53 	if( im_avg( argv[0], &amp;f ) )
54 <a name="8"></a>		return( -1 );
55 	*((double *) argv[1]) = f;
56 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
57 }
58 static im_function avg_desc = {
59 	"im_avg", 				N_( "average value of image" ),		IM_FN_PIO,				avg_vec, 				IM_NUMBER( image_in_num_out ), 		image_in_num_out 		};
60 static im_arg_desc point_args[] = {
61 	IM_INPUT_IMAGE( "in" ),
62 	IM_INPUT_INTERPOLATE( "interpolate" ),
63 	IM_INPUT_DOUBLE( "x" ),
64 	IM_INPUT_DOUBLE( "y" ),
65 	IM_INPUT_INT( "band" ),
66 	IM_OUTPUT_DOUBLE( "out" )
67 };
68 static int
69 point_vec( im_object *argv )
70 {</b></font>
71 <a name="5"></a>	VipsInterpolate *interpolate = VIPS_INTERPOLATE( argv[1] );
72 	double x = *((double *) argv[2]);
73 	double y = *((double *) argv[3]);
74 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int band = *((int *) argv[4]);
75 	return( im_point( argv[0], interpolate, x, y, band, argv[5] ) );
76 }
77 static im_function point_desc = {
78 	"im_point",
79 	"interpolate value at single point",
80 	IM_FN_PIO,
81 	point_vec,
82 	IM_NUMBER( point_args ),
83 	point_args
84 };
85 static im_arg_desc point_bilinear_args[] = {
86   IM_INPUT_IMAGE ("in"),
87   IM_INPUT_DOUBLE("x"),
88   IM_INPUT_DOUBLE("y"),
89   IM_INPUT_INT("band"),
90   IM_OUTPUT_DOUBLE("val")
91 };
92 static int
93 point_bilinear_vec( im_object *argv )
94 {</b></font>
95   return im_point_bilinear( argv[0], *(double*)argv[1], *(double*)argv[2], *(int*)argv[3], argv[4] );
96 }
97 static im_function point_bilinear_desc = {
98   "im_point_bilinear",
99   "interpolate value at single point, linearly",
100   IM_FN_PIO,
101   point_bilinear_vec,
102   IM_NUMBER( point_bilinear_args ),
103   point_bilinear_args
104 };
105 static int
106 deviate_vec( im_object *argv )
107 {
108 	double f;
109 	if( im_deviate( argv[0], &amp;f ) )
110 		return( -1 );
111 <a name="0"></a>
112 	*((double *) argv[1]) = f;
113 	return( 0 );
114 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
115 static im_function deviate_desc = {
116 	"im_deviate", 				N_( "standard deviation of image" ),		IM_FN_PIO,				deviate_vec, 				IM_NUMBER( image_in_num_out ), 		image_in_num_out 		};
117 static int
118 exp10tra_vec( im_object *argv )
119 {
120 	return( im_exp10tra( argv[0], argv[1] ) );
121 }
122 static im_function exp10tra_desc = {
123 	"im_exp10tra", 				N_( "10^pel of image" ),		IM_FN_PIO | IM_FN_PTOP,			exp10tra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
124 static int
125 exptra_vec( im_object *argv )
126 {
127 	return( im_exptra( argv[0], argv[1] ) );
128 }
129 static im_function exptra_desc = {
130 	"im_exptra", 				N_( "e^pel of image" ),			IM_FN_PIO | IM_FN_PTOP,			exptra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
131 static im_arg_desc powtra_args[] = {
132 	IM_INPUT_IMAGE( "in" ),
133 	IM_OUTPUT_IMAGE( "out" ),
134 	IM_INPUT_DOUBLE( "x" )
135 };
136 static int
137 expntra_vec( im_object *argv )
138 <a name="7"></a>{</b></font>
139 	double a = *((double *) argv[2]);
140 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_expntra( argv[0], argv[1], a ) );
141 }
142 static im_function expntra_desc = {
143 	"im_expntra", 				N_( "x^pel of image" ),			IM_FN_PIO | IM_FN_PTOP,			expntra_vec, 				IM_NUMBER( powtra_args ), 		powtra_args 			};
144 static im_arg_desc expntra_vec_args[] = {
145 	IM_INPUT_IMAGE( "in" ),
146 	IM_OUTPUT_IMAGE( "out" ),
147 	IM_INPUT_DOUBLEVEC( "v" )
148 };
149 static int
150 expntra_vec_vec( im_object *argv )
151 {</b></font>
152 	im_doublevec_object *rv = (im_doublevec_object *) argv[2];
153 	return( im_expntra_vec( argv[0], argv[1], rv-&gt;n, rv-&gt;vec ) );
154 }
155 static im_function expntra_vec_desc = {
156 	"im_expntra_vec", 			N_( "[x,y,z]^pel of image" ),		IM_FN_PIO | IM_FN_PTOP,			expntra_vec_vec, 			IM_NUMBER( expntra_vec_args ), 		expntra_vec_args 		};
157 static int
158 divide_vec( im_object *argv )
159 {
160 	return( im_divide( argv[0], argv[1], argv[2] ) );
161 }
162 static im_function divide_desc = {
163 	"im_divide", 				N_( "divide two images" ),
164 	IM_FN_PIO,				divide_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
165 <a name="6"></a>static int
166 invert_vec( im_object *argv )
167 {
168 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_invert( argv[0], argv[1] ) );
169 }
170 static im_function invert_desc = {
171 	"im_invert", 				N_( "photographic negative" ),		IM_FN_PIO | IM_FN_PTOP,			invert_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
172 static im_arg_desc lintra_args[] = {
173 	IM_INPUT_DOUBLE( "a" ),
174 	IM_INPUT_IMAGE( "in" ),
175 	IM_INPUT_DOUBLE( "b" ),
176 	IM_OUTPUT_IMAGE( "out" )
177 };
178 static int
179 lintra_vec( im_object *argv )
180 {</b></font>
181 	double a = *((double *) argv[0]);
182 <a name="10"></a>	double b = *((double *) argv[2]);
183 	return( im_lintra( a, argv[1], b, argv[3] ) );
184 <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
185 static im_function lintra_desc = {
186 	"im_lintra", 				N_( "calculate a*in + b = outfile" ),
187 	IM_FN_PIO | IM_FN_PTOP,			lintra_vec, 				IM_NUMBER( lintra_args ), 		lintra_args 			};
188 static im_arg_desc lintra_vec_args[] = {
189 	IM_INPUT_DOUBLEVEC( "a" ),
190 	IM_INPUT_IMAGE( "in" ),
191 	IM_INPUT_DOUBLEVEC( "b" ),
192 	IM_OUTPUT_IMAGE( "out" )
193 };
194 static int
195 lintra_vec_vec( im_object *argv )
196 {</b></font>
197 	im_doublevec_object *dva = (im_doublevec_object *) argv[0];
198 	im_doublevec_object *dvb = (im_doublevec_object *) argv[2];
199 	if( dva-&gt;n != dvb-&gt;n ) {
200 		im_error( "im_lintra_vec", 
201 			"%s", _( "vectors not equal length" ) );
202 		return( -1 );
203 	}
204 	return( im_lintra_vec( dva-&gt;n, dva-&gt;vec, argv[1], dvb-&gt;vec, argv[3] ) );
205 }
206 static im_function lintra_vec_desc = {
207 	"im_lintra_vec", 			N_( "calculate a*in + b -&gt; out, a and b vectors" ),
208 	IM_FN_PIO | IM_FN_PTOP,			lintra_vec_vec, 			IM_NUMBER( lintra_vec_args ), 		lintra_vec_args 		};
209 static int
210 log10tra_vec( im_object *argv )
211 {
212 	return( im_log10tra( argv[0], argv[1] ) );
213 }
214 static im_function log10tra_desc = {
215 	"im_log10tra", 				N_( "log10 of image" ),			IM_FN_PIO | IM_FN_PTOP,			log10tra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
216 static int
217 logtra_vec( im_object *argv )
218 {
219 	return( im_logtra( argv[0], argv[1] ) );
220 }
221 static im_function logtra_desc = {
222 	"im_logtra", 				N_( "ln of image" ),			IM_FN_PIO | IM_FN_PTOP,			logtra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
223 static int
224 tantra_vec( im_object *argv )
225 {
226 	return( im_tantra( argv[0], argv[1] ) );
227 }
228 static im_function tantra_desc = {
229 	"im_tantra", 				N_( "tan of image (angles in degrees)" ),
230 	IM_FN_PIO | IM_FN_PTOP,			tantra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
231 static int
232 atantra_vec( im_object *argv )
233 {
234 	return( im_atantra( argv[0], argv[1] ) );
235 }
236 static im_function atantra_desc = {
237 	"im_atantra", 				N_( "atan of image (result in degrees)" ),
238 	IM_FN_PIO | IM_FN_PTOP,			atantra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
239 static int
240 costra_vec( im_object *argv )
241 {
242 	return( im_costra( argv[0], argv[1] ) );
243 }
244 static im_function costra_desc = {
245 	"im_costra", 				N_( "cos of image (angles in degrees)" ),
246 	IM_FN_PIO | IM_FN_PTOP,			costra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
247 static int
248 acostra_vec( im_object *argv )
249 {
250 	return( im_acostra( argv[0], argv[1] ) );
251 }
252 static im_function acostra_desc = {
253 	"im_acostra", 				N_( "acos of image (result in degrees)" ),
254 	IM_FN_PIO | IM_FN_PTOP,			acostra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
255 static int
256 ceil_vec( im_object *argv )
257 {
258 	return( im_ceil( argv[0], argv[1] ) );
259 }
260 static im_function ceil_desc = {
261 	"im_ceil", 				N_( "round to smallest integer value not less than" ),
262 	IM_FN_PIO | IM_FN_PTOP,			ceil_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
263 static int
264 floor_vec( im_object *argv )
265 {
266 	return( im_floor( argv[0], argv[1] ) );
267 }
268 static im_function floor_desc = {
269 	"im_floor", 				N_( "round to largest integer value not greater than" ),
270 	IM_FN_PIO | IM_FN_PTOP,			floor_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
271 static int
272 rint_vec( im_object *argv )
273 {
274 	return( im_rint( argv[0], argv[1] ) );
275 }
276 static im_function rint_desc = {
277 	"im_rint", 				N_( "round to nearest integer value" ),
278 	IM_FN_PIO | IM_FN_PTOP,			rint_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
279 static int
280 sintra_vec( im_object *argv )
281 {
282 	return( im_sintra( argv[0], argv[1] ) );
283 }
284 static im_function sintra_desc = {
285 	"im_sintra", 				N_( "sin of image (angles in degrees)" ),
286 	IM_FN_PIO | IM_FN_PTOP,			sintra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
287 static int
288 bandmean_vec( im_object *argv )
289 {
290 	return( im_bandmean( argv[0], argv[1] ) );
291 }
292 static im_function bandmean_desc = {
293 	"im_bandmean", 				N_( "average image bands" ),
294 	IM_FN_PIO,				bandmean_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
295 static int
296 sign_vec( im_object *argv )
297 {
298 	return( im_sign( argv[0], argv[1] ) );
299 }
300 static im_function sign_desc = {
301 	"im_sign", 				N_( "unit vector in direction of value" ),
302 	IM_FN_PIO | IM_FN_PTOP,			sign_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
303 static int
304 asintra_vec( im_object *argv )
305 {
306 	return( im_asintra( argv[0], argv[1] ) );
307 }
308 static im_function asintra_desc = {
309 	"im_asintra", 				N_( "asin of image (result in degrees)" ),
310 	IM_FN_PIO | IM_FN_PTOP,			asintra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
311 static int
312 max_vec( im_object *argv )
313 {
314 	double f;
315 <a name="11"></a>
316 	if( im_max( argv[0], &amp;f ) )
317 		return( -1 );
318 <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	*((double *) argv[1]) = f;
319 	return( 0 );
320 }
321 static im_function max_desc = {
322 	"im_max", 				N_( "maximum value of image" ),		IM_FN_PIO,				max_vec, 				IM_NUMBER( image_in_num_out ), 		image_in_num_out 		};
323 static im_arg_desc maxpos_args[] = {
324 	IM_INPUT_IMAGE( "in" ),
325 	IM_OUTPUT_COMPLEX( "position" )
326 };
327 static int</b></font>
328 maxpos_vec( im_object *argv )
329 {
330 	double f;
331 	int x, y;
332 	if( im_maxpos( argv[0], &amp;x, &amp;y, &amp;f ) )
333 		return( -1 );
334 	((double *) argv[1])[0] = x;
335 	((double *) argv[1])[1] = y;
336 	return( 0 );
337 }
338 static im_function maxpos_desc = {
339 	"im_maxpos", 				N_( "position of maximum value of image" ),
340 	0,					maxpos_vec, 				IM_NUMBER( maxpos_args ), 		maxpos_args 			};
341 static im_arg_desc maxpos_avg_args[] = {
342   IM_INPUT_IMAGE ("in"),
343   IM_OUTPUT_DOUBLE("x"),
344   IM_OUTPUT_DOUBLE("y"),
345   IM_OUTPUT_DOUBLE("out")
346 };
347 <a name="4"></a>static int
348 maxpos_avg_vec( im_object *argv )
349 {
350 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  return im_maxpos_avg( argv[0], argv[1], argv[2], argv[3] );
351 }
352 static im_function maxpos_avg_desc = {
353   "im_maxpos_avg",
354   N_( "position of maximum value of image, averaging in case of draw" ),
355   IM_FN_PIO,
356   maxpos_avg_vec,
357   IM_NUMBER( maxpos_avg_args ),
358   maxpos_avg_args
359 };
360 static im_arg_desc maxpos_vec_args[] = {
361   IM_INPUT_IMAGE ("in"),
362   IM_INPUT_INT ("n"),
363   IM_OUTPUT_INTVEC("xes"),
364   IM_OUTPUT_INTVEC("yes"),
365   IM_OUTPUT_DOUBLEVEC("maxima")
366 };
367 static int
368 maxpos_vec_vec( im_object *argv )
369 {
370   int n = *((int *) argv[1]);</b></font>
371   im_intvec_object *xes = argv[2];
372   im_intvec_object *yes = argv[3];
373   im_doublevec_object *maxima = argv[4];
374   xes-&gt;vec = IM_ARRAY( NULL, n, int );
375   xes-&gt;n = n;
376   yes-&gt;vec = IM_ARRAY( NULL, n, int );
377   yes-&gt;n = n;
378   maxima-&gt;vec = IM_ARRAY( NULL, n, double );
379   maxima-&gt;n = n;
380   if( !xes-&gt;vec || !yes-&gt;vec || !maxima-&gt;vec ||
381     im_maxpos_vec( argv[0], xes-&gt;vec, yes-&gt;vec, maxima-&gt;vec, n ) )
382     return -1;
383   return 0;
384 }
385 static im_function maxpos_vec_desc = {
386   "im_maxpos_vec",
387   N_( "position and value of n maxima of image" ),
388   IM_FN_PIO,
389   maxpos_vec_vec,
390   IM_NUMBER( maxpos_vec_args ),
391   maxpos_vec_args
392 };
393 static int
394 minpos_vec_vec( im_object *argv )
395 {
396   int n = *((int *) argv[1]);
397   im_intvec_object *xes = argv[2];
398   im_intvec_object *yes = argv[3];
399   im_doublevec_object *minima = argv[4];
400   xes-&gt;vec = IM_ARRAY( NULL, n, int );
401   xes-&gt;n = n;
402   yes-&gt;vec = IM_ARRAY( NULL, n, int );
403   yes-&gt;n = n;
404   minima-&gt;vec = IM_ARRAY( NULL, n, double );
405   minima-&gt;n = n;
406   if( !xes-&gt;vec || !yes-&gt;vec || !minima-&gt;vec ||
407     im_minpos_vec( argv[0], xes-&gt;vec, yes-&gt;vec, minima-&gt;vec, n ) )
408     return -1;
409   return 0;
410 }
411 static im_function minpos_vec_desc = {
412   "im_minpos_vec",
413   N_( "position and value of n minima of image" ),
414   IM_FN_PIO,
415   minpos_vec_vec,
416   IM_NUMBER( maxpos_vec_args ),
417   maxpos_vec_args
418 };
419 static im_arg_desc measure_args[] = {
420 	IM_INPUT_IMAGE( "in" ),
421 	IM_OUTPUT_DMASK( "mask" ),
422 	IM_INPUT_INT( "x" ),
423 	IM_INPUT_INT( "y" ),
424 	IM_INPUT_INT( "w" ),
425 	IM_INPUT_INT( "h" ),
426 	IM_INPUT_INT( "h_patches" ),
427 	IM_INPUT_INT( "v_patches" )
428 };
429 static int
430 measure_vec( im_object *argv )
431 <a name="3"></a>{
432 	im_mask_object *mo = argv[1];
433 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int x = *((int *) argv[2]);
434 	int y = *((int *) argv[3]);
435 	int w = *((int *) argv[4]);
436 	int h = *((int *) argv[5]);
437 	int u = *((int *) argv[6]);
438 	int v = *((int *) argv[7]);</b></font>
439 	if( !(mo-&gt;mask = 
440 		im_measure_area( argv[0], 
441 			x, y, w, h, u, v, NULL, 0, mo-&gt;name )) ) {
442 		return( -1 );
443 	}
444 	return( 0 );
445 }
446 static im_function measure_desc = {
447 	"im_measure", 				N_( "measure averages of a grid of patches" ),
448 	IM_FN_PIO,				measure_vec, 				IM_NUMBER( measure_args ), 		measure_args 			};
449 static int
450 min_vec( im_object *argv )
451 {
452 	double f;
453 	if( im_min( argv[0], &amp;f ) )
454 		return( -1 );
455 	*((double *) argv[1]) = f;
456 	return( 0 );
457 }
458 static im_function min_desc = {
459 	"im_min", 				N_( "minimum value of image" ),		IM_FN_PIO,				min_vec, 				IM_NUMBER( image_in_num_out ), 		image_in_num_out 		};
460 static int
461 minpos_vec( im_object *argv )
462 {
463 	double f;
464 	int x, y;
465 	if( im_minpos( argv[0], &amp;x, &amp;y, &amp;f ) )
466 		return( -1 );
467 	((double *) argv[1])[0] = x;
468 	((double *) argv[1])[1] = y;
469 	return( 0 );
470 }
471 static im_function minpos_desc = {
472 	"im_minpos", 				N_( "position of minimum value of image" ),
473 	0,					minpos_vec, 				IM_NUMBER( maxpos_args ), 		maxpos_args 			};
474 static int
475 remainder_vec( im_object *argv )
476 {
477 	return( im_remainder( argv[0], argv[1], argv[2] ) );
478 }
479 static im_function remainder_desc = {
480 	"im_remainder", 			N_( "remainder after integer division" ),		IM_FN_PIO | IM_FN_PTOP,			remainder_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
481 static int
482 remainderconst_vec( im_object *argv )
483 {
484 	double c = *((double *) argv[2]);
485 	return( im_remainderconst( argv[0], argv[1], c ) );
486 }
487 static im_arg_desc remainderconst_args[] = {
488 	IM_INPUT_IMAGE( "in" ),
489 	IM_OUTPUT_IMAGE( "out" ),
490 	IM_INPUT_DOUBLE( "x" )
491 };
492 static im_function remainderconst_desc = {
493 	"im_remainderconst", 			N_( "remainder after integer division by a constant" ),	IM_FN_PIO | IM_FN_PTOP,			remainderconst_vec, 			IM_NUMBER( remainderconst_args ),	remainderconst_args 		};
494 static int
495 remainder_vec_vec( im_object *argv )
496 {
497 	im_doublevec_object *dv = (im_doublevec_object *) argv[2];
498 	return( im_remainder_vec( argv[0], argv[1], dv-&gt;n, dv-&gt;vec ) );
499 }
500 static im_arg_desc remainder_vec_args[] = {
501 	IM_INPUT_IMAGE( "in" ),
502 	IM_OUTPUT_IMAGE( "out" ),
503 	IM_INPUT_DOUBLEVEC( "x" )
504 };
505 static im_function remainder_vec_desc = {
506 	"im_remainder_vec", 			N_( "remainder after integer division by a vector of constants" ),
507 	IM_FN_PIO | IM_FN_PTOP,			remainder_vec_vec, 			IM_NUMBER( remainder_vec_args ),	remainder_vec_args 		};
508 static int
509 <a name="1"></a>multiply_vec( im_object *argv )
510 {
511 	return( im_multiply( argv[0], argv[1], argv[2] ) );
512 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
513 static im_function multiply_desc = {
514 	"im_multiply", 				N_( "multiply two images" ),		IM_FN_PIO | IM_FN_PTOP,			multiply_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
515 static int
516 powtra_vec( im_object *argv )
517 {
518 	double a = *((double *) argv[2]);
519 	return( im_powtra( argv[0], argv[1], a ) );
520 }
521 static im_function powtra_desc = {
522 	"im_powtra", 				N_( "pel^x of image" ),
523 	IM_FN_PIO | IM_FN_PTOP,			powtra_vec, 				IM_NUMBER( powtra_args ), 		powtra_args 			};
524 static int
525 powtra_vec_vec( im_object *argv )
526 {</b></font>
527 	im_doublevec_object *rv = (im_doublevec_object *) argv[2];
528 	return( im_powtra_vec( argv[0], argv[1], rv-&gt;n, rv-&gt;vec ) );
529 }
530 static im_function powtra_vec_desc = {
531 	"im_powtra_vec", 			N_( "pel^[x,y,z] of image" ),
532 	IM_FN_PIO | IM_FN_PTOP,			powtra_vec_vec, 			IM_NUMBER( expntra_vec_args ), 		expntra_vec_args 		};
533 static im_arg_desc stats_args[] = {
534 	IM_INPUT_IMAGE( "in" ),
535 	IM_OUTPUT_DMASK_STATS( "statistics" )
536 };
537 static int
538 stats_vec( im_object *argv )
539 {
540 	im_mask_object *mo = argv[1];
541 	if( !(mo-&gt;mask = im_stats( argv[0] )) )
542 		return( -1 );
543 	return( 0 );
544 }
545 static im_function stats_desc = {
546 	"im_stats", 				N_( "many image statistics in one pass" ),
547 	IM_FN_PIO,				stats_vec, 				IM_NUMBER( stats_args ), 		stats_args 			};
548 static int
549 subtract_vec( im_object *argv )
550 {
551 	return( im_subtract( argv[0], argv[1], argv[2] ) );
552 }
553 static im_function subtract_desc = {
554 	"im_subtract", 				N_( "subtract two images" ),		IM_FN_PIO,				subtract_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
555 static im_arg_desc linreg_args[] = {
556 	IM_INPUT_IMAGEVEC( "ins" ),
557 	IM_OUTPUT_IMAGE( "out" ),
558         IM_INPUT_DOUBLEVEC( "xs" )
559 };
560 static int
561 linreg_vec( im_object *argv )
562 {
563 #define FUNCTION_NAME "im_linreg_vec"
564   im_imagevec_object *ins_vec= (im_imagevec_object*) argv[0];
565   im_doublevec_object *xs_vec= (im_doublevec_object*) argv[2];
566   IMAGE *out= (IMAGE*) argv[1];
567   IMAGE **ins= IM_ARRAY( out, ins_vec-&gt; n + 1, IMAGE* );
568   int i;
569   if( ! ins )
570     return -1;
571   for( i= 0; i &lt; ins_vec-&gt; n; ++i )
572     ins[ i ]= ins_vec-&gt; vec[ i ];
573   ins[ ins_vec-&gt; n ]= NULL;
574   if( xs_vec-&gt; n != ins_vec-&gt; n ){
575     im_error( FUNCTION_NAME, "image vector and x vector differ in length" );
576     return -1;
577   }
578   return im_linreg( ins, out, xs_vec-&gt; vec );
579 #undef FUNCTION_NAME
580 }
581 static im_function linreg_desc = {
582 	"im_linreg", 				N_( "pixelwise linear regression" ),
583 	IM_FN_PIO | IM_FN_PTOP,			linreg_vec, 				IM_NUMBER( linreg_args ), 		linreg_args 			};
584 static int
585 <a name="9"></a>cross_phase_vec( im_object *argv )
586 {
587 	return( im_cross_phase( argv[0], argv[1], argv[2] ) );
588 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
589 static im_function cross_phase_desc = {
590 	"im_cross_phase", 				N_( "phase of cross power spectrum of two complex images" ),		IM_FN_PIO | IM_FN_PTOP,			cross_phase_vec, 			IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
591 static im_function *arith_list[] = {
592 	&amp;abs_desc,
593 	&amp;acostra_desc,
594 	&amp;add_desc,
595 	&amp;asintra_desc,
596 	&amp;atantra_desc,
597 	&amp;avg_desc,
598         &amp;point_desc,
599         &amp;point_bilinear_desc,
600         &amp;bandmean_desc,
601 	&amp;ceil_desc,
602 	&amp;costra_desc,
603 	&amp;cross_phase_desc,
604 	&amp;deviate_desc,
605 	&amp;divide_desc,
606 	&amp;exp10tra_desc,
607 	&amp;expntra_desc,
608 	&amp;expntra_vec_desc,
609 	&amp;exptra_desc,
610 	&amp;floor_desc,
611 	&amp;invert_desc,
612 	&amp;lintra_desc,
613 	&amp;linreg_desc,
614 	&amp;lintra_vec_desc,
615 	&amp;log10tra_desc,
616 	&amp;logtra_desc,
617 	&amp;max_desc,
618 	&amp;maxpos_desc,
619 	&amp;maxpos_avg_desc,
620 	&amp;maxpos_vec_desc,
621 	&amp;measure_desc,
622 	&amp;min_desc,
623 	&amp;minpos_desc,
624 	&amp;minpos_vec_desc,
625 	&amp;multiply_desc,
626 	&amp;powtra_desc,
627 	&amp;powtra_vec_desc,
628 	&amp;recomb_desc,
629 	&amp;remainder_desc,
630 	&amp;remainderconst_desc,
631 	&amp;remainder_vec_desc,
632 	&amp;rint_desc,
633 	&amp;sign_desc,
634 	&amp;sintra_desc,
635 	&amp;stats_desc,
636 	&amp;subtract_desc,
637 	&amp;tantra_desc
638 };
639 im_package im__arithmetic = {
640 	"arithmetic",
641 	IM_NUMBER( arith_list ),
642 	arith_list
643 };</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
