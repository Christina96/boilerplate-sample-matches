<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for mosaicing_dispatch.c & arith_dispatch.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for mosaicing_dispatch.c & arith_dispatch.c
      </h3>
      <h1 align="center">
        31.0%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>mosaicing_dispatch.c (32.44147%)<TH>arith_dispatch.c (29.709036%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#0',2,'match1138-1.html#0',3)" NAME="0">(660-708)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#0',2,'match1138-1.html#0',3)" NAME="0">(233-296)</A><TD ALIGN=center><FONT COLOR="#ff0000">30</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#1',2,'match1138-1.html#1',3)" NAME="1">(610-645)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#1',2,'match1138-1.html#1',3)" NAME="1">(1046-1084)</A><TD ALIGN=center><FONT COLOR="#aa0000">20</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#2',2,'match1138-1.html#2',3)" NAME="2">(47-115)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#2',2,'match1138-1.html#2',3)" NAME="2">(45-77)</A><TD ALIGN=center><FONT COLOR="#a10000">19</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#3',2,'match1138-1.html#3',3)" NAME="3">(116-121)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#3',2,'match1138-1.html#3',3)" NAME="3">(881-887)</A><TD ALIGN=center><FONT COLOR="#990000">18</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#4',2,'match1138-1.html#4',3)" NAME="4">(220-250)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#4',2,'match1138-1.html#4',3)" NAME="4">(769-798)</A><TD ALIGN=center><FONT COLOR="#880000">16</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#5',2,'match1138-1.html#5',3)" NAME="5">(150-193)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#5',2,'match1138-1.html#5',3)" NAME="5">(176-206)</A><TD ALIGN=center><FONT COLOR="#880000">16</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#6',2,'match1138-1.html#6',3)" NAME="6">(549-586)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#6',2,'match1138-1.html#6',3)" NAME="6">(366-393)</A><TD ALIGN=center><FONT COLOR="#6e0000">13</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#7',2,'match1138-1.html#7',3)" NAME="7">(499-537)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#7',2,'match1138-1.html#7',3)" NAME="7">(299-325)</A><TD ALIGN=center><FONT COLOR="#6e0000">13</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#8',2,'match1138-1.html#8',3)" NAME="8">(388-419)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#8',2,'match1138-1.html#8',3)" NAME="8">(143-172)</A><TD ALIGN=center><FONT COLOR="#6e0000">13</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#9',2,'match1138-1.html#9',3)" NAME="9">(716-756)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#9',2,'match1138-1.html#9',3)" NAME="9">(1205-1275)</A><TD ALIGN=center><FONT COLOR="#660000">12</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#10',2,'match1138-1.html#10',3)" NAME="10">(456-489)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#10',2,'match1138-1.html#10',3)" NAME="10">(398-424)</A><TD ALIGN=center><FONT COLOR="#660000">12</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1138-0.html#11',2,'match1138-1.html#11',3)" NAME="11">(318-352)<TD><A HREF="javascript:ZweiFrames('match1138-0.html#11',2,'match1138-1.html#11',3)" NAME="11">(704-729)</A><TD ALIGN=center><FONT COLOR="#660000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>mosaicing_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Function dispatch tables for mosaicing.
 *
 * J. Cupitt, 23/2/95
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;
#include &lt;vips/internal.h&gt;
#include &lt;vips/transform.h&gt;
<A NAME="2"></A>
/* Merge args.
 */
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1138-1.html#2',3,'match1138-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static im_arg_desc merge_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;dx&quot; ),
	IM_INPUT_INT( &quot;dy&quot; ),
	IM_INPUT_INT( &quot;mwidth&quot; )
};

/* Merge1 args.
 */
static im_arg_desc merge1_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;xr1&quot; ),
	IM_INPUT_INT( &quot;yr1&quot; ),
	IM_INPUT_INT( &quot;xs1&quot; ),
	IM_INPUT_INT( &quot;ys1&quot; ),
	IM_INPUT_INT( &quot;xr2&quot; ),
	IM_INPUT_INT( &quot;yr2&quot; ),
	IM_INPUT_INT( &quot;xs2&quot; ),
	IM_INPUT_INT( &quot;ys2&quot; ),
	IM_INPUT_INT( &quot;mwidth&quot; )
};

/* Mosaic args.
 */
static im_arg_desc mosaic_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;bandno&quot; ),
	IM_INPUT_INT( &quot;xr&quot; ),
	IM_INPUT_INT( &quot;yr&quot; ),
	IM_INPUT_INT( &quot;xs&quot; ),
	IM_INPUT_INT( &quot;ys&quot; ),
	IM_INPUT_INT( &quot;halfcorrelation&quot; ),
	IM_INPUT_INT( &quot;halfarea&quot; ),
	IM_INPUT_INT( &quot;balancetype&quot; ),
	IM_INPUT_INT( &quot;mwidth&quot; )
};

/* Mosaic1 args.
 */
static im_arg_desc mosaic1_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;bandno&quot; ),
	IM_INPUT_INT( &quot;xr1&quot; ),
	IM_INPUT_INT( &quot;yr1&quot; ),
	IM_INPUT_INT( &quot;xs1&quot; ),
	IM_INPUT_INT( &quot;ys1&quot; ),
	IM_INPUT_INT( &quot;xr2&quot; ),
	IM_INPUT_INT( &quot;yr2&quot; ),
	IM_INPUT_INT( &quot;xs2&quot; ),
	IM_INPUT_INT( &quot;ys2&quot; ),
	IM_INPUT_INT( &quot;halfcorrelation&quot; ),
	IM_INPUT_INT( &quot;halfarea&quot; ),
	IM_INPUT_INT( &quot;balancetype&quot; ),
	IM_INPUT_INT( &quot;mwidth&quot; )
};

/* Call im_lrmosaic via arg vector.
 */
<A NAME="3"></A>static int
lrmosaic_vec( im_object *argv )
{</B></FONT>
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1138-1.html#3',3,'match1138-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int bandno = *((int *) argv[3]);
	int xr = *((int *) argv[4]);
	int yr = *((int *) argv[5]);
	int xs = *((int *) argv[6]);
	int ys = *((int *) argv[7]);
	int halfcorrelation = *((int *) argv[8]);</B></FONT>
	int halfarea = *((int *) argv[9]);
	int balancetype = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);

	return( vips__lrmosaic( argv[0], argv[1], argv[2], 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}

/* Call im_lrmosaic1 via arg vector.
 */
static int
lrmosaic1_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int xr1 = *((int *) argv[4]);
	int yr1 = *((int *) argv[5]);
	int xs1 = *((int *) argv[6]);
	int ys1 = *((int *) argv[7]);
	int xr2 = *((int *) argv[8]);
	int yr2 = *((int *) argv[9]);
	int xs2 = *((int *) argv[10]);
	int ys2 = *((int *) argv[11]);
<A NAME="5"></A>	int halfcorrelation = *((int *) argv[12]);
	int halfarea = *((int *) argv[13]);
	int balancetype = *((int *) argv[14]);
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match1138-1.html#5',3,'match1138-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int mwidth = *((int *) argv[15]);

	return( im_lrmosaic1( argv[0], argv[1], argv[2], 
		bandno, 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}

/* Description of im_lrmosaic.
 */ 
static im_function lrmosaic_desc = {
	&quot;im_lrmosaic&quot;, 			/* Name */
	&quot;left-right mosaic of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	lrmosaic_vec, 			/* Dispatch function */
	IM_NUMBER( mosaic_args ), 		/* Size of arg list */
	mosaic_args 			/* Arg list */
};

static im_arg_desc find_overlap_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_INPUT_INT( &quot;bandno&quot; ),
	IM_INPUT_INT( &quot;xr&quot; ),
	IM_INPUT_INT( &quot;yr&quot; ),
	IM_INPUT_INT( &quot;xs&quot; ),
	IM_INPUT_INT( &quot;ys&quot; ),
	IM_INPUT_INT( &quot;halfcorrelation&quot; ),
	IM_INPUT_INT( &quot;halfarea&quot; ),
	IM_OUTPUT_INT( &quot;dx0&quot; ),
	IM_OUTPUT_INT( &quot;dy0&quot; ),
	IM_OUTPUT_DOUBLE( &quot;scale1&quot; ),
	IM_OUTPUT_DOUBLE( &quot;angle1&quot; ),
	IM_OUTPUT_DOUBLE( &quot;dx1&quot; ),
	IM_OUTPUT_DOUBLE( &quot;dy1&quot; )
};

/* Call im__find_lroverlap via arg vector.
 */
static int
find_lroverlap_vec( im_object *argv )
{</B></FONT>
	int bandno = *((int *) argv[2]);
	int xr = *((int *) argv[3]);
	int yr = *((int *) argv[4]);
	int xs = *((int *) argv[5]);
	int ys = *((int *) argv[6]);
	int halfcorrelation = *((int *) argv[7]);
	int halfarea = *((int *) argv[8]);
	int *dx0 = (int *) argv[9];
	int *dy0 = (int *) argv[10];
	double *scale1 = (double *) argv[11];
	double *angle1 = (double *) argv[12];
	double *dx1 = (double *) argv[13];
	double *dy1 = (double *) argv[14];

	IMAGE *t;
	int result;

	if( !(t = im_open( &quot;find_lroverlap_vec&quot;, &quot;p&quot; )) )
		return( -1 );
	result = vips__find_lroverlap( argv[0], argv[1], t, 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
<A NAME="4"></A>		dx0, dy0, scale1, angle1, dx1, dy1 );
	im_close( t );

<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1138-1.html#4',3,'match1138-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( result );
}

/* Description of im__find_lroverlap.
 */ 
static im_function find_lroverlap_desc = {
	&quot;im__find_lroverlap&quot;,		/* Name */
	&quot;search for left-right overlap of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	find_lroverlap_vec, 		/* Dispatch function */
	IM_NUMBER( find_overlap_args ),	/* Size of arg list */
	find_overlap_args 		/* Arg list */
};

/* Description of im_lrmosaic1.
 */ 
static im_function lrmosaic1_desc = {
	&quot;im_lrmosaic1&quot;,			/* Name */
	&quot;first-order left-right mosaic of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	lrmosaic1_vec, 			/* Dispatch function */
	IM_NUMBER( mosaic1_args ), 	/* Size of arg list */
	mosaic1_args 			/* Arg list */
};

/* Call im_tbmosaic via arg vector.
 */
static int
tbmosaic_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);</B></FONT>
	int x1 = *((int *) argv[4]);
	int y1 = *((int *) argv[5]);
	int x2 = *((int *) argv[6]);
	int y2 = *((int *) argv[7]);
	int halfcorrelation = *((int *) argv[8]);
	int halfarea = *((int *) argv[9]);
	int balancetype = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);

	return( vips__tbmosaic( argv[0], argv[1], argv[2], 
		bandno, 
		x1, y1, x2, y2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}

/* Call im_tbmosaic1 via arg vector.
 */
static int
tbmosaic1_vec( im_object *argv )
{
	int bandno = *((int *) argv[3]);
	int xr1 = *((int *) argv[4]);
	int yr1 = *((int *) argv[5]);
	int xs1 = *((int *) argv[6]);
	int ys1 = *((int *) argv[7]);
	int xr2 = *((int *) argv[8]);
	int yr2 = *((int *) argv[9]);
	int xs2 = *((int *) argv[10]);
	int ys2 = *((int *) argv[11]);
	int halfcorrelation = *((int *) argv[12]);
	int halfarea = *((int *) argv[13]);
	int balancetype = *((int *) argv[14]);
	int mwidth = *((int *) argv[15]);

	return( im_tbmosaic1( argv[0], argv[1], argv[2], 
		bandno, 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, 
		halfcorrelation, halfarea,
		balancetype, mwidth ) );
}

/* Call im__find_tboverlap via arg vector.
 */
static int
find_tboverlap_vec( im_object *argv )
{
	int bandno = *((int *) argv[2]);
	int xr = *((int *) argv[3]);
	int yr = *((int *) argv[4]);
	int xs = *((int *) argv[5]);
	int ys = *((int *) argv[6]);
	int halfcorrelation = *((int *) argv[7]);
	int halfarea = *((int *) argv[8]);
	int *dx0 = (int *) argv[9];
	int *dy0 = (int *) argv[10];
	double *scale1 = (double *) argv[11];
	double *angle1 = (double *) argv[12];
	double *dx1 = (double *) argv[13];
	double *dy1 = (double *) argv[14];

	IMAGE *t;
	int result;
<A NAME="11"></A>
	if( !(t = im_open( &quot;find_tboverlap_vec&quot;, &quot;p&quot; )) )
		return( -1 );
<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match1138-1.html#11',3,'match1138-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	result = vips__find_tboverlap( argv[0], argv[1], t, 
		bandno, 
		xr, yr, xs, ys, 
		halfcorrelation, halfarea,
		dx0, dy0, scale1, angle1, dx1, dy1 );
	im_close( t );

	return( result );
}

/* Description of im__find_tboverlap.
 */ 
static im_function find_tboverlap_desc = {
	&quot;im__find_tboverlap&quot;,		/* Name */
	&quot;search for top-bottom overlap of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	find_tboverlap_vec, 		/* Dispatch function */
	IM_NUMBER( find_overlap_args ),	/* Size of arg list */
	find_overlap_args 		/* Arg list */
};

/* Description of im_tbmosaic.
 */ 
static im_function tbmosaic_desc = {
	&quot;im_tbmosaic&quot;, 			/* Name */
	&quot;top-bottom mosaic of in1 and in2&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	tbmosaic_vec, 			/* Dispatch function */
	IM_NUMBER( mosaic_args ), 		/* Size of arg list */
	mosaic_args 			/* Arg list */
};

/* Description of im_tbmosaic1.
 */ 
static im_function tbmosaic1_desc = {</B></FONT>
	&quot;im_tbmosaic1&quot;,			/* Name */
	&quot;first-order top-bottom mosaic of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	tbmosaic1_vec, 			/* Dispatch function */
	IM_NUMBER( mosaic1_args ), 	/* Size of arg list */
	mosaic1_args 			/* Arg list */
};

/* Call im_lrmerge via arg vector.
 */
static int
lrmerge_vec( im_object *argv )
{
	int dx = *((int *) argv[3]);
	int dy = *((int *) argv[4]);
	int mwidth = *((int *) argv[5]);

	return( im_lrmerge( argv[0], argv[1], argv[2], dx, dy, mwidth ) );
}

/* Call im_lrmerge1 via arg vector.
 */
static int
lrmerge1_vec( im_object *argv )
{
	int xr1 = *((int *) argv[3]);
	int yr1 = *((int *) argv[4]);
	int xs1 = *((int *) argv[5]);
	int ys1 = *((int *) argv[6]);
	int xr2 = *((int *) argv[7]);
	int yr2 = *((int *) argv[8]);
	int xs2 = *((int *) argv[9]);
<A NAME="8"></A>	int ys2 = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);

<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match1138-1.html#8',3,'match1138-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( im_lrmerge1( argv[0], argv[1], argv[2], 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, mwidth ) ); 
}

/* Description of im_lrmerge.
 */ 
static im_function lrmerge_desc = {
	&quot;im_lrmerge&quot;, 			/* Name */
	&quot;left-right merge of in1 and in2&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	lrmerge_vec, 			/* Dispatch function */
	IM_NUMBER( merge_args ), 		/* Size of arg list */
	merge_args 			/* Arg list */
};

/* Description of im_lrmerge1.
 */ 
static im_function lrmerge1_desc = {
	&quot;im_lrmerge1&quot;, 			/* Name */
	&quot;first-order left-right merge of ref and sec&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	lrmerge1_vec, 			/* Dispatch function */
	IM_NUMBER( merge1_args ), 		/* Size of arg list */
	merge1_args 			/* Arg list */
};

/* Call im_tbmerge via arg vector.
 */
static int
tbmerge_vec( im_object *argv )
{</B></FONT>
	int dx = *((int *) argv[3]);
	int dy = *((int *) argv[4]);
	int mwidth = *((int *) argv[5]);

	return( im_tbmerge( argv[0], argv[1], argv[2], dx, dy, mwidth ) );
}

/* Call im_tbmerge1 via arg vector.
 */
static int
tbmerge1_vec( im_object *argv )
{
	int xr1 = *((int *) argv[3]);
	int yr1 = *((int *) argv[4]);
	int xs1 = *((int *) argv[5]);
	int ys1 = *((int *) argv[6]);
	int xr2 = *((int *) argv[7]);
	int yr2 = *((int *) argv[8]);
	int xs2 = *((int *) argv[9]);
	int ys2 = *((int *) argv[10]);
	int mwidth = *((int *) argv[11]);

	return( im_tbmerge1( argv[0], argv[1], argv[2], 
		xr1, yr1, xs1, ys1, 
		xr2, yr2, xs2, ys2, mwidth ) ); 
}

/* Description of im_tbmerge.
 */ 
static im_function tbmerge_desc = {
	&quot;im_tbmerge&quot;, 			/* Name */
	&quot;top-bottom merge of in1 and in2&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
<A NAME="10"></A>	tbmerge_vec, 			/* Dispatch function */
	IM_NUMBER( merge_args ), 		/* Size of arg list */
	merge_args 			/* Arg list */
<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match1138-1.html#10',3,'match1138-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

/* Description of im_tbmerge1.
 */ 
static im_function tbmerge1_desc = {
	&quot;im_tbmerge1&quot;, 			/* Name */
	&quot;first-order top-bottom merge of in1 and in2&quot;,/* Description */
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	tbmerge1_vec, 			/* Dispatch function */
	IM_NUMBER( merge1_args ), 		/* Size of arg list */
	merge1_args 			/* Arg list */
};

/* match_linear args
 */
static im_arg_desc match_linear_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;xref1&quot; ),
	IM_INPUT_INT( &quot;yref1&quot; ),
	IM_INPUT_INT( &quot;xsec1&quot; ),
	IM_INPUT_INT( &quot;ysec1&quot; ),
	IM_INPUT_INT( &quot;xref2&quot; ),
	IM_INPUT_INT( &quot;yref2&quot; ),
	IM_INPUT_INT( &quot;xsec2&quot; ),
	IM_INPUT_INT( &quot;ysec2&quot; )
};

/* Call im_match_linear via arg vector.
 */
static int
match_linear_vec( im_object *argv )
{</B></FONT>
	int xref1 = *((int *) argv[3]);
	int yref1 = *((int *) argv[4]);
	int xsec1 = *((int *) argv[5]);
	int ysec1 = *((int *) argv[6]);
	int xref2 = *((int *) argv[7]);
	int yref2 = *((int *) argv[8]);
<A NAME="7"></A>	int xsec2 = *((int *) argv[9]);
	int ysec2 = *((int *) argv[10]);

<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match1138-1.html#7',3,'match1138-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( im_match_linear( argv[0], argv[1], argv[2],
		xref1, yref1, xsec1, ysec1, 
		xref2, yref2, xsec2, ysec2 ) );
}

/* Description of im_match_linear.
 */ 
static im_function match_linear_desc = {
	&quot;im_match_linear&quot;, 		/* Name */
	&quot;resample ref so that tie-points match&quot;,
	IM_FN_PIO,			/* Flags */
	match_linear_vec, 		/* Dispatch function */
	IM_NUMBER( match_linear_args ), 	/* Size of arg list */
	match_linear_args 		/* Arg list */
};

/* match_linear_search args
 */
static im_arg_desc match_linear_search_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_INT( &quot;xref1&quot; ),
	IM_INPUT_INT( &quot;yref1&quot; ),
	IM_INPUT_INT( &quot;xsec1&quot; ),
	IM_INPUT_INT( &quot;ysec1&quot; ),
	IM_INPUT_INT( &quot;xref2&quot; ),
	IM_INPUT_INT( &quot;yref2&quot; ),
	IM_INPUT_INT( &quot;xsec2&quot; ),
	IM_INPUT_INT( &quot;ysec2&quot; ),
	IM_INPUT_INT( &quot;hwindowsize&quot; ),
	IM_INPUT_INT( &quot;hsearchsize&quot; )
};

/* Call im_match_linear_search via arg vector.
 */
static int
match_linear_search_vec( im_object *argv )
{</B></FONT>
	int xref1 = *((int *) argv[3]);
	int yref1 = *((int *) argv[4]);
	int xsec1 = *((int *) argv[5]);
	int ysec1 = *((int *) argv[6]);
	int xref2 = *((int *) argv[7]);
	int yref2 = *((int *) argv[8]);
	int xsec2 = *((int *) argv[9]);
	int ysec2 = *((int *) argv[10]);
<A NAME="6"></A>	int hwin = *((int *) argv[11]);
	int hsrch = *((int *) argv[12]);

<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match1138-1.html#6',3,'match1138-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	return( im_match_linear_search( argv[0], argv[1], argv[2],
		xref1, yref1, xsec1, ysec1, 
		xref2, yref2, xsec2, ysec2,
		hwin, hsrch ) );
}

/* Description of im_match_linear_search.
 */ 
static im_function match_linear_search_desc = {
	&quot;im_match_linear_search&quot;, 	/* Name */
	&quot;search sec, then resample so that tie-points match&quot;,
	IM_FN_PIO,			/* Flags */
	match_linear_search_vec, 	/* Dispatch function */
	IM_NUMBER( match_linear_search_args ),/* Size of arg list */
	match_linear_search_args 	/* Arg list */
};

/* correl args
 */
static im_arg_desc correl_args[] = {
	IM_INPUT_IMAGE( &quot;ref&quot; ),
	IM_INPUT_IMAGE( &quot;sec&quot; ),
	IM_INPUT_INT( &quot;xref&quot; ),
	IM_INPUT_INT( &quot;yref&quot; ),
	IM_INPUT_INT( &quot;xsec&quot; ),
	IM_INPUT_INT( &quot;ysec&quot; ),
	IM_INPUT_INT( &quot;hwindowsize&quot; ),
	IM_INPUT_INT( &quot;hsearchsize&quot; ),
	IM_OUTPUT_DOUBLE( &quot;correlation&quot; ),
	IM_OUTPUT_INT( &quot;x&quot; ),
	IM_OUTPUT_INT( &quot;y&quot; )
};

/* Call im_correl via arg vector.
 */
static int
correl_vec( im_object *argv )
{</B></FONT>
	int xref = *((int *) argv[2]);
	int yref = *((int *) argv[3]);
	int xsec = *((int *) argv[4]);
	int ysec = *((int *) argv[5]);
	int cor = *((int *) argv[6]);
	int area = *((int *) argv[7]);
	int *x = (int *) argv[8];
	int *y = (int *) argv[9];
	double *correlation = (double *) argv[10];

	return( vips__correl( argv[0], argv[1], 
		xref, yref, xsec, ysec, cor, area, correlation, x, y ) );
}

/* Description of im_correl.
 */ 
static im_function correl_desc = {
	&quot;im_correl&quot;, 			/* Name */
	&quot;search area around sec for match for area around ref&quot;,
	IM_FN_PIO,			/* Flags */
<A NAME="1"></A>	correl_vec, 			/* Dispatch function */
	IM_NUMBER( correl_args ), 		/* Size of arg list */
	correl_args 			/* Arg list */
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1138-1.html#1',3,'match1138-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

/* global_balance args
 */
static im_arg_desc global_balance_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_DOUBLE( &quot;gamma&quot; )
};

/* Call im_global_balance via arg vector.
 */
static int
global_balance_vec( im_object *argv )
{
	double gamma = *((double *) argv[2]);

	return( im_global_balance( argv[0], argv[1], gamma ) );
}

/* Description of im_global_balance.
 */ 
static im_function global_balance_desc = {
	&quot;im_global_balance&quot;,		/* Name */
	&quot;automatically rebuild mosaic with balancing&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	global_balance_vec, 		/* Dispatch function */
	IM_NUMBER( global_balance_args ),	/* Size of arg list */
	global_balance_args 		/* Arg list */
};

/* Call im_global_balancef via arg vector.
 */
static int
global_balancef_vec( im_object *argv )
{</B></FONT>
	double gamma = *((double *) argv[2]);

	return( im_global_balancef( argv[0], argv[1], gamma ) );
}

/* Description of im_global_balancef.
 */ 
static im_function global_balancef_desc = {
	&quot;im_global_balancef&quot;,		/* Name */
	&quot;automatically rebuild mosaic with balancing, float output&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
<A NAME="0"></A>	global_balancef_vec, 		/* Dispatch function */
	IM_NUMBER( global_balance_args ),	/* Size of arg list */
	global_balance_args 		/* Arg list */
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1138-1.html#0',3,'match1138-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

/* remosaic args
 */
static im_arg_desc remosaic_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_STRING( &quot;old_str&quot; ),
	IM_INPUT_STRING( &quot;new_str&quot; )
};

/* Call im_remosaic via arg vector.
 */
static int
remosaic_vec( im_object *argv )
{
	return( im_remosaic( argv[0], argv[1], argv[2], argv[3] ) );
}

/* Description of im_remosaic.
 */ 
static im_function remosaic_desc = {
	&quot;im_remosaic&quot;,		/* Name */
	&quot;automatically rebuild mosaic with new files&quot;,
	IM_FN_TRANSFORM | IM_FN_PIO,	/* Flags */
	remosaic_vec, 		/* Dispatch function */
	IM_NUMBER( remosaic_args ),/* Size of arg list */
	remosaic_args 		/* Arg list */
};

static int align_bands_vec( im_object *argv ){
  return im_align_bands( (IMAGE*)argv[0], (IMAGE*)argv[1] );
}

static im_arg_desc align_bands_arg_types[]= {
  IM_INPUT_IMAGE( &quot;in&quot; ),
  IM_OUTPUT_IMAGE( &quot;out&quot; )
};

static im_function align_bands_desc= {
  &quot;im_align_bands&quot;,
  &quot;align the bands of an image&quot;,
  0,
  align_bands_vec,
  IM_NUMBER( align_bands_arg_types ),
  align_bands_arg_types
};

static int maxpos_subpel_vec( im_object *argv ){</B></FONT>
  return im_maxpos_subpel( (IMAGE*)argv[0], (double*)argv[1], (double*)argv[2] );
}

static im_arg_desc maxpos_subpel_arg_types[]= {
<A NAME="9"></A>  IM_INPUT_IMAGE( &quot;im&quot; ),
  IM_OUTPUT_DOUBLE( &quot;x&quot; ),
  IM_OUTPUT_DOUBLE( &quot;y&quot; )
<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match1138-1.html#9',3,'match1138-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>};

static im_function maxpos_subpel_desc= {
  &quot;im_maxpos_subpel&quot;,
  &quot;subpixel position of maximum of (phase correlation) image&quot;,
  IM_FN_PIO,
  maxpos_subpel_vec,
  IM_NUMBER( maxpos_subpel_arg_types ),
  maxpos_subpel_arg_types
};

/* Package up all these functions.
 */
static im_function *mos_list[] = {
        &amp;align_bands_desc,
	&amp;correl_desc,
	&amp;find_lroverlap_desc,
	&amp;find_tboverlap_desc,
	&amp;global_balance_desc,
	&amp;global_balancef_desc,
	&amp;lrmerge_desc,
	&amp;lrmerge1_desc,
	&amp;lrmosaic_desc,
	&amp;lrmosaic1_desc,
	&amp;match_linear_desc,
	&amp;match_linear_search_desc,
        &amp;maxpos_subpel_desc,
	&amp;remosaic_desc,
	&amp;tbmerge_desc,
	&amp;tbmerge1_desc,
	&amp;tbmosaic_desc,
	&amp;tbmosaic1_desc
};

/* Package of functions.
 */
im_package im__mosaicing = {
	&quot;mosaicing&quot;,
	IM_NUMBER( mos_list ),
	mos_list
};</B></FONT>
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>arith_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* Function dispatch tables for arithmetic.
 *
 * J. Cupitt, 8/4/93.
 */

/*

    This file is part of VIPS.
    
    VIPS is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301  USA

 */

/*

    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk

 */

#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#endif /*HAVE_CONFIG_H*/
#include &lt;vips/intl.h&gt;

#include &lt;stdio.h&gt;

#include &lt;vips/vips.h&gt;
#include &lt;vips/vips7compat.h&gt;
<A NAME="2"></A>
/* One image in, one out.
 */
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#2',2,'match1138-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static im_arg_desc one_in_one_out[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Two images in, one out.
 */
static im_arg_desc two_in_one_out[] = {
	IM_INPUT_IMAGE( &quot;in1&quot; ),
	IM_INPUT_IMAGE( &quot;in2&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Image in, number out.
 */
static im_arg_desc image_in_num_out[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_DOUBLE( &quot;value&quot; )
};

/* Args for im_recomb.
 */
static im_arg_desc recomb_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_DMASK( &quot;matrix&quot; )
};

/* Call im_recomb via arg vector.
 */
static int
recomb_vec( im_object *argv )
{</B></FONT>
	im_mask_object *mo = argv[2];

	return( im_recomb( argv[0], argv[1], mo-&gt;mask ) );
}

/* Description of im_recomb.
 */
static im_function recomb_desc = {
	&quot;im_recomb&quot;, 			/* Name */
	&quot;linear recombination with mask&quot;,
	IM_FN_PIO,			/* Flags */
	recomb_vec, 			/* Dispatch function */
	IM_NUMBER( recomb_args ), 	/* Size of arg list */
	recomb_args 			/* Arg list */
};

/* Call im_abs via arg vector.
 */
static int
abs_vec( im_object *argv )
{
	return( im_abs( argv[0], argv[1] ) );
}

/* Description of im_abs.
 */ 
static im_function abs_desc = {
	&quot;im_abs&quot;, 			/* Name */
	N_( &quot;absolute value&quot; ),		/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	abs_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_add via arg vector.
 */
static int
add_vec( im_object *argv )
{
	return( im_add( argv[0], argv[1], argv[2] ) );
}

/* Description of im_add.
 */ 
static im_function add_desc = {
	&quot;im_add&quot;, 			/* Name */
	N_( &quot;add two images&quot; ),		/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	add_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Call im_avg via arg vector.
 */
static int
avg_vec( im_object *argv )
{
	double f;

	if( im_avg( argv[0], &amp;f ) )
<A NAME="8"></A>		return( -1 );

	*((double *) argv[1]) = f;
<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#8',2,'match1138-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( 0 );
}

/* Description of im_avg.
 */ 
static im_function avg_desc = {
	&quot;im_avg&quot;, 			/* Name */
	N_( &quot;average value of image&quot; ),	/* Description */
	IM_FN_PIO,			/* Flags */
	avg_vec, 			/* Dispatch function */
	IM_NUMBER( image_in_num_out ), 	/* Size of arg list */
	image_in_num_out 		/* Arg list */
};

/* Args to im_point.
 */
static im_arg_desc point_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_INTERPOLATE( &quot;interpolate&quot; ),
	IM_INPUT_DOUBLE( &quot;x&quot; ),
	IM_INPUT_DOUBLE( &quot;y&quot; ),
	IM_INPUT_INT( &quot;band&quot; ),
	IM_OUTPUT_DOUBLE( &quot;out&quot; )
};

/* Call im_point via arg vector.
 */
static int
point_vec( im_object *argv )
{</B></FONT>
<A NAME="5"></A>	VipsInterpolate *interpolate = VIPS_INTERPOLATE( argv[1] );
	double x = *((double *) argv[2]);
	double y = *((double *) argv[3]);
<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#5',2,'match1138-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int band = *((int *) argv[4]);

	return( im_point( argv[0], interpolate, x, y, band, argv[5] ) );
}

/* Description of im_point.
 */
static im_function point_desc = {
	&quot;im_point&quot;,
	&quot;interpolate value at single point&quot;,
	IM_FN_PIO,
	point_vec,
	IM_NUMBER( point_args ),
	point_args
};

/* Args to im_point_bilinear.
 */
static im_arg_desc point_bilinear_args[] = {
  IM_INPUT_IMAGE (&quot;in&quot;),
  IM_INPUT_DOUBLE(&quot;x&quot;),
  IM_INPUT_DOUBLE(&quot;y&quot;),
  IM_INPUT_INT(&quot;band&quot;),
  IM_OUTPUT_DOUBLE(&quot;val&quot;)
};

/* Call im_point_bilinear via arg vector.
 */
static int
point_bilinear_vec( im_object *argv )
{</B></FONT>
  return im_point_bilinear( argv[0], *(double*)argv[1], *(double*)argv[2], *(int*)argv[3], argv[4] );
}

/* Description of im_point_bilinear.
 */
static im_function point_bilinear_desc = {
  &quot;im_point_bilinear&quot;,
  &quot;interpolate value at single point, linearly&quot;,
  IM_FN_PIO,
  point_bilinear_vec,
  IM_NUMBER( point_bilinear_args ),
  point_bilinear_args
};

/* Call im_deviate via arg vector.
 */
static int
deviate_vec( im_object *argv )
{
	double f;

	if( im_deviate( argv[0], &amp;f ) )
		return( -1 );
<A NAME="0"></A>
	*((double *) argv[1]) = f;
	return( 0 );
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#0',2,'match1138-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_deviate.
 */ 
static im_function deviate_desc = {
	&quot;im_deviate&quot;, 			/* Name */
	N_( &quot;standard deviation of image&quot; ),	/* Description */
	IM_FN_PIO,			/* Flags */
	deviate_vec, 			/* Dispatch function */
	IM_NUMBER( image_in_num_out ), 	/* Size of arg list */
	image_in_num_out 		/* Arg list */
};

/* Call im_exp10tra via arg vector.
 */
static int
exp10tra_vec( im_object *argv )
{
	return( im_exp10tra( argv[0], argv[1] ) );
}

/* Description of im_exp10tra.
 */ 
static im_function exp10tra_desc = {
	&quot;im_exp10tra&quot;, 			/* Name */
	N_( &quot;10^pel of image&quot; ),	/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	exp10tra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_exptra via arg vector.
 */
static int
exptra_vec( im_object *argv )
{
	return( im_exptra( argv[0], argv[1] ) );
}

/* Description of im_exptra.
 */ 
static im_function exptra_desc = {
	&quot;im_exptra&quot;, 			/* Name */
	N_( &quot;e^pel of image&quot; ),		/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	exptra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Args for im_powtra().
 */
static im_arg_desc powtra_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_DOUBLE( &quot;x&quot; )
};

/* Call im_expntra via arg vector.
 */
static int
expntra_vec( im_object *argv )
<A NAME="7"></A>{</B></FONT>
	double a = *((double *) argv[2]);

<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#7',2,'match1138-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( im_expntra( argv[0], argv[1], a ) );
}

/* Description of im_expntra.
 */ 
static im_function expntra_desc = {
	&quot;im_expntra&quot;, 			/* Name */
	N_( &quot;x^pel of image&quot; ),		/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	expntra_vec, 			/* Dispatch function */
	IM_NUMBER( powtra_args ), 	/* Size of arg list */
	powtra_args 			/* Arg list */
};

/* Args for im_expntra_vec().
 */
static im_arg_desc expntra_vec_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_DOUBLEVEC( &quot;v&quot; )
};

/* Call im_expntra_vec() via arg vector.
 */
static int
expntra_vec_vec( im_object *argv )
{</B></FONT>
	im_doublevec_object *rv = (im_doublevec_object *) argv[2];

	return( im_expntra_vec( argv[0], argv[1], rv-&gt;n, rv-&gt;vec ) );
}

/* Description of im_expntra_vec.
 */ 
static im_function expntra_vec_desc = {
	&quot;im_expntra_vec&quot;, 		/* Name */
	N_( &quot;[x,y,z]^pel of image&quot; ),	/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	expntra_vec_vec, 		/* Dispatch function */
	IM_NUMBER( expntra_vec_args ), 	/* Size of arg list */
	expntra_vec_args 		/* Arg list */
};

/* Call im_divide via arg vector.
 */
static int
divide_vec( im_object *argv )
{
	return( im_divide( argv[0], argv[1], argv[2] ) );
}

/* Description of im_divide.
 */ 
static im_function divide_desc = {
	&quot;im_divide&quot;, 			/* Name */
	N_( &quot;divide two images&quot; ),
	IM_FN_PIO,			/* Flags */
	divide_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Call im_invert via arg vector.
 */
<A NAME="6"></A>static int
invert_vec( im_object *argv )
{
<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#6',2,'match1138-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	return( im_invert( argv[0], argv[1] ) );
}

/* Description of im_invert.
 */ 
static im_function invert_desc = {
	&quot;im_invert&quot;, 			/* Name */
	N_( &quot;photographic negative&quot; ),	/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	invert_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Args for im_lintra().
 */
static im_arg_desc lintra_args[] = {
	IM_INPUT_DOUBLE( &quot;a&quot; ),
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_DOUBLE( &quot;b&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Call im_lintra() via arg vector.
 */
static int
lintra_vec( im_object *argv )
{</B></FONT>
	double a = *((double *) argv[0]);
<A NAME="10"></A>	double b = *((double *) argv[2]);

	return( im_lintra( a, argv[1], b, argv[3] ) );
<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#10',2,'match1138-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_lintra().
 */ 
static im_function lintra_desc = {
	&quot;im_lintra&quot;, 			/* Name */
	N_( &quot;calculate a*in + b = outfile&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	lintra_vec, 			/* Dispatch function */
	IM_NUMBER( lintra_args ), 	/* Size of arg list */
	lintra_args 			/* Arg list */
};

/* Args for im_lintra_vec().
 */
static im_arg_desc lintra_vec_args[] = {
	IM_INPUT_DOUBLEVEC( &quot;a&quot; ),
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_INPUT_DOUBLEVEC( &quot;b&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; )
};

/* Call im_lintra_vec() via arg vector.
 */
static int
lintra_vec_vec( im_object *argv )
{</B></FONT>
	im_doublevec_object *dva = (im_doublevec_object *) argv[0];
	im_doublevec_object *dvb = (im_doublevec_object *) argv[2];

	if( dva-&gt;n != dvb-&gt;n ) {
		im_error( &quot;im_lintra_vec&quot;, 
			&quot;%s&quot;, _( &quot;vectors not equal length&quot; ) );
		return( -1 );
	}

	return( im_lintra_vec( dva-&gt;n, dva-&gt;vec, argv[1], dvb-&gt;vec, argv[3] ) );
}

/* Description of im_lintra_vec().
 */ 
static im_function lintra_vec_desc = {
	&quot;im_lintra_vec&quot;, 		/* Name */
	N_( &quot;calculate a*in + b -&gt; out, a and b vectors&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	lintra_vec_vec, 		/* Dispatch function */
	IM_NUMBER( lintra_vec_args ), 	/* Size of arg list */
	lintra_vec_args 		/* Arg list */
};

/* Call im_log10tra via arg vector.
 */
static int
log10tra_vec( im_object *argv )
{
	return( im_log10tra( argv[0], argv[1] ) );
}

/* Description of im_log10tra.
 */ 
static im_function log10tra_desc = {
	&quot;im_log10tra&quot;, 			/* Name */
	N_( &quot;log10 of image&quot; ),		/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	log10tra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_logtra via arg vector.
 */
static int
logtra_vec( im_object *argv )
{
	return( im_logtra( argv[0], argv[1] ) );
}

/* Description of im_logtra.
 */ 
static im_function logtra_desc = {
	&quot;im_logtra&quot;, 			/* Name */
	N_( &quot;ln of image&quot; ),		/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	logtra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_tantra via arg vector.
 */
static int
tantra_vec( im_object *argv )
{
	return( im_tantra( argv[0], argv[1] ) );
}

/* Description of im_tantra.
 */ 
static im_function tantra_desc = {
	&quot;im_tantra&quot;, 			/* Name */
	N_( &quot;tan of image (angles in degrees)&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	tantra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_atantra via arg vector.
 */
static int
atantra_vec( im_object *argv )
{
	return( im_atantra( argv[0], argv[1] ) );
}

/* Description of im_atantra.
 */ 
static im_function atantra_desc = {
	&quot;im_atantra&quot;, 			/* Name */
	N_( &quot;atan of image (result in degrees)&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	atantra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_costra via arg vector.
 */
static int
costra_vec( im_object *argv )
{
	return( im_costra( argv[0], argv[1] ) );
}

/* Description of im_costra.
 */ 
static im_function costra_desc = {
	&quot;im_costra&quot;, 			/* Name */
	N_( &quot;cos of image (angles in degrees)&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	costra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_acostra via arg vector.
 */
static int
acostra_vec( im_object *argv )
{
	return( im_acostra( argv[0], argv[1] ) );
}

/* Description of im_acostra.
 */ 
static im_function acostra_desc = {
	&quot;im_acostra&quot;, 			/* Name */
	N_( &quot;acos of image (result in degrees)&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	acostra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_ceil via arg vector.
 */
static int
ceil_vec( im_object *argv )
{
	return( im_ceil( argv[0], argv[1] ) );
}

/* Description of im_ceil.
 */ 
static im_function ceil_desc = {
	&quot;im_ceil&quot;, 			/* Name */
	N_( &quot;round to smallest integer value not less than&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	ceil_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_floor via arg vector.
 */
static int
floor_vec( im_object *argv )
{
	return( im_floor( argv[0], argv[1] ) );
}

/* Description of im_floor.
 */ 
static im_function floor_desc = {
	&quot;im_floor&quot;, 			/* Name */
	N_( &quot;round to largest integer value not greater than&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	floor_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_rint via arg vector.
 */
static int
rint_vec( im_object *argv )
{
	return( im_rint( argv[0], argv[1] ) );
}

/* Description of im_rint.
 */ 
static im_function rint_desc = {
	&quot;im_rint&quot;, 			/* Name */
	N_( &quot;round to nearest integer value&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	rint_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_sintra via arg vector.
 */
static int
sintra_vec( im_object *argv )
{
	return( im_sintra( argv[0], argv[1] ) );
}

/* Description of im_sintra.
 */ 
static im_function sintra_desc = {
	&quot;im_sintra&quot;, 			/* Name */
	N_( &quot;sin of image (angles in degrees)&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	sintra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_bandmean via arg vector.
 */
static int
bandmean_vec( im_object *argv )
{
	return( im_bandmean( argv[0], argv[1] ) );
}

/* Description of im_bandmean.
 */ 
static im_function bandmean_desc = {
	&quot;im_bandmean&quot;, 			/* Name */
	N_( &quot;average image bands&quot; ),
	IM_FN_PIO,			/* Flags */
	bandmean_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_sign via arg vector.
 */
static int
sign_vec( im_object *argv )
{
	return( im_sign( argv[0], argv[1] ) );
}

/* Description of im_sign.
 */ 
static im_function sign_desc = {
	&quot;im_sign&quot;, 			/* Name */
	N_( &quot;unit vector in direction of value&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	sign_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_asintra via arg vector.
 */
static int
asintra_vec( im_object *argv )
{
	return( im_asintra( argv[0], argv[1] ) );
}

/* Description of im_asintra.
 */ 
static im_function asintra_desc = {
	&quot;im_asintra&quot;, 			/* Name */
	N_( &quot;asin of image (result in degrees)&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	asintra_vec, 			/* Dispatch function */
	IM_NUMBER( one_in_one_out ), 	/* Size of arg list */
	one_in_one_out 			/* Arg list */
};

/* Call im_max via arg vector.
 */
static int
max_vec( im_object *argv )
{
	double f;
<A NAME="11"></A>
	if( im_max( argv[0], &amp;f ) )
		return( -1 );
<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#11',2,'match1138-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	*((double *) argv[1]) = f;

	return( 0 );
}

/* Description of im_max.
 */ 
static im_function max_desc = {
	&quot;im_max&quot;, 			/* Name */
	N_( &quot;maximum value of image&quot; ),	/* Description */
	IM_FN_PIO,			/* Flags */
	max_vec, 			/* Dispatch function */
	IM_NUMBER( image_in_num_out ), 	/* Size of arg list */
	image_in_num_out 		/* Arg list */
};

/* Args for maxpos (and minpos).
 */
static im_arg_desc maxpos_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_COMPLEX( &quot;position&quot; )
};

/* Call im_maxpos via arg vector.
 */
static int</B></FONT>
maxpos_vec( im_object *argv )
{
	double f;
	int x, y;

	if( im_maxpos( argv[0], &amp;x, &amp;y, &amp;f ) )
		return( -1 );

	((double *) argv[1])[0] = x;
	((double *) argv[1])[1] = y;

	return( 0 );
}

/* Description of im_maxpos.
 */ 
static im_function maxpos_desc = {
	&quot;im_maxpos&quot;, 			/* Name */
	N_( &quot;position of maximum value of image&quot; ),
	0,				/* Flags */
	maxpos_vec, 			/* Dispatch function */
	IM_NUMBER( maxpos_args ), 	/* Size of arg list */
	maxpos_args 			/* Arg list */
};

/* Args to im_maxpos_avg.
 */
static im_arg_desc maxpos_avg_args[] = {
  IM_INPUT_IMAGE (&quot;in&quot;),
  IM_OUTPUT_DOUBLE(&quot;x&quot;),
  IM_OUTPUT_DOUBLE(&quot;y&quot;),
  IM_OUTPUT_DOUBLE(&quot;out&quot;)
};

/* Call im_maxpos_avg via arg vector.
 */
<A NAME="4"></A>static int
maxpos_avg_vec( im_object *argv )
{
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#4',2,'match1138-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  return im_maxpos_avg( argv[0], argv[1], argv[2], argv[3] );
}

/* Description of im_maxpos_avg.
 */
static im_function maxpos_avg_desc = {
  &quot;im_maxpos_avg&quot;,
  N_( &quot;position of maximum value of image, averaging in case of draw&quot; ),
  IM_FN_PIO,
  maxpos_avg_vec,
  IM_NUMBER( maxpos_avg_args ),
  maxpos_avg_args
};

/* Args to im_min/maxpos_vec.
 */
static im_arg_desc maxpos_vec_args[] = {
  IM_INPUT_IMAGE (&quot;in&quot;),
  IM_INPUT_INT (&quot;n&quot;),
  IM_OUTPUT_INTVEC(&quot;xes&quot;),
  IM_OUTPUT_INTVEC(&quot;yes&quot;),
  IM_OUTPUT_DOUBLEVEC(&quot;maxima&quot;)
};

/* Call im_maxpos_vec via arg vector.
 */
static int
maxpos_vec_vec( im_object *argv )
{
  int n = *((int *) argv[1]);</B></FONT>
  im_intvec_object *xes = argv[2];
  im_intvec_object *yes = argv[3];
  im_doublevec_object *maxima = argv[4];

  xes-&gt;vec = IM_ARRAY( NULL, n, int );
  xes-&gt;n = n;
  yes-&gt;vec = IM_ARRAY( NULL, n, int );
  yes-&gt;n = n;
  maxima-&gt;vec = IM_ARRAY( NULL, n, double );
  maxima-&gt;n = n;
  if( !xes-&gt;vec || !yes-&gt;vec || !maxima-&gt;vec ||
    im_maxpos_vec( argv[0], xes-&gt;vec, yes-&gt;vec, maxima-&gt;vec, n ) )
    return -1;

  return 0;
}

/* Description of im_maxpos_vec.
 */
static im_function maxpos_vec_desc = {
  &quot;im_maxpos_vec&quot;,
  N_( &quot;position and value of n maxima of image&quot; ),
  IM_FN_PIO,
  maxpos_vec_vec,
  IM_NUMBER( maxpos_vec_args ),
  maxpos_vec_args
};

/* Call im_minpos_vec via arg vector.
 */
static int
minpos_vec_vec( im_object *argv )
{
  int n = *((int *) argv[1]);
  im_intvec_object *xes = argv[2];
  im_intvec_object *yes = argv[3];
  im_doublevec_object *minima = argv[4];

  xes-&gt;vec = IM_ARRAY( NULL, n, int );
  xes-&gt;n = n;
  yes-&gt;vec = IM_ARRAY( NULL, n, int );
  yes-&gt;n = n;
  minima-&gt;vec = IM_ARRAY( NULL, n, double );
  minima-&gt;n = n;
  if( !xes-&gt;vec || !yes-&gt;vec || !minima-&gt;vec ||
    im_minpos_vec( argv[0], xes-&gt;vec, yes-&gt;vec, minima-&gt;vec, n ) )
    return -1;

  return 0;
}

/* Description of im_minpos_vec.
 */
static im_function minpos_vec_desc = {
  &quot;im_minpos_vec&quot;,
  N_( &quot;position and value of n minima of image&quot; ),
  IM_FN_PIO,
  minpos_vec_vec,
  IM_NUMBER( maxpos_vec_args ),
  maxpos_vec_args
};

/* Args for measure.
 */
static im_arg_desc measure_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_DMASK( &quot;mask&quot; ),
	IM_INPUT_INT( &quot;x&quot; ),
	IM_INPUT_INT( &quot;y&quot; ),
	IM_INPUT_INT( &quot;w&quot; ),
	IM_INPUT_INT( &quot;h&quot; ),
	IM_INPUT_INT( &quot;h_patches&quot; ),
	IM_INPUT_INT( &quot;v_patches&quot; )
};

/* Call im_measure via arg vector.
 */
static int
measure_vec( im_object *argv )
<A NAME="3"></A>{
	im_mask_object *mo = argv[1];

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#3',2,'match1138-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int x = *((int *) argv[2]);
	int y = *((int *) argv[3]);
	int w = *((int *) argv[4]);
	int h = *((int *) argv[5]);

	int u = *((int *) argv[6]);
	int v = *((int *) argv[7]);</B></FONT>

	if( !(mo-&gt;mask = 
		im_measure_area( argv[0], 
			x, y, w, h, u, v, NULL, 0, mo-&gt;name )) ) {
		return( -1 );
	}

	return( 0 );
}

/* Description of im_measure.
 */
static im_function measure_desc = {
	&quot;im_measure&quot;, 			/* Name */
	N_( &quot;measure averages of a grid of patches&quot; ),
	IM_FN_PIO,			/* Flags */
	measure_vec, 			/* Dispatch function */
	IM_NUMBER( measure_args ), 	/* Size of arg list */
	measure_args 			/* Arg list */
};

/* Call im_min via arg vector.
 */
static int
min_vec( im_object *argv )
{
	double f;

	if( im_min( argv[0], &amp;f ) )
		return( -1 );
	*((double *) argv[1]) = f;

	return( 0 );
}

/* Description of im_min.
 */ 
static im_function min_desc = {
	&quot;im_min&quot;, 			/* Name */
	N_( &quot;minimum value of image&quot; ),	/* Description */
	IM_FN_PIO,			/* Flags */
	min_vec, 			/* Dispatch function */
	IM_NUMBER( image_in_num_out ), 	/* Size of arg list */
	image_in_num_out 		/* Arg list */
};

/* Call im_minpos via arg vector.
 */
static int
minpos_vec( im_object *argv )
{
	double f;
	int x, y;

	if( im_minpos( argv[0], &amp;x, &amp;y, &amp;f ) )
		return( -1 );

	((double *) argv[1])[0] = x;
	((double *) argv[1])[1] = y;

	return( 0 );
}

/* Description of im_minpos.
 */ 
static im_function minpos_desc = {
	&quot;im_minpos&quot;, 			/* Name */
	N_( &quot;position of minimum value of image&quot; ),
	0,				/* Flags */
	minpos_vec, 			/* Dispatch function */
	IM_NUMBER( maxpos_args ), 	/* Size of arg list */
	maxpos_args 			/* Arg list */
};

/* Call im_remainder via arg vector.
 */
static int
remainder_vec( im_object *argv )
{
	return( im_remainder( argv[0], argv[1], argv[2] ) );
}

/* Description of im_remainder.
 */ 
static im_function remainder_desc = {
	&quot;im_remainder&quot;, 		/* Name */
	N_( &quot;remainder after integer division&quot; ),	/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	remainder_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Call im_remainderconst via arg vector.
 */
static int
remainderconst_vec( im_object *argv )
{
	double c = *((double *) argv[2]);

	return( im_remainderconst( argv[0], argv[1], c ) );
}

/* Args for im_remainderconst().
 */
static im_arg_desc remainderconst_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_DOUBLE( &quot;x&quot; )
};

/* Description of im_remainderconst.
 */ 
static im_function remainderconst_desc = {
	&quot;im_remainderconst&quot;, 		/* Name */
	N_( &quot;remainder after integer division by a constant&quot; ),/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	remainderconst_vec, 		/* Dispatch function */
	IM_NUMBER( remainderconst_args ),/* Size of arg list */
	remainderconst_args 		/* Arg list */
};

/* Call im_remainder_vec via arg vector.
 */
static int
remainder_vec_vec( im_object *argv )
{
	im_doublevec_object *dv = (im_doublevec_object *) argv[2];

	return( im_remainder_vec( argv[0], argv[1], dv-&gt;n, dv-&gt;vec ) );
}

/* Args for im_remainder_vec().
 */
static im_arg_desc remainder_vec_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
	IM_INPUT_DOUBLEVEC( &quot;x&quot; )
};

/* Description of im_remainder_vec.
 */ 
static im_function remainder_vec_desc = {
	&quot;im_remainder_vec&quot;, 		/* Name */
	N_( &quot;remainder after integer division by a vector of constants&quot; ),
					/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	remainder_vec_vec, 		/* Dispatch function */
	IM_NUMBER( remainder_vec_args ),/* Size of arg list */
	remainder_vec_args 		/* Arg list */
};

/* Call im_multiply via arg vector.
 */
static int
<A NAME="1"></A>multiply_vec( im_object *argv )
{
	return( im_multiply( argv[0], argv[1], argv[2] ) );
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#1',2,'match1138-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_multiply.
 */ 
static im_function multiply_desc = {
	&quot;im_multiply&quot;, 			/* Name */
	N_( &quot;multiply two images&quot; ),	/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	multiply_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Call im_powtra() via arg vector.
 */
static int
powtra_vec( im_object *argv )
{
	double a = *((double *) argv[2]);

	return( im_powtra( argv[0], argv[1], a ) );
}

/* Description of im_powtra().
 */ 
static im_function powtra_desc = {
	&quot;im_powtra&quot;, 			/* Name */
	N_( &quot;pel^x of image&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	powtra_vec, 			/* Dispatch function */
	IM_NUMBER( powtra_args ), 	/* Size of arg list */
	powtra_args 			/* Arg list */
};

/* Call im_powtra_vec() via arg vector.
 */
static int
powtra_vec_vec( im_object *argv )
{</B></FONT>
	im_doublevec_object *rv = (im_doublevec_object *) argv[2];

	return( im_powtra_vec( argv[0], argv[1], rv-&gt;n, rv-&gt;vec ) );
}

/* Description of im_powtra_vec().
 */ 
static im_function powtra_vec_desc = {
	&quot;im_powtra_vec&quot;, 		/* Name */
	N_( &quot;pel^[x,y,z] of image&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	powtra_vec_vec, 		/* Dispatch function */
	IM_NUMBER( expntra_vec_args ), 	/* Size of arg list */
	expntra_vec_args 		/* Arg list */
};

/* Args for im_stats.
 */
static im_arg_desc stats_args[] = {
	IM_INPUT_IMAGE( &quot;in&quot; ),
	IM_OUTPUT_DMASK_STATS( &quot;statistics&quot; )
};

/* Call im_stats() via arg vector.
 */
static int
stats_vec( im_object *argv )
{
	im_mask_object *mo = argv[1];

	if( !(mo-&gt;mask = im_stats( argv[0] )) )
		return( -1 );

	return( 0 );
}

/* Description of im_stats().
 */ 
static im_function stats_desc = {
	&quot;im_stats&quot;, 			/* Name */
	N_( &quot;many image statistics in one pass&quot; ),
	IM_FN_PIO,			/* Flags */
	stats_vec, 			/* Dispatch function */
	IM_NUMBER( stats_args ), 	/* Size of arg list */
	stats_args 			/* Arg list */
};

/* Call im_subtract via arg vector.
 */
static int
subtract_vec( im_object *argv )
{
	return( im_subtract( argv[0], argv[1], argv[2] ) );
}

/* Description of im_subtract.
 */ 
static im_function subtract_desc = {
	&quot;im_subtract&quot;, 			/* Name */
	N_( &quot;subtract two images&quot; ),	/* Description */
	IM_FN_PIO,			/* Flags */
	subtract_vec, 			/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Args for im_linreg.
 */
static im_arg_desc linreg_args[] = {
	IM_INPUT_IMAGEVEC( &quot;ins&quot; ),
	IM_OUTPUT_IMAGE( &quot;out&quot; ),
        IM_INPUT_DOUBLEVEC( &quot;xs&quot; )
};

/* Call im_linreg() via arg vector.
 */
static int
linreg_vec( im_object *argv )
{
#define FUNCTION_NAME &quot;im_linreg_vec&quot;
  im_imagevec_object *ins_vec= (im_imagevec_object*) argv[0];
  im_doublevec_object *xs_vec= (im_doublevec_object*) argv[2];
  IMAGE *out= (IMAGE*) argv[1];
  IMAGE **ins= IM_ARRAY( out, ins_vec-&gt; n + 1, IMAGE* );
  int i;

  if( ! ins )
    return -1;

  for( i= 0; i &lt; ins_vec-&gt; n; ++i )
    ins[ i ]= ins_vec-&gt; vec[ i ];

  ins[ ins_vec-&gt; n ]= NULL;
  
  if( xs_vec-&gt; n != ins_vec-&gt; n ){
    im_error( FUNCTION_NAME, &quot;image vector and x vector differ in length&quot; );
    return -1;
  }
  return im_linreg( ins, out, xs_vec-&gt; vec );

#undef FUNCTION_NAME
}

/* Description of im_linreg().
 */ 
static im_function linreg_desc = {
	&quot;im_linreg&quot;, 			/* Name */
	N_( &quot;pixelwise linear regression&quot; ),
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	linreg_vec, 			/* Dispatch function */
	IM_NUMBER( linreg_args ), 	/* Size of arg list */
	linreg_args 			/* Arg list */
};

/* Call im_cross_phase via arg vector.
 */
static int
<A NAME="9"></A>cross_phase_vec( im_object *argv )
{
	return( im_cross_phase( argv[0], argv[1], argv[2] ) );
<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1138-0.html#9',2,'match1138-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

/* Description of im_cross_phase.
 */ 
static im_function cross_phase_desc = {
	&quot;im_cross_phase&quot;, 			/* Name */
	N_( &quot;phase of cross power spectrum of two complex images&quot; ),	/* Description */
	IM_FN_PIO | IM_FN_PTOP,		/* Flags */
	cross_phase_vec, 		/* Dispatch function */
	IM_NUMBER( two_in_one_out ), 	/* Size of arg list */
	two_in_one_out 			/* Arg list */
};

/* Package up all these functions.
 */
static im_function *arith_list[] = {
	&amp;abs_desc,
	&amp;acostra_desc,
	&amp;add_desc,
	&amp;asintra_desc,
	&amp;atantra_desc,
	&amp;avg_desc,
        &amp;point_desc,
        &amp;point_bilinear_desc,
        &amp;bandmean_desc,
	&amp;ceil_desc,
	&amp;costra_desc,
	&amp;cross_phase_desc,
	&amp;deviate_desc,
	&amp;divide_desc,
	&amp;exp10tra_desc,
	&amp;expntra_desc,
	&amp;expntra_vec_desc,
	&amp;exptra_desc,
	&amp;floor_desc,
	&amp;invert_desc,
	&amp;lintra_desc,
	&amp;linreg_desc,
	&amp;lintra_vec_desc,
	&amp;log10tra_desc,
	&amp;logtra_desc,
	&amp;max_desc,
	&amp;maxpos_desc,
	&amp;maxpos_avg_desc,
	&amp;maxpos_vec_desc,
	&amp;measure_desc,
	&amp;min_desc,
	&amp;minpos_desc,
	&amp;minpos_vec_desc,
	&amp;multiply_desc,
	&amp;powtra_desc,
	&amp;powtra_vec_desc,
	&amp;recomb_desc,
	&amp;remainder_desc,
	&amp;remainderconst_desc,
	&amp;remainder_vec_desc,
	&amp;rint_desc,
	&amp;sign_desc,
	&amp;sintra_desc,
	&amp;stats_desc,
	&amp;subtract_desc,
	&amp;tantra_desc
};

/* Package of functions.
 */
im_package im__arithmetic = {
	&quot;arithmetic&quot;,
	IM_NUMBER( arith_list ),
	arith_list
};</B></FONT>
</PRE>
</div>
  </div>
</body>
</html>
