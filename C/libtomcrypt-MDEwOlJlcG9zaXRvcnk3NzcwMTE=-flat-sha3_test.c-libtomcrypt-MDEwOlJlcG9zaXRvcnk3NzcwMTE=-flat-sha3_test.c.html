
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sha3_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SHA3
3  int sha3_224_test(void)
4  {
5  #ifndef LTC_TEST
6     return CRYPT_NOP;
7  #else
8     unsigned char buf[200], hash[224 / 8];
9     int i;
10     hash_state c;
11     const unsigned char c1 = 0xa3;
12     const unsigned char sha3_224_empty[224 / 8] = {
13        0x6b, 0x4e, 0x03, 0x42, 0x36, 0x67, 0xdb, 0xb7,
14        0x3b, 0x6e, 0x15, 0x45, 0x4f, 0x0e, 0xb1, 0xab,
15        0xd4, 0x59, 0x7f, 0x9a, 0x1b, 0x07, 0x8e, 0x3f,
16        0x5b, 0x5a, 0x6b, 0xc7
17     };
18     const unsigned char sha3_224_0xa3_200_times[224 / 8] = {
19        0x93, 0x76, 0x81, 0x6a, 0xba, 0x50, 0x3f, 0x72,
20        0xf9, 0x6c, 0xe7, 0xeb, 0x65, 0xac, 0x09, 0x5d,
21        0xee, 0xe3, 0xbe, 0x4b, 0xf9, 0xbb, 0xc2, 0xa1,
22        0xcb, 0x7e, 0x11, 0xe0
23     };
24     XMEMSET(buf, c1, sizeof(buf));
25     sha3_224_init(&c);
26     sha3_done(&c, hash);
27     if (compare_testvector(hash, sizeof(hash), sha3_224_empty, sizeof(sha3_224_empty), "SHA3-224", 0)) {
28        return CRYPT_FAIL_TESTVECTOR;
29     }
30     sha3_224_init(&c);
31     sha3_process(&c, buf, sizeof(buf) / 2);
32     sha3_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
33     sha3_done(&c, hash);
34     if (compare_testvector(hash, sizeof(hash), sha3_224_0xa3_200_times, sizeof(sha3_224_0xa3_200_times), "SHA3-224", 1)) {
35        return CRYPT_FAIL_TESTVECTOR;
36     }
37     i = 200;
38     sha3_224_init(&c);
39     while (i--) {
40         sha3_process(&c, &c1, 1);
41     }
42     sha3_done(&c, hash);
43     if (compare_testvector(hash, sizeof(hash), sha3_224_0xa3_200_times, sizeof(sha3_224_0xa3_200_times), "SHA3-224", 2)) {
44        return CRYPT_FAIL_TESTVECTOR;
45     }
46     return CRYPT_OK;
47  #endif
48  }
49  int sha3_256_test(void)
50  {
51  #ifndef LTC_TEST
52     return CRYPT_NOP;
53  #else
54     unsigned char buf[200], hash[256 / 8];
55     int i;
56     hash_state c;
57     const unsigned char c1 = 0xa3;
58     const unsigned char sha3_256_empty[256 / 8] = {
59        0xa7, 0xff, 0xc6, 0xf8, 0xbf, 0x1e, 0xd7, 0x66,
60        0x51, 0xc1, 0x47, 0x56, 0xa0, 0x61, 0xd6, 0x62,
61        0xf5, 0x80, 0xff, 0x4d, 0xe4, 0x3b, 0x49, 0xfa,
62        0x82, 0xd8, 0x0a, 0x4b, 0x80, 0xf8, 0x43, 0x4a
63     };
64     const unsigned char sha3_256_0xa3_200_times[256 / 8] = {
65        0x79, 0xf3, 0x8a, 0xde, 0xc5, 0xc2, 0x03, 0x07,
66        0xa9, 0x8e, 0xf7, 0x6e, 0x83, 0x24, 0xaf, 0xbf,
67        0xd4, 0x6c, 0xfd, 0x81, 0xb2, 0x2e, 0x39, 0x73,
68        0xc6, 0x5f, 0xa1, 0xbd, 0x9d, 0xe3, 0x17, 0x87
69     };
70     XMEMSET(buf, c1, sizeof(buf));
71     sha3_256_init(&c);
72     sha3_done(&c, hash);
73     if (compare_testvector(hash, sizeof(hash), sha3_256_empty, sizeof(sha3_256_empty), "SHA3-256", 0)) {
74        return CRYPT_FAIL_TESTVECTOR;
75     }
76     sha3_256_init(&c);
77     sha3_process(&c, buf, sizeof(buf));
78     sha3_done(&c, hash);
79     if (compare_testvector(hash, sizeof(hash), sha3_256_0xa3_200_times, sizeof(sha3_256_0xa3_200_times), "SHA3-256", 1)) {
80        return CRYPT_FAIL_TESTVECTOR;
81     }
82     sha3_256_init(&c);
83     sha3_process(&c, buf, sizeof(buf) / 2);
84     sha3_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
85     sha3_done(&c, hash);
86     if (compare_testvector(hash, sizeof(hash), sha3_256_0xa3_200_times, sizeof(sha3_256_0xa3_200_times), "SHA3-256", 2)) {
87        return CRYPT_FAIL_TESTVECTOR;
88     }
89     i = 200;
90     sha3_256_init(&c);
91     while (i--) {
92         sha3_process(&c, &c1, 1);
93     }
94     sha3_done(&c, hash);
95     if (compare_testvector(hash, sizeof(hash), sha3_256_0xa3_200_times, sizeof(sha3_256_0xa3_200_times), "SHA3-256", 3)) {
96        return CRYPT_FAIL_TESTVECTOR;
97     }
98     sha3_256_init(&c);
99     sha3_process(&c, (unsigned char*)
100             "\xb7\x71\xd5\xce\xf5\xd1\xa4\x1a"
101             "\x93\xd1\x56\x43\xd7\x18\x1d\x2a"
102             "\x2e\xf0\xa8\xe8\x4d\x91\x81\x2f"
103             "\x20\xed\x21\xf1\x47\xbe\xf7\x32"
104             "\xbf\x3a\x60\xef\x40\x67\xc3\x73"
105             "\x4b\x85\xbc\x8c\xd4\x71\x78\x0f"
106             "\x10\xdc\x9e\x82\x91\xb5\x83\x39"
107             "\xa6\x77\xb9\x60\x21\x8f\x71\xe7"
108             "\x93\xf2\x79\x7a\xea\x34\x94\x06"
109             "\x51\x28\x29\x06\x5d\x37\xbb\x55"
110             "\xea\x79\x6f\xa4\xf5\x6f\xd8\x89"
111             "\x6b\x49\xb2\xcd\x19\xb4\x32\x15"
112             "\xad\x96\x7c\x71\x2b\x24\xe5\x03"
113             "\x2d\x06\x52\x32\xe0\x2c\x12\x74"
114             "\x09\xd2\xed\x41\x46\xb9\xd7\x5d"
115             "\x76\x3d\x52\xdb\x98\xd9\x49\xd3"
116             "\xb0\xfe\xd6\xa8\x05\x2f\xbb", 1080 / 8);
117     sha3_done(&c, hash);
118     if(compare_testvector(hash, sizeof(hash),
119             "\xa1\x9e\xee\x92\xbb\x20\x97\xb6"
120             "\x4e\x82\x3d\x59\x77\x98\xaa\x18"
121             "\xbe\x9b\x7c\x73\x6b\x80\x59\xab"
122             "\xfd\x67\x79\xac\x35\xac\x81\xb5", 256 / 8, "SHA3-256", 4)) {
123        return CRYPT_FAIL_TESTVECTOR;
124     }
125     return CRYPT_OK;
126  #endif
127  }
128  int sha3_384_test(void)
129  {
130  #ifndef LTC_TEST
131     return CRYPT_NOP;
132  #else
133     unsigned char buf[200], hash[384 / 8];
134     int i;
135     hash_state c;
136     const unsigned char c1 = 0xa3;
137     const unsigned char sha3_384_0xa3_200_times[384 / 8] = {
138        0x18, 0x81, 0xde, 0x2c, 0xa7, 0xe4, 0x1e, 0xf9,
139        0x5d, 0xc4, 0x73, 0x2b, 0x8f, 0x5f, 0x00, 0x2b,
140        0x18, 0x9c, 0xc1, 0xe4, 0x2b, 0x74, 0x16, 0x8e,
141        0xd1, 0x73, 0x26, 0x49, 0xce, 0x1d, 0xbc, 0xdd,
142        0x76, 0x19, 0x7a, 0x31, 0xfd, 0x55, 0xee, 0x98,
143        0x9f, 0x2d, 0x70, 0x50, 0xdd, 0x47, 0x3e, 0x8f
144     };
145     XMEMSET(buf, c1, sizeof(buf));
146     sha3_384_init(&c);
147     sha3_process(&c, buf, sizeof(buf));
148     sha3_done(&c, hash);
149     if (compare_testvector(hash, sizeof(hash), sha3_384_0xa3_200_times, sizeof(sha3_384_0xa3_200_times), "SHA3-384", 0)) {
150        return CRYPT_FAIL_TESTVECTOR;
151     }
152     sha3_384_init(&c);
153     sha3_process(&c, buf, sizeof(buf) / 2);
154     sha3_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
155     sha3_done(&c, hash);
156     if (compare_testvector(hash, sizeof(hash), sha3_384_0xa3_200_times, sizeof(sha3_384_0xa3_200_times), "SHA3-384", 1)) {
157        return CRYPT_FAIL_TESTVECTOR;
158     }
159     i = 200;
160     sha3_384_init(&c);
161     while (i--) {
162         sha3_process(&c, &c1, 1);
163     }
164     sha3_done(&c, hash);
165     if (compare_testvector(hash, sizeof(hash), sha3_384_0xa3_200_times, sizeof(sha3_384_0xa3_200_times), "SHA3-384", 2)) {
166        return CRYPT_FAIL_TESTVECTOR;
167     }
168     return CRYPT_OK;
169  #endif
170  }
171  int sha3_512_test(void)
172  {
173  #ifndef LTC_TEST
174     return CRYPT_NOP;
175  #else
176     unsigned char buf[200], hash[512 / 8];
177     int i;
178     hash_state c;
179     const unsigned char c1 = 0xa3;
180     const unsigned char sha3_512_0xa3_200_times[512 / 8] = {
181        0xe7, 0x6d, 0xfa, 0xd2, 0x20, 0x84, 0xa8, 0xb1,
182        0x46, 0x7f, 0xcf, 0x2f, 0xfa, 0x58, 0x36, 0x1b,
183        0xec, 0x76, 0x28, 0xed, 0xf5, 0xf3, 0xfd, 0xc0,
184        0xe4, 0x80, 0x5d, 0xc4, 0x8c, 0xae, 0xec, 0xa8,
185        0x1b, 0x7c, 0x13, 0xc3, 0x0a, 0xdf, 0x52, 0xa3,
186        0x65, 0x95, 0x84, 0x73, 0x9a, 0x2d, 0xf4, 0x6b,
187        0xe5, 0x89, 0xc5, 0x1c, 0xa1, 0xa4, 0xa8, 0x41,
188        0x6d, 0xf6, 0x54, 0x5a, 0x1c, 0xe8, 0xba, 0x00
189     };
190     XMEMSET(buf, c1, sizeof(buf));
191     sha3_512_init(&c);
192     sha3_process(&c, buf, sizeof(buf));
193     sha3_done(&c, hash);
194     if (compare_testvector(hash, sizeof(hash), sha3_512_0xa3_200_times, sizeof(sha3_512_0xa3_200_times), "SHA3-512", 0)) {
195        return CRYPT_FAIL_TESTVECTOR;
196     }
197     sha3_512_init(&c);
198     sha3_process(&c, buf, sizeof(buf) / 2);
199     sha3_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
200     sha3_done(&c, hash);
201     if (compare_testvector(hash, sizeof(hash), sha3_512_0xa3_200_times, sizeof(sha3_512_0xa3_200_times), "SHA3-512", 1)) {
202        return CRYPT_FAIL_TESTVECTOR;
203     }
204     i = 200;
205     sha3_512_init(&c);
206     while (i--) {
207         sha3_process(&c, &c1, 1);
208     }
209     sha3_done(&c, hash);
210     if (compare_testvector(hash, sizeof(hash), sha3_512_0xa3_200_times, sizeof(sha3_512_0xa3_200_times), "SHA3-512", 2)) {
211        return CRYPT_FAIL_TESTVECTOR;
212     }
213     return CRYPT_OK;
214  #endif
215  }
216  int sha3_shake_test(void)
217  {
218  #ifndef LTC_TEST
219     return CRYPT_NOP;
220  #else
221     unsigned char buf[200], hash[512];
222     int i;
223     hash_state c;
224     const unsigned char c1 = 0xa3;
225     unsigned long len;
226     const unsigned char shake256_empty[32] = {
227        0xab, 0x0b, 0xae, 0x31, 0x63, 0x39, 0x89, 0x43,
228        0x04, 0xe3, 0x58, 0x77, 0xb0, 0xc2, 0x8a, 0x9b,
229        0x1f, 0xd1, 0x66, 0xc7, 0x96, 0xb9, 0xcc, 0x25,
230        0x8a, 0x06, 0x4a, 0x8f, 0x57, 0xe2, 0x7f, 0x2a
231     };
232     const unsigned char shake256_0xa3_200_times[32] = {
233        0x6a, 0x1a, 0x9d, 0x78, 0x46, 0x43, 0x6e, 0x4d,
234        0xca, 0x57, 0x28, 0xb6, 0xf7, 0x60, 0xee, 0xf0,
235        0xca, 0x92, 0xbf, 0x0b, 0xe5, 0x61, 0x5e, 0x96,
236        0x95, 0x9d, 0x76, 0x71, 0x97, 0xa0, 0xbe, 0xeb
237     };
238     const unsigned char shake128_empty[32] = {
239        0x43, 0xe4, 0x1b, 0x45, 0xa6, 0x53, 0xf2, 0xa5,
240        0xc4, 0x49, 0x2c, 0x1a, 0xdd, 0x54, 0x45, 0x12,
241        0xdd, 0xa2, 0x52, 0x98, 0x33, 0x46, 0x2b, 0x71,
242        0xa4, 0x1a, 0x45, 0xbe, 0x97, 0x29, 0x0b, 0x6f
243     };
244     const unsigned char shake128_0xa3_200_times[32] = {
245        0x44, 0xc9, 0xfb, 0x35, 0x9f, 0xd5, 0x6a, 0xc0,
246        0xa9, 0xa7, 0x5a, 0x74, 0x3c, 0xff, 0x68, 0x62,
247        0xf1, 0x7d, 0x72, 0x59, 0xab, 0x07, 0x52, 0x16,
248        0xc0, 0x69, 0x95, 0x11, 0x64, 0x3b, 0x64, 0x39
249     };
250     XMEMSET(buf, c1, sizeof(buf));
251     sha3_shake_init(&c, 256);
252     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
253     if (compare_testvector(hash, sizeof(shake256_empty), shake256_empty, sizeof(shake256_empty), "SHAKE256", 0)) {
254        return CRYPT_FAIL_TESTVECTOR;
255     }
256     len = 512;
257     sha3_shake_memory(256, buf, sizeof(buf), hash, &len);
258     if (compare_testvector(hash + 480, sizeof(shake256_0xa3_200_times), shake256_0xa3_200_times, sizeof(shake256_0xa3_200_times), "SHAKE256", 1)) {
259        return CRYPT_FAIL_TESTVECTOR;
260     }
261     sha3_shake_init(&c, 256);
262     sha3_shake_process(&c, buf, sizeof(buf));
263     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
264     if (compare_testvector(hash, sizeof(shake256_0xa3_200_times), shake256_0xa3_200_times, sizeof(shake256_0xa3_200_times), "SHAKE256", 2)) {
265        return CRYPT_FAIL_TESTVECTOR;
266     }
267     sha3_shake_init(&c, 256);
268     sha3_shake_process(&c, buf, sizeof(buf) / 2);
269     sha3_shake_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
270     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
271     if (compare_testvector(hash, sizeof(shake256_0xa3_200_times), shake256_0xa3_200_times, sizeof(shake256_0xa3_200_times), "SHAKE256", 3)) {
272        return CRYPT_FAIL_TESTVECTOR;
273     }
274     i = 200;
275     sha3_shake_init(&c, 256);
276     while (i--) sha3_shake_process(&c, &c1, 1);
277     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
278     if (compare_testvector(hash, sizeof(shake256_0xa3_200_times), shake256_0xa3_200_times, sizeof(shake256_0xa3_200_times), "SHAKE256", 4)) {
279        return CRYPT_FAIL_TESTVECTOR;
280     }
281     sha3_shake_init(&c, 128);
282     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
283     if (compare_testvector(hash, sizeof(shake128_empty), shake128_empty, sizeof(shake128_empty), "SHAKE128", 0)) {
284        return CRYPT_FAIL_TESTVECTOR;
285     }
286     len = 512;
287     sha3_shake_memory(128, buf, sizeof(buf), hash, &len);
288     if (compare_testvector(hash + 480, sizeof(shake128_0xa3_200_times), shake128_0xa3_200_times, sizeof(shake128_0xa3_200_times), "SHAKE128", 1)) {
289        return CRYPT_FAIL_TESTVECTOR;
290     }
291     sha3_shake_init(&c, 128);
292     sha3_shake_process(&c, buf, sizeof(buf));
293     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
294     if (compare_testvector(hash, sizeof(shake128_0xa3_200_times), shake128_0xa3_200_times, sizeof(shake128_0xa3_200_times), "SHAKE128", 2)) {
295        return CRYPT_FAIL_TESTVECTOR;
296     }
297     sha3_shake_init(&c, 128);
298     sha3_shake_process(&c, buf, sizeof(buf) / 2);
299     sha3_shake_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
300     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
301     if (compare_testvector(hash, sizeof(shake128_0xa3_200_times), shake128_0xa3_200_times, sizeof(shake128_0xa3_200_times), "SHAKE128", 3)) {
302        return CRYPT_FAIL_TESTVECTOR;
303     }
304     i = 200;
305     sha3_shake_init(&c, 128);
306     while (i--) sha3_shake_process(&c, &c1, 1);
307     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
308     if (compare_testvector(hash, sizeof(shake128_0xa3_200_times), shake128_0xa3_200_times, sizeof(shake128_0xa3_200_times), "SHAKE128", 4)) {
309        return CRYPT_FAIL_TESTVECTOR;
310     }
311     return CRYPT_OK;
312  #endif
313  }
314  #endif
315  #ifdef LTC_KECCAK
316  int keccak_224_test(void)
317  {
318  #ifndef LTC_TEST
319     return CRYPT_NOP;
320  #else
321     hash_state c;
322     unsigned char hash[MAXBLOCKSIZE];
323     keccak_224_init(&c);
324     keccak_process(&c, (unsigned char*) "\xcc", 1);
325     keccak_done(&c, hash);
326     if(compare_testvector(hash, 28,
327                           "\xa9\xca\xb5\x9e\xb4\x0a\x10\xb2"
328                           "\x46\x29\x0f\x2d\x60\x86\xe3\x2e"
329                           "\x36\x89\xfa\xf1\xd2\x6b\x47\x0c"
330                           "\x89\x9f\x28\x02", 28,
331                           "KECCAK-224", 0) != 0) {
332         return CRYPT_FAIL_TESTVECTOR;
333     }
334     keccak_224_init(&c);
335     keccak_process(&c, (unsigned char*)"\x41\xfb", 2);
336     keccak_done(&c, hash);
337     if(compare_testvector(hash, 28,
338                           "\x61\x5b\xa3\x67\xaf\xdc\x35\xaa"
339                           "\xc3\x97\xbc\x7e\xb5\xd5\x8d\x10"
340                           "\x6a\x73\x4b\x24\x98\x6d\x5d\x97"
341                           "\x8f\xef\xd6\x2c", 28,
342                           "KECCAK-224", 1) != 0) {
343         return CRYPT_FAIL_TESTVECTOR;
344     }
345     keccak_224_init(&c);
346     keccak_process(&c, (unsigned char*)
347                      "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
348                      "\x44\x57\xa5\x7e\xde\x78\x21\x76", 16);
349     keccak_done(&c, hash);
350     if(compare_testvector(hash, 28,
351                           "\x56\x79\xcd\x50\x9c\x51\x20\xaf"
352                           "\x54\x79\x5c\xf4\x77\x14\x96\x41"
353                           "\xcf\x27\xb2\xeb\xb6\xa5\xf9\x03"
354                           "\x40\x70\x4e\x57", 28,
355                           "KECCAK-224", 2) != 0) {
356         return CRYPT_FAIL_TESTVECTOR;
357     }
358     keccak_224_init(&c);
359     keccak_process(&c, (unsigned char*)
360                      "\x43\x3c\x53\x03\x13\x16\x24\xc0"
361                      "\x02\x1d\x86\x8a\x30\x82\x54\x75"
362                      "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
363                      "\x03\x98\xf4\xca\x44\x23\xb9\x82"
364                      "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
365                      "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
366                      "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
367                      "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
368                      "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
369                      "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
370                      "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
371                      "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84"
372                      "\x6d\xcb\xb4\xce", 100);
373     keccak_done(&c, hash);
374     if(compare_testvector(hash, 28,
375                           "\x62\xb1\x0f\x1b\x62\x36\xeb\xc2"
376                           "\xda\x72\x95\x77\x42\xa8\xd4\xe4"
377                           "\x8e\x21\x3b\x5f\x89\x34\x60\x4b"
378                           "\xfd\x4d\x2c\x3a", 28,
379                           "KECCAK-224", 3) != 0) {
380         return CRYPT_FAIL_TESTVECTOR;
381     }
382     return CRYPT_OK;
383  #endif
384  }
385  int keccak_256_test(void)
386  {
387  #ifndef LTC_TEST
388     return CRYPT_NOP;
389  #else
390     hash_state c;
391     unsigned char hash[MAXBLOCKSIZE];
392     keccak_256_init(&c);
393     keccak_process(&c, (unsigned char*) "\xcc", 1);
394     keccak_done(&c, hash);
395     if(compare_testvector(hash, 32,
396                           "\xee\xad\x6d\xbf\xc7\x34\x0a\x56"
397                           "\xca\xed\xc0\x44\x69\x6a\x16\x88"
398                           "\x70\x54\x9a\x6a\x7f\x6f\x56\x96"
399                           "\x1e\x84\xa5\x4b\xd9\x97\x0b\x8a", 32,
400                           "KECCAK-256", 0) != 0) {
401         return CRYPT_FAIL_TESTVECTOR;
402     }
403     keccak_256_init(&c);
404     keccak_process(&c, (unsigned char*)"\x41\xfb", 2);
405     keccak_done(&c, hash);
406     if(compare_testvector(hash, 32,
407                           "\xa8\xea\xce\xda\x4d\x47\xb3\x28"
408                           "\x1a\x79\x5a\xd9\xe1\xea\x21\x22"
409                           "\xb4\x07\xba\xf9\xaa\xbc\xb9\xe1"
410                           "\x8b\x57\x17\xb7\x87\x35\x37\xd2", 32,
411                           "KECCAK-256", 1) != 0) {
412         return CRYPT_FAIL_TESTVECTOR;
413     }
414     keccak_256_init(&c);
415     keccak_process(&c, (unsigned char*)
416                      "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
417                      "\x44\x57\xa5\x7e\xde\x78\x21\x76", 16);
418     keccak_done(&c, hash);
419     if(compare_testvector(hash, 32,
420                           "\x0e\x32\xde\xfa\x20\x71\xf0\xb5"
421                           "\xac\x0e\x6a\x10\x8b\x84\x2e\xd0"
422                           "\xf1\xd3\x24\x97\x12\xf5\x8e\xe0"
423                           "\xdd\xf9\x56\xfe\x33\x2a\x5f\x95", 32,
424                           "KECCAK-256", 2) != 0) {
425         return CRYPT_FAIL_TESTVECTOR;
426     }
427     keccak_256_init(&c);
428     keccak_process(&c, (unsigned char*)
429                      "\x43\x3c\x53\x03\x13\x16\x24\xc0"
430                      "\x02\x1d\x86\x8a\x30\x82\x54\x75"
431                      "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
432                      "\x03\x98\xf4\xca\x44\x23\xb9\x82"
433                      "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
434                      "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
435                      "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
436                      "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
437                      "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
438                      "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
439                      "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
440                      "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84"
441                      "\x6d\xcb\xb4\xce", 100);
442     keccak_done(&c, hash);
443     if(compare_testvector(hash, 32,
444                           "\xce\x87\xa5\x17\x3b\xff\xd9\x23"
445                           "\x99\x22\x16\x58\xf8\x01\xd4\x5c"
446                           "\x29\x4d\x90\x06\xee\x9f\x3f\x9d"
<span onclick='openModal()' class='match'>447                           "\x41\x9c\x8d\x42\x77\x48\xdc\x41", 32,
448                           "KECCAK-256", 3) != 0) {
449         return CRYPT_FAIL_TESTVECTOR;
450     }
451     return CRYPT_OK;
</span>452  #endif
453  }
454  int keccak_384_test(void)
455  {
456  #ifndef LTC_TEST
457     return CRYPT_NOP;
458  #else
459     hash_state c;
460     unsigned char hash[MAXBLOCKSIZE];
461     keccak_384_init(&c);
462     keccak_process(&c, (unsigned char*) "\xcc", 1);
463     keccak_done(&c, hash);
464     if(compare_testvector(hash, 48,
465                           "\x1b\x84\xe6\x2a\x46\xe5\xa2\x01"
466                           "\x86\x17\x54\xaf\x5d\xc9\x5c\x4a"
467                           "\x1a\x69\xca\xf4\xa7\x96\xae\x40"
468                           "\x56\x80\x16\x1e\x29\x57\x26\x41"
469                           "\xf5\xfa\x1e\x86\x41\xd7\x95\x83"
470                           "\x36\xee\x7b\x11\xc5\x8f\x73\xe9", 48,
471                           "KECCAK-384", 0) != 0) {
472         return CRYPT_FAIL_TESTVECTOR;
473     }
474     keccak_384_init(&c);
475     keccak_process(&c, (unsigned char*)"\x41\xfb", 2);
476     keccak_done(&c, hash);
477     if(compare_testvector(hash, 48,
478                           "\x49\x5c\xce\x27\x14\xcd\x72\xc8"
479                           "\xc5\x3c\x33\x63\xd2\x2c\x58\xb5"
480                           "\x59\x60\xfe\x26\xbe\x0b\xf3\xbb"
481                           "\xc7\xa3\x31\x6d\xd5\x63\xad\x1d"
482                           "\xb8\x41\x0e\x75\xee\xfe\xa6\x55"
483                           "\xe3\x9d\x46\x70\xec\x0b\x17\x92", 48,
484                           "KECCAK-384", 1) != 0) {
485         return CRYPT_FAIL_TESTVECTOR;
486     }
487     keccak_384_init(&c);
488     keccak_process(&c, (unsigned char*)
489                      "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
490                      "\x44\x57\xa5\x7e\xde\x78\x21\x76", 16);
491     keccak_done(&c, hash);
492     if(compare_testvector(hash, 48,
493                           "\x18\x42\x2a\xc1\xd3\xa1\xe5\x4b"
494                           "\xad\x87\x68\x83\xd2\xd6\xdd\x65"
495                           "\xf6\x5c\x1d\x5f\x33\xa7\x12\x5c"
496                           "\xc4\xc1\x86\x40\x5a\x12\xed\x64"
497                           "\xba\x96\x67\x2e\xed\xda\x8c\x5a"
498                           "\x63\x31\xd2\x86\x83\xf4\x88\xeb", 48,
499                           "KECCAK-384", 2) != 0) {
500         return CRYPT_FAIL_TESTVECTOR;
501     }
502     keccak_384_init(&c);
503     keccak_process(&c, (unsigned char*)
504                      "\x43\x3c\x53\x03\x13\x16\x24\xc0"
505                      "\x02\x1d\x86\x8a\x30\x82\x54\x75"
506                      "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
507                      "\x03\x98\xf4\xca\x44\x23\xb9\x82"
508                      "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
509                      "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
510                      "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
511                      "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
512                      "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
513                      "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
514                      "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
515                      "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84"
516                      "\x6d\xcb\xb4\xce", 100);
517     keccak_done(&c, hash);
518     if(compare_testvector(hash, 48,
519                           "\x13\x51\x14\x50\x8d\xd6\x3e\x27"
520                           "\x9e\x70\x9c\x26\xf7\x81\x7c\x04"
521                           "\x82\x76\x6c\xde\x49\x13\x2e\x3e"
522                           "\xdf\x2e\xed\xd8\x99\x6f\x4e\x35"
523                           "\x96\xd1\x84\x10\x0b\x38\x48\x68"
524                           "\x24\x9f\x1d\x8b\x8f\xda\xa2\xc9", 48,
525                           "KECCAK-384", 3) != 0) {
526         return CRYPT_FAIL_TESTVECTOR;
527     }
528     return CRYPT_OK;
529  #endif
530  }
531  int keccak_512_test(void)
532  {
533  #ifndef LTC_TEST
534     return CRYPT_NOP;
535  #else
536     hash_state c;
537     unsigned char hash[MAXBLOCKSIZE];
538     keccak_512_init(&c);
539     keccak_process(&c, (unsigned char*) "\xcc", 1);
540     keccak_done(&c, hash);
541     if(compare_testvector(hash, 64,
542                           "\x86\x30\xc1\x3c\xbd\x06\x6e\xa7"
543                           "\x4b\xbe\x7f\xe4\x68\xfe\xc1\xde"
544                           "\xe1\x0e\xdc\x12\x54\xfb\x4c\x1b"
545                           "\x7c\x5f\xd6\x9b\x64\x6e\x44\x16"
546                           "\x0b\x8c\xe0\x1d\x05\xa0\x90\x8c"
547                           "\xa7\x90\xdf\xb0\x80\xf4\xb5\x13"
548                           "\xbc\x3b\x62\x25\xec\xe7\xa8\x10"
549                           "\x37\x14\x41\xa5\xac\x66\x6e\xb9", 64,
550                           "KECCAK-512", 0) != 0) {
551         return CRYPT_FAIL_TESTVECTOR;
552     }
553     keccak_512_init(&c);
554     keccak_process(&c, (unsigned char*)"\x41\xfb", 2);
555     keccak_done(&c, hash);
556     if(compare_testvector(hash, 64,
557                           "\x55\x1d\xa6\x23\x6f\x8b\x96\xfc"
558                           "\xe9\xf9\x7f\x11\x90\xe9\x01\x32"
559                           "\x4f\x0b\x45\xe0\x6d\xbb\xb5\xcd"
560                           "\xb8\x35\x5d\x6e\xd1\xdc\x34\xb3"
561                           "\xf0\xea\xe7\xdc\xb6\x86\x22\xff"
562                           "\x23\x2f\xa3\xce\xce\x0d\x46\x16"
563                           "\xcd\xeb\x39\x31\xf9\x38\x03\x66"
564                           "\x2a\x28\xdf\x1c\xd5\x35\xb7\x31", 64,
565                           "KECCAK-512", 1) != 0) {
566         return CRYPT_FAIL_TESTVECTOR;
567     }
568     keccak_512_init(&c);
569     keccak_process(&c, (unsigned char*)
570                      "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
571                      "\x44\x57\xa5\x7e\xde\x78\x21\x76", 16);
572     keccak_done(&c, hash);
573     if(compare_testvector(hash, 64,
574                           "\x4b\x39\xd3\xda\x5b\xcd\xf4\xd9"
575                           "\xb7\x69\x01\x59\x95\x64\x43\x11"
576                           "\xc1\x4c\x43\x5b\xf7\x2b\x10\x09"
577                           "\xd6\xdd\x71\xb0\x1a\x63\xb9\x7c"
578                           "\xfb\x59\x64\x18\xe8\xe4\x23\x42"
579                           "\xd1\x17\xe0\x74\x71\xa8\x91\x43"
580                           "\x14\xba\x7b\x0e\x26\x4d\xad\xf0"
581                           "\xce\xa3\x81\x86\x8c\xbd\x43\xd1", 64,
582                           "KECCAK-512", 2) != 0) {
583         return CRYPT_FAIL_TESTVECTOR;
584     }
585     keccak_512_init(&c);
586     keccak_process(&c, (unsigned char*)
587                      "\x43\x3c\x53\x03\x13\x16\x24\xc0"
588                      "\x02\x1d\x86\x8a\x30\x82\x54\x75"
589                      "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
590                      "\x03\x98\xf4\xca\x44\x23\xb9\x82"
591                      "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
592                      "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
593                      "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
594                      "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
595                      "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
596                      "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
597                      "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
598                      "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84"
599                      "\x6d\xcb\xb4\xce", 100);
600     keccak_done(&c, hash);
601     if(compare_testvector(hash, 64,
602                           "\x52\x7d\x28\xe3\x41\xe6\xb1\x4f"
603                           "\x46\x84\xad\xb4\xb8\x24\xc4\x96"
604                           "\xc6\x48\x2e\x51\x14\x95\x65\xd3"
605                           "\xd1\x72\x26\x82\x88\x84\x30\x6b"
606                           "\x51\xd6\x14\x8a\x72\x62\x2c\x2b"
607                           "\x75\xf5\xd3\x51\x0b\x79\x9d\x8b"
608                           "\xdc\x03\xea\xed\xe4\x53\x67\x6a"
609                           "\x6e\xc8\xfe\x03\xa1\xad\x0e\xab", 64,
610                           "KECCAK-512", 3) != 0) {
611         return CRYPT_FAIL_TESTVECTOR;
612     }
613     return CRYPT_OK;
614  #endif
615  }
616  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sha3_test.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SHA3
3  int sha3_224_test(void)
4  {
5  #ifndef LTC_TEST
6     return CRYPT_NOP;
7  #else
8     unsigned char buf[200], hash[224 / 8];
9     int i;
10     hash_state c;
11     const unsigned char c1 = 0xa3;
12     const unsigned char sha3_224_empty[224 / 8] = {
13        0x6b, 0x4e, 0x03, 0x42, 0x36, 0x67, 0xdb, 0xb7,
14        0x3b, 0x6e, 0x15, 0x45, 0x4f, 0x0e, 0xb1, 0xab,
15        0xd4, 0x59, 0x7f, 0x9a, 0x1b, 0x07, 0x8e, 0x3f,
16        0x5b, 0x5a, 0x6b, 0xc7
17     };
18     const unsigned char sha3_224_0xa3_200_times[224 / 8] = {
19        0x93, 0x76, 0x81, 0x6a, 0xba, 0x50, 0x3f, 0x72,
20        0xf9, 0x6c, 0xe7, 0xeb, 0x65, 0xac, 0x09, 0x5d,
21        0xee, 0xe3, 0xbe, 0x4b, 0xf9, 0xbb, 0xc2, 0xa1,
22        0xcb, 0x7e, 0x11, 0xe0
23     };
24     XMEMSET(buf, c1, sizeof(buf));
25     sha3_224_init(&c);
26     sha3_done(&c, hash);
27     if (compare_testvector(hash, sizeof(hash), sha3_224_empty, sizeof(sha3_224_empty), "SHA3-224", 0)) {
28        return CRYPT_FAIL_TESTVECTOR;
29     }
30     sha3_224_init(&c);
31     sha3_process(&c, buf, sizeof(buf) / 2);
32     sha3_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
33     sha3_done(&c, hash);
34     if (compare_testvector(hash, sizeof(hash), sha3_224_0xa3_200_times, sizeof(sha3_224_0xa3_200_times), "SHA3-224", 1)) {
35        return CRYPT_FAIL_TESTVECTOR;
36     }
37     i = 200;
38     sha3_224_init(&c);
39     while (i--) {
40         sha3_process(&c, &c1, 1);
41     }
42     sha3_done(&c, hash);
43     if (compare_testvector(hash, sizeof(hash), sha3_224_0xa3_200_times, sizeof(sha3_224_0xa3_200_times), "SHA3-224", 2)) {
44        return CRYPT_FAIL_TESTVECTOR;
45     }
46     return CRYPT_OK;
47  #endif
48  }
49  int sha3_256_test(void)
50  {
51  #ifndef LTC_TEST
52     return CRYPT_NOP;
53  #else
54     unsigned char buf[200], hash[256 / 8];
55     int i;
56     hash_state c;
57     const unsigned char c1 = 0xa3;
58     const unsigned char sha3_256_empty[256 / 8] = {
59        0xa7, 0xff, 0xc6, 0xf8, 0xbf, 0x1e, 0xd7, 0x66,
60        0x51, 0xc1, 0x47, 0x56, 0xa0, 0x61, 0xd6, 0x62,
61        0xf5, 0x80, 0xff, 0x4d, 0xe4, 0x3b, 0x49, 0xfa,
62        0x82, 0xd8, 0x0a, 0x4b, 0x80, 0xf8, 0x43, 0x4a
63     };
64     const unsigned char sha3_256_0xa3_200_times[256 / 8] = {
65        0x79, 0xf3, 0x8a, 0xde, 0xc5, 0xc2, 0x03, 0x07,
66        0xa9, 0x8e, 0xf7, 0x6e, 0x83, 0x24, 0xaf, 0xbf,
67        0xd4, 0x6c, 0xfd, 0x81, 0xb2, 0x2e, 0x39, 0x73,
68        0xc6, 0x5f, 0xa1, 0xbd, 0x9d, 0xe3, 0x17, 0x87
69     };
70     XMEMSET(buf, c1, sizeof(buf));
71     sha3_256_init(&c);
72     sha3_done(&c, hash);
73     if (compare_testvector(hash, sizeof(hash), sha3_256_empty, sizeof(sha3_256_empty), "SHA3-256", 0)) {
74        return CRYPT_FAIL_TESTVECTOR;
75     }
76     sha3_256_init(&c);
77     sha3_process(&c, buf, sizeof(buf));
78     sha3_done(&c, hash);
79     if (compare_testvector(hash, sizeof(hash), sha3_256_0xa3_200_times, sizeof(sha3_256_0xa3_200_times), "SHA3-256", 1)) {
80        return CRYPT_FAIL_TESTVECTOR;
81     }
82     sha3_256_init(&c);
83     sha3_process(&c, buf, sizeof(buf) / 2);
84     sha3_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
85     sha3_done(&c, hash);
86     if (compare_testvector(hash, sizeof(hash), sha3_256_0xa3_200_times, sizeof(sha3_256_0xa3_200_times), "SHA3-256", 2)) {
87        return CRYPT_FAIL_TESTVECTOR;
88     }
89     i = 200;
90     sha3_256_init(&c);
91     while (i--) {
92         sha3_process(&c, &c1, 1);
93     }
94     sha3_done(&c, hash);
95     if (compare_testvector(hash, sizeof(hash), sha3_256_0xa3_200_times, sizeof(sha3_256_0xa3_200_times), "SHA3-256", 3)) {
96        return CRYPT_FAIL_TESTVECTOR;
97     }
98     sha3_256_init(&c);
99     sha3_process(&c, (unsigned char*)
100             "\xb7\x71\xd5\xce\xf5\xd1\xa4\x1a"
101             "\x93\xd1\x56\x43\xd7\x18\x1d\x2a"
102             "\x2e\xf0\xa8\xe8\x4d\x91\x81\x2f"
103             "\x20\xed\x21\xf1\x47\xbe\xf7\x32"
104             "\xbf\x3a\x60\xef\x40\x67\xc3\x73"
105             "\x4b\x85\xbc\x8c\xd4\x71\x78\x0f"
106             "\x10\xdc\x9e\x82\x91\xb5\x83\x39"
107             "\xa6\x77\xb9\x60\x21\x8f\x71\xe7"
108             "\x93\xf2\x79\x7a\xea\x34\x94\x06"
109             "\x51\x28\x29\x06\x5d\x37\xbb\x55"
110             "\xea\x79\x6f\xa4\xf5\x6f\xd8\x89"
111             "\x6b\x49\xb2\xcd\x19\xb4\x32\x15"
112             "\xad\x96\x7c\x71\x2b\x24\xe5\x03"
113             "\x2d\x06\x52\x32\xe0\x2c\x12\x74"
114             "\x09\xd2\xed\x41\x46\xb9\xd7\x5d"
115             "\x76\x3d\x52\xdb\x98\xd9\x49\xd3"
116             "\xb0\xfe\xd6\xa8\x05\x2f\xbb", 1080 / 8);
117     sha3_done(&c, hash);
118     if(compare_testvector(hash, sizeof(hash),
119             "\xa1\x9e\xee\x92\xbb\x20\x97\xb6"
120             "\x4e\x82\x3d\x59\x77\x98\xaa\x18"
121             "\xbe\x9b\x7c\x73\x6b\x80\x59\xab"
122             "\xfd\x67\x79\xac\x35\xac\x81\xb5", 256 / 8, "SHA3-256", 4)) {
123        return CRYPT_FAIL_TESTVECTOR;
124     }
125     return CRYPT_OK;
126  #endif
127  }
128  int sha3_384_test(void)
129  {
130  #ifndef LTC_TEST
131     return CRYPT_NOP;
132  #else
133     unsigned char buf[200], hash[384 / 8];
134     int i;
135     hash_state c;
136     const unsigned char c1 = 0xa3;
137     const unsigned char sha3_384_0xa3_200_times[384 / 8] = {
138        0x18, 0x81, 0xde, 0x2c, 0xa7, 0xe4, 0x1e, 0xf9,
139        0x5d, 0xc4, 0x73, 0x2b, 0x8f, 0x5f, 0x00, 0x2b,
140        0x18, 0x9c, 0xc1, 0xe4, 0x2b, 0x74, 0x16, 0x8e,
141        0xd1, 0x73, 0x26, 0x49, 0xce, 0x1d, 0xbc, 0xdd,
142        0x76, 0x19, 0x7a, 0x31, 0xfd, 0x55, 0xee, 0x98,
143        0x9f, 0x2d, 0x70, 0x50, 0xdd, 0x47, 0x3e, 0x8f
144     };
145     XMEMSET(buf, c1, sizeof(buf));
146     sha3_384_init(&c);
147     sha3_process(&c, buf, sizeof(buf));
148     sha3_done(&c, hash);
149     if (compare_testvector(hash, sizeof(hash), sha3_384_0xa3_200_times, sizeof(sha3_384_0xa3_200_times), "SHA3-384", 0)) {
150        return CRYPT_FAIL_TESTVECTOR;
151     }
152     sha3_384_init(&c);
153     sha3_process(&c, buf, sizeof(buf) / 2);
154     sha3_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
155     sha3_done(&c, hash);
156     if (compare_testvector(hash, sizeof(hash), sha3_384_0xa3_200_times, sizeof(sha3_384_0xa3_200_times), "SHA3-384", 1)) {
157        return CRYPT_FAIL_TESTVECTOR;
158     }
159     i = 200;
160     sha3_384_init(&c);
161     while (i--) {
162         sha3_process(&c, &c1, 1);
163     }
164     sha3_done(&c, hash);
165     if (compare_testvector(hash, sizeof(hash), sha3_384_0xa3_200_times, sizeof(sha3_384_0xa3_200_times), "SHA3-384", 2)) {
166        return CRYPT_FAIL_TESTVECTOR;
167     }
168     return CRYPT_OK;
169  #endif
170  }
171  int sha3_512_test(void)
172  {
173  #ifndef LTC_TEST
174     return CRYPT_NOP;
175  #else
176     unsigned char buf[200], hash[512 / 8];
177     int i;
178     hash_state c;
179     const unsigned char c1 = 0xa3;
180     const unsigned char sha3_512_0xa3_200_times[512 / 8] = {
181        0xe7, 0x6d, 0xfa, 0xd2, 0x20, 0x84, 0xa8, 0xb1,
182        0x46, 0x7f, 0xcf, 0x2f, 0xfa, 0x58, 0x36, 0x1b,
183        0xec, 0x76, 0x28, 0xed, 0xf5, 0xf3, 0xfd, 0xc0,
184        0xe4, 0x80, 0x5d, 0xc4, 0x8c, 0xae, 0xec, 0xa8,
185        0x1b, 0x7c, 0x13, 0xc3, 0x0a, 0xdf, 0x52, 0xa3,
186        0x65, 0x95, 0x84, 0x73, 0x9a, 0x2d, 0xf4, 0x6b,
187        0xe5, 0x89, 0xc5, 0x1c, 0xa1, 0xa4, 0xa8, 0x41,
188        0x6d, 0xf6, 0x54, 0x5a, 0x1c, 0xe8, 0xba, 0x00
189     };
190     XMEMSET(buf, c1, sizeof(buf));
191     sha3_512_init(&c);
192     sha3_process(&c, buf, sizeof(buf));
193     sha3_done(&c, hash);
194     if (compare_testvector(hash, sizeof(hash), sha3_512_0xa3_200_times, sizeof(sha3_512_0xa3_200_times), "SHA3-512", 0)) {
195        return CRYPT_FAIL_TESTVECTOR;
196     }
197     sha3_512_init(&c);
198     sha3_process(&c, buf, sizeof(buf) / 2);
199     sha3_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
200     sha3_done(&c, hash);
201     if (compare_testvector(hash, sizeof(hash), sha3_512_0xa3_200_times, sizeof(sha3_512_0xa3_200_times), "SHA3-512", 1)) {
202        return CRYPT_FAIL_TESTVECTOR;
203     }
204     i = 200;
205     sha3_512_init(&c);
206     while (i--) {
207         sha3_process(&c, &c1, 1);
208     }
209     sha3_done(&c, hash);
210     if (compare_testvector(hash, sizeof(hash), sha3_512_0xa3_200_times, sizeof(sha3_512_0xa3_200_times), "SHA3-512", 2)) {
211        return CRYPT_FAIL_TESTVECTOR;
212     }
213     return CRYPT_OK;
214  #endif
215  }
216  int sha3_shake_test(void)
217  {
218  #ifndef LTC_TEST
219     return CRYPT_NOP;
220  #else
221     unsigned char buf[200], hash[512];
222     int i;
223     hash_state c;
224     const unsigned char c1 = 0xa3;
225     unsigned long len;
226     const unsigned char shake256_empty[32] = {
227        0xab, 0x0b, 0xae, 0x31, 0x63, 0x39, 0x89, 0x43,
228        0x04, 0xe3, 0x58, 0x77, 0xb0, 0xc2, 0x8a, 0x9b,
229        0x1f, 0xd1, 0x66, 0xc7, 0x96, 0xb9, 0xcc, 0x25,
230        0x8a, 0x06, 0x4a, 0x8f, 0x57, 0xe2, 0x7f, 0x2a
231     };
232     const unsigned char shake256_0xa3_200_times[32] = {
233        0x6a, 0x1a, 0x9d, 0x78, 0x46, 0x43, 0x6e, 0x4d,
234        0xca, 0x57, 0x28, 0xb6, 0xf7, 0x60, 0xee, 0xf0,
235        0xca, 0x92, 0xbf, 0x0b, 0xe5, 0x61, 0x5e, 0x96,
236        0x95, 0x9d, 0x76, 0x71, 0x97, 0xa0, 0xbe, 0xeb
237     };
238     const unsigned char shake128_empty[32] = {
239        0x43, 0xe4, 0x1b, 0x45, 0xa6, 0x53, 0xf2, 0xa5,
240        0xc4, 0x49, 0x2c, 0x1a, 0xdd, 0x54, 0x45, 0x12,
241        0xdd, 0xa2, 0x52, 0x98, 0x33, 0x46, 0x2b, 0x71,
242        0xa4, 0x1a, 0x45, 0xbe, 0x97, 0x29, 0x0b, 0x6f
243     };
244     const unsigned char shake128_0xa3_200_times[32] = {
245        0x44, 0xc9, 0xfb, 0x35, 0x9f, 0xd5, 0x6a, 0xc0,
246        0xa9, 0xa7, 0x5a, 0x74, 0x3c, 0xff, 0x68, 0x62,
247        0xf1, 0x7d, 0x72, 0x59, 0xab, 0x07, 0x52, 0x16,
248        0xc0, 0x69, 0x95, 0x11, 0x64, 0x3b, 0x64, 0x39
249     };
250     XMEMSET(buf, c1, sizeof(buf));
251     sha3_shake_init(&c, 256);
252     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
253     if (compare_testvector(hash, sizeof(shake256_empty), shake256_empty, sizeof(shake256_empty), "SHAKE256", 0)) {
254        return CRYPT_FAIL_TESTVECTOR;
255     }
256     len = 512;
257     sha3_shake_memory(256, buf, sizeof(buf), hash, &len);
258     if (compare_testvector(hash + 480, sizeof(shake256_0xa3_200_times), shake256_0xa3_200_times, sizeof(shake256_0xa3_200_times), "SHAKE256", 1)) {
259        return CRYPT_FAIL_TESTVECTOR;
260     }
261     sha3_shake_init(&c, 256);
262     sha3_shake_process(&c, buf, sizeof(buf));
263     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
264     if (compare_testvector(hash, sizeof(shake256_0xa3_200_times), shake256_0xa3_200_times, sizeof(shake256_0xa3_200_times), "SHAKE256", 2)) {
265        return CRYPT_FAIL_TESTVECTOR;
266     }
267     sha3_shake_init(&c, 256);
268     sha3_shake_process(&c, buf, sizeof(buf) / 2);
269     sha3_shake_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
270     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
271     if (compare_testvector(hash, sizeof(shake256_0xa3_200_times), shake256_0xa3_200_times, sizeof(shake256_0xa3_200_times), "SHAKE256", 3)) {
272        return CRYPT_FAIL_TESTVECTOR;
273     }
274     i = 200;
275     sha3_shake_init(&c, 256);
276     while (i--) sha3_shake_process(&c, &c1, 1);
277     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
278     if (compare_testvector(hash, sizeof(shake256_0xa3_200_times), shake256_0xa3_200_times, sizeof(shake256_0xa3_200_times), "SHAKE256", 4)) {
279        return CRYPT_FAIL_TESTVECTOR;
280     }
281     sha3_shake_init(&c, 128);
282     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
283     if (compare_testvector(hash, sizeof(shake128_empty), shake128_empty, sizeof(shake128_empty), "SHAKE128", 0)) {
284        return CRYPT_FAIL_TESTVECTOR;
285     }
286     len = 512;
287     sha3_shake_memory(128, buf, sizeof(buf), hash, &len);
288     if (compare_testvector(hash + 480, sizeof(shake128_0xa3_200_times), shake128_0xa3_200_times, sizeof(shake128_0xa3_200_times), "SHAKE128", 1)) {
289        return CRYPT_FAIL_TESTVECTOR;
290     }
291     sha3_shake_init(&c, 128);
292     sha3_shake_process(&c, buf, sizeof(buf));
293     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
294     if (compare_testvector(hash, sizeof(shake128_0xa3_200_times), shake128_0xa3_200_times, sizeof(shake128_0xa3_200_times), "SHAKE128", 2)) {
295        return CRYPT_FAIL_TESTVECTOR;
296     }
297     sha3_shake_init(&c, 128);
298     sha3_shake_process(&c, buf, sizeof(buf) / 2);
299     sha3_shake_process(&c, buf + sizeof(buf) / 2, sizeof(buf) / 2);
300     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
301     if (compare_testvector(hash, sizeof(shake128_0xa3_200_times), shake128_0xa3_200_times, sizeof(shake128_0xa3_200_times), "SHAKE128", 3)) {
302        return CRYPT_FAIL_TESTVECTOR;
303     }
304     i = 200;
305     sha3_shake_init(&c, 128);
306     while (i--) sha3_shake_process(&c, &c1, 1);
307     for (i = 0; i < 16; i++) sha3_shake_done(&c, hash, 32); &bsol;* get 512 bytes, keep in hash the last 32 */
308     if (compare_testvector(hash, sizeof(shake128_0xa3_200_times), shake128_0xa3_200_times, sizeof(shake128_0xa3_200_times), "SHAKE128", 4)) {
309        return CRYPT_FAIL_TESTVECTOR;
310     }
311     return CRYPT_OK;
312  #endif
313  }
314  #endif
315  #ifdef LTC_KECCAK
316  int keccak_224_test(void)
317  {
318  #ifndef LTC_TEST
319     return CRYPT_NOP;
320  #else
321     hash_state c;
322     unsigned char hash[MAXBLOCKSIZE];
323     keccak_224_init(&c);
324     keccak_process(&c, (unsigned char*) "\xcc", 1);
325     keccak_done(&c, hash);
326     if(compare_testvector(hash, 28,
327                           "\xa9\xca\xb5\x9e\xb4\x0a\x10\xb2"
328                           "\x46\x29\x0f\x2d\x60\x86\xe3\x2e"
329                           "\x36\x89\xfa\xf1\xd2\x6b\x47\x0c"
<span onclick='openModal()' class='match'>330                           "\x89\x9f\x28\x02", 28,
331                           "KECCAK-224", 0) != 0) {
332         return CRYPT_FAIL_TESTVECTOR;
333     }
334     keccak_224_init(&c);
</span>335     keccak_process(&c, (unsigned char*)"\x41\xfb", 2);
336     keccak_done(&c, hash);
337     if(compare_testvector(hash, 28,
338                           "\x61\x5b\xa3\x67\xaf\xdc\x35\xaa"
339                           "\xc3\x97\xbc\x7e\xb5\xd5\x8d\x10"
340                           "\x6a\x73\x4b\x24\x98\x6d\x5d\x97"
341                           "\x8f\xef\xd6\x2c", 28,
342                           "KECCAK-224", 1) != 0) {
343         return CRYPT_FAIL_TESTVECTOR;
344     }
345     keccak_224_init(&c);
346     keccak_process(&c, (unsigned char*)
347                      "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
348                      "\x44\x57\xa5\x7e\xde\x78\x21\x76", 16);
349     keccak_done(&c, hash);
350     if(compare_testvector(hash, 28,
351                           "\x56\x79\xcd\x50\x9c\x51\x20\xaf"
352                           "\x54\x79\x5c\xf4\x77\x14\x96\x41"
353                           "\xcf\x27\xb2\xeb\xb6\xa5\xf9\x03"
354                           "\x40\x70\x4e\x57", 28,
355                           "KECCAK-224", 2) != 0) {
356         return CRYPT_FAIL_TESTVECTOR;
357     }
358     keccak_224_init(&c);
359     keccak_process(&c, (unsigned char*)
360                      "\x43\x3c\x53\x03\x13\x16\x24\xc0"
361                      "\x02\x1d\x86\x8a\x30\x82\x54\x75"
362                      "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
363                      "\x03\x98\xf4\xca\x44\x23\xb9\x82"
364                      "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
365                      "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
366                      "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
367                      "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
368                      "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
369                      "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
370                      "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
371                      "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84"
372                      "\x6d\xcb\xb4\xce", 100);
373     keccak_done(&c, hash);
374     if(compare_testvector(hash, 28,
375                           "\x62\xb1\x0f\x1b\x62\x36\xeb\xc2"
376                           "\xda\x72\x95\x77\x42\xa8\xd4\xe4"
377                           "\x8e\x21\x3b\x5f\x89\x34\x60\x4b"
378                           "\xfd\x4d\x2c\x3a", 28,
379                           "KECCAK-224", 3) != 0) {
380         return CRYPT_FAIL_TESTVECTOR;
381     }
382     return CRYPT_OK;
383  #endif
384  }
385  int keccak_256_test(void)
386  {
387  #ifndef LTC_TEST
388     return CRYPT_NOP;
389  #else
390     hash_state c;
391     unsigned char hash[MAXBLOCKSIZE];
392     keccak_256_init(&c);
393     keccak_process(&c, (unsigned char*) "\xcc", 1);
394     keccak_done(&c, hash);
395     if(compare_testvector(hash, 32,
396                           "\xee\xad\x6d\xbf\xc7\x34\x0a\x56"
397                           "\xca\xed\xc0\x44\x69\x6a\x16\x88"
398                           "\x70\x54\x9a\x6a\x7f\x6f\x56\x96"
399                           "\x1e\x84\xa5\x4b\xd9\x97\x0b\x8a", 32,
400                           "KECCAK-256", 0) != 0) {
401         return CRYPT_FAIL_TESTVECTOR;
402     }
403     keccak_256_init(&c);
404     keccak_process(&c, (unsigned char*)"\x41\xfb", 2);
405     keccak_done(&c, hash);
406     if(compare_testvector(hash, 32,
407                           "\xa8\xea\xce\xda\x4d\x47\xb3\x28"
408                           "\x1a\x79\x5a\xd9\xe1\xea\x21\x22"
409                           "\xb4\x07\xba\xf9\xaa\xbc\xb9\xe1"
410                           "\x8b\x57\x17\xb7\x87\x35\x37\xd2", 32,
411                           "KECCAK-256", 1) != 0) {
412         return CRYPT_FAIL_TESTVECTOR;
413     }
414     keccak_256_init(&c);
415     keccak_process(&c, (unsigned char*)
416                      "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
417                      "\x44\x57\xa5\x7e\xde\x78\x21\x76", 16);
418     keccak_done(&c, hash);
419     if(compare_testvector(hash, 32,
420                           "\x0e\x32\xde\xfa\x20\x71\xf0\xb5"
421                           "\xac\x0e\x6a\x10\x8b\x84\x2e\xd0"
422                           "\xf1\xd3\x24\x97\x12\xf5\x8e\xe0"
423                           "\xdd\xf9\x56\xfe\x33\x2a\x5f\x95", 32,
424                           "KECCAK-256", 2) != 0) {
425         return CRYPT_FAIL_TESTVECTOR;
426     }
427     keccak_256_init(&c);
428     keccak_process(&c, (unsigned char*)
429                      "\x43\x3c\x53\x03\x13\x16\x24\xc0"
430                      "\x02\x1d\x86\x8a\x30\x82\x54\x75"
431                      "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
432                      "\x03\x98\xf4\xca\x44\x23\xb9\x82"
433                      "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
434                      "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
435                      "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
436                      "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
437                      "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
438                      "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
439                      "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
440                      "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84"
441                      "\x6d\xcb\xb4\xce", 100);
442     keccak_done(&c, hash);
443     if(compare_testvector(hash, 32,
444                           "\xce\x87\xa5\x17\x3b\xff\xd9\x23"
445                           "\x99\x22\x16\x58\xf8\x01\xd4\x5c"
446                           "\x29\x4d\x90\x06\xee\x9f\x3f\x9d"
447                           "\x41\x9c\x8d\x42\x77\x48\xdc\x41", 32,
448                           "KECCAK-256", 3) != 0) {
449         return CRYPT_FAIL_TESTVECTOR;
450     }
451     return CRYPT_OK;
452  #endif
453  }
454  int keccak_384_test(void)
455  {
456  #ifndef LTC_TEST
457     return CRYPT_NOP;
458  #else
459     hash_state c;
460     unsigned char hash[MAXBLOCKSIZE];
461     keccak_384_init(&c);
462     keccak_process(&c, (unsigned char*) "\xcc", 1);
463     keccak_done(&c, hash);
464     if(compare_testvector(hash, 48,
465                           "\x1b\x84\xe6\x2a\x46\xe5\xa2\x01"
466                           "\x86\x17\x54\xaf\x5d\xc9\x5c\x4a"
467                           "\x1a\x69\xca\xf4\xa7\x96\xae\x40"
468                           "\x56\x80\x16\x1e\x29\x57\x26\x41"
469                           "\xf5\xfa\x1e\x86\x41\xd7\x95\x83"
470                           "\x36\xee\x7b\x11\xc5\x8f\x73\xe9", 48,
471                           "KECCAK-384", 0) != 0) {
472         return CRYPT_FAIL_TESTVECTOR;
473     }
474     keccak_384_init(&c);
475     keccak_process(&c, (unsigned char*)"\x41\xfb", 2);
476     keccak_done(&c, hash);
477     if(compare_testvector(hash, 48,
478                           "\x49\x5c\xce\x27\x14\xcd\x72\xc8"
479                           "\xc5\x3c\x33\x63\xd2\x2c\x58\xb5"
480                           "\x59\x60\xfe\x26\xbe\x0b\xf3\xbb"
481                           "\xc7\xa3\x31\x6d\xd5\x63\xad\x1d"
482                           "\xb8\x41\x0e\x75\xee\xfe\xa6\x55"
483                           "\xe3\x9d\x46\x70\xec\x0b\x17\x92", 48,
484                           "KECCAK-384", 1) != 0) {
485         return CRYPT_FAIL_TESTVECTOR;
486     }
487     keccak_384_init(&c);
488     keccak_process(&c, (unsigned char*)
489                      "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
490                      "\x44\x57\xa5\x7e\xde\x78\x21\x76", 16);
491     keccak_done(&c, hash);
492     if(compare_testvector(hash, 48,
493                           "\x18\x42\x2a\xc1\xd3\xa1\xe5\x4b"
494                           "\xad\x87\x68\x83\xd2\xd6\xdd\x65"
495                           "\xf6\x5c\x1d\x5f\x33\xa7\x12\x5c"
496                           "\xc4\xc1\x86\x40\x5a\x12\xed\x64"
497                           "\xba\x96\x67\x2e\xed\xda\x8c\x5a"
498                           "\x63\x31\xd2\x86\x83\xf4\x88\xeb", 48,
499                           "KECCAK-384", 2) != 0) {
500         return CRYPT_FAIL_TESTVECTOR;
501     }
502     keccak_384_init(&c);
503     keccak_process(&c, (unsigned char*)
504                      "\x43\x3c\x53\x03\x13\x16\x24\xc0"
505                      "\x02\x1d\x86\x8a\x30\x82\x54\x75"
506                      "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
507                      "\x03\x98\xf4\xca\x44\x23\xb9\x82"
508                      "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
509                      "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
510                      "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
511                      "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
512                      "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
513                      "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
514                      "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
515                      "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84"
516                      "\x6d\xcb\xb4\xce", 100);
517     keccak_done(&c, hash);
518     if(compare_testvector(hash, 48,
519                           "\x13\x51\x14\x50\x8d\xd6\x3e\x27"
520                           "\x9e\x70\x9c\x26\xf7\x81\x7c\x04"
521                           "\x82\x76\x6c\xde\x49\x13\x2e\x3e"
522                           "\xdf\x2e\xed\xd8\x99\x6f\x4e\x35"
523                           "\x96\xd1\x84\x10\x0b\x38\x48\x68"
524                           "\x24\x9f\x1d\x8b\x8f\xda\xa2\xc9", 48,
525                           "KECCAK-384", 3) != 0) {
526         return CRYPT_FAIL_TESTVECTOR;
527     }
528     return CRYPT_OK;
529  #endif
530  }
531  int keccak_512_test(void)
532  {
533  #ifndef LTC_TEST
534     return CRYPT_NOP;
535  #else
536     hash_state c;
537     unsigned char hash[MAXBLOCKSIZE];
538     keccak_512_init(&c);
539     keccak_process(&c, (unsigned char*) "\xcc", 1);
540     keccak_done(&c, hash);
541     if(compare_testvector(hash, 64,
542                           "\x86\x30\xc1\x3c\xbd\x06\x6e\xa7"
543                           "\x4b\xbe\x7f\xe4\x68\xfe\xc1\xde"
544                           "\xe1\x0e\xdc\x12\x54\xfb\x4c\x1b"
545                           "\x7c\x5f\xd6\x9b\x64\x6e\x44\x16"
546                           "\x0b\x8c\xe0\x1d\x05\xa0\x90\x8c"
547                           "\xa7\x90\xdf\xb0\x80\xf4\xb5\x13"
548                           "\xbc\x3b\x62\x25\xec\xe7\xa8\x10"
549                           "\x37\x14\x41\xa5\xac\x66\x6e\xb9", 64,
550                           "KECCAK-512", 0) != 0) {
551         return CRYPT_FAIL_TESTVECTOR;
552     }
553     keccak_512_init(&c);
554     keccak_process(&c, (unsigned char*)"\x41\xfb", 2);
555     keccak_done(&c, hash);
556     if(compare_testvector(hash, 64,
557                           "\x55\x1d\xa6\x23\x6f\x8b\x96\xfc"
558                           "\xe9\xf9\x7f\x11\x90\xe9\x01\x32"
559                           "\x4f\x0b\x45\xe0\x6d\xbb\xb5\xcd"
560                           "\xb8\x35\x5d\x6e\xd1\xdc\x34\xb3"
561                           "\xf0\xea\xe7\xdc\xb6\x86\x22\xff"
562                           "\x23\x2f\xa3\xce\xce\x0d\x46\x16"
563                           "\xcd\xeb\x39\x31\xf9\x38\x03\x66"
564                           "\x2a\x28\xdf\x1c\xd5\x35\xb7\x31", 64,
565                           "KECCAK-512", 1) != 0) {
566         return CRYPT_FAIL_TESTVECTOR;
567     }
568     keccak_512_init(&c);
569     keccak_process(&c, (unsigned char*)
570                      "\x52\xa6\x08\xab\x21\xcc\xdd\x8a"
571                      "\x44\x57\xa5\x7e\xde\x78\x21\x76", 16);
572     keccak_done(&c, hash);
573     if(compare_testvector(hash, 64,
574                           "\x4b\x39\xd3\xda\x5b\xcd\xf4\xd9"
575                           "\xb7\x69\x01\x59\x95\x64\x43\x11"
576                           "\xc1\x4c\x43\x5b\xf7\x2b\x10\x09"
577                           "\xd6\xdd\x71\xb0\x1a\x63\xb9\x7c"
578                           "\xfb\x59\x64\x18\xe8\xe4\x23\x42"
579                           "\xd1\x17\xe0\x74\x71\xa8\x91\x43"
580                           "\x14\xba\x7b\x0e\x26\x4d\xad\xf0"
581                           "\xce\xa3\x81\x86\x8c\xbd\x43\xd1", 64,
582                           "KECCAK-512", 2) != 0) {
583         return CRYPT_FAIL_TESTVECTOR;
584     }
585     keccak_512_init(&c);
586     keccak_process(&c, (unsigned char*)
587                      "\x43\x3c\x53\x03\x13\x16\x24\xc0"
588                      "\x02\x1d\x86\x8a\x30\x82\x54\x75"
589                      "\xe8\xd0\xbd\x30\x52\xa0\x22\x18"
590                      "\x03\x98\xf4\xca\x44\x23\xb9\x82"
591                      "\x14\xb6\xbe\xaa\xc2\x1c\x88\x07"
592                      "\xa2\xc3\x3f\x8c\x93\xbd\x42\xb0"
593                      "\x92\xcc\x1b\x06\xce\xdf\x32\x24"
594                      "\xd5\xed\x1e\xc2\x97\x84\x44\x4f"
595                      "\x22\xe0\x8a\x55\xaa\x58\x54\x2b"
596                      "\x52\x4b\x02\xcd\x3d\x5d\x5f\x69"
597                      "\x07\xaf\xe7\x1c\x5d\x74\x62\x22"
598                      "\x4a\x3f\x9d\x9e\x53\xe7\xe0\x84"
599                      "\x6d\xcb\xb4\xce", 100);
600     keccak_done(&c, hash);
601     if(compare_testvector(hash, 64,
602                           "\x52\x7d\x28\xe3\x41\xe6\xb1\x4f"
603                           "\x46\x84\xad\xb4\xb8\x24\xc4\x96"
604                           "\xc6\x48\x2e\x51\x14\x95\x65\xd3"
605                           "\xd1\x72\x26\x82\x88\x84\x30\x6b"
606                           "\x51\xd6\x14\x8a\x72\x62\x2c\x2b"
607                           "\x75\xf5\xd3\x51\x0b\x79\x9d\x8b"
608                           "\xdc\x03\xea\xed\xe4\x53\x67\x6a"
609                           "\x6e\xc8\xfe\x03\xa1\xad\x0e\xab", 64,
610                           "KECCAK-512", 3) != 0) {
611         return CRYPT_FAIL_TESTVECTOR;
612     }
613     return CRYPT_OK;
614  #endif
615  }
616  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sha3_test.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-sha3_test.c</div>
                </div>
                <div class="column column_space"><pre><code>447                           "\x41\x9c\x8d\x42\x77\x48\xdc\x41", 32,
448                           "KECCAK-256", 3) != 0) {
449         return CRYPT_FAIL_TESTVECTOR;
450     }
451     return CRYPT_OK;
</pre></code></div>
                <div class="column column_space"><pre><code>330                           "\x89\x9f\x28\x02", 28,
331                           "KECCAK-224", 0) != 0) {
332         return CRYPT_FAIL_TESTVECTOR;
333     }
334     keccak_224_init(&c);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    