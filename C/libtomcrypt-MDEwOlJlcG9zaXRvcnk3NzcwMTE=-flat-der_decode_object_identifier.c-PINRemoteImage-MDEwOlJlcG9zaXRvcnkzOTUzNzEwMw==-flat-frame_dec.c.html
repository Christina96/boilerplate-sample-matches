
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.4000000000000004%, Tokens: 8</h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_object_identifier.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_DER
3  int der_decode_object_identifier(const unsigned char *in,    unsigned long  inlen,
4                                         unsigned long *words, unsigned long *outlen)
5  {
6     unsigned long x, y, t, len;
7     int err;
8     LTC_ARGCHK(in     != NULL);
9     LTC_ARGCHK(words  != NULL);
10     LTC_ARGCHK(outlen != NULL);
11     if (inlen < 3) {
12        return CRYPT_INVALID_PACKET;
13     }
14     if (*outlen < 2) {
15        *outlen = 2;
16        return CRYPT_BUFFER_OVERFLOW;
17     }
18     x = 0;
19     if ((in[x++] & 0x1F) != 0x06) {
20        return CRYPT_INVALID_PACKET;
21     }
22     y = inlen - x;
23     if ((err = der_decode_asn1_length(in + x, &y, &len)) != CRYPT_OK) {
24        return err;
25     }
26     x += y;
27     if ((len == 0) || (len > (inlen - x))) {
28        return CRYPT_INVALID_PACKET;
29     }
30     y = 0;
31     t = 0;
32     while (len--) {
33        t = (t << 7) | (in[x] & 0x7F);
34        if (!(in[x++] & 0x80)) {
35           if (y >= *outlen) {
36              y++;
37           } else {
38              if (y == 0) {
39                 if (t <= 79) {
40                    words[0] = t / 40;
41                    words[1] = t % 40;
42                 } else {
43                    words[0] = 2;
44                    words[1] = t - 80;
45                 }
46                 y = 2;
47              } else {
48                 words[y++] = t;
49              }
50           }
51           t = 0;
52        }
53     }
<span onclick='openModal()' class='match'>54     if (y > *outlen) {
55        err =  CRYPT_BUFFER_OVERFLOW;
56     } else {
57        err =  CRYPT_OK;
58     }
</span>59     *outlen = y;
60     return err;
61  }
62  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-frame_dec.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include "src/dec/vp8i_dec.h"
3  #include "src/utils/utils.h"
4  static const uint16_t kScan[16] = {
5    0 +  0 * BPS,  4 +  0 * BPS, 8 +  0 * BPS, 12 +  0 * BPS,
6    0 +  4 * BPS,  4 +  4 * BPS, 8 +  4 * BPS, 12 +  4 * BPS,
7    0 +  8 * BPS,  4 +  8 * BPS, 8 +  8 * BPS, 12 +  8 * BPS,
8    0 + 12 * BPS,  4 + 12 * BPS, 8 + 12 * BPS, 12 + 12 * BPS
9  };
10  static int CheckMode(int mb_x, int mb_y, int mode) {
11    if (mode == B_DC_PRED) {
12      if (mb_x == 0) {
13        return (mb_y == 0) ? B_DC_PRED_NOTOPLEFT : B_DC_PRED_NOLEFT;
14      } else {
15        return (mb_y == 0) ? B_DC_PRED_NOTOP : B_DC_PRED;
16      }
17    }
18    return mode;
19  }
20  static void Copy32b(uint8_t* const dst, const uint8_t* const src) {
21    memcpy(dst, src, 4);
22  }
23  static WEBP_INLINE void DoTransform(uint32_t bits, const int16_t* const src,
24                                      uint8_t* const dst) {
25    switch (bits >> 30) {
26      case 3:
27        VP8Transform(src, dst, 0);
28        break;
29      case 2:
30        VP8TransformAC3(src, dst);
31        break;
32      case 1:
33        VP8TransformDC(src, dst);
34        break;
35      default:
36        break;
37    }
38  }
39  static void DoUVTransform(uint32_t bits, const int16_t* const src,
40                            uint8_t* const dst) {
41    if (bits & 0xff) {    
42      if (bits & 0xaa) {  
43        VP8TransformUV(src, dst);   
44      } else {
45        VP8TransformDCUV(src, dst);
46      }
47    }
48  }
49  static void ReconstructRow(const VP8Decoder* const dec,
50                             const VP8ThreadContext* ctx) {
51    int j;
52    int mb_x;
53    const int mb_y = ctx->mb_y_;
54    const int cache_id = ctx->id_;
55    uint8_t* const y_dst = dec->yuv_b_ + Y_OFF;
56    uint8_t* const u_dst = dec->yuv_b_ + U_OFF;
57    uint8_t* const v_dst = dec->yuv_b_ + V_OFF;
58    for (j = 0; j < 16; ++j) {
59      y_dst[j * BPS - 1] = 129;
60    }
61    for (j = 0; j < 8; ++j) {
62      u_dst[j * BPS - 1] = 129;
63      v_dst[j * BPS - 1] = 129;
64    }
65    if (mb_y > 0) {
66      y_dst[-1 - BPS] = u_dst[-1 - BPS] = v_dst[-1 - BPS] = 129;
67    } else {
68      memset(y_dst - BPS - 1, 127, 16 + 4 + 1);
69      memset(u_dst - BPS - 1, 127, 8 + 1);
70      memset(v_dst - BPS - 1, 127, 8 + 1);
71    }
72    for (mb_x = 0; mb_x < dec->mb_w_; ++mb_x) {
73      const VP8MBData* const block = ctx->mb_data_ + mb_x;
74      if (mb_x > 0) {
75        for (j = -1; j < 16; ++j) {
76          Copy32b(&y_dst[j * BPS - 4], &y_dst[j * BPS + 12]);
77        }
78        for (j = -1; j < 8; ++j) {
79          Copy32b(&u_dst[j * BPS - 4], &u_dst[j * BPS + 4]);
80          Copy32b(&v_dst[j * BPS - 4], &v_dst[j * BPS + 4]);
81        }
82      }
83      {
84        VP8TopSamples* const top_yuv = dec->yuv_t_ + mb_x;
85        const int16_t* const coeffs = block->coeffs_;
86        uint32_t bits = block->non_zero_y_;
87        int n;
88        if (mb_y > 0) {
89          memcpy(y_dst - BPS, top_yuv[0].y, 16);
90          memcpy(u_dst - BPS, top_yuv[0].u, 8);
91          memcpy(v_dst - BPS, top_yuv[0].v, 8);
92        }
93        if (block->is_i4x4_) {   
94          uint32_t* const top_right = (uint32_t*)(y_dst - BPS + 16);
95          if (mb_y > 0) {
96            if (mb_x >= dec->mb_w_ - 1) {    
97              memset(top_right, top_yuv[0].y[15], sizeof(*top_right));
98            } else {
99              memcpy(top_right, top_yuv[1].y, sizeof(*top_right));
100            }
101          }
102          top_right[BPS] = top_right[2 * BPS] = top_right[3 * BPS] = top_right[0];
103          for (n = 0; n < 16; ++n, bits <<= 2) {
104            uint8_t* const dst = y_dst + kScan[n];
105            VP8PredLuma4[block->imodes_[n]](dst);
106            DoTransform(bits, coeffs + n * 16, dst);
107          }
108        } else {    
109          const int pred_func = CheckMode(mb_x, mb_y, block->imodes_[0]);
110          VP8PredLuma16[pred_func](y_dst);
111          if (bits != 0) {
112            for (n = 0; n < 16; ++n, bits <<= 2) {
113              DoTransform(bits, coeffs + n * 16, y_dst + kScan[n]);
114            }
115          }
116        }
117        {
118          const uint32_t bits_uv = block->non_zero_uv_;
119          const int pred_func = CheckMode(mb_x, mb_y, block->uvmode_);
120          VP8PredChroma8[pred_func](u_dst);
121          VP8PredChroma8[pred_func](v_dst);
122          DoUVTransform(bits_uv >> 0, coeffs + 16 * 16, u_dst);
123          DoUVTransform(bits_uv >> 8, coeffs + 20 * 16, v_dst);
124        }
125        if (mb_y < dec->mb_h_ - 1) {
126          memcpy(top_yuv[0].y, y_dst + 15 * BPS, 16);
127          memcpy(top_yuv[0].u, u_dst +  7 * BPS,  8);
128          memcpy(top_yuv[0].v, v_dst +  7 * BPS,  8);
129        }
130      }
131      {
132        const int y_offset = cache_id * 16 * dec->cache_y_stride_;
133        const int uv_offset = cache_id * 8 * dec->cache_uv_stride_;
134        uint8_t* const y_out = dec->cache_y_ + mb_x * 16 + y_offset;
135        uint8_t* const u_out = dec->cache_u_ + mb_x * 8 + uv_offset;
136        uint8_t* const v_out = dec->cache_v_ + mb_x * 8 + uv_offset;
137        for (j = 0; j < 16; ++j) {
138          memcpy(y_out + j * dec->cache_y_stride_, y_dst + j * BPS, 16);
139        }
140        for (j = 0; j < 8; ++j) {
141          memcpy(u_out + j * dec->cache_uv_stride_, u_dst + j * BPS, 8);
142          memcpy(v_out + j * dec->cache_uv_stride_, v_dst + j * BPS, 8);
143        }
144      }
145    }
146  }
147  static const uint8_t kFilterExtraRows[3] = { 0, 2, 8 };
148  static void DoFilter(const VP8Decoder* const dec, int mb_x, int mb_y) {
149    const VP8ThreadContext* const ctx = &dec->thread_ctx_;
150    const int cache_id = ctx->id_;
151    const int y_bps = dec->cache_y_stride_;
152    const VP8FInfo* const f_info = ctx->f_info_ + mb_x;
153    uint8_t* const y_dst = dec->cache_y_ + cache_id * 16 * y_bps + mb_x * 16;
154    const int ilevel = f_info->f_ilevel_;
155    const int limit = f_info->f_limit_;
156    if (limit == 0) {
157      return;
158    }
159    assert(limit >= 3);
160    if (dec->filter_type_ == 1) {   
161      if (mb_x > 0) {
162        VP8SimpleHFilter16(y_dst, y_bps, limit + 4);
163      }
164      if (f_info->f_inner_) {
165        VP8SimpleHFilter16i(y_dst, y_bps, limit);
166      }
167      if (mb_y > 0) {
168        VP8SimpleVFilter16(y_dst, y_bps, limit + 4);
169      }
170      if (f_info->f_inner_) {
171        VP8SimpleVFilter16i(y_dst, y_bps, limit);
172      }
173    } else {    
174      const int uv_bps = dec->cache_uv_stride_;
175      uint8_t* const u_dst = dec->cache_u_ + cache_id * 8 * uv_bps + mb_x * 8;
176      uint8_t* const v_dst = dec->cache_v_ + cache_id * 8 * uv_bps + mb_x * 8;
177      const int hev_thresh = f_info->hev_thresh_;
178      if (mb_x > 0) {
179        VP8HFilter16(y_dst, y_bps, limit + 4, ilevel, hev_thresh);
180        VP8HFilter8(u_dst, v_dst, uv_bps, limit + 4, ilevel, hev_thresh);
181      }
182      if (f_info->f_inner_) {
183        VP8HFilter16i(y_dst, y_bps, limit, ilevel, hev_thresh);
184        VP8HFilter8i(u_dst, v_dst, uv_bps, limit, ilevel, hev_thresh);
185      }
186      if (mb_y > 0) {
187        VP8VFilter16(y_dst, y_bps, limit + 4, ilevel, hev_thresh);
188        VP8VFilter8(u_dst, v_dst, uv_bps, limit + 4, ilevel, hev_thresh);
189      }
190      if (f_info->f_inner_) {
191        VP8VFilter16i(y_dst, y_bps, limit, ilevel, hev_thresh);
192        VP8VFilter8i(u_dst, v_dst, uv_bps, limit, ilevel, hev_thresh);
193      }
194    }
195  }
196  static void FilterRow(const VP8Decoder* const dec) {
197    int mb_x;
198    const int mb_y = dec->thread_ctx_.mb_y_;
199    assert(dec->thread_ctx_.filter_row_);
200    for (mb_x = dec->tl_mb_x_; mb_x < dec->br_mb_x_; ++mb_x) {
201      DoFilter(dec, mb_x, mb_y);
202    }
203  }
204  static void PrecomputeFilterStrengths(VP8Decoder* const dec) {
205    if (dec->filter_type_ > 0) {
206      int s;
207      const VP8FilterHeader* const hdr = &dec->filter_hdr_;
208      for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
209        int i4x4;
210        int base_level;
211        if (dec->segment_hdr_.use_segment_) {
212          base_level = dec->segment_hdr_.filter_strength_[s];
213          if (!dec->segment_hdr_.absolute_delta_) {
214            base_level += hdr->level_;
215          }
216        } else {
217          base_level = hdr->level_;
218        }
219        for (i4x4 = 0; i4x4 <= 1; ++i4x4) {
220          VP8FInfo* const info = &dec->fstrengths_[s][i4x4];
221          int level = base_level;
222          if (hdr->use_lf_delta_) {
223            level += hdr->ref_lf_delta_[0];
224            if (i4x4) {
225              level += hdr->mode_lf_delta_[0];
226            }
227          }
228          level = (level < 0) ? 0 : (level > 63) ? 63 : level;
229          if (level > 0) {
230            int ilevel = level;
231            if (hdr->sharpness_ > 0) {
<span onclick='openModal()' class='match'>232              if (hdr->sharpness_ > 4) {
233                ilevel >>= 2;
234              } else {
235                ilevel >>= 1;
236              }
</span>237              if (ilevel > 9 - hdr->sharpness_) {
238                ilevel = 9 - hdr->sharpness_;
239              }
240            }
241            if (ilevel < 1) ilevel = 1;
242            info->f_ilevel_ = ilevel;
243            info->f_limit_ = 2 * level + ilevel;
244            info->hev_thresh_ = (level >= 40) ? 2 : (level >= 15) ? 1 : 0;
245          } else {
246            info->f_limit_ = 0;  
247          }
248          info->f_inner_ = i4x4;
249        }
250      }
251    }
252  }
253  #define MIN_DITHER_AMP 4
254  #define DITHER_AMP_TAB_SIZE 12
255  static const uint8_t kQuantToDitherAmp[DITHER_AMP_TAB_SIZE] = {
256    8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1
257  };
258  void VP8InitDithering(const WebPDecoderOptions* const options,
259                        VP8Decoder* const dec) {
260    assert(dec != NULL);
261    if (options != NULL) {
262      const int d = options->dithering_strength;
263      const int max_amp = (1 << VP8_RANDOM_DITHER_FIX) - 1;
264      const int f = (d < 0) ? 0 : (d > 100) ? max_amp : (d * max_amp / 100);
265      if (f > 0) {
266        int s;
267        int all_amp = 0;
268        for (s = 0; s < NUM_MB_SEGMENTS; ++s) {
269          VP8QuantMatrix* const dqm = &dec->dqm_[s];
270          if (dqm->uv_quant_ < DITHER_AMP_TAB_SIZE) {
271            const int idx = (dqm->uv_quant_ < 0) ? 0 : dqm->uv_quant_;
272            dqm->dither_ = (f * kQuantToDitherAmp[idx]) >> 3;
273          }
274          all_amp |= dqm->dither_;
275        }
276        if (all_amp != 0) {
277          VP8InitRandom(&dec->dithering_rg_, 1.0f);
278          dec->dither_ = 1;
279        }
280      }
281      dec->alpha_dithering_ = options->alpha_dithering_strength;
282      if (dec->alpha_dithering_ > 100) {
283        dec->alpha_dithering_ = 100;
284      } else if (dec->alpha_dithering_ < 0) {
285        dec->alpha_dithering_ = 0;
286      }
287    }
288  }
289  static void Dither8x8(VP8Random* const rg, uint8_t* dst, int bps, int amp) {
290    uint8_t dither[64];
291    int i;
292    for (i = 0; i < 8 * 8; ++i) {
293      dither[i] = VP8RandomBits2(rg, VP8_DITHER_AMP_BITS + 1, amp);
294    }
295    VP8DitherCombine8x8(dither, dst, bps);
296  }
297  static void DitherRow(VP8Decoder* const dec) {
298    int mb_x;
299    assert(dec->dither_);
300    for (mb_x = dec->tl_mb_x_; mb_x < dec->br_mb_x_; ++mb_x) {
301      const VP8ThreadContext* const ctx = &dec->thread_ctx_;
302      const VP8MBData* const data = ctx->mb_data_ + mb_x;
303      const int cache_id = ctx->id_;
304      const int uv_bps = dec->cache_uv_stride_;
305      if (data->dither_ >= MIN_DITHER_AMP) {
306        uint8_t* const u_dst = dec->cache_u_ + cache_id * 8 * uv_bps + mb_x * 8;
307        uint8_t* const v_dst = dec->cache_v_ + cache_id * 8 * uv_bps + mb_x * 8;
308        Dither8x8(&dec->dithering_rg_, u_dst, uv_bps, data->dither_);
309        Dither8x8(&dec->dithering_rg_, v_dst, uv_bps, data->dither_);
310      }
311    }
312  }
313  #define MACROBLOCK_VPOS(mb_y)  ((mb_y) * 16)    
314  static int FinishRow(void* arg1, void* arg2) {
315    VP8Decoder* const dec = (VP8Decoder*)arg1;
316    VP8Io* const io = (VP8Io*)arg2;
317    int ok = 1;
318    const VP8ThreadContext* const ctx = &dec->thread_ctx_;
319    const int cache_id = ctx->id_;
320    const int extra_y_rows = kFilterExtraRows[dec->filter_type_];
321    const int ysize = extra_y_rows * dec->cache_y_stride_;
322    const int uvsize = (extra_y_rows / 2) * dec->cache_uv_stride_;
323    const int y_offset = cache_id * 16 * dec->cache_y_stride_;
324    const int uv_offset = cache_id * 8 * dec->cache_uv_stride_;
325    uint8_t* const ydst = dec->cache_y_ - ysize + y_offset;
326    uint8_t* const udst = dec->cache_u_ - uvsize + uv_offset;
327    uint8_t* const vdst = dec->cache_v_ - uvsize + uv_offset;
328    const int mb_y = ctx->mb_y_;
329    const int is_first_row = (mb_y == 0);
330    const int is_last_row = (mb_y >= dec->br_mb_y_ - 1);
331    if (dec->mt_method_ == 2) {
332      ReconstructRow(dec, ctx);
333    }
334    if (ctx->filter_row_) {
335      FilterRow(dec);
336    }
337    if (dec->dither_) {
338      DitherRow(dec);
339    }
340    if (io->put != NULL) {
341      int y_start = MACROBLOCK_VPOS(mb_y);
342      int y_end = MACROBLOCK_VPOS(mb_y + 1);
343      if (!is_first_row) {
344        y_start -= extra_y_rows;
345        io->y = ydst;
346        io->u = udst;
347        io->v = vdst;
348      } else {
349        io->y = dec->cache_y_ + y_offset;
350        io->u = dec->cache_u_ + uv_offset;
351        io->v = dec->cache_v_ + uv_offset;
352      }
353      if (!is_last_row) {
354        y_end -= extra_y_rows;
355      }
356      if (y_end > io->crop_bottom) {
357        y_end = io->crop_bottom;    
358      }
359      io->a = NULL;
360      if (dec->alpha_data_ != NULL && y_start < y_end) {
361        io->a = VP8DecompressAlphaRows(dec, io, y_start, y_end - y_start);
362        if (io->a == NULL) {
363          return VP8SetError(dec, VP8_STATUS_BITSTREAM_ERROR,
364                             "Could not decode alpha data.");
365        }
366      }
367      if (y_start < io->crop_top) {
368        const int delta_y = io->crop_top - y_start;
369        y_start = io->crop_top;
370        assert(!(delta_y & 1));
371        io->y += dec->cache_y_stride_ * delta_y;
372        io->u += dec->cache_uv_stride_ * (delta_y >> 1);
373        io->v += dec->cache_uv_stride_ * (delta_y >> 1);
374        if (io->a != NULL) {
375          io->a += io->width * delta_y;
376        }
377      }
378      if (y_start < y_end) {
379        io->y += io->crop_left;
380        io->u += io->crop_left >> 1;
381        io->v += io->crop_left >> 1;
382        if (io->a != NULL) {
383          io->a += io->crop_left;
384        }
385        io->mb_y = y_start - io->crop_top;
386        io->mb_w = io->crop_right - io->crop_left;
387        io->mb_h = y_end - y_start;
388        ok = io->put(io);
389      }
390    }
391    if (cache_id + 1 == dec->num_caches_) {
392      if (!is_last_row) {
393        memcpy(dec->cache_y_ - ysize, ydst + 16 * dec->cache_y_stride_, ysize);
394        memcpy(dec->cache_u_ - uvsize, udst + 8 * dec->cache_uv_stride_, uvsize);
395        memcpy(dec->cache_v_ - uvsize, vdst + 8 * dec->cache_uv_stride_, uvsize);
396      }
397    }
398    return ok;
399  }
400  #undef MACROBLOCK_VPOS
401  int VP8ProcessRow(VP8Decoder* const dec, VP8Io* const io) {
402    int ok = 1;
403    VP8ThreadContext* const ctx = &dec->thread_ctx_;
404    const int filter_row =
405        (dec->filter_type_ > 0) &&
406        (dec->mb_y_ >= dec->tl_mb_y_) && (dec->mb_y_ <= dec->br_mb_y_);
407    if (dec->mt_method_ == 0) {
408      ctx->mb_y_ = dec->mb_y_;
409      ctx->filter_row_ = filter_row;
410      ReconstructRow(dec, ctx);
411      ok = FinishRow(dec, io);
412    } else {
413      WebPWorker* const worker = &dec->worker_;
414      ok &= WebPGetWorkerInterface()->Sync(worker);
415      assert(worker->status_ == OK);
416      if (ok) {   
417        ctx->io_ = *io;
418        ctx->id_ = dec->cache_id_;
419        ctx->mb_y_ = dec->mb_y_;
420        ctx->filter_row_ = filter_row;
421        if (dec->mt_method_ == 2) {  
422          VP8MBData* const tmp = ctx->mb_data_;
423          ctx->mb_data_ = dec->mb_data_;
424          dec->mb_data_ = tmp;
425        } else {
426          ReconstructRow(dec, ctx);
427        }
428        if (filter_row) {            
429          VP8FInfo* const tmp = ctx->f_info_;
430          ctx->f_info_ = dec->f_info_;
431          dec->f_info_ = tmp;
432        }
433        WebPGetWorkerInterface()->Launch(worker);
434        if (++dec->cache_id_ == dec->num_caches_) {
435          dec->cache_id_ = 0;
436        }
437      }
438    }
439    return ok;
440  }
441  VP8StatusCode VP8EnterCritical(VP8Decoder* const dec, VP8Io* const io) {
442    if (io->setup != NULL && !io->setup(io)) {
443      VP8SetError(dec, VP8_STATUS_USER_ABORT, "Frame setup failed");
444      return dec->status_;
445    }
446    if (io->bypass_filtering) {
447      dec->filter_type_ = 0;
448    }
449    {
450      const int extra_pixels = kFilterExtraRows[dec->filter_type_];
451      if (dec->filter_type_ == 2) {
452        dec->tl_mb_x_ = 0;
453        dec->tl_mb_y_ = 0;
454      } else {
455        dec->tl_mb_x_ = (io->crop_left - extra_pixels) >> 4;
456        dec->tl_mb_y_ = (io->crop_top - extra_pixels) >> 4;
457        if (dec->tl_mb_x_ < 0) dec->tl_mb_x_ = 0;
458        if (dec->tl_mb_y_ < 0) dec->tl_mb_y_ = 0;
459      }
460      dec->br_mb_y_ = (io->crop_bottom + 15 + extra_pixels) >> 4;
461      dec->br_mb_x_ = (io->crop_right + 15 + extra_pixels) >> 4;
462      if (dec->br_mb_x_ > dec->mb_w_) {
463        dec->br_mb_x_ = dec->mb_w_;
464      }
465      if (dec->br_mb_y_ > dec->mb_h_) {
466        dec->br_mb_y_ = dec->mb_h_;
467      }
468    }
469    PrecomputeFilterStrengths(dec);
470    return VP8_STATUS_OK;
471  }
472  int VP8ExitCritical(VP8Decoder* const dec, VP8Io* const io) {
473    int ok = 1;
474    if (dec->mt_method_ > 0) {
475      ok = WebPGetWorkerInterface()->Sync(&dec->worker_);
476    }
477    if (io->teardown != NULL) {
478      io->teardown(io);
479    }
480    return ok;
481  }
482  #define MT_CACHE_LINES 3
483  #define ST_CACHE_LINES 1   
484  static int InitThreadContext(VP8Decoder* const dec) {
485    dec->cache_id_ = 0;
486    if (dec->mt_method_ > 0) {
487      WebPWorker* const worker = &dec->worker_;
488      if (!WebPGetWorkerInterface()->Reset(worker)) {
489        return VP8SetError(dec, VP8_STATUS_OUT_OF_MEMORY,
490                           "thread initialization failed.");
491      }
492      worker->data1 = dec;
493      worker->data2 = (void*)&dec->thread_ctx_.io_;
494      worker->hook = FinishRow;
495      dec->num_caches_ =
496        (dec->filter_type_ > 0) ? MT_CACHE_LINES : MT_CACHE_LINES - 1;
497    } else {
498      dec->num_caches_ = ST_CACHE_LINES;
499    }
500    return 1;
501  }
502  int VP8GetThreadMethod(const WebPDecoderOptions* const options,
503                         const WebPHeaderStructure* const headers,
504                         int width, int height) {
505    if (options == NULL || options->use_threads == 0) {
506      return 0;
507    }
508    (void)headers;
509    (void)width;
510    (void)height;
511    assert(headers == NULL || !headers->is_lossless);
512  #if defined(WEBP_USE_THREAD)
513    if (width >= MIN_WIDTH_FOR_THREADS) return 2;
514  #endif
515    return 0;
516  }
517  #undef MT_CACHE_LINES
518  #undef ST_CACHE_LINES
519  static int AllocateMemory(VP8Decoder* const dec) {
520    const int num_caches = dec->num_caches_;
521    const int mb_w = dec->mb_w_;
522    const size_t intra_pred_mode_size = 4 * mb_w * sizeof(uint8_t);
523    const size_t top_size = sizeof(VP8TopSamples) * mb_w;
524    const size_t mb_info_size = (mb_w + 1) * sizeof(VP8MB);
525    const size_t f_info_size =
526        (dec->filter_type_ > 0) ?
527            mb_w * (dec->mt_method_ > 0 ? 2 : 1) * sizeof(VP8FInfo)
528          : 0;
529    const size_t yuv_size = YUV_SIZE * sizeof(*dec->yuv_b_);
530    const size_t mb_data_size =
531        (dec->mt_method_ == 2 ? 2 : 1) * mb_w * sizeof(*dec->mb_data_);
532    const size_t cache_height = (16 * num_caches
533                              + kFilterExtraRows[dec->filter_type_]) * 3 / 2;
534    const size_t cache_size = top_size * cache_height;
535    const uint64_t alpha_size = (dec->alpha_data_ != NULL) ?
536        (uint64_t)dec->pic_hdr_.width_ * dec->pic_hdr_.height_ : 0ULL;
537    const uint64_t needed = (uint64_t)intra_pred_mode_size
538                          + top_size + mb_info_size + f_info_size
539                          + yuv_size + mb_data_size
540                          + cache_size + alpha_size + WEBP_ALIGN_CST;
541    uint8_t* mem;
542    if (needed != (size_t)needed) return 0;  
543    if (needed > dec->mem_size_) {
544      WebPSafeFree(dec->mem_);
545      dec->mem_size_ = 0;
546      dec->mem_ = WebPSafeMalloc(needed, sizeof(uint8_t));
547      if (dec->mem_ == NULL) {
548        return VP8SetError(dec, VP8_STATUS_OUT_OF_MEMORY,
549                           "no memory during frame initialization.");
550      }
551      dec->mem_size_ = (size_t)needed;
552    }
553    mem = (uint8_t*)dec->mem_;
554    dec->intra_t_ = mem;
555    mem += intra_pred_mode_size;
556    dec->yuv_t_ = (VP8TopSamples*)mem;
557    mem += top_size;
558    dec->mb_info_ = ((VP8MB*)mem) + 1;
559    mem += mb_info_size;
560    dec->f_info_ = f_info_size ? (VP8FInfo*)mem : NULL;
561    mem += f_info_size;
562    dec->thread_ctx_.id_ = 0;
563    dec->thread_ctx_.f_info_ = dec->f_info_;
564    if (dec->filter_type_ > 0 && dec->mt_method_ > 0) {
565      dec->thread_ctx_.f_info_ += mb_w;
566    }
567    mem = (uint8_t*)WEBP_ALIGN(mem);
568    assert((yuv_size & WEBP_ALIGN_CST) == 0);
569    dec->yuv_b_ = mem;
570    mem += yuv_size;
571    dec->mb_data_ = (VP8MBData*)mem;
572    dec->thread_ctx_.mb_data_ = (VP8MBData*)mem;
573    if (dec->mt_method_ == 2) {
574      dec->thread_ctx_.mb_data_ += mb_w;
575    }
576    mem += mb_data_size;
577    dec->cache_y_stride_ = 16 * mb_w;
578    dec->cache_uv_stride_ = 8 * mb_w;
579    {
580      const int extra_rows = kFilterExtraRows[dec->filter_type_];
581      const int extra_y = extra_rows * dec->cache_y_stride_;
582      const int extra_uv = (extra_rows / 2) * dec->cache_uv_stride_;
583      dec->cache_y_ = mem + extra_y;
584      dec->cache_u_ = dec->cache_y_
585                    + 16 * num_caches * dec->cache_y_stride_ + extra_uv;
586      dec->cache_v_ = dec->cache_u_
587                    + 8 * num_caches * dec->cache_uv_stride_ + extra_uv;
588      dec->cache_id_ = 0;
589    }
590    mem += cache_size;
591    dec->alpha_plane_ = alpha_size ? mem : NULL;
592    mem += alpha_size;
593    assert(mem <= (uint8_t*)dec->mem_ + dec->mem_size_);
594    memset(dec->mb_info_ - 1, 0, mb_info_size);
595    VP8InitScanline(dec);   
596    memset(dec->intra_t_, B_DC_PRED, intra_pred_mode_size);
597    return 1;
598  }
599  static void InitIo(VP8Decoder* const dec, VP8Io* io) {
600    io->mb_y = 0;
601    io->y = dec->cache_y_;
602    io->u = dec->cache_u_;
603    io->v = dec->cache_v_;
604    io->y_stride = dec->cache_y_stride_;
605    io->uv_stride = dec->cache_uv_stride_;
606    io->a = NULL;
607  }
608  int VP8InitFrame(VP8Decoder* const dec, VP8Io* const io) {
609    if (!InitThreadContext(dec)) return 0;  
610    if (!AllocateMemory(dec)) return 0;
611    InitIo(dec, io);
612    VP8DspInit();  
613    return 1;
614  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-der_decode_object_identifier.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-frame_dec.c</div>
                <div class="column column_space"><pre><code>54     if (y > *outlen) {
55        err =  CRYPT_BUFFER_OVERFLOW;
56     } else {
57        err =  CRYPT_OK;
58     }
</pre></code></div>
                <div class="column column_space"><pre><code>232              if (hdr->sharpness_ > 4) {
233                ilevel >>= 2;
234              } else {
235                ilevel >>= 1;
236              }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    