<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for defines.h &amp; viz_output.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for defines.h &amp; viz_output.c
      </h3>
<h1 align="center">
        0.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>defines.h (1.4098691%)<th>viz_output.c (0.58848256%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(811-821)<td><a href="#" name="0">(1606-1616)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>defines.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef SRC4_DEFINES_H_
2 #define SRC4_DEFINES_H_
3 #include &lt;stdint.h&gt;
4 #include &lt;vector&gt;
5 #include &lt;set&gt;
6 #include &lt;string&gt;
7 #include &lt;cassert&gt;
8 #include &lt;climits&gt;
9 #include &lt;cmath&gt;
10 #include &lt;iostream&gt;
11 #include &lt;map&gt;
12 #include &lt;unordered_map&gt;
13 #include "mcell_structs_shared.h"
14 #include "debug_config.h"
15 #include "../libs/glm/glm.hpp"
16 #define GLM_ENABLE_EXPERIMENTAL
17 #include "../libs/glm/gtx/component_wise.hpp"
18 #include "bng/shared_defines.h" 
19 #if defined(NDEBUG) &amp;&amp; defined(INDEXER_WA)
20 #warning "INDEXER_WA is enabled and this will lead to lower performance"
21 #endif
22 #ifndef INDEXER_WA
23 #include &lt;boost/container/small_vector.hpp&gt;
24 #include &lt;boost/container/flat_set.hpp&gt;
25 #endif
26 namespace MCell {
27 using BNGCommon::f_to_str;
28 using BNGCommon::EPS;
29 using BNGCommon::SQRT_EPS;
30 using BNGCommon::DBL_GIGANTIC;
31 using BNGCommon::pos_t;
32 using BNGCommon::POS_EPS;
33 using BNGCommon::POS_SQRT_EPS;
34 using BNGCommon::POS_GIGANTIC;
35 using BNGCommon::stime_t;
36 using BNGCommon::STIME_EPS;
37 using BNGCommon::STIME_SQRT_EPS;
38 using BNGCommon::STIME_GIGANTIC;
39 using BNGCommon::fabs_f;
40 using BNGCommon::cmp_eq;
41 using BNGCommon::distinguishable_p;
42 using BNGCommon::distinguishable_f;
43 using BNGCommon::sqrt_f;
44 using BNGCommon::pow_f;
45 using BNGCommon::floor_f;
46 using BNGCommon::round_f;
47 using BNG::species_id_t;
48 using BNG::SPECIES_ID_INVALID;
49 using BNG::orientation_t;
50 using BNG::ORIENTATION_DOWN;
51 using BNG::ORIENTATION_NONE;
52 using BNG::ORIENTATION_UP;
53 using BNG::ORIENTATION_NOT_SET;
54 using BNG::ORIENTATION_DEPENDS_ON_SURF_COMP;
55 const double MIN_WALL_GAP = 1e-4; 
56 #if defined(likely) || defined(unlikely)
57 #error "Macros 'likely' or 'unlikely' are already defined"
58 #endif
59 #ifndef _MSC_VER
60 #define likely(x)       __builtin_expect((x),1)
61 #define unlikely(x)     __builtin_expect((x),0)
62 #else
63 #define likely(x)       (x)
64 #define unlikely(x)     (x)
65 #endif
66 const double SCHEDULER_COMPARISON_EPS = 1e-10;
67 const size_t SCHEDULER_MAX_BUCKETS_TO_FUTURE = 100000000;
68 const double MESH_DISTINCTIVE_EPS = EPS;
69 const uint SORT_MOLS_BY_SUBPART_PERIODICITY = 20;
70 const uint DEFRAGMENTATION_PERIODICITY = 100;
71 const pos_t PARTITION_EDGE_LENGTH_DEFAULT_UM = 10; const pos_t PARTITION_EDGE_EXTRA_MARGIN_UM = 0.01;
72 const uint SUBPARTITIONS_PER_PARTITION_DIMENSION_DEFAULT = 1;
73 const uint MAX_SUBPARTS_PER_PARTITION = 300;
74 const double COUNT_BUFFER_FLUSH_SECONDS = 60;
75 const uint64_t ITERATIONS_BEFORE_RUN_N_ITERATIONS_END_EVENT = 10000;
76 const uint64_t DEFAULT_MOL_ORDER_SHUFFLE_PERIODICITY = 10000;
77 const pos_t POS_INVALID = FLT_MAX; const pos_t LENGTH_INVALID = FLT_MAX;
78 const double TIME_INVALID = -256;
79 const double TIME_FOREVER = 1e20; const double TIME_SIMULATION_START = 0;
80 const pos_t POS_SQRT2 = 1.41421356238;
81 const pos_t POS_RXN_RADIUS_MULTIPLIER = 1.3; 
82 const uint INT_INVALID = INT32_MAX;
83 typedef uint molecule_id_t;
84 const molecule_id_t MOLECULE_ID_INVALID = ID_INVALID;
85 typedef std::vector&lt;molecule_id_t&gt; MoleculeIdsVector;
86 typedef uint_set&lt;molecule_id_t&gt; MoleculeIdsSet;
87 typedef uint molecule_index_t;
88 const molecule_index_t MOLECULE_INDEX_INVALID = INDEX_INVALID;
89 typedef uint partition_id_t;
90 const partition_id_t PARTITION_ID_INITIAL = 0;
91 const partition_id_t PARTITION_ID_INVALID = INDEX_INVALID;
92 typedef uint subpart_index_t;
93 const subpart_index_t SUBPART_INDEX_INVALID = INDEX_INVALID;
94 const uint TIME_STEP_INDEX_INVALID = INDEX_INVALID;
95 const char* const NAME_INVALID = "name_invalid";
96 const char* const NAME_NOT_SET = "name_not_set";
97 const uint64_t BUCKET_INDEX_INVALID = UINT64_MAX;
98 const uint VERTICES_IN_TRIANGLE = 3;
99 const uint EDGES_IN_TRIANGLE = VERTICES_IN_TRIANGLE; 
100 typedef uint vertex_index_t; const vertex_index_t VERTEX_INDEX_INVALID = INDEX_INVALID;
101 typedef uint wall_index_t; const wall_index_t WALL_INDEX_INVALID = INDEX_INVALID;
102 typedef uint tile_index_t; const tile_index_t TILE_INDEX_INVALID = INDEX_INVALID;
103 typedef uint edge_index_t; const edge_index_t EDGE_INDEX_0 = 0;
104 const edge_index_t EDGE_INDEX_1 = 1;
105 const edge_index_t EDGE_INDEX_2 = 2;
106 const edge_index_t EDGE_INDEX_WITHIN_WALL = 3; const edge_index_t EDGE_INDEX_CANNOT_TELL = 4;
107 const edge_index_t EDGE_INDEX_INVALID = INDEX_INVALID;
108 typedef uint count_buffer_id_t; const count_buffer_id_t COUNT_BUFFER_ID_INVALID = INDEX_INVALID;
109 typedef uint rgba_t; const rgba_t DEFAULT_COLOR = 0xFFFFFF3F; 
110 class WallTileIndexPair {
111 public:
112   WallTileIndexPair()
113     : wall_index(WALL_INDEX_INVALID), tile_index(TILE_INDEX_INVALID)
114     {
115   }
116   WallTileIndexPair(const wall_index_t wall_index_, const tile_index_t tile_index_)
117     : wall_index(wall_index_), tile_index(tile_index_)
118     {
119   }
120   bool operator== (const WallTileIndexPair&amp; other) const {
121     return wall_index == other.wall_index &amp;&amp; tile_index == other.tile_index;
122   }
123   wall_index_t wall_index;    tile_index_t tile_index;  };
124 typedef uint wall_id_t; const wall_id_t WALL_ID_INVALID = ID_INVALID;
125 const wall_id_t WALL_ID_NOT_IN_PARTITION = ID_INVALID2;
126 typedef uint region_id_t; const region_id_t REGION_ID_INVALID = ID_INVALID;
127 typedef uint region_index_t; const region_index_t REGION_INDEX_INVALID = INDEX_INVALID;
128 typedef uint_set&lt;region_index_t&gt; RegionIndicesSet;
129 typedef uint geometry_object_index_t;
130 const geometry_object_index_t GEOMETRY_OBJECT_INDEX_INVALID = INDEX_INVALID;
131 typedef uint geometry_object_id_t; const geometry_object_id_t GEOMETRY_OBJECT_ID_INVALID = ID_INVALID;
132 typedef uint counted_volume_index_t;
133 const counted_volume_index_t COUNTED_VOLUME_INDEX_OUTSIDE_ALL = 0;
134 const counted_volume_index_t COUNTED_VOLUME_INDEX_INTERSECTS = INDEX_INVALID2;
135 const counted_volume_index_t COUNTED_VOLUME_INDEX_INVALID = INDEX_INVALID;
136 typedef std::pair&lt;partition_id_t, wall_index_t&gt; PartitionWallIndexPair;
137 typedef std::pair&lt;partition_id_t, region_index_t&gt; PartitionRegionIndexPair;
138 typedef std::pair&lt;partition_id_t, vertex_index_t&gt; PartitionVertexIndexPair;
139 typedef std::pair&lt;pos_t, PartitionWallIndexPair&gt; CummAreaPWallIndexPair;
140 typedef std::map&lt;geometry_object_id_t, uint_set&lt;geometry_object_id_t&gt;&gt; CountedVolumesMap;
141 const int BASE_CONTAINER_ALLOC = 16;
142 #ifndef INDEXER_WA
143 typedef boost::container::small_vector&lt;subpart_index_t, BASE_CONTAINER_ALLOC&gt;  SubpartIndicesVector;
144 typedef boost::container::small_vector&lt;wall_index_t, BASE_CONTAINER_ALLOC&gt; WallIndicesVector;
145 typedef uint_dense_hash_set&lt;subpart_index_t&gt; SubpartIndicesSet; #else
146 typedef std::vector&lt;subpart_index_t&gt; SubpartIndicesVector;
147 typedef std::vector&lt;wall_index_t&gt; WallIndicesVector;
148 typedef std::set&lt;subpart_index_t&gt; SubpartIndicesSet;
149 #endif
150 template&lt;typename T&gt;
151 class insertion_ordered_set {
152 public:
153   void insert_ordered(const T&amp; value) {
154     if (s.count(value) == 0) {
155       s.insert(value);
156       v.push_back(value);
157     }
158   }
159   const T&amp; operator [] (const size_t i) const {
160     assert(i &lt; size());
161     return v[i];
162   }
163   size_t size() const {
164     assert(v.size() == s.size());
165     return v.size();
166   }
167   const std::vector&lt;T&gt;&amp; get_as_vector() const {
168     return v;
169   }
170 private:
171   std::vector&lt;T&gt; v;
172   std::set&lt;T&gt; s;
173 };
174 #if POS_T_BYTES == 8
175 typedef glm::dvec3 glm_vec3_t;
176 typedef glm::dvec2 glm_vec2_t;
177 typedef glm::dmat4x4 mat4x4;
178 #else
179 typedef glm::fvec3 glm_vec3_t;
180 typedef glm::fvec2 glm_vec2_t;
181 typedef glm::fmat4x4 mat4x4;
182 #endif
183 typedef glm::ivec3 glm_ivec3_t;
184 typedef glm::uvec3 UVec3;
185 typedef glm::bvec3 BVec3;
186 struct IVec3: public glm_ivec3_t {
187   IVec3() = default;
188   IVec3(const glm_vec3_t&amp; a) { x = a.x; y = a.y; z = a.z; }
189   IVec3(const IVec3&amp; a) : glm_ivec3_t(a.x, a.y, a.z) { }
190   IVec3(const int x_, const int y_, const int z_) { x = x_; y = y_; z = z_; }
191   IVec3(const int xyz) { x = xyz; y = xyz; z = xyz; }
192   IVec3(const std::vector&lt;int&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
193   IVec3(const vector3&amp; v3) { x = v3.x; y = v3.y; z = v3.z; }
194   IVec3&amp; operator=(const IVec3&amp; other) = default;
195   bool operator &lt; (const IVec3&amp; other) const {
196     if (x &lt; other.x) {
197       return true;
198     }
199     else if (x == other.x) {
200       if (y &lt; other.y) {
201         return true;
202       }
203       else if (y == other.y) {
204         if (z &lt; other.z) {
205           return true;
206         }
207         else {
208           return false;
209         }
210       }
211       else {
212         return false;
213       }
214     }
215     else {
216       return false;
217     }
218   }
219 };
220 struct Vec3: public glm_vec3_t {
221   Vec3() = default;
222   Vec3(const glm_vec3_t&amp; a) { x = a.x; y = a.y; z = a.z; }
223   Vec3(const Vec3&amp; a) : glm_vec3_t(a.x, a.y, a.z) { }
224   Vec3(const IVec3&amp; a) : glm_vec3_t(a.x, a.y, a.z) { }
225   Vec3(const vector3&amp; a) { x = a.x; y = a.y; z = a.z; }
226   Vec3(const pos_t x_, const pos_t y_, const pos_t z_) { x = x_; y = y_; z = z_; }
227   Vec3(const pos_t xyz) { x = xyz; y = xyz; z = xyz; }
228   Vec3(const std::vector&lt;double&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
229 #if POS_T_BYTES == 4
230   Vec3(const std::vector&lt;pos_t&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
231 #endif
232   Vec3&amp; operator=(const Vec3&amp; other) = default;
233   std::vector&lt;double&gt; to_vec() const {
234     std::vector&lt;double&gt; res(3);
235     res[0] = x;
236     res[1] = y;
237     res[2] = z;
238     return res;
239   }
240   bool is_valid() const { return !(x == POS_INVALID || y == POS_INVALID || z == POS_INVALID); }
241   std::string to_string() const;
242   void dump(const std::string extra_comment, const std::string ind) const;
243 };
244 struct Vec2: public glm_vec2_t {
245   Vec2() = default;
246   Vec2(const glm_vec2_t&amp; a) { x = a.x; y = a.y; }
247   Vec2(const Vec2&amp; a) : glm_vec2_t(a.x, a.y) { }
248   Vec2(const vector2&amp; a) { x = a.u; y = a.v; }
249   Vec2(const pos_t x_, const pos_t y_) { x = x_; y = y_; }
250   Vec2(const pos_t xy) { x = xy; y = xy; }
251   Vec2(const std::vector&lt;double&gt;&amp; xy) { assert(xy.size() == 2); x = xy[0]; y = xy[1]; }
252 #if POS_T_BYTES == 4
253   Vec2(const std::vector&lt;pos_t&gt;&amp; xy) { assert(xy.size() == 2); x = xy[0]; y = xy[1]; }
254 #endif
255   Vec2&amp; operator=(const Vec2&amp; other) = default;
256   std::vector&lt;double&gt; to_vec() const {
257     std::vector&lt;double&gt; res(2);
258     res[0] = x;
259     res[1] = y;
260     return res;
261   }
262   bool is_valid() const { return !(x == POS_INVALID || y == POS_INVALID); }
263   std::string to_string() const;
264   void dump(const std::string extra_comment, const std::string ind) const;
265 };
266 static inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const Vec3&amp; a) {
267   out &lt;&lt; "(" &lt;&lt; a.x &lt;&lt; ", " &lt;&lt; a.y &lt;&lt; ", " &lt;&lt; a.z &lt;&lt; ")";
268   return out;
269 }
270 static inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const Vec2&amp; a) {
271   out &lt;&lt; "(" &lt;&lt; a.u &lt;&lt; ", " &lt;&lt; a.v &lt;&lt; ")";
272   return out;
273 }
274 static inline double log_f(const double x) {
275   assert(x != 0);
276   return log(x);
277 }
278 static inline pos_t log_p(const pos_t x) {
279   assert(x != 0);
280 #if POS_T_BYTES == 4
281   return logf(x);
282 #else
283   return log(x);
284 #endif
285 }
286 static inline double exp_f(const double x) {
287   return exp(x);
288 }
289 static inline double ceil_f(const double x) {
290   return ceil(x);
291 }
292 static inline double ceil_p(const pos_t x) {
293 #if POS_T_BYTES == 8
294   return ceil(x);
295 #else
296   return ceilf(x);
297 #endif
298 }
299 static inline pos_t fabs_p(const pos_t x) {
300   if (x &lt; 0) {
301     return -x;
302   }
303   else {
304     return x;
305   }
306 }
307 static inline double floor_to_multiple_f(const double val, double multiple) {
308   assert(val &gt;= 0);
309   assert(multiple &gt; 0);
310   return (double)((long long)((val + EPS)/ multiple)) * multiple;
311 }
312 static inline pos_t floor_to_multiple_p(const pos_t val, pos_t multiple) {
313   assert(val &gt;= 0);
314   assert(multiple &gt; 0);
315   return (pos_t)((long long)((val + EPS)/ multiple)) * multiple;
316 }
317 static inline double floor_to_multiple_allow_negative_p(const double val, pos_t multiple) {
318   if (val &gt;= 0) {
319     return (double)((long long)((val + EPS)/ multiple)) * multiple;
320   }
321   else {
322     return (double)((long long)((val + EPS - multiple)/ multiple)) * multiple;
323   }
324 }
325 static inline Vec3 floor_to_multiple_allow_negative_p(const Vec3&amp; val, const pos_t multiple) {
326   Vec3 res;
327   res.x = floor_to_multiple_allow_negative_p(val.x, multiple);
328   res.y = floor_to_multiple_allow_negative_p(val.y, multiple);
329   res.z = floor_to_multiple_allow_negative_p(val.z, multiple);
330   return res;
331 }
332 static inline double ceil_to_multiple_p(const double val, const pos_t multiple) {
333   assert(val &gt;= 0);
334   double res = floor_to_multiple_p(val, multiple);
335   if (!cmp_eq(val, res)) {
336     res += multiple;
337   }
338   return res;
339 }
340 static inline Vec3 ceil_to_multiple_p(const Vec3&amp; val, const pos_t multiple) {
341   Vec3 res;
342   res.x = ceil_to_multiple_p(val.x, multiple);
343   res.y = ceil_to_multiple_p(val.y, multiple);
344   res.z = ceil_to_multiple_p(val.z, multiple);
345   return res;
346 }
347 static inline bool cmp_eq(const Vec3&amp; a, const Vec3&amp; b, const pos_t eps) {
348   return cmp_eq(a.x, b.x, eps) &amp;&amp; cmp_eq(a.y, b.y, eps) &amp;&amp; cmp_eq(a.z, b.z, eps);
349 }
350 static inline bool cmp_eq(const Vec3&amp; a, const Vec3&amp; b) {
351   return cmp_eq(a, b, EPS);
352 }
353 static inline bool cmp_eq(const Vec2&amp; a, const Vec2&amp; b, const pos_t eps) {
354   return cmp_eq(a.x, b.x, eps) &amp;&amp; cmp_eq(a.y, b.y, eps);
355 }
356 static inline bool cmp_eq(const Vec2&amp; a, const Vec2&amp; b) {
357   return cmp_eq(a, b, EPS);
358 }
359 static inline bool cmp_lt(const double a, const double b, const double eps) {
360   return a &lt; b &amp;&amp; !cmp_eq(a, b, eps);
361 }
362 static inline bool cmp_le(const double a, const double b, const double eps) {
363   return a &lt; b || cmp_eq(a, b, eps);
364 }
365 static inline bool cmp_gt(const double a, const double b, const double eps) {
366   return a &gt; b &amp;&amp; !cmp_eq(a, b, eps);
367 }
368 static inline bool cmp_ge(const double a, const double b, const double eps) {
369   return a &gt; b || cmp_eq(a, b, eps);
370 }
371 static inline pos_t sqrt_p(const pos_t x) {
372 #if POS_T_BYTES == 4
373   return sqrtf(x);
374 #else
375   return sqrt(x);
376 #endif
377 }
378 static inline uint powu(const uint a, const uint n) {
379   uint res = a;
380   for (uint i = 1; i &lt; n; i++) {
381     res *= a;
382   }
383   return res;
384 }
385 static inline pos_t max3(const Vec3&amp; v) {
386   return glm::compMax((glm_vec3_t)v);
387 }
388 static inline pos_t min3(const Vec3&amp; v) {
389   return glm::compMin((glm_vec3_t)v);
390 }
391 static inline pos_t min3_p(const pos_t x, const pos_t y, const pos_t z) {
392   return (z &lt; y) ? ((z &lt; x) ? z : x) : ((y &lt; x) ? y : x);
393 }
394 static inline int max3_i(const IVec3&amp; v) {
395   return glm::compMax((glm_ivec3_t)v);
396 }
397 static inline int min3_i(const IVec3&amp; v) {
398   return glm::compMin((glm_ivec3_t)v);
399 }
400 static inline Vec3 abs3(const Vec3&amp; v) {
401   return glm::abs((glm_vec3_t)v);
402 }
403 static inline Vec3 floor3(const Vec3&amp; v) {
404   return glm::floor((glm_vec3_t)v);
405 }
406 static inline Vec3 round3(const Vec3&amp; v) {
407   return glm::round((glm_vec3_t)v);
408 }
409 static inline pos_t abs_max_2vec(const Vec3&amp; v1, const Vec3&amp; v2) {
410   glm_vec3_t v1abs = abs3(v1);
411   glm_vec3_t v2abs = abs3(v2);
412   Vec3 vmax = glm::max(v1abs, v2abs);
413   return MCell::max3(vmax);
414 }
415 static inline pos_t determinant2(const Vec2&amp; v1, const Vec2&amp; v2) {
416   return v1.u * v2.v - v1.v * v2.u;
417 }
418 static inline pos_t dot2(const Vec2&amp; v1, const Vec2&amp; v2) {
419   return glm::dot((glm_vec2_t)v1, (glm_vec2_t)v2);
420 }
421 static inline pos_t len2_squared(const Vec2&amp; v1) {
422   return v1.u * v1.u + v1.v * v1.v;
423 }
424 static inline pos_t len2(const Vec2&amp; v1) {
425   return sqrt_p(len2_squared(v1));
426 }
427 static inline pos_t dot(const Vec3&amp; v1, const Vec3&amp; v2) {
428   return glm::dot((glm_vec3_t)v1, (glm_vec3_t)v2);
429 }
430 static inline pos_t len3_squared(const Vec3&amp; v1) {
431   return v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
432 }
433 static inline pos_t len3(const Vec3&amp; v1) {
434   return sqrt_p(len3_squared(v1));
435 }
436 static inline pos_t distance3_squared(const Vec3&amp; v1, const Vec3&amp; v2) {
437   return len3_squared(v1 - v2);
438 }
439 static inline pos_t distance3(const Vec3&amp; v1, const Vec3&amp; v2) {
440   return sqrt_p( len3_squared(v1 - v2) );
441 }
442 static inline uint get_largest_abs_dim_index(const Vec3&amp; v) {
443   Vec3 a = glm::abs(glm_vec3_t(v));
444   if (a.x &gt; a.y) {
445     if (a.x &gt; a.z) {
446       return 0;     }
447     else {
448       return 2;     }
449   }
450   else {
451     if (a.y &gt; a.z) {
452       return 1;     }
453     else {
454       return 2;     }
455   }
456 }
457 static inline bool point_in_box(const Vec3&amp; pt, const Vec3&amp; llf, const Vec3&amp; urb) {
458   return
459       pt.x &gt;= llf.x &amp;&amp; pt.x &lt;= urb.x &amp;&amp;
460       pt.y &gt;= llf.y &amp;&amp; pt.y &lt;= urb.y &amp;&amp;
461       pt.z &gt;= llf.z &amp;&amp; pt.z &lt;= urb.z;
462 }
463 static inline Vec3 cross(const Vec3&amp; v1, const Vec3&amp; v2) {
464   return glm::cross((glm_vec3_t)v1, (glm_vec3_t)v2);
465 }
466 static inline int distinguishable_vec2(const Vec2&amp; a, const Vec2&amp; b, const pos_t eps) {
467   pos_t c, cc, d;
468   c = fabs_p(a.u);
469   d = fabs_p(a.v);
470   if (d &gt; c)
471     c = d;
472   d = fabs_p(b.u);
473   if (d &gt; c)
474     c = d;
475   d = fabs_p(b.v);
476   if (d &gt; c)
477     c = d;
478   cc = fabs_p(a.u - b.u);
479   d = fabs_p(a.v - b.v);
480   if (d &gt; cc)
481     cc = d;
482   if (c &lt; eps)
483     c = eps;
484   return (c * eps &lt; cc);
485 }
486 static inline bool distinguishable_vec3(const Vec3&amp; a, const Vec3&amp; b, const pos_t eps) {
487   pos_t c, cc, d;
488   c = fabs_p(a.x);
489   d = fabs_p(a.y);
490   if (d &gt; c)
491     c = d;
492   d = fabs_p(a.z);
493   if (d &gt; c)
494     c = d;
495   d = fabs_p(b.x);
496   if (d &gt; c)
497     c = d;
498   d = fabs_p(b.y);
499   if (d &gt; c)
500     c = d;
501   d = fabs_p(b.z);
502   if (d &gt; c)
503     c = d;
504   cc = fabs_p(a.x - b.x);
505   d = fabs_p(a.y - b.y);
506   if (d &gt; cc)
507     cc = d;
508   d = fabs_p(a.z - b.z);
509   if (d &gt; cc)
510     cc = d;
511   if (c &lt; eps)
512     c = eps;
513   return (c * eps &lt; cc);
514 <a name="0"></a>}
515 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static inline void guard_zero_div(Vec3&amp; val) {
516   if (val.x == 0) {
517     val.x = FLT_MIN;
518   }
519   if (val.y == 0) {
520     val.y = FLT_MIN;
521   }
522   if (val.z == 0) {
523     val.z = FLT_MIN;
524   }
525 }</b></font>
526 uint64_t get_mem_usage();
527 } 
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>viz_output.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdarg.h&gt;
3 #include &lt;limits.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;fcntl.h&gt;
8 #ifndef _MSC_VER
9 #include &lt;unistd.h&gt;
10 #include &lt;dirent.h&gt;
11 #endif
12 #include &lt;string.h&gt;
13 #include &lt;sys/types.h&gt;
14 #include &lt;sys/stat.h&gt;
15 #include &lt;errno.h&gt;
16 #include &lt;assert.h&gt;
17 #include "c_vector.h"
18 #include "debug_config.h"
19 #include "logging.h"
20 #include "mcell_structs.h"
21 #include "grid_util.h"
22 #include "sched_util.h"
23 #include "viz_output.h"
24 #include "strfunc.h"
25 #include "util.h"
26 #include "vol_util.h"
27 #include "sym_table.h"
28 #include "bng_util.h"
29 #define VIZ_OPTS_NONE        0x00L
30 #define VIZ_COMP_NAMING_MASK 0x0FL #define VIZ_COMP_ALL_SAME    0x01L #define VIZ_COMP_NAME_GLOBAL 0x02L #define VIZ_COMP_MOL_LOCAL   0x03L #define VIZ_PROXY_OUTPUT     0x08L 
31 #define VIZ_ALT_FILES_MASK   0xF0L #define VIZ_ALT_DUMP_FMT     0x10L #define VIZ_JSON_MOLCOMP_FMT 0x20L 
32 static int output_ascii_molecules(struct volume *world,
33                                   struct viz_output_block *,
34                                   struct frame_data_list *fdlp);
35 static int output_cellblender_molecules(struct volume *world,
36                                         struct viz_output_block *,
37                                         struct frame_data_list *fdlp);
38 static long long frame_iteration(struct volume *world, double iterval,
39                                  int type) {
40   switch (type) {
41   case OUTPUT_BY_ITERATION_LIST:
42     return (long long)iterval;
43   case OUTPUT_BY_TIME_LIST:
44     if (world-&gt;chkpt_seq_num == 1) {
45       return (long long)(iterval / world-&gt;time_unit + ROUND_UP);
46     } else {
47       if (iterval &gt;= world-&gt;simulation_start_seconds) {
48         return (long long) convert_seconds_to_iterations(
49             world-&gt;start_iterations, world-&gt;time_unit,
50             world-&gt;simulation_start_seconds, iterval) + ROUND_UP;
51       } else {
52         return INT_MIN;
53       }
54     }
55   default:
56     mcell_internal_error("Invalid frame_data_list list_type (%d).", type);
57   }
58 }
59 static int sort_molecules_by_species(struct volume *world,
60                                      struct viz_output_block *vizblk,
61                                      struct abstract_molecule ****viz_molpp,
62                                      u_int **viz_mol_countp, int include_volume,
63                                      int include_grid) {
64   struct storage_list *slp;
65   u_int *counts;
66   int species_index;
67   if ((*viz_molpp = (struct abstract_molecule ***)allocate_ptr_array(
68            world-&gt;n_species)) == NULL)
69     return 1;
70   if ((counts = *viz_mol_countp = allocate_uint_array(world-&gt;n_species, 0)) ==
71       NULL)
72     return 1;
73   for (species_index = 0; species_index &lt; world-&gt;n_species; ++species_index) {
74     int mol_count;
75     u_int spec_id = world-&gt;species_list[species_index]-&gt;species_id;
76     if (vizblk-&gt;species_viz_states[species_index] == EXCLUDE_OBJ)
77       continue;
78     if (world-&gt;species_list[species_index]-&gt;flags &amp; IS_SURFACE)
79       continue;
80     if (!include_grid &amp;&amp; (world-&gt;species_list[species_index]-&gt;flags &amp; ON_GRID))
81       continue;
82     if (!include_volume &amp;&amp;
83         !(world-&gt;species_list[species_index]-&gt;flags &amp; ON_GRID))
84       continue;
85     mol_count = world-&gt;species_list[species_index]-&gt;population;
86     if (mol_count &lt;= 0)
87       continue;
88     if (((*viz_molpp)[spec_id] =
89              (struct abstract_molecule **)allocate_ptr_array(mol_count)) ==
90         NULL)
91       return 1;
92   }
93   for (slp = world-&gt;storage_head; slp != NULL; slp = slp-&gt;next) {
94     struct storage *sp = slp-&gt;store;
95     struct schedule_helper *shp;
96     struct abstract_molecule *amp;
97     int sched_slot_index;
98     for (shp = sp-&gt;timer; shp != NULL; shp = shp-&gt;next_scale) {
99       for (sched_slot_index = -1; sched_slot_index &lt; shp-&gt;buf_len;
100            ++sched_slot_index) {
101         for (amp = (struct abstract_molecule *)((sched_slot_index &lt; 0)
102                                                     ? shp-&gt;current
103                                                     : shp-&gt;circ_buf_head
104                                                           [sched_slot_index]);
105              amp != NULL; amp = amp-&gt;next) {
106           u_int spec_id;
107           if (amp-&gt;properties == NULL)
108             continue;
109           spec_id = amp-&gt;properties-&gt;species_id;
110           if (vizblk-&gt;species_viz_states[spec_id] == EXCLUDE_OBJ)
111             continue;
112           if (!include_grid &amp;&amp; (amp-&gt;flags &amp; TYPE_MASK) != TYPE_VOL)
113             continue;
114           if (!include_volume &amp;&amp; (amp-&gt;flags &amp; TYPE_MASK) == TYPE_VOL)
115             continue;
116           if (counts[spec_id] &lt; amp-&gt;properties-&gt;population)
117             (*viz_molpp)[spec_id][counts[spec_id]++] = amp;
118           else {
119             mcell_warn("Molecule count disagreement!\n"
120                        "  Species %s  population = %d  count = %d",
121                        amp-&gt;properties-&gt;sym-&gt;name, amp-&gt;properties-&gt;population,
122                        counts[spec_id]);
123           }
124         }
125       }
126     }
127   }
128   return 0;
129 }
130 static int reset_time_values(struct volume *world, struct frame_data_list *fdlp,
131                              long long curiter) {
132   if (curiter != 0)
133     ++curiter;
134   for (; fdlp != NULL; fdlp = fdlp-&gt;next) {
135     fdlp-&gt;curr_viz_iteration = fdlp-&gt;iteration_list;
136     fdlp-&gt;viz_iteration = -1;
137     while (fdlp-&gt;curr_viz_iteration != NULL) {
138       if (frame_iteration(world, fdlp-&gt;curr_viz_iteration-&gt;value,
139                           fdlp-&gt;list_type) &gt;= curiter)
140         break;
141       fdlp-&gt;curr_viz_iteration = fdlp-&gt;curr_viz_iteration-&gt;next;
142     }
143     if (fdlp-&gt;curr_viz_iteration != NULL)
144       fdlp-&gt;viz_iteration = frame_iteration(
145           world, fdlp-&gt;curr_viz_iteration-&gt;value, fdlp-&gt;list_type);
146   }
147   return 0;
148 }
149 static int count_time_values(struct volume *world,
150                              struct frame_data_list *const fdlp) {
151   int time_values = 0;
152   long long curiter = -1;
153   struct frame_data_list *fdlpcur = NULL;
154   for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
155     fdlpcur-&gt;curr_viz_iteration = fdlpcur-&gt;iteration_list;
156     fdlpcur-&gt;n_viz_iterations = 0;
157     fdlpcur-&gt;viz_iteration = -1;
158   }
159   while (1) {
160     curiter = -1;
161     for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
162       long long thisiter;
163       if (fdlpcur-&gt;curr_viz_iteration == NULL)
164         continue;
165       thisiter = frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
166                                  fdlpcur-&gt;list_type);
167       if (curiter == -1)
168         curiter = thisiter;
169       else if (thisiter &lt; curiter)
170         curiter = thisiter;
171     }
172     if (curiter == -1)
173       break;
174     if (curiter &gt; world-&gt;iterations)
175       break;
176     if (world-&gt;chkpt_iterations != 0 &amp;&amp;
177         curiter &gt; world-&gt;start_iterations + world-&gt;chkpt_iterations)
178       break;
179     if (curiter &gt; world-&gt;start_iterations)
180       ++time_values;
181     else if ((world-&gt;start_iterations | curiter) == 0)
182       ++time_values;
183     for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
184       if (fdlpcur-&gt;curr_viz_iteration == NULL)
185         continue;
186       if (curiter &gt; world-&gt;start_iterations || (world-&gt;start_iterations | curiter) == 0) {
187         if (frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
188                             fdlpcur-&gt;list_type) == curiter)
189           ++fdlpcur-&gt;n_viz_iterations;
190       }
191       while (fdlpcur-&gt;curr_viz_iteration &amp;&amp;
192              frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
193                              fdlpcur-&gt;list_type) == curiter)
194         fdlpcur-&gt;curr_viz_iteration = fdlpcur-&gt;curr_viz_iteration-&gt;next;
195     }
196   }
197   return time_values;
198 }
199 static int output_ascii_molecules(struct volume *world,
200                                   struct viz_output_block *vizblk,
201                                   struct frame_data_list *fdlp) {
202   FILE *custom_file;
203   char *cf_name;
204   struct storage_list *slp;
205   struct schedule_helper *shp;
206   struct abstract_element *aep;
207   struct abstract_molecule *amp;
208   struct volume_molecule *mp;
209   struct surface_molecule *gmp;
210   short orient = 0;
211   int ndigits, i;
212   long long lli;
213   struct vector3 where, norm;
214   no_printf("Output in ASCII mode (molecules only)...\n");
215   if ((fdlp-&gt;type == ALL_MOL_DATA) || (fdlp-&gt;type == MOL_POS)) {
216     lli = 10;
217     for (ndigits = 1; lli &lt;= world-&gt;iterations &amp;&amp; ndigits &lt; 20;
218          lli *= 10, ndigits++) {
219     }
220     cf_name =
221         CHECKED_SPRINTF("%s.ascii.%.*lld.dat", vizblk-&gt;file_prefix_name,
222                         ndigits, fdlp-&gt;viz_iteration);
223     if (cf_name == NULL)
224       return 1;
225     if (make_parent_dir(cf_name)) {
226       free(cf_name);
227       mcell_error(
228           "Failed to create parent directory for ASCII-mode VIZ output.");
229     }
230     custom_file = open_file(cf_name, "w");
231     if (!custom_file)
232       mcell_die();
233     else {
234       no_printf("Writing to file %s\n", cf_name);
235     }
236     free(cf_name);
237     cf_name = NULL;
238     c_vector_t *vec = vector_create();
239     for (slp = world-&gt;storage_head; slp != NULL; slp = slp-&gt;next) {
240       for (shp = slp-&gt;store-&gt;timer; shp != NULL; shp = shp-&gt;next_scale) {
241         for (i = -1; i &lt; shp-&gt;buf_len; i++) {
242           for (aep = (i &lt; 0) ? shp-&gt;current : shp-&gt;circ_buf_head[i];
243                aep != NULL; aep = aep-&gt;next) {
244             amp = (struct abstract_molecule *)aep;
245             if (amp-&gt;properties == NULL)
246               continue;
247             vector_push_back(vec, amp);
248           }
249         }
250       }
251     }
252 #ifdef MCELL3_SORTED_VIZ_OUTPUT
253     vector_sort_by_mol_id(vec);
254 #endif    
255     size_t sz = vector_get_size(vec);
256     for (size_t k = 0; k &lt; sz; k++) {
257       amp = (struct abstract_molecule*)vector_at(vec, k);
258       int id = vizblk-&gt;species_viz_states[amp-&gt;properties-&gt;species_id];
259       if (id == EXCLUDE_OBJ)
260         continue;
261       if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
262         mp = (struct volume_molecule *)amp;
263         where.x = mp-&gt;pos.x;
264         where.y = mp-&gt;pos.y;
265         where.z = mp-&gt;pos.z;
266         norm.x = 0;
267         norm.y = 0;
268         norm.z = 0;
269       } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
270         gmp = (struct surface_molecule *)amp;
271         uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
272         orient = gmp-&gt;orient;
273         norm.x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
274         norm.y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
275         norm.z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
276       } else
277         continue;
278       where.x *= world-&gt;length_unit;
279       where.y *= world-&gt;length_unit;
280       where.z *= world-&gt;length_unit;
281       std::string species_name = amp-&gt;properties-&gt;sym-&gt;name;
282       #ifdef ASCII_VIZ_EXTERNAL_SPECIES_NAME
283         if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
284           species_name = graph_pattern_to_bngl(amp-&gt;graph_data-&gt;graph_pattern);
285         }
286       #endif
287       if (id == INCLUDE_OBJ) {
288         fprintf(custom_file, "%s %lu %.9g %.9g %.9g %.9g %.9g %.9g\n",
289                 species_name.c_str(), amp-&gt;id, where.x, where.y,
290                 where.z, norm.x, norm.y, norm.z);
291       } else {
292         fprintf(custom_file, "%d %lu %.9g %.9g %.9g %.9g %.9g %.9g\n", id,
293                 amp-&gt;id, where.x, where.y, where.z, norm.x, norm.y,
294                 norm.z);
295       }
296     }
297     vector_delete(vec);
298     fclose(custom_file);
299   }
300   return 0;
301 }
302 typedef struct external_mol_viz_struct {
303   char mol_type;    float pos_x, pos_y, pos_z;
304   float norm_x, norm_y, norm_z;
305   struct external_mol_viz_struct *next_mol;
306 } external_mol_viz;
307 typedef struct external_mol_viz_by_name_struct {
308   char *mol_name;
309   external_mol_viz *mol_list;
310   struct external_mol_viz_by_name_struct *next_name;
311 } external_mol_viz_by_name;
312 typedef struct external_mol_viz_entry_struct {
313   char *mol_id_string;  } external_mol_viz_entry;
314 static struct sym_table_head *graph_pattern_table = NULL;
315 static long next_molcomp_id = 0L;
316 typedef struct external_molcomp_loc_struct {
317   bool is_mol;
318   bool has_coords;
319   bool is_final;
320   double x, y, z;
321   double kx, ky, kz;
322   char *name;
323   char *graph_string;
324   int num_peers;
325   int *peers;
326   char *states;
327 } external_molcomp_loc;
328 typedef struct molcomp_list_struct {
329   external_molcomp_loc *molcomp_array;
330   int num_molcomp_items;
331   long molcomp_id;
332 } molcomp_list;
333 static void dump_molcomp_array_to ( FILE *out_file, external_molcomp_loc *molcomp_array, int num_parts ) {
334   int i, j;
335   fprintf ( out_file, "%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%\n" );
336   for (i=0; i&lt;num_parts; i++) {
337     fprintf ( out_file, "[%d] = %s (", i, molcomp_array[i].name );
338     if (molcomp_array[i].is_mol) {
339       fprintf ( out_file, "m" );
340     } else {
341       fprintf ( out_file, "c" );
342     }
343     fprintf ( out_file, ") at  (%g, %g, %g) with peers [", molcomp_array[i].x, molcomp_array[i].y, molcomp_array[i].z );
344     for (j=0; j&lt;molcomp_array[i].num_peers; j++) {
345       fprintf ( out_file, "%d", molcomp_array[i].peers[j] );
346       if (j &lt; molcomp_array[i].num_peers - 1) {
347         fprintf ( out_file, "," );
348       }
349     }
350     fprintf ( out_file, "]\n" );
351   }
352   fprintf ( out_file, "%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%\n" );
353 }
354 static void dump_molcomp_list_to ( FILE *out_file, molcomp_list *mcl ) {
355   fprintf ( out_file, "ID=%ld\n", mcl-&gt;molcomp_id );
356   dump_molcomp_array_to ( out_file, mcl-&gt;molcomp_array, mcl-&gt;num_molcomp_items );
357 }
358 static void dump_molcomp_array ( external_molcomp_loc *molcomp_array, int num_parts ) {
359   dump_molcomp_array_to ( stdout, molcomp_array, num_parts );
360 }
361 double clipped_cos ( double angle ) {
362   double v = cos(angle);
363   if ((v &gt; -1e-6) &amp;&amp; (v &lt; 1e-6)) v = 0;
364   return ( v );
365 }
366 double clipped_sin ( double angle ) {
367   double v = sin(angle);
368   if ((v &gt; -1e-6) &amp;&amp; (v &lt; 1e-6)) v = 0;
369   return ( v );
370 }
371 static void set_component_positions_by_table ( struct volume *world, external_molcomp_loc *mc, int num_parts ) {
372   double scale = 0.02;
373   int mi;
374   for (mi=0; mi&lt;num_parts; mi++) {
375     if (mc[mi].is_mol) {
376       struct sym_entry *sp;
377       sp = retrieve_sym(mc[mi].name, world-&gt;mol_ss_sym_table);
378       if (sp != NULL) {
379         if (sp-&gt;sym_type == MOL_SS) {
380           for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
381             mc[mc[mi].peers[ci]].has_coords = false;
382           }
383           struct mol_ss *mol_ss_ptr = (struct mol_ss *)(sp-&gt;value);
384           struct mol_comp_ss *mc_ptr = mol_ss_ptr-&gt;mol_comp_ss_head;
385           int comp_count = 0;
386           while (mc_ptr != NULL) {
387             for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
388               if ( (!mc[mc[mi].peers[ci]].has_coords) &amp;&amp; (strcmp(mc[mc[mi].peers[ci]].name, mc_ptr-&gt;name) == 0) ) {
389                 mc[mc[mi].peers[ci]].x = mc_ptr-&gt;loc_x;
390                 mc[mc[mi].peers[ci]].y = mc_ptr-&gt;loc_y;
391                 mc[mc[mi].peers[ci]].z = mc_ptr-&gt;loc_z;
392                 mc[mc[mi].peers[ci]].kx = mc_ptr-&gt;rot_axis_x;                  mc[mc[mi].peers[ci]].ky = mc_ptr-&gt;rot_axis_y;                  mc[mc[mi].peers[ci]].kz = mc_ptr-&gt;rot_axis_z;                  mc[mc[mi].peers[ci]].has_coords = true;
393                 if (world-&gt;dump_level &gt;= 20) {
394                   fprintf ( stdout, "    Component %s is at (%g,%g,%g)\n", mc[mc[mi].peers[ci]].name, mc[mc[mi].peers[ci]].x, mc[mc[mi].peers[ci]].y, mc[mc[mi].peers[ci]].z );
395                   fprintf ( stdout, "       Ref key for %s is at (%g,%g,%g)\n", mc[mc[mi].peers[ci]].name, mc[mc[mi].peers[ci]].kx, mc[mc[mi].peers[ci]].ky, mc[mc[mi].peers[ci]].kz );
396                 }
397                 break;
398               }
399             }
400             comp_count += 1;
401             mc_ptr = mc_ptr-&gt;next;
402           }
403           for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
404             if (!mc[mc[mi].peers[ci]].has_coords) {
405               mc[mc[mi].peers[ci]].x = 0.0;
406               mc[mc[mi].peers[ci]].y = 0.0;
407               mc[mc[mi].peers[ci]].z = 0.0;
408               mc[mc[mi].peers[ci]].kx = 0.0;
409               mc[mc[mi].peers[ci]].ky = 0.0;
410               mc[mc[mi].peers[ci]].kz = 0.0;
411               mc[mc[mi].peers[ci]].has_coords = true;
412             }
413           }
414         }
415       } else {
416         fprintf ( stdout, "    No entry found for %s, using default. This is unexpected!!\n", mc[mi].name );
417         for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
418           double angle = 2 * MY_PI * ci / mc[mi].num_peers;
419           mc[mc[mi].peers[ci]].x = scale * cos(angle);
420           mc[mc[mi].peers[ci]].y = scale * sin(angle);
421           mc[mc[mi].peers[ci]].z = 0.0;
422           mc[mc[mi].peers[ci]].kx = 0.0;
423           mc[mc[mi].peers[ci]].ky = 0.0;
424           mc[mc[mi].peers[ci]].kz = scale;
425         }
426       }
427     }
428   }
429 }
430 static void bind_molecules_at_components ( struct volume *world, external_molcomp_loc *mc, int num_parts, int fixed_comp_index, int var_comp_index, bool as3D, bool with_rot ) {
431   int fixed_mol_index = mc[fixed_comp_index].peers[0];
432   int var_mol_index = mc[var_comp_index].peers[0];
433   double fixed_vec[3] = {0, 0, 0};    double   var_vec[3] = {0, 0, 0};
434   fixed_vec[0] = mc[fixed_comp_index].x - mc[fixed_mol_index].x;
435   fixed_vec[1] = mc[fixed_comp_index].y - mc[fixed_mol_index].y;
436   var_vec[0]   = mc[  var_comp_index].x - mc[  var_mol_index].x;
437   var_vec[1]   = mc[  var_comp_index].y - mc[  var_mol_index].y;
438   if (as3D) {
439     fixed_vec[2] = mc[fixed_comp_index].z - mc[fixed_mol_index].z;
440     var_vec[2]   = mc[  var_comp_index].z - mc[  var_mol_index].z;
441   }
442   double fixed_mag;
443   double   var_mag;
444   if (as3D) {
445     fixed_mag = sqrt ( (fixed_vec[0]*fixed_vec[0]) + (fixed_vec[1]*fixed_vec[1]) + (fixed_vec[2]*fixed_vec[2]) );
446       var_mag = sqrt ( (  var_vec[0]*  var_vec[0]) + (  var_vec[1]*  var_vec[1]) + (  var_vec[2]*  var_vec[2]) );
447   } else {
448     fixed_mag = sqrt ( (fixed_vec[0]*fixed_vec[0]) + (fixed_vec[1]*fixed_vec[1]) );
449       var_mag = sqrt ( (  var_vec[0]*  var_vec[0]) + (  var_vec[1]*  var_vec[1]) );
450   }
451   if ((fixed_mag * var_mag) == 0) {
452     if (world-&gt;dump_level &gt;= 10) {
453       fprintf ( stdout, "Molecules %s and %s are nonspatially bound.\n", mc[fixed_comp_index].name, mc[var_comp_index].name );
454     }
455     return;
456   }
457   double dot_prod;
458   if (as3D) {
459     dot_prod = (fixed_vec[0] * var_vec[0]) + (fixed_vec[1] * var_vec[1]) + (fixed_vec[2] * var_vec[2]);
460   } else {
461     dot_prod = (fixed_vec[0] * var_vec[0]) + (fixed_vec[1] * var_vec[1]);
462   }
463   double norm_dot_prod = dot_prod / ( fixed_mag * var_mag );
464   if (norm_dot_prod &gt;  1) { norm_dot_prod =  1; }
465   if (norm_dot_prod &lt; -1) { norm_dot_prod = -1; }
466   double angle = acos ( norm_dot_prod );
467   if (as3D) {
468     angle = -angle;
469   } else {
470     if ( ( (fixed_vec[0] * var_vec[1]) - (fixed_vec[1] * var_vec[0]) ) &gt; 0 ) {
471       angle = -angle;
472     }
473   }
474   angle = MY_PI + angle;
475   while (angle &gt; MY_PI) {
476     angle = angle - (2 * MY_PI);
477   }
478   while (angle &lt;= -MY_PI) {
479     angle = angle + (2 * MY_PI);
480   }
481   double cos_angle = cos(angle);
482   double sin_angle = sin(angle);
483   if (as3D) {
484     double cross_prod[3];
485     cross_prod[0] = (fixed_vec[1] * var_vec[2]) - (fixed_vec[2] * var_vec[1]);
486     cross_prod[1] = (fixed_vec[2] * var_vec[0]) - (fixed_vec[0] * var_vec[2]);
487     cross_prod[2] = (fixed_vec[0] * var_vec[1]) - (fixed_vec[1] * var_vec[0]);
488     double xpx, xpy, xpz;
489     xpx = cross_prod[0] / (fixed_mag * var_mag);
490     xpy = cross_prod[1] / (fixed_mag * var_mag);
491     xpz = cross_prod[2] / (fixed_mag * var_mag);
492     double axis_length = sqrt ( (xpx*xpx) + (xpy*xpy) + (xpz*xpz) );
493     double R[3][3] = { { 1, 0, 0 },
494                        { 0, 1, 0 },
495                        { 0, 0, 1 } };
496     if (axis_length &lt; 1e-30) {
497       if (norm_dot_prod &lt; 0) {
498       } else {
499         for (int i=0; i&lt;3; i++) {
500           R[i][i] = -1;
501         }
502       }
503     } else {
504       double ux = xpx / axis_length;
505       double uy = xpy / axis_length;
506       double uz = xpz / axis_length;
507       double omca = 1 - cos_angle;
508       R[0][0] = cos_angle + (ux*ux*omca);
509       R[0][1] = (ux*uy*omca) - (uz*sin_angle);
510       R[0][2] = (ux*uz*omca) + (uy*sin_angle);
511       R[1][0] = (uy*ux*omca) + (uz*sin_angle);
512       R[1][1] = cos_angle + (uy*uy*omca);
513       R[1][2] = (uy*uz*omca) - (ux*sin_angle);
514       R[2][0] = (uz*ux*omca) - (uy*sin_angle);
515       R[2][1] = (uz*uy*omca) + (ux*sin_angle);
516       R[2][2] = cos_angle + (uz*uz*omca);
517     }
518     for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
519       double x = mc[mc[var_mol_index].peers[ci]].x;
520       double y = mc[mc[var_mol_index].peers[ci]].y;
521       double z = mc[mc[var_mol_index].peers[ci]].z;
522       mc[mc[var_mol_index].peers[ci]].x = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z);
523       mc[mc[var_mol_index].peers[ci]].y = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z);
524       mc[mc[var_mol_index].peers[ci]].z = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z);
525       x = mc[mc[var_mol_index].peers[ci]].kx;
526       y = mc[mc[var_mol_index].peers[ci]].ky;
527       z = mc[mc[var_mol_index].peers[ci]].kz;
528       mc[mc[var_mol_index].peers[ci]].kx = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z);
529       mc[mc[var_mol_index].peers[ci]].ky = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z);
530       mc[mc[var_mol_index].peers[ci]].kz = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z);
531     }
532   } else {
533     for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
534       double x = mc[mc[var_mol_index].peers[ci]].x;
535       double y = mc[mc[var_mol_index].peers[ci]].y;
536       mc[mc[var_mol_index].peers[ci]].x = (x * cos_angle) - (y * sin_angle);
537       mc[mc[var_mol_index].peers[ci]].y = (x * sin_angle) + (y * cos_angle);
538     }
539   }
540   if ( as3D &amp;&amp; with_rot) {
541     double fixed_req_bond_angle = world-&gt;bond_angle / 2;     double var_req_bond_angle = world-&gt;bond_angle / 2;   
542     double fvc[3];
543     fvc[0] = mc[fixed_comp_index].x - mc[fixed_mol_index].x;
544     fvc[1] = mc[fixed_comp_index].y - mc[fixed_mol_index].y;
545     fvc[2] = mc[fixed_comp_index].z - mc[fixed_mol_index].z;
546     double vvc[3];
547     vvc[0] = mc[var_comp_index].x - mc[var_mol_index].x;
548     vvc[1] = mc[var_comp_index].y - mc[var_mol_index].y;
549     vvc[2] = mc[var_comp_index].z - mc[var_mol_index].z;
550     double fvk[3];
551     fvk[0] = mc[fixed_comp_index].kx - mc[fixed_mol_index].x;
552     fvk[1] = mc[fixed_comp_index].ky - mc[fixed_mol_index].y;
553     fvk[2] = mc[fixed_comp_index].kz - mc[fixed_mol_index].z;
554     double vvk[3];
555     vvk[0] = mc[var_comp_index].kx - mc[var_mol_index].x;
556     vvk[1] = mc[var_comp_index].ky - mc[var_mol_index].y;
557     vvk[2] = mc[var_comp_index].kz - mc[var_mol_index].z;
558     if (world-&gt;dump_level &gt;= 20) {
559       fprintf ( stdout, "  Fixed vcomp = [ %g %g %g ]\n", fvc[0], fvc[1], fvc[2] );
560       fprintf ( stdout, "  Var   vcomp = [ %g %g %g ]\n", vvc[0], vvc[1], vvc[2] );
561       fprintf ( stdout, "  Fixed vkey  = [ %g %g %g ]\n", fvk[0], fvk[1], fvk[2] );
562       fprintf ( stdout, "  Var vkey    = [ %g %g %g ]\n", vvk[0], vvk[1], vvk[2] );
563     }
564     double fixed_normal[3];
565     fixed_normal[0] = (fvc[1] * fvk[2]) - (fvc[2] * fvk[1]);
566     fixed_normal[1] = (fvc[2] * fvk[0]) - (fvc[0] * fvk[2]);
567     fixed_normal[2] = (fvc[0] * fvk[1]) - (fvc[1] * fvk[0]);
568     double var_normal[3];
569     var_normal[0] = (vvc[1] * vvk[2]) - (vvc[2] * vvk[1]);
570     var_normal[1] = (vvc[2] * vvk[0]) - (vvc[0] * vvk[2]);
571     var_normal[2] = (vvc[0] * vvk[1]) - (vvc[1] * vvk[0]);
572     double fixed_norm_mag = sqrt ( (fixed_normal[0]*fixed_normal[0]) + (fixed_normal[1]*fixed_normal[1]) + (fixed_normal[2]*fixed_normal[2]) );
573     double var_norm_mag   = sqrt ( (  var_normal[0]*  var_normal[0]) + (  var_normal[1]*  var_normal[1]) + (  var_normal[2]*  var_normal[2]) );
574     double fixed_unit[3];
575     fixed_unit[0] = fixed_normal[0] / fixed_norm_mag;
576     fixed_unit[1] = fixed_normal[1] / fixed_norm_mag;
577     fixed_unit[2] = fixed_normal[2] / fixed_norm_mag;
578     double var_unit[3];
579     var_unit[0] = var_normal[0] / var_norm_mag;
580     var_unit[1] = var_normal[1] / var_norm_mag;
581     var_unit[2] = var_normal[2] / var_norm_mag;
582     if (world-&gt;dump_level &gt;= 20) {
583       fprintf ( stdout, "  Fixed unit = [ %g %g %g ]\n", fixed_unit[0], fixed_unit[1], fixed_unit[2] );
584       fprintf ( stdout, "  Var unit = [ %g %g %g ]\n", var_unit[0], var_unit[1], var_unit[2] );
585     }
586     double norm_dot_prod_again;
587     norm_dot_prod_again = (fixed_unit[0] * var_unit[0]) + (fixed_unit[1] * var_unit[1]) + (fixed_unit[2] * var_unit[2]);
588     if (norm_dot_prod_again &gt;  1) {
589       if (world-&gt;dump_level &gt;= 20) {
590         fprintf ( stdout, "Numerical Warning: normalized dot product %g was greater than 1\n", norm_dot_prod_again );
591       }
592       norm_dot_prod_again =  1;
593     }
594     if (norm_dot_prod_again &lt; -1) {
595       if (world-&gt;dump_level &gt;= 20) {
596         fprintf ( stdout, "Numerical Warning: normalized dot product %g was less than -1\n", norm_dot_prod_again );
597       }
598       norm_dot_prod_again = -1;
599     }
600     if (world-&gt;dump_level &gt;= 20) {
601       fprintf ( stdout, "  Normalized Dot Product between fixed and var is %g\n", norm_dot_prod_again );
602     }
603     double cur_key_plane_angle = acos ( norm_dot_prod_again );
604     if (world-&gt;dump_level &gt;= 20) {
605       fprintf ( stdout, "Current key plane angle = %g\n", (180*cur_key_plane_angle/MY_PI) );
606     }
607     double cross_prod[3];
608     cross_prod[0] = (fixed_unit[1] * var_unit[2]) - (fixed_unit[2] * var_unit[1]);
609     cross_prod[1] = (fixed_unit[2] * var_unit[0]) - (fixed_unit[0] * var_unit[2]);
610     cross_prod[2] = (fixed_unit[0] * var_unit[1]) - (fixed_unit[1] * var_unit[0]);
611     double dot_cross_rot = (cross_prod[0] * vvc[0]) + (cross_prod[1] * vvc[1]) + (cross_prod[2] * vvc[2]);
612     if (dot_cross_rot &gt; 0) {
613       cur_key_plane_angle = (2*MY_PI) - cur_key_plane_angle;
614     }
615     if (world-&gt;dump_level &gt;= 20) {
616       fprintf ( stdout, "Current key plane angle = %g,  dot_cross_rot = %g\n", (180*cur_key_plane_angle/MY_PI), dot_cross_rot );
617     }
618     double composite_rot_angle = MY_PI + (var_req_bond_angle+fixed_req_bond_angle) + cur_key_plane_angle;  
619     if (world-&gt;dump_level &gt;= 20) {
620       fprintf ( stdout, "  Fixed angle                is = %g degrees\n", 180 * fixed_req_bond_angle / MY_PI );
621       fprintf ( stdout, "  Var angle                  is = %g degrees\n", 180 * var_req_bond_angle / MY_PI );
622       fprintf ( stdout, "  Current angle between keys is = %g degrees\n", 180 * cur_key_plane_angle / MY_PI );
623       fprintf ( stdout, "  Composite rotation angle   is = %g degrees\n", 180 * composite_rot_angle / MY_PI );
624     }
625     double var_vcomp_mag = sqrt ( (vvc[0]*vvc[0]) + (vvc[1]*vvc[1]) + (vvc[2]*vvc[2]) );
626     double var_rot_unit[3];
627     var_rot_unit[0] = vvc[0] / var_vcomp_mag;
628     var_rot_unit[1] = vvc[1] / var_vcomp_mag;
629     var_rot_unit[2] = vvc[2] / var_vcomp_mag;
630     double ux = var_rot_unit[0];
631     double uy = var_rot_unit[1];
632     double uz = var_rot_unit[2];
633     double cca = cos(composite_rot_angle);
634     double sca = sin(composite_rot_angle);
635     double omcca = 1 - cca;
636     double R[3][3] = { { 1, 0, 0 },
637                        { 0, 1, 0 },
638                        { 0, 0, 1 } };
639     R[0][0] = cca + (ux*ux*omcca);
640     R[0][1] = (ux*uy*omcca) - (uz*sca);
641     R[0][2] = (ux*uz*omcca) + (uy*sca);
642     R[1][0] = (uy*ux*omcca) + (uz*sca);
643     R[1][1] = cca + (uy*uy*omcca);
644     R[1][2] = (uy*uz*omcca) - (ux*sca);
645     R[2][0] = (uz*ux*omcca) - (uy*sca);
646     R[2][1] = (uz*uy*omcca) + (ux*sca);
647     R[2][2] = cca + (uz*uz*omcca);
648     for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
649       double x = mc[mc[var_mol_index].peers[ci]].x - mc[var_mol_index].x;
650       double y = mc[mc[var_mol_index].peers[ci]].y - mc[var_mol_index].y;
651       double z = mc[mc[var_mol_index].peers[ci]].z - mc[var_mol_index].z;
652       mc[mc[var_mol_index].peers[ci]].x = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z) + mc[var_mol_index].x;
653       mc[mc[var_mol_index].peers[ci]].y = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z) + mc[var_mol_index].y;
654       mc[mc[var_mol_index].peers[ci]].z = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z) + mc[var_mol_index].z;
655       x = mc[mc[var_mol_index].peers[ci]].kx - mc[var_mol_index].x;
656       y = mc[mc[var_mol_index].peers[ci]].ky - mc[var_mol_index].y;
657       z = mc[mc[var_mol_index].peers[ci]].kz - mc[var_mol_index].z;
658       mc[mc[var_mol_index].peers[ci]].kx = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z) + mc[var_mol_index].x;
659       mc[mc[var_mol_index].peers[ci]].ky = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z) + mc[var_mol_index].y;
660       mc[mc[var_mol_index].peers[ci]].kz = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z) + mc[var_mol_index].z;
661     }
662   }
663   double dx = mc[fixed_comp_index].x - mc[var_comp_index].x;
664   double dy = mc[fixed_comp_index].y - mc[var_comp_index].y;
665   double dz = mc[fixed_comp_index].z - mc[var_comp_index].z;
666   mc[var_mol_index].x += dx;
667   mc[var_mol_index].y += dy;
668   mc[var_mol_index].z += dz;
669   for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
670     mc[mc[var_mol_index].peers[ci]].x += dx;
671     mc[mc[var_mol_index].peers[ci]].y += dy;
672     mc[mc[var_mol_index].peers[ci]].z += dz;
673     mc[mc[var_mol_index].peers[ci]].kx += dx;
674     mc[mc[var_mol_index].peers[ci]].ky += dy;
675     mc[mc[var_mol_index].peers[ci]].kz += dz;
676   }
677 }
678 static void bind_all_molecules ( struct volume *world, external_molcomp_loc *molcomp_array, int num_parts, bool as3D, bool with_rot ) {
679   int mi=0;
680   int pi=0;
681   for (mi=0; mi&lt;num_parts; mi++) {
682     if (molcomp_array[mi].is_mol) break;
683   }
684   if (molcomp_array[mi].is_mol) {
685     molcomp_array[mi].is_final = true;
686     for (int ci=0; ci&lt;molcomp_array[mi].num_peers; ci++) {
687       molcomp_array[molcomp_array[mi].peers[ci]].is_final = true;
688     }
689     int done = 0;
690     while (done == 0) {
691       done = 1;
692       for (mi=0; mi&lt;num_parts; mi++) {
693         if (!molcomp_array[mi].is_mol) {
694           if (molcomp_array[mi].num_peers &gt; 1) {
695             for (int ci=1; ci&lt;molcomp_array[mi].num_peers; ci++) {
696               pi = molcomp_array[mi].peers[ci];                if (molcomp_array[mi].is_final != molcomp_array[pi].is_final) {
697                 done = 0;
698                 int fci, vci;                  int vmi;                  if (molcomp_array[mi].is_final) {
699                   fci = mi;
700                   vci = pi;
701                 } else {
702                   fci = pi;
703                   vci = mi;
704                 }
705                 vmi = molcomp_array[vci].peers[0];
706                 bind_molecules_at_components ( world, molcomp_array, num_parts, fci, vci, as3D, with_rot );
707                 molcomp_array[vmi].is_final = true;
708                 for (int vmici=0; vmici&lt;molcomp_array[vmi].num_peers; vmici++) {
709                   molcomp_array[molcomp_array[vmi].peers[vmici]].is_final = true;
710                 }
711               }
712             }
713           }
714         }
715       }
716     }
717   }
718 }
719 static external_molcomp_loc *build_molcomp_array ( struct volume *world, char **graph_strings ) {
720   int part_num;
721   char *next_part;
722   part_num = 0;
723   next_part = graph_strings[part_num];
724   while (next_part != NULL) {
725     part_num++;
726     next_part = graph_strings[part_num];
727   }
728   external_molcomp_loc *molcomp_loc_array = (external_molcomp_loc *) malloc ( part_num * sizeof(external_molcomp_loc) );
729   part_num = 0;
730   next_part = graph_strings[part_num];
731   while (next_part != NULL) {
732     molcomp_loc_array[part_num].has_coords = 0;
733     molcomp_loc_array[part_num].graph_string = (char *) malloc ( 1 + strlen(next_part) );
734     strcpy ( molcomp_loc_array[part_num].graph_string, next_part );
735     molcomp_loc_array[part_num].x = 0;
736     molcomp_loc_array[part_num].y = 0;
737     molcomp_loc_array[part_num].z = 0;
738     molcomp_loc_array[part_num].states = NULL;
739     if (strstr(next_part,"m:") == next_part) {
740       molcomp_loc_array[part_num].is_mol = 1;
741       if (strchr(next_part,'!') == NULL) {
742         molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
743         strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
744       } else {
745         char *end_point = strchr(next_part,'!');
746         *end_point = '\0';
747         molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
748         strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
749         *end_point = '!';
750       }
751       char *at_sign = strchr(molcomp_loc_array[part_num].name, '@');
752       if (at_sign != NULL) {
753         *at_sign = '\0';
754         char *shorter_name = (char *) malloc ( 1 + strlen(molcomp_loc_array[part_num].name) );
755         strcpy ( shorter_name, molcomp_loc_array[part_num].name );
756         *at_sign = '@';
757         free ( molcomp_loc_array[part_num].name );
758         molcomp_loc_array[part_num].name = shorter_name;
759       }
760       molcomp_loc_array[part_num].num_peers = 0;
761       molcomp_loc_array[part_num].peers = NULL;
762       char *next_excl = strchr(next_part,'!');
763       while (next_excl != NULL) {
764         molcomp_loc_array[part_num].num_peers++;
765         next_excl++;
766         next_excl = strchr(next_excl,'!');
767       }
768       if (molcomp_loc_array[part_num].num_peers &gt; 0) {
769         molcomp_loc_array[part_num].peers = (int *) malloc ( molcomp_loc_array[part_num].num_peers * sizeof(int) );
770         next_excl = strchr(next_part,'!');
771         int peer_num = 0;
772         int comp_index;
773         while (next_excl != NULL) {
774           next_excl++;
775           comp_index = atoi(next_excl);
776           molcomp_loc_array[part_num].peers[peer_num] = comp_index;
777           peer_num++;
778           next_excl = strchr(next_excl,'!');
779         }
780       }
781     } else {
782       molcomp_loc_array[part_num].is_mol = 0;
783       char *first_exc = strchr(next_part,'!');
784       char *first_til = strchr(next_part,'~');
785       char *end_point;
786       char previous_end;
787       if ( (first_exc != NULL) &amp;&amp; (first_til != NULL) ) {
788         if (first_exc &lt; first_til) {
789           end_point = first_exc;
790         } else {
791           end_point = first_til;
792         }
793       } else if (first_exc != NULL) {
794         end_point = first_exc;
795       } else if (first_til != NULL) {
796         end_point = first_til;
797       } else {
798         end_point = strchr(next_part,'\0');
799       }
800       previous_end = *end_point;
801       *end_point = '\0';
802       molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
803       strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
804       *end_point = previous_end;
805       if (first_til != NULL) {
806         if (first_exc != NULL) {
807           end_point = first_exc;
808         } else {
809           end_point = strchr(next_part,'\0');
810         }
811         previous_end = *end_point;
812         *end_point = '\0';
813         molcomp_loc_array[part_num].states = (char *) malloc ( 1 + strlen(first_til) );
814         strcpy ( molcomp_loc_array[part_num].states, first_til );
815         *end_point = previous_end;
816       }
817       molcomp_loc_array[part_num].num_peers = 0;
818       molcomp_loc_array[part_num].peers = NULL;
819       char *next_excl = strchr(next_part,'!');
820       while (next_excl != NULL) {
821         molcomp_loc_array[part_num].num_peers++;
822         next_excl++;
823         next_excl = strchr(next_excl,'!');
824       }
825       if (molcomp_loc_array[part_num].num_peers &gt; 0) {
826         molcomp_loc_array[part_num].peers = (int *) malloc ( molcomp_loc_array[part_num].num_peers * sizeof(int) );
827         next_excl = strchr(next_part,'!');
828         int peer_num = 0;
829         int comp_index;
830         while (next_excl != NULL) {
831           next_excl++;
832           comp_index = atoi(next_excl);
833           molcomp_loc_array[part_num].peers[peer_num] = comp_index;
834           peer_num++;
835           next_excl = strchr(next_excl,'!');
836         }
837       }
838     }
839     part_num++;
840     next_part = graph_strings[part_num];
841   }
842   set_component_positions_by_table ( world, molcomp_loc_array, part_num );
843   bind_all_molecules ( world, molcomp_loc_array, part_num, true, true );
844   if (world-&gt;dump_level &gt;= 20) {
845     fprintf ( stdout, "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Final molcomp_loc_array &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n" );
846     dump_molcomp_array ( molcomp_loc_array, part_num );
847     fprintf ( stdout, "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n" );
848   }
849   return molcomp_loc_array;
850 }
851 static char **get_graph_strings ( char *nauty_string ) {
852   int num_parts;
853   int part_num;
854   char **graph_parts;
855   char *first, *last;
856   part_num = 0;
857   first = nauty_string;
858   last = strchr ( first, ',' );
859   while (last != NULL) {
860     first = last+1;
861     last = strchr ( first, ',' );
862     part_num++;
863   }
864   num_parts = part_num;
865   graph_parts = (char **) malloc ( (num_parts+1) * sizeof(char *) );
866   graph_parts[num_parts] = NULL; 
867   part_num = 0;
868   first = nauty_string;
869   last = strchr ( first, ',' );
870   while (last != NULL) {
871     *last = '\0';
872     char *s = (char *) malloc ( strlen(first) + 1 );
873     strcpy ( s, first );
874     graph_parts[part_num] = s;
875     *last = ',';
876     first = last+1;
877     last = strchr ( first, ',' );
878     part_num++;
879   }
880   return graph_parts;
881 }
882 static void free_graph_parts ( char **graph_parts ) {
883   if (graph_parts != NULL) {
884     int part_num = 0;
885     char *next_part = graph_parts[part_num];
886     while (next_part != NULL) {
887       free ( next_part );
888       part_num++;
889       next_part = graph_parts[part_num];
890     }
891     free ( graph_parts );
892   }
893 }
894 static void end_line_opt_comma ( FILE *space_struct_file, bool add_comma ) {
895   if (add_comma) {
896     fprintf ( space_struct_file, "," );
897   }
898   fprintf ( space_struct_file, "\n" );
899 }
900 static int output_cellblender_molecules(struct volume *world,
901                                         struct viz_output_block *vizblk,
902                                         struct frame_data_list *fdlp) {
903   no_printf("Output in CELLBLENDER mode (molecules only)...\n");
904   if ( (world-&gt;dump_level &gt;= 20) &amp;&amp; (world-&gt;viz_options != VIZ_OPTS_NONE) ) {
905     fprintf ( stdout, "vizblk-&gt;file_prefix_name = \"%s\"\n", vizblk-&gt;file_prefix_name );
906   }
907   if ( (world-&gt;dump_level &gt;= 5) &amp;&amp; (world-&gt;viz_options != VIZ_OPTS_NONE) ) {
908     fprintf ( stdout, "Visualization Options = 0x%lx\n", world-&gt;viz_options );
909     fprintf ( stdout, "Proxy = 0x%lx\n", world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT );
910   }
911   if (world-&gt;dump_level &gt;= 50) {
912     fprintf ( stdout, "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Top of MolViz Output &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n" );
913   }
914   char *file_prefix_no_Scene = NULL;
915   char *file_prefix_usually_Scene = NULL;
916   char *last_sep = strrchr ( vizblk-&gt;file_prefix_name, '/' );
917   file_prefix_usually_Scene = my_strcat ( last_sep+1, NULL );
918   *last_sep = '\0';
919   file_prefix_no_Scene = my_strcat ( vizblk-&gt;file_prefix_name, NULL );
920   *last_sep = '/';
921   if ((fdlp-&gt;type == ALL_MOL_DATA) || (fdlp-&gt;type == MOL_POS)) {
922     long long lli = 10;
923     int ndigits = 1;
924     for (; lli &lt;= world-&gt;iterations &amp;&amp; ndigits &lt; 20;
925          lli *= 10, ndigits++) {
926     }
927     char *cf_name =
928         CHECKED_SPRINTF("%s.cellbin.%.*lld.dat", vizblk-&gt;file_prefix_name,
929                         ndigits, fdlp-&gt;viz_iteration);
930     if (cf_name == NULL)
931       return 1;
932     if (make_parent_dir(cf_name)) {
933       free(cf_name);
934       mcell_error(
935           "Failed to create parent directory for CELLBLENDER-mode VIZ output.");
936     }
937     FILE *custom_file = open_file(cf_name, "wb");
938     if (!custom_file)
939       mcell_die();
940     else {
941       no_printf("Writing to file %s\n", cf_name);
942     }
943     free(cf_name);
944     cf_name = NULL;
945     FILE *space_struct_file = NULL;
946     if (world-&gt;viz_options &amp; VIZ_ALT_FILES_MASK) {
947       if (world-&gt;dump_level &gt;= 20) {
948         fprintf ( stdout, "Spatially Structured Option = 0x%lx\n", world-&gt;viz_options &amp; VIZ_ALT_FILES_MASK );
949       }
950       cf_name =
951           CHECKED_SPRINTF("%s/viz_bngl/%s.bnglviz.%.*lld.dat", file_prefix_no_Scene, file_prefix_usually_Scene,
952                           ndigits, fdlp-&gt;viz_iteration);
953       if (cf_name == NULL)
954         return 1;
955       if (make_parent_dir(cf_name)) {
956         free(cf_name);
957         mcell_error(
958             "Failed to create parent directory for SPATIAL-mode VIZ output.");
959       }
960       space_struct_file = open_file(cf_name, "wb");
961       if (!space_struct_file) {
962         mcell_die();
963       } else {
964         no_printf("Writing to file %s\n", cf_name);
965       }
966       free(cf_name);
967       cf_name = NULL;
968     }
969     u_int *viz_mol_count = NULL;
970     struct abstract_molecule ***viz_molp = NULL;
971     if (sort_molecules_by_species(
972         world, vizblk, &amp;viz_molp, &amp;viz_mol_count, 1, 1)) {
973       fclose(custom_file);
974       custom_file = NULL;
975       return 1;
976     }
977     u_int cellbin_version = 1;
978     fwrite(&amp;cellbin_version, sizeof(cellbin_version), 1, custom_file);
979     for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
980       const unsigned int this_mol_count = viz_mol_count[species_idx];
981       if (this_mol_count == 0)
982         continue;
983       const int id = vizblk-&gt;species_viz_states[species_idx];
984       if (id == EXCLUDE_OBJ)
985         continue;
986       struct abstract_molecule **const mols = viz_molp[species_idx];
987       if (mols == NULL)
988         continue;
989       struct abstract_molecule *amp = mols[0];       if ( (world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT) || ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) == 0) ) {
990         char mol_name[33];
991         if (id == INCLUDE_OBJ) {
992           snprintf(mol_name, 33, "%s", amp-&gt;properties-&gt;sym-&gt;name);
993         } else {
994           snprintf(mol_name, 33, "%d", id);
995         }
996         byte name_len = strlen(mol_name);
997         fwrite(&amp;name_len, sizeof(name_len), 1, custom_file);
998         fwrite(mol_name, sizeof(char), name_len, custom_file);
999         byte species_type = 0;
1000         if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1001           species_type = 1;
1002         }
1003         fwrite(&amp;species_type, sizeof(species_type), 1, custom_file);
1004         u_int n_floats = 3 * this_mol_count;
1005         fwrite(&amp;n_floats, sizeof(n_floats), 1, custom_file);
1006         float pos_x = 0.0;
1007         float pos_y = 0.0;
1008         float pos_z = 0.0;
1009         for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
1010           amp = mols[n_mol];
1011           if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
1012             struct volume_molecule *mp = (struct volume_molecule *)amp;
1013             struct vector3 pos_output = {0.0, 0.0, 0.0};
1014             if (!convert_relative_to_abs_PBC_coords(
1015                 world-&gt;periodic_box_obj,
1016                 mp-&gt;periodic_box,
1017                 world-&gt;periodic_traditional,
1018                 &amp;mp-&gt;pos,
1019                 &amp;pos_output)) {
1020               pos_x = pos_output.x;
1021               pos_y = pos_output.y;
1022               pos_z = pos_output.z;
1023             }
1024             else {
1025               pos_x = mp-&gt;pos.x;
1026               pos_y = mp-&gt;pos.y;
1027               pos_z = mp-&gt;pos.z;
1028             }
1029           } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1030             struct surface_molecule *gmp = (struct surface_molecule *)amp;
1031             struct vector3 where;
1032             uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
1033             struct vector3 pos_output = {0.0, 0.0, 0.0};
1034             if (!convert_relative_to_abs_PBC_coords(
1035                 world-&gt;periodic_box_obj,
1036                 gmp-&gt;periodic_box,
1037                 world-&gt;periodic_traditional,
1038                 &amp;where,
1039                 &amp;pos_output)) {
1040               pos_x = pos_output.x;
1041               pos_y = pos_output.y;
1042               pos_z = pos_output.z;
1043             }
1044             else {
1045               pos_x = where.x;
1046               pos_y = where.y;
1047               pos_z = where.z;
1048             }
1049           }
1050           pos_x *= world-&gt;length_unit;
1051           pos_y *= world-&gt;length_unit;
1052           pos_z *= world-&gt;length_unit;
1053           fwrite(&amp;pos_x, sizeof(pos_x), 1, custom_file);
1054           fwrite(&amp;pos_y, sizeof(pos_y), 1, custom_file);
1055           fwrite(&amp;pos_z, sizeof(pos_z), 1, custom_file);
1056         }
1057         amp = mols[0];
1058         if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1059           for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
1060             struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
1061             short orient = gmp-&gt;orient;
1062             float norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
1063 <a name="0"></a>            float norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
1064             float norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
1065 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            if (world-&gt;periodic_box_obj &amp;&amp; !(world-&gt;periodic_traditional)) {
1066               if (gmp-&gt;periodic_box-&gt;x % 2 != 0) {
1067                 norm_x *= -1;
1068               }
1069               if (gmp-&gt;periodic_box-&gt;y % 2 != 0) {
1070                 norm_y *= -1;
1071               }
1072               if (gmp-&gt;periodic_box-&gt;z % 2 != 0) {
1073                 norm_z *= -1;
1074               }
1075             }</b></font>
1076             fwrite(&amp;norm_x, sizeof(norm_x), 1, custom_file);
1077             fwrite(&amp;norm_y, sizeof(norm_y), 1, custom_file);
1078             fwrite(&amp;norm_z, sizeof(norm_z), 1, custom_file);
1079           }
1080         }
1081       }
1082     } 
1083     external_mol_viz_by_name *mol_name_list = NULL;
1084     for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
1085       const unsigned int this_mol_count = viz_mol_count[species_idx];
1086       if (this_mol_count == 0)
1087         continue;
1088       const int id = vizblk-&gt;species_viz_states[species_idx];
1089       if (id == EXCLUDE_OBJ)
1090         continue;
1091       struct abstract_molecule **const mols = viz_molp[species_idx];
1092       if (mols == NULL)
1093         continue;
1094       struct abstract_molecule *amp;
1095       amp = mols[0];
1096       char mol_name[33];
1097       if (id == INCLUDE_OBJ) {
1098         snprintf(mol_name, 33, "%s", amp-&gt;properties-&gt;sym-&gt;name);
1099       } else {
1100         snprintf(mol_name, 33, "%d", id);
1101       }
1102       for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
1103         amp = mols[n_mol];
1104         float pos_x = 0.0;
1105         float pos_y = 0.0;
1106         float pos_z = 0.0;
1107         float norm_x = 0.0;
1108         float norm_y = 0.0;
1109         float norm_z = 0.0;
1110         if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
1111           struct volume_molecule *mp = (struct volume_molecule *)amp;
1112           pos_x = mp-&gt;pos.x;
1113           pos_y = mp-&gt;pos.y;
1114           pos_z = mp-&gt;pos.z;
1115         } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1116           struct surface_molecule *gmp = (struct surface_molecule *)amp;
1117           struct vector3 where;
1118           uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
1119           pos_x = where.x;
1120           pos_y = where.y;
1121           pos_z = where.z;
1122         }
1123         pos_x *= world-&gt;length_unit;
1124         pos_y *= world-&gt;length_unit;
1125         pos_z *= world-&gt;length_unit;
1126         char mol_type = 'v';
1127         if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1128           mol_type = 's';
1129           struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
1130           short orient = gmp-&gt;orient;
1131           norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
1132           norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
1133           norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
1134         }
1135         float x_offset = 0.0;
1136         if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
1137           char *next_mol = amp-&gt;graph_data-&gt;graph_pattern;
1138           if (graph_pattern_table == NULL) {
1139             graph_pattern_table = init_symtab ( 10 );
1140           }
1141           struct sym_entry *sp;
1142           sp = retrieve_sym(next_mol, graph_pattern_table);
1143           if (sp == NULL) {
1144             char **graph_parts = get_graph_strings ( next_mol );
1145             if (world-&gt;dump_level &gt;= 10) {
1146               fprintf ( stdout, "=#= New Graph Pattern: %s\n", next_mol );
1147             }
1148             int num_parts = 0;
1149             char *next_part = graph_parts[num_parts];
1150             while (next_part != NULL) {
1151               if (world-&gt;dump_level &gt;= 20) {
1152                 fprintf ( stdout, "  Graph Part %d: %s\n", num_parts, next_part );
1153               }
1154               num_parts++;
1155               next_part = graph_parts[num_parts];
1156             }
1157             external_molcomp_loc *molcomp_array = build_molcomp_array ( world, graph_parts );
1158             if (world-&gt;dump_level &gt;= 10) {
1159               fprintf ( stdout, "=============== molcomp_array ===============\n" );
1160               dump_molcomp_array ( molcomp_array, num_parts );
1161               fprintf ( stdout, "=============================================\n" );
1162             }
1163             molcomp_list *mcl = (molcomp_list *) malloc ( sizeof(molcomp_list) );
1164             mcl-&gt;molcomp_array = molcomp_array;
1165             mcl-&gt;num_molcomp_items = num_parts;
1166             mcl-&gt;molcomp_id = next_molcomp_id;
1167             next_molcomp_id += 1;
1168             sp = store_sym ( next_mol, VOID_PTR, graph_pattern_table, mcl );
1169             free_graph_parts ( graph_parts );
1170           }
1171           molcomp_list *mcl = NULL;
1172           if (sp != NULL) {
1173             mcl = (molcomp_list *) sp-&gt;value;
1174             int part_num;
1175             for (part_num = 0; part_num&lt;mcl-&gt;num_molcomp_items; part_num++) {
1176               if ( mcl-&gt;molcomp_array[part_num].is_mol == false ) {
1177                 if ((mcl-&gt;molcomp_array[part_num].x==0) &amp;&amp; (mcl-&gt;molcomp_array[part_num].y==0) &amp;&amp; (mcl-&gt;molcomp_array[part_num].z==0) ) {
1178                   mcl = NULL;
1179                   break;
1180                 }
1181               }
1182             }
1183           }
1184           if (mcl != NULL) {
1185             int part_num;
1186             for (part_num = 0; part_num&lt;mcl-&gt;num_molcomp_items; part_num++) {
1187               if ( mcl-&gt;molcomp_array[part_num].is_mol || (world-&gt;viz_options!=VIZ_OPTS_NONE) ) {
1188                 char *name_to_find_or_add = NULL;
1189                 if (mcl-&gt;molcomp_array[part_num].is_mol) {
1190                   name_to_find_or_add = (char *) malloc (1+strlen(mcl-&gt;molcomp_array[part_num].name));
1191                   strcpy ( name_to_find_or_add, mcl-&gt;molcomp_array[part_num].name );
1192                 } else {
1193                   int viz_naming_bits = world-&gt;viz_options &amp; VIZ_COMP_NAMING_MASK;
1194                   if (viz_naming_bits == VIZ_COMP_ALL_SAME) {
1195                     name_to_find_or_add = (char *) malloc (1+strlen("component"));
1196                     strcpy ( name_to_find_or_add, "component" );
1197                   } else if (viz_naming_bits == VIZ_COMP_NAME_GLOBAL) {
1198                     name_to_find_or_add = (char *) malloc (1+strlen("comp_")+strlen(mcl-&gt;molcomp_array[part_num].name));
1199                     strcpy ( name_to_find_or_add, "comp_" );
1200                     strcpy ( &amp;name_to_find_or_add[strlen("comp_")], mcl-&gt;molcomp_array[part_num].name );
1201                   } else if (viz_naming_bits == VIZ_COMP_MOL_LOCAL) {
1202                     char *last_mol_name = NULL;
1203                     if (mcl-&gt;molcomp_array[part_num].num_peers &lt; 1) {
1204                       last_mol_name = (char *) malloc (1+strlen("unknown_"));
1205                       strcpy ( last_mol_name, "unknown_" );
1206                     } else {
1207                       char *name_ptr = mcl-&gt;molcomp_array[mcl-&gt;molcomp_array[part_num].peers[0]].name;
1208                       last_mol_name = (char *) malloc (1+strlen(name_ptr));
1209                       strcpy ( last_mol_name, name_ptr );
1210                     }
1211                     name_to_find_or_add = (char *) malloc (1+strlen(last_mol_name)+strlen("_comp_")+strlen(mcl-&gt;molcomp_array[part_num].name));
1212                     strcpy ( name_to_find_or_add,                               last_mol_name );
1213                     strcpy ( &amp;name_to_find_or_add[strlen(name_to_find_or_add)], "_comp_" );
1214                     strcpy ( &amp;name_to_find_or_add[strlen(name_to_find_or_add)], mcl-&gt;molcomp_array[part_num].name );
1215                     if (last_mol_name != NULL) {
1216                       free ( last_mol_name );
1217                     }
1218                   }
1219                 }
1220                 external_mol_viz_by_name *next_mol_name = mol_name_list;
1221                 int found = 0;
1222                 do {
1223                   if (next_mol_name == NULL) {
1224                     break;
1225                   }
1226                   if (strcmp(name_to_find_or_add, next_mol_name-&gt;mol_name) == 0) {
1227                     found = 1;
1228                     break;
1229                   }
1230                   next_mol_name = next_mol_name-&gt;next_name;
1231                 } while ( found == 0 );
1232                 if (found == 0) {
1233                   next_mol_name = (external_mol_viz_by_name *) malloc ( sizeof(external_mol_viz_by_name) );
1234                   next_mol_name-&gt;mol_name = name_to_find_or_add;                    next_mol_name-&gt;mol_list = NULL;
1235                   next_mol_name-&gt;next_name = mol_name_list;
1236                   mol_name_list = next_mol_name;
1237                 } else {
1238                   if (name_to_find_or_add != NULL) {
1239                     free ( name_to_find_or_add );
1240                     name_to_find_or_add = NULL;
1241                   }
1242                 }
1243 						    external_mol_viz *new_mol_viz_item = (external_mol_viz *) malloc ( sizeof(external_mol_viz) );
1244                 new_mol_viz_item-&gt;mol_type = mol_type;
1245                 new_mol_viz_item-&gt;pos_x = pos_x + mcl-&gt;molcomp_array[part_num].x;
1246                 new_mol_viz_item-&gt;pos_y = pos_y + mcl-&gt;molcomp_array[part_num].y;
1247                 new_mol_viz_item-&gt;pos_z = pos_z + mcl-&gt;molcomp_array[part_num].z;
1248                 new_mol_viz_item-&gt;norm_x = norm_x;
1249                 new_mol_viz_item-&gt;norm_y = norm_y;
1250                 new_mol_viz_item-&gt;norm_z = norm_z;
1251                 new_mol_viz_item-&gt;next_mol = next_mol_name-&gt;mol_list;
1252                 next_mol_name-&gt;mol_list = new_mol_viz_item;
1253                 next_mol += 1;
1254               }
1255             }
1256           } else {
1257             while ((next_mol = strstr(next_mol,"m:")) != NULL ) {
1258               char *end_mol = strpbrk ( next_mol, "@!,(~" );
1259               if (end_mol == NULL) {
1260                 end_mol = next_mol + strlen(next_mol);
1261               }
1262               int ext_name_len = end_mol - next_mol;
1263               char *ext_name = (char *) malloc ( ext_name_len + 1 );
1264               strncpy ( ext_name, next_mol+2, ext_name_len-2 );
1265               ext_name[ext_name_len-2] = '\0';
1266               external_mol_viz_by_name *next_mol_name = mol_name_list;
1267               int found = 0;
1268               do {
1269                 if (next_mol_name == NULL) {
1270                   break;
1271                 }
1272                 if (strcmp(ext_name, next_mol_name-&gt;mol_name) == 0) {
1273                   found = 1;
1274                   break;
1275                 }
1276                 next_mol_name = next_mol_name-&gt;next_name;
1277               } while ( found == 0 );
1278               if (found == 0) {
1279                 next_mol_name = (external_mol_viz_by_name *) malloc ( sizeof(external_mol_viz_by_name) );
1280                 next_mol_name-&gt;mol_name = ext_name;                  next_mol_name-&gt;mol_list = NULL;
1281                 next_mol_name-&gt;next_name = mol_name_list;
1282                 mol_name_list = next_mol_name;
1283               } else {
1284                 free ( ext_name );
1285               }
1286 						  external_mol_viz *new_mol_viz_item = (external_mol_viz *) malloc ( sizeof(external_mol_viz) );
1287               new_mol_viz_item-&gt;mol_type = mol_type;
1288               new_mol_viz_item-&gt;pos_x = pos_x + x_offset;               new_mol_viz_item-&gt;pos_y = pos_y;
1289               new_mol_viz_item-&gt;pos_z = pos_z;
1290               new_mol_viz_item-&gt;norm_x = norm_x;
1291               new_mol_viz_item-&gt;norm_y = norm_y;
1292               new_mol_viz_item-&gt;norm_z = norm_z;
1293               new_mol_viz_item-&gt;next_mol = next_mol_name-&gt;mol_list;
1294               next_mol_name-&gt;mol_list = new_mol_viz_item;
1295               next_mol += 1;
1296             }
1297           }
1298         }
1299       }
1300     }
1301     external_mol_viz_by_name *nl = mol_name_list;
1302     external_mol_viz *mv;
1303     while (nl != NULL) {
1304       if ( (world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT) || ( (strcmp(nl-&gt;mol_name,"volume_proxy")!=0) &amp;&amp; (strcmp(nl-&gt;mol_name,"volume_proxy")!=0) ) ) {
1305         byte name_len = strlen(nl-&gt;mol_name);
1306         fwrite(&amp;name_len, sizeof(name_len), 1, custom_file);
1307         fwrite(nl-&gt;mol_name, sizeof(char), name_len, custom_file);
1308         byte species_type = 0;
1309         if (nl-&gt;mol_list != NULL) {
1310           if (nl-&gt;mol_list-&gt;mol_type == 's') {
1311             species_type = 1;
1312           }
1313         }
1314         fwrite(&amp;species_type, sizeof(species_type), 1, custom_file);
1315         u_int n_floats = 0;
1316         mv = nl-&gt;mol_list;
1317         while (mv != NULL) {
1318           n_floats += 3;
1319           mv = mv-&gt;next_mol;
1320         }
1321         fwrite(&amp;n_floats, sizeof(n_floats), 1, custom_file);
1322         mv = nl-&gt;mol_list;
1323         while (mv != NULL) {
1324           float pos_x = mv-&gt;pos_x;
1325           float pos_y = mv-&gt;pos_y;
1326           float pos_z = mv-&gt;pos_z;
1327           fwrite(&amp;pos_x, sizeof(pos_x), 1, custom_file);
1328           fwrite(&amp;pos_y, sizeof(pos_y), 1, custom_file);
1329           fwrite(&amp;pos_z, sizeof(pos_z), 1, custom_file);
1330           mv = mv-&gt;next_mol;
1331         }
1332         mv = nl-&gt;mol_list;
1333         if (mv-&gt;mol_type == 's') {
1334           while (mv != NULL) {
1335             float norm_x = mv-&gt;norm_x;
1336             float norm_y = mv-&gt;norm_y;
1337             float norm_z = mv-&gt;norm_z;
1338             fwrite(&amp;norm_x, sizeof(norm_x), 1, custom_file);
1339             fwrite(&amp;norm_y, sizeof(norm_y), 1, custom_file);
1340             fwrite(&amp;norm_z, sizeof(norm_z), 1, custom_file);
1341             mv = mv-&gt;next_mol;
1342           }
1343         }
1344         nl = nl-&gt;next_name;
1345       }
1346     }
1347     if (space_struct_file != NULL) {
1348       if ( world-&gt;viz_options &amp; VIZ_ALT_DUMP_FMT ) {
1349         u_int ss_version = 2;
1350         fprintf ( space_struct_file, "%d\n", ss_version );
1351         if (graph_pattern_table != NULL) {
1352           for (int bin=0; bin&lt;graph_pattern_table-&gt;n_bins; bin++) {
1353             if (graph_pattern_table-&gt;entries[bin] != NULL) {
1354               struct sym_entry *se = graph_pattern_table-&gt;entries[bin];
1355               while (se != NULL) {
1356                 fprintf ( space_struct_file, "Entry: %s\n", se-&gt;name );
1357                 molcomp_list *mcl = (molcomp_list *) se-&gt;value;
1358                 dump_molcomp_list_to ( space_struct_file, mcl );
1359                 se = se-&gt;next;
1360               }
1361             }
1362           }
1363         }
1364         for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
1365           const unsigned int this_mol_count = viz_mol_count[species_idx];
1366           if (this_mol_count == 0)
1367             continue;
1368           const int id = vizblk-&gt;species_viz_states[species_idx];
1369           if (id == EXCLUDE_OBJ)
1370             continue;
1371           struct abstract_molecule **const mols = viz_molp[species_idx];
1372           if (mols == NULL)
1373             continue;
1374           struct abstract_molecule *amp;
1375           for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
1376             amp = mols[n_mol];
1377             if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
1378               char *gp = amp-&gt;graph_data-&gt;graph_pattern;
1379               long mol_class = -1;
1380               if (graph_pattern_table != NULL) {
1381                 struct sym_entry *sp;
1382                 sp = retrieve_sym(gp, graph_pattern_table);
1383                 if (sp != NULL) {
1384                   molcomp_list *mcl = NULL;
1385                   mcl = (molcomp_list *) sp-&gt;value;
1386                   mol_class = -1 * mcl-&gt;molcomp_id;                  }
1387               }
1388               float pos_x = 0.0;
1389               float pos_y = 0.0;
1390               float pos_z = 0.0;
1391               float norm_x = 0.0;
1392               float norm_y = 0.0;
1393               float norm_z = 0.0;
1394               if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
1395                 struct volume_molecule *mp = (struct volume_molecule *)amp;
1396                 pos_x = mp-&gt;pos.x;
1397                 pos_y = mp-&gt;pos.y;
1398                 pos_z = mp-&gt;pos.z;
1399               } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1400                 struct surface_molecule *gmp = (struct surface_molecule *)amp;
1401                 struct vector3 where;
1402                 uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
1403                 pos_x = where.x;
1404                 pos_y = where.y;
1405                 pos_z = where.z;
1406               }
1407               pos_x *= world-&gt;length_unit;
1408               pos_y *= world-&gt;length_unit;
1409               pos_z *= world-&gt;length_unit;
1410               if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1411                 struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
1412                 short orient = gmp-&gt;orient;
1413                 norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
1414                 norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
1415                 norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
1416               }
1417               fprintf ( space_struct_file, "Mol %d:  Class=%ld  Position=(%g %g %g)  Orientation=(%g %g %g)\n", n_mol, mol_class, pos_x, pos_y, pos_z, norm_x, norm_y, norm_z );
1418             }
1419           }
1420         }
1421         fflush ( space_struct_file );
1422         fclose ( space_struct_file );
1423       } else if ( world-&gt;viz_options &amp; VIZ_JSON_MOLCOMP_FMT ) {
1424         int *gp_entry_for_id = NULL;  
1425         fprintf ( space_struct_file, "[\n" );            fprintf ( space_struct_file, " 2,\n" );          fprintf ( space_struct_file, " [\n" );   
1426         if (graph_pattern_table != NULL) {
1427           int n_gp_entries = graph_pattern_table-&gt;n_entries;
1428           int gp_entry_num = 0;
1429           gp_entry_for_id = (int *) malloc ( n_gp_entries * sizeof(int) ); 
1430           for (int bin=0; bin&lt;graph_pattern_table-&gt;n_bins; bin++) {
1431             if (graph_pattern_table-&gt;entries[bin] != NULL) {
1432               struct sym_entry *se = graph_pattern_table-&gt;entries[bin];
1433               while (se != NULL) {
1434                 molcomp_list *mcl = (molcomp_list *) se-&gt;value;
1435                 gp_entry_for_id[mcl-&gt;molcomp_id] = gp_entry_num;                  external_molcomp_loc *mca = mcl-&gt;molcomp_array;
1436                 int num_parts = mcl-&gt;num_molcomp_items;
1437                 {
1438                   int i, j;
1439                   fprintf ( space_struct_file, "  [\n" );                    for (i=0; i&lt;num_parts; i++) {
1440                     fprintf ( space_struct_file, "   [ " );                      if (mca[i].is_mol) {
1441                       fprintf ( space_struct_file, "\"m\"" );
1442                     } else {
1443                       fprintf ( space_struct_file, "\"c\"" );
1444                     }
1445                     fprintf ( space_struct_file, ", \"%s\"", mca[i].name );
1446                     fprintf ( space_struct_file, ", [%g, %g, %g], [", mca[i].x, mca[i].y, mca[i].z );
1447                     for (j=0; j&lt;mca[i].num_peers; j++) {
1448                       fprintf ( space_struct_file, "%d", mca[i].peers[j] );
1449                       if (j &lt; mca[i].num_peers - 1) {
1450                         fprintf ( space_struct_file, "," );
1451                       }
1452                     }
1453                     if (mca[i].states == NULL) {
1454                       fprintf ( space_struct_file, "], \"\" ]" );                      } else if (strcmp(mca[i].states,"~NO_STATE")==0) {
1455                       fprintf ( space_struct_file, "], \"\" ]" );                      } else {
1456                       fprintf ( space_struct_file, "], \"%s\" ]", mca[i].states );                      }
1457                     end_line_opt_comma ( space_struct_file, i &lt; (num_parts-1) );
1458                   }
1459                   fprintf ( space_struct_file, "  ]" );                    gp_entry_num++;
1460                   end_line_opt_comma ( space_struct_file, gp_entry_num &lt; n_gp_entries );
1461                 }
1462                 se = se-&gt;next;
1463               }
1464             }
1465           }
1466         }
1467         fprintf ( space_struct_file, " ],\n" );  
1468         fprintf ( space_struct_file, " [" );          int first_pass = 1;
1469         for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
1470           const unsigned int this_mol_count = viz_mol_count[species_idx];
1471           if (this_mol_count == 0)
1472             continue;
1473           const int id = vizblk-&gt;species_viz_states[species_idx];
1474           if (id == EXCLUDE_OBJ)
1475             continue;
1476           struct abstract_molecule **const mols = viz_molp[species_idx];
1477           if (mols == NULL)
1478             continue;
1479           struct abstract_molecule *amp;
1480           for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
1481             amp = mols[n_mol];
1482             if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
1483               char *gp = amp-&gt;graph_data-&gt;graph_pattern;
1484               long mol_class = -1;
1485               if (graph_pattern_table != NULL) {
1486                 struct sym_entry *sp;
1487                 sp = retrieve_sym(gp, graph_pattern_table);
1488                 if (sp != NULL) {
1489                   molcomp_list *mcl = NULL;
1490                   mcl = (molcomp_list *) sp-&gt;value;
1491                   mol_class = gp_entry_for_id[mcl-&gt;molcomp_id];
1492                 }
1493               }
1494               float pos_x = 0.0;
1495               float pos_y = 0.0;
1496               float pos_z = 0.0;
1497               float norm_x = 0.0;
1498               float norm_y = 0.0;
1499               float norm_z = 0.0;
1500               if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
1501                 struct volume_molecule *mp = (struct volume_molecule *)amp;
1502                 pos_x = mp-&gt;pos.x;
1503                 pos_y = mp-&gt;pos.y;
1504                 pos_z = mp-&gt;pos.z;
1505               } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1506                 struct surface_molecule *gmp = (struct surface_molecule *)amp;
1507                 struct vector3 where;
1508                 uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
1509                 pos_x = where.x;
1510                 pos_y = where.y;
1511                 pos_z = where.z;
1512               }
1513               pos_x *= world-&gt;length_unit;
1514               pos_y *= world-&gt;length_unit;
1515               pos_z *= world-&gt;length_unit;
1516               if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
1517                 struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
1518                 short orient = gmp-&gt;orient;
1519                 norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
1520                 norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
1521                 norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
1522               }
1523               if ( first_pass ) {
1524                 fprintf ( space_struct_file, "\n" );                  first_pass = 0;
1525               } else {
1526                 fprintf ( space_struct_file, ",\n" );                }
1527               fprintf ( space_struct_file, "  [%ld,[%g,%g,%g],[%g,%g,%g]]", mol_class, pos_x, pos_y, pos_z, norm_x, norm_y, norm_z );
1528             }
1529           }
1530         }
1531         fprintf ( space_struct_file, "\n ]\n" );  
1532         fprintf ( space_struct_file, "]\n" );  
1533         fflush ( space_struct_file );
1534         fclose ( space_struct_file );
1535         if ( gp_entry_for_id != NULL ) {
1536           free ( gp_entry_for_id );
1537         }
1538       }
1539     }
1540     while (mol_name_list != NULL) {
1541       nl = mol_name_list;
1542       free ( nl-&gt;mol_name );
1543       while (nl-&gt;mol_list != NULL) {
1544         mv = nl-&gt;mol_list;
1545         nl-&gt;mol_list = mv-&gt;next_mol;
1546         free ( mv );
1547       }
1548       mol_name_list = nl-&gt;next_name;
1549       free ( nl );
1550     }
1551     fclose(custom_file);
1552     custom_file = NULL;
1553     free_ptr_array((void **)viz_molp, world-&gt;n_species);
1554     viz_molp = NULL;
1555     free(viz_mol_count);
1556     viz_mol_count = NULL;
1557   } 
1558   free ( file_prefix_no_Scene );
1559   free ( file_prefix_usually_Scene );
1560   if (world-&gt;dump_level &gt;= 50) {
1561     fprintf ( stdout, "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Bottom of MolViz Output &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n" );
1562   }
1563   return 0;
1564 }
1565 int init_frame_data_list(struct volume *world,
1566                          struct viz_output_block *vizblk) {
1567   int mol_orient_frame_present = 0;
1568   int mol_pos_frame_present = 0;
1569   struct frame_data_list *fdlp;
1570   if (vizblk-&gt;frame_data_head == NULL)
1571     return 0;
1572   switch (vizblk-&gt;viz_mode) {
1573   case NO_VIZ_MODE:
1574     count_time_values(world, vizblk-&gt;frame_data_head);
1575     if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
1576       return 1;
1577     break;
1578   case ASCII_MODE:
1579     count_time_values(world, vizblk-&gt;frame_data_head);
1580     if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
1581       return 1;
1582     break;
1583   case CELLBLENDER_MODE_V1:
1584     count_time_values(world, vizblk-&gt;frame_data_head);
1585     if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
1586       return 1;
1587     break;
1588   default:
1589     count_time_values(world, vizblk-&gt;frame_data_head);
1590     if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
1591       return 1;
1592     break;
1593   }
1594   for (fdlp = vizblk-&gt;frame_data_head; fdlp != NULL; fdlp = fdlp-&gt;next) {
1595     if (fdlp-&gt;curr_viz_iteration == NULL)
1596       continue;
1597     switch (fdlp-&gt;type) {
1598     case MOL_ORIENT:
1599       mol_orient_frame_present = 1;
1600       break;
1601     case MOL_POS:
1602       mol_pos_frame_present = 1;
1603       break;
1604     case ALL_MOL_DATA:
1605       mol_pos_frame_present = 1;
1606       mol_orient_frame_present = 1;
1607       break;
1608     default:
1609       ;
1610     }
1611   } 
1612   if ((mol_orient_frame_present) &amp; (!mol_pos_frame_present))
1613     mcell_warn("The input file contains ORIENTATIONS but not POSITIONS "
1614                "statement in the MOLECULES block. The molecules cannot be "
1615                "visualized.");
1616   return 0;
1617 }
1618 int update_frame_data_list(struct volume *world,
1619                            struct viz_output_block *vizblk) {
1620   static char const *const FRAME_TYPES[NUM_FRAME_TYPES] = {
1621     "MOL_POS",  "MOL_ORIENT", "ALL_MOL_DATA", 
1622   };
1623   if (vizblk == NULL)
1624     return 0;
1625   if (vizblk-&gt;frame_data_head == NULL)
1626     return 0;
1627   switch (world-&gt;notify-&gt;viz_output_report) {
1628   case NOTIFY_NONE:
1629     break;
1630   case NOTIFY_BRIEF:
1631   case NOTIFY_FULL:
1632     mcell_log("Updating viz output on iteration %lld.", world-&gt;current_iterations);
1633     break;
1634   default:
1635     UNHANDLED_CASE(world-&gt;notify-&gt;viz_output_report);
1636   }
1637   for (struct frame_data_list *fdlp = vizblk-&gt;frame_data_head; fdlp != NULL;
1638        fdlp = fdlp-&gt;next) {
1639     if (world-&gt;current_iterations != fdlp-&gt;viz_iteration)
1640       continue;
1641     if (world-&gt;notify-&gt;viz_output_report == NOTIFY_FULL) {
1642       if (fdlp-&gt;type &gt;= NUM_FRAME_TYPES)
1643         mcell_warn("  Updating data frame of unknown type %d.", fdlp-&gt;type);
1644       else
1645         mcell_log("  Updating data frame of type %s.", FRAME_TYPES[fdlp-&gt;type]);
1646     }
1647     switch (vizblk-&gt;viz_mode) {
1648     case ASCII_MODE:
1649       if (output_ascii_molecules(world, vizblk, fdlp))
1650         return 1;
1651       break;
1652     case CELLBLENDER_MODE_V1:
1653       if (output_cellblender_molecules(world, vizblk, fdlp))
1654         return 1;
1655       break;
1656     case NO_VIZ_MODE:
1657     default:
1658       break;
1659     }
1660     while (fdlp-&gt;curr_viz_iteration != NULL &amp;&amp;
1661            fdlp-&gt;viz_iteration == world-&gt;current_iterations) {
1662       fdlp-&gt;curr_viz_iteration = fdlp-&gt;curr_viz_iteration-&gt;next;
1663       if (fdlp-&gt;curr_viz_iteration)
1664         fdlp-&gt;viz_iteration = frame_iteration(
1665             world, fdlp-&gt;curr_viz_iteration-&gt;value, fdlp-&gt;list_type);
1666     }
1667     if (world-&gt;notify-&gt;viz_output_report == NOTIFY_FULL)
1668       mcell_log("  Next update on iteration %lld.", fdlp-&gt;viz_iteration);
1669   }
1670   return 0;
1671 }
1672 int finalize_viz_output(struct volume *world, struct viz_output_block *vizblk) {
1673   if (vizblk == NULL)
1674     return 0;
1675   switch (vizblk-&gt;viz_mode) {
1676   case NO_VIZ_MODE:
1677   case ASCII_MODE:
1678   default:
1679     break;
1680   }
1681   return 0;
1682 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
