<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for defines.h & viz_output.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for defines.h & viz_output.c
      </h3>
      <h1 align="center">
        0.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>defines.h (1.4098691%)<TH>viz_output.c (0.58848256%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1581-0.html#0',2,'match1581-1.html#0',3)" NAME="0">(811-821)<TD><A HREF="javascript:ZweiFrames('match1581-0.html#0',2,'match1581-1.html#0',3)" NAME="0">(1606-1616)</A><TD ALIGN=center><FONT COLOR="#ff0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>defines.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
 *
 * Copyright (C) 2019 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

#ifndef SRC4_DEFINES_H_
#define SRC4_DEFINES_H_

#include &lt;stdint.h&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;

#include &quot;mcell_structs_shared.h&quot;
#include &quot;debug_config.h&quot;

// warning: do not use floating point types from directly,
// we need to be able to control the precision
#include &quot;../libs/glm/glm.hpp&quot;
#define GLM_ENABLE_EXPERIMENTAL
#include &quot;../libs/glm/gtx/component_wise.hpp&quot;

#include &quot;bng/shared_defines.h&quot; // may define INDEXER_WA

#if defined(NDEBUG) &amp;&amp; defined(INDEXER_WA)
#warning &quot;INDEXER_WA is enabled and this will lead to lower performance&quot;
#endif

#ifndef INDEXER_WA
#include &lt;boost/container/small_vector.hpp&gt;
#include &lt;boost/container/flat_set.hpp&gt;
#endif

// this file must not depend on any other from mcell4 otherwise there
// might be some nasty cyclic include dependencies

/**
 * Usage of IDs and indexes:
 *
 * ID - world-unique identifier of an object
 * Index -partition-unique identifier of an object
 *
 * Why use indices instead of pointers:
 *   - Having a value that is independent on actual position in memory can be beneficial,
 *     this way, we can migrate the data to a different piece of memory and the index will be still valid
 *
 *   - Do we really need to move data? - Yes
 *      - Growing arrays get reallocated
 *      - Defragmentation of molecule arrays
 *
 * Use only IDs?
 *   - This would mean that for every access, we need to use indirection, might be cheap, but also might
 *     block some superscalar executions...
 *   - Also, every type of object would have its own mapping array for all the possible IDs
 *     in each partition
 *
 * What about cases when a wall changes its partition?
 *   - If I hold just its index, I cannot know that it has moved.
 *
 * Go back to single partition? Do not think about multicore execution for now?
 *   - Single partition system won't need to use indices, just IDs
 *   - However, ids do not allow for defragmentation without fixing up all existing references
 *
 * Keep the implementation it as it is for now? - Yes
 *   - molecules use ids, everything else uses indices
 *   - refactor once we will have a good reason to do it - e.g. initially we might now want to allow walls to cross partitions
 *
 * Another approach:
 *   - Id + index for everything that can change?
 *   - Id for everything that does not change?
 *
 */

namespace MCell {

// import shared declarations from BNG into our own namespace
using BNGCommon::f_to_str;

using BNGCommon::EPS;
using BNGCommon::SQRT_EPS;
using BNGCommon::DBL_GIGANTIC;

using BNGCommon::pos_t;
using BNGCommon::POS_EPS;
using BNGCommon::POS_SQRT_EPS;
using BNGCommon::POS_GIGANTIC;

using BNGCommon::stime_t;
using BNGCommon::STIME_EPS;
using BNGCommon::STIME_SQRT_EPS;
using BNGCommon::STIME_GIGANTIC;

using BNGCommon::fabs_f;
using BNGCommon::cmp_eq;
using BNGCommon::distinguishable_p;
using BNGCommon::distinguishable_f;
using BNGCommon::sqrt_f;
using BNGCommon::pow_f;
using BNGCommon::floor_f;
using BNGCommon::round_f;

// also import commonly used declarations from BNG into our own namespace
using BNG::species_id_t;
using BNG::SPECIES_ID_INVALID;

using BNG::orientation_t;
using BNG::ORIENTATION_DOWN;
using BNG::ORIENTATION_NONE;
using BNG::ORIENTATION_UP;
using BNG::ORIENTATION_NOT_SET;
using BNG::ORIENTATION_DEPENDS_ON_SURF_COMP;


const double MIN_WALL_GAP = 1e-4; // 1 angstrom when length unit is 1um

// ---------------------------------- optimization macros ----------------------------------
#if defined(likely) || defined(unlikely)
#error &quot;Macros 'likely' or 'unlikely' are already defined&quot;
#endif

#ifndef _MSC_VER
#define likely(x)       __builtin_expect((x),1)
#define unlikely(x)     __builtin_expect((x),0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif

// ---------------------------------- float types ----------------------------------

const double SCHEDULER_COMPARISON_EPS = 1e-10;
const size_t SCHEDULER_MAX_BUCKETS_TO_FUTURE = 100000000;

const double MESH_DISTINCTIVE_EPS = EPS;

// ---------------------------------- configurable constants----------------------------------

const uint SORT_MOLS_BY_SUBPART_PERIODICITY = 20;

const uint DEFRAGMENTATION_PERIODICITY = 100;

const pos_t PARTITION_EDGE_LENGTH_DEFAULT_UM = 10; // large for now because we have just one partition
const pos_t PARTITION_EDGE_EXTRA_MARGIN_UM = 0.01;
const uint SUBPARTITIONS_PER_PARTITION_DIMENSION_DEFAULT = 1;

const uint MAX_SUBPARTS_PER_PARTITION = 300;

// with low sampling rate, the buffers take long to flush and
// the user may want to see the results earlier, so the buffers are
// periodically flushed, not only when they are full
// this time is checked with output frequency (when the iterations report is printed)
const double COUNT_BUFFER_FLUSH_SECONDS = 60;

// ideally we would need this event to be scheduled right away but this may
// require too much memory (related to maximal distance of simulation barrier)
const uint64_t ITERATIONS_BEFORE_RUN_N_ITERATIONS_END_EVENT = 10000;


const uint64_t DEFAULT_MOL_ORDER_SHUFFLE_PERIODICITY = 10000;

// ---------------------------------- fixed constants and specific typedefs -------------------
const pos_t POS_INVALID = FLT_MAX; // cannot be NAN because we cannot do any comparison with NANs
const pos_t LENGTH_INVALID = FLT_MAX;

const double TIME_INVALID = -256;
const double TIME_FOREVER = 1e20; // based on MCell3
const double TIME_SIMULATION_START = 0;

const pos_t POS_SQRT2 = 1.41421356238;
const pos_t POS_RXN_RADIUS_MULTIPLIER = 1.3; // TEMPORARY - we should figure out why some collisions with subparts are missed..., but maybe it won't have big perf impact...

const uint INT_INVALID = INT32_MAX;



// molecule id is a unique identifier of a molecule,
// no 2 molecules may have the same ID in the course of a simulation (at least for now)
typedef uint molecule_id_t;
const molecule_id_t MOLECULE_ID_INVALID = ID_INVALID;

typedef std::vector&lt;molecule_id_t&gt; MoleculeIdsVector;
typedef uint_set&lt;molecule_id_t&gt; MoleculeIdsSet;

// molecule index is index into partition's molecules array, indices and ids are
// identical until the first defragmentation that shuffles molecules in the molecules array
typedef uint molecule_index_t;
const molecule_index_t MOLECULE_INDEX_INVALID = INDEX_INVALID;

// for now, this is the partition that contains point 0,0,0 in its center
typedef uint partition_id_t;
const partition_id_t PARTITION_ID_INITIAL = 0;
const partition_id_t PARTITION_ID_INVALID = INDEX_INVALID;

typedef uint subpart_index_t;
const subpart_index_t SUBPART_INDEX_INVALID = INDEX_INVALID;

// time step is used in partition to make sets of molecules that can be diffused with
// different periodicity
const uint TIME_STEP_INDEX_INVALID = INDEX_INVALID;

const char* const NAME_INVALID = &quot;name_invalid&quot;;
const char* const NAME_NOT_SET = &quot;name_not_set&quot;;

const uint64_t BUCKET_INDEX_INVALID = UINT64_MAX;

const uint VERTICES_IN_TRIANGLE = 3;
const uint EDGES_IN_TRIANGLE = VERTICES_IN_TRIANGLE; // same of course as above, but different name to specify what we are counting

typedef uint vertex_index_t; // index in partition's vertices
const vertex_index_t VERTEX_INDEX_INVALID = INDEX_INVALID;

typedef uint wall_index_t; // index in partition's walls
const wall_index_t WALL_INDEX_INVALID = INDEX_INVALID;

typedef uint tile_index_t; // index of a tile in a grid
const tile_index_t TILE_INDEX_INVALID = INDEX_INVALID;

typedef uint edge_index_t; // index of an edge in a wall, must be in range 0..2
const edge_index_t EDGE_INDEX_0 = 0;
const edge_index_t EDGE_INDEX_1 = 1;
const edge_index_t EDGE_INDEX_2 = 2;
const edge_index_t EDGE_INDEX_WITHIN_WALL = 3; // used in find_edge_point
const edge_index_t EDGE_INDEX_CANNOT_TELL = 4;
const edge_index_t EDGE_INDEX_INVALID = INDEX_INVALID;


typedef uint count_buffer_id_t; // index of a tile in a grid
const count_buffer_id_t COUNT_BUFFER_ID_INVALID = INDEX_INVALID;

typedef uint rgba_t; // color represented by rgba
const rgba_t DEFAULT_COLOR = 0xFFFFFF3F; // 1, 1, 1, 0.25

/* contains information about the neighbors of the tile */
class WallTileIndexPair {
public:
  WallTileIndexPair()
    : wall_index(WALL_INDEX_INVALID), tile_index(TILE_INDEX_INVALID)
    {
  }

  WallTileIndexPair(const wall_index_t wall_index_, const tile_index_t tile_index_)
    : wall_index(wall_index_), tile_index(tile_index_)
    {
  }

  bool operator== (const WallTileIndexPair&amp; other) const {
    return wall_index == other.wall_index &amp;&amp; tile_index == other.tile_index;
  }

  wall_index_t wall_index;  /* surface grid the tile is on */
  tile_index_t tile_index;  /* index on that tile */
};

typedef uint wall_id_t; // world-unique wall id
const wall_id_t WALL_ID_INVALID = ID_INVALID;
const wall_id_t WALL_ID_NOT_IN_PARTITION = ID_INVALID2;

typedef uint region_id_t; // world-unique region id
const region_id_t REGION_ID_INVALID = ID_INVALID;

typedef uint region_index_t; // index in partition's regions
const region_index_t REGION_INDEX_INVALID = INDEX_INVALID;
typedef uint_set&lt;region_index_t&gt; RegionIndicesSet;

typedef uint geometry_object_index_t;
const geometry_object_index_t GEOMETRY_OBJECT_INDEX_INVALID = INDEX_INVALID;

typedef uint geometry_object_id_t; // world-unique unique geometry object id
const geometry_object_id_t GEOMETRY_OBJECT_ID_INVALID = ID_INVALID;

// each partition has a list of volumes that are counted
// each counted volume is identified by a set of geometry objects it is in
// completely
typedef uint counted_volume_index_t;
// volume outside of all objects, i.e. WORLD-all objects,
// this is a special counted volume that has no geometry objects
const counted_volume_index_t COUNTED_VOLUME_INDEX_OUTSIDE_ALL = 0;

// special value that tells that the specific index must be computed
// based on the specific position
const counted_volume_index_t COUNTED_VOLUME_INDEX_INTERSECTS = INDEX_INVALID2;

const counted_volume_index_t COUNTED_VOLUME_INDEX_INVALID = INDEX_INVALID;


typedef std::pair&lt;partition_id_t, wall_index_t&gt; PartitionWallIndexPair;
typedef std::pair&lt;partition_id_t, region_index_t&gt; PartitionRegionIndexPair;
typedef std::pair&lt;partition_id_t, vertex_index_t&gt; PartitionVertexIndexPair;

typedef std::pair&lt;pos_t, PartitionWallIndexPair&gt; CummAreaPWallIndexPair;

typedef std::map&lt;geometry_object_id_t, uint_set&lt;geometry_object_id_t&gt;&gt; CountedVolumesMap;

const int BASE_CONTAINER_ALLOC = 16;

#ifndef INDEXER_WA
typedef boost::container::small_vector&lt;subpart_index_t, BASE_CONTAINER_ALLOC&gt;  SubpartIndicesVector;
typedef boost::container::small_vector&lt;wall_index_t, BASE_CONTAINER_ALLOC&gt; WallIndicesVector;
// WARNING: std::set_intersection and possibly other algorithms do not work correctly with dense_hash_set
typedef uint_dense_hash_set&lt;subpart_index_t&gt; SubpartIndicesSet; // boost-based uint_set is worse on average
#else
typedef std::vector&lt;subpart_index_t&gt; SubpartIndicesVector;
typedef std::vector&lt;wall_index_t&gt; WallIndicesVector;
typedef std::set&lt;subpart_index_t&gt; SubpartIndicesSet;

#endif

template&lt;typename T&gt;
class insertion_ordered_set {
public:
  void insert_ordered(const T&amp; value) {
    if (s.count(value) == 0) {
      s.insert(value);
      v.push_back(value);
    }
  }

  const T&amp; operator [] (const size_t i) const {
    assert(i &lt; size());
    return v[i];
  }

  size_t size() const {
    assert(v.size() == s.size());
    return v.size();
  }

  const std::vector&lt;T&gt;&amp; get_as_vector() const {
    return v;
  }

private:
  std::vector&lt;T&gt; v;
  std::set&lt;T&gt; s;
};

// ---------------------------------- vector types ----------------------------------

#if POS_T_BYTES == 8
typedef glm::dvec3 glm_vec3_t;
typedef glm::dvec2 glm_vec2_t;
typedef glm::dmat4x4 mat4x4;
#else
typedef glm::fvec3 glm_vec3_t;
typedef glm::fvec2 glm_vec2_t;
typedef glm::fmat4x4 mat4x4;
#endif

typedef glm::ivec3 glm_ivec3_t;
typedef glm::uvec3 UVec3;
typedef glm::bvec3 BVec3;


struct IVec3: public glm_ivec3_t {
  IVec3() = default;
  IVec3(const glm_vec3_t&amp; a) { x = a.x; y = a.y; z = a.z; }
  IVec3(const IVec3&amp; a) : glm_ivec3_t(a.x, a.y, a.z) { }
  IVec3(const int x_, const int y_, const int z_) { x = x_; y = y_; z = z_; }
  IVec3(const int xyz) { x = xyz; y = xyz; z = xyz; }
  IVec3(const std::vector&lt;int&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
  IVec3(const vector3&amp; v3) { x = v3.x; y = v3.y; z = v3.z; }
  IVec3&amp; operator=(const IVec3&amp; other) = default;

  // arbitrary ordering in order to use IVec3 as keys in sets and maps
  bool operator &lt; (const IVec3&amp; other) const {
    if (x &lt; other.x) {
      return true;
    }
    else if (x == other.x) {
      if (y &lt; other.y) {
        return true;
      }
      else if (y == other.y) {
        if (z &lt; other.z) {
          return true;
        }
        else {
          return false;
        }
      }
      else {
        return false;
      }
    }
    else {
      return false;
    }
  }
};

struct Vec3: public glm_vec3_t {
  Vec3() = default;
  Vec3(const glm_vec3_t&amp; a) { x = a.x; y = a.y; z = a.z; }
  Vec3(const Vec3&amp; a) : glm_vec3_t(a.x, a.y, a.z) { }
  Vec3(const IVec3&amp; a) : glm_vec3_t(a.x, a.y, a.z) { }
  Vec3(const vector3&amp; a) { x = a.x; y = a.y; z = a.z; }
  Vec3(const pos_t x_, const pos_t y_, const pos_t z_) { x = x_; y = y_; z = z_; }
  Vec3(const pos_t xyz) { x = xyz; y = xyz; z = xyz; }
  Vec3(const std::vector&lt;double&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
#if POS_T_BYTES == 4
  Vec3(const std::vector&lt;pos_t&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
#endif
  Vec3&amp; operator=(const Vec3&amp; other) = default;

  std::vector&lt;double&gt; to_vec() const {
    std::vector&lt;double&gt; res(3);
    res[0] = x;
    res[1] = y;
    res[2] = z;
    return res;
  }

  bool is_valid() const { return !(x == POS_INVALID || y == POS_INVALID || z == POS_INVALID); }

  std::string to_string() const;
  void dump(const std::string extra_comment, const std::string ind) const;
};

// usually are .u and .v used to access contained values
struct Vec2: public glm_vec2_t {
  Vec2() = default;
  Vec2(const glm_vec2_t&amp; a) { x = a.x; y = a.y; }
  Vec2(const Vec2&amp; a) : glm_vec2_t(a.x, a.y) { }
  Vec2(const vector2&amp; a) { x = a.u; y = a.v; }
  Vec2(const pos_t x_, const pos_t y_) { x = x_; y = y_; }
  Vec2(const pos_t xy) { x = xy; y = xy; }
  Vec2(const std::vector&lt;double&gt;&amp; xy) { assert(xy.size() == 2); x = xy[0]; y = xy[1]; }
#if POS_T_BYTES == 4
  Vec2(const std::vector&lt;pos_t&gt;&amp; xy) { assert(xy.size() == 2); x = xy[0]; y = xy[1]; }
#endif
  Vec2&amp; operator=(const Vec2&amp; other) = default;

  std::vector&lt;double&gt; to_vec() const {
    std::vector&lt;double&gt; res(2);
    res[0] = x;
    res[1] = y;
    return res;
  }

  bool is_valid() const { return !(x == POS_INVALID || y == POS_INVALID); }

  std::string to_string() const;
  void dump(const std::string extra_comment, const std::string ind) const;
};



static inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const Vec3&amp; a) {
  out &lt;&lt; &quot;(&quot; &lt;&lt; a.x &lt;&lt; &quot;, &quot; &lt;&lt; a.y &lt;&lt; &quot;, &quot; &lt;&lt; a.z &lt;&lt; &quot;)&quot;;
  return out;
}
static inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const Vec2&amp; a) {
  out &lt;&lt; &quot;(&quot; &lt;&lt; a.u &lt;&lt; &quot;, &quot; &lt;&lt; a.v &lt;&lt; &quot;)&quot;;
  return out;
}


// ---------------------------------- auxiliary functions ----------------------------------

static inline double log_f(const double x) {
  assert(x != 0);
  return log(x);
}

static inline pos_t log_p(const pos_t x) {
  assert(x != 0);
#if POS_T_BYTES == 4
  return logf(x);
#else
  return log(x);
#endif
}

static inline double exp_f(const double x) {
  return exp(x);
}

static inline double ceil_f(const double x) {
  return ceil(x);
}

static inline double ceil_p(const pos_t x) {
#if POS_T_BYTES == 8
  return ceil(x);
#else
  return ceilf(x);
#endif
}

static inline pos_t fabs_p(const pos_t x) {
  if (x &lt; 0) {
    return -x;
  }
  else {
    return x;
  }
}

static inline double floor_to_multiple_f(const double val, double multiple) {
  assert(val &gt;= 0);
  assert(multiple &gt; 0);
  return (double)((long long)((val + EPS)/ multiple)) * multiple;
}

static inline pos_t floor_to_multiple_p(const pos_t val, pos_t multiple) {
  assert(val &gt;= 0);
  assert(multiple &gt; 0);
  return (pos_t)((long long)((val + EPS)/ multiple)) * multiple;
}

static inline double floor_to_multiple_allow_negative_p(const double val, pos_t multiple) {
  if (val &gt;= 0) {
    return (double)((long long)((val + EPS)/ multiple)) * multiple;
  }
  else {
    // we need to floor towards the lower negative value, the code above would
    // ceil the value for negative inputs
    return (double)((long long)((val + EPS - multiple)/ multiple)) * multiple;
  }
}

static inline Vec3 floor_to_multiple_allow_negative_p(const Vec3&amp; val, const pos_t multiple) {
  Vec3 res;
  res.x = floor_to_multiple_allow_negative_p(val.x, multiple);
  res.y = floor_to_multiple_allow_negative_p(val.y, multiple);
  res.z = floor_to_multiple_allow_negative_p(val.z, multiple);
  return res;
}

static inline double ceil_to_multiple_p(const double val, const pos_t multiple) {
  assert(val &gt;= 0);
  double res = floor_to_multiple_p(val, multiple);
  if (!cmp_eq(val, res)) {
    res += multiple;
  }
  return res;
}

static inline Vec3 ceil_to_multiple_p(const Vec3&amp; val, const pos_t multiple) {
  Vec3 res;
  res.x = ceil_to_multiple_p(val.x, multiple);
  res.y = ceil_to_multiple_p(val.y, multiple);
  res.z = ceil_to_multiple_p(val.z, multiple);
  return res;
}

static inline bool cmp_eq(const Vec3&amp; a, const Vec3&amp; b, const pos_t eps) {
  return cmp_eq(a.x, b.x, eps) &amp;&amp; cmp_eq(a.y, b.y, eps) &amp;&amp; cmp_eq(a.z, b.z, eps);
}

static inline bool cmp_eq(const Vec3&amp; a, const Vec3&amp; b) {
  return cmp_eq(a, b, EPS);
}

static inline bool cmp_eq(const Vec2&amp; a, const Vec2&amp; b, const pos_t eps) {
  return cmp_eq(a.x, b.x, eps) &amp;&amp; cmp_eq(a.y, b.y, eps);
}

static inline bool cmp_eq(const Vec2&amp; a, const Vec2&amp; b) {
  return cmp_eq(a, b, EPS);
}

static inline bool cmp_lt(const double a, const double b, const double eps) {
  return a &lt; b &amp;&amp; !cmp_eq(a, b, eps);
}

static inline bool cmp_le(const double a, const double b, const double eps) {
  return a &lt; b || cmp_eq(a, b, eps);
}

static inline bool cmp_gt(const double a, const double b, const double eps) {
  return a &gt; b &amp;&amp; !cmp_eq(a, b, eps);
}

static inline bool cmp_ge(const double a, const double b, const double eps) {
  return a &gt; b || cmp_eq(a, b, eps);
}

static inline pos_t sqrt_p(const pos_t x) {
#if POS_T_BYTES == 4
  return sqrtf(x);
#else
  return sqrt(x);
#endif
}


static inline uint powu(const uint a, const uint n) {
  uint res = a;
  for (uint i = 1; i &lt; n; i++) {
    res *= a;
  }
  return res;
}


static inline pos_t max3(const Vec3&amp; v) {
  return glm::compMax((glm_vec3_t)v);
}

static inline pos_t min3(const Vec3&amp; v) {
  return glm::compMin((glm_vec3_t)v);
}

static inline pos_t min3_p(const pos_t x, const pos_t y, const pos_t z) {
  return (z &lt; y) ? ((z &lt; x) ? z : x) : ((y &lt; x) ? y : x);
}

static inline int max3_i(const IVec3&amp; v) {
  return glm::compMax((glm_ivec3_t)v);
}

static inline int min3_i(const IVec3&amp; v) {
  return glm::compMin((glm_ivec3_t)v);
}

static inline Vec3 abs3(const Vec3&amp; v) {
  return glm::abs((glm_vec3_t)v);
}

static inline Vec3 floor3(const Vec3&amp; v) {
  return glm::floor((glm_vec3_t)v);
}

static inline Vec3 round3(const Vec3&amp; v) {
  return glm::round((glm_vec3_t)v);
}

/* abs_max_2vec picks out the largest (absolute) value found among two vectors
 * (useful for properly handling floating-point rounding error). */
static inline pos_t abs_max_2vec(const Vec3&amp; v1, const Vec3&amp; v2) {
  glm_vec3_t v1abs = abs3(v1);
  glm_vec3_t v2abs = abs3(v2);
  Vec3 vmax = glm::max(v1abs, v2abs);
  return MCell::max3(vmax);
}

static inline pos_t determinant2(const Vec2&amp; v1, const Vec2&amp; v2) {
  return v1.u * v2.v - v1.v * v2.u;
}

static inline pos_t dot2(const Vec2&amp; v1, const Vec2&amp; v2) {
  return glm::dot((glm_vec2_t)v1, (glm_vec2_t)v2);
}

static inline pos_t len2_squared(const Vec2&amp; v1) {
  return v1.u * v1.u + v1.v * v1.v;
}

static inline pos_t len2(const Vec2&amp; v1) {
  return sqrt_p(len2_squared(v1));
}

static inline pos_t dot(const Vec3&amp; v1, const Vec3&amp; v2) {
  return glm::dot((glm_vec3_t)v1, (glm_vec3_t)v2);
}

static inline pos_t len3_squared(const Vec3&amp; v1) {
  return v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
}

static inline pos_t len3(const Vec3&amp; v1) {
  return sqrt_p(len3_squared(v1));
}

static inline pos_t distance3_squared(const Vec3&amp; v1, const Vec3&amp; v2) {
  return len3_squared(v1 - v2);
}

static inline pos_t distance3(const Vec3&amp; v1, const Vec3&amp; v2) {
  return sqrt_p( len3_squared(v1 - v2) );
}

static inline uint get_largest_abs_dim_index(const Vec3&amp; v) {
  Vec3 a = glm::abs(glm_vec3_t(v));
  if (a.x &gt; a.y) {
    if (a.x &gt; a.z) {
      return 0; // x
    }
    else {
      return 2; // z
    }
  }
  else {
    if (a.y &gt; a.z) {
      return 1; // y
    }
    else {
      return 2; // z
    }

  }
}

/***************************************************************************
point_in_box:
  In:  pt - we want to find out if this point is in the box
       llf - lower left front corner of the box
       urb - upper right back corner of the box

  Out: Returns true if point is in box, 0 otherwise
***************************************************************************/
static inline bool point_in_box(const Vec3&amp; pt, const Vec3&amp; llf, const Vec3&amp; urb) {
  return
      pt.x &gt;= llf.x &amp;&amp; pt.x &lt;= urb.x &amp;&amp;
      pt.y &gt;= llf.y &amp;&amp; pt.y &lt;= urb.y &amp;&amp;
      pt.z &gt;= llf.z &amp;&amp; pt.z &lt;= urb.z;
}

/**
 * Performs vector cross product.
 * Computes the cross product of two vector3's v1 and v2 storing the result
 * in vector3 v3.
 */
static inline Vec3 cross(const Vec3&amp; v1, const Vec3&amp; v2) {
  return glm::cross((glm_vec3_t)v1, (glm_vec3_t)v2);
}


static inline int distinguishable_vec2(const Vec2&amp; a, const Vec2&amp; b, const pos_t eps) {
  pos_t c, cc, d;

  /* Find largest coordinate */
  c = fabs_p(a.u);

  d = fabs_p(a.v);
  if (d &gt; c)
    c = d;

  d = fabs_p(b.u);
  if (d &gt; c)
    c = d;

  d = fabs_p(b.v);
  if (d &gt; c)
    c = d;

  /* Find largest difference */
  cc = fabs_p(a.u - b.u);

  d = fabs_p(a.v - b.v);
  if (d &gt; cc)
    cc = d;

  /* Make sure fractional difference is at least eps and absolute difference is
   * at least (eps*eps) */
  if (c &lt; eps)
    c = eps;
  return (c * eps &lt; cc);
}


static inline bool distinguishable_vec3(const Vec3&amp; a, const Vec3&amp; b, const pos_t eps) {
  pos_t c, cc, d;

  /* Find largest coordinate */
  c = fabs_p(a.x);

  d = fabs_p(a.y);
  if (d &gt; c)
    c = d;

  d = fabs_p(a.z);
  if (d &gt; c)
    c = d;

  d = fabs_p(b.x);
  if (d &gt; c)
    c = d;

  d = fabs_p(b.y);
  if (d &gt; c)
    c = d;

  d = fabs_p(b.z);
  if (d &gt; c)
    c = d;

  /* Find largest difference */
  cc = fabs_p(a.x - b.x);

  d = fabs_p(a.y - b.y);
  if (d &gt; cc)
    cc = d;

  d = fabs_p(a.z - b.z);
  if (d &gt; cc)
    cc = d;

  /* Make sure fractional difference is at least eps and absolute difference is
   * at least (eps*eps) */
  if (c &lt; eps)
    c = eps;
  return (c * eps &lt; cc);
<A NAME="0"></A>}


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1581-1.html#0',3,'match1581-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static inline void guard_zero_div(Vec3&amp; val) {
  if (val.x == 0) {
    val.x = FLT_MIN;
  }
  if (val.y == 0) {
    val.y = FLT_MIN;
  }
  if (val.z == 0) {
    val.z = FLT_MIN;
  }
}</B></FONT>

// some utilities
uint64_t get_mem_usage();


} // namespace mcell

#endif // SRC4_DEFINES_H_
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>viz_output.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/******************************************************************************
 *
 * Copyright (C) 2006-2017 by
 * The Salk Institute for Biological Studies and
 * Pittsburgh Supercomputing Center, Carnegie Mellon University
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 *
******************************************************************************/

#include &quot;config.h&quot;

#include &lt;stdarg.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;fcntl.h&gt;
#ifndef _MSC_VER
#include &lt;unistd.h&gt;
#include &lt;dirent.h&gt;
#endif
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
#include &lt;assert.h&gt;

#include &quot;c_vector.h&quot;
#include &quot;debug_config.h&quot;

/*
#include &quot;isaac64.h&quot;
#include &quot;rng.h&quot;
*/

#include &quot;logging.h&quot;
#include &quot;mcell_structs.h&quot;
#include &quot;grid_util.h&quot;
#include &quot;sched_util.h&quot;
#include &quot;viz_output.h&quot;
#include &quot;strfunc.h&quot;
#include &quot;util.h&quot;
#include &quot;vol_util.h&quot;
#include &quot;sym_table.h&quot;

#include &quot;bng_util.h&quot;

/***  Temporary Viz Options compared to world-&gt;viz_options ***/

#define VIZ_OPTS_NONE        0x00L

#define VIZ_COMP_NAMING_MASK 0x0FL /* Lowest hex digit */
#define VIZ_COMP_ALL_SAME    0x01L /* Name all component &quot;molecules&quot; with the same name */
#define VIZ_COMP_NAME_GLOBAL 0x02L /* Name all component &quot;molecules&quot; by their global component name */
#define VIZ_COMP_MOL_LOCAL   0x03L /* Name all component &quot;molecules&quot; by their molecule and component name */
#define VIZ_PROXY_OUTPUT     0x08L /* Force output of proxy molecules */

#define VIZ_ALT_FILES_MASK   0xF0L /* Second lowest hex digit */
#define VIZ_ALT_DUMP_FMT     0x10L /* Text format for human reading */
#define VIZ_JSON_MOLCOMP_FMT 0x20L /* Text format using JSON lists to represent a molecule/component list */



/* Output frame types. */
static int output_ascii_molecules(struct volume *world,
                                  struct viz_output_block *,
                                  struct frame_data_list *fdlp);

static int output_cellblender_molecules(struct volume *world,
                                        struct viz_output_block *,
                                        struct frame_data_list *fdlp);

/* == viz-specific Utilities == */

/*************************************************************************
frame_iteration:
    Gets the iteration number for a given time/iteration value and &quot;type&quot;.

        In:  double iterval - the time/iteration value
             int type - the type of value
        Out: the frame time as an iteration number
**************************************************************************/
static long long frame_iteration(struct volume *world, double iterval,
                                 int type) {
  switch (type) {
  case OUTPUT_BY_ITERATION_LIST:
    return (long long)iterval;

  case OUTPUT_BY_TIME_LIST:
    if (world-&gt;chkpt_seq_num == 1) {
      return (long long)(iterval / world-&gt;time_unit + ROUND_UP);
    } else {
      if (iterval &gt;= world-&gt;simulation_start_seconds) {
        return (long long) convert_seconds_to_iterations(
            world-&gt;start_iterations, world-&gt;time_unit,
            world-&gt;simulation_start_seconds, iterval) + ROUND_UP;
      } else {
        /* This iteration_time was in the past - just return flag.
           We do this because TIME_STEP may have been changed between
           checkpoints */
        return INT_MIN;
      }
    }

  default:
    mcell_internal_error(&quot;Invalid frame_data_list list_type (%d).&quot;, type);
    /*return -1;*/
  }
}

/*************************************************************************
sort_molecules_by_species:
    Scans over all molecules, sorting them into arrays by species.

        In:  struct abstract_molecule ****viz_molpp
             u_int  **viz_mol_countp
             int include_volume - should the lists include vol mols?
             int include_grid - should the lists include surface mols?
        Out: 0 on success, 1 on error; viz_molpp and viz_mol_countp arrays are
             allocated and filled with sorted data.
**************************************************************************/
static int sort_molecules_by_species(struct volume *world,
                                     struct viz_output_block *vizblk,
                                     struct abstract_molecule ****viz_molpp,
                                     u_int **viz_mol_countp, int include_volume,
                                     int include_grid) {
  struct storage_list *slp;
  u_int *counts;
  int species_index;

  /* XXX: May leave memory allocated on failure */
  if ((*viz_molpp = (struct abstract_molecule ***)allocate_ptr_array(
           world-&gt;n_species)) == NULL)
    return 1;
  if ((counts = *viz_mol_countp = allocate_uint_array(world-&gt;n_species, 0)) ==
      NULL)
    return 1;

  /* Walk through the species allocating arrays for all molecules of that
   * species */
  for (species_index = 0; species_index &lt; world-&gt;n_species; ++species_index) {
    int mol_count;
    u_int spec_id = world-&gt;species_list[species_index]-&gt;species_id;

    if (vizblk-&gt;species_viz_states[species_index] == EXCLUDE_OBJ)
      continue;

    if (world-&gt;species_list[species_index]-&gt;flags &amp; IS_SURFACE)
      continue;

    if (!include_grid &amp;&amp; (world-&gt;species_list[species_index]-&gt;flags &amp; ON_GRID))
      continue;

    if (!include_volume &amp;&amp;
        !(world-&gt;species_list[species_index]-&gt;flags &amp; ON_GRID))
      continue;

    mol_count = world-&gt;species_list[species_index]-&gt;population;
    if (mol_count &lt;= 0)
      continue;

    if (((*viz_molpp)[spec_id] =
             (struct abstract_molecule **)allocate_ptr_array(mol_count)) ==
        NULL)
      return 1;
  }

  /* Sort molecules by species id */
  for (slp = world-&gt;storage_head; slp != NULL; slp = slp-&gt;next) {
    struct storage *sp = slp-&gt;store;
    struct schedule_helper *shp;
    struct abstract_molecule *amp;
    int sched_slot_index;
    for (shp = sp-&gt;timer; shp != NULL; shp = shp-&gt;next_scale) {
      for (sched_slot_index = -1; sched_slot_index &lt; shp-&gt;buf_len;
           ++sched_slot_index) {
        for (amp = (struct abstract_molecule *)((sched_slot_index &lt; 0)
                                                    ? shp-&gt;current
                                                    : shp-&gt;circ_buf_head
                                                          [sched_slot_index]);
             amp != NULL; amp = amp-&gt;next) {
          u_int spec_id;
          if (amp-&gt;properties == NULL)
            continue;

          spec_id = amp-&gt;properties-&gt;species_id;
          if (vizblk-&gt;species_viz_states[spec_id] == EXCLUDE_OBJ)
            continue;

          if (!include_grid &amp;&amp; (amp-&gt;flags &amp; TYPE_MASK) != TYPE_VOL)
            continue;

          if (!include_volume &amp;&amp; (amp-&gt;flags &amp; TYPE_MASK) == TYPE_VOL)
            continue;

          if (counts[spec_id] &lt; amp-&gt;properties-&gt;population)
            (*viz_molpp)[spec_id][counts[spec_id]++] = amp;
          else {
            mcell_warn(&quot;Molecule count disagreement!\n&quot;
                       &quot;  Species %s  population = %d  count = %d&quot;,
                       amp-&gt;properties-&gt;sym-&gt;name, amp-&gt;properties-&gt;population,
                       counts[spec_id]);
          }
        }
      }
    }
  }

  return 0;
}

/*************************************************************************
reset_time_values:
    Scan over all frame data elements, resetting the &quot;next&quot; iteration state to
    the soonest iteration following or equal to the specified iteration.

        In:  struct frame_data_list *fdlp - the head of the frame data list
             long long curiter - the minimum iteration number
        Out: 0 on success, 1 on failure
**************************************************************************/
static int reset_time_values(struct volume *world, struct frame_data_list *fdlp,
                             long long curiter) {
  /* If we've loaded a checkpoint, don't output on the first iter */
  if (curiter != 0)
    ++curiter;

  for (; fdlp != NULL; fdlp = fdlp-&gt;next) {
    fdlp-&gt;curr_viz_iteration = fdlp-&gt;iteration_list;
    fdlp-&gt;viz_iteration = -1;

    /* Scan for first iteration &gt;= curiter */
    while (fdlp-&gt;curr_viz_iteration != NULL) {
      if (frame_iteration(world, fdlp-&gt;curr_viz_iteration-&gt;value,
                          fdlp-&gt;list_type) &gt;= curiter)
        break;
      fdlp-&gt;curr_viz_iteration = fdlp-&gt;curr_viz_iteration-&gt;next;
    }

    /* If we had an iteration, use it to set viz_iteration */
    if (fdlp-&gt;curr_viz_iteration != NULL)
      fdlp-&gt;viz_iteration = frame_iteration(
          world, fdlp-&gt;curr_viz_iteration-&gt;value, fdlp-&gt;list_type);
  }

  return 0;
}

/*************************************************************************
count_time_values:
    Scan over all frame data elements, counting iterations.  The number of
    distinct iterations on which viz data will be output is returned.  In the
    process, each frame data elements n_viz_iterations is set, as is the &quot;final
    viz iteration&quot;.  The total number of distinct iterations is returned.

        In:  struct frame_data_list *fdlp - the head of the frame data list
        Out: num distinct iterations
**************************************************************************/
static int count_time_values(struct volume *world,
                             struct frame_data_list *const fdlp) {
  int time_values = 0;
  long long curiter = -1;
  struct frame_data_list *fdlpcur = NULL;
  for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
    fdlpcur-&gt;curr_viz_iteration = fdlpcur-&gt;iteration_list;
    fdlpcur-&gt;n_viz_iterations = 0;
    fdlpcur-&gt;viz_iteration = -1;
  }

  while (1) {
    curiter = -1;

    /* Find the next iteration */
    for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
      long long thisiter;
      if (fdlpcur-&gt;curr_viz_iteration == NULL)
        continue;

      thisiter = frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
                                 fdlpcur-&gt;list_type);

      if (curiter == -1)
        curiter = thisiter;
      else if (thisiter &lt; curiter)
        curiter = thisiter;
    }

    /* If we found no new iteration, quit */
    if (curiter == -1)
      break;

    /* We won't create any more output frames after the apocalypse. */
    if (curiter &gt; world-&gt;iterations)
      break;

    /* We won't create any more output frames after we checkpoint. */
    if (world-&gt;chkpt_iterations != 0 &amp;&amp;
        curiter &gt; world-&gt;start_iterations + world-&gt;chkpt_iterations)
      break;

    /* We found at least one more.  Note that the only time we will output at
     * iteration == start_iterations is when start_iterations is zero.  This is because we
     * do not output on the first iteration after we resume.
     */
    if (curiter &gt; world-&gt;start_iterations)
      ++time_values;
    else if ((world-&gt;start_iterations | curiter) == 0)
      ++time_values;

    /* Advance any frame data items which are set to this iteration */
    for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
      if (fdlpcur-&gt;curr_viz_iteration == NULL)
        continue;

      if (curiter &gt; world-&gt;start_iterations || (world-&gt;start_iterations | curiter) == 0) {
        if (frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
                            fdlpcur-&gt;list_type) == curiter)
          ++fdlpcur-&gt;n_viz_iterations;
      }

      while (fdlpcur-&gt;curr_viz_iteration &amp;&amp;
             frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
                             fdlpcur-&gt;list_type) == curiter)
        fdlpcur-&gt;curr_viz_iteration = fdlpcur-&gt;curr_viz_iteration-&gt;next;
    }
  }

  return time_values;
}

/************************************************************************
output_ascii_molecules:
In: vizblk: VIZ_OUTPUT block for this frame list
    a frame data list (internal viz output data structure)
Out: 0 on success, 1 on failure.  The positions of molecules are output
     in exponential floating point notation (with 8 decimal places)
*************************************************************************/
static int output_ascii_molecules(struct volume *world,
                                  struct viz_output_block *vizblk,
                                  struct frame_data_list *fdlp) {
  FILE *custom_file;
  char *cf_name;
  struct storage_list *slp;
  struct schedule_helper *shp;
  struct abstract_element *aep;
  struct abstract_molecule *amp;
  struct volume_molecule *mp;
  struct surface_molecule *gmp;
  short orient = 0;

  int ndigits, i;
  long long lli;

  struct vector3 where, norm;

  no_printf(&quot;Output in ASCII mode (molecules only)...\n&quot;);

  if ((fdlp-&gt;type == ALL_MOL_DATA) || (fdlp-&gt;type == MOL_POS)) {
    lli = 10;
    for (ndigits = 1; lli &lt;= world-&gt;iterations &amp;&amp; ndigits &lt; 20;
         lli *= 10, ndigits++) {
    }
    cf_name =
        CHECKED_SPRINTF(&quot;%s.ascii.%.*lld.dat&quot;, vizblk-&gt;file_prefix_name,
                        ndigits, fdlp-&gt;viz_iteration);
    if (cf_name == NULL)
      return 1;
    if (make_parent_dir(cf_name)) {
      free(cf_name);
      mcell_error(
          &quot;Failed to create parent directory for ASCII-mode VIZ output.&quot;);
      /*return 1;*/
    }
    custom_file = open_file(cf_name, &quot;w&quot;);
    if (!custom_file)
      mcell_die();
    else {
      no_printf(&quot;Writing to file %s\n&quot;, cf_name);
    }
    free(cf_name);
    cf_name = NULL;

    c_vector_t *vec = vector_create();

    for (slp = world-&gt;storage_head; slp != NULL; slp = slp-&gt;next) {
      for (shp = slp-&gt;store-&gt;timer; shp != NULL; shp = shp-&gt;next_scale) {
        for (i = -1; i &lt; shp-&gt;buf_len; i++) {
          for (aep = (i &lt; 0) ? shp-&gt;current : shp-&gt;circ_buf_head[i];
               aep != NULL; aep = aep-&gt;next) {
            amp = (struct abstract_molecule *)aep;
            if (amp-&gt;properties == NULL)
              continue;

            // remember
            vector_push_back(vec, amp);
          }
        }
      }
    }
#ifdef MCELL3_SORTED_VIZ_OUTPUT
    // sort - necessary for comparison with mcell4 because
    // molecules with diffusion constant zero are printed out in some &quot;random&quot; order
    vector_sort_by_mol_id(vec);
#endif    

    // print
    size_t sz = vector_get_size(vec);
    for (size_t k = 0; k &lt; sz; k++) {
      amp = (struct abstract_molecule*)vector_at(vec, k);

      int id = vizblk-&gt;species_viz_states[amp-&gt;properties-&gt;species_id];
      if (id == EXCLUDE_OBJ)
        continue;

      if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
        mp = (struct volume_molecule *)amp;
        where.x = mp-&gt;pos.x;
        where.y = mp-&gt;pos.y;
        where.z = mp-&gt;pos.z;
        norm.x = 0;
        norm.y = 0;
        norm.z = 0;
      } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
        gmp = (struct surface_molecule *)amp;
        uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
        orient = gmp-&gt;orient;
        norm.x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
        norm.y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
        norm.z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
      } else
        continue;

      where.x *= world-&gt;length_unit;
      where.y *= world-&gt;length_unit;
      where.z *= world-&gt;length_unit;
      /*
                  fprintf(custom_file,&quot;%d %15.8e %15.8e %15.8e
         %2d\n&quot;,id,where.x,where.y,where.z,orient);
      */
      std::string species_name = amp-&gt;properties-&gt;sym-&gt;name;

      #ifdef ASCII_VIZ_EXTERNAL_SPECIES_NAME
        if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
          /* This is complex molecule, so add a new viz molecule for each molecule in the complex */
          /* The graph pattern will be something like: */
          /*    c:SH2~NO_STATE!5,c:U~NO_STATE!5!3,c:a~NO_STATE!6,c:b~Y!6!1,c:g~Y!6,m:Lyn@PM!0!1,m:Rec@PM!2!3!4, */
          species_name = graph_pattern_to_bngl(amp-&gt;graph_data-&gt;graph_pattern);
        }
      #endif

      if (id == INCLUDE_OBJ) {
        /* write name of molecule */
        fprintf(custom_file, &quot;%s %lu %.9g %.9g %.9g %.9g %.9g %.9g\n&quot;,
                species_name.c_str(), amp-&gt;id, where.x, where.y,
                where.z, norm.x, norm.y, norm.z);
      } else {
        /* write state value of molecule */
        fprintf(custom_file, &quot;%d %lu %.9g %.9g %.9g %.9g %.9g %.9g\n&quot;, id,
                amp-&gt;id, where.x, where.y, where.z, norm.x, norm.y,
                norm.z);
      }
    }

    vector_delete(vec);

    fclose(custom_file);
  }

  return 0;
}


typedef struct external_mol_viz_struct {
  char mol_type;  /* s = surface, v = volume, n = none (don't display?) */
  float pos_x, pos_y, pos_z;
  float norm_x, norm_y, norm_z;
  struct external_mol_viz_struct *next_mol;
} external_mol_viz;

typedef struct external_mol_viz_by_name_struct {
  char *mol_name;
  external_mol_viz *mol_list;
  struct external_mol_viz_by_name_struct *next_name;
} external_mol_viz_by_name;



typedef struct external_mol_viz_entry_struct {
  char *mol_id_string;  /* Typically the NAUTY string (although that will be the key) */
} external_mol_viz_entry;


static struct sym_table_head *graph_pattern_table = NULL;
static long next_molcomp_id = 0L;

typedef struct external_molcomp_loc_struct {
  bool is_mol;
  bool has_coords;
  bool is_final;
  double x, y, z;
  double kx, ky, kz;
  char *name;
  char *graph_string;
  int num_peers;
  int *peers;
  char *states;
} external_molcomp_loc;

typedef struct molcomp_list_struct {
  external_molcomp_loc *molcomp_array;
  int num_molcomp_items;
  long molcomp_id;
} molcomp_list;

static void dump_molcomp_array_to ( FILE *out_file, external_molcomp_loc *molcomp_array, int num_parts ) {
  int i, j;
  fprintf ( out_file, &quot;%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%\n&quot; );
  for (i=0; i&lt;num_parts; i++) {
    fprintf ( out_file, &quot;[%d] = %s (&quot;, i, molcomp_array[i].name );
    if (molcomp_array[i].is_mol) {
      fprintf ( out_file, &quot;m&quot; );
    } else {
      fprintf ( out_file, &quot;c&quot; );
    }
    fprintf ( out_file, &quot;) at  (%g, %g, %g) with peers [&quot;, molcomp_array[i].x, molcomp_array[i].y, molcomp_array[i].z );
    for (j=0; j&lt;molcomp_array[i].num_peers; j++) {
      fprintf ( out_file, &quot;%d&quot;, molcomp_array[i].peers[j] );
      if (j &lt; molcomp_array[i].num_peers - 1) {
        fprintf ( out_file, &quot;,&quot; );
      }
    }
    fprintf ( out_file, &quot;]\n&quot; );
  }
  fprintf ( out_file, &quot;%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%\n&quot; );
}

static void dump_molcomp_list_to ( FILE *out_file, molcomp_list *mcl ) {
  fprintf ( out_file, &quot;ID=%ld\n&quot;, mcl-&gt;molcomp_id );
  dump_molcomp_array_to ( out_file, mcl-&gt;molcomp_array, mcl-&gt;num_molcomp_items );
}

static void dump_molcomp_array ( external_molcomp_loc *molcomp_array, int num_parts ) {
  dump_molcomp_array_to ( stdout, molcomp_array, num_parts );
}

/* Currently unused except in commented code
static void dump_molcomp_list ( molcomp_list *mcl ) {
  dump_molcomp_list_to ( stdout, mcl );
}
*/

double clipped_cos ( double angle ) {
  double v = cos(angle);
  if ((v &gt; -1e-6) &amp;&amp; (v &lt; 1e-6)) v = 0;
  return ( v );
}

double clipped_sin ( double angle ) {
  double v = sin(angle);
  if ((v &gt; -1e-6) &amp;&amp; (v &lt; 1e-6)) v = 0;
  return ( v );
}


static void set_component_positions_by_table ( struct volume *world, external_molcomp_loc *mc, int num_parts ) {
  double scale = 0.02;
  int mi;
  //fprintf ( stdout, &quot;Setting positions by table.\n&quot; );
  // Dump the table just to verify how to read it
  //fprintf ( stdout, &quot;==============================================\n&quot; );
  //dump_symtab(world-&gt;mol_ss_sym_table);
  //fprintf ( stdout, &quot;==============================================\n&quot; );

  for (mi=0; mi&lt;num_parts; mi++) {
    if (mc[mi].is_mol) {
      // Look up this molecule in the table
      //fprintf ( stdout, &quot;  Looking up component positions for %s\n&quot;, mc[mi].name );
      struct sym_entry *sp;
      sp = retrieve_sym(mc[mi].name, world-&gt;mol_ss_sym_table);
      if (sp != NULL) {
        //fprintf ( stdout, &quot;    Got an entry with symbol type %d and name %s\n&quot;, sp-&gt;sym_type, sp-&gt;name );
        // Fill in all of the component positions in this molecule from the list
        if (sp-&gt;sym_type == MOL_SS) {
          //fprintf ( stdout, &quot;       It's a Spatially Structured Molecule!!\n&quot; );

          // Set the has_coords flag to false on each component of this molecule
          for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
            mc[mc[mi].peers[ci]].has_coords = false;
          }

          // Walk through the list of component positions and for each one, find a matching mol_comp entry without coordinates

          struct mol_ss *mol_ss_ptr = (struct mol_ss *)(sp-&gt;value);
          struct mol_comp_ss *mc_ptr = mol_ss_ptr-&gt;mol_comp_ss_head;
          int comp_count = 0;
          // char *translations[5] = { &quot;COINCIDENT&quot;, &quot;XYZ&quot;, &quot;XYZA&quot;, &quot;XYZRef&quot;, &quot;XYZVA&quot; };
          while (mc_ptr != NULL) {
            //fprintf ( stdout, &quot;         Component %d is \&quot;%s\&quot; of type %s at (%g,%g,%g).\n&quot;, comp_count, mc_ptr-&gt;name, translations[mc_ptr-&gt;spatial_type], mc_ptr-&gt;loc_x, mc_ptr-&gt;loc_y, mc_ptr-&gt;loc_z );
            for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
              if ( (!mc[mc[mi].peers[ci]].has_coords) &amp;&amp; (strcmp(mc[mc[mi].peers[ci]].name, mc_ptr-&gt;name) == 0) ) {
                mc[mc[mi].peers[ci]].x = mc_ptr-&gt;loc_x;
                mc[mc[mi].peers[ci]].y = mc_ptr-&gt;loc_y;
                mc[mc[mi].peers[ci]].z = mc_ptr-&gt;loc_z;
                mc[mc[mi].peers[ci]].kx = mc_ptr-&gt;rot_axis_x;  // These are currently key locations rather than rotation axis locations
                mc[mc[mi].peers[ci]].ky = mc_ptr-&gt;rot_axis_y;  // These are currently key locations rather than rotation axis locations
                mc[mc[mi].peers[ci]].kz = mc_ptr-&gt;rot_axis_z;  // These are currently key locations rather than rotation axis locations
                mc[mc[mi].peers[ci]].has_coords = true;
                if (world-&gt;dump_level &gt;= 20) {
                  fprintf ( stdout, &quot;    Component %s is at (%g,%g,%g)\n&quot;, mc[mc[mi].peers[ci]].name, mc[mc[mi].peers[ci]].x, mc[mc[mi].peers[ci]].y, mc[mc[mi].peers[ci]].z );
                  fprintf ( stdout, &quot;       Ref key for %s is at (%g,%g,%g)\n&quot;, mc[mc[mi].peers[ci]].name, mc[mc[mi].peers[ci]].kx, mc[mc[mi].peers[ci]].ky, mc[mc[mi].peers[ci]].kz );
                }
                break;
              }
            }
            comp_count += 1;
            mc_ptr = mc_ptr-&gt;next;
          }

          //fprintf ( stdout, &quot;       This molecule has %d components.\n&quot;, comp_count );

          // Just to be sure, set any unset coordinates to 0

          for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
            if (!mc[mc[mi].peers[ci]].has_coords) {
              mc[mc[mi].peers[ci]].x = 0.0;
              mc[mc[mi].peers[ci]].y = 0.0;
              mc[mc[mi].peers[ci]].z = 0.0;
              mc[mc[mi].peers[ci]].kx = 0.0;
              mc[mc[mi].peers[ci]].ky = 0.0;
              mc[mc[mi].peers[ci]].kz = 0.0;
              mc[mc[mi].peers[ci]].has_coords = true;
            }
          }

        }
      } else {
        fprintf ( stdout, &quot;    No entry found for %s, using default. This is unexpected!!\n&quot;, mc[mi].name );
        for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
          double angle = 2 * MY_PI * ci / mc[mi].num_peers;
          mc[mc[mi].peers[ci]].x = scale * cos(angle);
          mc[mc[mi].peers[ci]].y = scale * sin(angle);
          mc[mc[mi].peers[ci]].z = 0.0;
          mc[mc[mi].peers[ci]].kx = 0.0;
          mc[mc[mi].peers[ci]].ky = 0.0;
          mc[mc[mi].peers[ci]].kz = scale;
          //#### fprintf ( stdout, &quot;  Component %s is at (%g,%g)\n&quot;, mc[mc[mi].peers[ci]].name, mc[mc[mi].peers[ci]].x, mc[mc[mi].peers[ci]].y );
        }
      }
    }
  }
}


static void bind_molecules_at_components ( struct volume *world, external_molcomp_loc *mc, int num_parts, int fixed_comp_index, int var_comp_index, bool as3D, bool with_rot ) {
  // Bind these two molecules by aligning their axes and shifting to align their components
  //#### fprintf ( stdout, &quot;########## Binding %s to %s\n&quot;, mc[fixed_comp_index].name, mc[var_comp_index].name );
  //#### dump_molcomp_array(mc,num_parts);

  int fixed_mol_index = mc[fixed_comp_index].peers[0];
  int var_mol_index = mc[var_comp_index].peers[0];

  double fixed_vec[3] = {0, 0, 0};  // This will either hold 2 or 3 values, but since it's temporary, the allocation difference doesn't accumulate.
  double   var_vec[3] = {0, 0, 0};
  fixed_vec[0] = mc[fixed_comp_index].x - mc[fixed_mol_index].x;
  fixed_vec[1] = mc[fixed_comp_index].y - mc[fixed_mol_index].y;
  var_vec[0]   = mc[  var_comp_index].x - mc[  var_mol_index].x;
  var_vec[1]   = mc[  var_comp_index].y - mc[  var_mol_index].y;
  if (as3D) {
    fixed_vec[2] = mc[fixed_comp_index].z - mc[fixed_mol_index].z;
    var_vec[2]   = mc[  var_comp_index].z - mc[  var_mol_index].z;
  }

  double fixed_mag;
  double   var_mag;
  if (as3D) {
    fixed_mag = sqrt ( (fixed_vec[0]*fixed_vec[0]) + (fixed_vec[1]*fixed_vec[1]) + (fixed_vec[2]*fixed_vec[2]) );
      var_mag = sqrt ( (  var_vec[0]*  var_vec[0]) + (  var_vec[1]*  var_vec[1]) + (  var_vec[2]*  var_vec[2]) );
  } else {
    fixed_mag = sqrt ( (fixed_vec[0]*fixed_vec[0]) + (fixed_vec[1]*fixed_vec[1]) );
      var_mag = sqrt ( (  var_vec[0]*  var_vec[0]) + (  var_vec[1]*  var_vec[1]) );
  }

  // Check to see if either are zero which indicates that it's not possible to bind them
  if ((fixed_mag * var_mag) == 0) {
    if (world-&gt;dump_level &gt;= 10) {
      fprintf ( stdout, &quot;Molecules %s and %s are nonspatially bound.\n&quot;, mc[fixed_comp_index].name, mc[var_comp_index].name );
    }
    return;
  }

  double dot_prod;
  if (as3D) {
    dot_prod = (fixed_vec[0] * var_vec[0]) + (fixed_vec[1] * var_vec[1]) + (fixed_vec[2] * var_vec[2]);
  } else {
    dot_prod = (fixed_vec[0] * var_vec[0]) + (fixed_vec[1] * var_vec[1]);
  }

  // In general, the magnitudes should be checked for 0. However, in this case, they were generated as non-zero.
  double norm_dot_prod = dot_prod / ( fixed_mag * var_mag );

  // Ensure that the dot product is a legal argument for the &quot;acos&quot; function:
  if (norm_dot_prod &gt;  1) { norm_dot_prod =  1; }
  if (norm_dot_prod &lt; -1) { norm_dot_prod = -1; }

  //#### fprintf ( stdout, &quot;norm_dot_prod = %g\n&quot;, norm_dot_prod );
  double angle = acos ( norm_dot_prod );
  //#### fprintf ( stdout, &quot;Angle (from acos) = %g\n&quot;, angle );

  if (as3D) {
    // This seems to be required to get everything right:
    angle = -angle;
  } else {
    // Try using the cross product to fix the direction issue
    //#### fprintf ( stdout, &quot;Cross of (%g,%g) X (%g,%g) = %g\n&quot;, fixed_vec[0], fixed_vec[1], var_vec[0], var_vec[1], (fixed_vec[0] * var_vec[1]) - (fixed_vec[1] * var_vec[0]) );
    if ( ( (fixed_vec[0] * var_vec[1]) - (fixed_vec[1] * var_vec[0]) ) &gt; 0 ) {
      angle = -angle;
    }
  }

  // Reverse the direction since we want the components attached to each other
  angle = MY_PI + angle;

  // Normalize between -PI and PI
  while (angle &gt; MY_PI) {
    angle = angle - (2 * MY_PI);
  }
  while (angle &lt;= -MY_PI) {
    angle = angle + (2 * MY_PI);
  }

  //angle = -angle;

  //#### fprintf ( stdout, &quot;Final corrected angle = %g\n&quot;, angle );

  //#### fprintf ( stdout, &quot;Binding between f(%s: %g,%g) and v(%s: %g,%g) is at angle %g deg\n&quot;, mc[fixed_comp_index].name, fixed_vec[0], fixed_vec[1], mc[var_comp_index].name, var_vec[0], var_vec[1], 180*angle/MY_PI );

  // Rotate all of the components of the var_mol_index by the angle
  double cos_angle = cos(angle);
  double sin_angle = sin(angle);

  if (as3D) {
    double cross_prod[3];
    cross_prod[0] = (fixed_vec[1] * var_vec[2]) - (fixed_vec[2] * var_vec[1]);
    cross_prod[1] = (fixed_vec[2] * var_vec[0]) - (fixed_vec[0] * var_vec[2]);
    cross_prod[2] = (fixed_vec[0] * var_vec[1]) - (fixed_vec[1] * var_vec[0]);

    double xpx, xpy, xpz;
    xpx = cross_prod[0] / (fixed_mag * var_mag);
    xpy = cross_prod[1] / (fixed_mag * var_mag);
    xpz = cross_prod[2] / (fixed_mag * var_mag);

    double axis_length = sqrt ( (xpx*xpx) + (xpy*xpy) + (xpz*xpz) );

    double R[3][3] = { { 1, 0, 0 },
                       { 0, 1, 0 },
                       { 0, 0, 1 } };
    if (axis_length &lt; 1e-30) {
      // Can't compute a meaningful unit vector for the rotation matrix ... make it identity
      if (norm_dot_prod &lt; 0) {
        // R is fine as defined
      } else {
        // Change the sign on the diagonal of R
        for (int i=0; i&lt;3; i++) {
          R[i][i] = -1;
        }
      }
    } else {
      // Build the rotation matrix R
      double ux = xpx / axis_length;
      double uy = xpy / axis_length;
      double uz = xpz / axis_length;
      double omca = 1 - cos_angle;

      R[0][0] = cos_angle + (ux*ux*omca);
      R[0][1] = (ux*uy*omca) - (uz*sin_angle);
      R[0][2] = (ux*uz*omca) + (uy*sin_angle);

      R[1][0] = (uy*ux*omca) + (uz*sin_angle);
      R[1][1] = cos_angle + (uy*uy*omca);
      R[1][2] = (uy*uz*omca) - (ux*sin_angle);
                
      R[2][0] = (uz*ux*omca) - (uy*sin_angle);
      R[2][1] = (uz*uy*omca) + (ux*sin_angle);
      R[2][2] = cos_angle + (uz*uz*omca);
    }

    for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
      // Rotate the component locations
      double x = mc[mc[var_mol_index].peers[ci]].x;
      double y = mc[mc[var_mol_index].peers[ci]].y;
      double z = mc[mc[var_mol_index].peers[ci]].z;
      mc[mc[var_mol_index].peers[ci]].x = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z);
      mc[mc[var_mol_index].peers[ci]].y = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z);
      mc[mc[var_mol_index].peers[ci]].z = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z);

      // Rotate the rotation key locations
      x = mc[mc[var_mol_index].peers[ci]].kx;
      y = mc[mc[var_mol_index].peers[ci]].ky;
      z = mc[mc[var_mol_index].peers[ci]].kz;
      mc[mc[var_mol_index].peers[ci]].kx = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z);
      mc[mc[var_mol_index].peers[ci]].ky = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z);
      mc[mc[var_mol_index].peers[ci]].kz = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z);
    }

  } else {
    // Note that the 2D branch is not expected to be used in MCell, so it may be out of date.

    //#### fprintf ( stdout, &quot;Rotating component positions for %s by %g\n&quot;, mc[var_mol_index].name, 180*angle/MY_PI );
    for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
      //#### fprintf ( stdout, &quot;  Component %s before is at (%g,%g)\n&quot;, mc[mc[var_mol_index].peers[ci]].name, mc[mc[var_mol_index].peers[ci]].x, mc[mc[var_mol_index].peers[ci]].y );
      double x = mc[mc[var_mol_index].peers[ci]].x;
      double y = mc[mc[var_mol_index].peers[ci]].y;
      mc[mc[var_mol_index].peers[ci]].x = (x * cos_angle) - (y * sin_angle);
      mc[mc[var_mol_index].peers[ci]].y = (x * sin_angle) + (y * cos_angle);
      //#### fprintf ( stdout, &quot;  Component %s after  is at (%g,%g)\n&quot;, mc[mc[var_mol_index].peers[ci]].name, mc[mc[var_mol_index].peers[ci]].x, mc[mc[var_mol_index].peers[ci]].y );
    }
  }


  // Now the molecules are aligned as they should be except for rotation along their bonding axis

  if ( as3D &amp;&amp; with_rot) {
    // Rotate the variable molecule along its bonding axis to align based on the rotation key angle



    ////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    double fixed_req_bond_angle = world-&gt;bond_angle / 2; // Radians ... should be a function of the bond!!
    double var_req_bond_angle = world-&gt;bond_angle / 2;   // Radians ... should be a function of the bond!!
    ////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////



    // fixed_vcomp (fvc) will be the vector from the fixed molecule to the fixed component
    double fvc[3];
    fvc[0] = mc[fixed_comp_index].x - mc[fixed_mol_index].x;
    fvc[1] = mc[fixed_comp_index].y - mc[fixed_mol_index].y;
    fvc[2] = mc[fixed_comp_index].z - mc[fixed_mol_index].z;

    // var_vcomp (vvc) will be the vector from the var molecule to the var component
    double vvc[3];
    vvc[0] = mc[var_comp_index].x - mc[var_mol_index].x;
    vvc[1] = mc[var_comp_index].y - mc[var_mol_index].y;
    vvc[2] = mc[var_comp_index].z - mc[var_mol_index].z;


    // fixed_vkey (fvk) will be the vector from the fixed molecule to the fixed key
    double fvk[3];
    fvk[0] = mc[fixed_comp_index].kx - mc[fixed_mol_index].x;
    fvk[1] = mc[fixed_comp_index].ky - mc[fixed_mol_index].y;
    fvk[2] = mc[fixed_comp_index].kz - mc[fixed_mol_index].z;

    // var_vkey (vvk) will be the vector from the var molecule to the var key
    double vvk[3];
    vvk[0] = mc[var_comp_index].kx - mc[var_mol_index].x;
    vvk[1] = mc[var_comp_index].ky - mc[var_mol_index].y;
    vvk[2] = mc[var_comp_index].kz - mc[var_mol_index].z;

    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, &quot;  Fixed vcomp = [ %g %g %g ]\n&quot;, fvc[0], fvc[1], fvc[2] );
      fprintf ( stdout, &quot;  Var   vcomp = [ %g %g %g ]\n&quot;, vvc[0], vvc[1], vvc[2] );
      fprintf ( stdout, &quot;  Fixed vkey  = [ %g %g %g ]\n&quot;, fvk[0], fvk[1], fvk[2] );
      fprintf ( stdout, &quot;  Var vkey    = [ %g %g %g ]\n&quot;, vvk[0], vvk[1], vvk[2] );
    }

    // Use the cross product to get the normal to the fixed molecule-component-key plane
    double fixed_normal[3];
    fixed_normal[0] = (fvc[1] * fvk[2]) - (fvc[2] * fvk[1]);
    fixed_normal[1] = (fvc[2] * fvk[0]) - (fvc[0] * fvk[2]);
    fixed_normal[2] = (fvc[0] * fvk[1]) - (fvc[1] * fvk[0]);

    // Use the cross product to get the normal to the variable molecule-component-key plane
    double var_normal[3];
    var_normal[0] = (vvc[1] * vvk[2]) - (vvc[2] * vvk[1]);
    var_normal[1] = (vvc[2] * vvk[0]) - (vvc[0] * vvk[2]);
    var_normal[2] = (vvc[0] * vvk[1]) - (vvc[1] * vvk[0]);

    // Get the magnitudes of the two vectors for normalization
    double fixed_norm_mag = sqrt ( (fixed_normal[0]*fixed_normal[0]) + (fixed_normal[1]*fixed_normal[1]) + (fixed_normal[2]*fixed_normal[2]) );
    double var_norm_mag   = sqrt ( (  var_normal[0]*  var_normal[0]) + (  var_normal[1]*  var_normal[1]) + (  var_normal[2]*  var_normal[2]) );

    // Calculate unit vectors
    double fixed_unit[3];
    fixed_unit[0] = fixed_normal[0] / fixed_norm_mag;
    fixed_unit[1] = fixed_normal[1] / fixed_norm_mag;
    fixed_unit[2] = fixed_normal[2] / fixed_norm_mag;
    double var_unit[3];
    var_unit[0] = var_normal[0] / var_norm_mag;
    var_unit[1] = var_normal[1] / var_norm_mag;
    var_unit[2] = var_normal[2] / var_norm_mag;

    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, &quot;  Fixed unit = [ %g %g %g ]\n&quot;, fixed_unit[0], fixed_unit[1], fixed_unit[2] );
      fprintf ( stdout, &quot;  Var unit = [ %g %g %g ]\n&quot;, var_unit[0], var_unit[1], var_unit[2] );
    }

    double norm_dot_prod_again;
    norm_dot_prod_again = (fixed_unit[0] * var_unit[0]) + (fixed_unit[1] * var_unit[1]) + (fixed_unit[2] * var_unit[2]);

    // Ensure that the dot product is a legal argument for the &quot;acos&quot; function:
    if (norm_dot_prod_again &gt;  1) {
      if (world-&gt;dump_level &gt;= 20) {
        fprintf ( stdout, &quot;Numerical Warning: normalized dot product %g was greater than 1\n&quot;, norm_dot_prod_again );
      }
      norm_dot_prod_again =  1;
    }
    if (norm_dot_prod_again &lt; -1) {
      if (world-&gt;dump_level &gt;= 20) {
        fprintf ( stdout, &quot;Numerical Warning: normalized dot product %g was less than -1\n&quot;, norm_dot_prod_again );
      }
      norm_dot_prod_again = -1;
    }
    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, &quot;  Normalized Dot Product between fixed and var is %g\n&quot;, norm_dot_prod_again );
    }

    // Compute the amount of rotation to bring the planes into alignment offset by the requested bond angles
    double cur_key_plane_angle = acos ( norm_dot_prod_again );

    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, &quot;Current key plane angle = %g\n&quot;, (180*cur_key_plane_angle/MY_PI) );
    }

    double cross_prod[3];

    cross_prod[0] = (fixed_unit[1] * var_unit[2]) - (fixed_unit[2] * var_unit[1]);
    cross_prod[1] = (fixed_unit[2] * var_unit[0]) - (fixed_unit[0] * var_unit[2]);
    cross_prod[2] = (fixed_unit[0] * var_unit[1]) - (fixed_unit[1] * var_unit[0]);

    double dot_cross_rot = (cross_prod[0] * vvc[0]) + (cross_prod[1] * vvc[1]) + (cross_prod[2] * vvc[2]);
    if (dot_cross_rot &gt; 0) {
      cur_key_plane_angle = (2*MY_PI) - cur_key_plane_angle;
    }

    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, &quot;Current key plane angle = %g,  dot_cross_rot = %g\n&quot;, (180*cur_key_plane_angle/MY_PI), dot_cross_rot );
    }

    double composite_rot_angle = MY_PI + (var_req_bond_angle+fixed_req_bond_angle) + cur_key_plane_angle;  // The &quot;MY_PI&quot; adds 180 degrees to make the components &quot;line up&quot;

    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, &quot;  Fixed angle                is = %g degrees\n&quot;, 180 * fixed_req_bond_angle / MY_PI );
      fprintf ( stdout, &quot;  Var angle                  is = %g degrees\n&quot;, 180 * var_req_bond_angle / MY_PI );
      fprintf ( stdout, &quot;  Current angle between keys is = %g degrees\n&quot;, 180 * cur_key_plane_angle / MY_PI );
      fprintf ( stdout, &quot;  Composite rotation angle   is = %g degrees\n&quot;, 180 * composite_rot_angle / MY_PI );
    }

    // Build a 3D rotation matrix along the axis of the molecule to the component
    double var_vcomp_mag = sqrt ( (vvc[0]*vvc[0]) + (vvc[1]*vvc[1]) + (vvc[2]*vvc[2]) );

    double var_rot_unit[3];
    var_rot_unit[0] = vvc[0] / var_vcomp_mag;
    var_rot_unit[1] = vvc[1] / var_vcomp_mag;
    var_rot_unit[2] = vvc[2] / var_vcomp_mag;

    double ux = var_rot_unit[0];
    double uy = var_rot_unit[1];
    double uz = var_rot_unit[2];

    // Build the rotation matrix directly

    double cca = cos(composite_rot_angle);
    double sca = sin(composite_rot_angle);
    double omcca = 1 - cca;

    double R[3][3] = { { 1, 0, 0 },
                       { 0, 1, 0 },
                       { 0, 0, 1 } };

    R[0][0] = cca + (ux*ux*omcca);
    R[0][1] = (ux*uy*omcca) - (uz*sca);
    R[0][2] = (ux*uz*omcca) + (uy*sca);

    R[1][0] = (uy*ux*omcca) + (uz*sca);
    R[1][1] = cca + (uy*uy*omcca);
    R[1][2] = (uy*uz*omcca) - (ux*sca);

    R[2][0] = (uz*ux*omcca) - (uy*sca);
    R[2][1] = (uz*uy*omcca) + (ux*sca);
    R[2][2] = cca + (uz*uz*omcca);

    // Apply the rotation matrix after subtracting the molecule center location from all components and keys

    for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
      // Rotate the component locations
      double x = mc[mc[var_mol_index].peers[ci]].x - mc[var_mol_index].x;
      double y = mc[mc[var_mol_index].peers[ci]].y - mc[var_mol_index].y;
      double z = mc[mc[var_mol_index].peers[ci]].z - mc[var_mol_index].z;
      mc[mc[var_mol_index].peers[ci]].x = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z) + mc[var_mol_index].x;
      mc[mc[var_mol_index].peers[ci]].y = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z) + mc[var_mol_index].y;
      mc[mc[var_mol_index].peers[ci]].z = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z) + mc[var_mol_index].z;

      // Rotate the rotation key locations
      x = mc[mc[var_mol_index].peers[ci]].kx - mc[var_mol_index].x;
      y = mc[mc[var_mol_index].peers[ci]].ky - mc[var_mol_index].y;
      z = mc[mc[var_mol_index].peers[ci]].kz - mc[var_mol_index].z;
      mc[mc[var_mol_index].peers[ci]].kx = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z) + mc[var_mol_index].x;
      mc[mc[var_mol_index].peers[ci]].ky = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z) + mc[var_mol_index].y;
      mc[mc[var_mol_index].peers[ci]].kz = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z) + mc[var_mol_index].z;
    }

  }

  //#### dump_molcomp_array(mc,num_parts);

  // Shift the var molecule location and the locations of all of its components by the difference of the binding components

  double dx = mc[fixed_comp_index].x - mc[var_comp_index].x;
  double dy = mc[fixed_comp_index].y - mc[var_comp_index].y;
  double dz = mc[fixed_comp_index].z - mc[var_comp_index].z;

  //#### fprintf ( stdout, &quot;Shifting molecule and component positions for %s\n&quot;, mc[var_mol_index].name );
  mc[var_mol_index].x += dx;
  mc[var_mol_index].y += dy;
  mc[var_mol_index].z += dz;
  for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
    // Shift the component locations
    mc[mc[var_mol_index].peers[ci]].x += dx;
    mc[mc[var_mol_index].peers[ci]].y += dy;
    mc[mc[var_mol_index].peers[ci]].z += dz;
    // Shift the rotation key locations
    mc[mc[var_mol_index].peers[ci]].kx += dx;
    mc[mc[var_mol_index].peers[ci]].ky += dy;
    mc[mc[var_mol_index].peers[ci]].kz += dz;
    //#### fprintf ( stdout, &quot;  Component %s is at (%g,%g)\n&quot;, mc[mc[var_mol_index].peers[ci]].name, mc[mc[var_mol_index].peers[ci]].x, mc[mc[var_mol_index].peers[ci]].y );
  }

  //#### dump_molcomp_array(mc,num_parts);

  //#### fprintf ( stdout, &quot;########## Done Binding %s to %s\n&quot;, mc[fixed_comp_index].name, mc[var_comp_index].name );
}


static void bind_all_molecules ( struct volume *world, external_molcomp_loc *molcomp_array, int num_parts, bool as3D, bool with_rot ) {
  // Compute positions for all molecules/components in a molcomp_array
  int mi=0;
  int pi=0;

  // Find first molecule
  for (mi=0; mi&lt;num_parts; mi++) {
    if (molcomp_array[mi].is_mol) break;
  }
  if (molcomp_array[mi].is_mol) {
    // Set this first molecule and all of its components to final
    molcomp_array[mi].is_final = true;
    for (int ci=0; ci&lt;molcomp_array[mi].num_peers; ci++) {
      molcomp_array[molcomp_array[mi].peers[ci]].is_final = true;
    }
    int done = 0;
    while (done == 0) {
      // Look for a bond between a non-final and a final component
      done = 1;
      for (mi=0; mi&lt;num_parts; mi++) {
        if (!molcomp_array[mi].is_mol) {
          // Only search components for bonds
          if (molcomp_array[mi].num_peers &gt; 1) {
            // This component has bonds, so search them
            for (int ci=1; ci&lt;molcomp_array[mi].num_peers; ci++) {
              pi = molcomp_array[mi].peers[ci];  // Peer index
              if (molcomp_array[mi].is_final != molcomp_array[pi].is_final) {
                done = 0;
                // One of these is final and the other is not so join them and make them all final
                int fci, vci;  // Fixed comp index and Variable comp index
                int vmi;  // Fixed mol index and Variable mol index
                // Figure out which is fixed and which is not
                if (molcomp_array[mi].is_final) {
                  fci = mi;
                  vci = pi;
                } else {
                  fci = pi;
                  vci = mi;
                }
                // Set the molecule index values for the bond
                vmi = molcomp_array[vci].peers[0];

                // Set the initial (relative) positions of the components with each molecule at (0,0)
                // set_component_positions_2D ( world, molcomp_array, num_parts );

                // Perform the bond (changes the locations)
                bind_molecules_at_components ( world, molcomp_array, num_parts, fci, vci, as3D, with_rot );

                // Set the variable molecule and its components to final
                molcomp_array[vmi].is_final = true;
                for (int vmici=0; vmici&lt;molcomp_array[vmi].num_peers; vmici++) {
                  molcomp_array[molcomp_array[vmi].peers[vmici]].is_final = true;
                }

              }
            }
          }
        }
      }
    }
  }

}


static external_molcomp_loc *build_molcomp_array ( struct volume *world, char **graph_strings ) {
  int part_num;
  char *next_part;

  /* Had trouble using the rng_state mechanism, skip for now
  if (rng == NULL) {
    rng = (rng_state *) malloc ( sizeof (struct rng_state) );
    rng_init ( rng, 12345 );
  }
  */

  part_num = 0;
  next_part = graph_strings[part_num];
  while (next_part != NULL) {
    part_num++;
    next_part = graph_strings[part_num];
  }

  // Allocate the entire block at once ...
  external_molcomp_loc *molcomp_loc_array = (external_molcomp_loc *) malloc ( part_num * sizeof(external_molcomp_loc) );

  // Copy the data into the block
  part_num = 0;
  next_part = graph_strings[part_num];
  while (next_part != NULL) {
    molcomp_loc_array[part_num].has_coords = 0;
    molcomp_loc_array[part_num].graph_string = (char *) malloc ( 1 + strlen(next_part) );
    strcpy ( molcomp_loc_array[part_num].graph_string, next_part );
    molcomp_loc_array[part_num].x = 0;
    molcomp_loc_array[part_num].y = 0;
    molcomp_loc_array[part_num].z = 0;
    molcomp_loc_array[part_num].states = NULL;
    if (strstr(next_part,&quot;m:&quot;) == next_part) {
      // This is a molecule
      molcomp_loc_array[part_num].is_mol = 1;
      // For molecules, the name ends with ! or possibly the end of the string
      if (strchr(next_part,'!') == NULL) {
        molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
        strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
      } else {
        char *end_point = strchr(next_part,'!');
        *end_point = '\0';
        molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
        strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
        *end_point = '!';
      }
      // Remove any @ portions if they exist
      char *at_sign = strchr(molcomp_loc_array[part_num].name, '@');
      if (at_sign != NULL) {
        // Make a copy up to that point
        *at_sign = '\0';
        char *shorter_name = (char *) malloc ( 1 + strlen(molcomp_loc_array[part_num].name) );
        strcpy ( shorter_name, molcomp_loc_array[part_num].name );
        *at_sign = '@';
        free ( molcomp_loc_array[part_num].name );
        molcomp_loc_array[part_num].name = shorter_name;
      }
      // Get the molecule's neighbors which should all be components
      molcomp_loc_array[part_num].num_peers = 0;
      molcomp_loc_array[part_num].peers = NULL;
      char *next_excl = strchr(next_part,'!');
      while (next_excl != NULL) {
        molcomp_loc_array[part_num].num_peers++;
        next_excl++;
        next_excl = strchr(next_excl,'!');
      }
      if (molcomp_loc_array[part_num].num_peers &gt; 0) {
        molcomp_loc_array[part_num].peers = (int *) malloc ( molcomp_loc_array[part_num].num_peers * sizeof(int) );
        next_excl = strchr(next_part,'!');
        int peer_num = 0;
        int comp_index;
        while (next_excl != NULL) {
          next_excl++;
          comp_index = atoi(next_excl);
          molcomp_loc_array[part_num].peers[peer_num] = comp_index;
          peer_num++;
          next_excl = strchr(next_excl,'!');
        }
      }
    } else {
      // This is a component
      molcomp_loc_array[part_num].is_mol = 0;
      char *first_exc = strchr(next_part,'!');
      char *first_til = strchr(next_part,'~');
      char *end_point;
      char previous_end;

      // For components, the name ends with ~ or ! or possibly the end of the string
      if ( (first_exc != NULL) &amp;&amp; (first_til != NULL) ) {
        // Use whichever comes first
        if (first_exc &lt; first_til) {
          end_point = first_exc;
        } else {
          end_point = first_til;
        }
      } else if (first_exc != NULL) {
        // Name ends at exc
        end_point = first_exc;
      } else if (first_til != NULL) {
        // Name ends at til
        end_point = first_til;
      } else {
        // Name ends at end of string
        end_point = strchr(next_part,'\0');
      }
      previous_end = *end_point;
      *end_point = '\0';
      molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
      strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
      *end_point = previous_end;

      // For components, the state starts with ~ and ends with ! or possibly the end of the string
      if (first_til != NULL) {
        // There are states on this component
        if (first_exc != NULL) {
          // The states are bounded between first_til and first_exc
          end_point = first_exc;
        } else {
          // The states are bounded between first_til and the end of the string
          end_point = strchr(next_part,'\0');
        }
        previous_end = *end_point;
        *end_point = '\0';
        molcomp_loc_array[part_num].states = (char *) malloc ( 1 + strlen(first_til) );
        strcpy ( molcomp_loc_array[part_num].states, first_til );
        *end_point = previous_end;
      }

      // Get the component's neighbors (the first will be the molecule)
      molcomp_loc_array[part_num].num_peers = 0;
      molcomp_loc_array[part_num].peers = NULL;
      char *next_excl = strchr(next_part,'!');
      while (next_excl != NULL) {
        molcomp_loc_array[part_num].num_peers++;
        next_excl++;
        next_excl = strchr(next_excl,'!');
      }
      if (molcomp_loc_array[part_num].num_peers &gt; 0) {
        molcomp_loc_array[part_num].peers = (int *) malloc ( molcomp_loc_array[part_num].num_peers * sizeof(int) );
        next_excl = strchr(next_part,'!');
        int peer_num = 0;
        int comp_index;
        while (next_excl != NULL) {
          next_excl++;
          comp_index = atoi(next_excl);
          molcomp_loc_array[part_num].peers[peer_num] = comp_index;
          peer_num++;
          next_excl = strchr(next_excl,'!');
        }
      }
    }
    part_num++;
    next_part = graph_strings[part_num];
  }
  // set_molcomp_positions_2D_first_try ( world, molcomp_loc_array, part_num );
  // Set the initial (relative) positions of the components with each molecule at (0,0)

  // set_component_positions_2D ( world, molcomp_loc_array, part_num );
  set_component_positions_by_table ( world, molcomp_loc_array, part_num );

  bind_all_molecules ( world, molcomp_loc_array, part_num, true, true );

  if (world-&gt;dump_level &gt;= 20) {
    fprintf ( stdout, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Final molcomp_loc_array &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot; );
    dump_molcomp_array ( molcomp_loc_array, part_num );
    fprintf ( stdout, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot; );
  }

  return molcomp_loc_array;
}


static char **get_graph_strings ( char *nauty_string ) {
  // Parse the graph pattern
  // This code assumes that the graph pattern ends with a comma!!
  int num_parts;
  int part_num;
  char **graph_parts;
  char *first, *last;

  // Start by just counting the parts
  part_num = 0;
  first = nauty_string;
  last = strchr ( first, ',' );
  while (last != NULL) {
    first = last+1;
    last = strchr ( first, ',' );
    part_num++;
  }
  num_parts = part_num;

  // Allocate the array and mark the end
  graph_parts = (char **) malloc ( (num_parts+1) * sizeof(char *) );
  graph_parts[num_parts] = NULL; // Marks the end of the &quot;list&quot;

  // Copy the parts into the array of strings
  part_num = 0;
  first = nauty_string;
  last = strchr ( first, ',' );
  while (last != NULL) {
    *last = '\0';
    char *s = (char *) malloc ( strlen(first) + 1 );
    strcpy ( s, first );
    graph_parts[part_num] = s;
    *last = ',';
    first = last+1;
    last = strchr ( first, ',' );
    part_num++;
  }

  return graph_parts;
}



static void free_graph_parts ( char **graph_parts ) {
  if (graph_parts != NULL) {
    int part_num = 0;
    char *next_part = graph_parts[part_num];
    while (next_part != NULL) {
      free ( next_part );
      part_num++;
      next_part = graph_parts[part_num];
    }
    free ( graph_parts );
  }
}


static void end_line_opt_comma ( FILE *space_struct_file, bool add_comma ) {
  if (add_comma) {
    fprintf ( space_struct_file, &quot;,&quot; );
  }
  fprintf ( space_struct_file, &quot;\n&quot; );
}

/************************************************************************
output_cellblender_molecules:
In: vizblk: VIZ_OUTPUT block for this frame list
    a frame data list (internal viz output data structure)
Out: 0 on success, 1 on failure.  The names and positions of molecules are
     output in binary format designed for fast visualization in CellBlender

     Format of binary file is:
       Header:
         A single four-byte u_int containing version number of binary file
         format. This is value less than or equal to 16777215, which is
         0x00ffffff.  This allows automagic detection of ASCII and binary
         format molecule viz files, as well as the endianness of the binary
         format files during molecule viz in CellBlender.
       Molecule Viz Data:
         Version 0x00000001 files contain a block of binary data for each
         molecule species structured as follows:

           A single byte containing the length of the ASCII string of the
           molecule species name or state value, not including the terminating
           NULL. 32 chars max.

           The ASCII string containing the molecule species name or state value,
           not including the terminating NULL. 32 chars max.

           A single byte containing the molecule species type.
           Type 0 means volume molecule.  Type 1 means surface surface molecule.

           A four-byte u_int, N, whose value is 3 times the number of molecules
           of this species contained in the block, i.e. the number of floats
           in the block for the x,y,z coordinates of the molecule positions.

           A block of N four-byte floats containing the x,y,z coordinates of
           the molecule positions.

           If the molecules are surface molecules then block of x,y,z positions
           is followed by another block of N four-byte floats containing the
           i,j,k components of the orientation vector of the surface molecules.

         Note that the end of the file is indicated by the usual EOF only.

*************************************************************************/
static int output_cellblender_molecules(struct volume *world,
                                        struct viz_output_block *vizblk,
                                        struct frame_data_list *fdlp) {

  no_printf(&quot;Output in CELLBLENDER mode (molecules only)...\n&quot;);

  if ( (world-&gt;dump_level &gt;= 20) &amp;&amp; (world-&gt;viz_options != VIZ_OPTS_NONE) ) {
    fprintf ( stdout, &quot;vizblk-&gt;file_prefix_name = \&quot;%s\&quot;\n&quot;, vizblk-&gt;file_prefix_name );
  }
  if ( (world-&gt;dump_level &gt;= 5) &amp;&amp; (world-&gt;viz_options != VIZ_OPTS_NONE) ) {
    fprintf ( stdout, &quot;Visualization Options = 0x%lx\n&quot;, world-&gt;viz_options );
    fprintf ( stdout, &quot;Proxy = 0x%lx\n&quot;, world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT );
  }
  if (world-&gt;dump_level &gt;= 50) {
    fprintf ( stdout, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Top of MolViz Output &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot; );
  }

  // Unfortunately, the file name in vizblk-&gt;file_prefix_name has the &quot;Scene&quot; attached to the end.
  // This makes it difficult to use to build other paths that don't have a &quot;Scene&quot; in them.
  // For example: vizblk-&gt;file_prefix_name = &quot;./viz_data/seed_00001/Scene&quot;
  // So this will take some string &quot;monkey business&quot; to fix
  // We want &quot;./viz_data/seed_#..#/ without the &quot;Scene&quot; attached
  char *file_prefix_no_Scene = NULL;
  char *file_prefix_usually_Scene = NULL;

  // Get the location of the last separator
  char *last_sep = strrchr ( vizblk-&gt;file_prefix_name, '/' );
  // Use the last_sep to copy the file part (usually Scene)
  file_prefix_usually_Scene = my_strcat ( last_sep+1, NULL );
  // Also use the last sep to copy the path part
  // Set it to \0 to mark the end of the string
  *last_sep = '\0';
  // Copy it with the desired prefix
  file_prefix_no_Scene = my_strcat ( vizblk-&gt;file_prefix_name, NULL );
  // Restore the vizblk-&gt;file_prefix_name
  *last_sep = '/';

  //fprintf ( stdout, &quot;path without file = %s\n&quot;, file_prefix_no_Scene );
  //fprintf ( stdout, &quot;file without path = %s\n&quot;, file_prefix_usually_Scene );

  if ((fdlp-&gt;type == ALL_MOL_DATA) || (fdlp-&gt;type == MOL_POS)) {

    long long lli = 10;
    int ndigits = 1;
    for (; lli &lt;= world-&gt;iterations &amp;&amp; ndigits &lt; 20;
         lli *= 10, ndigits++) {
    }
    char *cf_name =
        CHECKED_SPRINTF(&quot;%s.cellbin.%.*lld.dat&quot;, vizblk-&gt;file_prefix_name,
                        ndigits, fdlp-&gt;viz_iteration);
    if (cf_name == NULL)
      return 1;
    if (make_parent_dir(cf_name)) {
      free(cf_name);
      mcell_error(
          &quot;Failed to create parent directory for CELLBLENDER-mode VIZ output.&quot;);
      /*return 1;*/
    }
    FILE *custom_file = open_file(cf_name, &quot;wb&quot;);
    if (!custom_file)
      mcell_die();
    else {
      no_printf(&quot;Writing to file %s\n&quot;, cf_name);
    }
    free(cf_name);
    cf_name = NULL;

    FILE *space_struct_file = NULL;
    if (world-&gt;viz_options &amp; VIZ_ALT_FILES_MASK) {
      // Create the output files (format need not be determined yet)
      if (world-&gt;dump_level &gt;= 20) {
        fprintf ( stdout, &quot;Spatially Structured Option = 0x%lx\n&quot;, world-&gt;viz_options &amp; VIZ_ALT_FILES_MASK );
      }
      // Create the spatially structured mol file to hold the instances
      cf_name =
          CHECKED_SPRINTF(&quot;%s/viz_bngl/%s.bnglviz.%.*lld.dat&quot;, file_prefix_no_Scene, file_prefix_usually_Scene,
                          ndigits, fdlp-&gt;viz_iteration);
      if (cf_name == NULL)
        return 1;
      if (make_parent_dir(cf_name)) {
        free(cf_name);
        mcell_error(
            &quot;Failed to create parent directory for SPATIAL-mode VIZ output.&quot;);
        /*return 1;*/
      }
      space_struct_file = open_file(cf_name, &quot;wb&quot;);
      if (!space_struct_file) {
        mcell_die();
      } else {
        no_printf(&quot;Writing to file %s\n&quot;, cf_name);
      }
      free(cf_name);
      cf_name = NULL;
    }

    /* Get a list of molecules sorted by species. */
    u_int *viz_mol_count = NULL;
    struct abstract_molecule ***viz_molp = NULL;
    if (sort_molecules_by_species(
        world, vizblk, &amp;viz_molp, &amp;viz_mol_count, 1, 1)) {
      fclose(custom_file);
      custom_file = NULL;
      return 1;
    }

    /* Write file header(s) */
    u_int cellbin_version = 1;
    fwrite(&amp;cellbin_version, sizeof(cellbin_version), 1, custom_file);


    /* Write all the molecules whether EXTERNAL_SPECIES or not (for now) */

    for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {

      const unsigned int this_mol_count = viz_mol_count[species_idx];
      if (this_mol_count == 0)
        continue;

      const int id = vizblk-&gt;species_viz_states[species_idx];
      if (id == EXCLUDE_OBJ)
        continue;

      struct abstract_molecule **const mols = viz_molp[species_idx];
      if (mols == NULL)
        continue;

      struct abstract_molecule *amp = mols[0]; // Need to use one of the mols to get the flags
      if ( (world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT) || ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) == 0) ) {

        /* Write species name: */
        char mol_name[33];
        if (id == INCLUDE_OBJ) {
          /* encode name of species as ASCII string, 32 chars max */
          snprintf(mol_name, 33, &quot;%s&quot;, amp-&gt;properties-&gt;sym-&gt;name);
        } else {
          /* encode state value of species as ASCII string, 32 chars max */
          snprintf(mol_name, 33, &quot;%d&quot;, id);
        }
        byte name_len = strlen(mol_name);
        fwrite(&amp;name_len, sizeof(name_len), 1, custom_file);
        fwrite(mol_name, sizeof(char), name_len, custom_file);

        /* Write species type: */
        byte species_type = 0;
        if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
          species_type = 1;
        }
        fwrite(&amp;species_type, sizeof(species_type), 1, custom_file);

        /* write number of x,y,z floats for mol positions to follow: */
        u_int n_floats = 3 * this_mol_count;
        fwrite(&amp;n_floats, sizeof(n_floats), 1, custom_file);

        /* Write positions of volume and surface molecules: */
        float pos_x = 0.0;
        float pos_y = 0.0;
        float pos_z = 0.0;
        for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
          amp = mols[n_mol];
          /* This is a normal molecule so write it out. EXTERNAL_SPECIES will be written later */
          if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
            struct volume_molecule *mp = (struct volume_molecule *)amp;
            struct vector3 pos_output = {0.0, 0.0, 0.0};
            if (!convert_relative_to_abs_PBC_coords(
                world-&gt;periodic_box_obj,
                mp-&gt;periodic_box,
                world-&gt;periodic_traditional,
                &amp;mp-&gt;pos,
                &amp;pos_output)) {
              pos_x = pos_output.x;
              pos_y = pos_output.y;
              pos_z = pos_output.z;
            }
            else {
              pos_x = mp-&gt;pos.x;
              pos_y = mp-&gt;pos.y;
              pos_z = mp-&gt;pos.z;
            }

          } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
            struct surface_molecule *gmp = (struct surface_molecule *)amp;
            struct vector3 where;
            uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
            struct vector3 pos_output = {0.0, 0.0, 0.0};
            if (!convert_relative_to_abs_PBC_coords(
                world-&gt;periodic_box_obj,
                gmp-&gt;periodic_box,
                world-&gt;periodic_traditional,
                &amp;where,
                &amp;pos_output)) {
              pos_x = pos_output.x;
              pos_y = pos_output.y;
              pos_z = pos_output.z;
            }
            else {
              pos_x = where.x;
              pos_y = where.y;
              pos_z = where.z;
            }
          }

          pos_x *= world-&gt;length_unit;
          pos_y *= world-&gt;length_unit;
          pos_z *= world-&gt;length_unit;

          fwrite(&amp;pos_x, sizeof(pos_x), 1, custom_file);
          fwrite(&amp;pos_y, sizeof(pos_y), 1, custom_file);
          fwrite(&amp;pos_z, sizeof(pos_z), 1, custom_file);
        }

        /* Write orientations of surface surface molecules: */
        amp = mols[0];
        /* This is a normal molecule so write as needed. EXTERNAL_SPECIES will be written later */
        if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
          for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
            struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
            short orient = gmp-&gt;orient;
            float norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
<A NAME="0"></A>            float norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
            float norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1581-0.html#0',2,'match1581-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>            if (world-&gt;periodic_box_obj &amp;&amp; !(world-&gt;periodic_traditional)) {
              if (gmp-&gt;periodic_box-&gt;x % 2 != 0) {
                norm_x *= -1;
              }
              if (gmp-&gt;periodic_box-&gt;y % 2 != 0) {
                norm_y *= -1;
              }
              if (gmp-&gt;periodic_box-&gt;z % 2 != 0) {
                norm_z *= -1;
              }
            }</B></FONT>

            fwrite(&amp;norm_x, sizeof(norm_x), 1, custom_file);
            fwrite(&amp;norm_y, sizeof(norm_y), 1, custom_file);
            fwrite(&amp;norm_z, sizeof(norm_z), 1, custom_file);
          }
        }
      }

    } // for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {

    /* Add additional Viz blocks for all EXTERNAL_SPECIES molecules */
    /* Note that this could be done while processing normal molecules, but separating makes code clearer. */

    external_mol_viz_by_name *mol_name_list = NULL;

    for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
      const unsigned int this_mol_count = viz_mol_count[species_idx];

      if (this_mol_count == 0)
        continue;

      const int id = vizblk-&gt;species_viz_states[species_idx];
      if (id == EXCLUDE_OBJ)
        continue;

      struct abstract_molecule **const mols = viz_molp[species_idx];
      if (mols == NULL)
        continue;

      /* Get species name: */
      struct abstract_molecule *amp;
      amp = mols[0];
      char mol_name[33];
      if (id == INCLUDE_OBJ) {
        /* encode name of species as ASCII string, 32 chars max */
        snprintf(mol_name, 33, &quot;%s&quot;, amp-&gt;properties-&gt;sym-&gt;name);
      } else {
        /* encode state value of species as ASCII string, 32 chars max */
        snprintf(mol_name, 33, &quot;%d&quot;, id);
      }

      /* Get species type: */
      /*byte species_type = 0;*/
      /*if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {*/
      /*  species_type = 1;*/
      /*}*/

      /* Get and save positions of EXTERNAL_SPECIES volume and surface molecules: */
      for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
        amp = mols[n_mol];

        float pos_x = 0.0;
        float pos_y = 0.0;
        float pos_z = 0.0;
        float norm_x = 0.0;
        float norm_y = 0.0;
        float norm_z = 0.0;
        if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
          struct volume_molecule *mp = (struct volume_molecule *)amp;
          pos_x = mp-&gt;pos.x;
          pos_y = mp-&gt;pos.y;
          pos_z = mp-&gt;pos.z;
        } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
          struct surface_molecule *gmp = (struct surface_molecule *)amp;
          struct vector3 where;
          uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
          pos_x = where.x;
          pos_y = where.y;
          pos_z = where.z;
        }

        pos_x *= world-&gt;length_unit;
        pos_y *= world-&gt;length_unit;
        pos_z *= world-&gt;length_unit;

        char mol_type = 'v';
        if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
          mol_type = 's';
          struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
          short orient = gmp-&gt;orient;
          norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
          norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
          norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
        }

        float x_offset = 0.0;

        if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
          /* This is complex molecule, so add a new viz molecule for each molecule in the complex */
          /* The graph pattern will be something like: */
          /*    c:SH2~NO_STATE!5,c:U~NO_STATE!5!3,c:a~NO_STATE!6,c:b~Y!6!1,c:g~Y!6,m:Lyn@PM!0!1,m:Rec@PM!2!3!4, */
          char *next_mol = amp-&gt;graph_data-&gt;graph_pattern;

/* BEGIN NEW PROCESSING */
// fprintf ( stdout, &quot;=============== BEGIN NEW PROCESSING ===============\n&quot; );

          if (graph_pattern_table == NULL) {
            graph_pattern_table = init_symtab ( 10 );
          }

          struct sym_entry *sp;
          sp = retrieve_sym(next_mol, graph_pattern_table);

          if (sp == NULL) {

            // This pattern has not been saved yet, so parse it, save it, and possibly print it.
            // Note that patterns stored in the graph_pattern_table are never purged.
            // These patterns remain throughout the life of the simulation.

            char **graph_parts = get_graph_strings ( next_mol );

            // Print for use with external tools like the SpatialMols2D.java
            if (world-&gt;dump_level &gt;= 10) {
              fprintf ( stdout, &quot;=#= New Graph Pattern: %s\n&quot;, next_mol );
            }

            // Count the number of parts in graph_parts linked list
            int num_parts = 0;
            char *next_part = graph_parts[num_parts];
            while (next_part != NULL) {
              if (world-&gt;dump_level &gt;= 20) {
                fprintf ( stdout, &quot;  Graph Part %d: %s\n&quot;, num_parts, next_part );
              }
              num_parts++;
              next_part = graph_parts[num_parts];
            }

            external_molcomp_loc *molcomp_array = build_molcomp_array ( world, graph_parts );

            if (world-&gt;dump_level &gt;= 10) {
              fprintf ( stdout, &quot;=============== molcomp_array ===============\n&quot; );
              dump_molcomp_array ( molcomp_array, num_parts );
              fprintf ( stdout, &quot;=============================================\n&quot; );
            }


            molcomp_list *mcl = (molcomp_list *) malloc ( sizeof(molcomp_list) );
            mcl-&gt;molcomp_array = molcomp_array;
            mcl-&gt;num_molcomp_items = num_parts;
            mcl-&gt;molcomp_id = next_molcomp_id;
            next_molcomp_id += 1;


            //#### fprintf ( stdout, &quot;=============== molcomp_list ===============\n&quot; );
            //#### dump_molcomp_list ( mcl );
            //#### fprintf ( stdout, &quot;=============================================\n&quot; );

            /*   store_sym ( symbol,   sym_type, symbol_table,       data )  */
            sp = store_sym ( next_mol, VOID_PTR, graph_pattern_table, mcl );

            //#### fprintf ( stdout, &quot;=============== graph_pattern_table ===============\n&quot; );
            //#### dump_symtab ( graph_pattern_table );
            //#### fprintf ( stdout, &quot;===================================================\n&quot; );

            free_graph_parts ( graph_parts );
          }

          molcomp_list *mcl = NULL;
          if (sp != NULL) {
            mcl = (molcomp_list *) sp-&gt;value;
            // fprintf ( stdout, &quot;     sp: %s\n&quot;, mcl-&gt;name );
            // Look for component locations of all zero which indicates a non-spatial molecule
            int part_num;
            for (part_num = 0; part_num&lt;mcl-&gt;num_molcomp_items; part_num++) {
              // fprintf ( stdout, &quot;    Mol Viz part_num %d\n&quot;, part_num );
              if ( mcl-&gt;molcomp_array[part_num].is_mol == false ) {
                // Check component location
                if ((mcl-&gt;molcomp_array[part_num].x==0) &amp;&amp; (mcl-&gt;molcomp_array[part_num].y==0) &amp;&amp; (mcl-&gt;molcomp_array[part_num].z==0) ) {
                  // A component cannot be at the origin
                  mcl = NULL;
                  break;
                }
              }
            }
          }

          if (mcl != NULL) {

            // This is the normal path for spatially structured molecules

            // Note that this logic assumes that each part is either a molecule or a component
            // That's fine at the time of this design, but be aware that adding anything else
            //   that's other than a molecule or component may break this logic!!

            int part_num;

            for (part_num = 0; part_num&lt;mcl-&gt;num_molcomp_items; part_num++) {
              // fprintf ( stdout, &quot;    Mol Viz part_num %d\n&quot;, part_num );
              if ( mcl-&gt;molcomp_array[part_num].is_mol || (world-&gt;viz_options!=VIZ_OPTS_NONE) ) {
                // fprintf ( stdout, &quot;    mcl %s\n&quot;, mcl-&gt;molcomp_array[part_num].name );

                // Choose the name based on the type of item and the viz flags
                char *name_to_find_or_add = NULL;

                if (mcl-&gt;molcomp_array[part_num].is_mol) {

                  // Handle Molecule Viz

                  name_to_find_or_add = (char *) malloc (1+strlen(mcl-&gt;molcomp_array[part_num].name));
                  strcpy ( name_to_find_or_add, mcl-&gt;molcomp_array[part_num].name );

                } else {

                  // Handle Component Viz

                  int viz_naming_bits = world-&gt;viz_options &amp; VIZ_COMP_NAMING_MASK;

                  if (viz_naming_bits == VIZ_COMP_ALL_SAME) {
                    // Build a global component name alone (same glyph for all components and all molecules)
                    name_to_find_or_add = (char *) malloc (1+strlen(&quot;component&quot;));
                    strcpy ( name_to_find_or_add, &quot;component&quot; );
                  } else if (viz_naming_bits == VIZ_COMP_NAME_GLOBAL) {
                    // Build the name from the component name alone (same glyph for all components with this name across all molecules)
                    name_to_find_or_add = (char *) malloc (1+strlen(&quot;comp_&quot;)+strlen(mcl-&gt;molcomp_array[part_num].name));
                    strcpy ( name_to_find_or_add, &quot;comp_&quot; );
                    strcpy ( &amp;name_to_find_or_add[strlen(&quot;comp_&quot;)], mcl-&gt;molcomp_array[part_num].name );
                  } else if (viz_naming_bits == VIZ_COMP_MOL_LOCAL) {
                    // Build the name from the molecule name and the component name (glyph only applies to this mol/comp combination)
                    char *last_mol_name = NULL;
                    if (mcl-&gt;molcomp_array[part_num].num_peers &lt; 1) {
                      // This shouldn't happen ...
                      last_mol_name = (char *) malloc (1+strlen(&quot;unknown_&quot;));
                      strcpy ( last_mol_name, &quot;unknown_&quot; );
                    } else {
                      // Copy the molecule name
                      char *name_ptr = mcl-&gt;molcomp_array[mcl-&gt;molcomp_array[part_num].peers[0]].name;
                      last_mol_name = (char *) malloc (1+strlen(name_ptr));
                      strcpy ( last_mol_name, name_ptr );
                    }
                    name_to_find_or_add = (char *) malloc (1+strlen(last_mol_name)+strlen(&quot;_comp_&quot;)+strlen(mcl-&gt;molcomp_array[part_num].name));
                    strcpy ( name_to_find_or_add,                               last_mol_name );
                    strcpy ( &amp;name_to_find_or_add[strlen(name_to_find_or_add)], &quot;_comp_&quot; );
                    strcpy ( &amp;name_to_find_or_add[strlen(name_to_find_or_add)], mcl-&gt;molcomp_array[part_num].name );

                    if (last_mol_name != NULL) {
                      free ( last_mol_name );
                    }
                  }

                }

                /* Check to see if this name is already in the mol_name_list */
                external_mol_viz_by_name *next_mol_name = mol_name_list;
                int found = 0;
                // Check for the actual mol name being in the list
                do {
                  if (next_mol_name == NULL) {
                    break;
                  }
                  if (strcmp(name_to_find_or_add, next_mol_name-&gt;mol_name) == 0) {
                    found = 1;
                    break;
                  }
                  next_mol_name = next_mol_name-&gt;next_name;
                } while ( found == 0 );

                if (found == 0) {
                  /* This molecule or component name is not in the list, so add a new name to the front */
                  next_mol_name = (external_mol_viz_by_name *) malloc ( sizeof(external_mol_viz_by_name) );
                  next_mol_name-&gt;mol_name = name_to_find_or_add;  /* This takes &quot;ownership&quot; of the allocated &quot;name_to_find_or_add&quot; memory */
                  next_mol_name-&gt;mol_list = NULL;
                  next_mol_name-&gt;next_name = mol_name_list;
                  mol_name_list = next_mol_name;
                } else {
                  /* The name was already in the list so free the memory */
                  if (name_to_find_or_add != NULL) {
                    free ( name_to_find_or_add );
                    name_to_find_or_add = NULL;
                  }
                }

                /* next_mol_name now points to the list of molecules by this name */

                /* Make a new molecule viz item to store this location */
						    external_mol_viz *new_mol_viz_item = (external_mol_viz *) malloc ( sizeof(external_mol_viz) );

                /* Set its values */
                new_mol_viz_item-&gt;mol_type = mol_type;

                new_mol_viz_item-&gt;pos_x = pos_x + mcl-&gt;molcomp_array[part_num].x;
                new_mol_viz_item-&gt;pos_y = pos_y + mcl-&gt;molcomp_array[part_num].y;
                new_mol_viz_item-&gt;pos_z = pos_z + mcl-&gt;molcomp_array[part_num].z;

                // fprintf ( stdout, &quot;=MVM= Mol Viz Mol at: (%g,%g,%g)\n&quot;, new_mol_viz_item-&gt;pos_x, new_mol_viz_item-&gt;pos_y, new_mol_viz_item-&gt;pos_z );

                new_mol_viz_item-&gt;norm_x = norm_x;
                new_mol_viz_item-&gt;norm_y = norm_y;
                new_mol_viz_item-&gt;norm_z = norm_z;

                /* Add it to the top of the molecule list. This takes ownership of the allocated memory. */
                new_mol_viz_item-&gt;next_mol = next_mol_name-&gt;mol_list;
                next_mol_name-&gt;mol_list = new_mol_viz_item;

                next_mol += 1;

              }
            }

// fprintf ( stdout, &quot;=============== END NEW PROCESSING ===============\n&quot; );

/* END NEW PROCESSING */

          } else {

            // Arriving here means that the molecules are non-spatial (at least one component is at the origin)

            while ((next_mol = strstr(next_mol,&quot;m:&quot;)) != NULL ) {
              /* Pull the next actual molecule name out of the graph pattern */
              char *end_mol = strpbrk ( next_mol, &quot;@!,(~&quot; );
              if (end_mol == NULL) {
                end_mol = next_mol + strlen(next_mol);
              }
              int ext_name_len = end_mol - next_mol;
              char *ext_name = (char *) malloc ( ext_name_len + 1 );
              strncpy ( ext_name, next_mol+2, ext_name_len-2 );
              ext_name[ext_name_len-2] = '\0';

              /* Check to see if this name is already in the list */
              external_mol_viz_by_name *next_mol_name = mol_name_list;
              int found = 0;
              do {
                if (next_mol_name == NULL) {
                  break;
                }
                if (strcmp(ext_name, next_mol_name-&gt;mol_name) == 0) {
                  found = 1;
                  break;
                }
                next_mol_name = next_mol_name-&gt;next_name;
              } while ( found == 0 );

              if (found == 0) {
                /* This molecule name is not in the list, so add a new name to the front */
                next_mol_name = (external_mol_viz_by_name *) malloc ( sizeof(external_mol_viz_by_name) );
                next_mol_name-&gt;mol_name = ext_name;  /* This takes &quot;ownership&quot; of the allocated name memory */
                next_mol_name-&gt;mol_list = NULL;
                next_mol_name-&gt;next_name = mol_name_list;
                mol_name_list = next_mol_name;
              } else {
                /* This molecule name is already in the list and next_mol_name points to it, so just free the name. */
                free ( ext_name );
              }

              /* next_mol_name now points to the list of molecules by this name */

              /* Make a new molecule viz item to store this location */
						  external_mol_viz *new_mol_viz_item = (external_mol_viz *) malloc ( sizeof(external_mol_viz) );

              /* Set its values */
              new_mol_viz_item-&gt;mol_type = mol_type;

              new_mol_viz_item-&gt;pos_x = pos_x + x_offset; //   x_offset += 0.008;
              new_mol_viz_item-&gt;pos_y = pos_y;
              new_mol_viz_item-&gt;pos_z = pos_z;

              new_mol_viz_item-&gt;norm_x = norm_x;
              new_mol_viz_item-&gt;norm_y = norm_y;
              new_mol_viz_item-&gt;norm_z = norm_z;

              /* Add it to the top of the molecule list */
              new_mol_viz_item-&gt;next_mol = next_mol_name-&gt;mol_list;
              next_mol_name-&gt;mol_list = new_mol_viz_item;

              next_mol += 1;
            }

          }

        }
      }
    }

    /* Write out the molecules with their proper names */
    external_mol_viz_by_name *nl = mol_name_list;
    external_mol_viz *mv;

    while (nl != NULL) {

      if ( (world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT) || ( (strcmp(nl-&gt;mol_name,&quot;volume_proxy&quot;)!=0) &amp;&amp; (strcmp(nl-&gt;mol_name,&quot;volume_proxy&quot;)!=0) ) ) {

        /* Write the name length and name */
        byte name_len = strlen(nl-&gt;mol_name);
        fwrite(&amp;name_len, sizeof(name_len), 1, custom_file);
        fwrite(nl-&gt;mol_name, sizeof(char), name_len, custom_file);

        /* Write species type: */
        byte species_type = 0;
        if (nl-&gt;mol_list != NULL) {
          if (nl-&gt;mol_list-&gt;mol_type == 's') {
            species_type = 1;
          }
        }
        fwrite(&amp;species_type, sizeof(species_type), 1, custom_file);

        /* write number of x,y,z floats for mol positions to follow: */
        u_int n_floats = 0;
        mv = nl-&gt;mol_list;
        while (mv != NULL) {
          n_floats += 3;
          mv = mv-&gt;next_mol;
        }
        fwrite(&amp;n_floats, sizeof(n_floats), 1, custom_file);

        /* Write positions of volume and surface molecules: */
        mv = nl-&gt;mol_list;
        while (mv != NULL) {
          float pos_x = mv-&gt;pos_x;
          float pos_y = mv-&gt;pos_y;
          float pos_z = mv-&gt;pos_z;
          fwrite(&amp;pos_x, sizeof(pos_x), 1, custom_file);
          fwrite(&amp;pos_y, sizeof(pos_y), 1, custom_file);
          fwrite(&amp;pos_z, sizeof(pos_z), 1, custom_file);
          mv = mv-&gt;next_mol;
        }
        /* Write orientations of surface surface molecules: */
        mv = nl-&gt;mol_list;
        if (mv-&gt;mol_type == 's') {
          while (mv != NULL) {
            float norm_x = mv-&gt;norm_x;
            float norm_y = mv-&gt;norm_y;
            float norm_z = mv-&gt;norm_z;
            fwrite(&amp;norm_x, sizeof(norm_x), 1, custom_file);
            fwrite(&amp;norm_y, sizeof(norm_y), 1, custom_file);
            fwrite(&amp;norm_z, sizeof(norm_z), 1, custom_file);
            mv = mv-&gt;next_mol;
          }
        }
        nl = nl-&gt;next_name;

      }

    }


    /*****************************************************/
    /******** Write the new BNGL Viz format files ********/
    /*****************************************************/

    if (space_struct_file != NULL) {

      if ( world-&gt;viz_options &amp; VIZ_ALT_DUMP_FMT ) {

        // Write the data in a human readable format

        u_int ss_version = 2;
        // fwrite(&amp;ss_version, sizeof(ss_version), 1, space_struct_file );
        fprintf ( space_struct_file, &quot;%d\n&quot;, ss_version );

        if (graph_pattern_table != NULL) {
          // Traverse the symbol table to build a dictionary of molecule types
          // A sym_table_head has: sym_entry **entries
          //   First dimension is n_bins
          //   Second dimension is a linked list
          // fprintf ( stdout, &quot;] ] ] ] ] ] ] ] graph pattern table has %d entries in %d bins\n&quot;, graph_pattern_table-&gt;n_entries, graph_pattern_table-&gt;n_bins );

          for (int bin=0; bin&lt;graph_pattern_table-&gt;n_bins; bin++) {
            if (graph_pattern_table-&gt;entries[bin] != NULL) {
              // fprintf ( stdout, &quot;  bin %d is non-empty\n&quot;, bin );
              struct sym_entry *se = graph_pattern_table-&gt;entries[bin];
              while (se != NULL) {
                // fprintf ( stdout, &quot;   entry: %.200s\n&quot;, se-&gt;name );
                fprintf ( space_struct_file, &quot;Entry: %s\n&quot;, se-&gt;name );
                molcomp_list *mcl = (molcomp_list *) se-&gt;value;
                // fprintf ( stdout, &quot;=============== MOL From graph_pattern_table ===============\n&quot; );
                dump_molcomp_list_to ( space_struct_file, mcl );
                se = se-&gt;next;
              }
            }
          }
        }

        /* Start with a simple output format */
        for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {

          const unsigned int this_mol_count = viz_mol_count[species_idx];

          if (this_mol_count == 0)
            continue;

          const int id = vizblk-&gt;species_viz_states[species_idx];
          if (id == EXCLUDE_OBJ)
            continue;

          struct abstract_molecule **const mols = viz_molp[species_idx];
          if (mols == NULL)
            continue;

          /* Get and save positions of EXTERNAL_SPECIES volume and surface molecules: */
          struct abstract_molecule *amp;

          for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {

            amp = mols[n_mol];

            if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {

              /* This is complex molecule */
              /* The graph pattern will be something like: */
              /*    c:SH2~NO_STATE!5,c:U~NO_STATE!5!3,c:a~NO_STATE!6,c:b~Y!6!1,c:g~Y!6,m:Lyn@PM!0!1,m:Rec@PM!2!3!4, */

              char *gp = amp-&gt;graph_data-&gt;graph_pattern;

              // Write out text for now

              // fprintf ( space_struct_file, &quot;Mol Instance %d, name: %.80s\n&quot;, n_mol, gp );

              long mol_class = -1;

              if (graph_pattern_table != NULL) {

                struct sym_entry *sp;
                sp = retrieve_sym(gp, graph_pattern_table);

                if (sp != NULL) {
                  molcomp_list *mcl = NULL;
                  mcl = (molcomp_list *) sp-&gt;value;
                  mol_class = -1 * mcl-&gt;molcomp_id;  // The code to handle this is only implemented in the JSON branch at this time
                  // fprintf ( stdout, &quot;=============== MOL From graph_pattern_table ===============\n&quot; );
                  // dump_molcomp_list_to ( space_struct_file, mcl );
                }
              }

              // fprintf ( space_struct_file, &quot;  Mol Class = %ld\n&quot;, mcl-&gt;molcomp_id );

              float pos_x = 0.0;
              float pos_y = 0.0;
              float pos_z = 0.0;
              float norm_x = 0.0;
              float norm_y = 0.0;
              float norm_z = 0.0;
              if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
                struct volume_molecule *mp = (struct volume_molecule *)amp;
                pos_x = mp-&gt;pos.x;
                pos_y = mp-&gt;pos.y;
                pos_z = mp-&gt;pos.z;
              } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
                struct surface_molecule *gmp = (struct surface_molecule *)amp;
                struct vector3 where;
                uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
                pos_x = where.x;
                pos_y = where.y;
                pos_z = where.z;
              }

              pos_x *= world-&gt;length_unit;
              pos_y *= world-&gt;length_unit;
              pos_z *= world-&gt;length_unit;

              if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
                struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
                short orient = gmp-&gt;orient;
                norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
                norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
                norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
              }

              fprintf ( space_struct_file, &quot;Mol %d:  Class=%ld  Position=(%g %g %g)  Orientation=(%g %g %g)\n&quot;, n_mol, mol_class, pos_x, pos_y, pos_z, norm_x, norm_y, norm_z );
            }
          }
        }
        fflush ( space_struct_file );
        fclose ( space_struct_file );

      } else if ( world-&gt;viz_options &amp; VIZ_JSON_MOLCOMP_FMT ) {

        // Write the data as a JSON MOLCOMP format (list of lists)

        int *gp_entry_for_id = NULL;  // Graph Pattern Entry: Mapping from IDs to the index in the table

        fprintf ( space_struct_file, &quot;[\n&quot; );    // Start of entire file as a single list
        fprintf ( space_struct_file, &quot; 2,\n&quot; );  // File format number
        fprintf ( space_struct_file, &quot; [\n&quot; );   // Start of molecule definitions

        if (graph_pattern_table != NULL) {
          // Traverse the symbol table to build a dictionary of molecule types
          // A sym_table_head has: sym_entry **entries
          //   First dimension is n_bins
          //   Second dimension is a linked list
          // fprintf ( stdout, &quot;] ] ] ] ] ] ] ] graph pattern table has %d entries in %d bins\n&quot;, graph_pattern_table-&gt;n_entries, graph_pattern_table-&gt;n_bins );

          int n_gp_entries = graph_pattern_table-&gt;n_entries;
          int gp_entry_num = 0;

          gp_entry_for_id = (int *) malloc ( n_gp_entries * sizeof(int) ); // This is the mapping from ids to index in the table

          for (int bin=0; bin&lt;graph_pattern_table-&gt;n_bins; bin++) {
            if (graph_pattern_table-&gt;entries[bin] != NULL) {
              // fprintf ( stdout, &quot;  bin %d is non-empty\n&quot;, bin );
              struct sym_entry *se = graph_pattern_table-&gt;entries[bin];
              while (se != NULL) {
                // fprintf ( stdout, &quot;   entry: %.200s\n&quot;, se-&gt;name );
                // fprintf ( space_struct_file, &quot;Entry: %s\n&quot;, se-&gt;name );
                molcomp_list *mcl = (molcomp_list *) se-&gt;value;
                gp_entry_for_id[mcl-&gt;molcomp_id] = gp_entry_num;  // Set the table entry for this id
                external_molcomp_loc *mca = mcl-&gt;molcomp_array;
                int num_parts = mcl-&gt;num_molcomp_items;
                // fprintf ( stdout, &quot;=============== MOL From graph_pattern_table ===============\n&quot; );
                {
                  int i, j;
                  fprintf ( space_struct_file, &quot;  [\n&quot; );  // Start of a complex
                  for (i=0; i&lt;num_parts; i++) {
                    fprintf ( space_struct_file, &quot;   [ &quot; );  // Start of a molecule or component
                    if (mca[i].is_mol) {
                      fprintf ( space_struct_file, &quot;\&quot;m\&quot;&quot; );
                    } else {
                      fprintf ( space_struct_file, &quot;\&quot;c\&quot;&quot; );
                    }
                    fprintf ( space_struct_file, &quot;, \&quot;%s\&quot;&quot;, mca[i].name );
                    fprintf ( space_struct_file, &quot;, [%g, %g, %g], [&quot;, mca[i].x, mca[i].y, mca[i].z );
                    for (j=0; j&lt;mca[i].num_peers; j++) {
                      fprintf ( space_struct_file, &quot;%d&quot;, mca[i].peers[j] );
                      if (j &lt; mca[i].num_peers - 1) {
                        fprintf ( space_struct_file, &quot;,&quot; );
                      }
                    }
                    if (mca[i].states == NULL) {
                      fprintf ( space_struct_file, &quot;], \&quot;\&quot; ]&quot; );  // End of a molecule or component with no states
                    } else if (strcmp(mca[i].states,&quot;~NO_STATE&quot;)==0) {
                      fprintf ( space_struct_file, &quot;], \&quot;\&quot; ]&quot; );  // End of a molecule or component with no states
                    } else {
                      fprintf ( space_struct_file, &quot;], \&quot;%s\&quot; ]&quot;, mca[i].states );  // End of a molecule or component with states
                    }
                    end_line_opt_comma ( space_struct_file, i &lt; (num_parts-1) );
                  }
                  fprintf ( space_struct_file, &quot;  ]&quot; );  // End of a complex
                  gp_entry_num++;
                  end_line_opt_comma ( space_struct_file, gp_entry_num &lt; n_gp_entries );
                }

                // dump_molcomp_list_to ( space_struct_file, mcl );

                se = se-&gt;next;
              }
            }
          }

        }

        fprintf ( space_struct_file, &quot; ],\n&quot; );  // End of molecule definitions

        /* Write the molecule instances */

        fprintf ( space_struct_file, &quot; [&quot; );  // Start of instances - newlines will be added as new elements are added to handle commas
        int first_pass = 1;

        for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {

          const unsigned int this_mol_count = viz_mol_count[species_idx];

          if (this_mol_count == 0)
            continue;

          const int id = vizblk-&gt;species_viz_states[species_idx];
          if (id == EXCLUDE_OBJ)
            continue;

          struct abstract_molecule **const mols = viz_molp[species_idx];
          if (mols == NULL)
            continue;

          /* Get and save positions of EXTERNAL_SPECIES volume and surface molecules: */
          struct abstract_molecule *amp;

          for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {

            amp = mols[n_mol];

            if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {

              /* This is complex molecule */
              /* The graph pattern will be something like: */
              /*    c:SH2~NO_STATE!5,c:U~NO_STATE!5!3,c:a~NO_STATE!6,c:b~Y!6!1,c:g~Y!6,m:Lyn@PM!0!1,m:Rec@PM!2!3!4, */

              char *gp = amp-&gt;graph_data-&gt;graph_pattern;

              // Write out text for now

              // fprintf ( space_struct_file, &quot;Mol Instance %d, name: %.80s\n&quot;, n_mol, gp );

              long mol_class = -1;

              if (graph_pattern_table != NULL) {

                struct sym_entry *sp;
                sp = retrieve_sym(gp, graph_pattern_table);

                if (sp != NULL) {
                  molcomp_list *mcl = NULL;
                  mcl = (molcomp_list *) sp-&gt;value;
                  mol_class = gp_entry_for_id[mcl-&gt;molcomp_id];
                  // fprintf ( stdout, &quot;=============== MOL From graph_pattern_table ===============\n&quot; );
                  // dump_molcomp_list_to ( space_struct_file, mcl );
                }
              }

              // fprintf ( space_struct_file, &quot;  Mol Class = %ld\n&quot;, mcl-&gt;molcomp_id );

              float pos_x = 0.0;
              float pos_y = 0.0;
              float pos_z = 0.0;
              float norm_x = 0.0;
              float norm_y = 0.0;
              float norm_z = 0.0;
              if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
                struct volume_molecule *mp = (struct volume_molecule *)amp;
                pos_x = mp-&gt;pos.x;
                pos_y = mp-&gt;pos.y;
                pos_z = mp-&gt;pos.z;
              } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
                struct surface_molecule *gmp = (struct surface_molecule *)amp;
                struct vector3 where;
                uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
                pos_x = where.x;
                pos_y = where.y;
                pos_z = where.z;
              }

              pos_x *= world-&gt;length_unit;
              pos_y *= world-&gt;length_unit;
              pos_z *= world-&gt;length_unit;

              if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
                struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
                short orient = gmp-&gt;orient;
                norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
                norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
                norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
              }

              if ( first_pass ) {
                fprintf ( space_struct_file, &quot;\n&quot; );  // End the previous line without a comma
                first_pass = 0;
              } else {
                fprintf ( space_struct_file, &quot;,\n&quot; );  // End the previous line with a comma
              }

              // fprintf ( space_struct_file, &quot;  Mol %d:  Class=%ld  Position=(%g %g %g)  Orientation=(%g %g %g)\n&quot;, n_mol, mol_class, pos_x, pos_y, pos_z, norm_x, norm_y, norm_z );
              fprintf ( space_struct_file, &quot;  [%ld,[%g,%g,%g],[%g,%g,%g]]&quot;, mol_class, pos_x, pos_y, pos_z, norm_x, norm_y, norm_z );
              // It's not clear why this should be (species_idx&lt;(world-&gt;n_species-2). Why -2 and not -1? Is there an extra species?
              // end_line_opt_comma ( space_struct_file, (species_idx&lt;(world-&gt;n_species-2)) || (n_mol &lt; (this_mol_count-1)) );
            }
          }
        }

        fprintf ( space_struct_file, &quot;\n ]\n&quot; );  // End of instances

        fprintf ( space_struct_file, &quot;]\n&quot; );  // End of entire file as a single list

        fflush ( space_struct_file );
        fclose ( space_struct_file );

        if ( gp_entry_for_id != NULL ) {
          free ( gp_entry_for_id );
        }

      }
    }

    /* Free the structures used to build the molecule lists from the complexes */
    while (mol_name_list != NULL) {
      nl = mol_name_list;
      /* Free the name block */
      free ( nl-&gt;mol_name );
      /* Free the list of molecule instances */
      while (nl-&gt;mol_list != NULL) {
        mv = nl-&gt;mol_list;
        nl-&gt;mol_list = mv-&gt;next_mol;
        free ( mv );
      }
      mol_name_list = nl-&gt;next_name;
      free ( nl );
    }

    fclose(custom_file);
    custom_file = NULL;

    free_ptr_array((void **)viz_molp, world-&gt;n_species);
    viz_molp = NULL;
    free(viz_mol_count);
    viz_mol_count = NULL;

  } // if ((fdlp-&gt;type == ALL_MOL_DATA) || (fdlp-&gt;type == MOL_POS)) {

  free ( file_prefix_no_Scene );
  free ( file_prefix_usually_Scene );

  if (world-&gt;dump_level &gt;= 50) {
    fprintf ( stdout, &quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Bottom of MolViz Output &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n&quot; );
  }

  return 0;
}

/*********************************************************************
init_frame_data_list:

   In: vizblk: the VIZ_OUTPUT block to initialize
   Out: 0 on success, 1 on error.
        Initializes frame_data_list structure.
        Sets the value of the current iteration step to the start value.
        Sets the number of iterations.
***********************************************************************/
int init_frame_data_list(struct volume *world,
                         struct viz_output_block *vizblk) {
  int mol_orient_frame_present = 0;
  int mol_pos_frame_present = 0;
  struct frame_data_list *fdlp;

  if (vizblk-&gt;frame_data_head == NULL)
    return 0;

  switch (vizblk-&gt;viz_mode) {
  case NO_VIZ_MODE:
    count_time_values(world, vizblk-&gt;frame_data_head);
    if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
      return 1;
    break;
  //      return 0;

  case ASCII_MODE:
    count_time_values(world, vizblk-&gt;frame_data_head);
    if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
      return 1;
    break;

  case CELLBLENDER_MODE_V1:
    count_time_values(world, vizblk-&gt;frame_data_head);
    if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
      return 1;
    break;

  default:
    count_time_values(world, vizblk-&gt;frame_data_head);
    if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
      return 1;
    break;
  }

  for (fdlp = vizblk-&gt;frame_data_head; fdlp != NULL; fdlp = fdlp-&gt;next) {
    if (fdlp-&gt;curr_viz_iteration == NULL)
      continue;

    switch (fdlp-&gt;type) {
    case MOL_ORIENT:
      mol_orient_frame_present = 1;
      break;

    case MOL_POS:
      mol_pos_frame_present = 1;
      break;

    case ALL_MOL_DATA:
      mol_pos_frame_present = 1;
      mol_orient_frame_present = 1;
      break;

    default:
      /* Do nothing */
      ;
    }
  } /* end while */

  /* Check that the user hasn't selected a useless set of output info */
  if ((mol_orient_frame_present) &amp; (!mol_pos_frame_present))
    mcell_warn(&quot;The input file contains ORIENTATIONS but not POSITIONS &quot;
               &quot;statement in the MOLECULES block. The molecules cannot be &quot;
               &quot;visualized.&quot;);

  return 0;
}

/**************************************************************************
update_frame_data_list:
        In: vizblk: VIZ_OUTPUT block
        Out: 0 on success, 1 on failure.
             Calls output visualization functions if necessary.
             Updates value of the current iteration step and pointer
             to the current iteration in the linked list.
**************************************************************************/
int update_frame_data_list(struct volume *world,
                           struct viz_output_block *vizblk) {
  static char const *const FRAME_TYPES[NUM_FRAME_TYPES] = {
    &quot;MOL_POS&quot;,  &quot;MOL_ORIENT&quot;, &quot;ALL_MOL_DATA&quot;, 
  };

  if (vizblk == NULL)
    return 0;
  if (vizblk-&gt;frame_data_head == NULL)
    return 0;

  switch (world-&gt;notify-&gt;viz_output_report) {
  case NOTIFY_NONE:
    break;

  case NOTIFY_BRIEF:
  case NOTIFY_FULL:
    mcell_log(&quot;Updating viz output on iteration %lld.&quot;, world-&gt;current_iterations);
    break;

  default:
    UNHANDLED_CASE(world-&gt;notify-&gt;viz_output_report);
  }

  /* Scan over all frames, producing appropriate output. */
  for (struct frame_data_list *fdlp = vizblk-&gt;frame_data_head; fdlp != NULL;
       fdlp = fdlp-&gt;next) {
    if (world-&gt;current_iterations != fdlp-&gt;viz_iteration)
      continue;

    if (world-&gt;notify-&gt;viz_output_report == NOTIFY_FULL) {
      if (fdlp-&gt;type &gt;= NUM_FRAME_TYPES)
        mcell_warn(&quot;  Updating data frame of unknown type %d.&quot;, fdlp-&gt;type);
      else
        mcell_log(&quot;  Updating data frame of type %s.&quot;, FRAME_TYPES[fdlp-&gt;type]);
    }

    switch (vizblk-&gt;viz_mode) {
    case ASCII_MODE:
      if (output_ascii_molecules(world, vizblk, fdlp))
        return 1;
      break;

    case CELLBLENDER_MODE_V1:
      if (output_cellblender_molecules(world, vizblk, fdlp))
        return 1;
      break;

    case NO_VIZ_MODE:
    default:
      /* Do nothing for vizualization */
      break;
    }

    while (fdlp-&gt;curr_viz_iteration != NULL &amp;&amp;
           fdlp-&gt;viz_iteration == world-&gt;current_iterations) {
      fdlp-&gt;curr_viz_iteration = fdlp-&gt;curr_viz_iteration-&gt;next;
      if (fdlp-&gt;curr_viz_iteration)
        fdlp-&gt;viz_iteration = frame_iteration(
            world, fdlp-&gt;curr_viz_iteration-&gt;value, fdlp-&gt;list_type);
    }
    if (world-&gt;notify-&gt;viz_output_report == NOTIFY_FULL)
      mcell_log(&quot;  Next update on iteration %lld.&quot;, fdlp-&gt;viz_iteration);
  }
  return 0;
}

/**************************************************************************
finalize_viz_output:
        In: vizblk: VIZ_OUTPUT block
        Out: Returns 1 on error and zero otherwise. Writes final information
             into visualization output files.
**************************************************************************/
int finalize_viz_output(struct volume *world, struct viz_output_block *vizblk) {
  if (vizblk == NULL)
    return 0;

  switch (vizblk-&gt;viz_mode) {
  case NO_VIZ_MODE:
  case ASCII_MODE:
  default:
    /* Do nothing for vizualization */
    break;
  }

  return 0;
}
</PRE>
</div>
  </div>
</body>
</html>
