<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for defines.h &amp; viz_output.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for defines.h &amp; viz_output.c
      </h3>
<h1 align="center">
        0.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>defines.h (1.4098691%)<th>viz_output.c (0.58848256%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(811-821)<td><a href="#" name="0">(1606-1616)</a><td align="center"><font color="#ff0000">14</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>defines.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef SRC4_DEFINES_H_
#define SRC4_DEFINES_H_
#include &lt;stdint.h&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include "mcell_structs_shared.h"
#include "debug_config.h"
#include "../libs/glm/glm.hpp"
#define GLM_ENABLE_EXPERIMENTAL
#include "../libs/glm/gtx/component_wise.hpp"
#include "bng/shared_defines.h" 
#if defined(NDEBUG) &amp;&amp; defined(INDEXER_WA)
#warning "INDEXER_WA is enabled and this will lead to lower performance"
#endif
#ifndef INDEXER_WA
#include &lt;boost/container/small_vector.hpp&gt;
#include &lt;boost/container/flat_set.hpp&gt;
#endif
namespace MCell {
using BNGCommon::f_to_str;
using BNGCommon::EPS;
using BNGCommon::SQRT_EPS;
using BNGCommon::DBL_GIGANTIC;
using BNGCommon::pos_t;
using BNGCommon::POS_EPS;
using BNGCommon::POS_SQRT_EPS;
using BNGCommon::POS_GIGANTIC;
using BNGCommon::stime_t;
using BNGCommon::STIME_EPS;
using BNGCommon::STIME_SQRT_EPS;
using BNGCommon::STIME_GIGANTIC;
using BNGCommon::fabs_f;
using BNGCommon::cmp_eq;
using BNGCommon::distinguishable_p;
using BNGCommon::distinguishable_f;
using BNGCommon::sqrt_f;
using BNGCommon::pow_f;
using BNGCommon::floor_f;
using BNGCommon::round_f;
using BNG::species_id_t;
using BNG::SPECIES_ID_INVALID;
using BNG::orientation_t;
using BNG::ORIENTATION_DOWN;
using BNG::ORIENTATION_NONE;
using BNG::ORIENTATION_UP;
using BNG::ORIENTATION_NOT_SET;
using BNG::ORIENTATION_DEPENDS_ON_SURF_COMP;
const double MIN_WALL_GAP = 1e-4; 
#if defined(likely) || defined(unlikely)
#error "Macros 'likely' or 'unlikely' are already defined"
#endif
#ifndef _MSC_VER
#define likely(x)       __builtin_expect((x),1)
#define unlikely(x)     __builtin_expect((x),0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
const double SCHEDULER_COMPARISON_EPS = 1e-10;
const size_t SCHEDULER_MAX_BUCKETS_TO_FUTURE = 100000000;
const double MESH_DISTINCTIVE_EPS = EPS;
const uint SORT_MOLS_BY_SUBPART_PERIODICITY = 20;
const uint DEFRAGMENTATION_PERIODICITY = 100;
const pos_t PARTITION_EDGE_LENGTH_DEFAULT_UM = 10; const pos_t PARTITION_EDGE_EXTRA_MARGIN_UM = 0.01;
const uint SUBPARTITIONS_PER_PARTITION_DIMENSION_DEFAULT = 1;
const uint MAX_SUBPARTS_PER_PARTITION = 300;
const double COUNT_BUFFER_FLUSH_SECONDS = 60;
const uint64_t ITERATIONS_BEFORE_RUN_N_ITERATIONS_END_EVENT = 10000;
const uint64_t DEFAULT_MOL_ORDER_SHUFFLE_PERIODICITY = 10000;
const pos_t POS_INVALID = FLT_MAX; const pos_t LENGTH_INVALID = FLT_MAX;
const double TIME_INVALID = -256;
const double TIME_FOREVER = 1e20; const double TIME_SIMULATION_START = 0;
const pos_t POS_SQRT2 = 1.41421356238;
const pos_t POS_RXN_RADIUS_MULTIPLIER = 1.3; 
const uint INT_INVALID = INT32_MAX;
typedef uint molecule_id_t;
const molecule_id_t MOLECULE_ID_INVALID = ID_INVALID;
typedef std::vector&lt;molecule_id_t&gt; MoleculeIdsVector;
typedef uint_set&lt;molecule_id_t&gt; MoleculeIdsSet;
typedef uint molecule_index_t;
const molecule_index_t MOLECULE_INDEX_INVALID = INDEX_INVALID;
typedef uint partition_id_t;
const partition_id_t PARTITION_ID_INITIAL = 0;
const partition_id_t PARTITION_ID_INVALID = INDEX_INVALID;
typedef uint subpart_index_t;
const subpart_index_t SUBPART_INDEX_INVALID = INDEX_INVALID;
const uint TIME_STEP_INDEX_INVALID = INDEX_INVALID;
const char* const NAME_INVALID = "name_invalid";
const char* const NAME_NOT_SET = "name_not_set";
const uint64_t BUCKET_INDEX_INVALID = UINT64_MAX;
const uint VERTICES_IN_TRIANGLE = 3;
const uint EDGES_IN_TRIANGLE = VERTICES_IN_TRIANGLE; 
typedef uint vertex_index_t; const vertex_index_t VERTEX_INDEX_INVALID = INDEX_INVALID;
typedef uint wall_index_t; const wall_index_t WALL_INDEX_INVALID = INDEX_INVALID;
typedef uint tile_index_t; const tile_index_t TILE_INDEX_INVALID = INDEX_INVALID;
typedef uint edge_index_t; const edge_index_t EDGE_INDEX_0 = 0;
const edge_index_t EDGE_INDEX_1 = 1;
const edge_index_t EDGE_INDEX_2 = 2;
const edge_index_t EDGE_INDEX_WITHIN_WALL = 3; const edge_index_t EDGE_INDEX_CANNOT_TELL = 4;
const edge_index_t EDGE_INDEX_INVALID = INDEX_INVALID;
typedef uint count_buffer_id_t; const count_buffer_id_t COUNT_BUFFER_ID_INVALID = INDEX_INVALID;
typedef uint rgba_t; const rgba_t DEFAULT_COLOR = 0xFFFFFF3F; 
class WallTileIndexPair {
public:
  WallTileIndexPair()
    : wall_index(WALL_INDEX_INVALID), tile_index(TILE_INDEX_INVALID)
    {
  }
  WallTileIndexPair(const wall_index_t wall_index_, const tile_index_t tile_index_)
    : wall_index(wall_index_), tile_index(tile_index_)
    {
  }
  bool operator== (const WallTileIndexPair&amp; other) const {
    return wall_index == other.wall_index &amp;&amp; tile_index == other.tile_index;
  }
  wall_index_t wall_index;    tile_index_t tile_index;  };
typedef uint wall_id_t; const wall_id_t WALL_ID_INVALID = ID_INVALID;
const wall_id_t WALL_ID_NOT_IN_PARTITION = ID_INVALID2;
typedef uint region_id_t; const region_id_t REGION_ID_INVALID = ID_INVALID;
typedef uint region_index_t; const region_index_t REGION_INDEX_INVALID = INDEX_INVALID;
typedef uint_set&lt;region_index_t&gt; RegionIndicesSet;
typedef uint geometry_object_index_t;
const geometry_object_index_t GEOMETRY_OBJECT_INDEX_INVALID = INDEX_INVALID;
typedef uint geometry_object_id_t; const geometry_object_id_t GEOMETRY_OBJECT_ID_INVALID = ID_INVALID;
typedef uint counted_volume_index_t;
const counted_volume_index_t COUNTED_VOLUME_INDEX_OUTSIDE_ALL = 0;
const counted_volume_index_t COUNTED_VOLUME_INDEX_INTERSECTS = INDEX_INVALID2;
const counted_volume_index_t COUNTED_VOLUME_INDEX_INVALID = INDEX_INVALID;
typedef std::pair&lt;partition_id_t, wall_index_t&gt; PartitionWallIndexPair;
typedef std::pair&lt;partition_id_t, region_index_t&gt; PartitionRegionIndexPair;
typedef std::pair&lt;partition_id_t, vertex_index_t&gt; PartitionVertexIndexPair;
typedef std::pair&lt;pos_t, PartitionWallIndexPair&gt; CummAreaPWallIndexPair;
typedef std::map&lt;geometry_object_id_t, uint_set&lt;geometry_object_id_t&gt;&gt; CountedVolumesMap;
const int BASE_CONTAINER_ALLOC = 16;
#ifndef INDEXER_WA
typedef boost::container::small_vector&lt;subpart_index_t, BASE_CONTAINER_ALLOC&gt;  SubpartIndicesVector;
typedef boost::container::small_vector&lt;wall_index_t, BASE_CONTAINER_ALLOC&gt; WallIndicesVector;
typedef uint_dense_hash_set&lt;subpart_index_t&gt; SubpartIndicesSet; #else
typedef std::vector&lt;subpart_index_t&gt; SubpartIndicesVector;
typedef std::vector&lt;wall_index_t&gt; WallIndicesVector;
typedef std::set&lt;subpart_index_t&gt; SubpartIndicesSet;
#endif
template&lt;typename T&gt;
class insertion_ordered_set {
public:
  void insert_ordered(const T&amp; value) {
    if (s.count(value) == 0) {
      s.insert(value);
      v.push_back(value);
    }
  }
  const T&amp; operator [] (const size_t i) const {
    assert(i &lt; size());
    return v[i];
  }
  size_t size() const {
    assert(v.size() == s.size());
    return v.size();
  }
  const std::vector&lt;T&gt;&amp; get_as_vector() const {
    return v;
  }
private:
  std::vector&lt;T&gt; v;
  std::set&lt;T&gt; s;
};
#if POS_T_BYTES == 8
typedef glm::dvec3 glm_vec3_t;
typedef glm::dvec2 glm_vec2_t;
typedef glm::dmat4x4 mat4x4;
#else
typedef glm::fvec3 glm_vec3_t;
typedef glm::fvec2 glm_vec2_t;
typedef glm::fmat4x4 mat4x4;
#endif
typedef glm::ivec3 glm_ivec3_t;
typedef glm::uvec3 UVec3;
typedef glm::bvec3 BVec3;
struct IVec3: public glm_ivec3_t {
  IVec3() = default;
  IVec3(const glm_vec3_t&amp; a) { x = a.x; y = a.y; z = a.z; }
  IVec3(const IVec3&amp; a) : glm_ivec3_t(a.x, a.y, a.z) { }
  IVec3(const int x_, const int y_, const int z_) { x = x_; y = y_; z = z_; }
  IVec3(const int xyz) { x = xyz; y = xyz; z = xyz; }
  IVec3(const std::vector&lt;int&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
  IVec3(const vector3&amp; v3) { x = v3.x; y = v3.y; z = v3.z; }
  IVec3&amp; operator=(const IVec3&amp; other) = default;
  bool operator &lt; (const IVec3&amp; other) const {
    if (x &lt; other.x) {
      return true;
    }
    else if (x == other.x) {
      if (y &lt; other.y) {
        return true;
      }
      else if (y == other.y) {
        if (z &lt; other.z) {
          return true;
        }
        else {
          return false;
        }
      }
      else {
        return false;
      }
    }
    else {
      return false;
    }
  }
};
struct Vec3: public glm_vec3_t {
  Vec3() = default;
  Vec3(const glm_vec3_t&amp; a) { x = a.x; y = a.y; z = a.z; }
  Vec3(const Vec3&amp; a) : glm_vec3_t(a.x, a.y, a.z) { }
  Vec3(const IVec3&amp; a) : glm_vec3_t(a.x, a.y, a.z) { }
  Vec3(const vector3&amp; a) { x = a.x; y = a.y; z = a.z; }
  Vec3(const pos_t x_, const pos_t y_, const pos_t z_) { x = x_; y = y_; z = z_; }
  Vec3(const pos_t xyz) { x = xyz; y = xyz; z = xyz; }
  Vec3(const std::vector&lt;double&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
#if POS_T_BYTES == 4
  Vec3(const std::vector&lt;pos_t&gt;&amp; xyz) { assert(xyz.size() == 3); x = xyz[0]; y = xyz[1]; z = xyz[2]; }
#endif
  Vec3&amp; operator=(const Vec3&amp; other) = default;
  std::vector&lt;double&gt; to_vec() const {
    std::vector&lt;double&gt; res(3);
    res[0] = x;
    res[1] = y;
    res[2] = z;
    return res;
  }
  bool is_valid() const { return !(x == POS_INVALID || y == POS_INVALID || z == POS_INVALID); }
  std::string to_string() const;
  void dump(const std::string extra_comment, const std::string ind) const;
};
struct Vec2: public glm_vec2_t {
  Vec2() = default;
  Vec2(const glm_vec2_t&amp; a) { x = a.x; y = a.y; }
  Vec2(const Vec2&amp; a) : glm_vec2_t(a.x, a.y) { }
  Vec2(const vector2&amp; a) { x = a.u; y = a.v; }
  Vec2(const pos_t x_, const pos_t y_) { x = x_; y = y_; }
  Vec2(const pos_t xy) { x = xy; y = xy; }
  Vec2(const std::vector&lt;double&gt;&amp; xy) { assert(xy.size() == 2); x = xy[0]; y = xy[1]; }
#if POS_T_BYTES == 4
  Vec2(const std::vector&lt;pos_t&gt;&amp; xy) { assert(xy.size() == 2); x = xy[0]; y = xy[1]; }
#endif
  Vec2&amp; operator=(const Vec2&amp; other) = default;
  std::vector&lt;double&gt; to_vec() const {
    std::vector&lt;double&gt; res(2);
    res[0] = x;
    res[1] = y;
    return res;
  }
  bool is_valid() const { return !(x == POS_INVALID || y == POS_INVALID); }
  std::string to_string() const;
  void dump(const std::string extra_comment, const std::string ind) const;
};
static inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const Vec3&amp; a) {
  out &lt;&lt; "(" &lt;&lt; a.x &lt;&lt; ", " &lt;&lt; a.y &lt;&lt; ", " &lt;&lt; a.z &lt;&lt; ")";
  return out;
}
static inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp;out, const Vec2&amp; a) {
  out &lt;&lt; "(" &lt;&lt; a.u &lt;&lt; ", " &lt;&lt; a.v &lt;&lt; ")";
  return out;
}
static inline double log_f(const double x) {
  assert(x != 0);
  return log(x);
}
static inline pos_t log_p(const pos_t x) {
  assert(x != 0);
#if POS_T_BYTES == 4
  return logf(x);
#else
  return log(x);
#endif
}
static inline double exp_f(const double x) {
  return exp(x);
}
static inline double ceil_f(const double x) {
  return ceil(x);
}
static inline double ceil_p(const pos_t x) {
#if POS_T_BYTES == 8
  return ceil(x);
#else
  return ceilf(x);
#endif
}
static inline pos_t fabs_p(const pos_t x) {
  if (x &lt; 0) {
    return -x;
  }
  else {
    return x;
  }
}
static inline double floor_to_multiple_f(const double val, double multiple) {
  assert(val &gt;= 0);
  assert(multiple &gt; 0);
  return (double)((long long)((val + EPS)/ multiple)) * multiple;
}
static inline pos_t floor_to_multiple_p(const pos_t val, pos_t multiple) {
  assert(val &gt;= 0);
  assert(multiple &gt; 0);
  return (pos_t)((long long)((val + EPS)/ multiple)) * multiple;
}
static inline double floor_to_multiple_allow_negative_p(const double val, pos_t multiple) {
  if (val &gt;= 0) {
    return (double)((long long)((val + EPS)/ multiple)) * multiple;
  }
  else {
    return (double)((long long)((val + EPS - multiple)/ multiple)) * multiple;
  }
}
static inline Vec3 floor_to_multiple_allow_negative_p(const Vec3&amp; val, const pos_t multiple) {
  Vec3 res;
  res.x = floor_to_multiple_allow_negative_p(val.x, multiple);
  res.y = floor_to_multiple_allow_negative_p(val.y, multiple);
  res.z = floor_to_multiple_allow_negative_p(val.z, multiple);
  return res;
}
static inline double ceil_to_multiple_p(const double val, const pos_t multiple) {
  assert(val &gt;= 0);
  double res = floor_to_multiple_p(val, multiple);
  if (!cmp_eq(val, res)) {
    res += multiple;
  }
  return res;
}
static inline Vec3 ceil_to_multiple_p(const Vec3&amp; val, const pos_t multiple) {
  Vec3 res;
  res.x = ceil_to_multiple_p(val.x, multiple);
  res.y = ceil_to_multiple_p(val.y, multiple);
  res.z = ceil_to_multiple_p(val.z, multiple);
  return res;
}
static inline bool cmp_eq(const Vec3&amp; a, const Vec3&amp; b, const pos_t eps) {
  return cmp_eq(a.x, b.x, eps) &amp;&amp; cmp_eq(a.y, b.y, eps) &amp;&amp; cmp_eq(a.z, b.z, eps);
}
static inline bool cmp_eq(const Vec3&amp; a, const Vec3&amp; b) {
  return cmp_eq(a, b, EPS);
}
static inline bool cmp_eq(const Vec2&amp; a, const Vec2&amp; b, const pos_t eps) {
  return cmp_eq(a.x, b.x, eps) &amp;&amp; cmp_eq(a.y, b.y, eps);
}
static inline bool cmp_eq(const Vec2&amp; a, const Vec2&amp; b) {
  return cmp_eq(a, b, EPS);
}
static inline bool cmp_lt(const double a, const double b, const double eps) {
  return a &lt; b &amp;&amp; !cmp_eq(a, b, eps);
}
static inline bool cmp_le(const double a, const double b, const double eps) {
  return a &lt; b || cmp_eq(a, b, eps);
}
static inline bool cmp_gt(const double a, const double b, const double eps) {
  return a &gt; b &amp;&amp; !cmp_eq(a, b, eps);
}
static inline bool cmp_ge(const double a, const double b, const double eps) {
  return a &gt; b || cmp_eq(a, b, eps);
}
static inline pos_t sqrt_p(const pos_t x) {
#if POS_T_BYTES == 4
  return sqrtf(x);
#else
  return sqrt(x);
#endif
}
static inline uint powu(const uint a, const uint n) {
  uint res = a;
  for (uint i = 1; i &lt; n; i++) {
    res *= a;
  }
  return res;
}
static inline pos_t max3(const Vec3&amp; v) {
  return glm::compMax((glm_vec3_t)v);
}
static inline pos_t min3(const Vec3&amp; v) {
  return glm::compMin((glm_vec3_t)v);
}
static inline pos_t min3_p(const pos_t x, const pos_t y, const pos_t z) {
  return (z &lt; y) ? ((z &lt; x) ? z : x) : ((y &lt; x) ? y : x);
}
static inline int max3_i(const IVec3&amp; v) {
  return glm::compMax((glm_ivec3_t)v);
}
static inline int min3_i(const IVec3&amp; v) {
  return glm::compMin((glm_ivec3_t)v);
}
static inline Vec3 abs3(const Vec3&amp; v) {
  return glm::abs((glm_vec3_t)v);
}
static inline Vec3 floor3(const Vec3&amp; v) {
  return glm::floor((glm_vec3_t)v);
}
static inline Vec3 round3(const Vec3&amp; v) {
  return glm::round((glm_vec3_t)v);
}
static inline pos_t abs_max_2vec(const Vec3&amp; v1, const Vec3&amp; v2) {
  glm_vec3_t v1abs = abs3(v1);
  glm_vec3_t v2abs = abs3(v2);
  Vec3 vmax = glm::max(v1abs, v2abs);
  return MCell::max3(vmax);
}
static inline pos_t determinant2(const Vec2&amp; v1, const Vec2&amp; v2) {
  return v1.u * v2.v - v1.v * v2.u;
}
static inline pos_t dot2(const Vec2&amp; v1, const Vec2&amp; v2) {
  return glm::dot((glm_vec2_t)v1, (glm_vec2_t)v2);
}
static inline pos_t len2_squared(const Vec2&amp; v1) {
  return v1.u * v1.u + v1.v * v1.v;
}
static inline pos_t len2(const Vec2&amp; v1) {
  return sqrt_p(len2_squared(v1));
}
static inline pos_t dot(const Vec3&amp; v1, const Vec3&amp; v2) {
  return glm::dot((glm_vec3_t)v1, (glm_vec3_t)v2);
}
static inline pos_t len3_squared(const Vec3&amp; v1) {
  return v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
}
static inline pos_t len3(const Vec3&amp; v1) {
  return sqrt_p(len3_squared(v1));
}
static inline pos_t distance3_squared(const Vec3&amp; v1, const Vec3&amp; v2) {
  return len3_squared(v1 - v2);
}
static inline pos_t distance3(const Vec3&amp; v1, const Vec3&amp; v2) {
  return sqrt_p( len3_squared(v1 - v2) );
}
static inline uint get_largest_abs_dim_index(const Vec3&amp; v) {
  Vec3 a = glm::abs(glm_vec3_t(v));
  if (a.x &gt; a.y) {
    if (a.x &gt; a.z) {
      return 0;     }
    else {
      return 2;     }
  }
  else {
    if (a.y &gt; a.z) {
      return 1;     }
    else {
      return 2;     }
  }
}
static inline bool point_in_box(const Vec3&amp; pt, const Vec3&amp; llf, const Vec3&amp; urb) {
  return
      pt.x &gt;= llf.x &amp;&amp; pt.x &lt;= urb.x &amp;&amp;
      pt.y &gt;= llf.y &amp;&amp; pt.y &lt;= urb.y &amp;&amp;
      pt.z &gt;= llf.z &amp;&amp; pt.z &lt;= urb.z;
}
static inline Vec3 cross(const Vec3&amp; v1, const Vec3&amp; v2) {
  return glm::cross((glm_vec3_t)v1, (glm_vec3_t)v2);
}
static inline int distinguishable_vec2(const Vec2&amp; a, const Vec2&amp; b, const pos_t eps) {
  pos_t c, cc, d;
  c = fabs_p(a.u);
  d = fabs_p(a.v);
  if (d &gt; c)
    c = d;
  d = fabs_p(b.u);
  if (d &gt; c)
    c = d;
  d = fabs_p(b.v);
  if (d &gt; c)
    c = d;
  cc = fabs_p(a.u - b.u);
  d = fabs_p(a.v - b.v);
  if (d &gt; cc)
    cc = d;
  if (c &lt; eps)
    c = eps;
  return (c * eps &lt; cc);
}
static inline bool distinguishable_vec3(const Vec3&amp; a, const Vec3&amp; b, const pos_t eps) {
  pos_t c, cc, d;
  c = fabs_p(a.x);
  d = fabs_p(a.y);
  if (d &gt; c)
    c = d;
  d = fabs_p(a.z);
  if (d &gt; c)
    c = d;
  d = fabs_p(b.x);
  if (d &gt; c)
    c = d;
  d = fabs_p(b.y);
  if (d &gt; c)
    c = d;
  d = fabs_p(b.z);
  if (d &gt; c)
    c = d;
  cc = fabs_p(a.x - b.x);
  d = fabs_p(a.y - b.y);
  if (d &gt; cc)
    cc = d;
  d = fabs_p(a.z - b.z);
  if (d &gt; cc)
    cc = d;
  if (c &lt; eps)
    c = eps;
  return (c * eps &lt; cc);
<a name="0"></a>}
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>static inline void guard_zero_div(Vec3&amp; val) {
  if (val.x == 0) {
    val.x = FLT_MIN;
  }
  if (val.y == 0) {
    val.y = FLT_MIN;
  }
  if (val.z == 0) {
    val.z = FLT_MIN;
  }
}</b></font>
uint64_t get_mem_usage();
} 
#endif </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>viz_output.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdarg.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;fcntl.h&gt;
#ifndef _MSC_VER
#include &lt;unistd.h&gt;
#include &lt;dirent.h&gt;
#endif
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
#include &lt;assert.h&gt;
#include "c_vector.h"
#include "debug_config.h"
#include "logging.h"
#include "mcell_structs.h"
#include "grid_util.h"
#include "sched_util.h"
#include "viz_output.h"
#include "strfunc.h"
#include "util.h"
#include "vol_util.h"
#include "sym_table.h"
#include "bng_util.h"
#define VIZ_OPTS_NONE        0x00L
#define VIZ_COMP_NAMING_MASK 0x0FL #define VIZ_COMP_ALL_SAME    0x01L #define VIZ_COMP_NAME_GLOBAL 0x02L #define VIZ_COMP_MOL_LOCAL   0x03L #define VIZ_PROXY_OUTPUT     0x08L 
#define VIZ_ALT_FILES_MASK   0xF0L #define VIZ_ALT_DUMP_FMT     0x10L #define VIZ_JSON_MOLCOMP_FMT 0x20L 
static int output_ascii_molecules(struct volume *world,
                                  struct viz_output_block *,
                                  struct frame_data_list *fdlp);
static int output_cellblender_molecules(struct volume *world,
                                        struct viz_output_block *,
                                        struct frame_data_list *fdlp);
static long long frame_iteration(struct volume *world, double iterval,
                                 int type) {
  switch (type) {
  case OUTPUT_BY_ITERATION_LIST:
    return (long long)iterval;
  case OUTPUT_BY_TIME_LIST:
    if (world-&gt;chkpt_seq_num == 1) {
      return (long long)(iterval / world-&gt;time_unit + ROUND_UP);
    } else {
      if (iterval &gt;= world-&gt;simulation_start_seconds) {
        return (long long) convert_seconds_to_iterations(
            world-&gt;start_iterations, world-&gt;time_unit,
            world-&gt;simulation_start_seconds, iterval) + ROUND_UP;
      } else {
        return INT_MIN;
      }
    }
  default:
    mcell_internal_error("Invalid frame_data_list list_type (%d).", type);
  }
}
static int sort_molecules_by_species(struct volume *world,
                                     struct viz_output_block *vizblk,
                                     struct abstract_molecule ****viz_molpp,
                                     u_int **viz_mol_countp, int include_volume,
                                     int include_grid) {
  struct storage_list *slp;
  u_int *counts;
  int species_index;
  if ((*viz_molpp = (struct abstract_molecule ***)allocate_ptr_array(
           world-&gt;n_species)) == NULL)
    return 1;
  if ((counts = *viz_mol_countp = allocate_uint_array(world-&gt;n_species, 0)) ==
      NULL)
    return 1;
  for (species_index = 0; species_index &lt; world-&gt;n_species; ++species_index) {
    int mol_count;
    u_int spec_id = world-&gt;species_list[species_index]-&gt;species_id;
    if (vizblk-&gt;species_viz_states[species_index] == EXCLUDE_OBJ)
      continue;
    if (world-&gt;species_list[species_index]-&gt;flags &amp; IS_SURFACE)
      continue;
    if (!include_grid &amp;&amp; (world-&gt;species_list[species_index]-&gt;flags &amp; ON_GRID))
      continue;
    if (!include_volume &amp;&amp;
        !(world-&gt;species_list[species_index]-&gt;flags &amp; ON_GRID))
      continue;
    mol_count = world-&gt;species_list[species_index]-&gt;population;
    if (mol_count &lt;= 0)
      continue;
    if (((*viz_molpp)[spec_id] =
             (struct abstract_molecule **)allocate_ptr_array(mol_count)) ==
        NULL)
      return 1;
  }
  for (slp = world-&gt;storage_head; slp != NULL; slp = slp-&gt;next) {
    struct storage *sp = slp-&gt;store;
    struct schedule_helper *shp;
    struct abstract_molecule *amp;
    int sched_slot_index;
    for (shp = sp-&gt;timer; shp != NULL; shp = shp-&gt;next_scale) {
      for (sched_slot_index = -1; sched_slot_index &lt; shp-&gt;buf_len;
           ++sched_slot_index) {
        for (amp = (struct abstract_molecule *)((sched_slot_index &lt; 0)
                                                    ? shp-&gt;current
                                                    : shp-&gt;circ_buf_head
                                                          [sched_slot_index]);
             amp != NULL; amp = amp-&gt;next) {
          u_int spec_id;
          if (amp-&gt;properties == NULL)
            continue;
          spec_id = amp-&gt;properties-&gt;species_id;
          if (vizblk-&gt;species_viz_states[spec_id] == EXCLUDE_OBJ)
            continue;
          if (!include_grid &amp;&amp; (amp-&gt;flags &amp; TYPE_MASK) != TYPE_VOL)
            continue;
          if (!include_volume &amp;&amp; (amp-&gt;flags &amp; TYPE_MASK) == TYPE_VOL)
            continue;
          if (counts[spec_id] &lt; amp-&gt;properties-&gt;population)
            (*viz_molpp)[spec_id][counts[spec_id]++] = amp;
          else {
            mcell_warn("Molecule count disagreement!\n"
                       "  Species %s  population = %d  count = %d",
                       amp-&gt;properties-&gt;sym-&gt;name, amp-&gt;properties-&gt;population,
                       counts[spec_id]);
          }
        }
      }
    }
  }
  return 0;
}
static int reset_time_values(struct volume *world, struct frame_data_list *fdlp,
                             long long curiter) {
  if (curiter != 0)
    ++curiter;
  for (; fdlp != NULL; fdlp = fdlp-&gt;next) {
    fdlp-&gt;curr_viz_iteration = fdlp-&gt;iteration_list;
    fdlp-&gt;viz_iteration = -1;
    while (fdlp-&gt;curr_viz_iteration != NULL) {
      if (frame_iteration(world, fdlp-&gt;curr_viz_iteration-&gt;value,
                          fdlp-&gt;list_type) &gt;= curiter)
        break;
      fdlp-&gt;curr_viz_iteration = fdlp-&gt;curr_viz_iteration-&gt;next;
    }
    if (fdlp-&gt;curr_viz_iteration != NULL)
      fdlp-&gt;viz_iteration = frame_iteration(
          world, fdlp-&gt;curr_viz_iteration-&gt;value, fdlp-&gt;list_type);
  }
  return 0;
}
static int count_time_values(struct volume *world,
                             struct frame_data_list *const fdlp) {
  int time_values = 0;
  long long curiter = -1;
  struct frame_data_list *fdlpcur = NULL;
  for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
    fdlpcur-&gt;curr_viz_iteration = fdlpcur-&gt;iteration_list;
    fdlpcur-&gt;n_viz_iterations = 0;
    fdlpcur-&gt;viz_iteration = -1;
  }
  while (1) {
    curiter = -1;
    for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
      long long thisiter;
      if (fdlpcur-&gt;curr_viz_iteration == NULL)
        continue;
      thisiter = frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
                                 fdlpcur-&gt;list_type);
      if (curiter == -1)
        curiter = thisiter;
      else if (thisiter &lt; curiter)
        curiter = thisiter;
    }
    if (curiter == -1)
      break;
    if (curiter &gt; world-&gt;iterations)
      break;
    if (world-&gt;chkpt_iterations != 0 &amp;&amp;
        curiter &gt; world-&gt;start_iterations + world-&gt;chkpt_iterations)
      break;
    if (curiter &gt; world-&gt;start_iterations)
      ++time_values;
    else if ((world-&gt;start_iterations | curiter) == 0)
      ++time_values;
    for (fdlpcur = fdlp; fdlpcur != NULL; fdlpcur = fdlpcur-&gt;next) {
      if (fdlpcur-&gt;curr_viz_iteration == NULL)
        continue;
      if (curiter &gt; world-&gt;start_iterations || (world-&gt;start_iterations | curiter) == 0) {
        if (frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
                            fdlpcur-&gt;list_type) == curiter)
          ++fdlpcur-&gt;n_viz_iterations;
      }
      while (fdlpcur-&gt;curr_viz_iteration &amp;&amp;
             frame_iteration(world, fdlpcur-&gt;curr_viz_iteration-&gt;value,
                             fdlpcur-&gt;list_type) == curiter)
        fdlpcur-&gt;curr_viz_iteration = fdlpcur-&gt;curr_viz_iteration-&gt;next;
    }
  }
  return time_values;
}
static int output_ascii_molecules(struct volume *world,
                                  struct viz_output_block *vizblk,
                                  struct frame_data_list *fdlp) {
  FILE *custom_file;
  char *cf_name;
  struct storage_list *slp;
  struct schedule_helper *shp;
  struct abstract_element *aep;
  struct abstract_molecule *amp;
  struct volume_molecule *mp;
  struct surface_molecule *gmp;
  short orient = 0;
  int ndigits, i;
  long long lli;
  struct vector3 where, norm;
  no_printf("Output in ASCII mode (molecules only)...\n");
  if ((fdlp-&gt;type == ALL_MOL_DATA) || (fdlp-&gt;type == MOL_POS)) {
    lli = 10;
    for (ndigits = 1; lli &lt;= world-&gt;iterations &amp;&amp; ndigits &lt; 20;
         lli *= 10, ndigits++) {
    }
    cf_name =
        CHECKED_SPRINTF("%s.ascii.%.*lld.dat", vizblk-&gt;file_prefix_name,
                        ndigits, fdlp-&gt;viz_iteration);
    if (cf_name == NULL)
      return 1;
    if (make_parent_dir(cf_name)) {
      free(cf_name);
      mcell_error(
          "Failed to create parent directory for ASCII-mode VIZ output.");
    }
    custom_file = open_file(cf_name, "w");
    if (!custom_file)
      mcell_die();
    else {
      no_printf("Writing to file %s\n", cf_name);
    }
    free(cf_name);
    cf_name = NULL;
    c_vector_t *vec = vector_create();
    for (slp = world-&gt;storage_head; slp != NULL; slp = slp-&gt;next) {
      for (shp = slp-&gt;store-&gt;timer; shp != NULL; shp = shp-&gt;next_scale) {
        for (i = -1; i &lt; shp-&gt;buf_len; i++) {
          for (aep = (i &lt; 0) ? shp-&gt;current : shp-&gt;circ_buf_head[i];
               aep != NULL; aep = aep-&gt;next) {
            amp = (struct abstract_molecule *)aep;
            if (amp-&gt;properties == NULL)
              continue;
            vector_push_back(vec, amp);
          }
        }
      }
    }
#ifdef MCELL3_SORTED_VIZ_OUTPUT
    vector_sort_by_mol_id(vec);
#endif    
    size_t sz = vector_get_size(vec);
    for (size_t k = 0; k &lt; sz; k++) {
      amp = (struct abstract_molecule*)vector_at(vec, k);
      int id = vizblk-&gt;species_viz_states[amp-&gt;properties-&gt;species_id];
      if (id == EXCLUDE_OBJ)
        continue;
      if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
        mp = (struct volume_molecule *)amp;
        where.x = mp-&gt;pos.x;
        where.y = mp-&gt;pos.y;
        where.z = mp-&gt;pos.z;
        norm.x = 0;
        norm.y = 0;
        norm.z = 0;
      } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
        gmp = (struct surface_molecule *)amp;
        uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
        orient = gmp-&gt;orient;
        norm.x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
        norm.y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
        norm.z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
      } else
        continue;
      where.x *= world-&gt;length_unit;
      where.y *= world-&gt;length_unit;
      where.z *= world-&gt;length_unit;
      std::string species_name = amp-&gt;properties-&gt;sym-&gt;name;
      #ifdef ASCII_VIZ_EXTERNAL_SPECIES_NAME
        if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
          species_name = graph_pattern_to_bngl(amp-&gt;graph_data-&gt;graph_pattern);
        }
      #endif
      if (id == INCLUDE_OBJ) {
        fprintf(custom_file, "%s %lu %.9g %.9g %.9g %.9g %.9g %.9g\n",
                species_name.c_str(), amp-&gt;id, where.x, where.y,
                where.z, norm.x, norm.y, norm.z);
      } else {
        fprintf(custom_file, "%d %lu %.9g %.9g %.9g %.9g %.9g %.9g\n", id,
                amp-&gt;id, where.x, where.y, where.z, norm.x, norm.y,
                norm.z);
      }
    }
    vector_delete(vec);
    fclose(custom_file);
  }
  return 0;
}
typedef struct external_mol_viz_struct {
  char mol_type;    float pos_x, pos_y, pos_z;
  float norm_x, norm_y, norm_z;
  struct external_mol_viz_struct *next_mol;
} external_mol_viz;
typedef struct external_mol_viz_by_name_struct {
  char *mol_name;
  external_mol_viz *mol_list;
  struct external_mol_viz_by_name_struct *next_name;
} external_mol_viz_by_name;
typedef struct external_mol_viz_entry_struct {
  char *mol_id_string;  } external_mol_viz_entry;
static struct sym_table_head *graph_pattern_table = NULL;
static long next_molcomp_id = 0L;
typedef struct external_molcomp_loc_struct {
  bool is_mol;
  bool has_coords;
  bool is_final;
  double x, y, z;
  double kx, ky, kz;
  char *name;
  char *graph_string;
  int num_peers;
  int *peers;
  char *states;
} external_molcomp_loc;
typedef struct molcomp_list_struct {
  external_molcomp_loc *molcomp_array;
  int num_molcomp_items;
  long molcomp_id;
} molcomp_list;
static void dump_molcomp_array_to ( FILE *out_file, external_molcomp_loc *molcomp_array, int num_parts ) {
  int i, j;
  fprintf ( out_file, "%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%\n" );
  for (i=0; i&lt;num_parts; i++) {
    fprintf ( out_file, "[%d] = %s (", i, molcomp_array[i].name );
    if (molcomp_array[i].is_mol) {
      fprintf ( out_file, "m" );
    } else {
      fprintf ( out_file, "c" );
    }
    fprintf ( out_file, ") at  (%g, %g, %g) with peers [", molcomp_array[i].x, molcomp_array[i].y, molcomp_array[i].z );
    for (j=0; j&lt;molcomp_array[i].num_peers; j++) {
      fprintf ( out_file, "%d", molcomp_array[i].peers[j] );
      if (j &lt; molcomp_array[i].num_peers - 1) {
        fprintf ( out_file, "," );
      }
    }
    fprintf ( out_file, "]\n" );
  }
  fprintf ( out_file, "%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%=%%\n" );
}
static void dump_molcomp_list_to ( FILE *out_file, molcomp_list *mcl ) {
  fprintf ( out_file, "ID=%ld\n", mcl-&gt;molcomp_id );
  dump_molcomp_array_to ( out_file, mcl-&gt;molcomp_array, mcl-&gt;num_molcomp_items );
}
static void dump_molcomp_array ( external_molcomp_loc *molcomp_array, int num_parts ) {
  dump_molcomp_array_to ( stdout, molcomp_array, num_parts );
}
double clipped_cos ( double angle ) {
  double v = cos(angle);
  if ((v &gt; -1e-6) &amp;&amp; (v &lt; 1e-6)) v = 0;
  return ( v );
}
double clipped_sin ( double angle ) {
  double v = sin(angle);
  if ((v &gt; -1e-6) &amp;&amp; (v &lt; 1e-6)) v = 0;
  return ( v );
}
static void set_component_positions_by_table ( struct volume *world, external_molcomp_loc *mc, int num_parts ) {
  double scale = 0.02;
  int mi;
  for (mi=0; mi&lt;num_parts; mi++) {
    if (mc[mi].is_mol) {
      struct sym_entry *sp;
      sp = retrieve_sym(mc[mi].name, world-&gt;mol_ss_sym_table);
      if (sp != NULL) {
        if (sp-&gt;sym_type == MOL_SS) {
          for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
            mc[mc[mi].peers[ci]].has_coords = false;
          }
          struct mol_ss *mol_ss_ptr = (struct mol_ss *)(sp-&gt;value);
          struct mol_comp_ss *mc_ptr = mol_ss_ptr-&gt;mol_comp_ss_head;
          int comp_count = 0;
          while (mc_ptr != NULL) {
            for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
              if ( (!mc[mc[mi].peers[ci]].has_coords) &amp;&amp; (strcmp(mc[mc[mi].peers[ci]].name, mc_ptr-&gt;name) == 0) ) {
                mc[mc[mi].peers[ci]].x = mc_ptr-&gt;loc_x;
                mc[mc[mi].peers[ci]].y = mc_ptr-&gt;loc_y;
                mc[mc[mi].peers[ci]].z = mc_ptr-&gt;loc_z;
                mc[mc[mi].peers[ci]].kx = mc_ptr-&gt;rot_axis_x;                  mc[mc[mi].peers[ci]].ky = mc_ptr-&gt;rot_axis_y;                  mc[mc[mi].peers[ci]].kz = mc_ptr-&gt;rot_axis_z;                  mc[mc[mi].peers[ci]].has_coords = true;
                if (world-&gt;dump_level &gt;= 20) {
                  fprintf ( stdout, "    Component %s is at (%g,%g,%g)\n", mc[mc[mi].peers[ci]].name, mc[mc[mi].peers[ci]].x, mc[mc[mi].peers[ci]].y, mc[mc[mi].peers[ci]].z );
                  fprintf ( stdout, "       Ref key for %s is at (%g,%g,%g)\n", mc[mc[mi].peers[ci]].name, mc[mc[mi].peers[ci]].kx, mc[mc[mi].peers[ci]].ky, mc[mc[mi].peers[ci]].kz );
                }
                break;
              }
            }
            comp_count += 1;
            mc_ptr = mc_ptr-&gt;next;
          }
          for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
            if (!mc[mc[mi].peers[ci]].has_coords) {
              mc[mc[mi].peers[ci]].x = 0.0;
              mc[mc[mi].peers[ci]].y = 0.0;
              mc[mc[mi].peers[ci]].z = 0.0;
              mc[mc[mi].peers[ci]].kx = 0.0;
              mc[mc[mi].peers[ci]].ky = 0.0;
              mc[mc[mi].peers[ci]].kz = 0.0;
              mc[mc[mi].peers[ci]].has_coords = true;
            }
          }
        }
      } else {
        fprintf ( stdout, "    No entry found for %s, using default. This is unexpected!!\n", mc[mi].name );
        for (int ci=0; ci&lt;mc[mi].num_peers; ci++) {
          double angle = 2 * MY_PI * ci / mc[mi].num_peers;
          mc[mc[mi].peers[ci]].x = scale * cos(angle);
          mc[mc[mi].peers[ci]].y = scale * sin(angle);
          mc[mc[mi].peers[ci]].z = 0.0;
          mc[mc[mi].peers[ci]].kx = 0.0;
          mc[mc[mi].peers[ci]].ky = 0.0;
          mc[mc[mi].peers[ci]].kz = scale;
        }
      }
    }
  }
}
static void bind_molecules_at_components ( struct volume *world, external_molcomp_loc *mc, int num_parts, int fixed_comp_index, int var_comp_index, bool as3D, bool with_rot ) {
  int fixed_mol_index = mc[fixed_comp_index].peers[0];
  int var_mol_index = mc[var_comp_index].peers[0];
  double fixed_vec[3] = {0, 0, 0};    double   var_vec[3] = {0, 0, 0};
  fixed_vec[0] = mc[fixed_comp_index].x - mc[fixed_mol_index].x;
  fixed_vec[1] = mc[fixed_comp_index].y - mc[fixed_mol_index].y;
  var_vec[0]   = mc[  var_comp_index].x - mc[  var_mol_index].x;
  var_vec[1]   = mc[  var_comp_index].y - mc[  var_mol_index].y;
  if (as3D) {
    fixed_vec[2] = mc[fixed_comp_index].z - mc[fixed_mol_index].z;
    var_vec[2]   = mc[  var_comp_index].z - mc[  var_mol_index].z;
  }
  double fixed_mag;
  double   var_mag;
  if (as3D) {
    fixed_mag = sqrt ( (fixed_vec[0]*fixed_vec[0]) + (fixed_vec[1]*fixed_vec[1]) + (fixed_vec[2]*fixed_vec[2]) );
      var_mag = sqrt ( (  var_vec[0]*  var_vec[0]) + (  var_vec[1]*  var_vec[1]) + (  var_vec[2]*  var_vec[2]) );
  } else {
    fixed_mag = sqrt ( (fixed_vec[0]*fixed_vec[0]) + (fixed_vec[1]*fixed_vec[1]) );
      var_mag = sqrt ( (  var_vec[0]*  var_vec[0]) + (  var_vec[1]*  var_vec[1]) );
  }
  if ((fixed_mag * var_mag) == 0) {
    if (world-&gt;dump_level &gt;= 10) {
      fprintf ( stdout, "Molecules %s and %s are nonspatially bound.\n", mc[fixed_comp_index].name, mc[var_comp_index].name );
    }
    return;
  }
  double dot_prod;
  if (as3D) {
    dot_prod = (fixed_vec[0] * var_vec[0]) + (fixed_vec[1] * var_vec[1]) + (fixed_vec[2] * var_vec[2]);
  } else {
    dot_prod = (fixed_vec[0] * var_vec[0]) + (fixed_vec[1] * var_vec[1]);
  }
  double norm_dot_prod = dot_prod / ( fixed_mag * var_mag );
  if (norm_dot_prod &gt;  1) { norm_dot_prod =  1; }
  if (norm_dot_prod &lt; -1) { norm_dot_prod = -1; }
  double angle = acos ( norm_dot_prod );
  if (as3D) {
    angle = -angle;
  } else {
    if ( ( (fixed_vec[0] * var_vec[1]) - (fixed_vec[1] * var_vec[0]) ) &gt; 0 ) {
      angle = -angle;
    }
  }
  angle = MY_PI + angle;
  while (angle &gt; MY_PI) {
    angle = angle - (2 * MY_PI);
  }
  while (angle &lt;= -MY_PI) {
    angle = angle + (2 * MY_PI);
  }
  double cos_angle = cos(angle);
  double sin_angle = sin(angle);
  if (as3D) {
    double cross_prod[3];
    cross_prod[0] = (fixed_vec[1] * var_vec[2]) - (fixed_vec[2] * var_vec[1]);
    cross_prod[1] = (fixed_vec[2] * var_vec[0]) - (fixed_vec[0] * var_vec[2]);
    cross_prod[2] = (fixed_vec[0] * var_vec[1]) - (fixed_vec[1] * var_vec[0]);
    double xpx, xpy, xpz;
    xpx = cross_prod[0] / (fixed_mag * var_mag);
    xpy = cross_prod[1] / (fixed_mag * var_mag);
    xpz = cross_prod[2] / (fixed_mag * var_mag);
    double axis_length = sqrt ( (xpx*xpx) + (xpy*xpy) + (xpz*xpz) );
    double R[3][3] = { { 1, 0, 0 },
                       { 0, 1, 0 },
                       { 0, 0, 1 } };
    if (axis_length &lt; 1e-30) {
      if (norm_dot_prod &lt; 0) {
      } else {
        for (int i=0; i&lt;3; i++) {
          R[i][i] = -1;
        }
      }
    } else {
      double ux = xpx / axis_length;
      double uy = xpy / axis_length;
      double uz = xpz / axis_length;
      double omca = 1 - cos_angle;
      R[0][0] = cos_angle + (ux*ux*omca);
      R[0][1] = (ux*uy*omca) - (uz*sin_angle);
      R[0][2] = (ux*uz*omca) + (uy*sin_angle);
      R[1][0] = (uy*ux*omca) + (uz*sin_angle);
      R[1][1] = cos_angle + (uy*uy*omca);
      R[1][2] = (uy*uz*omca) - (ux*sin_angle);
      R[2][0] = (uz*ux*omca) - (uy*sin_angle);
      R[2][1] = (uz*uy*omca) + (ux*sin_angle);
      R[2][2] = cos_angle + (uz*uz*omca);
    }
    for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
      double x = mc[mc[var_mol_index].peers[ci]].x;
      double y = mc[mc[var_mol_index].peers[ci]].y;
      double z = mc[mc[var_mol_index].peers[ci]].z;
      mc[mc[var_mol_index].peers[ci]].x = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z);
      mc[mc[var_mol_index].peers[ci]].y = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z);
      mc[mc[var_mol_index].peers[ci]].z = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z);
      x = mc[mc[var_mol_index].peers[ci]].kx;
      y = mc[mc[var_mol_index].peers[ci]].ky;
      z = mc[mc[var_mol_index].peers[ci]].kz;
      mc[mc[var_mol_index].peers[ci]].kx = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z);
      mc[mc[var_mol_index].peers[ci]].ky = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z);
      mc[mc[var_mol_index].peers[ci]].kz = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z);
    }
  } else {
    for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
      double x = mc[mc[var_mol_index].peers[ci]].x;
      double y = mc[mc[var_mol_index].peers[ci]].y;
      mc[mc[var_mol_index].peers[ci]].x = (x * cos_angle) - (y * sin_angle);
      mc[mc[var_mol_index].peers[ci]].y = (x * sin_angle) + (y * cos_angle);
    }
  }
  if ( as3D &amp;&amp; with_rot) {
    double fixed_req_bond_angle = world-&gt;bond_angle / 2;     double var_req_bond_angle = world-&gt;bond_angle / 2;   
    double fvc[3];
    fvc[0] = mc[fixed_comp_index].x - mc[fixed_mol_index].x;
    fvc[1] = mc[fixed_comp_index].y - mc[fixed_mol_index].y;
    fvc[2] = mc[fixed_comp_index].z - mc[fixed_mol_index].z;
    double vvc[3];
    vvc[0] = mc[var_comp_index].x - mc[var_mol_index].x;
    vvc[1] = mc[var_comp_index].y - mc[var_mol_index].y;
    vvc[2] = mc[var_comp_index].z - mc[var_mol_index].z;
    double fvk[3];
    fvk[0] = mc[fixed_comp_index].kx - mc[fixed_mol_index].x;
    fvk[1] = mc[fixed_comp_index].ky - mc[fixed_mol_index].y;
    fvk[2] = mc[fixed_comp_index].kz - mc[fixed_mol_index].z;
    double vvk[3];
    vvk[0] = mc[var_comp_index].kx - mc[var_mol_index].x;
    vvk[1] = mc[var_comp_index].ky - mc[var_mol_index].y;
    vvk[2] = mc[var_comp_index].kz - mc[var_mol_index].z;
    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, "  Fixed vcomp = [ %g %g %g ]\n", fvc[0], fvc[1], fvc[2] );
      fprintf ( stdout, "  Var   vcomp = [ %g %g %g ]\n", vvc[0], vvc[1], vvc[2] );
      fprintf ( stdout, "  Fixed vkey  = [ %g %g %g ]\n", fvk[0], fvk[1], fvk[2] );
      fprintf ( stdout, "  Var vkey    = [ %g %g %g ]\n", vvk[0], vvk[1], vvk[2] );
    }
    double fixed_normal[3];
    fixed_normal[0] = (fvc[1] * fvk[2]) - (fvc[2] * fvk[1]);
    fixed_normal[1] = (fvc[2] * fvk[0]) - (fvc[0] * fvk[2]);
    fixed_normal[2] = (fvc[0] * fvk[1]) - (fvc[1] * fvk[0]);
    double var_normal[3];
    var_normal[0] = (vvc[1] * vvk[2]) - (vvc[2] * vvk[1]);
    var_normal[1] = (vvc[2] * vvk[0]) - (vvc[0] * vvk[2]);
    var_normal[2] = (vvc[0] * vvk[1]) - (vvc[1] * vvk[0]);
    double fixed_norm_mag = sqrt ( (fixed_normal[0]*fixed_normal[0]) + (fixed_normal[1]*fixed_normal[1]) + (fixed_normal[2]*fixed_normal[2]) );
    double var_norm_mag   = sqrt ( (  var_normal[0]*  var_normal[0]) + (  var_normal[1]*  var_normal[1]) + (  var_normal[2]*  var_normal[2]) );
    double fixed_unit[3];
    fixed_unit[0] = fixed_normal[0] / fixed_norm_mag;
    fixed_unit[1] = fixed_normal[1] / fixed_norm_mag;
    fixed_unit[2] = fixed_normal[2] / fixed_norm_mag;
    double var_unit[3];
    var_unit[0] = var_normal[0] / var_norm_mag;
    var_unit[1] = var_normal[1] / var_norm_mag;
    var_unit[2] = var_normal[2] / var_norm_mag;
    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, "  Fixed unit = [ %g %g %g ]\n", fixed_unit[0], fixed_unit[1], fixed_unit[2] );
      fprintf ( stdout, "  Var unit = [ %g %g %g ]\n", var_unit[0], var_unit[1], var_unit[2] );
    }
    double norm_dot_prod_again;
    norm_dot_prod_again = (fixed_unit[0] * var_unit[0]) + (fixed_unit[1] * var_unit[1]) + (fixed_unit[2] * var_unit[2]);
    if (norm_dot_prod_again &gt;  1) {
      if (world-&gt;dump_level &gt;= 20) {
        fprintf ( stdout, "Numerical Warning: normalized dot product %g was greater than 1\n", norm_dot_prod_again );
      }
      norm_dot_prod_again =  1;
    }
    if (norm_dot_prod_again &lt; -1) {
      if (world-&gt;dump_level &gt;= 20) {
        fprintf ( stdout, "Numerical Warning: normalized dot product %g was less than -1\n", norm_dot_prod_again );
      }
      norm_dot_prod_again = -1;
    }
    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, "  Normalized Dot Product between fixed and var is %g\n", norm_dot_prod_again );
    }
    double cur_key_plane_angle = acos ( norm_dot_prod_again );
    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, "Current key plane angle = %g\n", (180*cur_key_plane_angle/MY_PI) );
    }
    double cross_prod[3];
    cross_prod[0] = (fixed_unit[1] * var_unit[2]) - (fixed_unit[2] * var_unit[1]);
    cross_prod[1] = (fixed_unit[2] * var_unit[0]) - (fixed_unit[0] * var_unit[2]);
    cross_prod[2] = (fixed_unit[0] * var_unit[1]) - (fixed_unit[1] * var_unit[0]);
    double dot_cross_rot = (cross_prod[0] * vvc[0]) + (cross_prod[1] * vvc[1]) + (cross_prod[2] * vvc[2]);
    if (dot_cross_rot &gt; 0) {
      cur_key_plane_angle = (2*MY_PI) - cur_key_plane_angle;
    }
    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, "Current key plane angle = %g,  dot_cross_rot = %g\n", (180*cur_key_plane_angle/MY_PI), dot_cross_rot );
    }
    double composite_rot_angle = MY_PI + (var_req_bond_angle+fixed_req_bond_angle) + cur_key_plane_angle;  
    if (world-&gt;dump_level &gt;= 20) {
      fprintf ( stdout, "  Fixed angle                is = %g degrees\n", 180 * fixed_req_bond_angle / MY_PI );
      fprintf ( stdout, "  Var angle                  is = %g degrees\n", 180 * var_req_bond_angle / MY_PI );
      fprintf ( stdout, "  Current angle between keys is = %g degrees\n", 180 * cur_key_plane_angle / MY_PI );
      fprintf ( stdout, "  Composite rotation angle   is = %g degrees\n", 180 * composite_rot_angle / MY_PI );
    }
    double var_vcomp_mag = sqrt ( (vvc[0]*vvc[0]) + (vvc[1]*vvc[1]) + (vvc[2]*vvc[2]) );
    double var_rot_unit[3];
    var_rot_unit[0] = vvc[0] / var_vcomp_mag;
    var_rot_unit[1] = vvc[1] / var_vcomp_mag;
    var_rot_unit[2] = vvc[2] / var_vcomp_mag;
    double ux = var_rot_unit[0];
    double uy = var_rot_unit[1];
    double uz = var_rot_unit[2];
    double cca = cos(composite_rot_angle);
    double sca = sin(composite_rot_angle);
    double omcca = 1 - cca;
    double R[3][3] = { { 1, 0, 0 },
                       { 0, 1, 0 },
                       { 0, 0, 1 } };
    R[0][0] = cca + (ux*ux*omcca);
    R[0][1] = (ux*uy*omcca) - (uz*sca);
    R[0][2] = (ux*uz*omcca) + (uy*sca);
    R[1][0] = (uy*ux*omcca) + (uz*sca);
    R[1][1] = cca + (uy*uy*omcca);
    R[1][2] = (uy*uz*omcca) - (ux*sca);
    R[2][0] = (uz*ux*omcca) - (uy*sca);
    R[2][1] = (uz*uy*omcca) + (ux*sca);
    R[2][2] = cca + (uz*uz*omcca);
    for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
      double x = mc[mc[var_mol_index].peers[ci]].x - mc[var_mol_index].x;
      double y = mc[mc[var_mol_index].peers[ci]].y - mc[var_mol_index].y;
      double z = mc[mc[var_mol_index].peers[ci]].z - mc[var_mol_index].z;
      mc[mc[var_mol_index].peers[ci]].x = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z) + mc[var_mol_index].x;
      mc[mc[var_mol_index].peers[ci]].y = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z) + mc[var_mol_index].y;
      mc[mc[var_mol_index].peers[ci]].z = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z) + mc[var_mol_index].z;
      x = mc[mc[var_mol_index].peers[ci]].kx - mc[var_mol_index].x;
      y = mc[mc[var_mol_index].peers[ci]].ky - mc[var_mol_index].y;
      z = mc[mc[var_mol_index].peers[ci]].kz - mc[var_mol_index].z;
      mc[mc[var_mol_index].peers[ci]].kx = (R[0][0]*x) + (R[0][1]*y) + (R[0][2]*z) + mc[var_mol_index].x;
      mc[mc[var_mol_index].peers[ci]].ky = (R[1][0]*x) + (R[1][1]*y) + (R[1][2]*z) + mc[var_mol_index].y;
      mc[mc[var_mol_index].peers[ci]].kz = (R[2][0]*x) + (R[2][1]*y) + (R[2][2]*z) + mc[var_mol_index].z;
    }
  }
  double dx = mc[fixed_comp_index].x - mc[var_comp_index].x;
  double dy = mc[fixed_comp_index].y - mc[var_comp_index].y;
  double dz = mc[fixed_comp_index].z - mc[var_comp_index].z;
  mc[var_mol_index].x += dx;
  mc[var_mol_index].y += dy;
  mc[var_mol_index].z += dz;
  for (int ci=0; ci&lt;mc[var_mol_index].num_peers; ci++) {
    mc[mc[var_mol_index].peers[ci]].x += dx;
    mc[mc[var_mol_index].peers[ci]].y += dy;
    mc[mc[var_mol_index].peers[ci]].z += dz;
    mc[mc[var_mol_index].peers[ci]].kx += dx;
    mc[mc[var_mol_index].peers[ci]].ky += dy;
    mc[mc[var_mol_index].peers[ci]].kz += dz;
  }
}
static void bind_all_molecules ( struct volume *world, external_molcomp_loc *molcomp_array, int num_parts, bool as3D, bool with_rot ) {
  int mi=0;
  int pi=0;
  for (mi=0; mi&lt;num_parts; mi++) {
    if (molcomp_array[mi].is_mol) break;
  }
  if (molcomp_array[mi].is_mol) {
    molcomp_array[mi].is_final = true;
    for (int ci=0; ci&lt;molcomp_array[mi].num_peers; ci++) {
      molcomp_array[molcomp_array[mi].peers[ci]].is_final = true;
    }
    int done = 0;
    while (done == 0) {
      done = 1;
      for (mi=0; mi&lt;num_parts; mi++) {
        if (!molcomp_array[mi].is_mol) {
          if (molcomp_array[mi].num_peers &gt; 1) {
            for (int ci=1; ci&lt;molcomp_array[mi].num_peers; ci++) {
              pi = molcomp_array[mi].peers[ci];                if (molcomp_array[mi].is_final != molcomp_array[pi].is_final) {
                done = 0;
                int fci, vci;                  int vmi;                  if (molcomp_array[mi].is_final) {
                  fci = mi;
                  vci = pi;
                } else {
                  fci = pi;
                  vci = mi;
                }
                vmi = molcomp_array[vci].peers[0];
                bind_molecules_at_components ( world, molcomp_array, num_parts, fci, vci, as3D, with_rot );
                molcomp_array[vmi].is_final = true;
                for (int vmici=0; vmici&lt;molcomp_array[vmi].num_peers; vmici++) {
                  molcomp_array[molcomp_array[vmi].peers[vmici]].is_final = true;
                }
              }
            }
          }
        }
      }
    }
  }
}
static external_molcomp_loc *build_molcomp_array ( struct volume *world, char **graph_strings ) {
  int part_num;
  char *next_part;
  part_num = 0;
  next_part = graph_strings[part_num];
  while (next_part != NULL) {
    part_num++;
    next_part = graph_strings[part_num];
  }
  external_molcomp_loc *molcomp_loc_array = (external_molcomp_loc *) malloc ( part_num * sizeof(external_molcomp_loc) );
  part_num = 0;
  next_part = graph_strings[part_num];
  while (next_part != NULL) {
    molcomp_loc_array[part_num].has_coords = 0;
    molcomp_loc_array[part_num].graph_string = (char *) malloc ( 1 + strlen(next_part) );
    strcpy ( molcomp_loc_array[part_num].graph_string, next_part );
    molcomp_loc_array[part_num].x = 0;
    molcomp_loc_array[part_num].y = 0;
    molcomp_loc_array[part_num].z = 0;
    molcomp_loc_array[part_num].states = NULL;
    if (strstr(next_part,"m:") == next_part) {
      molcomp_loc_array[part_num].is_mol = 1;
      if (strchr(next_part,'!') == NULL) {
        molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
        strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
      } else {
        char *end_point = strchr(next_part,'!');
        *end_point = '\0';
        molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
        strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
        *end_point = '!';
      }
      char *at_sign = strchr(molcomp_loc_array[part_num].name, '@');
      if (at_sign != NULL) {
        *at_sign = '\0';
        char *shorter_name = (char *) malloc ( 1 + strlen(molcomp_loc_array[part_num].name) );
        strcpy ( shorter_name, molcomp_loc_array[part_num].name );
        *at_sign = '@';
        free ( molcomp_loc_array[part_num].name );
        molcomp_loc_array[part_num].name = shorter_name;
      }
      molcomp_loc_array[part_num].num_peers = 0;
      molcomp_loc_array[part_num].peers = NULL;
      char *next_excl = strchr(next_part,'!');
      while (next_excl != NULL) {
        molcomp_loc_array[part_num].num_peers++;
        next_excl++;
        next_excl = strchr(next_excl,'!');
      }
      if (molcomp_loc_array[part_num].num_peers &gt; 0) {
        molcomp_loc_array[part_num].peers = (int *) malloc ( molcomp_loc_array[part_num].num_peers * sizeof(int) );
        next_excl = strchr(next_part,'!');
        int peer_num = 0;
        int comp_index;
        while (next_excl != NULL) {
          next_excl++;
          comp_index = atoi(next_excl);
          molcomp_loc_array[part_num].peers[peer_num] = comp_index;
          peer_num++;
          next_excl = strchr(next_excl,'!');
        }
      }
    } else {
      molcomp_loc_array[part_num].is_mol = 0;
      char *first_exc = strchr(next_part,'!');
      char *first_til = strchr(next_part,'~');
      char *end_point;
      char previous_end;
      if ( (first_exc != NULL) &amp;&amp; (first_til != NULL) ) {
        if (first_exc &lt; first_til) {
          end_point = first_exc;
        } else {
          end_point = first_til;
        }
      } else if (first_exc != NULL) {
        end_point = first_exc;
      } else if (first_til != NULL) {
        end_point = first_til;
      } else {
        end_point = strchr(next_part,'\0');
      }
      previous_end = *end_point;
      *end_point = '\0';
      molcomp_loc_array[part_num].name = (char *) malloc ( 1 + strlen(next_part) - 2 );
      strcpy ( molcomp_loc_array[part_num].name, &amp;next_part[2] );
      *end_point = previous_end;
      if (first_til != NULL) {
        if (first_exc != NULL) {
          end_point = first_exc;
        } else {
          end_point = strchr(next_part,'\0');
        }
        previous_end = *end_point;
        *end_point = '\0';
        molcomp_loc_array[part_num].states = (char *) malloc ( 1 + strlen(first_til) );
        strcpy ( molcomp_loc_array[part_num].states, first_til );
        *end_point = previous_end;
      }
      molcomp_loc_array[part_num].num_peers = 0;
      molcomp_loc_array[part_num].peers = NULL;
      char *next_excl = strchr(next_part,'!');
      while (next_excl != NULL) {
        molcomp_loc_array[part_num].num_peers++;
        next_excl++;
        next_excl = strchr(next_excl,'!');
      }
      if (molcomp_loc_array[part_num].num_peers &gt; 0) {
        molcomp_loc_array[part_num].peers = (int *) malloc ( molcomp_loc_array[part_num].num_peers * sizeof(int) );
        next_excl = strchr(next_part,'!');
        int peer_num = 0;
        int comp_index;
        while (next_excl != NULL) {
          next_excl++;
          comp_index = atoi(next_excl);
          molcomp_loc_array[part_num].peers[peer_num] = comp_index;
          peer_num++;
          next_excl = strchr(next_excl,'!');
        }
      }
    }
    part_num++;
    next_part = graph_strings[part_num];
  }
  set_component_positions_by_table ( world, molcomp_loc_array, part_num );
  bind_all_molecules ( world, molcomp_loc_array, part_num, true, true );
  if (world-&gt;dump_level &gt;= 20) {
    fprintf ( stdout, "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Final molcomp_loc_array &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n" );
    dump_molcomp_array ( molcomp_loc_array, part_num );
    fprintf ( stdout, "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n" );
  }
  return molcomp_loc_array;
}
static char **get_graph_strings ( char *nauty_string ) {
  int num_parts;
  int part_num;
  char **graph_parts;
  char *first, *last;
  part_num = 0;
  first = nauty_string;
  last = strchr ( first, ',' );
  while (last != NULL) {
    first = last+1;
    last = strchr ( first, ',' );
    part_num++;
  }
  num_parts = part_num;
  graph_parts = (char **) malloc ( (num_parts+1) * sizeof(char *) );
  graph_parts[num_parts] = NULL; 
  part_num = 0;
  first = nauty_string;
  last = strchr ( first, ',' );
  while (last != NULL) {
    *last = '\0';
    char *s = (char *) malloc ( strlen(first) + 1 );
    strcpy ( s, first );
    graph_parts[part_num] = s;
    *last = ',';
    first = last+1;
    last = strchr ( first, ',' );
    part_num++;
  }
  return graph_parts;
}
static void free_graph_parts ( char **graph_parts ) {
  if (graph_parts != NULL) {
    int part_num = 0;
    char *next_part = graph_parts[part_num];
    while (next_part != NULL) {
      free ( next_part );
      part_num++;
      next_part = graph_parts[part_num];
    }
    free ( graph_parts );
  }
}
static void end_line_opt_comma ( FILE *space_struct_file, bool add_comma ) {
  if (add_comma) {
    fprintf ( space_struct_file, "," );
  }
  fprintf ( space_struct_file, "\n" );
}
static int output_cellblender_molecules(struct volume *world,
                                        struct viz_output_block *vizblk,
                                        struct frame_data_list *fdlp) {
  no_printf("Output in CELLBLENDER mode (molecules only)...\n");
  if ( (world-&gt;dump_level &gt;= 20) &amp;&amp; (world-&gt;viz_options != VIZ_OPTS_NONE) ) {
    fprintf ( stdout, "vizblk-&gt;file_prefix_name = \"%s\"\n", vizblk-&gt;file_prefix_name );
  }
  if ( (world-&gt;dump_level &gt;= 5) &amp;&amp; (world-&gt;viz_options != VIZ_OPTS_NONE) ) {
    fprintf ( stdout, "Visualization Options = 0x%lx\n", world-&gt;viz_options );
    fprintf ( stdout, "Proxy = 0x%lx\n", world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT );
  }
  if (world-&gt;dump_level &gt;= 50) {
    fprintf ( stdout, "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Top of MolViz Output &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n" );
  }
  char *file_prefix_no_Scene = NULL;
  char *file_prefix_usually_Scene = NULL;
  char *last_sep = strrchr ( vizblk-&gt;file_prefix_name, '/' );
  file_prefix_usually_Scene = my_strcat ( last_sep+1, NULL );
  *last_sep = '\0';
  file_prefix_no_Scene = my_strcat ( vizblk-&gt;file_prefix_name, NULL );
  *last_sep = '/';
  if ((fdlp-&gt;type == ALL_MOL_DATA) || (fdlp-&gt;type == MOL_POS)) {
    long long lli = 10;
    int ndigits = 1;
    for (; lli &lt;= world-&gt;iterations &amp;&amp; ndigits &lt; 20;
         lli *= 10, ndigits++) {
    }
    char *cf_name =
        CHECKED_SPRINTF("%s.cellbin.%.*lld.dat", vizblk-&gt;file_prefix_name,
                        ndigits, fdlp-&gt;viz_iteration);
    if (cf_name == NULL)
      return 1;
    if (make_parent_dir(cf_name)) {
      free(cf_name);
      mcell_error(
          "Failed to create parent directory for CELLBLENDER-mode VIZ output.");
    }
    FILE *custom_file = open_file(cf_name, "wb");
    if (!custom_file)
      mcell_die();
    else {
      no_printf("Writing to file %s\n", cf_name);
    }
    free(cf_name);
    cf_name = NULL;
    FILE *space_struct_file = NULL;
    if (world-&gt;viz_options &amp; VIZ_ALT_FILES_MASK) {
      if (world-&gt;dump_level &gt;= 20) {
        fprintf ( stdout, "Spatially Structured Option = 0x%lx\n", world-&gt;viz_options &amp; VIZ_ALT_FILES_MASK );
      }
      cf_name =
          CHECKED_SPRINTF("%s/viz_bngl/%s.bnglviz.%.*lld.dat", file_prefix_no_Scene, file_prefix_usually_Scene,
                          ndigits, fdlp-&gt;viz_iteration);
      if (cf_name == NULL)
        return 1;
      if (make_parent_dir(cf_name)) {
        free(cf_name);
        mcell_error(
            "Failed to create parent directory for SPATIAL-mode VIZ output.");
      }
      space_struct_file = open_file(cf_name, "wb");
      if (!space_struct_file) {
        mcell_die();
      } else {
        no_printf("Writing to file %s\n", cf_name);
      }
      free(cf_name);
      cf_name = NULL;
    }
    u_int *viz_mol_count = NULL;
    struct abstract_molecule ***viz_molp = NULL;
    if (sort_molecules_by_species(
        world, vizblk, &amp;viz_molp, &amp;viz_mol_count, 1, 1)) {
      fclose(custom_file);
      custom_file = NULL;
      return 1;
    }
    u_int cellbin_version = 1;
    fwrite(&amp;cellbin_version, sizeof(cellbin_version), 1, custom_file);
    for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
      const unsigned int this_mol_count = viz_mol_count[species_idx];
      if (this_mol_count == 0)
        continue;
      const int id = vizblk-&gt;species_viz_states[species_idx];
      if (id == EXCLUDE_OBJ)
        continue;
      struct abstract_molecule **const mols = viz_molp[species_idx];
      if (mols == NULL)
        continue;
      struct abstract_molecule *amp = mols[0];       if ( (world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT) || ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) == 0) ) {
        char mol_name[33];
        if (id == INCLUDE_OBJ) {
          snprintf(mol_name, 33, "%s", amp-&gt;properties-&gt;sym-&gt;name);
        } else {
          snprintf(mol_name, 33, "%d", id);
        }
        byte name_len = strlen(mol_name);
        fwrite(&amp;name_len, sizeof(name_len), 1, custom_file);
        fwrite(mol_name, sizeof(char), name_len, custom_file);
        byte species_type = 0;
        if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
          species_type = 1;
        }
        fwrite(&amp;species_type, sizeof(species_type), 1, custom_file);
        u_int n_floats = 3 * this_mol_count;
        fwrite(&amp;n_floats, sizeof(n_floats), 1, custom_file);
        float pos_x = 0.0;
        float pos_y = 0.0;
        float pos_z = 0.0;
        for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
          amp = mols[n_mol];
          if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
            struct volume_molecule *mp = (struct volume_molecule *)amp;
            struct vector3 pos_output = {0.0, 0.0, 0.0};
            if (!convert_relative_to_abs_PBC_coords(
                world-&gt;periodic_box_obj,
                mp-&gt;periodic_box,
                world-&gt;periodic_traditional,
                &amp;mp-&gt;pos,
                &amp;pos_output)) {
              pos_x = pos_output.x;
              pos_y = pos_output.y;
              pos_z = pos_output.z;
            }
            else {
              pos_x = mp-&gt;pos.x;
              pos_y = mp-&gt;pos.y;
              pos_z = mp-&gt;pos.z;
            }
          } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
            struct surface_molecule *gmp = (struct surface_molecule *)amp;
            struct vector3 where;
            uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
            struct vector3 pos_output = {0.0, 0.0, 0.0};
            if (!convert_relative_to_abs_PBC_coords(
                world-&gt;periodic_box_obj,
                gmp-&gt;periodic_box,
                world-&gt;periodic_traditional,
                &amp;where,
                &amp;pos_output)) {
              pos_x = pos_output.x;
              pos_y = pos_output.y;
              pos_z = pos_output.z;
            }
            else {
              pos_x = where.x;
              pos_y = where.y;
              pos_z = where.z;
            }
          }
          pos_x *= world-&gt;length_unit;
          pos_y *= world-&gt;length_unit;
          pos_z *= world-&gt;length_unit;
          fwrite(&amp;pos_x, sizeof(pos_x), 1, custom_file);
          fwrite(&amp;pos_y, sizeof(pos_y), 1, custom_file);
          fwrite(&amp;pos_z, sizeof(pos_z), 1, custom_file);
        }
        amp = mols[0];
        if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
          for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
            struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
            short orient = gmp-&gt;orient;
            float norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
<a name="0"></a>            float norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
            float norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>            if (world-&gt;periodic_box_obj &amp;&amp; !(world-&gt;periodic_traditional)) {
              if (gmp-&gt;periodic_box-&gt;x % 2 != 0) {
                norm_x *= -1;
              }
              if (gmp-&gt;periodic_box-&gt;y % 2 != 0) {
                norm_y *= -1;
              }
              if (gmp-&gt;periodic_box-&gt;z % 2 != 0) {
                norm_z *= -1;
              }
            }</b></font>
            fwrite(&amp;norm_x, sizeof(norm_x), 1, custom_file);
            fwrite(&amp;norm_y, sizeof(norm_y), 1, custom_file);
            fwrite(&amp;norm_z, sizeof(norm_z), 1, custom_file);
          }
        }
      }
    } 
    external_mol_viz_by_name *mol_name_list = NULL;
    for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
      const unsigned int this_mol_count = viz_mol_count[species_idx];
      if (this_mol_count == 0)
        continue;
      const int id = vizblk-&gt;species_viz_states[species_idx];
      if (id == EXCLUDE_OBJ)
        continue;
      struct abstract_molecule **const mols = viz_molp[species_idx];
      if (mols == NULL)
        continue;
      struct abstract_molecule *amp;
      amp = mols[0];
      char mol_name[33];
      if (id == INCLUDE_OBJ) {
        snprintf(mol_name, 33, "%s", amp-&gt;properties-&gt;sym-&gt;name);
      } else {
        snprintf(mol_name, 33, "%d", id);
      }
      for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
        amp = mols[n_mol];
        float pos_x = 0.0;
        float pos_y = 0.0;
        float pos_z = 0.0;
        float norm_x = 0.0;
        float norm_y = 0.0;
        float norm_z = 0.0;
        if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
          struct volume_molecule *mp = (struct volume_molecule *)amp;
          pos_x = mp-&gt;pos.x;
          pos_y = mp-&gt;pos.y;
          pos_z = mp-&gt;pos.z;
        } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
          struct surface_molecule *gmp = (struct surface_molecule *)amp;
          struct vector3 where;
          uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
          pos_x = where.x;
          pos_y = where.y;
          pos_z = where.z;
        }
        pos_x *= world-&gt;length_unit;
        pos_y *= world-&gt;length_unit;
        pos_z *= world-&gt;length_unit;
        char mol_type = 'v';
        if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
          mol_type = 's';
          struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
          short orient = gmp-&gt;orient;
          norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
          norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
          norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
        }
        float x_offset = 0.0;
        if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
          char *next_mol = amp-&gt;graph_data-&gt;graph_pattern;
          if (graph_pattern_table == NULL) {
            graph_pattern_table = init_symtab ( 10 );
          }
          struct sym_entry *sp;
          sp = retrieve_sym(next_mol, graph_pattern_table);
          if (sp == NULL) {
            char **graph_parts = get_graph_strings ( next_mol );
            if (world-&gt;dump_level &gt;= 10) {
              fprintf ( stdout, "=#= New Graph Pattern: %s\n", next_mol );
            }
            int num_parts = 0;
            char *next_part = graph_parts[num_parts];
            while (next_part != NULL) {
              if (world-&gt;dump_level &gt;= 20) {
                fprintf ( stdout, "  Graph Part %d: %s\n", num_parts, next_part );
              }
              num_parts++;
              next_part = graph_parts[num_parts];
            }
            external_molcomp_loc *molcomp_array = build_molcomp_array ( world, graph_parts );
            if (world-&gt;dump_level &gt;= 10) {
              fprintf ( stdout, "=============== molcomp_array ===============\n" );
              dump_molcomp_array ( molcomp_array, num_parts );
              fprintf ( stdout, "=============================================\n" );
            }
            molcomp_list *mcl = (molcomp_list *) malloc ( sizeof(molcomp_list) );
            mcl-&gt;molcomp_array = molcomp_array;
            mcl-&gt;num_molcomp_items = num_parts;
            mcl-&gt;molcomp_id = next_molcomp_id;
            next_molcomp_id += 1;
            sp = store_sym ( next_mol, VOID_PTR, graph_pattern_table, mcl );
            free_graph_parts ( graph_parts );
          }
          molcomp_list *mcl = NULL;
          if (sp != NULL) {
            mcl = (molcomp_list *) sp-&gt;value;
            int part_num;
            for (part_num = 0; part_num&lt;mcl-&gt;num_molcomp_items; part_num++) {
              if ( mcl-&gt;molcomp_array[part_num].is_mol == false ) {
                if ((mcl-&gt;molcomp_array[part_num].x==0) &amp;&amp; (mcl-&gt;molcomp_array[part_num].y==0) &amp;&amp; (mcl-&gt;molcomp_array[part_num].z==0) ) {
                  mcl = NULL;
                  break;
                }
              }
            }
          }
          if (mcl != NULL) {
            int part_num;
            for (part_num = 0; part_num&lt;mcl-&gt;num_molcomp_items; part_num++) {
              if ( mcl-&gt;molcomp_array[part_num].is_mol || (world-&gt;viz_options!=VIZ_OPTS_NONE) ) {
                char *name_to_find_or_add = NULL;
                if (mcl-&gt;molcomp_array[part_num].is_mol) {
                  name_to_find_or_add = (char *) malloc (1+strlen(mcl-&gt;molcomp_array[part_num].name));
                  strcpy ( name_to_find_or_add, mcl-&gt;molcomp_array[part_num].name );
                } else {
                  int viz_naming_bits = world-&gt;viz_options &amp; VIZ_COMP_NAMING_MASK;
                  if (viz_naming_bits == VIZ_COMP_ALL_SAME) {
                    name_to_find_or_add = (char *) malloc (1+strlen("component"));
                    strcpy ( name_to_find_or_add, "component" );
                  } else if (viz_naming_bits == VIZ_COMP_NAME_GLOBAL) {
                    name_to_find_or_add = (char *) malloc (1+strlen("comp_")+strlen(mcl-&gt;molcomp_array[part_num].name));
                    strcpy ( name_to_find_or_add, "comp_" );
                    strcpy ( &amp;name_to_find_or_add[strlen("comp_")], mcl-&gt;molcomp_array[part_num].name );
                  } else if (viz_naming_bits == VIZ_COMP_MOL_LOCAL) {
                    char *last_mol_name = NULL;
                    if (mcl-&gt;molcomp_array[part_num].num_peers &lt; 1) {
                      last_mol_name = (char *) malloc (1+strlen("unknown_"));
                      strcpy ( last_mol_name, "unknown_" );
                    } else {
                      char *name_ptr = mcl-&gt;molcomp_array[mcl-&gt;molcomp_array[part_num].peers[0]].name;
                      last_mol_name = (char *) malloc (1+strlen(name_ptr));
                      strcpy ( last_mol_name, name_ptr );
                    }
                    name_to_find_or_add = (char *) malloc (1+strlen(last_mol_name)+strlen("_comp_")+strlen(mcl-&gt;molcomp_array[part_num].name));
                    strcpy ( name_to_find_or_add,                               last_mol_name );
                    strcpy ( &amp;name_to_find_or_add[strlen(name_to_find_or_add)], "_comp_" );
                    strcpy ( &amp;name_to_find_or_add[strlen(name_to_find_or_add)], mcl-&gt;molcomp_array[part_num].name );
                    if (last_mol_name != NULL) {
                      free ( last_mol_name );
                    }
                  }
                }
                external_mol_viz_by_name *next_mol_name = mol_name_list;
                int found = 0;
                do {
                  if (next_mol_name == NULL) {
                    break;
                  }
                  if (strcmp(name_to_find_or_add, next_mol_name-&gt;mol_name) == 0) {
                    found = 1;
                    break;
                  }
                  next_mol_name = next_mol_name-&gt;next_name;
                } while ( found == 0 );
                if (found == 0) {
                  next_mol_name = (external_mol_viz_by_name *) malloc ( sizeof(external_mol_viz_by_name) );
                  next_mol_name-&gt;mol_name = name_to_find_or_add;                    next_mol_name-&gt;mol_list = NULL;
                  next_mol_name-&gt;next_name = mol_name_list;
                  mol_name_list = next_mol_name;
                } else {
                  if (name_to_find_or_add != NULL) {
                    free ( name_to_find_or_add );
                    name_to_find_or_add = NULL;
                  }
                }
						    external_mol_viz *new_mol_viz_item = (external_mol_viz *) malloc ( sizeof(external_mol_viz) );
                new_mol_viz_item-&gt;mol_type = mol_type;
                new_mol_viz_item-&gt;pos_x = pos_x + mcl-&gt;molcomp_array[part_num].x;
                new_mol_viz_item-&gt;pos_y = pos_y + mcl-&gt;molcomp_array[part_num].y;
                new_mol_viz_item-&gt;pos_z = pos_z + mcl-&gt;molcomp_array[part_num].z;
                new_mol_viz_item-&gt;norm_x = norm_x;
                new_mol_viz_item-&gt;norm_y = norm_y;
                new_mol_viz_item-&gt;norm_z = norm_z;
                new_mol_viz_item-&gt;next_mol = next_mol_name-&gt;mol_list;
                next_mol_name-&gt;mol_list = new_mol_viz_item;
                next_mol += 1;
              }
            }
          } else {
            while ((next_mol = strstr(next_mol,"m:")) != NULL ) {
              char *end_mol = strpbrk ( next_mol, "@!,(~" );
              if (end_mol == NULL) {
                end_mol = next_mol + strlen(next_mol);
              }
              int ext_name_len = end_mol - next_mol;
              char *ext_name = (char *) malloc ( ext_name_len + 1 );
              strncpy ( ext_name, next_mol+2, ext_name_len-2 );
              ext_name[ext_name_len-2] = '\0';
              external_mol_viz_by_name *next_mol_name = mol_name_list;
              int found = 0;
              do {
                if (next_mol_name == NULL) {
                  break;
                }
                if (strcmp(ext_name, next_mol_name-&gt;mol_name) == 0) {
                  found = 1;
                  break;
                }
                next_mol_name = next_mol_name-&gt;next_name;
              } while ( found == 0 );
              if (found == 0) {
                next_mol_name = (external_mol_viz_by_name *) malloc ( sizeof(external_mol_viz_by_name) );
                next_mol_name-&gt;mol_name = ext_name;                  next_mol_name-&gt;mol_list = NULL;
                next_mol_name-&gt;next_name = mol_name_list;
                mol_name_list = next_mol_name;
              } else {
                free ( ext_name );
              }
						  external_mol_viz *new_mol_viz_item = (external_mol_viz *) malloc ( sizeof(external_mol_viz) );
              new_mol_viz_item-&gt;mol_type = mol_type;
              new_mol_viz_item-&gt;pos_x = pos_x + x_offset;               new_mol_viz_item-&gt;pos_y = pos_y;
              new_mol_viz_item-&gt;pos_z = pos_z;
              new_mol_viz_item-&gt;norm_x = norm_x;
              new_mol_viz_item-&gt;norm_y = norm_y;
              new_mol_viz_item-&gt;norm_z = norm_z;
              new_mol_viz_item-&gt;next_mol = next_mol_name-&gt;mol_list;
              next_mol_name-&gt;mol_list = new_mol_viz_item;
              next_mol += 1;
            }
          }
        }
      }
    }
    external_mol_viz_by_name *nl = mol_name_list;
    external_mol_viz *mv;
    while (nl != NULL) {
      if ( (world-&gt;viz_options &amp; VIZ_PROXY_OUTPUT) || ( (strcmp(nl-&gt;mol_name,"volume_proxy")!=0) &amp;&amp; (strcmp(nl-&gt;mol_name,"volume_proxy")!=0) ) ) {
        byte name_len = strlen(nl-&gt;mol_name);
        fwrite(&amp;name_len, sizeof(name_len), 1, custom_file);
        fwrite(nl-&gt;mol_name, sizeof(char), name_len, custom_file);
        byte species_type = 0;
        if (nl-&gt;mol_list != NULL) {
          if (nl-&gt;mol_list-&gt;mol_type == 's') {
            species_type = 1;
          }
        }
        fwrite(&amp;species_type, sizeof(species_type), 1, custom_file);
        u_int n_floats = 0;
        mv = nl-&gt;mol_list;
        while (mv != NULL) {
          n_floats += 3;
          mv = mv-&gt;next_mol;
        }
        fwrite(&amp;n_floats, sizeof(n_floats), 1, custom_file);
        mv = nl-&gt;mol_list;
        while (mv != NULL) {
          float pos_x = mv-&gt;pos_x;
          float pos_y = mv-&gt;pos_y;
          float pos_z = mv-&gt;pos_z;
          fwrite(&amp;pos_x, sizeof(pos_x), 1, custom_file);
          fwrite(&amp;pos_y, sizeof(pos_y), 1, custom_file);
          fwrite(&amp;pos_z, sizeof(pos_z), 1, custom_file);
          mv = mv-&gt;next_mol;
        }
        mv = nl-&gt;mol_list;
        if (mv-&gt;mol_type == 's') {
          while (mv != NULL) {
            float norm_x = mv-&gt;norm_x;
            float norm_y = mv-&gt;norm_y;
            float norm_z = mv-&gt;norm_z;
            fwrite(&amp;norm_x, sizeof(norm_x), 1, custom_file);
            fwrite(&amp;norm_y, sizeof(norm_y), 1, custom_file);
            fwrite(&amp;norm_z, sizeof(norm_z), 1, custom_file);
            mv = mv-&gt;next_mol;
          }
        }
        nl = nl-&gt;next_name;
      }
    }
    if (space_struct_file != NULL) {
      if ( world-&gt;viz_options &amp; VIZ_ALT_DUMP_FMT ) {
        u_int ss_version = 2;
        fprintf ( space_struct_file, "%d\n", ss_version );
        if (graph_pattern_table != NULL) {
          for (int bin=0; bin&lt;graph_pattern_table-&gt;n_bins; bin++) {
            if (graph_pattern_table-&gt;entries[bin] != NULL) {
              struct sym_entry *se = graph_pattern_table-&gt;entries[bin];
              while (se != NULL) {
                fprintf ( space_struct_file, "Entry: %s\n", se-&gt;name );
                molcomp_list *mcl = (molcomp_list *) se-&gt;value;
                dump_molcomp_list_to ( space_struct_file, mcl );
                se = se-&gt;next;
              }
            }
          }
        }
        for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
          const unsigned int this_mol_count = viz_mol_count[species_idx];
          if (this_mol_count == 0)
            continue;
          const int id = vizblk-&gt;species_viz_states[species_idx];
          if (id == EXCLUDE_OBJ)
            continue;
          struct abstract_molecule **const mols = viz_molp[species_idx];
          if (mols == NULL)
            continue;
          struct abstract_molecule *amp;
          for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
            amp = mols[n_mol];
            if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
              char *gp = amp-&gt;graph_data-&gt;graph_pattern;
              long mol_class = -1;
              if (graph_pattern_table != NULL) {
                struct sym_entry *sp;
                sp = retrieve_sym(gp, graph_pattern_table);
                if (sp != NULL) {
                  molcomp_list *mcl = NULL;
                  mcl = (molcomp_list *) sp-&gt;value;
                  mol_class = -1 * mcl-&gt;molcomp_id;                  }
              }
              float pos_x = 0.0;
              float pos_y = 0.0;
              float pos_z = 0.0;
              float norm_x = 0.0;
              float norm_y = 0.0;
              float norm_z = 0.0;
              if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
                struct volume_molecule *mp = (struct volume_molecule *)amp;
                pos_x = mp-&gt;pos.x;
                pos_y = mp-&gt;pos.y;
                pos_z = mp-&gt;pos.z;
              } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
                struct surface_molecule *gmp = (struct surface_molecule *)amp;
                struct vector3 where;
                uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
                pos_x = where.x;
                pos_y = where.y;
                pos_z = where.z;
              }
              pos_x *= world-&gt;length_unit;
              pos_y *= world-&gt;length_unit;
              pos_z *= world-&gt;length_unit;
              if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
                struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
                short orient = gmp-&gt;orient;
                norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
                norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
                norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
              }
              fprintf ( space_struct_file, "Mol %d:  Class=%ld  Position=(%g %g %g)  Orientation=(%g %g %g)\n", n_mol, mol_class, pos_x, pos_y, pos_z, norm_x, norm_y, norm_z );
            }
          }
        }
        fflush ( space_struct_file );
        fclose ( space_struct_file );
      } else if ( world-&gt;viz_options &amp; VIZ_JSON_MOLCOMP_FMT ) {
        int *gp_entry_for_id = NULL;  
        fprintf ( space_struct_file, "[\n" );            fprintf ( space_struct_file, " 2,\n" );          fprintf ( space_struct_file, " [\n" );   
        if (graph_pattern_table != NULL) {
          int n_gp_entries = graph_pattern_table-&gt;n_entries;
          int gp_entry_num = 0;
          gp_entry_for_id = (int *) malloc ( n_gp_entries * sizeof(int) ); 
          for (int bin=0; bin&lt;graph_pattern_table-&gt;n_bins; bin++) {
            if (graph_pattern_table-&gt;entries[bin] != NULL) {
              struct sym_entry *se = graph_pattern_table-&gt;entries[bin];
              while (se != NULL) {
                molcomp_list *mcl = (molcomp_list *) se-&gt;value;
                gp_entry_for_id[mcl-&gt;molcomp_id] = gp_entry_num;                  external_molcomp_loc *mca = mcl-&gt;molcomp_array;
                int num_parts = mcl-&gt;num_molcomp_items;
                {
                  int i, j;
                  fprintf ( space_struct_file, "  [\n" );                    for (i=0; i&lt;num_parts; i++) {
                    fprintf ( space_struct_file, "   [ " );                      if (mca[i].is_mol) {
                      fprintf ( space_struct_file, "\"m\"" );
                    } else {
                      fprintf ( space_struct_file, "\"c\"" );
                    }
                    fprintf ( space_struct_file, ", \"%s\"", mca[i].name );
                    fprintf ( space_struct_file, ", [%g, %g, %g], [", mca[i].x, mca[i].y, mca[i].z );
                    for (j=0; j&lt;mca[i].num_peers; j++) {
                      fprintf ( space_struct_file, "%d", mca[i].peers[j] );
                      if (j &lt; mca[i].num_peers - 1) {
                        fprintf ( space_struct_file, "," );
                      }
                    }
                    if (mca[i].states == NULL) {
                      fprintf ( space_struct_file, "], \"\" ]" );                      } else if (strcmp(mca[i].states,"~NO_STATE")==0) {
                      fprintf ( space_struct_file, "], \"\" ]" );                      } else {
                      fprintf ( space_struct_file, "], \"%s\" ]", mca[i].states );                      }
                    end_line_opt_comma ( space_struct_file, i &lt; (num_parts-1) );
                  }
                  fprintf ( space_struct_file, "  ]" );                    gp_entry_num++;
                  end_line_opt_comma ( space_struct_file, gp_entry_num &lt; n_gp_entries );
                }
                se = se-&gt;next;
              }
            }
          }
        }
        fprintf ( space_struct_file, " ],\n" );  
        fprintf ( space_struct_file, " [" );          int first_pass = 1;
        for (int species_idx = 0; species_idx &lt; world-&gt;n_species; species_idx++) {
          const unsigned int this_mol_count = viz_mol_count[species_idx];
          if (this_mol_count == 0)
            continue;
          const int id = vizblk-&gt;species_viz_states[species_idx];
          if (id == EXCLUDE_OBJ)
            continue;
          struct abstract_molecule **const mols = viz_molp[species_idx];
          if (mols == NULL)
            continue;
          struct abstract_molecule *amp;
          for (unsigned int n_mol = 0; n_mol &lt; this_mol_count; ++n_mol) {
            amp = mols[n_mol];
            if ((amp-&gt;properties-&gt;flags &amp; EXTERNAL_SPECIES) != 0) {
              char *gp = amp-&gt;graph_data-&gt;graph_pattern;
              long mol_class = -1;
              if (graph_pattern_table != NULL) {
                struct sym_entry *sp;
                sp = retrieve_sym(gp, graph_pattern_table);
                if (sp != NULL) {
                  molcomp_list *mcl = NULL;
                  mcl = (molcomp_list *) sp-&gt;value;
                  mol_class = gp_entry_for_id[mcl-&gt;molcomp_id];
                }
              }
              float pos_x = 0.0;
              float pos_y = 0.0;
              float pos_z = 0.0;
              float norm_x = 0.0;
              float norm_y = 0.0;
              float norm_z = 0.0;
              if ((amp-&gt;properties-&gt;flags &amp; NOT_FREE) == 0) {
                struct volume_molecule *mp = (struct volume_molecule *)amp;
                pos_x = mp-&gt;pos.x;
                pos_y = mp-&gt;pos.y;
                pos_z = mp-&gt;pos.z;
              } else if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
                struct surface_molecule *gmp = (struct surface_molecule *)amp;
                struct vector3 where;
                uv2xyz(&amp;(gmp-&gt;s_pos), gmp-&gt;grid-&gt;surface, &amp;where);
                pos_x = where.x;
                pos_y = where.y;
                pos_z = where.z;
              }
              pos_x *= world-&gt;length_unit;
              pos_y *= world-&gt;length_unit;
              pos_z *= world-&gt;length_unit;
              if ((amp-&gt;properties-&gt;flags &amp; ON_GRID) != 0) {
                struct surface_molecule *gmp = (struct surface_molecule *)mols[n_mol];
                short orient = gmp-&gt;orient;
                norm_x = orient * gmp-&gt;grid-&gt;surface-&gt;normal.x;
                norm_y = orient * gmp-&gt;grid-&gt;surface-&gt;normal.y;
                norm_z = orient * gmp-&gt;grid-&gt;surface-&gt;normal.z;
              }
              if ( first_pass ) {
                fprintf ( space_struct_file, "\n" );                  first_pass = 0;
              } else {
                fprintf ( space_struct_file, ",\n" );                }
              fprintf ( space_struct_file, "  [%ld,[%g,%g,%g],[%g,%g,%g]]", mol_class, pos_x, pos_y, pos_z, norm_x, norm_y, norm_z );
            }
          }
        }
        fprintf ( space_struct_file, "\n ]\n" );  
        fprintf ( space_struct_file, "]\n" );  
        fflush ( space_struct_file );
        fclose ( space_struct_file );
        if ( gp_entry_for_id != NULL ) {
          free ( gp_entry_for_id );
        }
      }
    }
    while (mol_name_list != NULL) {
      nl = mol_name_list;
      free ( nl-&gt;mol_name );
      while (nl-&gt;mol_list != NULL) {
        mv = nl-&gt;mol_list;
        nl-&gt;mol_list = mv-&gt;next_mol;
        free ( mv );
      }
      mol_name_list = nl-&gt;next_name;
      free ( nl );
    }
    fclose(custom_file);
    custom_file = NULL;
    free_ptr_array((void **)viz_molp, world-&gt;n_species);
    viz_molp = NULL;
    free(viz_mol_count);
    viz_mol_count = NULL;
  } 
  free ( file_prefix_no_Scene );
  free ( file_prefix_usually_Scene );
  if (world-&gt;dump_level &gt;= 50) {
    fprintf ( stdout, "&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Bottom of MolViz Output &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n" );
  }
  return 0;
}
int init_frame_data_list(struct volume *world,
                         struct viz_output_block *vizblk) {
  int mol_orient_frame_present = 0;
  int mol_pos_frame_present = 0;
  struct frame_data_list *fdlp;
  if (vizblk-&gt;frame_data_head == NULL)
    return 0;
  switch (vizblk-&gt;viz_mode) {
  case NO_VIZ_MODE:
    count_time_values(world, vizblk-&gt;frame_data_head);
    if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
      return 1;
    break;
  case ASCII_MODE:
    count_time_values(world, vizblk-&gt;frame_data_head);
    if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
      return 1;
    break;
  case CELLBLENDER_MODE_V1:
    count_time_values(world, vizblk-&gt;frame_data_head);
    if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
      return 1;
    break;
  default:
    count_time_values(world, vizblk-&gt;frame_data_head);
    if (reset_time_values(world, vizblk-&gt;frame_data_head, world-&gt;start_iterations))
      return 1;
    break;
  }
  for (fdlp = vizblk-&gt;frame_data_head; fdlp != NULL; fdlp = fdlp-&gt;next) {
    if (fdlp-&gt;curr_viz_iteration == NULL)
      continue;
    switch (fdlp-&gt;type) {
    case MOL_ORIENT:
      mol_orient_frame_present = 1;
      break;
    case MOL_POS:
      mol_pos_frame_present = 1;
      break;
    case ALL_MOL_DATA:
      mol_pos_frame_present = 1;
      mol_orient_frame_present = 1;
      break;
    default:
      ;
    }
  } 
  if ((mol_orient_frame_present) &amp; (!mol_pos_frame_present))
    mcell_warn("The input file contains ORIENTATIONS but not POSITIONS "
               "statement in the MOLECULES block. The molecules cannot be "
               "visualized.");
  return 0;
}
int update_frame_data_list(struct volume *world,
                           struct viz_output_block *vizblk) {
  static char const *const FRAME_TYPES[NUM_FRAME_TYPES] = {
    "MOL_POS",  "MOL_ORIENT", "ALL_MOL_DATA", 
  };
  if (vizblk == NULL)
    return 0;
  if (vizblk-&gt;frame_data_head == NULL)
    return 0;
  switch (world-&gt;notify-&gt;viz_output_report) {
  case NOTIFY_NONE:
    break;
  case NOTIFY_BRIEF:
  case NOTIFY_FULL:
    mcell_log("Updating viz output on iteration %lld.", world-&gt;current_iterations);
    break;
  default:
    UNHANDLED_CASE(world-&gt;notify-&gt;viz_output_report);
  }
  for (struct frame_data_list *fdlp = vizblk-&gt;frame_data_head; fdlp != NULL;
       fdlp = fdlp-&gt;next) {
    if (world-&gt;current_iterations != fdlp-&gt;viz_iteration)
      continue;
    if (world-&gt;notify-&gt;viz_output_report == NOTIFY_FULL) {
      if (fdlp-&gt;type &gt;= NUM_FRAME_TYPES)
        mcell_warn("  Updating data frame of unknown type %d.", fdlp-&gt;type);
      else
        mcell_log("  Updating data frame of type %s.", FRAME_TYPES[fdlp-&gt;type]);
    }
    switch (vizblk-&gt;viz_mode) {
    case ASCII_MODE:
      if (output_ascii_molecules(world, vizblk, fdlp))
        return 1;
      break;
    case CELLBLENDER_MODE_V1:
      if (output_cellblender_molecules(world, vizblk, fdlp))
        return 1;
      break;
    case NO_VIZ_MODE:
    default:
      break;
    }
    while (fdlp-&gt;curr_viz_iteration != NULL &amp;&amp;
           fdlp-&gt;viz_iteration == world-&gt;current_iterations) {
      fdlp-&gt;curr_viz_iteration = fdlp-&gt;curr_viz_iteration-&gt;next;
      if (fdlp-&gt;curr_viz_iteration)
        fdlp-&gt;viz_iteration = frame_iteration(
            world, fdlp-&gt;curr_viz_iteration-&gt;value, fdlp-&gt;list_type);
    }
    if (world-&gt;notify-&gt;viz_output_report == NOTIFY_FULL)
      mcell_log("  Next update on iteration %lld.", fdlp-&gt;viz_iteration);
  }
  return 0;
}
int finalize_viz_output(struct volume *world, struct viz_output_block *vizblk) {
  if (vizblk == NULL)
    return 0;
  switch (vizblk-&gt;viz_mode) {
  case NO_VIZ_MODE:
  case ASCII_MODE:
  default:
    break;
  }
  return 0;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
