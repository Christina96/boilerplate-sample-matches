
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.3622370446382766%, Tokens: 10</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc.c</h3>
            <pre><code>1  #include "src/dsp/dsp.h"
2  #include <assert.h>
3  #include <math.h>
4  #include <stdlib.h>
5  #include "src/dec/vp8li_dec.h"
6  #include "src/utils/endian_inl_utils.h"
7  #include "src/dsp/lossless.h"
8  #include "src/dsp/lossless_common.h"
9  #include "src/dsp/yuv.h"
10  const float kLog2Table[LOG_LOOKUP_IDX_MAX] = {
11    0.0000000000000000f, 0.0000000000000000f,
12    1.0000000000000000f, 1.5849625007211560f,
13    2.0000000000000000f, 2.3219280948873621f,
14    2.5849625007211560f, 2.8073549220576041f,
15    3.0000000000000000f, 3.1699250014423121f,
16    3.3219280948873621f, 3.4594316186372973f,
17    3.5849625007211560f, 3.7004397181410921f,
18    3.8073549220576041f, 3.9068905956085187f,
19    4.0000000000000000f, 4.0874628412503390f,
20    4.1699250014423121f, 4.2479275134435852f,
21    4.3219280948873626f, 4.3923174227787606f,
22    4.4594316186372973f, 4.5235619560570130f,
23    4.5849625007211560f, 4.6438561897747243f,
24    4.7004397181410917f, 4.7548875021634682f,
25    4.8073549220576037f, 4.8579809951275718f,
26    4.9068905956085187f, 4.9541963103868749f,
27    5.0000000000000000f, 5.0443941193584533f,
28    5.0874628412503390f, 5.1292830169449663f,
29    5.1699250014423121f, 5.2094533656289501f,
30    5.2479275134435852f, 5.2854022188622487f,
31    5.3219280948873626f, 5.3575520046180837f,
32    5.3923174227787606f, 5.4262647547020979f,
33    5.4594316186372973f, 5.4918530963296747f,
34    5.5235619560570130f, 5.5545888516776376f,
35    5.5849625007211560f, 5.6147098441152083f,
36    5.6438561897747243f, 5.6724253419714951f,
37    5.7004397181410917f, 5.7279204545631987f,
38    5.7548875021634682f, 5.7813597135246599f,
39    5.8073549220576037f, 5.8328900141647412f,
40    5.8579809951275718f, 5.8826430493618415f,
41    5.9068905956085187f, 5.9307373375628866f,
42    5.9541963103868749f, 5.9772799234999167f,
43    6.0000000000000000f, 6.0223678130284543f,
44    6.0443941193584533f, 6.0660891904577720f,
45    6.0874628412503390f, 6.1085244567781691f,
46    6.1292830169449663f, 6.1497471195046822f,
47    6.1699250014423121f, 6.1898245588800175f,
48    6.2094533656289501f, 6.2288186904958804f,
49    6.2479275134435852f, 6.2667865406949010f,
50    6.2854022188622487f, 6.3037807481771030f,
51    6.3219280948873626f, 6.3398500028846243f,
52    6.3575520046180837f, 6.3750394313469245f,
53    6.3923174227787606f, 6.4093909361377017f,
54    6.4262647547020979f, 6.4429434958487279f,
55    6.4594316186372973f, 6.4757334309663976f,
56    6.4918530963296747f, 6.5077946401986963f,
57    6.5235619560570130f, 6.5391588111080309f,
58    6.5545888516776376f, 6.5698556083309478f,
59    6.5849625007211560f, 6.5999128421871278f,
60    6.6147098441152083f, 6.6293566200796094f,
61    6.6438561897747243f, 6.6582114827517946f,
62    6.6724253419714951f, 6.6865005271832185f,
63    6.7004397181410917f, 6.7142455176661224f,
64    6.7279204545631987f, 6.7414669864011464f,
65    6.7548875021634682f, 6.7681843247769259f,
66    6.7813597135246599f, 6.7944158663501061f,
67    6.8073549220576037f, 6.8201789624151878f,
68    6.8328900141647412f, 6.8454900509443747f,
69    6.8579809951275718f, 6.8703647195834047f,
70    6.8826430493618415f, 6.8948177633079437f,
71    6.9068905956085187f, 6.9188632372745946f,
72    6.9307373375628866f, 6.9425145053392398f,
73    6.9541963103868749f, 6.9657842846620869f,
74    6.9772799234999167f, 6.9886846867721654f,
75    7.0000000000000000f, 7.0112272554232539f,
76    7.0223678130284543f, 7.0334230015374501f,
77    7.0443941193584533f, 7.0552824355011898f,
78    7.0660891904577720f, 7.0768155970508308f,
79    7.0874628412503390f, 7.0980320829605263f,
80    7.1085244567781691f, 7.1189410727235076f,
81    7.1292830169449663f, 7.1395513523987936f,
82    7.1497471195046822f, 7.1598713367783890f,
83    7.1699250014423121f, 7.1799090900149344f,
84    7.1898245588800175f, 7.1996723448363644f,
85    7.2094533656289501f, 7.2191685204621611f,
86    7.2288186904958804f, 7.2384047393250785f,
87    7.2479275134435852f, 7.2573878426926521f,
88    7.2667865406949010f, 7.2761244052742375f,
89    7.2854022188622487f, 7.2946207488916270f,
90    7.3037807481771030f, 7.3128829552843557f,
91    7.3219280948873626f, 7.3309168781146167f,
92    7.3398500028846243f, 7.3487281542310771f,
93    7.3575520046180837f, 7.3663222142458160f,
94    7.3750394313469245f, 7.3837042924740519f,
95    7.3923174227787606f, 7.4008794362821843f,
96    7.4093909361377017f, 7.4178525148858982f,
97    7.4262647547020979f, 7.4346282276367245f,
98    7.4429434958487279f, 7.4512111118323289f,
99    7.4594316186372973f, 7.4676055500829976f,
100    7.4757334309663976f, 7.4838157772642563f,
101    7.4918530963296747f, 7.4998458870832056f,
102    7.5077946401986963f, 7.5156998382840427f,
103    7.5235619560570130f, 7.5313814605163118f,
104    7.5391588111080309f, 7.5468944598876364f,
105    7.5545888516776376f, 7.5622424242210728f,
106    7.5698556083309478f, 7.5774288280357486f,
107    7.5849625007211560f, 7.5924570372680806f,
108    7.5999128421871278f, 7.6073303137496104f,
109    7.6147098441152083f, 7.6220518194563764f,
110    7.6293566200796094f, 7.6366246205436487f,
111    7.6438561897747243f, 7.6510516911789281f,
112    7.6582114827517946f, 7.6653359171851764f,
113    7.6724253419714951f, 7.6794800995054464f,
114    7.6865005271832185f, 7.6934869574993252f,
115    7.7004397181410917f, 7.7073591320808825f,
116    7.7142455176661224f, 7.7210991887071855f,
117    7.7279204545631987f, 7.7347096202258383f,
118    7.7414669864011464f, 7.7481928495894605f,
119    7.7548875021634682f, 7.7615512324444795f,
120    7.7681843247769259f, 7.7747870596011736f,
121    7.7813597135246599f, 7.7879025593914317f,
122    7.7944158663501061f, 7.8008998999203047f,
123    7.8073549220576037f, 7.8137811912170374f,
124    7.8201789624151878f, 7.8265484872909150f,
125    7.8328900141647412f, 7.8392037880969436f,
126    7.8454900509443747f, 7.8517490414160571f,
127    7.8579809951275718f, 7.8641861446542797f,
128    7.8703647195834047f, 7.8765169465649993f,
129    7.8826430493618415f, 7.8887432488982591f,
130    7.8948177633079437f, 7.9008668079807486f,
131    7.9068905956085187f, 7.9128893362299619f,
132    7.9188632372745946f, 7.9248125036057812f,
133    7.9307373375628866f, 7.9366379390025709f,
134    7.9425145053392398f, 7.9483672315846778f,
135    7.9541963103868749f, 7.9600019320680805f,
136    7.9657842846620869f, 7.9715435539507719f,
137    7.9772799234999167f, 7.9829935746943103f,
138    7.9886846867721654f, 7.9943534368588577f
139  };
140  const float kSLog2Table[LOG_LOOKUP_IDX_MAX] = {
141    0.00000000f,    0.00000000f,  2.00000000f,   4.75488750f,
142    8.00000000f,   11.60964047f,  15.50977500f,  19.65148445f,
143    24.00000000f,  28.52932501f,  33.21928095f,  38.05374781f,
144    43.01955001f,  48.10571634f,  53.30296891f,  58.60335893f,
145    64.00000000f,  69.48686830f,  75.05865003f,  80.71062276f,
146    86.43856190f,  92.23866588f,  98.10749561f,  104.04192499f,
147    110.03910002f, 116.09640474f, 122.21143267f, 128.38196256f,
148    134.60593782f, 140.88144886f, 147.20671787f, 153.58008562f,
149    160.00000000f, 166.46500594f, 172.97373660f, 179.52490559f,
150    186.11730005f, 192.74977453f, 199.42124551f, 206.13068654f,
151    212.87712380f, 219.65963219f, 226.47733176f, 233.32938445f,
152    240.21499122f, 247.13338933f, 254.08384998f, 261.06567603f,
153    268.07820003f, 275.12078236f, 282.19280949f, 289.29369244f,
154    296.42286534f, 303.57978409f, 310.76392512f, 317.97478424f,
155    325.21187564f, 332.47473081f, 339.76289772f, 347.07593991f,
156    354.41343574f, 361.77497759f, 369.16017124f, 376.56863518f,
157    384.00000000f, 391.45390785f, 398.93001188f, 406.42797576f,
158    413.94747321f, 421.48818752f, 429.04981119f, 436.63204548f,
159    444.23460010f, 451.85719280f, 459.49954906f, 467.16140179f,
160    474.84249102f, 482.54256363f, 490.26137307f, 497.99867911f,
161    505.75424759f, 513.52785023f, 521.31926438f, 529.12827280f,
162    536.95466351f, 544.79822957f, 552.65876890f, 560.53608414f,
163    568.42998244f, 576.34027536f, 584.26677867f, 592.20931226f,
164    600.16769996f, 608.14176943f, 616.13135206f, 624.13628279f,
165    632.15640007f, 640.19154569f, 648.24156472f, 656.30630539f,
166    664.38561898f, 672.47935976f, 680.58738488f, 688.70955430f,
167    696.84573069f, 704.99577935f, 713.15956818f, 721.33696754f,
168    729.52785023f, 737.73209140f, 745.94956849f, 754.18016116f,
169    762.42375127f, 770.68022275f, 778.94946161f, 787.23135586f,
170    795.52579543f, 803.83267219f, 812.15187982f, 820.48331383f,
171    828.82687147f, 837.18245171f, 845.54995518f, 853.92928416f,
172    862.32034249f, 870.72303558f, 879.13727036f, 887.56295522f,
173    896.00000000f, 904.44831595f, 912.90781569f, 921.37841320f,
174    929.86002376f, 938.35256392f, 946.85595152f, 955.37010560f,
175    963.89494641f, 972.43039537f, 980.97637504f, 989.53280911f,
176    998.09962237f, 1006.67674069f, 1015.26409097f, 1023.86160116f,
177    1032.46920021f, 1041.08681805f, 1049.71438560f, 1058.35183469f,
178    1066.99909811f, 1075.65610955f, 1084.32280357f, 1092.99911564f,
179    1101.68498204f, 1110.38033993f, 1119.08512727f, 1127.79928282f,
180    1136.52274614f, 1145.25545758f, 1153.99735821f, 1162.74838989f,
181    1171.50849518f, 1180.27761738f, 1189.05570047f, 1197.84268914f,
182    1206.63852876f, 1215.44316535f, 1224.25654560f, 1233.07861684f,
183    1241.90932703f, 1250.74862473f, 1259.59645914f, 1268.45278005f,
184    1277.31753781f, 1286.19068338f, 1295.07216828f, 1303.96194457f,
185    1312.85996488f, 1321.76618236f, 1330.68055071f, 1339.60302413f,
186    1348.53355734f, 1357.47210556f, 1366.41862452f, 1375.37307041f,
187    1384.33539991f, 1393.30557020f, 1402.28353887f, 1411.26926400f,
188    1420.26270412f, 1429.26381818f, 1438.27256558f, 1447.28890615f,
189    1456.31280014f, 1465.34420819f, 1474.38309138f, 1483.42941118f,
190    1492.48312945f, 1501.54420843f, 1510.61261078f, 1519.68829949f,
191    1528.77123795f, 1537.86138993f, 1546.95871952f, 1556.06319119f,
192    1565.17476976f, 1574.29342040f, 1583.41910860f, 1592.55180020f,
193    1601.69146137f, 1610.83805860f, 1619.99155871f, 1629.15192882f,
194    1638.31913637f, 1647.49314911f, 1656.67393509f, 1665.86146266f,
195    1675.05570047f, 1684.25661744f, 1693.46418280f, 1702.67836605f,
196    1711.89913698f, 1721.12646563f, 1730.36032233f, 1739.60067768f,
197    1748.84750254f, 1758.10076802f, 1767.36044551f, 1776.62650662f,
198    1785.89892323f, 1795.17766747f, 1804.46271172f, 1813.75402857f,
199    1823.05159087f, 1832.35537170f, 1841.66534438f, 1850.98148244f,
200    1860.30375965f, 1869.63214999f, 1878.96662767f, 1888.30716711f,
201    1897.65374295f, 1907.00633003f, 1916.36490342f, 1925.72943838f,
202    1935.09991037f, 1944.47629506f, 1953.85856831f, 1963.24670620f,
203    1972.64068498f, 1982.04048108f, 1991.44607117f, 2000.85743204f,
204    2010.27454072f, 2019.69737440f, 2029.12591044f, 2038.56012640f
205  };
206  const VP8LPrefixCode kPrefixEncodeCode[PREFIX_LOOKUP_IDX_MAX] = {
207    { 0, 0}, { 0, 0}, { 1, 0}, { 2, 0}, { 3, 0}, { 4, 1}, { 4, 1}, { 5, 1},
208    { 5, 1}, { 6, 2}, { 6, 2}, { 6, 2}, { 6, 2}, { 7, 2}, { 7, 2}, { 7, 2},
209    { 7, 2}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3}, { 8, 3},
210    { 8, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3}, { 9, 3},
211    { 9, 3}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4},
212    {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4}, {10, 4},
213    {10, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4},
214    {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4}, {11, 4},
215    {11, 4}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
216    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
217    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
218    {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5}, {12, 5},
219    {12, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
220    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
221    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
222    {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5}, {13, 5},
223    {13, 5}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
224    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
225    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
226    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
227    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
228    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
229    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
230    {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6}, {14, 6},
231    {14, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
232    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
233    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
234    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
235    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
236    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
237    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
238    {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6}, {15, 6},
239    {15, 6}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
240    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
241    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
242    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
243    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
244    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
245    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
246    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
247    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
248    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
249    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
250    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
251    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
252    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
253    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
254    {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7}, {16, 7},
255    {16, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
256    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
257    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
258    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
259    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
260    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
261    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
262    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
263    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
264    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
265    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
266    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
267    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
268    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
269    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
270    {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7}, {17, 7},
271  };
272  const uint8_t kPrefixEncodeExtraBitsValue[PREFIX_LOOKUP_IDX_MAX] = {
273     0,  0,  0,  0,  0,  0,  1,  0,  1,  0,  1,  2,  3,  0,  1,  2,  3,
274     0,  1,  2,  3,  4,  5,  6,  7,  0,  1,  2,  3,  4,  5,  6,  7,
275     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
276     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
277     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
278    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
279     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
280    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
281     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
282    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
283    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
284    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
285     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
286    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
287    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
288    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
289     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
290    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
291    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
292    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
293    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
294    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
295    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
296    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,
297    127,
298     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
299    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
300    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
301    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
302    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
303    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
304    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
305    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126
306  };
307  static float FastSLog2Slow_C(uint32_t v) {
308    assert(v >= LOG_LOOKUP_IDX_MAX);
309    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
310      int log_cnt = 0;
311      uint32_t y = 1;
312      int correction = 0;
313      const float v_f = (float)v;
314      const uint32_t orig_v = v;
315      do {
316        ++log_cnt;
317        v = v >> 1;
318        y = y << 1;
319      } while (v >= LOG_LOOKUP_IDX_MAX);
320      correction = (23 * (orig_v & (y - 1))) >> 4;
321      return v_f * (kLog2Table[v] + log_cnt) + correction;
322    } else {
323      return (float)(LOG_2_RECIPROCAL * v * log((double)v));
324    }
325  }
326  static float FastLog2Slow_C(uint32_t v) {
327    assert(v >= LOG_LOOKUP_IDX_MAX);
328    if (v < APPROX_LOG_WITH_CORRECTION_MAX) {
329      int log_cnt = 0;
330      uint32_t y = 1;
331      const uint32_t orig_v = v;
332      double log_2;
333      do {
334        ++log_cnt;
335        v = v >> 1;
336        y = y << 1;
337      } while (v >= LOG_LOOKUP_IDX_MAX);
338      log_2 = kLog2Table[v] + log_cnt;
339      if (orig_v >= APPROX_LOG_MAX) {
340        const int correction = (23 * (orig_v & (y - 1))) >> 4;
341        log_2 += (double)correction / orig_v;
342      }
343      return (float)log_2;
344    } else {
345      return (float)(LOG_2_RECIPROCAL * log((double)v));
346    }
347  }
348  static float CombinedShannonEntropy_C(const int X[256], const int Y[256]) {
349    int i;
350    double retval = 0.;
351    int sumX = 0, sumXY = 0;
352    for (i = 0; i < 256; ++i) {
353      const int x = X[i];
354      if (x != 0) {
355        const int xy = x + Y[i];
356        sumX += x;
357        retval -= VP8LFastSLog2(x);
358        sumXY += xy;
359        retval -= VP8LFastSLog2(xy);
360      } else if (Y[i] != 0) {
361        sumXY += Y[i];
362        retval -= VP8LFastSLog2(Y[i]);
363      }
364    }
365    retval += VP8LFastSLog2(sumX) + VP8LFastSLog2(sumXY);
366    return (float)retval;
367  }
368  void VP8LBitEntropyInit(VP8LBitEntropy* const entropy) {
369    entropy->entropy = 0.;
370    entropy->sum = 0;
371    entropy->nonzeros = 0;
372    entropy->max_val = 0;
373    entropy->nonzero_code = VP8L_NON_TRIVIAL_SYM;
374  }
375  void VP8LBitsEntropyUnrefined(const uint32_t* const array, int n,
376                                VP8LBitEntropy* const entropy) {
377    int i;
378    VP8LBitEntropyInit(entropy);
379    for (i = 0; i < n; ++i) {
380      if (array[i] != 0) {
381        entropy->sum += array[i];
382        entropy->nonzero_code = i;
383        ++entropy->nonzeros;
384        entropy->entropy -= VP8LFastSLog2(array[i]);
385        if (entropy->max_val < array[i]) {
386          entropy->max_val = array[i];
387        }
388      }
389    }
390    entropy->entropy += VP8LFastSLog2(entropy->sum);
391  }
392  static WEBP_INLINE void GetEntropyUnrefinedHelper(
393      uint32_t val, int i, uint32_t* const val_prev, int* const i_prev,
394      VP8LBitEntropy* const bit_entropy, VP8LStreaks* const stats) {
395    const int streak = i - *i_prev;
396    if (*val_prev != 0) {
397      bit_entropy->sum += (*val_prev) * streak;
398      bit_entropy->nonzeros += streak;
399      bit_entropy->nonzero_code = *i_prev;
400      bit_entropy->entropy -= VP8LFastSLog2(*val_prev) * streak;
401      if (bit_entropy->max_val < *val_prev) {
402        bit_entropy->max_val = *val_prev;
403      }
404    }
405    stats->counts[*val_prev != 0] += (streak > 3);
406    stats->streaks[*val_prev != 0][(streak > 3)] += streak;
407    *val_prev = val;
408    *i_prev = i;
409  }
410  static void GetEntropyUnrefined_C(const uint32_t X[], int length,
411                                    VP8LBitEntropy* const bit_entropy,
412                                    VP8LStreaks* const stats) {
413    int i;
414    int i_prev = 0;
415    uint32_t x_prev = X[0];
416    memset(stats, 0, sizeof(*stats));
417    VP8LBitEntropyInit(bit_entropy);
418    for (i = 1; i < length; ++i) {
419      const uint32_t x = X[i];
420      if (x != x_prev) {
421        GetEntropyUnrefinedHelper(x, i, &x_prev, &i_prev, bit_entropy, stats);
422      }
423    }
424    GetEntropyUnrefinedHelper(0, i, &x_prev, &i_prev, bit_entropy, stats);
425    bit_entropy->entropy += VP8LFastSLog2(bit_entropy->sum);
426  }
427  static void GetCombinedEntropyUnrefined_C(const uint32_t X[],
428                                            const uint32_t Y[],
429                                            int length,
430                                            VP8LBitEntropy* const bit_entropy,
431                                            VP8LStreaks* const stats) {
432    int i = 1;
433    int i_prev = 0;
434    uint32_t xy_prev = X[0] + Y[0];
435    memset(stats, 0, sizeof(*stats));
436    VP8LBitEntropyInit(bit_entropy);
437    for (i = 1; i < length; ++i) {
438      const uint32_t xy = X[i] + Y[i];
439      if (xy != xy_prev) {
440        GetEntropyUnrefinedHelper(xy, i, &xy_prev, &i_prev, bit_entropy, stats);
441      }
442    }
443    GetEntropyUnrefinedHelper(0, i, &xy_prev, &i_prev, bit_entropy, stats);
444    bit_entropy->entropy += VP8LFastSLog2(bit_entropy->sum);
445  }
446  void VP8LSubtractGreenFromBlueAndRed_C(uint32_t* argb_data, int num_pixels) {
447    int i;
448    for (i = 0; i < num_pixels; ++i) {
449      const int argb = argb_data[i];
450      const int green = (argb >> 8) & 0xff;
451      const uint32_t new_r = (((argb >> 16) & 0xff) - green) & 0xff;
452      const uint32_t new_b = (((argb >>  0) & 0xff) - green) & 0xff;
453      argb_data[i] = (argb & 0xff00ff00u) | (new_r << 16) | new_b;
454    }
455  }
456  static WEBP_INLINE int ColorTransformDelta(int8_t color_pred, int8_t color) {
457    return ((int)color_pred * color) >> 5;
458  }
459  static WEBP_INLINE int8_t U32ToS8(uint32_t v) {
460    return (int8_t)(v & 0xff);
461  }
462  void VP8LTransformColor_C(const VP8LMultipliers* const m, uint32_t* data,
463                            int num_pixels) {
464    int i;
465    for (i = 0; i < num_pixels; ++i) {
466      const uint32_t argb = data[i];
467      const int8_t green = U32ToS8(argb >>  8);
468      const int8_t red   = U32ToS8(argb >> 16);
469      int new_red = red & 0xff;
470      int new_blue = argb & 0xff;
471      new_red -= ColorTransformDelta(m->green_to_red_, green);
472      new_red &= 0xff;
473      new_blue -= ColorTransformDelta(m->green_to_blue_, green);
474      new_blue -= ColorTransformDelta(m->red_to_blue_, red);
475      new_blue &= 0xff;
476      data[i] = (argb & 0xff00ff00u) | (new_red << 16) | (new_blue);
477    }
478  }
479  static WEBP_INLINE uint8_t TransformColorRed(uint8_t green_to_red,
480                                               uint32_t argb) {
481    const int8_t green = U32ToS8(argb >> 8);
482    int new_red = argb >> 16;
483    new_red -= ColorTransformDelta(green_to_red, green);
484    return (new_red & 0xff);
485  }
486  static WEBP_INLINE uint8_t TransformColorBlue(uint8_t green_to_blue,
487                                                uint8_t red_to_blue,
488                                                uint32_t argb) {
489    const int8_t green = U32ToS8(argb >>  8);
490    const int8_t red   = U32ToS8(argb >> 16);
491    uint8_t new_blue = argb & 0xff;
492    new_blue -= ColorTransformDelta(green_to_blue, green);
493    new_blue -= ColorTransformDelta(red_to_blue, red);
494    return (new_blue & 0xff);
495  }
496  void VP8LCollectColorRedTransforms_C(const uint32_t* argb, int stride,
497                                       int tile_width, int tile_height,
498                                       int green_to_red, int histo[]) {
499    while (tile_height-- > 0) {
500      int x;
501      for (x = 0; x < tile_width; ++x) {
502        ++histo[TransformColorRed((uint8_t)green_to_red, argb[x])];
503      }
504      argb += stride;
505    }
506  }
507  void VP8LCollectColorBlueTransforms_C(const uint32_t* argb, int stride,
508                                        int tile_width, int tile_height,
509                                        int green_to_blue, int red_to_blue,
510                                        int histo[]) {
511    while (tile_height-- > 0) {
512      int x;
513      for (x = 0; x < tile_width; ++x) {
514        ++histo[TransformColorBlue((uint8_t)green_to_blue, (uint8_t)red_to_blue,
515                                   argb[x])];
516      }
517      argb += stride;
518    }
519  }
520  static int VectorMismatch_C(const uint32_t* const array1,
521                              const uint32_t* const array2, int length) {
522    int match_len = 0;
523    while (match_len < length && array1[match_len] == array2[match_len]) {
524      ++match_len;
525    }
526    return match_len;
527  }
528  void VP8LBundleColorMap_C(const uint8_t* const row, int width, int xbits,
529                            uint32_t* dst) {
530    int x;
531    if (xbits > 0) {
532      const int bit_depth = 1 << (3 - xbits);
533      const int mask = (1 << xbits) - 1;
534      uint32_t code = 0xff000000;
535      for (x = 0; x < width; ++x) {
536        const int xsub = x & mask;
537        if (xsub == 0) {
538          code = 0xff000000;
539        }
540        code |= row[x] << (8 + bit_depth * xsub);
541        dst[x >> xbits] = code;
542      }
543    } else {
544      for (x = 0; x < width; ++x) dst[x] = 0xff000000 | (row[x] << 8);
545    }
546  }
547  static double ExtraCost_C(const uint32_t* population, int length) {
548    int i;
549    double cost = 0.;
550    for (i = 2; i < length - 2; ++i) cost += (i >> 1) * population[i + 2];
551    return cost;
552  }
553  static double ExtraCostCombined_C(const uint32_t* X, const uint32_t* Y,
554                                    int length) {
555    int i;
556    double cost = 0.;
557    for (i = 2; i < length - 2; ++i) {
558      const int xy = X[i + 2] + Y[i + 2];
559      cost += (i >> 1) * xy;
560    }
561    return cost;
562  }
563  static void AddVector_C(const uint32_t* a, const uint32_t* b, uint32_t* out,
564                          int size) {
565    int i;
566    for (i = 0; i < size; ++i) out[i] = a[i] + b[i];
567  }
568  static void AddVectorEq_C(const uint32_t* a, uint32_t* out, int size) {
569    int i;
570    for (i = 0; i < size; ++i) out[i] += a[i];
571  }
572  #define ADD(X, ARG, LEN) do {                                                  \
573    if (a->is_used_[X]) {                                                        \
574      if (b->is_used_[X]) {                                                      \
575        VP8LAddVector(a->ARG, b->ARG, out->ARG, (LEN));                          \
576      } else {                                                                   \
577        memcpy(&out->ARG[0], &a->ARG[0], (LEN) * sizeof(out->ARG[0]));           \
578      }                                                                          \
579    } else if (b->is_used_[X]) {                                                 \
580      memcpy(&out->ARG[0], &b->ARG[0], (LEN) * sizeof(out->ARG[0]));             \
581    } else {                                                                     \
582      memset(&out->ARG[0], 0, (LEN) * sizeof(out->ARG[0]));                      \
583    }                                                                            \
584  } while (0)
585  #define ADD_EQ(X, ARG, LEN) do {                                               \
586    if (a->is_used_[X]) {                                                        \
587      if (out->is_used_[X]) {                                                    \
588        VP8LAddVectorEq(a->ARG, out->ARG, (LEN));                                \
589      } else {                                                                   \
590        memcpy(&out->ARG[0], &a->ARG[0], (LEN) * sizeof(out->ARG[0]));           \
591      }                                                                          \
592    }                                                                            \
593  } while (0)
594  void VP8LHistogramAdd(const VP8LHistogram* const a,
595                        const VP8LHistogram* const b, VP8LHistogram* const out) {
596    int i;
597    const int literal_size = VP8LHistogramNumCodes(a->palette_code_bits_);
598    assert(a->palette_code_bits_ == b->palette_code_bits_);
599    if (b != out) {
600      ADD(0, literal_, literal_size);
601      ADD(1, red_, NUM_LITERAL_CODES);
602      ADD(2, blue_, NUM_LITERAL_CODES);
603      ADD(3, alpha_, NUM_LITERAL_CODES);
604      ADD(4, distance_, NUM_DISTANCE_CODES);
605      for (i = 0; i < 5; ++i) {
606        out->is_used_[i] = (a->is_used_[i] | b->is_used_[i]);
607      }
608    } else {
609      ADD_EQ(0, literal_, literal_size);
610      ADD_EQ(1, red_, NUM_LITERAL_CODES);
611      ADD_EQ(2, blue_, NUM_LITERAL_CODES);
612      ADD_EQ(3, alpha_, NUM_LITERAL_CODES);
613      ADD_EQ(4, distance_, NUM_DISTANCE_CODES);
614      for (i = 0; i < 5; ++i) out->is_used_[i] |= a->is_used_[i];
615    }
616  }
617  #undef ADD
618  #undef ADD_EQ
619  static WEBP_INLINE uint32_t Average2(uint32_t a0, uint32_t a1) {
620    return (((a0 ^ a1) & 0xfefefefeu) >> 1) + (a0 & a1);
621  }
622  static WEBP_INLINE uint32_t Average3(uint32_t a0, uint32_t a1, uint32_t a2) {
623    return Average2(Average2(a0, a2), a1);
624  }
625  static WEBP_INLINE uint32_t Average4(uint32_t a0, uint32_t a1,
626                                       uint32_t a2, uint32_t a3) {
627    return Average2(Average2(a0, a1), Average2(a2, a3));
628  }
629  static WEBP_INLINE uint32_t Clip255(uint32_t a) {
630    if (a < 256) {
631      return a;
632    }
633    return ~a >> 24;
634  }
635  static WEBP_INLINE int AddSubtractComponentFull(int a, int b, int c) {
636    return Clip255(a + b - c);
637  }
638  static WEBP_INLINE uint32_t ClampedAddSubtractFull(uint32_t c0, uint32_t c1,
639                                                     uint32_t c2) {
640    const int a = AddSubtractComponentFull(c0 >> 24, c1 >> 24, c2 >> 24);
641    const int r = AddSubtractComponentFull((c0 >> 16) & 0xff,
642                                           (c1 >> 16) & 0xff,
643                                           (c2 >> 16) & 0xff);
644    const int g = AddSubtractComponentFull((c0 >> 8) & 0xff,
645                                           (c1 >> 8) & 0xff,
646                                           (c2 >> 8) & 0xff);
647    const int b = AddSubtractComponentFull(c0 & 0xff, c1 & 0xff, c2 & 0xff);
648    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
649  }
650  static WEBP_INLINE int AddSubtractComponentHalf(int a, int b) {
651    return Clip255(a + (a - b) / 2);
652  }
653  static WEBP_INLINE uint32_t ClampedAddSubtractHalf(uint32_t c0, uint32_t c1,
654                                                     uint32_t c2) {
655    const uint32_t ave = Average2(c0, c1);
656    const int a = AddSubtractComponentHalf(ave >> 24, c2 >> 24);
657    const int r = AddSubtractComponentHalf((ave >> 16) & 0xff, (c2 >> 16) & 0xff);
658    const int g = AddSubtractComponentHalf((ave >> 8) & 0xff, (c2 >> 8) & 0xff);
659    const int b = AddSubtractComponentHalf((ave >> 0) & 0xff, (c2 >> 0) & 0xff);
660    return ((uint32_t)a << 24) | (r << 16) | (g << 8) | b;
661  }
662  #if defined(__arm__) && \
663      (LOCAL_GCC_VERSION == 0x409 || LOCAL_GCC_VERSION == 0x408)
664  # define LOCAL_INLINE __attribute__ ((noinline))
665  #else
666  # define LOCAL_INLINE WEBP_INLINE
667  #endif
668  static LOCAL_INLINE int Sub3(int a, int b, int c) {
669    const int pb = b - c;
670    const int pa = a - c;
671    return abs(pb) - abs(pa);
672  }
673  #undef LOCAL_INLINE
674  static WEBP_INLINE uint32_t Select(uint32_t a, uint32_t b, uint32_t c) {
675    const int pa_minus_pb =
676        Sub3((a >> 24)       , (b >> 24)       , (c >> 24)       ) +
677        Sub3((a >> 16) & 0xff, (b >> 16) & 0xff, (c >> 16) & 0xff) +
678        Sub3((a >>  8) & 0xff, (b >>  8) & 0xff, (c >>  8) & 0xff) +
679        Sub3((a      ) & 0xff, (b      ) & 0xff, (c      ) & 0xff);
680    return (pa_minus_pb <= 0) ? a : b;
681  }
682  static uint32_t Predictor2(uint32_t left, const uint32_t* const top) {
683    (void)left;
684    return top[0];
685  }
686  static uint32_t Predictor3(uint32_t left, const uint32_t* const top) {
687    (void)left;
688    return top[1];
689  }
690  static uint32_t Predictor4(uint32_t left, const uint32_t* const top) {
691    (void)left;
692    return top[-1];
693  }
694  static uint32_t Predictor5(uint32_t left, const uint32_t* const top) {
695    const uint32_t pred = Average3(left, top[0], top[1]);
696    return pred;
697  }
698  static uint32_t Predictor6(uint32_t left, const uint32_t* const top) {
699    const uint32_t pred = Average2(left, top[-1]);
700    return pred;
701  }
702  static uint32_t Predictor7(uint32_t left, const uint32_t* const top) {
703    const uint32_t pred = Average2(left, top[0]);
704    return pred;
705  }
706  static uint32_t Predictor8(uint32_t left, const uint32_t* const top) {
707    const uint32_t pred = Average2(top[-1], top[0]);
708    (void)left;
709    return pred;
710  }
711  static uint32_t Predictor9(uint32_t left, const uint32_t* const top) {
712    const uint32_t pred = Average2(top[0], top[1]);
713    (void)left;
714    return pred;
715  }
716  static uint32_t Predictor10(uint32_t left, const uint32_t* const top) {
717    const uint32_t pred = Average4(left, top[-1], top[0], top[1]);
718    return pred;
719  }
720  static uint32_t Predictor11(uint32_t left, const uint32_t* const top) {
721    const uint32_t pred = Select(top[0], left, top[-1]);
722    return pred;
723  }
724  static uint32_t Predictor12(uint32_t left, const uint32_t* const top) {
725    const uint32_t pred = ClampedAddSubtractFull(left, top[0], top[-1]);
726    return pred;
727  }
728  static uint32_t Predictor13(uint32_t left, const uint32_t* const top) {
729    const uint32_t pred = ClampedAddSubtractHalf(left, top[0], top[-1]);
730    return pred;
731  }
732  static void PredictorSub0_C(const uint32_t* in, const uint32_t* upper,
733                              int num_pixels, uint32_t* out) {
734    int i;
735    for (i = 0; i < num_pixels; ++i) out[i] = VP8LSubPixels(in[i], ARGB_BLACK);
736    (void)upper;
737  }
738  static void PredictorSub1_C(const uint32_t* in, const uint32_t* upper,
739                              int num_pixels, uint32_t* out) {
740    int i;
741    for (i = 0; i < num_pixels; ++i) out[i] = VP8LSubPixels(in[i], in[i - 1]);
742    (void)upper;
743  }
744  GENERATE_PREDICTOR_SUB(Predictor2, PredictorSub2_C)
745  GENERATE_PREDICTOR_SUB(Predictor3, PredictorSub3_C)
746  GENERATE_PREDICTOR_SUB(Predictor4, PredictorSub4_C)
747  GENERATE_PREDICTOR_SUB(Predictor5, PredictorSub5_C)
748  GENERATE_PREDICTOR_SUB(Predictor6, PredictorSub6_C)
749  GENERATE_PREDICTOR_SUB(Predictor7, PredictorSub7_C)
750  GENERATE_PREDICTOR_SUB(Predictor8, PredictorSub8_C)
751  GENERATE_PREDICTOR_SUB(Predictor9, PredictorSub9_C)
752  GENERATE_PREDICTOR_SUB(Predictor10, PredictorSub10_C)
753  GENERATE_PREDICTOR_SUB(Predictor11, PredictorSub11_C)
754  GENERATE_PREDICTOR_SUB(Predictor12, PredictorSub12_C)
755  GENERATE_PREDICTOR_SUB(Predictor13, PredictorSub13_C)
756  VP8LProcessEncBlueAndRedFunc VP8LSubtractGreenFromBlueAndRed;
757  VP8LTransformColorFunc VP8LTransformColor;
758  VP8LCollectColorBlueTransformsFunc VP8LCollectColorBlueTransforms;
759  VP8LCollectColorRedTransformsFunc VP8LCollectColorRedTransforms;
760  VP8LFastLog2SlowFunc VP8LFastLog2Slow;
761  VP8LFastLog2SlowFunc VP8LFastSLog2Slow;
762  VP8LCostFunc VP8LExtraCost;
763  VP8LCostCombinedFunc VP8LExtraCostCombined;
764  VP8LCombinedShannonEntropyFunc VP8LCombinedShannonEntropy;
765  VP8LGetEntropyUnrefinedFunc VP8LGetEntropyUnrefined;
766  VP8LGetCombinedEntropyUnrefinedFunc VP8LGetCombinedEntropyUnrefined;
767  VP8LAddVectorFunc VP8LAddVector;
768  VP8LAddVectorEqFunc VP8LAddVectorEq;
769  VP8LVectorMismatchFunc VP8LVectorMismatch;
770  VP8LBundleColorMapFunc VP8LBundleColorMap;
771  VP8LPredictorAddSubFunc VP8LPredictorsSub[16];
772  VP8LPredictorAddSubFunc VP8LPredictorsSub_C[16];
773  extern void VP8LEncDspInitSSE2(void);
774  extern void VP8LEncDspInitSSE41(void);
775  extern void VP8LEncDspInitNEON(void);
776  extern void VP8LEncDspInitMIPS32(void);
777  extern void VP8LEncDspInitMIPSdspR2(void);
778  extern void VP8LEncDspInitMSA(void);
779  WEBP_DSP_INIT_FUNC(VP8LEncDspInit) {
780    VP8LDspInit();
781  #if !WEBP_NEON_OMIT_C_CODE
782    VP8LSubtractGreenFromBlueAndRed = VP8LSubtractGreenFromBlueAndRed_C;
783    VP8LTransformColor = VP8LTransformColor_C;
784  #endif
785    VP8LCollectColorBlueTransforms = VP8LCollectColorBlueTransforms_C;
786    VP8LCollectColorRedTransforms = VP8LCollectColorRedTransforms_C;
787    VP8LFastLog2Slow = FastLog2Slow_C;
788    VP8LFastSLog2Slow = FastSLog2Slow_C;
789    VP8LExtraCost = ExtraCost_C;
790    VP8LExtraCostCombined = ExtraCostCombined_C;
791    VP8LCombinedShannonEntropy = CombinedShannonEntropy_C;
792    VP8LGetEntropyUnrefined = GetEntropyUnrefined_C;
793    VP8LGetCombinedEntropyUnrefined = GetCombinedEntropyUnrefined_C;
794    VP8LAddVector = AddVector_C;
795    VP8LAddVectorEq = AddVectorEq_C;
796    VP8LVectorMismatch = VectorMismatch_C;
797    VP8LBundleColorMap = VP8LBundleColorMap_C;
798    VP8LPredictorsSub[0] = PredictorSub0_C;
799    VP8LPredictorsSub[1] = PredictorSub1_C;
800    VP8LPredictorsSub[2] = PredictorSub2_C;
801    VP8LPredictorsSub[3] = PredictorSub3_C;
802    VP8LPredictorsSub[4] = PredictorSub4_C;
803    VP8LPredictorsSub[5] = PredictorSub5_C;
804    VP8LPredictorsSub[6] = PredictorSub6_C;
805    VP8LPredictorsSub[7] = PredictorSub7_C;
806    VP8LPredictorsSub[8] = PredictorSub8_C;
807    VP8LPredictorsSub[9] = PredictorSub9_C;
808    VP8LPredictorsSub[10] = PredictorSub10_C;
809    VP8LPredictorsSub[11] = PredictorSub11_C;
810    VP8LPredictorsSub[12] = PredictorSub12_C;
811    VP8LPredictorsSub[13] = PredictorSub13_C;
812    VP8LPredictorsSub[14] = PredictorSub0_C;  
813    VP8LPredictorsSub[15] = PredictorSub0_C;
814    VP8LPredictorsSub_C[0] = PredictorSub0_C;
815    VP8LPredictorsSub_C[1] = PredictorSub1_C;
816    VP8LPredictorsSub_C[2] = PredictorSub2_C;
817    VP8LPredictorsSub_C[3] = PredictorSub3_C;
818    VP8LPredictorsSub_C[4] = PredictorSub4_C;
819    VP8LPredictorsSub_C[5] = PredictorSub5_C;
820    VP8LPredictorsSub_C[6] = PredictorSub6_C;
821    VP8LPredictorsSub_C[7] = PredictorSub7_C;
822    VP8LPredictorsSub_C[8] = PredictorSub8_C;
<span onclick='openModal()' class='match'>823    VP8LPredictorsSub_C[9] = PredictorSub9_C;
824    VP8LPredictorsSub_C[10] = PredictorSub10_C;
825    VP8LPredictorsSub_C[11] = PredictorSub11_C;
826    VP8LPredictorsSub_C[12] = PredictorSub12_C;
827    VP8LPredictorsSub_C[13] = PredictorSub13_C;
828    VP8LPredictorsSub_C[14] = PredictorSub0_C;  
829    VP8LPredictorsSub_C[15] = PredictorSub0_C;
830    if (VP8GetCPUInfo != NULL) {
</span>831  #if defined(WEBP_USE_SSE2)
832      if (VP8GetCPUInfo(kSSE2)) {
833        VP8LEncDspInitSSE2();
834  #if defined(WEBP_USE_SSE41)
835        if (VP8GetCPUInfo(kSSE4_1)) {
836          VP8LEncDspInitSSE41();
837        }
838  #endif
839      }
840  #endif
841  #if defined(WEBP_USE_MIPS32)
842      if (VP8GetCPUInfo(kMIPS32)) {
843        VP8LEncDspInitMIPS32();
844      }
845  #endif
846  #if defined(WEBP_USE_MIPS_DSP_R2)
847      if (VP8GetCPUInfo(kMIPSdspR2)) {
848        VP8LEncDspInitMIPSdspR2();
849      }
850  #endif
851  #if defined(WEBP_USE_MSA)
852      if (VP8GetCPUInfo(kMSA)) {
853        VP8LEncDspInitMSA();
854      }
855  #endif
856    }
857  #if defined(WEBP_USE_NEON)
858    if (WEBP_NEON_OMIT_C_CODE ||
859        (VP8GetCPUInfo != NULL && VP8GetCPUInfo(kNEON))) {
860      VP8LEncDspInitNEON();
861    }
862  #endif
863    assert(VP8LSubtractGreenFromBlueAndRed != NULL);
864    assert(VP8LTransformColor != NULL);
865    assert(VP8LCollectColorBlueTransforms != NULL);
866    assert(VP8LCollectColorRedTransforms != NULL);
867    assert(VP8LFastLog2Slow != NULL);
868    assert(VP8LFastSLog2Slow != NULL);
869    assert(VP8LExtraCost != NULL);
870    assert(VP8LExtraCostCombined != NULL);
871    assert(VP8LCombinedShannonEntropy != NULL);
872    assert(VP8LGetEntropyUnrefined != NULL);
873    assert(VP8LGetCombinedEntropyUnrefined != NULL);
874    assert(VP8LAddVector != NULL);
875    assert(VP8LAddVectorEq != NULL);
876    assert(VP8LVectorMismatch != NULL);
877    assert(VP8LBundleColorMap != NULL);
878    assert(VP8LPredictorsSub[0] != NULL);
879    assert(VP8LPredictorsSub[1] != NULL);
880    assert(VP8LPredictorsSub[2] != NULL);
881    assert(VP8LPredictorsSub[3] != NULL);
882    assert(VP8LPredictorsSub[4] != NULL);
883    assert(VP8LPredictorsSub[5] != NULL);
884    assert(VP8LPredictorsSub[6] != NULL);
885    assert(VP8LPredictorsSub[7] != NULL);
886    assert(VP8LPredictorsSub[8] != NULL);
887    assert(VP8LPredictorsSub[9] != NULL);
888    assert(VP8LPredictorsSub[10] != NULL);
889    assert(VP8LPredictorsSub[11] != NULL);
890    assert(VP8LPredictorsSub[12] != NULL);
891    assert(VP8LPredictorsSub[13] != NULL);
892    assert(VP8LPredictorsSub[14] != NULL);
893    assert(VP8LPredictorsSub[15] != NULL);
894    assert(VP8LPredictorsSub_C[0] != NULL);
895    assert(VP8LPredictorsSub_C[1] != NULL);
896    assert(VP8LPredictorsSub_C[2] != NULL);
897    assert(VP8LPredictorsSub_C[3] != NULL);
898    assert(VP8LPredictorsSub_C[4] != NULL);
899    assert(VP8LPredictorsSub_C[5] != NULL);
900    assert(VP8LPredictorsSub_C[6] != NULL);
901    assert(VP8LPredictorsSub_C[7] != NULL);
902    assert(VP8LPredictorsSub_C[8] != NULL);
903    assert(VP8LPredictorsSub_C[9] != NULL);
904    assert(VP8LPredictorsSub_C[10] != NULL);
905    assert(VP8LPredictorsSub_C[11] != NULL);
906    assert(VP8LPredictorsSub_C[12] != NULL);
907    assert(VP8LPredictorsSub_C[13] != NULL);
908    assert(VP8LPredictorsSub_C[14] != NULL);
909    assert(VP8LPredictorsSub_C[15] != NULL);
910  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_dec.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include "src/dec/alphai_dec.h"
3  #include "src/dec/vp8li_dec.h"
4  #include "src/dsp/dsp.h"
5  #include "src/dsp/lossless.h"
6  #include "src/dsp/lossless_common.h"
7  #include "src/dsp/yuv.h"
8  #include "src/utils/endian_inl_utils.h"
9  #include "src/utils/huffman_utils.h"
10  #include "src/utils/utils.h"
11  #define NUM_ARGB_CACHE_ROWS          16
12  static const int kCodeLengthLiterals = 16;
13  static const int kCodeLengthRepeatCode = 16;
14  static const uint8_t kCodeLengthExtraBits[3] = { 2, 3, 7 };
15  static const uint8_t kCodeLengthRepeatOffsets[3] = { 3, 3, 11 };
16  typedef enum {
17    GREEN = 0,
18    RED   = 1,
19    BLUE  = 2,
20    ALPHA = 3,
21    DIST  = 4
22  } HuffIndex;
23  static const uint16_t kAlphabetSize[HUFFMAN_CODES_PER_META_CODE] = {
24    NUM_LITERAL_CODES + NUM_LENGTH_CODES,
25    NUM_LITERAL_CODES, NUM_LITERAL_CODES, NUM_LITERAL_CODES,
26    NUM_DISTANCE_CODES
27  };
28  static const uint8_t kLiteralMap[HUFFMAN_CODES_PER_META_CODE] = {
29    0, 1, 1, 1, 0
30  };
31  #define NUM_CODE_LENGTH_CODES       19
32  static const uint8_t kCodeLengthCodeOrder[NUM_CODE_LENGTH_CODES] = {
33    17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
34  };
35  #define CODE_TO_PLANE_CODES        120
36  static const uint8_t kCodeToPlane[CODE_TO_PLANE_CODES] = {
37    0x18, 0x07, 0x17, 0x19, 0x28, 0x06, 0x27, 0x29, 0x16, 0x1a,
38    0x26, 0x2a, 0x38, 0x05, 0x37, 0x39, 0x15, 0x1b, 0x36, 0x3a,
39    0x25, 0x2b, 0x48, 0x04, 0x47, 0x49, 0x14, 0x1c, 0x35, 0x3b,
40    0x46, 0x4a, 0x24, 0x2c, 0x58, 0x45, 0x4b, 0x34, 0x3c, 0x03,
41    0x57, 0x59, 0x13, 0x1d, 0x56, 0x5a, 0x23, 0x2d, 0x44, 0x4c,
42    0x55, 0x5b, 0x33, 0x3d, 0x68, 0x02, 0x67, 0x69, 0x12, 0x1e,
43    0x66, 0x6a, 0x22, 0x2e, 0x54, 0x5c, 0x43, 0x4d, 0x65, 0x6b,
44    0x32, 0x3e, 0x78, 0x01, 0x77, 0x79, 0x53, 0x5d, 0x11, 0x1f,
45    0x64, 0x6c, 0x42, 0x4e, 0x76, 0x7a, 0x21, 0x2f, 0x75, 0x7b,
46    0x31, 0x3f, 0x63, 0x6d, 0x52, 0x5e, 0x00, 0x74, 0x7c, 0x41,
47    0x4f, 0x10, 0x20, 0x62, 0x6e, 0x30, 0x73, 0x7d, 0x51, 0x5f,
48    0x40, 0x72, 0x7e, 0x61, 0x6f, 0x50, 0x71, 0x7f, 0x60, 0x70
49  };
50  #define FIXED_TABLE_SIZE (630 * 3 + 410)
51  static const uint16_t kTableSize[12] = {
52    FIXED_TABLE_SIZE + 654,
53    FIXED_TABLE_SIZE + 656,
54    FIXED_TABLE_SIZE + 658,
55    FIXED_TABLE_SIZE + 662,
56    FIXED_TABLE_SIZE + 670,
57    FIXED_TABLE_SIZE + 686,
58    FIXED_TABLE_SIZE + 718,
59    FIXED_TABLE_SIZE + 782,
60    FIXED_TABLE_SIZE + 912,
61    FIXED_TABLE_SIZE + 1168,
62    FIXED_TABLE_SIZE + 1680,
63    FIXED_TABLE_SIZE + 2704
64  };
65  static int DecodeImageStream(int xsize, int ysize,
66                               int is_level0,
67                               VP8LDecoder* const dec,
68                               uint32_t** const decoded_data);
69  int VP8LCheckSignature(const uint8_t* const data, size_t size) {
70    return (size >= VP8L_FRAME_HEADER_SIZE &&
71            data[0] == VP8L_MAGIC_BYTE &&
72            (data[4] >> 5) == 0);  
73  }
74  static int ReadImageInfo(VP8LBitReader* const br,
75                           int* const width, int* const height,
76                           int* const has_alpha) {
77    if (VP8LReadBits(br, 8) != VP8L_MAGIC_BYTE) return 0;
78    *width = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;
79    *height = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;
80    *has_alpha = VP8LReadBits(br, 1);
81    if (VP8LReadBits(br, VP8L_VERSION_BITS) != 0) return 0;
82    return !br->eos_;
83  }
84  int VP8LGetInfo(const uint8_t* data, size_t data_size,
85                  int* const width, int* const height, int* const has_alpha) {
86    if (data == NULL || data_size < VP8L_FRAME_HEADER_SIZE) {
87      return 0;         
88    } else if (!VP8LCheckSignature(data, data_size)) {
89      return 0;         
90    } else {
91      int w, h, a;
92      VP8LBitReader br;
93      VP8LInitBitReader(&br, data, data_size);
94      if (!ReadImageInfo(&br, &w, &h, &a)) {
95        return 0;
96      }
97      if (width != NULL) *width = w;
98      if (height != NULL) *height = h;
99      if (has_alpha != NULL) *has_alpha = a;
100      return 1;
101    }
102  }
103  static WEBP_INLINE int GetCopyDistance(int distance_symbol,
104                                         VP8LBitReader* const br) {
105    int extra_bits, offset;
106    if (distance_symbol < 4) {
107      return distance_symbol + 1;
108    }
109    extra_bits = (distance_symbol - 2) >> 1;
110    offset = (2 + (distance_symbol & 1)) << extra_bits;
111    return offset + VP8LReadBits(br, extra_bits) + 1;
112  }
113  static WEBP_INLINE int GetCopyLength(int length_symbol,
114                                       VP8LBitReader* const br) {
115    return GetCopyDistance(length_symbol, br);
116  }
117  static WEBP_INLINE int PlaneCodeToDistance(int xsize, int plane_code) {
118    if (plane_code > CODE_TO_PLANE_CODES) {
119      return plane_code - CODE_TO_PLANE_CODES;
120    } else {
121      const int dist_code = kCodeToPlane[plane_code - 1];
122      const int yoffset = dist_code >> 4;
123      const int xoffset = 8 - (dist_code & 0xf);
124      const int dist = yoffset * xsize + xoffset;
125      return (dist >= 1) ? dist : 1;  
126    }
127  }
128  static WEBP_INLINE int ReadSymbol(const HuffmanCode* table,
129                                    VP8LBitReader* const br) {
130    int nbits;
131    uint32_t val = VP8LPrefetchBits(br);
132    table += val & HUFFMAN_TABLE_MASK;
133    nbits = table->bits - HUFFMAN_TABLE_BITS;
134    if (nbits > 0) {
135      VP8LSetBitPos(br, br->bit_pos_ + HUFFMAN_TABLE_BITS);
136      val = VP8LPrefetchBits(br);
137      table += table->value;
138      table += val & ((1 << nbits) - 1);
139    }
140    VP8LSetBitPos(br, br->bit_pos_ + table->bits);
141    return table->value;
142  }
143  #define BITS_SPECIAL_MARKER 0x100  
144  #define PACKED_NON_LITERAL_CODE 0  
145  static WEBP_INLINE int ReadPackedSymbols(const HTreeGroup* group,
146                                           VP8LBitReader* const br,
147                                           uint32_t* const dst) {
148    const uint32_t val = VP8LPrefetchBits(br) & (HUFFMAN_PACKED_TABLE_SIZE - 1);
149    const HuffmanCode32 code = group->packed_table[val];
150    assert(group->use_packed_table);
151    if (code.bits < BITS_SPECIAL_MARKER) {
152      VP8LSetBitPos(br, br->bit_pos_ + code.bits);
153      *dst = code.value;
154      return PACKED_NON_LITERAL_CODE;
155    } else {
156      VP8LSetBitPos(br, br->bit_pos_ + code.bits - BITS_SPECIAL_MARKER);
157      assert(code.value >= NUM_LITERAL_CODES);
158      return code.value;
159    }
160  }
161  static int AccumulateHCode(HuffmanCode hcode, int shift,
162                             HuffmanCode32* const huff) {
163    huff->bits += hcode.bits;
164    huff->value |= (uint32_t)hcode.value << shift;
165    assert(huff->bits <= HUFFMAN_TABLE_BITS);
166    return hcode.bits;
167  }
168  static void BuildPackedTable(HTreeGroup* const htree_group) {
169    uint32_t code;
170    for (code = 0; code < HUFFMAN_PACKED_TABLE_SIZE; ++code) {
171      uint32_t bits = code;
172      HuffmanCode32* const huff = &htree_group->packed_table[bits];
173      HuffmanCode hcode = htree_group->htrees[GREEN][bits];
174      if (hcode.value >= NUM_LITERAL_CODES) {
175        huff->bits = hcode.bits + BITS_SPECIAL_MARKER;
176        huff->value = hcode.value;
177      } else {
178        huff->bits = 0;
179        huff->value = 0;
180        bits >>= AccumulateHCode(hcode, 8, huff);
181        bits >>= AccumulateHCode(htree_group->htrees[RED][bits], 16, huff);
182        bits >>= AccumulateHCode(htree_group->htrees[BLUE][bits], 0, huff);
183        bits >>= AccumulateHCode(htree_group->htrees[ALPHA][bits], 24, huff);
184        (void)bits;
185      }
186    }
187  }
188  static int ReadHuffmanCodeLengths(
189      VP8LDecoder* const dec, const int* const code_length_code_lengths,
190      int num_symbols, int* const code_lengths) {
191    int ok = 0;
192    VP8LBitReader* const br = &dec->br_;
193    int symbol;
194    int max_symbol;
195    int prev_code_len = DEFAULT_CODE_LENGTH;
196    HuffmanCode table[1 << LENGTHS_TABLE_BITS];
197    if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,
198                               code_length_code_lengths,
199                               NUM_CODE_LENGTH_CODES)) {
200      goto End;
201    }
202    if (VP8LReadBits(br, 1)) {    
203      const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);
204      max_symbol = 2 + VP8LReadBits(br, length_nbits);
205      if (max_symbol > num_symbols) {
206        goto End;
207      }
208    } else {
209      max_symbol = num_symbols;
210    }
211    symbol = 0;
212    while (symbol < num_symbols) {
213      const HuffmanCode* p;
214      int code_len;
215      if (max_symbol-- == 0) break;
216      VP8LFillBitWindow(br);
217      p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];
218      VP8LSetBitPos(br, br->bit_pos_ + p->bits);
219      code_len = p->value;
220      if (code_len < kCodeLengthLiterals) {
221        code_lengths[symbol++] = code_len;
222        if (code_len != 0) prev_code_len = code_len;
223      } else {
224        const int use_prev = (code_len == kCodeLengthRepeatCode);
225        const int slot = code_len - kCodeLengthLiterals;
226        const int extra_bits = kCodeLengthExtraBits[slot];
227        const int repeat_offset = kCodeLengthRepeatOffsets[slot];
228        int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;
229        if (symbol + repeat > num_symbols) {
230          goto End;
231        } else {
232          const int length = use_prev ? prev_code_len : 0;
233          while (repeat-- > 0) code_lengths[symbol++] = length;
234        }
235      }
236    }
237    ok = 1;
238   End:
239    if (!ok) dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
240    return ok;
241  }
242  static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,
243                             int* const code_lengths, HuffmanCode* const table) {
244    int ok = 0;
245    int size = 0;
246    VP8LBitReader* const br = &dec->br_;
247    const int simple_code = VP8LReadBits(br, 1);
248    memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));
249    if (simple_code) {  
250      const int num_symbols = VP8LReadBits(br, 1) + 1;
251      const int first_symbol_len_code = VP8LReadBits(br, 1);
252      int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);
253      code_lengths[symbol] = 1;
254      if (num_symbols == 2) {
255        symbol = VP8LReadBits(br, 8);
256        code_lengths[symbol] = 1;
257      }
258      ok = 1;
259    } else {  
260      int i;
261      int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };
262      const int num_codes = VP8LReadBits(br, 4) + 4;
263      if (num_codes > NUM_CODE_LENGTH_CODES) {
264        dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
265        return 0;
266      }
267      for (i = 0; i < num_codes; ++i) {
268        code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);
269      }
270      ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,
271                                  code_lengths);
272    }
273    ok = ok && !br->eos_;
274    if (ok) {
275      size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,
276                                   code_lengths, alphabet_size);
277    }
278    if (!ok || size == 0) {
279      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
280      return 0;
281    }
282    return size;
283  }
284  static int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,
285                              int color_cache_bits, int allow_recursion) {
286    int i, j;
287    VP8LBitReader* const br = &dec->br_;
288    VP8LMetadata* const hdr = &dec->hdr_;
289    uint32_t* huffman_image = NULL;
290    HTreeGroup* htree_groups = NULL;
291    HuffmanCode* huffman_tables = NULL;
292    HuffmanCode* huffman_table = NULL;
293    int num_htree_groups = 1;
294    int num_htree_groups_max = 1;
295    int max_alphabet_size = 0;
296    int* code_lengths = NULL;
297    const int table_size = kTableSize[color_cache_bits];
298    int* mapping = NULL;
299    int ok = 0;
300    if (allow_recursion && VP8LReadBits(br, 1)) {
301      const int huffman_precision = VP8LReadBits(br, 3) + 2;
302      const int huffman_xsize = VP8LSubSampleSize(xsize, huffman_precision);
303      const int huffman_ysize = VP8LSubSampleSize(ysize, huffman_precision);
304      const int huffman_pixs = huffman_xsize * huffman_ysize;
305      if (!DecodeImageStream(huffman_xsize, huffman_ysize, 0, dec,
306                             &huffman_image)) {
307        goto Error;
308      }
309      hdr->huffman_subsample_bits_ = huffman_precision;
310      for (i = 0; i < huffman_pixs; ++i) {
311        const int group = (huffman_image[i] >> 8) & 0xffff;
312        huffman_image[i] = group;
313        if (group >= num_htree_groups_max) {
314          num_htree_groups_max = group + 1;
315        }
316      }
317      if (num_htree_groups_max > 1000 || num_htree_groups_max > xsize * ysize) {
318        mapping = (int*)WebPSafeMalloc(num_htree_groups_max, sizeof(*mapping));
319        if (mapping == NULL) {
320          dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
321          goto Error;
322        }
323        memset(mapping, 0xff, num_htree_groups_max * sizeof(*mapping));
324        for (num_htree_groups = 0, i = 0; i < huffman_pixs; ++i) {
325          int* const mapped_group = &mapping[huffman_image[i]];
326          if (*mapped_group == -1) *mapped_group = num_htree_groups++;
327          huffman_image[i] = *mapped_group;
328        }
329      } else {
330        num_htree_groups = num_htree_groups_max;
331      }
332    }
333    if (br->eos_) goto Error;
334    for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
335      int alphabet_size = kAlphabetSize[j];
336      if (j == 0 && color_cache_bits > 0) {
337        alphabet_size += 1 << color_cache_bits;
338      }
339      if (max_alphabet_size < alphabet_size) {
340        max_alphabet_size = alphabet_size;
341      }
342    }
343    code_lengths = (int*)WebPSafeCalloc((uint64_t)max_alphabet_size,
344                                        sizeof(*code_lengths));
345    huffman_tables = (HuffmanCode*)WebPSafeMalloc(num_htree_groups * table_size,
346                                                  sizeof(*huffman_tables));
347    htree_groups = VP8LHtreeGroupsNew(num_htree_groups);
348    if (htree_groups == NULL || code_lengths == NULL || huffman_tables == NULL) {
349      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
350      goto Error;
351    }
352    huffman_table = huffman_tables;
353    for (i = 0; i < num_htree_groups_max; ++i) {
354      if (mapping != NULL && mapping[i] == -1) {
355        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
356          int alphabet_size = kAlphabetSize[j];
357          if (j == 0 && color_cache_bits > 0) {
358            alphabet_size += (1 << color_cache_bits);
359          }
360          if (!ReadHuffmanCode(alphabet_size, dec, code_lengths, NULL)) {
361            goto Error;
362          }
363        }
364      } else {
365        HTreeGroup* const htree_group =
366            &htree_groups[(mapping == NULL) ? i : mapping[i]];
367        HuffmanCode** const htrees = htree_group->htrees;
368        int size;
369        int total_size = 0;
370        int is_trivial_literal = 1;
371        int max_bits = 0;
372        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {
373          int alphabet_size = kAlphabetSize[j];
374          htrees[j] = huffman_table;
375          if (j == 0 && color_cache_bits > 0) {
376            alphabet_size += (1 << color_cache_bits);
377          }
378          size = ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_table);
379          if (size == 0) {
380            goto Error;
381          }
382          if (is_trivial_literal && kLiteralMap[j] == 1) {
383            is_trivial_literal = (huffman_table->bits == 0);
384          }
385          total_size += huffman_table->bits;
386          huffman_table += size;
387          if (j <= ALPHA) {
388            int local_max_bits = code_lengths[0];
389            int k;
390            for (k = 1; k < alphabet_size; ++k) {
391              if (code_lengths[k] > local_max_bits) {
392                local_max_bits = code_lengths[k];
393              }
394            }
395            max_bits += local_max_bits;
396          }
397        }
398        htree_group->is_trivial_literal = is_trivial_literal;
399        htree_group->is_trivial_code = 0;
400        if (is_trivial_literal) {
401          const int red = htrees[RED][0].value;
402          const int blue = htrees[BLUE][0].value;
403          const int alpha = htrees[ALPHA][0].value;
404          htree_group->literal_arb = ((uint32_t)alpha << 24) | (red << 16) | blue;
405          if (total_size == 0 && htrees[GREEN][0].value < NUM_LITERAL_CODES) {
406            htree_group->is_trivial_code = 1;
407            htree_group->literal_arb |= htrees[GREEN][0].value << 8;
408          }
409        }
410        htree_group->use_packed_table =
411            !htree_group->is_trivial_code && (max_bits < HUFFMAN_PACKED_BITS);
412        if (htree_group->use_packed_table) BuildPackedTable(htree_group);
413      }
414    }
415    ok = 1;
416    hdr->huffman_image_ = huffman_image;
417    hdr->num_htree_groups_ = num_htree_groups;
418    hdr->htree_groups_ = htree_groups;
419    hdr->huffman_tables_ = huffman_tables;
420   Error:
421    WebPSafeFree(code_lengths);
422    WebPSafeFree(mapping);
423    if (!ok) {
424      WebPSafeFree(huffman_image);
425      WebPSafeFree(huffman_tables);
426      VP8LHtreeGroupsFree(htree_groups);
427    }
428    return ok;
429  }
430  #if !defined(WEBP_REDUCE_SIZE)
431  static int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {
432    const int num_channels = 4;
433    const int in_width = io->mb_w;
434    const int out_width = io->scaled_width;
435    const int in_height = io->mb_h;
436    const int out_height = io->scaled_height;
437    const uint64_t work_size = 2 * num_channels * (uint64_t)out_width;
438    rescaler_t* work;        
439    const uint64_t scaled_data_size = (uint64_t)out_width;
440    uint32_t* scaled_data;  
441    const uint64_t memory_size = sizeof(*dec->rescaler) +
442                                 work_size * sizeof(*work) +
443                                 scaled_data_size * sizeof(*scaled_data);
444    uint8_t* memory = (uint8_t*)WebPSafeMalloc(memory_size, sizeof(*memory));
445    if (memory == NULL) {
446      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
447      return 0;
448    }
449    assert(dec->rescaler_memory == NULL);
450    dec->rescaler_memory = memory;
451    dec->rescaler = (WebPRescaler*)memory;
452    memory += sizeof(*dec->rescaler);
453    work = (rescaler_t*)memory;
454    memory += work_size * sizeof(*work);
455    scaled_data = (uint32_t*)memory;
456    WebPRescalerInit(dec->rescaler, in_width, in_height, (uint8_t*)scaled_data,
457                     out_width, out_height, 0, num_channels, work);
458    return 1;
459  }
460  #endif   
461  #if !defined(WEBP_REDUCE_SIZE)
462  static int Export(WebPRescaler* const rescaler, WEBP_CSP_MODE colorspace,
463                    int rgba_stride, uint8_t* const rgba) {
464    uint32_t* const src = (uint32_t*)rescaler->dst;
465    const int dst_width = rescaler->dst_width;
466    int num_lines_out = 0;
467    while (WebPRescalerHasPendingOutput(rescaler)) {
468      uint8_t* const dst = rgba + num_lines_out * rgba_stride;
469      WebPRescalerExportRow(rescaler);
470      WebPMultARGBRow(src, dst_width, 1);
471      VP8LConvertFromBGRA(src, dst_width, colorspace, dst);
472      ++num_lines_out;
473    }
474    return num_lines_out;
475  }
476  static int EmitRescaledRowsRGBA(const VP8LDecoder* const dec,
477                                  uint8_t* in, int in_stride, int mb_h,
478                                  uint8_t* const out, int out_stride) {
479    const WEBP_CSP_MODE colorspace = dec->output_->colorspace;
480    int num_lines_in = 0;
481    int num_lines_out = 0;
482    while (num_lines_in < mb_h) {
483      uint8_t* const row_in = in + num_lines_in * in_stride;
484      uint8_t* const row_out = out + num_lines_out * out_stride;
485      const int lines_left = mb_h - num_lines_in;
486      const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);
487      int lines_imported;
488      assert(needed_lines > 0 && needed_lines <= lines_left);
489      WebPMultARGBRows(row_in, in_stride,
490                       dec->rescaler->src_width, needed_lines, 0);
491      lines_imported =
492          WebPRescalerImport(dec->rescaler, lines_left, row_in, in_stride);
493      assert(lines_imported == needed_lines);
494      num_lines_in += lines_imported;
495      num_lines_out += Export(dec->rescaler, colorspace, out_stride, row_out);
496    }
497    return num_lines_out;
498  }
499  #endif   
500  static int EmitRows(WEBP_CSP_MODE colorspace,
501                      const uint8_t* row_in, int in_stride,
502                      int mb_w, int mb_h,
503                      uint8_t* const out, int out_stride) {
504    int lines = mb_h;
505    uint8_t* row_out = out;
506    while (lines-- > 0) {
507      VP8LConvertFromBGRA((const uint32_t*)row_in, mb_w, colorspace, row_out);
508      row_in += in_stride;
509      row_out += out_stride;
510    }
511    return mb_h;  
512  }
513  static void ConvertToYUVA(const uint32_t* const src, int width, int y_pos,
514                            const WebPDecBuffer* const output) {
515    const WebPYUVABuffer* const buf = &output->u.YUVA;
516    WebPConvertARGBToY(src, buf->y + y_pos * buf->y_stride, width);
517    {
518      uint8_t* const u = buf->u + (y_pos >> 1) * buf->u_stride;
519      uint8_t* const v = buf->v + (y_pos >> 1) * buf->v_stride;
520      WebPConvertARGBToUV(src, u, v, width, !(y_pos & 1));
521    }
522    if (buf->a != NULL) {
523      uint8_t* const a = buf->a + y_pos * buf->a_stride;
524  #if defined(WORDS_BIGENDIAN)
525      WebPExtractAlpha((uint8_t*)src + 0, 0, width, 1, a, 0);
526  #else
527      WebPExtractAlpha((uint8_t*)src + 3, 0, width, 1, a, 0);
528  #endif
529    }
530  }
531  static int ExportYUVA(const VP8LDecoder* const dec, int y_pos) {
532    WebPRescaler* const rescaler = dec->rescaler;
533    uint32_t* const src = (uint32_t*)rescaler->dst;
534    const int dst_width = rescaler->dst_width;
535    int num_lines_out = 0;
536    while (WebPRescalerHasPendingOutput(rescaler)) {
537      WebPRescalerExportRow(rescaler);
538      WebPMultARGBRow(src, dst_width, 1);
539      ConvertToYUVA(src, dst_width, y_pos, dec->output_);
540      ++y_pos;
541      ++num_lines_out;
542    }
543    return num_lines_out;
544  }
545  static int EmitRescaledRowsYUVA(const VP8LDecoder* const dec,
546                                  uint8_t* in, int in_stride, int mb_h) {
547    int num_lines_in = 0;
548    int y_pos = dec->last_out_row_;
549    while (num_lines_in < mb_h) {
550      const int lines_left = mb_h - num_lines_in;
551      const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);
552      int lines_imported;
553      WebPMultARGBRows(in, in_stride, dec->rescaler->src_width, needed_lines, 0);
554      lines_imported =
555          WebPRescalerImport(dec->rescaler, lines_left, in, in_stride);
556      assert(lines_imported == needed_lines);
557      num_lines_in += lines_imported;
558      in += needed_lines * in_stride;
559      y_pos += ExportYUVA(dec, y_pos);
560    }
561    return y_pos;
562  }
563  static int EmitRowsYUVA(const VP8LDecoder* const dec,
564                          const uint8_t* in, int in_stride,
565                          int mb_w, int num_rows) {
566    int y_pos = dec->last_out_row_;
567    while (num_rows-- > 0) {
568      ConvertToYUVA((const uint32_t*)in, mb_w, y_pos, dec->output_);
569      in += in_stride;
570      ++y_pos;
571    }
572    return y_pos;
573  }
574  static int SetCropWindow(VP8Io* const io, int y_start, int y_end,
575                           uint8_t** const in_data, int pixel_stride) {
576    assert(y_start < y_end);
577    assert(io->crop_left < io->crop_right);
578    if (y_end > io->crop_bottom) {
579      y_end = io->crop_bottom;  
580    }
581    if (y_start < io->crop_top) {
582      const int delta = io->crop_top - y_start;
583      y_start = io->crop_top;
584      *in_data += delta * pixel_stride;
585    }
586    if (y_start >= y_end) return 0;  
587    *in_data += io->crop_left * sizeof(uint32_t);
588    io->mb_y = y_start - io->crop_top;
589    io->mb_w = io->crop_right - io->crop_left;
590    io->mb_h = y_end - y_start;
591    return 1;  
592  }
593  static WEBP_INLINE int GetMetaIndex(
594      const uint32_t* const image, int xsize, int bits, int x, int y) {
595    if (bits == 0) return 0;
596    return image[xsize * (y >> bits) + (x >> bits)];
597  }
598  static WEBP_INLINE HTreeGroup* GetHtreeGroupForPos(VP8LMetadata* const hdr,
599                                                     int x, int y) {
600    const int meta_index = GetMetaIndex(hdr->huffman_image_, hdr->huffman_xsize_,
601                                        hdr->huffman_subsample_bits_, x, y);
602    assert(meta_index < hdr->num_htree_groups_);
603    return hdr->htree_groups_ + meta_index;
604  }
605  typedef void (*ProcessRowsFunc)(VP8LDecoder* const dec, int row);
606  static void ApplyInverseTransforms(VP8LDecoder* const dec,
607                                     int start_row, int num_rows,
608                                     const uint32_t* const rows) {
609    int n = dec->next_transform_;
610    const int cache_pixs = dec->width_ * num_rows;
611    const int end_row = start_row + num_rows;
612    const uint32_t* rows_in = rows;
613    uint32_t* const rows_out = dec->argb_cache_;
614    while (n-- > 0) {
615      VP8LTransform* const transform = &dec->transforms_[n];
616      VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);
617      rows_in = rows_out;
618    }
619    if (rows_in != rows_out) {
620      memcpy(rows_out, rows_in, cache_pixs * sizeof(*rows_out));
621    }
622  }
623  static void ProcessRows(VP8LDecoder* const dec, int row) {
624    const uint32_t* const rows = dec->pixels_ + dec->width_ * dec->last_row_;
625    const int num_rows = row - dec->last_row_;
626    assert(row <= dec->io_->crop_bottom);
627    assert(num_rows <= NUM_ARGB_CACHE_ROWS);
628    if (num_rows > 0) {    
629      VP8Io* const io = dec->io_;
630      uint8_t* rows_data = (uint8_t*)dec->argb_cache_;
631      const int in_stride = io->width * sizeof(uint32_t);  
632      ApplyInverseTransforms(dec, dec->last_row_, num_rows, rows);
633      if (!SetCropWindow(io, dec->last_row_, row, &rows_data, in_stride)) {
634      } else {
635        const WebPDecBuffer* const output = dec->output_;
636        if (WebPIsRGBMode(output->colorspace)) {  
637          const WebPRGBABuffer* const buf = &output->u.RGBA;
638          uint8_t* const rgba = buf->rgba + dec->last_out_row_ * buf->stride;
639          const int num_rows_out =
640  #if !defined(WEBP_REDUCE_SIZE)
641           io->use_scaling ?
642              EmitRescaledRowsRGBA(dec, rows_data, in_stride, io->mb_h,
643                                   rgba, buf->stride) :
644  #endif  
645              EmitRows(output->colorspace, rows_data, in_stride,
646                       io->mb_w, io->mb_h, rgba, buf->stride);
647          dec->last_out_row_ += num_rows_out;
648        } else {                              
649          dec->last_out_row_ = io->use_scaling ?
650              EmitRescaledRowsYUVA(dec, rows_data, in_stride, io->mb_h) :
651              EmitRowsYUVA(dec, rows_data, in_stride, io->mb_w, io->mb_h);
652        }
653        assert(dec->last_out_row_ <= output->height);
654      }
655    }
656    dec->last_row_ = row;
657    assert(dec->last_row_ <= dec->height_);
658  }
659  static int Is8bOptimizable(const VP8LMetadata* const hdr) {
660    int i;
661    if (hdr->color_cache_size_ > 0) return 0;
662    for (i = 0; i < hdr->num_htree_groups_; ++i) {
663      HuffmanCode** const htrees = hdr->htree_groups_[i].htrees;
664      if (htrees[RED][0].bits > 0) return 0;
665      if (htrees[BLUE][0].bits > 0) return 0;
666      if (htrees[ALPHA][0].bits > 0) return 0;
667    }
668    return 1;
669  }
670  static void AlphaApplyFilter(ALPHDecoder* const alph_dec,
671                               int first_row, int last_row,
672                               uint8_t* out, int stride) {
673    if (alph_dec->filter_ != WEBP_FILTER_NONE) {
674      int y;
675      const uint8_t* prev_line = alph_dec->prev_line_;
676      assert(WebPUnfilters[alph_dec->filter_] != NULL);
677      for (y = first_row; y < last_row; ++y) {
678        WebPUnfilters[alph_dec->filter_](prev_line, out, out, stride);
679        prev_line = out;
680        out += stride;
681      }
682      alph_dec->prev_line_ = prev_line;
683    }
684  }
685  static void ExtractPalettedAlphaRows(VP8LDecoder* const dec, int last_row) {
686    ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;
687    const int top_row =
688        (alph_dec->filter_ == WEBP_FILTER_NONE ||
689         alph_dec->filter_ == WEBP_FILTER_HORIZONTAL) ? dec->io_->crop_top
690                                                      : dec->last_row_;
691    const int first_row = (dec->last_row_ < top_row) ? top_row : dec->last_row_;
692    assert(last_row <= dec->io_->crop_bottom);
693    if (last_row > first_row) {
694      const int width = dec->io_->width;
695      uint8_t* out = alph_dec->output_ + width * first_row;
696      const uint8_t* const in =
697        (uint8_t*)dec->pixels_ + dec->width_ * first_row;
698      VP8LTransform* const transform = &dec->transforms_[0];
699      assert(dec->next_transform_ == 1);
700      assert(transform->type_ == COLOR_INDEXING_TRANSFORM);
701      VP8LColorIndexInverseTransformAlpha(transform, first_row, last_row,
702                                          in, out);
703      AlphaApplyFilter(alph_dec, first_row, last_row, out, width);
704    }
705    dec->last_row_ = dec->last_out_row_ = last_row;
706  }
707  static WEBP_INLINE uint32_t Rotate8b(uint32_t V) {
708  #if defined(WORDS_BIGENDIAN)
709    return ((V & 0xff000000u) >> 24) | (V << 8);
710  #else
711    return ((V & 0xffu) << 24) | (V >> 8);
712  #endif
713  }
714  static WEBP_INLINE void CopySmallPattern8b(const uint8_t* src, uint8_t* dst,
715                                             int length, uint32_t pattern) {
716    int i;
717    while ((uintptr_t)dst & 3) {
718      *dst++ = *src++;
719      pattern = Rotate8b(pattern);
720      --length;
721    }
722    for (i = 0; i < (length >> 2); ++i) {
723      ((uint32_t*)dst)[i] = pattern;
724    }
725    for (i <<= 2; i < length; ++i) {
726      dst[i] = src[i];
727    }
728  }
729  static WEBP_INLINE void CopyBlock8b(uint8_t* const dst, int dist, int length) {
730    const uint8_t* src = dst - dist;
731    if (length >= 8) {
732      uint32_t pattern = 0;
733      switch (dist) {
734        case 1:
735          pattern = src[0];
736  #if defined(__arm__) || defined(_M_ARM)   
737          pattern |= pattern << 8;
738          pattern |= pattern << 16;
739  #elif defined(WEBP_USE_MIPS_DSP_R2)
740          __asm__ volatile ("replv.qb %0, %0" : "+r"(pattern));
741  #else
742          pattern = 0x01010101u * pattern;
743  #endif
744          break;
745        case 2:
746  #if !defined(WORDS_BIGENDIAN)
747          memcpy(&pattern, src, sizeof(uint16_t));
748  #else
749          pattern = ((uint32_t)src[0] << 8) | src[1];
750  #endif
751  #if defined(__arm__) || defined(_M_ARM)
752          pattern |= pattern << 16;
753  #elif defined(WEBP_USE_MIPS_DSP_R2)
754          __asm__ volatile ("replv.ph %0, %0" : "+r"(pattern));
755  #else
756          pattern = 0x00010001u * pattern;
757  #endif
758          break;
759        case 4:
760          memcpy(&pattern, src, sizeof(uint32_t));
761          break;
762        default:
763          goto Copy;
764          break;
765      }
766      CopySmallPattern8b(src, dst, length, pattern);
767      return;
768    }
769   Copy:
770    if (dist >= length) {  
771      memcpy(dst, src, length * sizeof(*dst));
772    } else {
773      int i;
774      for (i = 0; i < length; ++i) dst[i] = src[i];
775    }
776  }
777  static WEBP_INLINE void CopySmallPattern32b(const uint32_t* src,
778                                              uint32_t* dst,
779                                              int length, uint64_t pattern) {
780    int i;
781    if ((uintptr_t)dst & 4) {           
782      *dst++ = *src++;
783      pattern = (pattern >> 32) | (pattern << 32);
784      --length;
785    }
786    assert(0 == ((uintptr_t)dst & 7));
787    for (i = 0; i < (length >> 1); ++i) {
788      ((uint64_t*)dst)[i] = pattern;    
789    }
790    if (length & 1) {                   
791      dst[i << 1] = src[i << 1];
792    }
793  }
794  static WEBP_INLINE void CopyBlock32b(uint32_t* const dst,
795                                       int dist, int length) {
796    const uint32_t* const src = dst - dist;
797    if (dist <= 2 && length >= 4 && ((uintptr_t)dst & 3) == 0) {
798      uint64_t pattern;
799      if (dist == 1) {
800        pattern = (uint64_t)src[0];
801        pattern |= pattern << 32;
802      } else {
803        memcpy(&pattern, src, sizeof(pattern));
804      }
805      CopySmallPattern32b(src, dst, length, pattern);
806    } else if (dist >= length) {  
807      memcpy(dst, src, length * sizeof(*dst));
808    } else {
809      int i;
810      for (i = 0; i < length; ++i) dst[i] = src[i];
811    }
812  }
813  static int DecodeAlphaData(VP8LDecoder* const dec, uint8_t* const data,
814                             int width, int height, int last_row) {
815    int ok = 1;
816    int row = dec->last_pixel_ / width;
817    int col = dec->last_pixel_ % width;
818    VP8LBitReader* const br = &dec->br_;
819    VP8LMetadata* const hdr = &dec->hdr_;
820    int pos = dec->last_pixel_;         
821    const int end = width * height;     
822    const int last = width * last_row;  
823    const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;
824    const int mask = hdr->huffman_mask_;
825    const HTreeGroup* htree_group =
826        (pos < last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;
827    assert(pos <= end);
828    assert(last_row <= height);
829    assert(Is8bOptimizable(hdr));
830    while (!br->eos_ && pos < last) {
831      int code;
832      if ((col & mask) == 0) {
833        htree_group = GetHtreeGroupForPos(hdr, col, row);
834      }
835      assert(htree_group != NULL);
836      VP8LFillBitWindow(br);
837      code = ReadSymbol(htree_group->htrees[GREEN], br);
838      if (code < NUM_LITERAL_CODES) {  
839        data[pos] = code;
840        ++pos;
841        ++col;
842        if (col >= width) {
843          col = 0;
844          ++row;
845          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
846            ExtractPalettedAlphaRows(dec, row);
847          }
848        }
849      } else if (code < len_code_limit) {  
850        int dist_code, dist;
851        const int length_sym = code - NUM_LITERAL_CODES;
852        const int length = GetCopyLength(length_sym, br);
853        const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);
854        VP8LFillBitWindow(br);
855        dist_code = GetCopyDistance(dist_symbol, br);
856        dist = PlaneCodeToDistance(width, dist_code);
857        if (pos >= dist && end - pos >= length) {
858          CopyBlock8b(data + pos, dist, length);
859        } else {
860          ok = 0;
861          goto End;
862        }
863        pos += length;
864        col += length;
865        while (col >= width) {
866          col -= width;
867          ++row;
868          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
869            ExtractPalettedAlphaRows(dec, row);
870          }
871        }
872        if (pos < last && (col & mask)) {
873          htree_group = GetHtreeGroupForPos(hdr, col, row);
874        }
875      } else {  
876        ok = 0;
877        goto End;
878      }
879      br->eos_ = VP8LIsEndOfStream(br);
880    }
881    ExtractPalettedAlphaRows(dec, row > last_row ? last_row : row);
882   End:
883    br->eos_ = VP8LIsEndOfStream(br);
884    if (!ok || (br->eos_ && pos < end)) {
885      ok = 0;
886      dec->status_ = br->eos_ ? VP8_STATUS_SUSPENDED
887                              : VP8_STATUS_BITSTREAM_ERROR;
888    } else {
889      dec->last_pixel_ = pos;
890    }
891    return ok;
892  }
893  static void SaveState(VP8LDecoder* const dec, int last_pixel) {
894    assert(dec->incremental_);
895    dec->saved_br_ = dec->br_;
896    dec->saved_last_pixel_ = last_pixel;
897    if (dec->hdr_.color_cache_size_ > 0) {
898      VP8LColorCacheCopy(&dec->hdr_.color_cache_, &dec->hdr_.saved_color_cache_);
899    }
900  }
901  static void RestoreState(VP8LDecoder* const dec) {
902    assert(dec->br_.eos_);
903    dec->status_ = VP8_STATUS_SUSPENDED;
904    dec->br_ = dec->saved_br_;
905    dec->last_pixel_ = dec->saved_last_pixel_;
906    if (dec->hdr_.color_cache_size_ > 0) {
907      VP8LColorCacheCopy(&dec->hdr_.saved_color_cache_, &dec->hdr_.color_cache_);
908    }
909  }
910  #define SYNC_EVERY_N_ROWS 8  
911  static int DecodeImageData(VP8LDecoder* const dec, uint32_t* const data,
912                             int width, int height, int last_row,
913                             ProcessRowsFunc process_func) {
914    int row = dec->last_pixel_ / width;
915    int col = dec->last_pixel_ % width;
916    VP8LBitReader* const br = &dec->br_;
917    VP8LMetadata* const hdr = &dec->hdr_;
918    uint32_t* src = data + dec->last_pixel_;
919    uint32_t* last_cached = src;
920    uint32_t* const src_end = data + width * height;     
921    uint32_t* const src_last = data + width * last_row;  
922    const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;
923    const int color_cache_limit = len_code_limit + hdr->color_cache_size_;
924    int next_sync_row = dec->incremental_ ? row : 1 << 24;
925    VP8LColorCache* const color_cache =
926        (hdr->color_cache_size_ > 0) ? &hdr->color_cache_ : NULL;
927    const int mask = hdr->huffman_mask_;
928    const HTreeGroup* htree_group =
929        (src < src_last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;
930    assert(dec->last_row_ < last_row);
931    assert(src_last <= src_end);
932    while (src < src_last) {
933      int code;
934      if (row >= next_sync_row) {
935        SaveState(dec, (int)(src - data));
936        next_sync_row = row + SYNC_EVERY_N_ROWS;
937      }
938      if ((col & mask) == 0) {
939        htree_group = GetHtreeGroupForPos(hdr, col, row);
940      }
941      assert(htree_group != NULL);
942      if (htree_group->is_trivial_code) {
943        *src = htree_group->literal_arb;
944        goto AdvanceByOne;
945      }
946      VP8LFillBitWindow(br);
947      if (htree_group->use_packed_table) {
948        code = ReadPackedSymbols(htree_group, br, src);
949        if (VP8LIsEndOfStream(br)) break;
950        if (code == PACKED_NON_LITERAL_CODE) goto AdvanceByOne;
951      } else {
952        code = ReadSymbol(htree_group->htrees[GREEN], br);
953      }
954      if (VP8LIsEndOfStream(br)) break;
955      if (code < NUM_LITERAL_CODES) {  
956        if (htree_group->is_trivial_literal) {
957          *src = htree_group->literal_arb | (code << 8);
958        } else {
959          int red, blue, alpha;
960          red = ReadSymbol(htree_group->htrees[RED], br);
961          VP8LFillBitWindow(br);
962          blue = ReadSymbol(htree_group->htrees[BLUE], br);
963          alpha = ReadSymbol(htree_group->htrees[ALPHA], br);
964          if (VP8LIsEndOfStream(br)) break;
965          *src = ((uint32_t)alpha << 24) | (red << 16) | (code << 8) | blue;
966        }
967      AdvanceByOne:
968        ++src;
969        ++col;
970        if (col >= width) {
971          col = 0;
972          ++row;
973          if (process_func != NULL) {
974            if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
975              process_func(dec, row);
976            }
977          }
978          if (color_cache != NULL) {
979            while (last_cached < src) {
980              VP8LColorCacheInsert(color_cache, *last_cached++);
981            }
982          }
983        }
984      } else if (code < len_code_limit) {  
985        int dist_code, dist;
986        const int length_sym = code - NUM_LITERAL_CODES;
987        const int length = GetCopyLength(length_sym, br);
988        const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);
989        VP8LFillBitWindow(br);
990        dist_code = GetCopyDistance(dist_symbol, br);
991        dist = PlaneCodeToDistance(width, dist_code);
992        if (VP8LIsEndOfStream(br)) break;
993        if (src - data < (ptrdiff_t)dist || src_end - src < (ptrdiff_t)length) {
994          goto Error;
995        } else {
996          CopyBlock32b(src, dist, length);
997        }
998        src += length;
999        col += length;
1000        while (col >= width) {
1001          col -= width;
1002          ++row;
1003          if (process_func != NULL) {
1004            if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {
1005              process_func(dec, row);
1006            }
1007          }
1008        }
1009        assert(src <= src_end);
1010        if (col & mask) htree_group = GetHtreeGroupForPos(hdr, col, row);
1011        if (color_cache != NULL) {
1012          while (last_cached < src) {
1013            VP8LColorCacheInsert(color_cache, *last_cached++);
1014          }
1015        }
1016      } else if (code < color_cache_limit) {  
1017        const int key = code - len_code_limit;
1018        assert(color_cache != NULL);
1019        while (last_cached < src) {
1020          VP8LColorCacheInsert(color_cache, *last_cached++);
1021        }
1022        *src = VP8LColorCacheLookup(color_cache, key);
1023        goto AdvanceByOne;
1024      } else {  
1025        goto Error;
1026      }
1027    }
1028    br->eos_ = VP8LIsEndOfStream(br);
1029    if (dec->incremental_ && br->eos_ && src < src_end) {
1030      RestoreState(dec);
1031    } else if (!br->eos_) {
1032      if (process_func != NULL) {
1033        process_func(dec, row > last_row ? last_row : row);
1034      }
1035      dec->status_ = VP8_STATUS_OK;
1036      dec->last_pixel_ = (int)(src - data);  
1037    } else {
1038      goto Error;
1039    }
1040    return 1;
1041   Error:
1042    dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1043    return 0;
1044  }
1045  static void ClearTransform(VP8LTransform* const transform) {
1046    WebPSafeFree(transform->data_);
1047    transform->data_ = NULL;
1048  }
1049  static int ExpandColorMap(int num_colors, VP8LTransform* const transform) {
1050    int i;
1051    const int final_num_colors = 1 << (8 >> transform->bits_);
1052    uint32_t* const new_color_map =
1053        (uint32_t*)WebPSafeMalloc((uint64_t)final_num_colors,
1054                                  sizeof(*new_color_map));
1055    if (new_color_map == NULL) {
1056      return 0;
1057    } else {
1058      uint8_t* const data = (uint8_t*)transform->data_;
1059      uint8_t* const new_data = (uint8_t*)new_color_map;
1060      new_color_map[0] = transform->data_[0];
1061      for (i = 4; i < 4 * num_colors; ++i) {
1062        new_data[i] = (data[i] + new_data[i - 4]) & 0xff;
1063      }
1064      for (; i < 4 * final_num_colors; ++i) {
1065        new_data[i] = 0;  
1066      }
1067      WebPSafeFree(transform->data_);
1068      transform->data_ = new_color_map;
1069    }
1070    return 1;
1071  }
1072  static int ReadTransform(int* const xsize, int const* ysize,
1073                           VP8LDecoder* const dec) {
1074    int ok = 1;
1075    VP8LBitReader* const br = &dec->br_;
1076    VP8LTransform* transform = &dec->transforms_[dec->next_transform_];
1077    const VP8LImageTransformType type =
1078        (VP8LImageTransformType)VP8LReadBits(br, 2);
1079    if (dec->transforms_seen_ & (1U << type)) {
1080      return 0;  
1081    }
1082    dec->transforms_seen_ |= (1U << type);
1083    transform->type_ = type;
1084    transform->xsize_ = *xsize;
1085    transform->ysize_ = *ysize;
1086    transform->data_ = NULL;
1087    ++dec->next_transform_;
1088    assert(dec->next_transform_ <= NUM_TRANSFORMS);
1089    switch (type) {
1090      case PREDICTOR_TRANSFORM:
1091      case CROSS_COLOR_TRANSFORM:
1092        transform->bits_ = VP8LReadBits(br, 3) + 2;
1093        ok = DecodeImageStream(VP8LSubSampleSize(transform->xsize_,
1094                                                 transform->bits_),
1095                               VP8LSubSampleSize(transform->ysize_,
1096                                                 transform->bits_),
1097                               0, dec, &transform->data_);
1098        break;
1099      case COLOR_INDEXING_TRANSFORM: {
1100         const int num_colors = VP8LReadBits(br, 8) + 1;
1101         const int bits = (num_colors > 16) ? 0
1102                        : (num_colors > 4) ? 1
1103                        : (num_colors > 2) ? 2
1104                        : 3;
1105         *xsize = VP8LSubSampleSize(transform->xsize_, bits);
1106         transform->bits_ = bits;
1107         ok = DecodeImageStream(num_colors, 1, 0, dec, &transform->data_);
1108         ok = ok && ExpandColorMap(num_colors, transform);
1109        break;
1110      }
1111      case SUBTRACT_GREEN:
1112        break;
1113      default:
1114        assert(0);    
1115        break;
1116    }
1117    return ok;
1118  }
1119  static void InitMetadata(VP8LMetadata* const hdr) {
1120    assert(hdr != NULL);
1121    memset(hdr, 0, sizeof(*hdr));
1122  }
1123  static void ClearMetadata(VP8LMetadata* const hdr) {
1124    assert(hdr != NULL);
1125    WebPSafeFree(hdr->huffman_image_);
1126    WebPSafeFree(hdr->huffman_tables_);
1127    VP8LHtreeGroupsFree(hdr->htree_groups_);
1128    VP8LColorCacheClear(&hdr->color_cache_);
1129    VP8LColorCacheClear(&hdr->saved_color_cache_);
1130    InitMetadata(hdr);
1131  }
1132  VP8LDecoder* VP8LNew(void) {
1133    VP8LDecoder* const dec = (VP8LDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));
1134    if (dec == NULL) return NULL;
1135    dec->status_ = VP8_STATUS_OK;
1136    dec->state_ = READ_DIM;
1137    VP8LDspInit();  
1138    return dec;
1139  }
1140  void VP8LClear(VP8LDecoder* const dec) {
1141    int i;
1142    if (dec == NULL) return;
1143    ClearMetadata(&dec->hdr_);
1144    WebPSafeFree(dec->pixels_);
1145    dec->pixels_ = NULL;
1146    for (i = 0; i < dec->next_transform_; ++i) {
1147      ClearTransform(&dec->transforms_[i]);
1148    }
1149    dec->next_transform_ = 0;
1150    dec->transforms_seen_ = 0;
1151    WebPSafeFree(dec->rescaler_memory);
1152    dec->rescaler_memory = NULL;
1153    dec->output_ = NULL;   
1154  }
1155  void VP8LDelete(VP8LDecoder* const dec) {
1156    if (dec != NULL) {
1157      VP8LClear(dec);
1158      WebPSafeFree(dec);
1159    }
1160  }
1161  static void UpdateDecoder(VP8LDecoder* const dec, int width, int height) {
1162    VP8LMetadata* const hdr = &dec->hdr_;
1163    const int num_bits = hdr->huffman_subsample_bits_;
1164    dec->width_ = width;
1165    dec->height_ = height;
1166    hdr->huffman_xsize_ = VP8LSubSampleSize(width, num_bits);
1167    hdr->huffman_mask_ = (num_bits == 0) ? ~0 : (1 << num_bits) - 1;
1168  }
1169  static int DecodeImageStream(int xsize, int ysize,
1170                               int is_level0,
1171                               VP8LDecoder* const dec,
1172                               uint32_t** const decoded_data) {
1173    int ok = 1;
1174    int transform_xsize = xsize;
1175    int transform_ysize = ysize;
1176    VP8LBitReader* const br = &dec->br_;
1177    VP8LMetadata* const hdr = &dec->hdr_;
1178    uint32_t* data = NULL;
1179    int color_cache_bits = 0;
1180    if (is_level0) {
1181      while (ok && VP8LReadBits(br, 1)) {
1182        ok = ReadTransform(&transform_xsize, &transform_ysize, dec);
1183      }
1184    }
1185    if (ok && VP8LReadBits(br, 1)) {
1186      color_cache_bits = VP8LReadBits(br, 4);
1187      ok = (color_cache_bits >= 1 && color_cache_bits <= MAX_CACHE_BITS);
1188      if (!ok) {
1189        dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1190        goto End;
1191      }
1192    }
1193    ok = ok && ReadHuffmanCodes(dec, transform_xsize, transform_ysize,
1194                                color_cache_bits, is_level0);
1195    if (!ok) {
1196      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1197      goto End;
1198    }
1199    if (color_cache_bits > 0) {
1200      hdr->color_cache_size_ = 1 << color_cache_bits;
1201      if (!VP8LColorCacheInit(&hdr->color_cache_, color_cache_bits)) {
1202        dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1203        ok = 0;
1204        goto End;
1205      }
1206    } else {
1207      hdr->color_cache_size_ = 0;
1208    }
1209    UpdateDecoder(dec, transform_xsize, transform_ysize);
1210    if (is_level0) {   
1211      dec->state_ = READ_HDR;
1212      goto End;
1213    }
1214    {
1215      const uint64_t total_size = (uint64_t)transform_xsize * transform_ysize;
1216      data = (uint32_t*)WebPSafeMalloc(total_size, sizeof(*data));
1217      if (data == NULL) {
1218        dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1219        ok = 0;
1220        goto End;
1221      }
1222    }
1223    ok = DecodeImageData(dec, data, transform_xsize, transform_ysize,
1224                         transform_ysize, NULL);
1225    ok = ok && !br->eos_;
1226   End:
1227    if (!ok) {
1228      WebPSafeFree(data);
1229      ClearMetadata(hdr);
1230    } else {
1231      if (decoded_data != NULL) {
1232        *decoded_data = data;
1233      } else {
1234        assert(data == NULL);
1235        assert(is_level0);
1236      }
1237      dec->last_pixel_ = 0;  
1238      if (!is_level0) ClearMetadata(hdr);  
1239    }
1240    return ok;
1241  }
1242  static int AllocateInternalBuffers32b(VP8LDecoder* const dec, int final_width) {
1243    const uint64_t num_pixels = (uint64_t)dec->width_ * dec->height_;
1244    const uint64_t cache_top_pixels = (uint16_t)final_width;
1245    const uint64_t cache_pixels = (uint64_t)final_width * NUM_ARGB_CACHE_ROWS;
1246    const uint64_t total_num_pixels =
1247        num_pixels + cache_top_pixels + cache_pixels;
1248    assert(dec->width_ <= final_width);
1249    dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint32_t));
1250    if (dec->pixels_ == NULL) {
1251      dec->argb_cache_ = NULL;    
1252      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1253      return 0;
1254    }
1255    dec->argb_cache_ = dec->pixels_ + num_pixels + cache_top_pixels;
1256    return 1;
1257  }
1258  static int AllocateInternalBuffers8b(VP8LDecoder* const dec) {
1259    const uint64_t total_num_pixels = (uint64_t)dec->width_ * dec->height_;
1260    dec->argb_cache_ = NULL;    
1261    dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint8_t));
1262    if (dec->pixels_ == NULL) {
1263      dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1264      return 0;
1265    }
1266    return 1;
1267  }
1268  static void ExtractAlphaRows(VP8LDecoder* const dec, int last_row) {
1269    int cur_row = dec->last_row_;
1270    int num_rows = last_row - cur_row;
1271    const uint32_t* in = dec->pixels_ + dec->width_ * cur_row;
1272    assert(last_row <= dec->io_->crop_bottom);
1273    while (num_rows > 0) {
1274      const int num_rows_to_process =
1275          (num_rows > NUM_ARGB_CACHE_ROWS) ? NUM_ARGB_CACHE_ROWS : num_rows;
1276      ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;
1277      uint8_t* const output = alph_dec->output_;
1278      const int width = dec->io_->width;      
1279      const int cache_pixs = width * num_rows_to_process;
1280      uint8_t* const dst = output + width * cur_row;
1281      const uint32_t* const src = dec->argb_cache_;
1282      ApplyInverseTransforms(dec, cur_row, num_rows_to_process, in);
1283      WebPExtractGreen(src, dst, cache_pixs);
1284      AlphaApplyFilter(alph_dec,
1285                       cur_row, cur_row + num_rows_to_process, dst, width);
1286      num_rows -= num_rows_to_process;
1287      in += num_rows_to_process * dec->width_;
1288      cur_row += num_rows_to_process;
1289    }
1290    assert(cur_row == last_row);
1291    dec->last_row_ = dec->last_out_row_ = last_row;
1292  }
1293  int VP8LDecodeAlphaHeader(ALPHDecoder* const alph_dec,
1294                            const uint8_t* const data, size_t data_size) {
1295    int ok = 0;
1296    VP8LDecoder* dec = VP8LNew();
1297    if (dec == NULL) return 0;
1298    assert(alph_dec != NULL);
<span onclick='openModal()' class='match'>1299    dec->width_ = alph_dec->width_;
1300    dec->height_ = alph_dec->height_;
1301    dec->io_ = &alph_dec->io_;
1302    dec->io_->opaque = alph_dec;
1303    dec->io_->width = alph_dec->width_;
1304    dec->io_->height = alph_dec->height_;
1305    dec->status_ = VP8_STATUS_OK;
1306    VP8LInitBitReader(&dec->br_, data, data_size);
1307    if (!DecodeImageStream(alph_dec->width_, alph_dec->height_, 1, dec, NULL)) {
</span>1308      goto Err;
1309    }
1310    if (dec->next_transform_ == 1 &&
1311        dec->transforms_[0].type_ == COLOR_INDEXING_TRANSFORM &&
1312        Is8bOptimizable(&dec->hdr_)) {
1313      alph_dec->use_8b_decode_ = 1;
1314      ok = AllocateInternalBuffers8b(dec);
1315    } else {
1316      alph_dec->use_8b_decode_ = 0;
1317      ok = AllocateInternalBuffers32b(dec, alph_dec->width_);
1318    }
1319    if (!ok) goto Err;
1320    alph_dec->vp8l_dec_ = dec;
1321    return 1;
1322   Err:
1323    VP8LDelete(dec);
1324    return 0;
1325  }
1326  int VP8LDecodeAlphaImageStream(ALPHDecoder* const alph_dec, int last_row) {
1327    VP8LDecoder* const dec = alph_dec->vp8l_dec_;
1328    assert(dec != NULL);
1329    assert(last_row <= dec->height_);
1330    if (dec->last_row_ >= last_row) {
1331      return 1;  
1332    }
1333    if (!alph_dec->use_8b_decode_) WebPInitAlphaProcessing();
1334    return alph_dec->use_8b_decode_ ?
1335        DecodeAlphaData(dec, (uint8_t*)dec->pixels_, dec->width_, dec->height_,
1336                        last_row) :
1337        DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,
1338                        last_row, ExtractAlphaRows);
1339  }
1340  int VP8LDecodeHeader(VP8LDecoder* const dec, VP8Io* const io) {
1341    int width, height, has_alpha;
1342    if (dec == NULL) return 0;
1343    if (io == NULL) {
1344      dec->status_ = VP8_STATUS_INVALID_PARAM;
1345      return 0;
1346    }
1347    dec->io_ = io;
1348    dec->status_ = VP8_STATUS_OK;
1349    VP8LInitBitReader(&dec->br_, io->data, io->data_size);
1350    if (!ReadImageInfo(&dec->br_, &width, &height, &has_alpha)) {
1351      dec->status_ = VP8_STATUS_BITSTREAM_ERROR;
1352      goto Error;
1353    }
1354    dec->state_ = READ_DIM;
1355    io->width = width;
1356    io->height = height;
1357    if (!DecodeImageStream(width, height, 1, dec, NULL)) goto Error;
1358    return 1;
1359   Error:
1360    VP8LClear(dec);
1361    assert(dec->status_ != VP8_STATUS_OK);
1362    return 0;
1363  }
1364  int VP8LDecodeImage(VP8LDecoder* const dec) {
1365    VP8Io* io = NULL;
1366    WebPDecParams* params = NULL;
1367    if (dec == NULL) return 0;
1368    assert(dec->hdr_.huffman_tables_ != NULL);
1369    assert(dec->hdr_.htree_groups_ != NULL);
1370    assert(dec->hdr_.num_htree_groups_ > 0);
1371    io = dec->io_;
1372    assert(io != NULL);
1373    params = (WebPDecParams*)io->opaque;
1374    assert(params != NULL);
1375    if (dec->state_ != READ_DATA) {
1376      dec->output_ = params->output;
1377      assert(dec->output_ != NULL);
1378      if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {
1379        dec->status_ = VP8_STATUS_INVALID_PARAM;
1380        goto Err;
1381      }
1382      if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;
1383  #if !defined(WEBP_REDUCE_SIZE)
1384      if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;
1385  #else
1386      if (io->use_scaling) {
1387        dec->status_ = VP8_STATUS_INVALID_PARAM;
1388        goto Err;
1389      }
1390  #endif
1391      if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {
1392        WebPInitAlphaProcessing();
1393      }
1394      if (!WebPIsRGBMode(dec->output_->colorspace)) {
1395        WebPInitConvertARGBToYUV();
1396        if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();
1397      }
1398      if (dec->incremental_) {
1399        if (dec->hdr_.color_cache_size_ > 0 &&
1400            dec->hdr_.saved_color_cache_.colors_ == NULL) {
1401          if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,
1402                                  dec->hdr_.color_cache_.hash_bits_)) {
1403            dec->status_ = VP8_STATUS_OUT_OF_MEMORY;
1404            goto Err;
1405          }
1406        }
1407      }
1408      dec->state_ = READ_DATA;
1409    }
1410    if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,
1411                         io->crop_bottom, ProcessRows)) {
1412      goto Err;
1413    }
1414    params->last_y = dec->last_out_row_;
1415    return 1;
1416   Err:
1417    VP8LClear(dec);
1418    assert(dec->status_ != VP8_STATUS_OK);
1419    return 0;
1420  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-lossless_enc.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-vp8l_dec.c</div>
                </div>
                <div class="column column_space"><pre><code>823    VP8LPredictorsSub_C[9] = PredictorSub9_C;
824    VP8LPredictorsSub_C[10] = PredictorSub10_C;
825    VP8LPredictorsSub_C[11] = PredictorSub11_C;
826    VP8LPredictorsSub_C[12] = PredictorSub12_C;
827    VP8LPredictorsSub_C[13] = PredictorSub13_C;
828    VP8LPredictorsSub_C[14] = PredictorSub0_C;  
829    VP8LPredictorsSub_C[15] = PredictorSub0_C;
830    if (VP8GetCPUInfo != NULL) {
</pre></code></div>
                <div class="column column_space"><pre><code>1299    dec->width_ = alph_dec->width_;
1300    dec->height_ = alph_dec->height_;
1301    dec->io_ = &alph_dec->io_;
1302    dec->io_->opaque = alph_dec;
1303    dec->io_->width = alph_dec->width_;
1304    dec->io_->height = alph_dec->height_;
1305    dec->status_ = VP8_STATUS_OK;
1306    VP8LInitBitReader(&dec->br_, data, data_size);
1307    if (!DecodeImageStream(alph_dec->width_, alph_dec->height_, 1, dec, NULL)) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    