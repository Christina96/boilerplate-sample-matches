
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.427672955974842%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-uri.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_URI_H_
2  #define RAPIDJSON_URI_H_
3  #include "internal/strfunc.h"
4  #if defined(__clang__)
5  RAPIDJSON_DIAG_PUSH
6  RAPIDJSON_DIAG_OFF(c++98-compat)
7  #elif defined(_MSC_VER)
8  RAPIDJSON_DIAG_OFF(4512) 
9  #endif
10  RAPIDJSON_NAMESPACE_BEGIN
11  template <typename ValueType, typename Allocator=CrtAllocator>
12  class GenericUri {
13  public:
14      typedef typename ValueType::Ch Ch;
15  #if RAPIDJSON_HAS_STDSTRING
16      typedef std::basic_string<Ch> String;
17  #endif
<span onclick='openModal()' class='match'>18      GenericUri(Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
19      }
20      GenericUri(const Ch* uri, SizeType len, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
21          Parse(uri, len);
22      }
23      GenericUri(const Ch* uri, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
24          Parse(uri, internal::StrLen<Ch>(uri));
25      }
</span>26      template<typename T> GenericUri(const T& uri, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
27          const Ch* u = uri.template Get<const Ch*>(); 
28          Parse(u, internal::StrLen<Ch>(u));
29      }
30  #if RAPIDJSON_HAS_STDSTRING
31      GenericUri(const String& uri, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
32          Parse(uri.c_str(), internal::StrLen<Ch>(uri.c_str()));
33      }
34  #endif
35      GenericUri(const GenericUri& rhs) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(), ownAllocator_() {
36          *this = rhs;
37      }
38      GenericUri(const GenericUri& rhs, Allocator* allocator) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
39          *this = rhs;
40      }
41      ~GenericUri() {
42          Free();
43          RAPIDJSON_DELETE(ownAllocator_);
44      }
45      GenericUri& operator=(const GenericUri& rhs) {
46          if (this != &rhs) {
47              Free();
48              Allocate(rhs.GetStringLength());
49              auth_ = CopyPart(scheme_, rhs.scheme_, rhs.GetSchemeStringLength());
50              path_ = CopyPart(auth_, rhs.auth_, rhs.GetAuthStringLength());
51              query_ = CopyPart(path_, rhs.path_, rhs.GetPathStringLength());
52              frag_ = CopyPart(query_, rhs.query_, rhs.GetQueryStringLength());
53              base_ = CopyPart(frag_, rhs.frag_, rhs.GetFragStringLength());
54              uri_ = CopyPart(base_, rhs.base_, rhs.GetBaseStringLength());
55              CopyPart(uri_, rhs.uri_, rhs.GetStringLength());
56          }
57          return *this;
58      }
59      template<typename T> void Get(T& uri, Allocator& allocator) {
60          uri.template Set<const Ch*>(this->GetString(), allocator); 
61      }
62      const Ch* GetString() const { return uri_; }
63      SizeType GetStringLength() const { return uri_ == 0 ? 0 : internal::StrLen<Ch>(uri_); }
64      const Ch* GetBaseString() const { return base_; }
65      SizeType GetBaseStringLength() const { return base_ == 0 ? 0 : internal::StrLen<Ch>(base_); }
66      const Ch* GetSchemeString() const { return scheme_; }
67      SizeType GetSchemeStringLength() const { return scheme_ == 0 ? 0 : internal::StrLen<Ch>(scheme_); }
68      const Ch* GetAuthString() const { return auth_; }
69      SizeType GetAuthStringLength() const { return auth_ == 0 ? 0 : internal::StrLen<Ch>(auth_); }
70      const Ch* GetPathString() const { return path_; }
71      SizeType GetPathStringLength() const { return path_ == 0 ? 0 : internal::StrLen<Ch>(path_); }
72      const Ch* GetQueryString() const { return query_; }
73      SizeType GetQueryStringLength() const { return query_ == 0 ? 0 : internal::StrLen<Ch>(query_); }
74      const Ch* GetFragString() const { return frag_; }
75      SizeType GetFragStringLength() const { return frag_ == 0 ? 0 : internal::StrLen<Ch>(frag_); }
76  #if RAPIDJSON_HAS_STDSTRING
77      static String Get(const GenericUri& uri) { return String(uri.GetString(), uri.GetStringLength()); }
78      static String GetBase(const GenericUri& uri) { return String(uri.GetBaseString(), uri.GetBaseStringLength()); }
79      static String GetScheme(const GenericUri& uri) { return String(uri.GetSchemeString(), uri.GetSchemeStringLength()); }
80      static String GetAuth(const GenericUri& uri) { return String(uri.GetAuthString(), uri.GetAuthStringLength()); }
81      static String GetPath(const GenericUri& uri) { return String(uri.GetPathString(), uri.GetPathStringLength()); }
82      static String GetQuery(const GenericUri& uri) { return String(uri.GetQueryString(), uri.GetQueryStringLength()); }
83      static String GetFrag(const GenericUri& uri) { return String(uri.GetFragString(), uri.GetFragStringLength()); }
84  #endif
85      bool operator==(const GenericUri& rhs) const {
86          return Match(rhs, true);
87      }
88      bool operator!=(const GenericUri& rhs) const {
89          return !Match(rhs, true);
90      }
91      bool Match(const GenericUri& uri, bool full = true) const {
92          Ch* s1;
93          Ch* s2;
94          if (full) {
95              s1 = uri_;
96              s2 = uri.uri_;
97          } else {
98              s1 = base_;
99              s2 = uri.base_;
100          }
101          if (s1 == s2) return true;
102          if (s1 == 0 || s2 == 0) return false;
103          return internal::StrCmp<Ch>(s1, s2) == 0;
104      }
105      GenericUri Resolve(const GenericUri& baseuri, Allocator* allocator = 0) {
106          GenericUri resuri;
107          resuri.allocator_ = allocator;
108          resuri.Allocate(GetStringLength() + baseuri.GetStringLength() + 1); 
109          if (!(GetSchemeStringLength() == 0)) {
110              resuri.auth_ = CopyPart(resuri.scheme_, scheme_, GetSchemeStringLength());
111              resuri.path_ = CopyPart(resuri.auth_, auth_, GetAuthStringLength());
112              resuri.query_ = CopyPart(resuri.path_, path_, GetPathStringLength());
113              resuri.frag_ = CopyPart(resuri.query_, query_, GetQueryStringLength());
114              resuri.RemoveDotSegments();
115          } else {
116              resuri.auth_ = CopyPart(resuri.scheme_, baseuri.scheme_, baseuri.GetSchemeStringLength());
117              if (!(GetAuthStringLength() == 0)) {
118                  resuri.path_ = CopyPart(resuri.auth_, auth_, GetAuthStringLength());
119                  resuri.query_ = CopyPart(resuri.path_, path_, GetPathStringLength());
120                  resuri.frag_ = CopyPart(resuri.query_, query_, GetQueryStringLength());
121                  resuri.RemoveDotSegments();
122              } else {
123                  resuri.path_ = CopyPart(resuri.auth_, baseuri.auth_, baseuri.GetAuthStringLength());
124                  if (GetPathStringLength() == 0) {
125                      resuri.query_ = CopyPart(resuri.path_, baseuri.path_, baseuri.GetPathStringLength());
126                      if (GetQueryStringLength() == 0) {
127                          resuri.frag_ = CopyPart(resuri.query_, baseuri.query_, baseuri.GetQueryStringLength());
128                      } else {
129                          resuri.frag_ = CopyPart(resuri.query_, query_, GetQueryStringLength());
130                      }
131                  } else {
132                      if (path_[0] == '/') {
133                          resuri.query_ = CopyPart(resuri.path_, path_, GetPathStringLength());
134                          resuri.RemoveDotSegments();
135                      } else {
136                          size_t pos = 0;
137                          if (!(baseuri.GetAuthStringLength() == 0) && baseuri.GetPathStringLength() == 0) {
138                              resuri.path_[pos] = '/';
139                              pos++;
140                          }
141                          size_t lastslashpos = baseuri.GetPathStringLength();
142                          while (lastslashpos > 0) {
143                              if (baseuri.path_[lastslashpos - 1] == '/') break;
144                              lastslashpos--;
145                          }
146                          std::memcpy(&resuri.path_[pos], baseuri.path_, lastslashpos * sizeof(Ch));
147                          pos += lastslashpos;
148                          resuri.query_ = CopyPart(&resuri.path_[pos], path_, GetPathStringLength());
149                          resuri.RemoveDotSegments();
150                      }
151                      resuri.frag_ = CopyPart(resuri.query_, query_, GetQueryStringLength());
152                  }
153              }
154          }
155          resuri.base_ = CopyPart(resuri.frag_, frag_, GetFragStringLength());
156          resuri.SetBase();
157          resuri.uri_ = resuri.base_ + resuri.GetBaseStringLength() + 1;
158          resuri.SetUri();
159          return resuri;
160      }
161      Allocator& GetAllocator() { return *allocator_; }
162  private:
163      std::size_t Allocate(std::size_t len) {
164          if (!allocator_)
165              ownAllocator_ =  allocator_ = RAPIDJSON_NEW(Allocator)();
166          size_t total = (3 * len + 7) * sizeof(Ch);
167          scheme_ = static_cast<Ch*>(allocator_->Malloc(total));
168          *scheme_ = '\0';
169          auth_ = scheme_ + 1;
170          *auth_ = '\0';
171          path_ = auth_ + 1;
172          *path_ = '\0';
173          query_ = path_ + 1;
174          *query_ = '\0';
175          frag_ = query_ + 1;
176          *frag_ = '\0';
177          base_ = frag_ + 1;
178          *base_ = '\0';
179          uri_ = base_ + 1;
180          *uri_ = '\0';
181          return total;
182      }
183      void Free() {
184          if (scheme_) {
185              Allocator::Free(scheme_);
186              scheme_ = 0;
187          }
188      }
189      void Parse(const Ch* uri, std::size_t len) {
190          std::size_t start = 0, pos1 = 0, pos2 = 0;
191          Allocate(len);
192          if (start < len) {
193              while (pos1 < len) {
194                  if (uri[pos1] == ':') break;
195                  pos1++;
196              }
197              if (pos1 != len) {
198                  while (pos2 < len) {
199                      if (uri[pos2] == '/') break;
200                      if (uri[pos2] == '?') break;
201                      if (uri[pos2] == '#') break;
202                      pos2++;
203                  }
204                  if (pos1 < pos2) {
205                      pos1++;
206                      std::memcpy(scheme_, &uri[start], pos1 * sizeof(Ch));
207                      scheme_[pos1] = '\0';
208                      start = pos1;
209                  }
210              }
211          }
212          auth_ = scheme_ + GetSchemeStringLength() + 1;
213          *auth_ = '\0';
214          if (start < len - 1 && uri[start] == '/' && uri[start + 1] == '/') {
215              pos2 = start + 2;
216              while (pos2 < len) {
217                  if (uri[pos2] == '/') break;
218                  if (uri[pos2] == '?') break;
219                  if (uri[pos2] == '#') break;
220                  pos2++;
221              }
222              std::memcpy(auth_, &uri[start], (pos2 - start) * sizeof(Ch));
223              auth_[pos2 - start] = '\0';
224              start = pos2;
225          }
226          path_ = auth_ + GetAuthStringLength() + 1;
227          *path_ = '\0';
228          if (start < len) {
229              pos2 = start;
230              while (pos2 < len) {
231                  if (uri[pos2] == '?') break;
232                  if (uri[pos2] == '#') break;
233                  pos2++;
234              }
235              if (start != pos2) {
236                  std::memcpy(path_, &uri[start], (pos2 - start) * sizeof(Ch));
237                  path_[pos2 - start] = '\0';
238                  if (path_[0] == '/')
239                      RemoveDotSegments();   
240                  start = pos2;
241              }
242          }
243          query_ = path_ + GetPathStringLength() + 1;
244          *query_ = '\0';
245          if (start < len && uri[start] == '?') {
246              pos2 = start + 1;
247              while (pos2 < len) {
248                  if (uri[pos2] == '#') break;
249                  pos2++;
250              }
251              if (start != pos2) {
252                  std::memcpy(query_, &uri[start], (pos2 - start) * sizeof(Ch));
253                  query_[pos2 - start] = '\0';
254                  start = pos2;
255              }
256          }
257          frag_ = query_ + GetQueryStringLength() + 1;
258          *frag_ = '\0';
259          if (start < len && uri[start] == '#') {
260              std::memcpy(frag_, &uri[start], (len - start) * sizeof(Ch));
261              frag_[len - start] = '\0';
262          }
263          base_ = frag_ + GetFragStringLength() + 1;
264          SetBase();
265          uri_ = base_ + GetBaseStringLength() + 1;
266          SetUri();
267      }
268      void SetBase() {
269          Ch* next = base_;
270          std::memcpy(next, scheme_, GetSchemeStringLength() * sizeof(Ch));
271          next+= GetSchemeStringLength();
272          std::memcpy(next, auth_, GetAuthStringLength() * sizeof(Ch));
273          next+= GetAuthStringLength();
274          std::memcpy(next, path_, GetPathStringLength() * sizeof(Ch));
275          next+= GetPathStringLength();
276          std::memcpy(next, query_, GetQueryStringLength() * sizeof(Ch));
277          next+= GetQueryStringLength();
278          *next = '\0';
279      }
280      void SetUri() {
281          Ch* next = uri_;
282          std::memcpy(next, base_, GetBaseStringLength() * sizeof(Ch));
283          next+= GetBaseStringLength();
284          std::memcpy(next, frag_, GetFragStringLength() * sizeof(Ch));
285          next+= GetFragStringLength();
286          *next = '\0';
287      }
288      Ch* CopyPart(Ch* to, Ch* from, std::size_t len) {
289          RAPIDJSON_ASSERT(to != 0);
290          RAPIDJSON_ASSERT(from != 0);
291          std::memcpy(to, from, len * sizeof(Ch));
292          to[len] = '\0';
293          Ch* next = to + len + 1;
294          return next;
295      }
296      void RemoveDotSegments() {
297          std::size_t pathlen = GetPathStringLength();
298          std::size_t pathpos = 0;  
299          std::size_t newpos = 0;   
300          while (pathpos < pathlen) {
301              size_t slashpos = 0;
302              while ((pathpos + slashpos) < pathlen) {
303                  if (path_[pathpos + slashpos] == '/') break;
304                  slashpos++;
305              }
306              if (slashpos == 2 && path_[pathpos] == '.' && path_[pathpos + 1] == '.') {
307                  RAPIDJSON_ASSERT(newpos == 0 || path_[newpos - 1] == '/');
308                  size_t lastslashpos = newpos;
309                  if (lastslashpos > 1) {
310                      lastslashpos--;
311                      while (lastslashpos > 0) {
312                          if (path_[lastslashpos - 1] == '/') break;
313                          lastslashpos--;
314                      }
315                      newpos = lastslashpos;
316                  }
317              } else if (slashpos == 1 && path_[pathpos] == '.') {
318              } else {
319                  RAPIDJSON_ASSERT(newpos <= pathpos);
320                  std::memmove(&path_[newpos], &path_[pathpos], slashpos * sizeof(Ch));
321                  newpos += slashpos;
322                  if ((pathpos + slashpos) < pathlen) {
323                      path_[newpos] = '/';
324                      newpos++;
325                  }
326              }
327              pathpos += slashpos + 1;
328          }
329          path_[newpos] = '\0';
330      }
331      Ch* uri_;    
332      Ch* base_;   
333      Ch* scheme_; 
334      Ch* auth_;   
335      Ch* path_;   
336      Ch* query_;  
337      Ch* frag_;   
338      Allocator* allocator_;      
339      Allocator* ownAllocator_;   
340  };
341  typedef GenericUri<Value> Uri;
342  RAPIDJSON_NAMESPACE_END
343  #if defined(__clang__)
344  RAPIDJSON_DIAG_POP
345  #endif
346  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-pointer.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_POINTER_H_
2  #define RAPIDJSON_POINTER_H_
3  #include "document.h"
4  #include "uri.h"
5  #include "internal/itoa.h"
6  #ifdef __clang__
7  RAPIDJSON_DIAG_PUSH
8  RAPIDJSON_DIAG_OFF(switch-enum)
9  #elif defined(_MSC_VER)
10  RAPIDJSON_DIAG_PUSH
11  RAPIDJSON_DIAG_OFF(4512) 
12  #endif
13  RAPIDJSON_NAMESPACE_BEGIN
14  static const SizeType kPointerInvalidIndex = ~SizeType(0);  
15  enum PointerParseErrorCode {
16      kPointerParseErrorNone = 0,                     
17      kPointerParseErrorTokenMustBeginWithSolidus,    
18      kPointerParseErrorInvalidEscape,                
19      kPointerParseErrorInvalidPercentEncoding,       
20      kPointerParseErrorCharacterMustPercentEncode    
21  };
22  template <typename ValueType, typename Allocator = CrtAllocator>
23  class GenericPointer {
24  public:
25      typedef typename ValueType::EncodingType EncodingType;  
26      typedef typename ValueType::Ch Ch;                      
27      typedef GenericUri<ValueType, Allocator> UriType;
28      struct Token {
29          const Ch* name;             
30          SizeType length;            
31          SizeType index;             
32      };
<span onclick='openModal()' class='match'>33      GenericPointer(Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {}
34      explicit GenericPointer(const Ch* source, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
35          Parse(source, internal::StrLen(source));
36      }
37  #if RAPIDJSON_HAS_STDSTRING
38      explicit GenericPointer(const std::basic_string<Ch>& source, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
39          Parse(source.c_str(), source.size());
40      }
</span>41  #endif
42      GenericPointer(const Ch* source, size_t length, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
43          Parse(source, length);
44      }
45      GenericPointer(const Token* tokens, size_t tokenCount) : allocator_(), ownAllocator_(), nameBuffer_(), tokens_(const_cast<Token*>(tokens)), tokenCount_(tokenCount), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {}
46      GenericPointer(const GenericPointer& rhs) : allocator_(), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
47          *this = rhs;
48      }
49      GenericPointer(const GenericPointer& rhs, Allocator* allocator) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
50          *this = rhs;
51      }
52      ~GenericPointer() {
53          if (nameBuffer_)    
54              Allocator::Free(tokens_);
55          RAPIDJSON_DELETE(ownAllocator_);
56      }
57      GenericPointer& operator=(const GenericPointer& rhs) {
58          if (this != &rhs) {
59              if (nameBuffer_)
60                  Allocator::Free(tokens_);
61              tokenCount_ = rhs.tokenCount_;
62              parseErrorOffset_ = rhs.parseErrorOffset_;
63              parseErrorCode_ = rhs.parseErrorCode_;
64              if (rhs.nameBuffer_)
65                  CopyFromRaw(rhs); 
66              else {
67                  tokens_ = rhs.tokens_; 
68                  nameBuffer_ = 0;
69              }
70          }
71          return *this;
72      }
73      GenericPointer& Swap(GenericPointer& other) RAPIDJSON_NOEXCEPT {
74          internal::Swap(allocator_, other.allocator_);
75          internal::Swap(ownAllocator_, other.ownAllocator_);
76          internal::Swap(nameBuffer_, other.nameBuffer_);
77          internal::Swap(tokens_, other.tokens_);
78          internal::Swap(tokenCount_, other.tokenCount_);
79          internal::Swap(parseErrorOffset_, other.parseErrorOffset_);
80          internal::Swap(parseErrorCode_, other.parseErrorCode_);
81          return *this;
82      }
83      friend inline void swap(GenericPointer& a, GenericPointer& b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
84      GenericPointer Append(const Token& token, Allocator* allocator = 0) const {
85          GenericPointer r;
86          r.allocator_ = allocator;
87          Ch *p = r.CopyFromRaw(*this, 1, token.length + 1);
88          std::memcpy(p, token.name, (token.length + 1) * sizeof(Ch));
89          r.tokens_[tokenCount_].name = p;
90          r.tokens_[tokenCount_].length = token.length;
91          r.tokens_[tokenCount_].index = token.index;
92          return r;
93      }
94      GenericPointer Append(const Ch* name, SizeType length, Allocator* allocator = 0) const {
95          Token token = { name, length, kPointerInvalidIndex };
96          return Append(token, allocator);
97      }
98      template <typename T>
99      RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >), (GenericPointer))
100      Append(T* name, Allocator* allocator = 0) const {
101          return Append(name, internal::StrLen(name), allocator);
102      }
103  #if RAPIDJSON_HAS_STDSTRING
104      GenericPointer Append(const std::basic_string<Ch>& name, Allocator* allocator = 0) const {
105          return Append(name.c_str(), static_cast<SizeType>(name.size()), allocator);
106      }
107  #endif
108      GenericPointer Append(SizeType index, Allocator* allocator = 0) const {
109          char buffer[21];
110          char* end = sizeof(SizeType) == 4 ? internal::u32toa(index, buffer) : internal::u64toa(index, buffer);
111          SizeType length = static_cast<SizeType>(end - buffer);
112          buffer[length] = '\0';
113          if (sizeof(Ch) == 1) {
114              Token token = { reinterpret_cast<Ch*>(buffer), length, index };
115              return Append(token, allocator);
116          }
117          else {
118              Ch name[21];
119              for (size_t i = 0; i <= length; i++)
120                  name[i] = static_cast<Ch>(buffer[i]);
121              Token token = { name, length, index };
122              return Append(token, allocator);
123          }
124      }
125      GenericPointer Append(const ValueType& token, Allocator* allocator = 0) const {
126          if (token.IsString())
127              return Append(token.GetString(), token.GetStringLength(), allocator);
128          else {
129              RAPIDJSON_ASSERT(token.IsUint64());
130              RAPIDJSON_ASSERT(token.GetUint64() <= SizeType(~0));
131              return Append(static_cast<SizeType>(token.GetUint64()), allocator);
132          }
133      }
134      bool IsValid() const { return parseErrorCode_ == kPointerParseErrorNone; }
135      size_t GetParseErrorOffset() const { return parseErrorOffset_; }
136      PointerParseErrorCode GetParseErrorCode() const { return parseErrorCode_; }
137      Allocator& GetAllocator() { return *allocator_; }
138      const Token* GetTokens() const { return tokens_; }
139      size_t GetTokenCount() const { return tokenCount_; }
140      bool operator==(const GenericPointer& rhs) const {
141          if (!IsValid() || !rhs.IsValid() || tokenCount_ != rhs.tokenCount_)
142              return false;
143          for (size_t i = 0; i < tokenCount_; i++) {
144              if (tokens_[i].index != rhs.tokens_[i].index ||
145                  tokens_[i].length != rhs.tokens_[i].length ||
146                  (tokens_[i].length != 0 && std::memcmp(tokens_[i].name, rhs.tokens_[i].name, sizeof(Ch)* tokens_[i].length) != 0))
147              {
148                  return false;
149              }
150          }
151          return true;
152      }
153      bool operator!=(const GenericPointer& rhs) const { return !(*this == rhs); }
154      bool operator<(const GenericPointer& rhs) const {
155          if (!IsValid())
156              return false;
157          if (!rhs.IsValid())
158              return true;
159          if (tokenCount_ != rhs.tokenCount_)
160              return tokenCount_ < rhs.tokenCount_;
161          for (size_t i = 0; i < tokenCount_; i++) {
162              if (tokens_[i].index != rhs.tokens_[i].index)
163                  return tokens_[i].index < rhs.tokens_[i].index;
164              if (tokens_[i].length != rhs.tokens_[i].length)
165                  return tokens_[i].length < rhs.tokens_[i].length;
166              if (int cmp = std::memcmp(tokens_[i].name, rhs.tokens_[i].name, sizeof(Ch) * tokens_[i].length))
167                  return cmp < 0;
168          }
169          return false;
170      }
171      template<typename OutputStream>
172      bool Stringify(OutputStream& os) const {
173          return Stringify<false, OutputStream>(os);
174      }
175      template<typename OutputStream>
176      bool StringifyUriFragment(OutputStream& os) const {
177          return Stringify<true, OutputStream>(os);
178      }
179      ValueType& Create(ValueType& root, typename ValueType::AllocatorType& allocator, bool* alreadyExist = 0) const {
180          RAPIDJSON_ASSERT(IsValid());
181          ValueType* v = &root;
182          bool exist = true;
183          for (const Token *t = tokens_; t != tokens_ + tokenCount_; ++t) {
184              if (v->IsArray() && t->name[0] == '-' && t->length == 1) {
185                  v->PushBack(ValueType().Move(), allocator);
186                  v = &((*v)[v->Size() - 1]);
187                  exist = false;
188              }
189              else {
190                  if (t->index == kPointerInvalidIndex) { 
191                      if (!v->IsObject())
192                          v->SetObject(); 
193                  }
194                  else { 
195                      if (!v->IsArray() && !v->IsObject())
196                          v->SetArray(); 
197                  }
198                  if (v->IsArray()) {
199                      if (t->index >= v->Size()) {
200                          v->Reserve(t->index + 1, allocator);
201                          while (t->index >= v->Size())
202                              v->PushBack(ValueType().Move(), allocator);
203                          exist = false;
204                      }
205                      v = &((*v)[t->index]);
206                  }
207                  else {
208                      typename ValueType::MemberIterator m = v->FindMember(GenericValue<EncodingType>(GenericStringRef<Ch>(t->name, t->length)));
209                      if (m == v->MemberEnd()) {
210                          v->AddMember(ValueType(t->name, t->length, allocator).Move(), ValueType().Move(), allocator);
211                          m = v->MemberEnd();
212                          v = &(--m)->value; 
213                          exist = false;
214                      }
215                      else
216                          v = &m->value;
217                  }
218              }
219          }
220          if (alreadyExist)
221              *alreadyExist = exist;
222          return *v;
223      }
224      template <typename stackAllocator>
225      ValueType& Create(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, bool* alreadyExist = 0) const {
226          return Create(document, document.GetAllocator(), alreadyExist);
227      }
228      UriType GetUri(ValueType& root, const UriType& rootUri, size_t* unresolvedTokenIndex = 0, Allocator* allocator = 0) const {
229          static const Ch kIdString[] = { 'i', 'd', '\0' };
230          static const ValueType kIdValue(kIdString, 2);
231          UriType base = UriType(rootUri, allocator);
232          RAPIDJSON_ASSERT(IsValid());
233          ValueType* v = &root;
234          for (const Token *t = tokens_; t != tokens_ + tokenCount_; ++t) {
235              switch (v->GetType()) {
236                  case kObjectType:
237                  {
238                      typename ValueType::MemberIterator m = v->FindMember(kIdValue);
239                      if (m != v->MemberEnd() && (m->value).IsString()) {
240                          UriType here = UriType(m->value, allocator).Resolve(base, allocator);
241                          base = here;
242                      }
243                      m = v->FindMember(GenericValue<EncodingType>(GenericStringRef<Ch>(t->name, t->length)));
244                      if (m == v->MemberEnd())
245                          break;
246                      v = &m->value;
247                  }
248                    continue;
249                  case kArrayType:
250                      if (t->index == kPointerInvalidIndex || t->index >= v->Size())
251                          break;
252                      v = &((*v)[t->index]);
253                      continue;
254                  default:
255                      break;
256              }
257              if (unresolvedTokenIndex)
258                  *unresolvedTokenIndex = static_cast<size_t>(t - tokens_);
259              return UriType(allocator);
260          }
261          return base;
262      }
263      UriType GetUri(const ValueType& root, const UriType& rootUri, size_t* unresolvedTokenIndex = 0, Allocator* allocator = 0) const {
264        return GetUri(const_cast<ValueType&>(root), rootUri, unresolvedTokenIndex, allocator);
265      }
266      ValueType* Get(ValueType& root, size_t* unresolvedTokenIndex = 0) const {
267          RAPIDJSON_ASSERT(IsValid());
268          ValueType* v = &root;
269          for (const Token *t = tokens_; t != tokens_ + tokenCount_; ++t) {
270              switch (v->GetType()) {
271              case kObjectType:
272                  {
273                      typename ValueType::MemberIterator m = v->FindMember(GenericValue<EncodingType>(GenericStringRef<Ch>(t->name, t->length)));
274                      if (m == v->MemberEnd())
275                          break;
276                      v = &m->value;
277                  }
278                  continue;
279              case kArrayType:
280                  if (t->index == kPointerInvalidIndex || t->index >= v->Size())
281                      break;
282                  v = &((*v)[t->index]);
283                  continue;
284              default:
285                  break;
286              }
287              if (unresolvedTokenIndex)
288                  *unresolvedTokenIndex = static_cast<size_t>(t - tokens_);
289              return 0;
290          }
291          return v;
292      }
293      const ValueType* Get(const ValueType& root, size_t* unresolvedTokenIndex = 0) const {
294          return Get(const_cast<ValueType&>(root), unresolvedTokenIndex);
295      }
296      ValueType& GetWithDefault(ValueType& root, const ValueType& defaultValue, typename ValueType::AllocatorType& allocator) const {
297          bool alreadyExist;
298          ValueType& v = Create(root, allocator, &alreadyExist);
299          return alreadyExist ? v : v.CopyFrom(defaultValue, allocator);
300      }
301      ValueType& GetWithDefault(ValueType& root, const Ch* defaultValue, typename ValueType::AllocatorType& allocator) const {
302          bool alreadyExist;
303          ValueType& v = Create(root, allocator, &alreadyExist);
304          return alreadyExist ? v : v.SetString(defaultValue, allocator);
305      }
306  #if RAPIDJSON_HAS_STDSTRING
307      ValueType& GetWithDefault(ValueType& root, const std::basic_string<Ch>& defaultValue, typename ValueType::AllocatorType& allocator) const {
308          bool alreadyExist;
309          ValueType& v = Create(root, allocator, &alreadyExist);
310          return alreadyExist ? v : v.SetString(defaultValue, allocator);
311      }
312  #endif
313      template <typename T>
314      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
315      GetWithDefault(ValueType& root, T defaultValue, typename ValueType::AllocatorType& allocator) const {
316          return GetWithDefault(root, ValueType(defaultValue).Move(), allocator);
317      }
318      template <typename stackAllocator>
319      ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const ValueType& defaultValue) const {
320          return GetWithDefault(document, defaultValue, document.GetAllocator());
321      }
322      template <typename stackAllocator>
323      ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const Ch* defaultValue) const {
324          return GetWithDefault(document, defaultValue, document.GetAllocator());
325      }
326  #if RAPIDJSON_HAS_STDSTRING
327      template <typename stackAllocator>
328      ValueType& GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const std::basic_string<Ch>& defaultValue) const {
329          return GetWithDefault(document, defaultValue, document.GetAllocator());
330      }
331  #endif
332      template <typename T, typename stackAllocator>
333      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
334      GetWithDefault(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, T defaultValue) const {
335          return GetWithDefault(document, defaultValue, document.GetAllocator());
336      }
337      ValueType& Set(ValueType& root, ValueType& value, typename ValueType::AllocatorType& allocator) const {
338          return Create(root, allocator) = value;
339      }
340      ValueType& Set(ValueType& root, const ValueType& value, typename ValueType::AllocatorType& allocator) const {
341          return Create(root, allocator).CopyFrom(value, allocator);
342      }
343      ValueType& Set(ValueType& root, const Ch* value, typename ValueType::AllocatorType& allocator) const {
344          return Create(root, allocator) = ValueType(value, allocator).Move();
345      }
346  #if RAPIDJSON_HAS_STDSTRING
347      ValueType& Set(ValueType& root, const std::basic_string<Ch>& value, typename ValueType::AllocatorType& allocator) const {
348          return Create(root, allocator) = ValueType(value, allocator).Move();
349      }
350  #endif
351      template <typename T>
352      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
353      Set(ValueType& root, T value, typename ValueType::AllocatorType& allocator) const {
354          return Create(root, allocator) = ValueType(value).Move();
355      }
356      template <typename stackAllocator>
357      ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, ValueType& value) const {
358          return Create(document) = value;
359      }
360      template <typename stackAllocator>
361      ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const ValueType& value) const {
362          return Create(document).CopyFrom(value, document.GetAllocator());
363      }
364      template <typename stackAllocator>
365      ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const Ch* value) const {
366          return Create(document) = ValueType(value, document.GetAllocator()).Move();
367      }
368  #if RAPIDJSON_HAS_STDSTRING
369      template <typename stackAllocator>
370      ValueType& Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, const std::basic_string<Ch>& value) const {
371          return Create(document) = ValueType(value, document.GetAllocator()).Move();
372      }
373  #endif
374      template <typename T, typename stackAllocator>
375      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&))
376          Set(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, T value) const {
377              return Create(document) = value;
378      }
379      ValueType& Swap(ValueType& root, ValueType& value, typename ValueType::AllocatorType& allocator) const {
380          return Create(root, allocator).Swap(value);
381      }
382      template <typename stackAllocator>
383      ValueType& Swap(GenericDocument<EncodingType, typename ValueType::AllocatorType, stackAllocator>& document, ValueType& value) const {
384          return Create(document).Swap(value);
385      }
386      bool Erase(ValueType& root) const {
387          RAPIDJSON_ASSERT(IsValid());
388          if (tokenCount_ == 0) 
389              return false;
390          ValueType* v = &root;
391          const Token* last = tokens_ + (tokenCount_ - 1);
392          for (const Token *t = tokens_; t != last; ++t) {
393              switch (v->GetType()) {
394              case kObjectType:
395                  {
396                      typename ValueType::MemberIterator m = v->FindMember(GenericValue<EncodingType>(GenericStringRef<Ch>(t->name, t->length)));
397                      if (m == v->MemberEnd())
398                          return false;
399                      v = &m->value;
400                  }
401                  break;
402              case kArrayType:
403                  if (t->index == kPointerInvalidIndex || t->index >= v->Size())
404                      return false;
405                  v = &((*v)[t->index]);
406                  break;
407              default:
408                  return false;
409              }
410          }
411          switch (v->GetType()) {
412          case kObjectType:
413              return v->EraseMember(GenericStringRef<Ch>(last->name, last->length));
414          case kArrayType:
415              if (last->index == kPointerInvalidIndex || last->index >= v->Size())
416                  return false;
417              v->Erase(v->Begin() + last->index);
418              return true;
419          default:
420              return false;
421          }
422      }
423  private:
424      Ch* CopyFromRaw(const GenericPointer& rhs, size_t extraToken = 0, size_t extraNameBufferSize = 0) {
425          if (!allocator_) 
426              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
427          size_t nameBufferSize = rhs.tokenCount_; 
428          for (Token *t = rhs.tokens_; t != rhs.tokens_ + rhs.tokenCount_; ++t)
429              nameBufferSize += t->length;
430          tokenCount_ = rhs.tokenCount_ + extraToken;
431          tokens_ = static_cast<Token *>(allocator_->Malloc(tokenCount_ * sizeof(Token) + (nameBufferSize + extraNameBufferSize) * sizeof(Ch)));
432          nameBuffer_ = reinterpret_cast<Ch *>(tokens_ + tokenCount_);
433          if (rhs.tokenCount_ > 0) {
434              std::memcpy(tokens_, rhs.tokens_, rhs.tokenCount_ * sizeof(Token));
435          }
436          if (nameBufferSize > 0) {
437              std::memcpy(nameBuffer_, rhs.nameBuffer_, nameBufferSize * sizeof(Ch));
438          }
439          std::ptrdiff_t diff = nameBuffer_ - rhs.nameBuffer_;
440          for (Token *t = tokens_; t != tokens_ + rhs.tokenCount_; ++t)
441              t->name += diff;
442          return nameBuffer_ + nameBufferSize;
443      }
444      bool NeedPercentEncode(Ch c) const {
445          return !((c >= '0' && c <= '9') || (c >= 'A' && c <='Z') || (c >= 'a' && c <= 'z') || c == '-' || c == '.' || c == '_' || c =='~');
446      }
447  #ifndef __clang__ 
448  #endif
449      void Parse(const Ch* source, size_t length) {
450          RAPIDJSON_ASSERT(source != NULL);
451          RAPIDJSON_ASSERT(nameBuffer_ == 0);
452          RAPIDJSON_ASSERT(tokens_ == 0);
453          if (!allocator_)
454              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
455          tokenCount_ = 0;
456          for (const Ch* s = source; s != source + length; s++)
457              if (*s == '/')
458                  tokenCount_++;
459          Token* token = tokens_ = static_cast<Token *>(allocator_->Malloc(tokenCount_ * sizeof(Token) + length * sizeof(Ch)));
460          Ch* name = nameBuffer_ = reinterpret_cast<Ch *>(tokens_ + tokenCount_);
461          size_t i = 0;
462          bool uriFragment = false;
463          if (source[i] == '#') {
464              uriFragment = true;
465              i++;
466          }
467          if (i != length && source[i] != '/') {
468              parseErrorCode_ = kPointerParseErrorTokenMustBeginWithSolidus;
469              goto error;
470          }
471          while (i < length) {
472              RAPIDJSON_ASSERT(source[i] == '/');
473              i++; 
474              token->name = name;
475              bool isNumber = true;
476              while (i < length && source[i] != '/') {
477                  Ch c = source[i];
478                  if (uriFragment) {
479                      if (c == '%') {
480                          PercentDecodeStream is(&source[i], source + length);
481                          GenericInsituStringStream<EncodingType> os(name);
482                          Ch* begin = os.PutBegin();
483                          if (!Transcoder<UTF8<>, EncodingType>().Validate(is, os) || !is.IsValid()) {
484                              parseErrorCode_ = kPointerParseErrorInvalidPercentEncoding;
485                              goto error;
486                          }
487                          size_t len = os.PutEnd(begin);
488                          i += is.Tell() - 1;
489                          if (len == 1)
490                              c = *name;
491                          else {
492                              name += len;
493                              isNumber = false;
494                              i++;
495                              continue;
496                          }
497                      }
498                      else if (NeedPercentEncode(c)) {
499                          parseErrorCode_ = kPointerParseErrorCharacterMustPercentEncode;
500                          goto error;
501                      }
502                  }
503                  i++;
504                  if (c == '~') {
505                      if (i < length) {
506                          c = source[i];
507                          if (c == '0')       c = '~';
508                          else if (c == '1')  c = '/';
509                          else {
510                              parseErrorCode_ = kPointerParseErrorInvalidEscape;
511                              goto error;
512                          }
513                          i++;
514                      }
515                      else {
516                          parseErrorCode_ = kPointerParseErrorInvalidEscape;
517                          goto error;
518                      }
519                  }
520                  if (c < '0' || c > '9')
521                      isNumber = false;
522                  *name++ = c;
523              }
524              token->length = static_cast<SizeType>(name - token->name);
525              if (token->length == 0)
526                  isNumber = false;
527              *name++ = '\0'; 
528              if (isNumber && token->length > 1 && token->name[0] == '0')
529                  isNumber = false;
530              SizeType n = 0;
531              if (isNumber) {
532                  for (size_t j = 0; j < token->length; j++) {
533                      SizeType m = n * 10 + static_cast<SizeType>(token->name[j] - '0');
534                      if (m < n) {   
535                          isNumber = false;
536                          break;
537                      }
538                      n = m;
539                  }
540              }
541              token->index = isNumber ? n : kPointerInvalidIndex;
542              token++;
543          }
544          RAPIDJSON_ASSERT(name <= nameBuffer_ + length); 
545          parseErrorCode_ = kPointerParseErrorNone;
546          return;
547      error:
548          Allocator::Free(tokens_);
549          nameBuffer_ = 0;
550          tokens_ = 0;
551          tokenCount_ = 0;
552          parseErrorOffset_ = i;
553          return;
554      }
555      template<bool uriFragment, typename OutputStream>
556      bool Stringify(OutputStream& os) const {
557          RAPIDJSON_ASSERT(IsValid());
558          if (uriFragment)
559              os.Put('#');
560          for (Token *t = tokens_; t != tokens_ + tokenCount_; ++t) {
561              os.Put('/');
562              for (size_t j = 0; j < t->length; j++) {
563                  Ch c = t->name[j];
564                  if (c == '~') {
565                      os.Put('~');
566                      os.Put('0');
567                  }
568                  else if (c == '/') {
569                      os.Put('~');
570                      os.Put('1');
571                  }
572                  else if (uriFragment && NeedPercentEncode(c)) {
573                      GenericStringStream<typename ValueType::EncodingType> source(&t->name[j]);
574                      PercentEncodeStream<OutputStream> target(os);
575                      if (!Transcoder<EncodingType, UTF8<> >().Validate(source, target))
576                          return false;
577                      j += source.Tell() - 1;
578                  }
579                  else
580                      os.Put(c);
581              }
582          }
583          return true;
584      }
585      class PercentDecodeStream {
586      public:
587          typedef typename ValueType::Ch Ch;
588          PercentDecodeStream(const Ch* source, const Ch* end) : src_(source), head_(source), end_(end), valid_(true) {}
589          Ch Take() {
590              if (*src_ != '%' || src_ + 3 > end_) { 
591                  valid_ = false;
592                  return 0;
593              }
594              src_++;
595              Ch c = 0;
596              for (int j = 0; j < 2; j++) {
597                  c = static_cast<Ch>(c << 4);
598                  Ch h = *src_;
599                  if      (h >= '0' && h <= '9') c = static_cast<Ch>(c + h - '0');
600                  else if (h >= 'A' && h <= 'F') c = static_cast<Ch>(c + h - 'A' + 10);
601                  else if (h >= 'a' && h <= 'f') c = static_cast<Ch>(c + h - 'a' + 10);
602                  else {
603                      valid_ = false;
604                      return 0;
605                  }
606                  src_++;
607              }
608              return c;
609          }
610          size_t Tell() const { return static_cast<size_t>(src_ - head_); }
611          bool IsValid() const { return valid_; }
612      private:
613          const Ch* src_;     
614          const Ch* head_;    
615          const Ch* end_;     
616          bool valid_;        
617      };
618      template <typename OutputStream>
619      class PercentEncodeStream {
620      public:
621          PercentEncodeStream(OutputStream& os) : os_(os) {}
622          void Put(char c) { 
623              unsigned char u = static_cast<unsigned char>(c);
624              static const char hexDigits[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
625              os_.Put('%');
626              os_.Put(static_cast<typename OutputStream::Ch>(hexDigits[u >> 4]));
627              os_.Put(static_cast<typename OutputStream::Ch>(hexDigits[u & 15]));
628          }
629      private:
630          OutputStream& os_;
631      };
632      Allocator* allocator_;                  
633      Allocator* ownAllocator_;               
634      Ch* nameBuffer_;                        
635      Token* tokens_;                         
636      size_t tokenCount_;                     
637      size_t parseErrorOffset_;               
638      PointerParseErrorCode parseErrorCode_;  
639  };
640  typedef GenericPointer<Value> Pointer;
641  template <typename T>
642  typename T::ValueType& CreateValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::AllocatorType& a) {
643      return pointer.Create(root, a);
644  }
645  template <typename T, typename CharType, size_t N>
646  typename T::ValueType& CreateValueByPointer(T& root, const CharType(&source)[N], typename T::AllocatorType& a) {
647      return GenericPointer<typename T::ValueType>(source, N - 1).Create(root, a);
648  }
649  template <typename DocumentType>
650  typename DocumentType::ValueType& CreateValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer) {
651      return pointer.Create(document);
652  }
653  template <typename DocumentType, typename CharType, size_t N>
654  typename DocumentType::ValueType& CreateValueByPointer(DocumentType& document, const CharType(&source)[N]) {
655      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Create(document);
656  }
657  template <typename T>
658  typename T::ValueType* GetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, size_t* unresolvedTokenIndex = 0) {
659      return pointer.Get(root, unresolvedTokenIndex);
660  }
661  template <typename T>
662  const typename T::ValueType* GetValueByPointer(const T& root, const GenericPointer<typename T::ValueType>& pointer, size_t* unresolvedTokenIndex = 0) {
663      return pointer.Get(root, unresolvedTokenIndex);
664  }
665  template <typename T, typename CharType, size_t N>
666  typename T::ValueType* GetValueByPointer(T& root, const CharType (&source)[N], size_t* unresolvedTokenIndex = 0) {
667      return GenericPointer<typename T::ValueType>(source, N - 1).Get(root, unresolvedTokenIndex);
668  }
669  template <typename T, typename CharType, size_t N>
670  const typename T::ValueType* GetValueByPointer(const T& root, const CharType(&source)[N], size_t* unresolvedTokenIndex = 0) {
671      return GenericPointer<typename T::ValueType>(source, N - 1).Get(root, unresolvedTokenIndex);
672  }
673  template <typename T>
674  typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::ValueType& defaultValue, typename T::AllocatorType& a) {
675      return pointer.GetWithDefault(root, defaultValue, a);
676  }
677  template <typename T>
678  typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::Ch* defaultValue, typename T::AllocatorType& a) {
679      return pointer.GetWithDefault(root, defaultValue, a);
680  }
681  #if RAPIDJSON_HAS_STDSTRING
682  template <typename T>
683  typename T::ValueType& GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, const std::basic_string<typename T::Ch>& defaultValue, typename T::AllocatorType& a) {
684      return pointer.GetWithDefault(root, defaultValue, a);
685  }
686  #endif
687  template <typename T, typename T2>
688  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
689  GetValueByPointerWithDefault(T& root, const GenericPointer<typename T::ValueType>& pointer, T2 defaultValue, typename T::AllocatorType& a) {
690      return pointer.GetWithDefault(root, defaultValue, a);
691  }
692  template <typename T, typename CharType, size_t N>
693  typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const typename T::ValueType& defaultValue, typename T::AllocatorType& a) {
694      return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
695  }
696  template <typename T, typename CharType, size_t N>
697  typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const typename T::Ch* defaultValue, typename T::AllocatorType& a) {
698      return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
699  }
700  #if RAPIDJSON_HAS_STDSTRING
701  template <typename T, typename CharType, size_t N>
702  typename T::ValueType& GetValueByPointerWithDefault(T& root, const CharType(&source)[N], const std::basic_string<typename T::Ch>& defaultValue, typename T::AllocatorType& a) {
703      return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
704  }
705  #endif
706  template <typename T, typename CharType, size_t N, typename T2>
707  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
708  GetValueByPointerWithDefault(T& root, const CharType(&source)[N], T2 defaultValue, typename T::AllocatorType& a) {
709      return GenericPointer<typename T::ValueType>(source, N - 1).GetWithDefault(root, defaultValue, a);
710  }
711  template <typename DocumentType>
712  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::ValueType& defaultValue) {
713      return pointer.GetWithDefault(document, defaultValue);
714  }
715  template <typename DocumentType>
716  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::Ch* defaultValue) {
717      return pointer.GetWithDefault(document, defaultValue);
718  }
719  #if RAPIDJSON_HAS_STDSTRING
720  template <typename DocumentType>
721  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const std::basic_string<typename DocumentType::Ch>& defaultValue) {
722      return pointer.GetWithDefault(document, defaultValue);
723  }
724  #endif
725  template <typename DocumentType, typename T2>
726  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
727  GetValueByPointerWithDefault(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, T2 defaultValue) {
728      return pointer.GetWithDefault(document, defaultValue);
729  }
730  template <typename DocumentType, typename CharType, size_t N>
731  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const typename DocumentType::ValueType& defaultValue) {
732      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
733  }
734  template <typename DocumentType, typename CharType, size_t N>
735  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const typename DocumentType::Ch* defaultValue) {
736      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
737  }
738  #if RAPIDJSON_HAS_STDSTRING
739  template <typename DocumentType, typename CharType, size_t N>
740  typename DocumentType::ValueType& GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], const std::basic_string<typename DocumentType::Ch>& defaultValue) {
741      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
742  }
743  #endif
744  template <typename DocumentType, typename CharType, size_t N, typename T2>
745  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
746  GetValueByPointerWithDefault(DocumentType& document, const CharType(&source)[N], T2 defaultValue) {
747      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).GetWithDefault(document, defaultValue);
748  }
749  template <typename T>
750  typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::ValueType& value, typename T::AllocatorType& a) {
751      return pointer.Set(root, value, a);
752  }
753  template <typename T>
754  typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::ValueType& value, typename T::AllocatorType& a) {
755      return pointer.Set(root, value, a);
756  }
757  template <typename T>
758  typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const typename T::Ch* value, typename T::AllocatorType& a) {
759      return pointer.Set(root, value, a);
760  }
761  #if RAPIDJSON_HAS_STDSTRING
762  template <typename T>
763  typename T::ValueType& SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, const std::basic_string<typename T::Ch>& value, typename T::AllocatorType& a) {
764      return pointer.Set(root, value, a);
765  }
766  #endif
767  template <typename T, typename T2>
768  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
769  SetValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, T2 value, typename T::AllocatorType& a) {
770      return pointer.Set(root, value, a);
771  }
772  template <typename T, typename CharType, size_t N>
773  typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], typename T::ValueType& value, typename T::AllocatorType& a) {
774      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
775  }
776  template <typename T, typename CharType, size_t N>
777  typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const typename T::ValueType& value, typename T::AllocatorType& a) {
778      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
779  }
780  template <typename T, typename CharType, size_t N>
781  typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const typename T::Ch* value, typename T::AllocatorType& a) {
782      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
783  }
784  #if RAPIDJSON_HAS_STDSTRING
785  template <typename T, typename CharType, size_t N>
786  typename T::ValueType& SetValueByPointer(T& root, const CharType(&source)[N], const std::basic_string<typename T::Ch>& value, typename T::AllocatorType& a) {
787      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
788  }
789  #endif
790  template <typename T, typename CharType, size_t N, typename T2>
791  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename T::ValueType&))
792  SetValueByPointer(T& root, const CharType(&source)[N], T2 value, typename T::AllocatorType& a) {
793      return GenericPointer<typename T::ValueType>(source, N - 1).Set(root, value, a);
794  }
795  template <typename DocumentType>
796  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, typename DocumentType::ValueType& value) {
797      return pointer.Set(document, value);
798  }
799  template <typename DocumentType>
800  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::ValueType& value) {
801      return pointer.Set(document, value);
802  }
803  template <typename DocumentType>
804  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const typename DocumentType::Ch* value) {
805      return pointer.Set(document, value);
806  }
807  #if RAPIDJSON_HAS_STDSTRING
808  template <typename DocumentType>
809  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, const std::basic_string<typename DocumentType::Ch>& value) {
810      return pointer.Set(document, value);
811  }
812  #endif
813  template <typename DocumentType, typename T2>
814  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
815  SetValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, T2 value) {
816      return pointer.Set(document, value);
817  }
818  template <typename DocumentType, typename CharType, size_t N>
819  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], typename DocumentType::ValueType& value) {
820      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
821  }
822  template <typename DocumentType, typename CharType, size_t N>
823  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const typename DocumentType::ValueType& value) {
824      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
825  }
826  template <typename DocumentType, typename CharType, size_t N>
827  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const typename DocumentType::Ch* value) {
828      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
829  }
830  #if RAPIDJSON_HAS_STDSTRING
831  template <typename DocumentType, typename CharType, size_t N>
832  typename DocumentType::ValueType& SetValueByPointer(DocumentType& document, const CharType(&source)[N], const std::basic_string<typename DocumentType::Ch>& value) {
833      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
834  }
835  #endif
836  template <typename DocumentType, typename CharType, size_t N, typename T2>
837  RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T2>, internal::IsGenericValue<T2> >), (typename DocumentType::ValueType&))
838  SetValueByPointer(DocumentType& document, const CharType(&source)[N], T2 value) {
839      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Set(document, value);
840  }
841  template <typename T>
842  typename T::ValueType& SwapValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer, typename T::ValueType& value, typename T::AllocatorType& a) {
843      return pointer.Swap(root, value, a);
844  }
845  template <typename T, typename CharType, size_t N>
846  typename T::ValueType& SwapValueByPointer(T& root, const CharType(&source)[N], typename T::ValueType& value, typename T::AllocatorType& a) {
847      return GenericPointer<typename T::ValueType>(source, N - 1).Swap(root, value, a);
848  }
849  template <typename DocumentType>
850  typename DocumentType::ValueType& SwapValueByPointer(DocumentType& document, const GenericPointer<typename DocumentType::ValueType>& pointer, typename DocumentType::ValueType& value) {
851      return pointer.Swap(document, value);
852  }
853  template <typename DocumentType, typename CharType, size_t N>
854  typename DocumentType::ValueType& SwapValueByPointer(DocumentType& document, const CharType(&source)[N], typename DocumentType::ValueType& value) {
855      return GenericPointer<typename DocumentType::ValueType>(source, N - 1).Swap(document, value);
856  }
857  template <typename T>
858  bool EraseValueByPointer(T& root, const GenericPointer<typename T::ValueType>& pointer) {
859      return pointer.Erase(root);
860  }
861  template <typename T, typename CharType, size_t N>
862  bool EraseValueByPointer(T& root, const CharType(&source)[N]) {
863      return GenericPointer<typename T::ValueType>(source, N - 1).Erase(root);
864  }
865  RAPIDJSON_NAMESPACE_END
866  #if defined(__clang__) || defined(_MSC_VER)
867  RAPIDJSON_DIAG_POP
868  #endif
869  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-uri.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-pointer.h</div>
                </div>
                <div class="column column_space"><pre><code>18      GenericUri(Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
19      }
20      GenericUri(const Ch* uri, SizeType len, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
21          Parse(uri, len);
22      }
23      GenericUri(const Ch* uri, Allocator* allocator = 0) : uri_(), base_(), scheme_(), auth_(), path_(), query_(), frag_(), allocator_(allocator), ownAllocator_() {
24          Parse(uri, internal::StrLen<Ch>(uri));
25      }
</pre></code></div>
                <div class="column column_space"><pre><code>33      GenericPointer(Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {}
34      explicit GenericPointer(const Ch* source, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
35          Parse(source, internal::StrLen(source));
36      }
37  #if RAPIDJSON_HAS_STDSTRING
38      explicit GenericPointer(const std::basic_string<Ch>& source, Allocator* allocator = 0) : allocator_(allocator), ownAllocator_(), nameBuffer_(), tokens_(), tokenCount_(), parseErrorOffset_(), parseErrorCode_(kPointerParseErrorNone) {
39          Parse(source.c_str(), source.size());
40      }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    