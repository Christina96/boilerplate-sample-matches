<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-gtk-certificate-view.c &amp; inf-xmpp-connection.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-gtk-certificate-view.c &amp; inf-xmpp-connection.c
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-gtk-certificate-view.c (21.6%)<th>inf-xmpp-connection.c (1.0787055%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(137-160)<td><a href="#" name="0">(3828-3854)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(343-359)<td><a href="#" name="1">(3007-3019)</a><td align="center"><font color="#ec0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-certificate-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfgtk/inf-gtk-certificate-view.h&gt;
#include &lt;libinfinity/common/inf-cert-util.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;time.h&gt;
typedef struct _InfGtkCertificateViewPrivate InfGtkCertificateViewPrivate;
struct _InfGtkCertificateViewPrivate {
  gnutls_x509_crt_t certificate;
  GtkWidget* subject_common_name;
  GtkWidget* subject_organization;
  GtkWidget* subject_organizational_unit;
  GtkWidget* subject_serial_number;
  GtkWidget* issuer_common_name;
  GtkWidget* issuer_organization;
  GtkWidget* issuer_organizational_unit;
  GtkWidget* activation_time;
  GtkWidget* expiration_time;
  GtkWidget* sha1_fingerprint;
  GtkWidget* sha256_fingerprint;
  GtkWidget* signature_algorithm;
};
enum {
  PROP_0,
  PROP_CERTIFICATE
};
#define INF_GTK_CERTIFICATE_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_CERTIFICATE_VIEW, InfGtkCertificateViewPrivate))
G_DEFINE_TYPE_WITH_CODE(InfGtkCertificateView, inf_gtk_certificate_view, GTK_TYPE_GRID,
  G_ADD_PRIVATE(InfGtkCertificateView))
static void
inf_gtk_certificate_view_set_label(GtkLabel* label,
                                   const gchar* value)
{
  const gchar* text;
  gchar* markup;
  if(value != NULL)
  {
    gtk_label_set_text(label, value);
  }
  else
  {
    text = _("&lt;Not part of certificate&gt;");
    markup = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", text);
    gtk_label_set_markup(label, markup);
    g_free(markup);
  }
}
static void
inf_gtk_certificate_view_set_label_dn_by_oid(gnutls_x509_crt_t cert,
                                             GtkLabel* label,
                                             const char* oid)
{
  gchar* value;
  value = inf_cert_util_get_dn_by_oid(cert, oid, 0);
  inf_gtk_certificate_view_set_label(label, value);
  g_free(value);
}
static void
inf_gtk_certificate_view_set_label_issuer_dn_by_oid(gnutls_x509_crt_t cert,
                                                    GtkLabel* label,
                                                    const gchar* oid)
{
  gchar* value;
  value = inf_cert_util_get_issuer_dn_by_oid(cert, oid, 0);
  inf_gtk_certificate_view_set_label(label, value);
  g_free(value);
}
static void
inf_gtk_certificate_view_init(InfGtkCertificateView* view)
{
  InfGtkCertificateViewPrivate* priv;
  PangoFontDescription* monospace_desc;
  gint size;
  priv = INF_GTK_CERTIFICATE_VIEW_PRIVATE(view);
  priv-&gt;certificate = NULL;
  gtk_widget_init_template(GTK_WIDGET(view));
}
static void
inf_gtk_certificate_view_set_property(GObject* object,
                                      guint prop_id,
                                      const GValue* value,
                                      GParamSpec* pspec)
{
  InfGtkCertificateView* view;
  InfGtkCertificateViewPrivate* priv;
  view = INF_GTK_CERTIFICATE_VIEW(object);
  priv = INF_GTK_CERTIFICATE_VIEW_PRIVATE(view);
  switch(prop_id)
  {
  case PROP_CERTIFICATE:
    inf_gtk_certificate_view_set_certificate(
      view,
<a name="0"></a>      (gnutls_x509_crt_t)g_value_get_pointer(value)
    );
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_gtk_certificate_view_get_property(GObject* object,
                                      guint prop_id,
                                      GValue* value,
                                      GParamSpec* pspec)
{
  InfGtkCertificateView* view;
  InfGtkCertificateViewPrivate* priv;
  view = INF_GTK_CERTIFICATE_VIEW(object);
  priv = INF_GTK_CERTIFICATE_VIEW_PRIVATE(view);
  switch(prop_id)
  {
  case PROP_CERTIFICATE:
    g_value_set_pointer(value, priv-&gt;certificate);
    break;</b></font>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_gtk_certificate_view_class_init(
  InfGtkCertificateViewClass* certificate_view_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(certificate_view_class);
  object_class-&gt;set_property = inf_gtk_certificate_view_set_property;
  object_class-&gt;get_property = inf_gtk_certificate_view_get_property;
  gtk_widget_class_set_template_from_resource(
    GTK_WIDGET_CLASS(certificate_view_class),
    "/de/0x539/libinfgtk/ui/infgtkcertificateview.ui"
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    subject_common_name
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    subject_organization
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    subject_organizational_unit
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    subject_serial_number
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    issuer_common_name
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    issuer_organization
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    issuer_organizational_unit
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    activation_time
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    expiration_time
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    sha1_fingerprint
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    sha256_fingerprint
  );
  gtk_widget_class_bind_template_child_private(
    GTK_WIDGET_CLASS(certificate_view_class),
    InfGtkCertificateView,
    signature_algorithm
  );
  g_object_class_install_property(
    object_class,
    PROP_CERTIFICATE,
    g_param_spec_pointer(
      "certificate",
      "Certificate",
      "The certificate to show",
      G_PARAM_READWRITE
    )
  );
}
GtkWidget*
inf_gtk_certificate_view_new(void)
{
  GObject* object;
  object = g_object_new(INF_GTK_TYPE_CERTIFICATE_VIEW, NULL);
  return GTK_WIDGET(object);
}
GtkWidget*
inf_gtk_certificate_view_new_with_certificate(gnutls_x509_crt_t cert)
{
  GObject* object;
  object = g_object_new(
    INF_GTK_TYPE_CERTIFICATE_VIEW,
    "certificate", cert,
    NULL
  );
  return GTK_WIDGET(object);
}
void
inf_gtk_certificate_view_set_certificate(InfGtkCertificateView* view,
                                         gnutls_x509_crt_t cert)
{
  InfGtkCertificateViewPrivate* priv;
  gchar* value;
  int algo;
  g_return_if_fail(INF_GTK_IS_CERTIFICATE_VIEW(view));
  priv = INF_GTK_CERTIFICATE_VIEW_PRIVATE(view);
<a name="1"></a>  priv-&gt;certificate = cert;
  if(cert == NULL)
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {
    gtk_label_set_text(GTK_LABEL(priv-&gt;subject_common_name), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;subject_organization), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;subject_organizational_unit), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;subject_serial_number), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;issuer_common_name), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;issuer_organization), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;issuer_organizational_unit), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;activation_time), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;expiration_time), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;sha1_fingerprint), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;sha256_fingerprint), NULL);
    gtk_label_set_text(GTK_LABEL(priv-&gt;signature_algorithm), NULL);</b></font>
  }
  else
  {
    inf_gtk_certificate_view_set_label_dn_by_oid(
      cert,
      GTK_LABEL(priv-&gt;subject_common_name),
      GNUTLS_OID_X520_COMMON_NAME
    );
    inf_gtk_certificate_view_set_label_dn_by_oid(
      cert,
      GTK_LABEL(priv-&gt;subject_organization),
      GNUTLS_OID_X520_ORGANIZATION_NAME
    );
    inf_gtk_certificate_view_set_label_dn_by_oid(
      cert,
      GTK_LABEL(priv-&gt;subject_organizational_unit),
      GNUTLS_OID_X520_ORGANIZATIONAL_UNIT_NAME
    );
    value = inf_cert_util_get_serial_number(cert);
    inf_gtk_certificate_view_set_label(
      GTK_LABEL(priv-&gt;subject_serial_number),
      value
    );
    g_free(value);
    inf_gtk_certificate_view_set_label_issuer_dn_by_oid(
      cert,
      GTK_LABEL(priv-&gt;issuer_common_name),
      GNUTLS_OID_X520_COMMON_NAME
    );
    inf_gtk_certificate_view_set_label_issuer_dn_by_oid(
      cert,
      GTK_LABEL(priv-&gt;issuer_organization),
      GNUTLS_OID_X520_ORGANIZATION_NAME
    );
    inf_gtk_certificate_view_set_label_issuer_dn_by_oid(
      cert,
      GTK_LABEL(priv-&gt;issuer_organizational_unit),
      GNUTLS_OID_X520_ORGANIZATIONAL_UNIT_NAME
    );
    value = inf_cert_util_get_activation_time(cert);
    inf_gtk_certificate_view_set_label(
      GTK_LABEL(priv-&gt;activation_time),
      value
    );
    g_free(value);
    value = inf_cert_util_get_expiration_time(cert);
    inf_gtk_certificate_view_set_label(
      GTK_LABEL(priv-&gt;expiration_time),
      value
    );
    g_free(value);
    value = inf_cert_util_get_fingerprint(cert, GNUTLS_DIG_SHA1);
    inf_gtk_certificate_view_set_label(
      GTK_LABEL(priv-&gt;sha1_fingerprint),
      value
    );
    g_free(value);
    value = inf_cert_util_get_fingerprint(cert, GNUTLS_DIG_SHA256);
    inf_gtk_certificate_view_set_label(
      GTK_LABEL(priv-&gt;sha256_fingerprint),
      value
    );
    g_free(value);
    algo = gnutls_x509_crt_get_signature_algorithm(cert);
    if(algo &lt; 0)
    {
      inf_gtk_certificate_view_set_label(
        GTK_LABEL(priv-&gt;signature_algorithm),
        gnutls_strerror(algo)
      );
    }
    else
    {
      inf_gtk_certificate_view_set_label(
        GTK_LABEL(priv-&gt;signature_algorithm),
        gnutls_sign_get_name(algo)
      );
    }
  }
  g_object_notify(G_OBJECT(view), "certificate");
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-xmpp-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
#include &lt;libinfinity/common/inf-xml-connection.h&gt;
#include &lt;libinfinity/common/inf-xml-util.h&gt;
#include &lt;libinfinity/common/inf-ip-address.h&gt;
#include &lt;libinfinity/common/inf-error.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;libinfinity/inf-define-enum.h&gt;
#include &lt;gnutls/x509.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include "config.h"
static const GEnumValue inf_xmpp_connection_site_values[] = {
  {
    INF_XMPP_CONNECTION_CLIENT,
    "INF_XMPP_CONNECTION_CLIENT",
    "client"
  }, {
    INF_XMPP_CONNECTION_SERVER,
    "INF_XMPP_CONNECTION_SERVER",
    "server"
  }, {
    0,
    NULL,
    NULL
  }
};
static const GEnumValue inf_xmpp_connection_security_policy_values[] = {
  {
    INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
    "INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED",
    "only-unsecured"
  }, {
    INF_XMPP_CONNECTION_SECURITY_ONLY_TLS,
    "INF_XMPP_CONNECTION_SECURITY_ONLY_TLS",
    "only-tls"
  }, {
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_UNSECURED,
    "INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_UNSECURED",
    "both-prefer-unsecured"
  }, {
    INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
    "INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS",
    "both-prefer-tls"
  }, {
    0,
    NULL,
    NULL
  }
};
gboolean INF_XMPP_CONNECTION_PRINT_TRAFFIC = FALSE;
typedef enum _InfXmppConnectionStatus {
  INF_XMPP_CONNECTION_CONNECTING,
  INF_XMPP_CONNECTION_CONNECTED,
  INF_XMPP_CONNECTION_AUTH_CONNECTED,
  INF_XMPP_CONNECTION_INITIATED,
  INF_XMPP_CONNECTION_AUTH_INITIATED,
  INF_XMPP_CONNECTION_AWAITING_FEATURES,
  INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES,
  INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED,
  INF_XMPP_CONNECTION_HANDSHAKING,
  INF_XMPP_CONNECTION_AUTHENTICATING,
  INF_XMPP_CONNECTION_READY,
  INF_XMPP_CONNECTION_CLOSING_STREAM,
  INF_XMPP_CONNECTION_CLOSING_GNUTLS,
  INF_XMPP_CONNECTION_CLOSED
} InfXmppConnectionStatus;
typedef void(*InfXmppConnectionSentFunc)(InfXmppConnection* xmpp,
                                         gpointer user_data);
typedef void(*InfXmppConnectionFreeFunc)(InfXmppConnection* xmpp,
                                         gpointer user_data);
typedef struct _InfXmppConnectionMessage InfXmppConnectionMessage;
struct _InfXmppConnectionMessage {
  InfXmppConnectionMessage* next;
  guint position;
  gboolean sent;
  InfXmppConnectionSentFunc sent_func;
  InfXmppConnectionFreeFunc free_func;
  gpointer user_data;
};
typedef struct _InfXmppConnectionPrivate InfXmppConnectionPrivate;
struct _InfXmppConnectionPrivate {
  InfTcpConnection* tcp;
  InfXmppConnectionSite site;
  gchar* local_hostname;
  gchar* remote_hostname;
  InfXmppConnectionSecurityPolicy security_policy;
  InfXmppConnectionStatus status;
  gnutls_certificate_request_t certificate_request;
  InfXmppConnectionCrtCallback certificate_callback;
  gpointer certificate_callback_user_data;
  GDestroyNotify certificate_callback_notify;
  guint position;
  xmlDocPtr doc;
  xmlBufferPtr buf;
  InfXmppConnectionMessage* messages;
  InfXmppConnectionMessage* last_message;
  guint parsing;   xmlParserCtxtPtr parser;
  xmlNodePtr root;
  xmlNodePtr cur;
  gnutls_session_t session;
  InfCertificateCredentials* creds;
  gnutls_x509_crt_t own_cert;
  InfCertificateChain* peer_cert;
  const gchar* pull_data;
  gsize pull_len;
  InfSaslContext* sasl_context;
  InfSaslContext* sasl_own_context;
  InfSaslContextSession* sasl_session;
  gchar* sasl_local_mechanisms;
  gchar* sasl_remote_mechanisms;
  GError* sasl_error;
};
enum {
  PROP_0,
  PROP_TCP,
  PROP_SITE,
  PROP_LOCAL_HOSTNAME,
  PROP_REMOTE_HOSTNAME,
  PROP_SECURITY_POLICY,
  PROP_TLS_ENABLED,
  PROP_CREDENTIALS,
  PROP_SASL_CONTEXT,
  PROP_SASL_MECHANISMS,
  PROP_STATUS,
  PROP_NETWORK,
  PROP_LOCAL_ID,
  PROP_REMOTE_ID,
  PROP_LOCAL_CERTIFICATE,
  PROP_REMOTE_CERTIFICATE
};
#define INF_XMPP_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_XMPP_CONNECTION, InfXmppConnectionPrivate))
static GQuark inf_xmpp_connection_stream_error_quark;
static GQuark inf_xmpp_connection_auth_error_quark;
static void inf_xmpp_connection_xml_connection_iface_init(InfXmlConnectionInterface* iface);
INF_DEFINE_ENUM_TYPE(InfXmppConnectionSite, inf_xmpp_connection_site, inf_xmpp_connection_site_values)
INF_DEFINE_ENUM_TYPE(InfXmppConnectionSecurityPolicy, inf_xmpp_connection_security_policy, inf_xmpp_connection_security_policy_values)
G_DEFINE_TYPE_WITH_CODE(InfXmppConnection, inf_xmpp_connection, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfXmppConnection)
  G_IMPLEMENT_INTERFACE(INF_TYPE_XML_CONNECTION, inf_xmpp_connection_xml_connection_iface_init))
typedef struct _InfXmppConnectionErrorCondition {
  const gchar* condition;
  guint code;
} InfXmppConnectionErrorCondition;
static const InfXmppConnectionErrorCondition
  inf_xmpp_connection_stream_error_conditions[] = {
    {
      "bad-format",
      INF_XMPP_CONNECTION_STREAM_ERROR_BAD_FORMAT
    }, {
      "bad-namespace-prefix",
      INF_XMPP_CONNECTION_STREAM_ERROR_BAD_NAMESPACE_PREFIX
    }, {
      "conflict",
      INF_XMPP_CONNECTION_STREAM_ERROR_CONFLICT
    }, {
      "connection-timeout",
      INF_XMPP_CONNECTION_STREAM_ERROR_CONNECTION_TIMEOUT
    }, {
      "host-gone",
      INF_XMPP_CONNECTION_STREAM_ERROR_HOST_GONE
    }, {
      "host-unknown",
      INF_XMPP_CONNECTION_STREAM_ERROR_HOST_UNKNOWN
    }, {
      "improper-addressing",
      INF_XMPP_CONNECTION_STREAM_ERROR_IMPROPER_ADDRESSING
    }, {
      "internal-server-error",
      INF_XMPP_CONNECTION_STREAM_ERROR_INTERNAL_SERVER_ERROR
    }, {
      "invalid-from",
      INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_FROM
    }, {
      "invalid-id",
      INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_ID
    }, {
      "invalid-namespace",
      INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_NAMESPACE
    }, {
      "invalid-xml",
      INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_XML
    }, {
      "not-authorized",
      INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED
    }, {
      "policy-violation",
      INF_XMPP_CONNECTION_STREAM_ERROR_POLICY_VIOLATION
    }, {
      "remote-connection-failed",
      INF_XMPP_CONNECTION_STREAM_ERROR_REMOTE_CONNECTION_FAILED
    }, {
      "resource-constraint",
      INF_XMPP_CONNECTION_STREAM_ERROR_RESOURCE_CONSTRAINT
    }, {
      "restricted-xml",
      INF_XMPP_CONNECTION_STREAM_ERROR_RESTRICTED_XML
    }, {
      "see-other-host",
      INF_XMPP_CONNECTION_STREAM_ERROR_SEE_OTHER_HOST
    }, {
      "system-shutdown",
      INF_XMPP_CONNECTION_STREAM_ERROR_SYSTEM_SHUTDOWN
    }, {
      "undefined-condition",
      INF_XMPP_CONNECTION_STREAM_ERROR_UNDEFINED_CONDITION
    }, {
      "undefined-condition",
      INF_XMPP_CONNECTION_STREAM_ERROR_FAILED
    }, {
      "unsupported-encoding",
      INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_ENCODING
    }, {
      "unsupported-stanza-type",
      INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_STANZA_TYPE
    }, {
      "unsupported-version",
      INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_VERSION
    }, {
      "xml-not-well-formed",
      INF_XMPP_CONNECTION_STREAM_ERROR_XML_NOT_WELL_FORMED
    }, {
      NULL,
      0
    }
  };
static const InfXmppConnectionErrorCondition
  inf_xmpp_connection_auth_error_conditions[] = {
    {
      "aborted",
      INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED
    }, {
      "incorrect-encoding",
      INF_XMPP_CONNECTION_AUTH_ERROR_INCORRECT_ENCODING
    }, {
      "invalid-authzid",
      INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_AUTHZID
    }, {
      "invalid-mechanism",
      INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM
    }, {
      "mechanism-too-weak",
      INF_XMPP_CONNECTION_AUTH_ERROR_MECHANISM_TOO_WEAK
    }, {
      "not-authorized",
      INF_XMPP_CONNECTION_AUTH_ERROR_NOT_AUTHORIZED
    }, {
      "temporary-auth-failure",
      INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE
    }, {
      NULL,
      0
    }
  };
static InfXmppConnectionStreamError
inf_xmpp_connection_stream_error_from_condition(const gchar* condition)
{
  const InfXmppConnectionErrorCondition* cond;
  for(cond = inf_xmpp_connection_stream_error_conditions;
      cond-&gt;condition != NULL;
      ++ cond)
  {
    if(strcmp(condition, cond-&gt;condition) == 0)
      return cond-&gt;code;
  }
  return INF_XMPP_CONNECTION_STREAM_ERROR_FAILED;
}
static const gchar*
inf_xmpp_connection_stream_error_to_condition(InfXmppConnectionStreamError code)
{
  const InfXmppConnectionErrorCondition* cond;
  for(cond = inf_xmpp_connection_stream_error_conditions;
      cond-&gt;condition != NULL;
      ++ cond)
  {
    if(code == cond-&gt;code)
      return cond-&gt;condition;
  }
  g_assert_not_reached();
  return NULL;
}
static const gchar*
inf_xmpp_connection_stream_strerror(InfXmppConnectionStreamError code)
{
  switch(code)
  {
  case INF_XMPP_CONNECTION_STREAM_ERROR_BAD_FORMAT:
    return _("The entity has sent XML that cannot be processed");
  case INF_XMPP_CONNECTION_STREAM_ERROR_BAD_NAMESPACE_PREFIX:
    return _("The entity has sent a namespace prefix that is unsupported, or "
             "has sent no namespace prefix on an element that requires such "
             "a prefix");
  case INF_XMPP_CONNECTION_STREAM_ERROR_CONFLICT:
    return _("The server is closing the active stream for this entity "
             "because a new stream has been initiated that conflicts with "
             "the existing stream");
  case INF_XMPP_CONNECTION_STREAM_ERROR_CONNECTION_TIMEOUT:
    return _("The entity has not generated any traffic over the stream for "
             "some period of time");
  case INF_XMPP_CONNECTION_STREAM_ERROR_HOST_GONE:
    return _("The value of the 'to' attribute provided by the initiating "
             "entity in the stream header corresponds to a hostname that is "
             "no longer hosted by the server");
  case INF_XMPP_CONNECTION_STREAM_ERROR_HOST_UNKNOWN:
    return _("The value of the 'to' attribute provided by the initiating "
             "entity  in the stream header does not correspond to a hostname "
             "that is hosted by the server");
  case INF_XMPP_CONNECTION_STREAM_ERROR_IMPROPER_ADDRESSING:
    return _("A stanza sent between two servers lacks a 'to' or 'from'"
             "attribute");
  case INF_XMPP_CONNECTION_STREAM_ERROR_INTERNAL_SERVER_ERROR:
    return _("The server has experienced a misconfiguration or an otherwise-"
             "undefined internal error that prevents it from servicing "
             "the stream");
  case INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_FROM:
    return _("The JID or hostname provided in a 'from' address does not "
             "match an authorized JID or validated domain negotiated between "
             "servers via SASL or dialback, or between a client and a "
             "server via authentication and resource binding");
  case INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_ID:
    return _("The stream ID or dialback ID is invalid or does not match an "
             "ID previously provided");
  case INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_NAMESPACE:
    return _("The streams namespace is something other than "
             "\"http://etherx.jabber.org/streams\" or the dialback namespace "
             "name is something other than \"jabber:server:dialback\"");
  case INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_XML:
    return _("The entity has sent invalid XML over the stream to a server "
             "that performs validation");
  case INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED:
    return _("The entity has attempted to send data before the stream has "
             "been authenticated, or otherwise is not authorized to perform "
             "an action related to stream negotiation");
  case INF_XMPP_CONNECTION_STREAM_ERROR_POLICY_VIOLATION:
    return _("The entity has violated some local service policy");
  case INF_XMPP_CONNECTION_STREAM_ERROR_REMOTE_CONNECTION_FAILED:
    return _("The server is unable to properly connect to a remote entity "
             "that is required for authentication or authorization");
  case INF_XMPP_CONNECTION_STREAM_ERROR_RESOURCE_CONSTRAINT:
    return _("The server lacks the system resources necessary to service the "
             "stream");
  case INF_XMPP_CONNECTION_STREAM_ERROR_RESTRICTED_XML:
    return _("The entity has attempted to send restricted XML features");
  case INF_XMPP_CONNECTION_STREAM_ERROR_SEE_OTHER_HOST:
    return _("The server will not provide service to the initiating "
             "entity but is redirecting traffic to another host");
  case INF_XMPP_CONNECTION_STREAM_ERROR_SYSTEM_SHUTDOWN:
    return _("The server is being shut down and all active streams are being "
             "closed");
  case INF_XMPP_CONNECTION_STREAM_ERROR_UNDEFINED_CONDITION:
  case INF_XMPP_CONNECTION_STREAM_ERROR_FAILED:
    return _("The error condition is not one of those defined by the other "
             "conditions");
  case INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_ENCODING:
    return _("The initiating entity has encoded the stream in an encoding "
             "that is not supported by the server");
  case INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_STANZA_TYPE:
    return _("The initiating entity has sent a first-level child of the "
             "stream that is not supported by the server.");
  case INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_VERSION:
    return _("The value of the 'version' attribute provided by the "
             "initiating entity in the stream header specifies a version of "
             "XMPP that is not supported by the server");
  case INF_XMPP_CONNECTION_STREAM_ERROR_XML_NOT_WELL_FORMED:
    return _("The initiating entity has sent XML that is not well-formed");
  default:
    g_assert_not_reached();
    break;
  }
}
static InfXmppConnectionAuthError
inf_xmpp_connection_auth_error_from_condition(const gchar* condition)
{
  const InfXmppConnectionErrorCondition* cond;
  for(cond = inf_xmpp_connection_auth_error_conditions;
      cond-&gt;condition != NULL;
      ++ cond)
  {
    if(strcmp(condition, cond-&gt;condition) == 0)
      return cond-&gt;code;
  }
  return INF_XMPP_CONNECTION_AUTH_ERROR_FAILED;
}
static const gchar*
inf_xmpp_connection_auth_error_to_condition(InfXmppConnectionAuthError code)
{
  const InfXmppConnectionErrorCondition* cond;
  for(cond = inf_xmpp_connection_auth_error_conditions;
      cond-&gt;condition != NULL;
      ++ cond)
  {
    if(cond-&gt;code == code)
      return cond-&gt;condition;
  }
  g_assert_not_reached();
  return NULL;
}
static const gchar*
inf_xmpp_connection_auth_strerror(InfXmppConnectionAuthError code)
{
  switch(code)
  {
  case INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED:
    return _("The receiving entity acknowledged an &lt;abort/&gt; element sent by "
             "the initiating entity");
  case INF_XMPP_CONNECTION_AUTH_ERROR_INCORRECT_ENCODING:
    return _("The data provided by the initiating entity could not be "
             "processed because the Base64 encoding is incorrect");
  case INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_AUTHZID:
    return _("The authzid provided by the initiating entity is invalid, "
             "either because it is incorrectly formatted or because the "
             "initiating entity does not have permissions to authorize "
             "that ID");
  case INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM:
    return _("The initiating entity did not provide a mechanism or requested "
             "a mechanism that is not supported by the receiving entity");
  case INF_XMPP_CONNECTION_AUTH_ERROR_MECHANISM_TOO_WEAK:
    return _("The mechanism requested by the initiating entity is weaker than "
             "server policy permits for that initiating entity");
  case INF_XMPP_CONNECTION_AUTH_ERROR_NOT_AUTHORIZED:
    return _("The authentication failed because the initiating entity did "
             "not provide valid credentials");
  case INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE:
    return _("The authentication failed because of a temporary error condition "
             "within the receiving entity");
  case INF_XMPP_CONNECTION_AUTH_ERROR_FAILED:
    return _("An unknown authentication error has occurred");
  default:
    g_assert_not_reached();
    return NULL;
  }
}
static void
inf_xmpp_connection_push_message(InfXmppConnection* xmpp,
                                 InfXmppConnectionSentFunc sent_func,
                                 InfXmppConnectionFreeFunc free_func,
                                 gpointer user_data)
{
  InfXmppConnectionPrivate* priv;
  InfXmppConnectionMessage* message;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;position == 0)
  {
    if(sent_func != NULL)
      sent_func(xmpp, user_data);
    if(free_func != NULL)
      free_func(xmpp, user_data);
  }
  else
  {
    message = g_slice_new(InfXmppConnectionMessage);
    message-&gt;next = NULL;
    message-&gt;position = priv-&gt;position;
    message-&gt;sent = FALSE;
    message-&gt;sent_func = sent_func;
    message-&gt;free_func = free_func;
    message-&gt;user_data = user_data;
    if(priv-&gt;last_message == NULL)
      priv-&gt;messages = message;
    else 
      priv-&gt;last_message-&gt;next = message;
    priv-&gt;last_message = message;
  }
}
static void
inf_xmpp_connection_pop_message(InfXmppConnection* connection)
{
  InfXmppConnectionPrivate* priv;
  InfXmppConnectionMessage* message;
  priv = INF_XMPP_CONNECTION_PRIVATE(connection);
  message = priv-&gt;messages;
  g_assert(message != NULL);
  priv-&gt;messages = message-&gt;next;
  if(priv-&gt;messages == NULL) priv-&gt;last_message = NULL;
  if(message-&gt;free_func != NULL)
    message-&gt;free_func(connection, message-&gt;user_data);
  g_slice_free(InfXmppConnectionMessage, message);
}
static void
inf_xmpp_connection_clear(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_object_freeze_notify(G_OBJECT(xmpp));
  if(priv-&gt;sasl_session != NULL)
  {
    inf_sasl_context_stop_session(priv-&gt;sasl_context, priv-&gt;sasl_session);
    priv-&gt;sasl_session = NULL;
  }
  if(priv-&gt;sasl_remote_mechanisms != NULL)
  {
    g_free(priv-&gt;sasl_remote_mechanisms);
    priv-&gt;sasl_remote_mechanisms = NULL;
  }
#if 0
  if(priv-&gt;own_cert != NULL)
  {
    gnutls_x509_crt_deinit(priv-&gt;own_cert);
    priv-&gt;own_cert = NULL;
    g_object_notify(G_OBJECT(xmpp), "local-certificate");
  }
  if(priv-&gt;peer_cert != NULL)
  {
    inf_certificate_chain_unref(priv-&gt;peer_cert);
    priv-&gt;peer_cert = NULL;
    g_object_notify(G_OBJECT(xmpp), "remote-certificate");
  }
#endif
  if(priv-&gt;session != NULL)
  {
    gnutls_deinit(priv-&gt;session);
    priv-&gt;session = NULL;
    g_object_notify(G_OBJECT(xmpp), "tls-enabled");
  }
  if(priv-&gt;parser != NULL)
  {
    xmlFreeParserCtxt(priv-&gt;parser);
    priv-&gt;parser = NULL;
    if(priv-&gt;root != NULL)
    {
      xmlFreeNode(priv-&gt;root);
      priv-&gt;root = NULL;
      priv-&gt;cur = NULL;
    }
  }
  while(priv-&gt;messages != NULL)
    inf_xmpp_connection_pop_message(xmpp);
  if(priv-&gt;buf != NULL)
  {
    g_assert(priv-&gt;doc != NULL);
    xmlBufferFree(priv-&gt;buf);
    xmlFreeDoc(priv-&gt;doc);
    priv-&gt;buf = NULL;
    priv-&gt;doc = NULL;
  }
  priv-&gt;pull_data = NULL;
  priv-&gt;pull_len = 0;
  g_object_thaw_notify(G_OBJECT(xmpp));
}
static void
inf_xmpp_connection_send_chars(InfXmppConnection* xmpp,
                               gconstpointer data,
                               guint len)
{
  InfXmppConnectionPrivate* priv;
  ssize_t cur_bytes;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_CLOSED);
  if(INF_XMPP_CONNECTION_PRINT_TRAFFIC)
    printf("\033[00;34m%.*s\033[00;00m\n", (int)len, (const char*)data);
  ++priv-&gt;parsing;
  if(priv-&gt;session != NULL)
  {
    do
    {
      cur_bytes = gnutls_record_send(priv-&gt;session, data, len);
      if(cur_bytes &lt; 0)
      {
        error = NULL;
        inf_gnutls_set_error(&amp;error, cur_bytes);
        inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
        g_error_free(error);
        inf_tcp_connection_close(priv-&gt;tcp);
        break;
      }
      else if(cur_bytes == 0)
      {
        g_assert_not_reached();
      }
      else
      {
        *((const char**)&amp;data) += cur_bytes;
        len -= cur_bytes;
      }
    } while(len &gt; 0);
  }
  else
  {
    priv-&gt;position += len;
    inf_tcp_connection_send(priv-&gt;tcp, data, len);
  }
  g_assert(priv-&gt;parsing &gt; 0);
  if(--priv-&gt;parsing == 0)
  {
    if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSED)
    {
      inf_xmpp_connection_clear(xmpp);
      g_object_notify(G_OBJECT(xmpp), "status");
    }
  }
}
static void
inf_xmpp_connection_send_xml(InfXmppConnection* xmpp,
                             xmlNodePtr xml)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_return_if_fail(priv-&gt;doc != NULL);
  g_return_if_fail(priv-&gt;buf != NULL);
  xmlDocSetRootElement(priv-&gt;doc, xml);
  xmlNodeDump(priv-&gt;buf, priv-&gt;doc, xml, 0, 0);
  xmlUnlinkNode(xml);
  xmlSetListDoc(xml, NULL);
  g_object_ref(xmpp);
  inf_xmpp_connection_send_chars(
    xmpp,
    xmlBufferContent(priv-&gt;buf),
    xmlBufferLength(priv-&gt;buf)
  );
  if(priv-&gt;buf != NULL)
    xmlBufferEmpty(priv-&gt;buf);
  g_object_unref(xmpp);
}
static xmlNodePtr
inf_xmpp_connection_node_new(const gchar* name,
                             const gchar* xmlns)
{
  xmlNodePtr ptr;
  ptr = xmlNewNode(NULL, (const xmlChar*)name);
  xmlNewProp(ptr, (const xmlChar*)"xmlns", (const xmlChar*)xmlns);
  return ptr;
}
static xmlNodePtr
inf_xmpp_connection_node_new_streams(const gchar* name)
{
  return inf_xmpp_connection_node_new(
    name,
    "urn:ietf:params:xml:ns:xmpp-streams"
  );
}
static xmlNodePtr
inf_xmpp_connection_node_new_tls(const gchar* name)
{
  return inf_xmpp_connection_node_new(
    name,
    "urn:ietf:params:xml:ns:xmpp-tls"
  );
}
static xmlNodePtr
inf_xmpp_connection_node_new_sasl(const gchar* name)
{
  return inf_xmpp_connection_node_new(
    name,
    "urn:ietf:params:xml:ns:xmpp-sasl"
  );
}
static void
inf_xmpp_connection_terminate(InfXmppConnection* xmpp)
{
  static const gchar xmpp_connection_deinit_request[] = "&lt;/stream:stream&gt;";
  InfXmppConnectionPrivate* priv;
  xmlNodePtr abort;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_GNUTLS &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_CONNECTING);
  if(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING &amp;&amp;
     priv-&gt;status != INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED)
  {
    if(priv-&gt;status != INF_XMPP_CONNECTION_CONNECTED &amp;&amp;
       priv-&gt;status != INF_XMPP_CONNECTION_AUTH_CONNECTED &amp;&amp;
       priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_STREAM)
    {
      if(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING)
      {
        abort = inf_xmpp_connection_node_new_sasl("abort");
        inf_xmpp_connection_send_xml(xmpp, abort);
        xmlFreeNode(abort);
      }
      if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED)
      {
        inf_xmpp_connection_send_chars(
          xmpp,
          xmpp_connection_deinit_request,
          sizeof(xmpp_connection_deinit_request) - 1
        );
      }
    }
    if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED &amp;&amp; priv-&gt;session != NULL)
      gnutls_bye(priv-&gt;session, GNUTLS_SHUT_WR);
  }
  if(priv-&gt;parsing == 0)
    inf_xmpp_connection_clear(xmpp);
  if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED)
  {
    if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_STREAM)
    {
      priv-&gt;status = INF_XMPP_CONNECTION_CLOSING_GNUTLS;
      if(priv-&gt;parsing == 0)
        g_object_notify(G_OBJECT(xmpp), "status");
    }
    else
    {
      priv-&gt;status = INF_XMPP_CONNECTION_CLOSING_GNUTLS;
    }
  }
}
static void
inf_xmpp_connection_send_auth_error(InfXmppConnection* xmpp,
                                    InfXmppConnectionAuthError code)
{
  InfXmppConnectionPrivate* priv;
  xmlNodePtr xml;
  xmlNodePtr child;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;sasl_context != NULL);
  xml = inf_xmpp_connection_node_new_sasl("failure");
  child = xmlNewChild(
    xml,
    NULL,
    (const xmlChar*)inf_xmpp_connection_auth_error_to_condition(code),
    NULL
  );
  if(priv-&gt;sasl_error != NULL)
  {
    xmlAddChild(
      child,
      inf_xml_util_new_node_from_error(priv-&gt;sasl_error, NULL, "error"));
  }
  inf_xmpp_connection_send_xml(xmpp, xml);
  xmlFreeNode(xml);
}
static void
inf_xmpp_connection_emit_auth_error(InfXmppConnection* xmpp,
                                    InfXmppConnectionAuthError code)
{
  GError* error;
  error = NULL;
  g_set_error_literal(
    &amp;error,
    inf_xmpp_connection_auth_error_quark,
    code,
    inf_xmpp_connection_auth_strerror(code)
  );
  inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
  g_error_free(error);
}
static void
inf_xmpp_connection_terminate_error(InfXmppConnection* xmpp,
                                    InfXmppConnectionStreamError code,
                                    const gchar* message)
{
  InfXmppConnectionPrivate* priv;
  xmlNodePtr node;
  xmlNodePtr child;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;parser != NULL);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED);
  error = NULL;
  g_set_error_literal(
    &amp;error,
    inf_xmpp_connection_stream_error_quark,
    code,
    message != NULL ? message : inf_xmpp_connection_stream_strerror(code)
  );
  node = xmlNewNode(NULL, (const xmlChar*)"stream:error");
  child = inf_xmpp_connection_node_new_streams(
    inf_xmpp_connection_stream_error_to_condition(code)
  );
  xmlAddChild(node, child);
  if(message != NULL)
  {
    child = inf_xmpp_connection_node_new_streams("text");
    xmlNodeAddContent(child, (const xmlChar*)message);
    xmlNodeSetLang(child, (const xmlChar*)"en");
  }
  inf_xmpp_connection_send_xml(xmpp, node);
  xmlFreeNode(node);
  inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
  g_error_free(error);
  inf_xmpp_connection_terminate(xmpp);
}
static void
inf_xmpp_connection_deinitiate(InfXmppConnection* xmpp)
{
  static const gchar xmpp_connection_deinitiate_request[] =
    "&lt;/stream:stream&gt;";
  InfXmppConnectionPrivate* priv;
  xmlNodePtr abort;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_GNUTLS &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_STREAM &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_CONNECTED &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_AUTH_CONNECTED);
  if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT &amp;&amp;
     priv-&gt;sasl_remote_mechanisms != NULL)
  {
    g_free(priv-&gt;sasl_remote_mechanisms);
    priv-&gt;sasl_remote_mechanisms = NULL;
  }
  if(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING)
  {
    if(priv-&gt;sasl_session != NULL)
    {
      abort = inf_xmpp_connection_node_new_sasl("abort");
      inf_xmpp_connection_send_xml(xmpp, abort);
    }
  }
  inf_xmpp_connection_send_chars(
    xmpp,
    xmpp_connection_deinitiate_request,
    sizeof(xmpp_connection_deinitiate_request) - 1
  );
  priv-&gt;status = INF_XMPP_CONNECTION_CLOSING_STREAM;
  g_object_notify(G_OBJECT(xmpp), "status");
}
static void
inf_xmpp_connection_initiate(InfXmppConnection* xmpp);
static gboolean
inf_xmpp_connection_prefers_tls(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  return
    priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS ||
    priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS;
}
static ssize_t
inf_xmpp_connection_tls_push(gnutls_transport_ptr_t ptr,
                             const void* data,
                             size_t len)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmpp = INF_XMPP_CONNECTION(ptr);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  priv-&gt;position += len;
  inf_tcp_connection_send(priv-&gt;tcp, data, len);
  return len;
}
static ssize_t
inf_xmpp_connection_tls_pull(gnutls_transport_ptr_t ptr,
                             void* data,
                             size_t len)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  size_t pull_len;
  xmpp = INF_XMPP_CONNECTION(ptr);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;pull_len == 0)
  {
    gnutls_transport_set_errno(priv-&gt;session, EAGAIN);
    return -1;
  }
  else
  {
    pull_len = priv-&gt;pull_len;
    if(len &lt; pull_len) pull_len = len;
    memcpy(data, priv-&gt;pull_data, pull_len);
    priv-&gt;pull_len -= pull_len;
    priv-&gt;pull_data += pull_len;
    return pull_len;
  }
}
static gnutls_x509_crt_t
inf_xmpp_connection_tls_import_own_certificate(InfXmppConnection* xmpp,
                                               GError** error)
{
  InfXmppConnectionPrivate* priv;
  const gnutls_datum_t* cert_raw;
  gnutls_x509_crt_t cert;
  int res;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  cert_raw = gnutls_certificate_get_ours(priv-&gt;session);
  if(cert_raw == NULL)
    return NULL;
  res = gnutls_x509_crt_init(&amp;cert);
  if(res != GNUTLS_E_SUCCESS)
  {
    inf_gnutls_set_error(error, res);
    return NULL;
  }
  res = gnutls_x509_crt_import(cert, cert_raw, GNUTLS_X509_FMT_DER);
  if(res != GNUTLS_E_SUCCESS)
  {
    gnutls_x509_crt_deinit(cert);
    inf_gnutls_set_error(error, res);
    return NULL;
  }
  return cert;
}
static InfCertificateChain*
inf_xmpp_connection_tls_import_peer_certificate(InfXmppConnection* xmpp,
                                                GError** error)
{
  InfXmppConnectionPrivate* priv;
  const gnutls_datum_t* certs_raw;
  unsigned int list_size;
  unsigned int n_certs;
  gnutls_x509_crt_t* certs;
  int res;
  guint i;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  certs_raw = gnutls_certificate_get_peers(priv-&gt;session, &amp;list_size);
  if(certs_raw == NULL)
    return NULL;
  certs = g_malloc(list_size * sizeof(gnutls_x509_crt_t));
#if 0
  n_certs = list_size;
  res = gnutls_x509_crt_list_import(
    certs,
    &amp;n_certs,
    certs_raw,
    GNUTLS_X509_FMT_DER,
    GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED
  );
  if(res &lt; 0)
  {
    g_free(certs);
    inf_gnutls_set_error(error, res);
    return NULL;
  }
  g_assert(res == n_certs);
  g_assert(res == list_size);
#else
  for(i = 0; i &lt; list_size; ++ i)
  {
    res = gnutls_x509_crt_init(&amp;certs[i]);
    if(res == GNUTLS_E_SUCCESS)
    {
      res = gnutls_x509_crt_import(
        certs[i],
        certs_raw + i,
        GNUTLS_X509_FMT_DER
      );
      if(res != GNUTLS_E_SUCCESS)
        gnutls_x509_crt_deinit(certs[i]);
    }
    if(res != GNUTLS_E_SUCCESS)
    {
      for(; i &gt; 0; -- i)
        gnutls_x509_crt_deinit(certs[i - 1]);
      g_free(certs);
      inf_gnutls_set_error(error, res);
      return NULL;
    }
  }
#endif
  return inf_certificate_chain_new(certs, list_size);
}
static void
inf_xmpp_connection_tls_handshake(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  int ret;
  InfCertificateChain* chain;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_HANDSHAKING);
  g_assert(priv-&gt;session != NULL);
  ret = gnutls_handshake(priv-&gt;session);
  switch(ret)
  {
  case GNUTLS_E_AGAIN:
    break;
  case 0:
    priv-&gt;status = INF_XMPP_CONNECTION_CONNECTED;
    g_object_notify(G_OBJECT(xmpp), "tls-enabled");
    error = NULL;
    g_assert(priv-&gt;own_cert == NULL);
    priv-&gt;own_cert =
      inf_xmpp_connection_tls_import_own_certificate(xmpp, &amp;error);
    if(error == NULL)
    {
      if(priv-&gt;own_cert != NULL)
        g_object_notify(G_OBJECT(xmpp), "local-certificate");
      g_assert(priv-&gt;peer_cert == NULL);
      priv-&gt;peer_cert =
        inf_xmpp_connection_tls_import_peer_certificate(xmpp, &amp;error);
      if(error == NULL)
      {
        if(priv-&gt;peer_cert == NULL)
        {
          if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
          {
            g_set_error_literal(
              &amp;error,
              inf_xmpp_connection_error_quark(),
              INF_XMPP_CONNECTION_ERROR_NO_CERTIFICATE_PROVIDED,
              _("The server did not provide a certificate")
            );
          }
        }
        else
        {
          g_object_notify(G_OBJECT(xmpp), "remote-certificate");
        }
      }
    }
    if(error != NULL)
    {
      inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
      g_error_free(error);
      inf_xmpp_connection_terminate(xmpp);
    }
    else
    {
      if(priv-&gt;certificate_callback != NULL)
      {
        priv-&gt;certificate_callback(
          xmpp,
          priv-&gt;session,
          priv-&gt;peer_cert,
          priv-&gt;certificate_callback_user_data
        );
      }
      else
      {
        inf_xmpp_connection_initiate(xmpp);
      }
    }
    break;
  default:
    error = NULL;
    inf_gnutls_set_error(&amp;error, ret);
    inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
    g_error_free(error);
    gnutls_deinit(priv-&gt;session);
    priv-&gt;session = NULL;
    switch(priv-&gt;site)
    {
    case INF_XMPP_CONNECTION_CLIENT:
      inf_xmpp_connection_terminate(xmpp);
      break;
    case INF_XMPP_CONNECTION_SERVER:
      priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
      inf_xmpp_connection_terminate(xmpp);
      break;
    default:
      g_assert_not_reached();
      break;
    }
    break;
  }
}
static void
inf_xmpp_connection_tls_init(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;session == NULL);
  if(priv-&gt;creds == NULL)
  {
    g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
    priv-&gt;creds = inf_certificate_credentials_new();
    g_object_notify(G_OBJECT(xmpp), "credentials");
  }
  switch(priv-&gt;site)
  {
  case INF_XMPP_CONNECTION_CLIENT:
    gnutls_init(&amp;priv-&gt;session, GNUTLS_CLIENT);
    break;
  case INF_XMPP_CONNECTION_SERVER:
    gnutls_init(&amp;priv-&gt;session, GNUTLS_SERVER);
    if(priv-&gt;certificate_callback != NULL)
    {
      gnutls_certificate_server_set_request(
        priv-&gt;session,
        priv-&gt;certificate_request
      );
    }
    break;
  default:
    g_assert_not_reached();
    break;
  }
  gnutls_priority_set_direct(priv-&gt;session, "NORMAL:-RSA:+RSA", NULL);
  gnutls_credentials_set(
    priv-&gt;session,
    GNUTLS_CRD_CERTIFICATE,
    inf_certificate_credentials_get(priv-&gt;creds)
  );
  gnutls_transport_set_ptr(priv-&gt;session, xmpp);
  gnutls_transport_set_push_function(
    priv-&gt;session,
    inf_xmpp_connection_tls_push
  );
  gnutls_transport_set_pull_function(
    priv-&gt;session,
    inf_xmpp_connection_tls_pull
  );
  priv-&gt;status = INF_XMPP_CONNECTION_HANDSHAKING;
  inf_xmpp_connection_tls_handshake(xmpp);
}
static gboolean
inf_xmpp_connection_sasl_has_mechanism(const char* mechlist,
                                       const char* mechanism)
{
  size_t len;
  const char* res;
  for(len = strlen(mechanism); mechlist != NULL; mechlist = strchr(res, ' '))
  {
    res = strstr(mechlist, mechanism);
    if(res == NULL)
      return FALSE;
    if( (res == mechlist  || isspace(res[ -1])) &amp;&amp;
        (res[len] == '\0' || isspace(res[len])))
      return TRUE;
  }
  return FALSE;
}
static void
inf_xmpp_connection_sasl_finish(InfXmppConnection* xmpp,
                                gboolean success)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;sasl_session != NULL)
  {
    inf_sasl_context_stop_session(priv-&gt;sasl_context, priv-&gt;sasl_session);
    priv-&gt;sasl_session = NULL;
  }
  if(success)
  {
    if(priv-&gt;sasl_error != NULL)
    {
      g_error_free(priv-&gt;sasl_error);
      priv-&gt;sasl_error = NULL;
    }
    priv-&gt;status = INF_XMPP_CONNECTION_AUTH_CONNECTED;
    if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
    {
      g_assert(priv-&gt;sasl_remote_mechanisms != NULL);
      g_free(priv-&gt;sasl_remote_mechanisms);
      priv-&gt;sasl_remote_mechanisms = NULL;
    }
    else
    {
      g_assert(priv-&gt;sasl_remote_mechanisms == NULL);
    }
    if(priv-&gt;parsing == 0)
      inf_xmpp_connection_initiate(xmpp);
  }
  else
  {
    if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
      priv-&gt;status = INF_XMPP_CONNECTION_AWAITING_FEATURES;
    else
      priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
  }
}
static void
inf_xmpp_connection_sasl_error(InfXmppConnection* xmpp,
                               const GError* error)
{
  InfXmppConnectionPrivate* priv;
  InfXmppConnectionAuthError auth_code;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
  if(priv-&gt;site == INF_XMPP_CONNECTION_SERVER)
  {
    switch(error-&gt;code)
    {
    case GSASL_UNKNOWN_MECHANISM:
    case GSASL_MECHANISM_PARSE_ERROR:
      auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM;
      break;
    case GSASL_BASE64_ERROR:
      auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_INCORRECT_ENCODING;
      break;
    case GSASL_AUTHENTICATION_ERROR:
      auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_NOT_AUTHORIZED;
      break;
    default:
      auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE;
      break;
    }
    inf_xmpp_connection_send_auth_error(xmpp, auth_code);
    priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
    inf_xmpp_connection_sasl_finish(xmpp, FALSE);
  }
  else
  {
    inf_xmpp_connection_sasl_finish(xmpp, FALSE);
    inf_xmpp_connection_terminate(xmpp);
  }
}
static void
inf_xmpp_connection_sasl_cb(InfSaslContextSession* session,
                            Gsasl_property property,
                            gpointer session_data,
                            gpointer user_data)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmpp = INF_XMPP_CONNECTION(user_data);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  switch(property)
  {
  case GSASL_ANONYMOUS_TOKEN:
    inf_sasl_context_session_set_property(
      session,
      GSASL_ANONYMOUS_TOKEN,
      g_get_user_name()
    );
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  case GSASL_VALIDATE_ANONYMOUS:
    inf_sasl_context_session_continue(session, GSASL_OK);
    break;
  default:
    g_assert_not_reached();
    inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
    break;
  }
}
static gboolean
inf_xmpp_connection_sasl_ensure(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;sasl_context == NULL)
  {
    g_assert(priv-&gt;sasl_own_context == NULL);
    error = NULL;
    priv-&gt;sasl_own_context = inf_sasl_context_new(&amp;error);
    if(priv-&gt;sasl_own_context == NULL)
    {
      inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
      g_error_free(error);
      inf_xmpp_connection_terminate(xmpp);
      return FALSE;
    }
    else
    {
      priv-&gt;sasl_context = priv-&gt;sasl_own_context;
      inf_sasl_context_ref(priv-&gt;sasl_context);
      inf_sasl_context_set_callback(
        priv-&gt;sasl_context,
        inf_xmpp_connection_sasl_cb,
        xmpp,
        NULL
      );
      g_object_notify(G_OBJECT(xmpp), "sasl-context");
    }
  }
  g_assert(priv-&gt;sasl_context != NULL);
  return TRUE;
}
static void
inf_xmpp_connection_sasl_request_feed_func(InfSaslContextSession* session,
                                           const char* data,
                                           gboolean needs_more,
                                           const GError* error,
                                           gpointer user_data)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmlNodePtr reply;
  xmpp = INF_XMPP_CONNECTION(user_data);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING);
  g_assert(priv-&gt;sasl_session != NULL);
  if(error)
  {
    inf_xmpp_connection_sasl_error(xmpp, error);
  }
  else
  {
    if(data != NULL)
    {
      reply = NULL;
      switch(priv-&gt;site)
      {
      case INF_XMPP_CONNECTION_SERVER:
        if(needs_more)
          reply = inf_xmpp_connection_node_new_sasl("challenge");
        break;
      case INF_XMPP_CONNECTION_CLIENT:
        reply = inf_xmpp_connection_node_new_sasl("response");
        break;
      default:
        g_assert_not_reached();
        break;
      }
      if(reply != NULL)
      {
        xmlNodeAddContent(reply, (const xmlChar*)data);
        inf_xmpp_connection_send_xml(xmpp, reply);
        xmlFreeNode(reply);
      }
    }
    if(!needs_more)
    {
      if(priv-&gt;site == INF_XMPP_CONNECTION_SERVER)
      {
        reply = inf_xmpp_connection_node_new_sasl("success");
        inf_xmpp_connection_send_xml(xmpp, reply);
        xmlFreeNode(reply);
        inf_xmpp_connection_sasl_finish(xmpp, TRUE);
      }
    }
  }
}
static void
inf_xmpp_connection_sasl_request(InfXmppConnection* xmpp,
                                 const gchar* input)
{
  InfXmppConnectionPrivate* priv;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING);
  g_assert(priv-&gt;sasl_session != NULL);
  if(inf_sasl_context_session_is_processing(priv-&gt;sasl_session))
  {
    error = NULL;
    inf_gsasl_set_error(&amp;error, GSASL_INTEGRITY_ERROR);
    inf_xmpp_connection_sasl_error(xmpp, error);
    g_error_free(error);
  }
  else
  {
    inf_sasl_context_session_feed(
      priv-&gt;sasl_session,
      input,
      inf_xmpp_connection_sasl_request_feed_func,
      xmpp
    );
  }
}
static void
inf_xmpp_connection_sasl_init(InfXmppConnection* xmpp,
                              const gchar* mechanism)
{
  InfXmppConnectionPrivate* priv;
  InfIo* io;
  xmlNodePtr auth;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_AUTHENTICATING);
  g_assert(priv-&gt;sasl_context != NULL);
  g_assert(priv-&gt;sasl_session == NULL);
  g_assert(priv-&gt;tcp != NULL);
  if(priv-&gt;sasl_error != NULL)
  {
    g_error_free(priv-&gt;sasl_error);
    priv-&gt;sasl_error = NULL;
  }
  g_object_get(G_OBJECT(priv-&gt;tcp), "io", &amp;io, NULL);
  g_assert(io != NULL);
  switch(priv-&gt;site)
  {
  case INF_XMPP_CONNECTION_CLIENT:
    auth = inf_xmpp_connection_node_new_sasl("auth");
    xmlNewProp(
      auth,
      (const xmlChar*)"mechanism",
      (const xmlChar*)mechanism
    );
    inf_xmpp_connection_send_xml(xmpp, auth);
    xmlFreeNode(auth);
    g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES);
    error = NULL;
    priv-&gt;sasl_session = inf_sasl_context_client_start_session(
      priv-&gt;sasl_context,
      io,
      mechanism,
      xmpp,
      &amp;error
    );
    break;
  case INF_XMPP_CONNECTION_SERVER:
    g_assert(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED);
    error = NULL;
    priv-&gt;sasl_session = inf_sasl_context_server_start_session(
      priv-&gt;sasl_context,
      io,
      mechanism,
      xmpp,
      &amp;error
    );
    break;
  default:
    g_assert_not_reached();
    break;
  }
  g_object_unref(io);
  if(error != NULL)
  {
    inf_xmpp_connection_sasl_error(xmpp, error);
    g_error_free(error);
  }
  else
  {
    priv-&gt;status = INF_XMPP_CONNECTION_AUTHENTICATING;
    if(priv-&gt;site == INF_XMPP_CONNECTION_SERVER)
      inf_xmpp_connection_sasl_request(xmpp, NULL);
  }
}
static void
inf_xmpp_connection_process_start_element(InfXmppConnection* xmpp,
                                          const xmlChar* name,
                                          const xmlChar** attrs)
{
  InfXmppConnectionPrivate* priv;
  xmlNodePtr node;
  const xmlChar** attr;
  const xmlChar* attr_name;
  const xmlChar* attr_value;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  node = xmlNewNode(NULL, name);
  if(attrs != NULL)
  {
    attr = attrs;
    while(*attr != NULL)
    {
      attr_name = *attr;
      ++ attr;
      attr_value = *attr;
      ++ attr;
      xmlNewProp(node, attr_name, attr_value);
    }
  }
  if(priv-&gt;root == NULL)
  {
    g_assert(priv-&gt;cur == NULL);
    priv-&gt;root = node;
    priv-&gt;cur = node;
  }
  else
  {
    g_assert(priv-&gt;cur != NULL);
    priv-&gt;cur = xmlAddChild(priv-&gt;cur, node);
  }
}
static void
inf_xmpp_connection_process_connected(InfXmppConnection* xmpp,
                                      const xmlChar** attrs)
{
  static const gchar xmpp_connection_initial_request[] = 
    "&lt;stream:stream xmlns:stream=\"http://etherx.jabber.org/streams\" "
    "xmlns=\"jabber:client\" version=\"1.0\" from=\"%s\"&gt;";
  InfXmppConnectionPrivate* priv;
  char* mech_list;
  char* begin;
  char* end;
  gchar* reply;
  xmlNodePtr features;
  xmlNodePtr starttls;
  xmlNodePtr mechanisms;
  xmlNodePtr mechanism;
  gchar* mechanism_dup;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;site == INF_XMPP_CONNECTION_SERVER);
  g_assert(priv-&gt;parser != NULL);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
           priv-&gt;status == INF_XMPP_CONNECTION_AUTH_CONNECTED);
  reply = g_strdup_printf(
    xmpp_connection_initial_request,
    priv-&gt;local_hostname
  );
  inf_xmpp_connection_send_chars(xmpp, reply, strlen(reply));
  g_free(reply);
  switch(priv-&gt;status)
  {
  case INF_XMPP_CONNECTION_CONNECTED:
    priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
    break;
  case INF_XMPP_CONNECTION_AUTH_CONNECTED:
    priv-&gt;status = INF_XMPP_CONNECTION_AUTH_INITIATED;
    break;
  default:
    g_assert_not_reached();
    break;
  }
  features = xmlNewNode(NULL, (const xmlChar*)"stream:features");
  if(priv-&gt;session == NULL &amp;&amp;
     priv-&gt;status != INF_XMPP_CONNECTION_AUTH_INITIATED)
  {
    if(priv-&gt;security_policy != INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED)
    {
      starttls = inf_xmpp_connection_node_new_tls("starttls");
      xmlAddChild(features, starttls);
      if(priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS)
        xmlNewChild(starttls, NULL, (const xmlChar*)"required", NULL);
    }
  }
  if(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED)
  {
    mechanisms = inf_xmpp_connection_node_new_sasl("mechanisms");
    xmlAddChild(features, mechanisms);
    if(inf_xmpp_connection_sasl_ensure(xmpp) == FALSE)
    {
      xmlFreeNode(features);
      return;
    }
    else if(priv-&gt;sasl_own_context != NULL)
    {
      xmlNewTextChild(
        mechanisms,
        NULL,
        (const xmlChar*)"mechanism",
        (const xmlChar*)"ANONYMOUS"
      );
    }
    else
    {
      if(priv-&gt;sasl_local_mechanisms == NULL)
      {
        error = NULL;
        mech_list = inf_sasl_context_server_list_mechanisms(
          priv-&gt;sasl_context,
          &amp;error
        );
        if(error != NULL)
        {
          xmlFreeNode(features);
          inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
          g_error_free(error);
          inf_xmpp_connection_terminate(xmpp);
          return;
        }
      }
      else
      {
        mech_list = priv-&gt;sasl_local_mechanisms;
      }
      begin = end = mech_list;
      while(*end != '\0')
      {
        end = strpbrk(begin, " \t\r\n");
        if(end == NULL) end = begin + strlen(begin);
        mechanism_dup = g_strndup(begin, end - begin);
        if(inf_sasl_context_server_supports_mechanism(priv-&gt;sasl_context,
                                                      mechanism_dup))
        {
          mechanism = xmlNewChild(
            mechanisms,
            NULL,
            (const xmlChar*)"mechanism",
            NULL
          );
          xmlNodeAddContentLen(mechanism, (const xmlChar*)begin, end - begin);
        }
        g_free(mechanism_dup);
        begin = end + 1;
      }
      if(priv-&gt;sasl_local_mechanisms == NULL)
        g_free(mech_list);
    }
  }
  inf_xmpp_connection_send_xml(xmpp, features);
  xmlFreeNode(features);
  if(priv-&gt;status == INF_XMPP_CONNECTION_AUTH_INITIATED)
  {
    priv-&gt;status = INF_XMPP_CONNECTION_READY;
    g_object_notify(G_OBJECT(xmpp), "status");
  }
}
static void
inf_xmpp_connection_process_initiated(InfXmppConnection* xmpp,
                                      xmlNodePtr xml)
{
  InfXmppConnectionPrivate* priv;
  xmlNodePtr proceed;
  xmlChar* mech;
  gboolean has_mechanism;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;site == INF_XMPP_CONNECTION_SERVER);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED);
  if(priv-&gt;session == NULL &amp;&amp;
     priv-&gt;security_policy != INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED)
  {
    if(strcmp((const gchar*)xml-&gt;name, "starttls") == 0)
    {
      proceed = inf_xmpp_connection_node_new_tls("proceed");
      inf_xmpp_connection_send_xml(xmpp, proceed);
      xmlFreeNode(proceed);
      inf_xmpp_connection_tls_init(xmpp);
    }
    else if(priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS)
    {
      inf_xmpp_connection_terminate_error(
        xmpp,
        INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED,
        _("Stream is not yet secured with TLS")
      );
    }
  }
  if(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED)
  {
    g_assert(priv-&gt;sasl_context != NULL);
    if(strcmp((const gchar*)xml-&gt;name, "auth") == 0)
    {
      mech = xmlGetProp(xml, (const xmlChar*)"mechanism");
      has_mechanism = TRUE;
      if(mech == NULL)
      {
        has_mechanism = FALSE;
      }
      else if(!inf_sasl_context_server_supports_mechanism(priv-&gt;sasl_context,
                                                          (const char*)mech))
      {
        has_mechanism = FALSE;
      }
      else if(priv-&gt;sasl_own_context == NULL &amp;&amp;
              priv-&gt;sasl_local_mechanisms != NULL &amp;&amp;
              !inf_xmpp_connection_sasl_has_mechanism(
                  priv-&gt;sasl_local_mechanisms,
                  (const char*)mech))
      {
        has_mechanism = FALSE;
      }
      else if(priv-&gt;sasl_own_context != NULL &amp;&amp;
              g_ascii_strcasecmp((const char*)mech, "ANONYMOUS") != 0)
      {
        has_mechanism = FALSE;
      }
      if(has_mechanism)
      {
        inf_xmpp_connection_sasl_init(xmpp, (const gchar*)mech);
      }
      else
      {
        inf_xmpp_connection_send_auth_error(
          xmpp,
          INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM
        );
        inf_xmpp_connection_emit_auth_error(
          xmpp,
          INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM
        );
      }
      if(mech != NULL)
        xmlFree(mech);
    }
    else
    {
      inf_xmpp_connection_terminate_error(
        xmpp,
        INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED,
        _("Stream is not yet authorized")
      );
    }
  }
}
static void
inf_xmpp_connection_load_sasl_remote_mechanisms(InfXmppConnection* xmpp,
                                                xmlNodePtr xml)
{
  InfXmppConnectionPrivate* priv;
  GString* mechanisms_string;
  xmlNodePtr child;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;sasl_remote_mechanisms == NULL);
  mechanisms_string = g_string_sized_new(128);
  for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
  {
    if(strcmp((const gchar*)child-&gt;name, "mechanism") == 0 &amp;&amp;
       child-&gt;children != NULL &amp;&amp;
       child-&gt;children-&gt;content != NULL)
    {
      g_string_append(
        mechanisms_string,
        (const char*) child-&gt;children-&gt;content
      );
      if(child-&gt;next != NULL)
        g_string_append_c(mechanisms_string, ' ');
    }
  }
  priv-&gt;sasl_remote_mechanisms = g_string_free(mechanisms_string, FALSE);
}
static const gchar*
inf_xmpp_connection_sasl_suggest_mechanism(InfXmppConnection* xmpp,
                                           GError** error)
{
  InfXmppConnectionPrivate* priv;
  GString* mechanisms_string;
  GString* mechanism_string;
  char* iter;
  char* end;
  const gchar* suggestion;
  gboolean has_mechanism;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  suggestion = NULL;
  if(priv-&gt;sasl_own_context != NULL)
  {
    for(iter = priv-&gt;sasl_remote_mechanisms; *iter; iter = end + 1)
    {
      end = strchr(iter, ' ');
      if(end == NULL)
      {
        if(strcmp(iter, "ANONYMOUS") == 0)
          suggestion = "ANONYMOUS";
        break;
      }
      if(strncmp(iter, "ANONYMOUS",
                 MAX((size_t) (end - iter), sizeof("ANONYMOUS") - 1)) == 0)
      {
        suggestion = "ANONYMOUS";
        break;
      }
    }
  }
  else
  {
    mechanisms_string = g_string_sized_new(128);
    mechanism_string = g_string_sized_new(16);     for(end = iter = priv-&gt;sasl_remote_mechanisms; end; iter = end + 1)
    {
      end = strchr(iter, ' ');
      if(end != NULL)
      {
        g_string_overwrite_len(mechanism_string, 0, iter, end - iter);
        g_string_truncate(mechanism_string, end - iter);
        iter = mechanism_string-&gt;str;
      }
      has_mechanism =
        inf_sasl_context_client_supports_mechanism(priv-&gt;sasl_context, iter);
      if(has_mechanism == TRUE &amp;&amp; priv-&gt;sasl_local_mechanisms != NULL)
      {
        has_mechanism = inf_xmpp_connection_sasl_has_mechanism(
          priv-&gt;sasl_local_mechanisms,
          iter
        );
      }
      if(has_mechanism == TRUE)
      {
        if(mechanisms_string-&gt;len &gt; 0)
          g_string_append_c(mechanisms_string, ' ');
        g_string_append(mechanisms_string, iter);
      }
    }
    if(mechanisms_string-&gt;len &gt; 0)
    {
      suggestion = inf_sasl_context_client_suggest_mechanism(
        priv-&gt;sasl_context,
        mechanisms_string-&gt;str
      );
    }
    g_string_free(mechanisms_string, TRUE);
  }
  if(suggestion == NULL)
  {
    g_set_error_literal(
      error,
      inf_xmpp_connection_error_quark(),
      INF_XMPP_CONNECTION_ERROR_NO_SUITABLE_MECHANISM,
      _("The server does not offer a suitable authentication mechanism")
    );
  }
  return suggestion;
}
static void
inf_xmpp_connection_process_features(InfXmppConnection* xmpp,
                                     xmlNodePtr xml)
{
  InfXmppConnectionPrivate* priv;
  xmlNodePtr child;
  xmlNodePtr req;
  xmlNodePtr starttls;
  const char* suggestion;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES ||
           priv-&gt;status == INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES);
  if(strcmp((const gchar*)xml-&gt;name, "stream:features") != 0)
  {
    return;
  }
  else if(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES &amp;&amp;
          priv-&gt;session == NULL)
  {
    for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
      if(strcmp((const gchar*)child-&gt;name, "starttls") == 0)
        break;
    if(child == NULL &amp;&amp;
       priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS)
    {
      error = g_error_new_literal(
        inf_xmpp_connection_error_quark(),
        INF_XMPP_CONNECTION_ERROR_TLS_UNSUPPORTED,
        _("The server does not support transport layer security (TLS)")
      );
      inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
      g_error_free(error);
      inf_xmpp_connection_deinitiate(xmpp);
    }
    else if(child != NULL)
    {
      for(req = child-&gt;children; req != NULL; req = req-&gt;next)
        if(strcmp((const gchar*)req-&gt;name, "required") == 0)
          break;
      if(req != NULL &amp;&amp;
         priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED)
      {
        error = NULL;
        g_set_error_literal(
          &amp;error,
          inf_xmpp_connection_error_quark(),
          INF_XMPP_CONNECTION_ERROR_TLS_REQUIRED,
          _("The server requires transport layer security (TLS)")
        );
        inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
        g_error_free(error);
        inf_xmpp_connection_deinitiate(xmpp);
      }
      else if(req != NULL || inf_xmpp_connection_prefers_tls(xmpp))
      {
        starttls = inf_xmpp_connection_node_new_tls("starttls");
        inf_xmpp_connection_send_xml(xmpp, starttls);
        xmlFreeNode(starttls);
        priv-&gt;status = INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED;
      }
    }
  }
  if(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES)
  {
    for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
      if(strcmp((const gchar*)child-&gt;name, "mechanisms") == 0)
        break;
    if(child == NULL)
    {
      error = g_error_new_literal(
        inf_xmpp_connection_error_quark(),
        INF_XMPP_CONNECTION_ERROR_AUTHENTICATION_UNSUPPORTED,
        _("The server does not provide any authentication mechanism")
      );
      inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
      g_error_free(error);
      inf_xmpp_connection_deinitiate(xmpp);
    }
    else if(inf_xmpp_connection_sasl_ensure(xmpp) == TRUE)
    {
      inf_xmpp_connection_load_sasl_remote_mechanisms(xmpp, child);
      error = NULL;
      suggestion = inf_xmpp_connection_sasl_suggest_mechanism(xmpp, &amp;error);
      if(!suggestion)
      {
        inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
        g_error_free(error);
        if(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES)
          inf_xmpp_connection_deinitiate(xmpp);
      }
      else
      {
        inf_xmpp_connection_sasl_init(xmpp, suggestion);
      }
    }
  }
  else if(priv-&gt;status == INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES)
  {
    priv-&gt;status = INF_XMPP_CONNECTION_READY;
    g_object_notify(G_OBJECT(xmpp), "status");
  }
}
static void
inf_xmpp_connection_process_encryption(InfXmppConnection* xmpp,
                                       xmlNodePtr xml)
{
  InfXmppConnectionPrivate* priv;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED);
  g_assert(priv-&gt;session == NULL);
  if(strcmp((const gchar*)xml-&gt;name, "proceed") == 0)
  {
    inf_xmpp_connection_tls_init(xmpp);
  }
  else if(strcmp((const gchar*)xml-&gt;name, "failure") == 0)
  {
    error = g_error_new_literal(
      inf_xmpp_connection_error_quark(),
      INF_XMPP_CONNECTION_ERROR_TLS_FAILURE,
      _("The server cannot perform the TLS handshake")
    );
    inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
    g_error_free(error);
    priv-&gt;status = INF_XMPP_CONNECTION_CLOSING_STREAM;
    g_object_notify(G_OBJECT(xmpp), "status");
  }
  else
  {
  }
}
static void
inf_xmpp_connection_process_authentication_error(
  InfXmppConnection* xmpp,
  InfXmppConnectionAuthError auth_code)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING);
  inf_xmpp_connection_sasl_finish(xmpp, FALSE);
  inf_xmpp_connection_emit_auth_error(xmpp, auth_code);
  if(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES)
    inf_xmpp_connection_deinitiate(xmpp);
}
static void
inf_xmpp_connection_process_authentication(InfXmppConnection* xmpp,
                                           xmlNodePtr xml)
{
  InfXmppConnectionPrivate* priv;
  InfXmppConnectionAuthError auth_code;
  xmlNodePtr child;
  xmlNodePtr error_node;
  xmlChar* content;
  GError* local_error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING);
  switch(priv-&gt;site)
  {
  case INF_XMPP_CONNECTION_CLIENT:
    if(strcmp((const gchar*)xml-&gt;name, "challenge") == 0)
    {
      if(priv-&gt;sasl_session != NULL)
      {
        content = xmlNodeGetContent(xml);
        inf_xmpp_connection_sasl_request(xmpp, (const gchar*)content);
        xmlFree(content);
      }
    }
    else if(strcmp((const gchar*)xml-&gt;name, "failure") == 0)
    {
      child = xml-&gt;children;
      auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_FAILED;
      if(child != NULL)
      {
        error_node = child-&gt;children;
        if(error_node != NULL &amp;&amp;
           strcmp((const char*)error_node-&gt;name, "error") == 0)
        {
          g_assert(priv-&gt;sasl_error == NULL);
          priv-&gt;sasl_error = inf_xml_util_new_error_from_node(error_node);
        }
        auth_code = inf_xmpp_connection_auth_error_from_condition(
          (const gchar*)child-&gt;name
        );
      }
      inf_xmpp_connection_process_authentication_error(xmpp, auth_code);
    }
    else if(strcmp((const gchar*)xml-&gt;name, "success") == 0)
    {
      inf_xmpp_connection_sasl_finish(xmpp, TRUE);
    }
    else
    {
    }
    break;
  case INF_XMPP_CONNECTION_SERVER:
    if(strcmp((const gchar*)xml-&gt;name, "response") == 0)
    {
      if(priv-&gt;sasl_session != NULL)
      {
        content = xmlNodeGetContent(xml);
        inf_xmpp_connection_sasl_request(xmpp, (const gchar*)content);
        xmlFree(content);
      }
      else
      {
        inf_xmpp_connection_sasl_finish(xmpp, FALSE);
        local_error = g_error_new_literal(
          inf_authentication_detail_error_quark(),
          INF_AUTHENTICATION_DETAIL_ERROR_TRY_AGAIN,
          inf_authentication_detail_strerror(
            INF_AUTHENTICATION_DETAIL_ERROR_TRY_AGAIN)
        );
        inf_xmpp_connection_set_sasl_error(xmpp, local_error);
        g_error_free(local_error);
        inf_xmpp_connection_send_auth_error(
          xmpp,
          INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE
        );
        inf_xmpp_connection_emit_auth_error(
          xmpp,
          INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE
        );
        if(priv-&gt;sasl_error)
        {
          g_error_free(priv-&gt;sasl_error);
          priv-&gt;sasl_error = NULL;
        }
      }
    }
    else if(strcmp((const gchar*)xml-&gt;name, "abort") == 0)
    {
      inf_xmpp_connection_sasl_finish(xmpp, FALSE);
      inf_xmpp_connection_send_auth_error(
        xmpp,
        INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED
      );
      inf_xmpp_connection_emit_auth_error(
        xmpp,
        INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED
      );
    }
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_xmpp_connection_process_end_element(InfXmppConnection* xmpp,
                                        const xmlChar* name)
{
  InfXmppConnectionPrivate* priv;
  InfXmppConnectionStreamError stream_code;
  GError* error;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;cur != NULL);
  g_assert(strcmp((const gchar*)priv-&gt;cur-&gt;name, (const gchar*)name) == 0);
  priv-&gt;cur = priv-&gt;cur-&gt;parent;
  if(priv-&gt;cur == NULL)
  {
    if(strcmp((const gchar*)name, "stream:error") == 0)
    {
      stream_code = INF_XMPP_CONNECTION_STREAM_ERROR_FAILED;
      if(priv-&gt;root-&gt;children != NULL)
      {
        stream_code = inf_xmpp_connection_stream_error_from_condition(
          (const gchar*)priv-&gt;root-&gt;children-&gt;name
        );
      }
      error = NULL;
      g_set_error_literal(
        &amp;error,
        inf_xmpp_connection_stream_error_quark,
        stream_code,
        inf_xmpp_connection_stream_strerror(stream_code)
      );
      inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
      g_error_free(error);
    }
    else
    {
      switch(priv-&gt;status)
      {
      case INF_XMPP_CONNECTION_INITIATED:
        g_assert(priv-&gt;site == INF_XMPP_CONNECTION_SERVER);
        inf_xmpp_connection_process_initiated(xmpp, priv-&gt;root);
        break;
      case INF_XMPP_CONNECTION_AWAITING_FEATURES:
      case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
        g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
        inf_xmpp_connection_process_features(xmpp, priv-&gt;root);
        break;
      case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
        g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
        inf_xmpp_connection_process_encryption(xmpp, priv-&gt;root);
        break;
      case INF_XMPP_CONNECTION_AUTHENTICATING:
        inf_xmpp_connection_process_authentication(xmpp, priv-&gt;root);
        break;
      case INF_XMPP_CONNECTION_READY:
        inf_xml_connection_received(INF_XML_CONNECTION(xmpp), priv-&gt;root);
        break;
      case INF_XMPP_CONNECTION_CLOSING_STREAM:
        break;
      case INF_XMPP_CONNECTION_AUTH_INITIATED:
      case INF_XMPP_CONNECTION_CONNECTING:
      case INF_XMPP_CONNECTION_CONNECTED:
      case INF_XMPP_CONNECTION_AUTH_CONNECTED:
      case INF_XMPP_CONNECTION_HANDSHAKING:
      case INF_XMPP_CONNECTION_CLOSING_GNUTLS:
      case INF_XMPP_CONNECTION_CLOSED:
      default:
        g_assert_not_reached();
        break;
      }
    }
    xmlFreeNode(priv-&gt;root);
    priv-&gt;root = NULL;
    priv-&gt;cur = NULL;
  }
}
static void
inf_xmpp_connection_sax_start_element(void* context,
                                      const xmlChar* name,
                                      const xmlChar** attrs)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmpp = INF_XMPP_CONNECTION(context);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS)
    return;
  switch(priv-&gt;status)
  {
  case INF_XMPP_CONNECTION_CONNECTED:
  case INF_XMPP_CONNECTION_AUTH_CONNECTED:
    g_assert(priv-&gt;site == INF_XMPP_CONNECTION_SERVER);
    if(strcmp((const gchar*)name, "stream:stream") != 0)
    {
      inf_xmpp_connection_terminate(xmpp);
    }
    else
    {
      inf_xmpp_connection_process_connected(xmpp, attrs);
    }
    break;
  case INF_XMPP_CONNECTION_INITIATED:
  case INF_XMPP_CONNECTION_AUTH_INITIATED:
    if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
    {
      if(strcmp((const gchar*)name, "stream:stream") != 0)
      {
        inf_xmpp_connection_terminate(xmpp);
      }
      else
      {
        if(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED)
          priv-&gt;status = INF_XMPP_CONNECTION_AWAITING_FEATURES;
        else
          priv-&gt;status = INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES;
      }
    }
    else
    {
      inf_xmpp_connection_process_start_element(xmpp, name, attrs);
    }
    break;
  case INF_XMPP_CONNECTION_CLOSING_STREAM:
  case INF_XMPP_CONNECTION_AWAITING_FEATURES:
  case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
  case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
  case INF_XMPP_CONNECTION_AUTHENTICATING:
  case INF_XMPP_CONNECTION_READY:
    inf_xmpp_connection_process_start_element(xmpp, name, attrs);
    break;
  case INF_XMPP_CONNECTION_CLOSING_GNUTLS:
  case INF_XMPP_CONNECTION_HANDSHAKING:
  case INF_XMPP_CONNECTION_CLOSED:
  case INF_XMPP_CONNECTION_CONNECTING:
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_xmpp_connection_sax_end_element(void* context,
                                    const xmlChar* name)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmpp = INF_XMPP_CONNECTION(context);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING);
  if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS)
    return;
  if(priv-&gt;root != NULL)
  {
    inf_xmpp_connection_process_end_element(xmpp, name);
  }
  else
  {
    g_assert(strcmp((const gchar*)name, "stream:stream") == 0 ||
             priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS ||
             priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
    switch(priv-&gt;status)
    {
    case INF_XMPP_CONNECTION_CLOSING_STREAM:
    case INF_XMPP_CONNECTION_AUTHENTICATING:
    case INF_XMPP_CONNECTION_INITIATED:
    case INF_XMPP_CONNECTION_AUTH_INITIATED:
    case INF_XMPP_CONNECTION_AWAITING_FEATURES:
    case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
    case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
    case INF_XMPP_CONNECTION_READY:
      inf_xmpp_connection_terminate(xmpp);
      break;
    case INF_XMPP_CONNECTION_CLOSED:
    case INF_XMPP_CONNECTION_CLOSING_GNUTLS:
      break;
    case INF_XMPP_CONNECTION_CONNECTED:
    case INF_XMPP_CONNECTION_AUTH_CONNECTED:
    case INF_XMPP_CONNECTION_HANDSHAKING:
    case INF_XMPP_CONNECTION_CONNECTING:
    default:
      g_assert_not_reached();
      break;
    }
  }
}
static void
inf_xmpp_connection_sax_characters(void* context,
                                   const xmlChar* content,
                                   int len)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmpp = INF_XMPP_CONNECTION(context);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING);
  if(priv-&gt;root == NULL)
  {
  }
  else
  {
    g_assert(priv-&gt;cur != NULL);
    xmlNodeAddContentLen(priv-&gt;cur, content, len);
  }
}
static void
inf_xmpp_connection_sax_warning(void* context,
                                const char* msg,
                                ...)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  InfIpAddress* address;
  gchar* addr_str;
  gchar* warn_str;
  va_list arglist;
  xmpp = INF_XMPP_CONNECTION(context);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_object_get(G_OBJECT(priv-&gt;tcp), "remote-address", &amp;address, NULL);
  addr_str = inf_ip_address_to_string(address);
  inf_ip_address_free(address);
  va_start(arglist, msg);
  warn_str = g_strdup_vprintf(msg, arglist);
  va_end(arglist);
  g_warning(_("XML warning from %s: %s\n"), addr_str, warn_str);
  g_free(addr_str);
  g_free(warn_str);
}
static void
inf_xmpp_connection_sax_error(void* context,
                              const char* msg,
                              ...)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  InfXmppConnectionStreamError stream_code;
  xmlErrorPtr error_xml;
  const gchar* message;
  xmpp = INF_XMPP_CONNECTION(context);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  error_xml = xmlCtxtGetLastError(priv-&gt;parser);
  g_assert(error_xml != NULL);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING);
  if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS)
    return;
  if(priv-&gt;status != INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED &amp;&amp;
     priv-&gt;status != INF_XMPP_CONNECTION_CONNECTED &amp;&amp;
     priv-&gt;status != INF_XMPP_CONNECTION_AUTH_CONNECTED)
  {
    stream_code = INF_XMPP_CONNECTION_STREAM_ERROR_BAD_FORMAT;
    if(error_xml-&gt;domain == XML_FROM_PARSER &amp;&amp;
       error_xml-&gt;code == XML_ERR_DOCUMENT_EMPTY)
    {
      message = _("Remote site is not an XMPP server");
    }
    else
    {
      message = error_xml-&gt;message;
    }
    inf_xmpp_connection_terminate_error(xmpp, stream_code, message);
  }
  else
  {
    inf_xmpp_connection_terminate(xmpp);
<a name="1"></a>  }
}
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static xmlSAXHandler inf_xmpp_connection_handler = {
  NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     inf_xmpp_connection_sax_start_element,    inf_xmpp_connection_sax_end_element,      NULL,                                     inf_xmpp_connection_sax_characters,       NULL,                                     NULL,                                     NULL,                                     inf_xmpp_connection_sax_warning,          inf_xmpp_connection_sax_error,            inf_xmpp_connection_sax_error,            NULL,                                     NULL,                                     NULL,                                     0,                                        NULL,                                     NULL,                                     NULL,                                     NULL                                    };
static void
inf_xmpp_connection_initiate(InfXmppConnection* xmpp)
{
  static const gchar xmpp_connection_initial_request[] =
    "&lt;stream:stream version=\"1.0\" xmlns=\"jabber:client\" "
    "xmlns:stream=\"http://etherx.jabber.org/streams\" to=\"%s\"&gt;";
  InfXmppConnectionPrivate* priv;
  gchar* request;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
           priv-&gt;status == INF_XMPP_CONNECTION_AUTH_CONNECTED);
  if(priv-&gt;parser != NULL) xmlFreeParserCtxt(priv-&gt;parser);
  priv-&gt;parser = xmlCreatePushParserCtxt(
    &amp;inf_xmpp_connection_handler,
    xmpp,
    NULL,
    0,
    NULL
  );
  if(priv-&gt;buf == NULL)
  {
    priv-&gt;buf = xmlBufferCreate();
    priv-&gt;doc = xmlNewDoc((const xmlChar*)"1.0");
  }
  if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
  {
    request = g_strdup_printf(
      xmpp_connection_initial_request,
      priv-&gt;remote_hostname
    );
    inf_xmpp_connection_send_chars(xmpp, request, strlen(request));
    g_free(request);
    switch(priv-&gt;status)
    {
    case INF_XMPP_CONNECTION_CONNECTED:
      priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
      break;
    case INF_XMPP_CONNECTION_AUTH_CONNECTED:
      priv-&gt;status = INF_XMPP_CONNECTION_AUTH_INITIATED;
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
}
static void
inf_xmpp_connection_received_cb_sent_func(InfXmppConnection* xmpp,
                                          gpointer user_data)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  inf_tcp_connection_close(priv-&gt;tcp);
}
static void
inf_xmpp_connection_sent_cb(InfTcpConnection* tcp,
                            gconstpointer data,
                            guint len,
                            gpointer user_data)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  InfXmppConnectionMessage* message;
  gboolean have_sent;
  xmpp = INF_XMPP_CONNECTION(user_data);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_assert(priv-&gt;position &gt;= len);
  g_object_ref(G_OBJECT(xmpp));
  priv-&gt;position -= len;
  if(priv-&gt;messages != NULL)
  {
    have_sent = priv-&gt;messages-&gt;sent;
    for(message = priv-&gt;messages; message != NULL; message = message-&gt;next)
    {
      if(!message-&gt;sent)
      {
        if(message-&gt;position &lt;= len)
          message-&gt;sent = TRUE;
        else
          message-&gt;position -= len;
      }
    }
    if(have_sent == FALSE)
    {
      while(priv-&gt;messages != NULL &amp;&amp; priv-&gt;messages-&gt;sent)
      {
        if(priv-&gt;messages-&gt;sent_func != NULL)
          priv-&gt;messages-&gt;sent_func(xmpp, priv-&gt;messages-&gt;user_data);
        if(priv-&gt;messages != NULL)
          inf_xmpp_connection_pop_message(xmpp);
      }
    }
  }
  g_object_unref(G_OBJECT(xmpp));
}
static void
inf_xmpp_connection_received_cb(InfTcpConnection* tcp,
                                gconstpointer data,
                                guint len,
                                gpointer user_data)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  gchar buffer[2048];
  ssize_t res;
  GError* error;
  gboolean receiving;
  xmpp = INF_XMPP_CONNECTION(user_data);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS)
    return;
  g_object_ref(xmpp);
  g_assert(priv-&gt;parsing == 0);
  g_assert(priv-&gt;parser != NULL);
  ++priv-&gt;parsing;
  if(priv-&gt;session != NULL)
  {
    g_assert(priv-&gt;pull_len == 0);
    priv-&gt;pull_data = data;
    priv-&gt;pull_len = len;
  }
  if(priv-&gt;status == INF_XMPP_CONNECTION_HANDSHAKING)
  {
    g_assert(priv-&gt;session != NULL);
    inf_xmpp_connection_tls_handshake(xmpp);
  }
  if(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING &amp;&amp;
     priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_GNUTLS)
  {
    if(priv-&gt;session != NULL)
    {
      receiving = TRUE;
      while(receiving &amp;&amp; (priv-&gt;pull_len &gt; 0 ||
                          gnutls_record_check_pending(priv-&gt;session) &gt; 0))
      {
        res = gnutls_record_recv(priv-&gt;session, buffer, 2048);
        if(res &lt; 0)
        {
          if(res != GNUTLS_E_INTERRUPTED &amp;&amp; res != GNUTLS_E_AGAIN)
          {
            error = NULL;
            inf_gnutls_set_error(&amp;error, res);
            inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
            g_error_free(error);
            inf_tcp_connection_close(priv-&gt;tcp);
            receiving = FALSE;
          }
        }
        else if(res == 0)
        {
          inf_tcp_connection_close(priv-&gt;tcp);
          receiving = FALSE;
        }
        else
        {
          if(INF_XMPP_CONNECTION_PRINT_TRAFFIC)
            printf("\033[00;32m%.*s\033[00;00m\n", (int)res, buffer);
          xmlParseChunk(priv-&gt;parser, buffer, res, 0);
          if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS ||
             priv-&gt;status == INF_XMPP_CONNECTION_CLOSED)
          {
            receiving = FALSE;
          }
        }
      }
    }
    else
    {
      if(INF_XMPP_CONNECTION_PRINT_TRAFFIC)
        printf("\033[00;31m%.*s\033[00;00m\n", (int)len, (const char*)data);
      xmlParseChunk(priv-&gt;parser, data, len, 0);
    }
  }
  g_assert(priv-&gt;parsing &gt; 0);
  if(--priv-&gt;parsing == 0)
  {
    if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS ||
       priv-&gt;status == INF_XMPP_CONNECTION_CLOSED)
    {
      inf_xmpp_connection_clear(xmpp);
      if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED)
      {
        inf_xmpp_connection_push_message(
          xmpp,
          inf_xmpp_connection_received_cb_sent_func,
          NULL,
          NULL
        );
      }
      g_object_notify(G_OBJECT(xmpp), "status");
    }
    else if(priv-&gt;status == INF_XMPP_CONNECTION_AUTH_CONNECTED)
    {
      inf_xmpp_connection_initiate(xmpp);
    }
  }
  g_object_unref(xmpp);
}
static void
inf_xmpp_connection_error_cb(InfTcpConnection* tcp,
                             GError* error,
                             gpointer user_data)
{
  inf_xml_connection_error(INF_XML_CONNECTION(user_data), error);
}
static void
inf_xmpp_connection_notify_status_cb(InfTcpConnection* tcp,
                                     GParamSpec* pspec,
                                     gpointer user_data)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  InfTcpConnectionStatus tcp_status;
  xmpp = INF_XMPP_CONNECTION(user_data);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
  switch(tcp_status)
  {
  case INF_TCP_CONNECTION_CLOSED:
    if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED)
    {
      if(priv-&gt;parsing == 0)
        inf_xmpp_connection_clear(xmpp);
      priv-&gt;status = INF_XMPP_CONNECTION_CLOSED;
      priv-&gt;position = 0;
      if(priv-&gt;parsing == 0)
        g_object_notify(G_OBJECT(xmpp), "status");
    }
    else
    {
      g_assert(priv-&gt;session == NULL);
      g_assert(priv-&gt;messages == NULL);
      g_assert(priv-&gt;parser == NULL);
      g_assert(priv-&gt;doc == NULL);
      g_assert(priv-&gt;position == 0);
      g_assert(priv-&gt;sasl_session == NULL);
    }
    break;
  case INF_TCP_CONNECTION_CONNECTING:
    g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
    if(priv-&gt;status != INF_XMPP_CONNECTION_CONNECTING)
    {
      priv-&gt;status = INF_XMPP_CONNECTION_CONNECTING;
      g_object_notify(G_OBJECT(xmpp), "status");
    }
    break;
  case INF_TCP_CONNECTION_CONNECTED:
    if(priv-&gt;own_cert != NULL)
    {
      gnutls_x509_crt_deinit(priv-&gt;own_cert);
      priv-&gt;own_cert = NULL;
      g_object_notify(G_OBJECT(xmpp), "local-certificate");
    }
    if(priv-&gt;peer_cert != NULL)
    {
      inf_certificate_chain_unref(priv-&gt;peer_cert);
      priv-&gt;peer_cert = NULL;
      g_object_notify(G_OBJECT(xmpp), "remote-certificate");
    }
    g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTING);
    priv-&gt;status = INF_XMPP_CONNECTION_CONNECTED;
    inf_xmpp_connection_initiate(xmpp);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_xmpp_connection_set_tcp(InfXmppConnection* xmpp,
                            InfTcpConnection* tcp)
{
  InfXmppConnectionPrivate* priv;
  InfTcpConnectionStatus tcp_status;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_object_freeze_notify(G_OBJECT(xmpp));
  if(priv-&gt;tcp != NULL)
  {
    g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;tcp_status, NULL);
    if(tcp_status != INF_TCP_CONNECTION_CLOSED)
      inf_tcp_connection_close(priv-&gt;tcp);
    g_assert(priv-&gt;sasl_session == NULL);
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(inf_xmpp_connection_sent_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(inf_xmpp_connection_received_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(inf_xmpp_connection_error_cb),
      xmpp
    );
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;tcp),
      G_CALLBACK(inf_xmpp_connection_notify_status_cb),
      xmpp
    );
    g_object_unref(G_OBJECT(priv-&gt;tcp));
  }
  priv-&gt;tcp = tcp;
  if(tcp != NULL)
  {
    g_object_ref(G_OBJECT(tcp));
    g_signal_connect(
      G_OBJECT(tcp),
      "sent",
      G_CALLBACK(inf_xmpp_connection_sent_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "received",
      G_CALLBACK(inf_xmpp_connection_received_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "error",
      G_CALLBACK(inf_xmpp_connection_error_cb),
      xmpp
    );
    g_signal_connect(
      G_OBJECT(tcp),
      "notify::status",
      G_CALLBACK(inf_xmpp_connection_notify_status_cb),
      xmpp
    );
    g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
    switch(tcp_status)
    {
    case INF_TCP_CONNECTION_CLOSED:
      g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
      break;
    case INF_TCP_CONNECTION_CONNECTING:
      priv-&gt;status = INF_XMPP_CONNECTION_CONNECTING;
      g_object_notify(G_OBJECT(xmpp), "status");
      break;
    case INF_TCP_CONNECTION_CONNECTED:
      priv-&gt;status = INF_XMPP_CONNECTION_CONNECTED;
      g_object_notify(G_OBJECT(xmpp), "status");
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  g_object_thaw_notify(G_OBJECT(xmpp));
}
static InfXmlConnectionStatus
inf_xmpp_connection_get_xml_status(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  switch(priv-&gt;status)
  {
  case INF_XMPP_CONNECTION_CONNECTING:
  case INF_XMPP_CONNECTION_CONNECTED:
  case INF_XMPP_CONNECTION_AUTH_CONNECTED:
  case INF_XMPP_CONNECTION_INITIATED:
  case INF_XMPP_CONNECTION_AUTH_INITIATED:
  case INF_XMPP_CONNECTION_AWAITING_FEATURES:
  case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
  case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
  case INF_XMPP_CONNECTION_HANDSHAKING:
  case INF_XMPP_CONNECTION_AUTHENTICATING:
    return INF_XML_CONNECTION_OPENING;
  case INF_XMPP_CONNECTION_READY:
    return INF_XML_CONNECTION_OPEN;
  case INF_XMPP_CONNECTION_CLOSING_STREAM:
  case INF_XMPP_CONNECTION_CLOSING_GNUTLS:
    return INF_XML_CONNECTION_CLOSING;
  case INF_XMPP_CONNECTION_CLOSED:
    return INF_XML_CONNECTION_CLOSED;
  default:
    g_assert_not_reached();
    return INF_XML_CONNECTION_CLOSED;
  }
}
static gchar*
inf_xmpp_connection_get_address_id(InfIpAddress* addr,
                                   guint port)
{
  gchar* addr_str;
  gchar* addr_id;
  addr_str = inf_ip_address_to_string(addr);
  switch(inf_ip_address_get_family(addr))
  {
  case INF_IP_ADDRESS_IPV4:
    addr_id = g_strdup_printf("%s:%u", addr_str, port);
    break;
  case INF_IP_ADDRESS_IPV6:
    addr_id = g_strdup_printf("[%s]:%u", addr_str, port);
    break;
  default:
    g_assert_not_reached();
    break;
  }
  g_free(addr_str);
  return addr_id;
}
static void
inf_xmpp_connection_init(InfXmppConnection* connection)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(connection);
  priv-&gt;tcp = NULL;
  priv-&gt;site = INF_XMPP_CONNECTION_CLIENT;
  priv-&gt;status = INF_XMPP_CONNECTION_CLOSED;
  priv-&gt;local_hostname = NULL;
  priv-&gt;remote_hostname = NULL;
  priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS;
  priv-&gt;certificate_request = GNUTLS_CERT_IGNORE;
  priv-&gt;certificate_callback = NULL;
  priv-&gt;certificate_callback_user_data = NULL;
  priv-&gt;certificate_callback_notify = NULL;
  priv-&gt;position = 0;
  priv-&gt;messages = NULL;
  priv-&gt;last_message = NULL;
  priv-&gt;parsing = 0;
  priv-&gt;parser = NULL;
  priv-&gt;root = NULL;
  priv-&gt;cur = NULL;
  priv-&gt;doc = NULL;
  priv-&gt;buf = NULL;
  priv-&gt;session = NULL;
  priv-&gt;creds = NULL;
  priv-&gt;own_cert = NULL;
  priv-&gt;peer_cert = NULL;
  priv-&gt;pull_data = NULL;
  priv-&gt;pull_len = 0;
  priv-&gt;sasl_context = NULL;
  priv-&gt;sasl_own_context = NULL;
  priv-&gt;sasl_session = NULL;
  priv-&gt;sasl_local_mechanisms = NULL;
  priv-&gt;sasl_remote_mechanisms = NULL;
  priv-&gt;sasl_error = NULL;
}
static void
inf_xmpp_connection_constructed(GObject* object)
{
  InfXmppConnectionPrivate* priv;
  InfTcpConnectionStatus status;
  G_OBJECT_CLASS(inf_xmpp_connection_parent_class)-&gt;constructed(object);
  priv = INF_XMPP_CONNECTION_PRIVATE(object);
  g_assert(priv-&gt;tcp != NULL);
  if(priv-&gt;local_hostname == NULL)
    priv-&gt;local_hostname = g_strdup(g_get_host_name());
  g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;status, NULL);
  if(status == INF_TCP_CONNECTION_CONNECTED)
    inf_xmpp_connection_initiate(INF_XMPP_CONNECTION(object));
  g_assert(
    priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
    priv-&gt;site == INF_XMPP_CONNECTION_CLIENT ||
    priv-&gt;creds != NULL
  );
}
static void
inf_xmpp_connection_dispose(GObject* object)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmpp = INF_XMPP_CONNECTION(object);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  inf_xmpp_connection_set_tcp(xmpp, NULL);
  g_assert(priv-&gt;session == NULL);
  g_assert(priv-&gt;sasl_session == NULL);
  if(priv-&gt;own_cert != NULL)
  {
    gnutls_x509_crt_deinit(priv-&gt;own_cert);
    priv-&gt;own_cert = NULL;
    g_object_notify(G_OBJECT(xmpp), "local-certificate");
  }
  if(priv-&gt;peer_cert != NULL)
  {
    inf_certificate_chain_unref(priv-&gt;peer_cert);
    priv-&gt;peer_cert = NULL;
    g_object_notify(G_OBJECT(xmpp), "remote-certificate");
  }
  if(priv-&gt;sasl_own_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_own_context);
    priv-&gt;sasl_own_context = NULL;
  }
  if(priv-&gt;sasl_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = NULL;
  }
  if(priv-&gt;creds != NULL)
  {
    inf_certificate_credentials_unref(priv-&gt;creds);
    priv-&gt;creds = NULL;
  }
  G_OBJECT_CLASS(inf_xmpp_connection_parent_class)-&gt;dispose(object);
}
static void
inf_xmpp_connection_finalize(GObject* object)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmpp = INF_XMPP_CONNECTION(object);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_free(priv-&gt;local_hostname);
  g_free(priv-&gt;remote_hostname);
  g_free(priv-&gt;sasl_local_mechanisms);
  g_free(priv-&gt;sasl_remote_mechanisms);
  if(priv-&gt;certificate_callback_notify != NULL)
    priv-&gt;certificate_callback_notify(priv-&gt;certificate_callback_user_data);
  if(priv-&gt;sasl_error)
    g_error_free(priv-&gt;sasl_error);
  G_OBJECT_CLASS(inf_xmpp_connection_parent_class)-&gt;finalize(object);
}
static void
inf_xmpp_connection_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  xmpp = INF_XMPP_CONNECTION(object);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  switch(prop_id)
  {
  case PROP_TCP:
    inf_xmpp_connection_set_tcp(
      xmpp,
      INF_TCP_CONNECTION(g_value_get_object(value))
    );
    break;
  case PROP_SITE:
    g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTING ||
             priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
             priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
    priv-&gt;site = g_value_get_enum(value);
    break;
  case PROP_LOCAL_HOSTNAME:
    g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTING ||
             priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
             priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
    g_free(priv-&gt;local_hostname);
    priv-&gt;local_hostname = g_value_dup_string(value);
    if(priv-&gt;local_hostname == NULL)
      priv-&gt;local_hostname = g_strdup(g_get_host_name());
    break;
  case PROP_REMOTE_HOSTNAME:
    g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTING ||
             priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
             priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
    g_free(priv-&gt;remote_hostname);
    priv-&gt;remote_hostname = g_value_dup_string(value);
    break;
  case PROP_SECURITY_POLICY:
    priv-&gt;security_policy = g_value_get_enum(value);
    break;
  case PROP_CREDENTIALS:
    g_assert(priv-&gt;session == NULL);
    if(priv-&gt;creds != NULL) inf_certificate_credentials_unref(priv-&gt;creds);
    priv-&gt;creds = g_value_dup_boxed(value);
    break;
  case PROP_SASL_CONTEXT:
    g_assert(priv-&gt;sasl_session == NULL);
    if(priv-&gt;sasl_own_context != NULL)
    {
      inf_sasl_context_unref(priv-&gt;sasl_own_context);
      priv-&gt;sasl_own_context = NULL;
    }
    if(priv-&gt;sasl_context != NULL)
      inf_sasl_context_unref(priv-&gt;sasl_context);
    priv-&gt;sasl_context = g_value_dup_boxed(value);
    break;
  case PROP_SASL_MECHANISMS:
    g_assert(priv-&gt;sasl_session == NULL);
<a name="0"></a>
    g_free(priv-&gt;sasl_local_mechanisms);
    priv-&gt;sasl_local_mechanisms = g_value_dup_string(value);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_xmpp_connection_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfXmppConnection* xmpp;
  InfXmppConnectionPrivate* priv;
  InfIpAddress* addr;
  guint port;
  gchar* id;
  xmpp = INF_XMPP_CONNECTION(object);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  switch(prop_id)
  {
  case PROP_TCP:
    g_value_set_object(value, G_OBJECT(priv-&gt;tcp));
    break;</b></font>
  case PROP_SITE:
    g_value_set_enum(value, priv-&gt;site);
    break;
  case PROP_LOCAL_HOSTNAME:
    g_value_set_string(value, priv-&gt;local_hostname);
    break;
  case PROP_REMOTE_HOSTNAME:
    g_value_set_string(value, priv-&gt;remote_hostname);
    break;
  case PROP_SECURITY_POLICY:
    g_value_set_enum(value, priv-&gt;security_policy);
    break;
  case PROP_TLS_ENABLED:
    g_value_set_boolean(value, inf_xmpp_connection_get_tls_enabled(xmpp));
    break;
  case PROP_CREDENTIALS:
    g_value_set_boxed(value, priv-&gt;creds);
    break;
  case PROP_SASL_CONTEXT:
    g_value_set_boxed(value, priv-&gt;sasl_context);
    break;
  case PROP_SASL_MECHANISMS:
    g_value_set_string(value, priv-&gt;sasl_local_mechanisms);
    break;
  case PROP_STATUS:
    g_value_set_enum(value, inf_xmpp_connection_get_xml_status(xmpp));
    break;
  case PROP_NETWORK:
    g_value_set_static_string(value, "tcp/ip");
    break;
  case PROP_LOCAL_ID:
    g_object_get(
      G_OBJECT(priv-&gt;tcp),
      "local-address", &amp;addr,
      "local-port", &amp;port,
      NULL
    );
    id = inf_xmpp_connection_get_address_id(addr, port);
    inf_ip_address_free(addr);
    g_value_take_string(value, id);
    break;
  case PROP_REMOTE_ID:
    addr = inf_tcp_connection_get_remote_address(priv-&gt;tcp);
    port = inf_tcp_connection_get_remote_port(priv-&gt;tcp);
    id = inf_xmpp_connection_get_address_id(addr, port);
    g_value_take_string(value, id);
    break;
  case PROP_LOCAL_CERTIFICATE:
    g_value_set_pointer(value, priv-&gt;own_cert);
    break;
  case PROP_REMOTE_CERTIFICATE:
    g_value_set_boxed(value, priv-&gt;peer_cert);
    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}
static void
inf_xmpp_connection_xml_connection_send_sent(InfXmppConnection* xmpp,
                                             gpointer xml)
{
  inf_xml_connection_sent(INF_XML_CONNECTION(xmpp), (xmlNodePtr)xml);
}
static void
inf_xmpp_connection_xml_connection_send_free(InfXmppConnection* xmpp,
                                             gpointer xml)
{
  xmlFreeNode((xmlNodePtr)xml);
}
static gboolean
inf_xmpp_connection_xml_connection_open(InfXmlConnection* connection,
                                        GError** error)
{
  InfXmppConnectionPrivate* priv;
  InfTcpConnectionStatus status;
  priv = INF_XMPP_CONNECTION_PRIVATE(connection);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
  g_assert(priv-&gt;tcp != NULL);
  g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;status, NULL);
  g_assert(status == INF_TCP_CONNECTION_CLOSED);
  return inf_tcp_connection_open(priv-&gt;tcp, error);
}
static void
inf_xmpp_connection_xml_connection_close(InfXmlConnection* connection)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(connection);
  g_assert(priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_STREAM &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_GNUTLS &amp;&amp;
           priv-&gt;status != INF_XMPP_CONNECTION_CLOSED);
  switch(priv-&gt;status)
  {
  case INF_XMPP_CONNECTION_CONNECTING:
    inf_tcp_connection_close(priv-&gt;tcp);
    break;
  case INF_XMPP_CONNECTION_CONNECTED:
  case INF_XMPP_CONNECTION_AUTH_CONNECTED:
    g_assert(priv-&gt;parsing == 0);
    inf_xmpp_connection_terminate(INF_XMPP_CONNECTION(connection));
    break;
  case INF_XMPP_CONNECTION_HANDSHAKING:
  case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
    g_assert(priv-&gt;session != NULL);
    gnutls_deinit(priv-&gt;session);
    priv-&gt;session = NULL;
    inf_tcp_connection_close(priv-&gt;tcp);
    break;
  case INF_XMPP_CONNECTION_AUTHENTICATING:
    g_assert(priv-&gt;parsing == 0);
    inf_xmpp_connection_terminate(INF_XMPP_CONNECTION(connection));
    break;
  case INF_XMPP_CONNECTION_INITIATED:
  case INF_XMPP_CONNECTION_AUTH_INITIATED:
  case INF_XMPP_CONNECTION_AWAITING_FEATURES:
  case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
  case INF_XMPP_CONNECTION_READY:
    inf_xmpp_connection_deinitiate(INF_XMPP_CONNECTION(connection));
    break;
  default:
    g_assert_not_reached();
    break;
  }
}
static void
inf_xmpp_connection_xml_connection_send(InfXmlConnection* connection,
                                        xmlNodePtr xml)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(connection);
  g_assert(priv-&gt;status == INF_XMPP_CONNECTION_READY);
  inf_xmpp_connection_send_xml(INF_XMPP_CONNECTION(connection), xml);
  if(priv-&gt;status == INF_XMPP_CONNECTION_READY)
  {
    inf_xmpp_connection_push_message(
      INF_XMPP_CONNECTION(connection),
      inf_xmpp_connection_xml_connection_send_sent,
      inf_xmpp_connection_xml_connection_send_free,
      xml
    );
  }
  else
  {
    xmlFreeNode(xml);
  }
}
static void
inf_xmpp_connection_class_init(InfXmppConnectionClass* xmpp_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(xmpp_class);
  object_class-&gt;constructed = inf_xmpp_connection_constructed;
  object_class-&gt;dispose = inf_xmpp_connection_dispose;
  object_class-&gt;finalize = inf_xmpp_connection_finalize;
  object_class-&gt;set_property = inf_xmpp_connection_set_property;
  object_class-&gt;get_property = inf_xmpp_connection_get_property;
  inf_xmpp_connection_stream_error_quark = g_quark_from_static_string(
    "INF_XMPP_CONNECTION_STREAM_ERROR"
  );
  inf_xmpp_connection_auth_error_quark = g_quark_from_static_string(
    "INF_XMPP_CONNECTION_AUTH_ERROR"
  );
  g_object_class_install_property(
    object_class,
    PROP_TCP,
    g_param_spec_object(
      "tcp-connection",
      "TCP connection",
      "Underlaying TCP connection",
      INF_TYPE_TCP_CONNECTION,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SITE,
    g_param_spec_enum(
      "site",
      "Site",
      "Site of the connection (client or server)",
      INF_TYPE_XMPP_CONNECTION_SITE,
      INF_XMPP_CONNECTION_CLIENT,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_LOCAL_HOSTNAME,
    g_param_spec_string(
      "local-hostname",
      "Local hostname",
      "The hostname of the local host",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_REMOTE_HOSTNAME,
    g_param_spec_string(
      "remote-hostname",
      "Remote hostname",
      "The hostname of the remote host",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SECURITY_POLICY,
    g_param_spec_enum(
      "security-policy",
      "Security policy",
      "How to choose whether to use (or offer, as a server) TLS",
      INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
      INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_TLS_ENABLED,
    g_param_spec_boolean(
      "tls-enabled",
      "TLS enabled",
      "Whether TLS is enabled for the connection or not",
      FALSE,
      G_PARAM_READABLE
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_CREDENTIALS,
    g_param_spec_boxed(
      "credentials",
      "Credentials",
      "The certificate credentials for GnuTLS",
      INF_TYPE_CERTIFICATE_CREDENTIALS,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_CONTEXT,
    g_param_spec_boxed(
      "sasl-context",
      "SASL context",
      "The SASL context used for authentication",
      INF_TYPE_SASL_CONTEXT,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_install_property(
    object_class,
    PROP_SASL_MECHANISMS,
    g_param_spec_string(
      "sasl-mechanisms",
      "SASL Mechanisms",
      "Whitespace separated list of SASL mechanisms to accept/offer",
      NULL,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT
    )
  );
  g_object_class_override_property(object_class, PROP_STATUS, "status");
  g_object_class_override_property(object_class, PROP_NETWORK, "network");
  g_object_class_override_property(object_class, PROP_LOCAL_ID, "local-id");
  g_object_class_override_property(object_class, PROP_REMOTE_ID, "remote-id");
  g_object_class_override_property(
    object_class,
    PROP_LOCAL_CERTIFICATE,
    "local-certificate"
  );
  g_object_class_override_property(
    object_class,
    PROP_REMOTE_CERTIFICATE,
    "remote-certificate"
  );
}
static void
inf_xmpp_connection_xml_connection_iface_init(
  InfXmlConnectionInterface* iface)
{
  iface-&gt;open = inf_xmpp_connection_xml_connection_open;
  iface-&gt;close = inf_xmpp_connection_xml_connection_close;
  iface-&gt;send = inf_xmpp_connection_xml_connection_send;
}
InfXmppConnection*
inf_xmpp_connection_new(InfTcpConnection* tcp,
                        InfXmppConnectionSite site,
                        const gchar* local_hostname,
                        const gchar* remote_hostname,
                        InfXmppConnectionSecurityPolicy security_policy,
                        InfCertificateCredentials* creds,
                        InfSaslContext* sasl_context,
                        const gchar* sasl_mechanisms)
{
  GObject* object;
  g_return_val_if_fail(INF_IS_TCP_CONNECTION(tcp), NULL);
  g_return_val_if_fail(
    security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
    site == INF_XMPP_CONNECTION_CLIENT || creds != NULL,
    NULL
  );
  object = g_object_new(
    INF_TYPE_XMPP_CONNECTION,
    "tcp-connection", tcp,
    "site", site,
    "local-hostname", local_hostname,
    "remote-hostname", remote_hostname,
    "security-policy", security_policy,
    "credentials", creds,
    "sasl-context", sasl_context,
    "sasl-mechanisms", sasl_mechanisms,
    NULL
  );
  return INF_XMPP_CONNECTION(object);
}
gboolean
inf_xmpp_connection_get_tls_enabled(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), FALSE);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;status == INF_XMPP_CONNECTION_HANDSHAKING) return FALSE;
  if(priv-&gt;session == NULL) return FALSE;
  return TRUE;
}
gnutls_x509_crt_t
inf_xmpp_connection_get_own_certificate(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), NULL);
  g_return_val_if_fail(inf_xmpp_connection_get_tls_enabled(xmpp), NULL);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  return priv-&gt;own_cert;
}
InfCertificateChain*
inf_xmpp_connection_get_peer_certificate(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), NULL);
  g_return_val_if_fail(inf_xmpp_connection_get_tls_enabled(xmpp), NULL);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  return priv-&gt;peer_cert;
}
gnutls_kx_algorithm_t
inf_xmpp_connection_get_kx_algorithm(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), GNUTLS_KX_UNKNOWN);
  g_return_val_if_fail(
    inf_xmpp_connection_get_tls_enabled(xmpp),
    GNUTLS_KX_UNKNOWN
  );
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  return gnutls_kx_get(priv-&gt;session);
}
gnutls_cipher_algorithm_t
inf_xmpp_connection_get_cipher_algorithm(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), GNUTLS_CIPHER_UNKNOWN);
  g_return_val_if_fail(
    inf_xmpp_connection_get_tls_enabled(xmpp),
    GNUTLS_CIPHER_UNKNOWN
  );
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  return gnutls_cipher_get(priv-&gt;session);
}
gnutls_mac_algorithm_t
inf_xmpp_connection_get_mac_algorithm(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), GNUTLS_MAC_UNKNOWN);
  g_return_val_if_fail(
    inf_xmpp_connection_get_tls_enabled(xmpp),
    GNUTLS_MAC_UNKNOWN
  );
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  return gnutls_mac_get(priv-&gt;session);
}
gnutls_protocol_t
inf_xmpp_connection_get_tls_protocol(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), GNUTLS_VERSION_UNKNOWN);
  g_return_val_if_fail(
    inf_xmpp_connection_get_tls_enabled(xmpp),
    GNUTLS_VERSION_UNKNOWN
  );
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  return gnutls_protocol_get_version(priv-&gt;session);
}
guint
inf_xmpp_connection_get_dh_prime_bits(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  int bits;
  g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), 0);
  g_return_val_if_fail(inf_xmpp_connection_get_tls_enabled(xmpp), 0);
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  bits = gnutls_dh_get_prime_bits(priv-&gt;session);
  if(bits &lt; 0) bits = 0;
  return (guint)bits;
}
void
inf_xmpp_connection_set_certificate_callback(InfXmppConnection* xmpp,
                                             gnutls_certificate_request_t req,
                                             InfXmppConnectionCrtCallback cb,
                                             gpointer user_data,
                                             GDestroyNotify notify)
{
  InfXmppConnectionPrivate* priv;
  g_return_if_fail(INF_IS_XMPP_CONNECTION(xmpp));
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;certificate_callback_notify != NULL)
    priv-&gt;certificate_callback_notify(priv-&gt;certificate_callback_user_data);
  priv-&gt;certificate_request = req;
  priv-&gt;certificate_callback = cb;
  priv-&gt;certificate_callback_user_data = user_data;
  priv-&gt;certificate_callback_notify = notify;
}
void
inf_xmpp_connection_certificate_verify_continue(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  g_return_if_fail(INF_IS_XMPP_CONNECTION(xmpp));
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_return_if_fail(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED);
  g_return_if_fail(priv-&gt;session != NULL);
  inf_xmpp_connection_initiate(xmpp);
}
void
inf_xmpp_connection_certificate_verify_cancel(InfXmppConnection* xmpp,
                                              const GError* error)
{
  InfXmppConnectionPrivate* priv;
  GError* local_error;
  g_return_if_fail(INF_IS_XMPP_CONNECTION(xmpp));
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_return_if_fail(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED);
  g_return_if_fail(priv-&gt;session != NULL);
  if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
  {
    if(error == NULL)
    {
      local_error = g_error_new_literal(
        inf_xmpp_connection_error_quark(),
        INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED,
        _("The server certificate is not trusted")
      );
    }
    else
    {
      local_error = g_error_new(
        inf_xmpp_connection_error_quark(),
        INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED,
        _("The server certificate is not trusted: %s"),
        error-&gt;message
      );
    }
  }
  else
  {
    if(error == NULL)
    {
      local_error = g_error_new_literal(
        inf_xmpp_connection_error_quark(),
        INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED,
        _("The client certificate is not trusted")
      );
    }
    else
    {
      local_error = g_error_new(
        inf_xmpp_connection_error_quark(),
        INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED,
        _("The client certificate is not trusted: %s"),
        error-&gt;message
      );
    }
  }
  inf_xml_connection_error(INF_XML_CONNECTION(xmpp), local_error);
  g_error_free(local_error);
  inf_xmpp_connection_terminate(xmpp);
}
void
inf_xmpp_connection_reset_sasl_authentication(InfXmppConnection* xmpp,
                                              InfSaslContext* new_context,
                                              const gchar* new_mechanisms)
{
  InfXmppConnectionPrivate* priv;
  xmlNodePtr xml;
  g_return_if_fail(INF_IS_XMPP_CONNECTION(xmpp));
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  if(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING)
  {
    switch(priv-&gt;site)
    {
    case INF_XMPP_CONNECTION_CLIENT:
      if(priv-&gt;sasl_session != NULL)
      {
        xml = inf_xmpp_connection_node_new_sasl("abort");
        inf_xmpp_connection_send_xml(xmpp, xml);
        inf_sasl_context_stop_session(priv-&gt;sasl_context, priv-&gt;sasl_session);
        priv-&gt;sasl_session = NULL;
      }
      break;
    case INF_XMPP_CONNECTION_SERVER:
      if(priv-&gt;sasl_session != NULL)
      {
        inf_sasl_context_stop_session(priv-&gt;sasl_context, priv-&gt;sasl_session);
        priv-&gt;sasl_session = NULL;
      }
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
  if(priv-&gt;sasl_own_context != NULL)
  {
    inf_sasl_context_unref(priv-&gt;sasl_own_context);
    priv-&gt;sasl_own_context = NULL;
  }
  if(priv-&gt;sasl_context != NULL)
    inf_sasl_context_unref(priv-&gt;sasl_context);
  priv-&gt;sasl_context = new_context;
  if(new_context != NULL) inf_sasl_context_ref(new_context);
  g_free(priv-&gt;sasl_local_mechanisms);
  priv-&gt;sasl_local_mechanisms = g_strdup(new_mechanisms);
  g_object_freeze_notify(G_OBJECT(xmpp));   if(new_context == NULL)
  {
    if(!inf_xmpp_connection_sasl_ensure(xmpp))
    {
      inf_xmpp_connection_deinitiate(xmpp);
    }
  }
  g_object_notify(G_OBJECT(xmpp), "sasl-context");
  g_object_notify(G_OBJECT(xmpp), "sasl-mechanisms");
  g_object_thaw_notify(G_OBJECT(xmpp));
}
gboolean
inf_xmpp_connection_retry_sasl_authentication(InfXmppConnection* xmpp,
                                              GError** error)
{
  InfXmppConnectionPrivate* priv;
  const gchar* suggestion;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_return_val_if_fail(
    priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES,
    FALSE
  );
  suggestion = inf_xmpp_connection_sasl_suggest_mechanism(xmpp, error);
  if(suggestion == NULL)
    return FALSE;
  inf_xmpp_connection_sasl_init(xmpp, suggestion);
  return TRUE;
}
void
inf_xmpp_connection_set_sasl_error(InfXmppConnection* xmpp,
                                   const GError* error)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_return_if_fail(priv-&gt;sasl_context != NULL);
  g_return_if_fail(priv-&gt;sasl_error == NULL);
  priv-&gt;sasl_error = g_error_copy(error);
}
const GError*
inf_xmpp_connection_get_sasl_error(InfXmppConnection* xmpp)
{
  InfXmppConnectionPrivate* priv;
  priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
  g_return_val_if_fail(priv-&gt;sasl_context != NULL, NULL);
  return priv-&gt;sasl_error;
}
GQuark
inf_xmpp_connection_error_quark(void)
{
  return g_quark_from_static_string("INF_XMPP_CONNECTION_ERROR");
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
