<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-gtk-certificate-view.c &amp; inf-xmpp-connection.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-gtk-certificate-view.c &amp; inf-xmpp-connection.c
      </h3>
<h1 align="center">
        2.0%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-gtk-certificate-view.c (21.6%)<th>inf-xmpp-connection.c (1.0787055%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(137-160)<td><a href="#" name="0">(3828-3854)</a><td align="center"><font color="#ff0000">14</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(343-359)<td><a href="#" name="1">(3007-3019)</a><td align="center"><font color="#ec0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-certificate-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfgtk/inf-gtk-certificate-view.h&gt;
2 #include &lt;libinfinity/common/inf-cert-util.h&gt;
3 #include &lt;libinfinity/inf-i18n.h&gt;
4 #include &lt;gnutls/x509.h&gt;
5 #include &lt;time.h&gt;
6 typedef struct _InfGtkCertificateViewPrivate InfGtkCertificateViewPrivate;
7 struct _InfGtkCertificateViewPrivate {
8   gnutls_x509_crt_t certificate;
9   GtkWidget* subject_common_name;
10   GtkWidget* subject_organization;
11   GtkWidget* subject_organizational_unit;
12   GtkWidget* subject_serial_number;
13   GtkWidget* issuer_common_name;
14   GtkWidget* issuer_organization;
15   GtkWidget* issuer_organizational_unit;
16   GtkWidget* activation_time;
17   GtkWidget* expiration_time;
18   GtkWidget* sha1_fingerprint;
19   GtkWidget* sha256_fingerprint;
20   GtkWidget* signature_algorithm;
21 };
22 enum {
23   PROP_0,
24   PROP_CERTIFICATE
25 };
26 #define INF_GTK_CERTIFICATE_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_CERTIFICATE_VIEW, InfGtkCertificateViewPrivate))
27 G_DEFINE_TYPE_WITH_CODE(InfGtkCertificateView, inf_gtk_certificate_view, GTK_TYPE_GRID,
28   G_ADD_PRIVATE(InfGtkCertificateView))
29 static void
30 inf_gtk_certificate_view_set_label(GtkLabel* label,
31                                    const gchar* value)
32 {
33   const gchar* text;
34   gchar* markup;
35   if(value != NULL)
36   {
37     gtk_label_set_text(label, value);
38   }
39   else
40   {
41     text = _("&lt;Not part of certificate&gt;");
42     markup = g_markup_printf_escaped("&lt;i&gt;%s&lt;/i&gt;", text);
43     gtk_label_set_markup(label, markup);
44     g_free(markup);
45   }
46 }
47 static void
48 inf_gtk_certificate_view_set_label_dn_by_oid(gnutls_x509_crt_t cert,
49                                              GtkLabel* label,
50                                              const char* oid)
51 {
52   gchar* value;
53   value = inf_cert_util_get_dn_by_oid(cert, oid, 0);
54   inf_gtk_certificate_view_set_label(label, value);
55   g_free(value);
56 }
57 static void
58 inf_gtk_certificate_view_set_label_issuer_dn_by_oid(gnutls_x509_crt_t cert,
59                                                     GtkLabel* label,
60                                                     const gchar* oid)
61 {
62   gchar* value;
63   value = inf_cert_util_get_issuer_dn_by_oid(cert, oid, 0);
64   inf_gtk_certificate_view_set_label(label, value);
65   g_free(value);
66 }
67 static void
68 inf_gtk_certificate_view_init(InfGtkCertificateView* view)
69 {
70   InfGtkCertificateViewPrivate* priv;
71   PangoFontDescription* monospace_desc;
72   gint size;
73   priv = INF_GTK_CERTIFICATE_VIEW_PRIVATE(view);
74   priv-&gt;certificate = NULL;
75   gtk_widget_init_template(GTK_WIDGET(view));
76 }
77 static void
78 inf_gtk_certificate_view_set_property(GObject* object,
79                                       guint prop_id,
80                                       const GValue* value,
81                                       GParamSpec* pspec)
82 {
83   InfGtkCertificateView* view;
84   InfGtkCertificateViewPrivate* priv;
85   view = INF_GTK_CERTIFICATE_VIEW(object);
86   priv = INF_GTK_CERTIFICATE_VIEW_PRIVATE(view);
87   switch(prop_id)
88   {
89   case PROP_CERTIFICATE:
90     inf_gtk_certificate_view_set_certificate(
91       view,
92 <a name="0"></a>      (gnutls_x509_crt_t)g_value_get_pointer(value)
93     );
94 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
95   default:
96     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
97     break;
98   }
99 }
100 static void
101 inf_gtk_certificate_view_get_property(GObject* object,
102                                       guint prop_id,
103                                       GValue* value,
104                                       GParamSpec* pspec)
105 {
106   InfGtkCertificateView* view;
107   InfGtkCertificateViewPrivate* priv;
108   view = INF_GTK_CERTIFICATE_VIEW(object);
109   priv = INF_GTK_CERTIFICATE_VIEW_PRIVATE(view);
110   switch(prop_id)
111   {
112   case PROP_CERTIFICATE:
113     g_value_set_pointer(value, priv-&gt;certificate);
114     break;</b></font>
115   default:
116     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
117     break;
118   }
119 }
120 static void
121 inf_gtk_certificate_view_class_init(
122   InfGtkCertificateViewClass* certificate_view_class)
123 {
124   GObjectClass* object_class;
125   object_class = G_OBJECT_CLASS(certificate_view_class);
126   object_class-&gt;set_property = inf_gtk_certificate_view_set_property;
127   object_class-&gt;get_property = inf_gtk_certificate_view_get_property;
128   gtk_widget_class_set_template_from_resource(
129     GTK_WIDGET_CLASS(certificate_view_class),
130     "/de/0x539/libinfgtk/ui/infgtkcertificateview.ui"
131   );
132   gtk_widget_class_bind_template_child_private(
133     GTK_WIDGET_CLASS(certificate_view_class),
134     InfGtkCertificateView,
135     subject_common_name
136   );
137   gtk_widget_class_bind_template_child_private(
138     GTK_WIDGET_CLASS(certificate_view_class),
139     InfGtkCertificateView,
140     subject_organization
141   );
142   gtk_widget_class_bind_template_child_private(
143     GTK_WIDGET_CLASS(certificate_view_class),
144     InfGtkCertificateView,
145     subject_organizational_unit
146   );
147   gtk_widget_class_bind_template_child_private(
148     GTK_WIDGET_CLASS(certificate_view_class),
149     InfGtkCertificateView,
150     subject_serial_number
151   );
152   gtk_widget_class_bind_template_child_private(
153     GTK_WIDGET_CLASS(certificate_view_class),
154     InfGtkCertificateView,
155     issuer_common_name
156   );
157   gtk_widget_class_bind_template_child_private(
158     GTK_WIDGET_CLASS(certificate_view_class),
159     InfGtkCertificateView,
160     issuer_organization
161   );
162   gtk_widget_class_bind_template_child_private(
163     GTK_WIDGET_CLASS(certificate_view_class),
164     InfGtkCertificateView,
165     issuer_organizational_unit
166   );
167   gtk_widget_class_bind_template_child_private(
168     GTK_WIDGET_CLASS(certificate_view_class),
169     InfGtkCertificateView,
170     activation_time
171   );
172   gtk_widget_class_bind_template_child_private(
173     GTK_WIDGET_CLASS(certificate_view_class),
174     InfGtkCertificateView,
175     expiration_time
176   );
177   gtk_widget_class_bind_template_child_private(
178     GTK_WIDGET_CLASS(certificate_view_class),
179     InfGtkCertificateView,
180     sha1_fingerprint
181   );
182   gtk_widget_class_bind_template_child_private(
183     GTK_WIDGET_CLASS(certificate_view_class),
184     InfGtkCertificateView,
185     sha256_fingerprint
186   );
187   gtk_widget_class_bind_template_child_private(
188     GTK_WIDGET_CLASS(certificate_view_class),
189     InfGtkCertificateView,
190     signature_algorithm
191   );
192   g_object_class_install_property(
193     object_class,
194     PROP_CERTIFICATE,
195     g_param_spec_pointer(
196       "certificate",
197       "Certificate",
198       "The certificate to show",
199       G_PARAM_READWRITE
200     )
201   );
202 }
203 GtkWidget*
204 inf_gtk_certificate_view_new(void)
205 {
206   GObject* object;
207   object = g_object_new(INF_GTK_TYPE_CERTIFICATE_VIEW, NULL);
208   return GTK_WIDGET(object);
209 }
210 GtkWidget*
211 inf_gtk_certificate_view_new_with_certificate(gnutls_x509_crt_t cert)
212 {
213   GObject* object;
214   object = g_object_new(
215     INF_GTK_TYPE_CERTIFICATE_VIEW,
216     "certificate", cert,
217     NULL
218   );
219   return GTK_WIDGET(object);
220 }
221 void
222 inf_gtk_certificate_view_set_certificate(InfGtkCertificateView* view,
223                                          gnutls_x509_crt_t cert)
224 {
225   InfGtkCertificateViewPrivate* priv;
226   gchar* value;
227   int algo;
228   g_return_if_fail(INF_GTK_IS_CERTIFICATE_VIEW(view));
229   priv = INF_GTK_CERTIFICATE_VIEW_PRIVATE(view);
230 <a name="1"></a>  priv-&gt;certificate = cert;
231   if(cert == NULL)
232 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  {
233     gtk_label_set_text(GTK_LABEL(priv-&gt;subject_common_name), NULL);
234     gtk_label_set_text(GTK_LABEL(priv-&gt;subject_organization), NULL);
235     gtk_label_set_text(GTK_LABEL(priv-&gt;subject_organizational_unit), NULL);
236     gtk_label_set_text(GTK_LABEL(priv-&gt;subject_serial_number), NULL);
237     gtk_label_set_text(GTK_LABEL(priv-&gt;issuer_common_name), NULL);
238     gtk_label_set_text(GTK_LABEL(priv-&gt;issuer_organization), NULL);
239     gtk_label_set_text(GTK_LABEL(priv-&gt;issuer_organizational_unit), NULL);
240     gtk_label_set_text(GTK_LABEL(priv-&gt;activation_time), NULL);
241     gtk_label_set_text(GTK_LABEL(priv-&gt;expiration_time), NULL);
242     gtk_label_set_text(GTK_LABEL(priv-&gt;sha1_fingerprint), NULL);
243     gtk_label_set_text(GTK_LABEL(priv-&gt;sha256_fingerprint), NULL);
244     gtk_label_set_text(GTK_LABEL(priv-&gt;signature_algorithm), NULL);</b></font>
245   }
246   else
247   {
248     inf_gtk_certificate_view_set_label_dn_by_oid(
249       cert,
250       GTK_LABEL(priv-&gt;subject_common_name),
251       GNUTLS_OID_X520_COMMON_NAME
252     );
253     inf_gtk_certificate_view_set_label_dn_by_oid(
254       cert,
255       GTK_LABEL(priv-&gt;subject_organization),
256       GNUTLS_OID_X520_ORGANIZATION_NAME
257     );
258     inf_gtk_certificate_view_set_label_dn_by_oid(
259       cert,
260       GTK_LABEL(priv-&gt;subject_organizational_unit),
261       GNUTLS_OID_X520_ORGANIZATIONAL_UNIT_NAME
262     );
263     value = inf_cert_util_get_serial_number(cert);
264     inf_gtk_certificate_view_set_label(
265       GTK_LABEL(priv-&gt;subject_serial_number),
266       value
267     );
268     g_free(value);
269     inf_gtk_certificate_view_set_label_issuer_dn_by_oid(
270       cert,
271       GTK_LABEL(priv-&gt;issuer_common_name),
272       GNUTLS_OID_X520_COMMON_NAME
273     );
274     inf_gtk_certificate_view_set_label_issuer_dn_by_oid(
275       cert,
276       GTK_LABEL(priv-&gt;issuer_organization),
277       GNUTLS_OID_X520_ORGANIZATION_NAME
278     );
279     inf_gtk_certificate_view_set_label_issuer_dn_by_oid(
280       cert,
281       GTK_LABEL(priv-&gt;issuer_organizational_unit),
282       GNUTLS_OID_X520_ORGANIZATIONAL_UNIT_NAME
283     );
284     value = inf_cert_util_get_activation_time(cert);
285     inf_gtk_certificate_view_set_label(
286       GTK_LABEL(priv-&gt;activation_time),
287       value
288     );
289     g_free(value);
290     value = inf_cert_util_get_expiration_time(cert);
291     inf_gtk_certificate_view_set_label(
292       GTK_LABEL(priv-&gt;expiration_time),
293       value
294     );
295     g_free(value);
296     value = inf_cert_util_get_fingerprint(cert, GNUTLS_DIG_SHA1);
297     inf_gtk_certificate_view_set_label(
298       GTK_LABEL(priv-&gt;sha1_fingerprint),
299       value
300     );
301     g_free(value);
302     value = inf_cert_util_get_fingerprint(cert, GNUTLS_DIG_SHA256);
303     inf_gtk_certificate_view_set_label(
304       GTK_LABEL(priv-&gt;sha256_fingerprint),
305       value
306     );
307     g_free(value);
308     algo = gnutls_x509_crt_get_signature_algorithm(cert);
309     if(algo &lt; 0)
310     {
311       inf_gtk_certificate_view_set_label(
312         GTK_LABEL(priv-&gt;signature_algorithm),
313         gnutls_strerror(algo)
314       );
315     }
316     else
317     {
318       inf_gtk_certificate_view_set_label(
319         GTK_LABEL(priv-&gt;signature_algorithm),
320         gnutls_sign_get_name(algo)
321       );
322     }
323   }
324   g_object_notify(G_OBJECT(view), "certificate");
325 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-xmpp-connection.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfinity/common/inf-xmpp-connection.h&gt;
2 #include &lt;libinfinity/common/inf-xml-connection.h&gt;
3 #include &lt;libinfinity/common/inf-xml-util.h&gt;
4 #include &lt;libinfinity/common/inf-ip-address.h&gt;
5 #include &lt;libinfinity/common/inf-error.h&gt;
6 #include &lt;libinfinity/inf-i18n.h&gt;
7 #include &lt;libinfinity/inf-signals.h&gt;
8 #include &lt;libinfinity/inf-define-enum.h&gt;
9 #include &lt;gnutls/x509.h&gt;
10 #include &lt;errno.h&gt;
11 #include &lt;string.h&gt;
12 #include &lt;ctype.h&gt;
13 #include "config.h"
14 static const GEnumValue inf_xmpp_connection_site_values[] = {
15   {
16     INF_XMPP_CONNECTION_CLIENT,
17     "INF_XMPP_CONNECTION_CLIENT",
18     "client"
19   }, {
20     INF_XMPP_CONNECTION_SERVER,
21     "INF_XMPP_CONNECTION_SERVER",
22     "server"
23   }, {
24     0,
25     NULL,
26     NULL
27   }
28 };
29 static const GEnumValue inf_xmpp_connection_security_policy_values[] = {
30   {
31     INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED,
32     "INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED",
33     "only-unsecured"
34   }, {
35     INF_XMPP_CONNECTION_SECURITY_ONLY_TLS,
36     "INF_XMPP_CONNECTION_SECURITY_ONLY_TLS",
37     "only-tls"
38   }, {
39     INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_UNSECURED,
40     "INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_UNSECURED",
41     "both-prefer-unsecured"
42   }, {
43     INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
44     "INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS",
45     "both-prefer-tls"
46   }, {
47     0,
48     NULL,
49     NULL
50   }
51 };
52 gboolean INF_XMPP_CONNECTION_PRINT_TRAFFIC = FALSE;
53 typedef enum _InfXmppConnectionStatus {
54   INF_XMPP_CONNECTION_CONNECTING,
55   INF_XMPP_CONNECTION_CONNECTED,
56   INF_XMPP_CONNECTION_AUTH_CONNECTED,
57   INF_XMPP_CONNECTION_INITIATED,
58   INF_XMPP_CONNECTION_AUTH_INITIATED,
59   INF_XMPP_CONNECTION_AWAITING_FEATURES,
60   INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES,
61   INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED,
62   INF_XMPP_CONNECTION_HANDSHAKING,
63   INF_XMPP_CONNECTION_AUTHENTICATING,
64   INF_XMPP_CONNECTION_READY,
65   INF_XMPP_CONNECTION_CLOSING_STREAM,
66   INF_XMPP_CONNECTION_CLOSING_GNUTLS,
67   INF_XMPP_CONNECTION_CLOSED
68 } InfXmppConnectionStatus;
69 typedef void(*InfXmppConnectionSentFunc)(InfXmppConnection* xmpp,
70                                          gpointer user_data);
71 typedef void(*InfXmppConnectionFreeFunc)(InfXmppConnection* xmpp,
72                                          gpointer user_data);
73 typedef struct _InfXmppConnectionMessage InfXmppConnectionMessage;
74 struct _InfXmppConnectionMessage {
75   InfXmppConnectionMessage* next;
76   guint position;
77   gboolean sent;
78   InfXmppConnectionSentFunc sent_func;
79   InfXmppConnectionFreeFunc free_func;
80   gpointer user_data;
81 };
82 typedef struct _InfXmppConnectionPrivate InfXmppConnectionPrivate;
83 struct _InfXmppConnectionPrivate {
84   InfTcpConnection* tcp;
85   InfXmppConnectionSite site;
86   gchar* local_hostname;
87   gchar* remote_hostname;
88   InfXmppConnectionSecurityPolicy security_policy;
89   InfXmppConnectionStatus status;
90   gnutls_certificate_request_t certificate_request;
91   InfXmppConnectionCrtCallback certificate_callback;
92   gpointer certificate_callback_user_data;
93   GDestroyNotify certificate_callback_notify;
94   guint position;
95   xmlDocPtr doc;
96   xmlBufferPtr buf;
97   InfXmppConnectionMessage* messages;
98   InfXmppConnectionMessage* last_message;
99   guint parsing;   xmlParserCtxtPtr parser;
100   xmlNodePtr root;
101   xmlNodePtr cur;
102   gnutls_session_t session;
103   InfCertificateCredentials* creds;
104   gnutls_x509_crt_t own_cert;
105   InfCertificateChain* peer_cert;
106   const gchar* pull_data;
107   gsize pull_len;
108   InfSaslContext* sasl_context;
109   InfSaslContext* sasl_own_context;
110   InfSaslContextSession* sasl_session;
111   gchar* sasl_local_mechanisms;
112   gchar* sasl_remote_mechanisms;
113   GError* sasl_error;
114 };
115 enum {
116   PROP_0,
117   PROP_TCP,
118   PROP_SITE,
119   PROP_LOCAL_HOSTNAME,
120   PROP_REMOTE_HOSTNAME,
121   PROP_SECURITY_POLICY,
122   PROP_TLS_ENABLED,
123   PROP_CREDENTIALS,
124   PROP_SASL_CONTEXT,
125   PROP_SASL_MECHANISMS,
126   PROP_STATUS,
127   PROP_NETWORK,
128   PROP_LOCAL_ID,
129   PROP_REMOTE_ID,
130   PROP_LOCAL_CERTIFICATE,
131   PROP_REMOTE_CERTIFICATE
132 };
133 #define INF_XMPP_CONNECTION_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TYPE_XMPP_CONNECTION, InfXmppConnectionPrivate))
134 static GQuark inf_xmpp_connection_stream_error_quark;
135 static GQuark inf_xmpp_connection_auth_error_quark;
136 static void inf_xmpp_connection_xml_connection_iface_init(InfXmlConnectionInterface* iface);
137 INF_DEFINE_ENUM_TYPE(InfXmppConnectionSite, inf_xmpp_connection_site, inf_xmpp_connection_site_values)
138 INF_DEFINE_ENUM_TYPE(InfXmppConnectionSecurityPolicy, inf_xmpp_connection_security_policy, inf_xmpp_connection_security_policy_values)
139 G_DEFINE_TYPE_WITH_CODE(InfXmppConnection, inf_xmpp_connection, G_TYPE_OBJECT,
140   G_ADD_PRIVATE(InfXmppConnection)
141   G_IMPLEMENT_INTERFACE(INF_TYPE_XML_CONNECTION, inf_xmpp_connection_xml_connection_iface_init))
142 typedef struct _InfXmppConnectionErrorCondition {
143   const gchar* condition;
144   guint code;
145 } InfXmppConnectionErrorCondition;
146 static const InfXmppConnectionErrorCondition
147   inf_xmpp_connection_stream_error_conditions[] = {
148     {
149       "bad-format",
150       INF_XMPP_CONNECTION_STREAM_ERROR_BAD_FORMAT
151     }, {
152       "bad-namespace-prefix",
153       INF_XMPP_CONNECTION_STREAM_ERROR_BAD_NAMESPACE_PREFIX
154     }, {
155       "conflict",
156       INF_XMPP_CONNECTION_STREAM_ERROR_CONFLICT
157     }, {
158       "connection-timeout",
159       INF_XMPP_CONNECTION_STREAM_ERROR_CONNECTION_TIMEOUT
160     }, {
161       "host-gone",
162       INF_XMPP_CONNECTION_STREAM_ERROR_HOST_GONE
163     }, {
164       "host-unknown",
165       INF_XMPP_CONNECTION_STREAM_ERROR_HOST_UNKNOWN
166     }, {
167       "improper-addressing",
168       INF_XMPP_CONNECTION_STREAM_ERROR_IMPROPER_ADDRESSING
169     }, {
170       "internal-server-error",
171       INF_XMPP_CONNECTION_STREAM_ERROR_INTERNAL_SERVER_ERROR
172     }, {
173       "invalid-from",
174       INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_FROM
175     }, {
176       "invalid-id",
177       INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_ID
178     }, {
179       "invalid-namespace",
180       INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_NAMESPACE
181     }, {
182       "invalid-xml",
183       INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_XML
184     }, {
185       "not-authorized",
186       INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED
187     }, {
188       "policy-violation",
189       INF_XMPP_CONNECTION_STREAM_ERROR_POLICY_VIOLATION
190     }, {
191       "remote-connection-failed",
192       INF_XMPP_CONNECTION_STREAM_ERROR_REMOTE_CONNECTION_FAILED
193     }, {
194       "resource-constraint",
195       INF_XMPP_CONNECTION_STREAM_ERROR_RESOURCE_CONSTRAINT
196     }, {
197       "restricted-xml",
198       INF_XMPP_CONNECTION_STREAM_ERROR_RESTRICTED_XML
199     }, {
200       "see-other-host",
201       INF_XMPP_CONNECTION_STREAM_ERROR_SEE_OTHER_HOST
202     }, {
203       "system-shutdown",
204       INF_XMPP_CONNECTION_STREAM_ERROR_SYSTEM_SHUTDOWN
205     }, {
206       "undefined-condition",
207       INF_XMPP_CONNECTION_STREAM_ERROR_UNDEFINED_CONDITION
208     }, {
209       "undefined-condition",
210       INF_XMPP_CONNECTION_STREAM_ERROR_FAILED
211     }, {
212       "unsupported-encoding",
213       INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_ENCODING
214     }, {
215       "unsupported-stanza-type",
216       INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_STANZA_TYPE
217     }, {
218       "unsupported-version",
219       INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_VERSION
220     }, {
221       "xml-not-well-formed",
222       INF_XMPP_CONNECTION_STREAM_ERROR_XML_NOT_WELL_FORMED
223     }, {
224       NULL,
225       0
226     }
227   };
228 static const InfXmppConnectionErrorCondition
229   inf_xmpp_connection_auth_error_conditions[] = {
230     {
231       "aborted",
232       INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED
233     }, {
234       "incorrect-encoding",
235       INF_XMPP_CONNECTION_AUTH_ERROR_INCORRECT_ENCODING
236     }, {
237       "invalid-authzid",
238       INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_AUTHZID
239     }, {
240       "invalid-mechanism",
241       INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM
242     }, {
243       "mechanism-too-weak",
244       INF_XMPP_CONNECTION_AUTH_ERROR_MECHANISM_TOO_WEAK
245     }, {
246       "not-authorized",
247       INF_XMPP_CONNECTION_AUTH_ERROR_NOT_AUTHORIZED
248     }, {
249       "temporary-auth-failure",
250       INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE
251     }, {
252       NULL,
253       0
254     }
255   };
256 static InfXmppConnectionStreamError
257 inf_xmpp_connection_stream_error_from_condition(const gchar* condition)
258 {
259   const InfXmppConnectionErrorCondition* cond;
260   for(cond = inf_xmpp_connection_stream_error_conditions;
261       cond-&gt;condition != NULL;
262       ++ cond)
263   {
264     if(strcmp(condition, cond-&gt;condition) == 0)
265       return cond-&gt;code;
266   }
267   return INF_XMPP_CONNECTION_STREAM_ERROR_FAILED;
268 }
269 static const gchar*
270 inf_xmpp_connection_stream_error_to_condition(InfXmppConnectionStreamError code)
271 {
272   const InfXmppConnectionErrorCondition* cond;
273   for(cond = inf_xmpp_connection_stream_error_conditions;
274       cond-&gt;condition != NULL;
275       ++ cond)
276   {
277     if(code == cond-&gt;code)
278       return cond-&gt;condition;
279   }
280   g_assert_not_reached();
281   return NULL;
282 }
283 static const gchar*
284 inf_xmpp_connection_stream_strerror(InfXmppConnectionStreamError code)
285 {
286   switch(code)
287   {
288   case INF_XMPP_CONNECTION_STREAM_ERROR_BAD_FORMAT:
289     return _("The entity has sent XML that cannot be processed");
290   case INF_XMPP_CONNECTION_STREAM_ERROR_BAD_NAMESPACE_PREFIX:
291     return _("The entity has sent a namespace prefix that is unsupported, or "
292              "has sent no namespace prefix on an element that requires such "
293              "a prefix");
294   case INF_XMPP_CONNECTION_STREAM_ERROR_CONFLICT:
295     return _("The server is closing the active stream for this entity "
296              "because a new stream has been initiated that conflicts with "
297              "the existing stream");
298   case INF_XMPP_CONNECTION_STREAM_ERROR_CONNECTION_TIMEOUT:
299     return _("The entity has not generated any traffic over the stream for "
300              "some period of time");
301   case INF_XMPP_CONNECTION_STREAM_ERROR_HOST_GONE:
302     return _("The value of the 'to' attribute provided by the initiating "
303              "entity in the stream header corresponds to a hostname that is "
304              "no longer hosted by the server");
305   case INF_XMPP_CONNECTION_STREAM_ERROR_HOST_UNKNOWN:
306     return _("The value of the 'to' attribute provided by the initiating "
307              "entity  in the stream header does not correspond to a hostname "
308              "that is hosted by the server");
309   case INF_XMPP_CONNECTION_STREAM_ERROR_IMPROPER_ADDRESSING:
310     return _("A stanza sent between two servers lacks a 'to' or 'from'"
311              "attribute");
312   case INF_XMPP_CONNECTION_STREAM_ERROR_INTERNAL_SERVER_ERROR:
313     return _("The server has experienced a misconfiguration or an otherwise-"
314              "undefined internal error that prevents it from servicing "
315              "the stream");
316   case INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_FROM:
317     return _("The JID or hostname provided in a 'from' address does not "
318              "match an authorized JID or validated domain negotiated between "
319              "servers via SASL or dialback, or between a client and a "
320              "server via authentication and resource binding");
321   case INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_ID:
322     return _("The stream ID or dialback ID is invalid or does not match an "
323              "ID previously provided");
324   case INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_NAMESPACE:
325     return _("The streams namespace is something other than "
326              "\"http://etherx.jabber.org/streams\" or the dialback namespace "
327              "name is something other than \"jabber:server:dialback\"");
328   case INF_XMPP_CONNECTION_STREAM_ERROR_INVALID_XML:
329     return _("The entity has sent invalid XML over the stream to a server "
330              "that performs validation");
331   case INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED:
332     return _("The entity has attempted to send data before the stream has "
333              "been authenticated, or otherwise is not authorized to perform "
334              "an action related to stream negotiation");
335   case INF_XMPP_CONNECTION_STREAM_ERROR_POLICY_VIOLATION:
336     return _("The entity has violated some local service policy");
337   case INF_XMPP_CONNECTION_STREAM_ERROR_REMOTE_CONNECTION_FAILED:
338     return _("The server is unable to properly connect to a remote entity "
339              "that is required for authentication or authorization");
340   case INF_XMPP_CONNECTION_STREAM_ERROR_RESOURCE_CONSTRAINT:
341     return _("The server lacks the system resources necessary to service the "
342              "stream");
343   case INF_XMPP_CONNECTION_STREAM_ERROR_RESTRICTED_XML:
344     return _("The entity has attempted to send restricted XML features");
345   case INF_XMPP_CONNECTION_STREAM_ERROR_SEE_OTHER_HOST:
346     return _("The server will not provide service to the initiating "
347              "entity but is redirecting traffic to another host");
348   case INF_XMPP_CONNECTION_STREAM_ERROR_SYSTEM_SHUTDOWN:
349     return _("The server is being shut down and all active streams are being "
350              "closed");
351   case INF_XMPP_CONNECTION_STREAM_ERROR_UNDEFINED_CONDITION:
352   case INF_XMPP_CONNECTION_STREAM_ERROR_FAILED:
353     return _("The error condition is not one of those defined by the other "
354              "conditions");
355   case INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_ENCODING:
356     return _("The initiating entity has encoded the stream in an encoding "
357              "that is not supported by the server");
358   case INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_STANZA_TYPE:
359     return _("The initiating entity has sent a first-level child of the "
360              "stream that is not supported by the server.");
361   case INF_XMPP_CONNECTION_STREAM_ERROR_UNSUPPORTED_VERSION:
362     return _("The value of the 'version' attribute provided by the "
363              "initiating entity in the stream header specifies a version of "
364              "XMPP that is not supported by the server");
365   case INF_XMPP_CONNECTION_STREAM_ERROR_XML_NOT_WELL_FORMED:
366     return _("The initiating entity has sent XML that is not well-formed");
367   default:
368     g_assert_not_reached();
369     break;
370   }
371 }
372 static InfXmppConnectionAuthError
373 inf_xmpp_connection_auth_error_from_condition(const gchar* condition)
374 {
375   const InfXmppConnectionErrorCondition* cond;
376   for(cond = inf_xmpp_connection_auth_error_conditions;
377       cond-&gt;condition != NULL;
378       ++ cond)
379   {
380     if(strcmp(condition, cond-&gt;condition) == 0)
381       return cond-&gt;code;
382   }
383   return INF_XMPP_CONNECTION_AUTH_ERROR_FAILED;
384 }
385 static const gchar*
386 inf_xmpp_connection_auth_error_to_condition(InfXmppConnectionAuthError code)
387 {
388   const InfXmppConnectionErrorCondition* cond;
389   for(cond = inf_xmpp_connection_auth_error_conditions;
390       cond-&gt;condition != NULL;
391       ++ cond)
392   {
393     if(cond-&gt;code == code)
394       return cond-&gt;condition;
395   }
396   g_assert_not_reached();
397   return NULL;
398 }
399 static const gchar*
400 inf_xmpp_connection_auth_strerror(InfXmppConnectionAuthError code)
401 {
402   switch(code)
403   {
404   case INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED:
405     return _("The receiving entity acknowledged an &lt;abort/&gt; element sent by "
406              "the initiating entity");
407   case INF_XMPP_CONNECTION_AUTH_ERROR_INCORRECT_ENCODING:
408     return _("The data provided by the initiating entity could not be "
409              "processed because the Base64 encoding is incorrect");
410   case INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_AUTHZID:
411     return _("The authzid provided by the initiating entity is invalid, "
412              "either because it is incorrectly formatted or because the "
413              "initiating entity does not have permissions to authorize "
414              "that ID");
415   case INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM:
416     return _("The initiating entity did not provide a mechanism or requested "
417              "a mechanism that is not supported by the receiving entity");
418   case INF_XMPP_CONNECTION_AUTH_ERROR_MECHANISM_TOO_WEAK:
419     return _("The mechanism requested by the initiating entity is weaker than "
420              "server policy permits for that initiating entity");
421   case INF_XMPP_CONNECTION_AUTH_ERROR_NOT_AUTHORIZED:
422     return _("The authentication failed because the initiating entity did "
423              "not provide valid credentials");
424   case INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE:
425     return _("The authentication failed because of a temporary error condition "
426              "within the receiving entity");
427   case INF_XMPP_CONNECTION_AUTH_ERROR_FAILED:
428     return _("An unknown authentication error has occurred");
429   default:
430     g_assert_not_reached();
431     return NULL;
432   }
433 }
434 static void
435 inf_xmpp_connection_push_message(InfXmppConnection* xmpp,
436                                  InfXmppConnectionSentFunc sent_func,
437                                  InfXmppConnectionFreeFunc free_func,
438                                  gpointer user_data)
439 {
440   InfXmppConnectionPrivate* priv;
441   InfXmppConnectionMessage* message;
442   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
443   if(priv-&gt;position == 0)
444   {
445     if(sent_func != NULL)
446       sent_func(xmpp, user_data);
447     if(free_func != NULL)
448       free_func(xmpp, user_data);
449   }
450   else
451   {
452     message = g_slice_new(InfXmppConnectionMessage);
453     message-&gt;next = NULL;
454     message-&gt;position = priv-&gt;position;
455     message-&gt;sent = FALSE;
456     message-&gt;sent_func = sent_func;
457     message-&gt;free_func = free_func;
458     message-&gt;user_data = user_data;
459     if(priv-&gt;last_message == NULL)
460       priv-&gt;messages = message;
461     else 
462       priv-&gt;last_message-&gt;next = message;
463     priv-&gt;last_message = message;
464   }
465 }
466 static void
467 inf_xmpp_connection_pop_message(InfXmppConnection* connection)
468 {
469   InfXmppConnectionPrivate* priv;
470   InfXmppConnectionMessage* message;
471   priv = INF_XMPP_CONNECTION_PRIVATE(connection);
472   message = priv-&gt;messages;
473   g_assert(message != NULL);
474   priv-&gt;messages = message-&gt;next;
475   if(priv-&gt;messages == NULL) priv-&gt;last_message = NULL;
476   if(message-&gt;free_func != NULL)
477     message-&gt;free_func(connection, message-&gt;user_data);
478   g_slice_free(InfXmppConnectionMessage, message);
479 }
480 static void
481 inf_xmpp_connection_clear(InfXmppConnection* xmpp)
482 {
483   InfXmppConnectionPrivate* priv;
484   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
485   g_object_freeze_notify(G_OBJECT(xmpp));
486   if(priv-&gt;sasl_session != NULL)
487   {
488     inf_sasl_context_stop_session(priv-&gt;sasl_context, priv-&gt;sasl_session);
489     priv-&gt;sasl_session = NULL;
490   }
491   if(priv-&gt;sasl_remote_mechanisms != NULL)
492   {
493     g_free(priv-&gt;sasl_remote_mechanisms);
494     priv-&gt;sasl_remote_mechanisms = NULL;
495   }
496 #if 0
497   if(priv-&gt;own_cert != NULL)
498   {
499     gnutls_x509_crt_deinit(priv-&gt;own_cert);
500     priv-&gt;own_cert = NULL;
501     g_object_notify(G_OBJECT(xmpp), "local-certificate");
502   }
503   if(priv-&gt;peer_cert != NULL)
504   {
505     inf_certificate_chain_unref(priv-&gt;peer_cert);
506     priv-&gt;peer_cert = NULL;
507     g_object_notify(G_OBJECT(xmpp), "remote-certificate");
508   }
509 #endif
510   if(priv-&gt;session != NULL)
511   {
512     gnutls_deinit(priv-&gt;session);
513     priv-&gt;session = NULL;
514     g_object_notify(G_OBJECT(xmpp), "tls-enabled");
515   }
516   if(priv-&gt;parser != NULL)
517   {
518     xmlFreeParserCtxt(priv-&gt;parser);
519     priv-&gt;parser = NULL;
520     if(priv-&gt;root != NULL)
521     {
522       xmlFreeNode(priv-&gt;root);
523       priv-&gt;root = NULL;
524       priv-&gt;cur = NULL;
525     }
526   }
527   while(priv-&gt;messages != NULL)
528     inf_xmpp_connection_pop_message(xmpp);
529   if(priv-&gt;buf != NULL)
530   {
531     g_assert(priv-&gt;doc != NULL);
532     xmlBufferFree(priv-&gt;buf);
533     xmlFreeDoc(priv-&gt;doc);
534     priv-&gt;buf = NULL;
535     priv-&gt;doc = NULL;
536   }
537   priv-&gt;pull_data = NULL;
538   priv-&gt;pull_len = 0;
539   g_object_thaw_notify(G_OBJECT(xmpp));
540 }
541 static void
542 inf_xmpp_connection_send_chars(InfXmppConnection* xmpp,
543                                gconstpointer data,
544                                guint len)
545 {
546   InfXmppConnectionPrivate* priv;
547   ssize_t cur_bytes;
548   GError* error;
549   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
550   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING &amp;&amp;
551            priv-&gt;status != INF_XMPP_CONNECTION_CLOSED);
552   if(INF_XMPP_CONNECTION_PRINT_TRAFFIC)
553     printf("\033[00;34m%.*s\033[00;00m\n", (int)len, (const char*)data);
554   ++priv-&gt;parsing;
555   if(priv-&gt;session != NULL)
556   {
557     do
558     {
559       cur_bytes = gnutls_record_send(priv-&gt;session, data, len);
560       if(cur_bytes &lt; 0)
561       {
562         error = NULL;
563         inf_gnutls_set_error(&amp;error, cur_bytes);
564         inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
565         g_error_free(error);
566         inf_tcp_connection_close(priv-&gt;tcp);
567         break;
568       }
569       else if(cur_bytes == 0)
570       {
571         g_assert_not_reached();
572       }
573       else
574       {
575         *((const char**)&amp;data) += cur_bytes;
576         len -= cur_bytes;
577       }
578     } while(len &gt; 0);
579   }
580   else
581   {
582     priv-&gt;position += len;
583     inf_tcp_connection_send(priv-&gt;tcp, data, len);
584   }
585   g_assert(priv-&gt;parsing &gt; 0);
586   if(--priv-&gt;parsing == 0)
587   {
588     if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSED)
589     {
590       inf_xmpp_connection_clear(xmpp);
591       g_object_notify(G_OBJECT(xmpp), "status");
592     }
593   }
594 }
595 static void
596 inf_xmpp_connection_send_xml(InfXmppConnection* xmpp,
597                              xmlNodePtr xml)
598 {
599   InfXmppConnectionPrivate* priv;
600   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
601   g_return_if_fail(priv-&gt;doc != NULL);
602   g_return_if_fail(priv-&gt;buf != NULL);
603   xmlDocSetRootElement(priv-&gt;doc, xml);
604   xmlNodeDump(priv-&gt;buf, priv-&gt;doc, xml, 0, 0);
605   xmlUnlinkNode(xml);
606   xmlSetListDoc(xml, NULL);
607   g_object_ref(xmpp);
608   inf_xmpp_connection_send_chars(
609     xmpp,
610     xmlBufferContent(priv-&gt;buf),
611     xmlBufferLength(priv-&gt;buf)
612   );
613   if(priv-&gt;buf != NULL)
614     xmlBufferEmpty(priv-&gt;buf);
615   g_object_unref(xmpp);
616 }
617 static xmlNodePtr
618 inf_xmpp_connection_node_new(const gchar* name,
619                              const gchar* xmlns)
620 {
621   xmlNodePtr ptr;
622   ptr = xmlNewNode(NULL, (const xmlChar*)name);
623   xmlNewProp(ptr, (const xmlChar*)"xmlns", (const xmlChar*)xmlns);
624   return ptr;
625 }
626 static xmlNodePtr
627 inf_xmpp_connection_node_new_streams(const gchar* name)
628 {
629   return inf_xmpp_connection_node_new(
630     name,
631     "urn:ietf:params:xml:ns:xmpp-streams"
632   );
633 }
634 static xmlNodePtr
635 inf_xmpp_connection_node_new_tls(const gchar* name)
636 {
637   return inf_xmpp_connection_node_new(
638     name,
639     "urn:ietf:params:xml:ns:xmpp-tls"
640   );
641 }
642 static xmlNodePtr
643 inf_xmpp_connection_node_new_sasl(const gchar* name)
644 {
645   return inf_xmpp_connection_node_new(
646     name,
647     "urn:ietf:params:xml:ns:xmpp-sasl"
648   );
649 }
650 static void
651 inf_xmpp_connection_terminate(InfXmppConnection* xmpp)
652 {
653   static const gchar xmpp_connection_deinit_request[] = "&lt;/stream:stream&gt;";
654   InfXmppConnectionPrivate* priv;
655   xmlNodePtr abort;
656   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
657   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED &amp;&amp;
658            priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_GNUTLS &amp;&amp;
659            priv-&gt;status != INF_XMPP_CONNECTION_CONNECTING);
660   if(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING &amp;&amp;
661      priv-&gt;status != INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED)
662   {
663     if(priv-&gt;status != INF_XMPP_CONNECTION_CONNECTED &amp;&amp;
664        priv-&gt;status != INF_XMPP_CONNECTION_AUTH_CONNECTED &amp;&amp;
665        priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_STREAM)
666     {
667       if(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING)
668       {
669         abort = inf_xmpp_connection_node_new_sasl("abort");
670         inf_xmpp_connection_send_xml(xmpp, abort);
671         xmlFreeNode(abort);
672       }
673       if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED)
674       {
675         inf_xmpp_connection_send_chars(
676           xmpp,
677           xmpp_connection_deinit_request,
678           sizeof(xmpp_connection_deinit_request) - 1
679         );
680       }
681     }
682     if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED &amp;&amp; priv-&gt;session != NULL)
683       gnutls_bye(priv-&gt;session, GNUTLS_SHUT_WR);
684   }
685   if(priv-&gt;parsing == 0)
686     inf_xmpp_connection_clear(xmpp);
687   if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED)
688   {
689     if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_STREAM)
690     {
691       priv-&gt;status = INF_XMPP_CONNECTION_CLOSING_GNUTLS;
692       if(priv-&gt;parsing == 0)
693         g_object_notify(G_OBJECT(xmpp), "status");
694     }
695     else
696     {
697       priv-&gt;status = INF_XMPP_CONNECTION_CLOSING_GNUTLS;
698     }
699   }
700 }
701 static void
702 inf_xmpp_connection_send_auth_error(InfXmppConnection* xmpp,
703                                     InfXmppConnectionAuthError code)
704 {
705   InfXmppConnectionPrivate* priv;
706   xmlNodePtr xml;
707   xmlNodePtr child;
708   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
709   g_assert(priv-&gt;sasl_context != NULL);
710   xml = inf_xmpp_connection_node_new_sasl("failure");
711   child = xmlNewChild(
712     xml,
713     NULL,
714     (const xmlChar*)inf_xmpp_connection_auth_error_to_condition(code),
715     NULL
716   );
717   if(priv-&gt;sasl_error != NULL)
718   {
719     xmlAddChild(
720       child,
721       inf_xml_util_new_node_from_error(priv-&gt;sasl_error, NULL, "error"));
722   }
723   inf_xmpp_connection_send_xml(xmpp, xml);
724   xmlFreeNode(xml);
725 }
726 static void
727 inf_xmpp_connection_emit_auth_error(InfXmppConnection* xmpp,
728                                     InfXmppConnectionAuthError code)
729 {
730   GError* error;
731   error = NULL;
732   g_set_error_literal(
733     &amp;error,
734     inf_xmpp_connection_auth_error_quark,
735     code,
736     inf_xmpp_connection_auth_strerror(code)
737   );
738   inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
739   g_error_free(error);
740 }
741 static void
742 inf_xmpp_connection_terminate_error(InfXmppConnection* xmpp,
743                                     InfXmppConnectionStreamError code,
744                                     const gchar* message)
745 {
746   InfXmppConnectionPrivate* priv;
747   xmlNodePtr node;
748   xmlNodePtr child;
749   GError* error;
750   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
751   g_assert(priv-&gt;parser != NULL);
752   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING &amp;&amp;
753            priv-&gt;status != INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED);
754   error = NULL;
755   g_set_error_literal(
756     &amp;error,
757     inf_xmpp_connection_stream_error_quark,
758     code,
759     message != NULL ? message : inf_xmpp_connection_stream_strerror(code)
760   );
761   node = xmlNewNode(NULL, (const xmlChar*)"stream:error");
762   child = inf_xmpp_connection_node_new_streams(
763     inf_xmpp_connection_stream_error_to_condition(code)
764   );
765   xmlAddChild(node, child);
766   if(message != NULL)
767   {
768     child = inf_xmpp_connection_node_new_streams("text");
769     xmlNodeAddContent(child, (const xmlChar*)message);
770     xmlNodeSetLang(child, (const xmlChar*)"en");
771   }
772   inf_xmpp_connection_send_xml(xmpp, node);
773   xmlFreeNode(node);
774   inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
775   g_error_free(error);
776   inf_xmpp_connection_terminate(xmpp);
777 }
778 static void
779 inf_xmpp_connection_deinitiate(InfXmppConnection* xmpp)
780 {
781   static const gchar xmpp_connection_deinitiate_request[] =
782     "&lt;/stream:stream&gt;";
783   InfXmppConnectionPrivate* priv;
784   xmlNodePtr abort;
785   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
786   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_GNUTLS &amp;&amp;
787            priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_STREAM &amp;&amp;
788            priv-&gt;status != INF_XMPP_CONNECTION_CONNECTED &amp;&amp;
789            priv-&gt;status != INF_XMPP_CONNECTION_AUTH_CONNECTED);
790   if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT &amp;&amp;
791      priv-&gt;sasl_remote_mechanisms != NULL)
792   {
793     g_free(priv-&gt;sasl_remote_mechanisms);
794     priv-&gt;sasl_remote_mechanisms = NULL;
795   }
796   if(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING)
797   {
798     if(priv-&gt;sasl_session != NULL)
799     {
800       abort = inf_xmpp_connection_node_new_sasl("abort");
801       inf_xmpp_connection_send_xml(xmpp, abort);
802     }
803   }
804   inf_xmpp_connection_send_chars(
805     xmpp,
806     xmpp_connection_deinitiate_request,
807     sizeof(xmpp_connection_deinitiate_request) - 1
808   );
809   priv-&gt;status = INF_XMPP_CONNECTION_CLOSING_STREAM;
810   g_object_notify(G_OBJECT(xmpp), "status");
811 }
812 static void
813 inf_xmpp_connection_initiate(InfXmppConnection* xmpp);
814 static gboolean
815 inf_xmpp_connection_prefers_tls(InfXmppConnection* xmpp)
816 {
817   InfXmppConnectionPrivate* priv;
818   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
819   return
820     priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS ||
821     priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS;
822 }
823 static ssize_t
824 inf_xmpp_connection_tls_push(gnutls_transport_ptr_t ptr,
825                              const void* data,
826                              size_t len)
827 {
828   InfXmppConnection* xmpp;
829   InfXmppConnectionPrivate* priv;
830   xmpp = INF_XMPP_CONNECTION(ptr);
831   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
832   priv-&gt;position += len;
833   inf_tcp_connection_send(priv-&gt;tcp, data, len);
834   return len;
835 }
836 static ssize_t
837 inf_xmpp_connection_tls_pull(gnutls_transport_ptr_t ptr,
838                              void* data,
839                              size_t len)
840 {
841   InfXmppConnection* xmpp;
842   InfXmppConnectionPrivate* priv;
843   size_t pull_len;
844   xmpp = INF_XMPP_CONNECTION(ptr);
845   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
846   if(priv-&gt;pull_len == 0)
847   {
848     gnutls_transport_set_errno(priv-&gt;session, EAGAIN);
849     return -1;
850   }
851   else
852   {
853     pull_len = priv-&gt;pull_len;
854     if(len &lt; pull_len) pull_len = len;
855     memcpy(data, priv-&gt;pull_data, pull_len);
856     priv-&gt;pull_len -= pull_len;
857     priv-&gt;pull_data += pull_len;
858     return pull_len;
859   }
860 }
861 static gnutls_x509_crt_t
862 inf_xmpp_connection_tls_import_own_certificate(InfXmppConnection* xmpp,
863                                                GError** error)
864 {
865   InfXmppConnectionPrivate* priv;
866   const gnutls_datum_t* cert_raw;
867   gnutls_x509_crt_t cert;
868   int res;
869   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
870   cert_raw = gnutls_certificate_get_ours(priv-&gt;session);
871   if(cert_raw == NULL)
872     return NULL;
873   res = gnutls_x509_crt_init(&amp;cert);
874   if(res != GNUTLS_E_SUCCESS)
875   {
876     inf_gnutls_set_error(error, res);
877     return NULL;
878   }
879   res = gnutls_x509_crt_import(cert, cert_raw, GNUTLS_X509_FMT_DER);
880   if(res != GNUTLS_E_SUCCESS)
881   {
882     gnutls_x509_crt_deinit(cert);
883     inf_gnutls_set_error(error, res);
884     return NULL;
885   }
886   return cert;
887 }
888 static InfCertificateChain*
889 inf_xmpp_connection_tls_import_peer_certificate(InfXmppConnection* xmpp,
890                                                 GError** error)
891 {
892   InfXmppConnectionPrivate* priv;
893   const gnutls_datum_t* certs_raw;
894   unsigned int list_size;
895   unsigned int n_certs;
896   gnutls_x509_crt_t* certs;
897   int res;
898   guint i;
899   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
900   certs_raw = gnutls_certificate_get_peers(priv-&gt;session, &amp;list_size);
901   if(certs_raw == NULL)
902     return NULL;
903   certs = g_malloc(list_size * sizeof(gnutls_x509_crt_t));
904 #if 0
905   n_certs = list_size;
906   res = gnutls_x509_crt_list_import(
907     certs,
908     &amp;n_certs,
909     certs_raw,
910     GNUTLS_X509_FMT_DER,
911     GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED
912   );
913   if(res &lt; 0)
914   {
915     g_free(certs);
916     inf_gnutls_set_error(error, res);
917     return NULL;
918   }
919   g_assert(res == n_certs);
920   g_assert(res == list_size);
921 #else
922   for(i = 0; i &lt; list_size; ++ i)
923   {
924     res = gnutls_x509_crt_init(&amp;certs[i]);
925     if(res == GNUTLS_E_SUCCESS)
926     {
927       res = gnutls_x509_crt_import(
928         certs[i],
929         certs_raw + i,
930         GNUTLS_X509_FMT_DER
931       );
932       if(res != GNUTLS_E_SUCCESS)
933         gnutls_x509_crt_deinit(certs[i]);
934     }
935     if(res != GNUTLS_E_SUCCESS)
936     {
937       for(; i &gt; 0; -- i)
938         gnutls_x509_crt_deinit(certs[i - 1]);
939       g_free(certs);
940       inf_gnutls_set_error(error, res);
941       return NULL;
942     }
943   }
944 #endif
945   return inf_certificate_chain_new(certs, list_size);
946 }
947 static void
948 inf_xmpp_connection_tls_handshake(InfXmppConnection* xmpp)
949 {
950   InfXmppConnectionPrivate* priv;
951   int ret;
952   InfCertificateChain* chain;
953   GError* error;
954   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
955   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_HANDSHAKING);
956   g_assert(priv-&gt;session != NULL);
957   ret = gnutls_handshake(priv-&gt;session);
958   switch(ret)
959   {
960   case GNUTLS_E_AGAIN:
961     break;
962   case 0:
963     priv-&gt;status = INF_XMPP_CONNECTION_CONNECTED;
964     g_object_notify(G_OBJECT(xmpp), "tls-enabled");
965     error = NULL;
966     g_assert(priv-&gt;own_cert == NULL);
967     priv-&gt;own_cert =
968       inf_xmpp_connection_tls_import_own_certificate(xmpp, &amp;error);
969     if(error == NULL)
970     {
971       if(priv-&gt;own_cert != NULL)
972         g_object_notify(G_OBJECT(xmpp), "local-certificate");
973       g_assert(priv-&gt;peer_cert == NULL);
974       priv-&gt;peer_cert =
975         inf_xmpp_connection_tls_import_peer_certificate(xmpp, &amp;error);
976       if(error == NULL)
977       {
978         if(priv-&gt;peer_cert == NULL)
979         {
980           if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
981           {
982             g_set_error_literal(
983               &amp;error,
984               inf_xmpp_connection_error_quark(),
985               INF_XMPP_CONNECTION_ERROR_NO_CERTIFICATE_PROVIDED,
986               _("The server did not provide a certificate")
987             );
988           }
989         }
990         else
991         {
992           g_object_notify(G_OBJECT(xmpp), "remote-certificate");
993         }
994       }
995     }
996     if(error != NULL)
997     {
998       inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
999       g_error_free(error);
1000       inf_xmpp_connection_terminate(xmpp);
1001     }
1002     else
1003     {
1004       if(priv-&gt;certificate_callback != NULL)
1005       {
1006         priv-&gt;certificate_callback(
1007           xmpp,
1008           priv-&gt;session,
1009           priv-&gt;peer_cert,
1010           priv-&gt;certificate_callback_user_data
1011         );
1012       }
1013       else
1014       {
1015         inf_xmpp_connection_initiate(xmpp);
1016       }
1017     }
1018     break;
1019   default:
1020     error = NULL;
1021     inf_gnutls_set_error(&amp;error, ret);
1022     inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1023     g_error_free(error);
1024     gnutls_deinit(priv-&gt;session);
1025     priv-&gt;session = NULL;
1026     switch(priv-&gt;site)
1027     {
1028     case INF_XMPP_CONNECTION_CLIENT:
1029       inf_xmpp_connection_terminate(xmpp);
1030       break;
1031     case INF_XMPP_CONNECTION_SERVER:
1032       priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
1033       inf_xmpp_connection_terminate(xmpp);
1034       break;
1035     default:
1036       g_assert_not_reached();
1037       break;
1038     }
1039     break;
1040   }
1041 }
1042 static void
1043 inf_xmpp_connection_tls_init(InfXmppConnection* xmpp)
1044 {
1045   InfXmppConnectionPrivate* priv;
1046   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1047   g_assert(priv-&gt;session == NULL);
1048   if(priv-&gt;creds == NULL)
1049   {
1050     g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
1051     priv-&gt;creds = inf_certificate_credentials_new();
1052     g_object_notify(G_OBJECT(xmpp), "credentials");
1053   }
1054   switch(priv-&gt;site)
1055   {
1056   case INF_XMPP_CONNECTION_CLIENT:
1057     gnutls_init(&amp;priv-&gt;session, GNUTLS_CLIENT);
1058     break;
1059   case INF_XMPP_CONNECTION_SERVER:
1060     gnutls_init(&amp;priv-&gt;session, GNUTLS_SERVER);
1061     if(priv-&gt;certificate_callback != NULL)
1062     {
1063       gnutls_certificate_server_set_request(
1064         priv-&gt;session,
1065         priv-&gt;certificate_request
1066       );
1067     }
1068     break;
1069   default:
1070     g_assert_not_reached();
1071     break;
1072   }
1073   gnutls_priority_set_direct(priv-&gt;session, "NORMAL:-RSA:+RSA", NULL);
1074   gnutls_credentials_set(
1075     priv-&gt;session,
1076     GNUTLS_CRD_CERTIFICATE,
1077     inf_certificate_credentials_get(priv-&gt;creds)
1078   );
1079   gnutls_transport_set_ptr(priv-&gt;session, xmpp);
1080   gnutls_transport_set_push_function(
1081     priv-&gt;session,
1082     inf_xmpp_connection_tls_push
1083   );
1084   gnutls_transport_set_pull_function(
1085     priv-&gt;session,
1086     inf_xmpp_connection_tls_pull
1087   );
1088   priv-&gt;status = INF_XMPP_CONNECTION_HANDSHAKING;
1089   inf_xmpp_connection_tls_handshake(xmpp);
1090 }
1091 static gboolean
1092 inf_xmpp_connection_sasl_has_mechanism(const char* mechlist,
1093                                        const char* mechanism)
1094 {
1095   size_t len;
1096   const char* res;
1097   for(len = strlen(mechanism); mechlist != NULL; mechlist = strchr(res, ' '))
1098   {
1099     res = strstr(mechlist, mechanism);
1100     if(res == NULL)
1101       return FALSE;
1102     if( (res == mechlist  || isspace(res[ -1])) &amp;&amp;
1103         (res[len] == '\0' || isspace(res[len])))
1104       return TRUE;
1105   }
1106   return FALSE;
1107 }
1108 static void
1109 inf_xmpp_connection_sasl_finish(InfXmppConnection* xmpp,
1110                                 gboolean success)
1111 {
1112   InfXmppConnectionPrivate* priv;
1113   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1114   if(priv-&gt;sasl_session != NULL)
1115   {
1116     inf_sasl_context_stop_session(priv-&gt;sasl_context, priv-&gt;sasl_session);
1117     priv-&gt;sasl_session = NULL;
1118   }
1119   if(success)
1120   {
1121     if(priv-&gt;sasl_error != NULL)
1122     {
1123       g_error_free(priv-&gt;sasl_error);
1124       priv-&gt;sasl_error = NULL;
1125     }
1126     priv-&gt;status = INF_XMPP_CONNECTION_AUTH_CONNECTED;
1127     if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
1128     {
1129       g_assert(priv-&gt;sasl_remote_mechanisms != NULL);
1130       g_free(priv-&gt;sasl_remote_mechanisms);
1131       priv-&gt;sasl_remote_mechanisms = NULL;
1132     }
1133     else
1134     {
1135       g_assert(priv-&gt;sasl_remote_mechanisms == NULL);
1136     }
1137     if(priv-&gt;parsing == 0)
1138       inf_xmpp_connection_initiate(xmpp);
1139   }
1140   else
1141   {
1142     if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
1143       priv-&gt;status = INF_XMPP_CONNECTION_AWAITING_FEATURES;
1144     else
1145       priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
1146   }
1147 }
1148 static void
1149 inf_xmpp_connection_sasl_error(InfXmppConnection* xmpp,
1150                                const GError* error)
1151 {
1152   InfXmppConnectionPrivate* priv;
1153   InfXmppConnectionAuthError auth_code;
1154   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1155   inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1156   if(priv-&gt;site == INF_XMPP_CONNECTION_SERVER)
1157   {
1158     switch(error-&gt;code)
1159     {
1160     case GSASL_UNKNOWN_MECHANISM:
1161     case GSASL_MECHANISM_PARSE_ERROR:
1162       auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM;
1163       break;
1164     case GSASL_BASE64_ERROR:
1165       auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_INCORRECT_ENCODING;
1166       break;
1167     case GSASL_AUTHENTICATION_ERROR:
1168       auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_NOT_AUTHORIZED;
1169       break;
1170     default:
1171       auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE;
1172       break;
1173     }
1174     inf_xmpp_connection_send_auth_error(xmpp, auth_code);
1175     priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
1176     inf_xmpp_connection_sasl_finish(xmpp, FALSE);
1177   }
1178   else
1179   {
1180     inf_xmpp_connection_sasl_finish(xmpp, FALSE);
1181     inf_xmpp_connection_terminate(xmpp);
1182   }
1183 }
1184 static void
1185 inf_xmpp_connection_sasl_cb(InfSaslContextSession* session,
1186                             Gsasl_property property,
1187                             gpointer session_data,
1188                             gpointer user_data)
1189 {
1190   InfXmppConnection* xmpp;
1191   InfXmppConnectionPrivate* priv;
1192   xmpp = INF_XMPP_CONNECTION(user_data);
1193   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1194   switch(property)
1195   {
1196   case GSASL_ANONYMOUS_TOKEN:
1197     inf_sasl_context_session_set_property(
1198       session,
1199       GSASL_ANONYMOUS_TOKEN,
1200       g_get_user_name()
1201     );
1202     inf_sasl_context_session_continue(session, GSASL_OK);
1203     break;
1204   case GSASL_VALIDATE_ANONYMOUS:
1205     inf_sasl_context_session_continue(session, GSASL_OK);
1206     break;
1207   default:
1208     g_assert_not_reached();
1209     inf_sasl_context_session_continue(session, GSASL_NO_CALLBACK);
1210     break;
1211   }
1212 }
1213 static gboolean
1214 inf_xmpp_connection_sasl_ensure(InfXmppConnection* xmpp)
1215 {
1216   InfXmppConnectionPrivate* priv;
1217   GError* error;
1218   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1219   if(priv-&gt;sasl_context == NULL)
1220   {
1221     g_assert(priv-&gt;sasl_own_context == NULL);
1222     error = NULL;
1223     priv-&gt;sasl_own_context = inf_sasl_context_new(&amp;error);
1224     if(priv-&gt;sasl_own_context == NULL)
1225     {
1226       inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1227       g_error_free(error);
1228       inf_xmpp_connection_terminate(xmpp);
1229       return FALSE;
1230     }
1231     else
1232     {
1233       priv-&gt;sasl_context = priv-&gt;sasl_own_context;
1234       inf_sasl_context_ref(priv-&gt;sasl_context);
1235       inf_sasl_context_set_callback(
1236         priv-&gt;sasl_context,
1237         inf_xmpp_connection_sasl_cb,
1238         xmpp,
1239         NULL
1240       );
1241       g_object_notify(G_OBJECT(xmpp), "sasl-context");
1242     }
1243   }
1244   g_assert(priv-&gt;sasl_context != NULL);
1245   return TRUE;
1246 }
1247 static void
1248 inf_xmpp_connection_sasl_request_feed_func(InfSaslContextSession* session,
1249                                            const char* data,
1250                                            gboolean needs_more,
1251                                            const GError* error,
1252                                            gpointer user_data)
1253 {
1254   InfXmppConnection* xmpp;
1255   InfXmppConnectionPrivate* priv;
1256   xmlNodePtr reply;
1257   xmpp = INF_XMPP_CONNECTION(user_data);
1258   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1259   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING);
1260   g_assert(priv-&gt;sasl_session != NULL);
1261   if(error)
1262   {
1263     inf_xmpp_connection_sasl_error(xmpp, error);
1264   }
1265   else
1266   {
1267     if(data != NULL)
1268     {
1269       reply = NULL;
1270       switch(priv-&gt;site)
1271       {
1272       case INF_XMPP_CONNECTION_SERVER:
1273         if(needs_more)
1274           reply = inf_xmpp_connection_node_new_sasl("challenge");
1275         break;
1276       case INF_XMPP_CONNECTION_CLIENT:
1277         reply = inf_xmpp_connection_node_new_sasl("response");
1278         break;
1279       default:
1280         g_assert_not_reached();
1281         break;
1282       }
1283       if(reply != NULL)
1284       {
1285         xmlNodeAddContent(reply, (const xmlChar*)data);
1286         inf_xmpp_connection_send_xml(xmpp, reply);
1287         xmlFreeNode(reply);
1288       }
1289     }
1290     if(!needs_more)
1291     {
1292       if(priv-&gt;site == INF_XMPP_CONNECTION_SERVER)
1293       {
1294         reply = inf_xmpp_connection_node_new_sasl("success");
1295         inf_xmpp_connection_send_xml(xmpp, reply);
1296         xmlFreeNode(reply);
1297         inf_xmpp_connection_sasl_finish(xmpp, TRUE);
1298       }
1299     }
1300   }
1301 }
1302 static void
1303 inf_xmpp_connection_sasl_request(InfXmppConnection* xmpp,
1304                                  const gchar* input)
1305 {
1306   InfXmppConnectionPrivate* priv;
1307   GError* error;
1308   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1309   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING);
1310   g_assert(priv-&gt;sasl_session != NULL);
1311   if(inf_sasl_context_session_is_processing(priv-&gt;sasl_session))
1312   {
1313     error = NULL;
1314     inf_gsasl_set_error(&amp;error, GSASL_INTEGRITY_ERROR);
1315     inf_xmpp_connection_sasl_error(xmpp, error);
1316     g_error_free(error);
1317   }
1318   else
1319   {
1320     inf_sasl_context_session_feed(
1321       priv-&gt;sasl_session,
1322       input,
1323       inf_xmpp_connection_sasl_request_feed_func,
1324       xmpp
1325     );
1326   }
1327 }
1328 static void
1329 inf_xmpp_connection_sasl_init(InfXmppConnection* xmpp,
1330                               const gchar* mechanism)
1331 {
1332   InfXmppConnectionPrivate* priv;
1333   InfIo* io;
1334   xmlNodePtr auth;
1335   GError* error;
1336   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1337   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_AUTHENTICATING);
1338   g_assert(priv-&gt;sasl_context != NULL);
1339   g_assert(priv-&gt;sasl_session == NULL);
1340   g_assert(priv-&gt;tcp != NULL);
1341   if(priv-&gt;sasl_error != NULL)
1342   {
1343     g_error_free(priv-&gt;sasl_error);
1344     priv-&gt;sasl_error = NULL;
1345   }
1346   g_object_get(G_OBJECT(priv-&gt;tcp), "io", &amp;io, NULL);
1347   g_assert(io != NULL);
1348   switch(priv-&gt;site)
1349   {
1350   case INF_XMPP_CONNECTION_CLIENT:
1351     auth = inf_xmpp_connection_node_new_sasl("auth");
1352     xmlNewProp(
1353       auth,
1354       (const xmlChar*)"mechanism",
1355       (const xmlChar*)mechanism
1356     );
1357     inf_xmpp_connection_send_xml(xmpp, auth);
1358     xmlFreeNode(auth);
1359     g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES);
1360     error = NULL;
1361     priv-&gt;sasl_session = inf_sasl_context_client_start_session(
1362       priv-&gt;sasl_context,
1363       io,
1364       mechanism,
1365       xmpp,
1366       &amp;error
1367     );
1368     break;
1369   case INF_XMPP_CONNECTION_SERVER:
1370     g_assert(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED);
1371     error = NULL;
1372     priv-&gt;sasl_session = inf_sasl_context_server_start_session(
1373       priv-&gt;sasl_context,
1374       io,
1375       mechanism,
1376       xmpp,
1377       &amp;error
1378     );
1379     break;
1380   default:
1381     g_assert_not_reached();
1382     break;
1383   }
1384   g_object_unref(io);
1385   if(error != NULL)
1386   {
1387     inf_xmpp_connection_sasl_error(xmpp, error);
1388     g_error_free(error);
1389   }
1390   else
1391   {
1392     priv-&gt;status = INF_XMPP_CONNECTION_AUTHENTICATING;
1393     if(priv-&gt;site == INF_XMPP_CONNECTION_SERVER)
1394       inf_xmpp_connection_sasl_request(xmpp, NULL);
1395   }
1396 }
1397 static void
1398 inf_xmpp_connection_process_start_element(InfXmppConnection* xmpp,
1399                                           const xmlChar* name,
1400                                           const xmlChar** attrs)
1401 {
1402   InfXmppConnectionPrivate* priv;
1403   xmlNodePtr node;
1404   const xmlChar** attr;
1405   const xmlChar* attr_name;
1406   const xmlChar* attr_value;
1407   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1408   node = xmlNewNode(NULL, name);
1409   if(attrs != NULL)
1410   {
1411     attr = attrs;
1412     while(*attr != NULL)
1413     {
1414       attr_name = *attr;
1415       ++ attr;
1416       attr_value = *attr;
1417       ++ attr;
1418       xmlNewProp(node, attr_name, attr_value);
1419     }
1420   }
1421   if(priv-&gt;root == NULL)
1422   {
1423     g_assert(priv-&gt;cur == NULL);
1424     priv-&gt;root = node;
1425     priv-&gt;cur = node;
1426   }
1427   else
1428   {
1429     g_assert(priv-&gt;cur != NULL);
1430     priv-&gt;cur = xmlAddChild(priv-&gt;cur, node);
1431   }
1432 }
1433 static void
1434 inf_xmpp_connection_process_connected(InfXmppConnection* xmpp,
1435                                       const xmlChar** attrs)
1436 {
1437   static const gchar xmpp_connection_initial_request[] = 
1438     "&lt;stream:stream xmlns:stream=\"http://etherx.jabber.org/streams\" "
1439     "xmlns=\"jabber:client\" version=\"1.0\" from=\"%s\"&gt;";
1440   InfXmppConnectionPrivate* priv;
1441   char* mech_list;
1442   char* begin;
1443   char* end;
1444   gchar* reply;
1445   xmlNodePtr features;
1446   xmlNodePtr starttls;
1447   xmlNodePtr mechanisms;
1448   xmlNodePtr mechanism;
1449   gchar* mechanism_dup;
1450   GError* error;
1451   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1452   g_assert(priv-&gt;site == INF_XMPP_CONNECTION_SERVER);
1453   g_assert(priv-&gt;parser != NULL);
1454   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
1455            priv-&gt;status == INF_XMPP_CONNECTION_AUTH_CONNECTED);
1456   reply = g_strdup_printf(
1457     xmpp_connection_initial_request,
1458     priv-&gt;local_hostname
1459   );
1460   inf_xmpp_connection_send_chars(xmpp, reply, strlen(reply));
1461   g_free(reply);
1462   switch(priv-&gt;status)
1463   {
1464   case INF_XMPP_CONNECTION_CONNECTED:
1465     priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
1466     break;
1467   case INF_XMPP_CONNECTION_AUTH_CONNECTED:
1468     priv-&gt;status = INF_XMPP_CONNECTION_AUTH_INITIATED;
1469     break;
1470   default:
1471     g_assert_not_reached();
1472     break;
1473   }
1474   features = xmlNewNode(NULL, (const xmlChar*)"stream:features");
1475   if(priv-&gt;session == NULL &amp;&amp;
1476      priv-&gt;status != INF_XMPP_CONNECTION_AUTH_INITIATED)
1477   {
1478     if(priv-&gt;security_policy != INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED)
1479     {
1480       starttls = inf_xmpp_connection_node_new_tls("starttls");
1481       xmlAddChild(features, starttls);
1482       if(priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS)
1483         xmlNewChild(starttls, NULL, (const xmlChar*)"required", NULL);
1484     }
1485   }
1486   if(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED)
1487   {
1488     mechanisms = inf_xmpp_connection_node_new_sasl("mechanisms");
1489     xmlAddChild(features, mechanisms);
1490     if(inf_xmpp_connection_sasl_ensure(xmpp) == FALSE)
1491     {
1492       xmlFreeNode(features);
1493       return;
1494     }
1495     else if(priv-&gt;sasl_own_context != NULL)
1496     {
1497       xmlNewTextChild(
1498         mechanisms,
1499         NULL,
1500         (const xmlChar*)"mechanism",
1501         (const xmlChar*)"ANONYMOUS"
1502       );
1503     }
1504     else
1505     {
1506       if(priv-&gt;sasl_local_mechanisms == NULL)
1507       {
1508         error = NULL;
1509         mech_list = inf_sasl_context_server_list_mechanisms(
1510           priv-&gt;sasl_context,
1511           &amp;error
1512         );
1513         if(error != NULL)
1514         {
1515           xmlFreeNode(features);
1516           inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1517           g_error_free(error);
1518           inf_xmpp_connection_terminate(xmpp);
1519           return;
1520         }
1521       }
1522       else
1523       {
1524         mech_list = priv-&gt;sasl_local_mechanisms;
1525       }
1526       begin = end = mech_list;
1527       while(*end != '\0')
1528       {
1529         end = strpbrk(begin, " \t\r\n");
1530         if(end == NULL) end = begin + strlen(begin);
1531         mechanism_dup = g_strndup(begin, end - begin);
1532         if(inf_sasl_context_server_supports_mechanism(priv-&gt;sasl_context,
1533                                                       mechanism_dup))
1534         {
1535           mechanism = xmlNewChild(
1536             mechanisms,
1537             NULL,
1538             (const xmlChar*)"mechanism",
1539             NULL
1540           );
1541           xmlNodeAddContentLen(mechanism, (const xmlChar*)begin, end - begin);
1542         }
1543         g_free(mechanism_dup);
1544         begin = end + 1;
1545       }
1546       if(priv-&gt;sasl_local_mechanisms == NULL)
1547         g_free(mech_list);
1548     }
1549   }
1550   inf_xmpp_connection_send_xml(xmpp, features);
1551   xmlFreeNode(features);
1552   if(priv-&gt;status == INF_XMPP_CONNECTION_AUTH_INITIATED)
1553   {
1554     priv-&gt;status = INF_XMPP_CONNECTION_READY;
1555     g_object_notify(G_OBJECT(xmpp), "status");
1556   }
1557 }
1558 static void
1559 inf_xmpp_connection_process_initiated(InfXmppConnection* xmpp,
1560                                       xmlNodePtr xml)
1561 {
1562   InfXmppConnectionPrivate* priv;
1563   xmlNodePtr proceed;
1564   xmlChar* mech;
1565   gboolean has_mechanism;
1566   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1567   g_assert(priv-&gt;site == INF_XMPP_CONNECTION_SERVER);
1568   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED);
1569   if(priv-&gt;session == NULL &amp;&amp;
1570      priv-&gt;security_policy != INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED)
1571   {
1572     if(strcmp((const gchar*)xml-&gt;name, "starttls") == 0)
1573     {
1574       proceed = inf_xmpp_connection_node_new_tls("proceed");
1575       inf_xmpp_connection_send_xml(xmpp, proceed);
1576       xmlFreeNode(proceed);
1577       inf_xmpp_connection_tls_init(xmpp);
1578     }
1579     else if(priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS)
1580     {
1581       inf_xmpp_connection_terminate_error(
1582         xmpp,
1583         INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED,
1584         _("Stream is not yet secured with TLS")
1585       );
1586     }
1587   }
1588   if(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED)
1589   {
1590     g_assert(priv-&gt;sasl_context != NULL);
1591     if(strcmp((const gchar*)xml-&gt;name, "auth") == 0)
1592     {
1593       mech = xmlGetProp(xml, (const xmlChar*)"mechanism");
1594       has_mechanism = TRUE;
1595       if(mech == NULL)
1596       {
1597         has_mechanism = FALSE;
1598       }
1599       else if(!inf_sasl_context_server_supports_mechanism(priv-&gt;sasl_context,
1600                                                           (const char*)mech))
1601       {
1602         has_mechanism = FALSE;
1603       }
1604       else if(priv-&gt;sasl_own_context == NULL &amp;&amp;
1605               priv-&gt;sasl_local_mechanisms != NULL &amp;&amp;
1606               !inf_xmpp_connection_sasl_has_mechanism(
1607                   priv-&gt;sasl_local_mechanisms,
1608                   (const char*)mech))
1609       {
1610         has_mechanism = FALSE;
1611       }
1612       else if(priv-&gt;sasl_own_context != NULL &amp;&amp;
1613               g_ascii_strcasecmp((const char*)mech, "ANONYMOUS") != 0)
1614       {
1615         has_mechanism = FALSE;
1616       }
1617       if(has_mechanism)
1618       {
1619         inf_xmpp_connection_sasl_init(xmpp, (const gchar*)mech);
1620       }
1621       else
1622       {
1623         inf_xmpp_connection_send_auth_error(
1624           xmpp,
1625           INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM
1626         );
1627         inf_xmpp_connection_emit_auth_error(
1628           xmpp,
1629           INF_XMPP_CONNECTION_AUTH_ERROR_INVALID_MECHANISM
1630         );
1631       }
1632       if(mech != NULL)
1633         xmlFree(mech);
1634     }
1635     else
1636     {
1637       inf_xmpp_connection_terminate_error(
1638         xmpp,
1639         INF_XMPP_CONNECTION_STREAM_ERROR_NOT_AUTHORIZED,
1640         _("Stream is not yet authorized")
1641       );
1642     }
1643   }
1644 }
1645 static void
1646 inf_xmpp_connection_load_sasl_remote_mechanisms(InfXmppConnection* xmpp,
1647                                                 xmlNodePtr xml)
1648 {
1649   InfXmppConnectionPrivate* priv;
1650   GString* mechanisms_string;
1651   xmlNodePtr child;
1652   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1653   g_assert(priv-&gt;sasl_remote_mechanisms == NULL);
1654   mechanisms_string = g_string_sized_new(128);
1655   for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
1656   {
1657     if(strcmp((const gchar*)child-&gt;name, "mechanism") == 0 &amp;&amp;
1658        child-&gt;children != NULL &amp;&amp;
1659        child-&gt;children-&gt;content != NULL)
1660     {
1661       g_string_append(
1662         mechanisms_string,
1663         (const char*) child-&gt;children-&gt;content
1664       );
1665       if(child-&gt;next != NULL)
1666         g_string_append_c(mechanisms_string, ' ');
1667     }
1668   }
1669   priv-&gt;sasl_remote_mechanisms = g_string_free(mechanisms_string, FALSE);
1670 }
1671 static const gchar*
1672 inf_xmpp_connection_sasl_suggest_mechanism(InfXmppConnection* xmpp,
1673                                            GError** error)
1674 {
1675   InfXmppConnectionPrivate* priv;
1676   GString* mechanisms_string;
1677   GString* mechanism_string;
1678   char* iter;
1679   char* end;
1680   const gchar* suggestion;
1681   gboolean has_mechanism;
1682   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1683   suggestion = NULL;
1684   if(priv-&gt;sasl_own_context != NULL)
1685   {
1686     for(iter = priv-&gt;sasl_remote_mechanisms; *iter; iter = end + 1)
1687     {
1688       end = strchr(iter, ' ');
1689       if(end == NULL)
1690       {
1691         if(strcmp(iter, "ANONYMOUS") == 0)
1692           suggestion = "ANONYMOUS";
1693         break;
1694       }
1695       if(strncmp(iter, "ANONYMOUS",
1696                  MAX((size_t) (end - iter), sizeof("ANONYMOUS") - 1)) == 0)
1697       {
1698         suggestion = "ANONYMOUS";
1699         break;
1700       }
1701     }
1702   }
1703   else
1704   {
1705     mechanisms_string = g_string_sized_new(128);
1706     mechanism_string = g_string_sized_new(16);     for(end = iter = priv-&gt;sasl_remote_mechanisms; end; iter = end + 1)
1707     {
1708       end = strchr(iter, ' ');
1709       if(end != NULL)
1710       {
1711         g_string_overwrite_len(mechanism_string, 0, iter, end - iter);
1712         g_string_truncate(mechanism_string, end - iter);
1713         iter = mechanism_string-&gt;str;
1714       }
1715       has_mechanism =
1716         inf_sasl_context_client_supports_mechanism(priv-&gt;sasl_context, iter);
1717       if(has_mechanism == TRUE &amp;&amp; priv-&gt;sasl_local_mechanisms != NULL)
1718       {
1719         has_mechanism = inf_xmpp_connection_sasl_has_mechanism(
1720           priv-&gt;sasl_local_mechanisms,
1721           iter
1722         );
1723       }
1724       if(has_mechanism == TRUE)
1725       {
1726         if(mechanisms_string-&gt;len &gt; 0)
1727           g_string_append_c(mechanisms_string, ' ');
1728         g_string_append(mechanisms_string, iter);
1729       }
1730     }
1731     if(mechanisms_string-&gt;len &gt; 0)
1732     {
1733       suggestion = inf_sasl_context_client_suggest_mechanism(
1734         priv-&gt;sasl_context,
1735         mechanisms_string-&gt;str
1736       );
1737     }
1738     g_string_free(mechanisms_string, TRUE);
1739   }
1740   if(suggestion == NULL)
1741   {
1742     g_set_error_literal(
1743       error,
1744       inf_xmpp_connection_error_quark(),
1745       INF_XMPP_CONNECTION_ERROR_NO_SUITABLE_MECHANISM,
1746       _("The server does not offer a suitable authentication mechanism")
1747     );
1748   }
1749   return suggestion;
1750 }
1751 static void
1752 inf_xmpp_connection_process_features(InfXmppConnection* xmpp,
1753                                      xmlNodePtr xml)
1754 {
1755   InfXmppConnectionPrivate* priv;
1756   xmlNodePtr child;
1757   xmlNodePtr req;
1758   xmlNodePtr starttls;
1759   const char* suggestion;
1760   GError* error;
1761   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1762   g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
1763   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES ||
1764            priv-&gt;status == INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES);
1765   if(strcmp((const gchar*)xml-&gt;name, "stream:features") != 0)
1766   {
1767     return;
1768   }
1769   else if(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES &amp;&amp;
1770           priv-&gt;session == NULL)
1771   {
1772     for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
1773       if(strcmp((const gchar*)child-&gt;name, "starttls") == 0)
1774         break;
1775     if(child == NULL &amp;&amp;
1776        priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_TLS)
1777     {
1778       error = g_error_new_literal(
1779         inf_xmpp_connection_error_quark(),
1780         INF_XMPP_CONNECTION_ERROR_TLS_UNSUPPORTED,
1781         _("The server does not support transport layer security (TLS)")
1782       );
1783       inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1784       g_error_free(error);
1785       inf_xmpp_connection_deinitiate(xmpp);
1786     }
1787     else if(child != NULL)
1788     {
1789       for(req = child-&gt;children; req != NULL; req = req-&gt;next)
1790         if(strcmp((const gchar*)req-&gt;name, "required") == 0)
1791           break;
1792       if(req != NULL &amp;&amp;
1793          priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED)
1794       {
1795         error = NULL;
1796         g_set_error_literal(
1797           &amp;error,
1798           inf_xmpp_connection_error_quark(),
1799           INF_XMPP_CONNECTION_ERROR_TLS_REQUIRED,
1800           _("The server requires transport layer security (TLS)")
1801         );
1802         inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1803         g_error_free(error);
1804         inf_xmpp_connection_deinitiate(xmpp);
1805       }
1806       else if(req != NULL || inf_xmpp_connection_prefers_tls(xmpp))
1807       {
1808         starttls = inf_xmpp_connection_node_new_tls("starttls");
1809         inf_xmpp_connection_send_xml(xmpp, starttls);
1810         xmlFreeNode(starttls);
1811         priv-&gt;status = INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED;
1812       }
1813     }
1814   }
1815   if(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES)
1816   {
1817     for(child = xml-&gt;children; child != NULL; child = child-&gt;next)
1818       if(strcmp((const gchar*)child-&gt;name, "mechanisms") == 0)
1819         break;
1820     if(child == NULL)
1821     {
1822       error = g_error_new_literal(
1823         inf_xmpp_connection_error_quark(),
1824         INF_XMPP_CONNECTION_ERROR_AUTHENTICATION_UNSUPPORTED,
1825         _("The server does not provide any authentication mechanism")
1826       );
1827       inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1828       g_error_free(error);
1829       inf_xmpp_connection_deinitiate(xmpp);
1830     }
1831     else if(inf_xmpp_connection_sasl_ensure(xmpp) == TRUE)
1832     {
1833       inf_xmpp_connection_load_sasl_remote_mechanisms(xmpp, child);
1834       error = NULL;
1835       suggestion = inf_xmpp_connection_sasl_suggest_mechanism(xmpp, &amp;error);
1836       if(!suggestion)
1837       {
1838         inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1839         g_error_free(error);
1840         if(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES)
1841           inf_xmpp_connection_deinitiate(xmpp);
1842       }
1843       else
1844       {
1845         inf_xmpp_connection_sasl_init(xmpp, suggestion);
1846       }
1847     }
1848   }
1849   else if(priv-&gt;status == INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES)
1850   {
1851     priv-&gt;status = INF_XMPP_CONNECTION_READY;
1852     g_object_notify(G_OBJECT(xmpp), "status");
1853   }
1854 }
1855 static void
1856 inf_xmpp_connection_process_encryption(InfXmppConnection* xmpp,
1857                                        xmlNodePtr xml)
1858 {
1859   InfXmppConnectionPrivate* priv;
1860   GError* error;
1861   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1862   g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
1863   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED);
1864   g_assert(priv-&gt;session == NULL);
1865   if(strcmp((const gchar*)xml-&gt;name, "proceed") == 0)
1866   {
1867     inf_xmpp_connection_tls_init(xmpp);
1868   }
1869   else if(strcmp((const gchar*)xml-&gt;name, "failure") == 0)
1870   {
1871     error = g_error_new_literal(
1872       inf_xmpp_connection_error_quark(),
1873       INF_XMPP_CONNECTION_ERROR_TLS_FAILURE,
1874       _("The server cannot perform the TLS handshake")
1875     );
1876     inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
1877     g_error_free(error);
1878     priv-&gt;status = INF_XMPP_CONNECTION_CLOSING_STREAM;
1879     g_object_notify(G_OBJECT(xmpp), "status");
1880   }
1881   else
1882   {
1883   }
1884 }
1885 static void
1886 inf_xmpp_connection_process_authentication_error(
1887   InfXmppConnection* xmpp,
1888   InfXmppConnectionAuthError auth_code)
1889 {
1890   InfXmppConnectionPrivate* priv;
1891   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1892   g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
1893   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING);
1894   inf_xmpp_connection_sasl_finish(xmpp, FALSE);
1895   inf_xmpp_connection_emit_auth_error(xmpp, auth_code);
1896   if(priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES)
1897     inf_xmpp_connection_deinitiate(xmpp);
1898 }
1899 static void
1900 inf_xmpp_connection_process_authentication(InfXmppConnection* xmpp,
1901                                            xmlNodePtr xml)
1902 {
1903   InfXmppConnectionPrivate* priv;
1904   InfXmppConnectionAuthError auth_code;
1905   xmlNodePtr child;
1906   xmlNodePtr error_node;
1907   xmlChar* content;
1908   GError* local_error;
1909   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
1910   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING);
1911   switch(priv-&gt;site)
1912   {
1913   case INF_XMPP_CONNECTION_CLIENT:
1914     if(strcmp((const gchar*)xml-&gt;name, "challenge") == 0)
1915     {
1916       if(priv-&gt;sasl_session != NULL)
1917       {
1918         content = xmlNodeGetContent(xml);
1919         inf_xmpp_connection_sasl_request(xmpp, (const gchar*)content);
1920         xmlFree(content);
1921       }
1922     }
1923     else if(strcmp((const gchar*)xml-&gt;name, "failure") == 0)
1924     {
1925       child = xml-&gt;children;
1926       auth_code = INF_XMPP_CONNECTION_AUTH_ERROR_FAILED;
1927       if(child != NULL)
1928       {
1929         error_node = child-&gt;children;
1930         if(error_node != NULL &amp;&amp;
1931            strcmp((const char*)error_node-&gt;name, "error") == 0)
1932         {
1933           g_assert(priv-&gt;sasl_error == NULL);
1934           priv-&gt;sasl_error = inf_xml_util_new_error_from_node(error_node);
1935         }
1936         auth_code = inf_xmpp_connection_auth_error_from_condition(
1937           (const gchar*)child-&gt;name
1938         );
1939       }
1940       inf_xmpp_connection_process_authentication_error(xmpp, auth_code);
1941     }
1942     else if(strcmp((const gchar*)xml-&gt;name, "success") == 0)
1943     {
1944       inf_xmpp_connection_sasl_finish(xmpp, TRUE);
1945     }
1946     else
1947     {
1948     }
1949     break;
1950   case INF_XMPP_CONNECTION_SERVER:
1951     if(strcmp((const gchar*)xml-&gt;name, "response") == 0)
1952     {
1953       if(priv-&gt;sasl_session != NULL)
1954       {
1955         content = xmlNodeGetContent(xml);
1956         inf_xmpp_connection_sasl_request(xmpp, (const gchar*)content);
1957         xmlFree(content);
1958       }
1959       else
1960       {
1961         inf_xmpp_connection_sasl_finish(xmpp, FALSE);
1962         local_error = g_error_new_literal(
1963           inf_authentication_detail_error_quark(),
1964           INF_AUTHENTICATION_DETAIL_ERROR_TRY_AGAIN,
1965           inf_authentication_detail_strerror(
1966             INF_AUTHENTICATION_DETAIL_ERROR_TRY_AGAIN)
1967         );
1968         inf_xmpp_connection_set_sasl_error(xmpp, local_error);
1969         g_error_free(local_error);
1970         inf_xmpp_connection_send_auth_error(
1971           xmpp,
1972           INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE
1973         );
1974         inf_xmpp_connection_emit_auth_error(
1975           xmpp,
1976           INF_XMPP_CONNECTION_AUTH_ERROR_TEMPORARY_AUTH_FAILURE
1977         );
1978         if(priv-&gt;sasl_error)
1979         {
1980           g_error_free(priv-&gt;sasl_error);
1981           priv-&gt;sasl_error = NULL;
1982         }
1983       }
1984     }
1985     else if(strcmp((const gchar*)xml-&gt;name, "abort") == 0)
1986     {
1987       inf_xmpp_connection_sasl_finish(xmpp, FALSE);
1988       inf_xmpp_connection_send_auth_error(
1989         xmpp,
1990         INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED
1991       );
1992       inf_xmpp_connection_emit_auth_error(
1993         xmpp,
1994         INF_XMPP_CONNECTION_AUTH_ERROR_ABORTED
1995       );
1996     }
1997     break;
1998   default:
1999     g_assert_not_reached();
2000     break;
2001   }
2002 }
2003 static void
2004 inf_xmpp_connection_process_end_element(InfXmppConnection* xmpp,
2005                                         const xmlChar* name)
2006 {
2007   InfXmppConnectionPrivate* priv;
2008   InfXmppConnectionStreamError stream_code;
2009   GError* error;
2010   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2011   g_assert(priv-&gt;cur != NULL);
2012   g_assert(strcmp((const gchar*)priv-&gt;cur-&gt;name, (const gchar*)name) == 0);
2013   priv-&gt;cur = priv-&gt;cur-&gt;parent;
2014   if(priv-&gt;cur == NULL)
2015   {
2016     if(strcmp((const gchar*)name, "stream:error") == 0)
2017     {
2018       stream_code = INF_XMPP_CONNECTION_STREAM_ERROR_FAILED;
2019       if(priv-&gt;root-&gt;children != NULL)
2020       {
2021         stream_code = inf_xmpp_connection_stream_error_from_condition(
2022           (const gchar*)priv-&gt;root-&gt;children-&gt;name
2023         );
2024       }
2025       error = NULL;
2026       g_set_error_literal(
2027         &amp;error,
2028         inf_xmpp_connection_stream_error_quark,
2029         stream_code,
2030         inf_xmpp_connection_stream_strerror(stream_code)
2031       );
2032       inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
2033       g_error_free(error);
2034     }
2035     else
2036     {
2037       switch(priv-&gt;status)
2038       {
2039       case INF_XMPP_CONNECTION_INITIATED:
2040         g_assert(priv-&gt;site == INF_XMPP_CONNECTION_SERVER);
2041         inf_xmpp_connection_process_initiated(xmpp, priv-&gt;root);
2042         break;
2043       case INF_XMPP_CONNECTION_AWAITING_FEATURES:
2044       case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
2045         g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
2046         inf_xmpp_connection_process_features(xmpp, priv-&gt;root);
2047         break;
2048       case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
2049         g_assert(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT);
2050         inf_xmpp_connection_process_encryption(xmpp, priv-&gt;root);
2051         break;
2052       case INF_XMPP_CONNECTION_AUTHENTICATING:
2053         inf_xmpp_connection_process_authentication(xmpp, priv-&gt;root);
2054         break;
2055       case INF_XMPP_CONNECTION_READY:
2056         inf_xml_connection_received(INF_XML_CONNECTION(xmpp), priv-&gt;root);
2057         break;
2058       case INF_XMPP_CONNECTION_CLOSING_STREAM:
2059         break;
2060       case INF_XMPP_CONNECTION_AUTH_INITIATED:
2061       case INF_XMPP_CONNECTION_CONNECTING:
2062       case INF_XMPP_CONNECTION_CONNECTED:
2063       case INF_XMPP_CONNECTION_AUTH_CONNECTED:
2064       case INF_XMPP_CONNECTION_HANDSHAKING:
2065       case INF_XMPP_CONNECTION_CLOSING_GNUTLS:
2066       case INF_XMPP_CONNECTION_CLOSED:
2067       default:
2068         g_assert_not_reached();
2069         break;
2070       }
2071     }
2072     xmlFreeNode(priv-&gt;root);
2073     priv-&gt;root = NULL;
2074     priv-&gt;cur = NULL;
2075   }
2076 }
2077 static void
2078 inf_xmpp_connection_sax_start_element(void* context,
2079                                       const xmlChar* name,
2080                                       const xmlChar** attrs)
2081 {
2082   InfXmppConnection* xmpp;
2083   InfXmppConnectionPrivate* priv;
2084   xmpp = INF_XMPP_CONNECTION(context);
2085   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2086   if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS)
2087     return;
2088   switch(priv-&gt;status)
2089   {
2090   case INF_XMPP_CONNECTION_CONNECTED:
2091   case INF_XMPP_CONNECTION_AUTH_CONNECTED:
2092     g_assert(priv-&gt;site == INF_XMPP_CONNECTION_SERVER);
2093     if(strcmp((const gchar*)name, "stream:stream") != 0)
2094     {
2095       inf_xmpp_connection_terminate(xmpp);
2096     }
2097     else
2098     {
2099       inf_xmpp_connection_process_connected(xmpp, attrs);
2100     }
2101     break;
2102   case INF_XMPP_CONNECTION_INITIATED:
2103   case INF_XMPP_CONNECTION_AUTH_INITIATED:
2104     if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
2105     {
2106       if(strcmp((const gchar*)name, "stream:stream") != 0)
2107       {
2108         inf_xmpp_connection_terminate(xmpp);
2109       }
2110       else
2111       {
2112         if(priv-&gt;status == INF_XMPP_CONNECTION_INITIATED)
2113           priv-&gt;status = INF_XMPP_CONNECTION_AWAITING_FEATURES;
2114         else
2115           priv-&gt;status = INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES;
2116       }
2117     }
2118     else
2119     {
2120       inf_xmpp_connection_process_start_element(xmpp, name, attrs);
2121     }
2122     break;
2123   case INF_XMPP_CONNECTION_CLOSING_STREAM:
2124   case INF_XMPP_CONNECTION_AWAITING_FEATURES:
2125   case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
2126   case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
2127   case INF_XMPP_CONNECTION_AUTHENTICATING:
2128   case INF_XMPP_CONNECTION_READY:
2129     inf_xmpp_connection_process_start_element(xmpp, name, attrs);
2130     break;
2131   case INF_XMPP_CONNECTION_CLOSING_GNUTLS:
2132   case INF_XMPP_CONNECTION_HANDSHAKING:
2133   case INF_XMPP_CONNECTION_CLOSED:
2134   case INF_XMPP_CONNECTION_CONNECTING:
2135   default:
2136     g_assert_not_reached();
2137     break;
2138   }
2139 }
2140 static void
2141 inf_xmpp_connection_sax_end_element(void* context,
2142                                     const xmlChar* name)
2143 {
2144   InfXmppConnection* xmpp;
2145   InfXmppConnectionPrivate* priv;
2146   xmpp = INF_XMPP_CONNECTION(context);
2147   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2148   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING);
2149   if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS)
2150     return;
2151   if(priv-&gt;root != NULL)
2152   {
2153     inf_xmpp_connection_process_end_element(xmpp, name);
2154   }
2155   else
2156   {
2157     g_assert(strcmp((const gchar*)name, "stream:stream") == 0 ||
2158              priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS ||
2159              priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
2160     switch(priv-&gt;status)
2161     {
2162     case INF_XMPP_CONNECTION_CLOSING_STREAM:
2163     case INF_XMPP_CONNECTION_AUTHENTICATING:
2164     case INF_XMPP_CONNECTION_INITIATED:
2165     case INF_XMPP_CONNECTION_AUTH_INITIATED:
2166     case INF_XMPP_CONNECTION_AWAITING_FEATURES:
2167     case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
2168     case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
2169     case INF_XMPP_CONNECTION_READY:
2170       inf_xmpp_connection_terminate(xmpp);
2171       break;
2172     case INF_XMPP_CONNECTION_CLOSED:
2173     case INF_XMPP_CONNECTION_CLOSING_GNUTLS:
2174       break;
2175     case INF_XMPP_CONNECTION_CONNECTED:
2176     case INF_XMPP_CONNECTION_AUTH_CONNECTED:
2177     case INF_XMPP_CONNECTION_HANDSHAKING:
2178     case INF_XMPP_CONNECTION_CONNECTING:
2179     default:
2180       g_assert_not_reached();
2181       break;
2182     }
2183   }
2184 }
2185 static void
2186 inf_xmpp_connection_sax_characters(void* context,
2187                                    const xmlChar* content,
2188                                    int len)
2189 {
2190   InfXmppConnection* xmpp;
2191   InfXmppConnectionPrivate* priv;
2192   xmpp = INF_XMPP_CONNECTION(context);
2193   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2194   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING);
2195   if(priv-&gt;root == NULL)
2196   {
2197   }
2198   else
2199   {
2200     g_assert(priv-&gt;cur != NULL);
2201     xmlNodeAddContentLen(priv-&gt;cur, content, len);
2202   }
2203 }
2204 static void
2205 inf_xmpp_connection_sax_warning(void* context,
2206                                 const char* msg,
2207                                 ...)
2208 {
2209   InfXmppConnection* xmpp;
2210   InfXmppConnectionPrivate* priv;
2211   InfIpAddress* address;
2212   gchar* addr_str;
2213   gchar* warn_str;
2214   va_list arglist;
2215   xmpp = INF_XMPP_CONNECTION(context);
2216   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2217   g_object_get(G_OBJECT(priv-&gt;tcp), "remote-address", &amp;address, NULL);
2218   addr_str = inf_ip_address_to_string(address);
2219   inf_ip_address_free(address);
2220   va_start(arglist, msg);
2221   warn_str = g_strdup_vprintf(msg, arglist);
2222   va_end(arglist);
2223   g_warning(_("XML warning from %s: %s\n"), addr_str, warn_str);
2224   g_free(addr_str);
2225   g_free(warn_str);
2226 }
2227 static void
2228 inf_xmpp_connection_sax_error(void* context,
2229                               const char* msg,
2230                               ...)
2231 {
2232   InfXmppConnection* xmpp;
2233   InfXmppConnectionPrivate* priv;
2234   InfXmppConnectionStreamError stream_code;
2235   xmlErrorPtr error_xml;
2236   const gchar* message;
2237   xmpp = INF_XMPP_CONNECTION(context);
2238   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2239   error_xml = xmlCtxtGetLastError(priv-&gt;parser);
2240   g_assert(error_xml != NULL);
2241   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING);
2242   if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS)
2243     return;
2244   if(priv-&gt;status != INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED &amp;&amp;
2245      priv-&gt;status != INF_XMPP_CONNECTION_CONNECTED &amp;&amp;
2246      priv-&gt;status != INF_XMPP_CONNECTION_AUTH_CONNECTED)
2247   {
2248     stream_code = INF_XMPP_CONNECTION_STREAM_ERROR_BAD_FORMAT;
2249     if(error_xml-&gt;domain == XML_FROM_PARSER &amp;&amp;
2250        error_xml-&gt;code == XML_ERR_DOCUMENT_EMPTY)
2251     {
2252       message = _("Remote site is not an XMPP server");
2253     }
2254     else
2255     {
2256       message = error_xml-&gt;message;
2257     }
2258     inf_xmpp_connection_terminate_error(xmpp, stream_code, message);
2259   }
2260   else
2261   {
2262     inf_xmpp_connection_terminate(xmpp);
2263 <a name="1"></a>  }
2264 }
2265 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static xmlSAXHandler inf_xmpp_connection_handler = {
2266   NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     NULL,                                     inf_xmpp_connection_sax_start_element,    inf_xmpp_connection_sax_end_element,      NULL,                                     inf_xmpp_connection_sax_characters,       NULL,                                     NULL,                                     NULL,                                     inf_xmpp_connection_sax_warning,          inf_xmpp_connection_sax_error,            inf_xmpp_connection_sax_error,            NULL,                                     NULL,                                     NULL,                                     0,                                        NULL,                                     NULL,                                     NULL,                                     NULL                                    };
2267 static void
2268 inf_xmpp_connection_initiate(InfXmppConnection* xmpp)
2269 {
2270   static const gchar xmpp_connection_initial_request[] =
2271     "&lt;stream:stream version=\"1.0\" xmlns=\"jabber:client\" "
2272     "xmlns:stream=\"http://etherx.jabber.org/streams\" to=\"%s\"&gt;";
2273   InfXmppConnectionPrivate* priv;
2274   gchar* request;
2275   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2276   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
2277            priv-&gt;status == INF_XMPP_CONNECTION_AUTH_CONNECTED);
2278   if(priv-&gt;parser != NULL) xmlFreeParserCtxt(priv-&gt;parser);
2279   priv-&gt;parser = xmlCreatePushParserCtxt(
2280     &amp;inf_xmpp_connection_handler,
2281     xmpp,
2282     NULL,
2283     0,
2284     NULL
2285   );
2286   if(priv-&gt;buf == NULL)
2287   {
2288     priv-&gt;buf = xmlBufferCreate();
2289     priv-&gt;doc = xmlNewDoc((const xmlChar*)"1.0");
2290   }
2291   if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
2292   {
2293     request = g_strdup_printf(
2294       xmpp_connection_initial_request,
2295       priv-&gt;remote_hostname
2296     );
2297     inf_xmpp_connection_send_chars(xmpp, request, strlen(request));
2298     g_free(request);
2299     switch(priv-&gt;status)
2300     {
2301     case INF_XMPP_CONNECTION_CONNECTED:
2302       priv-&gt;status = INF_XMPP_CONNECTION_INITIATED;
2303       break;
2304     case INF_XMPP_CONNECTION_AUTH_CONNECTED:
2305       priv-&gt;status = INF_XMPP_CONNECTION_AUTH_INITIATED;
2306       break;
2307     default:
2308       g_assert_not_reached();
2309       break;
2310     }
2311   }
2312 }
2313 static void
2314 inf_xmpp_connection_received_cb_sent_func(InfXmppConnection* xmpp,
2315                                           gpointer user_data)
2316 {
2317   InfXmppConnectionPrivate* priv;
2318   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2319   inf_tcp_connection_close(priv-&gt;tcp);
2320 }
2321 static void
2322 inf_xmpp_connection_sent_cb(InfTcpConnection* tcp,
2323                             gconstpointer data,
2324                             guint len,
2325                             gpointer user_data)
2326 {
2327   InfXmppConnection* xmpp;
2328   InfXmppConnectionPrivate* priv;
2329   InfXmppConnectionMessage* message;
2330   gboolean have_sent;
2331   xmpp = INF_XMPP_CONNECTION(user_data);
2332   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2333   g_assert(priv-&gt;position &gt;= len);
2334   g_object_ref(G_OBJECT(xmpp));
2335   priv-&gt;position -= len;
2336   if(priv-&gt;messages != NULL)
2337   {
2338     have_sent = priv-&gt;messages-&gt;sent;
2339     for(message = priv-&gt;messages; message != NULL; message = message-&gt;next)
2340     {
2341       if(!message-&gt;sent)
2342       {
2343         if(message-&gt;position &lt;= len)
2344           message-&gt;sent = TRUE;
2345         else
2346           message-&gt;position -= len;
2347       }
2348     }
2349     if(have_sent == FALSE)
2350     {
2351       while(priv-&gt;messages != NULL &amp;&amp; priv-&gt;messages-&gt;sent)
2352       {
2353         if(priv-&gt;messages-&gt;sent_func != NULL)
2354           priv-&gt;messages-&gt;sent_func(xmpp, priv-&gt;messages-&gt;user_data);
2355         if(priv-&gt;messages != NULL)
2356           inf_xmpp_connection_pop_message(xmpp);
2357       }
2358     }
2359   }
2360   g_object_unref(G_OBJECT(xmpp));
2361 }
2362 static void
2363 inf_xmpp_connection_received_cb(InfTcpConnection* tcp,
2364                                 gconstpointer data,
2365                                 guint len,
2366                                 gpointer user_data)
2367 {
2368   InfXmppConnection* xmpp;
2369   InfXmppConnectionPrivate* priv;
2370   gchar buffer[2048];
2371   ssize_t res;
2372   GError* error;
2373   gboolean receiving;
2374   xmpp = INF_XMPP_CONNECTION(user_data);
2375   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2376   if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS)
2377     return;
2378   g_object_ref(xmpp);
2379   g_assert(priv-&gt;parsing == 0);
2380   g_assert(priv-&gt;parser != NULL);
2381   ++priv-&gt;parsing;
2382   if(priv-&gt;session != NULL)
2383   {
2384     g_assert(priv-&gt;pull_len == 0);
2385     priv-&gt;pull_data = data;
2386     priv-&gt;pull_len = len;
2387   }
2388   if(priv-&gt;status == INF_XMPP_CONNECTION_HANDSHAKING)
2389   {
2390     g_assert(priv-&gt;session != NULL);
2391     inf_xmpp_connection_tls_handshake(xmpp);
2392   }
2393   if(priv-&gt;status != INF_XMPP_CONNECTION_HANDSHAKING &amp;&amp;
2394      priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_GNUTLS)
2395   {
2396     if(priv-&gt;session != NULL)
2397     {
2398       receiving = TRUE;
2399       while(receiving &amp;&amp; (priv-&gt;pull_len &gt; 0 ||
2400                           gnutls_record_check_pending(priv-&gt;session) &gt; 0))
2401       {
2402         res = gnutls_record_recv(priv-&gt;session, buffer, 2048);
2403         if(res &lt; 0)
2404         {
2405           if(res != GNUTLS_E_INTERRUPTED &amp;&amp; res != GNUTLS_E_AGAIN)
2406           {
2407             error = NULL;
2408             inf_gnutls_set_error(&amp;error, res);
2409             inf_xml_connection_error(INF_XML_CONNECTION(xmpp), error);
2410             g_error_free(error);
2411             inf_tcp_connection_close(priv-&gt;tcp);
2412             receiving = FALSE;
2413           }
2414         }
2415         else if(res == 0)
2416         {
2417           inf_tcp_connection_close(priv-&gt;tcp);
2418           receiving = FALSE;
2419         }
2420         else
2421         {
2422           if(INF_XMPP_CONNECTION_PRINT_TRAFFIC)
2423             printf("\033[00;32m%.*s\033[00;00m\n", (int)res, buffer);
2424           xmlParseChunk(priv-&gt;parser, buffer, res, 0);
2425           if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS ||
2426              priv-&gt;status == INF_XMPP_CONNECTION_CLOSED)
2427           {
2428             receiving = FALSE;
2429           }
2430         }
2431       }
2432     }
2433     else
2434     {
2435       if(INF_XMPP_CONNECTION_PRINT_TRAFFIC)
2436         printf("\033[00;31m%.*s\033[00;00m\n", (int)len, (const char*)data);
2437       xmlParseChunk(priv-&gt;parser, data, len, 0);
2438     }
2439   }
2440   g_assert(priv-&gt;parsing &gt; 0);
2441   if(--priv-&gt;parsing == 0)
2442   {
2443     if(priv-&gt;status == INF_XMPP_CONNECTION_CLOSING_GNUTLS ||
2444        priv-&gt;status == INF_XMPP_CONNECTION_CLOSED)
2445     {
2446       inf_xmpp_connection_clear(xmpp);
2447       if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED)
2448       {
2449         inf_xmpp_connection_push_message(
2450           xmpp,
2451           inf_xmpp_connection_received_cb_sent_func,
2452           NULL,
2453           NULL
2454         );
2455       }
2456       g_object_notify(G_OBJECT(xmpp), "status");
2457     }
2458     else if(priv-&gt;status == INF_XMPP_CONNECTION_AUTH_CONNECTED)
2459     {
2460       inf_xmpp_connection_initiate(xmpp);
2461     }
2462   }
2463   g_object_unref(xmpp);
2464 }
2465 static void
2466 inf_xmpp_connection_error_cb(InfTcpConnection* tcp,
2467                              GError* error,
2468                              gpointer user_data)
2469 {
2470   inf_xml_connection_error(INF_XML_CONNECTION(user_data), error);
2471 }
2472 static void
2473 inf_xmpp_connection_notify_status_cb(InfTcpConnection* tcp,
2474                                      GParamSpec* pspec,
2475                                      gpointer user_data)
2476 {
2477   InfXmppConnection* xmpp;
2478   InfXmppConnectionPrivate* priv;
2479   InfTcpConnectionStatus tcp_status;
2480   xmpp = INF_XMPP_CONNECTION(user_data);
2481   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2482   g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
2483   switch(tcp_status)
2484   {
2485   case INF_TCP_CONNECTION_CLOSED:
2486     if(priv-&gt;status != INF_XMPP_CONNECTION_CLOSED)
2487     {
2488       if(priv-&gt;parsing == 0)
2489         inf_xmpp_connection_clear(xmpp);
2490       priv-&gt;status = INF_XMPP_CONNECTION_CLOSED;
2491       priv-&gt;position = 0;
2492       if(priv-&gt;parsing == 0)
2493         g_object_notify(G_OBJECT(xmpp), "status");
2494     }
2495     else
2496     {
2497       g_assert(priv-&gt;session == NULL);
2498       g_assert(priv-&gt;messages == NULL);
2499       g_assert(priv-&gt;parser == NULL);
2500       g_assert(priv-&gt;doc == NULL);
2501       g_assert(priv-&gt;position == 0);
2502       g_assert(priv-&gt;sasl_session == NULL);
2503     }
2504     break;
2505   case INF_TCP_CONNECTION_CONNECTING:
2506     g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
2507     if(priv-&gt;status != INF_XMPP_CONNECTION_CONNECTING)
2508     {
2509       priv-&gt;status = INF_XMPP_CONNECTION_CONNECTING;
2510       g_object_notify(G_OBJECT(xmpp), "status");
2511     }
2512     break;
2513   case INF_TCP_CONNECTION_CONNECTED:
2514     if(priv-&gt;own_cert != NULL)
2515     {
2516       gnutls_x509_crt_deinit(priv-&gt;own_cert);
2517       priv-&gt;own_cert = NULL;
2518       g_object_notify(G_OBJECT(xmpp), "local-certificate");
2519     }
2520     if(priv-&gt;peer_cert != NULL)
2521     {
2522       inf_certificate_chain_unref(priv-&gt;peer_cert);
2523       priv-&gt;peer_cert = NULL;
2524       g_object_notify(G_OBJECT(xmpp), "remote-certificate");
2525     }
2526     g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTING);
2527     priv-&gt;status = INF_XMPP_CONNECTION_CONNECTED;
2528     inf_xmpp_connection_initiate(xmpp);
2529     break;
2530   default:
2531     g_assert_not_reached();
2532     break;
2533   }
2534 }
2535 static void
2536 inf_xmpp_connection_set_tcp(InfXmppConnection* xmpp,
2537                             InfTcpConnection* tcp)
2538 {
2539   InfXmppConnectionPrivate* priv;
2540   InfTcpConnectionStatus tcp_status;
2541   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2542   g_object_freeze_notify(G_OBJECT(xmpp));
2543   if(priv-&gt;tcp != NULL)
2544   {
2545     g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;tcp_status, NULL);
2546     if(tcp_status != INF_TCP_CONNECTION_CLOSED)
2547       inf_tcp_connection_close(priv-&gt;tcp);
2548     g_assert(priv-&gt;sasl_session == NULL);
2549     inf_signal_handlers_disconnect_by_func(
2550       G_OBJECT(priv-&gt;tcp),
2551       G_CALLBACK(inf_xmpp_connection_sent_cb),
2552       xmpp
2553     );
2554     inf_signal_handlers_disconnect_by_func(
2555       G_OBJECT(priv-&gt;tcp),
2556       G_CALLBACK(inf_xmpp_connection_received_cb),
2557       xmpp
2558     );
2559     inf_signal_handlers_disconnect_by_func(
2560       G_OBJECT(priv-&gt;tcp),
2561       G_CALLBACK(inf_xmpp_connection_error_cb),
2562       xmpp
2563     );
2564     inf_signal_handlers_disconnect_by_func(
2565       G_OBJECT(priv-&gt;tcp),
2566       G_CALLBACK(inf_xmpp_connection_notify_status_cb),
2567       xmpp
2568     );
2569     g_object_unref(G_OBJECT(priv-&gt;tcp));
2570   }
2571   priv-&gt;tcp = tcp;
2572   if(tcp != NULL)
2573   {
2574     g_object_ref(G_OBJECT(tcp));
2575     g_signal_connect(
2576       G_OBJECT(tcp),
2577       "sent",
2578       G_CALLBACK(inf_xmpp_connection_sent_cb),
2579       xmpp
2580     );
2581     g_signal_connect(
2582       G_OBJECT(tcp),
2583       "received",
2584       G_CALLBACK(inf_xmpp_connection_received_cb),
2585       xmpp
2586     );
2587     g_signal_connect(
2588       G_OBJECT(tcp),
2589       "error",
2590       G_CALLBACK(inf_xmpp_connection_error_cb),
2591       xmpp
2592     );
2593     g_signal_connect(
2594       G_OBJECT(tcp),
2595       "notify::status",
2596       G_CALLBACK(inf_xmpp_connection_notify_status_cb),
2597       xmpp
2598     );
2599     g_object_get(G_OBJECT(tcp), "status", &amp;tcp_status, NULL);
2600     switch(tcp_status)
2601     {
2602     case INF_TCP_CONNECTION_CLOSED:
2603       g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
2604       break;
2605     case INF_TCP_CONNECTION_CONNECTING:
2606       priv-&gt;status = INF_XMPP_CONNECTION_CONNECTING;
2607       g_object_notify(G_OBJECT(xmpp), "status");
2608       break;
2609     case INF_TCP_CONNECTION_CONNECTED:
2610       priv-&gt;status = INF_XMPP_CONNECTION_CONNECTED;
2611       g_object_notify(G_OBJECT(xmpp), "status");
2612       break;
2613     default:
2614       g_assert_not_reached();
2615       break;
2616     }
2617   }
2618   g_object_thaw_notify(G_OBJECT(xmpp));
2619 }
2620 static InfXmlConnectionStatus
2621 inf_xmpp_connection_get_xml_status(InfXmppConnection* xmpp)
2622 {
2623   InfXmppConnectionPrivate* priv;
2624   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2625   switch(priv-&gt;status)
2626   {
2627   case INF_XMPP_CONNECTION_CONNECTING:
2628   case INF_XMPP_CONNECTION_CONNECTED:
2629   case INF_XMPP_CONNECTION_AUTH_CONNECTED:
2630   case INF_XMPP_CONNECTION_INITIATED:
2631   case INF_XMPP_CONNECTION_AUTH_INITIATED:
2632   case INF_XMPP_CONNECTION_AWAITING_FEATURES:
2633   case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
2634   case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
2635   case INF_XMPP_CONNECTION_HANDSHAKING:
2636   case INF_XMPP_CONNECTION_AUTHENTICATING:
2637     return INF_XML_CONNECTION_OPENING;
2638   case INF_XMPP_CONNECTION_READY:
2639     return INF_XML_CONNECTION_OPEN;
2640   case INF_XMPP_CONNECTION_CLOSING_STREAM:
2641   case INF_XMPP_CONNECTION_CLOSING_GNUTLS:
2642     return INF_XML_CONNECTION_CLOSING;
2643   case INF_XMPP_CONNECTION_CLOSED:
2644     return INF_XML_CONNECTION_CLOSED;
2645   default:
2646     g_assert_not_reached();
2647     return INF_XML_CONNECTION_CLOSED;
2648   }
2649 }
2650 static gchar*
2651 inf_xmpp_connection_get_address_id(InfIpAddress* addr,
2652                                    guint port)
2653 {
2654   gchar* addr_str;
2655   gchar* addr_id;
2656   addr_str = inf_ip_address_to_string(addr);
2657   switch(inf_ip_address_get_family(addr))
2658   {
2659   case INF_IP_ADDRESS_IPV4:
2660     addr_id = g_strdup_printf("%s:%u", addr_str, port);
2661     break;
2662   case INF_IP_ADDRESS_IPV6:
2663     addr_id = g_strdup_printf("[%s]:%u", addr_str, port);
2664     break;
2665   default:
2666     g_assert_not_reached();
2667     break;
2668   }
2669   g_free(addr_str);
2670   return addr_id;
2671 }
2672 static void
2673 inf_xmpp_connection_init(InfXmppConnection* connection)
2674 {
2675   InfXmppConnectionPrivate* priv;
2676   priv = INF_XMPP_CONNECTION_PRIVATE(connection);
2677   priv-&gt;tcp = NULL;
2678   priv-&gt;site = INF_XMPP_CONNECTION_CLIENT;
2679   priv-&gt;status = INF_XMPP_CONNECTION_CLOSED;
2680   priv-&gt;local_hostname = NULL;
2681   priv-&gt;remote_hostname = NULL;
2682   priv-&gt;security_policy = INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS;
2683   priv-&gt;certificate_request = GNUTLS_CERT_IGNORE;
2684   priv-&gt;certificate_callback = NULL;
2685   priv-&gt;certificate_callback_user_data = NULL;
2686   priv-&gt;certificate_callback_notify = NULL;
2687   priv-&gt;position = 0;
2688   priv-&gt;messages = NULL;
2689   priv-&gt;last_message = NULL;
2690   priv-&gt;parsing = 0;
2691   priv-&gt;parser = NULL;
2692   priv-&gt;root = NULL;
2693   priv-&gt;cur = NULL;
2694   priv-&gt;doc = NULL;
2695   priv-&gt;buf = NULL;
2696   priv-&gt;session = NULL;
2697   priv-&gt;creds = NULL;
2698   priv-&gt;own_cert = NULL;
2699   priv-&gt;peer_cert = NULL;
2700   priv-&gt;pull_data = NULL;
2701   priv-&gt;pull_len = 0;
2702   priv-&gt;sasl_context = NULL;
2703   priv-&gt;sasl_own_context = NULL;
2704   priv-&gt;sasl_session = NULL;
2705   priv-&gt;sasl_local_mechanisms = NULL;
2706   priv-&gt;sasl_remote_mechanisms = NULL;
2707   priv-&gt;sasl_error = NULL;
2708 }
2709 static void
2710 inf_xmpp_connection_constructed(GObject* object)
2711 {
2712   InfXmppConnectionPrivate* priv;
2713   InfTcpConnectionStatus status;
2714   G_OBJECT_CLASS(inf_xmpp_connection_parent_class)-&gt;constructed(object);
2715   priv = INF_XMPP_CONNECTION_PRIVATE(object);
2716   g_assert(priv-&gt;tcp != NULL);
2717   if(priv-&gt;local_hostname == NULL)
2718     priv-&gt;local_hostname = g_strdup(g_get_host_name());
2719   g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;status, NULL);
2720   if(status == INF_TCP_CONNECTION_CONNECTED)
2721     inf_xmpp_connection_initiate(INF_XMPP_CONNECTION(object));
2722   g_assert(
2723     priv-&gt;security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
2724     priv-&gt;site == INF_XMPP_CONNECTION_CLIENT ||
2725     priv-&gt;creds != NULL
2726   );
2727 }
2728 static void
2729 inf_xmpp_connection_dispose(GObject* object)
2730 {
2731   InfXmppConnection* xmpp;
2732   InfXmppConnectionPrivate* priv;
2733   xmpp = INF_XMPP_CONNECTION(object);
2734   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2735   inf_xmpp_connection_set_tcp(xmpp, NULL);
2736   g_assert(priv-&gt;session == NULL);
2737   g_assert(priv-&gt;sasl_session == NULL);
2738   if(priv-&gt;own_cert != NULL)
2739   {
2740     gnutls_x509_crt_deinit(priv-&gt;own_cert);
2741     priv-&gt;own_cert = NULL;
2742     g_object_notify(G_OBJECT(xmpp), "local-certificate");
2743   }
2744   if(priv-&gt;peer_cert != NULL)
2745   {
2746     inf_certificate_chain_unref(priv-&gt;peer_cert);
2747     priv-&gt;peer_cert = NULL;
2748     g_object_notify(G_OBJECT(xmpp), "remote-certificate");
2749   }
2750   if(priv-&gt;sasl_own_context != NULL)
2751   {
2752     inf_sasl_context_unref(priv-&gt;sasl_own_context);
2753     priv-&gt;sasl_own_context = NULL;
2754   }
2755   if(priv-&gt;sasl_context != NULL)
2756   {
2757     inf_sasl_context_unref(priv-&gt;sasl_context);
2758     priv-&gt;sasl_context = NULL;
2759   }
2760   if(priv-&gt;creds != NULL)
2761   {
2762     inf_certificate_credentials_unref(priv-&gt;creds);
2763     priv-&gt;creds = NULL;
2764   }
2765   G_OBJECT_CLASS(inf_xmpp_connection_parent_class)-&gt;dispose(object);
2766 }
2767 static void
2768 inf_xmpp_connection_finalize(GObject* object)
2769 {
2770   InfXmppConnection* xmpp;
2771   InfXmppConnectionPrivate* priv;
2772   xmpp = INF_XMPP_CONNECTION(object);
2773   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2774   g_free(priv-&gt;local_hostname);
2775   g_free(priv-&gt;remote_hostname);
2776   g_free(priv-&gt;sasl_local_mechanisms);
2777   g_free(priv-&gt;sasl_remote_mechanisms);
2778   if(priv-&gt;certificate_callback_notify != NULL)
2779     priv-&gt;certificate_callback_notify(priv-&gt;certificate_callback_user_data);
2780   if(priv-&gt;sasl_error)
2781     g_error_free(priv-&gt;sasl_error);
2782   G_OBJECT_CLASS(inf_xmpp_connection_parent_class)-&gt;finalize(object);
2783 }
2784 static void
2785 inf_xmpp_connection_set_property(GObject* object,
2786                                  guint prop_id,
2787                                  const GValue* value,
2788                                  GParamSpec* pspec)
2789 {
2790   InfXmppConnection* xmpp;
2791   InfXmppConnectionPrivate* priv;
2792   xmpp = INF_XMPP_CONNECTION(object);
2793   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2794   switch(prop_id)
2795   {
2796   case PROP_TCP:
2797     inf_xmpp_connection_set_tcp(
2798       xmpp,
2799       INF_TCP_CONNECTION(g_value_get_object(value))
2800     );
2801     break;
2802   case PROP_SITE:
2803     g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTING ||
2804              priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
2805              priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
2806     priv-&gt;site = g_value_get_enum(value);
2807     break;
2808   case PROP_LOCAL_HOSTNAME:
2809     g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTING ||
2810              priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
2811              priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
2812     g_free(priv-&gt;local_hostname);
2813     priv-&gt;local_hostname = g_value_dup_string(value);
2814     if(priv-&gt;local_hostname == NULL)
2815       priv-&gt;local_hostname = g_strdup(g_get_host_name());
2816     break;
2817   case PROP_REMOTE_HOSTNAME:
2818     g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTING ||
2819              priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED ||
2820              priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
2821     g_free(priv-&gt;remote_hostname);
2822     priv-&gt;remote_hostname = g_value_dup_string(value);
2823     break;
2824   case PROP_SECURITY_POLICY:
2825     priv-&gt;security_policy = g_value_get_enum(value);
2826     break;
2827   case PROP_CREDENTIALS:
2828     g_assert(priv-&gt;session == NULL);
2829     if(priv-&gt;creds != NULL) inf_certificate_credentials_unref(priv-&gt;creds);
2830     priv-&gt;creds = g_value_dup_boxed(value);
2831     break;
2832   case PROP_SASL_CONTEXT:
2833     g_assert(priv-&gt;sasl_session == NULL);
2834     if(priv-&gt;sasl_own_context != NULL)
2835     {
2836       inf_sasl_context_unref(priv-&gt;sasl_own_context);
2837       priv-&gt;sasl_own_context = NULL;
2838     }
2839     if(priv-&gt;sasl_context != NULL)
2840       inf_sasl_context_unref(priv-&gt;sasl_context);
2841     priv-&gt;sasl_context = g_value_dup_boxed(value);
2842     break;
2843   case PROP_SASL_MECHANISMS:
2844     g_assert(priv-&gt;sasl_session == NULL);
2845 <a name="0"></a>
2846     g_free(priv-&gt;sasl_local_mechanisms);
2847     priv-&gt;sasl_local_mechanisms = g_value_dup_string(value);
2848 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
2849   default:
2850     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
2851     break;
2852   }
2853 }
2854 static void
2855 inf_xmpp_connection_get_property(GObject* object,
2856                                  guint prop_id,
2857                                  GValue* value,
2858                                  GParamSpec* pspec)
2859 {
2860   InfXmppConnection* xmpp;
2861   InfXmppConnectionPrivate* priv;
2862   InfIpAddress* addr;
2863   guint port;
2864   gchar* id;
2865   xmpp = INF_XMPP_CONNECTION(object);
2866   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
2867   switch(prop_id)
2868   {
2869   case PROP_TCP:
2870     g_value_set_object(value, G_OBJECT(priv-&gt;tcp));
2871     break;</b></font>
2872   case PROP_SITE:
2873     g_value_set_enum(value, priv-&gt;site);
2874     break;
2875   case PROP_LOCAL_HOSTNAME:
2876     g_value_set_string(value, priv-&gt;local_hostname);
2877     break;
2878   case PROP_REMOTE_HOSTNAME:
2879     g_value_set_string(value, priv-&gt;remote_hostname);
2880     break;
2881   case PROP_SECURITY_POLICY:
2882     g_value_set_enum(value, priv-&gt;security_policy);
2883     break;
2884   case PROP_TLS_ENABLED:
2885     g_value_set_boolean(value, inf_xmpp_connection_get_tls_enabled(xmpp));
2886     break;
2887   case PROP_CREDENTIALS:
2888     g_value_set_boxed(value, priv-&gt;creds);
2889     break;
2890   case PROP_SASL_CONTEXT:
2891     g_value_set_boxed(value, priv-&gt;sasl_context);
2892     break;
2893   case PROP_SASL_MECHANISMS:
2894     g_value_set_string(value, priv-&gt;sasl_local_mechanisms);
2895     break;
2896   case PROP_STATUS:
2897     g_value_set_enum(value, inf_xmpp_connection_get_xml_status(xmpp));
2898     break;
2899   case PROP_NETWORK:
2900     g_value_set_static_string(value, "tcp/ip");
2901     break;
2902   case PROP_LOCAL_ID:
2903     g_object_get(
2904       G_OBJECT(priv-&gt;tcp),
2905       "local-address", &amp;addr,
2906       "local-port", &amp;port,
2907       NULL
2908     );
2909     id = inf_xmpp_connection_get_address_id(addr, port);
2910     inf_ip_address_free(addr);
2911     g_value_take_string(value, id);
2912     break;
2913   case PROP_REMOTE_ID:
2914     addr = inf_tcp_connection_get_remote_address(priv-&gt;tcp);
2915     port = inf_tcp_connection_get_remote_port(priv-&gt;tcp);
2916     id = inf_xmpp_connection_get_address_id(addr, port);
2917     g_value_take_string(value, id);
2918     break;
2919   case PROP_LOCAL_CERTIFICATE:
2920     g_value_set_pointer(value, priv-&gt;own_cert);
2921     break;
2922   case PROP_REMOTE_CERTIFICATE:
2923     g_value_set_boxed(value, priv-&gt;peer_cert);
2924     break;
2925   default:
2926     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
2927     break;
2928   }
2929 }
2930 static void
2931 inf_xmpp_connection_xml_connection_send_sent(InfXmppConnection* xmpp,
2932                                              gpointer xml)
2933 {
2934   inf_xml_connection_sent(INF_XML_CONNECTION(xmpp), (xmlNodePtr)xml);
2935 }
2936 static void
2937 inf_xmpp_connection_xml_connection_send_free(InfXmppConnection* xmpp,
2938                                              gpointer xml)
2939 {
2940   xmlFreeNode((xmlNodePtr)xml);
2941 }
2942 static gboolean
2943 inf_xmpp_connection_xml_connection_open(InfXmlConnection* connection,
2944                                         GError** error)
2945 {
2946   InfXmppConnectionPrivate* priv;
2947   InfTcpConnectionStatus status;
2948   priv = INF_XMPP_CONNECTION_PRIVATE(connection);
2949   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_CLOSED);
2950   g_assert(priv-&gt;tcp != NULL);
2951   g_object_get(G_OBJECT(priv-&gt;tcp), "status", &amp;status, NULL);
2952   g_assert(status == INF_TCP_CONNECTION_CLOSED);
2953   return inf_tcp_connection_open(priv-&gt;tcp, error);
2954 }
2955 static void
2956 inf_xmpp_connection_xml_connection_close(InfXmlConnection* connection)
2957 {
2958   InfXmppConnectionPrivate* priv;
2959   priv = INF_XMPP_CONNECTION_PRIVATE(connection);
2960   g_assert(priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_STREAM &amp;&amp;
2961            priv-&gt;status != INF_XMPP_CONNECTION_CLOSING_GNUTLS &amp;&amp;
2962            priv-&gt;status != INF_XMPP_CONNECTION_CLOSED);
2963   switch(priv-&gt;status)
2964   {
2965   case INF_XMPP_CONNECTION_CONNECTING:
2966     inf_tcp_connection_close(priv-&gt;tcp);
2967     break;
2968   case INF_XMPP_CONNECTION_CONNECTED:
2969   case INF_XMPP_CONNECTION_AUTH_CONNECTED:
2970     g_assert(priv-&gt;parsing == 0);
2971     inf_xmpp_connection_terminate(INF_XMPP_CONNECTION(connection));
2972     break;
2973   case INF_XMPP_CONNECTION_HANDSHAKING:
2974   case INF_XMPP_CONNECTION_ENCRYPTION_REQUESTED:
2975     g_assert(priv-&gt;session != NULL);
2976     gnutls_deinit(priv-&gt;session);
2977     priv-&gt;session = NULL;
2978     inf_tcp_connection_close(priv-&gt;tcp);
2979     break;
2980   case INF_XMPP_CONNECTION_AUTHENTICATING:
2981     g_assert(priv-&gt;parsing == 0);
2982     inf_xmpp_connection_terminate(INF_XMPP_CONNECTION(connection));
2983     break;
2984   case INF_XMPP_CONNECTION_INITIATED:
2985   case INF_XMPP_CONNECTION_AUTH_INITIATED:
2986   case INF_XMPP_CONNECTION_AWAITING_FEATURES:
2987   case INF_XMPP_CONNECTION_AUTH_AWAITING_FEATURES:
2988   case INF_XMPP_CONNECTION_READY:
2989     inf_xmpp_connection_deinitiate(INF_XMPP_CONNECTION(connection));
2990     break;
2991   default:
2992     g_assert_not_reached();
2993     break;
2994   }
2995 }
2996 static void
2997 inf_xmpp_connection_xml_connection_send(InfXmlConnection* connection,
2998                                         xmlNodePtr xml)
2999 {
3000   InfXmppConnectionPrivate* priv;
3001   priv = INF_XMPP_CONNECTION_PRIVATE(connection);
3002   g_assert(priv-&gt;status == INF_XMPP_CONNECTION_READY);
3003   inf_xmpp_connection_send_xml(INF_XMPP_CONNECTION(connection), xml);
3004   if(priv-&gt;status == INF_XMPP_CONNECTION_READY)
3005   {
3006     inf_xmpp_connection_push_message(
3007       INF_XMPP_CONNECTION(connection),
3008       inf_xmpp_connection_xml_connection_send_sent,
3009       inf_xmpp_connection_xml_connection_send_free,
3010       xml
3011     );
3012   }
3013   else
3014   {
3015     xmlFreeNode(xml);
3016   }
3017 }
3018 static void
3019 inf_xmpp_connection_class_init(InfXmppConnectionClass* xmpp_class)
3020 {
3021   GObjectClass* object_class;
3022   object_class = G_OBJECT_CLASS(xmpp_class);
3023   object_class-&gt;constructed = inf_xmpp_connection_constructed;
3024   object_class-&gt;dispose = inf_xmpp_connection_dispose;
3025   object_class-&gt;finalize = inf_xmpp_connection_finalize;
3026   object_class-&gt;set_property = inf_xmpp_connection_set_property;
3027   object_class-&gt;get_property = inf_xmpp_connection_get_property;
3028   inf_xmpp_connection_stream_error_quark = g_quark_from_static_string(
3029     "INF_XMPP_CONNECTION_STREAM_ERROR"
3030   );
3031   inf_xmpp_connection_auth_error_quark = g_quark_from_static_string(
3032     "INF_XMPP_CONNECTION_AUTH_ERROR"
3033   );
3034   g_object_class_install_property(
3035     object_class,
3036     PROP_TCP,
3037     g_param_spec_object(
3038       "tcp-connection",
3039       "TCP connection",
3040       "Underlaying TCP connection",
3041       INF_TYPE_TCP_CONNECTION,
3042       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
3043     )
3044   );
3045   g_object_class_install_property(
3046     object_class,
3047     PROP_SITE,
3048     g_param_spec_enum(
3049       "site",
3050       "Site",
3051       "Site of the connection (client or server)",
3052       INF_TYPE_XMPP_CONNECTION_SITE,
3053       INF_XMPP_CONNECTION_CLIENT,
3054       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
3055     )
3056   );
3057   g_object_class_install_property(
3058     object_class,
3059     PROP_LOCAL_HOSTNAME,
3060     g_param_spec_string(
3061       "local-hostname",
3062       "Local hostname",
3063       "The hostname of the local host",
3064       NULL,
3065       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
3066     )
3067   );
3068   g_object_class_install_property(
3069     object_class,
3070     PROP_REMOTE_HOSTNAME,
3071     g_param_spec_string(
3072       "remote-hostname",
3073       "Remote hostname",
3074       "The hostname of the remote host",
3075       NULL,
3076       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
3077     )
3078   );
3079   g_object_class_install_property(
3080     object_class,
3081     PROP_SECURITY_POLICY,
3082     g_param_spec_enum(
3083       "security-policy",
3084       "Security policy",
3085       "How to choose whether to use (or offer, as a server) TLS",
3086       INF_TYPE_XMPP_CONNECTION_SECURITY_POLICY,
3087       INF_XMPP_CONNECTION_SECURITY_BOTH_PREFER_TLS,
3088       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
3089     )
3090   );
3091   g_object_class_install_property(
3092     object_class,
3093     PROP_TLS_ENABLED,
3094     g_param_spec_boolean(
3095       "tls-enabled",
3096       "TLS enabled",
3097       "Whether TLS is enabled for the connection or not",
3098       FALSE,
3099       G_PARAM_READABLE
3100     )
3101   );
3102   g_object_class_install_property(
3103     object_class,
3104     PROP_CREDENTIALS,
3105     g_param_spec_boxed(
3106       "credentials",
3107       "Credentials",
3108       "The certificate credentials for GnuTLS",
3109       INF_TYPE_CERTIFICATE_CREDENTIALS,
3110       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
3111     )
3112   );
3113   g_object_class_install_property(
3114     object_class,
3115     PROP_SASL_CONTEXT,
3116     g_param_spec_boxed(
3117       "sasl-context",
3118       "SASL context",
3119       "The SASL context used for authentication",
3120       INF_TYPE_SASL_CONTEXT,
3121       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
3122     )
3123   );
3124   g_object_class_install_property(
3125     object_class,
3126     PROP_SASL_MECHANISMS,
3127     g_param_spec_string(
3128       "sasl-mechanisms",
3129       "SASL Mechanisms",
3130       "Whitespace separated list of SASL mechanisms to accept/offer",
3131       NULL,
3132       G_PARAM_READWRITE | G_PARAM_CONSTRUCT
3133     )
3134   );
3135   g_object_class_override_property(object_class, PROP_STATUS, "status");
3136   g_object_class_override_property(object_class, PROP_NETWORK, "network");
3137   g_object_class_override_property(object_class, PROP_LOCAL_ID, "local-id");
3138   g_object_class_override_property(object_class, PROP_REMOTE_ID, "remote-id");
3139   g_object_class_override_property(
3140     object_class,
3141     PROP_LOCAL_CERTIFICATE,
3142     "local-certificate"
3143   );
3144   g_object_class_override_property(
3145     object_class,
3146     PROP_REMOTE_CERTIFICATE,
3147     "remote-certificate"
3148   );
3149 }
3150 static void
3151 inf_xmpp_connection_xml_connection_iface_init(
3152   InfXmlConnectionInterface* iface)
3153 {
3154   iface-&gt;open = inf_xmpp_connection_xml_connection_open;
3155   iface-&gt;close = inf_xmpp_connection_xml_connection_close;
3156   iface-&gt;send = inf_xmpp_connection_xml_connection_send;
3157 }
3158 InfXmppConnection*
3159 inf_xmpp_connection_new(InfTcpConnection* tcp,
3160                         InfXmppConnectionSite site,
3161                         const gchar* local_hostname,
3162                         const gchar* remote_hostname,
3163                         InfXmppConnectionSecurityPolicy security_policy,
3164                         InfCertificateCredentials* creds,
3165                         InfSaslContext* sasl_context,
3166                         const gchar* sasl_mechanisms)
3167 {
3168   GObject* object;
3169   g_return_val_if_fail(INF_IS_TCP_CONNECTION(tcp), NULL);
3170   g_return_val_if_fail(
3171     security_policy == INF_XMPP_CONNECTION_SECURITY_ONLY_UNSECURED ||
3172     site == INF_XMPP_CONNECTION_CLIENT || creds != NULL,
3173     NULL
3174   );
3175   object = g_object_new(
3176     INF_TYPE_XMPP_CONNECTION,
3177     "tcp-connection", tcp,
3178     "site", site,
3179     "local-hostname", local_hostname,
3180     "remote-hostname", remote_hostname,
3181     "security-policy", security_policy,
3182     "credentials", creds,
3183     "sasl-context", sasl_context,
3184     "sasl-mechanisms", sasl_mechanisms,
3185     NULL
3186   );
3187   return INF_XMPP_CONNECTION(object);
3188 }
3189 gboolean
3190 inf_xmpp_connection_get_tls_enabled(InfXmppConnection* xmpp)
3191 {
3192   InfXmppConnectionPrivate* priv;
3193   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), FALSE);
3194   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3195   if(priv-&gt;status == INF_XMPP_CONNECTION_HANDSHAKING) return FALSE;
3196   if(priv-&gt;session == NULL) return FALSE;
3197   return TRUE;
3198 }
3199 gnutls_x509_crt_t
3200 inf_xmpp_connection_get_own_certificate(InfXmppConnection* xmpp)
3201 {
3202   InfXmppConnectionPrivate* priv;
3203   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), NULL);
3204   g_return_val_if_fail(inf_xmpp_connection_get_tls_enabled(xmpp), NULL);
3205   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3206   return priv-&gt;own_cert;
3207 }
3208 InfCertificateChain*
3209 inf_xmpp_connection_get_peer_certificate(InfXmppConnection* xmpp)
3210 {
3211   InfXmppConnectionPrivate* priv;
3212   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), NULL);
3213   g_return_val_if_fail(inf_xmpp_connection_get_tls_enabled(xmpp), NULL);
3214   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3215   return priv-&gt;peer_cert;
3216 }
3217 gnutls_kx_algorithm_t
3218 inf_xmpp_connection_get_kx_algorithm(InfXmppConnection* xmpp)
3219 {
3220   InfXmppConnectionPrivate* priv;
3221   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), GNUTLS_KX_UNKNOWN);
3222   g_return_val_if_fail(
3223     inf_xmpp_connection_get_tls_enabled(xmpp),
3224     GNUTLS_KX_UNKNOWN
3225   );
3226   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3227   return gnutls_kx_get(priv-&gt;session);
3228 }
3229 gnutls_cipher_algorithm_t
3230 inf_xmpp_connection_get_cipher_algorithm(InfXmppConnection* xmpp)
3231 {
3232   InfXmppConnectionPrivate* priv;
3233   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), GNUTLS_CIPHER_UNKNOWN);
3234   g_return_val_if_fail(
3235     inf_xmpp_connection_get_tls_enabled(xmpp),
3236     GNUTLS_CIPHER_UNKNOWN
3237   );
3238   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3239   return gnutls_cipher_get(priv-&gt;session);
3240 }
3241 gnutls_mac_algorithm_t
3242 inf_xmpp_connection_get_mac_algorithm(InfXmppConnection* xmpp)
3243 {
3244   InfXmppConnectionPrivate* priv;
3245   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), GNUTLS_MAC_UNKNOWN);
3246   g_return_val_if_fail(
3247     inf_xmpp_connection_get_tls_enabled(xmpp),
3248     GNUTLS_MAC_UNKNOWN
3249   );
3250   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3251   return gnutls_mac_get(priv-&gt;session);
3252 }
3253 gnutls_protocol_t
3254 inf_xmpp_connection_get_tls_protocol(InfXmppConnection* xmpp)
3255 {
3256   InfXmppConnectionPrivate* priv;
3257   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), GNUTLS_VERSION_UNKNOWN);
3258   g_return_val_if_fail(
3259     inf_xmpp_connection_get_tls_enabled(xmpp),
3260     GNUTLS_VERSION_UNKNOWN
3261   );
3262   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3263   return gnutls_protocol_get_version(priv-&gt;session);
3264 }
3265 guint
3266 inf_xmpp_connection_get_dh_prime_bits(InfXmppConnection* xmpp)
3267 {
3268   InfXmppConnectionPrivate* priv;
3269   int bits;
3270   g_return_val_if_fail(INF_IS_XMPP_CONNECTION(xmpp), 0);
3271   g_return_val_if_fail(inf_xmpp_connection_get_tls_enabled(xmpp), 0);
3272   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3273   bits = gnutls_dh_get_prime_bits(priv-&gt;session);
3274   if(bits &lt; 0) bits = 0;
3275   return (guint)bits;
3276 }
3277 void
3278 inf_xmpp_connection_set_certificate_callback(InfXmppConnection* xmpp,
3279                                              gnutls_certificate_request_t req,
3280                                              InfXmppConnectionCrtCallback cb,
3281                                              gpointer user_data,
3282                                              GDestroyNotify notify)
3283 {
3284   InfXmppConnectionPrivate* priv;
3285   g_return_if_fail(INF_IS_XMPP_CONNECTION(xmpp));
3286   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3287   if(priv-&gt;certificate_callback_notify != NULL)
3288     priv-&gt;certificate_callback_notify(priv-&gt;certificate_callback_user_data);
3289   priv-&gt;certificate_request = req;
3290   priv-&gt;certificate_callback = cb;
3291   priv-&gt;certificate_callback_user_data = user_data;
3292   priv-&gt;certificate_callback_notify = notify;
3293 }
3294 void
3295 inf_xmpp_connection_certificate_verify_continue(InfXmppConnection* xmpp)
3296 {
3297   InfXmppConnectionPrivate* priv;
3298   g_return_if_fail(INF_IS_XMPP_CONNECTION(xmpp));
3299   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3300   g_return_if_fail(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED);
3301   g_return_if_fail(priv-&gt;session != NULL);
3302   inf_xmpp_connection_initiate(xmpp);
3303 }
3304 void
3305 inf_xmpp_connection_certificate_verify_cancel(InfXmppConnection* xmpp,
3306                                               const GError* error)
3307 {
3308   InfXmppConnectionPrivate* priv;
3309   GError* local_error;
3310   g_return_if_fail(INF_IS_XMPP_CONNECTION(xmpp));
3311   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3312   g_return_if_fail(priv-&gt;status == INF_XMPP_CONNECTION_CONNECTED);
3313   g_return_if_fail(priv-&gt;session != NULL);
3314   if(priv-&gt;site == INF_XMPP_CONNECTION_CLIENT)
3315   {
3316     if(error == NULL)
3317     {
3318       local_error = g_error_new_literal(
3319         inf_xmpp_connection_error_quark(),
3320         INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED,
3321         _("The server certificate is not trusted")
3322       );
3323     }
3324     else
3325     {
3326       local_error = g_error_new(
3327         inf_xmpp_connection_error_quark(),
3328         INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED,
3329         _("The server certificate is not trusted: %s"),
3330         error-&gt;message
3331       );
3332     }
3333   }
3334   else
3335   {
3336     if(error == NULL)
3337     {
3338       local_error = g_error_new_literal(
3339         inf_xmpp_connection_error_quark(),
3340         INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED,
3341         _("The client certificate is not trusted")
3342       );
3343     }
3344     else
3345     {
3346       local_error = g_error_new(
3347         inf_xmpp_connection_error_quark(),
3348         INF_XMPP_CONNECTION_ERROR_CERTIFICATE_NOT_TRUSTED,
3349         _("The client certificate is not trusted: %s"),
3350         error-&gt;message
3351       );
3352     }
3353   }
3354   inf_xml_connection_error(INF_XML_CONNECTION(xmpp), local_error);
3355   g_error_free(local_error);
3356   inf_xmpp_connection_terminate(xmpp);
3357 }
3358 void
3359 inf_xmpp_connection_reset_sasl_authentication(InfXmppConnection* xmpp,
3360                                               InfSaslContext* new_context,
3361                                               const gchar* new_mechanisms)
3362 {
3363   InfXmppConnectionPrivate* priv;
3364   xmlNodePtr xml;
3365   g_return_if_fail(INF_IS_XMPP_CONNECTION(xmpp));
3366   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3367   if(priv-&gt;status == INF_XMPP_CONNECTION_AUTHENTICATING)
3368   {
3369     switch(priv-&gt;site)
3370     {
3371     case INF_XMPP_CONNECTION_CLIENT:
3372       if(priv-&gt;sasl_session != NULL)
3373       {
3374         xml = inf_xmpp_connection_node_new_sasl("abort");
3375         inf_xmpp_connection_send_xml(xmpp, xml);
3376         inf_sasl_context_stop_session(priv-&gt;sasl_context, priv-&gt;sasl_session);
3377         priv-&gt;sasl_session = NULL;
3378       }
3379       break;
3380     case INF_XMPP_CONNECTION_SERVER:
3381       if(priv-&gt;sasl_session != NULL)
3382       {
3383         inf_sasl_context_stop_session(priv-&gt;sasl_context, priv-&gt;sasl_session);
3384         priv-&gt;sasl_session = NULL;
3385       }
3386       break;
3387     default:
3388       g_assert_not_reached();
3389       break;
3390     }
3391   }
3392   if(priv-&gt;sasl_own_context != NULL)
3393   {
3394     inf_sasl_context_unref(priv-&gt;sasl_own_context);
3395     priv-&gt;sasl_own_context = NULL;
3396   }
3397   if(priv-&gt;sasl_context != NULL)
3398     inf_sasl_context_unref(priv-&gt;sasl_context);
3399   priv-&gt;sasl_context = new_context;
3400   if(new_context != NULL) inf_sasl_context_ref(new_context);
3401   g_free(priv-&gt;sasl_local_mechanisms);
3402   priv-&gt;sasl_local_mechanisms = g_strdup(new_mechanisms);
3403   g_object_freeze_notify(G_OBJECT(xmpp));   if(new_context == NULL)
3404   {
3405     if(!inf_xmpp_connection_sasl_ensure(xmpp))
3406     {
3407       inf_xmpp_connection_deinitiate(xmpp);
3408     }
3409   }
3410   g_object_notify(G_OBJECT(xmpp), "sasl-context");
3411   g_object_notify(G_OBJECT(xmpp), "sasl-mechanisms");
3412   g_object_thaw_notify(G_OBJECT(xmpp));
3413 }
3414 gboolean
3415 inf_xmpp_connection_retry_sasl_authentication(InfXmppConnection* xmpp,
3416                                               GError** error)
3417 {
3418   InfXmppConnectionPrivate* priv;
3419   const gchar* suggestion;
3420   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3421   g_return_val_if_fail(
3422     priv-&gt;status == INF_XMPP_CONNECTION_AWAITING_FEATURES,
3423     FALSE
3424   );
3425   suggestion = inf_xmpp_connection_sasl_suggest_mechanism(xmpp, error);
3426   if(suggestion == NULL)
3427     return FALSE;
3428   inf_xmpp_connection_sasl_init(xmpp, suggestion);
3429   return TRUE;
3430 }
3431 void
3432 inf_xmpp_connection_set_sasl_error(InfXmppConnection* xmpp,
3433                                    const GError* error)
3434 {
3435   InfXmppConnectionPrivate* priv;
3436   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3437   g_return_if_fail(priv-&gt;sasl_context != NULL);
3438   g_return_if_fail(priv-&gt;sasl_error == NULL);
3439   priv-&gt;sasl_error = g_error_copy(error);
3440 }
3441 const GError*
3442 inf_xmpp_connection_get_sasl_error(InfXmppConnection* xmpp)
3443 {
3444   InfXmppConnectionPrivate* priv;
3445   priv = INF_XMPP_CONNECTION_PRIVATE(xmpp);
3446   g_return_val_if_fail(priv-&gt;sasl_context != NULL, NULL);
3447   return priv-&gt;sasl_error;
3448 }
3449 GQuark
3450 inf_xmpp_connection_error_quark(void)
3451 {
3452   return g_quark_from_static_string("INF_XMPP_CONNECTION_ERROR");
3453 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
