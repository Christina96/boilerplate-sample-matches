
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.408094435075886%, Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hash.h</h3>
            <pre><code>1  #ifndef JEMALLOC_INTERNAL_HASH_H
2  #define JEMALLOC_INTERNAL_HASH_H
3  #include "jemalloc/internal/assert.h"
4  static inline uint32_t
5  hash_rotl_32(uint32_t x, int8_t r) {
6  	return ((x << r) | (x >> (32 - r)));
7  }
8  static inline uint64_t
9  hash_rotl_64(uint64_t x, int8_t r) {
10  	return ((x << r) | (x >> (64 - r)));
11  }
12  static inline uint32_t
13  hash_get_block_32(const uint32_t *p, int i) {
14  	if (unlikely((uintptr_t)p & (sizeof(uint32_t)-1)) != 0) {
15  		uint32_t ret;
16  		memcpy(&ret, (uint8_t *)(p + i), sizeof(uint32_t));
17  		return ret;
18  	}
19  	return p[i];
20  }
21  static inline uint64_t
22  hash_get_block_64(const uint64_t *p, int i) {
23  	if (unlikely((uintptr_t)p & (sizeof(uint64_t)-1)) != 0) {
24  		uint64_t ret;
25  		memcpy(&ret, (uint8_t *)(p + i), sizeof(uint64_t));
26  		return ret;
27  	}
28  	return p[i];
29  }
30  static inline uint32_t
31  hash_fmix_32(uint32_t h) {
32  	h ^= h >> 16;
33  	h *= 0x85ebca6b;
34  	h ^= h >> 13;
35  	h *= 0xc2b2ae35;
36  	h ^= h >> 16;
37  	return h;
38  }
39  static inline uint64_t
40  hash_fmix_64(uint64_t k) {
41  	k ^= k >> 33;
42  	k *= KQU(0xff51afd7ed558ccd);
43  	k ^= k >> 33;
44  	k *= KQU(0xc4ceb9fe1a85ec53);
45  	k ^= k >> 33;
46  	return k;
47  }
48  static inline uint32_t
49  hash_x86_32(const void *key, int len, uint32_t seed) {
50  	const uint8_t *data = (const uint8_t *) key;
51  	const int nblocks = len / 4;
52  	uint32_t h1 = seed;
53  	const uint32_t c1 = 0xcc9e2d51;
54  	const uint32_t c2 = 0x1b873593;
55  	{
56  		const uint32_t *blocks = (const uint32_t *) (data + nblocks*4);
57  		int i;
58  		for (i = -nblocks; i; i++) {
59  			uint32_t k1 = hash_get_block_32(blocks, i);
60  			k1 *= c1;
61  			k1 = hash_rotl_32(k1, 15);
62  			k1 *= c2;
63  			h1 ^= k1;
64  			h1 = hash_rotl_32(h1, 13);
65  			h1 = h1*5 + 0xe6546b64;
66  		}
67  	}
68  	{
69  		const uint8_t *tail = (const uint8_t *) (data + nblocks*4);
70  		uint32_t k1 = 0;
71  		switch (len & 3) {
72  		case 3: k1 ^= tail[2] << 16; JEMALLOC_FALLTHROUGH
73  		case 2: k1 ^= tail[1] << 8; JEMALLOC_FALLTHROUGH
74  		case 1: k1 ^= tail[0]; k1 *= c1; k1 = hash_rotl_32(k1, 15);
75  			k1 *= c2; h1 ^= k1;
76  		}
77  	}
78  	h1 ^= len;
79  	h1 = hash_fmix_32(h1);
80  	return h1;
81  }
82  static inline void
83  hash_x86_128(const void *key, const int len, uint32_t seed,
84      uint64_t r_out[2]) {
85  	const uint8_t * data = (const uint8_t *) key;
86  	const int nblocks = len / 16;
87  	uint32_t h1 = seed;
88  	uint32_t h2 = seed;
89  	uint32_t h3 = seed;
90  	uint32_t h4 = seed;
91  	const uint32_t c1 = 0x239b961b;
92  	const uint32_t c2 = 0xab0e9789;
93  	const uint32_t c3 = 0x38b34ae5;
94  	const uint32_t c4 = 0xa1e38b93;
95  	{
96  		const uint32_t *blocks = (const uint32_t *) (data + nblocks*16);
97  		int i;
98  		for (i = -nblocks; i; i++) {
<span onclick='openModal()' class='match'>99  			uint32_t k1 = hash_get_block_32(blocks, i*4 + 0);
100  			uint32_t k2 = hash_get_block_32(blocks, i*4 + 1);
101  			uint32_t k3 = hash_get_block_32(blocks, i*4 + 2);
102  			uint32_t k4 = hash_get_block_32(blocks, i*4 + 3);
103  			k1 *= c1; k1 = hash_rotl_32(k1, 15); k1 *= c2; h1 ^= k1;
104  			h1 = hash_rotl_32(h1, 19); h1 += h2;
105  			h1 = h1*5 + 0x561ccd1b;
106  			k2 *= c2; k2 = hash_rotl_32(k2, 16); k2 *= c3; h2 ^= k2;
107  			h2 = hash_rotl_32(h2, 17); h2 += h3;
108  			h2 = h2*5 + 0x0bcaa747;
109  			k3 *= c3; k3 = hash_rotl_32(k3, 17); k3 *= c4; h3 ^= k3;
</span>110  			h3 = hash_rotl_32(h3, 15); h3 += h4;
111  			h3 = h3*5 + 0x96cd1c35;
112  			k4 *= c4; k4 = hash_rotl_32(k4, 18); k4 *= c1; h4 ^= k4;
113  			h4 = hash_rotl_32(h4, 13); h4 += h1;
114  			h4 = h4*5 + 0x32ac3b17;
115  		}
116  	}
117  	{
118  		const uint8_t *tail = (const uint8_t *) (data + nblocks*16);
119  		uint32_t k1 = 0;
120  		uint32_t k2 = 0;
121  		uint32_t k3 = 0;
122  		uint32_t k4 = 0;
123  		switch (len & 15) {
124  		case 15: k4 ^= tail[14] << 16; JEMALLOC_FALLTHROUGH
125  		case 14: k4 ^= tail[13] << 8; JEMALLOC_FALLTHROUGH
126  		case 13: k4 ^= tail[12] << 0;
127  			k4 *= c4; k4 = hash_rotl_32(k4, 18); k4 *= c1; h4 ^= k4;
128        JEMALLOC_FALLTHROUGH
129  		case 12: k3 ^= tail[11] << 24; JEMALLOC_FALLTHROUGH
130  		case 11: k3 ^= tail[10] << 16; JEMALLOC_FALLTHROUGH
131  		case 10: k3 ^= tail[ 9] << 8; JEMALLOC_FALLTHROUGH
132  		case  9: k3 ^= tail[ 8] << 0;
133  		     k3 *= c3; k3 = hash_rotl_32(k3, 17); k3 *= c4; h3 ^= k3;
134           JEMALLOC_FALLTHROUGH
135  		case  8: k2 ^= tail[ 7] << 24; JEMALLOC_FALLTHROUGH
136  		case  7: k2 ^= tail[ 6] << 16; JEMALLOC_FALLTHROUGH
137  		case  6: k2 ^= tail[ 5] << 8; JEMALLOC_FALLTHROUGH
138  		case  5: k2 ^= tail[ 4] << 0;
139  			k2 *= c2; k2 = hash_rotl_32(k2, 16); k2 *= c3; h2 ^= k2;
140        JEMALLOC_FALLTHROUGH
141  		case  4: k1 ^= tail[ 3] << 24; JEMALLOC_FALLTHROUGH
142  		case  3: k1 ^= tail[ 2] << 16; JEMALLOC_FALLTHROUGH
143  		case  2: k1 ^= tail[ 1] << 8; JEMALLOC_FALLTHROUGH
144  		case  1: k1 ^= tail[ 0] << 0;
145  			k1 *= c1; k1 = hash_rotl_32(k1, 15); k1 *= c2; h1 ^= k1;
146        JEMALLOC_FALLTHROUGH
147  		}
148  	}
149  	h1 ^= len; h2 ^= len; h3 ^= len; h4 ^= len;
150  	h1 += h2; h1 += h3; h1 += h4;
151  	h2 += h1; h3 += h1; h4 += h1;
152  	h1 = hash_fmix_32(h1);
153  	h2 = hash_fmix_32(h2);
154  	h3 = hash_fmix_32(h3);
155  	h4 = hash_fmix_32(h4);
156  	h1 += h2; h1 += h3; h1 += h4;
157  	h2 += h1; h3 += h1; h4 += h1;
158  	r_out[0] = (((uint64_t) h2) << 32) | h1;
159  	r_out[1] = (((uint64_t) h4) << 32) | h3;
160  }
161  static inline void
162  hash_x64_128(const void *key, const int len, const uint32_t seed,
163      uint64_t r_out[2]) {
164  	const uint8_t *data = (const uint8_t *) key;
165  	const int nblocks = len / 16;
166  	uint64_t h1 = seed;
167  	uint64_t h2 = seed;
168  	const uint64_t c1 = KQU(0x87c37b91114253d5);
169  	const uint64_t c2 = KQU(0x4cf5ad432745937f);
170  	{
171  		const uint64_t *blocks = (const uint64_t *) (data);
172  		int i;
173  		for (i = 0; i < nblocks; i++) {
174  			uint64_t k1 = hash_get_block_64(blocks, i*2 + 0);
175  			uint64_t k2 = hash_get_block_64(blocks, i*2 + 1);
176  			k1 *= c1; k1 = hash_rotl_64(k1, 31); k1 *= c2; h1 ^= k1;
177  			h1 = hash_rotl_64(h1, 27); h1 += h2;
178  			h1 = h1*5 + 0x52dce729;
179  			k2 *= c2; k2 = hash_rotl_64(k2, 33); k2 *= c1; h2 ^= k2;
180  			h2 = hash_rotl_64(h2, 31); h2 += h1;
181  			h2 = h2*5 + 0x38495ab5;
182  		}
183  	}
184  	{
185  		const uint8_t *tail = (const uint8_t*)(data + nblocks*16);
186  		uint64_t k1 = 0;
187  		uint64_t k2 = 0;
188  		switch (len & 15) {
189  		case 15: k2 ^= ((uint64_t)(tail[14])) << 48; JEMALLOC_FALLTHROUGH
190  		case 14: k2 ^= ((uint64_t)(tail[13])) << 40; JEMALLOC_FALLTHROUGH
191  		case 13: k2 ^= ((uint64_t)(tail[12])) << 32; JEMALLOC_FALLTHROUGH
192  		case 12: k2 ^= ((uint64_t)(tail[11])) << 24; JEMALLOC_FALLTHROUGH
193  		case 11: k2 ^= ((uint64_t)(tail[10])) << 16; JEMALLOC_FALLTHROUGH
194  		case 10: k2 ^= ((uint64_t)(tail[ 9])) << 8;  JEMALLOC_FALLTHROUGH
195  		case  9: k2 ^= ((uint64_t)(tail[ 8])) << 0;
196  			k2 *= c2; k2 = hash_rotl_64(k2, 33); k2 *= c1; h2 ^= k2;
197  			JEMALLOC_FALLTHROUGH
198  		case  8: k1 ^= ((uint64_t)(tail[ 7])) << 56; JEMALLOC_FALLTHROUGH
199  		case  7: k1 ^= ((uint64_t)(tail[ 6])) << 48; JEMALLOC_FALLTHROUGH
200  		case  6: k1 ^= ((uint64_t)(tail[ 5])) << 40; JEMALLOC_FALLTHROUGH
201  		case  5: k1 ^= ((uint64_t)(tail[ 4])) << 32; JEMALLOC_FALLTHROUGH
202  		case  4: k1 ^= ((uint64_t)(tail[ 3])) << 24; JEMALLOC_FALLTHROUGH
203  		case  3: k1 ^= ((uint64_t)(tail[ 2])) << 16; JEMALLOC_FALLTHROUGH
204  		case  2: k1 ^= ((uint64_t)(tail[ 1])) << 8;  JEMALLOC_FALLTHROUGH
205  		case  1: k1 ^= ((uint64_t)(tail[ 0])) << 0;
206  			k1 *= c1; k1 = hash_rotl_64(k1, 31); k1 *= c2; h1 ^= k1;
207  		}
208  	}
209  	h1 ^= len; h2 ^= len;
210  	h1 += h2;
211  	h2 += h1;
212  	h1 = hash_fmix_64(h1);
213  	h2 = hash_fmix_64(h2);
214  	h1 += h2;
215  	h2 += h1;
216  	r_out[0] = h1;
217  	r_out[1] = h2;
218  }
219  static inline void
220  hash(const void *key, size_t len, const uint32_t seed, size_t r_hash[2]) {
221  	assert(len <= INT_MAX); &bsol;* Unfortunate implementation limitation. */
222  #if (LG_SIZEOF_PTR == 3 && !defined(JEMALLOC_BIG_ENDIAN))
223  	hash_x64_128(key, (int)len, seed, (uint64_t *)r_hash);
224  #else
225  	{
226  		uint64_t hashes[2];
227  		hash_x86_128(key, (int)len, seed, hashes);
228  		r_hash[0] = (size_t)hashes[0];
229  		r_hash[1] = (size_t)hashes[1];
230  	}
231  #endif
232  }
233  #endif &bsol;* JEMALLOC_INTERNAL_HASH_H */
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-tc.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <pcap.h>
5  #include <pcap-int.h>
6  #include "pcap-tc.h"
7  #include <malloc.h>
8  #include <memory.h>
9  #include <string.h>
10  #include <errno.h>
11  #ifdef _WIN32
12  #include <tchar.h>
13  #endif
14  typedef TC_STATUS	(TC_CALLCONV *TcFcnQueryPortList)			(PTC_PORT *ppPorts, PULONG pLength);
15  typedef TC_STATUS	(TC_CALLCONV *TcFcnFreePortList)			(TC_PORT *pPorts);
16  typedef PCHAR		(TC_CALLCONV *TcFcnStatusGetString)			(TC_STATUS status);
17  typedef PCHAR		(TC_CALLCONV *TcFcnPortGetName)				(TC_PORT port);
18  typedef PCHAR		(TC_CALLCONV *TcFcnPortGetDescription)		(TC_PORT port);
19  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceOpenByName)		(PCHAR name, PTC_INSTANCE pInstance);
20  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceClose)			(TC_INSTANCE instance);
21  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceSetFeature)		(TC_INSTANCE instance, ULONG feature, ULONG value);
22  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceQueryFeature)	(TC_INSTANCE instance, ULONG feature, PULONG pValue);
23  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceReceivePackets)	(TC_INSTANCE instance, PTC_PACKETS_BUFFER pBuffer);
24  typedef HANDLE		(TC_CALLCONV *TcFcnInstanceGetReceiveWaitHandle) (TC_INSTANCE instance);
25  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceTransmitPackets)	(TC_INSTANCE instance, TC_PACKETS_BUFFER pBuffer);
26  typedef TC_STATUS	(TC_CALLCONV *TcFcnInstanceQueryStatistics)	(TC_INSTANCE instance, PTC_STATISTICS pStatistics);
27  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferCreate)		(ULONG size, PTC_PACKETS_BUFFER pBuffer);
28  typedef VOID		(TC_CALLCONV *TcFcnPacketsBufferDestroy)	(TC_PACKETS_BUFFER buffer);
29  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferQueryNextPacket)(TC_PACKETS_BUFFER buffer, PTC_PACKET_HEADER pHeader, PVOID *ppData);
30  typedef TC_STATUS	(TC_CALLCONV *TcFcnPacketsBufferCommitNextPacket)(TC_PACKETS_BUFFER buffer, PTC_PACKET_HEADER pHeader, PVOID pData);
31  typedef VOID		(TC_CALLCONV *TcFcnStatisticsDestroy)		(TC_STATISTICS statistics);
32  typedef TC_STATUS	(TC_CALLCONV *TcFcnStatisticsUpdate)		(TC_STATISTICS statistics);
33  typedef TC_STATUS	(TC_CALLCONV *TcFcnStatisticsQueryValue)	(TC_STATISTICS statistics, ULONG counterId, PULONGLONG pValue);
34  typedef enum LONG
35  {
36  	TC_API_UNLOADED = 0,
37  	TC_API_LOADED,
38  	TC_API_CANNOT_LOAD,
39  	TC_API_LOADING
40  }
41  	TC_API_LOAD_STATUS;
42  typedef struct _TC_FUNCTIONS
43  {
44  	TC_API_LOAD_STATUS			LoadStatus;
45  #ifdef _WIN32
46  	HMODULE						hTcApiDllHandle;
47  #endif
48  	TcFcnQueryPortList			QueryPortList;
49  	TcFcnFreePortList			FreePortList;
50  	TcFcnStatusGetString		StatusGetString;
51  	TcFcnPortGetName			PortGetName;
52  	TcFcnPortGetDescription		PortGetDescription;
53  	TcFcnInstanceOpenByName		InstanceOpenByName;
54  	TcFcnInstanceClose			InstanceClose;
55  	TcFcnInstanceSetFeature		InstanceSetFeature;
56  	TcFcnInstanceQueryFeature	InstanceQueryFeature;
57  	TcFcnInstanceReceivePackets	InstanceReceivePackets;
58  #ifdef _WIN32
59  	TcFcnInstanceGetReceiveWaitHandle InstanceGetReceiveWaitHandle;
60  #endif
61  	TcFcnInstanceTransmitPackets InstanceTransmitPackets;
62  	TcFcnInstanceQueryStatistics InstanceQueryStatistics;
63  	TcFcnPacketsBufferCreate	PacketsBufferCreate;
64  	TcFcnPacketsBufferDestroy	PacketsBufferDestroy;
65  	TcFcnPacketsBufferQueryNextPacket	PacketsBufferQueryNextPacket;
66  	TcFcnPacketsBufferCommitNextPacket  PacketsBufferCommitNextPacket;
67  	TcFcnStatisticsDestroy		StatisticsDestroy;
68  	TcFcnStatisticsUpdate		StatisticsUpdate;
69  	TcFcnStatisticsQueryValue	StatisticsQueryValue;
70  }
71  	TC_FUNCTIONS;
72  static pcap_if_t* TcCreatePcapIfFromPort(TC_PORT port);
73  static int TcSetDatalink(pcap_t *p, int dlt);
74  static int TcGetNonBlock(pcap_t *p);
75  static int TcSetNonBlock(pcap_t *p, int nonblock);
76  static void TcCleanup(pcap_t *p);
77  static int TcInject(pcap_t *p, const void *buf, int size);
78  static int TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user);
79  static int TcStats(pcap_t *p, struct pcap_stat *ps);
80  #ifdef _WIN32
81  static struct pcap_stat *TcStatsEx(pcap_t *p, int *pcap_stat_size);
82  static int TcSetBuff(pcap_t *p, int dim);
83  static int TcSetMode(pcap_t *p, int mode);
84  static int TcSetMinToCopy(pcap_t *p, int size);
85  static HANDLE TcGetReceiveWaitHandle(pcap_t *p);
86  static int TcOidGetRequest(pcap_t *p, bpf_u_int32 oid, void *data, size_t *lenp);
87  static int TcOidSetRequest(pcap_t *p, bpf_u_int32 oid, const void *data, size_t *lenp);
88  static u_int TcSendqueueTransmit(pcap_t *p, pcap_send_queue *queue, int sync);
89  static int TcSetUserBuffer(pcap_t *p, int size);
90  static int TcLiveDump(pcap_t *p, char *filename, int maxsize, int maxpacks);
91  static int TcLiveDumpEnded(pcap_t *p, int sync);
92  static PAirpcapHandle TcGetAirPcapHandle(pcap_t *p);
93  #endif
94  #ifdef _WIN32
95  TC_FUNCTIONS g_TcFunctions =
96  {
97  	TC_API_UNLOADED, &bsol;* LoadStatus */
98  	NULL,  &bsol;* hTcApiDllHandle */
99  	NULL,  &bsol;* QueryPortList */
100  	NULL,  &bsol;* FreePortList */
101  	NULL,  &bsol;* StatusGetString */
102  	NULL,  &bsol;* PortGetName */
103  	NULL,  &bsol;* PortGetDescription */
104  	NULL,  &bsol;* InstanceOpenByName */
105  	NULL,  &bsol;* InstanceClose */
106  	NULL,  &bsol;* InstanceSetFeature */
107  	NULL,  &bsol;* InstanceQueryFeature */
108  	NULL,  &bsol;* InstanceReceivePackets */
109  	NULL,  &bsol;* InstanceGetReceiveWaitHandle */
110  	NULL,  &bsol;* InstanceTransmitPackets */
111  	NULL,  &bsol;* InstanceQueryStatistics */
112  	NULL,  &bsol;* PacketsBufferCreate */
113  	NULL,  &bsol;* PacketsBufferDestroy */
114  	NULL,  &bsol;* PacketsBufferQueryNextPacket */
115  	NULL,  &bsol;* PacketsBufferCommitNextPacket */
116  	NULL,  &bsol;* StatisticsDestroy */
117  	NULL,  &bsol;* StatisticsUpdate */
118  	NULL  &bsol;* StatisticsQueryValue */
119  };
120  #else
121  TC_FUNCTIONS g_TcFunctions =
122  {
123  	TC_API_LOADED, &bsol;* LoadStatus */
124  	TcQueryPortList,
125  	TcFreePortList,
126  	TcStatusGetString,
127  	TcPortGetName,
128  	TcPortGetDescription,
129  	TcInstanceOpenByName,
130  	TcInstanceClose,
131  	TcInstanceSetFeature,
132  	TcInstanceQueryFeature,
133  	TcInstanceReceivePackets,
134  #ifdef _WIN32
135  	TcInstanceGetReceiveWaitHandle,
136  #endif
137  	TcInstanceTransmitPackets,
138  	TcInstanceQueryStatistics,
139  	TcPacketsBufferCreate,
140  	TcPacketsBufferDestroy,
141  	TcPacketsBufferQueryNextPacket,
142  	TcPacketsBufferCommitNextPacket,
143  	TcStatisticsDestroy,
144  	TcStatisticsUpdate,
145  	TcStatisticsQueryValue,
146  };
147  #endif
148  #define MAX_TC_PACKET_SIZE	9500
149  #pragma pack(push, 1)
150  #define PPH_PH_FLAG_PADDING	((UCHAR)0x01)
151  #define PPH_PH_VERSION		((UCHAR)0x00)
152  typedef struct _PPI_PACKET_HEADER
153  {
154  	UCHAR	PphVersion;
155  	UCHAR	PphFlags;
156  	USHORT	PphLength;
157  	ULONG	PphDlt;
158  }
159  	PPI_PACKET_HEADER, *PPPI_PACKET_HEADER;
160  typedef struct _PPI_FIELD_HEADER
161  {
162  	USHORT PfhType;
163  	USHORT PfhLength;
164  }
165  	PPI_FIELD_HEADER, *PPPI_FIELD_HEADER;
166  #define		PPI_FIELD_TYPE_AGGREGATION_EXTENSION	((UCHAR)0x08)
167  typedef struct _PPI_FIELD_AGGREGATION_EXTENSION
168  {
169  	ULONG		InterfaceId;
170  }
171  	PPI_FIELD_AGGREGATION_EXTENSION, *PPPI_FIELD_AGGREGATION_EXTENSION;
172  #define		PPI_FIELD_TYPE_802_3_EXTENSION			((UCHAR)0x09)
173  #define PPI_FLD_802_3_EXT_FLAG_FCS_PRESENT			((ULONG)0x00000001)
174  typedef struct _PPI_FIELD_802_3_EXTENSION
175  {
176  	ULONG		Flags;
177  	ULONG		Errors;
178  }
179  	PPI_FIELD_802_3_EXTENSION, *PPPI_FIELD_802_3_EXTENSION;
180  typedef struct _PPI_HEADER
181  {
182  	PPI_PACKET_HEADER PacketHeader;
183  	PPI_FIELD_HEADER  AggregationFieldHeader;
184  	PPI_FIELD_AGGREGATION_EXTENSION AggregationField;
185  	PPI_FIELD_HEADER  Dot3FieldHeader;
186  	PPI_FIELD_802_3_EXTENSION Dot3Field;
187  }
188  	PPI_HEADER, *PPPI_HEADER;
189  #pragma pack(pop)
190  #ifdef _WIN32
191  TC_API_LOAD_STATUS LoadTcFunctions(void)
192  {
193  	TC_API_LOAD_STATUS currentStatus;
194  	do
195  	{
196  		currentStatus = InterlockedCompareExchange((LONG*)&g_TcFunctions.LoadStatus, TC_API_LOADING, TC_API_UNLOADED);
197  		while(currentStatus == TC_API_LOADING)
198  		{
199  			currentStatus = InterlockedCompareExchange((LONG*)&g_TcFunctions.LoadStatus, TC_API_LOADING, TC_API_LOADING);
200  			Sleep(10);
201  		}
202  		if(currentStatus  == TC_API_LOADED)
203  		{
204  			return TC_API_LOADED;
205  		}
206  		if (currentStatus == TC_API_CANNOT_LOAD)
207  		{
208  			return TC_API_CANNOT_LOAD;
209  		}
210  		currentStatus = TC_API_CANNOT_LOAD;
211  		g_TcFunctions.hTcApiDllHandle = pcap_load_code("TcApi.dll");
212  		if (g_TcFunctions.hTcApiDllHandle == NULL)	break;
<span onclick='openModal()' class='match'>213  		g_TcFunctions.QueryPortList			= (TcFcnQueryPortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcQueryPortList");
214  		g_TcFunctions.FreePortList			= (TcFcnFreePortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcFreePortList");
215  		g_TcFunctions.StatusGetString			= (TcFcnStatusGetString)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatusGetString");
216  		g_TcFunctions.PortGetName			= (TcFcnPortGetName)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetName");
217  		g_TcFunctions.PortGetDescription		= (TcFcnPortGetDescription)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetDescription");
218  		g_TcFunctions.InstanceOpenByName		= (TcFcnInstanceOpenByName)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceOpenByName");
219  		g_TcFunctions.InstanceClose			= (TcFcnInstanceClose)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceClose");
220  		g_TcFunctions.InstanceSetFeature		= (TcFcnInstanceSetFeature)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceSetFeature");
221  		g_TcFunctions.InstanceQueryFeature		= (TcFcnInstanceQueryFeature)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryFeature");
222  		g_TcFunctions.InstanceReceivePackets		= (TcFcnInstanceReceivePackets)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceReceivePackets");
223  		g_TcFunctions.InstanceGetReceiveWaitHandle	= (TcFcnInstanceGetReceiveWaitHandle)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceGetReceiveWaitHandle");
224  		g_TcFunctions.InstanceTransmitPackets		= (TcFcnInstanceTransmitPackets)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceTransmitPackets");
225  		g_TcFunctions.InstanceQueryStatistics		= (TcFcnInstanceQueryStatistics)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryStatistics");
226  		g_TcFunctions.PacketsBufferCreate		= (TcFcnPacketsBufferCreate)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCreate");
227  		g_TcFunctions.PacketsBufferDestroy		= (TcFcnPacketsBufferDestroy)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferDestroy");
228  		g_TcFunctions.PacketsBufferQueryNextPacket	= (TcFcnPacketsBufferQueryNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferQueryNextPacket");
229  		g_TcFunctions.PacketsBufferCommitNextPacket	= (TcFcnPacketsBufferCommitNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCommitNextPacket");
230  		g_TcFunctions.StatisticsDestroy			= (TcFcnStatisticsDestroy)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsDestroy");
231  		g_TcFunctions.StatisticsUpdate			= (TcFcnStatisticsUpdate)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsUpdate");
232  		g_TcFunctions.StatisticsQueryValue		= (TcFcnStatisticsQueryValue)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsQueryValue");
</span>233  		if (   g_TcFunctions.QueryPortList == NULL
234  			|| g_TcFunctions.FreePortList == NULL
235  			|| g_TcFunctions.StatusGetString == NULL
236  			|| g_TcFunctions.PortGetName == NULL
237  			|| g_TcFunctions.PortGetDescription == NULL
238  			|| g_TcFunctions.InstanceOpenByName == NULL
239  			|| g_TcFunctions.InstanceClose == NULL
240  			|| g_TcFunctions.InstanceSetFeature	 == NULL
241  			|| g_TcFunctions.InstanceQueryFeature == NULL
242  			|| g_TcFunctions.InstanceReceivePackets == NULL
243  			|| g_TcFunctions.InstanceGetReceiveWaitHandle == NULL
244  			|| g_TcFunctions.InstanceTransmitPackets == NULL
245  			|| g_TcFunctions.InstanceQueryStatistics == NULL
246  			|| g_TcFunctions.PacketsBufferCreate == NULL
247  			|| g_TcFunctions.PacketsBufferDestroy == NULL
248  			|| g_TcFunctions.PacketsBufferQueryNextPacket == NULL
249  			|| g_TcFunctions.PacketsBufferCommitNextPacket == NULL
250  			|| g_TcFunctions.StatisticsDestroy == NULL
251  			|| g_TcFunctions.StatisticsUpdate == NULL
252  			|| g_TcFunctions.StatisticsQueryValue == NULL
253  		)
254  		{
255  			break;
256  		}
257  		currentStatus = TC_API_LOADED;
258  	}while(FALSE);
259  	if (currentStatus != TC_API_LOADED)
260  	{
261  		if (g_TcFunctions.hTcApiDllHandle != NULL)
262  		{
263  			FreeLibrary(g_TcFunctions.hTcApiDllHandle);
264  			g_TcFunctions.hTcApiDllHandle = NULL;
265  		}
266  	}
267  	InterlockedExchange((LONG*)&g_TcFunctions.LoadStatus, currentStatus);
268  	return currentStatus;
269  }
270  #else
271  TC_API_LOAD_STATUS LoadTcFunctions(void)
272  {
273  	return TC_API_LOADED;
274  }
275  #endif
276  struct pcap_tc {
277  	TC_INSTANCE TcInstance;
278  	TC_PACKETS_BUFFER TcPacketsBuffer;
279  	ULONG TcAcceptedCount;
280  	u_char *PpiPacket;
281  };
282  int
283  TcFindAllDevs(pcap_if_list_t *devlist, char *errbuf)
284  {
285  	TC_API_LOAD_STATUS loadStatus;
286  	ULONG numPorts;
287  	PTC_PORT pPorts = NULL;
288  	TC_STATUS status;
289  	int result = 0;
290  	pcap_if_t *dev;
291  	ULONG i;
292  	do
293  	{
294  		loadStatus = LoadTcFunctions();
295  		if (loadStatus != TC_API_LOADED)
296  		{
297  			result = 0;
298  			break;
299  		}
300  		status = g_TcFunctions.QueryPortList(&pPorts, &numPorts);
301  		if (status != TC_SUCCESS)
302  		{
303  			result = 0;
304  			break;
305  		}
306  		for (i = 0; i < numPorts; i++)
307  		{
308  			dev = TcCreatePcapIfFromPort(pPorts[i]);
309  			if (dev != NULL)
310  				pcap_add_dev(devlist, dev->name, dev->flags, dev->description, errbuf);
311  		}
312  		if (numPorts > 0)
313  		{
314  			status = g_TcFunctions.FreePortList(pPorts);
315  		}
316  	}while(FALSE);
317  	return result;
318  }
319  static pcap_if_t* TcCreatePcapIfFromPort(TC_PORT port)
320  {
321  	CHAR *name;
322  	CHAR *description;
323  	pcap_if_t *newIf = NULL;
324  	newIf = (pcap_if_t*)malloc(sizeof(*newIf));
325  	if (newIf == NULL)
326  	{
327  		return NULL;
328  	}
329  	memset(newIf, 0, sizeof(*newIf));
330  	name = g_TcFunctions.PortGetName(port);
331  	description = g_TcFunctions.PortGetDescription(port);
332  	newIf->name = (char*)malloc(strlen(name) + 1);
333  	if (newIf->name == NULL)
334  	{
335  		free(newIf);
336  		return NULL;
337  	}
338  	newIf->description = (char*)malloc(strlen(description) + 1);
339  	if (newIf->description == NULL)
340  	{
341  		free(newIf->name);
342  		free(newIf);
343  		return NULL;
344  	}
345  	strcpy(newIf->name, name);
346  	strcpy(newIf->description, description);
347  	newIf->addresses = NULL;
348  	newIf->next = NULL;
349  	newIf->flags = 0;
350  	return newIf;
351  }
352  static int
353  TcActivate(pcap_t *p)
354  {
355  	struct pcap_tc *pt = p->priv;
356  	TC_STATUS status;
357  	ULONG timeout;
358  	PPPI_HEADER pPpiHeader;
359  	if (p->opt.rfmon)
360  	{
361  		return PCAP_ERROR_RFMON_NOTSUP;
362  	}
363  	pt->PpiPacket = malloc(sizeof(PPI_HEADER) + MAX_TC_PACKET_SIZE);
364  	if (pt->PpiPacket == NULL)
365  	{
366  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Error allocating memory");
367  		return PCAP_ERROR;
368  	}
369  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
370  		p->snapshot = MAXIMUM_SNAPLEN;
371  	pPpiHeader = (PPPI_HEADER)pt->PpiPacket;
372  	pPpiHeader->PacketHeader.PphDlt = DLT_EN10MB;
373  	pPpiHeader->PacketHeader.PphLength = sizeof(PPI_HEADER);
374  	pPpiHeader->PacketHeader.PphFlags = 0;
375  	pPpiHeader->PacketHeader.PphVersion = 0;
376  	pPpiHeader->AggregationFieldHeader.PfhLength = sizeof(PPI_FIELD_AGGREGATION_EXTENSION);
377  	pPpiHeader->AggregationFieldHeader.PfhType = PPI_FIELD_TYPE_AGGREGATION_EXTENSION;
378  	pPpiHeader->Dot3FieldHeader.PfhLength = sizeof(PPI_FIELD_802_3_EXTENSION);
379  	pPpiHeader->Dot3FieldHeader.PfhType = PPI_FIELD_TYPE_802_3_EXTENSION;
380  	status = g_TcFunctions.InstanceOpenByName(p->opt.device, &pt->TcInstance);
381  	if (status != TC_SUCCESS)
382  	{
383  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Error opening TurboCap adapter: %s", g_TcFunctions.StatusGetString(status));
384  		return PCAP_ERROR;
385  	}
386  	p->linktype = DLT_EN10MB;
387  	p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
388  	if (p->dlt_list != NULL) {
389  		p->dlt_list[0] = DLT_EN10MB;
390  		p->dlt_list[1] = DLT_PPI;
391  		p->dlt_count = 2;
392  	}
393  	status = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_RX_STATUS, 1);
394  	if (status != TC_SUCCESS)
395  	{
396  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,"Error enabling reception on a TurboCap instance: %s", g_TcFunctions.StatusGetString(status));
397  		goto bad;
398  	}
399  	status = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_TX_STATUS, 1);
400  	p->inject_op = TcInject;
401  	if (p->opt.timeout == 0)
402  	{
403  		timeout = 0xFFFFFFFF;
404  	}
405  	else
406  	if (p->opt.timeout < 0)
407  	{
408  		timeout = 10;
409  	}
410  	else
411  	{
412  		timeout = p->opt.timeout;
413  	}
414  	status = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_READ_TIMEOUT, timeout);
415  	if (status != TC_SUCCESS)
416  	{
417  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,"Error setting the read timeout a TurboCap instance: %s", g_TcFunctions.StatusGetString(status));
418  		goto bad;
419  	}
420  	p->read_op = TcRead;
421  	p->setfilter_op = pcap_install_bpf_program;
422  	p->setdirection_op = NULL;	&bsol;* Not implemented. */
423  	p->set_datalink_op = TcSetDatalink;
424  	p->getnonblock_op = TcGetNonBlock;
425  	p->setnonblock_op = TcSetNonBlock;
426  	p->stats_op = TcStats;
427  #ifdef _WIN32
428  	p->stats_ex_op = TcStatsEx;
429  	p->setbuff_op = TcSetBuff;
430  	p->setmode_op = TcSetMode;
431  	p->setmintocopy_op = TcSetMinToCopy;
432  	p->getevent_op = TcGetReceiveWaitHandle;
433  	p->oid_get_request_op = TcOidGetRequest;
434  	p->oid_set_request_op = TcOidSetRequest;
435  	p->sendqueue_transmit_op = TcSendqueueTransmit;
436  	p->setuserbuffer_op = TcSetUserBuffer;
437  	p->live_dump_op = TcLiveDump;
438  	p->live_dump_ended_op = TcLiveDumpEnded;
439  	p->get_airpcap_handle_op = TcGetAirPcapHandle;
440  #else
441  	p->selectable_fd = -1;
442  #endif
443  	p->cleanup_op = TcCleanup;
444  	return 0;
445  bad:
446  	TcCleanup(p);
447  	return PCAP_ERROR;
448  }
449  pcap_t *
450  TcCreate(const char *device, char *ebuf, int *is_ours)
451  {
452  	ULONG numPorts;
453  	PTC_PORT pPorts = NULL;
454  	TC_STATUS status;
455  	int is_tc;
456  	ULONG i;
457  	pcap_t *p;
458  	if (LoadTcFunctions() != TC_API_LOADED)
459  	{
460  		*is_ours = 0;
461  		return NULL;
462  	}
463  	status = g_TcFunctions.QueryPortList(&pPorts, &numPorts);
464  	if (status != TC_SUCCESS)
465  	{
466  		*is_ours = 0;
467  		return NULL;
468  	}
469  	is_tc = FALSE;
470  	for (i = 0; i < numPorts; i++)
471  	{
472  		if (strcmp(g_TcFunctions.PortGetName(pPorts[i]), device) == 0)
473  		{
474  			is_tc = TRUE;
475  			break;
476  		}
477  	}
478  	if (numPorts > 0)
479  	{
480  		(void)g_TcFunctions.FreePortList(pPorts);
481  	}
482  	if (!is_tc)
483  	{
484  		*is_ours = 0;
485  		return NULL;
486  	}
487  	*is_ours = 1;
488  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_tc);
489  	if (p == NULL)
490  		return NULL;
491  	p->activate_op = TcActivate;
492  	p->getnonblock_op = TcGetNonBlock;
493  	p->setnonblock_op = TcSetNonBlock;
494  	return p;
495  }
496  static int TcSetDatalink(pcap_t *p, int dlt)
497  {
498  	return 0;
499  }
500  static int TcGetNonBlock(pcap_t *p)
501  {
502  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
503  	    "Non-blocking mode isn't supported for TurboCap ports");
504  	return -1;
505  }
506  static int TcSetNonBlock(pcap_t *p, int nonblock)
507  {
508  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
509  	    "Non-blocking mode isn't supported for TurboCap ports");
510  	return -1;
511  }
512  static void TcCleanup(pcap_t *p)
513  {
514  	struct pcap_tc *pt = p->priv;
515  	if (pt->TcPacketsBuffer != NULL)
516  	{
517  		g_TcFunctions.PacketsBufferDestroy(pt->TcPacketsBuffer);
518  		pt->TcPacketsBuffer = NULL;
519  	}
520  	if (pt->TcInstance != NULL)
521  	{
522  		g_TcFunctions.InstanceClose(pt->TcInstance);
523  		pt->TcInstance = NULL;
524  	}
525  	if (pt->PpiPacket != NULL)
526  	{
527  		free(pt->PpiPacket);
528  		pt->PpiPacket = NULL;
529  	}
530  	pcap_cleanup_live_common(p);
531  }
532  static int TcInject(pcap_t *p, const void *buf, int size)
533  {
534  	struct pcap_tc *pt = p->priv;
535  	TC_STATUS status;
536  	TC_PACKETS_BUFFER buffer;
537  	TC_PACKET_HEADER header;
538  	if (size >= 0xFFFF)
539  	{
540  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "send error: the TurboCap API does not support packets larger than 64k");
541  		return -1;
542  	}
543  	status = g_TcFunctions.PacketsBufferCreate(sizeof(TC_PACKET_HEADER) + TC_ALIGN_USHORT_TO_64BIT((USHORT)size), &buffer);
544  	if (status != TC_SUCCESS)
545  	{
546  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "send error: TcPacketsBufferCreate failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
547  		return -1;
548  	}
549  	memset(&header, 0, sizeof(header));
550  	header.Length = (USHORT)size;
551  	header.CapturedLength = header.Length;
552  	status = g_TcFunctions.PacketsBufferCommitNextPacket(buffer, &header, (PVOID)buf);
553  	if (status == TC_SUCCESS)
554  	{
555  		status = g_TcFunctions.InstanceTransmitPackets(pt->TcInstance, buffer);
556  		if (status != TC_SUCCESS)
557  		{
558  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "send error: TcInstanceTransmitPackets failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
559  		}
560  	}
561  	else
562  	{
563  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "send error: TcPacketsBufferCommitNextPacket failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
564  	}
565  	g_TcFunctions.PacketsBufferDestroy(buffer);
566  	if (status != TC_SUCCESS)
567  	{
568  		return -1;
569  	}
570  	else
571  	{
572  		return 0;
573  	}
574  }
575  static int TcRead(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
576  {
577  	struct pcap_tc *pt = p->priv;
578  	TC_STATUS status;
579  	int n = 0;
580  	if (p->break_loop)
581  	{
582  		p->break_loop = 0;
583  		return -2;
584  	}
585  	if (pt->TcPacketsBuffer == NULL)
586  	{
587  		status = g_TcFunctions.InstanceReceivePackets(pt->TcInstance, &pt->TcPacketsBuffer);
588  		if (status != TC_SUCCESS)
589  		{
590  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "read error, TcInstanceReceivePackets failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
591  			return -1;
592  		}
593  	}
594  	while (TRUE)
595  	{
596  		struct pcap_pkthdr hdr;
597  		TC_PACKET_HEADER tcHeader;
598  		PVOID data;
599  		ULONG filterResult;
600  		if (p->break_loop)
601  		{
602  			if (n == 0)
603  			{
604  				p->break_loop = 0;
605  				return -2;
606  			}
607  			else
608  			{
609  				return n;
610  			}
611  		}
612  		if (pt->TcPacketsBuffer == NULL)
613  		{
614  			break;
615  		}
616  		status = g_TcFunctions.PacketsBufferQueryNextPacket(pt->TcPacketsBuffer, &tcHeader, &data);
617  		if (status == TC_ERROR_END_OF_BUFFER)
618  		{
619  			g_TcFunctions.PacketsBufferDestroy(pt->TcPacketsBuffer);
620  			pt->TcPacketsBuffer = NULL;
621  			break;
622  		}
623  		if (status != TC_SUCCESS)
624  		{
625  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "read error, TcPacketsBufferQueryNextPacket failure: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
626  			return -1;
627  		}
628  		if (p->fcode.bf_insns)
629  		{
630  			filterResult = pcap_filter(p->fcode.bf_insns, data, tcHeader.Length, tcHeader.CapturedLength);
631  			if (filterResult == 0)
632  			{
633  				continue;
634  			}
635  			if (filterResult > tcHeader.CapturedLength)
636  			{
637  				filterResult = tcHeader.CapturedLength;
638  			}
639  		}
640  		else
641  		{
642  			filterResult = tcHeader.CapturedLength;
643  		}
644  		pt->TcAcceptedCount ++;
645  		hdr.ts.tv_sec = (bpf_u_int32)(tcHeader.Timestamp / (ULONGLONG)(1000  * 1000 * 1000));
646  		hdr.ts.tv_usec = (bpf_u_int32)((tcHeader.Timestamp % (ULONGLONG)(1000  * 1000 * 1000)) / 1000);
647  		if (p->linktype == DLT_EN10MB)
648  		{
649  			hdr.caplen = filterResult;
650  			hdr.len = tcHeader.Length;
651  			(*callback)(user, &hdr, data);
652  		}
653  		else
654  		{
655  			PPPI_HEADER pPpiHeader = (PPPI_HEADER)pt->PpiPacket;
656  			PVOID data2 = pPpiHeader + 1;
657  			pPpiHeader->AggregationField.InterfaceId = TC_PH_FLAGS_RX_PORT_ID(tcHeader.Flags);
658  			pPpiHeader->Dot3Field.Errors = tcHeader.Errors;
659  			if (tcHeader.Flags & TC_PH_FLAGS_CHECKSUM)
660  			{
661  				pPpiHeader->Dot3Field.Flags = PPI_FLD_802_3_EXT_FLAG_FCS_PRESENT;
662  			}
663  			else
664  			{
665  				pPpiHeader->Dot3Field.Flags = 0;
666  			}
667  			if (filterResult <= MAX_TC_PACKET_SIZE)
668  			{
669  				memcpy(data2, data, filterResult);
670  				hdr.caplen = sizeof(PPI_HEADER) + filterResult;
671  				hdr.len = sizeof(PPI_HEADER) + tcHeader.Length;
672  			}
673  			else
674  			{
675  				memcpy(data2, data, MAX_TC_PACKET_SIZE);
676  				hdr.caplen = sizeof(PPI_HEADER) + MAX_TC_PACKET_SIZE;
677  				hdr.len = sizeof(PPI_HEADER) + tcHeader.Length;
678  			}
679  			(*callback)(user, &hdr, pt->PpiPacket);
680  		}
681  		if (++n >= cnt && cnt > 0)
682  		{
683  			return n;
684  		}
685  	}
686  	return n;
687  }
688  static int
689  TcStats(pcap_t *p, struct pcap_stat *ps)
690  {
691  	struct pcap_tc *pt = p->priv;
692  	TC_STATISTICS statistics;
693  	TC_STATUS status;
694  	ULONGLONG counter;
695  	struct pcap_stat s;
696  	status = g_TcFunctions.InstanceQueryStatistics(pt->TcInstance, &statistics);
697  	if (status != TC_SUCCESS)
698  	{
699  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcInstanceQueryStatistics: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
700  		return -1;
701  	}
702  	memset(&s, 0, sizeof(s));
703  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_TOTAL_RX_PACKETS, &counter);
704  	if (status != TC_SUCCESS)
705  	{
706  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcStatisticsQueryValue: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
707  		return -1;
708  	}
709  	if (counter <= (ULONGLONG)0xFFFFFFFF)
710  	{
711  		s.ps_recv = (ULONG)counter;
712  	}
713  	else
714  	{
715  		s.ps_recv = 0xFFFFFFFF;
716  	}
717  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_RX_DROPPED_PACKETS, &counter);
718  	if (status != TC_SUCCESS)
719  	{
720  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcStatisticsQueryValue: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
721  		return -1;
722  	}
723  	if (counter <= (ULONGLONG)0xFFFFFFFF)
724  	{
725  		s.ps_ifdrop = (ULONG)counter;
726  		s.ps_drop = (ULONG)counter;
727  	}
728  	else
729  	{
730  		s.ps_ifdrop = 0xFFFFFFFF;
731  		s.ps_drop = 0xFFFFFFFF;
732  	}
733  #if defined(_WIN32) && defined(ENABLE_REMOTE)
734  	s.ps_capt = pt->TcAcceptedCount;
735  #endif
736  	*ps = s;
737  	return 0;
738  }
739  #ifdef _WIN32
740  static struct pcap_stat *
741  TcStatsEx(pcap_t *p, int *pcap_stat_size)
742  {
743  	struct pcap_tc *pt = p->priv;
744  	TC_STATISTICS statistics;
745  	TC_STATUS status;
746  	ULONGLONG counter;
747  	*pcap_stat_size = sizeof (p->stat);
748  	status = g_TcFunctions.InstanceQueryStatistics(pt->TcInstance, &statistics);
749  	if (status != TC_SUCCESS)
750  	{
751  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcInstanceQueryStatistics: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
752  		return NULL;
753  	}
754  	memset(&p->stat, 0, sizeof(p->stat));
755  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_TOTAL_RX_PACKETS, &counter);
756  	if (status != TC_SUCCESS)
757  	{
758  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcStatisticsQueryValue: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
759  		return NULL;
760  	}
761  	if (counter <= (ULONGLONG)0xFFFFFFFF)
762  	{
763  		p->stat.ps_recv = (ULONG)counter;
764  	}
765  	else
766  	{
767  		p->stat.ps_recv = 0xFFFFFFFF;
768  	}
769  	status = g_TcFunctions.StatisticsQueryValue(statistics, TC_COUNTER_INSTANCE_RX_DROPPED_PACKETS, &counter);
770  	if (status != TC_SUCCESS)
771  	{
772  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error in TcStatisticsQueryValue: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
773  		return NULL;
774  	}
775  	if (counter <= (ULONGLONG)0xFFFFFFFF)
776  	{
777  		p->stat.ps_ifdrop = (ULONG)counter;
778  		p->stat.ps_drop = (ULONG)counter;
779  	}
780  	else
781  	{
782  		p->stat.ps_ifdrop = 0xFFFFFFFF;
783  		p->stat.ps_drop = 0xFFFFFFFF;
784  	}
785  #if defined(_WIN32) && defined(ENABLE_REMOTE)
786  	p->stat.ps_capt = pt->TcAcceptedCount;
787  #endif
788  	return &p->stat;
789  }
790  static int
791  TcSetBuff(pcap_t *p, int dim)
792  {
793  	return 0;
794  }
795  static int
796  TcSetMode(pcap_t *p, int mode)
797  {
798  	if (mode != MODE_CAPT)
799  	{
800  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Mode %d not supported by TurboCap devices. TurboCap only supports capture.", mode);
801  		return -1;
802  	}
803  	return 0;
804  }
805  static int
806  TcSetMinToCopy(pcap_t *p, int size)
807  {
808  	struct pcap_tc *pt = p->priv;
809  	TC_STATUS status;
810  	if (size < 0)
811  	{
812  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Mintocopy cannot be less than 0.");
813  		return -1;
814  	}
815  	status = g_TcFunctions.InstanceSetFeature(pt->TcInstance, TC_INST_FT_MINTOCOPY, (ULONG)size);
816  	if (status != TC_SUCCESS)
817  	{
818  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "TurboCap error setting the mintocopy: %s (%08x)", g_TcFunctions.StatusGetString(status), status);
819  	}
820  	return 0;
821  }
822  static HANDLE
823  TcGetReceiveWaitHandle(pcap_t *p)
824  {
825  	struct pcap_tc *pt = p->priv;
826  	return g_TcFunctions.InstanceGetReceiveWaitHandle(pt->TcInstance);
827  }
828  static int
829  TcOidGetRequest(pcap_t *p, bpf_u_int32 oid _U_, void *data _U_, size_t *lenp _U_)
830  {
831  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
832  	    "An OID get request cannot be performed on a TurboCap device");
833  	return PCAP_ERROR;
834  }
835  static int
836  TcOidSetRequest(pcap_t *p, bpf_u_int32 oid _U_, const void *data _U_,
837      size_t *lenp _U_)
838  {
839  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
840  	    "An OID set request cannot be performed on a TurboCap device");
841  	return PCAP_ERROR;
842  }
843  static u_int
844  TcSendqueueTransmit(pcap_t *p, pcap_send_queue *queue _U_, int sync _U_)
845  {
846  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
847  	    "Packets cannot be bulk transmitted on a TurboCap device");
848  	return 0;
849  }
850  static int
851  TcSetUserBuffer(pcap_t *p, int size _U_)
852  {
853  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
854  	    "The user buffer cannot be set on a TurboCap device");
855  	return -1;
856  }
857  static int
858  TcLiveDump(pcap_t *p, char *filename _U_, int maxsize _U_, int maxpacks _U_)
859  {
860  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
861  	    "Live packet dumping cannot be performed on a TurboCap device");
862  	return -1;
863  }
864  static int
865  TcLiveDumpEnded(pcap_t *p, int sync _U_)
866  {
867  	snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
868  	    "Live packet dumping cannot be performed on a TurboCap device");
869  	return -1;
870  }
871  static PAirpcapHandle
872  TcGetAirPcapHandle(pcap_t *p _U_)
873  {
874  	return NULL;
875  }
876  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hash.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-tc.c</div>
                </div>
                <div class="column column_space"><pre><code>99  			uint32_t k1 = hash_get_block_32(blocks, i*4 + 0);
100  			uint32_t k2 = hash_get_block_32(blocks, i*4 + 1);
101  			uint32_t k3 = hash_get_block_32(blocks, i*4 + 2);
102  			uint32_t k4 = hash_get_block_32(blocks, i*4 + 3);
103  			k1 *= c1; k1 = hash_rotl_32(k1, 15); k1 *= c2; h1 ^= k1;
104  			h1 = hash_rotl_32(h1, 19); h1 += h2;
105  			h1 = h1*5 + 0x561ccd1b;
106  			k2 *= c2; k2 = hash_rotl_32(k2, 16); k2 *= c3; h2 ^= k2;
107  			h2 = hash_rotl_32(h2, 17); h2 += h3;
108  			h2 = h2*5 + 0x0bcaa747;
109  			k3 *= c3; k3 = hash_rotl_32(k3, 17); k3 *= c4; h3 ^= k3;
</pre></code></div>
                <div class="column column_space"><pre><code>213  		g_TcFunctions.QueryPortList			= (TcFcnQueryPortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcQueryPortList");
214  		g_TcFunctions.FreePortList			= (TcFcnFreePortList)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcFreePortList");
215  		g_TcFunctions.StatusGetString			= (TcFcnStatusGetString)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatusGetString");
216  		g_TcFunctions.PortGetName			= (TcFcnPortGetName)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetName");
217  		g_TcFunctions.PortGetDescription		= (TcFcnPortGetDescription)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPortGetDescription");
218  		g_TcFunctions.InstanceOpenByName		= (TcFcnInstanceOpenByName)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceOpenByName");
219  		g_TcFunctions.InstanceClose			= (TcFcnInstanceClose)			pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceClose");
220  		g_TcFunctions.InstanceSetFeature		= (TcFcnInstanceSetFeature)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceSetFeature");
221  		g_TcFunctions.InstanceQueryFeature		= (TcFcnInstanceQueryFeature)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryFeature");
222  		g_TcFunctions.InstanceReceivePackets		= (TcFcnInstanceReceivePackets)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceReceivePackets");
223  		g_TcFunctions.InstanceGetReceiveWaitHandle	= (TcFcnInstanceGetReceiveWaitHandle)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceGetReceiveWaitHandle");
224  		g_TcFunctions.InstanceTransmitPackets		= (TcFcnInstanceTransmitPackets)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceTransmitPackets");
225  		g_TcFunctions.InstanceQueryStatistics		= (TcFcnInstanceQueryStatistics)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcInstanceQueryStatistics");
226  		g_TcFunctions.PacketsBufferCreate		= (TcFcnPacketsBufferCreate)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCreate");
227  		g_TcFunctions.PacketsBufferDestroy		= (TcFcnPacketsBufferDestroy)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferDestroy");
228  		g_TcFunctions.PacketsBufferQueryNextPacket	= (TcFcnPacketsBufferQueryNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferQueryNextPacket");
229  		g_TcFunctions.PacketsBufferCommitNextPacket	= (TcFcnPacketsBufferCommitNextPacket)pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcPacketsBufferCommitNextPacket");
230  		g_TcFunctions.StatisticsDestroy			= (TcFcnStatisticsDestroy)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsDestroy");
231  		g_TcFunctions.StatisticsUpdate			= (TcFcnStatisticsUpdate)		pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsUpdate");
232  		g_TcFunctions.StatisticsQueryValue		= (TcFcnStatisticsQueryValue)	pcap_find_function(g_TcFunctions.hTcApiDllHandle, "TcStatisticsQueryValue");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    