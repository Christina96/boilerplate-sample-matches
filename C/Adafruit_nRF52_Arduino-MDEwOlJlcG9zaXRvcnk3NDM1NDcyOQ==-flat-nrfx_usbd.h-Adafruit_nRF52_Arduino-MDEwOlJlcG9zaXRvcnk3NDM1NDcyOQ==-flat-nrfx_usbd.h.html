
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_usbd.h</h3>
            <pre><code>1  #ifndef NRFX_USBD_H__
2  #define NRFX_USBD_H__
3  #include <nrfx.h>
4  #include <hal/nrf_usbd.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  #define NRFX_USBD_EPSIZE 64
9  #define NRFX_USBD_ISOSIZE 1024
10  #define NRFX_USBD_FEEDER_BUFFER_SIZE NRFX_USBD_EPSIZE
11  #define NRFX_USBD_EPIN(n)   ((nrfx_usbd_ep_t)NRF_USBD_EPIN(n))
12  #define NRFX_USBD_EPOUT(n)  ((nrfx_usbd_ep_t)NRF_USBD_EPOUT(n))
13  typedef enum
14  {
15      NRFX_USBD_EPOUT0 = NRF_USBD_EPOUT(0), &bsol;**< Endpoint OUT 0 */
16      NRFX_USBD_EPOUT1 = NRF_USBD_EPOUT(1), &bsol;**< Endpoint OUT 1 */
17      NRFX_USBD_EPOUT2 = NRF_USBD_EPOUT(2), &bsol;**< Endpoint OUT 2 */
18      NRFX_USBD_EPOUT3 = NRF_USBD_EPOUT(3), &bsol;**< Endpoint OUT 3 */
19      NRFX_USBD_EPOUT4 = NRF_USBD_EPOUT(4), &bsol;**< Endpoint OUT 4 */
20      NRFX_USBD_EPOUT5 = NRF_USBD_EPOUT(5), &bsol;**< Endpoint OUT 5 */
21      NRFX_USBD_EPOUT6 = NRF_USBD_EPOUT(6), &bsol;**< Endpoint OUT 6 */
22      NRFX_USBD_EPOUT7 = NRF_USBD_EPOUT(7), &bsol;**< Endpoint OUT 7 */
23      NRFX_USBD_EPOUT8 = NRF_USBD_EPOUT(8), &bsol;**< Endpoint OUT 8 */
24      NRFX_USBD_EPIN0  = NRF_USBD_EPIN(0), &bsol;**< Endpoint IN 0 */
25      NRFX_USBD_EPIN1  = NRF_USBD_EPIN(1), &bsol;**< Endpoint IN 1 */
26      NRFX_USBD_EPIN2  = NRF_USBD_EPIN(2), &bsol;**< Endpoint IN 2 */
27      NRFX_USBD_EPIN3  = NRF_USBD_EPIN(3), &bsol;**< Endpoint IN 3 */
28      NRFX_USBD_EPIN4  = NRF_USBD_EPIN(4), &bsol;**< Endpoint IN 4 */
29      NRFX_USBD_EPIN5  = NRF_USBD_EPIN(5), &bsol;**< Endpoint IN 5 */
30      NRFX_USBD_EPIN6  = NRF_USBD_EPIN(6), &bsol;**< Endpoint IN 6 */
31      NRFX_USBD_EPIN7  = NRF_USBD_EPIN(7), &bsol;**< Endpoint IN 7 */
32      NRFX_USBD_EPIN8  = NRF_USBD_EPIN(8), &bsol;**< Endpoint IN 8 */
33  } nrfx_usbd_ep_t;
34  typedef enum
35  {
36      NRFX_USBD_EVT_SOF,        &bsol;**< Start Of Frame event on USB bus detected. */
37      NRFX_USBD_EVT_RESET,      &bsol;**< Reset condition on USB bus detected. */
38      NRFX_USBD_EVT_SUSPEND,    &bsol;**< This device should go to suspend mode now. */
39      NRFX_USBD_EVT_RESUME,     &bsol;**< This device should resume from suspend now. */
40      NRFX_USBD_EVT_WUREQ,      &bsol;**< Wakeup request - the USBD peripheral is ready to generate
41  	                               WAKEUP signal after exiting low power mode. */
42      NRFX_USBD_EVT_SETUP,      &bsol;**< Setup frame received and decoded. */
43      NRFX_USBD_EVT_EPTRANSFER, &bsol;**< For Rx (OUT: Host->Device):
44                                 *   1. The packet has been received but there is no buffer prepared for transfer already.
45                                 *   2. Whole transfer has been finished.
46                                 *
47                                 *   For Tx (IN: Device->Host):
48                                 *   The last packet from requested transfer has been transfered over USB bus and acknowledged.
49                                 */
50      NRFX_USBD_EVT_CNT         &bsol;**< Number of defined events. */
51  } nrfx_usbd_event_type_t;
52  typedef enum
53  {
54      NRFX_USBD_EP_OK,       &bsol;**< No error occured. */
55      NRFX_USBD_EP_WAITING,  &bsol;**< Data received, no buffer prepared already - waiting for configured transfer. */
56      NRFX_USBD_EP_OVERLOAD, &bsol;**< Received number of bytes cannot fit given buffer.
57                              *   This error would also be returned when next_transfer function has been defined
58                              *   but currently received data cannot fit completely in current buffer.
59                              *   No data split from single endpoint transmission is supported.
60                              *
61                              *   When this error is reported - data is left inside endpoint buffer.
62                              *   Clear endpoint or prepare new buffer and read it.
63                              */
64      NRFX_USBD_EP_ABORTED,  &bsol;**< EP0 transfer can be aborted when new setup comes.
65                              *   Any other transfer can be aborted by USB reset or driver stopping.
66                              */
67      NRFX_USBD_EP_BUSY,     &bsol;**< Transfer is in progress. */
68  } nrfx_usbd_ep_status_t;
69  typedef struct
70  {
71      nrfx_usbd_event_type_t type;          &bsol;**< Event type. */
72      union
73      {
74          struct {
75              uint16_t framecnt;            &bsol;**< Current value of frame counter. */
76          } sof;                            &bsol;**< Data available for @ref NRFX_USBD_EVT_SOF. */
77          struct {
78              nrfx_usbd_ep_t        ep;     &bsol;**< Endpoint number. */
79          } isocrc;                         &bsol;**< Isochronouns channel endpoint number. */
80          struct {
81              nrfx_usbd_ep_t        ep;     &bsol;**< Endpoint number. */
82              nrfx_usbd_ep_status_t status; &bsol;**< Status for the endpoint. */
83          } eptransfer;                     &bsol;**< Endpoint transfer status. */
84      } data;                               &bsol;**< Union to store event data. */
85  } nrfx_usbd_evt_t;
86  typedef void (*nrfx_usbd_event_handler_t)(nrfx_usbd_evt_t const * p_event);
87  typedef union
88  {
89      void const * tx; 
90      void * rx;       
91      uint32_t addr;   
92  } nrfx_usbd_data_ptr_t;
93  typedef struct
94  {
95      nrfx_usbd_data_ptr_t p_data; 
96      size_t size;                 
97  } nrfx_usbd_ep_transfer_t;
98  typedef enum
99  {
100      NRFX_USBD_TRANSFER_ZLP_FLAG = 1U << 0, 
101  } nrfx_usbd_transfer_flags_t;
102  typedef struct
103  {
104      nrfx_usbd_data_ptr_t p_data; 
105      size_t size;                 
106      uint32_t flags;              
107  } nrfx_usbd_transfer_t;
108  #define NRFX_USBD_TRANSFER_IN(name, tx_buff, tx_size, tx_flags) \
109      const nrfx_usbd_transfer_t name = {                         \
110         .p_data = { .tx = (tx_buff)  },                          \
111         .size = (tx_size),                                       \
112         .flags = (tx_flags)                                      \
113      }
114  #define NRFX_USBD_TRANSFER_OUT(name, rx_buff, rx_size) \
115      const nrfx_usbd_transfer_t name = {                \
116         .p_data = { .rx = (rx_buff)  },                 \
117         .size = (rx_size),                              \
118         .flags = 0                                      \
119      }
120  typedef bool (*nrfx_usbd_feeder_t)(nrfx_usbd_ep_transfer_t * p_next,
121                                     void * p_context,
122                                     size_t ep_size);
123  typedef bool (*nrfx_usbd_consumer_t)(nrfx_usbd_ep_transfer_t * p_next,
124                                       void * p_context,
125                                       size_t ep_size,
126                                       size_t data_size);
127  typedef union
128  {
129      nrfx_usbd_feeder_t   feeder;   
130      nrfx_usbd_consumer_t consumer; 
131  } nrfx_usbd_handler_t;
132  typedef struct
133  {
134      nrfx_usbd_handler_t handler;   
135      void *              p_context; 
136  } nrfx_usbd_handler_desc_t;
137  typedef struct
138  {
139      uint8_t  bmRequestType; 
140      uint8_t  bRequest;      
141      uint16_t wValue;        
142      uint16_t wIndex;        
143      uint16_t wLength;       
144  } nrfx_usbd_setup_t;
145  nrfx_err_t nrfx_usbd_init(nrfx_usbd_event_handler_t event_handler);
146  void nrfx_usbd_uninit(void);
147  void nrfx_usbd_enable(void);
148  void nrfx_usbd_disable(void);
149  void nrfx_usbd_start(bool enable_sof);
150  void nrfx_usbd_stop(void);
151  bool nrfx_usbd_is_initialized(void);
152  bool nrfx_usbd_is_enabled(void);
153  bool nrfx_usbd_is_started(void);
154  bool nrfx_usbd_suspend(void);
155  bool nrfx_usbd_wakeup_req(void);
156  bool nrfx_usbd_suspend_check(void);
157  void nrfx_usbd_suspend_irq_config(void);
158  void nrfx_usbd_active_irq_config(void);
159  bool nrfx_usbd_bus_suspend_check(void);
160  void nrfx_usbd_force_bus_wakeup(void);
161  void nrfx_usbd_ep_max_packet_size_set(nrfx_usbd_ep_t ep, uint16_t size);
162  uint16_t nrfx_usbd_ep_max_packet_size_get(nrfx_usbd_ep_t ep);
163  bool nrfx_usbd_ep_enable_check(nrfx_usbd_ep_t ep);
164  void nrfx_usbd_ep_enable(nrfx_usbd_ep_t ep);
165  void nrfx_usbd_ep_disable(nrfx_usbd_ep_t ep);
<span onclick='openModal()' class='match'>166  void nrfx_usbd_ep_default_config(void);
167  nrfx_err_t nrfx_usbd_ep_transfer(nrfx_usbd_ep_t ep,
168                                   nrfx_usbd_transfer_t const * p_transfer);
169  nrfx_err_t nrfx_usbd_ep_handled_transfer(nrfx_usbd_ep_t ep,
</span>170                                           nrfx_usbd_handler_desc_t const * p_handler);
171  void * nrfx_usbd_feeder_buffer_get(void);
172  nrfx_usbd_ep_status_t nrfx_usbd_ep_status_get(nrfx_usbd_ep_t ep, size_t * p_size);
173  size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep);
174  bool nrfx_usbd_ep_is_busy(nrfx_usbd_ep_t ep);
175  void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep);
176  void nrfx_usbd_ep_stall_clear(nrfx_usbd_ep_t ep);
177  bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep);
178  void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep);
179  void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup);
180  void nrfx_usbd_setup_data_clear(void);
181  void nrfx_usbd_setup_clear(void);
182  void nrfx_usbd_setup_stall(void);
183  void nrfx_usbd_ep_abort(nrfx_usbd_ep_t ep);
184  nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void);
185  void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep);
186  void nrfx_usbd_irq_handler(void);
187  #ifdef __cplusplus
188  }
189  #endif
190  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_usbd.h</h3>
            <pre><code>1  #ifndef NRFX_USBD_H__
2  #define NRFX_USBD_H__
3  #include <nrfx.h>
4  #include <hal/nrf_usbd.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  #define NRFX_USBD_EPSIZE 64
9  #define NRFX_USBD_ISOSIZE 1024
10  #define NRFX_USBD_FEEDER_BUFFER_SIZE NRFX_USBD_EPSIZE
11  #define NRFX_USBD_EPIN(n)   ((nrfx_usbd_ep_t)NRF_USBD_EPIN(n))
12  #define NRFX_USBD_EPOUT(n)  ((nrfx_usbd_ep_t)NRF_USBD_EPOUT(n))
13  typedef enum
14  {
15      NRFX_USBD_EPOUT0 = NRF_USBD_EPOUT(0), &bsol;**< Endpoint OUT 0 */
16      NRFX_USBD_EPOUT1 = NRF_USBD_EPOUT(1), &bsol;**< Endpoint OUT 1 */
17      NRFX_USBD_EPOUT2 = NRF_USBD_EPOUT(2), &bsol;**< Endpoint OUT 2 */
18      NRFX_USBD_EPOUT3 = NRF_USBD_EPOUT(3), &bsol;**< Endpoint OUT 3 */
19      NRFX_USBD_EPOUT4 = NRF_USBD_EPOUT(4), &bsol;**< Endpoint OUT 4 */
20      NRFX_USBD_EPOUT5 = NRF_USBD_EPOUT(5), &bsol;**< Endpoint OUT 5 */
21      NRFX_USBD_EPOUT6 = NRF_USBD_EPOUT(6), &bsol;**< Endpoint OUT 6 */
22      NRFX_USBD_EPOUT7 = NRF_USBD_EPOUT(7), &bsol;**< Endpoint OUT 7 */
23      NRFX_USBD_EPOUT8 = NRF_USBD_EPOUT(8), &bsol;**< Endpoint OUT 8 */
24      NRFX_USBD_EPIN0  = NRF_USBD_EPIN(0), &bsol;**< Endpoint IN 0 */
25      NRFX_USBD_EPIN1  = NRF_USBD_EPIN(1), &bsol;**< Endpoint IN 1 */
26      NRFX_USBD_EPIN2  = NRF_USBD_EPIN(2), &bsol;**< Endpoint IN 2 */
27      NRFX_USBD_EPIN3  = NRF_USBD_EPIN(3), &bsol;**< Endpoint IN 3 */
28      NRFX_USBD_EPIN4  = NRF_USBD_EPIN(4), &bsol;**< Endpoint IN 4 */
29      NRFX_USBD_EPIN5  = NRF_USBD_EPIN(5), &bsol;**< Endpoint IN 5 */
30      NRFX_USBD_EPIN6  = NRF_USBD_EPIN(6), &bsol;**< Endpoint IN 6 */
31      NRFX_USBD_EPIN7  = NRF_USBD_EPIN(7), &bsol;**< Endpoint IN 7 */
32      NRFX_USBD_EPIN8  = NRF_USBD_EPIN(8), &bsol;**< Endpoint IN 8 */
33  } nrfx_usbd_ep_t;
34  typedef enum
35  {
36      NRFX_USBD_EVT_SOF,        &bsol;**< Start Of Frame event on USB bus detected. */
37      NRFX_USBD_EVT_RESET,      &bsol;**< Reset condition on USB bus detected. */
38      NRFX_USBD_EVT_SUSPEND,    &bsol;**< This device should go to suspend mode now. */
39      NRFX_USBD_EVT_RESUME,     &bsol;**< This device should resume from suspend now. */
40      NRFX_USBD_EVT_WUREQ,      &bsol;**< Wakeup request - the USBD peripheral is ready to generate
41  	                               WAKEUP signal after exiting low power mode. */
42      NRFX_USBD_EVT_SETUP,      &bsol;**< Setup frame received and decoded. */
43      NRFX_USBD_EVT_EPTRANSFER, &bsol;**< For Rx (OUT: Host->Device):
44                                 *   1. The packet has been received but there is no buffer prepared for transfer already.
45                                 *   2. Whole transfer has been finished.
46                                 *
47                                 *   For Tx (IN: Device->Host):
48                                 *   The last packet from requested transfer has been transfered over USB bus and acknowledged.
49                                 */
50      NRFX_USBD_EVT_CNT         &bsol;**< Number of defined events. */
51  } nrfx_usbd_event_type_t;
52  typedef enum
53  {
54      NRFX_USBD_EP_OK,       &bsol;**< No error occured. */
55      NRFX_USBD_EP_WAITING,  &bsol;**< Data received, no buffer prepared already - waiting for configured transfer. */
56      NRFX_USBD_EP_OVERLOAD, &bsol;**< Received number of bytes cannot fit given buffer.
57                              *   This error would also be returned when next_transfer function has been defined
58                              *   but currently received data cannot fit completely in current buffer.
59                              *   No data split from single endpoint transmission is supported.
60                              *
61                              *   When this error is reported - data is left inside endpoint buffer.
62                              *   Clear endpoint or prepare new buffer and read it.
63                              */
64      NRFX_USBD_EP_ABORTED,  &bsol;**< EP0 transfer can be aborted when new setup comes.
65                              *   Any other transfer can be aborted by USB reset or driver stopping.
66                              */
67      NRFX_USBD_EP_BUSY,     &bsol;**< Transfer is in progress. */
68  } nrfx_usbd_ep_status_t;
69  typedef struct
70  {
71      nrfx_usbd_event_type_t type;          &bsol;**< Event type. */
72      union
73      {
74          struct {
75              uint16_t framecnt;            &bsol;**< Current value of frame counter. */
76          } sof;                            &bsol;**< Data available for @ref NRFX_USBD_EVT_SOF. */
77          struct {
78              nrfx_usbd_ep_t        ep;     &bsol;**< Endpoint number. */
79          } isocrc;                         &bsol;**< Isochronouns channel endpoint number. */
80          struct {
81              nrfx_usbd_ep_t        ep;     &bsol;**< Endpoint number. */
82              nrfx_usbd_ep_status_t status; &bsol;**< Status for the endpoint. */
83          } eptransfer;                     &bsol;**< Endpoint transfer status. */
84      } data;                               &bsol;**< Union to store event data. */
85  } nrfx_usbd_evt_t;
86  typedef void (*nrfx_usbd_event_handler_t)(nrfx_usbd_evt_t const * p_event);
87  typedef union
88  {
89      void const * tx; 
90      void * rx;       
91      uint32_t addr;   
92  } nrfx_usbd_data_ptr_t;
93  typedef struct
94  {
95      nrfx_usbd_data_ptr_t p_data; 
96      size_t size;                 
97  } nrfx_usbd_ep_transfer_t;
98  typedef enum
99  {
100      NRFX_USBD_TRANSFER_ZLP_FLAG = 1U << 0, 
101  } nrfx_usbd_transfer_flags_t;
102  typedef struct
103  {
104      nrfx_usbd_data_ptr_t p_data; 
105      size_t size;                 
106      uint32_t flags;              
107  } nrfx_usbd_transfer_t;
108  #define NRFX_USBD_TRANSFER_IN(name, tx_buff, tx_size, tx_flags) \
109      const nrfx_usbd_transfer_t name = {                         \
110         .p_data = { .tx = (tx_buff)  },                          \
111         .size = (tx_size),                                       \
112         .flags = (tx_flags)                                      \
113      }
114  #define NRFX_USBD_TRANSFER_OUT(name, rx_buff, rx_size) \
115      const nrfx_usbd_transfer_t name = {                \
116         .p_data = { .rx = (rx_buff)  },                 \
117         .size = (rx_size),                              \
118         .flags = 0                                      \
119      }
120  typedef bool (*nrfx_usbd_feeder_t)(nrfx_usbd_ep_transfer_t * p_next,
121                                     void * p_context,
122                                     size_t ep_size);
123  typedef bool (*nrfx_usbd_consumer_t)(nrfx_usbd_ep_transfer_t * p_next,
124                                       void * p_context,
125                                       size_t ep_size,
126                                       size_t data_size);
127  typedef union
128  {
129      nrfx_usbd_feeder_t   feeder;   
130      nrfx_usbd_consumer_t consumer; 
131  } nrfx_usbd_handler_t;
132  typedef struct
133  {
134      nrfx_usbd_handler_t handler;   
135      void *              p_context; 
136  } nrfx_usbd_handler_desc_t;
137  typedef struct
138  {
139      uint8_t  bmRequestType; 
140      uint8_t  bRequest;      
141      uint16_t wValue;        
142      uint16_t wIndex;        
143      uint16_t wLength;       
144  } nrfx_usbd_setup_t;
145  nrfx_err_t nrfx_usbd_init(nrfx_usbd_event_handler_t event_handler);
146  void nrfx_usbd_uninit(void);
147  void nrfx_usbd_enable(void);
148  void nrfx_usbd_disable(void);
149  void nrfx_usbd_start(bool enable_sof);
150  void nrfx_usbd_stop(void);
151  bool nrfx_usbd_is_initialized(void);
152  bool nrfx_usbd_is_enabled(void);
153  bool nrfx_usbd_is_started(void);
154  bool nrfx_usbd_suspend(void);
155  bool nrfx_usbd_wakeup_req(void);
156  bool nrfx_usbd_suspend_check(void);
157  void nrfx_usbd_suspend_irq_config(void);
158  void nrfx_usbd_active_irq_config(void);
159  bool nrfx_usbd_bus_suspend_check(void);
160  void nrfx_usbd_force_bus_wakeup(void);
161  void nrfx_usbd_ep_max_packet_size_set(nrfx_usbd_ep_t ep, uint16_t size);
162  uint16_t nrfx_usbd_ep_max_packet_size_get(nrfx_usbd_ep_t ep);
163  bool nrfx_usbd_ep_enable_check(nrfx_usbd_ep_t ep);
164  void nrfx_usbd_ep_enable(nrfx_usbd_ep_t ep);
165  void nrfx_usbd_ep_disable(nrfx_usbd_ep_t ep);
<span onclick='openModal()' class='match'>166  void nrfx_usbd_ep_default_config(void);
167  nrfx_err_t nrfx_usbd_ep_transfer(nrfx_usbd_ep_t ep,
168                                   nrfx_usbd_transfer_t const * p_transfer);
169  nrfx_err_t nrfx_usbd_ep_handled_transfer(nrfx_usbd_ep_t ep,
</span>170                                           nrfx_usbd_handler_desc_t const * p_handler);
171  void * nrfx_usbd_feeder_buffer_get(void);
172  nrfx_usbd_ep_status_t nrfx_usbd_ep_status_get(nrfx_usbd_ep_t ep, size_t * p_size);
173  size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep);
174  bool nrfx_usbd_ep_is_busy(nrfx_usbd_ep_t ep);
175  void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep);
176  void nrfx_usbd_ep_stall_clear(nrfx_usbd_ep_t ep);
177  bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep);
178  void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep);
179  void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup);
180  void nrfx_usbd_setup_data_clear(void);
181  void nrfx_usbd_setup_clear(void);
182  void nrfx_usbd_setup_stall(void);
183  void nrfx_usbd_ep_abort(nrfx_usbd_ep_t ep);
184  nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void);
185  void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep);
186  void nrfx_usbd_irq_handler(void);
187  #ifdef __cplusplus
188  }
189  #endif
190  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_usbd.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_usbd.h</div>
                </div>
                <div class="column column_space"><pre><code>166  void nrfx_usbd_ep_default_config(void);
167  nrfx_err_t nrfx_usbd_ep_transfer(nrfx_usbd_ep_t ep,
168                                   nrfx_usbd_transfer_t const * p_transfer);
169  nrfx_err_t nrfx_usbd_ep_handled_transfer(nrfx_usbd_ep_t ep,
</pre></code></div>
                <div class="column column_space"><pre><code>166  void nrfx_usbd_ep_default_config(void);
167  nrfx_err_t nrfx_usbd_ep_transfer(nrfx_usbd_ep_t ep,
168                                   nrfx_usbd_transfer_t const * p_transfer);
169  nrfx_err_t nrfx_usbd_ep_handled_transfer(nrfx_usbd_ep_t ep,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    