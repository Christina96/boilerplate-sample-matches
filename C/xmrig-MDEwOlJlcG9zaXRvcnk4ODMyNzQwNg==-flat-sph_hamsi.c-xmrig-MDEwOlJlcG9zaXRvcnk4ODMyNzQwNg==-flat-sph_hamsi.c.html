
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 114, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_hamsi.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include "sph_hamsi.h"
4  #ifdef __cplusplus
5  extern "C"{
6  #endif
7  #if SPH_SMALL_FOOTPRINT && !defined SPH_SMALL_FOOTPRINT_HAMSI
8  #define SPH_SMALL_FOOTPRINT_HAMSI   1
9  #endif
10  #if !defined SPH_HAMSI_EXPAND_SMALL
11  #if SPH_SMALL_FOOTPRINT_HAMSI
12  #define SPH_HAMSI_EXPAND_SMALL  4
13  #else
14  #define SPH_HAMSI_EXPAND_SMALL  8
15  #endif
16  #endif
17  #if !defined SPH_HAMSI_EXPAND_BIG
18  #define SPH_HAMSI_EXPAND_BIG    8
19  #endif
20  #ifdef _MSC_VER
21  #pragma warning (disable: 4146)
22  #endif
23  #include "sph_hamsi_helper.c"
24  static const sph_u32 IV224[] = {
25  	SPH_C32(0xc3967a67), SPH_C32(0xc3bc6c20), SPH_C32(0x4bc3bcc3),
26  	SPH_C32(0xa7c3bc6b), SPH_C32(0x2c204b61), SPH_C32(0x74686f6c),
27  	SPH_C32(0x69656b65), SPH_C32(0x20556e69)
28  };
29  static const sph_u32 IV256[] = {
30  	SPH_C32(0x76657273), SPH_C32(0x69746569), SPH_C32(0x74204c65),
31  	SPH_C32(0x7576656e), SPH_C32(0x2c204465), SPH_C32(0x70617274),
32  	SPH_C32(0x656d656e), SPH_C32(0x7420456c)
33  };
34  static const sph_u32 IV384[] = {
35  	SPH_C32(0x656b7472), SPH_C32(0x6f746563), SPH_C32(0x686e6965),
36  	SPH_C32(0x6b2c2043), SPH_C32(0x6f6d7075), SPH_C32(0x74657220),
37  	SPH_C32(0x53656375), SPH_C32(0x72697479), SPH_C32(0x20616e64),
38  	SPH_C32(0x20496e64), SPH_C32(0x75737472), SPH_C32(0x69616c20),
39  	SPH_C32(0x43727970), SPH_C32(0x746f6772), SPH_C32(0x61706879),
40  	SPH_C32(0x2c204b61)
41  };
42  static const sph_u32 IV512[] = {
43  	SPH_C32(0x73746565), SPH_C32(0x6c706172), SPH_C32(0x6b204172),
44  	SPH_C32(0x656e6265), SPH_C32(0x72672031), SPH_C32(0x302c2062),
45  	SPH_C32(0x75732032), SPH_C32(0x3434362c), SPH_C32(0x20422d33),
46  	SPH_C32(0x30303120), SPH_C32(0x4c657576), SPH_C32(0x656e2d48),
47  	SPH_C32(0x65766572), SPH_C32(0x6c65652c), SPH_C32(0x2042656c),
48  	SPH_C32(0x6769756d)
49  };
50  static const sph_u32 alpha_n[] = {
51  	SPH_C32(0xff00f0f0), SPH_C32(0xccccaaaa), SPH_C32(0xf0f0cccc),
52  	SPH_C32(0xff00aaaa), SPH_C32(0xccccaaaa), SPH_C32(0xf0f0ff00),
53  	SPH_C32(0xaaaacccc), SPH_C32(0xf0f0ff00), SPH_C32(0xf0f0cccc),
54  	SPH_C32(0xaaaaff00), SPH_C32(0xccccff00), SPH_C32(0xaaaaf0f0),
55  	SPH_C32(0xaaaaf0f0), SPH_C32(0xff00cccc), SPH_C32(0xccccf0f0),
56  	SPH_C32(0xff00aaaa), SPH_C32(0xccccaaaa), SPH_C32(0xff00f0f0),
57  	SPH_C32(0xff00aaaa), SPH_C32(0xf0f0cccc), SPH_C32(0xf0f0ff00),
58  	SPH_C32(0xccccaaaa), SPH_C32(0xf0f0ff00), SPH_C32(0xaaaacccc),
59  	SPH_C32(0xaaaaff00), SPH_C32(0xf0f0cccc), SPH_C32(0xaaaaf0f0),
60  	SPH_C32(0xccccff00), SPH_C32(0xff00cccc), SPH_C32(0xaaaaf0f0),
61  	SPH_C32(0xff00aaaa), SPH_C32(0xccccf0f0)
62  };
63  static const sph_u32 alpha_f[] = {
64  	SPH_C32(0xcaf9639c), SPH_C32(0x0ff0f9c0), SPH_C32(0x639c0ff0),
65  	SPH_C32(0xcaf9f9c0), SPH_C32(0x0ff0f9c0), SPH_C32(0x639ccaf9),
66  	SPH_C32(0xf9c00ff0), SPH_C32(0x639ccaf9), SPH_C32(0x639c0ff0),
67  	SPH_C32(0xf9c0caf9), SPH_C32(0x0ff0caf9), SPH_C32(0xf9c0639c),
68  	SPH_C32(0xf9c0639c), SPH_C32(0xcaf90ff0), SPH_C32(0x0ff0639c),
69  	SPH_C32(0xcaf9f9c0), SPH_C32(0x0ff0f9c0), SPH_C32(0xcaf9639c),
70  	SPH_C32(0xcaf9f9c0), SPH_C32(0x639c0ff0), SPH_C32(0x639ccaf9),
71  	SPH_C32(0x0ff0f9c0), SPH_C32(0x639ccaf9), SPH_C32(0xf9c00ff0),
72  	SPH_C32(0xf9c0caf9), SPH_C32(0x639c0ff0), SPH_C32(0xf9c0639c),
73  	SPH_C32(0x0ff0caf9), SPH_C32(0xcaf90ff0), SPH_C32(0xf9c0639c),
74  	SPH_C32(0xcaf9f9c0), SPH_C32(0x0ff0639c)
75  };
76  #define DECL_STATE_SMALL \
77  	sph_u32 c0, c1, c2, c3, c4, c5, c6, c7;
78  #define READ_STATE_SMALL(sc)   do { \
79  		c0 = sc->h[0x0]; \
80  		c1 = sc->h[0x1]; \
81  		c2 = sc->h[0x2]; \
82  		c3 = sc->h[0x3]; \
83  		c4 = sc->h[0x4]; \
84  		c5 = sc->h[0x5]; \
85  		c6 = sc->h[0x6]; \
86  		c7 = sc->h[0x7]; \
87  	} while (0)
88  #define WRITE_STATE_SMALL(sc)   do { \
89  		sc->h[0x0] = c0; \
90  		sc->h[0x1] = c1; \
91  		sc->h[0x2] = c2; \
92  		sc->h[0x3] = c3; \
93  		sc->h[0x4] = c4; \
94  		sc->h[0x5] = c5; \
95  		sc->h[0x6] = c6; \
96  		sc->h[0x7] = c7; \
97  	} while (0)
98  #define s0   m0
99  #define s1   m1
100  #define s2   c0
101  #define s3   c1
102  #define s4   c2
103  #define s5   c3
104  #define s6   m2
105  #define s7   m3
106  #define s8   m4
107  #define s9   m5
108  #define sA   c4
109  #define sB   c5
110  #define sC   c6
111  #define sD   c7
112  #define sE   m6
113  #define sF   m7
114  #define SBOX(a, b, c, d)   do { \
115  		sph_u32 t; \
116  		t = (a); \
117  		(a) &= (c); \
118  		(a) ^= (d); \
119  		(c) ^= (b); \
120  		(c) ^= (a); \
121  		(d) |= t; \
122  		(d) ^= (b); \
123  		t ^= (c); \
124  		(b) = (d); \
125  		(d) |= t; \
126  		(d) ^= (a); \
127  		(a) &= (b); \
128  		t ^= (a); \
129  		(b) ^= (d); \
130  		(b) ^= t; \
131  		(a) = (c); \
132  		(c) = (b); \
133  		(b) = (d); \
134  		(d) = SPH_T32(~t); \
135  	} while (0)
136  #define L(a, b, c, d)   do { \
137  		(a) = SPH_ROTL32(a, 13); \
138  		(c) = SPH_ROTL32(c, 3); \
139  		(b) ^= (a) ^ (c); \
140  		(d) ^= (c) ^ SPH_T32((a) << 3); \
141  		(b) = SPH_ROTL32(b, 1); \
142  		(d) = SPH_ROTL32(d, 7); \
143  		(a) ^= (b) ^ (d); \
144  		(c) ^= (d) ^ SPH_T32((b) << 7); \
145  		(a) = SPH_ROTL32(a, 5); \
146  		(c) = SPH_ROTL32(c, 22); \
147  	} while (0)
148  #define ROUND_SMALL(rc, alpha)   do { \
149  		s0 ^= alpha[0x00]; \
150  		s1 ^= alpha[0x01] ^ (sph_u32)(rc); \
151  		s2 ^= alpha[0x02]; \
152  		s3 ^= alpha[0x03]; \
153  		s4 ^= alpha[0x08]; \
154  		s5 ^= alpha[0x09]; \
155  		s6 ^= alpha[0x0A]; \
156  		s7 ^= alpha[0x0B]; \
157  		s8 ^= alpha[0x10]; \
158  		s9 ^= alpha[0x11]; \
159  		sA ^= alpha[0x12]; \
160  		sB ^= alpha[0x13]; \
161  		sC ^= alpha[0x18]; \
162  		sD ^= alpha[0x19]; \
163  		sE ^= alpha[0x1A]; \
164  		sF ^= alpha[0x1B]; \
165  		SBOX(s0, s4, s8, sC); \
166  		SBOX(s1, s5, s9, sD); \
167  		SBOX(s2, s6, sA, sE); \
168  		SBOX(s3, s7, sB, sF); \
169  		L(s0, s5, sA, sF); \
170  		L(s1, s6, sB, sC); \
171  		L(s2, s7, s8, sD); \
172  		L(s3, s4, s9, sE); \
173  	} while (0)
174  #define P_SMALL   do { \
175  		ROUND_SMALL(0, alpha_n); \
176  		ROUND_SMALL(1, alpha_n); \
177  		ROUND_SMALL(2, alpha_n); \
178  	} while (0)
179  #define PF_SMALL   do { \
180  		ROUND_SMALL(0, alpha_f); \
181  		ROUND_SMALL(1, alpha_f); \
182  		ROUND_SMALL(2, alpha_f); \
183  		ROUND_SMALL(3, alpha_f); \
184  		ROUND_SMALL(4, alpha_f); \
185  		ROUND_SMALL(5, alpha_f); \
186  	} while (0)
187  #define T_SMALL   do { \
188  		 \
189  		c7 = (sc->h[7] ^= sB); \
190  		c6 = (sc->h[6] ^= sA); \
191  		c5 = (sc->h[5] ^= s9); \
192  		c4 = (sc->h[4] ^= s8); \
193  		c3 = (sc->h[3] ^= s3); \
194  		c2 = (sc->h[2] ^= s2); \
195  		c1 = (sc->h[1] ^= s1); \
196  		c0 = (sc->h[0] ^= s0); \
197  	} while (0)
198  static void
199  hamsi_small(sph_hamsi_small_context *sc, const unsigned char *buf, size_t num)
200  {
201  	DECL_STATE_SMALL
202  #if !SPH_64
203  	sph_u32 tmp;
204  #endif
205  #if SPH_64
206  	sc->count += (sph_u64)num << 5;
207  #else
208  	tmp = SPH_T32((sph_u32)num << 5);
209  	sc->count_low = SPH_T32(sc->count_low + tmp);
210  	sc->count_high += (sph_u32)((num >> 13) >> 14);
211  	if (sc->count_low < tmp)
212  		sc->count_high ++;
213  #endif
214  	READ_STATE_SMALL(sc);
215  	while (num -- > 0) {
216  		sph_u32 m0, m1, m2, m3, m4, m5, m6, m7;
217  		INPUT_SMALL;
218  		P_SMALL;
219  		T_SMALL;
220  		buf += 4;
221  	}
222  	WRITE_STATE_SMALL(sc);
223  }
224  static void
225  hamsi_small_final(sph_hamsi_small_context *sc, const unsigned char *buf)
226  {
227  	sph_u32 m0, m1, m2, m3, m4, m5, m6, m7;
228  	DECL_STATE_SMALL
229  	READ_STATE_SMALL(sc);
230  	INPUT_SMALL;
231  	PF_SMALL;
232  	T_SMALL;
233  	WRITE_STATE_SMALL(sc);
234  }
235  static void
236  hamsi_small_init(sph_hamsi_small_context *sc, const sph_u32 *iv)
237  {
238  	sc->partial_len = 0;
239  	memcpy(sc->h, iv, sizeof sc->h);
240  #if SPH_64
241  	sc->count = 0;
242  #else
243  	sc->count_high = sc->count_low = 0;
244  #endif
245  }
246  static void
247  hamsi_small_core(sph_hamsi_small_context *sc, const void *data, size_t len)
248  {
249  	if (sc->partial_len != 0) {
250  		size_t mlen;
251  		mlen = 4 - sc->partial_len;
252  		if (len < mlen) {
253  			memcpy(sc->partial + sc->partial_len, data, len);
254  			sc->partial_len += len;
255  			return;
256  		} else {
257  			memcpy(sc->partial + sc->partial_len, data, mlen);
258  			len -= mlen;
259  			data = (const unsigned char *)data + mlen;
260  			hamsi_small(sc, sc->partial, 1);
<span onclick='openModal()' class='match'>261  			sc->partial_len = 0;
262  		}
263  	}
264  	hamsi_small(sc, data, (len >> 2));
265  	data = (const unsigned char *)data + (len & ~(size_t)3);
266  	len &= (size_t)3;
267  	memcpy(sc->partial, data, len);
268  	sc->partial_len = len;
269  }
270  static void
271  hamsi_small_close(sph_hamsi_small_context *sc,
272  	unsigned ub, unsigned n, void *dst, size_t out_size_w32)
273  {
274  	unsigned char pad[12];
275  	size_t ptr, u;
276  	unsigned z;
277  	unsigned char *out;
278  	ptr = sc->partial_len;
279  	memcpy(pad, sc->partial, ptr);
</span>280  #if SPH_64
281  	sph_enc64be(pad + 4, sc->count + (ptr << 3) + n);
282  #else
283  	sph_enc32be(pad + 4, sc->count_high);
284  	sph_enc32be(pad + 8, sc->count_low + (ptr << 3) + n);
285  #endif
286  	z = 0x80 >> n;
287  	pad[ptr ++] = ((ub & -z) | z) & 0xFF;
288  	while (ptr < 4)
289  		pad[ptr ++] = 0;
290  	hamsi_small(sc, pad, 2);
291  	hamsi_small_final(sc, pad + 8);
292  	out = dst;
293  	for (u = 0; u < out_size_w32; u ++)
294  		sph_enc32be(out + (u << 2), sc->h[u]);
295  }
296  #define DECL_STATE_BIG \
297  	sph_u32 c0, c1, c2, c3, c4, c5, c6, c7; \
298  	sph_u32 c8, c9, cA, cB, cC, cD, cE, cF;
299  #define READ_STATE_BIG(sc)   do { \
300  		c0 = sc->h[0x0]; \
301  		c1 = sc->h[0x1]; \
302  		c2 = sc->h[0x2]; \
303  		c3 = sc->h[0x3]; \
304  		c4 = sc->h[0x4]; \
305  		c5 = sc->h[0x5]; \
306  		c6 = sc->h[0x6]; \
307  		c7 = sc->h[0x7]; \
308  		c8 = sc->h[0x8]; \
309  		c9 = sc->h[0x9]; \
310  		cA = sc->h[0xA]; \
311  		cB = sc->h[0xB]; \
312  		cC = sc->h[0xC]; \
313  		cD = sc->h[0xD]; \
314  		cE = sc->h[0xE]; \
315  		cF = sc->h[0xF]; \
316  	} while (0)
317  #define WRITE_STATE_BIG(sc)   do { \
318  		sc->h[0x0] = c0; \
319  		sc->h[0x1] = c1; \
320  		sc->h[0x2] = c2; \
321  		sc->h[0x3] = c3; \
322  		sc->h[0x4] = c4; \
323  		sc->h[0x5] = c5; \
324  		sc->h[0x6] = c6; \
325  		sc->h[0x7] = c7; \
326  		sc->h[0x8] = c8; \
327  		sc->h[0x9] = c9; \
328  		sc->h[0xA] = cA; \
329  		sc->h[0xB] = cB; \
330  		sc->h[0xC] = cC; \
331  		sc->h[0xD] = cD; \
332  		sc->h[0xE] = cE; \
333  		sc->h[0xF] = cF; \
334  	} while (0)
335  #define s00   m0
336  #define s01   m1
337  #define s02   c0
338  #define s03   c1
339  #define s04   m2
340  #define s05   m3
341  #define s06   c2
342  #define s07   c3
343  #define s08   c4
344  #define s09   c5
345  #define s0A   m4
346  #define s0B   m5
347  #define s0C   c6
348  #define s0D   c7
349  #define s0E   m6
350  #define s0F   m7
351  #define s10   m8
352  #define s11   m9
353  #define s12   c8
354  #define s13   c9
355  #define s14   mA
356  #define s15   mB
357  #define s16   cA
358  #define s17   cB
359  #define s18   cC
360  #define s19   cD
361  #define s1A   mC
362  #define s1B   mD
363  #define s1C   cE
364  #define s1D   cF
365  #define s1E   mE
366  #define s1F   mF
367  #define ROUND_BIG(rc, alpha)   do { \
368  		s00 ^= alpha[0x00]; \
369  		s01 ^= alpha[0x01] ^ (sph_u32)(rc); \
370  		s02 ^= alpha[0x02]; \
371  		s03 ^= alpha[0x03]; \
372  		s04 ^= alpha[0x04]; \
373  		s05 ^= alpha[0x05]; \
374  		s06 ^= alpha[0x06]; \
375  		s07 ^= alpha[0x07]; \
376  		s08 ^= alpha[0x08]; \
377  		s09 ^= alpha[0x09]; \
378  		s0A ^= alpha[0x0A]; \
379  		s0B ^= alpha[0x0B]; \
380  		s0C ^= alpha[0x0C]; \
381  		s0D ^= alpha[0x0D]; \
382  		s0E ^= alpha[0x0E]; \
383  		s0F ^= alpha[0x0F]; \
384  		s10 ^= alpha[0x10]; \
385  		s11 ^= alpha[0x11]; \
386  		s12 ^= alpha[0x12]; \
387  		s13 ^= alpha[0x13]; \
388  		s14 ^= alpha[0x14]; \
389  		s15 ^= alpha[0x15]; \
390  		s16 ^= alpha[0x16]; \
391  		s17 ^= alpha[0x17]; \
392  		s18 ^= alpha[0x18]; \
393  		s19 ^= alpha[0x19]; \
394  		s1A ^= alpha[0x1A]; \
395  		s1B ^= alpha[0x1B]; \
396  		s1C ^= alpha[0x1C]; \
397  		s1D ^= alpha[0x1D]; \
398  		s1E ^= alpha[0x1E]; \
399  		s1F ^= alpha[0x1F]; \
400  		SBOX(s00, s08, s10, s18); \
401  		SBOX(s01, s09, s11, s19); \
402  		SBOX(s02, s0A, s12, s1A); \
403  		SBOX(s03, s0B, s13, s1B); \
404  		SBOX(s04, s0C, s14, s1C); \
405  		SBOX(s05, s0D, s15, s1D); \
406  		SBOX(s06, s0E, s16, s1E); \
407  		SBOX(s07, s0F, s17, s1F); \
408  		L(s00, s09, s12, s1B); \
409  		L(s01, s0A, s13, s1C); \
410  		L(s02, s0B, s14, s1D); \
411  		L(s03, s0C, s15, s1E); \
412  		L(s04, s0D, s16, s1F); \
413  		L(s05, s0E, s17, s18); \
414  		L(s06, s0F, s10, s19); \
415  		L(s07, s08, s11, s1A); \
416  		L(s00, s02, s05, s07); \
417  		L(s10, s13, s15, s16); \
418  		L(s09, s0B, s0C, s0E); \
419  		L(s19, s1A, s1C, s1F); \
420  	} while (0)
421  #if SPH_SMALL_FOOTPRINT_HAMSI
422  #define P_BIG   do { \
423  		unsigned r; \
424  		for (r = 0; r < 6; r ++) \
425  			ROUND_BIG(r, alpha_n); \
426  	} while (0)
427  #define PF_BIG   do { \
428  		unsigned r; \
429  		for (r = 0; r < 12; r ++) \
430  			ROUND_BIG(r, alpha_f); \
431  	} while (0)
432  #else
433  #define P_BIG   do { \
434  		ROUND_BIG(0, alpha_n); \
435  		ROUND_BIG(1, alpha_n); \
436  		ROUND_BIG(2, alpha_n); \
437  		ROUND_BIG(3, alpha_n); \
438  		ROUND_BIG(4, alpha_n); \
439  		ROUND_BIG(5, alpha_n); \
440  	} while (0)
441  #define PF_BIG   do { \
442  		ROUND_BIG(0, alpha_f); \
443  		ROUND_BIG(1, alpha_f); \
444  		ROUND_BIG(2, alpha_f); \
445  		ROUND_BIG(3, alpha_f); \
446  		ROUND_BIG(4, alpha_f); \
447  		ROUND_BIG(5, alpha_f); \
448  		ROUND_BIG(6, alpha_f); \
449  		ROUND_BIG(7, alpha_f); \
450  		ROUND_BIG(8, alpha_f); \
451  		ROUND_BIG(9, alpha_f); \
452  		ROUND_BIG(10, alpha_f); \
453  		ROUND_BIG(11, alpha_f); \
454  	} while (0)
455  #endif
456  #define T_BIG   do { \
457  		 \
458  		cF = (sc->h[0xF] ^= s17); \
459  		cE = (sc->h[0xE] ^= s16); \
460  		cD = (sc->h[0xD] ^= s15); \
461  		cC = (sc->h[0xC] ^= s14); \
462  		cB = (sc->h[0xB] ^= s13); \
463  		cA = (sc->h[0xA] ^= s12); \
464  		c9 = (sc->h[0x9] ^= s11); \
465  		c8 = (sc->h[0x8] ^= s10); \
466  		c7 = (sc->h[0x7] ^= s07); \
467  		c6 = (sc->h[0x6] ^= s06); \
468  		c5 = (sc->h[0x5] ^= s05); \
469  		c4 = (sc->h[0x4] ^= s04); \
470  		c3 = (sc->h[0x3] ^= s03); \
471  		c2 = (sc->h[0x2] ^= s02); \
472  		c1 = (sc->h[0x1] ^= s01); \
473  		c0 = (sc->h[0x0] ^= s00); \
474  	} while (0)
475  static void
476  hamsi_big(sph_hamsi_big_context *sc, const unsigned char *buf, size_t num)
477  {
478  	DECL_STATE_BIG
479  #if !SPH_64
480  	sph_u32 tmp;
481  #endif
482  #if SPH_64
483  	sc->count += (sph_u64)num << 6;
484  #else
485  	tmp = SPH_T32((sph_u32)num << 6);
486  	sc->count_low = SPH_T32(sc->count_low + tmp);
487  	sc->count_high += (sph_u32)((num >> 13) >> 13);
488  	if (sc->count_low < tmp)
489  		sc->count_high ++;
490  #endif
491  	READ_STATE_BIG(sc);
492  	while (num -- > 0) {
493  		sph_u32 m0, m1, m2, m3, m4, m5, m6, m7;
494  		sph_u32 m8, m9, mA, mB, mC, mD, mE, mF;
495  		INPUT_BIG;
496  		P_BIG;
497  		T_BIG;
498  		buf += 8;
499  	}
500  	WRITE_STATE_BIG(sc);
501  }
502  static void
503  hamsi_big_final(sph_hamsi_big_context *sc, const unsigned char *buf)
504  {
505  	sph_u32 m0, m1, m2, m3, m4, m5, m6, m7;
506  	sph_u32 m8, m9, mA, mB, mC, mD, mE, mF;
507  	DECL_STATE_BIG
508  	READ_STATE_BIG(sc);
509  	INPUT_BIG;
510  	PF_BIG;
511  	T_BIG;
512  	WRITE_STATE_BIG(sc);
513  }
514  static void
515  hamsi_big_init(sph_hamsi_big_context *sc, const sph_u32 *iv)
516  {
517  	sc->partial_len = 0;
518  	memcpy(sc->h, iv, sizeof sc->h);
519  #if SPH_64
520  	sc->count = 0;
521  #else
522  	sc->count_high = sc->count_low = 0;
523  #endif
524  }
525  static void
526  hamsi_big_core(sph_hamsi_big_context *sc, const void *data, size_t len)
527  {
528  	if (sc->partial_len != 0) {
529  		size_t mlen;
530  		mlen = 8 - sc->partial_len;
531  		if (len < mlen) {
532  			memcpy(sc->partial + sc->partial_len, data, len);
533  			sc->partial_len += len;
534  			return;
535  		} else {
536  			memcpy(sc->partial + sc->partial_len, data, mlen);
537  			len -= mlen;
538  			data = (const unsigned char *)data + mlen;
539  			hamsi_big(sc, sc->partial, 1);
540  			sc->partial_len = 0;
541  		}
542  	}
543  	hamsi_big(sc, data, (len >> 3));
544  	data = (const unsigned char *)data + (len & ~(size_t)7);
545  	len &= (size_t)7;
546  	memcpy(sc->partial, data, len);
547  	sc->partial_len = len;
548  }
549  static void
550  hamsi_big_close(sph_hamsi_big_context *sc,
551  	unsigned ub, unsigned n, void *dst, size_t out_size_w32)
552  {
553  	unsigned char pad[8];
554  	size_t ptr, u;
555  	unsigned z;
556  	unsigned char *out;
557  	ptr = sc->partial_len;
558  #if SPH_64
559  	sph_enc64be(pad, sc->count + (ptr << 3) + n);
560  #else
561  	sph_enc32be(pad, sc->count_high);
562  	sph_enc32be(pad + 4, sc->count_low + (ptr << 3) + n);
563  #endif
564  	z = 0x80 >> n;
565  	sc->partial[ptr ++] = ((ub & -z) | z) & 0xFF;
566  	while (ptr < 8)
567  		sc->partial[ptr ++] = 0;
568  	hamsi_big(sc, sc->partial, 1);
569  	hamsi_big_final(sc, pad);
570  	out = dst;
571  	if (out_size_w32 == 12) {
572  		sph_enc32be(out +  0, sc->h[ 0]);
573  		sph_enc32be(out +  4, sc->h[ 1]);
574  		sph_enc32be(out +  8, sc->h[ 3]);
575  		sph_enc32be(out + 12, sc->h[ 4]);
576  		sph_enc32be(out + 16, sc->h[ 5]);
577  		sph_enc32be(out + 20, sc->h[ 6]);
578  		sph_enc32be(out + 24, sc->h[ 8]);
579  		sph_enc32be(out + 28, sc->h[ 9]);
580  		sph_enc32be(out + 32, sc->h[10]);
581  		sph_enc32be(out + 36, sc->h[12]);
582  		sph_enc32be(out + 40, sc->h[13]);
583  		sph_enc32be(out + 44, sc->h[15]);
584  	} else {
585  		for (u = 0; u < 16; u ++)
586  			sph_enc32be(out + (u << 2), sc->h[u]);
587  	}
588  }
589  void
590  sph_hamsi224_init(void *cc)
591  {
592  	hamsi_small_init(cc, IV224);
593  }
594  void
595  sph_hamsi224(void *cc, const void *data, size_t len)
596  {
597  	hamsi_small_core(cc, data, len);
598  }
599  void
600  sph_hamsi224_close(void *cc, void *dst)
601  {
602  	hamsi_small_close(cc, 0, 0, dst, 7);
603  }
604  void
605  sph_hamsi224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
606  {
607  	hamsi_small_close(cc, ub, n, dst, 7);
608  }
609  void
610  sph_hamsi256_init(void *cc)
611  {
612  	hamsi_small_init(cc, IV256);
613  }
614  void
615  sph_hamsi256(void *cc, const void *data, size_t len)
616  {
617  	hamsi_small_core(cc, data, len);
618  }
619  void
620  sph_hamsi256_close(void *cc, void *dst)
621  {
622  	hamsi_small_close(cc, 0, 0, dst, 8);
623  }
624  void
625  sph_hamsi256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
626  {
627  	hamsi_small_close(cc, ub, n, dst, 8);
628  }
629  void
630  sph_hamsi384_init(void *cc)
631  {
632  	hamsi_big_init(cc, IV384);
633  }
634  void
635  sph_hamsi384(void *cc, const void *data, size_t len)
636  {
637  	hamsi_big_core(cc, data, len);
638  }
639  void
640  sph_hamsi384_close(void *cc, void *dst)
641  {
642  	hamsi_big_close(cc, 0, 0, dst, 12);
643  }
644  void
645  sph_hamsi384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
646  {
647  	hamsi_big_close(cc, ub, n, dst, 12);
648  }
649  void
650  sph_hamsi512_init(void *cc)
651  {
652  	hamsi_big_init(cc, IV512);
653  }
654  void
655  sph_hamsi512(void *cc, const void *data, size_t len)
656  {
657  	hamsi_big_core(cc, data, len);
658  }
659  void
660  sph_hamsi512_close(void *cc, void *dst)
661  {
662  	hamsi_big_close(cc, 0, 0, dst, 16);
663  }
664  void
665  sph_hamsi512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
666  {
667  	hamsi_big_close(cc, ub, n, dst, 16);
668  }
669  #ifdef __cplusplus
670  }
671  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_hamsi.c</h3>
            <pre><code>1  #include <stddef.h>
2  #include <string.h>
3  #include "sph_hamsi.h"
4  #ifdef __cplusplus
5  extern "C"{
6  #endif
7  #if SPH_SMALL_FOOTPRINT && !defined SPH_SMALL_FOOTPRINT_HAMSI
8  #define SPH_SMALL_FOOTPRINT_HAMSI   1
9  #endif
10  #if !defined SPH_HAMSI_EXPAND_SMALL
11  #if SPH_SMALL_FOOTPRINT_HAMSI
12  #define SPH_HAMSI_EXPAND_SMALL  4
13  #else
14  #define SPH_HAMSI_EXPAND_SMALL  8
15  #endif
16  #endif
17  #if !defined SPH_HAMSI_EXPAND_BIG
18  #define SPH_HAMSI_EXPAND_BIG    8
19  #endif
20  #ifdef _MSC_VER
21  #pragma warning (disable: 4146)
22  #endif
23  #include "sph_hamsi_helper.c"
24  static const sph_u32 IV224[] = {
25  	SPH_C32(0xc3967a67), SPH_C32(0xc3bc6c20), SPH_C32(0x4bc3bcc3),
26  	SPH_C32(0xa7c3bc6b), SPH_C32(0x2c204b61), SPH_C32(0x74686f6c),
27  	SPH_C32(0x69656b65), SPH_C32(0x20556e69)
28  };
29  static const sph_u32 IV256[] = {
30  	SPH_C32(0x76657273), SPH_C32(0x69746569), SPH_C32(0x74204c65),
31  	SPH_C32(0x7576656e), SPH_C32(0x2c204465), SPH_C32(0x70617274),
32  	SPH_C32(0x656d656e), SPH_C32(0x7420456c)
33  };
34  static const sph_u32 IV384[] = {
35  	SPH_C32(0x656b7472), SPH_C32(0x6f746563), SPH_C32(0x686e6965),
36  	SPH_C32(0x6b2c2043), SPH_C32(0x6f6d7075), SPH_C32(0x74657220),
37  	SPH_C32(0x53656375), SPH_C32(0x72697479), SPH_C32(0x20616e64),
38  	SPH_C32(0x20496e64), SPH_C32(0x75737472), SPH_C32(0x69616c20),
39  	SPH_C32(0x43727970), SPH_C32(0x746f6772), SPH_C32(0x61706879),
40  	SPH_C32(0x2c204b61)
41  };
42  static const sph_u32 IV512[] = {
43  	SPH_C32(0x73746565), SPH_C32(0x6c706172), SPH_C32(0x6b204172),
44  	SPH_C32(0x656e6265), SPH_C32(0x72672031), SPH_C32(0x302c2062),
45  	SPH_C32(0x75732032), SPH_C32(0x3434362c), SPH_C32(0x20422d33),
46  	SPH_C32(0x30303120), SPH_C32(0x4c657576), SPH_C32(0x656e2d48),
47  	SPH_C32(0x65766572), SPH_C32(0x6c65652c), SPH_C32(0x2042656c),
48  	SPH_C32(0x6769756d)
49  };
50  static const sph_u32 alpha_n[] = {
51  	SPH_C32(0xff00f0f0), SPH_C32(0xccccaaaa), SPH_C32(0xf0f0cccc),
52  	SPH_C32(0xff00aaaa), SPH_C32(0xccccaaaa), SPH_C32(0xf0f0ff00),
53  	SPH_C32(0xaaaacccc), SPH_C32(0xf0f0ff00), SPH_C32(0xf0f0cccc),
54  	SPH_C32(0xaaaaff00), SPH_C32(0xccccff00), SPH_C32(0xaaaaf0f0),
55  	SPH_C32(0xaaaaf0f0), SPH_C32(0xff00cccc), SPH_C32(0xccccf0f0),
56  	SPH_C32(0xff00aaaa), SPH_C32(0xccccaaaa), SPH_C32(0xff00f0f0),
57  	SPH_C32(0xff00aaaa), SPH_C32(0xf0f0cccc), SPH_C32(0xf0f0ff00),
58  	SPH_C32(0xccccaaaa), SPH_C32(0xf0f0ff00), SPH_C32(0xaaaacccc),
59  	SPH_C32(0xaaaaff00), SPH_C32(0xf0f0cccc), SPH_C32(0xaaaaf0f0),
60  	SPH_C32(0xccccff00), SPH_C32(0xff00cccc), SPH_C32(0xaaaaf0f0),
61  	SPH_C32(0xff00aaaa), SPH_C32(0xccccf0f0)
62  };
63  static const sph_u32 alpha_f[] = {
64  	SPH_C32(0xcaf9639c), SPH_C32(0x0ff0f9c0), SPH_C32(0x639c0ff0),
65  	SPH_C32(0xcaf9f9c0), SPH_C32(0x0ff0f9c0), SPH_C32(0x639ccaf9),
66  	SPH_C32(0xf9c00ff0), SPH_C32(0x639ccaf9), SPH_C32(0x639c0ff0),
67  	SPH_C32(0xf9c0caf9), SPH_C32(0x0ff0caf9), SPH_C32(0xf9c0639c),
68  	SPH_C32(0xf9c0639c), SPH_C32(0xcaf90ff0), SPH_C32(0x0ff0639c),
69  	SPH_C32(0xcaf9f9c0), SPH_C32(0x0ff0f9c0), SPH_C32(0xcaf9639c),
70  	SPH_C32(0xcaf9f9c0), SPH_C32(0x639c0ff0), SPH_C32(0x639ccaf9),
71  	SPH_C32(0x0ff0f9c0), SPH_C32(0x639ccaf9), SPH_C32(0xf9c00ff0),
72  	SPH_C32(0xf9c0caf9), SPH_C32(0x639c0ff0), SPH_C32(0xf9c0639c),
73  	SPH_C32(0x0ff0caf9), SPH_C32(0xcaf90ff0), SPH_C32(0xf9c0639c),
74  	SPH_C32(0xcaf9f9c0), SPH_C32(0x0ff0639c)
75  };
76  #define DECL_STATE_SMALL \
77  	sph_u32 c0, c1, c2, c3, c4, c5, c6, c7;
78  #define READ_STATE_SMALL(sc)   do { \
79  		c0 = sc->h[0x0]; \
80  		c1 = sc->h[0x1]; \
81  		c2 = sc->h[0x2]; \
82  		c3 = sc->h[0x3]; \
83  		c4 = sc->h[0x4]; \
84  		c5 = sc->h[0x5]; \
85  		c6 = sc->h[0x6]; \
86  		c7 = sc->h[0x7]; \
87  	} while (0)
88  #define WRITE_STATE_SMALL(sc)   do { \
89  		sc->h[0x0] = c0; \
90  		sc->h[0x1] = c1; \
91  		sc->h[0x2] = c2; \
92  		sc->h[0x3] = c3; \
93  		sc->h[0x4] = c4; \
94  		sc->h[0x5] = c5; \
95  		sc->h[0x6] = c6; \
96  		sc->h[0x7] = c7; \
97  	} while (0)
98  #define s0   m0
99  #define s1   m1
100  #define s2   c0
101  #define s3   c1
102  #define s4   c2
103  #define s5   c3
104  #define s6   m2
105  #define s7   m3
106  #define s8   m4
107  #define s9   m5
108  #define sA   c4
109  #define sB   c5
110  #define sC   c6
111  #define sD   c7
112  #define sE   m6
113  #define sF   m7
114  #define SBOX(a, b, c, d)   do { \
115  		sph_u32 t; \
116  		t = (a); \
117  		(a) &= (c); \
118  		(a) ^= (d); \
119  		(c) ^= (b); \
120  		(c) ^= (a); \
121  		(d) |= t; \
122  		(d) ^= (b); \
123  		t ^= (c); \
124  		(b) = (d); \
125  		(d) |= t; \
126  		(d) ^= (a); \
127  		(a) &= (b); \
128  		t ^= (a); \
129  		(b) ^= (d); \
130  		(b) ^= t; \
131  		(a) = (c); \
132  		(c) = (b); \
133  		(b) = (d); \
134  		(d) = SPH_T32(~t); \
135  	} while (0)
136  #define L(a, b, c, d)   do { \
137  		(a) = SPH_ROTL32(a, 13); \
138  		(c) = SPH_ROTL32(c, 3); \
139  		(b) ^= (a) ^ (c); \
140  		(d) ^= (c) ^ SPH_T32((a) << 3); \
141  		(b) = SPH_ROTL32(b, 1); \
142  		(d) = SPH_ROTL32(d, 7); \
143  		(a) ^= (b) ^ (d); \
144  		(c) ^= (d) ^ SPH_T32((b) << 7); \
145  		(a) = SPH_ROTL32(a, 5); \
146  		(c) = SPH_ROTL32(c, 22); \
147  	} while (0)
148  #define ROUND_SMALL(rc, alpha)   do { \
149  		s0 ^= alpha[0x00]; \
150  		s1 ^= alpha[0x01] ^ (sph_u32)(rc); \
151  		s2 ^= alpha[0x02]; \
152  		s3 ^= alpha[0x03]; \
153  		s4 ^= alpha[0x08]; \
154  		s5 ^= alpha[0x09]; \
155  		s6 ^= alpha[0x0A]; \
156  		s7 ^= alpha[0x0B]; \
157  		s8 ^= alpha[0x10]; \
158  		s9 ^= alpha[0x11]; \
159  		sA ^= alpha[0x12]; \
160  		sB ^= alpha[0x13]; \
161  		sC ^= alpha[0x18]; \
162  		sD ^= alpha[0x19]; \
163  		sE ^= alpha[0x1A]; \
164  		sF ^= alpha[0x1B]; \
165  		SBOX(s0, s4, s8, sC); \
166  		SBOX(s1, s5, s9, sD); \
167  		SBOX(s2, s6, sA, sE); \
168  		SBOX(s3, s7, sB, sF); \
169  		L(s0, s5, sA, sF); \
170  		L(s1, s6, sB, sC); \
171  		L(s2, s7, s8, sD); \
172  		L(s3, s4, s9, sE); \
173  	} while (0)
174  #define P_SMALL   do { \
175  		ROUND_SMALL(0, alpha_n); \
176  		ROUND_SMALL(1, alpha_n); \
177  		ROUND_SMALL(2, alpha_n); \
178  	} while (0)
179  #define PF_SMALL   do { \
180  		ROUND_SMALL(0, alpha_f); \
181  		ROUND_SMALL(1, alpha_f); \
182  		ROUND_SMALL(2, alpha_f); \
183  		ROUND_SMALL(3, alpha_f); \
184  		ROUND_SMALL(4, alpha_f); \
185  		ROUND_SMALL(5, alpha_f); \
186  	} while (0)
187  #define T_SMALL   do { \
188  		 \
189  		c7 = (sc->h[7] ^= sB); \
190  		c6 = (sc->h[6] ^= sA); \
191  		c5 = (sc->h[5] ^= s9); \
192  		c4 = (sc->h[4] ^= s8); \
193  		c3 = (sc->h[3] ^= s3); \
194  		c2 = (sc->h[2] ^= s2); \
195  		c1 = (sc->h[1] ^= s1); \
196  		c0 = (sc->h[0] ^= s0); \
197  	} while (0)
198  static void
199  hamsi_small(sph_hamsi_small_context *sc, const unsigned char *buf, size_t num)
200  {
201  	DECL_STATE_SMALL
202  #if !SPH_64
203  	sph_u32 tmp;
204  #endif
205  #if SPH_64
206  	sc->count += (sph_u64)num << 5;
207  #else
208  	tmp = SPH_T32((sph_u32)num << 5);
209  	sc->count_low = SPH_T32(sc->count_low + tmp);
210  	sc->count_high += (sph_u32)((num >> 13) >> 14);
211  	if (sc->count_low < tmp)
212  		sc->count_high ++;
213  #endif
214  	READ_STATE_SMALL(sc);
215  	while (num -- > 0) {
216  		sph_u32 m0, m1, m2, m3, m4, m5, m6, m7;
217  		INPUT_SMALL;
218  		P_SMALL;
219  		T_SMALL;
220  		buf += 4;
221  	}
222  	WRITE_STATE_SMALL(sc);
223  }
224  static void
225  hamsi_small_final(sph_hamsi_small_context *sc, const unsigned char *buf)
226  {
227  	sph_u32 m0, m1, m2, m3, m4, m5, m6, m7;
228  	DECL_STATE_SMALL
229  	READ_STATE_SMALL(sc);
230  	INPUT_SMALL;
231  	PF_SMALL;
232  	T_SMALL;
233  	WRITE_STATE_SMALL(sc);
234  }
235  static void
236  hamsi_small_init(sph_hamsi_small_context *sc, const sph_u32 *iv)
237  {
238  	sc->partial_len = 0;
239  	memcpy(sc->h, iv, sizeof sc->h);
240  #if SPH_64
241  	sc->count = 0;
242  #else
243  	sc->count_high = sc->count_low = 0;
244  #endif
245  }
246  static void
247  hamsi_small_core(sph_hamsi_small_context *sc, const void *data, size_t len)
248  {
249  	if (sc->partial_len != 0) {
250  		size_t mlen;
251  		mlen = 4 - sc->partial_len;
252  		if (len < mlen) {
253  			memcpy(sc->partial + sc->partial_len, data, len);
254  			sc->partial_len += len;
255  			return;
256  		} else {
257  			memcpy(sc->partial + sc->partial_len, data, mlen);
258  			len -= mlen;
259  			data = (const unsigned char *)data + mlen;
260  			hamsi_small(sc, sc->partial, 1);
261  			sc->partial_len = 0;
262  		}
263  	}
264  	hamsi_small(sc, data, (len >> 2));
265  	data = (const unsigned char *)data + (len & ~(size_t)3);
266  	len &= (size_t)3;
267  	memcpy(sc->partial, data, len);
268  	sc->partial_len = len;
269  }
270  static void
271  hamsi_small_close(sph_hamsi_small_context *sc,
272  	unsigned ub, unsigned n, void *dst, size_t out_size_w32)
273  {
274  	unsigned char pad[12];
275  	size_t ptr, u;
276  	unsigned z;
277  	unsigned char *out;
278  	ptr = sc->partial_len;
279  	memcpy(pad, sc->partial, ptr);
280  #if SPH_64
281  	sph_enc64be(pad + 4, sc->count + (ptr << 3) + n);
282  #else
283  	sph_enc32be(pad + 4, sc->count_high);
284  	sph_enc32be(pad + 8, sc->count_low + (ptr << 3) + n);
285  #endif
286  	z = 0x80 >> n;
287  	pad[ptr ++] = ((ub & -z) | z) & 0xFF;
288  	while (ptr < 4)
289  		pad[ptr ++] = 0;
290  	hamsi_small(sc, pad, 2);
291  	hamsi_small_final(sc, pad + 8);
292  	out = dst;
293  	for (u = 0; u < out_size_w32; u ++)
294  		sph_enc32be(out + (u << 2), sc->h[u]);
295  }
296  #define DECL_STATE_BIG \
297  	sph_u32 c0, c1, c2, c3, c4, c5, c6, c7; \
298  	sph_u32 c8, c9, cA, cB, cC, cD, cE, cF;
299  #define READ_STATE_BIG(sc)   do { \
300  		c0 = sc->h[0x0]; \
301  		c1 = sc->h[0x1]; \
302  		c2 = sc->h[0x2]; \
303  		c3 = sc->h[0x3]; \
304  		c4 = sc->h[0x4]; \
305  		c5 = sc->h[0x5]; \
306  		c6 = sc->h[0x6]; \
307  		c7 = sc->h[0x7]; \
308  		c8 = sc->h[0x8]; \
309  		c9 = sc->h[0x9]; \
310  		cA = sc->h[0xA]; \
311  		cB = sc->h[0xB]; \
312  		cC = sc->h[0xC]; \
313  		cD = sc->h[0xD]; \
314  		cE = sc->h[0xE]; \
315  		cF = sc->h[0xF]; \
316  	} while (0)
317  #define WRITE_STATE_BIG(sc)   do { \
318  		sc->h[0x0] = c0; \
319  		sc->h[0x1] = c1; \
320  		sc->h[0x2] = c2; \
321  		sc->h[0x3] = c3; \
322  		sc->h[0x4] = c4; \
323  		sc->h[0x5] = c5; \
324  		sc->h[0x6] = c6; \
325  		sc->h[0x7] = c7; \
326  		sc->h[0x8] = c8; \
327  		sc->h[0x9] = c9; \
328  		sc->h[0xA] = cA; \
329  		sc->h[0xB] = cB; \
330  		sc->h[0xC] = cC; \
331  		sc->h[0xD] = cD; \
332  		sc->h[0xE] = cE; \
333  		sc->h[0xF] = cF; \
334  	} while (0)
335  #define s00   m0
336  #define s01   m1
337  #define s02   c0
338  #define s03   c1
339  #define s04   m2
340  #define s05   m3
341  #define s06   c2
342  #define s07   c3
343  #define s08   c4
344  #define s09   c5
345  #define s0A   m4
346  #define s0B   m5
347  #define s0C   c6
348  #define s0D   c7
349  #define s0E   m6
350  #define s0F   m7
351  #define s10   m8
352  #define s11   m9
353  #define s12   c8
354  #define s13   c9
355  #define s14   mA
356  #define s15   mB
357  #define s16   cA
358  #define s17   cB
359  #define s18   cC
360  #define s19   cD
361  #define s1A   mC
362  #define s1B   mD
363  #define s1C   cE
364  #define s1D   cF
365  #define s1E   mE
366  #define s1F   mF
367  #define ROUND_BIG(rc, alpha)   do { \
368  		s00 ^= alpha[0x00]; \
369  		s01 ^= alpha[0x01] ^ (sph_u32)(rc); \
370  		s02 ^= alpha[0x02]; \
371  		s03 ^= alpha[0x03]; \
372  		s04 ^= alpha[0x04]; \
373  		s05 ^= alpha[0x05]; \
374  		s06 ^= alpha[0x06]; \
375  		s07 ^= alpha[0x07]; \
376  		s08 ^= alpha[0x08]; \
377  		s09 ^= alpha[0x09]; \
378  		s0A ^= alpha[0x0A]; \
379  		s0B ^= alpha[0x0B]; \
380  		s0C ^= alpha[0x0C]; \
381  		s0D ^= alpha[0x0D]; \
382  		s0E ^= alpha[0x0E]; \
383  		s0F ^= alpha[0x0F]; \
384  		s10 ^= alpha[0x10]; \
385  		s11 ^= alpha[0x11]; \
386  		s12 ^= alpha[0x12]; \
387  		s13 ^= alpha[0x13]; \
388  		s14 ^= alpha[0x14]; \
389  		s15 ^= alpha[0x15]; \
390  		s16 ^= alpha[0x16]; \
391  		s17 ^= alpha[0x17]; \
392  		s18 ^= alpha[0x18]; \
393  		s19 ^= alpha[0x19]; \
394  		s1A ^= alpha[0x1A]; \
395  		s1B ^= alpha[0x1B]; \
396  		s1C ^= alpha[0x1C]; \
397  		s1D ^= alpha[0x1D]; \
398  		s1E ^= alpha[0x1E]; \
399  		s1F ^= alpha[0x1F]; \
400  		SBOX(s00, s08, s10, s18); \
401  		SBOX(s01, s09, s11, s19); \
402  		SBOX(s02, s0A, s12, s1A); \
403  		SBOX(s03, s0B, s13, s1B); \
404  		SBOX(s04, s0C, s14, s1C); \
405  		SBOX(s05, s0D, s15, s1D); \
406  		SBOX(s06, s0E, s16, s1E); \
407  		SBOX(s07, s0F, s17, s1F); \
408  		L(s00, s09, s12, s1B); \
409  		L(s01, s0A, s13, s1C); \
410  		L(s02, s0B, s14, s1D); \
411  		L(s03, s0C, s15, s1E); \
412  		L(s04, s0D, s16, s1F); \
413  		L(s05, s0E, s17, s18); \
414  		L(s06, s0F, s10, s19); \
415  		L(s07, s08, s11, s1A); \
416  		L(s00, s02, s05, s07); \
417  		L(s10, s13, s15, s16); \
418  		L(s09, s0B, s0C, s0E); \
419  		L(s19, s1A, s1C, s1F); \
420  	} while (0)
421  #if SPH_SMALL_FOOTPRINT_HAMSI
422  #define P_BIG   do { \
423  		unsigned r; \
424  		for (r = 0; r < 6; r ++) \
425  			ROUND_BIG(r, alpha_n); \
426  	} while (0)
427  #define PF_BIG   do { \
428  		unsigned r; \
429  		for (r = 0; r < 12; r ++) \
430  			ROUND_BIG(r, alpha_f); \
431  	} while (0)
432  #else
433  #define P_BIG   do { \
434  		ROUND_BIG(0, alpha_n); \
435  		ROUND_BIG(1, alpha_n); \
436  		ROUND_BIG(2, alpha_n); \
437  		ROUND_BIG(3, alpha_n); \
438  		ROUND_BIG(4, alpha_n); \
439  		ROUND_BIG(5, alpha_n); \
440  	} while (0)
441  #define PF_BIG   do { \
442  		ROUND_BIG(0, alpha_f); \
443  		ROUND_BIG(1, alpha_f); \
444  		ROUND_BIG(2, alpha_f); \
445  		ROUND_BIG(3, alpha_f); \
446  		ROUND_BIG(4, alpha_f); \
447  		ROUND_BIG(5, alpha_f); \
448  		ROUND_BIG(6, alpha_f); \
449  		ROUND_BIG(7, alpha_f); \
450  		ROUND_BIG(8, alpha_f); \
451  		ROUND_BIG(9, alpha_f); \
452  		ROUND_BIG(10, alpha_f); \
453  		ROUND_BIG(11, alpha_f); \
454  	} while (0)
455  #endif
456  #define T_BIG   do { \
457  		 \
458  		cF = (sc->h[0xF] ^= s17); \
459  		cE = (sc->h[0xE] ^= s16); \
460  		cD = (sc->h[0xD] ^= s15); \
461  		cC = (sc->h[0xC] ^= s14); \
462  		cB = (sc->h[0xB] ^= s13); \
463  		cA = (sc->h[0xA] ^= s12); \
464  		c9 = (sc->h[0x9] ^= s11); \
465  		c8 = (sc->h[0x8] ^= s10); \
466  		c7 = (sc->h[0x7] ^= s07); \
467  		c6 = (sc->h[0x6] ^= s06); \
468  		c5 = (sc->h[0x5] ^= s05); \
469  		c4 = (sc->h[0x4] ^= s04); \
470  		c3 = (sc->h[0x3] ^= s03); \
471  		c2 = (sc->h[0x2] ^= s02); \
472  		c1 = (sc->h[0x1] ^= s01); \
473  		c0 = (sc->h[0x0] ^= s00); \
474  	} while (0)
475  static void
476  hamsi_big(sph_hamsi_big_context *sc, const unsigned char *buf, size_t num)
477  {
478  	DECL_STATE_BIG
479  #if !SPH_64
480  	sph_u32 tmp;
481  #endif
482  #if SPH_64
483  	sc->count += (sph_u64)num << 6;
484  #else
485  	tmp = SPH_T32((sph_u32)num << 6);
486  	sc->count_low = SPH_T32(sc->count_low + tmp);
487  	sc->count_high += (sph_u32)((num >> 13) >> 13);
488  	if (sc->count_low < tmp)
489  		sc->count_high ++;
490  #endif
491  	READ_STATE_BIG(sc);
492  	while (num -- > 0) {
493  		sph_u32 m0, m1, m2, m3, m4, m5, m6, m7;
494  		sph_u32 m8, m9, mA, mB, mC, mD, mE, mF;
495  		INPUT_BIG;
496  		P_BIG;
497  		T_BIG;
498  		buf += 8;
499  	}
500  	WRITE_STATE_BIG(sc);
501  }
502  static void
503  hamsi_big_final(sph_hamsi_big_context *sc, const unsigned char *buf)
504  {
505  	sph_u32 m0, m1, m2, m3, m4, m5, m6, m7;
506  	sph_u32 m8, m9, mA, mB, mC, mD, mE, mF;
507  	DECL_STATE_BIG
508  	READ_STATE_BIG(sc);
509  	INPUT_BIG;
510  	PF_BIG;
511  	T_BIG;
512  	WRITE_STATE_BIG(sc);
513  }
514  static void
515  hamsi_big_init(sph_hamsi_big_context *sc, const sph_u32 *iv)
516  {
517  	sc->partial_len = 0;
518  	memcpy(sc->h, iv, sizeof sc->h);
519  #if SPH_64
520  	sc->count = 0;
521  #else
522  	sc->count_high = sc->count_low = 0;
523  #endif
524  }
525  static void
526  hamsi_big_core(sph_hamsi_big_context *sc, const void *data, size_t len)
527  {
528  	if (sc->partial_len != 0) {
529  		size_t mlen;
530  		mlen = 8 - sc->partial_len;
531  		if (len < mlen) {
532  			memcpy(sc->partial + sc->partial_len, data, len);
533  			sc->partial_len += len;
534  			return;
535  		} else {
536  			memcpy(sc->partial + sc->partial_len, data, mlen);
537  			len -= mlen;
538  			data = (const unsigned char *)data + mlen;
539  			hamsi_big(sc, sc->partial, 1);
<span onclick='openModal()' class='match'>540  			sc->partial_len = 0;
541  		}
542  	}
543  	hamsi_big(sc, data, (len >> 3));
544  	data = (const unsigned char *)data + (len & ~(size_t)7);
545  	len &= (size_t)7;
546  	memcpy(sc->partial, data, len);
547  	sc->partial_len = len;
548  }
549  static void
550  hamsi_big_close(sph_hamsi_big_context *sc,
551  	unsigned ub, unsigned n, void *dst, size_t out_size_w32)
552  {
553  	unsigned char pad[8];
554  	size_t ptr, u;
555  	unsigned z;
556  	unsigned char *out;
557  	ptr = sc->partial_len;
558  #if SPH_64
</span>559  	sph_enc64be(pad, sc->count + (ptr << 3) + n);
560  #else
561  	sph_enc32be(pad, sc->count_high);
562  	sph_enc32be(pad + 4, sc->count_low + (ptr << 3) + n);
563  #endif
564  	z = 0x80 >> n;
565  	sc->partial[ptr ++] = ((ub & -z) | z) & 0xFF;
566  	while (ptr < 8)
567  		sc->partial[ptr ++] = 0;
568  	hamsi_big(sc, sc->partial, 1);
569  	hamsi_big_final(sc, pad);
570  	out = dst;
571  	if (out_size_w32 == 12) {
572  		sph_enc32be(out +  0, sc->h[ 0]);
573  		sph_enc32be(out +  4, sc->h[ 1]);
574  		sph_enc32be(out +  8, sc->h[ 3]);
575  		sph_enc32be(out + 12, sc->h[ 4]);
576  		sph_enc32be(out + 16, sc->h[ 5]);
577  		sph_enc32be(out + 20, sc->h[ 6]);
578  		sph_enc32be(out + 24, sc->h[ 8]);
579  		sph_enc32be(out + 28, sc->h[ 9]);
580  		sph_enc32be(out + 32, sc->h[10]);
581  		sph_enc32be(out + 36, sc->h[12]);
582  		sph_enc32be(out + 40, sc->h[13]);
583  		sph_enc32be(out + 44, sc->h[15]);
584  	} else {
585  		for (u = 0; u < 16; u ++)
586  			sph_enc32be(out + (u << 2), sc->h[u]);
587  	}
588  }
589  void
590  sph_hamsi224_init(void *cc)
591  {
592  	hamsi_small_init(cc, IV224);
593  }
594  void
595  sph_hamsi224(void *cc, const void *data, size_t len)
596  {
597  	hamsi_small_core(cc, data, len);
598  }
599  void
600  sph_hamsi224_close(void *cc, void *dst)
601  {
602  	hamsi_small_close(cc, 0, 0, dst, 7);
603  }
604  void
605  sph_hamsi224_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
606  {
607  	hamsi_small_close(cc, ub, n, dst, 7);
608  }
609  void
610  sph_hamsi256_init(void *cc)
611  {
612  	hamsi_small_init(cc, IV256);
613  }
614  void
615  sph_hamsi256(void *cc, const void *data, size_t len)
616  {
617  	hamsi_small_core(cc, data, len);
618  }
619  void
620  sph_hamsi256_close(void *cc, void *dst)
621  {
622  	hamsi_small_close(cc, 0, 0, dst, 8);
623  }
624  void
625  sph_hamsi256_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
626  {
627  	hamsi_small_close(cc, ub, n, dst, 8);
628  }
629  void
630  sph_hamsi384_init(void *cc)
631  {
632  	hamsi_big_init(cc, IV384);
633  }
634  void
635  sph_hamsi384(void *cc, const void *data, size_t len)
636  {
637  	hamsi_big_core(cc, data, len);
638  }
639  void
640  sph_hamsi384_close(void *cc, void *dst)
641  {
642  	hamsi_big_close(cc, 0, 0, dst, 12);
643  }
644  void
645  sph_hamsi384_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
646  {
647  	hamsi_big_close(cc, ub, n, dst, 12);
648  }
649  void
650  sph_hamsi512_init(void *cc)
651  {
652  	hamsi_big_init(cc, IV512);
653  }
654  void
655  sph_hamsi512(void *cc, const void *data, size_t len)
656  {
657  	hamsi_big_core(cc, data, len);
658  }
659  void
660  sph_hamsi512_close(void *cc, void *dst)
661  {
662  	hamsi_big_close(cc, 0, 0, dst, 16);
663  }
664  void
665  sph_hamsi512_addbits_and_close(void *cc, unsigned ub, unsigned n, void *dst)
666  {
667  	hamsi_big_close(cc, ub, n, dst, 16);
668  }
669  #ifdef __cplusplus
670  }
671  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_hamsi.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-sph_hamsi.c</div>
                </div>
                <div class="column column_space"><pre><code>261  			sc->partial_len = 0;
262  		}
263  	}
264  	hamsi_small(sc, data, (len >> 2));
265  	data = (const unsigned char *)data + (len & ~(size_t)3);
266  	len &= (size_t)3;
267  	memcpy(sc->partial, data, len);
268  	sc->partial_len = len;
269  }
270  static void
271  hamsi_small_close(sph_hamsi_small_context *sc,
272  	unsigned ub, unsigned n, void *dst, size_t out_size_w32)
273  {
274  	unsigned char pad[12];
275  	size_t ptr, u;
276  	unsigned z;
277  	unsigned char *out;
278  	ptr = sc->partial_len;
279  	memcpy(pad, sc->partial, ptr);
</pre></code></div>
                <div class="column column_space"><pre><code>540  			sc->partial_len = 0;
541  		}
542  	}
543  	hamsi_big(sc, data, (len >> 3));
544  	data = (const unsigned char *)data + (len & ~(size_t)7);
545  	len &= (size_t)7;
546  	memcpy(sc->partial, data, len);
547  	sc->partial_len = len;
548  }
549  static void
550  hamsi_big_close(sph_hamsi_big_context *sc,
551  	unsigned ub, unsigned n, void *dst, size_t out_size_w32)
552  {
553  	unsigned char pad[8];
554  	size_t ptr, u;
555  	unsigned z;
556  	unsigned char *out;
557  	ptr = sc->partial_len;
558  #if SPH_64
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    