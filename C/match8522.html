<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for sRGB2scRGB.c &amp; min.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for sRGB2scRGB.c &amp; min.c
      </h3>
<h1 align="center">
        13.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>sRGB2scRGB.c (14.035088%)<th>min.c (13.675214%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(264-281)<td><a href="#" name="0">(417-434)</a><td align="center"><font color="#ff0000">18</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(101-111)<td><a href="#" name="1">(174-185)</a><td align="center"><font color="#c60000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>sRGB2scRGB.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;math.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include "pcolour.h"
8 typedef struct _VipssRGB2scRGB {
9 	VipsOperation parent_instance;
10 	VipsImage *in;
11 	VipsImage *out;
12 } VipssRGB2scRGB; 
13 typedef VipsOperationClass VipssRGB2scRGBClass;
14 G_DEFINE_TYPE( VipssRGB2scRGB, vips_sRGB2scRGB, VIPS_TYPE_OPERATION );
15 static void
16 vips_sRGB2scRGB_line_8( float * restrict q, VipsPel * restrict p, 
17 	int extra_bands, int width )
18 {
19 	int i, j;
20 	if( extra_bands == 0 ) {
21 		for( i = 0; i &lt; width; i++ ) {
22 			q[0] = vips_v2Y_8[p[0]];
23 			q[1] = vips_v2Y_8[p[1]];
24 			q[2] = vips_v2Y_8[p[2]];
25 			p += 3;
26 			q += 3;
27 		}
28 	}
29 	else if( extra_bands == 1 ) {
30 		for( i = 0; i &lt; width; i++ ) {
31 <a name="1"></a>			q[0] = vips_v2Y_8[p[0]];
32 			q[1] = vips_v2Y_8[p[1]];
33 			q[2] = vips_v2Y_8[p[2]];
34 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>			q[3] = p[3];
35 			p += 4;
36 			q += 4;
37 		}
38 	}
39 	else {
40 		for( i = 0; i &lt; width; i++ ) {
41 			q[0] = vips_v2Y_8[p[0]];
42 			q[1] = vips_v2Y_8[p[1]];
43 			q[2] = vips_v2Y_8[p[2]];</b></font>
44 			p += 3;
45 			q += 3;
46 			for( j = 0; j &lt; extra_bands; j++ )
47 				q[j] = p[j];
48 			p += extra_bands;
49 			q += extra_bands;
50 		}
51 	}
52 }
53 static void
54 vips_sRGB2scRGB_line_16( float * restrict q, unsigned short * restrict p, 
55 	int extra_bands, int width )
56 {
57 	int i, j;
58 	if( extra_bands == 0 ) {
59 		for( i = 0; i &lt; width; i++ ) {
60 			q[0] = vips_v2Y_16[p[0]];
61 			q[1] = vips_v2Y_16[p[1]];
62 			q[2] = vips_v2Y_16[p[2]];
63 			p += 3;
64 			q += 3;
65 		}
66 	}
67 	else if( extra_bands == 1 ) {
68 		for( i = 0; i &lt; width; i++ ) {
69 			q[0] = vips_v2Y_16[p[0]];
70 			q[1] = vips_v2Y_16[p[1]];
71 			q[2] = vips_v2Y_16[p[2]];
72 			q[3] = p[3] / 256.0;
73 			p += 4;
74 			q += 4;
75 		}
76 	}
77 	else {
78 		for( i = 0; i &lt; width; i++ ) {
79 			q[0] = vips_v2Y_16[p[0]];
80 			q[1] = vips_v2Y_16[p[1]];
81 			q[2] = vips_v2Y_16[p[2]];
82 			p += 3;
83 			q += 3;
84 			for( j = 0; j &lt; extra_bands; j++ )
85 				q[j] = p[j] / 256.0;
86 			p += extra_bands;
87 			q += extra_bands;
88 		}
89 	}
90 }
91 static int
92 vips_sRGB2scRGB_gen( VipsRegion *or, 
93 	void *seq, void *a, void *b, gboolean *stop )
94 {
95 	VipsRegion *ir = (VipsRegion *) seq;
96 	VipsRect *r = &amp;or-&gt;valid;
97 	VipsImage *in = ir-&gt;im;
98 	int y;
99 	if( vips_region_prepare( ir, r ) ) 
100 		return( -1 );
101 	VIPS_GATE_START( "vips_sRGB2scRGB_gen: work" ); 
102 	if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR ) {
103 		vips_col_make_tables_RGB_8();
104 		for( y = 0; y &lt; r-&gt;height; y++ ) {
105 			VipsPel *p = VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y );
106 			float *q = (float *)
107 				VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );
108 			vips_sRGB2scRGB_line_8( q, p, in-&gt;Bands - 3, r-&gt;width );
109 		}
110 	}
111 	else {
112 		vips_col_make_tables_RGB_16();
113 		for( y = 0; y &lt; r-&gt;height; y++ ) {
114 			VipsPel *p = VIPS_REGION_ADDR( ir, r-&gt;left, r-&gt;top + y );
115 			float *q = (float *)
116 				VIPS_REGION_ADDR( or, r-&gt;left, r-&gt;top + y );
117 			vips_sRGB2scRGB_line_16( q, (unsigned short *) p, 
118 				in-&gt;Bands - 3, r-&gt;width );
119 		}
120 	}
121 	VIPS_GATE_STOP( "vips_sRGB2scRGB_gen: work" ); 
122 	return( 0 );
123 }
124 static int
125 vips_sRGB2scRGB_build( VipsObject *object )
126 {
127 	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( object ); 
128 	VipssRGB2scRGB *sRGB2scRGB = (VipssRGB2scRGB *) object;
129 	VipsImage **t = (VipsImage **) vips_object_local_array( object, 2 );
130 	VipsImage *in;
131 	VipsImage *out;
132 	VipsBandFormat format;
133 	if( VIPS_OBJECT_CLASS( vips_sRGB2scRGB_parent_class )-&gt;
134 		build( object ) )
135 		return( -1 );
136 	in = sRGB2scRGB-&gt;in;
137 	if( vips_check_bands_atleast( class-&gt;nickname, in, 3 ) )
138 		return( -1 ); 
139 	format = in-&gt;Type == VIPS_INTERPRETATION_RGB16 ?
140 		VIPS_FORMAT_USHORT : VIPS_FORMAT_UCHAR;
141 	if( in-&gt;BandFmt != format ) {
142 		if( vips_cast( in, &amp;t[0], format, NULL ) )
143 			return( -1 );
144 	}
145 	else {
146 		t[0] = in;
147 		g_object_ref( t[0] ); 
148 	}
149 	in = t[0];
150 	out = vips_image_new();
151 	if( vips_image_pipelinev( out, 
152 		VIPS_DEMAND_STYLE_THINSTRIP, in, NULL ) ) {
153 		g_object_unref( out );
154 		return( -1 );
155 	}
156 	out-&gt;Type = VIPS_INTERPRETATION_scRGB;
157 	out-&gt;BandFmt = VIPS_FORMAT_FLOAT;
158 	if( vips_image_generate( out,
159 		vips_start_one, vips_sRGB2scRGB_gen, vips_stop_one, 
160 		in, sRGB2scRGB ) ) {
161 		g_object_unref( out );
162 		return( -1 );
163 	}
164 <a name="0"></a>
165 	g_object_set( object, "out", out, NULL ); 
166 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
167 }
168 static void
169 vips_sRGB2scRGB_class_init( VipssRGB2scRGBClass *class )
170 {
171 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
172 	VipsObjectClass *object_class = (VipsObjectClass *) class;
173 	VipsOperationClass *operation_class = VIPS_OPERATION_CLASS( class );
174 	gobject_class-&gt;set_property = vips_object_set_property;
175 	gobject_class-&gt;get_property = vips_object_get_property;
176 	object_class-&gt;nickname = "sRGB2scRGB";
177 	object_class-&gt;description = _( "convert an sRGB image to scRGB" );
178 	object_class-&gt;build = vips_sRGB2scRGB_build;
179 	operation_class-&gt;flags = VIPS_OPERATION_SEQUENTIAL;</b></font>
180 	VIPS_ARG_IMAGE( class, "in", 1, 
181 		_( "Input" ), 
182 		_( "Input image" ),
183 		VIPS_ARGUMENT_REQUIRED_INPUT, 
184 		G_STRUCT_OFFSET( VipssRGB2scRGB, in ) );
185 	VIPS_ARG_IMAGE( class, "out", 100, 
186 		_( "Output" ), 
187 		_( "Output image" ),
188 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
189 		G_STRUCT_OFFSET( VipssRGB2scRGB, out ) );
190 }
191 static void
192 vips_sRGB2scRGB_init( VipssRGB2scRGB *sRGB2scRGB )
193 {
194 }
195 int
196 vips_sRGB2scRGB( VipsImage *in, VipsImage **out, ... )
197 {
198 	va_list ap;
199 	int result;
200 	va_start( ap, out );
201 	result = vips_call_split( "sRGB2scRGB", ap, in, out );
202 	va_end( ap );
203 	return( result );
204 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>min.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;limits.h&gt;
8 #include &lt;vips/vips.h&gt;
9 #include &lt;vips/internal.h&gt;
10 #include "statistic.h"
11 typedef struct _VipsValues {
12 	struct _VipsMin *min;
13 	int size;
14 	int n;
15 	double *value;
16 	int *x_pos;
17 	int *y_pos;
18 } VipsValues;
19 typedef struct _VipsMin {
20 	VipsStatistic parent_instance;
21 	int size;
22 	double min;
23 	int x;
24 	int y;
25 	VipsArrayDouble *min_array;
26 	VipsArrayInt *x_array;
27 	VipsArrayInt *y_array;
28 	VipsValues values;
29 } VipsMin;
30 static void
31 vips_values_init( VipsValues *values, VipsMin *min )
32 {
33 	values-&gt;min = min;
34 	values-&gt;size = min-&gt;size;
35 	values-&gt;n = 0;
36 	values-&gt;value = VIPS_ARRAY( min, values-&gt;size, double );
37 	values-&gt;x_pos = VIPS_ARRAY( min, values-&gt;size, int );
38 	values-&gt;y_pos = VIPS_ARRAY( min, values-&gt;size, int );
39 }
40 static void
41 vips_values_add( VipsValues *values, double v, int x, int y )
42 {
43 	int i, j;
44 	for( i = 0; i &lt; values-&gt;n; i++ ) {
45 		if( v &gt; values-&gt;value[i] ) 
46 			break;
47 		if( v == values-&gt;value[i] ) {
48 			if( y &lt; values-&gt;y_pos[i] )
49 				break;
50 			if( y == values-&gt;y_pos[i] )
51 				if( x &lt;= values-&gt;x_pos[i] )
52 					break;
53 		}
54 	}
55 	if( values-&gt;n == values-&gt;size ) {
56 		if( i &gt; 0 ) {
57 			for( j = 0; j &lt; i - 1; j++ ) {
58 				values-&gt;value[j] = values-&gt;value[j + 1];
59 <a name="1"></a>				values-&gt;x_pos[j] = values-&gt;x_pos[j + 1];
60 				values-&gt;y_pos[j] = values-&gt;y_pos[j + 1];
61 			}
62 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>			values-&gt;value[i - 1] = v;
63 			values-&gt;x_pos[i - 1] = x;
64 			values-&gt;y_pos[i - 1] = y;
65 		}
66 	}
67 	else {
68 		for( j = values-&gt;n; j &gt; i; j-- ) {
69 			values-&gt;value[j] = values-&gt;value[j - 1];
70 			values-&gt;x_pos[j] = values-&gt;x_pos[j - 1];
71 			values-&gt;y_pos[j] = values-&gt;y_pos[j - 1];</b></font>
72 		}
73 		values-&gt;value[i] = v;
74 		values-&gt;x_pos[i] = x;
75 		values-&gt;y_pos[i] = y;
76 		values-&gt;n += 1;
77 	}
78 }
79 typedef VipsStatisticClass VipsMinClass;
80 G_DEFINE_TYPE( VipsMin, vips_min, VIPS_TYPE_STATISTIC );
81 static int
82 vips_min_build( VipsObject *object )
83 {
84 	VipsStatistic *statistic = VIPS_STATISTIC( object ); 
85 	VipsMin *min = (VipsMin *) object;
86 	VipsValues *values = &amp;min-&gt;values;
87 	vips_values_init( values, min );
88 	if( VIPS_OBJECT_CLASS( vips_min_parent_class )-&gt;build( object ) )
89 		return( -1 );
90 	if( vips_band_format_iscomplex( 
91 		vips_image_get_format( statistic-&gt;in ) ) ) {
92 		int i;
93 		for( i = 0; i &lt; values-&gt;n; i++ ) 
94 			values-&gt;value[i] = sqrt( values-&gt;value[i] );
95 	}
96 	if( values-&gt;n &gt; 0 ) {
97 		VipsArrayDouble *out_array;
98 		VipsArrayInt *x_array;
99 		VipsArrayInt *y_array;
100 		out_array = vips_array_double_new( values-&gt;value, values-&gt;n );
101 		x_array = vips_array_int_new( values-&gt;x_pos, values-&gt;n );
102 		y_array = vips_array_int_new( values-&gt;y_pos, values-&gt;n );
103 		g_object_set( min, 
104 			"out", values-&gt;value[values-&gt;n - 1],
105 			"x", values-&gt;x_pos[values-&gt;n - 1],
106 			"y", values-&gt;y_pos[values-&gt;n - 1],
107 			"out_array", out_array,
108 			"x_array", x_array,
109 			"y_array", y_array,
110 			NULL );
111 		vips_area_unref( VIPS_AREA( out_array ) );
112 		vips_area_unref( VIPS_AREA( x_array ) );
113 		vips_area_unref( VIPS_AREA( y_array ) );
114 	}
115 #ifdef DEBUG
116 {	
117 	int i;
118 	printf( "vips_min_build: %d values found\n", values-&gt;n );
119 	for( i = 0; i &lt; values-&gt;n; i++ )
120 		printf( "%d) %g\t%d\t%d\n", 
121 			i, 
122 			values-&gt;value[i], 
123 			values-&gt;x_pos[i], values-&gt;y_pos[i] ); 
124 }
125 	return( 0 );
126 }
127 static void *
128 vips_min_start( VipsStatistic *statistic )
129 {
130 	VipsValues *values;
131 	values = g_new( VipsValues, 1 );
132 	vips_values_init( values, (VipsMin *) statistic ); 
133 	return( (void *) values );
134 }
135 static int
136 vips_min_stop( VipsStatistic *statistic, void *seq )
137 {
138 	VipsMin *min = (VipsMin *) statistic;
139 	VipsValues *values = (VipsValues *) seq;
140 	int i;
141 	for( i = 0; i &lt; values-&gt;n; i++ )
142 		vips_values_add( &amp;min-&gt;values, 
143 			values-&gt;value[i], values-&gt;x_pos[i], values-&gt;y_pos[i] );
144 	g_free( values );
145 	return( 0 );
146 }
147 #define LOOPU( TYPE, LOWER ) { \
148 	TYPE *p = (TYPE *) in; \
149 	TYPE m; \
150 	\
151 	for( i = 0; i &lt; sz &amp;&amp; values-&gt;n &lt; values-&gt;size; i++ ) \
152 		vips_values_add( values, p[i], x + i / bands, y ); \
153 	m = values-&gt;value[0]; \
154 	\
155 	for( ; i &lt; sz; i++ ) { \
156 		if( p[i] &lt; m ) { \
157 			vips_values_add( values, p[i], x + i / bands, y ); \
158 			m = values-&gt;value[0]; \
159 			\
160 			if( m &lt;= LOWER ) { \
161 				statistic-&gt;stop = TRUE; \
162 				break; \
163 			} \
164 		} \
165 	} \
166 } 
167 #define LOOPF( TYPE ) { \
168 	TYPE *p = (TYPE *) in; \
169 	TYPE m; \
170 	\
171 	for( i = 0; i &lt; sz &amp;&amp; values-&gt;n &lt; values-&gt;size; i++ ) \
172 		if( !VIPS_ISNAN( p[i] ) ) \
173 			vips_values_add( values, p[i], x + i / bands, y ); \
174 	m = values-&gt;value[0]; \
175 	\
176 	for( ; i &lt; sz; i++ ) \
177 		if( p[i] &lt; m ) { \
178 			vips_values_add( values, p[i], x + i / bands, y ); \
179 			m = values-&gt;value[0]; \
180 		} \
181 } 
182 #define LOOPC( TYPE ) { \
183 	TYPE *p = (TYPE *) in; \
184 	TYPE m; \
185 	\
186 	for( i = 0; i &lt; sz &amp;&amp; values-&gt;n &lt; values-&gt;size; i++ ) { \
187 		TYPE mod2 = p[0] * p[0] + p[1] * p[1]; \
188 		\
189 		if( !VIPS_ISNAN( mod2 ) ) \
190 			vips_values_add( values, p[i], x + i / bands, y ); \
191 		\
192 		p += 2; \
193 	} \
194 	m = values-&gt;value[0]; \
195 	\
196 	for( ; i &lt; sz; i++ ) { \
197 		TYPE mod2 = p[0] * p[0] + p[1] * p[1]; \
198 		\
199 		if( mod2 &lt; m ) { \
200 			vips_values_add( values, mod2, x + i / bands, y ); \
201 			m = values-&gt;value[0]; \
202 		} \
203 		\
204 		p += 2; \
205 	} \
206 } 
207 static int
208 vips_min_scan( VipsStatistic *statistic, void *seq, 
209 	int x, int y, void *in, int n )
210 {
211 	VipsValues *values = (VipsValues *) seq;
212 	const int bands = vips_image_get_bands( statistic-&gt;in );
213 	const int sz = n * bands;
214 	int i;
215 	switch( vips_image_get_format( statistic-&gt;in ) ) {
216 	case VIPS_FORMAT_UCHAR:		
217 		LOOPU( unsigned char, 0 ); break; 
218 	case VIPS_FORMAT_CHAR:	
219 		LOOPU( signed char, SCHAR_MIN ); break; 
220 	case VIPS_FORMAT_USHORT:	
221 		LOOPU( unsigned short, 0 ); break; 
222 	case VIPS_FORMAT_SHORT:	
223 		LOOPU( signed short, SHRT_MIN ); break; 
224 	case VIPS_FORMAT_UINT:	
225 		LOOPU( unsigned int, 0 ); break;
226 	case VIPS_FORMAT_INT:	
227 		LOOPU( signed int, INT_MIN ); break; 
228 	case VIPS_FORMAT_FLOAT:	
229 		LOOPF( float ); break; 
230 	case VIPS_FORMAT_DOUBLE:	
231 		LOOPF( double ); break; 
232 	case VIPS_FORMAT_COMPLEX:
233 		LOOPC( float ); break; 
234 	case VIPS_FORMAT_DPCOMPLEX:
235 		LOOPC( double ); break; 
236 	default:  
237 <a name="0"></a>		g_assert_not_reached();
238 	}
239 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
240 }
241 static void
242 vips_min_class_init( VipsMinClass *class )
243 {
244 	GObjectClass *gobject_class = (GObjectClass *) class;
245 	VipsObjectClass *object_class = (VipsObjectClass *) class;
246 	VipsStatisticClass *sclass = VIPS_STATISTIC_CLASS( class );
247 	gobject_class-&gt;set_property = vips_object_set_property;
248 	gobject_class-&gt;get_property = vips_object_get_property;
249 	object_class-&gt;nickname = "min";
250 	object_class-&gt;description = _( "find image minimum" );
251 	object_class-&gt;build = vips_min_build;
252 	sclass-&gt;start = vips_min_start;</b></font>
253 	sclass-&gt;scan = vips_min_scan;
254 	sclass-&gt;stop = vips_min_stop;
255 	VIPS_ARG_DOUBLE( class, "out", 1, 
256 		_( "Output" ), 
257 		_( "Output value" ),
258 		VIPS_ARGUMENT_REQUIRED_OUTPUT,
259 		G_STRUCT_OFFSET( VipsMin, min ),
260 		-INFINITY, INFINITY, 0.0 );
261 	VIPS_ARG_INT( class, "x", 2, 
262 		_( "x" ), 
263 		_( "Horizontal position of minimum" ),
264 		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
265 		G_STRUCT_OFFSET( VipsMin, x ),
266 		0, VIPS_MAX_COORD, 0 );
267 	VIPS_ARG_INT( class, "y", 3, 
268 		_( "y" ), 
269 		_( "Vertical position of minimum" ),
270 		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
271 		G_STRUCT_OFFSET( VipsMin, y ),
272 		0, VIPS_MAX_COORD, 0 );
273 	VIPS_ARG_INT( class, "size", 4, 
274 		_( "Size" ), 
275 		_( "Number of minimum values to find" ),
276 		VIPS_ARGUMENT_OPTIONAL_INPUT,
277 		G_STRUCT_OFFSET( VipsMin, size ),
278 		1, 1000000, 10 );
279 	VIPS_ARG_BOXED( class, "out_array", 6, 
280 		_( "Output array" ), 
281 		_( "Array of output values" ),
282 		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
283 		G_STRUCT_OFFSET( VipsMin, min_array ),
284 		VIPS_TYPE_ARRAY_DOUBLE );
285 	VIPS_ARG_BOXED( class, "x_array", 7, 
286 		_( "x array" ), 
287 		_( "Array of horizontal positions" ),
288 		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
289 		G_STRUCT_OFFSET( VipsMin, x_array ),
290 		VIPS_TYPE_ARRAY_INT );
291 	VIPS_ARG_BOXED( class, "y_array", 8, 
292 		_( "y array" ), 
293 		_( "Array of vertical positions" ),
294 		VIPS_ARGUMENT_OPTIONAL_OUTPUT,
295 		G_STRUCT_OFFSET( VipsMin, y_array ),
296 		VIPS_TYPE_ARRAY_INT );
297 }
298 static void
299 vips_min_init( VipsMin *min )
300 {
301 	min-&gt;size = 1;
302 }
303 int
304 vips_min( VipsImage *in, double *out, ... )
305 {
306 	va_list ap;
307 	int result;
308 	va_start( ap, out );
309 	result = vips_call_split( "min", ap, in, out );
310 	va_end( ap );
311 	return( result );
312 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
