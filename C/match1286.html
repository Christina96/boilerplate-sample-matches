<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ompgsql.c &amp; imhiredis.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ompgsql.c &amp; imhiredis.c
      </h3>
<h1 align="center">
        8.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ompgsql.c (15.968586%)<th>imhiredis.c (5.7009344%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(87-102)<td><a href="#" name="0">(146-159)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(454-457)<td><a href="#" name="1">(333-336)</a><td align="center"><font color="#7a0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(420-423)<td><a href="#" name="2">(337-340)</a><td align="center"><font color="#7a0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(391-403)<td><a href="#" name="3">(321-332)</a><td align="center"><font color="#7a0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ompgsql.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;netdb.h&gt;
#include &lt;libpq-fe.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "parserif.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("ompgsql")
DEF_OMOD_STATIC_DATA
typedef struct _instanceData {
	char            dbname[_DB_MAXDBLEN+1];         	char            user[_DB_MAXUNAMELEN+1];        	char            pass[_DB_MAXPWDLEN+1];          	char            conninfo[_DB_MAXCONNINFOLEN+1]; 	unsigned int    trans_age;
	unsigned int    trans_commit;
	unsigned short  multi_row;
	int             port;
	uchar          *tpl;                      } instanceData;
typedef struct wrkrInstanceData {
	instanceData   *pData;
	PGconn         *f_hpgsql;                	ConnStatusType  eLastPgSQLStatus;        } wrkrInstanceData_t;
static struct cnfparamdescr actpdescr[] = {
	{ "server",     eCmdHdlrGetWord, 0 },
	{ "db",         eCmdHdlrGetWord, 0 },
<a name="0"></a>	{ "user",       eCmdHdlrGetWord, 0 },
	{ "uid",        eCmdHdlrGetWord, 0 },
	{ "pass",       eCmdHdlrGetWord, 0 },
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "pwd",        eCmdHdlrGetWord, 0 },
	{ "multirows",  eCmdHdlrInt,     0 },
	{ "trans_size", eCmdHdlrInt,     0 },
	{ "trans_age",  eCmdHdlrInt,     0 },
	{ "serverport", eCmdHdlrInt,     0 },
	{ "port",       eCmdHdlrInt,     0 },
	{ "template",   eCmdHdlrGetWord, 0 },
	{ "conninfo",   eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</b></font>
BEGINinitConfVars     CODESTARTinitConfVars
ENDinitConfVars
static rsRetVal writePgSQL(uchar *psz, wrkrInstanceData_t *pData);
BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;f_hpgsql = NULL;
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if (eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
static void closePgSQL(wrkrInstanceData_t *pWrkrData)
{
	assert(pWrkrData != NULL);
	if (pWrkrData-&gt;f_hpgsql != NULL) {  		PQfinish(pWrkrData-&gt;f_hpgsql);
		pWrkrData-&gt;f_hpgsql = NULL;
	}
}
BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;tpl);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	closePgSQL(pWrkrData);
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo
static void reportDBError(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	char errMsg[512];
	ConnStatusType ePgSQLStatus;
	assert(pWrkrData != NULL);
	bSilent = 0;
	errno = 0;
	if (pWrkrData-&gt;f_hpgsql == NULL) {
		LogError(0, NO_ERRCODE, "unknown DB error occurred - could not obtain PgSQL handle");
	} else { 		ePgSQLStatus = PQstatus(pWrkrData-&gt;f_hpgsql);
		snprintf(errMsg, sizeof(errMsg), "db error (%d): %s\n", ePgSQLStatus,
				PQerrorMessage(pWrkrData-&gt;f_hpgsql));
		if (bSilent || ePgSQLStatus == pWrkrData-&gt;eLastPgSQLStatus)
			dbgprintf("pgsql, DBError(silent): %s\n", errMsg);
		else {
			pWrkrData-&gt;eLastPgSQLStatus = ePgSQLStatus;
			LogError(0, NO_ERRCODE, "%s", errMsg);
		}
	}
	return;
}
static rsRetVal initPgSQL(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	int sslStatus;
	instanceData *pData;
	DEFiRet;
	pData = pWrkrData-&gt;pData;
	assert(pData != NULL);
	assert(pWrkrData-&gt;f_hpgsql == NULL);
	if (strlen(pData-&gt;conninfo) &gt; 0) {
		dbgprintf("initPgSQL: using connection string provided by conninfo\n");
		pWrkrData-&gt;f_hpgsql = PQconnectdb(pData-&gt;conninfo);
	} else {
		dbgprintf("initPgSQL: host=%s port=%d dbname=%s uid=%s\n", pData-&gt;srv, pData-&gt;port,
		                                                           pData-&gt;dbname, pData-&gt;user);
		const char *PgConnectionOptions = "-c standard_conforming_strings=on";
		char port[6];
		snprintf(port, sizeof(port), "%d", pData-&gt;port);
		pWrkrData-&gt;f_hpgsql = PQsetdbLogin(pData-&gt;srv, port, PgConnectionOptions, NULL,
		                                   pData-&gt;dbname, pData-&gt;user, pData-&gt;pass);
	}
	if (pWrkrData-&gt;f_hpgsql == NULL) {
		reportDBError(pWrkrData, bSilent);
		closePgSQL(pWrkrData); 		iRet = RS_RET_SUSPENDED;
	}
#ifdef HAVE_PGSSLINUSE
	sslStatus = PQsslInUse(pWrkrData-&gt;f_hpgsql);
#else
	sslStatus = PQgetssl(pWrkrData-&gt;f_hpgsql) == NULL ? 0 : 1;
#endif
	dbgprintf("initPgSQL: ssl status: %d\n", sslStatus);
	RETiRet;
}
static int
tryExec(uchar *pszCmd, wrkrInstanceData_t *pWrkrData)
{
	PGresult *pgRet;
	ExecStatusType execState;
	int bHadError = 0;
	pgRet = PQexec(pWrkrData-&gt;f_hpgsql, (char*)pszCmd);
	execState = PQresultStatus(pgRet);
	if (execState != PGRES_COMMAND_OK &amp;&amp; execState != PGRES_TUPLES_OK) {
		dbgprintf("postgres query execution failed: %s\n", PQresStatus(PQresultStatus(pgRet)));
		bHadError = 1;
	}
	PQclear(pgRet);
	return(bHadError);
}
static rsRetVal
writePgSQL(uchar *psz, wrkrInstanceData_t *pWrkrData)
{
	int bHadError = 0;
	DEFiRet;
	assert(psz != NULL);
	assert(pWrkrData != NULL);
	dbgprintf("writePgSQL: %s\n", psz);
	bHadError = tryExec(psz, pWrkrData); 
	if (bHadError || (PQstatus(pWrkrData-&gt;f_hpgsql) != CONNECTION_OK)) {
#if 0				int inTransaction = 0;
		if(pData-&gt;f_hpgsql != NULL) {
			PGTransactionStatusType xactStatus = PQtransactionStatus(pData-&gt;f_hpgsql);
			if((xactStatus == PQTRANS_INTRANS) || (xactStatus == PQTRANS_ACTIVE)) {
				inTransaction = 1;
			}
		}
		if ( inTransaction == 0 )
#endif
		{
			closePgSQL(pWrkrData); 			CHKiRet(initPgSQL(pWrkrData, 0)); 			bHadError = tryExec(psz, pWrkrData); 		}
		if(bHadError || (PQstatus(pWrkrData-&gt;f_hpgsql) != CONNECTION_OK)) {
			reportDBError(pWrkrData, 0);
			closePgSQL(pWrkrData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}
finalize_it:
	if (iRet == RS_RET_OK) {
		pWrkrData-&gt;eLastPgSQLStatus = CONNECTION_OK; 	}
	RETiRet;
}
BEGINtryResume
CODESTARTtryResume
	if (pWrkrData-&gt;f_hpgsql == NULL) {
		iRet = initPgSQL(pWrkrData, 1);
		if (iRet == RS_RET_OK) {
			iRet = writePgSQL((uchar*)"select 'a' as a", pWrkrData);
		}
	}
ENDtryResume
BEGINbeginTransaction
CODESTARTbeginTransaction
ENDbeginTransaction
BEGINcommitTransaction
CODESTARTcommitTransaction
	dbgprintf("ompgsql: beginTransaction\n");
	if (pWrkrData-&gt;f_hpgsql == NULL)
		initPgSQL(pWrkrData, 0);
	CHKiRet(writePgSQL((uchar*) "BEGIN", pWrkrData)); 
	for (unsigned i = 0 ; i &lt; nParams ; ++i) {
		iRet = writePgSQL(actParam(pParams, 1, i, 0).param, pWrkrData);
		if (iRet != RS_RET_OK
			&amp;&amp; iRet != RS_RET_DEFER_COMMIT
			&amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED) {
		}
	}
	CHKiRet(writePgSQL((uchar*) "COMMIT", pWrkrData)); 
finalize_it:
	if (iRet == RS_RET_OK) {
		pWrkrData-&gt;eLastPgSQLStatus = CONNECTION_OK; 	}
ENDcommitTransaction
static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;tpl           = NULL;
	pData-&gt;multi_row     = 100;
	pData-&gt;trans_commit  = 100;
	pData-&gt;trans_age     = 60;
	pData-&gt;port          = 5432;
	strcpy(pData-&gt;user, "postgres");
	strcpy(pData-&gt;pass, "postgres");
}
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
<a name="3"></a>	char *cstr;
	size_t len;
CODESTARTnewActInst
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	CODE_STD_STRING_REQUESTparseSelectorAct(1)
	for (i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(actpblk.descr[i].name, "server")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;srv)-1) {
				parser_errmsg("ompgsql: srv parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;srv)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;srv, cstr, len+1);
			free(cstr);
		} else if (!strcmp(actpblk.descr[i].name, "port")) {
			pData-&gt;port = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "serverport")) {
			pData-&gt;port = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "multirows")) {
<a name="2"></a>			pData-&gt;multi_row = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "trans_size")) {
			pData-&gt;trans_commit = (int) pvals[i].val.d.n;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if (!strcmp(actpblk.descr[i].name, "trans_age")) {
			pData-&gt;trans_age = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "db")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbname)-1) {
				parser_errmsg("ompgsql: db parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;dbname)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbname, cstr, len+1);
			free(cstr);
		} else if (   !strcmp(actpblk.descr[i].name, "user")
		           || !strcmp(actpblk.descr[i].name, "uid")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;user)-1) {
				parser_errmsg("ompgsql: user/uid parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;user)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;user, cstr, len+1);
			free(cstr);
		} else if (   !strcmp(actpblk.descr[i].name, "pass")
		           || !strcmp(actpblk.descr[i].name, "pwd")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;pass)-1) {
				parser_errmsg("ompgsql: pass/pwd parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;pass)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
<a name="1"></a>			}
			memcpy(pData-&gt;pass, cstr, len+1);
			free(cstr);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if (!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tpl = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "conninfo")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;conninfo)-1) {
				parser_errmsg("ompgsql: conninfo parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;conninfo)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;conninfo, cstr, len+1);
			free(cstr);
		} else {
			dbgprintf("ompgsql: program error, non-handled "
				"param '%s'\n", actpblk.descr[i].name);
		}
	}
	if (strlen(pData-&gt;conninfo) == 0 &amp;&amp; (strlen(pData-&gt;srv) == 0 || strlen(pData-&gt;dbname) == 0)) {
		parser_errmsg("ompgsql: must provide conninfo or server and dbname");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if (pData-&gt;tpl == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup(" StdPgSQLFmt"),     OMSR_RQD_TPL_OPT_SQL));
	} else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup((char*) pData-&gt;tpl), OMSR_RQD_TPL_OPT_SQL));
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINparseSelectorAct
	int iPgSQLPropErr = 0;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if (!strncmp((char*) p, ":ompgsql:", sizeof(":ompgsql:") - 1))
		p += sizeof(":ompgsql:") - 1; 	else
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	if ((iRet = createInstance(&amp;pData)) != RS_RET_OK)
		goto finalize_it;
	setInstParamDefaults(pData);
	if (getSubString(&amp;p, pData-&gt;srv, MAXHOSTNAMELEN+1, ','))
		iPgSQLPropErr++;
	dbgprintf("%p:%s\n",p,p);
	if (*pData-&gt;srv == '\0')
		iPgSQLPropErr++;
	if (getSubString(&amp;p, pData-&gt;dbname, _DB_MAXDBLEN+1, ','))
		iPgSQLPropErr++;
	if (*pData-&gt;dbname == '\0')
		iPgSQLPropErr++;
	if (getSubString(&amp;p, pData-&gt;user, _DB_MAXUNAMELEN+1, ','))
		iPgSQLPropErr++;
	if (*pData-&gt;user == '\0')
		iPgSQLPropErr++;
	if (getSubString(&amp;p, pData-&gt;pass, _DB_MAXPWDLEN+1, ';'))
		iPgSQLPropErr++;
	if (*(p - 1) == ';') {
		p--;
		CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*) pData-&gt;tpl));
	} else {
		CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*)" StdPgSQLFmt"));
	}
	if (iPgSQLPropErr) {
		LogError(0, RS_RET_INVALID_PARAMS, "Trouble with PgSQL connection properties. "
				"-PgSQL logging disabled");
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	}
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
BEGINmodExit
CODESTARTmodExit
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMODTX_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	if (!bCoreSupportsBatching) {
		LogError(0, NO_ERRCODE, "ompgsql: rsyslog core too old");
		ABORT_FINALIZE(RS_RET_ERR);
	}
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imhiredis.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;hiredis/hiredis.h&gt;
#include &lt;hiredis/async.h&gt;
#include &lt;hiredis/adapters/libevent.h&gt;
#include &lt;event2/thread.h&gt;
#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "atomic.h"
#include "statsobj.h"
#include "unicode-helper.h"
#include "prop.h"
#include "ruleset.h"
#include "glbl.h"
#include "cfsysline.h"
#include "msg.h"
#include "dirty.h"
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imhiredis")
DEF_IMOD_STATIC_DATA
#define QUEUE_BATCH_SIZE 10
#define IMHIREDIS_MODE_QUEUE 1
#define IMHIREDIS_MODE_SUBSCRIBE 2
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)
typedef struct redisNode_s {
	sbool isMaster;
	sbool usesSocket;
	uchar *socketPath;
	uchar *server;
	int port;
	struct redisNode_s *next;
} redisNode;
struct instanceConf_s {
	uchar *password;
	uchar *key;
	uchar *modeDescription;
	int mode;
	sbool useLPop;
	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;		
	redisContext *conn;
	redisAsyncContext *aconn;
	struct event_base *evtBase;
	redisNode *redisNodesList;
	struct instanceConf_s *next;
};
struct modConfData_s {
	rsconf_t *pConf;			instanceConf_t *root, *tail;
};
static struct imhiredisWrkrInfo_s {
	pthread_t tid;			instanceConf_t *inst;	} *imhiredisWrkrInfo;
pthread_attr_t wrkrThrdAttr;	
static int activeHiredisworkers = 0;
static char *redis_replies[] = {"unknown", "string", "array", "integer", "nil", "status", "error"};
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
static prop_t *pInputName = NULL;
static struct cnfparamdescr modpdescr[] = {};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
<a name="0"></a>
static struct cnfparamdescr inppdescr[] = {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "socketPath", eCmdHdlrGetWord, 0 },
	{ "server", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrInt, 0 },
	{ "password", eCmdHdlrGetWord, 0 },
	{ "mode", eCmdHdlrGetWord, 0 },
	{ "key", eCmdHdlrGetWord, 0 },
	{ "uselpop", eCmdHdlrBinary, 0 },
	{ "ruleset", eCmdHdlrString, 0 },
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};</b></font>
struct timeval glblRedisConnectTimeout = { 3, 0 }; 
#include "im-helper.h" 
static void redisAsyncRecvCallback (redisAsyncContext __attribute__((unused)) *c, void *reply, void *inst_obj);
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status);
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status);
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message);
rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password);
rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password);
rsRetVal redisActualizeCurrentNode(instanceConf_t *inst);
rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result);
rsRetVal redisAuthenticate(instanceConf_t *inst);
rsRetVal redisConnectSync(redisContext **conn, redisNode *node);
rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node);
rsRetVal redisDequeue(instanceConf_t *inst);
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me);
void workerLoopQueue(struct imhiredisWrkrInfo_s *me);
static void *imhirediswrkr(void *myself);
static rsRetVal createRedisNode(redisNode **root);
rsRetVal copyNode(redisNode *src, redisNode **dst);
redisNode *freeNode(redisNode *node);
void insertNodeAfter(redisNode *root, redisNode *elem);
void dbgPrintNode(redisNode *node);
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	DEFiRet;
	instanceConf_t *inst;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;
	inst-&gt;password = NULL;
	inst-&gt;key = NULL;
	inst-&gt;mode = 0;
	inst-&gt;useLPop = 0;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;conn = NULL;
	inst-&gt;aconn = NULL;
	CHKiRet(createRedisNode(&amp;(inst-&gt;redisNodesList)));
	inst-&gt;currentNode = inst-&gt;redisNodesList;
	inst-&gt;evtBase = NULL;
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}
	*pinst = inst;
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
checkInstance(instanceConf_t *const inst)
{
	DEFiRet;
	assert(inst-&gt;redisNodesList != NULL);
	if (inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath != NULL) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: both 'server' and 'socketPath' are given, "
								"ignoring 'socketPath'.");
		free(inst-&gt;redisNodesList-&gt;socketPath);
		inst-&gt;redisNodesList-&gt;socketPath = NULL;
	}
	if(inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;server[0] != '\0') {
		if (inst-&gt;redisNodesList-&gt;port == 0) {
			LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: port not set, setting default 6379");
			inst-&gt;redisNodesList-&gt;port = 6379;
		}
		DBGPRINTF("imhiredis: preferred server is %s (%d)\n",
			inst-&gt;redisNodesList-&gt;server,
			inst-&gt;redisNodesList-&gt;port);
		inst-&gt;redisNodesList-&gt;usesSocket = 0;
	}
	else if(inst-&gt;redisNodesList-&gt;socketPath != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath[0] != '\0') {
		DBGPRINTF("imhiredis: preferred server is %s\n",
			inst-&gt;redisNodesList-&gt;socketPath);
		inst-&gt;redisNodesList-&gt;usesSocket = 1;
	} else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: neither 'server' nor 'socketPath' are defined!");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (inst-&gt;key != NULL) {
		DBGPRINTF("imhiredis: key/channel is '%s'\n", inst-&gt;key);
	} else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: no key defined !");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (inst-&gt;mode != IMHIREDIS_MODE_QUEUE &amp;&amp; inst-&gt;mode != IMHIREDIS_MODE_SUBSCRIBE) {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: invalid mode, please choose 'subscribe' or 'queue' mode.");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;useLPop) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: 'uselpop' set with mode = subscribe : ignored.");
	}
	if (inst-&gt;password != NULL) {
		DBGPRINTF("imhiredis: password is '%s'\n", inst-&gt;password);
	}
	inst-&gt;currentNode = inst-&gt;redisNodesList;
	if (RS_RET_OK != redisActualizeCurrentNode(inst) || inst-&gt;currentNode == NULL) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to a valid master!");
	}
finalize_it:
	RETiRet;
}
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imhiredis: ruleset '%s' not found - "
		"using default ruleset instead",
		inst-&gt;pszBindRuleset);
}
BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imhiredis)\n");
	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
<a name="3"></a>		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(Debug) {
		dbgprintf("input param blk in imhiredis:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}
	CHKiRet(createInstance(&amp;inst));
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
<a name="1"></a>
		if(!strcmp(inppblk.descr[i].name, "server")) {
			inst-&gt;redisNodesList-&gt;server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "socketPath")) {
<a name="2"></a>			inst-&gt;redisNodesList-&gt;socketPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "port")) {
			inst-&gt;redisNodesList-&gt;port = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "password")) {
			inst-&gt;password = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "uselpop")) {
			inst-&gt;useLPop = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "mode")) {
			inst-&gt;modeDescription = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if (!strcmp((const char*)inst-&gt;modeDescription, "queue")) {
				inst-&gt;mode = IMHIREDIS_MODE_QUEUE;
			} else if (!strcmp((const char*)inst-&gt;modeDescription, "subscribe")) {
				inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
			} else {
				LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: unsupported mode "
					"'%s'", inppblk.descr[i].name);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
		} else if(!strcmp(inppblk.descr[i].name, "key")) {
			inst-&gt;key = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("imhiredis: program error, non-handled "
				"param '%s'\n", inppblk.descr[i].name);
		}
	}
	DBGPRINTF("imhiredis: checking config sanity\n");
	if (inst-&gt;modeDescription == NULL) {
		CHKmalloc(inst-&gt;modeDescription = (uchar*)strdup("subscribe"));
		inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: \"mode\" parameter not specified "
			"using default redis 'subscribe' mode -- this may not be what you want!");
	}
	if (inst-&gt;key == NULL) {
		LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: \"key\" required parameter not specified!");
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	if(inst-&gt;redisNodesList-&gt;server == NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath == NULL) {
		CHKmalloc(inst-&gt;redisNodesList-&gt;server = (uchar *)strdup("127.0.0.1"));
		inst-&gt;redisNodesList-&gt;port = 6379;
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: no server parameter specified "
			"using default 127.0.0.1:6379 -- this may not be what you want!");
	}
	if (inst-&gt;password == NULL) {
		LogMsg(0, RS_RET_OK, LOG_INFO, "imhiredis: no password specified");
	}
	DBGPRINTF("imhiredis: newInpInst key=%s, mode=%s, uselpop=%d\n",
		inst-&gt;key, inst-&gt;modeDescription, inst-&gt;useLPop);
finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imhiredis: error processing module "
			"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for imhiredis:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		} else {
			dbgprintf("imhiredis: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad
BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
ENDcheckCnf
BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
ENDactivateCnfPrePrivDrop
BEGINactivateCnf
CODESTARTactivateCnf
	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		iRet = checkInstance(inst);
		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
			inst-&gt;evtBase = event_base_new();
	}
ENDactivateCnf
BEGINfreeCnf
	instanceConf_t *inst, *del;
	redisNode *node;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		if (inst-&gt;evtBase)
			event_base_free(inst-&gt;evtBase);
		if (inst-&gt;password != NULL)
			free(inst-&gt;password);
		free(inst-&gt;modeDescription);
		free(inst-&gt;key);
		free(inst-&gt;pszBindRuleset);
		if(inst-&gt;conn != NULL) {
			redisFree(inst-&gt;conn);
			inst-&gt;conn = NULL;
		}
		if(inst-&gt;aconn != NULL) {
			redisAsyncFree(inst-&gt;aconn);
			inst-&gt;aconn = NULL;
		}
		for (node = inst-&gt;redisNodesList; node != NULL; node = freeNode(node)) {;}
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf
static void
shutdownImhiredisWorkers(void)
{
	int i;
	instanceConf_t *inst;
	assert(imhiredisWrkrInfo != NULL);
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;aconn) {
			DBGPRINTF("imhiredis: disconnecting async worker\n");
			redisAsyncDisconnect(inst-&gt;aconn);
		}
	}
	DBGPRINTF("imhiredis: waiting on imhiredis workerthread termination\n");
	for(i = 0 ; i &lt; activeHiredisworkers ; ++i) {
		pthread_join(imhiredisWrkrInfo[i].tid, NULL);
		DBGPRINTF("imhiredis: Stopped worker %d\n", i);
	}
	free(imhiredisWrkrInfo);
	imhiredisWrkrInfo = NULL;
	return;
}
BEGINrunInput
	int i;
	instanceConf_t *inst;
CODESTARTrunInput
	DBGPRINTF("imhiredis: runInput loop started ...\n");
	activeHiredisworkers = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		++activeHiredisworkers;
	}
	if(activeHiredisworkers == 0) {
		LogError(0, RS_RET_ERR, "imhiredis: no active inputs, input does "
			"not run - there should have been additional error "
			"messages given previously");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	DBGPRINTF("imhiredis: Starting %d imhiredis workerthreads\n", activeHiredisworkers);
	imhiredisWrkrInfo = calloc(activeHiredisworkers, sizeof(struct imhiredisWrkrInfo_s));
	if (imhiredisWrkrInfo == NULL) {
		LogError(errno, RS_RET_OUT_OF_MEMORY, "imhiredis: worker-info array allocation failed.");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	i = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		imhiredisWrkrInfo[i].inst = inst; 		pthread_create(&amp;imhiredisWrkrInfo[i].tid, &amp;wrkrThrdAttr, imhirediswrkr, &amp;(imhiredisWrkrInfo[i]));
		i++;
	}
	while(glbl.GetGlobalInputTermState() == 0) {
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(0, 100000);
	}
	DBGPRINTF("imhiredis: terminating upon request of rsyslog core\n");
	shutdownImhiredisWorkers();
finalize_it:
ENDrunInput
BEGINwillRun
CODESTARTwillRun
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imhiredis"), sizeof("imhiredis") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun
BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
ENDafterRun
BEGINmodExit
CODESTARTmodExit
	pthread_attr_destroy(&amp;wrkrThrdAttr);
	libevent_global_shutdown();
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
	evthread_use_pthreads();
ENDmodInit
static void redisAsyncRecvCallback (redisAsyncContext *aconn, void *reply, void __attribute__((unused)) *unused) {
	instanceConf_t *const inst = (instanceConf_t *) aconn-&gt;data;
	redisReply * r = (redisReply *) reply;
	if (r == NULL) return;
	if (r-&gt;elements &lt; 3 || r-&gt;element[2]-&gt;str == NULL) {
		return;
	}
	enqMsg(inst, r-&gt;element[2]-&gt;str);
	return;
}
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status) {
	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): could not connect to redis: "
			"%s", c-&gt;errstr);
		instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
		assert(inst != NULL);
		inst-&gt;aconn = NULL;
		return;
	}
	DBGPRINTF("imhiredis (async): successfully connected!\n");
	return;
}
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status) {
	instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
	assert(inst != NULL);
	inst-&gt;aconn = NULL;
	inst-&gt;currentNode = NULL;
	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): got disconnected from redis: "
			"%s", c-&gt;errstr);
		return;
	}
	DBGPRINTF("imhiredis (async): successfully disconnected!\n");
	return;
}
redisReply *getRole(redisContext *c) {
	redisReply *reply;
	assert(c != NULL);
	reply = redisCommand(c, "ROLE");
	if (reply == NULL) {
		DBGPRINTF("imhiredis: could not get reply from ROLE command\n");
	}
	else if (reply-&gt;type == REDIS_REPLY_ERROR) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis got an error while querying role -&gt; "
			"%s\n", reply-&gt;str);
		freeReplyObject(reply);
		reply = NULL;
	}
	else if (reply-&gt;type != REDIS_REPLY_ARRAY) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: did not get an array from ROLE command");
		freeReplyObject(reply);
		reply = NULL;
	}
	return reply;
}
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message) {
	DEFiRet;
	smsg_t *pMsg;
	if (message == NULL || message[0] == '\0') {
		FINALIZE;
	}
	DBGPRINTF("imhiredis: enqMsg: Msg -&gt; '%s'\n", message);
	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, message, strlen(message));
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	MsgSetMSGoffs(pMsg, 0);		CHKiRet(submitMsg2(pMsg));
finalize_it:
	RETiRet;
}
rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password) {
	DEFiRet;
	redisReply *reply = NULL;
	assert(conn != NULL);
	assert(password != NULL);
	assert(password[0] != '\0');
	reply = (redisReply *) redisCommand(conn, "AUTH %s", password);
	if (reply == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Could not authenticate!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if (strncmp(reply-&gt;str, "OK", 2)) {
		LogError(0, RS_RET_REDIS_AUTH_FAILED, "imhiredis: Authentication failure -&gt; %s\n", reply-&gt;str);
		ABORT_FINALIZE(RS_RET_REDIS_AUTH_FAILED);
	}
finalize_it:
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}
rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password) {
	DEFiRet;
	assert(aconn != NULL);
	assert(password != NULL);
	assert(password[0] != '\0');
	if (REDIS_OK != redisAsyncCommand(aconn, NULL, NULL, "AUTH %s", password)) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: error while authenticating asynchronously -&gt; %s\n",
			aconn-&gt;errstr);
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
finalize_it:
	RETiRet;
}
rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result) {
	DEFiRet;
	redisContext *context;
	redisReply *reply = NULL, *replica;
	unsigned int i;
	assert(node != NULL);
	CHKiRet(redisConnectSync(&amp;context, node));
	if(password != NULL &amp;&amp; password[0] != '\0') {
		CHKiRet(redisAuthentSynchronous(context, password));
	}
	reply = getRole(context);
	if(reply == NULL) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: did not get the role of the server");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
	if (	reply-&gt;elements == 5 &amp;&amp;
		strncmp(reply-&gt;element[0]-&gt;str, "slave", 5) == 0) {
		CHKiRet(createRedisNode(result));
		(*result)-&gt;server = (uchar *) strdup((const char *)reply-&gt;element[1]-&gt;str);
		(*result)-&gt;port = reply-&gt;element[2]-&gt;integer;
		(*result)-&gt;isMaster = 1;
	}
	else if (	reply-&gt;elements == 3 &amp;&amp;
			reply-&gt;element[2]-&gt;type == REDIS_REPLY_ARRAY &amp;&amp;
			strncmp(reply-&gt;element[0]-&gt;str, "master", 6) == 0) {
		for (i = 0; i &lt; reply-&gt;element[2]-&gt;elements; i++) {
			replica = reply-&gt;element[2]-&gt;element[i];
			if (replica-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; replica-&gt;elements == 3) {
				CHKiRet(createRedisNode(result));
				(*result)-&gt;server = (uchar *) strdup((const char *)replica-&gt;element[0]-&gt;str);
				(*result)-&gt;port = atoi(replica-&gt;element[1]-&gt;str);
			}
		}
	} else {
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
finalize_it:
	if (reply != NULL)
		freeReplyObject(reply);
	if (context != NULL)
		redisFree(context);
	RETiRet;
}
rsRetVal redisActualizeCurrentNode(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	redisNode *node, *tmp, *newList = NULL;
	assert(inst != NULL);
	assert(inst-&gt;redisNodesList != NULL);
	inst-&gt;currentNode = NULL;
	copyNode(inst-&gt;redisNodesList, &amp;newList);
	newList-&gt;next = NULL;
	for (node = inst-&gt;redisNodesList; node != NULL; node = node-&gt;next) {
		tmp = NULL;
		DBGPRINTF("imhiredis: trying to connect to node to get info...\n");
		dbgPrintNode(node);
		if (RS_RET_OK == redisGetServersList(node, inst-&gt;password, &amp;tmp)) {
			if (tmp &amp;&amp; tmp-&gt;isMaster) {
				DBGPRINTF("imhiredis: node replied with a master node, is a replica\n");
				inst-&gt;currentNode = tmp;
				tmp = NULL;
				if(RS_RET_OK != redisGetServersList(inst-&gt;currentNode, inst-&gt;password, &amp;tmp)) {
					DBGPRINTF("imhiredis: had a master but cannot connect, keeping in list\n");
					dbgPrintNode(inst-&gt;currentNode);
					insertNodeAfter(newList, inst-&gt;currentNode);
					inst-&gt;currentNode = NULL;
					continue;
				}
			} else {
				DBGPRINTF("imhiredis: node replied with a list of replicas, is a master\n");
				node-&gt;isMaster = 1;
				copyNode(node, &amp;(inst-&gt;currentNode));
				inst-&gt;currentNode-&gt;next = NULL;
			}
			if (tmp) {
				insertNodeAfter(newList, tmp);
				DBGPRINTF("imhiredis: inserting replicas to list\n");
				for (tmp = newList-&gt;next; tmp != NULL; tmp = tmp-&gt;next) {
					dbgPrintNode(tmp);
				}
			}
			DBGPRINTF("imhiredis: inserting new master node in list\n");
			dbgPrintNode(inst-&gt;currentNode);
			insertNodeAfter(newList, inst-&gt;currentNode);
			tmp = newList;
			newList = inst-&gt;redisNodesList;
			inst-&gt;redisNodesList = tmp;
			FINALIZE;
		}
	}
	DBGPRINTF("imhiredis: did not find a valid master");
	iRet = RS_RET_NOT_FOUND;
	inst-&gt;currentNode = NULL;
finalize_it:
	if (reply != NULL)
		freeReplyObject(reply);
	for (node = newList; node != NULL; ) {
		node = freeNode(node);
	}
	RETiRet;
}
rsRetVal redisAuthenticate(instanceConf_t *inst) {
	DEFiRet;
	redisContext *usedContext = NULL;
	redisReply *reply = NULL;
	assert(inst != NULL);
	assert(inst-&gt;currentNode != NULL);
	assert(inst-&gt;password != NULL);
	assert(inst-&gt;password[0] != '\0');
	DBGPRINTF("imhiredis: authenticating...\n");
	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
		if (RS_RET_OK != redisConnectSync(&amp;usedContext, inst-&gt;currentNode)) {
			LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to current "
				"active node synchronously to validate authentication");
			ABORT_FINALIZE(RS_RET_REDIS_ERROR);
		}
	} else {
		usedContext = inst-&gt;conn;
	}
	CHKiRet(redisAuthentSynchronous(usedContext, inst-&gt;password));
	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
		CHKiRet(redisAuthentAsynchronous(inst-&gt;aconn, inst-&gt;password));
	}
	DBGPRINTF("imhiredis: authentication successful\n");
finalize_it:
	if(inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; usedContext)
		redisFree(usedContext);
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}
rsRetVal redisConnectSync(redisContext **conn, redisNode *node) {
	DEFiRet;
	assert(node != NULL);
	if (node-&gt;usesSocket)
		*conn = redisConnectUnixWithTimeout((const char *)node-&gt;socketPath, glblRedisConnectTimeout);
	else
		*conn = redisConnectWithTimeout((const char *)node-&gt;server, node-&gt;port, glblRedisConnectTimeout);
	if (*conn == NULL) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
				"-&gt; could not allocate context!\n", node-&gt;socketPath);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -&gt; could not allocate context!\n", node-&gt;server, node-&gt;port);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
	else if ((*conn)-&gt;err) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
				"-&gt; %s\n", node-&gt;socketPath, (*conn)-&gt;errstr);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -&gt; %s\n", node-&gt;server, node-&gt;port, (*conn)-&gt;errstr);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		if (*conn)
			redisFree(*conn);
		*conn = NULL;
	}
	RETiRet;
}
rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node) {
	DEFiRet;
	assert(node != NULL);
	if (node-&gt;usesSocket)
		*aconn = redisAsyncConnectUnix((const char*)node-&gt;socketPath);
	else
		*aconn = redisAsyncConnect((const char *)node-&gt;server, node-&gt;port);
	if(*aconn == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): could not allocate context!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if ((*aconn)-&gt;err) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s' "
				"-&gt; %s\n", node-&gt;socketPath, (*aconn)-&gt;errstr);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s', port '%d' "
				"-&gt; %s\n", node-&gt;server, node-&gt;port, (*aconn)-&gt;errstr);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		if(*aconn)
			redisAsyncFree(*aconn);
		*aconn = NULL;
	}
	RETiRet;
}
rsRetVal redisDequeue(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	uint replyType = 0, i;
	assert(inst != NULL);
	DBGPRINTF("imhiredis: beginning to dequeue key '%s'\n", inst-&gt;key);
	do {
		if (inst-&gt;useLPop == 1) {
			DBGPRINTF("imhiredis: Queuing #%d LPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst-&gt;key);
			for (i=0; i&lt;QUEUE_BATCH_SIZE; ++i ) {
				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "LPOP %s", inst-&gt;key))
					break;
			}
		} else {
			DBGPRINTF("imhiredis: Queuing #%d RPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst-&gt;key);
			for (i=0; i&lt;QUEUE_BATCH_SIZE; i++) {
				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "RPOP %s", inst-&gt;key))
					break;
			}
		}
		do {
			if (REDIS_OK != redisGetReply(inst-&gt;conn, (void **) &amp;reply)) {
				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Error reading reply after POP #%d on key "
								"'%s'", (QUEUE_BATCH_SIZE - i), inst-&gt;key);
				ABORT_FINALIZE(RS_RET_REDIS_ERROR);
			} else {
				if (reply != NULL) {
					replyType = reply-&gt;type;
					switch(replyType) {
						case REDIS_REPLY_STRING:
							enqMsg(inst, reply-&gt;str);
							break;
						case REDIS_REPLY_NIL:
							break;
						case REDIS_REPLY_ERROR:
							LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: error "
							"while POP'ing key '%s' -&gt; %s", inst-&gt;key, reply-&gt;str);
							ABORT_FINALIZE(RS_RET_REDIS_ERROR);
						default:
							LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: unexpected "
							"reply type: %s", redis_replies[replyType%7]);
					}
					freeReplyObject(reply);
					reply = NULL;
				} else { 					LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: unexpected empty reply "
						"for successful return");
					ABORT_FINALIZE(RS_RET_REDIS_ERROR);
				}
			}
		} while (--i &gt; 0);
	} while (replyType == REDIS_REPLY_STRING &amp;&amp; glbl.GetGlobalInputTermState() == 0);
	DBGPRINTF("imhiredis: finished to dequeue key '%s'\n", inst-&gt;key);
finalize_it:
	if (reply)
		freeReplyObject(reply);
	RETiRet;
}
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis (async): beginning of subscribe worker loop...\n");
	if (me-&gt;inst-&gt;currentNode != NULL) {
		if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
			me-&gt;inst-&gt;currentNode = NULL;
		}
		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
			redisAsyncFree(me-&gt;inst-&gt;aconn);
			me-&gt;inst-&gt;aconn = NULL;
			me-&gt;inst-&gt;currentNode = NULL;
		}
		me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
		redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
		redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
		redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
	}
	while(glbl.GetGlobalInputTermState() == 0) {
		if (me-&gt;inst-&gt;aconn == NULL) {
			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
			for(i = 0; i &lt; 100; i++) {
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				srSleep(0, 100000);
			}
			if (me-&gt;inst-&gt;currentNode == NULL) {
				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
					continue;
			}
			if(me-&gt;inst-&gt;currentNode != NULL) {
				if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
					redisAsyncFree(me-&gt;inst-&gt;aconn);
					me-&gt;inst-&gt;aconn = NULL;
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
			}
			me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
			redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
			redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
			redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
		}
		if (me-&gt;inst-&gt;aconn != NULL) {
			DBGPRINTF("imhiredis (async): subscribing to channel '%s'\n", me-&gt;inst-&gt;key);
			redisAsyncCommand(
				me-&gt;inst-&gt;aconn,
				redisAsyncRecvCallback,
				NULL,
				"SUBSCRIBE %s",
				me-&gt;inst-&gt;key);
			event_base_dispatch(me-&gt;inst-&gt;evtBase);
		}
	}
end_loop:
	return;
}
void workerLoopQueue(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis: beginning of queue worker loop...\n");
	if (me-&gt;inst-&gt;currentNode != NULL) {
		if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
			me-&gt;inst-&gt;currentNode = NULL;
		}
		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
			redisFree(me-&gt;inst-&gt;conn);
			me-&gt;inst-&gt;conn = NULL;
			me-&gt;inst-&gt;currentNode = NULL;
		}
	}
	while(glbl.GetGlobalInputTermState() == 0) {
		if (me-&gt;inst-&gt;conn == NULL) {
			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
			for(i = 0; i &lt; 100; i++) {
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				srSleep(0, 100000);
			}
			if (me-&gt;inst-&gt;currentNode == NULL) {
				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
					continue;
			}
			if(me-&gt;inst-&gt;currentNode != NULL) {
				if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
					redisFree(me-&gt;inst-&gt;conn);
					me-&gt;inst-&gt;conn = NULL;
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
			}
		}
		if (me-&gt;inst-&gt;conn != NULL) {
			if (redisDequeue(me-&gt;inst) == RS_RET_REDIS_ERROR) {
				DBGPRINTF("imhiredis: current connection invalidated\n");
				redisFree(me-&gt;inst-&gt;conn);
				me-&gt;inst-&gt;currentNode = NULL;
				me-&gt;inst-&gt;conn = NULL;
			}
			if(glbl.GetGlobalInputTermState() == 0) {
				for(i = 0; i &lt; 10; i++) {
					if (glbl.GetGlobalInputTermState() != 0)
						goto end_loop;
					srSleep(0, 100000);
				}
			}
		}
	}
end_loop:
	return;
}
static void *
imhirediswrkr(void *myself)
{
	struct imhiredisWrkrInfo_s *me = (struct imhiredisWrkrInfo_s*) myself;
	DBGPRINTF("imhiredis: started hiredis consumer workerthread\n");
	dbgPrintNode(me-&gt;inst-&gt;currentNode);
	if(me-&gt;inst-&gt;mode == IMHIREDIS_MODE_QUEUE)
		workerLoopQueue(me);
	else if (me-&gt;inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
		workerLoopSubscribe(me);
	DBGPRINTF("imhiredis: stopped hiredis consumer workerthread\n");
	return NULL;
}
static rsRetVal
createRedisNode(redisNode **root) {
	redisNode *node;
	DEFiRet;
	CHKmalloc(node = malloc(sizeof(redisNode)));
	node-&gt;port = 0;
	node-&gt;server = NULL;
	node-&gt;socketPath = NULL;
	node-&gt;usesSocket = 0;
	node-&gt;isMaster = 0;
	node-&gt;next = NULL;
	if (!root) {
		*root = node;
	} else {
		node-&gt;next = (*root);
		*root = node;
	}
finalize_it:
	RETiRet;
}
rsRetVal copyNode(redisNode *src, redisNode **dst) {
	DEFiRet;
	assert(src != NULL);
	CHKiRet(createRedisNode(dst));
	(*dst)-&gt;isMaster = src-&gt;isMaster;
	(*dst)-&gt;next = src-&gt;next;
	(*dst)-&gt;port = src-&gt;port;
	(*dst)-&gt;usesSocket = src-&gt;usesSocket;
	if (src-&gt;server)
		(*dst)-&gt;server = (uchar *) strdup((const char *)src-&gt;server);
	if (src-&gt;socketPath)
		(*dst)-&gt;socketPath = (uchar *) strdup((const char *)src-&gt;socketPath);
finalize_it:
	RETiRet;
}
redisNode *freeNode(redisNode *node) {
	redisNode *ret = NULL;
	if (node != NULL) {
		if (node-&gt;next != NULL)
			ret = node-&gt;next;
		if(node-&gt;server != NULL)
			free(node-&gt;server);
		if(node-&gt;socketPath != NULL)
			free(node-&gt;socketPath);
		free(node);
	}
	return ret;
}
void insertNodeAfter(redisNode *root, redisNode *elem) {
	assert(root != NULL);
	assert(elem != NULL);
	if(root-&gt;next != NULL) {
		elem-&gt;next = root-&gt;next;
	}
	root-&gt;next = elem;
	return;
}
void dbgPrintNode(redisNode *node) {
	if (node != NULL) {
		if (node-&gt;usesSocket) {
			if (node-&gt;isMaster) {
				DBGPRINTF("imhiredis: node is %s (master)\n", node-&gt;socketPath);
			} else {
				DBGPRINTF("imhiredis: node is %s (replica)\n", node-&gt;socketPath);
			}
		} else {
			if (node-&gt;isMaster) {
				DBGPRINTF("imhiredis: node is %s:%d (master)\n", node-&gt;server, node-&gt;port);
			} else {
				DBGPRINTF("imhiredis: node is %s:%d (replica)\n", node-&gt;server, node-&gt;port);
			}
		}
	}
	return;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
