<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for ompgsql.c &amp; imhiredis.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ompgsql.c &amp; imhiredis.c
      </h3>
<h1 align="center">
        8.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ompgsql.c (15.968586%)<th>imhiredis.c (5.7009344%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(87-102)<td><a href="#" name="0">(146-159)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(454-457)<td><a href="#" name="1">(333-336)</a><td align="center"><font color="#7a0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(420-423)<td><a href="#" name="2">(337-340)</a><td align="center"><font color="#7a0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(391-403)<td><a href="#" name="3">(321-332)</a><td align="center"><font color="#7a0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ompgsql.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* ompgsql.c
 * This is the implementation of the build-in output module for PgSQL.
 *
 * NOTE: read comments in module-template.h to understand how this file
 *       works!
 *
 * File begun on 2007-10-18 by sur5r (converted from ommysql.c)
 *
 * Copyright 2007-2018 Rainer Gerhards and Adiscon GmbH.
 *
 * The following link my be useful for the not-so-postgres literate
 * when setting up a test environment (on Fedora):
 * http://www.jboss.org/community/wiki/InstallPostgreSQLonFedora
 *
 * This file is part of rsyslog.
 *
 * Rsyslog is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Rsyslog is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Rsyslog.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * A copy of the GPL can be found in the file "COPYING" in this distribution.
 */
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;netdb.h&gt;
#include &lt;libpq-fe.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "parserif.h"

MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("ompgsql")


/* internal structures
 */
DEF_OMOD_STATIC_DATA

typedef struct _instanceData {
	char            srv[MAXHOSTNAMELEN+1];          /* IP or hostname of DB server*/
	char            dbname[_DB_MAXDBLEN+1];         /* DB name */
	char            user[_DB_MAXUNAMELEN+1];        /* DB user */
	char            pass[_DB_MAXPWDLEN+1];          /* DB user's password */
	char            conninfo[_DB_MAXCONNINFOLEN+1]; /* Connection parameters or URI */
	unsigned int    trans_age;
	unsigned int    trans_commit;
	unsigned short  multi_row;
	int             port;
	uchar          *tpl;                      /* format template to use */
} instanceData;

typedef struct wrkrInstanceData {
	instanceData   *pData;
	PGconn         *f_hpgsql;                /* handle to PgSQL */
	ConnStatusType  eLastPgSQLStatus;        /* last status from postgres */
} wrkrInstanceData_t;

/* action (instance) parameters */
static struct cnfparamdescr actpdescr[] = {
	{ "server",     eCmdHdlrGetWord, 0 },
	{ "db",         eCmdHdlrGetWord, 0 },
<a name="0"></a>	{ "user",       eCmdHdlrGetWord, 0 },
	{ "uid",        eCmdHdlrGetWord, 0 },
	{ "pass",       eCmdHdlrGetWord, 0 },
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "pwd",        eCmdHdlrGetWord, 0 },
	{ "multirows",  eCmdHdlrInt,     0 },
	{ "trans_size", eCmdHdlrInt,     0 },
	{ "trans_age",  eCmdHdlrInt,     0 },
	{ "serverport", eCmdHdlrInt,     0 },
	{ "port",       eCmdHdlrInt,     0 },
	{ "template",   eCmdHdlrGetWord, 0 },
	{ "conninfo",   eCmdHdlrGetWord, 0 }
};


static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};</b></font>


BEGINinitConfVars     /* (re)set config variables to default values */
CODESTARTinitConfVars
ENDinitConfVars


static rsRetVal writePgSQL(uchar *psz, wrkrInstanceData_t *pData);

BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance

BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;f_hpgsql = NULL;
ENDcreateWrkrInstance


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if (eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


/* The following function is responsible for closing a
 * PgSQL connection.
 */
static void closePgSQL(wrkrInstanceData_t *pWrkrData)
{
	assert(pWrkrData != NULL);

	if (pWrkrData-&gt;f_hpgsql != NULL) {  /* just to be on the safe side... */
		PQfinish(pWrkrData-&gt;f_hpgsql);
		pWrkrData-&gt;f_hpgsql = NULL;
	}
}

BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;tpl);
ENDfreeInstance

BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	closePgSQL(pWrkrData);
ENDfreeWrkrInstance

BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	/* nothing special here */
ENDdbgPrintInstInfo


/* log a database error with descriptive message.
 * We check if we have a valid handle. If not, we simply
 * report an error, but can not be specific. RGerhards, 2007-01-30
 */
static void reportDBError(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	char errMsg[512];
	ConnStatusType ePgSQLStatus;

	assert(pWrkrData != NULL);
	bSilent = 0;

	/* output log message */
	errno = 0;
	if (pWrkrData-&gt;f_hpgsql == NULL) {
		LogError(0, NO_ERRCODE, "unknown DB error occurred - could not obtain PgSQL handle");
	} else { /* we can ask pgsql for the error description... */
		ePgSQLStatus = PQstatus(pWrkrData-&gt;f_hpgsql);
		snprintf(errMsg, sizeof(errMsg), "db error (%d): %s\n", ePgSQLStatus,
				PQerrorMessage(pWrkrData-&gt;f_hpgsql));
		if (bSilent || ePgSQLStatus == pWrkrData-&gt;eLastPgSQLStatus)
			dbgprintf("pgsql, DBError(silent): %s\n", errMsg);
		else {
			pWrkrData-&gt;eLastPgSQLStatus = ePgSQLStatus;
			LogError(0, NO_ERRCODE, "%s", errMsg);
		}
	}

	return;
}


/* The following function is responsible for initializing a
 * PgSQL connection.
 */
static rsRetVal initPgSQL(wrkrInstanceData_t *pWrkrData, int bSilent)
{
	int sslStatus;
	instanceData *pData;
	DEFiRet;

	pData = pWrkrData-&gt;pData;
	assert(pData != NULL);
	assert(pWrkrData-&gt;f_hpgsql == NULL);

	if (strlen(pData-&gt;conninfo) &gt; 0) {
		/* Don't log the whole connection string, because it contains the DB password */
		dbgprintf("initPgSQL: using connection string provided by conninfo\n");
		pWrkrData-&gt;f_hpgsql = PQconnectdb(pData-&gt;conninfo);
	} else {
		dbgprintf("initPgSQL: host=%s port=%d dbname=%s uid=%s\n", pData-&gt;srv, pData-&gt;port,
		                                                           pData-&gt;dbname, pData-&gt;user);

		/* Force PostgreSQL to use ANSI-SQL conforming strings, otherwise we may
		 * get all sorts of side effects (e.g.: backslash escapes) and warnings
		 *
		 * Note: PostgreSQL versions since 9.3 have this already on by default.
		 */
		const char *PgConnectionOptions = "-c standard_conforming_strings=on";

		/* Connect to database */
		char port[6];
		snprintf(port, sizeof(port), "%d", pData-&gt;port);

		pWrkrData-&gt;f_hpgsql = PQsetdbLogin(pData-&gt;srv, port, PgConnectionOptions, NULL,
		                                   pData-&gt;dbname, pData-&gt;user, pData-&gt;pass);
	}

	if (pWrkrData-&gt;f_hpgsql == NULL) {
		reportDBError(pWrkrData, bSilent);
		closePgSQL(pWrkrData); /* ignore any error we may get */
		iRet = RS_RET_SUSPENDED;
	}

#ifdef HAVE_PGSSLINUSE
	sslStatus = PQsslInUse(pWrkrData-&gt;f_hpgsql);
#else
	sslStatus = PQgetssl(pWrkrData-&gt;f_hpgsql) == NULL ? 0 : 1;
#endif
	dbgprintf("initPgSQL: ssl status: %d\n", sslStatus);

	RETiRet;
}


/* try the insert into postgres and return if that failed or not
 * (1 = had error, 0=ok). We do not use the standard IRET calling convention
 * rgerhards, 2009-04-17
 */
static int
tryExec(uchar *pszCmd, wrkrInstanceData_t *pWrkrData)
{
	PGresult *pgRet;
	ExecStatusType execState;
	int bHadError = 0;

	/* try insert */
	pgRet = PQexec(pWrkrData-&gt;f_hpgsql, (char*)pszCmd);
	execState = PQresultStatus(pgRet);
	if (execState != PGRES_COMMAND_OK &amp;&amp; execState != PGRES_TUPLES_OK) {
		dbgprintf("postgres query execution failed: %s\n", PQresStatus(PQresultStatus(pgRet)));
		bHadError = 1;
	}
	PQclear(pgRet);

	return(bHadError);
}


/* The following function writes the current log entry
 * to an established PgSQL session.
 * Enhanced function to take care of the returned error
 * value (if there is such). Note that this may happen due to
 * a sql format error - connection aborts were properly handled
 * before my patch. -- rgerhards, 2009-04-17
 */
static rsRetVal
writePgSQL(uchar *psz, wrkrInstanceData_t *pWrkrData)
{
	int bHadError = 0;
	DEFiRet;

	assert(psz != NULL);
	assert(pWrkrData != NULL);

	dbgprintf("writePgSQL: %s\n", psz);

	bHadError = tryExec(psz, pWrkrData); /* try insert */

	if (bHadError || (PQstatus(pWrkrData-&gt;f_hpgsql) != CONNECTION_OK)) {
#if 0		/* re-enable once we have transaction support */
		/* error occurred, try to re-init connection and retry */
		int inTransaction = 0;
		if(pData-&gt;f_hpgsql != NULL) {
			PGTransactionStatusType xactStatus = PQtransactionStatus(pData-&gt;f_hpgsql);
			if((xactStatus == PQTRANS_INTRANS) || (xactStatus == PQTRANS_ACTIVE)) {
				inTransaction = 1;
			}
		}
		if ( inTransaction == 0 )
#endif
		{
			closePgSQL(pWrkrData); /* close the current handle */
			CHKiRet(initPgSQL(pWrkrData, 0)); /* try to re-open */
			bHadError = tryExec(psz, pWrkrData); /* retry */
		}
		if(bHadError || (PQstatus(pWrkrData-&gt;f_hpgsql) != CONNECTION_OK)) {
			/* we failed, giving up for now */
			reportDBError(pWrkrData, 0);
			closePgSQL(pWrkrData); /* free ressources */
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	}

finalize_it:
	if (iRet == RS_RET_OK) {
		pWrkrData-&gt;eLastPgSQLStatus = CONNECTION_OK; /* reset error for error supression */
	}

	RETiRet;
}


BEGINtryResume
CODESTARTtryResume
	if (pWrkrData-&gt;f_hpgsql == NULL) {
		iRet = initPgSQL(pWrkrData, 1);
		if (iRet == RS_RET_OK) {
			/* the code above seems not to actually connect to the database. As such, we do a
			 * dummy statement (a pointless select...) to verify the connection and return
			 * success only when that statemetn succeeds. Note that I am far from being a
			 * PostgreSQL expert, so any patch that does the desired result in a more
			 * intelligent way is highly welcome. -- rgerhards, 2009-12-16
			 */
			iRet = writePgSQL((uchar*)"select 'a' as a", pWrkrData);
		}
	}
ENDtryResume


BEGINbeginTransaction
CODESTARTbeginTransaction
ENDbeginTransaction


BEGINcommitTransaction
CODESTARTcommitTransaction
	dbgprintf("ompgsql: beginTransaction\n");
	if (pWrkrData-&gt;f_hpgsql == NULL)
		initPgSQL(pWrkrData, 0);
	CHKiRet(writePgSQL((uchar*) "BEGIN", pWrkrData)); /* TODO: make user-configurable */

	for (unsigned i = 0 ; i &lt; nParams ; ++i) {
		iRet = writePgSQL(actParam(pParams, 1, i, 0).param, pWrkrData);
		if (iRet != RS_RET_OK
			&amp;&amp; iRet != RS_RET_DEFER_COMMIT
			&amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED) {
			/*if(mysql_rollback(pWrkrData-&gt;hmysql) != 0) {
				DBGPRINTF("ommysql: server error: transaction could not be rolled back\n");
			}*/
			// closeMySQL(pWrkrData);
			// FINALIZE;
		}
	}

	CHKiRet(writePgSQL((uchar*) "COMMIT", pWrkrData)); /* TODO: make user-configurable */

finalize_it:
	if (iRet == RS_RET_OK) {
		pWrkrData-&gt;eLastPgSQLStatus = CONNECTION_OK; /* reset error for error supression */
	}

ENDcommitTransaction


static inline void
setInstParamDefaults(instanceData *pData)
{
	pData-&gt;tpl           = NULL;
	pData-&gt;multi_row     = 100;
	pData-&gt;trans_commit  = 100;
	pData-&gt;trans_age     = 60;
	pData-&gt;port          = 5432;
	strcpy(pData-&gt;user, "postgres");
	strcpy(pData-&gt;pass, "postgres");
}

BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
<a name="3"></a>	char *cstr;
	size_t len;
CODESTARTnewActInst
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);

	CODE_STD_STRING_REQUESTparseSelectorAct(1)
	for (i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if (!pvals[i].bUsed)
			continue;
		if (!strcmp(actpblk.descr[i].name, "server")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;srv)-1) {
				parser_errmsg("ompgsql: srv parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;srv)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;srv, cstr, len+1);
			free(cstr);
		} else if (!strcmp(actpblk.descr[i].name, "port")) {
			pData-&gt;port = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "serverport")) {
			pData-&gt;port = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "multirows")) {
<a name="2"></a>			pData-&gt;multi_row = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "trans_size")) {
			pData-&gt;trans_commit = (int) pvals[i].val.d.n;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if (!strcmp(actpblk.descr[i].name, "trans_age")) {
			pData-&gt;trans_age = (int) pvals[i].val.d.n;
		} else if (!strcmp(actpblk.descr[i].name, "db")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;dbname)-1) {
				parser_errmsg("ompgsql: db parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;dbname)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;dbname, cstr, len+1);
			free(cstr);
		} else if (   !strcmp(actpblk.descr[i].name, "user")
		           || !strcmp(actpblk.descr[i].name, "uid")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;user)-1) {
				parser_errmsg("ompgsql: user/uid parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;user)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;user, cstr, len+1);
			free(cstr);
		} else if (   !strcmp(actpblk.descr[i].name, "pass")
		           || !strcmp(actpblk.descr[i].name, "pwd")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;pass)-1) {
				parser_errmsg("ompgsql: pass/pwd parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;pass)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
<a name="1"></a>			}
			memcpy(pData-&gt;pass, cstr, len+1);
			free(cstr);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if (!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tpl = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if (!strcmp(actpblk.descr[i].name, "conninfo")) {
			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			len = es_strlen(pvals[i].val.d.estr);
			if(len &gt;= sizeof(pData-&gt;conninfo)-1) {
				parser_errmsg("ompgsql: conninfo parameter longer than supported "
					"maximum of %d characters", (int)sizeof(pData-&gt;conninfo)-1);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
			memcpy(pData-&gt;conninfo, cstr, len+1);
			free(cstr);
		} else {
			dbgprintf("ompgsql: program error, non-handled "
				"param '%s'\n", actpblk.descr[i].name);
		}
	}

	if (strlen(pData-&gt;conninfo) == 0 &amp;&amp; (strlen(pData-&gt;srv) == 0 || strlen(pData-&gt;dbname) == 0)) {
		parser_errmsg("ompgsql: must provide conninfo or server and dbname");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if (pData-&gt;tpl == NULL) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup(" StdPgSQLFmt"),     OMSR_RQD_TPL_OPT_SQL));
	} else {
		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup((char*) pData-&gt;tpl), OMSR_RQD_TPL_OPT_SQL));
	}

CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst

BEGINparseSelectorAct
	int iPgSQLPropErr = 0;
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	/* first check if this config line is actually for us
	 * The first test [*p == '&gt;'] can be skipped if a module shall only
	 * support the newer slection syntax [:modname:]. This is in fact
	 * recommended for new modules. Please note that over time this part
	 * will be handled by rsyslogd itself, but for the time being it is
	 * a good compromise to do it at the module level.
	 * rgerhards, 2007-10-15
	 */

	if (!strncmp((char*) p, ":ompgsql:", sizeof(":ompgsql:") - 1))
		p += sizeof(":ompgsql:") - 1; /* eat indicator sequence (-1 because of '\0'!) */
	else
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);

	/* ok, if we reach this point, we have something for us */
	if ((iRet = createInstance(&amp;pData)) != RS_RET_OK)
		goto finalize_it;
	setInstParamDefaults(pData);

	/* sur5r 2007-10-18: added support for PgSQL
	 * :ompgsql:server,dbname,userid,password
	 * Now we read the PgSQL connection properties
	 * and verify that the properties are valid.
	 */
	if (getSubString(&amp;p, pData-&gt;srv, MAXHOSTNAMELEN+1, ','))
		iPgSQLPropErr++;
	dbgprintf("%p:%s\n",p,p);
	if (*pData-&gt;srv == '\0')
		iPgSQLPropErr++;
	if (getSubString(&amp;p, pData-&gt;dbname, _DB_MAXDBLEN+1, ','))
		iPgSQLPropErr++;
	if (*pData-&gt;dbname == '\0')
		iPgSQLPropErr++;
	if (getSubString(&amp;p, pData-&gt;user, _DB_MAXUNAMELEN+1, ','))
		iPgSQLPropErr++;
	if (*pData-&gt;user == '\0')
		iPgSQLPropErr++;
	if (getSubString(&amp;p, pData-&gt;pass, _DB_MAXPWDLEN+1, ';'))
		iPgSQLPropErr++;
	/* now check for template
	 * We specify that the SQL option must be present in the template.
	 * This is for your own protection (prevent sql injection).
	 */
	if (*(p - 1) == ';') {
		p--;
		CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*) pData-&gt;tpl));
	} else {
		CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*)" StdPgSQLFmt"));
	}

	/* If we detect invalid properties, we disable logging,
	 * because right properties are vital at this place.
	 * Retries make no sense.
	 */
	if (iPgSQLPropErr) {
		LogError(0, RS_RET_INVALID_PARAMS, "Trouble with PgSQL connection properties. "
				"-PgSQL logging disabled");
		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
	}

CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct

BEGINmodExit
CODESTARTmodExit
ENDmodExit


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMODTX_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
/* CODEqueryEtryPt_TXIF_OMOD_QUERIES currently no TX support! */ /* we support the transactional interface! */
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	if (!bCoreSupportsBatching) {
		LogError(0, NO_ERRCODE, "ompgsql: rsyslog core too old");
		ABORT_FINALIZE(RS_RET_ERR);
	}
ENDmodInit

/* vi:set ai: */
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imhiredis.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* imhiredis.c
* Copyright 2021 aDvens
*
* This file is contrib for rsyslog.
* This input plugin is a log consumer from REDIS
* See README for doc
*
*
* This program is free software: you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public License
* as published by the Free Software Foundation, either version 3 of
* the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this program. If not, see
* &lt;http://www.gnu.org/licenses/&gt;.
*
* Author: Jérémie Jourdin
* &lt;jeremie.jourdin@advens.fr&gt;
*/

#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;hiredis/hiredis.h&gt;
#include &lt;hiredis/async.h&gt;
#include &lt;hiredis/adapters/libevent.h&gt;
#include &lt;event2/thread.h&gt;

#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "atomic.h"
#include "statsobj.h"
#include "unicode-helper.h"
#include "prop.h"
#include "ruleset.h"
#include "glbl.h"
#include "cfsysline.h"
#include "msg.h"
#include "dirty.h"

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("imhiredis")

/* static data */
DEF_IMOD_STATIC_DATA
#define QUEUE_BATCH_SIZE 10
#define IMHIREDIS_MODE_QUEUE 1
#define IMHIREDIS_MODE_SUBSCRIBE 2
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)


typedef struct redisNode_s {
	sbool isMaster;
	sbool usesSocket;
	uchar *socketPath;
	uchar *server;
	int port;
	struct redisNode_s *next;
} redisNode;


struct instanceConf_s {
	uchar *password;
	uchar *key;
	uchar *modeDescription;
	int mode;
	sbool useLPop;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */

	redisContext *conn;
	redisAsyncContext *aconn;
	struct event_base *evtBase;

	redisNode *currentNode; /* currently used redis node, can be any of the nodes in the redisNodesList list */
	/* the list of seen nodes
	 * the preferred node (the one from configuration) will always be the first element
	 * second one is a master (if preferred one is unavailable/replica) or a replica, others are replicas
	 * the preferred node may appear twice, but it is accepted
	 */
	redisNode *redisNodesList;

	struct instanceConf_s *next;
};


struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
};

/* The following structure controls the worker threads. Global data is
 * needed for their access.
 */
static struct imhiredisWrkrInfo_s {
	pthread_t tid;		/* the worker's thread ID */
	instanceConf_t *inst;	/* Pointer to imhiredis instance */
} *imhiredisWrkrInfo;


/* GLOBAL DATA */
pthread_attr_t wrkrThrdAttr;	/* Attribute for worker threads ; read only after startup */

static int activeHiredisworkers = 0;
static char *redis_replies[] = {"unknown", "string", "array", "integer", "nil", "status", "error"};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this input */


/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
<a name="0"></a>
/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "socketPath", eCmdHdlrGetWord, 0 },
	{ "server", eCmdHdlrGetWord, 0 },
	{ "port", eCmdHdlrInt, 0 },
	{ "password", eCmdHdlrGetWord, 0 },
	{ "mode", eCmdHdlrGetWord, 0 },
	{ "key", eCmdHdlrGetWord, 0 },
	{ "uselpop", eCmdHdlrBinary, 0 },
	{ "ruleset", eCmdHdlrString, 0 },
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};</b></font>

struct timeval glblRedisConnectTimeout = { 3, 0 }; /* 3 seconds */


#include "im-helper.h" /* must be included AFTER the type definitions! */


/* forward references */
static void redisAsyncRecvCallback (redisAsyncContext __attribute__((unused)) *c, void *reply, void *inst_obj);
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status);
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status);
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message);
rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password);
rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password);
rsRetVal redisActualizeCurrentNode(instanceConf_t *inst);
rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result);
rsRetVal redisAuthenticate(instanceConf_t *inst);
rsRetVal redisConnectSync(redisContext **conn, redisNode *node);
rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node);
rsRetVal redisDequeue(instanceConf_t *inst);
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me);
void workerLoopQueue(struct imhiredisWrkrInfo_s *me);
static void *imhirediswrkr(void *myself);
static rsRetVal createRedisNode(redisNode **root);
rsRetVal copyNode(redisNode *src, redisNode **dst);
redisNode *freeNode(redisNode *node);
void insertNodeAfter(redisNode *root, redisNode *elem);
void dbgPrintNode(redisNode *node);


/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	DEFiRet;
	instanceConf_t *inst;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));

	inst-&gt;next = NULL;
	inst-&gt;password = NULL;
	inst-&gt;key = NULL;
	inst-&gt;mode = 0;
	inst-&gt;useLPop = 0;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pBindRuleset = NULL;

	/* Redis objects */
	inst-&gt;conn = NULL;
	inst-&gt;aconn = NULL;

	/* redis nodes list */
	CHKiRet(createRedisNode(&amp;(inst-&gt;redisNodesList)));
	inst-&gt;currentNode = inst-&gt;redisNodesList;

	/* libevent base for async connection */
	inst-&gt;evtBase = NULL;

	/* node created, let's add to config */
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}

/* this function checks instance parameters and does some required pre-processing
 */
static rsRetVal ATTR_NONNULL()
checkInstance(instanceConf_t *const inst)
{
	DEFiRet;
	/* first node should be created from configuration */
	assert(inst-&gt;redisNodesList != NULL);

	/* check and print redis connection settings */
	if (inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath != NULL) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: both 'server' and 'socketPath' are given, "
								"ignoring 'socketPath'.");
		free(inst-&gt;redisNodesList-&gt;socketPath);
		inst-&gt;redisNodesList-&gt;socketPath = NULL;
	}

	if(inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;server[0] != '\0') {
		if (inst-&gt;redisNodesList-&gt;port == 0) {
			LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: port not set, setting default 6379");
			inst-&gt;redisNodesList-&gt;port = 6379;
		}
		DBGPRINTF("imhiredis: preferred server is %s (%d)\n",
			inst-&gt;redisNodesList-&gt;server,
			inst-&gt;redisNodesList-&gt;port);
		inst-&gt;redisNodesList-&gt;usesSocket = 0;
	}
	else if(inst-&gt;redisNodesList-&gt;socketPath != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath[0] != '\0') {
		DBGPRINTF("imhiredis: preferred server is %s\n",
			inst-&gt;redisNodesList-&gt;socketPath);
		inst-&gt;redisNodesList-&gt;usesSocket = 1;
	} else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: neither 'server' nor 'socketPath' are defined!");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	if (inst-&gt;key != NULL) {
		DBGPRINTF("imhiredis: key/channel is '%s'\n", inst-&gt;key);
	} else {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: no key defined !");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	if (inst-&gt;mode != IMHIREDIS_MODE_QUEUE &amp;&amp; inst-&gt;mode != IMHIREDIS_MODE_SUBSCRIBE) {
		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: invalid mode, please choose 'subscribe' or 'queue' mode.");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}

	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;useLPop) {
		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: 'uselpop' set with mode = subscribe : ignored.");

	}

	if (inst-&gt;password != NULL) {
		DBGPRINTF("imhiredis: password is '%s'\n", inst-&gt;password);
	}

	// set default current node as first node in list (preferred node)
	inst-&gt;currentNode = inst-&gt;redisNodesList;
	// search master node (should be either preferred node or its master)
	if (RS_RET_OK != redisActualizeCurrentNode(inst) || inst-&gt;currentNode == NULL) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to a valid master!");
	}

finalize_it:
	RETiRet;
}

/* function to generate an error message if the ruleset cannot be found */
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, "imhiredis: ruleset '%s' not found - "
		"using default ruleset instead",
		inst-&gt;pszBindRuleset);
}


BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
	int i;
CODESTARTnewInpInst
	DBGPRINTF("newInpInst (imhiredis)\n");

	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
<a name="3"></a>		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(Debug) {
		dbgprintf("input param blk in imhiredis:\n");
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));
	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
<a name="1"></a>
		if(!strcmp(inppblk.descr[i].name, "server")) {
			inst-&gt;redisNodesList-&gt;server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "socketPath")) {
<a name="2"></a>			inst-&gt;redisNodesList-&gt;socketPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "port")) {
			inst-&gt;redisNodesList-&gt;port = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "password")) {
			inst-&gt;password = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
		} else if(!strcmp(inppblk.descr[i].name, "uselpop")) {
			inst-&gt;useLPop = pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, "mode")) {
			inst-&gt;modeDescription = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if (!strcmp((const char*)inst-&gt;modeDescription, "queue")) {
				inst-&gt;mode = IMHIREDIS_MODE_QUEUE;
			} else if (!strcmp((const char*)inst-&gt;modeDescription, "subscribe")) {
				inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
			} else {
				LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: unsupported mode "
					"'%s'", inppblk.descr[i].name);
				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
			}
		} else if(!strcmp(inppblk.descr[i].name, "key")) {
			inst-&gt;key = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {
			dbgprintf("imhiredis: program error, non-handled "
				"param '%s'\n", inppblk.descr[i].name);
		}
	}

	DBGPRINTF("imhiredis: checking config sanity\n");
	if (inst-&gt;modeDescription == NULL) {
		CHKmalloc(inst-&gt;modeDescription = (uchar*)strdup("subscribe"));
		inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: \"mode\" parameter not specified "
			"using default redis 'subscribe' mode -- this may not be what you want!");
	}
	if (inst-&gt;key == NULL) {
		LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: \"key\" required parameter not specified!");
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	if(inst-&gt;redisNodesList-&gt;server == NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath == NULL) {
		CHKmalloc(inst-&gt;redisNodesList-&gt;server = (uchar *)strdup("127.0.0.1"));
		inst-&gt;redisNodesList-&gt;port = 6379;
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: no server parameter specified "
			"using default 127.0.0.1:6379 -- this may not be what you want!");
	}
	if (inst-&gt;password == NULL) {
		LogMsg(0, RS_RET_OK, LOG_INFO, "imhiredis: no password specified");
	}

	DBGPRINTF("imhiredis: newInpInst key=%s, mode=%s, uselpop=%d\n",
		inst-&gt;key, inst-&gt;modeDescription, inst-&gt;useLPop);

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad


BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "imhiredis: error processing module "
			"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf("module (global) param blk for imhiredis:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		} else {
			dbgprintf("imhiredis: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad

BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		std_checkRuleset(pModConf, inst);
	}
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
ENDactivateCnfPrePrivDrop

BEGINactivateCnf
CODESTARTactivateCnf
	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		iRet = checkInstance(inst);
		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
			inst-&gt;evtBase = event_base_new();
	}
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
	redisNode *node;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		if (inst-&gt;evtBase)
			event_base_free(inst-&gt;evtBase);
		if (inst-&gt;password != NULL)
			free(inst-&gt;password);
		free(inst-&gt;modeDescription);
		free(inst-&gt;key);
		free(inst-&gt;pszBindRuleset);
		if(inst-&gt;conn != NULL) {
			redisFree(inst-&gt;conn);
			inst-&gt;conn = NULL;
		}
		if(inst-&gt;aconn != NULL) {
			redisAsyncFree(inst-&gt;aconn);
			inst-&gt;aconn = NULL;
		}

		for (node = inst-&gt;redisNodesList; node != NULL; node = freeNode(node)) {;}

		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
ENDfreeCnf


/* Cleanup imhiredis worker threads */
static void
shutdownImhiredisWorkers(void)
{
	int i;
	instanceConf_t *inst;

	assert(imhiredisWrkrInfo != NULL);

	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;aconn) {
			DBGPRINTF("imhiredis: disconnecting async worker\n");
			redisAsyncDisconnect(inst-&gt;aconn);
		}
	}

	// event_base_loopbreak(runModConf-&gt;evtBase);

	DBGPRINTF("imhiredis: waiting on imhiredis workerthread termination\n");
	for(i = 0 ; i &lt; activeHiredisworkers ; ++i) {
		pthread_join(imhiredisWrkrInfo[i].tid, NULL);
		DBGPRINTF("imhiredis: Stopped worker %d\n", i);
	}
	free(imhiredisWrkrInfo);
	imhiredisWrkrInfo = NULL;

	return;
}


/* This function is called to gather input.  */
BEGINrunInput
	int i;
	instanceConf_t *inst;
CODESTARTrunInput
	DBGPRINTF("imhiredis: runInput loop started ...\n");
	activeHiredisworkers = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		++activeHiredisworkers;
	}

	if(activeHiredisworkers == 0) {
		LogError(0, RS_RET_ERR, "imhiredis: no active inputs, input does "
			"not run - there should have been additional error "
			"messages given previously");
		ABORT_FINALIZE(RS_RET_ERR);
	}


	DBGPRINTF("imhiredis: Starting %d imhiredis workerthreads\n", activeHiredisworkers);
	imhiredisWrkrInfo = calloc(activeHiredisworkers, sizeof(struct imhiredisWrkrInfo_s));
	if (imhiredisWrkrInfo == NULL) {
		LogError(errno, RS_RET_OUT_OF_MEMORY, "imhiredis: worker-info array allocation failed.");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}

	/* Start worker threads for each imhiredis input source
	*/
	i = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		/* init worker info structure! */
		imhiredisWrkrInfo[i].inst = inst; /* Set reference pointer */
		pthread_create(&amp;imhiredisWrkrInfo[i].tid, &amp;wrkrThrdAttr, imhirediswrkr, &amp;(imhiredisWrkrInfo[i]));
		i++;
	}

	// This thread simply runs the various threads, then waits for Rsyslog to stop
	while(glbl.GetGlobalInputTermState() == 0) {
		if(glbl.GetGlobalInputTermState() == 0)
			/* Check termination state every 100ms
			 * should be sufficient to grant fast response to shutdown while not hogging CPU
			 */
			srSleep(0, 100000);
	}
	DBGPRINTF("imhiredis: terminating upon request of rsyslog core\n");

	shutdownImhiredisWorkers();
finalize_it:
ENDrunInput


BEGINwillRun
CODESTARTwillRun
	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imhiredis"), sizeof("imhiredis") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun


BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);

ENDafterRun


BEGINmodExit
CODESTARTmodExit
	pthread_attr_destroy(&amp;wrkrThrdAttr);

	/* force cleaning of all libevent-related structures
	 * (clean shutdowns are not always guaranteed without it)
	 */
	libevent_global_shutdown();

	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	/* initialize "read-only" thread attributes */
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);

	/* activate libevent for (p)threads support */
	evthread_use_pthreads();

ENDmodInit


/* ------------------------------ callbacks ------------------------------ */


/**
 *	Asynchronous subscribe callback handler
 */
static void redisAsyncRecvCallback (redisAsyncContext *aconn, void *reply, void __attribute__((unused)) *unused) {
	/*
		redisReply is supposed to be an array of three elements: [''message', &lt;channel&gt;, &lt;message&gt;]


		JJO: For future reference (https://github.com/redis/hiredis/blob/master/README.md)

		Important: the current version of hiredis (1.0.0) frees replies when the asynchronous API is used.
		This means you should not call freeReplyObject when you use this API.
		The reply is cleaned up by hiredis after the callback returns.
		TODO We may have to change this function in the future to free replies.
	*/
	instanceConf_t *const inst = (instanceConf_t *) aconn-&gt;data;
	redisReply * r = (redisReply *) reply;
	if (r == NULL) return;

	if (r-&gt;elements &lt; 3 || r-&gt;element[2]-&gt;str == NULL) {
		return;
	}
	enqMsg(inst, r-&gt;element[2]-&gt;str);

	return;
}


/**
 *	Asynchronous connection callback handler
 */
static void redisAsyncConnectCallback (const redisAsyncContext *c, int status) {
	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): could not connect to redis: "
			"%s", c-&gt;errstr);
		// remove async context from instance config object, still contained in context's 'data' field
		instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
		assert(inst != NULL);
		inst-&gt;aconn = NULL;
		return;
	}
	DBGPRINTF("imhiredis (async): successfully connected!\n");

	return;
}


/**
 *	Asynchronous disconnection callback handler
 */
static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status) {

	// remove context from instance config object (which is stored in the context 'data' field by us)
	// context will be freed by the library, so it's only set to NULL here
	instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
	assert(inst != NULL);
	inst-&gt;aconn = NULL;
	inst-&gt;currentNode = NULL;

	if (status != REDIS_OK) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): got disconnected from redis: "
			"%s", c-&gt;errstr);
		return;
	}
	DBGPRINTF("imhiredis (async): successfully disconnected!\n");

	return;
}


/* ------------------------------ end callbacks ------------------------------ */

/*
 *	sends a ROLE command to the redis pointed by context
 *	context should be a valid redis context
 *	returns a valid redisReply pointer if an array reply was received, NULL otherwise
 */
redisReply *getRole(redisContext *c) {
	redisReply *reply;

	assert(c != NULL);

	reply = redisCommand(c, "ROLE");
	if (reply == NULL) {
		DBGPRINTF("imhiredis: could not get reply from ROLE command\n");
	}
	else if (reply-&gt;type == REDIS_REPLY_ERROR) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis got an error while querying role -&gt; "
			"%s\n", reply-&gt;str);
		freeReplyObject(reply);
		reply = NULL;
	}
	else if (reply-&gt;type != REDIS_REPLY_ARRAY) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: did not get an array from ROLE command");
		freeReplyObject(reply);
		reply = NULL;
	}

	return reply;
}


/*
 *	enqueue the hiredis message. The provided string is
 *	not freed - this must be done by the caller.
 */
static rsRetVal enqMsg(instanceConf_t *const inst, const char *message) {
	DEFiRet;
	smsg_t *pMsg;

	if (message == NULL || message[0] == '\0') {
		/* we do not process empty lines */
		FINALIZE;
	}

	DBGPRINTF("imhiredis: enqMsg: Msg -&gt; '%s'\n", message);

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, message, strlen(message));
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */
	CHKiRet(submitMsg2(pMsg));

finalize_it:
	RETiRet;
}


/*
 *	execute a synchronous authentication using the context conn
 *	conn and password should be non-NULL
 *	conn should be a valid context
 */
rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password) {
	DEFiRet;
	redisReply *reply = NULL;

	assert(conn != NULL);
	assert(password != NULL);
	assert(password[0] != '\0');

	reply = (redisReply *) redisCommand(conn, "AUTH %s", password);
	if (reply == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Could not authenticate!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if (strncmp(reply-&gt;str, "OK", 2)) {
		LogError(0, RS_RET_REDIS_AUTH_FAILED, "imhiredis: Authentication failure -&gt; %s\n", reply-&gt;str);
		ABORT_FINALIZE(RS_RET_REDIS_AUTH_FAILED);
	}

finalize_it:
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}


/*
 *	execute an asynchronous authentication using the context aconn
 *	aconn and password should be non-NULL
 *	aconn should be a valid (async) context
 */
rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password) {
	DEFiRet;

	assert(aconn != NULL);
	assert(password != NULL);
	assert(password[0] != '\0');

	if (REDIS_OK != redisAsyncCommand(aconn, NULL, NULL, "AUTH %s", password)) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: error while authenticating asynchronously -&gt; %s\n",
			aconn-&gt;errstr);
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

finalize_it:
	RETiRet;
}


/*
 *	connect to node, authenticate (if necessary), get role, then get all node information provided by ROLE
 *	node should be a non-NULL valid redisNode pointer
 *	password can be NULL, meaning no authentication will be done
 *	result will hold the result of the ROLE command executed on the node:
 *		- NULL if the node was a single master instance
 *		- a single (master) node if the provided node was a replica
 *		- a list of (replica) nodes if the provided node was a master
 */
rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result) {
	DEFiRet;
	redisContext *context;
	redisReply *reply = NULL, *replica;
	unsigned int i;

	assert(node != NULL);

	CHKiRet(redisConnectSync(&amp;context, node));

	if(password != NULL &amp;&amp; password[0] != '\0') {
		CHKiRet(redisAuthentSynchronous(context, password));
	}

	reply = getRole(context);

	if(reply == NULL) {
		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: did not get the role of the server");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

	/*
	* string comparisons for ROLE could be skipped
	* as each role returns a different number of elements,
	* but lets keep it as a security...
	*/
	if (	reply-&gt;elements == 5 &amp;&amp;
		strncmp(reply-&gt;element[0]-&gt;str, "slave", 5) == 0) {

		CHKiRet(createRedisNode(result));
		(*result)-&gt;server = (uchar *) strdup((const char *)reply-&gt;element[1]-&gt;str);
		(*result)-&gt;port = reply-&gt;element[2]-&gt;integer;
		(*result)-&gt;isMaster = 1;
	}
	else if (	reply-&gt;elements == 3 &amp;&amp;
			reply-&gt;element[2]-&gt;type == REDIS_REPLY_ARRAY &amp;&amp;
			strncmp(reply-&gt;element[0]-&gt;str, "master", 6) == 0) {

		// iterate on all replicas given in the reply (if any)
		for (i = 0; i &lt; reply-&gt;element[2]-&gt;elements; i++) {
			replica = reply-&gt;element[2]-&gt;element[i];

			if (replica-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; replica-&gt;elements == 3) {
				/* node will be a new node every time
				* with old ones shifted in the list
				*/
				CHKiRet(createRedisNode(result));
				(*result)-&gt;server = (uchar *) strdup((const char *)replica-&gt;element[0]-&gt;str);
				// yes, the value in that case is a string and NOT an integer!
				(*result)-&gt;port = atoi(replica-&gt;element[1]-&gt;str);
			}
		}
	} else {
		// we have a sentinel, or a problem
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}

finalize_it:
	if (reply != NULL)
		freeReplyObject(reply);
	if (context != NULL)
		redisFree(context);
	RETiRet;
}



/*
 *	actualize the current master node to use during connection for instance inst
 *	inst should be a valid, non-NULL instanceConf object
 *	inst should also possess at least a single node in inst-&gt;redisNodeList
 *	if the function returns RS_RET_OK, inst-&gt;currentNode and inst-&gt;redisNodeList have been both updated
 *	to reflect new master and potential replicas
 *	the first configured node (called preferred node) is always kept as the first entry in redisNodeList
 */
rsRetVal redisActualizeCurrentNode(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	redisNode *node, *tmp, *newList = NULL;

	assert(inst != NULL);
	assert(inst-&gt;redisNodesList != NULL);

	inst-&gt;currentNode = NULL;
	// keep first node in list = preferred node (comes from configuration)
	copyNode(inst-&gt;redisNodesList, &amp;newList);
	newList-&gt;next = NULL;

	for (node = inst-&gt;redisNodesList; node != NULL; node = node-&gt;next) {
		tmp = NULL;

		DBGPRINTF("imhiredis: trying to connect to node to get info...\n");
		dbgPrintNode(node);

		if (RS_RET_OK == redisGetServersList(node, inst-&gt;password, &amp;tmp)) {
			// server replied

			if (tmp &amp;&amp; tmp-&gt;isMaster) {
				DBGPRINTF("imhiredis: node replied with a master node, is a replica\n");
				// master node, keep it as potential new active node
				inst-&gt;currentNode = tmp;
				tmp = NULL;

				// try to connect to the master and get replicas
				if(RS_RET_OK != redisGetServersList(inst-&gt;currentNode, inst-&gt;password, &amp;tmp)) {

					/* had a master, but cannot connect
					* save suspected master in new list but keep searching with other nodes
					*/
					DBGPRINTF("imhiredis: had a master but cannot connect, keeping in list\n");
					dbgPrintNode(inst-&gt;currentNode);
					insertNodeAfter(newList, inst-&gt;currentNode);
					inst-&gt;currentNode = NULL;
					continue;
				}
			} else {
				DBGPRINTF("imhiredis: node replied with a list of replicas, is a master\n");
				// copy the node to the new currentNode, list owning node will be freed
				node-&gt;isMaster = 1;
				copyNode(node, &amp;(inst-&gt;currentNode));
				inst-&gt;currentNode-&gt;next = NULL;
			}

			/*
			 * here, tmp is a list of replicas or NULL (single node)
			 * inst-&gt;currentNode is the new active master
			 */

			// add the replicas to the list
			if (tmp) {
				insertNodeAfter(newList, tmp);
				DBGPRINTF("imhiredis: inserting replicas to list\n");
				for (tmp = newList-&gt;next; tmp != NULL; tmp = tmp-&gt;next) {
					dbgPrintNode(tmp);
				}
			}
			// insert the master after the preferred node (configuration)
			DBGPRINTF("imhiredis: inserting new master node in list\n");
			dbgPrintNode(inst-&gt;currentNode);
			insertNodeAfter(newList, inst-&gt;currentNode);

			// swap newList and redisNodesList to free old list at the end of the function
			tmp = newList;
			newList = inst-&gt;redisNodesList;
			inst-&gt;redisNodesList = tmp;
			FINALIZE;
		}
	}

	DBGPRINTF("imhiredis: did not find a valid master");
	iRet = RS_RET_NOT_FOUND;
	inst-&gt;currentNode = NULL;

finalize_it:
	if (reply != NULL)
		freeReplyObject(reply);
	// newList is always completely freed
	for (node = newList; node != NULL; ) {
		node = freeNode(node);
	}

	RETiRet;
}


/*
 *	authentication function, for both synchronous and asynchronous modes (queue or subscribe)
 *	inst, inst-&gt;curentMode and inst-&gt;password should not be NULL
 */
rsRetVal redisAuthenticate(instanceConf_t *inst) {
	DEFiRet;
	redisContext *usedContext = NULL;
	redisReply *reply = NULL;

	assert(inst != NULL);
	assert(inst-&gt;currentNode != NULL);
	assert(inst-&gt;password != NULL);
	assert(inst-&gt;password[0] != '\0');

	DBGPRINTF("imhiredis: authenticating...\n");

	// Create a temporary context for synchronous connection, used to validate AUTH command in asynchronous contexts
	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
		if (RS_RET_OK != redisConnectSync(&amp;usedContext, inst-&gt;currentNode)) {
			LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to current "
				"active node synchronously to validate authentication");
			ABORT_FINALIZE(RS_RET_REDIS_ERROR);
		}
	} else {
		usedContext = inst-&gt;conn;
	}

	/*
	 * Try synchronous connection, whatever the method for the instance
	 * This is also done for the asynchronous mode, to validate the successful authentication
	 */
	CHKiRet(redisAuthentSynchronous(usedContext, inst-&gt;password));

	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
		CHKiRet(redisAuthentAsynchronous(inst-&gt;aconn, inst-&gt;password));
	}

	DBGPRINTF("imhiredis: authentication successful\n");

finalize_it:
	if(inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; usedContext)
		redisFree(usedContext);
	if(reply)
		freeReplyObject(reply);
	RETiRet;
}


/*
 *	connection function for synchronous (queue) mode
 *	node should not be NULL
 */
rsRetVal redisConnectSync(redisContext **conn, redisNode *node) {
	DEFiRet;

	assert(node != NULL);

	if (node-&gt;usesSocket)
		*conn = redisConnectUnixWithTimeout((const char *)node-&gt;socketPath, glblRedisConnectTimeout);
	else
		*conn = redisConnectWithTimeout((const char *)node-&gt;server, node-&gt;port, glblRedisConnectTimeout);

	if (*conn == NULL) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
				"-&gt; could not allocate context!\n", node-&gt;socketPath);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -&gt; could not allocate context!\n", node-&gt;server, node-&gt;port);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}
	else if ((*conn)-&gt;err) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
				"-&gt; %s\n", node-&gt;socketPath, (*conn)-&gt;errstr);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
				"port %d -&gt; %s\n", node-&gt;server, node-&gt;port, (*conn)-&gt;errstr);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		if (*conn)
			redisFree(*conn);
		*conn = NULL;
	}
	RETiRet;
}


/*
 *	connection function for asynchronous (subscribe) mode
 *	node should not be NULL
 */
rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node) {
	DEFiRet;

	assert(node != NULL);

	if (node-&gt;usesSocket)
		*aconn = redisAsyncConnectUnix((const char*)node-&gt;socketPath);
	else
		*aconn = redisAsyncConnect((const char *)node-&gt;server, node-&gt;port);

	if(*aconn == NULL) {
		LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): could not allocate context!\n");
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	} else if ((*aconn)-&gt;err) {
		if (node-&gt;usesSocket) {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s' "
				"-&gt; %s\n", node-&gt;socketPath, (*aconn)-&gt;errstr);
		} else {
			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s', port '%d' "
				"-&gt; %s\n", node-&gt;server, node-&gt;port, (*aconn)-&gt;errstr);
		}
		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
	}

finalize_it:
	if (iRet != RS_RET_OK) {
		if(*aconn)
			redisAsyncFree(*aconn);
		*aconn = NULL;
	}
	RETiRet;
}

/*
 *	dequeue all entries in the redis list, using batches of 10 commands
 */
rsRetVal redisDequeue(instanceConf_t *inst) {
	DEFiRet;
	redisReply *reply = NULL;
	uint replyType = 0, i;

	assert(inst != NULL);

	DBGPRINTF("imhiredis: beginning to dequeue key '%s'\n", inst-&gt;key);

	do {
		// append a batch of QUEUE_BATCH_SIZE POP commands (either LPOP or RPOP depending on conf)
		if (inst-&gt;useLPop == 1) {
			DBGPRINTF("imhiredis: Queuing #%d LPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst-&gt;key);
			for (i=0; i&lt;QUEUE_BATCH_SIZE; ++i ) {
				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "LPOP %s", inst-&gt;key))
					break;
			}
		} else {
			DBGPRINTF("imhiredis: Queuing #%d RPOP commands on key '%s' \n",
					QUEUE_BATCH_SIZE,
					inst-&gt;key);
			for (i=0; i&lt;QUEUE_BATCH_SIZE; i++) {
				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "RPOP %s", inst-&gt;key))
					break;
			}
		}

		// parse responses from appended commands
		do {
			if (REDIS_OK != redisGetReply(inst-&gt;conn, (void **) &amp;reply)) {
				// error getting reply, must stop
				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Error reading reply after POP #%d on key "
								"'%s'", (QUEUE_BATCH_SIZE - i), inst-&gt;key);
				ABORT_FINALIZE(RS_RET_REDIS_ERROR);
			} else {
				if (reply != NULL) {
					replyType = reply-&gt;type;
					switch(replyType) {
						case REDIS_REPLY_STRING:
							enqMsg(inst, reply-&gt;str);
							break;
						case REDIS_REPLY_NIL:
							// replies are dequeued but are empty = end of list
							break;
						case REDIS_REPLY_ERROR:
							// There is a problem with the key or the Redis instance
							LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: error "
							"while POP'ing key '%s' -&gt; %s", inst-&gt;key, reply-&gt;str);
							ABORT_FINALIZE(RS_RET_REDIS_ERROR);
						default:
							LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: unexpected "
							"reply type: %s", redis_replies[replyType%7]);
					}
					freeReplyObject(reply);
					reply = NULL;
				} else { /* reply == NULL */
					LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: unexpected empty reply "
						"for successful return");
					ABORT_FINALIZE(RS_RET_REDIS_ERROR);
				}
			}

		// while there are replies to unpack, continue
		} while (--i &gt; 0);

	// while input can run and last reply was a string, continue with a new batch
	} while (replyType == REDIS_REPLY_STRING &amp;&amp; glbl.GetGlobalInputTermState() == 0);

	DBGPRINTF("imhiredis: finished to dequeue key '%s'\n", inst-&gt;key);

finalize_it:
	if (reply)
		freeReplyObject(reply);
	RETiRet;
}


/*
 *	worker function for asynchronous (subscribe) mode
 */
void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis (async): beginning of subscribe worker loop...\n");

	// Connect first time without delay
	if (me-&gt;inst-&gt;currentNode != NULL) {
		if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
			me-&gt;inst-&gt;currentNode = NULL;
		}
		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {

			redisAsyncFree(me-&gt;inst-&gt;aconn);
			me-&gt;inst-&gt;aconn = NULL;
			me-&gt;inst-&gt;currentNode = NULL;
		}

		// finalize context creation
		me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
		redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
		redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
		redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
	}

	while(glbl.GetGlobalInputTermState() == 0) {
		if (me-&gt;inst-&gt;aconn == NULL) {
			/*
			 * Sleep 10 seconds before attempting to resume a broken connexion
			 * (sleep small amounts to avoid missing termination status)
			 */
			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
			for(i = 0; i &lt; 100; i++) {
				// Rsyslog asked for shutdown, thread should be stopped
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				// 100ms sleeps
				srSleep(0, 100000);
			}

			// search the current master node
			if (me-&gt;inst-&gt;currentNode == NULL) {
				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
					continue;
			}

			// connect to current master
			if(me-&gt;inst-&gt;currentNode != NULL) {
				if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {

					redisAsyncFree(me-&gt;inst-&gt;aconn);
					me-&gt;inst-&gt;aconn = NULL;
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
			}

			// finalize context creation
			me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
			redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
			redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
			redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
		}
		if (me-&gt;inst-&gt;aconn != NULL) {
			DBGPRINTF("imhiredis (async): subscribing to channel '%s'\n", me-&gt;inst-&gt;key);
			redisAsyncCommand(
				me-&gt;inst-&gt;aconn,
				redisAsyncRecvCallback,
				NULL,
				"SUBSCRIBE %s",
				me-&gt;inst-&gt;key);
			event_base_dispatch(me-&gt;inst-&gt;evtBase);
		}
	}

end_loop:
	return;
}


/*
 *	worker function for synchronous (queue) mode
 */
void workerLoopQueue(struct imhiredisWrkrInfo_s *me) {
	uint i;
	DBGPRINTF("imhiredis: beginning of queue worker loop...\n");
	// Connect first time without delay
	if (me-&gt;inst-&gt;currentNode != NULL) {
		if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
			me-&gt;inst-&gt;currentNode = NULL;
		}
		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {

			redisFree(me-&gt;inst-&gt;conn);
			me-&gt;inst-&gt;conn = NULL;
			me-&gt;inst-&gt;currentNode = NULL;
		}
	}

	while(glbl.GetGlobalInputTermState() == 0) {
		if (me-&gt;inst-&gt;conn == NULL) {
			/* Sleep 10 seconds before attempting to resume a broken connexion
			 * (sleep small amounts to avoid missing termination status)
			 */
			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
			for(i = 0; i &lt; 100; i++) {
				// Time to stop the thread
				if (glbl.GetGlobalInputTermState() != 0)
					goto end_loop;
				// 100ms sleeps
				srSleep(0, 100000);
			}

			// search the current master node
			if (me-&gt;inst-&gt;currentNode == NULL) {
				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
					continue;
			}

			// connect to current master
			if(me-&gt;inst-&gt;currentNode != NULL) {
				if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {

					redisFree(me-&gt;inst-&gt;conn);
					me-&gt;inst-&gt;conn = NULL;
					me-&gt;inst-&gt;currentNode = NULL;
					continue;
				}
			}
		}
		if (me-&gt;inst-&gt;conn != NULL) {
			if (redisDequeue(me-&gt;inst) == RS_RET_REDIS_ERROR) {
				DBGPRINTF("imhiredis: current connection invalidated\n");
				redisFree(me-&gt;inst-&gt;conn);
				me-&gt;inst-&gt;currentNode = NULL;
				me-&gt;inst-&gt;conn = NULL;
			}
			if(glbl.GetGlobalInputTermState() == 0) {
				/* sleep 1s between 2 POP tries
				* this does NOT limit dequeing rate, but prevents the input from polling Redis too often
				*/
				for(i = 0; i &lt; 10; i++) {
					// Time to stop the thread
					if (glbl.GetGlobalInputTermState() != 0)
						goto end_loop;
					// 100ms sleeps
					srSleep(0, 100000);
				}
			}
		}
	}

end_loop:
	return;
}


/*
 *	Workerthread function for a single hiredis consumer
 */
static void *
imhirediswrkr(void *myself)
{
	struct imhiredisWrkrInfo_s *me = (struct imhiredisWrkrInfo_s*) myself;
	DBGPRINTF("imhiredis: started hiredis consumer workerthread\n");
	dbgPrintNode(me-&gt;inst-&gt;currentNode);

	if(me-&gt;inst-&gt;mode == IMHIREDIS_MODE_QUEUE)
		workerLoopQueue(me);
	else if (me-&gt;inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
		workerLoopSubscribe(me);

	DBGPRINTF("imhiredis: stopped hiredis consumer workerthread\n");
	return NULL;
}



// -------------------------- redisNode functions -----------------------------------

/*
 *	create a redisNode and set default values
 *	if a valid node is given as parameter, the new node is inserted as the new head of the linked list
 */
static rsRetVal
createRedisNode(redisNode **root) {
	redisNode *node;
	DEFiRet;
	CHKmalloc(node = malloc(sizeof(redisNode)));
	node-&gt;port = 0;
	node-&gt;server = NULL;
	node-&gt;socketPath = NULL;
	node-&gt;usesSocket = 0;
	node-&gt;isMaster = 0;
	node-&gt;next = NULL;

	if (!root) {
		*root = node;
	} else {
		node-&gt;next = (*root);
		*root = node;
	}

finalize_it:
	RETiRet;
}

/*
 *	make a complete copy of the src node into the newly-created node in dst
 *	if dst already contains a node, the new node will be added as the new head of the provided list
 *	src should not be NULL
 */
rsRetVal copyNode(redisNode *src, redisNode **dst) {
	DEFiRet;

	assert(src != NULL);

	CHKiRet(createRedisNode(dst));

	(*dst)-&gt;isMaster = src-&gt;isMaster;
	(*dst)-&gt;next = src-&gt;next;
	(*dst)-&gt;port = src-&gt;port;
	(*dst)-&gt;usesSocket = src-&gt;usesSocket;

	if (src-&gt;server)
		(*dst)-&gt;server = (uchar *) strdup((const char *)src-&gt;server);
	if (src-&gt;socketPath)
		(*dst)-&gt;socketPath = (uchar *) strdup((const char *)src-&gt;socketPath);

finalize_it:
	RETiRet;
}

/*
 *	free all ressources of the node
 *	will return next node if one is present, NULL otherwise
 */
redisNode *freeNode(redisNode *node) {
	redisNode *ret = NULL;
	if (node != NULL) {
		if (node-&gt;next != NULL)
			ret = node-&gt;next;

		if(node-&gt;server != NULL)
			free(node-&gt;server);
		if(node-&gt;socketPath != NULL)
			free(node-&gt;socketPath);
		free(node);
	}

	return ret;
}

/*
 *	insert node 'elem' after node 'root' in the linked list
 *	both root and elem should not be NULL
 */
void insertNodeAfter(redisNode *root, redisNode *elem) {
	assert(root != NULL);
	assert(elem != NULL);

	if(root-&gt;next != NULL) {
		elem-&gt;next = root-&gt;next;
	}
	root-&gt;next = elem;

	return;
}

void dbgPrintNode(redisNode *node) {
	if (node != NULL) {
		if (node-&gt;usesSocket) {
			if (node-&gt;isMaster) {
				DBGPRINTF("imhiredis: node is %s (master)\n", node-&gt;socketPath);
			} else {
				DBGPRINTF("imhiredis: node is %s (replica)\n", node-&gt;socketPath);
			}
		} else {
			if (node-&gt;isMaster) {
				DBGPRINTF("imhiredis: node is %s:%d (master)\n", node-&gt;server, node-&gt;port);
			} else {
				DBGPRINTF("imhiredis: node is %s:%d (replica)\n", node-&gt;server, node-&gt;port);
			}
		}
	}
	return;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
