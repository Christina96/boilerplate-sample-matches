<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for ompgsql.c &amp; imhiredis.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for ompgsql.c &amp; imhiredis.c
      </h3>
<h1 align="center">
        8.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>ompgsql.c (15.968586%)<th>imhiredis.c (5.7009344%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(87-102)<td><a href="#" name="0">(146-159)</a><td align="center"><font color="#ff0000">25</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(454-457)<td><a href="#" name="1">(333-336)</a><td align="center"><font color="#7a0000">12</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(420-423)<td><a href="#" name="2">(337-340)</a><td align="center"><font color="#7a0000">12</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(391-403)<td><a href="#" name="3">(321-332)</a><td align="center"><font color="#7a0000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ompgsql.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;assert.h&gt;
8 #include &lt;signal.h&gt;
9 #include &lt;errno.h&gt;
10 #include &lt;time.h&gt;
11 #include &lt;netdb.h&gt;
12 #include &lt;libpq-fe.h&gt;
13 #include "conf.h"
14 #include "syslogd-types.h"
15 #include "srUtils.h"
16 #include "template.h"
17 #include "module-template.h"
18 #include "errmsg.h"
19 #include "parserif.h"
20 MODULE_TYPE_OUTPUT
21 MODULE_TYPE_NOKEEP
22 MODULE_CNFNAME("ompgsql")
23 DEF_OMOD_STATIC_DATA
24 typedef struct _instanceData {
25 	char            dbname[_DB_MAXDBLEN+1];         	char            user[_DB_MAXUNAMELEN+1];        	char            pass[_DB_MAXPWDLEN+1];          	char            conninfo[_DB_MAXCONNINFOLEN+1]; 	unsigned int    trans_age;
26 	unsigned int    trans_commit;
27 	unsigned short  multi_row;
28 	int             port;
29 	uchar          *tpl;                      } instanceData;
30 typedef struct wrkrInstanceData {
31 	instanceData   *pData;
32 	PGconn         *f_hpgsql;                	ConnStatusType  eLastPgSQLStatus;        } wrkrInstanceData_t;
33 static struct cnfparamdescr actpdescr[] = {
34 	{ "server",     eCmdHdlrGetWord, 0 },
35 	{ "db",         eCmdHdlrGetWord, 0 },
36 <a name="0"></a>	{ "user",       eCmdHdlrGetWord, 0 },
37 	{ "uid",        eCmdHdlrGetWord, 0 },
38 	{ "pass",       eCmdHdlrGetWord, 0 },
39 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "pwd",        eCmdHdlrGetWord, 0 },
40 	{ "multirows",  eCmdHdlrInt,     0 },
41 	{ "trans_size", eCmdHdlrInt,     0 },
42 	{ "trans_age",  eCmdHdlrInt,     0 },
43 	{ "serverport", eCmdHdlrInt,     0 },
44 	{ "port",       eCmdHdlrInt,     0 },
45 	{ "template",   eCmdHdlrGetWord, 0 },
46 	{ "conninfo",   eCmdHdlrGetWord, 0 }
47 };
48 static struct cnfparamblk actpblk =
49 	{ CNFPARAMBLK_VERSION,
50 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
51 	  actpdescr
52 	};</b></font>
53 BEGINinitConfVars     CODESTARTinitConfVars
54 ENDinitConfVars
55 static rsRetVal writePgSQL(uchar *psz, wrkrInstanceData_t *pData);
56 BEGINcreateInstance
57 CODESTARTcreateInstance
58 ENDcreateInstance
59 BEGINcreateWrkrInstance
60 CODESTARTcreateWrkrInstance
61 	pWrkrData-&gt;f_hpgsql = NULL;
62 ENDcreateWrkrInstance
63 BEGINisCompatibleWithFeature
64 CODESTARTisCompatibleWithFeature
65 	if (eFeat == sFEATURERepeatedMsgReduction)
66 		iRet = RS_RET_OK;
67 ENDisCompatibleWithFeature
68 static void closePgSQL(wrkrInstanceData_t *pWrkrData)
69 {
70 	assert(pWrkrData != NULL);
71 	if (pWrkrData-&gt;f_hpgsql != NULL) {  		PQfinish(pWrkrData-&gt;f_hpgsql);
72 		pWrkrData-&gt;f_hpgsql = NULL;
73 	}
74 }
75 BEGINfreeInstance
76 CODESTARTfreeInstance
77 	free(pData-&gt;tpl);
78 ENDfreeInstance
79 BEGINfreeWrkrInstance
80 CODESTARTfreeWrkrInstance
81 	closePgSQL(pWrkrData);
82 ENDfreeWrkrInstance
83 BEGINdbgPrintInstInfo
84 CODESTARTdbgPrintInstInfo
85 ENDdbgPrintInstInfo
86 static void reportDBError(wrkrInstanceData_t *pWrkrData, int bSilent)
87 {
88 	char errMsg[512];
89 	ConnStatusType ePgSQLStatus;
90 	assert(pWrkrData != NULL);
91 	bSilent = 0;
92 	errno = 0;
93 	if (pWrkrData-&gt;f_hpgsql == NULL) {
94 		LogError(0, NO_ERRCODE, "unknown DB error occurred - could not obtain PgSQL handle");
95 	} else { 		ePgSQLStatus = PQstatus(pWrkrData-&gt;f_hpgsql);
96 		snprintf(errMsg, sizeof(errMsg), "db error (%d): %s\n", ePgSQLStatus,
97 				PQerrorMessage(pWrkrData-&gt;f_hpgsql));
98 		if (bSilent || ePgSQLStatus == pWrkrData-&gt;eLastPgSQLStatus)
99 			dbgprintf("pgsql, DBError(silent): %s\n", errMsg);
100 		else {
101 			pWrkrData-&gt;eLastPgSQLStatus = ePgSQLStatus;
102 			LogError(0, NO_ERRCODE, "%s", errMsg);
103 		}
104 	}
105 	return;
106 }
107 static rsRetVal initPgSQL(wrkrInstanceData_t *pWrkrData, int bSilent)
108 {
109 	int sslStatus;
110 	instanceData *pData;
111 	DEFiRet;
112 	pData = pWrkrData-&gt;pData;
113 	assert(pData != NULL);
114 	assert(pWrkrData-&gt;f_hpgsql == NULL);
115 	if (strlen(pData-&gt;conninfo) &gt; 0) {
116 		dbgprintf("initPgSQL: using connection string provided by conninfo\n");
117 		pWrkrData-&gt;f_hpgsql = PQconnectdb(pData-&gt;conninfo);
118 	} else {
119 		dbgprintf("initPgSQL: host=%s port=%d dbname=%s uid=%s\n", pData-&gt;srv, pData-&gt;port,
120 		                                                           pData-&gt;dbname, pData-&gt;user);
121 		const char *PgConnectionOptions = "-c standard_conforming_strings=on";
122 		char port[6];
123 		snprintf(port, sizeof(port), "%d", pData-&gt;port);
124 		pWrkrData-&gt;f_hpgsql = PQsetdbLogin(pData-&gt;srv, port, PgConnectionOptions, NULL,
125 		                                   pData-&gt;dbname, pData-&gt;user, pData-&gt;pass);
126 	}
127 	if (pWrkrData-&gt;f_hpgsql == NULL) {
128 		reportDBError(pWrkrData, bSilent);
129 		closePgSQL(pWrkrData); 		iRet = RS_RET_SUSPENDED;
130 	}
131 #ifdef HAVE_PGSSLINUSE
132 	sslStatus = PQsslInUse(pWrkrData-&gt;f_hpgsql);
133 #else
134 	sslStatus = PQgetssl(pWrkrData-&gt;f_hpgsql) == NULL ? 0 : 1;
135 #endif
136 	dbgprintf("initPgSQL: ssl status: %d\n", sslStatus);
137 	RETiRet;
138 }
139 static int
140 tryExec(uchar *pszCmd, wrkrInstanceData_t *pWrkrData)
141 {
142 	PGresult *pgRet;
143 	ExecStatusType execState;
144 	int bHadError = 0;
145 	pgRet = PQexec(pWrkrData-&gt;f_hpgsql, (char*)pszCmd);
146 	execState = PQresultStatus(pgRet);
147 	if (execState != PGRES_COMMAND_OK &amp;&amp; execState != PGRES_TUPLES_OK) {
148 		dbgprintf("postgres query execution failed: %s\n", PQresStatus(PQresultStatus(pgRet)));
149 		bHadError = 1;
150 	}
151 	PQclear(pgRet);
152 	return(bHadError);
153 }
154 static rsRetVal
155 writePgSQL(uchar *psz, wrkrInstanceData_t *pWrkrData)
156 {
157 	int bHadError = 0;
158 	DEFiRet;
159 	assert(psz != NULL);
160 	assert(pWrkrData != NULL);
161 	dbgprintf("writePgSQL: %s\n", psz);
162 	bHadError = tryExec(psz, pWrkrData); 
163 	if (bHadError || (PQstatus(pWrkrData-&gt;f_hpgsql) != CONNECTION_OK)) {
164 #if 0				int inTransaction = 0;
165 		if(pData-&gt;f_hpgsql != NULL) {
166 			PGTransactionStatusType xactStatus = PQtransactionStatus(pData-&gt;f_hpgsql);
167 			if((xactStatus == PQTRANS_INTRANS) || (xactStatus == PQTRANS_ACTIVE)) {
168 				inTransaction = 1;
169 			}
170 		}
171 		if ( inTransaction == 0 )
172 #endif
173 		{
174 			closePgSQL(pWrkrData); 			CHKiRet(initPgSQL(pWrkrData, 0)); 			bHadError = tryExec(psz, pWrkrData); 		}
175 		if(bHadError || (PQstatus(pWrkrData-&gt;f_hpgsql) != CONNECTION_OK)) {
176 			reportDBError(pWrkrData, 0);
177 			closePgSQL(pWrkrData); 			ABORT_FINALIZE(RS_RET_SUSPENDED);
178 		}
179 	}
180 finalize_it:
181 	if (iRet == RS_RET_OK) {
182 		pWrkrData-&gt;eLastPgSQLStatus = CONNECTION_OK; 	}
183 	RETiRet;
184 }
185 BEGINtryResume
186 CODESTARTtryResume
187 	if (pWrkrData-&gt;f_hpgsql == NULL) {
188 		iRet = initPgSQL(pWrkrData, 1);
189 		if (iRet == RS_RET_OK) {
190 			iRet = writePgSQL((uchar*)"select 'a' as a", pWrkrData);
191 		}
192 	}
193 ENDtryResume
194 BEGINbeginTransaction
195 CODESTARTbeginTransaction
196 ENDbeginTransaction
197 BEGINcommitTransaction
198 CODESTARTcommitTransaction
199 	dbgprintf("ompgsql: beginTransaction\n");
200 	if (pWrkrData-&gt;f_hpgsql == NULL)
201 		initPgSQL(pWrkrData, 0);
202 	CHKiRet(writePgSQL((uchar*) "BEGIN", pWrkrData)); 
203 	for (unsigned i = 0 ; i &lt; nParams ; ++i) {
204 		iRet = writePgSQL(actParam(pParams, 1, i, 0).param, pWrkrData);
205 		if (iRet != RS_RET_OK
206 			&amp;&amp; iRet != RS_RET_DEFER_COMMIT
207 			&amp;&amp; iRet != RS_RET_PREVIOUS_COMMITTED) {
208 		}
209 	}
210 	CHKiRet(writePgSQL((uchar*) "COMMIT", pWrkrData)); 
211 finalize_it:
212 	if (iRet == RS_RET_OK) {
213 		pWrkrData-&gt;eLastPgSQLStatus = CONNECTION_OK; 	}
214 ENDcommitTransaction
215 static inline void
216 setInstParamDefaults(instanceData *pData)
217 {
218 	pData-&gt;tpl           = NULL;
219 	pData-&gt;multi_row     = 100;
220 	pData-&gt;trans_commit  = 100;
221 	pData-&gt;trans_age     = 60;
222 	pData-&gt;port          = 5432;
223 	strcpy(pData-&gt;user, "postgres");
224 	strcpy(pData-&gt;pass, "postgres");
225 }
226 BEGINnewActInst
227 	struct cnfparamvals *pvals;
228 	int i;
229 <a name="3"></a>	char *cstr;
230 	size_t len;
231 CODESTARTnewActInst
232 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if ((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
233 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
234 	}
235 	CHKiRet(createInstance(&amp;pData));
236 	setInstParamDefaults(pData);
237 	CODE_STD_STRING_REQUESTparseSelectorAct(1)
238 	for (i = 0 ; i &lt; actpblk.nParams ; ++i) {
239 		if (!pvals[i].bUsed)
240 			continue;
241 		if (!strcmp(actpblk.descr[i].name, "server")) {
242 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
243 			len = es_strlen(pvals[i].val.d.estr);
244 			if(len &gt;= sizeof(pData-&gt;srv)-1) {
245 				parser_errmsg("ompgsql: srv parameter longer than supported "
246 					"maximum of %d characters", (int)sizeof(pData-&gt;srv)-1);
247 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
248 			}
249 			memcpy(pData-&gt;srv, cstr, len+1);
250 			free(cstr);
251 		} else if (!strcmp(actpblk.descr[i].name, "port")) {
252 			pData-&gt;port = (int) pvals[i].val.d.n;
253 		} else if (!strcmp(actpblk.descr[i].name, "serverport")) {
254 			pData-&gt;port = (int) pvals[i].val.d.n;
255 		} else if (!strcmp(actpblk.descr[i].name, "multirows")) {
256 <a name="2"></a>			pData-&gt;multi_row = (int) pvals[i].val.d.n;
257 		} else if (!strcmp(actpblk.descr[i].name, "trans_size")) {
258 			pData-&gt;trans_commit = (int) pvals[i].val.d.n;
259 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if (!strcmp(actpblk.descr[i].name, "trans_age")) {
260 			pData-&gt;trans_age = (int) pvals[i].val.d.n;
261 		} else if (!strcmp(actpblk.descr[i].name, "db")) {
262 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
263 			len = es_strlen(pvals[i].val.d.estr);
264 			if(len &gt;= sizeof(pData-&gt;dbname)-1) {
265 				parser_errmsg("ompgsql: db parameter longer than supported "
266 					"maximum of %d characters", (int)sizeof(pData-&gt;dbname)-1);
267 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
268 			}
269 			memcpy(pData-&gt;dbname, cstr, len+1);
270 			free(cstr);
271 		} else if (   !strcmp(actpblk.descr[i].name, "user")
272 		           || !strcmp(actpblk.descr[i].name, "uid")) {
273 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
274 			len = es_strlen(pvals[i].val.d.estr);
275 			if(len &gt;= sizeof(pData-&gt;user)-1) {
276 				parser_errmsg("ompgsql: user/uid parameter longer than supported "
277 					"maximum of %d characters", (int)sizeof(pData-&gt;user)-1);
278 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
279 			}
280 			memcpy(pData-&gt;user, cstr, len+1);
281 			free(cstr);
282 		} else if (   !strcmp(actpblk.descr[i].name, "pass")
283 		           || !strcmp(actpblk.descr[i].name, "pwd")) {
284 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);
285 			len = es_strlen(pvals[i].val.d.estr);
286 			if(len &gt;= sizeof(pData-&gt;pass)-1) {
287 				parser_errmsg("ompgsql: pass/pwd parameter longer than supported "
288 					"maximum of %d characters", (int)sizeof(pData-&gt;pass)-1);
289 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
290 <a name="1"></a>			}
291 			memcpy(pData-&gt;pass, cstr, len+1);
292 			free(cstr);
293 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if (!strcmp(actpblk.descr[i].name, "template")) {
294 			pData-&gt;tpl = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
295 		} else if (!strcmp(actpblk.descr[i].name, "conninfo")) {
296 			cstr = es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
297 			len = es_strlen(pvals[i].val.d.estr);
298 			if(len &gt;= sizeof(pData-&gt;conninfo)-1) {
299 				parser_errmsg("ompgsql: conninfo parameter longer than supported "
300 					"maximum of %d characters", (int)sizeof(pData-&gt;conninfo)-1);
301 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
302 			}
303 			memcpy(pData-&gt;conninfo, cstr, len+1);
304 			free(cstr);
305 		} else {
306 			dbgprintf("ompgsql: program error, non-handled "
307 				"param '%s'\n", actpblk.descr[i].name);
308 		}
309 	}
310 	if (strlen(pData-&gt;conninfo) == 0 &amp;&amp; (strlen(pData-&gt;srv) == 0 || strlen(pData-&gt;dbname) == 0)) {
311 		parser_errmsg("ompgsql: must provide conninfo or server and dbname");
312 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
313 	}
314 	if (pData-&gt;tpl == NULL) {
315 		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup(" StdPgSQLFmt"),     OMSR_RQD_TPL_OPT_SQL));
316 	} else {
317 		CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*) strdup((char*) pData-&gt;tpl), OMSR_RQD_TPL_OPT_SQL));
318 	}
319 CODE_STD_FINALIZERnewActInst
320 	cnfparamvalsDestruct(pvals, &amp;actpblk);
321 ENDnewActInst
322 BEGINparseSelectorAct
323 	int iPgSQLPropErr = 0;
324 CODESTARTparseSelectorAct
325 CODE_STD_STRING_REQUESTparseSelectorAct(1)
326 	if (!strncmp((char*) p, ":ompgsql:", sizeof(":ompgsql:") - 1))
327 		p += sizeof(":ompgsql:") - 1; 	else
328 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
329 	if ((iRet = createInstance(&amp;pData)) != RS_RET_OK)
330 		goto finalize_it;
331 	setInstParamDefaults(pData);
332 	if (getSubString(&amp;p, pData-&gt;srv, MAXHOSTNAMELEN+1, ','))
333 		iPgSQLPropErr++;
334 	dbgprintf("%p:%s\n",p,p);
335 	if (*pData-&gt;srv == '\0')
336 		iPgSQLPropErr++;
337 	if (getSubString(&amp;p, pData-&gt;dbname, _DB_MAXDBLEN+1, ','))
338 		iPgSQLPropErr++;
339 	if (*pData-&gt;dbname == '\0')
340 		iPgSQLPropErr++;
341 	if (getSubString(&amp;p, pData-&gt;user, _DB_MAXUNAMELEN+1, ','))
342 		iPgSQLPropErr++;
343 	if (*pData-&gt;user == '\0')
344 		iPgSQLPropErr++;
345 	if (getSubString(&amp;p, pData-&gt;pass, _DB_MAXPWDLEN+1, ';'))
346 		iPgSQLPropErr++;
347 	if (*(p - 1) == ';') {
348 		p--;
349 		CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*) pData-&gt;tpl));
350 	} else {
351 		CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, OMSR_RQD_TPL_OPT_SQL, (uchar*)" StdPgSQLFmt"));
352 	}
353 	if (iPgSQLPropErr) {
354 		LogError(0, RS_RET_INVALID_PARAMS, "Trouble with PgSQL connection properties. "
355 				"-PgSQL logging disabled");
356 		ABORT_FINALIZE(RS_RET_INVALID_PARAMS);
357 	}
358 CODE_STD_FINALIZERparseSelectorAct
359 ENDparseSelectorAct
360 BEGINmodExit
361 CODESTARTmodExit
362 ENDmodExit
363 BEGINqueryEtryPt
364 CODESTARTqueryEtryPt
365 CODEqueryEtryPt_STD_OMODTX_QUERIES
366 CODEqueryEtryPt_STD_OMOD8_QUERIES
367 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
368 ENDqueryEtryPt
369 BEGINmodInit()
370 CODESTARTmodInit
371 INITLegCnfVars
372 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
373 	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
374 	if (!bCoreSupportsBatching) {
375 		LogError(0, NO_ERRCODE, "ompgsql: rsyslog core too old");
376 		ABORT_FINALIZE(RS_RET_ERR);
377 	}
378 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imhiredis.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;fcntl.h&gt;
9 #include &lt;pthread.h&gt;
10 #include &lt;sys/uio.h&gt;
11 #include &lt;hiredis/hiredis.h&gt;
12 #include &lt;hiredis/async.h&gt;
13 #include &lt;hiredis/adapters/libevent.h&gt;
14 #include &lt;event2/thread.h&gt;
15 #include "rsyslog.h"
16 #include "conf.h"
17 #include "syslogd-types.h"
18 #include "srUtils.h"
19 #include "template.h"
20 #include "module-template.h"
21 #include "errmsg.h"
22 #include "atomic.h"
23 #include "statsobj.h"
24 #include "unicode-helper.h"
25 #include "prop.h"
26 #include "ruleset.h"
27 #include "glbl.h"
28 #include "cfsysline.h"
29 #include "msg.h"
30 #include "dirty.h"
31 MODULE_TYPE_INPUT
32 MODULE_TYPE_NOKEEP
33 MODULE_CNFNAME("imhiredis")
34 DEF_IMOD_STATIC_DATA
35 #define QUEUE_BATCH_SIZE 10
36 #define IMHIREDIS_MODE_QUEUE 1
37 #define IMHIREDIS_MODE_SUBSCRIBE 2
38 DEFobjCurrIf(prop)
39 DEFobjCurrIf(ruleset)
40 DEFobjCurrIf(glbl)
41 DEFobjCurrIf(statsobj)
42 typedef struct redisNode_s {
43 	sbool isMaster;
44 	sbool usesSocket;
45 	uchar *socketPath;
46 	uchar *server;
47 	int port;
48 	struct redisNode_s *next;
49 } redisNode;
50 struct instanceConf_s {
51 	uchar *password;
52 	uchar *key;
53 	uchar *modeDescription;
54 	int mode;
55 	sbool useLPop;
56 	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;		
57 	redisContext *conn;
58 	redisAsyncContext *aconn;
59 	struct event_base *evtBase;
60 	redisNode *redisNodesList;
61 	struct instanceConf_s *next;
62 };
63 struct modConfData_s {
64 	rsconf_t *pConf;			instanceConf_t *root, *tail;
65 };
66 static struct imhiredisWrkrInfo_s {
67 	pthread_t tid;			instanceConf_t *inst;	} *imhiredisWrkrInfo;
68 pthread_attr_t wrkrThrdAttr;	
69 static int activeHiredisworkers = 0;
70 static char *redis_replies[] = {"unknown", "string", "array", "integer", "nil", "status", "error"};
71 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
72 static prop_t *pInputName = NULL;
73 static struct cnfparamdescr modpdescr[] = {};
74 static struct cnfparamblk modpblk =
75 	{ CNFPARAMBLK_VERSION,
76 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
77 	  modpdescr
78 	};
79 <a name="0"></a>
80 static struct cnfparamdescr inppdescr[] = {
81 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "socketPath", eCmdHdlrGetWord, 0 },
82 	{ "server", eCmdHdlrGetWord, 0 },
83 	{ "port", eCmdHdlrInt, 0 },
84 	{ "password", eCmdHdlrGetWord, 0 },
85 	{ "mode", eCmdHdlrGetWord, 0 },
86 	{ "key", eCmdHdlrGetWord, 0 },
87 	{ "uselpop", eCmdHdlrBinary, 0 },
88 	{ "ruleset", eCmdHdlrString, 0 },
89 };
90 static struct cnfparamblk inppblk =
91 	{ CNFPARAMBLK_VERSION,
92 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
93 	  inppdescr
94 	};</b></font>
95 struct timeval glblRedisConnectTimeout = { 3, 0 }; 
96 #include "im-helper.h" 
97 static void redisAsyncRecvCallback (redisAsyncContext __attribute__((unused)) *c, void *reply, void *inst_obj);
98 static void redisAsyncConnectCallback (const redisAsyncContext *c, int status);
99 static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status);
100 static rsRetVal enqMsg(instanceConf_t *const inst, const char *message);
101 rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password);
102 rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password);
103 rsRetVal redisActualizeCurrentNode(instanceConf_t *inst);
104 rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result);
105 rsRetVal redisAuthenticate(instanceConf_t *inst);
106 rsRetVal redisConnectSync(redisContext **conn, redisNode *node);
107 rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node);
108 rsRetVal redisDequeue(instanceConf_t *inst);
109 void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me);
110 void workerLoopQueue(struct imhiredisWrkrInfo_s *me);
111 static void *imhirediswrkr(void *myself);
112 static rsRetVal createRedisNode(redisNode **root);
113 rsRetVal copyNode(redisNode *src, redisNode **dst);
114 redisNode *freeNode(redisNode *node);
115 void insertNodeAfter(redisNode *root, redisNode *elem);
116 void dbgPrintNode(redisNode *node);
117 static rsRetVal
118 createInstance(instanceConf_t **pinst)
119 {
120 	DEFiRet;
121 	instanceConf_t *inst;
122 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
123 	inst-&gt;next = NULL;
124 	inst-&gt;password = NULL;
125 	inst-&gt;key = NULL;
126 	inst-&gt;mode = 0;
127 	inst-&gt;useLPop = 0;
128 	inst-&gt;pszBindRuleset = NULL;
129 	inst-&gt;pBindRuleset = NULL;
130 	inst-&gt;conn = NULL;
131 	inst-&gt;aconn = NULL;
132 	CHKiRet(createRedisNode(&amp;(inst-&gt;redisNodesList)));
133 	inst-&gt;currentNode = inst-&gt;redisNodesList;
134 	inst-&gt;evtBase = NULL;
135 	if(loadModConf-&gt;tail == NULL) {
136 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
137 	} else {
138 		loadModConf-&gt;tail-&gt;next = inst;
139 		loadModConf-&gt;tail = inst;
140 	}
141 	*pinst = inst;
142 finalize_it:
143 	RETiRet;
144 }
145 static rsRetVal ATTR_NONNULL()
146 checkInstance(instanceConf_t *const inst)
147 {
148 	DEFiRet;
149 	assert(inst-&gt;redisNodesList != NULL);
150 	if (inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath != NULL) {
151 		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: both 'server' and 'socketPath' are given, "
152 								"ignoring 'socketPath'.");
153 		free(inst-&gt;redisNodesList-&gt;socketPath);
154 		inst-&gt;redisNodesList-&gt;socketPath = NULL;
155 	}
156 	if(inst-&gt;redisNodesList-&gt;server != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;server[0] != '\0') {
157 		if (inst-&gt;redisNodesList-&gt;port == 0) {
158 			LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: port not set, setting default 6379");
159 			inst-&gt;redisNodesList-&gt;port = 6379;
160 		}
161 		DBGPRINTF("imhiredis: preferred server is %s (%d)\n",
162 			inst-&gt;redisNodesList-&gt;server,
163 			inst-&gt;redisNodesList-&gt;port);
164 		inst-&gt;redisNodesList-&gt;usesSocket = 0;
165 	}
166 	else if(inst-&gt;redisNodesList-&gt;socketPath != NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath[0] != '\0') {
167 		DBGPRINTF("imhiredis: preferred server is %s\n",
168 			inst-&gt;redisNodesList-&gt;socketPath);
169 		inst-&gt;redisNodesList-&gt;usesSocket = 1;
170 	} else {
171 		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: neither 'server' nor 'socketPath' are defined!");
172 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
173 	}
174 	if (inst-&gt;key != NULL) {
175 		DBGPRINTF("imhiredis: key/channel is '%s'\n", inst-&gt;key);
176 	} else {
177 		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: no key defined !");
178 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
179 	}
180 	if (inst-&gt;mode != IMHIREDIS_MODE_QUEUE &amp;&amp; inst-&gt;mode != IMHIREDIS_MODE_SUBSCRIBE) {
181 		LogError(0, RS_RET_CONFIG_ERROR, "imhiredis: invalid mode, please choose 'subscribe' or 'queue' mode.");
182 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
183 	}
184 	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;useLPop) {
185 		LogMsg(0, RS_RET_CONFIG_ERROR, LOG_WARNING,"imhiredis: 'uselpop' set with mode = subscribe : ignored.");
186 	}
187 	if (inst-&gt;password != NULL) {
188 		DBGPRINTF("imhiredis: password is '%s'\n", inst-&gt;password);
189 	}
190 	inst-&gt;currentNode = inst-&gt;redisNodesList;
191 	if (RS_RET_OK != redisActualizeCurrentNode(inst) || inst-&gt;currentNode == NULL) {
192 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to a valid master!");
193 	}
194 finalize_it:
195 	RETiRet;
196 }
197 static inline void
198 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
199 {
200 	LogError(0, NO_ERRCODE, "imhiredis: ruleset '%s' not found - "
201 		"using default ruleset instead",
202 		inst-&gt;pszBindRuleset);
203 }
204 BEGINnewInpInst
205 	struct cnfparamvals *pvals;
206 	instanceConf_t *inst;
207 	int i;
208 CODESTARTnewInpInst
209 	DBGPRINTF("newInpInst (imhiredis)\n");
210 	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
211 <a name="3"></a>		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
212 	}
213 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if(Debug) {
214 		dbgprintf("input param blk in imhiredis:\n");
215 		cnfparamsPrint(&amp;inppblk, pvals);
216 	}
217 	CHKiRet(createInstance(&amp;inst));
218 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
219 		if(!pvals[i].bUsed)
220 			continue;
221 <a name="1"></a>
222 		if(!strcmp(inppblk.descr[i].name, "server")) {
223 			inst-&gt;redisNodesList-&gt;server = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
224 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "socketPath")) {
225 <a name="2"></a>			inst-&gt;redisNodesList-&gt;socketPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
226 		} else if(!strcmp(inppblk.descr[i].name, "ruleset")) {
227 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
228 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(inppblk.descr[i].name, "port")) {
229 			inst-&gt;redisNodesList-&gt;port = (int) pvals[i].val.d.n;
230 		} else if(!strcmp(inppblk.descr[i].name, "password")) {
231 			inst-&gt;password = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
232 		} else if(!strcmp(inppblk.descr[i].name, "uselpop")) {
233 			inst-&gt;useLPop = pvals[i].val.d.n;
234 		} else if(!strcmp(inppblk.descr[i].name, "mode")) {
235 			inst-&gt;modeDescription = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
236 			if (!strcmp((const char*)inst-&gt;modeDescription, "queue")) {
237 				inst-&gt;mode = IMHIREDIS_MODE_QUEUE;
238 			} else if (!strcmp((const char*)inst-&gt;modeDescription, "subscribe")) {
239 				inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
240 			} else {
241 				LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: unsupported mode "
242 					"'%s'", inppblk.descr[i].name);
243 				ABORT_FINALIZE(RS_RET_PARAM_ERROR);
244 			}
245 		} else if(!strcmp(inppblk.descr[i].name, "key")) {
246 			inst-&gt;key = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
247 		} else {
248 			dbgprintf("imhiredis: program error, non-handled "
249 				"param '%s'\n", inppblk.descr[i].name);
250 		}
251 	}
252 	DBGPRINTF("imhiredis: checking config sanity\n");
253 	if (inst-&gt;modeDescription == NULL) {
254 		CHKmalloc(inst-&gt;modeDescription = (uchar*)strdup("subscribe"));
255 		inst-&gt;mode = IMHIREDIS_MODE_SUBSCRIBE;
256 		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: \"mode\" parameter not specified "
257 			"using default redis 'subscribe' mode -- this may not be what you want!");
258 	}
259 	if (inst-&gt;key == NULL) {
260 		LogMsg(0, RS_RET_PARAM_ERROR, LOG_ERR, "imhiredis: \"key\" required parameter not specified!");
261 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
262 	}
263 	if(inst-&gt;redisNodesList-&gt;server == NULL &amp;&amp; inst-&gt;redisNodesList-&gt;socketPath == NULL) {
264 		CHKmalloc(inst-&gt;redisNodesList-&gt;server = (uchar *)strdup("127.0.0.1"));
265 		inst-&gt;redisNodesList-&gt;port = 6379;
266 		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: no server parameter specified "
267 			"using default 127.0.0.1:6379 -- this may not be what you want!");
268 	}
269 	if (inst-&gt;password == NULL) {
270 		LogMsg(0, RS_RET_OK, LOG_INFO, "imhiredis: no password specified");
271 	}
272 	DBGPRINTF("imhiredis: newInpInst key=%s, mode=%s, uselpop=%d\n",
273 		inst-&gt;key, inst-&gt;modeDescription, inst-&gt;useLPop);
274 finalize_it:
275 CODE_STD_FINALIZERnewInpInst
276 	cnfparamvalsDestruct(pvals, &amp;inppblk);
277 ENDnewInpInst
278 BEGINbeginCnfLoad
279 CODESTARTbeginCnfLoad
280 	loadModConf = pModConf;
281 	pModConf-&gt;pConf = pConf;
282 ENDbeginCnfLoad
283 BEGINsetModCnf
284 	struct cnfparamvals *pvals = NULL;
285 	int i;
286 CODESTARTsetModCnf
287 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
288 	if(pvals == NULL) {
289 		LogError(0, RS_RET_MISSING_CNFPARAMS, "imhiredis: error processing module "
290 			"config parameters [module(...)]");
291 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
292 	}
293 	if(Debug) {
294 		dbgprintf("module (global) param blk for imhiredis:\n");
295 		cnfparamsPrint(&amp;modpblk, pvals);
296 	}
297 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
298 		if(!pvals[i].bUsed) {
299 			continue;
300 		} else {
301 			dbgprintf("imhiredis: program error, non-handled "
302 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
303 		}
304 	}
305 finalize_it:
306 	if(pvals != NULL)
307 		cnfparamvalsDestruct(pvals, &amp;modpblk);
308 ENDsetModCnf
309 BEGINendCnfLoad
310 CODESTARTendCnfLoad
311 ENDendCnfLoad
312 BEGINcheckCnf
313 	instanceConf_t *inst;
314 CODESTARTcheckCnf
315 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
316 		std_checkRuleset(pModConf, inst);
317 	}
318 ENDcheckCnf
319 BEGINactivateCnfPrePrivDrop
320 CODESTARTactivateCnfPrePrivDrop
321 	runModConf = pModConf;
322 ENDactivateCnfPrePrivDrop
323 BEGINactivateCnf
324 CODESTARTactivateCnf
325 	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
326 		iRet = checkInstance(inst);
327 		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
328 			inst-&gt;evtBase = event_base_new();
329 	}
330 ENDactivateCnf
331 BEGINfreeCnf
332 	instanceConf_t *inst, *del;
333 	redisNode *node;
334 CODESTARTfreeCnf
335 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
336 		if (inst-&gt;evtBase)
337 			event_base_free(inst-&gt;evtBase);
338 		if (inst-&gt;password != NULL)
339 			free(inst-&gt;password);
340 		free(inst-&gt;modeDescription);
341 		free(inst-&gt;key);
342 		free(inst-&gt;pszBindRuleset);
343 		if(inst-&gt;conn != NULL) {
344 			redisFree(inst-&gt;conn);
345 			inst-&gt;conn = NULL;
346 		}
347 		if(inst-&gt;aconn != NULL) {
348 			redisAsyncFree(inst-&gt;aconn);
349 			inst-&gt;aconn = NULL;
350 		}
351 		for (node = inst-&gt;redisNodesList; node != NULL; node = freeNode(node)) {;}
352 		del = inst;
353 		inst = inst-&gt;next;
354 		free(del);
355 	}
356 ENDfreeCnf
357 static void
358 shutdownImhiredisWorkers(void)
359 {
360 	int i;
361 	instanceConf_t *inst;
362 	assert(imhiredisWrkrInfo != NULL);
363 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
364 		if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; inst-&gt;aconn) {
365 			DBGPRINTF("imhiredis: disconnecting async worker\n");
366 			redisAsyncDisconnect(inst-&gt;aconn);
367 		}
368 	}
369 	DBGPRINTF("imhiredis: waiting on imhiredis workerthread termination\n");
370 	for(i = 0 ; i &lt; activeHiredisworkers ; ++i) {
371 		pthread_join(imhiredisWrkrInfo[i].tid, NULL);
372 		DBGPRINTF("imhiredis: Stopped worker %d\n", i);
373 	}
374 	free(imhiredisWrkrInfo);
375 	imhiredisWrkrInfo = NULL;
376 	return;
377 }
378 BEGINrunInput
379 	int i;
380 	instanceConf_t *inst;
381 CODESTARTrunInput
382 	DBGPRINTF("imhiredis: runInput loop started ...\n");
383 	activeHiredisworkers = 0;
384 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
385 		++activeHiredisworkers;
386 	}
387 	if(activeHiredisworkers == 0) {
388 		LogError(0, RS_RET_ERR, "imhiredis: no active inputs, input does "
389 			"not run - there should have been additional error "
390 			"messages given previously");
391 		ABORT_FINALIZE(RS_RET_ERR);
392 	}
393 	DBGPRINTF("imhiredis: Starting %d imhiredis workerthreads\n", activeHiredisworkers);
394 	imhiredisWrkrInfo = calloc(activeHiredisworkers, sizeof(struct imhiredisWrkrInfo_s));
395 	if (imhiredisWrkrInfo == NULL) {
396 		LogError(errno, RS_RET_OUT_OF_MEMORY, "imhiredis: worker-info array allocation failed.");
397 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
398 	}
399 	i = 0;
400 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
401 		imhiredisWrkrInfo[i].inst = inst; 		pthread_create(&amp;imhiredisWrkrInfo[i].tid, &amp;wrkrThrdAttr, imhirediswrkr, &amp;(imhiredisWrkrInfo[i]));
402 		i++;
403 	}
404 	while(glbl.GetGlobalInputTermState() == 0) {
405 		if(glbl.GetGlobalInputTermState() == 0)
406 			srSleep(0, 100000);
407 	}
408 	DBGPRINTF("imhiredis: terminating upon request of rsyslog core\n");
409 	shutdownImhiredisWorkers();
410 finalize_it:
411 ENDrunInput
412 BEGINwillRun
413 CODESTARTwillRun
414 	CHKiRet(prop.Construct(&amp;pInputName));
415 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("imhiredis"), sizeof("imhiredis") - 1));
416 	CHKiRet(prop.ConstructFinalize(pInputName));
417 finalize_it:
418 ENDwillRun
419 BEGINafterRun
420 CODESTARTafterRun
421 	if(pInputName != NULL)
422 		prop.Destruct(&amp;pInputName);
423 ENDafterRun
424 BEGINmodExit
425 CODESTARTmodExit
426 	pthread_attr_destroy(&amp;wrkrThrdAttr);
427 	libevent_global_shutdown();
428 	objRelease(statsobj, CORE_COMPONENT);
429 	objRelease(ruleset, CORE_COMPONENT);
430 	objRelease(glbl, CORE_COMPONENT);
431 	objRelease(prop, CORE_COMPONENT);
432 ENDmodExit
433 BEGINisCompatibleWithFeature
434 CODESTARTisCompatibleWithFeature
435 	if(eFeat == sFEATURENonCancelInputTermination)
436 		iRet = RS_RET_OK;
437 ENDisCompatibleWithFeature
438 BEGINqueryEtryPt
439 CODESTARTqueryEtryPt
440 CODEqueryEtryPt_STD_IMOD_QUERIES
441 CODEqueryEtryPt_STD_CONF2_QUERIES
442 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
443 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
444 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
445 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
446 ENDqueryEtryPt
447 BEGINmodInit()
448 CODESTARTmodInit
449 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
450 CODEmodInit_QueryRegCFSLineHdlr
451 	CHKiRet(objUse(glbl, CORE_COMPONENT));
452 	CHKiRet(objUse(prop, CORE_COMPONENT));
453 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
454 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
455 	pthread_attr_init(&amp;wrkrThrdAttr);
456 	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
457 	evthread_use_pthreads();
458 ENDmodInit
459 static void redisAsyncRecvCallback (redisAsyncContext *aconn, void *reply, void __attribute__((unused)) *unused) {
460 	instanceConf_t *const inst = (instanceConf_t *) aconn-&gt;data;
461 	redisReply * r = (redisReply *) reply;
462 	if (r == NULL) return;
463 	if (r-&gt;elements &lt; 3 || r-&gt;element[2]-&gt;str == NULL) {
464 		return;
465 	}
466 	enqMsg(inst, r-&gt;element[2]-&gt;str);
467 	return;
468 }
469 static void redisAsyncConnectCallback (const redisAsyncContext *c, int status) {
470 	if (status != REDIS_OK) {
471 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): could not connect to redis: "
472 			"%s", c-&gt;errstr);
473 		instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
474 		assert(inst != NULL);
475 		inst-&gt;aconn = NULL;
476 		return;
477 	}
478 	DBGPRINTF("imhiredis (async): successfully connected!\n");
479 	return;
480 }
481 static void redisAsyncDisconnectCallback (const redisAsyncContext *c, int status) {
482 	instanceConf_t *inst = (instanceConf_t *) c-&gt;data;
483 	assert(inst != NULL);
484 	inst-&gt;aconn = NULL;
485 	inst-&gt;currentNode = NULL;
486 	if (status != REDIS_OK) {
487 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis (async): got disconnected from redis: "
488 			"%s", c-&gt;errstr);
489 		return;
490 	}
491 	DBGPRINTF("imhiredis (async): successfully disconnected!\n");
492 	return;
493 }
494 redisReply *getRole(redisContext *c) {
495 	redisReply *reply;
496 	assert(c != NULL);
497 	reply = redisCommand(c, "ROLE");
498 	if (reply == NULL) {
499 		DBGPRINTF("imhiredis: could not get reply from ROLE command\n");
500 	}
501 	else if (reply-&gt;type == REDIS_REPLY_ERROR) {
502 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis got an error while querying role -&gt; "
503 			"%s\n", reply-&gt;str);
504 		freeReplyObject(reply);
505 		reply = NULL;
506 	}
507 	else if (reply-&gt;type != REDIS_REPLY_ARRAY) {
508 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: did not get an array from ROLE command");
509 		freeReplyObject(reply);
510 		reply = NULL;
511 	}
512 	return reply;
513 }
514 static rsRetVal enqMsg(instanceConf_t *const inst, const char *message) {
515 	DEFiRet;
516 	smsg_t *pMsg;
517 	if (message == NULL || message[0] == '\0') {
518 		FINALIZE;
519 	}
520 	DBGPRINTF("imhiredis: enqMsg: Msg -&gt; '%s'\n", message);
521 	CHKiRet(msgConstruct(&amp;pMsg));
522 	MsgSetInputName(pMsg, pInputName);
523 	MsgSetRawMsg(pMsg, message, strlen(message));
524 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
525 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
526 	MsgSetMSGoffs(pMsg, 0);		CHKiRet(submitMsg2(pMsg));
527 finalize_it:
528 	RETiRet;
529 }
530 rsRetVal redisAuthentSynchronous(redisContext *conn, uchar *password) {
531 	DEFiRet;
532 	redisReply *reply = NULL;
533 	assert(conn != NULL);
534 	assert(password != NULL);
535 	assert(password[0] != '\0');
536 	reply = (redisReply *) redisCommand(conn, "AUTH %s", password);
537 	if (reply == NULL) {
538 		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Could not authenticate!\n");
539 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
540 	} else if (strncmp(reply-&gt;str, "OK", 2)) {
541 		LogError(0, RS_RET_REDIS_AUTH_FAILED, "imhiredis: Authentication failure -&gt; %s\n", reply-&gt;str);
542 		ABORT_FINALIZE(RS_RET_REDIS_AUTH_FAILED);
543 	}
544 finalize_it:
545 	if(reply)
546 		freeReplyObject(reply);
547 	RETiRet;
548 }
549 rsRetVal redisAuthentAsynchronous(redisAsyncContext *aconn, uchar *password) {
550 	DEFiRet;
551 	assert(aconn != NULL);
552 	assert(password != NULL);
553 	assert(password[0] != '\0');
554 	if (REDIS_OK != redisAsyncCommand(aconn, NULL, NULL, "AUTH %s", password)) {
555 		LogError(0, RS_RET_REDIS_ERROR, "imhiredis: error while authenticating asynchronously -&gt; %s\n",
556 			aconn-&gt;errstr);
557 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
558 	}
559 finalize_it:
560 	RETiRet;
561 }
562 rsRetVal redisGetServersList(redisNode *node, uchar *password, redisNode **result) {
563 	DEFiRet;
564 	redisContext *context;
565 	redisReply *reply = NULL, *replica;
566 	unsigned int i;
567 	assert(node != NULL);
568 	CHKiRet(redisConnectSync(&amp;context, node));
569 	if(password != NULL &amp;&amp; password[0] != '\0') {
570 		CHKiRet(redisAuthentSynchronous(context, password));
571 	}
572 	reply = getRole(context);
573 	if(reply == NULL) {
574 		LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: did not get the role of the server");
575 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
576 	}
577 	if (	reply-&gt;elements == 5 &amp;&amp;
578 		strncmp(reply-&gt;element[0]-&gt;str, "slave", 5) == 0) {
579 		CHKiRet(createRedisNode(result));
580 		(*result)-&gt;server = (uchar *) strdup((const char *)reply-&gt;element[1]-&gt;str);
581 		(*result)-&gt;port = reply-&gt;element[2]-&gt;integer;
582 		(*result)-&gt;isMaster = 1;
583 	}
584 	else if (	reply-&gt;elements == 3 &amp;&amp;
585 			reply-&gt;element[2]-&gt;type == REDIS_REPLY_ARRAY &amp;&amp;
586 			strncmp(reply-&gt;element[0]-&gt;str, "master", 6) == 0) {
587 		for (i = 0; i &lt; reply-&gt;element[2]-&gt;elements; i++) {
588 			replica = reply-&gt;element[2]-&gt;element[i];
589 			if (replica-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; replica-&gt;elements == 3) {
590 				CHKiRet(createRedisNode(result));
591 				(*result)-&gt;server = (uchar *) strdup((const char *)replica-&gt;element[0]-&gt;str);
592 				(*result)-&gt;port = atoi(replica-&gt;element[1]-&gt;str);
593 			}
594 		}
595 	} else {
596 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
597 	}
598 finalize_it:
599 	if (reply != NULL)
600 		freeReplyObject(reply);
601 	if (context != NULL)
602 		redisFree(context);
603 	RETiRet;
604 }
605 rsRetVal redisActualizeCurrentNode(instanceConf_t *inst) {
606 	DEFiRet;
607 	redisReply *reply = NULL;
608 	redisNode *node, *tmp, *newList = NULL;
609 	assert(inst != NULL);
610 	assert(inst-&gt;redisNodesList != NULL);
611 	inst-&gt;currentNode = NULL;
612 	copyNode(inst-&gt;redisNodesList, &amp;newList);
613 	newList-&gt;next = NULL;
614 	for (node = inst-&gt;redisNodesList; node != NULL; node = node-&gt;next) {
615 		tmp = NULL;
616 		DBGPRINTF("imhiredis: trying to connect to node to get info...\n");
617 		dbgPrintNode(node);
618 		if (RS_RET_OK == redisGetServersList(node, inst-&gt;password, &amp;tmp)) {
619 			if (tmp &amp;&amp; tmp-&gt;isMaster) {
620 				DBGPRINTF("imhiredis: node replied with a master node, is a replica\n");
621 				inst-&gt;currentNode = tmp;
622 				tmp = NULL;
623 				if(RS_RET_OK != redisGetServersList(inst-&gt;currentNode, inst-&gt;password, &amp;tmp)) {
624 					DBGPRINTF("imhiredis: had a master but cannot connect, keeping in list\n");
625 					dbgPrintNode(inst-&gt;currentNode);
626 					insertNodeAfter(newList, inst-&gt;currentNode);
627 					inst-&gt;currentNode = NULL;
628 					continue;
629 				}
630 			} else {
631 				DBGPRINTF("imhiredis: node replied with a list of replicas, is a master\n");
632 				node-&gt;isMaster = 1;
633 				copyNode(node, &amp;(inst-&gt;currentNode));
634 				inst-&gt;currentNode-&gt;next = NULL;
635 			}
636 			if (tmp) {
637 				insertNodeAfter(newList, tmp);
638 				DBGPRINTF("imhiredis: inserting replicas to list\n");
639 				for (tmp = newList-&gt;next; tmp != NULL; tmp = tmp-&gt;next) {
640 					dbgPrintNode(tmp);
641 				}
642 			}
643 			DBGPRINTF("imhiredis: inserting new master node in list\n");
644 			dbgPrintNode(inst-&gt;currentNode);
645 			insertNodeAfter(newList, inst-&gt;currentNode);
646 			tmp = newList;
647 			newList = inst-&gt;redisNodesList;
648 			inst-&gt;redisNodesList = tmp;
649 			FINALIZE;
650 		}
651 	}
652 	DBGPRINTF("imhiredis: did not find a valid master");
653 	iRet = RS_RET_NOT_FOUND;
654 	inst-&gt;currentNode = NULL;
655 finalize_it:
656 	if (reply != NULL)
657 		freeReplyObject(reply);
658 	for (node = newList; node != NULL; ) {
659 		node = freeNode(node);
660 	}
661 	RETiRet;
662 }
663 rsRetVal redisAuthenticate(instanceConf_t *inst) {
664 	DEFiRet;
665 	redisContext *usedContext = NULL;
666 	redisReply *reply = NULL;
667 	assert(inst != NULL);
668 	assert(inst-&gt;currentNode != NULL);
669 	assert(inst-&gt;password != NULL);
670 	assert(inst-&gt;password[0] != '\0');
671 	DBGPRINTF("imhiredis: authenticating...\n");
672 	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
673 		if (RS_RET_OK != redisConnectSync(&amp;usedContext, inst-&gt;currentNode)) {
674 			LogMsg(0, RS_RET_REDIS_ERROR, LOG_WARNING, "imhiredis: could not connect to current "
675 				"active node synchronously to validate authentication");
676 			ABORT_FINALIZE(RS_RET_REDIS_ERROR);
677 		}
678 	} else {
679 		usedContext = inst-&gt;conn;
680 	}
681 	CHKiRet(redisAuthentSynchronous(usedContext, inst-&gt;password));
682 	if (inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE) {
683 		CHKiRet(redisAuthentAsynchronous(inst-&gt;aconn, inst-&gt;password));
684 	}
685 	DBGPRINTF("imhiredis: authentication successful\n");
686 finalize_it:
687 	if(inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE &amp;&amp; usedContext)
688 		redisFree(usedContext);
689 	if(reply)
690 		freeReplyObject(reply);
691 	RETiRet;
692 }
693 rsRetVal redisConnectSync(redisContext **conn, redisNode *node) {
694 	DEFiRet;
695 	assert(node != NULL);
696 	if (node-&gt;usesSocket)
697 		*conn = redisConnectUnixWithTimeout((const char *)node-&gt;socketPath, glblRedisConnectTimeout);
698 	else
699 		*conn = redisConnectWithTimeout((const char *)node-&gt;server, node-&gt;port, glblRedisConnectTimeout);
700 	if (*conn == NULL) {
701 		if (node-&gt;usesSocket) {
702 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
703 				"-&gt; could not allocate context!\n", node-&gt;socketPath);
704 		} else {
705 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
706 				"port %d -&gt; could not allocate context!\n", node-&gt;server, node-&gt;port);
707 		}
708 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
709 	}
710 	else if ((*conn)-&gt;err) {
711 		if (node-&gt;usesSocket) {
712 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s' "
713 				"-&gt; %s\n", node-&gt;socketPath, (*conn)-&gt;errstr);
714 		} else {
715 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis: can not connect to redis server '%s', "
716 				"port %d -&gt; %s\n", node-&gt;server, node-&gt;port, (*conn)-&gt;errstr);
717 		}
718 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
719 	}
720 finalize_it:
721 	if (iRet != RS_RET_OK) {
722 		if (*conn)
723 			redisFree(*conn);
724 		*conn = NULL;
725 	}
726 	RETiRet;
727 }
728 rsRetVal redisConnectAsync(redisAsyncContext **aconn, redisNode *node) {
729 	DEFiRet;
730 	assert(node != NULL);
731 	if (node-&gt;usesSocket)
732 		*aconn = redisAsyncConnectUnix((const char*)node-&gt;socketPath);
733 	else
734 		*aconn = redisAsyncConnect((const char *)node-&gt;server, node-&gt;port);
735 	if(*aconn == NULL) {
736 		LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): could not allocate context!\n");
737 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
738 	} else if ((*aconn)-&gt;err) {
739 		if (node-&gt;usesSocket) {
740 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s' "
741 				"-&gt; %s\n", node-&gt;socketPath, (*aconn)-&gt;errstr);
742 		} else {
743 			LogError(0, RS_RET_REDIS_ERROR, "imhiredis (async): cannot connect to server '%s', port '%d' "
744 				"-&gt; %s\n", node-&gt;server, node-&gt;port, (*aconn)-&gt;errstr);
745 		}
746 		ABORT_FINALIZE(RS_RET_REDIS_ERROR);
747 	}
748 finalize_it:
749 	if (iRet != RS_RET_OK) {
750 		if(*aconn)
751 			redisAsyncFree(*aconn);
752 		*aconn = NULL;
753 	}
754 	RETiRet;
755 }
756 rsRetVal redisDequeue(instanceConf_t *inst) {
757 	DEFiRet;
758 	redisReply *reply = NULL;
759 	uint replyType = 0, i;
760 	assert(inst != NULL);
761 	DBGPRINTF("imhiredis: beginning to dequeue key '%s'\n", inst-&gt;key);
762 	do {
763 		if (inst-&gt;useLPop == 1) {
764 			DBGPRINTF("imhiredis: Queuing #%d LPOP commands on key '%s' \n",
765 					QUEUE_BATCH_SIZE,
766 					inst-&gt;key);
767 			for (i=0; i&lt;QUEUE_BATCH_SIZE; ++i ) {
768 				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "LPOP %s", inst-&gt;key))
769 					break;
770 			}
771 		} else {
772 			DBGPRINTF("imhiredis: Queuing #%d RPOP commands on key '%s' \n",
773 					QUEUE_BATCH_SIZE,
774 					inst-&gt;key);
775 			for (i=0; i&lt;QUEUE_BATCH_SIZE; i++) {
776 				if (REDIS_OK != redisAppendCommand(inst-&gt;conn, "RPOP %s", inst-&gt;key))
777 					break;
778 			}
779 		}
780 		do {
781 			if (REDIS_OK != redisGetReply(inst-&gt;conn, (void **) &amp;reply)) {
782 				LogError(0, RS_RET_REDIS_ERROR, "imhiredis: Error reading reply after POP #%d on key "
783 								"'%s'", (QUEUE_BATCH_SIZE - i), inst-&gt;key);
784 				ABORT_FINALIZE(RS_RET_REDIS_ERROR);
785 			} else {
786 				if (reply != NULL) {
787 					replyType = reply-&gt;type;
788 					switch(replyType) {
789 						case REDIS_REPLY_STRING:
790 							enqMsg(inst, reply-&gt;str);
791 							break;
792 						case REDIS_REPLY_NIL:
793 							break;
794 						case REDIS_REPLY_ERROR:
795 							LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: error "
796 							"while POP'ing key '%s' -&gt; %s", inst-&gt;key, reply-&gt;str);
797 							ABORT_FINALIZE(RS_RET_REDIS_ERROR);
798 						default:
799 							LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, "imhiredis: unexpected "
800 							"reply type: %s", redis_replies[replyType%7]);
801 					}
802 					freeReplyObject(reply);
803 					reply = NULL;
804 				} else { 					LogMsg(0, RS_RET_REDIS_ERROR, LOG_ERR, "imhiredis: unexpected empty reply "
805 						"for successful return");
806 					ABORT_FINALIZE(RS_RET_REDIS_ERROR);
807 				}
808 			}
809 		} while (--i &gt; 0);
810 	} while (replyType == REDIS_REPLY_STRING &amp;&amp; glbl.GetGlobalInputTermState() == 0);
811 	DBGPRINTF("imhiredis: finished to dequeue key '%s'\n", inst-&gt;key);
812 finalize_it:
813 	if (reply)
814 		freeReplyObject(reply);
815 	RETiRet;
816 }
817 void workerLoopSubscribe(struct imhiredisWrkrInfo_s *me) {
818 	uint i;
819 	DBGPRINTF("imhiredis (async): beginning of subscribe worker loop...\n");
820 	if (me-&gt;inst-&gt;currentNode != NULL) {
821 		if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
822 			me-&gt;inst-&gt;currentNode = NULL;
823 		}
824 		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
825 			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
826 			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
827 			redisAsyncFree(me-&gt;inst-&gt;aconn);
828 			me-&gt;inst-&gt;aconn = NULL;
829 			me-&gt;inst-&gt;currentNode = NULL;
830 		}
831 		me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
832 		redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
833 		redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
834 		redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
835 	}
836 	while(glbl.GetGlobalInputTermState() == 0) {
837 		if (me-&gt;inst-&gt;aconn == NULL) {
838 			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
839 			for(i = 0; i &lt; 100; i++) {
840 				if (glbl.GetGlobalInputTermState() != 0)
841 					goto end_loop;
842 				srSleep(0, 100000);
843 			}
844 			if (me-&gt;inst-&gt;currentNode == NULL) {
845 				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
846 					continue;
847 			}
848 			if(me-&gt;inst-&gt;currentNode != NULL) {
849 				if(RS_RET_OK != redisConnectAsync(&amp;(me-&gt;inst-&gt;aconn), me-&gt;inst-&gt;currentNode)) {
850 					me-&gt;inst-&gt;currentNode = NULL;
851 					continue;
852 				}
853 				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
854 					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
855 					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
856 					redisAsyncFree(me-&gt;inst-&gt;aconn);
857 					me-&gt;inst-&gt;aconn = NULL;
858 					me-&gt;inst-&gt;currentNode = NULL;
859 					continue;
860 				}
861 			}
862 			me-&gt;inst-&gt;aconn-&gt;data = (void *)me-&gt;inst;
863 			redisAsyncSetConnectCallback(me-&gt;inst-&gt;aconn, redisAsyncConnectCallback);
864 			redisAsyncSetDisconnectCallback(me-&gt;inst-&gt;aconn, redisAsyncDisconnectCallback);
865 			redisLibeventAttach(me-&gt;inst-&gt;aconn, me-&gt;inst-&gt;evtBase);
866 		}
867 		if (me-&gt;inst-&gt;aconn != NULL) {
868 			DBGPRINTF("imhiredis (async): subscribing to channel '%s'\n", me-&gt;inst-&gt;key);
869 			redisAsyncCommand(
870 				me-&gt;inst-&gt;aconn,
871 				redisAsyncRecvCallback,
872 				NULL,
873 				"SUBSCRIBE %s",
874 				me-&gt;inst-&gt;key);
875 			event_base_dispatch(me-&gt;inst-&gt;evtBase);
876 		}
877 	}
878 end_loop:
879 	return;
880 }
881 void workerLoopQueue(struct imhiredisWrkrInfo_s *me) {
882 	uint i;
883 	DBGPRINTF("imhiredis: beginning of queue worker loop...\n");
884 	if (me-&gt;inst-&gt;currentNode != NULL) {
885 		if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
886 			me-&gt;inst-&gt;currentNode = NULL;
887 		}
888 		if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
889 			me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
890 			RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
891 			redisFree(me-&gt;inst-&gt;conn);
892 			me-&gt;inst-&gt;conn = NULL;
893 			me-&gt;inst-&gt;currentNode = NULL;
894 		}
895 	}
896 	while(glbl.GetGlobalInputTermState() == 0) {
897 		if (me-&gt;inst-&gt;conn == NULL) {
898 			DBGPRINTF("imhiredis: no valid connection, sleeping 10 seconds before retrying...\n");
899 			for(i = 0; i &lt; 100; i++) {
900 				if (glbl.GetGlobalInputTermState() != 0)
901 					goto end_loop;
902 				srSleep(0, 100000);
903 			}
904 			if (me-&gt;inst-&gt;currentNode == NULL) {
905 				if(RS_RET_OK != redisActualizeCurrentNode(me-&gt;inst))
906 					continue;
907 			}
908 			if(me-&gt;inst-&gt;currentNode != NULL) {
909 				if(RS_RET_OK != redisConnectSync(&amp;(me-&gt;inst-&gt;conn), me-&gt;inst-&gt;currentNode)) {
910 					me-&gt;inst-&gt;currentNode = NULL;
911 					continue;
912 				}
913 				if(	me-&gt;inst-&gt;password != NULL &amp;&amp;
914 					me-&gt;inst-&gt;password[0] != '\0' &amp;&amp;
915 					RS_RET_OK != redisAuthenticate(me-&gt;inst)) {
916 					redisFree(me-&gt;inst-&gt;conn);
917 					me-&gt;inst-&gt;conn = NULL;
918 					me-&gt;inst-&gt;currentNode = NULL;
919 					continue;
920 				}
921 			}
922 		}
923 		if (me-&gt;inst-&gt;conn != NULL) {
924 			if (redisDequeue(me-&gt;inst) == RS_RET_REDIS_ERROR) {
925 				DBGPRINTF("imhiredis: current connection invalidated\n");
926 				redisFree(me-&gt;inst-&gt;conn);
927 				me-&gt;inst-&gt;currentNode = NULL;
928 				me-&gt;inst-&gt;conn = NULL;
929 			}
930 			if(glbl.GetGlobalInputTermState() == 0) {
931 				for(i = 0; i &lt; 10; i++) {
932 					if (glbl.GetGlobalInputTermState() != 0)
933 						goto end_loop;
934 					srSleep(0, 100000);
935 				}
936 			}
937 		}
938 	}
939 end_loop:
940 	return;
941 }
942 static void *
943 imhirediswrkr(void *myself)
944 {
945 	struct imhiredisWrkrInfo_s *me = (struct imhiredisWrkrInfo_s*) myself;
946 	DBGPRINTF("imhiredis: started hiredis consumer workerthread\n");
947 	dbgPrintNode(me-&gt;inst-&gt;currentNode);
948 	if(me-&gt;inst-&gt;mode == IMHIREDIS_MODE_QUEUE)
949 		workerLoopQueue(me);
950 	else if (me-&gt;inst-&gt;mode == IMHIREDIS_MODE_SUBSCRIBE)
951 		workerLoopSubscribe(me);
952 	DBGPRINTF("imhiredis: stopped hiredis consumer workerthread\n");
953 	return NULL;
954 }
955 static rsRetVal
956 createRedisNode(redisNode **root) {
957 	redisNode *node;
958 	DEFiRet;
959 	CHKmalloc(node = malloc(sizeof(redisNode)));
960 	node-&gt;port = 0;
961 	node-&gt;server = NULL;
962 	node-&gt;socketPath = NULL;
963 	node-&gt;usesSocket = 0;
964 	node-&gt;isMaster = 0;
965 	node-&gt;next = NULL;
966 	if (!root) {
967 		*root = node;
968 	} else {
969 		node-&gt;next = (*root);
970 		*root = node;
971 	}
972 finalize_it:
973 	RETiRet;
974 }
975 rsRetVal copyNode(redisNode *src, redisNode **dst) {
976 	DEFiRet;
977 	assert(src != NULL);
978 	CHKiRet(createRedisNode(dst));
979 	(*dst)-&gt;isMaster = src-&gt;isMaster;
980 	(*dst)-&gt;next = src-&gt;next;
981 	(*dst)-&gt;port = src-&gt;port;
982 	(*dst)-&gt;usesSocket = src-&gt;usesSocket;
983 	if (src-&gt;server)
984 		(*dst)-&gt;server = (uchar *) strdup((const char *)src-&gt;server);
985 	if (src-&gt;socketPath)
986 		(*dst)-&gt;socketPath = (uchar *) strdup((const char *)src-&gt;socketPath);
987 finalize_it:
988 	RETiRet;
989 }
990 redisNode *freeNode(redisNode *node) {
991 	redisNode *ret = NULL;
992 	if (node != NULL) {
993 		if (node-&gt;next != NULL)
994 			ret = node-&gt;next;
995 		if(node-&gt;server != NULL)
996 			free(node-&gt;server);
997 		if(node-&gt;socketPath != NULL)
998 			free(node-&gt;socketPath);
999 		free(node);
1000 	}
1001 	return ret;
1002 }
1003 void insertNodeAfter(redisNode *root, redisNode *elem) {
1004 	assert(root != NULL);
1005 	assert(elem != NULL);
1006 	if(root-&gt;next != NULL) {
1007 		elem-&gt;next = root-&gt;next;
1008 	}
1009 	root-&gt;next = elem;
1010 	return;
1011 }
1012 void dbgPrintNode(redisNode *node) {
1013 	if (node != NULL) {
1014 		if (node-&gt;usesSocket) {
1015 			if (node-&gt;isMaster) {
1016 				DBGPRINTF("imhiredis: node is %s (master)\n", node-&gt;socketPath);
1017 			} else {
1018 				DBGPRINTF("imhiredis: node is %s (replica)\n", node-&gt;socketPath);
1019 			}
1020 		} else {
1021 			if (node-&gt;isMaster) {
1022 				DBGPRINTF("imhiredis: node is %s:%d (master)\n", node-&gt;server, node-&gt;port);
1023 			} else {
1024 				DBGPRINTF("imhiredis: node is %s:%d (replica)\n", node-&gt;server, node-&gt;port);
1025 			}
1026 		}
1027 	}
1028 	return;
1029 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
