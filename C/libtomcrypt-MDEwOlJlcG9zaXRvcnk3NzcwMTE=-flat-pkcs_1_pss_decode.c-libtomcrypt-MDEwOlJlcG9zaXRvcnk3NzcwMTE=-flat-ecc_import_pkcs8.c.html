
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 26.229508196721312%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pkcs_1_pss_decode.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_PKCS_1
<span onclick='openModal()' class='match'>3  int pkcs_1_pss_decode(const unsigned char *msghash, unsigned long msghashlen,
4                        const unsigned char *sig,     unsigned long siglen,
</span>5                              unsigned long saltlen,  int           hash_idx,
6                              unsigned long modulus_bitlen, int    *res)
7  {
8     unsigned char *DB, *mask, *salt, *hash;
9     unsigned long x, y, hLen, modulus_len;
10     int           err;
11     hash_state    md;
12     LTC_ARGCHK(msghash != NULL);
13     LTC_ARGCHK(res     != NULL);
14     *res = 0;
15     if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) {
16        return err;
17     }
18     hLen        = hash_descriptor[hash_idx].hashsize;
19     modulus_bitlen--;
20     modulus_len = (modulus_bitlen>>3) + (modulus_bitlen & 7 ? 1 : 0);
21     if ((saltlen > modulus_len) ||
22         (modulus_len < hLen + saltlen + 2)) {
23        return CRYPT_PK_INVALID_SIZE;
24     }
25     DB   = XMALLOC(modulus_len);
26     mask = XMALLOC(modulus_len);
27     salt = XMALLOC(modulus_len);
28     hash = XMALLOC(modulus_len);
29     if (DB == NULL || mask == NULL || salt == NULL || hash == NULL) {
30        if (DB != NULL) {
31           XFREE(DB);
32        }
33        if (mask != NULL) {
34           XFREE(mask);
35        }
36        if (salt != NULL) {
37           XFREE(salt);
38        }
39        if (hash != NULL) {
40           XFREE(hash);
41        }
42        return CRYPT_MEM;
43     }
44     if (sig[siglen-1] != 0xBC) {
45        err = CRYPT_INVALID_PACKET;
46        goto LBL_ERR;
47     }
48     x = 0;
49     XMEMCPY(DB, sig + x, modulus_len - hLen - 1);
50     x += modulus_len - hLen - 1;
51     XMEMCPY(hash, sig + x, hLen);
52     if ((sig[0] & ~(0xFF >> ((modulus_len<<3) - (modulus_bitlen)))) != 0) {
53        err = CRYPT_INVALID_PACKET;
54        goto LBL_ERR;
55     }
56     if ((err = pkcs_1_mgf1(hash_idx, hash, hLen, mask, modulus_len - hLen - 1)) != CRYPT_OK) {
57        goto LBL_ERR;
58     }
59     for (y = 0; y < (modulus_len - hLen - 1); y++) {
60        DB[y] ^= mask[y];
61     }
62     DB[0] &= 0xFF >> ((modulus_len<<3) - (modulus_bitlen));
63     for (x = 0; x < modulus_len - saltlen - hLen - 2; x++) {
64         if (DB[x] != 0x00) {
65            err = CRYPT_INVALID_PACKET;
66            goto LBL_ERR;
67         }
68     }
69     if (DB[x++] != 0x01) {
70        err = CRYPT_INVALID_PACKET;
71        goto LBL_ERR;
72     }
73     if ((err = hash_descriptor[hash_idx].init(&md)) != CRYPT_OK) {
74        goto LBL_ERR;
75     }
76     zeromem(mask, 8);
77     if ((err = hash_descriptor[hash_idx].process(&md, mask, 8)) != CRYPT_OK) {
78        goto LBL_ERR;
79     }
80     if ((err = hash_descriptor[hash_idx].process(&md, msghash, msghashlen)) != CRYPT_OK) {
81        goto LBL_ERR;
82     }
83     if ((err = hash_descriptor[hash_idx].process(&md, DB+x, saltlen)) != CRYPT_OK) {
84        goto LBL_ERR;
85     }
86     if ((err = hash_descriptor[hash_idx].done(&md, mask)) != CRYPT_OK) {
87        goto LBL_ERR;
88     }
89     if (XMEM_NEQ(mask, hash, hLen) == 0) {
90        *res = 1;
91     }
92     err = CRYPT_OK;
93  LBL_ERR:
94  #ifdef LTC_CLEAN_STACK
95     zeromem(DB,   modulus_len);
96     zeromem(mask, modulus_len);
97     zeromem(salt, modulus_len);
98     zeromem(hash, modulus_len);
99  #endif
100     XFREE(hash);
101     XFREE(salt);
102     XFREE(mask);
103     XFREE(DB);
104     return err;
105  }
106  #endif &bsol;* LTC_PKCS_1 */
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_import_pkcs8.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_MECC
3  typedef struct {
4     ltc_asn1_type t;
5     ltc_asn1_list **pp;
6  } der_flexi_check;
7  #define LTC_SET_DER_FLEXI_CHECK(list, index, Type, P)    \
8     do {                                         \
9        int LTC_SDFC_temp##__LINE__ = (index);   \
10        list[LTC_SDFC_temp##__LINE__].t = Type;  \
11        list[LTC_SDFC_temp##__LINE__].pp = P;    \
12     } while (0)
13  static int s_der_flexi_sequence_cmp(const ltc_asn1_list *flexi, der_flexi_check *check)
14  {
15     const ltc_asn1_list *cur;
16     if (flexi->type != LTC_ASN1_SEQUENCE) {
17        return CRYPT_INVALID_PACKET;
18     }
19     cur = flexi->child;
20     while(check->t != LTC_ASN1_EOL) {
21        if (!LTC_ASN1_IS_TYPE(cur, check->t)) {
22           return CRYPT_INVALID_PACKET;
23        }
24        if (check->pp != NULL) *check->pp = (ltc_asn1_list*)cur;
25        cur = cur->next;
26        check++;
27     }
28     return CRYPT_OK;
29  }
<span onclick='openModal()' class='match'>30  int ecc_import_pkcs8(const unsigned char *in, unsigned long inlen,
31                       const void *pwd, unsigned long pwdlen,
</span>32                       ecc_key *key)
33  {
34     void          *a, *b, *gx, *gy;
35     unsigned long len, cofactor, n;
36     const char    *pka_ec_oid;
37     int           err;
38     char          OID[256];
39     const ltc_ecc_curve *curve;
40     ltc_asn1_list *p = NULL, *l = NULL;
41     der_flexi_check flexi_should[7];
42     ltc_asn1_list *seq, *priv_key;
43     LTC_ARGCHK(in          != NULL);
44     LTC_ARGCHK(key         != NULL);
45     LTC_ARGCHK(ltc_mp.name != NULL);
46     err = pk_get_oid(LTC_OID_EC, &pka_ec_oid);
47     if (err != CRYPT_OK) return err;
48     err = mp_init_multi(&a, &b, &gx, &gy, LTC_NULL);
49     if (err != CRYPT_OK) return err;
50     if ((err = pkcs8_decode_flexi(in, inlen, pwd, pwdlen, &l)) == CRYPT_OK) {
51        n=0;
52        LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, NULL);
53        LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_SEQUENCE, &seq);
54        LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_OCTET_STRING, &priv_key);
55        LTC_SET_DER_FLEXI_CHECK(flexi_should, n, LTC_ASN1_EOL, NULL);
56        if (((err = s_der_flexi_sequence_cmp(l, flexi_should)) == CRYPT_OK) &&
57              (pk_oid_cmp_with_asn1(pka_ec_oid, seq->child) == CRYPT_OK)) {
58           ltc_asn1_list *version, *field, *point, *point_g, *order, *p_cofactor;
59           n=0;
60           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &version);
61           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_SEQUENCE, &field);
62           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_SEQUENCE, &point);
63           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_OCTET_STRING, &point_g);
64           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &order);
65           LTC_SET_DER_FLEXI_CHECK(flexi_should, n++, LTC_ASN1_INTEGER, &p_cofactor);
66           LTC_SET_DER_FLEXI_CHECK(flexi_should, n, LTC_ASN1_EOL, NULL);
67           if (LTC_ASN1_IS_TYPE(seq->child->next, LTC_ASN1_OBJECT_IDENTIFIER)) {
68              ltc_asn1_list *curve_oid = seq->child->next;
69              len = sizeof(OID);
70              if ((err = pk_oid_num_to_str(curve_oid->data, curve_oid->size, OID, &len)) != CRYPT_OK) { goto LBL_DONE; }
71              if ((err = ecc_find_curve(OID, &curve)) != CRYPT_OK)                          { goto LBL_DONE; }
72              if ((err = ecc_set_curve(curve, key)) != CRYPT_OK)                            { goto LBL_DONE; }
73           }
74           else if ((err = s_der_flexi_sequence_cmp(seq->child->next, flexi_should)) == CRYPT_OK) {
75              if (mp_get_int(version->data) != 1) {
76                 goto LBL_DONE;
77              }
78              cofactor = mp_get_int(p_cofactor->data);
79              if (LTC_ASN1_IS_TYPE(field->child, LTC_ASN1_OBJECT_IDENTIFIER) &&
80                  LTC_ASN1_IS_TYPE(field->child->next, LTC_ASN1_INTEGER) &&
81                  LTC_ASN1_IS_TYPE(point->child, LTC_ASN1_OCTET_STRING) &&
82                  LTC_ASN1_IS_TYPE(point->child->next, LTC_ASN1_OCTET_STRING)) {
83                 ltc_asn1_list *prime = field->child->next;
84                 if ((err = mp_read_unsigned_bin(a, point->child->data, point->child->size)) != CRYPT_OK) {
85                    goto LBL_DONE;
86                 }
87                 if ((err = mp_read_unsigned_bin(b, point->child->next->data, point->child->next->size)) != CRYPT_OK) {
88                    goto LBL_DONE;
89                 }
90                 if ((err = ltc_ecc_import_point(point_g->data, point_g->size, prime->data, a, b, gx, gy)) != CRYPT_OK) {
91                    goto LBL_DONE;
92                 }
93                 if ((err = ecc_set_curve_from_mpis(a, b, prime->data, order->data, gx, gy, cofactor, key)) != CRYPT_OK) {
94                    goto LBL_DONE;
95                 }
96              }
97           }
98           else {
99              err = CRYPT_INVALID_PACKET;
100              goto LBL_DONE;
101           }
102           len = priv_key->size;
103           if ((err = der_decode_sequence_flexi(priv_key->data, &len, &p)) == CRYPT_OK) {
104              if (p->type == LTC_ASN1_SEQUENCE &&
105                  LTC_ASN1_IS_TYPE(p->child, LTC_ASN1_INTEGER) &&
106                  LTC_ASN1_IS_TYPE(p->child->next, LTC_ASN1_OCTET_STRING)) {
107                 ltc_asn1_list *lk = p->child->next;
108                 if (mp_cmp_d(p->child->data, 1) != LTC_MP_EQ) {
109                    err = CRYPT_INVALID_PACKET;
110                    goto LBL_ECCFREE;
111                 }
112                 if ((err = ecc_set_key(lk->data, lk->size, PK_PRIVATE, key)) != CRYPT_OK) {
113                    goto LBL_ECCFREE;
114                 }
115                 goto LBL_DONE; &bsol;* success */
116              }
117           }
118        }
119     }
120     err = CRYPT_INVALID_PACKET;
121     goto LBL_DONE;
122  LBL_ECCFREE:
123     ecc_free(key);
124  LBL_DONE:
125     mp_clear_multi(a, b, gx, gy, LTC_NULL);
126     if (l) der_free_sequence_flexi(l);
127     if (p) der_free_sequence_flexi(p);
128     return err;
129  }
130  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-pkcs_1_pss_decode.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-ecc_import_pkcs8.c</div>
                </div>
                <div class="column column_space"><pre><code>3  int pkcs_1_pss_decode(const unsigned char *msghash, unsigned long msghashlen,
4                        const unsigned char *sig,     unsigned long siglen,
</pre></code></div>
                <div class="column column_space"><pre><code>30  int ecc_import_pkcs8(const unsigned char *in, unsigned long inlen,
31                       const void *pwd, unsigned long pwdlen,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    