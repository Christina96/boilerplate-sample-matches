<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for invert.c &amp; interpolate.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for invert.c &amp; interpolate.c
      </h3>
<h1 align="center">
        7.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>invert.c (15.0%)<th>interpolate.c (4.743083%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(156-167)<td><a href="#" name="0">(169-185)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>invert.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include "unary.h"
9 typedef VipsUnary VipsInvert;
10 typedef VipsUnaryClass VipsInvertClass;
11 G_DEFINE_TYPE( VipsInvert, vips_invert, VIPS_TYPE_UNARY );
12 #define LOOP( TYPE, L ) { \
13 	TYPE * restrict p = (TYPE *) in[0]; \
14 	TYPE * restrict q = (TYPE *) out; \
15 	\
16 	for( x = 0; x &lt; sz; x++ ) \
17 		q[x] = (L) - p[x]; \
18 }
19 #define LOOPN( TYPE ) { \
20 	TYPE * restrict p = (TYPE *) in[0]; \
21 	TYPE * restrict q = (TYPE *) out; \
22 	\
23 	for( x = 0; x &lt; sz; x++ ) \
24 		q[x] = -1 * p[x]; \
25 }
26 #define LOOPC( TYPE ) { \
27 	TYPE * restrict p = (TYPE *) in[0]; \
28 	TYPE * restrict q = (TYPE *) out; \
29 	\
30 	for( x = 0; x &lt; sz; x++ ) { \
31 		q[0] = -1 * p[0]; \
32 		q[1] = p[1]; \
33  		\
34 		p += 2; \
35 		q += 2; \
36 	} \
37 }
38 static void
39 vips_invert_buffer( VipsArithmetic *arithmetic, 
40 	VipsPel *out, VipsPel **in, int width )
41 {
42 	VipsImage *im = arithmetic-&gt;ready[0];
43 	const int sz = width * vips_image_get_bands( im );
44 	int x;
45 	switch( vips_image_get_format( im ) ) {
46 	case VIPS_FORMAT_UCHAR: 	
47 		LOOP( unsigned char, UCHAR_MAX ); break; 
48 	case VIPS_FORMAT_CHAR: 	
49 		LOOPN( signed char ); break; 
50 	case VIPS_FORMAT_USHORT: 
51 		LOOP( unsigned short, USHRT_MAX ); break; 
52 	case VIPS_FORMAT_SHORT: 	
53 		LOOPN( signed short ); break; 
54 	case VIPS_FORMAT_UINT: 	
55 		LOOP( unsigned int, UINT_MAX ); break; 
56 	case VIPS_FORMAT_INT: 	
57 		LOOPN( signed int ); break; 
58 	case VIPS_FORMAT_FLOAT: 		
59 		LOOPN( float ); break; 
60 	case VIPS_FORMAT_DOUBLE:	
61 		LOOPN( double ); break;
62 	case VIPS_FORMAT_COMPLEX: 
63 		LOOPC( float ); break;
64 	case VIPS_FORMAT_DPCOMPLEX: 
65 		LOOPC( double ); break;
66 	default:
67 		g_assert_not_reached();
68 	}
69 }
70 #define UC VIPS_FORMAT_UCHAR
71 #define C VIPS_FORMAT_CHAR
72 #define US VIPS_FORMAT_USHORT
73 #define S VIPS_FORMAT_SHORT
74 #define UI VIPS_FORMAT_UINT
75 #define I VIPS_FORMAT_INT
76 #define F VIPS_FORMAT_FLOAT
77 #define X VIPS_FORMAT_COMPLEX
78 #define D VIPS_FORMAT_DOUBLE
79 #define DX VIPS_FORMAT_DPCOMPLEX
80 <a name="0"></a>static const VipsBandFormat vips_invert_format_table[10] = {
81    UC, C,  US, S,  UI, I,  F,  X,  D,  DX 
82 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
83 static void
84 vips_invert_class_init( VipsInvertClass *class )
85 {
86 	VipsObjectClass *object_class = (VipsObjectClass *) class;
87 	VipsArithmeticClass *aclass = VIPS_ARITHMETIC_CLASS( class );
88 	object_class-&gt;nickname = "invert";
89 	object_class-&gt;description = _( "invert an image" );
90 	aclass-&gt;process_line = vips_invert_buffer;</b></font>
91 	vips_arithmetic_set_format_table( aclass, vips_invert_format_table ); 
92 }
93 static void
94 vips_invert_init( VipsInvert *invert )
95 {
96 }
97 int
98 vips_invert( VipsImage *in, VipsImage **out, ... )
99 {
100 	va_list ap;
101 	int result;
102 	va_start( ap, out );
103 	result = vips_call_split( "invert", ap, in, out );
104 	va_end( ap );
105 	return( result );
106 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>interpolate.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;vips/vips.h&gt;
7 #include &lt;vips/internal.h&gt;
8 G_DEFINE_ABSTRACT_TYPE( VipsInterpolate, vips_interpolate, VIPS_TYPE_OBJECT );
9 #ifdef DEBUG
10 static void
11 vips_interpolate_finalize( GObject *gobject )
12 {
13 	printf( "vips_interpolate_finalize: " );
14 	vips_object_print_name( VIPS_OBJECT( gobject ) );
15 	G_OBJECT_CLASS( vips_interpolate_parent_class )-&gt;finalize( gobject );
16 }
17 static int
18 vips_interpolate_real_get_window_size( VipsInterpolate *interpolate )
19 {
20 	VipsInterpolateClass *class = VIPS_INTERPOLATE_GET_CLASS( interpolate );
21 	g_assert( class-&gt;window_size != -1 );
22 	return( class-&gt;window_size );
23 }
24 static int
25 vips_interpolate_real_get_window_offset( VipsInterpolate *interpolate )
26 {
27 	VipsInterpolateClass *class = VIPS_INTERPOLATE_GET_CLASS( interpolate );
28 	if( class-&gt;window_offset != -1 )
29 		return( class-&gt;window_offset );
30 	else {
31 		int window_size = 
32 			vips_interpolate_get_window_size( interpolate );
33 		return( VIPS_MAX( 0, window_size / 2 - 1 ) );
34 	}
35 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
36 static void
37 vips_interpolate_class_init( VipsInterpolateClass *class )
38 {
39 	VipsObjectClass *vobject_class = VIPS_OBJECT_CLASS( class );
40 #ifdef DEBUG
41 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
42 #ifdef DEBUG
43 	gobject_class-&gt;finalize = vips_interpolate_finalize;
44 	vobject_class-&gt;nickname = "interpolate";
45 	vobject_class-&gt;description = _( "VIPS interpolators" );</b></font>
46 	class-&gt;interpolate = NULL;
47 	class-&gt;get_window_size = vips_interpolate_real_get_window_size;
48 	class-&gt;get_window_offset = vips_interpolate_real_get_window_offset;
49 	class-&gt;window_size = -1;
50 	class-&gt;window_offset = -1;
51 }
52 static void
53 vips_interpolate_init( VipsInterpolate *interpolate )
54 {
55 #ifdef DEBUG
56 	printf( "vips_interpolate_init: " );
57 	vips_object_print_name( VIPS_OBJECT( interpolate ) );
58 }
59 void
60 vips_interpolate( VipsInterpolate *interpolate,
61 	void *out, VipsRegion *in, double x, double y )
62 {
63 	VipsInterpolateClass *class = VIPS_INTERPOLATE_GET_CLASS( interpolate );
64 	g_assert( class-&gt;interpolate );
65 	class-&gt;interpolate( interpolate, out, in, x, y );
66 }
67 VipsInterpolateMethod
68 vips_interpolate_get_method( VipsInterpolate *interpolate )
69 {
70 	VipsInterpolateClass *class = VIPS_INTERPOLATE_GET_CLASS( interpolate );
71 	g_assert( class-&gt;interpolate );
72 	return( class-&gt;interpolate );
73 }
74 int
75 vips_interpolate_get_window_size( VipsInterpolate *interpolate )
76 {
77 	VipsInterpolateClass *class = VIPS_INTERPOLATE_GET_CLASS( interpolate );
78 	g_assert( class-&gt;get_window_size );
79 	return( class-&gt;get_window_size( interpolate ) );
80 }
81 int
82 vips_interpolate_get_window_offset( VipsInterpolate *interpolate )
83 {
84 	VipsInterpolateClass *class = VIPS_INTERPOLATE_GET_CLASS( interpolate );
85 	g_assert( class-&gt;get_window_offset );
86 	return( class-&gt;get_window_offset( interpolate ) );
87 }
88 #define VIPS_TYPE_INTERPOLATE_NEAREST (vips_interpolate_nearest_get_type())
89 #define VIPS_INTERPOLATE_NEAREST( obj ) \
90 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
91 	VIPS_TYPE_INTERPOLATE_NEAREST, VipsInterpolateNearest ))
92 #define VIPS_INTERPOLATE_NEAREST_CLASS( klass ) \
93 	(G_TYPE_CHECK_CLASS_CAST( (klass), \
94 	VIPS_TYPE_INTERPOLATE_NEAREST, VipsInterpolateNearestClass))
95 #define VIPS_IS_INTERPOLATE_NEAREST( obj ) \
96 	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_INTERPOLATE_NEAREST ))
97 #define VIPS_IS_INTERPOLATE_NEAREST_CLASS( klass ) \
98 	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_INTERPOLATE_NEAREST ))
99 #define VIPS_INTERPOLATE_NEAREST_GET_CLASS( obj ) \
100 	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
101 	VIPS_TYPE_INTERPOLATE_NEAREST, VipsInterpolateNearestClass ))
102 typedef VipsInterpolate VipsInterpolateNearest;
103 typedef VipsInterpolateClass VipsInterpolateNearestClass;
104 G_DEFINE_TYPE( VipsInterpolateNearest, vips_interpolate_nearest,
105 	VIPS_TYPE_INTERPOLATE );
106 static void
107 vips_interpolate_nearest_interpolate( VipsInterpolate *interpolate,
108 	void *out, VipsRegion *in, double x, double y )
109 {
110 	const int ps = VIPS_IMAGE_SIZEOF_PEL( in-&gt;im );
111 	const int xi = (int) x;
112 	const int yi = (int) y;
113 	const VipsPel * restrict p = VIPS_REGION_ADDR( in, xi, yi );
114 	VipsPel * restrict q = (VipsPel *) out;
115 	int z;
116 	for( z = 0; z &lt; ps; z++ )
117 		q[z] = p[z];
118 }
119 static void
120 vips_interpolate_nearest_class_init( VipsInterpolateNearestClass *class )
121 {
122 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( class );
123 	VipsInterpolateClass *interpolate_class =
124 		VIPS_INTERPOLATE_CLASS( class );
125 	object_class-&gt;nickname = "nearest";
126 	object_class-&gt;description = _( "nearest-neighbour interpolation" );
127 	interpolate_class-&gt;interpolate = vips_interpolate_nearest_interpolate;
128 	interpolate_class-&gt;window_size = 1;
129 }
130 static void
131 vips_interpolate_nearest_init( VipsInterpolateNearest *nearest )
132 {
133 #ifdef DEBUG
134 	printf( "vips_interpolate_nearest_init: " );
135 	vips_object_print_name( VIPS_OBJECT( nearest ) );
136 }
137 VipsInterpolate *
138 vips_interpolate_nearest_new( void )
139 {
140 	return( VIPS_INTERPOLATE( vips_object_new(
141 		VIPS_TYPE_INTERPOLATE_NEAREST, NULL, NULL, NULL ) ) );
142 }
143 VipsInterpolate *
144 vips_interpolate_nearest_static( void )
145 {
146 	static VipsInterpolate *interpolate = NULL;
147 	if( !interpolate ) {
148 		interpolate = vips_interpolate_nearest_new();
149 		vips_object_set_static( VIPS_OBJECT( interpolate ), TRUE );
150 	}
151 	return( interpolate );
152 }
153 #define VIPS_TYPE_INTERPOLATE_BILINEAR (vips_interpolate_bilinear_get_type())
154 #define VIPS_INTERPOLATE_BILINEAR( obj ) \
155 	(G_TYPE_CHECK_INSTANCE_CAST( (obj), \
156 	VIPS_TYPE_INTERPOLATE_BILINEAR, VipsInterpolateBilinear ))
157 #define VIPS_INTERPOLATE_BILINEAR_CLASS( klass ) \
158 	(G_TYPE_CHECK_CLASS_CAST( (klass), \
159 	VIPS_TYPE_INTERPOLATE_BILINEAR, VipsInterpolateBilinearClass))
160 #define VIPS_IS_INTERPOLATE_BILINEAR( obj ) \
161 	(G_TYPE_CHECK_INSTANCE_TYPE( (obj), VIPS_TYPE_INTERPOLATE_BILINEAR ))
162 #define VIPS_IS_INTERPOLATE_BILINEAR_CLASS( klass ) \
163 	(G_TYPE_CHECK_CLASS_TYPE( (klass), VIPS_TYPE_INTERPOLATE_BILINEAR ))
164 #define VIPS_INTERPOLATE_BILINEAR_GET_CLASS( obj ) \
165 	(G_TYPE_INSTANCE_GET_CLASS( (obj), \
166 	VIPS_TYPE_INTERPOLATE_BILINEAR, VipsInterpolateBilinearClass ))
167 typedef VipsInterpolate VipsInterpolateBilinear;
168 typedef VipsInterpolateClass VipsInterpolateBilinearClass;
169 G_DEFINE_TYPE( VipsInterpolateBilinear, vips_interpolate_bilinear,
170 	VIPS_TYPE_INTERPOLATE );
171 #define BILINEAR_INT_INNER { \
172 	tq[z] = (c1 * tp1[z] + c2 * tp2[z] + \
173 		 c3 * tp3[z] + c4 * tp4[z] + \
174 		 (1 &lt;&lt; VIPS_INTERPOLATE_SHIFT) / 2) &gt;&gt; VIPS_INTERPOLATE_SHIFT; \
175 	z += 1; \
176 }
177 #define BILINEAR_INT( TYPE ) { \
178 	TYPE * restrict tq = (TYPE *) out; \
179 	\
180 	int X = (x - ix) * VIPS_INTERPOLATE_SCALE; \
181 	int Y = (y - iy) * VIPS_INTERPOLATE_SCALE; \
182 	\
183 	int Yd = VIPS_INTERPOLATE_SCALE - Y; \
184         \
185 	int c4 = (Y * X) &gt;&gt; VIPS_INTERPOLATE_SHIFT; \
186 	int c2 = (Yd * X) &gt;&gt; VIPS_INTERPOLATE_SHIFT; \
187 	int c3 = Y - c4; \
188 	int c1 = Yd - c2; \
189 	\
190 	const TYPE * restrict tp1 = (TYPE *) p1; \
191 	const TYPE * restrict tp2 = (TYPE *) p2; \
192 	const TYPE * restrict tp3 = (TYPE *) p3; \
193 	const TYPE * restrict tp4 = (TYPE *) p4; \
194 	\
195 	z = 0; \
196 	VIPS_UNROLL( b, BILINEAR_INT_INNER ); \
197 }
198 #define BILINEAR_FLOAT_INNER { \
199 	tq[z] = c1 * tp1[z] + c2 * tp2[z] + \
200 		c3 * tp3[z] + c4 * tp4[z]; \
201 	z += 1; \
202 }
203 #define BILINEAR_FLOAT( TYPE ) { \
204 	TYPE * restrict tq = (TYPE *) out; \
205 	\
206 	double X = x - ix; \
207 	double Y = y - iy; \
208         \
209 	double Yd = 1.0f - Y; \
210         \
211 	double c4 = Y * X; \
212 	double c2 = Yd * X; \
213 	double c3 = Y - c4; \
214 	double c1 = Yd - c2; \
215  	\
216 	const TYPE * restrict tp1 = (TYPE *) p1; \
217 	const TYPE * restrict tp2 = (TYPE *) p2; \
218 	const TYPE * restrict tp3 = (TYPE *) p3; \
219 	const TYPE * restrict tp4 = (TYPE *) p4; \
220 	\
221 	z = 0; \
222 	VIPS_UNROLL( b, BILINEAR_FLOAT_INNER ); \
223 }
224 #define SWITCH_INTERPOLATE( FMT, INT, FLOAT ) { \
225 	switch( (FMT) ) { \
226 	case VIPS_FORMAT_UCHAR:	INT( unsigned char ); break; \
227 	case VIPS_FORMAT_CHAR: 	INT( char ); break; \
228 	case VIPS_FORMAT_USHORT:INT( unsigned short ); break; \
229 	case VIPS_FORMAT_SHORT: INT( short ); break; \
230 	case VIPS_FORMAT_UINT: 	FLOAT( unsigned int ); break; \
231 	case VIPS_FORMAT_INT: 	FLOAT( int );  break; \
232 	case VIPS_FORMAT_FLOAT: FLOAT( float ); break; \
233 	case VIPS_FORMAT_DOUBLE:FLOAT( double ); break; \
234 	case VIPS_FORMAT_COMPLEX: FLOAT( float ); break; \
235 	case VIPS_FORMAT_DPCOMPLEX:FLOAT( double ); break; \
236 	default: \
237 		g_assert( FALSE ); \
238 	} \
239 }
240 static void
241 vips_interpolate_bilinear_interpolate( VipsInterpolate *interpolate,
242 	void *out, VipsRegion *in, double x, double y )
243 {
244 	const int ps = VIPS_IMAGE_SIZEOF_PEL( in-&gt;im );
245 	const int ls = VIPS_REGION_LSKIP( in );
246 	const int b = in-&gt;im-&gt;Bands *
247 		(vips_band_format_iscomplex( in-&gt;im-&gt;BandFmt ) ?  2 : 1);
248 	const int ix = (int) x;
249 	const int iy = (int) y;
250 	const VipsPel * restrict p1 = VIPS_REGION_ADDR( in, ix, iy );
251 	const VipsPel * restrict p2 = p1 + ps;
252 	const VipsPel * restrict p3 = p1 + ls;
253 	const VipsPel * restrict p4 = p3 + ps;
254 	int z;
255 	g_assert( (int) x &gt;= in-&gt;valid.left );
256 	g_assert( (int) y &gt;= in-&gt;valid.top );
257 	g_assert( (int) x + 1 &lt; VIPS_RECT_RIGHT( &amp;in-&gt;valid ) );
258 	g_assert( (int) y + 1 &lt; VIPS_RECT_BOTTOM( &amp;in-&gt;valid ) );
259 	SWITCH_INTERPOLATE( in-&gt;im-&gt;BandFmt, BILINEAR_INT, BILINEAR_FLOAT );
260 }
261 static void
262 vips_interpolate_bilinear_class_init( VipsInterpolateBilinearClass *class )
263 {
264 	VipsObjectClass *object_class = VIPS_OBJECT_CLASS( class );
265 	VipsInterpolateClass *interpolate_class =
266 		(VipsInterpolateClass *) class;
267 	object_class-&gt;nickname = "bilinear";
268 	object_class-&gt;description = _( "bilinear interpolation" );
269 	interpolate_class-&gt;interpolate = vips_interpolate_bilinear_interpolate;
270 	interpolate_class-&gt;window_size = 2;
271 }
272 static void
273 vips_interpolate_bilinear_init( VipsInterpolateBilinear *bilinear )
274 {
275 #ifdef DEBUG
276 	printf( "vips_interpolate_bilinear_init: " );
277 	vips_object_print_name( VIPS_OBJECT( bilinear ) );
278 }
279 VipsInterpolate *
280 vips_interpolate_bilinear_new( void )
281 {
282 	return( VIPS_INTERPOLATE( vips_object_new(
283 		VIPS_TYPE_INTERPOLATE_BILINEAR, NULL, NULL, NULL ) ) );
284 }
285 VipsInterpolate *
286 vips_interpolate_bilinear_static( void )
287 {
288 	static VipsInterpolate *interpolate = NULL;
289 	if( !interpolate ) {
290 		interpolate = vips_interpolate_bilinear_new();
291 		vips_object_set_static( VIPS_OBJECT( interpolate ), TRUE );
292 	}
293 	return( interpolate );
294 }
295 void
296 vips__interpolate_init( void )
297 {
298 	extern GType vips_interpolate_bicubic_get_type( void );
299 	extern GType vips_interpolate_lbb_get_type( void );
300 	extern GType vips_interpolate_nohalo_get_type( void );
301 	extern GType vips_interpolate_vsqbs_get_type( void );
302 	vips_interpolate_nearest_get_type();
303 	vips_interpolate_bilinear_get_type();
304 	vips_interpolate_bicubic_get_type();
305 	vips_interpolate_lbb_get_type();
306 	vips_interpolate_nohalo_get_type();
307 	vips_interpolate_vsqbs_get_type();
308 }
309 VipsInterpolate *
310 vips_interpolate_new( const char *nickname )
311 {
312 	GType type;
313 	if( !(type = vips_type_find( "VipsInterpolate", nickname )) ) {
314 		vips_error( "VipsInterpolate", 
315 			_( "class \"%s\" not found" ), nickname );
316 		return( NULL );
317 	}
318 	return( VIPS_INTERPOLATE( vips_object_new( type, NULL, NULL, NULL ) ) );
319 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
