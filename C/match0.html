<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for libsvm_helper.c &amp; libsvm_sparse_helper.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for libsvm_helper.c &amp; libsvm_sparse_helper.c
      </h3>
<h1 align="center">
        58.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>libsvm_helper.c (67.46411%)<th>libsvm_sparse_helper.c (52.31911%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(115-141)<td><a href="#" name="0">(109-137)</a><td align="center"><font color="#ff0000">47</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(166-192)<td><a href="#" name="1">(164-190)</a><td align="center"><font color="#c80000">37</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(286-314)<td><a href="#" name="2">(380-409)</a><td align="center"><font color="#970000">28</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(237-256)<td><a href="#" name="3">(342-364)</a><td align="center"><font color="#870000">25</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(405-424)<td><a href="#" name="4">(452-471)</a><td align="center"><font color="#6c0000">20</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(70-86)<td><a href="#" name="5">(58-74)</a><td align="center"><font color="#670000">19</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(65-69)<td><a href="#" name="6">(50-54)</a><td align="center"><font color="#670000">19</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(258-274)<td><a href="#" name="7">(330-341)</a><td align="center"><font color="#610000">18</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(369-403)<td><a href="#" name="8">(417-439)</a><td align="center"><font color="#560000">16</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(323-333)<td><a href="#" name="9">(266-277)</a><td align="center"><font color="#4b0000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(339-353)<td><a href="#" name="10">(286-299)</a><td align="center"><font color="#460000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(159-165)<td><a href="#" name="11">(146-152)</a><td align="center"><font color="#460000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(47-52)<td><a href="#" name="12">(19-26)</a><td align="center"><font color="#460000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>libsvm_helper.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;stdlib.h&gt;
2 #include &lt;numpy/arrayobject.h&gt;
3 #include "svm.h"
4 #include "_svm_cython_blas_helpers.h"
5 #ifndef MAX
6     #define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
7 #endif
8 struct svm_node *dense_to_libsvm (double *x, npy_intp *dims)
9 {
10     struct svm_node *node;
11     npy_intp len_row = dims[1];
12 <a name="12"></a>    double *tx = x;
13     int i;
14 <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    node = malloc (dims[0] * sizeof(struct svm_node));
15     if (node == NULL) return NULL;
16     for (i=0; i&lt;dims[0]; ++i) {
17         node[i].values = tx;
18         node[i].dim = (int) len_row;</b></font>
19         tx += len_row;
20     }
21     return node;
22 }
23 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>void set_parameter(struct svm_parameter *param, int svm_type, int kernel_type, int degree,
24 		double gamma, double coef0, double nu, double cache_size, double C,
25 <a name="5"></a>		double eps, double p, int shrinking, int probability, int nr_weight,
26 		char *weight_label, char *weight, int max_iter, int random_seed)
27 {</b></font>
28 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    param-&gt;svm_type = svm_type;
29     param-&gt;kernel_type = kernel_type;
30     param-&gt;degree = degree;
31     param-&gt;coef0 = coef0;
32     param-&gt;nu = nu;
33     param-&gt;cache_size = cache_size;
34     param-&gt;C = C;
35     param-&gt;eps = eps;
36     param-&gt;p = p;
37     param-&gt;shrinking = shrinking;
38     param-&gt;probability = probability;
39     param-&gt;nr_weight = nr_weight;
40     param-&gt;weight_label = (int *) weight_label;
41     param-&gt;weight = (double *) weight;
42     param-&gt;gamma = gamma;
43     param-&gt;max_iter = max_iter;
44     param-&gt;random_seed = random_seed;</b></font>
45 }
46 void set_problem(struct svm_problem *problem, char *X, char *Y, char *sample_weight, npy_intp *dims, int kernel_type)
47 {
48     if (problem == NULL) return;
49     problem-&gt;l = (int) dims[0];     problem-&gt;y = (double *) Y;
50     problem-&gt;x = dense_to_libsvm((double *) X, dims);     problem-&gt;W = (double *) sample_weight;
51 }
52 struct svm_model *set_model(struct svm_parameter *param, int nr_class,
53 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                            char *SV, npy_intp *SV_dims,
54                             char *support, npy_intp *support_dims,
55                             npy_intp *sv_coef_strides,
56                             char *sv_coef, char *rho, char *nSV,
57                             char *probA, char *probB)
58 {
59     struct svm_model *model;
60     double *dsv_coef = (double *) sv_coef;
61     int i, m;
62     m = nr_class * (nr_class-1)/2;
63     if ((model = malloc(sizeof(struct svm_model))) == NULL)
64         goto model_error;
65     if ((model-&gt;nSV = malloc(nr_class * sizeof(int))) == NULL)
66         goto nsv_error;
67     if ((model-&gt;label = malloc(nr_class * sizeof(int))) == NULL)
68         goto label_error;
69     if ((model-&gt;sv_coef = malloc((nr_class-1)*sizeof(double *))) == NULL)
70         goto sv_coef_error;
71     if ((model-&gt;rho = malloc( m * sizeof(double))) == NULL)
72         goto rho_error;
73     model-&gt;n_iter = NULL;
74     model-&gt;nr_class = nr_class;</b></font>
75     model-&gt;param = *param;
76     model-&gt;l = (int) support_dims[0];
77     if (param-&gt;kernel_type == PRECOMPUTED) {
78         if ((model-&gt;SV = malloc ((model-&gt;l) * sizeof(struct svm_node))) == NULL)
79             goto SV_error;
80         for (i=0; i&lt;model-&gt;l; ++i) {
81             model-&gt;SV[i].ind = ((int *) support)[i];
82             model-&gt;SV[i].values = NULL;
83         }
84     } else {
85         model-&gt;SV = dense_to_libsvm((double *) SV, SV_dims);
86     }
87 <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if (param-&gt;svm_type &lt; 2) {
88         memcpy(model-&gt;nSV, nSV,     model-&gt;nr_class * sizeof(int));
89         for(i=0; i &lt; model-&gt;nr_class; i++)
90             model-&gt;label[i] = i;
91 <a name="1"></a>    }
92     for (i=0; i &lt; model-&gt;nr_class-1; i++) {</b></font>
93 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        model-&gt;sv_coef[i] = dsv_coef + i*(model-&gt;l);
94     }
95     for (i=0; i&lt;m; ++i) {
96         (model-&gt;rho)[i] = -((double *) rho)[i];
97     }
98     if (param-&gt;probability) {
99         if ((model-&gt;probA = malloc(m * sizeof(double))) == NULL)
100             goto probA_error;
101         memcpy(model-&gt;probA, probA, m * sizeof(double));
102         if ((model-&gt;probB = malloc(m * sizeof(double))) == NULL)
103             goto probB_error;
104         memcpy(model-&gt;probB, probB, m * sizeof(double));
105     } else {
106         model-&gt;probA = NULL;
107         model-&gt;probB = NULL;
108     }
109     model-&gt;free_sv = 0;
110     return model;</b></font>
111 probB_error:
112     free(model-&gt;probA);
113 probA_error:
114     free(model-&gt;SV);
115 SV_error:
116     free(model-&gt;rho);
117 rho_error:
118     free(model-&gt;sv_coef);
119 sv_coef_error:
120     free(model-&gt;label);
121 label_error:
122     free(model-&gt;nSV);
123 nsv_error:
124     free(model);
125 model_error:
126     return NULL;
127 }
128 npy_intp get_l(struct svm_model *model)
129 {
130     return (npy_intp) model-&gt;l;
131 }
132 npy_intp get_nr(struct svm_model *model)
133 {
134     return (npy_intp) model-&gt;nr_class;
135 }
136 <a name="3"></a>void copy_n_iter(char *data, struct svm_model *model)
137 {
138     const int n_models = MAX(1, model-&gt;nr_class * (model-&gt;nr_class-1) / 2);
139 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    memcpy(data, model-&gt;n_iter, n_models * sizeof(int));
140 }
141 void copy_sv_coef(char *data, struct svm_model *model)
142 {
143     int i, len = model-&gt;nr_class-1;
144     double *temp = (double *) data;
145     for(i=0; i&lt;len; ++i) {
146         memcpy(temp, model-&gt;sv_coef[i], sizeof(double) * model-&gt;l);
147         temp += model-&gt;l;
148     }
149 }
150 <a name="7"></a>void copy_intercept(char *data, struct svm_model *model, npy_intp *dims)
151 {</b></font>
152 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    npy_intp i, n = dims[0];
153     double t, *ddata = (double *) data;
154     for (i=0; i&lt;n; ++i) {
155         t = model-&gt;rho[i];
156         *ddata = (t != 0) ? -t : 0;
157         ++ddata;
158     }
159 }
160 void copy_SV(char *data, struct svm_model *model, npy_intp *dims)
161 {</b></font>
162     int i, n = model-&gt;l;
163     double *tdata = (double *) data;
164     int dim = model-&gt;SV[0].dim;
165     for (i=0; i&lt;n; ++i) {
166         memcpy (tdata, model-&gt;SV[i].values, dim * sizeof(double));
167         tdata += dim;
168     }
169 }
170 <a name="2"></a>
171 void copy_support (char *data, struct svm_model *model)
172 {
173 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    memcpy (data, model-&gt;sv_ind, (model-&gt;l) * sizeof(int));
174 }
175 void copy_nSV(char *data, struct svm_model *model)
176 {
177     if (model-&gt;label == NULL) return;
178     memcpy(data, model-&gt;nSV, model-&gt;nr_class * sizeof(int));
179 }
180 void copy_probA(char *data, struct svm_model *model, npy_intp * dims)
181 {
182     memcpy(data, model-&gt;probA, dims[0] * sizeof(double));
183 }
184 void copy_probB(char *data, struct svm_model *model, npy_intp * dims)
185 {
186     memcpy(data, model-&gt;probB, dims[0] * sizeof(double));
187 }
188 int copy_predict(char *predict, struct svm_model *model, npy_intp *predict_dims,</b></font>
189                  char *dec_values, BlasFunctions *blas_functions)
190 {
191     double *t = (double *) dec_values;
192     struct svm_node *predict_nodes;
193     npy_intp i;
194 <a name="9"></a>
195     predict_nodes = dense_to_libsvm((double *) predict, predict_dims);
196 <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if (predict_nodes == NULL)
197         return -1;
198     for(i=0; i&lt;predict_dims[0]; ++i) {
199         *t = svm_predict(model, &amp;predict_nodes[i], blas_functions);
200         ++t;
201     }
202     free(predict_nodes);
203     return 0;
204 }
205 int copy_predict_values(char *predict, struct svm_model *model,</b></font>
206                         npy_intp *predict_dims, char *dec_values, int nr_class, BlasFunctions *blas_functions)
207 {
208 <a name="10"></a>    npy_intp i;
209     struct svm_node *predict_nodes;
210     predict_nodes = dense_to_libsvm((double *) predict, predict_dims);
211 <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if (predict_nodes == NULL)
212         return -1;
213     for(i=0; i&lt;predict_dims[0]; ++i) {
214         svm_predict_values(model, &amp;predict_nodes[i],
215                                 ((double *) dec_values) + i*nr_class,
216 				blas_functions);
217     }
218     free(predict_nodes);
219     return 0;
220 }
221 int copy_predict_proba(char *predict, struct svm_model *model, npy_intp *predict_dims,</b></font>
222                  char *dec_values, BlasFunctions *blas_functions)
223 {
224     npy_intp i, n, m;
225     struct svm_node *predict_nodes;
226     n = predict_dims[0];
227     m = (npy_intp) model-&gt;nr_class;
228     predict_nodes = dense_to_libsvm((double *) predict, predict_dims);
229     if (predict_nodes == NULL)
230         return -1;
231     for(i=0; i&lt;n; ++i) {
232         svm_predict_probability(model, &amp;predict_nodes[i],
233                                 ((double *) dec_values) + i*m,
234 <a name="8"></a>				blas_functions);
235     }
236     free(predict_nodes);
237 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    return 0;
238 }
239 int free_model(struct svm_model *model)
240 {
241     if (model == NULL) return -1;
242     free(model-&gt;SV);
243     free(model-&gt;sv_coef);
244     free(model-&gt;rho);
245     free(model-&gt;label);
246     free(model-&gt;probA);
247     free(model-&gt;probB);
248     free(model-&gt;nSV);
249     free(model);
250     return 0;
251 }
252 int free_param(struct svm_parameter *param)
253 <a name="4"></a>{
254     if (param == NULL) return -1;</b></font>
255     free(param);
256 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    return 0;
257 }
258 static void print_null(const char *s) {}
259 static void print_string_stdout(const char *s)
260 {
261 	fputs(s,stdout);
262 	fflush(stdout);
263 }
264 void set_verbosity(int verbosity_flag){
265 	if (verbosity_flag)
266 		svm_set_print_string_function(&amp;print_string_stdout);
267 	else
268 		svm_set_print_string_function(&amp;print_null);
269 }</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>libsvm_sparse_helper.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;stdlib.h&gt;
2 #include &lt;numpy/arrayobject.h&gt;
3 #include "svm.h"
4 #include "_svm_cython_blas_helpers.h"
5 #ifndef MAX
6     #define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
7 #endif
8 struct svm_csr_node **csr_to_libsvm (double *values, int* indices, int* indptr, npy_int n_samples)
9 <a name="12"></a>{
10     struct svm_csr_node **sparse, *temp;
11     int i, j=0, k=0, n;
12 <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    sparse = malloc (n_samples * sizeof(struct svm_csr_node *));
13     if (sparse == NULL)
14         return NULL;
15     for (i=0; i&lt;n_samples; ++i) {
16         n = indptr[i+1] - indptr[i];         temp = malloc ((n+1) * sizeof(struct svm_csr_node));</b></font>
17         if (temp == NULL) {
18             for (j=0; j&lt;i; j++)
19                 free(sparse[j]);
20             free(sparse);
21             return NULL;
22         }
23         for (j=0; j&lt;n; ++j) {
24             temp[j].value = values[k];
25             temp[j].index = indices[k] + 1;             ++k;
26         }
27         temp[n].index = -1;
28         sparse[i] = temp;
29     }
30     return sparse;
31 }
32 <a name="6"></a>
33 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>struct svm_parameter * set_parameter(int svm_type, int kernel_type, int degree,
34 		double gamma, double coef0, double nu, double cache_size, double C,
35 		double eps, double p, int shrinking, int probability, int nr_weight,
36 		char *weight_label, char *weight, int max_iter, int random_seed)
37 {</b></font>
38 <a name="5"></a>    struct svm_parameter *param;
39     param = malloc(sizeof(struct svm_parameter));
40     if (param == NULL) return NULL;
41 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    param-&gt;svm_type = svm_type;
42     param-&gt;kernel_type = kernel_type;
43     param-&gt;degree = degree;
44     param-&gt;coef0 = coef0;
45     param-&gt;nu = nu;
46     param-&gt;cache_size = cache_size;
47     param-&gt;C = C;
48     param-&gt;eps = eps;
49     param-&gt;p = p;
50     param-&gt;shrinking = shrinking;
51     param-&gt;probability = probability;
52     param-&gt;nr_weight = nr_weight;
53     param-&gt;weight_label = (int *) weight_label;
54     param-&gt;weight = (double *) weight;
55     param-&gt;gamma = gamma;
56     param-&gt;max_iter = max_iter;
57     param-&gt;random_seed = random_seed;</b></font>
58     return param;
59 }
60 struct svm_csr_problem * csr_set_problem (char *values, npy_intp *n_indices,
61 		char *indices, npy_intp *n_indptr, char *indptr, char *Y,
62                 char *sample_weight, int kernel_type) {
63     struct svm_csr_problem *problem;
64     problem = malloc (sizeof (struct svm_csr_problem));
65     if (problem == NULL) return NULL;
66     problem-&gt;l = (int) n_indptr[0] - 1;
67     problem-&gt;y = (double *) Y;
68     problem-&gt;x = csr_to_libsvm((double *) values, (int *) indices,
69                                (int *) indptr, problem-&gt;l);
70     problem-&gt;W = (double *) sample_weight;
71     if (problem-&gt;x == NULL) {
72         free(problem);
73         return NULL;
74     }
75     return problem;
76 }
77 <a name="0"></a>
78 struct svm_csr_model *csr_set_model(struct svm_parameter *param, int nr_class,
79                             char *SV_data, npy_intp *SV_indices_dims,
80 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>                            char *SV_indices, npy_intp *SV_indptr_dims,
81                             char *SV_intptr,
82                             char *sv_coef, char *rho, char *nSV,
83                             char *probA, char *probB)
84 {
85     struct svm_csr_model *model;
86     double *dsv_coef = (double *) sv_coef;
87     int i, m;
88     m = nr_class * (nr_class-1)/2;
89     if ((model = malloc(sizeof(struct svm_csr_model))) == NULL)
90         goto model_error;
91     if ((model-&gt;nSV = malloc(nr_class * sizeof(int))) == NULL)
92         goto nsv_error;
93     if ((model-&gt;label = malloc(nr_class * sizeof(int))) == NULL)
94         goto label_error;
95     if ((model-&gt;sv_coef = malloc((nr_class-1)*sizeof(double *))) == NULL)
96         goto sv_coef_error;
97     if ((model-&gt;rho = malloc( m * sizeof(double))) == NULL)
98         goto rho_error;
99     model-&gt;n_iter = NULL;
100     model-&gt;l = (int) SV_indptr_dims[0] - 1;</b></font>
101     model-&gt;SV = csr_to_libsvm((double *) SV_data, (int *) SV_indices,
102                               (int *) SV_intptr, model-&gt;l);
103     model-&gt;nr_class = nr_class;
104     model-&gt;param = *param;
105 <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (param-&gt;svm_type &lt; 2) {
106         memcpy(model-&gt;nSV,   nSV,   model-&gt;nr_class * sizeof(int));
107         for(i=0; i &lt; model-&gt;nr_class; i++)
108             model-&gt;label[i] = i;
109     }
110     for (i=0; i &lt; model-&gt;nr_class-1; i++) {</b></font>
111         if ((model-&gt;sv_coef[i] = malloc((model-&gt;l) * sizeof(double))) == NULL) {
112             int j;
113             for (j=0; j&lt;i; j++)
114                 free(model-&gt;sv_coef[j]);
115 <a name="1"></a>            goto sv_coef_i_error;
116         }
117         memcpy(model-&gt;sv_coef[i], dsv_coef, (model-&gt;l) * sizeof(double));
118 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        dsv_coef += model-&gt;l;
119     }
120     for (i=0; i&lt;m; ++i) {
121         (model-&gt;rho)[i] = -((double *) rho)[i];
122     }
123     if (param-&gt;probability) {
124         if ((model-&gt;probA = malloc(m * sizeof(double))) == NULL)
125             goto probA_error;
126         memcpy(model-&gt;probA, probA, m * sizeof(double));
127         if ((model-&gt;probB = malloc(m * sizeof(double))) == NULL)
128             goto probB_error;
129         memcpy(model-&gt;probB, probB, m * sizeof(double));
130     } else {
131         model-&gt;probA = NULL;
132         model-&gt;probB = NULL;
133     }
134     model-&gt;free_sv = 0;
135     return model;</b></font>
136 probB_error:
137     free(model-&gt;probA);
138 probA_error:
139     for (i=0; i &lt; model-&gt;nr_class-1; i++)
140         free(model-&gt;sv_coef[i]);
141 sv_coef_i_error:
142     free(model-&gt;rho);
143 rho_error:
144     free(model-&gt;sv_coef);
145 sv_coef_error:
146     free(model-&gt;label);
147 label_error:
148     free(model-&gt;nSV);
149 nsv_error:
150     free(model);
151 model_error:
152     return NULL;
153 }
154 int csr_copy_SV (char *data, npy_intp *n_indices,
155 		char *indices, npy_intp *n_indptr, char *indptr,
156 		struct svm_csr_model *model, int n_features)
157 {
158 	int i, j, k=0, index;
159 	double *dvalues = (double *) data;
160 	int *iindices = (int *) indices;
161 	int *iindptr  = (int *) indptr;
162 	iindptr[0] = 0;
163 	for (i=0; i&lt;model-&gt;l; ++i) { 		index = model-&gt;SV[i][0].index;
164         for(j=0; index &gt;=0 ; ++j) {
165         	iindices[k] = index - 1;
166             dvalues[k] = model-&gt;SV[i][j].value;
167             index = model-&gt;SV[i][j+1].index;
168             ++k;
169         }
170         iindptr[i+1] = k;
171 	}
172 	return 0;
173 }
174 npy_intp get_nonzero_SV (struct svm_csr_model *model) {
175 	int i, j;
176 	npy_intp count=0;
177 	for (i=0; i&lt;model-&gt;l; ++i) {
178 		j = 0;
179 		while (model-&gt;SV[i][j].index != -1) {
180 			++j;
181 			++count;
182 		}
183 	}
184 	return count;
185 }
186 int csr_copy_predict (npy_intp *data_size, char *data, npy_intp *index_size,
187 		char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
188 		char *dec_values, BlasFunctions *blas_functions) {
189     double *t = (double *) dec_values;
190     struct svm_csr_node **predict_nodes;
191     npy_intp i;
192 <a name="9"></a>    predict_nodes = csr_to_libsvm((double *) data, (int *) index,
193                                   (int *) intptr, intptr_size[0]-1);
194 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (predict_nodes == NULL)
195         return -1;
196     for(i=0; i &lt; intptr_size[0] - 1; ++i) {
197         *t = svm_csr_predict(model, predict_nodes[i], blas_functions);
198         free(predict_nodes[i]);
199         ++t;
200     }
201     free(predict_nodes);
202     return 0;
203 }
204 int csr_copy_predict_values (npy_intp *data_size, char *data, npy_intp *index_size,</b></font>
205                 char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
206                 char *dec_values, int nr_class, BlasFunctions *blas_functions) {
207     struct svm_csr_node **predict_nodes;
208     npy_intp i;
209 <a name="10"></a>    predict_nodes = csr_to_libsvm((double *) data, (int *) index,
210                                   (int *) intptr, intptr_size[0]-1);
211 <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (predict_nodes == NULL)
212         return -1;
213     for(i=0; i &lt; intptr_size[0] - 1; ++i) {
214         svm_csr_predict_values(model, predict_nodes[i],
215                                ((double *) dec_values) + i*nr_class,
216 			       blas_functions);
217         free(predict_nodes[i]);
218     }
219     free(predict_nodes);
220     return 0;
221 }
222 int csr_copy_predict_proba (npy_intp *data_size, char *data, npy_intp *index_size,</b></font>
223 		char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
224 		char *dec_values, BlasFunctions *blas_functions) {
225     struct svm_csr_node **predict_nodes;
226     npy_intp i;
227     int m = model-&gt;nr_class;
228     predict_nodes = csr_to_libsvm((double *) data, (int *) index,
229                                   (int *) intptr, intptr_size[0]-1);
230     if (predict_nodes == NULL)
231         return -1;
232     for(i=0; i &lt; intptr_size[0] - 1; ++i) {
233         svm_csr_predict_probability(
234 		model, predict_nodes[i], ((double *) dec_values) + i*m, blas_functions);
235         free(predict_nodes[i]);
236     }
237     free(predict_nodes);
238     return 0;
239 }
240 npy_intp get_nr(struct svm_csr_model *model)
241 {
242     return (npy_intp) model-&gt;nr_class;
243 }
244 <a name="7"></a>void copy_intercept(char *data, struct svm_csr_model *model, npy_intp *dims)
245 {
246 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    npy_intp i, n = dims[0];
247     double t, *ddata = (double *) data;
248     for (i=0; i&lt;n; ++i) {
249         t = model-&gt;rho[i];
250         *ddata = (t != 0) ? -t : 0;
251         ++ddata;
252     }
253 }
254 <a name="3"></a>
255 void copy_support (char *data, struct svm_csr_model *model)
256 {</b></font>
257 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    memcpy (data, model-&gt;sv_ind, (model-&gt;l) * sizeof(int));
258 }
259 void copy_sv_coef(char *data, struct svm_csr_model *model)
260 {
261     int i, len = model-&gt;nr_class-1;
262     double *temp = (double *) data;
263     for(i=0; i&lt;len; ++i) {
264         memcpy(temp, model-&gt;sv_coef[i], sizeof(double) * model-&gt;l);
265         temp += model-&gt;l;
266     }
267 }
268 void copy_n_iter(char *data, struct svm_csr_model *model)
269 {</b></font>
270     const int n_models = MAX(1, model-&gt;nr_class * (model-&gt;nr_class-1) / 2);
271     memcpy(data, model-&gt;n_iter, n_models * sizeof(int));
272 }
273 npy_intp get_l(struct svm_csr_model *model)
274 {
275     return (npy_intp) model-&gt;l;
276 }
277 <a name="2"></a>void copy_nSV(char *data, struct svm_csr_model *model)
278 {
279     if (model-&gt;label == NULL) return;
280 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    memcpy(data, model-&gt;nSV, model-&gt;nr_class * sizeof(int));
281 }
282 void copy_label(char *data, struct svm_csr_model *model)
283 {
284     if (model-&gt;label == NULL) return;
285     memcpy(data, model-&gt;label, model-&gt;nr_class * sizeof(int));
286 }
287 void copy_probA(char *data, struct svm_csr_model *model, npy_intp * dims)
288 {
289     memcpy(data, model-&gt;probA, dims[0] * sizeof(double));
290 }
291 void copy_probB(char *data, struct svm_csr_model *model, npy_intp * dims)
292 {
293     memcpy(data, model-&gt;probB, dims[0] * sizeof(double));
294 }
295 int free_problem(struct svm_csr_problem *problem)</b></font>
296 {
297     int i;
298     if (problem == NULL) return -1;
299     for (i=0; i&lt;problem-&gt;l; ++i)
300 <a name="8"></a>        free (problem-&gt;x[i]);
301     free (problem-&gt;x);
302     free (problem);
303 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    return 0;
304 }
305 int free_model(struct svm_csr_model *model)
306 {
307     if (model == NULL) return -1;
308     free(model-&gt;SV);
309     free(model-&gt;sv_coef);
310     free(model-&gt;rho);
311     free(model-&gt;label);
312     free(model-&gt;probA);
313     free(model-&gt;probB);
314     free(model-&gt;nSV);
315     free(model);
316     return 0;
317 }
318 int free_param(struct svm_parameter *param)
319 {
320     if (param == NULL) return -1;</b></font>
321     free(param);
322     return 0;
323 }
324 int free_model_SV(struct svm_csr_model *model)
325 {
326     int i;
327     for (i=model-&gt;l-1; i&gt;=0; --i) free(model-&gt;SV[i]);
328 <a name="4"></a>        for (i=0; i &lt; model-&gt;nr_class-1 ; ++i) free(model-&gt;sv_coef[i]);
329 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    return 0;
330 }
331 static void print_null(const char *s) {}
332 static void print_string_stdout(const char *s)
333 {
334 	fputs(s,stdout);
335 	fflush(stdout);
336 }
337 void set_verbosity(int verbosity_flag){
338 	if (verbosity_flag)
339 		svm_set_print_string_function(&amp;print_string_stdout);
340 	else
341 		svm_set_print_string_function(&amp;print_null);
342 }</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
