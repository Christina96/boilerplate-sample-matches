<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for libsvm_helper.c &amp; libsvm_sparse_helper.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for libsvm_helper.c &amp; libsvm_sparse_helper.c
      </h3>
<h1 align="center">
        58.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>libsvm_helper.c (67.46411%)<th>libsvm_sparse_helper.c (52.31911%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(115-141)<td><a href="#" name="0">(109-137)</a><td align="center"><font color="#ff0000">47</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(166-192)<td><a href="#" name="1">(164-190)</a><td align="center"><font color="#c80000">37</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(286-314)<td><a href="#" name="2">(380-409)</a><td align="center"><font color="#970000">28</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(237-256)<td><a href="#" name="3">(342-364)</a><td align="center"><font color="#870000">25</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(405-424)<td><a href="#" name="4">(452-471)</a><td align="center"><font color="#6c0000">20</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(70-86)<td><a href="#" name="5">(58-74)</a><td align="center"><font color="#670000">19</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(65-69)<td><a href="#" name="6">(50-54)</a><td align="center"><font color="#670000">19</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(258-274)<td><a href="#" name="7">(330-341)</a><td align="center"><font color="#610000">18</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(369-403)<td><a href="#" name="8">(417-439)</a><td align="center"><font color="#560000">16</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(323-333)<td><a href="#" name="9">(266-277)</a><td align="center"><font color="#4b0000">14</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(339-353)<td><a href="#" name="10">(286-299)</a><td align="center"><font color="#460000">13</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(159-165)<td><a href="#" name="11">(146-152)</a><td align="center"><font color="#460000">13</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(47-52)<td><a href="#" name="12">(19-26)</a><td align="center"><font color="#460000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>libsvm_helper.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;stdlib.h&gt;
#include &lt;numpy/arrayobject.h&gt;
#include "svm.h"
#include "_svm_cython_blas_helpers.h"


#ifndef MAX
    #define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
#endif


/*
 * Some helper methods for libsvm bindings.
 *
 * We need to access from python some parameters stored in svm_model
 * but libsvm does not expose this structure, so we define it here
 * along some utilities to convert from numpy arrays.
 *
 * License: BSD 3 clause
 *
 * Author: 2010 Fabian Pedregosa &lt;fabian.pedregosa@inria.fr&gt;
 */


/*
 * Convert matrix to sparse representation suitable for libsvm. x is
 * expected to be an array of length nrow*ncol.
 *
 * Typically the matrix will be dense, so we speed up the routine for
 * this case. We create a temporary array temp that collects non-zero
 * elements and after we just memcpy that to the proper array.
 *
 * Special care must be taken with indinces, since libsvm indices start
 * at 1 and not at 0.
 *
 * Strictly speaking, the C standard does not require that structs are
 * contiguous, but in practice its a reasonable assumption.
 *
 */
struct svm_node *dense_to_libsvm (double *x, npy_intp *dims)
{
    struct svm_node *node;
    npy_intp len_row = dims[1];
<a name="12"></a>    double *tx = x;
    int i;

<font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    node = malloc (dims[0] * sizeof(struct svm_node));

    if (node == NULL) return NULL;
    for (i=0; i&lt;dims[0]; ++i) {
        node[i].values = tx;
        node[i].dim = (int) len_row;</b></font>
        node[i].ind = i; /* only used if kernel=precomputed, but not
                            too much overhead */
        tx += len_row;
    }

    return node;
}


<a name="6"></a>/*
 * Fill an svm_parameter struct.
 */
<font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>void set_parameter(struct svm_parameter *param, int svm_type, int kernel_type, int degree,
		double gamma, double coef0, double nu, double cache_size, double C,
<a name="5"></a>		double eps, double p, int shrinking, int probability, int nr_weight,
		char *weight_label, char *weight, int max_iter, int random_seed)
{</b></font>
<font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    param-&gt;svm_type = svm_type;
    param-&gt;kernel_type = kernel_type;
    param-&gt;degree = degree;
    param-&gt;coef0 = coef0;
    param-&gt;nu = nu;
    param-&gt;cache_size = cache_size;
    param-&gt;C = C;
    param-&gt;eps = eps;
    param-&gt;p = p;
    param-&gt;shrinking = shrinking;
    param-&gt;probability = probability;
    param-&gt;nr_weight = nr_weight;
    param-&gt;weight_label = (int *) weight_label;
    param-&gt;weight = (double *) weight;
    param-&gt;gamma = gamma;
    param-&gt;max_iter = max_iter;
    param-&gt;random_seed = random_seed;</b></font>
}

/*
 * Fill an svm_problem struct. problem-&gt;x will be malloc'd.
 */
void set_problem(struct svm_problem *problem, char *X, char *Y, char *sample_weight, npy_intp *dims, int kernel_type)
{
    if (problem == NULL) return;
    problem-&gt;l = (int) dims[0]; /* number of samples */
    problem-&gt;y = (double *) Y;
    problem-&gt;x = dense_to_libsvm((double *) X, dims); /* implicit call to malloc */
    problem-&gt;W = (double *) sample_weight;
}

/*
 * Create and return an instance of svm_model.
 *
 * The copy of model-&gt;sv_coef should be straightforward, but
 * unfortunately to represent a matrix numpy and libsvm use different
 * approaches, so it requires some iteration.
 *
 * Possible issue: on 64 bits, the number of columns that numpy can
 * store is a long, but libsvm enforces this number (model-&gt;l) to be
 * an int, so we might have numpy matrices that do not fit into libsvm's
 * data structure.
<a name="0"></a> *
 */
struct svm_model *set_model(struct svm_parameter *param, int nr_class,
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>                            char *SV, npy_intp *SV_dims,
                            char *support, npy_intp *support_dims,
                            npy_intp *sv_coef_strides,
                            char *sv_coef, char *rho, char *nSV,
                            char *probA, char *probB)
{
    struct svm_model *model;
    double *dsv_coef = (double *) sv_coef;
    int i, m;

    m = nr_class * (nr_class-1)/2;

    if ((model = malloc(sizeof(struct svm_model))) == NULL)
        goto model_error;
    if ((model-&gt;nSV = malloc(nr_class * sizeof(int))) == NULL)
        goto nsv_error;
    if ((model-&gt;label = malloc(nr_class * sizeof(int))) == NULL)
        goto label_error;
    if ((model-&gt;sv_coef = malloc((nr_class-1)*sizeof(double *))) == NULL)
        goto sv_coef_error;
    if ((model-&gt;rho = malloc( m * sizeof(double))) == NULL)
        goto rho_error;

    // This is only allocated in dynamic memory while training.
    model-&gt;n_iter = NULL;

    model-&gt;nr_class = nr_class;</b></font>
    model-&gt;param = *param;
    model-&gt;l = (int) support_dims[0];

    if (param-&gt;kernel_type == PRECOMPUTED) {
        if ((model-&gt;SV = malloc ((model-&gt;l) * sizeof(struct svm_node))) == NULL)
            goto SV_error;
        for (i=0; i&lt;model-&gt;l; ++i) {
            model-&gt;SV[i].ind = ((int *) support)[i];
            model-&gt;SV[i].values = NULL;
        }
    } else {
        model-&gt;SV = dense_to_libsvm((double *) SV, SV_dims);
    }
    /*
<a name="11"></a>     * regression and one-class does not use nSV, label.
     * TODO: does this provoke memory leaks (we just malloc'ed them)?
     */
<font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if (param-&gt;svm_type &lt; 2) {
        memcpy(model-&gt;nSV, nSV,     model-&gt;nr_class * sizeof(int));
        for(i=0; i &lt; model-&gt;nr_class; i++)
            model-&gt;label[i] = i;
<a name="1"></a>    }

    for (i=0; i &lt; model-&gt;nr_class-1; i++) {</b></font>
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        model-&gt;sv_coef[i] = dsv_coef + i*(model-&gt;l);
    }

    for (i=0; i&lt;m; ++i) {
        (model-&gt;rho)[i] = -((double *) rho)[i];
    }

    /*
     * just to avoid segfaults, these features are not wrapped but
     * svm_destroy_model will try to free them.
     */

    if (param-&gt;probability) {
        if ((model-&gt;probA = malloc(m * sizeof(double))) == NULL)
            goto probA_error;
        memcpy(model-&gt;probA, probA, m * sizeof(double));
        if ((model-&gt;probB = malloc(m * sizeof(double))) == NULL)
            goto probB_error;
        memcpy(model-&gt;probB, probB, m * sizeof(double));
    } else {
        model-&gt;probA = NULL;
        model-&gt;probB = NULL;
    }

    /* We'll free SV ourselves */
    model-&gt;free_sv = 0;
    return model;</b></font>

probB_error:
    free(model-&gt;probA);
probA_error:
    free(model-&gt;SV);
SV_error:
    free(model-&gt;rho);
rho_error:
    free(model-&gt;sv_coef);
sv_coef_error:
    free(model-&gt;label);
label_error:
    free(model-&gt;nSV);
nsv_error:
    free(model);
model_error:
    return NULL;
}



/*
 * Get the number of support vectors in a model.
 */
npy_intp get_l(struct svm_model *model)
{
    return (npy_intp) model-&gt;l;
}

/*
 * Get the number of classes in a model, = 2 in regression/one class
 * svm.
 */
npy_intp get_nr(struct svm_model *model)
{
    return (npy_intp) model-&gt;nr_class;
}

/*
 * Get the number of iterations run in optimization
 */
<a name="3"></a>void copy_n_iter(char *data, struct svm_model *model)
{
    const int n_models = MAX(1, model-&gt;nr_class * (model-&gt;nr_class-1) / 2);
<font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    memcpy(data, model-&gt;n_iter, n_models * sizeof(int));
}

/*
 * Some helpers to convert from libsvm sparse data structures
 * model-&gt;sv_coef is a double **, whereas data is just a double *,
 * so we have to do some stupid copying.
 */
void copy_sv_coef(char *data, struct svm_model *model)
{
    int i, len = model-&gt;nr_class-1;
    double *temp = (double *) data;
    for(i=0; i&lt;len; ++i) {
        memcpy(temp, model-&gt;sv_coef[i], sizeof(double) * model-&gt;l);
        temp += model-&gt;l;
    }
}

<a name="7"></a>void copy_intercept(char *data, struct svm_model *model, npy_intp *dims)
{</b></font>
    /* intercept = -rho */
<font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    npy_intp i, n = dims[0];
    double t, *ddata = (double *) data;
    for (i=0; i&lt;n; ++i) {
        t = model-&gt;rho[i];
        /* we do this to avoid ugly -0.0 */
        *ddata = (t != 0) ? -t : 0;
        ++ddata;
    }
}

/*
 * This is a bit more complex since SV are stored as sparse
 * structures, so we have to do the conversion on the fly and also
 * iterate fast over data.
 */
void copy_SV(char *data, struct svm_model *model, npy_intp *dims)
{</b></font>
    int i, n = model-&gt;l;
    double *tdata = (double *) data;
    int dim = model-&gt;SV[0].dim;
    for (i=0; i&lt;n; ++i) {
        memcpy (tdata, model-&gt;SV[i].values, dim * sizeof(double));
        tdata += dim;
    }
}
<a name="2"></a>
void copy_support (char *data, struct svm_model *model)
{
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    memcpy (data, model-&gt;sv_ind, (model-&gt;l) * sizeof(int));
}

/*
 * copy svm_model.nSV, an array with the number of SV for each class
 * will be NULL in the case of SVR, OneClass
 */
void copy_nSV(char *data, struct svm_model *model)
{
    if (model-&gt;label == NULL) return;
    memcpy(data, model-&gt;nSV, model-&gt;nr_class * sizeof(int));
}

void copy_probA(char *data, struct svm_model *model, npy_intp * dims)
{
    memcpy(data, model-&gt;probA, dims[0] * sizeof(double));
}

void copy_probB(char *data, struct svm_model *model, npy_intp * dims)
{
    memcpy(data, model-&gt;probB, dims[0] * sizeof(double));
}

/*
 * Predict using model.
 *
 *  It will return -1 if we run out of memory.
 */
int copy_predict(char *predict, struct svm_model *model, npy_intp *predict_dims,</b></font>
                 char *dec_values, BlasFunctions *blas_functions)
{
    double *t = (double *) dec_values;
    struct svm_node *predict_nodes;
    npy_intp i;
<a name="9"></a>
    predict_nodes = dense_to_libsvm((double *) predict, predict_dims);

<font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if (predict_nodes == NULL)
        return -1;
    for(i=0; i&lt;predict_dims[0]; ++i) {
        *t = svm_predict(model, &amp;predict_nodes[i], blas_functions);
        ++t;
    }
    free(predict_nodes);
    return 0;
}

int copy_predict_values(char *predict, struct svm_model *model,</b></font>
                        npy_intp *predict_dims, char *dec_values, int nr_class, BlasFunctions *blas_functions)
{
<a name="10"></a>    npy_intp i;
    struct svm_node *predict_nodes;
    predict_nodes = dense_to_libsvm((double *) predict, predict_dims);
<font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    if (predict_nodes == NULL)
        return -1;
    for(i=0; i&lt;predict_dims[0]; ++i) {
        svm_predict_values(model, &amp;predict_nodes[i],
                                ((double *) dec_values) + i*nr_class,
				blas_functions);
    }

    free(predict_nodes);
    return 0;
}



int copy_predict_proba(char *predict, struct svm_model *model, npy_intp *predict_dims,</b></font>
                 char *dec_values, BlasFunctions *blas_functions)
{
    npy_intp i, n, m;
    struct svm_node *predict_nodes;
    n = predict_dims[0];
    m = (npy_intp) model-&gt;nr_class;
    predict_nodes = dense_to_libsvm((double *) predict, predict_dims);
    if (predict_nodes == NULL)
        return -1;
    for(i=0; i&lt;n; ++i) {
        svm_predict_probability(model, &amp;predict_nodes[i],
                                ((double *) dec_values) + i*m,
<a name="8"></a>				blas_functions);
    }
    free(predict_nodes);
<font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    return 0;
}


/*
 * Some free routines. Some of them are nontrivial since a lot of
 * sharing happens across objects (they *must* be called in the
 * correct order)
 */

int free_model(struct svm_model *model)
{
    /* like svm_free_and_destroy_model, but does not free sv_coef[i] */
    if (model == NULL) return -1;
    free(model-&gt;SV);

    /* We don't free sv_ind and n_iter, since we did not create them in
       set_model */
    /* free(model-&gt;sv_ind);
     * free(model-&gt;n_iter);
     */
    free(model-&gt;sv_coef);
    free(model-&gt;rho);
    free(model-&gt;label);
    free(model-&gt;probA);
    free(model-&gt;probB);
    free(model-&gt;nSV);
    free(model);

    return 0;
}

int free_param(struct svm_parameter *param)
<a name="4"></a>{
    if (param == NULL) return -1;</b></font>
    free(param);
<font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    return 0;
}


/* borrowed from original libsvm code */
static void print_null(const char *s) {}

static void print_string_stdout(const char *s)
{
	fputs(s,stdout);
	fflush(stdout);
}

/* provide convenience wrapper */
void set_verbosity(int verbosity_flag){
	if (verbosity_flag)
		svm_set_print_string_function(&amp;print_string_stdout);
	else
		svm_set_print_string_function(&amp;print_null);
}</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>libsvm_sparse_helper.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include &lt;stdlib.h&gt;
#include &lt;numpy/arrayobject.h&gt;
#include "svm.h"
#include "_svm_cython_blas_helpers.h"


#ifndef MAX
    #define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
#endif


/*
 * Convert scipy.sparse.csr to libsvm's sparse data structure
 */
struct svm_csr_node **csr_to_libsvm (double *values, int* indices, int* indptr, npy_int n_samples)
<a name="12"></a>{
    struct svm_csr_node **sparse, *temp;
    int i, j=0, k=0, n;
<font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    sparse = malloc (n_samples * sizeof(struct svm_csr_node *));

    if (sparse == NULL)
        return NULL;

    for (i=0; i&lt;n_samples; ++i) {
        n = indptr[i+1] - indptr[i]; /* count elements in row i */
        temp = malloc ((n+1) * sizeof(struct svm_csr_node));</b></font>

        if (temp == NULL) {
            for (j=0; j&lt;i; j++)
                free(sparse[j]);
            free(sparse);
            return NULL;
        }

        for (j=0; j&lt;n; ++j) {
            temp[j].value = values[k];
            temp[j].index = indices[k] + 1; /* libsvm uses 1-based indexing */
            ++k;
        }
        /* set sentinel */
        temp[n].index = -1;
        sparse[i] = temp;
    }

    return sparse;
}
<a name="6"></a>


<font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>struct svm_parameter * set_parameter(int svm_type, int kernel_type, int degree,
		double gamma, double coef0, double nu, double cache_size, double C,
		double eps, double p, int shrinking, int probability, int nr_weight,
		char *weight_label, char *weight, int max_iter, int random_seed)
{</b></font>
<a name="5"></a>    struct svm_parameter *param;
    param = malloc(sizeof(struct svm_parameter));
    if (param == NULL) return NULL;
<font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    param-&gt;svm_type = svm_type;
    param-&gt;kernel_type = kernel_type;
    param-&gt;degree = degree;
    param-&gt;coef0 = coef0;
    param-&gt;nu = nu;
    param-&gt;cache_size = cache_size;
    param-&gt;C = C;
    param-&gt;eps = eps;
    param-&gt;p = p;
    param-&gt;shrinking = shrinking;
    param-&gt;probability = probability;
    param-&gt;nr_weight = nr_weight;
    param-&gt;weight_label = (int *) weight_label;
    param-&gt;weight = (double *) weight;
    param-&gt;gamma = gamma;
    param-&gt;max_iter = max_iter;
    param-&gt;random_seed = random_seed;</b></font>
    return param;
}


/*
 * Create and return a svm_csr_problem struct from a scipy.sparse.csr matrix. It is
 * up to the user to free resulting structure.
 *
 * TODO: precomputed kernel.
 */
struct svm_csr_problem * csr_set_problem (char *values, npy_intp *n_indices,
		char *indices, npy_intp *n_indptr, char *indptr, char *Y,
                char *sample_weight, int kernel_type) {

    struct svm_csr_problem *problem;
    problem = malloc (sizeof (struct svm_csr_problem));
    if (problem == NULL) return NULL;
    problem-&gt;l = (int) n_indptr[0] - 1;
    problem-&gt;y = (double *) Y;
    problem-&gt;x = csr_to_libsvm((double *) values, (int *) indices,
                               (int *) indptr, problem-&gt;l);
    /* should be removed once we implement weighted samples */
    problem-&gt;W = (double *) sample_weight;

    if (problem-&gt;x == NULL) {
        free(problem);
        return NULL;
    }
    return problem;
}

<a name="0"></a>
struct svm_csr_model *csr_set_model(struct svm_parameter *param, int nr_class,
                            char *SV_data, npy_intp *SV_indices_dims,
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>                            char *SV_indices, npy_intp *SV_indptr_dims,
                            char *SV_intptr,
                            char *sv_coef, char *rho, char *nSV,
                            char *probA, char *probB)
{
    struct svm_csr_model *model;
    double *dsv_coef = (double *) sv_coef;
    int i, m;

    m = nr_class * (nr_class-1)/2;

    if ((model = malloc(sizeof(struct svm_csr_model))) == NULL)
        goto model_error;
    if ((model-&gt;nSV = malloc(nr_class * sizeof(int))) == NULL)
        goto nsv_error;
    if ((model-&gt;label = malloc(nr_class * sizeof(int))) == NULL)
        goto label_error;
    if ((model-&gt;sv_coef = malloc((nr_class-1)*sizeof(double *))) == NULL)
        goto sv_coef_error;
    if ((model-&gt;rho = malloc( m * sizeof(double))) == NULL)
        goto rho_error;

    // This is only allocated in dynamic memory while training.
    model-&gt;n_iter = NULL;

    /* in the case of precomputed kernels we do not use
       dense_to_precomputed because we don't want the leading 0. As
       indices start at 1 (not at 0) this will work */
    model-&gt;l = (int) SV_indptr_dims[0] - 1;</b></font>
    model-&gt;SV = csr_to_libsvm((double *) SV_data, (int *) SV_indices,
                              (int *) SV_intptr, model-&gt;l);
    model-&gt;nr_class = nr_class;
    model-&gt;param = *param;

<a name="11"></a>    /*
     * regression and one-class does not use nSV, label.
     */
<font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (param-&gt;svm_type &lt; 2) {
        memcpy(model-&gt;nSV,   nSV,   model-&gt;nr_class * sizeof(int));
        for(i=0; i &lt; model-&gt;nr_class; i++)
            model-&gt;label[i] = i;
    }

    for (i=0; i &lt; model-&gt;nr_class-1; i++) {</b></font>
        /*
         * We cannot squash all this mallocs in a single call since
         * svm_destroy_model will free each element of the array.
         */
        if ((model-&gt;sv_coef[i] = malloc((model-&gt;l) * sizeof(double))) == NULL) {
            int j;
            for (j=0; j&lt;i; j++)
                free(model-&gt;sv_coef[j]);
<a name="1"></a>            goto sv_coef_i_error;
        }
        memcpy(model-&gt;sv_coef[i], dsv_coef, (model-&gt;l) * sizeof(double));
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        dsv_coef += model-&gt;l;
    }

    for (i=0; i&lt;m; ++i) {
        (model-&gt;rho)[i] = -((double *) rho)[i];
    }

    /*
     * just to avoid segfaults, these features are not wrapped but
     * svm_destroy_model will try to free them.
     */

    if (param-&gt;probability) {
        if ((model-&gt;probA = malloc(m * sizeof(double))) == NULL)
            goto probA_error;
        memcpy(model-&gt;probA, probA, m * sizeof(double));
        if ((model-&gt;probB = malloc(m * sizeof(double))) == NULL)
            goto probB_error;
        memcpy(model-&gt;probB, probB, m * sizeof(double));
    } else {
        model-&gt;probA = NULL;
        model-&gt;probB = NULL;
    }

    /* We'll free SV ourselves */
    model-&gt;free_sv = 0;
    return model;</b></font>

probB_error:
    free(model-&gt;probA);
probA_error:
    for (i=0; i &lt; model-&gt;nr_class-1; i++)
        free(model-&gt;sv_coef[i]);
sv_coef_i_error:
    free(model-&gt;rho);
rho_error:
    free(model-&gt;sv_coef);
sv_coef_error:
    free(model-&gt;label);
label_error:
    free(model-&gt;nSV);
nsv_error:
    free(model);
model_error:
    return NULL;
}


/*
 * Copy support vectors into a scipy.sparse.csr matrix
 */
int csr_copy_SV (char *data, npy_intp *n_indices,
		char *indices, npy_intp *n_indptr, char *indptr,
		struct svm_csr_model *model, int n_features)
{
	int i, j, k=0, index;
	double *dvalues = (double *) data;
	int *iindices = (int *) indices;
	int *iindptr  = (int *) indptr;
	iindptr[0] = 0;
	for (i=0; i&lt;model-&gt;l; ++i) { /* iterate over support vectors */
		index = model-&gt;SV[i][0].index;
        for(j=0; index &gt;=0 ; ++j) {
        	iindices[k] = index - 1;
            dvalues[k] = model-&gt;SV[i][j].value;
            index = model-&gt;SV[i][j+1].index;
            ++k;
        }
        iindptr[i+1] = k;
	}

	return 0;
}

/* get number of nonzero coefficients in support vectors */
npy_intp get_nonzero_SV (struct svm_csr_model *model) {
	int i, j;
	npy_intp count=0;
	for (i=0; i&lt;model-&gt;l; ++i) {
		j = 0;
		while (model-&gt;SV[i][j].index != -1) {
			++j;
			++count;
		}
	}
	return count;
}


/*
 * Predict using a model, where data is expected to be encoded into a csr matrix.
 */
int csr_copy_predict (npy_intp *data_size, char *data, npy_intp *index_size,
		char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
		char *dec_values, BlasFunctions *blas_functions) {
    double *t = (double *) dec_values;
    struct svm_csr_node **predict_nodes;
    npy_intp i;

<a name="9"></a>    predict_nodes = csr_to_libsvm((double *) data, (int *) index,
                                  (int *) intptr, intptr_size[0]-1);

<font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (predict_nodes == NULL)
        return -1;
    for(i=0; i &lt; intptr_size[0] - 1; ++i) {
        *t = svm_csr_predict(model, predict_nodes[i], blas_functions);
        free(predict_nodes[i]);
        ++t;
    }
    free(predict_nodes);
    return 0;
}

int csr_copy_predict_values (npy_intp *data_size, char *data, npy_intp *index_size,</b></font>
                char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
                char *dec_values, int nr_class, BlasFunctions *blas_functions) {
    struct svm_csr_node **predict_nodes;
    npy_intp i;

<a name="10"></a>    predict_nodes = csr_to_libsvm((double *) data, (int *) index,
                                  (int *) intptr, intptr_size[0]-1);

<font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    if (predict_nodes == NULL)
        return -1;
    for(i=0; i &lt; intptr_size[0] - 1; ++i) {
        svm_csr_predict_values(model, predict_nodes[i],
                               ((double *) dec_values) + i*nr_class,
			       blas_functions);
        free(predict_nodes[i]);
    }
    free(predict_nodes);

    return 0;
}

int csr_copy_predict_proba (npy_intp *data_size, char *data, npy_intp *index_size,</b></font>
		char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
		char *dec_values, BlasFunctions *blas_functions) {

    struct svm_csr_node **predict_nodes;
    npy_intp i;
    int m = model-&gt;nr_class;

    predict_nodes = csr_to_libsvm((double *) data, (int *) index,
                                  (int *) intptr, intptr_size[0]-1);

    if (predict_nodes == NULL)
        return -1;
    for(i=0; i &lt; intptr_size[0] - 1; ++i) {
        svm_csr_predict_probability(
		model, predict_nodes[i], ((double *) dec_values) + i*m, blas_functions);
        free(predict_nodes[i]);
    }
    free(predict_nodes);
    return 0;
}


npy_intp get_nr(struct svm_csr_model *model)
{
    return (npy_intp) model-&gt;nr_class;
}

<a name="7"></a>void copy_intercept(char *data, struct svm_csr_model *model, npy_intp *dims)
{
    /* intercept = -rho */
<font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    npy_intp i, n = dims[0];
    double t, *ddata = (double *) data;
    for (i=0; i&lt;n; ++i) {
        t = model-&gt;rho[i];
        /* we do this to avoid ugly -0.0 */
        *ddata = (t != 0) ? -t : 0;
        ++ddata;
    }
}
<a name="3"></a>
void copy_support (char *data, struct svm_csr_model *model)
{</b></font>
<font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    memcpy (data, model-&gt;sv_ind, (model-&gt;l) * sizeof(int));
}

/*
 * Some helpers to convert from libsvm sparse data structures
 * model-&gt;sv_coef is a double **, whereas data is just a double *,
 * so we have to do some stupid copying.
 */
void copy_sv_coef(char *data, struct svm_csr_model *model)
{
    int i, len = model-&gt;nr_class-1;
    double *temp = (double *) data;
    for(i=0; i&lt;len; ++i) {
        memcpy(temp, model-&gt;sv_coef[i], sizeof(double) * model-&gt;l);
        temp += model-&gt;l;
    }
}

/*
 * Get the number of iterations run in optimization
 */
void copy_n_iter(char *data, struct svm_csr_model *model)
{</b></font>
    const int n_models = MAX(1, model-&gt;nr_class * (model-&gt;nr_class-1) / 2);
    memcpy(data, model-&gt;n_iter, n_models * sizeof(int));
}

/*
 * Get the number of support vectors in a model.
 */
npy_intp get_l(struct svm_csr_model *model)
{
    return (npy_intp) model-&gt;l;
}

<a name="2"></a>void copy_nSV(char *data, struct svm_csr_model *model)
{
    if (model-&gt;label == NULL) return;
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    memcpy(data, model-&gt;nSV, model-&gt;nr_class * sizeof(int));
}

/*
 * same as above with model-&gt;label
 * TODO: merge in the cython layer
 */
void copy_label(char *data, struct svm_csr_model *model)
{
    if (model-&gt;label == NULL) return;
    memcpy(data, model-&gt;label, model-&gt;nr_class * sizeof(int));
}

void copy_probA(char *data, struct svm_csr_model *model, npy_intp * dims)
{
    memcpy(data, model-&gt;probA, dims[0] * sizeof(double));
}

void copy_probB(char *data, struct svm_csr_model *model, npy_intp * dims)
{
    memcpy(data, model-&gt;probB, dims[0] * sizeof(double));
}


/*
 * Some free routines. Some of them are nontrivial since a lot of
 * sharing happens across objects (they *must* be called in the
 * correct order)
 */
int free_problem(struct svm_csr_problem *problem)</b></font>
{
    int i;
    if (problem == NULL) return -1;
    for (i=0; i&lt;problem-&gt;l; ++i)
<a name="8"></a>        free (problem-&gt;x[i]);
    free (problem-&gt;x);
    free (problem);
<font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    return 0;
}

int free_model(struct svm_csr_model *model)
{
    /* like svm_free_and_destroy_model, but does not free sv_coef[i] */
    /* We don't free n_iter, since we did not create them in set_model. */
    if (model == NULL) return -1;
    free(model-&gt;SV);
    free(model-&gt;sv_coef);
    free(model-&gt;rho);
    free(model-&gt;label);
    free(model-&gt;probA);
    free(model-&gt;probB);
    free(model-&gt;nSV);
    free(model);

    return 0;
}

int free_param(struct svm_parameter *param)
{
    if (param == NULL) return -1;</b></font>
    free(param);
    return 0;
}


int free_model_SV(struct svm_csr_model *model)
{
    int i;
    for (i=model-&gt;l-1; i&gt;=0; --i) free(model-&gt;SV[i]);
<a name="4"></a>    /* svn_destroy_model frees model-&gt;SV */
    for (i=0; i &lt; model-&gt;nr_class-1 ; ++i) free(model-&gt;sv_coef[i]);
    /* svn_destroy_model frees model-&gt;sv_coef */
<font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    return 0;
}


/* borrowed from original libsvm code */
static void print_null(const char *s) {}

static void print_string_stdout(const char *s)
{
	fputs(s,stdout);
	fflush(stdout);
}

/* provide convenience wrapper */
void set_verbosity(int verbosity_flag){
	if (verbosity_flag)
		svm_set_print_string_function(&amp;print_string_stdout);
	else
		svm_set_print_string_function(&amp;print_null);
}</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
