<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for libsvm_helper.c & libsvm_sparse_helper.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for libsvm_helper.c & libsvm_sparse_helper.c
      </h3>
      <h1 align="center">
        58.9%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>libsvm_helper.c (67.46411%)<TH>libsvm_sparse_helper.c (52.31911%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#0',2,'match0-1.html#0',3)" NAME="0">(115-141)<TD><A HREF="javascript:ZweiFrames('match0-0.html#0',2,'match0-1.html#0',3)" NAME="0">(109-137)</A><TD ALIGN=center><FONT COLOR="#ff0000">47</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#1',2,'match0-1.html#1',3)" NAME="1">(166-192)<TD><A HREF="javascript:ZweiFrames('match0-0.html#1',2,'match0-1.html#1',3)" NAME="1">(164-190)</A><TD ALIGN=center><FONT COLOR="#c80000">37</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#2',2,'match0-1.html#2',3)" NAME="2">(286-314)<TD><A HREF="javascript:ZweiFrames('match0-0.html#2',2,'match0-1.html#2',3)" NAME="2">(380-409)</A><TD ALIGN=center><FONT COLOR="#970000">28</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#3',2,'match0-1.html#3',3)" NAME="3">(237-256)<TD><A HREF="javascript:ZweiFrames('match0-0.html#3',2,'match0-1.html#3',3)" NAME="3">(342-364)</A><TD ALIGN=center><FONT COLOR="#870000">25</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#4',2,'match0-1.html#4',3)" NAME="4">(405-424)<TD><A HREF="javascript:ZweiFrames('match0-0.html#4',2,'match0-1.html#4',3)" NAME="4">(452-471)</A><TD ALIGN=center><FONT COLOR="#6c0000">20</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#5',2,'match0-1.html#5',3)" NAME="5">(70-86)<TD><A HREF="javascript:ZweiFrames('match0-0.html#5',2,'match0-1.html#5',3)" NAME="5">(58-74)</A><TD ALIGN=center><FONT COLOR="#670000">19</FONT>
<TR><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#6',2,'match0-1.html#6',3)" NAME="6">(65-69)<TD><A HREF="javascript:ZweiFrames('match0-0.html#6',2,'match0-1.html#6',3)" NAME="6">(50-54)</A><TD ALIGN=center><FONT COLOR="#670000">19</FONT>
<TR><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#7',2,'match0-1.html#7',3)" NAME="7">(258-274)<TD><A HREF="javascript:ZweiFrames('match0-0.html#7',2,'match0-1.html#7',3)" NAME="7">(330-341)</A><TD ALIGN=center><FONT COLOR="#610000">18</FONT>
<TR><TD BGCOLOR="#c58917"><FONT COLOR="#c58917">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#8',2,'match0-1.html#8',3)" NAME="8">(369-403)<TD><A HREF="javascript:ZweiFrames('match0-0.html#8',2,'match0-1.html#8',3)" NAME="8">(417-439)</A><TD ALIGN=center><FONT COLOR="#560000">16</FONT>
<TR><TD BGCOLOR="#83a33a"><FONT COLOR="#83a33a">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#9',2,'match0-1.html#9',3)" NAME="9">(323-333)<TD><A HREF="javascript:ZweiFrames('match0-0.html#9',2,'match0-1.html#9',3)" NAME="9">(266-277)</A><TD ALIGN=center><FONT COLOR="#4b0000">14</FONT>
<TR><TD BGCOLOR="#ad5910"><FONT COLOR="#ad5910">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#10',2,'match0-1.html#10',3)" NAME="10">(339-353)<TD><A HREF="javascript:ZweiFrames('match0-0.html#10',2,'match0-1.html#10',3)" NAME="10">(286-299)</A><TD ALIGN=center><FONT COLOR="#460000">13</FONT>
<TR><TD BGCOLOR="#b041ff"><FONT COLOR="#b041ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#11',2,'match0-1.html#11',3)" NAME="11">(159-165)<TD><A HREF="javascript:ZweiFrames('match0-0.html#11',2,'match0-1.html#11',3)" NAME="11">(146-152)</A><TD ALIGN=center><FONT COLOR="#460000">13</FONT>
<TR><TD BGCOLOR="#571b7e"><FONT COLOR="#571b7e">-</FONT><TD><A HREF="javascript:ZweiFrames('match0-0.html#12',2,'match0-1.html#12',3)" NAME="12">(47-52)<TD><A HREF="javascript:ZweiFrames('match0-0.html#12',2,'match0-1.html#12',3)" NAME="12">(19-26)</A><TD ALIGN=center><FONT COLOR="#460000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>libsvm_helper.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;stdlib.h&gt;
#include &lt;numpy/arrayobject.h&gt;
#include &quot;svm.h&quot;
#include &quot;_svm_cython_blas_helpers.h&quot;


#ifndef MAX
    #define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
#endif


/*
 * Some helper methods for libsvm bindings.
 *
 * We need to access from python some parameters stored in svm_model
 * but libsvm does not expose this structure, so we define it here
 * along some utilities to convert from numpy arrays.
 *
 * License: BSD 3 clause
 *
 * Author: 2010 Fabian Pedregosa &lt;fabian.pedregosa@inria.fr&gt;
 */


/*
 * Convert matrix to sparse representation suitable for libsvm. x is
 * expected to be an array of length nrow*ncol.
 *
 * Typically the matrix will be dense, so we speed up the routine for
 * this case. We create a temporary array temp that collects non-zero
 * elements and after we just memcpy that to the proper array.
 *
 * Special care must be taken with indinces, since libsvm indices start
 * at 1 and not at 0.
 *
 * Strictly speaking, the C standard does not require that structs are
 * contiguous, but in practice its a reasonable assumption.
 *
 */
struct svm_node *dense_to_libsvm (double *x, npy_intp *dims)
{
    struct svm_node *node;
    npy_intp len_row = dims[1];
<A NAME="12"></A>    double *tx = x;
    int i;

<FONT color="#571b7e"><A HREF="javascript:ZweiFrames('match0-1.html#12',3,'match0-top.html#12',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    node = malloc (dims[0] * sizeof(struct svm_node));

    if (node == NULL) return NULL;
    for (i=0; i&lt;dims[0]; ++i) {
        node[i].values = tx;
        node[i].dim = (int) len_row;</B></FONT>
        node[i].ind = i; /* only used if kernel=precomputed, but not
                            too much overhead */
        tx += len_row;
    }

    return node;
}


<A NAME="6"></A>/*
 * Fill an svm_parameter struct.
 */
<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match0-1.html#6',3,'match0-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>void set_parameter(struct svm_parameter *param, int svm_type, int kernel_type, int degree,
		double gamma, double coef0, double nu, double cache_size, double C,
<A NAME="5"></A>		double eps, double p, int shrinking, int probability, int nr_weight,
		char *weight_label, char *weight, int max_iter, int random_seed)
{</B></FONT>
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match0-1.html#5',3,'match0-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    param-&gt;svm_type = svm_type;
    param-&gt;kernel_type = kernel_type;
    param-&gt;degree = degree;
    param-&gt;coef0 = coef0;
    param-&gt;nu = nu;
    param-&gt;cache_size = cache_size;
    param-&gt;C = C;
    param-&gt;eps = eps;
    param-&gt;p = p;
    param-&gt;shrinking = shrinking;
    param-&gt;probability = probability;
    param-&gt;nr_weight = nr_weight;
    param-&gt;weight_label = (int *) weight_label;
    param-&gt;weight = (double *) weight;
    param-&gt;gamma = gamma;
    param-&gt;max_iter = max_iter;
    param-&gt;random_seed = random_seed;</B></FONT>
}

/*
 * Fill an svm_problem struct. problem-&gt;x will be malloc'd.
 */
void set_problem(struct svm_problem *problem, char *X, char *Y, char *sample_weight, npy_intp *dims, int kernel_type)
{
    if (problem == NULL) return;
    problem-&gt;l = (int) dims[0]; /* number of samples */
    problem-&gt;y = (double *) Y;
    problem-&gt;x = dense_to_libsvm((double *) X, dims); /* implicit call to malloc */
    problem-&gt;W = (double *) sample_weight;
}

/*
 * Create and return an instance of svm_model.
 *
 * The copy of model-&gt;sv_coef should be straightforward, but
 * unfortunately to represent a matrix numpy and libsvm use different
 * approaches, so it requires some iteration.
 *
 * Possible issue: on 64 bits, the number of columns that numpy can
 * store is a long, but libsvm enforces this number (model-&gt;l) to be
 * an int, so we might have numpy matrices that do not fit into libsvm's
 * data structure.
<A NAME="0"></A> *
 */
struct svm_model *set_model(struct svm_parameter *param, int nr_class,
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match0-1.html#0',3,'match0-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>                            char *SV, npy_intp *SV_dims,
                            char *support, npy_intp *support_dims,
                            npy_intp *sv_coef_strides,
                            char *sv_coef, char *rho, char *nSV,
                            char *probA, char *probB)
{
    struct svm_model *model;
    double *dsv_coef = (double *) sv_coef;
    int i, m;

    m = nr_class * (nr_class-1)/2;

    if ((model = malloc(sizeof(struct svm_model))) == NULL)
        goto model_error;
    if ((model-&gt;nSV = malloc(nr_class * sizeof(int))) == NULL)
        goto nsv_error;
    if ((model-&gt;label = malloc(nr_class * sizeof(int))) == NULL)
        goto label_error;
    if ((model-&gt;sv_coef = malloc((nr_class-1)*sizeof(double *))) == NULL)
        goto sv_coef_error;
    if ((model-&gt;rho = malloc( m * sizeof(double))) == NULL)
        goto rho_error;

    // This is only allocated in dynamic memory while training.
    model-&gt;n_iter = NULL;

    model-&gt;nr_class = nr_class;</B></FONT>
    model-&gt;param = *param;
    model-&gt;l = (int) support_dims[0];

    if (param-&gt;kernel_type == PRECOMPUTED) {
        if ((model-&gt;SV = malloc ((model-&gt;l) * sizeof(struct svm_node))) == NULL)
            goto SV_error;
        for (i=0; i&lt;model-&gt;l; ++i) {
            model-&gt;SV[i].ind = ((int *) support)[i];
            model-&gt;SV[i].values = NULL;
        }
    } else {
        model-&gt;SV = dense_to_libsvm((double *) SV, SV_dims);
    }
    /*
<A NAME="11"></A>     * regression and one-class does not use nSV, label.
     * TODO: does this provoke memory leaks (we just malloc'ed them)?
     */
<FONT color="#b041ff"><A HREF="javascript:ZweiFrames('match0-1.html#11',3,'match0-top.html#11',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    if (param-&gt;svm_type &lt; 2) {
        memcpy(model-&gt;nSV, nSV,     model-&gt;nr_class * sizeof(int));
        for(i=0; i &lt; model-&gt;nr_class; i++)
            model-&gt;label[i] = i;
<A NAME="1"></A>    }

    for (i=0; i &lt; model-&gt;nr_class-1; i++) {</B></FONT>
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match0-1.html#1',3,'match0-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        model-&gt;sv_coef[i] = dsv_coef + i*(model-&gt;l);
    }

    for (i=0; i&lt;m; ++i) {
        (model-&gt;rho)[i] = -((double *) rho)[i];
    }

    /*
     * just to avoid segfaults, these features are not wrapped but
     * svm_destroy_model will try to free them.
     */

    if (param-&gt;probability) {
        if ((model-&gt;probA = malloc(m * sizeof(double))) == NULL)
            goto probA_error;
        memcpy(model-&gt;probA, probA, m * sizeof(double));
        if ((model-&gt;probB = malloc(m * sizeof(double))) == NULL)
            goto probB_error;
        memcpy(model-&gt;probB, probB, m * sizeof(double));
    } else {
        model-&gt;probA = NULL;
        model-&gt;probB = NULL;
    }

    /* We'll free SV ourselves */
    model-&gt;free_sv = 0;
    return model;</B></FONT>

probB_error:
    free(model-&gt;probA);
probA_error:
    free(model-&gt;SV);
SV_error:
    free(model-&gt;rho);
rho_error:
    free(model-&gt;sv_coef);
sv_coef_error:
    free(model-&gt;label);
label_error:
    free(model-&gt;nSV);
nsv_error:
    free(model);
model_error:
    return NULL;
}



/*
 * Get the number of support vectors in a model.
 */
npy_intp get_l(struct svm_model *model)
{
    return (npy_intp) model-&gt;l;
}

/*
 * Get the number of classes in a model, = 2 in regression/one class
 * svm.
 */
npy_intp get_nr(struct svm_model *model)
{
    return (npy_intp) model-&gt;nr_class;
}

/*
 * Get the number of iterations run in optimization
 */
<A NAME="3"></A>void copy_n_iter(char *data, struct svm_model *model)
{
    const int n_models = MAX(1, model-&gt;nr_class * (model-&gt;nr_class-1) / 2);
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match0-1.html#3',3,'match0-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    memcpy(data, model-&gt;n_iter, n_models * sizeof(int));
}

/*
 * Some helpers to convert from libsvm sparse data structures
 * model-&gt;sv_coef is a double **, whereas data is just a double *,
 * so we have to do some stupid copying.
 */
void copy_sv_coef(char *data, struct svm_model *model)
{
    int i, len = model-&gt;nr_class-1;
    double *temp = (double *) data;
    for(i=0; i&lt;len; ++i) {
        memcpy(temp, model-&gt;sv_coef[i], sizeof(double) * model-&gt;l);
        temp += model-&gt;l;
    }
}

<A NAME="7"></A>void copy_intercept(char *data, struct svm_model *model, npy_intp *dims)
{</B></FONT>
    /* intercept = -rho */
<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match0-1.html#7',3,'match0-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    npy_intp i, n = dims[0];
    double t, *ddata = (double *) data;
    for (i=0; i&lt;n; ++i) {
        t = model-&gt;rho[i];
        /* we do this to avoid ugly -0.0 */
        *ddata = (t != 0) ? -t : 0;
        ++ddata;
    }
}

/*
 * This is a bit more complex since SV are stored as sparse
 * structures, so we have to do the conversion on the fly and also
 * iterate fast over data.
 */
void copy_SV(char *data, struct svm_model *model, npy_intp *dims)
{</B></FONT>
    int i, n = model-&gt;l;
    double *tdata = (double *) data;
    int dim = model-&gt;SV[0].dim;
    for (i=0; i&lt;n; ++i) {
        memcpy (tdata, model-&gt;SV[i].values, dim * sizeof(double));
        tdata += dim;
    }
}
<A NAME="2"></A>
void copy_support (char *data, struct svm_model *model)
{
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match0-1.html#2',3,'match0-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    memcpy (data, model-&gt;sv_ind, (model-&gt;l) * sizeof(int));
}

/*
 * copy svm_model.nSV, an array with the number of SV for each class
 * will be NULL in the case of SVR, OneClass
 */
void copy_nSV(char *data, struct svm_model *model)
{
    if (model-&gt;label == NULL) return;
    memcpy(data, model-&gt;nSV, model-&gt;nr_class * sizeof(int));
}

void copy_probA(char *data, struct svm_model *model, npy_intp * dims)
{
    memcpy(data, model-&gt;probA, dims[0] * sizeof(double));
}

void copy_probB(char *data, struct svm_model *model, npy_intp * dims)
{
    memcpy(data, model-&gt;probB, dims[0] * sizeof(double));
}

/*
 * Predict using model.
 *
 *  It will return -1 if we run out of memory.
 */
int copy_predict(char *predict, struct svm_model *model, npy_intp *predict_dims,</B></FONT>
                 char *dec_values, BlasFunctions *blas_functions)
{
    double *t = (double *) dec_values;
    struct svm_node *predict_nodes;
    npy_intp i;
<A NAME="9"></A>
    predict_nodes = dense_to_libsvm((double *) predict, predict_dims);

<FONT color="#83a33a"><A HREF="javascript:ZweiFrames('match0-1.html#9',3,'match0-top.html#9',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    if (predict_nodes == NULL)
        return -1;
    for(i=0; i&lt;predict_dims[0]; ++i) {
        *t = svm_predict(model, &amp;predict_nodes[i], blas_functions);
        ++t;
    }
    free(predict_nodes);
    return 0;
}

int copy_predict_values(char *predict, struct svm_model *model,</B></FONT>
                        npy_intp *predict_dims, char *dec_values, int nr_class, BlasFunctions *blas_functions)
{
<A NAME="10"></A>    npy_intp i;
    struct svm_node *predict_nodes;
    predict_nodes = dense_to_libsvm((double *) predict, predict_dims);
<FONT color="#ad5910"><A HREF="javascript:ZweiFrames('match0-1.html#10',3,'match0-top.html#10',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    if (predict_nodes == NULL)
        return -1;
    for(i=0; i&lt;predict_dims[0]; ++i) {
        svm_predict_values(model, &amp;predict_nodes[i],
                                ((double *) dec_values) + i*nr_class,
				blas_functions);
    }

    free(predict_nodes);
    return 0;
}



int copy_predict_proba(char *predict, struct svm_model *model, npy_intp *predict_dims,</B></FONT>
                 char *dec_values, BlasFunctions *blas_functions)
{
    npy_intp i, n, m;
    struct svm_node *predict_nodes;
    n = predict_dims[0];
    m = (npy_intp) model-&gt;nr_class;
    predict_nodes = dense_to_libsvm((double *) predict, predict_dims);
    if (predict_nodes == NULL)
        return -1;
    for(i=0; i&lt;n; ++i) {
        svm_predict_probability(model, &amp;predict_nodes[i],
                                ((double *) dec_values) + i*m,
<A NAME="8"></A>				blas_functions);
    }
    free(predict_nodes);
<FONT color="#c58917"><A HREF="javascript:ZweiFrames('match0-1.html#8',3,'match0-top.html#8',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    return 0;
}


/*
 * Some free routines. Some of them are nontrivial since a lot of
 * sharing happens across objects (they *must* be called in the
 * correct order)
 */

int free_model(struct svm_model *model)
{
    /* like svm_free_and_destroy_model, but does not free sv_coef[i] */
    if (model == NULL) return -1;
    free(model-&gt;SV);

    /* We don't free sv_ind and n_iter, since we did not create them in
       set_model */
    /* free(model-&gt;sv_ind);
     * free(model-&gt;n_iter);
     */
    free(model-&gt;sv_coef);
    free(model-&gt;rho);
    free(model-&gt;label);
    free(model-&gt;probA);
    free(model-&gt;probB);
    free(model-&gt;nSV);
    free(model);

    return 0;
}

int free_param(struct svm_parameter *param)
<A NAME="4"></A>{
    if (param == NULL) return -1;</B></FONT>
    free(param);
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match0-1.html#4',3,'match0-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    return 0;
}


/* borrowed from original libsvm code */
static void print_null(const char *s) {}

static void print_string_stdout(const char *s)
{
	fputs(s,stdout);
	fflush(stdout);
}

/* provide convenience wrapper */
void set_verbosity(int verbosity_flag){
	if (verbosity_flag)
		svm_set_print_string_function(&amp;print_string_stdout);
	else
		svm_set_print_string_function(&amp;print_null);
}</B></FONT>
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>libsvm_sparse_helper.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;stdlib.h&gt;
#include &lt;numpy/arrayobject.h&gt;
#include &quot;svm.h&quot;
#include &quot;_svm_cython_blas_helpers.h&quot;


#ifndef MAX
    #define MAX(x, y) (((x) &gt; (y)) ? (x) : (y))
#endif


/*
 * Convert scipy.sparse.csr to libsvm's sparse data structure
 */
struct svm_csr_node **csr_to_libsvm (double *values, int* indices, int* indptr, npy_int n_samples)
<A NAME="12"></A>{
    struct svm_csr_node **sparse, *temp;
    int i, j=0, k=0, n;
<FONT color="#571b7e"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#12',2,'match0-top.html#12',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    sparse = malloc (n_samples * sizeof(struct svm_csr_node *));

    if (sparse == NULL)
        return NULL;

    for (i=0; i&lt;n_samples; ++i) {
        n = indptr[i+1] - indptr[i]; /* count elements in row i */
        temp = malloc ((n+1) * sizeof(struct svm_csr_node));</B></FONT>

        if (temp == NULL) {
            for (j=0; j&lt;i; j++)
                free(sparse[j]);
            free(sparse);
            return NULL;
        }

        for (j=0; j&lt;n; ++j) {
            temp[j].value = values[k];
            temp[j].index = indices[k] + 1; /* libsvm uses 1-based indexing */
            ++k;
        }
        /* set sentinel */
        temp[n].index = -1;
        sparse[i] = temp;
    }

    return sparse;
}
<A NAME="6"></A>


<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#6',2,'match0-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>struct svm_parameter * set_parameter(int svm_type, int kernel_type, int degree,
		double gamma, double coef0, double nu, double cache_size, double C,
		double eps, double p, int shrinking, int probability, int nr_weight,
		char *weight_label, char *weight, int max_iter, int random_seed)
{</B></FONT>
<A NAME="5"></A>    struct svm_parameter *param;
    param = malloc(sizeof(struct svm_parameter));
    if (param == NULL) return NULL;
<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#5',2,'match0-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    param-&gt;svm_type = svm_type;
    param-&gt;kernel_type = kernel_type;
    param-&gt;degree = degree;
    param-&gt;coef0 = coef0;
    param-&gt;nu = nu;
    param-&gt;cache_size = cache_size;
    param-&gt;C = C;
    param-&gt;eps = eps;
    param-&gt;p = p;
    param-&gt;shrinking = shrinking;
    param-&gt;probability = probability;
    param-&gt;nr_weight = nr_weight;
    param-&gt;weight_label = (int *) weight_label;
    param-&gt;weight = (double *) weight;
    param-&gt;gamma = gamma;
    param-&gt;max_iter = max_iter;
    param-&gt;random_seed = random_seed;</B></FONT>
    return param;
}


/*
 * Create and return a svm_csr_problem struct from a scipy.sparse.csr matrix. It is
 * up to the user to free resulting structure.
 *
 * TODO: precomputed kernel.
 */
struct svm_csr_problem * csr_set_problem (char *values, npy_intp *n_indices,
		char *indices, npy_intp *n_indptr, char *indptr, char *Y,
                char *sample_weight, int kernel_type) {

    struct svm_csr_problem *problem;
    problem = malloc (sizeof (struct svm_csr_problem));
    if (problem == NULL) return NULL;
    problem-&gt;l = (int) n_indptr[0] - 1;
    problem-&gt;y = (double *) Y;
    problem-&gt;x = csr_to_libsvm((double *) values, (int *) indices,
                               (int *) indptr, problem-&gt;l);
    /* should be removed once we implement weighted samples */
    problem-&gt;W = (double *) sample_weight;

    if (problem-&gt;x == NULL) {
        free(problem);
        return NULL;
    }
    return problem;
}

<A NAME="0"></A>
struct svm_csr_model *csr_set_model(struct svm_parameter *param, int nr_class,
                            char *SV_data, npy_intp *SV_indices_dims,
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#0',2,'match0-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>                            char *SV_indices, npy_intp *SV_indptr_dims,
                            char *SV_intptr,
                            char *sv_coef, char *rho, char *nSV,
                            char *probA, char *probB)
{
    struct svm_csr_model *model;
    double *dsv_coef = (double *) sv_coef;
    int i, m;

    m = nr_class * (nr_class-1)/2;

    if ((model = malloc(sizeof(struct svm_csr_model))) == NULL)
        goto model_error;
    if ((model-&gt;nSV = malloc(nr_class * sizeof(int))) == NULL)
        goto nsv_error;
    if ((model-&gt;label = malloc(nr_class * sizeof(int))) == NULL)
        goto label_error;
    if ((model-&gt;sv_coef = malloc((nr_class-1)*sizeof(double *))) == NULL)
        goto sv_coef_error;
    if ((model-&gt;rho = malloc( m * sizeof(double))) == NULL)
        goto rho_error;

    // This is only allocated in dynamic memory while training.
    model-&gt;n_iter = NULL;

    /* in the case of precomputed kernels we do not use
       dense_to_precomputed because we don't want the leading 0. As
       indices start at 1 (not at 0) this will work */
    model-&gt;l = (int) SV_indptr_dims[0] - 1;</B></FONT>
    model-&gt;SV = csr_to_libsvm((double *) SV_data, (int *) SV_indices,
                              (int *) SV_intptr, model-&gt;l);
    model-&gt;nr_class = nr_class;
    model-&gt;param = *param;

<A NAME="11"></A>    /*
     * regression and one-class does not use nSV, label.
     */
<FONT color="#b041ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#11',2,'match0-top.html#11',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    if (param-&gt;svm_type &lt; 2) {
        memcpy(model-&gt;nSV,   nSV,   model-&gt;nr_class * sizeof(int));
        for(i=0; i &lt; model-&gt;nr_class; i++)
            model-&gt;label[i] = i;
    }

    for (i=0; i &lt; model-&gt;nr_class-1; i++) {</B></FONT>
        /*
         * We cannot squash all this mallocs in a single call since
         * svm_destroy_model will free each element of the array.
         */
        if ((model-&gt;sv_coef[i] = malloc((model-&gt;l) * sizeof(double))) == NULL) {
            int j;
            for (j=0; j&lt;i; j++)
                free(model-&gt;sv_coef[j]);
<A NAME="1"></A>            goto sv_coef_i_error;
        }
        memcpy(model-&gt;sv_coef[i], dsv_coef, (model-&gt;l) * sizeof(double));
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#1',2,'match0-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        dsv_coef += model-&gt;l;
    }

    for (i=0; i&lt;m; ++i) {
        (model-&gt;rho)[i] = -((double *) rho)[i];
    }

    /*
     * just to avoid segfaults, these features are not wrapped but
     * svm_destroy_model will try to free them.
     */

    if (param-&gt;probability) {
        if ((model-&gt;probA = malloc(m * sizeof(double))) == NULL)
            goto probA_error;
        memcpy(model-&gt;probA, probA, m * sizeof(double));
        if ((model-&gt;probB = malloc(m * sizeof(double))) == NULL)
            goto probB_error;
        memcpy(model-&gt;probB, probB, m * sizeof(double));
    } else {
        model-&gt;probA = NULL;
        model-&gt;probB = NULL;
    }

    /* We'll free SV ourselves */
    model-&gt;free_sv = 0;
    return model;</B></FONT>

probB_error:
    free(model-&gt;probA);
probA_error:
    for (i=0; i &lt; model-&gt;nr_class-1; i++)
        free(model-&gt;sv_coef[i]);
sv_coef_i_error:
    free(model-&gt;rho);
rho_error:
    free(model-&gt;sv_coef);
sv_coef_error:
    free(model-&gt;label);
label_error:
    free(model-&gt;nSV);
nsv_error:
    free(model);
model_error:
    return NULL;
}


/*
 * Copy support vectors into a scipy.sparse.csr matrix
 */
int csr_copy_SV (char *data, npy_intp *n_indices,
		char *indices, npy_intp *n_indptr, char *indptr,
		struct svm_csr_model *model, int n_features)
{
	int i, j, k=0, index;
	double *dvalues = (double *) data;
	int *iindices = (int *) indices;
	int *iindptr  = (int *) indptr;
	iindptr[0] = 0;
	for (i=0; i&lt;model-&gt;l; ++i) { /* iterate over support vectors */
		index = model-&gt;SV[i][0].index;
        for(j=0; index &gt;=0 ; ++j) {
        	iindices[k] = index - 1;
            dvalues[k] = model-&gt;SV[i][j].value;
            index = model-&gt;SV[i][j+1].index;
            ++k;
        }
        iindptr[i+1] = k;
	}

	return 0;
}

/* get number of nonzero coefficients in support vectors */
npy_intp get_nonzero_SV (struct svm_csr_model *model) {
	int i, j;
	npy_intp count=0;
	for (i=0; i&lt;model-&gt;l; ++i) {
		j = 0;
		while (model-&gt;SV[i][j].index != -1) {
			++j;
			++count;
		}
	}
	return count;
}


/*
 * Predict using a model, where data is expected to be encoded into a csr matrix.
 */
int csr_copy_predict (npy_intp *data_size, char *data, npy_intp *index_size,
		char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
		char *dec_values, BlasFunctions *blas_functions) {
    double *t = (double *) dec_values;
    struct svm_csr_node **predict_nodes;
    npy_intp i;

<A NAME="9"></A>    predict_nodes = csr_to_libsvm((double *) data, (int *) index,
                                  (int *) intptr, intptr_size[0]-1);

<FONT color="#83a33a"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#9',2,'match0-top.html#9',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    if (predict_nodes == NULL)
        return -1;
    for(i=0; i &lt; intptr_size[0] - 1; ++i) {
        *t = svm_csr_predict(model, predict_nodes[i], blas_functions);
        free(predict_nodes[i]);
        ++t;
    }
    free(predict_nodes);
    return 0;
}

int csr_copy_predict_values (npy_intp *data_size, char *data, npy_intp *index_size,</B></FONT>
                char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
                char *dec_values, int nr_class, BlasFunctions *blas_functions) {
    struct svm_csr_node **predict_nodes;
    npy_intp i;

<A NAME="10"></A>    predict_nodes = csr_to_libsvm((double *) data, (int *) index,
                                  (int *) intptr, intptr_size[0]-1);

<FONT color="#ad5910"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#10',2,'match0-top.html#10',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    if (predict_nodes == NULL)
        return -1;
    for(i=0; i &lt; intptr_size[0] - 1; ++i) {
        svm_csr_predict_values(model, predict_nodes[i],
                               ((double *) dec_values) + i*nr_class,
			       blas_functions);
        free(predict_nodes[i]);
    }
    free(predict_nodes);

    return 0;
}

int csr_copy_predict_proba (npy_intp *data_size, char *data, npy_intp *index_size,</B></FONT>
		char *index, npy_intp *intptr_size, char *intptr, struct svm_csr_model *model,
		char *dec_values, BlasFunctions *blas_functions) {

    struct svm_csr_node **predict_nodes;
    npy_intp i;
    int m = model-&gt;nr_class;

    predict_nodes = csr_to_libsvm((double *) data, (int *) index,
                                  (int *) intptr, intptr_size[0]-1);

    if (predict_nodes == NULL)
        return -1;
    for(i=0; i &lt; intptr_size[0] - 1; ++i) {
        svm_csr_predict_probability(
		model, predict_nodes[i], ((double *) dec_values) + i*m, blas_functions);
        free(predict_nodes[i]);
    }
    free(predict_nodes);
    return 0;
}


npy_intp get_nr(struct svm_csr_model *model)
{
    return (npy_intp) model-&gt;nr_class;
}

<A NAME="7"></A>void copy_intercept(char *data, struct svm_csr_model *model, npy_intp *dims)
{
    /* intercept = -rho */
<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#7',2,'match0-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    npy_intp i, n = dims[0];
    double t, *ddata = (double *) data;
    for (i=0; i&lt;n; ++i) {
        t = model-&gt;rho[i];
        /* we do this to avoid ugly -0.0 */
        *ddata = (t != 0) ? -t : 0;
        ++ddata;
    }
}
<A NAME="3"></A>
void copy_support (char *data, struct svm_csr_model *model)
{</B></FONT>
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#3',2,'match0-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    memcpy (data, model-&gt;sv_ind, (model-&gt;l) * sizeof(int));
}

/*
 * Some helpers to convert from libsvm sparse data structures
 * model-&gt;sv_coef is a double **, whereas data is just a double *,
 * so we have to do some stupid copying.
 */
void copy_sv_coef(char *data, struct svm_csr_model *model)
{
    int i, len = model-&gt;nr_class-1;
    double *temp = (double *) data;
    for(i=0; i&lt;len; ++i) {
        memcpy(temp, model-&gt;sv_coef[i], sizeof(double) * model-&gt;l);
        temp += model-&gt;l;
    }
}

/*
 * Get the number of iterations run in optimization
 */
void copy_n_iter(char *data, struct svm_csr_model *model)
{</B></FONT>
    const int n_models = MAX(1, model-&gt;nr_class * (model-&gt;nr_class-1) / 2);
    memcpy(data, model-&gt;n_iter, n_models * sizeof(int));
}

/*
 * Get the number of support vectors in a model.
 */
npy_intp get_l(struct svm_csr_model *model)
{
    return (npy_intp) model-&gt;l;
}

<A NAME="2"></A>void copy_nSV(char *data, struct svm_csr_model *model)
{
    if (model-&gt;label == NULL) return;
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#2',2,'match0-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    memcpy(data, model-&gt;nSV, model-&gt;nr_class * sizeof(int));
}

/*
 * same as above with model-&gt;label
 * TODO: merge in the cython layer
 */
void copy_label(char *data, struct svm_csr_model *model)
{
    if (model-&gt;label == NULL) return;
    memcpy(data, model-&gt;label, model-&gt;nr_class * sizeof(int));
}

void copy_probA(char *data, struct svm_csr_model *model, npy_intp * dims)
{
    memcpy(data, model-&gt;probA, dims[0] * sizeof(double));
}

void copy_probB(char *data, struct svm_csr_model *model, npy_intp * dims)
{
    memcpy(data, model-&gt;probB, dims[0] * sizeof(double));
}


/*
 * Some free routines. Some of them are nontrivial since a lot of
 * sharing happens across objects (they *must* be called in the
 * correct order)
 */
int free_problem(struct svm_csr_problem *problem)</B></FONT>
{
    int i;
    if (problem == NULL) return -1;
    for (i=0; i&lt;problem-&gt;l; ++i)
<A NAME="8"></A>        free (problem-&gt;x[i]);
    free (problem-&gt;x);
    free (problem);
<FONT color="#c58917"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#8',2,'match0-top.html#8',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    return 0;
}

int free_model(struct svm_csr_model *model)
{
    /* like svm_free_and_destroy_model, but does not free sv_coef[i] */
    /* We don't free n_iter, since we did not create them in set_model. */
    if (model == NULL) return -1;
    free(model-&gt;SV);
    free(model-&gt;sv_coef);
    free(model-&gt;rho);
    free(model-&gt;label);
    free(model-&gt;probA);
    free(model-&gt;probB);
    free(model-&gt;nSV);
    free(model);

    return 0;
}

int free_param(struct svm_parameter *param)
{
    if (param == NULL) return -1;</B></FONT>
    free(param);
    return 0;
}


int free_model_SV(struct svm_csr_model *model)
{
    int i;
    for (i=model-&gt;l-1; i&gt;=0; --i) free(model-&gt;SV[i]);
<A NAME="4"></A>    /* svn_destroy_model frees model-&gt;SV */
    for (i=0; i &lt; model-&gt;nr_class-1 ; ++i) free(model-&gt;sv_coef[i]);
    /* svn_destroy_model frees model-&gt;sv_coef */
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#4',2,'match0-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    return 0;
}


/* borrowed from original libsvm code */
static void print_null(const char *s) {}

static void print_string_stdout(const char *s)
{
	fputs(s,stdout);
	fflush(stdout);
}

/* provide convenience wrapper */
void set_verbosity(int verbosity_flag){
	if (verbosity_flag)
		svm_set_print_string_function(&amp;print_string_stdout);
	else
		svm_set_print_string_function(&amp;print_null);
}</B></FONT>
</PRE>
</div>
  </div>
</body>
</html>
