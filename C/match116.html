<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for arith_dispatch.c &amp; conver_dispatch.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for arith_dispatch.c &amp; conver_dispatch.c
      </h3>
<h1 align="center">
        63.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>arith_dispatch.c (67.6876%)<th>conver_dispatch.c (60.054348%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(434-583)<td><a href="#" name="0">(931-1080)</a><td align="center"><font color="#ff0000">70</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(583-697)<td><a href="#" name="1">(721-852)</a><td align="center"><font color="#c40000">54</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(232-296)<td><a href="#" name="2">(549-617)</a><td align="center"><font color="#700000">31</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(988-1044)<td><a href="#" name="3">(375-426)</a><td align="center"><font color="#620000">27</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(80-136)<td><a href="#" name="4">(492-548)</a><td align="center"><font color="#620000">27</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1118-1166)<td><a href="#" name="5">(1159-1206)</a><td align="center"><font color="#570000">24</font>
<tr onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#8c8774"><font color="#8c8774">-</font><td><a href="#" name="6">(397-432)<td><a href="#" name="6">(868-904)</a><td align="center"><font color="#450000">19</font>
<tr onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#38a4a5"><font color="#38a4a5">-</font><td><a href="#" name="7">(881-887)<td><a href="#" name="7">(333-338)</a><td align="center"><font color="#410000">18</font>
<tr onclick='openModal("#c58917")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#c58917"><font color="#c58917">-</font><td><a href="#" name="8">(176-207)<td><a href="#" name="8">(1207-1237)</a><td align="center"><font color="#3d0000">17</font>
<tr onclick='openModal("#83a33a")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#83a33a"><font color="#83a33a">-</font><td><a href="#" name="9">(843-879)<td><a href="#" name="9">(48-72)</a><td align="center"><font color="#3a0000">16</font>
<tr onclick='openModal("#ad5910")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#ad5910"><font color="#ad5910">-</font><td><a href="#" name="10">(769-798)<td><a href="#" name="10">(168-199)</a><td align="center"><font color="#3a0000">16</font>
<tr onclick='openModal("#b041ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#b041ff"><font color="#b041ff">-</font><td><a href="#" name="11">(48-77)<td><a href="#" name="11">(127-159)</a><td align="center"><font color="#3a0000">16</font>
<tr onclick='openModal("#571b7e")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#571b7e"><font color="#571b7e">-</font><td><a href="#" name="12">(809-832)<td><a href="#" name="12">(906-928)</a><td align="center"><font color="#330000">14</font>
<tr onclick='openModal("#3b9c9c")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3b9c9c"><font color="#3b9c9c">-</font><td><a href="#" name="13">(299-326)<td><a href="#" name="13">(94-118)</a><td align="center"><font color="#330000">14</font>
<tr onclick='openModal("#842dce")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#842dce"><font color="#842dce">-</font><td><a href="#" name="14">(142-172)<td><a href="#" name="14">(659-694)</a><td align="center"><font color="#330000">14</font>
<tr onclick='openModal("#f52887")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f52887"><font color="#f52887">-</font><td><a href="#" name="15">(1204-1275)<td><a href="#" name="15">(1274-1344)</a><td align="center"><font color="#2f0000">13</font>
<tr onclick='openModal("#2981b2")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#2981b2"><font color="#2981b2">-</font><td><a href="#" name="16">(1087-1112)<td><a href="#" name="16">(301-332)</a><td align="center"><font color="#2f0000">13</font>
<tr onclick='openModal("#3090c7")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#3090c7"><font color="#3090c7">-</font><td><a href="#" name="17">(741-768)<td><a href="#" name="17">(272-298)</a><td align="center"><font color="#2f0000">13</font>
<tr onclick='openModal("#800517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#800517"><font color="#800517">-</font><td><a href="#" name="18">(706-731)<td><a href="#" name="18">(241-268)</a><td align="center"><font color="#2f0000">13</font>
<tr onclick='openModal("#f62817")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f62817"><font color="#f62817">-</font><td><a href="#" name="19">(366-393)<td><a href="#" name="19">(205-235)</a><td align="center"><font color="#2f0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>arith_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;vips/vips.h&gt;
6 #include &lt;vips/vips7compat.h&gt;
7 <a name="11"></a>static im_arg_desc one_in_one_out[] = {
8 	IM_INPUT_IMAGE( "in" ),
9 	IM_OUTPUT_IMAGE( "out" )
10 <font color="#b041ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>};
11 static im_arg_desc two_in_one_out[] = {
12 	IM_INPUT_IMAGE( "in1" ),
13 	IM_INPUT_IMAGE( "in2" ),
14 	IM_OUTPUT_IMAGE( "out" )
15 };
16 static im_arg_desc image_in_num_out[] = {
17 	IM_INPUT_IMAGE( "in" ),
18 	IM_OUTPUT_DOUBLE( "value" )
19 };
20 static im_arg_desc recomb_args[] = {
21 	IM_INPUT_IMAGE( "in" ),
22 	IM_OUTPUT_IMAGE( "out" ),
23 	IM_INPUT_DMASK( "matrix" )
24 };
25 static int
26 recomb_vec( im_object *argv )
27 <a name="4"></a>{</b></font>
28 	im_mask_object *mo = argv[2];
29 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_recomb( argv[0], argv[1], mo-&gt;mask ) );
30 }
31 static im_function recomb_desc = {
32 	"im_recomb", 				"linear recombination with mask",
33 	IM_FN_PIO,				recomb_vec, 				IM_NUMBER( recomb_args ), 		recomb_args 			};
34 static int
35 abs_vec( im_object *argv )
36 {
37 	return( im_abs( argv[0], argv[1] ) );
38 }
39 static im_function abs_desc = {
40 	"im_abs", 				N_( "absolute value" ),			IM_FN_PIO | IM_FN_PTOP,			abs_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
41 static int
42 add_vec( im_object *argv )
43 {
44 	return( im_add( argv[0], argv[1], argv[2] ) );
45 }
46 static im_function add_desc = {
47 	"im_add", 				N_( "add two images" ),			IM_FN_PIO | IM_FN_PTOP,			add_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
48 static int
49 avg_vec( im_object *argv )
50 {</b></font>
51 	double f;
52 <a name="14"></a>	if( im_avg( argv[0], &amp;f ) )
53 		return( -1 );
54 <font color="#842dce"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	*((double *) argv[1]) = f;
55 	return( 0 );
56 }
57 static im_function avg_desc = {
58 	"im_avg", 				N_( "average value of image" ),		IM_FN_PIO,				avg_vec, 				IM_NUMBER( image_in_num_out ), 		image_in_num_out 		};
59 static im_arg_desc point_args[] = {
60 	IM_INPUT_IMAGE( "in" ),
61 	IM_INPUT_INTERPOLATE( "interpolate" ),
62 	IM_INPUT_DOUBLE( "x" ),
63 	IM_INPUT_DOUBLE( "y" ),
64 	IM_INPUT_INT( "band" ),
65 	IM_OUTPUT_DOUBLE( "out" )
66 };
67 static int
68 point_vec( im_object *argv )
69 {</b></font>
70 <a name="8"></a>	VipsInterpolate *interpolate = VIPS_INTERPOLATE( argv[1] );
71 	double x = *((double *) argv[2]);
72 	double y = *((double *) argv[3]);
73 <font color="#c58917"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int band = *((int *) argv[4]);
74 	return( im_point( argv[0], interpolate, x, y, band, argv[5] ) );
75 }
76 static im_function point_desc = {
77 	"im_point",
78 	"interpolate value at single point",
79 	IM_FN_PIO,
80 	point_vec,
81 	IM_NUMBER( point_args ),
82 	point_args
83 };
84 static im_arg_desc point_bilinear_args[] = {
85   IM_INPUT_IMAGE ("in"),
86   IM_INPUT_DOUBLE("x"),
87   IM_INPUT_DOUBLE("y"),
88   IM_INPUT_INT("band"),
89   IM_OUTPUT_DOUBLE("val")
90 };
91 static int
92 point_bilinear_vec( im_object *argv )
93 {
94   return im_point_bilinear( argv[0], *(double*)argv[1], *(double*)argv[2], *(int*)argv[3], argv[4] );</b></font>
95 }
96 static im_function point_bilinear_desc = {
97   "im_point_bilinear",
98   "interpolate value at single point, linearly",
99   IM_FN_PIO,
100   point_bilinear_vec,
101   IM_NUMBER( point_bilinear_args ),
102   point_bilinear_args
103 };
104 static int
105 deviate_vec( im_object *argv )
106 {
107 	double f;
108 	if( im_deviate( argv[0], &amp;f ) )
109 <a name="2"></a>		return( -1 );
110 	*((double *) argv[1]) = f;
111 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
112 }
113 static im_function deviate_desc = {
114 	"im_deviate", 				N_( "standard deviation of image" ),		IM_FN_PIO,				deviate_vec, 				IM_NUMBER( image_in_num_out ), 		image_in_num_out 		};
115 static int
116 exp10tra_vec( im_object *argv )
117 {
118 	return( im_exp10tra( argv[0], argv[1] ) );
119 }
120 static im_function exp10tra_desc = {
121 	"im_exp10tra", 				N_( "10^pel of image" ),		IM_FN_PIO | IM_FN_PTOP,			exp10tra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
122 static int
123 exptra_vec( im_object *argv )
124 {
125 	return( im_exptra( argv[0], argv[1] ) );
126 }
127 static im_function exptra_desc = {
128 	"im_exptra", 				N_( "e^pel of image" ),			IM_FN_PIO | IM_FN_PTOP,			exptra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
129 static im_arg_desc powtra_args[] = {
130 	IM_INPUT_IMAGE( "in" ),
131 	IM_OUTPUT_IMAGE( "out" ),
132 	IM_INPUT_DOUBLE( "x" )
133 };
134 static int
135 expntra_vec( im_object *argv )
136 <a name="13"></a>{</b></font>
137 	double a = *((double *) argv[2]);
138 <font color="#3b9c9c"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_expntra( argv[0], argv[1], a ) );
139 }
140 static im_function expntra_desc = {
141 	"im_expntra", 				N_( "x^pel of image" ),			IM_FN_PIO | IM_FN_PTOP,			expntra_vec, 				IM_NUMBER( powtra_args ), 		powtra_args 			};
142 static im_arg_desc expntra_vec_args[] = {
143 	IM_INPUT_IMAGE( "in" ),
144 	IM_OUTPUT_IMAGE( "out" ),
145 	IM_INPUT_DOUBLEVEC( "v" )
146 };
147 static int
148 expntra_vec_vec( im_object *argv )
149 {
150 	im_doublevec_object *rv = (im_doublevec_object *) argv[2];</b></font>
151 	return( im_expntra_vec( argv[0], argv[1], rv-&gt;n, rv-&gt;vec ) );
152 }
153 static im_function expntra_vec_desc = {
154 	"im_expntra_vec", 			N_( "[x,y,z]^pel of image" ),		IM_FN_PIO | IM_FN_PTOP,			expntra_vec_vec, 			IM_NUMBER( expntra_vec_args ), 		expntra_vec_args 		};
155 static int
156 divide_vec( im_object *argv )
157 {
158 	return( im_divide( argv[0], argv[1], argv[2] ) );
159 }
160 static im_function divide_desc = {
161 	"im_divide", 				N_( "divide two images" ),
162 	IM_FN_PIO,				divide_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
163 <a name="19"></a>static int
164 invert_vec( im_object *argv )
165 {
166 <font color="#f62817"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_invert( argv[0], argv[1] ) );
167 }
168 static im_function invert_desc = {
169 	"im_invert", 				N_( "photographic negative" ),		IM_FN_PIO | IM_FN_PTOP,			invert_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
170 static im_arg_desc lintra_args[] = {
171 	IM_INPUT_DOUBLE( "a" ),
172 	IM_INPUT_IMAGE( "in" ),
173 	IM_INPUT_DOUBLE( "b" ),
174 	IM_OUTPUT_IMAGE( "out" )
175 };
176 static int
177 lintra_vec( im_object *argv )
178 {</b></font>
179 <a name="6"></a>	double a = *((double *) argv[0]);
180 	double b = *((double *) argv[2]);
181 <font color="#8c8774"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_lintra( a, argv[1], b, argv[3] ) );
182 }
183 static im_function lintra_desc = {
184 	"im_lintra", 				N_( "calculate a*in + b = outfile" ),
185 	IM_FN_PIO | IM_FN_PTOP,			lintra_vec, 				IM_NUMBER( lintra_args ), 		lintra_args 			};
186 static im_arg_desc lintra_vec_args[] = {
187 	IM_INPUT_DOUBLEVEC( "a" ),
188 	IM_INPUT_IMAGE( "in" ),
189 	IM_INPUT_DOUBLEVEC( "b" ),
190 	IM_OUTPUT_IMAGE( "out" )
191 };
192 static int
193 lintra_vec_vec( im_object *argv )
194 {
195 	im_doublevec_object *dva = (im_doublevec_object *) argv[0];
196 	im_doublevec_object *dvb = (im_doublevec_object *) argv[2];
197 	if( dva-&gt;n != dvb-&gt;n ) {
198 		im_error( "im_lintra_vec", 
199 			"%s", _( "vectors not equal length" ) );
200 <a name="0"></a>		return( -1 );
201 	}</b></font>
202 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_lintra_vec( dva-&gt;n, dva-&gt;vec, argv[1], dvb-&gt;vec, argv[3] ) );
203 }
204 static im_function lintra_vec_desc = {
205 	"im_lintra_vec", 			N_( "calculate a*in + b -&gt; out, a and b vectors" ),
206 	IM_FN_PIO | IM_FN_PTOP,			lintra_vec_vec, 			IM_NUMBER( lintra_vec_args ), 		lintra_vec_args 		};
207 static int
208 log10tra_vec( im_object *argv )
209 {
210 	return( im_log10tra( argv[0], argv[1] ) );
211 }
212 static im_function log10tra_desc = {
213 	"im_log10tra", 				N_( "log10 of image" ),			IM_FN_PIO | IM_FN_PTOP,			log10tra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
214 static int
215 logtra_vec( im_object *argv )
216 {
217 	return( im_logtra( argv[0], argv[1] ) );
218 }
219 static im_function logtra_desc = {
220 	"im_logtra", 				N_( "ln of image" ),			IM_FN_PIO | IM_FN_PTOP,			logtra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
221 static int
222 tantra_vec( im_object *argv )
223 {
224 	return( im_tantra( argv[0], argv[1] ) );
225 }
226 static im_function tantra_desc = {
227 	"im_tantra", 				N_( "tan of image (angles in degrees)" ),
228 	IM_FN_PIO | IM_FN_PTOP,			tantra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
229 static int
230 atantra_vec( im_object *argv )
231 {
232 	return( im_atantra( argv[0], argv[1] ) );
233 }
234 static im_function atantra_desc = {
235 	"im_atantra", 				N_( "atan of image (result in degrees)" ),
236 	IM_FN_PIO | IM_FN_PTOP,			atantra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
237 static int
238 costra_vec( im_object *argv )
239 {
240 	return( im_costra( argv[0], argv[1] ) );
241 }
242 static im_function costra_desc = {
243 	"im_costra", 				N_( "cos of image (angles in degrees)" ),
244 	IM_FN_PIO | IM_FN_PTOP,			costra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
245 static int
246 acostra_vec( im_object *argv )
247 {
248 	return( im_acostra( argv[0], argv[1] ) );
249 }
250 static im_function acostra_desc = {
251 	"im_acostra", 				N_( "acos of image (result in degrees)" ),
252 	IM_FN_PIO | IM_FN_PTOP,			acostra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
253 static int
254 ceil_vec( im_object *argv )
255 {
256 	return( im_ceil( argv[0], argv[1] ) );
257 }
258 static im_function ceil_desc = {
259 	"im_ceil", 				N_( "round to smallest integer value not less than" ),
260 	IM_FN_PIO | IM_FN_PTOP,			ceil_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
261 <a name="1"></a>
262 static int</b></font><font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>
263 floor_vec( im_object *argv )
264 {
265 	return( im_floor( argv[0], argv[1] ) );
266 }
267 static im_function floor_desc = {
268 	"im_floor", 				N_( "round to largest integer value not greater than" ),
269 	IM_FN_PIO | IM_FN_PTOP,			floor_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
270 static int
271 rint_vec( im_object *argv )
272 {
273 	return( im_rint( argv[0], argv[1] ) );
274 }
275 static im_function rint_desc = {
276 	"im_rint", 				N_( "round to nearest integer value" ),
277 	IM_FN_PIO | IM_FN_PTOP,			rint_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
278 static int
279 sintra_vec( im_object *argv )
280 {
281 	return( im_sintra( argv[0], argv[1] ) );
282 }
283 static im_function sintra_desc = {
284 	"im_sintra", 				N_( "sin of image (angles in degrees)" ),
285 	IM_FN_PIO | IM_FN_PTOP,			sintra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
286 static int
287 bandmean_vec( im_object *argv )
288 {
289 	return( im_bandmean( argv[0], argv[1] ) );
290 }
291 static im_function bandmean_desc = {
292 	"im_bandmean", 				N_( "average image bands" ),
293 	IM_FN_PIO,				bandmean_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
294 static int
295 sign_vec( im_object *argv )
296 {
297 	return( im_sign( argv[0], argv[1] ) );
298 }
299 static im_function sign_desc = {
300 	"im_sign", 				N_( "unit vector in direction of value" ),
301 	IM_FN_PIO | IM_FN_PTOP,			sign_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
302 static int
303 asintra_vec( im_object *argv )
304 {
305 	return( im_asintra( argv[0], argv[1] ) );
306 }
307 static im_function asintra_desc = {
308 	"im_asintra", 				N_( "asin of image (result in degrees)" ),
309 	IM_FN_PIO | IM_FN_PTOP,			asintra_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
310 static int</b></font>
311 max_vec( im_object *argv )
312 {
313 	double f;
314 	if( im_max( argv[0], &amp;f ) )
315 <a name="18"></a>		return( -1 );
316 	*((double *) argv[1]) = f;
317 <font color="#800517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
318 }
319 static im_function max_desc = {
320 	"im_max", 				N_( "maximum value of image" ),		IM_FN_PIO,				max_vec, 				IM_NUMBER( image_in_num_out ), 		image_in_num_out 		};
321 static im_arg_desc maxpos_args[] = {
322 	IM_INPUT_IMAGE( "in" ),
323 	IM_OUTPUT_COMPLEX( "position" )
324 };
325 static int
326 maxpos_vec( im_object *argv )
327 {</b></font>
328 	double f;
329 	int x, y;
330 	if( im_maxpos( argv[0], &amp;x, &amp;y, &amp;f ) )
331 		return( -1 );
332 <a name="17"></a>	((double *) argv[1])[0] = x;
333 	((double *) argv[1])[1] = y;
334 <font color="#3090c7"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
335 }
336 static im_function maxpos_desc = {
337 	"im_maxpos", 				N_( "position of maximum value of image" ),
338 	0,					maxpos_vec, 				IM_NUMBER( maxpos_args ), 		maxpos_args 			};
339 static im_arg_desc maxpos_avg_args[] = {
340   IM_INPUT_IMAGE ("in"),
341   IM_OUTPUT_DOUBLE("x"),
342   IM_OUTPUT_DOUBLE("y"),
343   IM_OUTPUT_DOUBLE("out")
344 };
345 <a name="10"></a>static int
346 maxpos_avg_vec( im_object *argv )
347 {</b></font>
348 <font color="#ad5910"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  return im_maxpos_avg( argv[0], argv[1], argv[2], argv[3] );
349 }
350 static im_function maxpos_avg_desc = {
351   "im_maxpos_avg",
352   N_( "position of maximum value of image, averaging in case of draw" ),
353   IM_FN_PIO,
354   maxpos_avg_vec,
355   IM_NUMBER( maxpos_avg_args ),
356   maxpos_avg_args
357 };
358 static im_arg_desc maxpos_vec_args[] = {
359   IM_INPUT_IMAGE ("in"),
360   IM_INPUT_INT ("n"),
361   IM_OUTPUT_INTVEC("xes"),
362   IM_OUTPUT_INTVEC("yes"),
363   IM_OUTPUT_DOUBLEVEC("maxima")
364 };
365 static int
366 maxpos_vec_vec( im_object *argv )
367 {
368   int n = *((int *) argv[1]);</b></font>
369   im_intvec_object *xes = argv[2];
370   im_intvec_object *yes = argv[3];
371   im_doublevec_object *maxima = argv[4];
372   xes-&gt;vec = IM_ARRAY( NULL, n, int );
373   xes-&gt;n = n;
374   yes-&gt;vec = IM_ARRAY( NULL, n, int );
375 <a name="12"></a>  yes-&gt;n = n;
376   maxima-&gt;vec = IM_ARRAY( NULL, n, double );
377   maxima-&gt;n = n;
378 <font color="#571b7e"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if( !xes-&gt;vec || !yes-&gt;vec || !maxima-&gt;vec ||
379     im_maxpos_vec( argv[0], xes-&gt;vec, yes-&gt;vec, maxima-&gt;vec, n ) )
380     return -1;
381   return 0;
382 }
383 static im_function maxpos_vec_desc = {
384   "im_maxpos_vec",
385   N_( "position and value of n maxima of image" ),
386   IM_FN_PIO,
387   maxpos_vec_vec,
388   IM_NUMBER( maxpos_vec_args ),
389   maxpos_vec_args
390 };
391 static int
392 minpos_vec_vec( im_object *argv )
393 {
394   int n = *((int *) argv[1]);</b></font>
395   im_intvec_object *xes = argv[2];
396   im_intvec_object *yes = argv[3];
397   im_doublevec_object *minima = argv[4];
398   xes-&gt;vec = IM_ARRAY( NULL, n, int );
399   xes-&gt;n = n;
400   yes-&gt;vec = IM_ARRAY( NULL, n, int );
401 <a name="9"></a>  yes-&gt;n = n;
402   minima-&gt;vec = IM_ARRAY( NULL, n, double );
403   minima-&gt;n = n;
404 <font color="#83a33a"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if( !xes-&gt;vec || !yes-&gt;vec || !minima-&gt;vec ||
405     im_minpos_vec( argv[0], xes-&gt;vec, yes-&gt;vec, minima-&gt;vec, n ) )
406     return -1;
407   return 0;
408 }
409 static im_function minpos_vec_desc = {
410   "im_minpos_vec",
411   N_( "position and value of n minima of image" ),
412   IM_FN_PIO,
413   minpos_vec_vec,
414   IM_NUMBER( maxpos_vec_args ),
415   maxpos_vec_args
416 };
417 static im_arg_desc measure_args[] = {
418 	IM_INPUT_IMAGE( "in" ),
419 	IM_OUTPUT_DMASK( "mask" ),
420 	IM_INPUT_INT( "x" ),
421 	IM_INPUT_INT( "y" ),
422 	IM_INPUT_INT( "w" ),
423 	IM_INPUT_INT( "h" ),
424 	IM_INPUT_INT( "h_patches" ),
425 	IM_INPUT_INT( "v_patches" )
426 };
427 static int
428 measure_vec( im_object *argv )
429 <a name="7"></a>{
430 	im_mask_object *mo = argv[1];</b></font>
431 <font color="#38a4a5"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	int x = *((int *) argv[2]);
432 	int y = *((int *) argv[3]);
433 	int w = *((int *) argv[4]);
434 	int h = *((int *) argv[5]);
435 	int u = *((int *) argv[6]);
436 	int v = *((int *) argv[7]);</b></font>
437 	if( !(mo-&gt;mask = 
438 		im_measure_area( argv[0], 
439 			x, y, w, h, u, v, NULL, 0, mo-&gt;name )) ) {
440 		return( -1 );
441 	}
442 	return( 0 );
443 }
444 static im_function measure_desc = {
445 	"im_measure", 				N_( "measure averages of a grid of patches" ),
446 	IM_FN_PIO,				measure_vec, 				IM_NUMBER( measure_args ), 		measure_args 			};
447 static int
448 min_vec( im_object *argv )
449 {
450 	double f;
451 	if( im_min( argv[0], &amp;f ) )
452 		return( -1 );
453 	*((double *) argv[1]) = f;
454 	return( 0 );
455 }
456 static im_function min_desc = {
457 	"im_min", 				N_( "minimum value of image" ),		IM_FN_PIO,				min_vec, 				IM_NUMBER( image_in_num_out ), 		image_in_num_out 		};
458 static int
459 minpos_vec( im_object *argv )
460 {
461 	double f;
462 	int x, y;
463 	if( im_minpos( argv[0], &amp;x, &amp;y, &amp;f ) )
464 		return( -1 );
465 	((double *) argv[1])[0] = x;
466 	((double *) argv[1])[1] = y;
467 	return( 0 );
468 }
469 static im_function minpos_desc = {
470 	"im_minpos", 				N_( "position of minimum value of image" ),
471 	0,					minpos_vec, 				IM_NUMBER( maxpos_args ), 		maxpos_args 			};
472 static int
473 remainder_vec( im_object *argv )
474 {
475 	return( im_remainder( argv[0], argv[1], argv[2] ) );
476 }
477 static im_function remainder_desc = {
478 	"im_remainder", 			N_( "remainder after integer division" ),		IM_FN_PIO | IM_FN_PTOP,			remainder_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
479 static int
480 remainderconst_vec( im_object *argv )
481 <a name="3"></a>{
482 	double c = *((double *) argv[2]);
483 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_remainderconst( argv[0], argv[1], c ) );
484 }
485 static im_arg_desc remainderconst_args[] = {
486 	IM_INPUT_IMAGE( "in" ),
487 	IM_OUTPUT_IMAGE( "out" ),
488 	IM_INPUT_DOUBLE( "x" )
489 };
490 static im_function remainderconst_desc = {
491 	"im_remainderconst", 			N_( "remainder after integer division by a constant" ),	IM_FN_PIO | IM_FN_PTOP,			remainderconst_vec, 			IM_NUMBER( remainderconst_args ),	remainderconst_args 		};
492 static int
493 remainder_vec_vec( im_object *argv )
494 {
495 	im_doublevec_object *dv = (im_doublevec_object *) argv[2];
496 	return( im_remainder_vec( argv[0], argv[1], dv-&gt;n, dv-&gt;vec ) );
497 }
498 static im_arg_desc remainder_vec_args[] = {
499 	IM_INPUT_IMAGE( "in" ),
500 	IM_OUTPUT_IMAGE( "out" ),
501 	IM_INPUT_DOUBLEVEC( "x" )
502 };
503 static im_function remainder_vec_desc = {
504 	"im_remainder_vec", 			N_( "remainder after integer division by a vector of constants" ),
505 	IM_FN_PIO | IM_FN_PTOP,			remainder_vec_vec, 			IM_NUMBER( remainder_vec_args ),	remainder_vec_args 		};
506 static int
507 multiply_vec( im_object *argv )
508 {</b></font>
509 	return( im_multiply( argv[0], argv[1], argv[2] ) );
510 }
511 static im_function multiply_desc = {
512 	"im_multiply", 				N_( "multiply two images" ),		IM_FN_PIO | IM_FN_PTOP,			multiply_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
513 static int
514 powtra_vec( im_object *argv )
515 {
516 	double a = *((double *) argv[2]);
517 	return( im_powtra( argv[0], argv[1], a ) );
518 }
519 static im_function powtra_desc = {
520 	"im_powtra", 				N_( "pel^x of image" ),
521 	IM_FN_PIO | IM_FN_PTOP,			powtra_vec, 				IM_NUMBER( powtra_args ), 		powtra_args 			};
522 static int
523 powtra_vec_vec( im_object *argv )
524 <a name="16"></a>{
525 	im_doublevec_object *rv = (im_doublevec_object *) argv[2];
526 <font color="#2981b2"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_powtra_vec( argv[0], argv[1], rv-&gt;n, rv-&gt;vec ) );
527 }
528 static im_function powtra_vec_desc = {
529 	"im_powtra_vec", 			N_( "pel^[x,y,z] of image" ),
530 	IM_FN_PIO | IM_FN_PTOP,			powtra_vec_vec, 			IM_NUMBER( expntra_vec_args ), 		expntra_vec_args 		};
531 static im_arg_desc stats_args[] = {
532 	IM_INPUT_IMAGE( "in" ),
533 	IM_OUTPUT_DMASK_STATS( "statistics" )
534 };
535 static int
536 stats_vec( im_object *argv )
537 {</b></font>
538 	im_mask_object *mo = argv[1];
539 <a name="5"></a>	if( !(mo-&gt;mask = im_stats( argv[0] )) )
540 		return( -1 );
541 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( 0 );
542 }
543 static im_function stats_desc = {
544 	"im_stats", 				N_( "many image statistics in one pass" ),
545 	IM_FN_PIO,				stats_vec, 				IM_NUMBER( stats_args ), 		stats_args 			};
546 static int
547 subtract_vec( im_object *argv )
548 {
549 	return( im_subtract( argv[0], argv[1], argv[2] ) );
550 }
551 static im_function subtract_desc = {
552 	"im_subtract", 				N_( "subtract two images" ),		IM_FN_PIO,				subtract_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
553 static im_arg_desc linreg_args[] = {
554 	IM_INPUT_IMAGEVEC( "ins" ),
555 	IM_OUTPUT_IMAGE( "out" ),
556         IM_INPUT_DOUBLEVEC( "xs" )
557 };
558 static int
559 linreg_vec( im_object *argv )
560 {
561 #define FUNCTION_NAME "im_linreg_vec"
562   im_imagevec_object *ins_vec= (im_imagevec_object*) argv[0];
563   im_doublevec_object *xs_vec= (im_doublevec_object*) argv[2];</b></font>
564   IMAGE *out= (IMAGE*) argv[1];
565   IMAGE **ins= IM_ARRAY( out, ins_vec-&gt; n + 1, IMAGE* );
566   int i;
567   if( ! ins )
568     return -1;
569   for( i= 0; i &lt; ins_vec-&gt; n; ++i )
570     ins[ i ]= ins_vec-&gt; vec[ i ];
571   ins[ ins_vec-&gt; n ]= NULL;
572   if( xs_vec-&gt; n != ins_vec-&gt; n ){
573     im_error( FUNCTION_NAME, "image vector and x vector differ in length" );
574     return -1;
575   }
576   return im_linreg( ins, out, xs_vec-&gt; vec );
577 #undef FUNCTION_NAME
578 }
579 static im_function linreg_desc = {
580 	"im_linreg", 				N_( "pixelwise linear regression" ),
581 	IM_FN_PIO | IM_FN_PTOP,			linreg_vec, 				IM_NUMBER( linreg_args ), 		linreg_args 			};
582 <a name="15"></a>static int
583 cross_phase_vec( im_object *argv )
584 {
585 <font color="#f52887"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	return( im_cross_phase( argv[0], argv[1], argv[2] ) );
586 }
587 static im_function cross_phase_desc = {
588 	"im_cross_phase", 				N_( "phase of cross power spectrum of two complex images" ),		IM_FN_PIO | IM_FN_PTOP,			cross_phase_vec, 			IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
589 static im_function *arith_list[] = {
590 	&amp;abs_desc,
591 	&amp;acostra_desc,
592 	&amp;add_desc,
593 	&amp;asintra_desc,
594 	&amp;atantra_desc,
595 	&amp;avg_desc,
596         &amp;point_desc,
597         &amp;point_bilinear_desc,
598         &amp;bandmean_desc,
599 	&amp;ceil_desc,
600 	&amp;costra_desc,
601 	&amp;cross_phase_desc,
602 	&amp;deviate_desc,
603 	&amp;divide_desc,
604 	&amp;exp10tra_desc,
605 	&amp;expntra_desc,
606 	&amp;expntra_vec_desc,
607 	&amp;exptra_desc,
608 	&amp;floor_desc,
609 	&amp;invert_desc,
610 	&amp;lintra_desc,
611 	&amp;linreg_desc,
612 	&amp;lintra_vec_desc,
613 	&amp;log10tra_desc,
614 	&amp;logtra_desc,
615 	&amp;max_desc,
616 	&amp;maxpos_desc,
617 	&amp;maxpos_avg_desc,
618 	&amp;maxpos_vec_desc,
619 	&amp;measure_desc,
620 	&amp;min_desc,
621 	&amp;minpos_desc,
622 	&amp;minpos_vec_desc,
623 	&amp;multiply_desc,
624 	&amp;powtra_desc,
625 	&amp;powtra_vec_desc,
626 	&amp;recomb_desc,
627 	&amp;remainder_desc,
628 	&amp;remainderconst_desc,
629 	&amp;remainder_vec_desc,
630 	&amp;rint_desc,
631 	&amp;sign_desc,
632 	&amp;sintra_desc,
633 	&amp;stats_desc,
634 	&amp;subtract_desc,
635 	&amp;tantra_desc
636 };
637 im_package im__arithmetic = {
638 	"arithmetic",
639 	IM_NUMBER( arith_list ),
640 	arith_list
641 };</b></font>
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>conver_dispatch.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;vips/vips.h&gt;
5 #include &lt;vips/vips7compat.h&gt;
6 static int
7 system_vec( im_object *argv )
8 {
9 	IMAGE *in = argv[0];
10 <a name="9"></a>	char *cmd = argv[1];
11 	char **out = (char **) &amp;argv[2];
12 <font color="#83a33a"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( im_system( in, cmd, out ) )
13 		return( -1 );
14 	return( 0 );
15 }
16 static im_arg_desc system_args[] = {
17 	IM_INPUT_IMAGE( "im" ),
18 	IM_INPUT_STRING( "command" ),
19 	IM_OUTPUT_STRING( "output" )
20 };
21 static im_function system_desc = {
22 	"im_system",				"run command on image",			0,					system_vec, 				IM_NUMBER( system_args ),		system_args 			};
23 static int
24 system_image_vec( im_object *argv )
25 {
26 	IMAGE *in = argv[0];</b></font>
27 	IMAGE *out = argv[1];
28 	char *in_format = argv[2];
29 	char *out_format = argv[3];
30 	char *cmd = argv[4];
31 	char **log = (char **) &amp;argv[5];
32 	IMAGE *out_image;
33 	if( !(out_image = im_system_image( in, 
34 		in_format, out_format, cmd, log )) ) {
35 		im_error( "im_system_image", "%s", *log );
36 		return( -1 );
37 	}
38 	if( im_copy( out_image, out ) ||
39 		im_add_close_callback( out, 
40 			(im_callback_fn) im_close, out_image, NULL ) ) {
41 		im_close( out_image );
42 <a name="13"></a>		return( -1 );
43 	}
44 <font color="#3b9c9c"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
45 }
46 static im_arg_desc system_image_args[] = {
47 	IM_INPUT_IMAGE( "in" ),
48 	IM_OUTPUT_IMAGE( "out" ),
49 	IM_INPUT_STRING( "in_format" ),
50 	IM_INPUT_STRING( "out_format" ),
51 	IM_INPUT_STRING( "command" ),
52 	IM_OUTPUT_STRING( "log" )
53 };
54 static im_function system_image_desc = {
55 	"im_system_image",			"run command on image, with image output",	0,					system_image_vec, 			IM_NUMBER( system_image_args ),		system_image_args 		};
56 static int
57 subsample_vec( im_object *argv )
58 {
59 	IMAGE *in = argv[0];</b></font>
60 	IMAGE *out = argv[1];
61 	int xsh = *((int *) argv[2]);
62 	int ysh = *((int *) argv[3]);
63 	if( im_subsample( in, out, xsh, ysh ) )
64 <a name="11"></a>		return( -1 );
65 	return( 0 );
66 <font color="#b041ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
67 static im_arg_desc subsample_args[] = {
68 	IM_INPUT_IMAGE( "in" ),
69 	IM_OUTPUT_IMAGE( "out" ),
70 	IM_INPUT_INT( "xshrink" ),
71 	IM_INPUT_INT( "yshrink" )
72 };
73 static im_function subsample_desc = {
74 	"im_subsample",				"subsample image by integer factors",		IM_FN_PIO,				subsample_vec,				IM_NUMBER( subsample_args ), 		subsample_args 			};
75 static im_arg_desc gaussnoise_args[] = {
76 	IM_OUTPUT_IMAGE( "out" ),
77 	IM_INPUT_INT( "xsize" ),
78 	IM_INPUT_INT( "ysize" ),
79 	IM_INPUT_DOUBLE( "mean" ),
80 	IM_INPUT_DOUBLE( "sigma" )
81 };
82 static int
83 gaussnoise_vec( im_object *argv )
84 {</b></font>
85 	int xsize = *((int *) argv[1]);
86 	int ysize = *((int *) argv[2]);
87 	double mean = *((double *) argv[3]);
88 	double sigma = *((double *) argv[4]);
89 <a name="10"></a>	if( im_gaussnoise( argv[0], xsize, ysize, mean, sigma ) )
90 		return( -1 );
91 <font color="#ad5910"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( 0 );
92 }
93 static im_function gaussnoise_desc = {
94 	"im_gaussnoise", 			"generate image of gaussian noise with specified statistics",
95 	IM_FN_PIO | IM_FN_NOCACHE,		gaussnoise_vec, 			IM_NUMBER( gaussnoise_args ), 		gaussnoise_args 		};
96 static im_arg_desc extract_args[] = {
97 	IM_INPUT_IMAGE( "input" ),
98 	IM_OUTPUT_IMAGE( "output" ),
99 	IM_INPUT_INT( "left" ),
100 	IM_INPUT_INT( "top" ),
101 	IM_INPUT_INT( "width" ),
102 	IM_INPUT_INT( "height" ),
103 	IM_INPUT_INT( "band" )
104 };
105 static int
106 extract_vec( im_object *argv )
107 {
108 	int left = *((int *) argv[2]);</b></font>
109 	int top = *((int *) argv[3]);
110 	int width = *((int *) argv[4]);
111 <a name="19"></a>	int height = *((int *) argv[5]);
112 	int band = *((int *) argv[6]);
113 <font color="#f62817"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_extract_areabands( argv[0], argv[1], 
114 		left, top, width, height, band, 1 ) );
115 }
116 static im_function extract_desc = {
117 	"im_extract", 				"extract area/band",			IM_FN_TRANSFORM | IM_FN_PIO,		extract_vec, 				IM_NUMBER( extract_args ), 		extract_args 			};
118 static im_arg_desc extract_area_args[] = {
119 	IM_INPUT_IMAGE( "input" ),
120 	IM_OUTPUT_IMAGE( "output" ),
121 	IM_INPUT_INT( "left" ),
122 	IM_INPUT_INT( "top" ),
123 	IM_INPUT_INT( "width" ),
124 	IM_INPUT_INT( "height" )
125 };
126 static int
127 extract_area_vec( im_object *argv )
128 {</b></font>
129 	int x = *((int *) argv[2]);
130 	int y = *((int *) argv[3]);
131 <a name="18"></a>	int w = *((int *) argv[4]);
132 	int h = *((int *) argv[5]);
133 <font color="#800517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_extract_area( argv[0], argv[1], x, y, w, h ) );
134 }
135 static im_function extract_area_desc = {
136 	"im_extract_area", 			"extract area",				IM_FN_TRANSFORM | IM_FN_PIO,		extract_area_vec, 			IM_NUMBER( extract_area_args ), 	extract_area_args 		};
137 static im_arg_desc extract_bands_args[] = {
138 	IM_INPUT_IMAGE( "input" ),
139 	IM_OUTPUT_IMAGE( "output" ),
140 	IM_INPUT_INT( "band" ),
141 	IM_INPUT_INT( "nbands" ),
142 };
143 static int
144 extract_bands_vec( im_object *argv )
145 {</b></font>
146 <a name="17"></a>	int chsel = *((int *) argv[2]);
147 	int nbands = *((int *) argv[3]);
148 <font color="#3090c7"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_extract_bands( argv[0], argv[1], chsel, nbands ) );
149 }
150 static im_function extract_bands_desc = {
151 	"im_extract_bands", 			"extract several bands",		IM_FN_PIO,				extract_bands_vec, 			IM_NUMBER( extract_bands_args ),	extract_bands_args 		};
152 static im_arg_desc extract_band_args[] = {
153 	IM_INPUT_IMAGE( "input" ),
154 	IM_OUTPUT_IMAGE( "output" ),
155 	IM_INPUT_INT( "band" )
156 };
157 static int
158 extract_band_vec( im_object *argv )
159 <a name="16"></a>{</b></font>
160 	int chsel = *((int *) argv[2]);
161 <font color="#2981b2"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_extract_band( argv[0], argv[1], chsel ) );
162 }
163 static im_function extract_band_desc = {
164 	"im_extract_band", 			"extract band",				IM_FN_PIO,				extract_band_vec, 			IM_NUMBER( extract_band_args ), 	extract_band_args 		};
165 static im_arg_desc extract_areabands_args[] = {
166 	IM_INPUT_IMAGE( "input" ),
167 	IM_OUTPUT_IMAGE( "output" ),
168 	IM_INPUT_INT( "left" ),
169 	IM_INPUT_INT( "top" ),
170 	IM_INPUT_INT( "width" ),
171 	IM_INPUT_INT( "height" ),
172 	IM_INPUT_INT( "band" ),
173 	IM_INPUT_INT( "nbands" )
174 };
175 <a name="7"></a>static int
176 extract_areabands_vec( im_object *argv )
177 {</b></font>
178 <font color="#38a4a5"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	int left = *((int *) argv[2]);
179 	int top = *((int *) argv[3]);
180 	int width = *((int *) argv[4]);
181 	int height = *((int *) argv[5]);
182 	int band = *((int *) argv[6]);
183 	int nbands = *((int *) argv[7]);</b></font>
184 	return( im_extract_areabands( argv[0], argv[1],
185 		left, top, width, height, band, nbands ) );
186 }
187 static im_function extract_areabands_desc = {
188 	"im_extract_areabands",         	"extract area and bands",       	IM_FN_TRANSFORM | IM_FN_PIO,		extract_areabands_vec,          	IM_NUMBER( extract_areabands_args ),	extract_areabands_args          };
189 static im_arg_desc one_in_one_out[] = {
190 	IM_INPUT_IMAGE( "in" ),
191 	IM_OUTPUT_IMAGE( "out" )
192 };
193 static im_arg_desc two_in_one_out[] = {
194 	IM_INPUT_IMAGE( "in1" ),
195 	IM_INPUT_IMAGE( "in2" ),
196 	IM_OUTPUT_IMAGE( "out" )
197 };
198 <a name="3"></a>static int
199 bandjoin_vec( im_object *argv )
200 {
201 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_bandjoin( argv[0], argv[1], argv[2] ) );
202 }
203 static im_function bandjoin_desc = {
204 	"im_bandjoin", 				"bandwise join of two images",		IM_FN_PIO,				bandjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
205 static im_arg_desc gbandjoin_args[] = {
206 	IM_INPUT_IMAGEVEC( "in" ),
207 	IM_OUTPUT_IMAGE( "out" )
208 };
209 static int
210 gbandjoin_vec( im_object *argv )
211 {
212 	im_imagevec_object *iv = (im_imagevec_object *) argv[0];
213 	return( im_gbandjoin( iv-&gt;vec, argv[1], iv-&gt;n ) );
214 }
215 static im_function gbandjoin_desc = {
216 	"im_gbandjoin", 			"bandwise join of many images",		IM_FN_PIO,				gbandjoin_vec, 				IM_NUMBER( gbandjoin_args ), 		gbandjoin_args 			};
217 static im_arg_desc text_args[] = {
218 	IM_OUTPUT_IMAGE( "out" ),
219 	IM_INPUT_STRING( "text" ),
220 	IM_INPUT_STRING( "font" ),
221 	IM_INPUT_INT( "width" ),
222 	IM_INPUT_INT( "alignment" ),
223 	IM_INPUT_INT( "dpi" )
224 };
225 static int
226 text_vec( im_object *argv )
227 {</b></font>
228 	int width = *((int *) argv[3]);
229 	int alignment = *((int *) argv[4]);
230 	int dpi = *((int *) argv[5]);
231 	return( im_text( argv[0], argv[1], argv[2], width, alignment, dpi ) );
232 }
233 static im_function text_desc = {
234 	"im_text", 				"generate text image",			IM_FN_PIO,				text_vec, 				IM_NUMBER( text_args ), 		text_args 			};
235 static im_arg_desc black_args[] = {
236 	IM_OUTPUT_IMAGE( "output" ),
237 	IM_INPUT_INT( "x_size" ),
238 	IM_INPUT_INT( "y_size" ),
239 	IM_INPUT_INT( "bands" )
240 };
241 static int
242 black_vec( im_object *argv )
243 {
244 	int xs = *((int *) argv[1]);
245 	int ys = *((int *) argv[2]);
246 	int bands = *((int *) argv[3]);
247 	return( im_black( argv[0], xs, ys, bands ) );
248 }
249 static im_function black_desc = {
250 	"im_black", 				"generate black image",			IM_FN_PIO,				black_vec, 				IM_NUMBER( black_args ), 		black_args 			};
251 static im_arg_desc clip2fmt_args[] = {
252 	IM_INPUT_IMAGE( "in" ),
253 	IM_OUTPUT_IMAGE( "out" ),
254 	IM_INPUT_INT( "ofmt" )
255 };
256 static int
257 clip2fmt_vec( im_object *argv )
258 <a name="4"></a>{
259 	int ofmt = *((int *) argv[2]);
260 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_clip2fmt( argv[0], argv[1], ofmt ) );
261 }
262 static im_function clip2fmt_desc = {
263 	"im_clip2fmt", 				"convert image format to ofmt",		IM_FN_PIO | IM_FN_PTOP,			clip2fmt_vec, 				IM_NUMBER( clip2fmt_args ),		clip2fmt_args 			};
264 static int
265 c2rect_vec( im_object *argv )
266 {
267 	return( im_c2rect( argv[0], argv[1] ) );
268 }
269 static im_function c2rect_desc = {
270 	"im_c2rect", 				"convert phase and amplitude to real and imaginary",
271 	IM_FN_PTOP | IM_FN_PIO,			c2rect_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
272 static int
273 c2amph_vec( im_object *argv )
274 {
275 	return( im_c2amph( argv[0], argv[1] ) );
276 }
277 static im_function c2amph_desc = {
278 	"im_c2amph", 				"convert real and imaginary to phase and amplitude",
279 	IM_FN_PTOP | IM_FN_PIO,			c2amph_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
280 <a name="2"></a>static int
281 ri2c_vec( im_object *argv )
282 {</b></font>
283 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_ri2c( argv[0], argv[1], argv[2] ) );
284 }
285 static im_function ri2c_desc = {
286 	"im_ri2c", 				"join two non-complex images to form complex",
287 	IM_FN_PTOP | IM_FN_PIO,			ri2c_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
288 static int
289 c2imag_vec( im_object *argv )
290 {
291 	return( im_c2imag( argv[0], argv[1] ) );
292 }
293 static im_function c2imag_desc = {
294 	"im_c2imag", 				"extract imaginary part of complex image",
295 	IM_FN_PTOP | IM_FN_PIO,			c2imag_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
296 static int
297 c2real_vec( im_object *argv )
298 {
299 	return( im_c2real( argv[0], argv[1] ) );
300 }
301 static im_function c2real_desc = {
302 	"im_c2real", 				"extract real part of complex image",
303 	IM_FN_PTOP | IM_FN_PIO,			c2real_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
304 static im_arg_desc copy_set_args[] = {
305 	IM_INPUT_IMAGE( "input" ),
306 	IM_OUTPUT_IMAGE( "output" ),
307 	IM_INPUT_INT( "Type" ),
308 	IM_INPUT_DOUBLE( "Xres" ),
309 	IM_INPUT_DOUBLE( "Yres" ),
310 	IM_INPUT_INT( "Xoffset" ),
311 	IM_INPUT_INT( "Yoffset" )
312 };
313 static int
314 copy_set_vec( im_object *argv )
315 {</b></font>
316 	int Type = *((int *) argv[2]);
317 	float Xres = *((double *) argv[3]);
318 	float Yres = *((double *) argv[4]);
319 	int Xoffset = *((int *) argv[5]);
320 	int Yoffset = *((int *) argv[6]);
321 	return( im_copy_set( argv[0], argv[1],
322 		Type, Xres, Yres, Xoffset, Yoffset ) );
323 }
324 static im_function copy_set_desc = {
325 	"im_copy_set", 				"copy image, setting informational fields",
326 	IM_FN_PIO,			
327 	copy_set_vec, 				IM_NUMBER( copy_set_args ), 		copy_set_args 			};
328 static im_arg_desc copy_set_meta_args[] = {
329 	IM_INPUT_IMAGE( "input" ),
330 	IM_OUTPUT_IMAGE( "output" ),
331 	IM_INPUT_STRING( "field" ),
332 	IM_INPUT_GVALUE( "value" )
333 };
334 static int
335 <a name="14"></a>copy_set_meta_vec( im_object *argv )
336 {
337 	const char *field = argv[2];
338 <font color="#842dce"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	GValue *value = argv[3];
339 	return( im_copy_set_meta( argv[0], argv[1], field, value ) ); 
340 }
341 static im_function copy_set_meta_desc = {
342 	"im_copy_set_meta", 			"copy image, setting a meta field",
343 	IM_FN_PIO,			
344 	copy_set_meta_vec, 			IM_NUMBER( copy_set_meta_args ),	copy_set_meta_args 		};
345 static im_arg_desc copy_morph_args[] = {
346 	IM_INPUT_IMAGE( "input" ),
347 	IM_OUTPUT_IMAGE( "output" ),
348 	IM_INPUT_INT( "Bands" ),
349 	IM_INPUT_INT( "BandFmt" ),
350 	IM_INPUT_INT( "Coding" )
351 };
352 static int
353 copy_morph_vec( im_object *argv )
354 {</b></font>
355 	int Bands = *((int *) argv[2]);
356 	int BandFmt = *((int *) argv[3]);
357 	int Coding = *((int *) argv[4]);
358 	return( im_copy_morph( argv[0], argv[1],
359 		Bands, BandFmt, Coding ) );
360 }
361 static im_function copy_morph_desc = {
362 	"im_copy_morph", 				"copy image, setting pixel layout",
363 	IM_FN_PIO,			
364 	copy_morph_vec, 			IM_NUMBER( copy_morph_args ), 		copy_morph_args 		};
365 <a name="1"></a>
366 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>static int
367 copy_vec( im_object *argv )
368 {
369 	return( im_copy( argv[0], argv[1] ) );
370 }
371 static im_function copy_desc = {
372 	"im_copy", 				"copy image",
373 	IM_FN_PIO | IM_FN_NOCACHE,
374 	copy_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
375 static int
376 copy_file_vec( im_object *argv )
377 {
378 	return( im_copy_file( argv[0], argv[1] ) );
379 }
380 static im_function copy_file_desc = {
381 	"im_copy_file", 				"copy image to a file and return that",
382 	IM_FN_PIO,			
383 	copy_file_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
384 static int
385 copy_swap_vec( im_object *argv )
386 {
387 	return( im_copy_swap( argv[0], argv[1] ) );
388 }
389 static im_function copy_swap_desc = {
390 	"im_copy_swap", 				"copy image, swapping byte order",
391 	IM_FN_PIO,			
392 	copy_swap_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
393 static int
394 fliphor_vec( im_object *argv )
395 {
396 	return( im_fliphor( argv[0], argv[1] ) );
397 }
398 static im_function fliphor_desc = {
399 	"im_fliphor", 				"flip image left-right",
400 	IM_FN_PIO,				fliphor_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
401 static int
402 flipver_vec( im_object *argv )
403 {
404 	return( im_flipver( argv[0], argv[1] ) );
405 }
406 static im_function flipver_desc = {
407 	"im_flipver", 				"flip image top-bottom",
408 	IM_FN_PIO,				flipver_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
409 static int
410 falsecolour_vec( im_object *argv )
411 {
412 	return( im_falsecolour( argv[0], argv[1] ) );
413 }
414 static im_function falsecolour_desc = {
415 	"im_falsecolour", 			"turn luminance changes into chrominance changes",
416 	IM_FN_PTOP | IM_FN_PIO,			falsecolour_vec, 			IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
417 static im_arg_desc insert_args[] = {</b></font>
418 	IM_INPUT_IMAGE( "in" ),
419 	IM_INPUT_IMAGE( "sub" ),
420 	IM_OUTPUT_IMAGE( "out" ),
421 	IM_INPUT_INT( "x" ),
422 	IM_INPUT_INT( "y" )
423 };
424 static int
425 insert_vec( im_object *argv )
426 {
427 <a name="6"></a>	int x = *((int *) argv[3]);
428 	int y = *((int *) argv[4]);
429 <font color="#8c8774"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_insert( argv[0], argv[1], argv[2], x, y ) );
430 }
431 static im_function insert_desc = {
432 	"im_insert", 				"insert sub-image into main image at position",
433 	IM_FN_PIO | IM_FN_TRANSFORM,		insert_vec, 				IM_NUMBER( insert_args ), 		insert_args 			};
434 static im_arg_desc insertset_args[] = {
435 	IM_INPUT_IMAGE( "main" ),
436 	IM_INPUT_IMAGE( "sub" ),
437 	IM_OUTPUT_IMAGE( "out" ),
438 	IM_INPUT_INTVEC( "x" ),
439 	IM_INPUT_INTVEC( "y" )
440 };
441 static int
442 insertset_vec( im_object *argv )
443 {
444 	im_intvec_object *xv = (im_intvec_object *) argv[3];
445 	im_intvec_object *yv = (im_intvec_object *) argv[4];
446 	if( xv-&gt;n != yv-&gt;n ) {
447 		im_error( "im_insertset", "%s", 
448 			_( "vectors not same length" ) );
449 <a name="12"></a>		return( -1 );
450 	}</b></font>
451 <font color="#571b7e"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( im_insertset( argv[0], argv[1], argv[2], xv-&gt;n, xv-&gt;vec, yv-&gt;vec ) )
452 		return( -1 );
453 	return( 0 );
454 }
455 static im_function insertset_desc = {
456 	"im_insertset", 			"insert sub into main at every position in x, y",
457 	0,					insertset_vec, 				IM_NUMBER( insertset_args ), 		insertset_args 			};
458 static int
459 insert_noexpand_vec( im_object *argv )
460 {
461 <a name="0"></a>	int x = *((int *) argv[3]);</b></font>
462 	int y = *((int *) argv[4]);
463 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_insert_noexpand( argv[0], argv[1], argv[2], x, y ) );
464 }
465 static im_function insert_noexpand_desc = {
466 	"im_insert_noexpand", 			"insert sub-image into main image at position, no expansion",
467 	IM_FN_PIO | IM_FN_TRANSFORM,		insert_noexpand_vec, 			IM_NUMBER( insert_args ),		insert_args 			};
468 static int
469 rot180_vec( im_object *argv )
470 {
471 	return( im_rot180( argv[0], argv[1] ) );
472 }
473 static im_function rot180_desc = {
474 	"im_rot180", 				"rotate image 180 degrees",
475 	IM_FN_PIO | IM_FN_TRANSFORM,		rot180_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
476 static int
477 rot90_vec( im_object *argv )
478 {
479 	return( im_rot90( argv[0], argv[1] ) );
480 }
481 static im_function rot90_desc = {
482 	"im_rot90", 				"rotate image 90 degrees clockwise",
483 	IM_FN_PIO | IM_FN_TRANSFORM,		rot90_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
484 static int
485 rot270_vec( im_object *argv )
486 {
487 	return( im_rot270( argv[0], argv[1] ) );
488 }
489 static im_function rot270_desc = {
490 	"im_rot270", 				"rotate image 270 degrees clockwise",
491 	IM_FN_PIO | IM_FN_TRANSFORM,		rot270_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
492 static int
493 lrjoin_vec( im_object *argv )
494 {
495 	return( im_lrjoin( argv[0], argv[1], argv[2] ) );
496 }
497 static im_function lrjoin_desc = {
498 	"im_lrjoin", 				"join two images left-right",
499 	IM_FN_PIO | IM_FN_TRANSFORM,		lrjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
500 static int
501 tbjoin_vec( im_object *argv )
502 {
503 	return( im_tbjoin( argv[0], argv[1], argv[2] ) );
504 }
505 static im_function tbjoin_desc = {
506 	"im_tbjoin", 				"join two images top-bottom",
507 	IM_FN_PIO | IM_FN_TRANSFORM,		tbjoin_vec, 				IM_NUMBER( two_in_one_out ), 		two_in_one_out 			};
508 static int
509 scale_vec( im_object *argv )
510 {
511 	return( im_scale( argv[0], argv[1] ) );
512 }
513 static im_function scale_desc = {
514 	"im_scale", 				"scale image linearly to fit range 0-255",
515 	IM_FN_PIO,				scale_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
516 static int
517 scaleps_vec( im_object *argv )
518 {
519 	return( im_scaleps( argv[0], argv[1] ) );
520 }
521 static im_function scaleps_desc = {
522 	"im_scaleps", 				"logarithmic scale of image to fit range 0-255",
523 	0,					scaleps_vec, 				IM_NUMBER( one_in_one_out ), 		one_in_one_out 			};
524 static im_arg_desc grid_args[] = {</b></font>
525 	IM_INPUT_IMAGE( "input" ),
526 	IM_OUTPUT_IMAGE( "output" ),
527 	IM_INPUT_INT( "tile_height" ),
528 	IM_INPUT_INT( "across" ),
529 	IM_INPUT_INT( "down" )
530 };
531 static int
532 grid_vec( im_object *argv )
533 {
534 	int tile_height = *((int *) argv[2]);
535 	int across = *((int *) argv[3]);
536 	int down = *((int *) argv[4]);
537 	return( im_grid( argv[0], argv[1], tile_height, across, down ) );
538 }
539 static im_function grid_desc = {
540 	"im_grid", 				"chop a tall thin image into a grid of images",
541 	IM_FN_TRANSFORM | IM_FN_PIO,		grid_vec, 				IM_NUMBER( grid_args ), 		grid_args 			};
542 static im_arg_desc replicate_args[] = {
543 	IM_INPUT_IMAGE( "input" ),
544 	IM_OUTPUT_IMAGE( "output" ),
545 	IM_INPUT_INT( "across" ),
546 	IM_INPUT_INT( "down" )
547 };
548 static int
549 replicate_vec( im_object *argv )
550 {
551 	int across = *((int *) argv[2]);
552 	int down = *((int *) argv[3]);
553 	return( im_replicate( argv[0], argv[1], across, down ) );
554 }
555 static im_function replicate_desc = {
556 	"im_replicate", 			"replicate an image horizontally and vertically",
557 	IM_FN_TRANSFORM | IM_FN_PIO,		replicate_vec, 				IM_NUMBER( replicate_args ), 		replicate_args 			};
558 static im_arg_desc zoom_args[] = {
559 	IM_INPUT_IMAGE( "input" ),
560 	IM_OUTPUT_IMAGE( "output" ),
561 	IM_INPUT_INT( "xfac" ),
562 	IM_INPUT_INT( "yfac" )
563 };
564 static int
565 zoom_vec( im_object *argv )
566 {
567 <a name="5"></a>	int xfac = *((int *) argv[2]);
568 	int yfac = *((int *) argv[3]);
569 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_zoom( argv[0], argv[1], xfac, yfac ) );
570 }
571 static im_function zoom_desc = {
572 	"im_zoom", 				"simple zoom of an image by integer factors",
573 	IM_FN_TRANSFORM | IM_FN_PIO,		zoom_vec, 				IM_NUMBER( zoom_args ),			zoom_args 			};
574 static int
575 msb_vec (im_object * argv)
576 {
577   return im_msb (argv[0], argv[1]);
578 }
579 static im_function msb_desc = {
580   "im_msb",			  "convert to uchar by discarding bits",
581   IM_FN_PIO | IM_FN_PTOP,	  msb_vec,			  IM_NUMBER (one_in_one_out),	  one_in_one_out		};
582 static im_arg_desc msb_band_args[] = {
583   IM_INPUT_IMAGE ("in"),
584   IM_OUTPUT_IMAGE ("out"),
585   IM_INPUT_INT ("band")
586 };
587 static int
588 msb_band_vec (im_object * argv)
589 <a name="8"></a>{
590   IMAGE *in = (IMAGE *) argv[0];
591   IMAGE *out = (IMAGE *) argv[1];</b></font>
592 <font color="#c58917"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  int *band = (int *) argv[2];
593   return im_msb_band (in, out, *band);
594 }
595 static im_function msb_band_desc = {
596   "im_msb_band",		  "convert to single band uchar by discarding bits",
597   IM_FN_PIO | IM_FN_PTOP,	  msb_band_vec,			  IM_NUMBER (msb_band_args),	  msb_band_args			};
598 static im_arg_desc wrap_args[] = {
599 	IM_INPUT_IMAGE( "in" ),
600 	IM_OUTPUT_IMAGE( "out" ),
601 	IM_INPUT_INT( "x" ),
602 	IM_INPUT_INT( "y" )
603 };
604 static int
605 wrap_vec (im_object * argv)
606 {
607   return im_wrap( argv[0], argv[1], *(int*)argv[2], *(int*)argv[3] );</b></font>
608 }
609 static im_function wrap_desc = {
610   "im_wrap",			  "shift image origin, wrapping at sides",
611   IM_FN_PIO | IM_FN_TRANSFORM,	  wrap_vec,			  IM_NUMBER (wrap_args),	  wrap_args			};
612 static im_arg_desc embed_args[] = {
613 	IM_INPUT_IMAGE( "in" ),
614 	IM_OUTPUT_IMAGE( "out" ),
615 	IM_INPUT_INT( "type" ),
616 	IM_INPUT_INT( "x" ),
617 	IM_INPUT_INT( "y" ),
618 	IM_INPUT_INT( "width" ),
619 	IM_INPUT_INT( "height" )
620 };
621 static int
622 embed_vec( im_object *argv )
623 {
624 	int type = *((int *) argv[2]);
625 	int x = *((int *) argv[3]);
626 	int y = *((int *) argv[4]);
627 <a name="15"></a>	int width = *((int *) argv[5]);
628 	int height = *((int *) argv[6]);
629 <font color="#f52887"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	return( im_embed( argv[0], argv[1], type, x, y, width, height ) );
630 }
631 static im_function embed_desc = {
632 	"im_embed",	 			"embed in within a set of borders", 
633 	IM_FN_PIO | IM_FN_TRANSFORM,		embed_vec, 				IM_NUMBER( embed_args ), 		embed_args 			};
634 static im_function *conv_list[] = {
635 	&amp;gaussnoise_desc,
636 	&amp;bandjoin_desc,
637 	&amp;black_desc,
638 	&amp;c2amph_desc,
639 	&amp;c2imag_desc,
640 	&amp;c2real_desc,
641 	&amp;c2rect_desc,
642 	&amp;clip2fmt_desc,
643 	&amp;copy_desc,
644 	&amp;copy_file_desc,
645 	&amp;copy_morph_desc,
646 	&amp;copy_swap_desc,
647 	&amp;copy_set_desc,
648 	&amp;copy_set_meta_desc,
649 	&amp;extract_area_desc,
650 	&amp;extract_areabands_desc,
651 	&amp;extract_band_desc,
652 	&amp;extract_bands_desc,
653 	&amp;extract_desc,
654 	&amp;falsecolour_desc,
655 	&amp;fliphor_desc,
656 	&amp;flipver_desc,
657 	&amp;gbandjoin_desc,
658 	&amp;grid_desc,
659 	&amp;insert_desc,
660 	&amp;insertset_desc,
661 	&amp;insert_noexpand_desc,
662 	&amp;embed_desc,
663 	&amp;lrjoin_desc,
664         &amp;msb_desc,
665         &amp;msb_band_desc,
666 	&amp;replicate_desc,
667 	&amp;ri2c_desc,
668 	&amp;rot180_desc,
669 	&amp;rot270_desc,
670 	&amp;rot90_desc,
671 	&amp;scale_desc,
672 	&amp;scaleps_desc,
673 	&amp;subsample_desc,
674 	&amp;system_desc,
675 	&amp;system_image_desc,
676 	&amp;tbjoin_desc,
677 	&amp;text_desc,
678 	&amp;wrap_desc,
679 	&amp;zoom_desc
680 };
681 im_package im__conversion = {
682 	"conversion",
683 	IM_NUMBER( conv_list ),
684 	conv_list
685 };</b></font>
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
