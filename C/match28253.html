<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tbmerge.c &amp; global_balance.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tbmerge.c &amp; global_balance.c
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tbmerge.c (4.123711%)<th>global_balance.c (1.3104013%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(258-282)<td><a href="#" name="0">(494-513)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tbmerge.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/thread.h&gt;
#include &lt;vips/transform.h&gt;
#include &lt;vips/internal.h&gt;
#include "pmosaicing.h"
static int
find_top( VipsRegion *ir, int *pos, int x, int y, int h )
{
	VipsPel *pr = VIPS_REGION_ADDR( ir, x, y );
	VipsImage *im = ir-&gt;im;
	int ls = VIPS_REGION_LSKIP( ir ) / VIPS_IMAGE_SIZEOF_ELEMENT( im );
	int b = im-&gt;Bands;
	int i, j;
	if( vips_band_format_iscomplex( im-&gt;BandFmt ) )
		b *= 2;
#define tsearch( TYPE ) { \
	TYPE *p = (TYPE *) pr; \
	\
	for( i = 0; i &lt; h; i++ ) { \
		for( j = 0; j &lt; b; j++ ) \
			if( p[j] ) \
				break; \
		if( j &lt; b ) \
			break; \
		\
		p += ls; \
	} \
}
	switch( im-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR:	tsearch( unsigned char ); break; 
	case VIPS_FORMAT_CHAR:	tsearch( signed char ); break; 
	case VIPS_FORMAT_USHORT:	tsearch( unsigned short ); break; 
	case VIPS_FORMAT_SHORT:	tsearch( signed short ); break; 
	case VIPS_FORMAT_UINT:	tsearch( unsigned int ); break; 
	case VIPS_FORMAT_INT:	tsearch( signed int );  break; 
	case VIPS_FORMAT_FLOAT:	tsearch( float ); break; 
	case VIPS_FORMAT_DOUBLE:	tsearch( double ); break; 
	case VIPS_FORMAT_COMPLEX:	tsearch( float ); break; 
	case VIPS_FORMAT_DPCOMPLEX:	tsearch( double ); break;
	default:
		vips_error( "vips_tbmerge", "%s", _( "internal error" ) );
		return( -1 );
	}
	*pos = y + i;
	return( 0 );
}
static int
find_bot( VipsRegion *ir, int *pos, int x, int y, int h )
{
	VipsPel *pr = VIPS_REGION_ADDR( ir, x, y );
	VipsImage *im = ir-&gt;im;
	int ls = VIPS_REGION_LSKIP( ir ) / VIPS_IMAGE_SIZEOF_ELEMENT( ir-&gt;im );
	int b = im-&gt;Bands;
	int i, j;
	if( vips_band_format_iscomplex( im-&gt;BandFmt ) )
		b *= 2;
#define rsearch( TYPE ) { \
	TYPE *p = (TYPE *) pr + (h - 1) * ls; \
	\
	for( i = h - 1; i &gt;= 0; i-- ) { \
		for( j = 0; j &lt; b; j++ ) \
			if( p[j] ) \
				break; \
		if( j &lt; b ) \
			break; \
		\
		p -= ls; \
	} \
}
	switch( im-&gt;BandFmt ) {
	case VIPS_FORMAT_UCHAR:	rsearch( unsigned char ); break;
	case VIPS_FORMAT_CHAR:	rsearch( signed char ); break;
	case VIPS_FORMAT_USHORT:	rsearch( unsigned short ); break;
	case VIPS_FORMAT_SHORT:	rsearch( signed short ); break;
	case VIPS_FORMAT_UINT:	rsearch( unsigned int ); break;
	case VIPS_FORMAT_INT:	rsearch( signed int );  break;
	case VIPS_FORMAT_FLOAT:	rsearch( float ); break;
	case VIPS_FORMAT_DOUBLE:	rsearch( double ); break;
	case VIPS_FORMAT_COMPLEX:	rsearch( float ); break;
	case VIPS_FORMAT_DPCOMPLEX:	rsearch( double ); break;
	default:
		vips_error( "vips_tbmerge", "%s", _( "internal error" ) );
		return( -1 );
	}
	*pos = y + i;
	return( 0 );
}
static int
make_firstlast( MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsRect rr, sr;
	int x;
	int missing;
	g_mutex_lock( ovlap-&gt;fl_lock );
	missing = 0;
	for( x = oreg-&gt;left; x &lt; VIPS_RECT_RIGHT( oreg ); x++ ) {
		const int j = x - ovlap-&gt;overlap.left;
		const int first = ovlap-&gt;first[j];
		if( first &lt; 0 ) {
			missing = 1;
<a name="0"></a>			break;
		}
	}
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( !missing ) {
		g_mutex_unlock( ovlap-&gt;fl_lock );
		return( 0 );
	}
	rr.left = oreg-&gt;left;
	rr.top = ovlap-&gt;overlap.top;
	rr.width = oreg-&gt;width;
	rr.height = ovlap-&gt;overlap.height;
	rr.left -= ovlap-&gt;rarea.left;
	rr.top -= ovlap-&gt;rarea.top;
	sr.left = oreg-&gt;left;
	sr.top = ovlap-&gt;overlap.top;
	sr.width = oreg-&gt;width;
	sr.height = ovlap-&gt;overlap.height;
	sr.left -= ovlap-&gt;sarea.left;
	sr.top -= ovlap-&gt;sarea.top;</b></font>
	if( vips_region_prepare( rir, &amp;rr ) || 
		vips_region_prepare( sir, &amp;sr ) ) {
		g_mutex_unlock( ovlap-&gt;fl_lock );
		return( -1 );
	}
	for( x = 0; x &lt; oreg-&gt;width; x++ ) {
		const int j = (x + oreg-&gt;left) - ovlap-&gt;overlap.left;
		int *first = &amp;ovlap-&gt;first[j];
		int *last = &amp;ovlap-&gt;last[j];
		if( *first &lt; 0 ) {
			if( find_top( sir, first, 
				x + sr.left, sr.top, sr.height ) ||
				find_bot( rir, last, 
					x + rr.left, rr.top, rr.height ) ) {
				g_mutex_unlock( ovlap-&gt;fl_lock );
				return( -1 );
			}
			*first += ovlap-&gt;sarea.top;
			*last += ovlap-&gt;rarea.top;
			if( ovlap-&gt;mwidth &gt;= 0 &amp;&amp; 
				*last - *first &gt; ovlap-&gt;mwidth ) {
				int shrinkby = (*last - *first) - ovlap-&gt;mwidth;
				*first += shrinkby / 2;
				*last -= shrinkby / 2;
			}
		}
	}
	g_mutex_unlock( ovlap-&gt;fl_lock );
	return( 0 );
}
#define TEST_ZERO( TYPE, T, RESULT ) { \
	TYPE *tt = (T); \
	int ii; \
	\
	for( ii = 0; ii &lt; cb; ii++ ) \
		if( tt[i + ii] ) \
			break; \
	if( ii == cb )  \
		(RESULT) = 1; \
}
#define iblend( TYPE, B, IN1, IN2, OUT ) { \
	TYPE *tr = (TYPE *) (IN1); \
	TYPE *ts = (TYPE *) (IN2); \
	TYPE *tq = (TYPE *) (OUT); \
	const int cb = (B); \
	int ref_zero; \
	int sec_zero; \
	int x, b; \
	int i; \
	\
	for( i = 0, x = 0; x &lt; oreg-&gt;width; x++ ) { \
		ref_zero = 0; \
		sec_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		\
		if( y &lt; first[x] ) { \
			if( !ref_zero ) \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = tr[i]; \
			else \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = ts[i]; \
		} \
		else if( y &gt;= last[x] ) { \
			if( !sec_zero ) \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = ts[i]; \
			else \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = tr[i]; \
		} \
		else { \
			if( !ref_zero &amp;&amp; !sec_zero ) { \
				const int bheight = last[x] - first[x]; \
				const int inx = ((y - first[x]) &lt;&lt; \
					BLEND_SHIFT) / bheight; \
				int c1 = vips__icoef1[inx];  \
				int c2 = vips__icoef2[inx];  \
				\
				for( b = 0; b &lt; cb; b++, i++ ) \
					tq[i] = c1 * tr[i] / BLEND_SCALE + \
						c2 * ts[i] / BLEND_SCALE; \
			} \
			else if( !ref_zero ) \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = tr[i]; \
			else \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = ts[i]; \
		}  \
	} \
}
#define fblend( TYPE, B, IN1, IN2, OUT ) { \
	TYPE *tr = (TYPE *) (IN1); \
	TYPE *ts = (TYPE *) (IN2); \
	TYPE *tq = (TYPE *) (OUT); \
	int ref_zero; \
	int sec_zero; \
	const int cb = (B); \
	int x, b; \
	int i; \
	\
	for( i = 0, x = 0; x &lt; oreg-&gt;width; x++ ) { \
		ref_zero = 0; \
		sec_zero = 0; \
		TEST_ZERO( TYPE, tr, ref_zero ); \
		TEST_ZERO( TYPE, ts, sec_zero ); \
		\
		if( y &lt; first[x] )  \
			if( !ref_zero ) \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = tr[i]; \
			else \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = tr[i]; \
		else if( y &gt;= last[x] )  \
			if( !sec_zero ) \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = ts[i]; \
			else \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = tr[i]; \
		else { \
			if( !ref_zero &amp;&amp; !sec_zero ) { \
				const int bheight = last[x] - first[x]; \
				const int inx = ((y - first[x]) &lt;&lt; \
					BLEND_SHIFT) / bheight; \
				double c1 = vips__coef1[inx];  \
				double c2 = vips__coef2[inx];  \
				\
				for( b = 0; b &lt; cb; b++, i++ ) \
					tq[i] = c1 * tr[i] + c2 * ts[i]; \
			} \
			else if( !ref_zero ) \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = tr[i]; \
			else \
				for( b = 0; b &lt; cb; b++, i++ )  \
					tq[i] = ts[i]; \
		}  \
	} \
}
static int
tb_blend( VipsRegion *or, MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsImage *im = or-&gt;im;
	VipsRect prr, psr;
	int y, yr, ys;
	if( make_firstlast( inf, ovlap, oreg ) )
		return( -1 );
	prr = *oreg;
	prr.left -= ovlap-&gt;rarea.left;
	prr.top -= ovlap-&gt;rarea.top;
	psr = *oreg;
	psr.left -= ovlap-&gt;sarea.left;
	psr.top -= ovlap-&gt;sarea.top;
	if( vips_region_prepare( rir, &amp;prr ) ||
		vips_region_prepare( sir, &amp;psr ) )
		return( -1 );
	for( y = oreg-&gt;top, yr = prr.top, ys = psr.top; 
		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) { 
		VipsPel *pr = VIPS_REGION_ADDR( rir, prr.left, yr );
		VipsPel *ps = VIPS_REGION_ADDR( sir, psr.left, ys );
		VipsPel *q = VIPS_REGION_ADDR( or, oreg-&gt;left, y );
		const int j = oreg-&gt;left - ovlap-&gt;overlap.left;
		const int *first = ovlap-&gt;first + j;
		const int *last = ovlap-&gt;last + j;
		switch( im-&gt;BandFmt ) {
		case VIPS_FORMAT_UCHAR: 	
			iblend( unsigned char, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_CHAR: 	
			iblend( signed char, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_USHORT: 
			iblend( unsigned short, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_SHORT: 	
			iblend( signed short, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_UINT: 	
			iblend( unsigned int, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_INT: 	
			iblend( signed int, im-&gt;Bands, pr, ps, q );  break; 
		case VIPS_FORMAT_FLOAT: 	
			fblend( float, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_DOUBLE:	
			fblend( double, im-&gt;Bands, pr, ps, q ); break; 
		case VIPS_FORMAT_COMPLEX:
			fblend( float, im-&gt;Bands * 2, pr, ps, q ); break; 
		case VIPS_FORMAT_DPCOMPLEX:
			fblend( double, im-&gt;Bands * 2, pr, ps, q ); break;
		default:
			vips_error( "vips_tbmerge", "%s", _( "internal error" ) );
			return( -1 );
		}
	}
	return( 0 );
}
static int
tb_blend_labpack( VipsRegion *or, MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
{
	VipsRegion *rir = inf-&gt;rir;
	VipsRegion *sir = inf-&gt;sir;
	VipsRect prr, psr;
	int y, yr, ys;
	if( make_firstlast( inf, ovlap, oreg ) )
		return( -1 );
	prr = *oreg;
	prr.left -= ovlap-&gt;rarea.left;
	prr.top -= ovlap-&gt;rarea.top;
	psr = *oreg;
	psr.left -= ovlap-&gt;sarea.left;
	psr.top -= ovlap-&gt;sarea.top;
	if( vips_region_prepare( rir, &amp;prr ) || 
		vips_region_prepare( sir, &amp;psr ) )
		return( -1 );
	for( y = oreg-&gt;top, yr = prr.top, ys = psr.top; 
		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) { 
		VipsPel *pr = VIPS_REGION_ADDR( rir, prr.left, yr );
		VipsPel *ps = VIPS_REGION_ADDR( sir, psr.left, ys );
		VipsPel *q = VIPS_REGION_ADDR( or, oreg-&gt;left, y );
		const int j = oreg-&gt;left - ovlap-&gt;overlap.left;
		const int *first = ovlap-&gt;first + j;
		const int *last = ovlap-&gt;last + j;
		float *fq = inf-&gt;merge;
		float *r = inf-&gt;from1;
		float *s = inf-&gt;from2;
		vips__LabQ2Lab_vec( r, pr, oreg-&gt;width );
		vips__LabQ2Lab_vec( s, ps, oreg-&gt;width );
		fblend( float, 3, r, s, fq ); 
		vips__Lab2LabQ_vec( q, inf-&gt;merge, oreg-&gt;width );
	}
	return( 0 );
}
static Overlapping *
build_tbstate( VipsImage *ref, VipsImage *sec, VipsImage *out, int dx, int dy, int mwidth )
{
   	Overlapping *ovlap;
	if( !(ovlap = vips__build_mergestate( "vips_tbmerge", 
		ref, sec, out, dx, dy, mwidth )) )
		return( NULL );
	switch( ovlap-&gt;ref-&gt;Coding ) {
	case VIPS_CODING_LABQ:
		ovlap-&gt;blend = tb_blend_labpack;
		break;
	case VIPS_CODING_NONE:
		ovlap-&gt;blend = tb_blend;
		break;
	default:
		vips_error( "vips_tbmerge", "%s", _( "unknown coding type" ) );
		return( NULL );
	}
	ovlap-&gt;rpart = ovlap-&gt;rarea;
	ovlap-&gt;spart = ovlap-&gt;sarea;
	ovlap-&gt;rpart.height -= ovlap-&gt;overlap.height;
	ovlap-&gt;spart.top += ovlap-&gt;overlap.height;
	ovlap-&gt;spart.height -= ovlap-&gt;overlap.height;
	if( VIPS_RECT_BOTTOM( &amp;ovlap-&gt;rarea ) &gt; VIPS_RECT_BOTTOM( &amp;ovlap-&gt;sarea ) ||
		ovlap-&gt;rarea.top &gt; ovlap-&gt;sarea.top ) {
		vips_error( "vips_tbmerge", "%s", _( "too much overlap" ) );
		return( NULL );
	}
	ovlap-&gt;blsize = ovlap-&gt;overlap.width;
	return( ovlap );
}
int
vips__tbmerge( VipsImage *ref, VipsImage *sec, VipsImage *out, 
	int dx, int dy, int mwidth )
{  
	Overlapping *ovlap;
	if( dy &gt; 0 || dy &lt; 1 - ref-&gt;Ysize ) {
		VipsImage *x;
#ifdef DEBUG
		printf( "vips__tbmerge: no overlap, using insert\n" ); 
#endif
  		if( vips_insert( ref, sec, &amp;x, -dx, -dy,
			"expand", TRUE,
			NULL ) )
			return( -1 );
		if( vips_image_write( x, out ) ) {
			g_object_unref( x );
			return( -1 );
		}
		g_object_unref( x );
		out-&gt;Xoffset = -dx;
		out-&gt;Yoffset = -dy;
		return( 0 );
	}
	if( !(ovlap = build_tbstate( ref, sec, out, dx, dy, mwidth )) )
		return( -1 );
	if( vips_image_pipelinev( out,
		VIPS_DEMAND_STYLE_THINSTRIP, ovlap-&gt;ref, ovlap-&gt;sec, NULL ) )
		return( -1 );
	out-&gt;Xsize = ovlap-&gt;oarea.width;
	out-&gt;Ysize = ovlap-&gt;oarea.height;
	out-&gt;Xoffset = -dx;
	out-&gt;Yoffset = -dy;
	if( vips_image_generate( out,
		vips__start_merge, vips__merge_gen, vips__stop_merge, ovlap, NULL ) )
		return( -1 );
	return ( 0 );
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>global_balance.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifdef HAVE_CONFIG_H
#include &lt;config.h&gt;
#include &lt;vips/intl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;math.h&gt;
#include &lt;vips/vips.h&gt;
#include &lt;vips/transform.h&gt;
#include &lt;vips/internal.h&gt;
#include "pmosaicing.h"
#include "global_balance.h"
#define MAX_ITEMS (50)
#define TRIVIAL (20 * 20)
static int
break_items( char *line, char **out )
{
	int i;
	char *p;
	for( i = 0; i &lt; MAX_ITEMS; i++ ) {
		if( !(p = strchr( line, '&lt;' )) )
			break;
		out[i] = line = p + 1;
		if( !(p = strchr( line, '&gt;' )) ) {
			vips_error( "break_files", "%s", _( "no matching '&gt;'" ) );
			return( -1 );
		}
		*p = '\0';
		line = p + 1;
	}
	if( i == MAX_ITEMS ) {
		vips_error( "break_files", "%s", _( "too many items" ) );
		return( -1 );
	}
	return( i );
}
VipsImage *
vips__global_open_image( SymbolTable *st, char *name )
{
	char *basename;
	VipsImage *image;
	if( !(image = vips_image_new_from_file( name, NULL ))) {
		basename = g_path_get_basename( name );
		if( !(image = vips_image_new_from_file( basename, NULL ))) {
			g_free( basename );
			return( NULL );
		}
		g_free( basename );
	}
	vips_object_local( st-&gt;im, image );
	return( image );
}
static void
junk_node( VipsImage *image, JoinNode *node )
{
	VIPS_FREEF( g_slist_free, node-&gt;overlaps );
}
static int
hash( char *n )
{
	int i;
	int r = 0;
	int l = strlen( n );
	for( i = 0; i &lt; l; i++ )
		r = ((r + n[i]) * 43) &amp; 0xffffff;
	return( r % SYM_TAB_SIZE );
}
static JoinNode *
build_node( SymbolTable *st, char *name )
{
	JoinNode *node = VIPS_NEW( st-&gt;im, JoinNode );
	int n = hash( name );
	if( !node || !(node-&gt;name = 
		vips_strdup( VIPS_OBJECT( st-&gt;im ), name )) )
		return( NULL );
	node-&gt;type = JOIN_LEAF;
	node-&gt;dirty = 0;
	node-&gt;mwidth = -2;
	node-&gt;st = st;
	vips__transform_init( &amp;node-&gt;cumtrn );
	node-&gt;trnim = NULL;
	node-&gt;arg1 = NULL;
	node-&gt;arg2 = NULL;
	node-&gt;overlaps = NULL;
	node-&gt;im = NULL;
	node-&gt;index = 0;
	g_signal_connect( st-&gt;im, "close",
		G_CALLBACK( junk_node ), node );
	if( (node-&gt;im = vips__global_open_image( st, name )) ) {
		node-&gt;cumtrn.oarea.width = node-&gt;im-&gt;Xsize;
		node-&gt;cumtrn.oarea.height = node-&gt;im-&gt;Ysize;
	}
	else {
		vips_error_clear();
	}
	st-&gt;table[n] = g_slist_prepend( st-&gt;table[n], node );
	return( node );
}
static OverlapInfo *
build_overlap( JoinNode *node, JoinNode *other, VipsRect *overlap )
{
	OverlapInfo *lap = VIPS_NEW( node-&gt;st-&gt;im, OverlapInfo );
	if( !lap )
		return( NULL );
	lap-&gt;node = node;
	lap-&gt;other = other;
	lap-&gt;overlap = *overlap;
	lap-&gt;nstats = NULL;
	lap-&gt;ostats = NULL;
	node-&gt;overlaps = g_slist_prepend( node-&gt;overlaps, lap );
	node-&gt;st-&gt;novl++;
	return( lap );
}
static void
overlap_destroy( OverlapInfo *lap )
{
	JoinNode *node = lap-&gt;node;
	node-&gt;overlaps = g_slist_remove( node-&gt;overlaps, lap );
	g_assert( node-&gt;st-&gt;novl &gt; 0 );
	node-&gt;st-&gt;novl--;
}
static void
junk_table( VipsImage *image, SymbolTable *st ) {
	int i;
	for( i = 0; i &lt; st-&gt;sz; i++ )
		VIPS_FREEF( g_slist_free, st-&gt;table[i] );
}
SymbolTable *
vips__build_symtab( VipsImage *out, int sz )
{
	SymbolTable *st = VIPS_NEW( out, SymbolTable );
	int i;
	if( !st ||
		!(st-&gt;table = VIPS_ARRAY( out, sz, GSList * )) )
		return( NULL );
	st-&gt;sz = sz;
	st-&gt;im = out;
	st-&gt;novl = 0;
	st-&gt;nim = 0;
	st-&gt;njoin = 0;
	st-&gt;root = NULL;
	st-&gt;leaf = NULL;
	st-&gt;fac = NULL;
	g_signal_connect( out, "close", 
		G_CALLBACK( junk_table ), st );
	for( i = 0; i &lt; sz; i++ )
		st-&gt;table[i] = NULL;
	return( st );
}
static JoinNode *
test_name( JoinNode *node, char *name, void *b )
{
	if( strcmp( node-&gt;name, name ) == 0 )
		return( node );
	else
		return( NULL );
}
static JoinNode *
find_node( SymbolTable *st, char *name ) 
{
	return( vips_slist_map2( st-&gt;table[hash( name )],
		(VipsSListMap2Fn) test_name, name, NULL ) );
}
static JoinNode *
add_node( SymbolTable *st, char *name )
{
	JoinNode *node;
	if( !(node = find_node( st, name )) &amp;&amp; 
		!(node = build_node( st, name )) )
		return( NULL );
	return( node );
}
void *
vips__map_table( SymbolTable *st, VipsSListMap2Fn fn, void *a, void *b )
{
	int i;
	void *r;
	for( i = 0; i &lt; st-&gt;sz; i++ )
		if( (r = vips_slist_map2( st-&gt;table[i], fn, a, b )) )
			return( r );
	return( NULL );
}
static void *
set_dirty( JoinNode *node, int state, void *b )
{	
	node-&gt;dirty = state;
	return( NULL );
}
static void
clean_table( SymbolTable *st )
{
	(void) vips__map_table( st, 
		(VipsSListMap2Fn) set_dirty, (void *) 0, NULL );
}
static void
calc_geometry( JoinNode *node )
{
	VipsRect um;
	switch( node-&gt;type ) {
	case JOIN_LR:
	case JOIN_TB:
	case JOIN_LRROTSCALE:
	case JOIN_TBROTSCALE:
		vips_rect_unionrect( &amp;node-&gt;arg1-&gt;cumtrn.oarea,
			&amp;node-&gt;arg2-&gt;cumtrn.oarea, &amp;um );
		node-&gt;cumtrn.iarea.left = 0;
		node-&gt;cumtrn.iarea.top = 0;
		node-&gt;cumtrn.iarea.width = um.width;
		node-&gt;cumtrn.iarea.height = um.height;
		vips__transform_set_area( &amp;node-&gt;cumtrn );
		break;
	case JOIN_CP:
		node-&gt;cumtrn = node-&gt;arg1-&gt;cumtrn;
		break;
	case JOIN_LEAF:
		if( node-&gt;im ) {
			node-&gt;cumtrn.iarea.left = 0;
			node-&gt;cumtrn.iarea.top = 0;
			node-&gt;cumtrn.iarea.width = node-&gt;im-&gt;Xsize;
			node-&gt;cumtrn.iarea.height = node-&gt;im-&gt;Ysize;
			vips__transform_set_area( &amp;node-&gt;cumtrn );
		}
		break;
	default:
		vips_error_exit( "internal error #98356" );
	}
}
static int
propagate_transform( JoinNode *node, VipsTransformation *trn )
{
	if( !node )
		return( 0 );
	if( node-&gt;dirty &amp;&amp; node-&gt;arg1 &amp;&amp; node-&gt;arg2 ) {
		vips_error( "vips_global_balance", 
			"%s", _( "circularity detected" ) );
		return( -1 );
	}
	node-&gt;dirty = 1;
	if( propagate_transform( node-&gt;arg1, trn ) ||
		propagate_transform( node-&gt;arg2, trn ) )
		return( -1 );
	vips__transform_add( &amp;node-&gt;cumtrn, trn, &amp;node-&gt;cumtrn );
	calc_geometry( node );
	return( 0 );
}
static int
make_join( SymbolTable *st, JoinType type, 
	JoinNode *arg1, JoinNode *arg2, JoinNode *out, 
	double a, double b, double dx, double dy, int mwidth )
{
	VipsTransformation trn;
<a name="0"></a>
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( out-&gt;type != JOIN_LEAF ) {
		vips_error( "vips_global_balance", 
			_( "image \"%s\" used twice as output" ), out-&gt;name );
		return( -1 );
	}
	out-&gt;type = type;
	out-&gt;mwidth = mwidth;
	out-&gt;a = a;
	out-&gt;b = b;
	out-&gt;dx = dx;
	out-&gt;dy = dy;
	out-&gt;arg1 = arg1;
	out-&gt;arg2 = arg2;
	out-&gt;thistrn.a = a;
	out-&gt;thistrn.b = -b;
	out-&gt;thistrn.c = b;
	out-&gt;thistrn.d = a;</b></font>
	out-&gt;thistrn.idx = 0;
	out-&gt;thistrn.idy = 0;
	out-&gt;thistrn.odx = dx;
	out-&gt;thistrn.ody = dy;
	clean_table( st );
	if( propagate_transform( arg2, &amp;out-&gt;thistrn ) )
		return( -1 );
	calc_geometry( out );
	trn.a = 1.0;
	trn.b = 0.0;
	trn.c = 0.0;
	trn.d = 1.0;
	trn.idx = 0;
	trn.idy = 0;
	trn.odx = -out-&gt;cumtrn.oarea.left;
	trn.ody = -out-&gt;cumtrn.oarea.top;
	clean_table( st );
	if( propagate_transform( out, &amp;trn ) )
		return( -1 );
	return( 0 );
}
static int
make_copy( SymbolTable *st, JoinNode *before, JoinNode *after )
{
	if( after-&gt;type != JOIN_LEAF ) {
		vips_error( "vips_global_balance", 
			_( "image \"%s\" used twice as output" ), after-&gt;name );
		return( -1 );
	}
	after-&gt;type = JOIN_CP;
	after-&gt;arg1 = before;
	after-&gt;arg2 = NULL;
	calc_geometry( after ); 
	return( 0 );
}
static int
process_line( SymbolTable *st, const char *text )
{
	char line[1024];
#ifdef DEBUG
	printf( "read: %s\n", text );
	vips_strncpy( line, text, 1024 );
	if( vips_isprefix( "#LRJOIN ", line ) ||
		vips_isprefix( "#TBJOIN ", line ) ) {
		char *item[MAX_ITEMS];
		int nitems;
		JoinType type;
		JoinNode *arg1, *arg2, *join;
		int dx, dy, mwidth;
		if( (nitems = break_items( line, item )) &lt; 0 )
			return( -1 );
		if( nitems != 5 &amp;&amp; nitems != 6 ) {
			vips_error( "global_balance", 
				"%s", _( "bad number of args in join line" ) );
			return( -1 );
		}
		if( !(arg1 = add_node( st, item[0] )) ||
			!(arg2 = add_node( st, item[1] )) ||
			!(join = add_node( st, item[2] )) )
			return( -1 );
		dx = atoi( item[3] );
		dy = atoi( item[4] );
		if( nitems == 6 ) 
			mwidth = atoi( item[5] );
		else
			mwidth = -1;
		if( vips_isprefix( "#LRJOIN ", line ) )
			type = JOIN_LR;
		else
			type = JOIN_TB;
		if( make_join( st, type, arg1, arg2, 
			join, 1.0, 0.0, dx, dy, mwidth ) )
			return( -1 );
	}
	else if( vips_isprefix( "#LRROTSCALE ", line ) ||
		vips_isprefix( "#TBROTSCALE ", line ) ) {
		char *item[MAX_ITEMS];
		int nitems;
		JoinType type;
		JoinNode *arg1, *arg2, *join;
		double a, b, dx, dy;
		int mwidth;
		if( (nitems = break_items( line, item )) &lt; 0 )
			return( -1 );
		if( nitems != 7 &amp;&amp; nitems != 8 ) {
			vips_error( "global_balance", 
				"%s", _( "bad number of args in join1 line" ) );
			return( -1 );
		}
		if( !(arg1 = add_node( st, item[0] )) ||
			!(arg2 = add_node( st, item[1] )) ||
			!(join = add_node( st, item[2] )) )
			return( -1 );
		a = g_ascii_strtod( item[3], NULL );
		b = g_ascii_strtod( item[4], NULL );
		dx = g_ascii_strtod( item[5], NULL );
		dy = g_ascii_strtod( item[6], NULL );
		if( nitems == 8 )
			mwidth = atoi( item[7] );
		else
			mwidth = -1;
		if( vips_isprefix( "#LRROTSCALE ", line ) )
			type = JOIN_LRROTSCALE;
		else
			type = JOIN_TBROTSCALE;
		if( make_join( st, type, arg1, arg2, 
			join, a, b, dx, dy, mwidth ) )
			return( -1 );
	}
	else if( vips_isprefix( "copy ", line ) ) {
		char *item[MAX_ITEMS];
		int nitems;
		JoinNode *before, *after;
		if( (nitems = break_items( line, item )) &lt; 0 )
			return( -1 );
		if( nitems != 2 ) {
			vips_error( "global_balance", 
				"%s", _( "bad number of args in copy line" ) );
			return( -1 );
		}
		if( !(before = add_node( st, item[0] )) ||
			!(after = add_node( st, item[1] )) ||
			make_copy( st, before, after ) )
			return( -1 );
	}
	return( 0 );
}
static void *
set_referenced( JoinNode *node, void *a, void *b )
{
	if( node-&gt;arg1 )
		node-&gt;arg1-&gt;dirty = 1;
	if( node-&gt;arg2 )
		node-&gt;arg2-&gt;dirty = 1;
	return( NULL );
}
static void *
is_root( JoinNode *node, void *a, void *b )
{
	if( !node-&gt;dirty )
		return( (void *) node );
	else
		return( NULL );
}
static JoinNode *
find_root( SymbolTable *st )
{
	JoinNode *root;
	clean_table( st );
	vips__map_table( st, (VipsSListMap2Fn) set_referenced, NULL, NULL );
	root = (JoinNode *) vips__map_table( st, 
		(VipsSListMap2Fn) is_root, NULL, NULL );
	if( !root ) {
		vips_error( "vips_global_balance", 
			"%s", _( "mosaic root not found in desc file\n"
			"is this really a mosaiced image?" ) );
		return( NULL );
	}
	root-&gt;dirty = 1;
	if( vips__map_table( st, (VipsSListMap2Fn) is_root, NULL, NULL ) ) {
		vips_error( "vips_global_balance", 
			"%s", _( "more than one root" ) );
		return( NULL );
	}
	return( root );
}
int
vips__parse_desc( SymbolTable *st, VipsImage *in )
{
	GSList *p;
	for( p = in-&gt;history_list; p; p = p-&gt;next ) {
		GValue *value = (GValue *) p-&gt;data;
		g_assert( G_VALUE_TYPE( value ) == VIPS_TYPE_REF_STRING );
		if( process_line( st, vips_value_get_ref_string( value, NULL ) ) )
			return( -1 );
	}
	if( !(st-&gt;root = find_root( st )) )
		return( -1 );
	return( 0 );
}
static void *
count_leaves( JoinNode *node, void *a, void *b )
{
	if( node-&gt;type == JOIN_LEAF ) {
		node-&gt;index = node-&gt;st-&gt;nim;
		node-&gt;st-&gt;nim++;
	}
	return( NULL );
}
#ifdef DEBUG
static void
print_node( JoinNode *node )
{
	char *basename = g_path_get_basename( node-&gt;name );
	printf( "%s, position %dx%d, size %dx%d, index %d\n",
		basename,
		node-&gt;cumtrn.oarea.left, node-&gt;cumtrn.oarea.top,
		node-&gt;cumtrn.oarea.width, node-&gt;cumtrn.oarea.height,
		node-&gt;index );
	g_free( basename );
}
#ifdef DEBUG
static void *
print_leaf( JoinNode *node, void *a, void *b )
{
	if( node-&gt;type == JOIN_LEAF ) 
		print_node( node );
	return( NULL );
}
static void *
count_joins( JoinNode *node, void *a, void *b )
{
	if( node-&gt;type == JOIN_TB ||
		node-&gt;type == JOIN_LR ||
		node-&gt;type == JOIN_LRROTSCALE ||
		node-&gt;type == JOIN_TBROTSCALE )
		node-&gt;st-&gt;njoin++;
	return( NULL );
}
#ifdef DEBUG
static void
spc( int n )
{
	int i;
	for( i = 0; i &lt; n; i++ )
		printf( " " );
}
#ifdef DEBUG
static char *
JoinType2char( JoinType type )
{
	switch( type ) {
	case JOIN_LR: 		return( "JOIN_LR" );
	case JOIN_TB: 		return( "JOIN_TB" );
	case JOIN_LRROTSCALE: 	return( "JOIN_LRROTSCALE" );
	case JOIN_TBROTSCALE: 	return( "JOIN_TBROTSCALE" );
	case JOIN_CP: 		return( "JOIN_CP" );
	case JOIN_LEAF: 	return( "JOIN_LEAF" );
	default:
		vips_error_exit( "internal error #9275" );
		return( NULL );
	}
}
#ifdef DEBUG
static void *
print_joins( JoinNode *node, int indent )
{
	char *basename = g_path_get_basename( node-&gt;name );
	switch( node-&gt;type ) {
	case JOIN_TB:
	case JOIN_LR:
	case JOIN_TBROTSCALE:
	case JOIN_LRROTSCALE:
		spc( indent );
		printf( "%s to make %s, size %dx%d, pos. %dx%d, of:\n", 
			JoinType2char( node-&gt;type ), 
			basename,
			node-&gt;cumtrn.oarea.width, node-&gt;cumtrn.oarea.height,
			node-&gt;cumtrn.oarea.left, node-&gt;cumtrn.oarea.top );
		spc( indent );
		printf( "reference:\n" );
		print_joins( node-&gt;arg1, indent + 2 );
		spc( indent );
		printf( "secondary:\n" );
		print_joins( node-&gt;arg2, indent + 2 );
		break;
	case JOIN_CP:
		spc( indent );
		printf( "copy to make %s of:\n", basename );
		print_joins( node-&gt;arg1, indent + 2 );
		break;
	case JOIN_LEAF:
		spc( indent );
		printf( "input image %s\n", basename );
		break;
	}
	g_free( basename );
	return( NULL );
}
#ifdef DEBUG
static void *
print_overlap( OverlapInfo *lap, void *a, void *b )
{
	char *basename_node = g_path_get_basename( lap-&gt;node-&gt;name );
	char *basename_other = g_path_get_basename( lap-&gt;other-&gt;name );
	printf( "-&gt; %s overlaps with %s; (this, other) = (%.4G, %.4G)\n",
		basename_node,
		basename_other,
		*VIPS_MATRIX( lap-&gt;nstats, 4, 0 ),
		*VIPS_MATRIX( lap-&gt;ostats, 4, 0 ) );
	g_free( basename_node );
	g_free( basename_other );
	return( NULL );
}
#ifdef DEBUG
static void *
print_overlaps( JoinNode *node, void *a, void *b )
{
	char *basename;
	if( node-&gt;type == JOIN_LEAF &amp;&amp; g_slist_length( node-&gt;overlaps ) &gt; 0 ) {
		basename = g_path_get_basename( node-&gt;name );
		printf( "overlap of %s with:\n", basename );
		g_free( basename );
		vips_slist_map2( node-&gt;overlaps, 
			(VipsSListMap2Fn) print_overlap, NULL, NULL );
	}
	return( NULL );
}
#ifdef DEBUG
static void *
print_overlap_error( OverlapInfo *lap, double *fac, double *total )
{
	char *basename_other = g_path_get_basename( lap-&gt;other-&gt;name );
	double na = *VIPS_MATRIX( lap-&gt;nstats, 4, 0 );
	double oa = *VIPS_MATRIX( lap-&gt;ostats, 4, 0 );
	double err;
	if( fac ) {
		na *= fac[lap-&gt;node-&gt;index];
		oa *= fac[lap-&gt;other-&gt;index];
	}
	err = na - oa;
	printf( "-&gt; file %s, error = %g\n",
		basename_other, err );
	*total += err * err;
	g_free( basename_other );
	return( NULL );
}
#ifdef DEBUG
static void *
print_overlap_errors( JoinNode *node, double *fac, double *total )
{
	char *basename;
	if( node-&gt;type == JOIN_LEAF &amp;&amp; g_slist_length( node-&gt;overlaps ) &gt; 0 ) {
		basename = g_path_get_basename( node-&gt;name );
		printf( "overlap of %s (index %d) with:\n", basename, 
			node-&gt;index );
		g_free( basename );
		vips_slist_map2( node-&gt;overlaps, 
			(VipsSListMap2Fn) print_overlap_error, fac, total );
	}
	return( NULL );
}
static int
extract_rect( VipsImage *in, VipsImage **out, VipsRect *r )
{
	return( vips_extract_area( in, out, 
		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height, NULL ) );
}
static int
make_overlap_mask( VipsImage *mem, 
	VipsImage *ref, VipsImage *sec, VipsImage **mask, 
	VipsRect *rarea, VipsRect *sarea )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( mem ), 6 );
	if( extract_rect( ref, &amp;t[0], rarea ) ||
		extract_rect( sec, &amp;t[1], sarea ) ||
		vips_extract_band( t[0], &amp;t[2], 0, NULL ) ||
		vips_extract_band( t[1], &amp;t[3], 0, NULL ) ||
		vips_notequal_const1( t[2], &amp;t[4], 0.0, NULL ) ||
		vips_notequal_const1( t[3], &amp;t[5], 0.0, NULL ) ||
		vips_andimage( t[4], t[5], mask, NULL ) ) 
		return( -1 );
	return( 0 );
}
static int
count_nonzero( VipsImage *in, gint64 *count )
{
	double avg;
	if( vips_avg( in, &amp;avg, NULL ) )
		return( -1 );
	*count = (avg * VIPS_IMAGE_N_PELS( in )) / 255.0;
	return( 0 );
}
static VipsImage *
find_image_stats( VipsImage *mem, 
	VipsImage *in, VipsImage *mask, VipsRect *area )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( mem ), 5 );
	gint64 count;
	if( extract_rect( in, &amp;t[0], area ) ||
		vips_black( &amp;t[1], t[0]-&gt;Xsize, t[0]-&gt;Ysize, 
			"bands", t[0]-&gt;Bands, 
			NULL ) ||
		vips_cast( t[1], &amp;t[2], t[0]-&gt;BandFmt, NULL ) ||
		vips_ifthenelse( mask, t[0], t[2], &amp;t[3], NULL ) )
		return( NULL );
	if( vips_stats( t[3], &amp;t[4], NULL ) )
		return( NULL );
	if( count_nonzero( mask, &amp;count ) )
		return( NULL );
	*VIPS_MATRIX( t[4], 4, 0 ) *= 
		(double) count / VIPS_IMAGE_N_PELS( mask );
	*VIPS_MATRIX( t[4], 5, 0 )  = count;
#ifdef DEBUG
	if( count == 0 )
		g_warning( "global_balance %s", _( "empty overlap!" ) );
	return( t[4] );
}
static int
find_overlap_stats( OverlapInfo *lap )
{
	VipsImage *mem = lap-&gt;node-&gt;st-&gt;im;
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( mem ), 1 );
	VipsRect rarea, sarea;
	rarea = lap-&gt;overlap;
	rarea.left -= lap-&gt;node-&gt;cumtrn.oarea.left;
	rarea.top -= lap-&gt;node-&gt;cumtrn.oarea.top;
	sarea = lap-&gt;overlap;
	sarea.left -= lap-&gt;other-&gt;cumtrn.oarea.left;
	sarea.top -= lap-&gt;other-&gt;cumtrn.oarea.top;
	if( make_overlap_mask( mem, 
		lap-&gt;node-&gt;trnim, lap-&gt;other-&gt;trnim, &amp;t[0], &amp;rarea, &amp;sarea ) )
		return( -1 );
	if( !(lap-&gt;nstats = find_image_stats( mem, 
		lap-&gt;node-&gt;trnim, t[0], &amp;rarea )) )
		return( -1 );
	if( !(lap-&gt;ostats = find_image_stats( mem, 
		lap-&gt;other-&gt;trnim, t[0], &amp;sarea )) )
		return( -1 );
	return( 0 );
}
static void *
overlap_eq( OverlapInfo *this, JoinNode *node, void *b )
{
	if( this-&gt;other == node )
		return( this );
	else
		return( NULL );
}
static void *
test_overlap( JoinNode *other, JoinNode *node, void *b )
{
	VipsRect overlap;
	OverlapInfo *lap;
	if( other-&gt;type != JOIN_LEAF || node == other ) 
		return( NULL );
	vips_rect_intersectrect( &amp;node-&gt;cumtrn.oarea, &amp;other-&gt;cumtrn.oarea, 
		&amp;overlap );
	if( vips_rect_isempty( &amp;overlap ) ) 
		return( NULL );
	if( overlap.width * overlap.height &lt; TRIVIAL )
		return( NULL );
	if( vips_slist_map2( other-&gt;overlaps, 
		(VipsSListMap2Fn) overlap_eq, node, NULL ) )
		return( NULL );
	if( !(lap = build_overlap( node, other, &amp;overlap )) )
		return( node );
	if( find_overlap_stats( lap ) ) 
		return( node );
	if( *VIPS_MATRIX( lap-&gt;nstats, 5, 0 ) &lt; TRIVIAL ||
		*VIPS_MATRIX( lap-&gt;ostats, 5, 0 ) &lt; TRIVIAL ) {
#ifdef DEBUG
		printf( "trivial overlap ... junking\n" );
		printf( "nstats count = %g, ostats count = %g\n",
			*VIPS_MATRIX( lap-&gt;nstats, 5, 0 ), *VIPS_MATRIX( lap-&gt;ostats, 5, 0 ) );
		print_overlap( lap, NULL, NULL );
		overlap_destroy( lap );
	}
	return( NULL );
}
static void *
find_overlaps( JoinNode *node, SymbolTable *st, void *b )
{
	if( node-&gt;type == JOIN_LEAF ) {
		if( !node-&gt;im ) {
			vips_error( "vips_global_balance", 
				_( "unable to open \"%s\"" ), node-&gt;name );
			return( node );
		}
		if( !node-&gt;trnim ) 
			vips_error_exit( "global_balance: sanity failure #9834" );
		return( vips__map_table( st, 
			(VipsSListMap2Fn) test_overlap, node, NULL ) );
	}
	return( NULL );
}
typedef struct {
	SymbolTable *st;			JoinNode *leaf;				VipsImage *K;				VipsImage *M;				int row;			} MatrixBundle;
static void *
add_nominated( OverlapInfo *ovl, MatrixBundle *bun, double *gamma )
{
	double ns = pow( *VIPS_MATRIX( ovl-&gt;nstats, 4, 0 ), 1.0 / (*gamma) );
	double os = pow( *VIPS_MATRIX( ovl-&gt;ostats, 4, 0 ), 1.0 / (*gamma) );
	*VIPS_MATRIX( bun-&gt;K, 0, bun-&gt;row ) = ns;
	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;other-&gt;index - 1, bun-&gt;row ) = os;
	bun-&gt;row++;
	return( NULL );
}
static void *
add_other( OverlapInfo *ovl, MatrixBundle *bun, double *gamma )
{
	double ns = -pow( *VIPS_MATRIX( ovl-&gt;nstats, 4, 0 ), 1.0 / (*gamma) );
	double os = pow( *VIPS_MATRIX( ovl-&gt;ostats, 4, 0 ), 1.0 / (*gamma) );
	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;node-&gt;index - 1, bun-&gt;row ) = ns;
	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;other-&gt;index - 1, bun-&gt;row ) = os;
	bun-&gt;row++;
	return( NULL );
}
static void *
add_row( JoinNode *node, MatrixBundle *bun, double *gamma )
{
	if( node == bun-&gt;leaf )
		vips_slist_map2( node-&gt;overlaps, 
			(VipsSListMap2Fn) add_nominated, bun, gamma );
	else
		vips_slist_map2( node-&gt;overlaps, 
			(VipsSListMap2Fn) add_other, bun, gamma );
	return( NULL );
}
static void
fill_matrices( SymbolTable *st, double gamma, VipsImage *K, VipsImage *M )
{
	MatrixBundle bun;
	bun.st = st;
	bun.leaf = st-&gt;leaf;
	bun.K = K;
	bun.M = M;
	bun.row = 0;
	vips__map_table( st, (VipsSListMap2Fn) add_row, &amp;bun, &amp;gamma );
}
static void *
choose_leaf( JoinNode *node, void *a, void *b )
{
	if( node-&gt;type == JOIN_LEAF )
		return( node );
	return( NULL );
}
static VipsImage *
make_mos_image( SymbolTable *st, JoinNode *node, transform_fn tfn, void *a )
{
	VipsImage *im1, *im2, *out;
	switch( node-&gt;type ) {
	case JOIN_LR:
	case JOIN_TB:
		if( !(im1 = make_mos_image( st, node-&gt;arg1, tfn, a )) ||
			!(im2 = make_mos_image( st, node-&gt;arg2, tfn, a )) )
			return( NULL );
		if( vips_merge( im1, im2, &amp;out, 
			node-&gt;type == JOIN_LR ? 
				VIPS_DIRECTION_HORIZONTAL : 
				VIPS_DIRECTION_VERTICAL,
			-node-&gt;dx, -node-&gt;dy, 
			"mblend", node-&gt;mwidth,
			NULL ) )
			return( NULL );
		vips_object_local( st-&gt;im, out );
		vips_image_set_string( out, "mosaic-name", node-&gt;name );
		break;
	case JOIN_LRROTSCALE:
	case JOIN_TBROTSCALE:
		if( !(im1 = make_mos_image( st, node-&gt;arg1, tfn, a )) ||
			!(im2 = make_mos_image( st, node-&gt;arg2, tfn, a )) )
			return( NULL );
		out = vips_image_new();
		vips_object_local( st-&gt;im, out );
		vips_image_set_string( out, "mosaic-name", node-&gt;name );
		if( node-&gt;type == JOIN_LRROTSCALE ) {
			if( vips__lrmerge1( im1, im2, out, 
				node-&gt;a, node-&gt;b, node-&gt;dx, node-&gt;dy,
				node-&gt;mwidth ) )
				return( NULL );
		}
		else {
			if( vips__tbmerge1( im1, im2, out, 
				node-&gt;a, node-&gt;b, node-&gt;dx, node-&gt;dy,
				node-&gt;mwidth ) )
				return( NULL );
		}
		break;
	case JOIN_LEAF:
		if( !(out = tfn( node, a )) )
			return( NULL );
		break;
	case JOIN_CP:
		out = make_mos_image( st, node-&gt;arg1, tfn, a );
		break;
	default:
		vips_error_exit( "internal error #982369824375987" );
		return( NULL );
	}
	return( out );
}
int
vips__build_mosaic( SymbolTable *st, VipsImage *out, transform_fn tfn, void *a )
{
	JoinNode *root = st-&gt;root;
	VipsImage *im1, *im2;
	VipsImage *x;
	switch( root-&gt;type ) {
	case JOIN_LR:
	case JOIN_TB:
		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
			!(im2 = make_mos_image( st, root-&gt;arg2, tfn, a )) )
			return( -1 );
		if( vips_merge( im1, im2, &amp;x, 
			root-&gt;type == JOIN_LR ? 
				VIPS_DIRECTION_HORIZONTAL : 
				VIPS_DIRECTION_VERTICAL,
			-root-&gt;dx, -root-&gt;dy, 
			"mblend", root-&gt;mwidth,
			NULL ) )
			return( -1 );
		if( vips_image_write( x, out ) ) {
			g_object_unref( x );
			return( -1 );
		}
		g_object_unref( x );
		break;
	case JOIN_LRROTSCALE:
	case JOIN_TBROTSCALE:
		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
			!(im2 = make_mos_image( st, root-&gt;arg2, tfn, a )) )
			return( -1 );
		if( root-&gt;type == JOIN_LRROTSCALE ) {
			if( vips__lrmerge1( im1, im2, out, 
				root-&gt;a, root-&gt;b, root-&gt;dx, root-&gt;dy,
				root-&gt;mwidth ) )
				return( -1 );
		}
		else {
			if( vips__tbmerge1( im1, im2, out, 
				root-&gt;a, root-&gt;b, root-&gt;dx, root-&gt;dy,
				root-&gt;mwidth ) )
				return( -1 );
		}
		break;
	case JOIN_LEAF:
		if( !(im1 = tfn( root, a )) || 
			vips_image_write( im1, out ) )
			return( -1 );
		break;
	case JOIN_CP:
		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
			vips_image_write( im1, out ) )
			return( -1 );
		break;
	default:
		vips_error_exit( "internal error #982369824375987" );
	}
	return( 0 );
}
static int
vips__matrixtranspose( VipsImage *in, VipsImage **out )
{
	int yc, xc;
	if( !(*out = vips_image_new_matrix( in-&gt;Ysize, in-&gt;Xsize )) )
		return( -1 );
	for( yc = 0; yc &lt; (*out)-&gt;Ysize; ++yc )
		for( xc = 0; xc &lt; (*out)-&gt;Xsize; ++xc )
			*VIPS_MATRIX( *out, xc, yc ) = *VIPS_MATRIX( in, yc, xc );
	return( 0 );
}
static int
vips__matrixmultiply( VipsImage *in1, VipsImage *in2, VipsImage **out )
{
	int xc, yc, col;
	double sum;
	double *mat, *a, *b;
	double *s1, *s2;
	if( in1-&gt;Xsize != in2-&gt;Ysize ) {
		vips_error( "vips__matrixmultiply", "%s", _( "bad sizes" ) );
		return( -1 );
	}
	if( !(*out = vips_image_new_matrix( in2-&gt;Xsize, in1-&gt;Ysize  )) )
		return( -1 );
	mat = VIPS_MATRIX( *out, 0, 0 );
	s1 = VIPS_MATRIX( in1, 0, 0 );
	for( yc = 0; yc &lt; in1-&gt;Ysize; yc++ ) {
		s2 = VIPS_MATRIX( in2, 0, 0 );
		for( col = 0; col &lt; in2-&gt;Xsize; col++ ) {
			a = s1;
			b = s2;
			for( sum = 0.0, xc = 0; xc &lt; in1-&gt;Xsize; xc++ ) {
				sum += *a++ * *b;
				b += in2-&gt;Xsize;
			}
			*mat++ = sum;
			s2++;
		}
		s1 += in1-&gt;Xsize;
	}
	return( 0 );
}
static int
find_factors( SymbolTable *st, double gamma )
{
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 7 );
	double total;
	double avg;
	int i;
	if( !(t[0] = vips_image_new_matrix( 1, st-&gt;novl )) ||
		!(t[1] = vips_image_new_matrix( st-&gt;nim - 1, st-&gt;novl )) )
		return( -1 );
	fill_matrices( st, gamma, t[0], t[1] );
#ifdef DEBUG
	vips_image_write_to_file( t[0], "K.mat", NULL ); 
	vips_image_write_to_file( t[1], "M.mat", NULL );
	if( vips__matrixtranspose( t[1], &amp;t[2] ) ||
		vips__matrixmultiply( t[2], t[1], &amp;t[3] ) ||
		vips_matrixinvert( t[3], &amp;t[4], NULL ) ||
		vips__matrixmultiply( t[4], t[2], &amp;t[5] ) ||
		vips__matrixmultiply( t[5], t[0], &amp;t[6] ) )
		return( -1 );
	if( !(st-&gt;fac = VIPS_ARRAY( st-&gt;im, st-&gt;nim, double )) )
		return( -1 );
	for( i = 0; i &lt; t[6]-&gt;Ysize; i++ )
		st-&gt;fac[i + 1] = *VIPS_MATRIX( t[6], 0, i );
	st-&gt;fac[0] = 1.0;
	total = 0.0;
	for( i = 0; i &lt; st-&gt;nim; i++ )
		total += st-&gt;fac[i];
	avg = total / st-&gt;nim;
	for( i = 0; i &lt; st-&gt;nim; i++ )
		st-&gt;fac[i] /= avg;
#ifdef DEBUG
	printf( "debugging output for vips_global_balance():\n" );
	for( i = 0; i &lt; st-&gt;nim; i++ )
		printf( "balance factor %d = %g\n", i, st-&gt;fac[i] );
	total = 0.0;
	printf( "Overlap errors:\n" );
	vips__map_table( st, 
		(VipsSListMap2Fn) print_overlap_errors, NULL, &amp;total );
	printf( "RMS error = %g\n", sqrt( total / st-&gt;novl ) );
	total = 0.0;
	printf( "Overlap errors after adjustment:\n" );
	vips__map_table( st, 
		(VipsSListMap2Fn) print_overlap_errors, st-&gt;fac, &amp;total );
	printf( "RMS error = %g\n", sqrt( total / st-&gt;novl ) );
	return( 0 );
}
int
vips__affinei( VipsImage *in, VipsImage *out, VipsTransformation *trn )
{
	VipsImage **t = (VipsImage **)
		vips_object_local_array( VIPS_OBJECT( out ), 2 );
	VipsArea *oarea;
	gboolean repack;
	oarea = VIPS_AREA( vips_array_int_newv( 4,
		trn-&gt;oarea.left, trn-&gt;oarea.top,
		trn-&gt;oarea.width, trn-&gt;oarea.height ) );
	repack = in-&gt;Coding == VIPS_CODING_LABQ;
	if( vips_affine( in, &amp;t[0],
		trn-&gt;a, trn-&gt;b, trn-&gt;c, trn-&gt;d,
		"oarea", oarea,
		"odx", trn-&gt;odx,
		"ody", trn-&gt;ody,
		NULL ) ) {
		vips_area_unref( oarea );
		return( -1 );
	}
	vips_area_unref( oarea );
	in = t[0];
	if( repack ) {
		if (vips_colourspace( in, &amp;t[1],
			VIPS_INTERPRETATION_LABQ, NULL ) )
			return ( -1 );
		in = t[1];
	}
	if( vips_image_write( in, out ) )
		return( -1 );
	return( 0 );
}
static void *
generate_trn_leaves( JoinNode *node, SymbolTable *st, void *b )
{
	if( node-&gt;type == JOIN_LEAF ) {
		if( !node-&gt;im ) {
			vips_error( "vips_global_balance", 
				_( "unable to open \"%s\"" ), node-&gt;name );
			return( node );
		}
		if( node-&gt;trnim ) 
			vips_error_exit( "global_balance: sanity failure #765" );
		if( vips__transform_isidentity( &amp;node-&gt;cumtrn ) )
			node-&gt;trnim = node-&gt;im;
		else {
			node-&gt;trnim = vips_image_new();
			vips_object_local( node-&gt;st-&gt;im, node-&gt;trnim );
			if ( vips__affinei( node-&gt;im, node-&gt;trnim, &amp;node-&gt;cumtrn ) )
				return( node );
		}
	}
	return( NULL );
}
static int
analyse_mosaic( SymbolTable *st, VipsImage *in )
{
	if( vips__parse_desc( st, in ) )
		return( -1 );
#ifdef DEBUG
	printf( "Input files:\n" );
	vips__map_table( st, (VipsSListMap2Fn) print_leaf, NULL, NULL );
	printf( "\nOutput file:\n" );
	print_node( st-&gt;root );
	printf( "\nJoin commands:\n" );
	print_joins( st-&gt;root, 0 );
	if( vips__map_table( st, 
		(VipsSListMap2Fn) generate_trn_leaves, st, NULL ) )
		return( -1 );
	if( vips__map_table( st, (VipsSListMap2Fn) find_overlaps, st, NULL ) )
		return( -1 );
	vips__map_table( st, (VipsSListMap2Fn) count_leaves, NULL, NULL );
	vips__map_table( st, (VipsSListMap2Fn) count_joins, NULL, NULL );
	st-&gt;leaf = vips__map_table( st, 
		(VipsSListMap2Fn) choose_leaf, NULL, NULL );
#ifdef DEBUG
	printf( "\nLeaf to be 1.000:\n" );
	print_node( st-&gt;leaf );
	printf( "\nOverlaps:\n" );
	vips__map_table( st, (VipsSListMap2Fn) print_overlaps, NULL, NULL );
	printf( "\n%d input files, %d unique overlaps, %d joins\n", 
		st-&gt;nim, st-&gt;novl, st-&gt;njoin );
	return( 0 );
}
static VipsImage *
transform( JoinNode *node, double *gamma )
{
	SymbolTable *st = node-&gt;st;
	VipsImage *in = node-&gt;im;
	double fac = st-&gt;fac[node-&gt;index];
	VipsImage **t = (VipsImage **)
		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 8 );
	VipsImage *out;
	if( fac == 1.0 ) {
		out = in;
	}
	else if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR || 
		in-&gt;BandFmt == VIPS_FORMAT_USHORT ) {
		if( vips_identity( &amp;t[0],
				"bands", 1,
				"ushort", in-&gt;BandFmt == VIPS_FORMAT_USHORT,
				NULL ) ||
			vips_pow_const1( t[0], &amp;t[1],
				1.0 / (*gamma), NULL ) ||
			vips_linear1( t[1], &amp;t[2], fac, 0.0, NULL ) ||
			vips_pow_const1( t[2], &amp;t[3], *gamma, NULL ) ||
			vips_cast( t[3], &amp;t[4], in-&gt;BandFmt, NULL ) ||
			vips_maplut( in, &amp;t[5], t[4], NULL ) )
			return( NULL );
		out = t[5];
	}
	else {
		if( vips_linear1( in, &amp;t[6], fac, 0.0, NULL ) ||
			vips_cast( t[6], &amp;t[7], in-&gt;BandFmt, NULL ) )
			return( NULL );
		out = t[7];
	}
	vips_image_set_string( out, "mosaic-name", node-&gt;name );
	return( out );
}
static VipsImage *
transformf( JoinNode *node, double *gamma )
{
	SymbolTable *st = node-&gt;st;
	VipsImage *in = node-&gt;im;
	double fac = node-&gt;st-&gt;fac[node-&gt;index];
	VipsImage **t = (VipsImage **) 
		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 6 );
	VipsImage *out;
	if( fac == 1.0 ) {
		out = in;
	}
	else if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR || 
		in-&gt;BandFmt == VIPS_FORMAT_USHORT ) {
		if( vips_identity( &amp;t[0],
				"bands", 1,
				"ushort", in-&gt;BandFmt == VIPS_FORMAT_USHORT,
				NULL ) ||
			vips_pow_const1( t[0], &amp;t[1],
				1.0 / (*gamma), NULL ) ||
			vips_linear1( t[1], &amp;t[2], fac, 0.0, NULL ) ||
			vips_pow_const1( t[2], &amp;t[3], *gamma, NULL ) ||
			vips_maplut( in, &amp;t[4], t[3], NULL ) )
			return( NULL );
		out = t[4];
	}
	else {
		if( vips_linear1( in, &amp;t[5], fac, 0.0, NULL ) )
			return( NULL );
		out = t[5];
	}
	vips_image_set_string( out, "mosaic-name", node-&gt;name );
	return( out );
}
typedef struct {
	VipsOperation parent_instance;
	VipsImage *in;
	VipsImage *out;
	gboolean int_output;
	double gamma;
} VipsGlobalbalance;
typedef VipsOperationClass VipsGlobalbalanceClass;
G_DEFINE_TYPE( VipsGlobalbalance, vips_globalbalance, VIPS_TYPE_OPERATION );
static int
vips_globalbalance_build( VipsObject *object )
{
	VipsGlobalbalance *globalbalance = (VipsGlobalbalance *) object;
	SymbolTable *st;
	transform_fn trn;
	g_object_set( globalbalance, "out", vips_image_new(), NULL ); 
	if( VIPS_OBJECT_CLASS( vips_globalbalance_parent_class )-&gt;
		build( object ) )
		return( -1 );
	if( !(st = vips__build_symtab( globalbalance-&gt;out, SYM_TAB_SIZE )) ||
		analyse_mosaic( st, globalbalance-&gt;in ) ||
		find_factors( st, globalbalance-&gt;gamma ) )
		return( -1 );
	trn = globalbalance-&gt;int_output ? 
		(transform_fn) transform : (transform_fn) transformf; 
	if( vips__build_mosaic( st, globalbalance-&gt;out, 
		trn, &amp;globalbalance-&gt;gamma ) )
		return( -1 );
	return( 0 );
}
static void
vips_globalbalance_class_init( VipsGlobalbalanceClass *class )
{
	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
	VipsObjectClass *object_class = (VipsObjectClass *) class;
	gobject_class-&gt;set_property = vips_object_set_property;
	gobject_class-&gt;get_property = vips_object_get_property;
	object_class-&gt;nickname = "globalbalance";
	object_class-&gt;description = _( "global balance an image mosaic" );
	object_class-&gt;build = vips_globalbalance_build;
	VIPS_ARG_IMAGE( class, "in", 1, 
		_( "Input" ), 
		_( "Input image" ),
		VIPS_ARGUMENT_REQUIRED_INPUT, 
		G_STRUCT_OFFSET( VipsGlobalbalance, in ) );
	VIPS_ARG_IMAGE( class, "out", 2, 
		_( "Output" ), 
		_( "Output image" ),
		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
		G_STRUCT_OFFSET( VipsGlobalbalance, out ) );
	VIPS_ARG_DOUBLE( class, "gamma", 5, 
		_( "gamma" ), 
		_( "Image gamma" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsGlobalbalance, gamma ),
		0.00001, 10, 1.6 );
	VIPS_ARG_BOOL( class, "int_output", 7, 
		_( "Int output" ), 
		_( "Integer output" ),
		VIPS_ARGUMENT_OPTIONAL_INPUT,
		G_STRUCT_OFFSET( VipsGlobalbalance, int_output ),
		FALSE ); 
}
static void
vips_globalbalance_init( VipsGlobalbalance *globalbalance )
{
	globalbalance-&gt;gamma = 1.6;
}
int 
vips_globalbalance( VipsImage *in, VipsImage **out, ... )
{
	va_list ap;
	int result;
	va_start( ap, out );
	result = vips_call_split( "globalbalance", ap, in, out );
	va_end( ap );
	return( result );
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
