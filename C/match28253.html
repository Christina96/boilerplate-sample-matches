<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tbmerge.c &amp; global_balance.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tbmerge.c &amp; global_balance.c
      </h3>
<h1 align="center">
        1.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tbmerge.c (4.123711%)<th>global_balance.c (1.3104013%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(258-282)<td><a href="#" name="0">(494-513)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tbmerge.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;math.h&gt;
7 #include &lt;vips/vips.h&gt;
8 #include &lt;vips/thread.h&gt;
9 #include &lt;vips/transform.h&gt;
10 #include &lt;vips/internal.h&gt;
11 #include "pmosaicing.h"
12 static int
13 find_top( VipsRegion *ir, int *pos, int x, int y, int h )
14 {
15 	VipsPel *pr = VIPS_REGION_ADDR( ir, x, y );
16 	VipsImage *im = ir-&gt;im;
17 	int ls = VIPS_REGION_LSKIP( ir ) / VIPS_IMAGE_SIZEOF_ELEMENT( im );
18 	int b = im-&gt;Bands;
19 	int i, j;
20 	if( vips_band_format_iscomplex( im-&gt;BandFmt ) )
21 		b *= 2;
22 #define tsearch( TYPE ) { \
23 	TYPE *p = (TYPE *) pr; \
24 	\
25 	for( i = 0; i &lt; h; i++ ) { \
26 		for( j = 0; j &lt; b; j++ ) \
27 			if( p[j] ) \
28 				break; \
29 		if( j &lt; b ) \
30 			break; \
31 		\
32 		p += ls; \
33 	} \
34 }
35 	switch( im-&gt;BandFmt ) {
36 	case VIPS_FORMAT_UCHAR:	tsearch( unsigned char ); break; 
37 	case VIPS_FORMAT_CHAR:	tsearch( signed char ); break; 
38 	case VIPS_FORMAT_USHORT:	tsearch( unsigned short ); break; 
39 	case VIPS_FORMAT_SHORT:	tsearch( signed short ); break; 
40 	case VIPS_FORMAT_UINT:	tsearch( unsigned int ); break; 
41 	case VIPS_FORMAT_INT:	tsearch( signed int );  break; 
42 	case VIPS_FORMAT_FLOAT:	tsearch( float ); break; 
43 	case VIPS_FORMAT_DOUBLE:	tsearch( double ); break; 
44 	case VIPS_FORMAT_COMPLEX:	tsearch( float ); break; 
45 	case VIPS_FORMAT_DPCOMPLEX:	tsearch( double ); break;
46 	default:
47 		vips_error( "vips_tbmerge", "%s", _( "internal error" ) );
48 		return( -1 );
49 	}
50 	*pos = y + i;
51 	return( 0 );
52 }
53 static int
54 find_bot( VipsRegion *ir, int *pos, int x, int y, int h )
55 {
56 	VipsPel *pr = VIPS_REGION_ADDR( ir, x, y );
57 	VipsImage *im = ir-&gt;im;
58 	int ls = VIPS_REGION_LSKIP( ir ) / VIPS_IMAGE_SIZEOF_ELEMENT( ir-&gt;im );
59 	int b = im-&gt;Bands;
60 	int i, j;
61 	if( vips_band_format_iscomplex( im-&gt;BandFmt ) )
62 		b *= 2;
63 #define rsearch( TYPE ) { \
64 	TYPE *p = (TYPE *) pr + (h - 1) * ls; \
65 	\
66 	for( i = h - 1; i &gt;= 0; i-- ) { \
67 		for( j = 0; j &lt; b; j++ ) \
68 			if( p[j] ) \
69 				break; \
70 		if( j &lt; b ) \
71 			break; \
72 		\
73 		p -= ls; \
74 	} \
75 }
76 	switch( im-&gt;BandFmt ) {
77 	case VIPS_FORMAT_UCHAR:	rsearch( unsigned char ); break;
78 	case VIPS_FORMAT_CHAR:	rsearch( signed char ); break;
79 	case VIPS_FORMAT_USHORT:	rsearch( unsigned short ); break;
80 	case VIPS_FORMAT_SHORT:	rsearch( signed short ); break;
81 	case VIPS_FORMAT_UINT:	rsearch( unsigned int ); break;
82 	case VIPS_FORMAT_INT:	rsearch( signed int );  break;
83 	case VIPS_FORMAT_FLOAT:	rsearch( float ); break;
84 	case VIPS_FORMAT_DOUBLE:	rsearch( double ); break;
85 	case VIPS_FORMAT_COMPLEX:	rsearch( float ); break;
86 	case VIPS_FORMAT_DPCOMPLEX:	rsearch( double ); break;
87 	default:
88 		vips_error( "vips_tbmerge", "%s", _( "internal error" ) );
89 		return( -1 );
90 	}
91 	*pos = y + i;
92 	return( 0 );
93 }
94 static int
95 make_firstlast( MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
96 {
97 	VipsRegion *rir = inf-&gt;rir;
98 	VipsRegion *sir = inf-&gt;sir;
99 	VipsRect rr, sr;
100 	int x;
101 	int missing;
102 	g_mutex_lock( ovlap-&gt;fl_lock );
103 	missing = 0;
104 	for( x = oreg-&gt;left; x &lt; VIPS_RECT_RIGHT( oreg ); x++ ) {
105 		const int j = x - ovlap-&gt;overlap.left;
106 		const int first = ovlap-&gt;first[j];
107 		if( first &lt; 0 ) {
108 			missing = 1;
109 <a name="0"></a>			break;
110 		}
111 	}
112 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	if( !missing ) {
113 		g_mutex_unlock( ovlap-&gt;fl_lock );
114 		return( 0 );
115 	}
116 	rr.left = oreg-&gt;left;
117 	rr.top = ovlap-&gt;overlap.top;
118 	rr.width = oreg-&gt;width;
119 	rr.height = ovlap-&gt;overlap.height;
120 	rr.left -= ovlap-&gt;rarea.left;
121 	rr.top -= ovlap-&gt;rarea.top;
122 	sr.left = oreg-&gt;left;
123 	sr.top = ovlap-&gt;overlap.top;
124 	sr.width = oreg-&gt;width;
125 	sr.height = ovlap-&gt;overlap.height;
126 	sr.left -= ovlap-&gt;sarea.left;
127 	sr.top -= ovlap-&gt;sarea.top;</b></font>
128 	if( vips_region_prepare( rir, &amp;rr ) || 
129 		vips_region_prepare( sir, &amp;sr ) ) {
130 		g_mutex_unlock( ovlap-&gt;fl_lock );
131 		return( -1 );
132 	}
133 	for( x = 0; x &lt; oreg-&gt;width; x++ ) {
134 		const int j = (x + oreg-&gt;left) - ovlap-&gt;overlap.left;
135 		int *first = &amp;ovlap-&gt;first[j];
136 		int *last = &amp;ovlap-&gt;last[j];
137 		if( *first &lt; 0 ) {
138 			if( find_top( sir, first, 
139 				x + sr.left, sr.top, sr.height ) ||
140 				find_bot( rir, last, 
141 					x + rr.left, rr.top, rr.height ) ) {
142 				g_mutex_unlock( ovlap-&gt;fl_lock );
143 				return( -1 );
144 			}
145 			*first += ovlap-&gt;sarea.top;
146 			*last += ovlap-&gt;rarea.top;
147 			if( ovlap-&gt;mwidth &gt;= 0 &amp;&amp; 
148 				*last - *first &gt; ovlap-&gt;mwidth ) {
149 				int shrinkby = (*last - *first) - ovlap-&gt;mwidth;
150 				*first += shrinkby / 2;
151 				*last -= shrinkby / 2;
152 			}
153 		}
154 	}
155 	g_mutex_unlock( ovlap-&gt;fl_lock );
156 	return( 0 );
157 }
158 #define TEST_ZERO( TYPE, T, RESULT ) { \
159 	TYPE *tt = (T); \
160 	int ii; \
161 	\
162 	for( ii = 0; ii &lt; cb; ii++ ) \
163 		if( tt[i + ii] ) \
164 			break; \
165 	if( ii == cb )  \
166 		(RESULT) = 1; \
167 }
168 #define iblend( TYPE, B, IN1, IN2, OUT ) { \
169 	TYPE *tr = (TYPE *) (IN1); \
170 	TYPE *ts = (TYPE *) (IN2); \
171 	TYPE *tq = (TYPE *) (OUT); \
172 	const int cb = (B); \
173 	int ref_zero; \
174 	int sec_zero; \
175 	int x, b; \
176 	int i; \
177 	\
178 	for( i = 0, x = 0; x &lt; oreg-&gt;width; x++ ) { \
179 		ref_zero = 0; \
180 		sec_zero = 0; \
181 		TEST_ZERO( TYPE, tr, ref_zero ); \
182 		TEST_ZERO( TYPE, ts, sec_zero ); \
183 		\
184 		if( y &lt; first[x] ) { \
185 			if( !ref_zero ) \
186 				for( b = 0; b &lt; cb; b++, i++ )  \
187 					tq[i] = tr[i]; \
188 			else \
189 				for( b = 0; b &lt; cb; b++, i++ )  \
190 					tq[i] = ts[i]; \
191 		} \
192 		else if( y &gt;= last[x] ) { \
193 			if( !sec_zero ) \
194 				for( b = 0; b &lt; cb; b++, i++ )  \
195 					tq[i] = ts[i]; \
196 			else \
197 				for( b = 0; b &lt; cb; b++, i++ )  \
198 					tq[i] = tr[i]; \
199 		} \
200 		else { \
201 			if( !ref_zero &amp;&amp; !sec_zero ) { \
202 				const int bheight = last[x] - first[x]; \
203 				const int inx = ((y - first[x]) &lt;&lt; \
204 					BLEND_SHIFT) / bheight; \
205 				int c1 = vips__icoef1[inx];  \
206 				int c2 = vips__icoef2[inx];  \
207 				\
208 				for( b = 0; b &lt; cb; b++, i++ ) \
209 					tq[i] = c1 * tr[i] / BLEND_SCALE + \
210 						c2 * ts[i] / BLEND_SCALE; \
211 			} \
212 			else if( !ref_zero ) \
213 				for( b = 0; b &lt; cb; b++, i++ )  \
214 					tq[i] = tr[i]; \
215 			else \
216 				for( b = 0; b &lt; cb; b++, i++ )  \
217 					tq[i] = ts[i]; \
218 		}  \
219 	} \
220 }
221 #define fblend( TYPE, B, IN1, IN2, OUT ) { \
222 	TYPE *tr = (TYPE *) (IN1); \
223 	TYPE *ts = (TYPE *) (IN2); \
224 	TYPE *tq = (TYPE *) (OUT); \
225 	int ref_zero; \
226 	int sec_zero; \
227 	const int cb = (B); \
228 	int x, b; \
229 	int i; \
230 	\
231 	for( i = 0, x = 0; x &lt; oreg-&gt;width; x++ ) { \
232 		ref_zero = 0; \
233 		sec_zero = 0; \
234 		TEST_ZERO( TYPE, tr, ref_zero ); \
235 		TEST_ZERO( TYPE, ts, sec_zero ); \
236 		\
237 		if( y &lt; first[x] )  \
238 			if( !ref_zero ) \
239 				for( b = 0; b &lt; cb; b++, i++ )  \
240 					tq[i] = tr[i]; \
241 			else \
242 				for( b = 0; b &lt; cb; b++, i++ )  \
243 					tq[i] = tr[i]; \
244 		else if( y &gt;= last[x] )  \
245 			if( !sec_zero ) \
246 				for( b = 0; b &lt; cb; b++, i++ )  \
247 					tq[i] = ts[i]; \
248 			else \
249 				for( b = 0; b &lt; cb; b++, i++ )  \
250 					tq[i] = tr[i]; \
251 		else { \
252 			if( !ref_zero &amp;&amp; !sec_zero ) { \
253 				const int bheight = last[x] - first[x]; \
254 				const int inx = ((y - first[x]) &lt;&lt; \
255 					BLEND_SHIFT) / bheight; \
256 				double c1 = vips__coef1[inx];  \
257 				double c2 = vips__coef2[inx];  \
258 				\
259 				for( b = 0; b &lt; cb; b++, i++ ) \
260 					tq[i] = c1 * tr[i] + c2 * ts[i]; \
261 			} \
262 			else if( !ref_zero ) \
263 				for( b = 0; b &lt; cb; b++, i++ )  \
264 					tq[i] = tr[i]; \
265 			else \
266 				for( b = 0; b &lt; cb; b++, i++ )  \
267 					tq[i] = ts[i]; \
268 		}  \
269 	} \
270 }
271 static int
272 tb_blend( VipsRegion *or, MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
273 {
274 	VipsRegion *rir = inf-&gt;rir;
275 	VipsRegion *sir = inf-&gt;sir;
276 	VipsImage *im = or-&gt;im;
277 	VipsRect prr, psr;
278 	int y, yr, ys;
279 	if( make_firstlast( inf, ovlap, oreg ) )
280 		return( -1 );
281 	prr = *oreg;
282 	prr.left -= ovlap-&gt;rarea.left;
283 	prr.top -= ovlap-&gt;rarea.top;
284 	psr = *oreg;
285 	psr.left -= ovlap-&gt;sarea.left;
286 	psr.top -= ovlap-&gt;sarea.top;
287 	if( vips_region_prepare( rir, &amp;prr ) ||
288 		vips_region_prepare( sir, &amp;psr ) )
289 		return( -1 );
290 	for( y = oreg-&gt;top, yr = prr.top, ys = psr.top; 
291 		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) { 
292 		VipsPel *pr = VIPS_REGION_ADDR( rir, prr.left, yr );
293 		VipsPel *ps = VIPS_REGION_ADDR( sir, psr.left, ys );
294 		VipsPel *q = VIPS_REGION_ADDR( or, oreg-&gt;left, y );
295 		const int j = oreg-&gt;left - ovlap-&gt;overlap.left;
296 		const int *first = ovlap-&gt;first + j;
297 		const int *last = ovlap-&gt;last + j;
298 		switch( im-&gt;BandFmt ) {
299 		case VIPS_FORMAT_UCHAR: 	
300 			iblend( unsigned char, im-&gt;Bands, pr, ps, q ); break; 
301 		case VIPS_FORMAT_CHAR: 	
302 			iblend( signed char, im-&gt;Bands, pr, ps, q ); break; 
303 		case VIPS_FORMAT_USHORT: 
304 			iblend( unsigned short, im-&gt;Bands, pr, ps, q ); break; 
305 		case VIPS_FORMAT_SHORT: 	
306 			iblend( signed short, im-&gt;Bands, pr, ps, q ); break; 
307 		case VIPS_FORMAT_UINT: 	
308 			iblend( unsigned int, im-&gt;Bands, pr, ps, q ); break; 
309 		case VIPS_FORMAT_INT: 	
310 			iblend( signed int, im-&gt;Bands, pr, ps, q );  break; 
311 		case VIPS_FORMAT_FLOAT: 	
312 			fblend( float, im-&gt;Bands, pr, ps, q ); break; 
313 		case VIPS_FORMAT_DOUBLE:	
314 			fblend( double, im-&gt;Bands, pr, ps, q ); break; 
315 		case VIPS_FORMAT_COMPLEX:
316 			fblend( float, im-&gt;Bands * 2, pr, ps, q ); break; 
317 		case VIPS_FORMAT_DPCOMPLEX:
318 			fblend( double, im-&gt;Bands * 2, pr, ps, q ); break;
319 		default:
320 			vips_error( "vips_tbmerge", "%s", _( "internal error" ) );
321 			return( -1 );
322 		}
323 	}
324 	return( 0 );
325 }
326 static int
327 tb_blend_labpack( VipsRegion *or, MergeInfo *inf, Overlapping *ovlap, VipsRect *oreg )
328 {
329 	VipsRegion *rir = inf-&gt;rir;
330 	VipsRegion *sir = inf-&gt;sir;
331 	VipsRect prr, psr;
332 	int y, yr, ys;
333 	if( make_firstlast( inf, ovlap, oreg ) )
334 		return( -1 );
335 	prr = *oreg;
336 	prr.left -= ovlap-&gt;rarea.left;
337 	prr.top -= ovlap-&gt;rarea.top;
338 	psr = *oreg;
339 	psr.left -= ovlap-&gt;sarea.left;
340 	psr.top -= ovlap-&gt;sarea.top;
341 	if( vips_region_prepare( rir, &amp;prr ) || 
342 		vips_region_prepare( sir, &amp;psr ) )
343 		return( -1 );
344 	for( y = oreg-&gt;top, yr = prr.top, ys = psr.top; 
345 		y &lt; VIPS_RECT_BOTTOM( oreg ); y++, yr++, ys++ ) { 
346 		VipsPel *pr = VIPS_REGION_ADDR( rir, prr.left, yr );
347 		VipsPel *ps = VIPS_REGION_ADDR( sir, psr.left, ys );
348 		VipsPel *q = VIPS_REGION_ADDR( or, oreg-&gt;left, y );
349 		const int j = oreg-&gt;left - ovlap-&gt;overlap.left;
350 		const int *first = ovlap-&gt;first + j;
351 		const int *last = ovlap-&gt;last + j;
352 		float *fq = inf-&gt;merge;
353 		float *r = inf-&gt;from1;
354 		float *s = inf-&gt;from2;
355 		vips__LabQ2Lab_vec( r, pr, oreg-&gt;width );
356 		vips__LabQ2Lab_vec( s, ps, oreg-&gt;width );
357 		fblend( float, 3, r, s, fq ); 
358 		vips__Lab2LabQ_vec( q, inf-&gt;merge, oreg-&gt;width );
359 	}
360 	return( 0 );
361 }
362 static Overlapping *
363 build_tbstate( VipsImage *ref, VipsImage *sec, VipsImage *out, int dx, int dy, int mwidth )
364 {
365    	Overlapping *ovlap;
366 	if( !(ovlap = vips__build_mergestate( "vips_tbmerge", 
367 		ref, sec, out, dx, dy, mwidth )) )
368 		return( NULL );
369 	switch( ovlap-&gt;ref-&gt;Coding ) {
370 	case VIPS_CODING_LABQ:
371 		ovlap-&gt;blend = tb_blend_labpack;
372 		break;
373 	case VIPS_CODING_NONE:
374 		ovlap-&gt;blend = tb_blend;
375 		break;
376 	default:
377 		vips_error( "vips_tbmerge", "%s", _( "unknown coding type" ) );
378 		return( NULL );
379 	}
380 	ovlap-&gt;rpart = ovlap-&gt;rarea;
381 	ovlap-&gt;spart = ovlap-&gt;sarea;
382 	ovlap-&gt;rpart.height -= ovlap-&gt;overlap.height;
383 	ovlap-&gt;spart.top += ovlap-&gt;overlap.height;
384 	ovlap-&gt;spart.height -= ovlap-&gt;overlap.height;
385 	if( VIPS_RECT_BOTTOM( &amp;ovlap-&gt;rarea ) &gt; VIPS_RECT_BOTTOM( &amp;ovlap-&gt;sarea ) ||
386 		ovlap-&gt;rarea.top &gt; ovlap-&gt;sarea.top ) {
387 		vips_error( "vips_tbmerge", "%s", _( "too much overlap" ) );
388 		return( NULL );
389 	}
390 	ovlap-&gt;blsize = ovlap-&gt;overlap.width;
391 	return( ovlap );
392 }
393 int
394 vips__tbmerge( VipsImage *ref, VipsImage *sec, VipsImage *out, 
395 	int dx, int dy, int mwidth )
396 {  
397 	Overlapping *ovlap;
398 	if( dy &gt; 0 || dy &lt; 1 - ref-&gt;Ysize ) {
399 		VipsImage *x;
400 #ifdef DEBUG
401 		printf( "vips__tbmerge: no overlap, using insert\n" ); 
402 #endif
403   		if( vips_insert( ref, sec, &amp;x, -dx, -dy,
404 			"expand", TRUE,
405 			NULL ) )
406 			return( -1 );
407 		if( vips_image_write( x, out ) ) {
408 			g_object_unref( x );
409 			return( -1 );
410 		}
411 		g_object_unref( x );
412 		out-&gt;Xoffset = -dx;
413 		out-&gt;Yoffset = -dy;
414 		return( 0 );
415 	}
416 	if( !(ovlap = build_tbstate( ref, sec, out, dx, dy, mwidth )) )
417 		return( -1 );
418 	if( vips_image_pipelinev( out,
419 		VIPS_DEMAND_STYLE_THINSTRIP, ovlap-&gt;ref, ovlap-&gt;sec, NULL ) )
420 		return( -1 );
421 	out-&gt;Xsize = ovlap-&gt;oarea.width;
422 	out-&gt;Ysize = ovlap-&gt;oarea.height;
423 	out-&gt;Xoffset = -dx;
424 	out-&gt;Yoffset = -dy;
425 	if( vips_image_generate( out,
426 		vips__start_merge, vips__merge_gen, vips__stop_merge, ovlap, NULL ) )
427 		return( -1 );
428 	return ( 0 );
429 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>global_balance.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef HAVE_CONFIG_H
2 #include &lt;config.h&gt;
3 #include &lt;vips/intl.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;string.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;math.h&gt;
9 #include &lt;vips/vips.h&gt;
10 #include &lt;vips/transform.h&gt;
11 #include &lt;vips/internal.h&gt;
12 #include "pmosaicing.h"
13 #include "global_balance.h"
14 #define MAX_ITEMS (50)
15 #define TRIVIAL (20 * 20)
16 static int
17 break_items( char *line, char **out )
18 {
19 	int i;
20 	char *p;
21 	for( i = 0; i &lt; MAX_ITEMS; i++ ) {
22 		if( !(p = strchr( line, '&lt;' )) )
23 			break;
24 		out[i] = line = p + 1;
25 		if( !(p = strchr( line, '&gt;' )) ) {
26 			vips_error( "break_files", "%s", _( "no matching '&gt;'" ) );
27 			return( -1 );
28 		}
29 		*p = '\0';
30 		line = p + 1;
31 	}
32 	if( i == MAX_ITEMS ) {
33 		vips_error( "break_files", "%s", _( "too many items" ) );
34 		return( -1 );
35 	}
36 	return( i );
37 }
38 VipsImage *
39 vips__global_open_image( SymbolTable *st, char *name )
40 {
41 	char *basename;
42 	VipsImage *image;
43 	if( !(image = vips_image_new_from_file( name, NULL ))) {
44 		basename = g_path_get_basename( name );
45 		if( !(image = vips_image_new_from_file( basename, NULL ))) {
46 			g_free( basename );
47 			return( NULL );
48 		}
49 		g_free( basename );
50 	}
51 	vips_object_local( st-&gt;im, image );
52 	return( image );
53 }
54 static void
55 junk_node( VipsImage *image, JoinNode *node )
56 {
57 	VIPS_FREEF( g_slist_free, node-&gt;overlaps );
58 }
59 static int
60 hash( char *n )
61 {
62 	int i;
63 	int r = 0;
64 	int l = strlen( n );
65 	for( i = 0; i &lt; l; i++ )
66 		r = ((r + n[i]) * 43) &amp; 0xffffff;
67 	return( r % SYM_TAB_SIZE );
68 }
69 static JoinNode *
70 build_node( SymbolTable *st, char *name )
71 {
72 	JoinNode *node = VIPS_NEW( st-&gt;im, JoinNode );
73 	int n = hash( name );
74 	if( !node || !(node-&gt;name = 
75 		vips_strdup( VIPS_OBJECT( st-&gt;im ), name )) )
76 		return( NULL );
77 	node-&gt;type = JOIN_LEAF;
78 	node-&gt;dirty = 0;
79 	node-&gt;mwidth = -2;
80 	node-&gt;st = st;
81 	vips__transform_init( &amp;node-&gt;cumtrn );
82 	node-&gt;trnim = NULL;
83 	node-&gt;arg1 = NULL;
84 	node-&gt;arg2 = NULL;
85 	node-&gt;overlaps = NULL;
86 	node-&gt;im = NULL;
87 	node-&gt;index = 0;
88 	g_signal_connect( st-&gt;im, "close",
89 		G_CALLBACK( junk_node ), node );
90 	if( (node-&gt;im = vips__global_open_image( st, name )) ) {
91 		node-&gt;cumtrn.oarea.width = node-&gt;im-&gt;Xsize;
92 		node-&gt;cumtrn.oarea.height = node-&gt;im-&gt;Ysize;
93 	}
94 	else {
95 		vips_error_clear();
96 	}
97 	st-&gt;table[n] = g_slist_prepend( st-&gt;table[n], node );
98 	return( node );
99 }
100 static OverlapInfo *
101 build_overlap( JoinNode *node, JoinNode *other, VipsRect *overlap )
102 {
103 	OverlapInfo *lap = VIPS_NEW( node-&gt;st-&gt;im, OverlapInfo );
104 	if( !lap )
105 		return( NULL );
106 	lap-&gt;node = node;
107 	lap-&gt;other = other;
108 	lap-&gt;overlap = *overlap;
109 	lap-&gt;nstats = NULL;
110 	lap-&gt;ostats = NULL;
111 	node-&gt;overlaps = g_slist_prepend( node-&gt;overlaps, lap );
112 	node-&gt;st-&gt;novl++;
113 	return( lap );
114 }
115 static void
116 overlap_destroy( OverlapInfo *lap )
117 {
118 	JoinNode *node = lap-&gt;node;
119 	node-&gt;overlaps = g_slist_remove( node-&gt;overlaps, lap );
120 	g_assert( node-&gt;st-&gt;novl &gt; 0 );
121 	node-&gt;st-&gt;novl--;
122 }
123 static void
124 junk_table( VipsImage *image, SymbolTable *st ) {
125 	int i;
126 	for( i = 0; i &lt; st-&gt;sz; i++ )
127 		VIPS_FREEF( g_slist_free, st-&gt;table[i] );
128 }
129 SymbolTable *
130 vips__build_symtab( VipsImage *out, int sz )
131 {
132 	SymbolTable *st = VIPS_NEW( out, SymbolTable );
133 	int i;
134 	if( !st ||
135 		!(st-&gt;table = VIPS_ARRAY( out, sz, GSList * )) )
136 		return( NULL );
137 	st-&gt;sz = sz;
138 	st-&gt;im = out;
139 	st-&gt;novl = 0;
140 	st-&gt;nim = 0;
141 	st-&gt;njoin = 0;
142 	st-&gt;root = NULL;
143 	st-&gt;leaf = NULL;
144 	st-&gt;fac = NULL;
145 	g_signal_connect( out, "close", 
146 		G_CALLBACK( junk_table ), st );
147 	for( i = 0; i &lt; sz; i++ )
148 		st-&gt;table[i] = NULL;
149 	return( st );
150 }
151 static JoinNode *
152 test_name( JoinNode *node, char *name, void *b )
153 {
154 	if( strcmp( node-&gt;name, name ) == 0 )
155 		return( node );
156 	else
157 		return( NULL );
158 }
159 static JoinNode *
160 find_node( SymbolTable *st, char *name ) 
161 {
162 	return( vips_slist_map2( st-&gt;table[hash( name )],
163 		(VipsSListMap2Fn) test_name, name, NULL ) );
164 }
165 static JoinNode *
166 add_node( SymbolTable *st, char *name )
167 {
168 	JoinNode *node;
169 	if( !(node = find_node( st, name )) &amp;&amp; 
170 		!(node = build_node( st, name )) )
171 		return( NULL );
172 	return( node );
173 }
174 void *
175 vips__map_table( SymbolTable *st, VipsSListMap2Fn fn, void *a, void *b )
176 {
177 	int i;
178 	void *r;
179 	for( i = 0; i &lt; st-&gt;sz; i++ )
180 		if( (r = vips_slist_map2( st-&gt;table[i], fn, a, b )) )
181 			return( r );
182 	return( NULL );
183 }
184 static void *
185 set_dirty( JoinNode *node, int state, void *b )
186 {	
187 	node-&gt;dirty = state;
188 	return( NULL );
189 }
190 static void
191 clean_table( SymbolTable *st )
192 {
193 	(void) vips__map_table( st, 
194 		(VipsSListMap2Fn) set_dirty, (void *) 0, NULL );
195 }
196 static void
197 calc_geometry( JoinNode *node )
198 {
199 	VipsRect um;
200 	switch( node-&gt;type ) {
201 	case JOIN_LR:
202 	case JOIN_TB:
203 	case JOIN_LRROTSCALE:
204 	case JOIN_TBROTSCALE:
205 		vips_rect_unionrect( &amp;node-&gt;arg1-&gt;cumtrn.oarea,
206 			&amp;node-&gt;arg2-&gt;cumtrn.oarea, &amp;um );
207 		node-&gt;cumtrn.iarea.left = 0;
208 		node-&gt;cumtrn.iarea.top = 0;
209 		node-&gt;cumtrn.iarea.width = um.width;
210 		node-&gt;cumtrn.iarea.height = um.height;
211 		vips__transform_set_area( &amp;node-&gt;cumtrn );
212 		break;
213 	case JOIN_CP:
214 		node-&gt;cumtrn = node-&gt;arg1-&gt;cumtrn;
215 		break;
216 	case JOIN_LEAF:
217 		if( node-&gt;im ) {
218 			node-&gt;cumtrn.iarea.left = 0;
219 			node-&gt;cumtrn.iarea.top = 0;
220 			node-&gt;cumtrn.iarea.width = node-&gt;im-&gt;Xsize;
221 			node-&gt;cumtrn.iarea.height = node-&gt;im-&gt;Ysize;
222 			vips__transform_set_area( &amp;node-&gt;cumtrn );
223 		}
224 		break;
225 	default:
226 		vips_error_exit( "internal error #98356" );
227 	}
228 }
229 static int
230 propagate_transform( JoinNode *node, VipsTransformation *trn )
231 {
232 	if( !node )
233 		return( 0 );
234 	if( node-&gt;dirty &amp;&amp; node-&gt;arg1 &amp;&amp; node-&gt;arg2 ) {
235 		vips_error( "vips_global_balance", 
236 			"%s", _( "circularity detected" ) );
237 		return( -1 );
238 	}
239 	node-&gt;dirty = 1;
240 	if( propagate_transform( node-&gt;arg1, trn ) ||
241 		propagate_transform( node-&gt;arg2, trn ) )
242 		return( -1 );
243 	vips__transform_add( &amp;node-&gt;cumtrn, trn, &amp;node-&gt;cumtrn );
244 	calc_geometry( node );
245 	return( 0 );
246 }
247 static int
248 make_join( SymbolTable *st, JoinType type, 
249 	JoinNode *arg1, JoinNode *arg2, JoinNode *out, 
250 	double a, double b, double dx, double dy, int mwidth )
251 {
252 	VipsTransformation trn;
253 <a name="0"></a>
254 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	if( out-&gt;type != JOIN_LEAF ) {
255 		vips_error( "vips_global_balance", 
256 			_( "image \"%s\" used twice as output" ), out-&gt;name );
257 		return( -1 );
258 	}
259 	out-&gt;type = type;
260 	out-&gt;mwidth = mwidth;
261 	out-&gt;a = a;
262 	out-&gt;b = b;
263 	out-&gt;dx = dx;
264 	out-&gt;dy = dy;
265 	out-&gt;arg1 = arg1;
266 	out-&gt;arg2 = arg2;
267 	out-&gt;thistrn.a = a;
268 	out-&gt;thistrn.b = -b;
269 	out-&gt;thistrn.c = b;
270 	out-&gt;thistrn.d = a;</b></font>
271 	out-&gt;thistrn.idx = 0;
272 	out-&gt;thistrn.idy = 0;
273 	out-&gt;thistrn.odx = dx;
274 	out-&gt;thistrn.ody = dy;
275 	clean_table( st );
276 	if( propagate_transform( arg2, &amp;out-&gt;thistrn ) )
277 		return( -1 );
278 	calc_geometry( out );
279 	trn.a = 1.0;
280 	trn.b = 0.0;
281 	trn.c = 0.0;
282 	trn.d = 1.0;
283 	trn.idx = 0;
284 	trn.idy = 0;
285 	trn.odx = -out-&gt;cumtrn.oarea.left;
286 	trn.ody = -out-&gt;cumtrn.oarea.top;
287 	clean_table( st );
288 	if( propagate_transform( out, &amp;trn ) )
289 		return( -1 );
290 	return( 0 );
291 }
292 static int
293 make_copy( SymbolTable *st, JoinNode *before, JoinNode *after )
294 {
295 	if( after-&gt;type != JOIN_LEAF ) {
296 		vips_error( "vips_global_balance", 
297 			_( "image \"%s\" used twice as output" ), after-&gt;name );
298 		return( -1 );
299 	}
300 	after-&gt;type = JOIN_CP;
301 	after-&gt;arg1 = before;
302 	after-&gt;arg2 = NULL;
303 	calc_geometry( after ); 
304 	return( 0 );
305 }
306 static int
307 process_line( SymbolTable *st, const char *text )
308 {
309 	char line[1024];
310 #ifdef DEBUG
311 	printf( "read: %s\n", text );
312 	vips_strncpy( line, text, 1024 );
313 	if( vips_isprefix( "#LRJOIN ", line ) ||
314 		vips_isprefix( "#TBJOIN ", line ) ) {
315 		char *item[MAX_ITEMS];
316 		int nitems;
317 		JoinType type;
318 		JoinNode *arg1, *arg2, *join;
319 		int dx, dy, mwidth;
320 		if( (nitems = break_items( line, item )) &lt; 0 )
321 			return( -1 );
322 		if( nitems != 5 &amp;&amp; nitems != 6 ) {
323 			vips_error( "global_balance", 
324 				"%s", _( "bad number of args in join line" ) );
325 			return( -1 );
326 		}
327 		if( !(arg1 = add_node( st, item[0] )) ||
328 			!(arg2 = add_node( st, item[1] )) ||
329 			!(join = add_node( st, item[2] )) )
330 			return( -1 );
331 		dx = atoi( item[3] );
332 		dy = atoi( item[4] );
333 		if( nitems == 6 ) 
334 			mwidth = atoi( item[5] );
335 		else
336 			mwidth = -1;
337 		if( vips_isprefix( "#LRJOIN ", line ) )
338 			type = JOIN_LR;
339 		else
340 			type = JOIN_TB;
341 		if( make_join( st, type, arg1, arg2, 
342 			join, 1.0, 0.0, dx, dy, mwidth ) )
343 			return( -1 );
344 	}
345 	else if( vips_isprefix( "#LRROTSCALE ", line ) ||
346 		vips_isprefix( "#TBROTSCALE ", line ) ) {
347 		char *item[MAX_ITEMS];
348 		int nitems;
349 		JoinType type;
350 		JoinNode *arg1, *arg2, *join;
351 		double a, b, dx, dy;
352 		int mwidth;
353 		if( (nitems = break_items( line, item )) &lt; 0 )
354 			return( -1 );
355 		if( nitems != 7 &amp;&amp; nitems != 8 ) {
356 			vips_error( "global_balance", 
357 				"%s", _( "bad number of args in join1 line" ) );
358 			return( -1 );
359 		}
360 		if( !(arg1 = add_node( st, item[0] )) ||
361 			!(arg2 = add_node( st, item[1] )) ||
362 			!(join = add_node( st, item[2] )) )
363 			return( -1 );
364 		a = g_ascii_strtod( item[3], NULL );
365 		b = g_ascii_strtod( item[4], NULL );
366 		dx = g_ascii_strtod( item[5], NULL );
367 		dy = g_ascii_strtod( item[6], NULL );
368 		if( nitems == 8 )
369 			mwidth = atoi( item[7] );
370 		else
371 			mwidth = -1;
372 		if( vips_isprefix( "#LRROTSCALE ", line ) )
373 			type = JOIN_LRROTSCALE;
374 		else
375 			type = JOIN_TBROTSCALE;
376 		if( make_join( st, type, arg1, arg2, 
377 			join, a, b, dx, dy, mwidth ) )
378 			return( -1 );
379 	}
380 	else if( vips_isprefix( "copy ", line ) ) {
381 		char *item[MAX_ITEMS];
382 		int nitems;
383 		JoinNode *before, *after;
384 		if( (nitems = break_items( line, item )) &lt; 0 )
385 			return( -1 );
386 		if( nitems != 2 ) {
387 			vips_error( "global_balance", 
388 				"%s", _( "bad number of args in copy line" ) );
389 			return( -1 );
390 		}
391 		if( !(before = add_node( st, item[0] )) ||
392 			!(after = add_node( st, item[1] )) ||
393 			make_copy( st, before, after ) )
394 			return( -1 );
395 	}
396 	return( 0 );
397 }
398 static void *
399 set_referenced( JoinNode *node, void *a, void *b )
400 {
401 	if( node-&gt;arg1 )
402 		node-&gt;arg1-&gt;dirty = 1;
403 	if( node-&gt;arg2 )
404 		node-&gt;arg2-&gt;dirty = 1;
405 	return( NULL );
406 }
407 static void *
408 is_root( JoinNode *node, void *a, void *b )
409 {
410 	if( !node-&gt;dirty )
411 		return( (void *) node );
412 	else
413 		return( NULL );
414 }
415 static JoinNode *
416 find_root( SymbolTable *st )
417 {
418 	JoinNode *root;
419 	clean_table( st );
420 	vips__map_table( st, (VipsSListMap2Fn) set_referenced, NULL, NULL );
421 	root = (JoinNode *) vips__map_table( st, 
422 		(VipsSListMap2Fn) is_root, NULL, NULL );
423 	if( !root ) {
424 		vips_error( "vips_global_balance", 
425 			"%s", _( "mosaic root not found in desc file\n"
426 			"is this really a mosaiced image?" ) );
427 		return( NULL );
428 	}
429 	root-&gt;dirty = 1;
430 	if( vips__map_table( st, (VipsSListMap2Fn) is_root, NULL, NULL ) ) {
431 		vips_error( "vips_global_balance", 
432 			"%s", _( "more than one root" ) );
433 		return( NULL );
434 	}
435 	return( root );
436 }
437 int
438 vips__parse_desc( SymbolTable *st, VipsImage *in )
439 {
440 	GSList *p;
441 	for( p = in-&gt;history_list; p; p = p-&gt;next ) {
442 		GValue *value = (GValue *) p-&gt;data;
443 		g_assert( G_VALUE_TYPE( value ) == VIPS_TYPE_REF_STRING );
444 		if( process_line( st, vips_value_get_ref_string( value, NULL ) ) )
445 			return( -1 );
446 	}
447 	if( !(st-&gt;root = find_root( st )) )
448 		return( -1 );
449 	return( 0 );
450 }
451 static void *
452 count_leaves( JoinNode *node, void *a, void *b )
453 {
454 	if( node-&gt;type == JOIN_LEAF ) {
455 		node-&gt;index = node-&gt;st-&gt;nim;
456 		node-&gt;st-&gt;nim++;
457 	}
458 	return( NULL );
459 }
460 #ifdef DEBUG
461 static void
462 print_node( JoinNode *node )
463 {
464 	char *basename = g_path_get_basename( node-&gt;name );
465 	printf( "%s, position %dx%d, size %dx%d, index %d\n",
466 		basename,
467 		node-&gt;cumtrn.oarea.left, node-&gt;cumtrn.oarea.top,
468 		node-&gt;cumtrn.oarea.width, node-&gt;cumtrn.oarea.height,
469 		node-&gt;index );
470 	g_free( basename );
471 }
472 #ifdef DEBUG
473 static void *
474 print_leaf( JoinNode *node, void *a, void *b )
475 {
476 	if( node-&gt;type == JOIN_LEAF ) 
477 		print_node( node );
478 	return( NULL );
479 }
480 static void *
481 count_joins( JoinNode *node, void *a, void *b )
482 {
483 	if( node-&gt;type == JOIN_TB ||
484 		node-&gt;type == JOIN_LR ||
485 		node-&gt;type == JOIN_LRROTSCALE ||
486 		node-&gt;type == JOIN_TBROTSCALE )
487 		node-&gt;st-&gt;njoin++;
488 	return( NULL );
489 }
490 #ifdef DEBUG
491 static void
492 spc( int n )
493 {
494 	int i;
495 	for( i = 0; i &lt; n; i++ )
496 		printf( " " );
497 }
498 #ifdef DEBUG
499 static char *
500 JoinType2char( JoinType type )
501 {
502 	switch( type ) {
503 	case JOIN_LR: 		return( "JOIN_LR" );
504 	case JOIN_TB: 		return( "JOIN_TB" );
505 	case JOIN_LRROTSCALE: 	return( "JOIN_LRROTSCALE" );
506 	case JOIN_TBROTSCALE: 	return( "JOIN_TBROTSCALE" );
507 	case JOIN_CP: 		return( "JOIN_CP" );
508 	case JOIN_LEAF: 	return( "JOIN_LEAF" );
509 	default:
510 		vips_error_exit( "internal error #9275" );
511 		return( NULL );
512 	}
513 }
514 #ifdef DEBUG
515 static void *
516 print_joins( JoinNode *node, int indent )
517 {
518 	char *basename = g_path_get_basename( node-&gt;name );
519 	switch( node-&gt;type ) {
520 	case JOIN_TB:
521 	case JOIN_LR:
522 	case JOIN_TBROTSCALE:
523 	case JOIN_LRROTSCALE:
524 		spc( indent );
525 		printf( "%s to make %s, size %dx%d, pos. %dx%d, of:\n", 
526 			JoinType2char( node-&gt;type ), 
527 			basename,
528 			node-&gt;cumtrn.oarea.width, node-&gt;cumtrn.oarea.height,
529 			node-&gt;cumtrn.oarea.left, node-&gt;cumtrn.oarea.top );
530 		spc( indent );
531 		printf( "reference:\n" );
532 		print_joins( node-&gt;arg1, indent + 2 );
533 		spc( indent );
534 		printf( "secondary:\n" );
535 		print_joins( node-&gt;arg2, indent + 2 );
536 		break;
537 	case JOIN_CP:
538 		spc( indent );
539 		printf( "copy to make %s of:\n", basename );
540 		print_joins( node-&gt;arg1, indent + 2 );
541 		break;
542 	case JOIN_LEAF:
543 		spc( indent );
544 		printf( "input image %s\n", basename );
545 		break;
546 	}
547 	g_free( basename );
548 	return( NULL );
549 }
550 #ifdef DEBUG
551 static void *
552 print_overlap( OverlapInfo *lap, void *a, void *b )
553 {
554 	char *basename_node = g_path_get_basename( lap-&gt;node-&gt;name );
555 	char *basename_other = g_path_get_basename( lap-&gt;other-&gt;name );
556 	printf( "-&gt; %s overlaps with %s; (this, other) = (%.4G, %.4G)\n",
557 		basename_node,
558 		basename_other,
559 		*VIPS_MATRIX( lap-&gt;nstats, 4, 0 ),
560 		*VIPS_MATRIX( lap-&gt;ostats, 4, 0 ) );
561 	g_free( basename_node );
562 	g_free( basename_other );
563 	return( NULL );
564 }
565 #ifdef DEBUG
566 static void *
567 print_overlaps( JoinNode *node, void *a, void *b )
568 {
569 	char *basename;
570 	if( node-&gt;type == JOIN_LEAF &amp;&amp; g_slist_length( node-&gt;overlaps ) &gt; 0 ) {
571 		basename = g_path_get_basename( node-&gt;name );
572 		printf( "overlap of %s with:\n", basename );
573 		g_free( basename );
574 		vips_slist_map2( node-&gt;overlaps, 
575 			(VipsSListMap2Fn) print_overlap, NULL, NULL );
576 	}
577 	return( NULL );
578 }
579 #ifdef DEBUG
580 static void *
581 print_overlap_error( OverlapInfo *lap, double *fac, double *total )
582 {
583 	char *basename_other = g_path_get_basename( lap-&gt;other-&gt;name );
584 	double na = *VIPS_MATRIX( lap-&gt;nstats, 4, 0 );
585 	double oa = *VIPS_MATRIX( lap-&gt;ostats, 4, 0 );
586 	double err;
587 	if( fac ) {
588 		na *= fac[lap-&gt;node-&gt;index];
589 		oa *= fac[lap-&gt;other-&gt;index];
590 	}
591 	err = na - oa;
592 	printf( "-&gt; file %s, error = %g\n",
593 		basename_other, err );
594 	*total += err * err;
595 	g_free( basename_other );
596 	return( NULL );
597 }
598 #ifdef DEBUG
599 static void *
600 print_overlap_errors( JoinNode *node, double *fac, double *total )
601 {
602 	char *basename;
603 	if( node-&gt;type == JOIN_LEAF &amp;&amp; g_slist_length( node-&gt;overlaps ) &gt; 0 ) {
604 		basename = g_path_get_basename( node-&gt;name );
605 		printf( "overlap of %s (index %d) with:\n", basename, 
606 			node-&gt;index );
607 		g_free( basename );
608 		vips_slist_map2( node-&gt;overlaps, 
609 			(VipsSListMap2Fn) print_overlap_error, fac, total );
610 	}
611 	return( NULL );
612 }
613 static int
614 extract_rect( VipsImage *in, VipsImage **out, VipsRect *r )
615 {
616 	return( vips_extract_area( in, out, 
617 		r-&gt;left, r-&gt;top, r-&gt;width, r-&gt;height, NULL ) );
618 }
619 static int
620 make_overlap_mask( VipsImage *mem, 
621 	VipsImage *ref, VipsImage *sec, VipsImage **mask, 
622 	VipsRect *rarea, VipsRect *sarea )
623 {
624 	VipsImage **t = (VipsImage **) 
625 		vips_object_local_array( VIPS_OBJECT( mem ), 6 );
626 	if( extract_rect( ref, &amp;t[0], rarea ) ||
627 		extract_rect( sec, &amp;t[1], sarea ) ||
628 		vips_extract_band( t[0], &amp;t[2], 0, NULL ) ||
629 		vips_extract_band( t[1], &amp;t[3], 0, NULL ) ||
630 		vips_notequal_const1( t[2], &amp;t[4], 0.0, NULL ) ||
631 		vips_notequal_const1( t[3], &amp;t[5], 0.0, NULL ) ||
632 		vips_andimage( t[4], t[5], mask, NULL ) ) 
633 		return( -1 );
634 	return( 0 );
635 }
636 static int
637 count_nonzero( VipsImage *in, gint64 *count )
638 {
639 	double avg;
640 	if( vips_avg( in, &amp;avg, NULL ) )
641 		return( -1 );
642 	*count = (avg * VIPS_IMAGE_N_PELS( in )) / 255.0;
643 	return( 0 );
644 }
645 static VipsImage *
646 find_image_stats( VipsImage *mem, 
647 	VipsImage *in, VipsImage *mask, VipsRect *area )
648 {
649 	VipsImage **t = (VipsImage **) 
650 		vips_object_local_array( VIPS_OBJECT( mem ), 5 );
651 	gint64 count;
652 	if( extract_rect( in, &amp;t[0], area ) ||
653 		vips_black( &amp;t[1], t[0]-&gt;Xsize, t[0]-&gt;Ysize, 
654 			"bands", t[0]-&gt;Bands, 
655 			NULL ) ||
656 		vips_cast( t[1], &amp;t[2], t[0]-&gt;BandFmt, NULL ) ||
657 		vips_ifthenelse( mask, t[0], t[2], &amp;t[3], NULL ) )
658 		return( NULL );
659 	if( vips_stats( t[3], &amp;t[4], NULL ) )
660 		return( NULL );
661 	if( count_nonzero( mask, &amp;count ) )
662 		return( NULL );
663 	*VIPS_MATRIX( t[4], 4, 0 ) *= 
664 		(double) count / VIPS_IMAGE_N_PELS( mask );
665 	*VIPS_MATRIX( t[4], 5, 0 )  = count;
666 #ifdef DEBUG
667 	if( count == 0 )
668 		g_warning( "global_balance %s", _( "empty overlap!" ) );
669 	return( t[4] );
670 }
671 static int
672 find_overlap_stats( OverlapInfo *lap )
673 {
674 	VipsImage *mem = lap-&gt;node-&gt;st-&gt;im;
675 	VipsImage **t = (VipsImage **) 
676 		vips_object_local_array( VIPS_OBJECT( mem ), 1 );
677 	VipsRect rarea, sarea;
678 	rarea = lap-&gt;overlap;
679 	rarea.left -= lap-&gt;node-&gt;cumtrn.oarea.left;
680 	rarea.top -= lap-&gt;node-&gt;cumtrn.oarea.top;
681 	sarea = lap-&gt;overlap;
682 	sarea.left -= lap-&gt;other-&gt;cumtrn.oarea.left;
683 	sarea.top -= lap-&gt;other-&gt;cumtrn.oarea.top;
684 	if( make_overlap_mask( mem, 
685 		lap-&gt;node-&gt;trnim, lap-&gt;other-&gt;trnim, &amp;t[0], &amp;rarea, &amp;sarea ) )
686 		return( -1 );
687 	if( !(lap-&gt;nstats = find_image_stats( mem, 
688 		lap-&gt;node-&gt;trnim, t[0], &amp;rarea )) )
689 		return( -1 );
690 	if( !(lap-&gt;ostats = find_image_stats( mem, 
691 		lap-&gt;other-&gt;trnim, t[0], &amp;sarea )) )
692 		return( -1 );
693 	return( 0 );
694 }
695 static void *
696 overlap_eq( OverlapInfo *this, JoinNode *node, void *b )
697 {
698 	if( this-&gt;other == node )
699 		return( this );
700 	else
701 		return( NULL );
702 }
703 static void *
704 test_overlap( JoinNode *other, JoinNode *node, void *b )
705 {
706 	VipsRect overlap;
707 	OverlapInfo *lap;
708 	if( other-&gt;type != JOIN_LEAF || node == other ) 
709 		return( NULL );
710 	vips_rect_intersectrect( &amp;node-&gt;cumtrn.oarea, &amp;other-&gt;cumtrn.oarea, 
711 		&amp;overlap );
712 	if( vips_rect_isempty( &amp;overlap ) ) 
713 		return( NULL );
714 	if( overlap.width * overlap.height &lt; TRIVIAL )
715 		return( NULL );
716 	if( vips_slist_map2( other-&gt;overlaps, 
717 		(VipsSListMap2Fn) overlap_eq, node, NULL ) )
718 		return( NULL );
719 	if( !(lap = build_overlap( node, other, &amp;overlap )) )
720 		return( node );
721 	if( find_overlap_stats( lap ) ) 
722 		return( node );
723 	if( *VIPS_MATRIX( lap-&gt;nstats, 5, 0 ) &lt; TRIVIAL ||
724 		*VIPS_MATRIX( lap-&gt;ostats, 5, 0 ) &lt; TRIVIAL ) {
725 #ifdef DEBUG
726 		printf( "trivial overlap ... junking\n" );
727 		printf( "nstats count = %g, ostats count = %g\n",
728 			*VIPS_MATRIX( lap-&gt;nstats, 5, 0 ), *VIPS_MATRIX( lap-&gt;ostats, 5, 0 ) );
729 		print_overlap( lap, NULL, NULL );
730 		overlap_destroy( lap );
731 	}
732 	return( NULL );
733 }
734 static void *
735 find_overlaps( JoinNode *node, SymbolTable *st, void *b )
736 {
737 	if( node-&gt;type == JOIN_LEAF ) {
738 		if( !node-&gt;im ) {
739 			vips_error( "vips_global_balance", 
740 				_( "unable to open \"%s\"" ), node-&gt;name );
741 			return( node );
742 		}
743 		if( !node-&gt;trnim ) 
744 			vips_error_exit( "global_balance: sanity failure #9834" );
745 		return( vips__map_table( st, 
746 			(VipsSListMap2Fn) test_overlap, node, NULL ) );
747 	}
748 	return( NULL );
749 }
750 typedef struct {
751 	SymbolTable *st;			JoinNode *leaf;				VipsImage *K;				VipsImage *M;				int row;			} MatrixBundle;
752 static void *
753 add_nominated( OverlapInfo *ovl, MatrixBundle *bun, double *gamma )
754 {
755 	double ns = pow( *VIPS_MATRIX( ovl-&gt;nstats, 4, 0 ), 1.0 / (*gamma) );
756 	double os = pow( *VIPS_MATRIX( ovl-&gt;ostats, 4, 0 ), 1.0 / (*gamma) );
757 	*VIPS_MATRIX( bun-&gt;K, 0, bun-&gt;row ) = ns;
758 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;other-&gt;index - 1, bun-&gt;row ) = os;
759 	bun-&gt;row++;
760 	return( NULL );
761 }
762 static void *
763 add_other( OverlapInfo *ovl, MatrixBundle *bun, double *gamma )
764 {
765 	double ns = -pow( *VIPS_MATRIX( ovl-&gt;nstats, 4, 0 ), 1.0 / (*gamma) );
766 	double os = pow( *VIPS_MATRIX( ovl-&gt;ostats, 4, 0 ), 1.0 / (*gamma) );
767 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;node-&gt;index - 1, bun-&gt;row ) = ns;
768 	*VIPS_MATRIX( bun-&gt;M, ovl-&gt;other-&gt;index - 1, bun-&gt;row ) = os;
769 	bun-&gt;row++;
770 	return( NULL );
771 }
772 static void *
773 add_row( JoinNode *node, MatrixBundle *bun, double *gamma )
774 {
775 	if( node == bun-&gt;leaf )
776 		vips_slist_map2( node-&gt;overlaps, 
777 			(VipsSListMap2Fn) add_nominated, bun, gamma );
778 	else
779 		vips_slist_map2( node-&gt;overlaps, 
780 			(VipsSListMap2Fn) add_other, bun, gamma );
781 	return( NULL );
782 }
783 static void
784 fill_matrices( SymbolTable *st, double gamma, VipsImage *K, VipsImage *M )
785 {
786 	MatrixBundle bun;
787 	bun.st = st;
788 	bun.leaf = st-&gt;leaf;
789 	bun.K = K;
790 	bun.M = M;
791 	bun.row = 0;
792 	vips__map_table( st, (VipsSListMap2Fn) add_row, &amp;bun, &amp;gamma );
793 }
794 static void *
795 choose_leaf( JoinNode *node, void *a, void *b )
796 {
797 	if( node-&gt;type == JOIN_LEAF )
798 		return( node );
799 	return( NULL );
800 }
801 static VipsImage *
802 make_mos_image( SymbolTable *st, JoinNode *node, transform_fn tfn, void *a )
803 {
804 	VipsImage *im1, *im2, *out;
805 	switch( node-&gt;type ) {
806 	case JOIN_LR:
807 	case JOIN_TB:
808 		if( !(im1 = make_mos_image( st, node-&gt;arg1, tfn, a )) ||
809 			!(im2 = make_mos_image( st, node-&gt;arg2, tfn, a )) )
810 			return( NULL );
811 		if( vips_merge( im1, im2, &amp;out, 
812 			node-&gt;type == JOIN_LR ? 
813 				VIPS_DIRECTION_HORIZONTAL : 
814 				VIPS_DIRECTION_VERTICAL,
815 			-node-&gt;dx, -node-&gt;dy, 
816 			"mblend", node-&gt;mwidth,
817 			NULL ) )
818 			return( NULL );
819 		vips_object_local( st-&gt;im, out );
820 		vips_image_set_string( out, "mosaic-name", node-&gt;name );
821 		break;
822 	case JOIN_LRROTSCALE:
823 	case JOIN_TBROTSCALE:
824 		if( !(im1 = make_mos_image( st, node-&gt;arg1, tfn, a )) ||
825 			!(im2 = make_mos_image( st, node-&gt;arg2, tfn, a )) )
826 			return( NULL );
827 		out = vips_image_new();
828 		vips_object_local( st-&gt;im, out );
829 		vips_image_set_string( out, "mosaic-name", node-&gt;name );
830 		if( node-&gt;type == JOIN_LRROTSCALE ) {
831 			if( vips__lrmerge1( im1, im2, out, 
832 				node-&gt;a, node-&gt;b, node-&gt;dx, node-&gt;dy,
833 				node-&gt;mwidth ) )
834 				return( NULL );
835 		}
836 		else {
837 			if( vips__tbmerge1( im1, im2, out, 
838 				node-&gt;a, node-&gt;b, node-&gt;dx, node-&gt;dy,
839 				node-&gt;mwidth ) )
840 				return( NULL );
841 		}
842 		break;
843 	case JOIN_LEAF:
844 		if( !(out = tfn( node, a )) )
845 			return( NULL );
846 		break;
847 	case JOIN_CP:
848 		out = make_mos_image( st, node-&gt;arg1, tfn, a );
849 		break;
850 	default:
851 		vips_error_exit( "internal error #982369824375987" );
852 		return( NULL );
853 	}
854 	return( out );
855 }
856 int
857 vips__build_mosaic( SymbolTable *st, VipsImage *out, transform_fn tfn, void *a )
858 {
859 	JoinNode *root = st-&gt;root;
860 	VipsImage *im1, *im2;
861 	VipsImage *x;
862 	switch( root-&gt;type ) {
863 	case JOIN_LR:
864 	case JOIN_TB:
865 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
866 			!(im2 = make_mos_image( st, root-&gt;arg2, tfn, a )) )
867 			return( -1 );
868 		if( vips_merge( im1, im2, &amp;x, 
869 			root-&gt;type == JOIN_LR ? 
870 				VIPS_DIRECTION_HORIZONTAL : 
871 				VIPS_DIRECTION_VERTICAL,
872 			-root-&gt;dx, -root-&gt;dy, 
873 			"mblend", root-&gt;mwidth,
874 			NULL ) )
875 			return( -1 );
876 		if( vips_image_write( x, out ) ) {
877 			g_object_unref( x );
878 			return( -1 );
879 		}
880 		g_object_unref( x );
881 		break;
882 	case JOIN_LRROTSCALE:
883 	case JOIN_TBROTSCALE:
884 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
885 			!(im2 = make_mos_image( st, root-&gt;arg2, tfn, a )) )
886 			return( -1 );
887 		if( root-&gt;type == JOIN_LRROTSCALE ) {
888 			if( vips__lrmerge1( im1, im2, out, 
889 				root-&gt;a, root-&gt;b, root-&gt;dx, root-&gt;dy,
890 				root-&gt;mwidth ) )
891 				return( -1 );
892 		}
893 		else {
894 			if( vips__tbmerge1( im1, im2, out, 
895 				root-&gt;a, root-&gt;b, root-&gt;dx, root-&gt;dy,
896 				root-&gt;mwidth ) )
897 				return( -1 );
898 		}
899 		break;
900 	case JOIN_LEAF:
901 		if( !(im1 = tfn( root, a )) || 
902 			vips_image_write( im1, out ) )
903 			return( -1 );
904 		break;
905 	case JOIN_CP:
906 		if( !(im1 = make_mos_image( st, root-&gt;arg1, tfn, a )) ||
907 			vips_image_write( im1, out ) )
908 			return( -1 );
909 		break;
910 	default:
911 		vips_error_exit( "internal error #982369824375987" );
912 	}
913 	return( 0 );
914 }
915 static int
916 vips__matrixtranspose( VipsImage *in, VipsImage **out )
917 {
918 	int yc, xc;
919 	if( !(*out = vips_image_new_matrix( in-&gt;Ysize, in-&gt;Xsize )) )
920 		return( -1 );
921 	for( yc = 0; yc &lt; (*out)-&gt;Ysize; ++yc )
922 		for( xc = 0; xc &lt; (*out)-&gt;Xsize; ++xc )
923 			*VIPS_MATRIX( *out, xc, yc ) = *VIPS_MATRIX( in, yc, xc );
924 	return( 0 );
925 }
926 static int
927 vips__matrixmultiply( VipsImage *in1, VipsImage *in2, VipsImage **out )
928 {
929 	int xc, yc, col;
930 	double sum;
931 	double *mat, *a, *b;
932 	double *s1, *s2;
933 	if( in1-&gt;Xsize != in2-&gt;Ysize ) {
934 		vips_error( "vips__matrixmultiply", "%s", _( "bad sizes" ) );
935 		return( -1 );
936 	}
937 	if( !(*out = vips_image_new_matrix( in2-&gt;Xsize, in1-&gt;Ysize  )) )
938 		return( -1 );
939 	mat = VIPS_MATRIX( *out, 0, 0 );
940 	s1 = VIPS_MATRIX( in1, 0, 0 );
941 	for( yc = 0; yc &lt; in1-&gt;Ysize; yc++ ) {
942 		s2 = VIPS_MATRIX( in2, 0, 0 );
943 		for( col = 0; col &lt; in2-&gt;Xsize; col++ ) {
944 			a = s1;
945 			b = s2;
946 			for( sum = 0.0, xc = 0; xc &lt; in1-&gt;Xsize; xc++ ) {
947 				sum += *a++ * *b;
948 				b += in2-&gt;Xsize;
949 			}
950 			*mat++ = sum;
951 			s2++;
952 		}
953 		s1 += in1-&gt;Xsize;
954 	}
955 	return( 0 );
956 }
957 static int
958 find_factors( SymbolTable *st, double gamma )
959 {
960 	VipsImage **t = (VipsImage **) 
961 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 7 );
962 	double total;
963 	double avg;
964 	int i;
965 	if( !(t[0] = vips_image_new_matrix( 1, st-&gt;novl )) ||
966 		!(t[1] = vips_image_new_matrix( st-&gt;nim - 1, st-&gt;novl )) )
967 		return( -1 );
968 	fill_matrices( st, gamma, t[0], t[1] );
969 #ifdef DEBUG
970 	vips_image_write_to_file( t[0], "K.mat", NULL ); 
971 	vips_image_write_to_file( t[1], "M.mat", NULL );
972 	if( vips__matrixtranspose( t[1], &amp;t[2] ) ||
973 		vips__matrixmultiply( t[2], t[1], &amp;t[3] ) ||
974 		vips_matrixinvert( t[3], &amp;t[4], NULL ) ||
975 		vips__matrixmultiply( t[4], t[2], &amp;t[5] ) ||
976 		vips__matrixmultiply( t[5], t[0], &amp;t[6] ) )
977 		return( -1 );
978 	if( !(st-&gt;fac = VIPS_ARRAY( st-&gt;im, st-&gt;nim, double )) )
979 		return( -1 );
980 	for( i = 0; i &lt; t[6]-&gt;Ysize; i++ )
981 		st-&gt;fac[i + 1] = *VIPS_MATRIX( t[6], 0, i );
982 	st-&gt;fac[0] = 1.0;
983 	total = 0.0;
984 	for( i = 0; i &lt; st-&gt;nim; i++ )
985 		total += st-&gt;fac[i];
986 	avg = total / st-&gt;nim;
987 	for( i = 0; i &lt; st-&gt;nim; i++ )
988 		st-&gt;fac[i] /= avg;
989 #ifdef DEBUG
990 	printf( "debugging output for vips_global_balance():\n" );
991 	for( i = 0; i &lt; st-&gt;nim; i++ )
992 		printf( "balance factor %d = %g\n", i, st-&gt;fac[i] );
993 	total = 0.0;
994 	printf( "Overlap errors:\n" );
995 	vips__map_table( st, 
996 		(VipsSListMap2Fn) print_overlap_errors, NULL, &amp;total );
997 	printf( "RMS error = %g\n", sqrt( total / st-&gt;novl ) );
998 	total = 0.0;
999 	printf( "Overlap errors after adjustment:\n" );
1000 	vips__map_table( st, 
1001 		(VipsSListMap2Fn) print_overlap_errors, st-&gt;fac, &amp;total );
1002 	printf( "RMS error = %g\n", sqrt( total / st-&gt;novl ) );
1003 	return( 0 );
1004 }
1005 int
1006 vips__affinei( VipsImage *in, VipsImage *out, VipsTransformation *trn )
1007 {
1008 	VipsImage **t = (VipsImage **)
1009 		vips_object_local_array( VIPS_OBJECT( out ), 2 );
1010 	VipsArea *oarea;
1011 	gboolean repack;
1012 	oarea = VIPS_AREA( vips_array_int_newv( 4,
1013 		trn-&gt;oarea.left, trn-&gt;oarea.top,
1014 		trn-&gt;oarea.width, trn-&gt;oarea.height ) );
1015 	repack = in-&gt;Coding == VIPS_CODING_LABQ;
1016 	if( vips_affine( in, &amp;t[0],
1017 		trn-&gt;a, trn-&gt;b, trn-&gt;c, trn-&gt;d,
1018 		"oarea", oarea,
1019 		"odx", trn-&gt;odx,
1020 		"ody", trn-&gt;ody,
1021 		NULL ) ) {
1022 		vips_area_unref( oarea );
1023 		return( -1 );
1024 	}
1025 	vips_area_unref( oarea );
1026 	in = t[0];
1027 	if( repack ) {
1028 		if (vips_colourspace( in, &amp;t[1],
1029 			VIPS_INTERPRETATION_LABQ, NULL ) )
1030 			return ( -1 );
1031 		in = t[1];
1032 	}
1033 	if( vips_image_write( in, out ) )
1034 		return( -1 );
1035 	return( 0 );
1036 }
1037 static void *
1038 generate_trn_leaves( JoinNode *node, SymbolTable *st, void *b )
1039 {
1040 	if( node-&gt;type == JOIN_LEAF ) {
1041 		if( !node-&gt;im ) {
1042 			vips_error( "vips_global_balance", 
1043 				_( "unable to open \"%s\"" ), node-&gt;name );
1044 			return( node );
1045 		}
1046 		if( node-&gt;trnim ) 
1047 			vips_error_exit( "global_balance: sanity failure #765" );
1048 		if( vips__transform_isidentity( &amp;node-&gt;cumtrn ) )
1049 			node-&gt;trnim = node-&gt;im;
1050 		else {
1051 			node-&gt;trnim = vips_image_new();
1052 			vips_object_local( node-&gt;st-&gt;im, node-&gt;trnim );
1053 			if ( vips__affinei( node-&gt;im, node-&gt;trnim, &amp;node-&gt;cumtrn ) )
1054 				return( node );
1055 		}
1056 	}
1057 	return( NULL );
1058 }
1059 static int
1060 analyse_mosaic( SymbolTable *st, VipsImage *in )
1061 {
1062 	if( vips__parse_desc( st, in ) )
1063 		return( -1 );
1064 #ifdef DEBUG
1065 	printf( "Input files:\n" );
1066 	vips__map_table( st, (VipsSListMap2Fn) print_leaf, NULL, NULL );
1067 	printf( "\nOutput file:\n" );
1068 	print_node( st-&gt;root );
1069 	printf( "\nJoin commands:\n" );
1070 	print_joins( st-&gt;root, 0 );
1071 	if( vips__map_table( st, 
1072 		(VipsSListMap2Fn) generate_trn_leaves, st, NULL ) )
1073 		return( -1 );
1074 	if( vips__map_table( st, (VipsSListMap2Fn) find_overlaps, st, NULL ) )
1075 		return( -1 );
1076 	vips__map_table( st, (VipsSListMap2Fn) count_leaves, NULL, NULL );
1077 	vips__map_table( st, (VipsSListMap2Fn) count_joins, NULL, NULL );
1078 	st-&gt;leaf = vips__map_table( st, 
1079 		(VipsSListMap2Fn) choose_leaf, NULL, NULL );
1080 #ifdef DEBUG
1081 	printf( "\nLeaf to be 1.000:\n" );
1082 	print_node( st-&gt;leaf );
1083 	printf( "\nOverlaps:\n" );
1084 	vips__map_table( st, (VipsSListMap2Fn) print_overlaps, NULL, NULL );
1085 	printf( "\n%d input files, %d unique overlaps, %d joins\n", 
1086 		st-&gt;nim, st-&gt;novl, st-&gt;njoin );
1087 	return( 0 );
1088 }
1089 static VipsImage *
1090 transform( JoinNode *node, double *gamma )
1091 {
1092 	SymbolTable *st = node-&gt;st;
1093 	VipsImage *in = node-&gt;im;
1094 	double fac = st-&gt;fac[node-&gt;index];
1095 	VipsImage **t = (VipsImage **)
1096 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 8 );
1097 	VipsImage *out;
1098 	if( fac == 1.0 ) {
1099 		out = in;
1100 	}
1101 	else if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR || 
1102 		in-&gt;BandFmt == VIPS_FORMAT_USHORT ) {
1103 		if( vips_identity( &amp;t[0],
1104 				"bands", 1,
1105 				"ushort", in-&gt;BandFmt == VIPS_FORMAT_USHORT,
1106 				NULL ) ||
1107 			vips_pow_const1( t[0], &amp;t[1],
1108 				1.0 / (*gamma), NULL ) ||
1109 			vips_linear1( t[1], &amp;t[2], fac, 0.0, NULL ) ||
1110 			vips_pow_const1( t[2], &amp;t[3], *gamma, NULL ) ||
1111 			vips_cast( t[3], &amp;t[4], in-&gt;BandFmt, NULL ) ||
1112 			vips_maplut( in, &amp;t[5], t[4], NULL ) )
1113 			return( NULL );
1114 		out = t[5];
1115 	}
1116 	else {
1117 		if( vips_linear1( in, &amp;t[6], fac, 0.0, NULL ) ||
1118 			vips_cast( t[6], &amp;t[7], in-&gt;BandFmt, NULL ) )
1119 			return( NULL );
1120 		out = t[7];
1121 	}
1122 	vips_image_set_string( out, "mosaic-name", node-&gt;name );
1123 	return( out );
1124 }
1125 static VipsImage *
1126 transformf( JoinNode *node, double *gamma )
1127 {
1128 	SymbolTable *st = node-&gt;st;
1129 	VipsImage *in = node-&gt;im;
1130 	double fac = node-&gt;st-&gt;fac[node-&gt;index];
1131 	VipsImage **t = (VipsImage **) 
1132 		vips_object_local_array( VIPS_OBJECT( st-&gt;im ), 6 );
1133 	VipsImage *out;
1134 	if( fac == 1.0 ) {
1135 		out = in;
1136 	}
1137 	else if( in-&gt;BandFmt == VIPS_FORMAT_UCHAR || 
1138 		in-&gt;BandFmt == VIPS_FORMAT_USHORT ) {
1139 		if( vips_identity( &amp;t[0],
1140 				"bands", 1,
1141 				"ushort", in-&gt;BandFmt == VIPS_FORMAT_USHORT,
1142 				NULL ) ||
1143 			vips_pow_const1( t[0], &amp;t[1],
1144 				1.0 / (*gamma), NULL ) ||
1145 			vips_linear1( t[1], &amp;t[2], fac, 0.0, NULL ) ||
1146 			vips_pow_const1( t[2], &amp;t[3], *gamma, NULL ) ||
1147 			vips_maplut( in, &amp;t[4], t[3], NULL ) )
1148 			return( NULL );
1149 		out = t[4];
1150 	}
1151 	else {
1152 		if( vips_linear1( in, &amp;t[5], fac, 0.0, NULL ) )
1153 			return( NULL );
1154 		out = t[5];
1155 	}
1156 	vips_image_set_string( out, "mosaic-name", node-&gt;name );
1157 	return( out );
1158 }
1159 typedef struct {
1160 	VipsOperation parent_instance;
1161 	VipsImage *in;
1162 	VipsImage *out;
1163 	gboolean int_output;
1164 	double gamma;
1165 } VipsGlobalbalance;
1166 typedef VipsOperationClass VipsGlobalbalanceClass;
1167 G_DEFINE_TYPE( VipsGlobalbalance, vips_globalbalance, VIPS_TYPE_OPERATION );
1168 static int
1169 vips_globalbalance_build( VipsObject *object )
1170 {
1171 	VipsGlobalbalance *globalbalance = (VipsGlobalbalance *) object;
1172 	SymbolTable *st;
1173 	transform_fn trn;
1174 	g_object_set( globalbalance, "out", vips_image_new(), NULL ); 
1175 	if( VIPS_OBJECT_CLASS( vips_globalbalance_parent_class )-&gt;
1176 		build( object ) )
1177 		return( -1 );
1178 	if( !(st = vips__build_symtab( globalbalance-&gt;out, SYM_TAB_SIZE )) ||
1179 		analyse_mosaic( st, globalbalance-&gt;in ) ||
1180 		find_factors( st, globalbalance-&gt;gamma ) )
1181 		return( -1 );
1182 	trn = globalbalance-&gt;int_output ? 
1183 		(transform_fn) transform : (transform_fn) transformf; 
1184 	if( vips__build_mosaic( st, globalbalance-&gt;out, 
1185 		trn, &amp;globalbalance-&gt;gamma ) )
1186 		return( -1 );
1187 	return( 0 );
1188 }
1189 static void
1190 vips_globalbalance_class_init( VipsGlobalbalanceClass *class )
1191 {
1192 	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
1193 	VipsObjectClass *object_class = (VipsObjectClass *) class;
1194 	gobject_class-&gt;set_property = vips_object_set_property;
1195 	gobject_class-&gt;get_property = vips_object_get_property;
1196 	object_class-&gt;nickname = "globalbalance";
1197 	object_class-&gt;description = _( "global balance an image mosaic" );
1198 	object_class-&gt;build = vips_globalbalance_build;
1199 	VIPS_ARG_IMAGE( class, "in", 1, 
1200 		_( "Input" ), 
1201 		_( "Input image" ),
1202 		VIPS_ARGUMENT_REQUIRED_INPUT, 
1203 		G_STRUCT_OFFSET( VipsGlobalbalance, in ) );
1204 	VIPS_ARG_IMAGE( class, "out", 2, 
1205 		_( "Output" ), 
1206 		_( "Output image" ),
1207 		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
1208 		G_STRUCT_OFFSET( VipsGlobalbalance, out ) );
1209 	VIPS_ARG_DOUBLE( class, "gamma", 5, 
1210 		_( "gamma" ), 
1211 		_( "Image gamma" ),
1212 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1213 		G_STRUCT_OFFSET( VipsGlobalbalance, gamma ),
1214 		0.00001, 10, 1.6 );
1215 	VIPS_ARG_BOOL( class, "int_output", 7, 
1216 		_( "Int output" ), 
1217 		_( "Integer output" ),
1218 		VIPS_ARGUMENT_OPTIONAL_INPUT,
1219 		G_STRUCT_OFFSET( VipsGlobalbalance, int_output ),
1220 		FALSE ); 
1221 }
1222 static void
1223 vips_globalbalance_init( VipsGlobalbalance *globalbalance )
1224 {
1225 	globalbalance-&gt;gamma = 1.6;
1226 }
1227 int 
1228 vips_globalbalance( VipsImage *in, VipsImage **out, ... )
1229 {
1230 	va_list ap;
1231 	int result;
1232 	va_start( ap, out );
1233 	result = vips_call_split( "globalbalance", ap, in, out );
1234 	va_end( ap );
1235 	return( result );
1236 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
