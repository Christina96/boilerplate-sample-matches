
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-document.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_DOCUMENT_H_
2  #define RAPIDJSON_DOCUMENT_H_
3  #include &quot;reader.h&quot;
4  #include &quot;internal/meta.h&quot;
5  #include &quot;internal/strfunc.h&quot;
6  #include &quot;memorystream.h&quot;
7  #include &quot;encodedstream.h&quot;
8  #include &lt;new&gt;      
9  #include &lt;limits&gt;
10  #ifdef __cpp_lib_three_way_comparison
11  #include &lt;compare&gt;
12  #endif
13  RAPIDJSON_DIAG_PUSH
14  #ifdef __clang__
15  RAPIDJSON_DIAG_OFF(padded)
16  RAPIDJSON_DIAG_OFF(switch-enum)
17  RAPIDJSON_DIAG_OFF(c++98-compat)
18  #elif defined(_MSC_VER)
19  RAPIDJSON_DIAG_OFF(4127) 
20  RAPIDJSON_DIAG_OFF(4244) 
21  #endif
22  #ifdef __GNUC__
23  RAPIDJSON_DIAG_OFF(effc++)
24  #endif 
25  #ifdef GetObject
26  #pragma push_macro(&quot;GetObject&quot;)
27  #define RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
28  #undef GetObject
29  #endif
30  #ifndef RAPIDJSON_NOMEMBERITERATORCLASS
31  #include &lt;iterator&gt; 
32  #endif
33  #if RAPIDJSON_USE_MEMBERSMAP
34  #include &lt;map&gt; 
35  #endif
36  RAPIDJSON_NAMESPACE_BEGIN
37  template &lt;typename Encoding, typename Allocator&gt;
38  class GenericValue;
39  template &lt;typename Encoding, typename Allocator, typename StackAllocator&gt;
40  class GenericDocument;
41  #ifndef RAPIDJSON_DEFAULT_ALLOCATOR
42  #define RAPIDJSON_DEFAULT_ALLOCATOR MemoryPoolAllocator&lt;CrtAllocator&gt;
43  #endif
44  #ifndef RAPIDJSON_DEFAULT_STACK_ALLOCATOR
45  #define RAPIDJSON_DEFAULT_STACK_ALLOCATOR CrtAllocator
46  #endif
47  #ifndef RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY
48  #define RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY 16
49  #endif
50  #ifndef RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY
51  #define RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY 16
52  #endif
53  template &lt;typename Encoding, typename Allocator&gt;
54  class GenericMember {
55  public:
56      GenericValue&lt;Encoding, Allocator&gt; name;     
57      GenericValue&lt;Encoding, Allocator&gt; value;    
58  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
59      GenericMember(GenericMember&amp;&amp; rhs) RAPIDJSON_NOEXCEPT
60          : name(std::move(rhs.name)),
61            value(std::move(rhs.value))
62      {
63      }
64      GenericMember&amp; operator=(GenericMember&amp;&amp; rhs) RAPIDJSON_NOEXCEPT {
65          return *this = static_cast&lt;GenericMember&amp;&gt;(rhs);
66      }
67  #endif
68      GenericMember&amp; operator=(GenericMember&amp; rhs) RAPIDJSON_NOEXCEPT {
69          if (RAPIDJSON_LIKELY(this != &amp;rhs)) {
70              name = rhs.name;
71              value = rhs.value;
72          }
73          return *this;
74      }
75      friend inline void swap(GenericMember&amp; a, GenericMember&amp; b) RAPIDJSON_NOEXCEPT {
76          a.name.Swap(b.name);
77          a.value.Swap(b.value);
78      }
79  private:
80      GenericMember(const GenericMember&amp; rhs);
81  };
82  #ifndef RAPIDJSON_NOMEMBERITERATORCLASS
83  template &lt;bool Const, typename Encoding, typename Allocator&gt;
84  class GenericMemberIterator {
85      friend class GenericValue&lt;Encoding,Allocator&gt;;
86      template &lt;bool, typename, typename&gt; friend class GenericMemberIterator;
87      typedef GenericMember&lt;Encoding,Allocator&gt; PlainType;
88      typedef typename internal::MaybeAddConst&lt;Const,PlainType&gt;::Type ValueType;
89  public:
90      typedef GenericMemberIterator Iterator;
91      typedef GenericMemberIterator&lt;true,Encoding,Allocator&gt;  ConstIterator;
92      typedef GenericMemberIterator&lt;false,Encoding,Allocator&gt; NonConstIterator;
93      typedef ValueType      value_type;
94      typedef ValueType *    pointer;
95      typedef ValueType &amp;    reference;
96      typedef std::ptrdiff_t difference_type;
97      typedef std::random_access_iterator_tag iterator_category;
98      typedef pointer         Pointer;
99      typedef reference       Reference;
100      typedef difference_type DifferenceType;
101      GenericMemberIterator() : ptr_() {}
102      GenericMemberIterator(const NonConstIterator &amp; it) : ptr_(it.ptr_) {}
103      Iterator&amp; operator=(const NonConstIterator &amp; it) { ptr_ = it.ptr_; return *this; }
104      Iterator&amp; operator++(){ ++ptr_; return *this; }
105      Iterator&amp; operator--(){ --ptr_; return *this; }
106      Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }
107      Iterator  operator--(int){ Iterator old(*this); --ptr_; return old; }
108      Iterator operator+(DifferenceType n) const { return Iterator(ptr_+n); }
109      Iterator operator-(DifferenceType n) const { return Iterator(ptr_-n); }
110      Iterator&amp; operator+=(DifferenceType n) { ptr_+=n; return *this; }
111      Iterator&amp; operator-=(DifferenceType n) { ptr_-=n; return *this; }
112      template &lt;bool Const_&gt; bool operator==(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ == that.ptr_; }
113      template &lt;bool Const_&gt; bool operator!=(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ != that.ptr_; }
114      template &lt;bool Const_&gt; bool operator&lt;=(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &lt;= that.ptr_; }
115      template &lt;bool Const_&gt; bool operator&gt;=(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &gt;= that.ptr_; }
116      template &lt;bool Const_&gt; bool operator&lt; (const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &lt; that.ptr_; }
117      template &lt;bool Const_&gt; bool operator&gt; (const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &gt; that.ptr_; }
118  #ifdef __cpp_lib_three_way_comparison
119      template &lt;bool Const_&gt; std::strong_ordering operator&lt;=&gt;(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &lt;=&gt; that.ptr_; }
120  #endif
121      Reference operator*() const { return *ptr_; }
122      Pointer   operator-&gt;() const { return ptr_; }
123      Reference operator[](DifferenceType n) const { return ptr_[n]; }
124      DifferenceType operator-(ConstIterator that) const { return ptr_-that.ptr_; }
125  private:
126      explicit GenericMemberIterator(Pointer p) : ptr_(p) {}
127      Pointer ptr_; 
128  };
129  #else 
130  template &lt;bool Const, typename Encoding, typename Allocator&gt;
131  class GenericMemberIterator;
132  template &lt;typename Encoding, typename Allocator&gt;
133  class GenericMemberIterator&lt;false,Encoding,Allocator&gt; {
134  public:
135      typedef GenericMember&lt;Encoding,Allocator&gt;* Iterator;
136  };
137  template &lt;typename Encoding, typename Allocator&gt;
138  class GenericMemberIterator&lt;true,Encoding,Allocator&gt; {
139  public:
140      typedef const GenericMember&lt;Encoding,Allocator&gt;* Iterator;
141  };
142  #endif 
143  template&lt;typename CharType&gt;
144  struct GenericStringRef {
145      typedef CharType Ch; 
146  #ifndef __clang__ 
147  #endif
148      template&lt;SizeType N&gt;
149      GenericStringRef(const CharType (&amp;str)[N]) RAPIDJSON_NOEXCEPT
150          : s(str), length(N-1) {}
151  #ifndef __clang__ 
152  #endif
153      explicit GenericStringRef(const CharType* str)
154          : s(str), length(NotNullStrLen(str)) {}
155  #ifndef __clang__ 
156  #endif
157      GenericStringRef(const CharType* str, SizeType len)
158          : s(RAPIDJSON_LIKELY(str) ? str : emptyString), length(len) { RAPIDJSON_ASSERT(str != 0 || len == 0u); }
159      GenericStringRef(const GenericStringRef&amp; rhs) : s(rhs.s), length(rhs.length) {}
160      operator const Ch *() const { return s; }
161      const Ch* const s; 
162      const SizeType length; 
163  private:
164      SizeType NotNullStrLen(const CharType* str) {
165          RAPIDJSON_ASSERT(str != 0);
166          return internal::StrLen(str);
167      }
168      static const Ch emptyString[];
169      template&lt;SizeType N&gt;
170      GenericStringRef(CharType (&amp;str)[N]) &amp;bsol;* = delete */;
171      GenericStringRef&amp; operator=(const GenericStringRef&amp; rhs) &amp;bsol;* = delete */;
172  };
173  template&lt;typename CharType&gt;
174  const CharType GenericStringRef&lt;CharType&gt;::emptyString[] = { CharType() };
175  template&lt;typename CharType&gt;
176  inline GenericStringRef&lt;CharType&gt; StringRef(const CharType* str) {
177      return GenericStringRef&lt;CharType&gt;(str);
178  }
179  template&lt;typename CharType&gt;
180  inline GenericStringRef&lt;CharType&gt; StringRef(const CharType* str, size_t length) {
181      return GenericStringRef&lt;CharType&gt;(str, SizeType(length));
182  }
183  #if RAPIDJSON_HAS_STDSTRING
184  template&lt;typename CharType&gt;
185  inline GenericStringRef&lt;CharType&gt; StringRef(const std::basic_string&lt;CharType&gt;&amp; str) {
186      return GenericStringRef&lt;CharType&gt;(str.data(), SizeType(str.size()));
187  }
188  #endif
189  namespace internal {
190  template &lt;typename T, typename Encoding = void, typename Allocator = void&gt;
191  struct IsGenericValueImpl : FalseType {};
192  template &lt;typename T&gt; struct IsGenericValueImpl&lt;T, typename Void&lt;typename T::EncodingType&gt;::Type, typename Void&lt;typename T::AllocatorType&gt;::Type&gt;
193      : IsBaseOf&lt;GenericValue&lt;typename T::EncodingType, typename T::AllocatorType&gt;, T&gt;::Type {};
194  template &lt;typename T&gt; struct IsGenericValue : IsGenericValueImpl&lt;T&gt;::Type {};
195  } 
196  namespace internal {
197  template &lt;typename ValueType, typename T&gt;
198  struct TypeHelper {};
199  template&lt;typename ValueType&gt;
200  struct TypeHelper&lt;ValueType, bool&gt; {
201      static bool Is(const ValueType&amp; v) { return v.IsBool(); }
202      static bool Get(const ValueType&amp; v) { return v.GetBool(); }
203      static ValueType&amp; Set(ValueType&amp; v, bool data) { return v.SetBool(data); }
204      static ValueType&amp; Set(ValueType&amp; v, bool data, typename ValueType::AllocatorType&amp;) { return v.SetBool(data); }
205  };
206  template&lt;typename ValueType&gt;
207  struct TypeHelper&lt;ValueType, int&gt; {
208      static bool Is(const ValueType&amp; v) { return v.IsInt(); }
209      static int Get(const ValueType&amp; v) { return v.GetInt(); }
210      static ValueType&amp; Set(ValueType&amp; v, int data) { return v.SetInt(data); }
211      static ValueType&amp; Set(ValueType&amp; v, int data, typename ValueType::AllocatorType&amp;) { return v.SetInt(data); }
212  };
213  template&lt;typename ValueType&gt;
214  struct TypeHelper&lt;ValueType, unsigned&gt; {
215      static bool Is(const ValueType&amp; v) { return v.IsUint(); }
216      static unsigned Get(const ValueType&amp; v) { return v.GetUint(); }
217      static ValueType&amp; Set(ValueType&amp; v, unsigned data) { return v.SetUint(data); }
218      static ValueType&amp; Set(ValueType&amp; v, unsigned data, typename ValueType::AllocatorType&amp;) { return v.SetUint(data); }
219  };
220  #ifdef _MSC_VER
221  RAPIDJSON_STATIC_ASSERT(sizeof(long) == sizeof(int));
222  template&lt;typename ValueType&gt;
223  struct TypeHelper&lt;ValueType, long&gt; {
224      static bool Is(const ValueType&amp; v) { return v.IsInt(); }
225      static long Get(const ValueType&amp; v) { return v.GetInt(); }
226      static ValueType&amp; Set(ValueType&amp; v, long data) { return v.SetInt(data); }
227      static ValueType&amp; Set(ValueType&amp; v, long data, typename ValueType::AllocatorType&amp;) { return v.SetInt(data); }
228  };
229  RAPIDJSON_STATIC_ASSERT(sizeof(unsigned long) == sizeof(unsigned));
230  template&lt;typename ValueType&gt;
231  struct TypeHelper&lt;ValueType, unsigned long&gt; {
232      static bool Is(const ValueType&amp; v) { return v.IsUint(); }
233      static unsigned long Get(const ValueType&amp; v) { return v.GetUint(); }
234      static ValueType&amp; Set(ValueType&amp; v, unsigned long data) { return v.SetUint(data); }
235      static ValueType&amp; Set(ValueType&amp; v, unsigned long data, typename ValueType::AllocatorType&amp;) { return v.SetUint(data); }
236  };
237  #endif
238  template&lt;typename ValueType&gt;
239  struct TypeHelper&lt;ValueType, int64_t&gt; {
240      static bool Is(const ValueType&amp; v) { return v.IsInt64(); }
241      static int64_t Get(const ValueType&amp; v) { return v.GetInt64(); }
242      static ValueType&amp; Set(ValueType&amp; v, int64_t data) { return v.SetInt64(data); }
243      static ValueType&amp; Set(ValueType&amp; v, int64_t data, typename ValueType::AllocatorType&amp;) { return v.SetInt64(data); }
244  };
245  template&lt;typename ValueType&gt;
246  struct TypeHelper&lt;ValueType, uint64_t&gt; {
247      static bool Is(const ValueType&amp; v) { return v.IsUint64(); }
248      static uint64_t Get(const ValueType&amp; v) { return v.GetUint64(); }
249      static ValueType&amp; Set(ValueType&amp; v, uint64_t data) { return v.SetUint64(data); }
250      static ValueType&amp; Set(ValueType&amp; v, uint64_t data, typename ValueType::AllocatorType&amp;) { return v.SetUint64(data); }
251  };
252  template&lt;typename ValueType&gt;
253  struct TypeHelper&lt;ValueType, double&gt; {
254      static bool Is(const ValueType&amp; v) { return v.IsDouble(); }
255      static double Get(const ValueType&amp; v) { return v.GetDouble(); }
256      static ValueType&amp; Set(ValueType&amp; v, double data) { return v.SetDouble(data); }
257      static ValueType&amp; Set(ValueType&amp; v, double data, typename ValueType::AllocatorType&amp;) { return v.SetDouble(data); }
258  };
259  template&lt;typename ValueType&gt;
260  struct TypeHelper&lt;ValueType, float&gt; {
261      static bool Is(const ValueType&amp; v) { return v.IsFloat(); }
262      static float Get(const ValueType&amp; v) { return v.GetFloat(); }
263      static ValueType&amp; Set(ValueType&amp; v, float data) { return v.SetFloat(data); }
264      static ValueType&amp; Set(ValueType&amp; v, float data, typename ValueType::AllocatorType&amp;) { return v.SetFloat(data); }
265  };
266  template&lt;typename ValueType&gt;
267  struct TypeHelper&lt;ValueType, const typename ValueType::Ch*&gt; {
268      typedef const typename ValueType::Ch* StringType;
269      static bool Is(const ValueType&amp; v) { return v.IsString(); }
270      static StringType Get(const ValueType&amp; v) { return v.GetString(); }
271      static ValueType&amp; Set(ValueType&amp; v, const StringType data) { return v.SetString(typename ValueType::StringRefType(data)); }
272      static ValueType&amp; Set(ValueType&amp; v, const StringType data, typename ValueType::AllocatorType&amp; a) { return v.SetString(data, a); }
273  };
274  #if RAPIDJSON_HAS_STDSTRING
275  template&lt;typename ValueType&gt;
276  struct TypeHelper&lt;ValueType, std::basic_string&lt;typename ValueType::Ch&gt; &gt; {
277      typedef std::basic_string&lt;typename ValueType::Ch&gt; StringType;
278      static bool Is(const ValueType&amp; v) { return v.IsString(); }
279      static StringType Get(const ValueType&amp; v) { return StringType(v.GetString(), v.GetStringLength()); }
280      static ValueType&amp; Set(ValueType&amp; v, const StringType&amp; data, typename ValueType::AllocatorType&amp; a) { return v.SetString(data, a); }
281  };
282  #endif
283  template&lt;typename ValueType&gt;
284  struct TypeHelper&lt;ValueType, typename ValueType::Array&gt; {
285      typedef typename ValueType::Array ArrayType;
286      static bool Is(const ValueType&amp; v) { return v.IsArray(); }
287      static ArrayType Get(ValueType&amp; v) { return v.GetArray(); }
288      static ValueType&amp; Set(ValueType&amp; v, ArrayType data) { return v = data; }
289      static ValueType&amp; Set(ValueType&amp; v, ArrayType data, typename ValueType::AllocatorType&amp;) { return v = data; }
290  };
291  template&lt;typename ValueType&gt;
292  struct TypeHelper&lt;ValueType, typename ValueType::ConstArray&gt; {
293      typedef typename ValueType::ConstArray ArrayType;
294      static bool Is(const ValueType&amp; v) { return v.IsArray(); }
295      static ArrayType Get(const ValueType&amp; v) { return v.GetArray(); }
296  };
297  template&lt;typename ValueType&gt;
298  struct TypeHelper&lt;ValueType, typename ValueType::Object&gt; {
299      typedef typename ValueType::Object ObjectType;
300      static bool Is(const ValueType&amp; v) { return v.IsObject(); }
301      static ObjectType Get(ValueType&amp; v) { return v.GetObject(); }
302      static ValueType&amp; Set(ValueType&amp; v, ObjectType data) { return v = data; }
303      static ValueType&amp; Set(ValueType&amp; v, ObjectType data, typename ValueType::AllocatorType&amp;) { return v = data; }
304  };
305  template&lt;typename ValueType&gt;
306  struct TypeHelper&lt;ValueType, typename ValueType::ConstObject&gt; {
307      typedef typename ValueType::ConstObject ObjectType;
308      static bool Is(const ValueType&amp; v) { return v.IsObject(); }
309      static ObjectType Get(const ValueType&amp; v) { return v.GetObject(); }
310  };
311  } 
312  template &lt;bool, typename&gt; class GenericArray;
313  template &lt;bool, typename&gt; class GenericObject;
314  template &lt;typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR &gt;
315  class GenericValue {
316  public:
317      typedef GenericMember&lt;Encoding, Allocator&gt; Member;
318      typedef Encoding EncodingType;                  
319      typedef Allocator AllocatorType;                
320      typedef typename Encoding::Ch Ch;               
321      typedef GenericStringRef&lt;Ch&gt; StringRefType;     
322      typedef typename GenericMemberIterator&lt;false,Encoding,Allocator&gt;::Iterator MemberIterator;  
323      typedef typename GenericMemberIterator&lt;true,Encoding,Allocator&gt;::Iterator ConstMemberIterator;  
324      typedef GenericValue* ValueIterator;            
325      typedef const GenericValue* ConstValueIterator; 
326      typedef GenericValue&lt;Encoding, Allocator&gt; ValueType;    
327      typedef GenericArray&lt;false, ValueType&gt; Array;
328      typedef GenericArray&lt;true, ValueType&gt; ConstArray;
329      typedef GenericObject&lt;false, ValueType&gt; Object;
330      typedef GenericObject&lt;true, ValueType&gt; ConstObject;
331      GenericValue() RAPIDJSON_NOEXCEPT : data_() { data_.f.flags = kNullFlag; }
332  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
333      GenericValue(GenericValue&amp;&amp; rhs) RAPIDJSON_NOEXCEPT : data_(rhs.data_) {
334          rhs.data_.f.flags = kNullFlag; 
335      }
336  #endif
337  private:
338      GenericValue(const GenericValue&amp; rhs);
339  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
340      template &lt;typename StackAllocator&gt;
341      GenericValue(GenericDocument&lt;Encoding,Allocator,StackAllocator&gt;&amp;&amp; rhs);
342      template &lt;typename StackAllocator&gt;
343      GenericValue&amp; operator=(GenericDocument&lt;Encoding,Allocator,StackAllocator&gt;&amp;&amp; rhs);
344  #endif
345  public:
346      explicit GenericValue(Type type) RAPIDJSON_NOEXCEPT : data_() {
347          static const uint16_t defaultFlags[] = {
348              kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kShortStringFlag,
349              kNumberAnyFlag
350          };
351          RAPIDJSON_NOEXCEPT_ASSERT(type &gt;= kNullType &amp;&amp; type &lt;= kNumberType);
352          data_.f.flags = defaultFlags[type];
353          if (type == kStringType)
354              data_.ss.SetLength(0);
355      }
356      template &lt;typename SourceAllocator&gt;
357      GenericValue(const GenericValue&lt;Encoding,SourceAllocator&gt;&amp; rhs, Allocator&amp; allocator, bool copyConstStrings = false) {
358          switch (rhs.GetType()) {
359          case kObjectType:
360              DoCopyMembers(rhs, allocator, copyConstStrings);
361              break;
362          case kArrayType: {
363                  SizeType count = rhs.data_.a.size;
364                  GenericValue* le = reinterpret_cast&lt;GenericValue*&gt;(allocator.Malloc(count * sizeof(GenericValue)));
365                  const GenericValue&lt;Encoding,SourceAllocator&gt;* re = rhs.GetElementsPointer();
366                  for (SizeType i = 0; i &lt; count; i++)
367                      new (&amp;le[i]) GenericValue(re[i], allocator, copyConstStrings);
368                  data_.f.flags = kArrayFlag;
369                  data_.a.size = data_.a.capacity = count;
370                  SetElementsPointer(le);
371              }
372              break;
373          case kStringType:
374              if (rhs.data_.f.flags == kConstStringFlag &amp;&amp; !copyConstStrings) {
375                  data_.f.flags = rhs.data_.f.flags;
376                  data_  = *reinterpret_cast&lt;const Data*&gt;(&amp;rhs.data_);
377              }
378              else
379                  SetStringRaw(StringRef(rhs.GetString(), rhs.GetStringLength()), allocator);
380              break;
381          default:
382              data_.f.flags = rhs.data_.f.flags;
383              data_  = *reinterpret_cast&lt;const Data*&gt;(&amp;rhs.data_);
384              break;
385          }
386      }
387  #ifndef RAPIDJSON_DOXYGEN_RUNNING 
388      template &lt;typename T&gt;
389      explicit GenericValue(T b, RAPIDJSON_ENABLEIF((internal::IsSame&lt;bool, T&gt;))) RAPIDJSON_NOEXCEPT  
390  #else
391      explicit GenericValue(bool b) RAPIDJSON_NOEXCEPT
392  #endif
393          : data_() {
394              RAPIDJSON_STATIC_ASSERT((internal::IsSame&lt;bool,T&gt;::Value));
395              data_.f.flags = b ? kTrueFlag : kFalseFlag;
396      }
397      explicit GenericValue(int i) RAPIDJSON_NOEXCEPT : data_() {
398          data_.n.i64 = i;
399          data_.f.flags = (i &gt;= 0) ? (kNumberIntFlag | kUintFlag | kUint64Flag) : kNumberIntFlag;
400      }
401      explicit GenericValue(unsigned u) RAPIDJSON_NOEXCEPT : data_() {
402          data_.n.u64 = u;
403          data_.f.flags = (u &amp; 0x80000000) ? kNumberUintFlag : (kNumberUintFlag | kIntFlag | kInt64Flag);
404      }
405      explicit GenericValue(int64_t i64) RAPIDJSON_NOEXCEPT : data_() {
406          data_.n.i64 = i64;
407          data_.f.flags = kNumberInt64Flag;
408          if (i64 &gt;= 0) {
409              data_.f.flags |= kNumberUint64Flag;
410              if (!(static_cast&lt;uint64_t&gt;(i64) &amp; RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))
411                  data_.f.flags |= kUintFlag;
412              if (!(static_cast&lt;uint64_t&gt;(i64) &amp; RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
413                  data_.f.flags |= kIntFlag;
414          }
415          else if (i64 &gt;= static_cast&lt;int64_t&gt;(RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
416              data_.f.flags |= kIntFlag;
417      }
418      explicit GenericValue(uint64_t u64) RAPIDJSON_NOEXCEPT : data_() {
419          data_.n.u64 = u64;
420          data_.f.flags = kNumberUint64Flag;
421          if (!(u64 &amp; RAPIDJSON_UINT64_C2(0x80000000, 0x00000000)))
422              data_.f.flags |= kInt64Flag;
423          if (!(u64 &amp; RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))
424              data_.f.flags |= kUintFlag;
425          if (!(u64 &amp; RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
426              data_.f.flags |= kIntFlag;
427      }
428      explicit GenericValue(double d) RAPIDJSON_NOEXCEPT : data_() { data_.n.d = d; data_.f.flags = kNumberDoubleFlag; }
429      explicit GenericValue(float f) RAPIDJSON_NOEXCEPT : data_() { data_.n.d = static_cast&lt;double&gt;(f); data_.f.flags = kNumberDoubleFlag; }
430      GenericValue(const Ch* s, SizeType length) RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(StringRef(s, length)); }
431      explicit GenericValue(StringRefType s) RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(s); }
432      GenericValue(const Ch* s, SizeType length, Allocator&amp; allocator) : data_() { SetStringRaw(StringRef(s, length), allocator); }
433      GenericValue(const Ch*s, Allocator&amp; allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
434  #if RAPIDJSON_HAS_STDSTRING
435      GenericValue(const std::basic_string&lt;Ch&gt;&amp; s, Allocator&amp; allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
436  #endif
437      GenericValue(Array a) RAPIDJSON_NOEXCEPT : data_(a.value_.data_) {
438          a.value_.data_ = Data();
439          a.value_.data_.f.flags = kArrayFlag;
440      }
441      GenericValue(Object o) RAPIDJSON_NOEXCEPT : data_(o.value_.data_) {
442          o.value_.data_ = Data();
443          o.value_.data_.f.flags = kObjectFlag;
444      }
445      ~GenericValue() {
446          if (Allocator::kNeedFree || (RAPIDJSON_USE_MEMBERSMAP+0 &amp;&amp;
447                                       internal::IsRefCounted&lt;Allocator&gt;::Value)) {
448              switch(data_.f.flags) {
449              case kArrayFlag:
450                  {
451                      GenericValue* e = GetElementsPointer();
452                      for (GenericValue* v = e; v != e + data_.a.size; ++v)
453                          v-&gt;~GenericValue();
454                      if (Allocator::kNeedFree) { 
455                          Allocator::Free(e);
456                      }
457                  }
458                  break;
459              case kObjectFlag:
460                  DoFreeMembers();
461                  break;
462              case kCopyStringFlag:
463                  if (Allocator::kNeedFree) { 
464                      Allocator::Free(const_cast&lt;Ch*&gt;(GetStringPointer()));
465                  }
466                  break;
467              default:
468                  break;  
469              }
470          }
471      }
472      GenericValue&amp; operator=(GenericValue&amp; rhs) RAPIDJSON_NOEXCEPT {
473          if (RAPIDJSON_LIKELY(this != &amp;rhs)) {
474              GenericValue temp;
475              temp.RawAssign(rhs);
476              this-&gt;~GenericValue();
477              RawAssign(temp);
478          }
479          return *this;
480      }
481  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
482      GenericValue&amp; operator=(GenericValue&amp;&amp; rhs) RAPIDJSON_NOEXCEPT {
483          return *this = rhs.Move();
484      }
485  #endif
486      GenericValue&amp; operator=(StringRefType str) RAPIDJSON_NOEXCEPT {
487          GenericValue s(str);
488          return *this = s;
489      }
490      template &lt;typename T&gt;
491      RAPIDJSON_DISABLEIF_RETURN((internal::IsPointer&lt;T&gt;), (GenericValue&amp;))
492      operator=(T value) {
493          GenericValue v(value);
494          return *this = v;
495      }
496      template &lt;typename SourceAllocator&gt;
497      GenericValue&amp; CopyFrom(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; rhs, Allocator&amp; allocator, bool copyConstStrings = false) {
498          RAPIDJSON_ASSERT(static_cast&lt;void*&gt;(this) != static_cast&lt;void const*&gt;(&amp;rhs));
499          this-&gt;~GenericValue();
500          new (this) GenericValue(rhs, allocator, copyConstStrings);
501          return *this;
502      }
503      GenericValue&amp; Swap(GenericValue&amp; other) RAPIDJSON_NOEXCEPT {
504          GenericValue temp;
505          temp.RawAssign(*this);
506          RawAssign(other);
507          other.RawAssign(temp);
508          return *this;
509      }
510      friend inline void swap(GenericValue&amp; a, GenericValue&amp; b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
511      GenericValue&amp; Move() RAPIDJSON_NOEXCEPT { return *this; }
512      template &lt;typename SourceAllocator&gt;
513      bool operator==(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; rhs) const {
514          typedef GenericValue&lt;Encoding, SourceAllocator&gt; RhsType;
515          if (GetType() != rhs.GetType())
516              return false;
517          switch (GetType()) {
518          case kObjectType: 
519              if (data_.o.size != rhs.data_.o.size)
520                  return false;
521              for (ConstMemberIterator lhsMemberItr = MemberBegin(); lhsMemberItr != MemberEnd(); ++lhsMemberItr) {
522                  typename RhsType::ConstMemberIterator rhsMemberItr = rhs.FindMember(lhsMemberItr-&gt;name);
523                  if (rhsMemberItr == rhs.MemberEnd() || lhsMemberItr-&gt;value != rhsMemberItr-&gt;value)
524                      return false;
525              }
526              return true;
527          case kArrayType:
528              if (data_.a.size != rhs.data_.a.size)
529                  return false;
530              for (SizeType i = 0; i &lt; data_.a.size; i++)
531                  if ((*this)[i] != rhs[i])
532                      return false;
533              return true;
534          case kStringType:
535              return StringEqual(rhs);
536          case kNumberType:
537              if (IsDouble() || rhs.IsDouble()) {
538                  double a = GetDouble();     
539                  double b = rhs.GetDouble(); 
540                  return a &gt;= b &amp;&amp; a &lt;= b;    
541              }
542              else
543                  return data_.n.u64 == rhs.data_.n.u64;
544          default:
545              return true;
546          }
547      }
548      bool operator==(const Ch* rhs) const { return *this == GenericValue(StringRef(rhs)); }
549  #if RAPIDJSON_HAS_STDSTRING
550      bool operator==(const std::basic_string&lt;Ch&gt;&amp; rhs) const { return *this == GenericValue(StringRef(rhs)); }
551  #endif
552      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;,internal::IsGenericValue&lt;T&gt; &gt;), (bool)) operator==(const T&amp; rhs) const { return *this == GenericValue(rhs); }
553      template &lt;typename SourceAllocator&gt;
554      bool operator!=(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; rhs) const { return !(*this == rhs); }
555      bool operator!=(const Ch* rhs) const { return !(*this == rhs); }
556      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue&lt;T&gt;), (bool)) operator!=(const T&amp; rhs) const { return !(*this == rhs); }
557  #ifndef __cpp_lib_three_way_comparison
558      template &lt;typename T&gt; friend RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue&lt;T&gt;), (bool)) operator==(const T&amp; lhs, const GenericValue&amp; rhs) { return rhs == lhs; }
559      template &lt;typename T&gt; friend RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue&lt;T&gt;), (bool)) operator!=(const T&amp; lhs, const GenericValue&amp; rhs) { return !(rhs == lhs); }
560  #endif
561      Type GetType()  const { return static_cast&lt;Type&gt;(data_.f.flags &amp; kTypeMask); }
562      bool IsNull()   const { return data_.f.flags == kNullFlag; }
563      bool IsFalse()  const { return data_.f.flags == kFalseFlag; }
564      bool IsTrue()   const { return data_.f.flags == kTrueFlag; }
565      bool IsBool()   const { return (data_.f.flags &amp; kBoolFlag) != 0; }
566      bool IsObject() const { return data_.f.flags == kObjectFlag; }
567      bool IsArray()  const { return data_.f.flags == kArrayFlag; }
568      bool IsNumber() const { return (data_.f.flags &amp; kNumberFlag) != 0; }
569      bool IsInt()    const { return (data_.f.flags &amp; kIntFlag) != 0; }
570      bool IsUint()   const { return (data_.f.flags &amp; kUintFlag) != 0; }
571      bool IsInt64()  const { return (data_.f.flags &amp; kInt64Flag) != 0; }
572      bool IsUint64() const { return (data_.f.flags &amp; kUint64Flag) != 0; }
573      bool IsDouble() const { return (data_.f.flags &amp; kDoubleFlag) != 0; }
574      bool IsString() const { return (data_.f.flags &amp; kStringFlag) != 0; }
575      bool IsLosslessDouble() const {
576          if (!IsNumber()) return false;
577          if (IsUint64()) {
578              uint64_t u = GetUint64();
579              volatile double d = static_cast&lt;double&gt;(u);
580              return (d &gt;= 0.0)
581                  &amp;&amp; (d &lt; static_cast&lt;double&gt;((std::numeric_limits&lt;uint64_t&gt;::max)()))
582                  &amp;&amp; (u == static_cast&lt;uint64_t&gt;(d));
583          }
584          if (IsInt64()) {
585              int64_t i = GetInt64();
586              volatile double d = static_cast&lt;double&gt;(i);
587              return (d &gt;= static_cast&lt;double&gt;((std::numeric_limits&lt;int64_t&gt;::min)()))
588                  &amp;&amp; (d &lt; static_cast&lt;double&gt;((std::numeric_limits&lt;int64_t&gt;::max)()))
589                  &amp;&amp; (i == static_cast&lt;int64_t&gt;(d));
590          }
591          return true; 
592      }
593      bool IsFloat() const  {
594          if ((data_.f.flags &amp; kDoubleFlag) == 0)
595              return false;
596          double d = GetDouble();
597          return d &gt;= -3.4028234e38 &amp;&amp; d &lt;= 3.4028234e38;
598      }
599      bool IsLosslessFloat() const {
600          if (!IsNumber()) return false;
601          double a = GetDouble();
602          if (a &lt; static_cast&lt;double&gt;(-(std::numeric_limits&lt;float&gt;::max)())
603                  || a &gt; static_cast&lt;double&gt;((std::numeric_limits&lt;float&gt;::max)()))
604              return false;
605          double b = static_cast&lt;double&gt;(static_cast&lt;float&gt;(a));
606          return a &gt;= b &amp;&amp; a &lt;= b;    
607      }
608      GenericValue&amp; SetNull() { this-&gt;~GenericValue(); new (this) GenericValue(); return *this; }
609      bool GetBool() const { RAPIDJSON_ASSERT(IsBool()); return data_.f.flags == kTrueFlag; }
610      GenericValue&amp; SetBool(bool b) { this-&gt;~GenericValue(); new (this) GenericValue(b); return *this; }
611      GenericValue&amp; SetObject() { this-&gt;~GenericValue(); new (this) GenericValue(kObjectType); return *this; }
612      SizeType MemberCount() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.size; }
613      SizeType MemberCapacity() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.capacity; }
614      bool ObjectEmpty() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.size == 0; }
615      template &lt;typename T&gt;
616      RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr&lt;internal::IsSame&lt;typename internal::RemoveConst&lt;T&gt;::Type, Ch&gt; &gt;),(GenericValue&amp;)) operator[](T* name) {
617          GenericValue n(StringRef(name));
618          return (*this)[n];
619      }
620      template &lt;typename T&gt;
621      RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr&lt;internal::IsSame&lt;typename internal::RemoveConst&lt;T&gt;::Type, Ch&gt; &gt;),(const GenericValue&amp;)) operator[](T* name) const { return const_cast&lt;GenericValue&amp;&gt;(*this)[name]; }
622      template &lt;typename SourceAllocator&gt;
623      GenericValue&amp; operator[](const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
624          MemberIterator member = FindMember(name);
625          if (member != MemberEnd())
626              return member-&gt;value;
627          else {
628              RAPIDJSON_ASSERT(false);    
629              static char buffer[sizeof(GenericValue)];
630              return *new (buffer) GenericValue();
631          }
632      }
633      template &lt;typename SourceAllocator&gt;
634      const GenericValue&amp; operator[](const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) const { return const_cast&lt;GenericValue&amp;&gt;(*this)[name]; }
635  #if RAPIDJSON_HAS_STDSTRING
636      GenericValue&amp; operator[](const std::basic_string&lt;Ch&gt;&amp; name) { return (*this)[GenericValue(StringRef(name))]; }
637      const GenericValue&amp; operator[](const std::basic_string&lt;Ch&gt;&amp; name) const { return (*this)[GenericValue(StringRef(name))]; }
638  #endif
639      ConstMemberIterator MemberBegin() const { RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer()); }
640      ConstMemberIterator MemberEnd() const   { RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer() + data_.o.size); }
641      MemberIterator MemberBegin()            { RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer()); }
642      MemberIterator MemberEnd()              { RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer() + data_.o.size); }
643      GenericValue&amp; MemberReserve(SizeType newCapacity, Allocator &amp;allocator) {
644          RAPIDJSON_ASSERT(IsObject());
645          DoReserveMembers(newCapacity, allocator);
646          return *this;
647      }
648      bool HasMember(const Ch* name) const { return FindMember(name) != MemberEnd(); }
649  #if RAPIDJSON_HAS_STDSTRING
650      bool HasMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return FindMember(name) != MemberEnd(); }
651  #endif
652      template &lt;typename SourceAllocator&gt;
653      bool HasMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) const { return FindMember(name) != MemberEnd(); }
654      MemberIterator FindMember(const Ch* name) {
655          GenericValue n(StringRef(name));
656          return FindMember(n);
657      }
658      ConstMemberIterator FindMember(const Ch* name) const { return const_cast&lt;GenericValue&amp;&gt;(*this).FindMember(name); }
659      template &lt;typename SourceAllocator&gt;
660      MemberIterator FindMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
661          RAPIDJSON_ASSERT(IsObject());
662          RAPIDJSON_ASSERT(name.IsString());
663          return DoFindMember(name);
664      }
665      template &lt;typename SourceAllocator&gt; ConstMemberIterator FindMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) const { return const_cast&lt;GenericValue&amp;&gt;(*this).FindMember(name); }
666  #if RAPIDJSON_HAS_STDSTRING
667      MemberIterator FindMember(const std::basic_string&lt;Ch&gt;&amp; name) { return FindMember(GenericValue(StringRef(name))); }
668      ConstMemberIterator FindMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return FindMember(GenericValue(StringRef(name))); }
669  #endif
670      GenericValue&amp; AddMember(GenericValue&amp; name, GenericValue&amp; value, Allocator&amp; allocator) {
671          RAPIDJSON_ASSERT(IsObject());
672          RAPIDJSON_ASSERT(name.IsString());
673          DoAddMember(name, value, allocator);
674          return *this;
675      }
676      GenericValue&amp; AddMember(GenericValue&amp; name, StringRefType value, Allocator&amp; allocator) {
677          GenericValue v(value);
678          return AddMember(name, v, allocator);
679      }
680  #if RAPIDJSON_HAS_STDSTRING
681      GenericValue&amp; AddMember(GenericValue&amp; name, std::basic_string&lt;Ch&gt;&amp; value, Allocator&amp; allocator) {
682          GenericValue v(value, allocator);
683          return AddMember(name, v, allocator);
684      }
685  #endif
686      template &lt;typename T&gt;
687      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (GenericValue&amp;))
688      AddMember(GenericValue&amp; name, T value, Allocator&amp; allocator) {
689          GenericValue v(value);
690          return AddMember(name, v, allocator);
691      }
692  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
693      GenericValue&amp; AddMember(GenericValue&amp;&amp; name, GenericValue&amp;&amp; value, Allocator&amp; allocator) {
694          return AddMember(name, value, allocator);
695      }
696      GenericValue&amp; AddMember(GenericValue&amp;&amp; name, GenericValue&amp; value, Allocator&amp; allocator) {
697          return AddMember(name, value, allocator);
698      }
699      GenericValue&amp; AddMember(GenericValue&amp; name, GenericValue&amp;&amp; value, Allocator&amp; allocator) {
700          return AddMember(name, value, allocator);
701      }
702      GenericValue&amp; AddMember(StringRefType name, GenericValue&amp;&amp; value, Allocator&amp; allocator) {
703          GenericValue n(name);
704          return AddMember(n, value, allocator);
705      }
706  #endif 
707      GenericValue&amp; AddMember(StringRefType name, GenericValue&amp; value, Allocator&amp; allocator) {
708          GenericValue n(name);
709          return AddMember(n, value, allocator);
710      }
711      GenericValue&amp; AddMember(StringRefType name, StringRefType value, Allocator&amp; allocator) {
712          GenericValue v(value);
713          return AddMember(name, v, allocator);
714      }
715      template &lt;typename T&gt;
716      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (GenericValue&amp;))
717      AddMember(StringRefType name, T value, Allocator&amp; allocator) {
718          GenericValue n(name);
719          return AddMember(n, value, allocator);
720      }
721      void RemoveAllMembers() {
722          RAPIDJSON_ASSERT(IsObject());
723          DoClearMembers();
724      }
725      bool RemoveMember(const Ch* name) {
726          GenericValue n(StringRef(name));
727          return RemoveMember(n);
728      }
729  #if RAPIDJSON_HAS_STDSTRING
730      bool RemoveMember(const std::basic_string&lt;Ch&gt;&amp; name) { return RemoveMember(GenericValue(StringRef(name))); }
731  #endif
732      template &lt;typename SourceAllocator&gt;
733      bool RemoveMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
734          MemberIterator m = FindMember(name);
735          if (m != MemberEnd()) {
736              RemoveMember(m);
737              return true;
738          }
739          else
740              return false;
741      }
742      MemberIterator RemoveMember(MemberIterator m) {
743          RAPIDJSON_ASSERT(IsObject());
744          RAPIDJSON_ASSERT(data_.o.size &gt; 0);
745          RAPIDJSON_ASSERT(GetMembersPointer() != 0);
746          RAPIDJSON_ASSERT(m &gt;= MemberBegin() &amp;&amp; m &lt; MemberEnd());
747          return DoRemoveMember(m);
748      }
749      MemberIterator EraseMember(ConstMemberIterator pos) {
750          return EraseMember(pos, pos +1);
751      }
752      MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) {
753          RAPIDJSON_ASSERT(IsObject());
754          RAPIDJSON_ASSERT(data_.o.size &gt; 0);
755          RAPIDJSON_ASSERT(GetMembersPointer() != 0);
756          RAPIDJSON_ASSERT(first &gt;= MemberBegin());
757          RAPIDJSON_ASSERT(first &lt;= last);
758          RAPIDJSON_ASSERT(last &lt;= MemberEnd());
759          return DoEraseMembers(first, last);
760      }
761      bool EraseMember(const Ch* name) {
762          GenericValue n(StringRef(name));
763          return EraseMember(n);
764      }
765  #if RAPIDJSON_HAS_STDSTRING
766      bool EraseMember(const std::basic_string&lt;Ch&gt;&amp; name) { return EraseMember(GenericValue(StringRef(name))); }
767  #endif
768      template &lt;typename SourceAllocator&gt;
769      bool EraseMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
770          MemberIterator m = FindMember(name);
771          if (m != MemberEnd()) {
772              EraseMember(m);
773              return true;
774          }
775          else
776              return false;
777      }
778      Object GetObject() { RAPIDJSON_ASSERT(IsObject()); return Object(*this); }
779      Object GetObj() { RAPIDJSON_ASSERT(IsObject()); return Object(*this); }
780      ConstObject GetObject() const { RAPIDJSON_ASSERT(IsObject()); return ConstObject(*this); }
781      ConstObject GetObj() const { RAPIDJSON_ASSERT(IsObject()); return ConstObject(*this); }
782      GenericValue&amp; SetArray() { this-&gt;~GenericValue(); new (this) GenericValue(kArrayType); return *this; }
783      SizeType Size() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.size; }
784      SizeType Capacity() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.capacity; }
785      bool Empty() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.size == 0; }
786      void Clear() {
787          RAPIDJSON_ASSERT(IsArray());
788          GenericValue* e = GetElementsPointer();
789          for (GenericValue* v = e; v != e + data_.a.size; ++v)
790              v-&gt;~GenericValue();
791          data_.a.size = 0;
792      }
793      GenericValue&amp; operator[](SizeType index) {
794          RAPIDJSON_ASSERT(IsArray());
795          RAPIDJSON_ASSERT(index &lt; data_.a.size);
796          return GetElementsPointer()[index];
797      }
798      const GenericValue&amp; operator[](SizeType index) const { return const_cast&lt;GenericValue&amp;&gt;(*this)[index]; }
799      ValueIterator Begin() { RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer(); }
800      ValueIterator End() { RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer() + data_.a.size; }
801      ConstValueIterator Begin() const { return const_cast&lt;GenericValue&amp;&gt;(*this).Begin(); }
802      ConstValueIterator End() const { return const_cast&lt;GenericValue&amp;&gt;(*this).End(); }
803      GenericValue&amp; Reserve(SizeType newCapacity, Allocator &amp;allocator) {
804          RAPIDJSON_ASSERT(IsArray());
805          if (newCapacity &gt; data_.a.capacity) {
806              SetElementsPointer(reinterpret_cast&lt;GenericValue*&gt;(allocator.Realloc(GetElementsPointer(), data_.a.capacity * sizeof(GenericValue), newCapacity * sizeof(GenericValue))));
807              data_.a.capacity = newCapacity;
808          }
809          return *this;
810      }
811      GenericValue&amp; PushBack(GenericValue&amp; value, Allocator&amp; allocator) {
812          RAPIDJSON_ASSERT(IsArray());
813          if (data_.a.size &gt;= data_.a.capacity)
814              Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : (data_.a.capacity + (data_.a.capacity + 1) / 2), allocator);
815          GetElementsPointer()[data_.a.size++].RawAssign(value);
816          return *this;
817      }
818  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
819      GenericValue&amp; PushBack(GenericValue&amp;&amp; value, Allocator&amp; allocator) {
820          return PushBack(value, allocator);
821      }
822  #endif 
823      GenericValue&amp; PushBack(StringRefType value, Allocator&amp; allocator) {
824          return (*this).template PushBack&lt;StringRefType&gt;(value, allocator);
825      }
826      template &lt;typename T&gt;
827      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (GenericValue&amp;))
828      PushBack(T value, Allocator&amp; allocator) {
829          GenericValue v(value);
830          return PushBack(v, allocator);
831      }
832      GenericValue&amp; PopBack() {
833          RAPIDJSON_ASSERT(IsArray());
834          RAPIDJSON_ASSERT(!Empty());
835          GetElementsPointer()[--data_.a.size].~GenericValue();
836          return *this;
837      }
838      ValueIterator Erase(ConstValueIterator pos) {
839          return Erase(pos, pos + 1);
840      }
841      ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) {
842          RAPIDJSON_ASSERT(IsArray());
843          RAPIDJSON_ASSERT(data_.a.size &gt; 0);
844          RAPIDJSON_ASSERT(GetElementsPointer() != 0);
845          RAPIDJSON_ASSERT(first &gt;= Begin());
846          RAPIDJSON_ASSERT(first &lt;= last);
847          RAPIDJSON_ASSERT(last &lt;= End());
848          ValueIterator pos = Begin() + (first - Begin());
849          for (ValueIterator itr = pos; itr != last; ++itr)
850              itr-&gt;~GenericValue();
851          std::memmove(static_cast&lt;void*&gt;(pos), last, static_cast&lt;size_t&gt;(End() - last) * sizeof(GenericValue));
852          data_.a.size -= static_cast&lt;SizeType&gt;(last - first);
853          return pos;
854      }
855      Array GetArray() { RAPIDJSON_ASSERT(IsArray()); return Array(*this); }
856      ConstArray GetArray() const { RAPIDJSON_ASSERT(IsArray()); return ConstArray(*this); }
857      int GetInt() const          { RAPIDJSON_ASSERT(data_.f.flags &amp; kIntFlag);   return data_.n.i.i;   }
858      unsigned GetUint() const    { RAPIDJSON_ASSERT(data_.f.flags &amp; kUintFlag);  return data_.n.u.u;   }
859      int64_t GetInt64() const    { RAPIDJSON_ASSERT(data_.f.flags &amp; kInt64Flag); return data_.n.i64; }
860      uint64_t GetUint64() const  { RAPIDJSON_ASSERT(data_.f.flags &amp; kUint64Flag); return data_.n.u64; }
861      double GetDouble() const {
862          RAPIDJSON_ASSERT(IsNumber());
863          if ((data_.f.flags &amp; kDoubleFlag) != 0)                return data_.n.d;   
864          if ((data_.f.flags &amp; kIntFlag) != 0)                   return data_.n.i.i; 
865          if ((data_.f.flags &amp; kUintFlag) != 0)                  return data_.n.u.u; 
866          if ((data_.f.flags &amp; kInt64Flag) != 0)                 return static_cast&lt;double&gt;(data_.n.i64); 
867          RAPIDJSON_ASSERT((data_.f.flags &amp; kUint64Flag) != 0);  return static_cast&lt;double&gt;(data_.n.u64); 
868      }
869      float GetFloat() const {
870          return static_cast&lt;float&gt;(GetDouble());
871      }
872      GenericValue&amp; SetInt(int i)             { this-&gt;~GenericValue(); new (this) GenericValue(i);    return *this; }
873      GenericValue&amp; SetUint(unsigned u)       { this-&gt;~GenericValue(); new (this) GenericValue(u);    return *this; }
874      GenericValue&amp; SetInt64(int64_t i64)     { this-&gt;~GenericValue(); new (this) GenericValue(i64);  return *this; }
875      GenericValue&amp; SetUint64(uint64_t u64)   { this-&gt;~GenericValue(); new (this) GenericValue(u64);  return *this; }
876      GenericValue&amp; SetDouble(double d)       { this-&gt;~GenericValue(); new (this) GenericValue(d);    return *this; }
877      GenericValue&amp; SetFloat(float f)         { this-&gt;~GenericValue(); new (this) GenericValue(static_cast&lt;double&gt;(f)); return *this; }
878      const Ch* GetString() const { RAPIDJSON_ASSERT(IsString()); return DataString(data_); }
879      SizeType GetStringLength() const { RAPIDJSON_ASSERT(IsString()); return DataStringLength(data_); }
880      GenericValue&amp; SetString(const Ch* s, SizeType length) { return SetString(StringRef(s, length)); }
881      GenericValue&amp; SetString(StringRefType s) { this-&gt;~GenericValue(); SetStringRaw(s); return *this; }
882      GenericValue&amp; SetString(const Ch* s, SizeType length, Allocator&amp; allocator) { return SetString(StringRef(s, length), allocator); }
883      GenericValue&amp; SetString(const Ch* s, Allocator&amp; allocator) { return SetString(StringRef(s), allocator); }
884      GenericValue&amp; SetString(StringRefType s, Allocator&amp; allocator) { this-&gt;~GenericValue(); SetStringRaw(s, allocator); return *this; }
885  #if RAPIDJSON_HAS_STDSTRING
886      GenericValue&amp; SetString(const std::basic_string&lt;Ch&gt;&amp; s, Allocator&amp; allocator) { return SetString(StringRef(s), allocator); }
887  #endif
888      template &lt;typename T&gt;
889      bool Is() const { return internal::TypeHelper&lt;ValueType, T&gt;::Is(*this); }
890      template &lt;typename T&gt;
891      T Get() const { return internal::TypeHelper&lt;ValueType, T&gt;::Get(*this); }
892      template &lt;typename T&gt;
893      T Get() { return internal::TypeHelper&lt;ValueType, T&gt;::Get(*this); }
894      template&lt;typename T&gt;
895      ValueType&amp; Set(const T&amp; data) { return internal::TypeHelper&lt;ValueType, T&gt;::Set(*this, data); }
896      template&lt;typename T&gt;
897      ValueType&amp; Set(const T&amp; data, AllocatorType&amp; allocator) { return internal::TypeHelper&lt;ValueType, T&gt;::Set(*this, data, allocator); }
898      template &lt;typename Handler&gt;
899      bool Accept(Handler&amp; handler) const {
900          switch(GetType()) {
901          case kNullType:     return handler.Null();
902          case kFalseType:    return handler.Bool(false);
903          case kTrueType:     return handler.Bool(true);
904          case kObjectType:
905              if (RAPIDJSON_UNLIKELY(!handler.StartObject()))
906                  return false;
907              for (ConstMemberIterator m = MemberBegin(); m != MemberEnd(); ++m) {
908                  RAPIDJSON_ASSERT(m-&gt;name.IsString()); 
909                  if (RAPIDJSON_UNLIKELY(!handler.Key(m-&gt;name.GetString(), m-&gt;name.GetStringLength(), (m-&gt;name.data_.f.flags &amp; kCopyFlag) != 0)))
910                      return false;
911                  if (RAPIDJSON_UNLIKELY(!m-&gt;value.Accept(handler)))
912                      return false;
913              }
914              return handler.EndObject(data_.o.size);
915          case kArrayType:
916              if (RAPIDJSON_UNLIKELY(!handler.StartArray()))
917                  return false;
918              for (ConstValueIterator v = Begin(); v != End(); ++v)
919                  if (RAPIDJSON_UNLIKELY(!v-&gt;Accept(handler)))
920                      return false;
921              return handler.EndArray(data_.a.size);
922          case kStringType:
923              return handler.String(GetString(), GetStringLength(), (data_.f.flags &amp; kCopyFlag) != 0);
924          default:
925              RAPIDJSON_ASSERT(GetType() == kNumberType);
926              if (IsDouble())         return handler.Double(data_.n.d);
927              else if (IsInt())       return handler.Int(data_.n.i.i);
928              else if (IsUint())      return handler.Uint(data_.n.u.u);
929              else if (IsInt64())     return handler.Int64(data_.n.i64);
930              else                    return handler.Uint64(data_.n.u64);
931          }
932      }
933  private:
934      template &lt;typename, typename&gt; friend class GenericValue;
935      template &lt;typename, typename, typename&gt; friend class GenericDocument;
936      enum {
937          kBoolFlag       = 0x0008,
938          kNumberFlag     = 0x0010,
939          kIntFlag        = 0x0020,
940          kUintFlag       = 0x0040,
941          kInt64Flag      = 0x0080,
942          kUint64Flag     = 0x0100,
943          kDoubleFlag     = 0x0200,
944          kStringFlag     = 0x0400,
945          kCopyFlag       = 0x0800,
946          kInlineStrFlag  = 0x1000,
947          kNullFlag = kNullType,
948          kTrueFlag = static_cast&lt;int&gt;(kTrueType) | static_cast&lt;int&gt;(kBoolFlag),
949          kFalseFlag = static_cast&lt;int&gt;(kFalseType) | static_cast&lt;int&gt;(kBoolFlag),
950          kNumberIntFlag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kIntFlag | kInt64Flag),
951          kNumberUintFlag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag),
952          kNumberInt64Flag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kInt64Flag),
953          kNumberUint64Flag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kUint64Flag),
954          kNumberDoubleFlag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kDoubleFlag),
955          kNumberAnyFlag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kIntFlag | kInt64Flag | kUintFlag | kUint64Flag | kDoubleFlag),
956          kConstStringFlag = static_cast&lt;int&gt;(kStringType) | static_cast&lt;int&gt;(kStringFlag),
957          kCopyStringFlag = static_cast&lt;int&gt;(kStringType) | static_cast&lt;int&gt;(kStringFlag | kCopyFlag),
958          kShortStringFlag = static_cast&lt;int&gt;(kStringType) | static_cast&lt;int&gt;(kStringFlag | kCopyFlag | kInlineStrFlag),
959          kObjectFlag = kObjectType,
960          kArrayFlag = kArrayType,
961          kTypeMask = 0x07
962      };
963      static const SizeType kDefaultArrayCapacity = RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY;
964      static const SizeType kDefaultObjectCapacity = RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY;
965      struct Flag {
966  #if RAPIDJSON_48BITPOINTER_OPTIMIZATION
967          char payload[sizeof(SizeType) * 2 + 6];     
968  #elif RAPIDJSON_64BIT
969          char payload[sizeof(SizeType) * 2 + sizeof(void*) + 6]; 
970  #else
971          char payload[sizeof(SizeType) * 2 + sizeof(void*) + 2]; 
972  #endif
973          uint16_t flags;
974      };
975      struct String {
976          SizeType length;
977          SizeType hashcode;  
978          const Ch* str;
979      };  
980      struct ShortString {
981          enum { MaxChars = sizeof(static_cast&lt;Flag*&gt;(0)-&gt;payload) / sizeof(Ch), MaxSize = MaxChars - 1, LenPos = MaxSize };
982          Ch str[MaxChars];
983          inline static bool Usable(SizeType len) { return                       (MaxSize &gt;= len); }
984          inline void     SetLength(SizeType len) { str[LenPos] = static_cast&lt;Ch&gt;(MaxSize -  len); }
985          inline SizeType GetLength() const       { return  static_cast&lt;SizeType&gt;(MaxSize -  str[LenPos]); }
986      };  
987      union Number {
988  #if RAPIDJSON_ENDIAN == RAPIDJSON_LITTLEENDIAN
989          struct I {
990              int i;
991              char padding[4];
992          }i;
993          struct U {
994              unsigned u;
995              char padding2[4];
996          }u;
997  #else
998          struct I {
999              char padding[4];
1000              int i;
1001          }i;
1002          struct U {
1003              char padding2[4];
1004              unsigned u;
1005          }u;
1006  #endif
1007          int64_t i64;
1008          uint64_t u64;
1009          double d;
1010      };  
1011      struct ObjectData {
1012          SizeType size;
1013          SizeType capacity;
1014          Member* members;
1015      };  
1016      struct ArrayData {
1017          SizeType size;
1018          SizeType capacity;
1019          GenericValue* elements;
1020      };  
1021      union Data {
1022          String s;
1023          ShortString ss;
1024          Number n;
1025          ObjectData o;
1026          ArrayData a;
1027          Flag f;
1028      };  
1029      static RAPIDJSON_FORCEINLINE const Ch* DataString(const Data&amp; data) {
1030          return (data.f.flags &amp; kInlineStrFlag) ? data.ss.str : RAPIDJSON_GETPOINTER(Ch, data.s.str);
1031      }
1032      static RAPIDJSON_FORCEINLINE SizeType DataStringLength(const Data&amp; data) {
1033          return (data.f.flags &amp; kInlineStrFlag) ? data.ss.GetLength() : data.s.length;
1034      }
1035      RAPIDJSON_FORCEINLINE const Ch* GetStringPointer() const { return RAPIDJSON_GETPOINTER(Ch, data_.s.str); }
1036      RAPIDJSON_FORCEINLINE const Ch* SetStringPointer(const Ch* str) { return RAPIDJSON_SETPOINTER(Ch, data_.s.str, str); }
1037      RAPIDJSON_FORCEINLINE GenericValue* GetElementsPointer() const { return RAPIDJSON_GETPOINTER(GenericValue, data_.a.elements); }
<span onclick='openModal()' class='match'>1038      RAPIDJSON_FORCEINLINE GenericValue* SetElementsPointer(GenericValue* elements) { return RAPIDJSON_SETPOINTER(GenericValue, data_.a.elements, elements); }
1039      RAPIDJSON_FORCEINLINE Member* GetMembersPointer() const { return RAPIDJSON_GETPOINTER(Member, data_.o.members); }
</span>1040      RAPIDJSON_FORCEINLINE Member* SetMembersPointer(Member* members) { return RAPIDJSON_SETPOINTER(Member, data_.o.members, members); }
1041  #if RAPIDJSON_USE_MEMBERSMAP
1042      struct MapTraits {
1043          struct Less {
1044              bool operator()(const Data&amp; s1, const Data&amp; s2) const {
1045                  SizeType n1 = DataStringLength(s1), n2 = DataStringLength(s2);
1046                  int cmp = std::memcmp(DataString(s1), DataString(s2), sizeof(Ch) * (n1 &lt; n2 ? n1 : n2));
1047                  return cmp &lt; 0 || (cmp == 0 &amp;&amp; n1 &lt; n2);
1048              }
1049          };
1050          typedef std::pair&lt;const Data, SizeType&gt; Pair;
1051          typedef std::multimap&lt;Data, SizeType, Less, StdAllocator&lt;Pair, Allocator&gt; &gt; Map;
1052          typedef typename Map::iterator Iterator;
1053      };
1054      typedef typename MapTraits::Map         Map;
1055      typedef typename MapTraits::Less        MapLess;
1056      typedef typename MapTraits::Pair        MapPair;
1057      typedef typename MapTraits::Iterator    MapIterator;
1058      static RAPIDJSON_FORCEINLINE size_t GetMapLayoutSize(SizeType capacity) {
1059          return RAPIDJSON_ALIGN(sizeof(Map*)) +
1060                 RAPIDJSON_ALIGN(sizeof(SizeType)) +
1061                 RAPIDJSON_ALIGN(capacity * sizeof(Member)) +
1062                 capacity * sizeof(MapIterator);
1063      }
1064      static RAPIDJSON_FORCEINLINE SizeType &amp;GetMapCapacity(Map* &amp;map) {
1065          return *reinterpret_cast&lt;SizeType*&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;map) +
1066                                              RAPIDJSON_ALIGN(sizeof(Map*)));
1067      }
1068      static RAPIDJSON_FORCEINLINE Member* GetMapMembers(Map* &amp;map) {
1069          return reinterpret_cast&lt;Member*&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;map) +
1070                                           RAPIDJSON_ALIGN(sizeof(Map*)) +
1071                                           RAPIDJSON_ALIGN(sizeof(SizeType)));
1072      }
1073      static RAPIDJSON_FORCEINLINE MapIterator* GetMapIterators(Map* &amp;map) {
1074          return reinterpret_cast&lt;MapIterator*&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;map) +
1075                                                RAPIDJSON_ALIGN(sizeof(Map*)) +
1076                                                RAPIDJSON_ALIGN(sizeof(SizeType)) +
1077                                                RAPIDJSON_ALIGN(GetMapCapacity(map) * sizeof(Member)));
1078      }
1079      static RAPIDJSON_FORCEINLINE Map* &amp;GetMap(Member* members) {
1080          RAPIDJSON_ASSERT(members != 0);
1081          return *reinterpret_cast&lt;Map**&gt;(reinterpret_cast&lt;uintptr_t&gt;(members) -
1082                                          RAPIDJSON_ALIGN(sizeof(SizeType)) -
1083                                          RAPIDJSON_ALIGN(sizeof(Map*)));
1084      }
1085      RAPIDJSON_FORCEINLINE MapIterator DropMapIterator(MapIterator&amp; rhs) {
1086  #if RAPIDJSON_HAS_CXX11
1087          MapIterator ret = std::move(rhs);
1088  #else
1089          MapIterator ret = rhs;
1090  #endif
1091          rhs.~MapIterator();
1092          return ret;
1093      }
1094      Map* &amp;DoReallocMap(Map** oldMap, SizeType newCapacity, Allocator&amp; allocator) {
1095          Map **newMap = static_cast&lt;Map**&gt;(allocator.Malloc(GetMapLayoutSize(newCapacity)));
1096          GetMapCapacity(*newMap) = newCapacity;
1097          if (!oldMap) {
1098              *newMap = new (allocator.Malloc(sizeof(Map))) Map(MapLess(), allocator);
1099          }
1100          else {
1101              *newMap = *oldMap;
1102              size_t count = (*oldMap)-&gt;size();
1103              std::memcpy(static_cast&lt;void*&gt;(GetMapMembers(*newMap)),
1104                          static_cast&lt;void*&gt;(GetMapMembers(*oldMap)),
1105                          count * sizeof(Member));
1106              MapIterator *oldIt = GetMapIterators(*oldMap),
1107                          *newIt = GetMapIterators(*newMap);
1108              while (count--) {
1109                  new (&amp;newIt[count]) MapIterator(DropMapIterator(oldIt[count]));
1110              }
1111              Allocator::Free(oldMap);
1112          }
1113          return *newMap;
1114      }
1115      RAPIDJSON_FORCEINLINE Member* DoAllocMembers(SizeType capacity, Allocator&amp; allocator) {
1116          return GetMapMembers(DoReallocMap(0, capacity, allocator));
1117      }
1118      void DoReserveMembers(SizeType newCapacity, Allocator&amp; allocator) {
1119          ObjectData&amp; o = data_.o;
1120          if (newCapacity &gt; o.capacity) {
1121              Member* oldMembers = GetMembersPointer();
1122              Map **oldMap = oldMembers ? &amp;GetMap(oldMembers) : 0,
1123                  *&amp;newMap = DoReallocMap(oldMap, newCapacity, allocator);
1124              RAPIDJSON_SETPOINTER(Member, o.members, GetMapMembers(newMap));
1125              o.capacity = newCapacity;
1126          }
1127      }
1128      template &lt;typename SourceAllocator&gt;
1129      MemberIterator DoFindMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
1130          if (Member* members = GetMembersPointer()) {
1131              Map* &amp;map = GetMap(members);
1132              MapIterator mit = map-&gt;find(reinterpret_cast&lt;const Data&amp;&gt;(name.data_));
1133              if (mit != map-&gt;end()) {
1134                  return MemberIterator(&amp;members[mit-&gt;second]);
1135              }
1136          }
1137          return MemberEnd();
1138      }
1139      void DoClearMembers() {
1140          if (Member* members = GetMembersPointer()) {
1141              Map* &amp;map = GetMap(members);
1142              MapIterator* mit = GetMapIterators(map);
1143              for (SizeType i = 0; i &lt; data_.o.size; i++) {
1144                  map-&gt;erase(DropMapIterator(mit[i]));
1145                  members[i].~Member();
1146              }
1147              data_.o.size = 0;
1148          }
1149      }
1150      void DoFreeMembers() {
1151          if (Member* members = GetMembersPointer()) {
1152              GetMap(members)-&gt;~Map();
1153              for (SizeType i = 0; i &lt; data_.o.size; i++) {
1154                  members[i].~Member();
1155              }
1156              if (Allocator::kNeedFree) { 
1157                  Map** map = &amp;GetMap(members);
1158                  Allocator::Free(*map);
1159                  Allocator::Free(map);
1160              }
1161          }
1162      }
1163  #else 
1164      RAPIDJSON_FORCEINLINE Member* DoAllocMembers(SizeType capacity, Allocator&amp; allocator) {
1165          return Malloc&lt;Member&gt;(allocator, capacity);
1166      }
1167      void DoReserveMembers(SizeType newCapacity, Allocator&amp; allocator) {
1168          ObjectData&amp; o = data_.o;
1169          if (newCapacity &gt; o.capacity) {
1170              Member* newMembers = Realloc&lt;Member&gt;(allocator, GetMembersPointer(), o.capacity, newCapacity);
1171              RAPIDJSON_SETPOINTER(Member, o.members, newMembers);
1172              o.capacity = newCapacity;
1173          }
1174      }
1175      template &lt;typename SourceAllocator&gt;
1176      MemberIterator DoFindMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
1177          MemberIterator member = MemberBegin();
1178          for ( ; member != MemberEnd(); ++member)
1179              if (name.StringEqual(member-&gt;name))
1180                  break;
1181          return member;
1182      }
1183      void DoClearMembers() {
1184          for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
1185              m-&gt;~Member();
1186          data_.o.size = 0;
1187      }
1188      void DoFreeMembers() {
1189          for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
1190              m-&gt;~Member();
1191          Allocator::Free(GetMembersPointer());
1192      }
1193  #endif 
1194      void DoAddMember(GenericValue&amp; name, GenericValue&amp; value, Allocator&amp; allocator) {
1195          ObjectData&amp; o = data_.o;
1196          if (o.size &gt;= o.capacity)
1197              DoReserveMembers(o.capacity ? (o.capacity + (o.capacity + 1) / 2) : kDefaultObjectCapacity, allocator);
1198          Member* members = GetMembersPointer();
1199          Member* m = members + o.size;
1200          m-&gt;name.RawAssign(name);
1201          m-&gt;value.RawAssign(value);
1202  #if RAPIDJSON_USE_MEMBERSMAP
1203          Map* &amp;map = GetMap(members);
1204          MapIterator* mit = GetMapIterators(map);
1205          new (&amp;mit[o.size]) MapIterator(map-&gt;insert(MapPair(m-&gt;name.data_, o.size)));
1206  #endif
1207          ++o.size;
1208      }
1209      MemberIterator DoRemoveMember(MemberIterator m) {
1210          ObjectData&amp; o = data_.o;
1211          Member* members = GetMembersPointer();
1212  #if RAPIDJSON_USE_MEMBERSMAP
1213          Map* &amp;map = GetMap(members);
1214          MapIterator* mit = GetMapIterators(map);
1215          SizeType mpos = static_cast&lt;SizeType&gt;(&amp;*m - members);
1216          map-&gt;erase(DropMapIterator(mit[mpos]));
1217  #endif
1218          MemberIterator last(members + (o.size - 1));
1219          if (o.size &gt; 1 &amp;&amp; m != last) {
1220  #if RAPIDJSON_USE_MEMBERSMAP
1221              new (&amp;mit[mpos]) MapIterator(DropMapIterator(mit[&amp;*last - members]));
1222              mit[mpos]-&gt;second = mpos;
1223  #endif
1224              *m = *last; 
1225          }
1226          else {
1227              m-&gt;~Member(); 
1228          }
1229          --o.size;
1230          return m;
1231      }
1232      MemberIterator DoEraseMembers(ConstMemberIterator first, ConstMemberIterator last) {
1233          ObjectData&amp; o = data_.o;
1234          MemberIterator beg = MemberBegin(),
1235                         pos = beg + (first - beg),
1236                         end = MemberEnd();
1237  #if RAPIDJSON_USE_MEMBERSMAP
1238          Map* &amp;map = GetMap(GetMembersPointer());
1239          MapIterator* mit = GetMapIterators(map);
1240  #endif
1241          for (MemberIterator itr = pos; itr != last; ++itr) {
1242  #if RAPIDJSON_USE_MEMBERSMAP
1243              map-&gt;erase(DropMapIterator(mit[itr - beg]));
1244  #endif
1245              itr-&gt;~Member();
1246          }
1247  #if RAPIDJSON_USE_MEMBERSMAP
1248          if (first != last) {
1249              MemberIterator next = pos + (last - first);
1250              for (MemberIterator itr = pos; next != end; ++itr, ++next) {
1251                  std::memcpy(static_cast&lt;void*&gt;(&amp;*itr), &amp;*next, sizeof(Member));
1252                  SizeType mpos = static_cast&lt;SizeType&gt;(itr - beg);
1253                  new (&amp;mit[mpos]) MapIterator(DropMapIterator(mit[next - beg]));
1254                  mit[mpos]-&gt;second = mpos;
1255              }
1256          }
1257  #else
1258          std::memmove(static_cast&lt;void*&gt;(&amp;*pos), &amp;*last,
1259                       static_cast&lt;size_t&gt;(end - last) * sizeof(Member));
1260  #endif
1261          o.size -= static_cast&lt;SizeType&gt;(last - first);
1262          return pos;
1263      }
1264      template &lt;typename SourceAllocator&gt;
1265      void DoCopyMembers(const GenericValue&lt;Encoding,SourceAllocator&gt;&amp; rhs, Allocator&amp; allocator, bool copyConstStrings) {
1266          RAPIDJSON_ASSERT(rhs.GetType() == kObjectType);
1267          data_.f.flags = kObjectFlag;
1268          SizeType count = rhs.data_.o.size;
1269          Member* lm = DoAllocMembers(count, allocator);
1270          const typename GenericValue&lt;Encoding,SourceAllocator&gt;::Member* rm = rhs.GetMembersPointer();
1271  #if RAPIDJSON_USE_MEMBERSMAP
1272          Map* &amp;map = GetMap(lm);
1273          MapIterator* mit = GetMapIterators(map);
1274  #endif
1275          for (SizeType i = 0; i &lt; count; i++) {
1276              new (&amp;lm[i].name) GenericValue(rm[i].name, allocator, copyConstStrings);
1277              new (&amp;lm[i].value) GenericValue(rm[i].value, allocator, copyConstStrings);
1278  #if RAPIDJSON_USE_MEMBERSMAP
1279              new (&amp;mit[i]) MapIterator(map-&gt;insert(MapPair(lm[i].name.data_, i)));
1280  #endif
1281          }
1282          data_.o.size = data_.o.capacity = count;
1283          SetMembersPointer(lm);
1284      }
1285      void SetArrayRaw(GenericValue* values, SizeType count, Allocator&amp; allocator) {
1286          data_.f.flags = kArrayFlag;
1287          if (count) {
1288              GenericValue* e = static_cast&lt;GenericValue*&gt;(allocator.Malloc(count * sizeof(GenericValue)));
1289              SetElementsPointer(e);
1290              std::memcpy(static_cast&lt;void*&gt;(e), values, count * sizeof(GenericValue));
1291          }
1292          else
1293              SetElementsPointer(0);
1294          data_.a.size = data_.a.capacity = count;
1295      }
1296      void SetObjectRaw(Member* members, SizeType count, Allocator&amp; allocator) {
1297          data_.f.flags = kObjectFlag;
1298          if (count) {
1299              Member* m = DoAllocMembers(count, allocator);
1300              SetMembersPointer(m);
1301              std::memcpy(static_cast&lt;void*&gt;(m), members, count * sizeof(Member));
1302  #if RAPIDJSON_USE_MEMBERSMAP
1303              Map* &amp;map = GetMap(m);
1304              MapIterator* mit = GetMapIterators(map);
1305              for (SizeType i = 0; i &lt; count; i++) {
1306                  new (&amp;mit[i]) MapIterator(map-&gt;insert(MapPair(m[i].name.data_, i)));
1307              }
1308  #endif
1309          }
1310          else
1311              SetMembersPointer(0);
1312          data_.o.size = data_.o.capacity = count;
1313      }
1314      void SetStringRaw(StringRefType s) RAPIDJSON_NOEXCEPT {
1315          data_.f.flags = kConstStringFlag;
1316          SetStringPointer(s);
1317          data_.s.length = s.length;
1318      }
1319      void SetStringRaw(StringRefType s, Allocator&amp; allocator) {
1320          Ch* str = 0;
1321          if (ShortString::Usable(s.length)) {
1322              data_.f.flags = kShortStringFlag;
1323              data_.ss.SetLength(s.length);
1324              str = data_.ss.str;
1325          } else {
1326              data_.f.flags = kCopyStringFlag;
1327              data_.s.length = s.length;
1328              str = static_cast&lt;Ch *&gt;(allocator.Malloc((s.length + 1) * sizeof(Ch)));
1329              SetStringPointer(str);
1330          }
1331          std::memcpy(str, s, s.length * sizeof(Ch));
1332          str[s.length] = &#x27;\0&#x27;;
1333      }
1334      void RawAssign(GenericValue&amp; rhs) RAPIDJSON_NOEXCEPT {
1335          data_ = rhs.data_;
1336          rhs.data_.f.flags = kNullFlag;
1337      }
1338      template &lt;typename SourceAllocator&gt;
1339      bool StringEqual(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; rhs) const {
1340          RAPIDJSON_ASSERT(IsString());
1341          RAPIDJSON_ASSERT(rhs.IsString());
1342          const SizeType len1 = GetStringLength();
1343          const SizeType len2 = rhs.GetStringLength();
1344          if(len1 != len2) { return false; }
1345          const Ch* const str1 = GetString();
1346          const Ch* const str2 = rhs.GetString();
1347          if(str1 == str2) { return true; } 
1348          return (std::memcmp(str1, str2, sizeof(Ch) * len1) == 0);
1349      }
1350      Data data_;
1351  };
1352  typedef GenericValue&lt;UTF8&lt;&gt; &gt; Value;
1353  template &lt;typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR, typename StackAllocator = RAPIDJSON_DEFAULT_STACK_ALLOCATOR &gt;
1354  class GenericDocument : public GenericValue&lt;Encoding, Allocator&gt; {
1355  public:
1356      typedef typename Encoding::Ch Ch;                       
1357      typedef GenericValue&lt;Encoding, Allocator&gt; ValueType;    
1358      typedef Allocator AllocatorType;                        
1359      explicit GenericDocument(Type type, Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
1360          GenericValue&lt;Encoding, Allocator&gt;(type),  allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
1361      {
1362          if (!allocator_)
1363              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
1364      }
1365      GenericDocument(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
1366          allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
1367      {
1368          if (!allocator_)
1369              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
1370      }
1371  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1372      GenericDocument(GenericDocument&amp;&amp; rhs) RAPIDJSON_NOEXCEPT
1373          : ValueType(std::forward&lt;ValueType&gt;(rhs)), 
1374            allocator_(rhs.allocator_),
1375            ownAllocator_(rhs.ownAllocator_),
1376            stack_(std::move(rhs.stack_)),
1377            parseResult_(rhs.parseResult_)
1378      {
1379          rhs.allocator_ = 0;
1380          rhs.ownAllocator_ = 0;
1381          rhs.parseResult_ = ParseResult();
1382      }
1383  #endif
1384      ~GenericDocument() {
1385          if (ownAllocator_) {
1386              ValueType::SetNull();
1387          }
1388          Destroy();
1389      }
1390  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1391      GenericDocument&amp; operator=(GenericDocument&amp;&amp; rhs) RAPIDJSON_NOEXCEPT
1392      {
1393          ValueType::operator=(std::forward&lt;ValueType&gt;(rhs));
1394          Destroy();
1395          allocator_ = rhs.allocator_;
1396          ownAllocator_ = rhs.ownAllocator_;
1397          stack_ = std::move(rhs.stack_);
1398          parseResult_ = rhs.parseResult_;
1399          rhs.allocator_ = 0;
1400          rhs.ownAllocator_ = 0;
1401          rhs.parseResult_ = ParseResult();
1402          return *this;
1403      }
1404  #endif
1405      GenericDocument&amp; Swap(GenericDocument&amp; rhs) RAPIDJSON_NOEXCEPT {
1406          ValueType::Swap(rhs);
1407          stack_.Swap(rhs.stack_);
1408          internal::Swap(allocator_, rhs.allocator_);
1409          internal::Swap(ownAllocator_, rhs.ownAllocator_);
1410          internal::Swap(parseResult_, rhs.parseResult_);
1411          return *this;
1412      }
1413      using ValueType::Swap;
1414      friend inline void swap(GenericDocument&amp; a, GenericDocument&amp; b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
1415      template &lt;typename Generator&gt;
1416      GenericDocument&amp; Populate(Generator&amp; g) {
1417          ClearStackOnExit scope(*this);
1418          if (g(*this)) {
1419              RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); 
1420              ValueType::operator=(*stack_.template Pop&lt;ValueType&gt;(1));
1421          }
1422          return *this;
1423      }
1424      template &lt;unsigned parseFlags, typename SourceEncoding, typename InputStream&gt;
1425      GenericDocument&amp; ParseStream(InputStream&amp; is) {
1426          GenericReader&lt;SourceEncoding, Encoding, StackAllocator&gt; reader(
1427              stack_.HasAllocator() ? &amp;stack_.GetAllocator() : 0);
1428          ClearStackOnExit scope(*this);
1429          parseResult_ = reader.template Parse&lt;parseFlags&gt;(is, *this);
1430          if (parseResult_) {
1431              RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); 
1432              ValueType::operator=(*stack_.template Pop&lt;ValueType&gt;(1));
1433          }
1434          return *this;
1435      }
1436      template &lt;unsigned parseFlags, typename InputStream&gt;
1437      GenericDocument&amp; ParseStream(InputStream&amp; is) {
1438          return ParseStream&lt;parseFlags, Encoding, InputStream&gt;(is);
1439      }
1440      template &lt;typename InputStream&gt;
1441      GenericDocument&amp; ParseStream(InputStream&amp; is) {
1442          return ParseStream&lt;kParseDefaultFlags, Encoding, InputStream&gt;(is);
1443      }
1444      template &lt;unsigned parseFlags&gt;
1445      GenericDocument&amp; ParseInsitu(Ch* str) {
1446          GenericInsituStringStream&lt;Encoding&gt; s(str);
1447          return ParseStream&lt;parseFlags | kParseInsituFlag&gt;(s);
1448      }
1449      GenericDocument&amp; ParseInsitu(Ch* str) {
1450          return ParseInsitu&lt;kParseDefaultFlags&gt;(str);
1451      }
1452      template &lt;unsigned parseFlags, typename SourceEncoding&gt;
1453      GenericDocument&amp; Parse(const typename SourceEncoding::Ch* str) {
1454          RAPIDJSON_ASSERT(!(parseFlags &amp; kParseInsituFlag));
1455          GenericStringStream&lt;SourceEncoding&gt; s(str);
1456          return ParseStream&lt;parseFlags, SourceEncoding&gt;(s);
1457      }
1458      template &lt;unsigned parseFlags&gt;
1459      GenericDocument&amp; Parse(const Ch* str) {
1460          return Parse&lt;parseFlags, Encoding&gt;(str);
1461      }
1462      GenericDocument&amp; Parse(const Ch* str) {
1463          return Parse&lt;kParseDefaultFlags&gt;(str);
1464      }
1465      template &lt;unsigned parseFlags, typename SourceEncoding&gt;
1466      GenericDocument&amp; Parse(const typename SourceEncoding::Ch* str, size_t length) {
1467          RAPIDJSON_ASSERT(!(parseFlags &amp; kParseInsituFlag));
1468          MemoryStream ms(reinterpret_cast&lt;const char*&gt;(str), length * sizeof(typename SourceEncoding::Ch));
1469          EncodedInputStream&lt;SourceEncoding, MemoryStream&gt; is(ms);
1470          ParseStream&lt;parseFlags, SourceEncoding&gt;(is);
1471          return *this;
1472      }
1473      template &lt;unsigned parseFlags&gt;
1474      GenericDocument&amp; Parse(const Ch* str, size_t length) {
1475          return Parse&lt;parseFlags, Encoding&gt;(str, length);
1476      }
1477      GenericDocument&amp; Parse(const Ch* str, size_t length) {
1478          return Parse&lt;kParseDefaultFlags&gt;(str, length);
1479      }
1480  #if RAPIDJSON_HAS_STDSTRING
1481      template &lt;unsigned parseFlags, typename SourceEncoding&gt;
1482      GenericDocument&amp; Parse(const std::basic_string&lt;typename SourceEncoding::Ch&gt;&amp; str) {
1483          return Parse&lt;parseFlags, SourceEncoding&gt;(str.c_str());
1484      }
1485      template &lt;unsigned parseFlags&gt;
1486      GenericDocument&amp; Parse(const std::basic_string&lt;Ch&gt;&amp; str) {
1487          return Parse&lt;parseFlags, Encoding&gt;(str.c_str());
1488      }
1489      GenericDocument&amp; Parse(const std::basic_string&lt;Ch&gt;&amp; str) {
1490          return Parse&lt;kParseDefaultFlags&gt;(str);
1491      }
1492  #endif 
1493      bool HasParseError() const { return parseResult_.IsError(); }
1494      ParseErrorCode GetParseError() const { return parseResult_.Code(); }
1495      size_t GetErrorOffset() const { return parseResult_.Offset(); }
1496  #ifndef __clang 
1497  #endif
1498      operator ParseResult() const { return parseResult_; }
1499      Allocator&amp; GetAllocator() {
1500          RAPIDJSON_ASSERT(allocator_);
1501          return *allocator_;
1502      }
1503      size_t GetStackCapacity() const { return stack_.GetCapacity(); }
1504  private:
1505      struct ClearStackOnExit {
1506          explicit ClearStackOnExit(GenericDocument&amp; d) : d_(d) {}
1507          ~ClearStackOnExit() { d_.ClearStack(); }
1508      private:
1509          ClearStackOnExit(const ClearStackOnExit&amp;);
1510          ClearStackOnExit&amp; operator=(const ClearStackOnExit&amp;);
1511          GenericDocument&amp; d_;
1512      };
1513      template &lt;typename, typename&gt; friend class GenericValue; 
1514  public:
1515      bool Null() { new (stack_.template Push&lt;ValueType&gt;()) ValueType(); return true; }
1516      bool Bool(bool b) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(b); return true; }
1517      bool Int(int i) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(i); return true; }
1518      bool Uint(unsigned i) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(i); return true; }
1519      bool Int64(int64_t i) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(i); return true; }
1520      bool Uint64(uint64_t i) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(i); return true; }
1521      bool Double(double d) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(d); return true; }
1522      bool RawNumber(const Ch* str, SizeType length, bool copy) {
1523          if (copy)
1524              new (stack_.template Push&lt;ValueType&gt;()) ValueType(str, length, GetAllocator());
1525          else
1526              new (stack_.template Push&lt;ValueType&gt;()) ValueType(str, length);
1527          return true;
1528      }
1529      bool String(const Ch* str, SizeType length, bool copy) {
1530          if (copy)
1531              new (stack_.template Push&lt;ValueType&gt;()) ValueType(str, length, GetAllocator());
1532          else
1533              new (stack_.template Push&lt;ValueType&gt;()) ValueType(str, length);
1534          return true;
1535      }
1536      bool StartObject() { new (stack_.template Push&lt;ValueType&gt;()) ValueType(kObjectType); return true; }
1537      bool Key(const Ch* str, SizeType length, bool copy) { return String(str, length, copy); }
1538      bool EndObject(SizeType memberCount) {
1539          typename ValueType::Member* members = stack_.template Pop&lt;typename ValueType::Member&gt;(memberCount);
1540          stack_.template Top&lt;ValueType&gt;()-&gt;SetObjectRaw(members, memberCount, GetAllocator());
1541          return true;
1542      }
1543      bool StartArray() { new (stack_.template Push&lt;ValueType&gt;()) ValueType(kArrayType); return true; }
1544      bool EndArray(SizeType elementCount) {
1545          ValueType* elements = stack_.template Pop&lt;ValueType&gt;(elementCount);
1546          stack_.template Top&lt;ValueType&gt;()-&gt;SetArrayRaw(elements, elementCount, GetAllocator());
1547          return true;
1548      }
1549  private:
1550      GenericDocument(const GenericDocument&amp;);
1551      GenericDocument&amp; operator=(const GenericDocument&amp;);
1552      void ClearStack() {
1553          if (Allocator::kNeedFree)
1554              while (stack_.GetSize() &gt; 0)    
1555                  (stack_.template Pop&lt;ValueType&gt;(1))-&gt;~ValueType();
1556          else
1557              stack_.Clear();
1558          stack_.ShrinkToFit();
1559      }
1560      void Destroy() {
1561          RAPIDJSON_DELETE(ownAllocator_);
1562      }
1563      static const size_t kDefaultStackCapacity = 1024;
1564      Allocator* allocator_;
1565      Allocator* ownAllocator_;
1566      internal::Stack&lt;StackAllocator&gt; stack_;
1567      ParseResult parseResult_;
1568  };
1569  typedef GenericDocument&lt;UTF8&lt;&gt; &gt; Document;
1570  template &lt;bool Const, typename ValueT&gt;
1571  class GenericArray {
1572  public:
1573      typedef GenericArray&lt;true, ValueT&gt; ConstArray;
1574      typedef GenericArray&lt;false, ValueT&gt; Array;
1575      typedef ValueT PlainType;
1576      typedef typename internal::MaybeAddConst&lt;Const,PlainType&gt;::Type ValueType;
1577      typedef ValueType* ValueIterator;  
1578      typedef const ValueT* ConstValueIterator;
1579      typedef typename ValueType::AllocatorType AllocatorType;
1580      typedef typename ValueType::StringRefType StringRefType;
1581      template &lt;typename, typename&gt;
1582      friend class GenericValue;
1583      GenericArray(const GenericArray&amp; rhs) : value_(rhs.value_) {}
1584      GenericArray&amp; operator=(const GenericArray&amp; rhs) { value_ = rhs.value_; return *this; }
1585      ~GenericArray() {}
1586      operator ValueType&amp;() const { return value_; }
1587      SizeType Size() const { return value_.Size(); }
1588      SizeType Capacity() const { return value_.Capacity(); }
1589      bool Empty() const { return value_.Empty(); }
1590      void Clear() const { value_.Clear(); }
1591      ValueType&amp; operator[](SizeType index) const {  return value_[index]; }
1592      ValueIterator Begin() const { return value_.Begin(); }
1593      ValueIterator End() const { return value_.End(); }
1594      GenericArray Reserve(SizeType newCapacity, AllocatorType &amp;allocator) const { value_.Reserve(newCapacity, allocator); return *this; }
1595      GenericArray PushBack(ValueType&amp; value, AllocatorType&amp; allocator) const { value_.PushBack(value, allocator); return *this; }
1596  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1597      GenericArray PushBack(ValueType&amp;&amp; value, AllocatorType&amp; allocator) const { value_.PushBack(value, allocator); return *this; }
1598  #endif 
1599      GenericArray PushBack(StringRefType value, AllocatorType&amp; allocator) const { value_.PushBack(value, allocator); return *this; }
1600      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (const GenericArray&amp;)) PushBack(T value, AllocatorType&amp; allocator) const { value_.PushBack(value, allocator); return *this; }
1601      GenericArray PopBack() const { value_.PopBack(); return *this; }
1602      ValueIterator Erase(ConstValueIterator pos) const { return value_.Erase(pos); }
1603      ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) const { return value_.Erase(first, last); }
1604  #if RAPIDJSON_HAS_CXX11_RANGE_FOR
1605      ValueIterator begin() const { return value_.Begin(); }
1606      ValueIterator end() const { return value_.End(); }
1607  #endif
1608  private:
1609      GenericArray();
1610      GenericArray(ValueType&amp; value) : value_(value) {}
1611      ValueType&amp; value_;
1612  };
1613  template &lt;bool Const, typename ValueT&gt;
1614  class GenericObject {
1615  public:
1616      typedef GenericObject&lt;true, ValueT&gt; ConstObject;
1617      typedef GenericObject&lt;false, ValueT&gt; Object;
1618      typedef ValueT PlainType;
1619      typedef typename internal::MaybeAddConst&lt;Const,PlainType&gt;::Type ValueType;
1620      typedef GenericMemberIterator&lt;Const, typename ValueT::EncodingType, typename ValueT::AllocatorType&gt; MemberIterator;  
1621      typedef GenericMemberIterator&lt;true, typename ValueT::EncodingType, typename ValueT::AllocatorType&gt; ConstMemberIterator;
1622      typedef typename ValueType::AllocatorType AllocatorType;
1623      typedef typename ValueType::StringRefType StringRefType;
1624      typedef typename ValueType::EncodingType EncodingType;
1625      typedef typename ValueType::Ch Ch;
1626      template &lt;typename, typename&gt;
1627      friend class GenericValue;
1628      GenericObject(const GenericObject&amp; rhs) : value_(rhs.value_) {}
1629      GenericObject&amp; operator=(const GenericObject&amp; rhs) { value_ = rhs.value_; return *this; }
1630      ~GenericObject() {}
1631      operator ValueType&amp;() const { return value_; }
1632      SizeType MemberCount() const { return value_.MemberCount(); }
1633      SizeType MemberCapacity() const { return value_.MemberCapacity(); }
1634      bool ObjectEmpty() const { return value_.ObjectEmpty(); }
1635      template &lt;typename T&gt; ValueType&amp; operator[](T* name) const { return value_[name]; }
1636      template &lt;typename SourceAllocator&gt; ValueType&amp; operator[](const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_[name]; }
1637  #if RAPIDJSON_HAS_STDSTRING
1638      ValueType&amp; operator[](const std::basic_string&lt;Ch&gt;&amp; name) const { return value_[name]; }
1639  #endif
1640      MemberIterator MemberBegin() const { return value_.MemberBegin(); }
1641      MemberIterator MemberEnd() const { return value_.MemberEnd(); }
1642      GenericObject MemberReserve(SizeType newCapacity, AllocatorType &amp;allocator) const { value_.MemberReserve(newCapacity, allocator); return *this; }
1643      bool HasMember(const Ch* name) const { return value_.HasMember(name); }
1644  #if RAPIDJSON_HAS_STDSTRING
1645      bool HasMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return value_.HasMember(name); }
1646  #endif
1647      template &lt;typename SourceAllocator&gt; bool HasMember(const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_.HasMember(name); }
1648      MemberIterator FindMember(const Ch* name) const { return value_.FindMember(name); }
1649      template &lt;typename SourceAllocator&gt; MemberIterator FindMember(const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_.FindMember(name); }
1650  #if RAPIDJSON_HAS_STDSTRING
1651      MemberIterator FindMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return value_.FindMember(name); }
1652  #endif
1653      GenericObject AddMember(ValueType&amp; name, ValueType&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1654      GenericObject AddMember(ValueType&amp; name, StringRefType value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1655  #if RAPIDJSON_HAS_STDSTRING
1656      GenericObject AddMember(ValueType&amp; name, std::basic_string&lt;Ch&gt;&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1657  #endif
1658      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (ValueType&amp;)) AddMember(ValueType&amp; name, T value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1659  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1660      GenericObject AddMember(ValueType&amp;&amp; name, ValueType&amp;&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1661      GenericObject AddMember(ValueType&amp;&amp; name, ValueType&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1662      GenericObject AddMember(ValueType&amp; name, ValueType&amp;&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1663      GenericObject AddMember(StringRefType name, ValueType&amp;&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1664  #endif 
1665      GenericObject AddMember(StringRefType name, ValueType&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1666      GenericObject AddMember(StringRefType name, StringRefType value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1667      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (GenericObject)) AddMember(StringRefType name, T value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1668      void RemoveAllMembers() { value_.RemoveAllMembers(); }
1669      bool RemoveMember(const Ch* name) const { return value_.RemoveMember(name); }
1670  #if RAPIDJSON_HAS_STDSTRING
1671      bool RemoveMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return value_.RemoveMember(name); }
1672  #endif
1673      template &lt;typename SourceAllocator&gt; bool RemoveMember(const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_.RemoveMember(name); }
1674      MemberIterator RemoveMember(MemberIterator m) const { return value_.RemoveMember(m); }
1675      MemberIterator EraseMember(ConstMemberIterator pos) const { return value_.EraseMember(pos); }
1676      MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) const { return value_.EraseMember(first, last); }
1677      bool EraseMember(const Ch* name) const { return value_.EraseMember(name); }
1678  #if RAPIDJSON_HAS_STDSTRING
1679      bool EraseMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return EraseMember(ValueType(StringRef(name))); }
1680  #endif
1681      template &lt;typename SourceAllocator&gt; bool EraseMember(const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_.EraseMember(name); }
1682  #if RAPIDJSON_HAS_CXX11_RANGE_FOR
1683      MemberIterator begin() const { return value_.MemberBegin(); }
1684      MemberIterator end() const { return value_.MemberEnd(); }
1685  #endif
1686  private:
1687      GenericObject();
1688      GenericObject(ValueType&amp; value) : value_(value) {}
1689      ValueType&amp; value_;
1690  };
1691  RAPIDJSON_NAMESPACE_END
1692  RAPIDJSON_DIAG_POP
1693  #ifdef RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
1694  #pragma pop_macro(&quot;GetObject&quot;)
1695  #undef RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
1696  #endif
1697  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-document.h</h3>
            <pre><code>1  #ifndef RAPIDJSON_DOCUMENT_H_
2  #define RAPIDJSON_DOCUMENT_H_
3  #include &quot;reader.h&quot;
4  #include &quot;internal/meta.h&quot;
5  #include &quot;internal/strfunc.h&quot;
6  #include &quot;memorystream.h&quot;
7  #include &quot;encodedstream.h&quot;
8  #include &lt;new&gt;      
9  #include &lt;limits&gt;
10  #ifdef __cpp_lib_three_way_comparison
11  #include &lt;compare&gt;
12  #endif
13  RAPIDJSON_DIAG_PUSH
14  #ifdef __clang__
15  RAPIDJSON_DIAG_OFF(padded)
16  RAPIDJSON_DIAG_OFF(switch-enum)
17  RAPIDJSON_DIAG_OFF(c++98-compat)
18  #elif defined(_MSC_VER)
19  RAPIDJSON_DIAG_OFF(4127) 
20  RAPIDJSON_DIAG_OFF(4244) 
21  #endif
22  #ifdef __GNUC__
23  RAPIDJSON_DIAG_OFF(effc++)
24  #endif 
25  #ifdef GetObject
26  #pragma push_macro(&quot;GetObject&quot;)
27  #define RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
28  #undef GetObject
29  #endif
30  #ifndef RAPIDJSON_NOMEMBERITERATORCLASS
31  #include &lt;iterator&gt; 
32  #endif
33  #if RAPIDJSON_USE_MEMBERSMAP
34  #include &lt;map&gt; 
35  #endif
36  RAPIDJSON_NAMESPACE_BEGIN
37  template &lt;typename Encoding, typename Allocator&gt;
38  class GenericValue;
39  template &lt;typename Encoding, typename Allocator, typename StackAllocator&gt;
40  class GenericDocument;
41  #ifndef RAPIDJSON_DEFAULT_ALLOCATOR
42  #define RAPIDJSON_DEFAULT_ALLOCATOR MemoryPoolAllocator&lt;CrtAllocator&gt;
43  #endif
44  #ifndef RAPIDJSON_DEFAULT_STACK_ALLOCATOR
45  #define RAPIDJSON_DEFAULT_STACK_ALLOCATOR CrtAllocator
46  #endif
47  #ifndef RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY
48  #define RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY 16
49  #endif
50  #ifndef RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY
51  #define RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY 16
52  #endif
53  template &lt;typename Encoding, typename Allocator&gt;
54  class GenericMember {
55  public:
56      GenericValue&lt;Encoding, Allocator&gt; name;     
57      GenericValue&lt;Encoding, Allocator&gt; value;    
58  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
59      GenericMember(GenericMember&amp;&amp; rhs) RAPIDJSON_NOEXCEPT
60          : name(std::move(rhs.name)),
61            value(std::move(rhs.value))
62      {
63      }
64      GenericMember&amp; operator=(GenericMember&amp;&amp; rhs) RAPIDJSON_NOEXCEPT {
65          return *this = static_cast&lt;GenericMember&amp;&gt;(rhs);
66      }
67  #endif
68      GenericMember&amp; operator=(GenericMember&amp; rhs) RAPIDJSON_NOEXCEPT {
69          if (RAPIDJSON_LIKELY(this != &amp;rhs)) {
70              name = rhs.name;
71              value = rhs.value;
72          }
73          return *this;
74      }
75      friend inline void swap(GenericMember&amp; a, GenericMember&amp; b) RAPIDJSON_NOEXCEPT {
76          a.name.Swap(b.name);
77          a.value.Swap(b.value);
78      }
79  private:
80      GenericMember(const GenericMember&amp; rhs);
81  };
82  #ifndef RAPIDJSON_NOMEMBERITERATORCLASS
83  template &lt;bool Const, typename Encoding, typename Allocator&gt;
84  class GenericMemberIterator {
85      friend class GenericValue&lt;Encoding,Allocator&gt;;
86      template &lt;bool, typename, typename&gt; friend class GenericMemberIterator;
87      typedef GenericMember&lt;Encoding,Allocator&gt; PlainType;
88      typedef typename internal::MaybeAddConst&lt;Const,PlainType&gt;::Type ValueType;
89  public:
90      typedef GenericMemberIterator Iterator;
91      typedef GenericMemberIterator&lt;true,Encoding,Allocator&gt;  ConstIterator;
92      typedef GenericMemberIterator&lt;false,Encoding,Allocator&gt; NonConstIterator;
93      typedef ValueType      value_type;
94      typedef ValueType *    pointer;
95      typedef ValueType &amp;    reference;
96      typedef std::ptrdiff_t difference_type;
97      typedef std::random_access_iterator_tag iterator_category;
98      typedef pointer         Pointer;
99      typedef reference       Reference;
100      typedef difference_type DifferenceType;
101      GenericMemberIterator() : ptr_() {}
102      GenericMemberIterator(const NonConstIterator &amp; it) : ptr_(it.ptr_) {}
103      Iterator&amp; operator=(const NonConstIterator &amp; it) { ptr_ = it.ptr_; return *this; }
104      Iterator&amp; operator++(){ ++ptr_; return *this; }
105      Iterator&amp; operator--(){ --ptr_; return *this; }
106      Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }
107      Iterator  operator--(int){ Iterator old(*this); --ptr_; return old; }
108      Iterator operator+(DifferenceType n) const { return Iterator(ptr_+n); }
109      Iterator operator-(DifferenceType n) const { return Iterator(ptr_-n); }
110      Iterator&amp; operator+=(DifferenceType n) { ptr_+=n; return *this; }
111      Iterator&amp; operator-=(DifferenceType n) { ptr_-=n; return *this; }
112      template &lt;bool Const_&gt; bool operator==(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ == that.ptr_; }
113      template &lt;bool Const_&gt; bool operator!=(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ != that.ptr_; }
114      template &lt;bool Const_&gt; bool operator&lt;=(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &lt;= that.ptr_; }
115      template &lt;bool Const_&gt; bool operator&gt;=(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &gt;= that.ptr_; }
116      template &lt;bool Const_&gt; bool operator&lt; (const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &lt; that.ptr_; }
117      template &lt;bool Const_&gt; bool operator&gt; (const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &gt; that.ptr_; }
118  #ifdef __cpp_lib_three_way_comparison
119      template &lt;bool Const_&gt; std::strong_ordering operator&lt;=&gt;(const GenericMemberIterator&lt;Const_, Encoding, Allocator&gt;&amp; that) const { return ptr_ &lt;=&gt; that.ptr_; }
120  #endif
121      Reference operator*() const { return *ptr_; }
122      Pointer   operator-&gt;() const { return ptr_; }
123      Reference operator[](DifferenceType n) const { return ptr_[n]; }
124      DifferenceType operator-(ConstIterator that) const { return ptr_-that.ptr_; }
125  private:
126      explicit GenericMemberIterator(Pointer p) : ptr_(p) {}
127      Pointer ptr_; 
128  };
129  #else 
130  template &lt;bool Const, typename Encoding, typename Allocator&gt;
131  class GenericMemberIterator;
132  template &lt;typename Encoding, typename Allocator&gt;
133  class GenericMemberIterator&lt;false,Encoding,Allocator&gt; {
134  public:
135      typedef GenericMember&lt;Encoding,Allocator&gt;* Iterator;
136  };
137  template &lt;typename Encoding, typename Allocator&gt;
138  class GenericMemberIterator&lt;true,Encoding,Allocator&gt; {
139  public:
140      typedef const GenericMember&lt;Encoding,Allocator&gt;* Iterator;
141  };
142  #endif 
143  template&lt;typename CharType&gt;
144  struct GenericStringRef {
145      typedef CharType Ch; 
146  #ifndef __clang__ 
147  #endif
148      template&lt;SizeType N&gt;
149      GenericStringRef(const CharType (&amp;str)[N]) RAPIDJSON_NOEXCEPT
150          : s(str), length(N-1) {}
151  #ifndef __clang__ 
152  #endif
153      explicit GenericStringRef(const CharType* str)
154          : s(str), length(NotNullStrLen(str)) {}
155  #ifndef __clang__ 
156  #endif
157      GenericStringRef(const CharType* str, SizeType len)
158          : s(RAPIDJSON_LIKELY(str) ? str : emptyString), length(len) { RAPIDJSON_ASSERT(str != 0 || len == 0u); }
159      GenericStringRef(const GenericStringRef&amp; rhs) : s(rhs.s), length(rhs.length) {}
160      operator const Ch *() const { return s; }
161      const Ch* const s; 
162      const SizeType length; 
163  private:
164      SizeType NotNullStrLen(const CharType* str) {
165          RAPIDJSON_ASSERT(str != 0);
166          return internal::StrLen(str);
167      }
168      static const Ch emptyString[];
169      template&lt;SizeType N&gt;
170      GenericStringRef(CharType (&amp;str)[N]) &amp;bsol;* = delete */;
171      GenericStringRef&amp; operator=(const GenericStringRef&amp; rhs) &amp;bsol;* = delete */;
172  };
173  template&lt;typename CharType&gt;
174  const CharType GenericStringRef&lt;CharType&gt;::emptyString[] = { CharType() };
175  template&lt;typename CharType&gt;
176  inline GenericStringRef&lt;CharType&gt; StringRef(const CharType* str) {
177      return GenericStringRef&lt;CharType&gt;(str);
178  }
179  template&lt;typename CharType&gt;
180  inline GenericStringRef&lt;CharType&gt; StringRef(const CharType* str, size_t length) {
181      return GenericStringRef&lt;CharType&gt;(str, SizeType(length));
182  }
183  #if RAPIDJSON_HAS_STDSTRING
184  template&lt;typename CharType&gt;
185  inline GenericStringRef&lt;CharType&gt; StringRef(const std::basic_string&lt;CharType&gt;&amp; str) {
186      return GenericStringRef&lt;CharType&gt;(str.data(), SizeType(str.size()));
187  }
188  #endif
189  namespace internal {
190  template &lt;typename T, typename Encoding = void, typename Allocator = void&gt;
191  struct IsGenericValueImpl : FalseType {};
192  template &lt;typename T&gt; struct IsGenericValueImpl&lt;T, typename Void&lt;typename T::EncodingType&gt;::Type, typename Void&lt;typename T::AllocatorType&gt;::Type&gt;
193      : IsBaseOf&lt;GenericValue&lt;typename T::EncodingType, typename T::AllocatorType&gt;, T&gt;::Type {};
194  template &lt;typename T&gt; struct IsGenericValue : IsGenericValueImpl&lt;T&gt;::Type {};
195  } 
196  namespace internal {
197  template &lt;typename ValueType, typename T&gt;
198  struct TypeHelper {};
199  template&lt;typename ValueType&gt;
200  struct TypeHelper&lt;ValueType, bool&gt; {
201      static bool Is(const ValueType&amp; v) { return v.IsBool(); }
202      static bool Get(const ValueType&amp; v) { return v.GetBool(); }
203      static ValueType&amp; Set(ValueType&amp; v, bool data) { return v.SetBool(data); }
204      static ValueType&amp; Set(ValueType&amp; v, bool data, typename ValueType::AllocatorType&amp;) { return v.SetBool(data); }
205  };
206  template&lt;typename ValueType&gt;
207  struct TypeHelper&lt;ValueType, int&gt; {
208      static bool Is(const ValueType&amp; v) { return v.IsInt(); }
209      static int Get(const ValueType&amp; v) { return v.GetInt(); }
210      static ValueType&amp; Set(ValueType&amp; v, int data) { return v.SetInt(data); }
211      static ValueType&amp; Set(ValueType&amp; v, int data, typename ValueType::AllocatorType&amp;) { return v.SetInt(data); }
212  };
213  template&lt;typename ValueType&gt;
214  struct TypeHelper&lt;ValueType, unsigned&gt; {
215      static bool Is(const ValueType&amp; v) { return v.IsUint(); }
216      static unsigned Get(const ValueType&amp; v) { return v.GetUint(); }
217      static ValueType&amp; Set(ValueType&amp; v, unsigned data) { return v.SetUint(data); }
218      static ValueType&amp; Set(ValueType&amp; v, unsigned data, typename ValueType::AllocatorType&amp;) { return v.SetUint(data); }
219  };
220  #ifdef _MSC_VER
221  RAPIDJSON_STATIC_ASSERT(sizeof(long) == sizeof(int));
222  template&lt;typename ValueType&gt;
223  struct TypeHelper&lt;ValueType, long&gt; {
224      static bool Is(const ValueType&amp; v) { return v.IsInt(); }
225      static long Get(const ValueType&amp; v) { return v.GetInt(); }
226      static ValueType&amp; Set(ValueType&amp; v, long data) { return v.SetInt(data); }
227      static ValueType&amp; Set(ValueType&amp; v, long data, typename ValueType::AllocatorType&amp;) { return v.SetInt(data); }
228  };
229  RAPIDJSON_STATIC_ASSERT(sizeof(unsigned long) == sizeof(unsigned));
230  template&lt;typename ValueType&gt;
231  struct TypeHelper&lt;ValueType, unsigned long&gt; {
232      static bool Is(const ValueType&amp; v) { return v.IsUint(); }
233      static unsigned long Get(const ValueType&amp; v) { return v.GetUint(); }
234      static ValueType&amp; Set(ValueType&amp; v, unsigned long data) { return v.SetUint(data); }
235      static ValueType&amp; Set(ValueType&amp; v, unsigned long data, typename ValueType::AllocatorType&amp;) { return v.SetUint(data); }
236  };
237  #endif
238  template&lt;typename ValueType&gt;
239  struct TypeHelper&lt;ValueType, int64_t&gt; {
240      static bool Is(const ValueType&amp; v) { return v.IsInt64(); }
241      static int64_t Get(const ValueType&amp; v) { return v.GetInt64(); }
242      static ValueType&amp; Set(ValueType&amp; v, int64_t data) { return v.SetInt64(data); }
243      static ValueType&amp; Set(ValueType&amp; v, int64_t data, typename ValueType::AllocatorType&amp;) { return v.SetInt64(data); }
244  };
245  template&lt;typename ValueType&gt;
246  struct TypeHelper&lt;ValueType, uint64_t&gt; {
247      static bool Is(const ValueType&amp; v) { return v.IsUint64(); }
248      static uint64_t Get(const ValueType&amp; v) { return v.GetUint64(); }
249      static ValueType&amp; Set(ValueType&amp; v, uint64_t data) { return v.SetUint64(data); }
250      static ValueType&amp; Set(ValueType&amp; v, uint64_t data, typename ValueType::AllocatorType&amp;) { return v.SetUint64(data); }
251  };
252  template&lt;typename ValueType&gt;
253  struct TypeHelper&lt;ValueType, double&gt; {
254      static bool Is(const ValueType&amp; v) { return v.IsDouble(); }
255      static double Get(const ValueType&amp; v) { return v.GetDouble(); }
256      static ValueType&amp; Set(ValueType&amp; v, double data) { return v.SetDouble(data); }
257      static ValueType&amp; Set(ValueType&amp; v, double data, typename ValueType::AllocatorType&amp;) { return v.SetDouble(data); }
258  };
259  template&lt;typename ValueType&gt;
260  struct TypeHelper&lt;ValueType, float&gt; {
261      static bool Is(const ValueType&amp; v) { return v.IsFloat(); }
262      static float Get(const ValueType&amp; v) { return v.GetFloat(); }
263      static ValueType&amp; Set(ValueType&amp; v, float data) { return v.SetFloat(data); }
264      static ValueType&amp; Set(ValueType&amp; v, float data, typename ValueType::AllocatorType&amp;) { return v.SetFloat(data); }
265  };
266  template&lt;typename ValueType&gt;
267  struct TypeHelper&lt;ValueType, const typename ValueType::Ch*&gt; {
268      typedef const typename ValueType::Ch* StringType;
269      static bool Is(const ValueType&amp; v) { return v.IsString(); }
270      static StringType Get(const ValueType&amp; v) { return v.GetString(); }
271      static ValueType&amp; Set(ValueType&amp; v, const StringType data) { return v.SetString(typename ValueType::StringRefType(data)); }
272      static ValueType&amp; Set(ValueType&amp; v, const StringType data, typename ValueType::AllocatorType&amp; a) { return v.SetString(data, a); }
273  };
274  #if RAPIDJSON_HAS_STDSTRING
275  template&lt;typename ValueType&gt;
276  struct TypeHelper&lt;ValueType, std::basic_string&lt;typename ValueType::Ch&gt; &gt; {
277      typedef std::basic_string&lt;typename ValueType::Ch&gt; StringType;
278      static bool Is(const ValueType&amp; v) { return v.IsString(); }
279      static StringType Get(const ValueType&amp; v) { return StringType(v.GetString(), v.GetStringLength()); }
280      static ValueType&amp; Set(ValueType&amp; v, const StringType&amp; data, typename ValueType::AllocatorType&amp; a) { return v.SetString(data, a); }
281  };
282  #endif
283  template&lt;typename ValueType&gt;
284  struct TypeHelper&lt;ValueType, typename ValueType::Array&gt; {
285      typedef typename ValueType::Array ArrayType;
286      static bool Is(const ValueType&amp; v) { return v.IsArray(); }
287      static ArrayType Get(ValueType&amp; v) { return v.GetArray(); }
288      static ValueType&amp; Set(ValueType&amp; v, ArrayType data) { return v = data; }
289      static ValueType&amp; Set(ValueType&amp; v, ArrayType data, typename ValueType::AllocatorType&amp;) { return v = data; }
290  };
291  template&lt;typename ValueType&gt;
292  struct TypeHelper&lt;ValueType, typename ValueType::ConstArray&gt; {
293      typedef typename ValueType::ConstArray ArrayType;
294      static bool Is(const ValueType&amp; v) { return v.IsArray(); }
295      static ArrayType Get(const ValueType&amp; v) { return v.GetArray(); }
296  };
297  template&lt;typename ValueType&gt;
298  struct TypeHelper&lt;ValueType, typename ValueType::Object&gt; {
299      typedef typename ValueType::Object ObjectType;
300      static bool Is(const ValueType&amp; v) { return v.IsObject(); }
301      static ObjectType Get(ValueType&amp; v) { return v.GetObject(); }
302      static ValueType&amp; Set(ValueType&amp; v, ObjectType data) { return v = data; }
303      static ValueType&amp; Set(ValueType&amp; v, ObjectType data, typename ValueType::AllocatorType&amp;) { return v = data; }
304  };
305  template&lt;typename ValueType&gt;
306  struct TypeHelper&lt;ValueType, typename ValueType::ConstObject&gt; {
307      typedef typename ValueType::ConstObject ObjectType;
308      static bool Is(const ValueType&amp; v) { return v.IsObject(); }
309      static ObjectType Get(const ValueType&amp; v) { return v.GetObject(); }
310  };
311  } 
312  template &lt;bool, typename&gt; class GenericArray;
313  template &lt;bool, typename&gt; class GenericObject;
314  template &lt;typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR &gt;
315  class GenericValue {
316  public:
317      typedef GenericMember&lt;Encoding, Allocator&gt; Member;
318      typedef Encoding EncodingType;                  
319      typedef Allocator AllocatorType;                
320      typedef typename Encoding::Ch Ch;               
321      typedef GenericStringRef&lt;Ch&gt; StringRefType;     
322      typedef typename GenericMemberIterator&lt;false,Encoding,Allocator&gt;::Iterator MemberIterator;  
323      typedef typename GenericMemberIterator&lt;true,Encoding,Allocator&gt;::Iterator ConstMemberIterator;  
324      typedef GenericValue* ValueIterator;            
325      typedef const GenericValue* ConstValueIterator; 
326      typedef GenericValue&lt;Encoding, Allocator&gt; ValueType;    
327      typedef GenericArray&lt;false, ValueType&gt; Array;
328      typedef GenericArray&lt;true, ValueType&gt; ConstArray;
329      typedef GenericObject&lt;false, ValueType&gt; Object;
330      typedef GenericObject&lt;true, ValueType&gt; ConstObject;
331      GenericValue() RAPIDJSON_NOEXCEPT : data_() { data_.f.flags = kNullFlag; }
332  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
333      GenericValue(GenericValue&amp;&amp; rhs) RAPIDJSON_NOEXCEPT : data_(rhs.data_) {
334          rhs.data_.f.flags = kNullFlag; 
335      }
336  #endif
337  private:
338      GenericValue(const GenericValue&amp; rhs);
339  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
340      template &lt;typename StackAllocator&gt;
341      GenericValue(GenericDocument&lt;Encoding,Allocator,StackAllocator&gt;&amp;&amp; rhs);
342      template &lt;typename StackAllocator&gt;
343      GenericValue&amp; operator=(GenericDocument&lt;Encoding,Allocator,StackAllocator&gt;&amp;&amp; rhs);
344  #endif
345  public:
346      explicit GenericValue(Type type) RAPIDJSON_NOEXCEPT : data_() {
347          static const uint16_t defaultFlags[] = {
348              kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kShortStringFlag,
349              kNumberAnyFlag
350          };
351          RAPIDJSON_NOEXCEPT_ASSERT(type &gt;= kNullType &amp;&amp; type &lt;= kNumberType);
352          data_.f.flags = defaultFlags[type];
353          if (type == kStringType)
354              data_.ss.SetLength(0);
355      }
356      template &lt;typename SourceAllocator&gt;
357      GenericValue(const GenericValue&lt;Encoding,SourceAllocator&gt;&amp; rhs, Allocator&amp; allocator, bool copyConstStrings = false) {
358          switch (rhs.GetType()) {
359          case kObjectType:
360              DoCopyMembers(rhs, allocator, copyConstStrings);
361              break;
362          case kArrayType: {
363                  SizeType count = rhs.data_.a.size;
364                  GenericValue* le = reinterpret_cast&lt;GenericValue*&gt;(allocator.Malloc(count * sizeof(GenericValue)));
365                  const GenericValue&lt;Encoding,SourceAllocator&gt;* re = rhs.GetElementsPointer();
366                  for (SizeType i = 0; i &lt; count; i++)
367                      new (&amp;le[i]) GenericValue(re[i], allocator, copyConstStrings);
368                  data_.f.flags = kArrayFlag;
369                  data_.a.size = data_.a.capacity = count;
370                  SetElementsPointer(le);
371              }
372              break;
373          case kStringType:
374              if (rhs.data_.f.flags == kConstStringFlag &amp;&amp; !copyConstStrings) {
375                  data_.f.flags = rhs.data_.f.flags;
376                  data_  = *reinterpret_cast&lt;const Data*&gt;(&amp;rhs.data_);
377              }
378              else
379                  SetStringRaw(StringRef(rhs.GetString(), rhs.GetStringLength()), allocator);
380              break;
381          default:
382              data_.f.flags = rhs.data_.f.flags;
383              data_  = *reinterpret_cast&lt;const Data*&gt;(&amp;rhs.data_);
384              break;
385          }
386      }
387  #ifndef RAPIDJSON_DOXYGEN_RUNNING 
388      template &lt;typename T&gt;
389      explicit GenericValue(T b, RAPIDJSON_ENABLEIF((internal::IsSame&lt;bool, T&gt;))) RAPIDJSON_NOEXCEPT  
390  #else
391      explicit GenericValue(bool b) RAPIDJSON_NOEXCEPT
392  #endif
393          : data_() {
394              RAPIDJSON_STATIC_ASSERT((internal::IsSame&lt;bool,T&gt;::Value));
395              data_.f.flags = b ? kTrueFlag : kFalseFlag;
396      }
397      explicit GenericValue(int i) RAPIDJSON_NOEXCEPT : data_() {
398          data_.n.i64 = i;
399          data_.f.flags = (i &gt;= 0) ? (kNumberIntFlag | kUintFlag | kUint64Flag) : kNumberIntFlag;
400      }
401      explicit GenericValue(unsigned u) RAPIDJSON_NOEXCEPT : data_() {
402          data_.n.u64 = u;
403          data_.f.flags = (u &amp; 0x80000000) ? kNumberUintFlag : (kNumberUintFlag | kIntFlag | kInt64Flag);
404      }
405      explicit GenericValue(int64_t i64) RAPIDJSON_NOEXCEPT : data_() {
406          data_.n.i64 = i64;
407          data_.f.flags = kNumberInt64Flag;
408          if (i64 &gt;= 0) {
409              data_.f.flags |= kNumberUint64Flag;
410              if (!(static_cast&lt;uint64_t&gt;(i64) &amp; RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))
411                  data_.f.flags |= kUintFlag;
412              if (!(static_cast&lt;uint64_t&gt;(i64) &amp; RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
413                  data_.f.flags |= kIntFlag;
414          }
415          else if (i64 &gt;= static_cast&lt;int64_t&gt;(RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
416              data_.f.flags |= kIntFlag;
417      }
418      explicit GenericValue(uint64_t u64) RAPIDJSON_NOEXCEPT : data_() {
419          data_.n.u64 = u64;
420          data_.f.flags = kNumberUint64Flag;
421          if (!(u64 &amp; RAPIDJSON_UINT64_C2(0x80000000, 0x00000000)))
422              data_.f.flags |= kInt64Flag;
423          if (!(u64 &amp; RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))
424              data_.f.flags |= kUintFlag;
425          if (!(u64 &amp; RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))
426              data_.f.flags |= kIntFlag;
427      }
428      explicit GenericValue(double d) RAPIDJSON_NOEXCEPT : data_() { data_.n.d = d; data_.f.flags = kNumberDoubleFlag; }
429      explicit GenericValue(float f) RAPIDJSON_NOEXCEPT : data_() { data_.n.d = static_cast&lt;double&gt;(f); data_.f.flags = kNumberDoubleFlag; }
430      GenericValue(const Ch* s, SizeType length) RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(StringRef(s, length)); }
431      explicit GenericValue(StringRefType s) RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(s); }
432      GenericValue(const Ch* s, SizeType length, Allocator&amp; allocator) : data_() { SetStringRaw(StringRef(s, length), allocator); }
433      GenericValue(const Ch*s, Allocator&amp; allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
434  #if RAPIDJSON_HAS_STDSTRING
435      GenericValue(const std::basic_string&lt;Ch&gt;&amp; s, Allocator&amp; allocator) : data_() { SetStringRaw(StringRef(s), allocator); }
436  #endif
437      GenericValue(Array a) RAPIDJSON_NOEXCEPT : data_(a.value_.data_) {
438          a.value_.data_ = Data();
439          a.value_.data_.f.flags = kArrayFlag;
440      }
441      GenericValue(Object o) RAPIDJSON_NOEXCEPT : data_(o.value_.data_) {
442          o.value_.data_ = Data();
443          o.value_.data_.f.flags = kObjectFlag;
444      }
445      ~GenericValue() {
446          if (Allocator::kNeedFree || (RAPIDJSON_USE_MEMBERSMAP+0 &amp;&amp;
447                                       internal::IsRefCounted&lt;Allocator&gt;::Value)) {
448              switch(data_.f.flags) {
449              case kArrayFlag:
450                  {
451                      GenericValue* e = GetElementsPointer();
452                      for (GenericValue* v = e; v != e + data_.a.size; ++v)
453                          v-&gt;~GenericValue();
454                      if (Allocator::kNeedFree) { 
455                          Allocator::Free(e);
456                      }
457                  }
458                  break;
459              case kObjectFlag:
460                  DoFreeMembers();
461                  break;
462              case kCopyStringFlag:
463                  if (Allocator::kNeedFree) { 
464                      Allocator::Free(const_cast&lt;Ch*&gt;(GetStringPointer()));
465                  }
466                  break;
467              default:
468                  break;  
469              }
470          }
471      }
472      GenericValue&amp; operator=(GenericValue&amp; rhs) RAPIDJSON_NOEXCEPT {
473          if (RAPIDJSON_LIKELY(this != &amp;rhs)) {
474              GenericValue temp;
475              temp.RawAssign(rhs);
476              this-&gt;~GenericValue();
477              RawAssign(temp);
478          }
479          return *this;
480      }
481  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
482      GenericValue&amp; operator=(GenericValue&amp;&amp; rhs) RAPIDJSON_NOEXCEPT {
483          return *this = rhs.Move();
484      }
485  #endif
486      GenericValue&amp; operator=(StringRefType str) RAPIDJSON_NOEXCEPT {
487          GenericValue s(str);
488          return *this = s;
489      }
490      template &lt;typename T&gt;
491      RAPIDJSON_DISABLEIF_RETURN((internal::IsPointer&lt;T&gt;), (GenericValue&amp;))
492      operator=(T value) {
493          GenericValue v(value);
494          return *this = v;
495      }
496      template &lt;typename SourceAllocator&gt;
497      GenericValue&amp; CopyFrom(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; rhs, Allocator&amp; allocator, bool copyConstStrings = false) {
498          RAPIDJSON_ASSERT(static_cast&lt;void*&gt;(this) != static_cast&lt;void const*&gt;(&amp;rhs));
499          this-&gt;~GenericValue();
500          new (this) GenericValue(rhs, allocator, copyConstStrings);
501          return *this;
502      }
503      GenericValue&amp; Swap(GenericValue&amp; other) RAPIDJSON_NOEXCEPT {
504          GenericValue temp;
505          temp.RawAssign(*this);
506          RawAssign(other);
507          other.RawAssign(temp);
508          return *this;
509      }
510      friend inline void swap(GenericValue&amp; a, GenericValue&amp; b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
511      GenericValue&amp; Move() RAPIDJSON_NOEXCEPT { return *this; }
512      template &lt;typename SourceAllocator&gt;
513      bool operator==(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; rhs) const {
514          typedef GenericValue&lt;Encoding, SourceAllocator&gt; RhsType;
515          if (GetType() != rhs.GetType())
516              return false;
517          switch (GetType()) {
518          case kObjectType: 
519              if (data_.o.size != rhs.data_.o.size)
520                  return false;
521              for (ConstMemberIterator lhsMemberItr = MemberBegin(); lhsMemberItr != MemberEnd(); ++lhsMemberItr) {
522                  typename RhsType::ConstMemberIterator rhsMemberItr = rhs.FindMember(lhsMemberItr-&gt;name);
523                  if (rhsMemberItr == rhs.MemberEnd() || lhsMemberItr-&gt;value != rhsMemberItr-&gt;value)
524                      return false;
525              }
526              return true;
527          case kArrayType:
528              if (data_.a.size != rhs.data_.a.size)
529                  return false;
530              for (SizeType i = 0; i &lt; data_.a.size; i++)
531                  if ((*this)[i] != rhs[i])
532                      return false;
533              return true;
534          case kStringType:
535              return StringEqual(rhs);
536          case kNumberType:
537              if (IsDouble() || rhs.IsDouble()) {
538                  double a = GetDouble();     
539                  double b = rhs.GetDouble(); 
540                  return a &gt;= b &amp;&amp; a &lt;= b;    
541              }
542              else
543                  return data_.n.u64 == rhs.data_.n.u64;
544          default:
545              return true;
546          }
547      }
548      bool operator==(const Ch* rhs) const { return *this == GenericValue(StringRef(rhs)); }
549  #if RAPIDJSON_HAS_STDSTRING
550      bool operator==(const std::basic_string&lt;Ch&gt;&amp; rhs) const { return *this == GenericValue(StringRef(rhs)); }
551  #endif
552      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;,internal::IsGenericValue&lt;T&gt; &gt;), (bool)) operator==(const T&amp; rhs) const { return *this == GenericValue(rhs); }
553      template &lt;typename SourceAllocator&gt;
554      bool operator!=(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; rhs) const { return !(*this == rhs); }
555      bool operator!=(const Ch* rhs) const { return !(*this == rhs); }
556      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue&lt;T&gt;), (bool)) operator!=(const T&amp; rhs) const { return !(*this == rhs); }
557  #ifndef __cpp_lib_three_way_comparison
558      template &lt;typename T&gt; friend RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue&lt;T&gt;), (bool)) operator==(const T&amp; lhs, const GenericValue&amp; rhs) { return rhs == lhs; }
559      template &lt;typename T&gt; friend RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue&lt;T&gt;), (bool)) operator!=(const T&amp; lhs, const GenericValue&amp; rhs) { return !(rhs == lhs); }
560  #endif
561      Type GetType()  const { return static_cast&lt;Type&gt;(data_.f.flags &amp; kTypeMask); }
562      bool IsNull()   const { return data_.f.flags == kNullFlag; }
563      bool IsFalse()  const { return data_.f.flags == kFalseFlag; }
564      bool IsTrue()   const { return data_.f.flags == kTrueFlag; }
565      bool IsBool()   const { return (data_.f.flags &amp; kBoolFlag) != 0; }
566      bool IsObject() const { return data_.f.flags == kObjectFlag; }
567      bool IsArray()  const { return data_.f.flags == kArrayFlag; }
568      bool IsNumber() const { return (data_.f.flags &amp; kNumberFlag) != 0; }
569      bool IsInt()    const { return (data_.f.flags &amp; kIntFlag) != 0; }
570      bool IsUint()   const { return (data_.f.flags &amp; kUintFlag) != 0; }
571      bool IsInt64()  const { return (data_.f.flags &amp; kInt64Flag) != 0; }
572      bool IsUint64() const { return (data_.f.flags &amp; kUint64Flag) != 0; }
573      bool IsDouble() const { return (data_.f.flags &amp; kDoubleFlag) != 0; }
574      bool IsString() const { return (data_.f.flags &amp; kStringFlag) != 0; }
575      bool IsLosslessDouble() const {
576          if (!IsNumber()) return false;
577          if (IsUint64()) {
578              uint64_t u = GetUint64();
579              volatile double d = static_cast&lt;double&gt;(u);
580              return (d &gt;= 0.0)
581                  &amp;&amp; (d &lt; static_cast&lt;double&gt;((std::numeric_limits&lt;uint64_t&gt;::max)()))
582                  &amp;&amp; (u == static_cast&lt;uint64_t&gt;(d));
583          }
584          if (IsInt64()) {
585              int64_t i = GetInt64();
586              volatile double d = static_cast&lt;double&gt;(i);
587              return (d &gt;= static_cast&lt;double&gt;((std::numeric_limits&lt;int64_t&gt;::min)()))
588                  &amp;&amp; (d &lt; static_cast&lt;double&gt;((std::numeric_limits&lt;int64_t&gt;::max)()))
589                  &amp;&amp; (i == static_cast&lt;int64_t&gt;(d));
590          }
591          return true; 
592      }
593      bool IsFloat() const  {
594          if ((data_.f.flags &amp; kDoubleFlag) == 0)
595              return false;
596          double d = GetDouble();
597          return d &gt;= -3.4028234e38 &amp;&amp; d &lt;= 3.4028234e38;
598      }
599      bool IsLosslessFloat() const {
600          if (!IsNumber()) return false;
601          double a = GetDouble();
602          if (a &lt; static_cast&lt;double&gt;(-(std::numeric_limits&lt;float&gt;::max)())
603                  || a &gt; static_cast&lt;double&gt;((std::numeric_limits&lt;float&gt;::max)()))
604              return false;
605          double b = static_cast&lt;double&gt;(static_cast&lt;float&gt;(a));
606          return a &gt;= b &amp;&amp; a &lt;= b;    
607      }
608      GenericValue&amp; SetNull() { this-&gt;~GenericValue(); new (this) GenericValue(); return *this; }
609      bool GetBool() const { RAPIDJSON_ASSERT(IsBool()); return data_.f.flags == kTrueFlag; }
610      GenericValue&amp; SetBool(bool b) { this-&gt;~GenericValue(); new (this) GenericValue(b); return *this; }
611      GenericValue&amp; SetObject() { this-&gt;~GenericValue(); new (this) GenericValue(kObjectType); return *this; }
612      SizeType MemberCount() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.size; }
613      SizeType MemberCapacity() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.capacity; }
614      bool ObjectEmpty() const { RAPIDJSON_ASSERT(IsObject()); return data_.o.size == 0; }
615      template &lt;typename T&gt;
616      RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr&lt;internal::IsSame&lt;typename internal::RemoveConst&lt;T&gt;::Type, Ch&gt; &gt;),(GenericValue&amp;)) operator[](T* name) {
617          GenericValue n(StringRef(name));
618          return (*this)[n];
619      }
620      template &lt;typename T&gt;
621      RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr&lt;internal::IsSame&lt;typename internal::RemoveConst&lt;T&gt;::Type, Ch&gt; &gt;),(const GenericValue&amp;)) operator[](T* name) const { return const_cast&lt;GenericValue&amp;&gt;(*this)[name]; }
622      template &lt;typename SourceAllocator&gt;
623      GenericValue&amp; operator[](const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
624          MemberIterator member = FindMember(name);
625          if (member != MemberEnd())
626              return member-&gt;value;
627          else {
628              RAPIDJSON_ASSERT(false);    
629              static char buffer[sizeof(GenericValue)];
630              return *new (buffer) GenericValue();
631          }
632      }
633      template &lt;typename SourceAllocator&gt;
634      const GenericValue&amp; operator[](const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) const { return const_cast&lt;GenericValue&amp;&gt;(*this)[name]; }
635  #if RAPIDJSON_HAS_STDSTRING
636      GenericValue&amp; operator[](const std::basic_string&lt;Ch&gt;&amp; name) { return (*this)[GenericValue(StringRef(name))]; }
637      const GenericValue&amp; operator[](const std::basic_string&lt;Ch&gt;&amp; name) const { return (*this)[GenericValue(StringRef(name))]; }
638  #endif
639      ConstMemberIterator MemberBegin() const { RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer()); }
640      ConstMemberIterator MemberEnd() const   { RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer() + data_.o.size); }
641      MemberIterator MemberBegin()            { RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer()); }
642      MemberIterator MemberEnd()              { RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer() + data_.o.size); }
643      GenericValue&amp; MemberReserve(SizeType newCapacity, Allocator &amp;allocator) {
644          RAPIDJSON_ASSERT(IsObject());
645          DoReserveMembers(newCapacity, allocator);
646          return *this;
647      }
648      bool HasMember(const Ch* name) const { return FindMember(name) != MemberEnd(); }
649  #if RAPIDJSON_HAS_STDSTRING
650      bool HasMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return FindMember(name) != MemberEnd(); }
651  #endif
652      template &lt;typename SourceAllocator&gt;
653      bool HasMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) const { return FindMember(name) != MemberEnd(); }
654      MemberIterator FindMember(const Ch* name) {
655          GenericValue n(StringRef(name));
656          return FindMember(n);
657      }
658      ConstMemberIterator FindMember(const Ch* name) const { return const_cast&lt;GenericValue&amp;&gt;(*this).FindMember(name); }
659      template &lt;typename SourceAllocator&gt;
660      MemberIterator FindMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
661          RAPIDJSON_ASSERT(IsObject());
662          RAPIDJSON_ASSERT(name.IsString());
663          return DoFindMember(name);
664      }
665      template &lt;typename SourceAllocator&gt; ConstMemberIterator FindMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) const { return const_cast&lt;GenericValue&amp;&gt;(*this).FindMember(name); }
666  #if RAPIDJSON_HAS_STDSTRING
667      MemberIterator FindMember(const std::basic_string&lt;Ch&gt;&amp; name) { return FindMember(GenericValue(StringRef(name))); }
668      ConstMemberIterator FindMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return FindMember(GenericValue(StringRef(name))); }
669  #endif
670      GenericValue&amp; AddMember(GenericValue&amp; name, GenericValue&amp; value, Allocator&amp; allocator) {
671          RAPIDJSON_ASSERT(IsObject());
672          RAPIDJSON_ASSERT(name.IsString());
673          DoAddMember(name, value, allocator);
674          return *this;
675      }
676      GenericValue&amp; AddMember(GenericValue&amp; name, StringRefType value, Allocator&amp; allocator) {
677          GenericValue v(value);
678          return AddMember(name, v, allocator);
679      }
680  #if RAPIDJSON_HAS_STDSTRING
681      GenericValue&amp; AddMember(GenericValue&amp; name, std::basic_string&lt;Ch&gt;&amp; value, Allocator&amp; allocator) {
682          GenericValue v(value, allocator);
683          return AddMember(name, v, allocator);
684      }
685  #endif
686      template &lt;typename T&gt;
687      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (GenericValue&amp;))
688      AddMember(GenericValue&amp; name, T value, Allocator&amp; allocator) {
689          GenericValue v(value);
690          return AddMember(name, v, allocator);
691      }
692  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
693      GenericValue&amp; AddMember(GenericValue&amp;&amp; name, GenericValue&amp;&amp; value, Allocator&amp; allocator) {
694          return AddMember(name, value, allocator);
695      }
696      GenericValue&amp; AddMember(GenericValue&amp;&amp; name, GenericValue&amp; value, Allocator&amp; allocator) {
697          return AddMember(name, value, allocator);
698      }
699      GenericValue&amp; AddMember(GenericValue&amp; name, GenericValue&amp;&amp; value, Allocator&amp; allocator) {
700          return AddMember(name, value, allocator);
701      }
702      GenericValue&amp; AddMember(StringRefType name, GenericValue&amp;&amp; value, Allocator&amp; allocator) {
703          GenericValue n(name);
704          return AddMember(n, value, allocator);
705      }
706  #endif 
707      GenericValue&amp; AddMember(StringRefType name, GenericValue&amp; value, Allocator&amp; allocator) {
708          GenericValue n(name);
709          return AddMember(n, value, allocator);
710      }
711      GenericValue&amp; AddMember(StringRefType name, StringRefType value, Allocator&amp; allocator) {
712          GenericValue v(value);
713          return AddMember(name, v, allocator);
714      }
715      template &lt;typename T&gt;
716      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (GenericValue&amp;))
717      AddMember(StringRefType name, T value, Allocator&amp; allocator) {
718          GenericValue n(name);
719          return AddMember(n, value, allocator);
720      }
721      void RemoveAllMembers() {
722          RAPIDJSON_ASSERT(IsObject());
723          DoClearMembers();
724      }
725      bool RemoveMember(const Ch* name) {
726          GenericValue n(StringRef(name));
727          return RemoveMember(n);
728      }
729  #if RAPIDJSON_HAS_STDSTRING
730      bool RemoveMember(const std::basic_string&lt;Ch&gt;&amp; name) { return RemoveMember(GenericValue(StringRef(name))); }
731  #endif
732      template &lt;typename SourceAllocator&gt;
733      bool RemoveMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
734          MemberIterator m = FindMember(name);
735          if (m != MemberEnd()) {
736              RemoveMember(m);
737              return true;
738          }
739          else
740              return false;
741      }
742      MemberIterator RemoveMember(MemberIterator m) {
743          RAPIDJSON_ASSERT(IsObject());
744          RAPIDJSON_ASSERT(data_.o.size &gt; 0);
745          RAPIDJSON_ASSERT(GetMembersPointer() != 0);
746          RAPIDJSON_ASSERT(m &gt;= MemberBegin() &amp;&amp; m &lt; MemberEnd());
747          return DoRemoveMember(m);
748      }
749      MemberIterator EraseMember(ConstMemberIterator pos) {
750          return EraseMember(pos, pos +1);
751      }
752      MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) {
753          RAPIDJSON_ASSERT(IsObject());
754          RAPIDJSON_ASSERT(data_.o.size &gt; 0);
755          RAPIDJSON_ASSERT(GetMembersPointer() != 0);
756          RAPIDJSON_ASSERT(first &gt;= MemberBegin());
757          RAPIDJSON_ASSERT(first &lt;= last);
758          RAPIDJSON_ASSERT(last &lt;= MemberEnd());
759          return DoEraseMembers(first, last);
760      }
761      bool EraseMember(const Ch* name) {
762          GenericValue n(StringRef(name));
763          return EraseMember(n);
764      }
765  #if RAPIDJSON_HAS_STDSTRING
766      bool EraseMember(const std::basic_string&lt;Ch&gt;&amp; name) { return EraseMember(GenericValue(StringRef(name))); }
767  #endif
768      template &lt;typename SourceAllocator&gt;
769      bool EraseMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
770          MemberIterator m = FindMember(name);
771          if (m != MemberEnd()) {
772              EraseMember(m);
773              return true;
774          }
775          else
776              return false;
777      }
778      Object GetObject() { RAPIDJSON_ASSERT(IsObject()); return Object(*this); }
779      Object GetObj() { RAPIDJSON_ASSERT(IsObject()); return Object(*this); }
780      ConstObject GetObject() const { RAPIDJSON_ASSERT(IsObject()); return ConstObject(*this); }
781      ConstObject GetObj() const { RAPIDJSON_ASSERT(IsObject()); return ConstObject(*this); }
782      GenericValue&amp; SetArray() { this-&gt;~GenericValue(); new (this) GenericValue(kArrayType); return *this; }
783      SizeType Size() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.size; }
784      SizeType Capacity() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.capacity; }
785      bool Empty() const { RAPIDJSON_ASSERT(IsArray()); return data_.a.size == 0; }
786      void Clear() {
787          RAPIDJSON_ASSERT(IsArray());
788          GenericValue* e = GetElementsPointer();
789          for (GenericValue* v = e; v != e + data_.a.size; ++v)
790              v-&gt;~GenericValue();
791          data_.a.size = 0;
792      }
793      GenericValue&amp; operator[](SizeType index) {
794          RAPIDJSON_ASSERT(IsArray());
795          RAPIDJSON_ASSERT(index &lt; data_.a.size);
796          return GetElementsPointer()[index];
797      }
798      const GenericValue&amp; operator[](SizeType index) const { return const_cast&lt;GenericValue&amp;&gt;(*this)[index]; }
799      ValueIterator Begin() { RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer(); }
800      ValueIterator End() { RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer() + data_.a.size; }
801      ConstValueIterator Begin() const { return const_cast&lt;GenericValue&amp;&gt;(*this).Begin(); }
802      ConstValueIterator End() const { return const_cast&lt;GenericValue&amp;&gt;(*this).End(); }
803      GenericValue&amp; Reserve(SizeType newCapacity, Allocator &amp;allocator) {
804          RAPIDJSON_ASSERT(IsArray());
805          if (newCapacity &gt; data_.a.capacity) {
806              SetElementsPointer(reinterpret_cast&lt;GenericValue*&gt;(allocator.Realloc(GetElementsPointer(), data_.a.capacity * sizeof(GenericValue), newCapacity * sizeof(GenericValue))));
807              data_.a.capacity = newCapacity;
808          }
809          return *this;
810      }
811      GenericValue&amp; PushBack(GenericValue&amp; value, Allocator&amp; allocator) {
812          RAPIDJSON_ASSERT(IsArray());
813          if (data_.a.size &gt;= data_.a.capacity)
814              Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : (data_.a.capacity + (data_.a.capacity + 1) / 2), allocator);
815          GetElementsPointer()[data_.a.size++].RawAssign(value);
816          return *this;
817      }
818  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
819      GenericValue&amp; PushBack(GenericValue&amp;&amp; value, Allocator&amp; allocator) {
820          return PushBack(value, allocator);
821      }
822  #endif 
823      GenericValue&amp; PushBack(StringRefType value, Allocator&amp; allocator) {
824          return (*this).template PushBack&lt;StringRefType&gt;(value, allocator);
825      }
826      template &lt;typename T&gt;
827      RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (GenericValue&amp;))
828      PushBack(T value, Allocator&amp; allocator) {
829          GenericValue v(value);
830          return PushBack(v, allocator);
831      }
832      GenericValue&amp; PopBack() {
833          RAPIDJSON_ASSERT(IsArray());
834          RAPIDJSON_ASSERT(!Empty());
835          GetElementsPointer()[--data_.a.size].~GenericValue();
836          return *this;
837      }
838      ValueIterator Erase(ConstValueIterator pos) {
839          return Erase(pos, pos + 1);
840      }
841      ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) {
842          RAPIDJSON_ASSERT(IsArray());
843          RAPIDJSON_ASSERT(data_.a.size &gt; 0);
844          RAPIDJSON_ASSERT(GetElementsPointer() != 0);
845          RAPIDJSON_ASSERT(first &gt;= Begin());
846          RAPIDJSON_ASSERT(first &lt;= last);
847          RAPIDJSON_ASSERT(last &lt;= End());
848          ValueIterator pos = Begin() + (first - Begin());
849          for (ValueIterator itr = pos; itr != last; ++itr)
850              itr-&gt;~GenericValue();
851          std::memmove(static_cast&lt;void*&gt;(pos), last, static_cast&lt;size_t&gt;(End() - last) * sizeof(GenericValue));
852          data_.a.size -= static_cast&lt;SizeType&gt;(last - first);
853          return pos;
854      }
855      Array GetArray() { RAPIDJSON_ASSERT(IsArray()); return Array(*this); }
856      ConstArray GetArray() const { RAPIDJSON_ASSERT(IsArray()); return ConstArray(*this); }
857      int GetInt() const          { RAPIDJSON_ASSERT(data_.f.flags &amp; kIntFlag);   return data_.n.i.i;   }
858      unsigned GetUint() const    { RAPIDJSON_ASSERT(data_.f.flags &amp; kUintFlag);  return data_.n.u.u;   }
859      int64_t GetInt64() const    { RAPIDJSON_ASSERT(data_.f.flags &amp; kInt64Flag); return data_.n.i64; }
860      uint64_t GetUint64() const  { RAPIDJSON_ASSERT(data_.f.flags &amp; kUint64Flag); return data_.n.u64; }
861      double GetDouble() const {
862          RAPIDJSON_ASSERT(IsNumber());
863          if ((data_.f.flags &amp; kDoubleFlag) != 0)                return data_.n.d;   
864          if ((data_.f.flags &amp; kIntFlag) != 0)                   return data_.n.i.i; 
865          if ((data_.f.flags &amp; kUintFlag) != 0)                  return data_.n.u.u; 
866          if ((data_.f.flags &amp; kInt64Flag) != 0)                 return static_cast&lt;double&gt;(data_.n.i64); 
867          RAPIDJSON_ASSERT((data_.f.flags &amp; kUint64Flag) != 0);  return static_cast&lt;double&gt;(data_.n.u64); 
868      }
869      float GetFloat() const {
870          return static_cast&lt;float&gt;(GetDouble());
871      }
872      GenericValue&amp; SetInt(int i)             { this-&gt;~GenericValue(); new (this) GenericValue(i);    return *this; }
873      GenericValue&amp; SetUint(unsigned u)       { this-&gt;~GenericValue(); new (this) GenericValue(u);    return *this; }
874      GenericValue&amp; SetInt64(int64_t i64)     { this-&gt;~GenericValue(); new (this) GenericValue(i64);  return *this; }
875      GenericValue&amp; SetUint64(uint64_t u64)   { this-&gt;~GenericValue(); new (this) GenericValue(u64);  return *this; }
876      GenericValue&amp; SetDouble(double d)       { this-&gt;~GenericValue(); new (this) GenericValue(d);    return *this; }
877      GenericValue&amp; SetFloat(float f)         { this-&gt;~GenericValue(); new (this) GenericValue(static_cast&lt;double&gt;(f)); return *this; }
878      const Ch* GetString() const { RAPIDJSON_ASSERT(IsString()); return DataString(data_); }
879      SizeType GetStringLength() const { RAPIDJSON_ASSERT(IsString()); return DataStringLength(data_); }
880      GenericValue&amp; SetString(const Ch* s, SizeType length) { return SetString(StringRef(s, length)); }
881      GenericValue&amp; SetString(StringRefType s) { this-&gt;~GenericValue(); SetStringRaw(s); return *this; }
882      GenericValue&amp; SetString(const Ch* s, SizeType length, Allocator&amp; allocator) { return SetString(StringRef(s, length), allocator); }
883      GenericValue&amp; SetString(const Ch* s, Allocator&amp; allocator) { return SetString(StringRef(s), allocator); }
884      GenericValue&amp; SetString(StringRefType s, Allocator&amp; allocator) { this-&gt;~GenericValue(); SetStringRaw(s, allocator); return *this; }
885  #if RAPIDJSON_HAS_STDSTRING
886      GenericValue&amp; SetString(const std::basic_string&lt;Ch&gt;&amp; s, Allocator&amp; allocator) { return SetString(StringRef(s), allocator); }
887  #endif
888      template &lt;typename T&gt;
889      bool Is() const { return internal::TypeHelper&lt;ValueType, T&gt;::Is(*this); }
890      template &lt;typename T&gt;
891      T Get() const { return internal::TypeHelper&lt;ValueType, T&gt;::Get(*this); }
892      template &lt;typename T&gt;
893      T Get() { return internal::TypeHelper&lt;ValueType, T&gt;::Get(*this); }
894      template&lt;typename T&gt;
895      ValueType&amp; Set(const T&amp; data) { return internal::TypeHelper&lt;ValueType, T&gt;::Set(*this, data); }
896      template&lt;typename T&gt;
897      ValueType&amp; Set(const T&amp; data, AllocatorType&amp; allocator) { return internal::TypeHelper&lt;ValueType, T&gt;::Set(*this, data, allocator); }
898      template &lt;typename Handler&gt;
899      bool Accept(Handler&amp; handler) const {
900          switch(GetType()) {
901          case kNullType:     return handler.Null();
902          case kFalseType:    return handler.Bool(false);
903          case kTrueType:     return handler.Bool(true);
904          case kObjectType:
905              if (RAPIDJSON_UNLIKELY(!handler.StartObject()))
906                  return false;
907              for (ConstMemberIterator m = MemberBegin(); m != MemberEnd(); ++m) {
908                  RAPIDJSON_ASSERT(m-&gt;name.IsString()); 
909                  if (RAPIDJSON_UNLIKELY(!handler.Key(m-&gt;name.GetString(), m-&gt;name.GetStringLength(), (m-&gt;name.data_.f.flags &amp; kCopyFlag) != 0)))
910                      return false;
911                  if (RAPIDJSON_UNLIKELY(!m-&gt;value.Accept(handler)))
912                      return false;
913              }
914              return handler.EndObject(data_.o.size);
915          case kArrayType:
916              if (RAPIDJSON_UNLIKELY(!handler.StartArray()))
917                  return false;
918              for (ConstValueIterator v = Begin(); v != End(); ++v)
919                  if (RAPIDJSON_UNLIKELY(!v-&gt;Accept(handler)))
920                      return false;
921              return handler.EndArray(data_.a.size);
922          case kStringType:
923              return handler.String(GetString(), GetStringLength(), (data_.f.flags &amp; kCopyFlag) != 0);
924          default:
925              RAPIDJSON_ASSERT(GetType() == kNumberType);
926              if (IsDouble())         return handler.Double(data_.n.d);
927              else if (IsInt())       return handler.Int(data_.n.i.i);
928              else if (IsUint())      return handler.Uint(data_.n.u.u);
929              else if (IsInt64())     return handler.Int64(data_.n.i64);
930              else                    return handler.Uint64(data_.n.u64);
931          }
932      }
933  private:
934      template &lt;typename, typename&gt; friend class GenericValue;
935      template &lt;typename, typename, typename&gt; friend class GenericDocument;
936      enum {
937          kBoolFlag       = 0x0008,
938          kNumberFlag     = 0x0010,
939          kIntFlag        = 0x0020,
940          kUintFlag       = 0x0040,
941          kInt64Flag      = 0x0080,
942          kUint64Flag     = 0x0100,
943          kDoubleFlag     = 0x0200,
944          kStringFlag     = 0x0400,
945          kCopyFlag       = 0x0800,
946          kInlineStrFlag  = 0x1000,
947          kNullFlag = kNullType,
948          kTrueFlag = static_cast&lt;int&gt;(kTrueType) | static_cast&lt;int&gt;(kBoolFlag),
949          kFalseFlag = static_cast&lt;int&gt;(kFalseType) | static_cast&lt;int&gt;(kBoolFlag),
950          kNumberIntFlag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kIntFlag | kInt64Flag),
951          kNumberUintFlag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag),
952          kNumberInt64Flag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kInt64Flag),
953          kNumberUint64Flag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kUint64Flag),
954          kNumberDoubleFlag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kDoubleFlag),
955          kNumberAnyFlag = static_cast&lt;int&gt;(kNumberType) | static_cast&lt;int&gt;(kNumberFlag | kIntFlag | kInt64Flag | kUintFlag | kUint64Flag | kDoubleFlag),
956          kConstStringFlag = static_cast&lt;int&gt;(kStringType) | static_cast&lt;int&gt;(kStringFlag),
957          kCopyStringFlag = static_cast&lt;int&gt;(kStringType) | static_cast&lt;int&gt;(kStringFlag | kCopyFlag),
958          kShortStringFlag = static_cast&lt;int&gt;(kStringType) | static_cast&lt;int&gt;(kStringFlag | kCopyFlag | kInlineStrFlag),
959          kObjectFlag = kObjectType,
960          kArrayFlag = kArrayType,
961          kTypeMask = 0x07
962      };
963      static const SizeType kDefaultArrayCapacity = RAPIDJSON_VALUE_DEFAULT_ARRAY_CAPACITY;
964      static const SizeType kDefaultObjectCapacity = RAPIDJSON_VALUE_DEFAULT_OBJECT_CAPACITY;
965      struct Flag {
966  #if RAPIDJSON_48BITPOINTER_OPTIMIZATION
967          char payload[sizeof(SizeType) * 2 + 6];     
968  #elif RAPIDJSON_64BIT
969          char payload[sizeof(SizeType) * 2 + sizeof(void*) + 6]; 
970  #else
971          char payload[sizeof(SizeType) * 2 + sizeof(void*) + 2]; 
972  #endif
973          uint16_t flags;
974      };
975      struct String {
976          SizeType length;
977          SizeType hashcode;  
978          const Ch* str;
979      };  
980      struct ShortString {
981          enum { MaxChars = sizeof(static_cast&lt;Flag*&gt;(0)-&gt;payload) / sizeof(Ch), MaxSize = MaxChars - 1, LenPos = MaxSize };
982          Ch str[MaxChars];
983          inline static bool Usable(SizeType len) { return                       (MaxSize &gt;= len); }
984          inline void     SetLength(SizeType len) { str[LenPos] = static_cast&lt;Ch&gt;(MaxSize -  len); }
985          inline SizeType GetLength() const       { return  static_cast&lt;SizeType&gt;(MaxSize -  str[LenPos]); }
986      };  
987      union Number {
988  #if RAPIDJSON_ENDIAN == RAPIDJSON_LITTLEENDIAN
989          struct I {
990              int i;
991              char padding[4];
992          }i;
993          struct U {
994              unsigned u;
995              char padding2[4];
996          }u;
997  #else
998          struct I {
999              char padding[4];
1000              int i;
1001          }i;
1002          struct U {
1003              char padding2[4];
1004              unsigned u;
1005          }u;
1006  #endif
1007          int64_t i64;
1008          uint64_t u64;
1009          double d;
1010      };  
1011      struct ObjectData {
1012          SizeType size;
1013          SizeType capacity;
1014          Member* members;
1015      };  
1016      struct ArrayData {
1017          SizeType size;
1018          SizeType capacity;
1019          GenericValue* elements;
1020      };  
1021      union Data {
1022          String s;
1023          ShortString ss;
1024          Number n;
1025          ObjectData o;
1026          ArrayData a;
1027          Flag f;
1028      };  
1029      static RAPIDJSON_FORCEINLINE const Ch* DataString(const Data&amp; data) {
1030          return (data.f.flags &amp; kInlineStrFlag) ? data.ss.str : RAPIDJSON_GETPOINTER(Ch, data.s.str);
1031      }
1032      static RAPIDJSON_FORCEINLINE SizeType DataStringLength(const Data&amp; data) {
1033          return (data.f.flags &amp; kInlineStrFlag) ? data.ss.GetLength() : data.s.length;
1034      }
1035      RAPIDJSON_FORCEINLINE const Ch* GetStringPointer() const { return RAPIDJSON_GETPOINTER(Ch, data_.s.str); }
1036      RAPIDJSON_FORCEINLINE const Ch* SetStringPointer(const Ch* str) { return RAPIDJSON_SETPOINTER(Ch, data_.s.str, str); }
1037      RAPIDJSON_FORCEINLINE GenericValue* GetElementsPointer() const { return RAPIDJSON_GETPOINTER(GenericValue, data_.a.elements); }
1038      RAPIDJSON_FORCEINLINE GenericValue* SetElementsPointer(GenericValue* elements) { return RAPIDJSON_SETPOINTER(GenericValue, data_.a.elements, elements); }
1039      RAPIDJSON_FORCEINLINE Member* GetMembersPointer() const { return RAPIDJSON_GETPOINTER(Member, data_.o.members); }
<span onclick='openModal()' class='match'>1040      RAPIDJSON_FORCEINLINE Member* SetMembersPointer(Member* members) { return RAPIDJSON_SETPOINTER(Member, data_.o.members, members); }
1041  #if RAPIDJSON_USE_MEMBERSMAP
</span>1042      struct MapTraits {
1043          struct Less {
1044              bool operator()(const Data&amp; s1, const Data&amp; s2) const {
1045                  SizeType n1 = DataStringLength(s1), n2 = DataStringLength(s2);
1046                  int cmp = std::memcmp(DataString(s1), DataString(s2), sizeof(Ch) * (n1 &lt; n2 ? n1 : n2));
1047                  return cmp &lt; 0 || (cmp == 0 &amp;&amp; n1 &lt; n2);
1048              }
1049          };
1050          typedef std::pair&lt;const Data, SizeType&gt; Pair;
1051          typedef std::multimap&lt;Data, SizeType, Less, StdAllocator&lt;Pair, Allocator&gt; &gt; Map;
1052          typedef typename Map::iterator Iterator;
1053      };
1054      typedef typename MapTraits::Map         Map;
1055      typedef typename MapTraits::Less        MapLess;
1056      typedef typename MapTraits::Pair        MapPair;
1057      typedef typename MapTraits::Iterator    MapIterator;
1058      static RAPIDJSON_FORCEINLINE size_t GetMapLayoutSize(SizeType capacity) {
1059          return RAPIDJSON_ALIGN(sizeof(Map*)) +
1060                 RAPIDJSON_ALIGN(sizeof(SizeType)) +
1061                 RAPIDJSON_ALIGN(capacity * sizeof(Member)) +
1062                 capacity * sizeof(MapIterator);
1063      }
1064      static RAPIDJSON_FORCEINLINE SizeType &amp;GetMapCapacity(Map* &amp;map) {
1065          return *reinterpret_cast&lt;SizeType*&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;map) +
1066                                              RAPIDJSON_ALIGN(sizeof(Map*)));
1067      }
1068      static RAPIDJSON_FORCEINLINE Member* GetMapMembers(Map* &amp;map) {
1069          return reinterpret_cast&lt;Member*&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;map) +
1070                                           RAPIDJSON_ALIGN(sizeof(Map*)) +
1071                                           RAPIDJSON_ALIGN(sizeof(SizeType)));
1072      }
1073      static RAPIDJSON_FORCEINLINE MapIterator* GetMapIterators(Map* &amp;map) {
1074          return reinterpret_cast&lt;MapIterator*&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;map) +
1075                                                RAPIDJSON_ALIGN(sizeof(Map*)) +
1076                                                RAPIDJSON_ALIGN(sizeof(SizeType)) +
1077                                                RAPIDJSON_ALIGN(GetMapCapacity(map) * sizeof(Member)));
1078      }
1079      static RAPIDJSON_FORCEINLINE Map* &amp;GetMap(Member* members) {
1080          RAPIDJSON_ASSERT(members != 0);
1081          return *reinterpret_cast&lt;Map**&gt;(reinterpret_cast&lt;uintptr_t&gt;(members) -
1082                                          RAPIDJSON_ALIGN(sizeof(SizeType)) -
1083                                          RAPIDJSON_ALIGN(sizeof(Map*)));
1084      }
1085      RAPIDJSON_FORCEINLINE MapIterator DropMapIterator(MapIterator&amp; rhs) {
1086  #if RAPIDJSON_HAS_CXX11
1087          MapIterator ret = std::move(rhs);
1088  #else
1089          MapIterator ret = rhs;
1090  #endif
1091          rhs.~MapIterator();
1092          return ret;
1093      }
1094      Map* &amp;DoReallocMap(Map** oldMap, SizeType newCapacity, Allocator&amp; allocator) {
1095          Map **newMap = static_cast&lt;Map**&gt;(allocator.Malloc(GetMapLayoutSize(newCapacity)));
1096          GetMapCapacity(*newMap) = newCapacity;
1097          if (!oldMap) {
1098              *newMap = new (allocator.Malloc(sizeof(Map))) Map(MapLess(), allocator);
1099          }
1100          else {
1101              *newMap = *oldMap;
1102              size_t count = (*oldMap)-&gt;size();
1103              std::memcpy(static_cast&lt;void*&gt;(GetMapMembers(*newMap)),
1104                          static_cast&lt;void*&gt;(GetMapMembers(*oldMap)),
1105                          count * sizeof(Member));
1106              MapIterator *oldIt = GetMapIterators(*oldMap),
1107                          *newIt = GetMapIterators(*newMap);
1108              while (count--) {
1109                  new (&amp;newIt[count]) MapIterator(DropMapIterator(oldIt[count]));
1110              }
1111              Allocator::Free(oldMap);
1112          }
1113          return *newMap;
1114      }
1115      RAPIDJSON_FORCEINLINE Member* DoAllocMembers(SizeType capacity, Allocator&amp; allocator) {
1116          return GetMapMembers(DoReallocMap(0, capacity, allocator));
1117      }
1118      void DoReserveMembers(SizeType newCapacity, Allocator&amp; allocator) {
1119          ObjectData&amp; o = data_.o;
1120          if (newCapacity &gt; o.capacity) {
1121              Member* oldMembers = GetMembersPointer();
1122              Map **oldMap = oldMembers ? &amp;GetMap(oldMembers) : 0,
1123                  *&amp;newMap = DoReallocMap(oldMap, newCapacity, allocator);
1124              RAPIDJSON_SETPOINTER(Member, o.members, GetMapMembers(newMap));
1125              o.capacity = newCapacity;
1126          }
1127      }
1128      template &lt;typename SourceAllocator&gt;
1129      MemberIterator DoFindMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
1130          if (Member* members = GetMembersPointer()) {
1131              Map* &amp;map = GetMap(members);
1132              MapIterator mit = map-&gt;find(reinterpret_cast&lt;const Data&amp;&gt;(name.data_));
1133              if (mit != map-&gt;end()) {
1134                  return MemberIterator(&amp;members[mit-&gt;second]);
1135              }
1136          }
1137          return MemberEnd();
1138      }
1139      void DoClearMembers() {
1140          if (Member* members = GetMembersPointer()) {
1141              Map* &amp;map = GetMap(members);
1142              MapIterator* mit = GetMapIterators(map);
1143              for (SizeType i = 0; i &lt; data_.o.size; i++) {
1144                  map-&gt;erase(DropMapIterator(mit[i]));
1145                  members[i].~Member();
1146              }
1147              data_.o.size = 0;
1148          }
1149      }
1150      void DoFreeMembers() {
1151          if (Member* members = GetMembersPointer()) {
1152              GetMap(members)-&gt;~Map();
1153              for (SizeType i = 0; i &lt; data_.o.size; i++) {
1154                  members[i].~Member();
1155              }
1156              if (Allocator::kNeedFree) { 
1157                  Map** map = &amp;GetMap(members);
1158                  Allocator::Free(*map);
1159                  Allocator::Free(map);
1160              }
1161          }
1162      }
1163  #else 
1164      RAPIDJSON_FORCEINLINE Member* DoAllocMembers(SizeType capacity, Allocator&amp; allocator) {
1165          return Malloc&lt;Member&gt;(allocator, capacity);
1166      }
1167      void DoReserveMembers(SizeType newCapacity, Allocator&amp; allocator) {
1168          ObjectData&amp; o = data_.o;
1169          if (newCapacity &gt; o.capacity) {
1170              Member* newMembers = Realloc&lt;Member&gt;(allocator, GetMembersPointer(), o.capacity, newCapacity);
1171              RAPIDJSON_SETPOINTER(Member, o.members, newMembers);
1172              o.capacity = newCapacity;
1173          }
1174      }
1175      template &lt;typename SourceAllocator&gt;
1176      MemberIterator DoFindMember(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; name) {
1177          MemberIterator member = MemberBegin();
1178          for ( ; member != MemberEnd(); ++member)
1179              if (name.StringEqual(member-&gt;name))
1180                  break;
1181          return member;
1182      }
1183      void DoClearMembers() {
1184          for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
1185              m-&gt;~Member();
1186          data_.o.size = 0;
1187      }
1188      void DoFreeMembers() {
1189          for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)
1190              m-&gt;~Member();
1191          Allocator::Free(GetMembersPointer());
1192      }
1193  #endif 
1194      void DoAddMember(GenericValue&amp; name, GenericValue&amp; value, Allocator&amp; allocator) {
1195          ObjectData&amp; o = data_.o;
1196          if (o.size &gt;= o.capacity)
1197              DoReserveMembers(o.capacity ? (o.capacity + (o.capacity + 1) / 2) : kDefaultObjectCapacity, allocator);
1198          Member* members = GetMembersPointer();
1199          Member* m = members + o.size;
1200          m-&gt;name.RawAssign(name);
1201          m-&gt;value.RawAssign(value);
1202  #if RAPIDJSON_USE_MEMBERSMAP
1203          Map* &amp;map = GetMap(members);
1204          MapIterator* mit = GetMapIterators(map);
1205          new (&amp;mit[o.size]) MapIterator(map-&gt;insert(MapPair(m-&gt;name.data_, o.size)));
1206  #endif
1207          ++o.size;
1208      }
1209      MemberIterator DoRemoveMember(MemberIterator m) {
1210          ObjectData&amp; o = data_.o;
1211          Member* members = GetMembersPointer();
1212  #if RAPIDJSON_USE_MEMBERSMAP
1213          Map* &amp;map = GetMap(members);
1214          MapIterator* mit = GetMapIterators(map);
1215          SizeType mpos = static_cast&lt;SizeType&gt;(&amp;*m - members);
1216          map-&gt;erase(DropMapIterator(mit[mpos]));
1217  #endif
1218          MemberIterator last(members + (o.size - 1));
1219          if (o.size &gt; 1 &amp;&amp; m != last) {
1220  #if RAPIDJSON_USE_MEMBERSMAP
1221              new (&amp;mit[mpos]) MapIterator(DropMapIterator(mit[&amp;*last - members]));
1222              mit[mpos]-&gt;second = mpos;
1223  #endif
1224              *m = *last; 
1225          }
1226          else {
1227              m-&gt;~Member(); 
1228          }
1229          --o.size;
1230          return m;
1231      }
1232      MemberIterator DoEraseMembers(ConstMemberIterator first, ConstMemberIterator last) {
1233          ObjectData&amp; o = data_.o;
1234          MemberIterator beg = MemberBegin(),
1235                         pos = beg + (first - beg),
1236                         end = MemberEnd();
1237  #if RAPIDJSON_USE_MEMBERSMAP
1238          Map* &amp;map = GetMap(GetMembersPointer());
1239          MapIterator* mit = GetMapIterators(map);
1240  #endif
1241          for (MemberIterator itr = pos; itr != last; ++itr) {
1242  #if RAPIDJSON_USE_MEMBERSMAP
1243              map-&gt;erase(DropMapIterator(mit[itr - beg]));
1244  #endif
1245              itr-&gt;~Member();
1246          }
1247  #if RAPIDJSON_USE_MEMBERSMAP
1248          if (first != last) {
1249              MemberIterator next = pos + (last - first);
1250              for (MemberIterator itr = pos; next != end; ++itr, ++next) {
1251                  std::memcpy(static_cast&lt;void*&gt;(&amp;*itr), &amp;*next, sizeof(Member));
1252                  SizeType mpos = static_cast&lt;SizeType&gt;(itr - beg);
1253                  new (&amp;mit[mpos]) MapIterator(DropMapIterator(mit[next - beg]));
1254                  mit[mpos]-&gt;second = mpos;
1255              }
1256          }
1257  #else
1258          std::memmove(static_cast&lt;void*&gt;(&amp;*pos), &amp;*last,
1259                       static_cast&lt;size_t&gt;(end - last) * sizeof(Member));
1260  #endif
1261          o.size -= static_cast&lt;SizeType&gt;(last - first);
1262          return pos;
1263      }
1264      template &lt;typename SourceAllocator&gt;
1265      void DoCopyMembers(const GenericValue&lt;Encoding,SourceAllocator&gt;&amp; rhs, Allocator&amp; allocator, bool copyConstStrings) {
1266          RAPIDJSON_ASSERT(rhs.GetType() == kObjectType);
1267          data_.f.flags = kObjectFlag;
1268          SizeType count = rhs.data_.o.size;
1269          Member* lm = DoAllocMembers(count, allocator);
1270          const typename GenericValue&lt;Encoding,SourceAllocator&gt;::Member* rm = rhs.GetMembersPointer();
1271  #if RAPIDJSON_USE_MEMBERSMAP
1272          Map* &amp;map = GetMap(lm);
1273          MapIterator* mit = GetMapIterators(map);
1274  #endif
1275          for (SizeType i = 0; i &lt; count; i++) {
1276              new (&amp;lm[i].name) GenericValue(rm[i].name, allocator, copyConstStrings);
1277              new (&amp;lm[i].value) GenericValue(rm[i].value, allocator, copyConstStrings);
1278  #if RAPIDJSON_USE_MEMBERSMAP
1279              new (&amp;mit[i]) MapIterator(map-&gt;insert(MapPair(lm[i].name.data_, i)));
1280  #endif
1281          }
1282          data_.o.size = data_.o.capacity = count;
1283          SetMembersPointer(lm);
1284      }
1285      void SetArrayRaw(GenericValue* values, SizeType count, Allocator&amp; allocator) {
1286          data_.f.flags = kArrayFlag;
1287          if (count) {
1288              GenericValue* e = static_cast&lt;GenericValue*&gt;(allocator.Malloc(count * sizeof(GenericValue)));
1289              SetElementsPointer(e);
1290              std::memcpy(static_cast&lt;void*&gt;(e), values, count * sizeof(GenericValue));
1291          }
1292          else
1293              SetElementsPointer(0);
1294          data_.a.size = data_.a.capacity = count;
1295      }
1296      void SetObjectRaw(Member* members, SizeType count, Allocator&amp; allocator) {
1297          data_.f.flags = kObjectFlag;
1298          if (count) {
1299              Member* m = DoAllocMembers(count, allocator);
1300              SetMembersPointer(m);
1301              std::memcpy(static_cast&lt;void*&gt;(m), members, count * sizeof(Member));
1302  #if RAPIDJSON_USE_MEMBERSMAP
1303              Map* &amp;map = GetMap(m);
1304              MapIterator* mit = GetMapIterators(map);
1305              for (SizeType i = 0; i &lt; count; i++) {
1306                  new (&amp;mit[i]) MapIterator(map-&gt;insert(MapPair(m[i].name.data_, i)));
1307              }
1308  #endif
1309          }
1310          else
1311              SetMembersPointer(0);
1312          data_.o.size = data_.o.capacity = count;
1313      }
1314      void SetStringRaw(StringRefType s) RAPIDJSON_NOEXCEPT {
1315          data_.f.flags = kConstStringFlag;
1316          SetStringPointer(s);
1317          data_.s.length = s.length;
1318      }
1319      void SetStringRaw(StringRefType s, Allocator&amp; allocator) {
1320          Ch* str = 0;
1321          if (ShortString::Usable(s.length)) {
1322              data_.f.flags = kShortStringFlag;
1323              data_.ss.SetLength(s.length);
1324              str = data_.ss.str;
1325          } else {
1326              data_.f.flags = kCopyStringFlag;
1327              data_.s.length = s.length;
1328              str = static_cast&lt;Ch *&gt;(allocator.Malloc((s.length + 1) * sizeof(Ch)));
1329              SetStringPointer(str);
1330          }
1331          std::memcpy(str, s, s.length * sizeof(Ch));
1332          str[s.length] = &#x27;\0&#x27;;
1333      }
1334      void RawAssign(GenericValue&amp; rhs) RAPIDJSON_NOEXCEPT {
1335          data_ = rhs.data_;
1336          rhs.data_.f.flags = kNullFlag;
1337      }
1338      template &lt;typename SourceAllocator&gt;
1339      bool StringEqual(const GenericValue&lt;Encoding, SourceAllocator&gt;&amp; rhs) const {
1340          RAPIDJSON_ASSERT(IsString());
1341          RAPIDJSON_ASSERT(rhs.IsString());
1342          const SizeType len1 = GetStringLength();
1343          const SizeType len2 = rhs.GetStringLength();
1344          if(len1 != len2) { return false; }
1345          const Ch* const str1 = GetString();
1346          const Ch* const str2 = rhs.GetString();
1347          if(str1 == str2) { return true; } 
1348          return (std::memcmp(str1, str2, sizeof(Ch) * len1) == 0);
1349      }
1350      Data data_;
1351  };
1352  typedef GenericValue&lt;UTF8&lt;&gt; &gt; Value;
1353  template &lt;typename Encoding, typename Allocator = RAPIDJSON_DEFAULT_ALLOCATOR, typename StackAllocator = RAPIDJSON_DEFAULT_STACK_ALLOCATOR &gt;
1354  class GenericDocument : public GenericValue&lt;Encoding, Allocator&gt; {
1355  public:
1356      typedef typename Encoding::Ch Ch;                       
1357      typedef GenericValue&lt;Encoding, Allocator&gt; ValueType;    
1358      typedef Allocator AllocatorType;                        
1359      explicit GenericDocument(Type type, Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
1360          GenericValue&lt;Encoding, Allocator&gt;(type),  allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
1361      {
1362          if (!allocator_)
1363              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
1364      }
1365      GenericDocument(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :
1366          allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()
1367      {
1368          if (!allocator_)
1369              ownAllocator_ = allocator_ = RAPIDJSON_NEW(Allocator)();
1370      }
1371  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1372      GenericDocument(GenericDocument&amp;&amp; rhs) RAPIDJSON_NOEXCEPT
1373          : ValueType(std::forward&lt;ValueType&gt;(rhs)), 
1374            allocator_(rhs.allocator_),
1375            ownAllocator_(rhs.ownAllocator_),
1376            stack_(std::move(rhs.stack_)),
1377            parseResult_(rhs.parseResult_)
1378      {
1379          rhs.allocator_ = 0;
1380          rhs.ownAllocator_ = 0;
1381          rhs.parseResult_ = ParseResult();
1382      }
1383  #endif
1384      ~GenericDocument() {
1385          if (ownAllocator_) {
1386              ValueType::SetNull();
1387          }
1388          Destroy();
1389      }
1390  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1391      GenericDocument&amp; operator=(GenericDocument&amp;&amp; rhs) RAPIDJSON_NOEXCEPT
1392      {
1393          ValueType::operator=(std::forward&lt;ValueType&gt;(rhs));
1394          Destroy();
1395          allocator_ = rhs.allocator_;
1396          ownAllocator_ = rhs.ownAllocator_;
1397          stack_ = std::move(rhs.stack_);
1398          parseResult_ = rhs.parseResult_;
1399          rhs.allocator_ = 0;
1400          rhs.ownAllocator_ = 0;
1401          rhs.parseResult_ = ParseResult();
1402          return *this;
1403      }
1404  #endif
1405      GenericDocument&amp; Swap(GenericDocument&amp; rhs) RAPIDJSON_NOEXCEPT {
1406          ValueType::Swap(rhs);
1407          stack_.Swap(rhs.stack_);
1408          internal::Swap(allocator_, rhs.allocator_);
1409          internal::Swap(ownAllocator_, rhs.ownAllocator_);
1410          internal::Swap(parseResult_, rhs.parseResult_);
1411          return *this;
1412      }
1413      using ValueType::Swap;
1414      friend inline void swap(GenericDocument&amp; a, GenericDocument&amp; b) RAPIDJSON_NOEXCEPT { a.Swap(b); }
1415      template &lt;typename Generator&gt;
1416      GenericDocument&amp; Populate(Generator&amp; g) {
1417          ClearStackOnExit scope(*this);
1418          if (g(*this)) {
1419              RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); 
1420              ValueType::operator=(*stack_.template Pop&lt;ValueType&gt;(1));
1421          }
1422          return *this;
1423      }
1424      template &lt;unsigned parseFlags, typename SourceEncoding, typename InputStream&gt;
1425      GenericDocument&amp; ParseStream(InputStream&amp; is) {
1426          GenericReader&lt;SourceEncoding, Encoding, StackAllocator&gt; reader(
1427              stack_.HasAllocator() ? &amp;stack_.GetAllocator() : 0);
1428          ClearStackOnExit scope(*this);
1429          parseResult_ = reader.template Parse&lt;parseFlags&gt;(is, *this);
1430          if (parseResult_) {
1431              RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); 
1432              ValueType::operator=(*stack_.template Pop&lt;ValueType&gt;(1));
1433          }
1434          return *this;
1435      }
1436      template &lt;unsigned parseFlags, typename InputStream&gt;
1437      GenericDocument&amp; ParseStream(InputStream&amp; is) {
1438          return ParseStream&lt;parseFlags, Encoding, InputStream&gt;(is);
1439      }
1440      template &lt;typename InputStream&gt;
1441      GenericDocument&amp; ParseStream(InputStream&amp; is) {
1442          return ParseStream&lt;kParseDefaultFlags, Encoding, InputStream&gt;(is);
1443      }
1444      template &lt;unsigned parseFlags&gt;
1445      GenericDocument&amp; ParseInsitu(Ch* str) {
1446          GenericInsituStringStream&lt;Encoding&gt; s(str);
1447          return ParseStream&lt;parseFlags | kParseInsituFlag&gt;(s);
1448      }
1449      GenericDocument&amp; ParseInsitu(Ch* str) {
1450          return ParseInsitu&lt;kParseDefaultFlags&gt;(str);
1451      }
1452      template &lt;unsigned parseFlags, typename SourceEncoding&gt;
1453      GenericDocument&amp; Parse(const typename SourceEncoding::Ch* str) {
1454          RAPIDJSON_ASSERT(!(parseFlags &amp; kParseInsituFlag));
1455          GenericStringStream&lt;SourceEncoding&gt; s(str);
1456          return ParseStream&lt;parseFlags, SourceEncoding&gt;(s);
1457      }
1458      template &lt;unsigned parseFlags&gt;
1459      GenericDocument&amp; Parse(const Ch* str) {
1460          return Parse&lt;parseFlags, Encoding&gt;(str);
1461      }
1462      GenericDocument&amp; Parse(const Ch* str) {
1463          return Parse&lt;kParseDefaultFlags&gt;(str);
1464      }
1465      template &lt;unsigned parseFlags, typename SourceEncoding&gt;
1466      GenericDocument&amp; Parse(const typename SourceEncoding::Ch* str, size_t length) {
1467          RAPIDJSON_ASSERT(!(parseFlags &amp; kParseInsituFlag));
1468          MemoryStream ms(reinterpret_cast&lt;const char*&gt;(str), length * sizeof(typename SourceEncoding::Ch));
1469          EncodedInputStream&lt;SourceEncoding, MemoryStream&gt; is(ms);
1470          ParseStream&lt;parseFlags, SourceEncoding&gt;(is);
1471          return *this;
1472      }
1473      template &lt;unsigned parseFlags&gt;
1474      GenericDocument&amp; Parse(const Ch* str, size_t length) {
1475          return Parse&lt;parseFlags, Encoding&gt;(str, length);
1476      }
1477      GenericDocument&amp; Parse(const Ch* str, size_t length) {
1478          return Parse&lt;kParseDefaultFlags&gt;(str, length);
1479      }
1480  #if RAPIDJSON_HAS_STDSTRING
1481      template &lt;unsigned parseFlags, typename SourceEncoding&gt;
1482      GenericDocument&amp; Parse(const std::basic_string&lt;typename SourceEncoding::Ch&gt;&amp; str) {
1483          return Parse&lt;parseFlags, SourceEncoding&gt;(str.c_str());
1484      }
1485      template &lt;unsigned parseFlags&gt;
1486      GenericDocument&amp; Parse(const std::basic_string&lt;Ch&gt;&amp; str) {
1487          return Parse&lt;parseFlags, Encoding&gt;(str.c_str());
1488      }
1489      GenericDocument&amp; Parse(const std::basic_string&lt;Ch&gt;&amp; str) {
1490          return Parse&lt;kParseDefaultFlags&gt;(str);
1491      }
1492  #endif 
1493      bool HasParseError() const { return parseResult_.IsError(); }
1494      ParseErrorCode GetParseError() const { return parseResult_.Code(); }
1495      size_t GetErrorOffset() const { return parseResult_.Offset(); }
1496  #ifndef __clang 
1497  #endif
1498      operator ParseResult() const { return parseResult_; }
1499      Allocator&amp; GetAllocator() {
1500          RAPIDJSON_ASSERT(allocator_);
1501          return *allocator_;
1502      }
1503      size_t GetStackCapacity() const { return stack_.GetCapacity(); }
1504  private:
1505      struct ClearStackOnExit {
1506          explicit ClearStackOnExit(GenericDocument&amp; d) : d_(d) {}
1507          ~ClearStackOnExit() { d_.ClearStack(); }
1508      private:
1509          ClearStackOnExit(const ClearStackOnExit&amp;);
1510          ClearStackOnExit&amp; operator=(const ClearStackOnExit&amp;);
1511          GenericDocument&amp; d_;
1512      };
1513      template &lt;typename, typename&gt; friend class GenericValue; 
1514  public:
1515      bool Null() { new (stack_.template Push&lt;ValueType&gt;()) ValueType(); return true; }
1516      bool Bool(bool b) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(b); return true; }
1517      bool Int(int i) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(i); return true; }
1518      bool Uint(unsigned i) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(i); return true; }
1519      bool Int64(int64_t i) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(i); return true; }
1520      bool Uint64(uint64_t i) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(i); return true; }
1521      bool Double(double d) { new (stack_.template Push&lt;ValueType&gt;()) ValueType(d); return true; }
1522      bool RawNumber(const Ch* str, SizeType length, bool copy) {
1523          if (copy)
1524              new (stack_.template Push&lt;ValueType&gt;()) ValueType(str, length, GetAllocator());
1525          else
1526              new (stack_.template Push&lt;ValueType&gt;()) ValueType(str, length);
1527          return true;
1528      }
1529      bool String(const Ch* str, SizeType length, bool copy) {
1530          if (copy)
1531              new (stack_.template Push&lt;ValueType&gt;()) ValueType(str, length, GetAllocator());
1532          else
1533              new (stack_.template Push&lt;ValueType&gt;()) ValueType(str, length);
1534          return true;
1535      }
1536      bool StartObject() { new (stack_.template Push&lt;ValueType&gt;()) ValueType(kObjectType); return true; }
1537      bool Key(const Ch* str, SizeType length, bool copy) { return String(str, length, copy); }
1538      bool EndObject(SizeType memberCount) {
1539          typename ValueType::Member* members = stack_.template Pop&lt;typename ValueType::Member&gt;(memberCount);
1540          stack_.template Top&lt;ValueType&gt;()-&gt;SetObjectRaw(members, memberCount, GetAllocator());
1541          return true;
1542      }
1543      bool StartArray() { new (stack_.template Push&lt;ValueType&gt;()) ValueType(kArrayType); return true; }
1544      bool EndArray(SizeType elementCount) {
1545          ValueType* elements = stack_.template Pop&lt;ValueType&gt;(elementCount);
1546          stack_.template Top&lt;ValueType&gt;()-&gt;SetArrayRaw(elements, elementCount, GetAllocator());
1547          return true;
1548      }
1549  private:
1550      GenericDocument(const GenericDocument&amp;);
1551      GenericDocument&amp; operator=(const GenericDocument&amp;);
1552      void ClearStack() {
1553          if (Allocator::kNeedFree)
1554              while (stack_.GetSize() &gt; 0)    
1555                  (stack_.template Pop&lt;ValueType&gt;(1))-&gt;~ValueType();
1556          else
1557              stack_.Clear();
1558          stack_.ShrinkToFit();
1559      }
1560      void Destroy() {
1561          RAPIDJSON_DELETE(ownAllocator_);
1562      }
1563      static const size_t kDefaultStackCapacity = 1024;
1564      Allocator* allocator_;
1565      Allocator* ownAllocator_;
1566      internal::Stack&lt;StackAllocator&gt; stack_;
1567      ParseResult parseResult_;
1568  };
1569  typedef GenericDocument&lt;UTF8&lt;&gt; &gt; Document;
1570  template &lt;bool Const, typename ValueT&gt;
1571  class GenericArray {
1572  public:
1573      typedef GenericArray&lt;true, ValueT&gt; ConstArray;
1574      typedef GenericArray&lt;false, ValueT&gt; Array;
1575      typedef ValueT PlainType;
1576      typedef typename internal::MaybeAddConst&lt;Const,PlainType&gt;::Type ValueType;
1577      typedef ValueType* ValueIterator;  
1578      typedef const ValueT* ConstValueIterator;
1579      typedef typename ValueType::AllocatorType AllocatorType;
1580      typedef typename ValueType::StringRefType StringRefType;
1581      template &lt;typename, typename&gt;
1582      friend class GenericValue;
1583      GenericArray(const GenericArray&amp; rhs) : value_(rhs.value_) {}
1584      GenericArray&amp; operator=(const GenericArray&amp; rhs) { value_ = rhs.value_; return *this; }
1585      ~GenericArray() {}
1586      operator ValueType&amp;() const { return value_; }
1587      SizeType Size() const { return value_.Size(); }
1588      SizeType Capacity() const { return value_.Capacity(); }
1589      bool Empty() const { return value_.Empty(); }
1590      void Clear() const { value_.Clear(); }
1591      ValueType&amp; operator[](SizeType index) const {  return value_[index]; }
1592      ValueIterator Begin() const { return value_.Begin(); }
1593      ValueIterator End() const { return value_.End(); }
1594      GenericArray Reserve(SizeType newCapacity, AllocatorType &amp;allocator) const { value_.Reserve(newCapacity, allocator); return *this; }
1595      GenericArray PushBack(ValueType&amp; value, AllocatorType&amp; allocator) const { value_.PushBack(value, allocator); return *this; }
1596  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1597      GenericArray PushBack(ValueType&amp;&amp; value, AllocatorType&amp; allocator) const { value_.PushBack(value, allocator); return *this; }
1598  #endif 
1599      GenericArray PushBack(StringRefType value, AllocatorType&amp; allocator) const { value_.PushBack(value, allocator); return *this; }
1600      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (const GenericArray&amp;)) PushBack(T value, AllocatorType&amp; allocator) const { value_.PushBack(value, allocator); return *this; }
1601      GenericArray PopBack() const { value_.PopBack(); return *this; }
1602      ValueIterator Erase(ConstValueIterator pos) const { return value_.Erase(pos); }
1603      ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) const { return value_.Erase(first, last); }
1604  #if RAPIDJSON_HAS_CXX11_RANGE_FOR
1605      ValueIterator begin() const { return value_.Begin(); }
1606      ValueIterator end() const { return value_.End(); }
1607  #endif
1608  private:
1609      GenericArray();
1610      GenericArray(ValueType&amp; value) : value_(value) {}
1611      ValueType&amp; value_;
1612  };
1613  template &lt;bool Const, typename ValueT&gt;
1614  class GenericObject {
1615  public:
1616      typedef GenericObject&lt;true, ValueT&gt; ConstObject;
1617      typedef GenericObject&lt;false, ValueT&gt; Object;
1618      typedef ValueT PlainType;
1619      typedef typename internal::MaybeAddConst&lt;Const,PlainType&gt;::Type ValueType;
1620      typedef GenericMemberIterator&lt;Const, typename ValueT::EncodingType, typename ValueT::AllocatorType&gt; MemberIterator;  
1621      typedef GenericMemberIterator&lt;true, typename ValueT::EncodingType, typename ValueT::AllocatorType&gt; ConstMemberIterator;
1622      typedef typename ValueType::AllocatorType AllocatorType;
1623      typedef typename ValueType::StringRefType StringRefType;
1624      typedef typename ValueType::EncodingType EncodingType;
1625      typedef typename ValueType::Ch Ch;
1626      template &lt;typename, typename&gt;
1627      friend class GenericValue;
1628      GenericObject(const GenericObject&amp; rhs) : value_(rhs.value_) {}
1629      GenericObject&amp; operator=(const GenericObject&amp; rhs) { value_ = rhs.value_; return *this; }
1630      ~GenericObject() {}
1631      operator ValueType&amp;() const { return value_; }
1632      SizeType MemberCount() const { return value_.MemberCount(); }
1633      SizeType MemberCapacity() const { return value_.MemberCapacity(); }
1634      bool ObjectEmpty() const { return value_.ObjectEmpty(); }
1635      template &lt;typename T&gt; ValueType&amp; operator[](T* name) const { return value_[name]; }
1636      template &lt;typename SourceAllocator&gt; ValueType&amp; operator[](const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_[name]; }
1637  #if RAPIDJSON_HAS_STDSTRING
1638      ValueType&amp; operator[](const std::basic_string&lt;Ch&gt;&amp; name) const { return value_[name]; }
1639  #endif
1640      MemberIterator MemberBegin() const { return value_.MemberBegin(); }
1641      MemberIterator MemberEnd() const { return value_.MemberEnd(); }
1642      GenericObject MemberReserve(SizeType newCapacity, AllocatorType &amp;allocator) const { value_.MemberReserve(newCapacity, allocator); return *this; }
1643      bool HasMember(const Ch* name) const { return value_.HasMember(name); }
1644  #if RAPIDJSON_HAS_STDSTRING
1645      bool HasMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return value_.HasMember(name); }
1646  #endif
1647      template &lt;typename SourceAllocator&gt; bool HasMember(const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_.HasMember(name); }
1648      MemberIterator FindMember(const Ch* name) const { return value_.FindMember(name); }
1649      template &lt;typename SourceAllocator&gt; MemberIterator FindMember(const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_.FindMember(name); }
1650  #if RAPIDJSON_HAS_STDSTRING
1651      MemberIterator FindMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return value_.FindMember(name); }
1652  #endif
1653      GenericObject AddMember(ValueType&amp; name, ValueType&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1654      GenericObject AddMember(ValueType&amp; name, StringRefType value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1655  #if RAPIDJSON_HAS_STDSTRING
1656      GenericObject AddMember(ValueType&amp; name, std::basic_string&lt;Ch&gt;&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1657  #endif
1658      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (ValueType&amp;)) AddMember(ValueType&amp; name, T value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1659  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS
1660      GenericObject AddMember(ValueType&amp;&amp; name, ValueType&amp;&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1661      GenericObject AddMember(ValueType&amp;&amp; name, ValueType&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1662      GenericObject AddMember(ValueType&amp; name, ValueType&amp;&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1663      GenericObject AddMember(StringRefType name, ValueType&amp;&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1664  #endif 
1665      GenericObject AddMember(StringRefType name, ValueType&amp; value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1666      GenericObject AddMember(StringRefType name, StringRefType value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1667      template &lt;typename T&gt; RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr&lt;internal::IsPointer&lt;T&gt;, internal::IsGenericValue&lt;T&gt; &gt;), (GenericObject)) AddMember(StringRefType name, T value, AllocatorType&amp; allocator) const { value_.AddMember(name, value, allocator); return *this; }
1668      void RemoveAllMembers() { value_.RemoveAllMembers(); }
1669      bool RemoveMember(const Ch* name) const { return value_.RemoveMember(name); }
1670  #if RAPIDJSON_HAS_STDSTRING
1671      bool RemoveMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return value_.RemoveMember(name); }
1672  #endif
1673      template &lt;typename SourceAllocator&gt; bool RemoveMember(const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_.RemoveMember(name); }
1674      MemberIterator RemoveMember(MemberIterator m) const { return value_.RemoveMember(m); }
1675      MemberIterator EraseMember(ConstMemberIterator pos) const { return value_.EraseMember(pos); }
1676      MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) const { return value_.EraseMember(first, last); }
1677      bool EraseMember(const Ch* name) const { return value_.EraseMember(name); }
1678  #if RAPIDJSON_HAS_STDSTRING
1679      bool EraseMember(const std::basic_string&lt;Ch&gt;&amp; name) const { return EraseMember(ValueType(StringRef(name))); }
1680  #endif
1681      template &lt;typename SourceAllocator&gt; bool EraseMember(const GenericValue&lt;EncodingType, SourceAllocator&gt;&amp; name) const { return value_.EraseMember(name); }
1682  #if RAPIDJSON_HAS_CXX11_RANGE_FOR
1683      MemberIterator begin() const { return value_.MemberBegin(); }
1684      MemberIterator end() const { return value_.MemberEnd(); }
1685  #endif
1686  private:
1687      GenericObject();
1688      GenericObject(ValueType&amp; value) : value_(value) {}
1689      ValueType&amp; value_;
1690  };
1691  RAPIDJSON_NAMESPACE_END
1692  RAPIDJSON_DIAG_POP
1693  #ifdef RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
1694  #pragma pop_macro(&quot;GetObject&quot;)
1695  #undef RAPIDJSON_WINDOWS_GETOBJECT_WORKAROUND_APPLIED
1696  #endif
1697  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-document.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-document.h</div>
                </div>
                <div class="column column_space"><pre><code>1038      RAPIDJSON_FORCEINLINE GenericValue* SetElementsPointer(GenericValue* elements) { return RAPIDJSON_SETPOINTER(GenericValue, data_.a.elements, elements); }
1039      RAPIDJSON_FORCEINLINE Member* GetMembersPointer() const { return RAPIDJSON_GETPOINTER(Member, data_.o.members); }
</pre></code></div>
                <div class="column column_space"><pre><code>1040      RAPIDJSON_FORCEINLINE Member* SetMembersPointer(Member* members) { return RAPIDJSON_SETPOINTER(Member, data_.o.members, members); }
1041  #if RAPIDJSON_USE_MEMBERSMAP
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    