
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 13, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lgc.h</h3>
            <pre><code>1  #ifndef lgc_h
2  #define lgc_h
3  #include "lobject.h"
4  #define GCSpause	0
5  #define GCSpropagate	1
6  #define GCSsweepstring	2
7  #define GCSsweep	3
8  #define GCSfinalize	4
9  #define resetbits(x,m)	((x) &= cast(lu_byte, ~(m)))
10  #define setbits(x,m)	((x) |= (m))
11  #define testbits(x,m)	((x) & (m))
12  #define bitmask(b)	(1<<(b))
13  #define bit2mask(b1,b2)	(bitmask(b1) | bitmask(b2))
14  #define l_setbit(x,b)	setbits(x, bitmask(b))
15  #define resetbit(x,b)	resetbits(x, bitmask(b))
16  #define testbit(x,b)	testbits(x, bitmask(b))
17  #define set2bits(x,b1,b2)	setbits(x, (bit2mask(b1, b2)))
18  #define reset2bits(x,b1,b2)	resetbits(x, (bit2mask(b1, b2)))
19  #define test2bits(x,b1,b2)	testbits(x, (bit2mask(b1, b2)))
20  #define WHITE0BIT	0
21  #define WHITE1BIT	1
22  #define BLACKBIT	2
23  #define FINALIZEDBIT	3
24  #define KEYWEAKBIT	3
25  #define VALUEWEAKBIT	4
26  #define FIXEDBIT	5
27  #define SFIXEDBIT	6
28  #define WHITEBITS	bit2mask(WHITE0BIT, WHITE1BIT)
29  #define iswhite(x)      test2bits((x)->gch.marked, WHITE0BIT, WHITE1BIT)
30  #define isblack(x)      testbit((x)->gch.marked, BLACKBIT)
31  #define isgray(x)	(!isblack(x) && !iswhite(x))
32  #define otherwhite(g)	(g->currentwhite ^ WHITEBITS)
33  #define isdead(g,v)	((v)->gch.marked & otherwhite(g) & WHITEBITS)
34  #define changewhite(x)	((x)->gch.marked ^= WHITEBITS)
35  #define gray2black(x)	l_setbit((x)->gch.marked, BLACKBIT)
36  #define valiswhite(x)	(iscollectable(x) && iswhite(gcvalue(x)))
37  #define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)
38  #define luaC_checkGC(L) { \
39    condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); \
40    if (G(L)->totalbytes >= G(L)->GCthreshold) \
41  	luaC_step(L); }
42  #define luaC_barrier(L,p,v) { if (valiswhite(v) && isblack(obj2gco(p)))  \
43  	luaC_barrierf(L,obj2gco(p),gcvalue(v)); }
44  #define luaC_barriert(L,t,v) { if (valiswhite(v) && isblack(obj2gco(t)))  \
45  	luaC_barrierback(L,t); }
46  #define luaC_objbarrier(L,p,o)  \
47  	{ if (iswhite(obj2gco(o)) && isblack(obj2gco(p))) \
48  		luaC_barrierf(L,obj2gco(p),obj2gco(o)); }
49  #define luaC_objbarriert(L,t,o)  \
50     { if (iswhite(obj2gco(o)) && isblack(obj2gco(t))) luaC_barrierback(L,t); }
51  LUAI_FUNC size_t luaC_separateudata (lua_State *L, int all);
52  LUAI_FUNC void luaC_callGCTM (lua_State *L);
53  LUAI_FUNC void luaC_freeall (lua_State *L);
54  LUAI_FUNC void luaC_step (lua_State *L);
55  LUAI_FUNC void luaC_fullgc (lua_State *L);
56  LUAI_FUNC void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
57  LUAI_FUNC void luaC_linkupval (lua_State *L, UpVal *uv);
58  LUAI_FUNC void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v);
<span onclick='openModal()' class='match'>59  LUAI_FUNC void luaC_barrierback (lua_State *L, Table *t);
60  #endif
</span></code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstate.h</h3>
            <pre><code>1  #ifndef lstate_h
2  #define lstate_h
3  #include "lua.h"
4  #include "lobject.h"
5  #include "ltm.h"
6  #include "lzio.h"
7  struct lua_longjmp;  &bsol;* defined in ldo.c */
8  #define gt(L)	(&L->l_gt)
9  #define registry(L)	(&G(L)->l_registry)
10  #define EXTRA_STACK   5
11  #define BASIC_CI_SIZE           8
12  #define BASIC_STACK_SIZE        (2*LUA_MINSTACK)
13  typedef struct stringtable {
14    GCObject **hash;
15    lu_int32 nuse;  &bsol;* number of elements */
16    int size;
17  } stringtable;
18  typedef struct CallInfo {
19    StkId base;  &bsol;* base for this function */
20    StkId func;  &bsol;* function index in the stack */
21    StkId	top;  &bsol;* top for this function */
22    const Instruction *savedpc;
23    int nresults;  &bsol;* expected number of results from this function */
24    int tailcalls;  &bsol;* number of tail calls lost under this entry */
25  } CallInfo;
26  #define curr_func(L)	(clvalue(L->ci->func))
27  #define ci_func(ci)	(clvalue((ci)->func))
28  #define f_isLua(ci)	(!ci_func(ci)->c.isC)
29  #define isLua(ci)	(ttisfunction((ci)->func) && f_isLua(ci))
30  typedef struct global_State {
31    stringtable strt;  &bsol;* hash table for strings */
32    lua_Alloc frealloc;  &bsol;* function to reallocate memory */
33    void *ud;         &bsol;* auxiliary data to `frealloc' */
34    lu_byte currentwhite;
35    lu_byte gcstate;  &bsol;* state of garbage collector */
36    int sweepstrgc;  &bsol;* position of sweep in `strt' */
37    GCObject *rootgc;  &bsol;* list of all collectable objects */
38    GCObject **sweepgc;  &bsol;* position of sweep in `rootgc' */
39    GCObject *gray;  &bsol;* list of gray objects */
40    GCObject *grayagain;  &bsol;* list of objects to be traversed atomically */
41    GCObject *weak;  &bsol;* list of weak tables (to be cleared) */
42    GCObject *tmudata;  &bsol;* last element of list of userdata to be GC */
43    Mbuffer buff;  &bsol;* temporary buffer for string concatentation */
44    lu_mem GCthreshold;
45    lu_mem totalbytes;  &bsol;* number of bytes currently allocated */
46    lu_mem estimate;  &bsol;* an estimate of number of bytes actually in use */
47    lu_mem gcdept;  &bsol;* how much GC is `behind schedule' */
48    int gcpause;  &bsol;* size of pause between successive GCs */
49    int gcstepmul;  &bsol;* GC `granularity' */
50    lua_CFunction panic;  &bsol;* to be called in unprotected errors */
51    TValue l_registry;
52    struct lua_State *mainthread;
53    UpVal uvhead;  &bsol;* head of double-linked list of all open upvalues */
54    struct Table *mt[NUM_TAGS];  &bsol;* metatables for basic types */
55    TString *tmname[TM_N];  &bsol;* array with tag-method names */
56  } global_State;
57  struct lua_State {
58    CommonHeader;
59    lu_byte status;
60    StkId top;  &bsol;* first free slot in the stack */
61    StkId base;  &bsol;* base of current function */
62    global_State *l_G;
63    CallInfo *ci;  &bsol;* call info for current function */
64    const Instruction *savedpc;  &bsol;* `savedpc' of current function */
65    StkId stack_last;  &bsol;* last free slot in the stack */
66    StkId stack;  &bsol;* stack base */
67    CallInfo *end_ci;  &bsol;* points after end of ci array*/
68    CallInfo *base_ci;  &bsol;* array of CallInfo's */
69    int stacksize;
70    int size_ci;  &bsol;* size of array `base_ci' */
71    unsigned short nCcalls;  &bsol;* number of nested C calls */
72    unsigned short baseCcalls;  &bsol;* nested C calls when resuming coroutine */
73    lu_byte hookmask;
74    lu_byte allowhook;
75    int basehookcount;
76    int hookcount;
77    lua_Hook hook;
78    TValue l_gt;  &bsol;* table of globals */
79    TValue env;  &bsol;* temporary place for environments */
80    GCObject *openupval;  &bsol;* list of open upvalues in this stack */
81    GCObject *gclist;
82    struct lua_longjmp *errorJmp;  &bsol;* current error recover point */
83    ptrdiff_t errfunc;  &bsol;* current error handling function (stack index) */
84  };
85  #define G(L)	(L->l_G)
86  union GCObject {
87    GCheader gch;
88    union TString ts;
89    union Udata u;
90    union Closure cl;
91    struct Table h;
92    struct Proto p;
93    struct UpVal uv;
94    struct lua_State th;  &bsol;* thread */
95  };
96  #define rawgco2ts(o)	check_exp((o)->gch.tt == LUA_TSTRING, &((o)->ts))
97  #define gco2ts(o)	(&rawgco2ts(o)->tsv)
98  #define rawgco2u(o)	check_exp((o)->gch.tt == LUA_TUSERDATA, &((o)->u))
99  #define gco2u(o)	(&rawgco2u(o)->uv)
100  #define gco2cl(o)	check_exp((o)->gch.tt == LUA_TFUNCTION, &((o)->cl))
101  #define gco2h(o)	check_exp((o)->gch.tt == LUA_TTABLE, &((o)->h))
102  #define gco2p(o)	check_exp((o)->gch.tt == LUA_TPROTO, &((o)->p))
103  #define gco2uv(o)	check_exp((o)->gch.tt == LUA_TUPVAL, &((o)->uv))
104  #define ngcotouv(o) \
105  	check_exp((o) == NULL || (o)->gch.tt == LUA_TUPVAL, &((o)->uv))
106  #define gco2th(o)	check_exp((o)->gch.tt == LUA_TTHREAD, &((o)->th))
107  #define obj2gco(v)	(cast(GCObject *, (v)))
108  LUAI_FUNC lua_State *luaE_newthread (lua_State *L);
<span onclick='openModal()' class='match'>109  LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
110  #endif
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lgc.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-lstate.h</div>
                </div>
                <div class="column column_space"><pre><code>59  LUAI_FUNC void luaC_barrierback (lua_State *L, Table *t);
60  #endif
</pre></code></div>
                <div class="column column_space"><pre><code>109  LUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);
110  #endif
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    