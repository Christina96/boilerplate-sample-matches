
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-x86.c</h3>
            <pre><code>1  #include &quot;private/autogen/config.h&quot;
2  #include &quot;hwloc.h&quot;
3  #include &quot;private/private.h&quot;
4  #include &quot;private/debug.h&quot;
5  #include &quot;private/misc.h&quot;
6  #include &quot;private/cpuid-x86.h&quot;
7  #include &lt;sys/types.h&gt;
8  #ifdef HAVE_DIRENT_H
9  #include &lt;dirent.h&gt;
10  #endif
11  #ifdef HAVE_VALGRIND_VALGRIND_H
12  #include &lt;valgrind/valgrind.h&gt;
13  #endif
14  struct hwloc_x86_backend_data_s {
15    unsigned nbprocs;
16    hwloc_bitmap_t apicid_set;
17    int apicid_unique;
18    char *src_cpuiddump_path;
19    int is_knl;
20  };
21  struct cpuiddump {
22    unsigned nr;
23    struct cpuiddump_entry {
24      unsigned inmask; &amp;bsol;* which of ine[abcd]x are set on input */
25      unsigned ineax;
26      unsigned inebx;
27      unsigned inecx;
28      unsigned inedx;
29      unsigned outeax;
30      unsigned outebx;
31      unsigned outecx;
32      unsigned outedx;
33    } *entries;
34  };
35  static void
36  cpuiddump_free(struct cpuiddump *cpuiddump)
37  {
38    if (cpuiddump-&gt;nr)
39      free(cpuiddump-&gt;entries);
40    free(cpuiddump);
41  }
42  static struct cpuiddump *
43  cpuiddump_read(const char *dirpath, unsigned idx)
44  {
45    struct cpuiddump *cpuiddump;
46    struct cpuiddump_entry *cur;
47    size_t filenamelen;
48    char *filename;
49    FILE *file;
50    char line[128];
51    unsigned nr;
52    cpuiddump = malloc(sizeof(*cpuiddump));
53    if (!cpuiddump) {
54      fprintf(stderr, &quot;Failed to allocate cpuiddump for PU #%u, ignoring cpuiddump.\n&quot;, idx);
55      goto out;
56    }
57    filenamelen = strlen(dirpath) + 15;
58    filename = malloc(filenamelen);
59    if (!filename)
60      goto out_with_dump;
61    snprintf(filename, filenamelen, &quot;%s/pu%u&quot;, dirpath, idx);
62    file = fopen(filename, &quot;r&quot;);
63    if (!file) {
64      fprintf(stderr, &quot;Could not read dumped cpuid file %s, ignoring cpuiddump.\n&quot;, filename);
65      goto out_with_filename;
66    }
67    nr = 0;
68    while (fgets(line, sizeof(line), file))
69      nr++;
70    cpuiddump-&gt;entries = malloc(nr * sizeof(struct cpuiddump_entry));
71    if (!cpuiddump-&gt;entries) {
72      fprintf(stderr, &quot;Failed to allocate %u cpuiddump entries for PU #%u, ignoring cpuiddump.\n&quot;, nr, idx);
73      goto out_with_file;
74    }
75    fseek(file, 0, SEEK_SET);
76    cur = &amp;cpuiddump-&gt;entries[0];
77    nr = 0;
78    while (fgets(line, sizeof(line), file)) {
79      if (*line == &#x27;#&#x27;)
80        continue;
81      if (sscanf(line, &quot;%x %x %x %x %x =&gt; %x %x %x %x&quot;,
82  	      &amp;cur-&gt;inmask,
83  	      &amp;cur-&gt;ineax, &amp;cur-&gt;inebx, &amp;cur-&gt;inecx, &amp;cur-&gt;inedx,
84  	      &amp;cur-&gt;outeax, &amp;cur-&gt;outebx, &amp;cur-&gt;outecx, &amp;cur-&gt;outedx) == 9) {
85        cur++;
86        nr++;
87      }
88    }
89    cpuiddump-&gt;nr = nr;
90    fclose(file);
91    free(filename);
92    return cpuiddump;
93   out_with_file:
94    fclose(file);
95   out_with_filename:
96    free(filename);
97   out_with_dump:
98    free(cpuiddump);
99   out:
100    return NULL;
101  }
102  static void
103  cpuiddump_find_by_input(unsigned *eax, unsigned *ebx, unsigned *ecx, unsigned *edx, struct cpuiddump *cpuiddump)
104  {
105    unsigned i;
106    for(i=0; i&lt;cpuiddump-&gt;nr; i++) {
107      struct cpuiddump_entry *entry = &amp;cpuiddump-&gt;entries[i];
108      if ((entry-&gt;inmask &amp; 0x1) &amp;&amp; *eax != entry-&gt;ineax)
109        continue;
110      if ((entry-&gt;inmask &amp; 0x2) &amp;&amp; *ebx != entry-&gt;inebx)
111        continue;
112      if ((entry-&gt;inmask &amp; 0x4) &amp;&amp; *ecx != entry-&gt;inecx)
113        continue;
114      if ((entry-&gt;inmask &amp; 0x8) &amp;&amp; *edx != entry-&gt;inedx)
115        continue;
116      *eax = entry-&gt;outeax;
117      *ebx = entry-&gt;outebx;
118      *ecx = entry-&gt;outecx;
119      *edx = entry-&gt;outedx;
120      return;
121    }
122    fprintf(stderr, &quot;Couldn&#x27;t find %x,%x,%x,%x in dumped cpuid, returning 0s.\n&quot;,
123  	  *eax, *ebx, *ecx, *edx);
124    *eax = 0;
125    *ebx = 0;
126    *ecx = 0;
127    *edx = 0;
128  }
129  static void cpuid_or_from_dump(unsigned *eax, unsigned *ebx, unsigned *ecx, unsigned *edx, struct cpuiddump *src_cpuiddump)
130  {
131    if (src_cpuiddump) {
132      cpuiddump_find_by_input(eax, ebx, ecx, edx, src_cpuiddump);
133    } else {
134      hwloc_x86_cpuid(eax, ebx, ecx, edx);
135    }
136  }
137  enum hwloc_x86_disc_flags {
138    HWLOC_X86_DISC_FLAG_FULL = (1&lt;&lt;0), &amp;bsol;* discover everything instead of only annotating */
139    HWLOC_X86_DISC_FLAG_TOPOEXT_NUMANODES = (1&lt;&lt;1) &amp;bsol;* use AMD topoext numanode information */
140  };
141  #define has_topoext(features) ((features)[6] &amp; (1 &lt;&lt; 22))
142  #define has_x2apic(features) ((features)[4] &amp; (1 &lt;&lt; 21))
143  #define has_hybrid(features) ((features)[18] &amp; (1 &lt;&lt; 15))
144  struct cacheinfo {
145    hwloc_obj_cache_type_t type;
146    unsigned level;
147    unsigned nbthreads_sharing;
148    unsigned cacheid;
149    unsigned linesize;
150    unsigned linepart;
151    int inclusive;
152    int ways;
153    unsigned sets;
154    unsigned long size;
155  };
156  struct procinfo {
157    unsigned present;
158    unsigned apicid;
159  #define PKG 0
160  #define CORE 1
161  #define NODE 2
162  #define UNIT 3
163  #define TILE 4
164  #define MODULE 5
165  #define DIE 6
166  #define HWLOC_X86_PROCINFO_ID_NR 7
167    unsigned ids[HWLOC_X86_PROCINFO_ID_NR];
168    unsigned *otherids;
169    unsigned levels;
170    unsigned numcaches;
171    struct cacheinfo *cache;
172    char cpuvendor[13];
173    char cpumodel[3*4*4+1];
174    unsigned cpustepping;
175    unsigned cpumodelnumber;
176    unsigned cpufamilynumber;
177    unsigned hybridcoretype;
178    unsigned hybridnativemodel;
179  };
180  enum cpuid_type {
181    intel,
182    amd,
183    zhaoxin,
184    hygon,
185    unknown
186  };
187  static void setup__amd_cache_legacy(struct procinfo *infos, unsigned level, hwloc_obj_cache_type_t type, unsigned nbthreads_sharing, unsigned cpuid)
188  {
189    struct cacheinfo *cache, *tmpcaches;
190    unsigned cachenum;
191    unsigned long size = 0;
192    if (level == 1)
193      size = ((cpuid &gt;&gt; 24)) &lt;&lt; 10;
194    else if (level == 2)
195      size = ((cpuid &gt;&gt; 16)) &lt;&lt; 10;
196    else if (level == 3)
197      size = ((cpuid &gt;&gt; 18)) &lt;&lt; 19;
198    if (!size)
199      return;
200    tmpcaches = realloc(infos-&gt;cache, (infos-&gt;numcaches+1)*sizeof(*infos-&gt;cache));
201    if (!tmpcaches)
202      return;
203    infos-&gt;cache = tmpcaches;
204    cachenum = infos-&gt;numcaches++;
205    cache = &amp;infos-&gt;cache[cachenum];
206    cache-&gt;type = type;
207    cache-&gt;level = level;
208    cache-&gt;nbthreads_sharing = nbthreads_sharing;
209    cache-&gt;linesize = cpuid &amp; 0xff;
210    cache-&gt;linepart = 0;
211    cache-&gt;inclusive = 0; &amp;bsol;* old AMD (K8-K10) supposed to have exclusive caches */
212    if (level == 1) {
213      cache-&gt;ways = (cpuid &gt;&gt; 16) &amp; 0xff;
214      if (cache-&gt;ways == 0xff)
215        cache-&gt;ways = -1;
216    } else {
217      static const unsigned ways_tab[] = { 0, 1, 2, 0, 4, 0, 8, 0, 16, 0, 32, 48, 64, 96, 128, -1 };
218      unsigned ways = (cpuid &gt;&gt; 12) &amp; 0xf;
219      cache-&gt;ways = ways_tab[ways];
220    }
221    cache-&gt;size = size;
222    cache-&gt;sets = 0;
223    hwloc_debug(&quot;cache L%u t%u linesize %u ways %d size %luKB\n&quot;, cache-&gt;level, cache-&gt;nbthreads_sharing, cache-&gt;linesize, cache-&gt;ways, cache-&gt;size &gt;&gt; 10);
224  }
225  static void read_amd_caches_legacy(struct procinfo *infos, struct cpuiddump *src_cpuiddump, unsigned legacy_max_log_proc)
226  {
227    unsigned eax, ebx, ecx, edx;
228    eax = 0x80000005;
229    cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
230    setup__amd_cache_legacy(infos, 1, HWLOC_OBJ_CACHE_DATA, 1, ecx); &amp;bsol;* private L1d */
231    setup__amd_cache_legacy(infos, 1, HWLOC_OBJ_CACHE_INSTRUCTION, 1, edx); &amp;bsol;* private L1i */
232    eax = 0x80000006;
233    cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
234    if (ecx &amp; 0xf000)
235      setup__amd_cache_legacy(infos, 2, HWLOC_OBJ_CACHE_UNIFIED, 1, ecx); &amp;bsol;* private L2u */
236    if (edx &amp; 0xf000)
237      setup__amd_cache_legacy(infos, 3, HWLOC_OBJ_CACHE_UNIFIED, legacy_max_log_proc, edx); &amp;bsol;* package-wide L3u */
238  }
239  static void read_amd_caches_topoext(struct procinfo *infos, struct cpuiddump *src_cpuiddump)
240  {
241    unsigned eax, ebx, ecx, edx;
242    unsigned cachenum;
243    struct cacheinfo *cache;
244    assert(!infos-&gt;numcaches);
245    for (cachenum = 0; ; cachenum++) {
246      eax = 0x8000001d;
247      ecx = cachenum;
248      cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
249      if ((eax &amp; 0x1f) == 0)
250        break;
251      infos-&gt;numcaches++;
252    }
253    cache = infos-&gt;cache = malloc(infos-&gt;numcaches * sizeof(*infos-&gt;cache));
254    if (cache) {
255      for (cachenum = 0; ; cachenum++) {
256        unsigned long linesize, linepart, ways, sets;
257        eax = 0x8000001d;
258        ecx = cachenum;
259        cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
260        if ((eax &amp; 0x1f) == 0)
261  	break;
262        switch (eax &amp; 0x1f) {
263        case 1: cache-&gt;type = HWLOC_OBJ_CACHE_DATA; break;
264        case 2: cache-&gt;type = HWLOC_OBJ_CACHE_INSTRUCTION; break;
265        default: cache-&gt;type = HWLOC_OBJ_CACHE_UNIFIED; break;
266        }
267        cache-&gt;level = (eax &gt;&gt; 5) &amp; 0x7;
268        cache-&gt;nbthreads_sharing = ((eax &gt;&gt; 14) &amp;  0xfff) + 1;
269        cache-&gt;linesize = linesize = (ebx &amp; 0xfff) + 1;
270        cache-&gt;linepart = linepart = ((ebx &gt;&gt; 12) &amp; 0x3ff) + 1;
271        ways = ((ebx &gt;&gt; 22) &amp; 0x3ff) + 1;
272        if (eax &amp; (1 &lt;&lt; 9))
273  	cache-&gt;ways = -1;
274        else
275  	cache-&gt;ways = ways;
276        cache-&gt;sets = sets = ecx + 1;
277        cache-&gt;size = linesize * linepart * ways * sets;
278        cache-&gt;inclusive = edx &amp; 0x2;
279        hwloc_debug(&quot;cache %u L%u%c t%u linesize %lu linepart %lu ways %lu sets %lu, size %luKB\n&quot;,
280  		  cachenum, cache-&gt;level,
281  		  cache-&gt;type == HWLOC_OBJ_CACHE_DATA ? &#x27;d&#x27; : cache-&gt;type == HWLOC_OBJ_CACHE_INSTRUCTION ? &#x27;i&#x27; : &#x27;u&#x27;,
282  		  cache-&gt;nbthreads_sharing, linesize, linepart, ways, sets, cache-&gt;size &gt;&gt; 10);
283        cache++;
284      }
285    } else {
286      infos-&gt;numcaches = 0;
287    }
288  }
289  static void read_intel_caches(struct hwloc_x86_backend_data_s *data, struct procinfo *infos, struct cpuiddump *src_cpuiddump)
290  {
291    unsigned level;
292    struct cacheinfo *tmpcaches;
293    unsigned eax, ebx, ecx, edx;
294    unsigned oldnumcaches = infos-&gt;numcaches; &amp;bsol;* in case we got caches above */
295    unsigned cachenum;
296    struct cacheinfo *cache;
297    for (cachenum = 0; ; cachenum++) {
298      eax = 0x04;
299      ecx = cachenum;
300      cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
301      hwloc_debug(&quot;cache %u type %u\n&quot;, cachenum, eax &amp; 0x1f);
302      if ((eax &amp; 0x1f) == 0)
303        break;
304      level = (eax &gt;&gt; 5) &amp; 0x7;
305      if (data-&gt;is_knl &amp;&amp; level == 3)
306        break;
307      infos-&gt;numcaches++;
308    }
309    tmpcaches = realloc(infos-&gt;cache, infos-&gt;numcaches * sizeof(*infos-&gt;cache));
310    if (!tmpcaches) {
311      infos-&gt;numcaches = oldnumcaches;
312    } else {
313      infos-&gt;cache = tmpcaches;
314      cache = &amp;infos-&gt;cache[oldnumcaches];
315      for (cachenum = 0; ; cachenum++) {
316        unsigned long linesize, linepart, ways, sets;
317        eax = 0x04;
318        ecx = cachenum;
319        cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
320        if ((eax &amp; 0x1f) == 0)
321  	break;
322        level = (eax &gt;&gt; 5) &amp; 0x7;
323        if (data-&gt;is_knl &amp;&amp; level == 3)
324  	break;
325        switch (eax &amp; 0x1f) {
326        case 1: cache-&gt;type = HWLOC_OBJ_CACHE_DATA; break;
327        case 2: cache-&gt;type = HWLOC_OBJ_CACHE_INSTRUCTION; break;
328        default: cache-&gt;type = HWLOC_OBJ_CACHE_UNIFIED; break;
329        }
330        cache-&gt;level = level;
331        cache-&gt;nbthreads_sharing = ((eax &gt;&gt; 14) &amp; 0xfff) + 1;
332        cache-&gt;linesize = linesize = (ebx &amp; 0xfff) + 1;
333        cache-&gt;linepart = linepart = ((ebx &gt;&gt; 12) &amp; 0x3ff) + 1;
334        ways = ((ebx &gt;&gt; 22) &amp; 0x3ff) + 1;
335        if (eax &amp; (1 &lt;&lt; 9))
336          cache-&gt;ways = -1;
337        else
338          cache-&gt;ways = ways;
339        cache-&gt;sets = sets = ecx + 1;
340        cache-&gt;size = linesize * linepart * ways * sets;
341        cache-&gt;inclusive = edx &amp; 0x2;
342        hwloc_debug(&quot;cache %u L%u%c t%u linesize %lu linepart %lu ways %lu sets %lu, size %luKB\n&quot;,
343  		  cachenum, cache-&gt;level,
344  		  cache-&gt;type == HWLOC_OBJ_CACHE_DATA ? &#x27;d&#x27; : cache-&gt;type == HWLOC_OBJ_CACHE_INSTRUCTION ? &#x27;i&#x27; : &#x27;u&#x27;,
345  		  cache-&gt;nbthreads_sharing, linesize, linepart, ways, sets, cache-&gt;size &gt;&gt; 10);
346        cache++;
347      }
348    }
349  }
350  static void read_amd_cores_legacy(struct procinfo *infos, struct cpuiddump *src_cpuiddump)
351  {
352    unsigned eax, ebx, ecx, edx;
353    unsigned max_nbcores;
354    unsigned max_nbthreads;
355    unsigned coreidsize;
356    unsigned logprocid;
357    unsigned threadid __hwloc_attribute_unused;
358    eax = 0x80000008;
359    cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
360    coreidsize = (ecx &gt;&gt; 12) &amp; 0xf;
361    hwloc_debug(&quot;core ID size: %u\n&quot;, coreidsize);
362    if (!coreidsize) {
363      max_nbcores = (ecx &amp; 0xff) + 1;
364    } else
365      max_nbcores = 1 &lt;&lt; coreidsize;
366    hwloc_debug(&quot;Thus max # of cores: %u\n&quot;, max_nbcores);
367    max_nbthreads = 1 ;
368    hwloc_debug(&quot;and max # of threads: %u\n&quot;, max_nbthreads);
369    infos-&gt;ids[PKG] = infos-&gt;apicid / max_nbcores;
370    logprocid = infos-&gt;apicid % max_nbcores;
371    infos-&gt;ids[CORE] = logprocid / max_nbthreads;
372    threadid = logprocid % max_nbthreads;
373    hwloc_debug(&quot;this is thread %u of core %u\n&quot;, threadid, infos-&gt;ids[CORE]);
374  }
375  static void read_amd_cores_topoext(struct procinfo *infos, unsigned long flags, struct cpuiddump *src_cpuiddump)
376  {
377    unsigned apic_id, nodes_per_proc = 0;
378    unsigned eax, ebx, ecx, edx;
379    eax = 0x8000001e;
380    cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
381    infos-&gt;apicid = apic_id = eax;
382    if (flags &amp; HWLOC_X86_DISC_FLAG_TOPOEXT_NUMANODES) {
383      if (infos-&gt;cpufamilynumber == 0x16) {
384        infos-&gt;ids[NODE] = 0;
385        nodes_per_proc = 1;
386      } else {
387        infos-&gt;ids[NODE] = ecx &amp; 0xff;
388        nodes_per_proc = ((ecx &gt;&gt; 8) &amp; 7) + 1;
389      }
390      if ((infos-&gt;cpufamilynumber == 0x15 &amp;&amp; nodes_per_proc &gt; 2)
391  	|| ((infos-&gt;cpufamilynumber == 0x17 || infos-&gt;cpufamilynumber == 0x18) &amp;&amp; nodes_per_proc &gt; 4)
392          || (infos-&gt;cpufamilynumber == 0x19 &amp;&amp; nodes_per_proc &gt; 1)) {
393        hwloc_debug(&quot;warning: undefined nodes_per_proc value %u, assuming it means %u\n&quot;, nodes_per_proc, nodes_per_proc);
394      }
395    }
396    if (infos-&gt;cpufamilynumber &lt;= 0x16) { &amp;bsol;* topoext appeared in 0x15 and compute-units were only used in 0x15 and 0x16 */
397      unsigned cores_per_unit;
398      infos-&gt;ids[UNIT] = ebx &amp; 0xff;
399      cores_per_unit = ((ebx &gt;&gt; 8) &amp; 0xff) + 1;
400      hwloc_debug(&quot;topoext %08x, %u nodes, node %u, %u cores in unit %u\n&quot;, apic_id, nodes_per_proc, infos-&gt;ids[NODE], cores_per_unit, infos-&gt;ids[UNIT]);
401    } else {
402      unsigned threads_per_core;
403      infos-&gt;ids[CORE] = ebx &amp; 0xff;
404      threads_per_core = ((ebx &gt;&gt; 8) &amp; 0xff) + 1;
405      hwloc_debug(&quot;topoext %08x, %u nodes, node %u, %u threads in core %u\n&quot;, apic_id, nodes_per_proc, infos-&gt;ids[NODE], threads_per_core, infos-&gt;ids[CORE]);
406    }
407  }
408  static void read_intel_cores_exttopoenum(struct procinfo *infos, unsigned leaf, struct cpuiddump *src_cpuiddump)
409  {
410    unsigned level, apic_nextshift, apic_number, apic_type, apic_id = 0, apic_shift = 0, id;
411    unsigned threadid __hwloc_attribute_unused = 0; &amp;bsol;* shut-up compiler */
412    unsigned eax, ebx, ecx = 0, edx;
413    int apic_packageshift = 0;
414    for (level = 0; ; level++) {
415      ecx = level;
416      eax = leaf;
417      cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
418      if (!eax &amp;&amp; !ebx)
419        break;
420      apic_packageshift = eax &amp; 0x1f;
421    }
422    if (level) {
423      infos-&gt;otherids = malloc(level * sizeof(*infos-&gt;otherids));
424      if (infos-&gt;otherids) {
425        infos-&gt;levels = level;
426        for (level = 0; ; level++) {
427  	ecx = level;
428  	eax = leaf;
429  	cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
430  	if (!eax &amp;&amp; !ebx)
431  	  break;
432  	apic_nextshift = eax &amp; 0x1f;
433  	apic_number = ebx &amp; 0xffff;
434  	apic_type = (ecx &amp; 0xff00) &gt;&gt; 8;
435  	apic_id = edx;
436  	id = (apic_id &gt;&gt; apic_shift) &amp; ((1 &lt;&lt; (apic_packageshift - apic_shift)) - 1);
437  	hwloc_debug(&quot;x2APIC %08x %u: nextshift %u num %2u type %u id %2u\n&quot;, apic_id, level, apic_nextshift, apic_number, apic_type, id);
438  	infos-&gt;apicid = apic_id;
439  	infos-&gt;otherids[level] = UINT_MAX;
440  	switch (apic_type) {
441  	case 1:
442  	  threadid = id;
443  	  break;
444  	case 2:
445  	  infos-&gt;ids[CORE] = id;
446  	  break;
447  	case 3:
448  	  infos-&gt;ids[MODULE] = id;
449  	  break;
450  	case 4:
451  	  infos-&gt;ids[TILE] = id;
452  	  break;
453  	case 5:
454  	  infos-&gt;ids[DIE] = id;
455  	  break;
456  	default:
457  	  hwloc_debug(&quot;x2APIC %u: unknown type %u\n&quot;, level, apic_type);
458  	  infos-&gt;otherids[level] = apic_id &gt;&gt; apic_shift;
459  	  break;
460  	}
461  	apic_shift = apic_nextshift;
462        }
463        infos-&gt;apicid = apic_id;
464        infos-&gt;ids[PKG] = apic_id &gt;&gt; apic_shift;
465        hwloc_debug(&quot;x2APIC remainder: %u\n&quot;, infos-&gt;ids[PKG]);
466        hwloc_debug(&quot;this is thread %u of core %u\n&quot;, threadid, infos-&gt;ids[CORE]);
467      }
468    }
469  }
470  static void look_proc(struct hwloc_backend *backend, struct procinfo *infos, unsigned long flags, unsigned highest_cpuid, unsigned highest_ext_cpuid, unsigned *features, enum cpuid_type cpuid_type, struct cpuiddump *src_cpuiddump)
471  {
472    struct hwloc_x86_backend_data_s *data = backend-&gt;private_data;
473    unsigned eax, ebx, ecx = 0, edx;
474    unsigned cachenum;
475    struct cacheinfo *cache;
476    unsigned regs[4];
477    unsigned legacy_max_log_proc; &amp;bsol;* not valid on Intel processors with &gt; 256 threads, or when cpuid 0x80000008 is supported */
478    unsigned legacy_log_proc_id;
479    unsigned _model, _extendedmodel, _family, _extendedfamily;
480    infos-&gt;present = 1;
481    eax = 0x01;
482    cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
483    infos-&gt;apicid = ebx &gt;&gt; 24;
484    if (edx &amp; (1 &lt;&lt; 28)) {
485      legacy_max_log_proc = 1 &lt;&lt; hwloc_flsl(((ebx &gt;&gt; 16) &amp; 0xff) - 1);
486    } else {
487      hwloc_debug(&quot;HTT bit not set in CPUID 0x01.edx, assuming legacy_max_log_proc = 1\n&quot;);
488      legacy_max_log_proc = 1;
489    }
490    hwloc_debug(&quot;APIC ID 0x%02x legacy_max_log_proc %u\n&quot;, infos-&gt;apicid, legacy_max_log_proc);
491    infos-&gt;ids[PKG] = infos-&gt;apicid / legacy_max_log_proc;
492    legacy_log_proc_id = infos-&gt;apicid % legacy_max_log_proc;
493    hwloc_debug(&quot;phys %u legacy thread %u\n&quot;, infos-&gt;ids[PKG], legacy_log_proc_id);
494    _model          = (eax&gt;&gt;4) &amp; 0xf;
495    _extendedmodel  = (eax&gt;&gt;16) &amp; 0xf;
496    _family         = (eax&gt;&gt;8) &amp; 0xf;
497    _extendedfamily = (eax&gt;&gt;20) &amp; 0xff;
498    if ((cpuid_type == intel || cpuid_type == amd || cpuid_type == hygon) &amp;&amp; _family == 0xf) {
499      infos-&gt;cpufamilynumber = _family + _extendedfamily;
500    } else {
501      infos-&gt;cpufamilynumber = _family;
502    }
503    if ((cpuid_type == intel &amp;&amp; (_family == 0x6 || _family == 0xf))
504        || ((cpuid_type == amd || cpuid_type == hygon) &amp;&amp; _family == 0xf)
505        || (cpuid_type == zhaoxin &amp;&amp; (_family == 0x6 || _family == 0x7))) {
506      infos-&gt;cpumodelnumber = _model + (_extendedmodel &lt;&lt; 4);
507    } else {
508      infos-&gt;cpumodelnumber = _model;
509    }
510    infos-&gt;cpustepping = eax &amp; 0xf;
511    if (cpuid_type == intel &amp;&amp; infos-&gt;cpufamilynumber == 0x6 &amp;&amp;
512        (infos-&gt;cpumodelnumber == 0x57 || infos-&gt;cpumodelnumber == 0x85))
513      data-&gt;is_knl = 1; &amp;bsol;* KNM is the same as KNL */
514    memset(regs, 0, sizeof(regs));
515    regs[0] = 0;
516    cpuid_or_from_dump(&amp;regs[0], &amp;regs[1], &amp;regs[3], &amp;regs[2], src_cpuiddump);
517    memcpy(infos-&gt;cpuvendor, regs+1, 4*3);
518    if (highest_ext_cpuid &gt;= 0x80000004) {
519      memset(regs, 0, sizeof(regs));
520      regs[0] = 0x80000002;
521      cpuid_or_from_dump(&amp;regs[0], &amp;regs[1], &amp;regs[2], &amp;regs[3], src_cpuiddump);
522      memcpy(infos-&gt;cpumodel, regs, 4*4);
523      regs[0] = 0x80000003;
524      cpuid_or_from_dump(&amp;regs[0], &amp;regs[1], &amp;regs[2], &amp;regs[3], src_cpuiddump);
525      memcpy(infos-&gt;cpumodel + 4*4, regs, 4*4);
526      regs[0] = 0x80000004;
527      cpuid_or_from_dump(&amp;regs[0], &amp;regs[1], &amp;regs[2], &amp;regs[3], src_cpuiddump);
528      memcpy(infos-&gt;cpumodel + 4*4*2, regs, 4*4);
529    }
530    if ((cpuid_type != amd &amp;&amp; cpuid_type != hygon) &amp;&amp; highest_cpuid &gt;= 0x04) {
531      eax = 0x04;
532      ecx = 0;
533      cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
534      if ((eax &amp; 0x1f) != 0) {
535        unsigned max_nbcores;
536        unsigned max_nbthreads;
537        unsigned threadid __hwloc_attribute_unused;
538        hwloc_debug(&quot;Trying to get core/thread IDs from 0x04...\n&quot;);
539        max_nbcores = ((eax &gt;&gt; 26) &amp; 0x3f) + 1;
540        hwloc_debug(&quot;found %u cores max\n&quot;, max_nbcores);
541        if (!max_nbcores) {
542          hwloc_debug(&quot;cannot detect core/thread IDs from 0x04 without a valid max of cores\n&quot;);
543        } else {
544          max_nbthreads = legacy_max_log_proc / max_nbcores;
545          hwloc_debug(&quot;found %u threads max\n&quot;, max_nbthreads);
546          if (!max_nbthreads) {
547            hwloc_debug(&quot;cannot detect core/thread IDs from 0x04 without a valid max of threads\n&quot;);
548          } else {
549            threadid = legacy_log_proc_id % max_nbthreads;
550            infos-&gt;ids[CORE] = legacy_log_proc_id / max_nbthreads;
551            hwloc_debug(&quot;this is thread %u of core %u\n&quot;, threadid, infos-&gt;ids[CORE]);
552          }
553        }
554      }
555    }
556    if (highest_cpuid &gt;= 0x1a &amp;&amp; has_hybrid(features)) {
557      eax = 0x1a;
558      ecx = 0;
<span onclick='openModal()' class='match'>559      cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
560      infos-&gt;hybridcoretype = eax &gt;&gt; 24;
</span>561      infos-&gt;hybridnativemodel = eax &amp; 0xffffff;
562    }
563    if (cpuid_type != intel &amp;&amp; cpuid_type != zhaoxin &amp;&amp; highest_ext_cpuid &gt;= 0x80000008 &amp;&amp; !has_x2apic(features)) {
564      read_amd_cores_legacy(infos, src_cpuiddump);
565    }
566    if (cpuid_type != intel &amp;&amp; cpuid_type != zhaoxin &amp;&amp; has_topoext(features)) {
567      read_amd_cores_topoext(infos, flags, src_cpuiddump);
568    }
569    if ((cpuid_type == intel) &amp;&amp; highest_cpuid &gt;= 0x1f) {
570      read_intel_cores_exttopoenum(infos, 0x1f, src_cpuiddump);
571    } else if ((cpuid_type == intel || cpuid_type == amd || cpuid_type == zhaoxin)
572  	     &amp;&amp; highest_cpuid &gt;= 0x0b &amp;&amp; has_x2apic(features)) {
573      read_intel_cores_exttopoenum(infos, 0x0b, src_cpuiddump);
574    }
575    infos-&gt;numcaches = 0;
576    infos-&gt;cache = NULL;
577    if (cpuid_type != intel &amp;&amp; cpuid_type != zhaoxin &amp;&amp; has_topoext(features)) {
578      read_amd_caches_topoext(infos, src_cpuiddump);
579    } else if (cpuid_type != intel &amp;&amp; cpuid_type != zhaoxin &amp;&amp; highest_ext_cpuid &gt;= 0x80000006) {
580      read_amd_caches_legacy(infos, src_cpuiddump, legacy_max_log_proc);
581    }
582    if ((cpuid_type != amd &amp;&amp; cpuid_type != hygon) &amp;&amp; highest_cpuid &gt;= 0x04) {
583      read_intel_caches(data, infos, src_cpuiddump);
584    }
585    for (cachenum = 0; cachenum &lt; infos-&gt;numcaches; cachenum++) {
586      cache = &amp;infos-&gt;cache[cachenum];
587      cache-&gt;cacheid = infos-&gt;apicid / cache-&gt;nbthreads_sharing;
588      if (cpuid_type == intel) {
589        unsigned bits = hwloc_flsl(cache-&gt;nbthreads_sharing-1);
590        unsigned mask = ~((1U&lt;&lt;bits) - 1);
591        cache-&gt;cacheid = infos-&gt;apicid &amp; mask;
592      } else if (cpuid_type == amd) {
593        if (infos-&gt;cpufamilynumber &gt;= 0x17 &amp;&amp; cache-&gt;level == 3) {
594          unsigned nbapics_sharing = cache-&gt;nbthreads_sharing;
595          if (nbapics_sharing &amp; (nbapics_sharing-1))
596            nbapics_sharing = 1U&lt;&lt;(1+hwloc_ffsl(nbapics_sharing));
597  	cache-&gt;cacheid = infos-&gt;apicid / nbapics_sharing;
598        } else if (infos-&gt;cpufamilynumber== 0x10 &amp;&amp; infos-&gt;cpumodelnumber == 0x9
599  	  &amp;&amp; cache-&gt;level == 3
600  	  &amp;&amp; (cache-&gt;ways == -1 || (cache-&gt;ways % 2 == 0)) &amp;&amp; cache-&gt;nbthreads_sharing &gt;= 8) {
601  	if (cache-&gt;nbthreads_sharing == 16)
602  	  cache-&gt;nbthreads_sharing = 12; &amp;bsol;* nbthreads_sharing is a power of 2 but the processor actually has 8 or 12 cores */
603  	cache-&gt;nbthreads_sharing /= 2;
604  	cache-&gt;size /= 2;
605  	if (cache-&gt;ways != -1)
606  	  cache-&gt;ways /= 2;
607  	cache-&gt;cacheid = (infos-&gt;apicid % legacy_max_log_proc) / cache-&gt;nbthreads_sharing &amp;bsol;* cacheid within the package */
608  	  + 2 * (infos-&gt;apicid / legacy_max_log_proc); &amp;bsol;* add 2 caches per previous package */
609        } else if (infos-&gt;cpufamilynumber == 0x15
610  		 &amp;&amp; (infos-&gt;cpumodelnumber == 0x1 &amp;bsol;* Bulldozer */ || infos-&gt;cpumodelnumber == 0x2 &amp;bsol;* Piledriver */)
611  		 &amp;&amp; cache-&gt;level == 3 &amp;&amp; cache-&gt;nbthreads_sharing == 6) {
612  	cache-&gt;cacheid = (infos-&gt;apicid % legacy_max_log_proc) / cache-&gt;nbthreads_sharing &amp;bsol;* cacheid within the package */
613  	  + 2 * (infos-&gt;apicid / legacy_max_log_proc); &amp;bsol;* add 2 cache per previous package */
614        }
615      } else if (cpuid_type == hygon) {
616        if (infos-&gt;cpufamilynumber == 0x18
617  	  &amp;&amp; cache-&gt;level == 3 &amp;&amp; cache-&gt;nbthreads_sharing == 6) {
618          cache-&gt;cacheid = infos-&gt;apicid / 8;
619        }
620      }
621    }
622    if (hwloc_bitmap_isset(data-&gt;apicid_set, infos-&gt;apicid))
623      data-&gt;apicid_unique = 0;
624    else
625      hwloc_bitmap_set(data-&gt;apicid_set, infos-&gt;apicid);
626  }
627  static void
628  hwloc_x86_add_cpuinfos(hwloc_obj_t obj, struct procinfo *info, int replace)
629  {
630    char number[12];
631    if (info-&gt;cpuvendor[0])
632      hwloc__add_info_nodup(&amp;obj-&gt;infos, &amp;obj-&gt;infos_count, &quot;CPUVendor&quot;, info-&gt;cpuvendor, replace);
633    snprintf(number, sizeof(number), &quot;%u&quot;, info-&gt;cpufamilynumber);
634    hwloc__add_info_nodup(&amp;obj-&gt;infos, &amp;obj-&gt;infos_count, &quot;CPUFamilyNumber&quot;, number, replace);
635    snprintf(number, sizeof(number), &quot;%u&quot;, info-&gt;cpumodelnumber);
636    hwloc__add_info_nodup(&amp;obj-&gt;infos, &amp;obj-&gt;infos_count, &quot;CPUModelNumber&quot;, number, replace);
637    if (info-&gt;cpumodel[0]) {
638      const char *c = info-&gt;cpumodel;
639      while (*c == &#x27; &#x27;)
640        c++;
641      hwloc__add_info_nodup(&amp;obj-&gt;infos, &amp;obj-&gt;infos_count, &quot;CPUModel&quot;, c, replace);
642    }
643    snprintf(number, sizeof(number), &quot;%u&quot;, info-&gt;cpustepping);
644    hwloc__add_info_nodup(&amp;obj-&gt;infos, &amp;obj-&gt;infos_count, &quot;CPUStepping&quot;, number, replace);
645  }
646  static void
647  hwloc_x86_add_groups(hwloc_topology_t topology,
648  		     struct procinfo *infos,
649  		     unsigned nbprocs,
650  		     hwloc_bitmap_t remaining_cpuset,
651  		     unsigned type,
652  		     const char *subtype,
653  		     unsigned kind,
654  		     int dont_merge)
655  {
656    hwloc_bitmap_t obj_cpuset;
657    hwloc_obj_t obj;
658    unsigned i, j;
659    while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
660      unsigned packageid = infos[i].ids[PKG];
661      unsigned id = infos[i].ids[type];
662      if (id == (unsigned)-1) {
663        hwloc_bitmap_clr(remaining_cpuset, i);
664        continue;
665      }
666      obj_cpuset = hwloc_bitmap_alloc();
667      for (j = i; j &lt; nbprocs; j++) {
668        if (infos[j].ids[type] == (unsigned) -1) {
669  	hwloc_bitmap_clr(remaining_cpuset, j);
670  	continue;
671        }
672        if (infos[j].ids[PKG] == packageid &amp;&amp; infos[j].ids[type] == id) {
673  	hwloc_bitmap_set(obj_cpuset, j);
674  	hwloc_bitmap_clr(remaining_cpuset, j);
675        }
676      }
677      obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, id);
678      obj-&gt;cpuset = obj_cpuset;
679      obj-&gt;subtype = strdup(subtype);
680      obj-&gt;attr-&gt;group.kind = kind;
681      obj-&gt;attr-&gt;group.dont_merge = dont_merge;
682      hwloc_debug_2args_bitmap(&quot;os %s %u has cpuset %s\n&quot;,
683  			     subtype, id, obj_cpuset);
684      hwloc__insert_object_by_cpuset(topology, NULL, obj, &quot;x86:group&quot;);
685    }
686  }
687  static void summarize(struct hwloc_backend *backend, struct procinfo *infos, unsigned long flags)
688  {
689    struct hwloc_topology *topology = backend-&gt;topology;
690    struct hwloc_x86_backend_data_s *data = backend-&gt;private_data;
691    unsigned nbprocs = data-&gt;nbprocs;
692    hwloc_bitmap_t complete_cpuset = hwloc_bitmap_alloc();
693    unsigned i, j, l, level;
694    int one = -1;
695    hwloc_bitmap_t remaining_cpuset;
696    int gotnuma = 0;
697    int fulldiscovery = (flags &amp; HWLOC_X86_DISC_FLAG_FULL);
698  #ifdef HWLOC_DEBUG
699    hwloc_debug(&quot;\nSummary of x86 CPUID topology:\n&quot;);
700    for(i=0; i&lt;nbprocs; i++) {
701      hwloc_debug(&quot;PU %u present=%u apicid=%u on PKG %d CORE %d DIE %d NODE %d\n&quot;,
702                  i, infos[i].present, infos[i].apicid,
703                  infos[i].ids[PKG], infos[i].ids[CORE], infos[i].ids[DIE], infos[i].ids[NODE]);
704    }
705    hwloc_debug(&quot;\n&quot;);
706  #endif
707    for (i = 0; i &lt; nbprocs; i++)
708      if (infos[i].present) {
709        hwloc_bitmap_set(complete_cpuset, i);
710        one = i;
711      }
712    if (one == -1) {
713      hwloc_bitmap_free(complete_cpuset);
714      return;
715    }
716    remaining_cpuset = hwloc_bitmap_alloc();
717    if (hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_PACKAGE)) {
718      hwloc_obj_t package;
719      hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
720      while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
721        if (fulldiscovery) {
722  	unsigned packageid = infos[i].ids[PKG];
723  	hwloc_bitmap_t package_cpuset = hwloc_bitmap_alloc();
724  	for (j = i; j &lt; nbprocs; j++) {
725  	  if (infos[j].ids[PKG] == packageid) {
726  	    hwloc_bitmap_set(package_cpuset, j);
727  	    hwloc_bitmap_clr(remaining_cpuset, j);
728  	  }
729  	}
730  	package = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PACKAGE, packageid);
731  	package-&gt;cpuset = package_cpuset;
732  	hwloc_x86_add_cpuinfos(package, &amp;infos[i], 0);
733  	hwloc_debug_1arg_bitmap(&quot;os package %u has cpuset %s\n&quot;,
734  				packageid, package_cpuset);
735  	hwloc__insert_object_by_cpuset(topology, NULL, package, &quot;x86:package&quot;);
736        } else {
737  	hwloc_bitmap_t set = hwloc_bitmap_alloc();
738  	hwloc_bitmap_set(set, i);
739  	package = hwloc_get_next_obj_covering_cpuset_by_type(topology, set, HWLOC_OBJ_PACKAGE, NULL);
740  	hwloc_bitmap_free(set);
741  	if (package) {
742  	  hwloc_x86_add_cpuinfos(package, &amp;infos[i], 1);
743  	  hwloc_bitmap_andnot(remaining_cpuset, remaining_cpuset, package-&gt;cpuset);
744  	} else {
745  	  hwloc_x86_add_cpuinfos(hwloc_get_root_obj(topology), &amp;infos[i], 1);
746  	  break;
747  	}
748        }
749      }
750    }
751    if (fulldiscovery &amp;&amp; (flags &amp; HWLOC_X86_DISC_FLAG_TOPOEXT_NUMANODES)) {
752      hwloc_bitmap_t node_cpuset;
753      hwloc_obj_t node;
754      hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
755      while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
756        unsigned packageid = infos[i].ids[PKG];
757        unsigned nodeid = infos[i].ids[NODE];
758        if (nodeid == (unsigned)-1) {
759          hwloc_bitmap_clr(remaining_cpuset, i);
760  	continue;
761        }
762        node_cpuset = hwloc_bitmap_alloc();
763        for (j = i; j &lt; nbprocs; j++) {
764  	if (infos[j].ids[NODE] == (unsigned) -1) {
765  	  hwloc_bitmap_clr(remaining_cpuset, j);
766  	  continue;
767  	}
768          if (infos[j].ids[PKG] == packageid &amp;&amp; infos[j].ids[NODE] == nodeid) {
769            hwloc_bitmap_set(node_cpuset, j);
770            hwloc_bitmap_clr(remaining_cpuset, j);
771          }
772        }
773        node = hwloc_alloc_setup_object(topology, HWLOC_OBJ_NUMANODE, nodeid);
774        node-&gt;cpuset = node_cpuset;
775        node-&gt;nodeset = hwloc_bitmap_alloc();
776        hwloc_bitmap_set(node-&gt;nodeset, nodeid);
777        hwloc_debug_1arg_bitmap(&quot;os node %u has cpuset %s\n&quot;,
778            nodeid, node_cpuset);
779        hwloc__insert_object_by_cpuset(topology, NULL, node, &quot;x86:numa&quot;);
780        gotnuma++;
781      }
782    }
783    if (hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
784      if (fulldiscovery) {
785        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
786        hwloc_x86_add_groups(topology, infos, nbprocs, remaining_cpuset,
787  			   UNIT, &quot;Compute Unit&quot;,
788  			   HWLOC_GROUP_KIND_AMD_COMPUTE_UNIT, 0);
789        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
790        hwloc_x86_add_groups(topology, infos, nbprocs, remaining_cpuset,
791  			   MODULE, &quot;Module&quot;,
792  			   HWLOC_GROUP_KIND_INTEL_MODULE, 0);
793        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
794        hwloc_x86_add_groups(topology, infos, nbprocs, remaining_cpuset,
795  			   TILE, &quot;Tile&quot;,
796  			   HWLOC_GROUP_KIND_INTEL_TILE, 0);
797        if (infos[one].otherids) {
798  	for (level = infos[one].levels-1; level &lt;= infos[one].levels-1; level--) {
799  	  if (infos[one].otherids[level] != UINT_MAX) {
800  	    hwloc_bitmap_t unknown_cpuset;
801  	    hwloc_obj_t unknown_obj;
802  	    hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
803  	    while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
804  	      unsigned unknownid = infos[i].otherids[level];
805  	      unknown_cpuset = hwloc_bitmap_alloc();
806  	      for (j = i; j &lt; nbprocs; j++) {
807  		if (infos[j].otherids[level] == unknownid) {
808  		  hwloc_bitmap_set(unknown_cpuset, j);
809  		  hwloc_bitmap_clr(remaining_cpuset, j);
810  		}
811  	      }
812  	      unknown_obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, unknownid);
813  	      unknown_obj-&gt;cpuset = unknown_cpuset;
814  	      unknown_obj-&gt;attr-&gt;group.kind = HWLOC_GROUP_KIND_INTEL_EXTTOPOENUM_UNKNOWN;
815  	      unknown_obj-&gt;attr-&gt;group.subkind = level;
816  	      hwloc_debug_2args_bitmap(&quot;os unknown%u %u has cpuset %s\n&quot;,
817  				       level, unknownid, unknown_cpuset);
818  	      hwloc__insert_object_by_cpuset(topology, NULL, unknown_obj, &quot;x86:group:unknown&quot;);
819  	    }
820  	  }
821  	}
822        }
823      }
824    }
825    if (hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_DIE)) {
826      if (fulldiscovery) {
827        hwloc_bitmap_t die_cpuset;
828        hwloc_obj_t die;
829        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
830        while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
831  	unsigned packageid = infos[i].ids[PKG];
832  	unsigned dieid = infos[i].ids[DIE];
833  	if (dieid == (unsigned) -1) {
834  	  hwloc_bitmap_clr(remaining_cpuset, i);
835  	  continue;
836  	}
837  	die_cpuset = hwloc_bitmap_alloc();
838  	for (j = i; j &lt; nbprocs; j++) {
839  	  if (infos[j].ids[DIE] == (unsigned) -1) {
840  	    hwloc_bitmap_clr(remaining_cpuset, j);
841  	    continue;
842  	  }
843  	  if (infos[j].ids[PKG] == packageid &amp;&amp; infos[j].ids[DIE] == dieid) {
844  	    hwloc_bitmap_set(die_cpuset, j);
845  	    hwloc_bitmap_clr(remaining_cpuset, j);
846  	  }
847  	}
848  	die = hwloc_alloc_setup_object(topology, HWLOC_OBJ_DIE, dieid);
849  	die-&gt;cpuset = die_cpuset;
850  	hwloc_debug_1arg_bitmap(&quot;os die %u has cpuset %s\n&quot;,
851  				dieid, die_cpuset);
852  	hwloc__insert_object_by_cpuset(topology, NULL, die, &quot;x86:die&quot;);
853        }
854      }
855    }
856    if (hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_CORE)) {
857      if (fulldiscovery) {
858        hwloc_bitmap_t core_cpuset;
859        hwloc_obj_t core;
860        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
861        while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
862  	unsigned packageid = infos[i].ids[PKG];
863  	unsigned nodeid = infos[i].ids[NODE];
864  	unsigned coreid = infos[i].ids[CORE];
865  	if (coreid == (unsigned) -1) {
866  	  hwloc_bitmap_clr(remaining_cpuset, i);
867  	  continue;
868  	}
869  	core_cpuset = hwloc_bitmap_alloc();
870  	for (j = i; j &lt; nbprocs; j++) {
871  	  if (infos[j].ids[CORE] == (unsigned) -1) {
872  	    hwloc_bitmap_clr(remaining_cpuset, j);
873  	    continue;
874  	  }
875  	  if (infos[j].ids[PKG] == packageid &amp;&amp; infos[j].ids[NODE] == nodeid &amp;&amp; infos[j].ids[CORE] == coreid) {
876  	    hwloc_bitmap_set(core_cpuset, j);
877  	    hwloc_bitmap_clr(remaining_cpuset, j);
878  	  }
879  	}
880  	core = hwloc_alloc_setup_object(topology, HWLOC_OBJ_CORE, coreid);
881  	core-&gt;cpuset = core_cpuset;
882  	hwloc_debug_1arg_bitmap(&quot;os core %u has cpuset %s\n&quot;,
883  				coreid, core_cpuset);
884  	hwloc__insert_object_by_cpuset(topology, NULL, core, &quot;x86:core&quot;);
885        }
886      }
887    }
888    if (fulldiscovery) {
889      hwloc_debug(&quot;%s&quot;, &quot;\n\n * CPU cpusets *\n\n&quot;);
890      for (i=0; i&lt;nbprocs; i++)
891        if(infos[i].present) { &amp;bsol;* Only add present PU. We don&#x27;t know if others actually exist */
892         struct hwloc_obj *obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PU, i);
893         obj-&gt;cpuset = hwloc_bitmap_alloc();
894         hwloc_bitmap_only(obj-&gt;cpuset, i);
895         hwloc_debug_1arg_bitmap(&quot;PU %u has cpuset %s\n&quot;, i, obj-&gt;cpuset);
896         hwloc__insert_object_by_cpuset(topology, NULL, obj, &quot;x86:pu&quot;);
897       }
898    }
899    level = 0;
900    for (i = 0; i &lt; nbprocs; i++)
901      for (j = 0; j &lt; infos[i].numcaches; j++)
902        if (infos[i].cache[j].level &gt; level)
903          level = infos[i].cache[j].level;
904    while (level &gt; 0) {
905      hwloc_obj_cache_type_t type;
906      HWLOC_BUILD_ASSERT(HWLOC_OBJ_CACHE_DATA == HWLOC_OBJ_CACHE_UNIFIED+1);
907      HWLOC_BUILD_ASSERT(HWLOC_OBJ_CACHE_INSTRUCTION == HWLOC_OBJ_CACHE_DATA+1);
908      for (type = HWLOC_OBJ_CACHE_UNIFIED; type &lt;= HWLOC_OBJ_CACHE_INSTRUCTION; type++) {
909        hwloc_obj_type_t otype;
910        hwloc_obj_t cache;
911        otype = hwloc_cache_type_by_depth_type(level, type);
912        if (otype == HWLOC_OBJ_TYPE_NONE)
913  	continue;
914        if (!hwloc_filter_check_keep_object_type(topology, otype))
915  	continue;
916        hwloc_bitmap_copy(remaining_cpuset, complete_cpuset);
917        while ((i = hwloc_bitmap_first(remaining_cpuset)) != (unsigned) -1) {
918  	hwloc_bitmap_t puset;
919  	for (l = 0; l &lt; infos[i].numcaches; l++) {
920  	  if (infos[i].cache[l].level == level &amp;&amp; infos[i].cache[l].type == type)
921  	    break;
922  	}
923  	if (l == infos[i].numcaches) {
924  	  hwloc_bitmap_clr(remaining_cpuset, i);
925  	  continue;
926  	}
927  	puset = hwloc_bitmap_alloc();
928  	hwloc_bitmap_set(puset, i);
929  	cache = hwloc_get_next_obj_covering_cpuset_by_type(topology, puset, otype, NULL);
930  	hwloc_bitmap_free(puset);
931  	if (cache) {
932  	  if (!hwloc_obj_get_info_by_name(cache, &quot;Inclusive&quot;))
933  	    hwloc_obj_add_info(cache, &quot;Inclusive&quot;, infos[i].cache[l].inclusive ? &quot;1&quot; : &quot;0&quot;);
934  	  hwloc_bitmap_andnot(remaining_cpuset, remaining_cpuset, cache-&gt;cpuset);
935  	} else {
936  	  hwloc_bitmap_t cache_cpuset;
937  	  unsigned packageid = infos[i].ids[PKG];
938  	  unsigned cacheid = infos[i].cache[l].cacheid;
939  	  cache_cpuset = hwloc_bitmap_alloc();
940  	  for (j = i; j &lt; nbprocs; j++) {
941  	    unsigned l2;
942  	    for (l2 = 0; l2 &lt; infos[j].numcaches; l2++) {
943  	      if (infos[j].cache[l2].level == level &amp;&amp; infos[j].cache[l2].type == type)
944  		break;
945  	    }
946  	    if (l2 == infos[j].numcaches) {
947  	      hwloc_bitmap_clr(remaining_cpuset, j);
948  	      continue;
949  	    }
950  	    if (infos[j].ids[PKG] == packageid &amp;&amp; infos[j].cache[l2].cacheid == cacheid) {
951  	      hwloc_bitmap_set(cache_cpuset, j);
952  	      hwloc_bitmap_clr(remaining_cpuset, j);
953  	    }
954  	  }
955  	  cache = hwloc_alloc_setup_object(topology, otype, HWLOC_UNKNOWN_INDEX);
956  	  cache-&gt;attr-&gt;cache.depth = level;
957  	  cache-&gt;attr-&gt;cache.size = infos[i].cache[l].size;
958  	  cache-&gt;attr-&gt;cache.linesize = infos[i].cache[l].linesize;
959  	  cache-&gt;attr-&gt;cache.associativity = infos[i].cache[l].ways;
960  	  cache-&gt;attr-&gt;cache.type = infos[i].cache[l].type;
961  	  cache-&gt;cpuset = cache_cpuset;
962  	  hwloc_obj_add_info(cache, &quot;Inclusive&quot;, infos[i].cache[l].inclusive ? &quot;1&quot; : &quot;0&quot;);
963  	  hwloc_debug_2args_bitmap(&quot;os L%u cache %u has cpuset %s\n&quot;,
964  				   level, cacheid, cache_cpuset);
965  	  hwloc__insert_object_by_cpuset(topology, NULL, cache, &quot;x86:cache&quot;);
966  	}
967        }
968      }
969      level--;
970    }
971    hwloc_bitmap_free(remaining_cpuset);
972    hwloc_bitmap_free(complete_cpuset);
973    if (gotnuma)
974      topology-&gt;support.discovery-&gt;numa = 1;
975  }
976  static int
977  look_procs(struct hwloc_backend *backend, struct procinfo *infos, unsigned long flags,
978  	   unsigned highest_cpuid, unsigned highest_ext_cpuid, unsigned *features, enum cpuid_type cpuid_type,
979  	   int (*get_cpubind)(hwloc_topology_t topology, hwloc_cpuset_t set, int flags),
980  	   int (*set_cpubind)(hwloc_topology_t topology, hwloc_const_cpuset_t set, int flags),
981             hwloc_bitmap_t restrict_set)
982  {
983    struct hwloc_x86_backend_data_s *data = backend-&gt;private_data;
984    struct hwloc_topology *topology = backend-&gt;topology;
985    unsigned nbprocs = data-&gt;nbprocs;
986    hwloc_bitmap_t orig_cpuset = NULL;
987    hwloc_bitmap_t set = NULL;
988    unsigned i;
989    if (!data-&gt;src_cpuiddump_path) {
990      orig_cpuset = hwloc_bitmap_alloc();
991      if (get_cpubind(topology, orig_cpuset, HWLOC_CPUBIND_STRICT)) {
992        hwloc_bitmap_free(orig_cpuset);
993        return -1;
994      }
995      set = hwloc_bitmap_alloc();
996    }
997    for (i = 0; i &lt; nbprocs; i++) {
998      struct cpuiddump *src_cpuiddump = NULL;
999      if (restrict_set &amp;&amp; !hwloc_bitmap_isset(restrict_set, i)) {
1000        continue;
1001      }
1002      if (data-&gt;src_cpuiddump_path) {
1003        src_cpuiddump = cpuiddump_read(data-&gt;src_cpuiddump_path, i);
1004        if (!src_cpuiddump)
1005  	continue;
1006      } else {
1007        hwloc_bitmap_only(set, i);
1008        hwloc_debug(&quot;binding to CPU%u\n&quot;, i);
1009        if (set_cpubind(topology, set, HWLOC_CPUBIND_STRICT)) {
1010  	hwloc_debug(&quot;could not bind to CPU%u: %s\n&quot;, i, strerror(errno));
1011  	continue;
1012        }
1013      }
1014      look_proc(backend, &amp;infos[i], flags, highest_cpuid, highest_ext_cpuid, features, cpuid_type, src_cpuiddump);
1015      if (data-&gt;src_cpuiddump_path) {
1016        cpuiddump_free(src_cpuiddump);
1017      }
1018    }
1019    if (!data-&gt;src_cpuiddump_path) {
1020      set_cpubind(topology, orig_cpuset, 0);
1021      hwloc_bitmap_free(set);
1022      hwloc_bitmap_free(orig_cpuset);
1023    }
1024    if (data-&gt;apicid_unique) {
1025      summarize(backend, infos, flags);
1026      if (has_hybrid(features) &amp;&amp; !(topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS)) {
1027        hwloc_bitmap_t atomset = hwloc_bitmap_alloc();
1028        hwloc_bitmap_t coreset = hwloc_bitmap_alloc();
1029        for(i=0; i&lt;nbprocs; i++) {
1030          if (infos[i].hybridcoretype == 0x20)
1031            hwloc_bitmap_set(atomset, i);
1032          else if (infos[i].hybridcoretype == 0x40)
1033            hwloc_bitmap_set(coreset, i);
1034        }
1035        if (!hwloc_bitmap_iszero(atomset)) {
1036          struct hwloc_info_s infoattr;
1037          infoattr.name = (char *) &quot;CoreType&quot;;
1038          infoattr.value = (char *) &quot;IntelAtom&quot;;
1039          hwloc_internal_cpukinds_register(topology, atomset, HWLOC_CPUKIND_EFFICIENCY_UNKNOWN, &amp;infoattr, 1, 0);
1040        } else {
1041          hwloc_bitmap_free(atomset);
1042        }
1043        if (!hwloc_bitmap_iszero(coreset)) {
1044          struct hwloc_info_s infoattr;
1045          infoattr.name = (char *) &quot;CoreType&quot;;
1046          infoattr.value = (char *) &quot;IntelCore&quot;;
1047          hwloc_internal_cpukinds_register(topology, coreset, HWLOC_CPUKIND_EFFICIENCY_UNKNOWN, &amp;infoattr, 1, 0);
1048        } else {
1049          hwloc_bitmap_free(coreset);
1050        }
1051      }
1052    }
1053    return 0;
1054  }
1055  #if defined HWLOC_FREEBSD_SYS &amp;&amp; defined HAVE_CPUSET_SETID
1056  #include &lt;sys/param.h&gt;
1057  #include &lt;sys/cpuset.h&gt;
1058  typedef cpusetid_t hwloc_x86_os_state_t;
1059  static void hwloc_x86_os_state_save(hwloc_x86_os_state_t *state, struct cpuiddump *src_cpuiddump)
1060  {
1061    if (!src_cpuiddump) {
1062      cpuset_getid(CPU_LEVEL_CPUSET, CPU_WHICH_PID, -1, state);
1063      cpuset_setid(CPU_WHICH_PID, -1, 0);
1064    }
1065  }
1066  static void hwloc_x86_os_state_restore(hwloc_x86_os_state_t *state, struct cpuiddump *src_cpuiddump)
1067  {
1068    if (!src_cpuiddump) {
1069      cpuset_setid(CPU_WHICH_PID, -1, *state);
1070    }
1071  }
1072  #else &amp;bsol;* !defined HWLOC_FREEBSD_SYS || !defined HAVE_CPUSET_SETID */
1073  typedef void * hwloc_x86_os_state_t;
1074  static void hwloc_x86_os_state_save(hwloc_x86_os_state_t *state __hwloc_attribute_unused, struct cpuiddump *src_cpuiddump __hwloc_attribute_unused) { }
1075  static void hwloc_x86_os_state_restore(hwloc_x86_os_state_t *state __hwloc_attribute_unused, struct cpuiddump *src_cpuiddump __hwloc_attribute_unused) { }
1076  #endif &amp;bsol;* !defined HWLOC_FREEBSD_SYS || !defined HAVE_CPUSET_SETID */
1077  #define INTEL_EBX (&#x27;G&#x27; | (&#x27;e&#x27;&lt;&lt;8) | (&#x27;n&#x27;&lt;&lt;16) | (&#x27;u&#x27;&lt;&lt;24))
1078  #define INTEL_EDX (&#x27;i&#x27; | (&#x27;n&#x27;&lt;&lt;8) | (&#x27;e&#x27;&lt;&lt;16) | (&#x27;I&#x27;&lt;&lt;24))
1079  #define INTEL_ECX (&#x27;n&#x27; | (&#x27;t&#x27;&lt;&lt;8) | (&#x27;e&#x27;&lt;&lt;16) | (&#x27;l&#x27;&lt;&lt;24))
1080  #define AMD_EBX (&#x27;A&#x27; | (&#x27;u&#x27;&lt;&lt;8) | (&#x27;t&#x27;&lt;&lt;16) | (&#x27;h&#x27;&lt;&lt;24))
1081  #define AMD_EDX (&#x27;e&#x27; | (&#x27;n&#x27;&lt;&lt;8) | (&#x27;t&#x27;&lt;&lt;16) | (&#x27;i&#x27;&lt;&lt;24))
1082  #define AMD_ECX (&#x27;c&#x27; | (&#x27;A&#x27;&lt;&lt;8) | (&#x27;M&#x27;&lt;&lt;16) | (&#x27;D&#x27;&lt;&lt;24))
1083  #define HYGON_EBX (&#x27;H&#x27; | (&#x27;y&#x27;&lt;&lt;8) | (&#x27;g&#x27;&lt;&lt;16) | (&#x27;o&#x27;&lt;&lt;24))
1084  #define HYGON_EDX (&#x27;n&#x27; | (&#x27;G&#x27;&lt;&lt;8) | (&#x27;e&#x27;&lt;&lt;16) | (&#x27;n&#x27;&lt;&lt;24))
1085  #define HYGON_ECX (&#x27;u&#x27; | (&#x27;i&#x27;&lt;&lt;8) | (&#x27;n&#x27;&lt;&lt;16) | (&#x27;e&#x27;&lt;&lt;24))
1086  #define ZX_EBX (&#x27;C&#x27; | (&#x27;e&#x27;&lt;&lt;8) | (&#x27;n&#x27;&lt;&lt;16) | (&#x27;t&#x27;&lt;&lt;24))
1087  #define ZX_EDX (&#x27;a&#x27; | (&#x27;u&#x27;&lt;&lt;8) | (&#x27;r&#x27;&lt;&lt;16) | (&#x27;H&#x27;&lt;&lt;24))
1088  #define ZX_ECX (&#x27;a&#x27; | (&#x27;u&#x27;&lt;&lt;8) | (&#x27;l&#x27;&lt;&lt;16) | (&#x27;s&#x27;&lt;&lt;24))
1089  #define SH_EBX (&#x27; &#x27; | (&#x27; &#x27;&lt;&lt;8) | (&#x27;S&#x27;&lt;&lt;16) | (&#x27;h&#x27;&lt;&lt;24))
1090  #define SH_EDX (&#x27;a&#x27; | (&#x27;n&#x27;&lt;&lt;8) | (&#x27;g&#x27;&lt;&lt;16) | (&#x27;h&#x27;&lt;&lt;24))
1091  #define SH_ECX (&#x27;a&#x27; | (&#x27;i&#x27;&lt;&lt;8) | (&#x27; &#x27;&lt;&lt;16) | (&#x27; &#x27;&lt;&lt;24))
1092  static int fake_get_cpubind(hwloc_topology_t topology __hwloc_attribute_unused,
1093  			    hwloc_cpuset_t set __hwloc_attribute_unused,
1094  			    int flags __hwloc_attribute_unused)
1095  {
1096    return 0;
1097  }
1098  static int fake_set_cpubind(hwloc_topology_t topology __hwloc_attribute_unused,
1099  			    hwloc_const_cpuset_t set __hwloc_attribute_unused,
1100  			    int flags __hwloc_attribute_unused)
1101  {
1102    return 0;
1103  }
1104  static
1105  int hwloc_look_x86(struct hwloc_backend *backend, unsigned long flags)
1106  {
1107    struct hwloc_x86_backend_data_s *data = backend-&gt;private_data;
1108    struct hwloc_topology *topology = backend-&gt;topology;
1109    unsigned nbprocs = data-&gt;nbprocs;
1110    unsigned eax, ebx, ecx = 0, edx;
1111    unsigned i;
1112    unsigned highest_cpuid;
1113    unsigned highest_ext_cpuid;
1114    unsigned features[19] = { 0 };
1115    struct procinfo *infos = NULL;
1116    enum cpuid_type cpuid_type = unknown;
1117    hwloc_x86_os_state_t os_state;
1118    struct hwloc_binding_hooks hooks;
1119    struct hwloc_topology_support support;
1120    struct hwloc_topology_membind_support memsupport __hwloc_attribute_unused;
1121    int (*get_cpubind)(hwloc_topology_t topology, hwloc_cpuset_t set, int flags) = NULL;
1122    int (*set_cpubind)(hwloc_topology_t topology, hwloc_const_cpuset_t set, int flags) = NULL;
1123    hwloc_bitmap_t restrict_set = NULL;
1124    struct cpuiddump *src_cpuiddump = NULL;
1125    int ret = -1;
1126    memset(&amp;hooks, 0, sizeof(hooks));
1127    support.membind = &amp;memsupport;
1128    hwloc_set_native_binding_hooks(&amp;hooks, &amp;support);
1129    if (data-&gt;src_cpuiddump_path) {
1130      src_cpuiddump = cpuiddump_read(data-&gt;src_cpuiddump_path, 0);
1131      if (!src_cpuiddump)
1132        goto out;
1133    } else {
1134      if (hooks.get_thisthread_cpubind &amp;&amp; hooks.set_thisthread_cpubind) {
1135        get_cpubind = hooks.get_thisthread_cpubind;
1136        set_cpubind = hooks.set_thisthread_cpubind;
1137      } else if (hooks.get_thisproc_cpubind &amp;&amp; hooks.set_thisproc_cpubind) {
1138        get_cpubind = hooks.get_thisproc_cpubind;
1139        set_cpubind = hooks.set_thisproc_cpubind;
1140      } else {
1141        if (nbprocs &gt; 1)
1142  	goto out;
1143        get_cpubind = fake_get_cpubind;
1144        set_cpubind = fake_set_cpubind;
1145      }
1146    }
1147    if (topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING) {
1148      restrict_set = hwloc_bitmap_alloc();
1149      if (!restrict_set)
1150        goto out;
1151      if (hooks.get_thisproc_cpubind)
1152        hooks.get_thisproc_cpubind(topology, restrict_set, 0);
1153      else if (hooks.get_thisthread_cpubind)
1154        hooks.get_thisthread_cpubind(topology, restrict_set, 0);
1155      if (hwloc_bitmap_iszero(restrict_set)) {
1156        hwloc_bitmap_free(restrict_set);
1157        restrict_set = NULL;
1158      }
1159    }
1160    if (!src_cpuiddump &amp;&amp; !hwloc_have_x86_cpuid())
1161      goto out;
1162    infos = calloc(nbprocs, sizeof(struct procinfo));
1163    if (NULL == infos)
1164      goto out;
1165    for (i = 0; i &lt; nbprocs; i++) {
1166      infos[i].ids[PKG] = (unsigned) -1;
1167      infos[i].ids[CORE] = (unsigned) -1;
1168      infos[i].ids[NODE] = (unsigned) -1;
1169      infos[i].ids[UNIT] = (unsigned) -1;
1170      infos[i].ids[TILE] = (unsigned) -1;
1171      infos[i].ids[MODULE] = (unsigned) -1;
1172      infos[i].ids[DIE] = (unsigned) -1;
1173    }
1174    eax = 0x00;
1175    cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
1176    highest_cpuid = eax;
1177    if (ebx == INTEL_EBX &amp;&amp; ecx == INTEL_ECX &amp;&amp; edx == INTEL_EDX)
1178      cpuid_type = intel;
1179    else if (ebx == AMD_EBX &amp;&amp; ecx == AMD_ECX &amp;&amp; edx == AMD_EDX)
1180      cpuid_type = amd;
1181    else if ((ebx == ZX_EBX &amp;&amp; ecx == ZX_ECX &amp;&amp; edx == ZX_EDX)
1182  	   || (ebx == SH_EBX &amp;&amp; ecx == SH_ECX &amp;&amp; edx == SH_EDX))
1183      cpuid_type = zhaoxin;
1184    else if (ebx == HYGON_EBX &amp;&amp; ecx == HYGON_ECX &amp;&amp; edx == HYGON_EDX)
1185      cpuid_type = hygon;
1186    hwloc_debug(&quot;highest cpuid %x, cpuid type %u\n&quot;, highest_cpuid, cpuid_type);
1187    if (highest_cpuid &lt; 0x01) {
1188        goto out_with_infos;
1189    }
1190    eax = 0x01;
1191    cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
1192    features[0] = edx;
1193    features[4] = ecx;
1194    eax = 0x80000000;
1195    cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
1196    highest_ext_cpuid = eax;
1197    hwloc_debug(&quot;highest extended cpuid %x\n&quot;, highest_ext_cpuid);
1198    if (highest_cpuid &gt;= 0x7) {
1199      eax = 0x7;
1200      ecx = 0;
1201      cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
1202      features[9] = ebx;
1203      features[18] = edx;
1204    }
1205    if (cpuid_type != intel &amp;&amp; highest_ext_cpuid &gt;= 0x80000001) {
1206      eax = 0x80000001;
1207      cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
1208      features[1] = edx;
1209      features[6] = ecx;
1210    }
1211    hwloc_x86_os_state_save(&amp;os_state, src_cpuiddump);
1212    ret = look_procs(backend, infos, flags,
1213  		   highest_cpuid, highest_ext_cpuid, features, cpuid_type,
1214  		   get_cpubind, set_cpubind, restrict_set);
1215    if (!ret)
1216      goto out_with_os_state;
1217    if (nbprocs == 1) {
1218      look_proc(backend, &amp;infos[0], flags, highest_cpuid, highest_ext_cpuid, features, cpuid_type, src_cpuiddump);
1219      summarize(backend, infos, flags);
1220      ret = 0;
1221    }
1222  out_with_os_state:
1223    hwloc_x86_os_state_restore(&amp;os_state, src_cpuiddump);
1224  out_with_infos:
1225    if (NULL != infos) {
1226      for (i = 0; i &lt; nbprocs; i++) {
1227        free(infos[i].cache);
1228        free(infos[i].otherids);
1229      }
1230      free(infos);
1231    }
1232  out:
1233    hwloc_bitmap_free(restrict_set);
1234    if (src_cpuiddump)
1235      cpuiddump_free(src_cpuiddump);
1236    return ret;
1237  }
1238  static int
1239  hwloc_x86_discover(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
1240  {
1241    struct hwloc_x86_backend_data_s *data = backend-&gt;private_data;
1242    struct hwloc_topology *topology = backend-&gt;topology;
1243    unsigned long flags = 0;
1244    int alreadypus = 0;
1245    int ret;
1246    assert(dstatus-&gt;phase == HWLOC_DISC_PHASE_CPU);
1247    if (topology-&gt;flags &amp; HWLOC_TOPOLOGY_FLAG_DONT_CHANGE_BINDING) {
1248      return 0;
1249    }
1250    if (getenv(&quot;HWLOC_X86_TOPOEXT_NUMANODES&quot;)) {
1251      flags |= HWLOC_X86_DISC_FLAG_TOPOEXT_NUMANODES;
1252    }
1253  #if HAVE_DECL_RUNNING_ON_VALGRIND
1254    if (RUNNING_ON_VALGRIND &amp;&amp; !data-&gt;src_cpuiddump_path) {
1255      fprintf(stderr, &quot;hwloc x86 backend cannot work under Valgrind, disabling.\n&quot;
1256  	    &quot;May be reenabled by dumping CPUIDs with hwloc-gather-cpuid\n&quot;
1257  	    &quot;and reloading them under Valgrind with HWLOC_CPUID_PATH.\n&quot;);
1258      return 0;
1259    }
1260  #endif
1261    if (data-&gt;src_cpuiddump_path) {
1262      assert(data-&gt;nbprocs &gt; 0); &amp;bsol;* enforced by hwloc_x86_component_instantiate() */
1263      topology-&gt;support.discovery-&gt;pu = 1;
1264    } else {
1265      int nbprocs = hwloc_fallback_nbprocessors(HWLOC_FALLBACK_NBPROCESSORS_INCLUDE_OFFLINE);
1266      if (nbprocs &gt;= 1)
1267        topology-&gt;support.discovery-&gt;pu = 1;
1268      else
1269        nbprocs = 1;
1270      data-&gt;nbprocs = (unsigned) nbprocs;
1271    }
1272    if (topology-&gt;levels[0][0]-&gt;cpuset) {
1273      hwloc_topology_reconnect(topology, 0);
1274      if (topology-&gt;nb_levels == 2 &amp;&amp; topology-&gt;level_nbobjects[1] == data-&gt;nbprocs) {
1275        alreadypus = 1;
1276        goto fulldiscovery;
1277      }
1278      ret = hwloc_look_x86(backend, flags);
1279      if (ret)
1280        hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;Backend&quot;, &quot;x86&quot;);
1281      return 0;
1282    } else {
1283      hwloc_alloc_root_sets(topology-&gt;levels[0][0]);
1284    }
1285  fulldiscovery:
1286    if (hwloc_look_x86(backend, flags | HWLOC_X86_DISC_FLAG_FULL) &lt; 0) {
1287      if (!alreadypus)
1288        hwloc_setup_pu_level(topology, data-&gt;nbprocs);
1289    }
1290    hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;Backend&quot;, &quot;x86&quot;);
1291    if (!data-&gt;src_cpuiddump_path) { &amp;bsol;* CPUID dump works for both x86 and x86_64 */
1292  #ifdef HAVE_UNAME
1293      hwloc_add_uname_info(topology, NULL); &amp;bsol;* we already know is_thissystem() is true */
1294  #else
1295  #ifdef HWLOC_X86_64_ARCH
1296      hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;Architecture&quot;, &quot;x86_64&quot;);
1297  #else
1298      hwloc_obj_add_info(topology-&gt;levels[0][0], &quot;Architecture&quot;, &quot;x86&quot;);
1299  #endif
1300  #endif
1301    }
1302    return 1;
1303  }
1304  static int
1305  hwloc_x86_check_cpuiddump_input(const char *src_cpuiddump_path, hwloc_bitmap_t set)
1306  {
1307  #if !(defined HWLOC_WIN_SYS &amp;&amp; !defined __MINGW32__ &amp;&amp; !defined __CYGWIN__) &amp;bsol;* needs a lot of work */
1308    struct dirent *dirent;
1309    DIR *dir;
1310    char *path;
1311    FILE *file;
1312    char line [32];
1313    dir = opendir(src_cpuiddump_path);
1314    if (!dir) 
1315      return -1;
1316    path = malloc(strlen(src_cpuiddump_path) + strlen(&quot;/hwloc-cpuid-info&quot;) + 1);
1317    if (!path)
1318      goto out_with_dir;
1319    sprintf(path, &quot;%s/hwloc-cpuid-info&quot;, src_cpuiddump_path);
1320    file = fopen(path, &quot;r&quot;);
1321    if (!file) {
1322      fprintf(stderr, &quot;Couldn&#x27;t open dumped cpuid summary %s\n&quot;, path);
1323      goto out_with_path;
1324    }
1325    if (!fgets(line, sizeof(line), file)) {
1326      fprintf(stderr, &quot;Found read dumped cpuid summary in %s\n&quot;, path);
1327      fclose(file);
1328      goto out_with_path;
1329    }
1330    fclose(file);
1331    if (strcmp(line, &quot;Architecture: x86\n&quot;)) {
1332      fprintf(stderr, &quot;Found non-x86 dumped cpuid summary in %s: %s\n&quot;, path, line);
1333      goto out_with_path;
1334    }
1335    free(path);
1336    while ((dirent = readdir(dir)) != NULL) {
1337      if (!strncmp(dirent-&gt;d_name, &quot;pu&quot;, 2)) {
1338        char *end;
1339        unsigned long idx = strtoul(dirent-&gt;d_name+2, &amp;end, 10);
1340        if (!*end)
1341  	hwloc_bitmap_set(set, idx);
1342        else
1343  	fprintf(stderr, &quot;Ignoring invalid dirent `%s&#x27; in dumped cpuid directory `%s&#x27;\n&quot;,
1344  		dirent-&gt;d_name, src_cpuiddump_path);
1345      }
1346    }
1347    closedir(dir);
1348    if (hwloc_bitmap_iszero(set)) {
1349      fprintf(stderr, &quot;Did not find any valid pu%%u entry in dumped cpuid directory `%s&#x27;\n&quot;,
1350  	    src_cpuiddump_path);
1351      return -1;
1352    } else if (hwloc_bitmap_last(set) != hwloc_bitmap_weight(set) - 1) {
1353      fprintf(stderr, &quot;Found non-contigous pu%%u range in dumped cpuid directory `%s&#x27;\n&quot;,
1354  	    src_cpuiddump_path);
1355      return -1;
1356    }
1357    return 0;
1358   out_with_path:
1359    free(path);
1360   out_with_dir:
1361    closedir(dir);
1362  #endif &amp;bsol;* HWLOC_WIN_SYS &amp; !__MINGW32__ needs a lot of work */
1363    return -1;
1364  }
1365  static void
1366  hwloc_x86_backend_disable(struct hwloc_backend *backend)
1367  {
1368    struct hwloc_x86_backend_data_s *data = backend-&gt;private_data;
1369    hwloc_bitmap_free(data-&gt;apicid_set);
1370    free(data-&gt;src_cpuiddump_path);
1371    free(data);
1372  }
1373  static struct hwloc_backend *
1374  hwloc_x86_component_instantiate(struct hwloc_topology *topology,
1375  				struct hwloc_disc_component *component,
1376  				unsigned excluded_phases __hwloc_attribute_unused,
1377  				const void *_data1 __hwloc_attribute_unused,
1378  				const void *_data2 __hwloc_attribute_unused,
1379  				const void *_data3 __hwloc_attribute_unused)
1380  {
1381    struct hwloc_backend *backend;
1382    struct hwloc_x86_backend_data_s *data;
1383    const char *src_cpuiddump_path;
1384    backend = hwloc_backend_alloc(topology, component);
1385    if (!backend)
1386      goto out;
1387    data = malloc(sizeof(*data));
1388    if (!data) {
1389      errno = ENOMEM;
1390      goto out_with_backend;
1391    }
1392    backend-&gt;private_data = data;
1393    backend-&gt;discover = hwloc_x86_discover;
1394    backend-&gt;disable = hwloc_x86_backend_disable;
1395    data-&gt;is_knl = 0;
1396    data-&gt;apicid_set = hwloc_bitmap_alloc();
1397    data-&gt;apicid_unique = 1;
1398    data-&gt;src_cpuiddump_path = NULL;
1399    src_cpuiddump_path = getenv(&quot;HWLOC_CPUID_PATH&quot;);
1400    if (src_cpuiddump_path) {
1401      hwloc_bitmap_t set = hwloc_bitmap_alloc();
1402      if (!hwloc_x86_check_cpuiddump_input(src_cpuiddump_path, set)) {
1403        backend-&gt;is_thissystem = 0;
1404        data-&gt;src_cpuiddump_path = strdup(src_cpuiddump_path);
1405        assert(!hwloc_bitmap_iszero(set)); &amp;bsol;* enforced by hwloc_x86_check_cpuiddump_input() */
1406        data-&gt;nbprocs = hwloc_bitmap_weight(set);
1407      } else {
1408        fprintf(stderr, &quot;Ignoring dumped cpuid directory.\n&quot;);
1409      }
1410      hwloc_bitmap_free(set);
1411    }
1412    return backend;
1413   out_with_backend:
1414    free(backend);
1415   out:
1416    return NULL;
1417  }
1418  static struct hwloc_disc_component hwloc_x86_disc_component = {
1419    &quot;x86&quot;,
1420    HWLOC_DISC_PHASE_CPU,
1421    HWLOC_DISC_PHASE_GLOBAL,
1422    hwloc_x86_component_instantiate,
1423    45, &amp;bsol;* between native and no_os */
1424    1,
1425    NULL
1426  };
1427  const struct hwloc_component hwloc_x86_component = {
1428    HWLOC_COMPONENT_ABI,
1429    NULL, NULL,
1430    HWLOC_COMPONENT_TYPE_DISC,
1431    0,
1432    &amp;hwloc_x86_disc_component
1433  };
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_sse2.c</h3>
            <pre><code>1  #include &quot;src/dsp/yuv.h&quot;
2  #if defined(WEBP_USE_SSE2)
3  #include &quot;src/dsp/common_sse2.h&quot;
4  #include &lt;stdlib.h&gt;
5  #include &lt;emmintrin.h&gt;
6  static void ConvertYUV444ToRGB_SSE2(const __m128i* const Y0,
7                                      const __m128i* const U0,
8                                      const __m128i* const V0,
9                                      __m128i* const R,
10                                      __m128i* const G,
11                                      __m128i* const B) {
12    const __m128i k19077 = _mm_set1_epi16(19077);
13    const __m128i k26149 = _mm_set1_epi16(26149);
14    const __m128i k14234 = _mm_set1_epi16(14234);
15    const __m128i k33050 = _mm_set1_epi16((short)33050);
16    const __m128i k17685 = _mm_set1_epi16(17685);
17    const __m128i k6419  = _mm_set1_epi16(6419);
18    const __m128i k13320 = _mm_set1_epi16(13320);
19    const __m128i k8708  = _mm_set1_epi16(8708);
20    const __m128i Y1 = _mm_mulhi_epu16(*Y0, k19077);
21    const __m128i R0 = _mm_mulhi_epu16(*V0, k26149);
22    const __m128i R1 = _mm_sub_epi16(Y1, k14234);
23    const __m128i R2 = _mm_add_epi16(R1, R0);
24    const __m128i G0 = _mm_mulhi_epu16(*U0, k6419);
25    const __m128i G1 = _mm_mulhi_epu16(*V0, k13320);
26    const __m128i G2 = _mm_add_epi16(Y1, k8708);
27    const __m128i G3 = _mm_add_epi16(G0, G1);
28    const __m128i G4 = _mm_sub_epi16(G2, G3);
29    const __m128i B0 = _mm_mulhi_epu16(*U0, k33050);
30    const __m128i B1 = _mm_adds_epu16(B0, Y1);
31    const __m128i B2 = _mm_subs_epu16(B1, k17685);
32    *R = _mm_srai_epi16(R2, 6);   
33    *G = _mm_srai_epi16(G4, 6);   
34    *B = _mm_srli_epi16(B2, 6);   
35  }
36  static WEBP_INLINE __m128i Load_HI_16_SSE2(const uint8_t* src) {
37    const __m128i zero = _mm_setzero_si128();
38    return _mm_unpacklo_epi8(zero, _mm_loadl_epi64((const __m128i*)src));
39  }
40  static WEBP_INLINE __m128i Load_UV_HI_8_SSE2(const uint8_t* src) {
41    const __m128i zero = _mm_setzero_si128();
42    const __m128i tmp0 = _mm_cvtsi32_si128(*(const uint32_t*)src);
43    const __m128i tmp1 = _mm_unpacklo_epi8(zero, tmp0);
44    return _mm_unpacklo_epi16(tmp1, tmp1);   
45  }
46  static void YUV444ToRGB_SSE2(const uint8_t* const y,
47                               const uint8_t* const u,
48                               const uint8_t* const v,
49                               __m128i* const R, __m128i* const G,
50                               __m128i* const B) {
51    const __m128i Y0 = Load_HI_16_SSE2(y), U0 = Load_HI_16_SSE2(u),
52                  V0 = Load_HI_16_SSE2(v);
53    ConvertYUV444ToRGB_SSE2(&amp;Y0, &amp;U0, &amp;V0, R, G, B);
54  }
55  static void YUV420ToRGB_SSE2(const uint8_t* const y,
56                               const uint8_t* const u,
57                               const uint8_t* const v,
58                               __m128i* const R, __m128i* const G,
59                               __m128i* const B) {
60    const __m128i Y0 = Load_HI_16_SSE2(y), U0 = Load_UV_HI_8_SSE2(u),
61                  V0 = Load_UV_HI_8_SSE2(v);
62    ConvertYUV444ToRGB_SSE2(&amp;Y0, &amp;U0, &amp;V0, R, G, B);
63  }
64  static WEBP_INLINE void PackAndStore4_SSE2(const __m128i* const R,
65                                             const __m128i* const G,
66                                             const __m128i* const B,
67                                             const __m128i* const A,
68                                             uint8_t* const dst) {
69    const __m128i rb = _mm_packus_epi16(*R, *B);
70    const __m128i ga = _mm_packus_epi16(*G, *A);
71    const __m128i rg = _mm_unpacklo_epi8(rb, ga);
72    const __m128i ba = _mm_unpackhi_epi8(rb, ga);
73    const __m128i RGBA_lo = _mm_unpacklo_epi16(rg, ba);
74    const __m128i RGBA_hi = _mm_unpackhi_epi16(rg, ba);
75    _mm_storeu_si128((__m128i*)(dst +  0), RGBA_lo);
76    _mm_storeu_si128((__m128i*)(dst + 16), RGBA_hi);
77  }
78  static WEBP_INLINE void PackAndStore4444_SSE2(const __m128i* const R,
79                                                const __m128i* const G,
80                                                const __m128i* const B,
81                                                const __m128i* const A,
82                                                uint8_t* const dst) {
83  #if (WEBP_SWAP_16BIT_CSP == 0)
84    const __m128i rg0 = _mm_packus_epi16(*R, *G);
85    const __m128i ba0 = _mm_packus_epi16(*B, *A);
86  #else
87    const __m128i rg0 = _mm_packus_epi16(*B, *A);
88    const __m128i ba0 = _mm_packus_epi16(*R, *G);
89  #endif
90    const __m128i mask_0xf0 = _mm_set1_epi8(0xf0);
91    const __m128i rb1 = _mm_unpacklo_epi8(rg0, ba0);  
92    const __m128i ga1 = _mm_unpackhi_epi8(rg0, ba0);  
93    const __m128i rb2 = _mm_and_si128(rb1, mask_0xf0);
94    const __m128i ga2 = _mm_srli_epi16(_mm_and_si128(ga1, mask_0xf0), 4);
95    const __m128i rgba4444 = _mm_or_si128(rb2, ga2);
96    _mm_storeu_si128((__m128i*)dst, rgba4444);
97  }
98  static WEBP_INLINE void PackAndStore565_SSE2(const __m128i* const R,
99                                               const __m128i* const G,
100                                               const __m128i* const B,
101                                               uint8_t* const dst) {
102    const __m128i r0 = _mm_packus_epi16(*R, *R);
103    const __m128i g0 = _mm_packus_epi16(*G, *G);
104    const __m128i b0 = _mm_packus_epi16(*B, *B);
105    const __m128i r1 = _mm_and_si128(r0, _mm_set1_epi8(0xf8));
106    const __m128i b1 = _mm_and_si128(_mm_srli_epi16(b0, 3), _mm_set1_epi8(0x1f));
107    const __m128i g1 = _mm_srli_epi16(_mm_and_si128(g0, _mm_set1_epi8(0xe0)), 5);
108    const __m128i g2 = _mm_slli_epi16(_mm_and_si128(g0, _mm_set1_epi8(0x1c)), 3);
109    const __m128i rg = _mm_or_si128(r1, g1);
110    const __m128i gb = _mm_or_si128(g2, b1);
111  #if (WEBP_SWAP_16BIT_CSP == 0)
112    const __m128i rgb565 = _mm_unpacklo_epi8(rg, gb);
113  #else
114    const __m128i rgb565 = _mm_unpacklo_epi8(gb, rg);
115  #endif
116    _mm_storeu_si128((__m128i*)dst, rgb565);
117  }
118  static WEBP_INLINE void PlanarTo24b_SSE2(__m128i* const in0, __m128i* const in1,
119                                           __m128i* const in2, __m128i* const in3,
120                                           __m128i* const in4, __m128i* const in5,
121                                           uint8_t* const rgb) {
122    VP8PlanarTo24b_SSE2(in0, in1, in2, in3, in4, in5);
123    _mm_storeu_si128((__m128i*)(rgb +  0), *in0);
124    _mm_storeu_si128((__m128i*)(rgb + 16), *in1);
125    _mm_storeu_si128((__m128i*)(rgb + 32), *in2);
126    _mm_storeu_si128((__m128i*)(rgb + 48), *in3);
127    _mm_storeu_si128((__m128i*)(rgb + 64), *in4);
128    _mm_storeu_si128((__m128i*)(rgb + 80), *in5);
129  }
130  void VP8YuvToRgba32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
131                           uint8_t* dst) {
132    const __m128i kAlpha = _mm_set1_epi16(255);
133    int n;
134    for (n = 0; n &lt; 32; n += 8, dst += 32) {
135      __m128i R, G, B;
136      YUV444ToRGB_SSE2(y + n, u + n, v + n, &amp;R, &amp;G, &amp;B);
137      PackAndStore4_SSE2(&amp;R, &amp;G, &amp;B, &amp;kAlpha, dst);
138    }
139  }
140  void VP8YuvToBgra32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
141                           uint8_t* dst) {
142    const __m128i kAlpha = _mm_set1_epi16(255);
143    int n;
144    for (n = 0; n &lt; 32; n += 8, dst += 32) {
145      __m128i R, G, B;
146      YUV444ToRGB_SSE2(y + n, u + n, v + n, &amp;R, &amp;G, &amp;B);
147      PackAndStore4_SSE2(&amp;B, &amp;G, &amp;R, &amp;kAlpha, dst);
148    }
149  }
150  void VP8YuvToArgb32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
151                           uint8_t* dst) {
152    const __m128i kAlpha = _mm_set1_epi16(255);
153    int n;
154    for (n = 0; n &lt; 32; n += 8, dst += 32) {
155      __m128i R, G, B;
156      YUV444ToRGB_SSE2(y + n, u + n, v + n, &amp;R, &amp;G, &amp;B);
<span onclick='openModal()' class='match'>157      PackAndStore4_SSE2(&amp;kAlpha, &amp;R, &amp;G, &amp;B, dst);
158    }
</span>159  }
160  void VP8YuvToRgba444432_SSE2(const uint8_t* y, const uint8_t* u,
161                               const uint8_t* v, uint8_t* dst) {
162    const __m128i kAlpha = _mm_set1_epi16(255);
163    int n;
164    for (n = 0; n &lt; 32; n += 8, dst += 16) {
165      __m128i R, G, B;
166      YUV444ToRGB_SSE2(y + n, u + n, v + n, &amp;R, &amp;G, &amp;B);
167      PackAndStore4444_SSE2(&amp;R, &amp;G, &amp;B, &amp;kAlpha, dst);
168    }
169  }
170  void VP8YuvToRgb56532_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
171                             uint8_t* dst) {
172    int n;
173    for (n = 0; n &lt; 32; n += 8, dst += 16) {
174      __m128i R, G, B;
175      YUV444ToRGB_SSE2(y + n, u + n, v + n, &amp;R, &amp;G, &amp;B);
176      PackAndStore565_SSE2(&amp;R, &amp;G, &amp;B, dst);
177    }
178  }
179  void VP8YuvToRgb32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
180                          uint8_t* dst) {
181    __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
182    __m128i rgb0, rgb1, rgb2, rgb3, rgb4, rgb5;
183    YUV444ToRGB_SSE2(y + 0, u + 0, v + 0, &amp;R0, &amp;G0, &amp;B0);
184    YUV444ToRGB_SSE2(y + 8, u + 8, v + 8, &amp;R1, &amp;G1, &amp;B1);
185    YUV444ToRGB_SSE2(y + 16, u + 16, v + 16, &amp;R2, &amp;G2, &amp;B2);
186    YUV444ToRGB_SSE2(y + 24, u + 24, v + 24, &amp;R3, &amp;G3, &amp;B3);
187    rgb0 = _mm_packus_epi16(R0, R1);
188    rgb1 = _mm_packus_epi16(R2, R3);
189    rgb2 = _mm_packus_epi16(G0, G1);
190    rgb3 = _mm_packus_epi16(G2, G3);
191    rgb4 = _mm_packus_epi16(B0, B1);
192    rgb5 = _mm_packus_epi16(B2, B3);
193    PlanarTo24b_SSE2(&amp;rgb0, &amp;rgb1, &amp;rgb2, &amp;rgb3, &amp;rgb4, &amp;rgb5, dst);
194  }
195  void VP8YuvToBgr32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
196                          uint8_t* dst) {
197    __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
198    __m128i bgr0, bgr1, bgr2, bgr3, bgr4, bgr5;
199    YUV444ToRGB_SSE2(y +  0, u +  0, v +  0, &amp;R0, &amp;G0, &amp;B0);
200    YUV444ToRGB_SSE2(y +  8, u +  8, v +  8, &amp;R1, &amp;G1, &amp;B1);
201    YUV444ToRGB_SSE2(y + 16, u + 16, v + 16, &amp;R2, &amp;G2, &amp;B2);
202    YUV444ToRGB_SSE2(y + 24, u + 24, v + 24, &amp;R3, &amp;G3, &amp;B3);
203    bgr0 = _mm_packus_epi16(B0, B1);
204    bgr1 = _mm_packus_epi16(B2, B3);
205    bgr2 = _mm_packus_epi16(G0, G1);
206    bgr3 = _mm_packus_epi16(G2, G3);
207    bgr4 = _mm_packus_epi16(R0, R1);
208    bgr5= _mm_packus_epi16(R2, R3);
209    PlanarTo24b_SSE2(&amp;bgr0, &amp;bgr1, &amp;bgr2, &amp;bgr3, &amp;bgr4, &amp;bgr5, dst);
210  }
211  static void YuvToRgbaRow_SSE2(const uint8_t* y,
212                                const uint8_t* u, const uint8_t* v,
213                                uint8_t* dst, int len) {
214    const __m128i kAlpha = _mm_set1_epi16(255);
215    int n;
216    for (n = 0; n + 8 &lt;= len; n += 8, dst += 32) {
217      __m128i R, G, B;
218      YUV420ToRGB_SSE2(y, u, v, &amp;R, &amp;G, &amp;B);
219      PackAndStore4_SSE2(&amp;R, &amp;G, &amp;B, &amp;kAlpha, dst);
220      y += 8;
221      u += 4;
222      v += 4;
223    }
224    for (; n &lt; len; ++n) {   
225      VP8YuvToRgba(y[0], u[0], v[0], dst);
226      dst += 4;
227      y += 1;
228      u += (n &amp; 1);
229      v += (n &amp; 1);
230    }
231  }
232  static void YuvToBgraRow_SSE2(const uint8_t* y,
233                                const uint8_t* u, const uint8_t* v,
234                                uint8_t* dst, int len) {
235    const __m128i kAlpha = _mm_set1_epi16(255);
236    int n;
237    for (n = 0; n + 8 &lt;= len; n += 8, dst += 32) {
238      __m128i R, G, B;
239      YUV420ToRGB_SSE2(y, u, v, &amp;R, &amp;G, &amp;B);
240      PackAndStore4_SSE2(&amp;B, &amp;G, &amp;R, &amp;kAlpha, dst);
241      y += 8;
242      u += 4;
243      v += 4;
244    }
245    for (; n &lt; len; ++n) {   
246      VP8YuvToBgra(y[0], u[0], v[0], dst);
247      dst += 4;
248      y += 1;
249      u += (n &amp; 1);
250      v += (n &amp; 1);
251    }
252  }
253  static void YuvToArgbRow_SSE2(const uint8_t* y,
254                                const uint8_t* u, const uint8_t* v,
255                                uint8_t* dst, int len) {
256    const __m128i kAlpha = _mm_set1_epi16(255);
257    int n;
258    for (n = 0; n + 8 &lt;= len; n += 8, dst += 32) {
259      __m128i R, G, B;
260      YUV420ToRGB_SSE2(y, u, v, &amp;R, &amp;G, &amp;B);
261      PackAndStore4_SSE2(&amp;kAlpha, &amp;R, &amp;G, &amp;B, dst);
262      y += 8;
263      u += 4;
264      v += 4;
265    }
266    for (; n &lt; len; ++n) {   
267      VP8YuvToArgb(y[0], u[0], v[0], dst);
268      dst += 4;
269      y += 1;
270      u += (n &amp; 1);
271      v += (n &amp; 1);
272    }
273  }
274  static void YuvToRgbRow_SSE2(const uint8_t* y,
275                               const uint8_t* u, const uint8_t* v,
276                               uint8_t* dst, int len) {
277    int n;
278    for (n = 0; n + 32 &lt;= len; n += 32, dst += 32 * 3) {
279      __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
280      __m128i rgb0, rgb1, rgb2, rgb3, rgb4, rgb5;
281      YUV420ToRGB_SSE2(y +  0, u +  0, v +  0, &amp;R0, &amp;G0, &amp;B0);
282      YUV420ToRGB_SSE2(y +  8, u +  4, v +  4, &amp;R1, &amp;G1, &amp;B1);
283      YUV420ToRGB_SSE2(y + 16, u +  8, v +  8, &amp;R2, &amp;G2, &amp;B2);
284      YUV420ToRGB_SSE2(y + 24, u + 12, v + 12, &amp;R3, &amp;G3, &amp;B3);
285      rgb0 = _mm_packus_epi16(R0, R1);
286      rgb1 = _mm_packus_epi16(R2, R3);
287      rgb2 = _mm_packus_epi16(G0, G1);
288      rgb3 = _mm_packus_epi16(G2, G3);
289      rgb4 = _mm_packus_epi16(B0, B1);
290      rgb5 = _mm_packus_epi16(B2, B3);
291      PlanarTo24b_SSE2(&amp;rgb0, &amp;rgb1, &amp;rgb2, &amp;rgb3, &amp;rgb4, &amp;rgb5, dst);
292      y += 32;
293      u += 16;
294      v += 16;
295    }
296    for (; n &lt; len; ++n) {   
297      VP8YuvToRgb(y[0], u[0], v[0], dst);
298      dst += 3;
299      y += 1;
300      u += (n &amp; 1);
301      v += (n &amp; 1);
302    }
303  }
304  static void YuvToBgrRow_SSE2(const uint8_t* y,
305                               const uint8_t* u, const uint8_t* v,
306                               uint8_t* dst, int len) {
307    int n;
308    for (n = 0; n + 32 &lt;= len; n += 32, dst += 32 * 3) {
309      __m128i R0, R1, R2, R3, G0, G1, G2, G3, B0, B1, B2, B3;
310      __m128i bgr0, bgr1, bgr2, bgr3, bgr4, bgr5;
311      YUV420ToRGB_SSE2(y +  0, u +  0, v +  0, &amp;R0, &amp;G0, &amp;B0);
312      YUV420ToRGB_SSE2(y +  8, u +  4, v +  4, &amp;R1, &amp;G1, &amp;B1);
313      YUV420ToRGB_SSE2(y + 16, u +  8, v +  8, &amp;R2, &amp;G2, &amp;B2);
314      YUV420ToRGB_SSE2(y + 24, u + 12, v + 12, &amp;R3, &amp;G3, &amp;B3);
315      bgr0 = _mm_packus_epi16(B0, B1);
316      bgr1 = _mm_packus_epi16(B2, B3);
317      bgr2 = _mm_packus_epi16(G0, G1);
318      bgr3 = _mm_packus_epi16(G2, G3);
319      bgr4 = _mm_packus_epi16(R0, R1);
320      bgr5 = _mm_packus_epi16(R2, R3);
321      PlanarTo24b_SSE2(&amp;bgr0, &amp;bgr1, &amp;bgr2, &amp;bgr3, &amp;bgr4, &amp;bgr5, dst);
322      y += 32;
323      u += 16;
324      v += 16;
325    }
326    for (; n &lt; len; ++n) {   
327      VP8YuvToBgr(y[0], u[0], v[0], dst);
328      dst += 3;
329      y += 1;
330      u += (n &amp; 1);
331      v += (n &amp; 1);
332    }
333  }
334  extern void WebPInitSamplersSSE2(void);
335  WEBP_TSAN_IGNORE_FUNCTION void WebPInitSamplersSSE2(void) {
336    WebPSamplers[MODE_RGB]  = YuvToRgbRow_SSE2;
337    WebPSamplers[MODE_RGBA] = YuvToRgbaRow_SSE2;
338    WebPSamplers[MODE_BGR]  = YuvToBgrRow_SSE2;
339    WebPSamplers[MODE_BGRA] = YuvToBgraRow_SSE2;
340    WebPSamplers[MODE_ARGB] = YuvToArgbRow_SSE2;
341  }
342  #define LOAD_16(src) _mm_loadu_si128((const __m128i*)(src))
343  #define STORE_16(V, dst) _mm_storeu_si128((__m128i*)(dst), (V))
344  static WEBP_INLINE void RGB24PackedToPlanarHelper_SSE2(
345      const __m128i* const in &amp;bsol;*in[6]*/, __m128i* const out &amp;bsol;*out[6]*/) {
346    out[0] = _mm_unpacklo_epi8(in[0], in[3]);
347    out[1] = _mm_unpackhi_epi8(in[0], in[3]);
348    out[2] = _mm_unpacklo_epi8(in[1], in[4]);
349    out[3] = _mm_unpackhi_epi8(in[1], in[4]);
350    out[4] = _mm_unpacklo_epi8(in[2], in[5]);
351    out[5] = _mm_unpackhi_epi8(in[2], in[5]);
352  }
353  static WEBP_INLINE void RGB24PackedToPlanar_SSE2(
354      const uint8_t* const rgb, __m128i* const out &amp;bsol;*out[6]*/) {
355    __m128i tmp[6];
356    tmp[0] = _mm_loadu_si128((const __m128i*)(rgb +  0));
357    tmp[1] = _mm_loadu_si128((const __m128i*)(rgb + 16));
358    tmp[2] = _mm_loadu_si128((const __m128i*)(rgb + 32));
359    tmp[3] = _mm_loadu_si128((const __m128i*)(rgb + 48));
360    tmp[4] = _mm_loadu_si128((const __m128i*)(rgb + 64));
361    tmp[5] = _mm_loadu_si128((const __m128i*)(rgb + 80));
362    RGB24PackedToPlanarHelper_SSE2(tmp, out);
363    RGB24PackedToPlanarHelper_SSE2(out, tmp);
364    RGB24PackedToPlanarHelper_SSE2(tmp, out);
365    RGB24PackedToPlanarHelper_SSE2(out, tmp);
366    RGB24PackedToPlanarHelper_SSE2(tmp, out);
367  }
368  static WEBP_INLINE void RGB32PackedToPlanar_SSE2(const uint32_t* const argb,
369                                                   __m128i* const rgb &amp;bsol;*in[6]*/) {
370    const __m128i zero = _mm_setzero_si128();
371    __m128i a0 = LOAD_16(argb + 0);
372    __m128i a1 = LOAD_16(argb + 4);
373    __m128i a2 = LOAD_16(argb + 8);
374    __m128i a3 = LOAD_16(argb + 12);
375    VP8L32bToPlanar_SSE2(&amp;a0, &amp;a1, &amp;a2, &amp;a3);
376    rgb[0] = _mm_unpacklo_epi8(a1, zero);
377    rgb[1] = _mm_unpackhi_epi8(a1, zero);
378    rgb[2] = _mm_unpacklo_epi8(a2, zero);
379    rgb[3] = _mm_unpackhi_epi8(a2, zero);
380    rgb[4] = _mm_unpacklo_epi8(a3, zero);
381    rgb[5] = _mm_unpackhi_epi8(a3, zero);
382  }
383  #define TRANSFORM(RG_LO, RG_HI, GB_LO, GB_HI, MULT_RG, MULT_GB, \
384                    ROUNDER, DESCALE_FIX, OUT) do {               \
385    const __m128i V0_lo = _mm_madd_epi16(RG_LO, MULT_RG);         \
386    const __m128i V0_hi = _mm_madd_epi16(RG_HI, MULT_RG);         \
387    const __m128i V1_lo = _mm_madd_epi16(GB_LO, MULT_GB);         \
388    const __m128i V1_hi = _mm_madd_epi16(GB_HI, MULT_GB);         \
389    const __m128i V2_lo = _mm_add_epi32(V0_lo, V1_lo);            \
390    const __m128i V2_hi = _mm_add_epi32(V0_hi, V1_hi);            \
391    const __m128i V3_lo = _mm_add_epi32(V2_lo, ROUNDER);          \
392    const __m128i V3_hi = _mm_add_epi32(V2_hi, ROUNDER);          \
393    const __m128i V5_lo = _mm_srai_epi32(V3_lo, DESCALE_FIX);     \
394    const __m128i V5_hi = _mm_srai_epi32(V3_hi, DESCALE_FIX);     \
395    (OUT) = _mm_packs_epi32(V5_lo, V5_hi);                        \
396  } while (0)
397  #define MK_CST_16(A, B) _mm_set_epi16((B), (A), (B), (A), (B), (A), (B), (A))
398  static WEBP_INLINE void ConvertRGBToY_SSE2(const __m128i* const R,
399                                             const __m128i* const G,
400                                             const __m128i* const B,
401                                             __m128i* const Y) {
402    const __m128i kRG_y = MK_CST_16(16839, 33059 - 16384);
403    const __m128i kGB_y = MK_CST_16(16384, 6420);
404    const __m128i kHALF_Y = _mm_set1_epi32((16 &lt;&lt; YUV_FIX) + YUV_HALF);
405    const __m128i RG_lo = _mm_unpacklo_epi16(*R, *G);
406    const __m128i RG_hi = _mm_unpackhi_epi16(*R, *G);
407    const __m128i GB_lo = _mm_unpacklo_epi16(*G, *B);
408    const __m128i GB_hi = _mm_unpackhi_epi16(*G, *B);
409    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_y, kGB_y, kHALF_Y, YUV_FIX, *Y);
410  }
411  static WEBP_INLINE void ConvertRGBToUV_SSE2(const __m128i* const R,
412                                              const __m128i* const G,
413                                              const __m128i* const B,
414                                              __m128i* const U,
415                                              __m128i* const V) {
416    const __m128i kRG_u = MK_CST_16(-9719, -19081);
417    const __m128i kGB_u = MK_CST_16(0, 28800);
418    const __m128i kRG_v = MK_CST_16(28800, 0);
419    const __m128i kGB_v = MK_CST_16(-24116, -4684);
420    const __m128i kHALF_UV = _mm_set1_epi32(((128 &lt;&lt; YUV_FIX) + YUV_HALF) &lt;&lt; 2);
421    const __m128i RG_lo = _mm_unpacklo_epi16(*R, *G);
422    const __m128i RG_hi = _mm_unpackhi_epi16(*R, *G);
423    const __m128i GB_lo = _mm_unpacklo_epi16(*G, *B);
424    const __m128i GB_hi = _mm_unpackhi_epi16(*G, *B);
425    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_u, kGB_u,
426              kHALF_UV, YUV_FIX + 2, *U);
427    TRANSFORM(RG_lo, RG_hi, GB_lo, GB_hi, kRG_v, kGB_v,
428              kHALF_UV, YUV_FIX + 2, *V);
429  }
430  #undef MK_CST_16
431  #undef TRANSFORM
432  static void ConvertRGB24ToY_SSE2(const uint8_t* rgb, uint8_t* y, int width) {
433    const int max_width = width &amp; ~31;
434    int i;
435    for (i = 0; i &lt; max_width; rgb += 3 * 16 * 2) {
436      __m128i rgb_plane[6];
437      int j;
438      RGB24PackedToPlanar_SSE2(rgb, rgb_plane);
439      for (j = 0; j &lt; 2; ++j, i += 16) {
440        const __m128i zero = _mm_setzero_si128();
441        __m128i r, g, b, Y0, Y1;
442        r = _mm_unpacklo_epi8(rgb_plane[0 + j], zero);
443        g = _mm_unpacklo_epi8(rgb_plane[2 + j], zero);
444        b = _mm_unpacklo_epi8(rgb_plane[4 + j], zero);
445        ConvertRGBToY_SSE2(&amp;r, &amp;g, &amp;b, &amp;Y0);
446        r = _mm_unpackhi_epi8(rgb_plane[0 + j], zero);
447        g = _mm_unpackhi_epi8(rgb_plane[2 + j], zero);
448        b = _mm_unpackhi_epi8(rgb_plane[4 + j], zero);
449        ConvertRGBToY_SSE2(&amp;r, &amp;g, &amp;b, &amp;Y1);
450        STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
451      }
452    }
453    for (; i &lt; width; ++i, rgb += 3) {   
454      y[i] = VP8RGBToY(rgb[0], rgb[1], rgb[2], YUV_HALF);
455    }
456  }
457  static void ConvertBGR24ToY_SSE2(const uint8_t* bgr, uint8_t* y, int width) {
458    const int max_width = width &amp; ~31;
459    int i;
460    for (i = 0; i &lt; max_width; bgr += 3 * 16 * 2) {
461      __m128i bgr_plane[6];
462      int j;
463      RGB24PackedToPlanar_SSE2(bgr, bgr_plane);
464      for (j = 0; j &lt; 2; ++j, i += 16) {
465        const __m128i zero = _mm_setzero_si128();
466        __m128i r, g, b, Y0, Y1;
467        b = _mm_unpacklo_epi8(bgr_plane[0 + j], zero);
468        g = _mm_unpacklo_epi8(bgr_plane[2 + j], zero);
469        r = _mm_unpacklo_epi8(bgr_plane[4 + j], zero);
470        ConvertRGBToY_SSE2(&amp;r, &amp;g, &amp;b, &amp;Y0);
471        b = _mm_unpackhi_epi8(bgr_plane[0 + j], zero);
472        g = _mm_unpackhi_epi8(bgr_plane[2 + j], zero);
473        r = _mm_unpackhi_epi8(bgr_plane[4 + j], zero);
474        ConvertRGBToY_SSE2(&amp;r, &amp;g, &amp;b, &amp;Y1);
475        STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
476      }
477    }
478    for (; i &lt; width; ++i, bgr += 3) {  
479      y[i] = VP8RGBToY(bgr[2], bgr[1], bgr[0], YUV_HALF);
480    }
481  }
482  static void ConvertARGBToY_SSE2(const uint32_t* argb, uint8_t* y, int width) {
483    const int max_width = width &amp; ~15;
484    int i;
485    for (i = 0; i &lt; max_width; i += 16) {
486      __m128i Y0, Y1, rgb[6];
487      RGB32PackedToPlanar_SSE2(&amp;argb[i], rgb);
488      ConvertRGBToY_SSE2(&amp;rgb[0], &amp;rgb[2], &amp;rgb[4], &amp;Y0);
489      ConvertRGBToY_SSE2(&amp;rgb[1], &amp;rgb[3], &amp;rgb[5], &amp;Y1);
490      STORE_16(_mm_packus_epi16(Y0, Y1), y + i);
491    }
492    for (; i &lt; width; ++i) {   
493      const uint32_t p = argb[i];
494      y[i] = VP8RGBToY((p &gt;&gt; 16) &amp; 0xff, (p &gt;&gt; 8) &amp; 0xff, (p &gt;&gt;  0) &amp; 0xff,
495                       YUV_HALF);
496    }
497  }
498  static void HorizontalAddPack_SSE2(const __m128i* const A,
499                                     const __m128i* const B,
500                                     __m128i* const out) {
501    const __m128i k2 = _mm_set1_epi16(2);
502    const __m128i C = _mm_madd_epi16(*A, k2);
503    const __m128i D = _mm_madd_epi16(*B, k2);
504    *out = _mm_packs_epi32(C, D);
505  }
506  static void ConvertARGBToUV_SSE2(const uint32_t* argb,
507                                   uint8_t* u, uint8_t* v,
508                                   int src_width, int do_store) {
509    const int max_width = src_width &amp; ~31;
510    int i;
511    for (i = 0; i &lt; max_width; i += 32, u += 16, v += 16) {
512      __m128i rgb[6], U0, V0, U1, V1;
513      RGB32PackedToPlanar_SSE2(&amp;argb[i], rgb);
514      HorizontalAddPack_SSE2(&amp;rgb[0], &amp;rgb[1], &amp;rgb[0]);
515      HorizontalAddPack_SSE2(&amp;rgb[2], &amp;rgb[3], &amp;rgb[2]);
516      HorizontalAddPack_SSE2(&amp;rgb[4], &amp;rgb[5], &amp;rgb[4]);
517      ConvertRGBToUV_SSE2(&amp;rgb[0], &amp;rgb[2], &amp;rgb[4], &amp;U0, &amp;V0);
518      RGB32PackedToPlanar_SSE2(&amp;argb[i + 16], rgb);
519      HorizontalAddPack_SSE2(&amp;rgb[0], &amp;rgb[1], &amp;rgb[0]);
520      HorizontalAddPack_SSE2(&amp;rgb[2], &amp;rgb[3], &amp;rgb[2]);
521      HorizontalAddPack_SSE2(&amp;rgb[4], &amp;rgb[5], &amp;rgb[4]);
522      ConvertRGBToUV_SSE2(&amp;rgb[0], &amp;rgb[2], &amp;rgb[4], &amp;U1, &amp;V1);
523      U0 = _mm_packus_epi16(U0, U1);
524      V0 = _mm_packus_epi16(V0, V1);
525      if (!do_store) {
526        const __m128i prev_u = LOAD_16(u);
527        const __m128i prev_v = LOAD_16(v);
528        U0 = _mm_avg_epu8(U0, prev_u);
529        V0 = _mm_avg_epu8(V0, prev_v);
530      }
531      STORE_16(U0, u);
532      STORE_16(V0, v);
533    }
534    if (i &lt; src_width) {  
535      WebPConvertARGBToUV_C(argb + i, u, v, src_width - i, do_store);
536    }
537  }
538  static WEBP_INLINE void RGBA32PackedToPlanar_16b_SSE2(
539      const uint16_t* const rgbx,
540      __m128i* const r, __m128i* const g, __m128i* const b) {
541    const __m128i in0 = LOAD_16(rgbx +  0);  
542    const __m128i in1 = LOAD_16(rgbx +  8);  
543    const __m128i in2 = LOAD_16(rgbx + 16);  
544    const __m128i in3 = LOAD_16(rgbx + 24);  
545    const __m128i A0 = _mm_unpacklo_epi16(in0, in1);
546    const __m128i A1 = _mm_unpackhi_epi16(in0, in1);
547    const __m128i A2 = _mm_unpacklo_epi16(in2, in3);
548    const __m128i A3 = _mm_unpackhi_epi16(in2, in3);
549    const __m128i B0 = _mm_unpacklo_epi16(A0, A1);  
550    const __m128i B1 = _mm_unpackhi_epi16(A0, A1);  
551    const __m128i B2 = _mm_unpacklo_epi16(A2, A3);  
552    const __m128i B3 = _mm_unpackhi_epi16(A2, A3);  
553    *r = _mm_unpacklo_epi64(B0, B2);
554    *g = _mm_unpackhi_epi64(B0, B2);
555    *b = _mm_unpacklo_epi64(B1, B3);
556  }
557  static void ConvertRGBA32ToUV_SSE2(const uint16_t* rgb,
558                                     uint8_t* u, uint8_t* v, int width) {
559    const int max_width = width &amp; ~15;
560    const uint16_t* const last_rgb = rgb + 4 * max_width;
561    while (rgb &lt; last_rgb) {
562      __m128i r, g, b, U0, V0, U1, V1;
563      RGBA32PackedToPlanar_16b_SSE2(rgb +  0, &amp;r, &amp;g, &amp;b);
564      ConvertRGBToUV_SSE2(&amp;r, &amp;g, &amp;b, &amp;U0, &amp;V0);
565      RGBA32PackedToPlanar_16b_SSE2(rgb + 32, &amp;r, &amp;g, &amp;b);
566      ConvertRGBToUV_SSE2(&amp;r, &amp;g, &amp;b, &amp;U1, &amp;V1);
567      STORE_16(_mm_packus_epi16(U0, U1), u);
568      STORE_16(_mm_packus_epi16(V0, V1), v);
569      u += 16;
570      v += 16;
571      rgb += 2 * 32;
572    }
573    if (max_width &lt; width) {  
574      WebPConvertRGBA32ToUV_C(rgb, u, v, width - max_width);
575    }
576  }
577  extern void WebPInitConvertARGBToYUVSSE2(void);
578  WEBP_TSAN_IGNORE_FUNCTION void WebPInitConvertARGBToYUVSSE2(void) {
579    WebPConvertARGBToY = ConvertARGBToY_SSE2;
580    WebPConvertARGBToUV = ConvertARGBToUV_SSE2;
581    WebPConvertRGB24ToY = ConvertRGB24ToY_SSE2;
582    WebPConvertBGR24ToY = ConvertBGR24ToY_SSE2;
583    WebPConvertRGBA32ToUV = ConvertRGBA32ToUV_SSE2;
584  }
585  #define MAX_Y ((1 &lt;&lt; 10) - 1)    
586  static uint16_t clip_y(int v) {
587    return (v &lt; 0) ? 0 : (v &gt; MAX_Y) ? MAX_Y : (uint16_t)v;
588  }
589  static uint64_t SharpYUVUpdateY_SSE2(const uint16_t* ref, const uint16_t* src,
590                                       uint16_t* dst, int len) {
591    uint64_t diff = 0;
592    uint32_t tmp[4];
593    int i;
594    const __m128i zero = _mm_setzero_si128();
595    const __m128i max = _mm_set1_epi16(MAX_Y);
596    const __m128i one = _mm_set1_epi16(1);
597    __m128i sum = zero;
598    for (i = 0; i + 8 &lt;= len; i += 8) {
599      const __m128i A = _mm_loadu_si128((const __m128i*)(ref + i));
600      const __m128i B = _mm_loadu_si128((const __m128i*)(src + i));
601      const __m128i C = _mm_loadu_si128((const __m128i*)(dst + i));
602      const __m128i D = _mm_sub_epi16(A, B);       
603      const __m128i E = _mm_cmpgt_epi16(zero, D);  
604      const __m128i F = _mm_add_epi16(C, D);       
605      const __m128i G = _mm_or_si128(E, one);      
606      const __m128i H = _mm_max_epi16(_mm_min_epi16(F, max), zero);
607      const __m128i I = _mm_madd_epi16(D, G);      
608      _mm_storeu_si128((__m128i*)(dst + i), H);
609      sum = _mm_add_epi32(sum, I);
610    }
611    _mm_storeu_si128((__m128i*)tmp, sum);
612    diff = tmp[3] + tmp[2] + tmp[1] + tmp[0];
613    for (; i &lt; len; ++i) {
614      const int diff_y = ref[i] - src[i];
615      const int new_y = (int)dst[i] + diff_y;
616      dst[i] = clip_y(new_y);
617      diff += (uint64_t)abs(diff_y);
618    }
619    return diff;
620  }
621  static void SharpYUVUpdateRGB_SSE2(const int16_t* ref, const int16_t* src,
622                                     int16_t* dst, int len) {
623    int i = 0;
624    for (i = 0; i + 8 &lt;= len; i += 8) {
625      const __m128i A = _mm_loadu_si128((const __m128i*)(ref + i));
626      const __m128i B = _mm_loadu_si128((const __m128i*)(src + i));
627      const __m128i C = _mm_loadu_si128((const __m128i*)(dst + i));
628      const __m128i D = _mm_sub_epi16(A, B);   
629      const __m128i E = _mm_add_epi16(C, D);   
630      _mm_storeu_si128((__m128i*)(dst + i), E);
631    }
632    for (; i &lt; len; ++i) {
633      const int diff_uv = ref[i] - src[i];
634      dst[i] += diff_uv;
635    }
636  }
637  static void SharpYUVFilterRow_SSE2(const int16_t* A, const int16_t* B, int len,
638                                     const uint16_t* best_y, uint16_t* out) {
639    int i;
640    const __m128i kCst8 = _mm_set1_epi16(8);
641    const __m128i max = _mm_set1_epi16(MAX_Y);
642    const __m128i zero = _mm_setzero_si128();
643    for (i = 0; i + 8 &lt;= len; i += 8) {
644      const __m128i a0 = _mm_loadu_si128((const __m128i*)(A + i + 0));
645      const __m128i a1 = _mm_loadu_si128((const __m128i*)(A + i + 1));
646      const __m128i b0 = _mm_loadu_si128((const __m128i*)(B + i + 0));
647      const __m128i b1 = _mm_loadu_si128((const __m128i*)(B + i + 1));
648      const __m128i a0b1 = _mm_add_epi16(a0, b1);
649      const __m128i a1b0 = _mm_add_epi16(a1, b0);
650      const __m128i a0a1b0b1 = _mm_add_epi16(a0b1, a1b0);  
651      const __m128i a0a1b0b1_8 = _mm_add_epi16(a0a1b0b1, kCst8);
652      const __m128i a0b1_2 = _mm_add_epi16(a0b1, a0b1);    
653      const __m128i a1b0_2 = _mm_add_epi16(a1b0, a1b0);    
654      const __m128i c0 = _mm_srai_epi16(_mm_add_epi16(a0b1_2, a0a1b0b1_8), 3);
655      const __m128i c1 = _mm_srai_epi16(_mm_add_epi16(a1b0_2, a0a1b0b1_8), 3);
656      const __m128i d0 = _mm_add_epi16(c1, a0);
657      const __m128i d1 = _mm_add_epi16(c0, a1);
658      const __m128i e0 = _mm_srai_epi16(d0, 1);
659      const __m128i e1 = _mm_srai_epi16(d1, 1);
660      const __m128i f0 = _mm_unpacklo_epi16(e0, e1);
661      const __m128i f1 = _mm_unpackhi_epi16(e0, e1);
662      const __m128i g0 = _mm_loadu_si128((const __m128i*)(best_y + 2 * i + 0));
663      const __m128i g1 = _mm_loadu_si128((const __m128i*)(best_y + 2 * i + 8));
664      const __m128i h0 = _mm_add_epi16(g0, f0);
665      const __m128i h1 = _mm_add_epi16(g1, f1);
666      const __m128i i0 = _mm_max_epi16(_mm_min_epi16(h0, max), zero);
667      const __m128i i1 = _mm_max_epi16(_mm_min_epi16(h1, max), zero);
668      _mm_storeu_si128((__m128i*)(out + 2 * i + 0), i0);
669      _mm_storeu_si128((__m128i*)(out + 2 * i + 8), i1);
670    }
671    for (; i &lt; len; ++i) {
672      const int a0b1 = A[i + 0] + B[i + 1];
673      const int a1b0 = A[i + 1] + B[i + 0];
674      const int a0a1b0b1 = a0b1 + a1b0 + 8;
675      const int v0 = (8 * A[i + 0] + 2 * a1b0 + a0a1b0b1) &gt;&gt; 4;
676      const int v1 = (8 * A[i + 1] + 2 * a0b1 + a0a1b0b1) &gt;&gt; 4;
677      out[2 * i + 0] = clip_y(best_y[2 * i + 0] + v0);
678      out[2 * i + 1] = clip_y(best_y[2 * i + 1] + v1);
679    }
680  }
681  #undef MAX_Y
682  extern void WebPInitSharpYUVSSE2(void);
683  WEBP_TSAN_IGNORE_FUNCTION void WebPInitSharpYUVSSE2(void) {
684    WebPSharpYUVUpdateY = SharpYUVUpdateY_SSE2;
685    WebPSharpYUVUpdateRGB = SharpYUVUpdateRGB_SSE2;
686    WebPSharpYUVFilterRow = SharpYUVFilterRow_SSE2;
687  }
688  #else  
689  WEBP_DSP_INIT_STUB(WebPInitSamplersSSE2)
690  WEBP_DSP_INIT_STUB(WebPInitConvertARGBToYUVSSE2)
691  WEBP_DSP_INIT_STUB(WebPInitSharpYUVSSE2)
692  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-x86.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv_sse2.c</div>
                </div>
                <div class="column column_space"><pre><code>559      cpuid_or_from_dump(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx, src_cpuiddump);
560      infos-&gt;hybridcoretype = eax &gt;&gt; 24;
</pre></code></div>
                <div class="column column_space"><pre><code>157      PackAndStore4_SSE2(&amp;kAlpha, &amp;R, &amp;G, &amp;B, dst);
158    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    