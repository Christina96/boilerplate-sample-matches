
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.0977734753146176%, Tokens: 8</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_utils.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <stdlib.h>
3  #include <string.h>
4  #include "src/dsp/dsp.h"
5  #include "src/utils/rescaler_utils.h"
6  void WebPRescalerInit(WebPRescaler* const wrk, int src_width, int src_height,
7                        uint8_t* const dst,
8                        int dst_width, int dst_height, int dst_stride,
9                        int num_channels, rescaler_t* const work) {
10    const int x_add = src_width, x_sub = dst_width;
11    const int y_add = src_height, y_sub = dst_height;
12    wrk->x_expand = (src_width < dst_width);
13    wrk->y_expand = (src_height < dst_height);
14    wrk->src_width = src_width;
15    wrk->src_height = src_height;
16    wrk->dst_width = dst_width;
17    wrk->dst_height = dst_height;
18    wrk->src_y = 0;
19    wrk->dst_y = 0;
20    wrk->dst = dst;
21    wrk->dst_stride = dst_stride;
22    wrk->num_channels = num_channels;
23    wrk->x_add = wrk->x_expand ? (x_sub - 1) : x_add;
24    wrk->x_sub = wrk->x_expand ? (x_add - 1) : x_sub;
25    if (!wrk->x_expand) {  
26      wrk->fx_scale = WEBP_RESCALER_FRAC(1, wrk->x_sub);
27    }
28    wrk->y_add = wrk->y_expand ? y_add - 1 : y_add;
29    wrk->y_sub = wrk->y_expand ? y_sub - 1 : y_sub;
30    wrk->y_accum = wrk->y_expand ? wrk->y_sub : wrk->y_add;
31    if (!wrk->y_expand) {
32      const uint64_t ratio =
33          (uint64_t)dst_height * WEBP_RESCALER_ONE / (wrk->x_add * wrk->y_add);
34      if (ratio != (uint32_t)ratio) {
35        wrk->fxy_scale = 0;
36      } else {
37        wrk->fxy_scale = (uint32_t)ratio;
38      }
39      wrk->fy_scale = WEBP_RESCALER_FRAC(1, wrk->y_sub);
40    } else {
41      wrk->fy_scale = WEBP_RESCALER_FRAC(1, wrk->x_add);
42    }
43    wrk->irow = work;
44    wrk->frow = work + num_channels * dst_width;
45    memset(work, 0, 2 * dst_width * num_channels * sizeof(*work));
46    WebPRescalerDspInit();
47  }
48  int WebPRescalerGetScaledDimensions(int src_width, int src_height,
49                                      int* const scaled_width,
50                                      int* const scaled_height) {
51    assert(scaled_width != NULL);
52    assert(scaled_height != NULL);
53    {
<span onclick='openModal()' class='match'>54      int width = *scaled_width;
55      int height = *scaled_height;
56      if (width == 0 && src_height > 0) {
57        width =
58            (int)(((uint64_t)src_width * height + src_height - 1) / src_height);
59      }
</span>60      if (height == 0 && src_width > 0) {
61        height =
62            (int)(((uint64_t)src_height * width + src_width - 1) / src_width);
63      }
64      if (width <= 0 || height <= 0) {
65        return 0;
66      }
67      *scaled_width = width;
68      *scaled_height = height;
69      return 1;
70    }
71  }
72  int WebPRescaleNeededLines(const WebPRescaler* const wrk, int max_num_lines) {
73    const int num_lines = (wrk->y_accum + wrk->y_sub - 1) / wrk->y_sub;
74    return (num_lines > max_num_lines) ? max_num_lines : num_lines;
75  }
76  int WebPRescalerImport(WebPRescaler* const wrk, int num_lines,
77                         const uint8_t* src, int src_stride) {
78    int total_imported = 0;
79    while (total_imported < num_lines && !WebPRescalerHasPendingOutput(wrk)) {
80      if (wrk->y_expand) {
81        rescaler_t* const tmp = wrk->irow;
82        wrk->irow = wrk->frow;
83        wrk->frow = tmp;
84      }
85      WebPRescalerImportRow(wrk, src);
86      if (!wrk->y_expand) {     
87        int x;
88        for (x = 0; x < wrk->num_channels * wrk->dst_width; ++x) {
89          wrk->irow[x] += wrk->frow[x];
90        }
91      }
92      ++wrk->src_y;
93      src += src_stride;
94      ++total_imported;
95      wrk->y_accum -= wrk->y_sub;
96    }
97    return total_imported;
98  }
99  int WebPRescalerExport(WebPRescaler* const rescaler) {
100    int total_exported = 0;
101    while (WebPRescalerHasPendingOutput(rescaler)) {
102      WebPRescalerExportRow(rescaler);
103      ++total_exported;
104    }
105    return total_exported;
106  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-dict_27.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/Win32_Time.h"
4  #include "Win32_Interop/win32fixes.h"
5  extern BOOL g_IsForkedProcess;
6  #endif
7  #include "fmacros.h"
8  #include <stdio.h>
9  #include <stdlib.h>
10  #include <stdint.h>
11  #include <string.h>
12  #include <stdarg.h>
13  #include <limits.h>
14  #ifndef _WIN32
15  #include <sys/time.h>
16  #endif
17  #include "dict.h"
18  #include "zmalloc.h"
19  #ifndef DICT_BENCHMARK_MAIN
20  #include "redisassert.h"
21  #else
22  #include <assert.h>
23  #endif
24  static int dict_can_resize = 1;
25  static unsigned int dict_force_resize_ratio = 5;
26  static int _dictExpandIfNeeded(dict *ht);
27  static PORT_ULONG _dictNextPower(PORT_ULONG size);
28  static PORT_LONG _dictKeyIndex(dict *ht, const void *key, uint64_t hash, dictEntry **existing);
29  static int _dictInit(dict *ht, dictType *type, void *privDataPtr);
30  static uint8_t dict_hash_function_seed[16];
31  void dictSetHashFunctionSeed(uint8_t *seed) {
32      memcpy(dict_hash_function_seed,seed,sizeof(dict_hash_function_seed));
33  }
34  uint8_t *dictGetHashFunctionSeed(void) {
35      return dict_hash_function_seed;
36  }
37  uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k);
38  uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k);
39  uint64_t dictGenHashFunction(const void *key, int len) {
40      return siphash(key,len,dict_hash_function_seed);
41  }
42  uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len) {
43      return siphash_nocase(buf,len,dict_hash_function_seed);
44  }
45  static void _dictReset(dictht *ht)
46  {
47      ht->table = NULL;
48      ht->size = 0;
49      ht->sizemask = 0;
50      ht->used = 0;
51  }
52  dict *dictCreate(dictType *type,
53          void *privDataPtr)
54  {
55      dict *d = zmalloc(sizeof(*d));
56      _dictInit(d,type,privDataPtr);
57      return d;
58  }
59  int _dictInit(dict *d, dictType *type,
60          void *privDataPtr)
61  {
62      _dictReset(&d->ht[0]);
63      _dictReset(&d->ht[1]);
64      d->type = type;
65      d->privdata = privDataPtr;
66      d->rehashidx = -1;
67      d->iterators = 0;
68      return DICT_OK;
69  }
70  int dictResize(dict *d)
71  {
72      int minimal;
73      if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;
74      minimal = (int)d->ht[0].used;                                               WIN_PORT_FIX &bsol;* cast (int) */
75      if (minimal < DICT_HT_INITIAL_SIZE)
76          minimal = DICT_HT_INITIAL_SIZE;
77      return dictExpand(d, minimal);
78  }
79  int dictExpand(dict *d, PORT_ULONG size)
80  {
81      if (dictIsRehashing(d) || d->ht[0].used > size)
82          return DICT_ERR;
83      dictht n; &bsol;* the new hash table */
84      PORT_ULONG realsize = _dictNextPower(size);
85      if (realsize == d->ht[0].size) return DICT_ERR;
86      n.size = realsize;
87      n.sizemask = realsize-1;
88      n.table = zcalloc(realsize*sizeof(dictEntry*));
89      n.used = (size_t) 0;                                                        WIN_PORT_FIX &bsol;* cast (size_t) */
90      if (d->ht[0].table == NULL) {
91          d->ht[0] = n;
92          return DICT_OK;
93      }
94      d->ht[1] = n;
95      d->rehashidx = 0;
96      return DICT_OK;
97  }
98  int dictRehash(dict *d, int n) {
99      WIN32_ONLY(if (g_IsForkedProcess) return 0;)
100      int empty_visits = n*10; &bsol;* Max number of empty buckets to visit. */
101      if (!dictIsRehashing(d)) return 0;
102      while(n-- && d->ht[0].used != 0) {
103          dictEntry *de, *nextde;
104          assert(d->ht[0].size > (PORT_ULONG)d->rehashidx);
105          while(d->ht[0].table[d->rehashidx] == NULL) {
106              d->rehashidx++;
107              if (--empty_visits == 0) return 1;
108          }
109          de = d->ht[0].table[d->rehashidx];
110          while(de) {
111              uint64_t h;
112              nextde = de->next;
113              h = dictHashKey(d, de->key) & d->ht[1].sizemask;
114              de->next = d->ht[1].table[h];
115              d->ht[1].table[h] = de;
116              d->ht[0].used--;
117              d->ht[1].used++;
118              de = nextde;
119          }
120          d->ht[0].table[d->rehashidx] = NULL;
121          d->rehashidx++;
122      }
123      if (d->ht[0].used == 0) {
124          zfree(d->ht[0].table);
125          d->ht[0] = d->ht[1];
126          _dictReset(&d->ht[1]);
127          d->rehashidx = -1;
128          return 0;
129      }
130      return 1;
131  }
132  PORT_LONGLONG timeInMilliseconds(void) {
133  #ifdef _WIN32
134      return GetHighResRelativeTime(1000);
135  #else
136      struct timeval tv;
137      gettimeofday(&tv,NULL);
138      return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
139  #endif
140  }
141  int dictRehashMilliseconds(dict *d, int ms) {
142      PORT_LONGLONG start = timeInMilliseconds();
143      int rehashes = 0;
144      while(dictRehash(d,100)) {
145          rehashes += 100;
146          if (timeInMilliseconds()-start > ms) break;
147      }
148      return rehashes;
149  }
150  static void _dictRehashStep(dict *d) {
151      if (d->iterators == 0) dictRehash(d,1);
152  }
153  int dictAdd(dict *d, void *key, void *val)
154  {
155      dictEntry *entry = dictAddRaw(d,key,NULL);
156      if (!entry) return DICT_ERR;
157      dictSetVal(d, entry, val);
158      return DICT_OK;
159  }
160  dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
161  {
162      PORT_LONG index;
163      dictEntry *entry;
164      dictht *ht;
165      if (dictIsRehashing(d)) _dictRehashStep(d);
166      if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
167          return NULL;
168      ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
169      entry = zmalloc(sizeof(*entry));
170      entry->next = ht->table[index];
171      ht->table[index] = entry;
172      ht->used++;
173      dictSetKey(d, entry, key);
174      return entry;
175  }
176  int dictReplace(dict *d, void *key, void *val)
177  {
178      dictEntry *entry, *existing, auxentry;
179      entry = dictAddRaw(d,key,&existing);
180      if (entry) {
181          dictSetVal(d, entry, val);
182          return 1;
183      }
184      auxentry = *existing;
185      dictSetVal(d, existing, val);
186      dictFreeVal(d, &auxentry);
187      return 0;
188  }
189  dictEntry *dictAddOrFind(dict *d, void *key) {
190      dictEntry *entry, *existing;
191      entry = dictAddRaw(d,key,&existing);
192      return entry ? entry : existing;
193  }
194  static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
195      uint64_t h, idx;
196      dictEntry *he, *prevHe;
197      int table;
198      if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;
199      if (dictIsRehashing(d)) _dictRehashStep(d);
200      h = dictHashKey(d, key);
201      for (table = 0; table <= 1; table++) {
202          idx = h & d->ht[table].sizemask;
203          he = d->ht[table].table[idx];
204          prevHe = NULL;
205          while(he) {
206              if (key==he->key || dictCompareKeys(d, key, he->key)) {
207                  if (prevHe)
208                      prevHe->next = he->next;
209                  else
210                      d->ht[table].table[idx] = he->next;
211                  if (!nofree) {
212                      dictFreeKey(d, he);
213                      dictFreeVal(d, he);
214                      zfree(he);
215                  }
216                  d->ht[table].used--;
217                  return he;
218              }
219              prevHe = he;
220              he = he->next;
221          }
222          if (!dictIsRehashing(d)) break;
223      }
224      return NULL; &bsol;* not found */
225  }
226  int dictDelete(dict *ht, const void *key) {
227      return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
228  }
229  dictEntry *dictUnlink(dict *ht, const void *key) {
230      return dictGenericDelete(ht,key,1);
231  }
232  void dictFreeUnlinkedEntry(dict *d, dictEntry *he) {
233      if (he == NULL) return;
234      dictFreeKey(d, he);
235      dictFreeVal(d, he);
236      zfree(he);
237  }
238  int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {
239      PORT_ULONG i;
240      for (i = 0; i < ht->size && ht->used > 0; i++) {
241          dictEntry *he, *nextHe;
242          if (callback && (i & 65535) == 0) callback(d->privdata);
243          if ((he = ht->table[i]) == NULL) continue;
244          while(he) {
245              nextHe = he->next;
246              dictFreeKey(d, he);
247              dictFreeVal(d, he);
248              zfree(he);
249              ht->used--;
250              he = nextHe;
251          }
252      }
253      zfree(ht->table);
254      _dictReset(ht);
255      return DICT_OK; &bsol;* never fails */
256  }
257  void dictRelease(dict *d)
258  {
259      _dictClear(d,&d->ht[0],NULL);
260      _dictClear(d,&d->ht[1],NULL);
261      zfree(d);
262  }
263  dictEntry *dictFind(dict *d, const void *key)
264  {
265      dictEntry *he;
266      uint64_t h, idx, table;
267      if (d->ht[0].used + d->ht[1].used == 0) return NULL; &bsol;* dict is empty */
268      if (dictIsRehashing(d)) _dictRehashStep(d);
269      h = dictHashKey(d, key);
270      for (table = 0; table <= 1; table++) {
271          idx = h & d->ht[table].sizemask;
272          he = d->ht[table].table[idx];
273          while(he) {
274              if (key==he->key || dictCompareKeys(d, key, he->key))
275                  return he;
276              he = he->next;
277          }
278          if (!dictIsRehashing(d)) return NULL;
279      }
280      return NULL;
281  }
282  void *dictFetchValue(dict *d, const void *key) {
283      dictEntry *he;
284      he = dictFind(d,key);
285      return he ? dictGetVal(he) : NULL;
286  }
287  PORT_LONGLONG dictFingerprint(dict *d) {
288      PORT_ULONG integers[6], hash = 0;
289      int j;
290      integers[0] = (PORT_LONG) d->ht[0].table;
291      integers[1] = d->ht[0].size;
292      integers[2] = d->ht[0].used;
293      integers[3] = (PORT_LONG) d->ht[1].table;
294      integers[4] = d->ht[1].size;
295      integers[5] = d->ht[1].used;
296      for (j = 0; j < 6; j++) {
297          hash += integers[j];
298          hash = (~hash) + (hash << 21); 
299          hash = hash ^ (hash >> 24);
300          hash = (hash + (hash << 3)) + (hash << 8); 
301          hash = hash ^ (hash >> 14);
302          hash = (hash + (hash << 2)) + (hash << 4); 
303          hash = hash ^ (hash >> 28);
304          hash = hash + (hash << 31);
305      }
306      return hash;
307  }
308  dictIterator *dictGetIterator(dict *d)
309  {
310      dictIterator *iter = zmalloc(sizeof(*iter));
311      iter->d = d;
312      iter->table = 0;
313      iter->index = -1;
314      iter->safe = 0;
315      iter->entry = NULL;
316      iter->nextEntry = NULL;
317      return iter;
318  }
319  dictIterator *dictGetSafeIterator(dict *d) {
320      dictIterator *i = dictGetIterator(d);
321      i->safe = 1;
322      return i;
323  }
324  dictEntry *dictNext(dictIterator *iter)
325  {
326      while (1) {
327          if (iter->entry == NULL) {
328              dictht *ht = &iter->d->ht[iter->table];
329              if (iter->index == -1 && iter->table == 0) {
330                  if (iter->safe)
331                      iter->d->iterators++;
332                  else
333                      iter->fingerprint = dictFingerprint(iter->d);
334              }
335              iter->index++;
336              if (iter->index >= (PORT_LONG) ht->size) {
337                  if (dictIsRehashing(iter->d) && iter->table == 0) {
338                      iter->table++;
339                      iter->index = 0;
340                      ht = &iter->d->ht[1];
341                  } else {
342                      break;
343                  }
344              }
345              iter->entry = ht->table[iter->index];
346          } else {
347              iter->entry = iter->nextEntry;
348          }
349          if (iter->entry) {
350              iter->nextEntry = iter->entry->next;
351              return iter->entry;
352          }
353      }
354      return NULL;
355  }
356  void dictReleaseIterator(dictIterator *iter)
357  {
358      if (!(iter->index == -1 && iter->table == 0)) {
359          if (iter->safe)
360              iter->d->iterators--;
361          else
362              assert(iter->fingerprint == dictFingerprint(iter->d));
363      }
364      zfree(iter);
365  }
366  dictEntry *dictGetRandomKey(dict *d)
367  {
368      dictEntry *he, *orighe;
369      PORT_ULONG h;
370      int listlen, listele;
371      if (dictSize(d) == 0) return NULL;
372      if (dictIsRehashing(d)) _dictRehashStep(d);
373      if (dictIsRehashing(d)) {
374          do {
375              h = (PORT_ULONG) (d->rehashidx + (random() % (d->ht[0].size +     WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
376                                              d->ht[1].size -
377                                              d->rehashidx)));
378              he = (h >= d->ht[0].size) ? d->ht[1].table[h - d->ht[0].size] :
379                                        d->ht[0].table[h];
380          } while(he == NULL);
381      } else {
382          do {
383              h = random() & d->ht[0].sizemask;
384              he = d->ht[0].table[h];
385          } while(he == NULL);
386      }
387      listlen = 0;
388      orighe = he;
389      while(he) {
390          he = he->next;
391          listlen++;
392      }
393      listele = random() % listlen;
394      he = orighe;
395      while(listele--) he = he->next;
396      return he;
397  }
398  unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {
399      PORT_ULONG j; &bsol;* internal hash table id, 0 or 1. */
400      PORT_ULONG tables; &bsol;* 1 or 2 tables? */
401      PORT_ULONG stored = 0, maxsizemask;
402      PORT_ULONG maxsteps;
403      if (dictSize(d) < count) count = (unsigned int)dictSize(d);                 WIN_PORT_FIX &bsol;* cast (unsigned int) */
404      maxsteps = count*10;
405      for (j = 0; j < count; j++) {
406          if (dictIsRehashing(d))
407              _dictRehashStep(d);
408          else
409              break;
410      }
411      tables = dictIsRehashing(d) ? 2 : 1;
412      maxsizemask = (unsigned int) d->ht[0].sizemask;                             WIN_PORT_FIX &bsol;* cast (unsigned int) */
413      if (tables > 1 && maxsizemask < d->ht[1].sizemask)
414          maxsizemask = (unsigned int) d->ht[1].sizemask;                         WIN_PORT_FIX &bsol;* cast (unsigned int) */
415      PORT_ULONG i = random() & maxsizemask;
416      PORT_ULONG emptylen = 0; &bsol;* Continuous empty entries so far. */
417      while(stored < count && maxsteps--) {
418          for (j = 0; j < tables; j++) {
419              if (tables == 2 && j == 0 && i < (PORT_ULONG) d->rehashidx) {
420                  if (i >= d->ht[1].size)
421                      i = (PORT_ULONG) d->rehashidx;        WIN_PORT_FIX &bsol;* cast (unsigned long) */
422                  else
423                      continue;
424              }
425              if (i >= d->ht[j].size) continue; &bsol;* Out of range for this table. */
426              dictEntry *he = d->ht[j].table[i];
427              if (he == NULL) {
428                  emptylen++;
429                  if (emptylen >= 5 && emptylen > count) {
430                      i = random() & maxsizemask;
431                      emptylen = 0;
432                  }
433              } else {
434                  emptylen = 0;
435                  while (he) {
436                      *des = he;
437                      des++;
438                      he = he->next;
439                      stored++;
440                      if (stored == count) return (unsigned int)stored;           WIN_PORT_FIX &bsol;* cast (unsigned int) */
441                  }
442              }
443          }
444          i = (i+1) & maxsizemask;
445      }
446      return (unsigned int)stored;                                                WIN_PORT_FIX &bsol;* cast (unsigned int) */
447  }
448  static PORT_ULONG rev(PORT_ULONG v) {
449      PORT_ULONG s = 8 * sizeof(v); 
450      PORT_ULONG mask = ~0;
451      while ((s >>= 1) > 0) {
452          mask ^= (mask << s);
453          v = ((v >> s) & mask) | ((v << s) & ~mask);
454      }
455      return v;
456  }
457  PORT_ULONG dictScan(dict *d,
458                         PORT_ULONG v,
459                         dictScanFunction *fn,
460                         dictScanBucketFunction* bucketfn,
461                         void *privdata)
462  {
463      dictht *t0, *t1;
464      const dictEntry *de, *next;
465      PORT_ULONG m0, m1;
466      if (dictSize(d) == 0) return 0;
467      if (!dictIsRehashing(d)) {
468          t0 = &(d->ht[0]);
469          m0 = (PORT_ULONG)t0->sizemask;                                          WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
470          if (bucketfn) bucketfn(privdata, &t0->table[v & m0]);
471          de = t0->table[v & m0];
472          while (de) {
473              next = de->next;
474              fn(privdata, de);
475              de = next;
476          }
477          v |= ~m0;
478          v = rev(v);
479          v++;
480          v = rev(v);
481      } else {
482          t0 = &d->ht[0];
483          t1 = &d->ht[1];
484          if (t0->size > t1->size) {
485              t0 = &d->ht[1];
486              t1 = &d->ht[0];
487          }
488          m0 = (PORT_ULONG)t0->sizemask;                                          WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
489          m1 = (PORT_ULONG)t1->sizemask;                                          WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
490          if (bucketfn) bucketfn(privdata, &t0->table[v & m0]);
491          de = t0->table[v & m0];
492          while (de) {
493              next = de->next;
494              fn(privdata, de);
495              de = next;
496          }
497          do {
498              if (bucketfn) bucketfn(privdata, &t1->table[v & m1]);
499              de = t1->table[v & m1];
500              while (de) {
501                  next = de->next;
502                  fn(privdata, de);
503                  de = next;
504              }
505              v |= ~m1;
506              v = rev(v);
507              v++;
508              v = rev(v);
509          } while (v & (m0 ^ m1));
510      }
511      return v;
512  }
513  static int _dictExpandIfNeeded(dict *d)
514  {
515      if (dictIsRehashing(d)) return DICT_OK;
516      if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);
517      if (d->ht[0].used >= d->ht[0].size &&
518          (dict_can_resize ||
519           d->ht[0].used/d->ht[0].size > dict_force_resize_ratio))
520      {
521          return dictExpand(d, d->ht[0].used*2);
522      }
523      return DICT_OK;
524  }
525  static PORT_ULONG _dictNextPower(PORT_ULONG size)
526  {
527      PORT_ULONG i = DICT_HT_INITIAL_SIZE;
528      if (size >= PORT_LONG_MAX) return PORT_LONG_MAX + 1LU;
529      while(1) {
530          if (i >= size)
531              return i;
532          i *= 2;
533      }
534  }
535  static PORT_LONG _dictKeyIndex(dict *d, const void *key, uint64_t hash, dictEntry **existing)
536  {
537      PORT_ULONG idx, table;
538      dictEntry *he;
539      if (existing) *existing = NULL;
540      if (_dictExpandIfNeeded(d) == DICT_ERR)
541          return -1;
542      for (table = 0; table <= 1; table++) {
543          idx = hash & d->ht[table].sizemask;
544          he = d->ht[table].table[idx];
545          while(he) {
546              if (key==he->key || dictCompareKeys(d, key, he->key)) {
547                  if (existing) *existing = he;
548                  return -1;
549              }
550              he = he->next;
551          }
552          if (!dictIsRehashing(d)) break;
553      }
554      return idx;
555  }
556  void dictEmpty(dict *d, void(callback)(void*)) {
557      _dictClear(d,&d->ht[0],callback);
558      _dictClear(d,&d->ht[1],callback);
559      d->rehashidx = -1;
560      d->iterators = 0;
561  }
562  void dictEnableResize(void) {
563      dict_can_resize = 1;
564  }
565  void dictDisableResize(void) {
566      dict_can_resize = 0;
567  }
568  uint64_t dictGetHash(dict *d, const void *key) {
569      return dictHashKey(d, key);
570  }
571  dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, uint64_t hash) {
572      dictEntry *he, **heref;
573      PORT_ULONG idx, table;
574      if (d->ht[0].used + d->ht[1].used == 0) return NULL; &bsol;* dict is empty */
575      for (table = 0; table <= 1; table++) {
576          idx = hash & d->ht[table].sizemask;
577          heref = &d->ht[table].table[idx];
578          he = *heref;
579          while(he) {
580              if (oldptr==he->key)
581                  return heref;
582              heref = &he->next;
583              he = *heref;
584          }
585          if (!dictIsRehashing(d)) return NULL;
586      }
587      return NULL;
588  }
589  #define DICT_STATS_VECTLEN 50
590  size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {
591      PORT_ULONG i, slots = 0, chainlen, maxchainlen = 0;
592      PORT_ULONG totchainlen = 0;
593      PORT_ULONG clvector[DICT_STATS_VECTLEN];
594      size_t l = 0;
595      if (ht->used == 0) {
596          return snprintf(buf,bufsize,
597              "No stats available for empty dictionaries\n");
598      }
599      for (i = 0; i < DICT_STATS_VECTLEN; i++) clvector[i] = 0;
600      for (i = 0; i < ht->size; i++) {
601          dictEntry *he;
602          if (ht->table[i] == NULL) {
603              clvector[0]++;
604              continue;
605          }
606          slots++;
607          chainlen = 0;
608          he = ht->table[i];
609          while(he) {
610              chainlen++;
611              he = he->next;
612          }
613          clvector[(chainlen < DICT_STATS_VECTLEN) ? chainlen : (DICT_STATS_VECTLEN-1)]++;
614          if (chainlen > maxchainlen) maxchainlen = chainlen;
615          totchainlen += chainlen;
616      }
617      l += snprintf(buf+l,bufsize-l,
618          "Hash table %d stats (%s):\n"
619          " table size: %Id\n"                                                      WIN_PORT_FIX &bsol;* %ld -> %Id */
620          " number of elements: %Id\n"                                              WIN_PORT_FIX &bsol;* %ld -> %Id */
621          " different slots: %Id\n"                                                 WIN_PORT_FIX &bsol;* %ld -> %Id */
622          " max chain length: %Id\n"                                                WIN_PORT_FIX &bsol;* %ld -> %Id */
623          " avg chain length (counted): %.02f\n"
624          " avg chain length (computed): %.02f\n"
625          " Chain length distribution:\n",
626          tableid, (tableid == 0) ? "main hash table" : "rehashing target",
627          ht->size, ht->used, slots, maxchainlen,
628          (float)totchainlen/slots, (float)ht->used/slots);
629      for (i = 0; i < DICT_STATS_VECTLEN-1; i++) {
630          if (clvector[i] == 0) continue;
631          if (l >= bufsize) break;
632          l += snprintf(buf+l,bufsize-l,
633              "   %s%Id: %Id (%.02f%%)\n",                                          WIN_PORT_FIX &bsol;* %ld -> %Id */
634              (i == DICT_STATS_VECTLEN-1)?">= ":"",
635              i, clvector[i], ((float)clvector[i]/ht->size)*100);
636      }
637      if (bufsize) buf[bufsize-1] = '\0';
638      return strlen(buf);
639  }
640  void dictGetStats(char *buf, size_t bufsize, dict *d) {
641      size_t l;
642      char *orig_buf = buf;
643      size_t orig_bufsize = bufsize;
644      l = _dictGetStatsHt(buf,bufsize,&d->ht[0],0);
645      buf += l;
646      bufsize -= l;
647      if (dictIsRehashing(d) && bufsize > 0) {
648          _dictGetStatsHt(buf,bufsize,&d->ht[1],1);
649      }
650      if (orig_bufsize) orig_buf[orig_bufsize-1] = '\0';
651  }
652  #ifdef DICT_BENCHMARK_MAIN
653  #include "sds.h"
654  uint64_t hashCallback(const void *key) {
655      return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
656  }
657  int compareCallback(void *privdata, const void *key1, const void *key2) {
658      int l1,l2;
659      DICT_NOTUSED(privdata);
660      l1 = sdslen((sds)key1);
661      l2 = sdslen((sds)key2);
662      if (l1 != l2) return 0;
663      return memcmp(key1, key2, l1) == 0;
664  }
665  void freeCallback(void *privdata, void *val) {
666      DICT_NOTUSED(privdata);
667      sdsfree(val);
668  }
669  dictType BenchmarkDictType = {
670      hashCallback,
671      NULL,
672      NULL,
673      compareCallback,
674      freeCallback,
675      NULL
676  };
677  #define start_benchmark() start = timeInMilliseconds()
678  #define end_benchmark(msg) do { \
679      elapsed = timeInMilliseconds()-start; \
680      printf(msg ": %ld items in %lld ms\n", count, elapsed); \
681  } while(0);
682  int main(int argc, char **argv) {
683      PORT_LONG j;
684      PORT_LONGLONG start, elapsed;
<span onclick='openModal()' class='match'>685      dict *dict = dictCreate(&BenchmarkDictType,NULL);
686      PORT_LONG count = 0;
687      if (argc == 2) {
688          count = strtol(argv[1],NULL,10);
689      } else {
</span>690          count = 5000000;
691      }
692      start_benchmark();
693      for (j = 0; j < count; j++) {
694          int retval = dictAdd(dict,sdsfromlonglong(j),(void*)j);
695          assert(retval == DICT_OK);
696      }
697      end_benchmark("Inserting");
698      assert((PORT_LONG)dictSize(dict) == count);
699      while (dictIsRehashing(dict)) {
700          dictRehashMilliseconds(dict,100);
701      }
702      start_benchmark();
703      for (j = 0; j < count; j++) {
704          sds key = sdsfromlonglong(j);
705          dictEntry *de = dictFind(dict,key);
706          assert(de != NULL);
707          sdsfree(key);
708      }
709      end_benchmark("Linear access of existing elements");
710      start_benchmark();
711      for (j = 0; j < count; j++) {
712          sds key = sdsfromlonglong(j);
713          dictEntry *de = dictFind(dict,key);
714          assert(de != NULL);
715          sdsfree(key);
716      }
717      end_benchmark("Linear access of existing elements (2nd round)");
718      start_benchmark();
719      for (j = 0; j < count; j++) {
720          sds key = sdsfromlonglong(rand() % count);
721          dictEntry *de = dictFind(dict,key);
722          assert(de != NULL);
723          sdsfree(key);
724      }
725      end_benchmark("Random access of existing elements");
726      start_benchmark();
727      for (j = 0; j < count; j++) {
728          sds key = sdsfromlonglong(rand() % count);
729          key[0] = 'X';
730          dictEntry *de = dictFind(dict,key);
731          assert(de == NULL);
732          sdsfree(key);
733      }
734      end_benchmark("Accessing missing");
735      start_benchmark();
736      for (j = 0; j < count; j++) {
737          sds key = sdsfromlonglong(j);
738          int retval = dictDelete(dict,key);
739          assert(retval == DICT_OK);
740          key[0] += 17; &bsol;* Change first number to letter. */
741          retval = dictAdd(dict,key,(void*)j);
742          assert(retval == DICT_OK);
743      }
744      end_benchmark("Removing and adding");
745  }
746  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-rescaler_utils.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-dict_27.c</div>
                </div>
                <div class="column column_space"><pre><code>54      int width = *scaled_width;
55      int height = *scaled_height;
56      if (width == 0 && src_height > 0) {
57        width =
58            (int)(((uint64_t)src_width * height + src_height - 1) / src_height);
59      }
</pre></code></div>
                <div class="column column_space"><pre><code>685      dict *dict = dictCreate(&BenchmarkDictType,NULL);
686      PORT_LONG count = 0;
687      if (argc == 2) {
688          count = strtol(argv[1],NULL,10);
689      } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    