
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.835543766578249%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-expire.c</h3>
            <pre><code>1  #include "server.h"
2  int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, PORT_LONGLONG now) {
3      PORT_LONGLONG t = dictGetSignedIntegerVal(de);
4      if (now > t) {
5          sds key = dictGetKey(de);
6          robj *keyobj = createStringObject(key,sdslen(key));
7          propagateExpire(db,keyobj,server.lazyfree_lazy_expire);
8          if (server.lazyfree_lazy_expire)
9              dbAsyncDelete(db,keyobj);
10          else
11              dbSyncDelete(db,keyobj);
12          notifyKeyspaceEvent(NOTIFY_EXPIRED,
13              "expired",keyobj,db->id);
14          decrRefCount(keyobj);
15          server.stat_expiredkeys++;
16          return 1;
17      } else {
18          return 0;
19      }
20  }
21  void activeExpireCycle(int type) {
22      static unsigned int current_db = 0; &bsol;* Last DB tested. */
23      static int timelimit_exit = 0;      &bsol;* Time limit hit in previous call? */
24      static PORT_LONGLONG last_fast_cycle = 0; &bsol;* When last fast cycle ran. */
25      int j, iteration = 0;
26      int dbs_per_call = CRON_DBS_PER_CALL;
27      PORT_LONGLONG start = ustime(), timelimit, elapsed;
28      if (clientsArePaused()) return;
29      if (type == ACTIVE_EXPIRE_CYCLE_FAST) {
30          if (!timelimit_exit) return;
31          if (start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;
32          last_fast_cycle = start;
33      }
34      if (dbs_per_call > server.dbnum || timelimit_exit)
35          dbs_per_call = server.dbnum;
36      timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;
37      timelimit_exit = 0;
38      if (timelimit <= 0) timelimit = 1;
39      if (type == ACTIVE_EXPIRE_CYCLE_FAST)
40          timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; &bsol;* in microseconds. */
41      PORT_LONG total_sampled = 0;
42  	PORT_LONG total_expired = 0;
43      for (j = 0; j < dbs_per_call && timelimit_exit == 0; j++) {
44          int expired;
45          redisDb *db = server.db+(current_db % server.dbnum);
46          current_db++;
47          do {
48              PORT_ULONG num, slots;
49              PORT_LONGLONG now, ttl_sum;
50              int ttl_samples;
51              iteration++;
52              if ((num = dictSize(db->expires)) == 0) {
53                  db->avg_ttl = 0;
54                  break;
55              }
56              slots = dictSlots(db->expires);
57              now = mstime();
58              if (num && slots > DICT_HT_INITIAL_SIZE &&
59                  (num*100/slots < 1)) break;
60              expired = 0;
61              ttl_sum = 0;
62              ttl_samples = 0;
63              if (num > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)
64                  num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;
65              while (num--) {
66                  dictEntry *de;
67                  PORT_LONGLONG ttl;
68                  if ((de = dictGetRandomKey(db->expires)) == NULL) break;
69                  ttl = dictGetSignedIntegerVal(de)-now;
70                  if (activeExpireCycleTryExpire(db,de,now)) expired++;
71                  if (ttl > 0) {
72                      ttl_sum += ttl;
73                      ttl_samples++;
74                  }
75                  total_sampled++;
76              }
77              total_expired += expired;
78              if (ttl_samples) {
79                  PORT_LONGLONG avg_ttl = ttl_sum/ttl_samples;
80                  if (db->avg_ttl == 0) db->avg_ttl = avg_ttl;
81                  db->avg_ttl = (db->avg_ttl/50)*49 + (avg_ttl/50);
82              }
83              if ((iteration & 0xf) == 0) { &bsol;* check once every 16 iterations. */
84                  elapsed = ustime()-start;
85                  if (elapsed > timelimit) {
86                      timelimit_exit = 1;
87                      server.stat_expired_time_cap_reached_count++;
88                      break;
89                  }
90              }
91          } while (expired > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);
92      }
93      elapsed = ustime()-start;
94      latencyAddSampleIfNeeded("expire-cycle",elapsed/1000);
95      double current_perc;
96      if (total_sampled) {
97          current_perc = (double)total_expired/total_sampled;
98      } else
99          current_perc = 0;
100      server.stat_expired_stale_perc = (current_perc*0.05)+
101                                       (server.stat_expired_stale_perc*0.95);
102  }
<span onclick='openModal()' class='match'>103  dict *slaveKeysWithExpire = NULL;
104  void expireSlaveKeys(void) {
105      if (slaveKeysWithExpire == NULL ||
106          dictSize(slaveKeysWithExpire) == 0) return;
107      int cycles = 0, noexpire = 0;
108      mstime_t start = mstime();
</span>109      while(1) {
110          dictEntry *de = dictGetRandomKey(slaveKeysWithExpire);
111          sds keyname = dictGetKey(de);
112          uint64_t dbids = dictGetUnsignedIntegerVal(de);
113          uint64_t new_dbids = 0;
114          int dbid = 0;
115          while(dbids && dbid < server.dbnum) {
116              if ((dbids & 1) != 0) {
117                  redisDb *db = server.db+dbid;
118                  dictEntry *expire = dictFind(db->expires,keyname);
119                  int expired = 0;
120                  if (expire &&
121                      activeExpireCycleTryExpire(server.db+dbid,expire,start))
122                  {
123                      expired = 1;
124                  }
125                  if (expire && !expired) {
126                      noexpire++;
127                      new_dbids |= (uint64_t)1 << dbid;
128                  }
129              }
130              dbid++;
131              dbids >>= 1;
132          }
133          if (new_dbids)
134              dictSetUnsignedIntegerVal(de,new_dbids);
135          else
136              dictDelete(slaveKeysWithExpire,keyname);
137          cycles++;
138          if (noexpire > 3) break;
139          if ((cycles % 64) == 0 && mstime()-start > 1) break;
140          if (dictSize(slaveKeysWithExpire) == 0) break;
141      }
142  }
143  void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
144      if (slaveKeysWithExpire == NULL) {
145          static dictType dt = {
146              dictSdsHash,                &bsol;* hash function */
147              NULL,                       &bsol;* key dup */
148              NULL,                       &bsol;* val dup */
149              dictSdsKeyCompare,          &bsol;* key compare */
150              dictSdsDestructor,          &bsol;* key destructor */
151              NULL                        &bsol;* val destructor */
152          };
153          slaveKeysWithExpire = dictCreate(&dt,NULL);
154      }
155      if (db->id > 63) return;
156      dictEntry *de = dictAddOrFind(slaveKeysWithExpire,key->ptr);
157      if (de->key == key->ptr) {
158          de->key = sdsdup(key->ptr);
159          dictSetUnsignedIntegerVal(de,0);
160      }
161      uint64_t dbids = dictGetUnsignedIntegerVal(de);
162      dbids |= (uint64_t)1 << db->id;
163      dictSetUnsignedIntegerVal(de,dbids);
164  }
165  size_t getSlaveKeyWithExpireCount(void) {
166      if (slaveKeysWithExpire == NULL) return 0;
167      return dictSize(slaveKeysWithExpire);
168  }
169  void flushSlaveKeysWithExpireList(void) {
170      if (slaveKeysWithExpire) {
171          dictRelease(slaveKeysWithExpire);
172          slaveKeysWithExpire = NULL;
173      }
174  }
175  int checkAlreadyExpired(PORT_LONGLONG when) {
176      return (when <= mstime() && !server.loading && !server.masterhost);
177  }
178  void expireGenericCommand(client *c, PORT_LONGLONG basetime, int unit) {
179      robj *key = c->argv[1], *param = c->argv[2];
180      PORT_LONGLONG when; &bsol;* unix time in milliseconds when the key will expire. */
181      if (getLongLongFromObjectOrReply(c, param, &when, NULL) != C_OK)
182          return;
183      if (unit == UNIT_SECONDS) when *= 1000;
184      when += basetime;
185      if (lookupKeyWrite(c->db,key) == NULL) {
186          addReply(c,shared.czero);
187          return;
188      }
189      if (checkAlreadyExpired(when)) {
190          robj *aux;
191          int deleted = server.lazyfree_lazy_expire ? dbAsyncDelete(c->db,key) :
192                                                      dbSyncDelete(c->db,key);
193          serverAssertWithInfo(c,key,deleted);
194          server.dirty++;
195          aux = server.lazyfree_lazy_expire ? shared.unlink : shared.del;
196          rewriteClientCommandVector(c,2,aux,key);
197          signalModifiedKey(c->db,key);
198          notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
199          addReply(c, shared.cone);
200          return;
201      } else {
202          setExpire(c,c->db,key,when);
203          addReply(c,shared.cone);
204          signalModifiedKey(c->db,key);
205          notifyKeyspaceEvent(NOTIFY_GENERIC,"expire",key,c->db->id);
206          server.dirty++;
207          return;
208      }
209  }
210  void expireCommand(client *c) {
211      expireGenericCommand(c,mstime(),UNIT_SECONDS);
212  }
213  void expireatCommand(client *c) {
214      expireGenericCommand(c,0,UNIT_SECONDS);
215  }
216  void pexpireCommand(client *c) {
217      expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);
218  }
219  void pexpireatCommand(client *c) {
220      expireGenericCommand(c,0,UNIT_MILLISECONDS);
221  }
222  void ttlGenericCommand(client *c, int output_ms) {
223      PORT_LONGLONG expire, ttl = -1;
224      if (lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH) == NULL) {
225          addReplyLongLong(c,-2);
226          return;
227      }
228      expire = getExpire(c->db,c->argv[1]);
229      if (expire != -1) {
230          ttl = expire-mstime();
231          if (ttl < 0) ttl = 0;
232      }
233      if (ttl == -1) {
234          addReplyLongLong(c,-1);
235      } else {
236          addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
237      }
238  }
239  void ttlCommand(client *c) {
240      ttlGenericCommand(c, 0);
241  }
242  void pttlCommand(client *c) {
243      ttlGenericCommand(c, 1);
244  }
245  void persistCommand(client *c) {
246      if (lookupKeyWrite(c->db,c->argv[1])) {
247          if (removeExpire(c->db,c->argv[1])) {
248              addReply(c,shared.cone);
249              server.dirty++;
250          } else {
251              addReply(c,shared.czero);
252          }
253      } else {
254          addReply(c,shared.czero);
255      }
256  }
257  void touchCommand(client *c) {
258      int touched = 0;
259      for (int j = 1; j < c->argc; j++)
260          if (lookupKeyRead(c->db,c->argv[j]) != NULL) touched++;
261      addReplyLongLong(c,touched);
262  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_dec.c</h3>
            <pre><code>1  #include <stdlib.h>
2  #include "src/dec/vp8i_dec.h"
3  #include "src/dec/vp8li_dec.h"
4  #include "src/dec/webpi_dec.h"
5  #include "src/utils/utils.h"
6  #include "src/webp/mux_types.h"  
7  static VP8StatusCode ParseRIFF(const uint8_t** const data,
8                                 size_t* const data_size, int have_all_data,
9                                 size_t* const riff_size) {
10    assert(data != NULL);
11    assert(data_size != NULL);
12    assert(riff_size != NULL);
13    *riff_size = 0;  
14    if (*data_size >= RIFF_HEADER_SIZE && !memcmp(*data, "RIFF", TAG_SIZE)) {
15      if (memcmp(*data + 8, "WEBP", TAG_SIZE)) {
16        return VP8_STATUS_BITSTREAM_ERROR;  
17      } else {
18        const uint32_t size = GetLE32(*data + TAG_SIZE);
19        if (size < TAG_SIZE + CHUNK_HEADER_SIZE) {
20          return VP8_STATUS_BITSTREAM_ERROR;
21        }
22        if (size > MAX_CHUNK_PAYLOAD) {
23          return VP8_STATUS_BITSTREAM_ERROR;
24        }
25        if (have_all_data && (size > *data_size - CHUNK_HEADER_SIZE)) {
26          return VP8_STATUS_NOT_ENOUGH_DATA;  
27        }
28        *riff_size = size;
29        *data += RIFF_HEADER_SIZE;
30        *data_size -= RIFF_HEADER_SIZE;
31      }
32    }
33    return VP8_STATUS_OK;
34  }
35  static VP8StatusCode ParseVP8X(const uint8_t** const data,
36                                 size_t* const data_size,
37                                 int* const found_vp8x,
38                                 int* const width_ptr, int* const height_ptr,
39                                 uint32_t* const flags_ptr) {
40    const uint32_t vp8x_size = CHUNK_HEADER_SIZE + VP8X_CHUNK_SIZE;
41    assert(data != NULL);
42    assert(data_size != NULL);
43    assert(found_vp8x != NULL);
44    *found_vp8x = 0;
45    if (*data_size < CHUNK_HEADER_SIZE) {
46      return VP8_STATUS_NOT_ENOUGH_DATA;  
47    }
48    if (!memcmp(*data, "VP8X", TAG_SIZE)) {
49      int width, height;
50      uint32_t flags;
51      const uint32_t chunk_size = GetLE32(*data + TAG_SIZE);
52      if (chunk_size != VP8X_CHUNK_SIZE) {
53        return VP8_STATUS_BITSTREAM_ERROR;  
54      }
55      if (*data_size < vp8x_size) {
56        return VP8_STATUS_NOT_ENOUGH_DATA;  
57      }
58      flags = GetLE32(*data + 8);
59      width = 1 + GetLE24(*data + 12);
60      height = 1 + GetLE24(*data + 15);
61      if (width * (uint64_t)height >= MAX_IMAGE_AREA) {
62        return VP8_STATUS_BITSTREAM_ERROR;  
63      }
64      if (flags_ptr != NULL) *flags_ptr = flags;
65      if (width_ptr != NULL) *width_ptr = width;
66      if (height_ptr != NULL) *height_ptr = height;
67      *data += vp8x_size;
68      *data_size -= vp8x_size;
69      *found_vp8x = 1;
70    }
71    return VP8_STATUS_OK;
72  }
73  static VP8StatusCode ParseOptionalChunks(const uint8_t** const data,
74                                           size_t* const data_size,
75                                           size_t const riff_size,
76                                           const uint8_t** const alpha_data,
77                                           size_t* const alpha_size) {
78    const uint8_t* buf;
79    size_t buf_size;
80    uint32_t total_size = TAG_SIZE +           
81                          CHUNK_HEADER_SIZE +  
82                          VP8X_CHUNK_SIZE;     
83    assert(data != NULL);
84    assert(data_size != NULL);
85    buf = *data;
86    buf_size = *data_size;
87    assert(alpha_data != NULL);
88    assert(alpha_size != NULL);
89    *alpha_data = NULL;
90    *alpha_size = 0;
91    while (1) {
92      uint32_t chunk_size;
93      uint32_t disk_chunk_size;   
94      *data = buf;
95      *data_size = buf_size;
96      if (buf_size < CHUNK_HEADER_SIZE) {  
97        return VP8_STATUS_NOT_ENOUGH_DATA;
98      }
99      chunk_size = GetLE32(buf + TAG_SIZE);
100      if (chunk_size > MAX_CHUNK_PAYLOAD) {
101        return VP8_STATUS_BITSTREAM_ERROR;          
102      }
103      disk_chunk_size = (CHUNK_HEADER_SIZE + chunk_size + 1) & ~1;
104      total_size += disk_chunk_size;
105      if (riff_size > 0 && (total_size > riff_size)) {
106        return VP8_STATUS_BITSTREAM_ERROR;          
107      }
108      if (!memcmp(buf, "VP8 ", TAG_SIZE) ||
109          !memcmp(buf, "VP8L", TAG_SIZE)) {
110        return VP8_STATUS_OK;
111      }
112      if (buf_size < disk_chunk_size) {             
113        return VP8_STATUS_NOT_ENOUGH_DATA;
114      }
115      if (!memcmp(buf, "ALPH", TAG_SIZE)) {         
116        *alpha_data = buf + CHUNK_HEADER_SIZE;
117        *alpha_size = chunk_size;
118      }
119      buf += disk_chunk_size;
120      buf_size -= disk_chunk_size;
121    }
122  }
123  static VP8StatusCode ParseVP8Header(const uint8_t** const data_ptr,
124                                      size_t* const data_size, int have_all_data,
125                                      size_t riff_size, size_t* const chunk_size,
126                                      int* const is_lossless) {
127    const uint8_t* const data = *data_ptr;
128    const int is_vp8 = !memcmp(data, "VP8 ", TAG_SIZE);
129    const int is_vp8l = !memcmp(data, "VP8L", TAG_SIZE);
130    const uint32_t minimal_size =
131        TAG_SIZE + CHUNK_HEADER_SIZE;  
132    assert(data != NULL);
133    assert(data_size != NULL);
134    assert(chunk_size != NULL);
135    assert(is_lossless != NULL);
136    if (*data_size < CHUNK_HEADER_SIZE) {
137      return VP8_STATUS_NOT_ENOUGH_DATA;  
138    }
139    if (is_vp8 || is_vp8l) {
140      const uint32_t size = GetLE32(data + TAG_SIZE);
141      if ((riff_size >= minimal_size) && (size > riff_size - minimal_size)) {
142        return VP8_STATUS_BITSTREAM_ERROR;  
143      }
144      if (have_all_data && (size > *data_size - CHUNK_HEADER_SIZE)) {
145        return VP8_STATUS_NOT_ENOUGH_DATA;  
146      }
147      *chunk_size = size;
148      *data_ptr += CHUNK_HEADER_SIZE;
149      *data_size -= CHUNK_HEADER_SIZE;
150      *is_lossless = is_vp8l;
151    } else {
152      *is_lossless = VP8LCheckSignature(data, *data_size);
153      *chunk_size = *data_size;
154    }
155    return VP8_STATUS_OK;
156  }
157  static VP8StatusCode ParseHeadersInternal(const uint8_t* data,
158                                            size_t data_size,
159                                            int* const width,
160                                            int* const height,
161                                            int* const has_alpha,
162                                            int* const has_animation,
163                                            int* const format,
164                                            WebPHeaderStructure* const headers) {
165    int canvas_width = 0;
166    int canvas_height = 0;
167    int image_width = 0;
168    int image_height = 0;
169    int found_riff = 0;
170    int found_vp8x = 0;
171    int animation_present = 0;
172    const int have_all_data = (headers != NULL) ? headers->have_all_data : 0;
173    VP8StatusCode status;
174    WebPHeaderStructure hdrs;
175    if (data == NULL || data_size < RIFF_HEADER_SIZE) {
176      return VP8_STATUS_NOT_ENOUGH_DATA;
177    }
178    memset(&hdrs, 0, sizeof(hdrs));
179    hdrs.data = data;
180    hdrs.data_size = data_size;
181    status = ParseRIFF(&data, &data_size, have_all_data, &hdrs.riff_size);
182    if (status != VP8_STATUS_OK) {
183      return status;   
184    }
185    found_riff = (hdrs.riff_size > 0);
186    {
187      uint32_t flags = 0;
188      status = ParseVP8X(&data, &data_size, &found_vp8x,
189                         &canvas_width, &canvas_height, &flags);
190      if (status != VP8_STATUS_OK) {
191        return status;  
192      }
193      animation_present = !!(flags & ANIMATION_FLAG);
194      if (!found_riff && found_vp8x) {
195        return VP8_STATUS_BITSTREAM_ERROR;
196      }
197      if (has_alpha != NULL) *has_alpha = !!(flags & ALPHA_FLAG);
198      if (has_animation != NULL) *has_animation = animation_present;
199      if (format != NULL) *format = 0;   
200      image_width = canvas_width;
201      image_height = canvas_height;
202      if (found_vp8x && animation_present && headers == NULL) {
203        status = VP8_STATUS_OK;
204        goto ReturnWidthHeight;  
205      }
206    }
207    if (data_size < TAG_SIZE) {
208      status = VP8_STATUS_NOT_ENOUGH_DATA;
209      goto ReturnWidthHeight;
210    }
211    if ((found_riff && found_vp8x) ||
212        (!found_riff && !found_vp8x && !memcmp(data, "ALPH", TAG_SIZE))) {
213      status = ParseOptionalChunks(&data, &data_size, hdrs.riff_size,
214                                   &hdrs.alpha_data, &hdrs.alpha_data_size);
215      if (status != VP8_STATUS_OK) {
216        goto ReturnWidthHeight;  
217      }
218    }
219    status = ParseVP8Header(&data, &data_size, have_all_data, hdrs.riff_size,
220                            &hdrs.compressed_size, &hdrs.is_lossless);
221    if (status != VP8_STATUS_OK) {
222      goto ReturnWidthHeight;  
223    }
224    if (hdrs.compressed_size > MAX_CHUNK_PAYLOAD) {
225      return VP8_STATUS_BITSTREAM_ERROR;
226    }
227    if (format != NULL && !animation_present) {
228      *format = hdrs.is_lossless ? 2 : 1;
229    }
230    if (!hdrs.is_lossless) {
231      if (data_size < VP8_FRAME_HEADER_SIZE) {
232        status = VP8_STATUS_NOT_ENOUGH_DATA;
233        goto ReturnWidthHeight;
234      }
235      if (!VP8GetInfo(data, data_size, (uint32_t)hdrs.compressed_size,
236                      &image_width, &image_height)) {
237        return VP8_STATUS_BITSTREAM_ERROR;
238      }
239    } else {
240      if (data_size < VP8L_FRAME_HEADER_SIZE) {
241        status = VP8_STATUS_NOT_ENOUGH_DATA;
242        goto ReturnWidthHeight;
243      }
244      if (!VP8LGetInfo(data, data_size, &image_width, &image_height, has_alpha)) {
245        return VP8_STATUS_BITSTREAM_ERROR;
246      }
247    }
248    if (found_vp8x) {
249      if (canvas_width != image_width || canvas_height != image_height) {
250        return VP8_STATUS_BITSTREAM_ERROR;
251      }
252    }
253    if (headers != NULL) {
254      *headers = hdrs;
255      headers->offset = data - headers->data;
256      assert((uint64_t)(data - headers->data) < MAX_CHUNK_PAYLOAD);
257      assert(headers->offset == headers->data_size - data_size);
258    }
259   ReturnWidthHeight:
260    if (status == VP8_STATUS_OK ||
261        (status == VP8_STATUS_NOT_ENOUGH_DATA && found_vp8x && headers == NULL)) {
262      if (has_alpha != NULL) {
263        *has_alpha |= (hdrs.alpha_data != NULL);
264      }
265      if (width != NULL) *width = image_width;
266      if (height != NULL) *height = image_height;
267      return VP8_STATUS_OK;
268    } else {
269      return status;
270    }
271  }
272  VP8StatusCode WebPParseHeaders(WebPHeaderStructure* const headers) {
273    volatile VP8StatusCode status;
274    int has_animation = 0;
275    assert(headers != NULL);
276    status = ParseHeadersInternal(headers->data, headers->data_size,
277                                  NULL, NULL, NULL, &has_animation,
278                                  NULL, headers);
279    if (status == VP8_STATUS_OK || status == VP8_STATUS_NOT_ENOUGH_DATA) {
280      if (has_animation) {
281        status = VP8_STATUS_UNSUPPORTED_FEATURE;
282      }
283    }
284    return status;
285  }
286  void WebPResetDecParams(WebPDecParams* const params) {
287    if (params != NULL) {
288      memset(params, 0, sizeof(*params));
289    }
290  }
291  static VP8StatusCode DecodeInto(const uint8_t* const data, size_t data_size,
292                                  WebPDecParams* const params) {
293    VP8StatusCode status;
294    VP8Io io;
295    WebPHeaderStructure headers;
296    headers.data = data;
297    headers.data_size = data_size;
298    headers.have_all_data = 1;
299    status = WebPParseHeaders(&headers);   
300    if (status != VP8_STATUS_OK) {
301      return status;
302    }
303    assert(params != NULL);
304    VP8InitIo(&io);
305    io.data = headers.data + headers.offset;
306    io.data_size = headers.data_size - headers.offset;
307    WebPInitCustomIo(params, &io);  
308    if (!headers.is_lossless) {
309      VP8Decoder* const dec = VP8New();
310      if (dec == NULL) {
311        return VP8_STATUS_OUT_OF_MEMORY;
312      }
313      dec->alpha_data_ = headers.alpha_data;
314      dec->alpha_data_size_ = headers.alpha_data_size;
315      if (!VP8GetHeaders(dec, &io)) {
316        status = dec->status_;   
317      } else {
318        status = WebPAllocateDecBuffer(io.width, io.height, params->options,
319                                       params->output);
320        if (status == VP8_STATUS_OK) {  
321          dec->mt_method_ = VP8GetThreadMethod(params->options, &headers,
322                                               io.width, io.height);
323          VP8InitDithering(params->options, dec);
324          if (!VP8Decode(dec, &io)) {
325            status = dec->status_;
326          }
327        }
328      }
329      VP8Delete(dec);
330    } else {
331      VP8LDecoder* const dec = VP8LNew();
332      if (dec == NULL) {
333        return VP8_STATUS_OUT_OF_MEMORY;
334      }
335      if (!VP8LDecodeHeader(dec, &io)) {
336        status = dec->status_;   
337      } else {
338        status = WebPAllocateDecBuffer(io.width, io.height, params->options,
339                                       params->output);
340        if (status == VP8_STATUS_OK) {  
341          if (!VP8LDecodeImage(dec)) {
342            status = dec->status_;
343          }
344        }
345      }
346      VP8LDelete(dec);
347    }
348    if (status != VP8_STATUS_OK) {
349      WebPFreeDecBuffer(params->output);
350    } else {
351      if (params->options != NULL && params->options->flip) {
352        status = WebPFlipBuffer(params->output);
353      }
354    }
355    return status;
356  }
357  static uint8_t* DecodeIntoRGBABuffer(WEBP_CSP_MODE colorspace,
358                                       const uint8_t* const data,
359                                       size_t data_size,
360                                       uint8_t* const rgba,
361                                       int stride, size_t size) {
362    WebPDecParams params;
363    WebPDecBuffer buf;
364    if (rgba == NULL) {
365      return NULL;
366    }
367    WebPInitDecBuffer(&buf);
368    WebPResetDecParams(&params);
369    params.output = &buf;
370    buf.colorspace    = colorspace;
371    buf.u.RGBA.rgba   = rgba;
372    buf.u.RGBA.stride = stride;
373    buf.u.RGBA.size   = size;
374    buf.is_external_memory = 1;
375    if (DecodeInto(data, data_size, &params) != VP8_STATUS_OK) {
376      return NULL;
377    }
378    return rgba;
379  }
380  uint8_t* WebPDecodeRGBInto(const uint8_t* data, size_t data_size,
381                             uint8_t* output, size_t size, int stride) {
382    return DecodeIntoRGBABuffer(MODE_RGB, data, data_size, output, stride, size);
383  }
384  uint8_t* WebPDecodeRGBAInto(const uint8_t* data, size_t data_size,
385                              uint8_t* output, size_t size, int stride) {
386    return DecodeIntoRGBABuffer(MODE_RGBA, data, data_size, output, stride, size);
387  }
388  uint8_t* WebPDecodeARGBInto(const uint8_t* data, size_t data_size,
389                              uint8_t* output, size_t size, int stride) {
390    return DecodeIntoRGBABuffer(MODE_ARGB, data, data_size, output, stride, size);
391  }
392  uint8_t* WebPDecodeBGRInto(const uint8_t* data, size_t data_size,
393                             uint8_t* output, size_t size, int stride) {
394    return DecodeIntoRGBABuffer(MODE_BGR, data, data_size, output, stride, size);
395  }
396  uint8_t* WebPDecodeBGRAInto(const uint8_t* data, size_t data_size,
397                              uint8_t* output, size_t size, int stride) {
398    return DecodeIntoRGBABuffer(MODE_BGRA, data, data_size, output, stride, size);
399  }
400  uint8_t* WebPDecodeYUVInto(const uint8_t* data, size_t data_size,
401                             uint8_t* luma, size_t luma_size, int luma_stride,
402                             uint8_t* u, size_t u_size, int u_stride,
<span onclick='openModal()' class='match'>403                             uint8_t* v, size_t v_size, int v_stride) {
404    WebPDecParams params;
405    WebPDecBuffer output;
406    if (luma == NULL) return NULL;
407    WebPInitDecBuffer(&output);
408    WebPResetDecParams(&params);
409    params.output = &output;
410    output.colorspace      = MODE_YUV;
411    output.u.YUVA.y        = luma;
</span>412    output.u.YUVA.y_stride = luma_stride;
413    output.u.YUVA.y_size   = luma_size;
414    output.u.YUVA.u        = u;
415    output.u.YUVA.u_stride = u_stride;
416    output.u.YUVA.u_size   = u_size;
417    output.u.YUVA.v        = v;
418    output.u.YUVA.v_stride = v_stride;
419    output.u.YUVA.v_size   = v_size;
420    output.is_external_memory = 1;
421    if (DecodeInto(data, data_size, &params) != VP8_STATUS_OK) {
422      return NULL;
423    }
424    return luma;
425  }
426  static uint8_t* Decode(WEBP_CSP_MODE mode, const uint8_t* const data,
427                         size_t data_size, int* const width, int* const height,
428                         WebPDecBuffer* const keep_info) {
429    WebPDecParams params;
430    WebPDecBuffer output;
431    WebPInitDecBuffer(&output);
432    WebPResetDecParams(&params);
433    params.output = &output;
434    output.colorspace = mode;
435    if (!WebPGetInfo(data, data_size, &output.width, &output.height)) {
436      return NULL;
437    }
438    if (width != NULL) *width = output.width;
439    if (height != NULL) *height = output.height;
440    if (DecodeInto(data, data_size, &params) != VP8_STATUS_OK) {
441      return NULL;
442    }
443    if (keep_info != NULL) {    
444      WebPCopyDecBuffer(&output, keep_info);
445    }
446    return WebPIsRGBMode(mode) ? output.u.RGBA.rgba : output.u.YUVA.y;
447  }
448  uint8_t* WebPDecodeRGB(const uint8_t* data, size_t data_size,
449                         int* width, int* height) {
450    return Decode(MODE_RGB, data, data_size, width, height, NULL);
451  }
452  uint8_t* WebPDecodeRGBA(const uint8_t* data, size_t data_size,
453                          int* width, int* height) {
454    return Decode(MODE_RGBA, data, data_size, width, height, NULL);
455  }
456  uint8_t* WebPDecodeARGB(const uint8_t* data, size_t data_size,
457                          int* width, int* height) {
458    return Decode(MODE_ARGB, data, data_size, width, height, NULL);
459  }
460  uint8_t* WebPDecodeBGR(const uint8_t* data, size_t data_size,
461                         int* width, int* height) {
462    return Decode(MODE_BGR, data, data_size, width, height, NULL);
463  }
464  uint8_t* WebPDecodeBGRA(const uint8_t* data, size_t data_size,
465                          int* width, int* height) {
466    return Decode(MODE_BGRA, data, data_size, width, height, NULL);
467  }
468  uint8_t* WebPDecodeYUV(const uint8_t* data, size_t data_size,
469                         int* width, int* height, uint8_t** u, uint8_t** v,
470                         int* stride, int* uv_stride) {
471    WebPDecBuffer output;   
472    uint8_t* const out = Decode(MODE_YUV, data, data_size,
473                                width, height, &output);
474    if (out != NULL) {
475      const WebPYUVABuffer* const buf = &output.u.YUVA;
476      *u = buf->u;
477      *v = buf->v;
478      *stride = buf->y_stride;
479      *uv_stride = buf->u_stride;
480      assert(buf->u_stride == buf->v_stride);
481    }
482    return out;
483  }
484  static void DefaultFeatures(WebPBitstreamFeatures* const features) {
485    assert(features != NULL);
486    memset(features, 0, sizeof(*features));
487  }
488  static VP8StatusCode GetFeatures(const uint8_t* const data, size_t data_size,
489                                   WebPBitstreamFeatures* const features) {
490    if (features == NULL || data == NULL) {
491      return VP8_STATUS_INVALID_PARAM;
492    }
493    DefaultFeatures(features);
494    return ParseHeadersInternal(data, data_size,
495                                &features->width, &features->height,
496                                &features->has_alpha, &features->has_animation,
497                                &features->format, NULL);
498  }
499  int WebPGetInfo(const uint8_t* data, size_t data_size,
500                  int* width, int* height) {
501    WebPBitstreamFeatures features;
502    if (GetFeatures(data, data_size, &features) != VP8_STATUS_OK) {
503      return 0;
504    }
505    if (width != NULL) {
506      *width  = features.width;
507    }
508    if (height != NULL) {
509      *height = features.height;
510    }
511    return 1;
512  }
513  int WebPInitDecoderConfigInternal(WebPDecoderConfig* config,
514                                    int version) {
515    if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_DECODER_ABI_VERSION)) {
516      return 0;   
517    }
518    if (config == NULL) {
519      return 0;
520    }
521    memset(config, 0, sizeof(*config));
522    DefaultFeatures(&config->input);
523    WebPInitDecBuffer(&config->output);
524    return 1;
525  }
526  VP8StatusCode WebPGetFeaturesInternal(const uint8_t* data, size_t data_size,
527                                        WebPBitstreamFeatures* features,
528                                        int version) {
529    if (WEBP_ABI_IS_INCOMPATIBLE(version, WEBP_DECODER_ABI_VERSION)) {
530      return VP8_STATUS_INVALID_PARAM;   
531    }
532    if (features == NULL) {
533      return VP8_STATUS_INVALID_PARAM;
534    }
535    return GetFeatures(data, data_size, features);
536  }
537  VP8StatusCode WebPDecode(const uint8_t* data, size_t data_size,
538                           WebPDecoderConfig* config) {
539    WebPDecParams params;
540    VP8StatusCode status;
541    if (config == NULL) {
542      return VP8_STATUS_INVALID_PARAM;
543    }
544    status = GetFeatures(data, data_size, &config->input);
545    if (status != VP8_STATUS_OK) {
546      if (status == VP8_STATUS_NOT_ENOUGH_DATA) {
547        return VP8_STATUS_BITSTREAM_ERROR;  
548      }
549      return status;
550    }
551    WebPResetDecParams(&params);
552    params.options = &config->options;
553    params.output = &config->output;
554    if (WebPAvoidSlowMemory(params.output, &config->input)) {
555      WebPDecBuffer in_mem_buffer;
556      WebPInitDecBuffer(&in_mem_buffer);
557      in_mem_buffer.colorspace = config->output.colorspace;
558      in_mem_buffer.width = config->input.width;
559      in_mem_buffer.height = config->input.height;
560      params.output = &in_mem_buffer;
561      status = DecodeInto(data, data_size, &params);
562      if (status == VP8_STATUS_OK) {  
563        status = WebPCopyDecBufferPixels(&in_mem_buffer, &config->output);
564      }
565      WebPFreeDecBuffer(&in_mem_buffer);
566    } else {
567      status = DecodeInto(data, data_size, &params);
568    }
569    return status;
570  }
571  int WebPIoInitFromOptions(const WebPDecoderOptions* const options,
572                            VP8Io* const io, WEBP_CSP_MODE src_colorspace) {
573    const int W = io->width;
574    const int H = io->height;
575    int x = 0, y = 0, w = W, h = H;
576    io->use_cropping = (options != NULL) && (options->use_cropping > 0);
577    if (io->use_cropping) {
578      w = options->crop_width;
579      h = options->crop_height;
580      x = options->crop_left;
581      y = options->crop_top;
582      if (!WebPIsRGBMode(src_colorspace)) {   
583        x &= ~1;
584        y &= ~1;
585      }
586      if (x < 0 || y < 0 || w <= 0 || h <= 0 || x + w > W || y + h > H) {
587        return 0;  
588      }
589    }
590    io->crop_left   = x;
591    io->crop_top    = y;
592    io->crop_right  = x + w;
593    io->crop_bottom = y + h;
594    io->mb_w = w;
595    io->mb_h = h;
596    io->use_scaling = (options != NULL) && (options->use_scaling > 0);
597    if (io->use_scaling) {
598      int scaled_width = options->scaled_width;
599      int scaled_height = options->scaled_height;
600      if (!WebPRescalerGetScaledDimensions(w, h, &scaled_width, &scaled_height)) {
601        return 0;
602      }
603      io->scaled_width = scaled_width;
604      io->scaled_height = scaled_height;
605    }
606    io->bypass_filtering = (options != NULL) && options->bypass_filtering;
607  #ifdef FANCY_UPSAMPLING
608    io->fancy_upsampling = (options == NULL) || (!options->no_fancy_upsampling);
609  #endif
610    if (io->use_scaling) {
611      io->bypass_filtering = (io->scaled_width < W * 3 / 4) &&
612                             (io->scaled_height < H * 3 / 4);
613      io->fancy_upsampling = 0;
614    }
615    return 1;
616  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-expire.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-webp_dec.c</div>
                </div>
                <div class="column column_space"><pre><code>103  dict *slaveKeysWithExpire = NULL;
104  void expireSlaveKeys(void) {
105      if (slaveKeysWithExpire == NULL ||
106          dictSize(slaveKeysWithExpire) == 0) return;
107      int cycles = 0, noexpire = 0;
108      mstime_t start = mstime();
</pre></code></div>
                <div class="column column_space"><pre><code>403                             uint8_t* v, size_t v_size, int v_stride) {
404    WebPDecParams params;
405    WebPDecBuffer output;
406    if (luma == NULL) return NULL;
407    WebPInitDecBuffer(&output);
408    WebPResetDecParams(&params);
409    params.output = &output;
410    output.colorspace      = MODE_YUV;
411    output.u.YUVA.y        = luma;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    