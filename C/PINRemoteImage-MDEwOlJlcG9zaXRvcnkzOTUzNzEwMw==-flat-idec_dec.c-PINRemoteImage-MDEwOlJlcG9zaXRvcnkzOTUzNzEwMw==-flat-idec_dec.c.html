
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-idec_dec.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <string.h>
3  #include <stdlib.h>
4  #include "src/dec/alphai_dec.h"
5  #include "src/dec/webpi_dec.h"
6  #include "src/dec/vp8i_dec.h"
7  #include "src/utils/utils.h"
8  #define CHUNK_SIZE 4096
9  #define MAX_MB_SIZE 4096
10  typedef enum {
11    STATE_WEBP_HEADER,  
12    STATE_VP8_HEADER,   
13    STATE_VP8_PARTS0,
14    STATE_VP8_DATA,
15    STATE_VP8L_HEADER,
16    STATE_VP8L_DATA,
17    STATE_DONE,
18    STATE_ERROR
19  } DecState;
20  typedef enum {
21    MEM_MODE_NONE = 0,
22    MEM_MODE_APPEND,
23    MEM_MODE_MAP
24  } MemBufferMode;
25  typedef struct {
26    MemBufferMode mode_;  
27    size_t start_;        
28    size_t end_;          
29    size_t buf_size_;     
30    uint8_t* buf_;        
31    size_t part0_size_;         
32    const uint8_t* part0_buf_;  
33  } MemBuffer;
34  struct WebPIDecoder {
35    DecState state_;         
36    WebPDecParams params_;   
37    int is_lossless_;        
38    void* dec_;              
39    VP8Io io_;
40    MemBuffer mem_;          
41    WebPDecBuffer output_;   
42    WebPDecBuffer* final_output_;  
43    size_t chunk_size_;      
44    int last_mb_y_;          
45  };
46  typedef struct {
47    VP8MB left_;
48    VP8MB info_;
49    VP8BitReader token_br_;
50  } MBContext;
51  static WEBP_INLINE size_t MemDataSize(const MemBuffer* mem) {
52    return (mem->end_ - mem->start_);
53  }
54  static int NeedCompressedAlpha(const WebPIDecoder* const idec) {
55    if (idec->state_ == STATE_WEBP_HEADER) {
56      return 0;
57    }
58    if (idec->is_lossless_) {
59      return 0;  
60    } else {
61      const VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
62      assert(dec != NULL);  
63      return (dec->alpha_data_ != NULL) && !dec->is_alpha_decoded_;
64    }
65  }
66  static void DoRemap(WebPIDecoder* const idec, ptrdiff_t offset) {
67    MemBuffer* const mem = &idec->mem_;
68    const uint8_t* const new_base = mem->buf_ + mem->start_;
69    idec->io_.data = new_base;
70    idec->io_.data_size = MemDataSize(mem);
71    if (idec->dec_ != NULL) {
72      if (!idec->is_lossless_) {
73        VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
74        const uint32_t last_part = dec->num_parts_minus_one_;
75        if (offset != 0) {
76          uint32_t p;
77          for (p = 0; p <= last_part; ++p) {
78            VP8RemapBitReader(dec->parts_ + p, offset);
79          }
80          if (mem->mode_ == MEM_MODE_MAP) {
81            VP8RemapBitReader(&dec->br_, offset);
82          }
83        }
84        {
85          const uint8_t* const last_start = dec->parts_[last_part].buf_;
86          VP8BitReaderSetBuffer(&dec->parts_[last_part], last_start,
87                                mem->buf_ + mem->end_ - last_start);
88        }
89        if (NeedCompressedAlpha(idec)) {
90          ALPHDecoder* const alph_dec = dec->alph_dec_;
91          dec->alpha_data_ += offset;
92          if (alph_dec != NULL && alph_dec->vp8l_dec_ != NULL) {
93            if (alph_dec->method_ == ALPHA_LOSSLESS_COMPRESSION) {
94              VP8LDecoder* const alph_vp8l_dec = alph_dec->vp8l_dec_;
95              assert(dec->alpha_data_size_ >= ALPHA_HEADER_LEN);
96              VP8LBitReaderSetBuffer(&alph_vp8l_dec->br_,
97                                     dec->alpha_data_ + ALPHA_HEADER_LEN,
98                                     dec->alpha_data_size_ - ALPHA_HEADER_LEN);
99            } else {  
100            }
101          }
102        }
103      } else {    
104        VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
105        VP8LBitReaderSetBuffer(&dec->br_, new_base, MemDataSize(mem));
106      }
107    }
108  }
109  static int AppendToMemBuffer(WebPIDecoder* const idec,
110                               const uint8_t* const data, size_t data_size) {
111    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
112    MemBuffer* const mem = &idec->mem_;
113    const int need_compressed_alpha = NeedCompressedAlpha(idec);
114    const uint8_t* const old_start =
115        (mem->buf_ == NULL) ? NULL : mem->buf_ + mem->start_;
116    const uint8_t* const old_base =
117        need_compressed_alpha ? dec->alpha_data_ : old_start;
118    assert(mem->buf_ != NULL || mem->start_ == 0);
119    assert(mem->mode_ == MEM_MODE_APPEND);
120    if (data_size > MAX_CHUNK_PAYLOAD) {
121      return 0;
122    }
123    if (mem->end_ + data_size > mem->buf_size_) {  
124      const size_t new_mem_start = old_start - old_base;
125      const size_t current_size = MemDataSize(mem) + new_mem_start;
126      const uint64_t new_size = (uint64_t)current_size + data_size;
127      const uint64_t extra_size = (new_size + CHUNK_SIZE - 1) & ~(CHUNK_SIZE - 1);
128      uint8_t* const new_buf =
129          (uint8_t*)WebPSafeMalloc(extra_size, sizeof(*new_buf));
130      if (new_buf == NULL) return 0;
131      if (old_base != NULL) memcpy(new_buf, old_base, current_size);
132      WebPSafeFree(mem->buf_);
133      mem->buf_ = new_buf;
134      mem->buf_size_ = (size_t)extra_size;
135      mem->start_ = new_mem_start;
136      mem->end_ = current_size;
137    }
138    assert(mem->buf_ != NULL);
139    memcpy(mem->buf_ + mem->end_, data, data_size);
140    mem->end_ += data_size;
141    assert(mem->end_ <= mem->buf_size_);
142    DoRemap(idec, mem->buf_ + mem->start_ - old_start);
143    return 1;
144  }
145  static int RemapMemBuffer(WebPIDecoder* const idec,
146                            const uint8_t* const data, size_t data_size) {
147    MemBuffer* const mem = &idec->mem_;
148    const uint8_t* const old_buf = mem->buf_;
149    const uint8_t* const old_start =
150        (old_buf == NULL) ? NULL : old_buf + mem->start_;
151    assert(old_buf != NULL || mem->start_ == 0);
152    assert(mem->mode_ == MEM_MODE_MAP);
153    if (data_size < mem->buf_size_) return 0;  
154    mem->buf_ = (uint8_t*)data;
155    mem->end_ = mem->buf_size_ = data_size;
156    DoRemap(idec, mem->buf_ + mem->start_ - old_start);
157    return 1;
158  }
159  static void InitMemBuffer(MemBuffer* const mem) {
160    mem->mode_       = MEM_MODE_NONE;
161    mem->buf_        = NULL;
162    mem->buf_size_   = 0;
163    mem->part0_buf_  = NULL;
164    mem->part0_size_ = 0;
165  }
166  static void ClearMemBuffer(MemBuffer* const mem) {
167    assert(mem);
168    if (mem->mode_ == MEM_MODE_APPEND) {
169      WebPSafeFree(mem->buf_);
170      WebPSafeFree((void*)mem->part0_buf_);
171    }
172  }
173  static int CheckMemBufferMode(MemBuffer* const mem, MemBufferMode expected) {
174    if (mem->mode_ == MEM_MODE_NONE) {
175      mem->mode_ = expected;    
176    } else if (mem->mode_ != expected) {
177      return 0;         
178    }
179    assert(mem->mode_ == expected);   
180    return 1;
181  }
182  static VP8StatusCode FinishDecoding(WebPIDecoder* const idec) {
183    const WebPDecoderOptions* const options = idec->params_.options;
184    WebPDecBuffer* const output = idec->params_.output;
185    idec->state_ = STATE_DONE;
186    if (options != NULL && options->flip) {
187      const VP8StatusCode status = WebPFlipBuffer(output);
188      if (status != VP8_STATUS_OK) return status;
189    }
190    if (idec->final_output_ != NULL) {
191      WebPCopyDecBufferPixels(output, idec->final_output_);  
192      WebPFreeDecBuffer(&idec->output_);
193      *output = *idec->final_output_;
194      idec->final_output_ = NULL;
195    }
196    return VP8_STATUS_OK;
197  }
198  static void SaveContext(const VP8Decoder* dec, const VP8BitReader* token_br,
199                          MBContext* const context) {
200    context->left_ = dec->mb_info_[-1];
201    context->info_ = dec->mb_info_[dec->mb_x_];
202    context->token_br_ = *token_br;
203  }
204  static void RestoreContext(const MBContext* context, VP8Decoder* const dec,
205                             VP8BitReader* const token_br) {
206    dec->mb_info_[-1] = context->left_;
207    dec->mb_info_[dec->mb_x_] = context->info_;
208    *token_br = context->token_br_;
209  }
210  static VP8StatusCode IDecError(WebPIDecoder* const idec, VP8StatusCode error) {
211    if (idec->state_ == STATE_VP8_DATA) {
212      VP8ExitCritical((VP8Decoder*)idec->dec_, &idec->io_);
213    }
214    idec->state_ = STATE_ERROR;
215    return error;
216  }
217  static void ChangeState(WebPIDecoder* const idec, DecState new_state,
218                          size_t consumed_bytes) {
219    MemBuffer* const mem = &idec->mem_;
220    idec->state_ = new_state;
221    mem->start_ += consumed_bytes;
222    assert(mem->start_ <= mem->end_);
223    idec->io_.data = mem->buf_ + mem->start_;
224    idec->io_.data_size = MemDataSize(mem);
225  }
226  static VP8StatusCode DecodeWebPHeaders(WebPIDecoder* const idec) {
227    MemBuffer* const mem = &idec->mem_;
228    const uint8_t* data = mem->buf_ + mem->start_;
229    size_t curr_size = MemDataSize(mem);
230    VP8StatusCode status;
231    WebPHeaderStructure headers;
232    headers.data = data;
233    headers.data_size = curr_size;
234    headers.have_all_data = 0;
235    status = WebPParseHeaders(&headers);
236    if (status == VP8_STATUS_NOT_ENOUGH_DATA) {
237      return VP8_STATUS_SUSPENDED;  
238    } else if (status != VP8_STATUS_OK) {
239      return IDecError(idec, status);
240    }
241    idec->chunk_size_ = headers.compressed_size;
242    idec->is_lossless_ = headers.is_lossless;
243    if (!idec->is_lossless_) {
244      VP8Decoder* const dec = VP8New();
245      if (dec == NULL) {
246        return VP8_STATUS_OUT_OF_MEMORY;
247      }
248      idec->dec_ = dec;
249      dec->alpha_data_ = headers.alpha_data;
250      dec->alpha_data_size_ = headers.alpha_data_size;
251      ChangeState(idec, STATE_VP8_HEADER, headers.offset);
252    } else {
253      VP8LDecoder* const dec = VP8LNew();
254      if (dec == NULL) {
255        return VP8_STATUS_OUT_OF_MEMORY;
256      }
257      idec->dec_ = dec;
258      ChangeState(idec, STATE_VP8L_HEADER, headers.offset);
259    }
260    return VP8_STATUS_OK;
261  }
262  static VP8StatusCode DecodeVP8FrameHeader(WebPIDecoder* const idec) {
263    const uint8_t* data = idec->mem_.buf_ + idec->mem_.start_;
264    const size_t curr_size = MemDataSize(&idec->mem_);
265    int width, height;
266    uint32_t bits;
267    if (curr_size < VP8_FRAME_HEADER_SIZE) {
268      return VP8_STATUS_SUSPENDED;
269    }
270    if (!VP8GetInfo(data, curr_size, idec->chunk_size_, &width, &height)) {
271      return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
272    }
273    bits = data[0] | (data[1] << 8) | (data[2] << 16);
274    idec->mem_.part0_size_ = (bits >> 5) + VP8_FRAME_HEADER_SIZE;
275    idec->io_.data = data;
276    idec->io_.data_size = curr_size;
277    idec->state_ = STATE_VP8_PARTS0;
278    return VP8_STATUS_OK;
279  }
280  static VP8StatusCode CopyParts0Data(WebPIDecoder* const idec) {
281    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
282    VP8BitReader* const br = &dec->br_;
283    const size_t part_size = br->buf_end_ - br->buf_;
284    MemBuffer* const mem = &idec->mem_;
285    assert(!idec->is_lossless_);
286    assert(mem->part0_buf_ == NULL);
287    assert(part_size <= mem->part0_size_);
288    if (part_size == 0) {   
289      return VP8_STATUS_BITSTREAM_ERROR;
290    }
291    if (mem->mode_ == MEM_MODE_APPEND) {
292      uint8_t* const part0_buf = (uint8_t*)WebPSafeMalloc(1ULL, part_size);
293      if (part0_buf == NULL) {
294        return VP8_STATUS_OUT_OF_MEMORY;
295      }
296      memcpy(part0_buf, br->buf_, part_size);
297      mem->part0_buf_ = part0_buf;
298      VP8BitReaderSetBuffer(br, part0_buf, part_size);
299    } else {
300    }
301    mem->start_ += part_size;
302    return VP8_STATUS_OK;
303  }
304  static VP8StatusCode DecodePartition0(WebPIDecoder* const idec) {
305    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
306    VP8Io* const io = &idec->io_;
307    const WebPDecParams* const params = &idec->params_;
308    WebPDecBuffer* const output = params->output;
309    if (MemDataSize(&idec->mem_) < idec->mem_.part0_size_) {
310      return VP8_STATUS_SUSPENDED;
311    }
312    if (!VP8GetHeaders(dec, io)) {
313      const VP8StatusCode status = dec->status_;
314      if (status == VP8_STATUS_SUSPENDED ||
315          status == VP8_STATUS_NOT_ENOUGH_DATA) {
316        return VP8_STATUS_SUSPENDED;
317      }
318      return IDecError(idec, status);
319    }
320    dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options,
321                                         output);
322    if (dec->status_ != VP8_STATUS_OK) {
323      return IDecError(idec, dec->status_);
324    }
325    dec->mt_method_ = VP8GetThreadMethod(params->options, NULL,
326                                         io->width, io->height);
327    VP8InitDithering(params->options, dec);
328    dec->status_ = CopyParts0Data(idec);
329    if (dec->status_ != VP8_STATUS_OK) {
330      return IDecError(idec, dec->status_);
331    }
332    if (VP8EnterCritical(dec, io) != VP8_STATUS_OK) {
333      return IDecError(idec, dec->status_);
334    }
335    idec->state_ = STATE_VP8_DATA;
336    if (!VP8InitFrame(dec, io)) {
337      return IDecError(idec, dec->status_);
338    }
339    return VP8_STATUS_OK;
340  }
341  static VP8StatusCode DecodeRemaining(WebPIDecoder* const idec) {
342    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
343    VP8Io* const io = &idec->io_;
344    if (!dec->ready_) {
345      return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
346    }
347    for (; dec->mb_y_ < dec->mb_h_; ++dec->mb_y_) {
348      if (idec->last_mb_y_ != dec->mb_y_) {
349        if (!VP8ParseIntraModeRow(&dec->br_, dec)) {
350          return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
351        }
352        idec->last_mb_y_ = dec->mb_y_;
353      }
354      for (; dec->mb_x_ < dec->mb_w_; ++dec->mb_x_) {
<span onclick='openModal()' class='match'>355        VP8BitReader* const token_br =
356            &dec->parts_[dec->mb_y_ & dec->num_parts_minus_one_];
357        MBContext context;
</span>358        SaveContext(dec, token_br, &context);
359        if (!VP8DecodeMB(dec, token_br)) {
360          if (dec->num_parts_minus_one_ == 0 &&
361              MemDataSize(&idec->mem_) > MAX_MB_SIZE) {
362            return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
363          }
364          if (dec->mt_method_ > 0) {
365            if (!WebPGetWorkerInterface()->Sync(&dec->worker_)) {
366              return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
367            }
368          }
369          RestoreContext(&context, dec, token_br);
370          return VP8_STATUS_SUSPENDED;
371        }
372        if (dec->num_parts_minus_one_ == 0) {
373          idec->mem_.start_ = token_br->buf_ - idec->mem_.buf_;
374          assert(idec->mem_.start_ <= idec->mem_.end_);
375        }
376      }
377      VP8InitScanline(dec);   
378      if (!VP8ProcessRow(dec, io)) {
379        return IDecError(idec, VP8_STATUS_USER_ABORT);
380      }
381    }
382    if (!VP8ExitCritical(dec, io)) {
383      idec->state_ = STATE_ERROR;  
384      return IDecError(idec, VP8_STATUS_USER_ABORT);
385    }
386    dec->ready_ = 0;
387    return FinishDecoding(idec);
388  }
389  static VP8StatusCode ErrorStatusLossless(WebPIDecoder* const idec,
390                                           VP8StatusCode status) {
391    if (status == VP8_STATUS_SUSPENDED || status == VP8_STATUS_NOT_ENOUGH_DATA) {
392      return VP8_STATUS_SUSPENDED;
393    }
394    return IDecError(idec, status);
395  }
396  static VP8StatusCode DecodeVP8LHeader(WebPIDecoder* const idec) {
397    VP8Io* const io = &idec->io_;
398    VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
399    const WebPDecParams* const params = &idec->params_;
400    WebPDecBuffer* const output = params->output;
401    size_t curr_size = MemDataSize(&idec->mem_);
402    assert(idec->is_lossless_);
403    if (curr_size < (idec->chunk_size_ >> 3)) {
404      dec->status_ = VP8_STATUS_SUSPENDED;
405      return ErrorStatusLossless(idec, dec->status_);
406    }
407    if (!VP8LDecodeHeader(dec, io)) {
408      if (dec->status_ == VP8_STATUS_BITSTREAM_ERROR &&
409          curr_size < idec->chunk_size_) {
410        dec->status_ = VP8_STATUS_SUSPENDED;
411      }
412      return ErrorStatusLossless(idec, dec->status_);
413    }
414    dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options,
415                                         output);
416    if (dec->status_ != VP8_STATUS_OK) {
417      return IDecError(idec, dec->status_);
418    }
419    idec->state_ = STATE_VP8L_DATA;
420    return VP8_STATUS_OK;
421  }
422  static VP8StatusCode DecodeVP8LData(WebPIDecoder* const idec) {
423    VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
424    const size_t curr_size = MemDataSize(&idec->mem_);
425    assert(idec->is_lossless_);
426    dec->incremental_ = (curr_size < idec->chunk_size_);
427    if (!VP8LDecodeImage(dec)) {
428      return ErrorStatusLossless(idec, dec->status_);
429    }
430    assert(dec->status_ == VP8_STATUS_OK || dec->status_ == VP8_STATUS_SUSPENDED);
431    return (dec->status_ == VP8_STATUS_SUSPENDED) ? dec->status_
432                                                  : FinishDecoding(idec);
433  }
434  static VP8StatusCode IDecode(WebPIDecoder* idec) {
435    VP8StatusCode status = VP8_STATUS_SUSPENDED;
436    if (idec->state_ == STATE_WEBP_HEADER) {
437      status = DecodeWebPHeaders(idec);
438    } else {
439      if (idec->dec_ == NULL) {
440        return VP8_STATUS_SUSPENDED;    
441      }
442    }
443    if (idec->state_ == STATE_VP8_HEADER) {
444      status = DecodeVP8FrameHeader(idec);
445    }
446    if (idec->state_ == STATE_VP8_PARTS0) {
447      status = DecodePartition0(idec);
448    }
449    if (idec->state_ == STATE_VP8_DATA) {
450      const VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
451      if (dec == NULL) {
452        return VP8_STATUS_SUSPENDED;  
453      }
454      status = DecodeRemaining(idec);
455    }
456    if (idec->state_ == STATE_VP8L_HEADER) {
457      status = DecodeVP8LHeader(idec);
458    }
459    if (idec->state_ == STATE_VP8L_DATA) {
460      status = DecodeVP8LData(idec);
461    }
462    return status;
463  }
464  static WebPIDecoder* NewDecoder(WebPDecBuffer* const output_buffer,
465                                  const WebPBitstreamFeatures* const features) {
466    WebPIDecoder* idec = (WebPIDecoder*)WebPSafeCalloc(1ULL, sizeof(*idec));
467    if (idec == NULL) {
468      return NULL;
469    }
470    idec->state_ = STATE_WEBP_HEADER;
471    idec->chunk_size_ = 0;
472    idec->last_mb_y_ = -1;
473    InitMemBuffer(&idec->mem_);
474    WebPInitDecBuffer(&idec->output_);
475    VP8InitIo(&idec->io_);
476    WebPResetDecParams(&idec->params_);
477    if (output_buffer == NULL || WebPAvoidSlowMemory(output_buffer, features)) {
478      idec->params_.output = &idec->output_;
479      idec->final_output_ = output_buffer;
480      if (output_buffer != NULL) {
481        idec->params_.output->colorspace = output_buffer->colorspace;
482      }
483    } else {
484      idec->params_.output = output_buffer;
485      idec->final_output_ = NULL;
486    }
487    WebPInitCustomIo(&idec->params_, &idec->io_);  
488    return idec;
489  }
490  WebPIDecoder* WebPINewDecoder(WebPDecBuffer* output_buffer) {
491    return NewDecoder(output_buffer, NULL);
492  }
493  WebPIDecoder* WebPIDecode(const uint8_t* data, size_t data_size,
494                            WebPDecoderConfig* config) {
495    WebPIDecoder* idec;
496    WebPBitstreamFeatures tmp_features;
497    WebPBitstreamFeatures* const features =
498        (config == NULL) ? &tmp_features : &config->input;
499    memset(&tmp_features, 0, sizeof(tmp_features));
500    if (data != NULL && data_size > 0) {
501      if (WebPGetFeatures(data, data_size, features) != VP8_STATUS_OK) {
502        return NULL;
503      }
504    }
505    idec = (config != NULL) ? NewDecoder(&config->output, features)
506                            : NewDecoder(NULL, features);
507    if (idec == NULL) {
508      return NULL;
509    }
510    if (config != NULL) {
511      idec->params_.options = &config->options;
512    }
513    return idec;
514  }
515  void WebPIDelete(WebPIDecoder* idec) {
516    if (idec == NULL) return;
517    if (idec->dec_ != NULL) {
518      if (!idec->is_lossless_) {
519        if (idec->state_ == STATE_VP8_DATA) {
520          VP8ExitCritical((VP8Decoder*)idec->dec_, &idec->io_);
521        }
522        VP8Delete((VP8Decoder*)idec->dec_);
523      } else {
524        VP8LDelete((VP8LDecoder*)idec->dec_);
525      }
526    }
527    ClearMemBuffer(&idec->mem_);
528    WebPFreeDecBuffer(&idec->output_);
529    WebPSafeFree(idec);
530  }
531  WebPIDecoder* WebPINewRGB(WEBP_CSP_MODE csp, uint8_t* output_buffer,
532                            size_t output_buffer_size, int output_stride) {
533    const int is_external_memory = (output_buffer != NULL) ? 1 : 0;
534    WebPIDecoder* idec;
535    if (csp >= MODE_YUV) return NULL;
536    if (is_external_memory == 0) {    
537      output_buffer_size = 0;
538      output_stride = 0;
539    } else {  
540      if (output_stride == 0 || output_buffer_size == 0) {
541        return NULL;   
542      }
543    }
544    idec = WebPINewDecoder(NULL);
545    if (idec == NULL) return NULL;
546    idec->output_.colorspace = csp;
547    idec->output_.is_external_memory = is_external_memory;
548    idec->output_.u.RGBA.rgba = output_buffer;
549    idec->output_.u.RGBA.stride = output_stride;
550    idec->output_.u.RGBA.size = output_buffer_size;
551    return idec;
552  }
553  WebPIDecoder* WebPINewYUVA(uint8_t* luma, size_t luma_size, int luma_stride,
554                             uint8_t* u, size_t u_size, int u_stride,
555                             uint8_t* v, size_t v_size, int v_stride,
556                             uint8_t* a, size_t a_size, int a_stride) {
557    const int is_external_memory = (luma != NULL) ? 1 : 0;
558    WebPIDecoder* idec;
559    WEBP_CSP_MODE colorspace;
560    if (is_external_memory == 0) {    
561      luma_size = u_size = v_size = a_size = 0;
562      luma_stride = u_stride = v_stride = a_stride = 0;
563      u = v = a = NULL;
564      colorspace = MODE_YUVA;
565    } else {  
566      if (u == NULL || v == NULL) return NULL;
567      if (luma_size == 0 || u_size == 0 || v_size == 0) return NULL;
568      if (luma_stride == 0 || u_stride == 0 || v_stride == 0) return NULL;
569      if (a != NULL) {
570        if (a_size == 0 || a_stride == 0) return NULL;
571      }
572      colorspace = (a == NULL) ? MODE_YUV : MODE_YUVA;
573    }
574    idec = WebPINewDecoder(NULL);
575    if (idec == NULL) return NULL;
576    idec->output_.colorspace = colorspace;
577    idec->output_.is_external_memory = is_external_memory;
578    idec->output_.u.YUVA.y = luma;
579    idec->output_.u.YUVA.y_stride = luma_stride;
580    idec->output_.u.YUVA.y_size = luma_size;
581    idec->output_.u.YUVA.u = u;
582    idec->output_.u.YUVA.u_stride = u_stride;
583    idec->output_.u.YUVA.u_size = u_size;
584    idec->output_.u.YUVA.v = v;
585    idec->output_.u.YUVA.v_stride = v_stride;
586    idec->output_.u.YUVA.v_size = v_size;
587    idec->output_.u.YUVA.a = a;
588    idec->output_.u.YUVA.a_stride = a_stride;
589    idec->output_.u.YUVA.a_size = a_size;
590    return idec;
591  }
592  WebPIDecoder* WebPINewYUV(uint8_t* luma, size_t luma_size, int luma_stride,
593                            uint8_t* u, size_t u_size, int u_stride,
594                            uint8_t* v, size_t v_size, int v_stride) {
595    return WebPINewYUVA(luma, luma_size, luma_stride,
596                        u, u_size, u_stride,
597                        v, v_size, v_stride,
598                        NULL, 0, 0);
599  }
600  static VP8StatusCode IDecCheckStatus(const WebPIDecoder* const idec) {
601    assert(idec);
602    if (idec->state_ == STATE_ERROR) {
603      return VP8_STATUS_BITSTREAM_ERROR;
604    }
605    if (idec->state_ == STATE_DONE) {
606      return VP8_STATUS_OK;
607    }
608    return VP8_STATUS_SUSPENDED;
609  }
610  VP8StatusCode WebPIAppend(WebPIDecoder* idec,
611                            const uint8_t* data, size_t data_size) {
612    VP8StatusCode status;
613    if (idec == NULL || data == NULL) {
614      return VP8_STATUS_INVALID_PARAM;
615    }
616    status = IDecCheckStatus(idec);
617    if (status != VP8_STATUS_SUSPENDED) {
618      return status;
619    }
620    if (!CheckMemBufferMode(&idec->mem_, MEM_MODE_APPEND)) {
621      return VP8_STATUS_INVALID_PARAM;
622    }
623    if (!AppendToMemBuffer(idec, data, data_size)) {
624      return VP8_STATUS_OUT_OF_MEMORY;
625    }
626    return IDecode(idec);
627  }
628  VP8StatusCode WebPIUpdate(WebPIDecoder* idec,
629                            const uint8_t* data, size_t data_size) {
630    VP8StatusCode status;
631    if (idec == NULL || data == NULL) {
632      return VP8_STATUS_INVALID_PARAM;
633    }
634    status = IDecCheckStatus(idec);
635    if (status != VP8_STATUS_SUSPENDED) {
636      return status;
637    }
638    if (!CheckMemBufferMode(&idec->mem_, MEM_MODE_MAP)) {
639      return VP8_STATUS_INVALID_PARAM;
640    }
641    if (!RemapMemBuffer(idec, data, data_size)) {
642      return VP8_STATUS_INVALID_PARAM;
643    }
644    return IDecode(idec);
645  }
646  static const WebPDecBuffer* GetOutputBuffer(const WebPIDecoder* const idec) {
647    if (idec == NULL || idec->dec_ == NULL) {
648      return NULL;
649    }
650    if (idec->state_ <= STATE_VP8_PARTS0) {
651      return NULL;
652    }
653    if (idec->final_output_ != NULL) {
654      return NULL;   
655    }
656    return idec->params_.output;
657  }
658  const WebPDecBuffer* WebPIDecodedArea(const WebPIDecoder* idec,
659                                        int* left, int* top,
660                                        int* width, int* height) {
661    const WebPDecBuffer* const src = GetOutputBuffer(idec);
662    if (left != NULL) *left = 0;
663    if (top != NULL) *top = 0;
664    if (src != NULL) {
665      if (width != NULL) *width = src->width;
666      if (height != NULL) *height = idec->params_.last_y;
667    } else {
668      if (width != NULL) *width = 0;
669      if (height != NULL) *height = 0;
670    }
671    return src;
672  }
673  uint8_t* WebPIDecGetRGB(const WebPIDecoder* idec, int* last_y,
674                          int* width, int* height, int* stride) {
675    const WebPDecBuffer* const src = GetOutputBuffer(idec);
676    if (src == NULL) return NULL;
677    if (src->colorspace >= MODE_YUV) {
678      return NULL;
679    }
680    if (last_y != NULL) *last_y = idec->params_.last_y;
681    if (width != NULL) *width = src->width;
682    if (height != NULL) *height = src->height;
683    if (stride != NULL) *stride = src->u.RGBA.stride;
684    return src->u.RGBA.rgba;
685  }
686  uint8_t* WebPIDecGetYUVA(const WebPIDecoder* idec, int* last_y,
687                           uint8_t** u, uint8_t** v, uint8_t** a,
688                           int* width, int* height,
689                           int* stride, int* uv_stride, int* a_stride) {
690    const WebPDecBuffer* const src = GetOutputBuffer(idec);
691    if (src == NULL) return NULL;
692    if (src->colorspace < MODE_YUV) {
693      return NULL;
694    }
695    if (last_y != NULL) *last_y = idec->params_.last_y;
696    if (u != NULL) *u = src->u.YUVA.u;
697    if (v != NULL) *v = src->u.YUVA.v;
698    if (a != NULL) *a = src->u.YUVA.a;
699    if (width != NULL) *width = src->width;
700    if (height != NULL) *height = src->height;
701    if (stride != NULL) *stride = src->u.YUVA.y_stride;
702    if (uv_stride != NULL) *uv_stride = src->u.YUVA.u_stride;
703    if (a_stride != NULL) *a_stride = src->u.YUVA.a_stride;
704    return src->u.YUVA.y;
705  }
706  int WebPISetIOHooks(WebPIDecoder* const idec,
707                      VP8IoPutHook put,
708                      VP8IoSetupHook setup,
709                      VP8IoTeardownHook teardown,
710                      void* user_data) {
711    if (idec == NULL || idec->state_ > STATE_WEBP_HEADER) {
712      return 0;
713    }
714    idec->io_.put = put;
715    idec->io_.setup = setup;
716    idec->io_.teardown = teardown;
717    idec->io_.opaque = user_data;
718    return 1;
719  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-idec_dec.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <string.h>
3  #include <stdlib.h>
4  #include "src/dec/alphai_dec.h"
5  #include "src/dec/webpi_dec.h"
6  #include "src/dec/vp8i_dec.h"
7  #include "src/utils/utils.h"
8  #define CHUNK_SIZE 4096
9  #define MAX_MB_SIZE 4096
10  typedef enum {
11    STATE_WEBP_HEADER,  
12    STATE_VP8_HEADER,   
13    STATE_VP8_PARTS0,
14    STATE_VP8_DATA,
15    STATE_VP8L_HEADER,
16    STATE_VP8L_DATA,
17    STATE_DONE,
18    STATE_ERROR
19  } DecState;
20  typedef enum {
21    MEM_MODE_NONE = 0,
22    MEM_MODE_APPEND,
23    MEM_MODE_MAP
24  } MemBufferMode;
25  typedef struct {
26    MemBufferMode mode_;  
27    size_t start_;        
28    size_t end_;          
29    size_t buf_size_;     
30    uint8_t* buf_;        
31    size_t part0_size_;         
32    const uint8_t* part0_buf_;  
33  } MemBuffer;
34  struct WebPIDecoder {
35    DecState state_;         
36    WebPDecParams params_;   
37    int is_lossless_;        
38    void* dec_;              
39    VP8Io io_;
40    MemBuffer mem_;          
41    WebPDecBuffer output_;   
42    WebPDecBuffer* final_output_;  
43    size_t chunk_size_;      
44    int last_mb_y_;          
45  };
46  typedef struct {
47    VP8MB left_;
48    VP8MB info_;
49    VP8BitReader token_br_;
50  } MBContext;
51  static WEBP_INLINE size_t MemDataSize(const MemBuffer* mem) {
52    return (mem->end_ - mem->start_);
53  }
54  static int NeedCompressedAlpha(const WebPIDecoder* const idec) {
55    if (idec->state_ == STATE_WEBP_HEADER) {
56      return 0;
57    }
58    if (idec->is_lossless_) {
59      return 0;  
60    } else {
61      const VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
62      assert(dec != NULL);  
63      return (dec->alpha_data_ != NULL) && !dec->is_alpha_decoded_;
64    }
65  }
66  static void DoRemap(WebPIDecoder* const idec, ptrdiff_t offset) {
67    MemBuffer* const mem = &idec->mem_;
68    const uint8_t* const new_base = mem->buf_ + mem->start_;
69    idec->io_.data = new_base;
70    idec->io_.data_size = MemDataSize(mem);
71    if (idec->dec_ != NULL) {
72      if (!idec->is_lossless_) {
73        VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
74        const uint32_t last_part = dec->num_parts_minus_one_;
75        if (offset != 0) {
76          uint32_t p;
77          for (p = 0; p <= last_part; ++p) {
78            VP8RemapBitReader(dec->parts_ + p, offset);
79          }
80          if (mem->mode_ == MEM_MODE_MAP) {
81            VP8RemapBitReader(&dec->br_, offset);
82          }
83        }
84        {
85          const uint8_t* const last_start = dec->parts_[last_part].buf_;
86          VP8BitReaderSetBuffer(&dec->parts_[last_part], last_start,
87                                mem->buf_ + mem->end_ - last_start);
88        }
89        if (NeedCompressedAlpha(idec)) {
90          ALPHDecoder* const alph_dec = dec->alph_dec_;
91          dec->alpha_data_ += offset;
92          if (alph_dec != NULL && alph_dec->vp8l_dec_ != NULL) {
93            if (alph_dec->method_ == ALPHA_LOSSLESS_COMPRESSION) {
94              VP8LDecoder* const alph_vp8l_dec = alph_dec->vp8l_dec_;
95              assert(dec->alpha_data_size_ >= ALPHA_HEADER_LEN);
96              VP8LBitReaderSetBuffer(&alph_vp8l_dec->br_,
97                                     dec->alpha_data_ + ALPHA_HEADER_LEN,
98                                     dec->alpha_data_size_ - ALPHA_HEADER_LEN);
99            } else {  
100            }
101          }
102        }
103      } else {    
104        VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
105        VP8LBitReaderSetBuffer(&dec->br_, new_base, MemDataSize(mem));
106      }
107    }
108  }
109  static int AppendToMemBuffer(WebPIDecoder* const idec,
110                               const uint8_t* const data, size_t data_size) {
111    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
112    MemBuffer* const mem = &idec->mem_;
113    const int need_compressed_alpha = NeedCompressedAlpha(idec);
114    const uint8_t* const old_start =
115        (mem->buf_ == NULL) ? NULL : mem->buf_ + mem->start_;
116    const uint8_t* const old_base =
117        need_compressed_alpha ? dec->alpha_data_ : old_start;
118    assert(mem->buf_ != NULL || mem->start_ == 0);
119    assert(mem->mode_ == MEM_MODE_APPEND);
120    if (data_size > MAX_CHUNK_PAYLOAD) {
121      return 0;
122    }
123    if (mem->end_ + data_size > mem->buf_size_) {  
124      const size_t new_mem_start = old_start - old_base;
125      const size_t current_size = MemDataSize(mem) + new_mem_start;
126      const uint64_t new_size = (uint64_t)current_size + data_size;
127      const uint64_t extra_size = (new_size + CHUNK_SIZE - 1) & ~(CHUNK_SIZE - 1);
128      uint8_t* const new_buf =
129          (uint8_t*)WebPSafeMalloc(extra_size, sizeof(*new_buf));
130      if (new_buf == NULL) return 0;
131      if (old_base != NULL) memcpy(new_buf, old_base, current_size);
132      WebPSafeFree(mem->buf_);
133      mem->buf_ = new_buf;
134      mem->buf_size_ = (size_t)extra_size;
135      mem->start_ = new_mem_start;
136      mem->end_ = current_size;
137    }
138    assert(mem->buf_ != NULL);
139    memcpy(mem->buf_ + mem->end_, data, data_size);
140    mem->end_ += data_size;
141    assert(mem->end_ <= mem->buf_size_);
142    DoRemap(idec, mem->buf_ + mem->start_ - old_start);
143    return 1;
144  }
145  static int RemapMemBuffer(WebPIDecoder* const idec,
146                            const uint8_t* const data, size_t data_size) {
147    MemBuffer* const mem = &idec->mem_;
148    const uint8_t* const old_buf = mem->buf_;
149    const uint8_t* const old_start =
150        (old_buf == NULL) ? NULL : old_buf + mem->start_;
151    assert(old_buf != NULL || mem->start_ == 0);
152    assert(mem->mode_ == MEM_MODE_MAP);
153    if (data_size < mem->buf_size_) return 0;  
154    mem->buf_ = (uint8_t*)data;
155    mem->end_ = mem->buf_size_ = data_size;
156    DoRemap(idec, mem->buf_ + mem->start_ - old_start);
157    return 1;
158  }
159  static void InitMemBuffer(MemBuffer* const mem) {
160    mem->mode_       = MEM_MODE_NONE;
161    mem->buf_        = NULL;
162    mem->buf_size_   = 0;
163    mem->part0_buf_  = NULL;
164    mem->part0_size_ = 0;
165  }
166  static void ClearMemBuffer(MemBuffer* const mem) {
167    assert(mem);
168    if (mem->mode_ == MEM_MODE_APPEND) {
169      WebPSafeFree(mem->buf_);
170      WebPSafeFree((void*)mem->part0_buf_);
171    }
172  }
173  static int CheckMemBufferMode(MemBuffer* const mem, MemBufferMode expected) {
174    if (mem->mode_ == MEM_MODE_NONE) {
175      mem->mode_ = expected;    
176    } else if (mem->mode_ != expected) {
177      return 0;         
178    }
179    assert(mem->mode_ == expected);   
180    return 1;
181  }
182  static VP8StatusCode FinishDecoding(WebPIDecoder* const idec) {
183    const WebPDecoderOptions* const options = idec->params_.options;
184    WebPDecBuffer* const output = idec->params_.output;
185    idec->state_ = STATE_DONE;
186    if (options != NULL && options->flip) {
187      const VP8StatusCode status = WebPFlipBuffer(output);
188      if (status != VP8_STATUS_OK) return status;
189    }
190    if (idec->final_output_ != NULL) {
191      WebPCopyDecBufferPixels(output, idec->final_output_);  
192      WebPFreeDecBuffer(&idec->output_);
193      *output = *idec->final_output_;
194      idec->final_output_ = NULL;
195    }
196    return VP8_STATUS_OK;
197  }
198  static void SaveContext(const VP8Decoder* dec, const VP8BitReader* token_br,
199                          MBContext* const context) {
200    context->left_ = dec->mb_info_[-1];
201    context->info_ = dec->mb_info_[dec->mb_x_];
202    context->token_br_ = *token_br;
203  }
204  static void RestoreContext(const MBContext* context, VP8Decoder* const dec,
205                             VP8BitReader* const token_br) {
206    dec->mb_info_[-1] = context->left_;
207    dec->mb_info_[dec->mb_x_] = context->info_;
208    *token_br = context->token_br_;
209  }
210  static VP8StatusCode IDecError(WebPIDecoder* const idec, VP8StatusCode error) {
211    if (idec->state_ == STATE_VP8_DATA) {
212      VP8ExitCritical((VP8Decoder*)idec->dec_, &idec->io_);
213    }
214    idec->state_ = STATE_ERROR;
215    return error;
216  }
217  static void ChangeState(WebPIDecoder* const idec, DecState new_state,
218                          size_t consumed_bytes) {
219    MemBuffer* const mem = &idec->mem_;
220    idec->state_ = new_state;
221    mem->start_ += consumed_bytes;
222    assert(mem->start_ <= mem->end_);
223    idec->io_.data = mem->buf_ + mem->start_;
224    idec->io_.data_size = MemDataSize(mem);
225  }
226  static VP8StatusCode DecodeWebPHeaders(WebPIDecoder* const idec) {
227    MemBuffer* const mem = &idec->mem_;
228    const uint8_t* data = mem->buf_ + mem->start_;
229    size_t curr_size = MemDataSize(mem);
230    VP8StatusCode status;
231    WebPHeaderStructure headers;
232    headers.data = data;
233    headers.data_size = curr_size;
234    headers.have_all_data = 0;
235    status = WebPParseHeaders(&headers);
236    if (status == VP8_STATUS_NOT_ENOUGH_DATA) {
237      return VP8_STATUS_SUSPENDED;  
238    } else if (status != VP8_STATUS_OK) {
239      return IDecError(idec, status);
240    }
241    idec->chunk_size_ = headers.compressed_size;
242    idec->is_lossless_ = headers.is_lossless;
243    if (!idec->is_lossless_) {
244      VP8Decoder* const dec = VP8New();
245      if (dec == NULL) {
246        return VP8_STATUS_OUT_OF_MEMORY;
247      }
248      idec->dec_ = dec;
249      dec->alpha_data_ = headers.alpha_data;
250      dec->alpha_data_size_ = headers.alpha_data_size;
251      ChangeState(idec, STATE_VP8_HEADER, headers.offset);
252    } else {
253      VP8LDecoder* const dec = VP8LNew();
254      if (dec == NULL) {
255        return VP8_STATUS_OUT_OF_MEMORY;
256      }
257      idec->dec_ = dec;
258      ChangeState(idec, STATE_VP8L_HEADER, headers.offset);
259    }
260    return VP8_STATUS_OK;
261  }
262  static VP8StatusCode DecodeVP8FrameHeader(WebPIDecoder* const idec) {
263    const uint8_t* data = idec->mem_.buf_ + idec->mem_.start_;
264    const size_t curr_size = MemDataSize(&idec->mem_);
265    int width, height;
266    uint32_t bits;
267    if (curr_size < VP8_FRAME_HEADER_SIZE) {
268      return VP8_STATUS_SUSPENDED;
269    }
270    if (!VP8GetInfo(data, curr_size, idec->chunk_size_, &width, &height)) {
271      return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
272    }
273    bits = data[0] | (data[1] << 8) | (data[2] << 16);
274    idec->mem_.part0_size_ = (bits >> 5) + VP8_FRAME_HEADER_SIZE;
275    idec->io_.data = data;
276    idec->io_.data_size = curr_size;
277    idec->state_ = STATE_VP8_PARTS0;
278    return VP8_STATUS_OK;
279  }
280  static VP8StatusCode CopyParts0Data(WebPIDecoder* const idec) {
281    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
282    VP8BitReader* const br = &dec->br_;
283    const size_t part_size = br->buf_end_ - br->buf_;
284    MemBuffer* const mem = &idec->mem_;
285    assert(!idec->is_lossless_);
286    assert(mem->part0_buf_ == NULL);
287    assert(part_size <= mem->part0_size_);
288    if (part_size == 0) {   
289      return VP8_STATUS_BITSTREAM_ERROR;
290    }
291    if (mem->mode_ == MEM_MODE_APPEND) {
292      uint8_t* const part0_buf = (uint8_t*)WebPSafeMalloc(1ULL, part_size);
293      if (part0_buf == NULL) {
294        return VP8_STATUS_OUT_OF_MEMORY;
295      }
296      memcpy(part0_buf, br->buf_, part_size);
297      mem->part0_buf_ = part0_buf;
298      VP8BitReaderSetBuffer(br, part0_buf, part_size);
299    } else {
300    }
301    mem->start_ += part_size;
302    return VP8_STATUS_OK;
303  }
304  static VP8StatusCode DecodePartition0(WebPIDecoder* const idec) {
305    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
306    VP8Io* const io = &idec->io_;
307    const WebPDecParams* const params = &idec->params_;
308    WebPDecBuffer* const output = params->output;
309    if (MemDataSize(&idec->mem_) < idec->mem_.part0_size_) {
310      return VP8_STATUS_SUSPENDED;
311    }
312    if (!VP8GetHeaders(dec, io)) {
313      const VP8StatusCode status = dec->status_;
314      if (status == VP8_STATUS_SUSPENDED ||
315          status == VP8_STATUS_NOT_ENOUGH_DATA) {
316        return VP8_STATUS_SUSPENDED;
317      }
318      return IDecError(idec, status);
319    }
320    dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options,
321                                         output);
322    if (dec->status_ != VP8_STATUS_OK) {
323      return IDecError(idec, dec->status_);
324    }
325    dec->mt_method_ = VP8GetThreadMethod(params->options, NULL,
326                                         io->width, io->height);
327    VP8InitDithering(params->options, dec);
328    dec->status_ = CopyParts0Data(idec);
329    if (dec->status_ != VP8_STATUS_OK) {
330      return IDecError(idec, dec->status_);
331    }
332    if (VP8EnterCritical(dec, io) != VP8_STATUS_OK) {
333      return IDecError(idec, dec->status_);
334    }
335    idec->state_ = STATE_VP8_DATA;
336    if (!VP8InitFrame(dec, io)) {
337      return IDecError(idec, dec->status_);
338    }
339    return VP8_STATUS_OK;
340  }
341  static VP8StatusCode DecodeRemaining(WebPIDecoder* const idec) {
342    VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
343    VP8Io* const io = &idec->io_;
344    if (!dec->ready_) {
345      return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
346    }
347    for (; dec->mb_y_ < dec->mb_h_; ++dec->mb_y_) {
348      if (idec->last_mb_y_ != dec->mb_y_) {
349        if (!VP8ParseIntraModeRow(&dec->br_, dec)) {
350          return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
351        }
352        idec->last_mb_y_ = dec->mb_y_;
353      }
354      for (; dec->mb_x_ < dec->mb_w_; ++dec->mb_x_) {
<span onclick='openModal()' class='match'>355        VP8BitReader* const token_br =
356            &dec->parts_[dec->mb_y_ & dec->num_parts_minus_one_];
357        MBContext context;
</span>358        SaveContext(dec, token_br, &context);
359        if (!VP8DecodeMB(dec, token_br)) {
360          if (dec->num_parts_minus_one_ == 0 &&
361              MemDataSize(&idec->mem_) > MAX_MB_SIZE) {
362            return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
363          }
364          if (dec->mt_method_ > 0) {
365            if (!WebPGetWorkerInterface()->Sync(&dec->worker_)) {
366              return IDecError(idec, VP8_STATUS_BITSTREAM_ERROR);
367            }
368          }
369          RestoreContext(&context, dec, token_br);
370          return VP8_STATUS_SUSPENDED;
371        }
372        if (dec->num_parts_minus_one_ == 0) {
373          idec->mem_.start_ = token_br->buf_ - idec->mem_.buf_;
374          assert(idec->mem_.start_ <= idec->mem_.end_);
375        }
376      }
377      VP8InitScanline(dec);   
378      if (!VP8ProcessRow(dec, io)) {
379        return IDecError(idec, VP8_STATUS_USER_ABORT);
380      }
381    }
382    if (!VP8ExitCritical(dec, io)) {
383      idec->state_ = STATE_ERROR;  
384      return IDecError(idec, VP8_STATUS_USER_ABORT);
385    }
386    dec->ready_ = 0;
387    return FinishDecoding(idec);
388  }
389  static VP8StatusCode ErrorStatusLossless(WebPIDecoder* const idec,
390                                           VP8StatusCode status) {
391    if (status == VP8_STATUS_SUSPENDED || status == VP8_STATUS_NOT_ENOUGH_DATA) {
392      return VP8_STATUS_SUSPENDED;
393    }
394    return IDecError(idec, status);
395  }
396  static VP8StatusCode DecodeVP8LHeader(WebPIDecoder* const idec) {
397    VP8Io* const io = &idec->io_;
398    VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
399    const WebPDecParams* const params = &idec->params_;
400    WebPDecBuffer* const output = params->output;
401    size_t curr_size = MemDataSize(&idec->mem_);
402    assert(idec->is_lossless_);
403    if (curr_size < (idec->chunk_size_ >> 3)) {
404      dec->status_ = VP8_STATUS_SUSPENDED;
405      return ErrorStatusLossless(idec, dec->status_);
406    }
407    if (!VP8LDecodeHeader(dec, io)) {
408      if (dec->status_ == VP8_STATUS_BITSTREAM_ERROR &&
409          curr_size < idec->chunk_size_) {
410        dec->status_ = VP8_STATUS_SUSPENDED;
411      }
412      return ErrorStatusLossless(idec, dec->status_);
413    }
414    dec->status_ = WebPAllocateDecBuffer(io->width, io->height, params->options,
415                                         output);
416    if (dec->status_ != VP8_STATUS_OK) {
417      return IDecError(idec, dec->status_);
418    }
419    idec->state_ = STATE_VP8L_DATA;
420    return VP8_STATUS_OK;
421  }
422  static VP8StatusCode DecodeVP8LData(WebPIDecoder* const idec) {
423    VP8LDecoder* const dec = (VP8LDecoder*)idec->dec_;
424    const size_t curr_size = MemDataSize(&idec->mem_);
425    assert(idec->is_lossless_);
426    dec->incremental_ = (curr_size < idec->chunk_size_);
427    if (!VP8LDecodeImage(dec)) {
428      return ErrorStatusLossless(idec, dec->status_);
429    }
430    assert(dec->status_ == VP8_STATUS_OK || dec->status_ == VP8_STATUS_SUSPENDED);
431    return (dec->status_ == VP8_STATUS_SUSPENDED) ? dec->status_
432                                                  : FinishDecoding(idec);
433  }
434  static VP8StatusCode IDecode(WebPIDecoder* idec) {
435    VP8StatusCode status = VP8_STATUS_SUSPENDED;
436    if (idec->state_ == STATE_WEBP_HEADER) {
437      status = DecodeWebPHeaders(idec);
438    } else {
439      if (idec->dec_ == NULL) {
440        return VP8_STATUS_SUSPENDED;    
441      }
442    }
443    if (idec->state_ == STATE_VP8_HEADER) {
444      status = DecodeVP8FrameHeader(idec);
445    }
446    if (idec->state_ == STATE_VP8_PARTS0) {
447      status = DecodePartition0(idec);
448    }
449    if (idec->state_ == STATE_VP8_DATA) {
450      const VP8Decoder* const dec = (VP8Decoder*)idec->dec_;
451      if (dec == NULL) {
452        return VP8_STATUS_SUSPENDED;  
453      }
454      status = DecodeRemaining(idec);
455    }
456    if (idec->state_ == STATE_VP8L_HEADER) {
457      status = DecodeVP8LHeader(idec);
458    }
459    if (idec->state_ == STATE_VP8L_DATA) {
460      status = DecodeVP8LData(idec);
461    }
462    return status;
463  }
464  static WebPIDecoder* NewDecoder(WebPDecBuffer* const output_buffer,
465                                  const WebPBitstreamFeatures* const features) {
466    WebPIDecoder* idec = (WebPIDecoder*)WebPSafeCalloc(1ULL, sizeof(*idec));
467    if (idec == NULL) {
468      return NULL;
469    }
470    idec->state_ = STATE_WEBP_HEADER;
471    idec->chunk_size_ = 0;
472    idec->last_mb_y_ = -1;
473    InitMemBuffer(&idec->mem_);
474    WebPInitDecBuffer(&idec->output_);
475    VP8InitIo(&idec->io_);
476    WebPResetDecParams(&idec->params_);
477    if (output_buffer == NULL || WebPAvoidSlowMemory(output_buffer, features)) {
478      idec->params_.output = &idec->output_;
479      idec->final_output_ = output_buffer;
480      if (output_buffer != NULL) {
481        idec->params_.output->colorspace = output_buffer->colorspace;
482      }
483    } else {
484      idec->params_.output = output_buffer;
485      idec->final_output_ = NULL;
486    }
487    WebPInitCustomIo(&idec->params_, &idec->io_);  
488    return idec;
489  }
490  WebPIDecoder* WebPINewDecoder(WebPDecBuffer* output_buffer) {
491    return NewDecoder(output_buffer, NULL);
492  }
493  WebPIDecoder* WebPIDecode(const uint8_t* data, size_t data_size,
494                            WebPDecoderConfig* config) {
495    WebPIDecoder* idec;
496    WebPBitstreamFeatures tmp_features;
497    WebPBitstreamFeatures* const features =
498        (config == NULL) ? &tmp_features : &config->input;
499    memset(&tmp_features, 0, sizeof(tmp_features));
500    if (data != NULL && data_size > 0) {
501      if (WebPGetFeatures(data, data_size, features) != VP8_STATUS_OK) {
502        return NULL;
503      }
504    }
505    idec = (config != NULL) ? NewDecoder(&config->output, features)
506                            : NewDecoder(NULL, features);
507    if (idec == NULL) {
508      return NULL;
509    }
510    if (config != NULL) {
511      idec->params_.options = &config->options;
512    }
513    return idec;
514  }
515  void WebPIDelete(WebPIDecoder* idec) {
516    if (idec == NULL) return;
517    if (idec->dec_ != NULL) {
518      if (!idec->is_lossless_) {
519        if (idec->state_ == STATE_VP8_DATA) {
520          VP8ExitCritical((VP8Decoder*)idec->dec_, &idec->io_);
521        }
522        VP8Delete((VP8Decoder*)idec->dec_);
523      } else {
524        VP8LDelete((VP8LDecoder*)idec->dec_);
525      }
526    }
527    ClearMemBuffer(&idec->mem_);
528    WebPFreeDecBuffer(&idec->output_);
529    WebPSafeFree(idec);
530  }
531  WebPIDecoder* WebPINewRGB(WEBP_CSP_MODE csp, uint8_t* output_buffer,
532                            size_t output_buffer_size, int output_stride) {
533    const int is_external_memory = (output_buffer != NULL) ? 1 : 0;
534    WebPIDecoder* idec;
535    if (csp >= MODE_YUV) return NULL;
536    if (is_external_memory == 0) {    
537      output_buffer_size = 0;
538      output_stride = 0;
539    } else {  
540      if (output_stride == 0 || output_buffer_size == 0) {
541        return NULL;   
542      }
543    }
544    idec = WebPINewDecoder(NULL);
545    if (idec == NULL) return NULL;
546    idec->output_.colorspace = csp;
547    idec->output_.is_external_memory = is_external_memory;
548    idec->output_.u.RGBA.rgba = output_buffer;
549    idec->output_.u.RGBA.stride = output_stride;
550    idec->output_.u.RGBA.size = output_buffer_size;
551    return idec;
552  }
553  WebPIDecoder* WebPINewYUVA(uint8_t* luma, size_t luma_size, int luma_stride,
554                             uint8_t* u, size_t u_size, int u_stride,
555                             uint8_t* v, size_t v_size, int v_stride,
556                             uint8_t* a, size_t a_size, int a_stride) {
557    const int is_external_memory = (luma != NULL) ? 1 : 0;
558    WebPIDecoder* idec;
559    WEBP_CSP_MODE colorspace;
560    if (is_external_memory == 0) {    
561      luma_size = u_size = v_size = a_size = 0;
562      luma_stride = u_stride = v_stride = a_stride = 0;
563      u = v = a = NULL;
564      colorspace = MODE_YUVA;
565    } else {  
566      if (u == NULL || v == NULL) return NULL;
567      if (luma_size == 0 || u_size == 0 || v_size == 0) return NULL;
568      if (luma_stride == 0 || u_stride == 0 || v_stride == 0) return NULL;
569      if (a != NULL) {
570        if (a_size == 0 || a_stride == 0) return NULL;
571      }
572      colorspace = (a == NULL) ? MODE_YUV : MODE_YUVA;
573    }
574    idec = WebPINewDecoder(NULL);
575    if (idec == NULL) return NULL;
576    idec->output_.colorspace = colorspace;
577    idec->output_.is_external_memory = is_external_memory;
578    idec->output_.u.YUVA.y = luma;
579    idec->output_.u.YUVA.y_stride = luma_stride;
580    idec->output_.u.YUVA.y_size = luma_size;
581    idec->output_.u.YUVA.u = u;
582    idec->output_.u.YUVA.u_stride = u_stride;
583    idec->output_.u.YUVA.u_size = u_size;
584    idec->output_.u.YUVA.v = v;
585    idec->output_.u.YUVA.v_stride = v_stride;
586    idec->output_.u.YUVA.v_size = v_size;
587    idec->output_.u.YUVA.a = a;
588    idec->output_.u.YUVA.a_stride = a_stride;
589    idec->output_.u.YUVA.a_size = a_size;
590    return idec;
591  }
592  WebPIDecoder* WebPINewYUV(uint8_t* luma, size_t luma_size, int luma_stride,
593                            uint8_t* u, size_t u_size, int u_stride,
594                            uint8_t* v, size_t v_size, int v_stride) {
595    return WebPINewYUVA(luma, luma_size, luma_stride,
596                        u, u_size, u_stride,
597                        v, v_size, v_stride,
598                        NULL, 0, 0);
599  }
600  static VP8StatusCode IDecCheckStatus(const WebPIDecoder* const idec) {
601    assert(idec);
602    if (idec->state_ == STATE_ERROR) {
603      return VP8_STATUS_BITSTREAM_ERROR;
604    }
605    if (idec->state_ == STATE_DONE) {
606      return VP8_STATUS_OK;
607    }
608    return VP8_STATUS_SUSPENDED;
609  }
610  VP8StatusCode WebPIAppend(WebPIDecoder* idec,
611                            const uint8_t* data, size_t data_size) {
612    VP8StatusCode status;
613    if (idec == NULL || data == NULL) {
614      return VP8_STATUS_INVALID_PARAM;
615    }
616    status = IDecCheckStatus(idec);
617    if (status != VP8_STATUS_SUSPENDED) {
618      return status;
619    }
620    if (!CheckMemBufferMode(&idec->mem_, MEM_MODE_APPEND)) {
621      return VP8_STATUS_INVALID_PARAM;
622    }
623    if (!AppendToMemBuffer(idec, data, data_size)) {
624      return VP8_STATUS_OUT_OF_MEMORY;
625    }
626    return IDecode(idec);
627  }
628  VP8StatusCode WebPIUpdate(WebPIDecoder* idec,
629                            const uint8_t* data, size_t data_size) {
630    VP8StatusCode status;
631    if (idec == NULL || data == NULL) {
632      return VP8_STATUS_INVALID_PARAM;
633    }
634    status = IDecCheckStatus(idec);
635    if (status != VP8_STATUS_SUSPENDED) {
636      return status;
637    }
638    if (!CheckMemBufferMode(&idec->mem_, MEM_MODE_MAP)) {
639      return VP8_STATUS_INVALID_PARAM;
640    }
641    if (!RemapMemBuffer(idec, data, data_size)) {
642      return VP8_STATUS_INVALID_PARAM;
643    }
644    return IDecode(idec);
645  }
646  static const WebPDecBuffer* GetOutputBuffer(const WebPIDecoder* const idec) {
647    if (idec == NULL || idec->dec_ == NULL) {
648      return NULL;
649    }
650    if (idec->state_ <= STATE_VP8_PARTS0) {
651      return NULL;
652    }
653    if (idec->final_output_ != NULL) {
654      return NULL;   
655    }
656    return idec->params_.output;
657  }
658  const WebPDecBuffer* WebPIDecodedArea(const WebPIDecoder* idec,
659                                        int* left, int* top,
660                                        int* width, int* height) {
661    const WebPDecBuffer* const src = GetOutputBuffer(idec);
662    if (left != NULL) *left = 0;
663    if (top != NULL) *top = 0;
664    if (src != NULL) {
665      if (width != NULL) *width = src->width;
666      if (height != NULL) *height = idec->params_.last_y;
667    } else {
668      if (width != NULL) *width = 0;
669      if (height != NULL) *height = 0;
670    }
671    return src;
672  }
673  uint8_t* WebPIDecGetRGB(const WebPIDecoder* idec, int* last_y,
674                          int* width, int* height, int* stride) {
675    const WebPDecBuffer* const src = GetOutputBuffer(idec);
676    if (src == NULL) return NULL;
677    if (src->colorspace >= MODE_YUV) {
678      return NULL;
679    }
680    if (last_y != NULL) *last_y = idec->params_.last_y;
681    if (width != NULL) *width = src->width;
682    if (height != NULL) *height = src->height;
683    if (stride != NULL) *stride = src->u.RGBA.stride;
684    return src->u.RGBA.rgba;
685  }
686  uint8_t* WebPIDecGetYUVA(const WebPIDecoder* idec, int* last_y,
687                           uint8_t** u, uint8_t** v, uint8_t** a,
688                           int* width, int* height,
689                           int* stride, int* uv_stride, int* a_stride) {
690    const WebPDecBuffer* const src = GetOutputBuffer(idec);
691    if (src == NULL) return NULL;
692    if (src->colorspace < MODE_YUV) {
693      return NULL;
694    }
695    if (last_y != NULL) *last_y = idec->params_.last_y;
696    if (u != NULL) *u = src->u.YUVA.u;
697    if (v != NULL) *v = src->u.YUVA.v;
698    if (a != NULL) *a = src->u.YUVA.a;
699    if (width != NULL) *width = src->width;
700    if (height != NULL) *height = src->height;
701    if (stride != NULL) *stride = src->u.YUVA.y_stride;
702    if (uv_stride != NULL) *uv_stride = src->u.YUVA.u_stride;
703    if (a_stride != NULL) *a_stride = src->u.YUVA.a_stride;
704    return src->u.YUVA.y;
705  }
706  int WebPISetIOHooks(WebPIDecoder* const idec,
707                      VP8IoPutHook put,
708                      VP8IoSetupHook setup,
709                      VP8IoTeardownHook teardown,
710                      void* user_data) {
711    if (idec == NULL || idec->state_ > STATE_WEBP_HEADER) {
712      return 0;
713    }
714    idec->io_.put = put;
715    idec->io_.setup = setup;
716    idec->io_.teardown = teardown;
717    idec->io_.opaque = user_data;
718    return 1;
719  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-idec_dec.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-idec_dec.c</div>
                </div>
                <div class="column column_space"><pre><code>355        VP8BitReader* const token_br =
356            &dec->parts_[dec->mb_y_ & dec->num_parts_minus_one_];
357        MBContext context;
</pre></code></div>
                <div class="column column_space"><pre><code>355        VP8BitReader* const token_br =
356            &dec->parts_[dec->mb_y_ & dec->num_parts_minus_one_];
357        MBContext context;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    