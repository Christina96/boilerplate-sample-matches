
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.03125%, Tokens: 9</h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_nfct.h</h3>
            <pre><code>1  #ifndef NRFX_NFCT_H__
2  #define NRFX_NFCT_H__
3  #include <nrfx.h>
4  #include <hal/nrf_nfct.h>
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  #define NRFX_NFCT_NFCID1_SINGLE_SIZE 4u  
9  #define NRFX_NFCT_NFCID1_DOUBLE_SIZE 7u  
10  #define NRFX_NFCT_NFCID1_TRIPLE_SIZE 10u 
11  #define NRFX_NFCT_NFCID1_DEFAULT_LEN NRFX_NFCT_NFCID1_DOUBLE_SIZE 
12  typedef enum
13  {
14      NRFX_NFCT_STATE_DISABLED  = NRF_NFCT_TASK_DISABLE,  
15      NRFX_NFCT_STATE_SENSING   = NRF_NFCT_TASK_SENSE,    
16      NRFX_NFCT_STATE_ACTIVATED = NRF_NFCT_TASK_ACTIVATE, 
17  } nrfx_nfct_state_t;
18  typedef enum
19  {
20      NRFX_NFCT_ACTIVE_STATE_IDLE  = NRF_NFCT_TASK_GOIDLE,  
21      NRFX_NFCT_ACTIVE_STATE_SLEEP = NRF_NFCT_TASK_GOSLEEP, 
22      NRFX_NFCT_ACTIVE_STATE_DEFAULT,                       
23  } nrfx_nfct_active_state_t;
24  typedef enum
25  {
26      NRFX_NFCT_EVT_FIELD_DETECTED = NRF_NFCT_INT_FIELDDETECTED_MASK, 
27      NRFX_NFCT_EVT_FIELD_LOST     = NRF_NFCT_INT_FIELDLOST_MASK,     
28      NRFX_NFCT_EVT_SELECTED       = NRF_NFCT_INT_SELECTED_MASK,      
29      NRFX_NFCT_EVT_RX_FRAMESTART  = NRF_NFCT_INT_RXFRAMESTART_MASK,  
30      NRFX_NFCT_EVT_RX_FRAMEEND    = NRF_NFCT_INT_RXFRAMEEND_MASK,    
31      NRFX_NFCT_EVT_TX_FRAMESTART  = NRF_NFCT_INT_TXFRAMESTART_MASK,  
32      NRFX_NFCT_EVT_TX_FRAMEEND    = NRF_NFCT_INT_TXFRAMEEND_MASK,    
33      NRFX_NFCT_EVT_ERROR          = NRF_NFCT_INT_ERROR_MASK,         
34  } nrfx_nfct_evt_id_t;
35  typedef enum
36  {
37      NRFX_NFCT_ERROR_FRAMEDELAYTIMEOUT, 
38      NRFX_NFCT_ERROR_NUM,               
39  } nrfx_nfct_error_t;
40  typedef enum
41  {
42      NRFX_NFCT_PARAM_ID_FDT,     
43      NRFX_NFCT_PARAM_ID_SEL_RES, 
44      NRFX_NFCT_PARAM_ID_NFCID1,  
<span onclick='openModal()' class='match'>45  } nrfx_nfct_param_id_t;
46  typedef struct
47  {
48      uint8_t const * p_id;    
49      uint8_t         id_size; 
50  } nrfx_nfct_nfcid1_t;
51  typedef struct
52  {
</span>53      nrfx_nfct_param_id_t   id;               
54      union
55      {
56          uint32_t           fdt;              
57          uint8_t            sel_res_protocol; 
58          nrfx_nfct_nfcid1_t nfcid1;           
59      } data;                                  
60  } nrfx_nfct_param_t;
61  typedef struct
62  {
63      uint32_t        data_size; 
64      uint8_t const * p_data;    
65  } nrfx_nfct_data_desc_t;
66  typedef struct
67  {
68      uint32_t              rx_status; 
69      nrfx_nfct_data_desc_t rx_data;   
70  } nrfx_nfct_evt_rx_frameend_t;
71  typedef struct
72  {
73      nrfx_nfct_data_desc_t tx_data; 
74  } nrfx_nfct_evt_tx_framestart_t;
75  typedef struct
76  {
77      nrfx_nfct_error_t reason; 
78  } nrfx_nfct_evt_error_t;
79  typedef struct
80  {
81      nrfx_nfct_evt_id_t evt_id;                       
82      union
83      {
84          nrfx_nfct_evt_rx_frameend_t   rx_frameend;   
85          nrfx_nfct_evt_tx_framestart_t tx_framestart; 
86          nrfx_nfct_evt_error_t         error;         
87      } params;                                        
88  } nrfx_nfct_evt_t;
89  typedef void (*nrfx_nfct_handler_t)(nrfx_nfct_evt_t const * p_event);
90  typedef struct
91  {
92      uint32_t            rxtx_int_mask; 
93      nrfx_nfct_handler_t cb;            
94  } nrfx_nfct_config_t;
95  nrfx_err_t nrfx_nfct_init(nrfx_nfct_config_t const * p_config);
96  void nrfx_nfct_uninit(void);
97  void nrfx_nfct_enable(void);
98  void nrfx_nfct_disable(void);
99  bool nrfx_nfct_field_check(void);
100  void nrfx_nfct_rx(nrfx_nfct_data_desc_t const * p_rx_data);
101  nrfx_err_t nrfx_nfct_tx(nrfx_nfct_data_desc_t const * p_tx_data,
102                          nrf_nfct_frame_delay_mode_t   delay_mode);
103  void nrfx_nfct_state_force(nrfx_nfct_state_t state);
104  void nrfx_nfct_init_substate_force(nrfx_nfct_active_state_t sub_state);
105  nrfx_err_t nrfx_nfct_parameter_set(nrfx_nfct_param_t const * p_param);
106  nrfx_err_t nrfx_nfct_nfcid1_default_bytes_get(uint8_t * const p_nfcid1_buff,
107                                                uint32_t        nfcid1_buff_len);
108  void nrfx_nfct_autocolres_enable(void);
109  void nrfx_nfct_autocolres_disable(void);
110  void nrfx_nfct_irq_handler(void);
111  #ifdef __cplusplus
112  }
113  #endif
114  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-indirect_6.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef problem *(*mkcld_t) (const problem_rdft *p);
3  typedef struct {
4       rdftapply apply;
5       problem *(*mkcld)(const problem_rdft *p);
6       const char *nam;
<span onclick='openModal()' class='match'>7  } ndrct_adt;
8  typedef struct {
9       solver super;
10       const ndrct_adt *adt;
11  } S;
12  typedef struct {
</span>13       plan_rdft super;
14       plan *cldcpy, *cld;
15       const S *slv;
16  } P;
17  static void apply_before(const plan *ego_, R *I, R *O)
18  {
19       const P *ego = (const P *) ego_;
20       {
21            plan_rdft *cldcpy = (plan_rdft *) ego->cldcpy;
22            cldcpy->apply(ego->cldcpy, I, O);
23       }
24       {
25            plan_rdft *cld = (plan_rdft *) ego->cld;
26            cld->apply(ego->cld, O, O);
27       }
28  }
29  static problem *mkcld_before(const problem_rdft *p)
30  {
31       return X(mkproblem_rdft_d)(X(tensor_copy_inplace)(p->sz, INPLACE_OS),
32  				X(tensor_copy_inplace)(p->vecsz, INPLACE_OS),
33  				p->O, p->O, p->kind);
34  }
35  static const ndrct_adt adt_before =
36  {
37       apply_before, mkcld_before, "rdft-indirect-before"
38  };
39  static void apply_after(const plan *ego_, R *I, R *O)
40  {
41       const P *ego = (const P *) ego_;
42       {
43            plan_rdft *cld = (plan_rdft *) ego->cld;
44            cld->apply(ego->cld, I, I);
45       }
46       {
47            plan_rdft *cldcpy = (plan_rdft *) ego->cldcpy;
48            cldcpy->apply(ego->cldcpy, I, O);
49       }
50  }
51  static problem *mkcld_after(const problem_rdft *p)
52  {
53       return X(mkproblem_rdft_d)(X(tensor_copy_inplace)(p->sz, INPLACE_IS),
54  				X(tensor_copy_inplace)(p->vecsz, INPLACE_IS),
55  				p->I, p->I, p->kind);
56  }
57  static const ndrct_adt adt_after =
58  {
59       apply_after, mkcld_after, "rdft-indirect-after"
60  };
61  static void destroy(plan *ego_)
62  {
63       P *ego = (P *) ego_;
64       X(plan_destroy_internal)(ego->cld);
65       X(plan_destroy_internal)(ego->cldcpy);
66  }
67  static void awake(plan *ego_, enum wakefulness wakefulness)
68  {
69       P *ego = (P *) ego_;
70       X(plan_awake)(ego->cldcpy, wakefulness);
71       X(plan_awake)(ego->cld, wakefulness);
72  }
73  static void print(const plan *ego_, printer *p)
74  {
75       const P *ego = (const P *) ego_;
76       const S *s = ego->slv;
77       p->print(p, "(%s%(%p%)%(%p%))", s->adt->nam, ego->cld, ego->cldcpy);
78  }
79  static int applicable0(const solver *ego_, const problem *p_,
80  		       const planner *plnr)
81  {
82       const S *ego = (const S *) ego_;
83       const problem_rdft *p = (const problem_rdft *) p_;
84       return (1
85  	     && FINITE_RNK(p->vecsz->rnk)
86  	     && p->sz->rnk > 0
87  	     && (0
88  		 || (p->I == p->O
89  		     && !(X(tensor_inplace_strides2)(p->sz, p->vecsz)))
90  		 || (p->I != p->O && ego->adt->apply == apply_after
91  		     && !NO_DESTROY_INPUTP(plnr)
92  		     && X(tensor_min_istride)(p->sz) <= 2
93  		     && X(tensor_min_ostride)(p->sz) > 2)
94  		 || (p->I != p->O && ego->adt->apply == apply_before
95  		     && X(tensor_min_ostride)(p->sz) <= 2
96  		     && X(tensor_min_istride)(p->sz) > 2)
97  		  )
98  	  );
99  }
100  static int applicable(const solver *ego_, const problem *p_,
101  		      const planner *plnr)
102  {
103       if (!applicable0(ego_, p_, plnr)) return 0;
104       if (NO_INDIRECT_OP_P(plnr)) {
105  	  const problem_rdft *p = (const problem_rdft *)p_;
106  	  if (p->I != p->O) return 0;
107       }
108       return 1;
109  }
110  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
111  {
112       const problem_rdft *p = (const problem_rdft *) p_;
113       const S *ego = (const S *) ego_;
114       P *pln;
115       plan *cld = 0, *cldcpy = 0;
116       static const plan_adt padt = {
117  	  X(rdft_solve), awake, print, destroy
118       };
119       if (!applicable(ego_, p_, plnr))
120            return (plan *) 0;
121       cldcpy = X(mkplan_d)(plnr,
122  			  X(mkproblem_rdft_0_d)(
123  			       X(tensor_append)(p->vecsz, p->sz),
124  			       p->I, p->O));
125       if (!cldcpy) goto nada;
126       cld = X(mkplan_f_d)(plnr, ego->adt->mkcld(p), NO_BUFFERING, 0, 0);
127       if (!cld) goto nada;
128       pln = MKPLAN_RDFT(P, &padt, ego->adt->apply);
129       pln->cld = cld;
130       pln->cldcpy = cldcpy;
131       pln->slv = ego;
132       X(ops_add)(&cld->ops, &cldcpy->ops, &pln->super.super.ops);
133       return &(pln->super.super);
134   nada:
135       X(plan_destroy_internal)(cld);
136       X(plan_destroy_internal)(cldcpy);
137       return (plan *)0;
138  }
139  static solver *mksolver(const ndrct_adt *adt)
140  {
141       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
142       S *slv = MKSOLVER(S, &sadt);
143       slv->adt = adt;
144       return &(slv->super);
145  }
146  void X(rdft_indirect_register)(planner *p)
147  {
148       unsigned i;
149       static const ndrct_adt *const adts[] = {
150  	  &adt_before, &adt_after
151       };
152       for (i = 0; i < sizeof(adts) / sizeof(adts[0]); ++i)
153            REGISTER_SOLVER(p, mksolver(adts[i]));
154  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_nfct.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-indirect_6.c</div>
                </div>
                <div class="column column_space"><pre><code>45  } nrfx_nfct_param_id_t;
46  typedef struct
47  {
48      uint8_t const * p_id;    
49      uint8_t         id_size; 
50  } nrfx_nfct_nfcid1_t;
51  typedef struct
52  {
</pre></code></div>
                <div class="column column_space"><pre><code>7  } ndrct_adt;
8  typedef struct {
9       solver super;
10       const ndrct_adt *adt;
11  } S;
12  typedef struct {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    