
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.38353196099675%, Tokens: 11</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ph.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  #include "jemalloc/internal/ph.h"
3  typedef struct node_s node_t;
4  struct node_s {
5  #define NODE_MAGIC 0x9823af7e
6  	uint32_t magic;
7  	phn(node_t) link;
8  	uint64_t key;
9  };
10  static int
11  node_cmp(const node_t *a, const node_t *b) {
12  	int ret;
13  	ret = (a->key > b->key) - (a->key < b->key);
14  	if (ret == 0) {
15  		ret = (((uintptr_t)a) > ((uintptr_t)b))
16  		    - (((uintptr_t)a) < ((uintptr_t)b));
17  	}
18  	return ret;
19  }
20  static int
21  node_cmp_magic(const node_t *a, const node_t *b) {
22  	assert_u32_eq(a->magic, NODE_MAGIC, "Bad magic");
23  	assert_u32_eq(b->magic, NODE_MAGIC, "Bad magic");
24  	return node_cmp(a, b);
25  }
26  typedef ph(node_t) heap_t;
27  ph_gen(static, heap_, heap_t, node_t, link, node_cmp_magic);
28  static void
29  node_print(const node_t *node, unsigned depth) {
30  	unsigned i;
31  	node_t *leftmost_child, *sibling;
32  	for (i = 0; i < depth; i++) {
33  		malloc_printf("\t");
34  	}
35  	malloc_printf("%2"FMTu64"\n", node->key);
36  	leftmost_child = phn_lchild_get(node_t, link, node);
37  	if (leftmost_child == NULL) {
38  		return;
39  	}
40  	node_print(leftmost_child, depth + 1);
41  	for (sibling = phn_next_get(node_t, link, leftmost_child); sibling !=
42  	    NULL; sibling = phn_next_get(node_t, link, sibling)) {
43  		node_print(sibling, depth + 1);
44  	}
45  }
46  static void
47  heap_print(const heap_t *heap) {
48  	node_t *auxelm;
49  	malloc_printf("vvv heap %p vvv\n", heap);
50  	if (heap->ph_root == NULL) {
51  		goto label_return;
52  	}
53  	node_print(heap->ph_root, 0);
54  	for (auxelm = phn_next_get(node_t, link, heap->ph_root); auxelm != NULL;
55  	    auxelm = phn_next_get(node_t, link, auxelm)) {
56  		assert_ptr_eq(phn_next_get(node_t, link, phn_prev_get(node_t,
57  		    link, auxelm)), auxelm,
58  		    "auxelm's prev doesn't link to auxelm");
59  		node_print(auxelm, 0);
60  	}
61  label_return:
62  	malloc_printf("^^^ heap %p ^^^\n", heap);
63  }
64  static unsigned
65  node_validate(const node_t *node, const node_t *parent) {
66  	unsigned nnodes = 1;
67  	node_t *leftmost_child, *sibling;
68  	if (parent != NULL) {
69  		assert_d_ge(node_cmp_magic(node, parent), 0,
70  		    "Child is less than parent");
71  	}
72  	leftmost_child = phn_lchild_get(node_t, link, node);
73  	if (leftmost_child == NULL) {
74  		return nnodes;
75  	}
76  	assert_ptr_eq((void *)phn_prev_get(node_t, link, leftmost_child),
77  	    (void *)node, "Leftmost child does not link to node");
78  	nnodes += node_validate(leftmost_child, node);
79  	for (sibling = phn_next_get(node_t, link, leftmost_child); sibling !=
80  	    NULL; sibling = phn_next_get(node_t, link, sibling)) {
81  		assert_ptr_eq(phn_next_get(node_t, link, phn_prev_get(node_t,
82  		    link, sibling)), sibling,
83  		    "sibling's prev doesn't link to sibling");
84  		nnodes += node_validate(sibling, node);
85  	}
86  	return nnodes;
87  }
88  static unsigned
89  heap_validate(const heap_t *heap) {
90  	unsigned nnodes = 0;
91  	node_t *auxelm;
92  	if (heap->ph_root == NULL) {
93  		goto label_return;
94  	}
95  	nnodes += node_validate(heap->ph_root, NULL);
96  	for (auxelm = phn_next_get(node_t, link, heap->ph_root); auxelm != NULL;
97  	    auxelm = phn_next_get(node_t, link, auxelm)) {
98  		assert_ptr_eq(phn_next_get(node_t, link, phn_prev_get(node_t,
99  		    link, auxelm)), auxelm,
100  		    "auxelm's prev doesn't link to auxelm");
101  		nnodes += node_validate(auxelm, NULL);
102  	}
103  label_return:
104  	if (false) {
105  		heap_print(heap);
106  	}
107  	return nnodes;
108  }
109  TEST_BEGIN(test_ph_empty) {
110  	heap_t heap;
111  	heap_new(&heap);
112  	assert_true(heap_empty(&heap), "Heap should be empty");
113  	assert_ptr_null(heap_first(&heap), "Unexpected node");
114  	assert_ptr_null(heap_any(&heap), "Unexpected node");
115  }
116  TEST_END
117  static void
118  node_remove(heap_t *heap, node_t *node) {
119  	heap_remove(heap, node);
120  	node->magic = 0;
121  }
122  static node_t *
123  node_remove_first(heap_t *heap) {
124  	node_t *node = heap_remove_first(heap);
125  	node->magic = 0;
126  	return node;
127  }
128  static node_t *
129  node_remove_any(heap_t *heap) {
130  	node_t *node = heap_remove_any(heap);
131  	node->magic = 0;
132  	return node;
133  }
134  TEST_BEGIN(test_ph_random) {
135  #define NNODES 25
136  #define NBAGS 250
137  #define SEED 42
138  	sfmt_t *sfmt;
139  	uint64_t bag[NNODES];
140  	heap_t heap;
141  	node_t nodes[NNODES];
142  	unsigned i, j, k;
143  	sfmt = init_gen_rand(SEED);
144  	for (i = 0; i < NBAGS; i++) {
145  		switch (i) {
146  		case 0:
147  			for (j = 0; j < NNODES; j++) {
148  				bag[j] = j;
149  			}
150  			break;
151  		case 1:
152  			for (j = 0; j < NNODES; j++) {
153  				bag[j] = NNODES - j - 1;
154  			}
155  			break;
156  		default:
157  			for (j = 0; j < NNODES; j++) {
158  				bag[j] = gen_rand64_range(sfmt, NNODES);
159  			}
160  		}
161  		for (j = 1; j <= NNODES; j++) {
162  			heap_new(&heap);
163  			assert_u_eq(heap_validate(&heap), 0,
164  			    "Incorrect node count");
<span onclick='openModal()' class='match'>165  			for (k = 0; k < j; k++) {
166  				nodes[k].magic = NODE_MAGIC;
167  				nodes[k].key = bag[k];
168  			}
169  			for (k = 0; k < j; k++) {
</span>170  				heap_insert(&heap, &nodes[k]);
171  				if (i % 13 == 12) {
172  					assert_ptr_not_null(heap_any(&heap),
173  					    "Heap should not be empty");
174  					assert_ptr_not_null(heap_first(&heap),
175  					    "Heap should not be empty");
176  				}
177  				assert_u_eq(heap_validate(&heap), k + 1,
178  				    "Incorrect node count");
179  			}
180  			assert_false(heap_empty(&heap),
181  			    "Heap should not be empty");
182  			switch (i % 6) {
183  			case 0:
184  				for (k = 0; k < j; k++) {
185  					assert_u_eq(heap_validate(&heap), j - k,
186  					    "Incorrect node count");
187  					node_remove(&heap, &nodes[k]);
188  					assert_u_eq(heap_validate(&heap), j - k
189  					    - 1, "Incorrect node count");
190  				}
191  				break;
192  			case 1:
193  				for (k = j; k > 0; k--) {
194  					node_remove(&heap, &nodes[k-1]);
195  					assert_u_eq(heap_validate(&heap), k - 1,
196  					    "Incorrect node count");
197  				}
198  				break;
199  			case 2: {
200  				node_t *prev = NULL;
201  				for (k = 0; k < j; k++) {
202  					node_t *node = node_remove_first(&heap);
203  					assert_u_eq(heap_validate(&heap), j - k
204  					    - 1, "Incorrect node count");
205  					if (prev != NULL) {
206  						assert_d_ge(node_cmp(node,
207  						    prev), 0,
208  						    "Bad removal order");
209  					}
210  					prev = node;
211  				}
212  				break;
213  			} case 3: {
214  				node_t *prev = NULL;
215  				for (k = 0; k < j; k++) {
216  					node_t *node = heap_first(&heap);
217  					assert_u_eq(heap_validate(&heap), j - k,
218  					    "Incorrect node count");
219  					if (prev != NULL) {
220  						assert_d_ge(node_cmp(node,
221  						    prev), 0,
222  						    "Bad removal order");
223  					}
224  					node_remove(&heap, node);
225  					assert_u_eq(heap_validate(&heap), j - k
226  					    - 1, "Incorrect node count");
227  					prev = node;
228  				}
229  				break;
230  			} case 4: {
231  				for (k = 0; k < j; k++) {
232  					node_remove_any(&heap);
233  					assert_u_eq(heap_validate(&heap), j - k
234  					    - 1, "Incorrect node count");
235  				}
236  				break;
237  			} case 5: {
238  				for (k = 0; k < j; k++) {
239  					node_t *node = heap_any(&heap);
240  					assert_u_eq(heap_validate(&heap), j - k,
241  					    "Incorrect node count");
242  					node_remove(&heap, node);
243  					assert_u_eq(heap_validate(&heap), j - k
244  					    - 1, "Incorrect node count");
245  				}
246  				break;
247  			} default:
248  				not_reached();
249  			}
250  			assert_ptr_null(heap_first(&heap),
251  			    "Heap should be empty");
252  			assert_ptr_null(heap_any(&heap),
253  			    "Heap should be empty");
254  			assert_true(heap_empty(&heap), "Heap should be empty");
255  		}
256  	}
257  	fini_gen_rand(sfmt);
258  #undef NNODES
259  #undef SEED
260  }
261  TEST_END
262  int
263  main(void) {
264  	return test(
265  	    test_ph_empty,
266  	    test_ph_random);
267  }
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-image_enc.c</h3>
            <pre><code>1  #include "./image_enc.h"
2  #include <assert.h>
3  #include <string.h>
4  #ifdef WEBP_HAVE_PNG
5  #include <png.h>
6  #include <setjmp.h>   
7  #endif
8  #ifdef HAVE_WINCODEC_H
9  #ifdef __MINGW32__
10  #define INITGUID  
11  #endif
12  #define CINTERFACE
13  #define COBJMACROS
14  #define _WIN32_IE 0x500  
15  #include <ole2.h>  
16  #include <shlwapi.h>
17  #include <tchar.h>
18  #include <windows.h>
19  #include <wincodec.h>
20  #endif
21  #include "./imageio_util.h"
22  #include "../examples/unicode.h"
23  #ifdef HAVE_WINCODEC_H
24  #define IFS(fn)                                                     \
25    do {                                                              \
26      if (SUCCEEDED(hr)) {                                            \
27        hr = (fn);                                                    \
28        if (FAILED(hr)) fprintf(stderr, #fn " failed %08lx\n", hr);   \
29      }                                                               \
30    } while (0)
31  #ifdef __cplusplus
32  #define MAKE_REFGUID(x) (x)
33  #else
34  #define MAKE_REFGUID(x) &(x)
35  #endif
36  static HRESULT CreateOutputStream(const char* out_file_name,
37                                    int write_to_mem, IStream** stream) {
38    HRESULT hr = S_OK;
39    if (write_to_mem) {
40      IFS(CreateStreamOnHGlobal(NULL, TRUE, stream));
41    } else {
42      IFS(SHCreateStreamOnFile((const LPTSTR)out_file_name,
43                               STGM_WRITE | STGM_CREATE, stream));
44    }
45    if (FAILED(hr)) {
46      _ftprintf(stderr, _T("Error opening output file %s (%08lx)\n"),
47                (const LPTSTR)out_file_name, hr);
48    }
49    return hr;
50  }
51  static HRESULT WriteUsingWIC(const char* out_file_name, int use_stdout,
52                               REFGUID container_guid,
53                               uint8_t* rgb, int stride,
54                               uint32_t width, uint32_t height, int has_alpha) {
55    HRESULT hr = S_OK;
56    IWICImagingFactory* factory = NULL;
57    IWICBitmapFrameEncode* frame = NULL;
58    IWICBitmapEncoder* encoder = NULL;
59    IStream* stream = NULL;
60    WICPixelFormatGUID pixel_format = has_alpha ? GUID_WICPixelFormat32bppBGRA
61                                                : GUID_WICPixelFormat24bppBGR;
62    if (out_file_name == NULL || rgb == NULL) return E_INVALIDARG;
63    IFS(CoInitialize(NULL));
64    IFS(CoCreateInstance(MAKE_REFGUID(CLSID_WICImagingFactory), NULL,
65                         CLSCTX_INPROC_SERVER,
66                         MAKE_REFGUID(IID_IWICImagingFactory),
67                         (LPVOID*)&factory));
68    if (hr == REGDB_E_CLASSNOTREG) {
69      fprintf(stderr,
70              "Couldn't access Windows Imaging Component (are you running "
71              "Windows XP SP3 or newer?). PNG support not available. "
72              "Use -ppm or -pgm for available PPM and PGM formats.\n");
73    }
74    IFS(CreateOutputStream(out_file_name, use_stdout, &stream));
75    IFS(IWICImagingFactory_CreateEncoder(factory, container_guid, NULL,
76                                         &encoder));
77    IFS(IWICBitmapEncoder_Initialize(encoder, stream,
78                                     WICBitmapEncoderNoCache));
79    IFS(IWICBitmapEncoder_CreateNewFrame(encoder, &frame, NULL));
80    IFS(IWICBitmapFrameEncode_Initialize(frame, NULL));
81    IFS(IWICBitmapFrameEncode_SetSize(frame, width, height));
82    IFS(IWICBitmapFrameEncode_SetPixelFormat(frame, &pixel_format));
83    IFS(IWICBitmapFrameEncode_WritePixels(frame, height, stride,
84                                          height * stride, rgb));
85    IFS(IWICBitmapFrameEncode_Commit(frame));
86    IFS(IWICBitmapEncoder_Commit(encoder));
87    if (SUCCEEDED(hr) && use_stdout) {
88      HGLOBAL image;
89      IFS(GetHGlobalFromStream(stream, &image));
90      if (SUCCEEDED(hr)) {
91        HANDLE std_output = GetStdHandle(STD_OUTPUT_HANDLE);
92        DWORD mode;
93        const BOOL update_mode = GetConsoleMode(std_output, &mode);
94        const void* const image_mem = GlobalLock(image);
95        DWORD bytes_written = 0;
96        if (update_mode) SetConsoleMode(std_output, 0);
97        if (!WriteFile(std_output, image_mem, (DWORD)GlobalSize(image),
98                       &bytes_written, NULL) ||
99            bytes_written != GlobalSize(image)) {
100          hr = E_FAIL;
101        }
102        if (update_mode) SetConsoleMode(std_output, mode);
103        GlobalUnlock(image);
104      }
105    }
106    if (frame != NULL) IUnknown_Release(frame);
107    if (encoder != NULL) IUnknown_Release(encoder);
108    if (factory != NULL) IUnknown_Release(factory);
109    if (stream != NULL) IUnknown_Release(stream);
110    return hr;
111  }
112  int WebPWritePNG(const char* out_file_name, int use_stdout,
113                   const WebPDecBuffer* const buffer) {
114    const uint32_t width = buffer->width;
115    const uint32_t height = buffer->height;
116    uint8_t* const rgb = buffer->u.RGBA.rgba;
117    const int stride = buffer->u.RGBA.stride;
118    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
119    return SUCCEEDED(WriteUsingWIC(out_file_name, use_stdout,
120                                   MAKE_REFGUID(GUID_ContainerFormatPng),
121                                   rgb, stride, width, height, has_alpha));
122  }
123  #elif defined(WEBP_HAVE_PNG)    
124  static void PNGAPI PNGErrorFunction(png_structp png, png_const_charp dummy) {
125    (void)dummy;  
126    longjmp(png_jmpbuf(png), 1);
127  }
128  int WebPWritePNG(FILE* out_file, const WebPDecBuffer* const buffer) {
129    volatile png_structp png;
130    volatile png_infop info;
131    if (out_file == NULL || buffer == NULL) return 0;
132    png = png_create_write_struct(PNG_LIBPNG_VER_STRING,
133                                  NULL, PNGErrorFunction, NULL);
134    if (png == NULL) {
135      return 0;
136    }
137    info = png_create_info_struct(png);
138    if (info == NULL) {
139      png_destroy_write_struct((png_structpp)&png, NULL);
140      return 0;
141    }
142    if (setjmp(png_jmpbuf(png))) {
143      png_destroy_write_struct((png_structpp)&png, (png_infopp)&info);
144      return 0;
145    }
146    png_init_io(png, out_file);
147    {
148      const uint32_t width = buffer->width;
149      const uint32_t height = buffer->height;
150      png_bytep row = buffer->u.RGBA.rgba;
151      const int stride = buffer->u.RGBA.stride;
152      const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
153      uint32_t y;
154      png_set_IHDR(png, info, width, height, 8,
155                   has_alpha ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB,
156                   PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_DEFAULT,
157                   PNG_FILTER_TYPE_DEFAULT);
158      png_write_info(png, info);
159      for (y = 0; y < height; ++y) {
160        png_write_rows(png, &row, 1);
161        row += stride;
162      }
163    }
164    png_write_end(png, info);
165    png_destroy_write_struct((png_structpp)&png, (png_infopp)&info);
166    return 1;
167  }
168  #else    
169  int WebPWritePNG(FILE* fout, const WebPDecBuffer* const buffer) {
170    if (fout == NULL || buffer == NULL) return 0;
171    fprintf(stderr, "PNG support not compiled. Please install the libpng "
172            "development package before building.\n");
173    fprintf(stderr, "You can run with -ppm flag to decode in PPM format.\n");
174    return 0;
175  }
176  #endif
177  static int WritePPMPAM(FILE* fout, const WebPDecBuffer* const buffer,
178                         int alpha) {
179    if (fout == NULL || buffer == NULL) {
180      return 0;
181    } else {
182      const uint32_t width = buffer->width;
183      const uint32_t height = buffer->height;
184      const uint8_t* row = buffer->u.RGBA.rgba;
185      const int stride = buffer->u.RGBA.stride;
186      const size_t bytes_per_px = alpha ? 4 : 3;
187      uint32_t y;
188      if (row == NULL) return 0;
189      if (alpha) {
190        fprintf(fout, "P7\nWIDTH %u\nHEIGHT %u\nDEPTH 4\nMAXVAL 255\n"
191                      "TUPLTYPE RGB_ALPHA\nENDHDR\n", width, height);
192      } else {
193        fprintf(fout, "P6\n%u %u\n255\n", width, height);
194      }
195      for (y = 0; y < height; ++y) {
196        if (fwrite(row, width, bytes_per_px, fout) != bytes_per_px) {
197          return 0;
198        }
199        row += stride;
200      }
201    }
202    return 1;
203  }
204  int WebPWritePPM(FILE* fout, const WebPDecBuffer* const buffer) {
205    return WritePPMPAM(fout, buffer, 0);
206  }
207  int WebPWritePAM(FILE* fout, const WebPDecBuffer* const buffer) {
208    return WritePPMPAM(fout, buffer, 1);
209  }
210  int WebPWrite16bAsPGM(FILE* fout, const WebPDecBuffer* const buffer) {
211    const uint32_t width = buffer->width;
212    const uint32_t height = buffer->height;
213    const uint8_t* rgba = buffer->u.RGBA.rgba;
214    const int stride = buffer->u.RGBA.stride;
215    const uint32_t bytes_per_px = 2;
216    uint32_t y;
217    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
218    fprintf(fout, "P5\n%u %u\n255\n", width * bytes_per_px, height);
219    for (y = 0; y < height; ++y) {
220      if (fwrite(rgba, width, bytes_per_px, fout) != bytes_per_px) {
221        return 0;
222      }
223      rgba += stride;
224    }
225    return 1;
226  }
227  static void PutLE16(uint8_t* const dst, uint32_t value) {
228    dst[0] = (value >> 0) & 0xff;
229    dst[1] = (value >> 8) & 0xff;
230  }
231  static void PutLE32(uint8_t* const dst, uint32_t value) {
232    PutLE16(dst + 0, (value >>  0) & 0xffff);
233    PutLE16(dst + 2, (value >> 16) & 0xffff);
234  }
235  #define BMP_HEADER_SIZE 54
236  int WebPWriteBMP(FILE* fout, const WebPDecBuffer* const buffer) {
237    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
238    const uint32_t width = buffer->width;
239    const uint32_t height = buffer->height;
240    const uint8_t* rgba = buffer->u.RGBA.rgba;
241    const int stride = buffer->u.RGBA.stride;
242    const uint32_t bytes_per_px = has_alpha ? 4 : 3;
243    uint32_t y;
244    const uint32_t line_size = bytes_per_px * width;
245    const uint32_t bmp_stride = (line_size + 3) & ~3;   
246    const uint32_t total_size = bmp_stride * height + BMP_HEADER_SIZE;
247    uint8_t bmp_header[BMP_HEADER_SIZE] = { 0 };
248    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
249    PutLE16(bmp_header + 0, 0x4d42);                
250    PutLE32(bmp_header + 2, total_size);            
251    PutLE32(bmp_header + 6, 0);                     
252    PutLE32(bmp_header + 10, BMP_HEADER_SIZE);      
253    PutLE32(bmp_header + 14, 40);                   
254    PutLE32(bmp_header + 18, width);                
255    PutLE32(bmp_header + 22, -(int)height);         
256    PutLE16(bmp_header + 26, 1);                    
257    PutLE16(bmp_header + 28, bytes_per_px * 8);     
258    PutLE32(bmp_header + 30, 0);                    
259    PutLE32(bmp_header + 34, 0);                    
260    PutLE32(bmp_header + 38, 2400);                 
261    PutLE32(bmp_header + 42, 2400);                 
262    PutLE32(bmp_header + 46, 0);                    
263    PutLE32(bmp_header + 50, 0);                    
264    if (fwrite(bmp_header, sizeof(bmp_header), 1, fout) != 1) {
265      return 0;
266    }
267    for (y = 0; y < height; ++y) {
268      if (fwrite(rgba, line_size, 1, fout) != 1) {
269        return 0;
270      }
271      if (bmp_stride != line_size) {
272        const uint8_t zeroes[3] = { 0 };
273        if (fwrite(zeroes, bmp_stride - line_size, 1, fout) != 1) {
274          return 0;
275        }
276      }
277      rgba += stride;
278    }
279    return 1;
280  }
281  #undef BMP_HEADER_SIZE
282  #define NUM_IFD_ENTRIES 15
283  #define EXTRA_DATA_SIZE 16
284  #define EXTRA_DATA_OFFSET (10 + 12 * NUM_IFD_ENTRIES + 4)
285  #define TIFF_HEADER_SIZE (EXTRA_DATA_OFFSET + EXTRA_DATA_SIZE)
286  int WebPWriteTIFF(FILE* fout, const WebPDecBuffer* const buffer) {
287    const int has_alpha = WebPIsAlphaMode(buffer->colorspace);
288    const uint32_t width = buffer->width;
289    const uint32_t height = buffer->height;
290    const uint8_t* rgba = buffer->u.RGBA.rgba;
291    const int stride = buffer->u.RGBA.stride;
292    const uint8_t bytes_per_px = has_alpha ? 4 : 3;
293    const uint8_t assoc_alpha =
294        WebPIsPremultipliedMode(buffer->colorspace) ? 1 : 2;
295    const uint8_t num_ifd_entries = has_alpha ? NUM_IFD_ENTRIES
296                                              : NUM_IFD_ENTRIES - 1;
297    uint8_t tiff_header[TIFF_HEADER_SIZE] = {
298      0x49, 0x49, 0x2a, 0x00,   
299      8, 0, 0, 0,               
300      num_ifd_entries, 0,       
301      0x00, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
302      0x01, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
303      0x02, 0x01, 3, 0, bytes_per_px, 0, 0, 0,     
304          EXTRA_DATA_OFFSET + 0, 0, 0, 0,
305      0x03, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
306      0x06, 0x01, 3, 0, 1, 0, 0, 0, 2, 0, 0, 0,    
307      0x11, 0x01, 4, 0, 1, 0, 0, 0,                
308          TIFF_HEADER_SIZE, 0, 0, 0,               
309      0x12, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
310      0x15, 0x01, 3, 0, 1, 0, 0, 0,                
311          bytes_per_px, 0, 0, 0,
312      0x16, 0x01, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
313      0x17, 0x01, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0,    
314      0x1a, 0x01, 5, 0, 1, 0, 0, 0,                
315          EXTRA_DATA_OFFSET + 8, 0, 0, 0,
316      0x1b, 0x01, 5, 0, 1, 0, 0, 0,                
317          EXTRA_DATA_OFFSET + 8, 0, 0, 0,
318      0x1c, 0x01, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0,    
319      0x28, 0x01, 3, 0, 1, 0, 0, 0, 2, 0, 0, 0,    
320      0x52, 0x01, 3, 0, 1, 0, 0, 0,
321          assoc_alpha, 0, 0, 0,                    
322      0, 0, 0, 0,                                  
323      8, 0, 8, 0, 8, 0, 8, 0,      
324      72, 0, 0, 0, 1, 0, 0, 0      
325    };
326    uint32_t y;
327    if (fout == NULL || buffer == NULL || rgba == NULL) return 0;
328    PutLE32(tiff_header + 10 + 8, width);
329    PutLE32(tiff_header + 22 + 8, height);
330    PutLE32(tiff_header + 106 + 8, height);
331    PutLE32(tiff_header + 118 + 8, width * bytes_per_px * height);
332    if (!has_alpha) PutLE32(tiff_header + 178, 0);  
333    if (fwrite(tiff_header, sizeof(tiff_header), 1, fout) != 1) {
334      return 0;
335    }
336    for (y = 0; y < height; ++y) {
337      if (fwrite(rgba, bytes_per_px, width, fout) != width) {
338        return 0;
339      }
340      rgba += stride;
341    }
342    return 1;
343  }
344  #undef TIFF_HEADER_SIZE
345  #undef EXTRA_DATA_OFFSET
346  #undef EXTRA_DATA_SIZE
347  #undef NUM_IFD_ENTRIES
348  int WebPWriteAlphaPlane(FILE* fout, const WebPDecBuffer* const buffer) {
349    if (fout == NULL || buffer == NULL) {
350      return 0;
351    } else {
352      const uint32_t width = buffer->width;
353      const uint32_t height = buffer->height;
354      const uint8_t* a = buffer->u.YUVA.a;
355      const int a_stride = buffer->u.YUVA.a_stride;
356      uint32_t y;
357      if (a == NULL) return 0;
358      fprintf(fout, "P5\n%u %u\n255\n", width, height);
359      for (y = 0; y < height; ++y) {
360        if (fwrite(a, width, 1, fout) != 1) return 0;
361        a += a_stride;
362      }
363      return 1;
364    }
365  }
366  int WebPWritePGM(FILE* fout, const WebPDecBuffer* const buffer) {
367    if (fout == NULL || buffer == NULL) {
368      return 0;
369    } else {
370      const int width = buffer->width;
371      const int height = buffer->height;
372      const WebPYUVABuffer* const yuv = &buffer->u.YUVA;
373      const uint8_t* src_y = yuv->y;
374      const uint8_t* src_u = yuv->u;
375      const uint8_t* src_v = yuv->v;
376      const uint8_t* src_a = yuv->a;
377      const int uv_width = (width + 1) / 2;
378      const int uv_height = (height + 1) / 2;
379      const int a_height = (src_a != NULL) ? height : 0;
380      int ok = 1;
381      int y;
382      if (src_y == NULL || src_u == NULL || src_v == NULL) return 0;
383      fprintf(fout, "P5\n%d %d\n255\n",
384              (width + 1) & ~1, height + uv_height + a_height);
385      for (y = 0; ok && y < height; ++y) {
386        ok &= (fwrite(src_y, width, 1, fout) == 1);
387        if (width & 1) fputc(0, fout);    
388        src_y += yuv->y_stride;
389      }
390      for (y = 0; ok && y < uv_height; ++y) {
391        ok &= (fwrite(src_u, uv_width, 1, fout) == 1);
392        ok &= (fwrite(src_v, uv_width, 1, fout) == 1);
393        src_u += yuv->u_stride;
394        src_v += yuv->v_stride;
395      }
396      for (y = 0; ok && y < a_height; ++y) {
397        ok &= (fwrite(src_a, width, 1, fout) == 1);
398        if (width & 1) fputc(0, fout);    
399        src_a += yuv->a_stride;
400      }
401      return ok;
402    }
403  }
404  int WebPWriteYUV(FILE* fout, const WebPDecBuffer* const buffer) {
405    if (fout == NULL || buffer == NULL) {
406      return 0;
407    } else {
408      const int width = buffer->width;
409      const int height = buffer->height;
410      const WebPYUVABuffer* const yuv = &buffer->u.YUVA;
411      const uint8_t* src_y = yuv->y;
412      const uint8_t* src_u = yuv->u;
413      const uint8_t* src_v = yuv->v;
414      const uint8_t* src_a = yuv->a;
415      const int uv_width = (width + 1) / 2;
416      const int uv_height = (height + 1) / 2;
417      const int a_height = (src_a != NULL) ? height : 0;
418      int ok = 1;
419      int y;
420      if (src_y == NULL || src_u == NULL || src_v == NULL) return 0;
<span onclick='openModal()' class='match'>421      for (y = 0; ok && y < height; ++y) {
422        ok &= (fwrite(src_y, width, 1, fout) == 1);
423        src_y += yuv->y_stride;
424      }
425      for (y = 0; ok && y < uv_height; ++y) {
</span>426        ok &= (fwrite(src_u, uv_width, 1, fout) == 1);
427        src_u += yuv->u_stride;
428      }
429      for (y = 0; ok && y < uv_height; ++y) {
430        ok &= (fwrite(src_v, uv_width, 1, fout) == 1);
431        src_v += yuv->v_stride;
432      }
433      for (y = 0; ok && y < a_height; ++y) {
434        ok &= (fwrite(src_a, width, 1, fout) == 1);
435        src_a += yuv->a_stride;
436      }
437      return ok;
438    }
439  }
440  int WebPSaveImage(const WebPDecBuffer* const buffer,
441                    WebPOutputFileFormat format,
442                    const char* const out_file_name) {
443    FILE* fout = NULL;
444    int needs_open_file = 1;
445    const int use_stdout =
446        (out_file_name != NULL) && !WSTRCMP(out_file_name, "-");
447    int ok = 1;
448    if (buffer == NULL || out_file_name == NULL) return 0;
449  #ifdef HAVE_WINCODEC_H
450    needs_open_file = (format != PNG);
451  #endif
452    if (needs_open_file) {
453      fout = use_stdout ? ImgIoUtilSetBinaryMode(stdout)
454                        : WFOPEN(out_file_name, "wb");
455      if (fout == NULL) {
456        WFPRINTF(stderr, "Error opening output file %s\n",
457                 (const W_CHAR*)out_file_name);
458        return 0;
459      }
460    }
461    if (format == PNG ||
462        format == RGBA || format == BGRA || format == ARGB ||
463        format == rgbA || format == bgrA || format == Argb) {
464  #ifdef HAVE_WINCODEC_H
465      ok &= WebPWritePNG(out_file_name, use_stdout, buffer);
466  #else
467      ok &= WebPWritePNG(fout, buffer);
468  #endif
469    } else if (format == PAM) {
470      ok &= WebPWritePAM(fout, buffer);
471    } else if (format == PPM || format == RGB || format == BGR) {
472      ok &= WebPWritePPM(fout, buffer);
473    } else if (format == RGBA_4444 || format == RGB_565 || format == rgbA_4444) {
474      ok &= WebPWrite16bAsPGM(fout, buffer);
475    } else if (format == BMP) {
476      ok &= WebPWriteBMP(fout, buffer);
477    } else if (format == TIFF) {
478      ok &= WebPWriteTIFF(fout, buffer);
479    } else if (format == RAW_YUV) {
480      ok &= WebPWriteYUV(fout, buffer);
481    } else if (format == PGM || format == YUV || format == YUVA) {
482      ok &= WebPWritePGM(fout, buffer);
483    } else if (format == ALPHA_PLANE_ONLY) {
484      ok &= WebPWriteAlphaPlane(fout, buffer);
485    }
486    if (fout != NULL && fout != stdout) {
487      fclose(fout);
488    }
489    return ok;
490  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-ph.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-image_enc.c</div>
                <div class="column column_space"><pre><code>165  			for (k = 0; k < j; k++) {
166  				nodes[k].magic = NODE_MAGIC;
167  				nodes[k].key = bag[k];
168  			}
169  			for (k = 0; k < j; k++) {
</pre></code></div>
                <div class="column column_space"><pre><code>421      for (y = 0; ok && y < height; ++y) {
422        ok &= (fwrite(src_y, width, 1, fout) == 1);
423        src_y += yuv->y_stride;
424      }
425      for (y = 0; ok && y < uv_height; ++y) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    