
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.775043936731107%, Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-pixfmt.h</h3>
            <pre><code>1  #ifndef AVUTIL_PIXFMT_H
2  #define AVUTIL_PIXFMT_H
3  #include "libavutil/avconfig.h"
4  #include "version.h"
5  #define AVPALETTE_SIZE 1024
6  #define AVPALETTE_COUNT 256
7  enum AVPixelFormat {
8      AV_PIX_FMT_NONE = -1,
9      AV_PIX_FMT_YUV420P,   
10      AV_PIX_FMT_YUYV422,   
11      AV_PIX_FMT_RGB24,     
12      AV_PIX_FMT_BGR24,     
13      AV_PIX_FMT_YUV422P,   
14      AV_PIX_FMT_YUV444P,   
15      AV_PIX_FMT_YUV410P,   
16      AV_PIX_FMT_YUV411P,   
17      AV_PIX_FMT_GRAY8,     
18      AV_PIX_FMT_MONOWHITE, 
19      AV_PIX_FMT_MONOBLACK, 
20      AV_PIX_FMT_PAL8,      
21      AV_PIX_FMT_YUVJ420P,  
22      AV_PIX_FMT_YUVJ422P,  
23      AV_PIX_FMT_YUVJ444P,  
24  #if FF_API_XVMC
25      AV_PIX_FMT_XVMC_MPEG2_MC,
26      AV_PIX_FMT_XVMC_MPEG2_IDCT,
27      AV_PIX_FMT_XVMC = AV_PIX_FMT_XVMC_MPEG2_IDCT,
28  #endif &bsol;* FF_API_XVMC */
29      AV_PIX_FMT_UYVY422,   
30      AV_PIX_FMT_UYYVYY411, 
31      AV_PIX_FMT_BGR8,      
32      AV_PIX_FMT_BGR4,      
33      AV_PIX_FMT_BGR4_BYTE, 
34      AV_PIX_FMT_RGB8,      
35      AV_PIX_FMT_RGB4,      
36      AV_PIX_FMT_RGB4_BYTE, 
37      AV_PIX_FMT_NV12,      
38      AV_PIX_FMT_NV21,      
39      AV_PIX_FMT_ARGB,      
40      AV_PIX_FMT_RGBA,      
41      AV_PIX_FMT_ABGR,      
42      AV_PIX_FMT_BGRA,      
43      AV_PIX_FMT_GRAY16BE,  
44      AV_PIX_FMT_GRAY16LE,  
45      AV_PIX_FMT_YUV440P,   
46      AV_PIX_FMT_YUVJ440P,  
47      AV_PIX_FMT_YUVA420P,  
48  #if FF_API_VDPAU
49      AV_PIX_FMT_VDPAU_H264,
50      AV_PIX_FMT_VDPAU_MPEG1,
51      AV_PIX_FMT_VDPAU_MPEG2,
52      AV_PIX_FMT_VDPAU_WMV3,
53      AV_PIX_FMT_VDPAU_VC1, 
54  #endif
55      AV_PIX_FMT_RGB48BE,   
56      AV_PIX_FMT_RGB48LE,   
57      AV_PIX_FMT_RGB565BE,  
58      AV_PIX_FMT_RGB565LE,  
59      AV_PIX_FMT_RGB555BE,  
60      AV_PIX_FMT_RGB555LE,  
61      AV_PIX_FMT_BGR565BE,  
62      AV_PIX_FMT_BGR565LE,  
63      AV_PIX_FMT_BGR555BE,  
64      AV_PIX_FMT_BGR555LE,  
65  #if FF_API_VAAPI
66      AV_PIX_FMT_VAAPI_MOCO, 
67      AV_PIX_FMT_VAAPI_IDCT, 
68      AV_PIX_FMT_VAAPI_VLD,  
69      AV_PIX_FMT_VAAPI = AV_PIX_FMT_VAAPI_VLD,
70  #else
71      AV_PIX_FMT_VAAPI,
72  #endif
73      AV_PIX_FMT_YUV420P16LE,  
74      AV_PIX_FMT_YUV420P16BE,  
75      AV_PIX_FMT_YUV422P16LE,  
76      AV_PIX_FMT_YUV422P16BE,  
77      AV_PIX_FMT_YUV444P16LE,  
78      AV_PIX_FMT_YUV444P16BE,  
79  #if FF_API_VDPAU
80      AV_PIX_FMT_VDPAU_MPEG4,  
81  #endif
82      AV_PIX_FMT_DXVA2_VLD,    
83      AV_PIX_FMT_RGB444LE,  
84      AV_PIX_FMT_RGB444BE,  
85      AV_PIX_FMT_BGR444LE,  
86      AV_PIX_FMT_BGR444BE,  
87      AV_PIX_FMT_YA8,       
88      AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8, 
89      AV_PIX_FMT_GRAY8A= AV_PIX_FMT_YA8, 
90      AV_PIX_FMT_BGR48BE,   
91      AV_PIX_FMT_BGR48LE,   
92      AV_PIX_FMT_YUV420P9BE, 
93      AV_PIX_FMT_YUV420P9LE, 
94      AV_PIX_FMT_YUV420P10BE,
95      AV_PIX_FMT_YUV420P10LE,
96      AV_PIX_FMT_YUV422P10BE,
97      AV_PIX_FMT_YUV422P10LE,
98      AV_PIX_FMT_YUV444P9BE, 
99      AV_PIX_FMT_YUV444P9LE, 
100      AV_PIX_FMT_YUV444P10BE,
101      AV_PIX_FMT_YUV444P10LE,
102      AV_PIX_FMT_YUV422P9BE, 
103      AV_PIX_FMT_YUV422P9LE, 
104      AV_PIX_FMT_VDA_VLD,    
105      AV_PIX_FMT_GBRP,      
106      AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP, 
107      AV_PIX_FMT_GBRP9BE,   
108      AV_PIX_FMT_GBRP9LE,   
109      AV_PIX_FMT_GBRP10BE,  
110      AV_PIX_FMT_GBRP10LE,  
111      AV_PIX_FMT_GBRP16BE,  
112      AV_PIX_FMT_GBRP16LE,  
113      AV_PIX_FMT_YUVA422P,  
114      AV_PIX_FMT_YUVA444P,  
115      AV_PIX_FMT_YUVA420P9BE,  
116      AV_PIX_FMT_YUVA420P9LE,  
117      AV_PIX_FMT_YUVA422P9BE,  
118      AV_PIX_FMT_YUVA422P9LE,  
119      AV_PIX_FMT_YUVA444P9BE,  
120      AV_PIX_FMT_YUVA444P9LE,  
121      AV_PIX_FMT_YUVA420P10BE, 
122      AV_PIX_FMT_YUVA420P10LE, 
123      AV_PIX_FMT_YUVA422P10BE, 
124      AV_PIX_FMT_YUVA422P10LE, 
125      AV_PIX_FMT_YUVA444P10BE, 
126      AV_PIX_FMT_YUVA444P10LE, 
127      AV_PIX_FMT_YUVA420P16BE, 
128      AV_PIX_FMT_YUVA420P16LE, 
129      AV_PIX_FMT_YUVA422P16BE, 
130      AV_PIX_FMT_YUVA422P16LE, 
131      AV_PIX_FMT_YUVA444P16BE, 
132      AV_PIX_FMT_YUVA444P16LE, 
133      AV_PIX_FMT_VDPAU,     
134      AV_PIX_FMT_XYZ12LE,      
135      AV_PIX_FMT_XYZ12BE,      
136      AV_PIX_FMT_NV16,         
137      AV_PIX_FMT_NV20LE,       
138      AV_PIX_FMT_NV20BE,       
139      AV_PIX_FMT_RGBA64BE,     
140      AV_PIX_FMT_RGBA64LE,     
141      AV_PIX_FMT_BGRA64BE,     
142      AV_PIX_FMT_BGRA64LE,     
143      AV_PIX_FMT_YVYU422,   
144      AV_PIX_FMT_VDA,          
145      AV_PIX_FMT_YA16BE,       
146      AV_PIX_FMT_YA16LE,       
147      AV_PIX_FMT_GBRAP,        
148      AV_PIX_FMT_GBRAP16BE,    
149      AV_PIX_FMT_GBRAP16LE,    
150      AV_PIX_FMT_QSV,
151      AV_PIX_FMT_MMAL,
152      AV_PIX_FMT_D3D11VA_VLD,  
153      AV_PIX_FMT_CUDA,
154      AV_PIX_FMT_0RGB=0x123+4,
155      AV_PIX_FMT_RGB0,        
156      AV_PIX_FMT_0BGR,        
157      AV_PIX_FMT_BGR0,        
158      AV_PIX_FMT_YUV420P12BE, 
159      AV_PIX_FMT_YUV420P12LE, 
160      AV_PIX_FMT_YUV420P14BE, 
161      AV_PIX_FMT_YUV420P14LE, 
162      AV_PIX_FMT_YUV422P12BE, 
163      AV_PIX_FMT_YUV422P12LE, 
164      AV_PIX_FMT_YUV422P14BE, 
165      AV_PIX_FMT_YUV422P14LE, 
166      AV_PIX_FMT_YUV444P12BE, 
167      AV_PIX_FMT_YUV444P12LE, 
168      AV_PIX_FMT_YUV444P14BE, 
169      AV_PIX_FMT_YUV444P14LE, 
170      AV_PIX_FMT_GBRP12BE,    
171      AV_PIX_FMT_GBRP12LE,    
172      AV_PIX_FMT_GBRP14BE,    
173      AV_PIX_FMT_GBRP14LE,    
174      AV_PIX_FMT_YUVJ411P,    
175      AV_PIX_FMT_BAYER_BGGR8,    
176      AV_PIX_FMT_BAYER_RGGB8,    
177      AV_PIX_FMT_BAYER_GBRG8,    
178      AV_PIX_FMT_BAYER_GRBG8,    
179      AV_PIX_FMT_BAYER_BGGR16LE, 
180      AV_PIX_FMT_BAYER_BGGR16BE, 
181      AV_PIX_FMT_BAYER_RGGB16LE, 
182      AV_PIX_FMT_BAYER_RGGB16BE, 
183      AV_PIX_FMT_BAYER_GBRG16LE, 
184      AV_PIX_FMT_BAYER_GBRG16BE, 
185      AV_PIX_FMT_BAYER_GRBG16LE, 
186      AV_PIX_FMT_BAYER_GRBG16BE, 
187  #if !FF_API_XVMC
188      AV_PIX_FMT_XVMC,
189  #endif &bsol;* !FF_API_XVMC */
190      AV_PIX_FMT_YUV440P10LE, 
191      AV_PIX_FMT_YUV440P10BE, 
192      AV_PIX_FMT_YUV440P12LE, 
193      AV_PIX_FMT_YUV440P12BE, 
194      AV_PIX_FMT_AYUV64LE,    
195      AV_PIX_FMT_AYUV64BE,    
196      AV_PIX_FMT_VIDEOTOOLBOX, 
197      AV_PIX_FMT_P010LE, 
198      AV_PIX_FMT_P010BE, 
199      AV_PIX_FMT_GBRAP12BE,  
200      AV_PIX_FMT_GBRAP12LE,  
201      AV_PIX_FMT_GBRAP10BE,  
202      AV_PIX_FMT_GBRAP10LE,  
203      AV_PIX_FMT_MEDIACODEC, 
204      AV_PIX_FMT_GRAY12BE,   
205      AV_PIX_FMT_GRAY12LE,   
206      AV_PIX_FMT_GRAY10BE,   
207      AV_PIX_FMT_GRAY10LE,   
208      AV_PIX_FMT_P016LE, 
209      AV_PIX_FMT_P016BE, 
210      AV_PIX_FMT_D3D11,
211      AV_PIX_FMT_GRAY9BE,   
212      AV_PIX_FMT_GRAY9LE,   
213      AV_PIX_FMT_GBRPF32BE,  
214      AV_PIX_FMT_GBRPF32LE,  
215      AV_PIX_FMT_GBRAPF32BE, 
216      AV_PIX_FMT_GBRAPF32LE, 
217      AV_PIX_FMT_DRM_PRIME,
218      AV_PIX_FMT_NB         
219  };
220  #if AV_HAVE_BIGENDIAN
221  #   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##be
222  #else
223  #   define AV_PIX_FMT_NE(be, le) AV_PIX_FMT_##le
224  #endif
225  #define AV_PIX_FMT_RGB32   AV_PIX_FMT_NE(ARGB, BGRA)
226  #define AV_PIX_FMT_RGB32_1 AV_PIX_FMT_NE(RGBA, ABGR)
227  #define AV_PIX_FMT_BGR32   AV_PIX_FMT_NE(ABGR, RGBA)
228  #define AV_PIX_FMT_BGR32_1 AV_PIX_FMT_NE(BGRA, ARGB)
229  #define AV_PIX_FMT_0RGB32  AV_PIX_FMT_NE(0RGB, BGR0)
230  #define AV_PIX_FMT_0BGR32  AV_PIX_FMT_NE(0BGR, RGB0)
231  #define AV_PIX_FMT_GRAY9  AV_PIX_FMT_NE(GRAY9BE,  GRAY9LE)
232  #define AV_PIX_FMT_GRAY10 AV_PIX_FMT_NE(GRAY10BE, GRAY10LE)
233  #define AV_PIX_FMT_GRAY12 AV_PIX_FMT_NE(GRAY12BE, GRAY12LE)
234  #define AV_PIX_FMT_GRAY16 AV_PIX_FMT_NE(GRAY16BE, GRAY16LE)
235  #define AV_PIX_FMT_YA16   AV_PIX_FMT_NE(YA16BE,   YA16LE)
236  #define AV_PIX_FMT_RGB48  AV_PIX_FMT_NE(RGB48BE,  RGB48LE)
237  #define AV_PIX_FMT_RGB565 AV_PIX_FMT_NE(RGB565BE, RGB565LE)
238  #define AV_PIX_FMT_RGB555 AV_PIX_FMT_NE(RGB555BE, RGB555LE)
239  #define AV_PIX_FMT_RGB444 AV_PIX_FMT_NE(RGB444BE, RGB444LE)
240  #define AV_PIX_FMT_RGBA64 AV_PIX_FMT_NE(RGBA64BE, RGBA64LE)
241  #define AV_PIX_FMT_BGR48  AV_PIX_FMT_NE(BGR48BE,  BGR48LE)
242  #define AV_PIX_FMT_BGR565 AV_PIX_FMT_NE(BGR565BE, BGR565LE)
243  #define AV_PIX_FMT_BGR555 AV_PIX_FMT_NE(BGR555BE, BGR555LE)
244  #define AV_PIX_FMT_BGR444 AV_PIX_FMT_NE(BGR444BE, BGR444LE)
245  #define AV_PIX_FMT_BGRA64 AV_PIX_FMT_NE(BGRA64BE, BGRA64LE)
246  #define AV_PIX_FMT_YUV420P9  AV_PIX_FMT_NE(YUV420P9BE , YUV420P9LE)
247  #define AV_PIX_FMT_YUV422P9  AV_PIX_FMT_NE(YUV422P9BE , YUV422P9LE)
248  #define AV_PIX_FMT_YUV444P9  AV_PIX_FMT_NE(YUV444P9BE , YUV444P9LE)
249  #define AV_PIX_FMT_YUV420P10 AV_PIX_FMT_NE(YUV420P10BE, YUV420P10LE)
250  #define AV_PIX_FMT_YUV422P10 AV_PIX_FMT_NE(YUV422P10BE, YUV422P10LE)
251  #define AV_PIX_FMT_YUV440P10 AV_PIX_FMT_NE(YUV440P10BE, YUV440P10LE)
252  #define AV_PIX_FMT_YUV444P10 AV_PIX_FMT_NE(YUV444P10BE, YUV444P10LE)
253  #define AV_PIX_FMT_YUV420P12 AV_PIX_FMT_NE(YUV420P12BE, YUV420P12LE)
254  #define AV_PIX_FMT_YUV422P12 AV_PIX_FMT_NE(YUV422P12BE, YUV422P12LE)
255  #define AV_PIX_FMT_YUV440P12 AV_PIX_FMT_NE(YUV440P12BE, YUV440P12LE)
256  #define AV_PIX_FMT_YUV444P12 AV_PIX_FMT_NE(YUV444P12BE, YUV444P12LE)
257  #define AV_PIX_FMT_YUV420P14 AV_PIX_FMT_NE(YUV420P14BE, YUV420P14LE)
258  #define AV_PIX_FMT_YUV422P14 AV_PIX_FMT_NE(YUV422P14BE, YUV422P14LE)
259  #define AV_PIX_FMT_YUV444P14 AV_PIX_FMT_NE(YUV444P14BE, YUV444P14LE)
260  #define AV_PIX_FMT_YUV420P16 AV_PIX_FMT_NE(YUV420P16BE, YUV420P16LE)
261  #define AV_PIX_FMT_YUV422P16 AV_PIX_FMT_NE(YUV422P16BE, YUV422P16LE)
262  #define AV_PIX_FMT_YUV444P16 AV_PIX_FMT_NE(YUV444P16BE, YUV444P16LE)
263  #define AV_PIX_FMT_GBRP9     AV_PIX_FMT_NE(GBRP9BE ,    GBRP9LE)
264  #define AV_PIX_FMT_GBRP10    AV_PIX_FMT_NE(GBRP10BE,    GBRP10LE)
265  #define AV_PIX_FMT_GBRP12    AV_PIX_FMT_NE(GBRP12BE,    GBRP12LE)
266  #define AV_PIX_FMT_GBRP14    AV_PIX_FMT_NE(GBRP14BE,    GBRP14LE)
267  #define AV_PIX_FMT_GBRP16    AV_PIX_FMT_NE(GBRP16BE,    GBRP16LE)
268  #define AV_PIX_FMT_GBRAP10   AV_PIX_FMT_NE(GBRAP10BE,   GBRAP10LE)
269  #define AV_PIX_FMT_GBRAP12   AV_PIX_FMT_NE(GBRAP12BE,   GBRAP12LE)
270  #define AV_PIX_FMT_GBRAP16   AV_PIX_FMT_NE(GBRAP16BE,   GBRAP16LE)
271  #define AV_PIX_FMT_BAYER_BGGR16 AV_PIX_FMT_NE(BAYER_BGGR16BE,    BAYER_BGGR16LE)
272  #define AV_PIX_FMT_BAYER_RGGB16 AV_PIX_FMT_NE(BAYER_RGGB16BE,    BAYER_RGGB16LE)
273  #define AV_PIX_FMT_BAYER_GBRG16 AV_PIX_FMT_NE(BAYER_GBRG16BE,    BAYER_GBRG16LE)
274  #define AV_PIX_FMT_BAYER_GRBG16 AV_PIX_FMT_NE(BAYER_GRBG16BE,    BAYER_GRBG16LE)
275  #define AV_PIX_FMT_GBRPF32    AV_PIX_FMT_NE(GBRPF32BE,  GBRPF32LE)
276  #define AV_PIX_FMT_GBRAPF32   AV_PIX_FMT_NE(GBRAPF32BE, GBRAPF32LE)
277  #define AV_PIX_FMT_YUVA420P9  AV_PIX_FMT_NE(YUVA420P9BE , YUVA420P9LE)
278  #define AV_PIX_FMT_YUVA422P9  AV_PIX_FMT_NE(YUVA422P9BE , YUVA422P9LE)
279  #define AV_PIX_FMT_YUVA444P9  AV_PIX_FMT_NE(YUVA444P9BE , YUVA444P9LE)
280  #define AV_PIX_FMT_YUVA420P10 AV_PIX_FMT_NE(YUVA420P10BE, YUVA420P10LE)
281  #define AV_PIX_FMT_YUVA422P10 AV_PIX_FMT_NE(YUVA422P10BE, YUVA422P10LE)
282  #define AV_PIX_FMT_YUVA444P10 AV_PIX_FMT_NE(YUVA444P10BE, YUVA444P10LE)
283  #define AV_PIX_FMT_YUVA420P16 AV_PIX_FMT_NE(YUVA420P16BE, YUVA420P16LE)
284  #define AV_PIX_FMT_YUVA422P16 AV_PIX_FMT_NE(YUVA422P16BE, YUVA422P16LE)
285  #define AV_PIX_FMT_YUVA444P16 AV_PIX_FMT_NE(YUVA444P16BE, YUVA444P16LE)
286  #define AV_PIX_FMT_XYZ12      AV_PIX_FMT_NE(XYZ12BE, XYZ12LE)
287  #define AV_PIX_FMT_NV20       AV_PIX_FMT_NE(NV20BE,  NV20LE)
288  #define AV_PIX_FMT_AYUV64     AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)
289  #define AV_PIX_FMT_P010       AV_PIX_FMT_NE(P010BE,  P010LE)
290  #define AV_PIX_FMT_P016       AV_PIX_FMT_NE(P016BE,  P016LE)
291  enum AVColorPrimaries {
292      AVCOL_PRI_RESERVED0   = 0,
293      AVCOL_PRI_BT709       = 1,  
294      AVCOL_PRI_UNSPECIFIED = 2,
295      AVCOL_PRI_RESERVED    = 3,
296      AVCOL_PRI_BT470M      = 4,  
297      AVCOL_PRI_BT470BG     = 5,  
298      AVCOL_PRI_SMPTE170M   = 6,  
299      AVCOL_PRI_SMPTE240M   = 7,  
300      AVCOL_PRI_FILM        = 8,  
301      AVCOL_PRI_BT2020      = 9,  
302      AVCOL_PRI_SMPTE428    = 10, 
303      AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428,
304      AVCOL_PRI_SMPTE431    = 11, 
305      AVCOL_PRI_SMPTE432    = 12, 
306      AVCOL_PRI_JEDEC_P22   = 22, 
307      AVCOL_PRI_NB                
308  };
<span onclick='openModal()' class='match'>309  enum AVColorTransferCharacteristic {
310      AVCOL_TRC_RESERVED0    = 0,
311      AVCOL_TRC_BT709        = 1,  
312      AVCOL_TRC_UNSPECIFIED  = 2,
313      AVCOL_TRC_RESERVED     = 3,
314      AVCOL_TRC_GAMMA22      = 4,  
315      AVCOL_TRC_GAMMA28      = 5,  
316      AVCOL_TRC_SMPTE170M    = 6,  
317      AVCOL_TRC_SMPTE240M    = 7,
318      AVCOL_TRC_LINEAR       = 8,  
319      AVCOL_TRC_LOG          = 9,  
320      AVCOL_TRC_LOG_SQRT     = 10, 
321      AVCOL_TRC_IEC61966_2_4 = 11, 
322      AVCOL_TRC_BT1361_ECG   = 12, 
323      AVCOL_TRC_IEC61966_2_1 = 13, 
324      AVCOL_TRC_BT2020_10    = 14, 
325      AVCOL_TRC_BT2020_12    = 15, 
326      AVCOL_TRC_SMPTE2084    = 16, 
327      AVCOL_TRC_SMPTEST2084  = AVCOL_TRC_SMPTE2084,
328      AVCOL_TRC_SMPTE428     = 17, 
329      AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428,
330      AVCOL_TRC_ARIB_STD_B67 = 18, 
</span>331      AVCOL_TRC_NB                 
332  };
333  enum AVColorSpace {
334      AVCOL_SPC_RGB         = 0,  
335      AVCOL_SPC_BT709       = 1,  
336      AVCOL_SPC_UNSPECIFIED = 2,
337      AVCOL_SPC_RESERVED    = 3,
338      AVCOL_SPC_FCC         = 4,  
339      AVCOL_SPC_BT470BG     = 5,  
340      AVCOL_SPC_SMPTE170M   = 6,  
341      AVCOL_SPC_SMPTE240M   = 7,  
342      AVCOL_SPC_YCGCO       = 8,  
343      AVCOL_SPC_YCOCG       = AVCOL_SPC_YCGCO,
344      AVCOL_SPC_BT2020_NCL  = 9,  
345      AVCOL_SPC_BT2020_CL   = 10, 
346      AVCOL_SPC_SMPTE2085   = 11, 
347      AVCOL_SPC_CHROMA_DERIVED_NCL = 12, 
348      AVCOL_SPC_CHROMA_DERIVED_CL = 13, 
349      AVCOL_SPC_ICTCP       = 14, 
350      AVCOL_SPC_NB                
351  };
352  enum AVColorRange {
353      AVCOL_RANGE_UNSPECIFIED = 0,
354      AVCOL_RANGE_MPEG        = 1, 
355      AVCOL_RANGE_JPEG        = 2, 
356      AVCOL_RANGE_NB               
357  };
358  enum AVChromaLocation {
359      AVCHROMA_LOC_UNSPECIFIED = 0,
360      AVCHROMA_LOC_LEFT        = 1, 
361      AVCHROMA_LOC_CENTER      = 2, 
362      AVCHROMA_LOC_TOPLEFT     = 3, 
363      AVCHROMA_LOC_TOP         = 4,
364      AVCHROMA_LOC_BOTTOMLEFT  = 5,
365      AVCHROMA_LOC_BOTTOM      = 6,
366      AVCHROMA_LOC_NB               
367  };
368  #endif &bsol;* AVUTIL_PIXFMT_H */
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hyperloglog.c</h3>
            <pre><code>1  #include "server.h"
2  #include <stdint.h>
3  #include <math.h>
4  struct hllhdr {
5      char magic[4];      &bsol;* "HYLL" */
6      uint8_t encoding;   &bsol;* HLL_DENSE or HLL_SPARSE. */
7      uint8_t notused[3]; &bsol;* Reserved for future use, must be zero. */
8      uint8_t card[8];    &bsol;* Cached cardinality, little endian. */
9      uint8_t registers[]; &bsol;* Data bytes. */
10  };
11  #define HLL_INVALIDATE_CACHE(hdr) (hdr)->card[7] |= (1<<7)
12  #define HLL_VALID_CACHE(hdr) (((hdr)->card[7] & (1<<7)) == 0)
13  #define HLL_P 14 &bsol;* The greater is P, the smaller the error. */
14  #define HLL_Q (64-HLL_P) &bsol;* The number of bits of the hash value used for
15                              determining the number of leading zeros. */
16  #define HLL_REGISTERS (1<<HLL_P) &bsol;* With P=14, 16384 registers. */
17  #define HLL_P_MASK (HLL_REGISTERS-1) &bsol;* Mask to index register. */
18  #define HLL_BITS 6 &bsol;* Enough to count up to 63 leading zeroes. */
19  #define HLL_REGISTER_MAX ((1<<HLL_BITS)-1)
20  #define HLL_HDR_SIZE sizeof(struct hllhdr)
21  #define HLL_DENSE_SIZE (HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8))
22  #define HLL_DENSE 0 &bsol;* Dense encoding. */
23  #define HLL_SPARSE 1 &bsol;* Sparse encoding. */
24  #define HLL_RAW 255 &bsol;* Only used internally, never exposed. */
25  #define HLL_MAX_ENCODING 1
26  static char *invalid_hll_err = "-INVALIDOBJ Corrupted HLL object detected\r\n";
27  #define HLL_DENSE_GET_REGISTER(target,p,regnum) do { \
28      uint8_t *_p = (uint8_t*) p; \
29      PORT_ULONG _byte = regnum*HLL_BITS/8; \
30      PORT_ULONG _fb = regnum*HLL_BITS&7; \
31      PORT_ULONG _fb8 = 8 - _fb; \
32      PORT_ULONG b0 = _p[_byte]; \
33      PORT_ULONG b1 = _p[_byte+1]; \
34      target = ((b0 >> _fb) | (b1 << _fb8)) & HLL_REGISTER_MAX; \
35  } while(0)
36  #define HLL_DENSE_SET_REGISTER(p,regnum,val) do { \
37      uint8_t *_p = (uint8_t*) p; \
38      PORT_ULONG _byte = regnum*HLL_BITS/8; \
39      PORT_ULONG _fb = regnum*HLL_BITS&7; \
40      PORT_ULONG _fb8 = 8 - _fb; \
41      PORT_ULONG _v = val; \
42      _p[_byte] &= ~(HLL_REGISTER_MAX << _fb); \
43      _p[_byte] |= _v << _fb; \
44      _p[_byte+1] &= ~(HLL_REGISTER_MAX >> _fb8); \
45      _p[_byte+1] |= _v >> _fb8; \
46  } while(0)
47  #define HLL_SPARSE_XZERO_BIT 0x40 &bsol;* 01xxxxxx */
48  #define HLL_SPARSE_VAL_BIT 0x80 &bsol;* 1vvvvvxx */
49  #define HLL_SPARSE_IS_ZERO(p) (((*(p)) & 0xc0) == 0) &bsol;* 00xxxxxx */
50  #define HLL_SPARSE_IS_XZERO(p) (((*(p)) & 0xc0) == HLL_SPARSE_XZERO_BIT)
51  #define HLL_SPARSE_IS_VAL(p) ((*(p)) & HLL_SPARSE_VAL_BIT)
52  #define HLL_SPARSE_ZERO_LEN(p) (((*(p)) & 0x3f)+1)
53  #define HLL_SPARSE_XZERO_LEN(p) (((((*(p)) & 0x3f) << 8) | (*((p)+1)))+1)
54  #define HLL_SPARSE_VAL_VALUE(p) ((((*(p)) >> 2) & 0x1f)+1)
55  #define HLL_SPARSE_VAL_LEN(p) (((*(p)) & 0x3)+1)
56  #define HLL_SPARSE_VAL_MAX_VALUE 32
57  #define HLL_SPARSE_VAL_MAX_LEN 4
58  #define HLL_SPARSE_ZERO_MAX_LEN 64
59  #define HLL_SPARSE_XZERO_MAX_LEN 16384
60  #define HLL_SPARSE_VAL_SET(p,val,len) do { \
61      *(p) = (((val)-1)<<2|((len)-1))|HLL_SPARSE_VAL_BIT; \
62  } while(0)
63  #define HLL_SPARSE_ZERO_SET(p,len) do { \
64      *(p) = (len)-1; \
65  } while(0)
66  #define HLL_SPARSE_XZERO_SET(p,len) do { \
67      int _l = (len)-1; \
68      *(p) = (_l>>8) | HLL_SPARSE_XZERO_BIT; \
69      *((p)+1) = (_l&0xff); \
70  } while(0)
71  #define HLL_ALPHA_INF 0.721347520444481703680 &bsol;* constant for 0.5/ln(2) */
72  uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
73      const uint64_t m = 0xc6a4a7935bd1e995;
74      const int r = 47;
75      uint64_t h = seed ^ (len * m);
76      const uint8_t *data = (const uint8_t *)key;
77      const uint8_t *end = data + (len-(len&7));
78      while(data != end) {
79          uint64_t k;
80  #if (BYTE_ORDER == LITTLE_ENDIAN)
81      #ifdef USE_ALIGNED_ACCESS
82          memcpy(&k,data,sizeof(uint64_t));
83      #else
84          k = *((uint64_t*)data);
85      #endif
86  #else
87          k = (uint64_t) data[0];
88          k |= (uint64_t) data[1] << 8;
89          k |= (uint64_t) data[2] << 16;
90          k |= (uint64_t) data[3] << 24;
91          k |= (uint64_t) data[4] << 32;
92          k |= (uint64_t) data[5] << 40;
93          k |= (uint64_t) data[6] << 48;
94          k |= (uint64_t) data[7] << 56;
95  #endif
96          k *= m;
97          k ^= k >> r;
98          k *= m;
99          h ^= k;
100          h *= m;
101          data += 8;
102      }
103      switch(len & 7) {
104      case 7: h ^= (uint64_t)data[6] << 48; &bsol;* fall-thru */
105      case 6: h ^= (uint64_t)data[5] << 40; &bsol;* fall-thru */
106      case 5: h ^= (uint64_t)data[4] << 32; &bsol;* fall-thru */
107      case 4: h ^= (uint64_t)data[3] << 24; &bsol;* fall-thru */
108      case 3: h ^= (uint64_t)data[2] << 16; &bsol;* fall-thru */
109      case 2: h ^= (uint64_t)data[1] << 8; &bsol;* fall-thru */
110      case 1: h ^= (uint64_t)data[0];
111              h *= m; &bsol;* fall-thru */
112      };
113      h ^= h >> r;
114      h *= m;
115      h ^= h >> r;
116      return h;
117  }
118  int hllPatLen(unsigned char *ele, size_t elesize, PORT_LONG *regp) {
119      uint64_t hash, bit, index;
120      int count;
121      hash = MurmurHash64A(ele,(int)elesize,0xadc83b19ULL);                       WIN_PORT_FIX &bsol;* cast (int) */
122      index = hash & HLL_P_MASK; &bsol;* Register index. */
123      hash >>= HLL_P; &bsol;* Remove bits used to address the register. */
124      hash |= ((uint64_t)1<<HLL_Q); &bsol;* Make sure the loop terminates
125                                       and count will be <= Q+1. */
126      bit = 1;
127      count = 1; &bsol;* Initialized to 1 since we count the "00000...1" pattern. */
128      while((hash & bit) == 0) {
129          count++;
130          bit <<= 1;
131      }
132      *regp = (int) index;
133      return count;
134  }
135  int hllDenseSet(uint8_t *registers, PORT_LONG index, uint8_t count) {
136      uint8_t oldcount;
137      HLL_DENSE_GET_REGISTER(oldcount,registers,index);
138      if (count > oldcount) {
139          HLL_DENSE_SET_REGISTER(registers,index,count);
140          return 1;
141      } else {
142          return 0;
143      }
144  }
145  int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {
146      PORT_LONG index;
147      uint8_t count = hllPatLen(ele,elesize,&index);
148      return hllDenseSet(registers,index,count);
149  }
150  void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
151      int j;
152      if (HLL_REGISTERS == 16384 && HLL_BITS == 6) {
153          uint8_t *r = registers;
154          PORT_ULONG r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,
155                        r10, r11, r12, r13, r14, r15;
<span onclick='openModal()' class='match'>156          for (j = 0; j < 1024; j++) {
157              r0 = r[0] & 63;
158              r1 = (r[0] >> 6 | r[1] << 2) & 63;
159              r2 = (r[1] >> 4 | r[2] << 4) & 63;
160              r3 = (r[2] >> 2) & 63;
161              r4 = r[3] & 63;
162              r5 = (r[3] >> 6 | r[4] << 2) & 63;
163              r6 = (r[4] >> 4 | r[5] << 4) & 63;
164              r7 = (r[5] >> 2) & 63;
165              r8 = r[6] & 63;
166              r9 = (r[6] >> 6 | r[7] << 2) & 63;
167              r10 = (r[7] >> 4 | r[8] << 4) & 63;
168              r11 = (r[8] >> 2) & 63;
169              r12 = r[9] & 63;
170              r13 = (r[9] >> 6 | r[10] << 2) & 63;
171              r14 = (r[10] >> 4 | r[11] << 4) & 63;
172              r15 = (r[11] >> 2) & 63;
173              reghisto[r0]++;
174              reghisto[r1]++;
175              reghisto[r2]++;
176              reghisto[r3]++;
177              reghisto[r4]++;
</span>178              reghisto[r5]++;
179              reghisto[r6]++;
180              reghisto[r7]++;
181              reghisto[r8]++;
182              reghisto[r9]++;
183              reghisto[r10]++;
184              reghisto[r11]++;
185              reghisto[r12]++;
186              reghisto[r13]++;
187              reghisto[r14]++;
188              reghisto[r15]++;
189              r += 12;
190          }
191      } else {
192          for(j = 0; j < HLL_REGISTERS; j++) {
193              PORT_ULONG reg;
194              HLL_DENSE_GET_REGISTER(reg,registers,j);
195              reghisto[reg]++;
196          }
197      }
198  }
199  int hllSparseToDense(robj *o) {
200      sds sparse = o->ptr, dense;
201      struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
202      int idx = 0, runlen, regval;
203      uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);
204      hdr = (struct hllhdr*) sparse;
205      if (hdr->encoding == HLL_DENSE) return C_OK;
206      dense = sdsnewlen(NULL,HLL_DENSE_SIZE);
207      hdr = (struct hllhdr*) dense;
208      *hdr = *oldhdr; &bsol;* This will copy the magic and cached cardinality. */
209      hdr->encoding = HLL_DENSE;
210      p += HLL_HDR_SIZE;
211      while(p < end) {
212          if (HLL_SPARSE_IS_ZERO(p)) {
213              runlen = HLL_SPARSE_ZERO_LEN(p);
214              idx += runlen;
215              p++;
216          } else if (HLL_SPARSE_IS_XZERO(p)) {
217              runlen = HLL_SPARSE_XZERO_LEN(p);
218              idx += runlen;
219              p += 2;
220          } else {
221              runlen = HLL_SPARSE_VAL_LEN(p);
222              regval = HLL_SPARSE_VAL_VALUE(p);
223              if ((runlen + idx) > HLL_REGISTERS) break; &bsol;* Overflow. */
224              while(runlen--) {
225                  HLL_DENSE_SET_REGISTER(hdr->registers,idx,regval);
226                  idx++;
227              }
228              p++;
229          }
230      }
231      if (idx != HLL_REGISTERS) {
232          sdsfree(dense);
233          return C_ERR;
234      }
235      sdsfree(o->ptr);
236      o->ptr = dense;
237      return C_OK;
238  }
239  int hllSparseSet(robj *o, PORT_LONG index, uint8_t count) {
240      struct hllhdr *hdr;
241      uint8_t oldcount, *sparse, *end, *p, *prev, *next;
242      PORT_LONG first, span;
243      PORT_LONG is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;
244      if (count > HLL_SPARSE_VAL_MAX_VALUE) goto promote;
245      o->ptr = sdsMakeRoomFor(o->ptr,3);
246      sparse = p = ((uint8_t*)o->ptr) + HLL_HDR_SIZE;
247      end = p + sdslen(o->ptr) - HLL_HDR_SIZE;
248      first = 0;
249      prev = NULL; &bsol;* Points to previous opcode at the end of the loop. */
250      next = NULL; &bsol;* Points to the next opcode at the end of the loop. */
251      span = 0;
252      while(p < end) {
253          PORT_LONG oplen;
254          oplen = 1;
255          if (HLL_SPARSE_IS_ZERO(p)) {
256              span = HLL_SPARSE_ZERO_LEN(p);
257          } else if (HLL_SPARSE_IS_VAL(p)) {
258              span = HLL_SPARSE_VAL_LEN(p);
259          } else { &bsol;* XZERO. */
260              span = HLL_SPARSE_XZERO_LEN(p);
261              oplen = 2;
262          }
263          if (index <= first+span-1) break;
264          prev = p;
265          p += oplen;
266          first += span;
267      }
268      if (span == 0 || p >= end) return -1; &bsol;* Invalid format. */
269      next = HLL_SPARSE_IS_XZERO(p) ? p+2 : p+1;
270      if (next >= end) next = NULL;
271      if (HLL_SPARSE_IS_ZERO(p)) {
272          is_zero = 1;
273          runlen = HLL_SPARSE_ZERO_LEN(p);
274      } else if (HLL_SPARSE_IS_XZERO(p)) {
275          is_xzero = 1;
276          runlen = HLL_SPARSE_XZERO_LEN(p);
277      } else {
278          is_val = 1;
279          runlen = HLL_SPARSE_VAL_LEN(p);
280      }
281      if (is_val) {
282          oldcount = HLL_SPARSE_VAL_VALUE(p);
283          if (oldcount >= count) return 0;
284          if (runlen == 1) {
285              HLL_SPARSE_VAL_SET(p,count,1);
286              goto updated;
287          }
288      }
289      if (is_zero && runlen == 1) {
290          HLL_SPARSE_VAL_SET(p,count,1);
291          goto updated;
292      }
293      uint8_t seq[5], *n = seq;
294      int last = (int)(first+span-1); &bsol;* Last register covered by the sequence. */  WIN_PORT_FIX &bsol;* cast (int) */
295      int len;
296      if (is_zero || is_xzero) {
297          if (index != first) {
298              len = (int)(index-first);                                           WIN_PORT_FIX &bsol;* cast (int) */
299              if (len > HLL_SPARSE_ZERO_MAX_LEN) {
300                  HLL_SPARSE_XZERO_SET(n,len);
301                  n += 2;
302              } else {
303                  HLL_SPARSE_ZERO_SET(n,len);
304                  n++;
305              }
306          }
307          HLL_SPARSE_VAL_SET(n,count,1);
308          n++;
309          if (index != last) {
310              len = (int)(last-index);                                            WIN_PORT_FIX &bsol;* cast (int) */
311              if (len > HLL_SPARSE_ZERO_MAX_LEN) {
312                  HLL_SPARSE_XZERO_SET(n,len);
313                  n += 2;
314              } else {
315                  HLL_SPARSE_ZERO_SET(n,len);
316                  n++;
317              }
318          }
319      } else {
320          int curval = HLL_SPARSE_VAL_VALUE(p);
321          if (index != first) {
322              len = (int)(index-first);                                           WIN_PORT_FIX &bsol;* cast (int) */
323              HLL_SPARSE_VAL_SET(n,curval,len);
324              n++;
325          }
326          HLL_SPARSE_VAL_SET(n,count,1);
327          n++;
328          if (index != last) {
329              len = (int)(last-index);                                            WIN_PORT_FIX &bsol;* cast (int) */
330              HLL_SPARSE_VAL_SET(n,curval,len);
331              n++;
332          }
333      }
334       int seqlen = (int)(n-seq);                                                 WIN_PORT_FIX &bsol;* cast (int) */
335       int oldlen = is_xzero ? 2 : 1;
336       int deltalen = seqlen-oldlen;
337       if (deltalen > 0 &&
338           sdslen(o->ptr)+deltalen > server.hll_sparse_max_bytes) goto promote;
339       if (deltalen && next) memmove(next+deltalen,next,end-next);
340       sdsIncrLen(o->ptr,deltalen);
341       memcpy(p,seq,seqlen);
342       end += deltalen;
343  updated:
344      p = prev ? prev : sparse;
345      int scanlen = 5; &bsol;* Scan up to 5 upcodes starting from prev. */
346      while (p < end && scanlen--) {
347          if (HLL_SPARSE_IS_XZERO(p)) {
348              p += 2;
349              continue;
350          } else if (HLL_SPARSE_IS_ZERO(p)) {
351              p++;
352              continue;
353          }
354          if (p+1 < end && HLL_SPARSE_IS_VAL(p+1)) {
355              int v1 = HLL_SPARSE_VAL_VALUE(p);
356              int v2 = HLL_SPARSE_VAL_VALUE(p+1);
357              if (v1 == v2) {
358                  int len = HLL_SPARSE_VAL_LEN(p)+HLL_SPARSE_VAL_LEN(p+1);
359                  if (len <= HLL_SPARSE_VAL_MAX_LEN) {
360                      HLL_SPARSE_VAL_SET(p+1,v1,len);
361                      memmove(p,p+1,end-p);
362                      sdsIncrLen(o->ptr,-1);
363                      end--;
364                      continue;
365                  }
366              }
367          }
368          p++;
369      }
370      hdr = o->ptr;
371      HLL_INVALIDATE_CACHE(hdr);
372      return 1;
373  promote: &bsol;* Promote to dense representation. */
374      if (hllSparseToDense(o) == C_ERR) return -1; &bsol;* Corrupted HLL. */
375      hdr = o->ptr;
376      int dense_retval = hllDenseSet(hdr->registers,index,count);
377      serverAssert(dense_retval == 1);
378      return dense_retval;
379  }
380  int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {
381      PORT_LONG index;
382      uint8_t count = hllPatLen(ele,elesize,&index);
383      return hllSparseSet(o,index,count);
384  }
385  void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghisto) {
386      int idx = 0, runlen, regval;
387      uint8_t *end = sparse+sparselen, *p = sparse;
388      while(p < end) {
389          if (HLL_SPARSE_IS_ZERO(p)) {
390              runlen = HLL_SPARSE_ZERO_LEN(p);
391              idx += runlen;
392              reghisto[0] += runlen;
393              p++;
394          } else if (HLL_SPARSE_IS_XZERO(p)) {
395              runlen = HLL_SPARSE_XZERO_LEN(p);
396              idx += runlen;
397              reghisto[0] += runlen;
398              p += 2;
399          } else {
400              runlen = HLL_SPARSE_VAL_LEN(p);
401              regval = HLL_SPARSE_VAL_VALUE(p);
402              idx += runlen;
403              reghisto[regval] += runlen;
404              p++;
405          }
406      }
407      if (idx != HLL_REGISTERS && invalid) *invalid = 1;
408  }
409  void hllRawRegHisto(uint8_t *registers, int* reghisto) {
410      uint64_t *word = (uint64_t*) registers;
411      uint8_t *bytes;
412      int j;
413      for (j = 0; j < HLL_REGISTERS/8; j++) {
414          if (*word == 0) {
415              reghisto[0] += 8;
416          } else {
417              bytes = (uint8_t*) word;
418              reghisto[bytes[0]]++;
419              reghisto[bytes[1]]++;
420              reghisto[bytes[2]]++;
421              reghisto[bytes[3]]++;
422              reghisto[bytes[4]]++;
423              reghisto[bytes[5]]++;
424              reghisto[bytes[6]]++;
425              reghisto[bytes[7]]++;
426          }
427          word++;
428      }
429  }
430  double hllSigma(double x) {
431      if (x == 1.) return INFINITY;
432      double zPrime;
433      double y = 1;
434      double z = x;
435      do {
436          x *= x;
437          zPrime = z;
438          z += x * y;
439          y += y;
440      } while(zPrime != z);
441      return z;
442  }
443  double hllTau(double x) {
444      if (x == 0. || x == 1.) return 0.;
445      double zPrime;
446      double y = 1.0;
447      double z = 1 - x;
448      do {
449          x = sqrt(x);
450          zPrime = z;
451          y *= 0.5;
452          z -= pow(1 - x, 2)*y;
453      } while(zPrime != z);
454      return z / 3;
455  }
456  uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
457      double m = HLL_REGISTERS;
458      double E;
459      int j;
460      int reghisto[64] = {0};
461      if (hdr->encoding == HLL_DENSE) {
462          hllDenseRegHisto(hdr->registers,reghisto);
463      } else if (hdr->encoding == HLL_SPARSE) {
464          hllSparseRegHisto(hdr->registers,
465                           sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);
466      } else if (hdr->encoding == HLL_RAW) {
467          hllRawRegHisto(hdr->registers,reghisto);
468      } else {
469          serverPanic("Unknown HyperLogLog encoding in hllCount()");
470      }
471      double z = m * hllTau((m-reghisto[HLL_Q+1])/(double)m);
472      for (j = HLL_Q; j >= 1; --j) {
473          z += reghisto[j];
474          z *= 0.5;
475      }
476      z += m * hllSigma(reghisto[0]/(double)m);
477      E = llroundl(HLL_ALPHA_INF*m*m/z);
478      return (uint64_t) E;
479  }
480  int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
481      struct hllhdr *hdr = o->ptr;
482      switch(hdr->encoding) {
483      case HLL_DENSE: return hllDenseAdd(hdr->registers,ele,elesize);
484      case HLL_SPARSE: return hllSparseAdd(o,ele,elesize);
485      default: return -1; &bsol;* Invalid representation. */
486      }
487  }
488  int hllMerge(uint8_t *max, robj *hll) {
489      struct hllhdr *hdr = hll->ptr;
490      int i;
491      if (hdr->encoding == HLL_DENSE) {
492          uint8_t val;
493          for (i = 0; i < HLL_REGISTERS; i++) {
494              HLL_DENSE_GET_REGISTER(val,hdr->registers,i);
495              if (val > max[i]) max[i] = val;
496          }
497      } else {
498          uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
499          PORT_LONG runlen, regval;
500          p += HLL_HDR_SIZE;
501          i = 0;
502          while(p < end) {
503              if (HLL_SPARSE_IS_ZERO(p)) {
504                  runlen = HLL_SPARSE_ZERO_LEN(p);
505                  i += (int)runlen;                                               WIN_PORT_FIX &bsol;* cast (int) */
506                  p++;
507              } else if (HLL_SPARSE_IS_XZERO(p)) {
508                  runlen = HLL_SPARSE_XZERO_LEN(p);
509                  i += (int)runlen;                                               WIN_PORT_FIX &bsol;* cast (int) */
510                  p += 2;
511              } else {
512                  runlen = HLL_SPARSE_VAL_LEN(p);
513                  regval = HLL_SPARSE_VAL_VALUE(p);
514                  if ((runlen + i) > HLL_REGISTERS) break; &bsol;* Overflow. */
515                  while(runlen--) {
516                      if (regval > max[i]) max[i] = (uint8_t)regval;              WIN_PORT_FIX &bsol;* cast (uint8_t) */
517                      i++;
518                  }
519                  p++;
520              }
521          }
522          if (i != HLL_REGISTERS) return C_ERR;
523      }
524      return C_OK;
525  }
526  robj *createHLLObject(void) {
527      robj *o;
528      struct hllhdr *hdr;
529      sds s;
530      uint8_t *p;
531      int sparselen = HLL_HDR_SIZE +
532                      (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN-1)) /
533                       HLL_SPARSE_XZERO_MAX_LEN)*2);
534      int aux;
535      aux = HLL_REGISTERS;
536      s = sdsnewlen(NULL,sparselen);
537      p = (uint8_t*)s + HLL_HDR_SIZE;
538      while(aux) {
539          int xzero = HLL_SPARSE_XZERO_MAX_LEN;
540          if (xzero > aux) xzero = aux;
541          HLL_SPARSE_XZERO_SET(p,xzero);
542          p += 2;
543          aux -= xzero;
544      }
545      serverAssert((p-(uint8_t*)s) == sparselen);
546      o = createObject(OBJ_STRING,s);
547      hdr = o->ptr;
548      memcpy(hdr->magic,"HYLL",4);
549      hdr->encoding = HLL_SPARSE;
550      return o;
551  }
552  int isHLLObjectOrReply(client *c, robj *o) {
553      struct hllhdr *hdr;
554      if (checkType(c,o,OBJ_STRING))
555          return C_ERR; &bsol;* Error already sent. */
556      if (!sdsEncodedObject(o)) goto invalid;
557      if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
558      hdr = o->ptr;
559      if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
560          hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;
561      if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;
562      if (hdr->encoding == HLL_DENSE &&
563          stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;
564      return C_OK;
565  invalid:
566      addReplySds(c,
567          sdsnew("-WRONGTYPE Key is not a valid "
568                 "HyperLogLog string value.\r\n"));
569      return C_ERR;
570  }
571  void pfaddCommand(client *c) {
572      robj *o = lookupKeyWrite(c->db,c->argv[1]);
573      struct hllhdr *hdr;
574      int updated = 0, j;
575      if (o == NULL) {
576          o = createHLLObject();
577          dbAdd(c->db,c->argv[1],o);
578          updated++;
579      } else {
580          if (isHLLObjectOrReply(c,o) != C_OK) return;
581          o = dbUnshareStringValue(c->db,c->argv[1],o);
582      }
583      for (j = 2; j < c->argc; j++) {
584          int retval = hllAdd(o, (unsigned char*)c->argv[j]->ptr,
585                                 sdslen(c->argv[j]->ptr));
586          switch(retval) {
587          case 1:
588              updated++;
589              break;
590          case -1:
591              addReplySds(c,sdsnew(invalid_hll_err));
592              return;
593          }
594      }
595      hdr = o->ptr;
596      if (updated) {
597          signalModifiedKey(c->db,c->argv[1]);
598          notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
599          server.dirty++;
600          HLL_INVALIDATE_CACHE(hdr);
601      }
602      addReply(c, updated ? shared.cone : shared.czero);
603  }
604  void pfcountCommand(client *c) {
605      robj *o;
606      struct hllhdr *hdr;
607      uint64_t card;
608      if (c->argc > 2) {
609          uint8_t max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;
610          int j;
611          memset(max,0,sizeof(max));
612          hdr = (struct hllhdr*) max;
613          hdr->encoding = HLL_RAW; &bsol;* Special internal-only encoding. */
614          registers = max + HLL_HDR_SIZE;
615          for (j = 1; j < c->argc; j++) {
616              robj *o = lookupKeyRead(c->db,c->argv[j]);
617              if (o == NULL) continue; &bsol;* Assume empty HLL for non existing var.*/
618              if (isHLLObjectOrReply(c,o) != C_OK) return;
619              if (hllMerge(registers,o) == C_ERR) {
620                  addReplySds(c,sdsnew(invalid_hll_err));
621                  return;
622              }
623          }
624          addReplyLongLong(c,hllCount(hdr,NULL));
625          return;
626      }
627      o = lookupKeyWrite(c->db,c->argv[1]);
628      if (o == NULL) {
629          addReply(c,shared.czero);
630      } else {
631          if (isHLLObjectOrReply(c,o) != C_OK) return;
632          o = dbUnshareStringValue(c->db,c->argv[1],o);
633          hdr = o->ptr;
634          if (HLL_VALID_CACHE(hdr)) {
635              card = (uint64_t)hdr->card[0];
636              card |= (uint64_t)hdr->card[1] << 8;
637              card |= (uint64_t)hdr->card[2] << 16;
638              card |= (uint64_t)hdr->card[3] << 24;
639              card |= (uint64_t)hdr->card[4] << 32;
640              card |= (uint64_t)hdr->card[5] << 40;
641              card |= (uint64_t)hdr->card[6] << 48;
642              card |= (uint64_t)hdr->card[7] << 56;
643          } else {
644              int invalid = 0;
645              card = hllCount(hdr,&invalid);
646              if (invalid) {
647                  addReplySds(c,sdsnew(invalid_hll_err));
648                  return;
649              }
650              hdr->card[0] = card & 0xff;
651              hdr->card[1] = (card >> 8) & 0xff;
652              hdr->card[2] = (card >> 16) & 0xff;
653              hdr->card[3] = (card >> 24) & 0xff;
654              hdr->card[4] = (card >> 32) & 0xff;
655              hdr->card[5] = (card >> 40) & 0xff;
656              hdr->card[6] = (card >> 48) & 0xff;
657              hdr->card[7] = (card >> 56) & 0xff;
658              signalModifiedKey(c->db,c->argv[1]);
659              server.dirty++;
660          }
661          addReplyLongLong(c,card);
662      }
663  }
664  void pfmergeCommand(client *c) {
665      uint8_t max[HLL_REGISTERS];
666      struct hllhdr *hdr;
667      int j;
668      int use_dense = 0; &bsol;* Use dense representation as target? */
669      memset(max,0,sizeof(max));
670      for (j = 1; j < c->argc; j++) {
671          robj *o = lookupKeyRead(c->db,c->argv[j]);
672          if (o == NULL) continue; &bsol;* Assume empty HLL for non existing var. */
673          if (isHLLObjectOrReply(c,o) != C_OK) return;
674          hdr = o->ptr;
675          if (hdr->encoding == HLL_DENSE) use_dense = 1;
676          if (hllMerge(max,o) == C_ERR) {
677              addReplySds(c,sdsnew(invalid_hll_err));
678              return;
679          }
680      }
681      robj *o = lookupKeyWrite(c->db,c->argv[1]);
682      if (o == NULL) {
683          o = createHLLObject();
684          dbAdd(c->db,c->argv[1],o);
685      } else {
686          o = dbUnshareStringValue(c->db,c->argv[1],o);
687      }
688      if (use_dense && hllSparseToDense(o) == C_ERR) {
689          addReplySds(c,sdsnew(invalid_hll_err));
690          return;
691      }
692      for (j = 0; j < HLL_REGISTERS; j++) {
693          if (max[j] == 0) continue;
694          hdr = o->ptr;
695          switch(hdr->encoding) {
696          case HLL_DENSE: hllDenseSet(hdr->registers,j,max[j]); break;
697          case HLL_SPARSE: hllSparseSet(o,j,max[j]); break;
698          }
699      }
700      hdr = o->ptr; &bsol;* o->ptr may be different now, as a side effect of
701                       last hllSparseSet() call. */
702      HLL_INVALIDATE_CACHE(hdr);
703      signalModifiedKey(c->db,c->argv[1]);
704      notifyKeyspaceEvent(NOTIFY_STRING,"pfadd",c->argv[1],c->db->id);
705      server.dirty++;
706      addReply(c,shared.ok);
707  }
708  #define HLL_TEST_CYCLES 1000
709  void pfselftestCommand(client *c) {
710      unsigned int j, i;
711      sds bitcounters = sdsnewlen(NULL,HLL_DENSE_SIZE);
712      struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;
713      robj *o = NULL;
714      uint8_t bytecounters[HLL_REGISTERS];
715      for (j = 0; j < HLL_TEST_CYCLES; j++) {
716          for (i = 0; i < HLL_REGISTERS; i++) {
717              unsigned int r = rand() & HLL_REGISTER_MAX;
718              bytecounters[i] = r;
719              HLL_DENSE_SET_REGISTER(hdr->registers,i,r);
720          }
721          for (i = 0; i < HLL_REGISTERS; i++) {
722              unsigned int val;
723              HLL_DENSE_GET_REGISTER(val,hdr->registers,i);
724              if (val != bytecounters[i]) {
725                  addReplyErrorFormat(c,
726                      "TESTFAILED Register %d should be %d but is %d",
727                      i, (int) bytecounters[i], (int) val);
728                  goto cleanup;
729              }
730          }
731      }
732      memset(hdr->registers,0,HLL_DENSE_SIZE-HLL_HDR_SIZE);
733      o = createHLLObject();
734      double relerr = 1.04/sqrt(HLL_REGISTERS);
735      int64_t checkpoint = 1;
736      uint64_t seed = (uint64_t)rand() | (uint64_t)rand() << 32;
737      uint64_t ele;
738      for (j = 1; j <= 10000000; j++) {
739          ele = j ^ seed;
740          hllDenseAdd(hdr->registers,(unsigned char*)&ele,sizeof(ele));
741          hllAdd(o,(unsigned char*)&ele,sizeof(ele));
742          if (j == checkpoint && j < server.hll_sparse_max_bytes/2) {
743              hdr2 = o->ptr;
744              if (hdr2->encoding != HLL_SPARSE) {
745                  addReplyError(c, "TESTFAILED sparse encoding not used");
746                  goto cleanup;
747              }
748          }
749          if (j == checkpoint && hllCount(hdr,NULL) != hllCount(o->ptr,NULL)) {
750                  addReplyError(c, "TESTFAILED dense/sparse disagree");
751                  goto cleanup;
752          }
753          if (j == checkpoint) {
754              int64_t abserr = checkpoint - (int64_t)hllCount(hdr,NULL);
755              uint64_t maxerr = (uint64_t)ceil(relerr*6*checkpoint);              WIN_PORT_FIX &bsol;* cast (uint64_t) */
756              if (j == 10) maxerr = 1;
757              if (abserr < 0) abserr = -abserr;
758              if (abserr > (int64_t)maxerr) {
759                  addReplyErrorFormat(c,
760                      "TESTFAILED Too big error. card:%llu abserr:%llu",
761                      (PORT_ULONGLONG) checkpoint,
762                      (PORT_ULONGLONG) abserr);
763                  goto cleanup;
764              }
765              checkpoint *= 10;
766          }
767      }
768      addReply(c,shared.ok);
769  cleanup:
770      sdsfree(bitcounters);
771      if (o) decrRefCount(o);
772  }
773  void pfdebugCommand(client *c) {
774      char *cmd = c->argv[1]->ptr;
775      struct hllhdr *hdr;
776      robj *o;
777      int j;
778      o = lookupKeyWrite(c->db,c->argv[2]);
779      if (o == NULL) {
780          addReplyError(c,"The specified key does not exist");
781          return;
782      }
783      if (isHLLObjectOrReply(c,o) != C_OK) return;
784      o = dbUnshareStringValue(c->db,c->argv[2],o);
785      hdr = o->ptr;
786      if (!strcasecmp(cmd,"getreg")) {
787          if (c->argc != 3) goto arityerr;
788          if (hdr->encoding == HLL_SPARSE) {
789              if (hllSparseToDense(o) == C_ERR) {
790                  addReplySds(c,sdsnew(invalid_hll_err));
791                  return;
792              }
793              server.dirty++; &bsol;* Force propagation on encoding change. */
794          }
795          hdr = o->ptr;
796          addReplyMultiBulkLen(c,HLL_REGISTERS);
797          for (j = 0; j < HLL_REGISTERS; j++) {
798              uint8_t val;
799              HLL_DENSE_GET_REGISTER(val,hdr->registers,j);
800              addReplyLongLong(c,val);
801          }
802      }
803      else if (!strcasecmp(cmd,"decode")) {
804          if (c->argc != 3) goto arityerr;
805          uint8_t *p = o->ptr, *end = p+sdslen(o->ptr);
806          sds decoded = sdsempty();
807          if (hdr->encoding != HLL_SPARSE) {
808              sdsfree(decoded);
809              addReplyError(c,"HLL encoding is not sparse");
810              return;
811          }
812          p += HLL_HDR_SIZE;
813          while(p < end) {
814              int runlen, regval;
815              if (HLL_SPARSE_IS_ZERO(p)) {
816                  runlen = HLL_SPARSE_ZERO_LEN(p);
817                  p++;
818                  decoded = sdscatprintf(decoded,"z:%d ",runlen);
819              } else if (HLL_SPARSE_IS_XZERO(p)) {
820                  runlen = HLL_SPARSE_XZERO_LEN(p);
821                  p += 2;
822                  decoded = sdscatprintf(decoded,"Z:%d ",runlen);
823              } else {
824                  runlen = HLL_SPARSE_VAL_LEN(p);
825                  regval = HLL_SPARSE_VAL_VALUE(p);
826                  p++;
827                  decoded = sdscatprintf(decoded,"v:%d,%d ",regval,runlen);
828              }
829          }
830          decoded = sdstrim(decoded," ");
831          addReplyBulkCBuffer(c,decoded,sdslen(decoded));
832          sdsfree(decoded);
833      }
834      else if (!strcasecmp(cmd,"encoding")) {
835          char *encodingstr[2] = {"dense","sparse"};
836          if (c->argc != 3) goto arityerr;
837          addReplyStatus(c,encodingstr[hdr->encoding]);
838      }
839      else if (!strcasecmp(cmd,"todense")) {
840          int conv = 0;
841          if (c->argc != 3) goto arityerr;
842          if (hdr->encoding == HLL_SPARSE) {
843              if (hllSparseToDense(o) == C_ERR) {
844                  addReplySds(c,sdsnew(invalid_hll_err));
845                  return;
846              }
847              conv = 1;
848              server.dirty++; &bsol;* Force propagation on encoding change. */
849          }
850          addReply(c,conv ? shared.cone : shared.czero);
851      } else {
852          addReplyErrorFormat(c,"Unknown PFDEBUG subcommand '%s'", cmd);
853      }
854      return;
855  arityerr:
856      addReplyErrorFormat(c,
857          "Wrong number of arguments for the '%s' subcommand",cmd);
858  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-pixfmt.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-hyperloglog.c</div>
                </div>
                <div class="column column_space"><pre><code>309  enum AVColorTransferCharacteristic {
310      AVCOL_TRC_RESERVED0    = 0,
311      AVCOL_TRC_BT709        = 1,  
312      AVCOL_TRC_UNSPECIFIED  = 2,
313      AVCOL_TRC_RESERVED     = 3,
314      AVCOL_TRC_GAMMA22      = 4,  
315      AVCOL_TRC_GAMMA28      = 5,  
316      AVCOL_TRC_SMPTE170M    = 6,  
317      AVCOL_TRC_SMPTE240M    = 7,
318      AVCOL_TRC_LINEAR       = 8,  
319      AVCOL_TRC_LOG          = 9,  
320      AVCOL_TRC_LOG_SQRT     = 10, 
321      AVCOL_TRC_IEC61966_2_4 = 11, 
322      AVCOL_TRC_BT1361_ECG   = 12, 
323      AVCOL_TRC_IEC61966_2_1 = 13, 
324      AVCOL_TRC_BT2020_10    = 14, 
325      AVCOL_TRC_BT2020_12    = 15, 
326      AVCOL_TRC_SMPTE2084    = 16, 
327      AVCOL_TRC_SMPTEST2084  = AVCOL_TRC_SMPTE2084,
328      AVCOL_TRC_SMPTE428     = 17, 
329      AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428,
330      AVCOL_TRC_ARIB_STD_B67 = 18, 
</pre></code></div>
                <div class="column column_space"><pre><code>156          for (j = 0; j < 1024; j++) {
157              r0 = r[0] & 63;
158              r1 = (r[0] >> 6 | r[1] << 2) & 63;
159              r2 = (r[1] >> 4 | r[2] << 4) & 63;
160              r3 = (r[2] >> 2) & 63;
161              r4 = r[3] & 63;
162              r5 = (r[3] >> 6 | r[4] << 2) & 63;
163              r6 = (r[4] >> 4 | r[5] << 4) & 63;
164              r7 = (r[5] >> 2) & 63;
165              r8 = r[6] & 63;
166              r9 = (r[6] >> 6 | r[7] << 2) & 63;
167              r10 = (r[7] >> 4 | r[8] << 4) & 63;
168              r11 = (r[8] >> 2) & 63;
169              r12 = r[9] & 63;
170              r13 = (r[9] >> 6 | r[10] << 2) & 63;
171              r14 = (r[10] >> 4 | r[11] << 4) & 63;
172              r15 = (r[11] >> 2) & 63;
173              reghisto[r0]++;
174              reghisto[r1]++;
175              reghisto[r2]++;
176              reghisto[r3]++;
177              reghisto[r4]++;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    