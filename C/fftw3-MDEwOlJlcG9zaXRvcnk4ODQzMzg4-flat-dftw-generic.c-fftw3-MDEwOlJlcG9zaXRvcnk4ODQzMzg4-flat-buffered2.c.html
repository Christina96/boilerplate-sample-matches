
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 20.689655172413794%, Tokens: 12</h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-generic.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef ct_solver S;
3  typedef struct {
4       plan_dftw super;
5       INT r, rs, m, mb, me, ms, v, vs;
6       plan *cld;
7       twid *td;
8       const S *slv;
9       int dec;
10  } P;
11  static void mktwiddle(P *ego, enum wakefulness wakefulness)
12  {
13       static const tw_instr tw[] = { { TW_FULL, 0, 0 }, { TW_NEXT, 1, 0 } };
14       X(twiddle_awake)(wakefulness, &ego->td, tw,
15  		      ego->r * ego->m, ego->m, ego->r);
16  }
17  static void bytwiddle(const P *ego, R *rio, R *iio)
18  {
19       INT iv, ir, im;
20       INT r = ego->r, rs = ego->rs;
21       INT m = ego->m, mb = ego->mb, me = ego->me, ms = ego->ms;
22       INT v = ego->v, vs = ego->vs;
23       const R *W = ego->td->W;
24       mb += (mb == 0); &bsol;* skip m=0 iteration */
25       for (iv = 0; iv < v; ++iv) {
26  	  for (ir = 1; ir < r; ++ir) {
27  	       for (im = mb; im < me; ++im) {
28  		    R *pr = rio + ms * im + rs * ir;
29  		    R *pi = iio + ms * im + rs * ir;
30  		    E xr = *pr;
31  		    E xi = *pi;
32  		    E wr = W[2 * im + (2 * (m-1)) * ir - 2];
33  		    E wi = W[2 * im + (2 * (m-1)) * ir - 1];
34  		    *pr = xr * wr + xi * wi;
35  		    *pi = xi * wr - xr * wi;
36  	       }
37  	  }
38  	  rio += vs;
39  	  iio += vs;
40       }
41  }
42  static int applicable(INT irs, INT ors, INT ivs, INT ovs,
43  		      const planner *plnr)
44  {
45       return (1
46  	     && irs == ors
47  	     && ivs == ovs
48  	     && !NO_SLOWP(plnr)
49  	  );
50  }
51  static void apply_dit(const plan *ego_, R *rio, R *iio)
52  {
53       const P *ego = (const P *) ego_;
54       plan_dft *cld;
55       INT dm = ego->ms * ego->mb;
56       bytwiddle(ego, rio, iio);
57       cld = (plan_dft *) ego->cld;
58       cld->apply(ego->cld, rio + dm, iio + dm, rio + dm, iio + dm);
59  }
60  static void apply_dif(const plan *ego_, R *rio, R *iio)
61  {
62       const P *ego = (const P *) ego_;
63       plan_dft *cld;
64       INT dm = ego->ms * ego->mb;
65       cld = (plan_dft *) ego->cld;
66       cld->apply(ego->cld, rio + dm, iio + dm, rio + dm, iio + dm);
67       bytwiddle(ego, rio, iio);
68  }
69  static void awake(plan *ego_, enum wakefulness wakefulness)
70  {
71       P *ego = (P *) ego_;
72       X(plan_awake)(ego->cld, wakefulness);
73       mktwiddle(ego, wakefulness);
74  }
75  static void destroy(plan *ego_)
76  {
77       P *ego = (P *) ego_;
78       X(plan_destroy_internal)(ego->cld);
79  }
80  static void print(const plan *ego_, printer *p)
81  {
82       const P *ego = (const P *) ego_;
83       p->print(p, "(dftw-generic-%s-%D-%D%v%(%p%))",
84  	      ego->dec == DECDIT ? "dit" : "dif",
85  	      ego->r, ego->m, ego->v, ego->cld);
86  }
87  static plan *mkcldw(const ct_solver *ego_,
88  		    INT r, INT irs, INT ors,
89  		    INT m, INT ms,
90  		    INT v, INT ivs, INT ovs,
91  		    INT mstart, INT mcount,
92  		    R *rio, R *iio,
93  		    planner *plnr)
94  {
95       const S *ego = (const S *)ego_;
96       P *pln;
97       plan *cld = 0;
98       INT dm = ms * mstart;
99       static const plan_adt padt = {
100  	  0, awake, print, destroy
101       };
102       A(mstart >= 0 && mstart + mcount <= m);
103       if (!applicable(irs, ors, ivs, ovs, plnr))
104            return (plan *)0;
105       cld = X(mkplan_d)(plnr,
106  			X(mkproblem_dft_d)(
107  			     X(mktensor_1d)(r, irs, irs),
108  			     X(mktensor_2d)(mcount, ms, ms, v, ivs, ivs),
109  			     rio + dm, iio + dm, rio + dm, iio + dm)
110  			);
111       if (!cld) goto nada;
112       pln = MKPLAN_DFTW(P, &padt, ego->dec == DECDIT ? apply_dit : apply_dif);
113       pln->slv = ego;
<span onclick='openModal()' class='match'>114       pln->cld = cld;
115       pln->r = r;
116       pln->rs = irs;
117       pln->m = m;
118       pln->ms = ms;
119       pln->v = v;
120       pln->vs = ivs;
121       pln->mb = mstart;
122       pln->me = mstart + mcount;
123       pln->dec = ego->dec;
124       pln->td = 0;
125       {
</span>126  	  double n0 = (r - 1) * (mcount - 1) * v;
127  	  pln->super.super.ops = cld->ops;
128  	  pln->super.super.ops.mul += 8 * n0;
129  	  pln->super.super.ops.add += 4 * n0;
130  	  pln->super.super.ops.other += 8 * n0;
131       }
132       return &(pln->super.super);
133   nada:
134       X(plan_destroy_internal)(cld);
135       return (plan *) 0;
136  }
137  static void regsolver(planner *plnr, INT r, int dec)
138  {
139       S *slv = (S *)X(mksolver_ct)(sizeof(S), r, dec, mkcldw, 0);
140       REGISTER_SOLVER(plnr, &(slv->super));
141       if (X(mksolver_ct_hook)) {
142  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), r, dec, mkcldw, 0);
143  	  REGISTER_SOLVER(plnr, &(slv->super));
144       }
145  }
146  void X(ct_generic_register)(planner *p)
147  {
148       regsolver(p, 0, DECDIT);
149       regsolver(p, 0, DECDIF);
150  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered2.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  #include "dft/dft.h"
3  typedef struct {
4       solver super;
5       size_t maxnbuf_ndx;
6  } S;
7  static const INT maxnbufs[] = { 8, 256 };
8  typedef struct {
9       plan_rdft2 super;
10       plan *cld, *cldcpy, *cldrest;
11       INT n, vl, nbuf, bufdist;
12       INT ivs_by_nbuf, ovs_by_nbuf;
13       INT ioffset, roffset;
14  } P;
15  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
16  {
17       const P *ego = (const P *) ego_;
18       plan_rdft2 *cld = (plan_rdft2 *) ego->cld;
19       plan_dft *cldcpy = (plan_dft *) ego->cldcpy;
20       INT i, vl = ego->vl, nbuf = ego->nbuf;
21       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
22       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist, BUFFERS);
23       R *bufr = bufs + ego->roffset;
24       R *bufi = bufs + ego->ioffset;
25       plan_rdft2 *cldrest;
26       for (i = nbuf; i <= vl; i += nbuf) {
27            cld->apply((plan *) cld, r0, r1, bufr, bufi);
28  	  r0 += ivs_by_nbuf; r1 += ivs_by_nbuf;
29            cldcpy->apply((plan *) cldcpy, bufr, bufi, cr, ci);
30  	  cr += ovs_by_nbuf; ci += ovs_by_nbuf;
31       }
32       X(ifree)(bufs);
33       cldrest = (plan_rdft2 *) ego->cldrest;
34       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
35  }
36  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
37  {
38       const P *ego = (const P *) ego_;
39       plan_rdft2 *cld = (plan_rdft2 *) ego->cld;
40       plan_dft *cldcpy = (plan_dft *) ego->cldcpy;
41       INT i, vl = ego->vl, nbuf = ego->nbuf;
42       INT ivs_by_nbuf = ego->ivs_by_nbuf, ovs_by_nbuf = ego->ovs_by_nbuf;
43       R *bufs = (R *)MALLOC(sizeof(R) * nbuf * ego->bufdist, BUFFERS);
44       R *bufr = bufs + ego->roffset;
45       R *bufi = bufs + ego->ioffset;
46       plan_rdft2 *cldrest;
47       for (i = nbuf; i <= vl; i += nbuf) {
48            cldcpy->apply((plan *) cldcpy, cr, ci, bufr, bufi);
49  	  cr += ivs_by_nbuf; ci += ivs_by_nbuf;
50            cld->apply((plan *) cld, r0, r1, bufr, bufi);
51  	  r0 += ovs_by_nbuf; r1 += ovs_by_nbuf;
52       }
53       X(ifree)(bufs);
54       cldrest = (plan_rdft2 *) ego->cldrest;
55       cldrest->apply((plan *) cldrest, r0, r1, cr, ci);
56  }
57  static void awake(plan *ego_, enum wakefulness wakefulness)
58  {
59       P *ego = (P *) ego_;
60       X(plan_awake)(ego->cld, wakefulness);
61       X(plan_awake)(ego->cldcpy, wakefulness);
62       X(plan_awake)(ego->cldrest, wakefulness);
63  }
64  static void destroy(plan *ego_)
65  {
66       P *ego = (P *) ego_;
67       X(plan_destroy_internal)(ego->cldrest);
68       X(plan_destroy_internal)(ego->cldcpy);
69       X(plan_destroy_internal)(ego->cld);
70  }
71  static void print(const plan *ego_, printer *p)
72  {
73       const P *ego = (const P *) ego_;
74       p->print(p, "(rdft2-buffered-%D%v/%D-%D%(%p%)%(%p%)%(%p%))",
75                ego->n, ego->nbuf,
76                ego->vl, ego->bufdist % ego->n,
77                ego->cld, ego->cldcpy, ego->cldrest);
78  }
79  static int applicable0(const S *ego, const problem *p_, const planner *plnr)
80  {
81       const problem_rdft2 *p = (const problem_rdft2 *) p_;
82       iodim *d = p->sz->dims;
83       if (1
84  	 && p->vecsz->rnk <= 1
85  	 && p->sz->rnk == 1
86  	 && (d[0].n % 2) == 0
87  	 && (p->kind == R2HC || p->kind == HC2R)
88  	  ) {
89  	  INT vl, ivs, ovs;
90  	  X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
91  	  if (X(toobig)(d[0].n) && CONSERVE_MEMORYP(plnr))
92  	       return 0;
93  	  if (X(nbuf_redundant)(d[0].n, vl,
94  				ego->maxnbuf_ndx,
95  				maxnbufs, NELEM(maxnbufs)))
96  	       return 0;
97  	  if (p->r0 != p->cr) {
98  	       if (p->kind == HC2R) {
99  		    return (NO_DESTROY_INPUTP(plnr));
100  	       } else {
101  		    return (d[0].os > 2);
102  	       }
103  	  }
104  	  if (X(rdft2_inplace_strides(p, RNK_MINFTY)))
105  	       return 1;
106  	  if (&bsol;* fits into buffer: */
107  	       ((p->vecsz->rnk == 0)
108  		||
109  		(X(nbuf)(d[0].n, p->vecsz->dims[0].n,
110  			 maxnbufs[ego->maxnbuf_ndx])
111  		 == p->vecsz->dims[0].n)))
112  	       return 1;
113       }
114       return 0;
115  }
116  static int applicable(const S *ego, const problem *p_, const planner *plnr)
117  {
118       const problem_rdft2 *p;
119       if (NO_BUFFERINGP(plnr)) return 0;
120       if (!applicable0(ego, p_, plnr)) return 0;
121       p = (const problem_rdft2 *) p_;
122       if (p->kind == HC2R) {
123  	  if (NO_UGLYP(plnr)) {
124  	       if (p->r0 == p->cr && X(toobig)(p->sz->dims[0].n)) 
125  		    return 0;
126  	  }
127       } else {
128  	  if (NO_UGLYP(plnr)) {
129  	       if (p->r0 != p->cr || X(toobig)(p->sz->dims[0].n))
130  		    return 0;
131  	  }
132       }
133       return 1;
134  }
135  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
136  {
137       P *pln;
138       const S *ego = (const S *)ego_;
139       plan *cld = (plan *) 0;
140       plan *cldcpy = (plan *) 0;
141       plan *cldrest = (plan *) 0;
142       const problem_rdft2 *p = (const problem_rdft2 *) p_;
143       R *bufs = (R *) 0;
144       INT nbuf = 0, bufdist, n, vl;
145       INT ivs, ovs, ioffset, roffset, id, od;
146       static const plan_adt padt = {
147  	  X(rdft2_solve), awake, print, destroy
148       };
149       if (!applicable(ego, p_, plnr))
150            goto nada;
151       n = X(tensor_sz)(p->sz);
152       X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs);
153       nbuf = X(nbuf)(n, vl, maxnbufs[ego->maxnbuf_ndx]);
154       bufdist = X(bufdist)(n + 2, vl); &bsol;* complex-side rdft2 stores N+2
155  					 real numbers */
156       A(nbuf > 0);
157       roffset = (p->cr - p->ci > 0) ? (INT)1 : (INT)0;
158       ioffset = 1 - roffset;
159       bufs = (R *) MALLOC(sizeof(R) * nbuf * bufdist, BUFFERS);
160       id = ivs * (nbuf * (vl / nbuf));
161       od = ovs * (nbuf * (vl / nbuf));
162       if (p->kind == R2HC) {
163  	  cld = X(mkplan_f_d)(
164  	       plnr, 
165  	       X(mkproblem_rdft2_d)(
166  		    X(mktensor_1d)(n, p->sz->dims[0].is, 2),
167  		    X(mktensor_1d)(nbuf, ivs, bufdist),
168  		    TAINT(p->r0, ivs * nbuf), TAINT(p->r1, ivs * nbuf),
169  		    bufs + roffset, bufs + ioffset, p->kind),
170  	       0, 0, (p->r0 == p->cr) ? NO_DESTROY_INPUT : 0);
171  	  if (!cld) goto nada;
172  	  cldcpy = X(mkplan_d)(
173  	       plnr, 
174  	       X(mkproblem_dft_d)(
175  		    X(mktensor_0d)(),
176  		    X(mktensor_2d)(nbuf, bufdist, ovs,
177  				   n/2+1, 2, p->sz->dims[0].os),
178  		    bufs + roffset, bufs + ioffset,
179  		    TAINT(p->cr, ovs * nbuf), TAINT(p->ci, ovs * nbuf) ));
180  	  if (!cldcpy) goto nada;
181  	  X(ifree)(bufs); bufs = 0;
182  	  cldrest = X(mkplan_d)(plnr, 
183  				X(mkproblem_rdft2_d)(
184  				     X(tensor_copy)(p->sz),
185  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
186  				     p->r0 + id, p->r1 + id, 
187  				     p->cr + od, p->ci + od,
188  				     p->kind));
189  	  if (!cldrest) goto nada;
190  	  pln = MKPLAN_RDFT2(P, &padt, apply_r2hc);
191       } else {
192  	  cld = X(mkplan_f_d)(
193  	       plnr, 
194  	       X(mkproblem_rdft2_d)(
195  		    X(mktensor_1d)(n, 2, p->sz->dims[0].os),
196  		    X(mktensor_1d)(nbuf, bufdist, ovs),
197  		    TAINT(p->r0, ovs * nbuf), TAINT(p->r1, ovs * nbuf),
198  		    bufs + roffset, bufs + ioffset, p->kind),
199  	       0, 0, NO_DESTROY_INPUT);
200  	  if (!cld) goto nada;
201  	  cldcpy = X(mkplan_d)(
202  	       plnr, 
203  	       X(mkproblem_dft_d)(
204  		    X(mktensor_0d)(),
205  		    X(mktensor_2d)(nbuf, ivs, bufdist,
206  				   n/2+1, p->sz->dims[0].is, 2),
207  		    TAINT(p->cr, ivs * nbuf), TAINT(p->ci, ivs * nbuf), 
208  		    bufs + roffset, bufs + ioffset));
209  	  if (!cldcpy) goto nada;
210  	  X(ifree)(bufs); bufs = 0;
211  	  cldrest = X(mkplan_d)(plnr, 
212  				X(mkproblem_rdft2_d)(
213  				     X(tensor_copy)(p->sz),
214  				     X(mktensor_1d)(vl % nbuf, ivs, ovs),
215  				     p->r0 + od, p->r1 + od, 
216  				     p->cr + id, p->ci + id,
217  				     p->kind));
218  	  if (!cldrest) goto nada;
219  	  pln = MKPLAN_RDFT2(P, &padt, apply_hc2r);
220       }
<span onclick='openModal()' class='match'>221       pln->cld = cld;
222       pln->cldcpy = cldcpy;
223       pln->cldrest = cldrest;
224       pln->n = n;
225       pln->vl = vl;
226       pln->ivs_by_nbuf = ivs * nbuf;
227       pln->ovs_by_nbuf = ovs * nbuf;
228       pln->roffset = roffset;
229       pln->ioffset = ioffset;
230       pln->nbuf = nbuf;
231       pln->bufdist = bufdist;
232       {
</span>233  	  opcnt t;
234  	  X(ops_add)(&cld->ops, &cldcpy->ops, &t);
235  	  X(ops_madd)(vl / nbuf, &t, &cldrest->ops, &pln->super.super.ops);
236       }
237       return &(pln->super.super);
238   nada:
239       X(ifree0)(bufs);
240       X(plan_destroy_internal)(cldrest);
241       X(plan_destroy_internal)(cldcpy);
242       X(plan_destroy_internal)(cld);
243       return (plan *) 0;
244  }
245  static solver *mksolver(size_t maxnbuf_ndx)
246  {
247       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
248       S *slv = MKSOLVER(S, &sadt);
249       slv->maxnbuf_ndx = maxnbuf_ndx;
250       return &(slv->super);
251  }
252  void X(rdft2_buffered_register)(planner *p)
253  {
254       size_t i;
255       for (i = 0; i < NELEM(maxnbufs); ++i)
256  	  REGISTER_SOLVER(p, mksolver(i));
257  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-generic.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-buffered2.c</div>
                </div>
                <div class="column column_space"><pre><code>114       pln->cld = cld;
115       pln->r = r;
116       pln->rs = irs;
117       pln->m = m;
118       pln->ms = ms;
119       pln->v = v;
120       pln->vs = ivs;
121       pln->mb = mstart;
122       pln->me = mstart + mcount;
123       pln->dec = ego->dec;
124       pln->td = 0;
125       {
</pre></code></div>
                <div class="column column_space"><pre><code>221       pln->cld = cld;
222       pln->cldcpy = cldcpy;
223       pln->cldrest = cldrest;
224       pln->n = n;
225       pln->vl = vl;
226       pln->ivs_by_nbuf = ivs * nbuf;
227       pln->ovs_by_nbuf = ovs * nbuf;
228       pln->roffset = roffset;
229       pln->ioffset = ioffset;
230       pln->nbuf = nbuf;
231       pln->bufdist = bufdist;
232       {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    