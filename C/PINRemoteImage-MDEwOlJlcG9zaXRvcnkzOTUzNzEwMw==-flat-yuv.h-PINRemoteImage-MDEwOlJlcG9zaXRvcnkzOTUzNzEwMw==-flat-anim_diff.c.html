
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.845117845117844%, Tokens: 16</h2>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv.h</h3>
            <pre><code>1  #ifndef WEBP_DSP_YUV_H_
2  #define WEBP_DSP_YUV_H_
3  #include "src/dsp/dsp.h"
4  #include "src/dec/vp8_dec.h"
5  #ifdef __cplusplus
6  extern "C" {
7  #endif
8  enum {
9    YUV_FIX = 16,                    
10    YUV_HALF = 1 << (YUV_FIX - 1),
11    YUV_FIX2 = 6,                   
12    YUV_MASK2 = (256 << YUV_FIX2) - 1
13  };
14  static WEBP_INLINE int MultHi(int v, int coeff) {   
15    return (v * coeff) >> 8;
16  }
17  static WEBP_INLINE int VP8Clip8(int v) {
18    return ((v & ~YUV_MASK2) == 0) ? (v >> YUV_FIX2) : (v < 0) ? 0 : 255;
19  }
20  static WEBP_INLINE int VP8YUVToR(int y, int v) {
21    return VP8Clip8(MultHi(y, 19077) + MultHi(v, 26149) - 14234);
22  }
23  static WEBP_INLINE int VP8YUVToG(int y, int u, int v) {
24    return VP8Clip8(MultHi(y, 19077) - MultHi(u, 6419) - MultHi(v, 13320) + 8708);
25  }
26  static WEBP_INLINE int VP8YUVToB(int y, int u) {
27    return VP8Clip8(MultHi(y, 19077) + MultHi(u, 33050) - 17685);
28  }
29  static WEBP_INLINE void VP8YuvToRgb(int y, int u, int v,
30                                      uint8_t* const rgb) {
31    rgb[0] = VP8YUVToR(y, v);
32    rgb[1] = VP8YUVToG(y, u, v);
33    rgb[2] = VP8YUVToB(y, u);
34  }
35  static WEBP_INLINE void VP8YuvToBgr(int y, int u, int v,
36                                      uint8_t* const bgr) {
37    bgr[0] = VP8YUVToB(y, u);
38    bgr[1] = VP8YUVToG(y, u, v);
39    bgr[2] = VP8YUVToR(y, v);
40  }
41  static WEBP_INLINE void VP8YuvToRgb565(int y, int u, int v,
<span onclick='openModal()' class='match'>42                                         uint8_t* const rgb) {
43    const int r = VP8YUVToR(y, v);      
44    const int g = VP8YUVToG(y, u, v);   
45    const int b = VP8YUVToB(y, u);      
46    const int rg = (r & 0xf8) | (g >> 5);
47    const int gb = ((g << 3) & 0xe0) | (b >> 3);
</span>48  #if (WEBP_SWAP_16BIT_CSP == 1)
49    rgb[0] = gb;
50    rgb[1] = rg;
51  #else
52    rgb[0] = rg;
53    rgb[1] = gb;
54  #endif
55  }
56  static WEBP_INLINE void VP8YuvToRgba4444(int y, int u, int v,
57                                           uint8_t* const argb) {
58    const int r = VP8YUVToR(y, v);        
59    const int g = VP8YUVToG(y, u, v);     
60    const int b = VP8YUVToB(y, u);        
61    const int rg = (r & 0xf0) | (g >> 4);
62    const int ba = (b & 0xf0) | 0x0f;     
63  #if (WEBP_SWAP_16BIT_CSP == 1)
64    argb[0] = ba;
65    argb[1] = rg;
66  #else
67    argb[0] = rg;
68    argb[1] = ba;
69  #endif
70  }
71  static WEBP_INLINE void VP8YuvToArgb(uint8_t y, uint8_t u, uint8_t v,
72                                       uint8_t* const argb) {
73    argb[0] = 0xff;
74    VP8YuvToRgb(y, u, v, argb + 1);
75  }
76  static WEBP_INLINE void VP8YuvToBgra(uint8_t y, uint8_t u, uint8_t v,
77                                       uint8_t* const bgra) {
78    VP8YuvToBgr(y, u, v, bgra);
79    bgra[3] = 0xff;
80  }
81  static WEBP_INLINE void VP8YuvToRgba(uint8_t y, uint8_t u, uint8_t v,
82                                       uint8_t* const rgba) {
83    VP8YuvToRgb(y, u, v, rgba);
84    rgba[3] = 0xff;
85  }
86  #if defined(WEBP_USE_SSE2)
87  void VP8YuvToRgba32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
88                           uint8_t* dst);
89  void VP8YuvToRgb32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
90                          uint8_t* dst);
91  void VP8YuvToBgra32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
92                           uint8_t* dst);
93  void VP8YuvToBgr32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
94                          uint8_t* dst);
95  void VP8YuvToArgb32_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
96                           uint8_t* dst);
97  void VP8YuvToRgba444432_SSE2(const uint8_t* y, const uint8_t* u,
98                               const uint8_t* v, uint8_t* dst);
99  void VP8YuvToRgb56532_SSE2(const uint8_t* y, const uint8_t* u, const uint8_t* v,
100                             uint8_t* dst);
101  #endif    
102  #if defined(WEBP_USE_SSE41)
103  void VP8YuvToRgb32_SSE41(const uint8_t* y, const uint8_t* u, const uint8_t* v,
104                           uint8_t* dst);
105  void VP8YuvToBgr32_SSE41(const uint8_t* y, const uint8_t* u, const uint8_t* v,
106                           uint8_t* dst);
107  #endif    
108  static WEBP_INLINE int VP8ClipUV(int uv, int rounding) {
109    uv = (uv + rounding + (128 << (YUV_FIX + 2))) >> (YUV_FIX + 2);
110    return ((uv & ~0xff) == 0) ? uv : (uv < 0) ? 0 : 255;
111  }
112  static WEBP_INLINE int VP8RGBToY(int r, int g, int b, int rounding) {
113    const int luma = 16839 * r + 33059 * g + 6420 * b;
114    return (luma + rounding + (16 << YUV_FIX)) >> YUV_FIX;  
115  }
116  static WEBP_INLINE int VP8RGBToU(int r, int g, int b, int rounding) {
117    const int u = -9719 * r - 19081 * g + 28800 * b;
118    return VP8ClipUV(u, rounding);
119  }
120  static WEBP_INLINE int VP8RGBToV(int r, int g, int b, int rounding) {
121    const int v = +28800 * r - 24116 * g - 4684 * b;
122    return VP8ClipUV(v, rounding);
123  }
124  #ifdef __cplusplus
125  }    
126  #endif
127  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_diff.c</h3>
            <pre><code>1  #include <assert.h>
2  #include <limits.h>
3  #include <stdio.h>
4  #include <stdlib.h>  
5  #include <string.h>  
6  #include "./anim_util.h"
7  #include "./example_util.h"
8  #include "./unicode.h"
9  #if defined(_MSC_VER) && _MSC_VER < 1900
10  #define snprintf _snprintf
11  #endif
12  static int AdditionWillOverflow(int a, int b) {
13    return (b > 0) && (a > INT_MAX - b);
14  }
15  static int FramesAreEqual(const uint8_t* const rgba1,
16                            const uint8_t* const rgba2, int width, int height) {
17    const int stride = width * 4;  
18    return !memcmp(rgba1, rgba2, stride * height);
19  }
20  static WEBP_INLINE int PixelsAreSimilar(uint32_t src, uint32_t dst,
<span onclick='openModal()' class='match'>21                                          int max_allowed_diff) {
22    const int src_a = (src >> 24) & 0xff;
23    const int src_r = (src >> 16) & 0xff;
24    const int src_g = (src >> 8) & 0xff;
25    const int src_b = (src >> 0) & 0xff;
26    const int dst_a = (dst >> 24) & 0xff;
</span>27    const int dst_r = (dst >> 16) & 0xff;
28    const int dst_g = (dst >> 8) & 0xff;
29    const int dst_b = (dst >> 0) & 0xff;
30    return (abs(src_r * src_a - dst_r * dst_a) <= (max_allowed_diff * 255)) &&
31           (abs(src_g * src_a - dst_g * dst_a) <= (max_allowed_diff * 255)) &&
32           (abs(src_b * src_a - dst_b * dst_a) <= (max_allowed_diff * 255)) &&
33           (abs(src_a - dst_a) <= max_allowed_diff);
34  }
35  static int FramesAreSimilar(const uint8_t* const rgba1,
36                              const uint8_t* const rgba2,
37                              int width, int height, int max_allowed_diff) {
38    int i, j;
39    assert(max_allowed_diff > 0);
40    for (j = 0; j < height; ++j) {
41      for (i = 0; i < width; ++i) {
42        const int stride = width * 4;
43        const size_t offset = j * stride + i;
44        if (!PixelsAreSimilar(rgba1[offset], rgba2[offset], max_allowed_diff)) {
45          return 0;
46        }
47      }
48    }
49    return 1;
50  }
51  static void MinimizeAnimationFrames(AnimatedImage* const img, int max_diff) {
52    uint32_t i;
53    for (i = 1; i < img->num_frames; ++i) {
54      DecodedFrame* const frame1 = &img->frames[i - 1];
55      DecodedFrame* const frame2 = &img->frames[i];
56      const uint8_t* const rgba1 = frame1->rgba;
57      const uint8_t* const rgba2 = frame2->rgba;
58      int should_merge_frames = 0;
59      if (AdditionWillOverflow(frame1->duration, frame2->duration)) continue;
60      if (max_diff > 0) {
61        should_merge_frames = FramesAreSimilar(rgba1, rgba2, img->canvas_width,
62                                               img->canvas_height, max_diff);
63      } else {
64        should_merge_frames =
65            FramesAreEqual(rgba1, rgba2, img->canvas_width, img->canvas_height);
66      }
67      if (should_merge_frames) {  
68        frame1->duration += frame2->duration;
69        if (i + 1 < img->num_frames) {
70          memmove(&img->frames[i], &img->frames[i + 1],
71                  (img->num_frames - i - 1) * sizeof(*img->frames));
72        }
73        --img->num_frames;
74        --i;
75      }
76    }
77  }
78  static int CompareValues(uint32_t a, uint32_t b, const char* output_str) {
79    if (a != b) {
80      fprintf(stderr, "%s: %d vs %d\n", output_str, a, b);
81      return 0;
82    }
83    return 1;
84  }
85  static int CompareBackgroundColor(uint32_t bg1, uint32_t bg2, int premultiply) {
86    if (premultiply) {
87      const int alpha1 = (bg1 >> 24) & 0xff;
88      const int alpha2 = (bg2 >> 24) & 0xff;
89      if (alpha1 == 0 && alpha2 == 0) return 1;
90    }
91    if (bg1 != bg2) {
92      fprintf(stderr, "Background color mismatch: 0x%08x vs 0x%08x\n",
93              bg1, bg2);
94      return 0;
95    }
96    return 1;
97  }
98  static int CompareAnimatedImagePair(const AnimatedImage* const img1,
99                                      const AnimatedImage* const img2,
100                                      int premultiply,
101                                      double min_psnr) {
102    int ok = 1;
103    const int is_multi_frame_image = (img1->num_frames > 1);
104    uint32_t i;
105    ok = CompareValues(img1->canvas_width, img2->canvas_width,
106                       "Canvas width mismatch") && ok;
107    ok = CompareValues(img1->canvas_height, img2->canvas_height,
108                       "Canvas height mismatch") && ok;
109    ok = CompareValues(img1->num_frames, img2->num_frames,
110                       "Frame count mismatch") && ok;
111    if (!ok) return 0;  
112    if (is_multi_frame_image) {  
113      int max_loop_count_workaround = 0;
114      if ((img1->format == ANIM_GIF && img1->loop_count == 65536 &&
115           img2->format == ANIM_WEBP && img2->loop_count == 65535) ||
116          (img1->format == ANIM_WEBP && img1->loop_count == 65535 &&
117           img2->format == ANIM_GIF && img2->loop_count == 65536)) {
118        max_loop_count_workaround = 1;
119      }
120      ok = (max_loop_count_workaround ||
121            CompareValues(img1->loop_count, img2->loop_count,
122                          "Loop count mismatch")) && ok;
123      ok = CompareBackgroundColor(img1->bgcolor, img2->bgcolor,
124                                  premultiply) && ok;
125    }
126    for (i = 0; i < img1->num_frames; ++i) {
127      const uint8_t* const rgba1 = img1->frames[i].rgba;
128      const uint8_t* const rgba2 = img2->frames[i].rgba;
129      int max_diff;
130      double psnr;
131      if (is_multi_frame_image) {  
132        const char format[] = "Frame #%d, duration mismatch";
133        char tmp[sizeof(format) + 8];
134        ok = ok && (snprintf(tmp, sizeof(tmp), format, i) >= 0);
135        ok = ok && CompareValues(img1->frames[i].duration,
136                                 img2->frames[i].duration, tmp);
137      }
138      GetDiffAndPSNR(rgba1, rgba2, img1->canvas_width, img1->canvas_height,
139                     premultiply, &max_diff, &psnr);
140      if (min_psnr > 0.) {
141        if (psnr < min_psnr) {
142          fprintf(stderr, "Frame #%d, psnr = %.2lf (min_psnr = %f)\n", i,
143                  psnr, min_psnr);
144          ok = 0;
145        }
146      } else {
147        if (max_diff != 0) {
148          fprintf(stderr, "Frame #%d, max pixel diff: %d\n", i, max_diff);
149          ok = 0;
150        }
151      }
152    }
153    return ok;
154  }
155  static void Help(void) {
156    printf("Usage: anim_diff <image1> <image2> [options]\n");
157    printf("\nOptions:\n");
158    printf("  -dump_frames <folder> dump decoded frames in PAM format\n");
159    printf("  -min_psnr <float> ... minimum per-frame PSNR\n");
160    printf("  -raw_comparison ..... if this flag is not used, RGB is\n");
161    printf("                        premultiplied before comparison\n");
162    printf("  -max_diff <int> ..... maximum allowed difference per channel\n"
163           "                        between corresponding pixels in subsequent\n"
164           "                        frames\n");
165    printf("  -h .................. this help\n");
166    printf("  -version ............ print version number and exit\n");
167  }
168  int main(int argc, const char* argv[]) {
169    int return_code = -1;
170    int dump_frames = 0;
171    const char* dump_folder = NULL;
172    double min_psnr = 0.;
173    int got_input1 = 0;
174    int got_input2 = 0;
175    int premultiply = 1;
176    int max_diff = 0;
177    int i, c;
178    const char* files[2] = { NULL, NULL };
179    AnimatedImage images[2];
180    INIT_WARGV(argc, argv);
181    for (c = 1; c < argc; ++c) {
182      int parse_error = 0;
183      if (!strcmp(argv[c], "-dump_frames")) {
184        if (c < argc - 1) {
185          dump_frames = 1;
186          dump_folder = (const char*)GET_WARGV(argv, ++c);
187        } else {
188          parse_error = 1;
189        }
190      } else if (!strcmp(argv[c], "-min_psnr")) {
191        if (c < argc - 1) {
192          min_psnr = ExUtilGetFloat(argv[++c], &parse_error);
193        } else {
194          parse_error = 1;
195        }
196      } else if (!strcmp(argv[c], "-raw_comparison")) {
197        premultiply = 0;
198      } else if (!strcmp(argv[c], "-max_diff")) {
199        if (c < argc - 1) {
200          max_diff = ExUtilGetInt(argv[++c], 0, &parse_error);
201        } else {
202          parse_error = 1;
203        }
204      } else if (!strcmp(argv[c], "-h") || !strcmp(argv[c], "-help")) {
205        Help();
206        FREE_WARGV_AND_RETURN(0);
207      } else if (!strcmp(argv[c], "-version")) {
208        int dec_version, demux_version;
209        GetAnimatedImageVersions(&dec_version, &demux_version);
210        printf("WebP Decoder version: %d.%d.%d\nWebP Demux version: %d.%d.%d\n",
211               (dec_version >> 16) & 0xff, (dec_version >> 8) & 0xff,
212               (dec_version >> 0) & 0xff,
213               (demux_version >> 16) & 0xff, (demux_version >> 8) & 0xff,
214               (demux_version >> 0) & 0xff);
215        FREE_WARGV_AND_RETURN(0);
216      } else {
217        if (!got_input1) {
218          files[0] = (const char*)GET_WARGV(argv, c);
219          got_input1 = 1;
220        } else if (!got_input2) {
221          files[1] = (const char*)GET_WARGV(argv, c);
222          got_input2 = 1;
223        } else {
224          parse_error = 1;
225        }
226      }
227      if (parse_error) {
228        Help();
229        FREE_WARGV_AND_RETURN(-1);
230      }
231    }
232    if (argc < 3) {
233      Help();
234      FREE_WARGV_AND_RETURN(-1);
235    }
236    if (!got_input2) {
237      Help();
238      FREE_WARGV_AND_RETURN(-1);
239    }
240    if (dump_frames) {
241      WPRINTF("Dumping decoded frames in: %s\n", (const W_CHAR*)dump_folder);
242    }
243    memset(images, 0, sizeof(images));
244    for (i = 0; i < 2; ++i) {
245      WPRINTF("Decoding file: %s\n", (const W_CHAR*)files[i]);
246      if (!ReadAnimatedImage(files[i], &images[i], dump_frames, dump_folder)) {
247        WFPRINTF(stderr, "Error decoding file: %s\n Aborting.\n",
248                 (const W_CHAR*)files[i]);
249        return_code = -2;
250        goto End;
251      } else {
252        MinimizeAnimationFrames(&images[i], max_diff);
253      }
254    }
255    if (!CompareAnimatedImagePair(&images[0], &images[1],
256                                  premultiply, min_psnr)) {
257      WFPRINTF(stderr, "\nFiles %s and %s differ.\n", (const W_CHAR*)files[0],
258               (const W_CHAR*)files[1]);
259      return_code = -3;
260    } else {
261      WPRINTF("\nFiles %s and %s are identical.\n", (const W_CHAR*)files[0],
262              (const W_CHAR*)files[1]);
263      return_code = 0;
264    }
265   End:
266    ClearAnimatedImage(&images[0]);
267    ClearAnimatedImage(&images[1]);
268    FREE_WARGV_AND_RETURN(return_code);
269  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-yuv.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from PINRemoteImage-MDEwOlJlcG9zaXRvcnkzOTUzNzEwMw==-flat-anim_diff.c</div>
                </div>
                <div class="column column_space"><pre><code>42                                         uint8_t* const rgb) {
43    const int r = VP8YUVToR(y, v);      
44    const int g = VP8YUVToG(y, u, v);   
45    const int b = VP8YUVToB(y, u);      
46    const int rg = (r & 0xf8) | (g >> 5);
47    const int gb = ((g << 3) & 0xe0) | (b >> 3);
</pre></code></div>
                <div class="column column_space"><pre><code>21                                          int max_allowed_diff) {
22    const int src_a = (src >> 24) & 0xff;
23    const int src_r = (src >> 16) & 0xff;
24    const int src_g = (src >> 8) & 0xff;
25    const int src_b = (src >> 0) & 0xff;
26    const int dst_a = (dst >> 24) & 0xff;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    