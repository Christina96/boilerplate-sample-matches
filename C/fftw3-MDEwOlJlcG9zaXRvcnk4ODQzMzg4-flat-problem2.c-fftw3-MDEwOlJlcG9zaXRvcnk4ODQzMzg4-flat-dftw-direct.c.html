
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.479028697571744%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-problem2.c</h3>
            <pre><code>1  #include "dft/dft.h"
2  #include "rdft/rdft.h"
3  #include <stddef.h>
4  static void destroy(problem *ego_)
5  {
6       problem_rdft2 *ego = (problem_rdft2 *) ego_;
7       X(tensor_destroy2)(ego->vecsz, ego->sz);
8       X(ifree)(ego_);
9  }
10  static void hash(const problem *p_, md5 *m)
11  {
12       const problem_rdft2 *p = (const problem_rdft2 *) p_;
13       X(md5puts)(m, "rdft2");
14       X(md5int)(m, p->r0 == p->cr);
15       X(md5INT)(m, p->r1 - p->r0);
16       X(md5INT)(m, p->ci - p->cr);
17       X(md5int)(m, X(ialignment_of)(p->r0));
18       X(md5int)(m, X(ialignment_of)(p->r1));
19       X(md5int)(m, X(ialignment_of)(p->cr)); 
20       X(md5int)(m, X(ialignment_of)(p->ci)); 
21       X(md5int)(m, p->kind);
22       X(tensor_md5)(m, p->sz);
23       X(tensor_md5)(m, p->vecsz);
24  }
25  static void print(const problem *ego_, printer *p)
26  {
27       const problem_rdft2 *ego = (const problem_rdft2 *) ego_;
28       p->print(p, "(rdft2 %d %d %T %T)", 
29  	      (int)(ego->cr == ego->r0), 
30  	      (int)(ego->kind),
31  	      ego->sz,
32  	      ego->vecsz);
33  }
34  static void recur(const iodim *dims, int rnk, R *I0, R *I1)
35  {
36       if (rnk == RNK_MINFTY)
37            return;
38       else if (rnk == 0)
39            I0[0] = K(0.0);
40       else if (rnk > 0) {
41            INT i, n = dims[0].n, is = dims[0].is;
42  	  if (rnk == 1) {
43  	       for (i = 0; i < n - 1; i += 2) {
44  		    *I0 = *I1 = K(0.0);
45  		    I0 += is; I1 += is;
46  	       }
47  	       if (i < n) 
48  		    *I0 = K(0.0);
49  	  } else {
50  	       for (i = 0; i < n; ++i)
51  		    recur(dims + 1, rnk - 1, I0 + i * is, I1 + i * is);
52  	  }
53       }
54  }
55  static void vrecur(const iodim *vdims, int vrnk,
56  		   const iodim *dims, int rnk, R *I0, R *I1)
57  {
58       if (vrnk == RNK_MINFTY)
59            return;
60       else if (vrnk == 0)
61  	  recur(dims, rnk, I0, I1);
62       else if (vrnk > 0) {
63            INT i, n = vdims[0].n, is = vdims[0].is;
64  	  for (i = 0; i < n; ++i)
65  	       vrecur(vdims + 1, vrnk - 1, 
66  		      dims, rnk, I0 + i * is, I1 + i * is);
67       }
68  }
69  INT X(rdft2_complex_n)(INT real_n, rdft_kind kind)
70  {
71       switch (kind) {
72  	 case R2HC:
73  	 case HC2R:
74  	      return (real_n / 2) + 1;
75  	 case R2HCII:
76  	 case HC2RIII:
77  	      return (real_n + 1) / 2;
78  	 default:
79  	      A(0);
80  	      return 0;
<span onclick='openModal()' class='match'>81       }
82  }
83  static void zero(const problem *ego_)
84  {
85       const problem_rdft2 *ego = (const problem_rdft2 *) ego_;
</span>86       if (R2HC_KINDP(ego->kind)) {
87  	  vrecur(ego->vecsz->dims, ego->vecsz->rnk, 
88  		 ego->sz->dims, ego->sz->rnk, 
89  		 UNTAINT(ego->r0), UNTAINT(ego->r1));
90       } else {
91  	  tensor *sz;
92  	  tensor *sz2 = X(tensor_copy)(ego->sz);
93  	  int rnk = sz2->rnk;
94  	  if (rnk > 0) &bsol;* ~half as many complex outputs */
95  	       sz2->dims[rnk-1].n = 
96  		    X(rdft2_complex_n)(sz2->dims[rnk-1].n, ego->kind);
97  	  sz = X(tensor_append)(ego->vecsz, sz2);
98  	  X(tensor_destroy)(sz2);
99  	  X(dft_zerotens)(sz, UNTAINT(ego->cr), UNTAINT(ego->ci));
100  	  X(tensor_destroy)(sz);
101       }
102  }
103  static const problem_adt padt =
104  {
105       PROBLEM_RDFT2,
106       hash,
107       zero,
108       print,
109       destroy
110  };
111  problem *X(mkproblem_rdft2)(const tensor *sz, const tensor *vecsz,
112  			    R *r0, R *r1, R *cr, R *ci,
113  			    rdft_kind kind)
114  {
115       problem_rdft2 *ego;
116       A(kind == R2HC || kind == R2HCII || kind == HC2R || kind == HC2RIII);
117       A(X(tensor_kosherp)(sz));
118       A(X(tensor_kosherp)(vecsz));
119       A(FINITE_RNK(sz->rnk));
120       if (UNTAINT(r0) == UNTAINT(ci))
121  	  return X(mkproblem_unsolvable)();
122       if (UNTAINT(r0) == UNTAINT(cr)) 
123  	  r0 = cr = JOIN_TAINT(r0, cr);
124       ego = (problem_rdft2 *)X(mkproblem)(sizeof(problem_rdft2), &padt);
125       if (sz->rnk > 1) { &bsol;* have to compress rnk-1 dims separately, ugh */
126  	  tensor *szc = X(tensor_copy_except)(sz, sz->rnk - 1);
127  	  tensor *szr = X(tensor_copy_sub)(sz, sz->rnk - 1, 1);
128  	  tensor *szcc = X(tensor_compress)(szc);
129  	  if (szcc->rnk > 0)
130  	       ego->sz = X(tensor_append)(szcc, szr);
131  	  else
132  	       ego->sz = X(tensor_compress)(szr);
133  	  X(tensor_destroy2)(szc, szr); X(tensor_destroy)(szcc);
134       } else {
135  	  ego->sz = X(tensor_compress)(sz);
136       }
137       ego->vecsz = X(tensor_compress_contiguous)(vecsz);
138       ego->r0 = r0;
139       ego->r1 = r1;
140       ego->cr = cr;
141       ego->ci = ci;
142       ego->kind = kind;
143       A(FINITE_RNK(ego->sz->rnk));
144       return &(ego->super);
145  }
146  problem *X(mkproblem_rdft2_d)(tensor *sz, tensor *vecsz,
147  			      R *r0, R *r1, R *cr, R *ci, rdft_kind kind)
148  {
149       problem *p = X(mkproblem_rdft2)(sz, vecsz, r0, r1, cr, ci, kind);
150       X(tensor_destroy2)(vecsz, sz);
151       return p;
152  }
153  problem *X(mkproblem_rdft2_d_3pointers)(tensor *sz, tensor *vecsz,
154  					R *r0, R *cr, R *ci, rdft_kind kind)
155  {
156       problem *p;
157       int rnk = sz->rnk;
158       R *r1;
159       if (rnk == 0)
160  	  r1 = r0;
161       else if (R2HC_KINDP(kind)) {
162  	  r1 = r0 + sz->dims[rnk-1].is;
163  	  sz->dims[rnk-1].is *= 2;
164       } else {
165  	  r1 = r0 + sz->dims[rnk-1].os;
166  	  sz->dims[rnk-1].os *= 2;
167       }
168       p = X(mkproblem_rdft2)(sz, vecsz, r0, r1, cr, ci, kind);
169       X(tensor_destroy2)(vecsz, sz);
170       return p;
171  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-direct.c</h3>
            <pre><code>1  #include "dft/ct.h"
2  typedef struct {
3       ct_solver super;
4       const ct_desc *desc;
5       int bufferedp;
6       kdftw k;
7  } S;
8  typedef struct {
9       plan_dftw super;
10       kdftw k;
11       INT r;
12       stride rs;
13       INT m, ms, v, vs, mb, me, extra_iter;
14       stride brs;
15       twid *td;
16       const S *slv;
17  } P;
18  static void apply(const plan *ego_, R *rio, R *iio)
19  {
20       const P *ego = (const P *) ego_;
21       INT i;
22       ASSERT_ALIGNED_DOUBLE;
23       for (i = 0; i < ego->v; ++i, rio += ego->vs, iio += ego->vs) {
24  	  INT  mb = ego->mb, ms = ego->ms;
25  	  ego->k(rio + mb*ms, iio + mb*ms, ego->td->W, 
26  		 ego->rs, mb, ego->me, ms);
<span onclick='openModal()' class='match'>27       }
28  }
29  static void apply_extra_iter(const plan *ego_, R *rio, R *iio)
30  {
31       const P *ego = (const P *) ego_;
</span>32       INT i, v = ego->v, vs = ego->vs;
33       INT mb = ego->mb, me = ego->me, mm = me - 1, ms = ego->ms;
34       ASSERT_ALIGNED_DOUBLE;
35       for (i = 0; i < v; ++i, rio += vs, iio += vs) {
36  	  ego->k(rio + mb*ms, iio + mb*ms, ego->td->W, 
37  		 ego->rs, mb, mm, ms);
38  	  ego->k(rio + mm*ms, iio + mm*ms, ego->td->W, 
39  		 ego->rs, mm, mm+2, 0);
40       }
41  }
42  static void dobatch(const P *ego, R *rA, R *iA, INT mb, INT me, R *buf)
43  {
44       INT brs = WS(ego->brs, 1);
45       INT rs = WS(ego->rs, 1);
46       INT ms = ego->ms;
47       X(cpy2d_pair_ci)(rA + mb*ms, iA + mb*ms, buf, buf + 1,
48  		      ego->r, rs, brs,
49  		      me - mb, ms, 2);
50       ego->k(buf, buf + 1, ego->td->W, ego->brs, mb, me, 2);
51       X(cpy2d_pair_co)(buf, buf + 1, rA + mb*ms, iA + mb*ms,
52  		      ego->r, brs, rs,
53  		      me - mb, 2, ms);
54  }
55  static INT compute_batchsize(INT radix)
56  {
57       radix += 3;
58       radix &= -4;
59       return (radix + 2);
60  }
61  static void apply_buf(const plan *ego_, R *rio, R *iio)
62  {
63       const P *ego = (const P *) ego_;
64       INT i, j, v = ego->v, r = ego->r;
65       INT batchsz = compute_batchsize(r);
66       R *buf;
67       INT mb = ego->mb, me = ego->me;
68       size_t bufsz = r * batchsz * 2 * sizeof(R);
69       BUF_ALLOC(R *, buf, bufsz);
70       for (i = 0; i < v; ++i, rio += ego->vs, iio += ego->vs) {
71  	  for (j = mb; j + batchsz < me; j += batchsz) 
72  	       dobatch(ego, rio, iio, j, j + batchsz, buf);
73  	  dobatch(ego, rio, iio, j, me, buf);
74       }
75       BUF_FREE(buf, bufsz);
76  }
77  static void awake(plan *ego_, enum wakefulness wakefulness)
78  {
79       P *ego = (P *) ego_;
80       X(twiddle_awake)(wakefulness, &ego->td, ego->slv->desc->tw,
81  		      ego->r * ego->m, ego->r, ego->m + ego->extra_iter);
82  }
83  static void destroy(plan *ego_)
84  {
85       P *ego = (P *) ego_;
86       X(stride_destroy)(ego->brs);
87       X(stride_destroy)(ego->rs);
88  }
89  static void print(const plan *ego_, printer *p)
90  {
91       const P *ego = (const P *) ego_;
92       const S *slv = ego->slv;
93       const ct_desc *e = slv->desc;
94       if (slv->bufferedp)
95  	  p->print(p, "(dftw-directbuf/%D-%D/%D%v \"%s\")",
96  		   compute_batchsize(ego->r), ego->r,
97  		   X(twiddle_length)(ego->r, e->tw), ego->v, e->nam);
98       else
99  	  p->print(p, "(dftw-direct-%D/%D%v \"%s\")",
100  		   ego->r, X(twiddle_length)(ego->r, e->tw), ego->v, e->nam);
101  }
102  static int applicable0(const S *ego,
103  		       INT r, INT irs, INT ors,
104  		       INT m, INT ms,
105  		       INT v, INT ivs, INT ovs,
106  		       INT mb, INT me,
107  		       R *rio, R *iio,
108  		       const planner *plnr, INT *extra_iter)
109  {
110       const ct_desc *e = ego->desc;
111       UNUSED(v);
112       return (
113  	  1
114  	  && r == e->radix
115  	  && irs == ors &bsol;* in-place along R */
116  	  && ivs == ovs &bsol;* in-place along V */
117  	  && ((*extra_iter = 0,
118  	       e->genus->okp(e, rio, iio, irs, ivs, m, mb, me, ms, plnr))
119  	      ||
120  	      (*extra_iter = 1,
121  	       (1
122  		&& mb == 0 && me == m
123  		&& e->genus->okp(e, rio, iio, irs, ivs,
124  				 m, mb, me - 1, ms, plnr)
125  		&& e->genus->okp(e, rio, iio, irs, ivs,
126  				 m, me - 1, me + 1, ms, plnr))))
127  	  && (e->genus->okp(e, rio + ivs, iio + ivs, irs, ivs,
128  			    m, mb, me - *extra_iter, ms, plnr))
129  	  );
130  }
131  static int applicable0_buf(const S *ego,
132  			   INT r, INT irs, INT ors,
133  			   INT m, INT ms,
134  			   INT v, INT ivs, INT ovs,
135  			   INT mb, INT me,
136  			   R *rio, R *iio,
137  			   const planner *plnr)
138  {
139       const ct_desc *e = ego->desc;
140       INT batchsz;
141       UNUSED(v); UNUSED(ms); UNUSED(rio); UNUSED(iio);
142       return (
143  	  1
144  	  && r == e->radix
145  	  && irs == ors &bsol;* in-place along R */
146  	  && ivs == ovs &bsol;* in-place along V */
147  	  && (batchsz = compute_batchsize(r), 1)
148  	  && (e->genus->okp(e, 0, ((const R *)0) + 1, 2 * batchsz, 0,
149  			    m, mb, mb + batchsz, 2, plnr))
150  	  && (e->genus->okp(e, 0, ((const R *)0) + 1, 2 * batchsz, 0,
151  			    m, mb, me, 2, plnr))
152  	  );
153  }
154  static int applicable(const S *ego,
155  		      INT r, INT irs, INT ors,
156  		      INT m, INT ms,
157  		      INT v, INT ivs, INT ovs,
158  		      INT mb, INT me,
159  		      R *rio, R *iio,
160  		      const planner *plnr, INT *extra_iter)
161  {
162       if (ego->bufferedp) {
163  	  *extra_iter = 0;
164  	  if (!applicable0_buf(ego,
165  			       r, irs, ors, m, ms, v, ivs, ovs, mb, me,
166  			       rio, iio, plnr))
167  	       return 0;
168       } else {
169  	  if (!applicable0(ego,
170  			   r, irs, ors, m, ms, v, ivs, ovs, mb, me,
171  			   rio, iio, plnr, extra_iter))
172  	       return 0;
173       }
174       if (NO_UGLYP(plnr) && X(ct_uglyp)((ego->bufferedp? (INT)512 : (INT)16),
175  				       v, m * r, r))
176  	  return 0;
177       if (m * r > 262144 && NO_FIXED_RADIX_LARGE_NP(plnr))
178  	  return 0;
179       return 1;
180  }
181  static plan *mkcldw(const ct_solver *ego_,
182  		    INT r, INT irs, INT ors,
183  		    INT m, INT ms,
184  		    INT v, INT ivs, INT ovs,
185  		    INT mstart, INT mcount,
186  		    R *rio, R *iio,
187  		    planner *plnr)
188  {
189       const S *ego = (const S *) ego_;
190       P *pln;
191       const ct_desc *e = ego->desc;
192       INT extra_iter;
193       static const plan_adt padt = {
194  	  0, awake, print, destroy
195       };
196       A(mstart >= 0 && mstart + mcount <= m);
197       if (!applicable(ego,
198  		     r, irs, ors, m, ms, v, ivs, ovs, mstart, mstart + mcount,
199  		     rio, iio, plnr, &extra_iter))
200            return (plan *)0;
201       if (ego->bufferedp) {
202  	  pln = MKPLAN_DFTW(P, &padt, apply_buf);
203       } else {
204  	  pln = MKPLAN_DFTW(P, &padt, extra_iter ? apply_extra_iter : apply);
205       }
206       pln->k = ego->k;
207       pln->rs = X(mkstride)(r, irs);
208       pln->td = 0;
209       pln->r = r;
210       pln->m = m;
211       pln->ms = ms;
212       pln->v = v;
213       pln->vs = ivs;
214       pln->mb = mstart;
215       pln->me = mstart + mcount;
216       pln->slv = ego;
217       pln->brs = X(mkstride)(r, 2 * compute_batchsize(r));
218       pln->extra_iter = extra_iter;
219       X(ops_zero)(&pln->super.super.ops);
220       X(ops_madd2)(v * (mcount/e->genus->vl), &e->ops, &pln->super.super.ops);
221       if (ego->bufferedp) {
222  	  pln->super.super.ops.other += 8 * r * mcount * v;
223       }
224       pln->super.super.could_prune_now_p =
225  	  (!ego->bufferedp && r >= 5 && r < 64 && m >= r);
226       return &(pln->super.super);
227  }
228  static void regone(planner *plnr, kdftw codelet,
229  		   const ct_desc *desc, int dec, int bufferedp)
230  {
231       S *slv = (S *)X(mksolver_ct)(sizeof(S), desc->radix, dec, mkcldw, 0);
232       slv->k = codelet;
233       slv->desc = desc;
234       slv->bufferedp = bufferedp;
235       REGISTER_SOLVER(plnr, &(slv->super.super));
236       if (X(mksolver_ct_hook)) {
237  	  slv = (S *)X(mksolver_ct_hook)(sizeof(S), desc->radix,
238  					 dec, mkcldw, 0);
239  	  slv->k = codelet;
240  	  slv->desc = desc;
241  	  slv->bufferedp = bufferedp;
242  	  REGISTER_SOLVER(plnr, &(slv->super.super));
243       }
244  }
245  void X(regsolver_ct_directw)(planner *plnr, kdftw codelet,
246  			     const ct_desc *desc, int dec)
247  {
248       regone(plnr, codelet, desc, dec, &bsol;* bufferedp */ 0);
249       regone(plnr, codelet, desc, dec, &bsol;* bufferedp */ 1);
250  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-problem2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-dftw-direct.c</div>
                </div>
                <div class="column column_space"><pre><code>81       }
82  }
83  static void zero(const problem *ego_)
84  {
85       const problem_rdft2 *ego = (const problem_rdft2 *) ego_;
</pre></code></div>
                <div class="column column_space"><pre><code>27       }
28  }
29  static void apply_extra_iter(const plan *ego_, R *rio, R *iio)
30  {
31       const P *ego = (const P *) ego_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    