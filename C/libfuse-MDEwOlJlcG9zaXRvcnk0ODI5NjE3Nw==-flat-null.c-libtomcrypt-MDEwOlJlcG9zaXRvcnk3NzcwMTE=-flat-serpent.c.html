
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.827751196172249%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-null.c</h3>
            <pre><code>1  #define FUSE_USE_VERSION 31
2  #include <fuse.h>
3  #include <fuse_lowlevel.h>
4  #include <stdio.h>
5  #include <stdlib.h>
6  #include <string.h>
7  #include <unistd.h>
8  #include <time.h>
9  #include <errno.h>
10  static int null_getattr(const char *path, struct stat *stbuf,
11  			struct fuse_file_info *fi)
12  {
13  	(void) fi;
14  	if(strcmp(path, "/") != 0)
15  		return -ENOENT;
16  	stbuf->st_mode = S_IFREG | 0644;
17  	stbuf->st_nlink = 1;
18  	stbuf->st_uid = getuid();
19  	stbuf->st_gid = getgid();
20  	stbuf->st_size = (1ULL << 32); &bsol;* 4G */
21  	stbuf->st_blocks = 0;
22  	stbuf->st_atime = stbuf->st_mtime = stbuf->st_ctime = time(NULL);
23  	return 0;
24  }
25  static int null_truncate(const char *path, off_t size,
26  			 struct fuse_file_info *fi)
27  {
28  	(void) size;
29  	(void) fi;
30  	if(strcmp(path, "/") != 0)
31  		return -ENOENT;
32  	return 0;
33  }
34  static int null_open(const char *path, struct fuse_file_info *fi)
35  {
36  	(void) fi;
37  	if(strcmp(path, "/") != 0)
38  		return -ENOENT;
39  	return 0;
40  }
41  static int null_read(const char *path, char *buf, size_t size,
42  		     off_t offset, struct fuse_file_info *fi)
43  {
44  	(void) buf;
45  	(void) offset;
46  	(void) fi;
47  	if(strcmp(path, "/") != 0)
48  		return -ENOENT;
49  	if (offset >= (1ULL << 32))
50  		return 0;
51  	memset(buf, 0, size);
52  	return size;
53  }
54  static int null_write(const char *path, const char *buf, size_t size,
55  		      off_t offset, struct fuse_file_info *fi)
56  {
57  	(void) buf;
58  	(void) offset;
59  	(void) fi;
60  	if(strcmp(path, "/") != 0)
61  		return -ENOENT;
62  	return size;
63  }
64  static const struct fuse_operations null_oper = {
65  	.getattr	= null_getattr,
66  	.truncate	= null_truncate,
67  	.open		= null_open,
68  	.read		= null_read,
69  	.write		= null_write,
70  };
71  int main(int argc, char *argv[])
72  {
73  	struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
74  	struct fuse_cmdline_opts opts;
75  	struct stat stbuf;
76  	if (fuse_parse_cmdline(&args, &opts) != 0)
77  		return 1;
78  	fuse_opt_free_args(&args);
<span onclick='openModal()' class='match'>79  	if (!opts.mountpoint) {
80  		fprintf(stderr, "missing mountpoint parameter\n");
81  		return 1;
82  	}
83  	if (stat(opts.mountpoint, &stbuf) == -1) {
84  		fprintf(stderr ,"failed to access mountpoint %s: %s\n",
85  			opts.mountpoint, strerror(errno));
86  		free(opts.mountpoint);
87  		return 1;
88  	}
89  	free(opts.mountpoint);
90  	if (!S_ISREG(stbuf.st_mode)) {
</span>91  		fprintf(stderr, "mountpoint is not a regular file\n");
92  		return 1;
93  	}
94  	return fuse_main(argc, argv, &null_oper, NULL);
95  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-serpent.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_SERPENT
3  const struct ltc_cipher_descriptor serpent_desc = {
4     "serpent",
5     25,                  &bsol;* cipher_ID */
6     16, 32, 16, 32,      &bsol;* min_key_len, max_key_len, block_len, default_rounds */
7     &serpent_setup,
8     &serpent_ecb_encrypt,
9     &serpent_ecb_decrypt,
10     &serpent_test,
11     &serpent_done,
12     &serpent_keysize,
13     NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
14  };
15  #define s_lt(i,a,b,c,d,e)  {                                 \
16                              a = ROLc(a, 13);                \
17                              c = ROLc(c, 3);                 \
18                              d = ROLc(d ^ c ^ (a << 3), 7);  \
19                              b = ROLc(b ^ a ^ c, 1);         \
20                              a = ROLc(a ^ b ^ d, 5);         \
21                              c = ROLc(c ^ d ^ (b << 7), 22); \
22                            }
23  #define s_ilt(i,a,b,c,d,e) {                                 \
24                              c = RORc(c, 22);                \
25                              a = RORc(a, 5);                 \
26                              c ^= d ^ (b << 7);              \
27                              a ^= b ^ d;                     \
28                              b = RORc(b, 1);                 \
29                              d = RORc(d, 7) ^ c ^ (a << 3);  \
30                              b ^= a ^ c;                     \
31                              c = RORc(c, 3);                 \
32                              a = RORc(a, 13);                \
33                            }
34  #define s_beforeS0(f) f(0,a,b,c,d,e)
35  #define s_afterS0(f)  f(1,b,e,c,a,d)
36  #define s_afterS1(f)  f(2,c,b,a,e,d)
37  #define s_afterS2(f)  f(3,a,e,b,d,c)
38  #define s_afterS3(f)  f(4,e,b,d,c,a)
39  #define s_afterS4(f)  f(5,b,a,e,c,d)
40  #define s_afterS5(f)  f(6,a,c,b,e,d)
41  #define s_afterS6(f)  f(7,a,c,d,b,e)
42  #define s_afterS7(f)  f(8,d,e,b,a,c)
43  #define s_beforeI7(f) f(8,a,b,c,d,e)
44  #define s_afterI7(f)  f(7,d,a,b,e,c)
45  #define s_afterI6(f)  f(6,a,b,c,e,d)
46  #define s_afterI5(f)  f(5,b,d,e,c,a)
47  #define s_afterI4(f)  f(4,b,c,e,a,d)
48  #define s_afterI3(f)  f(3,a,b,e,c,d)
49  #define s_afterI2(f)  f(2,b,d,e,c,a)
50  #define s_afterI1(f)  f(1,a,b,c,e,d)
51  #define s_afterI0(f)  f(0,a,d,b,e,c)
52  #define s_s0(i, r0, r1, r2, r3, r4) { \
53     r3 ^= r0;   \
54     r4 = r1;    \
55     r1 &= r3;   \
56     r4 ^= r2;   \
57     r1 ^= r0;   \
58     r0 |= r3;   \
59     r0 ^= r4;   \
60     r4 ^= r3;   \
61     r3 ^= r2;   \
62     r2 |= r1;   \
63     r2 ^= r4;   \
64     r4 = ~r4;   \
65     r4 |= r1;   \
66     r1 ^= r3;   \
67     r1 ^= r4;   \
68     r3 |= r0;   \
69     r1 ^= r3;   \
70     r4 ^= r3;   \
71  }
72  #define s_i0(i, r0, r1, r2, r3, r4) { \
73     r2 = ~r2;   \
74     r4 = r1;    \
75     r1 |= r0;   \
76     r4 = ~r4;   \
77     r1 ^= r2;   \
78     r2 |= r4;   \
79     r1 ^= r3;   \
80     r0 ^= r4;   \
81     r2 ^= r0;   \
82     r0 &= r3;   \
83     r4 ^= r0;   \
84     r0 |= r1;   \
85     r0 ^= r2;   \
86     r3 ^= r4;   \
87     r2 ^= r1;   \
88     r3 ^= r0;   \
89     r3 ^= r1;   \
90     r2 &= r3;   \
91     r4 ^= r2;   \
92  }
93  #define s_s1(i, r0, r1, r2, r3, r4) { \
94     r0 = ~r0;   \
95     r2 = ~r2;   \
96     r4 = r0;    \
97     r0 &= r1;   \
98     r2 ^= r0;   \
99     r0 |= r3;   \
100     r3 ^= r2;   \
101     r1 ^= r0;   \
102     r0 ^= r4;   \
103     r4 |= r1;   \
104     r1 ^= r3;   \
105     r2 |= r0;   \
106     r2 &= r4;   \
107     r0 ^= r1;   \
108     r1 &= r2;   \
109     r1 ^= r0;   \
110     r0 &= r2;   \
111     r0 ^= r4;   \
112  }
113  #define s_i1(i, r0, r1, r2, r3, r4) { \
114     r4 = r1;    \
115     r1 ^= r3;   \
116     r3 &= r1;   \
117     r4 ^= r2;   \
118     r3 ^= r0;   \
119     r0 |= r1;   \
120     r2 ^= r3;   \
121     r0 ^= r4;   \
122     r0 |= r2;   \
123     r1 ^= r3;   \
124     r0 ^= r1;   \
125     r1 |= r3;   \
126     r1 ^= r0;   \
127     r4 = ~r4;   \
128     r4 ^= r1;   \
129     r1 |= r0;   \
130     r1 ^= r0;   \
131     r1 |= r4;   \
132     r3 ^= r1;   \
133  }
134  #define s_s2(i, r0, r1, r2, r3, r4) { \
135     r4 = r0;    \
136     r0 &= r2;   \
137     r0 ^= r3;   \
138     r2 ^= r1;   \
139     r2 ^= r0;   \
140     r3 |= r4;   \
141     r3 ^= r1;   \
142     r4 ^= r2;   \
143     r1 = r3;    \
144     r3 |= r4;   \
145     r3 ^= r0;   \
146     r0 &= r1;   \
147     r4 ^= r0;   \
148     r1 ^= r3;   \
149     r1 ^= r4;   \
150     r4 = ~r4;   \
151  }
152  #define s_i2(i, r0, r1, r2, r3, r4) { \
153     r2 ^= r3;   \
154     r3 ^= r0;   \
155     r4 = r3;    \
156     r3 &= r2;   \
157     r3 ^= r1;   \
158     r1 |= r2;   \
159     r1 ^= r4;   \
160     r4 &= r3;   \
161     r2 ^= r3;   \
162     r4 &= r0;   \
163     r4 ^= r2;   \
164     r2 &= r1;   \
165     r2 |= r0;   \
166     r3 = ~r3;   \
167     r2 ^= r3;   \
168     r0 ^= r3;   \
169     r0 &= r1;   \
170     r3 ^= r4;   \
171     r3 ^= r0;   \
172  }
173  #define s_s3(i, r0, r1, r2, r3, r4) { \
174     r4 = r0;    \
175     r0 |= r3;   \
176     r3 ^= r1;   \
177     r1 &= r4;   \
178     r4 ^= r2;   \
179     r2 ^= r3;   \
180     r3 &= r0;   \
181     r4 |= r1;   \
182     r3 ^= r4;   \
183     r0 ^= r1;   \
184     r4 &= r0;   \
185     r1 ^= r3;   \
186     r4 ^= r2;   \
187     r1 |= r0;   \
188     r1 ^= r2;   \
189     r0 ^= r3;   \
190     r2 = r1;    \
191     r1 |= r3;   \
192     r1 ^= r0;   \
193  }
194  #define s_i3(i, r0, r1, r2, r3, r4) { \
195     r4 = r2;    \
196     r2 ^= r1;   \
197     r1 &= r2;   \
198     r1 ^= r0;   \
199     r0 &= r4;   \
200     r4 ^= r3;   \
201     r3 |= r1;   \
202     r3 ^= r2;   \
203     r0 ^= r4;   \
204     r2 ^= r0;   \
205     r0 |= r3;   \
206     r0 ^= r1;   \
207     r4 ^= r2;   \
208     r2 &= r3;   \
209     r1 |= r3;   \
210     r1 ^= r2;   \
211     r4 ^= r0;   \
212     r2 ^= r4;   \
213  }
214  #define s_s4(i, r0, r1, r2, r3, r4) { \
215     r1 ^= r3;   \
216     r3 = ~r3;   \
217     r2 ^= r3;   \
218     r3 ^= r0;   \
219     r4 = r1;    \
220     r1 &= r3;   \
221     r1 ^= r2;   \
222     r4 ^= r3;   \
223     r0 ^= r4;   \
224     r2 &= r4;   \
225     r2 ^= r0;   \
226     r0 &= r1;   \
227     r3 ^= r0;   \
228     r4 |= r1;   \
229     r4 ^= r0;   \
230     r0 |= r3;   \
231     r0 ^= r2;   \
232     r2 &= r3;   \
233     r0 = ~r0;   \
234     r4 ^= r2;   \
235  }
236  #define s_i4(i, r0, r1, r2, r3, r4) { \
237     r4 = r2;    \
238     r2 &= r3;   \
239     r2 ^= r1;   \
240     r1 |= r3;   \
241     r1 &= r0;   \
242     r4 ^= r2;   \
243     r4 ^= r1;   \
244     r1 &= r2;   \
245     r0 = ~r0;   \
246     r3 ^= r4;   \
247     r1 ^= r3;   \
248     r3 &= r0;   \
249     r3 ^= r2;   \
250     r0 ^= r1;   \
251     r2 &= r0;   \
252     r3 ^= r0;   \
253     r2 ^= r4;   \
254     r2 |= r3;   \
255     r3 ^= r0;   \
256     r2 ^= r1;   \
257  }
258  #define s_s5(i, r0, r1, r2, r3, r4) { \
259     r0 ^= r1;   \
260     r1 ^= r3;   \
261     r3 = ~r3;   \
262     r4 = r1;    \
263     r1 &= r0;   \
264     r2 ^= r3;   \
265     r1 ^= r2;   \
266     r2 |= r4;   \
267     r4 ^= r3;   \
268     r3 &= r1;   \
269     r3 ^= r0;   \
270     r4 ^= r1;   \
271     r4 ^= r2;   \
272     r2 ^= r0;   \
273     r0 &= r3;   \
274     r2 = ~r2;   \
275     r0 ^= r4;   \
276     r4 |= r3;   \
277     r2 ^= r4;   \
278  }
279  #define s_i5(i, r0, r1, r2, r3, r4) { \
280     r1 = ~r1;   \
281     r4 = r3;    \
282     r2 ^= r1;   \
283     r3 |= r0;   \
284     r3 ^= r2;   \
285     r2 |= r1;   \
286     r2 &= r0;   \
287     r4 ^= r3;   \
288     r2 ^= r4;   \
289     r4 |= r0;   \
290     r4 ^= r1;   \
291     r1 &= r2;   \
292     r1 ^= r3;   \
293     r4 ^= r2;   \
294     r3 &= r4;   \
295     r4 ^= r1;   \
296     r3 ^= r0;   \
297     r3 ^= r4;   \
298     r4 = ~r4;   \
299  }
300  #define s_s6(i, r0, r1, r2, r3, r4) { \
301     r2 = ~r2;   \
302     r4 = r3;    \
303     r3 &= r0;   \
304     r0 ^= r4;   \
305     r3 ^= r2;   \
306     r2 |= r4;   \
307     r1 ^= r3;   \
308     r2 ^= r0;   \
309     r0 |= r1;   \
310     r2 ^= r1;   \
311     r4 ^= r0;   \
312     r0 |= r3;   \
313     r0 ^= r2;   \
314     r4 ^= r3;   \
315     r4 ^= r0;   \
316     r3 = ~r3;   \
317     r2 &= r4;   \
318     r2 ^= r3;   \
319  }
320  #define s_i6(i, r0, r1, r2, r3, r4) { \
321     r0 ^= r2;   \
322     r4 = r2;    \
323     r2 &= r0;   \
324     r4 ^= r3;   \
325     r2 = ~r2;   \
326     r3 ^= r1;   \
327     r2 ^= r3;   \
328     r4 |= r0;   \
329     r0 ^= r2;   \
330     r3 ^= r4;   \
331     r4 ^= r1;   \
332     r1 &= r3;   \
333     r1 ^= r0;   \
334     r0 ^= r3;   \
335     r0 |= r2;   \
336     r3 ^= r1;   \
337     r4 ^= r0;   \
338  }
339  #define s_s7(i, r0, r1, r2, r3, r4) { \
340     r4 = r2;    \
341     r2 &= r1;   \
342     r2 ^= r3;   \
343     r3 &= r1;   \
344     r4 ^= r2;   \
345     r2 ^= r1;   \
346     r1 ^= r0;   \
347     r0 |= r4;   \
348     r0 ^= r2;   \
349     r3 ^= r1;   \
350     r2 ^= r3;   \
351     r3 &= r0;   \
352     r3 ^= r4;   \
353     r4 ^= r2;   \
354     r2 &= r0;   \
355     r4 = ~r4;   \
356     r2 ^= r4;   \
357     r4 &= r0;   \
358     r1 ^= r3;   \
359     r4 ^= r1;   \
360  }
361  #define s_i7(i, r0, r1, r2, r3, r4) { \
362     r4 = r2;    \
363     r2 ^= r0;   \
364     r0 &= r3;   \
365     r2 = ~r2;   \
366     r4 |= r3;   \
367     r3 ^= r1;   \
368     r1 |= r0;   \
369     r0 ^= r2;   \
370     r2 &= r4;   \
371     r1 ^= r2;   \
372     r2 ^= r0;   \
373     r0 |= r2;   \
374     r3 &= r4;   \
375     r0 ^= r3;   \
376     r4 ^= r1;   \
377     r3 ^= r4;   \
378     r4 |= r0;   \
379     r3 ^= r2;   \
380     r4 ^= r2;   \
381  }
382  #define s_kx(r, a, b, c, d, e) { \
383     a ^= k[4 * r + 0];   \
384     b ^= k[4 * r + 1];   \
385     c ^= k[4 * r + 2];   \
386     d ^= k[4 * r + 3];   \
387  }
388  #define s_lk(r, a, b, c, d, e) { \
389     a = k[(8-r)*4 + 0];  \
390     b = k[(8-r)*4 + 1];  \
391     c = k[(8-r)*4 + 2];  \
392     d = k[(8-r)*4 + 3];  \
393  }
394  #define s_sk(r, a, b, c, d, e) { \
395     k[(8-r)*4 + 4] = a;  \
396     k[(8-r)*4 + 5] = b;  \
397     k[(8-r)*4 + 6] = c;  \
398     k[(8-r)*4 + 7] = d;  \
399  }
400  static int s_setup_key(const unsigned char *key, int keylen, int rounds, ulong32 *k)
401  {
402     int i;
403     ulong32 t;
404     ulong32 k0[8] = { 0 }; &bsol;* zero-initialize */
405     ulong32 a, b, c, d, e;
406     for (i = 0; i < 8 && i < keylen/4; ++i) {
407        LOAD32L(k0[i], key + i * 4);
408     }
409     if (keylen < 32) {
410        k0[keylen/4] |= (ulong32)1 << ((keylen%4)*8);
411      }
412     t = k0[7];
413     for (i = 0; i < 8; ++i) {
414        k[i] = k0[i] = t = ROLc(k0[i] ^ k0[(i+3)%8] ^ k0[(i+5)%8] ^ t ^ 0x9e3779b9 ^ i, 11);
415     }
416     for (i = 8; i < 4*(rounds+1); ++i) {
417        k[i] = t = ROLc(k[i-8] ^ k[i-5] ^ k[i-3] ^ t ^ 0x9e3779b9 ^ i, 11);
418     }
419     k -= 20;
420     for (i = 0; i < rounds/8; i++) {
421        s_afterS2(s_lk);  s_afterS2(s_s3);  s_afterS3(s_sk);
422        s_afterS1(s_lk);  s_afterS1(s_s2);  s_afterS2(s_sk);
423        s_afterS0(s_lk);  s_afterS0(s_s1);  s_afterS1(s_sk);
424        s_beforeS0(s_lk); s_beforeS0(s_s0); s_afterS0(s_sk);
425        k += 8*4;
426        s_afterS6(s_lk); s_afterS6(s_s7); s_afterS7(s_sk);
427        s_afterS5(s_lk); s_afterS5(s_s6); s_afterS6(s_sk);
428        s_afterS4(s_lk); s_afterS4(s_s5); s_afterS5(s_sk);
429        s_afterS3(s_lk); s_afterS3(s_s4); s_afterS4(s_sk);
430     }
431     s_afterS2(s_lk); s_afterS2(s_s3); s_afterS3(s_sk);
432     return CRYPT_OK;
433  }
434  static int s_enc_block(const unsigned char *in, unsigned char *out, const ulong32 *k)
435  {
436     ulong32 a, b, c, d, e;
437     unsigned int i = 1;
438     LOAD32L(a, in + 0);
439     LOAD32L(b, in + 4);
440     LOAD32L(c, in + 8);
441     LOAD32L(d, in + 12);
442     do {
443        s_beforeS0(s_kx); s_beforeS0(s_s0); s_afterS0(s_lt);
444         s_afterS0(s_kx);  s_afterS0(s_s1); s_afterS1(s_lt);
445         s_afterS1(s_kx);  s_afterS1(s_s2); s_afterS2(s_lt);
446         s_afterS2(s_kx);  s_afterS2(s_s3); s_afterS3(s_lt);
447         s_afterS3(s_kx);  s_afterS3(s_s4); s_afterS4(s_lt);
448         s_afterS4(s_kx);  s_afterS4(s_s5); s_afterS5(s_lt);
449         s_afterS5(s_kx);  s_afterS5(s_s6); s_afterS6(s_lt);
450         s_afterS6(s_kx);  s_afterS6(s_s7);
451        if (i == 4) break;
452        ++i;
453        c = b;
454        b = e;
455        e = d;
456        d = a;
457        a = e;
458        k += 32;
459        s_beforeS0(s_lt);
460     } while (1);
461     s_afterS7(s_kx);
462     STORE32L(d, out + 0);
463     STORE32L(e, out + 4);
464     STORE32L(b, out + 8);
465     STORE32L(a, out + 12);
466     return CRYPT_OK;
467  }
468  static int s_dec_block(const unsigned char *in, unsigned char *out, const ulong32 *k)
469  {
470     ulong32 a, b, c, d, e;
471     unsigned int i;
472     LOAD32L(a, in + 0);
473     LOAD32L(b, in + 4);
474     LOAD32L(c, in + 8);
475     LOAD32L(d, in + 12);
476     e = 0; LTC_UNUSED_PARAM(e); &bsol;* avoid scan-build warning */
477     i = 4;
478     k += 96;
479     s_beforeI7(s_kx);
480     goto start;
481     do {
482        c = b;
483        b = d;
484        d = e;
485        k -= 32;
486        s_beforeI7(s_ilt);
487  start:
488                        s_beforeI7(s_i7); s_afterI7(s_kx);
489        s_afterI7(s_ilt); s_afterI7(s_i6); s_afterI6(s_kx);
490        s_afterI6(s_ilt); s_afterI6(s_i5); s_afterI5(s_kx);
491        s_afterI5(s_ilt); s_afterI5(s_i4); s_afterI4(s_kx);
492        s_afterI4(s_ilt); s_afterI4(s_i3); s_afterI3(s_kx);
493        s_afterI3(s_ilt); s_afterI3(s_i2); s_afterI2(s_kx);
494        s_afterI2(s_ilt); s_afterI2(s_i1); s_afterI1(s_kx);
495        s_afterI1(s_ilt); s_afterI1(s_i0); s_afterI0(s_kx);
496     } while (--i != 0);
497     STORE32L(a, out + 0);
498     STORE32L(d, out + 4);
499     STORE32L(b, out + 8);
500     STORE32L(e, out + 12);
501     return CRYPT_OK;
502  }
503  int serpent_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
504  {
505     int err;
506     LTC_ARGCHK(key  != NULL);
507     LTC_ARGCHK(skey != NULL);
508     if (num_rounds != 0 && num_rounds != 32) return CRYPT_INVALID_ROUNDS;
509     if (keylen != 16 && keylen != 24 && keylen != 32) return CRYPT_INVALID_KEYSIZE;
510     err = s_setup_key(key, keylen, 32, skey->serpent.k);
511  #ifdef LTC_CLEAN_STACK
512     burn_stack(sizeof(ulong32) * 14 + sizeof(int));
513  #endif
514     return err;
515  }
516  int serpent_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
517  {
518     int err = s_enc_block(pt, ct, skey->serpent.k);
519  #ifdef LTC_CLEAN_STACK
520     burn_stack(sizeof(ulong32) * 5 + sizeof(int));
521  #endif
522     return err;
523  }
524  int serpent_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
525  {
526     int err = s_dec_block(ct, pt, skey->serpent.k);
527  #ifdef LTC_CLEAN_STACK
528     burn_stack(sizeof(ulong32) * 5 + sizeof(int));
529  #endif
530     return err;
531  }
532  void serpent_done(symmetric_key *skey)
533  {
534     LTC_UNUSED_PARAM(skey);
535  }
536  int serpent_keysize(int *keysize)
537  {
538     LTC_ARGCHK(keysize != NULL);
539     if (*keysize >= 32) { *keysize = 32; }
540     else if (*keysize >= 24) { *keysize = 24; }
541     else if (*keysize >= 16) { *keysize = 16; }
542     else return CRYPT_INVALID_KEYSIZE;
543     return CRYPT_OK;
544  }
545  int serpent_test(void)
546  {
547  #ifndef LTC_TEST
548     return CRYPT_NOP;
549  #else
550     static const struct {
551        unsigned char key[32];
552        int keylen;
553        unsigned char pt[16], ct[16];
554     } tests[] = {
555        {
556            {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
557                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
558         32,
559             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
560             {0xA2,0x23,0xAA,0x12,0x88,0x46,0x3C,0x0E,0x2B,0xE3,0x8E,0xBD,0x82,0x56,0x16,0xC0}
561        },
562        {
563            {0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
564                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
565         32,
566             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
567             {0xEA,0xE1,0xD4,0x05,0x57,0x01,0x74,0xDF,0x7D,0xF2,0xF9,0x96,0x6D,0x50,0x91,0x59}
568        },
569        {
570            {0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
571                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
572         32,
573             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
574             {0x65,0xF3,0x76,0x84,0x47,0x1E,0x92,0x1D,0xC8,0xA3,0x0F,0x45,0xB4,0x3C,0x44,0x99}
575        },
576        {
577            {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
578                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
579         24,
580             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
581             {0x9E,0x27,0x4E,0xAD,0x9B,0x73,0x7B,0xB2,0x1E,0xFC,0xFC,0xA5,0x48,0x60,0x26,0x89}
582        },
583        {
584            {0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
585                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
586         24,
587             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
588             {0x92,0xFC,0x8E,0x51,0x03,0x99,0xE4,0x6A,0x04,0x1B,0xF3,0x65,0xE7,0xB3,0xAE,0x82}
589        },
590        {
591            {0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
592                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
593         24,
594             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
595             {0x5E,0x0D,0xA3,0x86,0xC4,0x6A,0xD4,0x93,0xDE,0xA2,0x03,0xFD,0xC6,0xF5,0x7D,0x70}
596        },
597        {
598            {0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
599         16,
600             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
601             {0x26,0x4E,0x54,0x81,0xEF,0xF4,0x2A,0x46,0x06,0xAB,0xDA,0x06,0xC0,0xBF,0xDA,0x3D}
602        },
603        {
604            {0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
605         16,
606             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
607             {0x4A,0x23,0x1B,0x3B,0xC7,0x27,0x99,0x34,0x07,0xAC,0x6E,0xC8,0x35,0x0E,0x85,0x24}
608        },
609        {
610            {0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
611         16,
612             {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
613             {0xE0,0x32,0x69,0xF9,0xE9,0xFD,0x85,0x3C,0x7D,0x81,0x56,0xDF,0x14,0xB9,0x8D,0x56}
614        }
615     };
616     unsigned char buf[2][16];
617     symmetric_key key;
618     int err, x;
619     for (x = 0; x < (int)(sizeof(tests)/sizeof(tests[0])); x++) {
620        if ((err = serpent_setup(tests[x].key, tests[x].keylen, 0, &key)) != CRYPT_OK) {
621          return err;
622        }
<span onclick='openModal()' class='match'>623        if ((err = serpent_ecb_encrypt(tests[x].pt, buf[0], &key)) != CRYPT_OK) {
624          return err;
625        }
626        if (compare_testvector(buf[0], 16, tests[x].ct, 16, "SERPENT Encrypt", x)) {
627          return CRYPT_FAIL_TESTVECTOR;
628        }
629        if ((err = serpent_ecb_decrypt(tests[x].ct, buf[1], &key)) != CRYPT_OK) {
</span>630          return err;
631        }
632        if (compare_testvector(buf[1], 16, tests[x].pt, 16, "SERPENT Decrypt", x)) {
633          return CRYPT_FAIL_TESTVECTOR;
634        }
635     }
636     return CRYPT_OK;
637  #endif
638  }
639  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libfuse-MDEwOlJlcG9zaXRvcnk0ODI5NjE3Nw==-flat-null.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-serpent.c</div>
                </div>
                <div class="column column_space"><pre><code>79  	if (!opts.mountpoint) {
80  		fprintf(stderr, "missing mountpoint parameter\n");
81  		return 1;
82  	}
83  	if (stat(opts.mountpoint, &stbuf) == -1) {
84  		fprintf(stderr ,"failed to access mountpoint %s: %s\n",
85  			opts.mountpoint, strerror(errno));
86  		free(opts.mountpoint);
87  		return 1;
88  	}
89  	free(opts.mountpoint);
90  	if (!S_ISREG(stbuf.st_mode)) {
</pre></code></div>
                <div class="column column_space"><pre><code>623        if ((err = serpent_ecb_encrypt(tests[x].pt, buf[0], &key)) != CRYPT_OK) {
624          return err;
625        }
626        if (compare_testvector(buf[0], 16, tests[x].ct, 16, "SERPENT Encrypt", x)) {
627          return CRYPT_FAIL_TESTVECTOR;
628        }
629        if ((err = serpent_ecb_decrypt(tests[x].ct, buf[1], &key)) != CRYPT_OK) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    