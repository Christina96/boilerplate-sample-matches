
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-windows.c</h3>
            <pre><code>1  #define _WIN32_WINNT 0x0601
2  #include "private/autogen/config.h"
3  #include "hwloc.h"
4  #include "hwloc/windows.h"
5  #include "private/private.h"
6  #include "private/windows.h" &bsol;* must be before windows.h */
7  #include "private/debug.h"
8  #include <windows.h>
9  #ifndef HAVE_KAFFINITY
10  typedef ULONG_PTR KAFFINITY, *PKAFFINITY;
11  #endif
12  #ifndef HAVE_PROCESSOR_CACHE_TYPE
13  typedef enum _PROCESSOR_CACHE_TYPE {
14    CacheUnified,
15    CacheInstruction,
16    CacheData,
17    CacheTrace
18  } PROCESSOR_CACHE_TYPE;
19  #endif
20  #ifndef CACHE_FULLY_ASSOCIATIVE
21  #define CACHE_FULLY_ASSOCIATIVE 0xFF
22  #endif
23  #ifndef MAXIMUM_PROC_PER_GROUP &bsol;* missing in MinGW */
24  #define MAXIMUM_PROC_PER_GROUP 64
25  #endif
26  #ifndef HAVE_CACHE_DESCRIPTOR
27  typedef struct _CACHE_DESCRIPTOR {
28    BYTE Level;
29    BYTE Associativity;
30    WORD LineSize;
31    DWORD Size; &bsol;* in bytes */
32    PROCESSOR_CACHE_TYPE Type;
33  } CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;
34  #endif
35  #ifndef HAVE_LOGICAL_PROCESSOR_RELATIONSHIP
36  typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
37    RelationProcessorCore,
38    RelationNumaNode,
39    RelationCache,
40    RelationProcessorPackage,
41    RelationGroup,
42    RelationAll = 0xffff
43  } LOGICAL_PROCESSOR_RELATIONSHIP;
44  #else &bsol;* HAVE_LOGICAL_PROCESSOR_RELATIONSHIP */
45  #  ifndef HAVE_RELATIONPROCESSORPACKAGE
46  #    define RelationProcessorPackage 3
47  #    define RelationGroup 4
48  #    define RelationAll 0xffff
49  #  endif &bsol;* HAVE_RELATIONPROCESSORPACKAGE */
50  #endif &bsol;* HAVE_LOGICAL_PROCESSOR_RELATIONSHIP */
51  #ifndef HAVE_GROUP_AFFINITY
52  typedef struct _GROUP_AFFINITY {
53    KAFFINITY Mask;
54    WORD Group;
55    WORD Reserved[3];
56  } GROUP_AFFINITY, *PGROUP_AFFINITY;
57  #endif
58  typedef struct HWLOC_PROCESSOR_RELATIONSHIP {
59    BYTE Flags;
60    BYTE EfficiencyClass; &bsol;* for RelationProcessorCore, higher means greater performance but less efficiency */
61    BYTE Reserved[20];
62    WORD GroupCount;
63    GROUP_AFFINITY GroupMask[ANYSIZE_ARRAY];
64  } HWLOC_PROCESSOR_RELATIONSHIP;
65  typedef struct HWLOC_NUMA_NODE_RELATIONSHIP {
66    DWORD NodeNumber;
67    BYTE Reserved[18];
68    WORD GroupCount;
69    _ANONYMOUS_UNION
70    union {
71      GROUP_AFFINITY GroupMask;
72      GROUP_AFFINITY GroupMasks[ANYSIZE_ARRAY];
73    } DUMMYUNIONNAME;
74  } HWLOC_NUMA_NODE_RELATIONSHIP;
75  typedef struct HWLOC_CACHE_RELATIONSHIP {
76    BYTE Level;
77    BYTE Associativity;
78    WORD LineSize;
79    DWORD CacheSize;
80    PROCESSOR_CACHE_TYPE Type;
81    BYTE Reserved[18];
82    WORD GroupCount;
83    union {
84      GROUP_AFFINITY GroupMask;
85      GROUP_AFFINITY GroupMasks[ANYSIZE_ARRAY];
86    } DUMMYUNIONNAME;
87  } HWLOC_CACHE_RELATIONSHIP;
88  #ifndef HAVE_PROCESSOR_GROUP_INFO
89  typedef struct _PROCESSOR_GROUP_INFO {
<span onclick='openModal()' class='match'>90    BYTE MaximumProcessorCount;
91    BYTE ActiveProcessorCount;
92    BYTE Reserved[38];
93    KAFFINITY ActiveProcessorMask;
94  } PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;
</span>95  #endif
96  #ifndef HAVE_GROUP_RELATIONSHIP
97  typedef struct _GROUP_RELATIONSHIP {
98    WORD MaximumGroupCount;
99    WORD ActiveGroupCount;
100    ULONGLONG Reserved[2];
101    PROCESSOR_GROUP_INFO GroupInfo[ANYSIZE_ARRAY];
102  } GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;
103  #endif
104  typedef struct HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
105    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
106    DWORD Size;
107    _ANONYMOUS_UNION
108    union {
109      HWLOC_PROCESSOR_RELATIONSHIP Processor;
110      HWLOC_NUMA_NODE_RELATIONSHIP NumaNode;
111      HWLOC_CACHE_RELATIONSHIP Cache;
112      GROUP_RELATIONSHIP Group;
113    } DUMMYUNIONNAME;
114  } HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
115  #ifndef HAVE_PSAPI_WORKING_SET_EX_BLOCK
116  typedef union _PSAPI_WORKING_SET_EX_BLOCK {
117    ULONG_PTR Flags;
118    struct {
119      unsigned Valid  :1;
120      unsigned ShareCount  :3;
121      unsigned Win32Protection  :11;
122      unsigned Shared  :1;
123      unsigned Node  :6;
124      unsigned Locked  :1;
125      unsigned LargePage  :1;
126    };
127  } PSAPI_WORKING_SET_EX_BLOCK;
128  #endif
129  #ifndef HAVE_PSAPI_WORKING_SET_EX_INFORMATION
130  typedef struct _PSAPI_WORKING_SET_EX_INFORMATION {
131    PVOID VirtualAddress;
132    PSAPI_WORKING_SET_EX_BLOCK VirtualAttributes;
133  } PSAPI_WORKING_SET_EX_INFORMATION;
134  #endif
135  #ifndef HAVE_PROCESSOR_NUMBER
136  typedef struct _PROCESSOR_NUMBER {
137    WORD Group;
138    BYTE Number;
139    BYTE Reserved;
140  } PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;
141  #endif
142  typedef WORD (WINAPI *PFN_GETACTIVEPROCESSORGROUPCOUNT)(void);
143  static PFN_GETACTIVEPROCESSORGROUPCOUNT GetActiveProcessorGroupCountProc;
144  typedef WORD (WINAPI *PFN_GETACTIVEPROCESSORCOUNT)(WORD);
145  static PFN_GETACTIVEPROCESSORCOUNT GetActiveProcessorCountProc;
146  typedef DWORD (WINAPI *PFN_GETCURRENTPROCESSORNUMBER)(void);
147  static PFN_GETCURRENTPROCESSORNUMBER GetCurrentProcessorNumberProc;
148  typedef VOID (WINAPI *PFN_GETCURRENTPROCESSORNUMBEREX)(PPROCESSOR_NUMBER);
149  static PFN_GETCURRENTPROCESSORNUMBEREX GetCurrentProcessorNumberExProc;
150  typedef BOOL (WINAPI *PFN_GETLOGICALPROCESSORINFORMATIONEX)(LOGICAL_PROCESSOR_RELATIONSHIP relationship, HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *Buffer, PDWORD ReturnLength);
151  static PFN_GETLOGICALPROCESSORINFORMATIONEX GetLogicalProcessorInformationExProc;
152  typedef BOOL (WINAPI *PFN_SETTHREADGROUPAFFINITY)(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity);
153  static PFN_SETTHREADGROUPAFFINITY SetThreadGroupAffinityProc;
154  typedef BOOL (WINAPI *PFN_GETTHREADGROUPAFFINITY)(HANDLE hThread, PGROUP_AFFINITY GroupAffinity);
155  static PFN_GETTHREADGROUPAFFINITY GetThreadGroupAffinityProc;
156  typedef BOOL (WINAPI *PFN_GETNUMAAVAILABLEMEMORYNODE)(UCHAR Node, PULONGLONG AvailableBytes);
157  static PFN_GETNUMAAVAILABLEMEMORYNODE GetNumaAvailableMemoryNodeProc;
158  typedef BOOL (WINAPI *PFN_GETNUMAAVAILABLEMEMORYNODEEX)(USHORT Node, PULONGLONG AvailableBytes);
159  static PFN_GETNUMAAVAILABLEMEMORYNODEEX GetNumaAvailableMemoryNodeExProc;
160  typedef LPVOID (WINAPI *PFN_VIRTUALALLOCEXNUMA)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred);
161  static PFN_VIRTUALALLOCEXNUMA VirtualAllocExNumaProc;
162  typedef BOOL (WINAPI *PFN_VIRTUALFREEEX)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
163  static PFN_VIRTUALFREEEX VirtualFreeExProc;
164  typedef BOOL (WINAPI *PFN_QUERYWORKINGSETEX)(HANDLE hProcess, PVOID pv, DWORD cb);
165  static PFN_QUERYWORKINGSETEX QueryWorkingSetExProc;
166  typedef NTSTATUS (WINAPI *PFN_RTLGETVERSION)(OSVERSIONINFOEX*);
167  PFN_RTLGETVERSION RtlGetVersionProc;
168  static void hwloc_win_get_function_ptrs(void)
169  {
170    HMODULE kernel32, ntdll;
171  #if HWLOC_HAVE_GCC_W_CAST_FUNCTION_TYPE
172  #pragma GCC diagnostic ignored "-Wcast-function-type"
173  #endif
174      kernel32 = LoadLibrary("kernel32.dll");
175      if (kernel32) {
176        GetActiveProcessorGroupCountProc =
177  	(PFN_GETACTIVEPROCESSORGROUPCOUNT) GetProcAddress(kernel32, "GetActiveProcessorGroupCount");
178        GetActiveProcessorCountProc =
179  	(PFN_GETACTIVEPROCESSORCOUNT) GetProcAddress(kernel32, "GetActiveProcessorCount");
180        GetCurrentProcessorNumberProc =
181  	(PFN_GETCURRENTPROCESSORNUMBER) GetProcAddress(kernel32, "GetCurrentProcessorNumber");
182        GetCurrentProcessorNumberExProc =
183  	(PFN_GETCURRENTPROCESSORNUMBEREX) GetProcAddress(kernel32, "GetCurrentProcessorNumberEx");
184        SetThreadGroupAffinityProc =
185  	(PFN_SETTHREADGROUPAFFINITY) GetProcAddress(kernel32, "SetThreadGroupAffinity");
186        GetThreadGroupAffinityProc =
187  	(PFN_GETTHREADGROUPAFFINITY) GetProcAddress(kernel32, "GetThreadGroupAffinity");
188        GetNumaAvailableMemoryNodeProc =
189  	(PFN_GETNUMAAVAILABLEMEMORYNODE) GetProcAddress(kernel32, "GetNumaAvailableMemoryNode");
190        GetNumaAvailableMemoryNodeExProc =
191  	(PFN_GETNUMAAVAILABLEMEMORYNODEEX) GetProcAddress(kernel32, "GetNumaAvailableMemoryNodeEx");
192        GetLogicalProcessorInformationExProc =
193  	(PFN_GETLOGICALPROCESSORINFORMATIONEX)GetProcAddress(kernel32, "GetLogicalProcessorInformationEx");
194        QueryWorkingSetExProc =
195  	(PFN_QUERYWORKINGSETEX) GetProcAddress(kernel32, "K32QueryWorkingSetEx");
196        VirtualAllocExNumaProc =
197  	(PFN_VIRTUALALLOCEXNUMA) GetProcAddress(kernel32, "VirtualAllocExNuma");
198        VirtualFreeExProc =
199  	(PFN_VIRTUALFREEEX) GetProcAddress(kernel32, "VirtualFreeEx");
200      }
201      if (!QueryWorkingSetExProc) {
202        HMODULE psapi = LoadLibrary("psapi.dll");
203        if (psapi)
204          QueryWorkingSetExProc = (PFN_QUERYWORKINGSETEX) GetProcAddress(psapi, "QueryWorkingSetEx");
205      }
206      ntdll = GetModuleHandle("ntdll");
207      RtlGetVersionProc = (PFN_RTLGETVERSION) GetProcAddress(ntdll, "RtlGetVersion");
208  #if HWLOC_HAVE_GCC_W_CAST_FUNCTION_TYPE
209  #pragma GCC diagnostic warning "-Wcast-function-type"
210  #endif
211  }
212  static void hwloc_bitmap_from_ULONG_PTR(hwloc_bitmap_t set, ULONG_PTR mask)
213  {
214  #if SIZEOF_VOID_P == 8
215    hwloc_bitmap_from_ulong(set, mask & 0xffffffff);
216    hwloc_bitmap_set_ith_ulong(set, 1, mask >> 32);
217  #else
218    hwloc_bitmap_from_ulong(set, mask);
219  #endif
220  }
221  static void hwloc_bitmap_from_ith_ULONG_PTR(hwloc_bitmap_t set, unsigned i, ULONG_PTR mask)
222  {
223  #if SIZEOF_VOID_P == 8
224    hwloc_bitmap_from_ith_ulong(set, 2*i, mask & 0xffffffff);
225    hwloc_bitmap_set_ith_ulong(set, 2*i+1, mask >> 32);
226  #else
227    hwloc_bitmap_from_ith_ulong(set, i, mask);
228  #endif
229  }
230  static void hwloc_bitmap_set_ith_ULONG_PTR(hwloc_bitmap_t set, unsigned i, ULONG_PTR mask)
231  {
232  #if SIZEOF_VOID_P == 8
233    hwloc_bitmap_set_ith_ulong(set, 2*i, mask & 0xffffffff);
234    hwloc_bitmap_set_ith_ulong(set, 2*i+1, mask >> 32);
235  #else
236    hwloc_bitmap_set_ith_ulong(set, i, mask);
237  #endif
238  }
239  static ULONG_PTR hwloc_bitmap_to_ULONG_PTR(hwloc_const_bitmap_t set)
240  {
241  #if SIZEOF_VOID_P == 8
242    ULONG_PTR up = hwloc_bitmap_to_ith_ulong(set, 1);
243    up <<= 32;
244    up |= hwloc_bitmap_to_ulong(set);
245    return up;
246  #else
247    return hwloc_bitmap_to_ulong(set);
248  #endif
249  }
250  static ULONG_PTR hwloc_bitmap_to_ith_ULONG_PTR(hwloc_const_bitmap_t set, unsigned i)
251  {
252  #if SIZEOF_VOID_P == 8
253    ULONG_PTR up = hwloc_bitmap_to_ith_ulong(set, 2*i+1);
254    up <<= 32;
255    up |= hwloc_bitmap_to_ith_ulong(set, 2*i);
256    return up;
257  #else
258    return hwloc_bitmap_to_ith_ulong(set, i);
259  #endif
260  }
261  static int hwloc_bitmap_to_single_ULONG_PTR(hwloc_const_bitmap_t set, unsigned *index, ULONG_PTR *mask)
262  {
263    unsigned first_ulp, last_ulp;
264    if (hwloc_bitmap_weight(set) == -1)
265      return -1;
266    first_ulp = hwloc_bitmap_first(set) / (sizeof(ULONG_PTR)*8);
267    last_ulp = hwloc_bitmap_last(set) / (sizeof(ULONG_PTR)*8);
268    if (first_ulp != last_ulp)
269      return -1;
270    *mask = hwloc_bitmap_to_ith_ULONG_PTR(set, first_ulp);
271    *index = first_ulp;
272    return 0;
273  }
274  static unsigned long max_numanode_index = 0;
275  static unsigned long nr_processor_groups = 1;
276  static hwloc_cpuset_t * processor_group_cpusets = NULL;
277  static void
278  hwloc_win_get_processor_groups(void)
279  {
280    HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *procInfoTotal, *tmpprocInfoTotal, *procInfo;
281    DWORD length;
282    unsigned i;
283    hwloc_debug("querying windows processor groups\n");
284    if (!GetLogicalProcessorInformationExProc)
285      goto error;
286    nr_processor_groups = GetActiveProcessorGroupCountProc();
287    if (!nr_processor_groups)
288      goto error;
289    hwloc_debug("found %lu windows processor groups\n", nr_processor_groups);
290    if (nr_processor_groups > 1 && SIZEOF_VOID_P == 4) {
291      if (HWLOC_SHOW_ALL_ERRORS())
292        fprintf(stderr, "hwloc: multiple processor groups found on 32bits Windows, topology may be invalid/incomplete.\n");
293    }
294    length = 0;
295    procInfoTotal = NULL;
296    while (1) {
297      if (GetLogicalProcessorInformationExProc(RelationGroup, procInfoTotal, &length))
298        break;
299      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
300        goto error;
301      tmpprocInfoTotal = realloc(procInfoTotal, length);
302      if (!tmpprocInfoTotal)
303        goto error_with_procinfo;
304      procInfoTotal = tmpprocInfoTotal;
305    }
306    processor_group_cpusets = calloc(nr_processor_groups, sizeof(*processor_group_cpusets));
307    if (!processor_group_cpusets)
308      goto error_with_procinfo;
309    for (procInfo = procInfoTotal;
310         (void*) procInfo < (void*) ((uintptr_t) procInfoTotal + length);
311         procInfo = (void*) ((uintptr_t) procInfo + procInfo->Size)) {
312      unsigned id;
313      assert(procInfo->Relationship == RelationGroup);
314      hwloc_debug("Found %u active windows processor groups\n",
315                  (unsigned) procInfo->Group.ActiveGroupCount);
316      for (id = 0; id < procInfo->Group.ActiveGroupCount; id++) {
317        KAFFINITY mask;
318        hwloc_bitmap_t set;
319        set = hwloc_bitmap_alloc();
320        if (!set)
321          goto error_with_cpusets;
322        mask = procInfo->Group.GroupInfo[id].ActiveProcessorMask;
323        hwloc_debug("group %u with %u cpus mask 0x%llx\n", id,
324                    (unsigned) procInfo->Group.GroupInfo[id].ActiveProcessorCount, (unsigned long long) mask);
325        hwloc_bitmap_set_ith_ULONG_PTR(set, id, mask);
326        hwloc_debug_2args_bitmap("group %u %d bitmap %s\n", id, procInfo->Group.GroupInfo[id].ActiveProcessorCount, set);
327        processor_group_cpusets[id] = set;
328      }
329    }
330    free(procInfoTotal);
331    return;
332   error_with_cpusets:
333    for(i=0; i<nr_processor_groups; i++) {
334      if (processor_group_cpusets[i])
335        hwloc_bitmap_free(processor_group_cpusets[i]);
336    }
337    free(processor_group_cpusets);
338    processor_group_cpusets = NULL;
339   error_with_procinfo:
340    free(procInfoTotal);
341   error:
342    nr_processor_groups = 1;
343  }
344  static void
345  hwloc_win_free_processor_groups(void)
346  {
347    unsigned i;
348    for(i=0; i<nr_processor_groups; i++) {
349      if (processor_group_cpusets[i])
350        hwloc_bitmap_free(processor_group_cpusets[i]);
351    }
352    free(processor_group_cpusets);
353    processor_group_cpusets = NULL;
354    nr_processor_groups = 1;
355  }
356  int
357  hwloc_windows_get_nr_processor_groups(hwloc_topology_t topology, unsigned long flags)
358  {
359    if (!topology->is_loaded || !topology->is_thissystem) {
360      errno = EINVAL;
361      return -1;
362    }
363    if (flags) {
364      errno = EINVAL;
365      return -1;
366    }
367    return nr_processor_groups;
368  }
369  int
370  hwloc_windows_get_processor_group_cpuset(hwloc_topology_t topology, unsigned pg_index, hwloc_cpuset_t cpuset, unsigned long flags)
371  {
372    if (!topology->is_loaded || !topology->is_thissystem) {
373      errno = EINVAL;
374      return -1;
375    }
376    if (!cpuset) {
377      errno = EINVAL;
378      return -1;
379    }
380    if (flags) {
381      errno = EINVAL;
382      return -1;
383    }
384    if (pg_index >= nr_processor_groups) {
385      errno = ENOENT;
386      return -1;
387    }
388    if (!processor_group_cpusets) {
389      assert(nr_processor_groups == 1);
390      hwloc_bitmap_copy(cpuset, topology->levels[0][0]->cpuset);
391      return 0;
392    }
393    if (!processor_group_cpusets[pg_index]) {
394      errno = ENOENT;
395      return -1;
396    }
397    hwloc_bitmap_copy(cpuset, processor_group_cpusets[pg_index]);
398    return 0;
399  }
400  static int
401  hwloc_win_get_thisthread_last_cpu_location(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
402  {
403    assert(GetCurrentProcessorNumberExProc || (GetCurrentProcessorNumberProc && nr_processor_groups == 1));
404    if (nr_processor_groups > 1 || !GetCurrentProcessorNumberProc) {
405      PROCESSOR_NUMBER num;
406      GetCurrentProcessorNumberExProc(&num);
407      hwloc_bitmap_from_ith_ULONG_PTR(set, num.Group, ((ULONG_PTR)1) << num.Number);
408      return 0;
409    }
410    hwloc_bitmap_from_ith_ULONG_PTR(set, 0, ((ULONG_PTR)1) << GetCurrentProcessorNumberProc());
411    return 0;
412  }
413  static int
414  hwloc_win_set_thread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_thread_t thread, hwloc_const_bitmap_t hwloc_set, int flags)
415  {
416    DWORD_PTR mask;
417    unsigned group;
418    if (flags & HWLOC_CPUBIND_NOMEMBIND) {
419      errno = ENOSYS;
420      return -1;
421    }
422    if (hwloc_bitmap_to_single_ULONG_PTR(hwloc_set, &group, &mask) < 0) {
423      errno = ENOSYS;
424      return -1;
425    }
426    assert(nr_processor_groups == 1 || SetThreadGroupAffinityProc);
427    if (nr_processor_groups > 1) {
428      GROUP_AFFINITY aff;
429      memset(&aff, 0, sizeof(aff)); &bsol;* we get Invalid Parameter error if Reserved field isn't cleared */
430      aff.Group = group;
431      aff.Mask = mask;
432      if (!SetThreadGroupAffinityProc(thread, &aff, NULL))
433        return -1;
434    } else {
435      if (!SetThreadAffinityMask(thread, mask))
436        return -1;
437    }
438    return 0;
439  }
440  static int
441  hwloc_win_set_thisthread_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t hwloc_set, int flags)
442  {
443    return hwloc_win_set_thread_cpubind(topology, GetCurrentThread(), hwloc_set, flags);
444  }
445  static int
446  hwloc_win_set_thisthread_membind(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
447  {
448    int ret;
449    hwloc_const_cpuset_t cpuset;
450    hwloc_cpuset_t _cpuset = NULL;
451    if ((policy != HWLOC_MEMBIND_DEFAULT && policy != HWLOC_MEMBIND_BIND)
452        || flags & HWLOC_MEMBIND_NOCPUBIND) {
453      errno = ENOSYS;
454      return -1;
455    }
456    if (policy == HWLOC_MEMBIND_DEFAULT) {
457      cpuset = hwloc_topology_get_complete_cpuset(topology);
458    } else {
459      cpuset = _cpuset = hwloc_bitmap_alloc();
460      hwloc_cpuset_from_nodeset(topology, _cpuset, nodeset);
461    }
462    ret = hwloc_win_set_thisthread_cpubind(topology, cpuset,
463  					 (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
464    hwloc_bitmap_free(_cpuset);
465    return ret;
466  }
467  static int
468  hwloc_win_get_thread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_thread_t thread, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
469  {
470    GROUP_AFFINITY aff;
471    assert(GetThreadGroupAffinityProc);
472    if (!GetThreadGroupAffinityProc(thread, &aff))
473      return -1;
474    hwloc_bitmap_from_ith_ULONG_PTR(set, aff.Group, aff.Mask);
475    return 0;
476  }
477  static int
478  hwloc_win_get_thisthread_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_cpuset_t set, int flags __hwloc_attribute_unused)
479  {
480    return hwloc_win_get_thread_cpubind(topology, GetCurrentThread(), set, flags);
481  }
482  static int
483  hwloc_win_get_thisthread_membind(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
484  {
485    int ret;
486    hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();
487    ret = hwloc_win_get_thread_cpubind(topology, GetCurrentThread(), cpuset, flags);
488    if (!ret) {
489      *policy = HWLOC_MEMBIND_BIND;
490      hwloc_cpuset_to_nodeset(topology, cpuset, nodeset);
491    }
492    hwloc_bitmap_free(cpuset);
493    return ret;
494  }
495  static int
496  hwloc_win_set_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t proc, hwloc_const_bitmap_t hwloc_set, int flags)
497  {
498    DWORD_PTR mask;
499    assert(nr_processor_groups == 1);
500    if (flags & HWLOC_CPUBIND_NOMEMBIND) {
501      errno = ENOSYS;
502      return -1;
503    }
504    mask = hwloc_bitmap_to_ULONG_PTR(hwloc_set);
505    if (!SetProcessAffinityMask(proc, mask))
506      return -1;
507    return 0;
508  }
509  static int
510  hwloc_win_set_thisproc_cpubind(hwloc_topology_t topology, hwloc_const_bitmap_t hwloc_set, int flags)
511  {
512    return hwloc_win_set_proc_cpubind(topology, GetCurrentProcess(), hwloc_set, flags);
513  }
514  static int
515  hwloc_win_set_proc_membind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
516  {
517    int ret;
518    hwloc_const_cpuset_t cpuset;
519    hwloc_cpuset_t _cpuset = NULL;
520    if ((policy != HWLOC_MEMBIND_DEFAULT && policy != HWLOC_MEMBIND_BIND)
521        || flags & HWLOC_MEMBIND_NOCPUBIND) {
522      errno = ENOSYS;
523      return -1;
524    }
525    if (policy == HWLOC_MEMBIND_DEFAULT) {
526      cpuset = hwloc_topology_get_complete_cpuset(topology);
527    } else {
528      cpuset = _cpuset = hwloc_bitmap_alloc();
529      hwloc_cpuset_from_nodeset(topology, _cpuset, nodeset);
530    }
531    ret = hwloc_win_set_proc_cpubind(topology, pid, cpuset,
532  				   (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
533    hwloc_bitmap_free(_cpuset);
534    return ret;
535  }
536  static int
537  hwloc_win_set_thisproc_membind(hwloc_topology_t topology, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags)
538  {
539    return hwloc_win_set_proc_membind(topology, GetCurrentProcess(), nodeset, policy, flags);
540  }
541  static int
542  hwloc_win_get_proc_cpubind(hwloc_topology_t topology __hwloc_attribute_unused, hwloc_pid_t proc, hwloc_bitmap_t hwloc_set, int flags)
543  {
544    DWORD_PTR proc_mask, sys_mask;
545    assert(nr_processor_groups == 1);
546    if (flags & HWLOC_CPUBIND_NOMEMBIND) {
547      errno = ENOSYS;
548      return -1;
549    }
550    if (!GetProcessAffinityMask(proc, &proc_mask, &sys_mask))
551      return -1;
552    hwloc_bitmap_from_ULONG_PTR(hwloc_set, proc_mask);
553    return 0;
554  }
555  static int
556  hwloc_win_get_proc_membind(hwloc_topology_t topology, hwloc_pid_t pid, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
557  {
558    int ret;
559    hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();
560    ret = hwloc_win_get_proc_cpubind(topology, pid, cpuset,
561  				   (flags & HWLOC_MEMBIND_STRICT) ? HWLOC_CPUBIND_STRICT : 0);
562    if (!ret) {
563      *policy = HWLOC_MEMBIND_BIND;
564      hwloc_cpuset_to_nodeset(topology, cpuset, nodeset);
565    }
566    hwloc_bitmap_free(cpuset);
567    return ret;
568  }
569  static int
570  hwloc_win_get_thisproc_cpubind(hwloc_topology_t topology, hwloc_bitmap_t hwloc_cpuset, int flags)
571  {
572    return hwloc_win_get_proc_cpubind(topology, GetCurrentProcess(), hwloc_cpuset, flags);
573  }
574  static int
575  hwloc_win_get_thisproc_membind(hwloc_topology_t topology, hwloc_nodeset_t nodeset, hwloc_membind_policy_t * policy, int flags)
576  {
577    return hwloc_win_get_proc_membind(topology, GetCurrentProcess(), nodeset, policy, flags);
578  }
579  static void *
580  hwloc_win_alloc(hwloc_topology_t topology __hwloc_attribute_unused, size_t len) {
581    return VirtualAlloc(NULL, len, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);
582  }
583  static void *
584  hwloc_win_alloc_membind(hwloc_topology_t topology __hwloc_attribute_unused, size_t len, hwloc_const_nodeset_t nodeset, hwloc_membind_policy_t policy, int flags) {
585    int node;
586    switch (policy) {
587      case HWLOC_MEMBIND_DEFAULT:
588      case HWLOC_MEMBIND_BIND:
589        break;
590      default:
591        errno = ENOSYS;
592        return hwloc_alloc_or_fail(topology, len, flags);
593    }
594    if (flags & HWLOC_MEMBIND_STRICT) {
595      errno = ENOSYS;
596      return NULL;
597    }
598    if (policy == HWLOC_MEMBIND_DEFAULT
599        || hwloc_bitmap_isequal(nodeset, hwloc_topology_get_complete_nodeset(topology)))
600      return hwloc_win_alloc(topology, len);
601    if (hwloc_bitmap_weight(nodeset) != 1) {
602      errno = EXDEV;
603      return hwloc_alloc_or_fail(topology, len, flags);
604    }
605    node = hwloc_bitmap_first(nodeset);
606    return VirtualAllocExNumaProc(GetCurrentProcess(), NULL, len, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE, node);
607  }
608  static int
609  hwloc_win_free_membind(hwloc_topology_t topology __hwloc_attribute_unused, void *addr, size_t len __hwloc_attribute_unused) {
610    if (!addr)
611      return 0;
612    if (!VirtualFreeExProc(GetCurrentProcess(), addr, 0, MEM_RELEASE))
613      return -1;
614    return 0;
615  }
616  static int
617  hwloc_win_get_area_memlocation(hwloc_topology_t topology __hwloc_attribute_unused, const void *addr, size_t len, hwloc_nodeset_t nodeset, int flags __hwloc_attribute_unused)
618  {
619    SYSTEM_INFO SystemInfo;
620    DWORD page_size;
621    uintptr_t start;
622    unsigned nb;
623    PSAPI_WORKING_SET_EX_INFORMATION *pv;
624    unsigned i;
625    GetSystemInfo(&SystemInfo);
626    page_size = SystemInfo.dwPageSize;
627    start = (((uintptr_t) addr) / page_size) * page_size;
628    nb = (unsigned)((((uintptr_t) addr + len - start) + page_size - 1) / page_size);
629    if (!nb)
630      nb = 1;
631    pv = calloc(nb, sizeof(*pv));
632    if (!pv)
633      return -1;
634    for (i = 0; i < nb; i++)
635      pv[i].VirtualAddress = (void*) (start + i * page_size);
636    if (!QueryWorkingSetExProc(GetCurrentProcess(), pv, nb * sizeof(*pv))) {
637      free(pv);
638      return -1;
639    }
640    for (i = 0; i < nb; i++) {
641      if (pv[i].VirtualAttributes.Valid)
642        hwloc_bitmap_set(nodeset, pv[i].VirtualAttributes.Node);
643    }
644    free(pv);
645    return 0;
646  }
647  struct hwloc_win_efficiency_classes {
648    unsigned nr_classes;
649    unsigned nr_classes_allocated;
650    struct hwloc_win_efficiency_class {
651      unsigned value;
652      hwloc_bitmap_t cpuset;
653    } *classes;
654  };
655  static void
656  hwloc_win_efficiency_classes_init(struct hwloc_win_efficiency_classes *classes)
657  {
658    classes->classes = NULL;
659    classes->nr_classes_allocated = 0;
660    classes->nr_classes = 0;
661  }
662  static int
663  hwloc_win_efficiency_classes_add(struct hwloc_win_efficiency_classes *classes,
664                                   hwloc_const_bitmap_t cpuset,
665                                   unsigned value)
666  {
667    unsigned i;
668    for(i=0; i<classes->nr_classes; i++) {
669      if (classes->classes[i].value == value) {
670        hwloc_bitmap_or(classes->classes[i].cpuset, classes->classes[i].cpuset, cpuset);
671        return 0;
672      }
673    }
674    if (classes->nr_classes == classes->nr_classes_allocated) {
675      struct hwloc_win_efficiency_class *tmp;
676      unsigned new_nr_allocated = 2*classes->nr_classes_allocated;
677      if (!new_nr_allocated) {
678  #define HWLOC_WIN_EFFICIENCY_CLASSES_DEFAULT_MAX 4 &bsol;* 2 should be enough is most cases */
679        new_nr_allocated = HWLOC_WIN_EFFICIENCY_CLASSES_DEFAULT_MAX;
680      }
681      tmp = realloc(classes->classes, new_nr_allocated * sizeof(*classes->classes));
682      if (!tmp)
683        return -1;
684      classes->classes = tmp;
685      classes->nr_classes_allocated = new_nr_allocated;
686    }
687    classes->classes[classes->nr_classes].cpuset = hwloc_bitmap_alloc();
688    if (!classes->classes[classes->nr_classes].cpuset)
689      return -1;
690    classes->classes[classes->nr_classes].value = value;
691    hwloc_bitmap_copy(classes->classes[classes->nr_classes].cpuset, cpuset);
692    classes->nr_classes++;
693    return 0;
694  }
695  static void
696  hwloc_win_efficiency_classes_register(hwloc_topology_t topology,
697                                        struct hwloc_win_efficiency_classes *classes)
698  {
699    unsigned i;
700    for(i=0; i<classes->nr_classes; i++) {
701      hwloc_internal_cpukinds_register(topology, classes->classes[i].cpuset, classes->classes[i].value, NULL, 0, 0);
702      classes->classes[i].cpuset = NULL; &bsol;* given to cpukinds */
703    }
704  }
705  static void
706  hwloc_win_efficiency_classes_destroy(struct hwloc_win_efficiency_classes *classes)
707  {
708    unsigned i;
709    for(i=0; i<classes->nr_classes; i++)
710      hwloc_bitmap_free(classes->classes[i].cpuset);
711    free(classes->classes);
712  }
713  static int
714  hwloc_look_windows(struct hwloc_backend *backend, struct hwloc_disc_status *dstatus)
715  {
716    struct hwloc_topology *topology = backend->topology;
717    hwloc_bitmap_t groups_pu_set = NULL;
718    SYSTEM_INFO SystemInfo;
719    DWORD length;
720    int gotnuma = 0;
721    int gotnumamemory = 0;
722    OSVERSIONINFOEX osvi;
723    char versionstr[20];
724    char hostname[122] = "";
725    unsigned hostname_size = sizeof(hostname);
726    int has_efficiencyclass = 0;
727    struct hwloc_win_efficiency_classes eclasses;
728    char *env = getenv("HWLOC_WINDOWS_PROCESSOR_GROUP_OBJS");
729    int keep_pgroup_objs = (env && atoi(env));
730    assert(dstatus->phase == HWLOC_DISC_PHASE_CPU);
731    if (topology->levels[0][0]->cpuset)
732      return -1;
733    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
734    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
735    if (RtlGetVersionProc) {
736      RtlGetVersionProc(&osvi);
737    } else {
738      GetVersionEx((LPOSVERSIONINFO)&osvi);
739    }
740    if (osvi.dwMajorVersion >= 10) {
741      has_efficiencyclass = 1;
742      hwloc_win_efficiency_classes_init(&eclasses);
743    }
744    hwloc_alloc_root_sets(topology->levels[0][0]);
745    GetSystemInfo(&SystemInfo);
746    if (GetLogicalProcessorInformationExProc) {
747        HWLOC_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX *procInfoTotal, *tmpprocInfoTotal, *procInfo;
748        unsigned id;
749        struct hwloc_obj *obj;
750        hwloc_obj_type_t type;
751        length = 0;
752        procInfoTotal = NULL;
753        while (1) {
754  	if (GetLogicalProcessorInformationExProc(RelationAll, procInfoTotal, &length))
755  	  break;
756  	if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
757  	  return -1;
758          tmpprocInfoTotal = realloc(procInfoTotal, length);
759  	if (!tmpprocInfoTotal) {
760  	  free(procInfoTotal);
761  	  goto out;
762  	}
763  	procInfoTotal = tmpprocInfoTotal;
764        }
765        for (procInfo = procInfoTotal;
766  	   (void*) procInfo < (void*) ((uintptr_t) procInfoTotal + length);
767  	   procInfo = (void*) ((uintptr_t) procInfo + procInfo->Size)) {
768          unsigned num, i;
769          unsigned efficiency_class = 0;
770          GROUP_AFFINITY *GroupMask;
771  	if (procInfo->Relationship == RelationCache
772  		&& procInfo->Cache.Type != CacheUnified
773  		&& procInfo->Cache.Type != CacheData
774  		&& procInfo->Cache.Type != CacheInstruction)
775  	  continue;
776  	id = HWLOC_UNKNOWN_INDEX;
777  	switch (procInfo->Relationship) {
778  	  case RelationNumaNode:
779  	    type = HWLOC_OBJ_NUMANODE;
780              if (procInfo->NumaNode.GroupCount) {
781                num = procInfo->NumaNode.GroupCount;
782                GroupMask = procInfo->NumaNode.GroupMasks;
783              } else {
784                num = 1;
785                GroupMask = &procInfo->NumaNode.GroupMask;
786              }
787  	    id = procInfo->NumaNode.NodeNumber;
788  	    gotnuma++;
789  	    if (id > max_numanode_index)
790  	      max_numanode_index = id;
791  	    break;
792  	  case RelationProcessorPackage:
793  	    type = HWLOC_OBJ_PACKAGE;
794              num = procInfo->Processor.GroupCount;
795              GroupMask = procInfo->Processor.GroupMask;
796  	    break;
797  	  case RelationCache:
798  	    type = (procInfo->Cache.Type == CacheInstruction ? HWLOC_OBJ_L1ICACHE : HWLOC_OBJ_L1CACHE) + procInfo->Cache.Level - 1;
799              if (procInfo->Cache.GroupCount) {
800                num = procInfo->Cache.GroupCount;
801                GroupMask = procInfo->Cache.GroupMasks;
802              } else {
803                num = 1;
804                GroupMask = &procInfo->Cache.GroupMask;
805              }
806  	    break;
807  	  case RelationProcessorCore:
808  	    type = HWLOC_OBJ_CORE;
809              num = procInfo->Processor.GroupCount;
810              GroupMask = procInfo->Processor.GroupMask;
811              efficiency_class = procInfo->Processor.EfficiencyClass;
812  	    break;
813  	  case RelationGroup:
814  	    for (id = 0; id < procInfo->Group.ActiveGroupCount; id++) {
815                KAFFINITY mask;
816  	      hwloc_bitmap_t set;
817  	      set = hwloc_bitmap_alloc();
818  	      mask = procInfo->Group.GroupInfo[id].ActiveProcessorMask;
819  	      hwloc_debug("group %u %d cpus mask %lx\n", id,
820  			  procInfo->Group.GroupInfo[id].ActiveProcessorCount, mask);
821  	      hwloc_bitmap_set_ith_ULONG_PTR(set, id, mask);
822  	      hwloc_debug_2args_bitmap("group %u %d bitmap %s\n", id, procInfo->Group.GroupInfo[id].ActiveProcessorCount, set);
823  	      if (!groups_pu_set)
824  		groups_pu_set = hwloc_bitmap_alloc();
825  	      hwloc_bitmap_or(groups_pu_set, groups_pu_set, set);
826                if (keep_pgroup_objs && hwloc_filter_check_keep_object_type(topology, HWLOC_OBJ_GROUP)) {
827  		obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_GROUP, id);
828  		obj->cpuset = set;
829  		obj->attr->group.kind = HWLOC_GROUP_KIND_WINDOWS_PROCESSOR_GROUP;
830  		hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:GetLogicalProcessorInformationEx:ProcessorGroup");
831  	      } else
832  		hwloc_bitmap_free(set);
833  	    }
834  	    continue;
835  	  default:
836              hwloc_debug("unknown relation %d\n", procInfo->Relationship);
837  	    continue;
838  	}
839  	if (!hwloc_filter_check_keep_object_type(topology, type))
840  	  continue;
841  	obj = hwloc_alloc_setup_object(topology, type, id);
842          obj->cpuset = hwloc_bitmap_alloc();
843          for (i = 0; i < num; i++) {
844            hwloc_debug("%s#%u %d: mask %d:%lx\n", hwloc_obj_type_string(type), id, i, GroupMask[i].Group, GroupMask[i].Mask);
845  	  hwloc_bitmap_set_ith_ULONG_PTR(obj->cpuset, GroupMask[i].Group, GroupMask[i].Mask);
846          }
847  	hwloc_debug_2args_bitmap("%s#%u bitmap %s\n", hwloc_obj_type_string(type), id, obj->cpuset);
848  	switch (type) {
849          case HWLOC_OBJ_CORE: {
850            if (has_efficiencyclass)
851              hwloc_win_efficiency_classes_add(&eclasses, obj->cpuset, efficiency_class);
852            break;
853          }
854  	  case HWLOC_OBJ_NUMANODE:
855  	    {
856  	      ULONGLONG avail;
857  	      obj->nodeset = hwloc_bitmap_alloc();
858  	      hwloc_bitmap_set(obj->nodeset, id);
859  	      if ((GetNumaAvailableMemoryNodeExProc && GetNumaAvailableMemoryNodeExProc(id, &avail))
860  		  || (GetNumaAvailableMemoryNodeProc && GetNumaAvailableMemoryNodeProc(id, &avail))) {
861  	        obj->attr->numanode.local_memory = avail;
862  		gotnumamemory++;
863  	      }
864  	      obj->attr->numanode.page_types = malloc(2 * sizeof(*obj->attr->numanode.page_types));
865  	      memset(obj->attr->numanode.page_types, 0, 2 * sizeof(*obj->attr->numanode.page_types));
866  	      obj->attr->numanode.page_types_len = 1;
867  	      obj->attr->numanode.page_types[0].size = SystemInfo.dwPageSize;
868  #if HAVE_DECL__SC_LARGE_PAGESIZE
869  	      obj->attr->numanode.page_types_len++;
870  	      obj->attr->numanode.page_types[1].size = sysconf(_SC_LARGE_PAGESIZE);
871  #endif
872  	      break;
873  	    }
874  	  case HWLOC_OBJ_L1CACHE:
875  	  case HWLOC_OBJ_L2CACHE:
876  	  case HWLOC_OBJ_L3CACHE:
877  	  case HWLOC_OBJ_L4CACHE:
878  	  case HWLOC_OBJ_L5CACHE:
879  	  case HWLOC_OBJ_L1ICACHE:
880  	  case HWLOC_OBJ_L2ICACHE:
881  	  case HWLOC_OBJ_L3ICACHE:
882  	    obj->attr->cache.size = procInfo->Cache.CacheSize;
883  	    obj->attr->cache.associativity = procInfo->Cache.Associativity == CACHE_FULLY_ASSOCIATIVE ? -1 : procInfo->Cache.Associativity ;
884  	    obj->attr->cache.linesize = procInfo->Cache.LineSize;
885  	    obj->attr->cache.depth = procInfo->Cache.Level;
886  	    switch (procInfo->Cache.Type) {
887  	      case CacheUnified:
888  		obj->attr->cache.type = HWLOC_OBJ_CACHE_UNIFIED;
889  		break;
890  	      case CacheData:
891  		obj->attr->cache.type = HWLOC_OBJ_CACHE_DATA;
892  		break;
893  	      case CacheInstruction:
894  		obj->attr->cache.type = HWLOC_OBJ_CACHE_INSTRUCTION;
895  		break;
896  	      default:
897  		hwloc_free_unlinked_object(obj);
898  		continue;
899  	    }
900  	    break;
901  	  default:
902  	    break;
903  	}
904  	hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:GetLogicalProcessorInformationEx");
905        }
906        free(procInfoTotal);
907    }
908    topology->support.discovery->pu = 1;
909    topology->support.discovery->numa = gotnuma;
910    topology->support.discovery->numa_memory = gotnumamemory;
911    if (groups_pu_set) {
912      hwloc_obj_t obj;
913      unsigned idx;
914      hwloc_bitmap_foreach_begin(idx, groups_pu_set) {
915        obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PU, idx);
916        obj->cpuset = hwloc_bitmap_alloc();
917        hwloc_bitmap_only(obj->cpuset, idx);
918        hwloc_debug_1arg_bitmap("cpu %u has cpuset %s\n",
919  			      idx, obj->cpuset);
920        hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:ProcessorGroup:pu");
921      } hwloc_bitmap_foreach_end();
922      hwloc_bitmap_free(groups_pu_set);
923    } else {
924      hwloc_obj_t obj;
925      unsigned idx;
926      for(idx=0; idx<32; idx++)
927        if (SystemInfo.dwActiveProcessorMask & (((DWORD_PTR)1)<<idx)) {
928  	obj = hwloc_alloc_setup_object(topology, HWLOC_OBJ_PU, idx);
929  	obj->cpuset = hwloc_bitmap_alloc();
930  	hwloc_bitmap_only(obj->cpuset, idx);
931  	hwloc_debug_1arg_bitmap("cpu %u has cpuset %s\n",
932  				idx, obj->cpuset);
933  	hwloc__insert_object_by_cpuset(topology, NULL, obj, "windows:pu");
934        }
935    }
936    if (has_efficiencyclass) {
937      topology->support.discovery->cpukind_efficiency = 1;
938      hwloc_win_efficiency_classes_register(topology, &eclasses);
939    }
940   out:
941    if (has_efficiencyclass)
942      hwloc_win_efficiency_classes_destroy(&eclasses);
943    hwloc_obj_add_info(topology->levels[0][0], "Backend", "Windows");
944    hwloc_obj_add_info(topology->levels[0][0], "OSName", "Windows");
945  #if defined(__CYGWIN__)
946    hwloc_obj_add_info(topology->levels[0][0], "WindowsBuildEnvironment", "Cygwin");
947  #elif defined(__MINGW32__)
948    hwloc_obj_add_info(topology->levels[0][0], "WindowsBuildEnvironment", "MinGW");
949  #endif
950    if (osvi.dwMajorVersion == 10) {
951      if (osvi.dwMinorVersion == 0)
952        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "10");
953    } else if (osvi.dwMajorVersion == 6) {
954      if (osvi.dwMinorVersion == 3)
955        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "8.1"); &bsol;* or "Server 2012 R2" */
956      else if (osvi.dwMinorVersion == 2)
957        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "8"); &bsol;* or "Server 2012" */
958      else if (osvi.dwMinorVersion == 1)
959        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "7"); &bsol;* or "Server 2008 R2" */
960      else if (osvi.dwMinorVersion == 0)
961        hwloc_obj_add_info(topology->levels[0][0], "OSRelease", "Vista"); &bsol;* or "Server 2008" */
962    } &bsol;* earlier versions are ignored */
963    snprintf(versionstr, sizeof(versionstr), "%u.%u.%u", osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);
964    hwloc_obj_add_info(topology->levels[0][0], "OSVersion", versionstr);
965  #if !defined(__CYGWIN__)
966    GetComputerName(hostname, &hostname_size);
967  #else
968    gethostname(hostname, hostname_size);
969  #endif
970    if (*hostname)
971      hwloc_obj_add_info(topology->levels[0][0], "Hostname", hostname);
972    switch (SystemInfo.wProcessorArchitecture) {
973    case 0:
974      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "i686");
975      break;
976    case 9:
977      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "x86_64");
978      break;
979    case 5:
980      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "arm");
981      break;
982    case 12:
983      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "arm64");
984      break;
985    case 6:
986      hwloc_obj_add_info(topology->levels[0][0], "Architecture", "ia64");
987      break;
988    }
989    return 0;
990  }
991  void
992  hwloc_set_windows_hooks(struct hwloc_binding_hooks *hooks,
993  			struct hwloc_topology_support *support)
994  {
995    if (GetCurrentProcessorNumberExProc || (GetCurrentProcessorNumberProc && nr_processor_groups == 1))
996      hooks->get_thisthread_last_cpu_location = hwloc_win_get_thisthread_last_cpu_location;
997    if (nr_processor_groups == 1) {
998      hooks->set_proc_cpubind = hwloc_win_set_proc_cpubind;
999      hooks->get_proc_cpubind = hwloc_win_get_proc_cpubind;
1000      hooks->set_thisproc_cpubind = hwloc_win_set_thisproc_cpubind;
1001      hooks->get_thisproc_cpubind = hwloc_win_get_thisproc_cpubind;
1002      hooks->set_proc_membind = hwloc_win_set_proc_membind;
1003      hooks->get_proc_membind = hwloc_win_get_proc_membind;
1004      hooks->set_thisproc_membind = hwloc_win_set_thisproc_membind;
1005      hooks->get_thisproc_membind = hwloc_win_get_thisproc_membind;
1006    }
1007    if (nr_processor_groups == 1 || SetThreadGroupAffinityProc) {
1008      hooks->set_thread_cpubind = hwloc_win_set_thread_cpubind;
1009      hooks->set_thisthread_cpubind = hwloc_win_set_thisthread_cpubind;
1010      hooks->set_thisthread_membind = hwloc_win_set_thisthread_membind;
1011    }
1012    if (GetThreadGroupAffinityProc) {
1013      hooks->get_thread_cpubind = hwloc_win_get_thread_cpubind;
1014      hooks->get_thisthread_cpubind = hwloc_win_get_thisthread_cpubind;
1015      hooks->get_thisthread_membind = hwloc_win_get_thisthread_membind;
1016    }
1017    if (VirtualAllocExNumaProc) {
1018      hooks->alloc_membind = hwloc_win_alloc_membind;
1019      hooks->alloc = hwloc_win_alloc;
1020      hooks->free_membind = hwloc_win_free_membind;
1021      support->membind->bind_membind = 1;
1022    }
1023    if (QueryWorkingSetExProc && max_numanode_index <= 63 &bsol;* PSAPI_WORKING_SET_EX_BLOCK.Node is 6 bits only */)
1024      hooks->get_area_memlocation = hwloc_win_get_area_memlocation;
1025  }
1026  static int hwloc_windows_component_init(unsigned long flags __hwloc_attribute_unused)
1027  {
1028    hwloc_win_get_function_ptrs();
1029    hwloc_win_get_processor_groups();
1030    return 0;
1031  }
1032  static void hwloc_windows_component_finalize(unsigned long flags __hwloc_attribute_unused)
1033  {
1034    hwloc_win_free_processor_groups();
1035  }
1036  static struct hwloc_backend *
1037  hwloc_windows_component_instantiate(struct hwloc_topology *topology,
1038  				    struct hwloc_disc_component *component,
1039  				    unsigned excluded_phases __hwloc_attribute_unused,
1040  				    const void *_data1 __hwloc_attribute_unused,
1041  				    const void *_data2 __hwloc_attribute_unused,
1042  				    const void *_data3 __hwloc_attribute_unused)
1043  {
1044    struct hwloc_backend *backend;
1045    backend = hwloc_backend_alloc(topology, component);
1046    if (!backend)
1047      return NULL;
1048    backend->discover = hwloc_look_windows;
1049    return backend;
1050  }
1051  static struct hwloc_disc_component hwloc_windows_disc_component = {
1052    "windows",
1053    HWLOC_DISC_PHASE_CPU,
1054    HWLOC_DISC_PHASE_GLOBAL,
1055    hwloc_windows_component_instantiate,
1056    50,
1057    1,
1058    NULL
1059  };
1060  const struct hwloc_component hwloc_windows_component = {
1061    HWLOC_COMPONENT_ABI,
1062    hwloc_windows_component_init, hwloc_windows_component_finalize,
1063    HWLOC_COMPONENT_TYPE_DISC,
1064    0,
1065    &hwloc_windows_disc_component
1066  };
1067  int
1068  hwloc_fallback_nbprocessors(unsigned flags __hwloc_attribute_unused) {
1069    int n;
1070    SYSTEM_INFO sysinfo;
1071    GetSystemInfo(&sysinfo);
1072    n = sysinfo.dwNumberOfProcessors; &bsol;* FIXME could be non-contigous, rather return a mask from dwActiveProcessorMask? */
1073    if (nr_processor_groups > 1) {
1074      if (GetActiveProcessorCountProc)
1075        n = MAXIMUM_PROC_PER_GROUP*(nr_processor_groups-1)
1076  	+ GetActiveProcessorCountProc((WORD)nr_processor_groups-1);
1077      else
1078        n = MAXIMUM_PROC_PER_GROUP*nr_processor_groups;
1079    }
1080    return n;
1081  }
1082  int64_t
1083  hwloc_fallback_memsize(void) {
1084    return -1;
1085  }
</code></pre>
        </div>
        <div class="column">
            <h3>android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeImageHandler.h</h3>
            <pre><code>1  &bsol;*
2   * cgeImageHandler.h
3   *
4   *  Created on: 2013-12-13
5   *      Author: Wang Yang
6   *      Mail: admin@wysaid.org
7   */
8  #ifndef _CGEIMAGEHANDLER_H_
9  #define _CGEIMAGEHANDLER_H_
10  #include "cgeGLFunctions.h"
11  #include "cgeGlobal.h"
12  #include "cgeImageFilter.h"
13  namespace CGE
14  {
15  class CGEImageFilterInterfaceAbstract;
16  class CGEImageFilterInterface;
17  class TextureDrawer;
18  class CGEImageHandlerInterface
19  {
20  public:
21      CGEImageHandlerInterface();
22      virtual ~CGEImageHandlerInterface();
23      virtual GLuint getResultTextureAndClearHandler();
24      virtual size_t getOutputBufferLen(size_t channel = 4); 
25      virtual size_t getOutputBufferBytesPerRow(size_t channel = 4);
26      inline const GLfloat* getPosVertices() const
27      {
28          return CGEGlobalConfig::sVertexDataCommon;
29      };
30      virtual void processingFilters() = 0;
31      virtual void setAsTarget() = 0;
32      virtual void swapBufferFBO() = 0; 
33      virtual GLuint copyLastResultTexture(GLuint dstTex = 0) { return 0; }
34      virtual GLuint copyResultTexture(GLuint dstTex = 0) { return 0; }
35      GLuint& getSourceTextureID() { return m_srcTexture; }
36      GLuint& getTargetTextureID() { return m_bufferTextures[0]; }
37      GLuint& getBufferTextureID() { return m_bufferTextures[1]; }
38      const CGESizei& getOutputFBOSize() const { return m_dstImageSize; }
39      GLuint& getFrameBufferID() { return m_dstFrameBuffer; }
40      void getOutputFBOSize(int& w, int& h)
41      {
42          w = m_dstImageSize.width;
43          h = m_dstImageSize.height;
44      }
45      void copyTextureData(void* data, int w, int h, GLuint texID, GLenum dataFmt, GLenum channelFmt);
46  protected:
47      virtual bool initImageFBO(const void* data, int w, int h, GLenum channelFmt, GLenum dataFmt, int channel);
48      virtual void clearImageFBO();
49  protected:
<span onclick='openModal()' class='match'>50      GLuint m_srcTexture;
51      CGESizei m_dstImageSize;
52      GLuint m_bufferTextures[2];
53      GLuint m_dstFrameBuffer;
54      GLuint m_vertexArrayBuffer;
</span>55  };
56  class CGEImageHandler : public CGEImageHandlerInterface
57  {
58  private:
59      explicit CGEImageHandler(const CGEImageHandler&) {}
60  public:
61      CGEImageHandler();
62      virtual ~CGEImageHandler();
63      bool initWithRawBufferData(const void* data, GLint w, GLint h, CGEBufferFormat format, bool bEnableReversion = true);
64      bool updateData(const void* data, int w, int h, CGEBufferFormat format);
65      bool initWithTexture(GLuint textureID, GLint w, GLint h, CGEBufferFormat format, bool bEnableReversion = false);
66      bool getOutputBufferData(void* data, CGEBufferFormat format);
67      size_t getOutputBufferLen(size_t channel);
68      size_t getOutputBufferBytesPerRow(size_t channel);
69      void setAsTarget();
70      void addImageFilter(CGEImageFilterInterfaceAbstract* proc);
71      void popImageFilter();
72      void clearImageFilters(bool bDelMem = true);
73      inline size_t getFilterNum() { return m_vecFilters.size(); }
74      inline CGEImageFilterInterfaceAbstract* getFilterByIndex(GLuint index)
75      {
76          return index >= m_vecFilters.size() ? nullptr : m_vecFilters[index];
77      }
78      int getFilterIndexByAddr(const void* addr);
79      bool insertFilterAtIndex(CGEImageFilterInterfaceAbstract* proc, GLuint index);
80      bool deleteFilterByAddr(const void* addr, bool bDelMem = true);
81      bool deleteFilterByIndex(GLuint index, bool bDelMem = true);
82      bool replaceFilterAtIndex(CGEImageFilterInterfaceAbstract* proc, GLuint index, bool bDelMem = true);
83      bool swapFilterByIndex(GLuint left, GLuint right);
84      void peekFilters(std::vector<CGEImageFilterInterfaceAbstract*>* vTrans);
85      std::vector<CGEImageFilterInterfaceAbstract*>& peekFilters() { return m_vecFilters; }
86      void processingFilters();
87      bool processingWithFilter(GLint index);
88      bool processingWithFilter(CGEImageFilterInterfaceAbstract* proc);
89      virtual void disableReversion();
90      bool reversionEnabled() { return m_bRevertEnabled; }
91      bool keepCurrentResult();
92      virtual bool revertToKeptResult(bool bRevert2Target = false);
93      virtual void swapBufferFBO(); 
94      virtual GLuint copyLastResultTexture(GLuint dstTex = 0);
95      virtual GLuint copyResultTexture(GLuint dstTex = 0);
96  #ifdef _CGE_USE_ES_API_3_0_
97      const void* mapOutputBuffer(CGEBufferFormat fmt);
98      void unmapOutputBuffer();
99  #endif
100      bool copyTexture(GLuint dst, GLuint src); 
101      bool copyTexture(GLuint dst, GLuint src, int x, int y, int w, int h);
102      bool copyTexture(GLuint dst, GLuint src, int xOffset, int yOffset, int x, int y, int w, int h);
103      void drawResult();
104      TextureDrawer* getResultDrawer();
105      void setResultDrawer(TextureDrawer* drawer);
106      virtual void useImageFBO();
107  protected:
108      bool m_bRevertEnabled;
109      std::vector<CGEImageFilterInterfaceAbstract*> m_vecFilters;
110      TextureDrawer *m_drawer, *m_resultDrawer;
111  #ifdef _CGE_USE_ES_API_3_0_
112      GLuint m_pixelPackBuffer;
113      GLsizei m_pixelPackBufferSize;
114      void clearPixelBuffer();
115      bool initPixelBuffer();
116      bool initImageFBO(const void* data, int w, int h, GLenum channelFmt, GLenum dataFmt, int channel);
117  #endif
118  };
119  } 
120  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-topology-windows.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from android-gpuimage-plus-MDEwOlJlcG9zaXRvcnk0NjU0NzQxNw==-flat-cgeImageHandler.h</div>
                </div>
                <div class="column column_space"><pre><code>90    BYTE MaximumProcessorCount;
91    BYTE ActiveProcessorCount;
92    BYTE Reserved[38];
93    KAFFINITY ActiveProcessorMask;
94  } PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;
</pre></code></div>
                <div class="column column_space"><pre><code>50      GLuint m_srcTexture;
51      CGESizei m_dstImageSize;
52      GLuint m_bufferTextures[2];
53      GLuint m_dstFrameBuffer;
54      GLuint m_vertexArrayBuffer;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    