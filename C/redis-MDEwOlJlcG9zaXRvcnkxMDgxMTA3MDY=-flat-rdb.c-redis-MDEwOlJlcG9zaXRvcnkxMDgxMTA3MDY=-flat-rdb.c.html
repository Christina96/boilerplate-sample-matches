
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rdb.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/win32_types.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "lzf.h"    &bsol;* LZF compression library */
7  #include "zipmap.h"
8  #include "endianconv.h"
9  #include "stream.h"
10  #include <math.h>
11  #include <sys/types.h>
12  #ifdef _WIN32
13  #include <stdio.h>
14  #include "Win32_Interop/Win32_QFork.h"
15  #include <direct.h>
16  #define MAXPATHLEN 1024
17  #else
18  #include <sys/time.h>
19  #include <sys/resource.h>
20  #include <sys/wait.h>
21  #include <arpa/inet.h>
22  #endif
23  #include <sys/stat.h>
24  #ifndef _WIN32
25  #include <sys/param.h>
26  #endif
27  #define rdbExitReportCorruptRDB(...) rdbCheckThenExit(__LINE__,__VA_ARGS__)
28  extern int rdbCheckMode;
29  void rdbCheckError(const char *fmt, ...);
30  void rdbCheckSetError(const char *fmt, ...);
31  WIN32_ONLY(__declspec(noreturn))
32  void rdbCheckThenExit(int linenum, char *reason, ...) {
33      va_list ap;
34      char msg[1024];
35      int len;
36      len = snprintf(msg,sizeof(msg),
37          "Internal error in RDB reading function at rdb.c:%d -> ", linenum);
38      va_start(ap,reason);
39      vsnprintf(msg+len,sizeof(msg)-len,reason,ap);
40      va_end(ap);
41      if (!rdbCheckMode) {
42          serverLog(LL_WARNING, "%s", msg);
43          char *argv[2] = {"",server.rdb_filename};
44          redis_check_rdb_main(2,argv,NULL);
45      } else {
46          rdbCheckError("%s",msg);
47      }
48      exit(1);
49  }
50  static int rdbWriteRaw(rio *rdb, void *p, size_t len) {
51      if (rdb && rioWrite(rdb,p,len) == 0)
52          return -1;
53      return (int)len;                  WIN_PORT_FIX &bsol;* cast (int) */
54  }
55  void rdbLoadRaw(rio *rdb, void *buf, uint64_t len) {
56      if (rioRead(rdb,buf,len) == 0) {
57          rdbExitReportCorruptRDB(
58              "Impossible to read %llu bytes in rdbLoadRaw()",
59              (PORT_ULONGLONG) len);
60          return; &bsol;* Not reached. */
61      }
62  }
63  int rdbSaveType(rio *rdb, unsigned char type) {
64      return rdbWriteRaw(rdb,&type,1);
65  }
66  int rdbLoadType(rio *rdb) {
67      unsigned char type;
68      if (rioRead(rdb,&type,1) == 0) return -1;
69      return type;
70  }
71  time_t rdbLoadTime(rio *rdb) {
72      int32_t t32;
73      rdbLoadRaw(rdb,&t32,4);
74      return (time_t)t32;
75  }
76  int rdbSaveMillisecondTime(rio *rdb, PORT_LONGLONG t) {
77      int64_t t64 = (int64_t) t;
78      memrev64ifbe(&t64); &bsol;* Store in little endian. */
79      return rdbWriteRaw(rdb,&t64,8);
80  }
81  PORT_LONGLONG rdbLoadMillisecondTime(rio *rdb, int rdbver) {
82      int64_t t64;
83      rdbLoadRaw(rdb,&t64,8);
84      if (rdbver >= 9) &bsol;* Check the top comment of this function. */
85          memrev64ifbe(&t64); &bsol;* Convert in big endian if the system is BE. */
86      return (PORT_LONGLONG)t64;
87  }
88  int rdbSaveLen(rio *rdb, uint64_t len) {
89      unsigned char buf[2];
90      size_t nwritten;
91      if (len < (1<<6)) {
92          buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);
93          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
94          nwritten = 1;
95      } else if (len < (1<<14)) {
96          buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
97          buf[1] = len&0xFF;
98          if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
99          nwritten = 2;
100      } else if (len <= UINT32_MAX) {
101          buf[0] = RDB_32BITLEN;
102          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
103          uint32_t len32 = htonl(len);
104          if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;
105          nwritten = 1+4;
106      } else {
107          buf[0] = RDB_64BITLEN;
108          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
109          len = htonu64(len);
110          if (rdbWriteRaw(rdb,&len,8) == -1) return -1;
111          nwritten = 1+8;
112      }
113      return (int)nwritten;                                                       WIN_PORT_FIX &bsol;* cast (int) */
114  }
115  int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
116      unsigned char buf[2];
117      int type;
118      if (isencoded) *isencoded = 0;
119      if (rioRead(rdb,buf,1) == 0) return -1;
120      type = (buf[0]&0xC0)>>6;
121      if (type == RDB_ENCVAL) {
122          if (isencoded) *isencoded = 1;
123          *lenptr = buf[0]&0x3F;
124      } else if (type == RDB_6BITLEN) {
125          *lenptr = buf[0]&0x3F;
126      } else if (type == RDB_14BITLEN) {
127          if (rioRead(rdb,buf+1,1) == 0) return -1;
128          *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
129      } else if (buf[0] == RDB_32BITLEN) {
130          uint32_t len;
131          if (rioRead(rdb,&len,4) == 0) return -1;
132          *lenptr = ntohl(len);
133      } else if (buf[0] == RDB_64BITLEN) {
134          uint64_t len;
135          if (rioRead(rdb,&len,8) == 0) return -1;
136          *lenptr = ntohu64(len);
137      } else {
138          rdbExitReportCorruptRDB(
139              "Unknown length encoding %d in rdbLoadLen()",type);
140          return -1; &bsol;* Never reached. */
141      }
142      return 0;
143  }
144  uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
145      uint64_t len;
146      if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
147      return len;
148  }
149  int rdbEncodeInteger(PORT_LONGLONG value, unsigned char *enc) {
150      if (value >= -(1<<7) && value <= (1<<7)-1) {
151          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;
152          enc[1] = value&0xFF;
153          return 2;
154      } else if (value >= -(1<<15) && value <= (1<<15)-1) {
155          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;
156          enc[1] = value&0xFF;
157          enc[2] = (value>>8)&0xFF;
158          return 3;
159      } else if (value >= -((PORT_LONGLONG)1<<31) && value <= ((PORT_LONGLONG)1<<31)-1) {
160          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;
161          enc[1] = value&0xFF;
162          enc[2] = (value>>8)&0xFF;
163          enc[3] = (value>>16)&0xFF;
164          enc[4] = (value>>24)&0xFF;
165          return 5;
166      } else {
167          return 0;
168      }
169  }
170  void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {
171      int plain = flags & RDB_LOAD_PLAIN;
172      int sds = flags & RDB_LOAD_SDS;
173      int encode = flags & RDB_LOAD_ENC;
174      unsigned char enc[4];
175      PORT_LONGLONG val;
176      if (enctype == RDB_ENC_INT8) {
177          if (rioRead(rdb,enc,1) == 0) return NULL;
178          val = (signed char)enc[0];
179      } else if (enctype == RDB_ENC_INT16) {
180          uint16_t v;
181          if (rioRead(rdb,enc,2) == 0) return NULL;
182          v = enc[0]|(enc[1]<<8);
183          val = (int16_t)v;
184      } else if (enctype == RDB_ENC_INT32) {
185          uint32_t v;
186          if (rioRead(rdb,enc,4) == 0) return NULL;
187          v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);
188          val = (int32_t)v;
189      } else {
190          val = 0; &bsol;* anti-warning */
191          rdbExitReportCorruptRDB("Unknown RDB integer encoding type %d",enctype);
192      }
193      if (plain || sds) {
194          char buf[LONG_STR_SIZE], *p;
195          int len = ll2string(buf,sizeof(buf),val);
196          if (lenptr) *lenptr = len;
197          p = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);
198          memcpy(p,buf,len);
199          return p;
200      } else if (encode) {
201          return createStringObjectFromLongLongForValue(val);
202      } else {
203          return createObject(OBJ_STRING,sdsfromlonglong(val));
204      }
205  }
206  int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
207      PORT_LONGLONG value;
208      char *endptr, buf[32];
209      value = strtoll(s, &endptr, 10);
210      if (endptr[0] != '\0') return 0;
211      ll2string(buf,32,value);
212      if (strlen(buf) != len || memcmp(buf,s,len)) return 0;
213      return rdbEncodeInteger(value,enc);
214  }
215  ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
216                         size_t original_len) {
217      unsigned char byte;
218      ssize_t n, nwritten = 0;
219      byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;
220      if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;
221      nwritten += n;
222      if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;
223      nwritten += n;
224      if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;
225      nwritten += n;
226      if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
227      nwritten += n;
228      return nwritten;
229  writeerr:
230      return -1;
231  }
232  ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
233      size_t comprlen, outlen;
234      void *out;
235      if (len <= 4) return 0;
236      outlen = len-4;
237      if ((out = zmalloc(outlen+1)) == NULL) return 0;
238      comprlen = lzf_compress(s, len, out, outlen);
239      if (comprlen == 0) {
240          zfree(out);
241          return 0;
242      }
243      ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
244      zfree(out);
245      return nwritten;
246  }
247  void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {
248      int plain = flags & RDB_LOAD_PLAIN;
249      int sds = flags & RDB_LOAD_SDS;
250      uint64_t len, clen;
251      unsigned char *c = NULL;
252      char *val = NULL;
253      if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
254      if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
255      if ((c = zmalloc(clen)) == NULL) goto err;
256      if (plain) {
257          val = zmalloc(len);
258      } else {
259          val = sdsnewlen(SDS_NOINIT,len);
260      }
261      if (lenptr) *lenptr = len;
262      if (rioRead(rdb,c,clen) == 0) goto err;
263      if (lzf_decompress(c,clen,val,len) == 0) {
264          if (rdbCheckMode) rdbCheckSetError("Invalid LZF compressed string");
265          goto err;
266      }
267      zfree(c);
268      if (plain || sds) {
269          return val;
270      } else {
271          return createObject(OBJ_STRING,val);
272      }
273  err:
274      zfree(c);
275      if (plain)
276          zfree(val);
277      else
278          sdsfree(val);
279      return NULL;
280  }
281  ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
282      int enclen;
283      ssize_t n, nwritten = 0;
284      if (len <= 11) {
285          unsigned char buf[5];
286          if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
287              if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
288              return enclen;
289          }
290      }
291      if (server.rdb_compression && len > 20) {
292          n = rdbSaveLzfStringObject(rdb,s,len);
293          if (n == -1) return -1;
294          if (n > 0) return n;
295      }
296      if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
297      nwritten += n;
298      if (len > 0) {
299          if (rdbWriteRaw(rdb,s,len) == -1) return -1;
300          nwritten += len;
301      }
302      return nwritten;
303  }
304  ssize_t rdbSaveLongLongAsStringObject(rio *rdb, PORT_LONGLONG value) {
305      unsigned char buf[32];
306      ssize_t n, nwritten = 0;
307      int enclen = rdbEncodeInteger(value,buf);
308      if (enclen > 0) {
309          return rdbWriteRaw(rdb,buf,enclen);
310      } else {
311          enclen = ll2string((char*)buf,32,value);
312          serverAssert(enclen < 32);
313          if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;
314          nwritten += n;
315          if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
316          nwritten += n;
317      }
318      return nwritten;
319  }
320  ssize_t rdbSaveStringObject(rio *rdb, robj *obj) {
321      if (obj->encoding == OBJ_ENCODING_INT) {
322          return rdbSaveLongLongAsStringObject(rdb,(PORT_LONG)obj->ptr);
323      } else {
324          serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));
325          return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));
326      }
327  }
328  void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
329      int encode = flags & RDB_LOAD_ENC;
330      int plain = flags & RDB_LOAD_PLAIN;
331      int sds = flags & RDB_LOAD_SDS;
332      int isencoded;
333      uint64_t len;
334      len = rdbLoadLen(rdb,&isencoded);
335      if (isencoded) {
336          switch(len) {
337          case RDB_ENC_INT8:
338          case RDB_ENC_INT16:
339          case RDB_ENC_INT32:
340              return rdbLoadIntegerObject(rdb,len,flags,lenptr);
341          case RDB_ENC_LZF:
342              return rdbLoadLzfStringObject(rdb,flags,lenptr);
343          default:
344              rdbExitReportCorruptRDB("Unknown RDB string encoding type %d",len);
345          }
346      }
347      if (len == RDB_LENERR) return NULL;
348      if (plain || sds) {
349          void *buf = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);
350          if (lenptr) *lenptr = len;
351          if (len && rioRead(rdb,buf,len) == 0) {
352              if (plain)
353                  zfree(buf);
354              else
355                  sdsfree(buf);
356              return NULL;
357          }
358          return buf;
359      } else {
360          robj *o = encode ? createStringObject(SDS_NOINIT,len) :
361                             createRawStringObject(SDS_NOINIT,len);
362          if (len && rioRead(rdb,o->ptr,len) == 0) {
363              decrRefCount(o);
364              return NULL;
365          }
366          return o;
367      }
368  }
369  robj *rdbLoadStringObject(rio *rdb) {
370      return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
371  }
372  robj *rdbLoadEncodedStringObject(rio *rdb) {
373      return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
374  }
375  int rdbSaveDoubleValue(rio *rdb, double val) {
376      unsigned char buf[128];
377      int len;
378      if (isnan(val)) {
379          buf[0] = 253;
380          len = 1;
381      } else if (!isfinite(val)) {
382          len = 1;
383          buf[0] = (val < 0) ? 255 : 254;
384      } else {
385  #if (DBL_MANT_DIG >= 52) && (LLONG_MAX == 0x7fffffffffffffffLL)
386          double min = -4503599627370495; &bsol;* (2^52)-1 */
387          double max = 4503599627370496; &bsol;* -(2^52) */
388          if (val > min && val < max && val == ((double)((PORT_LONGLONG)val)))
389              ll2string((char*)buf+1,sizeof(buf)-1,(PORT_LONGLONG)val);
390          else
391  #endif
392              snprintf((char*)buf+1,sizeof(buf)-1,"%.17g",val);
393          buf[0] = (unsigned char)strlen((char*)buf+1);                           WIN_PORT_FIX &bsol;* cast (unsigned char) */
394          len = buf[0]+1;
395      }
396      return rdbWriteRaw(rdb,buf,len);
397  }
398  int rdbLoadDoubleValue(rio *rdb, double *val) {
399      char buf[256];
400      unsigned char len;
401  #ifdef _WIN32
402      double scannedVal = 0;
403      int assigned = 0;
404      memset(buf, 0, sizeof(buf));
405  #endif
406      if (rioRead(rdb,&len,1) == 0) return -1;
407      switch(len) {
408      case 255: *val = R_NegInf; return 0;
409      case 254: *val = R_PosInf; return 0;
410      case 253: *val = R_Nan; return 0;
411      default:
412          if (rioRead(rdb,buf,len) == 0) return -1;
413          buf[len] = '\0';
414  #ifdef _WIN32
415          assigned = sscanf_s(buf, "%lg", &scannedVal);
416          if( assigned != 0 ) {
417              (*val) = scannedVal;
418              return 0;
419          } else {
420              return -1;
421          }
422  #else
423          sscanf(buf, "%lg", val);
424          return 0;
425  #endif
426      }
427  }
428  int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
429      memrev64ifbe(&val);
430      return rdbWriteRaw(rdb,&val,sizeof(val));
431  }
432  int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
433      if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
434      memrev64ifbe(val);
435      return 0;
436  }
437  int rdbSaveBinaryFloatValue(rio *rdb, float val) {
438      memrev32ifbe(&val);
439      return rdbWriteRaw(rdb,&val,sizeof(val));
440  }
441  int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
442      if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
443      memrev32ifbe(val);
444      return 0;
445  }
446  int rdbSaveObjectType(rio *rdb, robj *o) {
447      switch (o->type) {
448      case OBJ_STRING:
449          return rdbSaveType(rdb,RDB_TYPE_STRING);
450      case OBJ_LIST:
451          if (o->encoding == OBJ_ENCODING_QUICKLIST)
452              return rdbSaveType(rdb,RDB_TYPE_LIST_QUICKLIST);
453          else
454              serverPanic("Unknown list encoding");
455      case OBJ_SET:
456          if (o->encoding == OBJ_ENCODING_INTSET)
457              return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);
458          else if (o->encoding == OBJ_ENCODING_HT)
459              return rdbSaveType(rdb,RDB_TYPE_SET);
460          else
461              serverPanic("Unknown set encoding");
462      case OBJ_ZSET:
463          if (o->encoding == OBJ_ENCODING_ZIPLIST)
464              return rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);
465          else if (o->encoding == OBJ_ENCODING_SKIPLIST)
466              return rdbSaveType(rdb,RDB_TYPE_ZSET_2);
467          else
468              serverPanic("Unknown sorted set encoding");
469      case OBJ_HASH:
470          if (o->encoding == OBJ_ENCODING_ZIPLIST)
471              return rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);
472          else if (o->encoding == OBJ_ENCODING_HT)
473              return rdbSaveType(rdb,RDB_TYPE_HASH);
474          else
475              serverPanic("Unknown hash encoding");
476      case OBJ_STREAM:
477          return rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS);
478      case OBJ_MODULE:
479          return rdbSaveType(rdb,RDB_TYPE_MODULE_2);
480      default:
481          serverPanic("Unknown object type");
482      }
483      return -1; &bsol;* avoid warning */
484  }
485  int rdbLoadObjectType(rio *rdb) {
486      int type;
487      if ((type = rdbLoadType(rdb)) == -1) return -1;
488      if (!rdbIsObjectType(type)) return -1;
489      return type;
490  }
491  ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
492      ssize_t n, nwritten = 0;
493      if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
494      nwritten += n;
495      raxIterator ri;
496      raxStart(&ri,pel);
497      raxSeek(&ri,"^",NULL,0);
498      while(raxNext(&ri)) {
499          if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) return -1;
500          nwritten += n;
501          if (nacks) {
502              streamNACK *nack = ri.data;
503              if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1)
504                  return -1;
505              nwritten += n;
506              if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) return -1;
507              nwritten += n;
508          }
509      }
510      raxStop(&ri);
511      return nwritten;
512  }
513  size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
514      ssize_t n, nwritten = 0;
515      if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
516      nwritten += n;
517      raxIterator ri;
518      raxStart(&ri,cg->consumers);
519      raxSeek(&ri,"^",NULL,0);
520      while(raxNext(&ri)) {
521          streamConsumer *consumer = ri.data;
522          if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
523          nwritten += n;
524          if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1)
525              return -1;
526          nwritten += n;
527          if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1)
528              return -1;
529          nwritten += n;
530      }
531      raxStop(&ri);
532      return nwritten;
533  }
534  ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {
535      ssize_t n = 0, nwritten = 0;
536      if (o->type == OBJ_STRING) {
537          if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;
538          nwritten += n;
539      } else if (o->type == OBJ_LIST) {
540          if (o->encoding == OBJ_ENCODING_QUICKLIST) {
541              quicklist *ql = o->ptr;
542              quicklistNode *node = ql->head;
543              if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;
544              nwritten += n;
545              while(node) {
546                  if (quicklistNodeIsCompressed(node)) {
547                      void *data;
548                      size_t compress_len = quicklistGetLzf(node, &data);
549                      if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;
550                      nwritten += n;
551                  } else {
552                      if ((n = rdbSaveRawString(rdb,node->zl,node->sz)) == -1) return -1;
553                      nwritten += n;
554                  }
555                  node = node->next;
556              }
557          } else {
558              serverPanic("Unknown list encoding");
559          }
560      } else if (o->type == OBJ_SET) {
561          if (o->encoding == OBJ_ENCODING_HT) {
562              dict *set = o->ptr;
563              dictIterator *di = dictGetIterator(set);
564              dictEntry *de;
565              if ((n = rdbSaveLen(rdb,dictSize(set))) == -1) {
566                  dictReleaseIterator(di);
567                  return -1;
568              }
569              nwritten += n;
570              while((de = dictNext(di)) != NULL) {
571                  sds ele = dictGetKey(de);
572                  if ((n = rdbSaveRawString(rdb,(unsigned char*)ele,sdslen(ele)))
573                      == -1)
574                  {
575                      dictReleaseIterator(di);
576                      return -1;
577                  }
578                  nwritten += n;
579              }
580              dictReleaseIterator(di);
581          } else if (o->encoding == OBJ_ENCODING_INTSET) {
582              size_t l = intsetBlobLen((intset*)o->ptr);
583              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
584              nwritten += n;
585          } else {
586              serverPanic("Unknown set encoding");
587          }
588      } else if (o->type == OBJ_ZSET) {
589          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
590              size_t l = ziplistBlobLen((unsigned char*)o->ptr);
591              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
592              nwritten += n;
593          } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
594              zset *zs = o->ptr;
595              zskiplist *zsl = zs->zsl;
596              if ((n = rdbSaveLen(rdb,zsl->length)) == -1) return -1;
597              nwritten += n;
598              zskiplistNode *zn = zsl->tail;
599              while (zn != NULL) {
600                  if ((n = rdbSaveRawString(rdb,
601                      (unsigned char*)zn->ele,sdslen(zn->ele))) == -1)
602                  {
603                      return -1;
604                  }
605                  nwritten += n;
606                  if ((n = rdbSaveBinaryDoubleValue(rdb,zn->score)) == -1)
607                      return -1;
608                  nwritten += n;
609                  zn = zn->backward;
610              }
611          } else {
612              serverPanic("Unknown sorted set encoding");
613          }
614      } else if (o->type == OBJ_HASH) {
615          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
616              size_t l = ziplistBlobLen((unsigned char*)o->ptr);
617              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
618              nwritten += n;
619          } else if (o->encoding == OBJ_ENCODING_HT) {
620              dictIterator *di = dictGetIterator(o->ptr);
621              dictEntry *de;
622              if ((n = rdbSaveLen(rdb,dictSize((dict*)o->ptr))) == -1) {
623                  dictReleaseIterator(di);
624                  return -1;
625              }
626              nwritten += n;
627              while((de = dictNext(di)) != NULL) {
628                  sds field = dictGetKey(de);
629                  sds value = dictGetVal(de);
630                  if ((n = rdbSaveRawString(rdb,(unsigned char*)field,
631                          sdslen(field))) == -1)
632                  {
633                      dictReleaseIterator(di);
634                      return -1;
635                  }
636                  nwritten += n;
637                  if ((n = rdbSaveRawString(rdb,(unsigned char*)value,
638                          sdslen(value))) == -1)
639                  {
640                      dictReleaseIterator(di);
641                      return -1;
642                  }
643                  nwritten += n;
644              }
645              dictReleaseIterator(di);
646          } else {
647              serverPanic("Unknown hash encoding");
648          }
649      } else if (o->type == OBJ_STREAM) {
650          stream *s = o->ptr;
651          rax *rax = s->rax;
652          if ((n = rdbSaveLen(rdb,raxSize(rax))) == -1) return -1;
653          nwritten += n;
654          raxIterator ri;
655          raxStart(&ri,rax);
656          raxSeek(&ri,"^",NULL,0);
657          while (raxNext(&ri)) {
658              unsigned char *lp = ri.data;
659              size_t lp_bytes = lpBytes(lp);
660              if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
661              nwritten += n;
662              if ((n = rdbSaveRawString(rdb,lp,lp_bytes)) == -1) return -1;
663              nwritten += n;
664          }
665          raxStop(&ri);
666          if ((n = rdbSaveLen(rdb,s->length)) == -1) return -1;
667          nwritten += n;
668          if ((n = rdbSaveLen(rdb,s->last_id.ms)) == -1) return -1;
669          nwritten += n;
670          if ((n = rdbSaveLen(rdb,s->last_id.seq)) == -1) return -1;
671          nwritten += n;
672          size_t num_cgroups = s->cgroups ? raxSize(s->cgroups) : 0;
673          if ((n = rdbSaveLen(rdb,num_cgroups)) == -1) return -1;
674          nwritten += n;
675          if (num_cgroups) {
676              raxStart(&ri,s->cgroups);
677              raxSeek(&ri,"^",NULL,0);
678              while(raxNext(&ri)) {
679                  streamCG *cg = ri.data;
680                  if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1)
681                      return -1;
682                  nwritten += n;
683                  if ((n = rdbSaveLen(rdb,cg->last_id.ms)) == -1) return -1;
684                  nwritten += n;
685                  if ((n = rdbSaveLen(rdb,cg->last_id.seq)) == -1) return -1;
686                  nwritten += n;
687                  if ((n = rdbSaveStreamPEL(rdb,cg->pel,1)) == -1) return -1;
688                  nwritten += n;
689                  if ((n = rdbSaveStreamConsumers(rdb,cg)) == -1) return -1;
690                  nwritten += n;
691              }
692              raxStop(&ri);
693          }
694      } else if (o->type == OBJ_MODULE) {
695          RedisModuleIO io;
696          moduleValue *mv = o->ptr;
697          moduleType *mt = mv->type;
698          int retval = rdbSaveLen(rdb,mt->id);
699          if (retval == -1) return -1;
700          moduleInitIOContext(io,mt,rdb,key);
701          io.bytes += retval;
702          mt->rdb_save(&io,mv->value);
703          retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
704          if (retval == -1)
705              io.error = 1;
706          else
707              io.bytes += retval;
708          if (io.ctx) {
709              moduleFreeContext(io.ctx);
710              zfree(io.ctx);
711          }
712          return io.error ? -1 : (ssize_t)io.bytes;
713      } else {
714          serverPanic("Unknown object type");
715      }
716      return nwritten;
717  }
718  size_t rdbSavedObjectLen(robj *o) {
719      ssize_t len = rdbSaveObject(NULL,o,NULL);
720      serverAssertWithInfo(NULL,o,len != -1);
721      return len;
722  }
723  int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, PORT_LONGLONG expiretime) {
724      int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;
725      int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;
726      if (expiretime != -1) {
727          if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
728          if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
729      }
730      if (savelru) {
731          uint64_t idletime = estimateObjectIdleTime(val);
732          idletime /= 1000; &bsol;* Using seconds is enough and requires less space.*/
733          if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
734          if (rdbSaveLen(rdb,idletime) == -1) return -1;
735      }
736      if (savelfu) {
737          uint8_t buf[1];
738          buf[0] = LFUDecrAndReturn(val);
739          if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) return -1;
740          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
741      }
742      if (rdbSaveObjectType(rdb,val) == -1) return -1;
743      if (rdbSaveStringObject(rdb,key) == -1) return -1;
744      if (rdbSaveObject(rdb,val,key) == -1) return -1;
745      return 1;
746  }
747  ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
748      ssize_t ret, len = 0;
749      if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
750      len += ret;
751      if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
752      len += ret;
753      if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
754      len += ret;
755      return len;
756  }
757  ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
758      return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
759  }
760  ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, PORT_LONGLONG val) {
761      char buf[LONG_STR_SIZE];
762      int vlen = ll2string(buf,sizeof(buf),val);
763      return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
764  }
765  int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) {
766      int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
767      int aof_preamble = (flags & RDB_SAVE_AOF_PREAMBLE) != 0;
768      if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) return -1;
769      if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) return -1;
770      if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) return -1;
771      if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) return -1;
772      if (rsi) {
773          if (rdbSaveAuxFieldStrInt(rdb,"repl-stream-db",rsi->repl_stream_db)
774              == -1) return -1;
775          if (rdbSaveAuxFieldStrStr(rdb,"repl-id",server.replid)
776              == -1) return -1;
777          if (rdbSaveAuxFieldStrInt(rdb,"repl-offset",server.master_repl_offset)
778              == -1) return -1;
779      }
780      if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) return -1;
781      return 1;
782  }
783  ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
784      RedisModuleIO io;
785      int retval = rdbSaveType(rdb, RDB_OPCODE_MODULE_AUX);
786      if (retval == -1) return -1;
787      moduleInitIOContext(io,mt,rdb,NULL);                           WIN_PORT_FIX &bsol;*moved earlier before first usage of "io"*/
788      io.bytes += retval;
789      retval = rdbSaveLen(rdb,mt->id);
790      if (retval == -1) return -1;
791      io.bytes += retval;
792      retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_UINT);
793      if (retval == -1) return -1;
794      io.bytes += retval;
795      retval = rdbSaveLen(rdb,when);
796      if (retval == -1) return -1;
797      io.bytes += retval;
798      mt->aux_save(&io,when);
799      retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
800      if (retval == -1)
801          io.error = 1;
802      else
803          io.bytes += retval;
804      if (io.ctx) {
805          moduleFreeContext(io.ctx);
806          zfree(io.ctx);
807      }
808      if (io.error)
809          return -1;
810      return io.bytes;
811  }
812  int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
813      dictIterator *di = NULL;
814      dictEntry *de;
815      char magic[10];
816      int j;
817      uint64_t cksum;
818      size_t processed = 0;
819      if (server.rdb_checksum)
820          rdb->update_cksum = rioGenericUpdateChecksum;
821      snprintf(magic,sizeof(magic),"REDIS%04d",RDB_VERSION);
822      if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
823      if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;
824      if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;
825      for (j = 0; j < server.dbnum; j++) {
826          redisDb *db = server.db+j;
827          dict *d = db->dict;
828          if (dictSize(d) == 0) continue;
829          di = dictGetSafeIterator(d);
830          if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;
831          if (rdbSaveLen(rdb,j) == -1) goto werr;
832          uint64_t db_size, expires_size;
833          db_size = dictSize(db->dict);
834          expires_size = dictSize(db->expires);
835          if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;
836          if (rdbSaveLen(rdb,db_size) == -1) goto werr;
837          if (rdbSaveLen(rdb,expires_size) == -1) goto werr;
838          while((de = dictNext(di)) != NULL) {
839              sds keystr = dictGetKey(de);
840              robj key, *o = dictGetVal(de);
841              PORT_LONGLONG expire;
842              initStaticStringObject(key,keystr);
843              expire = getExpire(db,&key);
844              if (rdbSaveKeyValuePair(rdb,&key,o,expire) == -1) goto werr;
845              if (flags & RDB_SAVE_AOF_PREAMBLE &&
846                  rdb->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES)
847              {
848                  processed = rdb->processed_bytes;
849                  aofReadDiffFromParent();
850              }
851          }
852          dictReleaseIterator(di);
853          di = NULL; &bsol;* So that we don't release it again on error. */
854      }
855      if (rsi && dictSize(server.lua_scripts)) {
856          di = dictGetIterator(server.lua_scripts);
857          while((de = dictNext(di)) != NULL) {
858              robj *body = dictGetVal(de);
859              if (rdbSaveAuxField(rdb,"lua",3,body->ptr,sdslen(body->ptr)) == -1)
860                  goto werr;
861          }
862          dictReleaseIterator(di);
863          di = NULL; &bsol;* So that we don't release it again on error. */
864      }
865      if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == -1) goto werr;
866      if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;
867      cksum = rdb->cksum;
868      memrev64ifbe(&cksum);
869      if (rioWrite(rdb,&cksum,8) == 0) goto werr;
870      return C_OK;
871  werr:
872      if (error) *error = errno;
873      if (di) dictReleaseIterator(di);
874      return C_ERR;
875  }
876  int rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {
877      char eofmark[RDB_EOF_MARK_SIZE];
878      getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
879      if (error) *error = 0;
880      if (rioWrite(rdb,"$EOF:",5) == 0) goto werr;
881      if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
882      if (rioWrite(rdb,"\r\n",2) == 0) goto werr;
883      if (rdbSaveRio(rdb,error,RDB_SAVE_NONE,rsi) == C_ERR) goto werr;
884      if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
885      return C_OK;
886  werr: &bsol;* Write error. */
887      if (error && *error == 0) *error = errno;
888      return C_ERR;
889  }
890  int rdbSave(char *filename, rdbSaveInfo *rsi) {
891      char tmpfile[256];
892      char cwd[MAXPATHLEN]; &bsol;* Current working dir path for error messages. */
893      FILE *fp;
894      rio rdb;
895      int error = 0;
896      snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());
897      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
898      fp = fopen(tmpfile,IF_WIN32("wb","w"));
899      if (!fp) {
900          char *cwdp = IF_WIN32(_getcwd, getcwd)(cwd, MAXPATHLEN);
901          serverLog(LL_WARNING,
902              "Failed opening the RDB file %s (in server root dir %s) "
903              "for saving: %s",
904              filename,
905              cwdp ? cwdp : "unknown",
906              IF_WIN32(wsa_strerror(errno), strerror(errno)));
907          return C_ERR;
908      }
909      rioInitWithFile(&rdb,fp);
910      if (server.rdb_save_incremental_fsync)
911          rioSetAutoSync(&rdb,REDIS_AUTOSYNC_BYTES);
912      if (rdbSaveRio(&rdb,&error,RDB_SAVE_NONE,rsi) == C_ERR) {
913          errno = error;
914          goto werr;
915      }
916      if (fflush(fp) == EOF) goto werr;
917      if (fsync(fileno(fp)) == -1) goto werr;
918      if (fclose(fp) == EOF) goto werr;
919      if (rename(tmpfile,filename) == -1) {
920          char *cwdp = getcwd(cwd,MAXPATHLEN);
921          serverLog(LL_WARNING,
922              "Error moving temp DB file %s on the final "
923              "destination %s (in server root dir %s): %s",
924              tmpfile,
925              filename,
926              cwdp ? cwdp : "unknown",
927              IF_WIN32(wsa_strerror(errno),strerror(errno)));
928          unlink(tmpfile);
929          return C_ERR;
930      }
931      serverLog(LL_NOTICE,"DB saved on disk");
932      server.dirty = 0;
933      server.lastsave = time(NULL);
934      server.lastbgsave_status = C_OK;
935      return C_OK;
936  werr:
937      serverLog(LL_WARNING,"Write error saving DB on disk: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
938      fclose(fp);
939      unlink(tmpfile);
940      return C_ERR;
941  }
942  int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
943      pid_t childpid;
944      PORT_LONGLONG start;
945      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
946      server.dirty_before_bgsave = server.dirty;
947      server.lastbgsave_try = time(NULL);
948      openChildInfoPipe();
949      start = ustime();
950  #ifdef _WIN32
951      childpid = BeginForkOperation_Rdb(filename, &server, sizeof(server), dictGetHashFunctionSeed(), modules);
952  #else
953      if ((childpid = fork()) == 0) {
954          int retval;
955          closeListeningSockets(0);
956          redisSetProcTitle("redis-rdb-bgsave");
957          retval = rdbSave(filename,rsi);
958          if (retval == C_OK) {
959              size_t private_dirty = zmalloc_get_private_dirty(-1);
960              if (private_dirty) {
961                  serverLog(LL_NOTICE,
962                      "RDB: %zu MB of memory used by copy-on-write",
963                      private_dirty/(1024*1024));
964              }
965              server.child_info_data.cow_size = private_dirty;
966              sendChildInfo(CHILD_INFO_TYPE_RDB);
967          }
968          exitFromChild((retval == C_OK) ? 0 : 1);
969      } else {
970  #endif
971          server.stat_fork_time = ustime()-start;
972  #ifdef _WIN32
973          if (server.stat_fork_time == 0) {
974              server.stat_fork_time = 100000; 
975          }
976  #endif
977          server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
978          latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
979          if (childpid == -1) {
980              closeChildInfoPipe();
981              server.lastbgsave_status = C_ERR;
982              serverLog(LL_WARNING,"Can't save in background: fork: %s",
983                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
984              return C_ERR;
985          }
986          serverLog(LL_NOTICE,"Background saving started by pid %d",childpid);
987          server.rdb_save_time_start = time(NULL);
988          server.rdb_child_pid = childpid;
989          server.rdb_child_type = RDB_CHILD_TYPE_DISK;
990          updateDictResizePolicy();
991          return C_OK;
992  #ifndef _WIN32
993      }
994  #endif
995      return C_OK; &bsol;* unreached */
996  }
997  void rdbRemoveTempFile(pid_t childpid) {
998      char tmpfile[256];
999      snprintf(tmpfile,sizeof(tmpfile),"temp-%d.rdb", (int) childpid);
1000      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
1001      unlink(tmpfile);
1002  }
1003  robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
1004      uint64_t opcode;
1005      while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {
1006          if (opcode == RDB_MODULE_OPCODE_SINT ||
1007              opcode == RDB_MODULE_OPCODE_UINT)
1008          {
1009              uint64_t len;
1010              if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {
1011                  rdbExitReportCorruptRDB(
1012                      "Error reading integer from module %s value", modulename);
1013              }
1014          } else if (opcode == RDB_MODULE_OPCODE_STRING) {
1015              robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
1016              if (o == NULL) {
1017                  rdbExitReportCorruptRDB(
1018                      "Error reading string from module %s value", modulename);
1019              }
1020              decrRefCount(o);
1021          } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {
1022              float val;
1023              if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {
1024                  rdbExitReportCorruptRDB(
1025                      "Error reading float from module %s value", modulename);
1026              }
1027          } else if (opcode == RDB_MODULE_OPCODE_DOUBLE) {
1028              double val;
1029              if (rdbLoadBinaryDoubleValue(rdb,&val) == -1) {
1030                  rdbExitReportCorruptRDB(
1031                      "Error reading double from module %s value", modulename);
1032              }
1033          }
1034      }
1035      return createStringObject("module-dummy-value",18);
1036  }
1037  robj *rdbLoadObject(int rdbtype, rio *rdb, robj *key) {
1038      robj *o = NULL, *ele, *dec;
1039      uint64_t len;
1040      unsigned int i;
1041      if (rdbtype == RDB_TYPE_STRING) {
1042          if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
1043          o = tryObjectEncoding(o);
1044      } else if (rdbtype == RDB_TYPE_LIST) {
1045          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1046          o = createQuicklistObject();
1047          quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
1048                              server.list_compress_depth);
1049          while(len--) {
1050              if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
1051              dec = getDecodedObject(ele);
1052              size_t len = sdslen(dec->ptr);
1053              quicklistPushTail(o->ptr, dec->ptr, len);
1054              decrRefCount(dec);
1055              decrRefCount(ele);
1056          }
1057      } else if (rdbtype == RDB_TYPE_SET) {
1058          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1059          if (len > server.set_max_intset_entries) {
1060              o = createSetObject();
1061              if (len > DICT_HT_INITIAL_SIZE)
1062                  dictExpand(o->ptr,len);
1063          } else {
1064              o = createIntsetObject();
1065          }
1066          for (i = 0; i < len; i++) {
1067              PORT_LONGLONG llval;
1068              sds sdsele;
1069              if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1070                  == NULL) return NULL;
1071              if (o->encoding == OBJ_ENCODING_INTSET) {
1072                  if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {
1073                      o->ptr = intsetAdd(o->ptr,llval,NULL);
1074                  } else {
1075                      setTypeConvert(o,OBJ_ENCODING_HT);
1076                      dictExpand(o->ptr,len);
1077                  }
1078              }
1079              if (o->encoding == OBJ_ENCODING_HT) {
1080                  dictAdd((dict*)o->ptr,sdsele,NULL);
1081              } else {
1082                  sdsfree(sdsele);
1083              }
1084          }
1085      } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {
1086          uint64_t zsetlen;
1087          size_t maxelelen = 0;
1088          zset *zs;
1089          if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1090          o = createZsetObject();
1091          zs = o->ptr;
1092          if (zsetlen > DICT_HT_INITIAL_SIZE)
1093              dictExpand(zs->dict,zsetlen);
1094          while(zsetlen--) {
1095              sds sdsele;
1096              double score;
1097              zskiplistNode *znode;
1098              if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1099                  == NULL) return NULL;
1100              if (rdbtype == RDB_TYPE_ZSET_2) {
1101                  if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) return NULL;
1102              } else {
1103                  if (rdbLoadDoubleValue(rdb,&score) == -1) return NULL;
1104              }
1105              if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);
1106              znode = zslInsert(zs->zsl,score,sdsele);
1107              dictAdd(zs->dict,sdsele,&znode->score);
1108          }
1109          if (zsetLength(o) <= server.zset_max_ziplist_entries &&
1110              maxelelen <= server.zset_max_ziplist_value)
1111                  zsetConvert(o,OBJ_ENCODING_ZIPLIST);
1112      } else if (rdbtype == RDB_TYPE_HASH) {
1113          uint64_t len;
1114          int ret;
1115          sds field, value;
1116          len = rdbLoadLen(rdb, NULL);
1117          if (len == RDB_LENERR) return NULL;
1118          o = createHashObject();
1119          if (len > server.hash_max_ziplist_entries)
1120              hashTypeConvert(o, OBJ_ENCODING_HT);
1121          while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {
1122              len--;
1123              if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1124                  == NULL) return NULL;
1125              if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1126                  == NULL) return NULL;
1127              o->ptr = ziplistPush(o->ptr, (unsigned char*)field,
1128                      sdslen(field), ZIPLIST_TAIL);
1129              o->ptr = ziplistPush(o->ptr, (unsigned char*)value,
1130                      sdslen(value), ZIPLIST_TAIL);
1131              if (sdslen(field) > server.hash_max_ziplist_value ||
1132                  sdslen(value) > server.hash_max_ziplist_value)
1133              {
1134                  sdsfree(field);
1135                  sdsfree(value);
1136                  hashTypeConvert(o, OBJ_ENCODING_HT);
1137                  break;
1138              }
1139              sdsfree(field);
1140              sdsfree(value);
1141          }
1142          if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)
1143              dictExpand(o->ptr,len);
1144          while (o->encoding == OBJ_ENCODING_HT && len > 0) {
1145              len--;
1146              if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1147                  == NULL) return NULL;
1148              if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1149                  == NULL) return NULL;
1150              ret = dictAdd((dict*)o->ptr, field, value);
1151              if (ret == DICT_ERR) {
1152                  rdbExitReportCorruptRDB("Duplicate keys detected");
1153              }
1154          }
1155          serverAssert(len == 0);
1156      } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {
1157          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1158          o = createQuicklistObject();
1159          quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
1160                              server.list_compress_depth);
1161          while (len--) {
1162              unsigned char *zl =
1163                  rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1164              if (zl == NULL) return NULL;
1165              quicklistAppendZiplist(o->ptr, zl);
1166          }
1167      } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||
1168                 rdbtype == RDB_TYPE_LIST_ZIPLIST ||
1169                 rdbtype == RDB_TYPE_SET_INTSET   ||
1170                 rdbtype == RDB_TYPE_ZSET_ZIPLIST ||
1171                 rdbtype == RDB_TYPE_HASH_ZIPLIST)
1172      {
1173          unsigned char *encoded =
1174              rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1175          if (encoded == NULL) return NULL;
1176          o = createObject(OBJ_STRING,encoded); &bsol;* Obj type fixed below. */
1177          switch(rdbtype) {
1178              case RDB_TYPE_HASH_ZIPMAP:
1179                  {
1180                      unsigned char *zl = ziplistNew();
1181                      unsigned char *zi = zipmapRewind(o->ptr);
1182                      unsigned char *fstr, *vstr;
1183                      unsigned int flen, vlen;
1184                      unsigned int maxlen = 0;
1185                      while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {
1186                          if (flen > maxlen) maxlen = flen;
1187                          if (vlen > maxlen) maxlen = vlen;
1188                          zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);
1189                          zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);
1190                      }
1191                      zfree(o->ptr);
1192                      o->ptr = zl;
1193                      o->type = OBJ_HASH;
1194                      o->encoding = OBJ_ENCODING_ZIPLIST;
1195                      if (hashTypeLength(o) > server.hash_max_ziplist_entries ||
1196                          maxlen > server.hash_max_ziplist_value)
1197                      {
1198                          hashTypeConvert(o, OBJ_ENCODING_HT);
1199                      }
1200                  }
1201                  break;
1202              case RDB_TYPE_LIST_ZIPLIST:
1203                  o->type = OBJ_LIST;
1204                  o->encoding = OBJ_ENCODING_ZIPLIST;
1205                  listTypeConvert(o,OBJ_ENCODING_QUICKLIST);
1206                  break;
1207              case RDB_TYPE_SET_INTSET:
1208                  o->type = OBJ_SET;
1209                  o->encoding = OBJ_ENCODING_INTSET;
1210                  if (intsetLen(o->ptr) > server.set_max_intset_entries)
1211                      setTypeConvert(o,OBJ_ENCODING_HT);
1212                  break;
1213              case RDB_TYPE_ZSET_ZIPLIST:
1214                  o->type = OBJ_ZSET;
1215                  o->encoding = OBJ_ENCODING_ZIPLIST;
1216                  if (zsetLength(o) > server.zset_max_ziplist_entries)
1217                      zsetConvert(o,OBJ_ENCODING_SKIPLIST);
1218                  break;
1219              case RDB_TYPE_HASH_ZIPLIST:
1220                  o->type = OBJ_HASH;
1221                  o->encoding = OBJ_ENCODING_ZIPLIST;
1222                  if (hashTypeLength(o) > server.hash_max_ziplist_entries)
1223                      hashTypeConvert(o, OBJ_ENCODING_HT);
1224                  break;
1225              default:
1226                  rdbExitReportCorruptRDB("Unknown RDB encoding type %d",rdbtype);
1227                  break;
1228          }
1229      } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {
1230          o = createStreamObject();
1231          stream *s = o->ptr;
1232          uint64_t listpacks = rdbLoadLen(rdb,NULL);
1233          while(listpacks--) {
1234              sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1235              if (nodekey == NULL) {
1236                  rdbExitReportCorruptRDB("Stream master ID loading failed: invalid encoding or I/O error.");
1237              }
1238              if (sdslen(nodekey) != sizeof(streamID)) {
1239                  rdbExitReportCorruptRDB("Stream node key entry is not the "
1240                                          "size of a stream ID");
1241              }
1242              unsigned char *lp =
1243                  rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1244              if (lp == NULL) return NULL;
1245              unsigned char *first = lpFirst(lp);
1246              if (first == NULL) {
1247                  rdbExitReportCorruptRDB("Empty listpack inside stream");
1248              }
1249              int retval = raxInsert(s->rax,
1250                  (unsigned char*)nodekey,sizeof(streamID),lp,NULL);
1251              sdsfree(nodekey);
1252              if (!retval)
1253                  rdbExitReportCorruptRDB("Listpack re-added with existing key");
1254          }
1255          s->length = rdbLoadLen(rdb,NULL);
1256          s->last_id.ms = rdbLoadLen(rdb,NULL);
1257          s->last_id.seq = rdbLoadLen(rdb,NULL);
1258          size_t cgroups_count = rdbLoadLen(rdb,NULL);
1259          while(cgroups_count--) {
1260              streamID cg_id;
1261              sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1262              if (cgname == NULL) {
1263                  rdbExitReportCorruptRDB(
1264                      "Error reading the consumer group name from Stream");
1265              }
1266              cg_id.ms = rdbLoadLen(rdb,NULL);
1267              cg_id.seq = rdbLoadLen(rdb,NULL);
1268              streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);
1269              if (cgroup == NULL)
1270                  rdbExitReportCorruptRDB("Duplicated consumer group name %s",
1271                                           cgname);
1272              sdsfree(cgname);
1273              size_t pel_size = rdbLoadLen(rdb,NULL);
1274              while(pel_size--) {
1275                  unsigned char rawid[sizeof(streamID)];
1276                  rdbLoadRaw(rdb,rawid,sizeof(rawid));
1277                  streamNACK *nack = streamCreateNACK(NULL);
1278                  nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);
1279                  nack->delivery_count = rdbLoadLen(rdb,NULL);
1280                  if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))
1281                      rdbExitReportCorruptRDB("Duplicated gobal PEL entry "
1282                                              "loading stream consumer group");
1283              }
1284              size_t consumers_num = rdbLoadLen(rdb,NULL);
1285              while(consumers_num--) {
1286                  sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1287                  if (cname == NULL) {
1288                      rdbExitReportCorruptRDB(
1289                          "Error reading the consumer name from Stream group");
1290                  }
1291                  streamConsumer *consumer =
1292                      streamLookupConsumer(cgroup,cname,SLC_NONE);
1293                  sdsfree(cname);
1294                  consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);
1295                  pel_size = rdbLoadLen(rdb,NULL);
1296                  while(pel_size--) {
1297                      unsigned char rawid[sizeof(streamID)];
1298                      rdbLoadRaw(rdb,rawid,sizeof(rawid));
1299                      streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));
1300                      if (nack == raxNotFound)
1301                          rdbExitReportCorruptRDB("Consumer entry not found in "
1302                                                  "group global PEL");
1303                      nack->consumer = consumer;
1304                      if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))
1305                          rdbExitReportCorruptRDB("Duplicated consumer PEL entry "
1306                                                  " loading a stream consumer "
1307                                                  "group");
1308                  }
1309              }
1310          }
1311      } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {
1312          uint64_t moduleid = rdbLoadLen(rdb,NULL);
1313          moduleType *mt = moduleTypeLookupModuleByID(moduleid);
1314          char name[10];
1315          if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {
1316              moduleTypeNameByID(name,moduleid);
1317              return rdbLoadCheckModuleValue(rdb,name);
1318          }
1319          if (mt == NULL) {
1320              moduleTypeNameByID(name,moduleid);
1321              serverLog(LL_WARNING,"The RDB file contains module data I can't load: no matching module '%s'", name);
1322              exit(1);
1323          }
1324          RedisModuleIO io;
1325          moduleInitIOContext(io,mt,rdb,key);
1326          io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;
1327          void *ptr = mt->rdb_load(&io,moduleid&1023);
1328          if (io.ctx) {
1329              moduleFreeContext(io.ctx);
1330              zfree(io.ctx);
1331          }
1332          if (io.ver == 2) {
1333              uint64_t eof = rdbLoadLen(rdb,NULL);
1334              if (eof != RDB_MODULE_OPCODE_EOF) {
1335                  serverLog(LL_WARNING,"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker", name);
1336                  exit(1);
1337              }
1338          }
1339          if (ptr == NULL) {
1340              moduleTypeNameByID(name,moduleid);
1341              serverLog(LL_WARNING,"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
1342              exit(1);
1343          }
1344          o = createModuleObject(mt,ptr);
1345      } else {
1346          rdbExitReportCorruptRDB("Unknown RDB encoding type %d",rdbtype);
1347      }
1348      return o;
1349  }
1350  void startLoading(FILE *fp) {
1351      struct IF_WIN32(_stat64,stat) sb;                                           
1352      server.loading = 1;
1353      server.loading_start_time = time(NULL);
1354      server.loading_loaded_bytes = 0;
1355      if (fstat(fileno(fp), &sb) == -1) {
1356          server.loading_total_bytes = 0;
1357      } else {
1358          server.loading_total_bytes = sb.st_size;
1359      }
1360  }
1361  void loadingProgress(off_t pos) {
1362      server.loading_loaded_bytes = pos;
1363      if (server.stat_peak_memory < zmalloc_used_memory())
1364          server.stat_peak_memory = zmalloc_used_memory();
1365  }
1366  void stopLoading(void) {
1367      server.loading = 0;
1368  }
1369  void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
1370      if (server.rdb_checksum)
1371          rioGenericUpdateChecksum(r, buf, len);
1372      if (server.loading_process_events_interval_bytes &&
1373          (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)
1374      {
1375          updateCachedTime(0);
1376          if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)
1377              replicationSendNewlineToMaster();
1378          loadingProgress((off_t)r->processed_bytes);                             WIN_PORT_FIX &bsol;* cast (off_t) */
1379          processEventsWhileBlocked();
1380      }
1381  }
1382  int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
1383      uint64_t dbid;
1384      int type, rdbver;
1385      redisDb *db = server.db+0;
1386      char buf[1024];
1387      rdb->update_cksum = rdbLoadProgressCallback;
1388      rdb->max_processing_chunk = server.loading_process_events_interval_bytes;
1389      if (rioRead(rdb,buf,9) == 0) goto eoferr;
1390      buf[9] = '\0';
1391      if (memcmp(buf,"REDIS",5) != 0) {
1392          serverLog(LL_WARNING,"Wrong signature trying to load DB from file");
1393          errno = EINVAL;
1394          return C_ERR;
1395      }
1396      rdbver = atoi(buf+5);
1397      if (rdbver < 1 || rdbver > RDB_VERSION) {
1398          serverLog(LL_WARNING,"Can't handle RDB format version %d",rdbver);
1399          errno = EINVAL;
1400          return C_ERR;
1401      }
1402      PORT_LONGLONG lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();
1403      PORT_LONGLONG lru_clock = LRU_CLOCK();
1404      while(1) {
1405          robj *key, *val;
1406          if ((type = rdbLoadType(rdb)) == -1) goto eoferr;
1407          if (type == RDB_OPCODE_EXPIRETIME) {
1408              expiretime = rdbLoadTime(rdb);
1409              expiretime *= 1000;
1410              continue; &bsol;* Read next opcode. */
1411          } else if (type == RDB_OPCODE_EXPIRETIME_MS) {
1412              expiretime = rdbLoadMillisecondTime(rdb,rdbver);
1413              continue; &bsol;* Read next opcode. */
1414          } else if (type == RDB_OPCODE_FREQ) {
1415              uint8_t byte;
1416              if (rioRead(rdb,&byte,1) == 0) goto eoferr;
1417              lfu_freq = byte;
1418              continue; &bsol;* Read next opcode. */
1419          } else if (type == RDB_OPCODE_IDLE) {
1420              uint64_t qword;
1421              if ((qword = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;
1422              lru_idle = qword;
1423              continue; &bsol;* Read next opcode. */
1424          } else if (type == RDB_OPCODE_EOF) {
1425              break;
1426          } else if (type == RDB_OPCODE_SELECTDB) {
1427              if ((dbid = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;
1428              if (dbid >= (unsigned)server.dbnum) {
1429                  serverLog(LL_WARNING,
1430                      "FATAL: Data file was created with a Redis "
1431                      "server configured to handle more than %d "
1432                      "databases. Exiting\n", server.dbnum);
1433                  exit(1);
1434              }
1435              db = server.db+dbid;
1436              continue; &bsol;* Read next opcode. */
1437          } else if (type == RDB_OPCODE_RESIZEDB) {
1438              uint64_t db_size, expires_size;
1439              if ((db_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
1440                  goto eoferr;
1441              if ((expires_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
1442                  goto eoferr;
1443              dictExpand(db->dict,db_size);
1444              dictExpand(db->expires,expires_size);
1445              continue; &bsol;* Read next opcode. */
1446          } else if (type == RDB_OPCODE_AUX) {
1447              robj *auxkey, *auxval;
1448              if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1449              if ((auxval = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1450              if (((char*)auxkey->ptr)[0] == '%') {
1451                  serverLog(LL_NOTICE,"RDB '%s': %s",
1452                      (char*)auxkey->ptr,
1453                      (char*)auxval->ptr);
1454              } else if (!strcasecmp(auxkey->ptr,"repl-stream-db")) {
1455                  if (rsi) rsi->repl_stream_db = atoi(auxval->ptr);
1456              } else if (!strcasecmp(auxkey->ptr,"repl-id")) {
1457                  if (rsi && sdslen(auxval->ptr) == CONFIG_RUN_ID_SIZE) {
1458                      memcpy(rsi->repl_id,auxval->ptr,CONFIG_RUN_ID_SIZE+1);
1459                      rsi->repl_id_is_set = 1;
1460                  }
1461              } else if (!strcasecmp(auxkey->ptr,"repl-offset")) {
1462                  if (rsi) rsi->repl_offset = strtoll(auxval->ptr,NULL,10);
1463              } else if (!strcasecmp(auxkey->ptr,"lua")) {
1464                  if (luaCreateFunction(NULL,server.lua,auxval) == NULL) {
1465                      rdbExitReportCorruptRDB(
1466                          "Can't load Lua script from RDB file! "
1467                          "BODY: %s", auxval->ptr);
1468                  }
1469              } else {
1470                  serverLog(LL_DEBUG,"Unrecognized RDB AUX field: '%s'",
1471                      (char*)auxkey->ptr);
1472              }
1473              decrRefCount(auxkey);
1474              decrRefCount(auxval);
1475              continue; &bsol;* Read type again. */
1476          } else if (type == RDB_OPCODE_MODULE_AUX) {
1477              uint64_t moduleid = rdbLoadLen(rdb,NULL);
1478              int when_opcode = rdbLoadLen(rdb,NULL);
1479              int when = rdbLoadLen(rdb,NULL);
1480              if (when_opcode != RDB_MODULE_OPCODE_UINT)
1481                  rdbExitReportCorruptRDB("bad when_opcode");
<span onclick='openModal()' class='match'>1482              moduleType *mt = moduleTypeLookupModuleByID(moduleid);
1483              char name[10];
1484              moduleTypeNameByID(name,moduleid);
</span>1485              if (!rdbCheckMode && mt == NULL) {
1486                  serverLog(LL_WARNING,"The RDB file contains AUX module data I can't load: no matching module '%s'", name);
1487                  exit(1);
1488              } else if (!rdbCheckMode && mt != NULL) {
1489                  if (!mt->aux_load) {
1490                      serverLog(LL_WARNING,"The RDB file contains module AUX data, but the module '%s' doesn't seem to support it.", name);
1491                      exit(1);
1492                  }
1493                  RedisModuleIO io;
1494                  moduleInitIOContext(io,mt,rdb,NULL);
1495                  io.ver = 2;
1496                  if (mt->aux_load(&io,moduleid&1023, when) || io.error) {
1497                      moduleTypeNameByID(name,moduleid);
1498                      serverLog(LL_WARNING,"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
1499                      exit(1);
1500                  }
1501                  if (io.ctx) {
1502                      moduleFreeContext(io.ctx);
1503                      zfree(io.ctx);
1504                  }
1505                  uint64_t eof = rdbLoadLen(rdb,NULL);
1506                  if (eof != RDB_MODULE_OPCODE_EOF) {
1507                      serverLog(LL_WARNING,"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker", name);
1508                      exit(1);
1509                  }
1510                  continue;
1511              } else {
1512                  robj *aux = rdbLoadCheckModuleValue(rdb,name);
1513                  decrRefCount(aux);
1514                  continue; &bsol;* Read next opcode. */
1515              }
1516          }
1517          if ((key = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1518          if ((val = rdbLoadObject(type,rdb,key)) == NULL) goto eoferr;
1519          if (server.masterhost == NULL && !loading_aof && expiretime != -1 && expiretime < now) {
1520              decrRefCount(key);
1521              decrRefCount(val);
1522          } else {
1523              dbAdd(db,key,val);
1524              if (expiretime != -1) setExpire(NULL,db,key,expiretime);
1525              objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock);
1526              decrRefCount(key);
1527          }
1528          expiretime = -1;
1529          lfu_freq = -1;
1530          lru_idle = -1;
1531      }
1532      if (rdbver >= 5) {
1533          uint64_t cksum, expected = rdb->cksum;
1534          if (rioRead(rdb,&cksum,8) == 0) goto eoferr;
1535          if (server.rdb_checksum) {
1536              memrev64ifbe(&cksum);
1537              if (cksum == 0) {
1538                  serverLog(LL_WARNING,"RDB file was saved with checksum disabled: no check performed.");
1539              } else if (cksum != expected) {
1540                  serverLog(LL_WARNING,"Wrong RDB checksum. Aborting now.");
1541                  rdbExitReportCorruptRDB("RDB CRC error");
1542              }
1543          }
1544      }
1545      return C_OK;
1546  eoferr: &bsol;* unexpected end of file is handled here with a fatal exit */
1547      serverLog(LL_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now.");
1548      rdbExitReportCorruptRDB("Unexpected EOF reading RDB file");
1549      return C_ERR; &bsol;* Just to avoid warning */
1550  }
1551  int rdbLoad(char *filename, rdbSaveInfo *rsi) {
1552      FILE *fp;
1553      rio rdb;
1554      int retval;
1555      if ((fp = fopen(filename,IF_WIN32("rb","r"))) == NULL) return C_ERR;
1556      startLoading(fp);
1557      rioInitWithFile(&rdb,fp);
1558      retval = rdbLoadRio(&rdb,rsi,0);
1559      fclose(fp);
1560      stopLoading();
1561      return retval;
1562  }
1563  void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
1564      if (!bysignal && exitcode == 0) {
1565          serverLog(LL_NOTICE,
1566              "Background saving terminated with success");
1567          server.dirty = server.dirty - server.dirty_before_bgsave;
1568          server.lastsave = time(NULL);
1569          server.lastbgsave_status = C_OK;
1570      } else if (!bysignal && exitcode != 0) {
1571          serverLog(LL_WARNING, "Background saving error");
1572          server.lastbgsave_status = C_ERR;
1573      } else {
1574          mstime_t latency;
1575          serverLog(LL_WARNING,
1576              "Background saving terminated by signal %d", bysignal);
1577          latencyStartMonitor(latency);
1578          rdbRemoveTempFile(server.rdb_child_pid);
1579          latencyEndMonitor(latency);
1580          latencyAddSampleIfNeeded("rdb-unlink-temp-file",latency);
1581          if (bysignal != SIGUSR1)
1582              server.lastbgsave_status = C_ERR;
1583      }
1584      server.rdb_child_pid = -1;
1585      server.rdb_child_type = RDB_CHILD_TYPE_NONE;
1586      server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;
1587      server.rdb_save_time_start = -1;
1588      updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_DISK);
1589  }
1590  void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
1591      uint64_t *ok_slaves;
1592      if (!bysignal && exitcode == 0) {
1593          serverLog(LL_NOTICE,
1594              "Background RDB transfer terminated with success");
1595      } else if (!bysignal && exitcode != 0) {
1596          serverLog(LL_WARNING, "Background transfer error");
1597      } else {
1598          serverLog(LL_WARNING,
1599              "Background transfer terminated by signal %d", bysignal);
1600      }
1601      server.rdb_child_pid = -1;
1602      server.rdb_child_type = RDB_CHILD_TYPE_NONE;
1603      server.rdb_save_time_start = -1;
1604      ok_slaves = zmalloc(sizeof(uint64_t)); &bsol;* Make space for the count. */
1605      ok_slaves[0] = 0;
1606      if (!bysignal && exitcode == 0) {
1607          int readlen = sizeof(uint64_t);
1608          if (read(server.rdb_pipe_read_result_from_child, ok_slaves, readlen) ==
1609                   readlen)
1610          {
1611              readlen = (int)(ok_slaves[0]*sizeof(uint64_t)*2);                   WIN_PORT_FIX &bsol;* cast (int) */
1612              ok_slaves = zrealloc(ok_slaves,sizeof(uint64_t)+readlen);
1613              if (readlen &&
1614                  read(server.rdb_pipe_read_result_from_child, ok_slaves+1,
1615                       readlen) != readlen)
1616              {
1617                  ok_slaves[0] = 0;
1618              }
1619          }
1620      }
1621      close(server.rdb_pipe_read_result_from_child);
1622      close(server.rdb_pipe_write_result_to_parent);
1623      listNode *ln;
1624      listIter li;
1625      listRewind(server.slaves,&li);
1626      while((ln = listNext(&li))) {
1627          client *slave = ln->value;
1628          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
1629              uint64_t j;
1630              int errorcode = 0;
1631              for (j = 0; j < ok_slaves[0]; j++) {
1632                  if (slave->id == ok_slaves[2*j+1]) {
1633                      errorcode = (int)(ok_slaves[2*j+2]);                        WIN_PORT_FIX &bsol;* cast (int) */
1634                      break; &bsol;* Found in slaves list. */
1635                  }
1636              }
1637              if (j == ok_slaves[0] || errorcode != 0) {
1638                  serverLog(LL_WARNING,
1639                  "Closing slave %s: child->slave RDB transfer failed: %s",
1640                      replicationGetSlaveName(slave),
1641                      (errorcode == 0) ? "RDB transfer child aborted"
1642                                       : strerror(errorcode));
1643                  freeClient(slave);
1644              } else {
1645                  serverLog(LL_WARNING,
1646                  "Slave %s correctly received the streamed RDB file.",
1647                      replicationGetSlaveName(slave));
1648                  anetNonBlock(NULL,slave->fd);
1649                  anetSendTimeout(NULL,slave->fd,0);
1650              }
1651          }
1652      }
1653      zfree(ok_slaves);
1654      updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_SOCKET);
1655  }
1656  void backgroundSaveDoneHandler(int exitcode, int bysignal) {
1657      switch(server.rdb_child_type) {
1658      case RDB_CHILD_TYPE_DISK:
1659          backgroundSaveDoneHandlerDisk(exitcode,bysignal);
1660          break;
1661      case RDB_CHILD_TYPE_SOCKET:
1662          backgroundSaveDoneHandlerSocket(exitcode,bysignal);
1663          break;
1664      default:
1665          serverPanic("Unknown RDB child type.");
1666          break;
1667      }
1668  }
1669  int rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {
1670      int *fds;
1671      uint64_t *clientids;
1672      int numfds;
1673      listNode *ln;
1674      listIter li;
1675      pid_t childpid;
1676      PORT_LONGLONG start;
1677      int pipefds[2];
1678      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
1679      if (pipe(pipefds) == -1) return C_ERR;
1680      server.rdb_pipe_read_result_from_child = pipefds[0];
1681      server.rdb_pipe_write_result_to_parent = pipefds[1];
1682      fds = zmalloc(sizeof(int)*listLength(server.slaves));
1683      clientids = zmalloc(sizeof(uint64_t)*listLength(server.slaves));
1684      numfds = 0;
1685      listRewind(server.slaves,&li);
1686      while((ln = listNext(&li))) {
1687          client *slave = ln->value;
1688          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
1689              clientids[numfds] = slave->id;
1690              fds[numfds++] = slave->fd;
1691              replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());
1692              anetBlock(NULL,slave->fd);
1693              anetSendTimeout(NULL,slave->fd,(PORT_ULONG)server.repl_timeout*1000);  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1694          }
1695      }
1696      openChildInfoPipe();
1697      start = ustime();
1698  #ifdef _WIN32
1699      childpid = BeginForkOperation_Socket(fds, numfds, clientids, pipefds[1], &server, sizeof(server), dictGetHashFunctionSeed(), modules);
1700  #else
1701      if ((childpid = fork()) == 0) {
1702          int retval;
1703          rio slave_sockets;
1704          rioInitWithFdset(&slave_sockets,fds,numfds);
1705          zfree(fds);
1706          closeListeningSockets(0);
1707          redisSetProcTitle("redis-rdb-to-slaves");
1708          retval = rdbSaveRioWithEOFMark(&slave_sockets,NULL,rsi);
1709          if (retval == C_OK && rioFlush(&slave_sockets) == 0)
1710              retval = C_ERR;
1711          if (retval == C_OK) {
1712              size_t private_dirty = zmalloc_get_private_dirty(-1);
1713              if (private_dirty) {
1714                  serverLog(LL_NOTICE,
1715                      "RDB: %zu MB of memory used by copy-on-write",
1716                      private_dirty/(1024*1024));
1717              }
1718              server.child_info_data.cow_size = private_dirty;
1719              sendChildInfo(CHILD_INFO_TYPE_RDB);
1720              void *msg = zmalloc(sizeof(uint64_t)*(1+2*numfds));
1721              uint64_t *len = msg;
1722              uint64_t *ids = len+1;
1723              int j, msglen;
1724              *len = numfds;
1725              for (j = 0; j < numfds; j++) {
1726                  *ids++ = clientids[j];
1727                  *ids++ = slave_sockets.io.fdset.state[j];
1728              }
1729              msglen = sizeof(uint64_t)*(1+2*numfds);
1730              if (*len == 0 ||
1731                  write(server.rdb_pipe_write_result_to_parent,msg,msglen)
1732                  != msglen)
1733              {
1734                  retval = C_ERR;
1735              }
1736              zfree(msg);
1737          }
1738          zfree(clientids);
1739          rioFreeFdset(&slave_sockets);
1740          exitFromChild((retval == C_OK) ? 0 : 1);
1741      } else {
1742  #endif
1743          if (childpid == -1) {
1744              serverLog(LL_WARNING,"Can't save in background: fork: %s",
1745                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
1746              listRewind(server.slaves,&li);
1747              while((ln = listNext(&li))) {
1748                  client *slave = ln->value;
1749                  int j;
1750                  for (j = 0; j < numfds; j++) {
1751                      if (slave->id == clientids[j]) {
1752                          slave->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
1753                          break;
1754                      }
1755                  }
1756              }
1757              close(pipefds[0]);
1758              close(pipefds[1]);
1759              closeChildInfoPipe();
1760          } else {
1761              server.stat_fork_time = ustime()-start;
1762  #ifdef _WIN32
1763              if (server.stat_fork_time == 0) {
1764                  server.stat_fork_time = 100000; 
1765              }
1766  #endif
1767              server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
1768              latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
1769              serverLog(LL_NOTICE,"Background RDB transfer started by pid %d",
1770                  childpid);
1771              server.rdb_save_time_start = time(NULL);
1772              server.rdb_child_pid = childpid;
1773              server.rdb_child_type = RDB_CHILD_TYPE_SOCKET;
1774              updateDictResizePolicy();
1775          }
1776          zfree(clientids);
1777          zfree(fds);
1778          return (childpid == -1) ? C_ERR : C_OK;
1779  #ifndef _WIN32
1780      }
1781  #endif
1782      return C_OK; &bsol;* Unreached. */
1783  }
1784  void saveCommand(client *c) {
1785      if (server.rdb_child_pid != -1) {
1786          addReplyError(c,"Background save already in progress");
1787          return;
1788      }
1789      rdbSaveInfo rsi, *rsiptr;
1790      rsiptr = rdbPopulateSaveInfo(&rsi);
1791      if (rdbSave(server.rdb_filename,rsiptr) == C_OK) {
1792          addReply(c,shared.ok);
1793      } else {
1794          addReply(c,shared.err);
1795      }
1796  }
1797  void bgsaveCommand(client *c) {
1798      int schedule = 0;
1799      if (c->argc > 1) {
1800          if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"schedule")) {
1801              schedule = 1;
1802          } else {
1803              addReply(c,shared.syntaxerr);
1804              return;
1805          }
1806      }
1807      rdbSaveInfo rsi, *rsiptr;
1808      rsiptr = rdbPopulateSaveInfo(&rsi);
1809      if (server.rdb_child_pid != -1) {
1810          addReplyError(c,"Background save already in progress");
1811      } else if (server.aof_child_pid != -1) {
1812          if (schedule) {
1813              server.rdb_bgsave_scheduled = 1;
1814              addReplyStatus(c,"Background saving scheduled");
1815          } else {
1816              addReplyError(c,
1817                  "An AOF log rewriting in progress: can't BGSAVE right now. "
1818                  "Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever "
1819                  "possible.");
1820          }
1821      } else if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK) {
1822          addReplyStatus(c,"Background saving started");
1823      } else {
1824          addReply(c,shared.err);
1825      }
1826  }
1827  rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
1828      rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;
1829      *rsi = rsi_init;
1830      if (!server.masterhost && server.repl_backlog) {
1831          rsi->repl_stream_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;
1832          return rsi;
1833      }
1834      if (server.master) {
1835          rsi->repl_stream_db = server.master->db->id;
1836          return rsi;
1837      }
1838      if (server.cached_master) {
1839          rsi->repl_stream_db = server.cached_master->db->id;
1840          return rsi;
1841      }
1842      return NULL;
1843  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rdb.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/win32_types.h"
3  #include "Win32_Interop/Win32_Error.h"
4  #endif
5  #include "server.h"
6  #include "lzf.h"    &bsol;* LZF compression library */
7  #include "zipmap.h"
8  #include "endianconv.h"
9  #include "stream.h"
10  #include <math.h>
11  #include <sys/types.h>
12  #ifdef _WIN32
13  #include <stdio.h>
14  #include "Win32_Interop/Win32_QFork.h"
15  #include <direct.h>
16  #define MAXPATHLEN 1024
17  #else
18  #include <sys/time.h>
19  #include <sys/resource.h>
20  #include <sys/wait.h>
21  #include <arpa/inet.h>
22  #endif
23  #include <sys/stat.h>
24  #ifndef _WIN32
25  #include <sys/param.h>
26  #endif
27  #define rdbExitReportCorruptRDB(...) rdbCheckThenExit(__LINE__,__VA_ARGS__)
28  extern int rdbCheckMode;
29  void rdbCheckError(const char *fmt, ...);
30  void rdbCheckSetError(const char *fmt, ...);
31  WIN32_ONLY(__declspec(noreturn))
32  void rdbCheckThenExit(int linenum, char *reason, ...) {
33      va_list ap;
34      char msg[1024];
35      int len;
36      len = snprintf(msg,sizeof(msg),
37          "Internal error in RDB reading function at rdb.c:%d -> ", linenum);
38      va_start(ap,reason);
39      vsnprintf(msg+len,sizeof(msg)-len,reason,ap);
40      va_end(ap);
41      if (!rdbCheckMode) {
42          serverLog(LL_WARNING, "%s", msg);
43          char *argv[2] = {"",server.rdb_filename};
44          redis_check_rdb_main(2,argv,NULL);
45      } else {
46          rdbCheckError("%s",msg);
47      }
48      exit(1);
49  }
50  static int rdbWriteRaw(rio *rdb, void *p, size_t len) {
51      if (rdb && rioWrite(rdb,p,len) == 0)
52          return -1;
53      return (int)len;                  WIN_PORT_FIX &bsol;* cast (int) */
54  }
55  void rdbLoadRaw(rio *rdb, void *buf, uint64_t len) {
56      if (rioRead(rdb,buf,len) == 0) {
57          rdbExitReportCorruptRDB(
58              "Impossible to read %llu bytes in rdbLoadRaw()",
59              (PORT_ULONGLONG) len);
60          return; &bsol;* Not reached. */
61      }
62  }
63  int rdbSaveType(rio *rdb, unsigned char type) {
64      return rdbWriteRaw(rdb,&type,1);
65  }
66  int rdbLoadType(rio *rdb) {
67      unsigned char type;
68      if (rioRead(rdb,&type,1) == 0) return -1;
69      return type;
70  }
71  time_t rdbLoadTime(rio *rdb) {
72      int32_t t32;
73      rdbLoadRaw(rdb,&t32,4);
74      return (time_t)t32;
75  }
76  int rdbSaveMillisecondTime(rio *rdb, PORT_LONGLONG t) {
77      int64_t t64 = (int64_t) t;
78      memrev64ifbe(&t64); &bsol;* Store in little endian. */
79      return rdbWriteRaw(rdb,&t64,8);
80  }
81  PORT_LONGLONG rdbLoadMillisecondTime(rio *rdb, int rdbver) {
82      int64_t t64;
83      rdbLoadRaw(rdb,&t64,8);
84      if (rdbver >= 9) &bsol;* Check the top comment of this function. */
85          memrev64ifbe(&t64); &bsol;* Convert in big endian if the system is BE. */
86      return (PORT_LONGLONG)t64;
87  }
88  int rdbSaveLen(rio *rdb, uint64_t len) {
89      unsigned char buf[2];
90      size_t nwritten;
91      if (len < (1<<6)) {
92          buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);
93          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
94          nwritten = 1;
95      } else if (len < (1<<14)) {
96          buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
97          buf[1] = len&0xFF;
98          if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
99          nwritten = 2;
100      } else if (len <= UINT32_MAX) {
101          buf[0] = RDB_32BITLEN;
102          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
103          uint32_t len32 = htonl(len);
104          if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;
105          nwritten = 1+4;
106      } else {
107          buf[0] = RDB_64BITLEN;
108          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
109          len = htonu64(len);
110          if (rdbWriteRaw(rdb,&len,8) == -1) return -1;
111          nwritten = 1+8;
112      }
113      return (int)nwritten;                                                       WIN_PORT_FIX &bsol;* cast (int) */
114  }
115  int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
116      unsigned char buf[2];
117      int type;
118      if (isencoded) *isencoded = 0;
119      if (rioRead(rdb,buf,1) == 0) return -1;
120      type = (buf[0]&0xC0)>>6;
121      if (type == RDB_ENCVAL) {
122          if (isencoded) *isencoded = 1;
123          *lenptr = buf[0]&0x3F;
124      } else if (type == RDB_6BITLEN) {
125          *lenptr = buf[0]&0x3F;
126      } else if (type == RDB_14BITLEN) {
127          if (rioRead(rdb,buf+1,1) == 0) return -1;
128          *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
129      } else if (buf[0] == RDB_32BITLEN) {
130          uint32_t len;
131          if (rioRead(rdb,&len,4) == 0) return -1;
132          *lenptr = ntohl(len);
133      } else if (buf[0] == RDB_64BITLEN) {
134          uint64_t len;
135          if (rioRead(rdb,&len,8) == 0) return -1;
136          *lenptr = ntohu64(len);
137      } else {
138          rdbExitReportCorruptRDB(
139              "Unknown length encoding %d in rdbLoadLen()",type);
140          return -1; &bsol;* Never reached. */
141      }
142      return 0;
143  }
144  uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
145      uint64_t len;
146      if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
147      return len;
148  }
149  int rdbEncodeInteger(PORT_LONGLONG value, unsigned char *enc) {
150      if (value >= -(1<<7) && value <= (1<<7)-1) {
151          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;
152          enc[1] = value&0xFF;
153          return 2;
154      } else if (value >= -(1<<15) && value <= (1<<15)-1) {
155          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;
156          enc[1] = value&0xFF;
157          enc[2] = (value>>8)&0xFF;
158          return 3;
159      } else if (value >= -((PORT_LONGLONG)1<<31) && value <= ((PORT_LONGLONG)1<<31)-1) {
160          enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;
161          enc[1] = value&0xFF;
162          enc[2] = (value>>8)&0xFF;
163          enc[3] = (value>>16)&0xFF;
164          enc[4] = (value>>24)&0xFF;
165          return 5;
166      } else {
167          return 0;
168      }
169  }
170  void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {
171      int plain = flags & RDB_LOAD_PLAIN;
172      int sds = flags & RDB_LOAD_SDS;
173      int encode = flags & RDB_LOAD_ENC;
174      unsigned char enc[4];
175      PORT_LONGLONG val;
176      if (enctype == RDB_ENC_INT8) {
177          if (rioRead(rdb,enc,1) == 0) return NULL;
178          val = (signed char)enc[0];
179      } else if (enctype == RDB_ENC_INT16) {
180          uint16_t v;
181          if (rioRead(rdb,enc,2) == 0) return NULL;
182          v = enc[0]|(enc[1]<<8);
183          val = (int16_t)v;
184      } else if (enctype == RDB_ENC_INT32) {
185          uint32_t v;
186          if (rioRead(rdb,enc,4) == 0) return NULL;
187          v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);
188          val = (int32_t)v;
189      } else {
190          val = 0; &bsol;* anti-warning */
191          rdbExitReportCorruptRDB("Unknown RDB integer encoding type %d",enctype);
192      }
193      if (plain || sds) {
194          char buf[LONG_STR_SIZE], *p;
195          int len = ll2string(buf,sizeof(buf),val);
196          if (lenptr) *lenptr = len;
197          p = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);
198          memcpy(p,buf,len);
199          return p;
200      } else if (encode) {
201          return createStringObjectFromLongLongForValue(val);
202      } else {
203          return createObject(OBJ_STRING,sdsfromlonglong(val));
204      }
205  }
206  int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
207      PORT_LONGLONG value;
208      char *endptr, buf[32];
209      value = strtoll(s, &endptr, 10);
210      if (endptr[0] != '\0') return 0;
211      ll2string(buf,32,value);
212      if (strlen(buf) != len || memcmp(buf,s,len)) return 0;
213      return rdbEncodeInteger(value,enc);
214  }
215  ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
216                         size_t original_len) {
217      unsigned char byte;
218      ssize_t n, nwritten = 0;
219      byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;
220      if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;
221      nwritten += n;
222      if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;
223      nwritten += n;
224      if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;
225      nwritten += n;
226      if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
227      nwritten += n;
228      return nwritten;
229  writeerr:
230      return -1;
231  }
232  ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
233      size_t comprlen, outlen;
234      void *out;
235      if (len <= 4) return 0;
236      outlen = len-4;
237      if ((out = zmalloc(outlen+1)) == NULL) return 0;
238      comprlen = lzf_compress(s, len, out, outlen);
239      if (comprlen == 0) {
240          zfree(out);
241          return 0;
242      }
243      ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
244      zfree(out);
245      return nwritten;
246  }
247  void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {
248      int plain = flags & RDB_LOAD_PLAIN;
249      int sds = flags & RDB_LOAD_SDS;
250      uint64_t len, clen;
251      unsigned char *c = NULL;
252      char *val = NULL;
253      if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
254      if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
255      if ((c = zmalloc(clen)) == NULL) goto err;
256      if (plain) {
257          val = zmalloc(len);
258      } else {
259          val = sdsnewlen(SDS_NOINIT,len);
260      }
261      if (lenptr) *lenptr = len;
262      if (rioRead(rdb,c,clen) == 0) goto err;
263      if (lzf_decompress(c,clen,val,len) == 0) {
264          if (rdbCheckMode) rdbCheckSetError("Invalid LZF compressed string");
265          goto err;
266      }
267      zfree(c);
268      if (plain || sds) {
269          return val;
270      } else {
271          return createObject(OBJ_STRING,val);
272      }
273  err:
274      zfree(c);
275      if (plain)
276          zfree(val);
277      else
278          sdsfree(val);
279      return NULL;
280  }
281  ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
282      int enclen;
283      ssize_t n, nwritten = 0;
284      if (len <= 11) {
285          unsigned char buf[5];
286          if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
287              if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
288              return enclen;
289          }
290      }
291      if (server.rdb_compression && len > 20) {
292          n = rdbSaveLzfStringObject(rdb,s,len);
293          if (n == -1) return -1;
294          if (n > 0) return n;
295      }
296      if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
297      nwritten += n;
298      if (len > 0) {
299          if (rdbWriteRaw(rdb,s,len) == -1) return -1;
300          nwritten += len;
301      }
302      return nwritten;
303  }
304  ssize_t rdbSaveLongLongAsStringObject(rio *rdb, PORT_LONGLONG value) {
305      unsigned char buf[32];
306      ssize_t n, nwritten = 0;
307      int enclen = rdbEncodeInteger(value,buf);
308      if (enclen > 0) {
309          return rdbWriteRaw(rdb,buf,enclen);
310      } else {
311          enclen = ll2string((char*)buf,32,value);
312          serverAssert(enclen < 32);
313          if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;
314          nwritten += n;
315          if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
316          nwritten += n;
317      }
318      return nwritten;
319  }
320  ssize_t rdbSaveStringObject(rio *rdb, robj *obj) {
321      if (obj->encoding == OBJ_ENCODING_INT) {
322          return rdbSaveLongLongAsStringObject(rdb,(PORT_LONG)obj->ptr);
323      } else {
324          serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));
325          return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));
326      }
327  }
328  void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
329      int encode = flags & RDB_LOAD_ENC;
330      int plain = flags & RDB_LOAD_PLAIN;
331      int sds = flags & RDB_LOAD_SDS;
332      int isencoded;
333      uint64_t len;
334      len = rdbLoadLen(rdb,&isencoded);
335      if (isencoded) {
336          switch(len) {
337          case RDB_ENC_INT8:
338          case RDB_ENC_INT16:
339          case RDB_ENC_INT32:
340              return rdbLoadIntegerObject(rdb,len,flags,lenptr);
341          case RDB_ENC_LZF:
342              return rdbLoadLzfStringObject(rdb,flags,lenptr);
343          default:
344              rdbExitReportCorruptRDB("Unknown RDB string encoding type %d",len);
345          }
346      }
347      if (len == RDB_LENERR) return NULL;
348      if (plain || sds) {
349          void *buf = plain ? zmalloc(len) : sdsnewlen(SDS_NOINIT,len);
350          if (lenptr) *lenptr = len;
351          if (len && rioRead(rdb,buf,len) == 0) {
352              if (plain)
353                  zfree(buf);
354              else
355                  sdsfree(buf);
356              return NULL;
357          }
358          return buf;
359      } else {
360          robj *o = encode ? createStringObject(SDS_NOINIT,len) :
361                             createRawStringObject(SDS_NOINIT,len);
362          if (len && rioRead(rdb,o->ptr,len) == 0) {
363              decrRefCount(o);
364              return NULL;
365          }
366          return o;
367      }
368  }
369  robj *rdbLoadStringObject(rio *rdb) {
370      return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
371  }
372  robj *rdbLoadEncodedStringObject(rio *rdb) {
373      return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
374  }
375  int rdbSaveDoubleValue(rio *rdb, double val) {
376      unsigned char buf[128];
377      int len;
378      if (isnan(val)) {
379          buf[0] = 253;
380          len = 1;
381      } else if (!isfinite(val)) {
382          len = 1;
383          buf[0] = (val < 0) ? 255 : 254;
384      } else {
385  #if (DBL_MANT_DIG >= 52) && (LLONG_MAX == 0x7fffffffffffffffLL)
386          double min = -4503599627370495; &bsol;* (2^52)-1 */
387          double max = 4503599627370496; &bsol;* -(2^52) */
388          if (val > min && val < max && val == ((double)((PORT_LONGLONG)val)))
389              ll2string((char*)buf+1,sizeof(buf)-1,(PORT_LONGLONG)val);
390          else
391  #endif
392              snprintf((char*)buf+1,sizeof(buf)-1,"%.17g",val);
393          buf[0] = (unsigned char)strlen((char*)buf+1);                           WIN_PORT_FIX &bsol;* cast (unsigned char) */
394          len = buf[0]+1;
395      }
396      return rdbWriteRaw(rdb,buf,len);
397  }
398  int rdbLoadDoubleValue(rio *rdb, double *val) {
399      char buf[256];
400      unsigned char len;
401  #ifdef _WIN32
402      double scannedVal = 0;
403      int assigned = 0;
404      memset(buf, 0, sizeof(buf));
405  #endif
406      if (rioRead(rdb,&len,1) == 0) return -1;
407      switch(len) {
408      case 255: *val = R_NegInf; return 0;
409      case 254: *val = R_PosInf; return 0;
410      case 253: *val = R_Nan; return 0;
411      default:
412          if (rioRead(rdb,buf,len) == 0) return -1;
413          buf[len] = '\0';
414  #ifdef _WIN32
415          assigned = sscanf_s(buf, "%lg", &scannedVal);
416          if( assigned != 0 ) {
417              (*val) = scannedVal;
418              return 0;
419          } else {
420              return -1;
421          }
422  #else
423          sscanf(buf, "%lg", val);
424          return 0;
425  #endif
426      }
427  }
428  int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
429      memrev64ifbe(&val);
430      return rdbWriteRaw(rdb,&val,sizeof(val));
431  }
432  int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
433      if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
434      memrev64ifbe(val);
435      return 0;
436  }
437  int rdbSaveBinaryFloatValue(rio *rdb, float val) {
438      memrev32ifbe(&val);
439      return rdbWriteRaw(rdb,&val,sizeof(val));
440  }
441  int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
442      if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
443      memrev32ifbe(val);
444      return 0;
445  }
446  int rdbSaveObjectType(rio *rdb, robj *o) {
447      switch (o->type) {
448      case OBJ_STRING:
449          return rdbSaveType(rdb,RDB_TYPE_STRING);
450      case OBJ_LIST:
451          if (o->encoding == OBJ_ENCODING_QUICKLIST)
452              return rdbSaveType(rdb,RDB_TYPE_LIST_QUICKLIST);
453          else
454              serverPanic("Unknown list encoding");
455      case OBJ_SET:
456          if (o->encoding == OBJ_ENCODING_INTSET)
457              return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);
458          else if (o->encoding == OBJ_ENCODING_HT)
459              return rdbSaveType(rdb,RDB_TYPE_SET);
460          else
461              serverPanic("Unknown set encoding");
462      case OBJ_ZSET:
463          if (o->encoding == OBJ_ENCODING_ZIPLIST)
464              return rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);
465          else if (o->encoding == OBJ_ENCODING_SKIPLIST)
466              return rdbSaveType(rdb,RDB_TYPE_ZSET_2);
467          else
468              serverPanic("Unknown sorted set encoding");
469      case OBJ_HASH:
470          if (o->encoding == OBJ_ENCODING_ZIPLIST)
471              return rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);
472          else if (o->encoding == OBJ_ENCODING_HT)
473              return rdbSaveType(rdb,RDB_TYPE_HASH);
474          else
475              serverPanic("Unknown hash encoding");
476      case OBJ_STREAM:
477          return rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS);
478      case OBJ_MODULE:
479          return rdbSaveType(rdb,RDB_TYPE_MODULE_2);
480      default:
481          serverPanic("Unknown object type");
482      }
483      return -1; &bsol;* avoid warning */
484  }
485  int rdbLoadObjectType(rio *rdb) {
486      int type;
487      if ((type = rdbLoadType(rdb)) == -1) return -1;
488      if (!rdbIsObjectType(type)) return -1;
489      return type;
490  }
491  ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
492      ssize_t n, nwritten = 0;
493      if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
494      nwritten += n;
495      raxIterator ri;
496      raxStart(&ri,pel);
497      raxSeek(&ri,"^",NULL,0);
498      while(raxNext(&ri)) {
499          if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) return -1;
500          nwritten += n;
501          if (nacks) {
502              streamNACK *nack = ri.data;
503              if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1)
504                  return -1;
505              nwritten += n;
506              if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) return -1;
507              nwritten += n;
508          }
509      }
510      raxStop(&ri);
511      return nwritten;
512  }
513  size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
514      ssize_t n, nwritten = 0;
515      if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
516      nwritten += n;
517      raxIterator ri;
518      raxStart(&ri,cg->consumers);
519      raxSeek(&ri,"^",NULL,0);
520      while(raxNext(&ri)) {
521          streamConsumer *consumer = ri.data;
522          if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
523          nwritten += n;
524          if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1)
525              return -1;
526          nwritten += n;
527          if ((n = rdbSaveStreamPEL(rdb,consumer->pel,0)) == -1)
528              return -1;
529          nwritten += n;
530      }
531      raxStop(&ri);
532      return nwritten;
533  }
534  ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key) {
535      ssize_t n = 0, nwritten = 0;
536      if (o->type == OBJ_STRING) {
537          if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;
538          nwritten += n;
539      } else if (o->type == OBJ_LIST) {
540          if (o->encoding == OBJ_ENCODING_QUICKLIST) {
541              quicklist *ql = o->ptr;
542              quicklistNode *node = ql->head;
543              if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;
544              nwritten += n;
545              while(node) {
546                  if (quicklistNodeIsCompressed(node)) {
547                      void *data;
548                      size_t compress_len = quicklistGetLzf(node, &data);
549                      if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;
550                      nwritten += n;
551                  } else {
552                      if ((n = rdbSaveRawString(rdb,node->zl,node->sz)) == -1) return -1;
553                      nwritten += n;
554                  }
555                  node = node->next;
556              }
557          } else {
558              serverPanic("Unknown list encoding");
559          }
560      } else if (o->type == OBJ_SET) {
561          if (o->encoding == OBJ_ENCODING_HT) {
562              dict *set = o->ptr;
563              dictIterator *di = dictGetIterator(set);
564              dictEntry *de;
565              if ((n = rdbSaveLen(rdb,dictSize(set))) == -1) {
566                  dictReleaseIterator(di);
567                  return -1;
568              }
569              nwritten += n;
570              while((de = dictNext(di)) != NULL) {
571                  sds ele = dictGetKey(de);
572                  if ((n = rdbSaveRawString(rdb,(unsigned char*)ele,sdslen(ele)))
573                      == -1)
574                  {
575                      dictReleaseIterator(di);
576                      return -1;
577                  }
578                  nwritten += n;
579              }
580              dictReleaseIterator(di);
581          } else if (o->encoding == OBJ_ENCODING_INTSET) {
582              size_t l = intsetBlobLen((intset*)o->ptr);
583              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
584              nwritten += n;
585          } else {
586              serverPanic("Unknown set encoding");
587          }
588      } else if (o->type == OBJ_ZSET) {
589          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
590              size_t l = ziplistBlobLen((unsigned char*)o->ptr);
591              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
592              nwritten += n;
593          } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
594              zset *zs = o->ptr;
595              zskiplist *zsl = zs->zsl;
596              if ((n = rdbSaveLen(rdb,zsl->length)) == -1) return -1;
597              nwritten += n;
598              zskiplistNode *zn = zsl->tail;
599              while (zn != NULL) {
600                  if ((n = rdbSaveRawString(rdb,
601                      (unsigned char*)zn->ele,sdslen(zn->ele))) == -1)
602                  {
603                      return -1;
604                  }
605                  nwritten += n;
606                  if ((n = rdbSaveBinaryDoubleValue(rdb,zn->score)) == -1)
607                      return -1;
608                  nwritten += n;
609                  zn = zn->backward;
610              }
611          } else {
612              serverPanic("Unknown sorted set encoding");
613          }
614      } else if (o->type == OBJ_HASH) {
615          if (o->encoding == OBJ_ENCODING_ZIPLIST) {
616              size_t l = ziplistBlobLen((unsigned char*)o->ptr);
617              if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
618              nwritten += n;
619          } else if (o->encoding == OBJ_ENCODING_HT) {
620              dictIterator *di = dictGetIterator(o->ptr);
621              dictEntry *de;
622              if ((n = rdbSaveLen(rdb,dictSize((dict*)o->ptr))) == -1) {
623                  dictReleaseIterator(di);
624                  return -1;
625              }
626              nwritten += n;
627              while((de = dictNext(di)) != NULL) {
628                  sds field = dictGetKey(de);
629                  sds value = dictGetVal(de);
630                  if ((n = rdbSaveRawString(rdb,(unsigned char*)field,
631                          sdslen(field))) == -1)
632                  {
633                      dictReleaseIterator(di);
634                      return -1;
635                  }
636                  nwritten += n;
637                  if ((n = rdbSaveRawString(rdb,(unsigned char*)value,
638                          sdslen(value))) == -1)
639                  {
640                      dictReleaseIterator(di);
641                      return -1;
642                  }
643                  nwritten += n;
644              }
645              dictReleaseIterator(di);
646          } else {
647              serverPanic("Unknown hash encoding");
648          }
649      } else if (o->type == OBJ_STREAM) {
650          stream *s = o->ptr;
651          rax *rax = s->rax;
652          if ((n = rdbSaveLen(rdb,raxSize(rax))) == -1) return -1;
653          nwritten += n;
654          raxIterator ri;
655          raxStart(&ri,rax);
656          raxSeek(&ri,"^",NULL,0);
657          while (raxNext(&ri)) {
658              unsigned char *lp = ri.data;
659              size_t lp_bytes = lpBytes(lp);
660              if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) return -1;
661              nwritten += n;
662              if ((n = rdbSaveRawString(rdb,lp,lp_bytes)) == -1) return -1;
663              nwritten += n;
664          }
665          raxStop(&ri);
666          if ((n = rdbSaveLen(rdb,s->length)) == -1) return -1;
667          nwritten += n;
668          if ((n = rdbSaveLen(rdb,s->last_id.ms)) == -1) return -1;
669          nwritten += n;
670          if ((n = rdbSaveLen(rdb,s->last_id.seq)) == -1) return -1;
671          nwritten += n;
672          size_t num_cgroups = s->cgroups ? raxSize(s->cgroups) : 0;
673          if ((n = rdbSaveLen(rdb,num_cgroups)) == -1) return -1;
674          nwritten += n;
675          if (num_cgroups) {
676              raxStart(&ri,s->cgroups);
677              raxSeek(&ri,"^",NULL,0);
678              while(raxNext(&ri)) {
679                  streamCG *cg = ri.data;
680                  if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1)
681                      return -1;
682                  nwritten += n;
683                  if ((n = rdbSaveLen(rdb,cg->last_id.ms)) == -1) return -1;
684                  nwritten += n;
685                  if ((n = rdbSaveLen(rdb,cg->last_id.seq)) == -1) return -1;
686                  nwritten += n;
687                  if ((n = rdbSaveStreamPEL(rdb,cg->pel,1)) == -1) return -1;
688                  nwritten += n;
689                  if ((n = rdbSaveStreamConsumers(rdb,cg)) == -1) return -1;
690                  nwritten += n;
691              }
692              raxStop(&ri);
693          }
694      } else if (o->type == OBJ_MODULE) {
695          RedisModuleIO io;
696          moduleValue *mv = o->ptr;
697          moduleType *mt = mv->type;
698          int retval = rdbSaveLen(rdb,mt->id);
699          if (retval == -1) return -1;
700          moduleInitIOContext(io,mt,rdb,key);
701          io.bytes += retval;
702          mt->rdb_save(&io,mv->value);
703          retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
704          if (retval == -1)
705              io.error = 1;
706          else
707              io.bytes += retval;
708          if (io.ctx) {
709              moduleFreeContext(io.ctx);
710              zfree(io.ctx);
711          }
712          return io.error ? -1 : (ssize_t)io.bytes;
713      } else {
714          serverPanic("Unknown object type");
715      }
716      return nwritten;
717  }
718  size_t rdbSavedObjectLen(robj *o) {
719      ssize_t len = rdbSaveObject(NULL,o,NULL);
720      serverAssertWithInfo(NULL,o,len != -1);
721      return len;
722  }
723  int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, PORT_LONGLONG expiretime) {
724      int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;
725      int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;
726      if (expiretime != -1) {
727          if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
728          if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
729      }
730      if (savelru) {
731          uint64_t idletime = estimateObjectIdleTime(val);
732          idletime /= 1000; &bsol;* Using seconds is enough and requires less space.*/
733          if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
734          if (rdbSaveLen(rdb,idletime) == -1) return -1;
735      }
736      if (savelfu) {
737          uint8_t buf[1];
738          buf[0] = LFUDecrAndReturn(val);
739          if (rdbSaveType(rdb,RDB_OPCODE_FREQ) == -1) return -1;
740          if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
741      }
742      if (rdbSaveObjectType(rdb,val) == -1) return -1;
743      if (rdbSaveStringObject(rdb,key) == -1) return -1;
744      if (rdbSaveObject(rdb,val,key) == -1) return -1;
745      return 1;
746  }
747  ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
748      ssize_t ret, len = 0;
749      if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
750      len += ret;
751      if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
752      len += ret;
753      if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
754      len += ret;
755      return len;
756  }
757  ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
758      return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
759  }
760  ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, PORT_LONGLONG val) {
761      char buf[LONG_STR_SIZE];
762      int vlen = ll2string(buf,sizeof(buf),val);
763      return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
764  }
765  int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) {
766      int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
767      int aof_preamble = (flags & RDB_SAVE_AOF_PREAMBLE) != 0;
768      if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) return -1;
769      if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) return -1;
770      if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) return -1;
771      if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) return -1;
772      if (rsi) {
773          if (rdbSaveAuxFieldStrInt(rdb,"repl-stream-db",rsi->repl_stream_db)
774              == -1) return -1;
775          if (rdbSaveAuxFieldStrStr(rdb,"repl-id",server.replid)
776              == -1) return -1;
777          if (rdbSaveAuxFieldStrInt(rdb,"repl-offset",server.master_repl_offset)
778              == -1) return -1;
779      }
780      if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) return -1;
781      return 1;
782  }
783  ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
784      RedisModuleIO io;
785      int retval = rdbSaveType(rdb, RDB_OPCODE_MODULE_AUX);
786      if (retval == -1) return -1;
787      moduleInitIOContext(io,mt,rdb,NULL);                           WIN_PORT_FIX &bsol;*moved earlier before first usage of "io"*/
788      io.bytes += retval;
789      retval = rdbSaveLen(rdb,mt->id);
790      if (retval == -1) return -1;
791      io.bytes += retval;
792      retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_UINT);
793      if (retval == -1) return -1;
794      io.bytes += retval;
795      retval = rdbSaveLen(rdb,when);
796      if (retval == -1) return -1;
797      io.bytes += retval;
798      mt->aux_save(&io,when);
799      retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
800      if (retval == -1)
801          io.error = 1;
802      else
803          io.bytes += retval;
804      if (io.ctx) {
805          moduleFreeContext(io.ctx);
806          zfree(io.ctx);
807      }
808      if (io.error)
809          return -1;
810      return io.bytes;
811  }
812  int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
813      dictIterator *di = NULL;
814      dictEntry *de;
815      char magic[10];
816      int j;
817      uint64_t cksum;
818      size_t processed = 0;
819      if (server.rdb_checksum)
820          rdb->update_cksum = rioGenericUpdateChecksum;
821      snprintf(magic,sizeof(magic),"REDIS%04d",RDB_VERSION);
822      if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
823      if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;
824      if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;
825      for (j = 0; j < server.dbnum; j++) {
826          redisDb *db = server.db+j;
827          dict *d = db->dict;
828          if (dictSize(d) == 0) continue;
829          di = dictGetSafeIterator(d);
830          if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;
831          if (rdbSaveLen(rdb,j) == -1) goto werr;
832          uint64_t db_size, expires_size;
833          db_size = dictSize(db->dict);
834          expires_size = dictSize(db->expires);
835          if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;
836          if (rdbSaveLen(rdb,db_size) == -1) goto werr;
837          if (rdbSaveLen(rdb,expires_size) == -1) goto werr;
838          while((de = dictNext(di)) != NULL) {
839              sds keystr = dictGetKey(de);
840              robj key, *o = dictGetVal(de);
841              PORT_LONGLONG expire;
842              initStaticStringObject(key,keystr);
843              expire = getExpire(db,&key);
844              if (rdbSaveKeyValuePair(rdb,&key,o,expire) == -1) goto werr;
845              if (flags & RDB_SAVE_AOF_PREAMBLE &&
846                  rdb->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES)
847              {
848                  processed = rdb->processed_bytes;
849                  aofReadDiffFromParent();
850              }
851          }
852          dictReleaseIterator(di);
853          di = NULL; &bsol;* So that we don't release it again on error. */
854      }
855      if (rsi && dictSize(server.lua_scripts)) {
856          di = dictGetIterator(server.lua_scripts);
857          while((de = dictNext(di)) != NULL) {
858              robj *body = dictGetVal(de);
859              if (rdbSaveAuxField(rdb,"lua",3,body->ptr,sdslen(body->ptr)) == -1)
860                  goto werr;
861          }
862          dictReleaseIterator(di);
863          di = NULL; &bsol;* So that we don't release it again on error. */
864      }
865      if (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == -1) goto werr;
866      if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;
867      cksum = rdb->cksum;
868      memrev64ifbe(&cksum);
869      if (rioWrite(rdb,&cksum,8) == 0) goto werr;
870      return C_OK;
871  werr:
872      if (error) *error = errno;
873      if (di) dictReleaseIterator(di);
874      return C_ERR;
875  }
876  int rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {
877      char eofmark[RDB_EOF_MARK_SIZE];
878      getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
879      if (error) *error = 0;
880      if (rioWrite(rdb,"$EOF:",5) == 0) goto werr;
881      if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
882      if (rioWrite(rdb,"\r\n",2) == 0) goto werr;
883      if (rdbSaveRio(rdb,error,RDB_SAVE_NONE,rsi) == C_ERR) goto werr;
884      if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
885      return C_OK;
886  werr: &bsol;* Write error. */
887      if (error && *error == 0) *error = errno;
888      return C_ERR;
889  }
890  int rdbSave(char *filename, rdbSaveInfo *rsi) {
891      char tmpfile[256];
892      char cwd[MAXPATHLEN]; &bsol;* Current working dir path for error messages. */
893      FILE *fp;
894      rio rdb;
895      int error = 0;
896      snprintf(tmpfile,256,"temp-%d.rdb", (int) getpid());
897      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
898      fp = fopen(tmpfile,IF_WIN32("wb","w"));
899      if (!fp) {
900          char *cwdp = IF_WIN32(_getcwd, getcwd)(cwd, MAXPATHLEN);
901          serverLog(LL_WARNING,
902              "Failed opening the RDB file %s (in server root dir %s) "
903              "for saving: %s",
904              filename,
905              cwdp ? cwdp : "unknown",
906              IF_WIN32(wsa_strerror(errno), strerror(errno)));
907          return C_ERR;
908      }
909      rioInitWithFile(&rdb,fp);
910      if (server.rdb_save_incremental_fsync)
911          rioSetAutoSync(&rdb,REDIS_AUTOSYNC_BYTES);
912      if (rdbSaveRio(&rdb,&error,RDB_SAVE_NONE,rsi) == C_ERR) {
913          errno = error;
914          goto werr;
915      }
916      if (fflush(fp) == EOF) goto werr;
917      if (fsync(fileno(fp)) == -1) goto werr;
918      if (fclose(fp) == EOF) goto werr;
919      if (rename(tmpfile,filename) == -1) {
920          char *cwdp = getcwd(cwd,MAXPATHLEN);
921          serverLog(LL_WARNING,
922              "Error moving temp DB file %s on the final "
923              "destination %s (in server root dir %s): %s",
924              tmpfile,
925              filename,
926              cwdp ? cwdp : "unknown",
927              IF_WIN32(wsa_strerror(errno),strerror(errno)));
928          unlink(tmpfile);
929          return C_ERR;
930      }
931      serverLog(LL_NOTICE,"DB saved on disk");
932      server.dirty = 0;
933      server.lastsave = time(NULL);
934      server.lastbgsave_status = C_OK;
935      return C_OK;
936  werr:
937      serverLog(LL_WARNING,"Write error saving DB on disk: %s", IF_WIN32(wsa_strerror(errno),strerror(errno)));
938      fclose(fp);
939      unlink(tmpfile);
940      return C_ERR;
941  }
942  int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
943      pid_t childpid;
944      PORT_LONGLONG start;
945      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
946      server.dirty_before_bgsave = server.dirty;
947      server.lastbgsave_try = time(NULL);
948      openChildInfoPipe();
949      start = ustime();
950  #ifdef _WIN32
951      childpid = BeginForkOperation_Rdb(filename, &server, sizeof(server), dictGetHashFunctionSeed(), modules);
952  #else
953      if ((childpid = fork()) == 0) {
954          int retval;
955          closeListeningSockets(0);
956          redisSetProcTitle("redis-rdb-bgsave");
957          retval = rdbSave(filename,rsi);
958          if (retval == C_OK) {
959              size_t private_dirty = zmalloc_get_private_dirty(-1);
960              if (private_dirty) {
961                  serverLog(LL_NOTICE,
962                      "RDB: %zu MB of memory used by copy-on-write",
963                      private_dirty/(1024*1024));
964              }
965              server.child_info_data.cow_size = private_dirty;
966              sendChildInfo(CHILD_INFO_TYPE_RDB);
967          }
968          exitFromChild((retval == C_OK) ? 0 : 1);
969      } else {
970  #endif
971          server.stat_fork_time = ustime()-start;
972  #ifdef _WIN32
973          if (server.stat_fork_time == 0) {
974              server.stat_fork_time = 100000; 
975          }
976  #endif
977          server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
978          latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
979          if (childpid == -1) {
980              closeChildInfoPipe();
981              server.lastbgsave_status = C_ERR;
982              serverLog(LL_WARNING,"Can't save in background: fork: %s",
983                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
984              return C_ERR;
985          }
986          serverLog(LL_NOTICE,"Background saving started by pid %d",childpid);
987          server.rdb_save_time_start = time(NULL);
988          server.rdb_child_pid = childpid;
989          server.rdb_child_type = RDB_CHILD_TYPE_DISK;
990          updateDictResizePolicy();
991          return C_OK;
992  #ifndef _WIN32
993      }
994  #endif
995      return C_OK; &bsol;* unreached */
996  }
997  void rdbRemoveTempFile(pid_t childpid) {
998      char tmpfile[256];
999      snprintf(tmpfile,sizeof(tmpfile),"temp-%d.rdb", (int) childpid);
1000      WIN32_ONLY(tmpfile[sizeof(tmpfile) - 1] = 0;) &bsol;*get rid of C6053 warning*/
1001      unlink(tmpfile);
1002  }
1003  robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
1004      uint64_t opcode;
1005      while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {
1006          if (opcode == RDB_MODULE_OPCODE_SINT ||
1007              opcode == RDB_MODULE_OPCODE_UINT)
1008          {
1009              uint64_t len;
1010              if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {
1011                  rdbExitReportCorruptRDB(
1012                      "Error reading integer from module %s value", modulename);
1013              }
1014          } else if (opcode == RDB_MODULE_OPCODE_STRING) {
1015              robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
1016              if (o == NULL) {
1017                  rdbExitReportCorruptRDB(
1018                      "Error reading string from module %s value", modulename);
1019              }
1020              decrRefCount(o);
1021          } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {
1022              float val;
1023              if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {
1024                  rdbExitReportCorruptRDB(
1025                      "Error reading float from module %s value", modulename);
1026              }
1027          } else if (opcode == RDB_MODULE_OPCODE_DOUBLE) {
1028              double val;
1029              if (rdbLoadBinaryDoubleValue(rdb,&val) == -1) {
1030                  rdbExitReportCorruptRDB(
1031                      "Error reading double from module %s value", modulename);
1032              }
1033          }
1034      }
1035      return createStringObject("module-dummy-value",18);
1036  }
1037  robj *rdbLoadObject(int rdbtype, rio *rdb, robj *key) {
1038      robj *o = NULL, *ele, *dec;
1039      uint64_t len;
1040      unsigned int i;
1041      if (rdbtype == RDB_TYPE_STRING) {
1042          if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
1043          o = tryObjectEncoding(o);
1044      } else if (rdbtype == RDB_TYPE_LIST) {
1045          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1046          o = createQuicklistObject();
1047          quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
1048                              server.list_compress_depth);
1049          while(len--) {
1050              if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
1051              dec = getDecodedObject(ele);
1052              size_t len = sdslen(dec->ptr);
1053              quicklistPushTail(o->ptr, dec->ptr, len);
1054              decrRefCount(dec);
1055              decrRefCount(ele);
1056          }
1057      } else if (rdbtype == RDB_TYPE_SET) {
1058          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1059          if (len > server.set_max_intset_entries) {
1060              o = createSetObject();
1061              if (len > DICT_HT_INITIAL_SIZE)
1062                  dictExpand(o->ptr,len);
1063          } else {
1064              o = createIntsetObject();
1065          }
1066          for (i = 0; i < len; i++) {
1067              PORT_LONGLONG llval;
1068              sds sdsele;
1069              if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1070                  == NULL) return NULL;
1071              if (o->encoding == OBJ_ENCODING_INTSET) {
1072                  if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {
1073                      o->ptr = intsetAdd(o->ptr,llval,NULL);
1074                  } else {
1075                      setTypeConvert(o,OBJ_ENCODING_HT);
1076                      dictExpand(o->ptr,len);
1077                  }
1078              }
1079              if (o->encoding == OBJ_ENCODING_HT) {
1080                  dictAdd((dict*)o->ptr,sdsele,NULL);
1081              } else {
1082                  sdsfree(sdsele);
1083              }
1084          }
1085      } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {
1086          uint64_t zsetlen;
1087          size_t maxelelen = 0;
1088          zset *zs;
1089          if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1090          o = createZsetObject();
1091          zs = o->ptr;
1092          if (zsetlen > DICT_HT_INITIAL_SIZE)
1093              dictExpand(zs->dict,zsetlen);
1094          while(zsetlen--) {
1095              sds sdsele;
1096              double score;
1097              zskiplistNode *znode;
1098              if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1099                  == NULL) return NULL;
1100              if (rdbtype == RDB_TYPE_ZSET_2) {
1101                  if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) return NULL;
1102              } else {
1103                  if (rdbLoadDoubleValue(rdb,&score) == -1) return NULL;
1104              }
1105              if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);
1106              znode = zslInsert(zs->zsl,score,sdsele);
1107              dictAdd(zs->dict,sdsele,&znode->score);
1108          }
1109          if (zsetLength(o) <= server.zset_max_ziplist_entries &&
1110              maxelelen <= server.zset_max_ziplist_value)
1111                  zsetConvert(o,OBJ_ENCODING_ZIPLIST);
1112      } else if (rdbtype == RDB_TYPE_HASH) {
1113          uint64_t len;
1114          int ret;
1115          sds field, value;
1116          len = rdbLoadLen(rdb, NULL);
1117          if (len == RDB_LENERR) return NULL;
1118          o = createHashObject();
1119          if (len > server.hash_max_ziplist_entries)
1120              hashTypeConvert(o, OBJ_ENCODING_HT);
1121          while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {
1122              len--;
1123              if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1124                  == NULL) return NULL;
1125              if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1126                  == NULL) return NULL;
1127              o->ptr = ziplistPush(o->ptr, (unsigned char*)field,
1128                      sdslen(field), ZIPLIST_TAIL);
1129              o->ptr = ziplistPush(o->ptr, (unsigned char*)value,
1130                      sdslen(value), ZIPLIST_TAIL);
1131              if (sdslen(field) > server.hash_max_ziplist_value ||
1132                  sdslen(value) > server.hash_max_ziplist_value)
1133              {
1134                  sdsfree(field);
1135                  sdsfree(value);
1136                  hashTypeConvert(o, OBJ_ENCODING_HT);
1137                  break;
1138              }
1139              sdsfree(field);
1140              sdsfree(value);
1141          }
1142          if (o->encoding == OBJ_ENCODING_HT && len > DICT_HT_INITIAL_SIZE)
1143              dictExpand(o->ptr,len);
1144          while (o->encoding == OBJ_ENCODING_HT && len > 0) {
1145              len--;
1146              if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1147                  == NULL) return NULL;
1148              if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
1149                  == NULL) return NULL;
1150              ret = dictAdd((dict*)o->ptr, field, value);
1151              if (ret == DICT_ERR) {
1152                  rdbExitReportCorruptRDB("Duplicate keys detected");
1153              }
1154          }
1155          serverAssert(len == 0);
1156      } else if (rdbtype == RDB_TYPE_LIST_QUICKLIST) {
1157          if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
1158          o = createQuicklistObject();
1159          quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
1160                              server.list_compress_depth);
1161          while (len--) {
1162              unsigned char *zl =
1163                  rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1164              if (zl == NULL) return NULL;
1165              quicklistAppendZiplist(o->ptr, zl);
1166          }
1167      } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||
1168                 rdbtype == RDB_TYPE_LIST_ZIPLIST ||
1169                 rdbtype == RDB_TYPE_SET_INTSET   ||
1170                 rdbtype == RDB_TYPE_ZSET_ZIPLIST ||
1171                 rdbtype == RDB_TYPE_HASH_ZIPLIST)
1172      {
1173          unsigned char *encoded =
1174              rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1175          if (encoded == NULL) return NULL;
1176          o = createObject(OBJ_STRING,encoded); &bsol;* Obj type fixed below. */
1177          switch(rdbtype) {
1178              case RDB_TYPE_HASH_ZIPMAP:
1179                  {
1180                      unsigned char *zl = ziplistNew();
1181                      unsigned char *zi = zipmapRewind(o->ptr);
1182                      unsigned char *fstr, *vstr;
1183                      unsigned int flen, vlen;
1184                      unsigned int maxlen = 0;
1185                      while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {
1186                          if (flen > maxlen) maxlen = flen;
1187                          if (vlen > maxlen) maxlen = vlen;
1188                          zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);
1189                          zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);
1190                      }
1191                      zfree(o->ptr);
1192                      o->ptr = zl;
1193                      o->type = OBJ_HASH;
1194                      o->encoding = OBJ_ENCODING_ZIPLIST;
1195                      if (hashTypeLength(o) > server.hash_max_ziplist_entries ||
1196                          maxlen > server.hash_max_ziplist_value)
1197                      {
1198                          hashTypeConvert(o, OBJ_ENCODING_HT);
1199                      }
1200                  }
1201                  break;
1202              case RDB_TYPE_LIST_ZIPLIST:
1203                  o->type = OBJ_LIST;
1204                  o->encoding = OBJ_ENCODING_ZIPLIST;
1205                  listTypeConvert(o,OBJ_ENCODING_QUICKLIST);
1206                  break;
1207              case RDB_TYPE_SET_INTSET:
1208                  o->type = OBJ_SET;
1209                  o->encoding = OBJ_ENCODING_INTSET;
1210                  if (intsetLen(o->ptr) > server.set_max_intset_entries)
1211                      setTypeConvert(o,OBJ_ENCODING_HT);
1212                  break;
1213              case RDB_TYPE_ZSET_ZIPLIST:
1214                  o->type = OBJ_ZSET;
1215                  o->encoding = OBJ_ENCODING_ZIPLIST;
1216                  if (zsetLength(o) > server.zset_max_ziplist_entries)
1217                      zsetConvert(o,OBJ_ENCODING_SKIPLIST);
1218                  break;
1219              case RDB_TYPE_HASH_ZIPLIST:
1220                  o->type = OBJ_HASH;
1221                  o->encoding = OBJ_ENCODING_ZIPLIST;
1222                  if (hashTypeLength(o) > server.hash_max_ziplist_entries)
1223                      hashTypeConvert(o, OBJ_ENCODING_HT);
1224                  break;
1225              default:
1226                  rdbExitReportCorruptRDB("Unknown RDB encoding type %d",rdbtype);
1227                  break;
1228          }
1229      } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {
1230          o = createStreamObject();
1231          stream *s = o->ptr;
1232          uint64_t listpacks = rdbLoadLen(rdb,NULL);
1233          while(listpacks--) {
1234              sds nodekey = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1235              if (nodekey == NULL) {
1236                  rdbExitReportCorruptRDB("Stream master ID loading failed: invalid encoding or I/O error.");
1237              }
1238              if (sdslen(nodekey) != sizeof(streamID)) {
1239                  rdbExitReportCorruptRDB("Stream node key entry is not the "
1240                                          "size of a stream ID");
1241              }
1242              unsigned char *lp =
1243                  rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
1244              if (lp == NULL) return NULL;
1245              unsigned char *first = lpFirst(lp);
1246              if (first == NULL) {
1247                  rdbExitReportCorruptRDB("Empty listpack inside stream");
1248              }
1249              int retval = raxInsert(s->rax,
1250                  (unsigned char*)nodekey,sizeof(streamID),lp,NULL);
1251              sdsfree(nodekey);
1252              if (!retval)
1253                  rdbExitReportCorruptRDB("Listpack re-added with existing key");
1254          }
1255          s->length = rdbLoadLen(rdb,NULL);
1256          s->last_id.ms = rdbLoadLen(rdb,NULL);
1257          s->last_id.seq = rdbLoadLen(rdb,NULL);
1258          size_t cgroups_count = rdbLoadLen(rdb,NULL);
1259          while(cgroups_count--) {
1260              streamID cg_id;
1261              sds cgname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1262              if (cgname == NULL) {
1263                  rdbExitReportCorruptRDB(
1264                      "Error reading the consumer group name from Stream");
1265              }
1266              cg_id.ms = rdbLoadLen(rdb,NULL);
1267              cg_id.seq = rdbLoadLen(rdb,NULL);
1268              streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);
1269              if (cgroup == NULL)
1270                  rdbExitReportCorruptRDB("Duplicated consumer group name %s",
1271                                           cgname);
1272              sdsfree(cgname);
1273              size_t pel_size = rdbLoadLen(rdb,NULL);
1274              while(pel_size--) {
1275                  unsigned char rawid[sizeof(streamID)];
1276                  rdbLoadRaw(rdb,rawid,sizeof(rawid));
1277                  streamNACK *nack = streamCreateNACK(NULL);
1278                  nack->delivery_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);
1279                  nack->delivery_count = rdbLoadLen(rdb,NULL);
1280                  if (!raxInsert(cgroup->pel,rawid,sizeof(rawid),nack,NULL))
1281                      rdbExitReportCorruptRDB("Duplicated gobal PEL entry "
1282                                              "loading stream consumer group");
1283              }
1284              size_t consumers_num = rdbLoadLen(rdb,NULL);
1285              while(consumers_num--) {
1286                  sds cname = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL);
1287                  if (cname == NULL) {
1288                      rdbExitReportCorruptRDB(
1289                          "Error reading the consumer name from Stream group");
1290                  }
1291                  streamConsumer *consumer =
1292                      streamLookupConsumer(cgroup,cname,SLC_NONE);
1293                  sdsfree(cname);
1294                  consumer->seen_time = rdbLoadMillisecondTime(rdb,RDB_VERSION);
1295                  pel_size = rdbLoadLen(rdb,NULL);
1296                  while(pel_size--) {
1297                      unsigned char rawid[sizeof(streamID)];
1298                      rdbLoadRaw(rdb,rawid,sizeof(rawid));
1299                      streamNACK *nack = raxFind(cgroup->pel,rawid,sizeof(rawid));
1300                      if (nack == raxNotFound)
1301                          rdbExitReportCorruptRDB("Consumer entry not found in "
1302                                                  "group global PEL");
1303                      nack->consumer = consumer;
1304                      if (!raxInsert(consumer->pel,rawid,sizeof(rawid),nack,NULL))
1305                          rdbExitReportCorruptRDB("Duplicated consumer PEL entry "
1306                                                  " loading a stream consumer "
1307                                                  "group");
1308                  }
1309              }
1310          }
1311      } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {
1312          uint64_t moduleid = rdbLoadLen(rdb,NULL);
1313          moduleType *mt = moduleTypeLookupModuleByID(moduleid);
1314          char name[10];
1315          if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2) {
1316              moduleTypeNameByID(name,moduleid);
1317              return rdbLoadCheckModuleValue(rdb,name);
1318          }
1319          if (mt == NULL) {
1320              moduleTypeNameByID(name,moduleid);
1321              serverLog(LL_WARNING,"The RDB file contains module data I can't load: no matching module '%s'", name);
1322              exit(1);
1323          }
1324          RedisModuleIO io;
1325          moduleInitIOContext(io,mt,rdb,key);
1326          io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;
1327          void *ptr = mt->rdb_load(&io,moduleid&1023);
1328          if (io.ctx) {
1329              moduleFreeContext(io.ctx);
1330              zfree(io.ctx);
1331          }
1332          if (io.ver == 2) {
1333              uint64_t eof = rdbLoadLen(rdb,NULL);
1334              if (eof != RDB_MODULE_OPCODE_EOF) {
1335                  serverLog(LL_WARNING,"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker", name);
1336                  exit(1);
1337              }
1338          }
1339          if (ptr == NULL) {
1340              moduleTypeNameByID(name,moduleid);
1341              serverLog(LL_WARNING,"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
1342              exit(1);
1343          }
1344          o = createModuleObject(mt,ptr);
1345      } else {
1346          rdbExitReportCorruptRDB("Unknown RDB encoding type %d",rdbtype);
1347      }
1348      return o;
1349  }
1350  void startLoading(FILE *fp) {
1351      struct IF_WIN32(_stat64,stat) sb;                                           
1352      server.loading = 1;
1353      server.loading_start_time = time(NULL);
1354      server.loading_loaded_bytes = 0;
1355      if (fstat(fileno(fp), &sb) == -1) {
1356          server.loading_total_bytes = 0;
1357      } else {
1358          server.loading_total_bytes = sb.st_size;
1359      }
1360  }
1361  void loadingProgress(off_t pos) {
1362      server.loading_loaded_bytes = pos;
1363      if (server.stat_peak_memory < zmalloc_used_memory())
1364          server.stat_peak_memory = zmalloc_used_memory();
1365  }
1366  void stopLoading(void) {
1367      server.loading = 0;
1368  }
1369  void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
1370      if (server.rdb_checksum)
1371          rioGenericUpdateChecksum(r, buf, len);
1372      if (server.loading_process_events_interval_bytes &&
1373          (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)
1374      {
1375          updateCachedTime(0);
1376          if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)
1377              replicationSendNewlineToMaster();
1378          loadingProgress((off_t)r->processed_bytes);                             WIN_PORT_FIX &bsol;* cast (off_t) */
1379          processEventsWhileBlocked();
1380      }
1381  }
1382  int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi, int loading_aof) {
1383      uint64_t dbid;
1384      int type, rdbver;
1385      redisDb *db = server.db+0;
1386      char buf[1024];
1387      rdb->update_cksum = rdbLoadProgressCallback;
1388      rdb->max_processing_chunk = server.loading_process_events_interval_bytes;
1389      if (rioRead(rdb,buf,9) == 0) goto eoferr;
1390      buf[9] = '\0';
1391      if (memcmp(buf,"REDIS",5) != 0) {
1392          serverLog(LL_WARNING,"Wrong signature trying to load DB from file");
1393          errno = EINVAL;
1394          return C_ERR;
1395      }
1396      rdbver = atoi(buf+5);
1397      if (rdbver < 1 || rdbver > RDB_VERSION) {
1398          serverLog(LL_WARNING,"Can't handle RDB format version %d",rdbver);
1399          errno = EINVAL;
1400          return C_ERR;
1401      }
1402      PORT_LONGLONG lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();
1403      PORT_LONGLONG lru_clock = LRU_CLOCK();
1404      while(1) {
1405          robj *key, *val;
1406          if ((type = rdbLoadType(rdb)) == -1) goto eoferr;
1407          if (type == RDB_OPCODE_EXPIRETIME) {
1408              expiretime = rdbLoadTime(rdb);
1409              expiretime *= 1000;
1410              continue; &bsol;* Read next opcode. */
1411          } else if (type == RDB_OPCODE_EXPIRETIME_MS) {
1412              expiretime = rdbLoadMillisecondTime(rdb,rdbver);
1413              continue; &bsol;* Read next opcode. */
1414          } else if (type == RDB_OPCODE_FREQ) {
1415              uint8_t byte;
1416              if (rioRead(rdb,&byte,1) == 0) goto eoferr;
1417              lfu_freq = byte;
1418              continue; &bsol;* Read next opcode. */
1419          } else if (type == RDB_OPCODE_IDLE) {
1420              uint64_t qword;
1421              if ((qword = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;
1422              lru_idle = qword;
1423              continue; &bsol;* Read next opcode. */
1424          } else if (type == RDB_OPCODE_EOF) {
1425              break;
1426          } else if (type == RDB_OPCODE_SELECTDB) {
1427              if ((dbid = rdbLoadLen(rdb,NULL)) == RDB_LENERR) goto eoferr;
1428              if (dbid >= (unsigned)server.dbnum) {
1429                  serverLog(LL_WARNING,
1430                      "FATAL: Data file was created with a Redis "
1431                      "server configured to handle more than %d "
1432                      "databases. Exiting\n", server.dbnum);
1433                  exit(1);
1434              }
1435              db = server.db+dbid;
1436              continue; &bsol;* Read next opcode. */
1437          } else if (type == RDB_OPCODE_RESIZEDB) {
1438              uint64_t db_size, expires_size;
1439              if ((db_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
1440                  goto eoferr;
1441              if ((expires_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
1442                  goto eoferr;
1443              dictExpand(db->dict,db_size);
1444              dictExpand(db->expires,expires_size);
1445              continue; &bsol;* Read next opcode. */
1446          } else if (type == RDB_OPCODE_AUX) {
1447              robj *auxkey, *auxval;
1448              if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1449              if ((auxval = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1450              if (((char*)auxkey->ptr)[0] == '%') {
1451                  serverLog(LL_NOTICE,"RDB '%s': %s",
1452                      (char*)auxkey->ptr,
1453                      (char*)auxval->ptr);
1454              } else if (!strcasecmp(auxkey->ptr,"repl-stream-db")) {
1455                  if (rsi) rsi->repl_stream_db = atoi(auxval->ptr);
1456              } else if (!strcasecmp(auxkey->ptr,"repl-id")) {
1457                  if (rsi && sdslen(auxval->ptr) == CONFIG_RUN_ID_SIZE) {
1458                      memcpy(rsi->repl_id,auxval->ptr,CONFIG_RUN_ID_SIZE+1);
1459                      rsi->repl_id_is_set = 1;
1460                  }
1461              } else if (!strcasecmp(auxkey->ptr,"repl-offset")) {
1462                  if (rsi) rsi->repl_offset = strtoll(auxval->ptr,NULL,10);
1463              } else if (!strcasecmp(auxkey->ptr,"lua")) {
1464                  if (luaCreateFunction(NULL,server.lua,auxval) == NULL) {
1465                      rdbExitReportCorruptRDB(
1466                          "Can't load Lua script from RDB file! "
1467                          "BODY: %s", auxval->ptr);
1468                  }
1469              } else {
1470                  serverLog(LL_DEBUG,"Unrecognized RDB AUX field: '%s'",
1471                      (char*)auxkey->ptr);
1472              }
1473              decrRefCount(auxkey);
1474              decrRefCount(auxval);
1475              continue; &bsol;* Read type again. */
1476          } else if (type == RDB_OPCODE_MODULE_AUX) {
1477              uint64_t moduleid = rdbLoadLen(rdb,NULL);
1478              int when_opcode = rdbLoadLen(rdb,NULL);
1479              int when = rdbLoadLen(rdb,NULL);
1480              if (when_opcode != RDB_MODULE_OPCODE_UINT)
1481                  rdbExitReportCorruptRDB("bad when_opcode");
<span onclick='openModal()' class='match'>1482              moduleType *mt = moduleTypeLookupModuleByID(moduleid);
1483              char name[10];
1484              moduleTypeNameByID(name,moduleid);
</span>1485              if (!rdbCheckMode && mt == NULL) {
1486                  serverLog(LL_WARNING,"The RDB file contains AUX module data I can't load: no matching module '%s'", name);
1487                  exit(1);
1488              } else if (!rdbCheckMode && mt != NULL) {
1489                  if (!mt->aux_load) {
1490                      serverLog(LL_WARNING,"The RDB file contains module AUX data, but the module '%s' doesn't seem to support it.", name);
1491                      exit(1);
1492                  }
1493                  RedisModuleIO io;
1494                  moduleInitIOContext(io,mt,rdb,NULL);
1495                  io.ver = 2;
1496                  if (mt->aux_load(&io,moduleid&1023, when) || io.error) {
1497                      moduleTypeNameByID(name,moduleid);
1498                      serverLog(LL_WARNING,"The RDB file contains module AUX data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
1499                      exit(1);
1500                  }
1501                  if (io.ctx) {
1502                      moduleFreeContext(io.ctx);
1503                      zfree(io.ctx);
1504                  }
1505                  uint64_t eof = rdbLoadLen(rdb,NULL);
1506                  if (eof != RDB_MODULE_OPCODE_EOF) {
1507                      serverLog(LL_WARNING,"The RDB file contains module AUX data for the module '%s' that is not terminated by the proper module value EOF marker", name);
1508                      exit(1);
1509                  }
1510                  continue;
1511              } else {
1512                  robj *aux = rdbLoadCheckModuleValue(rdb,name);
1513                  decrRefCount(aux);
1514                  continue; &bsol;* Read next opcode. */
1515              }
1516          }
1517          if ((key = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
1518          if ((val = rdbLoadObject(type,rdb,key)) == NULL) goto eoferr;
1519          if (server.masterhost == NULL && !loading_aof && expiretime != -1 && expiretime < now) {
1520              decrRefCount(key);
1521              decrRefCount(val);
1522          } else {
1523              dbAdd(db,key,val);
1524              if (expiretime != -1) setExpire(NULL,db,key,expiretime);
1525              objectSetLRUOrLFU(val,lfu_freq,lru_idle,lru_clock);
1526              decrRefCount(key);
1527          }
1528          expiretime = -1;
1529          lfu_freq = -1;
1530          lru_idle = -1;
1531      }
1532      if (rdbver >= 5) {
1533          uint64_t cksum, expected = rdb->cksum;
1534          if (rioRead(rdb,&cksum,8) == 0) goto eoferr;
1535          if (server.rdb_checksum) {
1536              memrev64ifbe(&cksum);
1537              if (cksum == 0) {
1538                  serverLog(LL_WARNING,"RDB file was saved with checksum disabled: no check performed.");
1539              } else if (cksum != expected) {
1540                  serverLog(LL_WARNING,"Wrong RDB checksum. Aborting now.");
1541                  rdbExitReportCorruptRDB("RDB CRC error");
1542              }
1543          }
1544      }
1545      return C_OK;
1546  eoferr: &bsol;* unexpected end of file is handled here with a fatal exit */
1547      serverLog(LL_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now.");
1548      rdbExitReportCorruptRDB("Unexpected EOF reading RDB file");
1549      return C_ERR; &bsol;* Just to avoid warning */
1550  }
1551  int rdbLoad(char *filename, rdbSaveInfo *rsi) {
1552      FILE *fp;
1553      rio rdb;
1554      int retval;
1555      if ((fp = fopen(filename,IF_WIN32("rb","r"))) == NULL) return C_ERR;
1556      startLoading(fp);
1557      rioInitWithFile(&rdb,fp);
1558      retval = rdbLoadRio(&rdb,rsi,0);
1559      fclose(fp);
1560      stopLoading();
1561      return retval;
1562  }
1563  void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
1564      if (!bysignal && exitcode == 0) {
1565          serverLog(LL_NOTICE,
1566              "Background saving terminated with success");
1567          server.dirty = server.dirty - server.dirty_before_bgsave;
1568          server.lastsave = time(NULL);
1569          server.lastbgsave_status = C_OK;
1570      } else if (!bysignal && exitcode != 0) {
1571          serverLog(LL_WARNING, "Background saving error");
1572          server.lastbgsave_status = C_ERR;
1573      } else {
1574          mstime_t latency;
1575          serverLog(LL_WARNING,
1576              "Background saving terminated by signal %d", bysignal);
1577          latencyStartMonitor(latency);
1578          rdbRemoveTempFile(server.rdb_child_pid);
1579          latencyEndMonitor(latency);
1580          latencyAddSampleIfNeeded("rdb-unlink-temp-file",latency);
1581          if (bysignal != SIGUSR1)
1582              server.lastbgsave_status = C_ERR;
1583      }
1584      server.rdb_child_pid = -1;
1585      server.rdb_child_type = RDB_CHILD_TYPE_NONE;
1586      server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;
1587      server.rdb_save_time_start = -1;
1588      updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_DISK);
1589  }
1590  void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
1591      uint64_t *ok_slaves;
1592      if (!bysignal && exitcode == 0) {
1593          serverLog(LL_NOTICE,
1594              "Background RDB transfer terminated with success");
1595      } else if (!bysignal && exitcode != 0) {
1596          serverLog(LL_WARNING, "Background transfer error");
1597      } else {
1598          serverLog(LL_WARNING,
1599              "Background transfer terminated by signal %d", bysignal);
1600      }
1601      server.rdb_child_pid = -1;
1602      server.rdb_child_type = RDB_CHILD_TYPE_NONE;
1603      server.rdb_save_time_start = -1;
1604      ok_slaves = zmalloc(sizeof(uint64_t)); &bsol;* Make space for the count. */
1605      ok_slaves[0] = 0;
1606      if (!bysignal && exitcode == 0) {
1607          int readlen = sizeof(uint64_t);
1608          if (read(server.rdb_pipe_read_result_from_child, ok_slaves, readlen) ==
1609                   readlen)
1610          {
1611              readlen = (int)(ok_slaves[0]*sizeof(uint64_t)*2);                   WIN_PORT_FIX &bsol;* cast (int) */
1612              ok_slaves = zrealloc(ok_slaves,sizeof(uint64_t)+readlen);
1613              if (readlen &&
1614                  read(server.rdb_pipe_read_result_from_child, ok_slaves+1,
1615                       readlen) != readlen)
1616              {
1617                  ok_slaves[0] = 0;
1618              }
1619          }
1620      }
1621      close(server.rdb_pipe_read_result_from_child);
1622      close(server.rdb_pipe_write_result_to_parent);
1623      listNode *ln;
1624      listIter li;
1625      listRewind(server.slaves,&li);
1626      while((ln = listNext(&li))) {
1627          client *slave = ln->value;
1628          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
1629              uint64_t j;
1630              int errorcode = 0;
1631              for (j = 0; j < ok_slaves[0]; j++) {
1632                  if (slave->id == ok_slaves[2*j+1]) {
1633                      errorcode = (int)(ok_slaves[2*j+2]);                        WIN_PORT_FIX &bsol;* cast (int) */
1634                      break; &bsol;* Found in slaves list. */
1635                  }
1636              }
1637              if (j == ok_slaves[0] || errorcode != 0) {
1638                  serverLog(LL_WARNING,
1639                  "Closing slave %s: child->slave RDB transfer failed: %s",
1640                      replicationGetSlaveName(slave),
1641                      (errorcode == 0) ? "RDB transfer child aborted"
1642                                       : strerror(errorcode));
1643                  freeClient(slave);
1644              } else {
1645                  serverLog(LL_WARNING,
1646                  "Slave %s correctly received the streamed RDB file.",
1647                      replicationGetSlaveName(slave));
1648                  anetNonBlock(NULL,slave->fd);
1649                  anetSendTimeout(NULL,slave->fd,0);
1650              }
1651          }
1652      }
1653      zfree(ok_slaves);
1654      updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, RDB_CHILD_TYPE_SOCKET);
1655  }
1656  void backgroundSaveDoneHandler(int exitcode, int bysignal) {
1657      switch(server.rdb_child_type) {
1658      case RDB_CHILD_TYPE_DISK:
1659          backgroundSaveDoneHandlerDisk(exitcode,bysignal);
1660          break;
1661      case RDB_CHILD_TYPE_SOCKET:
1662          backgroundSaveDoneHandlerSocket(exitcode,bysignal);
1663          break;
1664      default:
1665          serverPanic("Unknown RDB child type.");
1666          break;
1667      }
1668  }
1669  int rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {
1670      int *fds;
1671      uint64_t *clientids;
1672      int numfds;
1673      listNode *ln;
1674      listIter li;
1675      pid_t childpid;
1676      PORT_LONGLONG start;
1677      int pipefds[2];
1678      if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
1679      if (pipe(pipefds) == -1) return C_ERR;
1680      server.rdb_pipe_read_result_from_child = pipefds[0];
1681      server.rdb_pipe_write_result_to_parent = pipefds[1];
1682      fds = zmalloc(sizeof(int)*listLength(server.slaves));
1683      clientids = zmalloc(sizeof(uint64_t)*listLength(server.slaves));
1684      numfds = 0;
1685      listRewind(server.slaves,&li);
1686      while((ln = listNext(&li))) {
1687          client *slave = ln->value;
1688          if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
1689              clientids[numfds] = slave->id;
1690              fds[numfds++] = slave->fd;
1691              replicationSetupSlaveForFullResync(slave,getPsyncInitialOffset());
1692              anetBlock(NULL,slave->fd);
1693              anetSendTimeout(NULL,slave->fd,(PORT_ULONG)server.repl_timeout*1000);  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1694          }
1695      }
1696      openChildInfoPipe();
1697      start = ustime();
1698  #ifdef _WIN32
1699      childpid = BeginForkOperation_Socket(fds, numfds, clientids, pipefds[1], &server, sizeof(server), dictGetHashFunctionSeed(), modules);
1700  #else
1701      if ((childpid = fork()) == 0) {
1702          int retval;
1703          rio slave_sockets;
1704          rioInitWithFdset(&slave_sockets,fds,numfds);
1705          zfree(fds);
1706          closeListeningSockets(0);
1707          redisSetProcTitle("redis-rdb-to-slaves");
1708          retval = rdbSaveRioWithEOFMark(&slave_sockets,NULL,rsi);
1709          if (retval == C_OK && rioFlush(&slave_sockets) == 0)
1710              retval = C_ERR;
1711          if (retval == C_OK) {
1712              size_t private_dirty = zmalloc_get_private_dirty(-1);
1713              if (private_dirty) {
1714                  serverLog(LL_NOTICE,
1715                      "RDB: %zu MB of memory used by copy-on-write",
1716                      private_dirty/(1024*1024));
1717              }
1718              server.child_info_data.cow_size = private_dirty;
1719              sendChildInfo(CHILD_INFO_TYPE_RDB);
1720              void *msg = zmalloc(sizeof(uint64_t)*(1+2*numfds));
1721              uint64_t *len = msg;
1722              uint64_t *ids = len+1;
1723              int j, msglen;
1724              *len = numfds;
1725              for (j = 0; j < numfds; j++) {
1726                  *ids++ = clientids[j];
1727                  *ids++ = slave_sockets.io.fdset.state[j];
1728              }
1729              msglen = sizeof(uint64_t)*(1+2*numfds);
1730              if (*len == 0 ||
1731                  write(server.rdb_pipe_write_result_to_parent,msg,msglen)
1732                  != msglen)
1733              {
1734                  retval = C_ERR;
1735              }
1736              zfree(msg);
1737          }
1738          zfree(clientids);
1739          rioFreeFdset(&slave_sockets);
1740          exitFromChild((retval == C_OK) ? 0 : 1);
1741      } else {
1742  #endif
1743          if (childpid == -1) {
1744              serverLog(LL_WARNING,"Can't save in background: fork: %s",
1745                  IF_WIN32(wsa_strerror(errno),strerror(errno)));
1746              listRewind(server.slaves,&li);
1747              while((ln = listNext(&li))) {
1748                  client *slave = ln->value;
1749                  int j;
1750                  for (j = 0; j < numfds; j++) {
1751                      if (slave->id == clientids[j]) {
1752                          slave->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
1753                          break;
1754                      }
1755                  }
1756              }
1757              close(pipefds[0]);
1758              close(pipefds[1]);
1759              closeChildInfoPipe();
1760          } else {
1761              server.stat_fork_time = ustime()-start;
1762  #ifdef _WIN32
1763              if (server.stat_fork_time == 0) {
1764                  server.stat_fork_time = 100000; 
1765              }
1766  #endif
1767              server.stat_fork_rate = (double)(zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024)); &bsol;* GB per second. */  WIN_PORT_FIX
1768              latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
1769              serverLog(LL_NOTICE,"Background RDB transfer started by pid %d",
1770                  childpid);
1771              server.rdb_save_time_start = time(NULL);
1772              server.rdb_child_pid = childpid;
1773              server.rdb_child_type = RDB_CHILD_TYPE_SOCKET;
1774              updateDictResizePolicy();
1775          }
1776          zfree(clientids);
1777          zfree(fds);
1778          return (childpid == -1) ? C_ERR : C_OK;
1779  #ifndef _WIN32
1780      }
1781  #endif
1782      return C_OK; &bsol;* Unreached. */
1783  }
1784  void saveCommand(client *c) {
1785      if (server.rdb_child_pid != -1) {
1786          addReplyError(c,"Background save already in progress");
1787          return;
1788      }
1789      rdbSaveInfo rsi, *rsiptr;
1790      rsiptr = rdbPopulateSaveInfo(&rsi);
1791      if (rdbSave(server.rdb_filename,rsiptr) == C_OK) {
1792          addReply(c,shared.ok);
1793      } else {
1794          addReply(c,shared.err);
1795      }
1796  }
1797  void bgsaveCommand(client *c) {
1798      int schedule = 0;
1799      if (c->argc > 1) {
1800          if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"schedule")) {
1801              schedule = 1;
1802          } else {
1803              addReply(c,shared.syntaxerr);
1804              return;
1805          }
1806      }
1807      rdbSaveInfo rsi, *rsiptr;
1808      rsiptr = rdbPopulateSaveInfo(&rsi);
1809      if (server.rdb_child_pid != -1) {
1810          addReplyError(c,"Background save already in progress");
1811      } else if (server.aof_child_pid != -1) {
1812          if (schedule) {
1813              server.rdb_bgsave_scheduled = 1;
1814              addReplyStatus(c,"Background saving scheduled");
1815          } else {
1816              addReplyError(c,
1817                  "An AOF log rewriting in progress: can't BGSAVE right now. "
1818                  "Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever "
1819                  "possible.");
1820          }
1821      } else if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK) {
1822          addReplyStatus(c,"Background saving started");
1823      } else {
1824          addReply(c,shared.err);
1825      }
1826  }
1827  rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
1828      rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;
1829      *rsi = rsi_init;
1830      if (!server.masterhost && server.repl_backlog) {
1831          rsi->repl_stream_db = server.slaveseldb == -1 ? 0 : server.slaveseldb;
1832          return rsi;
1833      }
1834      if (server.master) {
1835          rsi->repl_stream_db = server.master->db->id;
1836          return rsi;
1837      }
1838      if (server.cached_master) {
1839          rsi->repl_stream_db = server.cached_master->db->id;
1840          return rsi;
1841      }
1842      return NULL;
1843  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rdb.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-rdb.c</div>
                </div>
                <div class="column column_space"><pre><code>1482              moduleType *mt = moduleTypeLookupModuleByID(moduleid);
1483              char name[10];
1484              moduleTypeNameByID(name,moduleid);
</pre></code></div>
                <div class="column column_space"><pre><code>1482              moduleType *mt = moduleTypeLookupModuleByID(moduleid);
1483              char name[10];
1484              moduleTypeNameByID(name,moduleid);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    