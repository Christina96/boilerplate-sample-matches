<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omfile-hardened.c &amp; mmkubernetes.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omfile-hardened.c &amp; mmkubernetes.c
      </h3>
<h1 align="center">
        8.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omfile-hardened.c (10.526316%)<th>mmkubernetes.c (6.881243%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(238-279)<td><a href="#" name="0">(230-276)</a><td align="center"><font color="#ff0000">79</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1382-1389)<td><a href="#" name="1">(589-602)</a><td align="center"><font color="#4a0000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1335-1343)<td><a href="#" name="2">(713-726)</a><td align="center"><font color="#470000">22</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omfile-hardened.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include "glbl.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;libgen.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/statvfs.h&gt;
#ifdef HAVE_ATOMIC_BUILTINS
#	include &lt;pthread.h&gt;
#endif
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "outchannel.h"
#include "omfile.h"
#include "cfsysline.h"
#include "module-template.h"
#include "errmsg.h"
#include "stream.h"
#include "unicode-helper.h"
#include "atomic.h"
#include "statsobj.h"
#include "sigprov.h"
#include "cryprov.h"
#include "parserif.h"
#include "janitor.h"
#include "rsconf.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omfile")
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(strm)
DEFobjCurrIf(statsobj)
#if HAVE_ATOMIC_BUILTINS64
static uint64 clockFileAccess = 0;
#else
static unsigned clockFileAccess = 0;
#endif
#ifndef HAVE_ATOMIC_BUILTINS
static pthread_mutex_t mutClock;
#endif
static uint64
getClockFileAccess(void)
{
#if HAVE_ATOMIC_BUILTINS64
	return ATOMIC_INC_AND_FETCH_uint64(&amp;clockFileAccess, &amp;mutClock);
#else
	return ATOMIC_INC_AND_FETCH_unsigned(&amp;clockFileAccess, &amp;mutClock);
#endif
}
struct s_dynaFileCacheEntry {
	uchar *pName;			strm_t	*pStrm;			void	*sigprovFileData;		uint64	clkTickAccessed;	short nInactive;	};
typedef struct s_dynaFileCacheEntry dynaFileCacheEntry;
#define IOBUF_DFLT_SIZE 4096	#define FLUSH_INTRVL_DFLT 1 	#define USE_ASYNCWRITER_DFLT 0 	#define FLUSHONTX_DFLT 1 	
typedef struct _instanceData {
	pthread_mutex_t mutWrite; 	uchar	*fname;		uchar 	*tplName;		strm_t	*pStrm;			short nInactive;		char	bDynamicName;		int	fCreateMode;		int	fDirCreateMode;		int	bCreateDirs;		int	bSyncFile;		uint8_t iNumTpls;		uid_t	fileUID;		uid_t	dirUID;
	gid_t	fileGID;
	gid_t	dirGID;
	dynaFileCacheEntry **dynCache;
	off_t	iSizeLimit;			uchar	*pszSizeLimitCmd;		int 	iZipLevel;			uint	iIOBufSize;			int	iFlushInterval;			short	iCloseTimeout;			sbool	bFlushOnTXEnd;			sbool	bUseAsyncWriter;		sbool	bVeryRobustZip;
	statsobj_t *stats;			STATSCOUNTER_DEF(ctrRequests, mutCtrRequests);
	STATSCOUNTER_DEF(ctrLevel0, mutCtrLevel0);
	STATSCOUNTER_DEF(ctrEvict, mutCtrEvict);
	STATSCOUNTER_DEF(ctrMiss, mutCtrMiss);
	STATSCOUNTER_DEF(ctrMax, mutCtrMax);
	STATSCOUNTER_DEF(ctrCloseTimeouts, mutCtrCloseTimeouts);
	char janitorID[128];		} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
} wrkrInstanceData_t;
typedef struct configSettings_s {
	uint iDynaFileCacheSize; 	int fCreateMode; 	int fDirCreateMode; 	int	bFailOnChown;		uid_t	fileUID;		uid_t	fileGID;		uid_t	dirUID;			uid_t	dirGID;			int	bCreateDirs;	int	bEnableSync;	int	iZipLevel;		sbool	bFlushOnTXEnd;	int64	iIOBufSize;		int	iFlushInterval; 		int	bUseAsyncWriter;		EMPTY_STRUCT
} configSettings_t;
static configSettings_t cs;
uchar	*pszFileDfltTplName; 
struct modConfData_s {
	rsconf_t *pConf;		uchar 	*tplName;		int fCreateMode; 	int fDirCreateMode; 	uid_t fileUID;		uid_t dirUID;
	gid_t fileGID;
	gid_t dirGID;
	int bDynafileDoNotSuspend;
};
static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
<a name="0"></a>static struct cnfparamdescr modpdescr[] = {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "template", eCmdHdlrGetWord, 0 },
	{ "dircreatemode", eCmdHdlrFileCreateMode, 0 },
	{ "filecreatemode", eCmdHdlrFileCreateMode, 0 },
	{ "dirowner", eCmdHdlrUID, 0 },
	{ "dirownernum", eCmdHdlrInt, 0 },
	{ "dirgroup", eCmdHdlrGID, 0 },
	{ "dirgroupnum", eCmdHdlrInt, 0 },
	{ "fileowner", eCmdHdlrUID, 0 },
	{ "fileownernum", eCmdHdlrInt, 0 },
	{ "filegroup", eCmdHdlrGID, 0 },
	{ "dynafile.donotsuspend", eCmdHdlrBinary, 0 },
	{ "filegroupnum", eCmdHdlrInt, 0 },
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static struct cnfparamdescr actpdescr[] = {
	{ "dynafilecachesize", eCmdHdlrInt, 0 }, 	{ "ziplevel", eCmdHdlrInt, 0 }, 	{ "flushinterval", eCmdHdlrInt, 0 }, 	{ "asyncwriting", eCmdHdlrBinary, 0 }, 	{ "veryrobustzip", eCmdHdlrBinary, 0 },
	{ "flushontxend", eCmdHdlrBinary, 0 }, 	{ "iobuffersize", eCmdHdlrSize, 0 }, 	{ "dirowner", eCmdHdlrUID, 0 }, 	{ "dirownernum", eCmdHdlrInt, 0 }, 	{ "dirgroup", eCmdHdlrGID, 0 }, 	{ "dirgroupnum", eCmdHdlrInt, 0 }, 	{ "fileowner", eCmdHdlrUID, 0 }, 	{ "fileownernum", eCmdHdlrInt, 0 }, 	{ "filegroup", eCmdHdlrGID, 0 }, 	{ "filegroupnum", eCmdHdlrInt, 0 }, 	{ "dircreatemode", eCmdHdlrFileCreateMode, 0 }, 	{ "filecreatemode", eCmdHdlrFileCreateMode, 0 }, 	{ "failonchownfailure", eCmdHdlrBinary, 0 }, 	{ "createdirs", eCmdHdlrBinary, 0 }, 	{ "sync", eCmdHdlrBinary, 0 }, 	{ "file", eCmdHdlrString, 0 },     	{ "dynafile", eCmdHdlrString, 0 }, 	{ "sig.provider", eCmdHdlrGetWord, 0 },
	{ "cry.provider", eCmdHdlrGetWord, 0 },
	{ "closetimeout", eCmdHdlrPositiveInt, 0 },
	{ "template", eCmdHdlrGetWord, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};
static uchar*
getDfltTpl(void)
{
	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
		return loadModConf-&gt;tplName;
	else if(pszFileDfltTplName == NULL)
		return (uchar*)"RSYSLOG_FileFormat";
	else
		return pszFileDfltTplName;
}
BEGINinitConfVars		CODESTARTinitConfVars
	pszFileDfltTplName = NULL; 	iRet = resetConfigVariables(NULL, NULL); ENDinitConfVars
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	if(pData-&gt;bDynamicName) {
		dbgprintf("[dynamic]\n");
	} else { 		dbgprintf("%s%s\n", pData-&gt;fname,
			  (pData-&gt;pStrm == NULL) ? " (closed)" : "");
	}
	dbgprintf("\ttemplate='%s'\n", pData-&gt;fname);
	dbgprintf("\tuse async writer=%d\n", pData-&gt;bUseAsyncWriter);
	dbgprintf("\tflush on TX end=%d\n", pData-&gt;bFlushOnTXEnd);
	dbgprintf("\tflush interval=%d\n", pData-&gt;iFlushInterval);
	dbgprintf("\tfile cache size=%d\n", pData-&gt;iDynaFileCacheSize);
	dbgprintf("\tcreate directories: %s\n", pData-&gt;bCreateDirs ? "on" : "off");
	dbgprintf("\tvery robust zip: %s\n", pData-&gt;bCreateDirs ? "on" : "off");
	dbgprintf("\tfile owner %d, group %d\n", (int) pData-&gt;fileUID, (int) pData-&gt;fileGID);
	dbgprintf("\tdirectory owner %d, group %d\n", (int) pData-&gt;dirUID, (int) pData-&gt;dirGID);
	dbgprintf("\tdir create mode 0%3.3o, file create mode 0%3.3o\n",
		  pData-&gt;fDirCreateMode, pData-&gt;fCreateMode);
	dbgprintf("\tfail if owner/group can not be set: %s\n", pData-&gt;bFailOnChown ? "yes" : "no");
ENDdbgPrintInstInfo
static rsRetVal
setLegacyDfltTpl(void __attribute__((unused)) *pVal, uchar* newVal)
{
	DEFiRet;
	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL) {
		free(newVal);
		parser_errmsg("omfile: default template already set via module "
			"global parameter - can no longer be changed");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	free(pszFileDfltTplName);
	pszFileDfltTplName = newVal;
finalize_it:
	RETiRet;
}
static rsRetVal setDynaFileCacheSize(void __attribute__((unused)) *pVal, int iNewVal)
{
	DEFiRet;
	if(iNewVal &lt; 1) {
		errno = 0;
		parser_errmsg(
		         "DynaFileCacheSize must be greater 0 (%d given), changed to 1.", iNewVal);
		iRet = RS_RET_VAL_OUT_OF_RANGE;
		iNewVal = 1;
	} else if(iNewVal &gt; 1000) {
		errno = 0;
		parser_errmsg(
		         "DynaFileCacheSize maximum is 1,000 (%d given), changed to 1,000.", iNewVal);
		iRet = RS_RET_VAL_OUT_OF_RANGE;
		iNewVal = 1000;
	}
	cs.iDynaFileCacheSize = iNewVal;
	DBGPRINTF("DynaFileCacheSize changed to %d.\n", iNewVal);
	RETiRet;
}
static rsRetVal cflineParseOutchannel(instanceData *pData, uchar* p, omodStringRequest_t *pOMSR,
	int iEntry, int iTplOpts)
{
	DEFiRet;
	size_t i;
	struct outchannel *pOch;
	char szBuf[128];	
	++p; 	i = 0;
	while(*p &amp;&amp; *p != ';' &amp;&amp; *p != ' ' &amp;&amp;
	      i &lt; (sizeof(szBuf) - 1) ) {
	      szBuf[i++] = *p++;
	}
	szBuf[i] = '\0';
	pOch = ochFind(szBuf, i);
	if(pOch == NULL) {
		parser_errmsg(
			 "outchannel '%s' not found - ignoring action line",
			 szBuf);
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
	if(pOch-&gt;pszFileTemplate == NULL) {
		parser_errmsg(
			 "outchannel '%s' has no file name template - ignoring action line",
			 szBuf);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	pData-&gt;fname = ustrdup(pOch-&gt;pszFileTemplate);
	pData-&gt;iSizeLimit = pOch-&gt;uSizeLimit;
	pData-&gt;pszSizeLimitCmd = pOch-&gt;cmdOnSizeLimit;
	iRet = cflineParseTemplateName(&amp;p, pOMSR, iEntry, iTplOpts, getDfltTpl());
finalize_it:
	RETiRet;
}
static rsRetVal
dynaFileDelCacheEntry(instanceData *__restrict__ const pData, const int iEntry, const int bFreeEntry)
{
	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
	DEFiRet;
	assert(pCache != NULL);
	if(pCache[iEntry] == NULL)
		FINALIZE;
	DBGPRINTF("Removing entry %d for file '%s' from dynaCache.\n", iEntry,
		pCache[iEntry]-&gt;pName == NULL ? UCHAR_CONSTANT("[OPEN FAILED]") : pCache[iEntry]-&gt;pName);
	if(pCache[iEntry]-&gt;pName != NULL) {
		free(pCache[iEntry]-&gt;pName);
		pCache[iEntry]-&gt;pName = NULL;
	}
	if(pCache[iEntry]-&gt;pStrm != NULL) {
		strm.Destruct(&amp;pCache[iEntry]-&gt;pStrm);
		if(pData-&gt;useSigprov) {
			pData-&gt;sigprov.OnFileClose(pCache[iEntry]-&gt;sigprovFileData);
			pCache[iEntry]-&gt;sigprovFileData = NULL;
		}
	}
	if(bFreeEntry) {
		free(pCache[iEntry]);
		pCache[iEntry] = NULL;
	}
finalize_it:
	RETiRet;
}
static void
dynaFileFreeCacheEntries(instanceData *__restrict__ const pData)
{
	register uint i;
	assert(pData != NULL);
	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
		dynaFileDelCacheEntry(pData, i, 1);
	}
	pData-&gt;iCurrElt = -1; }
static void dynaFileFreeCache(instanceData *__restrict__ const pData)
{
	assert(pData != NULL);
	dynaFileFreeCacheEntries(pData);
	if(pData-&gt;dynCache != NULL)
		free(pData-&gt;dynCache);
}
static rsRetVal
closeFile(instanceData *__restrict__ const pData)
{
	DEFiRet;
	if(pData-&gt;useSigprov) {
		pData-&gt;sigprov.OnFileClose(pData-&gt;sigprovFileData);
		pData-&gt;sigprovFileData = NULL;
	}
	strm.Destruct(&amp;pData-&gt;pStrm);
	RETiRet;
}
static rsRetVal
sigprovPrepare(instanceData *__restrict__ const pData, uchar *__restrict__ const fn)
{
	DEFiRet;
	pData-&gt;sigprov.OnFileOpen(pData-&gt;sigprovData, fn, &amp;pData-&gt;sigprovFileData);
	RETiRet;
}
static rsRetVal
prepareFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
{
	int fd;
	char errStr[1024]; 	DEFiRet;
	pData-&gt;pStrm = NULL;
	if(access((char*)newFileName, F_OK) != 0) {
		if(pData-&gt;bCreateDirs) {
			if(makeFileParentDirs(newFileName, ustrlen(newFileName),
			     pData-&gt;fDirCreateMode, pData-&gt;dirUID,
			     pData-&gt;dirGID, pData-&gt;bFailOnChown) != 0) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				parser_errmsg( "omfile: creating parent "
					"directories for file  '%s' failed: %s",
					newFileName, errStr);
			     	ABORT_FINALIZE(RS_RET_ERR); 			}
		}
		fd = open((char*) newFileName, O_WRONLY|O_APPEND|O_CREAT|O_NOCTTY|O_CLOEXEC,
				pData-&gt;fCreateMode);
		if(fd != -1) {
			if(pData-&gt;fileUID != (uid_t)-1 || pData-&gt;fileGID != (gid_t) -1) {
				if(fchown(fd, pData-&gt;fileUID, pData-&gt;fileGID) != 0) {
					rs_strerror_r(errno, errStr, sizeof(errStr));
					parser_errmsg(
						"omfile: chown for file '%s' failed: %s",
						newFileName, errStr);
					if(pData-&gt;bFailOnChown) {
						close(fd);
						ABORT_FINALIZE(RS_RET_ERR); 					}
				}
			}
			close(fd); 		}
		else {
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	uchar szNameBuf[MAXFNAME+1];
	uchar szDirName[MAXFNAME+1];
	uchar szBaseName[MAXFNAME+1];
	ustrncpy(szNameBuf, newFileName, MAXFNAME);
	szNameBuf[MAXFNAME] = '\0';
	ustrncpy(szDirName, (uchar*)dirname((char*)szNameBuf), MAXFNAME);
	szDirName[MAXFNAME] = '\0';
	ustrncpy(szNameBuf, newFileName, MAXFNAME);
	szNameBuf[MAXFNAME] = '\0';
	ustrncpy(szBaseName, (uchar*)basename((char*)szNameBuf), MAXFNAME);
	szBaseName[MAXFNAME] = '\0';
	CHKiRet(strm.Construct(&amp;pData-&gt;pStrm));
	CHKiRet(strm.SetFName(pData-&gt;pStrm, szBaseName, ustrlen(szBaseName)));
	CHKiRet(strm.SetDir(pData-&gt;pStrm, szDirName, ustrlen(szDirName)));
	CHKiRet(strm.SetiZipLevel(pData-&gt;pStrm, pData-&gt;iZipLevel));
	CHKiRet(strm.SetbVeryReliableZip(pData-&gt;pStrm, pData-&gt;bVeryRobustZip));
	CHKiRet(strm.SetsIOBufSize(pData-&gt;pStrm, (size_t) pData-&gt;iIOBufSize));
	CHKiRet(strm.SettOperationsMode(pData-&gt;pStrm, STREAMMODE_WRITE_APPEND));
	CHKiRet(strm.SettOpenMode(pData-&gt;pStrm, cs.fCreateMode));
	CHKiRet(strm.SetbSync(pData-&gt;pStrm, pData-&gt;bSyncFile));
	CHKiRet(strm.SetsType(pData-&gt;pStrm, STREAMTYPE_FILE_SINGLE));
	CHKiRet(strm.SetiSizeLimit(pData-&gt;pStrm, pData-&gt;iSizeLimit));
	if(pData-&gt;useCryprov) {
		CHKiRet(strm.Setcryprov(pData-&gt;pStrm, &amp;pData-&gt;cryprov));
		CHKiRet(strm.SetcryprovData(pData-&gt;pStrm, pData-&gt;cryprovData));
	}
	if(pData-&gt;bUseAsyncWriter)
		CHKiRet(strm.SetiFlushInterval(pData-&gt;pStrm, pData-&gt;iFlushInterval));
	if(pData-&gt;pszSizeLimitCmd != NULL)
		CHKiRet(strm.SetpszSizeLimitCmd(pData-&gt;pStrm, ustrdup(pData-&gt;pszSizeLimitCmd)));
	CHKiRet(strm.ConstructFinalize(pData-&gt;pStrm));
	if(pData-&gt;useSigprov)
		sigprovPrepare(pData, szNameBuf);
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pData-&gt;pStrm != NULL) {
			closeFile(pData);
		}
	}
	RETiRet;
}
static rsRetVal
fsCheck(instanceData *__restrict__ const pData, const uchar *__restrict__ const fileName)
{
	DEFiRet;
	struct statvfs stat;
	char *pathcopy;
	const char *path;
	pathcopy = strdup((char*)fileName);
	path = dirname(pathcopy);
	if (statvfs(path, &amp;stat) != 0) {
		iRet = RS_RET_FILE_NO_STAT;
		LogError(0, iRet, "could not stat %s", path);
		FINALIZE;
	}
	if (stat.f_bsize * stat.f_bavail &lt;
		pData-&gt;iIOBufSize * pData-&gt;iDynaFileCacheSize + (uint)(glbl.GetMaxLine(runModConf-&gt;pConf)))
		{
			iRet = RS_RET_FS_ERR;
			LogError(0, iRet, "too few available blocks in %s", path);
			FINALIZE;
		}
	if (stat.f_favail &lt; 2 &amp;&amp; stat.f_files &gt; 0)
		{
			iRet = RS_RET_FS_ERR;
			LogError(0, iRet, "too few available inodes in %s", path);
			FINALIZE;
		}
	if (stat.f_flag == ST_RDONLY)
		{
			iRet = RS_RET_FS_ERR;
			LogError(0, iRet, "file-system is read-only in %s", path);
			FINALIZE;
		}
	iRet = RS_RET_OK;
finalize_it:
	if (pathcopy != NULL)
		free(pathcopy);
	RETiRet;
}
static rsRetVal
prepareDynFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
{
	uint64 ctOldest; 	int iOldest;
	uint i;
	int iFirstFree;
	rsRetVal localRet;
	dynaFileCacheEntry **pCache;
	DEFiRet;
	assert(pData != NULL);
	assert(newFileName != NULL);
	pCache = pData-&gt;dynCache;
	if(   (pData-&gt;iCurrElt != -1)
	   &amp;&amp; !ustrcmp(newFileName, pCache[pData-&gt;iCurrElt]-&gt;pName)) {
		CHKiRet(fsCheck(pData, newFileName));
		pCache[pData-&gt;iCurrElt]-&gt;clkTickAccessed = getClockFileAccess();
		STATSCOUNTER_INC(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
		FINALIZE;
	}
	pData-&gt;iCurrElt = -1;		iFirstFree = -1; 	iOldest = 0; 	ctOldest = getClockFileAccess(); 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
		if(pCache[i] == NULL || pCache[i]-&gt;pName == NULL) {
			if(iFirstFree == -1)
				iFirstFree = i;
		} else { 			if(!ustrcmp(newFileName, pCache[i]-&gt;pName)) {
				CHKiRet(fsCheck(pData, newFileName));
				pData-&gt;pStrm = pCache[i]-&gt;pStrm;
				if(pData-&gt;useSigprov)
					pData-&gt;sigprovFileData = pCache[i]-&gt;sigprovFileData;
				pData-&gt;iCurrElt = i;
				pCache[i]-&gt;clkTickAccessed = getClockFileAccess(); 				FINALIZE;
			}
			if(pCache[i]-&gt;clkTickAccessed &lt; ctOldest) {
				ctOldest = pCache[i]-&gt;clkTickAccessed;
				iOldest = i;
				}
		}
	}
	STATSCOUNTER_INC(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
	pData-&gt;pStrm = NULL, pData-&gt;sigprovFileData = NULL;
	if(iFirstFree == -1 &amp;&amp; (pData-&gt;iCurrCacheSize &lt; pData-&gt;iDynaFileCacheSize)) {
		iFirstFree = pData-&gt;iCurrCacheSize++;
		STATSCOUNTER_SETMAX_NOMUT(pData-&gt;ctrMax, (unsigned) pData-&gt;iCurrCacheSize);
	}
	if(iFirstFree == -1) {
		dynaFileDelCacheEntry(pData, iOldest, 0);
		STATSCOUNTER_INC(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
		iFirstFree = iOldest; 	} else {
		CHKmalloc(pCache[iFirstFree] = (dynaFileCacheEntry*) calloc(1, sizeof(dynaFileCacheEntry)));
	}
	localRet = prepareFile(pData, newFileName); 
	if(localRet != RS_RET_OK) {
		parser_errmsg("Could not open dynamic file '%s' [state %d]", newFileName, localRet);
		ABORT_FINALIZE(localRet);
	}
	localRet = fsCheck(pData, newFileName);
	if(localRet != RS_RET_OK) {
		parser_errmsg("Invalid file-system condition for dynamic file '%s' [state %d]", newFileName, localRet);
		ABORT_FINALIZE(localRet);
	}
	if((pCache[iFirstFree]-&gt;pName = ustrdup(newFileName)) == NULL) {
		closeFile(pData); 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	pCache[iFirstFree]-&gt;pStrm = pData-&gt;pStrm;
	if(pData-&gt;useSigprov)
		pCache[iFirstFree]-&gt;sigprovFileData = pData-&gt;sigprovFileData;
	pCache[iFirstFree]-&gt;clkTickAccessed = getClockFileAccess();
	pData-&gt;iCurrElt = iFirstFree;
	DBGPRINTF("Added new entry %d for file cache, file '%s'.\n", iFirstFree, newFileName);
finalize_it:
	if(iRet == RS_RET_OK)
		pCache[pData-&gt;iCurrElt]-&gt;nInactive = 0;
	RETiRet;
}
static  rsRetVal
doWrite(instanceData *__restrict__ const pData, uchar *__restrict__ const pszBuf, const int lenBuf)
{
	DEFiRet;
	assert(pData != NULL);
	assert(pszBuf != NULL);
	DBGPRINTF("omfile: write to stream, pData-&gt;pStrm %p, lenBuf %d, strt data %.128s\n",
		  pData-&gt;pStrm, lenBuf, pszBuf);
	if(pData-&gt;pStrm != NULL){
		CHKiRet(strm.Write(pData-&gt;pStrm, pszBuf, lenBuf));
		if(pData-&gt;useSigprov) {
			CHKiRet(pData-&gt;sigprov.OnRecordWrite(pData-&gt;sigprovFileData, pszBuf, lenBuf));
		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
writeFile(instanceData *__restrict__ const pData,
	  const actWrkrIParams_t *__restrict__ const pParam,
	  const int iMsg)
{
	DEFiRet;
	STATSCOUNTER_INC(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
	if(pData-&gt;bDynamicName) {
		DBGPRINTF("omfile: file to log to: %s\n",
			  actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param);
		CHKiRet(prepareDynFile(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param));
	} else { 		if(pData-&gt;pStrm == NULL) {
			CHKiRet(prepareFile(pData, pData-&gt;fname));
			if(pData-&gt;pStrm == NULL) {
				parser_errmsg(
					"Could not open output file '%s'", pData-&gt;fname);
			}
			CHKiRet(fsCheck(pData, pData-&gt;fname));
		}
		pData-&gt;nInactive = 0;
	}
	iRet = doWrite(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).param,
		actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).lenStr);
finalize_it:
	RETiRet;
}
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;tplName = NULL;
	pModConf-&gt;fCreateMode = 0644;
	pModConf-&gt;fDirCreateMode = 0700;
	pModConf-&gt;fileUID = -1;
	pModConf-&gt;dirUID = -1;
	pModConf-&gt;fileGID = -1;
	pModConf-&gt;dirGID = -1;
	pModConf-&gt;bDynafileDoNotSuspend = 1;
ENDbeginCnfLoad
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		parser_errmsg("error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for omfile:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		}
		if(!strcmp(modpblk.descr[i].name, "template")) {
			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			if(pszFileDfltTplName != NULL) {
				parser_errmsg("omfile: warning: default template was already "
					"set via legacy directive - may lead to inconsistent "
					"results.");
			}
		} else if(!strcmp(modpblk.descr[i].name, "dircreatemode")) {
			loadModConf-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "filecreatemode")) {
			loadModConf-&gt;fCreateMode = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "dirowner")) {
			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "dirownernum")) {
			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "dirgroup")) {
			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "dirgroupnum")) {
			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "fileowner")) {
			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "fileownernum")) {
			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "filegroup")) {
			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "filegroupnum")) {
			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "dynafile.donotsuspend")) {
			loadModConf-&gt;bDynafileDoNotSuspend = (int) pvals[i].val.d.n;
		} else {
			dbgprintf("omfile: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
static void
janitorChkDynaFiles(instanceData *__restrict__ const pData)
{
	uint i;
	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
		if(pCache[i] == NULL)
			continue;
		DBGPRINTF("omfile janitor: checking dynafile %d:%s, inactive since %d\n", i,
			pCache[i]-&gt;pName == NULL ? UCHAR_CONSTANT("[OPEN FAILED]") : pCache[i]-&gt;pName,
			(int) pCache[i]-&gt;nInactive);
		if(pCache[i]-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
			STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
			dynaFileDelCacheEntry(pData, i, 1);
			if(pData-&gt;iCurrElt &gt;= 0) {
				if((uint)(pData-&gt;iCurrElt) == i)
				pData-&gt;iCurrElt = -1; 			}
		} else {
			pCache[i]-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
		}
	}
}
static void
janitorCB(void *pUsr)
{
	instanceData *__restrict__ const pData = (instanceData *) pUsr;
	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
	if(pData-&gt;bDynamicName) {
		janitorChkDynaFiles(pData);
	} else {
		if(pData-&gt;pStrm != NULL) {
			DBGPRINTF("omfile janitor: checking file %s, inactive since %d\n",
				pData-&gt;fname, pData-&gt;nInactive);
			if(pData-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
				STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
				closeFile(pData);
			} else {
				pData-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
			}
		}
	}
	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
}
BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; 	free(pszFileDfltTplName);
	pszFileDfltTplName = NULL;
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
	free(pModConf-&gt;tplName);
ENDfreeCnf
BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;pStrm = NULL;
	pthread_mutex_init(&amp;pData-&gt;mutWrite, NULL);
ENDcreateInstance
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
ENDcreateWrkrInstance
BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;tplName);
	free(pData-&gt;fname);
	if(pData-&gt;iCloseTimeout &gt; 0)
		janitorDelEtry(pData-&gt;janitorID);
	if(pData-&gt;bDynamicName) {
		dynaFileFreeCache(pData);
	} else if(pData-&gt;pStrm != NULL)
		closeFile(pData);
	if(pData-&gt;stats != NULL)
		statsobj.Destruct(&amp;(pData-&gt;stats));
	if(pData-&gt;useSigprov) {
		pData-&gt;sigprov.Destruct(&amp;pData-&gt;sigprovData);
		obj.ReleaseObj(__FILE__, pData-&gt;sigprovNameFull+2, pData-&gt;sigprovNameFull,
			       (void*) &amp;pData-&gt;sigprov);
		free(pData-&gt;sigprovName);
		free(pData-&gt;sigprovNameFull);
	}
	if(pData-&gt;useCryprov) {
		pData-&gt;cryprov.Destruct(&amp;pData-&gt;cryprovData);
		obj.ReleaseObj(__FILE__, pData-&gt;cryprovNameFull+2, pData-&gt;cryprovNameFull,
			       (void*) &amp;pData-&gt;cryprov);
		free(pData-&gt;cryprovName);
		free(pData-&gt;cryprovNameFull);
	}
	pthread_mutex_destroy(&amp;pData-&gt;mutWrite);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
ENDfreeWrkrInstance
BEGINtryResume
CODESTARTtryResume
ENDtryResume
BEGINbeginTransaction
CODESTARTbeginTransaction
ENDbeginTransaction
BEGINcommitTransaction
	instanceData *__restrict__ const pData = pWrkrData-&gt;pData;
	unsigned i;
CODESTARTcommitTransaction
	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
	for(i = 0 ; i &lt; nParams ; ++i) {
		CHKiRet(writeFile(pData, pParams, i));
	}
	if(pData-&gt;bFlushOnTXEnd &amp;&amp; pData-&gt;pStrm != NULL) {
		CHKiRet(strm.Flush(pData-&gt;pStrm));
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		if (runModConf-&gt;bDynafileDoNotSuspend == 0 || !(pData-&gt;bDynamicName)) {
			LogError(0, iRet, "suspending action");
			iRet = RS_RET_SUSPENDED;
		}
		else {
			LogError(0, iRet, "discarding message");
		}
	}
	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
ENDcommitTransaction
static void
setInstParamDefaults(instanceData *__restrict__ const pData)
{
	pData-&gt;fname = NULL;
	pData-&gt;tplName = NULL;
	pData-&gt;fileUID = loadModConf-&gt;fileUID;
	pData-&gt;fileGID = loadModConf-&gt;fileGID;
	pData-&gt;dirUID = loadModConf-&gt;dirUID;
	pData-&gt;dirGID = loadModConf-&gt;dirGID;
	pData-&gt;bFailOnChown = 1;
	pData-&gt;iDynaFileCacheSize = 10;
	pData-&gt;fCreateMode = loadModConf-&gt;fCreateMode;
	pData-&gt;fDirCreateMode = loadModConf-&gt;fDirCreateMode;
	pData-&gt;bCreateDirs = 1;
	pData-&gt;bSyncFile = 0;
	pData-&gt;iZipLevel = 0;
	pData-&gt;bVeryRobustZip = 0;
	pData-&gt;bFlushOnTXEnd = FLUSHONTX_DFLT;
	pData-&gt;iIOBufSize = IOBUF_DFLT_SIZE;
	pData-&gt;iFlushInterval = FLUSH_INTRVL_DFLT;
	pData-&gt;bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
	pData-&gt;sigprovName = NULL;
	pData-&gt;cryprovName = NULL;
	pData-&gt;useSigprov = 0;
	pData-&gt;useCryprov = 0;
	pData-&gt;iCloseTimeout = -1;
}
static rsRetVal
setupInstStatsCtrs(instanceData *__restrict__ const pData)
{
	uchar ctrName[512];
	DEFiRet;
	if(!pData-&gt;bDynamicName) {
		FINALIZE;
	}
	snprintf((char*)ctrName, sizeof(ctrName), "dynafile cache %s", pData-&gt;fname);
	ctrName[sizeof(ctrName)-1] = '\0'; 	CHKiRet(statsobj.Construct(&amp;(pData-&gt;stats)));
	CHKiRet(statsobj.SetName(pData-&gt;stats, ctrName));
	CHKiRet(statsobj.SetOrigin(pData-&gt;stats, (uchar*)"omfile"));
	STATSCOUNTER_INIT(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("requests"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrRequests)));
	STATSCOUNTER_INIT(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("level0"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrLevel0)));
	STATSCOUNTER_INIT(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("missed"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMiss)));
	STATSCOUNTER_INIT(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("evicted"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrEvict)));
	STATSCOUNTER_INIT(pData-&gt;ctrMax, pData-&gt;mutCtrMax);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("maxused"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMax)));
	STATSCOUNTER_INIT(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("closetimeouts"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrCloseTimeouts)));
	CHKiRet(statsobj.ConstructFinalize(pData-&gt;stats));
finalize_it:
	RETiRet;
}
static void
initSigprov(instanceData *__restrict__ const pData, struct nvlst *lst)
{
	uchar szDrvrName[1024];
	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), "lmsig_%s", pData-&gt;sigprovName)
		== sizeof(szDrvrName)) {
		parser_errmsg("omfile: signature provider "
				"name is too long: '%s' - signatures disabled",
				pData-&gt;sigprovName);
		goto done;
	}
	pData-&gt;sigprovNameFull = ustrdup(szDrvrName);
	pData-&gt;sigprov.ifVersion = sigprovCURR_IF_VERSION;
	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;sigprov)
		!= RS_RET_OK) {
		parser_errmsg("omfile: could not load "
				"signature provider '%s' - signatures disabled",
				szDrvrName);
		goto done;
	}
	if(pData-&gt;sigprov.Construct(&amp;pData-&gt;sigprovData) != RS_RET_OK) {
		parser_errmsg("omfile: error constructing "
				"signature provider %s dataset - signatures disabled",
				szDrvrName);
		goto done;
	}
	pData-&gt;sigprov.SetCnfParam(pData-&gt;sigprovData, lst);
	dbgprintf("loaded signature provider %s, data instance at %p\n",
		  szDrvrName, pData-&gt;sigprovData);
	pData-&gt;useSigprov = 1;
done:	return;
}
static rsRetVal
initCryprov(instanceData *__restrict__ const pData, struct nvlst *lst)
{
	uchar szDrvrName[1024];
	DEFiRet;
	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), "lmcry_%s", pData-&gt;cryprovName)
		== sizeof(szDrvrName)) {
		parser_errmsg("omfile: crypto provider "
				"name is too long: '%s' - encryption disabled",
				pData-&gt;cryprovName);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	pData-&gt;cryprovNameFull = ustrdup(szDrvrName);
	pData-&gt;cryprov.ifVersion = cryprovCURR_IF_VERSION;
	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;cryprov)
		!= RS_RET_OK) {
		parser_errmsg("omfile: could not load "
				"crypto provider '%s' - encryption disabled",
				szDrvrName);
		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
	}
	if(pData-&gt;cryprov.Construct(&amp;pData-&gt;cryprovData) != RS_RET_OK) {
		parser_errmsg("omfile: error constructing "
				"crypto provider %s dataset - encryption disabled",
				szDrvrName);
		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
	}
	CHKiRet(pData-&gt;cryprov.SetCnfParam(pData-&gt;cryprovData, lst, CRYPROV_PARAMTYPE_REGULAR));
	dbgprintf("loaded crypto provider %s, data instance at %p\n",
		  szDrvrName, pData-&gt;cryprovData);
	pData-&gt;useCryprov = 1;
finalize_it:
	RETiRet;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
	uchar *tplToUse;
	int i;
CODESTARTnewActInst
	DBGPRINTF("newActInst (omfile)\n");
	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
	if(pvals == NULL) {
		parser_errmsg("omfile: either the \"file\" or "
				"\"dynafile\" parameter must be given");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("action param blk in omfile:\n");
		cnfparamsPrint(&amp;actpblk, pvals);
	}
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "dynafilecachesize")) {
<a name="2"></a>			pData-&gt;iDynaFileCacheSize = (uint) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "ziplevel")) {
			pData-&gt;iZipLevel = (int) pvals[i].val.d.n;
<font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "flushinterval")) {
			pData-&gt;iFlushInterval = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "veryrobustzip")) {
			pData-&gt;bVeryRobustZip = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "asyncwriting")) {
			pData-&gt;bUseAsyncWriter = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "flushontxend")) {
			pData-&gt;bFlushOnTXEnd = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "iobuffersize")) {</b></font>
			pData-&gt;iIOBufSize = (uint) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "dirowner")) {
			pData-&gt;dirUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "dirownernum")) {
			pData-&gt;dirUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "dirgroup")) {
			pData-&gt;dirGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "dirgroupnum")) {
			pData-&gt;dirGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "fileowner")) {
			pData-&gt;fileUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "fileownernum")) {
			pData-&gt;fileUID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "filegroup")) {
			pData-&gt;fileGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "filegroupnum")) {
			pData-&gt;fileGID = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "dircreatemode")) {
			pData-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "filecreatemode")) {
			pData-&gt;fCreateMode = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "failonchownfailure")) {
			pData-&gt;bFailOnChown = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "sync")) {
			pData-&gt;bSyncFile = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "createdirs")) {
			pData-&gt;bCreateDirs = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "file")) {
			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			CODE_STD_STRING_REQUESTnewActInst(1)
			pData-&gt;bDynamicName = 0;
		} else if(!strcmp(actpblk.descr[i].name, "dynafile")) {
			if(pData-&gt;fname != NULL) {
				parser_errmsg("omfile: both \"file\" and \"dynafile\" set, will use dynafile");
			}
<a name="1"></a>			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			CODE_STD_STRING_REQUESTnewActInst(2)
			pData-&gt;bDynamicName = 1;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "sig.provider")) {
			pData-&gt;sigprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "cry.provider")) {
			pData-&gt;cryprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "closetimeout")) {
			pData-&gt;iCloseTimeout = (int) pvals[i].val.d.n;</b></font>
		} else {
			dbgprintf("omfile: program error, non-handled "
			  "param '%s'\n", actpblk.descr[i].name);
		}
	}
	if(pData-&gt;fname == NULL) {
		parser_errmsg("omfile: either the \"file\" or "
				"\"dynafile\" parameter must be given");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(pData-&gt;sigprovName != NULL) {
		initSigprov(pData, lst);
	}
	if(pData-&gt;cryprovName != NULL) {
		CHKiRet(initCryprov(pData, lst));
	}
	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? getDfltTpl() : pData-&gt;tplName);
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
	pData-&gt;iNumTpls = 1;
	if(pData-&gt;bDynamicName) {
		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
		pData-&gt;iNumTpls = 2;
		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
				calloc(pData-&gt;iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
		pData-&gt;iCurrElt = -1;		  	}
	setupInstStatsCtrs(pData);
	if(pData-&gt;iCloseTimeout == -1) { 		pData-&gt;iCloseTimeout = (pData-&gt;bDynamicName) ? 10 : 0;
	}
	snprintf(pData-&gt;janitorID, sizeof(pData-&gt;janitorID), "omfile:%sfile:%s:%p",
		(pData-&gt;bDynamicName) ? "dyna" : "", pData-&gt;fname, pData);
	pData-&gt;janitorID[sizeof(pData-&gt;janitorID)-1] = '\0'; 
	if(pData-&gt;iCloseTimeout &gt; 0)
		janitorAddEtry(janitorCB, pData-&gt;janitorID, pData);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINparseSelectorAct
	uchar fname[MAXFNAME];
CODESTARTparseSelectorAct
	if(!strncmp((char*) p, ":omfile:", sizeof(":omfile:") - 1)) {
		p += sizeof(":omfile:") - 1;
	}
	if(!(*p == '$' || *p == '?' || *p == '/' || *p == '.' || *p == '-'))
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	CHKiRet(createInstance(&amp;pData));
	if(*p == '-') {
		pData-&gt;bSyncFile = 0;
		p++;
	} else {
		pData-&gt;bSyncFile = cs.bEnableSync;
	}
	pData-&gt;iSizeLimit = 0; 
	switch(*p) {
	case '$':
		CODE_STD_STRING_REQUESTparseSelectorAct(1)
		pData-&gt;iNumTpls = 1;
		CHKiRet(cflineParseOutchannel(pData, p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS));
		pData-&gt;bDynamicName = 0;
		break;
		CODE_STD_STRING_REQUESTparseSelectorAct(2)
		pData-&gt;iNumTpls = 2;
		++p; 		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
		pData-&gt;fname = ustrdup(fname);
		pData-&gt;bDynamicName = 1;
		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
				calloc(cs.iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
		break;
	case '/':
	case '.':
		CODE_STD_STRING_REQUESTparseSelectorAct(1)
		pData-&gt;iNumTpls = 1;
		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
		pData-&gt;fname = ustrdup(fname);
		pData-&gt;bDynamicName = 0;
		break;
	default:
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}
	pData-&gt;iDynaFileCacheSize = cs.iDynaFileCacheSize;
	pData-&gt;fCreateMode = cs.fCreateMode;
	pData-&gt;fDirCreateMode = cs.fDirCreateMode;
	pData-&gt;bCreateDirs = cs.bCreateDirs;
	pData-&gt;bFailOnChown = cs.bFailOnChown;
	pData-&gt;fileUID = cs.fileUID;
	pData-&gt;fileGID = cs.fileGID;
	pData-&gt;dirUID = cs.dirUID;
	pData-&gt;dirGID = cs.dirGID;
	pData-&gt;iZipLevel = cs.iZipLevel;
	pData-&gt;bFlushOnTXEnd = cs.bFlushOnTXEnd;
	pData-&gt;iIOBufSize = (uint) cs.iIOBufSize;
	pData-&gt;iFlushInterval = cs.iFlushInterval;
	pData-&gt;bUseAsyncWriter = cs.bUseAsyncWriter;
	pData-&gt;bVeryRobustZip = 0;		pData-&gt;iCloseTimeout = 0;		setupInstStatsCtrs(pData);
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	cs.fileUID = -1;
	cs.fileGID = -1;
	cs.dirUID = -1;
	cs.dirGID = -1;
	cs.bFailOnChown = 1;
	cs.iDynaFileCacheSize = 10;
	cs.fCreateMode = 0644;
	cs.fDirCreateMode = 0700;
	cs.bCreateDirs = 1;
	cs.bEnableSync = 0;
	cs.iZipLevel = 0;
	cs.bFlushOnTXEnd = FLUSHONTX_DFLT;
	cs.iIOBufSize = IOBUF_DFLT_SIZE;
	cs.iFlushInterval = FLUSH_INTRVL_DFLT;
	cs.bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
	free(pszFileDfltTplName);
	pszFileDfltTplName = NULL;
	return RS_RET_OK;
}
BEGINdoHUP
CODESTARTdoHUP
	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
	if(pData-&gt;bDynamicName) {
		dynaFileFreeCacheEntries(pData);
	} else {
		if(pData-&gt;pStrm != NULL) {
			closeFile(pData);
		}
	}
	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
ENDdoHUP
BEGINmodExit
CODESTARTmodExit
	objRelease(glbl, CORE_COMPONENT);
	objRelease(strm, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	DESTROY_ATOMIC_HELPER_MUT(mutClock);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMODTX_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_doHUP
ENDqueryEtryPt
BEGINmodInit(File)
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
INITLegCnfVars
	CHKiRet(objUse(strm, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	INIT_ATOMIC_HELPER_MUT(mutClock);
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	DBGPRINTF("omfile: %susing transactional output interface.\n", bCoreSupportsBatching ? "" : "not ");
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dynafilecachesize", 0, eCmdHdlrInt, setDynaFileCacheSize,
		NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileziplevel", 0, eCmdHdlrInt, NULL, &amp;cs.iZipLevel,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileflushinterval", 0, eCmdHdlrInt, NULL, &amp;cs.iFlushInterval,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileasyncwriting", 0, eCmdHdlrBinary, NULL, &amp;cs.bUseAsyncWriter,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileflushontxend", 0, eCmdHdlrBinary, NULL, &amp;cs.bFlushOnTXEnd,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileiobuffersize", 0, eCmdHdlrSize, NULL, &amp;cs.iIOBufSize,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirowner", 0, eCmdHdlrUID, NULL, &amp;cs.dirUID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirownernum", 0, eCmdHdlrInt, NULL, &amp;cs.dirUID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirgroup", 0, eCmdHdlrGID, NULL, &amp;cs.dirGID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirgroupnum", 0, eCmdHdlrInt, NULL, &amp;cs.dirGID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"fileowner", 0, eCmdHdlrUID, NULL, &amp;cs.fileUID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"fileownernum", 0, eCmdHdlrInt, NULL, &amp;cs.fileUID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filegroup", 0, eCmdHdlrGID, NULL, &amp;cs.fileGID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filegroupnum", 0, eCmdHdlrInt, NULL, &amp;cs.fileGID,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dircreatemode", 0, eCmdHdlrFileCreateMode, NULL,
		&amp;cs.fDirCreateMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filecreatemode", 0, eCmdHdlrFileCreateMode, NULL,
		&amp;cs.fCreateMode, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"createdirs", 0, eCmdHdlrBinary, NULL, &amp;cs.bCreateDirs,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"failonchownfailure", 0, eCmdHdlrBinary, NULL, &amp;cs.bFailOnChown,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileforcechown", 0, eCmdHdlrGoneAway, NULL, NULL,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionfileenablesync", 0, eCmdHdlrBinary, NULL, &amp;cs.bEnableSync,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionfiledefaulttemplate", 0, eCmdHdlrGetWord, setLegacyDfltTpl,
		NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
		NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmkubernetes.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#ifndef _GNU_SOURCE
#  define _GNU_SOURCE
#endif
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;libestr.h&gt;
#include &lt;liblognorm.h&gt;
#include &lt;json.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;curl/easy.h&gt;
#include &lt;pthread.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "module-template.h"
#include "errmsg.h"
#include "statsobj.h"
#include "regexp.h"
#include "hashtable.h"
#include "hashtable_itr.h"
#include "srUtils.h"
#include "unicode-helper.h"
#include "datetime.h"
MODULE_TYPE_OUTPUT MODULE_TYPE_KEEP MODULE_CNFNAME("mmkubernetes")
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(regexp)
DEFobjCurrIf(statsobj)
DEFobjCurrIf(datetime)
#define HAVE_LOADSAMPLESFROMSTRING 1
#if defined(NO_LOADSAMPLESFROMSTRING)
#undef HAVE_LOADSAMPLESFROMSTRING
#endif
#define DFLT_FILENAME_LNRULES "rule=:/var/log/containers/%pod_name:char-to:_%_"\
	"%namespace_name:char-to:_%_%container_name_and_id:char-to:.%.log"
#define DFLT_FILENAME_RULEBASE "/etc/rsyslog.d/k8s_filename.rulebase"
#define DFLT_CONTAINER_LNRULES "rule=:%k8s_prefix:char-to:_%_%container_name:char-to:.%."\
	"%container_hash:char-to:_%_"\
	"%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%\n"\
	"rule=:%k8s_prefix:char-to:_%_%container_name:char-to:_%_"\
	"%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%"
#define DFLT_CONTAINER_RULEBASE "/etc/rsyslog.d/k8s_container_name.rulebase"
#define DFLT_SRCMD_PATH "$!metadata!filename"
#define DFLT_DSTMD_PATH "$!"
#define DFLT_DE_DOT 1 #define DFLT_DE_DOT_SEPARATOR "_"
#define DFLT_CONTAINER_NAME "$!CONTAINER_NAME" #define DFLT_CONTAINER_ID_FULL "$!CONTAINER_ID_FULL" #define DFLT_KUBERNETES_URL "https://kubernetes.default.svc.cluster.local:443"
#if defined(ENABLE_OPENSSL) &amp;&amp; defined(X509_V_FLAG_PARTIAL_CHAIN)
#define SUPPORT_SSL_PARTIAL_CHAIN 1
#endif
struct cache_entry_s {
	time_t ttl; 	void *data; };
static struct cache_s {
	const uchar *kbUrl;
	struct hashtable *mdHt;
	struct hashtable *nsHt;
	pthread_mutex_t *cacheMtx;
	int lastBusyTime; 	time_t expirationTime; } **caches;
typedef struct {
	int nmemb;
	uchar **patterns;
	regex_t *regexps;
} annotation_match_t;
struct modConfData_s {
	rsconf_t *pConf;		uchar *kubernetesUrl;		uchar *srcMetadataPath;		uchar *dstMetadataPath;		uchar *caCertFile; 	uchar *myCertFile; 	uchar *myPrivKeyFile; 	sbool allowUnsignedCerts; 	sbool skipVerifyHost; 	uchar *token; 	uchar *tokenFile; 	sbool de_dot; 	uchar *de_dot_separator; 	size_t de_dot_separator_len; 	annotation_match_t annotation_match; 	char *fnRules; 	uchar *fnRulebase; 	char *contRules; 	uchar *contRulebase; 	int busyRetryInterval; 	sbool sslPartialChain; 	int cacheEntryTTL; 	int cacheExpireInterval; };
typedef struct _instanceData {
	msgPropDescr_t *contNameDescr; 	msgPropDescr_t *contIdFullDescr; 	struct cache_s *cache;
	int busyRetryInterval; 	sbool sslPartialChain; 	int cacheEntryTTL; 	int cacheExpireInterval; } instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	CURL *curlCtx;
	struct curl_slist *curlHdr;
	char *curlRply;
	size_t curlRplyLen;
	statsobj_t *stats; 	STATSCOUNTER_DEF(k8sRecordSeen, mutK8sRecordSeen);
	STATSCOUNTER_DEF(namespaceMetadataSuccess, mutNamespaceMetadataSuccess);
	STATSCOUNTER_DEF(namespaceMetadataNotFound, mutNamespaceMetadataNotFound);
	STATSCOUNTER_DEF(namespaceMetadataBusy, mutNamespaceMetadataBusy);
	STATSCOUNTER_DEF(namespaceMetadataError, mutNamespaceMetadataError);
	STATSCOUNTER_DEF(podMetadataSuccess, mutPodMetadataSuccess);
	STATSCOUNTER_DEF(podMetadataNotFound, mutPodMetadataNotFound);
	STATSCOUNTER_DEF(podMetadataBusy, mutPodMetadataBusy);
	STATSCOUNTER_DEF(podMetadataError, mutPodMetadataError);
	STATSCOUNTER_DEF(podCacheNumEntries, mutPodCacheNumEntries);
	STATSCOUNTER_DEF(namespaceCacheNumEntries, mutNamespaceCacheNumEntries);
	STATSCOUNTER_DEF(podCacheHits, mutPodCacheHits);
	STATSCOUNTER_DEF(namespaceCacheHits, mutNamespaceCacheHits);
	STATSCOUNTER_DEF(podCacheMisses, mutPodCacheMisses);
	STATSCOUNTER_DEF(namespaceCacheMisses, mutNamespaceCacheMisses);
} wrkrInstanceData_t;
static struct cnfparamdescr modpdescr[] = {
	{ "kubernetesurl", eCmdHdlrString, 0 },
	{ "srcmetadatapath", eCmdHdlrString, 0 },
	{ "dstmetadatapath", eCmdHdlrString, 0 },
	{ "tls.cacert", eCmdHdlrString, 0 },
	{ "tls.mycert", eCmdHdlrString, 0 },
	{ "tls.myprivkey", eCmdHdlrString, 0 },
<a name="0"></a>	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
	{ "skipverifyhost", eCmdHdlrBinary, 0 },
	{ "token", eCmdHdlrString, 0 },
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "tokenfile", eCmdHdlrString, 0 },
	{ "annotation_match", eCmdHdlrArray, 0 },
	{ "de_dot", eCmdHdlrBinary, 0 },
	{ "de_dot_separator", eCmdHdlrString, 0 },
	{ "filenamerulebase", eCmdHdlrString, 0 },
	{ "containerrulebase", eCmdHdlrString, 0 },
	{ "busyretryinterval", eCmdHdlrInt, 0 },
	{ "sslpartialchain", eCmdHdlrBinary, 0 },
	{ "cacheentryttl", eCmdHdlrInt, 0 },
	{ "cacheexpireinterval", eCmdHdlrInt, 0 }
#if HAVE_LOADSAMPLESFROMSTRING == 1
	,
	{ "filenamerules", eCmdHdlrArray, 0 },
	{ "containerrules", eCmdHdlrArray, 0 }
#endif
};
static struct cnfparamblk modpblk = {
	CNFPARAMBLK_VERSION,
	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	modpdescr
};
static struct cnfparamdescr actpdescr[] = {
	{ "kubernetesurl", eCmdHdlrString, 0 },
	{ "srcmetadatapath", eCmdHdlrString, 0 },
	{ "dstmetadatapath", eCmdHdlrString, 0 },
	{ "tls.cacert", eCmdHdlrString, 0 },
	{ "tls.mycert", eCmdHdlrString, 0 },
	{ "tls.myprivkey", eCmdHdlrString, 0 },
	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
	{ "skipverifyhost", eCmdHdlrBinary, 0 },
	{ "token", eCmdHdlrString, 0 },
	{ "tokenfile", eCmdHdlrString, 0 },
	{ "annotation_match", eCmdHdlrArray, 0 },
	{ "de_dot", eCmdHdlrBinary, 0 },
	{ "de_dot_separator", eCmdHdlrString, 0 },
	{ "filenamerulebase", eCmdHdlrString, 0 },
	{ "containerrulebase", eCmdHdlrString, 0 },
	{ "busyretryinterval", eCmdHdlrInt, 0 },
	{ "sslpartialchain", eCmdHdlrBinary, 0 },
	{ "cacheentryttl", eCmdHdlrInt, 0 },
	{ "cacheexpireinterval", eCmdHdlrInt, 0 }
#if HAVE_LOADSAMPLESFROMSTRING == 1
	,
	{ "filenamerules", eCmdHdlrArray, 0 },
	{ "containerrules", eCmdHdlrArray, 0 }</b></font>
#endif
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};
static modConfData_t *loadModConf = NULL;	static modConfData_t *runModConf = NULL;	
static void free_annotationmatch(annotation_match_t *match) {
	if (match) {
		for(int ii = 0 ; ii &lt; match-&gt;nmemb; ++ii) {
			if (match-&gt;patterns)
				free(match-&gt;patterns[ii]);
			if (match-&gt;regexps)
				regexp.regfree(&amp;match-&gt;regexps[ii]);
		}
		free(match-&gt;patterns);
		match-&gt;patterns = NULL;
		free(match-&gt;regexps);
		match-&gt;regexps = NULL;
		match-&gt;nmemb = 0;
	}
}
static int init_annotationmatch(annotation_match_t *match, struct cnfarray *ar) {
	DEFiRet;
	match-&gt;nmemb = ar-&gt;nmemb;
	CHKmalloc(match-&gt;patterns = calloc(sizeof(uchar*), match-&gt;nmemb));
	CHKmalloc(match-&gt;regexps = calloc(sizeof(regex_t), match-&gt;nmemb));
	for(int jj = 0; jj &lt; ar-&gt;nmemb; ++jj) {
		int rexret = 0;
		match-&gt;patterns[jj] = (uchar*)es_str2cstr(ar-&gt;arr[jj], NULL);
		rexret = regexp.regcomp(&amp;match-&gt;regexps[jj],
				(char *)match-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
		if (0 != rexret) {
			char errMsg[512];
			regexp.regerror(rexret, &amp;match-&gt;regexps[jj], errMsg, sizeof(errMsg));
			iRet = RS_RET_CONFIG_ERROR;
			LogError(0, iRet,
					"error: could not compile annotation_match string [%s]"
					" into an extended regexp - %d: %s\n",
					match-&gt;patterns[jj], rexret, errMsg);
			break;
		}
	}
finalize_it:
	if (iRet)
		free_annotationmatch(match);
	RETiRet;
}
static int copy_annotationmatch(annotation_match_t *src, annotation_match_t *dest) {
	DEFiRet;
	dest-&gt;nmemb = src-&gt;nmemb;
	CHKmalloc(dest-&gt;patterns = malloc(sizeof(uchar*) * dest-&gt;nmemb));
	CHKmalloc(dest-&gt;regexps = calloc(sizeof(regex_t), dest-&gt;nmemb));
	for(int jj = 0 ; jj &lt; src-&gt;nmemb ; ++jj) {
		CHKmalloc(dest-&gt;patterns[jj] = (uchar*)strdup((char *)src-&gt;patterns[jj]));
		regexp.regcomp(&amp;dest-&gt;regexps[jj], (char *)dest-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
	}
finalize_it:
	if (iRet)
	free_annotationmatch(dest);
	RETiRet;
}
static struct json_object *match_annotations(annotation_match_t *match,
		struct json_object *annotations) {
	struct json_object *ret = NULL;
	for (int jj = 0; jj &lt; match-&gt;nmemb; ++jj) {
		struct json_object_iterator it = json_object_iter_begin(annotations);
		struct json_object_iterator itEnd = json_object_iter_end(annotations);
		for (;!json_object_iter_equal(&amp;it, &amp;itEnd); json_object_iter_next(&amp;it)) {
			const char *const key = json_object_iter_peek_name(&amp;it);
			if (!ret || !fjson_object_object_get_ex(ret, key, NULL)) {
				if (!regexp.regexec(&amp;match-&gt;regexps[jj], key, 0, NULL, 0)) {
					if (!ret) {
						ret = json_object_new_object();
					}
					json_object_object_add(ret, key,
						json_object_get(json_object_iter_peek_value(&amp;it)));
				}
			}
		}
	}
	return ret;
}
static struct json_object *de_dot_json_object(struct json_object *jobj,
		const char *delim, size_t delim_len) {
	struct json_object *ret = NULL;
	struct json_object_iterator it = json_object_iter_begin(jobj);
	struct json_object_iterator itEnd = json_object_iter_end(jobj);
	es_str_t *new_es_key = NULL;
	DEFiRet;
	ret = json_object_new_object();
	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
		const char *const key = json_object_iter_peek_name(&amp;it);
		const char *cc = strstr(key, ".");
		if (NULL == cc) {
			json_object_object_add(ret, key,
					json_object_get(json_object_iter_peek_value(&amp;it)));
		} else {
			char *new_key = NULL;
			const char *prevcc = key;
			new_es_key = es_newStrFromCStr(key, (es_size_t)(cc-prevcc));
			while (cc) {
				if (es_addBuf(&amp;new_es_key, (char *)delim, (es_size_t)delim_len))
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				cc += 1; 				prevcc = cc; 				if ((cc = strstr(prevcc, ".")) || (cc = strchr(prevcc, '\0'))) {
					if (es_addBuf(&amp;new_es_key, (char *)prevcc, (es_size_t)(cc-prevcc)))
						ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
					if (!*cc)
						cc = NULL; 				}
			}
			new_key = es_str2cstr(new_es_key, NULL);
			es_deleteStr(new_es_key);
			new_es_key = NULL;
			json_object_object_add(ret, new_key,
					json_object_get(json_object_iter_peek_value(&amp;it)));
			free(new_key);
		}
		json_object_iter_next(&amp;it);
	}
finalize_it:
	if (iRet != RS_RET_OK) {
		json_object_put(ret);
		ret = NULL;
	}
	if (new_es_key)
		es_deleteStr(new_es_key);
	return ret;
}
static void parse_labels_annotations(struct json_object *jMetadata,
		annotation_match_t *match, sbool de_dot,
		const char *delim, size_t delim_len) {
	struct json_object *jo = NULL;
	if (fjson_object_object_get_ex(jMetadata, "annotations", &amp;jo)) {
		if ((jo = match_annotations(match, jo)))
			json_object_object_add(jMetadata, "annotations", jo);
		else
			json_object_object_del(jMetadata, "annotations");
	}
	if (de_dot) {
		struct json_object *jo2 = NULL;
		if (fjson_object_object_get_ex(jMetadata, "annotations", &amp;jo)) {
			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
				json_object_object_add(jMetadata, "annotations", jo2);
			}
		}
		if (fjson_object_object_get_ex(jMetadata, "labels", &amp;jo)) {
			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
				json_object_object_add(jMetadata, "labels", jo2);
			}
		}
	}
}
#if HAVE_LOADSAMPLESFROMSTRING == 1
static int array_to_rules(struct cnfarray *ar, char **rules) {
	DEFiRet;
	es_str_t *tmpstr = NULL;
	es_size_t size = 0;
	if (rules == NULL)
		FINALIZE;
	*rules = NULL;
	if (!ar-&gt;nmemb)
		FINALIZE;
	for (int jj = 0; jj &lt; ar-&gt;nmemb; jj++)
		size += es_strlen(ar-&gt;arr[jj]);
	if (!size)
		FINALIZE;
	CHKmalloc(tmpstr = es_newStr(size));
	CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[0])));
	CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\n")));
	for(int jj=1; jj &lt; ar-&gt;nmemb; ++jj) {
		CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[jj])));
		CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\n")));
	}
	CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\0")));
	CHKmalloc(*rules = es_str2cstr(tmpstr, NULL));
finalize_it:
	if (tmpstr) {
		es_deleteStr(tmpstr);
	}
	if (iRet != RS_RET_OK) {
		free(*rules);
		*rules = NULL;
	}
	RETiRet;
}
#endif
static void
errCallBack(void __attribute__((unused)) *cookie, const char *msg,
	    size_t __attribute__((unused)) lenMsg)
{
	LogError(0, RS_RET_ERR_LIBLOGNORM, "liblognorm error: %s", msg);
}
static rsRetVal
set_lnctx(ln_ctx *ctxln, char *instRules, uchar *instRulebase, char *modRules, uchar *modRulebase)
{
	DEFiRet;
	if (ctxln == NULL)
		FINALIZE;
	CHKmalloc(*ctxln = ln_initCtx());
	ln_setErrMsgCB(*ctxln, errCallBack, NULL);
	if(instRules) {
#if HAVE_LOADSAMPLESFROMSTRING == 1
		if(ln_loadSamplesFromString(*ctxln, instRules) !=0) {
			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rules '%s' "
					"could not be loaded", instRules);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
#else
		(void)instRules;
#endif
	} else if(instRulebase) {
		if(ln_loadSamples(*ctxln, (char*) instRulebase) != 0) {
			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
					"could not be loaded", instRulebase);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
	} else if(modRules) {
#if HAVE_LOADSAMPLESFROMSTRING == 1
		if(ln_loadSamplesFromString(*ctxln, modRules) !=0) {
			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rules '%s' "
					"could not be loaded", modRules);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
#else
		(void)modRules;
#endif
	} else if(modRulebase) {
		if(ln_loadSamples(*ctxln, (char*) modRulebase) != 0) {
			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
					"could not be loaded", modRulebase);
			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
		}
	}
finalize_it:
	if (iRet != RS_RET_OK){
		ln_exitCtx(*ctxln);
		*ctxln = NULL;
	}
	RETiRet;
}
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
ENDbeginCnfLoad
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
	FILE *fp = NULL;
	int ret;
	char errStr[1024];
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmkubernetes: "
			"error processing module config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for mmkubernetes:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	loadModConf-&gt;de_dot = DFLT_DE_DOT;
	loadModConf-&gt;busyRetryInterval = DFLT_BUSY_RETRY_INTERVAL;
	loadModConf-&gt;sslPartialChain = DFLT_SSL_PARTIAL_CHAIN;
	loadModConf-&gt;cacheEntryTTL = DFLT_CACHE_ENTRY_TTL;
	loadModConf-&gt;cacheExpireInterval = DFLT_CACHE_EXPIRE_INTERVAL;
<a name="1"></a>	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "kubernetesurl")) {
			free(loadModConf-&gt;kubernetesUrl);
			loadModConf-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "srcmetadatapath")) {
			free(loadModConf-&gt;srcMetadataPath);
			loadModConf-&gt;srcMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "dstmetadatapath")) {
			free(loadModConf-&gt;dstMetadataPath);
			loadModConf-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "tls.cacert")) {
			free(loadModConf-&gt;caCertFile);
			loadModConf-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
			fp = fopen((const char*)loadModConf-&gt;caCertFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: 'tls.cacert' file %s couldn't be accessed: %s\n",
						loadModConf-&gt;caCertFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, "tls.mycert")) {
			free(loadModConf-&gt;myCertFile);
			loadModConf-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;myCertFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
						loadModConf-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, "tls.myprivkey")) {
			loadModConf-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;myPrivKeyFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
						loadModConf-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, "allowunsignedcerts")) {
			loadModConf-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "skipverifyhost")) {
			loadModConf-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "token")) {
			free(loadModConf-&gt;token);
			loadModConf-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "tokenfile")) {
			free(loadModConf-&gt;tokenFile);
			loadModConf-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;tokenFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: token file %s couldn't be accessed: %s\n",
						loadModConf-&gt;tokenFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(modpblk.descr[i].name, "annotation_match")) {
			free_annotationmatch(&amp;loadModConf-&gt;annotation_match);
			if ((ret = init_annotationmatch(&amp;loadModConf-&gt;annotation_match, pvals[i].val.d.ar)))
				ABORT_FINALIZE(ret);
		} else if(!strcmp(modpblk.descr[i].name, "de_dot")) {
			loadModConf-&gt;de_dot = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "de_dot_separator")) {
			free(loadModConf-&gt;de_dot_separator);
			loadModConf-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, "filenamerules")) {
			free(loadModConf-&gt;fnRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;fnRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, "filenamerulebase")) {
			free(loadModConf-&gt;fnRulebase);
			loadModConf-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;fnRulebase, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: filenamerulebase file %s couldn't be accessed: %s\n",
						loadModConf-&gt;fnRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, "containerrules")) {
			free(loadModConf-&gt;contRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;contRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, "containerrulebase")) {
			free(loadModConf-&gt;contRulebase);
			loadModConf-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)loadModConf-&gt;contRulebase, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: containerrulebase file %s couldn't be accessed: %s\n",
						loadModConf-&gt;contRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
<a name="2"></a>				fclose(fp);
				fp = NULL;
			}
<font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "busyretryinterval")) {
			loadModConf-&gt;busyRetryInterval = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "sslpartialchain")) {
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
			loadModConf-&gt;sslPartialChain = pvals[i].val.d.n;
#else
			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
					"sslpartialchain is only supported for OpenSSL\n");
#endif
		} else if(!strcmp(modpblk.descr[i].name, "cacheentryttl")) {
			loadModConf-&gt;cacheEntryTTL = pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "cacheexpireinterval")) {
			loadModConf-&gt;cacheExpireInterval = pvals[i].val.d.n;
		} else {</b></font>
			dbgprintf("mmkubernetes: program error, non-handled "
				"param '%s' in module() block\n", modpblk.descr[i].name);
		}
	}
#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (loadModConf-&gt;fnRules &amp;&amp; loadModConf-&gt;fnRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
				"mmkubernetes: only 1 of filenamerules or filenamerulebase may be used");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (loadModConf-&gt;contRules &amp;&amp; loadModConf-&gt;contRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
				"mmkubernetes: only 1 of containerrules or containerrulebase may be used");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
#endif
	if ((loadModConf-&gt;cacheExpireInterval &gt; -1)) {
		if ((loadModConf-&gt;cacheEntryTTL &lt; 0)) {
			LogError(0, RS_RET_CONFIG_ERROR,
					"mmkubernetes: cacheentryttl value [%d] is invalid - "
					"value must be 0 or greater",
					loadModConf-&gt;cacheEntryTTL);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}
	if(loadModConf-&gt;srcMetadataPath == NULL)
		loadModConf-&gt;srcMetadataPath = (uchar *) strdup(DFLT_SRCMD_PATH);
	if(loadModConf-&gt;dstMetadataPath == NULL)
		loadModConf-&gt;dstMetadataPath = (uchar *) strdup(DFLT_DSTMD_PATH);
	if(loadModConf-&gt;de_dot_separator == NULL)
		loadModConf-&gt;de_dot_separator = (uchar *) strdup(DFLT_DE_DOT_SEPARATOR);
	if(loadModConf-&gt;de_dot_separator)
		loadModConf-&gt;de_dot_separator_len = strlen((const char *)loadModConf-&gt;de_dot_separator);
#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (loadModConf-&gt;fnRules == NULL &amp;&amp; loadModConf-&gt;fnRulebase == NULL)
		loadModConf-&gt;fnRules = strdup(DFLT_FILENAME_LNRULES);
	if (loadModConf-&gt;contRules == NULL &amp;&amp; loadModConf-&gt;contRulebase == NULL)
		loadModConf-&gt;contRules = strdup(DFLT_CONTAINER_LNRULES);
#else
	if (loadModConf-&gt;fnRulebase == NULL)
		loadModConf-&gt;fnRulebase = (uchar *)strdup(DFLT_FILENAME_RULEBASE);
	if (loadModConf-&gt;contRulebase == NULL)
		loadModConf-&gt;contRulebase = (uchar *)strdup(DFLT_CONTAINER_RULEBASE);
#endif
	caches = calloc(1, sizeof(struct cache_s *));
finalize_it:
	if (fp)
		fclose(fp);
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINcreateInstance
CODESTARTcreateInstance
ENDcreateInstance
BEGINfreeInstance
CODESTARTfreeInstance
	free(pData-&gt;kubernetesUrl);
	msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
	free(pData-&gt;srcMetadataDescr);
	free(pData-&gt;dstMetadataPath);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
	free(pData-&gt;token);
	free(pData-&gt;tokenFile);
	free(pData-&gt;fnRules);
	free(pData-&gt;fnRulebase);
	ln_exitCtx(pData-&gt;fnCtxln);
	free(pData-&gt;contRules);
	free(pData-&gt;contRulebase);
	ln_exitCtx(pData-&gt;contCtxln);
	free_annotationmatch(&amp;pData-&gt;annotation_match);
	free(pData-&gt;de_dot_separator);
	msgPropDescrDestruct(pData-&gt;contNameDescr);
	free(pData-&gt;contNameDescr);
	msgPropDescrDestruct(pData-&gt;contIdFullDescr);
	free(pData-&gt;contIdFullDescr);
ENDfreeInstance
static size_t curlCB(char *data, size_t size, size_t nmemb, void *usrptr)
{
	DEFiRet;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) usrptr;
	char * buf;
	size_t newlen;
	newlen = pWrkrData-&gt;curlRplyLen + size * nmemb;
	CHKmalloc(buf = realloc(pWrkrData-&gt;curlRply, newlen));
	memcpy(buf + pWrkrData-&gt;curlRplyLen, data, size * nmemb);
	pWrkrData-&gt;curlRply = buf;
	pWrkrData-&gt;curlRplyLen = newlen;
finalize_it:
	if (iRet != RS_RET_OK) {
		return 0;
	}
	return size * nmemb;
}
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
static CURLcode set_ssl_partial_chain(CURL *curl, void *ssl_ctx, void *userptr)
{
	(void)userptr; 	CURLcode rv = CURLE_ABORTED_BY_CALLBACK;
	X509_STORE *store = NULL;
	store = SSL_CTX_get_cert_store((SSL_CTX *)ssl_ctx);
	if(!store)
		goto finalize_it;
	if(!X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN))
		goto finalize_it;
	rv = CURLE_OK;
finalize_it:
	return rv;
}
#endif
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	CURL *ctx;
	struct curl_slist *hdr = NULL;
	char *tokenHdr = NULL;
	FILE *fp = NULL;
	char *token = NULL;
	char *statsName = NULL;
	CHKiRet(statsobj.Construct(&amp;(pWrkrData-&gt;stats)));
	if ((-1 == asprintf(&amp;statsName, "mmkubernetes(%s)", pWrkrData-&gt;pData-&gt;kubernetesUrl)) ||
		(!statsName)) {
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	CHKiRet(statsobj.SetName(pWrkrData-&gt;stats, (uchar *)statsName));
	free(statsName);
	statsName = NULL;
	CHKiRet(statsobj.SetOrigin(pWrkrData-&gt;stats, UCHAR_CONSTANT("mmkubernetes")));
	STATSCOUNTER_INIT(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("recordseen"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;k8sRecordSeen)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataSuccess, pWrkrData-&gt;mutNamespaceMetadataSuccess);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatasuccess"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataSuccess)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataNotFound, pWrkrData-&gt;mutNamespaceMetadataNotFound);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatanotfound"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataNotFound)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataBusy, pWrkrData-&gt;mutNamespaceMetadataBusy);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatabusy"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataBusy)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataError, pWrkrData-&gt;mutNamespaceMetadataError);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadataerror"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataError)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatasuccess"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataSuccess)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatanotfound"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataNotFound)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatabusy"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataBusy)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadataerror"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataError)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheNumEntries, pWrkrData-&gt;mutNamespaceCacheNumEntries);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachenumentries"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheNumEntries)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheNumEntries, pWrkrData-&gt;mutPodCacheNumEntries);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachenumentries"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheNumEntries)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheHits, pWrkrData-&gt;mutNamespaceCacheHits);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachehits"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheHits)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheHits, pWrkrData-&gt;mutPodCacheHits);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachehits"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheHits)));
	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheMisses, pWrkrData-&gt;mutNamespaceCacheMisses);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachemisses"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheMisses)));
	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheMisses, pWrkrData-&gt;mutPodCacheMisses);
	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachemisses"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheMisses)));
	CHKiRet(statsobj.ConstructFinalize(pWrkrData-&gt;stats));
	hdr = curl_slist_append(hdr, "Content-Type: text/json; charset=utf-8");
	if (pWrkrData-&gt;pData-&gt;token) {
		if ((-1 == asprintf(&amp;tokenHdr, "Authorization: Bearer %s", pWrkrData-&gt;pData-&gt;token)) ||
			(!tokenHdr)) {
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
	} else if (pWrkrData-&gt;pData-&gt;tokenFile) {
		struct stat statbuf;
		fp = fopen((const char*)pWrkrData-&gt;pData-&gt;tokenFile, "r");
		if (fp &amp;&amp; !fstat(fileno(fp), &amp;statbuf)) {
			size_t bytesread;
			CHKmalloc(token = malloc((statbuf.st_size+1)*sizeof(char)));
			if (0 &lt; (bytesread = fread(token, sizeof(char), statbuf.st_size, fp))) {
				token[bytesread] = '\0';
				if ((-1 == asprintf(&amp;tokenHdr, "Authorization: Bearer %s", token)) ||
					(!tokenHdr)) {
					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
				}
			}
			free(token);
			token = NULL;
		}
		if (fp) {
			fclose(fp);
			fp = NULL;
		}
	}
	if (tokenHdr) {
		hdr = curl_slist_append(hdr, tokenHdr);
		free(tokenHdr);
	}
	pWrkrData-&gt;curlHdr = hdr;
	ctx = curl_easy_init();
	curl_easy_setopt(ctx, CURLOPT_HTTPHEADER, hdr);
	curl_easy_setopt(ctx, CURLOPT_WRITEFUNCTION, curlCB);
	curl_easy_setopt(ctx, CURLOPT_WRITEDATA, pWrkrData);
	if(pWrkrData-&gt;pData-&gt;caCertFile)
		curl_easy_setopt(ctx, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
	if(pWrkrData-&gt;pData-&gt;myCertFile)
		curl_easy_setopt(ctx, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
		curl_easy_setopt(ctx, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYPEER, 0);
	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYHOST, 0);
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
	if(pWrkrData-&gt;pData-&gt;sslPartialChain) {
		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_FUNCTION, set_ssl_partial_chain);
		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_DATA, NULL);
	}
#endif
	pWrkrData-&gt;curlCtx = ctx;
finalize_it:
	free(token);
	free(statsName);
	if ((iRet != RS_RET_OK) &amp;&amp; pWrkrData-&gt;stats) {
		statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
	}
	if (fp) {
		fclose(fp);
	}
ENDcreateWrkrInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	curl_easy_cleanup(pWrkrData-&gt;curlCtx);
	curl_slist_free_all(pWrkrData-&gt;curlHdr);
	statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
ENDfreeWrkrInstance
static void
hashtable_json_object_put(void *jso)
{
	json_object_put((struct fjson_object *)jso);
}
static void
cache_entry_free(struct cache_entry_s *cache_entry)
{
	if (NULL != cache_entry) {
		if (cache_entry-&gt;data) {
			hashtable_json_object_put(cache_entry-&gt;data);
			cache_entry-&gt;data = NULL;
		}
		free(cache_entry);
	}
}
static void
cache_entry_free_raw(void *cache_entry_void)
{
	cache_entry_free((struct cache_entry_s *)cache_entry_void);
}
static struct cache_s *
cacheNew(instanceData *pData)
{
	DEFiRet;
	struct cache_s *cache = NULL;
	time_t now;
	int need_mutex_destroy = 0;
	CHKmalloc(cache = (struct cache_s *)calloc(1, sizeof(struct cache_s)));
	CHKmalloc(cache-&gt;cacheMtx = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)));
	CHKmalloc(cache-&gt;mdHt = create_hashtable(100, hash_from_string,
		key_equals_string, cache_entry_free_raw));
	CHKmalloc(cache-&gt;nsHt = create_hashtable(100, hash_from_string,
		key_equals_string, cache_entry_free_raw));
	CHKiConcCtrl(pthread_mutex_init(cache-&gt;cacheMtx, NULL));
	need_mutex_destroy = 1;
	datetime.GetTime(&amp;now);
	cache-&gt;kbUrl = pData-&gt;kubernetesUrl;
	cache-&gt;expirationTime = 0;
	if (pData-&gt;cacheExpireInterval &gt; -1)
		cache-&gt;expirationTime = pData-&gt;cacheExpireInterval + pData-&gt;cacheEntryTTL + now;
	cache-&gt;lastBusyTime = 0;
	dbgprintf("mmkubernetes: created cache mdht [%p] nsht [%p]\n",
			cache-&gt;mdHt, cache-&gt;nsHt);
finalize_it:
	if (iRet != RS_RET_OK) {
	        LogError(errno, iRet, "mmkubernetes: cacheNew: unable to create metadata cache for %s",
	                 pData-&gt;kubernetesUrl);
		if (cache) {
			if (cache-&gt;mdHt)
				hashtable_destroy(cache-&gt;mdHt, 1);
			if (cache-&gt;nsHt)
				hashtable_destroy(cache-&gt;nsHt, 1);
			if (cache-&gt;cacheMtx) {
				if (need_mutex_destroy)
					pthread_mutex_destroy(cache-&gt;cacheMtx);
				free(cache-&gt;cacheMtx);
			}
			free(cache);
			cache = NULL;
		}
	}
	return cache;
}
static void cacheFree(struct cache_s *cache)
{
	hashtable_destroy(cache-&gt;mdHt, 1);
	hashtable_destroy(cache-&gt;nsHt, 1);
	pthread_mutex_destroy(cache-&gt;cacheMtx);
	free(cache-&gt;cacheMtx);
	free(cache);
}
static struct cache_entry_s *cache_entry_new(time_t ttl, struct fjson_object *jso)
{
	DEFiRet;
	struct cache_entry_s *cache_entry = NULL;
	CHKmalloc(cache_entry = malloc(sizeof(struct cache_entry_s)));
	cache_entry-&gt;ttl = ttl;
	cache_entry-&gt;data = (void *)jso;
finalize_it:
	if (iRet) {
		free(cache_entry);
		cache_entry = NULL;
	}
	return cache_entry;
}
static int cache_delete_expired_entries(wrkrInstanceData_t *pWrkrData, int isnsmd, time_t now)
{
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
	struct hashtable_itr *itr = NULL;
	int more;
	if ((pWrkrData-&gt;pData-&gt;cacheExpireInterval &lt; 0) || (now &lt; pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime)) {
		return 0; 	}
	pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime = now + pWrkrData-&gt;pData-&gt;cacheExpireInterval;
	if (hashtable_count(ht) &lt; 1)
		return 1; 
	itr = hashtable_iterator(ht);
	if (NULL == itr)
		return 1; 
	do {
		struct cache_entry_s *cache_entry = (struct cache_entry_s *)hashtable_iterator_value(itr);
		if (now &gt;= cache_entry-&gt;ttl) {
			cache_entry_free(cache_entry);
			if (isnsmd) {
				STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
						 pWrkrData-&gt;mutNamespaceCacheNumEntries);
			} else {
				STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
						 pWrkrData-&gt;mutPodCacheNumEntries);
			}
			more = hashtable_iterator_remove(itr);
		} else {
			more = hashtable_iterator_advance(itr);
		}
	} while (more);
	free(itr);
	dbgprintf("mmkubernetes: cache_delete_expired_entries: cleaned [%s] cache - size is now [%llu]\n",
		  isnsmd ? "namespace" : "pod",
		  isnsmd ? pWrkrData-&gt;namespaceCacheNumEntries : pWrkrData-&gt;podCacheNumEntries);
	return 1;
}
static struct fjson_object *
cache_entry_get(wrkrInstanceData_t *pWrkrData,
		int isnsmd, const char *key, time_t now)
{
	struct fjson_object *jso = NULL;
	struct cache_entry_s *cache_entry = NULL;
	int checkttl = 1;
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
	if (cache_delete_expired_entries(pWrkrData, isnsmd, now))
		checkttl = 0; 	cache_entry = (struct cache_entry_s *)hashtable_search(ht, (void *)key);
	if (cache_entry &amp;&amp; checkttl &amp;&amp; (now &gt;= cache_entry-&gt;ttl)) {
		cache_entry = (struct cache_entry_s *)hashtable_remove(ht, (void *)key);
		if (isnsmd) {
			STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
		} else {
			STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
					 pWrkrData-&gt;mutPodCacheNumEntries);
		}
		cache_entry_free(cache_entry);
		cache_entry = NULL;
	}
	if (cache_entry) {
		jso = (struct fjson_object *)cache_entry-&gt;data;
		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheHits,
					 pWrkrData-&gt;mutNamespaceCacheHits);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheHits,
					 pWrkrData-&gt;mutPodCacheHits);
		}
		dbgprintf("mmkubernetes: cache_entry_get: cache hit for [%s] cache key [%s] - hits is now [%llu]\n",
			  isnsmd ? "namespace" : "pod", key,
			  isnsmd ? pWrkrData-&gt;namespaceCacheHits : pWrkrData-&gt;podCacheHits);
	} else {
		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheMisses,
					 pWrkrData-&gt;mutNamespaceCacheMisses);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheMisses,
					 pWrkrData-&gt;mutPodCacheMisses);
		}
		dbgprintf("mmkubernetes: cache_entry_get: cache miss for [%s] cache key [%s] - misses is now [%llu]\n",
			  isnsmd ? "namespace" : "pod", key,
			  isnsmd ? pWrkrData-&gt;namespaceCacheMisses : pWrkrData-&gt;podCacheMisses);
	}
	return jso;
}
static rsRetVal
cache_entry_add(wrkrInstanceData_t *pWrkrData,
		int isnsmd, const char *key, struct fjson_object *jso, time_t now, const int bDupKey)
{
	DEFiRet;
	struct cache_entry_s *cache_entry = NULL;
	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
	(void)cache_delete_expired_entries(pWrkrData, isnsmd, now);
	CHKmalloc(cache_entry = cache_entry_new(now + pWrkrData-&gt;pData-&gt;cacheEntryTTL, jso));
	if (cache_entry) {
		if (!hashtable_insert(ht, (void *)(bDupKey ? strdup(key) : key), cache_entry))
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		if (isnsmd) {
			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheNumEntries,
					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podCacheNumEntries,
					 pWrkrData-&gt;mutPodCacheNumEntries);
		}
		cache_entry = NULL;
	}
finalize_it:
	if (cache_entry)
		cache_entry_free(cache_entry);
	return iRet;
}
static struct fjson_object *cache_entry_get_md(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
{
	return cache_entry_get(pWrkrData, 0, key, now);
}
static struct fjson_object *cache_entry_get_nsmd(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
{
	return cache_entry_get(pWrkrData, 1, key, now);
}
static rsRetVal cache_entry_add_md(wrkrInstanceData_t *pWrkrData, const char *key,
				   struct fjson_object *jso, time_t now)
{
	return cache_entry_add(pWrkrData, 0, key, jso, now, 0);
}
static rsRetVal cache_entry_add_nsmd(wrkrInstanceData_t *pWrkrData, const char *key,
				     struct fjson_object *jso, time_t now)
{
	return cache_entry_add(pWrkrData, 1, key, jso, now, 1);
}
BEGINnewActInst
	struct cnfparamvals *pvals = NULL;
	int i;
	FILE *fp = NULL;
	char *rxstr = NULL;
	char *srcMetadataPath = NULL;
	char errStr[1024];
CODESTARTnewActInst
	DBGPRINTF("newActInst (mmkubernetes)\n");
	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmkubernetes: "
			"error processing config parameters [action(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("action param blk in mmkubernetes:\n");
		cnfparamsPrint(&amp;actpblk, pvals);
	}
	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
	CHKiRet(createInstance(&amp;pData));
	pData-&gt;de_dot = loadModConf-&gt;de_dot;
	pData-&gt;allowUnsignedCerts = loadModConf-&gt;allowUnsignedCerts;
	pData-&gt;skipVerifyHost = loadModConf-&gt;skipVerifyHost;
	pData-&gt;busyRetryInterval = loadModConf-&gt;busyRetryInterval;
	pData-&gt;sslPartialChain = loadModConf-&gt;sslPartialChain;
	pData-&gt;cacheEntryTTL = loadModConf-&gt;cacheEntryTTL;
	pData-&gt;cacheExpireInterval = loadModConf-&gt;cacheExpireInterval;
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed) {
			continue;
		} else if(!strcmp(actpblk.descr[i].name, "kubernetesurl")) {
			free(pData-&gt;kubernetesUrl);
			pData-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "srcmetadatapath")) {
			msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
			free(pData-&gt;srcMetadataDescr);
			CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
			srcMetadataPath = es_str2cstr(pvals[i].val.d.estr, NULL);
			CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, (uchar *)srcMetadataPath,
				strlen(srcMetadataPath)));
		} else if(!strcmp(actpblk.descr[i].name, "dstmetadatapath")) {
			free(pData-&gt;dstMetadataPath);
			pData-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
			free(pData-&gt;caCertFile);
			pData-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;caCertFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: certificate file %s couldn't be accessed: %s\n",
						pData-&gt;caCertFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
						pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
						pData-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "token")) {
			free(pData-&gt;token);
			pData-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "tokenfile")) {
			free(pData-&gt;tokenFile);
			pData-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;tokenFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: token file %s couldn't be accessed: %s\n",
						pData-&gt;tokenFile, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, "annotation_match")) {
			free_annotationmatch(&amp;pData-&gt;annotation_match);
			if (RS_RET_OK != (iRet = init_annotationmatch(&amp;pData-&gt;annotation_match, pvals[i].val.d.ar)))
				ABORT_FINALIZE(iRet);
		} else if(!strcmp(actpblk.descr[i].name, "de_dot")) {
			pData-&gt;de_dot = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "de_dot_separator")) {
			free(pData-&gt;de_dot_separator);
			pData-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, "filenamerules")) {
			free(pData-&gt;fnRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;fnRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, "filenamerulebase")) {
			free(pData-&gt;fnRulebase);
			pData-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;fnRulebase, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: filenamerulebase file %s couldn't be accessed: %s\n",
						pData-&gt;fnRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
#if HAVE_LOADSAMPLESFROMSTRING == 1
		} else if(!strcmp(modpblk.descr[i].name, "containerrules")) {
			free(pData-&gt;contRules);
			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;contRules)));
#endif
		} else if(!strcmp(modpblk.descr[i].name, "containerrulebase")) {
			free(pData-&gt;contRulebase);
			pData-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;contRulebase, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				iRet = RS_RET_NO_FILE_ACCESS;
				LogError(0, iRet,
						"error: containerrulebase file %s couldn't be accessed: %s\n",
						pData-&gt;contRulebase, errStr);
				ABORT_FINALIZE(iRet);
			} else {
				fclose(fp);
				fp = NULL;
			}
		} else if(!strcmp(actpblk.descr[i].name, "busyretryinterval")) {
			pData-&gt;busyRetryInterval = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "sslpartialchain")) {
#if defined(SUPPORT_SSL_PARTIAL_CHAIN)
			pData-&gt;sslPartialChain = pvals[i].val.d.n;
#else
			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
					"sslpartialchain is only supported for OpenSSL\n");
#endif
		} else if(!strcmp(actpblk.descr[i].name, "cacheentryttl")) {
			pData-&gt;cacheEntryTTL = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "cacheexpireinterval")) {
			pData-&gt;cacheExpireInterval = pvals[i].val.d.n;
		} else {
			dbgprintf("mmkubernetes: program error, non-handled "
				"param '%s' in action() block\n", actpblk.descr[i].name);
		}
	}
#if HAVE_LOADSAMPLESFROMSTRING == 1
	if (pData-&gt;fnRules &amp;&amp; pData-&gt;fnRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
		    "mmkubernetes: only 1 of filenamerules or filenamerulebase may be used");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (pData-&gt;contRules &amp;&amp; pData-&gt;contRulebase) {
		LogError(0, RS_RET_CONFIG_ERROR,
			"mmkubernetes: only 1 of containerrules or containerrulebase may be used");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
#endif
	CHKiRet(set_lnctx(&amp;pData-&gt;fnCtxln, pData-&gt;fnRules, pData-&gt;fnRulebase,
			loadModConf-&gt;fnRules, loadModConf-&gt;fnRulebase));
	CHKiRet(set_lnctx(&amp;pData-&gt;contCtxln, pData-&gt;contRules, pData-&gt;contRulebase,
			loadModConf-&gt;contRules, loadModConf-&gt;contRulebase));
	if ((pData-&gt;cacheExpireInterval &gt; -1)) {
		if ((pData-&gt;cacheEntryTTL &lt; 0)) {
			LogError(0, RS_RET_CONFIG_ERROR,
					"mmkubernetes: cacheentryttl value [%d] is invalid - "
					"value must be 0 or greater",
					pData-&gt;cacheEntryTTL);
			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
		}
	}
	if(pData-&gt;kubernetesUrl == NULL) {
		if(loadModConf-&gt;kubernetesUrl == NULL) {
			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup(DFLT_KUBERNETES_URL));
		} else {
			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup((char *) loadModConf-&gt;kubernetesUrl));
		}
	}
	if(pData-&gt;srcMetadataDescr == NULL) {
		CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
		CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, loadModConf-&gt;srcMetadataPath,
			strlen((char *)loadModConf-&gt;srcMetadataPath)));
	}
	if(pData-&gt;dstMetadataPath == NULL)
		pData-&gt;dstMetadataPath = (uchar *) strdup((char *) loadModConf-&gt;dstMetadataPath);
	if(pData-&gt;caCertFile == NULL &amp;&amp; loadModConf-&gt;caCertFile)
		pData-&gt;caCertFile = (uchar *) strdup((char *) loadModConf-&gt;caCertFile);
	if(pData-&gt;myCertFile == NULL &amp;&amp; loadModConf-&gt;myCertFile)
		pData-&gt;myCertFile = (uchar *) strdup((char *) loadModConf-&gt;myCertFile);
	if(pData-&gt;myPrivKeyFile == NULL &amp;&amp; loadModConf-&gt;myPrivKeyFile)
		pData-&gt;myPrivKeyFile = (uchar *) strdup((char *) loadModConf-&gt;myPrivKeyFile);
	if(pData-&gt;token == NULL &amp;&amp; loadModConf-&gt;token)
		pData-&gt;token = (uchar *) strdup((char *) loadModConf-&gt;token);
	if(pData-&gt;tokenFile == NULL &amp;&amp; loadModConf-&gt;tokenFile)
		pData-&gt;tokenFile = (uchar *) strdup((char *) loadModConf-&gt;tokenFile);
	if(pData-&gt;de_dot_separator == NULL &amp;&amp; loadModConf-&gt;de_dot_separator)
		pData-&gt;de_dot_separator = (uchar *) strdup((char *) loadModConf-&gt;de_dot_separator);
	if((pData-&gt;annotation_match.nmemb == 0) &amp;&amp; (loadModConf-&gt;annotation_match.nmemb &gt; 0))
		copy_annotationmatch(&amp;loadModConf-&gt;annotation_match, &amp;pData-&gt;annotation_match);
	if(pData-&gt;de_dot_separator)
		pData-&gt;de_dot_separator_len = strlen((const char *)pData-&gt;de_dot_separator);
	CHKmalloc(pData-&gt;contNameDescr = malloc(sizeof(msgPropDescr_t)));
	CHKiRet(msgPropDescrFill(pData-&gt;contNameDescr, (uchar*) DFLT_CONTAINER_NAME,
			strlen(DFLT_CONTAINER_NAME)));
	CHKmalloc(pData-&gt;contIdFullDescr = malloc(sizeof(msgPropDescr_t)));
	CHKiRet(msgPropDescrFill(pData-&gt;contIdFullDescr, (uchar*) DFLT_CONTAINER_ID_FULL,
			strlen(DFLT_CONTAINER_NAME)));
	for(i = 0; caches[i] != NULL; i++) {
		if(!strcmp((char *) pData-&gt;kubernetesUrl, (char *) caches[i]-&gt;kbUrl))
			break;
	}
	if(caches[i] != NULL) {
		pData-&gt;cache = caches[i];
	} else {
		CHKmalloc(pData-&gt;cache = cacheNew(pData));
		struct cache_s **new_caches = realloc(caches, (i + 2) * sizeof(struct cache_s *));
		CHKmalloc(new_caches);
		caches = new_caches;
		caches[i] = pData-&gt;cache;
		caches[i + 1] = NULL;
	}
CODE_STD_FINALIZERnewActInst
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;actpblk);
	if(fp)
		fclose(fp);
	free(rxstr);
	free(srcMetadataPath);
ENDnewActInst
BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(strncmp((char *) p, ":mmkubernetes:", sizeof(":mmkubernetes:") - 1)) {
		LogError(0, RS_RET_LEGA_ACT_NOT_SUPPORTED,
			"mmkubernetes supports only v6+ config format, use: "
			"action(type=\"mmkubernetes\" ...)");
	}
	ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
BEGINendCnfLoad
CODESTARTendCnfLoad
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	runModConf = pModConf;
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
	int i;
	free(pModConf-&gt;kubernetesUrl);
	free(pModConf-&gt;srcMetadataPath);
	free(pModConf-&gt;dstMetadataPath);
	free(pModConf-&gt;caCertFile);
	free(pModConf-&gt;myCertFile);
	free(pModConf-&gt;myPrivKeyFile);
	free(pModConf-&gt;token);
	free(pModConf-&gt;tokenFile);
	free(pModConf-&gt;de_dot_separator);
	free(pModConf-&gt;fnRules);
	free(pModConf-&gt;fnRulebase);
	free(pModConf-&gt;contRules);
	free(pModConf-&gt;contRulebase);
	free_annotationmatch(&amp;pModConf-&gt;annotation_match);
	for(i = 0; caches[i] != NULL; i++) {
		dbgprintf("mmkubernetes: freeing cache [%d] mdht [%p] nsht [%p]\n",
				i, caches[i]-&gt;mdHt, caches[i]-&gt;nsHt);
		cacheFree(caches[i]);
	}
	free(caches);
ENDfreeCnf
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
	dbgprintf("mmkubernetes\n");
	dbgprintf("\tkubernetesUrl='%s'\n", pData-&gt;kubernetesUrl);
	dbgprintf("\tsrcMetadataPath='%s'\n", pData-&gt;srcMetadataDescr-&gt;name);
	dbgprintf("\tdstMetadataPath='%s'\n", pData-&gt;dstMetadataPath);
	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
	dbgprintf("\tallowUnsignedCerts='%d'\n", pData-&gt;allowUnsignedCerts);
	dbgprintf("\tskipVerifyHost='%d'\n", pData-&gt;skipVerifyHost);
	dbgprintf("\ttoken='%s'\n", pData-&gt;token);
	dbgprintf("\ttokenFile='%s'\n", pData-&gt;tokenFile);
	dbgprintf("\tde_dot='%d'\n", pData-&gt;de_dot);
	dbgprintf("\tde_dot_separator='%s'\n", pData-&gt;de_dot_separator);
	dbgprintf("\tfilenamerulebase='%s'\n", pData-&gt;fnRulebase);
	dbgprintf("\tcontainerrulebase='%s'\n", pData-&gt;contRulebase);
#if HAVE_LOADSAMPLESFROMSTRING == 1
	dbgprintf("\tfilenamerules='%s'\n", pData-&gt;fnRules);
	dbgprintf("\tcontainerrules='%s'\n", pData-&gt;contRules);
#endif
	dbgprintf("\tbusyretryinterval='%d'\n", pData-&gt;busyRetryInterval);
	dbgprintf("\tcacheentryttl='%d'\n", pData-&gt;cacheEntryTTL);
	dbgprintf("\tcacheexpireinterval='%d'\n", pData-&gt;cacheExpireInterval);
ENDdbgPrintInstInfo
BEGINtryResume
CODESTARTtryResume
ENDtryResume
static rsRetVal
extractMsgMetadata(smsg_t *pMsg, instanceData *pData, struct json_object **json)
{
	DEFiRet;
	uchar *filename = NULL, *container_name = NULL, *container_id_full = NULL;
	rs_size_t fnLen, container_name_len, container_id_full_len;
	unsigned short freeFn = 0, free_container_name = 0, free_container_id_full = 0;
	int lnret;
	struct json_object *cnid = NULL;
	if (!json)
		FINALIZE;
	*json = NULL;
	container_name = MsgGetProp(pMsg, NULL, pData-&gt;contNameDescr,
				    &amp;container_name_len, &amp;free_container_name, NULL);
	container_id_full = MsgGetProp(
		pMsg, NULL, pData-&gt;contIdFullDescr, &amp;container_id_full_len, &amp;free_container_id_full, NULL);
	if (container_name &amp;&amp; container_id_full &amp;&amp; container_name_len &amp;&amp; container_id_full_len) {
		dbgprintf("mmkubernetes: CONTAINER_NAME: '%s'  CONTAINER_ID_FULL: '%s'.\n",
			  container_name, container_id_full);
		if ((lnret = ln_normalize(pData-&gt;contCtxln, (char*)container_name,
					  container_name_len, json))) {
			if (LN_WRONGPARSER != lnret) {
				LogMsg(0, RS_RET_ERR, LOG_ERR,
					"mmkubernetes: error parsing container_name [%s]: [%d]",
					container_name, lnret);
				ABORT_FINALIZE(RS_RET_ERR);
			}
		} else if (fjson_object_object_get_ex(*json, "pod_name", NULL) &amp;&amp;
			fjson_object_object_get_ex(*json, "namespace_name", NULL) &amp;&amp;
			fjson_object_object_get_ex(*json, "container_name", NULL)) {
			json_object_object_add(*json, "container_id",
				json_object_new_string_len((const char *)container_id_full,
							   container_id_full_len));
			ABORT_FINALIZE(RS_RET_OK);
		}
	}
	filename = MsgGetProp(pMsg, NULL, pData-&gt;srcMetadataDescr, &amp;fnLen, &amp;freeFn, NULL);
	if((filename == NULL) || (fnLen == 0))
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	dbgprintf("mmkubernetes: filename: '%s' len %d.\n", filename, fnLen);
	if ((lnret = ln_normalize(pData-&gt;fnCtxln, (char*)filename, fnLen, json))) {
		if (LN_WRONGPARSER != lnret) {
			LogMsg(0, RS_RET_ERR, LOG_ERR,
				"mmkubernetes: error parsing container_name [%s]: [%d]",
				filename, lnret);
			ABORT_FINALIZE(RS_RET_ERR);
		} else {
			ABORT_FINALIZE(RS_RET_NOT_FOUND);
		}
	}
	if (fjson_object_object_get_ex(*json, "pod_name", NULL) &amp;&amp;
		fjson_object_object_get_ex(*json, "namespace_name", NULL) &amp;&amp;
		fjson_object_object_get_ex(*json, "container_name_and_id", &amp;cnid)) {
		const char *container_name_and_id = json_object_get_string(cnid);
		const char *last_dash = NULL;
		if (container_name_and_id &amp;&amp; (last_dash = strrchr(container_name_and_id, '-')) &amp;&amp;
			*(last_dash + 1) &amp;&amp; (last_dash != container_name_and_id)) {
			json_object_object_add(*json, "container_name",
				json_object_new_string_len(container_name_and_id,
							   (int)(last_dash-container_name_and_id)));
			json_object_object_add(*json, "container_id",
					json_object_new_string(last_dash + 1));
			ABORT_FINALIZE(RS_RET_OK);
		}
	}
	ABORT_FINALIZE(RS_RET_NOT_FOUND);
finalize_it:
	if(freeFn)
		free(filename);
	if (free_container_name)
		free(container_name);
	if (free_container_id_full)
		free(container_id_full);
	if (iRet != RS_RET_OK) {
		json_object_put(*json);
		*json = NULL;
	}
	RETiRet;
}
static rsRetVal
queryKB(wrkrInstanceData_t *pWrkrData, char *url, time_t now, struct json_object **rply)
{
	DEFiRet;
	CURLcode ccode;
	struct json_tokener *jt = NULL;
	struct json_object *jo;
	long resp_code = 400;
	if (pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime) {
		now -= pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime;
		if (now &lt; pWrkrData-&gt;pData-&gt;busyRetryInterval) {
			LogMsg(0, RS_RET_RETRY, LOG_DEBUG,
				"mmkubernetes: Waited [%ld] of [%d] seconds for the requested url [%s]\n",
				now, pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
			ABORT_FINALIZE(RS_RET_RETRY);
		} else {
			LogMsg(0, RS_RET_OK, LOG_DEBUG,
				"mmkubernetes: Cleared busy status after [%d] seconds - "
				"will retry the requested url [%s]\n",
				pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = 0;
		}
	}
	ccode = curl_easy_setopt(pWrkrData-&gt;curlCtx, CURLOPT_URL, url);
	if(ccode != CURLE_OK)
		ABORT_FINALIZE(RS_RET_ERR);
	if(CURLE_OK != (ccode = curl_easy_perform(pWrkrData-&gt;curlCtx))) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      "mmkubernetes: failed to connect to [%s] - %d:%s\n",
			      url, ccode, curl_easy_strerror(ccode));
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	if(CURLE_OK != (ccode = curl_easy_getinfo(pWrkrData-&gt;curlCtx,
					CURLINFO_RESPONSE_CODE, &amp;resp_code))) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      "mmkubernetes: could not get response code from query to [%s] - %d:%s\n",
			      url, ccode, curl_easy_strerror(ccode));
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 401) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      "mmkubernetes: Unauthorized: not allowed to view url - "
			      "check token/auth credentials [%s]\n",
			      url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 403) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      "mmkubernetes: Forbidden: no access - "
			      "check permissions to view url [%s]\n",
			      url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(resp_code == 404) {
		LogMsg(0, RS_RET_NOT_FOUND, LOG_INFO,
			      "mmkubernetes: Not Found: the resource does not exist at url [%s]\n",
			      url);
		ABORT_FINALIZE(RS_RET_NOT_FOUND);
	}
	if(resp_code == 429) {
		if (pWrkrData-&gt;pData-&gt;busyRetryInterval) {
			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = now;
		}
		LogMsg(0, RS_RET_RETRY, LOG_INFO,
			      "mmkubernetes: Too Many Requests: the server is too heavily loaded "
			      "to provide the data for the requested url [%s]\n",
			      url);
		ABORT_FINALIZE(RS_RET_RETRY);
	}
	if(resp_code != 200) {
		LogMsg(0, RS_RET_ERR, LOG_ERR,
			      "mmkubernetes: server returned unexpected code [%ld] for url [%s]\n",
			      resp_code, url);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	jt = json_tokener_new();
	json_tokener_reset(jt);
	jo = json_tokener_parse_ex(jt, pWrkrData-&gt;curlRply, pWrkrData-&gt;curlRplyLen);
	json_tokener_free(jt);
	if(!json_object_is_type(jo, json_type_object)) {
		json_object_put(jo);
		jo = NULL;
		LogMsg(0, RS_RET_JSON_PARSE_ERR, LOG_INFO,
			      "mmkubernetes: unable to parse string as JSON:[%.*s]\n",
			      (int)pWrkrData-&gt;curlRplyLen, pWrkrData-&gt;curlRply);
		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
	}
	dbgprintf("mmkubernetes: queryKB reply:\n%s\n",
		json_object_to_json_string_ext(jo, JSON_C_TO_STRING_PRETTY));
	*rply = jo;
finalize_it:
	if(pWrkrData-&gt;curlRply != NULL) {
		free(pWrkrData-&gt;curlRply);
		pWrkrData-&gt;curlRply = NULL;
		pWrkrData-&gt;curlRplyLen = 0;
	}
	RETiRet;
}
#if defined(BEGINdoAction_NoStrings)
BEGINdoAction_NoStrings
	smsg_t **ppMsg = (smsg_t **) pMsgData;
	smsg_t *pMsg = ppMsg[0];
#else
BEGINdoAction
	smsg_t *pMsg = (smsg_t*) ppString[0];
#endif
	const char *podName = NULL, *ns = NULL, *containerName = NULL,
		*containerID = NULL;
	char *mdKey = NULL;
	struct json_object *jMetadata = NULL, *jMetadataCopy = NULL, *jMsgMeta = NULL,
			*jo = NULL;
	int add_pod_metadata = 1;
	time_t now;
CODESTARTdoAction
	CHKiRet_Hdlr(extractMsgMetadata(pMsg, pWrkrData-&gt;pData, &amp;jMsgMeta)) {
		ABORT_FINALIZE((iRet == RS_RET_NOT_FOUND) ? RS_RET_OK : iRet);
	}
	datetime.GetTime(&amp;now);
	STATSCOUNTER_INC(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
	if (fjson_object_object_get_ex(jMsgMeta, "pod_name", &amp;jo))
		podName = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, "namespace_name", &amp;jo))
		ns = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, "container_name", &amp;jo))
		containerName = json_object_get_string(jo);
	if (fjson_object_object_get_ex(jMsgMeta, "container_id", &amp;jo))
		containerID = json_object_get_string(jo);
	assert(podName != NULL);
	assert(ns != NULL);
	assert(containerName != NULL);
	assert(containerID != NULL);
	dbgprintf("mmkubernetes:\n  podName: '%s'\n  namespace: '%s'\n  containerName: '%s'\n"
		"  containerID: '%s'\n", podName, ns, containerName, containerID);
	if ((-1 == asprintf(&amp;mdKey, "%s_%s_%s", ns, podName, containerName)) ||
		(!mdKey)) {
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
	pthread_mutex_lock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
	jMetadata = cache_entry_get_md(pWrkrData, mdKey, now);
	if(jMetadata == NULL) {
		char *url = NULL;
		struct json_object *jReply = NULL, *jo2 = NULL, *jNsMeta = NULL, *jPodData = NULL;
		jNsMeta = cache_entry_get_nsmd(pWrkrData, (const char *)ns, now);
		if(jNsMeta == NULL) {
			if ((-1 == asprintf(&amp;url, "%s/api/v1/namespaces/%s",
				 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns)) ||
				(!url)) {
				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
			}
			iRet = queryKB(pWrkrData, url, now, &amp;jReply);
			free(url);
			if (iRet == RS_RET_NOT_FOUND) {
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataNotFound,
						 pWrkrData-&gt;mutNamespaceMetadataNotFound);
			} else if (iRet == RS_RET_RETRY) {
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataBusy,
						 pWrkrData-&gt;mutNamespaceMetadataBusy);
				if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
					pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
					ABORT_FINALIZE(RS_RET_ERR);
				}
				add_pod_metadata = 0; 			} else if (iRet != RS_RET_OK) {
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataError,
						 pWrkrData-&gt;mutNamespaceMetadataError);
			} else if (fjson_object_object_get_ex(jReply, "metadata", &amp;jNsMeta)) {
				jNsMeta = json_object_get(jNsMeta);
				parse_labels_annotations(jNsMeta, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
					pWrkrData-&gt;pData-&gt;de_dot,
					(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
					pWrkrData-&gt;pData-&gt;de_dot_separator_len);
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
			} else {
				LogMsg(0, RS_RET_ERR, LOG_INFO,
					      "mmkubernetes: namespace [%s] has no metadata!\n", ns);
				jNsMeta = json_object_new_object();
				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
			}
			if(jNsMeta) {
				if ((iRet = cache_entry_add_nsmd(pWrkrData, ns, jNsMeta, now))) {
					ABORT_FINALIZE(iRet);
				}
			}
			json_object_put(jReply);
			jReply = NULL;
		}
		if ((-1 == asprintf(&amp;url, "%s/api/v1/namespaces/%s/pods/%s",
			 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns, podName)) ||
			(!url)) {
			pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
		}
		iRet = queryKB(pWrkrData, url, now, &amp;jReply);
		free(url);
		if (iRet == RS_RET_NOT_FOUND) {
			iRet = RS_RET_OK;
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
		} else if (iRet == RS_RET_RETRY) {
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
			if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
				ABORT_FINALIZE(RS_RET_ERR);
			}
			add_pod_metadata = 0; 			iRet = RS_RET_OK;
		} else if(iRet != RS_RET_OK) {
			iRet = RS_RET_OK;
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
		} else {
			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
		}
		jo = json_object_new_object();
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "uid", &amp;jo2))
			json_object_object_add(jo, "namespace_id", json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "labels", &amp;jo2))
			json_object_object_add(jo, "namespace_labels", json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "annotations", &amp;jo2))
			json_object_object_add(jo, "namespace_annotations", json_object_get(jo2));
		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "creationTimestamp", &amp;jo2))
			json_object_object_add(jo, "creation_timestamp", json_object_get(jo2));
		if(fjson_object_object_get_ex(jReply, "metadata", &amp;jPodData)) {
			if(fjson_object_object_get_ex(jPodData, "uid", &amp;jo2))
				json_object_object_add(jo, "pod_id", json_object_get(jo2));
			parse_labels_annotations(jPodData, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
				pWrkrData-&gt;pData-&gt;de_dot,
				(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
				pWrkrData-&gt;pData-&gt;de_dot_separator_len);
			if(fjson_object_object_get_ex(jPodData, "annotations", &amp;jo2))
				json_object_object_add(jo, "annotations", json_object_get(jo2));
			if(fjson_object_object_get_ex(jPodData, "labels", &amp;jo2))
				json_object_object_add(jo, "labels", json_object_get(jo2));
		}
		if(fjson_object_object_get_ex(jReply, "spec", &amp;jPodData)) {
			if(fjson_object_object_get_ex(jPodData, "nodeName", &amp;jo2)) {
				json_object_object_add(jo, "host", json_object_get(jo2));
			}
		}
		json_object_put(jReply);
		jReply = NULL;
		if (fjson_object_object_get_ex(jMsgMeta, "pod_name", &amp;jo2))
			json_object_object_add(jo, "pod_name", json_object_get(jo2));
		if (fjson_object_object_get_ex(jMsgMeta, "namespace_name", &amp;jo2))
			json_object_object_add(jo, "namespace_name", json_object_get(jo2));
		if (fjson_object_object_get_ex(jMsgMeta, "container_name", &amp;jo2))
			json_object_object_add(jo, "container_name", json_object_get(jo2));
		json_object_object_add(jo, "master_url",
			json_object_new_string((const char *)pWrkrData-&gt;pData-&gt;kubernetesUrl));
		jMetadata = json_object_new_object();
		json_object_object_add(jMetadata, "kubernetes", jo);
		jo = json_object_new_object();
		if (fjson_object_object_get_ex(jMsgMeta, "container_id", &amp;jo2))
			json_object_object_add(jo, "container_id", json_object_get(jo2));
		json_object_object_add(jMetadata, "docker", jo);
		if (add_pod_metadata) {
			if ((iRet = cache_entry_add_md(pWrkrData, mdKey, jMetadata, now)))
				ABORT_FINALIZE(iRet);
			mdKey = NULL;
		}
	}
	jMetadataCopy = json_tokener_parse(json_object_get_string(jMetadata));
	if (!add_pod_metadata) {
		json_object_put(jMetadata);
		jMetadata = NULL;
	}
	pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
	msgAddJSON(pMsg, (uchar *) pWrkrData-&gt;pData-&gt;dstMetadataPath + 1, jMetadataCopy, 0, 0);
finalize_it:
	json_object_put(jMsgMeta);
	free(mdKey);
ENDdoAction
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
ENDisCompatibleWithFeature
BEGINmodExit
CODESTARTmodExit
	curl_global_cleanup();
	objRelease(datetime, CORE_COMPONENT);
	objRelease(regexp, LM_REGEXP_FILENAME);
	objRelease(statsobj, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	DBGPRINTF("mmkubernetes: module compiled with rsyslog version %s.\n", VERSION);
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(regexp, LM_REGEXP_FILENAME));
	CHKiRet(objUse(datetime, CORE_COMPONENT));
	curl_global_init(CURL_GLOBAL_ALL);
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
