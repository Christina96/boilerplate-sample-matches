<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omfile-hardened.c &amp; mmkubernetes.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omfile-hardened.c &amp; mmkubernetes.c
      </h3>
<h1 align="center">
        8.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omfile-hardened.c (10.526316%)<th>mmkubernetes.c (6.881243%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(238-279)<td><a href="#" name="0">(230-276)</a><td align="center"><font color="#ff0000">79</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1382-1389)<td><a href="#" name="1">(589-602)</a><td align="center"><font color="#4a0000">23</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1335-1343)<td><a href="#" name="2">(713-726)</a><td align="center"><font color="#470000">22</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omfile-hardened.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include "glbl.h"
4 #include &lt;stdio.h&gt;
5 #include &lt;stdarg.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;time.h&gt;
9 #include &lt;assert.h&gt;
10 #include &lt;errno.h&gt;
11 #include &lt;ctype.h&gt;
12 #include &lt;libgen.h&gt;
13 #include &lt;unistd.h&gt;
14 #include &lt;sys/file.h&gt;
15 #include &lt;fcntl.h&gt;
16 #include &lt;sys/statvfs.h&gt;
17 #ifdef HAVE_ATOMIC_BUILTINS
18 #	include &lt;pthread.h&gt;
19 #endif
20 #include "conf.h"
21 #include "syslogd-types.h"
22 #include "srUtils.h"
23 #include "template.h"
24 #include "outchannel.h"
25 #include "omfile.h"
26 #include "cfsysline.h"
27 #include "module-template.h"
28 #include "errmsg.h"
29 #include "stream.h"
30 #include "unicode-helper.h"
31 #include "atomic.h"
32 #include "statsobj.h"
33 #include "sigprov.h"
34 #include "cryprov.h"
35 #include "parserif.h"
36 #include "janitor.h"
37 #include "rsconf.h"
38 MODULE_TYPE_OUTPUT
39 MODULE_TYPE_NOKEEP
40 MODULE_CNFNAME("omfile")
41 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
42 DEF_OMOD_STATIC_DATA
43 DEFobjCurrIf(glbl)
44 DEFobjCurrIf(strm)
45 DEFobjCurrIf(statsobj)
46 #if HAVE_ATOMIC_BUILTINS64
47 static uint64 clockFileAccess = 0;
48 #else
49 static unsigned clockFileAccess = 0;
50 #endif
51 #ifndef HAVE_ATOMIC_BUILTINS
52 static pthread_mutex_t mutClock;
53 #endif
54 static uint64
55 getClockFileAccess(void)
56 {
57 #if HAVE_ATOMIC_BUILTINS64
58 	return ATOMIC_INC_AND_FETCH_uint64(&amp;clockFileAccess, &amp;mutClock);
59 #else
60 	return ATOMIC_INC_AND_FETCH_unsigned(&amp;clockFileAccess, &amp;mutClock);
61 #endif
62 }
63 struct s_dynaFileCacheEntry {
64 	uchar *pName;			strm_t	*pStrm;			void	*sigprovFileData;		uint64	clkTickAccessed;	short nInactive;	};
65 typedef struct s_dynaFileCacheEntry dynaFileCacheEntry;
66 #define IOBUF_DFLT_SIZE 4096	#define FLUSH_INTRVL_DFLT 1 	#define USE_ASYNCWRITER_DFLT 0 	#define FLUSHONTX_DFLT 1 	
67 typedef struct _instanceData {
68 	pthread_mutex_t mutWrite; 	uchar	*fname;		uchar 	*tplName;		strm_t	*pStrm;			short nInactive;		char	bDynamicName;		int	fCreateMode;		int	fDirCreateMode;		int	bCreateDirs;		int	bSyncFile;		uint8_t iNumTpls;		uid_t	fileUID;		uid_t	dirUID;
69 	gid_t	fileGID;
70 	gid_t	dirGID;
71 	dynaFileCacheEntry **dynCache;
72 	off_t	iSizeLimit;			uchar	*pszSizeLimitCmd;		int 	iZipLevel;			uint	iIOBufSize;			int	iFlushInterval;			short	iCloseTimeout;			sbool	bFlushOnTXEnd;			sbool	bUseAsyncWriter;		sbool	bVeryRobustZip;
73 	statsobj_t *stats;			STATSCOUNTER_DEF(ctrRequests, mutCtrRequests);
74 	STATSCOUNTER_DEF(ctrLevel0, mutCtrLevel0);
75 	STATSCOUNTER_DEF(ctrEvict, mutCtrEvict);
76 	STATSCOUNTER_DEF(ctrMiss, mutCtrMiss);
77 	STATSCOUNTER_DEF(ctrMax, mutCtrMax);
78 	STATSCOUNTER_DEF(ctrCloseTimeouts, mutCtrCloseTimeouts);
79 	char janitorID[128];		} instanceData;
80 typedef struct wrkrInstanceData {
81 	instanceData *pData;
82 } wrkrInstanceData_t;
83 typedef struct configSettings_s {
84 	uint iDynaFileCacheSize; 	int fCreateMode; 	int fDirCreateMode; 	int	bFailOnChown;		uid_t	fileUID;		uid_t	fileGID;		uid_t	dirUID;			uid_t	dirGID;			int	bCreateDirs;	int	bEnableSync;	int	iZipLevel;		sbool	bFlushOnTXEnd;	int64	iIOBufSize;		int	iFlushInterval; 		int	bUseAsyncWriter;		EMPTY_STRUCT
85 } configSettings_t;
86 static configSettings_t cs;
87 uchar	*pszFileDfltTplName; 
88 struct modConfData_s {
89 	rsconf_t *pConf;		uchar 	*tplName;		int fCreateMode; 	int fDirCreateMode; 	uid_t fileUID;		uid_t dirUID;
90 	gid_t fileGID;
91 	gid_t dirGID;
92 	int bDynafileDoNotSuspend;
93 };
94 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
95 <a name="0"></a>static struct cnfparamdescr modpdescr[] = {
96 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "template", eCmdHdlrGetWord, 0 },
97 	{ "dircreatemode", eCmdHdlrFileCreateMode, 0 },
98 	{ "filecreatemode", eCmdHdlrFileCreateMode, 0 },
99 	{ "dirowner", eCmdHdlrUID, 0 },
100 	{ "dirownernum", eCmdHdlrInt, 0 },
101 	{ "dirgroup", eCmdHdlrGID, 0 },
102 	{ "dirgroupnum", eCmdHdlrInt, 0 },
103 	{ "fileowner", eCmdHdlrUID, 0 },
104 	{ "fileownernum", eCmdHdlrInt, 0 },
105 	{ "filegroup", eCmdHdlrGID, 0 },
106 	{ "dynafile.donotsuspend", eCmdHdlrBinary, 0 },
107 	{ "filegroupnum", eCmdHdlrInt, 0 },
108 };
109 static struct cnfparamblk modpblk =
110 	{ CNFPARAMBLK_VERSION,
111 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
112 	  modpdescr
113 	};
114 static struct cnfparamdescr actpdescr[] = {
115 	{ "dynafilecachesize", eCmdHdlrInt, 0 }, 	{ "ziplevel", eCmdHdlrInt, 0 }, 	{ "flushinterval", eCmdHdlrInt, 0 }, 	{ "asyncwriting", eCmdHdlrBinary, 0 }, 	{ "veryrobustzip", eCmdHdlrBinary, 0 },
116 	{ "flushontxend", eCmdHdlrBinary, 0 }, 	{ "iobuffersize", eCmdHdlrSize, 0 }, 	{ "dirowner", eCmdHdlrUID, 0 }, 	{ "dirownernum", eCmdHdlrInt, 0 }, 	{ "dirgroup", eCmdHdlrGID, 0 }, 	{ "dirgroupnum", eCmdHdlrInt, 0 }, 	{ "fileowner", eCmdHdlrUID, 0 }, 	{ "fileownernum", eCmdHdlrInt, 0 }, 	{ "filegroup", eCmdHdlrGID, 0 }, 	{ "filegroupnum", eCmdHdlrInt, 0 }, 	{ "dircreatemode", eCmdHdlrFileCreateMode, 0 }, 	{ "filecreatemode", eCmdHdlrFileCreateMode, 0 }, 	{ "failonchownfailure", eCmdHdlrBinary, 0 }, 	{ "createdirs", eCmdHdlrBinary, 0 }, 	{ "sync", eCmdHdlrBinary, 0 }, 	{ "file", eCmdHdlrString, 0 },     	{ "dynafile", eCmdHdlrString, 0 }, 	{ "sig.provider", eCmdHdlrGetWord, 0 },
117 	{ "cry.provider", eCmdHdlrGetWord, 0 },
118 	{ "closetimeout", eCmdHdlrPositiveInt, 0 },
119 	{ "template", eCmdHdlrGetWord, 0 }
120 };
121 static struct cnfparamblk actpblk =
122 	{ CNFPARAMBLK_VERSION,
123 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
124 	  actpdescr
125 	};
126 static uchar*
127 getDfltTpl(void)
128 {
129 	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL)
130 		return loadModConf-&gt;tplName;
131 	else if(pszFileDfltTplName == NULL)
132 		return (uchar*)"RSYSLOG_FileFormat";
133 	else
134 		return pszFileDfltTplName;
135 }
136 BEGINinitConfVars		CODESTARTinitConfVars
137 	pszFileDfltTplName = NULL; 	iRet = resetConfigVariables(NULL, NULL); ENDinitConfVars
138 BEGINisCompatibleWithFeature
139 CODESTARTisCompatibleWithFeature
140 	if(eFeat == sFEATURERepeatedMsgReduction)
141 		iRet = RS_RET_OK;
142 ENDisCompatibleWithFeature
143 BEGINdbgPrintInstInfo
144 CODESTARTdbgPrintInstInfo
145 	if(pData-&gt;bDynamicName) {
146 		dbgprintf("[dynamic]\n");
147 	} else { 		dbgprintf("%s%s\n", pData-&gt;fname,
148 			  (pData-&gt;pStrm == NULL) ? " (closed)" : "");
149 	}
150 	dbgprintf("\ttemplate='%s'\n", pData-&gt;fname);
151 	dbgprintf("\tuse async writer=%d\n", pData-&gt;bUseAsyncWriter);
152 	dbgprintf("\tflush on TX end=%d\n", pData-&gt;bFlushOnTXEnd);
153 	dbgprintf("\tflush interval=%d\n", pData-&gt;iFlushInterval);
154 	dbgprintf("\tfile cache size=%d\n", pData-&gt;iDynaFileCacheSize);
155 	dbgprintf("\tcreate directories: %s\n", pData-&gt;bCreateDirs ? "on" : "off");
156 	dbgprintf("\tvery robust zip: %s\n", pData-&gt;bCreateDirs ? "on" : "off");
157 	dbgprintf("\tfile owner %d, group %d\n", (int) pData-&gt;fileUID, (int) pData-&gt;fileGID);
158 	dbgprintf("\tdirectory owner %d, group %d\n", (int) pData-&gt;dirUID, (int) pData-&gt;dirGID);
159 	dbgprintf("\tdir create mode 0%3.3o, file create mode 0%3.3o\n",
160 		  pData-&gt;fDirCreateMode, pData-&gt;fCreateMode);
161 	dbgprintf("\tfail if owner/group can not be set: %s\n", pData-&gt;bFailOnChown ? "yes" : "no");
162 ENDdbgPrintInstInfo
163 static rsRetVal
164 setLegacyDfltTpl(void __attribute__((unused)) *pVal, uchar* newVal)
165 {
166 	DEFiRet;
167 	if(loadModConf != NULL &amp;&amp; loadModConf-&gt;tplName != NULL) {
168 		free(newVal);
169 		parser_errmsg("omfile: default template already set via module "
170 			"global parameter - can no longer be changed");
171 		ABORT_FINALIZE(RS_RET_ERR);
172 	}
173 	free(pszFileDfltTplName);
174 	pszFileDfltTplName = newVal;
175 finalize_it:
176 	RETiRet;
177 }
178 static rsRetVal setDynaFileCacheSize(void __attribute__((unused)) *pVal, int iNewVal)
179 {
180 	DEFiRet;
181 	if(iNewVal &lt; 1) {
182 		errno = 0;
183 		parser_errmsg(
184 		         "DynaFileCacheSize must be greater 0 (%d given), changed to 1.", iNewVal);
185 		iRet = RS_RET_VAL_OUT_OF_RANGE;
186 		iNewVal = 1;
187 	} else if(iNewVal &gt; 1000) {
188 		errno = 0;
189 		parser_errmsg(
190 		         "DynaFileCacheSize maximum is 1,000 (%d given), changed to 1,000.", iNewVal);
191 		iRet = RS_RET_VAL_OUT_OF_RANGE;
192 		iNewVal = 1000;
193 	}
194 	cs.iDynaFileCacheSize = iNewVal;
195 	DBGPRINTF("DynaFileCacheSize changed to %d.\n", iNewVal);
196 	RETiRet;
197 }
198 static rsRetVal cflineParseOutchannel(instanceData *pData, uchar* p, omodStringRequest_t *pOMSR,
199 	int iEntry, int iTplOpts)
200 {
201 	DEFiRet;
202 	size_t i;
203 	struct outchannel *pOch;
204 	char szBuf[128];	
205 	++p; 	i = 0;
206 	while(*p &amp;&amp; *p != ';' &amp;&amp; *p != ' ' &amp;&amp;
207 	      i &lt; (sizeof(szBuf) - 1) ) {
208 	      szBuf[i++] = *p++;
209 	}
210 	szBuf[i] = '\0';
211 	pOch = ochFind(szBuf, i);
212 	if(pOch == NULL) {
213 		parser_errmsg(
214 			 "outchannel '%s' not found - ignoring action line",
215 			 szBuf);
216 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
217 	}
218 	if(pOch-&gt;pszFileTemplate == NULL) {
219 		parser_errmsg(
220 			 "outchannel '%s' has no file name template - ignoring action line",
221 			 szBuf);
222 		ABORT_FINALIZE(RS_RET_ERR);
223 	}
224 	pData-&gt;fname = ustrdup(pOch-&gt;pszFileTemplate);
225 	pData-&gt;iSizeLimit = pOch-&gt;uSizeLimit;
226 	pData-&gt;pszSizeLimitCmd = pOch-&gt;cmdOnSizeLimit;
227 	iRet = cflineParseTemplateName(&amp;p, pOMSR, iEntry, iTplOpts, getDfltTpl());
228 finalize_it:
229 	RETiRet;
230 }
231 static rsRetVal
232 dynaFileDelCacheEntry(instanceData *__restrict__ const pData, const int iEntry, const int bFreeEntry)
233 {
234 	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
235 	DEFiRet;
236 	assert(pCache != NULL);
237 	if(pCache[iEntry] == NULL)
238 		FINALIZE;
239 	DBGPRINTF("Removing entry %d for file '%s' from dynaCache.\n", iEntry,
240 		pCache[iEntry]-&gt;pName == NULL ? UCHAR_CONSTANT("[OPEN FAILED]") : pCache[iEntry]-&gt;pName);
241 	if(pCache[iEntry]-&gt;pName != NULL) {
242 		free(pCache[iEntry]-&gt;pName);
243 		pCache[iEntry]-&gt;pName = NULL;
244 	}
245 	if(pCache[iEntry]-&gt;pStrm != NULL) {
246 		strm.Destruct(&amp;pCache[iEntry]-&gt;pStrm);
247 		if(pData-&gt;useSigprov) {
248 			pData-&gt;sigprov.OnFileClose(pCache[iEntry]-&gt;sigprovFileData);
249 			pCache[iEntry]-&gt;sigprovFileData = NULL;
250 		}
251 	}
252 	if(bFreeEntry) {
253 		free(pCache[iEntry]);
254 		pCache[iEntry] = NULL;
255 	}
256 finalize_it:
257 	RETiRet;
258 }
259 static void
260 dynaFileFreeCacheEntries(instanceData *__restrict__ const pData)
261 {
262 	register uint i;
263 	assert(pData != NULL);
264 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
265 		dynaFileDelCacheEntry(pData, i, 1);
266 	}
267 	pData-&gt;iCurrElt = -1; }
268 static void dynaFileFreeCache(instanceData *__restrict__ const pData)
269 {
270 	assert(pData != NULL);
271 	dynaFileFreeCacheEntries(pData);
272 	if(pData-&gt;dynCache != NULL)
273 		free(pData-&gt;dynCache);
274 }
275 static rsRetVal
276 closeFile(instanceData *__restrict__ const pData)
277 {
278 	DEFiRet;
279 	if(pData-&gt;useSigprov) {
280 		pData-&gt;sigprov.OnFileClose(pData-&gt;sigprovFileData);
281 		pData-&gt;sigprovFileData = NULL;
282 	}
283 	strm.Destruct(&amp;pData-&gt;pStrm);
284 	RETiRet;
285 }
286 static rsRetVal
287 sigprovPrepare(instanceData *__restrict__ const pData, uchar *__restrict__ const fn)
288 {
289 	DEFiRet;
290 	pData-&gt;sigprov.OnFileOpen(pData-&gt;sigprovData, fn, &amp;pData-&gt;sigprovFileData);
291 	RETiRet;
292 }
293 static rsRetVal
294 prepareFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
295 {
296 	int fd;
297 	char errStr[1024]; 	DEFiRet;
298 	pData-&gt;pStrm = NULL;
299 	if(access((char*)newFileName, F_OK) != 0) {
300 		if(pData-&gt;bCreateDirs) {
301 			if(makeFileParentDirs(newFileName, ustrlen(newFileName),
302 			     pData-&gt;fDirCreateMode, pData-&gt;dirUID,
303 			     pData-&gt;dirGID, pData-&gt;bFailOnChown) != 0) {
304 				rs_strerror_r(errno, errStr, sizeof(errStr));
305 				parser_errmsg( "omfile: creating parent "
306 					"directories for file  '%s' failed: %s",
307 					newFileName, errStr);
308 			     	ABORT_FINALIZE(RS_RET_ERR); 			}
309 		}
310 		fd = open((char*) newFileName, O_WRONLY|O_APPEND|O_CREAT|O_NOCTTY|O_CLOEXEC,
311 				pData-&gt;fCreateMode);
312 		if(fd != -1) {
313 			if(pData-&gt;fileUID != (uid_t)-1 || pData-&gt;fileGID != (gid_t) -1) {
314 				if(fchown(fd, pData-&gt;fileUID, pData-&gt;fileGID) != 0) {
315 					rs_strerror_r(errno, errStr, sizeof(errStr));
316 					parser_errmsg(
317 						"omfile: chown for file '%s' failed: %s",
318 						newFileName, errStr);
319 					if(pData-&gt;bFailOnChown) {
320 						close(fd);
321 						ABORT_FINALIZE(RS_RET_ERR); 					}
322 				}
323 			}
324 			close(fd); 		}
325 		else {
326 			ABORT_FINALIZE(RS_RET_ERR);
327 		}
328 	}
329 	uchar szNameBuf[MAXFNAME+1];
330 	uchar szDirName[MAXFNAME+1];
331 	uchar szBaseName[MAXFNAME+1];
332 	ustrncpy(szNameBuf, newFileName, MAXFNAME);
333 	szNameBuf[MAXFNAME] = '\0';
334 	ustrncpy(szDirName, (uchar*)dirname((char*)szNameBuf), MAXFNAME);
335 	szDirName[MAXFNAME] = '\0';
336 	ustrncpy(szNameBuf, newFileName, MAXFNAME);
337 	szNameBuf[MAXFNAME] = '\0';
338 	ustrncpy(szBaseName, (uchar*)basename((char*)szNameBuf), MAXFNAME);
339 	szBaseName[MAXFNAME] = '\0';
340 	CHKiRet(strm.Construct(&amp;pData-&gt;pStrm));
341 	CHKiRet(strm.SetFName(pData-&gt;pStrm, szBaseName, ustrlen(szBaseName)));
342 	CHKiRet(strm.SetDir(pData-&gt;pStrm, szDirName, ustrlen(szDirName)));
343 	CHKiRet(strm.SetiZipLevel(pData-&gt;pStrm, pData-&gt;iZipLevel));
344 	CHKiRet(strm.SetbVeryReliableZip(pData-&gt;pStrm, pData-&gt;bVeryRobustZip));
345 	CHKiRet(strm.SetsIOBufSize(pData-&gt;pStrm, (size_t) pData-&gt;iIOBufSize));
346 	CHKiRet(strm.SettOperationsMode(pData-&gt;pStrm, STREAMMODE_WRITE_APPEND));
347 	CHKiRet(strm.SettOpenMode(pData-&gt;pStrm, cs.fCreateMode));
348 	CHKiRet(strm.SetbSync(pData-&gt;pStrm, pData-&gt;bSyncFile));
349 	CHKiRet(strm.SetsType(pData-&gt;pStrm, STREAMTYPE_FILE_SINGLE));
350 	CHKiRet(strm.SetiSizeLimit(pData-&gt;pStrm, pData-&gt;iSizeLimit));
351 	if(pData-&gt;useCryprov) {
352 		CHKiRet(strm.Setcryprov(pData-&gt;pStrm, &amp;pData-&gt;cryprov));
353 		CHKiRet(strm.SetcryprovData(pData-&gt;pStrm, pData-&gt;cryprovData));
354 	}
355 	if(pData-&gt;bUseAsyncWriter)
356 		CHKiRet(strm.SetiFlushInterval(pData-&gt;pStrm, pData-&gt;iFlushInterval));
357 	if(pData-&gt;pszSizeLimitCmd != NULL)
358 		CHKiRet(strm.SetpszSizeLimitCmd(pData-&gt;pStrm, ustrdup(pData-&gt;pszSizeLimitCmd)));
359 	CHKiRet(strm.ConstructFinalize(pData-&gt;pStrm));
360 	if(pData-&gt;useSigprov)
361 		sigprovPrepare(pData, szNameBuf);
362 finalize_it:
363 	if(iRet != RS_RET_OK) {
364 		if(pData-&gt;pStrm != NULL) {
365 			closeFile(pData);
366 		}
367 	}
368 	RETiRet;
369 }
370 static rsRetVal
371 fsCheck(instanceData *__restrict__ const pData, const uchar *__restrict__ const fileName)
372 {
373 	DEFiRet;
374 	struct statvfs stat;
375 	char *pathcopy;
376 	const char *path;
377 	pathcopy = strdup((char*)fileName);
378 	path = dirname(pathcopy);
379 	if (statvfs(path, &amp;stat) != 0) {
380 		iRet = RS_RET_FILE_NO_STAT;
381 		LogError(0, iRet, "could not stat %s", path);
382 		FINALIZE;
383 	}
384 	if (stat.f_bsize * stat.f_bavail &lt;
385 		pData-&gt;iIOBufSize * pData-&gt;iDynaFileCacheSize + (uint)(glbl.GetMaxLine(runModConf-&gt;pConf)))
386 		{
387 			iRet = RS_RET_FS_ERR;
388 			LogError(0, iRet, "too few available blocks in %s", path);
389 			FINALIZE;
390 		}
391 	if (stat.f_favail &lt; 2 &amp;&amp; stat.f_files &gt; 0)
392 		{
393 			iRet = RS_RET_FS_ERR;
394 			LogError(0, iRet, "too few available inodes in %s", path);
395 			FINALIZE;
396 		}
397 	if (stat.f_flag == ST_RDONLY)
398 		{
399 			iRet = RS_RET_FS_ERR;
400 			LogError(0, iRet, "file-system is read-only in %s", path);
401 			FINALIZE;
402 		}
403 	iRet = RS_RET_OK;
404 finalize_it:
405 	if (pathcopy != NULL)
406 		free(pathcopy);
407 	RETiRet;
408 }
409 static rsRetVal
410 prepareDynFile(instanceData *__restrict__ const pData, const uchar *__restrict__ const newFileName)
411 {
412 	uint64 ctOldest; 	int iOldest;
413 	uint i;
414 	int iFirstFree;
415 	rsRetVal localRet;
416 	dynaFileCacheEntry **pCache;
417 	DEFiRet;
418 	assert(pData != NULL);
419 	assert(newFileName != NULL);
420 	pCache = pData-&gt;dynCache;
421 	if(   (pData-&gt;iCurrElt != -1)
422 	   &amp;&amp; !ustrcmp(newFileName, pCache[pData-&gt;iCurrElt]-&gt;pName)) {
423 		CHKiRet(fsCheck(pData, newFileName));
424 		pCache[pData-&gt;iCurrElt]-&gt;clkTickAccessed = getClockFileAccess();
425 		STATSCOUNTER_INC(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
426 		FINALIZE;
427 	}
428 	pData-&gt;iCurrElt = -1;		iFirstFree = -1; 	iOldest = 0; 	ctOldest = getClockFileAccess(); 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
429 		if(pCache[i] == NULL || pCache[i]-&gt;pName == NULL) {
430 			if(iFirstFree == -1)
431 				iFirstFree = i;
432 		} else { 			if(!ustrcmp(newFileName, pCache[i]-&gt;pName)) {
433 				CHKiRet(fsCheck(pData, newFileName));
434 				pData-&gt;pStrm = pCache[i]-&gt;pStrm;
435 				if(pData-&gt;useSigprov)
436 					pData-&gt;sigprovFileData = pCache[i]-&gt;sigprovFileData;
437 				pData-&gt;iCurrElt = i;
438 				pCache[i]-&gt;clkTickAccessed = getClockFileAccess(); 				FINALIZE;
439 			}
440 			if(pCache[i]-&gt;clkTickAccessed &lt; ctOldest) {
441 				ctOldest = pCache[i]-&gt;clkTickAccessed;
442 				iOldest = i;
443 				}
444 		}
445 	}
446 	STATSCOUNTER_INC(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
447 	pData-&gt;pStrm = NULL, pData-&gt;sigprovFileData = NULL;
448 	if(iFirstFree == -1 &amp;&amp; (pData-&gt;iCurrCacheSize &lt; pData-&gt;iDynaFileCacheSize)) {
449 		iFirstFree = pData-&gt;iCurrCacheSize++;
450 		STATSCOUNTER_SETMAX_NOMUT(pData-&gt;ctrMax, (unsigned) pData-&gt;iCurrCacheSize);
451 	}
452 	if(iFirstFree == -1) {
453 		dynaFileDelCacheEntry(pData, iOldest, 0);
454 		STATSCOUNTER_INC(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
455 		iFirstFree = iOldest; 	} else {
456 		CHKmalloc(pCache[iFirstFree] = (dynaFileCacheEntry*) calloc(1, sizeof(dynaFileCacheEntry)));
457 	}
458 	localRet = prepareFile(pData, newFileName); 
459 	if(localRet != RS_RET_OK) {
460 		parser_errmsg("Could not open dynamic file '%s' [state %d]", newFileName, localRet);
461 		ABORT_FINALIZE(localRet);
462 	}
463 	localRet = fsCheck(pData, newFileName);
464 	if(localRet != RS_RET_OK) {
465 		parser_errmsg("Invalid file-system condition for dynamic file '%s' [state %d]", newFileName, localRet);
466 		ABORT_FINALIZE(localRet);
467 	}
468 	if((pCache[iFirstFree]-&gt;pName = ustrdup(newFileName)) == NULL) {
469 		closeFile(pData); 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
470 	}
471 	pCache[iFirstFree]-&gt;pStrm = pData-&gt;pStrm;
472 	if(pData-&gt;useSigprov)
473 		pCache[iFirstFree]-&gt;sigprovFileData = pData-&gt;sigprovFileData;
474 	pCache[iFirstFree]-&gt;clkTickAccessed = getClockFileAccess();
475 	pData-&gt;iCurrElt = iFirstFree;
476 	DBGPRINTF("Added new entry %d for file cache, file '%s'.\n", iFirstFree, newFileName);
477 finalize_it:
478 	if(iRet == RS_RET_OK)
479 		pCache[pData-&gt;iCurrElt]-&gt;nInactive = 0;
480 	RETiRet;
481 }
482 static  rsRetVal
483 doWrite(instanceData *__restrict__ const pData, uchar *__restrict__ const pszBuf, const int lenBuf)
484 {
485 	DEFiRet;
486 	assert(pData != NULL);
487 	assert(pszBuf != NULL);
488 	DBGPRINTF("omfile: write to stream, pData-&gt;pStrm %p, lenBuf %d, strt data %.128s\n",
489 		  pData-&gt;pStrm, lenBuf, pszBuf);
490 	if(pData-&gt;pStrm != NULL){
491 		CHKiRet(strm.Write(pData-&gt;pStrm, pszBuf, lenBuf));
492 		if(pData-&gt;useSigprov) {
493 			CHKiRet(pData-&gt;sigprov.OnRecordWrite(pData-&gt;sigprovFileData, pszBuf, lenBuf));
494 		}
495 	}
496 finalize_it:
497 	RETiRet;
498 }
499 static rsRetVal
500 writeFile(instanceData *__restrict__ const pData,
501 	  const actWrkrIParams_t *__restrict__ const pParam,
502 	  const int iMsg)
503 {
504 	DEFiRet;
505 	STATSCOUNTER_INC(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
506 	if(pData-&gt;bDynamicName) {
507 		DBGPRINTF("omfile: file to log to: %s\n",
508 			  actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param);
509 		CHKiRet(prepareDynFile(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 1).param));
510 	} else { 		if(pData-&gt;pStrm == NULL) {
511 			CHKiRet(prepareFile(pData, pData-&gt;fname));
512 			if(pData-&gt;pStrm == NULL) {
513 				parser_errmsg(
514 					"Could not open output file '%s'", pData-&gt;fname);
515 			}
516 			CHKiRet(fsCheck(pData, pData-&gt;fname));
517 		}
518 		pData-&gt;nInactive = 0;
519 	}
520 	iRet = doWrite(pData, actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).param,
521 		actParam(pParam, pData-&gt;iNumTpls, iMsg, 0).lenStr);
522 finalize_it:
523 	RETiRet;
524 }
525 BEGINbeginCnfLoad
526 CODESTARTbeginCnfLoad
527 	loadModConf = pModConf;
528 	pModConf-&gt;pConf = pConf;
529 	pModConf-&gt;tplName = NULL;
530 	pModConf-&gt;fCreateMode = 0644;
531 	pModConf-&gt;fDirCreateMode = 0700;
532 	pModConf-&gt;fileUID = -1;
533 	pModConf-&gt;dirUID = -1;
534 	pModConf-&gt;fileGID = -1;
535 	pModConf-&gt;dirGID = -1;
536 	pModConf-&gt;bDynafileDoNotSuspend = 1;
537 ENDbeginCnfLoad
538 BEGINsetModCnf
539 	struct cnfparamvals *pvals = NULL;
540 	int i;
541 CODESTARTsetModCnf
542 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
543 	if(pvals == NULL) {
544 		parser_errmsg("error processing module "
545 				"config parameters [module(...)]");
546 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
547 	}
548 	if(Debug) {
549 		dbgprintf("module (global) param blk for omfile:\n");
550 		cnfparamsPrint(&amp;modpblk, pvals);
551 	}
552 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
553 		if(!pvals[i].bUsed) {
554 			continue;
555 		}
556 		if(!strcmp(modpblk.descr[i].name, "template")) {
557 			loadModConf-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
558 			if(pszFileDfltTplName != NULL) {
559 				parser_errmsg("omfile: warning: default template was already "
560 					"set via legacy directive - may lead to inconsistent "
561 					"results.");
562 			}
563 		} else if(!strcmp(modpblk.descr[i].name, "dircreatemode")) {
564 			loadModConf-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
565 		} else if(!strcmp(modpblk.descr[i].name, "filecreatemode")) {
566 			loadModConf-&gt;fCreateMode = (int) pvals[i].val.d.n;
567 		} else if(!strcmp(modpblk.descr[i].name, "dirowner")) {
568 			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
569 		} else if(!strcmp(modpblk.descr[i].name, "dirownernum")) {
570 			loadModConf-&gt;dirUID = (int) pvals[i].val.d.n;
571 		} else if(!strcmp(modpblk.descr[i].name, "dirgroup")) {
572 			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
573 		} else if(!strcmp(modpblk.descr[i].name, "dirgroupnum")) {
574 			loadModConf-&gt;dirGID = (int) pvals[i].val.d.n;
575 		} else if(!strcmp(modpblk.descr[i].name, "fileowner")) {
576 			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
577 		} else if(!strcmp(modpblk.descr[i].name, "fileownernum")) {
578 			loadModConf-&gt;fileUID = (int) pvals[i].val.d.n;
579 		} else if(!strcmp(modpblk.descr[i].name, "filegroup")) {
580 			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
581 		} else if(!strcmp(modpblk.descr[i].name, "filegroupnum")) {
582 			loadModConf-&gt;fileGID = (int) pvals[i].val.d.n;
583 		} else if(!strcmp(modpblk.descr[i].name, "dynafile.donotsuspend")) {
584 			loadModConf-&gt;bDynafileDoNotSuspend = (int) pvals[i].val.d.n;
585 		} else {
586 			dbgprintf("omfile: program error, non-handled "
587 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
588 		}
589 	}
590 finalize_it:
591 	if(pvals != NULL)
592 		cnfparamvalsDestruct(pvals, &amp;modpblk);
593 ENDsetModCnf
594 static void
595 janitorChkDynaFiles(instanceData *__restrict__ const pData)
596 {
597 	uint i;
598 	dynaFileCacheEntry **pCache = pData-&gt;dynCache;
599 	for(i = 0 ; i &lt; pData-&gt;iCurrCacheSize ; ++i) {
600 		if(pCache[i] == NULL)
601 			continue;
602 		DBGPRINTF("omfile janitor: checking dynafile %d:%s, inactive since %d\n", i,
603 			pCache[i]-&gt;pName == NULL ? UCHAR_CONSTANT("[OPEN FAILED]") : pCache[i]-&gt;pName,
604 			(int) pCache[i]-&gt;nInactive);
605 		if(pCache[i]-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
606 			STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
607 			dynaFileDelCacheEntry(pData, i, 1);
608 			if(pData-&gt;iCurrElt &gt;= 0) {
609 				if((uint)(pData-&gt;iCurrElt) == i)
610 				pData-&gt;iCurrElt = -1; 			}
611 		} else {
612 			pCache[i]-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
613 		}
614 	}
615 }
616 static void
617 janitorCB(void *pUsr)
618 {
619 	instanceData *__restrict__ const pData = (instanceData *) pUsr;
620 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
621 	if(pData-&gt;bDynamicName) {
622 		janitorChkDynaFiles(pData);
623 	} else {
624 		if(pData-&gt;pStrm != NULL) {
625 			DBGPRINTF("omfile janitor: checking file %s, inactive since %d\n",
626 				pData-&gt;fname, pData-&gt;nInactive);
627 			if(pData-&gt;nInactive &gt;= pData-&gt;iCloseTimeout) {
628 				STATSCOUNTER_INC(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
629 				closeFile(pData);
630 			} else {
631 				pData-&gt;nInactive += runModConf-&gt;pConf-&gt;globals.janitorInterval;
632 			}
633 		}
634 	}
635 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
636 }
637 BEGINendCnfLoad
638 CODESTARTendCnfLoad
639 	loadModConf = NULL; 	free(pszFileDfltTplName);
640 	pszFileDfltTplName = NULL;
641 ENDendCnfLoad
642 BEGINcheckCnf
643 CODESTARTcheckCnf
644 ENDcheckCnf
645 BEGINactivateCnf
646 CODESTARTactivateCnf
647 	runModConf = pModConf;
648 ENDactivateCnf
649 BEGINfreeCnf
650 CODESTARTfreeCnf
651 	free(pModConf-&gt;tplName);
652 ENDfreeCnf
653 BEGINcreateInstance
654 CODESTARTcreateInstance
655 	pData-&gt;pStrm = NULL;
656 	pthread_mutex_init(&amp;pData-&gt;mutWrite, NULL);
657 ENDcreateInstance
658 BEGINcreateWrkrInstance
659 CODESTARTcreateWrkrInstance
660 ENDcreateWrkrInstance
661 BEGINfreeInstance
662 CODESTARTfreeInstance
663 	free(pData-&gt;tplName);
664 	free(pData-&gt;fname);
665 	if(pData-&gt;iCloseTimeout &gt; 0)
666 		janitorDelEtry(pData-&gt;janitorID);
667 	if(pData-&gt;bDynamicName) {
668 		dynaFileFreeCache(pData);
669 	} else if(pData-&gt;pStrm != NULL)
670 		closeFile(pData);
671 	if(pData-&gt;stats != NULL)
672 		statsobj.Destruct(&amp;(pData-&gt;stats));
673 	if(pData-&gt;useSigprov) {
674 		pData-&gt;sigprov.Destruct(&amp;pData-&gt;sigprovData);
675 		obj.ReleaseObj(__FILE__, pData-&gt;sigprovNameFull+2, pData-&gt;sigprovNameFull,
676 			       (void*) &amp;pData-&gt;sigprov);
677 		free(pData-&gt;sigprovName);
678 		free(pData-&gt;sigprovNameFull);
679 	}
680 	if(pData-&gt;useCryprov) {
681 		pData-&gt;cryprov.Destruct(&amp;pData-&gt;cryprovData);
682 		obj.ReleaseObj(__FILE__, pData-&gt;cryprovNameFull+2, pData-&gt;cryprovNameFull,
683 			       (void*) &amp;pData-&gt;cryprov);
684 		free(pData-&gt;cryprovName);
685 		free(pData-&gt;cryprovNameFull);
686 	}
687 	pthread_mutex_destroy(&amp;pData-&gt;mutWrite);
688 ENDfreeInstance
689 BEGINfreeWrkrInstance
690 CODESTARTfreeWrkrInstance
691 ENDfreeWrkrInstance
692 BEGINtryResume
693 CODESTARTtryResume
694 ENDtryResume
695 BEGINbeginTransaction
696 CODESTARTbeginTransaction
697 ENDbeginTransaction
698 BEGINcommitTransaction
699 	instanceData *__restrict__ const pData = pWrkrData-&gt;pData;
700 	unsigned i;
701 CODESTARTcommitTransaction
702 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
703 	for(i = 0 ; i &lt; nParams ; ++i) {
704 		CHKiRet(writeFile(pData, pParams, i));
705 	}
706 	if(pData-&gt;bFlushOnTXEnd &amp;&amp; pData-&gt;pStrm != NULL) {
707 		CHKiRet(strm.Flush(pData-&gt;pStrm));
708 	}
709 finalize_it:
710 	if (iRet != RS_RET_OK) {
711 		if (runModConf-&gt;bDynafileDoNotSuspend == 0 || !(pData-&gt;bDynamicName)) {
712 			LogError(0, iRet, "suspending action");
713 			iRet = RS_RET_SUSPENDED;
714 		}
715 		else {
716 			LogError(0, iRet, "discarding message");
717 		}
718 	}
719 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
720 ENDcommitTransaction
721 static void
722 setInstParamDefaults(instanceData *__restrict__ const pData)
723 {
724 	pData-&gt;fname = NULL;
725 	pData-&gt;tplName = NULL;
726 	pData-&gt;fileUID = loadModConf-&gt;fileUID;
727 	pData-&gt;fileGID = loadModConf-&gt;fileGID;
728 	pData-&gt;dirUID = loadModConf-&gt;dirUID;
729 	pData-&gt;dirGID = loadModConf-&gt;dirGID;
730 	pData-&gt;bFailOnChown = 1;
731 	pData-&gt;iDynaFileCacheSize = 10;
732 	pData-&gt;fCreateMode = loadModConf-&gt;fCreateMode;
733 	pData-&gt;fDirCreateMode = loadModConf-&gt;fDirCreateMode;
734 	pData-&gt;bCreateDirs = 1;
735 	pData-&gt;bSyncFile = 0;
736 	pData-&gt;iZipLevel = 0;
737 	pData-&gt;bVeryRobustZip = 0;
738 	pData-&gt;bFlushOnTXEnd = FLUSHONTX_DFLT;
739 	pData-&gt;iIOBufSize = IOBUF_DFLT_SIZE;
740 	pData-&gt;iFlushInterval = FLUSH_INTRVL_DFLT;
741 	pData-&gt;bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
742 	pData-&gt;sigprovName = NULL;
743 	pData-&gt;cryprovName = NULL;
744 	pData-&gt;useSigprov = 0;
745 	pData-&gt;useCryprov = 0;
746 	pData-&gt;iCloseTimeout = -1;
747 }
748 static rsRetVal
749 setupInstStatsCtrs(instanceData *__restrict__ const pData)
750 {
751 	uchar ctrName[512];
752 	DEFiRet;
753 	if(!pData-&gt;bDynamicName) {
754 		FINALIZE;
755 	}
756 	snprintf((char*)ctrName, sizeof(ctrName), "dynafile cache %s", pData-&gt;fname);
757 	ctrName[sizeof(ctrName)-1] = '\0'; 	CHKiRet(statsobj.Construct(&amp;(pData-&gt;stats)));
758 	CHKiRet(statsobj.SetName(pData-&gt;stats, ctrName));
759 	CHKiRet(statsobj.SetOrigin(pData-&gt;stats, (uchar*)"omfile"));
760 	STATSCOUNTER_INIT(pData-&gt;ctrRequests, pData-&gt;mutCtrRequests);
761 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("requests"),
762 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrRequests)));
763 	STATSCOUNTER_INIT(pData-&gt;ctrLevel0, pData-&gt;mutCtrLevel0);
764 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("level0"),
765 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrLevel0)));
766 	STATSCOUNTER_INIT(pData-&gt;ctrMiss, pData-&gt;mutCtrMiss);
767 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("missed"),
768 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMiss)));
769 	STATSCOUNTER_INIT(pData-&gt;ctrEvict, pData-&gt;mutCtrEvict);
770 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("evicted"),
771 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrEvict)));
772 	STATSCOUNTER_INIT(pData-&gt;ctrMax, pData-&gt;mutCtrMax);
773 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("maxused"),
774 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrMax)));
775 	STATSCOUNTER_INIT(pData-&gt;ctrCloseTimeouts, pData-&gt;mutCtrCloseTimeouts);
776 	CHKiRet(statsobj.AddCounter(pData-&gt;stats, UCHAR_CONSTANT("closetimeouts"),
777 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pData-&gt;ctrCloseTimeouts)));
778 	CHKiRet(statsobj.ConstructFinalize(pData-&gt;stats));
779 finalize_it:
780 	RETiRet;
781 }
782 static void
783 initSigprov(instanceData *__restrict__ const pData, struct nvlst *lst)
784 {
785 	uchar szDrvrName[1024];
786 	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), "lmsig_%s", pData-&gt;sigprovName)
787 		== sizeof(szDrvrName)) {
788 		parser_errmsg("omfile: signature provider "
789 				"name is too long: '%s' - signatures disabled",
790 				pData-&gt;sigprovName);
791 		goto done;
792 	}
793 	pData-&gt;sigprovNameFull = ustrdup(szDrvrName);
794 	pData-&gt;sigprov.ifVersion = sigprovCURR_IF_VERSION;
795 	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;sigprov)
796 		!= RS_RET_OK) {
797 		parser_errmsg("omfile: could not load "
798 				"signature provider '%s' - signatures disabled",
799 				szDrvrName);
800 		goto done;
801 	}
802 	if(pData-&gt;sigprov.Construct(&amp;pData-&gt;sigprovData) != RS_RET_OK) {
803 		parser_errmsg("omfile: error constructing "
804 				"signature provider %s dataset - signatures disabled",
805 				szDrvrName);
806 		goto done;
807 	}
808 	pData-&gt;sigprov.SetCnfParam(pData-&gt;sigprovData, lst);
809 	dbgprintf("loaded signature provider %s, data instance at %p\n",
810 		  szDrvrName, pData-&gt;sigprovData);
811 	pData-&gt;useSigprov = 1;
812 done:	return;
813 }
814 static rsRetVal
815 initCryprov(instanceData *__restrict__ const pData, struct nvlst *lst)
816 {
817 	uchar szDrvrName[1024];
818 	DEFiRet;
819 	if(snprintf((char*)szDrvrName, sizeof(szDrvrName), "lmcry_%s", pData-&gt;cryprovName)
820 		== sizeof(szDrvrName)) {
821 		parser_errmsg("omfile: crypto provider "
822 				"name is too long: '%s' - encryption disabled",
823 				pData-&gt;cryprovName);
824 		ABORT_FINALIZE(RS_RET_ERR);
825 	}
826 	pData-&gt;cryprovNameFull = ustrdup(szDrvrName);
827 	pData-&gt;cryprov.ifVersion = cryprovCURR_IF_VERSION;
828 	if(obj.UseObj(__FILE__, szDrvrName, szDrvrName, (void*) &amp;pData-&gt;cryprov)
829 		!= RS_RET_OK) {
830 		parser_errmsg("omfile: could not load "
831 				"crypto provider '%s' - encryption disabled",
832 				szDrvrName);
833 		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
834 	}
835 	if(pData-&gt;cryprov.Construct(&amp;pData-&gt;cryprovData) != RS_RET_OK) {
836 		parser_errmsg("omfile: error constructing "
837 				"crypto provider %s dataset - encryption disabled",
838 				szDrvrName);
839 		ABORT_FINALIZE(RS_RET_CRYPROV_ERR);
840 	}
841 	CHKiRet(pData-&gt;cryprov.SetCnfParam(pData-&gt;cryprovData, lst, CRYPROV_PARAMTYPE_REGULAR));
842 	dbgprintf("loaded crypto provider %s, data instance at %p\n",
843 		  szDrvrName, pData-&gt;cryprovData);
844 	pData-&gt;useCryprov = 1;
845 finalize_it:
846 	RETiRet;
847 }
848 BEGINnewActInst
849 	struct cnfparamvals *pvals;
850 	uchar *tplToUse;
851 	int i;
852 CODESTARTnewActInst
853 	DBGPRINTF("newActInst (omfile)\n");
854 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
855 	if(pvals == NULL) {
856 		parser_errmsg("omfile: either the \"file\" or "
857 				"\"dynafile\" parameter must be given");
858 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
859 	}
860 	if(Debug) {
861 		dbgprintf("action param blk in omfile:\n");
862 		cnfparamsPrint(&amp;actpblk, pvals);
863 	}
864 	CHKiRet(createInstance(&amp;pData));
865 	setInstParamDefaults(pData);
866 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
867 		if(!pvals[i].bUsed)
868 			continue;
869 		if(!strcmp(actpblk.descr[i].name, "dynafilecachesize")) {
870 <a name="2"></a>			pData-&gt;iDynaFileCacheSize = (uint) pvals[i].val.d.n;
871 		} else if(!strcmp(actpblk.descr[i].name, "ziplevel")) {
872 			pData-&gt;iZipLevel = (int) pvals[i].val.d.n;
873 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "flushinterval")) {
874 			pData-&gt;iFlushInterval = pvals[i].val.d.n;
875 		} else if(!strcmp(actpblk.descr[i].name, "veryrobustzip")) {
876 			pData-&gt;bVeryRobustZip = pvals[i].val.d.n;
877 		} else if(!strcmp(actpblk.descr[i].name, "asyncwriting")) {
878 			pData-&gt;bUseAsyncWriter = pvals[i].val.d.n;
879 		} else if(!strcmp(actpblk.descr[i].name, "flushontxend")) {
880 			pData-&gt;bFlushOnTXEnd = pvals[i].val.d.n;
881 		} else if(!strcmp(actpblk.descr[i].name, "iobuffersize")) {</b></font>
882 			pData-&gt;iIOBufSize = (uint) pvals[i].val.d.n;
883 		} else if(!strcmp(actpblk.descr[i].name, "dirowner")) {
884 			pData-&gt;dirUID = (int) pvals[i].val.d.n;
885 		} else if(!strcmp(actpblk.descr[i].name, "dirownernum")) {
886 			pData-&gt;dirUID = (int) pvals[i].val.d.n;
887 		} else if(!strcmp(actpblk.descr[i].name, "dirgroup")) {
888 			pData-&gt;dirGID = (int) pvals[i].val.d.n;
889 		} else if(!strcmp(actpblk.descr[i].name, "dirgroupnum")) {
890 			pData-&gt;dirGID = (int) pvals[i].val.d.n;
891 		} else if(!strcmp(actpblk.descr[i].name, "fileowner")) {
892 			pData-&gt;fileUID = (int) pvals[i].val.d.n;
893 		} else if(!strcmp(actpblk.descr[i].name, "fileownernum")) {
894 			pData-&gt;fileUID = (int) pvals[i].val.d.n;
895 		} else if(!strcmp(actpblk.descr[i].name, "filegroup")) {
896 			pData-&gt;fileGID = (int) pvals[i].val.d.n;
897 		} else if(!strcmp(actpblk.descr[i].name, "filegroupnum")) {
898 			pData-&gt;fileGID = (int) pvals[i].val.d.n;
899 		} else if(!strcmp(actpblk.descr[i].name, "dircreatemode")) {
900 			pData-&gt;fDirCreateMode = (int) pvals[i].val.d.n;
901 		} else if(!strcmp(actpblk.descr[i].name, "filecreatemode")) {
902 			pData-&gt;fCreateMode = (int) pvals[i].val.d.n;
903 		} else if(!strcmp(actpblk.descr[i].name, "failonchownfailure")) {
904 			pData-&gt;bFailOnChown = (int) pvals[i].val.d.n;
905 		} else if(!strcmp(actpblk.descr[i].name, "sync")) {
906 			pData-&gt;bSyncFile = (int) pvals[i].val.d.n;
907 		} else if(!strcmp(actpblk.descr[i].name, "createdirs")) {
908 			pData-&gt;bCreateDirs = (int) pvals[i].val.d.n;
909 		} else if(!strcmp(actpblk.descr[i].name, "file")) {
910 			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
911 			CODE_STD_STRING_REQUESTnewActInst(1)
912 			pData-&gt;bDynamicName = 0;
913 		} else if(!strcmp(actpblk.descr[i].name, "dynafile")) {
914 			if(pData-&gt;fname != NULL) {
915 				parser_errmsg("omfile: both \"file\" and \"dynafile\" set, will use dynafile");
916 			}
917 <a name="1"></a>			pData-&gt;fname = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
918 			CODE_STD_STRING_REQUESTnewActInst(2)
919 			pData-&gt;bDynamicName = 1;
920 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "template")) {
921 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
922 		} else if(!strcmp(actpblk.descr[i].name, "sig.provider")) {
923 			pData-&gt;sigprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
924 		} else if(!strcmp(actpblk.descr[i].name, "cry.provider")) {
925 			pData-&gt;cryprovName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
926 		} else if(!strcmp(actpblk.descr[i].name, "closetimeout")) {
927 			pData-&gt;iCloseTimeout = (int) pvals[i].val.d.n;</b></font>
928 		} else {
929 			dbgprintf("omfile: program error, non-handled "
930 			  "param '%s'\n", actpblk.descr[i].name);
931 		}
932 	}
933 	if(pData-&gt;fname == NULL) {
934 		parser_errmsg("omfile: either the \"file\" or "
935 				"\"dynafile\" parameter must be given");
936 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
937 	}
938 	if(pData-&gt;sigprovName != NULL) {
939 		initSigprov(pData, lst);
940 	}
941 	if(pData-&gt;cryprovName != NULL) {
942 		CHKiRet(initCryprov(pData, lst));
943 	}
944 	tplToUse = ustrdup((pData-&gt;tplName == NULL) ? getDfltTpl() : pData-&gt;tplName);
945 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, tplToUse, OMSR_NO_RQD_TPL_OPTS));
946 	pData-&gt;iNumTpls = 1;
947 	if(pData-&gt;bDynamicName) {
948 		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
949 		pData-&gt;iNumTpls = 2;
950 		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
951 				calloc(pData-&gt;iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
952 		pData-&gt;iCurrElt = -1;		  	}
953 	setupInstStatsCtrs(pData);
954 	if(pData-&gt;iCloseTimeout == -1) { 		pData-&gt;iCloseTimeout = (pData-&gt;bDynamicName) ? 10 : 0;
955 	}
956 	snprintf(pData-&gt;janitorID, sizeof(pData-&gt;janitorID), "omfile:%sfile:%s:%p",
957 		(pData-&gt;bDynamicName) ? "dyna" : "", pData-&gt;fname, pData);
958 	pData-&gt;janitorID[sizeof(pData-&gt;janitorID)-1] = '\0'; 
959 	if(pData-&gt;iCloseTimeout &gt; 0)
960 		janitorAddEtry(janitorCB, pData-&gt;janitorID, pData);
961 CODE_STD_FINALIZERnewActInst
962 	cnfparamvalsDestruct(pvals, &amp;actpblk);
963 ENDnewActInst
964 BEGINparseSelectorAct
965 	uchar fname[MAXFNAME];
966 CODESTARTparseSelectorAct
967 	if(!strncmp((char*) p, ":omfile:", sizeof(":omfile:") - 1)) {
968 		p += sizeof(":omfile:") - 1;
969 	}
970 	if(!(*p == '$' || *p == '?' || *p == '/' || *p == '.' || *p == '-'))
971 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
972 	CHKiRet(createInstance(&amp;pData));
973 	if(*p == '-') {
974 		pData-&gt;bSyncFile = 0;
975 		p++;
976 	} else {
977 		pData-&gt;bSyncFile = cs.bEnableSync;
978 	}
979 	pData-&gt;iSizeLimit = 0; 
980 	switch(*p) {
981 	case '$':
982 		CODE_STD_STRING_REQUESTparseSelectorAct(1)
983 		pData-&gt;iNumTpls = 1;
984 		CHKiRet(cflineParseOutchannel(pData, p, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS));
985 		pData-&gt;bDynamicName = 0;
986 		break;
987 		CODE_STD_STRING_REQUESTparseSelectorAct(2)
988 		pData-&gt;iNumTpls = 2;
989 		++p; 		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
990 		pData-&gt;fname = ustrdup(fname);
991 		pData-&gt;bDynamicName = 1;
992 		CHKiRet(OMSRsetEntry(*ppOMSR, 1, ustrdup(pData-&gt;fname), OMSR_NO_RQD_TPL_OPTS));
993 		CHKmalloc(pData-&gt;dynCache = (dynaFileCacheEntry**)
994 				calloc(cs.iDynaFileCacheSize, sizeof(dynaFileCacheEntry*)));
995 		break;
996 	case '/':
997 	case '.':
998 		CODE_STD_STRING_REQUESTparseSelectorAct(1)
999 		pData-&gt;iNumTpls = 1;
1000 		CHKiRet(cflineParseFileName(p, fname, *ppOMSR, 0, OMSR_NO_RQD_TPL_OPTS, getDfltTpl()));
1001 		pData-&gt;fname = ustrdup(fname);
1002 		pData-&gt;bDynamicName = 0;
1003 		break;
1004 	default:
1005 		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
1006 	}
1007 	pData-&gt;iDynaFileCacheSize = cs.iDynaFileCacheSize;
1008 	pData-&gt;fCreateMode = cs.fCreateMode;
1009 	pData-&gt;fDirCreateMode = cs.fDirCreateMode;
1010 	pData-&gt;bCreateDirs = cs.bCreateDirs;
1011 	pData-&gt;bFailOnChown = cs.bFailOnChown;
1012 	pData-&gt;fileUID = cs.fileUID;
1013 	pData-&gt;fileGID = cs.fileGID;
1014 	pData-&gt;dirUID = cs.dirUID;
1015 	pData-&gt;dirGID = cs.dirGID;
1016 	pData-&gt;iZipLevel = cs.iZipLevel;
1017 	pData-&gt;bFlushOnTXEnd = cs.bFlushOnTXEnd;
1018 	pData-&gt;iIOBufSize = (uint) cs.iIOBufSize;
1019 	pData-&gt;iFlushInterval = cs.iFlushInterval;
1020 	pData-&gt;bUseAsyncWriter = cs.bUseAsyncWriter;
1021 	pData-&gt;bVeryRobustZip = 0;		pData-&gt;iCloseTimeout = 0;		setupInstStatsCtrs(pData);
1022 CODE_STD_FINALIZERparseSelectorAct
1023 ENDparseSelectorAct
1024 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
1025 {
1026 	cs.fileUID = -1;
1027 	cs.fileGID = -1;
1028 	cs.dirUID = -1;
1029 	cs.dirGID = -1;
1030 	cs.bFailOnChown = 1;
1031 	cs.iDynaFileCacheSize = 10;
1032 	cs.fCreateMode = 0644;
1033 	cs.fDirCreateMode = 0700;
1034 	cs.bCreateDirs = 1;
1035 	cs.bEnableSync = 0;
1036 	cs.iZipLevel = 0;
1037 	cs.bFlushOnTXEnd = FLUSHONTX_DFLT;
1038 	cs.iIOBufSize = IOBUF_DFLT_SIZE;
1039 	cs.iFlushInterval = FLUSH_INTRVL_DFLT;
1040 	cs.bUseAsyncWriter = USE_ASYNCWRITER_DFLT;
1041 	free(pszFileDfltTplName);
1042 	pszFileDfltTplName = NULL;
1043 	return RS_RET_OK;
1044 }
1045 BEGINdoHUP
1046 CODESTARTdoHUP
1047 	pthread_mutex_lock(&amp;pData-&gt;mutWrite);
1048 	if(pData-&gt;bDynamicName) {
1049 		dynaFileFreeCacheEntries(pData);
1050 	} else {
1051 		if(pData-&gt;pStrm != NULL) {
1052 			closeFile(pData);
1053 		}
1054 	}
1055 	pthread_mutex_unlock(&amp;pData-&gt;mutWrite);
1056 ENDdoHUP
1057 BEGINmodExit
1058 CODESTARTmodExit
1059 	objRelease(glbl, CORE_COMPONENT);
1060 	objRelease(strm, CORE_COMPONENT);
1061 	objRelease(statsobj, CORE_COMPONENT);
1062 	DESTROY_ATOMIC_HELPER_MUT(mutClock);
1063 ENDmodExit
1064 BEGINqueryEtryPt
1065 CODESTARTqueryEtryPt
1066 CODEqueryEtryPt_STD_OMODTX_QUERIES
1067 CODEqueryEtryPt_STD_OMOD8_QUERIES
1068 CODEqueryEtryPt_STD_CONF2_QUERIES
1069 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1070 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1071 CODEqueryEtryPt_doHUP
1072 ENDqueryEtryPt
1073 BEGINmodInit(File)
1074 CODESTARTmodInit
1075 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1076 INITLegCnfVars
1077 	CHKiRet(objUse(strm, CORE_COMPONENT));
1078 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1079 	INIT_ATOMIC_HELPER_MUT(mutClock);
1080 	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
1081 	DBGPRINTF("omfile: %susing transactional output interface.\n", bCoreSupportsBatching ? "" : "not ");
1082 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dynafilecachesize", 0, eCmdHdlrInt, setDynaFileCacheSize,
1083 		NULL, STD_LOADABLE_MODULE_ID));
1084 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileziplevel", 0, eCmdHdlrInt, NULL, &amp;cs.iZipLevel,
1085 		STD_LOADABLE_MODULE_ID));
1086 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileflushinterval", 0, eCmdHdlrInt, NULL, &amp;cs.iFlushInterval,
1087 		STD_LOADABLE_MODULE_ID));
1088 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileasyncwriting", 0, eCmdHdlrBinary, NULL, &amp;cs.bUseAsyncWriter,
1089 		STD_LOADABLE_MODULE_ID));
1090 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileflushontxend", 0, eCmdHdlrBinary, NULL, &amp;cs.bFlushOnTXEnd,
1091 		STD_LOADABLE_MODULE_ID));
1092 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileiobuffersize", 0, eCmdHdlrSize, NULL, &amp;cs.iIOBufSize,
1093 		STD_LOADABLE_MODULE_ID));
1094 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirowner", 0, eCmdHdlrUID, NULL, &amp;cs.dirUID,
1095 		STD_LOADABLE_MODULE_ID));
1096 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirownernum", 0, eCmdHdlrInt, NULL, &amp;cs.dirUID,
1097 		STD_LOADABLE_MODULE_ID));
1098 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirgroup", 0, eCmdHdlrGID, NULL, &amp;cs.dirGID,
1099 		STD_LOADABLE_MODULE_ID));
1100 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dirgroupnum", 0, eCmdHdlrInt, NULL, &amp;cs.dirGID,
1101 		STD_LOADABLE_MODULE_ID));
1102 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"fileowner", 0, eCmdHdlrUID, NULL, &amp;cs.fileUID,
1103 		STD_LOADABLE_MODULE_ID));
1104 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"fileownernum", 0, eCmdHdlrInt, NULL, &amp;cs.fileUID,
1105 		STD_LOADABLE_MODULE_ID));
1106 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filegroup", 0, eCmdHdlrGID, NULL, &amp;cs.fileGID,
1107 		STD_LOADABLE_MODULE_ID));
1108 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filegroupnum", 0, eCmdHdlrInt, NULL, &amp;cs.fileGID,
1109 		STD_LOADABLE_MODULE_ID));
1110 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"dircreatemode", 0, eCmdHdlrFileCreateMode, NULL,
1111 		&amp;cs.fDirCreateMode, STD_LOADABLE_MODULE_ID));
1112 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"filecreatemode", 0, eCmdHdlrFileCreateMode, NULL,
1113 		&amp;cs.fCreateMode, STD_LOADABLE_MODULE_ID));
1114 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"createdirs", 0, eCmdHdlrBinary, NULL, &amp;cs.bCreateDirs,
1115 		STD_LOADABLE_MODULE_ID));
1116 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"failonchownfailure", 0, eCmdHdlrBinary, NULL, &amp;cs.bFailOnChown,
1117 		STD_LOADABLE_MODULE_ID));
1118 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"omfileforcechown", 0, eCmdHdlrGoneAway, NULL, NULL,
1119 		STD_LOADABLE_MODULE_ID));
1120 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionfileenablesync", 0, eCmdHdlrBinary, NULL, &amp;cs.bEnableSync,
1121 		STD_LOADABLE_MODULE_ID));
1122 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionfiledefaulttemplate", 0, eCmdHdlrGetWord, setLegacyDfltTpl,
1123 		NULL, STD_LOADABLE_MODULE_ID));
1124 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
1125 		NULL, STD_LOADABLE_MODULE_ID));
1126 	CHKiRet(objUse(glbl, CORE_COMPONENT));
1127 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>mmkubernetes.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifndef _GNU_SOURCE
2 #  define _GNU_SOURCE
3 #endif
4 #include "config.h"
5 #include "rsyslog.h"
6 #include &lt;stdio.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;stdlib.h&gt;
9 #include &lt;string.h&gt;
10 #include &lt;assert.h&gt;
11 #include &lt;errno.h&gt;
12 #include &lt;unistd.h&gt;
13 #include &lt;sys/stat.h&gt;
14 #include &lt;libestr.h&gt;
15 #include &lt;liblognorm.h&gt;
16 #include &lt;json.h&gt;
17 #include &lt;curl/curl.h&gt;
18 #include &lt;curl/easy.h&gt;
19 #include &lt;pthread.h&gt;
20 #include "conf.h"
21 #include "syslogd-types.h"
22 #include "module-template.h"
23 #include "errmsg.h"
24 #include "statsobj.h"
25 #include "regexp.h"
26 #include "hashtable.h"
27 #include "hashtable_itr.h"
28 #include "srUtils.h"
29 #include "unicode-helper.h"
30 #include "datetime.h"
31 MODULE_TYPE_OUTPUT MODULE_TYPE_KEEP MODULE_CNFNAME("mmkubernetes")
32 DEF_OMOD_STATIC_DATA
33 DEFobjCurrIf(regexp)
34 DEFobjCurrIf(statsobj)
35 DEFobjCurrIf(datetime)
36 #define HAVE_LOADSAMPLESFROMSTRING 1
37 #if defined(NO_LOADSAMPLESFROMSTRING)
38 #undef HAVE_LOADSAMPLESFROMSTRING
39 #endif
40 #define DFLT_FILENAME_LNRULES "rule=:/var/log/containers/%pod_name:char-to:_%_"\
41 	"%namespace_name:char-to:_%_%container_name_and_id:char-to:.%.log"
42 #define DFLT_FILENAME_RULEBASE "/etc/rsyslog.d/k8s_filename.rulebase"
43 #define DFLT_CONTAINER_LNRULES "rule=:%k8s_prefix:char-to:_%_%container_name:char-to:.%."\
44 	"%container_hash:char-to:_%_"\
45 	"%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%\n"\
46 	"rule=:%k8s_prefix:char-to:_%_%container_name:char-to:_%_"\
47 	"%pod_name:char-to:_%_%namespace_name:char-to:_%_%not_used_1:char-to:_%_%not_used_2:rest%"
48 #define DFLT_CONTAINER_RULEBASE "/etc/rsyslog.d/k8s_container_name.rulebase"
49 #define DFLT_SRCMD_PATH "$!metadata!filename"
50 #define DFLT_DSTMD_PATH "$!"
51 #define DFLT_DE_DOT 1 #define DFLT_DE_DOT_SEPARATOR "_"
52 #define DFLT_CONTAINER_NAME "$!CONTAINER_NAME" #define DFLT_CONTAINER_ID_FULL "$!CONTAINER_ID_FULL" #define DFLT_KUBERNETES_URL "https://kubernetes.default.svc.cluster.local:443"
53 #if defined(ENABLE_OPENSSL) &amp;&amp; defined(X509_V_FLAG_PARTIAL_CHAIN)
54 #define SUPPORT_SSL_PARTIAL_CHAIN 1
55 #endif
56 struct cache_entry_s {
57 	time_t ttl; 	void *data; };
58 static struct cache_s {
59 	const uchar *kbUrl;
60 	struct hashtable *mdHt;
61 	struct hashtable *nsHt;
62 	pthread_mutex_t *cacheMtx;
63 	int lastBusyTime; 	time_t expirationTime; } **caches;
64 typedef struct {
65 	int nmemb;
66 	uchar **patterns;
67 	regex_t *regexps;
68 } annotation_match_t;
69 struct modConfData_s {
70 	rsconf_t *pConf;		uchar *kubernetesUrl;		uchar *srcMetadataPath;		uchar *dstMetadataPath;		uchar *caCertFile; 	uchar *myCertFile; 	uchar *myPrivKeyFile; 	sbool allowUnsignedCerts; 	sbool skipVerifyHost; 	uchar *token; 	uchar *tokenFile; 	sbool de_dot; 	uchar *de_dot_separator; 	size_t de_dot_separator_len; 	annotation_match_t annotation_match; 	char *fnRules; 	uchar *fnRulebase; 	char *contRules; 	uchar *contRulebase; 	int busyRetryInterval; 	sbool sslPartialChain; 	int cacheEntryTTL; 	int cacheExpireInterval; };
71 typedef struct _instanceData {
72 	msgPropDescr_t *contNameDescr; 	msgPropDescr_t *contIdFullDescr; 	struct cache_s *cache;
73 	int busyRetryInterval; 	sbool sslPartialChain; 	int cacheEntryTTL; 	int cacheExpireInterval; } instanceData;
74 typedef struct wrkrInstanceData {
75 	instanceData *pData;
76 	CURL *curlCtx;
77 	struct curl_slist *curlHdr;
78 	char *curlRply;
79 	size_t curlRplyLen;
80 	statsobj_t *stats; 	STATSCOUNTER_DEF(k8sRecordSeen, mutK8sRecordSeen);
81 	STATSCOUNTER_DEF(namespaceMetadataSuccess, mutNamespaceMetadataSuccess);
82 	STATSCOUNTER_DEF(namespaceMetadataNotFound, mutNamespaceMetadataNotFound);
83 	STATSCOUNTER_DEF(namespaceMetadataBusy, mutNamespaceMetadataBusy);
84 	STATSCOUNTER_DEF(namespaceMetadataError, mutNamespaceMetadataError);
85 	STATSCOUNTER_DEF(podMetadataSuccess, mutPodMetadataSuccess);
86 	STATSCOUNTER_DEF(podMetadataNotFound, mutPodMetadataNotFound);
87 	STATSCOUNTER_DEF(podMetadataBusy, mutPodMetadataBusy);
88 	STATSCOUNTER_DEF(podMetadataError, mutPodMetadataError);
89 	STATSCOUNTER_DEF(podCacheNumEntries, mutPodCacheNumEntries);
90 	STATSCOUNTER_DEF(namespaceCacheNumEntries, mutNamespaceCacheNumEntries);
91 	STATSCOUNTER_DEF(podCacheHits, mutPodCacheHits);
92 	STATSCOUNTER_DEF(namespaceCacheHits, mutNamespaceCacheHits);
93 	STATSCOUNTER_DEF(podCacheMisses, mutPodCacheMisses);
94 	STATSCOUNTER_DEF(namespaceCacheMisses, mutNamespaceCacheMisses);
95 } wrkrInstanceData_t;
96 static struct cnfparamdescr modpdescr[] = {
97 	{ "kubernetesurl", eCmdHdlrString, 0 },
98 	{ "srcmetadatapath", eCmdHdlrString, 0 },
99 	{ "dstmetadatapath", eCmdHdlrString, 0 },
100 	{ "tls.cacert", eCmdHdlrString, 0 },
101 	{ "tls.mycert", eCmdHdlrString, 0 },
102 	{ "tls.myprivkey", eCmdHdlrString, 0 },
103 <a name="0"></a>	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
104 	{ "skipverifyhost", eCmdHdlrBinary, 0 },
105 	{ "token", eCmdHdlrString, 0 },
106 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "tokenfile", eCmdHdlrString, 0 },
107 	{ "annotation_match", eCmdHdlrArray, 0 },
108 	{ "de_dot", eCmdHdlrBinary, 0 },
109 	{ "de_dot_separator", eCmdHdlrString, 0 },
110 	{ "filenamerulebase", eCmdHdlrString, 0 },
111 	{ "containerrulebase", eCmdHdlrString, 0 },
112 	{ "busyretryinterval", eCmdHdlrInt, 0 },
113 	{ "sslpartialchain", eCmdHdlrBinary, 0 },
114 	{ "cacheentryttl", eCmdHdlrInt, 0 },
115 	{ "cacheexpireinterval", eCmdHdlrInt, 0 }
116 #if HAVE_LOADSAMPLESFROMSTRING == 1
117 	,
118 	{ "filenamerules", eCmdHdlrArray, 0 },
119 	{ "containerrules", eCmdHdlrArray, 0 }
120 #endif
121 };
122 static struct cnfparamblk modpblk = {
123 	CNFPARAMBLK_VERSION,
124 	sizeof(modpdescr)/sizeof(struct cnfparamdescr),
125 	modpdescr
126 };
127 static struct cnfparamdescr actpdescr[] = {
128 	{ "kubernetesurl", eCmdHdlrString, 0 },
129 	{ "srcmetadatapath", eCmdHdlrString, 0 },
130 	{ "dstmetadatapath", eCmdHdlrString, 0 },
131 	{ "tls.cacert", eCmdHdlrString, 0 },
132 	{ "tls.mycert", eCmdHdlrString, 0 },
133 	{ "tls.myprivkey", eCmdHdlrString, 0 },
134 	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
135 	{ "skipverifyhost", eCmdHdlrBinary, 0 },
136 	{ "token", eCmdHdlrString, 0 },
137 	{ "tokenfile", eCmdHdlrString, 0 },
138 	{ "annotation_match", eCmdHdlrArray, 0 },
139 	{ "de_dot", eCmdHdlrBinary, 0 },
140 	{ "de_dot_separator", eCmdHdlrString, 0 },
141 	{ "filenamerulebase", eCmdHdlrString, 0 },
142 	{ "containerrulebase", eCmdHdlrString, 0 },
143 	{ "busyretryinterval", eCmdHdlrInt, 0 },
144 	{ "sslpartialchain", eCmdHdlrBinary, 0 },
145 	{ "cacheentryttl", eCmdHdlrInt, 0 },
146 	{ "cacheexpireinterval", eCmdHdlrInt, 0 }
147 #if HAVE_LOADSAMPLESFROMSTRING == 1
148 	,
149 	{ "filenamerules", eCmdHdlrArray, 0 },
150 	{ "containerrules", eCmdHdlrArray, 0 }</b></font>
151 #endif
152 };
153 static struct cnfparamblk actpblk =
154 	{ CNFPARAMBLK_VERSION,
155 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
156 	  actpdescr
157 	};
158 static modConfData_t *loadModConf = NULL;	static modConfData_t *runModConf = NULL;	
159 static void free_annotationmatch(annotation_match_t *match) {
160 	if (match) {
161 		for(int ii = 0 ; ii &lt; match-&gt;nmemb; ++ii) {
162 			if (match-&gt;patterns)
163 				free(match-&gt;patterns[ii]);
164 			if (match-&gt;regexps)
165 				regexp.regfree(&amp;match-&gt;regexps[ii]);
166 		}
167 		free(match-&gt;patterns);
168 		match-&gt;patterns = NULL;
169 		free(match-&gt;regexps);
170 		match-&gt;regexps = NULL;
171 		match-&gt;nmemb = 0;
172 	}
173 }
174 static int init_annotationmatch(annotation_match_t *match, struct cnfarray *ar) {
175 	DEFiRet;
176 	match-&gt;nmemb = ar-&gt;nmemb;
177 	CHKmalloc(match-&gt;patterns = calloc(sizeof(uchar*), match-&gt;nmemb));
178 	CHKmalloc(match-&gt;regexps = calloc(sizeof(regex_t), match-&gt;nmemb));
179 	for(int jj = 0; jj &lt; ar-&gt;nmemb; ++jj) {
180 		int rexret = 0;
181 		match-&gt;patterns[jj] = (uchar*)es_str2cstr(ar-&gt;arr[jj], NULL);
182 		rexret = regexp.regcomp(&amp;match-&gt;regexps[jj],
183 				(char *)match-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
184 		if (0 != rexret) {
185 			char errMsg[512];
186 			regexp.regerror(rexret, &amp;match-&gt;regexps[jj], errMsg, sizeof(errMsg));
187 			iRet = RS_RET_CONFIG_ERROR;
188 			LogError(0, iRet,
189 					"error: could not compile annotation_match string [%s]"
190 					" into an extended regexp - %d: %s\n",
191 					match-&gt;patterns[jj], rexret, errMsg);
192 			break;
193 		}
194 	}
195 finalize_it:
196 	if (iRet)
197 		free_annotationmatch(match);
198 	RETiRet;
199 }
200 static int copy_annotationmatch(annotation_match_t *src, annotation_match_t *dest) {
201 	DEFiRet;
202 	dest-&gt;nmemb = src-&gt;nmemb;
203 	CHKmalloc(dest-&gt;patterns = malloc(sizeof(uchar*) * dest-&gt;nmemb));
204 	CHKmalloc(dest-&gt;regexps = calloc(sizeof(regex_t), dest-&gt;nmemb));
205 	for(int jj = 0 ; jj &lt; src-&gt;nmemb ; ++jj) {
206 		CHKmalloc(dest-&gt;patterns[jj] = (uchar*)strdup((char *)src-&gt;patterns[jj]));
207 		regexp.regcomp(&amp;dest-&gt;regexps[jj], (char *)dest-&gt;patterns[jj], REG_EXTENDED|REG_NOSUB);
208 	}
209 finalize_it:
210 	if (iRet)
211 	free_annotationmatch(dest);
212 	RETiRet;
213 }
214 static struct json_object *match_annotations(annotation_match_t *match,
215 		struct json_object *annotations) {
216 	struct json_object *ret = NULL;
217 	for (int jj = 0; jj &lt; match-&gt;nmemb; ++jj) {
218 		struct json_object_iterator it = json_object_iter_begin(annotations);
219 		struct json_object_iterator itEnd = json_object_iter_end(annotations);
220 		for (;!json_object_iter_equal(&amp;it, &amp;itEnd); json_object_iter_next(&amp;it)) {
221 			const char *const key = json_object_iter_peek_name(&amp;it);
222 			if (!ret || !fjson_object_object_get_ex(ret, key, NULL)) {
223 				if (!regexp.regexec(&amp;match-&gt;regexps[jj], key, 0, NULL, 0)) {
224 					if (!ret) {
225 						ret = json_object_new_object();
226 					}
227 					json_object_object_add(ret, key,
228 						json_object_get(json_object_iter_peek_value(&amp;it)));
229 				}
230 			}
231 		}
232 	}
233 	return ret;
234 }
235 static struct json_object *de_dot_json_object(struct json_object *jobj,
236 		const char *delim, size_t delim_len) {
237 	struct json_object *ret = NULL;
238 	struct json_object_iterator it = json_object_iter_begin(jobj);
239 	struct json_object_iterator itEnd = json_object_iter_end(jobj);
240 	es_str_t *new_es_key = NULL;
241 	DEFiRet;
242 	ret = json_object_new_object();
243 	while (!json_object_iter_equal(&amp;it, &amp;itEnd)) {
244 		const char *const key = json_object_iter_peek_name(&amp;it);
245 		const char *cc = strstr(key, ".");
246 		if (NULL == cc) {
247 			json_object_object_add(ret, key,
248 					json_object_get(json_object_iter_peek_value(&amp;it)));
249 		} else {
250 			char *new_key = NULL;
251 			const char *prevcc = key;
252 			new_es_key = es_newStrFromCStr(key, (es_size_t)(cc-prevcc));
253 			while (cc) {
254 				if (es_addBuf(&amp;new_es_key, (char *)delim, (es_size_t)delim_len))
255 					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
256 				cc += 1; 				prevcc = cc; 				if ((cc = strstr(prevcc, ".")) || (cc = strchr(prevcc, '\0'))) {
257 					if (es_addBuf(&amp;new_es_key, (char *)prevcc, (es_size_t)(cc-prevcc)))
258 						ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
259 					if (!*cc)
260 						cc = NULL; 				}
261 			}
262 			new_key = es_str2cstr(new_es_key, NULL);
263 			es_deleteStr(new_es_key);
264 			new_es_key = NULL;
265 			json_object_object_add(ret, new_key,
266 					json_object_get(json_object_iter_peek_value(&amp;it)));
267 			free(new_key);
268 		}
269 		json_object_iter_next(&amp;it);
270 	}
271 finalize_it:
272 	if (iRet != RS_RET_OK) {
273 		json_object_put(ret);
274 		ret = NULL;
275 	}
276 	if (new_es_key)
277 		es_deleteStr(new_es_key);
278 	return ret;
279 }
280 static void parse_labels_annotations(struct json_object *jMetadata,
281 		annotation_match_t *match, sbool de_dot,
282 		const char *delim, size_t delim_len) {
283 	struct json_object *jo = NULL;
284 	if (fjson_object_object_get_ex(jMetadata, "annotations", &amp;jo)) {
285 		if ((jo = match_annotations(match, jo)))
286 			json_object_object_add(jMetadata, "annotations", jo);
287 		else
288 			json_object_object_del(jMetadata, "annotations");
289 	}
290 	if (de_dot) {
291 		struct json_object *jo2 = NULL;
292 		if (fjson_object_object_get_ex(jMetadata, "annotations", &amp;jo)) {
293 			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
294 				json_object_object_add(jMetadata, "annotations", jo2);
295 			}
296 		}
297 		if (fjson_object_object_get_ex(jMetadata, "labels", &amp;jo)) {
298 			if ((jo2 = de_dot_json_object(jo, delim, delim_len))) {
299 				json_object_object_add(jMetadata, "labels", jo2);
300 			}
301 		}
302 	}
303 }
304 #if HAVE_LOADSAMPLESFROMSTRING == 1
305 static int array_to_rules(struct cnfarray *ar, char **rules) {
306 	DEFiRet;
307 	es_str_t *tmpstr = NULL;
308 	es_size_t size = 0;
309 	if (rules == NULL)
310 		FINALIZE;
311 	*rules = NULL;
312 	if (!ar-&gt;nmemb)
313 		FINALIZE;
314 	for (int jj = 0; jj &lt; ar-&gt;nmemb; jj++)
315 		size += es_strlen(ar-&gt;arr[jj]);
316 	if (!size)
317 		FINALIZE;
318 	CHKmalloc(tmpstr = es_newStr(size));
319 	CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[0])));
320 	CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\n")));
321 	for(int jj=1; jj &lt; ar-&gt;nmemb; ++jj) {
322 		CHKiRet((es_addStr(&amp;tmpstr, ar-&gt;arr[jj])));
323 		CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\n")));
324 	}
325 	CHKiRet((es_addBufConstcstr(&amp;tmpstr, "\0")));
326 	CHKmalloc(*rules = es_str2cstr(tmpstr, NULL));
327 finalize_it:
328 	if (tmpstr) {
329 		es_deleteStr(tmpstr);
330 	}
331 	if (iRet != RS_RET_OK) {
332 		free(*rules);
333 		*rules = NULL;
334 	}
335 	RETiRet;
336 }
337 #endif
338 static void
339 errCallBack(void __attribute__((unused)) *cookie, const char *msg,
340 	    size_t __attribute__((unused)) lenMsg)
341 {
342 	LogError(0, RS_RET_ERR_LIBLOGNORM, "liblognorm error: %s", msg);
343 }
344 static rsRetVal
345 set_lnctx(ln_ctx *ctxln, char *instRules, uchar *instRulebase, char *modRules, uchar *modRulebase)
346 {
347 	DEFiRet;
348 	if (ctxln == NULL)
349 		FINALIZE;
350 	CHKmalloc(*ctxln = ln_initCtx());
351 	ln_setErrMsgCB(*ctxln, errCallBack, NULL);
352 	if(instRules) {
353 #if HAVE_LOADSAMPLESFROMSTRING == 1
354 		if(ln_loadSamplesFromString(*ctxln, instRules) !=0) {
355 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rules '%s' "
356 					"could not be loaded", instRules);
357 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
358 		}
359 #else
360 		(void)instRules;
361 #endif
362 	} else if(instRulebase) {
363 		if(ln_loadSamples(*ctxln, (char*) instRulebase) != 0) {
364 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
365 					"could not be loaded", instRulebase);
366 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
367 		}
368 	} else if(modRules) {
369 #if HAVE_LOADSAMPLESFROMSTRING == 1
370 		if(ln_loadSamplesFromString(*ctxln, modRules) !=0) {
371 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rules '%s' "
372 					"could not be loaded", modRules);
373 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
374 		}
375 #else
376 		(void)modRules;
377 #endif
378 	} else if(modRulebase) {
379 		if(ln_loadSamples(*ctxln, (char*) modRulebase) != 0) {
380 			LogError(0, RS_RET_NO_RULEBASE, "error: normalization rulebase '%s' "
381 					"could not be loaded", modRulebase);
382 			ABORT_FINALIZE(RS_RET_ERR_LIBLOGNORM_SAMPDB_LOAD);
383 		}
384 	}
385 finalize_it:
386 	if (iRet != RS_RET_OK){
387 		ln_exitCtx(*ctxln);
388 		*ctxln = NULL;
389 	}
390 	RETiRet;
391 }
392 BEGINbeginCnfLoad
393 CODESTARTbeginCnfLoad
394 	loadModConf = pModConf;
395 	pModConf-&gt;pConf = pConf;
396 ENDbeginCnfLoad
397 BEGINsetModCnf
398 	struct cnfparamvals *pvals = NULL;
399 	int i;
400 	FILE *fp = NULL;
401 	int ret;
402 	char errStr[1024];
403 CODESTARTsetModCnf
404 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
405 	if(pvals == NULL) {
406 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmkubernetes: "
407 			"error processing module config parameters [module(...)]");
408 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
409 	}
410 	if(Debug) {
411 		dbgprintf("module (global) param blk for mmkubernetes:\n");
412 		cnfparamsPrint(&amp;modpblk, pvals);
413 	}
414 	loadModConf-&gt;de_dot = DFLT_DE_DOT;
415 	loadModConf-&gt;busyRetryInterval = DFLT_BUSY_RETRY_INTERVAL;
416 	loadModConf-&gt;sslPartialChain = DFLT_SSL_PARTIAL_CHAIN;
417 	loadModConf-&gt;cacheEntryTTL = DFLT_CACHE_ENTRY_TTL;
418 	loadModConf-&gt;cacheExpireInterval = DFLT_CACHE_EXPIRE_INTERVAL;
419 <a name="1"></a>	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
420 		if(!pvals[i].bUsed) {
421 			continue;
422 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "kubernetesurl")) {
423 			free(loadModConf-&gt;kubernetesUrl);
424 			loadModConf-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
425 		} else if(!strcmp(modpblk.descr[i].name, "srcmetadatapath")) {
426 			free(loadModConf-&gt;srcMetadataPath);
427 			loadModConf-&gt;srcMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
428 		} else if(!strcmp(modpblk.descr[i].name, "dstmetadatapath")) {
429 			free(loadModConf-&gt;dstMetadataPath);
430 			loadModConf-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
431 		} else if(!strcmp(modpblk.descr[i].name, "tls.cacert")) {
432 			free(loadModConf-&gt;caCertFile);
433 			loadModConf-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);</b></font>
434 			fp = fopen((const char*)loadModConf-&gt;caCertFile, "r");
435 			if(fp == NULL) {
436 				rs_strerror_r(errno, errStr, sizeof(errStr));
437 				iRet = RS_RET_NO_FILE_ACCESS;
438 				LogError(0, iRet,
439 						"error: 'tls.cacert' file %s couldn't be accessed: %s\n",
440 						loadModConf-&gt;caCertFile, errStr);
441 				ABORT_FINALIZE(iRet);
442 			} else {
443 				fclose(fp);
444 				fp = NULL;
445 			}
446 		} else if(!strcmp(modpblk.descr[i].name, "tls.mycert")) {
447 			free(loadModConf-&gt;myCertFile);
448 			loadModConf-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
449 			fp = fopen((const char*)loadModConf-&gt;myCertFile, "r");
450 			if(fp == NULL) {
451 				rs_strerror_r(errno, errStr, sizeof(errStr));
452 				iRet = RS_RET_NO_FILE_ACCESS;
453 				LogError(0, iRet,
454 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
455 						loadModConf-&gt;myCertFile, errStr);
456 			} else {
457 				fclose(fp);
458 				fp = NULL;
459 			}
460 		} else if(!strcmp(modpblk.descr[i].name, "tls.myprivkey")) {
461 			loadModConf-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
462 			fp = fopen((const char*)loadModConf-&gt;myPrivKeyFile, "r");
463 			if(fp == NULL) {
464 				rs_strerror_r(errno, errStr, sizeof(errStr));
465 				iRet = RS_RET_NO_FILE_ACCESS;
466 				LogError(0, iRet,
467 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
468 						loadModConf-&gt;myPrivKeyFile, errStr);
469 			} else {
470 				fclose(fp);
471 				fp = NULL;
472 			}
473 		} else if(!strcmp(modpblk.descr[i].name, "allowunsignedcerts")) {
474 			loadModConf-&gt;allowUnsignedCerts = pvals[i].val.d.n;
475 		} else if(!strcmp(modpblk.descr[i].name, "skipverifyhost")) {
476 			loadModConf-&gt;skipVerifyHost = pvals[i].val.d.n;
477 		} else if(!strcmp(modpblk.descr[i].name, "token")) {
478 			free(loadModConf-&gt;token);
479 			loadModConf-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
480 		} else if(!strcmp(modpblk.descr[i].name, "tokenfile")) {
481 			free(loadModConf-&gt;tokenFile);
482 			loadModConf-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
483 			fp = fopen((const char*)loadModConf-&gt;tokenFile, "r");
484 			if(fp == NULL) {
485 				rs_strerror_r(errno, errStr, sizeof(errStr));
486 				iRet = RS_RET_NO_FILE_ACCESS;
487 				LogError(0, iRet,
488 						"error: token file %s couldn't be accessed: %s\n",
489 						loadModConf-&gt;tokenFile, errStr);
490 				ABORT_FINALIZE(iRet);
491 			} else {
492 				fclose(fp);
493 				fp = NULL;
494 			}
495 		} else if(!strcmp(modpblk.descr[i].name, "annotation_match")) {
496 			free_annotationmatch(&amp;loadModConf-&gt;annotation_match);
497 			if ((ret = init_annotationmatch(&amp;loadModConf-&gt;annotation_match, pvals[i].val.d.ar)))
498 				ABORT_FINALIZE(ret);
499 		} else if(!strcmp(modpblk.descr[i].name, "de_dot")) {
500 			loadModConf-&gt;de_dot = pvals[i].val.d.n;
501 		} else if(!strcmp(modpblk.descr[i].name, "de_dot_separator")) {
502 			free(loadModConf-&gt;de_dot_separator);
503 			loadModConf-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
504 #if HAVE_LOADSAMPLESFROMSTRING == 1
505 		} else if(!strcmp(modpblk.descr[i].name, "filenamerules")) {
506 			free(loadModConf-&gt;fnRules);
507 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;fnRules)));
508 #endif
509 		} else if(!strcmp(modpblk.descr[i].name, "filenamerulebase")) {
510 			free(loadModConf-&gt;fnRulebase);
511 			loadModConf-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
512 			fp = fopen((const char*)loadModConf-&gt;fnRulebase, "r");
513 			if(fp == NULL) {
514 				rs_strerror_r(errno, errStr, sizeof(errStr));
515 				iRet = RS_RET_NO_FILE_ACCESS;
516 				LogError(0, iRet,
517 						"error: filenamerulebase file %s couldn't be accessed: %s\n",
518 						loadModConf-&gt;fnRulebase, errStr);
519 				ABORT_FINALIZE(iRet);
520 			} else {
521 				fclose(fp);
522 				fp = NULL;
523 			}
524 #if HAVE_LOADSAMPLESFROMSTRING == 1
525 		} else if(!strcmp(modpblk.descr[i].name, "containerrules")) {
526 			free(loadModConf-&gt;contRules);
527 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;loadModConf-&gt;contRules)));
528 #endif
529 		} else if(!strcmp(modpblk.descr[i].name, "containerrulebase")) {
530 			free(loadModConf-&gt;contRulebase);
531 			loadModConf-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
532 			fp = fopen((const char*)loadModConf-&gt;contRulebase, "r");
533 			if(fp == NULL) {
534 				rs_strerror_r(errno, errStr, sizeof(errStr));
535 				iRet = RS_RET_NO_FILE_ACCESS;
536 				LogError(0, iRet,
537 						"error: containerrulebase file %s couldn't be accessed: %s\n",
538 						loadModConf-&gt;contRulebase, errStr);
539 				ABORT_FINALIZE(iRet);
540 			} else {
541 <a name="2"></a>				fclose(fp);
542 				fp = NULL;
543 			}
544 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "busyretryinterval")) {
545 			loadModConf-&gt;busyRetryInterval = pvals[i].val.d.n;
546 		} else if(!strcmp(modpblk.descr[i].name, "sslpartialchain")) {
547 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
548 			loadModConf-&gt;sslPartialChain = pvals[i].val.d.n;
549 #else
550 			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
551 					"sslpartialchain is only supported for OpenSSL\n");
552 #endif
553 		} else if(!strcmp(modpblk.descr[i].name, "cacheentryttl")) {
554 			loadModConf-&gt;cacheEntryTTL = pvals[i].val.d.n;
555 		} else if(!strcmp(modpblk.descr[i].name, "cacheexpireinterval")) {
556 			loadModConf-&gt;cacheExpireInterval = pvals[i].val.d.n;
557 		} else {</b></font>
558 			dbgprintf("mmkubernetes: program error, non-handled "
559 				"param '%s' in module() block\n", modpblk.descr[i].name);
560 		}
561 	}
562 #if HAVE_LOADSAMPLESFROMSTRING == 1
563 	if (loadModConf-&gt;fnRules &amp;&amp; loadModConf-&gt;fnRulebase) {
564 		LogError(0, RS_RET_CONFIG_ERROR,
565 				"mmkubernetes: only 1 of filenamerules or filenamerulebase may be used");
566 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
567 	}
568 	if (loadModConf-&gt;contRules &amp;&amp; loadModConf-&gt;contRulebase) {
569 		LogError(0, RS_RET_CONFIG_ERROR,
570 				"mmkubernetes: only 1 of containerrules or containerrulebase may be used");
571 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
572 	}
573 #endif
574 	if ((loadModConf-&gt;cacheExpireInterval &gt; -1)) {
575 		if ((loadModConf-&gt;cacheEntryTTL &lt; 0)) {
576 			LogError(0, RS_RET_CONFIG_ERROR,
577 					"mmkubernetes: cacheentryttl value [%d] is invalid - "
578 					"value must be 0 or greater",
579 					loadModConf-&gt;cacheEntryTTL);
580 			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
581 		}
582 	}
583 	if(loadModConf-&gt;srcMetadataPath == NULL)
584 		loadModConf-&gt;srcMetadataPath = (uchar *) strdup(DFLT_SRCMD_PATH);
585 	if(loadModConf-&gt;dstMetadataPath == NULL)
586 		loadModConf-&gt;dstMetadataPath = (uchar *) strdup(DFLT_DSTMD_PATH);
587 	if(loadModConf-&gt;de_dot_separator == NULL)
588 		loadModConf-&gt;de_dot_separator = (uchar *) strdup(DFLT_DE_DOT_SEPARATOR);
589 	if(loadModConf-&gt;de_dot_separator)
590 		loadModConf-&gt;de_dot_separator_len = strlen((const char *)loadModConf-&gt;de_dot_separator);
591 #if HAVE_LOADSAMPLESFROMSTRING == 1
592 	if (loadModConf-&gt;fnRules == NULL &amp;&amp; loadModConf-&gt;fnRulebase == NULL)
593 		loadModConf-&gt;fnRules = strdup(DFLT_FILENAME_LNRULES);
594 	if (loadModConf-&gt;contRules == NULL &amp;&amp; loadModConf-&gt;contRulebase == NULL)
595 		loadModConf-&gt;contRules = strdup(DFLT_CONTAINER_LNRULES);
596 #else
597 	if (loadModConf-&gt;fnRulebase == NULL)
598 		loadModConf-&gt;fnRulebase = (uchar *)strdup(DFLT_FILENAME_RULEBASE);
599 	if (loadModConf-&gt;contRulebase == NULL)
600 		loadModConf-&gt;contRulebase = (uchar *)strdup(DFLT_CONTAINER_RULEBASE);
601 #endif
602 	caches = calloc(1, sizeof(struct cache_s *));
603 finalize_it:
604 	if (fp)
605 		fclose(fp);
606 	if(pvals != NULL)
607 		cnfparamvalsDestruct(pvals, &amp;modpblk);
608 ENDsetModCnf
609 BEGINcreateInstance
610 CODESTARTcreateInstance
611 ENDcreateInstance
612 BEGINfreeInstance
613 CODESTARTfreeInstance
614 	free(pData-&gt;kubernetesUrl);
615 	msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
616 	free(pData-&gt;srcMetadataDescr);
617 	free(pData-&gt;dstMetadataPath);
618 	free(pData-&gt;caCertFile);
619 	free(pData-&gt;myCertFile);
620 	free(pData-&gt;myPrivKeyFile);
621 	free(pData-&gt;token);
622 	free(pData-&gt;tokenFile);
623 	free(pData-&gt;fnRules);
624 	free(pData-&gt;fnRulebase);
625 	ln_exitCtx(pData-&gt;fnCtxln);
626 	free(pData-&gt;contRules);
627 	free(pData-&gt;contRulebase);
628 	ln_exitCtx(pData-&gt;contCtxln);
629 	free_annotationmatch(&amp;pData-&gt;annotation_match);
630 	free(pData-&gt;de_dot_separator);
631 	msgPropDescrDestruct(pData-&gt;contNameDescr);
632 	free(pData-&gt;contNameDescr);
633 	msgPropDescrDestruct(pData-&gt;contIdFullDescr);
634 	free(pData-&gt;contIdFullDescr);
635 ENDfreeInstance
636 static size_t curlCB(char *data, size_t size, size_t nmemb, void *usrptr)
637 {
638 	DEFiRet;
639 	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t *) usrptr;
640 	char * buf;
641 	size_t newlen;
642 	newlen = pWrkrData-&gt;curlRplyLen + size * nmemb;
643 	CHKmalloc(buf = realloc(pWrkrData-&gt;curlRply, newlen));
644 	memcpy(buf + pWrkrData-&gt;curlRplyLen, data, size * nmemb);
645 	pWrkrData-&gt;curlRply = buf;
646 	pWrkrData-&gt;curlRplyLen = newlen;
647 finalize_it:
648 	if (iRet != RS_RET_OK) {
649 		return 0;
650 	}
651 	return size * nmemb;
652 }
653 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
654 static CURLcode set_ssl_partial_chain(CURL *curl, void *ssl_ctx, void *userptr)
655 {
656 	(void)userptr; 	CURLcode rv = CURLE_ABORTED_BY_CALLBACK;
657 	X509_STORE *store = NULL;
658 	store = SSL_CTX_get_cert_store((SSL_CTX *)ssl_ctx);
659 	if(!store)
660 		goto finalize_it;
661 	if(!X509_STORE_set_flags(store, X509_V_FLAG_PARTIAL_CHAIN))
662 		goto finalize_it;
663 	rv = CURLE_OK;
664 finalize_it:
665 	return rv;
666 }
667 #endif
668 BEGINcreateWrkrInstance
669 CODESTARTcreateWrkrInstance
670 	CURL *ctx;
671 	struct curl_slist *hdr = NULL;
672 	char *tokenHdr = NULL;
673 	FILE *fp = NULL;
674 	char *token = NULL;
675 	char *statsName = NULL;
676 	CHKiRet(statsobj.Construct(&amp;(pWrkrData-&gt;stats)));
677 	if ((-1 == asprintf(&amp;statsName, "mmkubernetes(%s)", pWrkrData-&gt;pData-&gt;kubernetesUrl)) ||
678 		(!statsName)) {
679 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
680 	}
681 	CHKiRet(statsobj.SetName(pWrkrData-&gt;stats, (uchar *)statsName));
682 	free(statsName);
683 	statsName = NULL;
684 	CHKiRet(statsobj.SetOrigin(pWrkrData-&gt;stats, UCHAR_CONSTANT("mmkubernetes")));
685 	STATSCOUNTER_INIT(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
686 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("recordseen"),
687 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;k8sRecordSeen)));
688 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataSuccess, pWrkrData-&gt;mutNamespaceMetadataSuccess);
689 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatasuccess"),
690 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataSuccess)));
691 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataNotFound, pWrkrData-&gt;mutNamespaceMetadataNotFound);
692 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatanotfound"),
693 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataNotFound)));
694 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataBusy, pWrkrData-&gt;mutNamespaceMetadataBusy);
695 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadatabusy"),
696 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataBusy)));
697 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceMetadataError, pWrkrData-&gt;mutNamespaceMetadataError);
698 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacemetadataerror"),
699 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceMetadataError)));
700 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
701 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatasuccess"),
702 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataSuccess)));
703 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
704 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatanotfound"),
705 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataNotFound)));
706 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
707 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadatabusy"),
708 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataBusy)));
709 	STATSCOUNTER_INIT(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
710 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podmetadataerror"),
711 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podMetadataError)));
712 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheNumEntries, pWrkrData-&gt;mutNamespaceCacheNumEntries);
713 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachenumentries"),
714 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheNumEntries)));
715 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheNumEntries, pWrkrData-&gt;mutPodCacheNumEntries);
716 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachenumentries"),
717 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheNumEntries)));
718 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheHits, pWrkrData-&gt;mutNamespaceCacheHits);
719 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachehits"),
720 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheHits)));
721 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheHits, pWrkrData-&gt;mutPodCacheHits);
722 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachehits"),
723 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheHits)));
724 	STATSCOUNTER_INIT(pWrkrData-&gt;namespaceCacheMisses, pWrkrData-&gt;mutNamespaceCacheMisses);
725 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("namespacecachemisses"),
726 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;namespaceCacheMisses)));
727 	STATSCOUNTER_INIT(pWrkrData-&gt;podCacheMisses, pWrkrData-&gt;mutPodCacheMisses);
728 	CHKiRet(statsobj.AddCounter(pWrkrData-&gt;stats, UCHAR_CONSTANT("podcachemisses"),
729 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pWrkrData-&gt;podCacheMisses)));
730 	CHKiRet(statsobj.ConstructFinalize(pWrkrData-&gt;stats));
731 	hdr = curl_slist_append(hdr, "Content-Type: text/json; charset=utf-8");
732 	if (pWrkrData-&gt;pData-&gt;token) {
733 		if ((-1 == asprintf(&amp;tokenHdr, "Authorization: Bearer %s", pWrkrData-&gt;pData-&gt;token)) ||
734 			(!tokenHdr)) {
735 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
736 		}
737 	} else if (pWrkrData-&gt;pData-&gt;tokenFile) {
738 		struct stat statbuf;
739 		fp = fopen((const char*)pWrkrData-&gt;pData-&gt;tokenFile, "r");
740 		if (fp &amp;&amp; !fstat(fileno(fp), &amp;statbuf)) {
741 			size_t bytesread;
742 			CHKmalloc(token = malloc((statbuf.st_size+1)*sizeof(char)));
743 			if (0 &lt; (bytesread = fread(token, sizeof(char), statbuf.st_size, fp))) {
744 				token[bytesread] = '\0';
745 				if ((-1 == asprintf(&amp;tokenHdr, "Authorization: Bearer %s", token)) ||
746 					(!tokenHdr)) {
747 					ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
748 				}
749 			}
750 			free(token);
751 			token = NULL;
752 		}
753 		if (fp) {
754 			fclose(fp);
755 			fp = NULL;
756 		}
757 	}
758 	if (tokenHdr) {
759 		hdr = curl_slist_append(hdr, tokenHdr);
760 		free(tokenHdr);
761 	}
762 	pWrkrData-&gt;curlHdr = hdr;
763 	ctx = curl_easy_init();
764 	curl_easy_setopt(ctx, CURLOPT_HTTPHEADER, hdr);
765 	curl_easy_setopt(ctx, CURLOPT_WRITEFUNCTION, curlCB);
766 	curl_easy_setopt(ctx, CURLOPT_WRITEDATA, pWrkrData);
767 	if(pWrkrData-&gt;pData-&gt;caCertFile)
768 		curl_easy_setopt(ctx, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
769 	if(pWrkrData-&gt;pData-&gt;myCertFile)
770 		curl_easy_setopt(ctx, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
771 	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
772 		curl_easy_setopt(ctx, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
773 	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
774 		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYPEER, 0);
775 	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
776 		curl_easy_setopt(ctx, CURLOPT_SSL_VERIFYHOST, 0);
777 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
778 	if(pWrkrData-&gt;pData-&gt;sslPartialChain) {
779 		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_FUNCTION, set_ssl_partial_chain);
780 		curl_easy_setopt(ctx, CURLOPT_SSL_CTX_DATA, NULL);
781 	}
782 #endif
783 	pWrkrData-&gt;curlCtx = ctx;
784 finalize_it:
785 	free(token);
786 	free(statsName);
787 	if ((iRet != RS_RET_OK) &amp;&amp; pWrkrData-&gt;stats) {
788 		statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
789 	}
790 	if (fp) {
791 		fclose(fp);
792 	}
793 ENDcreateWrkrInstance
794 BEGINfreeWrkrInstance
795 CODESTARTfreeWrkrInstance
796 	curl_easy_cleanup(pWrkrData-&gt;curlCtx);
797 	curl_slist_free_all(pWrkrData-&gt;curlHdr);
798 	statsobj.Destruct(&amp;(pWrkrData-&gt;stats));
799 ENDfreeWrkrInstance
800 static void
801 hashtable_json_object_put(void *jso)
802 {
803 	json_object_put((struct fjson_object *)jso);
804 }
805 static void
806 cache_entry_free(struct cache_entry_s *cache_entry)
807 {
808 	if (NULL != cache_entry) {
809 		if (cache_entry-&gt;data) {
810 			hashtable_json_object_put(cache_entry-&gt;data);
811 			cache_entry-&gt;data = NULL;
812 		}
813 		free(cache_entry);
814 	}
815 }
816 static void
817 cache_entry_free_raw(void *cache_entry_void)
818 {
819 	cache_entry_free((struct cache_entry_s *)cache_entry_void);
820 }
821 static struct cache_s *
822 cacheNew(instanceData *pData)
823 {
824 	DEFiRet;
825 	struct cache_s *cache = NULL;
826 	time_t now;
827 	int need_mutex_destroy = 0;
828 	CHKmalloc(cache = (struct cache_s *)calloc(1, sizeof(struct cache_s)));
829 	CHKmalloc(cache-&gt;cacheMtx = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)));
830 	CHKmalloc(cache-&gt;mdHt = create_hashtable(100, hash_from_string,
831 		key_equals_string, cache_entry_free_raw));
832 	CHKmalloc(cache-&gt;nsHt = create_hashtable(100, hash_from_string,
833 		key_equals_string, cache_entry_free_raw));
834 	CHKiConcCtrl(pthread_mutex_init(cache-&gt;cacheMtx, NULL));
835 	need_mutex_destroy = 1;
836 	datetime.GetTime(&amp;now);
837 	cache-&gt;kbUrl = pData-&gt;kubernetesUrl;
838 	cache-&gt;expirationTime = 0;
839 	if (pData-&gt;cacheExpireInterval &gt; -1)
840 		cache-&gt;expirationTime = pData-&gt;cacheExpireInterval + pData-&gt;cacheEntryTTL + now;
841 	cache-&gt;lastBusyTime = 0;
842 	dbgprintf("mmkubernetes: created cache mdht [%p] nsht [%p]\n",
843 			cache-&gt;mdHt, cache-&gt;nsHt);
844 finalize_it:
845 	if (iRet != RS_RET_OK) {
846 	        LogError(errno, iRet, "mmkubernetes: cacheNew: unable to create metadata cache for %s",
847 	                 pData-&gt;kubernetesUrl);
848 		if (cache) {
849 			if (cache-&gt;mdHt)
850 				hashtable_destroy(cache-&gt;mdHt, 1);
851 			if (cache-&gt;nsHt)
852 				hashtable_destroy(cache-&gt;nsHt, 1);
853 			if (cache-&gt;cacheMtx) {
854 				if (need_mutex_destroy)
855 					pthread_mutex_destroy(cache-&gt;cacheMtx);
856 				free(cache-&gt;cacheMtx);
857 			}
858 			free(cache);
859 			cache = NULL;
860 		}
861 	}
862 	return cache;
863 }
864 static void cacheFree(struct cache_s *cache)
865 {
866 	hashtable_destroy(cache-&gt;mdHt, 1);
867 	hashtable_destroy(cache-&gt;nsHt, 1);
868 	pthread_mutex_destroy(cache-&gt;cacheMtx);
869 	free(cache-&gt;cacheMtx);
870 	free(cache);
871 }
872 static struct cache_entry_s *cache_entry_new(time_t ttl, struct fjson_object *jso)
873 {
874 	DEFiRet;
875 	struct cache_entry_s *cache_entry = NULL;
876 	CHKmalloc(cache_entry = malloc(sizeof(struct cache_entry_s)));
877 	cache_entry-&gt;ttl = ttl;
878 	cache_entry-&gt;data = (void *)jso;
879 finalize_it:
880 	if (iRet) {
881 		free(cache_entry);
882 		cache_entry = NULL;
883 	}
884 	return cache_entry;
885 }
886 static int cache_delete_expired_entries(wrkrInstanceData_t *pWrkrData, int isnsmd, time_t now)
887 {
888 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
889 	struct hashtable_itr *itr = NULL;
890 	int more;
891 	if ((pWrkrData-&gt;pData-&gt;cacheExpireInterval &lt; 0) || (now &lt; pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime)) {
892 		return 0; 	}
893 	pWrkrData-&gt;pData-&gt;cache-&gt;expirationTime = now + pWrkrData-&gt;pData-&gt;cacheExpireInterval;
894 	if (hashtable_count(ht) &lt; 1)
895 		return 1; 
896 	itr = hashtable_iterator(ht);
897 	if (NULL == itr)
898 		return 1; 
899 	do {
900 		struct cache_entry_s *cache_entry = (struct cache_entry_s *)hashtable_iterator_value(itr);
901 		if (now &gt;= cache_entry-&gt;ttl) {
902 			cache_entry_free(cache_entry);
903 			if (isnsmd) {
904 				STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
905 						 pWrkrData-&gt;mutNamespaceCacheNumEntries);
906 			} else {
907 				STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
908 						 pWrkrData-&gt;mutPodCacheNumEntries);
909 			}
910 			more = hashtable_iterator_remove(itr);
911 		} else {
912 			more = hashtable_iterator_advance(itr);
913 		}
914 	} while (more);
915 	free(itr);
916 	dbgprintf("mmkubernetes: cache_delete_expired_entries: cleaned [%s] cache - size is now [%llu]\n",
917 		  isnsmd ? "namespace" : "pod",
918 		  isnsmd ? pWrkrData-&gt;namespaceCacheNumEntries : pWrkrData-&gt;podCacheNumEntries);
919 	return 1;
920 }
921 static struct fjson_object *
922 cache_entry_get(wrkrInstanceData_t *pWrkrData,
923 		int isnsmd, const char *key, time_t now)
924 {
925 	struct fjson_object *jso = NULL;
926 	struct cache_entry_s *cache_entry = NULL;
927 	int checkttl = 1;
928 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
929 	if (cache_delete_expired_entries(pWrkrData, isnsmd, now))
930 		checkttl = 0; 	cache_entry = (struct cache_entry_s *)hashtable_search(ht, (void *)key);
931 	if (cache_entry &amp;&amp; checkttl &amp;&amp; (now &gt;= cache_entry-&gt;ttl)) {
932 		cache_entry = (struct cache_entry_s *)hashtable_remove(ht, (void *)key);
933 		if (isnsmd) {
934 			STATSCOUNTER_DEC(pWrkrData-&gt;namespaceCacheNumEntries,
935 					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
936 		} else {
937 			STATSCOUNTER_DEC(pWrkrData-&gt;podCacheNumEntries,
938 					 pWrkrData-&gt;mutPodCacheNumEntries);
939 		}
940 		cache_entry_free(cache_entry);
941 		cache_entry = NULL;
942 	}
943 	if (cache_entry) {
944 		jso = (struct fjson_object *)cache_entry-&gt;data;
945 		if (isnsmd) {
946 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheHits,
947 					 pWrkrData-&gt;mutNamespaceCacheHits);
948 		} else {
949 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheHits,
950 					 pWrkrData-&gt;mutPodCacheHits);
951 		}
952 		dbgprintf("mmkubernetes: cache_entry_get: cache hit for [%s] cache key [%s] - hits is now [%llu]\n",
953 			  isnsmd ? "namespace" : "pod", key,
954 			  isnsmd ? pWrkrData-&gt;namespaceCacheHits : pWrkrData-&gt;podCacheHits);
955 	} else {
956 		if (isnsmd) {
957 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheMisses,
958 					 pWrkrData-&gt;mutNamespaceCacheMisses);
959 		} else {
960 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheMisses,
961 					 pWrkrData-&gt;mutPodCacheMisses);
962 		}
963 		dbgprintf("mmkubernetes: cache_entry_get: cache miss for [%s] cache key [%s] - misses is now [%llu]\n",
964 			  isnsmd ? "namespace" : "pod", key,
965 			  isnsmd ? pWrkrData-&gt;namespaceCacheMisses : pWrkrData-&gt;podCacheMisses);
966 	}
967 	return jso;
968 }
969 static rsRetVal
970 cache_entry_add(wrkrInstanceData_t *pWrkrData,
971 		int isnsmd, const char *key, struct fjson_object *jso, time_t now, const int bDupKey)
972 {
973 	DEFiRet;
974 	struct cache_entry_s *cache_entry = NULL;
975 	struct hashtable *ht = isnsmd ? pWrkrData-&gt;pData-&gt;cache-&gt;nsHt : pWrkrData-&gt;pData-&gt;cache-&gt;mdHt;
976 	(void)cache_delete_expired_entries(pWrkrData, isnsmd, now);
977 	CHKmalloc(cache_entry = cache_entry_new(now + pWrkrData-&gt;pData-&gt;cacheEntryTTL, jso));
978 	if (cache_entry) {
979 		if (!hashtable_insert(ht, (void *)(bDupKey ? strdup(key) : key), cache_entry))
980 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
981 		if (isnsmd) {
982 			STATSCOUNTER_INC(pWrkrData-&gt;namespaceCacheNumEntries,
983 					 pWrkrData-&gt;mutNamespaceCacheNumEntries);
984 		} else {
985 			STATSCOUNTER_INC(pWrkrData-&gt;podCacheNumEntries,
986 					 pWrkrData-&gt;mutPodCacheNumEntries);
987 		}
988 		cache_entry = NULL;
989 	}
990 finalize_it:
991 	if (cache_entry)
992 		cache_entry_free(cache_entry);
993 	return iRet;
994 }
995 static struct fjson_object *cache_entry_get_md(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
996 {
997 	return cache_entry_get(pWrkrData, 0, key, now);
998 }
999 static struct fjson_object *cache_entry_get_nsmd(wrkrInstanceData_t *pWrkrData, const char *key, time_t now)
1000 {
1001 	return cache_entry_get(pWrkrData, 1, key, now);
1002 }
1003 static rsRetVal cache_entry_add_md(wrkrInstanceData_t *pWrkrData, const char *key,
1004 				   struct fjson_object *jso, time_t now)
1005 {
1006 	return cache_entry_add(pWrkrData, 0, key, jso, now, 0);
1007 }
1008 static rsRetVal cache_entry_add_nsmd(wrkrInstanceData_t *pWrkrData, const char *key,
1009 				     struct fjson_object *jso, time_t now)
1010 {
1011 	return cache_entry_add(pWrkrData, 1, key, jso, now, 1);
1012 }
1013 BEGINnewActInst
1014 	struct cnfparamvals *pvals = NULL;
1015 	int i;
1016 	FILE *fp = NULL;
1017 	char *rxstr = NULL;
1018 	char *srcMetadataPath = NULL;
1019 	char errStr[1024];
1020 CODESTARTnewActInst
1021 	DBGPRINTF("newActInst (mmkubernetes)\n");
1022 	pvals = nvlstGetParams(lst, &amp;actpblk, NULL);
1023 	if(pvals == NULL) {
1024 		LogError(0, RS_RET_MISSING_CNFPARAMS, "mmkubernetes: "
1025 			"error processing config parameters [action(...)]");
1026 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1027 	}
1028 	if(Debug) {
1029 		dbgprintf("action param blk in mmkubernetes:\n");
1030 		cnfparamsPrint(&amp;actpblk, pvals);
1031 	}
1032 	CODE_STD_STRING_REQUESTnewActInst(1)
1033 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, NULL, OMSR_TPL_AS_MSG));
1034 	CHKiRet(createInstance(&amp;pData));
1035 	pData-&gt;de_dot = loadModConf-&gt;de_dot;
1036 	pData-&gt;allowUnsignedCerts = loadModConf-&gt;allowUnsignedCerts;
1037 	pData-&gt;skipVerifyHost = loadModConf-&gt;skipVerifyHost;
1038 	pData-&gt;busyRetryInterval = loadModConf-&gt;busyRetryInterval;
1039 	pData-&gt;sslPartialChain = loadModConf-&gt;sslPartialChain;
1040 	pData-&gt;cacheEntryTTL = loadModConf-&gt;cacheEntryTTL;
1041 	pData-&gt;cacheExpireInterval = loadModConf-&gt;cacheExpireInterval;
1042 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
1043 		if(!pvals[i].bUsed) {
1044 			continue;
1045 		} else if(!strcmp(actpblk.descr[i].name, "kubernetesurl")) {
1046 			free(pData-&gt;kubernetesUrl);
1047 			pData-&gt;kubernetesUrl = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1048 		} else if(!strcmp(actpblk.descr[i].name, "srcmetadatapath")) {
1049 			msgPropDescrDestruct(pData-&gt;srcMetadataDescr);
1050 			free(pData-&gt;srcMetadataDescr);
1051 			CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
1052 			srcMetadataPath = es_str2cstr(pvals[i].val.d.estr, NULL);
1053 			CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, (uchar *)srcMetadataPath,
1054 				strlen(srcMetadataPath)));
1055 		} else if(!strcmp(actpblk.descr[i].name, "dstmetadatapath")) {
1056 			free(pData-&gt;dstMetadataPath);
1057 			pData-&gt;dstMetadataPath = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1058 		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
1059 			free(pData-&gt;caCertFile);
1060 			pData-&gt;caCertFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1061 			fp = fopen((const char*)pData-&gt;caCertFile, "r");
1062 			if(fp == NULL) {
1063 				rs_strerror_r(errno, errStr, sizeof(errStr));
1064 				iRet = RS_RET_NO_FILE_ACCESS;
1065 				LogError(0, iRet,
1066 						"error: certificate file %s couldn't be accessed: %s\n",
1067 						pData-&gt;caCertFile, errStr);
1068 				ABORT_FINALIZE(iRet);
1069 			} else {
1070 				fclose(fp);
1071 				fp = NULL;
1072 			}
1073 		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
1074 			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1075 			fp = fopen((const char*)pData-&gt;myCertFile, "r");
1076 			if(fp == NULL) {
1077 				rs_strerror_r(errno, errStr, sizeof(errStr));
1078 				iRet = RS_RET_NO_FILE_ACCESS;
1079 				LogError(0, iRet,
1080 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
1081 						pData-&gt;myCertFile, errStr);
1082 			} else {
1083 				fclose(fp);
1084 				fp = NULL;
1085 			}
1086 		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
1087 			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1088 			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
1089 			if(fp == NULL) {
1090 				rs_strerror_r(errno, errStr, sizeof(errStr));
1091 				iRet = RS_RET_NO_FILE_ACCESS;
1092 				LogError(0, iRet,
1093 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
1094 						pData-&gt;myPrivKeyFile, errStr);
1095 			} else {
1096 				fclose(fp);
1097 				fp = NULL;
1098 			}
1099 		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
1100 			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
1101 		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
1102 			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
1103 		} else if(!strcmp(actpblk.descr[i].name, "token")) {
1104 			free(pData-&gt;token);
1105 			pData-&gt;token = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1106 		} else if(!strcmp(actpblk.descr[i].name, "tokenfile")) {
1107 			free(pData-&gt;tokenFile);
1108 			pData-&gt;tokenFile = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1109 			fp = fopen((const char*)pData-&gt;tokenFile, "r");
1110 			if(fp == NULL) {
1111 				rs_strerror_r(errno, errStr, sizeof(errStr));
1112 				iRet = RS_RET_NO_FILE_ACCESS;
1113 				LogError(0, iRet,
1114 						"error: token file %s couldn't be accessed: %s\n",
1115 						pData-&gt;tokenFile, errStr);
1116 				ABORT_FINALIZE(iRet);
1117 			} else {
1118 				fclose(fp);
1119 				fp = NULL;
1120 			}
1121 		} else if(!strcmp(actpblk.descr[i].name, "annotation_match")) {
1122 			free_annotationmatch(&amp;pData-&gt;annotation_match);
1123 			if (RS_RET_OK != (iRet = init_annotationmatch(&amp;pData-&gt;annotation_match, pvals[i].val.d.ar)))
1124 				ABORT_FINALIZE(iRet);
1125 		} else if(!strcmp(actpblk.descr[i].name, "de_dot")) {
1126 			pData-&gt;de_dot = pvals[i].val.d.n;
1127 		} else if(!strcmp(actpblk.descr[i].name, "de_dot_separator")) {
1128 			free(pData-&gt;de_dot_separator);
1129 			pData-&gt;de_dot_separator = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1130 #if HAVE_LOADSAMPLESFROMSTRING == 1
1131 		} else if(!strcmp(modpblk.descr[i].name, "filenamerules")) {
1132 			free(pData-&gt;fnRules);
1133 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;fnRules)));
1134 #endif
1135 		} else if(!strcmp(modpblk.descr[i].name, "filenamerulebase")) {
1136 			free(pData-&gt;fnRulebase);
1137 			pData-&gt;fnRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1138 			fp = fopen((const char*)pData-&gt;fnRulebase, "r");
1139 			if(fp == NULL) {
1140 				rs_strerror_r(errno, errStr, sizeof(errStr));
1141 				iRet = RS_RET_NO_FILE_ACCESS;
1142 				LogError(0, iRet,
1143 						"error: filenamerulebase file %s couldn't be accessed: %s\n",
1144 						pData-&gt;fnRulebase, errStr);
1145 				ABORT_FINALIZE(iRet);
1146 			} else {
1147 				fclose(fp);
1148 				fp = NULL;
1149 			}
1150 #if HAVE_LOADSAMPLESFROMSTRING == 1
1151 		} else if(!strcmp(modpblk.descr[i].name, "containerrules")) {
1152 			free(pData-&gt;contRules);
1153 			CHKiRet((array_to_rules(pvals[i].val.d.ar, &amp;pData-&gt;contRules)));
1154 #endif
1155 		} else if(!strcmp(modpblk.descr[i].name, "containerrulebase")) {
1156 			free(pData-&gt;contRulebase);
1157 			pData-&gt;contRulebase = (uchar *) es_str2cstr(pvals[i].val.d.estr, NULL);
1158 			fp = fopen((const char*)pData-&gt;contRulebase, "r");
1159 			if(fp == NULL) {
1160 				rs_strerror_r(errno, errStr, sizeof(errStr));
1161 				iRet = RS_RET_NO_FILE_ACCESS;
1162 				LogError(0, iRet,
1163 						"error: containerrulebase file %s couldn't be accessed: %s\n",
1164 						pData-&gt;contRulebase, errStr);
1165 				ABORT_FINALIZE(iRet);
1166 			} else {
1167 				fclose(fp);
1168 				fp = NULL;
1169 			}
1170 		} else if(!strcmp(actpblk.descr[i].name, "busyretryinterval")) {
1171 			pData-&gt;busyRetryInterval = pvals[i].val.d.n;
1172 		} else if(!strcmp(actpblk.descr[i].name, "sslpartialchain")) {
1173 #if defined(SUPPORT_SSL_PARTIAL_CHAIN)
1174 			pData-&gt;sslPartialChain = pvals[i].val.d.n;
1175 #else
1176 			LogMsg(0, RS_RET_VALUE_NOT_IN_THIS_MODE, LOG_INFO,
1177 					"sslpartialchain is only supported for OpenSSL\n");
1178 #endif
1179 		} else if(!strcmp(actpblk.descr[i].name, "cacheentryttl")) {
1180 			pData-&gt;cacheEntryTTL = pvals[i].val.d.n;
1181 		} else if(!strcmp(actpblk.descr[i].name, "cacheexpireinterval")) {
1182 			pData-&gt;cacheExpireInterval = pvals[i].val.d.n;
1183 		} else {
1184 			dbgprintf("mmkubernetes: program error, non-handled "
1185 				"param '%s' in action() block\n", actpblk.descr[i].name);
1186 		}
1187 	}
1188 #if HAVE_LOADSAMPLESFROMSTRING == 1
1189 	if (pData-&gt;fnRules &amp;&amp; pData-&gt;fnRulebase) {
1190 		LogError(0, RS_RET_CONFIG_ERROR,
1191 		    "mmkubernetes: only 1 of filenamerules or filenamerulebase may be used");
1192 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1193 	}
1194 	if (pData-&gt;contRules &amp;&amp; pData-&gt;contRulebase) {
1195 		LogError(0, RS_RET_CONFIG_ERROR,
1196 			"mmkubernetes: only 1 of containerrules or containerrulebase may be used");
1197 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1198 	}
1199 #endif
1200 	CHKiRet(set_lnctx(&amp;pData-&gt;fnCtxln, pData-&gt;fnRules, pData-&gt;fnRulebase,
1201 			loadModConf-&gt;fnRules, loadModConf-&gt;fnRulebase));
1202 	CHKiRet(set_lnctx(&amp;pData-&gt;contCtxln, pData-&gt;contRules, pData-&gt;contRulebase,
1203 			loadModConf-&gt;contRules, loadModConf-&gt;contRulebase));
1204 	if ((pData-&gt;cacheExpireInterval &gt; -1)) {
1205 		if ((pData-&gt;cacheEntryTTL &lt; 0)) {
1206 			LogError(0, RS_RET_CONFIG_ERROR,
1207 					"mmkubernetes: cacheentryttl value [%d] is invalid - "
1208 					"value must be 0 or greater",
1209 					pData-&gt;cacheEntryTTL);
1210 			ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1211 		}
1212 	}
1213 	if(pData-&gt;kubernetesUrl == NULL) {
1214 		if(loadModConf-&gt;kubernetesUrl == NULL) {
1215 			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup(DFLT_KUBERNETES_URL));
1216 		} else {
1217 			CHKmalloc(pData-&gt;kubernetesUrl = (uchar *) strdup((char *) loadModConf-&gt;kubernetesUrl));
1218 		}
1219 	}
1220 	if(pData-&gt;srcMetadataDescr == NULL) {
1221 		CHKmalloc(pData-&gt;srcMetadataDescr = malloc(sizeof(msgPropDescr_t)));
1222 		CHKiRet(msgPropDescrFill(pData-&gt;srcMetadataDescr, loadModConf-&gt;srcMetadataPath,
1223 			strlen((char *)loadModConf-&gt;srcMetadataPath)));
1224 	}
1225 	if(pData-&gt;dstMetadataPath == NULL)
1226 		pData-&gt;dstMetadataPath = (uchar *) strdup((char *) loadModConf-&gt;dstMetadataPath);
1227 	if(pData-&gt;caCertFile == NULL &amp;&amp; loadModConf-&gt;caCertFile)
1228 		pData-&gt;caCertFile = (uchar *) strdup((char *) loadModConf-&gt;caCertFile);
1229 	if(pData-&gt;myCertFile == NULL &amp;&amp; loadModConf-&gt;myCertFile)
1230 		pData-&gt;myCertFile = (uchar *) strdup((char *) loadModConf-&gt;myCertFile);
1231 	if(pData-&gt;myPrivKeyFile == NULL &amp;&amp; loadModConf-&gt;myPrivKeyFile)
1232 		pData-&gt;myPrivKeyFile = (uchar *) strdup((char *) loadModConf-&gt;myPrivKeyFile);
1233 	if(pData-&gt;token == NULL &amp;&amp; loadModConf-&gt;token)
1234 		pData-&gt;token = (uchar *) strdup((char *) loadModConf-&gt;token);
1235 	if(pData-&gt;tokenFile == NULL &amp;&amp; loadModConf-&gt;tokenFile)
1236 		pData-&gt;tokenFile = (uchar *) strdup((char *) loadModConf-&gt;tokenFile);
1237 	if(pData-&gt;de_dot_separator == NULL &amp;&amp; loadModConf-&gt;de_dot_separator)
1238 		pData-&gt;de_dot_separator = (uchar *) strdup((char *) loadModConf-&gt;de_dot_separator);
1239 	if((pData-&gt;annotation_match.nmemb == 0) &amp;&amp; (loadModConf-&gt;annotation_match.nmemb &gt; 0))
1240 		copy_annotationmatch(&amp;loadModConf-&gt;annotation_match, &amp;pData-&gt;annotation_match);
1241 	if(pData-&gt;de_dot_separator)
1242 		pData-&gt;de_dot_separator_len = strlen((const char *)pData-&gt;de_dot_separator);
1243 	CHKmalloc(pData-&gt;contNameDescr = malloc(sizeof(msgPropDescr_t)));
1244 	CHKiRet(msgPropDescrFill(pData-&gt;contNameDescr, (uchar*) DFLT_CONTAINER_NAME,
1245 			strlen(DFLT_CONTAINER_NAME)));
1246 	CHKmalloc(pData-&gt;contIdFullDescr = malloc(sizeof(msgPropDescr_t)));
1247 	CHKiRet(msgPropDescrFill(pData-&gt;contIdFullDescr, (uchar*) DFLT_CONTAINER_ID_FULL,
1248 			strlen(DFLT_CONTAINER_NAME)));
1249 	for(i = 0; caches[i] != NULL; i++) {
1250 		if(!strcmp((char *) pData-&gt;kubernetesUrl, (char *) caches[i]-&gt;kbUrl))
1251 			break;
1252 	}
1253 	if(caches[i] != NULL) {
1254 		pData-&gt;cache = caches[i];
1255 	} else {
1256 		CHKmalloc(pData-&gt;cache = cacheNew(pData));
1257 		struct cache_s **new_caches = realloc(caches, (i + 2) * sizeof(struct cache_s *));
1258 		CHKmalloc(new_caches);
1259 		caches = new_caches;
1260 		caches[i] = pData-&gt;cache;
1261 		caches[i + 1] = NULL;
1262 	}
1263 CODE_STD_FINALIZERnewActInst
1264 	if(pvals != NULL)
1265 		cnfparamvalsDestruct(pvals, &amp;actpblk);
1266 	if(fp)
1267 		fclose(fp);
1268 	free(rxstr);
1269 	free(srcMetadataPath);
1270 ENDnewActInst
1271 BEGINparseSelectorAct
1272 CODESTARTparseSelectorAct
1273 CODE_STD_STRING_REQUESTparseSelectorAct(1)
1274 	if(strncmp((char *) p, ":mmkubernetes:", sizeof(":mmkubernetes:") - 1)) {
1275 		LogError(0, RS_RET_LEGA_ACT_NOT_SUPPORTED,
1276 			"mmkubernetes supports only v6+ config format, use: "
1277 			"action(type=\"mmkubernetes\" ...)");
1278 	}
1279 	ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
1280 CODE_STD_FINALIZERparseSelectorAct
1281 ENDparseSelectorAct
1282 BEGINendCnfLoad
1283 CODESTARTendCnfLoad
1284 ENDendCnfLoad
1285 BEGINcheckCnf
1286 CODESTARTcheckCnf
1287 ENDcheckCnf
1288 BEGINactivateCnf
1289 CODESTARTactivateCnf
1290 	runModConf = pModConf;
1291 ENDactivateCnf
1292 BEGINfreeCnf
1293 CODESTARTfreeCnf
1294 	int i;
1295 	free(pModConf-&gt;kubernetesUrl);
1296 	free(pModConf-&gt;srcMetadataPath);
1297 	free(pModConf-&gt;dstMetadataPath);
1298 	free(pModConf-&gt;caCertFile);
1299 	free(pModConf-&gt;myCertFile);
1300 	free(pModConf-&gt;myPrivKeyFile);
1301 	free(pModConf-&gt;token);
1302 	free(pModConf-&gt;tokenFile);
1303 	free(pModConf-&gt;de_dot_separator);
1304 	free(pModConf-&gt;fnRules);
1305 	free(pModConf-&gt;fnRulebase);
1306 	free(pModConf-&gt;contRules);
1307 	free(pModConf-&gt;contRulebase);
1308 	free_annotationmatch(&amp;pModConf-&gt;annotation_match);
1309 	for(i = 0; caches[i] != NULL; i++) {
1310 		dbgprintf("mmkubernetes: freeing cache [%d] mdht [%p] nsht [%p]\n",
1311 				i, caches[i]-&gt;mdHt, caches[i]-&gt;nsHt);
1312 		cacheFree(caches[i]);
1313 	}
1314 	free(caches);
1315 ENDfreeCnf
1316 BEGINdbgPrintInstInfo
1317 CODESTARTdbgPrintInstInfo
1318 	dbgprintf("mmkubernetes\n");
1319 	dbgprintf("\tkubernetesUrl='%s'\n", pData-&gt;kubernetesUrl);
1320 	dbgprintf("\tsrcMetadataPath='%s'\n", pData-&gt;srcMetadataDescr-&gt;name);
1321 	dbgprintf("\tdstMetadataPath='%s'\n", pData-&gt;dstMetadataPath);
1322 	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
1323 	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
1324 	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
1325 	dbgprintf("\tallowUnsignedCerts='%d'\n", pData-&gt;allowUnsignedCerts);
1326 	dbgprintf("\tskipVerifyHost='%d'\n", pData-&gt;skipVerifyHost);
1327 	dbgprintf("\ttoken='%s'\n", pData-&gt;token);
1328 	dbgprintf("\ttokenFile='%s'\n", pData-&gt;tokenFile);
1329 	dbgprintf("\tde_dot='%d'\n", pData-&gt;de_dot);
1330 	dbgprintf("\tde_dot_separator='%s'\n", pData-&gt;de_dot_separator);
1331 	dbgprintf("\tfilenamerulebase='%s'\n", pData-&gt;fnRulebase);
1332 	dbgprintf("\tcontainerrulebase='%s'\n", pData-&gt;contRulebase);
1333 #if HAVE_LOADSAMPLESFROMSTRING == 1
1334 	dbgprintf("\tfilenamerules='%s'\n", pData-&gt;fnRules);
1335 	dbgprintf("\tcontainerrules='%s'\n", pData-&gt;contRules);
1336 #endif
1337 	dbgprintf("\tbusyretryinterval='%d'\n", pData-&gt;busyRetryInterval);
1338 	dbgprintf("\tcacheentryttl='%d'\n", pData-&gt;cacheEntryTTL);
1339 	dbgprintf("\tcacheexpireinterval='%d'\n", pData-&gt;cacheExpireInterval);
1340 ENDdbgPrintInstInfo
1341 BEGINtryResume
1342 CODESTARTtryResume
1343 ENDtryResume
1344 static rsRetVal
1345 extractMsgMetadata(smsg_t *pMsg, instanceData *pData, struct json_object **json)
1346 {
1347 	DEFiRet;
1348 	uchar *filename = NULL, *container_name = NULL, *container_id_full = NULL;
1349 	rs_size_t fnLen, container_name_len, container_id_full_len;
1350 	unsigned short freeFn = 0, free_container_name = 0, free_container_id_full = 0;
1351 	int lnret;
1352 	struct json_object *cnid = NULL;
1353 	if (!json)
1354 		FINALIZE;
1355 	*json = NULL;
1356 	container_name = MsgGetProp(pMsg, NULL, pData-&gt;contNameDescr,
1357 				    &amp;container_name_len, &amp;free_container_name, NULL);
1358 	container_id_full = MsgGetProp(
1359 		pMsg, NULL, pData-&gt;contIdFullDescr, &amp;container_id_full_len, &amp;free_container_id_full, NULL);
1360 	if (container_name &amp;&amp; container_id_full &amp;&amp; container_name_len &amp;&amp; container_id_full_len) {
1361 		dbgprintf("mmkubernetes: CONTAINER_NAME: '%s'  CONTAINER_ID_FULL: '%s'.\n",
1362 			  container_name, container_id_full);
1363 		if ((lnret = ln_normalize(pData-&gt;contCtxln, (char*)container_name,
1364 					  container_name_len, json))) {
1365 			if (LN_WRONGPARSER != lnret) {
1366 				LogMsg(0, RS_RET_ERR, LOG_ERR,
1367 					"mmkubernetes: error parsing container_name [%s]: [%d]",
1368 					container_name, lnret);
1369 				ABORT_FINALIZE(RS_RET_ERR);
1370 			}
1371 		} else if (fjson_object_object_get_ex(*json, "pod_name", NULL) &amp;&amp;
1372 			fjson_object_object_get_ex(*json, "namespace_name", NULL) &amp;&amp;
1373 			fjson_object_object_get_ex(*json, "container_name", NULL)) {
1374 			json_object_object_add(*json, "container_id",
1375 				json_object_new_string_len((const char *)container_id_full,
1376 							   container_id_full_len));
1377 			ABORT_FINALIZE(RS_RET_OK);
1378 		}
1379 	}
1380 	filename = MsgGetProp(pMsg, NULL, pData-&gt;srcMetadataDescr, &amp;fnLen, &amp;freeFn, NULL);
1381 	if((filename == NULL) || (fnLen == 0))
1382 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
1383 	dbgprintf("mmkubernetes: filename: '%s' len %d.\n", filename, fnLen);
1384 	if ((lnret = ln_normalize(pData-&gt;fnCtxln, (char*)filename, fnLen, json))) {
1385 		if (LN_WRONGPARSER != lnret) {
1386 			LogMsg(0, RS_RET_ERR, LOG_ERR,
1387 				"mmkubernetes: error parsing container_name [%s]: [%d]",
1388 				filename, lnret);
1389 			ABORT_FINALIZE(RS_RET_ERR);
1390 		} else {
1391 			ABORT_FINALIZE(RS_RET_NOT_FOUND);
1392 		}
1393 	}
1394 	if (fjson_object_object_get_ex(*json, "pod_name", NULL) &amp;&amp;
1395 		fjson_object_object_get_ex(*json, "namespace_name", NULL) &amp;&amp;
1396 		fjson_object_object_get_ex(*json, "container_name_and_id", &amp;cnid)) {
1397 		const char *container_name_and_id = json_object_get_string(cnid);
1398 		const char *last_dash = NULL;
1399 		if (container_name_and_id &amp;&amp; (last_dash = strrchr(container_name_and_id, '-')) &amp;&amp;
1400 			*(last_dash + 1) &amp;&amp; (last_dash != container_name_and_id)) {
1401 			json_object_object_add(*json, "container_name",
1402 				json_object_new_string_len(container_name_and_id,
1403 							   (int)(last_dash-container_name_and_id)));
1404 			json_object_object_add(*json, "container_id",
1405 					json_object_new_string(last_dash + 1));
1406 			ABORT_FINALIZE(RS_RET_OK);
1407 		}
1408 	}
1409 	ABORT_FINALIZE(RS_RET_NOT_FOUND);
1410 finalize_it:
1411 	if(freeFn)
1412 		free(filename);
1413 	if (free_container_name)
1414 		free(container_name);
1415 	if (free_container_id_full)
1416 		free(container_id_full);
1417 	if (iRet != RS_RET_OK) {
1418 		json_object_put(*json);
1419 		*json = NULL;
1420 	}
1421 	RETiRet;
1422 }
1423 static rsRetVal
1424 queryKB(wrkrInstanceData_t *pWrkrData, char *url, time_t now, struct json_object **rply)
1425 {
1426 	DEFiRet;
1427 	CURLcode ccode;
1428 	struct json_tokener *jt = NULL;
1429 	struct json_object *jo;
1430 	long resp_code = 400;
1431 	if (pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime) {
1432 		now -= pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime;
1433 		if (now &lt; pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1434 			LogMsg(0, RS_RET_RETRY, LOG_DEBUG,
1435 				"mmkubernetes: Waited [%ld] of [%d] seconds for the requested url [%s]\n",
1436 				now, pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
1437 			ABORT_FINALIZE(RS_RET_RETRY);
1438 		} else {
1439 			LogMsg(0, RS_RET_OK, LOG_DEBUG,
1440 				"mmkubernetes: Cleared busy status after [%d] seconds - "
1441 				"will retry the requested url [%s]\n",
1442 				pWrkrData-&gt;pData-&gt;busyRetryInterval, url);
1443 			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = 0;
1444 		}
1445 	}
1446 	ccode = curl_easy_setopt(pWrkrData-&gt;curlCtx, CURLOPT_URL, url);
1447 	if(ccode != CURLE_OK)
1448 		ABORT_FINALIZE(RS_RET_ERR);
1449 	if(CURLE_OK != (ccode = curl_easy_perform(pWrkrData-&gt;curlCtx))) {
1450 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1451 			      "mmkubernetes: failed to connect to [%s] - %d:%s\n",
1452 			      url, ccode, curl_easy_strerror(ccode));
1453 		ABORT_FINALIZE(RS_RET_SUSPENDED);
1454 	}
1455 	if(CURLE_OK != (ccode = curl_easy_getinfo(pWrkrData-&gt;curlCtx,
1456 					CURLINFO_RESPONSE_CODE, &amp;resp_code))) {
1457 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1458 			      "mmkubernetes: could not get response code from query to [%s] - %d:%s\n",
1459 			      url, ccode, curl_easy_strerror(ccode));
1460 		ABORT_FINALIZE(RS_RET_ERR);
1461 	}
1462 	if(resp_code == 401) {
1463 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1464 			      "mmkubernetes: Unauthorized: not allowed to view url - "
1465 			      "check token/auth credentials [%s]\n",
1466 			      url);
1467 		ABORT_FINALIZE(RS_RET_ERR);
1468 	}
1469 	if(resp_code == 403) {
1470 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1471 			      "mmkubernetes: Forbidden: no access - "
1472 			      "check permissions to view url [%s]\n",
1473 			      url);
1474 		ABORT_FINALIZE(RS_RET_ERR);
1475 	}
1476 	if(resp_code == 404) {
1477 		LogMsg(0, RS_RET_NOT_FOUND, LOG_INFO,
1478 			      "mmkubernetes: Not Found: the resource does not exist at url [%s]\n",
1479 			      url);
1480 		ABORT_FINALIZE(RS_RET_NOT_FOUND);
1481 	}
1482 	if(resp_code == 429) {
1483 		if (pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1484 			pWrkrData-&gt;pData-&gt;cache-&gt;lastBusyTime = now;
1485 		}
1486 		LogMsg(0, RS_RET_RETRY, LOG_INFO,
1487 			      "mmkubernetes: Too Many Requests: the server is too heavily loaded "
1488 			      "to provide the data for the requested url [%s]\n",
1489 			      url);
1490 		ABORT_FINALIZE(RS_RET_RETRY);
1491 	}
1492 	if(resp_code != 200) {
1493 		LogMsg(0, RS_RET_ERR, LOG_ERR,
1494 			      "mmkubernetes: server returned unexpected code [%ld] for url [%s]\n",
1495 			      resp_code, url);
1496 		ABORT_FINALIZE(RS_RET_ERR);
1497 	}
1498 	jt = json_tokener_new();
1499 	json_tokener_reset(jt);
1500 	jo = json_tokener_parse_ex(jt, pWrkrData-&gt;curlRply, pWrkrData-&gt;curlRplyLen);
1501 	json_tokener_free(jt);
1502 	if(!json_object_is_type(jo, json_type_object)) {
1503 		json_object_put(jo);
1504 		jo = NULL;
1505 		LogMsg(0, RS_RET_JSON_PARSE_ERR, LOG_INFO,
1506 			      "mmkubernetes: unable to parse string as JSON:[%.*s]\n",
1507 			      (int)pWrkrData-&gt;curlRplyLen, pWrkrData-&gt;curlRply);
1508 		ABORT_FINALIZE(RS_RET_JSON_PARSE_ERR);
1509 	}
1510 	dbgprintf("mmkubernetes: queryKB reply:\n%s\n",
1511 		json_object_to_json_string_ext(jo, JSON_C_TO_STRING_PRETTY));
1512 	*rply = jo;
1513 finalize_it:
1514 	if(pWrkrData-&gt;curlRply != NULL) {
1515 		free(pWrkrData-&gt;curlRply);
1516 		pWrkrData-&gt;curlRply = NULL;
1517 		pWrkrData-&gt;curlRplyLen = 0;
1518 	}
1519 	RETiRet;
1520 }
1521 #if defined(BEGINdoAction_NoStrings)
1522 BEGINdoAction_NoStrings
1523 	smsg_t **ppMsg = (smsg_t **) pMsgData;
1524 	smsg_t *pMsg = ppMsg[0];
1525 #else
1526 BEGINdoAction
1527 	smsg_t *pMsg = (smsg_t*) ppString[0];
1528 #endif
1529 	const char *podName = NULL, *ns = NULL, *containerName = NULL,
1530 		*containerID = NULL;
1531 	char *mdKey = NULL;
1532 	struct json_object *jMetadata = NULL, *jMetadataCopy = NULL, *jMsgMeta = NULL,
1533 			*jo = NULL;
1534 	int add_pod_metadata = 1;
1535 	time_t now;
1536 CODESTARTdoAction
1537 	CHKiRet_Hdlr(extractMsgMetadata(pMsg, pWrkrData-&gt;pData, &amp;jMsgMeta)) {
1538 		ABORT_FINALIZE((iRet == RS_RET_NOT_FOUND) ? RS_RET_OK : iRet);
1539 	}
1540 	datetime.GetTime(&amp;now);
1541 	STATSCOUNTER_INC(pWrkrData-&gt;k8sRecordSeen, pWrkrData-&gt;mutK8sRecordSeen);
1542 	if (fjson_object_object_get_ex(jMsgMeta, "pod_name", &amp;jo))
1543 		podName = json_object_get_string(jo);
1544 	if (fjson_object_object_get_ex(jMsgMeta, "namespace_name", &amp;jo))
1545 		ns = json_object_get_string(jo);
1546 	if (fjson_object_object_get_ex(jMsgMeta, "container_name", &amp;jo))
1547 		containerName = json_object_get_string(jo);
1548 	if (fjson_object_object_get_ex(jMsgMeta, "container_id", &amp;jo))
1549 		containerID = json_object_get_string(jo);
1550 	assert(podName != NULL);
1551 	assert(ns != NULL);
1552 	assert(containerName != NULL);
1553 	assert(containerID != NULL);
1554 	dbgprintf("mmkubernetes:\n  podName: '%s'\n  namespace: '%s'\n  containerName: '%s'\n"
1555 		"  containerID: '%s'\n", podName, ns, containerName, containerID);
1556 	if ((-1 == asprintf(&amp;mdKey, "%s_%s_%s", ns, podName, containerName)) ||
1557 		(!mdKey)) {
1558 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1559 	}
1560 	pthread_mutex_lock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1561 	jMetadata = cache_entry_get_md(pWrkrData, mdKey, now);
1562 	if(jMetadata == NULL) {
1563 		char *url = NULL;
1564 		struct json_object *jReply = NULL, *jo2 = NULL, *jNsMeta = NULL, *jPodData = NULL;
1565 		jNsMeta = cache_entry_get_nsmd(pWrkrData, (const char *)ns, now);
1566 		if(jNsMeta == NULL) {
1567 			if ((-1 == asprintf(&amp;url, "%s/api/v1/namespaces/%s",
1568 				 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns)) ||
1569 				(!url)) {
1570 				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1571 				ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1572 			}
1573 			iRet = queryKB(pWrkrData, url, now, &amp;jReply);
1574 			free(url);
1575 			if (iRet == RS_RET_NOT_FOUND) {
1576 				jNsMeta = json_object_new_object();
1577 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataNotFound,
1578 						 pWrkrData-&gt;mutNamespaceMetadataNotFound);
1579 			} else if (iRet == RS_RET_RETRY) {
1580 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataBusy,
1581 						 pWrkrData-&gt;mutNamespaceMetadataBusy);
1582 				if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1583 					pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1584 					ABORT_FINALIZE(RS_RET_ERR);
1585 				}
1586 				add_pod_metadata = 0; 			} else if (iRet != RS_RET_OK) {
1587 				jNsMeta = json_object_new_object();
1588 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataError,
1589 						 pWrkrData-&gt;mutNamespaceMetadataError);
1590 			} else if (fjson_object_object_get_ex(jReply, "metadata", &amp;jNsMeta)) {
1591 				jNsMeta = json_object_get(jNsMeta);
1592 				parse_labels_annotations(jNsMeta, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
1593 					pWrkrData-&gt;pData-&gt;de_dot,
1594 					(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
1595 					pWrkrData-&gt;pData-&gt;de_dot_separator_len);
1596 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
1597 						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
1598 			} else {
1599 				LogMsg(0, RS_RET_ERR, LOG_INFO,
1600 					      "mmkubernetes: namespace [%s] has no metadata!\n", ns);
1601 				jNsMeta = json_object_new_object();
1602 				STATSCOUNTER_INC(pWrkrData-&gt;namespaceMetadataSuccess,
1603 						 pWrkrData-&gt;mutNamespaceMetadataSuccess);
1604 			}
1605 			if(jNsMeta) {
1606 				if ((iRet = cache_entry_add_nsmd(pWrkrData, ns, jNsMeta, now))) {
1607 					ABORT_FINALIZE(iRet);
1608 				}
1609 			}
1610 			json_object_put(jReply);
1611 			jReply = NULL;
1612 		}
1613 		if ((-1 == asprintf(&amp;url, "%s/api/v1/namespaces/%s/pods/%s",
1614 			 (char *) pWrkrData-&gt;pData-&gt;kubernetesUrl, ns, podName)) ||
1615 			(!url)) {
1616 			pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1617 			ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
1618 		}
1619 		iRet = queryKB(pWrkrData, url, now, &amp;jReply);
1620 		free(url);
1621 		if (iRet == RS_RET_NOT_FOUND) {
1622 			iRet = RS_RET_OK;
1623 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataNotFound, pWrkrData-&gt;mutPodMetadataNotFound);
1624 		} else if (iRet == RS_RET_RETRY) {
1625 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataBusy, pWrkrData-&gt;mutPodMetadataBusy);
1626 			if (0 == pWrkrData-&gt;pData-&gt;busyRetryInterval) {
1627 				pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1628 				ABORT_FINALIZE(RS_RET_ERR);
1629 			}
1630 			add_pod_metadata = 0; 			iRet = RS_RET_OK;
1631 		} else if(iRet != RS_RET_OK) {
1632 			iRet = RS_RET_OK;
1633 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataError, pWrkrData-&gt;mutPodMetadataError);
1634 		} else {
1635 			STATSCOUNTER_INC(pWrkrData-&gt;podMetadataSuccess, pWrkrData-&gt;mutPodMetadataSuccess);
1636 		}
1637 		jo = json_object_new_object();
1638 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "uid", &amp;jo2))
1639 			json_object_object_add(jo, "namespace_id", json_object_get(jo2));
1640 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "labels", &amp;jo2))
1641 			json_object_object_add(jo, "namespace_labels", json_object_get(jo2));
1642 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "annotations", &amp;jo2))
1643 			json_object_object_add(jo, "namespace_annotations", json_object_get(jo2));
1644 		if(jNsMeta &amp;&amp; fjson_object_object_get_ex(jNsMeta, "creationTimestamp", &amp;jo2))
1645 			json_object_object_add(jo, "creation_timestamp", json_object_get(jo2));
1646 		if(fjson_object_object_get_ex(jReply, "metadata", &amp;jPodData)) {
1647 			if(fjson_object_object_get_ex(jPodData, "uid", &amp;jo2))
1648 				json_object_object_add(jo, "pod_id", json_object_get(jo2));
1649 			parse_labels_annotations(jPodData, &amp;pWrkrData-&gt;pData-&gt;annotation_match,
1650 				pWrkrData-&gt;pData-&gt;de_dot,
1651 				(const char *)pWrkrData-&gt;pData-&gt;de_dot_separator,
1652 				pWrkrData-&gt;pData-&gt;de_dot_separator_len);
1653 			if(fjson_object_object_get_ex(jPodData, "annotations", &amp;jo2))
1654 				json_object_object_add(jo, "annotations", json_object_get(jo2));
1655 			if(fjson_object_object_get_ex(jPodData, "labels", &amp;jo2))
1656 				json_object_object_add(jo, "labels", json_object_get(jo2));
1657 		}
1658 		if(fjson_object_object_get_ex(jReply, "spec", &amp;jPodData)) {
1659 			if(fjson_object_object_get_ex(jPodData, "nodeName", &amp;jo2)) {
1660 				json_object_object_add(jo, "host", json_object_get(jo2));
1661 			}
1662 		}
1663 		json_object_put(jReply);
1664 		jReply = NULL;
1665 		if (fjson_object_object_get_ex(jMsgMeta, "pod_name", &amp;jo2))
1666 			json_object_object_add(jo, "pod_name", json_object_get(jo2));
1667 		if (fjson_object_object_get_ex(jMsgMeta, "namespace_name", &amp;jo2))
1668 			json_object_object_add(jo, "namespace_name", json_object_get(jo2));
1669 		if (fjson_object_object_get_ex(jMsgMeta, "container_name", &amp;jo2))
1670 			json_object_object_add(jo, "container_name", json_object_get(jo2));
1671 		json_object_object_add(jo, "master_url",
1672 			json_object_new_string((const char *)pWrkrData-&gt;pData-&gt;kubernetesUrl));
1673 		jMetadata = json_object_new_object();
1674 		json_object_object_add(jMetadata, "kubernetes", jo);
1675 		jo = json_object_new_object();
1676 		if (fjson_object_object_get_ex(jMsgMeta, "container_id", &amp;jo2))
1677 			json_object_object_add(jo, "container_id", json_object_get(jo2));
1678 		json_object_object_add(jMetadata, "docker", jo);
1679 		if (add_pod_metadata) {
1680 			if ((iRet = cache_entry_add_md(pWrkrData, mdKey, jMetadata, now)))
1681 				ABORT_FINALIZE(iRet);
1682 			mdKey = NULL;
1683 		}
1684 	}
1685 	jMetadataCopy = json_tokener_parse(json_object_get_string(jMetadata));
1686 	if (!add_pod_metadata) {
1687 		json_object_put(jMetadata);
1688 		jMetadata = NULL;
1689 	}
1690 	pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;cache-&gt;cacheMtx);
1691 	msgAddJSON(pMsg, (uchar *) pWrkrData-&gt;pData-&gt;dstMetadataPath + 1, jMetadataCopy, 0, 0);
1692 finalize_it:
1693 	json_object_put(jMsgMeta);
1694 	free(mdKey);
1695 ENDdoAction
1696 BEGINisCompatibleWithFeature
1697 CODESTARTisCompatibleWithFeature
1698 ENDisCompatibleWithFeature
1699 BEGINmodExit
1700 CODESTARTmodExit
1701 	curl_global_cleanup();
1702 	objRelease(datetime, CORE_COMPONENT);
1703 	objRelease(regexp, LM_REGEXP_FILENAME);
1704 	objRelease(statsobj, CORE_COMPONENT);
1705 ENDmodExit
1706 BEGINqueryEtryPt
1707 CODESTARTqueryEtryPt
1708 CODEqueryEtryPt_STD_OMOD_QUERIES
1709 CODEqueryEtryPt_STD_OMOD8_QUERIES
1710 CODEqueryEtryPt_STD_CONF2_QUERIES
1711 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
1712 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1713 ENDqueryEtryPt
1714 BEGINmodInit()
1715 CODESTARTmodInit
1716 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1717 	DBGPRINTF("mmkubernetes: module compiled with rsyslog version %s.\n", VERSION);
1718 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1719 	CHKiRet(objUse(regexp, LM_REGEXP_FILENAME));
1720 	CHKiRet(objUse(datetime, CORE_COMPONENT));
1721 	curl_global_init(CURL_GLOBAL_ALL);
1722 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
