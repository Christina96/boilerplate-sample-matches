
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-bitmap.c</h3>
            <pre><code>1  #include "private/autogen/config.h"
2  #include "hwloc/autogen/config.h"
3  #include "hwloc.h"
4  #include "private/misc.h"
5  #include "private/private.h"
6  #include "private/debug.h"
7  #include "hwloc/bitmap.h"
8  #include <stdarg.h>
9  #include <stdio.h>
10  #include <assert.h>
11  #include <errno.h>
12  #include <ctype.h>
13  #define HWLOC_BITMAP_MAGIC 0x20091007
14  #define HWLOC_BITMAP_PREALLOC_BITS 512
15  #define HWLOC_BITMAP_PREALLOC_ULONGS (HWLOC_BITMAP_PREALLOC_BITS/HWLOC_BITS_PER_LONG)
16  struct hwloc_bitmap_s {
17    unsigned ulongs_count; &bsol;* how many ulong bitmasks are valid, >= 1 */
18    unsigned ulongs_allocated; &bsol;* how many ulong bitmasks are allocated, >= ulongs_count */
19    unsigned long *ulongs;
20    int infinite; &bsol;* set to 1 if all bits beyond ulongs are set */
21  #ifdef HWLOC_DEBUG
22    int magic;
23  #endif
24  };
25  #ifdef HWLOC_DEBUG
26  #define HWLOC__BITMAP_CHECK(set) do {				\
27    assert((set)->magic == HWLOC_BITMAP_MAGIC);			\
28    assert((set)->ulongs_count >= 1);				\
29    assert((set)->ulongs_allocated >= (set)->ulongs_count);	\
30  } while (0)
31  #else
32  #define HWLOC__BITMAP_CHECK(set)
33  #endif
34  #define HWLOC_SUBBITMAP_INDEX(cpu)		((cpu)/(HWLOC_BITS_PER_LONG))
35  #define HWLOC_SUBBITMAP_CPU_ULBIT(cpu)		((cpu)%(HWLOC_BITS_PER_LONG))
36  #define HWLOC_SUBBITMAP_READULONG(set,x)	((x) < (set)->ulongs_count ? (set)->ulongs[x] : (set)->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO)
37  #define HWLOC_SUBBITMAP_ZERO			0UL
38  #define HWLOC_SUBBITMAP_FULL			(~0UL)
39  #define HWLOC_SUBBITMAP_ULBIT(bit)		(1UL<<(bit))
40  #define HWLOC_SUBBITMAP_CPU(cpu)		HWLOC_SUBBITMAP_ULBIT(HWLOC_SUBBITMAP_CPU_ULBIT(cpu))
41  #define HWLOC_SUBBITMAP_ULBIT_TO(bit)		(HWLOC_SUBBITMAP_FULL>>(HWLOC_BITS_PER_LONG-1-(bit)))
42  #define HWLOC_SUBBITMAP_ULBIT_FROM(bit)		(HWLOC_SUBBITMAP_FULL<<(bit))
43  #define HWLOC_SUBBITMAP_ULBIT_FROMTO(begin,end)	(HWLOC_SUBBITMAP_ULBIT_TO(end) & HWLOC_SUBBITMAP_ULBIT_FROM(begin))
44  struct hwloc_bitmap_s * hwloc_bitmap_alloc(void)
45  {
46    struct hwloc_bitmap_s * set;
47    set = malloc(sizeof(struct hwloc_bitmap_s));
48    if (!set)
49      return NULL;
50    set->ulongs_count = 1;
51    set->ulongs_allocated = HWLOC_BITMAP_PREALLOC_ULONGS;
52    set->ulongs = malloc(HWLOC_BITMAP_PREALLOC_ULONGS * sizeof(unsigned long));
53    if (!set->ulongs) {
54      free(set);
55      return NULL;
56    }
57    set->ulongs[0] = HWLOC_SUBBITMAP_ZERO;
58    set->infinite = 0;
59  #ifdef HWLOC_DEBUG
60    set->magic = HWLOC_BITMAP_MAGIC;
61  #endif
62    return set;
63  }
64  struct hwloc_bitmap_s * hwloc_bitmap_alloc_full(void)
65  {
66    struct hwloc_bitmap_s * set = hwloc_bitmap_alloc();
67    if (set) {
68      set->infinite = 1;
69      set->ulongs[0] = HWLOC_SUBBITMAP_FULL;
70    }
71    return set;
72  }
73  void hwloc_bitmap_free(struct hwloc_bitmap_s * set)
74  {
75    if (!set)
76      return;
77    HWLOC__BITMAP_CHECK(set);
78  #ifdef HWLOC_DEBUG
79    set->magic = 0;
80  #endif
81    free(set->ulongs);
82    free(set);
83  }
84  static int
85  hwloc_bitmap_enlarge_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count) __hwloc_attribute_warn_unused_result;
86  static int
87  hwloc_bitmap_enlarge_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count)
88  {
89    unsigned tmp = 1U << hwloc_flsl((unsigned long) needed_count - 1);
90    if (tmp > set->ulongs_allocated) {
91      unsigned long *tmpulongs;
92      tmpulongs = realloc(set->ulongs, tmp * sizeof(unsigned long));
93      if (!tmpulongs)
94        return -1;
95      set->ulongs = tmpulongs;
96      set->ulongs_allocated = tmp;
97    }
98    return 0;
99  }
100  static int
101  hwloc_bitmap_realloc_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count) __hwloc_attribute_warn_unused_result;
102  static int
103  hwloc_bitmap_realloc_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count)
104  {
105    unsigned i;
106    HWLOC__BITMAP_CHECK(set);
107    if (needed_count <= set->ulongs_count)
108      return 0;
109    if (hwloc_bitmap_enlarge_by_ulongs(set, needed_count) < 0)
110      return -1;
111    for(i=set->ulongs_count; i<needed_count; i++)
112      set->ulongs[i] = set->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
113    set->ulongs_count = needed_count;
114    return 0;
115  }
116  #define hwloc_bitmap_realloc_by_cpu_index(set, cpu) hwloc_bitmap_realloc_by_ulongs(set, ((cpu)/HWLOC_BITS_PER_LONG)+1)
117  static int
118  hwloc_bitmap_reset_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count) __hwloc_attribute_warn_unused_result;
119  static int
120  hwloc_bitmap_reset_by_ulongs(struct hwloc_bitmap_s * set, unsigned needed_count)
121  {
122    if (hwloc_bitmap_enlarge_by_ulongs(set, needed_count))
123      return -1;
124    set->ulongs_count = needed_count;
125    return 0;
126  }
127  #define hwloc_bitmap_reset_by_cpu_index(set, cpu) hwloc_bitmap_reset_by_ulongs(set, ((cpu)/HWLOC_BITS_PER_LONG)+1)
128  struct hwloc_bitmap_s * hwloc_bitmap_tma_dup(struct hwloc_tma *tma, const struct hwloc_bitmap_s * old)
129  {
130    struct hwloc_bitmap_s * new;
131    if (!old)
132      return NULL;
133    HWLOC__BITMAP_CHECK(old);
134    new = hwloc_tma_malloc(tma, sizeof(struct hwloc_bitmap_s));
135    if (!new)
136      return NULL;
137    new->ulongs = hwloc_tma_malloc(tma, old->ulongs_allocated * sizeof(unsigned long));
138    if (!new->ulongs) {
<span onclick='openModal()' class='match'>139      free(new);
140      return NULL;
141    }
142    new->ulongs_allocated = old->ulongs_allocated;
143    new->ulongs_count = old->ulongs_count;
</span>144    memcpy(new->ulongs, old->ulongs, new->ulongs_count * sizeof(unsigned long));
145    new->infinite = old->infinite;
146  #ifdef HWLOC_DEBUG
147    new->magic = HWLOC_BITMAP_MAGIC;
148  #endif
149    return new;
150  }
151  struct hwloc_bitmap_s * hwloc_bitmap_dup(const struct hwloc_bitmap_s * old)
152  {
153    return hwloc_bitmap_tma_dup(NULL, old);
154  }
155  int hwloc_bitmap_copy(struct hwloc_bitmap_s * dst, const struct hwloc_bitmap_s * src)
156  {
157    HWLOC__BITMAP_CHECK(dst);
158    HWLOC__BITMAP_CHECK(src);
159    if (hwloc_bitmap_reset_by_ulongs(dst, src->ulongs_count) < 0)
160      return -1;
161    memcpy(dst->ulongs, src->ulongs, src->ulongs_count * sizeof(unsigned long));
162    dst->infinite = src->infinite;
163    return 0;
164  }
165  #define HWLOC_PRIxSUBBITMAP		"%08lx"
166  #define HWLOC_BITMAP_SUBSTRING_SIZE	32
167  #define HWLOC_BITMAP_SUBSTRING_LENGTH	(HWLOC_BITMAP_SUBSTRING_SIZE/4)
168  #define HWLOC_BITMAP_STRING_PER_LONG	(HWLOC_BITS_PER_LONG/HWLOC_BITMAP_SUBSTRING_SIZE)
169  int hwloc_bitmap_snprintf(char * __hwloc_restrict buf, size_t buflen, const struct hwloc_bitmap_s * __hwloc_restrict set)
170  {
171    ssize_t size = buflen;
172    char *tmp = buf;
173    int res, ret = 0;
174    int needcomma = 0;
175    int i;
176    unsigned long accum = 0;
177    int accumed = 0;
178  #if HWLOC_BITS_PER_LONG == HWLOC_BITMAP_SUBSTRING_SIZE
179    const unsigned long accum_mask = ~0UL;
180  #else &bsol;* HWLOC_BITS_PER_LONG != HWLOC_BITMAP_SUBSTRING_SIZE */
181    const unsigned long accum_mask = ((1UL << HWLOC_BITMAP_SUBSTRING_SIZE) - 1) << (HWLOC_BITS_PER_LONG - HWLOC_BITMAP_SUBSTRING_SIZE);
182  #endif &bsol;* HWLOC_BITS_PER_LONG != HWLOC_BITMAP_SUBSTRING_SIZE */
183    HWLOC__BITMAP_CHECK(set);
184    if (buflen > 0)
185      tmp[0] = '\0';
186    if (set->infinite) {
187      res = hwloc_snprintf(tmp, size, "0xf...f");
188      needcomma = 1;
189      if (res < 0)
190        return -1;
191      ret += res;
192      if (res >= size)
193        res = size>0 ? (int)size - 1 : 0;
194      tmp += res;
195      size -= res;
196    }
197    i=(int) set->ulongs_count-1;
198    if (set->infinite) {
199      while (i>=0 && set->ulongs[i] == HWLOC_SUBBITMAP_FULL)
200        i--;
201    } else {
202      while (i>=0 && set->ulongs[i] == HWLOC_SUBBITMAP_ZERO)
203        i--;
204    }
205    while (i>=0 || accumed) {
206      if (!accumed) {
207        accum = set->ulongs[i--];
208        accumed = HWLOC_BITS_PER_LONG;
209      }
210      if (accum & accum_mask) {
211          res = hwloc_snprintf(tmp, size, needcomma ? ",0x" HWLOC_PRIxSUBBITMAP : "0x" HWLOC_PRIxSUBBITMAP,
212  		     (accum & accum_mask) >> (HWLOC_BITS_PER_LONG - HWLOC_BITMAP_SUBSTRING_SIZE));
213        needcomma = 1;
214      } else if (i == -1 && accumed == HWLOC_BITMAP_SUBSTRING_SIZE) {
215        res = hwloc_snprintf(tmp, size, needcomma ? ",0x0" : "0x0");
216      } else if (needcomma) {
217        res = hwloc_snprintf(tmp, size, ",");
218      } else {
219        res = 0;
220      }
221      if (res < 0)
222        return -1;
223      ret += res;
224  #if HWLOC_BITS_PER_LONG == HWLOC_BITMAP_SUBSTRING_SIZE
225      accum = 0;
226      accumed = 0;
227  #else
228      accum <<= HWLOC_BITMAP_SUBSTRING_SIZE;
229      accumed -= HWLOC_BITMAP_SUBSTRING_SIZE;
230  #endif
231      if (res >= size)
232        res = size>0 ? (int)size - 1 : 0;
233      tmp += res;
234      size -= res;
235    }
236    if (!ret) {
237      res = hwloc_snprintf(tmp, size, "0x0");
238      if (res < 0)
239        return -1;
240      ret += res;
241    }
242    return ret;
243  }
244  int hwloc_bitmap_asprintf(char ** strp, const struct hwloc_bitmap_s * __hwloc_restrict set)
245  {
246    int len;
247    char *buf;
248    HWLOC__BITMAP_CHECK(set);
249    len = hwloc_bitmap_snprintf(NULL, 0, set);
250    buf = malloc(len+1);
251    if (!buf)
252      return -1;
253    *strp = buf;
254    return hwloc_bitmap_snprintf(buf, len+1, set);
255  }
256  int hwloc_bitmap_sscanf(struct hwloc_bitmap_s *set, const char * __hwloc_restrict string)
257  {
258    const char * current = string;
259    unsigned long accum = 0;
260    int count=0;
261    int infinite = 0;
262    count++;
263    while ((current = strchr(current+1, ',')) != NULL)
264      count++;
265    current = string;
266    if (!strncmp("0xf...f", current, 7)) {
267      current += 7;
268      if (*current != ',') {
269        hwloc_bitmap_fill(set);
270        return 0;
271      }
272      current++;
273      infinite = 1;
274      count--;
275    }
276    if (hwloc_bitmap_reset_by_ulongs(set, (count + HWLOC_BITMAP_STRING_PER_LONG - 1) / HWLOC_BITMAP_STRING_PER_LONG) < 0)
277      return -1;
278    set->infinite = 0;
279    while (*current != '\0') {
280      unsigned long val;
281      char *next;
282      val = strtoul(current, &next, 16);
283      assert(count > 0);
284      count--;
285      accum |= (val << ((count * HWLOC_BITMAP_SUBSTRING_SIZE) % HWLOC_BITS_PER_LONG));
286      if (!(count % HWLOC_BITMAP_STRING_PER_LONG)) {
287        set->ulongs[count / HWLOC_BITMAP_STRING_PER_LONG] = accum;
288        accum = 0;
289      }
290      if (*next != ',') {
291        if (*next || count > 0)
292  	goto failed;
293        else
294  	break;
295      }
296      current = (const char*) next+1;
297    }
298    set->infinite = infinite; &bsol;* set at the end, to avoid spurious realloc with filled new ulongs */
299    return 0;
300   failed:
301    hwloc_bitmap_zero(set);
302    return -1;
303  }
304  int hwloc_bitmap_list_snprintf(char * __hwloc_restrict buf, size_t buflen, const struct hwloc_bitmap_s * __hwloc_restrict set)
305  {
306    int prev = -1;
307    ssize_t size = buflen;
308    char *tmp = buf;
309    int res, ret = 0;
310    int needcomma = 0;
311    HWLOC__BITMAP_CHECK(set);
312    if (buflen > 0)
313      tmp[0] = '\0';
314    while (1) {
315      int begin, end;
316      begin = hwloc_bitmap_next(set, prev);
317      if (begin == -1)
318        break;
319      end = hwloc_bitmap_next_unset(set, begin);
320      if (end == begin+1) {
321        res = hwloc_snprintf(tmp, size, needcomma ? ",%d" : "%d", begin);
322      } else if (end == -1) {
323        res = hwloc_snprintf(tmp, size, needcomma ? ",%d-" : "%d-", begin);
324      } else {
325        res = hwloc_snprintf(tmp, size, needcomma ? ",%d-%d" : "%d-%d", begin, end-1);
326      }
327      if (res < 0)
328        return -1;
329      ret += res;
330      if (res >= size)
331        res = size>0 ? (int)size - 1 : 0;
332      tmp += res;
333      size -= res;
334      needcomma = 1;
335      if (end == -1)
336        break;
337      else
338        prev = end - 1;
339    }
340    return ret;
341  }
342  int hwloc_bitmap_list_asprintf(char ** strp, const struct hwloc_bitmap_s * __hwloc_restrict set)
343  {
344    int len;
345    char *buf;
346    HWLOC__BITMAP_CHECK(set);
347    len = hwloc_bitmap_list_snprintf(NULL, 0, set);
348    buf = malloc(len+1);
349    if (!buf)
350      return -1;
351    *strp = buf;
352    return hwloc_bitmap_list_snprintf(buf, len+1, set);
353  }
354  int hwloc_bitmap_list_sscanf(struct hwloc_bitmap_s *set, const char * __hwloc_restrict string)
355  {
356    const char * current = string;
357    char *next;
358    long begin = -1, val;
359    hwloc_bitmap_zero(set);
360    while (*current != '\0') {
361      while (*current == ',' || *current == ' ')
362        current++;
363      val = strtoul(current, &next, 0);
364      if (next == current)
365        goto failed;
366      if (begin != -1) {
367        if (hwloc_bitmap_set_range(set, begin, val) < 0)
368          goto failed;
369        begin = -1;
370      } else if (*next == '-') {
371        if (*(next+1) == '\0') {
372  	if (hwloc_bitmap_set_range(set, val, -1) < 0)
373  	  goto failed;
374          break;
375        } else {
376  	begin = val;
377        }
378      } else if (*next == ',' || *next == ' ' || *next == '\0') {
379        hwloc_bitmap_set(set, val);
380      }
381      if (*next == '\0')
382        break;
383      current = next+1;
384    }
385    return 0;
386   failed:
387    hwloc_bitmap_zero(set);
388    return -1;
389  }
390  int hwloc_bitmap_taskset_snprintf(char * __hwloc_restrict buf, size_t buflen, const struct hwloc_bitmap_s * __hwloc_restrict set)
391  {
392    ssize_t size = buflen;
393    char *tmp = buf;
394    int res, ret = 0;
395    int started = 0;
396    int i;
397    HWLOC__BITMAP_CHECK(set);
398    if (buflen > 0)
399      tmp[0] = '\0';
400    if (set->infinite) {
401      res = hwloc_snprintf(tmp, size, "0xf...f");
402      started = 1;
403      if (res < 0)
404        return -1;
405      ret += res;
406      if (res >= size)
407        res = size>0 ? (int)size - 1 : 0;
408      tmp += res;
409      size -= res;
410    }
411    i=set->ulongs_count-1;
412    if (set->infinite) {
413      while (i>=0 && set->ulongs[i] == HWLOC_SUBBITMAP_FULL)
414        i--;
415    } else {
416      while (i>=1 && set->ulongs[i] == HWLOC_SUBBITMAP_ZERO)
417        i--;
418    }
419    while (i>=0) {
420      unsigned long val = set->ulongs[i--];
421      if (started) {
422  #if HWLOC_BITS_PER_LONG == 64
423        res = hwloc_snprintf(tmp, size, "%016lx", val);
424  #else
425        res = hwloc_snprintf(tmp, size, "%08lx", val);
426  #endif
427      } else if (val || i == -1) {
428        res = hwloc_snprintf(tmp, size, "0x%lx", val);
429        started = 1;
430      } else {
431        res = 0;
432      }
433      if (res < 0)
434        return -1;
435      ret += res;
436      if (res >= size)
437        res = size>0 ? (int)size - 1 : 0;
438      tmp += res;
439      size -= res;
440    }
441    if (!ret) {
442      res = hwloc_snprintf(tmp, size, "0x0");
443      if (res < 0)
444        return -1;
445      ret += res;
446    }
447    return ret;
448  }
449  int hwloc_bitmap_taskset_asprintf(char ** strp, const struct hwloc_bitmap_s * __hwloc_restrict set)
450  {
451    int len;
452    char *buf;
453    HWLOC__BITMAP_CHECK(set);
454    len = hwloc_bitmap_taskset_snprintf(NULL, 0, set);
455    buf = malloc(len+1);
456    if (!buf)
457      return -1;
458    *strp = buf;
459    return hwloc_bitmap_taskset_snprintf(buf, len+1, set);
460  }
461  int hwloc_bitmap_taskset_sscanf(struct hwloc_bitmap_s *set, const char * __hwloc_restrict string)
462  {
463    const char * current = string;
464    int chars;
465    int count;
466    int infinite = 0;
467    if (!strncmp("0xf...f", current, 7)) {
468      infinite = 1;
469      current += 7;
470      if (*current == '\0') {
471        hwloc_bitmap_fill(set);
472        return 0;
473      }
474    } else {
475      if (!strncmp("0x", current, 2))
476        current += 2;
477      if (*current == '\0') {
478        hwloc_bitmap_zero(set);
479        return 0;
480      }
481    }
482    chars = (int)strlen(current);
483    count = (chars * 4 + HWLOC_BITS_PER_LONG - 1) / HWLOC_BITS_PER_LONG;
484    if (hwloc_bitmap_reset_by_ulongs(set, count) < 0)
485      return -1;
486    set->infinite = 0;
487    while (*current != '\0') {
488      int tmpchars;
489      char ustr[17];
490      unsigned long val;
491      char *next;
492      tmpchars = chars % (HWLOC_BITS_PER_LONG/4);
493      if (!tmpchars)
494        tmpchars = (HWLOC_BITS_PER_LONG/4);
495      memcpy(ustr, current, tmpchars);
496      ustr[tmpchars] = '\0';
497      val = strtoul(ustr, &next, 16);
498      if (*next != '\0')
499        goto failed;
500      set->ulongs[count-1] = val;
501      current += tmpchars;
502      chars -= tmpchars;
503      count--;
504    }
505    set->infinite = infinite; &bsol;* set at the end, to avoid spurious realloc with filled new ulongs */
506    return 0;
507   failed:
508    hwloc_bitmap_zero(set);
509    return -1;
510  }
511  static void hwloc_bitmap__zero(struct hwloc_bitmap_s *set)
512  {
513  	unsigned i;
514  	for(i=0; i<set->ulongs_count; i++)
515  		set->ulongs[i] = HWLOC_SUBBITMAP_ZERO;
516  	set->infinite = 0;
517  }
518  void hwloc_bitmap_zero(struct hwloc_bitmap_s * set)
519  {
520  	HWLOC__BITMAP_CHECK(set);
521  	HWLOC_BUILD_ASSERT(HWLOC_BITMAP_PREALLOC_ULONGS >= 1);
522  	if (hwloc_bitmap_reset_by_ulongs(set, 1) < 0) {
523  	}
524  	hwloc_bitmap__zero(set);
525  }
526  static void hwloc_bitmap__fill(struct hwloc_bitmap_s * set)
527  {
528  	unsigned i;
529  	for(i=0; i<set->ulongs_count; i++)
530  		set->ulongs[i] = HWLOC_SUBBITMAP_FULL;
531  	set->infinite = 1;
532  }
533  void hwloc_bitmap_fill(struct hwloc_bitmap_s * set)
534  {
535  	HWLOC__BITMAP_CHECK(set);
536  	HWLOC_BUILD_ASSERT(HWLOC_BITMAP_PREALLOC_ULONGS >= 1);
537  	if (hwloc_bitmap_reset_by_ulongs(set, 1) < 0) {
538  	}
539  	hwloc_bitmap__fill(set);
540  }
541  int hwloc_bitmap_from_ulong(struct hwloc_bitmap_s *set, unsigned long mask)
542  {
543  	HWLOC__BITMAP_CHECK(set);
544  	HWLOC_BUILD_ASSERT(HWLOC_BITMAP_PREALLOC_ULONGS >= 1);
545  	if (hwloc_bitmap_reset_by_ulongs(set, 1) < 0) {
546  	}
547  	set->ulongs[0] = mask; &bsol;* there's always at least one ulong allocated */
548  	set->infinite = 0;
549  	return 0;
550  }
551  int hwloc_bitmap_from_ith_ulong(struct hwloc_bitmap_s *set, unsigned i, unsigned long mask)
552  {
553  	unsigned j;
554  	HWLOC__BITMAP_CHECK(set);
555  	if (hwloc_bitmap_reset_by_ulongs(set, i+1) < 0)
556  		return -1;
557  	set->ulongs[i] = mask;
558  	for(j=0; j<i; j++)
559  		set->ulongs[j] = HWLOC_SUBBITMAP_ZERO;
560  	set->infinite = 0;
561  	return 0;
562  }
563  int hwloc_bitmap_from_ulongs(struct hwloc_bitmap_s *set, unsigned nr, const unsigned long *masks)
564  {
565  	unsigned j;
566  	HWLOC__BITMAP_CHECK(set);
567  	if (hwloc_bitmap_reset_by_ulongs(set, nr) < 0)
568  		return -1;
569  	for(j=0; j<nr; j++)
570  		set->ulongs[j] = masks[j];
571  	set->infinite = 0;
572  	return 0;
573  }
574  unsigned long hwloc_bitmap_to_ulong(const struct hwloc_bitmap_s *set)
575  {
576  	HWLOC__BITMAP_CHECK(set);
577  	return set->ulongs[0]; &bsol;* there's always at least one ulong allocated */
578  }
579  unsigned long hwloc_bitmap_to_ith_ulong(const struct hwloc_bitmap_s *set, unsigned i)
580  {
581  	HWLOC__BITMAP_CHECK(set);
582  	return HWLOC_SUBBITMAP_READULONG(set, i);
583  }
584  int hwloc_bitmap_to_ulongs(const struct hwloc_bitmap_s *set, unsigned nr, unsigned long *masks)
585  {
586  	unsigned j;
587  	HWLOC__BITMAP_CHECK(set);
588  	for(j=0; j<nr; j++)
589  		masks[j] = HWLOC_SUBBITMAP_READULONG(set, j);
590  	return 0;
591  }
592  int hwloc_bitmap_nr_ulongs(const struct hwloc_bitmap_s *set)
593  {
594  	unsigned last;
595  	HWLOC__BITMAP_CHECK(set);
596  	if (set->infinite)
597  		return -1;
598  	last = hwloc_bitmap_last(set);
599  	return (last + HWLOC_BITS_PER_LONG)/HWLOC_BITS_PER_LONG;
600  }
601  int hwloc_bitmap_only(struct hwloc_bitmap_s * set, unsigned cpu)
602  {
603  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
604  	HWLOC__BITMAP_CHECK(set);
605  	if (hwloc_bitmap_reset_by_cpu_index(set, cpu) < 0)
606  		return -1;
607  	hwloc_bitmap__zero(set);
608  	set->ulongs[index_] |= HWLOC_SUBBITMAP_CPU(cpu);
609  	return 0;
610  }
611  int hwloc_bitmap_allbut(struct hwloc_bitmap_s * set, unsigned cpu)
612  {
613  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
614  	HWLOC__BITMAP_CHECK(set);
615  	if (hwloc_bitmap_reset_by_cpu_index(set, cpu) < 0)
616  		return -1;
617  	hwloc_bitmap__fill(set);
618  	set->ulongs[index_] &= ~HWLOC_SUBBITMAP_CPU(cpu);
619  	return 0;
620  }
621  int hwloc_bitmap_set(struct hwloc_bitmap_s * set, unsigned cpu)
622  {
623  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
624  	HWLOC__BITMAP_CHECK(set);
625  	if (set->infinite && cpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
626  		return 0;
627  	if (hwloc_bitmap_realloc_by_cpu_index(set, cpu) < 0)
628  		return -1;
629  	set->ulongs[index_] |= HWLOC_SUBBITMAP_CPU(cpu);
630  	return 0;
631  }
632  int hwloc_bitmap_set_range(struct hwloc_bitmap_s * set, unsigned begincpu, int _endcpu)
633  {
634  	unsigned i;
635  	unsigned beginset,endset;
636  	unsigned endcpu = (unsigned) _endcpu;
637  	HWLOC__BITMAP_CHECK(set);
638  	if (endcpu < begincpu)
639  		return 0;
640  	if (set->infinite && begincpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
641  		return 0;
642  	if (_endcpu == -1) {
643  		if (hwloc_bitmap_realloc_by_cpu_index(set, begincpu) < 0)
644  			return -1;
645  		beginset = HWLOC_SUBBITMAP_INDEX(begincpu);
646  		set->ulongs[beginset] |= HWLOC_SUBBITMAP_ULBIT_FROM(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu));
647  		for(i=beginset+1; i<set->ulongs_count; i++)
648  			set->ulongs[i] = HWLOC_SUBBITMAP_FULL;
649  		set->infinite = 1;
650  	} else {
651  		if (set->infinite && endcpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
652  			endcpu = set->ulongs_count * HWLOC_BITS_PER_LONG - 1;
653  		if (hwloc_bitmap_realloc_by_cpu_index(set, endcpu) < 0)
654  			return -1;
655  		beginset = HWLOC_SUBBITMAP_INDEX(begincpu);
656  		endset = HWLOC_SUBBITMAP_INDEX(endcpu);
657  		if (beginset == endset) {
658  			set->ulongs[beginset] |= HWLOC_SUBBITMAP_ULBIT_FROMTO(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu), HWLOC_SUBBITMAP_CPU_ULBIT(endcpu));
659  		} else {
660  			set->ulongs[beginset] |= HWLOC_SUBBITMAP_ULBIT_FROM(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu));
661  			set->ulongs[endset] |= HWLOC_SUBBITMAP_ULBIT_TO(HWLOC_SUBBITMAP_CPU_ULBIT(endcpu));
662  		}
663  		for(i=beginset+1; i<endset; i++)
664  			set->ulongs[i] = HWLOC_SUBBITMAP_FULL;
665  	}
666  	return 0;
667  }
668  int hwloc_bitmap_set_ith_ulong(struct hwloc_bitmap_s *set, unsigned i, unsigned long mask)
669  {
670  	HWLOC__BITMAP_CHECK(set);
671  	if (hwloc_bitmap_realloc_by_ulongs(set, i+1) < 0)
672  		return -1;
673  	set->ulongs[i] = mask;
674  	return 0;
675  }
676  int hwloc_bitmap_clr(struct hwloc_bitmap_s * set, unsigned cpu)
677  {
678  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
679  	HWLOC__BITMAP_CHECK(set);
680  	if (!set->infinite && cpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
681  		return 0;
682  	if (hwloc_bitmap_realloc_by_cpu_index(set, cpu) < 0)
683  		return -1;
684  	set->ulongs[index_] &= ~HWLOC_SUBBITMAP_CPU(cpu);
685  	return 0;
686  }
687  int hwloc_bitmap_clr_range(struct hwloc_bitmap_s * set, unsigned begincpu, int _endcpu)
688  {
689  	unsigned i;
690  	unsigned beginset,endset;
691  	unsigned endcpu = (unsigned) _endcpu;
692  	HWLOC__BITMAP_CHECK(set);
693  	if (endcpu < begincpu)
694  		return 0;
695  	if (!set->infinite && begincpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
696  		return 0;
697  	if (_endcpu == -1) {
698  		if (hwloc_bitmap_realloc_by_cpu_index(set, begincpu) < 0)
699  			return -1;
700  		beginset = HWLOC_SUBBITMAP_INDEX(begincpu);
701  		set->ulongs[beginset] &= ~HWLOC_SUBBITMAP_ULBIT_FROM(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu));
702  		for(i=beginset+1; i<set->ulongs_count; i++)
703  			set->ulongs[i] = HWLOC_SUBBITMAP_ZERO;
704  		set->infinite = 0;
705  	} else {
706  		if (!set->infinite && endcpu >= set->ulongs_count * HWLOC_BITS_PER_LONG)
707  			endcpu = set->ulongs_count * HWLOC_BITS_PER_LONG - 1;
708  		if (hwloc_bitmap_realloc_by_cpu_index(set, endcpu) < 0)
709  			return -1;
710  		beginset = HWLOC_SUBBITMAP_INDEX(begincpu);
711  		endset = HWLOC_SUBBITMAP_INDEX(endcpu);
712  		if (beginset == endset) {
713  			set->ulongs[beginset] &= ~HWLOC_SUBBITMAP_ULBIT_FROMTO(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu), HWLOC_SUBBITMAP_CPU_ULBIT(endcpu));
714  		} else {
715  			set->ulongs[beginset] &= ~HWLOC_SUBBITMAP_ULBIT_FROM(HWLOC_SUBBITMAP_CPU_ULBIT(begincpu));
716  			set->ulongs[endset] &= ~HWLOC_SUBBITMAP_ULBIT_TO(HWLOC_SUBBITMAP_CPU_ULBIT(endcpu));
717  		}
718  		for(i=beginset+1; i<endset; i++)
719  			set->ulongs[i] = HWLOC_SUBBITMAP_ZERO;
720  	}
721  	return 0;
722  }
723  int hwloc_bitmap_isset(const struct hwloc_bitmap_s * set, unsigned cpu)
724  {
725  	unsigned index_ = HWLOC_SUBBITMAP_INDEX(cpu);
726  	HWLOC__BITMAP_CHECK(set);
727  	return (HWLOC_SUBBITMAP_READULONG(set, index_) & HWLOC_SUBBITMAP_CPU(cpu)) != 0;
728  }
729  int hwloc_bitmap_iszero(const struct hwloc_bitmap_s *set)
730  {
731  	unsigned i;
732  	HWLOC__BITMAP_CHECK(set);
733  	if (set->infinite)
734  		return 0;
735  	for(i=0; i<set->ulongs_count; i++)
736  		if (set->ulongs[i] != HWLOC_SUBBITMAP_ZERO)
737  			return 0;
738  	return 1;
739  }
740  int hwloc_bitmap_isfull(const struct hwloc_bitmap_s *set)
741  {
742  	unsigned i;
743  	HWLOC__BITMAP_CHECK(set);
744  	if (!set->infinite)
745  		return 0;
746  	for(i=0; i<set->ulongs_count; i++)
747  		if (set->ulongs[i] != HWLOC_SUBBITMAP_FULL)
748  			return 0;
749  	return 1;
750  }
751  int hwloc_bitmap_isequal (const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
752  {
753  	unsigned count1 = set1->ulongs_count;
754  	unsigned count2 = set2->ulongs_count;
755  	unsigned min_count = count1 < count2 ? count1 : count2;
756  	unsigned i;
757  	HWLOC__BITMAP_CHECK(set1);
758  	HWLOC__BITMAP_CHECK(set2);
759  	for(i=0; i<min_count; i++)
760  		if (set1->ulongs[i] != set2->ulongs[i])
761  			return 0;
762  	if (count1 != count2) {
763  		unsigned long w1 = set1->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
764  		unsigned long w2 = set2->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
765  		for(i=min_count; i<count1; i++) {
766  			if (set1->ulongs[i] != w2)
767  				return 0;
768  		}
769  		for(i=min_count; i<count2; i++) {
770  			if (set2->ulongs[i] != w1)
771  				return 0;
772  		}
773  	}
774  	if (set1->infinite != set2->infinite)
775  		return 0;
776  	return 1;
777  }
778  int hwloc_bitmap_intersects (const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
779  {
780  	unsigned count1 = set1->ulongs_count;
781  	unsigned count2 = set2->ulongs_count;
782  	unsigned min_count = count1 < count2 ? count1 : count2;
783  	unsigned i;
784  	HWLOC__BITMAP_CHECK(set1);
785  	HWLOC__BITMAP_CHECK(set2);
786  	for(i=0; i<min_count; i++)
787  		if (set1->ulongs[i] & set2->ulongs[i])
788  			return 1;
789  	if (count1 != count2) {
790  		if (set2->infinite) {
791  			for(i=min_count; i<set1->ulongs_count; i++)
792  				if (set1->ulongs[i])
793  					return 1;
794  		}
795  		if (set1->infinite) {
796  			for(i=min_count; i<set2->ulongs_count; i++)
797  				if (set2->ulongs[i])
798  					return 1;
799  		}
800  	}
801  	if (set1->infinite && set2->infinite)
802  		return 1;
803  	return 0;
804  }
805  int hwloc_bitmap_isincluded (const struct hwloc_bitmap_s *sub_set, const struct hwloc_bitmap_s *super_set)
806  {
807  	unsigned super_count = super_set->ulongs_count;
808  	unsigned sub_count = sub_set->ulongs_count;
809  	unsigned min_count = super_count < sub_count ? super_count : sub_count;
810  	unsigned i;
811  	HWLOC__BITMAP_CHECK(sub_set);
812  	HWLOC__BITMAP_CHECK(super_set);
813  	for(i=0; i<min_count; i++)
814  		if (super_set->ulongs[i] != (super_set->ulongs[i] | sub_set->ulongs[i]))
815  			return 0;
816  	if (super_count != sub_count) {
817  		if (!super_set->infinite)
818  			for(i=min_count; i<sub_count; i++)
819  				if (sub_set->ulongs[i])
820  					return 0;
821  		if (sub_set->infinite)
822  			for(i=min_count; i<super_count; i++)
823  				if (super_set->ulongs[i] != HWLOC_SUBBITMAP_FULL)
824  					return 0;
825  	}
826  	if (sub_set->infinite && !super_set->infinite)
827  		return 0;
828  	return 1;
829  }
830  int hwloc_bitmap_or (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
831  {
832  	unsigned count1 = set1->ulongs_count;
833  	unsigned count2 = set2->ulongs_count;
834  	unsigned max_count = count1 > count2 ? count1 : count2;
835  	unsigned min_count = count1 + count2 - max_count;
836  	unsigned i;
837  	HWLOC__BITMAP_CHECK(res);
838  	HWLOC__BITMAP_CHECK(set1);
839  	HWLOC__BITMAP_CHECK(set2);
840  	if (hwloc_bitmap_reset_by_ulongs(res, max_count) < 0)
841  		return -1;
842  	for(i=0; i<min_count; i++)
843  		res->ulongs[i] = set1->ulongs[i] | set2->ulongs[i];
844  	if (count1 != count2) {
845  		if (min_count < count1) {
846  			if (set2->infinite) {
847  				res->ulongs_count = min_count;
848  			} else {
849  				for(i=min_count; i<max_count; i++)
850  					res->ulongs[i] = set1->ulongs[i];
851  			}
852  		} else {
853  			if (set1->infinite) {
854  				res->ulongs_count = min_count;
855  			} else {
856  				for(i=min_count; i<max_count; i++)
857  					res->ulongs[i] = set2->ulongs[i];
858  			}
859  		}
860  	}
861  	res->infinite = set1->infinite || set2->infinite;
862  	return 0;
863  }
864  int hwloc_bitmap_and (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
865  {
866  	unsigned count1 = set1->ulongs_count;
867  	unsigned count2 = set2->ulongs_count;
868  	unsigned max_count = count1 > count2 ? count1 : count2;
869  	unsigned min_count = count1 + count2 - max_count;
870  	unsigned i;
871  	HWLOC__BITMAP_CHECK(res);
872  	HWLOC__BITMAP_CHECK(set1);
873  	HWLOC__BITMAP_CHECK(set2);
874  	if (hwloc_bitmap_reset_by_ulongs(res, max_count) < 0)
875  		return -1;
876  	for(i=0; i<min_count; i++)
877  		res->ulongs[i] = set1->ulongs[i] & set2->ulongs[i];
878  	if (count1 != count2) {
879  		if (min_count < count1) {
880  			if (set2->infinite) {
881  				for(i=min_count; i<max_count; i++)
882  					res->ulongs[i] = set1->ulongs[i];
883  			} else {
884  				res->ulongs_count = min_count;
885  			}
886  		} else {
887  			if (set1->infinite) {
888  				for(i=min_count; i<max_count; i++)
889  					res->ulongs[i] = set2->ulongs[i];
890  			} else {
891  				res->ulongs_count = min_count;
892  			}
893  		}
894  	}
895  	res->infinite = set1->infinite && set2->infinite;
896  	return 0;
897  }
898  int hwloc_bitmap_andnot (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
899  {
900  	unsigned count1 = set1->ulongs_count;
901  	unsigned count2 = set2->ulongs_count;
902  	unsigned max_count = count1 > count2 ? count1 : count2;
903  	unsigned min_count = count1 + count2 - max_count;
904  	unsigned i;
905  	HWLOC__BITMAP_CHECK(res);
906  	HWLOC__BITMAP_CHECK(set1);
907  	HWLOC__BITMAP_CHECK(set2);
908  	if (hwloc_bitmap_reset_by_ulongs(res, max_count) < 0)
909  		return -1;
910  	for(i=0; i<min_count; i++)
911  		res->ulongs[i] = set1->ulongs[i] & ~set2->ulongs[i];
912  	if (count1 != count2) {
913  		if (min_count < count1) {
914  			if (!set2->infinite) {
915  				for(i=min_count; i<max_count; i++)
916  					res->ulongs[i] = set1->ulongs[i];
917  			} else {
918  				res->ulongs_count = min_count;
919  			}
920  		} else {
921  			if (set1->infinite) {
922  				for(i=min_count; i<max_count; i++)
923  					res->ulongs[i] = ~set2->ulongs[i];
924  			} else {
925  				res->ulongs_count = min_count;
926  			}
927  		}
928  	}
929  	res->infinite = set1->infinite && !set2->infinite;
930  	return 0;
931  }
932  int hwloc_bitmap_xor (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set1, const struct hwloc_bitmap_s *set2)
933  {
934  	unsigned count1 = set1->ulongs_count;
935  	unsigned count2 = set2->ulongs_count;
936  	unsigned max_count = count1 > count2 ? count1 : count2;
937  	unsigned min_count = count1 + count2 - max_count;
938  	unsigned i;
939  	HWLOC__BITMAP_CHECK(res);
940  	HWLOC__BITMAP_CHECK(set1);
941  	HWLOC__BITMAP_CHECK(set2);
942  	if (hwloc_bitmap_reset_by_ulongs(res, max_count) < 0)
943  		return -1;
944  	for(i=0; i<min_count; i++)
945  		res->ulongs[i] = set1->ulongs[i] ^ set2->ulongs[i];
946  	if (count1 != count2) {
947  		if (min_count < count1) {
948  			unsigned long w2 = set2->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
949  			for(i=min_count; i<max_count; i++)
950  				res->ulongs[i] = set1->ulongs[i] ^ w2;
951  		} else {
952  			unsigned long w1 = set1->infinite ? HWLOC_SUBBITMAP_FULL : HWLOC_SUBBITMAP_ZERO;
953  			for(i=min_count; i<max_count; i++)
954  				res->ulongs[i] = set2->ulongs[i] ^ w1;
955  		}
956  	}
957  	res->infinite = (!set1->infinite) != (!set2->infinite);
958  	return 0;
959  }
960  int hwloc_bitmap_not (struct hwloc_bitmap_s *res, const struct hwloc_bitmap_s *set)
961  {
962  	unsigned count = set->ulongs_count;
963  	unsigned i;
964  	HWLOC__BITMAP_CHECK(res);
965  	HWLOC__BITMAP_CHECK(set);
966  	if (hwloc_bitmap_reset_by_ulongs(res, count) < 0)
967  		return -1;
968  	for(i=0; i<count; i++)
969  		res->ulongs[i] = ~set->ulongs[i];
970  	res->infinite = !set->infinite;
971  	return 0;
972  }
973  int hwloc_bitmap_first(const struct hwloc_bitmap_s * set)
974  {
975  	unsigned i;
976  	HWLOC__BITMAP_CHECK(set);
977  	for(i=0; i<set->ulongs_count; i++) {
978  		unsigned long w = set->ulongs[i];
979  		if (w)
980  			return hwloc_ffsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
981  	}
982  	if (set->infinite)
983  		return set->ulongs_count * HWLOC_BITS_PER_LONG;
984  	return -1;
985  }
986  int hwloc_bitmap_first_unset(const struct hwloc_bitmap_s * set)
987  {
988  	unsigned i;
989  	HWLOC__BITMAP_CHECK(set);
990  	for(i=0; i<set->ulongs_count; i++) {
991  		unsigned long w = ~set->ulongs[i];
992  		if (w)
993  			return hwloc_ffsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
994  	}
995  	if (!set->infinite)
996  		return set->ulongs_count * HWLOC_BITS_PER_LONG;
997  	return -1;
998  }
999  int hwloc_bitmap_last(const struct hwloc_bitmap_s * set)
1000  {
1001  	int i;
1002  	HWLOC__BITMAP_CHECK(set);
1003  	if (set->infinite)
1004  		return -1;
1005  	for(i=(int)set->ulongs_count-1; i>=0; i--) {
1006  		unsigned long w = set->ulongs[i];
1007  		if (w)
1008  			return hwloc_flsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
1009  	}
1010  	return -1;
1011  }
1012  int hwloc_bitmap_last_unset(const struct hwloc_bitmap_s * set)
1013  {
1014  	int i;
1015  	HWLOC__BITMAP_CHECK(set);
1016  	if (!set->infinite)
1017  		return -1;
1018  	for(i=(int)set->ulongs_count-1; i>=0; i--) {
1019  		unsigned long w = ~set->ulongs[i];
1020  		if (w)
1021  			return hwloc_flsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
1022  	}
1023  	return -1;
1024  }
1025  int hwloc_bitmap_next(const struct hwloc_bitmap_s * set, int prev_cpu)
1026  {
1027  	unsigned i = HWLOC_SUBBITMAP_INDEX(prev_cpu + 1);
1028  	HWLOC__BITMAP_CHECK(set);
1029  	if (i >= set->ulongs_count) {
1030  		if (set->infinite)
1031  			return prev_cpu + 1;
1032  		else
1033  			return -1;
1034  	}
1035  	for(; i<set->ulongs_count; i++) {
1036  		unsigned long w = set->ulongs[i];
1037  		if (prev_cpu >= 0 && HWLOC_SUBBITMAP_INDEX((unsigned) prev_cpu) == i)
1038  			w &= ~HWLOC_SUBBITMAP_ULBIT_TO(HWLOC_SUBBITMAP_CPU_ULBIT(prev_cpu));
1039  		if (w)
1040  			return hwloc_ffsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
1041  	}
1042  	if (set->infinite)
1043  		return set->ulongs_count * HWLOC_BITS_PER_LONG;
1044  	return -1;
1045  }
1046  int hwloc_bitmap_next_unset(const struct hwloc_bitmap_s * set, int prev_cpu)
1047  {
1048  	unsigned i = HWLOC_SUBBITMAP_INDEX(prev_cpu + 1);
1049  	HWLOC__BITMAP_CHECK(set);
1050  	if (i >= set->ulongs_count) {
1051  		if (!set->infinite)
1052  			return prev_cpu + 1;
1053  		else
1054  			return -1;
1055  	}
1056  	for(; i<set->ulongs_count; i++) {
1057  		unsigned long w = ~set->ulongs[i];
1058  		if (prev_cpu >= 0 && HWLOC_SUBBITMAP_INDEX((unsigned) prev_cpu) == i)
1059  			w &= ~HWLOC_SUBBITMAP_ULBIT_TO(HWLOC_SUBBITMAP_CPU_ULBIT(prev_cpu));
1060  		if (w)
1061  			return hwloc_ffsl(w) - 1 + HWLOC_BITS_PER_LONG*i;
1062  	}
1063  	if (!set->infinite)
1064  		return set->ulongs_count * HWLOC_BITS_PER_LONG;
1065  	return -1;
1066  }
1067  int hwloc_bitmap_singlify(struct hwloc_bitmap_s * set)
1068  {
1069  	unsigned i;
1070  	int found = 0;
1071  	HWLOC__BITMAP_CHECK(set);
1072  	for(i=0; i<set->ulongs_count; i++) {
1073  		if (found) {
1074  			set->ulongs[i] = HWLOC_SUBBITMAP_ZERO;
1075  			continue;
1076  		} else {
1077  			unsigned long w = set->ulongs[i];
1078  			if (w) {
1079  				int _ffs = hwloc_ffsl(w);
1080  				set->ulongs[i] = HWLOC_SUBBITMAP_CPU(_ffs-1);
1081  				found = 1;
1082  			}
1083  		}
1084  	}
1085  	if (set->infinite) {
1086  		if (found) {
1087  			set->infinite = 0;
1088  		} else {
1089  			unsigned first = set->ulongs_count * HWLOC_BITS_PER_LONG;
1090  			set->infinite = 0; &bsol;* do not let realloc fill the newly allocated sets */
1091  			return hwloc_bitmap_set(set, first);
1092  		}
1093  	}
1094  	return 0;
1095  }
1096  int hwloc_bitmap_compare_first(const struct hwloc_bitmap_s * set1, const struct hwloc_bitmap_s * set2)
1097  {
1098  	unsigned count1 = set1->ulongs_count;
1099  	unsigned count2 = set2->ulongs_count;
1100  	unsigned max_count = count1 > count2 ? count1 : count2;
1101  	unsigned min_count = count1 + count2 - max_count;
1102  	unsigned i;
1103  	HWLOC__BITMAP_CHECK(set1);
1104  	HWLOC__BITMAP_CHECK(set2);
1105  	for(i=0; i<min_count; i++) {
1106  		unsigned long w1 = set1->ulongs[i];
1107  		unsigned long w2 = set2->ulongs[i];
1108  		if (w1 || w2) {
1109  			int _ffs1 = hwloc_ffsl(w1);
1110  			int _ffs2 = hwloc_ffsl(w2);
1111  			if (_ffs1 && _ffs2)
1112  				return _ffs1-_ffs2;
1113  			return _ffs2-_ffs1;
1114  		}
1115  	}
1116  	if (count1 != count2) {
1117  		if (min_count < count2) {
1118  			for(i=min_count; i<count2; i++) {
1119  				unsigned long w2 = set2->ulongs[i];
1120  				if (set1->infinite)
1121  					return -!(w2 & 1);
1122  				else if (w2)
1123  					return 1;
1124  			}
1125  		} else {
1126  			for(i=min_count; i<count1; i++) {
1127  				unsigned long w1 = set1->ulongs[i];
1128  				if (set2->infinite)
1129  					return !(w1 & 1);
1130  				else if (w1)
1131  					return -1;
1132  			}
1133  		}
1134  	}
1135  	return !!set1->infinite - !!set2->infinite;
1136  }
1137  int hwloc_bitmap_compare(const struct hwloc_bitmap_s * set1, const struct hwloc_bitmap_s * set2)
1138  {
1139  	unsigned count1 = set1->ulongs_count;
1140  	unsigned count2 = set2->ulongs_count;
1141  	unsigned max_count = count1 > count2 ? count1 : count2;
1142  	unsigned min_count = count1 + count2 - max_count;
1143  	int i;
1144  	HWLOC__BITMAP_CHECK(set1);
1145  	HWLOC__BITMAP_CHECK(set2);
1146  	if ((!set1->infinite) != (!set2->infinite))
1147  		return !!set1->infinite - !!set2->infinite;
1148  	if (count1 != count2) {
1149  		if (min_count < count2) {
1150  			unsigned long val1 = set1->infinite ? HWLOC_SUBBITMAP_FULL :  HWLOC_SUBBITMAP_ZERO;
1151  			for(i=(int)max_count-1; i>=(int) min_count; i--) {
1152  				unsigned long val2 = set2->ulongs[i];
1153  				if (val1 == val2)
1154  					continue;
1155  				return val1 < val2 ? -1 : 1;
1156  			}
1157  		} else {
1158  			unsigned long val2 = set2->infinite ? HWLOC_SUBBITMAP_FULL :  HWLOC_SUBBITMAP_ZERO;
1159  			for(i=(int)max_count-1; i>=(int) min_count; i--) {
1160  				unsigned long val1 = set1->ulongs[i];
1161  				if (val1 == val2)
1162  					continue;
1163  				return val1 < val2 ? -1 : 1;
1164  			}
1165  		}
1166  	}
1167  	for(i=(int)min_count-1; i>=0; i--) {
1168  		unsigned long val1 = set1->ulongs[i];
1169  		unsigned long val2 = set2->ulongs[i];
1170  		if (val1 == val2)
1171  			continue;
1172  		return val1 < val2 ? -1 : 1;
1173  	}
1174  	return 0;
1175  }
1176  int hwloc_bitmap_weight(const struct hwloc_bitmap_s * set)
1177  {
1178  	int weight = 0;
1179  	unsigned i;
1180  	HWLOC__BITMAP_CHECK(set);
1181  	if (set->infinite)
1182  		return -1;
1183  	for(i=0; i<set->ulongs_count; i++)
1184  		weight += hwloc_weight_long(set->ulongs[i]);
1185  	return weight;
1186  }
1187  int hwloc_bitmap_compare_inclusion(const struct hwloc_bitmap_s * set1, const struct hwloc_bitmap_s * set2)
1188  {
1189  	unsigned max_count = set1->ulongs_count > set2->ulongs_count ? set1->ulongs_count : set2->ulongs_count;
1190  	int result = HWLOC_BITMAP_EQUAL; &bsol;* means empty sets return equal */
1191  	int empty1 = 1;
1192  	int empty2 = 1;
1193  	unsigned i;
1194  	HWLOC__BITMAP_CHECK(set1);
1195  	HWLOC__BITMAP_CHECK(set2);
1196  	for(i=0; i<max_count; i++) {
1197  	  unsigned long val1 = HWLOC_SUBBITMAP_READULONG(set1, (unsigned) i);
1198  	  unsigned long val2 = HWLOC_SUBBITMAP_READULONG(set2, (unsigned) i);
1199  	  if (!val1) {
1200  	    if (!val2)
1201  	      continue;
1202  	    if (result == HWLOC_BITMAP_CONTAINS) {
1203  	      if (!empty2)
1204  		return HWLOC_BITMAP_INTERSECTS;
1205  	      result = HWLOC_BITMAP_DIFFERENT;
1206  	    } else if (result == HWLOC_BITMAP_EQUAL) {
1207  	      result = HWLOC_BITMAP_INCLUDED;
1208  	    }
1209  	  } else if (!val2) {
1210  	    if (result == HWLOC_BITMAP_INCLUDED) {
1211  	      if (!empty1)
1212  		return HWLOC_BITMAP_INTERSECTS;
1213  	      result = HWLOC_BITMAP_DIFFERENT;
1214  	    } else if (result == HWLOC_BITMAP_EQUAL) {
1215  	      result = HWLOC_BITMAP_CONTAINS;
1216  	    }
1217  	  } else if (val1 == val2) {
1218  	    if (result == HWLOC_BITMAP_DIFFERENT)
1219  	      return HWLOC_BITMAP_INTERSECTS;
1220  	  } else if ((val1 & val2) == val1) {
1221  	    if (result == HWLOC_BITMAP_CONTAINS || result == HWLOC_BITMAP_DIFFERENT)
1222  	      return HWLOC_BITMAP_INTERSECTS;
1223  	    result = HWLOC_BITMAP_INCLUDED;
1224  	  } else if ((val1 & val2) == val2) {
1225  	    if (result == HWLOC_BITMAP_INCLUDED || result == HWLOC_BITMAP_DIFFERENT)
1226  	      return HWLOC_BITMAP_INTERSECTS;
1227  	    result = HWLOC_BITMAP_CONTAINS;
1228  	  } else if ((val1 & val2) != 0) {
1229  	    return HWLOC_BITMAP_INTERSECTS;
1230  	  } else {
1231  	    if (result == HWLOC_BITMAP_EQUAL && !empty1 &bsol;* implies !empty2 */)
1232  	      return HWLOC_BITMAP_INTERSECTS;
1233  	    if (result == HWLOC_BITMAP_INCLUDED && !empty1)
1234  	      return HWLOC_BITMAP_INTERSECTS;
1235  	    if (result == HWLOC_BITMAP_CONTAINS && !empty2)
1236  	      return HWLOC_BITMAP_INTERSECTS;
1237  	    result = HWLOC_BITMAP_DIFFERENT;
1238  	  }
1239  	  empty1 &= !val1;
1240  	  empty2 &= !val2;
1241  	}
1242  	if (!set1->infinite) {
1243  	  if (set2->infinite) {
1244  	    if (result == HWLOC_BITMAP_CONTAINS) {
1245  	      if (!empty2)
1246  		return HWLOC_BITMAP_INTERSECTS;
1247  	      result = HWLOC_BITMAP_DIFFERENT;
1248  	    } else if (result == HWLOC_BITMAP_EQUAL) {
1249  	      result = HWLOC_BITMAP_INCLUDED;
1250  	    }
1251  	  }
1252  	} else if (!set2->infinite) {
1253  	  if (result == HWLOC_BITMAP_INCLUDED) {
1254  	    if (!empty1)
1255  	      return HWLOC_BITMAP_INTERSECTS;
1256  	    result = HWLOC_BITMAP_DIFFERENT;
1257  	  } else if (result == HWLOC_BITMAP_EQUAL) {
1258  	    result = HWLOC_BITMAP_CONTAINS;
1259  	  }
1260  	} else {
1261  	  if (result == HWLOC_BITMAP_DIFFERENT)
1262  	    return HWLOC_BITMAP_INTERSECTS;
1263  	}
1264  	return result;
1265  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-sita.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <stdio.h>
5  #include <string.h>
6  #include <stdlib.h>
7  #include <unistd.h>
8  #include <fcntl.h>
9  #include <errno.h>
10  #include <sys/time.h>
11  #include <sys/socket.h>
12  #include <netinet/in.h>
13  #include <arpa/inet.h>
14  #include "pcap-int.h"
15  #include "pcap-sita.h"
16  #define IOP_SNIFFER_PORT	49152			&bsol;* TCP port on the IOP used for 'distributed pcap' usage */
17  #define MAX_LINE_SIZE		255				&bsol;* max size of a buffer/line in /etc/hosts we allow */
18  #define MAX_CHASSIS			8				&bsol;* number of chassis in an ACN site */
19  #define MAX_GEOSLOT			8				&bsol;* max number of access units in an ACN site */
20  #define FIND			0
21  #define LIVE			1
22  typedef struct iface {
23  	struct iface	*next;		&bsol;* a pointer to the next interface */
24  	char		*name;		&bsol;* this interface's name */
25  	char		*IOPname;	&bsol;* this interface's name on an IOP */
26  	uint32_t	iftype;		&bsol;* the type of interface (DLT values) */
27  } iface_t;
28  typedef struct unit {
29  	char			*ip;		&bsol;* this unit's IP address (as extracted from /etc/hosts) */
30  	int			fd;		&bsol;* the connection to this unit (if it exists) */
31  	int			find_fd;	&bsol;* a big kludge to avoid my programming limitations since I could have this unit open for findalldevs purposes */
32  	int			first_time;	&bsol;* 0 = just opened via acn_open_live(),  ie. the first time, NZ = nth time */
33  	struct sockaddr_in	*serv_addr;	&bsol;* the address control block for comms to this unit */
34  	int			chassis;
35  	int			geoslot;
36  	iface_t			*iface;		&bsol;* a pointer to a linked list of interface structures */
37  	char			*imsg;		&bsol;* a pointer to an inbound message */
38  	int			len;		&bsol;* the current size of the inbound message */
39  } unit_t;
40  struct pcap_sita {
41  	int	dummy;
42  };
43  static unit_t		units[MAX_CHASSIS+1][MAX_GEOSLOT+1];	&bsol;* we use indexes of 1 through 8, but we reserve/waste index 0 */
44  static fd_set		readfds;				&bsol;* a place to store the file descriptors for the connections to the IOPs */
45  static int		max_fs;
46  pcap_if_t		*acn_if_list;		&bsol;* pcap's list of available interfaces */
47  static void dump_interface_list(void) {
48  	pcap_if_t		*iff;
49  	pcap_addr_t		*addr;
50  	int			longest_name_len = 0;
51  	char			*n, *d, *f;
52  	int			if_number = 0;
53  	iff = acn_if_list;
54  	while (iff) {
55  		if (iff->name && (strlen(iff->name) > longest_name_len)) longest_name_len = strlen(iff->name);
56  		iff = iff->next;
57  	}
58  	iff = acn_if_list;
59  	printf("Interface List:\n");
60  	while (iff) {
61  		n = (iff->name)							? iff->name			: "";
62  		d = (iff->description)					? iff->description	: "";
63  		f = (iff->flags == PCAP_IF_LOOPBACK)	? "L"				: "";
64  		printf("%3d: %*s %s '%s'\n", if_number++, longest_name_len, n, f, d);
65  		addr = iff->addresses;
66  		while (addr) {
67  			printf("%*s ", (5 + longest_name_len), "");		&bsol;* add some indentation */
68  			printf("%15s  ", (addr->addr)		? inet_ntoa(((struct sockaddr_in *)addr->addr)->sin_addr)		: "");
69  			printf("%15s  ", (addr->netmask)	? inet_ntoa(((struct sockaddr_in *)addr->netmask)->sin_addr)	: "");
70  			printf("%15s  ", (addr->broadaddr)	? inet_ntoa(((struct sockaddr_in *)addr->broadaddr)->sin_addr)	: "");
71  			printf("%15s  ", (addr->dstaddr)	? inet_ntoa(((struct sockaddr_in *)addr->dstaddr)->sin_addr)	: "");
72  			printf("\n");
73  			addr = addr->next;
74  		}
75  		iff = iff->next;
76  	}
77  }
78  static void dump(unsigned char *ptr, int i, int indent) {
79  	fprintf(stderr, "%*s", indent, " ");
80  	for (; i > 0; i--) {
81  		fprintf(stderr, "%2.2x ", *ptr++);
82  	}
83  	fprintf(stderr, "\n");
84  }
85  static void dump_interface_list_p(void) {
86  	pcap_if_t		*iff;
87  	pcap_addr_t		*addr;
88  	int				if_number = 0;
89  	iff = acn_if_list;
90  	printf("Interface Pointer @ %p is %p:\n", &acn_if_list, iff);
91  	while (iff) {
92  		printf("%3d: %p %p next: %p\n", if_number++, iff->name, iff->description, iff->next);
93  		dump((unsigned char *)iff, sizeof(pcap_if_t), 5);
94  		addr = iff->addresses;
95  		while (addr) {
96  			printf("          %p %p %p %p, next: %p\n", addr->addr, addr->netmask, addr->broadaddr, addr->dstaddr, addr->next);
97  			dump((unsigned char *)addr, sizeof(pcap_addr_t), 10);
98  			addr = addr->next;
99  		}
100  		iff = iff->next;
101  	}
102  }
103  static void dump_unit_table(void) {
104  	int		chassis, geoslot;
105  	iface_t	*p;
106  	printf("%c:%c %s %s\n", 'C', 'S', "fd", "IP Address");
107  	for (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {
108  		for (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {
109  			if (units[chassis][geoslot].ip != NULL)
110  				printf("%d:%d %2d %s\n", chassis, geoslot, units[chassis][geoslot].fd, units[chassis][geoslot].ip);
111  			p = units[chassis][geoslot].iface;
112  			while (p) {
113  				char *n = (p->name)			? p->name			: "";
114  				char *i = (p->IOPname)		? p->IOPname		: "";
115  				p = p->next;
116  				printf("   %12s    -> %12s\n", i, n);
117  			}
118  		}
119  	}
120  }
121  static int find_unit_by_fd(int fd, int *chassis, int *geoslot, unit_t **unit_ptr) {
122  	int		c, s;
123  	for (c = 0; c <= MAX_CHASSIS; c++) {
124  		for (s = 0; s <= MAX_GEOSLOT; s++) {
125  			if (units[c][s].fd == fd || units[c][s].find_fd == fd) {
126  				if (chassis)	*chassis = c;
127  				if (geoslot)	*geoslot = s;
128  				if (unit_ptr)	*unit_ptr = &units[c][s];
129  				return 1;
130  			}
131  		}
132  	}
133  	return 0;
134  }
135  static int read_client_nbytes(int fd, int count, unsigned char *buf) {
136  	unit_t			*u;
137  	int				chassis, geoslot;
138  	int				len;
139  	find_unit_by_fd(fd, &chassis, &geoslot, &u);
140  	while (count) {
141  		if ((len = recv(fd, buf, count, 0)) <= 0)	return -1;	&bsol;* read in whatever data was sent to us */
142  		count -= len;
143  		buf += len;
144  	}															&bsol;* till we have everything we are looking for */
145  	return 0;
146  }
147  static void empty_unit_iface(unit_t *u) {
148  	iface_t	*p, *cur;
149  	cur = u->iface;
150  	while (cur) {											&bsol;* loop over all the interface entries */
151  		if (cur->name)			free(cur->name);			&bsol;* throwing away the contents if they exist */
152  		if (cur->IOPname)		free(cur->IOPname);
153  		p = cur->next;
154  		free(cur);											&bsol;* then throw away the structure itself */
155  		cur = p;
156  	}
157  	u->iface = 0;											&bsol;* and finally remember that there are no remaining structure */
158  }
159  static void empty_unit(int chassis, int geoslot) {
160  	unit_t	*u = &units[chassis][geoslot];
161  	empty_unit_iface(u);
162  	if (u->imsg) {											&bsol;* then if an inbound message buffer exists */
163  		void *bigger_buffer;
164  		bigger_buffer = (char *)realloc(u->imsg, 1);				&bsol;* and re-allocate the old large buffer into a new small one */
165  		if (bigger_buffer == NULL) {	&bsol;* oops, realloc call failed */
166  			fprintf(stderr, "Warning...call to realloc() failed, value of errno is %d\n", errno);
167  			return;
168  		}
169  		u->imsg = bigger_buffer;
170  	}
171  }
172  static void empty_unit_table(void) {
173  	int		chassis, geoslot;
174  	for (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {
175  		for (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {
176  			if (units[chassis][geoslot].ip != NULL) {
177  				free(units[chassis][geoslot].ip);			&bsol;* get rid of the malloc'ed space that holds the IP address */
178  				units[chassis][geoslot].ip = 0;				&bsol;* then set the pointer to NULL */
179  			}
180  			empty_unit(chassis, geoslot);
181  		}
182  	}
183  }
184  static char *find_nth_interface_name(int n) {
185  	int		chassis, geoslot;
186  	iface_t	*p;
187  	char	*last_name = 0;
188  	if (n < 0) n = 0;												&bsol;* ensure we are working with a valid number */
189  	for (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {			&bsol;* scan the table... */
190  		for (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {
191  			if (units[chassis][geoslot].ip != NULL) {
192  				p = units[chassis][geoslot].iface;
193  				while (p) {											&bsol;* and all interfaces... */
194  					if (p->IOPname) last_name = p->name;			&bsol;* remembering the last name found */
195  					if (n-- == 0) return last_name;					&bsol;* and if we hit the instance requested */
196  					p = p->next;
197  				}
198  			}
199  		}
200  	}
201  	if (last_name)	return last_name;		&bsol;* ... but we did have at least one entry... return the last entry found */
202  	return "";								&bsol;* ... but if there wasn't any entry... return an empty string instead */
203  }
204  int acn_parse_hosts_file(char *errbuf) {				&bsol;* returns: -1 = error, 0 = OK */
205  	FILE	*fp;
206  	char	buf[MAX_LINE_SIZE];
207  	char	*ptr, *ptr2;
208  	int		pos;
209  	int		chassis, geoslot;
210  	unit_t	*u;
211  	empty_unit_table();
212  	if ((fp = fopen("/etc/hosts", "r")) == NULL) {										&bsol;* try to open the hosts file and if it fails */
213  		snprintf(errbuf, PCAP_ERRBUF_SIZE, "Cannot open '/etc/hosts' for reading.");	&bsol;* return the nohostsfile error response */
214  		return -1;
215  	}
216  	while (fgets(buf, MAX_LINE_SIZE-1, fp)) {			&bsol;* while looping over the file */
217  		pos = strcspn(buf, "#\n\r");					&bsol;* find the first comment character or EOL */
218  		*(buf + pos) = '\0';							&bsol;* and clobber it and anything that follows it */
219  		pos = strspn(buf, " \t");						&bsol;* then find the first non-white space */
220  		if (pos == strlen(buf))							&bsol;* if there is nothing but white space on the line */
221  			continue;									&bsol;* ignore that empty line */
222  		ptr = buf + pos;								&bsol;* and skip over any of that leading whitespace */
223  		if ((ptr2 = strstr(ptr, "_I_")) == NULL)		&bsol;* skip any lines that don't have names that look like they belong to IOPs */
224  			continue;
225  		if (*(ptr2 + 4) != '_')							&bsol;* and skip other lines that have names that don't look like ACN components */
226  			continue;
227  		*(ptr + strcspn(ptr, " \t")) = '\0';			&bsol;* null terminate the IP address so its a standalone string */
228  		chassis = *(ptr2 + 3) - '0';					&bsol;* extract the chassis number */
229  		geoslot = *(ptr2 + 5) - '0';					&bsol;* and geo-slot number */
230  		if (chassis < 1 || chassis > MAX_CHASSIS ||
231  			geoslot < 1 || geoslot > MAX_GEOSLOT) {		&bsol;* if the chassis and/or slot numbers appear to be bad... */
232  			snprintf(errbuf, PCAP_ERRBUF_SIZE, "Invalid ACN name in '/etc/hosts'.");	&bsol;* warn the user */
233  			continue;																	&bsol;* and ignore the entry */
234  		}
235  		ptr2 = strdup(ptr);					&bsol;* copy the IP address into our malloc'ed memory */
236  		if (ptr2 == NULL) {
237  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
238  			    errno, "malloc");
239  			continue;
240  		}
241  		u = &units[chassis][geoslot];
242  		u->ip = ptr2;									&bsol;* and remember the whole shebang */
243  		u->chassis = chassis;
244  		u->geoslot = geoslot;
245  	}
246  	fclose(fp);
247  	if (*errbuf)	return -1;
248  	else			return 0;
249  }
250  static int open_with_IOP(unit_t  *u, int flag) {
251  	int					sockfd;
252  	char				*ip;
253  	if (u->serv_addr == NULL) {
254  		u->serv_addr = malloc(sizeof(struct sockaddr_in));
255  		if (u->serv_addr == NULL) {	&bsol;* oops, we didn't get the memory requested	*/
256  			fprintf(stderr, "malloc() request for u->serv_addr failed, value of errno is: %d\n", errno);
257  			return 0;
258  		}
259  	}
260  	ip = u->ip;
261  	memset((char *)u->serv_addr, 0, sizeof(struct sockaddr_in));
262  	u->serv_addr->sin_family		= AF_INET;
263  	u->serv_addr->sin_addr.s_addr	= inet_addr(ip);
264  	u->serv_addr->sin_port			= htons(IOP_SNIFFER_PORT);
265  	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
266  		fprintf(stderr, "pcap can't open a socket for connecting to IOP at %s\n", ip);
267  		return 0;
268  	}
269  	if (connect(sockfd, (struct sockaddr *)u->serv_addr, sizeof(struct sockaddr_in)) < 0) {
270  		fprintf(stderr, "pcap can't connect to IOP at %s\n", ip);
271  		return 0;
272  	}
273  	if (flag == LIVE)	u->fd = sockfd;
274  	else				u->find_fd = sockfd;
275  	u->first_time = 0;
276  	return sockfd;			&bsol;* return the non-zero file descriptor as a 'success' indicator */
277  }
278  static void close_with_IOP(int chassis, int geoslot, int flag) {
279  	int		*id;
280  	if (flag == LIVE)	id = &units[chassis][geoslot].fd;
281  	else				id = &units[chassis][geoslot].find_fd;
282  	if (*id) {										&bsol;* this was the last time, so... if we are connected... */
283  		close(*id);									&bsol;* disconnect us */
284  		*id = 0;									&bsol;* and forget that the descriptor exists because we are not open */
285  	}
286  }
287  static void pcap_cleanup_acn(pcap_t *handle) {
288  	int		chassis, geoslot;
289  	unit_t	*u;
290  	if (find_unit_by_fd(handle->fd, &chassis, &geoslot, &u) == 0)
291  		return;
292  	close_with_IOP(chassis, geoslot, LIVE);
293  	if (u)
294  		u->first_time = 0;
295  	pcap_cleanup_live_common(handle);
296  }
297  static void send_to_fd(int fd, int len, unsigned char *str) {
298  	int		nwritten;
299  	int		chassis, geoslot;
300  	while (len > 0) {
301  		if ((nwritten = write(fd, str, len)) <= 0) {
302  			find_unit_by_fd(fd, &chassis, &geoslot, NULL);
303  			if (units[chassis][geoslot].fd == fd)			close_with_IOP(chassis, geoslot, LIVE);
304  			else if (units[chassis][geoslot].find_fd == fd)	close_with_IOP(chassis, geoslot, FIND);
305  			empty_unit(chassis, geoslot);
306  			return;
307  		}
308  		len -= nwritten;
309  		str += nwritten;
310  	}
311  }
312  static void acn_freealldevs(void) {
313  	pcap_if_t	*iff, *next_iff;
314  	pcap_addr_t	*addr, *next_addr;
315  	for (iff = acn_if_list; iff != NULL; iff = next_iff) {
316  		next_iff = iff->next;
317  		for (addr = iff->addresses; addr != NULL; addr = next_addr) {
318  			next_addr = addr->next;
319  			if (addr->addr)			free(addr->addr);
320  			if (addr->netmask)		free(addr->netmask);
321  			if (addr->broadaddr)	free(addr->broadaddr);
322  			if (addr->dstaddr)		free(addr->dstaddr);
323  			free(addr);
324  		}
325  		if (iff->name)			free(iff->name);
326  		if (iff->description)	free(iff->description);
327  		free(iff);
328  	}
329  }
330  static void nonUnified_IOP_port_name(char *buf, size_t bufsize, const char *proto, unit_t *u) {
331  	snprintf(buf, bufsize, "%s_%d_%d", proto, u->chassis, u->geoslot);
332  }
333  static void unified_IOP_port_name(char *buf, size_t bufsize, const char *proto, unit_t *u, int IOPportnum) {
334  	int			portnum;
335  	portnum = ((u->chassis - 1) * 64) + ((u->geoslot - 1) * 8) + IOPportnum + 1;
336  	snprintf(buf, bufsize, "%s_%d", proto, portnum);
337  }
338  static char *translate_IOP_to_pcap_name(unit_t *u, char *IOPname, bpf_u_int32 iftype) {
339  	iface_t		*iface_ptr, *iface;
340  	char		buf[32];
341  	char		*proto;
342  	char		*port;
343  	int			IOPportnum = 0;
344  	iface = malloc(sizeof(iface_t));		&bsol;* get memory for a structure */
345  	if (iface == NULL) {	&bsol;* oops, we didn't get the memory requested	*/
346  		fprintf(stderr, "Error...couldn't allocate memory for interface structure...value of errno is: %d\n", errno);
347  		return NULL;
348  	}
349  	memset((char *)iface, 0, sizeof(iface_t));	&bsol;* bzero is deprecated(), replaced with memset() */
350  	iface->iftype = iftype;					&bsol;* remember the interface type of this interface */
351  	iface->IOPname = strdup(IOPname);			&bsol;* copy it and stick it into the structure */
352          if (iface->IOPname == NULL) {    &bsol;* oops, we didn't get the memory requested     */
353                  fprintf(stderr, "Error...couldn't allocate memory for IOPname...value of errno is: %d\n", errno);
354                  return NULL;
355          }
356  	if (strncmp(IOPname, "lo", 2) == 0) {
357  		IOPportnum = atoi(&IOPname[2]);
358  		switch (iftype) {
359  			case DLT_EN10MB:
360  				nonUnified_IOP_port_name(buf, sizeof buf, "lo", u);
361  				break;
362  			default:
363  				unified_IOP_port_name(buf, sizeof buf, "???", u, IOPportnum);
364  				break;
365  		}
366  	} else if (strncmp(IOPname, "eth", 3) == 0) {
367  		IOPportnum = atoi(&IOPname[3]);
368  		switch (iftype) {
369  			case DLT_EN10MB:
370  				nonUnified_IOP_port_name(buf, sizeof buf, "eth", u);
371  				break;
372  			default:
373  				unified_IOP_port_name(buf, sizeof buf, "???", u, IOPportnum);
374  				break;
375  		}
376  	} else if (strncmp(IOPname, "wan", 3) == 0) {
377  		IOPportnum = atoi(&IOPname[3]);
378  		switch (iftype) {
379  			case DLT_SITA:
380  				unified_IOP_port_name(buf, sizeof buf, "wan", u, IOPportnum);
381  				break;
382  			default:
383  				unified_IOP_port_name(buf, sizeof buf, "???", u, IOPportnum);
384  				break;
385  		}
386  	} else {
387  		fprintf(stderr, "Error... invalid IOP name %s\n", IOPname);
388  		return NULL;
389  	}
390  	iface->name = strdup(buf);					&bsol;* make a copy and stick it into the structure */
391          if (iface->name == NULL) {    &bsol;* oops, we didn't get the memory requested     */
392                  fprintf(stderr, "Error...couldn't allocate memory for IOP port name...value of errno is: %d\n", errno);
393                  return NULL;
394          }
395  	if (u->iface == 0) {					&bsol;* if this is the first name */
396  		u->iface = iface;					&bsol;* stick this entry at the head of the list */
397  	} else {
398  		iface_ptr = u->iface;
399  		while (iface_ptr->next) {			&bsol;* otherwise scan the list */
400  			iface_ptr = iface_ptr->next;	&bsol;* till we're at the last entry */
401  		}
402  		iface_ptr->next = iface;			&bsol;* then tack this entry on the end of the list */
403  	}
404  	return iface->name;
405  }
406  static int if_sort(char *s1, char *s2) {
407  	char	*s1_p2, *s2_p2;
408  	char	str1[MAX_LINE_SIZE], str2[MAX_LINE_SIZE];
409  	int		s1_p1_len, s2_p1_len;
410  	int		retval;
411  	if ((s1_p2 = strchr(s1, '_'))) {	&bsol;* if an underscore is found... */
412  		s1_p1_len = s1_p2 - s1;			&bsol;* the prefix length is the difference in pointers */
413  		s1_p2++;						&bsol;* the suffix actually starts _after_ the underscore */
414  	} else {							&bsol;* otherwise... */
415  		s1_p1_len = strlen(s1);			&bsol;* the prefix length is the length of the string itself */
416  		s1_p2 = 0;						&bsol;* and there is no suffix */
417  	}
418  	if ((s2_p2 = strchr(s2, '_'))) {	&bsol;* now do the same for the second string */
419  		s2_p1_len = s2_p2 - s2;
420  		s2_p2++;
421  	} else {
422  		s2_p1_len = strlen(s2);
423  		s2_p2 = 0;
424  	}
425  	strncpy(str1, s1, (s1_p1_len > sizeof(str1)) ? s1_p1_len : sizeof(str1));   *(str1 + s1_p1_len) = 0;
426  	strncpy(str2, s2, (s2_p1_len > sizeof(str2)) ? s2_p1_len : sizeof(str2));   *(str2 + s2_p1_len) = 0;
427  	retval = strcmp(str1, str2);
428  	if (retval != 0) return retval;		&bsol;* if they are not identical, then we can quit now and return the indication */
429  	return strcmp(s1_p2, s2_p2);		&bsol;* otherwise we return the result of comparing the 2nd half of the string */
430  }
431  static void sort_if_table(void) {
432  	pcap_if_t	*p1, *p2, *prev, *temp;
433  	int			has_swapped;
434  	if (!acn_if_list) return;				&bsol;* nothing to do if the list is empty */
435  	while (1) {
436  		p1 = acn_if_list;					&bsol;* start at the head of the list */
437  		prev = 0;
438  		has_swapped = 0;
439  		while ((p2 = p1->next)) {
440  			if (if_sort(p1->name, p2->name) > 0) {
441  				if (prev) {					&bsol;* we are swapping things that are _not_ at the head of the list */
442  					temp = p2->next;
443  					prev->next = p2;
444  					p2->next = p1;
445  					p1->next = temp;
446  				} else {					&bsol;* special treatment if we are swapping with the head of the list */
447  					temp = p2->next;
448  					acn_if_list= p2;
449  					p2->next = p1;
450  					p1->next = temp;
451  				}
452  				p1 = p2;
453  				prev = p1;
454  				has_swapped = 1;
455  			}
456  			prev = p1;
457  			p1 = p1->next;
458  		}
459  		if (has_swapped == 0)
460  			return;
461  	}
462  	return;
463  }
464  static int process_client_data (char *errbuf) {								&bsol;* returns: -1 = error, 0 = OK */
465  	int					chassis, geoslot;
466  	unit_t				*u;
467  	pcap_if_t			*iff, *prev_iff;
468  	pcap_addr_t			*addr, *prev_addr;
469  	char				*ptr;
470  	int					address_count;
471  	struct sockaddr_in	*s;
472  	char				*newname;
473  	bpf_u_int32				interfaceType;
474  	unsigned char		flags;
475  	void *bigger_buffer;
476  	prev_iff = 0;
477  	for (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {
478  		for (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {				&bsol;* now loop over all the devices */
479  			u = &units[chassis][geoslot];
480  			empty_unit_iface(u);
481  			ptr = u->imsg;													&bsol;* point to the start of the msg for this IOP */
482  			while (ptr < (u->imsg + u->len)) {
483  				if ((iff = malloc(sizeof(pcap_if_t))) == NULL) {
484  					pcap_fmt_errmsg_for_errno(errbuf,
485  					    PCAP_ERRBUF_SIZE, errno, "malloc");
486  					return -1;
487  				}
488  				memset((char *)iff, 0, sizeof(pcap_if_t)); &bsol;* bzero() is deprecated, replaced with memset() */
489  				if (acn_if_list == 0)	acn_if_list = iff;					&bsol;* remember the head of the list */
490  				if (prev_iff)			prev_iff->next = iff;				&bsol;* insert a forward link */
491  				if (*ptr) {													&bsol;* if there is a count for the name */
492  					if ((iff->name = malloc(*ptr + 1)) == NULL) {			&bsol;* get that amount of space */
493  						pcap_fmt_errmsg_for_errno(errbuf,
494  						    PCAP_ERRBUF_SIZE, errno,
495  						    "malloc");
496  						return -1;
497  					}
498  					memcpy(iff->name, (ptr + 1), *ptr);						&bsol;* copy the name into the malloc'ed space */
499  					*(iff->name + *ptr) = 0;								&bsol;* and null terminate the string */
500  					ptr += *ptr;											&bsol;* now move the pointer forwards by the length of the count plus the length of the string */
501  				}
502  				ptr++;
503  				if (*ptr) {													&bsol;* if there is a count for the description */
504  					if ((iff->description = malloc(*ptr + 1)) == NULL) {	&bsol;* get that amount of space */
505  						pcap_fmt_errmsg_for_errno(errbuf,
506  						    PCAP_ERRBUF_SIZE, errno,
507  						    "malloc");
508  						return -1;
509  					}
510  					memcpy(iff->description, (ptr + 1), *ptr);				&bsol;* copy the name into the malloc'ed space */
511  					*(iff->description + *ptr) = 0;							&bsol;* and null terminate the string */
512  					ptr += *ptr;											&bsol;* now move the pointer forwards by the length of the count plus the length of the string */
513  				}
514  				ptr++;
515  				interfaceType = ntohl(*(bpf_u_int32 *)ptr);
516  				ptr += 4;													&bsol;* skip over the interface type */
517  				flags = *ptr++;
518  				if (flags) iff->flags = PCAP_IF_LOOPBACK;					&bsol;* if this is a loopback style interface, lets mark it as such */
519  				address_count = *ptr++;
520  				prev_addr = 0;
521  				while (address_count--) {
522  					if ((addr = malloc(sizeof(pcap_addr_t))) == NULL) {
523  						pcap_fmt_errmsg_for_errno(errbuf,
524  						    PCAP_ERRBUF_SIZE, errno,
525  						    "malloc");
526  						return -1;
527  					}
528  					memset((char *)addr, 0, sizeof(pcap_addr_t)); &bsol;* bzero() is deprecated, replaced with memset() */
529  					if (iff->addresses == 0) iff->addresses = addr;
530  					if (prev_addr) prev_addr->next = addr;							&bsol;* insert a forward link */
531  					if (*ptr) {														&bsol;* if there is a count for the address */
532  						if ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {		&bsol;* get that amount of space */
533  							pcap_fmt_errmsg_for_errno(errbuf,
534  							    PCAP_ERRBUF_SIZE,
535  							    errno, "malloc");
536  							return -1;
537  						}
538  						memset((char *)s, 0, sizeof(struct sockaddr_in)); &bsol;* bzero() is deprecated, replaced with memset() */
539  						addr->addr = (struct sockaddr *)s;
540  						s->sin_family		= AF_INET;
541  						s->sin_addr.s_addr	= *(bpf_u_int32 *)(ptr + 1);			&bsol;* copy the address in */
542  						ptr += *ptr;										&bsol;* now move the pointer forwards according to the specified length of the address */
543  					}
544  					ptr++;													&bsol;* then forwards one more for the 'length of the address' field */
545  					if (*ptr) {												&bsol;* process any netmask */
546  						if ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {
547  							pcap_fmt_errmsg_for_errno(errbuf,
548  							    PCAP_ERRBUF_SIZE,
549  							    errno, "malloc");
550  							return -1;
551  						}
552  						memset((char *)s, 0, sizeof(struct sockaddr_in));
553  						addr->netmask = (struct sockaddr *)s;
554  						s->sin_family		= AF_INET;
555  						s->sin_addr.s_addr	= *(bpf_u_int32*)(ptr + 1);
556  						ptr += *ptr;
557  					}
558  					ptr++;
559  					if (*ptr) {												&bsol;* process any broadcast address */
560  						if ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {
561  							pcap_fmt_errmsg_for_errno(errbuf,
562  							    PCAP_ERRBUF_SIZE,
563  							    errno, "malloc");
564  							return -1;
565  						}
566  						memset((char *)s, 0, sizeof(struct sockaddr_in));
567  						addr->broadaddr = (struct sockaddr *)s;
568  						s->sin_family		= AF_INET;
569  						s->sin_addr.s_addr	= *(bpf_u_int32*)(ptr + 1);
570  						ptr += *ptr;
571  					}
572  					ptr++;
573  					if (*ptr) {												&bsol;* process any destination address */
574  						if ((s = malloc(sizeof(struct sockaddr_in))) == NULL) {
575  							pcap_fmt_errmsg_for_errno(errbuf,
576  							    PCAP_ERRBUF_SIZE,
577  							    errno, "malloc");
578  							return -1;
579  						}
580  						memset((char *)s, 0, sizeof(struct sockaddr_in));
581  						addr->dstaddr = (struct sockaddr *)s;
582  						s->sin_family		= AF_INET;
583  						s->sin_addr.s_addr	= *(bpf_u_int32*)(ptr + 1);
584  						ptr += *ptr;
585  					}
586  					ptr++;
587  					prev_addr = addr;
588  				}
589  				prev_iff = iff;
590  				newname = translate_IOP_to_pcap_name(u, iff->name, interfaceType);		&bsol;* add a translation entry and get a point to the mangled name */
591  				bigger_buffer = realloc(iff->name, strlen(newname) + 1);
592  				if (bigger_buffer == NULL) {	&bsol;* we now re-write the name stored in the interface list */
593  					pcap_fmt_errmsg_for_errno(errbuf,
594  					    PCAP_ERRBUF_SIZE, errno, "realloc");
595  					return -1;
596  				}
597  				iff->name = bigger_buffer;
598  				strcpy(iff->name, newname);												&bsol;* to this new name */
599  			}
600  		}
601  	}
602  	return 0;
603  }
604  static int read_client_data (int fd) {
605  	unsigned char	buf[256];
606  	int				chassis, geoslot;
607  	unit_t			*u;
608  	int				len;
609  	find_unit_by_fd(fd, &chassis, &geoslot, &u);
610  	if ((len = recv(fd, buf, sizeof(buf), 0)) <= 0)	return 0;	&bsol;* read in whatever data was sent to us */
611  	if ((u->imsg = realloc(u->imsg, (u->len + len))) == NULL)	&bsol;* extend the buffer for the new data */
612  		return 0;
613  	memcpy((u->imsg + u->len), buf, len);						&bsol;* append the new data */
614  	u->len += len;
615  	return 1;
616  }
617  static void wait_for_all_answers(void) {
618  	int		retval;
619  	struct	timeval tv;
620  	int		fd;
621  	int		chassis, geoslot;
622  	tv.tv_sec = 2;
623  	tv.tv_usec = 0;
624  	while (1) {
625  		int flag = 0;
626  		fd_set working_set;
627  		for (fd = 0; fd <= max_fs; fd++) {								&bsol;* scan the list of descriptors we may be listening to */
628  			if (FD_ISSET(fd, &readfds)) flag = 1;						&bsol;* and see if there are any still set */
629  		}
630  		if (flag == 0) return;											&bsol;* we are done, when they are all gone */
631  		memcpy(&working_set, &readfds, sizeof(readfds));				&bsol;* otherwise, we still have to listen for more stuff, till we timeout */
632  		retval = select(max_fs + 1, &working_set, NULL, NULL, &tv);
633  		if (retval == -1) {												&bsol;* an error occurred !!!!! */
634  			return;
635  		} else if (retval == 0) {										&bsol;* timeout occurred, so process what we've got sofar and return */
636  			printf("timeout\n");
637  			return;
638  		} else {
639  			for (fd = 0; fd <= max_fs; fd++) {							&bsol;* scan the list of things to do, and do them */
640  				if (FD_ISSET(fd, &working_set)) {
641  					if (read_client_data(fd) == 0) {					&bsol;* if the socket has closed */
642  						FD_CLR(fd, &readfds);							&bsol;* and descriptors we listen to for errors */
643  						find_unit_by_fd(fd, &chassis, &geoslot, NULL);
644  						close_with_IOP(chassis, geoslot, FIND);			&bsol;* and close out connection to him */
645  					}
646  				}
647  			}
648  		}
649  	}
650  }
651  static char *get_error_response(int fd, char *errbuf) {		&bsol;* return a pointer on error, NULL on no error */
652  	char	byte;
653  	int		len = 0;
654  	while (1) {
655  		recv(fd, &byte, 1, 0);							&bsol;* read another byte in */
656  		if (errbuf && (len++ < PCAP_ERRBUF_SIZE)) {		&bsol;* and if there is still room in the buffer */
657  			*errbuf++ = byte;							&bsol;* stick it in */
658  			*errbuf = '\0';								&bsol;* ensure the string is null terminated just in case we might exceed the buffer's size */
659  		}
660  		if (byte == '\0') {
661  			if (len > 1)	{ return errbuf;	}
662  			else			{ return NULL;		}
663  		}
664  	}
665  }
666  int acn_findalldevs(char *errbuf) {								&bsol;* returns: -1 = error, 0 = OK */
667  	int		chassis, geoslot;
668  	unit_t	*u;
669  	FD_ZERO(&readfds);
670  	max_fs = 0;
671  	for (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {
672  		for (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {
673  			u = &units[chassis][geoslot];
674  			if (u->ip && (open_with_IOP(u, FIND))) {			&bsol;* connect to the remote IOP */
675  				send_to_fd(u->find_fd, 1, (unsigned char *)"\0");
676  				if (get_error_response(u->find_fd, errbuf))
677  					close_with_IOP(chassis, geoslot, FIND);
678  				else {
679  					if (u->find_fd > max_fs)
680  						max_fs = u->find_fd;								&bsol;* remember the highest number currently in use */
681  					FD_SET(u->find_fd, &readfds);						&bsol;* we are going to want to read this guy's response to */
682  					u->len = 0;
683  					send_to_fd(u->find_fd, 1, (unsigned char *)"Q");		&bsol;* this interface query request */
684  				}
685  			}
686  		}
687  	}
688  	wait_for_all_answers();
689  	if (process_client_data(errbuf))
690  		return -1;
691  	sort_if_table();
692  	return 0;
693  }
694  static int pcap_stats_acn(pcap_t *handle, struct pcap_stat *ps) {
695  	unsigned char	buf[12];
696  	send_to_fd(handle->fd, 1, (unsigned char *)"S");						&bsol;* send the get_stats command to the IOP */
697  	if (read_client_nbytes(handle->fd, sizeof(buf), buf) == -1) return -1;	&bsol;* try reading the required bytes */
698  	ps->ps_recv		= ntohl(*(uint32_t *)&buf[0]);							&bsol;* break the buffer into its three 32 bit components */
699  	ps->ps_drop		= ntohl(*(uint32_t *)&buf[4]);
700  	ps->ps_ifdrop	= ntohl(*(uint32_t *)&buf[8]);
701  	return 0;
702  }
703  static int acn_open_live(const char *name, char *errbuf, int *linktype) {		&bsol;* returns 0 on error, else returns the file descriptor */
704  	int			chassis, geoslot;
705  	unit_t		*u;
706  	iface_t		*p;
707  	pcap_if_list_t	devlist;
708  	pcap_platform_finddevs(&devlist, errbuf);
709  	for (chassis = 0; chassis <= MAX_CHASSIS; chassis++) {										&bsol;* scan the table... */
710  		for (geoslot = 0; geoslot <= MAX_GEOSLOT; geoslot++) {
711  			u = &units[chassis][geoslot];
712  			if (u->ip != NULL) {
713  				p = u->iface;
714  				while (p) {																		&bsol;* and all interfaces... */
715  					if (p->IOPname && p->name && (strcmp(p->name, name) == 0)) {				&bsol;* and if we found the interface we want... */
716  						*linktype = p->iftype;
717  						open_with_IOP(u, LIVE);													&bsol;* start a connection with that IOP */
718  						send_to_fd(u->fd, strlen(p->IOPname)+1, (unsigned char *)p->IOPname);	&bsol;* send the IOP's interface name, and a terminating null */
719  						if (get_error_response(u->fd, errbuf)) {
720  							return -1;
721  						}
722  						return u->fd;															&bsol;* and return that open descriptor */
723  					}
724  					p = p->next;
725  				}
726  			}
727  		}
728  	}
729  	return -1;																				&bsol;* if the interface wasn't found, return an error */
730  }
731  static void acn_start_monitor(int fd, int snaplen, int timeout, int promiscuous, int direction) {
732  	unsigned char	buf[8];
733  	unit_t			*u;
734  	find_unit_by_fd(fd, NULL, NULL, &u);
735  	if (u->first_time == 0) {
736  		buf[0]					= 'M';
737  		*(uint32_t *)&buf[1]	= htonl(snaplen);
738  		buf[5]					= timeout;
739  		buf[6]					= promiscuous;
740  		buf[7]					= direction;
741  		send_to_fd(fd, 8, buf);								&bsol;* send the start monitor command with its parameters to the IOP */
742  		u->first_time = 1;
743  	}
744  }
745  static int pcap_inject_acn(pcap_t *p, const void *buf _U_, int size _U_) {
746  	pcap_strlcpy(p->errbuf, "Sending packets isn't supported on ACN adapters",
747  	    PCAP_ERRBUF_SIZE);
748  	return (-1);
749  }
750  static int pcap_setfilter_acn(pcap_t *handle, struct bpf_program *bpf) {
751  	int				fd = handle->fd;
752  	int				count;
753  	struct bpf_insn	*p;
754  	uint16_t		shortInt;
755  	uint32_t		longInt;
756  	send_to_fd(fd, 1, (unsigned char *)"F");			&bsol;* BPF filter follows command */
757  	count = bpf->bf_len;
758  	longInt = htonl(count);
759  	send_to_fd(fd, 4, (unsigned char *)&longInt);		&bsol;* send the instruction sequence count */
760  	p = bpf->bf_insns;
761  	while (count--) {									&bsol;* followed by the list of instructions */
762  		shortInt = htons(p->code);
763  		longInt = htonl(p->k);
764  		send_to_fd(fd, 2, (unsigned char *)&shortInt);
765  		send_to_fd(fd, 1, (unsigned char *)&p->jt);
766  		send_to_fd(fd, 1, (unsigned char *)&p->jf);
767  		send_to_fd(fd, 4, (unsigned char *)&longInt);
768  		p++;
769  	}
770  	if (get_error_response(fd, NULL))
771  		return -1;
772  	return 0;
773  }
774  static int acn_read_n_bytes_with_timeout(pcap_t *handle, int count) {
775  	struct		timeval tv;
776  	int			retval, fd;
777  	fd_set		r_fds;
778  	fd_set		w_fds;
779  	u_char		*bp;
780  	int			len = 0;
781  	int			offset = 0;
782  	tv.tv_sec = 5;
783  	tv.tv_usec = 0;
784  	fd = handle->fd;
785  	FD_ZERO(&r_fds);
786  	FD_SET(fd, &r_fds);
787  	memcpy(&w_fds, &r_fds, sizeof(r_fds));
788  	bp = handle->bp;
789  	while (count) {
790  		retval = select(fd + 1, &w_fds, NULL, NULL, &tv);
791  		if (retval == -1) {											&bsol;* an error occurred !!!!! */
792  			return -1;										&bsol;* but we need to return a good indication to prevent unnecessary popups */
793  		} else if (retval == 0) {									&bsol;* timeout occurred, so process what we've got sofar and return */
794  			return -1;
795  		} else {
796  			if ((len = recv(fd, (bp + offset), count, 0)) <= 0) {
797  				return -1;
798  			}
799  			count -= len;
800  			offset += len;
801  		}
802  	}
803  	return 0;
804  }
805  static int pcap_read_acn(pcap_t *handle, int max_packets, pcap_handler callback, u_char *user) {
806  	#define HEADER_SIZE (4 * 4)
807  	unsigned char		packet_header[HEADER_SIZE];
808  	struct pcap_pkthdr	pcap_header;
809  	acn_start_monitor(handle->fd, handle->snapshot, handle->opt.timeout, handle->opt.promisc, handle->direction);	&bsol;* maybe tell him to start monitoring */
810  	handle->bp = packet_header;
811  	if (acn_read_n_bytes_with_timeout(handle, HEADER_SIZE) == -1) return 0;			&bsol;* try to read a packet header in so we can get the sizeof the packet data */
812  	pcap_header.ts.tv_sec	= ntohl(*(uint32_t *)&packet_header[0]);				&bsol;* tv_sec */
813  	pcap_header.ts.tv_usec	= ntohl(*(uint32_t *)&packet_header[4]);				&bsol;* tv_usec */
814  	pcap_header.caplen		= ntohl(*(uint32_t *)&packet_header[8]);				&bsol;* caplen */
815  	pcap_header.len			= ntohl(*(uint32_t *)&packet_header[12]);				&bsol;* len */
816  	handle->bp = handle->buffer + handle->offset;									&bsol;* start off the receive pointer at the right spot */
817  	if (acn_read_n_bytes_with_timeout(handle, pcap_header.caplen) == -1) return 0;	&bsol;* then try to read in the rest of the data */
818  	callback(user, &pcap_header, handle->bp);										&bsol;* call the user supplied callback function */
819  	return 1;
820  }
821  static int pcap_activate_sita(pcap_t *handle) {
822  	int		fd;
823  	if (handle->opt.rfmon) {
824  		return PCAP_ERROR_RFMON_NOTSUP;
825  	}
826  	handle->inject_op = pcap_inject_acn;
827  	handle->setfilter_op = pcap_setfilter_acn;
828  	handle->setdirection_op = NULL; &bsol;* Not implemented */
829  	handle->set_datalink_op = NULL;	&bsol;* can't change data link type */
830  	handle->getnonblock_op = pcap_getnonblock_fd;
831  	handle->setnonblock_op = pcap_setnonblock_fd;
832  	handle->cleanup_op = pcap_cleanup_acn;
833  	handle->read_op = pcap_read_acn;
834  	handle->stats_op = pcap_stats_acn;
835  	fd = acn_open_live(handle->opt.device, handle->errbuf,
836  	    &handle->linktype);
837  	if (fd == -1)
838  		return PCAP_ERROR;
839  	if (handle->snapshot <= 0 || handle->snapshot > MAXIMUM_SNAPLEN)
840  		handle->snapshot = MAXIMUM_SNAPLEN;
841  	handle->fd = fd;
842  	handle->bufsize = handle->snapshot;
843  	handle->buffer	 = malloc(handle->bufsize + handle->offset);
844  	if (!handle->buffer) {
845  		pcap_fmt_errmsg_for_errno(handle->errbuf, PCAP_ERRBUF_SIZE,
846  		    errno, "malloc");
<span onclick='openModal()' class='match'>847  		pcap_cleanup_acn(handle);
848  		return PCAP_ERROR;
849  	}
850  	handle->selectable_fd = handle->fd;
851  	return 0;
</span>852  }
853  pcap_t *pcap_create_interface(const char *device _U_, char *ebuf) {
854  	pcap_t *p;
855  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_sita);
856  	if (p == NULL)
857  		return (NULL);
858  	p->activate_op = pcap_activate_sita;
859  	return (p);
860  }
861  int pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf) {
862  	*alldevsp = 0;												&bsol;* initialize the returned variables before we do anything */
863  	strcpy(errbuf, "");
864  	if (acn_parse_hosts_file(errbuf))							&bsol;* scan the hosts file for potential IOPs */
865  		{
866  		return -1;
867  		}
868  	if (acn_findalldevs(errbuf))								&bsol;* then ask the IOPs for their monitorable devices */
869  		{
870  		return -1;
871  		}
872  	devlistp->beginning = acn_if_list;
873  	acn_if_list = 0;											&bsol;* then forget our list head, because someone will call pcap_freealldevs() to empty the malloc'ed stuff */
874  	return 0;
875  }
876  const char *
877  pcap_lib_version(void)
878  {
879  	return PCAP_VERSION_STRING " (SITA-only)";
880  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-bitmap.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-sita.c</div>
                </div>
                <div class="column column_space"><pre><code>139      free(new);
140      return NULL;
141    }
142    new->ulongs_allocated = old->ulongs_allocated;
143    new->ulongs_count = old->ulongs_count;
</pre></code></div>
                <div class="column column_space"><pre><code>847  		pcap_cleanup_acn(handle);
848  		return PCAP_ERROR;
849  	}
850  	handle->selectable_fd = handle->fd;
851  	return 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    