
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for imkafka.c & imrelp.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for imkafka.c & imrelp.c
      </h3>
      <h1 align="center">
        22.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>imkafka.c (25.040388%)<TH>imrelp.c (20.861372%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-1.html#0',3)" NAME="0">(135-150)<TD><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-1.html#0',3)" NAME="0">(139-154)</A><TD ALIGN=center><FONT COLOR="#ff0000">27</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-1.html#1',3)" NAME="1">(612-632)<TD><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-1.html#1',3)" NAME="1">(694-714)</A><TD ALIGN=center><FONT COLOR="#ec0000">25</FONT>
<TR onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#2',2,'match117-1.html#2',3)" NAME="2">(570-576)<TD><A HREF="javascript:ZweiFrames('match117-0.html#2',2,'match117-1.html#2',3)" NAME="2">(534-546)</A><TD ALIGN=center><FONT COLOR="#cf0000">22</FONT>
<TR onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#3',2,'match117-1.html#3',3)" NAME="3">(532-551)<TD><A HREF="javascript:ZweiFrames('match117-0.html#3',2,'match117-1.html#3',3)" NAME="3">(513-533)</A><TD ALIGN=center><FONT COLOR="#b30000">19</FONT>
<TR onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#4',2,'match117-1.html#4',3)" NAME="4">(649-663)<TD><A HREF="javascript:ZweiFrames('match117-0.html#4',2,'match117-1.html#4',3)" NAME="4">(748-763)</A><TD ALIGN=center><FONT COLOR="#a00000">17</FONT>
<TR onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#5',2,'match117-1.html#5',3)" NAME="5">(272-291)<TD><A HREF="javascript:ZweiFrames('match117-0.html#5',2,'match117-1.html#5',3)" NAME="5">(263-283)</A><TD ALIGN=center><FONT COLOR="#970000">16</FONT>
<TR onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#6',2,'match117-1.html#6',3)" NAME="6">(302-319)<TD><A HREF="javascript:ZweiFrames('match117-0.html#6',2,'match117-1.html#6',3)" NAME="6">(304-322)</A><TD ALIGN=center><FONT COLOR="#8d0000">15</FONT>
<TR onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#7',2,'match117-1.html#7',3)" NAME="7">(638-648)<TD><A HREF="javascript:ZweiFrames('match117-0.html#7',2,'match117-1.html#7',3)" NAME="7">(732-742)</A><TD ALIGN=center><FONT COLOR="#840000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imkafka.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* imkafka.c
 *
 * This input plugin is a consumer for Apache Kafka.
 *
 * File begun on 2017-04-25 by alorbach
 *
 * Copyright 2008-2017 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;librdkafka/rdkafka.h&gt;

#include &quot;rsyslog.h&quot;
#include &quot;conf.h&quot;
#include &quot;syslogd-types.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;template.h&quot;
#include &quot;module-template.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;atomic.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;prop.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;glbl.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;msg.h&quot;
#include &quot;dirty.h&quot;

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imkafka&quot;)

/* static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)

/* forward references */
static void * imkafkawrkr(void *myself);


struct kafka_params {
	const char *name;
	const char *val;
};

/* Module static data */
static struct configSettings_s {
	uchar *topic;
	uchar *consumergroup;
	char *brokers;
	uchar *pszBindRuleset;
	int nConfParams;
	struct kafka_params *confParams;
} cs;

struct instanceConf_s {
	uchar *topic;
	uchar *consumergroup;
	char *brokers;
	int64_t offset;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */
	int bReportErrs;
	int nConfParams;
	struct kafka_params *confParams;
	int bIsConnected;
	rd_kafka_conf_t *conf;
	rd_kafka_t *rk;
	rd_kafka_topic_conf_t *topic_conf;
	int partition;
	int bIsSubscribed;
	int nMsgParsingFlags;

	struct instanceConf_s *next;
};


struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	uchar *topic;
	uchar *consumergroup;
	char *brokers;
	instanceConf_t *root, *tail;
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to (use system default if unspecified) */
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */
};

/* global data */
pthread_attr_t wrkrThrdAttr;	/* Attribute for worker threads ; read only after startup */
static int activeKafkaworkers = 0;
/* The following structure controls the worker threads. Global data is
 * needed for their access.
 */
static struct kafkaWrkrInfo_s {
	pthread_t tid;		/* the worker's thread ID */
	instanceConf_t *inst;	/* Pointer to imkafka instance */
} *kafkaWrkrInfo;

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

static prop_t *pInputName = NULL;
/* there is only one global inputName for all messages generated by this input */
<A NAME="0"></A>
/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match117-1.html#0',3,'match117-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;ruleset&quot;, eCmdHdlrGetWord, 0 },
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ &quot;topic&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;broker&quot;, eCmdHdlrArray, 0 },
	{ &quot;confparam&quot;, eCmdHdlrArray, 0 },
	{ &quot;consumergroup&quot;, eCmdHdlrString, 0},
	{ &quot;ruleset&quot;, eCmdHdlrString, 0 },
	{ &quot;parsehostname&quot;, eCmdHdlrBinary, 0 },</B></FONT>
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

#include &quot;im-helper.h&quot; /* must be included AFTER the type definitions! */

/* ------------------------------ callbacks ------------------------------ */




/* ------------------------------ end callbacks ------------------------------ */

static void
kafkaLogger(const rd_kafka_t __attribute__((unused)) *rk, int level,
	    const char *fac, const char *buf)
{
	DBGPRINTF(&quot;imkafka: kafka log message [%d,%s]: %s\n&quot;,
		  level, fac, buf);
}


/* enqueue the kafka message. The provided string is
 * not freed - thuis must be done by the caller.
 */
static rsRetVal enqMsg(instanceConf_t *const __restrict__ inst,
			rd_kafka_message_t *const __restrict__ rkmessage)
{
	DEFiRet;
	smsg_t *pMsg;

	if((int)rkmessage-&gt;len == 0) {
		/* we do not process empty lines */
		FINALIZE;
	}

DBGPRINTF(&quot;imkafka: enqMsg: Msg: %.*s\n&quot;, (int)rkmessage-&gt;len, (char *)rkmessage-&gt;payload);

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, pInputName);
	MsgSetRawMsg(pMsg, (char*)rkmessage-&gt;payload, (int)rkmessage-&gt;len);
	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	pMsg-&gt;msgFlags  = inst-&gt;nMsgParsingFlags;
	/* Optional Fields */
	if (rkmessage-&gt;key_len) {
		DBGPRINTF(&quot;imkafka: enqMsg: Key: %.*s\n&quot;, (int)rkmessage-&gt;key_len, (char *)rkmessage-&gt;key);
		MsgSetTAG(pMsg, (const uchar *)rkmessage-&gt;key, (int)rkmessage-&gt;key_len);
	}
	MsgSetMSGoffs(pMsg, 0);	/* we do not have a header... */

	CHKiRet(submitMsg2(pMsg));

finalize_it:
	RETiRet;
}

/**
 * Handle Kafka Consumer Loop until all msgs are processed
 */
static void msgConsume (instanceConf_t *inst) {
	rd_kafka_message_t *rkmessage = NULL;

	do { /* Consume messages */
		rkmessage = rd_kafka_consumer_poll(inst-&gt;rk, 1000); /* Block for 1000 ms max */
		if(rkmessage == NULL) {
			DBGPRINTF(&quot;imkafka: msgConsume EMPTY Loop on %s/%s/%s\n&quot;,
				inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
			goto done;
		}

		if (rkmessage-&gt;err) {
			if (rkmessage-&gt;err == RD_KAFKA_RESP_ERR__PARTITION_EOF) {
				/* not an error, just a regular status! */
				DBGPRINTF(&quot;imkafka: Consumer &quot;
					&quot;reached end of topic \&quot;%s\&quot; [%&quot;PRId32&quot;]&quot;
					&quot;message queue offset %&quot;PRId64&quot;\n&quot;,
					rd_kafka_topic_name(rkmessage-&gt;rkt),
					rkmessage-&gt;partition,
					rkmessage-&gt;offset);
				goto done;
			}
			if (rkmessage-&gt;rkt) {
				LogError(0, RS_RET_KAFKA_ERROR,
				&quot;imkafka: Consumer error for topic \&quot;%s\&quot; [%&quot;PRId32&quot;]&quot;
				&quot;message queue offset %&quot;PRId64&quot;: %s\n&quot;,
					rd_kafka_topic_name(rkmessage-&gt;rkt),
					rkmessage-&gt;partition,
					rkmessage-&gt;offset,
					rd_kafka_message_errstr(rkmessage));
			} else {
				LogError(0, RS_RET_KAFKA_ERROR,
					&quot;imkafka: Consumer error for topic \&quot;%s\&quot;: \&quot;%s\&quot;\n&quot;,
					rd_kafka_err2str(rkmessage-&gt;err),
					rd_kafka_message_errstr(rkmessage));
			}
			goto done;
		}

		DBGPRINTF(&quot;imkafka: msgConsume Loop on %s/%s/%s: [%&quot;PRId32&quot;], &quot;
					&quot;offset %&quot;PRId64&quot;, %zd bytes):\n&quot;,
					rd_kafka_topic_name(rkmessage-&gt;rkt) /*inst-&gt;topic*/,
					inst-&gt;consumergroup,
					inst-&gt;brokers,
					rkmessage-&gt;partition,
					rkmessage-&gt;offset,
					rkmessage-&gt;len);
		enqMsg(inst, rkmessage);
		/* Destroy message and continue */
		rd_kafka_message_destroy(rkmessage);
		rkmessage = NULL;
	} while(1); /* loop broken inside */
done:
	/* Destroy message in case rkmessage-&gt;err was set */
	if(rkmessage != NULL) {
<A NAME="5"></A>		rd_kafka_message_destroy(rkmessage);
	}
	return;
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match117-1.html#5',3,'match117-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}



/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;

	inst-&gt;brokers = NULL;
	inst-&gt;topic = NULL;
	inst-&gt;consumergroup = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;nConfParams = 0;</B></FONT>
	inst-&gt;confParams = NULL;
	inst-&gt;pBindRuleset = NULL;
	inst-&gt;bReportErrs = 1; /* Fixed for now */
	inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
	inst-&gt;bIsConnected = 0;
	inst-&gt;bIsSubscribed = 0;
	/* Kafka objects */
<A NAME="6"></A>	inst-&gt;conf = NULL;
	inst-&gt;rk = NULL;
	inst-&gt;topic_conf = NULL;
<FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match117-1.html#6',3,'match117-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	inst-&gt;partition = RD_KAFKA_PARTITION_UA;

	/* node created, let's add to config */
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}

/* this function checks instance parameters and does some required pre-processing
 */
static rsRetVal ATTR_NONNULL()</B></FONT>
checkInstance(instanceConf_t *const inst)
{
	DEFiRet;
	char kafkaErrMsg[1024];

	/* main kafka conf */
	inst-&gt;conf = rd_kafka_conf_new();
	if(inst-&gt;conf == NULL) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_ERROR,
				&quot;imkafka: error creating kafka conf obj: %s\n&quot;,
				rd_kafka_err2str(rd_kafka_last_error()));
		}
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	}

#	ifdef DEBUG
	/* enable kafka debug output */
	if(rd_kafka_conf_set(inst-&gt;conf, &quot;debug&quot;, RD_KAFKA_DEBUG_CONTEXTS,
		kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
		LogError(0, RS_RET_KAFKA_ERROR, &quot;imkafka: error setting kafka debug option: %s\n&quot;, kafkaErrMsg);
		/* DO NOT ABORT IN THIS CASE! */
	}
#	endif

	/* Set custom configuration parameters */
	for(int i = 0 ; i &lt; inst-&gt;nConfParams ; ++i) {
		assert(inst-&gt;confParams+i != NULL); /* invariant: nConfParams MUST exist! */
		DBGPRINTF(&quot;imkafka: setting custom configuration parameter: %s:%s\n&quot;,
			inst-&gt;confParams[i].name,
			inst-&gt;confParams[i].val);
		if(rd_kafka_conf_set(inst-&gt;conf,
			inst-&gt;confParams[i].name,
			inst-&gt;confParams[i].val,
			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_PARAM_ERROR, &quot;error setting custom configuration &quot;
					&quot;parameter '%s=%s': %s&quot;,
					inst-&gt;confParams[i].name,
					inst-&gt;confParams[i].val, kafkaErrMsg);
			} else {
				DBGPRINTF(&quot;imkafka: error setting custom configuration parameter '%s=%s': %s&quot;,
					inst-&gt;confParams[i].name,
					inst-&gt;confParams[i].val, kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_PARAM_ERROR);
		}
	}

	/* Topic configuration */
	inst-&gt;topic_conf = rd_kafka_topic_conf_new();

	/* Assign kafka group id */
	if (inst-&gt;consumergroup != NULL) {
		DBGPRINTF(&quot;imkafka: setting consumergroup: '%s'\n&quot;, inst-&gt;consumergroup);
		if (rd_kafka_conf_set(inst-&gt;conf, &quot;group.id&quot;, (char*) inst-&gt;consumergroup,
			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					&quot;imkafka: error assigning consumergroup %s to &quot;
					&quot;kafka config: %s\n&quot;, inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}


		/* Set default for auto offset reset */
		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, &quot;auto.offset.reset&quot;,
			&quot;smallest&quot;, kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					&quot;imkafka: error setting kafka auto.offset.reset on %s: %s\n&quot;,
					inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}
		/* Consumer groups always use broker based offset storage */
		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, &quot;offset.store.method&quot;,
			&quot;broker&quot;, kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
			if(inst-&gt;bReportErrs) {
				LogError(0, RS_RET_KAFKA_ERROR,
					&quot;imkafka: error setting kafka offset.store.method on %s: %s\n&quot;,
					inst-&gt;consumergroup,
					kafkaErrMsg);
			}
			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
		}

		/* Set default topic config for pattern-matched topics. */
		rd_kafka_conf_set_default_topic_conf(inst-&gt;conf, inst-&gt;topic_conf);
	}

	#if RD_KAFKA_VERSION &gt;= 0x00090001
		rd_kafka_conf_set_log_cb(inst-&gt;conf, kafkaLogger);
	#endif

	/* Create Kafka Consumer */
	inst-&gt;rk = rd_kafka_new(RD_KAFKA_CONSUMER, inst-&gt;conf,
				     kafkaErrMsg, sizeof(kafkaErrMsg));
	if(inst-&gt;rk == NULL) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_ERROR,
				&quot;imkafka: error creating kafka handle: %s\n&quot;, kafkaErrMsg);
		}
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	}
	#if RD_KAFKA_VERSION &lt; 0x00090001
		rd_kafka_set_logger(inst-&gt;rk, kafkaLogger);
	#endif

	DBGPRINTF(&quot;imkafka: setting brokers: '%s'\n&quot;, inst-&gt;brokers);
	if(rd_kafka_brokers_add(inst-&gt;rk, (char*)inst-&gt;brokers) == 0) {
		if(inst-&gt;bReportErrs) {
			LogError(0, RS_RET_KAFKA_NO_VALID_BROKERS,
				&quot;imkafka: no valid brokers specified: %s&quot;, inst-&gt;brokers);
		}
		ABORT_FINALIZE(RS_RET_KAFKA_NO_VALID_BROKERS);
	}

	/* Kafka Consumer is opened */
	inst-&gt;bIsConnected = 1;

finalize_it:
	if(iRet != RS_RET_OK) {
		if(inst-&gt;rk == NULL) {
			if(inst-&gt;conf != NULL) {
				rd_kafka_conf_destroy(inst-&gt;conf);
				inst-&gt;conf = NULL;
			}
		} else { /* inst-&gt;rk != NULL ! */
			rd_kafka_destroy(inst-&gt;rk);
			inst-&gt;rk = NULL;
		}
	}

	RETiRet;
}

/* function to generate an error message if the ruleset cannot be found */
static inline void
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	if(inst-&gt;bReportErrs) {
		LogError(0, NO_ERRCODE, &quot;imkafka: ruleset '%s' not found - &quot;
			&quot;using default ruleset instead&quot;,
			inst-&gt;pszBindRuleset);
	}
}


static rsRetVal ATTR_NONNULL(2)
addConsumer(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
{
	DEFiRet;
	rd_kafka_resp_err_t err;

	assert(inst != NULL);

	rd_kafka_topic_partition_list_t *topics = NULL;
	DBGPRINTF(&quot;imkafka: creating kafka consumer on %s/%s/%s\n&quot;,
		inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);

	/* Redirect rd_kafka_poll() to consumer_poll() */
	rd_kafka_poll_set_consumer(inst-&gt;rk);

	topics = rd_kafka_topic_partition_list_new(1);
	rd_kafka_topic_partition_list_add(topics, (const char*)inst-&gt;topic, inst-&gt;partition);
	DBGPRINTF(&quot;imkafka: Created topics(%d) for %s)\n&quot;,
		topics-&gt;cnt, inst-&gt;topic);
	if ((err = rd_kafka_subscribe(inst-&gt;rk, topics))) {
		/* Subscription failed */
		inst-&gt;bIsSubscribed = 0;
		LogError(0, RS_RET_KAFKA_ERROR, &quot;imkafka: Failed to start consuming &quot;
			&quot;topics: %s\n&quot;, rd_kafka_err2str(err));
		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
	} else {
		DBGPRINTF(&quot;imkafka: Successfully subscribed to %s/%s/%s\n&quot;,
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
		/* Subscription is working */
		inst-&gt;bIsSubscribed = 1;
	}
finalize_it:
	if(topics != NULL)
		rd_kafka_topic_partition_list_destroy(topics);
	RETiRet;
}

static rsRetVal ATTR_NONNULL()
processKafkaParam(char *const param,
	const char **const name,
	const char **const paramval)
{
	DEFiRet;
	char *val = strstr(param, &quot;=&quot;);
	if(val == NULL) {
		LogError(0, RS_RET_PARAM_ERROR, &quot;missing equal sign in &quot;
				&quot;parameter '%s'&quot;, param);
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
	*val = '\0'; /* terminates name */
	++val; /* now points to begin of value */
	CHKmalloc(*name = strdup(param));
	CHKmalloc(*paramval = strdup(val));
finalize_it:
	RETiRet;
}

<A NAME="3"></A>BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst;
<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match117-1.html#3',3,'match117-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int i;
CODESTARTnewInpInst
	DBGPRINTF(&quot;newInpInst (imkafka)\n&quot;);

	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;input param blk in imkafka:\n&quot;);
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(inppblk.descr[i].name, &quot;broker&quot;)) {
			es_str_t *es = es_newStr(128);</B></FONT>
			int bNeedComma = 0;
			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				if(bNeedComma)
					es_addChar(&amp;es, ',');
				es_addStr(&amp;es, pvals[i].val.d.ar-&gt;arr[j]);
				bNeedComma = 1;
			}
			inst-&gt;brokers = es_str2cstr(es, NULL);
			es_deleteStr(es);
		} else if(!strcmp(inppblk.descr[i].name, &quot;confparam&quot;)) {
			inst-&gt;nConfParams = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(inst-&gt;confParams = malloc(sizeof(struct kafka_params)*inst-&gt;nConfParams));
			for(int j = 0; j &lt; inst-&gt;nConfParams; j++) {
				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				CHKiRet(processKafkaParam(cstr, &amp;inst-&gt;confParams[j].name,
<A NAME="2"></A>								&amp;inst-&gt;confParams[j].val));
				free(cstr);
			}
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match117-1.html#2',3,'match117-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(inppblk.descr[i].name, &quot;topic&quot;)) {
			inst-&gt;topic = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;consumergroup&quot;)) {
			inst-&gt;consumergroup = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;ruleset&quot;)) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;parsehostname&quot;)) {</B></FONT>
			if (pvals[i].val.d.n) {
				inst-&gt;nMsgParsingFlags = NEEDS_PARSING | PARSE_HOSTNAME;
			} else {
				inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
			}
		} else {
			dbgprintf(&quot;imkafka: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, inppblk.descr[i].name);
		}
	}

	if(inst-&gt;brokers == NULL) {
		CHKmalloc(inst-&gt;brokers = strdup(&quot;localhost:9092&quot;));
		LogMsg(0, NO_ERRCODE, LOG_INFO, &quot;imkafka: \&quot;broker\&quot; parameter not specified &quot;
			&quot;using default of localhost:9092 -- this may not be what you want!&quot;);
	}

	DBGPRINTF(&quot;imkafka: newInpIns brokers=%s, topic=%s, consumergroup=%s\n&quot;,
		inst-&gt;brokers, inst-&gt;topic, inst-&gt;consumergroup);

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;pszBindRuleset = NULL;
ENDbeginCnfLoad
<A NAME="1"></A>

BEGINsetModCnf
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match117-1.html#1',3,'match117-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;imkafka: error processing module &quot;
			&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for imkafka:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;ruleset&quot;)) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {</B></FONT>
			dbgprintf(&quot;imkafka: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
<A NAME="7"></A>		}
	}
finalize_it:
<FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match117-1.html#7',3,'match117-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	if(loadModConf-&gt;pszBindRuleset == NULL) {
		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
<A NAME="4"></A>			loadModConf-&gt;pszBindRuleset = NULL;
		} else {
			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));</B></FONT>
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match117-1.html#4',3,'match117-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		}
	}
finalize_it:
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	loadModConf = NULL; /* done loading */
ENDendCnfLoad

BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
		}</B></FONT>
		std_checkRuleset(pModConf, inst);
	}
finalize_it:
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
ENDactivateCnfPrePrivDrop

BEGINactivateCnf
CODESTARTactivateCnf
	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		iRet = checkInstance(inst);
	}
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;topic);
		free(inst-&gt;consumergroup);
		free(inst-&gt;brokers);
		free(inst-&gt;pszBindRuleset);
		for(int i = 0; i &lt; inst-&gt;nConfParams; i++) {
			free((void*)inst-&gt;confParams[i].name);
			free((void*)inst-&gt;confParams[i].val);
		}
		free((void*)inst-&gt;confParams);
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
	free(pModConf-&gt;pszBindRuleset);
ENDfreeCnf


/* Cleanup imkafka worker threads */
static void
shutdownKafkaWorkers(void)
{
	int i;
	instanceConf_t *inst;

	assert(kafkaWrkrInfo != NULL);

	DBGPRINTF(&quot;imkafka: waiting on imkafka workerthread termination\n&quot;);
	for(i = 0 ; i &lt; activeKafkaworkers ; ++i) {
		pthread_join(kafkaWrkrInfo[i].tid, NULL);
		DBGPRINTF(&quot;imkafka: Stopped worker %d\n&quot;, i);
	}
	free(kafkaWrkrInfo);
	kafkaWrkrInfo = NULL;

	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		DBGPRINTF(&quot;imkafka: stop consuming %s/%s/%s\n&quot;,
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
		rd_kafka_consumer_close(inst-&gt;rk); /* Close the consumer, committing final offsets, etc. */
		rd_kafka_destroy(inst-&gt;rk); /* Destroy handle object */
		DBGPRINTF(&quot;imkafka: stopped consuming %s/%s/%s\n&quot;,
			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);

		#if RD_KAFKA_VERSION &lt; 0x00090001
		/* Wait for kafka being destroyed in old API */
		if (rd_kafka_wait_destroyed(10000) &lt; 0)	{
			DBGPRINTF(&quot;imkafka: error, rd_kafka_destroy did not finish after grace &quot;
				&quot;timeout (10s)!\n&quot;);
		} else {
			DBGPRINTF(&quot;imkafka: rd_kafka_destroy successfully finished\n&quot;);
		}
		#endif
	}
}


/* This function is called to gather input.  */
BEGINrunInput
	int i;
	instanceConf_t *inst;
CODESTARTrunInput
	DBGPRINTF(&quot;imkafka: runInput loop started ...\n&quot;);
	activeKafkaworkers = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(inst-&gt;rk != NULL) {
			++activeKafkaworkers;
		}
	}

	if(activeKafkaworkers == 0) {
		LogError(0, RS_RET_ERR, &quot;imkafka: no active inputs, input does &quot;
			&quot;not run - there should have been additional error &quot;
			&quot;messages given previously&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}


	DBGPRINTF(&quot;imkafka: Starting %d imkafka workerthreads\n&quot;, activeKafkaworkers);
	kafkaWrkrInfo = calloc(activeKafkaworkers, sizeof(struct kafkaWrkrInfo_s));
	if (kafkaWrkrInfo == NULL) {
		LogError(errno, RS_RET_OUT_OF_MEMORY, &quot;imkafka: worker-info array allocation failed.&quot;);
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}

	/* Start worker threads for each imkafka input source
	*/
	i = 0;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		/* init worker info structure! */
		kafkaWrkrInfo[i].inst = inst; /* Set reference pointer */
		pthread_create(&amp;kafkaWrkrInfo[i].tid, &amp;wrkrThrdAttr, imkafkawrkr, &amp;(kafkaWrkrInfo[i]));
		i++;
	}

	while(glbl.GetGlobalInputTermState() == 0) {

		/* Note: the additional 10000ns wait is vitally important. It guards rsyslog
		 * against totally hogging the CPU if the users selects a polling interval
		 * of 0 seconds. It doesn't hurt any other valid scenario. So do not remove.
		 */
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(0, 100000);
	}
	DBGPRINTF(&quot;imkafka: terminating upon request of rsyslog core\n&quot;);

	/* we need to shutdown kafak worker threads here because this operation can
	 * potentially block (e.g. when no kafka broker is available!). If this
	 * happens in runInput, the rsyslog core can cancel our thread. However,
	 * in afterRun this is not possible, because the core does not assume it
	 * can block there. -- rgerhards, 2018-10-23
	 */
	shutdownKafkaWorkers();
finalize_it:
ENDrunInput


BEGINwillRun
CODESTARTwillRun
	/* we need to create the inputName property (only once during our lifetime) */
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT(&quot;imkafka&quot;), sizeof(&quot;imkafka&quot;) - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
finalize_it:
ENDwillRun


BEGINafterRun
CODESTARTafterRun
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);

ENDafterRun


BEGINmodExit
CODESTARTmodExit
	pthread_attr_destroy(&amp;wrkrThrdAttr);
	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION;
CODEmodInit_QueryRegCFSLineHdlr
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	/* initialize &quot;read-only&quot; thread attributes */
	pthread_attr_init(&amp;wrkrThrdAttr);
	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);

	DBGPRINTF(&quot;imkafka %s using librdkafka version %s, 0x%x\n&quot;,
		VERSION, rd_kafka_version_str(), rd_kafka_version());
ENDmodInit

/*
*	Workerthread function for a single kafka consomer
 */
static void *
imkafkawrkr(void *myself)
{
	struct kafkaWrkrInfo_s *me = (struct kafkaWrkrInfo_s*) myself;
	DBGPRINTF(&quot;imkafka: started kafka consumer workerthread on %s/%s/%s\n&quot;,
		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);

	do {
		if(glbl.GetGlobalInputTermState() == 1)
			break; /* terminate input! */

		if(me-&gt;inst-&gt;rk == NULL) {
			continue;
		}

		// Try to add consumer only if connected! */
		if(me-&gt;inst-&gt;bIsConnected == 1 &amp;&amp; me-&gt;inst-&gt;bIsSubscribed == 0 ) {
			addConsumer(runModConf, me-&gt;inst);
		}
		if(me-&gt;inst-&gt;bIsSubscribed == 1 ) {
			msgConsume(me-&gt;inst);
		}
		/* Note: the additional 10000ns wait is vitally important. It guards rsyslog
		 * against totally hogging the CPU if the users selects a polling interval
		 * of 0 seconds. It doesn't hurt any other valid scenario. So do not remove.
		 * rgerhards, 2008-02-14
		 */
		if(glbl.GetGlobalInputTermState() == 0)
			srSleep(0, 100000);
	} while(glbl.GetGlobalInputTermState() == 0);

	DBGPRINTF(&quot;imkafka: stopped kafka consumer workerthread on %s/%s/%s\n&quot;,
		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
	return NULL;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imrelp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* imrelp.c
 *
 * This is the implementation of the RELP input module.
 *
 * File begun on 2008-03-13 by RGerhards
 *
 * Copyright 2008-2019 Adiscon GmbH.
 *
 * This file is part of rsyslog.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *       -or-
 *       see COPYING.ASL20 in the source distribution
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include &quot;config.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;signal.h&gt;
#include &lt;librelp.h&gt;
#include &quot;rsyslog.h&quot;
#include &quot;dirty.h&quot;
#include &quot;errmsg.h&quot;
#include &quot;cfsysline.h&quot;
#include &quot;module-template.h&quot;
#include &quot;net.h&quot;
#include &quot;msg.h&quot;
#include &quot;unicode-helper.h&quot;
#include &quot;prop.h&quot;
#include &quot;ruleset.h&quot;
#include &quot;glbl.h&quot;
#include &quot;statsobj.h&quot;
#include &quot;srUtils.h&quot;
#include &quot;parserif.h&quot;

MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME(&quot;imrelp&quot;)

/* static data */
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(net)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(glbl)
DEFobjCurrIf(statsobj)

/* forward definitions */
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);


/* Module static data */
/* config vars for legacy config system */
static relpEngine_t *pRelpEngine;	/* our relp engine */

/* config settings */
typedef struct configSettings_s {
	uchar *pszBindRuleset;		/* name of Ruleset to bind to */
} configSettings_t;
static configSettings_t cs;

struct instanceConf_s {
	uchar *pszBindPort;		/* port to bind to */
	uchar *pszBindAddr;		/* address to bind to */
	uchar *pszBindRuleset;		/* name of ruleset to bind to */
	uchar *pszInputName;		/* value for inputname property */
	prop_t *pInputName;		/* InputName in property format for fast access */
	ruleset_t *pBindRuleset;	/* ruleset to bind listener to */
	sbool bKeepAlive;		/* support keep-alive packets */
	sbool bEnableTLS;
	sbool bEnableTLSZip;
	sbool bEnableLstn;		/* flag to permit disabling of listener in error case */
	int dhBits;
	size_t maxDataSize;
	int oversizeMode;
	uchar *pristring;		/* GnuTLS priority string (NULL if not to be provided) */
	uchar *authmode;		/* TLS auth mode */
	uchar *caCertFile;
	uchar *myCertFile;
	uchar *myPrivKeyFile;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	uchar *tlscfgcmd;
#endif
	int iKeepAliveIntvl;
	int iKeepAliveProbes;
	int iKeepAliveTime;
	flowControl_t flowCtlType;
	struct {
		int nmemb;
		uchar **name;
	} permittedPeers;

	struct instanceConf_s *next;
	/* with librelp, this module does not have any own specific session
	 * or listener active data item. As a &quot;work-around&quot;, we keep some
	 * data items inside the configuration object. To keep things
	 * decently clean, we put them all into their dedicated struct. So
	 * it is easy to judge what is actual configuration and what is
	 * dynamic runtime data. -- rgerhards, 2013-06-18
	 */
	struct {
		statsobj_t *stats;	/* listener stats */
		STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
	} data;
};


struct modConfData_s {
	rsconf_t *pConf;		/* our overall config object */
	instanceConf_t *root, *tail;
	const char *tlslib;
	uchar *pszBindRuleset;		/* default name of Ruleset to bind to */
};

static modConfData_t *loadModConf = NULL;/* modConf ptr to use for the current load process */
static modConfData_t *runModConf = NULL;/* modConf ptr to use for the current load process */

<A NAME="0"></A>/* module-global parameters */
static struct cnfparamdescr modpdescr[] = {
	{ &quot;ruleset&quot;, eCmdHdlrGetWord, 0 },
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;tls.tlslib&quot;, eCmdHdlrString, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};

/* input instance parameters */
static struct cnfparamdescr inppdescr[] = {
	{ &quot;port&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
	{ &quot;address&quot;, eCmdHdlrString, 0 },
	{ &quot;name&quot;, eCmdHdlrString, 0 },
	{ &quot;ruleset&quot;, eCmdHdlrString, 0 },
	{ &quot;keepalive&quot;, eCmdHdlrBinary, 0 },
	{ &quot;keepalive.probes&quot;, eCmdHdlrInt, 0 },</B></FONT>
	{ &quot;keepalive.time&quot;, eCmdHdlrInt, 0 },
	{ &quot;keepalive.interval&quot;, eCmdHdlrInt, 0 },
	{ &quot;maxdatasize&quot;, eCmdHdlrSize, 0 },
	{ &quot;oversizemode&quot;, eCmdHdlrString, 0 },
	{ &quot;flowcontrol&quot;, eCmdHdlrGetWord, 0 },
	{ &quot;tls&quot;, eCmdHdlrBinary, 0 },
	{ &quot;tls.permittedpeer&quot;, eCmdHdlrArray, 0 },
	{ &quot;tls.authmode&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.dhbits&quot;, eCmdHdlrInt, 0 },
	{ &quot;tls.prioritystring&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.tlscfgcmd&quot;, eCmdHdlrString, 0 },
	{ &quot;tls.compression&quot;, eCmdHdlrBinary, 0 }
};
static struct cnfparamblk inppblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
	  inppdescr
	};

#include &quot;im-helper.h&quot; /* must be included AFTER the type definitions! */
static int bLegacyCnfModGlobalsPermitted;/* are legacy module-global config parameters permitted? */

/* ------------------------------ callbacks ------------------------------ */

PRAGMA_DIAGNOSTIC_PUSH
PRAGMA_IGNORE_Wformat_nonliteral
static void __attribute__((format(printf, 1, 2)))
imrelp_dbgprintf(const char *fmt, ...)
{
	va_list ap;
	char pszWriteBuf[32*1024+1]; //this function has to be able to
					/*generate a buffer longer than that of r_dbgprintf, so
					r_dbgprintf can properly truncate*/

	if(!(Debug &amp;&amp; debugging_on)) {
		return;
	}

	va_start(ap, fmt);
	vsnprintf(pszWriteBuf, sizeof(pszWriteBuf), fmt, ap);
	va_end(ap);
	r_dbgprintf(&quot;imrelp.c&quot;, &quot;%s&quot;, pszWriteBuf);
}
PRAGMA_DIAGNOSTIC_POP

static void
onErr(void *pUsr, char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	instanceConf_t *inst = (instanceConf_t*) pUsr;
	LogError(0, RS_RET_RELP_AUTH_FAIL, &quot;imrelp[%s]: error '%s', object &quot;
			&quot; '%s' - input may not work as intended&quot;,
			inst-&gt;pszBindPort, errmesg, objinfo);
}

static void
onGenericErr(char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	LogError(0, RS_RET_RELP_ERR, &quot;imrelp: librelp error '%s', object &quot;
			&quot; '%s' - input may not work as intended&quot;, errmesg, objinfo);
}

static void
onAuthErr(void *pUsr, char *authinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
{
	instanceConf_t *inst = (instanceConf_t*) pUsr;
	LogError(0, RS_RET_RELP_AUTH_FAIL, &quot;imrelp[%s]: authentication error '%s', peer &quot;
			&quot;is '%s'&quot;, inst-&gt;pszBindPort, errmesg, authinfo);
}

/* callback for receiving syslog messages. This function is invoked from the
 * RELP engine when a syslog message arrived. It must return a relpRetVal,
 * with anything else but RELP_RET_OK terminating the relp session. Please note
 * that RELP_RET_OK is equal to RS_RET_OK and the other libRELP error codes
 * are different from our rsRetVal. So we can simply use our own iRet system
 * to fulfill the requirement.
 * rgerhards, 2008-03-21
 * Note: librelp 1.0.0 is required in order to receive the IP address, otherwise
 * we will only see the hostname (twice). -- rgerhards, 2009-10-14
 */
static relpRetVal
onSyslogRcv(void *pUsr, uchar *pHostname, uchar *pIP, uchar *msg, size_t lenMsg)
{
	prop_t *pProp = NULL;
	smsg_t *pMsg;
	instanceConf_t *inst = (instanceConf_t*) pUsr;
	DEFiRet;

	CHKiRet(msgConstruct(&amp;pMsg));
	MsgSetInputName(pMsg, inst-&gt;pInputName);
	MsgSetRawMsg(pMsg, (char*)msg, lenMsg);
	MsgSetFlowControlType(pMsg, inst-&gt;flowCtlType);
	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
	pMsg-&gt;msgFlags  = PARSE_HOSTNAME | NEEDS_PARSING;

	/* TODO: optimize this, we can store it inside the session */
	MsgSetRcvFromStr(pMsg, pHostname, ustrlen(pHostname), &amp;pProp);
	CHKiRet(prop.Destruct(&amp;pProp));
	CHKiRet(MsgSetRcvFromIPStr(pMsg, pIP, ustrlen(pIP), &amp;pProp));
	CHKiRet(prop.Destruct(&amp;pProp));
	CHKiRet(submitMsg2(pMsg));
	STATSCOUNTER_INC(inst-&gt;data.ctrSubmit, inst-&gt;data.mutCtrSubmit);

<A NAME="5"></A>finalize_it:

	RETiRet;
<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#5',2,'match117-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}


/* ------------------------------ end callbacks ------------------------------ */

/* create input instance, set default parameters, and
 * add it to the list of instances.
 */
static rsRetVal
createInstance(instanceConf_t **pinst)
{
	instanceConf_t *inst;
	DEFiRet;
	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
	inst-&gt;next = NULL;

	inst-&gt;pszBindPort = NULL;
	inst-&gt;pszBindAddr = NULL;
	inst-&gt;pszBindRuleset = NULL;
	inst-&gt;pszInputName = NULL;
	inst-&gt;pBindRuleset = NULL;</B></FONT>
	inst-&gt;bKeepAlive = 0;
	inst-&gt;iKeepAliveIntvl = 0;
	inst-&gt;iKeepAliveProbes = 0;
	inst-&gt;iKeepAliveTime = 0;
	inst-&gt;bEnableTLS = 0;
	inst-&gt;bEnableTLSZip = 0;
	inst-&gt;bEnableLstn = 0;
	inst-&gt;dhBits = 0;
	inst-&gt;pristring = NULL;
	inst-&gt;authmode = NULL;
	inst-&gt;permittedPeers.nmemb = 0;
	inst-&gt;caCertFile = NULL;
	inst-&gt;myCertFile = NULL;
	inst-&gt;myPrivKeyFile = NULL;
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
	inst-&gt;tlscfgcmd = NULL;
#endif
<A NAME="6"></A>	inst-&gt;maxDataSize = 0;
	inst-&gt;flowCtlType = eFLOWCTL_LIGHT_DELAY;
#ifdef HAVE_RELPSRVSETOVERSIZEMODE
<FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#6',2,'match117-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
#endif

	/* node created, let's add to config */
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
	} else {
		loadModConf-&gt;tail-&gt;next = inst;
		loadModConf-&gt;tail = inst;
	}

	*pinst = inst;
finalize_it:
	RETiRet;
}


/* function to generate an error message if the ruleset cannot be found */
static inline void</B></FONT>
std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
{
	LogError(0, NO_ERRCODE, &quot;imrelp[%s]: ruleset '%s' not found - &quot;
			&quot;using default ruleset instead&quot;,
			inst-&gt;pszBindPort, inst-&gt;pszBindRuleset);
}


/* This function is called when a new listener instance shall be added to
 * the current config object via the legacy config system. It just shuffles
 * all parameters to the listener in-memory instance.
 * rgerhards, 2011-05-04
 */
static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
{
	instanceConf_t *inst;
	DEFiRet;

	CHKiRet(createInstance(&amp;inst));

	if(pNewVal == NULL || *pNewVal == '\0') {
		LogError(0, NO_ERRCODE, &quot;imrelp: port number must be specified, listener ignored&quot;);
	}
	if((pNewVal == NULL) || (*pNewVal == '\0')) {
		inst-&gt;pszBindPort = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindPort = ustrdup(pNewVal));
	}
	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
		inst-&gt;pszBindRuleset = NULL;
	} else {
		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
	}
	inst-&gt;pBindRuleset = NULL;

	inst-&gt;bEnableLstn = -1; /* all ok, ready to start up */
finalize_it:
	free(pNewVal);
	RETiRet;
}


static rsRetVal
addListner(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
{
	relpSrv_t *pSrv;
	int relpRet;
	uchar statname[64];
	int i;
	DEFiRet;

	if(!inst-&gt;bEnableLstn) {
		DBGPRINTF(&quot;listener not started because it is disabled by config error\n&quot;);
		FINALIZE;
	}

	if(pRelpEngine == NULL) {
		CHKiRet(relpEngineConstruct(&amp;pRelpEngine));
		CHKiRet(relpEngineSetDbgprint(pRelpEngine, (void (*)(char *, ...))imrelp_dbgprintf));
		CHKiRet(relpEngineSetFamily(pRelpEngine, glbl.GetDefPFFamily(runModConf-&gt;pConf)));
		CHKiRet(relpEngineSetEnableCmd(pRelpEngine, (uchar*) &quot;syslog&quot;, eRelpCmdState_Required));
		CHKiRet(relpEngineSetSyslogRcv2(pRelpEngine, onSyslogRcv));
		CHKiRet(relpEngineSetOnErr(pRelpEngine, onErr));
		CHKiRet(relpEngineSetOnGenericErr(pRelpEngine, onGenericErr));
		CHKiRet(relpEngineSetOnAuthErr(pRelpEngine, onAuthErr));
		if (!glbl.GetDisableDNS(runModConf-&gt;pConf)) {
			CHKiRet(relpEngineSetDnsLookupMode(pRelpEngine, 1));
		}
		#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
			if(modConf-&gt;tlslib != NULL) {
				if(relpEngineSetTLSLibByName(pRelpEngine, modConf-&gt;tlslib) != RELP_RET_OK) {
					LogMsg(0, RS_RET_CONF_PARAM_INVLD, LOG_WARNING,
						&quot;imrelp: tlslib '%s' not accepted as valid by librelp - using default&quot;,
						modConf-&gt;tlslib);
				}
			}
		#endif
	}

	CHKiRet(relpEngineListnerConstruct(pRelpEngine, &amp;pSrv));
	CHKiRet(relpSrvSetMaxDataSize(pSrv, inst-&gt;maxDataSize));
	CHKiRet(relpSrvSetLstnPort(pSrv, inst-&gt;pszBindPort));
	#if defined(HAVE_RELPSRVSETLSTNADDR)
		CHKiRet(relpSrvSetLstnAddr(pSrv, inst-&gt;pszBindAddr));
	#endif

#ifdef HAVE_RELPSRVSETOVERSIZEMODE
	CHKiRet(relpSrvSetOversizeMode(pSrv, inst-&gt;oversizeMode));
#endif
	inst-&gt;pszInputName = ustrdup((inst-&gt;pszInputName == NULL) ?  UCHAR_CONSTANT(&quot;imrelp&quot;) : inst-&gt;pszInputName);
	CHKiRet(prop.Construct(&amp;inst-&gt;pInputName));
	CHKiRet(prop.SetString(inst-&gt;pInputName, inst-&gt;pszInputName, ustrlen(inst-&gt;pszInputName)));
	CHKiRet(prop.ConstructFinalize(inst-&gt;pInputName));
	/* support statistics gathering */
	CHKiRet(statsobj.Construct(&amp;(inst-&gt;data.stats)));
	snprintf((char*)statname, sizeof(statname), &quot;%s(%s)&quot;,
		 inst-&gt;pszInputName, inst-&gt;pszBindPort);
	statname[sizeof(statname)-1] = '\0'; /* just to be on the save side... */
	CHKiRet(statsobj.SetName(inst-&gt;data.stats, statname));
	CHKiRet(statsobj.SetOrigin(inst-&gt;data.stats, (uchar*)&quot;imrelp&quot;));
	STATSCOUNTER_INIT(inst-&gt;data.ctrSubmit, inst-&gt;data.mutCtrSubmit);
	CHKiRet(statsobj.AddCounter(inst-&gt;data.stats, UCHAR_CONSTANT(&quot;submitted&quot;),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(inst-&gt;data.ctrSubmit)));
	CHKiRet(statsobj.ConstructFinalize(inst-&gt;data.stats));
	/* end stats counters */
	relpSrvSetUsrPtr(pSrv, inst);
	relpSrvSetKeepAlive(pSrv, inst-&gt;bKeepAlive, inst-&gt;iKeepAliveIntvl,
			    inst-&gt;iKeepAliveProbes, inst-&gt;iKeepAliveTime);
	if(inst-&gt;bEnableTLS) {
		relpRet = relpSrvEnableTLS2(pSrv);
		if(relpRet == RELP_RET_ERR_NO_TLS) {
			LogError(0, RS_RET_RELP_NO_TLS,
					&quot;imrelp: could not activate relp TLS, librelp &quot;
					&quot;does not support it (most probably GnuTLS lib &quot;
					&quot;is too old)!&quot;);
			ABORT_FINALIZE(RS_RET_RELP_NO_TLS);
		} else if(relpRet == RELP_RET_ERR_NO_TLS_AUTH) {
			LogError(0, RS_RET_RELP_NO_TLS_AUTH,
					&quot;imrelp: could not activate relp TLS with &quot;
					&quot;authentication, librelp does not support it &quot;
					&quot;(most probably GnuTLS lib is too old)! &quot;
					&quot;Note: anonymous TLS is probably supported.&quot;);
			ABORT_FINALIZE(RS_RET_RELP_NO_TLS_AUTH);
		} else if(relpRet != RELP_RET_OK) {
			LogError(0, RS_RET_RELP_ERR,
					&quot;imrelp: could not activate relp TLS, code %d&quot;, relpRet);
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
		if(inst-&gt;bEnableTLSZip) {
			relpSrvEnableTLSZip2(pSrv);
		}
		if(inst-&gt;dhBits) {
			relpSrvSetDHBits(pSrv, inst-&gt;dhBits);
		}
		relpSrvSetGnuTLSPriString(pSrv, (char*)inst-&gt;pristring);
		if(relpSrvSetAuthMode(pSrv, (char*)inst-&gt;authmode) != RELP_RET_OK) {
			LogError(0, RS_RET_RELP_ERR,
					&quot;imrelp: invalid auth mode '%s'&quot;, inst-&gt;authmode);
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
		if(relpSrvSetCACert(pSrv, (char*) inst-&gt;caCertFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(relpSrvSetOwnCert(pSrv, (char*) inst-&gt;myCertFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
		if(relpSrvSetPrivKey(pSrv, (char*) inst-&gt;myPrivKeyFile) != RELP_RET_OK)
			ABORT_FINALIZE(RS_RET_RELP_ERR);
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
		if (inst-&gt;tlscfgcmd != NULL) {
			if(relpSrvSetTlsConfigCmd(pSrv, (char*) inst-&gt;tlscfgcmd) != RELP_RET_OK)
				ABORT_FINALIZE(RS_RET_RELP_ERR);
		}
#endif
		for(i = 0 ; i &lt;  inst-&gt;permittedPeers.nmemb ; ++i) {
			relpSrvAddPermittedPeer(pSrv, (char*)inst-&gt;permittedPeers.name[i]);
		}
	}
	relpRet = relpEngineListnerConstructFinalize(pRelpEngine, pSrv);
	/* re-check error TLS error codes. librelp seems to emit them only
	 * after finalize in some cases...
	 */
	if(relpRet == RELP_RET_ERR_NO_TLS) {
		LogError(0, RS_RET_RELP_NO_TLS,
				&quot;imrelp: could not activate relp TLS listener, librelp &quot;
				&quot;does not support it (most probably GnuTLS lib &quot;
				&quot;is too old)!&quot;);
		ABORT_FINALIZE(RS_RET_RELP_NO_TLS);
	} else if(relpRet == RELP_RET_ERR_NO_TLS_AUTH) {
		LogError(0, RS_RET_RELP_NO_TLS_AUTH,
				&quot;imrelp: could not activate relp TLS listener with &quot;
				&quot;authentication, librelp does not support it &quot;
				&quot;(most probably GnuTLS lib is too old)! &quot;
				&quot;Note: anonymous TLS is probably supported.&quot;);
		ABORT_FINALIZE(RS_RET_RELP_NO_TLS_AUTH);
	} else if(relpRet != RELP_RET_OK) {
		LogError(0, RS_RET_RELP_ERR,
				&quot;imrelp: could not activate relp listener, code %d&quot;, relpRet);
		ABORT_FINALIZE(RS_RET_RELP_ERR);
	}

	DBGPRINTF(&quot;imrelp: max data size %zd\n&quot;, inst-&gt;maxDataSize);
	resetConfigVariables(NULL,NULL);

finalize_it:
	RETiRet;
}


<A NAME="3"></A>BEGINnewInpInst
	struct cnfparamvals *pvals;
	instanceConf_t *inst = NULL;
<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#3',2,'match117-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int i,j;
	FILE *fp;
CODESTARTnewInpInst
	DBGPRINTF(&quot;newInpInst (imrelp)\n&quot;);

	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;input param blk in imrelp:\n&quot;);
		cnfparamsPrint(&amp;inppblk, pvals);
	}

	CHKiRet(createInstance(&amp;inst));

	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
<A NAME="2"></A>			continue;
		if(!strcmp(inppblk.descr[i].name, &quot;port&quot;)) {
			inst-&gt;pszBindPort = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#2',2,'match117-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(inppblk.descr[i].name, &quot;address&quot;)) {
			#if defined(HAVE_RELPSRVSETLSTNADDR)
				inst-&gt;pszBindAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			#else
				parser_errmsg(&quot;imrelp: librelp does not support input parameter 'address'; &quot;
					&quot;it probably is too old (1.2.16 should be fine); ignoring setting now, &quot;
					&quot;listening on all interfaces&quot;);
			#endif
		} else if(!strcmp(inppblk.descr[i].name, &quot;name&quot;)) {
			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;ruleset&quot;)) {
			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;maxdatasize&quot;)) {</B></FONT>
			inst-&gt;maxDataSize = (size_t) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;flowcontrol&quot;)) {
			if(!es_strconstcmp(pvals[i].val.d.estr, &quot;none&quot;)) {
				inst-&gt;flowCtlType = eFLOWCTL_NO_DELAY;
			} else if(!es_strconstcmp(pvals[i].val.d.estr, &quot;light&quot;)) {
				inst-&gt;flowCtlType = eFLOWCTL_LIGHT_DELAY;
			} else if(!es_strconstcmp(pvals[i].val.d.estr, &quot;full&quot;)) {
				inst-&gt;flowCtlType = eFLOWCTL_FULL_DELAY;
			} else {
				const char *const mode = es_str2cstr(pvals[i].val.d.estr, NULL);
				parser_errmsg(&quot;imrelp: wrong flowcontrol parameter &quot;
					&quot;value '%s', using default: 'light'; possible &quot;
					&quot;values: 'no', 'light', 'full'\n&quot;, mode);
				free((void*)mode);
			}
		} else if(!strcmp(inppblk.descr[i].name, &quot;oversizemode&quot;)) {
#ifdef HAVE_RELPSRVSETOVERSIZEMODE
			char *mode = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(!strcmp(mode, &quot;abort&quot;)) {
				inst-&gt;oversizeMode = RELP_OVERSIZE_ABORT;
			} else if(!strcmp(mode, &quot;truncate&quot;)) {
				inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
			} else if(!strcmp(mode, &quot;accept&quot;)) {
				inst-&gt;oversizeMode = RELP_OVERSIZE_ACCEPT;
			} else {
				parser_errmsg(&quot;imrelp: wrong oversizeMode parameter &quot;
					&quot;value %s, using default: truncate\n&quot;, mode);
				inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
			}
#else
			parser_errmsg(&quot;imrelp: parameter oversizeMode is not available in &quot;
				&quot;this relp version and is therefore disabled.&quot;);
#endif
		} else if(!strcmp(inppblk.descr[i].name, &quot;keepalive&quot;)) {
			inst-&gt;bKeepAlive = (sbool) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;keepalive.probes&quot;)) {
			inst-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;keepalive.time&quot;)) {
			inst-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;keepalive.interval&quot;)) {
			inst-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls&quot;)) {
			inst-&gt;bEnableTLS = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.dhbits&quot;)) {
			inst-&gt;dhBits = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.prioritystring&quot;)) {
			inst-&gt;pristring = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.authmode&quot;)) {
			inst-&gt;authmode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.compression&quot;)) {
			inst-&gt;bEnableTLSZip = (unsigned) pvals[i].val.d.n;
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.cacert&quot;)) {
			inst-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)inst-&gt;caCertFile, &quot;r&quot;);
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
				inst-&gt;caCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.mycert&quot;)) {
			inst-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)inst-&gt;myCertFile, &quot;r&quot;);
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
				inst-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
			inst-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)inst-&gt;myPrivKeyFile, &quot;r&quot;);
			if(fp == NULL) {
				char errStr[1024];
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
				inst-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.tlscfgcmd&quot;)) {
#if defined(HAVE_RELPENGINESETTLSCFGCMD)
			inst-&gt;tlscfgcmd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
#else
			parser_errmsg(&quot;imrelp: librelp does not support input parameter 'tls.tlscfgcmd'; &quot;
				&quot;it probably is too old (1.5.0 or higher should be fine); ignoring setting now.&quot;);
#endif
		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.permittedpeer&quot;)) {
			inst-&gt;permittedPeers.nmemb = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(inst-&gt;permittedPeers.name =
				malloc(sizeof(uchar*) * inst-&gt;permittedPeers.nmemb));
			for(j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				inst-&gt;permittedPeers.name[j] = (uchar*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
			}
		} else {
			dbgprintf(&quot;imrelp: program error, non-handled &quot;
			  &quot;param '%s'\n&quot;, inppblk.descr[i].name);
		}
	}

	if(inst-&gt;myCertFile  != NULL &amp;&amp; inst-&gt;myPrivKeyFile == NULL) {
		LogError(0, RS_RET_ERR, &quot;imrelp: certificate file given but no corresponding &quot;
			&quot;private key file - this is invalid, listener cannot be started&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(inst-&gt;myCertFile  == NULL &amp;&amp; inst-&gt;myPrivKeyFile != NULL) {
		LogError(0, RS_RET_ERR, &quot;imrelp: private key file given but no corresponding &quot;
			&quot;certificate file - this is invalid, listener cannot be started&quot;);
		ABORT_FINALIZE(RS_RET_ERR);
	}

	inst-&gt;bEnableLstn = -1; /* all ok, ready to start up */

finalize_it:
CODE_STD_FINALIZERnewInpInst
	cnfparamvalsDestruct(pvals, &amp;inppblk);
	if(iRet != RS_RET_OK) {
		if(inst != NULL) {
			free(inst-&gt;myCertFile);
			inst-&gt;myCertFile = NULL;
			free(inst-&gt;myPrivKeyFile);
			inst-&gt;myPrivKeyFile = NULL;
		}
	}
ENDnewInpInst


BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;pszBindRuleset = NULL;
	pModConf-&gt;tlslib = NULL;
	/* init legacy config variables */
	cs.pszBindRuleset = NULL;
	bLegacyCnfModGlobalsPermitted = 1;
ENDbeginCnfLoad
<A NAME="1"></A>

BEGINsetModCnf
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module &quot;
				&quot;config parameters [module(...)]&quot;);
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}

	if(Debug) {
		dbgprintf(&quot;module (global) param blk for imrelp:\n&quot;);
		cnfparamsPrint(&amp;modpblk, pvals);
	}

	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, &quot;ruleset&quot;)) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, &quot;tls.tlslib&quot;)) {</B></FONT>
			#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
				loadModConf-&gt;tlslib = es_str2cstr(pvals[i].val.d.estr, NULL);
			#else
				LogError(0, RS_RET_NOT_IMPLEMENTED,
					&quot;imrelp warning: parameter tls.tlslib ignored - librelp does not support &quot;
					&quot;this API call. Using whatever librelp was compiled with.&quot;);
			#endif
		} else {
			dbgprintf(&quot;imrelp: program error, non-handled &quot;
			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
		}
	}
	/* remove all of our legacy module handlers, as they can not used in addition
	 * the the new-style config method.
<A NAME="7"></A>	 */
	bLegacyCnfModGlobalsPermitted = 0;
finalize_it:
<FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#7',2,'match117-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf

BEGINendCnfLoad
CODESTARTendCnfLoad
	if(loadModConf-&gt;pszBindRuleset == NULL) {
		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
			loadModConf-&gt;pszBindRuleset = NULL;
		} else {
			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));</B></FONT>
		}
	} else {
<A NAME="4"></A>		if((cs.pszBindRuleset != NULL) &amp;&amp; (cs.pszBindRuleset[0] != '\0')) {
			LogError(0, RS_RET_DUP_PARAM, &quot;imrelp: ruleset &quot;
					&quot;set via legacy directive ignored&quot;);
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#4',2,'match117-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		}
	}
finalize_it:
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	loadModConf = NULL; /* done loading */
ENDendCnfLoad

BEGINcheckCnf
	instanceConf_t *inst;
	size_t maxMessageSize;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
		}</B></FONT>
		std_checkRuleset(pModConf, inst);


		if(inst-&gt;maxDataSize == 0) {
			/* We set default value for maxDataSize here because
			 * otherwise the maxMessageSize isn't set.
			 */
			inst-&gt;maxDataSize = glbl.GetMaxLine(loadConf);
		}
		maxMessageSize = (size_t)glbl.GetMaxLine(loadConf);
		if(inst-&gt;maxDataSize &lt; maxMessageSize) {
			LogError(0, RS_RET_INVALID_PARAMS, &quot;error: &quot;
					&quot;maxDataSize (%zu) is smaller than global parameter &quot;
					&quot;maxMessageSize (%zu) - global parameter will be used.&quot;,
					inst-&gt;maxDataSize, maxMessageSize);
			inst-&gt;maxDataSize = maxMessageSize;
		}
	}

finalize_it:
ENDcheckCnf


BEGINactivateCnfPrePrivDrop
	instanceConf_t *inst;
CODESTARTactivateCnfPrePrivDrop
	runModConf = pModConf;
	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		addListner(pModConf, inst);
	}
	if(pRelpEngine == NULL) {
		LogError(0, RS_RET_NO_LSTN_DEFINED, &quot;imrelp: no RELP listener defined, module can not run.&quot;);
		ABORT_FINALIZE(RS_RET_NO_RUN);
	}
finalize_it:
ENDactivateCnfPrePrivDrop

BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf


BEGINfreeCnf
	instanceConf_t *inst, *del;
	int i;
CODESTARTfreeCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
		free(inst-&gt;pszBindPort);
		if (inst-&gt;pszBindAddr != NULL) {
			free(inst-&gt;pszBindAddr);
		}
		free(inst-&gt;pszBindRuleset);
		free(inst-&gt;pszInputName);
		free(inst-&gt;pristring);
		free(inst-&gt;authmode);
		for(i = 0 ; i &lt;  inst-&gt;permittedPeers.nmemb ; ++i) {
			free(inst-&gt;permittedPeers.name[i]);
		}
		if(inst-&gt;bEnableLstn) {
			prop.Destruct(&amp;inst-&gt;pInputName);
			statsobj.Destruct(&amp;(inst-&gt;data.stats));
		}
		del = inst;
		inst = inst-&gt;next;
		free(del);
	}
	free(pModConf-&gt;pszBindRuleset);
ENDfreeCnf

/* This is used to terminate the plugin. Note that the signal handler blocks
 * other activity on the thread. As such, it is safe to request the stop. When
 * we terminate, relpEngine is called, and it's select() loop interrupted. But
 * only *after this function is done*. So we do not have a race!
 */
static void
doSIGTTIN(int __attribute__((unused)) sig)
{
	const int bTerminate = ATOMIC_FETCH_32BIT(&amp;bTerminateInputs, &amp;mutTerminateInputs);
	if(bTerminate) {
		relpEngineSetStop(pRelpEngine);
	}
}


/* This function is called to gather input.
 */
BEGINrunInput
	sigset_t sigSet;
	struct sigaction sigAct;
CODESTARTrunInput
	/* we want to support non-cancel input termination. To do so, we must signal librelp
	 * when to stop. As we run on the same thread, we need to register as SIGTTIN handler,
	 * which will be used to put the terminating condition into librelp.
	 */
	sigfillset(&amp;sigSet);
	pthread_sigmask(SIG_BLOCK, &amp;sigSet, NULL);
	sigemptyset(&amp;sigSet);
	sigaddset(&amp;sigSet, SIGTTIN);
	pthread_sigmask(SIG_UNBLOCK, &amp;sigSet, NULL);
	memset(&amp;sigAct, 0, sizeof (sigAct));
	sigemptyset(&amp;sigAct.sa_mask);
	sigAct.sa_handler = doSIGTTIN;
	sigaction(SIGTTIN, &amp;sigAct, NULL);

	iRet = relpEngineRun(pRelpEngine);
ENDrunInput


BEGINwillRun
CODESTARTwillRun
ENDwillRun


BEGINafterRun
CODESTARTafterRun
	/* do cleanup here */
ENDafterRun


BEGINmodExit
CODESTARTmodExit
	if(pRelpEngine != NULL)
		iRet = relpEngineDestruct(&amp;pRelpEngine);

	/* release objects we used */
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(net, LM_NET_FILENAME);
ENDmodExit


static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	free(cs.pszBindRuleset);
	cs.pszBindRuleset = NULL;
	return RS_RET_OK;
}


BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature


BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt


BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; /* we only support the current interface specification */
CODEmodInit_QueryRegCFSLineHdlr
	pRelpEngine = NULL;
	/* request objects we use */
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(net, LM_NET_FILENAME));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));

	#ifndef HAVE_RELPSRVSETOVERSIZEMODE
		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, &quot;imrelp: librelp too old, oversizemode &quot;
			&quot;defaults to \&quot;abort\&quot;&quot;);
	#endif

	/* register config file handlers */
	CHKiRet(regCfSysLineHdlr2((uchar*)&quot;inputrelpserverbindruleset&quot;, 0, eCmdHdlrGetWord,
				   NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputrelpserverrun&quot;, 0, eCmdHdlrGetWord,
				   addInstance, NULL, STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
