<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for imkafka.c & imrelp.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for imkafka.c & imrelp.c
      </h3>
      <h1 align="center">
        22.7%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>imkafka.c (25.040388%)<TH>imrelp.c (20.861372%)<TH>Tokens
<TR onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-1.html#0',3)" NAME="0">(135-150)<TD><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-1.html#0',3)" NAME="0">(139-154)</A><TD ALIGN=center><FONT COLOR="#ff0000">27</FONT>
<TR onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-1.html#1',3)" NAME="1">(612-632)<TD><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-1.html#1',3)" NAME="1">(694-714)</A><TD ALIGN=center><FONT COLOR="#ec0000">25</FONT>
<TR onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#2',2,'match117-1.html#2',3)" NAME="2">(570-576)<TD><A HREF="javascript:ZweiFrames('match117-0.html#2',2,'match117-1.html#2',3)" NAME="2">(534-546)</A><TD ALIGN=center><FONT COLOR="#cf0000">22</FONT>
<TR onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#3',2,'match117-1.html#3',3)" NAME="3">(532-551)<TD><A HREF="javascript:ZweiFrames('match117-0.html#3',2,'match117-1.html#3',3)" NAME="3">(513-533)</A><TD ALIGN=center><FONT COLOR="#b30000">19</FONT>
<TR onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#4',2,'match117-1.html#4',3)" NAME="4">(649-663)<TD><A HREF="javascript:ZweiFrames('match117-0.html#4',2,'match117-1.html#4',3)" NAME="4">(748-763)</A><TD ALIGN=center><FONT COLOR="#a00000">17</FONT>
<TR onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#5',2,'match117-1.html#5',3)" NAME="5">(272-291)<TD><A HREF="javascript:ZweiFrames('match117-0.html#5',2,'match117-1.html#5',3)" NAME="5">(263-283)</A><TD ALIGN=center><FONT COLOR="#970000">16</FONT>
<TR onclick='openModal("#8c8774")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#8c8774"><FONT COLOR="#8c8774">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#6',2,'match117-1.html#6',3)" NAME="6">(302-319)<TD><A HREF="javascript:ZweiFrames('match117-0.html#6',2,'match117-1.html#6',3)" NAME="6">(304-322)</A><TD ALIGN=center><FONT COLOR="#8d0000">15</FONT>
<TR onclick='openModal("#38a4a5")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"'><TD BGCOLOR="#38a4a5"><FONT COLOR="#38a4a5">-</FONT><TD><A HREF="javascript:ZweiFrames('match117-0.html#7',2,'match117-1.html#7',3)" NAME="7">(638-648)<TD><A HREF="javascript:ZweiFrames('match117-0.html#7',2,'match117-1.html#7',3)" NAME="7">(732-742)</A><TD ALIGN=center><FONT COLOR="#840000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>imkafka.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #include &quot;config.h&quot;
2 #include &lt;stdio.h&gt;
3 #include &lt;stdarg.h&gt;
4 #include &lt;stdlib.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;assert.h&gt;
7 #include &lt;errno.h&gt;
8 #include &lt;fcntl.h&gt;
9 #include &lt;pthread.h&gt;
10 #include &lt;sys/uio.h&gt;
11 #include &lt;librdkafka/rdkafka.h&gt;
12 #include &quot;rsyslog.h&quot;
13 #include &quot;conf.h&quot;
14 #include &quot;syslogd-types.h&quot;
15 #include &quot;srUtils.h&quot;
16 #include &quot;template.h&quot;
17 #include &quot;module-template.h&quot;
18 #include &quot;errmsg.h&quot;
19 #include &quot;atomic.h&quot;
20 #include &quot;statsobj.h&quot;
21 #include &quot;unicode-helper.h&quot;
22 #include &quot;prop.h&quot;
23 #include &quot;ruleset.h&quot;
24 #include &quot;glbl.h&quot;
25 #include &quot;cfsysline.h&quot;
26 #include &quot;msg.h&quot;
27 #include &quot;dirty.h&quot;
28 MODULE_TYPE_INPUT
29 MODULE_TYPE_NOKEEP
30 MODULE_CNFNAME(&quot;imkafka&quot;)
31 DEF_IMOD_STATIC_DATA
32 DEFobjCurrIf(prop)
33 DEFobjCurrIf(ruleset)
34 DEFobjCurrIf(glbl)
35 DEFobjCurrIf(statsobj)
36 static void * imkafkawrkr(void *myself);
37 struct kafka_params {
38 	const char *name;
39 	const char *val;
40 };
41 static struct configSettings_s {
42 	uchar *topic;
43 	uchar *consumergroup;
44 	char *brokers;
45 	uchar *pszBindRuleset;
46 	int nConfParams;
47 	struct kafka_params *confParams;
48 } cs;
49 struct instanceConf_s {
50 	uchar *topic;
51 	uchar *consumergroup;
52 	char *brokers;
53 	int64_t offset;
54 	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;			int bReportErrs;
55 	int nConfParams;
56 	struct kafka_params *confParams;
57 	int bIsConnected;
58 	rd_kafka_conf_t *conf;
59 	rd_kafka_t *rk;
60 	rd_kafka_topic_conf_t *topic_conf;
61 	int partition;
62 	int bIsSubscribed;
63 	int nMsgParsingFlags;
64 	struct instanceConf_s *next;
65 };
66 struct modConfData_s {
67 	rsconf_t *pConf;			uchar *topic;
68 	uchar *consumergroup;
69 	char *brokers;
70 	instanceConf_t *root, *tail;
71 	ruleset_t *pBindRuleset;		uchar *pszBindRuleset;		};
72 pthread_attr_t wrkrThrdAttr;	static int activeKafkaworkers = 0;
73 static struct kafkaWrkrInfo_s {
74 	pthread_t tid;			instanceConf_t *inst;	} *kafkaWrkrInfo;
75 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
76 static prop_t *pInputName = NULL;
77 <A NAME="0"></A>
78 static struct cnfparamdescr modpdescr[] = {
79 <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match117-1.html#0',3,'match117-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	{ &quot;ruleset&quot;, eCmdHdlrGetWord, 0 },
80 };
81 static struct cnfparamblk modpblk =
82 	{ CNFPARAMBLK_VERSION,
83 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
84 	  modpdescr
85 	};
86 static struct cnfparamdescr inppdescr[] = {
87 	{ &quot;topic&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
88 	{ &quot;broker&quot;, eCmdHdlrArray, 0 },
89 	{ &quot;confparam&quot;, eCmdHdlrArray, 0 },
90 	{ &quot;consumergroup&quot;, eCmdHdlrString, 0},
91 	{ &quot;ruleset&quot;, eCmdHdlrString, 0 },
92 	{ &quot;parsehostname&quot;, eCmdHdlrBinary, 0 },</B></FONT>
93 };
94 static struct cnfparamblk inppblk =
95 	{ CNFPARAMBLK_VERSION,
96 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
97 	  inppdescr
98 	};
99 #include &quot;im-helper.h&quot; 
100 static void
101 kafkaLogger(const rd_kafka_t __attribute__((unused)) *rk, int level,
102 	    const char *fac, const char *buf)
103 {
104 	DBGPRINTF(&quot;imkafka: kafka log message [%d,%s]: %s\n&quot;,
105 		  level, fac, buf);
106 }
107 static rsRetVal enqMsg(instanceConf_t *const __restrict__ inst,
108 			rd_kafka_message_t *const __restrict__ rkmessage)
109 {
110 	DEFiRet;
111 	smsg_t *pMsg;
112 	if((int)rkmessage-&gt;len == 0) {
113 		FINALIZE;
114 	}
115 DBGPRINTF(&quot;imkafka: enqMsg: Msg: %.*s\n&quot;, (int)rkmessage-&gt;len, (char *)rkmessage-&gt;payload);
116 	CHKiRet(msgConstruct(&amp;pMsg));
117 	MsgSetInputName(pMsg, pInputName);
118 	MsgSetRawMsg(pMsg, (char*)rkmessage-&gt;payload, (int)rkmessage-&gt;len);
119 	MsgSetFlowControlType(pMsg, eFLOWCTL_LIGHT_DELAY);
120 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
121 	pMsg-&gt;msgFlags  = inst-&gt;nMsgParsingFlags;
122 	if (rkmessage-&gt;key_len) {
123 		DBGPRINTF(&quot;imkafka: enqMsg: Key: %.*s\n&quot;, (int)rkmessage-&gt;key_len, (char *)rkmessage-&gt;key);
124 		MsgSetTAG(pMsg, (const uchar *)rkmessage-&gt;key, (int)rkmessage-&gt;key_len);
125 	}
126 	MsgSetMSGoffs(pMsg, 0);	
127 	CHKiRet(submitMsg2(pMsg));
128 finalize_it:
129 	RETiRet;
130 }
131 static void msgConsume (instanceConf_t *inst) {
132 	rd_kafka_message_t *rkmessage = NULL;
133 	do { 		rkmessage = rd_kafka_consumer_poll(inst-&gt;rk, 1000); 		if(rkmessage == NULL) {
134 			DBGPRINTF(&quot;imkafka: msgConsume EMPTY Loop on %s/%s/%s\n&quot;,
135 				inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
136 			goto done;
137 		}
138 		if (rkmessage-&gt;err) {
139 			if (rkmessage-&gt;err == RD_KAFKA_RESP_ERR__PARTITION_EOF) {
140 				DBGPRINTF(&quot;imkafka: Consumer &quot;
141 					&quot;reached end of topic \&quot;%s\&quot; [%&quot;PRId32&quot;]&quot;
142 					&quot;message queue offset %&quot;PRId64&quot;\n&quot;,
143 					rd_kafka_topic_name(rkmessage-&gt;rkt),
144 					rkmessage-&gt;partition,
145 					rkmessage-&gt;offset);
146 				goto done;
147 			}
148 			if (rkmessage-&gt;rkt) {
149 				LogError(0, RS_RET_KAFKA_ERROR,
150 				&quot;imkafka: Consumer error for topic \&quot;%s\&quot; [%&quot;PRId32&quot;]&quot;
151 				&quot;message queue offset %&quot;PRId64&quot;: %s\n&quot;,
152 					rd_kafka_topic_name(rkmessage-&gt;rkt),
153 					rkmessage-&gt;partition,
154 					rkmessage-&gt;offset,
155 					rd_kafka_message_errstr(rkmessage));
156 			} else {
157 				LogError(0, RS_RET_KAFKA_ERROR,
158 					&quot;imkafka: Consumer error for topic \&quot;%s\&quot;: \&quot;%s\&quot;\n&quot;,
159 					rd_kafka_err2str(rkmessage-&gt;err),
160 					rd_kafka_message_errstr(rkmessage));
161 			}
162 			goto done;
163 		}
164 		DBGPRINTF(&quot;imkafka: msgConsume Loop on %s/%s/%s: [%&quot;PRId32&quot;], &quot;
165 					&quot;offset %&quot;PRId64&quot;, %zd bytes):\n&quot;,
166 					inst-&gt;consumergroup,
167 					inst-&gt;brokers,
168 					rkmessage-&gt;partition,
169 					rkmessage-&gt;offset,
170 					rkmessage-&gt;len);
171 		enqMsg(inst, rkmessage);
172 		rd_kafka_message_destroy(rkmessage);
173 		rkmessage = NULL;
174 	} while(1); done:
175 	if(rkmessage != NULL) {
176 <A NAME="5"></A>		rd_kafka_message_destroy(rkmessage);
177 	}
178 	return;
179 <FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match117-1.html#5',3,'match117-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
180 static rsRetVal
181 createInstance(instanceConf_t **pinst)
182 {
183 	instanceConf_t *inst;
184 	DEFiRet;
185 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
186 	inst-&gt;next = NULL;
187 	inst-&gt;brokers = NULL;
188 	inst-&gt;topic = NULL;
189 	inst-&gt;consumergroup = NULL;
190 	inst-&gt;pszBindRuleset = NULL;
191 	inst-&gt;nConfParams = 0;</B></FONT>
192 	inst-&gt;confParams = NULL;
193 	inst-&gt;pBindRuleset = NULL;
194 	inst-&gt;bReportErrs = 1; 	inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
195 	inst-&gt;bIsConnected = 0;
196 	inst-&gt;bIsSubscribed = 0;
197 <A NAME="6"></A>	inst-&gt;conf = NULL;
198 	inst-&gt;rk = NULL;
199 	inst-&gt;topic_conf = NULL;
200 <FONT color="#8c8774"><A HREF="javascript:ZweiFrames('match117-1.html#6',3,'match117-top.html#6',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	inst-&gt;partition = RD_KAFKA_PARTITION_UA;
201 	if(loadModConf-&gt;tail == NULL) {
202 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
203 	} else {
204 		loadModConf-&gt;tail-&gt;next = inst;
205 		loadModConf-&gt;tail = inst;
206 	}
207 	*pinst = inst;
208 finalize_it:
209 	RETiRet;
210 }
211 static rsRetVal ATTR_NONNULL()</B></FONT>
212 checkInstance(instanceConf_t *const inst)
213 {
214 	DEFiRet;
215 	char kafkaErrMsg[1024];
216 	inst-&gt;conf = rd_kafka_conf_new();
217 	if(inst-&gt;conf == NULL) {
218 		if(inst-&gt;bReportErrs) {
219 			LogError(0, RS_RET_KAFKA_ERROR,
220 				&quot;imkafka: error creating kafka conf obj: %s\n&quot;,
221 				rd_kafka_err2str(rd_kafka_last_error()));
222 		}
223 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
224 	}
225 #	ifdef DEBUG
226 	if(rd_kafka_conf_set(inst-&gt;conf, &quot;debug&quot;, RD_KAFKA_DEBUG_CONTEXTS,
227 		kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
228 		LogError(0, RS_RET_KAFKA_ERROR, &quot;imkafka: error setting kafka debug option: %s\n&quot;, kafkaErrMsg);
229 	}
230 #	endif
231 	for(int i = 0 ; i &lt; inst-&gt;nConfParams ; ++i) {
232 		assert(inst-&gt;confParams+i != NULL); 		DBGPRINTF(&quot;imkafka: setting custom configuration parameter: %s:%s\n&quot;,
233 			inst-&gt;confParams[i].name,
234 			inst-&gt;confParams[i].val);
235 		if(rd_kafka_conf_set(inst-&gt;conf,
236 			inst-&gt;confParams[i].name,
237 			inst-&gt;confParams[i].val,
238 			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
239 			if(inst-&gt;bReportErrs) {
240 				LogError(0, RS_RET_PARAM_ERROR, &quot;error setting custom configuration &quot;
241 					&quot;parameter '%s=%s': %s&quot;,
242 					inst-&gt;confParams[i].name,
243 					inst-&gt;confParams[i].val, kafkaErrMsg);
244 			} else {
245 				DBGPRINTF(&quot;imkafka: error setting custom configuration parameter '%s=%s': %s&quot;,
246 					inst-&gt;confParams[i].name,
247 					inst-&gt;confParams[i].val, kafkaErrMsg);
248 			}
249 			ABORT_FINALIZE(RS_RET_PARAM_ERROR);
250 		}
251 	}
252 	inst-&gt;topic_conf = rd_kafka_topic_conf_new();
253 	if (inst-&gt;consumergroup != NULL) {
254 		DBGPRINTF(&quot;imkafka: setting consumergroup: '%s'\n&quot;, inst-&gt;consumergroup);
255 		if (rd_kafka_conf_set(inst-&gt;conf, &quot;group.id&quot;, (char*) inst-&gt;consumergroup,
256 			kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
257 			if(inst-&gt;bReportErrs) {
258 				LogError(0, RS_RET_KAFKA_ERROR,
259 					&quot;imkafka: error assigning consumergroup %s to &quot;
260 					&quot;kafka config: %s\n&quot;, inst-&gt;consumergroup,
261 					kafkaErrMsg);
262 			}
263 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
264 		}
265 		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, &quot;auto.offset.reset&quot;,
266 			&quot;smallest&quot;, kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
267 			if(inst-&gt;bReportErrs) {
268 				LogError(0, RS_RET_KAFKA_ERROR,
269 					&quot;imkafka: error setting kafka auto.offset.reset on %s: %s\n&quot;,
270 					inst-&gt;consumergroup,
271 					kafkaErrMsg);
272 			}
273 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
274 		}
275 		if (rd_kafka_topic_conf_set(inst-&gt;topic_conf, &quot;offset.store.method&quot;,
276 			&quot;broker&quot;, kafkaErrMsg, sizeof(kafkaErrMsg)) != RD_KAFKA_CONF_OK) {
277 			if(inst-&gt;bReportErrs) {
278 				LogError(0, RS_RET_KAFKA_ERROR,
279 					&quot;imkafka: error setting kafka offset.store.method on %s: %s\n&quot;,
280 					inst-&gt;consumergroup,
281 					kafkaErrMsg);
282 			}
283 			ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
284 		}
285 		rd_kafka_conf_set_default_topic_conf(inst-&gt;conf, inst-&gt;topic_conf);
286 	}
287 	#if RD_KAFKA_VERSION &gt;= 0x00090001
288 		rd_kafka_conf_set_log_cb(inst-&gt;conf, kafkaLogger);
289 	#endif
290 	inst-&gt;rk = rd_kafka_new(RD_KAFKA_CONSUMER, inst-&gt;conf,
291 				     kafkaErrMsg, sizeof(kafkaErrMsg));
292 	if(inst-&gt;rk == NULL) {
293 		if(inst-&gt;bReportErrs) {
294 			LogError(0, RS_RET_KAFKA_ERROR,
295 				&quot;imkafka: error creating kafka handle: %s\n&quot;, kafkaErrMsg);
296 		}
297 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
298 	}
299 	#if RD_KAFKA_VERSION &lt; 0x00090001
300 		rd_kafka_set_logger(inst-&gt;rk, kafkaLogger);
301 	#endif
302 	DBGPRINTF(&quot;imkafka: setting brokers: '%s'\n&quot;, inst-&gt;brokers);
303 	if(rd_kafka_brokers_add(inst-&gt;rk, (char*)inst-&gt;brokers) == 0) {
304 		if(inst-&gt;bReportErrs) {
305 			LogError(0, RS_RET_KAFKA_NO_VALID_BROKERS,
306 				&quot;imkafka: no valid brokers specified: %s&quot;, inst-&gt;brokers);
307 		}
308 		ABORT_FINALIZE(RS_RET_KAFKA_NO_VALID_BROKERS);
309 	}
310 	inst-&gt;bIsConnected = 1;
311 finalize_it:
312 	if(iRet != RS_RET_OK) {
313 		if(inst-&gt;rk == NULL) {
314 			if(inst-&gt;conf != NULL) {
315 				rd_kafka_conf_destroy(inst-&gt;conf);
316 				inst-&gt;conf = NULL;
317 			}
318 		} else { 			rd_kafka_destroy(inst-&gt;rk);
319 			inst-&gt;rk = NULL;
320 		}
321 	}
322 	RETiRet;
323 }
324 static inline void
325 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
326 {
327 	if(inst-&gt;bReportErrs) {
328 		LogError(0, NO_ERRCODE, &quot;imkafka: ruleset '%s' not found - &quot;
329 			&quot;using default ruleset instead&quot;,
330 			inst-&gt;pszBindRuleset);
331 	}
332 }
333 static rsRetVal ATTR_NONNULL(2)
334 addConsumer(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
335 {
336 	DEFiRet;
337 	rd_kafka_resp_err_t err;
338 	assert(inst != NULL);
339 	rd_kafka_topic_partition_list_t *topics = NULL;
340 	DBGPRINTF(&quot;imkafka: creating kafka consumer on %s/%s/%s\n&quot;,
341 		inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
342 	rd_kafka_poll_set_consumer(inst-&gt;rk);
343 	topics = rd_kafka_topic_partition_list_new(1);
344 	rd_kafka_topic_partition_list_add(topics, (const char*)inst-&gt;topic, inst-&gt;partition);
345 	DBGPRINTF(&quot;imkafka: Created topics(%d) for %s)\n&quot;,
346 		topics-&gt;cnt, inst-&gt;topic);
347 	if ((err = rd_kafka_subscribe(inst-&gt;rk, topics))) {
348 		inst-&gt;bIsSubscribed = 0;
349 		LogError(0, RS_RET_KAFKA_ERROR, &quot;imkafka: Failed to start consuming &quot;
350 			&quot;topics: %s\n&quot;, rd_kafka_err2str(err));
351 		ABORT_FINALIZE(RS_RET_KAFKA_ERROR);
352 	} else {
353 		DBGPRINTF(&quot;imkafka: Successfully subscribed to %s/%s/%s\n&quot;,
354 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
355 		inst-&gt;bIsSubscribed = 1;
356 	}
357 finalize_it:
358 	if(topics != NULL)
359 		rd_kafka_topic_partition_list_destroy(topics);
360 	RETiRet;
361 }
362 static rsRetVal ATTR_NONNULL()
363 processKafkaParam(char *const param,
364 	const char **const name,
365 	const char **const paramval)
366 {
367 	DEFiRet;
368 	char *val = strstr(param, &quot;=&quot;);
369 	if(val == NULL) {
370 		LogError(0, RS_RET_PARAM_ERROR, &quot;missing equal sign in &quot;
371 				&quot;parameter '%s'&quot;, param);
372 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
373 	}
374 	*val = '\0'; 	++val; 	CHKmalloc(*name = strdup(param));
375 	CHKmalloc(*paramval = strdup(val));
376 finalize_it:
377 	RETiRet;
378 }
379 <A NAME="3"></A>BEGINnewInpInst
380 	struct cnfparamvals *pvals;
381 	instanceConf_t *inst;
382 <FONT color="#53858b"><A HREF="javascript:ZweiFrames('match117-1.html#3',3,'match117-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int i;
383 CODESTARTnewInpInst
384 	DBGPRINTF(&quot;newInpInst (imkafka)\n&quot;);
385 	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
386 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
387 	}
388 	if(Debug) {
389 		dbgprintf(&quot;input param blk in imkafka:\n&quot;);
390 		cnfparamsPrint(&amp;inppblk, pvals);
391 	}
392 	CHKiRet(createInstance(&amp;inst));
393 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
394 		if(!pvals[i].bUsed)
395 			continue;
396 		if(!strcmp(inppblk.descr[i].name, &quot;broker&quot;)) {
397 			es_str_t *es = es_newStr(128);</B></FONT>
398 			int bNeedComma = 0;
399 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
400 				if(bNeedComma)
401 					es_addChar(&amp;es, ',');
402 				es_addStr(&amp;es, pvals[i].val.d.ar-&gt;arr[j]);
403 				bNeedComma = 1;
404 			}
405 			inst-&gt;brokers = es_str2cstr(es, NULL);
406 			es_deleteStr(es);
407 		} else if(!strcmp(inppblk.descr[i].name, &quot;confparam&quot;)) {
408 			inst-&gt;nConfParams = pvals[i].val.d.ar-&gt;nmemb;
409 			CHKmalloc(inst-&gt;confParams = malloc(sizeof(struct kafka_params)*inst-&gt;nConfParams));
410 			for(int j = 0; j &lt; inst-&gt;nConfParams; j++) {
411 				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
412 				CHKiRet(processKafkaParam(cstr, &amp;inst-&gt;confParams[j].name,
413 <A NAME="2"></A>								&amp;inst-&gt;confParams[j].val));
414 				free(cstr);
415 			}
416 <FONT color="#980517"><A HREF="javascript:ZweiFrames('match117-1.html#2',3,'match117-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		} else if(!strcmp(inppblk.descr[i].name, &quot;topic&quot;)) {
417 			inst-&gt;topic = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
418 		} else if(!strcmp(inppblk.descr[i].name, &quot;consumergroup&quot;)) {
419 			inst-&gt;consumergroup = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
420 		} else if(!strcmp(inppblk.descr[i].name, &quot;ruleset&quot;)) {
421 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
422 		} else if(!strcmp(inppblk.descr[i].name, &quot;parsehostname&quot;)) {</B></FONT>
423 			if (pvals[i].val.d.n) {
424 				inst-&gt;nMsgParsingFlags = NEEDS_PARSING | PARSE_HOSTNAME;
425 			} else {
426 				inst-&gt;nMsgParsingFlags = NEEDS_PARSING;
427 			}
428 		} else {
429 			dbgprintf(&quot;imkafka: program error, non-handled &quot;
430 			  &quot;param '%s'\n&quot;, inppblk.descr[i].name);
431 		}
432 	}
433 	if(inst-&gt;brokers == NULL) {
434 		CHKmalloc(inst-&gt;brokers = strdup(&quot;localhost:9092&quot;));
435 		LogMsg(0, NO_ERRCODE, LOG_INFO, &quot;imkafka: \&quot;broker\&quot; parameter not specified &quot;
436 			&quot;using default of localhost:9092 -- this may not be what you want!&quot;);
437 	}
438 	DBGPRINTF(&quot;imkafka: newInpIns brokers=%s, topic=%s, consumergroup=%s\n&quot;,
439 		inst-&gt;brokers, inst-&gt;topic, inst-&gt;consumergroup);
440 finalize_it:
441 CODE_STD_FINALIZERnewInpInst
442 	cnfparamvalsDestruct(pvals, &amp;inppblk);
443 ENDnewInpInst
444 BEGINbeginCnfLoad
445 CODESTARTbeginCnfLoad
446 	loadModConf = pModConf;
447 	pModConf-&gt;pConf = pConf;
448 	pModConf-&gt;pszBindRuleset = NULL;
449 ENDbeginCnfLoad
450 <A NAME="1"></A>
451 BEGINsetModCnf
452 <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match117-1.html#1',3,'match117-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	struct cnfparamvals *pvals = NULL;
453 	int i;
454 CODESTARTsetModCnf
455 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
456 	if(pvals == NULL) {
457 		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;imkafka: error processing module &quot;
458 			&quot;config parameters [module(...)]&quot;);
459 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
460 	}
461 	if(Debug) {
462 		dbgprintf(&quot;module (global) param blk for imkafka:\n&quot;);
463 		cnfparamsPrint(&amp;modpblk, pvals);
464 	}
465 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
466 		if(!pvals[i].bUsed)
467 			continue;
468 		if(!strcmp(modpblk.descr[i].name, &quot;ruleset&quot;)) {
469 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
470 		} else {</B></FONT>
471 			dbgprintf(&quot;imkafka: program error, non-handled &quot;
472 			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
473 <A NAME="7"></A>		}
474 	}
475 finalize_it:
476 <FONT color="#38a4a5"><A HREF="javascript:ZweiFrames('match117-1.html#7',3,'match117-top.html#7',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	if(pvals != NULL)
477 		cnfparamvalsDestruct(pvals, &amp;modpblk);
478 ENDsetModCnf
479 BEGINendCnfLoad
480 CODESTARTendCnfLoad
481 	if(loadModConf-&gt;pszBindRuleset == NULL) {
482 		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
483 <A NAME="4"></A>			loadModConf-&gt;pszBindRuleset = NULL;
484 		} else {
485 			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));</B></FONT>
486 <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match117-1.html#4',3,'match117-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		}
487 	}
488 finalize_it:
489 	free(cs.pszBindRuleset);
490 	cs.pszBindRuleset = NULL;
491 	loadModConf = NULL; ENDendCnfLoad
492 BEGINcheckCnf
493 	instanceConf_t *inst;
494 CODESTARTcheckCnf
495 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
496 		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
497 			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
498 		}</B></FONT>
499 		std_checkRuleset(pModConf, inst);
500 	}
501 finalize_it:
502 ENDcheckCnf
503 BEGINactivateCnfPrePrivDrop
504 CODESTARTactivateCnfPrePrivDrop
505 	runModConf = pModConf;
506 ENDactivateCnfPrePrivDrop
507 BEGINactivateCnf
508 CODESTARTactivateCnf
509 	for(instanceConf_t *inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
510 		iRet = checkInstance(inst);
511 	}
512 ENDactivateCnf
513 BEGINfreeCnf
514 	instanceConf_t *inst, *del;
515 CODESTARTfreeCnf
516 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
517 		free(inst-&gt;topic);
518 		free(inst-&gt;consumergroup);
519 		free(inst-&gt;brokers);
520 		free(inst-&gt;pszBindRuleset);
521 		for(int i = 0; i &lt; inst-&gt;nConfParams; i++) {
522 			free((void*)inst-&gt;confParams[i].name);
523 			free((void*)inst-&gt;confParams[i].val);
524 		}
525 		free((void*)inst-&gt;confParams);
526 		del = inst;
527 		inst = inst-&gt;next;
528 		free(del);
529 	}
530 	free(pModConf-&gt;pszBindRuleset);
531 ENDfreeCnf
532 static void
533 shutdownKafkaWorkers(void)
534 {
535 	int i;
536 	instanceConf_t *inst;
537 	assert(kafkaWrkrInfo != NULL);
538 	DBGPRINTF(&quot;imkafka: waiting on imkafka workerthread termination\n&quot;);
539 	for(i = 0 ; i &lt; activeKafkaworkers ; ++i) {
540 		pthread_join(kafkaWrkrInfo[i].tid, NULL);
541 		DBGPRINTF(&quot;imkafka: Stopped worker %d\n&quot;, i);
542 	}
543 	free(kafkaWrkrInfo);
544 	kafkaWrkrInfo = NULL;
545 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
546 		DBGPRINTF(&quot;imkafka: stop consuming %s/%s/%s\n&quot;,
547 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
548 		rd_kafka_consumer_close(inst-&gt;rk); 		rd_kafka_destroy(inst-&gt;rk); 		DBGPRINTF(&quot;imkafka: stopped consuming %s/%s/%s\n&quot;,
549 			inst-&gt;topic, inst-&gt;consumergroup, inst-&gt;brokers);
550 		#if RD_KAFKA_VERSION &lt; 0x00090001
551 		if (rd_kafka_wait_destroyed(10000) &lt; 0)	{
552 			DBGPRINTF(&quot;imkafka: error, rd_kafka_destroy did not finish after grace &quot;
553 				&quot;timeout (10s)!\n&quot;);
554 		} else {
555 			DBGPRINTF(&quot;imkafka: rd_kafka_destroy successfully finished\n&quot;);
556 		}
557 		#endif
558 	}
559 }
560 BEGINrunInput
561 	int i;
562 	instanceConf_t *inst;
563 CODESTARTrunInput
564 	DBGPRINTF(&quot;imkafka: runInput loop started ...\n&quot;);
565 	activeKafkaworkers = 0;
566 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
567 		if(inst-&gt;rk != NULL) {
568 			++activeKafkaworkers;
569 		}
570 	}
571 	if(activeKafkaworkers == 0) {
572 		LogError(0, RS_RET_ERR, &quot;imkafka: no active inputs, input does &quot;
573 			&quot;not run - there should have been additional error &quot;
574 			&quot;messages given previously&quot;);
575 		ABORT_FINALIZE(RS_RET_ERR);
576 	}
577 	DBGPRINTF(&quot;imkafka: Starting %d imkafka workerthreads\n&quot;, activeKafkaworkers);
578 	kafkaWrkrInfo = calloc(activeKafkaworkers, sizeof(struct kafkaWrkrInfo_s));
579 	if (kafkaWrkrInfo == NULL) {
580 		LogError(errno, RS_RET_OUT_OF_MEMORY, &quot;imkafka: worker-info array allocation failed.&quot;);
581 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
582 	}
583 	i = 0;
584 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
585 		kafkaWrkrInfo[i].inst = inst; 		pthread_create(&amp;kafkaWrkrInfo[i].tid, &amp;wrkrThrdAttr, imkafkawrkr, &amp;(kafkaWrkrInfo[i]));
586 		i++;
587 	}
588 	while(glbl.GetGlobalInputTermState() == 0) {
589 		if(glbl.GetGlobalInputTermState() == 0)
590 			srSleep(0, 100000);
591 	}
592 	DBGPRINTF(&quot;imkafka: terminating upon request of rsyslog core\n&quot;);
593 	shutdownKafkaWorkers();
594 finalize_it:
595 ENDrunInput
596 BEGINwillRun
597 CODESTARTwillRun
598 	CHKiRet(prop.Construct(&amp;pInputName));
599 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT(&quot;imkafka&quot;), sizeof(&quot;imkafka&quot;) - 1));
600 	CHKiRet(prop.ConstructFinalize(pInputName));
601 finalize_it:
602 ENDwillRun
603 BEGINafterRun
604 CODESTARTafterRun
605 	if(pInputName != NULL)
606 		prop.Destruct(&amp;pInputName);
607 ENDafterRun
608 BEGINmodExit
609 CODESTARTmodExit
610 	pthread_attr_destroy(&amp;wrkrThrdAttr);
611 	objRelease(statsobj, CORE_COMPONENT);
612 	objRelease(ruleset, CORE_COMPONENT);
613 	objRelease(glbl, CORE_COMPONENT);
614 	objRelease(prop, CORE_COMPONENT);
615 ENDmodExit
616 BEGINisCompatibleWithFeature
617 CODESTARTisCompatibleWithFeature
618 	if(eFeat == sFEATURENonCancelInputTermination)
619 		iRet = RS_RET_OK;
620 ENDisCompatibleWithFeature
621 BEGINqueryEtryPt
622 CODESTARTqueryEtryPt
623 CODEqueryEtryPt_STD_IMOD_QUERIES
624 CODEqueryEtryPt_STD_CONF2_QUERIES
625 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
626 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
627 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
628 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
629 ENDqueryEtryPt
630 BEGINmodInit()
631 CODESTARTmodInit
632 	*ipIFVersProvided = CURR_MOD_IF_VERSION;
633 CODEmodInit_QueryRegCFSLineHdlr
634 	CHKiRet(objUse(glbl, CORE_COMPONENT));
635 	CHKiRet(objUse(prop, CORE_COMPONENT));
636 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
637 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
638 	pthread_attr_init(&amp;wrkrThrdAttr);
639 	pthread_attr_setstacksize(&amp;wrkrThrdAttr, 4096*1024);
640 	DBGPRINTF(&quot;imkafka %s using librdkafka version %s, 0x%x\n&quot;,
641 		VERSION, rd_kafka_version_str(), rd_kafka_version());
642 ENDmodInit
643 static void *
644 imkafkawrkr(void *myself)
645 {
646 	struct kafkaWrkrInfo_s *me = (struct kafkaWrkrInfo_s*) myself;
647 	DBGPRINTF(&quot;imkafka: started kafka consumer workerthread on %s/%s/%s\n&quot;,
648 		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
649 	do {
650 		if(glbl.GetGlobalInputTermState() == 1)
651 			break; 
652 		if(me-&gt;inst-&gt;rk == NULL) {
653 			continue;
654 		}
655 		if(me-&gt;inst-&gt;bIsConnected == 1 &amp;&amp; me-&gt;inst-&gt;bIsSubscribed == 0 ) {
656 			addConsumer(runModConf, me-&gt;inst);
657 		}
658 		if(me-&gt;inst-&gt;bIsSubscribed == 1 ) {
659 			msgConsume(me-&gt;inst);
660 		}
661 		if(glbl.GetGlobalInputTermState() == 0)
662 			srSleep(0, 100000);
663 	} while(glbl.GetGlobalInputTermState() == 0);
664 	DBGPRINTF(&quot;imkafka: stopped kafka consumer workerthread on %s/%s/%s\n&quot;,
665 		me-&gt;inst-&gt;topic, me-&gt;inst-&gt;consumergroup, me-&gt;inst-&gt;brokers);
666 	return NULL;
667 }
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>imrelp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
1 #include &quot;config.h&quot;
2 #include &lt;stdlib.h&gt;
3 #include &lt;assert.h&gt;
4 #include &lt;string.h&gt;
5 #include &lt;errno.h&gt;
6 #include &lt;unistd.h&gt;
7 #include &lt;stdarg.h&gt;
8 #include &lt;ctype.h&gt;
9 #include &lt;netinet/in.h&gt;
10 #include &lt;netdb.h&gt;
11 #include &lt;sys/types.h&gt;
12 #include &lt;sys/socket.h&gt;
13 #include &lt;signal.h&gt;
14 #include &lt;librelp.h&gt;
15 #include &quot;rsyslog.h&quot;
16 #include &quot;dirty.h&quot;
17 #include &quot;errmsg.h&quot;
18 #include &quot;cfsysline.h&quot;
19 #include &quot;module-template.h&quot;
20 #include &quot;net.h&quot;
21 #include &quot;msg.h&quot;
22 #include &quot;unicode-helper.h&quot;
23 #include &quot;prop.h&quot;
24 #include &quot;ruleset.h&quot;
25 #include &quot;glbl.h&quot;
26 #include &quot;statsobj.h&quot;
27 #include &quot;srUtils.h&quot;
28 #include &quot;parserif.h&quot;
29 MODULE_TYPE_INPUT
30 MODULE_TYPE_NOKEEP
31 MODULE_CNFNAME(&quot;imrelp&quot;)
32 DEF_IMOD_STATIC_DATA
33 DEFobjCurrIf(net)
34 DEFobjCurrIf(prop)
35 DEFobjCurrIf(ruleset)
36 DEFobjCurrIf(glbl)
37 DEFobjCurrIf(statsobj)
38 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal);
39 static relpEngine_t *pRelpEngine;	
40 typedef struct configSettings_s {
41 	uchar *pszBindRuleset;		} configSettings_t;
42 static configSettings_t cs;
43 struct instanceConf_s {
44 	uchar *pszBindPort;			uchar *pszBindAddr;			uchar *pszBindRuleset;			uchar *pszInputName;			prop_t *pInputName;			ruleset_t *pBindRuleset;		sbool bKeepAlive;			sbool bEnableTLS;
45 	sbool bEnableTLSZip;
46 	sbool bEnableLstn;			int dhBits;
47 	size_t maxDataSize;
48 	int oversizeMode;
49 	uchar *pristring;			uchar *authmode;			uchar *caCertFile;
50 	uchar *myCertFile;
51 	uchar *myPrivKeyFile;
52 #if defined(HAVE_RELPENGINESETTLSCFGCMD)
53 	uchar *tlscfgcmd;
54 #endif
55 	int iKeepAliveIntvl;
56 	int iKeepAliveProbes;
57 	int iKeepAliveTime;
58 	flowControl_t flowCtlType;
59 	struct {
60 		int nmemb;
61 		uchar **name;
62 	} permittedPeers;
63 	struct instanceConf_s *next;
64 	struct {
65 		statsobj_t *stats;			STATSCOUNTER_DEF(ctrSubmit, mutCtrSubmit)
66 	} data;
67 };
68 struct modConfData_s {
69 	rsconf_t *pConf;			instanceConf_t *root, *tail;
70 	const char *tlslib;
71 	uchar *pszBindRuleset;		};
72 static modConfData_t *loadModConf = NULL;static modConfData_t *runModConf = NULL;
73 <A NAME="0"></A>static struct cnfparamdescr modpdescr[] = {
74 	{ &quot;ruleset&quot;, eCmdHdlrGetWord, 0 },
75 <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#0',2,'match117-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	{ &quot;tls.tlslib&quot;, eCmdHdlrString, 0 }
76 };
77 static struct cnfparamblk modpblk =
78 	{ CNFPARAMBLK_VERSION,
79 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
80 	  modpdescr
81 	};
82 static struct cnfparamdescr inppdescr[] = {
83 	{ &quot;port&quot;, eCmdHdlrString, CNFPARAM_REQUIRED },
84 	{ &quot;address&quot;, eCmdHdlrString, 0 },
85 	{ &quot;name&quot;, eCmdHdlrString, 0 },
86 	{ &quot;ruleset&quot;, eCmdHdlrString, 0 },
87 	{ &quot;keepalive&quot;, eCmdHdlrBinary, 0 },
88 	{ &quot;keepalive.probes&quot;, eCmdHdlrInt, 0 },</B></FONT>
89 	{ &quot;keepalive.time&quot;, eCmdHdlrInt, 0 },
90 	{ &quot;keepalive.interval&quot;, eCmdHdlrInt, 0 },
91 	{ &quot;maxdatasize&quot;, eCmdHdlrSize, 0 },
92 	{ &quot;oversizemode&quot;, eCmdHdlrString, 0 },
93 	{ &quot;flowcontrol&quot;, eCmdHdlrGetWord, 0 },
94 	{ &quot;tls&quot;, eCmdHdlrBinary, 0 },
95 	{ &quot;tls.permittedpeer&quot;, eCmdHdlrArray, 0 },
96 	{ &quot;tls.authmode&quot;, eCmdHdlrString, 0 },
97 	{ &quot;tls.dhbits&quot;, eCmdHdlrInt, 0 },
98 	{ &quot;tls.prioritystring&quot;, eCmdHdlrString, 0 },
99 	{ &quot;tls.cacert&quot;, eCmdHdlrString, 0 },
100 	{ &quot;tls.mycert&quot;, eCmdHdlrString, 0 },
101 	{ &quot;tls.myprivkey&quot;, eCmdHdlrString, 0 },
102 	{ &quot;tls.tlscfgcmd&quot;, eCmdHdlrString, 0 },
103 	{ &quot;tls.compression&quot;, eCmdHdlrBinary, 0 }
104 };
105 static struct cnfparamblk inppblk =
106 	{ CNFPARAMBLK_VERSION,
107 	  sizeof(inppdescr)/sizeof(struct cnfparamdescr),
108 	  inppdescr
109 	};
110 #include &quot;im-helper.h&quot; static int bLegacyCnfModGlobalsPermitted;
111 PRAGMA_DIAGNOSTIC_PUSH
112 PRAGMA_IGNORE_Wformat_nonliteral
113 static void __attribute__((format(printf, 1, 2)))
114 imrelp_dbgprintf(const char *fmt, ...)
115 {
116 	va_list ap;
117 	char pszWriteBuf[32*1024+1]; //this function has to be able to
118 	if(!(Debug &amp;&amp; debugging_on)) {
119 		return;
120 	}
121 	va_start(ap, fmt);
122 	vsnprintf(pszWriteBuf, sizeof(pszWriteBuf), fmt, ap);
123 	va_end(ap);
124 	r_dbgprintf(&quot;imrelp.c&quot;, &quot;%s&quot;, pszWriteBuf);
125 }
126 PRAGMA_DIAGNOSTIC_POP
127 static void
128 onErr(void *pUsr, char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
129 {
130 	instanceConf_t *inst = (instanceConf_t*) pUsr;
131 	LogError(0, RS_RET_RELP_AUTH_FAIL, &quot;imrelp[%s]: error '%s', object &quot;
132 			&quot; '%s' - input may not work as intended&quot;,
133 			inst-&gt;pszBindPort, errmesg, objinfo);
134 }
135 static void
136 onGenericErr(char *objinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
137 {
138 	LogError(0, RS_RET_RELP_ERR, &quot;imrelp: librelp error '%s', object &quot;
139 			&quot; '%s' - input may not work as intended&quot;, errmesg, objinfo);
140 }
141 static void
142 onAuthErr(void *pUsr, char *authinfo, char* errmesg, __attribute__((unused)) relpRetVal errcode)
143 {
144 	instanceConf_t *inst = (instanceConf_t*) pUsr;
145 	LogError(0, RS_RET_RELP_AUTH_FAIL, &quot;imrelp[%s]: authentication error '%s', peer &quot;
146 			&quot;is '%s'&quot;, inst-&gt;pszBindPort, errmesg, authinfo);
147 }
148 static relpRetVal
149 onSyslogRcv(void *pUsr, uchar *pHostname, uchar *pIP, uchar *msg, size_t lenMsg)
150 {
151 	prop_t *pProp = NULL;
152 	smsg_t *pMsg;
153 	instanceConf_t *inst = (instanceConf_t*) pUsr;
154 	DEFiRet;
155 	CHKiRet(msgConstruct(&amp;pMsg));
156 	MsgSetInputName(pMsg, inst-&gt;pInputName);
157 	MsgSetRawMsg(pMsg, (char*)msg, lenMsg);
158 	MsgSetFlowControlType(pMsg, inst-&gt;flowCtlType);
159 	MsgSetRuleset(pMsg, inst-&gt;pBindRuleset);
160 	pMsg-&gt;msgFlags  = PARSE_HOSTNAME | NEEDS_PARSING;
161 	MsgSetRcvFromStr(pMsg, pHostname, ustrlen(pHostname), &amp;pProp);
162 	CHKiRet(prop.Destruct(&amp;pProp));
163 	CHKiRet(MsgSetRcvFromIPStr(pMsg, pIP, ustrlen(pIP), &amp;pProp));
164 	CHKiRet(prop.Destruct(&amp;pProp));
165 	CHKiRet(submitMsg2(pMsg));
166 	STATSCOUNTER_INC(inst-&gt;data.ctrSubmit, inst-&gt;data.mutCtrSubmit);
167 <A NAME="5"></A>finalize_it:
168 	RETiRet;
169 <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#5',2,'match117-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
170 static rsRetVal
171 createInstance(instanceConf_t **pinst)
172 {
173 	instanceConf_t *inst;
174 	DEFiRet;
175 	CHKmalloc(inst = malloc(sizeof(instanceConf_t)));
176 	inst-&gt;next = NULL;
177 	inst-&gt;pszBindPort = NULL;
178 	inst-&gt;pszBindAddr = NULL;
179 	inst-&gt;pszBindRuleset = NULL;
180 	inst-&gt;pszInputName = NULL;
181 	inst-&gt;pBindRuleset = NULL;</B></FONT>
182 	inst-&gt;bKeepAlive = 0;
183 	inst-&gt;iKeepAliveIntvl = 0;
184 	inst-&gt;iKeepAliveProbes = 0;
185 	inst-&gt;iKeepAliveTime = 0;
186 	inst-&gt;bEnableTLS = 0;
187 	inst-&gt;bEnableTLSZip = 0;
188 	inst-&gt;bEnableLstn = 0;
189 	inst-&gt;dhBits = 0;
190 	inst-&gt;pristring = NULL;
191 	inst-&gt;authmode = NULL;
192 	inst-&gt;permittedPeers.nmemb = 0;
193 	inst-&gt;caCertFile = NULL;
194 	inst-&gt;myCertFile = NULL;
195 	inst-&gt;myPrivKeyFile = NULL;
196 #if defined(HAVE_RELPENGINESETTLSCFGCMD)
197 	inst-&gt;tlscfgcmd = NULL;
198 #endif
199 <A NAME="6"></A>	inst-&gt;maxDataSize = 0;
200 	inst-&gt;flowCtlType = eFLOWCTL_LIGHT_DELAY;
201 #ifdef HAVE_RELPSRVSETOVERSIZEMODE
202 <FONT color="#8c8774"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#6',2,'match117-top.html#6',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
203 #endif
204 	if(loadModConf-&gt;tail == NULL) {
205 		loadModConf-&gt;tail = loadModConf-&gt;root = inst;
206 	} else {
207 		loadModConf-&gt;tail-&gt;next = inst;
208 		loadModConf-&gt;tail = inst;
209 	}
210 	*pinst = inst;
211 finalize_it:
212 	RETiRet;
213 }
214 static inline void</B></FONT>
215 std_checkRuleset_genErrMsg(__attribute__((unused)) modConfData_t *modConf, instanceConf_t *inst)
216 {
217 	LogError(0, NO_ERRCODE, &quot;imrelp[%s]: ruleset '%s' not found - &quot;
218 			&quot;using default ruleset instead&quot;,
219 			inst-&gt;pszBindPort, inst-&gt;pszBindRuleset);
220 }
221 static rsRetVal addInstance(void __attribute__((unused)) *pVal, uchar *pNewVal)
222 {
223 	instanceConf_t *inst;
224 	DEFiRet;
225 	CHKiRet(createInstance(&amp;inst));
226 	if(pNewVal == NULL || *pNewVal == '\0') {
227 		LogError(0, NO_ERRCODE, &quot;imrelp: port number must be specified, listener ignored&quot;);
228 	}
229 	if((pNewVal == NULL) || (*pNewVal == '\0')) {
230 		inst-&gt;pszBindPort = NULL;
231 	} else {
232 		CHKmalloc(inst-&gt;pszBindPort = ustrdup(pNewVal));
233 	}
234 	if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
235 		inst-&gt;pszBindRuleset = NULL;
236 	} else {
237 		CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));
238 	}
239 	inst-&gt;pBindRuleset = NULL;
240 	inst-&gt;bEnableLstn = -1; finalize_it:
241 	free(pNewVal);
242 	RETiRet;
243 }
244 static rsRetVal
245 addListner(modConfData_t __attribute__((unused)) *modConf, instanceConf_t *inst)
246 {
247 	relpSrv_t *pSrv;
248 	int relpRet;
249 	uchar statname[64];
250 	int i;
251 	DEFiRet;
252 	if(!inst-&gt;bEnableLstn) {
253 		DBGPRINTF(&quot;listener not started because it is disabled by config error\n&quot;);
254 		FINALIZE;
255 	}
256 	if(pRelpEngine == NULL) {
257 		CHKiRet(relpEngineConstruct(&amp;pRelpEngine));
258 		CHKiRet(relpEngineSetDbgprint(pRelpEngine, (void (*)(char *, ...))imrelp_dbgprintf));
259 		CHKiRet(relpEngineSetFamily(pRelpEngine, glbl.GetDefPFFamily(runModConf-&gt;pConf)));
260 		CHKiRet(relpEngineSetEnableCmd(pRelpEngine, (uchar*) &quot;syslog&quot;, eRelpCmdState_Required));
261 		CHKiRet(relpEngineSetSyslogRcv2(pRelpEngine, onSyslogRcv));
262 		CHKiRet(relpEngineSetOnErr(pRelpEngine, onErr));
263 		CHKiRet(relpEngineSetOnGenericErr(pRelpEngine, onGenericErr));
264 		CHKiRet(relpEngineSetOnAuthErr(pRelpEngine, onAuthErr));
265 		if (!glbl.GetDisableDNS(runModConf-&gt;pConf)) {
266 			CHKiRet(relpEngineSetDnsLookupMode(pRelpEngine, 1));
267 		}
268 		#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
269 			if(modConf-&gt;tlslib != NULL) {
270 				if(relpEngineSetTLSLibByName(pRelpEngine, modConf-&gt;tlslib) != RELP_RET_OK) {
271 					LogMsg(0, RS_RET_CONF_PARAM_INVLD, LOG_WARNING,
272 						&quot;imrelp: tlslib '%s' not accepted as valid by librelp - using default&quot;,
273 						modConf-&gt;tlslib);
274 				}
275 			}
276 		#endif
277 	}
278 	CHKiRet(relpEngineListnerConstruct(pRelpEngine, &amp;pSrv));
279 	CHKiRet(relpSrvSetMaxDataSize(pSrv, inst-&gt;maxDataSize));
280 	CHKiRet(relpSrvSetLstnPort(pSrv, inst-&gt;pszBindPort));
281 	#if defined(HAVE_RELPSRVSETLSTNADDR)
282 		CHKiRet(relpSrvSetLstnAddr(pSrv, inst-&gt;pszBindAddr));
283 	#endif
284 #ifdef HAVE_RELPSRVSETOVERSIZEMODE
285 	CHKiRet(relpSrvSetOversizeMode(pSrv, inst-&gt;oversizeMode));
286 #endif
287 	inst-&gt;pszInputName = ustrdup((inst-&gt;pszInputName == NULL) ?  UCHAR_CONSTANT(&quot;imrelp&quot;) : inst-&gt;pszInputName);
288 	CHKiRet(prop.Construct(&amp;inst-&gt;pInputName));
289 	CHKiRet(prop.SetString(inst-&gt;pInputName, inst-&gt;pszInputName, ustrlen(inst-&gt;pszInputName)));
290 	CHKiRet(prop.ConstructFinalize(inst-&gt;pInputName));
291 	CHKiRet(statsobj.Construct(&amp;(inst-&gt;data.stats)));
292 	snprintf((char*)statname, sizeof(statname), &quot;%s(%s)&quot;,
293 		 inst-&gt;pszInputName, inst-&gt;pszBindPort);
294 	statname[sizeof(statname)-1] = '\0'; 	CHKiRet(statsobj.SetName(inst-&gt;data.stats, statname));
295 	CHKiRet(statsobj.SetOrigin(inst-&gt;data.stats, (uchar*)&quot;imrelp&quot;));
296 	STATSCOUNTER_INIT(inst-&gt;data.ctrSubmit, inst-&gt;data.mutCtrSubmit);
297 	CHKiRet(statsobj.AddCounter(inst-&gt;data.stats, UCHAR_CONSTANT(&quot;submitted&quot;),
298 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(inst-&gt;data.ctrSubmit)));
299 	CHKiRet(statsobj.ConstructFinalize(inst-&gt;data.stats));
300 	relpSrvSetUsrPtr(pSrv, inst);
301 	relpSrvSetKeepAlive(pSrv, inst-&gt;bKeepAlive, inst-&gt;iKeepAliveIntvl,
302 			    inst-&gt;iKeepAliveProbes, inst-&gt;iKeepAliveTime);
303 	if(inst-&gt;bEnableTLS) {
304 		relpRet = relpSrvEnableTLS2(pSrv);
305 		if(relpRet == RELP_RET_ERR_NO_TLS) {
306 			LogError(0, RS_RET_RELP_NO_TLS,
307 					&quot;imrelp: could not activate relp TLS, librelp &quot;
308 					&quot;does not support it (most probably GnuTLS lib &quot;
309 					&quot;is too old)!&quot;);
310 			ABORT_FINALIZE(RS_RET_RELP_NO_TLS);
311 		} else if(relpRet == RELP_RET_ERR_NO_TLS_AUTH) {
312 			LogError(0, RS_RET_RELP_NO_TLS_AUTH,
313 					&quot;imrelp: could not activate relp TLS with &quot;
314 					&quot;authentication, librelp does not support it &quot;
315 					&quot;(most probably GnuTLS lib is too old)! &quot;
316 					&quot;Note: anonymous TLS is probably supported.&quot;);
317 			ABORT_FINALIZE(RS_RET_RELP_NO_TLS_AUTH);
318 		} else if(relpRet != RELP_RET_OK) {
319 			LogError(0, RS_RET_RELP_ERR,
320 					&quot;imrelp: could not activate relp TLS, code %d&quot;, relpRet);
321 			ABORT_FINALIZE(RS_RET_RELP_ERR);
322 		}
323 		if(inst-&gt;bEnableTLSZip) {
324 			relpSrvEnableTLSZip2(pSrv);
325 		}
326 		if(inst-&gt;dhBits) {
327 			relpSrvSetDHBits(pSrv, inst-&gt;dhBits);
328 		}
329 		relpSrvSetGnuTLSPriString(pSrv, (char*)inst-&gt;pristring);
330 		if(relpSrvSetAuthMode(pSrv, (char*)inst-&gt;authmode) != RELP_RET_OK) {
331 			LogError(0, RS_RET_RELP_ERR,
332 					&quot;imrelp: invalid auth mode '%s'&quot;, inst-&gt;authmode);
333 			ABORT_FINALIZE(RS_RET_RELP_ERR);
334 		}
335 		if(relpSrvSetCACert(pSrv, (char*) inst-&gt;caCertFile) != RELP_RET_OK)
336 			ABORT_FINALIZE(RS_RET_RELP_ERR);
337 		if(relpSrvSetOwnCert(pSrv, (char*) inst-&gt;myCertFile) != RELP_RET_OK)
338 			ABORT_FINALIZE(RS_RET_RELP_ERR);
339 		if(relpSrvSetPrivKey(pSrv, (char*) inst-&gt;myPrivKeyFile) != RELP_RET_OK)
340 			ABORT_FINALIZE(RS_RET_RELP_ERR);
341 #if defined(HAVE_RELPENGINESETTLSCFGCMD)
342 		if (inst-&gt;tlscfgcmd != NULL) {
343 			if(relpSrvSetTlsConfigCmd(pSrv, (char*) inst-&gt;tlscfgcmd) != RELP_RET_OK)
344 				ABORT_FINALIZE(RS_RET_RELP_ERR);
345 		}
346 #endif
347 		for(i = 0 ; i &lt;  inst-&gt;permittedPeers.nmemb ; ++i) {
348 			relpSrvAddPermittedPeer(pSrv, (char*)inst-&gt;permittedPeers.name[i]);
349 		}
350 	}
351 	relpRet = relpEngineListnerConstructFinalize(pRelpEngine, pSrv);
352 	if(relpRet == RELP_RET_ERR_NO_TLS) {
353 		LogError(0, RS_RET_RELP_NO_TLS,
354 				&quot;imrelp: could not activate relp TLS listener, librelp &quot;
355 				&quot;does not support it (most probably GnuTLS lib &quot;
356 				&quot;is too old)!&quot;);
357 		ABORT_FINALIZE(RS_RET_RELP_NO_TLS);
358 	} else if(relpRet == RELP_RET_ERR_NO_TLS_AUTH) {
359 		LogError(0, RS_RET_RELP_NO_TLS_AUTH,
360 				&quot;imrelp: could not activate relp TLS listener with &quot;
361 				&quot;authentication, librelp does not support it &quot;
362 				&quot;(most probably GnuTLS lib is too old)! &quot;
363 				&quot;Note: anonymous TLS is probably supported.&quot;);
364 		ABORT_FINALIZE(RS_RET_RELP_NO_TLS_AUTH);
365 	} else if(relpRet != RELP_RET_OK) {
366 		LogError(0, RS_RET_RELP_ERR,
367 				&quot;imrelp: could not activate relp listener, code %d&quot;, relpRet);
368 		ABORT_FINALIZE(RS_RET_RELP_ERR);
369 	}
370 	DBGPRINTF(&quot;imrelp: max data size %zd\n&quot;, inst-&gt;maxDataSize);
371 	resetConfigVariables(NULL,NULL);
372 finalize_it:
373 	RETiRet;
374 }
375 <A NAME="3"></A>BEGINnewInpInst
376 	struct cnfparamvals *pvals;
377 	instanceConf_t *inst = NULL;
378 <FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#3',2,'match117-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	int i,j;
379 	FILE *fp;
380 CODESTARTnewInpInst
381 	DBGPRINTF(&quot;newInpInst (imrelp)\n&quot;);
382 	if((pvals = nvlstGetParams(lst, &amp;inppblk, NULL)) == NULL) {
383 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
384 	}
385 	if(Debug) {
386 		dbgprintf(&quot;input param blk in imrelp:\n&quot;);
387 		cnfparamsPrint(&amp;inppblk, pvals);
388 	}
389 	CHKiRet(createInstance(&amp;inst));
390 	for(i = 0 ; i &lt; inppblk.nParams ; ++i) {
391 		if(!pvals[i].bUsed)
392 <A NAME="2"></A>			continue;
393 		if(!strcmp(inppblk.descr[i].name, &quot;port&quot;)) {
394 			inst-&gt;pszBindPort = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);</B></FONT>
395 <FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#2',2,'match117-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		} else if(!strcmp(inppblk.descr[i].name, &quot;address&quot;)) {
396 			#if defined(HAVE_RELPSRVSETLSTNADDR)
397 				inst-&gt;pszBindAddr = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
398 			#else
399 				parser_errmsg(&quot;imrelp: librelp does not support input parameter 'address'; &quot;
400 					&quot;it probably is too old (1.2.16 should be fine); ignoring setting now, &quot;
401 					&quot;listening on all interfaces&quot;);
402 			#endif
403 		} else if(!strcmp(inppblk.descr[i].name, &quot;name&quot;)) {
404 			inst-&gt;pszInputName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
405 		} else if(!strcmp(inppblk.descr[i].name, &quot;ruleset&quot;)) {
406 			inst-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
407 		} else if(!strcmp(inppblk.descr[i].name, &quot;maxdatasize&quot;)) {</B></FONT>
408 			inst-&gt;maxDataSize = (size_t) pvals[i].val.d.n;
409 		} else if(!strcmp(inppblk.descr[i].name, &quot;flowcontrol&quot;)) {
410 			if(!es_strconstcmp(pvals[i].val.d.estr, &quot;none&quot;)) {
411 				inst-&gt;flowCtlType = eFLOWCTL_NO_DELAY;
412 			} else if(!es_strconstcmp(pvals[i].val.d.estr, &quot;light&quot;)) {
413 				inst-&gt;flowCtlType = eFLOWCTL_LIGHT_DELAY;
414 			} else if(!es_strconstcmp(pvals[i].val.d.estr, &quot;full&quot;)) {
415 				inst-&gt;flowCtlType = eFLOWCTL_FULL_DELAY;
416 			} else {
417 				const char *const mode = es_str2cstr(pvals[i].val.d.estr, NULL);
418 				parser_errmsg(&quot;imrelp: wrong flowcontrol parameter &quot;
419 					&quot;value '%s', using default: 'light'; possible &quot;
420 					&quot;values: 'no', 'light', 'full'\n&quot;, mode);
421 				free((void*)mode);
422 			}
423 		} else if(!strcmp(inppblk.descr[i].name, &quot;oversizemode&quot;)) {
424 #ifdef HAVE_RELPSRVSETOVERSIZEMODE
425 			char *mode = es_str2cstr(pvals[i].val.d.estr, NULL);
426 			if(!strcmp(mode, &quot;abort&quot;)) {
427 				inst-&gt;oversizeMode = RELP_OVERSIZE_ABORT;
428 			} else if(!strcmp(mode, &quot;truncate&quot;)) {
429 				inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
430 			} else if(!strcmp(mode, &quot;accept&quot;)) {
431 				inst-&gt;oversizeMode = RELP_OVERSIZE_ACCEPT;
432 			} else {
433 				parser_errmsg(&quot;imrelp: wrong oversizeMode parameter &quot;
434 					&quot;value %s, using default: truncate\n&quot;, mode);
435 				inst-&gt;oversizeMode = RELP_OVERSIZE_TRUNCATE;
436 			}
437 #else
438 			parser_errmsg(&quot;imrelp: parameter oversizeMode is not available in &quot;
439 				&quot;this relp version and is therefore disabled.&quot;);
440 #endif
441 		} else if(!strcmp(inppblk.descr[i].name, &quot;keepalive&quot;)) {
442 			inst-&gt;bKeepAlive = (sbool) pvals[i].val.d.n;
443 		} else if(!strcmp(inppblk.descr[i].name, &quot;keepalive.probes&quot;)) {
444 			inst-&gt;iKeepAliveProbes = (int) pvals[i].val.d.n;
445 		} else if(!strcmp(inppblk.descr[i].name, &quot;keepalive.time&quot;)) {
446 			inst-&gt;iKeepAliveTime = (int) pvals[i].val.d.n;
447 		} else if(!strcmp(inppblk.descr[i].name, &quot;keepalive.interval&quot;)) {
448 			inst-&gt;iKeepAliveIntvl = (int) pvals[i].val.d.n;
449 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls&quot;)) {
450 			inst-&gt;bEnableTLS = (unsigned) pvals[i].val.d.n;
451 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.dhbits&quot;)) {
452 			inst-&gt;dhBits = (unsigned) pvals[i].val.d.n;
453 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.prioritystring&quot;)) {
454 			inst-&gt;pristring = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
455 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.authmode&quot;)) {
456 			inst-&gt;authmode = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
457 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.compression&quot;)) {
458 			inst-&gt;bEnableTLSZip = (unsigned) pvals[i].val.d.n;
459 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.cacert&quot;)) {
460 			inst-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
461 			fp = fopen((const char*)inst-&gt;caCertFile, &quot;r&quot;);
462 			if(fp == NULL) {
463 				char errStr[1024];
464 				rs_strerror_r(errno, errStr, sizeof(errStr));
465 				LogError(0, RS_RET_NO_FILE_ACCESS,
466 				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
467 				inst-&gt;caCertFile, errStr);
468 			} else {
469 				fclose(fp);
470 			}
471 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.mycert&quot;)) {
472 			inst-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
473 			fp = fopen((const char*)inst-&gt;myCertFile, &quot;r&quot;);
474 			if(fp == NULL) {
475 				char errStr[1024];
476 				rs_strerror_r(errno, errStr, sizeof(errStr));
477 				LogError(0, RS_RET_NO_FILE_ACCESS,
478 				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
479 				inst-&gt;myCertFile, errStr);
480 			} else {
481 				fclose(fp);
482 			}
483 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.myprivkey&quot;)) {
484 			inst-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
485 			fp = fopen((const char*)inst-&gt;myPrivKeyFile, &quot;r&quot;);
486 			if(fp == NULL) {
487 				char errStr[1024];
488 				rs_strerror_r(errno, errStr, sizeof(errStr));
489 				LogError(0, RS_RET_NO_FILE_ACCESS,
490 				&quot;error: certificate file %s couldn't be accessed: %s\n&quot;,
491 				inst-&gt;myPrivKeyFile, errStr);
492 			} else {
493 				fclose(fp);
494 			}
495 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.tlscfgcmd&quot;)) {
496 #if defined(HAVE_RELPENGINESETTLSCFGCMD)
497 			inst-&gt;tlscfgcmd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
498 #else
499 			parser_errmsg(&quot;imrelp: librelp does not support input parameter 'tls.tlscfgcmd'; &quot;
500 				&quot;it probably is too old (1.5.0 or higher should be fine); ignoring setting now.&quot;);
501 #endif
502 		} else if(!strcmp(inppblk.descr[i].name, &quot;tls.permittedpeer&quot;)) {
503 			inst-&gt;permittedPeers.nmemb = pvals[i].val.d.ar-&gt;nmemb;
504 			CHKmalloc(inst-&gt;permittedPeers.name =
505 				malloc(sizeof(uchar*) * inst-&gt;permittedPeers.nmemb));
506 			for(j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
507 				inst-&gt;permittedPeers.name[j] = (uchar*)es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
508 			}
509 		} else {
510 			dbgprintf(&quot;imrelp: program error, non-handled &quot;
511 			  &quot;param '%s'\n&quot;, inppblk.descr[i].name);
512 		}
513 	}
514 	if(inst-&gt;myCertFile  != NULL &amp;&amp; inst-&gt;myPrivKeyFile == NULL) {
515 		LogError(0, RS_RET_ERR, &quot;imrelp: certificate file given but no corresponding &quot;
516 			&quot;private key file - this is invalid, listener cannot be started&quot;);
517 		ABORT_FINALIZE(RS_RET_ERR);
518 	}
519 	if(inst-&gt;myCertFile  == NULL &amp;&amp; inst-&gt;myPrivKeyFile != NULL) {
520 		LogError(0, RS_RET_ERR, &quot;imrelp: private key file given but no corresponding &quot;
521 			&quot;certificate file - this is invalid, listener cannot be started&quot;);
522 		ABORT_FINALIZE(RS_RET_ERR);
523 	}
524 	inst-&gt;bEnableLstn = -1; 
525 finalize_it:
526 CODE_STD_FINALIZERnewInpInst
527 	cnfparamvalsDestruct(pvals, &amp;inppblk);
528 	if(iRet != RS_RET_OK) {
529 		if(inst != NULL) {
530 			free(inst-&gt;myCertFile);
531 			inst-&gt;myCertFile = NULL;
532 			free(inst-&gt;myPrivKeyFile);
533 			inst-&gt;myPrivKeyFile = NULL;
534 		}
535 	}
536 ENDnewInpInst
537 BEGINbeginCnfLoad
538 CODESTARTbeginCnfLoad
539 	loadModConf = pModConf;
540 	pModConf-&gt;pConf = pConf;
541 	pModConf-&gt;pszBindRuleset = NULL;
542 	pModConf-&gt;tlslib = NULL;
543 	cs.pszBindRuleset = NULL;
544 	bLegacyCnfModGlobalsPermitted = 1;
545 ENDbeginCnfLoad
546 <A NAME="1"></A>
547 BEGINsetModCnf
548 <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#1',2,'match117-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	struct cnfparamvals *pvals = NULL;
549 	int i;
550 CODESTARTsetModCnf
551 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
552 	if(pvals == NULL) {
553 		LogError(0, RS_RET_MISSING_CNFPARAMS, &quot;error processing module &quot;
554 				&quot;config parameters [module(...)]&quot;);
555 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
556 	}
557 	if(Debug) {
558 		dbgprintf(&quot;module (global) param blk for imrelp:\n&quot;);
559 		cnfparamsPrint(&amp;modpblk, pvals);
560 	}
561 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
562 		if(!pvals[i].bUsed)
563 			continue;
564 		if(!strcmp(modpblk.descr[i].name, &quot;ruleset&quot;)) {
565 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
566 		} else if(!strcmp(modpblk.descr[i].name, &quot;tls.tlslib&quot;)) {</B></FONT>
567 			#if defined(HAVE_RELPENGINESETTLSLIBBYNAME)
568 				loadModConf-&gt;tlslib = es_str2cstr(pvals[i].val.d.estr, NULL);
569 			#else
570 				LogError(0, RS_RET_NOT_IMPLEMENTED,
571 					&quot;imrelp warning: parameter tls.tlslib ignored - librelp does not support &quot;
572 					&quot;this API call. Using whatever librelp was compiled with.&quot;);
573 			#endif
574 		} else {
575 			dbgprintf(&quot;imrelp: program error, non-handled &quot;
576 			  &quot;param '%s' in beginCnfLoad\n&quot;, modpblk.descr[i].name);
577 		}
578 	}
579 	bLegacyCnfModGlobalsPermitted = 0;
580 finalize_it:
581 <FONT color="#38a4a5"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#7',2,'match117-top.html#7',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(pvals != NULL)
582 		cnfparamvalsDestruct(pvals, &amp;modpblk);
583 ENDsetModCnf
584 BEGINendCnfLoad
585 CODESTARTendCnfLoad
586 	if(loadModConf-&gt;pszBindRuleset == NULL) {
587 		if((cs.pszBindRuleset == NULL) || (cs.pszBindRuleset[0] == '\0')) {
588 			loadModConf-&gt;pszBindRuleset = NULL;
589 		} else {
590 			CHKmalloc(loadModConf-&gt;pszBindRuleset = ustrdup(cs.pszBindRuleset));</B></FONT>
591 		}
592 	} else {
593 <A NAME="4"></A>		if((cs.pszBindRuleset != NULL) &amp;&amp; (cs.pszBindRuleset[0] != '\0')) {
594 			LogError(0, RS_RET_DUP_PARAM, &quot;imrelp: ruleset &quot;
595 					&quot;set via legacy directive ignored&quot;);
596 <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match117-0.html#4',2,'match117-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>		}
597 	}
598 finalize_it:
599 	free(cs.pszBindRuleset);
600 	cs.pszBindRuleset = NULL;
601 	loadModConf = NULL; ENDendCnfLoad
602 BEGINcheckCnf
603 	instanceConf_t *inst;
604 	size_t maxMessageSize;
605 CODESTARTcheckCnf
606 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
607 		if(inst-&gt;pszBindRuleset == NULL &amp;&amp; pModConf-&gt;pszBindRuleset != NULL) {
608 			CHKmalloc(inst-&gt;pszBindRuleset = ustrdup(pModConf-&gt;pszBindRuleset));
609 		}</B></FONT>
610 		std_checkRuleset(pModConf, inst);
611 		if(inst-&gt;maxDataSize == 0) {
612 			inst-&gt;maxDataSize = glbl.GetMaxLine(loadConf);
613 		}
614 		maxMessageSize = (size_t)glbl.GetMaxLine(loadConf);
615 		if(inst-&gt;maxDataSize &lt; maxMessageSize) {
616 			LogError(0, RS_RET_INVALID_PARAMS, &quot;error: &quot;
617 					&quot;maxDataSize (%zu) is smaller than global parameter &quot;
618 					&quot;maxMessageSize (%zu) - global parameter will be used.&quot;,
619 					inst-&gt;maxDataSize, maxMessageSize);
620 			inst-&gt;maxDataSize = maxMessageSize;
621 		}
622 	}
623 finalize_it:
624 ENDcheckCnf
625 BEGINactivateCnfPrePrivDrop
626 	instanceConf_t *inst;
627 CODESTARTactivateCnfPrePrivDrop
628 	runModConf = pModConf;
629 	for(inst = runModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
630 		addListner(pModConf, inst);
631 	}
632 	if(pRelpEngine == NULL) {
633 		LogError(0, RS_RET_NO_LSTN_DEFINED, &quot;imrelp: no RELP listener defined, module can not run.&quot;);
634 		ABORT_FINALIZE(RS_RET_NO_RUN);
635 	}
636 finalize_it:
637 ENDactivateCnfPrePrivDrop
638 BEGINactivateCnf
639 CODESTARTactivateCnf
640 ENDactivateCnf
641 BEGINfreeCnf
642 	instanceConf_t *inst, *del;
643 	int i;
644 CODESTARTfreeCnf
645 	for(inst = pModConf-&gt;root ; inst != NULL ; ) {
646 		free(inst-&gt;pszBindPort);
647 		if (inst-&gt;pszBindAddr != NULL) {
648 			free(inst-&gt;pszBindAddr);
649 		}
650 		free(inst-&gt;pszBindRuleset);
651 		free(inst-&gt;pszInputName);
652 		free(inst-&gt;pristring);
653 		free(inst-&gt;authmode);
654 		for(i = 0 ; i &lt;  inst-&gt;permittedPeers.nmemb ; ++i) {
655 			free(inst-&gt;permittedPeers.name[i]);
656 		}
657 		if(inst-&gt;bEnableLstn) {
658 			prop.Destruct(&amp;inst-&gt;pInputName);
659 			statsobj.Destruct(&amp;(inst-&gt;data.stats));
660 		}
661 		del = inst;
662 		inst = inst-&gt;next;
663 		free(del);
664 	}
665 	free(pModConf-&gt;pszBindRuleset);
666 ENDfreeCnf
667 static void
668 doSIGTTIN(int __attribute__((unused)) sig)
669 {
670 	const int bTerminate = ATOMIC_FETCH_32BIT(&amp;bTerminateInputs, &amp;mutTerminateInputs);
671 	if(bTerminate) {
672 		relpEngineSetStop(pRelpEngine);
673 	}
674 }
675 BEGINrunInput
676 	sigset_t sigSet;
677 	struct sigaction sigAct;
678 CODESTARTrunInput
679 	sigfillset(&amp;sigSet);
680 	pthread_sigmask(SIG_BLOCK, &amp;sigSet, NULL);
681 	sigemptyset(&amp;sigSet);
682 	sigaddset(&amp;sigSet, SIGTTIN);
683 	pthread_sigmask(SIG_UNBLOCK, &amp;sigSet, NULL);
684 	memset(&amp;sigAct, 0, sizeof (sigAct));
685 	sigemptyset(&amp;sigAct.sa_mask);
686 	sigAct.sa_handler = doSIGTTIN;
687 	sigaction(SIGTTIN, &amp;sigAct, NULL);
688 	iRet = relpEngineRun(pRelpEngine);
689 ENDrunInput
690 BEGINwillRun
691 CODESTARTwillRun
692 ENDwillRun
693 BEGINafterRun
694 CODESTARTafterRun
695 ENDafterRun
696 BEGINmodExit
697 CODESTARTmodExit
698 	if(pRelpEngine != NULL)
699 		iRet = relpEngineDestruct(&amp;pRelpEngine);
700 	objRelease(statsobj, CORE_COMPONENT);
701 	objRelease(ruleset, CORE_COMPONENT);
702 	objRelease(glbl, CORE_COMPONENT);
703 	objRelease(prop, CORE_COMPONENT);
704 	objRelease(net, LM_NET_FILENAME);
705 ENDmodExit
706 static rsRetVal
707 resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
708 {
709 	free(cs.pszBindRuleset);
710 	cs.pszBindRuleset = NULL;
711 	return RS_RET_OK;
712 }
713 BEGINisCompatibleWithFeature
714 CODESTARTisCompatibleWithFeature
715 	if(eFeat == sFEATURENonCancelInputTermination)
716 		iRet = RS_RET_OK;
717 ENDisCompatibleWithFeature
718 BEGINqueryEtryPt
719 CODESTARTqueryEtryPt
720 CODEqueryEtryPt_STD_IMOD_QUERIES
721 CODEqueryEtryPt_STD_CONF2_QUERIES
722 CODEqueryEtryPt_STD_CONF2_PREPRIVDROP_QUERIES
723 CODEqueryEtryPt_STD_CONF2_IMOD_QUERIES
724 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
725 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
726 ENDqueryEtryPt
727 BEGINmodInit()
728 CODESTARTmodInit
729 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
730 	pRelpEngine = NULL;
731 	CHKiRet(objUse(glbl, CORE_COMPONENT));
732 	CHKiRet(objUse(prop, CORE_COMPONENT));
733 	CHKiRet(objUse(net, LM_NET_FILENAME));
734 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
735 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
736 	#ifndef HAVE_RELPSRVSETOVERSIZEMODE
737 		LogMsg(0, RS_RET_OK_WARN, LOG_WARNING, &quot;imrelp: librelp too old, oversizemode &quot;
738 			&quot;defaults to \&quot;abort\&quot;&quot;);
739 	#endif
740 	CHKiRet(regCfSysLineHdlr2((uchar*)&quot;inputrelpserverbindruleset&quot;, 0, eCmdHdlrGetWord,
741 				   NULL, &amp;cs.pszBindRuleset, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
742 	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;inputrelpserverrun&quot;, 0, eCmdHdlrGetWord,
743 				   addInstance, NULL, STD_LOADABLE_MODULE_ID));
744 	CHKiRet(omsdRegCFSLineHdlr((uchar *)&quot;resetconfigvariables&quot;, 1, eCmdHdlrCustomHandler,
745 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
746 ENDmodInit
</PRE>
</div>
  </div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
