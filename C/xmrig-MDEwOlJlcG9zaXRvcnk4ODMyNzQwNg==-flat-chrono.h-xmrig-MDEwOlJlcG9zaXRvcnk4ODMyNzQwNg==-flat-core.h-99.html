
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</h3>
            <pre><code>1  #ifndef FMT_CHRONO_H_
2  #define FMT_CHRONO_H_
3  #include &lt;chrono&gt;
4  #include &lt;ctime&gt;
5  #include &lt;locale&gt;
6  #include &lt;sstream&gt;
7  #include &quot;format.h&quot;
8  #include &quot;locale.h&quot;
9  FMT_BEGIN_NAMESPACE
10  #ifndef FMT_SAFE_DURATION_CAST
11  #  define FMT_SAFE_DURATION_CAST 1
12  #endif
13  #if FMT_SAFE_DURATION_CAST
14  namespace safe_duration_cast {
15  template &lt;typename To, typename From,
16            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value &amp;&amp;
17                          std::numeric_limits&lt;From&gt;::is_signed ==
18                              std::numeric_limits&lt;To&gt;::is_signed)&gt;
19  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
20    ec = 0;
21    using F = std::numeric_limits&lt;From&gt;;
22    using T = std::numeric_limits&lt;To&gt;;
23    static_assert(F::is_integer, &quot;From must be integral&quot;);
24    static_assert(T::is_integer, &quot;To must be integral&quot;);
25    if (F::digits &lt;= T::digits) {
26    } else {
27      if (from &lt; (T::min)() || from &gt; (T::max)()) {
28        ec = 1;
29        return {};
30      }
31    }
32    return static_cast&lt;To&gt;(from);
33  }
34  template &lt;typename To, typename From,
35            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value &amp;&amp;
36                          std::numeric_limits&lt;From&gt;::is_signed !=
37                              std::numeric_limits&lt;To&gt;::is_signed)&gt;
38  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
39    ec = 0;
40    using F = std::numeric_limits&lt;From&gt;;
41    using T = std::numeric_limits&lt;To&gt;;
42    static_assert(F::is_integer, &quot;From must be integral&quot;);
43    static_assert(T::is_integer, &quot;To must be integral&quot;);
44    if (detail::const_check(F::is_signed &amp;&amp; !T::is_signed)) {
45      if (fmt::detail::is_negative(from)) {
46        ec = 1;
47        return {};
48      }
49      if (F::digits &gt; T::digits &amp;&amp;
50          from &gt; static_cast&lt;From&gt;(detail::max_value&lt;To&gt;())) {
51        ec = 1;
52        return {};
53      }
54    }
55    if (!F::is_signed &amp;&amp; T::is_signed &amp;&amp; F::digits &gt;= T::digits &amp;&amp;
56        from &gt; static_cast&lt;From&gt;(detail::max_value&lt;To&gt;())) {
57      ec = 1;
58      return {};
59    }
60    return static_cast&lt;To&gt;(from);  
61  }
62  template &lt;typename To, typename From,
63            FMT_ENABLE_IF(std::is_same&lt;From, To&gt;::value)&gt;
64  FMT_CONSTEXPR To lossless_integral_conversion(const From from, int&amp; ec) {
65    ec = 0;
66    return from;
67  }  
68  template &lt;typename To, typename From,
69            FMT_ENABLE_IF(!std::is_same&lt;From, To&gt;::value)&gt;
70  FMT_CONSTEXPR To safe_float_conversion(const From from, int&amp; ec) {
71    ec = 0;
72    using T = std::numeric_limits&lt;To&gt;;
73    static_assert(std::is_floating_point&lt;From&gt;::value, &quot;From must be floating&quot;);
74    static_assert(std::is_floating_point&lt;To&gt;::value, &quot;To must be floating&quot;);
75    if (std::isfinite(from)) {
76      if (from &gt;= T::lowest() &amp;&amp; from &lt;= (T::max)()) {
77        return static_cast&lt;To&gt;(from);
78      }
79      ec = 1;
80      return {};
81    }
82    return static_cast&lt;To&gt;(from);
83  }  
84  template &lt;typename To, typename From,
85            FMT_ENABLE_IF(std::is_same&lt;From, To&gt;::value)&gt;
86  FMT_CONSTEXPR To safe_float_conversion(const From from, int&amp; ec) {
87    ec = 0;
88    static_assert(std::is_floating_point&lt;From&gt;::value, &quot;From must be floating&quot;);
89    return from;
90  }
91  template &lt;typename To, typename FromRep, typename FromPeriod,
92            FMT_ENABLE_IF(std::is_integral&lt;FromRep&gt;::value),
93            FMT_ENABLE_IF(std::is_integral&lt;typename To::rep&gt;::value)&gt;
94  To safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from,
95                        int&amp; ec) {
96    using From = std::chrono::duration&lt;FromRep, FromPeriod&gt;;
97    ec = 0;
98    struct Factor
99        : std::ratio_divide&lt;typename From::period, typename To::period&gt; {};
100    static_assert(Factor::num &gt; 0, &quot;num must be positive&quot;);
101    static_assert(Factor::den &gt; 0, &quot;den must be positive&quot;);
102    using IntermediateRep =
103        typename std::common_type&lt;typename From::rep, typename To::rep,
104                                  decltype(Factor::num)&gt;::type;
105    IntermediateRep count =
106        lossless_integral_conversion&lt;IntermediateRep&gt;(from.count(), ec);
107    if (ec) return {};
108    if (detail::const_check(Factor::num != 1)) {
109      const auto max1 = detail::max_value&lt;IntermediateRep&gt;() / Factor::num;
110      if (count &gt; max1) {
111        ec = 1;
112        return {};
113      }
114      const auto min1 =
115          (std::numeric_limits&lt;IntermediateRep&gt;::min)() / Factor::num;
116      if (count &lt; min1) {
117        ec = 1;
118        return {};
119      }
120      count *= Factor::num;
121    }
122    if (detail::const_check(Factor::den != 1)) count /= Factor::den;
123    auto tocount = lossless_integral_conversion&lt;typename To::rep&gt;(count, ec);
124    return ec ? To() : To(tocount);
125  }
126  template &lt;typename To, typename FromRep, typename FromPeriod,
127            FMT_ENABLE_IF(std::is_floating_point&lt;FromRep&gt;::value),
128            FMT_ENABLE_IF(std::is_floating_point&lt;typename To::rep&gt;::value)&gt;
129  To safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from,
130                        int&amp; ec) {
131    using From = std::chrono::duration&lt;FromRep, FromPeriod&gt;;
132    ec = 0;
133    if (std::isnan(from.count())) {
134      return To{std::numeric_limits&lt;typename To::rep&gt;::quiet_NaN()};
135    }
136    if (std::isinf(from.count())) {
137      return To{from.count()};
138    }
139    struct Factor
140        : std::ratio_divide&lt;typename From::period, typename To::period&gt; {};
141    static_assert(Factor::num &gt; 0, &quot;num must be positive&quot;);
142    static_assert(Factor::den &gt; 0, &quot;den must be positive&quot;);
143    using IntermediateRep =
144        typename std::common_type&lt;typename From::rep, typename To::rep,
145                                  decltype(Factor::num)&gt;::type;
146    IntermediateRep count =
147        safe_float_conversion&lt;IntermediateRep&gt;(from.count(), ec);
148    if (ec) {
149      return {};
150    }
151    if (Factor::num != 1) {
152      constexpr auto max1 = detail::max_value&lt;IntermediateRep&gt;() /
153                            static_cast&lt;IntermediateRep&gt;(Factor::num);
154      if (count &gt; max1) {
155        ec = 1;
156        return {};
157      }
158      constexpr auto min1 = std::numeric_limits&lt;IntermediateRep&gt;::lowest() /
159                            static_cast&lt;IntermediateRep&gt;(Factor::num);
160      if (count &lt; min1) {
161        ec = 1;
162        return {};
163      }
164      count *= static_cast&lt;IntermediateRep&gt;(Factor::num);
165    }
166    if (Factor::den != 1) {
167      using common_t = typename std::common_type&lt;IntermediateRep, intmax_t&gt;::type;
168      count /= static_cast&lt;common_t&gt;(Factor::den);
169    }
170    using ToRep = typename To::rep;
171    const ToRep tocount = safe_float_conversion&lt;ToRep&gt;(count, ec);
172    if (ec) {
173      return {};
174    }
175    return To{tocount};
176  }
177  }  
178  #endif
179  #define FMT_NOMACRO
180  namespace detail {
181  inline null&lt;&gt; localtime_r FMT_NOMACRO(...) { return null&lt;&gt;(); }
182  inline null&lt;&gt; localtime_s(...) { return null&lt;&gt;(); }
183  inline null&lt;&gt; gmtime_r(...) { return null&lt;&gt;(); }
184  inline null&lt;&gt; gmtime_s(...) { return null&lt;&gt;(); }
185  }  
186  inline std::tm localtime(std::time_t time) {
187    struct dispatcher {
188      std::time_t time_;
189      std::tm tm_;
190      dispatcher(std::time_t t) : time_(t) {}
191      bool run() {
192        using namespace fmt::detail;
193        return handle(localtime_r(&amp;time_, &amp;tm_));
194      }
195      bool handle(std::tm* tm) { return tm != nullptr; }
196      bool handle(detail::null&lt;&gt;) {
197        using namespace fmt::detail;
198        return fallback(localtime_s(&amp;tm_, &amp;time_));
199      }
200      bool fallback(int res) { return res == 0; }
201  #if !FMT_MSC_VER
202      bool fallback(detail::null&lt;&gt;) {
203        using namespace fmt::detail;
204        std::tm* tm = std::localtime(&amp;time_);
205        if (tm) tm_ = *tm;
206        return tm != nullptr;
207      }
208  #endif
209    };
210    dispatcher lt(time);
211    if (!lt.run()) FMT_THROW(format_error(&quot;time_t value out of range&quot;));
212    return lt.tm_;
213  }
214  inline std::tm localtime(
215      std::chrono::time_point&lt;std::chrono::system_clock&gt; time_point) {
216    return localtime(std::chrono::system_clock::to_time_t(time_point));
217  }
218  inline std::tm gmtime(std::time_t time) {
219    struct dispatcher {
220      std::time_t time_;
221      std::tm tm_;
222      dispatcher(std::time_t t) : time_(t) {}
223      bool run() {
224        using namespace fmt::detail;
225        return handle(gmtime_r(&amp;time_, &amp;tm_));
226      }
227      bool handle(std::tm* tm) { return tm != nullptr; }
228      bool handle(detail::null&lt;&gt;) {
229        using namespace fmt::detail;
230        return fallback(gmtime_s(&amp;tm_, &amp;time_));
231      }
232      bool fallback(int res) { return res == 0; }
233  #if !FMT_MSC_VER
234      bool fallback(detail::null&lt;&gt;) {
235        std::tm* tm = std::gmtime(&amp;time_);
236        if (tm) tm_ = *tm;
237        return tm != nullptr;
238      }
239  #endif
240    };
241    dispatcher gt(time);
242    if (!gt.run()) FMT_THROW(format_error(&quot;time_t value out of range&quot;));
243    return gt.tm_;
244  }
245  inline std::tm gmtime(
246      std::chrono::time_point&lt;std::chrono::system_clock&gt; time_point) {
247    return gmtime(std::chrono::system_clock::to_time_t(time_point));
248  }
249  namespace detail {
250  inline size_t strftime(char* str, size_t count, const char* format,
251                         const std::tm* time) {
252    return std::strftime(str, count, format, time);
253  }
254  inline size_t strftime(wchar_t* str, size_t count, const wchar_t* format,
255                         const std::tm* time) {
256    return std::wcsftime(str, count, format, time);
257  }
258  }  
259  template &lt;typename Char&gt;
260  struct formatter&lt;std::chrono::time_point&lt;std::chrono::system_clock&gt;, Char&gt;
261      : formatter&lt;std::tm, Char&gt; {
262    template &lt;typename FormatContext&gt;
263    auto format(std::chrono::time_point&lt;std::chrono::system_clock&gt; val,
264                FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
265      std::tm time = localtime(val);
266      return formatter&lt;std::tm, Char&gt;::format(time, ctx);
267    }
268  };
269  template &lt;typename Char&gt; struct formatter&lt;std::tm, Char&gt; {
270    template &lt;typename ParseContext&gt;
271    auto parse(ParseContext&amp; ctx) -&gt; decltype(ctx.begin()) {
272      auto it = ctx.begin();
273      if (it != ctx.end() &amp;&amp; *it == &#x27;:&#x27;) ++it;
274      auto end = it;
275      while (end != ctx.end() &amp;&amp; *end != &#x27;}&#x27;) ++end;
276      tm_format.reserve(detail::to_unsigned(end - it + 1));
277      tm_format.append(it, end);
278      tm_format.push_back(&#x27;\0&#x27;);
279      return end;
280    }
281    template &lt;typename FormatContext&gt;
282    auto format(const std::tm&amp; tm, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
283      basic_memory_buffer&lt;Char&gt; buf;
284      size_t start = buf.size();
285      for (;;) {
286        size_t size = buf.capacity() - start;
287        size_t count = detail::strftime(&amp;buf[start], size, &amp;tm_format[0], &amp;tm);
288        if (count != 0) {
289          buf.resize(start + count);
290          break;
291        }
292        if (size &gt;= tm_format.size() * 256) {
293          break;
294        }
295        const size_t MIN_GROWTH = 10;
296        buf.reserve(buf.capacity() + (size &gt; MIN_GROWTH ? size : MIN_GROWTH));
297      }
298      return std::copy(buf.begin(), buf.end(), ctx.out());
299    }
300    basic_memory_buffer&lt;Char&gt; tm_format;
301  };
302  namespace detail {
303  template &lt;typename Period&gt; FMT_CONSTEXPR const char* get_units() {
304    return nullptr;
305  }
306  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::atto&gt;() { return &quot;as&quot;; }
307  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::femto&gt;() { return &quot;fs&quot;; }
308  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::pico&gt;() { return &quot;ps&quot;; }
309  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::nano&gt;() { return &quot;ns&quot;; }
310  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::micro&gt;() { return &quot;Âµs&quot;; }
311  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::milli&gt;() { return &quot;ms&quot;; }
312  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::centi&gt;() { return &quot;cs&quot;; }
313  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::deci&gt;() { return &quot;ds&quot;; }
314  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;1&gt;&gt;() { return &quot;s&quot;; }
315  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::deca&gt;() { return &quot;das&quot;; }
316  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::hecto&gt;() { return &quot;hs&quot;; }
317  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::kilo&gt;() { return &quot;ks&quot;; }
318  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::mega&gt;() { return &quot;Ms&quot;; }
319  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::giga&gt;() { return &quot;Gs&quot;; }
320  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::tera&gt;() { return &quot;Ts&quot;; }
321  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::peta&gt;() { return &quot;Ps&quot;; }
322  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::exa&gt;() { return &quot;Es&quot;; }
323  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;60&gt;&gt;() {
324    return &quot;m&quot;;
325  }
326  template &lt;&gt; FMT_CONSTEXPR const char* get_units&lt;std::ratio&lt;3600&gt;&gt;() {
327    return &quot;h&quot;;
328  }
329  enum class numeric_system {
330    standard,
331    alternative
332  };
333  template &lt;typename Char, typename Handler&gt;
334  FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
335                                                const Char* end,
336                                                Handler&amp;&amp; handler) {
337    auto ptr = begin;
338    while (ptr != end) {
339      auto c = *ptr;
340      if (c == &#x27;}&#x27;) break;
341      if (c != &#x27;%&#x27;) {
342        ++ptr;
343        continue;
344      }
345      if (begin != ptr) handler.on_text(begin, ptr);
346      ++ptr;  
347      if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
348      c = *ptr++;
349      switch (c) {
350      case &#x27;%&#x27;:
351        handler.on_text(ptr - 1, ptr);
352        break;
353      case &#x27;n&#x27;: {
354        const Char newline[] = {&#x27;\n&#x27;};
355        handler.on_text(newline, newline + 1);
356        break;
357      }
358      case &#x27;t&#x27;: {
359        const Char tab[] = {&#x27;\t&#x27;};
360        handler.on_text(tab, tab + 1);
361        break;
362      }
363      case &#x27;a&#x27;:
364        handler.on_abbr_weekday();
365        break;
366      case &#x27;A&#x27;:
367        handler.on_full_weekday();
368        break;
369      case &#x27;w&#x27;:
370        handler.on_dec0_weekday(numeric_system::standard);
371        break;
372      case &#x27;u&#x27;:
373        handler.on_dec1_weekday(numeric_system::standard);
374        break;
375      case &#x27;b&#x27;:
376        handler.on_abbr_month();
377        break;
378      case &#x27;B&#x27;:
379        handler.on_full_month();
380        break;
381      case &#x27;H&#x27;:
382        handler.on_24_hour(numeric_system::standard);
383        break;
384      case &#x27;I&#x27;:
385        handler.on_12_hour(numeric_system::standard);
386        break;
387      case &#x27;M&#x27;:
388        handler.on_minute(numeric_system::standard);
389        break;
390      case &#x27;S&#x27;:
391        handler.on_second(numeric_system::standard);
392        break;
393      case &#x27;c&#x27;:
394        handler.on_datetime(numeric_system::standard);
395        break;
396      case &#x27;x&#x27;:
397        handler.on_loc_date(numeric_system::standard);
398        break;
399      case &#x27;X&#x27;:
400        handler.on_loc_time(numeric_system::standard);
401        break;
402      case &#x27;D&#x27;:
403        handler.on_us_date();
404        break;
405      case &#x27;F&#x27;:
406        handler.on_iso_date();
407        break;
408      case &#x27;r&#x27;:
409        handler.on_12_hour_time();
410        break;
411      case &#x27;R&#x27;:
412        handler.on_24_hour_time();
413        break;
414      case &#x27;T&#x27;:
415        handler.on_iso_time();
416        break;
417      case &#x27;p&#x27;:
418        handler.on_am_pm();
419        break;
420      case &#x27;Q&#x27;:
421        handler.on_duration_value();
422        break;
423      case &#x27;q&#x27;:
424        handler.on_duration_unit();
425        break;
426      case &#x27;z&#x27;:
427        handler.on_utc_offset();
428        break;
429      case &#x27;Z&#x27;:
430        handler.on_tz_name();
431        break;
432      case &#x27;E&#x27;: {
433        if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
434        c = *ptr++;
435        switch (c) {
436        case &#x27;c&#x27;:
437          handler.on_datetime(numeric_system::alternative);
438          break;
439        case &#x27;x&#x27;:
440          handler.on_loc_date(numeric_system::alternative);
441          break;
442        case &#x27;X&#x27;:
443          handler.on_loc_time(numeric_system::alternative);
444          break;
445        default:
446          FMT_THROW(format_error(&quot;invalid format&quot;));
447        }
448        break;
449      }
450      case &#x27;O&#x27;:
451        if (ptr == end) FMT_THROW(format_error(&quot;invalid format&quot;));
452        c = *ptr++;
453        switch (c) {
454        case &#x27;w&#x27;:
455          handler.on_dec0_weekday(numeric_system::alternative);
456          break;
457        case &#x27;u&#x27;:
458          handler.on_dec1_weekday(numeric_system::alternative);
459          break;
460        case &#x27;H&#x27;:
461          handler.on_24_hour(numeric_system::alternative);
462          break;
463        case &#x27;I&#x27;:
464          handler.on_12_hour(numeric_system::alternative);
465          break;
466        case &#x27;M&#x27;:
467          handler.on_minute(numeric_system::alternative);
468          break;
469        case &#x27;S&#x27;:
470          handler.on_second(numeric_system::alternative);
471          break;
472        default:
473          FMT_THROW(format_error(&quot;invalid format&quot;));
474        }
475        break;
476      default:
477        FMT_THROW(format_error(&quot;invalid format&quot;));
478      }
479      begin = ptr;
480    }
481    if (begin != ptr) handler.on_text(begin, ptr);
482    return ptr;
483  }
484  struct chrono_format_checker {
485    FMT_NORETURN void report_no_date() { FMT_THROW(format_error(&quot;no date&quot;)); }
486    template &lt;typename Char&gt; void on_text(const Char*, const Char*) {}
487    FMT_NORETURN void on_abbr_weekday() { report_no_date(); }
488    FMT_NORETURN void on_full_weekday() { report_no_date(); }
489    FMT_NORETURN void on_dec0_weekday(numeric_system) { report_no_date(); }
490    FMT_NORETURN void on_dec1_weekday(numeric_system) { report_no_date(); }
491    FMT_NORETURN void on_abbr_month() { report_no_date(); }
492    FMT_NORETURN void on_full_month() { report_no_date(); }
493    void on_24_hour(numeric_system) {}
494    void on_12_hour(numeric_system) {}
495    void on_minute(numeric_system) {}
496    void on_second(numeric_system) {}
497    FMT_NORETURN void on_datetime(numeric_system) { report_no_date(); }
498    FMT_NORETURN void on_loc_date(numeric_system) { report_no_date(); }
499    FMT_NORETURN void on_loc_time(numeric_system) { report_no_date(); }
500    FMT_NORETURN void on_us_date() { report_no_date(); }
501    FMT_NORETURN void on_iso_date() { report_no_date(); }
502    void on_12_hour_time() {}
503    void on_24_hour_time() {}
504    void on_iso_time() {}
505    void on_am_pm() {}
506    void on_duration_value() {}
507    void on_duration_unit() {}
508    FMT_NORETURN void on_utc_offset() { report_no_date(); }
509    FMT_NORETURN void on_tz_name() { report_no_date(); }
510  };
511  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
512  inline bool isnan(T) {
513    return false;
514  }
515  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
516  inline bool isnan(T value) {
517    return std::isnan(value);
518  }
519  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
520  inline bool isfinite(T) {
521    return true;
522  }
523  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
524  inline bool isfinite(T value) {
525    return std::isfinite(value);
526  }
527  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
528  inline int to_nonnegative_int(T value, int upper) {
529    FMT_ASSERT(value &gt;= 0 &amp;&amp; value &lt;= upper, &quot;invalid value&quot;);
530    (void)upper;
531    return static_cast&lt;int&gt;(value);
532  }
533  template &lt;typename T, FMT_ENABLE_IF(!std::is_integral&lt;T&gt;::value)&gt;
534  inline int to_nonnegative_int(T value, int upper) {
535    FMT_ASSERT(
536        std::isnan(value) || (value &gt;= 0 &amp;&amp; value &lt;= static_cast&lt;T&gt;(upper)),
537        &quot;invalid value&quot;);
538    (void)upper;
539    return static_cast&lt;int&gt;(value);
540  }
541  template &lt;typename T, FMT_ENABLE_IF(std::is_integral&lt;T&gt;::value)&gt;
542  inline T mod(T x, int y) {
543    return x % static_cast&lt;T&gt;(y);
544  }
545  template &lt;typename T, FMT_ENABLE_IF(std::is_floating_point&lt;T&gt;::value)&gt;
546  inline T mod(T x, int y) {
547    return std::fmod(x, static_cast&lt;T&gt;(y));
548  }
549  template &lt;typename T, bool INTEGRAL = std::is_integral&lt;T&gt;::value&gt;
550  struct make_unsigned_or_unchanged {
551    using type = T;
552  };
553  template &lt;typename T&gt; struct make_unsigned_or_unchanged&lt;T, true&gt; {
554    using type = typename std::make_unsigned&lt;T&gt;::type;
555  };
556  #if FMT_SAFE_DURATION_CAST
557  template &lt;typename To, typename FromRep, typename FromPeriod&gt;
558  To fmt_safe_duration_cast(std::chrono::duration&lt;FromRep, FromPeriod&gt; from) {
559    int ec;
560    To to = safe_duration_cast::safe_duration_cast&lt;To&gt;(from, ec);
561    if (ec) FMT_THROW(format_error(&quot;cannot format duration&quot;));
562    return to;
563  }
564  #endif
565  template &lt;typename Rep, typename Period,
566            FMT_ENABLE_IF(std::is_integral&lt;Rep&gt;::value)&gt;
567  inline std::chrono::duration&lt;Rep, std::milli&gt; get_milliseconds(
568      std::chrono::duration&lt;Rep, Period&gt; d) {
569  #if FMT_SAFE_DURATION_CAST
570    using CommonSecondsType =
571        typename std::common_type&lt;decltype(d), std::chrono::seconds&gt;::type;
572    const auto d_as_common = fmt_safe_duration_cast&lt;CommonSecondsType&gt;(d);
573    const auto d_as_whole_seconds =
574        fmt_safe_duration_cast&lt;std::chrono::seconds&gt;(d_as_common);
575    const auto diff = d_as_common - d_as_whole_seconds;
576    const auto ms =
577        fmt_safe_duration_cast&lt;std::chrono::duration&lt;Rep, std::milli&gt;&gt;(diff);
578    return ms;
579  #else
580    auto s = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(d);
581    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(d - s);
582  #endif
583  }
584  template &lt;typename Rep, typename Period,
585            FMT_ENABLE_IF(std::is_floating_point&lt;Rep&gt;::value)&gt;
586  inline std::chrono::duration&lt;Rep, std::milli&gt; get_milliseconds(
587      std::chrono::duration&lt;Rep, Period&gt; d) {
588    using common_type = typename std::common_type&lt;Rep, std::intmax_t&gt;::type;
589    auto ms = mod(d.count() * static_cast&lt;common_type&gt;(Period::num) /
590                      static_cast&lt;common_type&gt;(Period::den) * 1000,
591                  1000);
592    return std::chrono::duration&lt;Rep, std::milli&gt;(static_cast&lt;Rep&gt;(ms));
593  }
594  template &lt;typename Char, typename Rep, typename OutputIt&gt;
595  OutputIt format_duration_value(OutputIt out, Rep val, int precision) {
596    const Char pr_f[] = {&#x27;{&#x27;, &#x27;:&#x27;, &#x27;.&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;f&#x27;, &#x27;}&#x27;, 0};
597    if (precision &gt;= 0) return format_to(out, pr_f, val, precision);
598    const Char fp_f[] = {&#x27;{&#x27;, &#x27;:&#x27;, &#x27;g&#x27;, &#x27;}&#x27;, 0};
599    const Char format[] = {&#x27;{&#x27;, &#x27;}&#x27;, 0};
600    return format_to(out, std::is_floating_point&lt;Rep&gt;::value ? fp_f : format,
601                     val);
602  }
603  template &lt;typename Char, typename OutputIt&gt;
604  OutputIt copy_unit(string_view unit, OutputIt out, Char) {
605    return std::copy(unit.begin(), unit.end(), out);
606  }
607  template &lt;typename OutputIt&gt;
608  OutputIt copy_unit(string_view unit, OutputIt out, wchar_t) {
609    utf8_to_utf16 u(unit);
610    return std::copy(u.c_str(), u.c_str() + u.size(), out);
611  }
612  template &lt;typename Char, typename Period, typename OutputIt&gt;
613  OutputIt format_duration_unit(OutputIt out) {
614    if (const char* unit = get_units&lt;Period&gt;())
615      return copy_unit(string_view(unit), out, Char());
616    const Char num_f[] = {&#x27;[&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;]&#x27;, &#x27;s&#x27;, 0};
617    if (const_check(Period::den == 1)) return format_to(out, num_f, Period::num);
618    const Char num_def_f[] = {&#x27;[&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;/&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;]&#x27;, &#x27;s&#x27;, 0};
619    return format_to(out, num_def_f, Period::num, Period::den);
620  }
<span onclick='openModal()' class='match'>621  template &lt;typename FormatContext, typename OutputIt, typename Rep,
622            typename Period&gt;
623  struct chrono_formatter {
624    FormatContext&amp; context;
</span>625    OutputIt out;
626    int precision;
627    using rep =
628        conditional_t&lt;std::is_integral&lt;Rep&gt;::value &amp;&amp; sizeof(Rep) &lt; sizeof(int),
629                      unsigned, typename make_unsigned_or_unchanged&lt;Rep&gt;::type&gt;;
630    rep val;
631    using seconds = std::chrono::duration&lt;rep&gt;;
632    seconds s;
633    using milliseconds = std::chrono::duration&lt;rep, std::milli&gt;;
634    bool negative;
635    using char_type = typename FormatContext::char_type;
636    explicit chrono_formatter(FormatContext&amp; ctx, OutputIt o,
637                              std::chrono::duration&lt;Rep, Period&gt; d)
638        : context(ctx),
639          out(o),
640          val(static_cast&lt;rep&gt;(d.count())),
641          negative(false) {
642      if (d.count() &lt; 0) {
643        val = 0 - val;
644        negative = true;
645      }
646  #if FMT_SAFE_DURATION_CAST
647      auto tmpval = std::chrono::duration&lt;rep, Period&gt;(val);
648      s = fmt_safe_duration_cast&lt;seconds&gt;(tmpval);
649  #else
650      s = std::chrono::duration_cast&lt;seconds&gt;(
651          std::chrono::duration&lt;rep, Period&gt;(val));
652  #endif
653    }
654    bool handle_nan_inf() {
655      if (isfinite(val)) {
656        return false;
657      }
658      if (isnan(val)) {
659        write_nan();
660        return true;
661      }
662      if (val &gt; 0) {
663        write_pinf();
664      } else {
665        write_ninf();
666      }
667      return true;
668    }
669    Rep hour() const { return static_cast&lt;Rep&gt;(mod((s.count() / 3600), 24)); }
670    Rep hour12() const {
671      Rep hour = static_cast&lt;Rep&gt;(mod((s.count() / 3600), 12));
672      return hour &lt;= 0 ? 12 : hour;
673    }
674    Rep minute() const { return static_cast&lt;Rep&gt;(mod((s.count() / 60), 60)); }
675    Rep second() const { return static_cast&lt;Rep&gt;(mod(s.count(), 60)); }
676    std::tm time() const {
677      auto time = std::tm();
678      time.tm_hour = to_nonnegative_int(hour(), 24);
679      time.tm_min = to_nonnegative_int(minute(), 60);
680      time.tm_sec = to_nonnegative_int(second(), 60);
681      return time;
682    }
683    void write_sign() {
684      if (negative) {
685        *out++ = &#x27;-&#x27;;
686        negative = false;
687      }
688    }
689    void write(Rep value, int width) {
690      write_sign();
691      if (isnan(value)) return write_nan();
692      uint32_or_64_or_128_t&lt;int&gt; n =
693          to_unsigned(to_nonnegative_int(value, max_value&lt;int&gt;()));
694      int num_digits = detail::count_digits(n);
695      if (width &gt; num_digits) out = std::fill_n(out, width - num_digits, &#x27;0&#x27;);
696      out = format_decimal&lt;char_type&gt;(out, n, num_digits).end;
697    }
698    void write_nan() { std::copy_n(&quot;nan&quot;, 3, out); }
699    void write_pinf() { std::copy_n(&quot;inf&quot;, 3, out); }
700    void write_ninf() { std::copy_n(&quot;-inf&quot;, 4, out); }
701    void format_localized(const tm&amp; time, char format, char modifier = 0) {
702      if (isnan(val)) return write_nan();
703      auto locale = context.locale().template get&lt;std::locale&gt;();
704      auto&amp; facet = std::use_facet&lt;std::time_put&lt;char_type&gt;&gt;(locale);
705      std::basic_ostringstream&lt;char_type&gt; os;
706      os.imbue(locale);
707      facet.put(os, os, &#x27; &#x27;, &amp;time, format, modifier);
708      auto str = os.str();
709      std::copy(str.begin(), str.end(), out);
710    }
711    void on_text(const char_type* begin, const char_type* end) {
712      std::copy(begin, end, out);
713    }
714    void on_abbr_weekday() {}
715    void on_full_weekday() {}
716    void on_dec0_weekday(numeric_system) {}
717    void on_dec1_weekday(numeric_system) {}
718    void on_abbr_month() {}
719    void on_full_month() {}
720    void on_datetime(numeric_system) {}
721    void on_loc_date(numeric_system) {}
722    void on_loc_time(numeric_system) {}
723    void on_us_date() {}
724    void on_iso_date() {}
725    void on_utc_offset() {}
726    void on_tz_name() {}
727    void on_24_hour(numeric_system ns) {
728      if (handle_nan_inf()) return;
729      if (ns == numeric_system::standard) return write(hour(), 2);
730      auto time = tm();
731      time.tm_hour = to_nonnegative_int(hour(), 24);
732      format_localized(time, &#x27;H&#x27;, &#x27;O&#x27;);
733    }
734    void on_12_hour(numeric_system ns) {
735      if (handle_nan_inf()) return;
736      if (ns == numeric_system::standard) return write(hour12(), 2);
737      auto time = tm();
738      time.tm_hour = to_nonnegative_int(hour12(), 12);
739      format_localized(time, &#x27;I&#x27;, &#x27;O&#x27;);
740    }
741    void on_minute(numeric_system ns) {
742      if (handle_nan_inf()) return;
743      if (ns == numeric_system::standard) return write(minute(), 2);
744      auto time = tm();
745      time.tm_min = to_nonnegative_int(minute(), 60);
746      format_localized(time, &#x27;M&#x27;, &#x27;O&#x27;);
747    }
748    void on_second(numeric_system ns) {
749      if (handle_nan_inf()) return;
750      if (ns == numeric_system::standard) {
751        write(second(), 2);
752  #if FMT_SAFE_DURATION_CAST
753        using duration_rep = std::chrono::duration&lt;rep, Period&gt;;
754        using duration_Rep = std::chrono::duration&lt;Rep, Period&gt;;
755        auto tmpval = fmt_safe_duration_cast&lt;duration_Rep&gt;(duration_rep{val});
756  #else
757        auto tmpval = std::chrono::duration&lt;Rep, Period&gt;(val);
758  #endif
759        auto ms = get_milliseconds(tmpval);
760        if (ms != std::chrono::milliseconds(0)) {
761          *out++ = &#x27;.&#x27;;
762          write(ms.count(), 3);
763        }
764        return;
765      }
766      auto time = tm();
767      time.tm_sec = to_nonnegative_int(second(), 60);
768      format_localized(time, &#x27;S&#x27;, &#x27;O&#x27;);
769    }
770    void on_12_hour_time() {
771      if (handle_nan_inf()) return;
772      format_localized(time(), &#x27;r&#x27;);
773    }
774    void on_24_hour_time() {
775      if (handle_nan_inf()) {
776        *out++ = &#x27;:&#x27;;
777        handle_nan_inf();
778        return;
779      }
780      write(hour(), 2);
781      *out++ = &#x27;:&#x27;;
782      write(minute(), 2);
783    }
784    void on_iso_time() {
785      on_24_hour_time();
786      *out++ = &#x27;:&#x27;;
787      if (handle_nan_inf()) return;
788      write(second(), 2);
789    }
790    void on_am_pm() {
791      if (handle_nan_inf()) return;
792      format_localized(time(), &#x27;p&#x27;);
793    }
794    void on_duration_value() {
795      if (handle_nan_inf()) return;
796      write_sign();
797      out = format_duration_value&lt;char_type&gt;(out, val, precision);
798    }
799    void on_duration_unit() {
800      out = format_duration_unit&lt;char_type, Period&gt;(out);
801    }
802  };
803  }  
804  template &lt;typename Rep, typename Period, typename Char&gt;
805  struct formatter&lt;std::chrono::duration&lt;Rep, Period&gt;, Char&gt; {
806   private:
807    basic_format_specs&lt;Char&gt; specs;
808    int precision;
809    using arg_ref_type = detail::arg_ref&lt;Char&gt;;
810    arg_ref_type width_ref;
811    arg_ref_type precision_ref;
812    mutable basic_string_view&lt;Char&gt; format_str;
813    using duration = std::chrono::duration&lt;Rep, Period&gt;;
814    struct spec_handler {
815      formatter&amp; f;
816      basic_format_parse_context&lt;Char&gt;&amp; context;
817      basic_string_view&lt;Char&gt; format_str;
818      template &lt;typename Id&gt; FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
819        context.check_arg_id(arg_id);
820        return arg_ref_type(arg_id);
821      }
822      FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view&lt;Char&gt; arg_id) {
823        context.check_arg_id(arg_id);
824        return arg_ref_type(arg_id);
825      }
826      FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
827        return arg_ref_type(context.next_arg_id());
828      }
829      void on_error(const char* msg) { FMT_THROW(format_error(msg)); }
830      void on_fill(basic_string_view&lt;Char&gt; fill) { f.specs.fill = fill; }
831      void on_align(align_t align) { f.specs.align = align; }
832      void on_width(int width) { f.specs.width = width; }
833      void on_precision(int _precision) { f.precision = _precision; }
834      void end_precision() {}
835      template &lt;typename Id&gt; void on_dynamic_width(Id arg_id) {
836        f.width_ref = make_arg_ref(arg_id);
837      }
838      template &lt;typename Id&gt; void on_dynamic_precision(Id arg_id) {
839        f.precision_ref = make_arg_ref(arg_id);
840      }
841    };
842    using iterator = typename basic_format_parse_context&lt;Char&gt;::iterator;
843    struct parse_range {
844      iterator begin;
845      iterator end;
846    };
847    FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context&lt;Char&gt;&amp; ctx) {
848      auto begin = ctx.begin(), end = ctx.end();
849      if (begin == end || *begin == &#x27;}&#x27;) return {begin, begin};
850      spec_handler handler{*this, ctx, format_str};
851      begin = detail::parse_align(begin, end, handler);
852      if (begin == end) return {begin, begin};
853      begin = detail::parse_width(begin, end, handler);
854      if (begin == end) return {begin, begin};
855      if (*begin == &#x27;.&#x27;) {
856        if (std::is_floating_point&lt;Rep&gt;::value)
857          begin = detail::parse_precision(begin, end, handler);
858        else
859          handler.on_error(&quot;precision not allowed for this argument type&quot;);
860      }
861      end = parse_chrono_format(begin, end, detail::chrono_format_checker());
862      return {begin, end};
863    }
864   public:
865    formatter() : precision(-1) {}
866    FMT_CONSTEXPR auto parse(basic_format_parse_context&lt;Char&gt;&amp; ctx)
867        -&gt; decltype(ctx.begin()) {
868      auto range = do_parse(ctx);
869      format_str = basic_string_view&lt;Char&gt;(
870          &amp;*range.begin, detail::to_unsigned(range.end - range.begin));
871      return range.end;
872    }
873    template &lt;typename FormatContext&gt;
874    auto format(const duration&amp; d, FormatContext&amp; ctx) -&gt; decltype(ctx.out()) {
875      auto begin = format_str.begin(), end = format_str.end();
876      basic_memory_buffer&lt;Char&gt; buf;
877      auto out = std::back_inserter(buf);
878      detail::handle_dynamic_spec&lt;detail::width_checker&gt;(specs.width, width_ref,
879                                                         ctx);
880      detail::handle_dynamic_spec&lt;detail::precision_checker&gt;(precision,
881                                                             precision_ref, ctx);
882      if (begin == end || *begin == &#x27;}&#x27;) {
883        out = detail::format_duration_value&lt;Char&gt;(out, d.count(), precision);
884        detail::format_duration_unit&lt;Char, Period&gt;(out);
885      } else {
886        detail::chrono_formatter&lt;FormatContext, decltype(out), Rep, Period&gt; f(
887            ctx, out, d);
888        f.precision = precision;
889        parse_chrono_format(begin, end, f);
890      }
891      return detail::write(
892          ctx.out(), basic_string_view&lt;Char&gt;(buf.data(), buf.size()), specs);
893    }
894  };
895  FMT_END_NAMESPACE
896  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-core.h</h3>
            <pre><code>1  #ifndef FMT_CORE_H_
2  #define FMT_CORE_H_
3  #include &lt;cstdio&gt;  
4  #include &lt;cstring&gt;
5  #include &lt;functional&gt;
6  #include &lt;iterator&gt;
7  #include &lt;memory&gt;
8  #include &lt;string&gt;
9  #include &lt;type_traits&gt;
10  #include &lt;vector&gt;
11  #define FMT_VERSION 70003
12  #ifdef __clang__
13  #  define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
14  #else
15  #  define FMT_CLANG_VERSION 0
16  #endif
17  #if defined(__GNUC__) &amp;&amp; !defined(__clang__)
18  #  define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
19  #else
20  #  define FMT_GCC_VERSION 0
21  #endif
22  #if defined(__INTEL_COMPILER)
23  #  define FMT_ICC_VERSION __INTEL_COMPILER
24  #else
25  #  define FMT_ICC_VERSION 0
26  #endif
27  #if __cplusplus &gt;= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
28  #  define FMT_HAS_GXX_CXX11 FMT_GCC_VERSION
29  #else
30  #  define FMT_HAS_GXX_CXX11 0
31  #endif
32  #ifdef __NVCC__
33  #  define FMT_NVCC __NVCC__
34  #else
35  #  define FMT_NVCC 0
36  #endif
37  #ifdef _MSC_VER
38  #  define FMT_MSC_VER _MSC_VER
39  #  define FMT_SUPPRESS_MSC_WARNING(n) __pragma(warning(suppress : n))
40  #else
41  #  define FMT_MSC_VER 0
42  #  define FMT_SUPPRESS_MSC_WARNING(n)
43  #endif
44  #ifdef __has_feature
45  #  define FMT_HAS_FEATURE(x) __has_feature(x)
46  #else
47  #  define FMT_HAS_FEATURE(x) 0
48  #endif
49  #if defined(__has_include) &amp;&amp; !defined(__INTELLISENSE__) &amp;&amp; \
50      (!FMT_ICC_VERSION || FMT_ICC_VERSION &gt;= 1600)
51  #  define FMT_HAS_INCLUDE(x) __has_include(x)
52  #else
53  #  define FMT_HAS_INCLUDE(x) 0
54  #endif
55  #ifdef __has_cpp_attribute
56  #  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
57  #else
58  #  define FMT_HAS_CPP_ATTRIBUTE(x) 0
59  #endif
60  #define FMT_HAS_CPP14_ATTRIBUTE(attribute) \
61    (__cplusplus &gt;= 201402L &amp;&amp; FMT_HAS_CPP_ATTRIBUTE(attribute))
62  #define FMT_HAS_CPP17_ATTRIBUTE(attribute) \
63    (__cplusplus &gt;= 201703L &amp;&amp; FMT_HAS_CPP_ATTRIBUTE(attribute))
64  #ifndef FMT_USE_CONSTEXPR
65  #  define FMT_USE_CONSTEXPR                                           \
66      (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VER &gt;= 1910 || \
67       (FMT_GCC_VERSION &gt;= 600 &amp;&amp; __cplusplus &gt;= 201402L)) &amp;&amp;           \
68          !FMT_NVCC &amp;&amp; !FMT_ICC_VERSION
69  #endif
70  #if FMT_USE_CONSTEXPR
71  #  define FMT_CONSTEXPR constexpr
72  #  define FMT_CONSTEXPR_DECL constexpr
73  #else
74  #  define FMT_CONSTEXPR inline
75  #  define FMT_CONSTEXPR_DECL
76  #endif
77  #ifndef FMT_OVERRIDE
78  #  if FMT_HAS_FEATURE(cxx_override_control) || \
79        (FMT_GCC_VERSION &gt;= 408 &amp;&amp; FMT_HAS_GXX_CXX11) || FMT_MSC_VER &gt;= 1900
80  #    define FMT_OVERRIDE override
81  #  else
82  #    define FMT_OVERRIDE
83  #  endif
84  #endif
85  #ifndef FMT_EXCEPTIONS
86  #  if (defined(__GNUC__) &amp;&amp; !defined(__EXCEPTIONS)) || \
87        FMT_MSC_VER &amp;&amp; !_HAS_EXCEPTIONS
88  #    define FMT_EXCEPTIONS 0
89  #  else
90  #    define FMT_EXCEPTIONS 1
91  #  endif
92  #endif
93  #ifndef FMT_USE_NOEXCEPT
94  #  define FMT_USE_NOEXCEPT 0
95  #endif
96  #if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \
97      (FMT_GCC_VERSION &gt;= 408 &amp;&amp; FMT_HAS_GXX_CXX11) || FMT_MSC_VER &gt;= 1900
98  #  define FMT_DETECTED_NOEXCEPT noexcept
99  #  define FMT_HAS_CXX11_NOEXCEPT 1
100  #else
101  #  define FMT_DETECTED_NOEXCEPT throw()
102  #  define FMT_HAS_CXX11_NOEXCEPT 0
103  #endif
104  #ifndef FMT_NOEXCEPT
105  #  if FMT_EXCEPTIONS || FMT_HAS_CXX11_NOEXCEPT
106  #    define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT
107  #  else
108  #    define FMT_NOEXCEPT
109  #  endif
110  #endif
111  #if FMT_EXCEPTIONS &amp;&amp; FMT_HAS_CPP_ATTRIBUTE(noreturn) &amp;&amp; !FMT_MSC_VER &amp;&amp; \
112      !FMT_NVCC
113  #  define FMT_NORETURN [[noreturn]]
114  #else
115  #  define FMT_NORETURN
116  #endif
117  #ifndef FMT_DEPRECATED
118  #  if FMT_HAS_CPP14_ATTRIBUTE(deprecated) || FMT_MSC_VER &gt;= 1900
119  #    define FMT_DEPRECATED [[deprecated]]
120  #  else
121  #    if (defined(__GNUC__) &amp;&amp; !defined(__LCC__)) || defined(__clang__)
122  #      define FMT_DEPRECATED __attribute__((deprecated))
123  #    elif FMT_MSC_VER
124  #      define FMT_DEPRECATED __declspec(deprecated)
125  #    else
126  #      define FMT_DEPRECATED &amp;bsol;* deprecated */
127  #    endif
128  #  endif
129  #endif
130  #if FMT_ICC_VERSION || defined(__PGI) || FMT_NVCC
131  #  define FMT_DEPRECATED_ALIAS
132  #else
133  #  define FMT_DEPRECATED_ALIAS FMT_DEPRECATED
134  #endif
135  #ifndef FMT_INLINE
136  #  if FMT_GCC_VERSION || FMT_CLANG_VERSION
137  #    define FMT_INLINE inline __attribute__((always_inline))
138  #  else
139  #    define FMT_INLINE inline
140  #  endif
141  #endif
142  #ifndef FMT_BEGIN_NAMESPACE
143  #  if FMT_HAS_FEATURE(cxx_inline_namespaces) || FMT_GCC_VERSION &gt;= 404 || \
144        (FMT_MSC_VER &gt;= 1900 &amp;&amp; !_MANAGED)
145  #    define FMT_INLINE_NAMESPACE inline namespace
146  #    define FMT_END_NAMESPACE \
147        }                       \
148        }
149  #  else
150  #    define FMT_INLINE_NAMESPACE namespace
151  #    define FMT_END_NAMESPACE \
152        }                       \
153        using namespace v7;     \
154        }
155  #  endif
156  #  define FMT_BEGIN_NAMESPACE \
157      namespace fmt {           \
158      FMT_INLINE_NAMESPACE v7 {
159  #endif
160  #if !defined(FMT_HEADER_ONLY) &amp;&amp; defined(_WIN32)
161  #  define FMT_CLASS_API FMT_SUPPRESS_MSC_WARNING(4275)
162  #  ifdef FMT_EXPORT
163  #    define FMT_API __declspec(dllexport)
164  #    define FMT_EXTERN_TEMPLATE_API FMT_API
165  #    define FMT_EXPORTED
166  #  elif defined(FMT_SHARED)
167  #    define FMT_API __declspec(dllimport)
168  #    define FMT_EXTERN_TEMPLATE_API FMT_API
169  #  endif
170  #else
171  #  define FMT_CLASS_API
172  #endif
173  #ifndef FMT_API
174  #  define FMT_API
175  #endif
176  #ifndef FMT_EXTERN_TEMPLATE_API
177  #  define FMT_EXTERN_TEMPLATE_API
178  #endif
179  #ifndef FMT_INSTANTIATION_DEF_API
180  #  define FMT_INSTANTIATION_DEF_API FMT_API
181  #endif
182  #ifndef FMT_HEADER_ONLY
183  #  define FMT_EXTERN extern
184  #else
185  #  define FMT_EXTERN
186  #endif
187  #if (FMT_HAS_INCLUDE(&lt;string_view&gt;) &amp;&amp;                       \
188       (__cplusplus &gt; 201402L || defined(_LIBCPP_VERSION))) || \
189      (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt; 201402L &amp;&amp; _MSC_VER &gt;= 1910)
190  #  include &lt;string_view&gt;
191  #  define FMT_USE_STRING_VIEW
192  #elif FMT_HAS_INCLUDE(&quot;experimental/string_view&quot;) &amp;&amp; __cplusplus &gt;= 201402L
193  #  include &lt;experimental/string_view&gt;
194  #  define FMT_USE_EXPERIMENTAL_STRING_VIEW
195  #endif
196  #ifndef FMT_UNICODE
197  #  define FMT_UNICODE !FMT_MSC_VER
198  #endif
199  #if FMT_UNICODE &amp;&amp; FMT_MSC_VER
200  #  pragma execution_character_set(&quot;utf-8&quot;)
201  #endif
202  FMT_BEGIN_NAMESPACE
203  template &lt;bool B, class T = void&gt;
204  using enable_if_t = typename std::enable_if&lt;B, T&gt;::type;
205  template &lt;bool B, class T, class F&gt;
206  using conditional_t = typename std::conditional&lt;B, T, F&gt;::type;
207  template &lt;bool B&gt; using bool_constant = std::integral_constant&lt;bool, B&gt;;
208  template &lt;typename T&gt;
209  using remove_reference_t = typename std::remove_reference&lt;T&gt;::type;
210  template &lt;typename T&gt;
211  using remove_const_t = typename std::remove_const&lt;T&gt;::type;
212  template &lt;typename T&gt;
213  using remove_cvref_t = typename std::remove_cv&lt;remove_reference_t&lt;T&gt;&gt;::type;
214  template &lt;typename T&gt; struct type_identity { using type = T; };
215  template &lt;typename T&gt; using type_identity_t = typename type_identity&lt;T&gt;::type;
216  struct monostate {};
217  #define FMT_ENABLE_IF(...) enable_if_t&lt;(__VA_ARGS__), int&gt; = 0
218  namespace detail {
219  template &lt;typename T&gt; constexpr T const_check(T value) { return value; }
220  FMT_NORETURN FMT_API void assert_fail(const char* file, int line,
221                                        const char* message);
222  #ifndef FMT_ASSERT
223  #  ifdef NDEBUG
224  #    define FMT_ASSERT(condition, message) ((void)0)
225  #  else
226  #    define FMT_ASSERT(condition, message)                                    \
227        ((condition) &amp;bsol;* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
228             ? (void)0                                                          \
229             : ::fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
230  #  endif
231  #endif
232  #if defined(FMT_USE_STRING_VIEW)
233  template &lt;typename Char&gt; using std_string_view = std::basic_string_view&lt;Char&gt;;
234  #elif defined(FMT_USE_EXPERIMENTAL_STRING_VIEW)
235  template &lt;typename Char&gt;
236  using std_string_view = std::experimental::basic_string_view&lt;Char&gt;;
237  #else
238  template &lt;typename T&gt; struct std_string_view {};
239  #endif
240  #ifdef FMT_USE_INT128
241  #elif defined(__SIZEOF_INT128__) &amp;&amp; !FMT_NVCC &amp;&amp; \
242      !(FMT_CLANG_VERSION &amp;&amp; FMT_MSC_VER)
243  #  define FMT_USE_INT128 1
244  using int128_t = __int128_t;
245  using uint128_t = __uint128_t;
246  #else
247  #  define FMT_USE_INT128 0
248  #endif
249  #if !FMT_USE_INT128
250  struct int128_t {};
251  struct uint128_t {};
252  #endif
253  template &lt;typename Int&gt;
254  FMT_CONSTEXPR typename std::make_unsigned&lt;Int&gt;::type to_unsigned(Int value) {
255    FMT_ASSERT(value &gt;= 0, &quot;negative value&quot;);
256    return static_cast&lt;typename std::make_unsigned&lt;Int&gt;::type&gt;(value);
257  }
258  FMT_SUPPRESS_MSC_WARNING(4566) constexpr unsigned char micro[] = &quot;\u00B5&quot;;
259  template &lt;typename Char&gt; constexpr bool is_unicode() {
260    return FMT_UNICODE || sizeof(Char) != 1 ||
261           (sizeof(micro) == 3 &amp;&amp; micro[0] == 0xC2 &amp;&amp; micro[1] == 0xB5);
262  }
263  #ifdef __cpp_char8_t
264  using char8_type = char8_t;
265  #else
266  enum char8_type : unsigned char {};
267  #endif
268  }  
269  #ifdef FMT_USE_INTERNAL
270  namespace internal = detail;  
271  #endif
272  template &lt;typename Char&gt; class basic_string_view {
273   private:
274    const Char* data_;
275    size_t size_;
276   public:
277    using value_type = Char;
278    using iterator = const Char*;
279    constexpr basic_string_view() FMT_NOEXCEPT : data_(nullptr), size_(0) {}
280    constexpr basic_string_view(const Char* s, size_t count) FMT_NOEXCEPT
281        : data_(s),
282          size_(count) {}
283  #if __cplusplus &gt;= 201703L  
284    FMT_CONSTEXPR
285  #endif
286    basic_string_view(const Char* s)
287        : data_(s), size_(std::char_traits&lt;Char&gt;::length(s)) {}
288    template &lt;typename Traits, typename Alloc&gt;
289    FMT_CONSTEXPR basic_string_view(
290        const std::basic_string&lt;Char, Traits, Alloc&gt;&amp; s) FMT_NOEXCEPT
291        : data_(s.data()),
292          size_(s.size()) {}
293    template &lt;typename S, FMT_ENABLE_IF(std::is_same&lt;
294                                        S, detail::std_string_view&lt;Char&gt;&gt;::value)&gt;
295    FMT_CONSTEXPR basic_string_view(S s) FMT_NOEXCEPT : data_(s.data()),
296                                                        size_(s.size()) {}
297    constexpr const Char* data() const { return data_; }
298    constexpr size_t size() const { return size_; }
299    constexpr iterator begin() const { return data_; }
300    constexpr iterator end() const { return data_ + size_; }
301    constexpr const Char&amp; operator[](size_t pos) const { return data_[pos]; }
302    FMT_CONSTEXPR void remove_prefix(size_t n) {
303      data_ += n;
304      size_ -= n;
305    }
306    int compare(basic_string_view other) const {
307      size_t str_size = size_ &lt; other.size_ ? size_ : other.size_;
308      int result = std::char_traits&lt;Char&gt;::compare(data_, other.data_, str_size);
309      if (result == 0)
310        result = size_ == other.size_ ? 0 : (size_ &lt; other.size_ ? -1 : 1);
311      return result;
312    }
313    friend bool operator==(basic_string_view lhs, basic_string_view rhs) {
314      return lhs.compare(rhs) == 0;
315    }
316    friend bool operator!=(basic_string_view lhs, basic_string_view rhs) {
317      return lhs.compare(rhs) != 0;
318    }
319    friend bool operator&lt;(basic_string_view lhs, basic_string_view rhs) {
320      return lhs.compare(rhs) &lt; 0;
321    }
322    friend bool operator&lt;=(basic_string_view lhs, basic_string_view rhs) {
323      return lhs.compare(rhs) &lt;= 0;
324    }
325    friend bool operator&gt;(basic_string_view lhs, basic_string_view rhs) {
326      return lhs.compare(rhs) &gt; 0;
327    }
328    friend bool operator&gt;=(basic_string_view lhs, basic_string_view rhs) {
329      return lhs.compare(rhs) &gt;= 0;
330    }
331  };
332  using string_view = basic_string_view&lt;char&gt;;
333  using wstring_view = basic_string_view&lt;wchar_t&gt;;
334  template &lt;typename T&gt; struct is_char : std::false_type {};
335  template &lt;&gt; struct is_char&lt;char&gt; : std::true_type {};
336  template &lt;&gt; struct is_char&lt;wchar_t&gt; : std::true_type {};
337  template &lt;&gt; struct is_char&lt;detail::char8_type&gt; : std::true_type {};
338  template &lt;&gt; struct is_char&lt;char16_t&gt; : std::true_type {};
339  template &lt;&gt; struct is_char&lt;char32_t&gt; : std::true_type {};
340  template &lt;typename Char, FMT_ENABLE_IF(is_char&lt;Char&gt;::value)&gt;
341  inline basic_string_view&lt;Char&gt; to_string_view(const Char* s) {
342    return s;
343  }
344  template &lt;typename Char, typename Traits, typename Alloc&gt;
345  inline basic_string_view&lt;Char&gt; to_string_view(
346      const std::basic_string&lt;Char, Traits, Alloc&gt;&amp; s) {
347    return s;
348  }
349  template &lt;typename Char&gt;
350  inline basic_string_view&lt;Char&gt; to_string_view(basic_string_view&lt;Char&gt; s) {
351    return s;
352  }
353  template &lt;typename Char,
354            FMT_ENABLE_IF(!std::is_empty&lt;detail::std_string_view&lt;Char&gt;&gt;::value)&gt;
355  inline basic_string_view&lt;Char&gt; to_string_view(detail::std_string_view&lt;Char&gt; s) {
356    return s;
357  }
358  struct compile_string {};
359  template &lt;typename S&gt;
360  struct is_compile_string : std::is_base_of&lt;compile_string, S&gt; {};
361  template &lt;typename S, FMT_ENABLE_IF(is_compile_string&lt;S&gt;::value)&gt;
362  constexpr basic_string_view&lt;typename S::char_type&gt; to_string_view(const S&amp; s) {
363    return s;
364  }
365  namespace detail {
366  void to_string_view(...);
367  using fmt::v7::to_string_view;
368  template &lt;typename S&gt;
369  struct is_string : std::is_class&lt;decltype(to_string_view(std::declval&lt;S&gt;()))&gt; {
370  };
371  template &lt;typename S, typename = void&gt; struct char_t_impl {};
372  template &lt;typename S&gt; struct char_t_impl&lt;S, enable_if_t&lt;is_string&lt;S&gt;::value&gt;&gt; {
373    using result = decltype(to_string_view(std::declval&lt;S&gt;()));
374    using type = typename result::value_type;
375  };
376  template &lt;typename..., typename S, FMT_ENABLE_IF(!is_compile_string&lt;S&gt;::value)&gt;
377  FMT_INLINE void check_format_string(const S&amp;) {
378  #ifdef FMT_ENFORCE_COMPILE_STRING
379    static_assert(is_compile_string&lt;S&gt;::value,
380                  &quot;FMT_ENFORCE_COMPILE_STRING requires all format strings to use &quot;
381                  &quot;FMT_STRING.&quot;);
382  #endif
383  }
384  template &lt;typename..., typename S, FMT_ENABLE_IF(is_compile_string&lt;S&gt;::value)&gt;
385  void check_format_string(S);
386  struct error_handler {
387    constexpr error_handler() = default;
388    constexpr error_handler(const error_handler&amp;) = default;
389    FMT_NORETURN FMT_API void on_error(const char* message);
390  };
391  }  
392  template &lt;typename S&gt; using char_t = typename detail::char_t_impl&lt;S&gt;::type;
393  template &lt;typename Char, typename ErrorHandler = detail::error_handler&gt;
394  class basic_format_parse_context : private ErrorHandler {
395   private:
396    basic_string_view&lt;Char&gt; format_str_;
397    int next_arg_id_;
398   public:
399    using char_type = Char;
400    using iterator = typename basic_string_view&lt;Char&gt;::iterator;
401    explicit constexpr basic_format_parse_context(
402        basic_string_view&lt;Char&gt; format_str, ErrorHandler eh = {},
403        int next_arg_id = 0)
404        : ErrorHandler(eh), format_str_(format_str), next_arg_id_(next_arg_id) {}
405    constexpr iterator begin() const FMT_NOEXCEPT { return format_str_.begin(); }
406    constexpr iterator end() const FMT_NOEXCEPT { return format_str_.end(); }
407    FMT_CONSTEXPR void advance_to(iterator it) {
408      format_str_.remove_prefix(detail::to_unsigned(it - begin()));
409    }
410    FMT_CONSTEXPR int next_arg_id() {
411      if (next_arg_id_ &gt;= 0) return next_arg_id_++;
412      on_error(&quot;cannot switch from manual to automatic argument indexing&quot;);
413      return 0;
414    }
415    FMT_CONSTEXPR void check_arg_id(int) {
416      if (next_arg_id_ &gt; 0)
417        on_error(&quot;cannot switch from automatic to manual argument indexing&quot;);
418      else
419        next_arg_id_ = -1;
420    }
421    FMT_CONSTEXPR void check_arg_id(basic_string_view&lt;Char&gt;) {}
422    FMT_CONSTEXPR void on_error(const char* message) {
423      ErrorHandler::on_error(message);
424    }
425    constexpr ErrorHandler error_handler() const { return *this; }
426  };
427  using format_parse_context = basic_format_parse_context&lt;char&gt;;
428  using wformat_parse_context = basic_format_parse_context&lt;wchar_t&gt;;
429  template &lt;typename Context&gt; class basic_format_arg;
430  template &lt;typename Context&gt; class basic_format_args;
431  template &lt;typename Context&gt; class dynamic_format_arg_store;
432  template &lt;typename T, typename Char = char, typename Enable = void&gt;
433  struct formatter {
434    formatter() = delete;
435  };
436  template &lt;typename T, typename Context&gt;
437  using has_formatter =
438      std::is_constructible&lt;typename Context::template formatter_type&lt;T&gt;&gt;;
439  template &lt;typename T&gt; struct is_contiguous : std::false_type {};
440  template &lt;typename Char&gt;
441  struct is_contiguous&lt;std::basic_string&lt;Char&gt;&gt; : std::true_type {};
442  namespace detail {
443  template &lt;typename Container&gt;
444  inline Container&amp; get_container(std::back_insert_iterator&lt;Container&gt; it) {
445    using bi_iterator = std::back_insert_iterator&lt;Container&gt;;
446    struct accessor : bi_iterator {
447      accessor(bi_iterator iter) : bi_iterator(iter) {}
448      using bi_iterator::container;
449    };
450    return *accessor(it).container;
451  }
452  template &lt;typename T&gt; class buffer {
453   private:
454    T* ptr_;
455    size_t size_;
456    size_t capacity_;
457   protected:
458    FMT_SUPPRESS_MSC_WARNING(26495)
459    buffer(size_t sz) FMT_NOEXCEPT : size_(sz), capacity_(sz) {}
460    buffer(T* p = nullptr, size_t sz = 0, size_t cap = 0) FMT_NOEXCEPT
461        : ptr_(p),
462          size_(sz),
463          capacity_(cap) {}
464    ~buffer() = default;
465    void set(T* buf_data, size_t buf_capacity) FMT_NOEXCEPT {
466      ptr_ = buf_data;
467      capacity_ = buf_capacity;
468    }
469    virtual void grow(size_t capacity) = 0;
470   public:
471    using value_type = T;
472    using const_reference = const T&amp;;
473    buffer(const buffer&amp;) = delete;
474    void operator=(const buffer&amp;) = delete;
475    T* begin() FMT_NOEXCEPT { return ptr_; }
476    T* end() FMT_NOEXCEPT { return ptr_ + size_; }
477    const T* begin() const FMT_NOEXCEPT { return ptr_; }
478    const T* end() const FMT_NOEXCEPT { return ptr_ + size_; }
479    size_t size() const FMT_NOEXCEPT { return size_; }
480    size_t capacity() const FMT_NOEXCEPT { return capacity_; }
481    T* data() FMT_NOEXCEPT { return ptr_; }
482    const T* data() const FMT_NOEXCEPT { return ptr_; }
483    void clear() { size_ = 0; }
484    void try_resize(size_t count) {
485      try_reserve(count);
486      size_ = count &lt;= capacity_ ? count : capacity_;
487    }
488    void try_reserve(size_t new_capacity) {
489      if (new_capacity &gt; capacity_) grow(new_capacity);
490    }
491    void push_back(const T&amp; value) {
492      try_reserve(size_ + 1);
493      ptr_[size_++] = value;
494    }
495    template &lt;typename U&gt; void append(const U* begin, const U* end);
496    template &lt;typename I&gt; T&amp; operator[](I index) { return ptr_[index]; }
497    template &lt;typename I&gt; const T&amp; operator[](I index) const {
498      return ptr_[index];
499    }
500  };
501  struct buffer_traits {
502    explicit buffer_traits(size_t) {}
503    size_t count() const { return 0; }
504    size_t limit(size_t size) { return size; }
505  };
506  class fixed_buffer_traits {
507   private:
508    size_t count_ = 0;
509    size_t limit_;
510   public:
511    explicit fixed_buffer_traits(size_t limit) : limit_(limit) {}
512    size_t count() const { return count_; }
513    size_t limit(size_t size) {
514      size_t n = limit_ - count_;
515      count_ += size;
516      return size &lt; n ? size : n;
517    }
518  };
519  template &lt;typename OutputIt, typename T, typename Traits = buffer_traits&gt;
520  class iterator_buffer : public Traits, public buffer&lt;T&gt; {
521   private:
522    OutputIt out_;
523    enum { buffer_size = 256 };
524    T data_[buffer_size];
525   protected:
526    void grow(size_t) final FMT_OVERRIDE {
527      if (this-&gt;size() == buffer_size) flush();
528    }
529    void flush();
530   public:
531    explicit iterator_buffer(OutputIt out, size_t n = buffer_size)
532        : Traits(n),
533          buffer&lt;T&gt;(data_, 0, n &lt; size_t(buffer_size) ? n : size_t(buffer_size)),
534          out_(out) {}
535    ~iterator_buffer() { flush(); }
536    OutputIt out() {
537      flush();
538      return out_;
539    }
540    size_t count() const { return Traits::count() + this-&gt;size(); }
541  };
542  template &lt;typename T&gt; class iterator_buffer&lt;T*, T&gt; : public buffer&lt;T&gt; {
543   protected:
544    void grow(size_t) final FMT_OVERRIDE {}
545   public:
546    explicit iterator_buffer(T* out, size_t = 0) : buffer&lt;T&gt;(out, 0, ~size_t()) {}
547    T* out() { return &amp;*this-&gt;end(); }
548  };
549  template &lt;typename Container&gt;
550  class iterator_buffer&lt;std::back_insert_iterator&lt;Container&gt;,
551                        enable_if_t&lt;is_contiguous&lt;Container&gt;::value,
552                                    typename Container::value_type&gt;&gt;
553      : public buffer&lt;typename Container::value_type&gt; {
554   private:
555    Container&amp; container_;
556   protected:
557    void grow(size_t capacity) final FMT_OVERRIDE {
558      container_.resize(capacity);
559      this-&gt;set(&amp;container_[0], capacity);
560    }
561   public:
562    explicit iterator_buffer(Container&amp; c)
563        : buffer&lt;typename Container::value_type&gt;(c.size()), container_(c) {}
564    explicit iterator_buffer(std::back_insert_iterator&lt;Container&gt; out, size_t = 0)
565        : iterator_buffer(get_container(out)) {}
566    std::back_insert_iterator&lt;Container&gt; out() {
567      return std::back_inserter(container_);
568    }
569  };
570  template &lt;typename T = char&gt; class counting_buffer : public buffer&lt;T&gt; {
571   private:
572    enum { buffer_size = 256 };
573    T data_[buffer_size];
574    size_t count_ = 0;
575   protected:
576    void grow(size_t) final FMT_OVERRIDE {
577      if (this-&gt;size() != buffer_size) return;
578      count_ += this-&gt;size();
579      this-&gt;clear();
580    }
581   public:
582    counting_buffer() : buffer&lt;T&gt;(data_, 0, buffer_size) {}
583    size_t count() { return count_ + this-&gt;size(); }
584  };
585  template &lt;typename T&gt;
586  class buffer_appender : public std::back_insert_iterator&lt;buffer&lt;T&gt;&gt; {
587    using base = std::back_insert_iterator&lt;buffer&lt;T&gt;&gt;;
588   public:
589    explicit buffer_appender(buffer&lt;T&gt;&amp; buf) : base(buf) {}
590    buffer_appender(base it) : base(it) {}
591    buffer_appender&amp; operator++() {
592      base::operator++();
593      return *this;
594    }
595    buffer_appender operator++(int) {
596      buffer_appender tmp = *this;
597      ++*this;
598      return tmp;
599    }
600  };
601  template &lt;typename T, typename OutputIt&gt;
602  iterator_buffer&lt;OutputIt, T&gt; get_buffer(OutputIt);
603  template &lt;typename T&gt; buffer&lt;T&gt;&amp; get_buffer(buffer_appender&lt;T&gt;);
604  template &lt;typename OutputIt&gt; OutputIt get_buffer_init(OutputIt out) {
605    return out;
606  }
607  template &lt;typename T&gt; buffer&lt;T&gt;&amp; get_buffer_init(buffer_appender&lt;T&gt; out) {
608    return get_container(out);
609  }
610  template &lt;typename Buffer&gt;
611  auto get_iterator(Buffer&amp; buf) -&gt; decltype(buf.out()) {
612    return buf.out();
613  }
614  template &lt;typename T&gt; buffer_appender&lt;T&gt; get_iterator(buffer&lt;T&gt;&amp; buf) {
615    return buffer_appender&lt;T&gt;(buf);
616  }
617  template &lt;typename T, typename Char = char, typename Enable = void&gt;
618  struct fallback_formatter {
619    fallback_formatter() = delete;
620  };
621  template &lt;typename T, typename Context&gt;
622  using has_fallback_formatter =
623      std::is_constructible&lt;fallback_formatter&lt;T, typename Context::char_type&gt;&gt;;
624  struct view {};
625  template &lt;typename Char, typename T&gt; struct named_arg : view {
626    const Char* name;
627    const T&amp; value;
628    named_arg(const Char* n, const T&amp; v) : name(n), value(v) {}
629  };
630  template &lt;typename Char&gt; struct named_arg_info {
631    const Char* name;
632    int id;
633  };
<span onclick='openModal()' class='match'>634  template &lt;typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS&gt;
635  struct arg_data {
636    T args_[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)];
</span>637    named_arg_info&lt;Char&gt; named_args_[NUM_NAMED_ARGS];
638    template &lt;typename... U&gt;
639    arg_data(const U&amp;... init) : args_{T(named_args_, NUM_NAMED_ARGS), init...} {}
640    arg_data(const arg_data&amp; other) = delete;
641    const T* args() const { return args_ + 1; }
642    named_arg_info&lt;Char&gt;* named_args() { return named_args_; }
643  };
644  template &lt;typename T, typename Char, size_t NUM_ARGS&gt;
645  struct arg_data&lt;T, Char, NUM_ARGS, 0&gt; {
646    T args_[NUM_ARGS != 0 ? NUM_ARGS : +1];
647    template &lt;typename... U&gt;
648    FMT_INLINE arg_data(const U&amp;... init) : args_{init...} {}
649    FMT_INLINE const T* args() const { return args_; }
650    FMT_INLINE std::nullptr_t named_args() { return nullptr; }
651  };
652  template &lt;typename Char&gt;
653  inline void init_named_args(named_arg_info&lt;Char&gt;*, int, int) {}
654  template &lt;typename Char, typename T, typename... Tail&gt;
655  void init_named_args(named_arg_info&lt;Char&gt;* named_args, int arg_count,
656                       int named_arg_count, const T&amp;, const Tail&amp;... args) {
657    init_named_args(named_args, arg_count + 1, named_arg_count, args...);
658  }
659  template &lt;typename Char, typename T, typename... Tail&gt;
660  void init_named_args(named_arg_info&lt;Char&gt;* named_args, int arg_count,
661                       int named_arg_count, const named_arg&lt;Char, T&gt;&amp; arg,
662                       const Tail&amp;... args) {
663    named_args[named_arg_count++] = {arg.name, arg_count};
664    init_named_args(named_args, arg_count + 1, named_arg_count, args...);
665  }
666  template &lt;typename... Args&gt;
667  FMT_INLINE void init_named_args(std::nullptr_t, int, int, const Args&amp;...) {}
668  template &lt;typename T&gt; struct is_named_arg : std::false_type {};
669  template &lt;typename T, typename Char&gt;
670  struct is_named_arg&lt;named_arg&lt;Char, T&gt;&gt; : std::true_type {};
671  template &lt;bool B = false&gt; constexpr size_t count() { return B ? 1 : 0; }
672  template &lt;bool B1, bool B2, bool... Tail&gt; constexpr size_t count() {
673    return (B1 ? 1 : 0) + count&lt;B2, Tail...&gt;();
674  }
675  template &lt;typename... Args&gt; constexpr size_t count_named_args() {
676    return count&lt;is_named_arg&lt;Args&gt;::value...&gt;();
677  }
678  enum class type {
679    none_type,
680    int_type,
681    uint_type,
682    long_long_type,
683    ulong_long_type,
684    int128_type,
685    uint128_type,
686    bool_type,
687    char_type,
688    last_integer_type = char_type,
689    float_type,
690    double_type,
691    long_double_type,
692    last_numeric_type = long_double_type,
693    cstring_type,
694    string_type,
695    pointer_type,
696    custom_type
697  };
698  template &lt;typename T, typename Char&gt;
699  struct type_constant : std::integral_constant&lt;type, type::custom_type&gt; {};
700  #define FMT_TYPE_CONSTANT(Type, constant) \
701    template &lt;typename Char&gt;                \
702    struct type_constant&lt;Type, Char&gt;        \
703        : std::integral_constant&lt;type, type::constant&gt; {}
704  FMT_TYPE_CONSTANT(int, int_type);
705  FMT_TYPE_CONSTANT(unsigned, uint_type);
706  FMT_TYPE_CONSTANT(long long, long_long_type);
707  FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
708  FMT_TYPE_CONSTANT(int128_t, int128_type);
709  FMT_TYPE_CONSTANT(uint128_t, uint128_type);
710  FMT_TYPE_CONSTANT(bool, bool_type);
711  FMT_TYPE_CONSTANT(Char, char_type);
712  FMT_TYPE_CONSTANT(float, float_type);
713  FMT_TYPE_CONSTANT(double, double_type);
714  FMT_TYPE_CONSTANT(long double, long_double_type);
715  FMT_TYPE_CONSTANT(const Char*, cstring_type);
716  FMT_TYPE_CONSTANT(basic_string_view&lt;Char&gt;, string_type);
717  FMT_TYPE_CONSTANT(const void*, pointer_type);
718  constexpr bool is_integral_type(type t) {
719    return t &gt; type::none_type &amp;&amp; t &lt;= type::last_integer_type;
720  }
721  constexpr bool is_arithmetic_type(type t) {
722    return t &gt; type::none_type &amp;&amp; t &lt;= type::last_numeric_type;
723  }
724  template &lt;typename Char&gt; struct string_value {
725    const Char* data;
726    size_t size;
727  };
728  template &lt;typename Char&gt; struct named_arg_value {
729    const named_arg_info&lt;Char&gt;* data;
730    size_t size;
731  };
732  template &lt;typename Context&gt; struct custom_value {
733    using parse_context = typename Context::parse_context_type;
734    const void* value;
735    void (*format)(const void* arg, parse_context&amp; parse_ctx, Context&amp; ctx);
736  };
737  template &lt;typename Context&gt; class value {
738   public:
739    using char_type = typename Context::char_type;
740    union {
741      int int_value;
742      unsigned uint_value;
743      long long long_long_value;
744      unsigned long long ulong_long_value;
745      int128_t int128_value;
746      uint128_t uint128_value;
747      bool bool_value;
748      char_type char_value;
749      float float_value;
750      double double_value;
751      long double long_double_value;
752      const void* pointer;
753      string_value&lt;char_type&gt; string;
754      custom_value&lt;Context&gt; custom;
755      named_arg_value&lt;char_type&gt; named_args;
756    };
757    constexpr FMT_INLINE value(int val = 0) : int_value(val) {}
758    constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
759    FMT_INLINE value(long long val) : long_long_value(val) {}
760    FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
761    FMT_INLINE value(int128_t val) : int128_value(val) {}
762    FMT_INLINE value(uint128_t val) : uint128_value(val) {}
763    FMT_INLINE value(float val) : float_value(val) {}
764    FMT_INLINE value(double val) : double_value(val) {}
765    FMT_INLINE value(long double val) : long_double_value(val) {}
766    FMT_INLINE value(bool val) : bool_value(val) {}
767    FMT_INLINE value(char_type val) : char_value(val) {}
768    FMT_INLINE value(const char_type* val) { string.data = val; }
769    FMT_INLINE value(basic_string_view&lt;char_type&gt; val) {
770      string.data = val.data();
771      string.size = val.size();
772    }
773    FMT_INLINE value(const void* val) : pointer(val) {}
774    FMT_INLINE value(const named_arg_info&lt;char_type&gt;* args, size_t size)
775        : named_args{args, size} {}
776    template &lt;typename T&gt; FMT_INLINE value(const T&amp; val) {
777      custom.value = &amp;val;
778      custom.format = format_custom_arg&lt;
779          T, conditional_t&lt;has_formatter&lt;T, Context&gt;::value,
780                           typename Context::template formatter_type&lt;T&gt;,
781                           fallback_formatter&lt;T, char_type&gt;&gt;&gt;;
782    }
783   private:
784    template &lt;typename T, typename Formatter&gt;
785    static void format_custom_arg(const void* arg,
786                                  typename Context::parse_context_type&amp; parse_ctx,
787                                  Context&amp; ctx) {
788      Formatter f;
789      parse_ctx.advance_to(f.parse(parse_ctx));
790      ctx.advance_to(f.format(*static_cast&lt;const T*&gt;(arg), ctx));
791    }
792  };
793  template &lt;typename Context, typename T&gt;
794  FMT_CONSTEXPR basic_format_arg&lt;Context&gt; make_arg(const T&amp; value);
795  enum { long_short = sizeof(long) == sizeof(int) };
796  using long_type = conditional_t&lt;long_short, int, long long&gt;;
797  using ulong_type = conditional_t&lt;long_short, unsigned, unsigned long long&gt;;
798  struct unformattable {};
799  template &lt;typename Context&gt; struct arg_mapper {
800    using char_type = typename Context::char_type;
801    FMT_CONSTEXPR int map(signed char val) { return val; }
802    FMT_CONSTEXPR unsigned map(unsigned char val) { return val; }
803    FMT_CONSTEXPR int map(short val) { return val; }
804    FMT_CONSTEXPR unsigned map(unsigned short val) { return val; }
805    FMT_CONSTEXPR int map(int val) { return val; }
806    FMT_CONSTEXPR unsigned map(unsigned val) { return val; }
807    FMT_CONSTEXPR long_type map(long val) { return val; }
808    FMT_CONSTEXPR ulong_type map(unsigned long val) { return val; }
809    FMT_CONSTEXPR long long map(long long val) { return val; }
810    FMT_CONSTEXPR unsigned long long map(unsigned long long val) { return val; }
811    FMT_CONSTEXPR int128_t map(int128_t val) { return val; }
812    FMT_CONSTEXPR uint128_t map(uint128_t val) { return val; }
813    FMT_CONSTEXPR bool map(bool val) { return val; }
814    template &lt;typename T, FMT_ENABLE_IF(is_char&lt;T&gt;::value)&gt;
815    FMT_CONSTEXPR char_type map(T val) {
816      static_assert(
817          std::is_same&lt;T, char&gt;::value || std::is_same&lt;T, char_type&gt;::value,
818          &quot;mixing character types is disallowed&quot;);
819      return val;
820    }
821    FMT_CONSTEXPR float map(float val) { return val; }
822    FMT_CONSTEXPR double map(double val) { return val; }
823    FMT_CONSTEXPR long double map(long double val) { return val; }
824    FMT_CONSTEXPR const char_type* map(char_type* val) { return val; }
825    FMT_CONSTEXPR const char_type* map(const char_type* val) { return val; }
826    template &lt;typename T, FMT_ENABLE_IF(is_string&lt;T&gt;::value)&gt;
827    FMT_CONSTEXPR basic_string_view&lt;char_type&gt; map(const T&amp; val) {
828      static_assert(std::is_same&lt;char_type, char_t&lt;T&gt;&gt;::value,
829                    &quot;mixing character types is disallowed&quot;);
830      return to_string_view(val);
831    }
832    template &lt;typename T,
833              FMT_ENABLE_IF(
834                  std::is_constructible&lt;basic_string_view&lt;char_type&gt;, T&gt;::value &amp;&amp;
835                  !is_string&lt;T&gt;::value &amp;&amp; !has_formatter&lt;T, Context&gt;::value &amp;&amp;
836                  !has_fallback_formatter&lt;T, Context&gt;::value)&gt;
837    FMT_CONSTEXPR basic_string_view&lt;char_type&gt; map(const T&amp; val) {
838      return basic_string_view&lt;char_type&gt;(val);
839    }
840    template &lt;
841        typename T,
842        FMT_ENABLE_IF(
843            std::is_constructible&lt;std_string_view&lt;char_type&gt;, T&gt;::value &amp;&amp;
844            !std::is_constructible&lt;basic_string_view&lt;char_type&gt;, T&gt;::value &amp;&amp;
845            !is_string&lt;T&gt;::value &amp;&amp; !has_formatter&lt;T, Context&gt;::value &amp;&amp;
846            !has_fallback_formatter&lt;T, Context&gt;::value)&gt;
847    FMT_CONSTEXPR basic_string_view&lt;char_type&gt; map(const T&amp; val) {
848      return std_string_view&lt;char_type&gt;(val);
849    }
850    FMT_CONSTEXPR const char* map(const signed char* val) {
851      static_assert(std::is_same&lt;char_type, char&gt;::value, &quot;invalid string type&quot;);
852      return reinterpret_cast&lt;const char*&gt;(val);
853    }
854    FMT_CONSTEXPR const char* map(const unsigned char* val) {
855      static_assert(std::is_same&lt;char_type, char&gt;::value, &quot;invalid string type&quot;);
856      return reinterpret_cast&lt;const char*&gt;(val);
857    }
858    FMT_CONSTEXPR const char* map(signed char* val) {
859      const auto* const_val = val;
860      return map(const_val);
861    }
862    FMT_CONSTEXPR const char* map(unsigned char* val) {
863      const auto* const_val = val;
864      return map(const_val);
865    }
866    FMT_CONSTEXPR const void* map(void* val) { return val; }
867    FMT_CONSTEXPR const void* map(const void* val) { return val; }
868    FMT_CONSTEXPR const void* map(std::nullptr_t val) { return val; }
869    template &lt;typename T&gt; FMT_CONSTEXPR int map(const T*) {
870      static_assert(!sizeof(T), &quot;formatting of non-void pointers is disallowed&quot;);
871      return 0;
872    }
873    template &lt;typename T,
874              FMT_ENABLE_IF(std::is_enum&lt;T&gt;::value &amp;&amp;
875                            !has_formatter&lt;T, Context&gt;::value &amp;&amp;
876                            !has_fallback_formatter&lt;T, Context&gt;::value)&gt;
877    FMT_CONSTEXPR auto map(const T&amp; val)
878        -&gt; decltype(std::declval&lt;arg_mapper&gt;().map(
879            static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(val))) {
880      return map(static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(val));
881    }
882    template &lt;typename T,
883              FMT_ENABLE_IF(!is_string&lt;T&gt;::value &amp;&amp; !is_char&lt;T&gt;::value &amp;&amp;
884                            (has_formatter&lt;T, Context&gt;::value ||
885                             has_fallback_formatter&lt;T, Context&gt;::value))&gt;
886    FMT_CONSTEXPR const T&amp; map(const T&amp; val) {
887      return val;
888    }
889    template &lt;typename T&gt;
890    FMT_CONSTEXPR auto map(const named_arg&lt;char_type, T&gt;&amp; val)
891        -&gt; decltype(std::declval&lt;arg_mapper&gt;().map(val.value)) {
892      return map(val.value);
893    }
894    unformattable map(...) { return {}; }
895  };
896  template &lt;typename T, typename Context&gt;
897  using mapped_type_constant =
898      type_constant&lt;decltype(arg_mapper&lt;Context&gt;().map(std::declval&lt;const T&amp;&gt;())),
899                    typename Context::char_type&gt;;
900  enum { packed_arg_bits = 4 };
901  enum { max_packed_args = 62 / packed_arg_bits };
902  enum : unsigned long long { is_unpacked_bit = 1ULL &lt;&lt; 63 };
903  enum : unsigned long long { has_named_args_bit = 1ULL &lt;&lt; 62 };
904  }  
905  template &lt;typename Context&gt; class basic_format_arg {
906   private:
907    detail::value&lt;Context&gt; value_;
908    detail::type type_;
909    template &lt;typename ContextType, typename T&gt;
910    friend FMT_CONSTEXPR basic_format_arg&lt;ContextType&gt; detail::make_arg(
911        const T&amp; value);
912    template &lt;typename Visitor, typename Ctx&gt;
913    friend FMT_CONSTEXPR auto visit_format_arg(Visitor&amp;&amp; vis,
914                                               const basic_format_arg&lt;Ctx&gt;&amp; arg)
915        -&gt; decltype(vis(0));
916    friend class basic_format_args&lt;Context&gt;;
917    friend class dynamic_format_arg_store&lt;Context&gt;;
918    using char_type = typename Context::char_type;
919    template &lt;typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS&gt;
920    friend struct detail::arg_data;
921    basic_format_arg(const detail::named_arg_info&lt;char_type&gt;* args, size_t size)
922        : value_(args, size) {}
923   public:
924    class handle {
925     public:
926      explicit handle(detail::custom_value&lt;Context&gt; custom) : custom_(custom) {}
927      void format(typename Context::parse_context_type&amp; parse_ctx,
928                  Context&amp; ctx) const {
929        custom_.format(custom_.value, parse_ctx, ctx);
930      }
931     private:
932      detail::custom_value&lt;Context&gt; custom_;
933    };
934    constexpr basic_format_arg() : type_(detail::type::none_type) {}
935    constexpr explicit operator bool() const FMT_NOEXCEPT {
936      return type_ != detail::type::none_type;
937    }
938    detail::type type() const { return type_; }
939    bool is_integral() const { return detail::is_integral_type(type_); }
940    bool is_arithmetic() const { return detail::is_arithmetic_type(type_); }
941  };
942  template &lt;typename Visitor, typename Context&gt;
943  FMT_CONSTEXPR_DECL FMT_INLINE auto visit_format_arg(
944      Visitor&amp;&amp; vis, const basic_format_arg&lt;Context&gt;&amp; arg) -&gt; decltype(vis(0)) {
945    using char_type = typename Context::char_type;
946    switch (arg.type_) {
947    case detail::type::none_type:
948      break;
949    case detail::type::int_type:
950      return vis(arg.value_.int_value);
951    case detail::type::uint_type:
952      return vis(arg.value_.uint_value);
953    case detail::type::long_long_type:
954      return vis(arg.value_.long_long_value);
955    case detail::type::ulong_long_type:
956      return vis(arg.value_.ulong_long_value);
957  #if FMT_USE_INT128
958    case detail::type::int128_type:
959      return vis(arg.value_.int128_value);
960    case detail::type::uint128_type:
961      return vis(arg.value_.uint128_value);
962  #else
963    case detail::type::int128_type:
964    case detail::type::uint128_type:
965      break;
966  #endif
967    case detail::type::bool_type:
968      return vis(arg.value_.bool_value);
969    case detail::type::char_type:
970      return vis(arg.value_.char_value);
971    case detail::type::float_type:
972      return vis(arg.value_.float_value);
973    case detail::type::double_type:
974      return vis(arg.value_.double_value);
975    case detail::type::long_double_type:
976      return vis(arg.value_.long_double_value);
977    case detail::type::cstring_type:
978      return vis(arg.value_.string.data);
979    case detail::type::string_type:
980      return vis(basic_string_view&lt;char_type&gt;(arg.value_.string.data,
981                                              arg.value_.string.size));
982    case detail::type::pointer_type:
983      return vis(arg.value_.pointer);
984    case detail::type::custom_type:
985      return vis(typename basic_format_arg&lt;Context&gt;::handle(arg.value_.custom));
986    }
987    return vis(monostate());
988  }
989  template &lt;typename T&gt; struct formattable : std::false_type {};
990  namespace detail {
991  template &lt;typename... Ts&gt; struct void_t_impl { using type = void; };
992  template &lt;typename... Ts&gt;
993  using void_t = typename detail::void_t_impl&lt;Ts...&gt;::type;
994  template &lt;typename It, typename Enable = void&gt;
995  struct iterator_category : std::false_type {};
996  template &lt;typename T&gt; struct iterator_category&lt;T*&gt; {
997    using type = std::random_access_iterator_tag;
998  };
999  template &lt;typename It&gt;
1000  struct iterator_category&lt;It, void_t&lt;typename It::iterator_category&gt;&gt; {
1001    using type = typename It::iterator_category;
1002  };
1003  template &lt;typename It&gt; class is_output_iterator {
1004    template &lt;typename U&gt;
1005    static decltype(*(std::declval&lt;U&gt;())) test(std::input_iterator_tag);
1006    template &lt;typename U&gt; static char&amp; test(std::output_iterator_tag);
1007    template &lt;typename U&gt; static const char&amp; test(...);
1008    using type = decltype(test&lt;It&gt;(typename iterator_category&lt;It&gt;::type{}));
1009   public:
1010    enum { value = !std::is_const&lt;remove_reference_t&lt;type&gt;&gt;::value };
1011  };
1012  template &lt;typename OutputIt&gt;
1013  struct is_back_insert_iterator : std::false_type {};
1014  template &lt;typename Container&gt;
1015  struct is_back_insert_iterator&lt;std::back_insert_iterator&lt;Container&gt;&gt;
1016      : std::true_type {};
1017  template &lt;typename OutputIt&gt;
1018  struct is_contiguous_back_insert_iterator : std::false_type {};
1019  template &lt;typename Container&gt;
1020  struct is_contiguous_back_insert_iterator&lt;std::back_insert_iterator&lt;Container&gt;&gt;
1021      : is_contiguous&lt;Container&gt; {};
1022  template &lt;typename Char&gt;
1023  struct is_contiguous_back_insert_iterator&lt;buffer_appender&lt;Char&gt;&gt;
1024      : std::true_type {};
1025  class locale_ref {
1026   private:
1027    const void* locale_;  
1028   public:
1029    locale_ref() : locale_(nullptr) {}
1030    template &lt;typename Locale&gt; explicit locale_ref(const Locale&amp; loc);
1031    explicit operator bool() const FMT_NOEXCEPT { return locale_ != nullptr; }
1032    template &lt;typename Locale&gt; Locale get() const;
1033  };
1034  template &lt;typename&gt; constexpr unsigned long long encode_types() { return 0; }
1035  template &lt;typename Context, typename Arg, typename... Args&gt;
1036  constexpr unsigned long long encode_types() {
1037    return static_cast&lt;unsigned&gt;(mapped_type_constant&lt;Arg, Context&gt;::value) |
1038           (encode_types&lt;Context, Args...&gt;() &lt;&lt; packed_arg_bits);
1039  }
1040  template &lt;typename Context, typename T&gt;
1041  FMT_CONSTEXPR basic_format_arg&lt;Context&gt; make_arg(const T&amp; value) {
1042    basic_format_arg&lt;Context&gt; arg;
1043    arg.type_ = mapped_type_constant&lt;T, Context&gt;::value;
1044    arg.value_ = arg_mapper&lt;Context&gt;().map(value);
1045    return arg;
1046  }
1047  template &lt;typename T&gt; int check(unformattable) {
1048    static_assert(
1049        formattable&lt;T&gt;(),
1050        &quot;Cannot format an argument. To make type T formattable provide a &quot;
1051        &quot;formatter&lt;T&gt; specialization: https:&amp;bsol;&amp;bsol;fmt.dev/dev/api.html#udt&quot;);
1052    return 0;
1053  }
1054  template &lt;typename T, typename U&gt; inline const U&amp; check(const U&amp; val) {
1055    return val;
1056  }
1057  template &lt;bool IS_PACKED, typename Context, type, typename T,
1058            FMT_ENABLE_IF(IS_PACKED)&gt;
1059  inline value&lt;Context&gt; make_arg(const T&amp; val) {
1060    return check&lt;T&gt;(arg_mapper&lt;Context&gt;().map(val));
1061  }
1062  template &lt;bool IS_PACKED, typename Context, type, typename T,
1063            FMT_ENABLE_IF(!IS_PACKED)&gt;
1064  inline basic_format_arg&lt;Context&gt; make_arg(const T&amp; value) {
1065    return make_arg&lt;Context&gt;(value);
1066  }
1067  template &lt;typename T&gt; struct is_reference_wrapper : std::false_type {};
1068  template &lt;typename T&gt;
1069  struct is_reference_wrapper&lt;std::reference_wrapper&lt;T&gt;&gt; : std::true_type {};
1070  template &lt;typename T&gt; const T&amp; unwrap(const T&amp; v) { return v; }
1071  template &lt;typename T&gt; const T&amp; unwrap(const std::reference_wrapper&lt;T&gt;&amp; v) {
1072    return static_cast&lt;const T&amp;&gt;(v);
1073  }
1074  class dynamic_arg_list {
1075    template &lt;typename = void&gt; struct node {
1076      virtual ~node() = default;
1077      std::unique_ptr&lt;node&lt;&gt;&gt; next;
1078    };
1079    template &lt;typename T&gt; struct typed_node : node&lt;&gt; {
1080      T value;
1081      template &lt;typename Arg&gt;
1082      FMT_CONSTEXPR typed_node(const Arg&amp; arg) : value(arg) {}
1083      template &lt;typename Char&gt;
1084      FMT_CONSTEXPR typed_node(const basic_string_view&lt;Char&gt;&amp; arg)
1085          : value(arg.data(), arg.size()) {}
1086    };
1087    std::unique_ptr&lt;node&lt;&gt;&gt; head_;
1088   public:
1089    template &lt;typename T, typename Arg&gt; const T&amp; push(const Arg&amp; arg) {
1090      auto new_node = std::unique_ptr&lt;typed_node&lt;T&gt;&gt;(new typed_node&lt;T&gt;(arg));
1091      auto&amp; value = new_node-&gt;value;
1092      new_node-&gt;next = std::move(head_);
1093      head_ = std::move(new_node);
1094      return value;
1095    }
1096  };
1097  }  
1098  template &lt;typename OutputIt, typename Char&gt; class basic_format_context {
1099   public:
1100    using char_type = Char;
1101   private:
1102    OutputIt out_;
1103    basic_format_args&lt;basic_format_context&gt; args_;
1104    detail::locale_ref loc_;
1105   public:
1106    using iterator = OutputIt;
1107    using format_arg = basic_format_arg&lt;basic_format_context&gt;;
1108    using parse_context_type = basic_format_parse_context&lt;Char&gt;;
1109    template &lt;typename T&gt; using formatter_type = formatter&lt;T, char_type&gt;;
1110    basic_format_context(const basic_format_context&amp;) = delete;
1111    void operator=(const basic_format_context&amp;) = delete;
1112    basic_format_context(OutputIt out,
1113                         basic_format_args&lt;basic_format_context&gt; ctx_args,
1114                         detail::locale_ref loc = detail::locale_ref())
1115        : out_(out), args_(ctx_args), loc_(loc) {}
1116    format_arg arg(int id) const { return args_.get(id); }
1117    format_arg arg(basic_string_view&lt;char_type&gt; name) { return args_.get(name); }
1118    int arg_id(basic_string_view&lt;char_type&gt; name) { return args_.get_id(name); }
1119    const basic_format_args&lt;basic_format_context&gt;&amp; args() const { return args_; }
1120    detail::error_handler error_handler() { return {}; }
1121    void on_error(const char* message) { error_handler().on_error(message); }
1122    iterator out() { return out_; }
1123    void advance_to(iterator it) {
1124      if (!detail::is_back_insert_iterator&lt;iterator&gt;()) out_ = it;
1125    }
1126    detail::locale_ref locale() { return loc_; }
1127  };
1128  template &lt;typename Char&gt;
1129  using buffer_context =
1130      basic_format_context&lt;detail::buffer_appender&lt;Char&gt;, Char&gt;;
1131  using format_context = buffer_context&lt;char&gt;;
1132  using wformat_context = buffer_context&lt;wchar_t&gt;;
1133  #define FMT_BUFFER_CONTEXT(Char) \
1134    basic_format_context&lt;detail::buffer_appender&lt;Char&gt;, Char&gt;
1135  template &lt;typename Context, typename... Args&gt;
1136  class format_arg_store
1137  #if FMT_GCC_VERSION &amp;&amp; FMT_GCC_VERSION &lt; 409
1138      : public basic_format_args&lt;Context&gt;
1139  #endif
1140  {
1141   private:
1142    static const size_t num_args = sizeof...(Args);
1143    static const size_t num_named_args = detail::count_named_args&lt;Args...&gt;();
1144    static const bool is_packed = num_args &lt;= detail::max_packed_args;
1145    using value_type = conditional_t&lt;is_packed, detail::value&lt;Context&gt;,
1146                                     basic_format_arg&lt;Context&gt;&gt;;
1147    detail::arg_data&lt;value_type, typename Context::char_type, num_args,
1148                     num_named_args&gt;
1149        data_;
1150    friend class basic_format_args&lt;Context&gt;;
1151    static constexpr unsigned long long desc =
1152        (is_packed ? detail::encode_types&lt;Context, Args...&gt;()
1153                   : detail::is_unpacked_bit | num_args) |
1154        (num_named_args != 0
1155             ? static_cast&lt;unsigned long long&gt;(detail::has_named_args_bit)
1156             : 0);
1157   public:
1158    format_arg_store(const Args&amp;... args)
1159        :
1160  #if FMT_GCC_VERSION &amp;&amp; FMT_GCC_VERSION &lt; 409
1161          basic_format_args&lt;Context&gt;(*this),
1162  #endif
1163          data_{detail::make_arg&lt;
1164              is_packed, Context,
1165              detail::mapped_type_constant&lt;Args, Context&gt;::value&gt;(args)...} {
1166      detail::init_named_args(data_.named_args(), 0, 0, args...);
1167    }
1168  };
1169  template &lt;typename Context = format_context, typename... Args&gt;
1170  inline format_arg_store&lt;Context, Args...&gt; make_format_args(
1171      const Args&amp;... args) {
1172    return {args...};
1173  }
1174  template &lt;typename... Args, typename S, typename Char = char_t&lt;S&gt;&gt;
1175  inline auto make_args_checked(const S&amp; format_str,
1176                                const remove_reference_t&lt;Args&gt;&amp;... args)
1177      -&gt; format_arg_store&lt;buffer_context&lt;Char&gt;, remove_reference_t&lt;Args&gt;...&gt; {
1178    static_assert(
1179        detail::count&lt;(
1180                std::is_base_of&lt;detail::view, remove_reference_t&lt;Args&gt;&gt;::value &amp;&amp;
1181                std::is_reference&lt;Args&gt;::value)...&gt;() == 0,
1182        &quot;passing views as lvalues is disallowed&quot;);
1183    detail::check_format_string&lt;Args...&gt;(format_str);
1184    return {args...};
1185  }
1186  template &lt;typename Char, typename T&gt;
1187  inline detail::named_arg&lt;Char, T&gt; arg(const Char* name, const T&amp; arg) {
1188    static_assert(!detail::is_named_arg&lt;T&gt;(), &quot;nested named arguments&quot;);
1189    return {name, arg};
1190  }
1191  template &lt;typename Context&gt;
1192  class dynamic_format_arg_store
1193  #if FMT_GCC_VERSION &amp;&amp; FMT_GCC_VERSION &lt; 409
1194      : public basic_format_args&lt;Context&gt;
1195  #endif
1196  {
1197   private:
1198    using char_type = typename Context::char_type;
1199    template &lt;typename T&gt; struct need_copy {
1200      static constexpr detail::type mapped_type =
1201          detail::mapped_type_constant&lt;T, Context&gt;::value;
1202      enum {
1203        value = !(detail::is_reference_wrapper&lt;T&gt;::value ||
1204                  std::is_same&lt;T, basic_string_view&lt;char_type&gt;&gt;::value ||
1205                  std::is_same&lt;T, detail::std_string_view&lt;char_type&gt;&gt;::value ||
1206                  (mapped_type != detail::type::cstring_type &amp;&amp;
1207                   mapped_type != detail::type::string_type &amp;&amp;
1208                   mapped_type != detail::type::custom_type))
1209      };
1210    };
1211    template &lt;typename T&gt;
1212    using stored_type = conditional_t&lt;detail::is_string&lt;T&gt;::value,
1213                                      std::basic_string&lt;char_type&gt;, T&gt;;
1214    std::vector&lt;basic_format_arg&lt;Context&gt;&gt; data_;
1215    std::vector&lt;detail::named_arg_info&lt;char_type&gt;&gt; named_info_;
1216    detail::dynamic_arg_list dynamic_args_;
1217    friend class basic_format_args&lt;Context&gt;;
1218    unsigned long long get_types() const {
1219      return detail::is_unpacked_bit | data_.size() |
1220             (named_info_.empty()
1221                  ? 0ULL
1222                  : static_cast&lt;unsigned long long&gt;(detail::has_named_args_bit));
1223    }
1224    const basic_format_arg&lt;Context&gt;* data() const {
1225      return named_info_.empty() ? data_.data() : data_.data() + 1;
1226    }
1227    template &lt;typename T&gt; void emplace_arg(const T&amp; arg) {
1228      data_.emplace_back(detail::make_arg&lt;Context&gt;(arg));
1229    }
1230    template &lt;typename T&gt;
1231    void emplace_arg(const detail::named_arg&lt;char_type, T&gt;&amp; arg) {
1232      if (named_info_.empty()) {
1233        constexpr const detail::named_arg_info&lt;char_type&gt;* zero_ptr{nullptr};
1234        data_.insert(data_.begin(), {zero_ptr, 0});
1235      }
1236      data_.emplace_back(detail::make_arg&lt;Context&gt;(detail::unwrap(arg.value)));
1237      auto pop_one = [](std::vector&lt;basic_format_arg&lt;Context&gt;&gt;* data) {
1238        data-&gt;pop_back();
1239      };
1240      std::unique_ptr&lt;std::vector&lt;basic_format_arg&lt;Context&gt;&gt;, decltype(pop_one)&gt;
1241          guard{&amp;data_, pop_one};
1242      named_info_.push_back({arg.name, static_cast&lt;int&gt;(data_.size() - 2u)});
1243      data_[0].value_.named_args = {named_info_.data(), named_info_.size()};
1244      guard.release();
1245    }
1246   public:
1247    template &lt;typename T&gt; void push_back(const T&amp; arg) {
1248      if (detail::const_check(need_copy&lt;T&gt;::value))
1249        emplace_arg(dynamic_args_.push&lt;stored_type&lt;T&gt;&gt;(arg));
1250      else
1251        emplace_arg(detail::unwrap(arg));
1252    }
1253    template &lt;typename T&gt; void push_back(std::reference_wrapper&lt;T&gt; arg) {
1254      static_assert(
1255          detail::is_named_arg&lt;typename std::remove_cv&lt;T&gt;::type&gt;::value ||
1256              need_copy&lt;T&gt;::value,
1257          &quot;objects of built-in types and string views are always copied&quot;);
1258      emplace_arg(arg.get());
1259    }
1260    template &lt;typename T&gt;
1261    void push_back(const detail::named_arg&lt;char_type, T&gt;&amp; arg) {
1262      const char_type* arg_name =
1263          dynamic_args_.push&lt;std::basic_string&lt;char_type&gt;&gt;(arg.name).c_str();
1264      if (detail::const_check(need_copy&lt;T&gt;::value)) {
1265        emplace_arg(
1266            fmt::arg(arg_name, dynamic_args_.push&lt;stored_type&lt;T&gt;&gt;(arg.value)));
1267      } else {
1268        emplace_arg(fmt::arg(arg_name, arg.value));
1269      }
1270    }
1271    void clear() {
1272      data_.clear();
1273      named_info_.clear();
1274      dynamic_args_ = detail::dynamic_arg_list();
1275    }
1276    void reserve(size_t new_cap, size_t new_cap_named) {
1277      FMT_ASSERT(new_cap &gt;= new_cap_named,
1278                 &quot;Set of arguments includes set of named arguments&quot;);
1279      data_.reserve(new_cap);
1280      named_info_.reserve(new_cap_named);
1281    }
1282  };
1283  template &lt;typename Context&gt; class basic_format_args {
1284   public:
1285    using size_type = int;
1286    using format_arg = basic_format_arg&lt;Context&gt;;
1287   private:
1288    unsigned long long desc_;
1289    union {
1290      const detail::value&lt;Context&gt;* values_;
1291      const format_arg* args_;
1292    };
1293    bool is_packed() const { return (desc_ &amp; detail::is_unpacked_bit) == 0; }
1294    bool has_named_args() const {
1295      return (desc_ &amp; detail::has_named_args_bit) != 0;
1296    }
1297    detail::type type(int index) const {
1298      int shift = index * detail::packed_arg_bits;
1299      unsigned int mask = (1 &lt;&lt; detail::packed_arg_bits) - 1;
1300      return static_cast&lt;detail::type&gt;((desc_ &gt;&gt; shift) &amp; mask);
1301    }
1302    basic_format_args(unsigned long long desc,
1303                      const detail::value&lt;Context&gt;* values)
1304        : desc_(desc), values_(values) {}
1305    basic_format_args(unsigned long long desc, const format_arg* args)
1306        : desc_(desc), args_(args) {}
1307   public:
1308    basic_format_args() : desc_(0) {}
1309    template &lt;typename... Args&gt;
1310    FMT_INLINE basic_format_args(const format_arg_store&lt;Context, Args...&gt;&amp; store)
1311        : basic_format_args(store.desc, store.data_.args()) {}
1312    FMT_INLINE basic_format_args(const dynamic_format_arg_store&lt;Context&gt;&amp; store)
1313        : basic_format_args(store.get_types(), store.data()) {}
1314    basic_format_args(const format_arg* args, int count)
1315        : basic_format_args(detail::is_unpacked_bit | detail::to_unsigned(count),
1316                            args) {}
1317    format_arg get(int id) const {
1318      format_arg arg;
1319      if (!is_packed()) {
1320        if (id &lt; max_size()) arg = args_[id];
1321        return arg;
1322      }
1323      if (id &gt;= detail::max_packed_args) return arg;
1324      arg.type_ = type(id);
1325      if (arg.type_ == detail::type::none_type) return arg;
1326      arg.value_ = values_[id];
1327      return arg;
1328    }
1329    template &lt;typename Char&gt; format_arg get(basic_string_view&lt;Char&gt; name) const {
1330      int id = get_id(name);
1331      return id &gt;= 0 ? get(id) : format_arg();
1332    }
1333    template &lt;typename Char&gt; int get_id(basic_string_view&lt;Char&gt; name) const {
1334      if (!has_named_args()) return -1;
1335      const auto&amp; named_args =
1336          (is_packed() ? values_[-1] : args_[-1].value_).named_args;
1337      for (size_t i = 0; i &lt; named_args.size; ++i) {
1338        if (named_args.data[i].name == name) return named_args.data[i].id;
1339      }
1340      return -1;
1341    }
1342    int max_size() const {
1343      unsigned long long max_packed = detail::max_packed_args;
1344      return static_cast&lt;int&gt;(is_packed() ? max_packed
1345                                          : desc_ &amp; ~detail::is_unpacked_bit);
1346    }
1347  };
1348  struct format_args : basic_format_args&lt;format_context&gt; {
1349    template &lt;typename... Args&gt;
1350    FMT_INLINE format_args(const Args&amp;... args) : basic_format_args(args...) {}
1351  };
1352  struct wformat_args : basic_format_args&lt;wformat_context&gt; {
1353    using basic_format_args::basic_format_args;
1354  };
1355  namespace detail {
1356  template &lt;typename Char, FMT_ENABLE_IF(!std::is_same&lt;Char, char&gt;::value)&gt;
1357  std::basic_string&lt;Char&gt; vformat(
1358      basic_string_view&lt;Char&gt; format_str,
1359      basic_format_args&lt;buffer_context&lt;type_identity_t&lt;Char&gt;&gt;&gt; args);
1360  FMT_API std::string vformat(string_view format_str, format_args args);
1361  template &lt;typename Char&gt;
1362  buffer_appender&lt;Char&gt; vformat_to(
1363      buffer&lt;Char&gt;&amp; buf, basic_string_view&lt;Char&gt; format_str,
1364      basic_format_args&lt;FMT_BUFFER_CONTEXT(type_identity_t&lt;Char&gt;)&gt; args);
1365  template &lt;typename Char, typename Args,
1366            FMT_ENABLE_IF(!std::is_same&lt;Char, char&gt;::value)&gt;
1367  inline void vprint_mojibake(std::FILE*, basic_string_view&lt;Char&gt;, const Args&amp;) {}
1368  FMT_API void vprint_mojibake(std::FILE*, string_view, format_args);
1369  #ifndef _WIN32
1370  inline void vprint_mojibake(std::FILE*, string_view, format_args) {}
1371  #endif
1372  }  
1373  template &lt;typename OutputIt, typename S, typename Char = char_t&lt;S&gt;,
1374            FMT_ENABLE_IF(detail::is_output_iterator&lt;OutputIt&gt;::value)&gt;
1375  OutputIt vformat_to(
1376      OutputIt out, const S&amp; format_str,
1377      basic_format_args&lt;buffer_context&lt;type_identity_t&lt;Char&gt;&gt;&gt; args) {
1378    decltype(detail::get_buffer&lt;Char&gt;(out)) buf(detail::get_buffer_init(out));
1379    detail::vformat_to(buf, to_string_view(format_str), args);
1380    return detail::get_iterator(buf);
1381  }
1382  template &lt;typename OutputIt, typename S, typename... Args,
1383            FMT_ENABLE_IF(detail::is_output_iterator&lt;OutputIt&gt;::value&amp;&amp;
1384                              detail::is_string&lt;S&gt;::value)&gt;
1385  inline OutputIt format_to(OutputIt out, const S&amp; format_str, Args&amp;&amp;... args) {
1386    const auto&amp; vargs = fmt::make_args_checked&lt;Args...&gt;(format_str, args...);
1387    return vformat_to(out, to_string_view(format_str), vargs);
1388  }
1389  template &lt;typename OutputIt&gt; struct format_to_n_result {
1390    OutputIt out;
1391    size_t size;
1392  };
1393  template &lt;typename OutputIt, typename Char, typename... Args,
1394            FMT_ENABLE_IF(detail::is_output_iterator&lt;OutputIt&gt;::value)&gt;
1395  inline format_to_n_result&lt;OutputIt&gt; vformat_to_n(
1396      OutputIt out, size_t n, basic_string_view&lt;Char&gt; format_str,
1397      basic_format_args&lt;buffer_context&lt;type_identity_t&lt;Char&gt;&gt;&gt; args) {
1398    detail::iterator_buffer&lt;OutputIt, Char, detail::fixed_buffer_traits&gt; buf(out,
1399                                                                             n);
1400    detail::vformat_to(buf, format_str, args);
1401    return {buf.out(), buf.count()};
1402  }
1403  template &lt;typename OutputIt, typename S, typename... Args,
1404            FMT_ENABLE_IF(detail::is_string&lt;S&gt;::value&amp;&amp;
1405                              detail::is_output_iterator&lt;OutputIt&gt;::value)&gt;
1406  inline format_to_n_result&lt;OutputIt&gt; format_to_n(OutputIt out, size_t n,
1407                                                  const S&amp; format_str,
1408                                                  const Args&amp;... args) {
1409    const auto&amp; vargs = fmt::make_args_checked&lt;Args...&gt;(format_str, args...);
1410    return vformat_to_n(out, n, to_string_view(format_str), vargs);
1411  }
1412  template &lt;typename... Args&gt;
1413  inline size_t formatted_size(string_view format_str, Args&amp;&amp;... args) {
1414    const auto&amp; vargs = fmt::make_args_checked&lt;Args...&gt;(format_str, args...);
1415    detail::counting_buffer&lt;&gt; buf;
1416    detail::vformat_to(buf, format_str, vargs);
1417    return buf.count();
1418  }
1419  template &lt;typename S, typename Char = char_t&lt;S&gt;&gt;
1420  FMT_INLINE std::basic_string&lt;Char&gt; vformat(
1421      const S&amp; format_str,
1422      basic_format_args&lt;buffer_context&lt;type_identity_t&lt;Char&gt;&gt;&gt; args) {
1423    return detail::vformat(to_string_view(format_str), args);
1424  }
1425  template &lt;typename S, typename... Args, typename Char = char_t&lt;S&gt;&gt;
1426  FMT_INLINE std::basic_string&lt;Char&gt; format(const S&amp; format_str, Args&amp;&amp;... args) {
1427    const auto&amp; vargs = fmt::make_args_checked&lt;Args...&gt;(format_str, args...);
1428    return detail::vformat(to_string_view(format_str), vargs);
1429  }
1430  FMT_API void vprint(string_view, format_args);
1431  FMT_API void vprint(std::FILE*, string_view, format_args);
1432  template &lt;typename S, typename... Args, typename Char = char_t&lt;S&gt;&gt;
1433  inline void print(std::FILE* f, const S&amp; format_str, Args&amp;&amp;... args) {
1434    const auto&amp; vargs = fmt::make_args_checked&lt;Args...&gt;(format_str, args...);
1435    return detail::is_unicode&lt;Char&gt;()
1436               ? vprint(f, to_string_view(format_str), vargs)
1437               : detail::vprint_mojibake(f, to_string_view(format_str), vargs);
1438  }
1439  template &lt;typename S, typename... Args, typename Char = char_t&lt;S&gt;&gt;
1440  inline void print(const S&amp; format_str, Args&amp;&amp;... args) {
1441    const auto&amp; vargs = fmt::make_args_checked&lt;Args...&gt;(format_str, args...);
1442    return detail::is_unicode&lt;Char&gt;()
1443               ? vprint(to_string_view(format_str), vargs)
1444               : detail::vprint_mojibake(stdout, to_string_view(format_str),
1445                                         vargs);
1446  }
1447  FMT_END_NAMESPACE
1448  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-chrono.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from xmrig-MDEwOlJlcG9zaXRvcnk4ODMyNzQwNg==-flat-core.h</div>
                </div>
                <div class="column column_space"><pre><code>621  template &lt;typename FormatContext, typename OutputIt, typename Rep,
622            typename Period&gt;
623  struct chrono_formatter {
624    FormatContext&amp; context;
</pre></code></div>
                <div class="column column_space"><pre><code>634  template &lt;typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS&gt;
635  struct arg_data {
636    T args_[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)];
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    