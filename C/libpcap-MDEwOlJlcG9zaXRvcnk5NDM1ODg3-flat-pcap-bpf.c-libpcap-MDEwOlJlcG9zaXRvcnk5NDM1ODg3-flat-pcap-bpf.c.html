
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-bpf.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <sys/param.h>			&bsol;* optionally get BSD define */
5  #include <sys/socket.h>
6  #include <time.h>
7  #include <sys/ioctl.h>
8  #ifdef HAVE_SYS_IOCCOM_H
9  #include <sys/ioccom.h>
10  #endif
11  #include <sys/utsname.h>
12  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
13  static const char usbus_prefix[] = "usbus";
14  #define USBUS_PREFIX_LEN	(sizeof(usbus_prefix) - 1)
15  #include <dirent.h>
16  #endif
17  #include <net/if.h>
18  #ifdef _AIX
19  #define PCAP_DONT_INCLUDE_PCAP_BPF_H
20  #include <sys/types.h>
21  #undef _AIX
22  #include <net/bpf.h>
23  #define _AIX
24  #if defined(BIOCROTZBUF) && defined(BPF_BUFMODE_ZBUF)
25    #define HAVE_ZEROCOPY_BPF
26    #include <sys/mman.h>
27    #include <machine/atomic.h>
28  #endif
29  #include <net/if_types.h>		&bsol;* for IFT_ values */
30  #include <sys/sysconfig.h>
31  #include <sys/device.h>
32  #include <sys/cfgodm.h>
33  #include <cf.h>
34  #ifdef __64BIT__
35  #define domakedev makedev64
36  #define getmajor major64
37  #define bpf_hdr bpf_hdr32
38  #else &bsol;* __64BIT__ */
39  #define domakedev makedev
40  #define getmajor major
41  #endif &bsol;* __64BIT__ */
42  #define BPF_NAME "bpf"
43  #define BPF_MINORS 4
44  #define DRIVER_PATH "/usr/lib/drivers"
45  #define BPF_NODE "/dev/bpf"
46  static int bpfloadedflag = 0;
47  static int odmlockid = 0;
48  static int bpf_load(char *errbuf);
49  #else &bsol;* _AIX */
50  #include <net/bpf.h>
51  #endif &bsol;* _AIX */
52  #include <fcntl.h>
53  #include <errno.h>
54  #include <netdb.h>
55  #include <stdio.h>
56  #include <stdlib.h>
57  #include <string.h>
58  #include <unistd.h>
59  #ifdef SIOCGIFMEDIA
60  # include <net/if_media.h>
61  #endif
62  #include "pcap-int.h"
63  #ifdef HAVE_OS_PROTO_H
64  #include "os-proto.h"
65  #endif
66  #if defined(__NetBSD__) && __NetBSD_Version__ > 106000000
67  #define       PCAP_FDDIPAD 3
68  #endif
69  struct pcap_bpf {
70  #ifdef HAVE_ZEROCOPY_BPF
71  	u_char *zbuf1, *zbuf2, *zbuffer;
72  	u_int zbufsize;
73  	u_int zerocopy;
74  	u_int interrupted;
75  	struct timespec firstsel;
76  	struct bpf_zbuf_header *bzh;
77  	int nonblock;		&bsol;* true if in nonblocking mode */
78  #endif &bsol;* HAVE_ZEROCOPY_BPF */
79  	char *device;		&bsol;* device name */
80  	int filtering_in_kernel; &bsol;* using kernel filter */
81  	int must_do_on_close;	&bsol;* stuff we must do when we close */
82  };
83  #define MUST_CLEAR_RFMON	0x00000001	&bsol;* clear rfmon (monitor) mode */
84  #define MUST_DESTROY_USBUS	0x00000002	&bsol;* destroy usbusN interface */
85  #ifdef BIOCGDLTLIST
86  # if (defined(HAVE_NET_IF_MEDIA_H) && defined(IFM_IEEE80211)) && !defined(__APPLE__)
87  #define HAVE_BSD_IEEE80211
88  #  if defined(IFM_GMASK) && IFM_GMASK > 0xFFFFFFFF
89  #    define IFM_ULIST_TYPE	uint64_t
90  #  else
91  #    define IFM_ULIST_TYPE	int
92  #  endif
93  # endif
94  # if defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)
95  static int find_802_11(struct bpf_dltlist *);
96  #  ifdef HAVE_BSD_IEEE80211
97  static int monitor_mode(pcap_t *, int);
98  #  endif
99  #  if defined(__APPLE__)
100  static void remove_non_802_11(pcap_t *);
101  static void remove_802_11(pcap_t *);
102  #  endif
103  # endif &bsol;* defined(__APPLE__) || defined(HAVE_BSD_IEEE80211) */
104  #endif &bsol;* BIOCGDLTLIST */
105  #if defined(sun) && defined(LIFNAMSIZ) && defined(lifr_zoneid)
106  #include <zone.h>
107  #endif
108  #ifndef DLT_DOCSIS
109  #define DLT_DOCSIS	143
110  #endif
111  #ifndef DLT_PRISM_HEADER
112  #define DLT_PRISM_HEADER	119
113  #endif
114  #ifndef DLT_AIRONET_HEADER
115  #define DLT_AIRONET_HEADER	120
116  #endif
117  #ifndef DLT_IEEE802_11_RADIO
118  #define DLT_IEEE802_11_RADIO	127
119  #endif
120  #ifndef DLT_IEEE802_11_RADIO_AVS
121  #define DLT_IEEE802_11_RADIO_AVS 163
122  #endif
123  static int pcap_can_set_rfmon_bpf(pcap_t *p);
124  static int pcap_activate_bpf(pcap_t *p);
125  static int pcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp);
126  static int pcap_setdirection_bpf(pcap_t *, pcap_direction_t);
127  static int pcap_set_datalink_bpf(pcap_t *p, int dlt);
128  static int
129  pcap_getnonblock_bpf(pcap_t *p)
130  {
131  #ifdef HAVE_ZEROCOPY_BPF
132  	struct pcap_bpf *pb = p->priv;
133  	if (pb->zerocopy)
134  		return (pb->nonblock);
135  #endif
136  	return (pcap_getnonblock_fd(p));
137  }
138  static int
139  pcap_setnonblock_bpf(pcap_t *p, int nonblock)
140  {
141  #ifdef HAVE_ZEROCOPY_BPF
142  	struct pcap_bpf *pb = p->priv;
143  	if (pb->zerocopy) {
144  		pb->nonblock = nonblock;
145  		return (0);
146  	}
147  #endif
148  	return (pcap_setnonblock_fd(p, nonblock));
149  }
150  #ifdef HAVE_ZEROCOPY_BPF
151  static int
152  pcap_next_zbuf_shm(pcap_t *p, int *cc)
153  {
154  	struct pcap_bpf *pb = p->priv;
155  	struct bpf_zbuf_header *bzh;
156  	if (pb->zbuffer == pb->zbuf2 || pb->zbuffer == NULL) {
157  		bzh = (struct bpf_zbuf_header *)pb->zbuf1;
158  		if (bzh->bzh_user_gen !=
159  		    atomic_load_acq_int(&bzh->bzh_kernel_gen)) {
160  			pb->bzh = bzh;
161  			pb->zbuffer = (u_char *)pb->zbuf1;
162  			p->buffer = pb->zbuffer + sizeof(*bzh);
163  			*cc = bzh->bzh_kernel_len;
164  			return (1);
165  		}
166  	} else if (pb->zbuffer == pb->zbuf1) {
167  		bzh = (struct bpf_zbuf_header *)pb->zbuf2;
168  		if (bzh->bzh_user_gen !=
169  		    atomic_load_acq_int(&bzh->bzh_kernel_gen)) {
170  			pb->bzh = bzh;
171  			pb->zbuffer = (u_char *)pb->zbuf2;
172  			p->buffer = pb->zbuffer + sizeof(*bzh);
173  			*cc = bzh->bzh_kernel_len;
174  			return (1);
175  		}
176  	}
177  	*cc = 0;
178  	return (0);
179  }
180  static int
181  pcap_next_zbuf(pcap_t *p, int *cc)
182  {
183  	struct pcap_bpf *pb = p->priv;
184  	struct bpf_zbuf bz;
185  	struct timeval tv;
186  	struct timespec cur;
187  	fd_set r_set;
188  	int data, r;
189  	int expire, tmout;
190  #define TSTOMILLI(ts) (((ts)->tv_sec * 1000) + ((ts)->tv_nsec / 1000000))
191  	data = pcap_next_zbuf_shm(p, cc);
192  	if (data)
193  		return (data);
194  	tmout = p->opt.timeout;
195  	if (tmout)
196  		(void) clock_gettime(CLOCK_MONOTONIC, &cur);
197  	if (pb->interrupted && p->opt.timeout) {
198  		expire = TSTOMILLI(&pb->firstsel) + p->opt.timeout;
199  		tmout = expire - TSTOMILLI(&cur);
200  #undef TSTOMILLI
201  		if (tmout <= 0) {
202  			pb->interrupted = 0;
203  			data = pcap_next_zbuf_shm(p, cc);
204  			if (data)
205  				return (data);
206  			if (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {
207  				pcap_fmt_errmsg_for_errno(p->errbuf,
208  				    PCAP_ERRBUF_SIZE, errno, "BIOCROTZBUF");
209  				return (PCAP_ERROR);
210  			}
211  			return (pcap_next_zbuf_shm(p, cc));
212  		}
213  	}
214  	if (!pb->nonblock) {
215  		FD_ZERO(&r_set);
216  		FD_SET(p->fd, &r_set);
217  		if (tmout != 0) {
218  			tv.tv_sec = tmout / 1000;
219  			tv.tv_usec = (tmout * 1000) % 1000000;
220  		}
221  		r = select(p->fd + 1, &r_set, NULL, NULL,
222  		    p->opt.timeout != 0 ? &tv : NULL);
223  		if (r < 0 && errno == EINTR) {
224  			if (!pb->interrupted && p->opt.timeout) {
225  				pb->interrupted = 1;
226  				pb->firstsel = cur;
227  			}
228  			return (0);
229  		} else if (r < 0) {
230  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
231  			    errno, "select");
232  			return (PCAP_ERROR);
233  		}
234  	}
235  	pb->interrupted = 0;
236  	data = pcap_next_zbuf_shm(p, cc);
237  	if (data)
238  		return (data);
239  	if (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {
240  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
241  		    errno, "BIOCROTZBUF");
242  		return (PCAP_ERROR);
243  	}
244  	return (pcap_next_zbuf_shm(p, cc));
245  }
246  static int
247  pcap_ack_zbuf(pcap_t *p)
248  {
249  	struct pcap_bpf *pb = p->priv;
250  	atomic_store_rel_int(&pb->bzh->bzh_user_gen,
251  	    pb->bzh->bzh_kernel_gen);
252  	pb->bzh = NULL;
253  	p->buffer = NULL;
254  	return (0);
255  }
256  #endif &bsol;* HAVE_ZEROCOPY_BPF */
257  pcap_t *
258  pcap_create_interface(const char *device _U_, char *ebuf)
259  {
260  	pcap_t *p;
261  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_bpf);
262  	if (p == NULL)
263  		return (NULL);
264  	p->activate_op = pcap_activate_bpf;
265  	p->can_set_rfmon_op = pcap_can_set_rfmon_bpf;
266  #ifdef BIOCSTSTAMP
267  	p->tstamp_precision_list = malloc(2 * sizeof(u_int));
268  	if (p->tstamp_precision_list == NULL) {
269  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,
270  		    "malloc");
271  		free(p);
272  		return (NULL);
273  	}
274  	p->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;
275  	p->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;
276  	p->tstamp_precision_count = 2;
277  #endif &bsol;* BIOCSTSTAMP */
278  	return (p);
279  }
280  static int
281  bpf_open(char *errbuf)
282  {
283  	int fd = -1;
284  	static const char cloning_device[] = "/dev/bpf";
285  	u_int n = 0;
286  	char device[sizeof "/dev/bpf0000000000"];
287  	static int no_cloning_bpf = 0;
288  #ifdef _AIX
289  	if (bpf_load(errbuf) == PCAP_ERROR)
290  		return (PCAP_ERROR);
291  #endif
292  	if (!no_cloning_bpf &&
293  	    (fd = open(cloning_device, O_RDWR)) == -1 &&
294  	    ((errno != EACCES && errno != ENOENT) ||
295  	     (fd = open(cloning_device, O_RDONLY)) == -1)) {
296  		if (errno != ENOENT) {
297  			if (errno == EACCES) {
298  				fd = PCAP_ERROR_PERM_DENIED;
299  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
300  				    "Attempt to open %s failed - root privileges may be required",
301  				    cloning_device);
302  			} else {
303  				fd = PCAP_ERROR;
304  				pcap_fmt_errmsg_for_errno(errbuf,
305  				    PCAP_ERRBUF_SIZE, errno,
306  				    "(cannot open device) %s", cloning_device);
307  			}
308  			return (fd);
309  		}
310  		no_cloning_bpf = 1;
311  	}
312  	if (no_cloning_bpf) {
313  		do {
314  			(void)snprintf(device, sizeof(device), "/dev/bpf%u", n++);
315  			fd = open(device, O_RDWR);
316  			if (fd == -1 && errno == EACCES)
317  				fd = open(device, O_RDONLY);
318  		} while (fd < 0 && errno == EBUSY);
319  	}
320  	if (fd < 0) {
321  		switch (errno) {
322  		case ENOENT:
323  			fd = PCAP_ERROR;
324  			if (n == 1) {
325  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
326  				    "(there are no BPF devices)");
327  			} else {
328  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
329  				    "(all BPF devices are busy)");
330  			}
331  			break;
332  		case EACCES:
333  			fd = PCAP_ERROR_PERM_DENIED;
334  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
335  			    "Attempt to open %s failed - root privileges may be required",
336  			    device);
337  			break;
338  		default:
339  			fd = PCAP_ERROR;
340  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
341  			    errno, "(cannot open BPF device) %s", device);
342  			break;
343  		}
344  	}
345  	return (fd);
346  }
347  #define BPF_BIND_SUCCEEDED	0
348  #define BPF_BIND_BUFFER_TOO_BIG	1
349  static int
350  bpf_bind(int fd, const char *name, char *errbuf)
351  {
352  	int status;
353  #ifdef LIFNAMSIZ
354  	struct lifreq ifr;
355  	if (strlen(name) >= sizeof(ifr.lifr_name)) {
356  		return (PCAP_ERROR_NO_SUCH_DEVICE);
357  	}
358  	(void)pcap_strlcpy(ifr.lifr_name, name, sizeof(ifr.lifr_name));
359  	status = ioctl(fd, BIOCSETLIF, (caddr_t)&ifr);
360  #else
361  	struct ifreq ifr;
362  	if (strlen(name) >= sizeof(ifr.ifr_name)) {
363  		return (PCAP_ERROR_NO_SUCH_DEVICE);
364  	}
365  	(void)pcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
366  	status = ioctl(fd, BIOCSETIF, (caddr_t)&ifr);
367  #endif
368  	if (status < 0) {
369  		switch (errno) {
370  #if defined(HAVE_SOLARIS)
371  		case ESRCH:
372  #else
373  		case ENXIO:
374  #endif
375  			errbuf[0] = '\0';
376  			return (PCAP_ERROR_NO_SUCH_DEVICE);
377  		case ENETDOWN:
378  			return (PCAP_ERROR_IFACE_NOT_UP);
379  		case ENOBUFS:
380  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
381  			    errno, "The requested buffer size for %s is too large",
382  			    name);
383  			return (BPF_BIND_BUFFER_TOO_BIG);
384  		default:
385  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
386  			    errno, "Binding interface %s to BPF device failed",
387  			    name);
388  			return (PCAP_ERROR);
389  		}
390  	}
391  	return (BPF_BIND_SUCCEEDED);
392  }
393  static int
394  bpf_open_and_bind(const char *name, char *errbuf)
395  {
396  	int fd;
397  	int status;
398  	fd = bpf_open(errbuf);
399  	if (fd < 0)
400  		return (fd);	&bsol;* fd is the appropriate error code */
401  	status = bpf_bind(fd, name, errbuf);
402  	if (status != BPF_BIND_SUCCEEDED) {
403  		close(fd);
404  		if (status == BPF_BIND_BUFFER_TOO_BIG) {
405  			return (PCAP_ERROR);
406  		}
407  		return (status);
408  	}
409  	return (fd);
410  }
411  #ifdef __APPLE__
412  static int
413  device_exists(int fd, const char *name, char *errbuf)
414  {
415  	int status;
416  	struct ifreq ifr;
417  	if (strlen(name) >= sizeof(ifr.ifr_name)) {
418  		return (PCAP_ERROR_NO_SUCH_DEVICE);
419  	}
420  	(void)pcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
421  	status = ioctl(fd, SIOCGIFFLAGS, (caddr_t)&ifr);
422  	if (status < 0) {
423  		if (errno == ENXIO || errno == EINVAL) {
424  			return (PCAP_ERROR_NO_SUCH_DEVICE);
425  		}
426  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
427  		    "Can't get interface flags on %s", name);
428  		return (PCAP_ERROR);
429  	}
430  	return (0);
431  }
432  #endif
433  #ifdef BIOCGDLTLIST
434  static int
435  get_dlt_list(int fd, int v, struct bpf_dltlist *bdlp, char *ebuf)
436  {
437  	memset(bdlp, 0, sizeof(*bdlp));
438  	if (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) == 0) {
439  		u_int i;
440  		int is_ethernet;
441  		bdlp->bfl_list = (u_int *) malloc(sizeof(u_int) * (bdlp->bfl_len + 1));
442  		if (bdlp->bfl_list == NULL) {
443  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
444  			    errno, "malloc");
445  			return (PCAP_ERROR);
446  		}
447  		if (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) < 0) {
448  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
449  			    errno, "BIOCGDLTLIST");
450  			free(bdlp->bfl_list);
451  			return (PCAP_ERROR);
452  		}
453  		if (v == DLT_EN10MB) {
454  			is_ethernet = 1;
455  			for (i = 0; i < bdlp->bfl_len; i++) {
456  				if (bdlp->bfl_list[i] != DLT_EN10MB
457  #ifdef DLT_IPNET
458  				    && bdlp->bfl_list[i] != DLT_IPNET
459  #endif
460  				    ) {
461  					is_ethernet = 0;
462  					break;
463  				}
464  			}
465  			if (is_ethernet) {
466  				bdlp->bfl_list[bdlp->bfl_len] = DLT_DOCSIS;
467  				bdlp->bfl_len++;
468  			}
469  		}
470  	} else {
471  		if (errno != EINVAL) {
472  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
473  			    errno, "BIOCGDLTLIST");
474  			return (PCAP_ERROR);
475  		}
476  	}
477  	return (0);
478  }
479  #endif
480  #if defined(__APPLE__)
481  static int
482  pcap_can_set_rfmon_bpf(pcap_t *p)
483  {
484  	struct utsname osinfo;
485  	int fd;
486  #ifdef BIOCGDLTLIST
487  	struct bpf_dltlist bdl;
488  	int err;
489  #endif
490  	if (uname(&osinfo) == -1) {
491  		return (0);
492  	}
493  	if (osinfo.release[0] < '8' && osinfo.release[1] == '.') {
494  		return (0);
495  	}
496  	if (osinfo.release[0] == '8' && osinfo.release[1] == '.') {
497  		char *wlt_name;
498  		int status;
499  		if (strncmp(p->opt.device, "en", 2) != 0) {
500  			return (0);
501  		}
502  		fd = socket(AF_INET, SOCK_DGRAM, 0);
503  		if (fd == -1) {
504  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
505  			    errno, "socket");
506  			return (PCAP_ERROR);
507  		}
508  		if (pcap_asprintf(&wlt_name, "wlt%s", p->opt.device + 2) == -1) {
509  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
510  			    errno, "malloc");
511  			close(fd);
512  			return (PCAP_ERROR);
513  		}
514  		status = device_exists(fd, wlt_name, p->errbuf);
515  		free(wlt_name);
516  		close(fd);
517  		if (status != 0) {
518  			if (status == PCAP_ERROR_NO_SUCH_DEVICE)
519  				return (0);
520  			return (status);
521  		}
522  		return (1);
523  	}
524  #ifdef BIOCGDLTLIST
525  	fd = bpf_open(p->errbuf);
526  	if (fd < 0)
527  		return (fd);	&bsol;* fd is the appropriate error code */
<span onclick='openModal()' class='match'>528  	err = bpf_bind(fd, p->opt.device, p->errbuf);
529  	if (err != BPF_BIND_SUCCEEDED) {
</span>530  		close(fd);
531  		if (err == BPF_BIND_BUFFER_TOO_BIG) {
532  			return (PCAP_ERROR);
533  		}
534  		return (err);
535  	}
536  	if (get_dlt_list(fd, DLT_NULL, &bdl, p->errbuf) == PCAP_ERROR) {
537  		close(fd);
538  		return (PCAP_ERROR);
539  	}
540  	if (find_802_11(&bdl) != -1) {
541  		free(bdl.bfl_list);
542  		close(fd);
543  		return (1);
544  	}
545  	free(bdl.bfl_list);
546  	close(fd);
547  #endif &bsol;* BIOCGDLTLIST */
548  	return (0);
549  }
550  #elif defined(HAVE_BSD_IEEE80211)
551  static int
552  pcap_can_set_rfmon_bpf(pcap_t *p)
553  {
554  	int ret;
555  	ret = monitor_mode(p, 0);
556  	if (ret == PCAP_ERROR_RFMON_NOTSUP)
557  		return (0);	&bsol;* not an error, just a "can't do" */
558  	if (ret == 0)
559  		return (1);	&bsol;* success */
560  	return (ret);
561  }
562  #else
563  static int
564  pcap_can_set_rfmon_bpf(pcap_t *p _U_)
565  {
566  	return (0);
567  }
568  #endif
569  static int
570  pcap_stats_bpf(pcap_t *p, struct pcap_stat *ps)
571  {
572  	struct bpf_stat s;
573  	if (ioctl(p->fd, BIOCGSTATS, (caddr_t)&s) < 0) {
574  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
575  		    errno, "BIOCGSTATS");
576  		return (PCAP_ERROR);
577  	}
578  	ps->ps_recv = s.bs_recv;
579  	ps->ps_drop = s.bs_drop;
580  	ps->ps_ifdrop = 0;
581  	return (0);
582  }
583  static int
584  pcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
585  {
586  	struct pcap_bpf *pb = p->priv;
587  	ssize_t cc;
588  	int n = 0;
589  	register u_char *bp, *ep;
590  	u_char *datap;
591  #ifdef PCAP_FDDIPAD
592  	register u_int pad;
593  #endif
594  #ifdef HAVE_ZEROCOPY_BPF
595  	int i;
596  #endif
597   again:
598  	if (p->break_loop) {
599  		p->break_loop = 0;
600  		return (PCAP_ERROR_BREAK);
601  	}
602  	cc = p->cc;
603  	if (p->cc == 0) {
604  #ifdef HAVE_ZEROCOPY_BPF
605  		if (pb->zerocopy) {
606  			if (p->buffer != NULL)
607  				pcap_ack_zbuf(p);
608  			i = pcap_next_zbuf(p, &cc);
609  			if (i == 0)
610  				goto again;
611  			if (i < 0)
612  				return (PCAP_ERROR);
613  		} else
614  #endif
615  		{
616  			cc = read(p->fd, p->buffer, p->bufsize);
617  		}
618  		if (cc < 0) {
619  			switch (errno) {
620  			case EINTR:
621  				goto again;
622  #ifdef _AIX
623  			case EFAULT:
624  				goto again;
625  #endif
626  			case EWOULDBLOCK:
627  				return (0);
628  			case ENXIO:	&bsol;* FreeBSD, DragonFly BSD, and Darwin */
629  			case EIO:	&bsol;* OpenBSD */
630  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
631  				    "The interface disappeared");
632  				return (PCAP_ERROR);
633  #if defined(sun) && !defined(BSD) && !defined(__svr4__) && !defined(__SVR4)
634  			case EINVAL:
635  				if (lseek(p->fd, 0L, SEEK_CUR) +
636  				    p->bufsize < 0) {
637  					(void)lseek(p->fd, 0L, SEEK_SET);
638  					goto again;
639  				}
640  #endif
641  			}
642  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
643  			    errno, "read");
644  			return (PCAP_ERROR);
645  		}
646  		bp = p->buffer;
647  	} else
648  		bp = p->bp;
649  #ifdef BIOCSTSTAMP
650  #define bhp ((struct bpf_xhdr *)bp)
651  #else
652  #define bhp ((struct bpf_hdr *)bp)
653  #endif
654  	ep = bp + cc;
655  #ifdef PCAP_FDDIPAD
656  	pad = p->fddipad;
657  #endif
658  	while (bp < ep) {
659  		register u_int caplen, hdrlen;
660  		if (p->break_loop) {
661  			p->bp = bp;
662  			p->cc = (int)(ep - bp);
663  			if (p->cc < 0)
664  				p->cc = 0;
665  			if (n == 0) {
666  				p->break_loop = 0;
667  				return (PCAP_ERROR_BREAK);
668  			} else
669  				return (n);
670  		}
671  		caplen = bhp->bh_caplen;
672  		hdrlen = bhp->bh_hdrlen;
673  		datap = bp + hdrlen;
674  		if (pb->filtering_in_kernel ||
675  		    pcap_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {
676  			struct pcap_pkthdr pkthdr;
677  #ifdef BIOCSTSTAMP
678  			struct bintime bt;
679  			bt.sec = bhp->bh_tstamp.bt_sec;
680  			bt.frac = bhp->bh_tstamp.bt_frac;
681  			if (p->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {
682  				struct timespec ts;
683  				bintime2timespec(&bt, &ts);
684  				pkthdr.ts.tv_sec = ts.tv_sec;
685  				pkthdr.ts.tv_usec = ts.tv_nsec;
686  			} else {
687  				struct timeval tv;
688  				bintime2timeval(&bt, &tv);
689  				pkthdr.ts.tv_sec = tv.tv_sec;
690  				pkthdr.ts.tv_usec = tv.tv_usec;
691  			}
692  #else
693  			pkthdr.ts.tv_sec = bhp->bh_tstamp.tv_sec;
694  #ifdef _AIX
695  			pkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec/1000;
696  #else
697  			pkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec;
698  #endif
699  #endif &bsol;* BIOCSTSTAMP */
700  #ifdef PCAP_FDDIPAD
701  			if (caplen > pad)
702  				pkthdr.caplen = caplen - pad;
703  			else
704  				pkthdr.caplen = 0;
705  			if (bhp->bh_datalen > pad)
706  				pkthdr.len = bhp->bh_datalen - pad;
707  			else
708  				pkthdr.len = 0;
709  			datap += pad;
710  #else
711  			pkthdr.caplen = caplen;
712  			pkthdr.len = bhp->bh_datalen;
713  #endif
714  			(*callback)(user, &pkthdr, datap);
715  			bp += BPF_WORDALIGN(caplen + hdrlen);
716  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
717  				p->bp = bp;
718  				p->cc = (int)(ep - bp);
719  				if (p->cc < 0)
720  					p->cc = 0;
721  				return (n);
722  			}
723  		} else {
724  			bp += BPF_WORDALIGN(caplen + hdrlen);
725  		}
726  	}
727  #undef bhp
728  	p->cc = 0;
729  	return (n);
730  }
731  static int
732  pcap_inject_bpf(pcap_t *p, const void *buf, int size)
733  {
734  	int ret;
735  	ret = (int)write(p->fd, buf, size);
736  #ifdef __APPLE__
737  	if (ret == -1 && errno == EAFNOSUPPORT) {
738  		u_int spoof_eth_src = 0;
739  		if (ioctl(p->fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {
740  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
741  			    errno, "send: can't turn off BIOCSHDRCMPLT");
742  			return (PCAP_ERROR);
743  		}
744  		ret = (int)write(p->fd, buf, size);
745  	}
746  #endif &bsol;* __APPLE__ */
747  	if (ret == -1) {
748  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
749  		    errno, "send");
750  		return (PCAP_ERROR);
751  	}
752  	return (ret);
753  }
754  #ifdef _AIX
755  static int
756  bpf_odminit(char *errbuf)
757  {
758  	char *errstr;
759  	if (odm_initialize() == -1) {
760  		if (odm_err_msg(odmerrno, &errstr) == -1)
761  			errstr = "Unknown error";
762  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
763  		    "bpf_load: odm_initialize failed: %s",
764  		    errstr);
765  		return (PCAP_ERROR);
766  	}
767  	if ((odmlockid = odm_lock("/etc/objrepos/config_lock", ODM_WAIT)) == -1) {
768  		if (odm_err_msg(odmerrno, &errstr) == -1)
769  			errstr = "Unknown error";
770  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
771  		    "bpf_load: odm_lock of /etc/objrepos/config_lock failed: %s",
772  		    errstr);
773  		(void)odm_terminate();
774  		return (PCAP_ERROR);
775  	}
776  	return (0);
777  }
778  static int
779  bpf_odmcleanup(char *errbuf)
780  {
781  	char *errstr;
782  	if (odm_unlock(odmlockid) == -1) {
783  		if (errbuf != NULL) {
784  			if (odm_err_msg(odmerrno, &errstr) == -1)
785  				errstr = "Unknown error";
786  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
787  			    "bpf_load: odm_unlock failed: %s",
788  			    errstr);
789  		}
790  		return (PCAP_ERROR);
791  	}
792  	if (odm_terminate() == -1) {
793  		if (errbuf != NULL) {
794  			if (odm_err_msg(odmerrno, &errstr) == -1)
795  				errstr = "Unknown error";
796  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
797  			    "bpf_load: odm_terminate failed: %s",
798  			    errstr);
799  		}
800  		return (PCAP_ERROR);
801  	}
802  	return (0);
803  }
804  static int
805  bpf_load(char *errbuf)
806  {
807  	long major;
808  	int *minors;
809  	int numminors, i, rc;
810  	char buf[1024];
811  	struct stat sbuf;
812  	struct bpf_config cfg_bpf;
813  	struct cfg_load cfg_ld;
814  	struct cfg_kmod cfg_km;
815  	if (bpfloadedflag)
816  		return (0);
817  	if (bpf_odminit(errbuf) == PCAP_ERROR)
818  		return (PCAP_ERROR);
819  	major = genmajor(BPF_NAME);
820  	if (major == -1) {
821  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
822  		    errno, "bpf_load: genmajor failed");
823  		(void)bpf_odmcleanup(NULL);
824  		return (PCAP_ERROR);
825  	}
826  	minors = getminor(major, &numminors, BPF_NAME);
827  	if (!minors) {
828  		minors = genminor("bpf", major, 0, BPF_MINORS, 1, 1);
829  		if (!minors) {
830  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
831  			    errno, "bpf_load: genminor failed");
832  			(void)bpf_odmcleanup(NULL);
833  			return (PCAP_ERROR);
834  		}
835  	}
836  	if (bpf_odmcleanup(errbuf) == PCAP_ERROR)
837  		return (PCAP_ERROR);
838  	rc = stat(BPF_NODE "0", &sbuf);
839  	if (rc == -1 && errno != ENOENT) {
840  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
841  		    errno, "bpf_load: can't stat %s", BPF_NODE "0");
842  		return (PCAP_ERROR);
843  	}
844  	if (rc == -1 || getmajor(sbuf.st_rdev) != major) {
845  		for (i = 0; i < BPF_MINORS; i++) {
846  			snprintf(buf, sizeof(buf), "%s%d", BPF_NODE, i);
847  			unlink(buf);
848  			if (mknod(buf, S_IRUSR | S_IFCHR, domakedev(major, i)) == -1) {
849  				pcap_fmt_errmsg_for_errno(errbuf,
850  				    PCAP_ERRBUF_SIZE, errno,
851  				    "bpf_load: can't mknod %s", buf);
852  				return (PCAP_ERROR);
853  			}
854  		}
855  	}
856  	memset(&cfg_ld, 0x0, sizeof(cfg_ld));
857  	snprintf(buf, sizeof(buf), "%s/%s", DRIVER_PATH, BPF_NAME);
858  	cfg_ld.path = buf;
859  	if ((sysconfig(SYS_QUERYLOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) ||
860  	    (cfg_ld.kmid == 0)) {
861  		if (sysconfig(SYS_SINGLELOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) {
862  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
863  			    errno, "bpf_load: could not load driver");
864  			return (PCAP_ERROR);
865  		}
866  	}
867  	cfg_km.cmd = CFG_INIT;
868  	cfg_km.kmid = cfg_ld.kmid;
869  	cfg_km.mdilen = sizeof(cfg_bpf);
870  	cfg_km.mdiptr = (void *)&cfg_bpf;
871  	for (i = 0; i < BPF_MINORS; i++) {
872  		cfg_bpf.devno = domakedev(major, i);
873  		if (sysconfig(SYS_CFGKMOD, (void *)&cfg_km, sizeof(cfg_km)) == -1) {
874  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
875  			    errno, "bpf_load: could not configure driver");
876  			return (PCAP_ERROR);
877  		}
878  	}
879  	bpfloadedflag = 1;
880  	return (0);
881  }
882  #endif
883  static void
884  pcap_cleanup_bpf(pcap_t *p)
885  {
886  	struct pcap_bpf *pb = p->priv;
887  #ifdef HAVE_BSD_IEEE80211
888  	int sock;
889  	struct ifmediareq req;
890  	struct ifreq ifr;
891  #endif
892  	if (pb->must_do_on_close != 0) {
893  #ifdef HAVE_BSD_IEEE80211
894  		if (pb->must_do_on_close & MUST_CLEAR_RFMON) {
895  			sock = socket(AF_INET, SOCK_DGRAM, 0);
896  			if (sock == -1) {
897  				fprintf(stderr,
898  				    "Can't restore interface flags (socket() failed: %s).\n"
899  				    "Please adjust manually.\n",
900  				    strerror(errno));
901  			} else {
902  				memset(&req, 0, sizeof(req));
903  				pcap_strlcpy(req.ifm_name, pb->device,
904  				    sizeof(req.ifm_name));
905  				if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
906  					fprintf(stderr,
907  					    "Can't restore interface flags (SIOCGIFMEDIA failed: %s).\n"
908  					    "Please adjust manually.\n",
909  					    strerror(errno));
910  				} else {
911  					if (req.ifm_current & IFM_IEEE80211_MONITOR) {
912  						memset(&ifr, 0, sizeof(ifr));
913  						(void)pcap_strlcpy(ifr.ifr_name,
914  						    pb->device,
915  						    sizeof(ifr.ifr_name));
916  						ifr.ifr_media =
917  						    req.ifm_current & ~IFM_IEEE80211_MONITOR;
918  						if (ioctl(sock, SIOCSIFMEDIA,
919  						    &ifr) == -1) {
920  							fprintf(stderr,
921  							    "Can't restore interface flags (SIOCSIFMEDIA failed: %s).\n"
922  							    "Please adjust manually.\n",
923  							    strerror(errno));
924  						}
925  					}
926  				}
927  				close(sock);
928  			}
929  		}
930  #endif &bsol;* HAVE_BSD_IEEE80211 */
931  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
932  		if (pb->must_do_on_close & MUST_DESTROY_USBUS) {
933  			if (if_nametoindex(pb->device) > 0) {
934  				int s;
935  				s = socket(AF_LOCAL, SOCK_DGRAM, 0);
936  				if (s >= 0) {
937  					pcap_strlcpy(ifr.ifr_name, pb->device,
938  					    sizeof(ifr.ifr_name));
939  					ioctl(s, SIOCIFDESTROY, &ifr);
940  					close(s);
941  				}
942  			}
943  		}
944  #endif &bsol;* defined(__FreeBSD__) && defined(SIOCIFCREATE2) */
945  		pcap_remove_from_pcaps_to_close(p);
946  		pb->must_do_on_close = 0;
947  	}
948  #ifdef HAVE_ZEROCOPY_BPF
949  	if (pb->zerocopy) {
950  		if (pb->zbuf1 != MAP_FAILED && pb->zbuf1 != NULL)
951  			(void) munmap(pb->zbuf1, pb->zbufsize);
952  		if (pb->zbuf2 != MAP_FAILED && pb->zbuf2 != NULL)
953  			(void) munmap(pb->zbuf2, pb->zbufsize);
954  		p->buffer = NULL;
955  	}
956  #endif
957  	if (pb->device != NULL) {
958  		free(pb->device);
959  		pb->device = NULL;
960  	}
961  	pcap_cleanup_live_common(p);
962  }
963  #ifdef __APPLE__
964  static int
965  check_setif_failure(pcap_t *p, int error)
966  {
967  	int fd;
968  	int err;
969  	if (error == PCAP_ERROR_NO_SUCH_DEVICE) {
970  		if (p->opt.rfmon && strncmp(p->opt.device, "wlt", 3) == 0) {
971  			fd = socket(AF_INET, SOCK_DGRAM, 0);
972  			if (fd != -1) {
973  				char *en_name;
974  				if (pcap_asprintf(&en_name, "en%s",
975  				    p->opt.device + 3) == -1) {
976  					pcap_fmt_errmsg_for_errno(p->errbuf,
977  					    PCAP_ERRBUF_SIZE, errno,
978  					    "malloc");
979  					close(fd);
980  					return (PCAP_ERROR_NO_SUCH_DEVICE);
981  				}
982  				err = device_exists(fd, en_name, p->errbuf);
983  				free(en_name);
984  				if (err != 0) {
985  					if (err == PCAP_ERROR_NO_SUCH_DEVICE) {
986  						err = PCAP_ERROR_RFMON_NOTSUP;
987  					}
988  				}
989  				close(fd);
990  			} else {
991  				err = PCAP_ERROR_NO_SUCH_DEVICE;
992  				pcap_fmt_errmsg_for_errno(p->errbuf,
993  				    errno, PCAP_ERRBUF_SIZE,
994  				    "socket() failed");
995  			}
996  			return (err);
997  		}
998  		return (PCAP_ERROR_NO_SUCH_DEVICE);
999  	}
1000  	return (error);
1001  }
1002  #else
1003  static int
1004  check_setif_failure(pcap_t *p _U_, int error)
1005  {
1006  	return (error);
1007  }
1008  #endif
1009  #ifdef _AIX
1010  #define DEFAULT_BUFSIZE	32768
1011  #else
1012  #define DEFAULT_BUFSIZE	524288
1013  #endif
1014  static int
1015  pcap_activate_bpf(pcap_t *p)
1016  {
1017  	struct pcap_bpf *pb = p->priv;
1018  	int status = 0;
1019  #ifdef HAVE_BSD_IEEE80211
1020  	int retv;
1021  #endif
1022  	int fd;
1023  #if defined(LIFNAMSIZ) && defined(ZONENAME_MAX) && defined(lifr_zoneid)
1024  	struct lifreq ifr;
1025  	char *zonesep;
1026  #endif
1027  	struct bpf_version bv;
1028  #ifdef __APPLE__
1029  	int sockfd;
1030  	char *wltdev = NULL;
1031  #endif
1032  #ifdef BIOCGDLTLIST
1033  	struct bpf_dltlist bdl;
1034  #if defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)
1035  	int new_dlt;
1036  #endif
1037  #endif &bsol;* BIOCGDLTLIST */
1038  #if defined(BIOCGHDRCMPLT) && defined(BIOCSHDRCMPLT)
1039  	u_int spoof_eth_src = 1;
1040  #endif
1041  	u_int v;
1042  	struct bpf_insn total_insn;
1043  	struct bpf_program total_prog;
1044  	struct utsname osinfo;
1045  	int have_osinfo = 0;
1046  #ifdef HAVE_ZEROCOPY_BPF
1047  	struct bpf_zbuf bz;
1048  	u_int bufmode, zbufmax;
1049  	int flags = MAP_ANON;
1050  #endif
1051  	fd = bpf_open(p->errbuf);
1052  	if (fd < 0) {
1053  		status = fd;
1054  		goto bad;
1055  	}
1056  	p->fd = fd;
1057  	if (ioctl(fd, BIOCVERSION, (caddr_t)&bv) < 0) {
1058  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1059  		    errno, "BIOCVERSION");
1060  		status = PCAP_ERROR;
1061  		goto bad;
1062  	}
1063  	if (bv.bv_major != BPF_MAJOR_VERSION ||
1064  	    bv.bv_minor < BPF_MINOR_VERSION) {
1065  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1066  		    "kernel bpf filter out of date");
1067  		status = PCAP_ERROR;
1068  		goto bad;
1069  	}
1070  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
1071  		p->snapshot = MAXIMUM_SNAPLEN;
1072  #if defined(LIFNAMSIZ) && defined(ZONENAME_MAX) && defined(lifr_zoneid)
1073  	if ((ifr.lifr_zoneid = getzoneid()) == -1) {
1074  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1075  		    errno, "getzoneid()");
1076  		status = PCAP_ERROR;
1077  		goto bad;
1078  	}
1079  	if ((zonesep = strchr(p->opt.device, '/')) != NULL) {
1080  		char path_zname[ZONENAME_MAX];
1081  		int  znamelen;
1082  		char *lnamep;
1083  		if (ifr.lifr_zoneid != GLOBAL_ZONEID) {
1084  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1085  			    "zonename/linkname only valid in global zone.");
1086  			status = PCAP_ERROR;
1087  			goto bad;
1088  		}
1089  		znamelen = zonesep - p->opt.device;
1090  		(void) pcap_strlcpy(path_zname, p->opt.device, znamelen + 1);
1091  		ifr.lifr_zoneid = getzoneidbyname(path_zname);
1092  		if (ifr.lifr_zoneid == -1) {
1093  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1094  			    errno, "getzoneidbyname(%s)", path_zname);
1095  			status = PCAP_ERROR;
1096  			goto bad;
1097  		}
1098  		lnamep = strdup(zonesep + 1);
1099  		if (lnamep == NULL) {
1100  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1101  			    errno, "strdup");
1102  			status = PCAP_ERROR;
1103  			goto bad;
1104  		}
1105  		free(p->opt.device);
1106  		p->opt.device = lnamep;
1107  	}
1108  #endif
1109  	pb->device = strdup(p->opt.device);
1110  	if (pb->device == NULL) {
1111  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1112  		    errno, "strdup");
1113  		status = PCAP_ERROR;
1114  		goto bad;
1115  	}
1116  	if (uname(&osinfo) == 0)
1117  		have_osinfo = 1;
1118  #ifdef __APPLE__
1119  	if (p->opt.rfmon) {
1120  		if (have_osinfo) {
1121  			if (osinfo.release[0] < '8' &&
1122  			    osinfo.release[1] == '.') {
1123  				status = PCAP_ERROR_RFMON_NOTSUP;
1124  				goto bad;
1125  			}
1126  			if (osinfo.release[0] == '8' &&
1127  			    osinfo.release[1] == '.') {
1128  				if (strncmp(p->opt.device, "en", 2) != 0) {
1129  					sockfd = socket(AF_INET, SOCK_DGRAM, 0);
1130  					if (sockfd != -1) {
1131  						status = device_exists(sockfd,
1132  						    p->opt.device, p->errbuf);
1133  						if (status == 0) {
1134  							status = PCAP_ERROR_RFMON_NOTSUP;
1135  						}
1136  						close(sockfd);
1137  					} else {
1138  						status = PCAP_ERROR_NO_SUCH_DEVICE;
1139  						pcap_fmt_errmsg_for_errno(p->errbuf,
1140  						    PCAP_ERRBUF_SIZE, errno,
1141  						    "socket() failed");
1142  					}
1143  					goto bad;
1144  				}
1145  				wltdev = malloc(strlen(p->opt.device) + 2);
1146  				if (wltdev == NULL) {
1147  					pcap_fmt_errmsg_for_errno(p->errbuf,
1148  					    PCAP_ERRBUF_SIZE, errno,
1149  					    "malloc");
1150  					status = PCAP_ERROR;
1151  					goto bad;
1152  				}
1153  				strcpy(wltdev, "wlt");
1154  				strcat(wltdev, p->opt.device + 2);
1155  				free(p->opt.device);
1156  				p->opt.device = wltdev;
1157  			}
1158  		}
1159  	}
1160  #endif &bsol;* __APPLE__ */
1161  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
1162  	if (strncmp(p->opt.device, usbus_prefix, USBUS_PREFIX_LEN) == 0) {
1163  		if (if_nametoindex(p->opt.device) == 0) {
1164  			int s;
1165  			struct ifreq ifr;
1166  			s = socket(AF_LOCAL, SOCK_DGRAM, 0);
1167  			if (s < 0) {
1168  				pcap_fmt_errmsg_for_errno(p->errbuf,
1169  				    PCAP_ERRBUF_SIZE, errno,
1170  				    "Can't open socket");
1171  				status = PCAP_ERROR;
1172  				goto bad;
1173  			}
1174  			if (!pcap_do_addexit(p)) {
1175  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1176  				     "atexit failed");
1177  				close(s);
1178  				status = PCAP_ERROR;
1179  				goto bad;
1180  			}
1181  			pcap_strlcpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));
1182  			if (ioctl(s, SIOCIFCREATE2, &ifr) < 0) {
1183  				if (errno == EINVAL) {
1184  					snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1185  					    "Invalid USB bus interface %s",
1186  					    p->opt.device);
1187  				} else {
1188  					pcap_fmt_errmsg_for_errno(p->errbuf,
1189  					    PCAP_ERRBUF_SIZE, errno,
1190  					    "Can't create interface for %s",
1191  					    p->opt.device);
1192  				}
1193  				close(s);
1194  				status = PCAP_ERROR;
1195  				goto bad;
1196  			}
1197  			pb->must_do_on_close |= MUST_DESTROY_USBUS;
1198  			pcap_add_to_pcaps_to_close(p);
1199  		}
1200  	}
1201  #endif &bsol;* defined(__FreeBSD__) && defined(SIOCIFCREATE2) */
1202  #ifdef HAVE_ZEROCOPY_BPF
1203  	bufmode = BPF_BUFMODE_ZBUF;
1204  	if (ioctl(fd, BIOCSETBUFMODE, (caddr_t)&bufmode) == 0) {
1205  		pb->zerocopy = 1;
1206  		if (ioctl(fd, BIOCGETZMAX, (caddr_t)&zbufmax) < 0) {
1207  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1208  			    errno, "BIOCGETZMAX");
1209  			status = PCAP_ERROR;
1210  			goto bad;
1211  		}
1212  		if (p->opt.buffer_size != 0) {
1213  			v = p->opt.buffer_size;
1214  		} else {
1215  			if ((ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) ||
1216  			    v < DEFAULT_BUFSIZE)
1217  				v = DEFAULT_BUFSIZE;
1218  		}
1219  #ifndef roundup
1220  #define roundup(x, y)   ((((x)+((y)-1))/(y))*(y))  &bsol;* to any y */
1221  #endif
1222  		pb->zbufsize = roundup(v, getpagesize());
1223  		if (pb->zbufsize > zbufmax)
1224  			pb->zbufsize = zbufmax;
1225  #ifdef MAP_32BIT
1226  		if (pcap_mmap_32bit) flags |= MAP_32BIT;
1227  #endif
1228  		pb->zbuf1 = mmap(NULL, pb->zbufsize, PROT_READ | PROT_WRITE,
1229  		    flags, -1, 0);
1230  		pb->zbuf2 = mmap(NULL, pb->zbufsize, PROT_READ | PROT_WRITE,
1231  		    flags, -1, 0);
1232  		if (pb->zbuf1 == MAP_FAILED || pb->zbuf2 == MAP_FAILED) {
1233  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1234  			    errno, "mmap");
1235  			status = PCAP_ERROR;
1236  			goto bad;
1237  		}
1238  		memset(&bz, 0, sizeof(bz)); &bsol;* bzero() deprecated, replaced with memset() */
1239  		bz.bz_bufa = pb->zbuf1;
1240  		bz.bz_bufb = pb->zbuf2;
1241  		bz.bz_buflen = pb->zbufsize;
1242  		if (ioctl(fd, BIOCSETZBUF, (caddr_t)&bz) < 0) {
1243  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1244  			    errno, "BIOCSETZBUF");
1245  			status = PCAP_ERROR;
1246  			goto bad;
1247  		}
1248  		status = bpf_bind(fd, p->opt.device, ifnamsiz, p->errbuf);
1249  		if (status != BPF_BIND_SUCCEEDED) {
1250  			if (status == BPF_BIND_BUFFER_TOO_BIG) {
1251  				status = PCAP_ERROR;
1252  			}
1253  			goto bad;
1254  		}
1255  		v = pb->zbufsize - sizeof(struct bpf_zbuf_header);
1256  	} else
1257  #endif
1258  	{
1259  		if (p->opt.buffer_size != 0) {
1260  			if (ioctl(fd, BIOCSBLEN,
1261  			    (caddr_t)&p->opt.buffer_size) < 0) {
1262  				pcap_fmt_errmsg_for_errno(p->errbuf,
1263  				    PCAP_ERRBUF_SIZE, errno,
1264  				    "BIOCSBLEN: %s", p->opt.device);
1265  				status = PCAP_ERROR;
1266  				goto bad;
1267  			}
1268  			status = bpf_bind(fd, p->opt.device, p->errbuf);
1269  			if (status != BPF_BIND_SUCCEEDED) {
1270  				if (status == BPF_BIND_BUFFER_TOO_BIG) {
1271  					status = PCAP_ERROR;
1272  					goto bad;
1273  				}
1274  				status = check_setif_failure(p, status);
1275  				goto bad;
1276  			}
1277  		} else {
1278  			if ((ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) ||
1279  			    v < DEFAULT_BUFSIZE)
1280  				v = DEFAULT_BUFSIZE;
1281  			for ( ; v != 0; v >>= 1) {
1282  				(void) ioctl(fd, BIOCSBLEN, (caddr_t)&v);
1283  				status = bpf_bind(fd, p->opt.device, p->errbuf);
1284  				if (status == BPF_BIND_SUCCEEDED)
1285  					break;	&bsol;* that size worked; we're done */
1286  				if (status != BPF_BIND_BUFFER_TOO_BIG) {
1287  					status = check_setif_failure(p, status);
1288  					goto bad;
1289  				}
1290  			}
1291  			if (v == 0) {
1292  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1293  				    "BIOCSBLEN: %s: No buffer size worked",
1294  				    p->opt.device);
1295  				status = PCAP_ERROR;
1296  				goto bad;
1297  			}
1298  		}
1299  	}
1300  	if (ioctl(fd, BIOCGDLT, (caddr_t)&v) < 0) {
1301  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1302  		    errno, "BIOCGDLT");
1303  		status = PCAP_ERROR;
1304  		goto bad;
1305  	}
1306  #ifdef _AIX
1307  	switch (v) {
1308  	case IFT_ETHER:
1309  	case IFT_ISO88023:
1310  		v = DLT_EN10MB;
1311  		break;
1312  	case IFT_FDDI:
1313  		v = DLT_FDDI;
1314  		break;
1315  	case IFT_ISO88025:
1316  		v = DLT_IEEE802;
1317  		break;
1318  	case IFT_LOOP:
1319  		v = DLT_NULL;
1320  		break;
1321  	default:
1322  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "unknown interface type %u",
1323  		    v);
1324  		status = PCAP_ERROR;
1325  		goto bad;
1326  	}
1327  #endif
1328  #if _BSDI_VERSION - 0 >= 199510
1329  	switch (v) {
1330  	case DLT_SLIP:
1331  		v = DLT_SLIP_BSDOS;
1332  		break;
1333  	case DLT_PPP:
1334  		v = DLT_PPP_BSDOS;
1335  		break;
1336  	case 11:	&bsol;*DLT_FR*/
1337  		v = DLT_FRELAY;
1338  		break;
1339  	case 12:	&bsol;*DLT_C_HDLC*/
1340  		v = DLT_CHDLC;
1341  		break;
1342  	}
1343  #endif
1344  #ifdef BIOCGDLTLIST
1345  	if (get_dlt_list(fd, v, &bdl, p->errbuf) == -1) {
1346  		status = PCAP_ERROR;
1347  		goto bad;
1348  	}
1349  	p->dlt_count = bdl.bfl_len;
1350  	p->dlt_list = bdl.bfl_list;
1351  #ifdef __APPLE__
1352  	if (have_osinfo) {
1353  		if (PCAP_ISDIGIT((unsigned)osinfo.release[0]) &&
1354  		     (osinfo.release[0] == '9' ||
1355  		     PCAP_ISDIGIT((unsigned)osinfo.release[1]))) {
1356  			new_dlt = find_802_11(&bdl);
1357  			if (new_dlt != -1) {
1358  				if (p->opt.rfmon) {
1359  					remove_non_802_11(p);
1360  					if ((u_int)new_dlt != v) {
1361  						if (ioctl(p->fd, BIOCSDLT,
1362  						    &new_dlt) != -1) {
1363  							v = new_dlt;
1364  						}
1365  					}
1366  				} else {
1367  					if (!p->oldstyle)
1368  						remove_802_11(p);
1369  				}
1370  			} else {
1371  				if (p->opt.rfmon) {
1372  					status = PCAP_ERROR_RFMON_NOTSUP;
1373  					goto bad;
1374  				}
1375  			}
1376  		}
1377  	}
1378  #elif defined(HAVE_BSD_IEEE80211)
1379  	if (p->opt.rfmon) {
1380  		retv = monitor_mode(p, 1);
1381  		if (retv != 0) {
1382  			status = retv;
1383  			goto bad;
1384  		}
1385  		new_dlt = find_802_11(&bdl);
1386  		if (new_dlt != -1) {
1387  			if ((u_int)new_dlt != v) {
1388  				if (ioctl(p->fd, BIOCSDLT, &new_dlt) != -1) {
1389  					v = new_dlt;
1390  				}
1391  			}
1392  		}
1393  	}
1394  #endif &bsol;* various platforms */
1395  #endif &bsol;* BIOCGDLTLIST */
1396  	if (v == DLT_EN10MB && p->dlt_count == 0) {
1397  		p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
1398  		if (p->dlt_list == NULL) {
1399  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1400  			    errno, "malloc");
1401  			status = PCAP_ERROR;
1402  			goto bad;
1403  		}
1404  		p->dlt_list[0] = DLT_EN10MB;
1405  		p->dlt_list[1] = DLT_DOCSIS;
1406  		p->dlt_count = 2;
1407  	}
1408  #ifdef PCAP_FDDIPAD
1409  	if (v == DLT_FDDI)
1410  		p->fddipad = PCAP_FDDIPAD;
1411  	else
1412  #endif
1413  		p->fddipad = 0;
1414  	p->linktype = v;
1415  #if defined(BIOCGHDRCMPLT) && defined(BIOCSHDRCMPLT)
1416  	if (ioctl(fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {
1417  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1418  		    errno, "BIOCSHDRCMPLT");
1419  		status = PCAP_ERROR;
1420  		goto bad;
1421  	}
1422  #endif
1423  #ifdef HAVE_ZEROCOPY_BPF
1424  	if (p->opt.timeout && !pb->zerocopy) {
1425  #else
1426  	if (p->opt.timeout) {
1427  #endif
1428  		struct timeval to;
1429  #ifdef HAVE_STRUCT_BPF_TIMEVAL
1430  		struct BPF_TIMEVAL bpf_to;
1431  		if (IOCPARM_LEN(BIOCSRTIMEOUT) != sizeof(struct timeval)) {
1432  			bpf_to.tv_sec = p->opt.timeout / 1000;
1433  			bpf_to.tv_usec = (p->opt.timeout * 1000) % 1000000;
1434  			if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&bpf_to) < 0) {
1435  				pcap_fmt_errmsg_for_errno(p->errbuf,
1436  				    errno, PCAP_ERRBUF_SIZE, "BIOCSRTIMEOUT");
1437  				status = PCAP_ERROR;
1438  				goto bad;
1439  			}
1440  		} else {
1441  #endif
1442  			to.tv_sec = p->opt.timeout / 1000;
1443  			to.tv_usec = (p->opt.timeout * 1000) % 1000000;
1444  			if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&to) < 0) {
1445  				pcap_fmt_errmsg_for_errno(p->errbuf,
1446  				    errno, PCAP_ERRBUF_SIZE, "BIOCSRTIMEOUT");
1447  				status = PCAP_ERROR;
1448  				goto bad;
1449  			}
1450  #ifdef HAVE_STRUCT_BPF_TIMEVAL
1451  		}
1452  #endif
1453  	}
1454  #ifdef	BIOCIMMEDIATE
1455  #ifndef _AIX
1456  	if (p->opt.immediate) {
1457  #endif &bsol;* _AIX */
1458  		v = 1;
1459  		if (ioctl(p->fd, BIOCIMMEDIATE, &v) < 0) {
1460  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1461  			    errno, "BIOCIMMEDIATE");
1462  			status = PCAP_ERROR;
1463  			goto bad;
1464  		}
1465  #ifndef _AIX
1466  	}
1467  #endif &bsol;* _AIX */
1468  #else &bsol;* BIOCIMMEDIATE */
1469  	if (p->opt.immediate) {
1470  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Immediate mode not supported");
1471  		status = PCAP_ERROR;
1472  		goto bad;
1473  	}
1474  #endif &bsol;* BIOCIMMEDIATE */
1475  	if (p->opt.promisc) {
1476  		if (ioctl(p->fd, BIOCPROMISC, NULL) < 0) {
1477  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1478  			    errno, "BIOCPROMISC");
1479  			status = PCAP_WARNING_PROMISC_NOTSUP;
1480  		}
1481  	}
1482  #ifdef BIOCSTSTAMP
1483  	v = BPF_T_BINTIME;
1484  	if (ioctl(p->fd, BIOCSTSTAMP, &v) < 0) {
1485  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1486  		    errno, "BIOCSTSTAMP");
1487  		status = PCAP_ERROR;
1488  		goto bad;
1489  	}
1490  #endif &bsol;* BIOCSTSTAMP */
1491  	if (ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) {
1492  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1493  		    errno, "BIOCGBLEN");
1494  		status = PCAP_ERROR;
1495  		goto bad;
1496  	}
1497  	p->bufsize = v;
1498  #ifdef HAVE_ZEROCOPY_BPF
1499  	if (!pb->zerocopy) {
1500  #endif
1501  	p->buffer = malloc(p->bufsize);
1502  	if (p->buffer == NULL) {
1503  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1504  		    errno, "malloc");
1505  		status = PCAP_ERROR;
1506  		goto bad;
1507  	}
1508  #ifdef _AIX
1509  	memset(p->buffer, 0x0, p->bufsize);
1510  #endif
1511  #ifdef HAVE_ZEROCOPY_BPF
1512  	}
1513  #endif
1514  	total_insn.code = (u_short)(BPF_RET | BPF_K);
1515  	total_insn.jt = 0;
1516  	total_insn.jf = 0;
1517  	total_insn.k = p->snapshot;
1518  	total_prog.bf_len = 1;
1519  	total_prog.bf_insns = &total_insn;
1520  	if (ioctl(p->fd, BIOCSETF, (caddr_t)&total_prog) < 0) {
1521  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1522  		    errno, "BIOCSETF");
1523  		status = PCAP_ERROR;
1524  		goto bad;
1525  	}
1526  	p->selectable_fd = p->fd;	&bsol;* assume select() works until we know otherwise */
1527  	if (have_osinfo) {
1528  		if (strcmp(osinfo.sysname, "FreeBSD") == 0) {
1529  			if (strncmp(osinfo.release, "4.3-", 4) == 0 ||
1530  			     strncmp(osinfo.release, "4.4-", 4) == 0)
1531  				p->selectable_fd = -1;
1532  		}
1533  	}
1534  	p->read_op = pcap_read_bpf;
1535  	p->inject_op = pcap_inject_bpf;
1536  	p->setfilter_op = pcap_setfilter_bpf;
1537  	p->setdirection_op = pcap_setdirection_bpf;
1538  	p->set_datalink_op = pcap_set_datalink_bpf;
1539  	p->getnonblock_op = pcap_getnonblock_bpf;
1540  	p->setnonblock_op = pcap_setnonblock_bpf;
1541  	p->stats_op = pcap_stats_bpf;
1542  	p->cleanup_op = pcap_cleanup_bpf;
1543  	return (status);
1544   bad:
1545  	pcap_cleanup_bpf(p);
1546  	return (status);
1547  }
1548  static int
1549  check_bpf_bindable(const char *name)
1550  {
1551  	int fd;
1552  	char errbuf[PCAP_ERRBUF_SIZE];
1553  #ifdef __APPLE__
1554  	if (strncmp(name, "wlt", 3) == 0) {
1555  		char *en_name;
1556  		size_t en_name_len;
1557  		en_name_len = strlen(name) - 1;
1558  		en_name = malloc(en_name_len + 1);
1559  		if (en_name == NULL) {
1560  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1561  			    errno, "malloc");
1562  			return (-1);
1563  		}
1564  		strcpy(en_name, "en");
1565  		strcat(en_name, name + 3);
1566  		fd = bpf_open_and_bind(en_name, errbuf);
1567  		free(en_name);
1568  	} else
1569  #endif &bsol;* __APPLE */
1570  	fd = bpf_open_and_bind(name, errbuf);
1571  	if (fd < 0) {
1572  		if (fd == PCAP_ERROR_NO_SUCH_DEVICE) {
1573  			return (0);
1574  		}
1575  		return (1);
1576  	}
1577  	close(fd);
1578  	return (1);
1579  }
1580  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
1581  static int
1582  get_usb_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
1583  {
1584  	return (0);
1585  }
1586  static int
1587  finddevs_usb(pcap_if_list_t *devlistp, char *errbuf)
1588  {
1589  	DIR *usbdir;
1590  	struct dirent *usbitem;
1591  	size_t name_max;
1592  	char *name;
1593  	usbdir = opendir("/dev/usb");
1594  	if (usbdir == NULL) {
1595  		return (0);
1596  	}
1597  	name_max = USBUS_PREFIX_LEN + 10 + 1;
1598  	name = malloc(name_max);
1599  	if (name == NULL) {
1600  		closedir(usbdir);
1601  		return (0);
1602  	}
1603  	while ((usbitem = readdir(usbdir)) != NULL) {
1604  		char *p;
1605  		size_t busnumlen;
1606  		if (strcmp(usbitem->d_name, ".") == 0 ||
1607  		    strcmp(usbitem->d_name, "..") == 0) {
1608  			continue;
1609  		}
1610  		p = strchr(usbitem->d_name, '.');
1611  		if (p == NULL)
1612  			continue;
1613  		busnumlen = p - usbitem->d_name;
1614  		memcpy(name, usbus_prefix, USBUS_PREFIX_LEN);
1615  		memcpy(name + USBUS_PREFIX_LEN, usbitem->d_name, busnumlen);
1616  		*(name + USBUS_PREFIX_LEN + busnumlen) = '\0';
1617  		if (pcap_find_or_add_dev(devlistp, name, PCAP_IF_UP,
1618  		    get_usb_if_flags, NULL, errbuf) == NULL) {
1619  			free(name);
1620  			closedir(usbdir);
1621  			return (PCAP_ERROR);
1622  		}
1623  	}
1624  	free(name);
1625  	closedir(usbdir);
1626  	return (0);
1627  }
1628  #endif
1629  #ifdef SIOCGIFMEDIA
1630  static int
1631  get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
1632  {
1633  	int sock;
1634  	struct ifmediareq req;
1635  	sock = socket(AF_INET, SOCK_DGRAM, 0);
1636  	if (sock == -1) {
1637  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
1638  		    "Can't create socket to get media information for %s",
1639  		    name);
1640  		return (-1);
1641  	}
1642  	memset(&req, 0, sizeof(req));
1643  	pcap_strlcpy(req.ifm_name, name, sizeof(req.ifm_name));
1644  	if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
1645  		if (errno == EOPNOTSUPP || errno == EINVAL || errno == ENOTTY ||
1646  		    errno == ENODEV || errno == EPERM
1647  #ifdef EPWROFF
1648  		    || errno == EPWROFF
1649  #endif
1650  		    ) {
1651  			*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
1652  			close(sock);
1653  			return (0);
1654  		}
1655  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
1656  		    "SIOCGIFMEDIA on %s failed", name);
1657  		close(sock);
1658  		return (-1);
1659  	}
1660  	close(sock);
1661  	switch (IFM_TYPE(req.ifm_active)) {
1662  	case IFM_IEEE80211:
1663  		*flags |= PCAP_IF_WIRELESS;
1664  		break;
1665  	}
1666  	if (req.ifm_status & IFM_AVALID) {
1667  		if (req.ifm_status & IFM_ACTIVE) {
1668  			*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;
1669  		} else {
1670  			*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;
1671  		}
1672  	}
1673  	return (0);
1674  }
1675  #else
1676  static int
1677  get_if_flags(const char *name _U_, bpf_u_int32 *flags, char *errbuf _U_)
1678  {
1679  	if (*flags & PCAP_IF_LOOPBACK) {
1680  		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
1681  		return (0);
1682  	}
1683  	return (0);
1684  }
1685  #endif
1686  int
1687  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
1688  {
1689  	if (pcap_findalldevs_interfaces(devlistp, errbuf, check_bpf_bindable,
1690  	    get_if_flags) == -1)
1691  		return (-1);	&bsol;* failure */
1692  #if defined(HAVE_SOLARIS_ANY_DEVICE)
1693  	if (pcap_add_any_dev(devlistp, errbuf) == NULL)
1694  		return (-1);
1695  #endif
1696  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
1697  	if (finddevs_usb(devlistp, errbuf) == -1)
1698  		return (-1);
1699  #endif
1700  	return (0);
1701  }
1702  #ifdef HAVE_BSD_IEEE80211
1703  static int
1704  monitor_mode(pcap_t *p, int set)
1705  {
1706  	struct pcap_bpf *pb = p->priv;
1707  	int sock;
1708  	struct ifmediareq req;
1709  	IFM_ULIST_TYPE *media_list;
1710  	int i;
1711  	int can_do;
1712  	struct ifreq ifr;
1713  	sock = socket(AF_INET, SOCK_DGRAM, 0);
1714  	if (sock == -1) {
1715  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1716  		    errno, "can't open socket");
1717  		return (PCAP_ERROR);
1718  	}
1719  	memset(&req, 0, sizeof req);
1720  	pcap_strlcpy(req.ifm_name, p->opt.device, sizeof req.ifm_name);
1721  	if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
1722  		switch (errno) {
1723  		case ENXIO:
1724  			p->errbuf[0] = '\0';
1725  			close(sock);
1726  			return (PCAP_ERROR_NO_SUCH_DEVICE);
1727  		case EINVAL:
1728  			close(sock);
1729  			return (PCAP_ERROR_RFMON_NOTSUP);
1730  		default:
1731  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1732  			    errno, "SIOCGIFMEDIA");
1733  			close(sock);
1734  			return (PCAP_ERROR);
1735  		}
1736  	}
1737  	if (req.ifm_count == 0) {
1738  		close(sock);
1739  		return (PCAP_ERROR_RFMON_NOTSUP);
1740  	}
1741  	media_list = malloc(req.ifm_count * sizeof(*media_list));
1742  	if (media_list == NULL) {
1743  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1744  		    errno, "malloc");
1745  		close(sock);
1746  		return (PCAP_ERROR);
1747  	}
1748  	req.ifm_ulist = media_list;
1749  	if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
1750  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1751  		    errno, "SIOCGIFMEDIA");
1752  		free(media_list);
1753  		close(sock);
1754  		return (PCAP_ERROR);
1755  	}
1756  	can_do = 0;
1757  	for (i = 0; i < req.ifm_count; i++) {
1758  		if (IFM_TYPE(media_list[i]) == IFM_IEEE80211
1759  		    && IFM_SUBTYPE(media_list[i]) == IFM_AUTO) {
1760  			if (media_list[i] & IFM_IEEE80211_MONITOR) {
1761  				can_do = 1;
1762  				break;
1763  			}
1764  		}
1765  	}
1766  	free(media_list);
1767  	if (!can_do) {
1768  		close(sock);
1769  		return (PCAP_ERROR_RFMON_NOTSUP);
1770  	}
1771  	if (set) {
1772  		if ((req.ifm_current & IFM_IEEE80211_MONITOR) == 0) {
1773  			if (!pcap_do_addexit(p)) {
1774  				close(sock);
1775  				return (PCAP_ERROR);
1776  			}
1777  			memset(&ifr, 0, sizeof(ifr));
1778  			(void)pcap_strlcpy(ifr.ifr_name, p->opt.device,
1779  			    sizeof(ifr.ifr_name));
1780  			ifr.ifr_media = req.ifm_current | IFM_IEEE80211_MONITOR;
1781  			if (ioctl(sock, SIOCSIFMEDIA, &ifr) == -1) {
1782  				pcap_fmt_errmsg_for_errno(p->errbuf,
1783  				    PCAP_ERRBUF_SIZE, errno, "SIOCSIFMEDIA");
1784  				close(sock);
1785  				return (PCAP_ERROR);
1786  			}
1787  			pb->must_do_on_close |= MUST_CLEAR_RFMON;
1788  			pcap_add_to_pcaps_to_close(p);
1789  		}
1790  	}
1791  	return (0);
1792  }
1793  #endif &bsol;* HAVE_BSD_IEEE80211 */
1794  #if defined(BIOCGDLTLIST) && (defined(__APPLE__) || defined(HAVE_BSD_IEEE80211))
1795  static int
1796  find_802_11(struct bpf_dltlist *bdlp)
1797  {
1798  	int new_dlt;
1799  	u_int i;
1800  	new_dlt = -1;
1801  	for (i = 0; i < bdlp->bfl_len; i++) {
1802  		switch (bdlp->bfl_list[i]) {
1803  		case DLT_IEEE802_11:
1804  			if (new_dlt == -1)
1805  				new_dlt = bdlp->bfl_list[i];
1806  			break;
1807  #ifdef DLT_PRISM_HEADER
1808  		case DLT_PRISM_HEADER:
1809  #endif
1810  #ifdef DLT_AIRONET_HEADER
1811  		case DLT_AIRONET_HEADER:
1812  #endif
1813  		case DLT_IEEE802_11_RADIO_AVS:
1814  			if (new_dlt != DLT_IEEE802_11_RADIO)
1815  				new_dlt = bdlp->bfl_list[i];
1816  			break;
1817  		case DLT_IEEE802_11_RADIO:
1818  			new_dlt = bdlp->bfl_list[i];
1819  			break;
1820  		default:
1821  			break;
1822  		}
1823  	}
1824  	return (new_dlt);
1825  }
1826  #endif &bsol;* defined(BIOCGDLTLIST) && (defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)) */
1827  #if defined(__APPLE__) && defined(BIOCGDLTLIST)
1828  static void
1829  remove_non_802_11(pcap_t *p)
1830  {
1831  	int i, j;
1832  	j = 0;
1833  	for (i = 0; i < p->dlt_count; i++) {
1834  		switch (p->dlt_list[i]) {
1835  		case DLT_EN10MB:
1836  		case DLT_RAW:
1837  			continue;
1838  		default:
1839  			break;
1840  		}
1841  		p->dlt_list[j] = p->dlt_list[i];
1842  		j++;
1843  	}
1844  	p->dlt_count = j;
1845  }
1846  static void
1847  remove_802_11(pcap_t *p)
1848  {
1849  	int i, j;
1850  	j = 0;
1851  	for (i = 0; i < p->dlt_count; i++) {
1852  		switch (p->dlt_list[i]) {
1853  		case DLT_IEEE802_11:
1854  #ifdef DLT_PRISM_HEADER
1855  		case DLT_PRISM_HEADER:
1856  #endif
1857  #ifdef DLT_AIRONET_HEADER
1858  		case DLT_AIRONET_HEADER:
1859  #endif
1860  		case DLT_IEEE802_11_RADIO:
1861  		case DLT_IEEE802_11_RADIO_AVS:
1862  #ifdef DLT_PPI
1863  		case DLT_PPI:
1864  #endif
1865  			continue;
1866  		default:
1867  			break;
1868  		}
1869  		p->dlt_list[j] = p->dlt_list[i];
1870  		j++;
1871  	}
1872  	p->dlt_count = j;
1873  }
1874  #endif &bsol;* defined(__APPLE__) && defined(BIOCGDLTLIST) */
1875  static int
1876  pcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp)
1877  {
1878  	struct pcap_bpf *pb = p->priv;
1879  	pcap_freecode(&p->fcode);
1880  	if (ioctl(p->fd, BIOCSETF, (caddr_t)fp) == 0) {
1881  		pb->filtering_in_kernel = 1;	&bsol;* filtering in the kernel */
1882  		p->cc = 0;
1883  		return (0);
1884  	}
1885  	if (errno != EINVAL) {
1886  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1887  		    errno, "BIOCSETF");
1888  		return (-1);
1889  	}
1890  	if (pcap_install_bpf_program(p, fp) < 0)
1891  		return (-1);
1892  	pb->filtering_in_kernel = 0;	&bsol;* filtering in userland */
1893  	return (0);
1894  }
1895  #if defined(BIOCSDIRECTION)
1896  static int
1897  pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
1898  {
1899  	u_int direction;
1900  	const char *direction_name;
1901  	switch (d) {
1902  	case PCAP_D_IN:
1903  		direction = BPF_D_IN;
1904  		direction_name = "\"incoming only\"";
1905  		break;
1906  	case PCAP_D_OUT:
1907  		direction = BPF_D_OUT;
1908  		direction_name = "\"outgoing only\"";
1909  		break;
1910  	default:
1911  		direction = BPF_D_INOUT;
1912  		direction_name = "\"incoming and outgoing\"";
1913  		break;
1914  	}
1915  	if (ioctl(p->fd, BIOCSDIRECTION, &direction) == -1) {
1916  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1917  		    errno, "Cannot set direction to %s", direction_name);
1918  		return (-1);
1919  	}
1920  	return (0);
1921  }
1922  #elif defined(BIOCSDIRFILT)
1923  static int
1924  pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
1925  {
1926  	u_int dirfilt;
1927  	const char *direction_name;
1928  	switch (d) {
1929  	case PCAP_D_IN:
1930  		dirfilt = BPF_DIRECTION_OUT;
1931  		direction_name = "\"incoming only\"";
1932  		break;
1933  	case PCAP_D_OUT:
1934  		dirfilt = BPF_DIRECTION_IN;
1935  		direction_name = "\"outgoing only\"";
1936  		break;
1937  	default:
1938  		dirfilt = 0;
1939  		direction_name = "\"incoming and outgoing\"";
1940  		break;
1941  	}
1942  	if (ioctl(p->fd, BIOCSDIRFILT, &dirfilt) == -1) {
1943  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1944  		    errno, "Cannot set direction to %s", direction_name);
1945  		return (-1);
1946  	}
1947  	return (0);
1948  }
1949  #elif defined(BIOCSSEESENT)
1950  static int
1951  pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
1952  {
1953  	u_int seesent;
1954  	const char *direction_name;
1955  	switch (d) {
1956  	case PCAP_D_IN:
1957  		seesent = 0;
1958  		direction_name = "\"incoming only\"";
1959  		break;
1960  	case PCAP_D_OUT:
1961  		snprintf(p->errbuf, sizeof(p->errbuf),
1962  		    "Setting direction to \"outgoing only\" is not supported on this device");
1963  		return (-1);
1964  	default:
1965  		seesent = 1;
1966  		direction_name = "\"incoming and outgoing\"";
1967  		break;
1968  	}
1969  	if (ioctl(p->fd, BIOCSSEESENT, &seesent) == -1) {
1970  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1971  		    errno, "Cannot set direction to %s", direction_name);
1972  		return (-1);
1973  	}
1974  	return (0);
1975  }
1976  #else
1977  static int
1978  pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d _U_)
1979  {
1980  	(void) snprintf(p->errbuf, sizeof(p->errbuf),
1981  	    "Setting direction is not supported on this device");
1982  	return (-1);
1983  }
1984  #endif
1985  #ifdef BIOCSDLT
1986  static int
1987  pcap_set_datalink_bpf(pcap_t *p, int dlt)
1988  {
1989  	if (ioctl(p->fd, BIOCSDLT, &dlt) == -1) {
1990  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1991  		    errno, "Cannot set DLT %d", dlt);
1992  		return (-1);
1993  	}
1994  	return (0);
1995  }
1996  #else
1997  static int
1998  pcap_set_datalink_bpf(pcap_t *p _U_, int dlt _U_)
1999  {
2000  	return (0);
2001  }
2002  #endif
2003  const char *
2004  pcap_lib_version(void)
2005  {
2006  #ifdef HAVE_ZEROCOPY_BPF
2007  	return (PCAP_VERSION_STRING " (with zerocopy support)");
2008  #else
2009  	return (PCAP_VERSION_STRING);
2010  #endif
2011  }
</code></pre>
        </div>
        <div class="column">
            <h3>libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-bpf.c</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #include <config.h>
3  #endif
4  #include <sys/param.h>			&bsol;* optionally get BSD define */
5  #include <sys/socket.h>
6  #include <time.h>
7  #include <sys/ioctl.h>
8  #ifdef HAVE_SYS_IOCCOM_H
9  #include <sys/ioccom.h>
10  #endif
11  #include <sys/utsname.h>
12  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
13  static const char usbus_prefix[] = "usbus";
14  #define USBUS_PREFIX_LEN	(sizeof(usbus_prefix) - 1)
15  #include <dirent.h>
16  #endif
17  #include <net/if.h>
18  #ifdef _AIX
19  #define PCAP_DONT_INCLUDE_PCAP_BPF_H
20  #include <sys/types.h>
21  #undef _AIX
22  #include <net/bpf.h>
23  #define _AIX
24  #if defined(BIOCROTZBUF) && defined(BPF_BUFMODE_ZBUF)
25    #define HAVE_ZEROCOPY_BPF
26    #include <sys/mman.h>
27    #include <machine/atomic.h>
28  #endif
29  #include <net/if_types.h>		&bsol;* for IFT_ values */
30  #include <sys/sysconfig.h>
31  #include <sys/device.h>
32  #include <sys/cfgodm.h>
33  #include <cf.h>
34  #ifdef __64BIT__
35  #define domakedev makedev64
36  #define getmajor major64
37  #define bpf_hdr bpf_hdr32
38  #else &bsol;* __64BIT__ */
39  #define domakedev makedev
40  #define getmajor major
41  #endif &bsol;* __64BIT__ */
42  #define BPF_NAME "bpf"
43  #define BPF_MINORS 4
44  #define DRIVER_PATH "/usr/lib/drivers"
45  #define BPF_NODE "/dev/bpf"
46  static int bpfloadedflag = 0;
47  static int odmlockid = 0;
48  static int bpf_load(char *errbuf);
49  #else &bsol;* _AIX */
50  #include <net/bpf.h>
51  #endif &bsol;* _AIX */
52  #include <fcntl.h>
53  #include <errno.h>
54  #include <netdb.h>
55  #include <stdio.h>
56  #include <stdlib.h>
57  #include <string.h>
58  #include <unistd.h>
59  #ifdef SIOCGIFMEDIA
60  # include <net/if_media.h>
61  #endif
62  #include "pcap-int.h"
63  #ifdef HAVE_OS_PROTO_H
64  #include "os-proto.h"
65  #endif
66  #if defined(__NetBSD__) && __NetBSD_Version__ > 106000000
67  #define       PCAP_FDDIPAD 3
68  #endif
69  struct pcap_bpf {
70  #ifdef HAVE_ZEROCOPY_BPF
71  	u_char *zbuf1, *zbuf2, *zbuffer;
72  	u_int zbufsize;
73  	u_int zerocopy;
74  	u_int interrupted;
75  	struct timespec firstsel;
76  	struct bpf_zbuf_header *bzh;
77  	int nonblock;		&bsol;* true if in nonblocking mode */
78  #endif &bsol;* HAVE_ZEROCOPY_BPF */
79  	char *device;		&bsol;* device name */
80  	int filtering_in_kernel; &bsol;* using kernel filter */
81  	int must_do_on_close;	&bsol;* stuff we must do when we close */
82  };
83  #define MUST_CLEAR_RFMON	0x00000001	&bsol;* clear rfmon (monitor) mode */
84  #define MUST_DESTROY_USBUS	0x00000002	&bsol;* destroy usbusN interface */
85  #ifdef BIOCGDLTLIST
86  # if (defined(HAVE_NET_IF_MEDIA_H) && defined(IFM_IEEE80211)) && !defined(__APPLE__)
87  #define HAVE_BSD_IEEE80211
88  #  if defined(IFM_GMASK) && IFM_GMASK > 0xFFFFFFFF
89  #    define IFM_ULIST_TYPE	uint64_t
90  #  else
91  #    define IFM_ULIST_TYPE	int
92  #  endif
93  # endif
94  # if defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)
95  static int find_802_11(struct bpf_dltlist *);
96  #  ifdef HAVE_BSD_IEEE80211
97  static int monitor_mode(pcap_t *, int);
98  #  endif
99  #  if defined(__APPLE__)
100  static void remove_non_802_11(pcap_t *);
101  static void remove_802_11(pcap_t *);
102  #  endif
103  # endif &bsol;* defined(__APPLE__) || defined(HAVE_BSD_IEEE80211) */
104  #endif &bsol;* BIOCGDLTLIST */
105  #if defined(sun) && defined(LIFNAMSIZ) && defined(lifr_zoneid)
106  #include <zone.h>
107  #endif
108  #ifndef DLT_DOCSIS
109  #define DLT_DOCSIS	143
110  #endif
111  #ifndef DLT_PRISM_HEADER
112  #define DLT_PRISM_HEADER	119
113  #endif
114  #ifndef DLT_AIRONET_HEADER
115  #define DLT_AIRONET_HEADER	120
116  #endif
117  #ifndef DLT_IEEE802_11_RADIO
118  #define DLT_IEEE802_11_RADIO	127
119  #endif
120  #ifndef DLT_IEEE802_11_RADIO_AVS
121  #define DLT_IEEE802_11_RADIO_AVS 163
122  #endif
123  static int pcap_can_set_rfmon_bpf(pcap_t *p);
124  static int pcap_activate_bpf(pcap_t *p);
125  static int pcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp);
126  static int pcap_setdirection_bpf(pcap_t *, pcap_direction_t);
127  static int pcap_set_datalink_bpf(pcap_t *p, int dlt);
128  static int
129  pcap_getnonblock_bpf(pcap_t *p)
130  {
131  #ifdef HAVE_ZEROCOPY_BPF
132  	struct pcap_bpf *pb = p->priv;
133  	if (pb->zerocopy)
134  		return (pb->nonblock);
135  #endif
136  	return (pcap_getnonblock_fd(p));
137  }
138  static int
139  pcap_setnonblock_bpf(pcap_t *p, int nonblock)
140  {
141  #ifdef HAVE_ZEROCOPY_BPF
142  	struct pcap_bpf *pb = p->priv;
143  	if (pb->zerocopy) {
144  		pb->nonblock = nonblock;
145  		return (0);
146  	}
147  #endif
148  	return (pcap_setnonblock_fd(p, nonblock));
149  }
150  #ifdef HAVE_ZEROCOPY_BPF
151  static int
152  pcap_next_zbuf_shm(pcap_t *p, int *cc)
153  {
154  	struct pcap_bpf *pb = p->priv;
155  	struct bpf_zbuf_header *bzh;
156  	if (pb->zbuffer == pb->zbuf2 || pb->zbuffer == NULL) {
157  		bzh = (struct bpf_zbuf_header *)pb->zbuf1;
158  		if (bzh->bzh_user_gen !=
159  		    atomic_load_acq_int(&bzh->bzh_kernel_gen)) {
160  			pb->bzh = bzh;
161  			pb->zbuffer = (u_char *)pb->zbuf1;
162  			p->buffer = pb->zbuffer + sizeof(*bzh);
163  			*cc = bzh->bzh_kernel_len;
164  			return (1);
165  		}
166  	} else if (pb->zbuffer == pb->zbuf1) {
167  		bzh = (struct bpf_zbuf_header *)pb->zbuf2;
168  		if (bzh->bzh_user_gen !=
169  		    atomic_load_acq_int(&bzh->bzh_kernel_gen)) {
170  			pb->bzh = bzh;
171  			pb->zbuffer = (u_char *)pb->zbuf2;
172  			p->buffer = pb->zbuffer + sizeof(*bzh);
173  			*cc = bzh->bzh_kernel_len;
174  			return (1);
175  		}
176  	}
177  	*cc = 0;
178  	return (0);
179  }
180  static int
181  pcap_next_zbuf(pcap_t *p, int *cc)
182  {
183  	struct pcap_bpf *pb = p->priv;
184  	struct bpf_zbuf bz;
185  	struct timeval tv;
186  	struct timespec cur;
187  	fd_set r_set;
188  	int data, r;
189  	int expire, tmout;
190  #define TSTOMILLI(ts) (((ts)->tv_sec * 1000) + ((ts)->tv_nsec / 1000000))
191  	data = pcap_next_zbuf_shm(p, cc);
192  	if (data)
193  		return (data);
194  	tmout = p->opt.timeout;
195  	if (tmout)
196  		(void) clock_gettime(CLOCK_MONOTONIC, &cur);
197  	if (pb->interrupted && p->opt.timeout) {
198  		expire = TSTOMILLI(&pb->firstsel) + p->opt.timeout;
199  		tmout = expire - TSTOMILLI(&cur);
200  #undef TSTOMILLI
201  		if (tmout <= 0) {
202  			pb->interrupted = 0;
203  			data = pcap_next_zbuf_shm(p, cc);
204  			if (data)
205  				return (data);
206  			if (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {
207  				pcap_fmt_errmsg_for_errno(p->errbuf,
208  				    PCAP_ERRBUF_SIZE, errno, "BIOCROTZBUF");
209  				return (PCAP_ERROR);
210  			}
211  			return (pcap_next_zbuf_shm(p, cc));
212  		}
213  	}
214  	if (!pb->nonblock) {
215  		FD_ZERO(&r_set);
216  		FD_SET(p->fd, &r_set);
217  		if (tmout != 0) {
218  			tv.tv_sec = tmout / 1000;
219  			tv.tv_usec = (tmout * 1000) % 1000000;
220  		}
221  		r = select(p->fd + 1, &r_set, NULL, NULL,
222  		    p->opt.timeout != 0 ? &tv : NULL);
223  		if (r < 0 && errno == EINTR) {
224  			if (!pb->interrupted && p->opt.timeout) {
225  				pb->interrupted = 1;
226  				pb->firstsel = cur;
227  			}
228  			return (0);
229  		} else if (r < 0) {
230  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
231  			    errno, "select");
232  			return (PCAP_ERROR);
233  		}
234  	}
235  	pb->interrupted = 0;
236  	data = pcap_next_zbuf_shm(p, cc);
237  	if (data)
238  		return (data);
239  	if (ioctl(p->fd, BIOCROTZBUF, &bz) < 0) {
240  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
241  		    errno, "BIOCROTZBUF");
242  		return (PCAP_ERROR);
243  	}
244  	return (pcap_next_zbuf_shm(p, cc));
245  }
246  static int
247  pcap_ack_zbuf(pcap_t *p)
248  {
249  	struct pcap_bpf *pb = p->priv;
250  	atomic_store_rel_int(&pb->bzh->bzh_user_gen,
251  	    pb->bzh->bzh_kernel_gen);
252  	pb->bzh = NULL;
253  	p->buffer = NULL;
254  	return (0);
255  }
256  #endif &bsol;* HAVE_ZEROCOPY_BPF */
257  pcap_t *
258  pcap_create_interface(const char *device _U_, char *ebuf)
259  {
260  	pcap_t *p;
261  	p = PCAP_CREATE_COMMON(ebuf, struct pcap_bpf);
262  	if (p == NULL)
263  		return (NULL);
264  	p->activate_op = pcap_activate_bpf;
265  	p->can_set_rfmon_op = pcap_can_set_rfmon_bpf;
266  #ifdef BIOCSTSTAMP
267  	p->tstamp_precision_list = malloc(2 * sizeof(u_int));
268  	if (p->tstamp_precision_list == NULL) {
269  		pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE, errno,
270  		    "malloc");
271  		free(p);
272  		return (NULL);
273  	}
274  	p->tstamp_precision_list[0] = PCAP_TSTAMP_PRECISION_MICRO;
275  	p->tstamp_precision_list[1] = PCAP_TSTAMP_PRECISION_NANO;
276  	p->tstamp_precision_count = 2;
277  #endif &bsol;* BIOCSTSTAMP */
278  	return (p);
279  }
280  static int
281  bpf_open(char *errbuf)
282  {
283  	int fd = -1;
284  	static const char cloning_device[] = "/dev/bpf";
285  	u_int n = 0;
286  	char device[sizeof "/dev/bpf0000000000"];
287  	static int no_cloning_bpf = 0;
288  #ifdef _AIX
289  	if (bpf_load(errbuf) == PCAP_ERROR)
290  		return (PCAP_ERROR);
291  #endif
292  	if (!no_cloning_bpf &&
293  	    (fd = open(cloning_device, O_RDWR)) == -1 &&
294  	    ((errno != EACCES && errno != ENOENT) ||
295  	     (fd = open(cloning_device, O_RDONLY)) == -1)) {
296  		if (errno != ENOENT) {
297  			if (errno == EACCES) {
298  				fd = PCAP_ERROR_PERM_DENIED;
299  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
300  				    "Attempt to open %s failed - root privileges may be required",
301  				    cloning_device);
302  			} else {
303  				fd = PCAP_ERROR;
304  				pcap_fmt_errmsg_for_errno(errbuf,
305  				    PCAP_ERRBUF_SIZE, errno,
306  				    "(cannot open device) %s", cloning_device);
307  			}
308  			return (fd);
309  		}
310  		no_cloning_bpf = 1;
311  	}
312  	if (no_cloning_bpf) {
313  		do {
314  			(void)snprintf(device, sizeof(device), "/dev/bpf%u", n++);
315  			fd = open(device, O_RDWR);
316  			if (fd == -1 && errno == EACCES)
317  				fd = open(device, O_RDONLY);
318  		} while (fd < 0 && errno == EBUSY);
319  	}
320  	if (fd < 0) {
321  		switch (errno) {
322  		case ENOENT:
323  			fd = PCAP_ERROR;
324  			if (n == 1) {
325  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
326  				    "(there are no BPF devices)");
327  			} else {
328  				snprintf(errbuf, PCAP_ERRBUF_SIZE,
329  				    "(all BPF devices are busy)");
330  			}
331  			break;
332  		case EACCES:
333  			fd = PCAP_ERROR_PERM_DENIED;
334  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
335  			    "Attempt to open %s failed - root privileges may be required",
336  			    device);
337  			break;
338  		default:
339  			fd = PCAP_ERROR;
340  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
341  			    errno, "(cannot open BPF device) %s", device);
342  			break;
343  		}
344  	}
345  	return (fd);
346  }
347  #define BPF_BIND_SUCCEEDED	0
348  #define BPF_BIND_BUFFER_TOO_BIG	1
349  static int
350  bpf_bind(int fd, const char *name, char *errbuf)
351  {
352  	int status;
353  #ifdef LIFNAMSIZ
354  	struct lifreq ifr;
355  	if (strlen(name) >= sizeof(ifr.lifr_name)) {
356  		return (PCAP_ERROR_NO_SUCH_DEVICE);
357  	}
358  	(void)pcap_strlcpy(ifr.lifr_name, name, sizeof(ifr.lifr_name));
359  	status = ioctl(fd, BIOCSETLIF, (caddr_t)&ifr);
360  #else
361  	struct ifreq ifr;
362  	if (strlen(name) >= sizeof(ifr.ifr_name)) {
363  		return (PCAP_ERROR_NO_SUCH_DEVICE);
364  	}
365  	(void)pcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
366  	status = ioctl(fd, BIOCSETIF, (caddr_t)&ifr);
367  #endif
368  	if (status < 0) {
369  		switch (errno) {
370  #if defined(HAVE_SOLARIS)
371  		case ESRCH:
372  #else
373  		case ENXIO:
374  #endif
375  			errbuf[0] = '\0';
376  			return (PCAP_ERROR_NO_SUCH_DEVICE);
377  		case ENETDOWN:
378  			return (PCAP_ERROR_IFACE_NOT_UP);
379  		case ENOBUFS:
380  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
381  			    errno, "The requested buffer size for %s is too large",
382  			    name);
383  			return (BPF_BIND_BUFFER_TOO_BIG);
384  		default:
385  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
386  			    errno, "Binding interface %s to BPF device failed",
387  			    name);
388  			return (PCAP_ERROR);
389  		}
390  	}
391  	return (BPF_BIND_SUCCEEDED);
392  }
393  static int
394  bpf_open_and_bind(const char *name, char *errbuf)
395  {
396  	int fd;
397  	int status;
398  	fd = bpf_open(errbuf);
399  	if (fd < 0)
400  		return (fd);	&bsol;* fd is the appropriate error code */
401  	status = bpf_bind(fd, name, errbuf);
402  	if (status != BPF_BIND_SUCCEEDED) {
403  		close(fd);
404  		if (status == BPF_BIND_BUFFER_TOO_BIG) {
405  			return (PCAP_ERROR);
406  		}
407  		return (status);
408  	}
409  	return (fd);
410  }
411  #ifdef __APPLE__
412  static int
413  device_exists(int fd, const char *name, char *errbuf)
414  {
415  	int status;
416  	struct ifreq ifr;
417  	if (strlen(name) >= sizeof(ifr.ifr_name)) {
418  		return (PCAP_ERROR_NO_SUCH_DEVICE);
419  	}
420  	(void)pcap_strlcpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));
421  	status = ioctl(fd, SIOCGIFFLAGS, (caddr_t)&ifr);
422  	if (status < 0) {
423  		if (errno == ENXIO || errno == EINVAL) {
424  			return (PCAP_ERROR_NO_SUCH_DEVICE);
425  		}
426  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
427  		    "Can't get interface flags on %s", name);
428  		return (PCAP_ERROR);
429  	}
430  	return (0);
431  }
432  #endif
433  #ifdef BIOCGDLTLIST
434  static int
435  get_dlt_list(int fd, int v, struct bpf_dltlist *bdlp, char *ebuf)
436  {
437  	memset(bdlp, 0, sizeof(*bdlp));
438  	if (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) == 0) {
439  		u_int i;
440  		int is_ethernet;
441  		bdlp->bfl_list = (u_int *) malloc(sizeof(u_int) * (bdlp->bfl_len + 1));
442  		if (bdlp->bfl_list == NULL) {
443  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
444  			    errno, "malloc");
445  			return (PCAP_ERROR);
446  		}
447  		if (ioctl(fd, BIOCGDLTLIST, (caddr_t)bdlp) < 0) {
448  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
449  			    errno, "BIOCGDLTLIST");
450  			free(bdlp->bfl_list);
451  			return (PCAP_ERROR);
452  		}
453  		if (v == DLT_EN10MB) {
454  			is_ethernet = 1;
455  			for (i = 0; i < bdlp->bfl_len; i++) {
456  				if (bdlp->bfl_list[i] != DLT_EN10MB
457  #ifdef DLT_IPNET
458  				    && bdlp->bfl_list[i] != DLT_IPNET
459  #endif
460  				    ) {
461  					is_ethernet = 0;
462  					break;
463  				}
464  			}
465  			if (is_ethernet) {
466  				bdlp->bfl_list[bdlp->bfl_len] = DLT_DOCSIS;
467  				bdlp->bfl_len++;
468  			}
469  		}
470  	} else {
471  		if (errno != EINVAL) {
472  			pcap_fmt_errmsg_for_errno(ebuf, PCAP_ERRBUF_SIZE,
473  			    errno, "BIOCGDLTLIST");
474  			return (PCAP_ERROR);
475  		}
476  	}
477  	return (0);
478  }
479  #endif
480  #if defined(__APPLE__)
481  static int
482  pcap_can_set_rfmon_bpf(pcap_t *p)
483  {
484  	struct utsname osinfo;
485  	int fd;
486  #ifdef BIOCGDLTLIST
487  	struct bpf_dltlist bdl;
488  	int err;
489  #endif
490  	if (uname(&osinfo) == -1) {
491  		return (0);
492  	}
493  	if (osinfo.release[0] < '8' && osinfo.release[1] == '.') {
494  		return (0);
495  	}
496  	if (osinfo.release[0] == '8' && osinfo.release[1] == '.') {
497  		char *wlt_name;
498  		int status;
499  		if (strncmp(p->opt.device, "en", 2) != 0) {
500  			return (0);
501  		}
502  		fd = socket(AF_INET, SOCK_DGRAM, 0);
503  		if (fd == -1) {
504  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
505  			    errno, "socket");
506  			return (PCAP_ERROR);
507  		}
508  		if (pcap_asprintf(&wlt_name, "wlt%s", p->opt.device + 2) == -1) {
509  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
510  			    errno, "malloc");
511  			close(fd);
512  			return (PCAP_ERROR);
513  		}
514  		status = device_exists(fd, wlt_name, p->errbuf);
515  		free(wlt_name);
516  		close(fd);
517  		if (status != 0) {
518  			if (status == PCAP_ERROR_NO_SUCH_DEVICE)
519  				return (0);
520  			return (status);
521  		}
522  		return (1);
523  	}
524  #ifdef BIOCGDLTLIST
525  	fd = bpf_open(p->errbuf);
526  	if (fd < 0)
527  		return (fd);	&bsol;* fd is the appropriate error code */
<span onclick='openModal()' class='match'>528  	err = bpf_bind(fd, p->opt.device, p->errbuf);
529  	if (err != BPF_BIND_SUCCEEDED) {
</span>530  		close(fd);
531  		if (err == BPF_BIND_BUFFER_TOO_BIG) {
532  			return (PCAP_ERROR);
533  		}
534  		return (err);
535  	}
536  	if (get_dlt_list(fd, DLT_NULL, &bdl, p->errbuf) == PCAP_ERROR) {
537  		close(fd);
538  		return (PCAP_ERROR);
539  	}
540  	if (find_802_11(&bdl) != -1) {
541  		free(bdl.bfl_list);
542  		close(fd);
543  		return (1);
544  	}
545  	free(bdl.bfl_list);
546  	close(fd);
547  #endif &bsol;* BIOCGDLTLIST */
548  	return (0);
549  }
550  #elif defined(HAVE_BSD_IEEE80211)
551  static int
552  pcap_can_set_rfmon_bpf(pcap_t *p)
553  {
554  	int ret;
555  	ret = monitor_mode(p, 0);
556  	if (ret == PCAP_ERROR_RFMON_NOTSUP)
557  		return (0);	&bsol;* not an error, just a "can't do" */
558  	if (ret == 0)
559  		return (1);	&bsol;* success */
560  	return (ret);
561  }
562  #else
563  static int
564  pcap_can_set_rfmon_bpf(pcap_t *p _U_)
565  {
566  	return (0);
567  }
568  #endif
569  static int
570  pcap_stats_bpf(pcap_t *p, struct pcap_stat *ps)
571  {
572  	struct bpf_stat s;
573  	if (ioctl(p->fd, BIOCGSTATS, (caddr_t)&s) < 0) {
574  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
575  		    errno, "BIOCGSTATS");
576  		return (PCAP_ERROR);
577  	}
578  	ps->ps_recv = s.bs_recv;
579  	ps->ps_drop = s.bs_drop;
580  	ps->ps_ifdrop = 0;
581  	return (0);
582  }
583  static int
584  pcap_read_bpf(pcap_t *p, int cnt, pcap_handler callback, u_char *user)
585  {
586  	struct pcap_bpf *pb = p->priv;
587  	ssize_t cc;
588  	int n = 0;
589  	register u_char *bp, *ep;
590  	u_char *datap;
591  #ifdef PCAP_FDDIPAD
592  	register u_int pad;
593  #endif
594  #ifdef HAVE_ZEROCOPY_BPF
595  	int i;
596  #endif
597   again:
598  	if (p->break_loop) {
599  		p->break_loop = 0;
600  		return (PCAP_ERROR_BREAK);
601  	}
602  	cc = p->cc;
603  	if (p->cc == 0) {
604  #ifdef HAVE_ZEROCOPY_BPF
605  		if (pb->zerocopy) {
606  			if (p->buffer != NULL)
607  				pcap_ack_zbuf(p);
608  			i = pcap_next_zbuf(p, &cc);
609  			if (i == 0)
610  				goto again;
611  			if (i < 0)
612  				return (PCAP_ERROR);
613  		} else
614  #endif
615  		{
616  			cc = read(p->fd, p->buffer, p->bufsize);
617  		}
618  		if (cc < 0) {
619  			switch (errno) {
620  			case EINTR:
621  				goto again;
622  #ifdef _AIX
623  			case EFAULT:
624  				goto again;
625  #endif
626  			case EWOULDBLOCK:
627  				return (0);
628  			case ENXIO:	&bsol;* FreeBSD, DragonFly BSD, and Darwin */
629  			case EIO:	&bsol;* OpenBSD */
630  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
631  				    "The interface disappeared");
632  				return (PCAP_ERROR);
633  #if defined(sun) && !defined(BSD) && !defined(__svr4__) && !defined(__SVR4)
634  			case EINVAL:
635  				if (lseek(p->fd, 0L, SEEK_CUR) +
636  				    p->bufsize < 0) {
637  					(void)lseek(p->fd, 0L, SEEK_SET);
638  					goto again;
639  				}
640  #endif
641  			}
642  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
643  			    errno, "read");
644  			return (PCAP_ERROR);
645  		}
646  		bp = p->buffer;
647  	} else
648  		bp = p->bp;
649  #ifdef BIOCSTSTAMP
650  #define bhp ((struct bpf_xhdr *)bp)
651  #else
652  #define bhp ((struct bpf_hdr *)bp)
653  #endif
654  	ep = bp + cc;
655  #ifdef PCAP_FDDIPAD
656  	pad = p->fddipad;
657  #endif
658  	while (bp < ep) {
659  		register u_int caplen, hdrlen;
660  		if (p->break_loop) {
661  			p->bp = bp;
662  			p->cc = (int)(ep - bp);
663  			if (p->cc < 0)
664  				p->cc = 0;
665  			if (n == 0) {
666  				p->break_loop = 0;
667  				return (PCAP_ERROR_BREAK);
668  			} else
669  				return (n);
670  		}
671  		caplen = bhp->bh_caplen;
672  		hdrlen = bhp->bh_hdrlen;
673  		datap = bp + hdrlen;
674  		if (pb->filtering_in_kernel ||
675  		    pcap_filter(p->fcode.bf_insns, datap, bhp->bh_datalen, caplen)) {
676  			struct pcap_pkthdr pkthdr;
677  #ifdef BIOCSTSTAMP
678  			struct bintime bt;
679  			bt.sec = bhp->bh_tstamp.bt_sec;
680  			bt.frac = bhp->bh_tstamp.bt_frac;
681  			if (p->opt.tstamp_precision == PCAP_TSTAMP_PRECISION_NANO) {
682  				struct timespec ts;
683  				bintime2timespec(&bt, &ts);
684  				pkthdr.ts.tv_sec = ts.tv_sec;
685  				pkthdr.ts.tv_usec = ts.tv_nsec;
686  			} else {
687  				struct timeval tv;
688  				bintime2timeval(&bt, &tv);
689  				pkthdr.ts.tv_sec = tv.tv_sec;
690  				pkthdr.ts.tv_usec = tv.tv_usec;
691  			}
692  #else
693  			pkthdr.ts.tv_sec = bhp->bh_tstamp.tv_sec;
694  #ifdef _AIX
695  			pkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec/1000;
696  #else
697  			pkthdr.ts.tv_usec = bhp->bh_tstamp.tv_usec;
698  #endif
699  #endif &bsol;* BIOCSTSTAMP */
700  #ifdef PCAP_FDDIPAD
701  			if (caplen > pad)
702  				pkthdr.caplen = caplen - pad;
703  			else
704  				pkthdr.caplen = 0;
705  			if (bhp->bh_datalen > pad)
706  				pkthdr.len = bhp->bh_datalen - pad;
707  			else
708  				pkthdr.len = 0;
709  			datap += pad;
710  #else
711  			pkthdr.caplen = caplen;
712  			pkthdr.len = bhp->bh_datalen;
713  #endif
714  			(*callback)(user, &pkthdr, datap);
715  			bp += BPF_WORDALIGN(caplen + hdrlen);
716  			if (++n >= cnt && !PACKET_COUNT_IS_UNLIMITED(cnt)) {
717  				p->bp = bp;
718  				p->cc = (int)(ep - bp);
719  				if (p->cc < 0)
720  					p->cc = 0;
721  				return (n);
722  			}
723  		} else {
724  			bp += BPF_WORDALIGN(caplen + hdrlen);
725  		}
726  	}
727  #undef bhp
728  	p->cc = 0;
729  	return (n);
730  }
731  static int
732  pcap_inject_bpf(pcap_t *p, const void *buf, int size)
733  {
734  	int ret;
735  	ret = (int)write(p->fd, buf, size);
736  #ifdef __APPLE__
737  	if (ret == -1 && errno == EAFNOSUPPORT) {
738  		u_int spoof_eth_src = 0;
739  		if (ioctl(p->fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {
740  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
741  			    errno, "send: can't turn off BIOCSHDRCMPLT");
742  			return (PCAP_ERROR);
743  		}
744  		ret = (int)write(p->fd, buf, size);
745  	}
746  #endif &bsol;* __APPLE__ */
747  	if (ret == -1) {
748  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
749  		    errno, "send");
750  		return (PCAP_ERROR);
751  	}
752  	return (ret);
753  }
754  #ifdef _AIX
755  static int
756  bpf_odminit(char *errbuf)
757  {
758  	char *errstr;
759  	if (odm_initialize() == -1) {
760  		if (odm_err_msg(odmerrno, &errstr) == -1)
761  			errstr = "Unknown error";
762  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
763  		    "bpf_load: odm_initialize failed: %s",
764  		    errstr);
765  		return (PCAP_ERROR);
766  	}
767  	if ((odmlockid = odm_lock("/etc/objrepos/config_lock", ODM_WAIT)) == -1) {
768  		if (odm_err_msg(odmerrno, &errstr) == -1)
769  			errstr = "Unknown error";
770  		snprintf(errbuf, PCAP_ERRBUF_SIZE,
771  		    "bpf_load: odm_lock of /etc/objrepos/config_lock failed: %s",
772  		    errstr);
773  		(void)odm_terminate();
774  		return (PCAP_ERROR);
775  	}
776  	return (0);
777  }
778  static int
779  bpf_odmcleanup(char *errbuf)
780  {
781  	char *errstr;
782  	if (odm_unlock(odmlockid) == -1) {
783  		if (errbuf != NULL) {
784  			if (odm_err_msg(odmerrno, &errstr) == -1)
785  				errstr = "Unknown error";
786  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
787  			    "bpf_load: odm_unlock failed: %s",
788  			    errstr);
789  		}
790  		return (PCAP_ERROR);
791  	}
792  	if (odm_terminate() == -1) {
793  		if (errbuf != NULL) {
794  			if (odm_err_msg(odmerrno, &errstr) == -1)
795  				errstr = "Unknown error";
796  			snprintf(errbuf, PCAP_ERRBUF_SIZE,
797  			    "bpf_load: odm_terminate failed: %s",
798  			    errstr);
799  		}
800  		return (PCAP_ERROR);
801  	}
802  	return (0);
803  }
804  static int
805  bpf_load(char *errbuf)
806  {
807  	long major;
808  	int *minors;
809  	int numminors, i, rc;
810  	char buf[1024];
811  	struct stat sbuf;
812  	struct bpf_config cfg_bpf;
813  	struct cfg_load cfg_ld;
814  	struct cfg_kmod cfg_km;
815  	if (bpfloadedflag)
816  		return (0);
817  	if (bpf_odminit(errbuf) == PCAP_ERROR)
818  		return (PCAP_ERROR);
819  	major = genmajor(BPF_NAME);
820  	if (major == -1) {
821  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
822  		    errno, "bpf_load: genmajor failed");
823  		(void)bpf_odmcleanup(NULL);
824  		return (PCAP_ERROR);
825  	}
826  	minors = getminor(major, &numminors, BPF_NAME);
827  	if (!minors) {
828  		minors = genminor("bpf", major, 0, BPF_MINORS, 1, 1);
829  		if (!minors) {
830  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
831  			    errno, "bpf_load: genminor failed");
832  			(void)bpf_odmcleanup(NULL);
833  			return (PCAP_ERROR);
834  		}
835  	}
836  	if (bpf_odmcleanup(errbuf) == PCAP_ERROR)
837  		return (PCAP_ERROR);
838  	rc = stat(BPF_NODE "0", &sbuf);
839  	if (rc == -1 && errno != ENOENT) {
840  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
841  		    errno, "bpf_load: can't stat %s", BPF_NODE "0");
842  		return (PCAP_ERROR);
843  	}
844  	if (rc == -1 || getmajor(sbuf.st_rdev) != major) {
845  		for (i = 0; i < BPF_MINORS; i++) {
846  			snprintf(buf, sizeof(buf), "%s%d", BPF_NODE, i);
847  			unlink(buf);
848  			if (mknod(buf, S_IRUSR | S_IFCHR, domakedev(major, i)) == -1) {
849  				pcap_fmt_errmsg_for_errno(errbuf,
850  				    PCAP_ERRBUF_SIZE, errno,
851  				    "bpf_load: can't mknod %s", buf);
852  				return (PCAP_ERROR);
853  			}
854  		}
855  	}
856  	memset(&cfg_ld, 0x0, sizeof(cfg_ld));
857  	snprintf(buf, sizeof(buf), "%s/%s", DRIVER_PATH, BPF_NAME);
858  	cfg_ld.path = buf;
859  	if ((sysconfig(SYS_QUERYLOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) ||
860  	    (cfg_ld.kmid == 0)) {
861  		if (sysconfig(SYS_SINGLELOAD, (void *)&cfg_ld, sizeof(cfg_ld)) == -1) {
862  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
863  			    errno, "bpf_load: could not load driver");
864  			return (PCAP_ERROR);
865  		}
866  	}
867  	cfg_km.cmd = CFG_INIT;
868  	cfg_km.kmid = cfg_ld.kmid;
869  	cfg_km.mdilen = sizeof(cfg_bpf);
870  	cfg_km.mdiptr = (void *)&cfg_bpf;
871  	for (i = 0; i < BPF_MINORS; i++) {
872  		cfg_bpf.devno = domakedev(major, i);
873  		if (sysconfig(SYS_CFGKMOD, (void *)&cfg_km, sizeof(cfg_km)) == -1) {
874  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
875  			    errno, "bpf_load: could not configure driver");
876  			return (PCAP_ERROR);
877  		}
878  	}
879  	bpfloadedflag = 1;
880  	return (0);
881  }
882  #endif
883  static void
884  pcap_cleanup_bpf(pcap_t *p)
885  {
886  	struct pcap_bpf *pb = p->priv;
887  #ifdef HAVE_BSD_IEEE80211
888  	int sock;
889  	struct ifmediareq req;
890  	struct ifreq ifr;
891  #endif
892  	if (pb->must_do_on_close != 0) {
893  #ifdef HAVE_BSD_IEEE80211
894  		if (pb->must_do_on_close & MUST_CLEAR_RFMON) {
895  			sock = socket(AF_INET, SOCK_DGRAM, 0);
896  			if (sock == -1) {
897  				fprintf(stderr,
898  				    "Can't restore interface flags (socket() failed: %s).\n"
899  				    "Please adjust manually.\n",
900  				    strerror(errno));
901  			} else {
902  				memset(&req, 0, sizeof(req));
903  				pcap_strlcpy(req.ifm_name, pb->device,
904  				    sizeof(req.ifm_name));
905  				if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
906  					fprintf(stderr,
907  					    "Can't restore interface flags (SIOCGIFMEDIA failed: %s).\n"
908  					    "Please adjust manually.\n",
909  					    strerror(errno));
910  				} else {
911  					if (req.ifm_current & IFM_IEEE80211_MONITOR) {
912  						memset(&ifr, 0, sizeof(ifr));
913  						(void)pcap_strlcpy(ifr.ifr_name,
914  						    pb->device,
915  						    sizeof(ifr.ifr_name));
916  						ifr.ifr_media =
917  						    req.ifm_current & ~IFM_IEEE80211_MONITOR;
918  						if (ioctl(sock, SIOCSIFMEDIA,
919  						    &ifr) == -1) {
920  							fprintf(stderr,
921  							    "Can't restore interface flags (SIOCSIFMEDIA failed: %s).\n"
922  							    "Please adjust manually.\n",
923  							    strerror(errno));
924  						}
925  					}
926  				}
927  				close(sock);
928  			}
929  		}
930  #endif &bsol;* HAVE_BSD_IEEE80211 */
931  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
932  		if (pb->must_do_on_close & MUST_DESTROY_USBUS) {
933  			if (if_nametoindex(pb->device) > 0) {
934  				int s;
935  				s = socket(AF_LOCAL, SOCK_DGRAM, 0);
936  				if (s >= 0) {
937  					pcap_strlcpy(ifr.ifr_name, pb->device,
938  					    sizeof(ifr.ifr_name));
939  					ioctl(s, SIOCIFDESTROY, &ifr);
940  					close(s);
941  				}
942  			}
943  		}
944  #endif &bsol;* defined(__FreeBSD__) && defined(SIOCIFCREATE2) */
945  		pcap_remove_from_pcaps_to_close(p);
946  		pb->must_do_on_close = 0;
947  	}
948  #ifdef HAVE_ZEROCOPY_BPF
949  	if (pb->zerocopy) {
950  		if (pb->zbuf1 != MAP_FAILED && pb->zbuf1 != NULL)
951  			(void) munmap(pb->zbuf1, pb->zbufsize);
952  		if (pb->zbuf2 != MAP_FAILED && pb->zbuf2 != NULL)
953  			(void) munmap(pb->zbuf2, pb->zbufsize);
954  		p->buffer = NULL;
955  	}
956  #endif
957  	if (pb->device != NULL) {
958  		free(pb->device);
959  		pb->device = NULL;
960  	}
961  	pcap_cleanup_live_common(p);
962  }
963  #ifdef __APPLE__
964  static int
965  check_setif_failure(pcap_t *p, int error)
966  {
967  	int fd;
968  	int err;
969  	if (error == PCAP_ERROR_NO_SUCH_DEVICE) {
970  		if (p->opt.rfmon && strncmp(p->opt.device, "wlt", 3) == 0) {
971  			fd = socket(AF_INET, SOCK_DGRAM, 0);
972  			if (fd != -1) {
973  				char *en_name;
974  				if (pcap_asprintf(&en_name, "en%s",
975  				    p->opt.device + 3) == -1) {
976  					pcap_fmt_errmsg_for_errno(p->errbuf,
977  					    PCAP_ERRBUF_SIZE, errno,
978  					    "malloc");
979  					close(fd);
980  					return (PCAP_ERROR_NO_SUCH_DEVICE);
981  				}
982  				err = device_exists(fd, en_name, p->errbuf);
983  				free(en_name);
984  				if (err != 0) {
985  					if (err == PCAP_ERROR_NO_SUCH_DEVICE) {
986  						err = PCAP_ERROR_RFMON_NOTSUP;
987  					}
988  				}
989  				close(fd);
990  			} else {
991  				err = PCAP_ERROR_NO_SUCH_DEVICE;
992  				pcap_fmt_errmsg_for_errno(p->errbuf,
993  				    errno, PCAP_ERRBUF_SIZE,
994  				    "socket() failed");
995  			}
996  			return (err);
997  		}
998  		return (PCAP_ERROR_NO_SUCH_DEVICE);
999  	}
1000  	return (error);
1001  }
1002  #else
1003  static int
1004  check_setif_failure(pcap_t *p _U_, int error)
1005  {
1006  	return (error);
1007  }
1008  #endif
1009  #ifdef _AIX
1010  #define DEFAULT_BUFSIZE	32768
1011  #else
1012  #define DEFAULT_BUFSIZE	524288
1013  #endif
1014  static int
1015  pcap_activate_bpf(pcap_t *p)
1016  {
1017  	struct pcap_bpf *pb = p->priv;
1018  	int status = 0;
1019  #ifdef HAVE_BSD_IEEE80211
1020  	int retv;
1021  #endif
1022  	int fd;
1023  #if defined(LIFNAMSIZ) && defined(ZONENAME_MAX) && defined(lifr_zoneid)
1024  	struct lifreq ifr;
1025  	char *zonesep;
1026  #endif
1027  	struct bpf_version bv;
1028  #ifdef __APPLE__
1029  	int sockfd;
1030  	char *wltdev = NULL;
1031  #endif
1032  #ifdef BIOCGDLTLIST
1033  	struct bpf_dltlist bdl;
1034  #if defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)
1035  	int new_dlt;
1036  #endif
1037  #endif &bsol;* BIOCGDLTLIST */
1038  #if defined(BIOCGHDRCMPLT) && defined(BIOCSHDRCMPLT)
1039  	u_int spoof_eth_src = 1;
1040  #endif
1041  	u_int v;
1042  	struct bpf_insn total_insn;
1043  	struct bpf_program total_prog;
1044  	struct utsname osinfo;
1045  	int have_osinfo = 0;
1046  #ifdef HAVE_ZEROCOPY_BPF
1047  	struct bpf_zbuf bz;
1048  	u_int bufmode, zbufmax;
1049  	int flags = MAP_ANON;
1050  #endif
1051  	fd = bpf_open(p->errbuf);
1052  	if (fd < 0) {
1053  		status = fd;
1054  		goto bad;
1055  	}
1056  	p->fd = fd;
1057  	if (ioctl(fd, BIOCVERSION, (caddr_t)&bv) < 0) {
1058  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1059  		    errno, "BIOCVERSION");
1060  		status = PCAP_ERROR;
1061  		goto bad;
1062  	}
1063  	if (bv.bv_major != BPF_MAJOR_VERSION ||
1064  	    bv.bv_minor < BPF_MINOR_VERSION) {
1065  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1066  		    "kernel bpf filter out of date");
1067  		status = PCAP_ERROR;
1068  		goto bad;
1069  	}
1070  	if (p->snapshot <= 0 || p->snapshot > MAXIMUM_SNAPLEN)
1071  		p->snapshot = MAXIMUM_SNAPLEN;
1072  #if defined(LIFNAMSIZ) && defined(ZONENAME_MAX) && defined(lifr_zoneid)
1073  	if ((ifr.lifr_zoneid = getzoneid()) == -1) {
1074  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1075  		    errno, "getzoneid()");
1076  		status = PCAP_ERROR;
1077  		goto bad;
1078  	}
1079  	if ((zonesep = strchr(p->opt.device, '/')) != NULL) {
1080  		char path_zname[ZONENAME_MAX];
1081  		int  znamelen;
1082  		char *lnamep;
1083  		if (ifr.lifr_zoneid != GLOBAL_ZONEID) {
1084  			snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1085  			    "zonename/linkname only valid in global zone.");
1086  			status = PCAP_ERROR;
1087  			goto bad;
1088  		}
1089  		znamelen = zonesep - p->opt.device;
1090  		(void) pcap_strlcpy(path_zname, p->opt.device, znamelen + 1);
1091  		ifr.lifr_zoneid = getzoneidbyname(path_zname);
1092  		if (ifr.lifr_zoneid == -1) {
1093  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1094  			    errno, "getzoneidbyname(%s)", path_zname);
1095  			status = PCAP_ERROR;
1096  			goto bad;
1097  		}
1098  		lnamep = strdup(zonesep + 1);
1099  		if (lnamep == NULL) {
1100  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1101  			    errno, "strdup");
1102  			status = PCAP_ERROR;
1103  			goto bad;
1104  		}
1105  		free(p->opt.device);
1106  		p->opt.device = lnamep;
1107  	}
1108  #endif
1109  	pb->device = strdup(p->opt.device);
1110  	if (pb->device == NULL) {
1111  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1112  		    errno, "strdup");
1113  		status = PCAP_ERROR;
1114  		goto bad;
1115  	}
1116  	if (uname(&osinfo) == 0)
1117  		have_osinfo = 1;
1118  #ifdef __APPLE__
1119  	if (p->opt.rfmon) {
1120  		if (have_osinfo) {
1121  			if (osinfo.release[0] < '8' &&
1122  			    osinfo.release[1] == '.') {
1123  				status = PCAP_ERROR_RFMON_NOTSUP;
1124  				goto bad;
1125  			}
1126  			if (osinfo.release[0] == '8' &&
1127  			    osinfo.release[1] == '.') {
1128  				if (strncmp(p->opt.device, "en", 2) != 0) {
1129  					sockfd = socket(AF_INET, SOCK_DGRAM, 0);
1130  					if (sockfd != -1) {
1131  						status = device_exists(sockfd,
1132  						    p->opt.device, p->errbuf);
1133  						if (status == 0) {
1134  							status = PCAP_ERROR_RFMON_NOTSUP;
1135  						}
1136  						close(sockfd);
1137  					} else {
1138  						status = PCAP_ERROR_NO_SUCH_DEVICE;
1139  						pcap_fmt_errmsg_for_errno(p->errbuf,
1140  						    PCAP_ERRBUF_SIZE, errno,
1141  						    "socket() failed");
1142  					}
1143  					goto bad;
1144  				}
1145  				wltdev = malloc(strlen(p->opt.device) + 2);
1146  				if (wltdev == NULL) {
1147  					pcap_fmt_errmsg_for_errno(p->errbuf,
1148  					    PCAP_ERRBUF_SIZE, errno,
1149  					    "malloc");
1150  					status = PCAP_ERROR;
1151  					goto bad;
1152  				}
1153  				strcpy(wltdev, "wlt");
1154  				strcat(wltdev, p->opt.device + 2);
1155  				free(p->opt.device);
1156  				p->opt.device = wltdev;
1157  			}
1158  		}
1159  	}
1160  #endif &bsol;* __APPLE__ */
1161  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
1162  	if (strncmp(p->opt.device, usbus_prefix, USBUS_PREFIX_LEN) == 0) {
1163  		if (if_nametoindex(p->opt.device) == 0) {
1164  			int s;
1165  			struct ifreq ifr;
1166  			s = socket(AF_LOCAL, SOCK_DGRAM, 0);
1167  			if (s < 0) {
1168  				pcap_fmt_errmsg_for_errno(p->errbuf,
1169  				    PCAP_ERRBUF_SIZE, errno,
1170  				    "Can't open socket");
1171  				status = PCAP_ERROR;
1172  				goto bad;
1173  			}
1174  			if (!pcap_do_addexit(p)) {
1175  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1176  				     "atexit failed");
1177  				close(s);
1178  				status = PCAP_ERROR;
1179  				goto bad;
1180  			}
1181  			pcap_strlcpy(ifr.ifr_name, p->opt.device, sizeof(ifr.ifr_name));
1182  			if (ioctl(s, SIOCIFCREATE2, &ifr) < 0) {
1183  				if (errno == EINVAL) {
1184  					snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1185  					    "Invalid USB bus interface %s",
1186  					    p->opt.device);
1187  				} else {
1188  					pcap_fmt_errmsg_for_errno(p->errbuf,
1189  					    PCAP_ERRBUF_SIZE, errno,
1190  					    "Can't create interface for %s",
1191  					    p->opt.device);
1192  				}
1193  				close(s);
1194  				status = PCAP_ERROR;
1195  				goto bad;
1196  			}
1197  			pb->must_do_on_close |= MUST_DESTROY_USBUS;
1198  			pcap_add_to_pcaps_to_close(p);
1199  		}
1200  	}
1201  #endif &bsol;* defined(__FreeBSD__) && defined(SIOCIFCREATE2) */
1202  #ifdef HAVE_ZEROCOPY_BPF
1203  	bufmode = BPF_BUFMODE_ZBUF;
1204  	if (ioctl(fd, BIOCSETBUFMODE, (caddr_t)&bufmode) == 0) {
1205  		pb->zerocopy = 1;
1206  		if (ioctl(fd, BIOCGETZMAX, (caddr_t)&zbufmax) < 0) {
1207  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1208  			    errno, "BIOCGETZMAX");
1209  			status = PCAP_ERROR;
1210  			goto bad;
1211  		}
1212  		if (p->opt.buffer_size != 0) {
1213  			v = p->opt.buffer_size;
1214  		} else {
1215  			if ((ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) ||
1216  			    v < DEFAULT_BUFSIZE)
1217  				v = DEFAULT_BUFSIZE;
1218  		}
1219  #ifndef roundup
1220  #define roundup(x, y)   ((((x)+((y)-1))/(y))*(y))  &bsol;* to any y */
1221  #endif
1222  		pb->zbufsize = roundup(v, getpagesize());
1223  		if (pb->zbufsize > zbufmax)
1224  			pb->zbufsize = zbufmax;
1225  #ifdef MAP_32BIT
1226  		if (pcap_mmap_32bit) flags |= MAP_32BIT;
1227  #endif
1228  		pb->zbuf1 = mmap(NULL, pb->zbufsize, PROT_READ | PROT_WRITE,
1229  		    flags, -1, 0);
1230  		pb->zbuf2 = mmap(NULL, pb->zbufsize, PROT_READ | PROT_WRITE,
1231  		    flags, -1, 0);
1232  		if (pb->zbuf1 == MAP_FAILED || pb->zbuf2 == MAP_FAILED) {
1233  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1234  			    errno, "mmap");
1235  			status = PCAP_ERROR;
1236  			goto bad;
1237  		}
1238  		memset(&bz, 0, sizeof(bz)); &bsol;* bzero() deprecated, replaced with memset() */
1239  		bz.bz_bufa = pb->zbuf1;
1240  		bz.bz_bufb = pb->zbuf2;
1241  		bz.bz_buflen = pb->zbufsize;
1242  		if (ioctl(fd, BIOCSETZBUF, (caddr_t)&bz) < 0) {
1243  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1244  			    errno, "BIOCSETZBUF");
1245  			status = PCAP_ERROR;
1246  			goto bad;
1247  		}
1248  		status = bpf_bind(fd, p->opt.device, ifnamsiz, p->errbuf);
1249  		if (status != BPF_BIND_SUCCEEDED) {
1250  			if (status == BPF_BIND_BUFFER_TOO_BIG) {
1251  				status = PCAP_ERROR;
1252  			}
1253  			goto bad;
1254  		}
1255  		v = pb->zbufsize - sizeof(struct bpf_zbuf_header);
1256  	} else
1257  #endif
1258  	{
1259  		if (p->opt.buffer_size != 0) {
1260  			if (ioctl(fd, BIOCSBLEN,
1261  			    (caddr_t)&p->opt.buffer_size) < 0) {
1262  				pcap_fmt_errmsg_for_errno(p->errbuf,
1263  				    PCAP_ERRBUF_SIZE, errno,
1264  				    "BIOCSBLEN: %s", p->opt.device);
1265  				status = PCAP_ERROR;
1266  				goto bad;
1267  			}
1268  			status = bpf_bind(fd, p->opt.device, p->errbuf);
1269  			if (status != BPF_BIND_SUCCEEDED) {
1270  				if (status == BPF_BIND_BUFFER_TOO_BIG) {
1271  					status = PCAP_ERROR;
1272  					goto bad;
1273  				}
1274  				status = check_setif_failure(p, status);
1275  				goto bad;
1276  			}
1277  		} else {
1278  			if ((ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) ||
1279  			    v < DEFAULT_BUFSIZE)
1280  				v = DEFAULT_BUFSIZE;
1281  			for ( ; v != 0; v >>= 1) {
1282  				(void) ioctl(fd, BIOCSBLEN, (caddr_t)&v);
1283  				status = bpf_bind(fd, p->opt.device, p->errbuf);
1284  				if (status == BPF_BIND_SUCCEEDED)
1285  					break;	&bsol;* that size worked; we're done */
1286  				if (status != BPF_BIND_BUFFER_TOO_BIG) {
1287  					status = check_setif_failure(p, status);
1288  					goto bad;
1289  				}
1290  			}
1291  			if (v == 0) {
1292  				snprintf(p->errbuf, PCAP_ERRBUF_SIZE,
1293  				    "BIOCSBLEN: %s: No buffer size worked",
1294  				    p->opt.device);
1295  				status = PCAP_ERROR;
1296  				goto bad;
1297  			}
1298  		}
1299  	}
1300  	if (ioctl(fd, BIOCGDLT, (caddr_t)&v) < 0) {
1301  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1302  		    errno, "BIOCGDLT");
1303  		status = PCAP_ERROR;
1304  		goto bad;
1305  	}
1306  #ifdef _AIX
1307  	switch (v) {
1308  	case IFT_ETHER:
1309  	case IFT_ISO88023:
1310  		v = DLT_EN10MB;
1311  		break;
1312  	case IFT_FDDI:
1313  		v = DLT_FDDI;
1314  		break;
1315  	case IFT_ISO88025:
1316  		v = DLT_IEEE802;
1317  		break;
1318  	case IFT_LOOP:
1319  		v = DLT_NULL;
1320  		break;
1321  	default:
1322  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "unknown interface type %u",
1323  		    v);
1324  		status = PCAP_ERROR;
1325  		goto bad;
1326  	}
1327  #endif
1328  #if _BSDI_VERSION - 0 >= 199510
1329  	switch (v) {
1330  	case DLT_SLIP:
1331  		v = DLT_SLIP_BSDOS;
1332  		break;
1333  	case DLT_PPP:
1334  		v = DLT_PPP_BSDOS;
1335  		break;
1336  	case 11:	&bsol;*DLT_FR*/
1337  		v = DLT_FRELAY;
1338  		break;
1339  	case 12:	&bsol;*DLT_C_HDLC*/
1340  		v = DLT_CHDLC;
1341  		break;
1342  	}
1343  #endif
1344  #ifdef BIOCGDLTLIST
1345  	if (get_dlt_list(fd, v, &bdl, p->errbuf) == -1) {
1346  		status = PCAP_ERROR;
1347  		goto bad;
1348  	}
1349  	p->dlt_count = bdl.bfl_len;
1350  	p->dlt_list = bdl.bfl_list;
1351  #ifdef __APPLE__
1352  	if (have_osinfo) {
1353  		if (PCAP_ISDIGIT((unsigned)osinfo.release[0]) &&
1354  		     (osinfo.release[0] == '9' ||
1355  		     PCAP_ISDIGIT((unsigned)osinfo.release[1]))) {
1356  			new_dlt = find_802_11(&bdl);
1357  			if (new_dlt != -1) {
1358  				if (p->opt.rfmon) {
1359  					remove_non_802_11(p);
1360  					if ((u_int)new_dlt != v) {
1361  						if (ioctl(p->fd, BIOCSDLT,
1362  						    &new_dlt) != -1) {
1363  							v = new_dlt;
1364  						}
1365  					}
1366  				} else {
1367  					if (!p->oldstyle)
1368  						remove_802_11(p);
1369  				}
1370  			} else {
1371  				if (p->opt.rfmon) {
1372  					status = PCAP_ERROR_RFMON_NOTSUP;
1373  					goto bad;
1374  				}
1375  			}
1376  		}
1377  	}
1378  #elif defined(HAVE_BSD_IEEE80211)
1379  	if (p->opt.rfmon) {
1380  		retv = monitor_mode(p, 1);
1381  		if (retv != 0) {
1382  			status = retv;
1383  			goto bad;
1384  		}
1385  		new_dlt = find_802_11(&bdl);
1386  		if (new_dlt != -1) {
1387  			if ((u_int)new_dlt != v) {
1388  				if (ioctl(p->fd, BIOCSDLT, &new_dlt) != -1) {
1389  					v = new_dlt;
1390  				}
1391  			}
1392  		}
1393  	}
1394  #endif &bsol;* various platforms */
1395  #endif &bsol;* BIOCGDLTLIST */
1396  	if (v == DLT_EN10MB && p->dlt_count == 0) {
1397  		p->dlt_list = (u_int *) malloc(sizeof(u_int) * 2);
1398  		if (p->dlt_list == NULL) {
1399  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1400  			    errno, "malloc");
1401  			status = PCAP_ERROR;
1402  			goto bad;
1403  		}
1404  		p->dlt_list[0] = DLT_EN10MB;
1405  		p->dlt_list[1] = DLT_DOCSIS;
1406  		p->dlt_count = 2;
1407  	}
1408  #ifdef PCAP_FDDIPAD
1409  	if (v == DLT_FDDI)
1410  		p->fddipad = PCAP_FDDIPAD;
1411  	else
1412  #endif
1413  		p->fddipad = 0;
1414  	p->linktype = v;
1415  #if defined(BIOCGHDRCMPLT) && defined(BIOCSHDRCMPLT)
1416  	if (ioctl(fd, BIOCSHDRCMPLT, &spoof_eth_src) == -1) {
1417  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1418  		    errno, "BIOCSHDRCMPLT");
1419  		status = PCAP_ERROR;
1420  		goto bad;
1421  	}
1422  #endif
1423  #ifdef HAVE_ZEROCOPY_BPF
1424  	if (p->opt.timeout && !pb->zerocopy) {
1425  #else
1426  	if (p->opt.timeout) {
1427  #endif
1428  		struct timeval to;
1429  #ifdef HAVE_STRUCT_BPF_TIMEVAL
1430  		struct BPF_TIMEVAL bpf_to;
1431  		if (IOCPARM_LEN(BIOCSRTIMEOUT) != sizeof(struct timeval)) {
1432  			bpf_to.tv_sec = p->opt.timeout / 1000;
1433  			bpf_to.tv_usec = (p->opt.timeout * 1000) % 1000000;
1434  			if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&bpf_to) < 0) {
1435  				pcap_fmt_errmsg_for_errno(p->errbuf,
1436  				    errno, PCAP_ERRBUF_SIZE, "BIOCSRTIMEOUT");
1437  				status = PCAP_ERROR;
1438  				goto bad;
1439  			}
1440  		} else {
1441  #endif
1442  			to.tv_sec = p->opt.timeout / 1000;
1443  			to.tv_usec = (p->opt.timeout * 1000) % 1000000;
1444  			if (ioctl(p->fd, BIOCSRTIMEOUT, (caddr_t)&to) < 0) {
1445  				pcap_fmt_errmsg_for_errno(p->errbuf,
1446  				    errno, PCAP_ERRBUF_SIZE, "BIOCSRTIMEOUT");
1447  				status = PCAP_ERROR;
1448  				goto bad;
1449  			}
1450  #ifdef HAVE_STRUCT_BPF_TIMEVAL
1451  		}
1452  #endif
1453  	}
1454  #ifdef	BIOCIMMEDIATE
1455  #ifndef _AIX
1456  	if (p->opt.immediate) {
1457  #endif &bsol;* _AIX */
1458  		v = 1;
1459  		if (ioctl(p->fd, BIOCIMMEDIATE, &v) < 0) {
1460  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1461  			    errno, "BIOCIMMEDIATE");
1462  			status = PCAP_ERROR;
1463  			goto bad;
1464  		}
1465  #ifndef _AIX
1466  	}
1467  #endif &bsol;* _AIX */
1468  #else &bsol;* BIOCIMMEDIATE */
1469  	if (p->opt.immediate) {
1470  		snprintf(p->errbuf, PCAP_ERRBUF_SIZE, "Immediate mode not supported");
1471  		status = PCAP_ERROR;
1472  		goto bad;
1473  	}
1474  #endif &bsol;* BIOCIMMEDIATE */
1475  	if (p->opt.promisc) {
1476  		if (ioctl(p->fd, BIOCPROMISC, NULL) < 0) {
1477  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1478  			    errno, "BIOCPROMISC");
1479  			status = PCAP_WARNING_PROMISC_NOTSUP;
1480  		}
1481  	}
1482  #ifdef BIOCSTSTAMP
1483  	v = BPF_T_BINTIME;
1484  	if (ioctl(p->fd, BIOCSTSTAMP, &v) < 0) {
1485  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1486  		    errno, "BIOCSTSTAMP");
1487  		status = PCAP_ERROR;
1488  		goto bad;
1489  	}
1490  #endif &bsol;* BIOCSTSTAMP */
1491  	if (ioctl(fd, BIOCGBLEN, (caddr_t)&v) < 0) {
1492  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1493  		    errno, "BIOCGBLEN");
1494  		status = PCAP_ERROR;
1495  		goto bad;
1496  	}
1497  	p->bufsize = v;
1498  #ifdef HAVE_ZEROCOPY_BPF
1499  	if (!pb->zerocopy) {
1500  #endif
1501  	p->buffer = malloc(p->bufsize);
1502  	if (p->buffer == NULL) {
1503  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1504  		    errno, "malloc");
1505  		status = PCAP_ERROR;
1506  		goto bad;
1507  	}
1508  #ifdef _AIX
1509  	memset(p->buffer, 0x0, p->bufsize);
1510  #endif
1511  #ifdef HAVE_ZEROCOPY_BPF
1512  	}
1513  #endif
1514  	total_insn.code = (u_short)(BPF_RET | BPF_K);
1515  	total_insn.jt = 0;
1516  	total_insn.jf = 0;
1517  	total_insn.k = p->snapshot;
1518  	total_prog.bf_len = 1;
1519  	total_prog.bf_insns = &total_insn;
1520  	if (ioctl(p->fd, BIOCSETF, (caddr_t)&total_prog) < 0) {
1521  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1522  		    errno, "BIOCSETF");
1523  		status = PCAP_ERROR;
1524  		goto bad;
1525  	}
1526  	p->selectable_fd = p->fd;	&bsol;* assume select() works until we know otherwise */
1527  	if (have_osinfo) {
1528  		if (strcmp(osinfo.sysname, "FreeBSD") == 0) {
1529  			if (strncmp(osinfo.release, "4.3-", 4) == 0 ||
1530  			     strncmp(osinfo.release, "4.4-", 4) == 0)
1531  				p->selectable_fd = -1;
1532  		}
1533  	}
1534  	p->read_op = pcap_read_bpf;
1535  	p->inject_op = pcap_inject_bpf;
1536  	p->setfilter_op = pcap_setfilter_bpf;
1537  	p->setdirection_op = pcap_setdirection_bpf;
1538  	p->set_datalink_op = pcap_set_datalink_bpf;
1539  	p->getnonblock_op = pcap_getnonblock_bpf;
1540  	p->setnonblock_op = pcap_setnonblock_bpf;
1541  	p->stats_op = pcap_stats_bpf;
1542  	p->cleanup_op = pcap_cleanup_bpf;
1543  	return (status);
1544   bad:
1545  	pcap_cleanup_bpf(p);
1546  	return (status);
1547  }
1548  static int
1549  check_bpf_bindable(const char *name)
1550  {
1551  	int fd;
1552  	char errbuf[PCAP_ERRBUF_SIZE];
1553  #ifdef __APPLE__
1554  	if (strncmp(name, "wlt", 3) == 0) {
1555  		char *en_name;
1556  		size_t en_name_len;
1557  		en_name_len = strlen(name) - 1;
1558  		en_name = malloc(en_name_len + 1);
1559  		if (en_name == NULL) {
1560  			pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
1561  			    errno, "malloc");
1562  			return (-1);
1563  		}
1564  		strcpy(en_name, "en");
1565  		strcat(en_name, name + 3);
1566  		fd = bpf_open_and_bind(en_name, errbuf);
1567  		free(en_name);
1568  	} else
1569  #endif &bsol;* __APPLE */
1570  	fd = bpf_open_and_bind(name, errbuf);
1571  	if (fd < 0) {
1572  		if (fd == PCAP_ERROR_NO_SUCH_DEVICE) {
1573  			return (0);
1574  		}
1575  		return (1);
1576  	}
1577  	close(fd);
1578  	return (1);
1579  }
1580  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
1581  static int
1582  get_usb_if_flags(const char *name _U_, bpf_u_int32 *flags _U_, char *errbuf _U_)
1583  {
1584  	return (0);
1585  }
1586  static int
1587  finddevs_usb(pcap_if_list_t *devlistp, char *errbuf)
1588  {
1589  	DIR *usbdir;
1590  	struct dirent *usbitem;
1591  	size_t name_max;
1592  	char *name;
1593  	usbdir = opendir("/dev/usb");
1594  	if (usbdir == NULL) {
1595  		return (0);
1596  	}
1597  	name_max = USBUS_PREFIX_LEN + 10 + 1;
1598  	name = malloc(name_max);
1599  	if (name == NULL) {
1600  		closedir(usbdir);
1601  		return (0);
1602  	}
1603  	while ((usbitem = readdir(usbdir)) != NULL) {
1604  		char *p;
1605  		size_t busnumlen;
1606  		if (strcmp(usbitem->d_name, ".") == 0 ||
1607  		    strcmp(usbitem->d_name, "..") == 0) {
1608  			continue;
1609  		}
1610  		p = strchr(usbitem->d_name, '.');
1611  		if (p == NULL)
1612  			continue;
1613  		busnumlen = p - usbitem->d_name;
1614  		memcpy(name, usbus_prefix, USBUS_PREFIX_LEN);
1615  		memcpy(name + USBUS_PREFIX_LEN, usbitem->d_name, busnumlen);
1616  		*(name + USBUS_PREFIX_LEN + busnumlen) = '\0';
1617  		if (pcap_find_or_add_dev(devlistp, name, PCAP_IF_UP,
1618  		    get_usb_if_flags, NULL, errbuf) == NULL) {
1619  			free(name);
1620  			closedir(usbdir);
1621  			return (PCAP_ERROR);
1622  		}
1623  	}
1624  	free(name);
1625  	closedir(usbdir);
1626  	return (0);
1627  }
1628  #endif
1629  #ifdef SIOCGIFMEDIA
1630  static int
1631  get_if_flags(const char *name, bpf_u_int32 *flags, char *errbuf)
1632  {
1633  	int sock;
1634  	struct ifmediareq req;
1635  	sock = socket(AF_INET, SOCK_DGRAM, 0);
1636  	if (sock == -1) {
1637  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
1638  		    "Can't create socket to get media information for %s",
1639  		    name);
1640  		return (-1);
1641  	}
1642  	memset(&req, 0, sizeof(req));
1643  	pcap_strlcpy(req.ifm_name, name, sizeof(req.ifm_name));
1644  	if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
1645  		if (errno == EOPNOTSUPP || errno == EINVAL || errno == ENOTTY ||
1646  		    errno == ENODEV || errno == EPERM
1647  #ifdef EPWROFF
1648  		    || errno == EPWROFF
1649  #endif
1650  		    ) {
1651  			*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
1652  			close(sock);
1653  			return (0);
1654  		}
1655  		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE, errno,
1656  		    "SIOCGIFMEDIA on %s failed", name);
1657  		close(sock);
1658  		return (-1);
1659  	}
1660  	close(sock);
1661  	switch (IFM_TYPE(req.ifm_active)) {
1662  	case IFM_IEEE80211:
1663  		*flags |= PCAP_IF_WIRELESS;
1664  		break;
1665  	}
1666  	if (req.ifm_status & IFM_AVALID) {
1667  		if (req.ifm_status & IFM_ACTIVE) {
1668  			*flags |= PCAP_IF_CONNECTION_STATUS_CONNECTED;
1669  		} else {
1670  			*flags |= PCAP_IF_CONNECTION_STATUS_DISCONNECTED;
1671  		}
1672  	}
1673  	return (0);
1674  }
1675  #else
1676  static int
1677  get_if_flags(const char *name _U_, bpf_u_int32 *flags, char *errbuf _U_)
1678  {
1679  	if (*flags & PCAP_IF_LOOPBACK) {
1680  		*flags |= PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE;
1681  		return (0);
1682  	}
1683  	return (0);
1684  }
1685  #endif
1686  int
1687  pcap_platform_finddevs(pcap_if_list_t *devlistp, char *errbuf)
1688  {
1689  	if (pcap_findalldevs_interfaces(devlistp, errbuf, check_bpf_bindable,
1690  	    get_if_flags) == -1)
1691  		return (-1);	&bsol;* failure */
1692  #if defined(HAVE_SOLARIS_ANY_DEVICE)
1693  	if (pcap_add_any_dev(devlistp, errbuf) == NULL)
1694  		return (-1);
1695  #endif
1696  #if defined(__FreeBSD__) && defined(SIOCIFCREATE2)
1697  	if (finddevs_usb(devlistp, errbuf) == -1)
1698  		return (-1);
1699  #endif
1700  	return (0);
1701  }
1702  #ifdef HAVE_BSD_IEEE80211
1703  static int
1704  monitor_mode(pcap_t *p, int set)
1705  {
1706  	struct pcap_bpf *pb = p->priv;
1707  	int sock;
1708  	struct ifmediareq req;
1709  	IFM_ULIST_TYPE *media_list;
1710  	int i;
1711  	int can_do;
1712  	struct ifreq ifr;
1713  	sock = socket(AF_INET, SOCK_DGRAM, 0);
1714  	if (sock == -1) {
1715  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1716  		    errno, "can't open socket");
1717  		return (PCAP_ERROR);
1718  	}
1719  	memset(&req, 0, sizeof req);
1720  	pcap_strlcpy(req.ifm_name, p->opt.device, sizeof req.ifm_name);
1721  	if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
1722  		switch (errno) {
1723  		case ENXIO:
1724  			p->errbuf[0] = '\0';
1725  			close(sock);
1726  			return (PCAP_ERROR_NO_SUCH_DEVICE);
1727  		case EINVAL:
1728  			close(sock);
1729  			return (PCAP_ERROR_RFMON_NOTSUP);
1730  		default:
1731  			pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1732  			    errno, "SIOCGIFMEDIA");
1733  			close(sock);
1734  			return (PCAP_ERROR);
1735  		}
1736  	}
1737  	if (req.ifm_count == 0) {
1738  		close(sock);
1739  		return (PCAP_ERROR_RFMON_NOTSUP);
1740  	}
1741  	media_list = malloc(req.ifm_count * sizeof(*media_list));
1742  	if (media_list == NULL) {
1743  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1744  		    errno, "malloc");
1745  		close(sock);
1746  		return (PCAP_ERROR);
1747  	}
1748  	req.ifm_ulist = media_list;
1749  	if (ioctl(sock, SIOCGIFMEDIA, &req) < 0) {
1750  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1751  		    errno, "SIOCGIFMEDIA");
1752  		free(media_list);
1753  		close(sock);
1754  		return (PCAP_ERROR);
1755  	}
1756  	can_do = 0;
1757  	for (i = 0; i < req.ifm_count; i++) {
1758  		if (IFM_TYPE(media_list[i]) == IFM_IEEE80211
1759  		    && IFM_SUBTYPE(media_list[i]) == IFM_AUTO) {
1760  			if (media_list[i] & IFM_IEEE80211_MONITOR) {
1761  				can_do = 1;
1762  				break;
1763  			}
1764  		}
1765  	}
1766  	free(media_list);
1767  	if (!can_do) {
1768  		close(sock);
1769  		return (PCAP_ERROR_RFMON_NOTSUP);
1770  	}
1771  	if (set) {
1772  		if ((req.ifm_current & IFM_IEEE80211_MONITOR) == 0) {
1773  			if (!pcap_do_addexit(p)) {
1774  				close(sock);
1775  				return (PCAP_ERROR);
1776  			}
1777  			memset(&ifr, 0, sizeof(ifr));
1778  			(void)pcap_strlcpy(ifr.ifr_name, p->opt.device,
1779  			    sizeof(ifr.ifr_name));
1780  			ifr.ifr_media = req.ifm_current | IFM_IEEE80211_MONITOR;
1781  			if (ioctl(sock, SIOCSIFMEDIA, &ifr) == -1) {
1782  				pcap_fmt_errmsg_for_errno(p->errbuf,
1783  				    PCAP_ERRBUF_SIZE, errno, "SIOCSIFMEDIA");
1784  				close(sock);
1785  				return (PCAP_ERROR);
1786  			}
1787  			pb->must_do_on_close |= MUST_CLEAR_RFMON;
1788  			pcap_add_to_pcaps_to_close(p);
1789  		}
1790  	}
1791  	return (0);
1792  }
1793  #endif &bsol;* HAVE_BSD_IEEE80211 */
1794  #if defined(BIOCGDLTLIST) && (defined(__APPLE__) || defined(HAVE_BSD_IEEE80211))
1795  static int
1796  find_802_11(struct bpf_dltlist *bdlp)
1797  {
1798  	int new_dlt;
1799  	u_int i;
1800  	new_dlt = -1;
1801  	for (i = 0; i < bdlp->bfl_len; i++) {
1802  		switch (bdlp->bfl_list[i]) {
1803  		case DLT_IEEE802_11:
1804  			if (new_dlt == -1)
1805  				new_dlt = bdlp->bfl_list[i];
1806  			break;
1807  #ifdef DLT_PRISM_HEADER
1808  		case DLT_PRISM_HEADER:
1809  #endif
1810  #ifdef DLT_AIRONET_HEADER
1811  		case DLT_AIRONET_HEADER:
1812  #endif
1813  		case DLT_IEEE802_11_RADIO_AVS:
1814  			if (new_dlt != DLT_IEEE802_11_RADIO)
1815  				new_dlt = bdlp->bfl_list[i];
1816  			break;
1817  		case DLT_IEEE802_11_RADIO:
1818  			new_dlt = bdlp->bfl_list[i];
1819  			break;
1820  		default:
1821  			break;
1822  		}
1823  	}
1824  	return (new_dlt);
1825  }
1826  #endif &bsol;* defined(BIOCGDLTLIST) && (defined(__APPLE__) || defined(HAVE_BSD_IEEE80211)) */
1827  #if defined(__APPLE__) && defined(BIOCGDLTLIST)
1828  static void
1829  remove_non_802_11(pcap_t *p)
1830  {
1831  	int i, j;
1832  	j = 0;
1833  	for (i = 0; i < p->dlt_count; i++) {
1834  		switch (p->dlt_list[i]) {
1835  		case DLT_EN10MB:
1836  		case DLT_RAW:
1837  			continue;
1838  		default:
1839  			break;
1840  		}
1841  		p->dlt_list[j] = p->dlt_list[i];
1842  		j++;
1843  	}
1844  	p->dlt_count = j;
1845  }
1846  static void
1847  remove_802_11(pcap_t *p)
1848  {
1849  	int i, j;
1850  	j = 0;
1851  	for (i = 0; i < p->dlt_count; i++) {
1852  		switch (p->dlt_list[i]) {
1853  		case DLT_IEEE802_11:
1854  #ifdef DLT_PRISM_HEADER
1855  		case DLT_PRISM_HEADER:
1856  #endif
1857  #ifdef DLT_AIRONET_HEADER
1858  		case DLT_AIRONET_HEADER:
1859  #endif
1860  		case DLT_IEEE802_11_RADIO:
1861  		case DLT_IEEE802_11_RADIO_AVS:
1862  #ifdef DLT_PPI
1863  		case DLT_PPI:
1864  #endif
1865  			continue;
1866  		default:
1867  			break;
1868  		}
1869  		p->dlt_list[j] = p->dlt_list[i];
1870  		j++;
1871  	}
1872  	p->dlt_count = j;
1873  }
1874  #endif &bsol;* defined(__APPLE__) && defined(BIOCGDLTLIST) */
1875  static int
1876  pcap_setfilter_bpf(pcap_t *p, struct bpf_program *fp)
1877  {
1878  	struct pcap_bpf *pb = p->priv;
1879  	pcap_freecode(&p->fcode);
1880  	if (ioctl(p->fd, BIOCSETF, (caddr_t)fp) == 0) {
1881  		pb->filtering_in_kernel = 1;	&bsol;* filtering in the kernel */
1882  		p->cc = 0;
1883  		return (0);
1884  	}
1885  	if (errno != EINVAL) {
1886  		pcap_fmt_errmsg_for_errno(p->errbuf, PCAP_ERRBUF_SIZE,
1887  		    errno, "BIOCSETF");
1888  		return (-1);
1889  	}
1890  	if (pcap_install_bpf_program(p, fp) < 0)
1891  		return (-1);
1892  	pb->filtering_in_kernel = 0;	&bsol;* filtering in userland */
1893  	return (0);
1894  }
1895  #if defined(BIOCSDIRECTION)
1896  static int
1897  pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
1898  {
1899  	u_int direction;
1900  	const char *direction_name;
1901  	switch (d) {
1902  	case PCAP_D_IN:
1903  		direction = BPF_D_IN;
1904  		direction_name = "\"incoming only\"";
1905  		break;
1906  	case PCAP_D_OUT:
1907  		direction = BPF_D_OUT;
1908  		direction_name = "\"outgoing only\"";
1909  		break;
1910  	default:
1911  		direction = BPF_D_INOUT;
1912  		direction_name = "\"incoming and outgoing\"";
1913  		break;
1914  	}
1915  	if (ioctl(p->fd, BIOCSDIRECTION, &direction) == -1) {
1916  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1917  		    errno, "Cannot set direction to %s", direction_name);
1918  		return (-1);
1919  	}
1920  	return (0);
1921  }
1922  #elif defined(BIOCSDIRFILT)
1923  static int
1924  pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
1925  {
1926  	u_int dirfilt;
1927  	const char *direction_name;
1928  	switch (d) {
1929  	case PCAP_D_IN:
1930  		dirfilt = BPF_DIRECTION_OUT;
1931  		direction_name = "\"incoming only\"";
1932  		break;
1933  	case PCAP_D_OUT:
1934  		dirfilt = BPF_DIRECTION_IN;
1935  		direction_name = "\"outgoing only\"";
1936  		break;
1937  	default:
1938  		dirfilt = 0;
1939  		direction_name = "\"incoming and outgoing\"";
1940  		break;
1941  	}
1942  	if (ioctl(p->fd, BIOCSDIRFILT, &dirfilt) == -1) {
1943  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1944  		    errno, "Cannot set direction to %s", direction_name);
1945  		return (-1);
1946  	}
1947  	return (0);
1948  }
1949  #elif defined(BIOCSSEESENT)
1950  static int
1951  pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d)
1952  {
1953  	u_int seesent;
1954  	const char *direction_name;
1955  	switch (d) {
1956  	case PCAP_D_IN:
1957  		seesent = 0;
1958  		direction_name = "\"incoming only\"";
1959  		break;
1960  	case PCAP_D_OUT:
1961  		snprintf(p->errbuf, sizeof(p->errbuf),
1962  		    "Setting direction to \"outgoing only\" is not supported on this device");
1963  		return (-1);
1964  	default:
1965  		seesent = 1;
1966  		direction_name = "\"incoming and outgoing\"";
1967  		break;
1968  	}
1969  	if (ioctl(p->fd, BIOCSSEESENT, &seesent) == -1) {
1970  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1971  		    errno, "Cannot set direction to %s", direction_name);
1972  		return (-1);
1973  	}
1974  	return (0);
1975  }
1976  #else
1977  static int
1978  pcap_setdirection_bpf(pcap_t *p, pcap_direction_t d _U_)
1979  {
1980  	(void) snprintf(p->errbuf, sizeof(p->errbuf),
1981  	    "Setting direction is not supported on this device");
1982  	return (-1);
1983  }
1984  #endif
1985  #ifdef BIOCSDLT
1986  static int
1987  pcap_set_datalink_bpf(pcap_t *p, int dlt)
1988  {
1989  	if (ioctl(p->fd, BIOCSDLT, &dlt) == -1) {
1990  		pcap_fmt_errmsg_for_errno(p->errbuf, sizeof(p->errbuf),
1991  		    errno, "Cannot set DLT %d", dlt);
1992  		return (-1);
1993  	}
1994  	return (0);
1995  }
1996  #else
1997  static int
1998  pcap_set_datalink_bpf(pcap_t *p _U_, int dlt _U_)
1999  {
2000  	return (0);
2001  }
2002  #endif
2003  const char *
2004  pcap_lib_version(void)
2005  {
2006  #ifdef HAVE_ZEROCOPY_BPF
2007  	return (PCAP_VERSION_STRING " (with zerocopy support)");
2008  #else
2009  	return (PCAP_VERSION_STRING);
2010  #endif
2011  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-bpf.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libpcap-MDEwOlJlcG9zaXRvcnk5NDM1ODg3-flat-pcap-bpf.c</div>
                </div>
                <div class="column column_space"><pre><code>528  	err = bpf_bind(fd, p->opt.device, p->errbuf);
529  	if (err != BPF_BIND_SUCCEEDED) {
</pre></code></div>
                <div class="column column_space"><pre><code>528  	err = bpf_bind(fd, p->opt.device, p->errbuf);
529  	if (err != BPF_BIND_SUCCEEDED) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    