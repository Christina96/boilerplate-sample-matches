
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_RedisLog.c</h3>
            <pre><code>1  #include "Win32_types.h"
2  #include "Win32_RedisLog.h"
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <malloc.h>
6  #include <string.h>
7  #include <process.h>
8  #include <time.h>
9  #include "Win32Fixes.h"
10  #include "Win32_EventLog.h"
11  #include "Win32_Time.h"
12  #include <assert.h>
13  static const char ellipsis[] = "[...]";
14  static const char ellipsisWithNewLine[] = "[...]\n";
15  static int verbosity = LL_WARNING;
16  static HANDLE hLogFile = INVALID_HANDLE_VALUE;
17  static int isStdout = 0;
18  static char* logFilename = NULL;
19  void setLogVerbosityLevel(int level)
20  {
21      verbosity = level;
22  }
23  const char* getLogFilename() {
24      if (logFilename == NULL || logFilename[0] == '\0') {
25          return "stdout";
26      } else {
27          return logFilename;
28      }
29  }
30  void setLogFile(const char* filename)
31  {
32      if (logFilename != NULL) {
33          free((void*) logFilename);
34          logFilename = NULL;
35      }
36      logFilename = (char*) malloc(strlen(filename) + 1);
37      if (logFilename == NULL) {
38          serverLog(LL_WARNING, "memory allocation failure");
39          return;
40      }
41      memset(logFilename, 0, strlen(filename) + 1);
42      strcpy(logFilename, filename);
43      if (hLogFile != INVALID_HANDLE_VALUE) {
44          if (!isStdout) CloseHandle(hLogFile);
45          hLogFile = INVALID_HANDLE_VALUE;
46      }
47      if (filename == NULL || (filename[0] == '\0') || (_stricmp(filename, "stdout") == 0)) {
48          hLogFile = GetStdHandle(STD_OUTPUT_HANDLE);
49          isStdout = 1;
50      }
51      else {
52          int len;
53          UINT codePage = CP_ACP;
54          wchar_t *widePath;
55          if ((len = MultiByteToWideChar(codePage, 0, filename, -1, 0, 0)) == 0) return;
56          if ((widePath = (wchar_t*)malloc(len * sizeof(wchar_t))) == NULL) return;
57          if (MultiByteToWideChar(codePage, 0, filename, -1, widePath, len) == 0) {
58              free(widePath);
59              return;
60          }
61          hLogFile = CreateFileW(
62              widePath,
63              FILE_APPEND_DATA,
64              FILE_SHARE_READ | FILE_SHARE_WRITE,
65              NULL,
66              OPEN_ALWAYS,
67              FILE_ATTRIBUTE_NORMAL, 
68              NULL);
69          if (hLogFile == INVALID_HANDLE_VALUE) {
70              DWORD err = GetLastError();
71              LPSTR messageBuffer = NULL;
72              FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
73                  NULL, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);
74              fprintf(stderr, "Could not open logfile %s: %s\n", filename, messageBuffer);
75              LocalFree(messageBuffer);
76          }
77          free(widePath);
78          isStdout = 0;
79      }
80  }
81  void serverLogRaw(int level, const char *msg) {
82      const char *c = ".-*#";
83      DWORD dwBytesWritten;
84      char buf[LOG_MAX_LEN];
85      const char *completeMessage;
86      DWORD completeMessageLength;
87      int rawmode = (level & LL_RAW);
88      level &= 0xff; &bsol;* clear flags */
89      if (level < verbosity) return;
90      if (hLogFile == INVALID_HANDLE_VALUE) return;
91      if (rawmode) {
92          completeMessage = msg;
93          completeMessageLength = (DWORD)strlen(msg);
94      } else {
95          int vlen, off = 0;
96          time_t secs;
97          unsigned int usecs;
98          struct tm * now ;
99          completeMessage = buf; 
100          secs = gettimeofdaysecs(&usecs);
101          now = localtime(&secs);
102          vlen = snprintf(buf + off, sizeof(buf) - off, "[%d] ", (int)_getpid());
103          assert(vlen >= 0);
104          off += vlen;
105          vlen = (int)strftime(buf + off, sizeof(buf) - off, "%d %b %H:%M:%S.", now);
106          assert(vlen >= 0);
107          off += vlen;
108          vlen = snprintf(buf + off, sizeof(buf) - off, "%03d %c ", usecs / 1000, c[level]);
109          assert(vlen >= 0);
110          off += vlen;
111          vlen = snprintf(buf + off, sizeof(buf) - off, "%s\n", msg);
112          if (vlen >= 0 && (off + vlen < sizeof(buf))) {
113              completeMessageLength = off + vlen;
114          }
115          else {
116              strncpy(buf + sizeof(buf)-sizeof(ellipsisWithNewLine), ellipsisWithNewLine, sizeof(ellipsisWithNewLine));
117              completeMessageLength = sizeof(buf)-1;
118          }
119      }
120      WriteFile(hLogFile, completeMessage, completeMessageLength, &dwBytesWritten, NULL);
121  #ifdef FLUSH_LOG_WRITES
122      FlushFileBuffers(hLogFile);
123  #endif
124      if (IsEventLogEnabled() == 1) {
125          WriteEventLog(msg);
126      }
127  }
128  void serverLog(int level, const char *fmt, ...) {
129      va_list ap;
130      char msg[LOG_MAX_LEN];
131      int vlen;
132      if ((level&0xff) < verbosity) return;
133      va_start(ap, fmt);
134      vlen = vsnprintf(msg, sizeof(msg), fmt, ap);
135      va_end(ap);
136      if (vlen < 0 || vlen >= sizeof(msg)) {
137          strncpy(msg + sizeof(msg) - sizeof(ellipsis), ellipsis, sizeof(ellipsis));
138      }
<span onclick='openModal()' class='match'>139      serverLogRaw(level,msg);
140  }
141  void serverLogFromHandler(int level, const char *msg) {
142  }
</span></code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-server.c</h3>
            <pre><code>1  #ifdef _WIN32
2  #include "Win32_Interop/Win32_Portability.h"
3  #include "Win32_Interop/Win32_FDAPI.h"
4  #include "Win32_Interop/Win32_ThreadControl.h"
5  #include "Win32_Interop/Win32_QFork.h"
6  #include "Win32_Interop/Win32_Error.h"
7  #endif
8  #include "server.h"
9  #include "cluster.h"
10  #include "slowlog.h"
11  #include "bio.h"
12  #include "latency.h"
13  #include "atomicvar.h"
14  #include <time.h>
15  #include <signal.h>
16  POSIX_ONLY(#include <sys/wait.h>)
17  #include <errno.h>
18  #include <assert.h>
19  #include <ctype.h>
20  #include <stdarg.h>
21  POSIX_ONLY(#include <arpa/inet.h>)
22  #include <sys/stat.h>
23  #include <fcntl.h>
24  POSIX_ONLY(#include <sys/time.h>)
25  POSIX_ONLY(#include <sys/resource.h>)
26  POSIX_ONLY(#include <sys/uio.h>)
27  POSIX_ONLY(#include <sys/un.h>)
28  #include <limits.h>
29  #include <float.h>
30  #include <math.h>
31  POSIX_ONLY(#include <sys/resource.h>)
32  POSIX_ONLY(#include <sys/utsname.h>)
33  #include <locale.h>
34  POSIX_ONLY(#include <sys/socket.h>)
35  struct sharedObjectsStruct shared;
36  double R_Zero, R_PosInf, R_NegInf, R_Nan;
37  struct redisServer server; &bsol;* Server global state */
38  volatile PORT_ULONG lru_clock; &bsol;* Server global current LRU time. */
39  struct redisCommand redisCommandTable[] = {
40      {"module",moduleCommand,-2,"as",0,NULL,0,0,0,0,0},
41      {"get",getCommand,2,"rF",0,NULL,1,1,1,0,0},
42      {"set",setCommand,-3,"wm",0,NULL,1,1,1,0,0},
43      {"setnx",setnxCommand,3,"wmF",0,NULL,1,1,1,0,0},
44      {"setex",setexCommand,4,"wm",0,NULL,1,1,1,0,0},
45      {"psetex",psetexCommand,4,"wm",0,NULL,1,1,1,0,0},
46      {"append",appendCommand,3,"wm",0,NULL,1,1,1,0,0},
47      {"strlen",strlenCommand,2,"rF",0,NULL,1,1,1,0,0},
48      {"del",delCommand,-2,"w",0,NULL,1,-1,1,0,0},
49      {"unlink",unlinkCommand,-2,"wF",0,NULL,1,-1,1,0,0},
50      {"exists",existsCommand,-2,"rF",0,NULL,1,-1,1,0,0},
51      {"setbit",setbitCommand,4,"wm",0,NULL,1,1,1,0,0},
52      {"getbit",getbitCommand,3,"rF",0,NULL,1,1,1,0,0},
53      {"bitfield",bitfieldCommand,-2,"wm",0,NULL,1,1,1,0,0},
54      {"setrange",setrangeCommand,4,"wm",0,NULL,1,1,1,0,0},
55      {"getrange",getrangeCommand,4,"r",0,NULL,1,1,1,0,0},
56      {"substr",getrangeCommand,4,"r",0,NULL,1,1,1,0,0},
57      {"incr",incrCommand,2,"wmF",0,NULL,1,1,1,0,0},
58      {"decr",decrCommand,2,"wmF",0,NULL,1,1,1,0,0},
59      {"mget",mgetCommand,-2,"rF",0,NULL,1,-1,1,0,0},
60      {"rpush",rpushCommand,-3,"wmF",0,NULL,1,1,1,0,0},
61      {"lpush",lpushCommand,-3,"wmF",0,NULL,1,1,1,0,0},
62      {"rpushx",rpushxCommand,-3,"wmF",0,NULL,1,1,1,0,0},
63      {"lpushx",lpushxCommand,-3,"wmF",0,NULL,1,1,1,0,0},
64      {"linsert",linsertCommand,5,"wm",0,NULL,1,1,1,0,0},
65      {"rpop",rpopCommand,2,"wF",0,NULL,1,1,1,0,0},
66      {"lpop",lpopCommand,2,"wF",0,NULL,1,1,1,0,0},
67      {"brpop",brpopCommand,-3,"ws",0,NULL,1,-2,1,0,0},
68      {"brpoplpush",brpoplpushCommand,4,"wms",0,NULL,1,2,1,0,0},
69      {"blpop",blpopCommand,-3,"ws",0,NULL,1,-2,1,0,0},
70      {"llen",llenCommand,2,"rF",0,NULL,1,1,1,0,0},
71      {"lindex",lindexCommand,3,"r",0,NULL,1,1,1,0,0},
72      {"lset",lsetCommand,4,"wm",0,NULL,1,1,1,0,0},
73      {"lrange",lrangeCommand,4,"r",0,NULL,1,1,1,0,0},
74      {"ltrim",ltrimCommand,4,"w",0,NULL,1,1,1,0,0},
75      {"lrem",lremCommand,4,"w",0,NULL,1,1,1,0,0},
76      {"rpoplpush",rpoplpushCommand,3,"wm",0,NULL,1,2,1,0,0},
77      {"sadd",saddCommand,-3,"wmF",0,NULL,1,1,1,0,0},
78      {"srem",sremCommand,-3,"wF",0,NULL,1,1,1,0,0},
79      {"smove",smoveCommand,4,"wF",0,NULL,1,2,1,0,0},
80      {"sismember",sismemberCommand,3,"rF",0,NULL,1,1,1,0,0},
81      {"scard",scardCommand,2,"rF",0,NULL,1,1,1,0,0},
82      {"spop",spopCommand,-2,"wRF",0,NULL,1,1,1,0,0},
83      {"srandmember",srandmemberCommand,-2,"rR",0,NULL,1,1,1,0,0},
84      {"sinter",sinterCommand,-2,"rS",0,NULL,1,-1,1,0,0},
85      {"sinterstore",sinterstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
86      {"sunion",sunionCommand,-2,"rS",0,NULL,1,-1,1,0,0},
87      {"sunionstore",sunionstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
88      {"sdiff",sdiffCommand,-2,"rS",0,NULL,1,-1,1,0,0},
89      {"sdiffstore",sdiffstoreCommand,-3,"wm",0,NULL,1,-1,1,0,0},
90      {"smembers",sinterCommand,2,"rS",0,NULL,1,1,1,0,0},
91      {"sscan",sscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
92      {"zadd",zaddCommand,-4,"wmF",0,NULL,1,1,1,0,0},
93      {"zincrby",zincrbyCommand,4,"wmF",0,NULL,1,1,1,0,0},
94      {"zrem",zremCommand,-3,"wF",0,NULL,1,1,1,0,0},
95      {"zremrangebyscore",zremrangebyscoreCommand,4,"w",0,NULL,1,1,1,0,0},
96      {"zremrangebyrank",zremrangebyrankCommand,4,"w",0,NULL,1,1,1,0,0},
97      {"zremrangebylex",zremrangebylexCommand,4,"w",0,NULL,1,1,1,0,0},
98      {"zunionstore",zunionstoreCommand,-4,"wm",0,zunionInterGetKeys,0,0,0,0,0},
99      {"zinterstore",zinterstoreCommand,-4,"wm",0,zunionInterGetKeys,0,0,0,0,0},
100      {"zrange",zrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
101      {"zrangebyscore",zrangebyscoreCommand,-4,"r",0,NULL,1,1,1,0,0},
102      {"zrevrangebyscore",zrevrangebyscoreCommand,-4,"r",0,NULL,1,1,1,0,0},
103      {"zrangebylex",zrangebylexCommand,-4,"r",0,NULL,1,1,1,0,0},
104      {"zrevrangebylex",zrevrangebylexCommand,-4,"r",0,NULL,1,1,1,0,0},
105      {"zcount",zcountCommand,4,"rF",0,NULL,1,1,1,0,0},
106      {"zlexcount",zlexcountCommand,4,"rF",0,NULL,1,1,1,0,0},
107      {"zrevrange",zrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
108      {"zcard",zcardCommand,2,"rF",0,NULL,1,1,1,0,0},
109      {"zscore",zscoreCommand,3,"rF",0,NULL,1,1,1,0,0},
110      {"zrank",zrankCommand,3,"rF",0,NULL,1,1,1,0,0},
111      {"zrevrank",zrevrankCommand,3,"rF",0,NULL,1,1,1,0,0},
112      {"zscan",zscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
113      {"zpopmin",zpopminCommand,-2,"wF",0,NULL,1,1,1,0,0},
114      {"zpopmax",zpopmaxCommand,-2,"wF",0,NULL,1,1,1,0,0},
115      {"bzpopmin",bzpopminCommand,-3,"wsF",0,NULL,1,-2,1,0,0},
116      {"bzpopmax",bzpopmaxCommand,-3,"wsF",0,NULL,1,-2,1,0,0},
117      {"hset",hsetCommand,-4,"wmF",0,NULL,1,1,1,0,0},
118      {"hsetnx",hsetnxCommand,4,"wmF",0,NULL,1,1,1,0,0},
119      {"hget",hgetCommand,3,"rF",0,NULL,1,1,1,0,0},
120      {"hmset",hsetCommand,-4,"wmF",0,NULL,1,1,1,0,0},
121      {"hmget",hmgetCommand,-3,"rF",0,NULL,1,1,1,0,0},
122      {"hincrby",hincrbyCommand,4,"wmF",0,NULL,1,1,1,0,0},
123      {"hincrbyfloat",hincrbyfloatCommand,4,"wmF",0,NULL,1,1,1,0,0},
124      {"hdel",hdelCommand,-3,"wF",0,NULL,1,1,1,0,0},
125      {"hlen",hlenCommand,2,"rF",0,NULL,1,1,1,0,0},
126      {"hstrlen",hstrlenCommand,3,"rF",0,NULL,1,1,1,0,0},
127      {"hkeys",hkeysCommand,2,"rS",0,NULL,1,1,1,0,0},
128      {"hvals",hvalsCommand,2,"rS",0,NULL,1,1,1,0,0},
129      {"hgetall",hgetallCommand,2,"rR",0,NULL,1,1,1,0,0},
130      {"hexists",hexistsCommand,3,"rF",0,NULL,1,1,1,0,0},
131      {"hscan",hscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
132      {"incrby",incrbyCommand,3,"wmF",0,NULL,1,1,1,0,0},
133      {"decrby",decrbyCommand,3,"wmF",0,NULL,1,1,1,0,0},
134      {"incrbyfloat",incrbyfloatCommand,3,"wmF",0,NULL,1,1,1,0,0},
135      {"getset",getsetCommand,3,"wm",0,NULL,1,1,1,0,0},
136      {"mset",msetCommand,-3,"wm",0,NULL,1,-1,2,0,0},
137      {"msetnx",msetnxCommand,-3,"wm",0,NULL,1,-1,2,0,0},
138      {"randomkey",randomkeyCommand,1,"rR",0,NULL,0,0,0,0,0},
139      {"select",selectCommand,2,"lF",0,NULL,0,0,0,0,0},
140      {"swapdb",swapdbCommand,3,"wF",0,NULL,0,0,0,0,0},
141      {"move",moveCommand,3,"wF",0,NULL,1,1,1,0,0},
142      {"rename",renameCommand,3,"w",0,NULL,1,2,1,0,0},
143      {"renamenx",renamenxCommand,3,"wF",0,NULL,1,2,1,0,0},
144      {"expire",expireCommand,3,"wF",0,NULL,1,1,1,0,0},
145      {"expireat",expireatCommand,3,"wF",0,NULL,1,1,1,0,0},
146      {"pexpire",pexpireCommand,3,"wF",0,NULL,1,1,1,0,0},
147      {"pexpireat",pexpireatCommand,3,"wF",0,NULL,1,1,1,0,0},
148      {"keys",keysCommand,2,"rS",0,NULL,0,0,0,0,0},
149      {"scan",scanCommand,-2,"rR",0,NULL,0,0,0,0,0},
150      {"dbsize",dbsizeCommand,1,"rF",0,NULL,0,0,0,0,0},
151      {"auth",authCommand,2,"sltMF",0,NULL,0,0,0,0,0},
152      {"ping",pingCommand,-1,"tF",0,NULL,0,0,0,0,0},
153      {"echo",echoCommand,2,"F",0,NULL,0,0,0,0,0},
154      {"save",saveCommand,1,"as",0,NULL,0,0,0,0,0},
155      {"bgsave",bgsaveCommand,-1,"as",0,NULL,0,0,0,0,0},
156      {"bgrewriteaof",bgrewriteaofCommand,1,"as",0,NULL,0,0,0,0,0},
157      {"shutdown",shutdownCommand,-1,"aslt",0,NULL,0,0,0,0,0},
158      {"lastsave",lastsaveCommand,1,"RF",0,NULL,0,0,0,0,0},
159      {"type",typeCommand,2,"rF",0,NULL,1,1,1,0,0},
160      {"multi",multiCommand,1,"sF",0,NULL,0,0,0,0,0},
161      {"exec",execCommand,1,"sM",0,NULL,0,0,0,0,0},
162      {"discard",discardCommand,1,"sF",0,NULL,0,0,0,0,0},
163      {"sync",syncCommand,1,"ars",0,NULL,0,0,0,0,0},
164      {"psync",syncCommand,3,"ars",0,NULL,0,0,0,0,0},
165      {"replconf",replconfCommand,-1,"aslt",0,NULL,0,0,0,0,0},
166      {"flushdb",flushdbCommand,-1,"w",0,NULL,0,0,0,0,0},
167      {"flushall",flushallCommand,-1,"w",0,NULL,0,0,0,0,0},
168      {"sort",sortCommand,-2,"wm",0,sortGetKeys,1,1,1,0,0},
169      {"info",infoCommand,-1,"ltR",0,NULL,0,0,0,0,0},
170      {"monitor",monitorCommand,1,"as",0,NULL,0,0,0,0,0},
171      {"ttl",ttlCommand,2,"rFR",0,NULL,1,1,1,0,0},
172      {"touch",touchCommand,-2,"rF",0,NULL,1,1,1,0,0},
173      {"pttl",pttlCommand,2,"rFR",0,NULL,1,1,1,0,0},
174      {"persist",persistCommand,2,"wF",0,NULL,1,1,1,0,0},
175      {"slaveof",replicaofCommand,3,"ast",0,NULL,0,0,0,0,0},
176      {"replicaof",replicaofCommand,3,"ast",0,NULL,0,0,0,0,0},
177      {"role",roleCommand,1,"lst",0,NULL,0,0,0,0,0},
178      {"debug",debugCommand,-2,"as",0,NULL,0,0,0,0,0},
179      {"config",configCommand,-2,"last",0,NULL,0,0,0,0,0},
180      {"subscribe",subscribeCommand,-2,"pslt",0,NULL,0,0,0,0,0},
181      {"unsubscribe",unsubscribeCommand,-1,"pslt",0,NULL,0,0,0,0,0},
182      {"psubscribe",psubscribeCommand,-2,"pslt",0,NULL,0,0,0,0,0},
183      {"punsubscribe",punsubscribeCommand,-1,"pslt",0,NULL,0,0,0,0,0},
184      {"publish",publishCommand,3,"pltF",0,NULL,0,0,0,0,0},
185      {"pubsub",pubsubCommand,-2,"pltR",0,NULL,0,0,0,0,0},
186      {"watch",watchCommand,-2,"sF",0,NULL,1,-1,1,0,0},
187      {"unwatch",unwatchCommand,1,"sF",0,NULL,0,0,0,0,0},
188      {"cluster",clusterCommand,-2,"a",0,NULL,0,0,0,0,0},
189      {"restore",restoreCommand,-4,"wm",0,NULL,1,1,1,0,0},
190      {"restore-asking",restoreCommand,-4,"wmk",0,NULL,1,1,1,0,0},
191      {"migrate",migrateCommand,-6,"wR",0,migrateGetKeys,0,0,0,0,0},
192      {"asking",askingCommand,1,"F",0,NULL,0,0,0,0,0},
193      {"readonly",readonlyCommand,1,"F",0,NULL,0,0,0,0,0},
194      {"readwrite",readwriteCommand,1,"F",0,NULL,0,0,0,0,0},
195      {"dump",dumpCommand,2,"rR",0,NULL,1,1,1,0,0},
196      {"object",objectCommand,-2,"rR",0,NULL,2,2,1,0,0},
197      {"memory",memoryCommand,-2,"rR",0,NULL,0,0,0,0,0},
198      {"client",clientCommand,-2,"as",0,NULL,0,0,0,0,0},
199      {"eval",evalCommand,-3,"s",0,evalGetKeys,0,0,0,0,0},
200      {"evalsha",evalShaCommand,-3,"s",0,evalGetKeys,0,0,0,0,0},
201      {"slowlog",slowlogCommand,-2,"aR",0,NULL,0,0,0,0,0},
202      {"script",scriptCommand,-2,"s",0,NULL,0,0,0,0,0},
203      {"time",timeCommand,1,"RF",0,NULL,0,0,0,0,0},
204      {"bitop",bitopCommand,-4,"wm",0,NULL,2,-1,1,0,0},
205      {"bitcount",bitcountCommand,-2,"r",0,NULL,1,1,1,0,0},
206      {"bitpos",bitposCommand,-3,"r",0,NULL,1,1,1,0,0},
207      {"wait",waitCommand,3,"s",0,NULL,0,0,0,0,0},
208      {"command",commandCommand,0,"ltR",0,NULL,0,0,0,0,0},
209      {"geoadd",geoaddCommand,-5,"wm",0,NULL,1,1,1,0,0},
210      {"georadius",georadiusCommand,-6,"w",0,georadiusGetKeys,1,1,1,0,0},
211      {"georadius_ro",georadiusroCommand,-6,"r",0,georadiusGetKeys,1,1,1,0,0},
212      {"georadiusbymember",georadiusbymemberCommand,-5,"w",0,georadiusGetKeys,1,1,1,0,0},
213      {"georadiusbymember_ro",georadiusbymemberroCommand,-5,"r",0,georadiusGetKeys,1,1,1,0,0},
214      {"geohash",geohashCommand,-2,"r",0,NULL,1,1,1,0,0},
215      {"geopos",geoposCommand,-2,"r",0,NULL,1,1,1,0,0},
216      {"geodist",geodistCommand,-4,"r",0,NULL,1,1,1,0,0},
217      {"pfselftest",pfselftestCommand,1,"a",0,NULL,0,0,0,0,0},
218      {"pfadd",pfaddCommand,-2,"wmF",0,NULL,1,1,1,0,0},
219      {"pfcount",pfcountCommand,-2,"r",0,NULL,1,-1,1,0,0},
220      {"pfmerge",pfmergeCommand,-2,"wm",0,NULL,1,-1,1,0,0},
221      {"pfdebug",pfdebugCommand,-3,"w",0,NULL,0,0,0,0,0},
222      {"xadd",xaddCommand,-5,"wmFR",0,NULL,1,1,1,0,0},
223      {"xrange",xrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
224      {"xrevrange",xrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
225      {"xlen",xlenCommand,2,"rF",0,NULL,1,1,1,0,0},
226      {"xread",xreadCommand,-4,"rs",0,xreadGetKeys,1,1,1,0,0},
227      {"xreadgroup",xreadCommand,-7,"ws",0,xreadGetKeys,1,1,1,0,0},
228      {"xgroup",xgroupCommand,-2,"wm",0,NULL,2,2,1,0,0},
229      {"xsetid",xsetidCommand,3,"wmF",0,NULL,1,1,1,0,0},
230      {"xack",xackCommand,-4,"wF",0,NULL,1,1,1,0,0},
231      {"xpending",xpendingCommand,-3,"rR",0,NULL,1,1,1,0,0},
232      {"xclaim",xclaimCommand,-6,"wRF",0,NULL,1,1,1,0,0},
233      {"xinfo",xinfoCommand,-2,"rR",0,NULL,2,2,1,0,0},
234      {"xdel",xdelCommand,-3,"wF",0,NULL,1,1,1,0,0},
235      {"xtrim",xtrimCommand,-2,"wFR",0,NULL,1,1,1,0,0},
236      {"post",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
237      {"host:",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
238      {"latency",latencyCommand,-2,"aslt",0,NULL,0,0,0,0,0},
239      {"lolwut",lolwutCommand,-1,"r",0,NULL,0,0,0,0,0}
240  };
241  void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);
242  #ifndef _WIN32 
243  void serverLogRaw(int level, const char *msg) {
244      const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };
245      const char *c = ".-*#";
246      FILE *fp;
247      char buf[64];
248      int rawmode = (level & LL_RAW);
249      int log_to_stdout = server.logfile[0] == '\0';
250      level &= 0xff; &bsol;* clear flags */
251      if (level < server.verbosity) return;
252      fp = log_to_stdout ? stdout : fopen(server.logfile,"a");
253      if (!fp) return;
254      if (rawmode) {
255          fprintf(fp,"%s",msg);
256      } else {
257          int off;
258          struct timeval tv;
259          int role_char;
260          pid_t pid = getpid();
261          gettimeofday(&tv,NULL);
262          struct tm tm;
263          nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);
264          off = strftime(buf,sizeof(buf),"%d %b %Y %H:%M:%S.",&tm);
265          snprintf(buf+off,sizeof(buf)-off,"%03d",(int)tv.tv_usec/1000);
266          if (server.sentinel_mode) {
267              role_char = 'X'; &bsol;* Sentinel. */
268          } else if (pid != server.pid) {
269              role_char = 'C'; &bsol;* RDB / AOF writing child. */
270          } else {
271              role_char = (server.masterhost ? 'S':'M'); &bsol;* Slave or Master. */
272          }
273          fprintf(fp,"%d:%c %s %c %s\n",
274              (int)getpid(),role_char, buf,c[level],msg);
275      }
276      fflush(fp);
277      if (!log_to_stdout) fclose(fp);
278      if (server.syslog_enabled) syslog(syslogLevelMap[level], "%s", msg);
279  }
280  void serverLog(int level, const char *fmt, ...) {
281      va_list ap;
282      char msg[LOG_MAX_LEN];
283      if ((level&0xff) < server.verbosity) return;
284      va_start(ap, fmt);
285      vsnprintf(msg, sizeof(msg), fmt, ap);
286      va_end(ap);
<span onclick='openModal()' class='match'>287      serverLogRaw(level,msg);
288  }
289  void serverLogFromHandler(int level, const char *msg) {
290      int fd;
</span>291      int log_to_stdout = server.logfile[0] == '\0';
292      char buf[64];
293      if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))
294          return;
295      fd = log_to_stdout ? STDOUT_FILENO :
296                           open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
297      if (fd == -1) return;
298      ll2string(buf,sizeof(buf),getpid());
299      if (write(fd,buf,strlen(buf)) == -1) goto err;
300      if (write(fd,":signal-handler (",17) == -1) goto err;
301      ll2string(buf,sizeof(buf),time(NULL));
302      if (write(fd,buf,strlen(buf)) == -1) goto err;
303      if (write(fd,") ",2) == -1) goto err;
304      if (write(fd,msg,strlen(msg)) == -1) goto err;
305      if (write(fd,"\n",1) == -1) goto err;
306  err:
307      if (!log_to_stdout) close(fd);
308  }
309  #endif
310  PORT_LONGLONG ustime(void) {
311      struct timeval tv;
312      PORT_LONGLONG ust;
313      gettimeofday(&tv, NULL);
314      ust = ((PORT_LONGLONG)tv.tv_sec)*1000000;
315      ust += tv.tv_usec;
316      return ust;
317  }
318  PORT_LONGLONG mstime(void) {
319      return ustime()/1000;
320  }
321  void exitFromChild(int retcode) {
322  #ifdef COVERAGE_TEST
323      exit(retcode);
324  #else
325      _exit(retcode);
326  #endif
327  }
328  void dictVanillaFree(void *privdata, void *val)
329  {
330      DICT_NOTUSED(privdata);
331      zfree(val);
332  }
333  void dictListDestructor(void *privdata, void *val)
334  {
335      DICT_NOTUSED(privdata);
336      listRelease((list*)val);
337  }
338  int dictSdsKeyCompare(void *privdata, const void *key1,
339          const void *key2)
340  {
341      int l1,l2;
342      DICT_NOTUSED(privdata);
343      l1 = (int)sdslen((sds)key1);                                                WIN_PORT_FIX &bsol;* cast (int) */
344      l2 = (int)sdslen((sds)key2);                                                WIN_PORT_FIX &bsol;* cast (int) */
345      if (l1 != l2) return 0;
346      return memcmp(key1, key2, l1) == 0;
347  }
348  int dictSdsKeyCaseCompare(void *privdata, const void *key1,
349          const void *key2)
350  {
351      DICT_NOTUSED(privdata);
352      return strcasecmp(key1, key2) == 0;
353  }
354  void dictObjectDestructor(void *privdata, void *val)
355  {
356      DICT_NOTUSED(privdata);
357      if (val == NULL) return; &bsol;* Lazy freeing will set value to NULL. */
358      decrRefCount(val);
359  }
360  void dictSdsDestructor(void *privdata, void *val)
361  {
362      DICT_NOTUSED(privdata);
363      sdsfree(val);
364  }
365  int dictObjKeyCompare(void *privdata, const void *key1,
366          const void *key2)
367  {
368      const robj *o1 = key1, *o2 = key2;
369      return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
370  }
371  uint64_t dictObjHash(const void *key) {
372      const robj *o = key;
373      return dictGenHashFunction(o->ptr, (int)sdslen((sds)o->ptr));               WIN_PORT_FIX &bsol;* cast (int) */
374  }
375  uint64_t dictSdsHash(const void *key) {
376      return dictGenHashFunction((unsigned char*)key, (int)sdslen((char*)key));   WIN_PORT_FIX &bsol;* cast (int) */
377  }
378  uint64_t dictSdsCaseHash(const void *key) {
379      return dictGenCaseHashFunction((unsigned char*)key, (int)sdslen((char*)key)); WIN_PORT_FIX &bsol;* cast (int) */
380  }
381  int dictEncObjKeyCompare(void *privdata, const void *key1,
382          const void *key2)
383  {
384      robj *o1 = (robj*) key1, *o2 = (robj*) key2;
385      int cmp;
386      if (o1->encoding == OBJ_ENCODING_INT &&
387          o2->encoding == OBJ_ENCODING_INT)
388              return o1->ptr == o2->ptr;
389      o1 = getDecodedObject(o1);
390      o2 = getDecodedObject(o2);
391      cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
392      decrRefCount(o1);
393      decrRefCount(o2);
394      return cmp;
395  }
396  uint64_t dictEncObjHash(const void *key) {
397      robj *o = (robj*) key;
398      if (sdsEncodedObject(o)) {
399          return dictGenHashFunction(o->ptr, (int)sdslen((sds)o->ptr));          WIN_PORT_FIX &bsol;* cast (int) */
400      } else {
401          if (o->encoding == OBJ_ENCODING_INT) {
402              char buf[32];
403              int len;
404              len = ll2string(buf,32,(PORT_LONG)o->ptr);
405              return dictGenHashFunction((unsigned char*)buf, len);
406          } else {
407              uint64_t hash;
408              o = getDecodedObject(o);
409              hash = dictGenHashFunction(o->ptr, (int)sdslen((sds)o->ptr));      WIN_PORT_FIX &bsol;* cast (int) */
410              decrRefCount(o);
411              return hash;
412          }
413      }
414  }
415  dictType objectKeyPointerValueDictType = {
416      dictEncObjHash,            &bsol;* hash function */
417      NULL,                      &bsol;* key dup */
418      NULL,                      &bsol;* val dup */
419      dictEncObjKeyCompare,      &bsol;* key compare */
420      dictObjectDestructor,      &bsol;* key destructor */
421      NULL                       &bsol;* val destructor */
422  };
423  dictType objectKeyHeapPointerValueDictType = {
424      dictEncObjHash,            &bsol;* hash function */
425      NULL,                      &bsol;* key dup */
426      NULL,                      &bsol;* val dup */
427      dictEncObjKeyCompare,      &bsol;* key compare */
428      dictObjectDestructor,      &bsol;* key destructor */
429      dictVanillaFree            &bsol;* val destructor */
430  };
431  dictType setDictType = {
432      dictSdsHash,               &bsol;* hash function */
433      NULL,                      &bsol;* key dup */
434      NULL,                      &bsol;* val dup */
435      dictSdsKeyCompare,         &bsol;* key compare */
436      dictSdsDestructor,         &bsol;* key destructor */
437      NULL                       &bsol;* val destructor */
438  };
439  dictType zsetDictType = {
440      dictSdsHash,               &bsol;* hash function */
441      NULL,                      &bsol;* key dup */
442      NULL,                      &bsol;* val dup */
443      dictSdsKeyCompare,         &bsol;* key compare */
444      NULL,                      &bsol;* Note: SDS string shared & freed by skiplist */
445      NULL                       &bsol;* val destructor */
446  };
447  dictType dbDictType = {
448      dictSdsHash,                &bsol;* hash function */
449      NULL,                       &bsol;* key dup */
450      NULL,                       &bsol;* val dup */
451      dictSdsKeyCompare,          &bsol;* key compare */
452      dictSdsDestructor,          &bsol;* key destructor */
453      dictObjectDestructor   &bsol;* val destructor */
454  };
455  dictType shaScriptObjectDictType = {
456      dictSdsCaseHash,            &bsol;* hash function */
457      NULL,                       &bsol;* key dup */
458      NULL,                       &bsol;* val dup */
459      dictSdsKeyCaseCompare,      &bsol;* key compare */
460      dictSdsDestructor,          &bsol;* key destructor */
461      dictObjectDestructor        &bsol;* val destructor */
462  };
463  dictType keyptrDictType = {
464      dictSdsHash,                &bsol;* hash function */
465      NULL,                       &bsol;* key dup */
466      NULL,                       &bsol;* val dup */
467      dictSdsKeyCompare,          &bsol;* key compare */
468      NULL,                       &bsol;* key destructor */
469      NULL                        &bsol;* val destructor */
470  };
471  dictType commandTableDictType = {
472      dictSdsCaseHash,            &bsol;* hash function */
473      NULL,                       &bsol;* key dup */
474      NULL,                       &bsol;* val dup */
475      dictSdsKeyCaseCompare,      &bsol;* key compare */
476      dictSdsDestructor,          &bsol;* key destructor */
477      NULL                        &bsol;* val destructor */
478  };
479  dictType hashDictType = {
480      dictSdsHash,                &bsol;* hash function */
481      NULL,                       &bsol;* key dup */
482      NULL,                       &bsol;* val dup */
483      dictSdsKeyCompare,          &bsol;* key compare */
484      dictSdsDestructor,          &bsol;* key destructor */
485      dictSdsDestructor           &bsol;* val destructor */
486  };
487  dictType keylistDictType = {
488      dictObjHash,                &bsol;* hash function */
489      NULL,                       &bsol;* key dup */
490      NULL,                       &bsol;* val dup */
491      dictObjKeyCompare,          &bsol;* key compare */
492      dictObjectDestructor,       &bsol;* key destructor */
493      dictListDestructor          &bsol;* val destructor */
494  };
495  dictType clusterNodesDictType = {
496      dictSdsHash,                &bsol;* hash function */
497      NULL,                       &bsol;* key dup */
498      NULL,                       &bsol;* val dup */
499      dictSdsKeyCompare,          &bsol;* key compare */
500      dictSdsDestructor,          &bsol;* key destructor */
501      NULL                        &bsol;* val destructor */
502  };
503  dictType clusterNodesBlackListDictType = {
504      dictSdsCaseHash,            &bsol;* hash function */
505      NULL,                       &bsol;* key dup */
506      NULL,                       &bsol;* val dup */
507      dictSdsKeyCaseCompare,      &bsol;* key compare */
508      dictSdsDestructor,          &bsol;* key destructor */
509      NULL                        &bsol;* val destructor */
510  };
511  dictType modulesDictType = {
512      dictSdsCaseHash,            &bsol;* hash function */
513      NULL,                       &bsol;* key dup */
514      NULL,                       &bsol;* val dup */
515      dictSdsKeyCaseCompare,      &bsol;* key compare */
516      dictSdsDestructor,          &bsol;* key destructor */
517      NULL                        &bsol;* val destructor */
518  };
519  dictType migrateCacheDictType = {
520      dictSdsHash,                &bsol;* hash function */
521      NULL,                       &bsol;* key dup */
522      NULL,                       &bsol;* val dup */
523      dictSdsKeyCompare,          &bsol;* key compare */
524      dictSdsDestructor,          &bsol;* key destructor */
525      NULL                        &bsol;* val destructor */
526  };
527  dictType replScriptCacheDictType = {
528      dictSdsCaseHash,            &bsol;* hash function */
529      NULL,                       &bsol;* key dup */
530      NULL,                       &bsol;* val dup */
531      dictSdsKeyCaseCompare,      &bsol;* key compare */
532      dictSdsDestructor,          &bsol;* key destructor */
533      NULL                        &bsol;* val destructor */
534  };
535  int htNeedsResize(dict *dict) {
536      PORT_LONGLONG size, used;
537      size = dictSlots(dict);
538      used = dictSize(dict);
539      return (size > DICT_HT_INITIAL_SIZE &&
540              (used*100/size < HASHTABLE_MIN_FILL));
541  }
542  void tryResizeHashTables(int dbid) {
543      if (htNeedsResize(server.db[dbid].dict))
544          dictResize(server.db[dbid].dict);
545      if (htNeedsResize(server.db[dbid].expires))
546          dictResize(server.db[dbid].expires);
547  }
548  int incrementallyRehash(int dbid) {
549      if (dictIsRehashing(server.db[dbid].dict)) {
550          dictRehashMilliseconds(server.db[dbid].dict,1);
551          return 1; &bsol;* already used our millisecond for this loop... */
552      }
553      if (dictIsRehashing(server.db[dbid].expires)) {
554          dictRehashMilliseconds(server.db[dbid].expires,1);
555          return 1; &bsol;* already used our millisecond for this loop... */
556      }
557      return 0;
558  }
559  void updateDictResizePolicy(void) {
560      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1)
561          dictEnableResize();
562      else
563          dictDisableResize();
564  }
565  int hasActiveChildProcess() {
566      return server.rdb_child_pid != -1 ||
567             server.aof_child_pid != -1;
568  }
569  void trackInstantaneousMetric(int metric, PORT_LONGLONG current_reading) {
570      PORT_LONGLONG t = mstime() - server.inst_metric[metric].last_sample_time;
571      PORT_LONGLONG ops = current_reading -
572                      server.inst_metric[metric].last_sample_count;
573      PORT_LONGLONG ops_sec;
574      ops_sec = t > 0 ? (ops*1000/t) : 0;
575      server.inst_metric[metric].samples[server.inst_metric[metric].idx] =
576          ops_sec;
577      server.inst_metric[metric].idx++;
578      server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;
579      server.inst_metric[metric].last_sample_time = mstime();
580      server.inst_metric[metric].last_sample_count = current_reading;
581  }
582  PORT_LONGLONG getInstantaneousMetric(int metric) {
583      int j;
584      PORT_LONGLONG sum = 0;
585      for (j = 0; j < STATS_METRIC_SAMPLES; j++)
586          sum += server.inst_metric[metric].samples[j];
587      return sum / STATS_METRIC_SAMPLES;
588  }
589  int clientsCronHandleTimeout(client *c, mstime_t now_ms) {
590      time_t now = now_ms/1000;
591      if (server.maxidletime &&
592          !(c->flags & CLIENT_SLAVE) &&    &bsol;* no timeout for slaves and monitors */
593          !(c->flags & CLIENT_MASTER) &&   &bsol;* no timeout for masters */
594          !(c->flags & CLIENT_BLOCKED) &&  &bsol;* no timeout for BLPOP */
595          !(c->flags & CLIENT_PUBSUB) &&   &bsol;* no timeout for Pub/Sub clients */
596          (now - c->lastinteraction > server.maxidletime))
597      {
598          serverLog(LL_VERBOSE,"Closing idle client");
599          freeClient(c);
600          return 1;
601      } else if (c->flags & CLIENT_BLOCKED) {
602          if (c->bpop.timeout != 0 && c->bpop.timeout < now_ms) {
603              replyToBlockedClientTimedOut(c);
604              unblockClient(c);
605          } else if (server.cluster_enabled) {
606              if (clusterRedirectBlockedClientIfNeeded(c))
607                  unblockClient(c);
608          }
609      }
610      return 0;
611  }
612  int clientsCronResizeQueryBuffer(client *c) {
613      size_t querybuf_size = sdsAllocSize(c->querybuf);
614      time_t idletime = server.unixtime - c->lastinteraction;
615      if (querybuf_size > PROTO_MBULK_BIG_ARG &&
616           ((querybuf_size/(c->querybuf_peak+1)) > 2 ||
617            idletime > 2))
618      {
619          if (sdsavail(c->querybuf) > 1024*4) {
620              c->querybuf = sdsRemoveFreeSpace(c->querybuf);
621          }
622      }
623      c->querybuf_peak = 0;
624      if (c->flags & CLIENT_MASTER) {
625          size_t pending_querybuf_size = sdsAllocSize(c->pending_querybuf);
626          if(pending_querybuf_size > LIMIT_PENDING_QUERYBUF &&
627             sdslen(c->pending_querybuf) < (pending_querybuf_size/2))
628          {
629              c->pending_querybuf = sdsRemoveFreeSpace(c->pending_querybuf);
630          }
631      }
632      return 0;
633  }
634  #define CLIENTS_PEAK_MEM_USAGE_SLOTS 8
635  size_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS];
636  size_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS];
637  int clientsCronTrackExpansiveClients(client *c) {
638      size_t in_usage = sdsAllocSize(c->querybuf);
639      size_t out_usage = getClientOutputBufferMemoryUsage(c);
640      int i = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;
641      int zeroidx = (i+1) % CLIENTS_PEAK_MEM_USAGE_SLOTS;
642      ClientsPeakMemInput[zeroidx] = 0;
643      ClientsPeakMemOutput[zeroidx] = 0;
644      if (in_usage > ClientsPeakMemInput[i]) ClientsPeakMemInput[i] = in_usage;
645      if (out_usage > ClientsPeakMemOutput[i]) ClientsPeakMemOutput[i] = out_usage;
646      return 0; &bsol;* This function never terminates the client. */
647  }
648  void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
649      size_t i = 0, o = 0;
650      for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {
651          if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];
652          if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];
653      }
654      *in_usage = i;
655      *out_usage = o;
656  }
657  #define CLIENTS_CRON_MIN_ITERATIONS 5
658  void clientsCron(void) {
659      int numclients = (int)listLength(server.clients);                           WIN_PORT_FIX &bsol;* cast (int) */
660      int iterations = numclients/server.hz;
661      mstime_t now = mstime();
662      if (iterations < CLIENTS_CRON_MIN_ITERATIONS)
663          iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?
664                       numclients : CLIENTS_CRON_MIN_ITERATIONS;
665      while(listLength(server.clients) && iterations--) {
666          client *c;
667          listNode *head;
668          listRotateTailToHead(server.clients);
669          head = listFirst(server.clients);
670          c = listNodeValue(head);
671          if (clientsCronHandleTimeout(c,now)) continue;
672          if (clientsCronResizeQueryBuffer(c)) continue;
673          if (clientsCronTrackExpansiveClients(c)) continue;
674      }
675  }
676  void databasesCron(void) {
677      if (server.active_expire_enabled) {
678          if (server.masterhost == NULL) {
679              activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);
680          } else {
681              expireSlaveKeys();
682          }
683      }
684      if (server.active_defrag_enabled)
685          activeDefragCycle();
686      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {
687          static unsigned int resize_db = 0;
688          static unsigned int rehash_db = 0;
689          int dbs_per_call = CRON_DBS_PER_CALL;
690          int j;
691          if (dbs_per_call > server.dbnum) dbs_per_call = server.dbnum;
692          for (j = 0; j < dbs_per_call; j++) {
693              tryResizeHashTables(resize_db % server.dbnum);
694              resize_db++;
695          }
696          if (server.activerehashing) {
697              for (j = 0; j < dbs_per_call; j++) {
698                  int work_done = incrementallyRehash(rehash_db);
699                  if (work_done) {
700                      break;
701                  } else {
702                      rehash_db++;
703                      rehash_db %= server.dbnum;
704                  }
705              }
706          }
707      }
708  }
709  void updateCachedTime(int update_daylight_info) {
710      server.ustime = ustime();
711      server.mstime = server.ustime / 1000;
712      time_t unixtime = server.mstime / 1000;
713      atomicSet(server.unixtime,unixtime);
714      if (update_daylight_info) {
715          struct tm tm;
716          time_t ut = server.unixtime;
717  #ifdef _WIN32
718          localtime_s(&tm,&ut);
719  #else
720          localtime_r(&ut,&tm);
721  #endif
722          server.daylight_active = tm.tm_isdst;
723      }
724  }
725  int serverCron(struct aeEventLoop *eventLoop, PORT_LONGLONG id, void *clientData) {
726      int j;
727      UNUSED(eventLoop);
728      UNUSED(id);
729      UNUSED(clientData);
730      if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);
731      updateCachedTime(1);
732      server.hz = server.config_hz;
733      if (server.dynamic_hz) {
734          while (listLength(server.clients) / server.hz >
735                 MAX_CLIENTS_PER_CLOCK_TICK)
736          {
737              server.hz *= 2;
738              if (server.hz > CONFIG_MAX_HZ) {
739                  server.hz = CONFIG_MAX_HZ;
740                  break;
741              }
742          }
743      }
744      run_with_period(100) {
745          trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);
746          trackInstantaneousMetric(STATS_METRIC_NET_INPUT,
747                  server.stat_net_input_bytes);
748          trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,
749                  server.stat_net_output_bytes);
750      }
751      unsigned long lruclock = getLRUClock();
752      atomicSet(server.lruclock,lruclock);
753      if (zmalloc_used_memory() > server.stat_peak_memory)
754          server.stat_peak_memory = zmalloc_used_memory();
755      run_with_period(100) {
756          server.cron_malloc_stats.process_rss = zmalloc_get_rss();
757          server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();
758          zmalloc_get_allocator_info(&server.cron_malloc_stats.allocator_allocated,
759                                     &server.cron_malloc_stats.allocator_active,
760                                     &server.cron_malloc_stats.allocator_resident);
761          if (!server.cron_malloc_stats.allocator_resident) {
762              size_t lua_memory = lua_gc(server.lua,LUA_GCCOUNT,0)*(PORT_LONGLONG)1024;  
763              server.cron_malloc_stats.allocator_resident = server.cron_malloc_stats.process_rss - lua_memory;
764          }
765          if (!server.cron_malloc_stats.allocator_active)
766              server.cron_malloc_stats.allocator_active = server.cron_malloc_stats.allocator_resident;
767          if (!server.cron_malloc_stats.allocator_allocated)
768              server.cron_malloc_stats.allocator_allocated = server.cron_malloc_stats.zmalloc_used;
769      }
770      if (server.shutdown_asap) {
771          if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);
772          serverLog(LL_WARNING,"SIGTERM received but errors trying to shut down the server, check the logs for more information");
773          server.shutdown_asap = 0;
774      }
775      run_with_period(5000) {
776          for (j = 0; j < server.dbnum; j++) {
777              PORT_LONGLONG size, used, vkeys;
778              size = dictSlots(server.db[j].dict);
779              used = dictSize(server.db[j].dict);
780              vkeys = dictSize(server.db[j].expires);
781              if (used || vkeys) {
782                  serverLog(LL_VERBOSE,"DB %d: %lld keys (%lld volatile) in %lld slots HT.",j,used,vkeys,size);
783              }
784          }
785      }
786      if (!server.sentinel_mode) {
787          run_with_period(5000) {
788              serverLog(LL_VERBOSE,
789                  "%Iu clients connected (%Iu replicas), %Iu bytes in use", WIN_PORT_FIX &bsol;* %zu -> %Iu, %lu -> %Iu */
790                  listLength(server.clients)-listLength(server.slaves),
791                  listLength(server.slaves),
792                  zmalloc_used_memory());
793          }
794      }
795      clientsCron();
796      databasesCron();
797      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
798          server.aof_rewrite_scheduled)
799      {
800          rewriteAppendOnlyFileBackground();
801      }
802      if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||
803          ldbPendingChildren())
804      {
805  #ifdef _WIN32
806          if (GetForkOperationStatus() == osCOMPLETE || GetForkOperationStatus() == osFAILED) {
807              RequestSuspension();
808              if (SuspensionCompleted()) {
809                  int exitcode;
810                  int bysignal;
811                  bysignal = (int) (GetForkOperationStatus() == osFAILED);
812                  serverLog(LL_WARNING, (bysignal ? "fork operation failed" : "fork operation complete"));
813                  EndForkOperation(&exitcode);
814                  ResumeFromSuspension();
815                  if (server.rdb_child_pid != -1) {
816                      backgroundSaveDoneHandler(exitcode, bysignal);
817                      if (!bysignal && exitcode == 0) receiveChildInfo();
818                  }
819                  else {
820                      backgroundRewriteDoneHandler(exitcode, bysignal);
821                      if (!bysignal && exitcode == 0) receiveChildInfo();
822                  }
823                  updateDictResizePolicy();
824              }
825          }
826  #else
827          int statloc;
828          pid_t pid;
829          if ((pid = wait3(&statloc,WNOHANG,NULL)) != 0) {
830              int exitcode = WEXITSTATUS(statloc);
831              int bysignal = 0;
832              if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
833              if (pid == -1) {
834                  serverLog(LL_WARNING,"wait3() returned an error: %s. "
835                      "rdb_child_pid = %d, aof_child_pid = %d",
836                      strerror(errno),
837                      (int) server.rdb_child_pid,
838                      (int) server.aof_child_pid);
839              } else if (pid == server.rdb_child_pid) {
840                  backgroundSaveDoneHandler(exitcode,bysignal);
841                  if (!bysignal && exitcode == 0) receiveChildInfo();
842              } else if (pid == server.aof_child_pid) {
843                  backgroundRewriteDoneHandler(exitcode,bysignal);
844                  if (!bysignal && exitcode == 0) receiveChildInfo();
845              } else {
846                  if (!ldbRemoveChild(pid)) {
847                      serverLog(LL_WARNING,
848                          "Warning, detected child with unmatched pid: %ld",
849                          (PORT_LONG)pid);
850                  }
851              }
852              updateDictResizePolicy();
853              closeChildInfoPipe();
854          }
855  #endif
856      } else {
857          for (j = 0; j < server.saveparamslen; j++) {
858              struct saveparam *sp = server.saveparams+j;
859              if (server.dirty >= sp->changes &&
860                  server.unixtime-server.lastsave > sp->seconds &&
861                  (server.unixtime-server.lastbgsave_try >
862                   CONFIG_BGSAVE_RETRY_DELAY ||
863                   server.lastbgsave_status == C_OK))
864              {
865                  serverLog(LL_NOTICE,"%d changes in %d seconds. Saving...",
866                      sp->changes, (int)sp->seconds);
867                  rdbSaveInfo rsi, *rsiptr;
868                  rsiptr = rdbPopulateSaveInfo(&rsi);
869                  rdbSaveBackground(server.rdb_filename,rsiptr);
870                  break;
871              }
872          }
873          if (server.aof_state == AOF_ON &&
874              server.rdb_child_pid == -1 &&
875              server.aof_child_pid == -1 &&
876              server.aof_rewrite_perc &&
877              server.aof_current_size > server.aof_rewrite_min_size)
878          {
879              PORT_LONGLONG base = server.aof_rewrite_base_size ?
880                  server.aof_rewrite_base_size : 1;
881              PORT_LONGLONG growth = (server.aof_current_size*100/base) - 100;
882              if (growth >= server.aof_rewrite_perc) {
883                  serverLog(LL_NOTICE,"Starting automatic rewriting of AOF on %lld%% growth",growth);
884                  rewriteAppendOnlyFileBackground();
885              }
886          }
887      }
888      if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);
889      run_with_period(1000) {
890          if (server.aof_last_write_status == C_ERR)
891              flushAppendOnlyFile(0);
892      }
893      freeClientsInAsyncFreeQueue();
894      clientsArePaused(); &bsol;* Don't check return value, just use the side effect.*/
895      run_with_period(1000) replicationCron();
896      run_with_period(100) {
897          if (server.cluster_enabled) clusterCron();
898      }
899      if (server.sentinel_mode) sentinelTimer();
900      run_with_period(1000) {
901          migrateCloseTimedoutSockets();
902      }
903      if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
904          server.rdb_bgsave_scheduled &&
905          (server.unixtime-server.lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY ||
906           server.lastbgsave_status == C_OK))
907      {
908          rdbSaveInfo rsi, *rsiptr;
909          rsiptr = rdbPopulateSaveInfo(&rsi);
910          if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)
911              server.rdb_bgsave_scheduled = 0;
912      }
913      server.cronloops++;
914      return 1000/server.hz;
915  }
916  void beforeSleep(struct aeEventLoop *eventLoop) {
917      UNUSED(eventLoop);
918  #ifdef WIN32
919  	aofProcessDiffRewriteEvents(eventLoop);
920  #endif
921      if (server.cluster_enabled) clusterBeforeSleep();
922      if (server.active_expire_enabled && server.masterhost == NULL)
923          activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);
924      if (server.get_ack_from_slaves) {
925          robj *argv[3];
926          argv[0] = createStringObject("REPLCONF",8);
927          argv[1] = createStringObject("GETACK",6);
928          argv[2] = createStringObject("*",1); &bsol;* Not used argument. */
929          replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);
930          decrRefCount(argv[0]);
931          decrRefCount(argv[1]);
932          decrRefCount(argv[2]);
933          server.get_ack_from_slaves = 0;
934      }
935      if (listLength(server.clients_waiting_acks))
936          processClientsWaitingReplicas();
937      moduleHandleBlockedClients();
938      if (listLength(server.unblocked_clients))
939          processUnblockedClients();
940      flushAppendOnlyFile(0);
941      handleClientsWithPendingWrites();
942      if (moduleCount()) moduleReleaseGIL();
943  }
944  void afterSleep(struct aeEventLoop *eventLoop) {
945      UNUSED(eventLoop);
946      if (moduleCount()) moduleAcquireGIL();
947  }
948  void createSharedObjects(void) {
949      int j;
950      shared.crlf = createObject(OBJ_STRING,sdsnew("\r\n"));
951      shared.ok = createObject(OBJ_STRING,sdsnew("+OK\r\n"));
952      shared.err = createObject(OBJ_STRING,sdsnew("-ERR\r\n"));
953      shared.emptybulk = createObject(OBJ_STRING,sdsnew("$0\r\n\r\n"));
954      shared.czero = createObject(OBJ_STRING,sdsnew(":0\r\n"));
955      shared.cone = createObject(OBJ_STRING,sdsnew(":1\r\n"));
956      shared.cnegone = createObject(OBJ_STRING,sdsnew(":-1\r\n"));
957      shared.nullbulk = createObject(OBJ_STRING,sdsnew("$-1\r\n"));
958      shared.nullmultibulk = createObject(OBJ_STRING,sdsnew("*-1\r\n"));
959      shared.emptymultibulk = createObject(OBJ_STRING,sdsnew("*0\r\n"));
960      shared.pong = createObject(OBJ_STRING,sdsnew("+PONG\r\n"));
961      shared.queued = createObject(OBJ_STRING,sdsnew("+QUEUED\r\n"));
962      shared.emptyscan = createObject(OBJ_STRING,sdsnew("*2\r\n$1\r\n0\r\n*0\r\n"));
963      shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(
964          "-WRONGTYPE Operation against a key holding the wrong kind of value\r\n"));
965      shared.nokeyerr = createObject(OBJ_STRING,sdsnew(
966          "-ERR no such key\r\n"));
967      shared.syntaxerr = createObject(OBJ_STRING,sdsnew(
968          "-ERR syntax error\r\n"));
969      shared.sameobjecterr = createObject(OBJ_STRING,sdsnew(
970          "-ERR source and destination objects are the same\r\n"));
971      shared.outofrangeerr = createObject(OBJ_STRING,sdsnew(
972          "-ERR index out of range\r\n"));
973      shared.noscripterr = createObject(OBJ_STRING,sdsnew(
974          "-NOSCRIPT No matching script. Please use EVAL.\r\n"));
975      shared.loadingerr = createObject(OBJ_STRING,sdsnew(
976          "-LOADING Redis is loading the dataset in memory\r\n"));
977      shared.slowscripterr = createObject(OBJ_STRING,sdsnew(
978          "-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\r\n"));
979      shared.masterdownerr = createObject(OBJ_STRING,sdsnew(
980          "-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\r\n"));
981      shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(
982          "-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\r\n"));
983      shared.roslaveerr = createObject(OBJ_STRING,sdsnew(
984          "-READONLY You can't write against a read only replica.\r\n"));
985      shared.noautherr = createObject(OBJ_STRING,sdsnew(
986          "-NOAUTH Authentication required.\r\n"));
987      shared.oomerr = createObject(OBJ_STRING,sdsnew(
988          "-OOM command not allowed when used memory > 'maxmemory'.\r\n"));
989      shared.execaborterr = createObject(OBJ_STRING,sdsnew(
990          "-EXECABORT Transaction discarded because of previous errors.\r\n"));
991      shared.noreplicaserr = createObject(OBJ_STRING,sdsnew(
992          "-NOREPLICAS Not enough good replicas to write.\r\n"));
993      shared.busykeyerr = createObject(OBJ_STRING,sdsnew(
994          "-BUSYKEY Target key name already exists.\r\n"));
995      shared.space = createObject(OBJ_STRING,sdsnew(" "));
996      shared.colon = createObject(OBJ_STRING,sdsnew(":"));
997      shared.plus = createObject(OBJ_STRING,sdsnew("+"));
998      for (j = 0; j < PROTO_SHARED_SELECT_CMDS; j++) {
999          char dictid_str[64];
1000          int dictid_len;
1001          dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);
1002          shared.select[j] = createObject(OBJ_STRING,
1003              sdscatprintf(sdsempty(),
1004                  "*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n",
1005                  dictid_len, dictid_str));
1006      }
1007      shared.messagebulk = createStringObject("$7\r\nmessage\r\n",13);
1008      shared.pmessagebulk = createStringObject("$8\r\npmessage\r\n",14);
1009      shared.subscribebulk = createStringObject("$9\r\nsubscribe\r\n",15);
1010      shared.unsubscribebulk = createStringObject("$11\r\nunsubscribe\r\n",18);
1011      shared.psubscribebulk = createStringObject("$10\r\npsubscribe\r\n",17);
1012      shared.punsubscribebulk = createStringObject("$12\r\npunsubscribe\r\n",19);
1013      shared.del = createStringObject("DEL",3);
1014      shared.unlink = createStringObject("UNLINK",6);
1015      shared.rpop = createStringObject("RPOP",4);
1016      shared.lpop = createStringObject("LPOP",4);
1017      shared.lpush = createStringObject("LPUSH",5);
1018      shared.rpoplpush = createStringObject("RPOPLPUSH",9);
1019      shared.zpopmin = createStringObject("ZPOPMIN",7);
1020      shared.zpopmax = createStringObject("ZPOPMAX",7);
1021      for (j = 0; j < OBJ_SHARED_INTEGERS; j++) {
1022          shared.integers[j] =
1023              makeObjectShared(createObject(OBJ_STRING,(void*)(PORT_LONG)j));
1024          shared.integers[j]->encoding = OBJ_ENCODING_INT;
1025      }
1026      for (j = 0; j < OBJ_SHARED_BULKHDR_LEN; j++) {
1027          shared.mbulkhdr[j] = createObject(OBJ_STRING,
1028              sdscatprintf(sdsempty(),"*%d\r\n",j));
1029          shared.bulkhdr[j] = createObject(OBJ_STRING,
1030              sdscatprintf(sdsempty(),"$%d\r\n",j));
1031      }
1032      shared.minstring = sdsnew("minstring");
1033      shared.maxstring = sdsnew("maxstring");
1034  }
1035  void initServerConfig(void) {
1036      int j;
1037  #ifdef _WIN32
1038  #pragma warning( suppress : 6031 )
1039  #endif
1040      pthread_mutex_init(&server.next_client_id_mutex,NULL);
1041  #ifdef _WIN32
1042  #pragma warning( suppress : 6031 )
1043  #endif
1044      pthread_mutex_init(&server.lruclock_mutex,NULL);
1045  #ifdef _WIN32
1046  #pragma warning( suppress : 6031 )
1047  #endif
1048      pthread_mutex_init(&server.unixtime_mutex,NULL);
1049      updateCachedTime(1);
1050      getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);
1051      server.runid[CONFIG_RUN_ID_SIZE] = '\0';
1052      changeReplicationId();
1053      clearReplicationId2();
1054      server.timezone = getTimeZone(); &bsol;* Initialized by tzset(). */
1055      server.configfile = NULL;
1056      server.executable = NULL;
1057      server.hz = server.config_hz = CONFIG_DEFAULT_HZ;
1058      server.dynamic_hz = CONFIG_DEFAULT_DYNAMIC_HZ;
1059      server.arch_bits = (sizeof(PORT_LONG) == 8) ? 64 : 32;
1060      server.port = CONFIG_DEFAULT_SERVER_PORT;
1061      server.tcp_backlog = CONFIG_DEFAULT_TCP_BACKLOG;
1062      server.bindaddr_count = 0;
1063      server.unixsocket = NULL;
1064      server.unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM;
1065      server.ipfd_count = 0;
1066      server.sofd = -1;
1067      server.protected_mode = CONFIG_DEFAULT_PROTECTED_MODE;
1068      server.dbnum = CONFIG_DEFAULT_DBNUM;
1069      server.verbosity = CONFIG_DEFAULT_VERBOSITY;
1070      WIN32_ONLY(setLogVerbosityLevel(server.verbosity);)
1071      server.maxidletime = CONFIG_DEFAULT_CLIENT_TIMEOUT;
1072      server.tcpkeepalive = CONFIG_DEFAULT_TCP_KEEPALIVE;
1073      server.active_expire_enabled = 1;
1074      server.active_defrag_enabled = CONFIG_DEFAULT_ACTIVE_DEFRAG;
1075      server.active_defrag_ignore_bytes = CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES;
1076      server.active_defrag_threshold_lower = CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER;
1077      server.active_defrag_threshold_upper = CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER;
1078      server.active_defrag_cycle_min = CONFIG_DEFAULT_DEFRAG_CYCLE_MIN;
1079      server.active_defrag_cycle_max = CONFIG_DEFAULT_DEFRAG_CYCLE_MAX;
1080      server.active_defrag_max_scan_fields = CONFIG_DEFAULT_DEFRAG_MAX_SCAN_FIELDS;
1081      server.proto_max_bulk_len = CONFIG_DEFAULT_PROTO_MAX_BULK_LEN;
1082      server.client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN;
1083      server.saveparams = NULL;
1084      server.loading = 0;
1085      server.logfile = zstrdup(CONFIG_DEFAULT_LOGFILE);
1086      server.syslog_enabled = CONFIG_DEFAULT_SYSLOG_ENABLED;
1087      server.syslog_ident = zstrdup(CONFIG_DEFAULT_SYSLOG_IDENT);
1088      POSIX_ONLY(server.syslog_facility = LOG_LOCAL0;)
1089      server.daemonize = CONFIG_DEFAULT_DAEMONIZE;
1090      server.supervised = 0;
1091      server.supervised_mode = SUPERVISED_NONE;
1092      server.aof_state = AOF_OFF;
1093      server.aof_fsync = CONFIG_DEFAULT_AOF_FSYNC;
1094      server.aof_no_fsync_on_rewrite = CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE;
1095      server.aof_rewrite_perc = AOF_REWRITE_PERC;
1096      server.aof_rewrite_min_size = AOF_REWRITE_MIN_SIZE;
1097      server.aof_rewrite_base_size = 0;
1098      server.aof_rewrite_scheduled = 0;
1099      server.aof_last_fsync = time(NULL);
1100      server.aof_rewrite_time_last = -1;
1101      server.aof_rewrite_time_start = -1;
1102      server.aof_lastbgrewrite_status = C_OK;
1103      server.aof_delayed_fsync = 0;
1104      server.aof_fd = -1;
1105      server.aof_selected_db = -1; &bsol;* Make sure the first time will not match */
1106      server.aof_flush_postponed_start = 0;
1107      server.aof_rewrite_incremental_fsync = CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC;
1108      server.rdb_save_incremental_fsync = CONFIG_DEFAULT_RDB_SAVE_INCREMENTAL_FSYNC;
1109      server.aof_load_truncated = CONFIG_DEFAULT_AOF_LOAD_TRUNCATED;
1110      server.aof_use_rdb_preamble = CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE;
1111      server.pidfile = NULL;
1112      server.rdb_filename = zstrdup(CONFIG_DEFAULT_RDB_FILENAME);
1113      server.aof_filename = zstrdup(CONFIG_DEFAULT_AOF_FILENAME);
1114      server.requirepass = NULL;
1115      server.rdb_compression = CONFIG_DEFAULT_RDB_COMPRESSION;
1116      server.rdb_checksum = CONFIG_DEFAULT_RDB_CHECKSUM;
1117      server.stop_writes_on_bgsave_err = CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR;
1118      server.activerehashing = CONFIG_DEFAULT_ACTIVE_REHASHING;
1119      server.active_defrag_running = 0;
1120      server.notify_keyspace_events = 0;
1121      server.maxclients = CONFIG_DEFAULT_MAX_CLIENTS;
1122      server.blocked_clients = 0;
1123      memset(server.blocked_clients_by_type,0,
1124             sizeof(server.blocked_clients_by_type));
1125      server.maxmemory = CONFIG_DEFAULT_MAXMEMORY;
1126      server.maxmemory_policy = CONFIG_DEFAULT_MAXMEMORY_POLICY;
1127      server.maxmemory_samples = CONFIG_DEFAULT_MAXMEMORY_SAMPLES;
1128      server.lfu_log_factor = CONFIG_DEFAULT_LFU_LOG_FACTOR;
1129      server.lfu_decay_time = CONFIG_DEFAULT_LFU_DECAY_TIME;
1130      server.hash_max_ziplist_entries = OBJ_HASH_MAX_ZIPLIST_ENTRIES;
1131      server.hash_max_ziplist_value = OBJ_HASH_MAX_ZIPLIST_VALUE;
1132      server.list_max_ziplist_size = OBJ_LIST_MAX_ZIPLIST_SIZE;
1133      server.list_compress_depth = OBJ_LIST_COMPRESS_DEPTH;
1134      server.set_max_intset_entries = OBJ_SET_MAX_INTSET_ENTRIES;
1135      server.zset_max_ziplist_entries = OBJ_ZSET_MAX_ZIPLIST_ENTRIES;
1136      server.zset_max_ziplist_value = OBJ_ZSET_MAX_ZIPLIST_VALUE;
1137      server.hll_sparse_max_bytes = CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES;
1138      server.stream_node_max_bytes = OBJ_STREAM_NODE_MAX_BYTES;
1139      server.stream_node_max_entries = OBJ_STREAM_NODE_MAX_ENTRIES;
1140      server.shutdown_asap = 0;
1141      server.cluster_enabled = 0;
1142      server.cluster_node_timeout = CLUSTER_DEFAULT_NODE_TIMEOUT;
1143      server.cluster_migration_barrier = CLUSTER_DEFAULT_MIGRATION_BARRIER;
1144      server.cluster_slave_validity_factor = CLUSTER_DEFAULT_SLAVE_VALIDITY;
1145      server.cluster_require_full_coverage = CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE;
1146      server.cluster_slave_no_failover = CLUSTER_DEFAULT_SLAVE_NO_FAILOVER;
1147      server.cluster_configfile = zstrdup(CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);
1148      server.cluster_announce_ip = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP;
1149      server.cluster_announce_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT;
1150      server.cluster_announce_bus_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT;
1151      server.cluster_module_flags = CLUSTER_MODULE_FLAG_NONE;
1152      server.migrate_cached_sockets = dictCreate(&migrateCacheDictType,NULL);
1153      server.next_client_id = 1; &bsol;* Client IDs, start from 1 .*/
1154      server.loading_process_events_interval_bytes = (1024*1024*2);
1155      server.lazyfree_lazy_eviction = CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION;
1156      server.lazyfree_lazy_expire = CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE;
1157      server.lazyfree_lazy_server_del = CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL;
1158      server.always_show_logo = CONFIG_DEFAULT_ALWAYS_SHOW_LOGO;
1159      server.lua_time_limit = LUA_SCRIPT_TIME_LIMIT;
1160      unsigned int lruclock = getLRUClock();
1161      atomicSet(server.lruclock,lruclock);
1162      resetServerSaveParams();
1163      appendServerSaveParams(60*60,1);  &bsol;* save after 1 hour and 1 change */
1164      appendServerSaveParams(300,100);  &bsol;* save after 5 minutes and 100 changes */
1165      appendServerSaveParams(60,10000); &bsol;* save after 1 minute and 10000 changes */
1166      server.masterauth = NULL;
1167      server.masterhost = NULL;
1168      server.masterport = 6379;
1169      server.master = NULL;
1170      server.cached_master = NULL;
1171      server.master_initial_offset = -1;
1172      server.repl_state = REPL_STATE_NONE;
1173      server.repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT;
1174      server.repl_serve_stale_data = CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA;
1175      server.repl_slave_ro = CONFIG_DEFAULT_SLAVE_READ_ONLY;
1176      server.repl_slave_ignore_maxmemory = CONFIG_DEFAULT_SLAVE_IGNORE_MAXMEMORY;
1177      server.repl_slave_lazy_flush = CONFIG_DEFAULT_SLAVE_LAZY_FLUSH;
1178      server.repl_down_since = 0; &bsol;* Never connected, repl is down since EVER. */
1179      server.repl_disable_tcp_nodelay = CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY;
1180      server.repl_diskless_sync = CONFIG_DEFAULT_REPL_DISKLESS_SYNC;
1181      server.repl_diskless_sync_delay = CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY;
1182      server.repl_ping_slave_period = CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD;
1183      server.repl_timeout = CONFIG_DEFAULT_REPL_TIMEOUT;
1184      server.repl_min_slaves_to_write = CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE;
1185      server.repl_min_slaves_max_lag = CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG;
1186      server.slave_priority = CONFIG_DEFAULT_SLAVE_PRIORITY;
1187      server.slave_announce_ip = CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP;
1188      server.slave_announce_port = CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT;
1189      server.master_repl_offset = 0;
1190      server.repl_backlog = NULL;
1191      server.repl_backlog_size = CONFIG_DEFAULT_REPL_BACKLOG_SIZE;
1192      server.repl_backlog_histlen = 0;
1193      server.repl_backlog_idx = 0;
1194      server.repl_backlog_off = 0;
1195      server.repl_backlog_time_limit = CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT;
1196      server.repl_no_slaves_since = time(NULL);
1197      for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++)
1198          server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];
1199      R_Zero = 0.0;
1200      R_PosInf = 1.0/R_Zero;
1201      R_NegInf = -1.0/R_Zero;
1202      R_Nan = R_Zero/R_Zero;
1203      server.commands = dictCreate(&commandTableDictType,NULL);
1204      server.orig_commands = dictCreate(&commandTableDictType,NULL);
1205      populateCommandTable();
1206      server.delCommand = lookupCommandByCString("del");
1207      server.multiCommand = lookupCommandByCString("multi");
1208      server.lpushCommand = lookupCommandByCString("lpush");
1209      server.lpopCommand = lookupCommandByCString("lpop");
1210      server.rpopCommand = lookupCommandByCString("rpop");
1211      server.zpopminCommand = lookupCommandByCString("zpopmin");
1212      server.zpopmaxCommand = lookupCommandByCString("zpopmax");
1213      server.sremCommand = lookupCommandByCString("srem");
1214      server.execCommand = lookupCommandByCString("exec");
1215      server.expireCommand = lookupCommandByCString("expire");
1216      server.pexpireCommand = lookupCommandByCString("pexpire");
1217      server.xclaimCommand = lookupCommandByCString("xclaim");
1218      server.xgroupCommand = lookupCommandByCString("xgroup");
1219      server.slowlog_log_slower_than = CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN;
1220      server.slowlog_max_len = CONFIG_DEFAULT_SLOWLOG_MAX_LEN;
1221      server.latency_monitor_threshold = CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD;
1222      server.assert_failed = "<no assertion failed>";
1223      server.assert_file = "<no file>";
1224      server.assert_line = 0;
1225      server.bug_report_start = 0;
1226      server.watchdog_period = 0;
1227      server.lua_always_replicate_commands = 1;
1228  }
1229  extern char **environ;
1230  int restartServer(int flags, mstime_t delay) {
1231      int j;
1232      if (access(server.executable,X_OK) == -1) {
1233          serverLog(LL_WARNING,"Can't restart: this process has no "
1234                               "permissions to execute %s", server.executable);
1235          return C_ERR;
1236      }
1237      if (flags & RESTART_SERVER_CONFIG_REWRITE &&
1238          server.configfile &&
1239          rewriteConfig(server.configfile) == -1)
1240      {
1241          serverLog(LL_WARNING,"Can't restart: configuration rewrite process "
1242                               "failed");
1243          return C_ERR;
1244      }
1245      if (flags & RESTART_SERVER_GRACEFULLY &&
1246          prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)
1247      {
1248          serverLog(LL_WARNING,"Can't restart: error preparing for shutdown");
1249          return C_ERR;
1250      }
1251      for (j = 3; j < (int)server.maxclients + 1024; j++) {
1252  #if _WIN32
1253          if (fcntl(j, F_GETFL, 0) != -1) close(j);
1254  #else
1255          if (fcntl(j,F_GETFD) != -1) close(j);
1256  #endif
1257      }
1258      if (delay) usleep(delay*1000);
1259      zfree(server.exec_argv[0]);
1260      server.exec_argv[0] = zstrdup(server.executable);
1261      IF_WIN32(_execve,execve)(server.executable,server.exec_argv,environ);
1262      _exit(1);
1263      return C_ERR; &bsol;* Never reached. */
1264  }
1265  void adjustOpenFilesLimit(void) {
1266  #ifndef _WIN32
1267      rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;
1268      struct rlimit limit;
1269      if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {
1270          serverLog(LL_WARNING,"Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.",
1271              strerror(errno));
1272          server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;
1273      } else {
1274          rlim_t oldlimit = limit.rlim_cur;
1275          if (oldlimit < maxfiles) {
1276              rlim_t bestlimit;
1277              int setrlimit_error = 0;
1278              bestlimit = maxfiles;
1279              while(bestlimit > oldlimit) {
1280                  rlim_t decr_step = 16;
1281                  limit.rlim_cur = bestlimit;
1282                  limit.rlim_max = bestlimit;
1283                  if (setrlimit(RLIMIT_NOFILE,&limit) != -1) break;
1284                  setrlimit_error = errno;
1285                  if (bestlimit < decr_step) break;
1286                  bestlimit -= decr_step;
1287              }
1288              if (bestlimit < oldlimit) bestlimit = oldlimit;
1289              if (bestlimit < maxfiles) {
1290                  unsigned int old_maxclients = server.maxclients;
1291                  server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;
1292                  if (bestlimit <= CONFIG_MIN_RESERVED_FDS) {
1293                      serverLog(LL_WARNING,"Your current 'ulimit -n' "
1294                          "of %llu is not enough for the server to start. "
1295                          "Please increase your open file limit to at least "
1296                          "%llu. Exiting.",
1297                          (PORT_ULONGLONG) oldlimit,
1298                          (PORT_ULONGLONG) maxfiles);
1299                      exit(1);
1300                  }
1301                  serverLog(LL_WARNING,"You requested maxclients of %d "
1302                      "requiring at least %llu max file descriptors.",
1303                      old_maxclients,
1304                      (PORT_ULONGLONG) maxfiles);
1305                  serverLog(LL_WARNING,"Server can't set maximum open files "
1306                      "to %llu because of OS error: %s.",
1307                      (PORT_ULONGLONG) maxfiles, strerror(setrlimit_error));
1308                  serverLog(LL_WARNING,"Current maximum open files is %llu. "
1309                      "maxclients has been reduced to %d to compensate for "
1310                      "low ulimit. "
1311                      "If you need higher maxclients increase 'ulimit -n'.",
1312                      (PORT_ULONGLONG) bestlimit, server.maxclients);
1313              } else {
1314                  serverLog(LL_NOTICE,"Increased maximum number of open files "
1315                      "to %llu (it was originally set to %llu).",
1316                      (PORT_ULONGLONG) maxfiles,
1317                      (PORT_ULONGLONG) oldlimit);
1318              }
1319          }
1320      }
1321  #endif
1322  }
1323  void checkTcpBacklogSettings(void) {
1324  #ifdef HAVE_PROC_SOMAXCONN
1325      FILE *fp = fopen("/proc/sys/net/core/somaxconn","r");
1326      char buf[1024];
1327      if (!fp) return;
1328      if (fgets(buf,sizeof(buf),fp) != NULL) {
1329          int somaxconn = atoi(buf);
1330          if (somaxconn > 0 && somaxconn < server.tcp_backlog) {
1331              serverLog(LL_WARNING,"WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.", server.tcp_backlog, somaxconn);
1332          }
1333      }
1334      fclose(fp);
1335  #endif
1336  }
1337  int listenToPort(int port, int *fds, int *count) {
1338      int j;
1339      if (server.bindaddr_count == 0) server.bindaddr[0] = NULL;
1340      for (j = 0; j < server.bindaddr_count || j == 0; j++) {
1341          if (server.bindaddr[j] == NULL) {
1342              int unsupported = 0;
1343              fds[*count] = anetTcp6Server(server.neterr,port,NULL,
1344                  server.tcp_backlog);
1345              if (fds[*count] != ANET_ERR) {
1346                  anetNonBlock(NULL,fds[*count]);
1347                  (*count)++;
1348              } else if (errno == EAFNOSUPPORT) {
1349                  unsupported++;
1350                  serverLog(LL_WARNING,"Not listening to IPv6: unsupproted");
1351              }
1352              if (*count == 1 || unsupported) {
1353                  fds[*count] = anetTcpServer(server.neterr,port,NULL,
1354                      server.tcp_backlog);
1355                  if (fds[*count] != ANET_ERR) {
1356                      anetNonBlock(NULL,fds[*count]);
1357                      (*count)++;
1358                  } else if (errno == EAFNOSUPPORT) {
1359                      unsupported++;
1360                      serverLog(LL_WARNING,"Not listening to IPv4: unsupproted");
1361                  }
1362              }
1363              if (*count + unsupported == 2) break;
1364          } else if (strchr(server.bindaddr[j],':')) {
1365              fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],
1366                  server.tcp_backlog);
1367          } else {
1368              fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],
1369                  server.tcp_backlog);
1370          }
1371          if (fds[*count] == ANET_ERR) {
1372              serverLog(LL_WARNING,
1373                  "Could not create server TCP listening socket %s:%d: %s",
1374                  server.bindaddr[j] ? server.bindaddr[j] : "*",
1375                  port, server.neterr);
1376                  if (errno == ENOPROTOOPT     || errno == EPROTONOSUPPORT ||
1377                      errno == ESOCKTNOSUPPORT || errno == EPFNOSUPPORT ||
1378                      errno == EAFNOSUPPORT    || errno == EADDRNOTAVAIL)
1379                      continue;
1380              return C_ERR;
1381          }
1382          anetNonBlock(NULL,fds[*count]);
1383          (*count)++;
1384      }
1385      return C_OK;
1386  }
1387  void resetServerStats(void) {
1388      int j;
1389      server.stat_numcommands = 0;
1390      server.stat_numconnections = 0;
1391      server.stat_expiredkeys = 0;
1392      server.stat_expired_stale_perc = 0;
1393      server.stat_expired_time_cap_reached_count = 0;
1394      server.stat_evictedkeys = 0;
1395      server.stat_keyspace_misses = 0;
1396      server.stat_keyspace_hits = 0;
1397      server.stat_active_defrag_hits = 0;
1398      server.stat_active_defrag_misses = 0;
1399      server.stat_active_defrag_key_hits = 0;
1400      server.stat_active_defrag_key_misses = 0;
1401      server.stat_active_defrag_scanned = 0;
1402      server.stat_fork_time = 0;
1403      server.stat_fork_rate = 0;
1404      server.stat_rejected_conn = 0;
1405      server.stat_sync_full = 0;
1406      server.stat_sync_partial_ok = 0;
1407      server.stat_sync_partial_err = 0;
1408      for (j = 0; j < STATS_METRIC_COUNT; j++) {
1409          server.inst_metric[j].idx = 0;
1410          server.inst_metric[j].last_sample_time = mstime();
1411          server.inst_metric[j].last_sample_count = 0;
1412          memset(server.inst_metric[j].samples,0,
1413              sizeof(server.inst_metric[j].samples));
1414      }
1415      server.stat_net_input_bytes = 0;
1416      server.stat_net_output_bytes = 0;
1417      server.aof_delayed_fsync = 0;
1418  }
1419  void initServer(void) {
1420      int j;
1421      WIN32_ONLY(HMODULE lib;)
1422      signal(SIGHUP, SIG_IGN);
1423      signal(SIGPIPE, SIG_IGN);
1424      setupSignalHandlers();
1425  #ifdef _WIN32
1426      _fmode = _O_BINARY;
1427      setmode(_fileno(stdin), _O_BINARY);
1428      setmode(_fileno(stdout), _O_BINARY);
1429      setmode(_fileno(stderr), _O_BINARY);
1430      setlocale(LC_ALL, "C");
1431      lib = LoadLibraryA("advapi32.dll");
1432      RtlGenRandom = (RtlGenRandomFunc) GetProcAddress(lib, "SystemFunction036");
1433  #else
1434      if (server.syslog_enabled) {
1435          openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,
1436              server.syslog_facility);
1437      }
1438  #endif
1439      server.hz = server.config_hz;
1440      server.pid = getpid();
1441      server.current_client = NULL;
1442      server.fixed_time_expire = 0;
1443      server.clients = listCreate();
1444      server.clients_index = raxNew();
1445      server.clients_to_close = listCreate();
1446      server.slaves = listCreate();
1447      server.monitors = listCreate();
1448      server.clients_pending_write = listCreate();
1449      server.slaveseldb = -1; &bsol;* Force to emit the first SELECT command. */
1450      server.unblocked_clients = listCreate();
1451      server.ready_keys = listCreate();
1452      server.clients_waiting_acks = listCreate();
1453      server.get_ack_from_slaves = 0;
1454      server.clients_paused = 0;
1455      server.system_memory_size = zmalloc_get_memory_size();
1456      createSharedObjects();
1457      adjustOpenFilesLimit();
1458      server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);
1459      if (server.el == NULL) {
1460          serverLog(LL_WARNING,
1461              "Failed creating the event loop. Error message: '%s'",
1462              IF_WIN32(wsa_strerror(errno), strerror(errno)));
1463          exit(1);
1464      }
1465      server.db = zmalloc(sizeof(redisDb)*server.dbnum);
1466      if (server.port != 0 &&
1467          listenToPort(server.port,server.ipfd,&server.ipfd_count) == C_ERR)
1468          exit(1);
1469      if (server.unixsocket != NULL) {
1470          unlink(server.unixsocket); &bsol;* don't care if this fails */
1471          server.sofd = anetUnixServer(server.neterr,server.unixsocket,
1472              server.unixsocketperm, server.tcp_backlog);
1473          if (server.sofd == ANET_ERR) {
1474              serverLog(LL_WARNING, "Opening Unix socket: %s", server.neterr);
1475              exit(1);
1476          }
1477          anetNonBlock(NULL,server.sofd);
1478      }
1479      if (server.ipfd_count == 0 && server.sofd < 0) {
1480          serverLog(LL_WARNING, "Configured to not listen anywhere, exiting.");
1481          exit(1);
1482      }
1483      for (j = 0; j < server.dbnum; j++) {
1484          server.db[j].dict = dictCreate(&dbDictType,NULL);
1485          server.db[j].expires = dictCreate(&keyptrDictType,NULL);
1486          server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);
1487          server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);
1488          server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);
1489          server.db[j].id = j;
1490          server.db[j].avg_ttl = 0;
1491          server.db[j].defrag_later = listCreate();
1492      }
1493      evictionPoolAlloc(); &bsol;* Initialize the LRU keys pool. */
1494      server.pubsub_channels = dictCreate(&keylistDictType,NULL);
1495      server.pubsub_patterns = listCreate();
1496      listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);
1497      listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);
1498      server.cronloops = 0;
1499      server.rdb_child_pid = -1;
1500      server.aof_child_pid = -1;
1501      server.rdb_child_type = RDB_CHILD_TYPE_NONE;
1502      server.rdb_bgsave_scheduled = 0;
1503      server.child_info_pipe[0] = -1;
1504      server.child_info_pipe[1] = -1;
1505      server.child_info_data.magic = 0;
1506      aofRewriteBufferReset();
1507      server.aof_buf = sdsempty();
1508      server.lastsave = time(NULL); &bsol;* At startup we consider the DB saved. */
1509      server.lastbgsave_try = 0;    &bsol;* At startup we never tried to BGSAVE. */
1510      server.rdb_save_time_last = -1;
1511      server.rdb_save_time_start = -1;
1512      server.dirty = 0;
1513      resetServerStats();
1514      server.stat_starttime = time(NULL);
1515      server.stat_peak_memory = 0;
1516      server.stat_rdb_cow_bytes = 0;
1517      server.stat_aof_cow_bytes = 0;
1518      server.cron_malloc_stats.zmalloc_used = 0;
1519      server.cron_malloc_stats.process_rss = 0;
1520      server.cron_malloc_stats.allocator_allocated = 0;
1521      server.cron_malloc_stats.allocator_active = 0;
1522      server.cron_malloc_stats.allocator_resident = 0;
1523      server.lastbgsave_status = C_OK;
1524      server.aof_last_write_status = C_OK;
1525      server.aof_last_write_errno = 0;
1526      server.repl_good_slaves_count = 0;
1527      if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
1528          serverPanic("Can't create event loop timers.");
1529          exit(1);
1530      }
1531      for (j = 0; j < server.ipfd_count; j++) {
1532          if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,
1533              acceptTcpHandler,NULL) == AE_ERR)
1534              {
1535                  serverPanic(
1536                      "Unrecoverable error creating server.ipfd file event.");
1537              }
1538      }
1539      if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,
1540          acceptUnixHandler,NULL) == AE_ERR) serverPanic("Unrecoverable error creating server.sofd file event.");
1541      if (aeCreateFileEvent(server.el, server.module_blocked_pipe[0], AE_READABLE,
1542          moduleBlockedClientPipeReadable,NULL) == AE_ERR) {
1543              serverPanic(
1544                  "Error registering the readable event for the module "
1545                  "blocked clients subsystem.");
1546      }
1547      if (server.aof_state == AOF_ON) {
1548  #ifdef _WIN32
1549          server.aof_fd = open(server.aof_filename,
1550              O_WRONLY | O_APPEND | O_CREAT | _O_BINARY, _S_IREAD | _S_IWRITE);
1551  #else
1552          server.aof_fd = open(server.aof_filename,
1553                                 O_WRONLY|O_APPEND|O_CREAT,0644);
1554  #endif
1555          if (server.aof_fd == -1) {
1556              serverLog(LL_WARNING, "Can't open the append-only file: %s",
1557                  IF_WIN32(wsa_strerror(errno), strerror(errno)));
1558              exit(1);
1559          }
1560      }
1561      if (server.arch_bits == 32 && server.maxmemory == 0) {
1562          serverLog(LL_WARNING,"Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.");
1563          server.maxmemory = 3072LL*(1024*1024); &bsol;* 3 GB */
1564          server.maxmemory_policy = MAXMEMORY_NO_EVICTION;
1565      }
1566      if (server.cluster_enabled) clusterInit();
1567      replicationScriptCacheInit();
1568      scriptingInit(1);
1569      slowlogInit();
1570      latencyMonitorInit();
1571  }
1572  void InitServerLast() {
1573      bioInit();
1574      server.initial_memory_usage = zmalloc_used_memory();
1575  }
1576  void populateCommandTable(void) {
1577      int j;
1578      int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);
1579      for (j = 0; j < numcommands; j++) {
1580          struct redisCommand *c = redisCommandTable+j;
1581          char *f = c->sflags;
1582          int retval1, retval2;
1583          while(*f != '\0') {
1584              switch(*f) {
1585              case 'w': c->flags |= CMD_WRITE; break;
1586              case 'r': c->flags |= CMD_READONLY; break;
1587              case 'm': c->flags |= CMD_DENYOOM; break;
1588              case 'a': c->flags |= CMD_ADMIN; break;
1589              case 'p': c->flags |= CMD_PUBSUB; break;
1590              case 's': c->flags |= CMD_NOSCRIPT; break;
1591              case 'R': c->flags |= CMD_RANDOM; break;
1592              case 'S': c->flags |= CMD_SORT_FOR_SCRIPT; break;
1593              case 'l': c->flags |= CMD_LOADING; break;
1594              case 't': c->flags |= CMD_STALE; break;
1595              case 'M': c->flags |= CMD_SKIP_MONITOR; break;
1596              case 'k': c->flags |= CMD_ASKING; break;
1597              case 'F': c->flags |= CMD_FAST; break;
1598              default: serverPanic("Unsupported command flag"); break;
1599              }
1600              f++;
1601          }
1602          retval1 = dictAdd(server.commands, sdsnew(c->name), c);
1603          retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);
1604          serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
1605      }
1606  }
1607  void resetCommandTableStats(void) {
1608      struct redisCommand *c;
1609      dictEntry *de;
1610      dictIterator *di;
1611      di = dictGetSafeIterator(server.commands);
1612      while((de = dictNext(di)) != NULL) {
1613          c = (struct redisCommand *) dictGetVal(de);
1614          c->microseconds = 0;
1615          c->calls = 0;
1616      }
1617      dictReleaseIterator(di);
1618  }
1619  void redisOpArrayInit(redisOpArray *oa) {
1620      oa->ops = NULL;
1621      oa->numops = 0;
1622  }
1623  int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,
1624                         robj **argv, int argc, int target)
1625  {
1626      redisOp *op;
1627      oa->ops = zrealloc(oa->ops,sizeof(redisOp)*((PORT_ULONG)oa->numops+1));  WIN_PORT_FIX &bsol;* cast (PORT_ULONG) */
1628      op = oa->ops+oa->numops;
1629      op->cmd = cmd;
1630      op->dbid = dbid;
1631      op->argv = argv;
1632      op->argc = argc;
1633      op->target = target;
1634      oa->numops++;
1635      return oa->numops;
1636  }
1637  void redisOpArrayFree(redisOpArray *oa) {
1638      while(oa->numops) {
1639          int j;
1640          redisOp *op;
1641          oa->numops--;
1642          op = oa->ops+oa->numops;
1643          for (j = 0; j < op->argc; j++)
1644              decrRefCount(op->argv[j]);
1645          zfree(op->argv);
1646      }
1647      zfree(oa->ops);
1648  }
1649  struct redisCommand *lookupCommand(sds name) {
1650      return dictFetchValue(server.commands, name);
1651  }
1652  struct redisCommand *lookupCommandByCString(char *s) {
1653      struct redisCommand *cmd;
1654      sds name = sdsnew(s);
1655      cmd = dictFetchValue(server.commands, name);
1656      sdsfree(name);
1657      return cmd;
1658  }
1659  struct redisCommand *lookupCommandOrOriginal(sds name) {
1660      struct redisCommand *cmd = dictFetchValue(server.commands, name);
1661      if (!cmd) cmd = dictFetchValue(server.orig_commands,name);
1662      return cmd;
1663  }
1664  void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
1665                 int flags)
1666  {
1667      if (server.aof_state != AOF_OFF && flags & PROPAGATE_AOF)
1668          feedAppendOnlyFile(cmd,dbid,argv,argc);
1669      if (flags & PROPAGATE_REPL)
1670          replicationFeedSlaves(server.slaves,dbid,argv,argc);
1671  }
1672  void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,
1673                     int target)
1674  {
1675      robj **argvcopy;
1676      int j;
1677      if (server.loading) return; &bsol;* No propagation during loading. */
1678      argvcopy = zmalloc(sizeof(robj*)*argc);
1679      for (j = 0; j < argc; j++) {
1680          argvcopy[j] = argv[j];
1681          incrRefCount(argv[j]);
1682      }
1683      redisOpArrayAppend(&server.also_propagate,cmd,dbid,argvcopy,argc,target);
1684  }
1685  void forceCommandPropagation(client *c, int flags) {
1686      if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;
1687      if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;
1688  }
1689  void preventCommandPropagation(client *c) {
1690      c->flags |= CLIENT_PREVENT_PROP;
1691  }
1692  void preventCommandAOF(client *c) {
1693      c->flags |= CLIENT_PREVENT_AOF_PROP;
1694  }
1695  void preventCommandReplication(client *c) {
1696      c->flags |= CLIENT_PREVENT_REPL_PROP;
1697  }
1698  void call(client *c, int flags) {
1699      PORT_LONGLONG dirty;
1700      ustime_t start, duration;
1701      int client_old_flags = c->flags;
1702      struct redisCommand *real_cmd = c->cmd;
1703      server.fixed_time_expire++;
1704      if (listLength(server.monitors) &&
1705          !server.loading &&
1706          !(c->cmd->flags & (CMD_SKIP_MONITOR|CMD_ADMIN)))
1707      {
1708          replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
1709      }
1710      c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
1711      redisOpArray prev_also_propagate = server.also_propagate;
1712      redisOpArrayInit(&server.also_propagate);
1713      dirty = server.dirty;
1714      updateCachedTime(0);
1715      start = server.ustime;
1716      c->cmd->proc(c);
1717      duration = ustime()-start;
1718      dirty = server.dirty-dirty;
1719      if (dirty < 0) dirty = 0;
1720      if (server.loading && c->flags & CLIENT_LUA)
1721          flags &= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);
1722      if (c->flags & CLIENT_LUA && server.lua_caller) {
1723          if (c->flags & CLIENT_FORCE_REPL)
1724              server.lua_caller->flags |= CLIENT_FORCE_REPL;
1725          if (c->flags & CLIENT_FORCE_AOF)
1726              server.lua_caller->flags |= CLIENT_FORCE_AOF;
1727      }
1728      if (flags & CMD_CALL_SLOWLOG && c->cmd->proc != execCommand) {
1729          char *latency_event = (c->cmd->flags & CMD_FAST) ?
1730                                "fast-command" : "command";
1731          latencyAddSampleIfNeeded(latency_event,duration/1000);
1732          slowlogPushEntryIfNeeded(c,c->argv,c->argc,duration);
1733      }
1734      if (flags & CMD_CALL_STATS) {
1735          real_cmd->microseconds += duration;
1736          real_cmd->calls++;
1737      }
1738      if (flags & CMD_CALL_PROPAGATE &&
1739          (c->flags & CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)
1740      {
1741          int propagate_flags = PROPAGATE_NONE;
1742          if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);
1743          if (c->flags & CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;
1744          if (c->flags & CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;
1745          if (c->flags & CLIENT_PREVENT_REPL_PROP ||
1746              !(flags & CMD_CALL_PROPAGATE_REPL))
1747                  propagate_flags &= ~PROPAGATE_REPL;
1748          if (c->flags & CLIENT_PREVENT_AOF_PROP ||
1749              !(flags & CMD_CALL_PROPAGATE_AOF))
1750                  propagate_flags &= ~PROPAGATE_AOF;
1751          if (propagate_flags != PROPAGATE_NONE && !(c->cmd->flags & CMD_MODULE))
1752              propagate(c->cmd,c->db->id,c->argv,c->argc,propagate_flags);
1753      }
1754      c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
1755      c->flags |= client_old_flags &
1756          (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
1757      if (server.also_propagate.numops) {
1758          int j;
1759          redisOp *rop;
1760          if (flags & CMD_CALL_PROPAGATE) {
1761              for (j = 0; j < server.also_propagate.numops; j++) {
1762                  rop = &server.also_propagate.ops[j];
1763                  int target = rop->target;
1764                  if (!(flags&CMD_CALL_PROPAGATE_AOF)) target &= ~PROPAGATE_AOF;
1765                  if (!(flags&CMD_CALL_PROPAGATE_REPL)) target &= ~PROPAGATE_REPL;
1766                  if (target)
1767                      propagate(rop->cmd,rop->dbid,rop->argv,rop->argc,target);
1768              }
1769          }
1770          redisOpArrayFree(&server.also_propagate);
1771      }
1772      server.also_propagate = prev_also_propagate;
1773      server.fixed_time_expire--;
1774      server.stat_numcommands++;
1775  }
1776  int processCommand(client *c) {
1777      moduleCallCommandFilters(c);
1778      if (!strcasecmp(c->argv[0]->ptr,"quit")) {
1779          addReply(c,shared.ok);
1780          c->flags |= CLIENT_CLOSE_AFTER_REPLY;
1781          return C_ERR;
1782      }
1783      c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);
1784      if (!c->cmd) {
1785          flagTransaction(c);
1786          sds args = sdsempty();
1787          int i;
1788          for (i=1; i < c->argc && sdslen(args) < 128; i++)
1789              args = sdscatprintf(args, "`%.*s`, ", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
1790          addReplyErrorFormat(c,"unknown command `%s`, with args beginning with: %s",
1791              (char*)c->argv[0]->ptr, args);
1792          sdsfree(args);
1793          return C_OK;
1794      } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
1795                 (c->argc < -c->cmd->arity)) {
1796          flagTransaction(c);
1797          addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
1798              c->cmd->name);
1799          return C_OK;
1800      }
1801      if (server.requirepass && !c->authenticated && c->cmd->proc != authCommand)
1802      {
1803          flagTransaction(c);
1804          addReply(c,shared.noautherr);
1805          return C_OK;
1806      }
1807      if (server.cluster_enabled &&
1808          !(c->flags & CLIENT_MASTER) &&
1809          !(c->flags & CLIENT_LUA &&
1810            server.lua_caller->flags & CLIENT_MASTER) &&
1811          !(c->cmd->getkeys_proc == NULL && c->cmd->firstkey == 0 &&
1812            c->cmd->proc != execCommand))
1813      {
1814          int hashslot;
1815          int error_code;
1816          clusterNode *n = getNodeByQuery(c,c->cmd,c->argv,c->argc,
1817                                          &hashslot,&error_code);
1818          if (n == NULL || n != server.cluster->myself) {
1819              if (c->cmd->proc == execCommand) {
1820                  discardTransaction(c);
1821              } else {
1822                  flagTransaction(c);
1823              }
1824              clusterRedirectClient(c,n,hashslot,error_code);
1825              return C_OK;
1826          }
1827      }
1828      if (server.maxmemory && !server.lua_timedout) {
1829          int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;
1830          if (server.current_client == NULL) return C_ERR;
1831          if (out_of_memory &&
1832              (c->cmd->flags & CMD_DENYOOM ||
1833               (c->flags & CLIENT_MULTI && c->cmd->proc != execCommand))) {
1834              flagTransaction(c);
1835              addReply(c, shared.oomerr);
1836              return C_OK;
1837          }
1838          if (c->cmd->proc == evalCommand || c->cmd->proc == evalShaCommand) {
1839              server.lua_oom = out_of_memory;
1840          }
1841      }
1842      int deny_write_type = writeCommandsDeniedByDiskError();
1843      if (deny_write_type != DISK_ERROR_TYPE_NONE &&
1844          server.masterhost == NULL &&
1845          (c->cmd->flags & CMD_WRITE ||
1846           c->cmd->proc == pingCommand))
1847      {
1848          flagTransaction(c);
1849          if (deny_write_type == DISK_ERROR_TYPE_RDB)
1850              addReply(c, shared.bgsaveerr);
1851          else
1852              addReplySds(c,
1853                  sdscatprintf(sdsempty(),
1854                  "-MISCONF Errors writing to the AOF file: %s\r\n",
1855                  strerror(server.aof_last_write_errno)));
1856          return C_OK;
1857      }
1858      if (server.masterhost == NULL &&
1859          server.repl_min_slaves_to_write &&
1860          server.repl_min_slaves_max_lag &&
1861          c->cmd->flags & CMD_WRITE &&
1862          server.repl_good_slaves_count < server.repl_min_slaves_to_write)
1863      {
1864          flagTransaction(c);
1865          addReply(c, shared.noreplicaserr);
1866          return C_OK;
1867      }
1868      if (server.masterhost && server.repl_slave_ro &&
1869          !(c->flags & CLIENT_MASTER) &&
1870          c->cmd->flags & CMD_WRITE)
1871      {
1872          addReply(c, shared.roslaveerr);
1873          return C_OK;
1874      }
1875      if (c->flags & CLIENT_PUBSUB &&
1876          c->cmd->proc != pingCommand &&
1877          c->cmd->proc != subscribeCommand &&
1878          c->cmd->proc != unsubscribeCommand &&
1879          c->cmd->proc != psubscribeCommand &&
1880          c->cmd->proc != punsubscribeCommand) {
1881          addReplyError(c,"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context");
1882          return C_OK;
1883      }
1884      if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED &&
1885          server.repl_serve_stale_data == 0 &&
1886          !(c->cmd->flags & CMD_STALE))
1887      {
1888          flagTransaction(c);
1889          addReply(c, shared.masterdownerr);
1890          return C_OK;
1891      }
1892      if (server.loading && !(c->cmd->flags & CMD_LOADING)) {
1893          addReply(c, shared.loadingerr);
1894          return C_OK;
1895      }
1896      if (server.lua_timedout &&
1897            c->cmd->proc != authCommand &&
1898            c->cmd->proc != replconfCommand &&
1899          !(c->cmd->proc == shutdownCommand &&
1900            c->argc == 2 &&
1901            tolower(((char*)c->argv[1]->ptr)[0]) == 'n') &&
1902          !(c->cmd->proc == scriptCommand &&
1903            c->argc == 2 &&
1904            tolower(((char*)c->argv[1]->ptr)[0]) == 'k'))
1905      {
1906          flagTransaction(c);
1907          addReply(c, shared.slowscripterr);
1908          return C_OK;
1909      }
1910      if (c->flags & CLIENT_MULTI &&
1911          c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&
1912          c->cmd->proc != multiCommand && c->cmd->proc != watchCommand)
1913      {
1914          queueMultiCommand(c);
1915          addReply(c,shared.queued);
1916      } else {
1917          call(c,CMD_CALL_FULL);
1918          c->woff = server.master_repl_offset;
1919          if (listLength(server.ready_keys))
1920              handleClientsBlockedOnKeys();
1921      }
1922      return C_OK;
1923  }
1924  void closeListeningSockets(int unlink_unix_socket) {
1925      int j;
1926      for (j = 0; j < server.ipfd_count; j++) close(server.ipfd[j]);
1927      if (server.sofd != -1) close(server.sofd);
1928      if (server.cluster_enabled)
1929          for (j = 0; j < server.cfd_count; j++) close(server.cfd[j]);
1930  #ifndef _WIN32
1931      if (unlink_unix_socket && server.unixsocket) {
1932          serverLog(LL_NOTICE,"Removing the unix socket file.");
1933          unlink(server.unixsocket); &bsol;* don't care if this fails */
1934      }
1935  #endif
1936  }
1937  int prepareForShutdown(int flags) {
1938      if (server.loading || server.sentinel_mode)
1939          flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;
1940      int save = flags & SHUTDOWN_SAVE;
1941      int nosave = flags & SHUTDOWN_NOSAVE;
1942      serverLog(LL_WARNING,"User requested shutdown...");
1943      ldbKillForkedSessions();
1944      if (server.rdb_child_pid != -1) {
1945          serverLog(LL_WARNING,"There is a child saving an .rdb. Killing it!");
1946          IF_WIN32(AbortForkOperation(), kill(server.rdb_child_pid,SIGUSR1));
1947          rdbRemoveTempFile(server.rdb_child_pid);
1948      }
1949      if (server.aof_state != AOF_OFF) {
1950          if (server.aof_child_pid != -1) {
1951              if (server.aof_state == AOF_WAIT_REWRITE) {
1952                  serverLog(LL_WARNING, "Writing initial AOF, can't exit.");
1953                  return C_ERR;
1954              }
1955              serverLog(LL_WARNING,
1956                  "There is a child rewriting the AOF. Killing it!");
1957              IF_WIN32(AbortForkOperation(), kill(server.aof_child_pid,SIGUSR1));
1958          }
1959          serverLog(LL_NOTICE,"Calling fsync() on the AOF file.");
1960          flushAppendOnlyFile(1);
1961          redis_fsync(server.aof_fd);
1962      }
1963      if ((server.saveparamslen > 0 && !nosave) || save) {
1964          serverLog(LL_NOTICE,"Saving the final RDB snapshot before exiting.");
1965          rdbSaveInfo rsi, *rsiptr;
1966          rsiptr = rdbPopulateSaveInfo(&rsi);
1967          if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {
1968              serverLog(LL_WARNING,"Error trying to save the DB, can't exit.");
1969              return C_ERR;
1970          }
1971      }
1972      if (server.daemonize || server.pidfile) {
1973          serverLog(LL_NOTICE,"Removing the pid file.");
1974          unlink(server.pidfile);
1975      }
1976      flushSlavesOutputBuffers();
1977      closeListeningSockets(1);
1978      serverLog(LL_WARNING,"%s is now ready to exit, bye bye...",
1979          server.sentinel_mode ? "Sentinel" : "Redis");
1980      return C_OK;
1981  }
1982  int writeCommandsDeniedByDiskError(void) {
1983      if (server.stop_writes_on_bgsave_err &&
1984          server.saveparamslen > 0 &&
1985          server.lastbgsave_status == C_ERR)
1986      {
1987          return DISK_ERROR_TYPE_RDB;
1988      } else if (server.aof_state != AOF_OFF &&
1989                 server.aof_last_write_status == C_ERR)
1990      {
1991          return DISK_ERROR_TYPE_AOF;
1992      } else {
1993          return DISK_ERROR_TYPE_NONE;
1994      }
1995  }
1996  int time_independent_strcmp(char *a, char *b) {
1997      char bufa[CONFIG_AUTHPASS_MAX_LEN], bufb[CONFIG_AUTHPASS_MAX_LEN];
1998      unsigned int alen = (unsigned int) strlen(a);                               WIN_PORT_FIX &bsol;* cast (unsigned int) */
1999      unsigned int blen = (unsigned int) strlen(b);                               WIN_PORT_FIX &bsol;* cast (unsigned int) */
2000      unsigned int j;
2001      int diff = 0;
2002      if (alen > sizeof(bufa) || blen > sizeof(bufb)) return 1;
2003      memset(bufa,0,sizeof(bufa));        &bsol;* Constant time. */
2004      memset(bufb,0,sizeof(bufb));        &bsol;* Constant time. */
2005      memcpy(bufa,a,alen);
2006      memcpy(bufb,b,blen);
2007      for (j = 0; j < sizeof(bufa); j++) {
2008          diff |= (bufa[j] ^ bufb[j]);
2009      }
2010      diff |= alen ^ blen;
2011      return diff; &bsol;* If zero strings are the same. */
2012  }
2013  void authCommand(client *c) {
2014      if (!server.requirepass) {
2015          addReplyError(c,"Client sent AUTH, but no password is set");
2016      } else if (!time_independent_strcmp(c->argv[1]->ptr, server.requirepass)) {
2017        c->authenticated = 1;
2018        addReply(c,shared.ok);
2019      } else {
2020        c->authenticated = 0;
2021        addReplyError(c,"invalid password");
2022      }
2023  }
2024  void pingCommand(client *c) {
2025      if (c->argc > 2) {
2026          addReplyErrorFormat(c,"wrong number of arguments for '%s' command",
2027              c->cmd->name);
2028          return;
2029      }
2030      if (c->flags & CLIENT_PUBSUB) {
2031          addReply(c,shared.mbulkhdr[2]);
2032          addReplyBulkCBuffer(c,"pong",4);
2033          if (c->argc == 1)
2034              addReplyBulkCBuffer(c,"",0);
2035          else
2036              addReplyBulk(c,c->argv[1]);
2037      } else {
2038          if (c->argc == 1)
2039              addReply(c,shared.pong);
2040          else
2041              addReplyBulk(c,c->argv[1]);
2042      }
2043  }
2044  void echoCommand(client *c) {
2045      addReplyBulk(c,c->argv[1]);
2046  }
2047  void timeCommand(client *c) {
2048      struct timeval tv;
2049      gettimeofday(&tv,NULL);
2050      addReplyMultiBulkLen(c,2);
2051      addReplyBulkLongLong(c,tv.tv_sec);
2052      addReplyBulkLongLong(c,tv.tv_usec);
2053  }
2054  int addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {
2055      if (cmd->flags & f) {
2056          addReplyStatus(c, reply);
2057          return 1;
2058      }
2059      return 0;
2060  }
2061  void addReplyCommand(client *c, struct redisCommand *cmd) {
2062      if (!cmd) {
2063          addReply(c, shared.nullbulk);
2064      } else {
2065          addReplyMultiBulkLen(c, 6);
2066          addReplyBulkCString(c, cmd->name);
2067          addReplyLongLong(c, cmd->arity);
2068          int flagcount = 0;
2069          void *flaglen = addDeferredMultiBulkLength(c);
2070          flagcount += addReplyCommandFlag(c,cmd,CMD_WRITE, "write");
2071          flagcount += addReplyCommandFlag(c,cmd,CMD_READONLY, "readonly");
2072          flagcount += addReplyCommandFlag(c,cmd,CMD_DENYOOM, "denyoom");
2073          flagcount += addReplyCommandFlag(c,cmd,CMD_ADMIN, "admin");
2074          flagcount += addReplyCommandFlag(c,cmd,CMD_PUBSUB, "pubsub");
2075          flagcount += addReplyCommandFlag(c,cmd,CMD_NOSCRIPT, "noscript");
2076          flagcount += addReplyCommandFlag(c,cmd,CMD_RANDOM, "random");
2077          flagcount += addReplyCommandFlag(c,cmd,CMD_SORT_FOR_SCRIPT,"sort_for_script");
2078          flagcount += addReplyCommandFlag(c,cmd,CMD_LOADING, "loading");
2079          flagcount += addReplyCommandFlag(c,cmd,CMD_STALE, "stale");
2080          flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_MONITOR, "skip_monitor");
2081          flagcount += addReplyCommandFlag(c,cmd,CMD_ASKING, "asking");
2082          flagcount += addReplyCommandFlag(c,cmd,CMD_FAST, "fast");
2083          if ((cmd->getkeys_proc && !(cmd->flags & CMD_MODULE)) ||
2084              cmd->flags & CMD_MODULE_GETKEYS)
2085          {
2086              addReplyStatus(c, "movablekeys");
2087              flagcount += 1;
2088          }
2089          setDeferredMultiBulkLength(c, flaglen, flagcount);
2090          addReplyLongLong(c, cmd->firstkey);
2091          addReplyLongLong(c, cmd->lastkey);
2092          addReplyLongLong(c, cmd->keystep);
2093      }
2094  }
2095  void commandCommand(client *c) {
2096      dictIterator *di;
2097      dictEntry *de;
2098      if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,"help")) {
2099          const char *help[] = {
2100  "(no subcommand) -- Return details about all Redis commands.",
2101  "COUNT -- Return the total number of commands in this Redis server.",
2102  "GETKEYS <full-command> -- Return the keys from a full Redis command.",
2103  "INFO [command-name ...] -- Return details about multiple Redis commands.",
2104  NULL
2105          };
2106          addReplyHelp(c, help);
2107      } else if (c->argc == 1) {
2108          addReplyMultiBulkLen(c, dictSize(server.commands));
2109          di = dictGetIterator(server.commands);
2110          while ((de = dictNext(di)) != NULL) {
2111              addReplyCommand(c, dictGetVal(de));
2112          }
2113          dictReleaseIterator(di);
2114      } else if (!strcasecmp(c->argv[1]->ptr, "info")) {
2115          int i;
2116          addReplyMultiBulkLen(c, (PORT_LONG)c->argc-2);  WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
2117          for (i = 2; i < c->argc; i++) {
2118              addReplyCommand(c, dictFetchValue(server.commands, c->argv[i]->ptr));
2119          }
2120      } else if (!strcasecmp(c->argv[1]->ptr, "count") && c->argc == 2) {
2121          addReplyLongLong(c, dictSize(server.commands));
2122      } else if (!strcasecmp(c->argv[1]->ptr,"getkeys") && c->argc >= 3) {
2123          struct redisCommand *cmd = lookupCommand(c->argv[2]->ptr);
2124          int *keys, numkeys, j;
2125          if (!cmd) {
2126              addReplyError(c,"Invalid command specified");
2127              return;
2128          } else if (cmd->getkeys_proc == NULL && cmd->firstkey == 0) {
2129              addReplyError(c,"The command has no key arguments");
2130              return;
2131          } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||
2132                     ((c->argc-2) < -cmd->arity))
2133          {
2134              addReplyError(c,"Invalid number of arguments specified for command");
2135              return;
2136          }
2137          keys = getKeysFromCommand(cmd,c->argv+2,c->argc-2,&numkeys);
2138          if (!keys) {
2139              addReplyError(c,"Invalid arguments specified for command");
2140          } else {
2141              addReplyMultiBulkLen(c,numkeys);
2142              for (j = 0; j < numkeys; j++) addReplyBulk(c,c->argv[keys[j]+2]);
2143              getKeysFreeResult(keys);
2144          }
2145      } else {
2146          addReplySubcommandSyntaxError(c);
2147      }
2148  }
2149  void bytesToHuman(char *s, PORT_ULONGLONG n) {
2150      double d;
2151      if (n < 1024) {
2152          sprintf(s,"%lluB",n);
2153      } else if (n < (1024*1024)) {
2154          d = (double)n/(1024);
2155          sprintf(s,"%.2fK",d);
2156      } else if (n < (1024LL*1024*1024)) {
2157          d = (double)(n/(1024*1024));  WIN_PORT_FIX
2158          sprintf(s,"%.2fM",d);
2159      } else if (n < (1024LL*1024*1024*1024)) {
2160          d = (double)n/(1024LL*1024*1024);
2161          sprintf(s,"%.2fG",d);
2162      } else if (n < (1024LL*1024*1024*1024*1024)) {
2163          d = (double)n/(1024LL*1024*1024*1024);
2164          sprintf(s,"%.2fT",d);
2165      } else if (n < (1024LL*1024*1024*1024*1024*1024)) {
2166          d = (double)n/(1024LL*1024*1024*1024*1024);
2167          sprintf(s,"%.2fP",d);
2168      } else {
2169          sprintf(s,"%lluB",n);
2170      }
2171  }
2172  sds genRedisInfoString(char *section) {
2173      sds info = sdsempty();
2174      time_t uptime = server.unixtime-server.stat_starttime;
2175      int j;
2176      struct rusage self_ru, c_ru;
2177      int allsections = 0, defsections = 0;
2178      int sections = 0;
2179      if (section == NULL) section = "default";
2180      allsections = strcasecmp(section,"all") == 0;
2181      defsections = strcasecmp(section,"default") == 0;
2182      getrusage(RUSAGE_SELF, &self_ru);
2183      getrusage(RUSAGE_CHILDREN, &c_ru);
2184      if (allsections || defsections || !strcasecmp(section,"server")) {
2185          POSIX_ONLY(static int call_uname = 1;)
2186          POSIX_ONLY(static struct utsname name;)
2187          char *mode;
2188          if (server.cluster_enabled) mode = "cluster";
2189          else if (server.sentinel_mode) mode = "sentinel";
2190          else mode = "standalone";
2191          if (sections++) info = sdscat(info,"\r\n");
2192  #ifndef _WIN32
2193          if (call_uname) {
2194              uname(&name);
2195              call_uname = 0;
2196          }
2197  #endif
2198          unsigned int lruclock;
2199          atomicGet(server.lruclock,lruclock);
2200          info = sdscatprintf(info,
2201              "# Server\r\n"
2202              "redis_version:%s\r\n"
2203              "redis_git_sha1:%s\r\n"
2204              "redis_git_dirty:%d\r\n"
2205              "redis_build_id:%llx\r\n"
2206              "redis_mode:%s\r\n"
2207              "os:%s %s %s\r\n"
2208              "arch_bits:%d\r\n"
2209              "multiplexing_api:%s\r\n"
2210              "atomicvar_api:%s\r\n"
2211              POSIX_ONLY("gcc_version:%d.%d.%d\r\n")
2212              "process_id:%Id\r\n"                                                WIN_PORT_FIX &bsol;* %ld -> %Id */
2213              "run_id:%s\r\n"
2214              "tcp_port:%d\r\n"
2215              "uptime_in_seconds:%lld\r\n"                                        WIN_PORT_FIX &bsol;* %jd -> %lld */
2216              "uptime_in_days:%lld\r\n"                                           WIN_PORT_FIX &bsol;* %jd -> %lld */
2217              "hz:%d\r\n"
2218              "configured_hz:%d\r\n"
2219              "lru_clock:%Id\r\n"                                                 WIN_PORT_FIX &bsol;* %ld -> %Id */
2220              "executable:%s\r\n"
2221              "config_file:%s\r\n",
2222              REDIS_VERSION,
2223              redisGitSHA1(),
2224              strtol(redisGitDirty(),NULL,10) > 0,
2225              (PORT_ULONGLONG) redisBuildId(),
2226              mode,
2227  #ifdef _WIN32
2228                  "Windows", "", "",
2229  #else
2230              name.sysname, name.release, name.machine,
2231  #endif
2232              server.arch_bits,
2233              aeGetApiName(),
2234              REDIS_ATOMIC_API,
2235  #ifndef _WIN32
2236  #ifdef __GNUC__
2237              __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,
2238  #else
2239              0,0,0,
2240  #endif
2241  #endif
2242              (PORT_LONG) getpid(),
2243              server.runid,
2244              server.port,
2245              (intmax_t)uptime,
2246              (intmax_t)(uptime/(3600*24)),
2247              server.hz,
2248              server.config_hz,
2249              (PORT_ULONG) lruclock,
2250              server.executable ? server.executable : "",
2251              server.configfile ? server.configfile : "");
2252      }
2253      if (allsections || defsections || !strcasecmp(section,"clients")) {
2254          size_t maxin, maxout;
2255          getExpansiveClientsInfo(&maxin,&maxout);
2256          if (sections++) info = sdscat(info,"\r\n");
2257          info = sdscatprintf(info,
2258              "# Clients\r\n"
2259              "connected_clients:%Iu\r\n"                      WIN_PORT_FIX &bsol;* %lu -> %Iu */
2260              "client_recent_max_input_buffer:%Iu\r\n"         WIN_PORT_FIX &bsol;* %zu -> %Iu */
2261              "client_recent_max_output_buffer:%Iu\r\n"        WIN_PORT_FIX &bsol;* %zu -> %Iu */
2262              "blocked_clients:%d\r\n",
2263              listLength(server.clients)-listLength(server.slaves),
2264              maxin, maxout,
2265              server.blocked_clients);
2266      }
2267      if (allsections || defsections || !strcasecmp(section,"memory")) {
2268          char hmem[64];
2269          char peak_hmem[64];
2270          char total_system_hmem[64];
2271          char used_memory_lua_hmem[64];
2272          char used_memory_scripts_hmem[64];
2273          char used_memory_rss_hmem[64];
2274          char maxmemory_hmem[64];
2275          size_t zmalloc_used = zmalloc_used_memory();
2276          size_t total_system_mem = server.system_memory_size;
2277          const char *evict_policy = evictPolicyToString();
2278          PORT_LONGLONG memory_lua = (PORT_LONGLONG)lua_gc(server.lua,LUA_GCCOUNT,0)*1024;
2279          struct redisMemOverhead *mh = getMemoryOverheadData();
2280          if (zmalloc_used > server.stat_peak_memory)
2281              server.stat_peak_memory = zmalloc_used;
2282          bytesToHuman(hmem,zmalloc_used);
2283          bytesToHuman(peak_hmem,server.stat_peak_memory);
2284          bytesToHuman(total_system_hmem,total_system_mem);
2285          bytesToHuman(used_memory_lua_hmem,memory_lua);
2286          bytesToHuman(used_memory_scripts_hmem,mh->lua_caches);
2287          bytesToHuman(used_memory_rss_hmem,server.cron_malloc_stats.process_rss);
2288          bytesToHuman(maxmemory_hmem,server.maxmemory);
2289          if (sections++) info = sdscat(info,"\r\n");
2290          info = sdscatprintf(info,
2291              "# Memory\r\n"
2292              "used_memory:%Iu\r\n"                                               WIN_PORT_FIX &bsol;* %zu -> %Iu */
2293              "used_memory_human:%s\r\n"
2294              "used_memory_rss:%Iu\r\n"                                           WIN_PORT_FIX &bsol;* %zu -> %Iu */
2295              "used_memory_rss_human:%s\r\n"
2296              "used_memory_peak:%Iu\r\n"                                          WIN_PORT_FIX &bsol;* %zu -> %Iu */
2297              "used_memory_peak_human:%s\r\n"
2298              "used_memory_peak_perc:%.2f%%\r\n"
2299              "used_memory_overhead:%Iu\r\n"                                      WIN_PORT_FIX &bsol;* %zu -> %Iu */
2300              "used_memory_startup:%Iu\r\n"                                       WIN_PORT_FIX &bsol;* %zu -> %Iu */
2301              "used_memory_dataset:%Iu\r\n"                                       WIN_PORT_FIX &bsol;* %zu -> %Iu */
2302              "used_memory_dataset_perc:%.2f%%\r\n"
2303              "allocator_allocated:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2304              "allocator_active:%Iu\r\n"			WIN_PORT_FIX &bsol;* %zu -> %Iu */
2305              "allocator_resident:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2306              "total_system_memory:%Iu\r\n"		WIN_PORT_FIX &bsol;* %lu -> %Iu */
2307              "total_system_memory_human:%s\r\n"
2308              "used_memory_lua:%lld\r\n"
2309              "used_memory_lua_human:%s\r\n"
2310              "used_memory_scripts:%lld\r\n"
2311              "used_memory_scripts_human:%s\r\n"
2312              "number_of_cached_scripts:%lu\r\n"
2313              "maxmemory:%lld\r\n"
2314              "maxmemory_human:%s\r\n"
2315              "maxmemory_policy:%s\r\n"
2316              "allocator_frag_ratio:%.2f\r\n"
2317              "allocator_frag_bytes:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2318              "allocator_rss_ratio:%.2f\r\n"
2319              "allocator_rss_bytes:%zd\r\n"
2320              "rss_overhead_ratio:%.2f\r\n"
2321              "rss_overhead_bytes:%zd\r\n"
2322              "mem_fragmentation_ratio:%.2f\r\n"
2323              "mem_fragmentation_bytes:%zd\r\n"
2324              "mem_not_counted_for_evict:%Iu\r\n" WIN_PORT_FIX &bsol;* %zu -> %Iu */
2325              "mem_replication_backlog:%Iu\r\n"	WIN_PORT_FIX &bsol;* %zu -> %Iu */
2326              "mem_clients_slaves:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2327              "mem_clients_normal:%Iu\r\n"		WIN_PORT_FIX &bsol;* %zu -> %Iu */
2328              "mem_aof_buffer:%Iu\r\n"			WIN_PORT_FIX &bsol;* %zu -> %Iu */
2329              "mem_allocator:%s\r\n"
2330              "active_defrag_running:%d\r\n"
2331              "lazyfree_pending_objects:%Iu\r\n", WIN_PORT_FIX &bsol;* %zu -> %Iu */
2332              zmalloc_used,
2333              hmem,
2334              server.cron_malloc_stats.process_rss,
2335              used_memory_rss_hmem,
2336              server.stat_peak_memory,
2337              peak_hmem,
2338              mh->peak_perc,
2339              mh->overhead_total,
2340              mh->startup_allocated,
2341              mh->dataset,
2342              mh->dataset_perc,
2343              server.cron_malloc_stats.allocator_allocated,
2344              server.cron_malloc_stats.allocator_active,
2345              server.cron_malloc_stats.allocator_resident,
2346              (PORT_ULONG)total_system_mem,
2347              total_system_hmem,
2348              memory_lua,
2349              used_memory_lua_hmem,
2350              (PORT_LONGLONG) mh->lua_caches,
2351              used_memory_scripts_hmem,
2352              dictSize(server.lua_scripts),
2353              server.maxmemory,
2354              maxmemory_hmem,
2355              evict_policy,
2356              mh->allocator_frag,
2357              mh->allocator_frag_bytes,
2358              mh->allocator_rss,
2359              mh->allocator_rss_bytes,
2360              mh->rss_extra,
2361              mh->rss_extra_bytes,
2362              mh->total_frag, &bsol;* this is the total RSS overhead, including fragmentation, */
2363              mh->total_frag_bytes, &bsol;* named so for backwards compatibility */
2364              freeMemoryGetNotCountedMemory(),
2365              mh->repl_backlog,
2366              mh->clients_slaves,
2367              mh->clients_normal,
2368              mh->aof_buffer,
2369              ZMALLOC_LIB,
2370              server.active_defrag_running,
2371              lazyfreeGetPendingObjectsCount()
2372          );
2373          freeMemoryOverheadData(mh);
2374      }
2375      if (allsections || defsections || !strcasecmp(section,"persistence")) {
2376          if (sections++) info = sdscat(info,"\r\n");
2377          info = sdscatprintf(info,
2378              "# Persistence\r\n"
2379              "loading:%d\r\n"
2380              "rdb_changes_since_last_save:%lld\r\n"
2381              "rdb_bgsave_in_progress:%d\r\n"
2382              "rdb_last_save_time:%lld\r\n"                                       WIN_PORT_FIX &bsol;* %jd -> %lld */
2383              "rdb_last_bgsave_status:%s\r\n"
2384              "rdb_last_bgsave_time_sec:%lld\r\n"                                 WIN_PORT_FIX &bsol;* %jd -> %lld */
2385              "rdb_current_bgsave_time_sec:%lld\r\n"                              WIN_PORT_FIX &bsol;* %jd -> %lld */
2386              "rdb_last_cow_size:%Iu\r\n"                                         WIN_PORT_FIX &bsol;* %zu -> %Iu */
2387              "aof_enabled:%d\r\n"
2388              "aof_rewrite_in_progress:%d\r\n"
2389              "aof_rewrite_scheduled:%d\r\n"
2390              "aof_last_rewrite_time_sec:%lld\r\n"                                WIN_PORT_FIX &bsol;* %jd -> %lld */
2391              "aof_current_rewrite_time_sec:%lld\r\n"                             WIN_PORT_FIX &bsol;* %jd -> %lld */
2392              "aof_last_bgrewrite_status:%s\r\n"
2393              "aof_last_write_status:%s\r\n"
2394              "aof_last_cow_size:%Iu\r\n", WIN_PORT_FIX &bsol;* %zu -> %Iu */
2395              server.loading,
2396              server.dirty,
2397              server.rdb_child_pid != -1,
2398              (intmax_t)server.lastsave,
2399              (server.lastbgsave_status == C_OK) ? "ok" : "err",
2400              (intmax_t)server.rdb_save_time_last,
2401              (intmax_t)((server.rdb_child_pid == -1) ?
2402                  -1 : time(NULL)-server.rdb_save_time_start),
2403              server.stat_rdb_cow_bytes,
2404              server.aof_state != AOF_OFF,
2405              server.aof_child_pid != -1,
2406              server.aof_rewrite_scheduled,
2407              (intmax_t)server.aof_rewrite_time_last,
2408              (intmax_t)((server.aof_child_pid == -1) ?
2409                  -1 : time(NULL)-server.aof_rewrite_time_start),
2410              (server.aof_lastbgrewrite_status == C_OK) ? "ok" : "err",
2411              (server.aof_last_write_status == C_OK) ? "ok" : "err",
2412              server.stat_aof_cow_bytes);
2413          if (server.aof_state != AOF_OFF) {
2414              info = sdscatprintf(info,
2415                  "aof_current_size:%lld\r\n"
2416                  "aof_base_size:%lld\r\n"
2417                  "aof_pending_rewrite:%d\r\n"
2418                  "aof_buffer_length:%Iu\r\n"                                     WIN_PORT_FIX &bsol;* %zu -> %Iu */
2419                  "aof_rewrite_buffer_length:%Iu\r\n"                             WIN_PORT_FIX &bsol;* %lu -> %Iu */
2420                  "aof_pending_bio_fsync:%llu\r\n"
2421                  "aof_delayed_fsync:%Iu\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
2422                  (PORT_LONGLONG) server.aof_current_size,
2423                  (PORT_LONGLONG) server.aof_rewrite_base_size,
2424                  server.aof_rewrite_scheduled,
2425                  sdslen(server.aof_buf),
2426                  aofRewriteBufferSize(),
2427                  bioPendingJobsOfType(BIO_AOF_FSYNC),
2428                  server.aof_delayed_fsync);
2429          }
2430          if (server.loading) {
2431              double perc;
2432              time_t eta, elapsed;
2433              off_t remaining_bytes = server.loading_total_bytes-
2434                                      server.loading_loaded_bytes;
2435              perc = ((double)server.loading_loaded_bytes /
2436                     (server.loading_total_bytes+1)) * 100;
2437              elapsed = time(NULL)-server.loading_start_time;
2438              if (elapsed == 0) {
2439                  eta = 1; &bsol;* A fake 1 second figure if we don't have
2440                              enough info */
2441              } else {
2442                  eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);
2443              }
2444              info = sdscatprintf(info,
2445                  "loading_start_time:%jd\r\n"
2446                  "loading_total_bytes:%llu\r\n"
2447                  "loading_loaded_bytes:%llu\r\n"
2448                  "loading_loaded_perc:%.2f\r\n"
2449                  "loading_eta_seconds:%jd\r\n",
2450                  (intmax_t) server.loading_start_time,
2451                  (PORT_ULONGLONG) server.loading_total_bytes,
2452                  (PORT_ULONGLONG) server.loading_loaded_bytes,
2453                  perc,
2454                  (intmax_t)eta
2455              );
2456          }
2457      }
2458      if (allsections || defsections || !strcasecmp(section,"stats")) {
2459          if (sections++) info = sdscat(info,"\r\n");
2460          info = sdscatprintf(info,
2461              "# Stats\r\n"
2462              "total_connections_received:%lld\r\n"
2463              "total_commands_processed:%lld\r\n"
2464              "instantaneous_ops_per_sec:%lld\r\n"
2465              "total_net_input_bytes:%lld\r\n"
2466              "total_net_output_bytes:%lld\r\n"
2467              "instantaneous_input_kbps:%.2f\r\n"
2468              "instantaneous_output_kbps:%.2f\r\n"
2469              "rejected_connections:%lld\r\n"
2470              "sync_full:%lld\r\n"
2471              "sync_partial_ok:%lld\r\n"
2472              "sync_partial_err:%lld\r\n"
2473              "expired_keys:%lld\r\n"
2474              "expired_stale_perc:%.2f\r\n"
2475              "expired_time_cap_reached_count:%lld\r\n"
2476              "evicted_keys:%lld\r\n"
2477              "keyspace_hits:%lld\r\n"
2478              "keyspace_misses:%lld\r\n"
2479              "pubsub_channels:%Id\r\n"                                           WIN_PORT_FIX &bsol;* %ld -> %Id */
2480              "pubsub_patterns:%Iu\r\n"                                           WIN_PORT_FIX &bsol;* %lu -> %Iu */
2481              "latest_fork_usec:%lld\r\n"
2482              "migrate_cached_sockets:%Id\r\n"                                    WIN_PORT_FIX &bsol;* %ld -> %Id */
2483              "slave_expires_tracked_keys:%Iu\r\n"                                WIN_PORT_FIX &bsol;* %zu -> %Iu */
2484              "active_defrag_hits:%lld\r\n"
2485              "active_defrag_misses:%lld\r\n"
2486              "active_defrag_key_hits:%lld\r\n"
2487              "active_defrag_key_misses:%lld\r\n",
2488              server.stat_numconnections,
2489              server.stat_numcommands,
2490              getInstantaneousMetric(STATS_METRIC_COMMAND),
2491              server.stat_net_input_bytes,
2492              server.stat_net_output_bytes,
2493              (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,
2494              (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,
2495              server.stat_rejected_conn,
2496              server.stat_sync_full,
2497              server.stat_sync_partial_ok,
2498              server.stat_sync_partial_err,
2499              server.stat_expiredkeys,
2500              server.stat_expired_stale_perc*100,
2501              server.stat_expired_time_cap_reached_count,
2502              server.stat_evictedkeys,
2503              server.stat_keyspace_hits,
2504              server.stat_keyspace_misses,
2505              dictSize(server.pubsub_channels),
2506              listLength(server.pubsub_patterns),
2507              server.stat_fork_time,
2508              dictSize(server.migrate_cached_sockets),
2509              getSlaveKeyWithExpireCount(),
2510              server.stat_active_defrag_hits,
2511              server.stat_active_defrag_misses,
2512              server.stat_active_defrag_key_hits,
2513              server.stat_active_defrag_key_misses);
2514      }
2515      if (allsections || defsections || !strcasecmp(section,"replication")) {
2516          if (sections++) info = sdscat(info,"\r\n");
2517          info = sdscatprintf(info,
2518              "# Replication\r\n"
2519              "role:%s\r\n",
2520              server.masterhost == NULL ? "master" : "slave");
2521          if (server.masterhost) {
2522              PORT_LONGLONG slave_repl_offset = 1;
2523              if (server.master)
2524                  slave_repl_offset = server.master->reploff;
2525              else if (server.cached_master)
2526                  slave_repl_offset = server.cached_master->reploff;
2527              info = sdscatprintf(info,
2528                  "master_host:%s\r\n"
2529                  "master_port:%d\r\n"
2530                  "master_link_status:%s\r\n"
2531                  "master_last_io_seconds_ago:%d\r\n"
2532                  "master_sync_in_progress:%d\r\n"
2533                  "slave_repl_offset:%lld\r\n"
2534                  ,server.masterhost,
2535                  server.masterport,
2536                  (server.repl_state == REPL_STATE_CONNECTED) ?
2537                      "up" : "down",
2538                  server.master ?
2539                  ((int)(server.unixtime-server.master->lastinteraction)) : -1,
2540                  server.repl_state == REPL_STATE_TRANSFER,
2541                  slave_repl_offset
2542              );
2543              if (server.repl_state == REPL_STATE_TRANSFER) {
2544                  info = sdscatprintf(info,
2545                      "master_sync_left_bytes:%lld\r\n"
2546                      "master_sync_last_io_seconds_ago:%d\r\n"
2547                      , (PORT_LONGLONG)
2548                          (server.repl_transfer_size - server.repl_transfer_read),
2549                      (int)(server.unixtime-server.repl_transfer_lastio)
2550                  );
2551              }
2552              if (server.repl_state != REPL_STATE_CONNECTED) {
2553                  info = sdscatprintf(info,
2554                      "master_link_down_since_seconds:%jd\r\n",
2555                      (intmax_t)server.unixtime-server.repl_down_since);
2556              }
2557              info = sdscatprintf(info,
2558                  "slave_priority:%d\r\n"
2559                  "slave_read_only:%d\r\n",
2560                  server.slave_priority,
2561                  server.repl_slave_ro);
2562          }
2563          info = sdscatprintf(info,
2564              "connected_slaves:%Iu\r\n", WIN_PORT_FIX &bsol;* %lu -> %Iu */
2565              listLength(server.slaves));
2566          if (server.repl_min_slaves_to_write &&
2567              server.repl_min_slaves_max_lag) {
2568              info = sdscatprintf(info,
2569                  "min_slaves_good_slaves:%d\r\n",
2570                  server.repl_good_slaves_count);
2571          }
2572          if (listLength(server.slaves)) {
2573              int slaveid = 0;
2574              listNode *ln;
2575              listIter li;
2576              listRewind(server.slaves,&li);
2577              while((ln = listNext(&li))) {
2578                  client *slave = listNodeValue(ln);
2579                  char *state = NULL;
2580                  char ip[NET_IP_STR_LEN], *slaveip = slave->slave_ip;
2581                  int port;
2582                  PORT_LONG lag = 0;
2583                  if (slaveip[0] == '\0') {
2584                      if (anetPeerToString(slave->fd,ip,sizeof(ip),&port) == -1)
2585                          continue;
2586                      slaveip = ip;
2587                  }
2588                  switch(slave->replstate) {
2589                  case SLAVE_STATE_WAIT_BGSAVE_START:
2590                  case SLAVE_STATE_WAIT_BGSAVE_END:
2591                      state = "wait_bgsave";
2592                      break;
2593                  case SLAVE_STATE_SEND_BULK:
2594                      state = "send_bulk";
2595                      break;
2596                  case SLAVE_STATE_ONLINE:
2597                      state = "online";
2598                      break;
2599                  }
2600                  if (state == NULL) continue;
2601                  if (slave->replstate == SLAVE_STATE_ONLINE)
2602                      lag = (PORT_LONG) (time(NULL) - slave->repl_ack_time);       WIN_PORT_FIX &bsol;* cast (PORT_LONG) */
2603                  info = sdscatprintf(info,
2604                      "slave%d:ip=%s,port=%d,state=%s,"
2605                      "offset=%lld,lag=%Id\r\n", WIN_PORT_FIX &bsol;* %ld -> %Id */
2606                      slaveid,slaveip,slave->slave_listening_port,state,
2607                      slave->repl_ack_off, lag);
2608                  slaveid++;
2609              }
2610          }
2611          info = sdscatprintf(info,
2612              "master_replid:%s\r\n"
2613              "master_replid2:%s\r\n"
2614              "master_repl_offset:%lld\r\n"
2615              "second_repl_offset:%lld\r\n"
2616              "repl_backlog_active:%d\r\n"
2617              "repl_backlog_size:%lld\r\n"
2618              "repl_backlog_first_byte_offset:%lld\r\n"
2619              "repl_backlog_histlen:%lld\r\n",
2620              server.replid,
2621              server.replid2,
2622              server.master_repl_offset,
2623              server.second_replid_offset,
2624              server.repl_backlog != NULL,
2625              server.repl_backlog_size,
2626              server.repl_backlog_off,
2627              server.repl_backlog_histlen);
2628      }
2629      if (allsections || defsections || !strcasecmp(section,"cpu")) {
2630          if (sections++) info = sdscat(info,"\r\n");
2631          info = sdscatprintf(info,
2632          "# CPU\r\n"
2633          "used_cpu_sys:%ld.%06ld\r\n"
2634          "used_cpu_user:%ld.%06ld\r\n"
2635          "used_cpu_sys_children:%ld.%06ld\r\n"
2636          "used_cpu_user_children:%ld.%06ld\r\n",
2637          (PORT_LONG)self_ru.ru_stime.tv_sec, (PORT_LONG)self_ru.ru_stime.tv_usec,
2638          (PORT_LONG)self_ru.ru_utime.tv_sec, (PORT_LONG)self_ru.ru_utime.tv_usec,
2639          (PORT_LONG)c_ru.ru_stime.tv_sec, (PORT_LONG)c_ru.ru_stime.tv_usec,
2640          (PORT_LONG)c_ru.ru_utime.tv_sec, (PORT_LONG)c_ru.ru_utime.tv_usec);
2641      }
2642      if (allsections || !strcasecmp(section,"commandstats")) {
2643          if (sections++) info = sdscat(info,"\r\n");
2644          info = sdscatprintf(info, "# Commandstats\r\n");
2645          struct redisCommand *c;
2646          dictEntry *de;
2647          dictIterator *di;
2648          di = dictGetSafeIterator(server.commands);
2649          while((de = dictNext(di)) != NULL) {
2650              c = (struct redisCommand *) dictGetVal(de);
2651              if (!c->calls) continue;
2652              info = sdscatprintf(info,
2653                  "cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f\r\n",
2654                  c->name, c->calls, c->microseconds,
2655                  (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls));
2656          }
2657          dictReleaseIterator(di);
2658      }
2659      if (allsections || defsections || !strcasecmp(section,"cluster")) {
2660          if (sections++) info = sdscat(info,"\r\n");
2661          info = sdscatprintf(info,
2662          "# Cluster\r\n"
2663          "cluster_enabled:%d\r\n",
2664          server.cluster_enabled);
2665      }
2666      if (allsections || defsections || !strcasecmp(section,"keyspace")) {
2667          if (sections++) info = sdscat(info,"\r\n");
2668          info = sdscatprintf(info, "# Keyspace\r\n");
2669          for (j = 0; j < server.dbnum; j++) {
2670              PORT_LONGLONG keys, vkeys;
2671              keys = dictSize(server.db[j].dict);
2672              vkeys = dictSize(server.db[j].expires);
2673              if (keys || vkeys) {
2674                  info = sdscatprintf(info,
2675                      "db%d:keys=%lld,expires=%lld,avg_ttl=%lld\r\n",
2676                      j, keys, vkeys, server.db[j].avg_ttl);
2677              }
2678          }
2679      }
2680      return info;
2681  }
2682  void infoCommand(client *c) {
2683      char *section = c->argc == 2 ? c->argv[1]->ptr : "default";
2684      if (c->argc > 2) {
2685          addReply(c,shared.syntaxerr);
2686          return;
2687      }
2688      addReplyBulkSds(c, genRedisInfoString(section));
2689  }
2690  void monitorCommand(client *c) {
2691      if (c->flags & CLIENT_SLAVE) return;
2692      c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);
2693      listAddNodeTail(server.monitors,c);
2694      addReply(c,shared.ok);
2695  }
2696  #ifdef __linux__
2697  int linuxOvercommitMemoryValue(void) {
2698      FILE *fp = fopen("/proc/sys/vm/overcommit_memory","r");
2699      char buf[64];
2700      if (!fp) return -1;
2701      if (fgets(buf,64,fp) == NULL) {
2702          fclose(fp);
2703          return -1;
2704      }
2705      fclose(fp);
2706      return atoi(buf);
2707  }
2708  void linuxMemoryWarnings(void) {
2709      if (linuxOvercommitMemoryValue() == 0) {
2710          serverLog(LL_WARNING,"WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.");
2711      }
2712      if (THPIsEnabled()) {
2713          serverLog(LL_WARNING,"WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.");
2714      }
2715  }
2716  #endif &bsol;* __linux__ */
2717  void createPidFile(void) {
2718      if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);
2719      FILE *fp = fopen(server.pidfile,"w");
2720      if (fp) {
2721          fprintf(fp,"%d\n",(int)getpid());
2722          fclose(fp);
2723      }
2724  }
2725  void daemonize(void) {
2726  #ifdef _WIN32
2727      serverLog(LL_WARNING, "Windows does not support daemonize. Start Redis as service");
2728  #else
2729      int fd;
2730      if (fork() != 0) exit(0); &bsol;* parent exits */
2731      setsid(); &bsol;* create a new session */
2732      if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
2733          dup2(fd, STDIN_FILENO);
2734          dup2(fd, STDOUT_FILENO);
2735          dup2(fd, STDERR_FILENO);
2736          if (fd > STDERR_FILENO) close(fd);
2737      }
2738  #endif
2739  }
2740  void version(void) {
2741      printf("Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\n",
2742          REDIS_VERSION,
2743          redisGitSHA1(),
2744          atoi(redisGitDirty()) > 0,
2745          ZMALLOC_LIB,
2746          sizeof(PORT_LONG) == 4 ? 32 : 64,
2747          (PORT_ULONGLONG) redisBuildId());
2748      exit(0);
2749  }
2750  void usage(void) {
2751      fprintf(stderr,"Usage: ./redis-server [/path/to/redis.conf] [options]\n");
2752      fprintf(stderr,"       ./redis-server - (read config from stdin)\n");
2753      fprintf(stderr,"       ./redis-server -v or --version\n");
2754      fprintf(stderr,"       ./redis-server -h or --help\n");
2755      fprintf(stderr,"       ./redis-server --test-memory <megabytes>\n\n");
2756      fprintf(stderr,"Examples:\n");
2757      fprintf(stderr,"       ./redis-server (run the server with default conf)\n");
2758      fprintf(stderr,"       ./redis-server /etc/redis/6379.conf\n");
2759      fprintf(stderr,"       ./redis-server --port 7777\n");
2760      fprintf(stderr,"       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\n");
2761      fprintf(stderr,"       ./redis-server /etc/myredis.conf --loglevel verbose\n\n");
2762      fprintf(stderr,"Sentinel mode:\n");
2763      fprintf(stderr,"       ./redis-server /etc/sentinel.conf --sentinel\n");
2764      exit(1);
2765  }
2766  void redisAsciiArt(void) {
2767  #include "asciilogo.h"
2768      char *buf = zmalloc(1024*16);
2769      char *mode;
2770      if (server.cluster_enabled) mode = "cluster";
2771      else if (server.sentinel_mode) mode = "sentinel";
2772      else mode = "standalone";
2773      int show_logo = ((!server.syslog_enabled &&
2774                        server.logfile[0] == '\0' &&
2775                        isatty(fileno(stdout))) ||
2776                       server.always_show_logo);
2777      if (!show_logo) {
2778          serverLog(LL_NOTICE,
2779              "Running mode=%s, port=%d.",
2780              mode, server.port
2781          );
2782      } else {
2783          snprintf(buf,1024*16,ascii_logo,
2784              REDIS_VERSION,
2785              redisGitSHA1(),
2786              strtol(redisGitDirty(),NULL,10) > 0,
2787              (sizeof(PORT_LONG) == 8) ? "64" : "32",
2788              mode, server.port,
2789              (PORT_LONG) getpid()
2790          );
2791          serverLogRaw(LL_NOTICE|LL_RAW,buf);
2792      }
2793      zfree(buf);
2794  }
2795  static void sigShutdownHandler(int sig) {
2796      char *msg;
2797      switch (sig) {
2798      case SIGINT:
2799          msg = "Received SIGINT scheduling shutdown...";
2800          break;
2801      case SIGTERM:
2802          msg = "Received SIGTERM scheduling shutdown...";
2803          break;
2804      default:
2805          msg = "Received shutdown signal, scheduling shutdown...";
2806      };
2807      if (server.shutdown_asap && sig == SIGINT) {
2808          serverLogFromHandler(LL_WARNING, "You insist... exiting now.");
2809          rdbRemoveTempFile(getpid());
2810          exit(1); &bsol;* Exit with an error since this was not a clean shutdown. */
2811      } else if (server.loading) {
2812          serverLogFromHandler(LL_WARNING, "Received shutdown signal during loading, exiting now.");
2813          exit(0);
2814      }
2815      serverLogFromHandler(LL_WARNING, msg);
2816      server.shutdown_asap = 1;
2817  }
2818  void setupSignalHandlers(void) {
2819      struct sigaction act;
2820      sigemptyset(&act.sa_mask);
2821      act.sa_flags = 0;
2822      act.sa_handler = sigShutdownHandler;
2823      sigaction(SIGTERM, &act, NULL);
2824      sigaction(SIGINT, &act, NULL);
2825  #ifdef HAVE_BACKTRACE
2826      sigemptyset(&act.sa_mask);
2827      act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
2828      act.sa_sigaction = sigsegvHandler;
2829      sigaction(SIGSEGV, &act, NULL);
2830      sigaction(SIGBUS, &act, NULL);
2831      sigaction(SIGFPE, &act, NULL);
2832      sigaction(SIGILL, &act, NULL);
2833  #endif
2834      return;
2835  }
2836  void memtest(size_t megabytes, int passes);
2837  int checkForSentinelMode(int argc, char **argv) {
2838      int j;
2839      if (strstr(argv[0],"redis-sentinel") != NULL) return 1;
2840      for (j = 1; j < argc; j++)
2841          if (!strcmp(argv[j],"--sentinel")) return 1;
2842      return 0;
2843  }
2844  void loadDataFromDisk(void) {
2845      PORT_LONGLONG start = ustime();
2846      if (server.aof_state == AOF_ON) {
2847          if (loadAppendOnlyFile(server.aof_filename) == C_OK)
2848              serverLog(LL_NOTICE,"DB loaded from append only file: %.3f seconds",(float)(ustime()-start)/1000000);
2849      } else {
2850          rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
2851          if (rdbLoad(server.rdb_filename,&rsi) == C_OK) {
2852              serverLog(LL_NOTICE,"DB loaded from disk: %.3f seconds",
2853                  (float)(ustime()-start)/1000000);
2854              if ((server.masterhost ||
2855                  (server.cluster_enabled &&
2856                  nodeIsSlave(server.cluster->myself))) &&
2857                  rsi.repl_id_is_set &&
2858                  rsi.repl_offset != -1 &&
2859                  rsi.repl_stream_db != -1)
2860              {
2861                  memcpy(server.replid,rsi.repl_id,sizeof(server.replid));
2862                  server.master_repl_offset = rsi.repl_offset;
2863                  replicationCacheMasterUsingMyself();
2864                  selectDb(server.cached_master,rsi.repl_stream_db);
2865              }
2866          } else if (errno != ENOENT) {
2867              serverLog(LL_WARNING,"Fatal error loading the DB: %s. Exiting.", IF_WIN32(wsa_strerror(errno), strerror(errno)));
2868              exit(1);
2869          }
2870      }
2871  }
2872  void redisOutOfMemoryHandler(size_t allocation_size) {
2873      WIN32_ONLY(bugReportStart();)
2874      serverLog(LL_WARNING,"Out Of Memory allocating %Iu bytes!", WIN_PORT_FIX &bsol;* %zu -> %Iu */
2875          allocation_size);
2876      IF_WIN32(abort(), serverPanic("Redis aborting for OUT OF MEMORY"));
2877  }
2878  void redisSetProcTitle(char *title) {
2879  #ifdef USE_SETPROCTITLE
2880      char *server_mode = "";
2881      if (server.cluster_enabled) server_mode = " [cluster]";
2882      else if (server.sentinel_mode) server_mode = " [sentinel]";
2883      setproctitle("%s %s:%d%s",
2884          title,
2885          server.bindaddr_count ? server.bindaddr[0] : "*",
2886          server.port,
2887          server_mode);
2888  #else
2889      UNUSED(title);
2890  #endif
2891  }
2892  int redisSupervisedUpstart(void) {
2893  #ifndef _WIN32
2894      const char *upstart_job = getenv("UPSTART_JOB");
2895      if (!upstart_job) {
2896          serverLog(LL_WARNING,
2897                  "upstart supervision requested, but UPSTART_JOB not found");
2898          return 0;
2899      }
2900      serverLog(LL_NOTICE, "supervised by upstart, will stop to signal readiness");
2901      raise(SIGSTOP);
2902      unsetenv("UPSTART_JOB");
2903      return 1;
2904  #endif
2905      return 0;
2906  }
2907  int redisSupervisedSystemd(void) {
2908  #ifndef _WIN32
2909      const char *notify_socket = getenv("NOTIFY_SOCKET");
2910      int fd = 1;
2911      struct sockaddr_un su;
2912      struct iovec iov;
2913      struct msghdr hdr;
2914      int sendto_flags = 0;
2915      if (!notify_socket) {
2916          serverLog(LL_WARNING,
2917                  "systemd supervision requested, but NOTIFY_SOCKET not found");
2918          return 0;
2919      }
2920      if ((strchr("@/", notify_socket[0])) == NULL || strlen(notify_socket) < 2) {
2921          return 0;
2922      }
2923      serverLog(LL_NOTICE, "supervised by systemd, will signal readiness");
2924      if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {
2925          serverLog(LL_WARNING,
2926                  "Can't connect to systemd socket %s", notify_socket);
2927          return 0;
2928      }
2929      memset(&su, 0, sizeof(su));
2930      su.sun_family = AF_UNIX;
2931      strncpy (su.sun_path, notify_socket, sizeof(su.sun_path) -1);
2932      su.sun_path[sizeof(su.sun_path) - 1] = '\0';
2933      if (notify_socket[0] == '@')
2934          su.sun_path[0] = '\0';
2935      memset(&iov, 0, sizeof(iov));
2936      iov.iov_base = "READY=1";
2937      iov.iov_len = strlen("READY=1");
2938      memset(&hdr, 0, sizeof(hdr));
2939      hdr.msg_name = &su;
2940      hdr.msg_namelen = offsetof(struct sockaddr_un, sun_path) +
2941          strlen(notify_socket);
2942      hdr.msg_iov = &iov;
2943      hdr.msg_iovlen = 1;
2944      unsetenv("NOTIFY_SOCKET");
2945  #ifdef HAVE_MSG_NOSIGNAL
2946      sendto_flags |= MSG_NOSIGNAL;
2947  #endif
2948      if (sendmsg(fd, &hdr, sendto_flags) < 0) {
2949          serverLog(LL_WARNING, "Can't send notification to systemd");
2950          close(fd);
2951          return 0;
2952      }
2953      close(fd);
2954      return 1;
2955  #endif
2956      return 0;
2957  }
2958  int redisIsSupervised(int mode) {
2959      if (mode == SUPERVISED_AUTODETECT) {
2960          const char *upstart_job = getenv("UPSTART_JOB");
2961          const char *notify_socket = getenv("NOTIFY_SOCKET");
2962          if (upstart_job) {
2963              redisSupervisedUpstart();
2964          } else if (notify_socket) {
2965              redisSupervisedSystemd();
2966          }
2967      } else if (mode == SUPERVISED_UPSTART) {
2968          return redisSupervisedUpstart();
2969      } else if (mode == SUPERVISED_SYSTEMD) {
2970          return redisSupervisedSystemd();
2971      }
2972      return 0;
2973  }
2974  int main(int argc, char **argv) {
2975      struct timeval tv;
2976      int j;
2977  #ifdef REDIS_TEST
2978      if (argc == 3 && !strcasecmp(argv[1], "test")) {
2979          if (!strcasecmp(argv[2], "ziplist")) {
2980              return ziplistTest(argc, argv);
2981          } else if (!strcasecmp(argv[2], "quicklist")) {
2982              quicklistTest(argc, argv);
2983          } else if (!strcasecmp(argv[2], "intset")) {
2984              return intsetTest(argc, argv);
2985          } else if (!strcasecmp(argv[2], "zipmap")) {
2986              return zipmapTest(argc, argv);
2987          } else if (!strcasecmp(argv[2], "sha1test")) {
2988              return sha1Test(argc, argv);
2989          } else if (!strcasecmp(argv[2], "util")) {
2990              return utilTest(argc, argv);
2991          } else if (!strcasecmp(argv[2], "endianconv")) {
2992              return endianconvTest(argc, argv);
2993          } else if (!strcasecmp(argv[2], "crc64")) {
2994              return crc64Test(argc, argv);
2995          } else if (!strcasecmp(argv[2], "zmalloc")) {
2996              return zmalloc_test(argc, argv);
2997          }
2998          return -1; &bsol;* test not found */
2999      }
3000  #endif
3001  #ifdef INIT_SETPROCTITLE_REPLACEMENT
3002      spt_init(argc, argv);
3003  #endif
3004      setlocale(LC_COLLATE,"");
3005      tzset(); &bsol;* Populates 'timezone' global. */
3006      zmalloc_set_oom_handler(redisOutOfMemoryHandler);
3007  #ifdef _WIN32
3008  #pragma warning( suppress : 6031 )
3009      pthread_mutex_init(&lazyfree_objects_mutex, NULL);
3010  #pragma warning( suppress : 6031 )
3011      pthread_mutex_init(&moduleUnblockedClientsMutex, NULL);
3012  #pragma warning( suppress : 6031 )
3013      pthread_mutex_init(&moduleGIL, NULL);
3014  #endif
3015      srand((unsigned int)time(NULL)^getpid());  WIN_PORT_FIX &bsol;* cast (unsigned int) */
3016      gettimeofday(&tv,NULL);
3017      char hashseed[16];
3018      getRandomHexChars(hashseed,sizeof(hashseed));
3019      dictSetHashFunctionSeed((uint8_t*)hashseed);
3020      server.sentinel_mode = checkForSentinelMode(argc,argv);
3021      initServerConfig();
3022      moduleInitModulesSystem();
3023      server.executable = getAbsolutePath(argv[0]);
3024      server.exec_argv = zmalloc(sizeof(char*)*((size_t)argc+1));
3025      server.exec_argv[argc] = NULL;
3026      for (j = 0; j < argc; j++) server.exec_argv[j] = zstrdup(argv[j]);
3027      if (server.sentinel_mode) {
3028          initSentinelConfig();
3029          initSentinel();
3030      }
3031      if (strstr(argv[0],"redis-check-rdb") != NULL)
3032  #ifdef _WIN32
3033          return
3034  #endif
3035          redis_check_rdb_main(argc,argv,NULL);
3036      else if (strstr(argv[0],"redis-check-aof") != NULL)
3037  #ifdef _WIN32
3038          return
3039  #endif
3040          redis_check_aof_main(argc,argv);
3041      if (argc >= 2) {
3042          j = 1; &bsol;* First option to parse in argv[] */
3043          sds options = sdsempty();
3044          char *configfile = NULL;
3045          if (strcmp(argv[1], "-v") == 0 ||
3046              strcmp(argv[1], "--version") == 0) version();
3047          if (strcmp(argv[1], "--help") == 0 ||
3048              strcmp(argv[1], "-h") == 0) usage();
3049          if (strcmp(argv[1], "--test-memory") == 0) {
3050              if (argc == 3) {
3051                  memtest(atoi(argv[2]), IF_WIN32(5, 50));
3052                  exit(0);
3053              } else {
3054                  fprintf(stderr,"Please specify the amount of memory to test in megabytes.\n");
3055                  fprintf(stderr,"Example: ./redis-server --test-memory 4096\n\n");
3056                  exit(1);
3057              }
3058          }
3059          if (argv[j][0] != '-' || argv[j][1] != '-') {
3060              configfile = argv[j];
3061              server.configfile = getAbsolutePath(configfile);
3062              zfree(server.exec_argv[j]);
3063              server.exec_argv[j] = zstrdup(server.configfile);
3064              j++;
3065          }
3066          while(j != argc) {
3067              if (argv[j][0] == '-' && argv[j][1] == '-') {
3068                  if (!strcmp(argv[j], "--check-rdb")) {
3069                      j++;
3070                      continue;
3071                  }
3072                  if (sdslen(options)) options = sdscat(options,"\n");
3073                  options = sdscat(options,argv[j]+2);
3074                  options = sdscat(options," ");
3075              } else {
3076                  options = sdscatrepr(options,argv[j],strlen(argv[j]));
3077                  options = sdscat(options," ");
3078              }
3079              j++;
3080          }
3081          if (server.sentinel_mode && configfile && *configfile == '-') {
3082              serverLog(LL_WARNING,
3083                  "Sentinel config from STDIN not allowed.");
3084              serverLog(LL_WARNING,
3085                  "Sentinel needs config file on disk to save state.  Exiting...");
3086              exit(1);
3087          }
3088          resetServerSaveParams();
3089          loadServerConfig(configfile,options);
3090          sdsfree(options);
3091      }
3092      serverLog(LL_WARNING, "oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo");
3093      serverLog(LL_WARNING,
3094          "Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started",
3095              REDIS_VERSION,
3096              (sizeof(PORT_LONG) == 8) ? 64 : 32,
3097              redisGitSHA1(),
3098              strtol(redisGitDirty(),NULL,10) > 0,
3099              (int)getpid());
3100      if (argc == 1) {
3101          serverLog(LL_WARNING, "Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf", argv[0], server.sentinel_mode ? "sentinel" : "redis");
3102      } else {
3103          serverLog(LL_WARNING, "Configuration loaded");
3104      }
3105      server.supervised = redisIsSupervised(server.supervised_mode);
3106      int background = server.daemonize && !server.supervised;
3107      if (background) daemonize();
3108      initServer();
3109      if (background || server.pidfile) createPidFile();
3110      redisSetProcTitle(argv[0]);
3111      redisAsciiArt();
3112      checkTcpBacklogSettings();
3113      if (!server.sentinel_mode) {
3114          serverLog(LL_WARNING,"Server initialized");
3115      #ifdef __linux__
3116          linuxMemoryWarnings();
3117      #endif
3118          moduleLoadFromQueue();
3119          InitServerLast();
3120          loadDataFromDisk();
3121          if (server.cluster_enabled) {
3122              if (verifyClusterConfigWithData() == C_ERR) {
3123                  serverLog(LL_WARNING,
3124                      "You can't have keys in a DB different than DB 0 when in "
3125                      "Cluster mode. Exiting.");
3126                  exit(1);
3127              }
3128          }
3129          if (server.ipfd_count > 0)
3130              serverLog(LL_NOTICE,"Ready to accept connections");
3131          if (server.sofd > 0)
3132              serverLog(LL_NOTICE,"The server is now ready to accept connections at %s", server.unixsocket);
3133      } else {
3134          InitServerLast();
3135          sentinelIsRunning();
3136      }
3137      if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {
3138          serverLog(LL_WARNING,"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?", server.maxmemory);
3139      }
3140      aeSetBeforeSleepProc(server.el,beforeSleep);
3141      aeSetAfterSleepProc(server.el,afterSleep);
3142      aeMain(server.el);
3143      aeDeleteEventLoop(server.el);
3144      return 0;
3145  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_RedisLog.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-server.c</div>
                </div>
                <div class="column column_space"><pre><code>139      serverLogRaw(level,msg);
140  }
141  void serverLogFromHandler(int level, const char *msg) {
142  }
</pre></code></div>
                <div class="column column_space"><pre><code>287      serverLogRaw(level,msg);
288  }
289  void serverLogFromHandler(int level, const char *msg) {
290      int fd;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    