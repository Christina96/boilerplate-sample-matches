<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omprog.c &amp; immark.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omprog.c &amp; immark.c
      </h3>
<h1 align="center">
        8.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omprog.c (5.0884957%)<th>immark.c (25.698324%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1117-1125)<td><a href="#" name="0">(167-175)</a><td align="center"><font color="#ff0000">26</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(138-153)<td><a href="#" name="1">(79-92)</a><td align="center"><font color="#c40000">20</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omprog.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;syslog.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;pthread.h&gt;
#include &lt;poll.h&gt;
#include "rsyslog.h"
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "glbl.h"
#include "rsconf.h"
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omprog")
extern char **environ; 
DEF_OMOD_STATIC_DATA
#define NO_HUP_FORWARD -1	#define DEFAULT_CONFIRM_TIMEOUT_MS 10000
#define DEFAULT_CLOSE_TIMEOUT_MS 5000
#define RESPONSE_LINE_BUFFER_SIZE 4096
#define OUTPUT_CAPTURE_BUFFER_SIZE 4096
#define MAX_FD_TO_CLOSE 65535
typedef struct childProcessCtx {
	int bIsRunning;			pid_t pid;				int fdPipeOut;			int fdPipeIn;		} childProcessCtx_t;
typedef struct outputCaptureCtx {
	uchar *szFileName;			mode_t fCreateMode;			pthread_mutex_t mutStart;		pthread_mutex_t mutWrite;		pthread_mutex_t mutTerm;		pthread_cond_t condTerm;		int bIsRunning;				pthread_t thrdID;			int fdPipe[2];				int fdFile;					int bFileErr;				int bReadErr;				int bWriteErr;			} outputCaptureCtx_t;
typedef struct _instanceData {
	uchar *szBinary;			char **aParams;				int iParams;				uchar *szTemplateName;		int bConfirmMessages;		long lConfirmTimeout;		int bReportFailures;		int bUseTransactions;		uchar *szBeginTransactionMark;		uchar *szCommitTransactionMark;		int iHUPForward;			int bSignalOnClose;			long lCloseTimeout;			int bKillUnresponsive;		int bForceSingleInst;		childProcessCtx_t *pSingleChildCtx;			pthread_mutex_t *pSingleChildMut;			outputCaptureCtx_t *pOutputCaptureCtx;		time_t block_if_err;			} instanceData;
typedef struct wrkrInstanceData {
	instanceData *pData;
	childProcessCtx_t *pChildCtx;	} wrkrInstanceData_t;
typedef struct configSettings_s {
	uchar *szBinary;	} configSettings_t;
static configSettings_t cs;
static struct cnfparamdescr actpdescr[] = {
	{ "binary", eCmdHdlrString, CNFPARAM_REQUIRED },
	{ "confirmMessages", eCmdHdlrBinary, 0 },
	{ "confirmTimeout", eCmdHdlrInt, 0 },
	{ "reportFailures", eCmdHdlrBinary, 0 },
	{ "useTransactions", eCmdHdlrBinary, 0 },
	{ "beginTransactionMark", eCmdHdlrString, 0 },
	{ "commitTransactionMark", eCmdHdlrString, 0 },
<a name="1"></a>	{ "forceSingleInstance", eCmdHdlrBinary, 0 },
	{ "hup.signal", eCmdHdlrGetWord, 0 },
	{ "template", eCmdHdlrGetWord, 0 },
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "signalOnClose", eCmdHdlrBinary, 0 },
	{ "closeTimeout", eCmdHdlrInt, 0 },
	{ "killUnresponsive", eCmdHdlrBinary, 0 },
	{ "output", eCmdHdlrString, 0 },
	{ "fileCreateMode", eCmdHdlrFileCreateMode, 0 }
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};
static __attribute__((noreturn)) void</b></font>
execBinary(const instanceData *pData, int fdStdin, int fdStdout)
{
	int fdOutput, maxFd, fd, sigNum;
	struct sigaction sigAct;
	sigset_t sigSet;
	char errStr[1024];
	if(dup2(fdStdin, STDIN_FILENO) == -1) {
		goto failed;
	}
	if(pData-&gt;pOutputCaptureCtx != NULL) {
		fdOutput = pData-&gt;pOutputCaptureCtx-&gt;fdPipe[1];
	} else {
		fdOutput = open("/dev/null", O_WRONLY);
		if(fdOutput == -1) {
			goto failed;
		}
	}
	if(fdStdout != -1) {
		if(dup2(fdStdout, STDOUT_FILENO) == -1) {
			goto failed;
		}
	} else {
		if(dup2(fdOutput, STDOUT_FILENO) == -1) {
			goto failed;
		}
	}
	if(dup2(fdOutput, STDERR_FILENO) == -1) {
		goto failed;
	}
	maxFd = sysconf(_SC_OPEN_MAX);
	if(maxFd &lt; 0 || maxFd &gt; MAX_FD_TO_CLOSE) {
		maxFd = MAX_FD_TO_CLOSE;
	}
#	ifdef VALGRIND
	else {  		maxFd -= 10;
	}
#	endif
	for(fd = STDERR_FILENO + 1 ; fd &lt;= maxFd ; ++fd) {
		close(fd);
	}
	memset(&amp;sigAct, 0, sizeof(sigAct));
	sigemptyset(&amp;sigAct.sa_mask);
	sigAct.sa_handler = SIG_DFL;
	for(sigNum = 1 ; sigNum &lt; NSIG ; ++sigNum) {
		sigaction(sigNum, &amp;sigAct, NULL);
	}
	sigAct.sa_handler = SIG_IGN;
	sigaction(SIGINT, &amp;sigAct, NULL);
	sigemptyset(&amp;sigSet);
	sigprocmask(SIG_SETMASK, &amp;sigSet, NULL);
	alarm(0);
	execve((char*)pData-&gt;szBinary, pData-&gt;aParams, environ);
failed:
	rs_strerror_r(errno, errStr, sizeof(errStr));
	DBGPRINTF("omprog: failed to execute program '%s': %s\n",
			pData-&gt;szBinary, errStr);
	openlog("rsyslogd", 0, LOG_SYSLOG);
	syslog(LOG_ERR, "omprog: failed to execute program '%s': %s\n",
			pData-&gt;szBinary, errStr);
	exit(1);
}
static rsRetVal
openPipe(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	int pipeStdin[2] = { -1, -1 };
	int pipeStdout[2] = { -1, -1 };
	pid_t cpid;
	DEFiRet;
	if(pipe(pipeStdin) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}
	if(pData-&gt;bConfirmMessages &amp;&amp; pipe(pipeStdout) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}
	DBGPRINTF("omprog: executing program '%s' with '%d' parameters\n", pData-&gt;szBinary,
			pData-&gt;iParams);
	cpid = fork();
	if(cpid == -1) {
		ABORT_FINALIZE(RS_RET_ERR_FORK);
	}
	if(cpid == 0) {  		close(pipeStdin[1]);
		if(pipeStdout[0] != -1) {
			close(pipeStdout[0]);
		}
		execBinary(pData, pipeStdin[0], pipeStdout[1]);
	}
	DBGPRINTF("omprog: child has pid %d\n", (int) cpid);
	close(pipeStdin[0]);
	if(pipeStdout[1] != -1) {
		close(pipeStdout[1]);
	}
	pChildCtx-&gt;fdPipeOut = pipeStdin[1];  	pChildCtx-&gt;fdPipeIn = pipeStdout[0];  	pChildCtx-&gt;pid = cpid;
	pChildCtx-&gt;bIsRunning = 1;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pipeStdin[0] != -1) {
			close(pipeStdin[0]);
			close(pipeStdin[1]);
		}
		if(pipeStdout[0] != -1) {
			close(pipeStdout[0]);
			close(pipeStdout[1]);
		}
	}
	RETiRet;
}
static void
waitForChild(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	int status;
	int ret;
	long counter;
	counter = pData-&gt;lCloseTimeout / 10;
	while ((ret = waitpid(pChildCtx-&gt;pid, &amp;status, WNOHANG)) == 0 &amp;&amp; counter &gt; 0) {
		srSleep(0, 10000);  		--counter;
	}
	if (ret == 0) {  		if (!pData-&gt;bKillUnresponsive) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' (pid %ld) did not terminate "
					"within timeout (%ld ms); ignoring it", pData-&gt;szBinary,
					(long) pChildCtx-&gt;pid, pData-&gt;lCloseTimeout);
			return;
		}
		LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' (pid %ld) did not terminate "
				"within timeout (%ld ms); killing it", pData-&gt;szBinary, (long) pChildCtx-&gt;pid,
				pData-&gt;lCloseTimeout);
		if (kill(pChildCtx-&gt;pid, SIGKILL) == -1) {
			LogError(errno, RS_RET_SYS_ERR, "omprog: could not send SIGKILL to child process");
			return;
		}
		ret = waitpid(pChildCtx-&gt;pid, &amp;status, 0);
	}
	if(ret == pChildCtx-&gt;pid) {
		glblReportChildProcessExit(runConf, pData-&gt;szBinary, pChildCtx-&gt;pid, status);
	}
}
static void
cleanupChild(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	assert(pChildCtx-&gt;bIsRunning);
	if(pChildCtx-&gt;fdPipeIn != -1) {
		close(pChildCtx-&gt;fdPipeIn);
		pChildCtx-&gt;fdPipeIn = -1;
	}
	if(pChildCtx-&gt;fdPipeOut != -1) {
		close(pChildCtx-&gt;fdPipeOut);
		pChildCtx-&gt;fdPipeOut = -1;
	}
	waitForChild(pData, pChildCtx);
	pChildCtx-&gt;bIsRunning = 0;
}
static void
terminateChild(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	assert(pChildCtx-&gt;bIsRunning);
	if (pData-&gt;bSignalOnClose) {
		kill(pChildCtx-&gt;pid, SIGTERM);
	}
	cleanupChild(pData, pChildCtx);
}
static rsRetVal
sendMessage(instanceData *pData, childProcessCtx_t *pChildCtx, const uchar *szMsg)
{
	ssize_t written;
	size_t offset = 0;
	DEFiRet;
	const size_t len = strlen((char*)szMsg);
	do {
		written = write(pChildCtx-&gt;fdPipeOut, ((char*)szMsg) + offset, len - offset);
		if(written == -1) {
			if(errno == EINTR) {
				continue;  			}
			if(errno == EPIPE) {
				LogMsg(0, RS_RET_ERR_WRITE_PIPE, LOG_WARNING,
						"omprog: program '%s' (pid %ld) terminated; will be restarted",
						pData-&gt;szBinary, (long) pChildCtx-&gt;pid);
				cleanupChild(pData, pChildCtx);  				ABORT_FINALIZE(RS_RET_SUSPENDED);
			}
			LogError(errno, RS_RET_ERR_WRITE_PIPE, "omprog: error sending message to program");
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		offset += written;
	} while(offset &lt; len);
finalize_it:
	RETiRet;
}
static rsRetVal
lineToStatusCode(instanceData *pData, const char* line)
{
	DEFiRet;
	while(line[0] == '.') {
		++line;
	}
	if(strcmp(line, "OK") == 0) {
		iRet = RS_RET_OK;
	} else if(strcmp(line, "DEFER_COMMIT") == 0) {
		iRet = RS_RET_DEFER_COMMIT;
	} else if(strcmp(line, "PREVIOUS_COMMITTED") == 0) {
		iRet = RS_RET_PREVIOUS_COMMITTED;
	} else {
		DBGPRINTF("omprog: program '%s' returned: %s\n", pData-&gt;szBinary, line);
		if(pData-&gt;bReportFailures) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned: %s",
					pData-&gt;szBinary, line);
		}
		iRet = RS_RET_SUSPENDED;
	}
	RETiRet;
}
static rsRetVal
readStatus(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	struct pollfd fdToPoll[1];
	int numReady;
	char lineBuf[RESPONSE_LINE_BUFFER_SIZE];
	ssize_t lenRead;
	size_t offset = 0;
	int lineEnded = 0;
	DEFiRet;
	fdToPoll[0].fd = pChildCtx-&gt;fdPipeIn;
	fdToPoll[0].events = POLLIN;
	do {
		numReady = poll(fdToPoll, 1, pData-&gt;lConfirmTimeout);
		if(numReady == -1) {
			if(errno == EINTR) {
				continue;  			}
			LogError(errno, RS_RET_SYS_ERR, "omprog: error polling for response from program");
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		if(numReady == 0) {  			LogMsg(0, RS_RET_TIMED_OUT, LOG_WARNING, "omprog: program '%s' (pid %ld) did not respond "
					"within timeout (%ld ms); will be restarted", pData-&gt;szBinary,
					(long) pChildCtx-&gt;pid, pData-&gt;lConfirmTimeout);
			terminateChild(pData, pChildCtx);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		lenRead = read(pChildCtx-&gt;fdPipeIn, lineBuf + offset, sizeof(lineBuf) - offset - 1);
		if(lenRead == -1) {
			if(errno == EINTR) {
				continue;  			}
			LogError(errno, RS_RET_READ_ERR, "omprog: error reading response from program");
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		if(lenRead == 0) {
			LogMsg(0, RS_RET_READ_ERR, LOG_WARNING, "omprog: program '%s' (pid %ld) terminated; "
					"will be restarted", pData-&gt;szBinary, (long) pChildCtx-&gt;pid);
			cleanupChild(pData, pChildCtx);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		offset += lenRead;
		lineBuf[offset] = '\0';
		lineEnded = (lineBuf[offset-1] == '\n');
		if(!lineEnded &amp;&amp; strchr(lineBuf + offset - lenRead, '\n') != NULL) {
			DBGPRINTF("omprog: program '%s' returned: %s\n", pData-&gt;szBinary, lineBuf);
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned a multiline response; "
					"will be restarted", pData-&gt;szBinary);
			if(pData-&gt;bReportFailures) {
				LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned: %s",
						pData-&gt;szBinary, lineBuf);
			}
			terminateChild(pData, pChildCtx);
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
	} while(!lineEnded &amp;&amp; offset &lt; sizeof(lineBuf) - 1);
	if(!lineEnded) {
		DBGPRINTF("omprog: program '%s' returned: %s\n", pData-&gt;szBinary, lineBuf);
		LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned a too long response; "
				"will be restarted", pData-&gt;szBinary);
		if(pData-&gt;bReportFailures) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: program '%s' returned: %s",
					pData-&gt;szBinary, lineBuf);
		}
		terminateChild(pData, pChildCtx);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	lineBuf[offset-1] = '\0';  
	iRet = lineToStatusCode(pData, lineBuf);
finalize_it:
	RETiRet;
}
static rsRetVal
allocChildCtx(childProcessCtx_t **ppChildCtx)
{
	childProcessCtx_t *pChildCtx;
	DEFiRet;
	CHKmalloc(pChildCtx = calloc(1, sizeof(childProcessCtx_t)));
	*ppChildCtx = pChildCtx;
	pChildCtx-&gt;bIsRunning = 0;
	pChildCtx-&gt;pid = -1;
	pChildCtx-&gt;fdPipeOut = -1;
	pChildCtx-&gt;fdPipeIn = -1;
finalize_it:
	RETiRet;
}
static rsRetVal
startChild(instanceData *pData, childProcessCtx_t *pChildCtx)
{
	DEFiRet;
	assert(!pChildCtx-&gt;bIsRunning);
	CHKiRet(openPipe(pData, pChildCtx));
	if(pData-&gt;bConfirmMessages) {
		CHKiRet(readStatus(pData, pChildCtx));
	}
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; pChildCtx-&gt;bIsRunning) {
		terminateChild(pData, pChildCtx);
	}
	RETiRet;
}
static rsRetVal
startSingleChildOnce(instanceData *pData)
{
	DEFiRet;
	assert(pData-&gt;bForceSingleInst);
	CHKiConcCtrl(pthread_mutex_lock(pData-&gt;pSingleChildMut));
	if(pData-&gt;pSingleChildCtx-&gt;bIsRunning)
		goto finalize_it;  
	iRet = startChild(pData, pData-&gt;pSingleChildCtx);
finalize_it:
	pthread_mutex_unlock(pData-&gt;pSingleChildMut);
	RETiRet;
}
static void
writeOutputToFile(outputCaptureCtx_t *pCtx, char *buf, ssize_t len)
{
	ssize_t written;
	ssize_t offset = 0;
	assert(pCtx-&gt;bIsRunning);
	pthread_mutex_lock(&amp;pCtx-&gt;mutWrite);
	if(pCtx-&gt;fdFile == -1) {
		if(pCtx-&gt;bFileErr) {  			goto done;
		}
		pCtx-&gt;fdFile = open((char*)pCtx-&gt;szFileName, O_WRONLY | O_APPEND | O_CREAT,
				pCtx-&gt;fCreateMode);
		if(pCtx-&gt;fdFile == -1) {
			LogError(errno, RS_RET_NO_FILE_ACCESS, "omprog: error opening output file %s; "
					"output from program will be discarded", pCtx-&gt;szFileName);
			pCtx-&gt;bFileErr = 1;  			goto done;
		}
	}
	do {
		written = write(pCtx-&gt;fdFile, buf + offset, len - offset);
		if(written == -1) {
			if(errno == EINTR) {
				continue;  			}
			if(!pCtx-&gt;bWriteErr) {
				LogError(errno, RS_RET_SYS_ERR, "omprog: error writing to output file "
						"(subsequent errors will not be reported)");
				pCtx-&gt;bWriteErr = 1;  			}
			break;
		}
		if(pCtx-&gt;bWriteErr) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: resumed writing to output file");
			pCtx-&gt;bWriteErr = 0;
		}
		offset += written;
	} while(offset &lt; len);
done:
	pthread_mutex_unlock(&amp;pCtx-&gt;mutWrite);
}
static void
closeOutputFile(outputCaptureCtx_t *pCtx)
{
	DBGPRINTF("omprog: reopening output file upon reception of HUP signal\n");
	pthread_mutex_lock(&amp;pCtx-&gt;mutWrite);
	if(pCtx-&gt;fdFile != -1) {
		close(pCtx-&gt;fdFile);
		pCtx-&gt;fdFile = -1;
	}
	pCtx-&gt;bFileErr = 0;  
	pthread_mutex_unlock(&amp;pCtx-&gt;mutWrite);
}
static void *
captureOutput(void *_pCtx) {
	outputCaptureCtx_t *pCtx = (outputCaptureCtx_t *)_pCtx;
	sigset_t sigSet;
	char readBuf[OUTPUT_CAPTURE_BUFFER_SIZE];
	ssize_t lenRead;
	DBGPRINTF("omprog: starting output capture thread\n");
	sigfillset(&amp;sigSet);
	pthread_sigmask(SIG_SETMASK, &amp;sigSet, NULL);
	for(;;) {
		lenRead = read(pCtx-&gt;fdPipe[0], readBuf, sizeof(readBuf));
		if(lenRead == -1) {
			if(errno == EINTR) {
				continue;  			}
			if(!pCtx-&gt;bReadErr) {
				LogError(errno, RS_RET_SYS_ERR, "omprog: error capturing output from program "
						"(subsequent errors will not be reported)");
				pCtx-&gt;bReadErr = 1;  			}
			continue;  		}
		if(lenRead == 0) {
			break;  		}
		if(pCtx-&gt;bReadErr) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: resumed capturing output from program");
			pCtx-&gt;bReadErr = 0;
		}
		writeOutputToFile(pCtx, readBuf, lenRead);
	}
	DBGPRINTF("omprog: all output-capture pipe ends closed, terminating output capture thread\n");
	pthread_mutex_lock(&amp;pCtx-&gt;mutTerm);
	pCtx-&gt;bIsRunning = 0;
	pthread_cond_signal(&amp;pCtx-&gt;condTerm);
	pthread_mutex_unlock(&amp;pCtx-&gt;mutTerm);
	return NULL;
}
static rsRetVal
allocOutputCaptureCtx(outputCaptureCtx_t **ppCtx)
{
	outputCaptureCtx_t *pCtx;
	DEFiRet;
	CHKmalloc(pCtx = calloc(1, sizeof(outputCaptureCtx_t)));
	*ppCtx = pCtx;
	pCtx-&gt;szFileName = NULL;
	pCtx-&gt;fCreateMode = 0600;
	pCtx-&gt;bIsRunning = 0;
	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutStart, NULL));
	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutWrite, NULL));
	CHKiConcCtrl(pthread_mutex_init(&amp;pCtx-&gt;mutTerm, NULL));
	CHKiConcCtrl(pthread_cond_init(&amp;pCtx-&gt;condTerm, NULL));
finalize_it:
	RETiRet;
}
static void
freeOutputCaptureCtx(outputCaptureCtx_t *pCtx) {
	if(pCtx-&gt;szFileName != NULL) {
		free(pCtx-&gt;szFileName);
	}
	pthread_cond_destroy(&amp;pCtx-&gt;condTerm);
	pthread_mutex_destroy(&amp;pCtx-&gt;mutTerm);
	pthread_mutex_destroy(&amp;pCtx-&gt;mutWrite);
	pthread_mutex_destroy(&amp;pCtx-&gt;mutStart);
	free(pCtx);
}
static rsRetVal
startOutputCaptureOnce(outputCaptureCtx_t *pCtx)
{
	int pip[2] = { -1, -1 };
	DEFiRet;
	CHKiConcCtrl(pthread_mutex_lock(&amp;pCtx-&gt;mutStart));
	if(pCtx-&gt;bIsRunning)
		goto finalize_it;  
	if(pipe(pip) == -1) {
		ABORT_FINALIZE(RS_RET_ERR_CREAT_PIPE);
	}
	pCtx-&gt;fdPipe[0] = pip[0];
	pCtx-&gt;fdPipe[1] = pip[1];
	pCtx-&gt;fdFile = -1;
	pCtx-&gt;bFileErr = 0;
	pCtx-&gt;bReadErr = 0;
	pCtx-&gt;bWriteErr = 0;
	CHKiConcCtrl(pthread_create(&amp;pCtx-&gt;thrdID, NULL, captureOutput, (void *)pCtx));
	pCtx-&gt;bIsRunning = 1;
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; pip[0] != -1) {
		close(pip[0]);
		close(pip[1]);
	}
	pthread_mutex_unlock(&amp;pCtx-&gt;mutStart);
	RETiRet;
}
static void
endOutputCapture(outputCaptureCtx_t *pCtx, long timeoutMs)
{
	struct timespec ts;
	int bTimedOut;
	assert(pCtx-&gt;bIsRunning);
	close(pCtx-&gt;fdPipe[1]);
	timeoutComp(&amp;ts, timeoutMs);
	pthread_mutex_lock(&amp;pCtx-&gt;mutTerm);
	bTimedOut = 0;
	while(pCtx-&gt;bIsRunning &amp;&amp; !bTimedOut) {
		if(pthread_cond_timedwait(&amp;pCtx-&gt;condTerm, &amp;pCtx-&gt;mutTerm, &amp;ts) == ETIMEDOUT) {
			bTimedOut = 1;
		}
	}
	pthread_mutex_unlock(&amp;pCtx-&gt;mutTerm);
	if(bTimedOut) {
		LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: forcing termination of output capture "
				"thread because of unresponsive child process");
		pthread_cancel(pCtx-&gt;thrdID);
		pCtx-&gt;bIsRunning = 0;
	}
	pthread_join(pCtx-&gt;thrdID, NULL);
	close(pCtx-&gt;fdPipe[0]);
	if(pCtx-&gt;fdFile != -1) {
		close(pCtx-&gt;fdFile);
	}
}
BEGINinitConfVars		CODESTARTinitConfVars
	cs.szBinary = NULL;	ENDinitConfVars
BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;szBinary = NULL;
	pData-&gt;szTemplateName = NULL;
	pData-&gt;aParams = NULL;
	pData-&gt;iParams = 0;
	pData-&gt;bConfirmMessages = 0;
	pData-&gt;block_if_err = 0;
	pData-&gt;lConfirmTimeout = DEFAULT_CONFIRM_TIMEOUT_MS;
	pData-&gt;bReportFailures = 0;
	pData-&gt;bUseTransactions = 0;
	pData-&gt;szBeginTransactionMark = NULL;
	pData-&gt;szCommitTransactionMark = NULL;
	pData-&gt;iHUPForward = NO_HUP_FORWARD;
	pData-&gt;bSignalOnClose = 0;
	pData-&gt;lCloseTimeout = DEFAULT_CLOSE_TIMEOUT_MS;
	pData-&gt;bKillUnresponsive = -1;
	pData-&gt;bForceSingleInst = 0;
	pData-&gt;pSingleChildCtx = NULL;
	pData-&gt;pSingleChildMut = NULL;
	pData-&gt;pOutputCaptureCtx = NULL;
ENDcreateInstance
static rsRetVal
postInitInstance(instanceData *pData)
{
	DEFiRet;
	if(pData-&gt;bUseTransactions &amp;&amp; pData-&gt;szBeginTransactionMark == NULL) {
		pData-&gt;szBeginTransactionMark = (uchar*)strdup("BEGIN TRANSACTION");
	}
	if(pData-&gt;bUseTransactions &amp;&amp; pData-&gt;szCommitTransactionMark == NULL) {
		pData-&gt;szCommitTransactionMark = (uchar*)strdup("COMMIT TRANSACTION");
	}
	if(pData-&gt;bKillUnresponsive == -1) {  		pData-&gt;bKillUnresponsive = pData-&gt;bSignalOnClose;
	}
	if(pData-&gt;pOutputCaptureCtx != NULL &amp;&amp; pData-&gt;pOutputCaptureCtx-&gt;szFileName == NULL) {
		LogError(0, RS_RET_CONF_PARAM_INVLD, "omprog: the 'fileCreateMode' parameter requires "
				"specifying the 'output' parameter also");
		ABORT_FINALIZE(RS_RET_CONF_PARAM_INVLD);
	}
	if(pData-&gt;bForceSingleInst) {
		CHKmalloc(pData-&gt;pSingleChildMut = calloc(1, sizeof(pthread_mutex_t)));
		CHKiConcCtrl(pthread_mutex_init(pData-&gt;pSingleChildMut, NULL));
		CHKiRet(allocChildCtx(&amp;pData-&gt;pSingleChildCtx));
	}
finalize_it:
	RETiRet;
}
BEGINcreateWrkrInstance
CODESTARTcreateWrkrInstance
	pWrkrData-&gt;pChildCtx = NULL;
	if(pWrkrData-&gt;pData-&gt;pOutputCaptureCtx != NULL) {
		CHKiRet(startOutputCaptureOnce(pWrkrData-&gt;pData-&gt;pOutputCaptureCtx));
	}
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiRet(startSingleChildOnce(pWrkrData-&gt;pData));
		pWrkrData-&gt;pChildCtx = pData-&gt;pSingleChildCtx;
	} else {
		CHKiRet(allocChildCtx(&amp;pWrkrData-&gt;pChildCtx));
		CHKiRet(startChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	}
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; !pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		free(pWrkrData-&gt;pChildCtx);
	}
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction) {
		iRet = RS_RET_OK;
	}
ENDisCompatibleWithFeature
BEGINdbgPrintInstInfo
CODESTARTdbgPrintInstInfo
ENDdbgPrintInstInfo
BEGINtryResume
CODESTARTtryResume
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
	}
	if(!pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
		CHKiRet(startChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	}
finalize_it:
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
	}
ENDtryResume
BEGINbeginTransaction
CODESTARTbeginTransaction
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
	}
	if(!pWrkrData-&gt;pData-&gt;bUseTransactions) {
		FINALIZE;
	}
	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx,
			pWrkrData-&gt;pData-&gt;szBeginTransactionMark));
	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) "\n"));
	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	}
finalize_it:
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
	}
ENDbeginTransaction
BEGINdoAction
CODESTARTdoAction
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
	}
	if(!pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {  		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	const uchar *const szMsg = ppString[0];
	const size_t len = strlen((char*)szMsg);
	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, szMsg));
	if(szMsg[len-1] != '\n') {
		const time_t tt = time(NULL);
		if(tt &gt; pWrkrData-&gt;pData-&gt;block_if_err) {
			LogMsg(0, NO_ERRCODE, LOG_WARNING, "omprog: messages must be terminated with \\n "
				"at end of message, but this message is not: '%s'\n", ppString[0]);
			pWrkrData-&gt;pData-&gt;block_if_err = tt + 30;
		}
		CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) "\n"));
	}
	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	} else if(pWrkrData-&gt;pData-&gt;bUseTransactions) {
		iRet = RS_RET_DEFER_COMMIT;
	}
finalize_it:
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
	}
ENDdoAction
BEGINendTransaction
CODESTARTendTransaction
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		CHKiConcCtrl(pthread_mutex_lock(pWrkrData-&gt;pData-&gt;pSingleChildMut));
	}
	if(!pWrkrData-&gt;pData-&gt;bUseTransactions) {
		FINALIZE;
	}
	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx,
			pWrkrData-&gt;pData-&gt;szCommitTransactionMark));
	CHKiRet(sendMessage(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx, (uchar*) "\n"));
	if(pWrkrData-&gt;pData-&gt;bConfirmMessages) {
		CHKiRet(readStatus(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx));
	}
finalize_it:
	if(pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		pthread_mutex_unlock(pWrkrData-&gt;pData-&gt;pSingleChildMut);
	}
ENDendTransaction
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	if(!pWrkrData-&gt;pData-&gt;bForceSingleInst) {
		if(pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
			terminateChild(pWrkrData-&gt;pData, pWrkrData-&gt;pChildCtx);
		}
		free(pWrkrData-&gt;pChildCtx);
	}
ENDfreeWrkrInstance
BEGINfreeInstance
	int i;
CODESTARTfreeInstance
	if(pData-&gt;pSingleChildCtx != NULL) {
		if(pData-&gt;pSingleChildCtx-&gt;bIsRunning) {
			terminateChild(pData, pData-&gt;pSingleChildCtx);
		}
		free(pData-&gt;pSingleChildCtx);
	}
	if(pData-&gt;pSingleChildMut != NULL) {
		pthread_mutex_destroy(pData-&gt;pSingleChildMut);
		free(pData-&gt;pSingleChildMut);
	}
	if(pData-&gt;pOutputCaptureCtx != NULL) {
		if(pData-&gt;pOutputCaptureCtx-&gt;bIsRunning) {
			endOutputCapture(pData-&gt;pOutputCaptureCtx, pData-&gt;lCloseTimeout);
		}
		freeOutputCaptureCtx(pData-&gt;pOutputCaptureCtx);
	}
	free(pData-&gt;szBinary);
	free(pData-&gt;szTemplateName);
	free(pData-&gt;szBeginTransactionMark);
	free(pData-&gt;szCommitTransactionMark);
	if(pData-&gt;aParams != NULL) {
		for (i = 0; i &lt; pData-&gt;iParams; i++) {
			free(pData-&gt;aParams[i]);
		}
		free(pData-&gt;aParams);
	}
ENDfreeInstance
BEGINnewActInst
	struct cnfparamvals *pvals;
	int i;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CHKiRet(createInstance(&amp;pData));
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "binary")) {
			CHKiRet(split_binary_parameters(&amp;pData-&gt;szBinary, &amp;pData-&gt;aParams, &amp;pData-&gt;iParams,
				pvals[i].val.d.estr));
		} else if(!strcmp(actpblk.descr[i].name, "confirmMessages")) {
<a name="0"></a>			pData-&gt;bConfirmMessages = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "confirmTimeout")) {
			pData-&gt;lConfirmTimeout = (long) pvals[i].val.d.n;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "reportFailures")) {
			pData-&gt;bReportFailures = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "useTransactions")) {
			pData-&gt;bUseTransactions = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "beginTransactionMark")) {
			pData-&gt;szBeginTransactionMark = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "commitTransactionMark")) {
			pData-&gt;szCommitTransactionMark = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "forceSingleInstance")) {</b></font>
			pData-&gt;bForceSingleInst = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "signalOnClose")) {
			pData-&gt;bSignalOnClose = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "closeTimeout")) {
			pData-&gt;lCloseTimeout = (long) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "killUnresponsive")) {
			pData-&gt;bKillUnresponsive = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "hup.signal")) {
			const char *const sig = es_str2cstr(pvals[i].val.d.estr, NULL);
			if(!strcmp(sig, "HUP"))
				pData-&gt;iHUPForward = SIGHUP;
			else if(!strcmp(sig, "USR1"))
				pData-&gt;iHUPForward = SIGUSR1;
			else if(!strcmp(sig, "USR2"))
				pData-&gt;iHUPForward = SIGUSR2;
			else if(!strcmp(sig, "INT"))
				pData-&gt;iHUPForward = SIGINT;
			else if(!strcmp(sig, "TERM"))
				pData-&gt;iHUPForward = SIGTERM;
			else {
				LogError(0, RS_RET_CONF_PARAM_INVLD,
					"omprog: hup.signal '%s' in hup.signal parameter", sig);
				ABORT_FINALIZE(RS_RET_CONF_PARAM_INVLD);
			}
			free((void*)sig);
		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;szTemplateName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "output")) {
			if(pData-&gt;pOutputCaptureCtx == NULL) {
				CHKiRet(allocOutputCaptureCtx(&amp;pData-&gt;pOutputCaptureCtx));
			}
			pData-&gt;pOutputCaptureCtx-&gt;szFileName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "fileCreateMode")) {
			if(pData-&gt;pOutputCaptureCtx == NULL) {
				CHKiRet(allocOutputCaptureCtx(&amp;pData-&gt;pOutputCaptureCtx));
			}
			pData-&gt;pOutputCaptureCtx-&gt;fCreateMode = (mode_t) pvals[i].val.d.n;
		} else {
			DBGPRINTF("omprog: program error, non-handled param '%s'\n", actpblk.descr[i].name);
		}
	}
	CODE_STD_STRING_REQUESTnewActInst(1)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup(pData-&gt;szTemplateName == NULL ?
			"RSYSLOG_FileFormat" : (char*)pData-&gt;szTemplateName), OMSR_NO_RQD_TPL_OPTS));
	iRet = postInitInstance(pData);
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
ENDnewActInst
BEGINparseSelectorAct
CODESTARTparseSelectorAct
CODE_STD_STRING_REQUESTparseSelectorAct(1)
	if(strncmp((char*) p, ":omprog:", sizeof(":omprog:") - 1)) {
		ABORT_FINALIZE(RS_RET_CONFLINE_UNPROCESSED);
	}
	p += sizeof(":omprog:") - 1; 	if(cs.szBinary == NULL) {
		LogError(0, RS_RET_CONF_RQRD_PARAM_MISSING, "no binary to execute specified");
		ABORT_FINALIZE(RS_RET_CONF_RQRD_PARAM_MISSING);
	}
	CHKiRet(createInstance(&amp;pData));
	CHKmalloc(pData-&gt;szBinary = (uchar*) strdup((char*)cs.szBinary));
	if(*(p-1) == ';')
		--p;
	CHKiRet(cflineParseTemplateName(&amp;p, *ppOMSR, 0, 0, (uchar*) "RSYSLOG_FileFormat"));
	iRet = postInitInstance(pData);
CODE_STD_FINALIZERparseSelectorAct
ENDparseSelectorAct
BEGINdoHUP
CODESTARTdoHUP
	if(pData-&gt;bForceSingleInst &amp;&amp; pData-&gt;iHUPForward != NO_HUP_FORWARD &amp;&amp;
			pData-&gt;pSingleChildCtx-&gt;bIsRunning) {
		DBGPRINTF("omprog: forwarding HUP to program '%s' (pid %ld) as signal %d\n",
				pData-&gt;szBinary, (long) pData-&gt;pSingleChildCtx-&gt;pid, pData-&gt;iHUPForward);
		kill(pData-&gt;pSingleChildCtx-&gt;pid, pData-&gt;iHUPForward);
	}
	if(pData-&gt;pOutputCaptureCtx != NULL &amp;&amp; pData-&gt;pOutputCaptureCtx-&gt;bIsRunning) {
		closeOutputFile(pData-&gt;pOutputCaptureCtx);
	}
ENDdoHUP
BEGINdoHUPWrkr
CODESTARTdoHUPWrkr
	if(!pWrkrData-&gt;pData-&gt;bForceSingleInst &amp;&amp; pWrkrData-&gt;pData-&gt;iHUPForward != NO_HUP_FORWARD &amp;&amp;
	 		pWrkrData-&gt;pChildCtx-&gt;bIsRunning) {
		DBGPRINTF("omprog: forwarding HUP to program '%s' (pid %ld) as signal %d\n",
				pWrkrData-&gt;pData-&gt;szBinary, (long) pWrkrData-&gt;pChildCtx-&gt;pid,
				pWrkrData-&gt;pData-&gt;iHUPForward);
		kill(pWrkrData-&gt;pChildCtx-&gt;pid, pWrkrData-&gt;pData-&gt;iHUPForward);
	}
ENDdoHUPWrkr
BEGINmodExit
CODESTARTmodExit
	free(cs.szBinary);
	cs.szBinary = NULL;
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_TXIF_OMOD_QUERIES CODEqueryEtryPt_doHUP
CODEqueryEtryPt_doHUPWrkr
ENDqueryEtryPt
static rsRetVal
resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	DEFiRet;
	free(cs.szBinary);
	cs.szBinary = NULL;
	RETiRet;
}
BEGINmodInit()
CODESTARTmodInit
INITLegCnfVars
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	INITChkCoreFeature(bCoreSupportsBatching, CORE_FEATURE_BATCHING);
	if (!bCoreSupportsBatching) {
		LogError(0, NO_ERRCODE, "omprog: rsyslog core too old (does not support batching)");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"actionomprogbinary", 0, eCmdHdlrGetWord, NULL, &amp;cs.szBinary,
		STD_LOADABLE_MODULE_ID));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler, resetConfigVariables,
		NULL, STD_LOADABLE_MODULE_ID));
CODEmodInit_QueryRegCFSLineHdlr
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>immark.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include "dirty.h"
#include "cfsysline.h"
#include "module-template.h"
#include "errmsg.h"
#include "msg.h"
#include "srUtils.h"
#include "glbl.h"
#include "unicode-helper.h"
#include "ruleset.h"
#include "prop.h"
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("immark")
#define DEFAULT_MARK_PERIOD (20 * 60)
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
static int iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
struct modConfData_s {
	rsconf_t *pConf;		const char *pszMarkMsgText;
	size_t lenMarkMsgText;
	uchar *pszBindRuleset;
	ruleset_t *pBindRuleset;
	int flags;
	int bUseMarkFlag;
	int bUseSyslogAPI;
	int iMarkMessagePeriod;
	sbool configSetViaV2Method;
};
<a name="1"></a>
static struct cnfparamdescr modpdescr[] = {
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "ruleset", eCmdHdlrString, 0 },
	{ "markmessagetext", eCmdHdlrString, 0 },
	{ "use.syslogcall", eCmdHdlrBinary, 0 },
	{ "use.markflag", eCmdHdlrBinary, 0 },
	{ "interval", eCmdHdlrInt, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static modConfData_t *loadModConf = NULL;static int bLegacyCnfModGlobalsPermitted;static prop_t *pInternalInputName = NULL;
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINafterRun
CODESTARTafterRun
ENDafterRun
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;pszMarkMsgText = NULL;
	pModConf-&gt;iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
	pModConf-&gt;bUseSyslogAPI = 1;
	pModConf-&gt;bUseMarkFlag = 1;
	pModConf-&gt;pszBindRuleset = NULL;
	pModConf-&gt;pBindRuleset = NULL;
	loadModConf-&gt;configSetViaV2Method = 0;
	bLegacyCnfModGlobalsPermitted = 1;
ENDbeginCnfLoad
static rsRetVal
checkRuleset(modConfData_t *modConf)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;
	if(modConf-&gt;pszBindRuleset == NULL)
		FINALIZE;
	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
	if(localRet == RS_RET_NOT_FOUND) {
		LogError(0, NO_ERRCODE, "immark: ruleset '%s' not found - "
				"using default ruleset instead", modConf-&gt;pszBindRuleset);
	}
	CHKiRet(localRet);
	modConf-&gt;pBindRuleset = pRuleset;
finalize_it:
	RETiRet;
}
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for immark:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
<a name="0"></a>			continue;
		if(!strcmp(modpblk.descr[i].name, "interval")) {
			loadModConf-&gt;iMarkMessagePeriod = (int) pvals[i].val.d.n;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "use.syslogcall")) {
			loadModConf-&gt;bUseSyslogAPI = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "use.markflag")) {
			loadModConf-&gt;bUseMarkFlag = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "ruleset")) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "markmessagetext")) {
			loadModConf-&gt;pszMarkMsgText = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {</b></font>
			dbgprintf("immark: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		pModConf-&gt;iMarkMessagePeriod = iMarkMessagePeriod;
	}
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
	pModConf-&gt;flags = (pModConf-&gt;bUseMarkFlag) ? MARK : 0;
	if(pModConf-&gt;pszMarkMsgText == NULL) {
		pModConf-&gt;pszMarkMsgText = strdup("-- MARK --");
	}
	pModConf-&gt;lenMarkMsgText = strlen(pModConf-&gt;pszMarkMsgText);
	if(pModConf-&gt;pszBindRuleset != NULL) {
		checkRuleset(pModConf);
		if(pModConf-&gt;bUseSyslogAPI) {
			LogError(0, NO_ERRCODE, "immark: ruleset specified, but configured to log "
				"via syslog call - switching to rsyslog-internal logging");
			pModConf-&gt;bUseSyslogAPI = 0;
		}
	}
	if(pModConf-&gt;iMarkMessagePeriod == 0) {
		LogError(0, NO_ERRCODE, "immark: mark message period must not be 0, can not run");
		ABORT_FINALIZE(RS_RET_NO_RUN);		}
finalize_it:
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	MarkInterval = pModConf-&gt;iMarkMessagePeriod;
	DBGPRINTF("immark set MarkInterval to %d\n", MarkInterval);
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf
static rsRetVal
injectMarkMessage(const int pri)
{
	smsg_t *pMsg;
	DEFiRet;
	CHKiRet(msgConstruct(&amp;pMsg));
	pMsg-&gt;msgFlags  = loadModConf-&gt;flags;
	MsgSetInputName(pMsg, pInternalInputName);
	MsgSetRawMsg(pMsg, loadModConf-&gt;pszMarkMsgText,loadModConf-&gt;lenMarkMsgText);
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
	MsgSetMSGoffs(pMsg, 0);
	MsgSetTAG(pMsg, (const uchar*)"rsyslogd:", sizeof("rsyslogd:")-1);
	msgSetPRI(pMsg, pri);
	MsgSetRuleset(pMsg, loadModConf-&gt;pBindRuleset);
	submitMsg2(pMsg);
finalize_it:
	RETiRet;
}
BEGINrunInput
CODESTARTrunInput
	while(1) {
		srSleep(MarkInterval, 0); 
		if(glbl.GetGlobalInputTermState() == 1)
			break; 
		dbgprintf("immark: injecting mark message\n");
		if(loadModConf-&gt;bUseSyslogAPI) {
			logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO,
				(uchar*)loadModConf-&gt;pszMarkMsgText, loadModConf-&gt;flags);
		} else {
			injectMarkMessage(LOG_SYSLOG|LOG_INFO);
		}
	}
ENDrunInput
BEGINwillRun
CODESTARTwillRun
ENDwillRun
BEGINmodExit
CODESTARTmodExit
	if(pInternalInputName != NULL)
		prop.Destruct(&amp;pInternalInputName);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
	return RS_RET_OK;
}
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(prop.Construct(&amp;pInternalInputName));
	CHKiRet(prop.SetString(pInternalInputName, UCHAR_CONSTANT("immark"), sizeof("immark") - 1));
	CHKiRet(prop.ConstructFinalize(pInternalInputName));
	CHKiRet(regCfSysLineHdlr2((uchar *)"markmessageperiod", 0, eCmdHdlrInt, NULL,
		&amp;iMarkMessagePeriod, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
