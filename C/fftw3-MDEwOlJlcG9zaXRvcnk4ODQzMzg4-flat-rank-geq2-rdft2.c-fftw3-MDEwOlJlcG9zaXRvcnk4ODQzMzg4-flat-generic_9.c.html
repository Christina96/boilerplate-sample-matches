
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 29.292929292929294%, Tokens: 8, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2-rdft2.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  #include "dft/dft.h"
3  typedef struct {
4       solver super;
5       int spltrnk;
6       const int *buddies;
7       size_t nbuddies;
8  } S;
9  typedef struct {
10       plan_dft super;
11       plan *cldr, *cldc;
12       const S *solver;
13  } P;
14  static void apply_r2hc(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
15  {
16       const P *ego = (const P *) ego_;
17       {
18  	  plan_rdft2 *cldr = (plan_rdft2 *) ego->cldr;
19  	  cldr->apply((plan *) cldr, r0, r1, cr, ci);
20       }
21       {
22  	  plan_dft *cldc = (plan_dft *) ego->cldc;
23  	  cldc->apply((plan *) cldc, cr, ci, cr, ci);
24       }
25  }
26  static void apply_hc2r(const plan *ego_, R *r0, R *r1, R *cr, R *ci)
27  {
28       const P *ego = (const P *) ego_;
29       {
30  	  plan_dft *cldc = (plan_dft *) ego->cldc;
31  	  cldc->apply((plan *) cldc, ci, cr, ci, cr);
32       }
<span onclick='openModal()' class='match'>33       {
34  	  plan_rdft2 *cldr = (plan_rdft2 *) ego->cldr;
35  	  cldr->apply((plan *) cldr, r0, r1, cr, ci);
36       }
37  }
38  static void awake(plan *ego_, enum wakefulness wakefulness)
39  {
40       P *ego = (P *) ego_;
</span>41       X(plan_awake)(ego->cldr, wakefulness);
42       X(plan_awake)(ego->cldc, wakefulness);
43  }
44  static void destroy(plan *ego_)
45  {
46       P *ego = (P *) ego_;
47       X(plan_destroy_internal)(ego->cldr);
48       X(plan_destroy_internal)(ego->cldc);
49  }
50  static void print(const plan *ego_, printer *p)
51  {
52       const P *ego = (const P *) ego_;
53       const S *s = ego->solver;
54       p->print(p, "(rdft2-rank>=2/%d%(%p%)%(%p%))", 
55  	      s->spltrnk, ego->cldr, ego->cldc);
56  }
57  static int picksplit(const S *ego, const tensor *sz, int *rp)
58  {
59       A(sz->rnk > 1); &bsol;* cannot split rnk <= 1 */
60       if (!X(pickdim)(ego->spltrnk, ego->buddies, ego->nbuddies, sz, 1, rp))
61            return 0;
62       *rp += 1; &bsol;* convert from dim. index to rank */
63       if (*rp >= sz->rnk) &bsol;* split must reduce rank */
64            return 0;
65       return 1;
66  }
67  static int applicable0(const solver *ego_, const problem *p_, int *rp,
68  		       const planner *plnr)
69  {
70       const problem_rdft2 *p = (const problem_rdft2 *) p_;
71       const S *ego = (const S *)ego_;
72       return (1
73  	     && FINITE_RNK(p->sz->rnk) && FINITE_RNK(p->vecsz->rnk)
74  	     && (p->kind == R2HC || p->kind == HC2R)
75  	     && p->sz->rnk >= 2
76  	     && picksplit(ego, p->sz, rp)
77  	     && (0
78  		 || (p->r0 != p->cr && 
79  		     (p->kind == R2HC || !NO_DESTROY_INPUTP(plnr)))
80  		 || (p->r0 == p->cr))
81  	  );
82  }
83  static int applicable(const solver *ego_, const problem *p_, 
84  		      const planner *plnr, int *rp)
85  {
86       const S *ego = (const S *)ego_;
87       if (!applicable0(ego_, p_, rp, plnr)) return 0;
88       if (NO_RANK_SPLITSP(plnr) && (ego->spltrnk != ego->buddies[0]))
89            return 0;
90       if (NO_UGLYP(plnr)) {
91  	  const problem_rdft2 *p = (const problem_rdft2 *) p_;
92  	  if (p->vecsz->rnk > 0 &&
93  	      X(tensor_min_stride)(p->vecsz) 
94  	      > X(rdft2_tensor_max_index)(p->sz, p->kind))
95  	       return 0;
96       }
97       return 1;
98  }
99  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
100  {
101       const S *ego = (const S *) ego_;
102       const problem_rdft2 *p;
103       P *pln;
104       plan *cldr = 0, *cldc = 0;
105       tensor *sz1, *sz2, *vecszi, *sz2i;
106       int spltrnk;
107       inplace_kind k;
108       problem *cldp;
109       static const plan_adt padt = {
110  	  X(rdft2_solve), awake, print, destroy
111       };
112       if (!applicable(ego_, p_, plnr, &spltrnk))
113            return (plan *) 0;
114       p = (const problem_rdft2 *) p_;
115       X(tensor_split)(p->sz, &sz1, spltrnk, &sz2);
116       k = p->kind == R2HC ? INPLACE_OS : INPLACE_IS;
117       vecszi = X(tensor_copy_inplace)(p->vecsz, k);
118       sz2i = X(tensor_copy_inplace)(sz2, k);
119       sz2i->dims[sz2i->rnk - 1].n = sz2i->dims[sz2i->rnk - 1].n/2 + 1;
120       cldr = X(mkplan_d)(plnr, 
121  		       X(mkproblem_rdft2_d)(X(tensor_copy)(sz2),
122  					    X(tensor_append)(p->vecsz, sz1),
123  					    p->r0, p->r1,
124  					    p->cr, p->ci, p->kind));
125       if (!cldr) goto nada;
126       if (p->kind == R2HC)
127  	  cldp = X(mkproblem_dft_d)(X(tensor_copy_inplace)(sz1, k),
128  				    X(tensor_append)(vecszi, sz2i),
129  				    p->cr, p->ci, p->cr, p->ci);
130       else &bsol;* HC2R must swap re/im parts to get IDFT */
131  	  cldp = X(mkproblem_dft_d)(X(tensor_copy_inplace)(sz1, k),
132  				    X(tensor_append)(vecszi, sz2i),
133  				    p->ci, p->cr, p->ci, p->cr);
134       cldc = X(mkplan_d)(plnr, cldp);
135       if (!cldc) goto nada;
136       pln = MKPLAN_RDFT2(P, &padt, p->kind == R2HC ? apply_r2hc : apply_hc2r);
137       pln->cldr = cldr;
138       pln->cldc = cldc;
139       pln->solver = ego;
140       X(ops_add)(&cldr->ops, &cldc->ops, &pln->super.super.ops);
141       X(tensor_destroy4)(sz2i, vecszi, sz2, sz1);
142       return &(pln->super.super);
143   nada:
144       X(plan_destroy_internal)(cldr);
145       X(plan_destroy_internal)(cldc);
146       X(tensor_destroy4)(sz2i, vecszi, sz2, sz1);
147       return (plan *) 0;
148  }
149  static solver *mksolver(int spltrnk, const int *buddies, size_t nbuddies)
150  {
151       static const solver_adt sadt = { PROBLEM_RDFT2, mkplan, 0 };
152       S *slv = MKSOLVER(S, &sadt);
153       slv->spltrnk = spltrnk;
154       slv->buddies = buddies;
155       slv->nbuddies = nbuddies;
156       return &(slv->super);
157  }
158  void X(rdft2_rank_geq2_register)(planner *p)
159  {
160       static const int buddies[] = { 1, 0, -2 };
161       size_t i;
162       for (i = 0; i < NELEM(buddies); ++i)
163            REGISTER_SOLVER(p, mksolver(buddies[i], buddies, NELEM(buddies)));
164  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-generic_9.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4       rdft_kind kind;
5  } S;
6  typedef struct {
7       plan_rdft super;
8       twid *td;
9       INT n, is, os;
10       rdft_kind kind;
11  } P;
12  static void cdot_r2hc(INT n, const E *x, const R *w, R *or0, R *oi1)
13  {
14       INT i;
15       E rr = x[0], ri = 0;
16       x += 1;
17       for (i = 1; i + i < n; ++i) {
18  	  rr += x[0] * w[0];
19  	  ri += x[1] * w[1];
20  	  x += 2; w += 2;
21       }
22       *or0 = rr;
23       *oi1 = ri;
24  }
25  static void hartley_r2hc(INT n, const R *xr, INT xs, E *o, R *pr)
26  {
27       INT i;
28       E sr;
29       o[0] = sr = xr[0]; o += 1;
30       for (i = 1; i + i < n; ++i) {
31  	  R a, b;
32  	  a = xr[i * xs];
33  	  b =  xr[(n - i) * xs];
34  	  sr += (o[0] = a + b);
35  #if FFT_SIGN == -1
36  	  o[1] = b - a;
37  #else
38  	  o[1] = a - b;
39  #endif
40  	  o += 2;
41       }
42       *pr = sr;
43  }
44  static void apply_r2hc(const plan *ego_, R *I, R *O)
45  {
46       const P *ego = (const P *) ego_;
47       INT i;
48       INT n = ego->n, is = ego->is, os = ego->os;
49       const R *W = ego->td->W;
50       E *buf;
51       size_t bufsz = n * sizeof(E);
52       BUF_ALLOC(E *, buf, bufsz);
53       hartley_r2hc(n, I, is, buf, O);
54       for (i = 1; i + i < n; ++i) {
55  	  cdot_r2hc(n, buf, W, O + i * os, O + (n - i) * os);
56  	  W += n - 1;
57       }
58       BUF_FREE(buf, bufsz);
59  }
60  static void cdot_hc2r(INT n, const E *x, const R *w, R *or0, R *or1)
61  {
62       INT i;
63       E rr = x[0], ii = 0; 
64       x += 1;
65       for (i = 1; i + i < n; ++i) {
66  	  rr += x[0] * w[0];
67  	  ii += x[1] * w[1];
68  	  x += 2; w += 2;
69       }
70  #if FFT_SIGN == -1
71       *or0 = rr - ii;
72       *or1 = rr + ii;
73  #else
74       *or0 = rr + ii;
75       *or1 = rr - ii;
76  #endif
77  }
78  static void hartley_hc2r(INT n, const R *x, INT xs, E *o, R *pr)
79  {
80       INT i;
81       E sr;
82       o[0] = sr = x[0]; o += 1;
83       for (i = 1; i + i < n; ++i) {
84  	  sr += (o[0] = x[i * xs] + x[i * xs]);
85  	  o[1] = x[(n - i) * xs] + x[(n - i) * xs];
86  	  o += 2;
87       }
88       *pr = sr;
89  }
90  static void apply_hc2r(const plan *ego_, R *I, R *O)		    
91  {
92       const P *ego = (const P *) ego_;
93       INT i;
94       INT n = ego->n, is = ego->is, os = ego->os;
95       const R *W = ego->td->W;
96       E *buf;
97       size_t bufsz = n * sizeof(E);
98       BUF_ALLOC(E *, buf, bufsz);
99       hartley_hc2r(n, I, is, buf, O);
<span onclick='openModal()' class='match'>100       for (i = 1; i + i < n; ++i) {
101  	  cdot_hc2r(n, buf, W, O + i * os, O + (n - i) * os);
102  	  W += n - 1;
103       }
104       BUF_FREE(buf, bufsz);
105  }
106  static void awake(plan *ego_, enum wakefulness wakefulness)
107  {
108       P *ego = (P *) ego_;
</span>109       static const tw_instr half_tw[] = {
110  	  { TW_HALF, 1, 0 },
111  	  { TW_NEXT, 1, 0 }
112       };
113       X(twiddle_awake)(wakefulness, &ego->td, half_tw, ego->n, ego->n,
114  		      (ego->n - 1) / 2);
115  }
116  static void print(const plan *ego_, printer *p)
117  {
118       const P *ego = (const P *) ego_;
119       p->print(p, "(rdft-generic-%s-%D)", 
120  	      ego->kind == R2HC ? "r2hc" : "hc2r", 
121  	      ego->n);
122  }
123  static int applicable(const S *ego, const problem *p_, 
124  		      const planner *plnr)
125  {
126       const problem_rdft *p = (const problem_rdft *) p_;
127       return (1
128  	     && p->sz->rnk == 1
129  	     && p->vecsz->rnk == 0
130  	     && (p->sz->dims[0].n % 2) == 1 
131  	     && CIMPLIES(NO_LARGE_GENERICP(plnr), p->sz->dims[0].n < GENERIC_MIN_BAD)
132  	     && CIMPLIES(NO_SLOWP(plnr), p->sz->dims[0].n > GENERIC_MAX_SLOW)
133  	     && X(is_prime)(p->sz->dims[0].n)
134  	     && p->kind[0] == ego->kind
135  	  );
136  }
137  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
138  {
139       const S *ego = (const S *)ego_;
140       const problem_rdft *p;
141       P *pln;
142       INT n;
143       static const plan_adt padt = {
144  	  X(rdft_solve), awake, print, X(plan_null_destroy)
145       };
146       if (!applicable(ego, p_, plnr))
147            return (plan *)0;
148       p = (const problem_rdft *) p_;
149       pln = MKPLAN_RDFT(P, &padt, 
150  		       R2HC_KINDP(p->kind[0]) ? apply_r2hc : apply_hc2r);
151       pln->n = n = p->sz->dims[0].n;
152       pln->is = p->sz->dims[0].is;
153       pln->os = p->sz->dims[0].os;
154       pln->td = 0;
155       pln->kind = ego->kind;
156       pln->super.super.ops.add = (n-1) * 2.5;
157       pln->super.super.ops.mul = 0;
158       pln->super.super.ops.fma = 0.5 * (n-1) * (n-1) ;
159  #if 0 &bsol;* these are nice pipelined sequential loads and should cost nothing */
160       pln->super.super.ops.other = (n-1)*(2 + 1 + (n-1));  &bsol;* approximate */
161  #endif
162       return &(pln->super.super);
163  }
164  static solver *mksolver(rdft_kind kind)
165  {
166       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
167       S *slv = MKSOLVER(S, &sadt);
168       slv->kind = kind;
169       return &(slv->super);
170  }
171  void X(rdft_generic_register)(planner *p)
172  {
173       REGISTER_SOLVER(p, mksolver(R2HC));
174       REGISTER_SOLVER(p, mksolver(HC2R));
175  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-rank-geq2-rdft2.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-generic_9.c</div>
                </div>
                <div class="column column_space"><pre><code>33       {
34  	  plan_rdft2 *cldr = (plan_rdft2 *) ego->cldr;
35  	  cldr->apply((plan *) cldr, r0, r1, cr, ci);
36       }
37  }
38  static void awake(plan *ego_, enum wakefulness wakefulness)
39  {
40       P *ego = (P *) ego_;
</pre></code></div>
                <div class="column column_space"><pre><code>100       for (i = 1; i + i < n; ++i) {
101  	  cdot_hc2r(n, buf, W, O + i * os, O + (n - i) * os);
102  	  W += n - 1;
103       }
104       BUF_FREE(buf, bufsz);
105  }
106  static void awake(plan *ego_, enum wakefulness wakefulness)
107  {
108       P *ego = (P *) ego_;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    