<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omhttp.c &amp; immark.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omhttp.c &amp; immark.c
      </h3>
<h1 align="center">
        3.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omhttp.c (1.9906323%)<th>immark.c (18.994413%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(216-228)<td><a href="#" name="0">(79-92)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1831-1835)<td><a href="#" name="1">(171-175)</a><td align="center"><font color="#b20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;curl/easy.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#if defined(__FreeBSD__)
#include &lt;unistd.h&gt;
#endif
#include &lt;json.h&gt;
#include &lt;zlib.h&gt;
#include "conf.h"
#include "syslogd-types.h"
#include "srUtils.h"
#include "template.h"
#include "module-template.h"
#include "errmsg.h"
#include "cfsysline.h"
#include "unicode-helper.h"
#include "obj-types.h"
#include "ratelimit.h"
#include "ruleset.h"
#include "statsobj.h"
#ifndef O_LARGEFILE
#  define O_LARGEFILE 0
#endif
MODULE_TYPE_OUTPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("omhttp")
DEF_OMOD_STATIC_DATA
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(statsobj)
statsobj_t *httpStats;
STATSCOUNTER_DEF(ctrMessagesSubmitted, mutCtrMessagesSubmitted); STATSCOUNTER_DEF(ctrMessagesSuccess, mutCtrMessagesSuccess); STATSCOUNTER_DEF(ctrMessagesFail, mutCtrMessagesFail); STATSCOUNTER_DEF(ctrMessagesRetry, mutCtrMessagesRetry); STATSCOUNTER_DEF(ctrHttpRequestCount, mutCtrHttpRequestCount); STATSCOUNTER_DEF(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess); STATSCOUNTER_DEF(ctrHttpRequestFail, mutCtrHttpRequestFail); STATSCOUNTER_DEF(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess); STATSCOUNTER_DEF(ctrHttpStatusFail, mutCtrHttpStatusFail); 
static prop_t *pInputName = NULL;
#define WRKR_DATA_TYPE_ES 0xBADF0001
#define HTTP_HEADER_CONTENT_JSON "Content-Type: application/json; charset=utf-8"
#define HTTP_HEADER_CONTENT_TEXT "Content-Type: text/plain"
#define HTTP_HEADER_CONTENT_KAFKA "Content-Type: application/vnd.kafka.v1+json"
#define HTTP_HEADER_ENCODING_GZIP "Content-Encoding: gzip"
#define HTTP_HEADER_EXPECT_EMPTY "Expect:"
#define VALID_BATCH_FORMATS "newline jsonarray kafkarest lokirest"
typedef enum batchFormat_e {
	FMT_NEWLINE,
	FMT_JSONARRAY,
	FMT_KAFKAREST,
	FMT_LOKIREST
} batchFormat_t;
typedef struct curl_slist HEADER;
typedef struct instanceConf_s {
	int defaultPort;
	int fdErrFile;			pthread_mutex_t mutErrFile;
	uchar **serverBaseUrls;
	int numServers;
	long healthCheckTimeout;
	uchar *uid;
	uchar *pwd;
	uchar *authBuf;
	uchar *httpcontenttype;
	uchar *headerContentTypeBuf;
	uchar *httpheaderkey;
	uchar *httpheadervalue;
	uchar *headerBuf;
	uchar **httpHeaders;
	int nHttpHeaders;
	uchar *restPath;
	uchar *checkPath;
	uchar *tplName;
	uchar *errorFile;
	sbool batchMode;
	uchar *batchFormatName;
	batchFormat_t batchFormat;
	sbool bFreeBatchFormatName;
	sbool dynRestPath;
	size_t maxBatchBytes;
	size_t maxBatchSize;
	sbool compress;
	sbool useHttps;
	sbool allowUnsignedCerts;
	sbool skipVerifyHost;
	uchar *caCertFile;
	uchar *myCertFile;
	uchar *myPrivKeyFile;
	sbool reloadOnHup;
	sbool retryFailures;
	unsigned int ratelimitInterval;
	unsigned int ratelimitBurst;
	ratelimit_t *ratelimiter;
	uchar *retryRulesetName;
	ruleset_t *retryRuleset;
	struct instanceConf_s *next;
} instanceData;
struct modConfData_s {
	rsconf_t *pConf;			instanceConf_t *root, *tail;
};
static modConfData_t *loadModConf = NULL;	
typedef struct wrkrInstanceData {
	PTR_ASSERT_DEF
	instanceData *pData;
	int serverIndex;
	int replyLen;
	char *reply;
	long httpStatusCode;		CURL	*curlCheckConnHandle;		CURL	*curlPostHandle;		HEADER	*curlHeader;		uchar *restURL;			sbool bzInitDone;
	z_stream zstrm; 	struct {
		uchar **data;				uchar *restPath;			size_t sizeBytes;			size_t nmemb;		
	} batch;
	struct {
		uchar *buf;
		size_t curLen;
		size_t len;
	} compressCtx;
} wrkrInstanceData_t;
static struct cnfparamdescr actpdescr[] = {
	{ "server", eCmdHdlrArray, 0 },
	{ "serverport", eCmdHdlrInt, 0 },
	{ "healthchecktimeout", eCmdHdlrInt, 0 },
	{ "httpcontenttype", eCmdHdlrGetWord, 0 },
	{ "httpheaderkey", eCmdHdlrGetWord, 0 },
	{ "httpheadervalue", eCmdHdlrString, 0 },
	{ "httpheaders", eCmdHdlrArray, 0 },
	{ "uid", eCmdHdlrGetWord, 0 },
	{ "pwd", eCmdHdlrGetWord, 0 },
	{ "restpath", eCmdHdlrGetWord, 0 },
	{ "checkpath", eCmdHdlrGetWord, 0 },
	{ "dynrestpath", eCmdHdlrBinary, 0 },
	{ "batch", eCmdHdlrBinary, 0 },
	{ "batch.format", eCmdHdlrGetWord, 0 },
	{ "batch.maxbytes", eCmdHdlrSize, 0 },
	{ "batch.maxsize", eCmdHdlrSize, 0 },
	{ "compress", eCmdHdlrBinary, 0 },
	{ "compress.level", eCmdHdlrInt, 0 },
	{ "usehttps", eCmdHdlrBinary, 0 },
	{ "errorfile", eCmdHdlrGetWord, 0 },
	{ "template", eCmdHdlrGetWord, 0 },
	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
	{ "skipverifyhost", eCmdHdlrBinary, 0 },
<a name="0"></a>	{ "tls.cacert", eCmdHdlrString, 0 },
	{ "tls.mycert", eCmdHdlrString, 0 },
	{ "tls.myprivkey", eCmdHdlrString, 0 },
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "reloadonhup", eCmdHdlrBinary, 0 },
	{ "retry", eCmdHdlrBinary, 0 },
	{ "retry.ruleset", eCmdHdlrString, 0 },
	{ "ratelimit.interval", eCmdHdlrInt, 0 },
	{ "ratelimit.burst", eCmdHdlrInt, 0 },
};
static struct cnfparamblk actpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
	  actpdescr
	};
static rsRetVal curlSetup(wrkrInstanceData_t *pWrkrData);</b></font>
static void curlCleanup(wrkrInstanceData_t *pWrkrData);
static void curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData);
static void ATTR_NONNULL()
initCompressCtx(wrkrInstanceData_t *pWrkrData);
static void ATTR_NONNULL()
freeCompressCtx(wrkrInstanceData_t *pWrkrData);
static rsRetVal ATTR_NONNULL()
resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len);
static rsRetVal ATTR_NONNULL()
growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen);
static rsRetVal ATTR_NONNULL()
appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen);
BEGINcreateInstance
CODESTARTcreateInstance
	pData-&gt;fdErrFile = -1;
	pthread_mutex_init(&amp;pData-&gt;mutErrFile, NULL);
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
	pData-&gt;ratelimiter = NULL;
	pData-&gt;retryRulesetName = NULL;
	pData-&gt;retryRuleset = NULL;
ENDcreateInstance
BEGINcreateWrkrInstance
uchar **batchData;
CODESTARTcreateWrkrInstance
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	pWrkrData-&gt;curlHeader = NULL;
	pWrkrData-&gt;curlPostHandle = NULL;
	pWrkrData-&gt;curlCheckConnHandle = NULL;
	pWrkrData-&gt;serverIndex = 0;
	pWrkrData-&gt;httpStatusCode = 0;
	pWrkrData-&gt;restURL = NULL;
	pWrkrData-&gt;bzInitDone = 0;
	if(pData-&gt;batchMode) {
		pWrkrData-&gt;batch.nmemb = 0;
		pWrkrData-&gt;batch.sizeBytes = 0;
		batchData = (uchar **) malloc(pData-&gt;maxBatchSize * sizeof(uchar *));
		if (batchData == NULL) {
			LogError(0, RS_RET_OUT_OF_MEMORY,
				"omhttp: cannot allocate memory for batch queue turning off batch mode\n");
			pData-&gt;batchMode = 0; 		} else {
			pWrkrData-&gt;batch.data = batchData;
			pWrkrData-&gt;batch.restPath = NULL;
		}
	}
	initCompressCtx(pWrkrData);
	iRet = curlSetup(pWrkrData);
ENDcreateWrkrInstance
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURERepeatedMsgReduction)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINfreeInstance
	int i;
CODESTARTfreeInstance
	if(pData-&gt;fdErrFile != -1)
		close(pData-&gt;fdErrFile);
	pthread_mutex_destroy(&amp;pData-&gt;mutErrFile);
	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
		free(pData-&gt;serverBaseUrls[i]);
	free(pData-&gt;serverBaseUrls);
	free(pData-&gt;uid);
	free(pData-&gt;httpcontenttype);
	free(pData-&gt;headerContentTypeBuf);
	free(pData-&gt;httpheaderkey);
	free(pData-&gt;httpheadervalue);
	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i) {
		free((void*) pData-&gt;httpHeaders[i]);
	}
	free(pData-&gt;httpHeaders);
	pData-&gt;nHttpHeaders = 0;
	free(pData-&gt;pwd);
	free(pData-&gt;authBuf);
	free(pData-&gt;headerBuf);
	free(pData-&gt;restPath);
	free(pData-&gt;checkPath);
	free(pData-&gt;tplName);
	free(pData-&gt;errorFile);
	free(pData-&gt;caCertFile);
	free(pData-&gt;myCertFile);
	free(pData-&gt;myPrivKeyFile);
	free(pData-&gt;retryRulesetName);
	if (pData-&gt;ratelimiter != NULL)
		ratelimitDestruct(pData-&gt;ratelimiter);
	if (pData-&gt;bFreeBatchFormatName)
		free(pData-&gt;batchFormatName);
ENDfreeInstance
BEGINfreeWrkrInstance
CODESTARTfreeWrkrInstance
	curlCleanup(pWrkrData);
	free(pWrkrData-&gt;restURL);
	pWrkrData-&gt;restURL = NULL;
	free(pWrkrData-&gt;batch.data);
	pWrkrData-&gt;batch.data = NULL;
	if (pWrkrData-&gt;batch.restPath != NULL)  {
		free(pWrkrData-&gt;batch.restPath);
		pWrkrData-&gt;batch.restPath = NULL;
	}
	if (pWrkrData-&gt;bzInitDone)
		deflateEnd(&amp;pWrkrData-&gt;zstrm);
	freeCompressCtx(pWrkrData);
ENDfreeWrkrInstance
BEGINdbgPrintInstInfo
	int i;
CODESTARTdbgPrintInstInfo
	dbgprintf("omhttp\n");
	dbgprintf("\ttemplate='%s'\n", pData-&gt;tplName);
	dbgprintf("\tnumServers=%d\n", pData-&gt;numServers);
	dbgprintf("\thealthCheckTimeout=%lu\n", pData-&gt;healthCheckTimeout);
	dbgprintf("\tserverBaseUrls=");
	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
		dbgprintf("%c'%s'", i == 0 ? '[' : ' ', pData-&gt;serverBaseUrls[i]);
	dbgprintf("]\n");
	dbgprintf("\tdefaultPort=%d\n", pData-&gt;defaultPort);
	dbgprintf("\tuid='%s'\n", pData-&gt;uid == NULL ? (uchar*)"(not configured)" : pData-&gt;uid);
	dbgprintf("\thttpcontenttype='%s'\n", pData-&gt;httpcontenttype == NULL ?
		(uchar*)"(not configured)" : pData-&gt;httpcontenttype);
	dbgprintf("\thttpheaderkey='%s'\n", pData-&gt;httpheaderkey == NULL ?
		(uchar*)"(not configured)" : pData-&gt;httpheaderkey);
	dbgprintf("\thttpheadervalue='%s'\n", pData-&gt;httpheadervalue == NULL ?
		(uchar*)"(not configured)" : pData-&gt;httpheadervalue);
	dbgprintf("\thttpHeaders=[");
	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i)
		dbgprintf("\t%s\n",pData-&gt;httpHeaders[i]);
	dbgprintf("\t]\n");
	dbgprintf("\tpwd=(%sconfigured)\n", pData-&gt;pwd == NULL ? "not " : "");
	dbgprintf("\trest path='%s'\n", pData-&gt;restPath);
	dbgprintf("\tcheck path='%s'\n", pData-&gt;checkPath);
	dbgprintf("\tdynamic rest path=%d\n", pData-&gt;dynRestPath);
	dbgprintf("\tuse https=%d\n", pData-&gt;useHttps);
	dbgprintf("\tbatch=%d\n", pData-&gt;batchMode);
	dbgprintf("\tbatch.format='%s'\n", pData-&gt;batchFormatName);
	dbgprintf("\tbatch.maxbytes=%zu\n", pData-&gt;maxBatchBytes);
	dbgprintf("\tbatch.maxsize=%zu\n", pData-&gt;maxBatchSize);
	dbgprintf("\tcompress=%d\n", pData-&gt;compress);
	dbgprintf("\tcompress.level=%d\n", pData-&gt;compressionLevel);
	dbgprintf("\tallowUnsignedCerts=%d\n", pData-&gt;allowUnsignedCerts);
	dbgprintf("\tskipVerifyHost=%d\n", pData-&gt;skipVerifyHost);
	dbgprintf("\terrorfile='%s'\n", pData-&gt;errorFile == NULL ?
		(uchar*)"(not configured)" : pData-&gt;errorFile);
	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
	dbgprintf("\treloadonhup='%d'\n", pData-&gt;reloadOnHup);
	dbgprintf("\tretry='%d'\n", pData-&gt;retryFailures);
	dbgprintf("\tretry.ruleset='%s'\n", pData-&gt;retryRulesetName);
	dbgprintf("\tratelimit.interval='%u'\n", pData-&gt;ratelimitInterval);
	dbgprintf("\tratelimit.burst='%u'\n", pData-&gt;ratelimitBurst);
ENDdbgPrintInstInfo
static size_t
curlResult(void *ptr, size_t size, size_t nmemb, void *userdata)
{
	char *p = (char *)ptr;
	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) userdata;
	char *buf;
	size_t newlen;
	PTR_ASSERT_CHK(pWrkrData, WRKR_DATA_TYPE_ES);
	newlen = pWrkrData-&gt;replyLen + size*nmemb;
	if((buf = realloc(pWrkrData-&gt;reply, newlen + 1)) == NULL) {
		LogError(errno, RS_RET_ERR, "omhttp: realloc failed in curlResult");
		return 0; 	}
	memcpy(buf+pWrkrData-&gt;replyLen, p, size*nmemb);
	pWrkrData-&gt;replyLen = newlen;
	pWrkrData-&gt;reply = buf;
	return size*nmemb;
}
static rsRetVal
computeBaseUrl(const char*const serverParam,
	const int defaultPort,
	const sbool useHttps,
	uchar **baseUrl)
{
#	define SCHEME_HTTPS "https://"
#	define SCHEME_HTTP "http://"
	char portBuf[64];
	int r = 0;
	const char *host = serverParam;
	DEFiRet;
	assert(serverParam[strlen(serverParam)-1] != '/');
	es_str_t *urlBuf = es_newStr(256);
	if (urlBuf == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
		"omhttp: failed to allocate es_str urlBuf in computeBaseUrl");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if (strcasestr(serverParam, SCHEME_HTTP))
		host = serverParam + strlen(SCHEME_HTTP);
	else if (strcasestr(serverParam, SCHEME_HTTPS))
		host = serverParam + strlen(SCHEME_HTTPS);
	else
		r = useHttps ? es_addBuf(&amp;urlBuf, SCHEME_HTTPS, sizeof(SCHEME_HTTPS)-1) :
			es_addBuf(&amp;urlBuf, SCHEME_HTTP, sizeof(SCHEME_HTTP)-1);
	if (r == 0) r = es_addBuf(&amp;urlBuf, (char *)serverParam, strlen(serverParam));
	if (r == 0 &amp;&amp; !strchr(host, ':')) {
		snprintf(portBuf, sizeof(portBuf), ":%d", defaultPort);
		r = es_addBuf(&amp;urlBuf, portBuf, strlen(portBuf));
	}
	if (r == 0) r = es_addChar(&amp;urlBuf, '/');
	if (r == 0) *baseUrl = (uchar*) es_str2cstr(urlBuf, NULL);
	if (r != 0 || baseUrl == NULL) {
		LogError(0, RS_RET_ERR,
			"omhttp: error occurred computing baseUrl from server %s", serverParam);
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	if (urlBuf) {
		es_deleteStr(urlBuf);
	}
	RETiRet;
}
static inline void
incrementServerIndex(wrkrInstanceData_t *pWrkrData)
{
	pWrkrData-&gt;serverIndex = (pWrkrData-&gt;serverIndex + 1) % pWrkrData-&gt;pData-&gt;numServers;
}
static rsRetVal ATTR_NONNULL()
checkConn(wrkrInstanceData_t *const pWrkrData)
{
	CURL *curl;
	CURLcode res;
	es_str_t *urlBuf = NULL;
	char* healthUrl;
	char* serverUrl;
	char* checkPath;
	int i;
	int r;
	DEFiRet;
	if (pWrkrData-&gt;pData-&gt;checkPath == NULL) {
		DBGPRINTF("omhttp: checkConn no health check uri configured skipping it\n");
		FINALIZE;
	}
	pWrkrData-&gt;reply = NULL;
	pWrkrData-&gt;replyLen = 0;
	curl = pWrkrData-&gt;curlCheckConnHandle;
	urlBuf = es_newStr(256);
	if (urlBuf == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			"omhttp: unable to allocate buffer for health check uri.");
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	}
	for(i = 0; i &lt; pWrkrData-&gt;pData-&gt;numServers; ++i) {
		serverUrl = (char*) pWrkrData-&gt;pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
		checkPath = (char*) pWrkrData-&gt;pData-&gt;checkPath;
		es_emptyStr(urlBuf);
		r = es_addBuf(&amp;urlBuf, serverUrl, strlen(serverUrl));
		if(r == 0 &amp;&amp; checkPath != NULL)
			r = es_addBuf(&amp;urlBuf, checkPath, strlen(checkPath));
		if(r == 0)
			healthUrl = es_str2cstr(urlBuf, NULL);
		if(r != 0 || healthUrl == NULL) {
			LogError(0, RS_RET_OUT_OF_MEMORY,
				"omhttp: unable to allocate buffer for health check uri.");
			ABORT_FINALIZE(RS_RET_SUSPENDED);
		}
		curlCheckConnSetup(pWrkrData);
		curl_easy_setopt(curl, CURLOPT_URL, healthUrl);
		res = curl_easy_perform(curl);
		free(healthUrl);
		if (res == CURLE_OK) {
			DBGPRINTF("omhttp: checkConn %s completed with success "
				"on attempt %d\n", serverUrl, i);
			ABORT_FINALIZE(RS_RET_OK);
		}
		DBGPRINTF("omhttp: checkConn %s failed on attempt %d: %s\n",
			serverUrl, i, curl_easy_strerror(res));
		incrementServerIndex(pWrkrData);
	}
	LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
		"omhttp: checkConn failed after %d attempts.", i);
	ABORT_FINALIZE(RS_RET_SUSPENDED);
finalize_it:
	if(urlBuf != NULL)
		es_deleteStr(urlBuf);
	free(pWrkrData-&gt;reply);
	pWrkrData-&gt;reply = NULL; 	RETiRet;
}
BEGINtryResume
CODESTARTtryResume
	DBGPRINTF("omhttp: tryResume called\n");
	iRet = checkConn(pWrkrData);
ENDtryResume
static void ATTR_NONNULL(1)
getRestPath(const instanceData *const pData, uchar **const tpls,
		      uchar **const restPath)
{
	*restPath = pData-&gt;restPath;
	if(tpls == NULL) {
		goto done;
	}
	int iNumTpls = 1;
	if(pData-&gt;dynRestPath) {
		*restPath = tpls[iNumTpls];
		++iNumTpls;
	}
done:
	assert(restPath != NULL);
	return;
}
static rsRetVal ATTR_NONNULL(1)
setPostURL(wrkrInstanceData_t *const pWrkrData, uchar **const tpls)
{
	uchar *restPath;
	char* baseUrl;
	es_str_t *url;
	int r;
	DEFiRet;
	instanceData *const pData = pWrkrData-&gt;pData;
	baseUrl = (char*)pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
	url = es_newStrFromCStr(baseUrl, strlen(baseUrl));
	if (url == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			"omhttp: error allocating new estr for POST url.");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if (pWrkrData-&gt;batch.restPath != NULL) {
		restPath = pWrkrData-&gt;batch.restPath;
	} else {
		getRestPath(pData, tpls, &amp;restPath);
	}
	r = 0;
	if (restPath != NULL)
		r = es_addBuf(&amp;url, (char*)restPath, ustrlen(restPath));
	if(r != 0) {
		LogError(0, RS_RET_ERR, "omhttp: failure in creating restURL, "
				"error code: %d", r);
		ABORT_FINALIZE(RS_RET_ERR);
	}
	if(pWrkrData-&gt;restURL != NULL)
		free(pWrkrData-&gt;restURL);
	pWrkrData-&gt;restURL = (uchar*)es_str2cstr(url, NULL);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_URL, pWrkrData-&gt;restURL);
	DBGPRINTF("omhttp: using REST URL: '%s'\n", pWrkrData-&gt;restURL);
finalize_it:
	if (url != NULL)
		es_deleteStr(url);
	RETiRet;
}
static rsRetVal
renderJsonErrorMessage(wrkrInstanceData_t *pWrkrData, uchar *reqmsg, char **rendered)
{
	DEFiRet;
	fjson_object *req = NULL;
	fjson_object *res = NULL;
	fjson_object *errRoot = NULL;
	if ((req = fjson_object_new_object()) == NULL)
		ABORT_FINALIZE(RS_RET_ERR);
	fjson_object_object_add(req, "url", fjson_object_new_string((char *)pWrkrData-&gt;restURL));
	fjson_object_object_add(req, "postdata", fjson_object_new_string((char *)reqmsg));
	if ((res = fjson_object_new_object()) == NULL) {
		fjson_object_put(req); 		ABORT_FINALIZE(RS_RET_ERR);
	}
	#define ERR_MSG_NULL "NULL: curl request failed or no response"
	fjson_object_object_add(res, "status", fjson_object_new_int(pWrkrData-&gt;httpStatusCode));
	if (pWrkrData-&gt;reply == NULL) {
		fjson_object_object_add(res, "message",
			fjson_object_new_string_len(ERR_MSG_NULL, strlen(ERR_MSG_NULL)));
	} else {
		fjson_object_object_add(res, "message",
			fjson_object_new_string_len(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen));
	}
	if ((errRoot = fjson_object_new_object()) == NULL) {
		fjson_object_put(req); 		fjson_object_put(res); 		ABORT_FINALIZE(RS_RET_ERR);
	}
	fjson_object_object_add(errRoot, "request", req);
	fjson_object_object_add(errRoot, "response", res);
	*rendered = strdup((char *) fjson_object_to_json_string(errRoot));
finalize_it:
	if (errRoot != NULL)
		fjson_object_put(errRoot);
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
writeDataError(wrkrInstanceData_t *const pWrkrData,
	instanceData *const pData, uchar *const reqmsg)
{
	char *rendered = NULL;
	size_t toWrite;
	ssize_t wrRet;
	sbool bMutLocked = 0;
	DEFiRet;
	if(pData-&gt;errorFile == NULL) {
		DBGPRINTF("omhttp: no local error logger defined - "
			"ignoring REST error information\n");
		FINALIZE;
	}
	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
	bMutLocked = 1;
	CHKiRet(renderJsonErrorMessage(pWrkrData, reqmsg, &amp;rendered));
	if(pData-&gt;fdErrFile == -1) {
		pData-&gt;fdErrFile = open((char*)pData-&gt;errorFile,
					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
		if(pData-&gt;fdErrFile == -1) {
			LogError(errno, RS_RET_ERR, "omhttp: error opening error file %s",
				pData-&gt;errorFile);
			ABORT_FINALIZE(RS_RET_ERR);
		}
	}
	DBGPRINTF("omhttp: error record: '%s'\n", rendered);
	toWrite = strlen(rendered) + 1;
	rendered[toWrite-1] = '\n'; 	wrRet = write(pData-&gt;fdErrFile, rendered, toWrite);
	if(wrRet != (ssize_t) toWrite) {
		LogError(errno, RS_RET_IO_ERROR,
			"omhttp: error writing error file %s, write returned %lld",
			pData-&gt;errorFile, (long long) wrRet);
	}
finalize_it:
	if(bMutLocked)
		pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
	free(rendered);
	RETiRet;
}
static rsRetVal
queueBatchOnRetryRuleset(wrkrInstanceData_t *const pWrkrData, instanceData *const pData)
{
	uchar *msgData;
	smsg_t *pMsg;
	DEFiRet;
	if (pData-&gt;retryRuleset == NULL) {
		LogError(0, RS_RET_ERR, "omhttp: queueBatchOnRetryRuleset invalid call with a NULL retryRuleset");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	for (size_t i = 0; i &lt; pWrkrData-&gt;batch.nmemb; i++) {
		msgData = pWrkrData-&gt;batch.data[i];
		DBGPRINTF("omhttp: queueBatchOnRetryRuleset putting message '%s' into retry ruleset '%s'\n",
			msgData, pData-&gt;retryRulesetName);
		CHKiRet(msgConstruct(&amp;pMsg));
		CHKiRet(MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY));
		MsgSetInputName(pMsg, pInputName);
		MsgSetRawMsg(pMsg, (const char *)msgData, ustrlen(msgData));
		MsgSetMSGoffs(pMsg, 0); 		MsgSetTAG(pMsg, (const uchar *)"omhttp-retry", 12);
		MsgSetRuleset(pMsg, pData-&gt;retryRuleset);
		ratelimitAddMsg(pData-&gt;ratelimiter, NULL, pMsg);
		STATSCOUNTER_INC(ctrMessagesRetry, mutCtrMessagesRetry);
	}
finalize_it:
	RETiRet;
}
static rsRetVal
checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
{
	instanceData *pData;
	long statusCode;
	size_t numMessages;
	DEFiRet;
	pData = pWrkrData-&gt;pData;
	statusCode = pWrkrData-&gt;httpStatusCode;
	if (pData-&gt;batchMode) {
		numMessages = pWrkrData-&gt;batch.nmemb;
	} else {
		numMessages = 1;
	}
	if (statusCode == 0) {
		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
		iRet = RS_RET_SUSPENDED;
	} else if (statusCode &gt;= 500) {
		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
		iRet = RS_RET_SUSPENDED;
	} else if (statusCode &gt;= 300) {
		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
		iRet = RS_RET_DATAFAIL;
	} else {
		STATSCOUNTER_INC(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
		STATSCOUNTER_ADD(ctrMessagesSuccess, mutCtrMessagesSuccess, numMessages);
		iRet = RS_RET_OK;
	}
	if (iRet != RS_RET_OK) {
		LogMsg(0, iRet, LOG_ERR, "omhttp: checkResult error http status code: %ld reply: %s",
			statusCode, pWrkrData-&gt;reply != NULL ? pWrkrData-&gt;reply : "NULL");
		writeDataError(pWrkrData, pWrkrData-&gt;pData, reqmsg);
		if (iRet == RS_RET_DATAFAIL)
			ABORT_FINALIZE(iRet);
		if (pData-&gt;batchMode &amp;&amp; pData-&gt;maxBatchSize &gt; 1) {
			if (pData-&gt;retryFailures &amp;&amp; pData-&gt;retryRuleset != NULL) {
				iRet = queueBatchOnRetryRuleset(pWrkrData, pData);
				if (iRet != RS_RET_OK) {
					LogMsg(0, iRet, LOG_ERR,
						"omhttp: checkResult error while queueing to retry ruleset"
						"some messages may be lost");
				}
			}
			iRet = RS_RET_OK; 		}
	}
finalize_it:
	RETiRet;
}
static rsRetVal
compressHttpPayload(wrkrInstanceData_t *pWrkrData, uchar *message, unsigned len)
{
	int zRet;
	unsigned outavail;
	uchar zipBuf[32*1024];
	DEFiRet;
	if (!pWrkrData-&gt;bzInitDone) {
		pWrkrData-&gt;zstrm.zalloc = Z_NULL;
		pWrkrData-&gt;zstrm.zfree = Z_NULL;
		pWrkrData-&gt;zstrm.opaque = Z_NULL;
		zRet = deflateInit2(&amp;pWrkrData-&gt;zstrm, pWrkrData-&gt;pData-&gt;compressionLevel,
			Z_DEFLATED, 31, 8, Z_DEFAULT_STRATEGY);
		if (zRet != Z_OK) {
			DBGPRINTF("omhttp: compressHttpPayload error %d returned from zlib/deflateInit2()\n", zRet);
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		}
		pWrkrData-&gt;bzInitDone = 1;
	}
	CHKiRet(resetCompressCtx(pWrkrData, len));
	pWrkrData-&gt;zstrm.next_in = (Bytef*) message;
	pWrkrData-&gt;zstrm.avail_in = len;
	do {
		DBGPRINTF("omhttp: compressHttpPayload in deflate() loop, avail_in %d, total_in %ld\n",
				pWrkrData-&gt;zstrm.avail_in, pWrkrData-&gt;zstrm.total_in);
		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
		pWrkrData-&gt;zstrm.next_out = zipBuf;
		zRet = deflate(&amp;pWrkrData-&gt;zstrm, Z_NO_FLUSH);
		DBGPRINTF("omhttp: compressHttpPayload after deflate, ret %d, avail_out %d\n",
				zRet, pWrkrData-&gt;zstrm.avail_out);
		if (zRet != Z_OK)
			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
		if (outavail != 0)
			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));
	} while (pWrkrData-&gt;zstrm.avail_out == 0);
	pWrkrData-&gt;zstrm.avail_in = 0;
	do {
		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
		pWrkrData-&gt;zstrm.next_out = zipBuf;
		deflate(&amp;pWrkrData-&gt;zstrm, Z_FINISH); 		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
		if (outavail != 0)
			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));
	} while (pWrkrData-&gt;zstrm.avail_out == 0);
finalize_it:
	if (pWrkrData-&gt;bzInitDone)
		deflateEnd(&amp;pWrkrData-&gt;zstrm);
	pWrkrData-&gt;bzInitDone = 0;
	RETiRet;
}
static void ATTR_NONNULL()
initCompressCtx(wrkrInstanceData_t *pWrkrData)
{
	pWrkrData-&gt;compressCtx.buf = NULL;
	pWrkrData-&gt;compressCtx.curLen = 0;
	pWrkrData-&gt;compressCtx.len = 0;
}
static void ATTR_NONNULL()
freeCompressCtx(wrkrInstanceData_t *pWrkrData)
{
	if (pWrkrData-&gt;compressCtx.buf != NULL) {
		free(pWrkrData-&gt;compressCtx.buf);
		pWrkrData-&gt;compressCtx.buf = NULL;
	}
}
static rsRetVal ATTR_NONNULL()
resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len)
{
	DEFiRet;
	pWrkrData-&gt;compressCtx.curLen = 0;
	pWrkrData-&gt;compressCtx.len = len;
	CHKiRet(growCompressCtx(pWrkrData, len));
finalize_it:
	if (iRet != RS_RET_OK)
		freeCompressCtx(pWrkrData);
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen)
{
	DEFiRet;
	if (pWrkrData-&gt;compressCtx.buf == NULL) {
		CHKmalloc(pWrkrData-&gt;compressCtx.buf = (uchar *)malloc(sizeof(uchar)*newLen));
	} else {
		uchar *const newbuf = (uchar *)realloc(pWrkrData-&gt;compressCtx.buf, sizeof(uchar)*newLen);
		CHKmalloc(newbuf);
		pWrkrData-&gt;compressCtx.buf = newbuf;
	}
	pWrkrData-&gt;compressCtx.len = newLen;
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen)
{
	size_t newLen;
	DEFiRet;
	newLen = pWrkrData-&gt;compressCtx.curLen + srcLen;
	if (newLen &gt; pWrkrData-&gt;compressCtx.len)
		CHKiRet(growCompressCtx(pWrkrData, newLen));
	memcpy(pWrkrData-&gt;compressCtx.buf + pWrkrData-&gt;compressCtx.curLen,
		srcBuf, srcLen);
	pWrkrData-&gt;compressCtx.curLen = newLen;
finalize_it:
	if (iRet != RS_RET_OK)
		freeCompressCtx(pWrkrData);
	RETiRet;
}
static rsRetVal ATTR_NONNULL()
buildCurlHeaders(wrkrInstanceData_t *pWrkrData, sbool contentEncodeGzip)
{
	struct curl_slist *slist = NULL;
	DEFiRet;
	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
	} else {
		if (pWrkrData-&gt;pData-&gt;batchMode) {
			switch (pWrkrData-&gt;pData-&gt;batchFormat) {
				case FMT_JSONARRAY:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
					break;
				case FMT_KAFKAREST:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_KAFKA);
					break;
				case FMT_NEWLINE:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
					break;
				case FMT_LOKIREST:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
					break;
				default:
					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
			}
		} else {
			slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
		}
	}
	CHKmalloc(slist);
	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
		CHKmalloc(slist);
	}
	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
		CHKmalloc(slist);
	}
	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
	CHKmalloc(slist);
	if (contentEncodeGzip) {
		slist = curl_slist_append(slist, HTTP_HEADER_ENCODING_GZIP);
		CHKmalloc(slist);
	}
	if (pWrkrData-&gt;curlHeader != NULL)
		curl_slist_free_all(pWrkrData-&gt;curlHeader);
	pWrkrData-&gt;curlHeader = slist;
finalize_it:
	if (iRet != RS_RET_OK) {
		curl_slist_free_all(slist);
		LogError(0, iRet, "omhttp: error allocating curl header slist, using previous one");
	}
	RETiRet;
}
static rsRetVal ATTR_NONNULL(1, 2)
curlPost(wrkrInstanceData_t *pWrkrData, uchar *message, int msglen, uchar **tpls,
		const int nmsgs __attribute__((unused)))
{
	CURLcode curlCode;
	CURL *const curl = pWrkrData-&gt;curlPostHandle;
	char errbuf[CURL_ERROR_SIZE] = "";
	char *postData;
	int postLen;
	sbool compressed;
	DEFiRet;
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	if(pWrkrData-&gt;pData-&gt;numServers &gt; 1) {
		CHKiRet(checkConn(pWrkrData));
	}
	CHKiRet(setPostURL(pWrkrData, tpls));
	pWrkrData-&gt;reply = NULL;
	pWrkrData-&gt;replyLen = 0;
	pWrkrData-&gt;httpStatusCode = 0;
	postData = (char *)message;
	postLen = msglen;
	compressed = 0;
	if (pWrkrData-&gt;pData-&gt;compress) {
		iRet = compressHttpPayload(pWrkrData, message, msglen);
		if (iRet != RS_RET_OK) {
			LogError(0, iRet, "omhttp: curlPost error while compressing, will default to uncompressed");
		} else {
			postData = (char *)pWrkrData-&gt;compressCtx.buf;
			postLen = pWrkrData-&gt;compressCtx.curLen;
			compressed = 1;
			DBGPRINTF("omhttp: curlPost compressed %d to %d bytes\n", msglen, postLen);
		}
	}
	buildCurlHeaders(pWrkrData, compressed);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData);
	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, postLen);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
	curlCode = curl_easy_perform(curl);
	DBGPRINTF("omhttp: curlPost curl returned %lld\n", (long long) curlCode);
	STATSCOUNTER_INC(ctrHttpRequestCount, mutCtrHttpRequestCount);
	if (curlCode != CURLE_OK) {
		STATSCOUNTER_INC(ctrHttpRequestFail, mutCtrHttpRequestFail);
		LogError(0, RS_RET_SUSPENDED,
			"omhttp: suspending ourselves due to server failure %lld: %s",
			(long long) curlCode, errbuf);
		checkResult(pWrkrData, message);
		ABORT_FINALIZE(RS_RET_SUSPENDED);
	} else {
		STATSCOUNTER_INC(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
	}
	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;pWrkrData-&gt;httpStatusCode);
	if(pWrkrData-&gt;reply == NULL) {
		DBGPRINTF("omhttp: curlPost pWrkrData reply==NULL, replyLen = '%d'\n",
			pWrkrData-&gt;replyLen);
	} else {
		DBGPRINTF("omhttp: curlPost pWrkrData replyLen = '%d'\n", pWrkrData-&gt;replyLen);
		if(pWrkrData-&gt;replyLen &gt; 0) {
			pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0';
		}
		DBGPRINTF("omhttp: curlPost pWrkrData reply: '%s'\n", pWrkrData-&gt;reply);
	}
	CHKiRet(checkResult(pWrkrData, message));
finalize_it:
	incrementServerIndex(pWrkrData);
	if (pWrkrData-&gt;reply != NULL) {
		free(pWrkrData-&gt;reply);
		pWrkrData-&gt;reply = NULL; 	}
	RETiRet;
}
static rsRetVal
serializeBatchKafkaRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
{
	fjson_object *batchArray = NULL;
	fjson_object *recordObj = NULL;
	fjson_object *valueObj = NULL;
	fjson_object *msgObj = NULL;
	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchKafkaRest numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
	DEFiRet;
	batchArray = fjson_object_new_array();
	if (batchArray == NULL) {
		LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create array");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	for (size_t i = 0; i &lt; numMessages; i++) {
		valueObj = fjson_object_new_object();
		if (valueObj == NULL) {
			fjson_object_put(batchArray); 			LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create value object");
			ABORT_FINALIZE(RS_RET_ERR);
		}
		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
		if (msgObj == NULL) {
			LogError(0, NO_ERRCODE,
				"omhttp: serializeBatchKafkaRest failed to parse %s as json ignoring it",
				pWrkrData-&gt;batch.data[i]);
			continue;
		}
		fjson_object_object_add(valueObj, "value", msgObj);
		fjson_object_array_add(batchArray, valueObj);
	}
	recordObj = fjson_object_new_object();
	if (recordObj == NULL) {
		fjson_object_put(batchArray); 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create record object");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	fjson_object_object_add(recordObj, "records", batchArray);
	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
	*batchBuf = strndup(batchString, strlen(batchString));
finalize_it:
	if (recordObj != NULL) {
		fjson_object_put(recordObj);
		recordObj = NULL;
	}
	RETiRet;
}
static rsRetVal
serializeBatchLokiRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
{
	fjson_object *batchArray = NULL;
	fjson_object *recordObj = NULL;
	fjson_object *msgObj = NULL;
	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchLokiRest numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
	DEFiRet;
	batchArray = fjson_object_new_array();
	if (batchArray == NULL) {
		LogError(0, RS_RET_ERR, "omhttp: serializeBatchLokiRest failed to create array");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	for (size_t i = 0; i &lt; numMessages; i++) {
		DBGPRINTF("omhttp: serializeBatchLokiRest parsing message [%s]\n",(char *) pWrkrData-&gt;batch.data[i]);
		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
		if (msgObj == NULL) {
			LogError(0, NO_ERRCODE,
				"omhttp: serializeBatchLokiRest failed to parse %s as json ignoring it",
				pWrkrData-&gt;batch.data[i]);
			continue;
		}
		fjson_object_array_add(batchArray, msgObj);
	}
	recordObj = fjson_object_new_object();
	if (recordObj == NULL) {
		fjson_object_put(batchArray); 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchLokiRest failed to create record object");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	fjson_object_object_add(recordObj, "streams", batchArray);
	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
	*batchBuf = strndup(batchString, strlen(batchString));
finalize_it:
	if (recordObj != NULL) {
		fjson_object_put(recordObj);
		recordObj = NULL;
	}
	RETiRet;
}
static rsRetVal
serializeBatchJsonArray(wrkrInstanceData_t *pWrkrData, char **batchBuf)
{
	fjson_object *batchArray = NULL;
	fjson_object *msgObj = NULL;
	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchJsonArray numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
	DEFiRet;
	batchArray = fjson_object_new_array();
	if (batchArray == NULL) {
		LogError(0, RS_RET_ERR, "omhttp: serializeBatchJsonArray failed to create array");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	for (size_t i = 0; i &lt; numMessages; i++) {
		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
		if (msgObj == NULL) {
			LogError(0, NO_ERRCODE,
				"omhttp: serializeBatchJsonArray failed to parse %s as json, ignoring it",
				pWrkrData-&gt;batch.data[i]);
			continue;
		}
		fjson_object_array_add(batchArray, msgObj);
	}
	const char *batchString = fjson_object_to_json_string_ext(batchArray, FJSON_TO_STRING_PLAIN);
	*batchBuf = strndup(batchString, strlen(batchString));
finalize_it:
	if (batchArray != NULL) {
		fjson_object_put(batchArray);
		batchArray = NULL;
	}
	RETiRet;
}
static rsRetVal
serializeBatchNewline(wrkrInstanceData_t *pWrkrData, char **batchBuf)
{
	DEFiRet;
	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages; 	int r = 0;
	DBGPRINTF("omhttp: serializeBatchNewline numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
	es_str_t *batchString = es_newStr(1024);
	if (batchString == NULL)
		ABORT_FINALIZE(RS_RET_ERR);
	for (size_t i = 0; i &lt; numMessages; i++) {
		size_t nToCopy = ustrlen(pWrkrData-&gt;batch.data[i]);
		if (r == 0) r = es_addBuf(&amp;batchString, (char *)pWrkrData-&gt;batch.data[i], nToCopy);
		if (i == numMessages - 1) break;
		if (r == 0) r = es_addChar(&amp;batchString, '\n');
	}
	if (r == 0) *batchBuf = (char *) es_str2cstr(batchString, NULL);
	if (r != 0 || *batchBuf== NULL) {
		LogError(0, RS_RET_ERR, "omhttp: serializeBatchNewline failed to build batch string");
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	if (batchString != NULL)
		es_deleteStr(batchString);
	RETiRet;
}
static size_t
computeBatchSize(wrkrInstanceData_t *pWrkrData)
{
	size_t extraBytes = 0;
	size_t sizeBytes = pWrkrData-&gt;batch.sizeBytes;
	size_t numMessages = pWrkrData-&gt;batch.nmemb;
	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
		case FMT_JSONARRAY:
			extraBytes = numMessages &gt; 0 ? numMessages + 1 : 2;
			break;
		case FMT_KAFKAREST:
			extraBytes = (numMessages * 10) + 14;
			break;
		case FMT_NEWLINE:
			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
			break;
		case FMT_LOKIREST:
			extraBytes = (numMessages * 2) + 14;
			break;
		default:
			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
	}
	return sizeBytes + extraBytes + 1; }
static void ATTR_NONNULL()
initializeBatch(wrkrInstanceData_t *pWrkrData)
{
	pWrkrData-&gt;batch.sizeBytes = 0;
	pWrkrData-&gt;batch.nmemb = 0;
	if (pWrkrData-&gt;batch.restPath != NULL)  {
		free(pWrkrData-&gt;batch.restPath);
		pWrkrData-&gt;batch.restPath = NULL;
	}
}
static rsRetVal
buildBatch(wrkrInstanceData_t *pWrkrData, uchar *message)
{
	DEFiRet;
	if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
		LogError(0, RS_RET_ERR, "omhttp: buildBatch something has gone wrong,"
			"number of messages in batch is bigger than the max batch size, bailing");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	pWrkrData-&gt;batch.data[pWrkrData-&gt;batch.nmemb] = message;
	pWrkrData-&gt;batch.sizeBytes += strlen((char *)message);
	pWrkrData-&gt;batch.nmemb++;
finalize_it:
	RETiRet;
}
static rsRetVal
submitBatch(wrkrInstanceData_t *pWrkrData, uchar **tpls)
{
	DEFiRet;
	char *batchBuf = NULL;
	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
		case FMT_JSONARRAY:
			iRet = serializeBatchJsonArray(pWrkrData, &amp;batchBuf);
			break;
		case FMT_KAFKAREST:
			iRet = serializeBatchKafkaRest(pWrkrData, &amp;batchBuf);
			break;
		case FMT_LOKIREST:
			iRet = serializeBatchLokiRest(pWrkrData, &amp;batchBuf);
			break;
		case FMT_NEWLINE:
			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
			break;
		default:
			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
	}
	if (iRet != RS_RET_OK || batchBuf == NULL)
		ABORT_FINALIZE(iRet);
	DBGPRINTF("omhttp: submitBatch, batch: '%s' tpls: '%p'\n", batchBuf, tpls);
	CHKiRet(curlPost(pWrkrData, (uchar*) batchBuf, strlen(batchBuf),
		tpls, pWrkrData-&gt;batch.nmemb));
finalize_it:
	if (batchBuf != NULL)
		free(batchBuf);
	RETiRet;
}
BEGINbeginTransaction
CODESTARTbeginTransaction
	if(!pWrkrData-&gt;pData-&gt;batchMode) {
		FINALIZE;
	}
	initializeBatch(pWrkrData);
finalize_it:
ENDbeginTransaction
BEGINdoAction
size_t nBytes;
sbool submit;
CODESTARTdoAction
	instanceData *const pData = pWrkrData-&gt;pData;
	uchar *restPath = NULL;
	STATSCOUNTER_INC(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
	if (pWrkrData-&gt;pData-&gt;batchMode) {
		if(pData-&gt;dynRestPath) {
			getRestPath(pData, ppString, &amp;restPath);
			if (pWrkrData-&gt;batch.restPath == NULL) {
				pWrkrData-&gt;batch.restPath = (uchar*)strdup((char*)restPath);
			} else if (strcmp((char*)pWrkrData-&gt;batch.restPath, (char*)restPath) != 0) {
				CHKiRet(submitBatch(pWrkrData, NULL));
				initializeBatch(pWrkrData);
			}
		}
		if (pWrkrData-&gt;pData-&gt;maxBatchSize == 1) {
			initializeBatch(pWrkrData);
			CHKiRet(buildBatch(pWrkrData, ppString[0]));
			CHKiRet(submitBatch(pWrkrData, ppString));
			FINALIZE;
		}
		nBytes = ustrlen((char *)ppString[0]) - 1 ;
		submit = 0;
		if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
			submit = 1;
			DBGPRINTF("omhttp: maxbatchsize limit reached submitting batch of %zd elements.\n",
				pWrkrData-&gt;batch.nmemb);
		} else if (computeBatchSize(pWrkrData) + nBytes &gt; pWrkrData-&gt;pData-&gt;maxBatchBytes) {
			submit = 1;
			DBGPRINTF("omhttp: maxbytes limit reached submitting partial batch of %zd elements.\n",
				pWrkrData-&gt;batch.nmemb);
		}
		if (submit) {
			CHKiRet(submitBatch(pWrkrData, ppString));
			initializeBatch(pWrkrData);
		}
		CHKiRet(buildBatch(pWrkrData, ppString[0]));
		iRet = pWrkrData-&gt;batch.nmemb == 1 ? RS_RET_PREVIOUS_COMMITTED : RS_RET_DEFER_COMMIT;
	} else {
		CHKiRet(curlPost(pWrkrData, ppString[0], strlen((char*)ppString[0]), ppString, 1));
	}
finalize_it:
ENDdoAction
BEGINendTransaction
CODESTARTendTransaction
	if (pWrkrData-&gt;batch.nmemb &gt; 0) {
		CHKiRet(submitBatch(pWrkrData, NULL));
	} else {
		dbgprintf("omhttp: endTransaction, pWrkrData-&gt;batch.nmemb = 0, "
			"nothing to send. \n");
	}
finalize_it:
ENDendTransaction
static rsRetVal
computeAuthHeader(char* uid, char* pwd, uchar** authBuf)
{
	int r;
	DEFiRet;
	es_str_t* auth = es_newStr(1024);
	if (auth == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
			"omhttp: failed to allocate es_str auth for auth header construction");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	r = es_addBuf(&amp;auth, uid, strlen(uid));
	if(r == 0) r = es_addChar(&amp;auth, ':');
	if(r == 0 &amp;&amp; pwd != NULL) r = es_addBuf(&amp;auth, pwd, strlen(pwd));
	if(r == 0) *authBuf = (uchar*) es_str2cstr(auth, NULL);
	if (r != 0 || *authBuf == NULL) {
		LogError(0, RS_RET_ERR, "omhttp: failed to build auth header\n");
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	if (auth != NULL)
		es_deleteStr(auth);
	RETiRet;
}
static rsRetVal
computeApiHeader(char* key, char* value, uchar** headerBuf)
{
	int r;
	DEFiRet;
	es_str_t* header = es_newStr(10240);
	if (header == NULL) {
		LogError(0, RS_RET_OUT_OF_MEMORY,
		"omhttp: failed to allocate es_str auth for api header construction");
		ABORT_FINALIZE(RS_RET_ERR);
	}
	r = es_addBuf(&amp;header, key, strlen(key));
	if(r == 0) r = es_addChar(&amp;header, ':');
	if(r == 0) r = es_addChar(&amp;header, ' ');
	if(r == 0 &amp;&amp; value != NULL) r = es_addBuf(&amp;header, value, strlen(value));
	if(r == 0) *headerBuf = (uchar*) es_str2cstr(header, NULL);
	if (r != 0 || *headerBuf == NULL) {
		LogError(0, RS_RET_ERR, "omhttp: failed to build http header\n");
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	if (header != NULL)
		es_deleteStr(header);
	RETiRet;
}
static void ATTR_NONNULL()
curlSetupCommon(wrkrInstanceData_t *const pWrkrData, CURL *const handle)
{
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	curl_easy_setopt(handle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
	curl_easy_setopt(handle, CURLOPT_NOSIGNAL, TRUE);
	curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, curlResult);
	curl_easy_setopt(handle, CURLOPT_WRITEDATA, pWrkrData);
	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYPEER, FALSE);
	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYHOST, FALSE);
	if(pWrkrData-&gt;pData-&gt;authBuf != NULL) {
		curl_easy_setopt(handle, CURLOPT_USERPWD, pWrkrData-&gt;pData-&gt;authBuf);
		curl_easy_setopt(handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
	}
	if(pWrkrData-&gt;pData-&gt;caCertFile)
		curl_easy_setopt(handle, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
	if(pWrkrData-&gt;pData-&gt;myCertFile)
		curl_easy_setopt(handle, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
		curl_easy_setopt(handle, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
}
static void ATTR_NONNULL()
curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData)
{
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlCheckConnHandle);
	curl_easy_setopt(pWrkrData-&gt;curlCheckConnHandle,
		CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;healthCheckTimeout);
}
static void ATTR_NONNULL(1)
curlPostSetup(wrkrInstanceData_t *const pWrkrData)
{
	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlPostHandle);
	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_POST, 1);
	CURLcode cRet;
	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPALIVE, 1L);
	if (cRet != CURLE_OK)
		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPALIVE\n");
	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPIDLE, 120L);
	if (cRet != CURLE_OK)
		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPIDLE\n");
	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPINTVL, 60L);
	if (cRet != CURLE_OK)
		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPINTVL\n");
}
static rsRetVal ATTR_NONNULL()
curlSetup(wrkrInstanceData_t *const pWrkrData)
{
	struct curl_slist *slist = NULL;
	DEFiRet;
	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
	} else {
		slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
	}
	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
		CHKmalloc(slist);
	}
	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
		CHKmalloc(slist);
	}
	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
	pWrkrData-&gt;curlHeader = slist;
	CHKmalloc(pWrkrData-&gt;curlPostHandle = curl_easy_init());
	curlPostSetup(pWrkrData);
	CHKmalloc(pWrkrData-&gt;curlCheckConnHandle = curl_easy_init());
	curlCheckConnSetup(pWrkrData);
finalize_it:
	if(iRet != RS_RET_OK &amp;&amp; pWrkrData-&gt;curlPostHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
		pWrkrData-&gt;curlPostHandle = NULL;
	}
	RETiRet;
}
static void ATTR_NONNULL()
curlCleanup(wrkrInstanceData_t *const pWrkrData)
{
	if (pWrkrData-&gt;curlHeader != NULL) {
		curl_slist_free_all(pWrkrData-&gt;curlHeader);
		pWrkrData-&gt;curlHeader = NULL;
	}
	if (pWrkrData-&gt;curlCheckConnHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlCheckConnHandle);
		pWrkrData-&gt;curlCheckConnHandle = NULL;
	}
	if (pWrkrData-&gt;curlPostHandle != NULL) {
		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
		pWrkrData-&gt;curlPostHandle = NULL;
	}
}
static void ATTR_NONNULL()
setInstParamDefaults(instanceData *const pData)
{
	pData-&gt;serverBaseUrls = NULL;
	pData-&gt;defaultPort = 443;
	pData-&gt;healthCheckTimeout = 3500;
	pData-&gt;uid = NULL;
	pData-&gt;httpcontenttype = NULL;
	pData-&gt;headerContentTypeBuf = NULL;
	pData-&gt;httpheaderkey = NULL;
	pData-&gt;httpheadervalue = NULL;
	pData-&gt;httpHeaders = NULL;
	pData-&gt;nHttpHeaders = 0;
	pData-&gt;pwd = NULL;
	pData-&gt;authBuf = NULL;
	pData-&gt;restPath = NULL;
	pData-&gt;checkPath = NULL;
	pData-&gt;dynRestPath = 0;
	pData-&gt;batchMode = 0;
	pData-&gt;batchFormatName = (uchar *)"newline";
	pData-&gt;batchFormat = FMT_NEWLINE;
	pData-&gt;bFreeBatchFormatName = 0;
	pData-&gt;useHttps = 1;
	pData-&gt;maxBatchBytes = 10485760; //i.e. 10 MB Is the default max message size for AWS API Gateway
	pData-&gt;maxBatchSize = 100; 	pData-&gt;compress = 0; 	pData-&gt;compressionLevel = -1; 	pData-&gt;allowUnsignedCerts = 0;
	pData-&gt;skipVerifyHost = 0;
	pData-&gt;tplName = NULL;
	pData-&gt;errorFile = NULL;
	pData-&gt;caCertFile = NULL;
	pData-&gt;myCertFile = NULL;
	pData-&gt;myPrivKeyFile = NULL;
	pData-&gt;reloadOnHup= 0;
	pData-&gt;retryFailures = 0;
	pData-&gt;ratelimitBurst = 20000;
	pData-&gt;ratelimitInterval = 600;
	pData-&gt;ratelimiter = NULL;
	pData-&gt;retryRulesetName = NULL;
	pData-&gt;retryRuleset = NULL;
}
static rsRetVal
checkHeaderParam(char *const param)
{
	DEFiRet;
	char *val = strstr(param, ":");
	if(val == NULL) {
		LogError(0, RS_RET_PARAM_ERROR, "missing ':' delimiter in "
				"parameter '%s'", param);
		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
	}
finalize_it:
	RETiRet;
}
BEGINnewActInst
	struct cnfparamvals *pvals;
	char* serverParam = NULL;
	struct cnfarray* servers = NULL;
	int i;
	int iNumTpls;
	FILE *fp;
	char errStr[1024];
	char *batchFormatName;
	int compressionLevel = -1;
CODESTARTnewActInst
	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	CHKiRet(createInstance(&amp;pData));
	setInstParamDefaults(pData);
	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(actpblk.descr[i].name, "server")) {
			servers = pvals[i].val.d.ar;
		} else if(!strcmp(actpblk.descr[i].name, "errorfile")) {
			pData-&gt;errorFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "serverport")) {
<a name="1"></a>			pData-&gt;defaultPort = (int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "healthchecktimeout")) {
			pData-&gt;healthCheckTimeout = (long) pvals[i].val.d.n;
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
			pData-&gt;uid = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "httpcontenttype")) {
			pData-&gt;httpcontenttype = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "httpheaderkey")) {</b></font>
			pData-&gt;httpheaderkey = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "httpheadervalue")) {
			pData-&gt;httpheadervalue = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "httpheaders")) {
			pData-&gt;nHttpHeaders = pvals[i].val.d.ar-&gt;nmemb;
			CHKmalloc(pData-&gt;httpHeaders = malloc(sizeof(uchar *) * pvals[i].val.d.ar-&gt;nmemb ));
			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
				CHKiRet(checkHeaderParam(cstr));
				pData-&gt;httpHeaders[j] = (uchar *)cstr;
			}
		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "restpath")) {
			pData-&gt;restPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "checkpath")) {
			pData-&gt;checkPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "dynrestpath")) {
			pData-&gt;dynRestPath = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "batch")) {
			pData-&gt;batchMode = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "batch.format")) {
			batchFormatName = es_str2cstr(pvals[i].val.d.estr, NULL);
			if (strstr(VALID_BATCH_FORMATS, batchFormatName) != NULL) {
				pData-&gt;batchFormatName = (uchar *)batchFormatName;
				pData-&gt;bFreeBatchFormatName = 1;
				if (!strcmp(batchFormatName, "newline")) {
					pData-&gt;batchFormat = FMT_NEWLINE;
				} else if (!strcmp(batchFormatName, "jsonarray")) {
					pData-&gt;batchFormat = FMT_JSONARRAY;
				} else if (!strcmp(batchFormatName, "kafkarest")) {
					pData-&gt;batchFormat = FMT_KAFKAREST;
				} else if (!strcmp(batchFormatName, "lokirest")) {
					pData-&gt;batchFormat = FMT_LOKIREST;
				}
			} else {
				LogError(0, NO_ERRCODE, "error: 'batch.format' %s unknown defaulting to 'newline'",
					batchFormatName);
			}
		} else if(!strcmp(actpblk.descr[i].name, "batch.maxbytes")) {
			pData-&gt;maxBatchBytes = (size_t) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "batch.maxsize")) {
			pData-&gt;maxBatchSize = (size_t) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "compress")) {
			pData-&gt;compress = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "compress.level")) {
			compressionLevel = pvals[i].val.d.n;
			if (compressionLevel == -1 || (compressionLevel &gt;= 0 &amp;&amp; compressionLevel &lt; 10)) {
				pData-&gt;compressionLevel = compressionLevel;
			} else {
				LogError(0, NO_ERRCODE, "omhttp: invalid compress.level %d using default instead,"
					"valid levels are -1 and 0-9",
					compressionLevel);
			}
		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "usehttps")) {
			pData-&gt;useHttps = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "template")) {
			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;caCertFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
						"error: 'tls.cacert' file %s couldn't be accessed: %s\n",
						pData-&gt;caCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myCertFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
						pData-&gt;myCertFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
			if(fp == NULL) {
				rs_strerror_r(errno, errStr, sizeof(errStr));
				LogError(0, RS_RET_NO_FILE_ACCESS,
						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
						pData-&gt;myPrivKeyFile, errStr);
			} else {
				fclose(fp);
			}
		} else if(!strcmp(actpblk.descr[i].name, "reloadonhup")) {
			pData-&gt;reloadOnHup= pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "retry")) {
			pData-&gt;retryFailures = pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "retry.ruleset")) {
			pData-&gt;retryRulesetName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.burst")) {
			pData-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.interval")) {
			pData-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
		} else {
			LogError(0, RS_RET_INTERNAL_ERROR, "omhttp: program error, "
				"non-handled param '%s'", actpblk.descr[i].name);
		}
	}
	if(pData-&gt;pwd != NULL &amp;&amp; pData-&gt;uid == NULL) {
		LogError(0, RS_RET_UID_MISSING,
			"omhttp: password is provided, but no uid "
			"- action definition invalid");
		ABORT_FINALIZE(RS_RET_UID_MISSING);
	}
	if(pData-&gt;httpheaderkey != NULL &amp;&amp; pData-&gt;httpheadervalue == NULL) {
		LogError(0, RS_RET_UID_MISSING,
			"omhttp: http header key is provided, but no http header value "
			"- action definition invalid");
		ABORT_FINALIZE(RS_RET_UID_MISSING);
	}
	if(pData-&gt;dynRestPath &amp;&amp; pData-&gt;restPath == NULL) {
		LogError(0, RS_RET_CONFIG_ERROR,
			"omhttp: requested dynamic rest path, but no name for rest "
			"path template given - action definition invalid");
		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
	}
	if (pData-&gt;uid != NULL)
		CHKiRet(computeAuthHeader((char*) pData-&gt;uid, (char*) pData-&gt;pwd, &amp;pData-&gt;authBuf));
	if (pData-&gt;httpcontenttype != NULL)
		CHKiRet(computeApiHeader((char*) "Content-Type",
				(char*) pData-&gt;httpcontenttype, &amp;pData-&gt;headerContentTypeBuf));
	if (pData-&gt;httpheaderkey != NULL)
		CHKiRet(computeApiHeader((char*) pData-&gt;httpheaderkey,
				(char*) pData-&gt;httpheadervalue, &amp;pData-&gt;headerBuf));
	iNumTpls = 1;
	if(pData-&gt;dynRestPath) ++iNumTpls;
	DBGPRINTF("omhttp: requesting %d templates\n", iNumTpls);
	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
					    " StdJSONFmt" : (char*)pData-&gt;tplName),
		OMSR_NO_RQD_TPL_OPTS));
	iNumTpls = 1;
	if(pData-&gt;dynRestPath) {
		CHKiRet(OMSRsetEntry(*ppOMSR, iNumTpls, ustrdup(pData-&gt;restPath),
			OMSR_NO_RQD_TPL_OPTS));
		++iNumTpls;
	}
	if (servers != NULL) {
		pData-&gt;numServers = servers-&gt;nmemb;
		pData-&gt;serverBaseUrls = malloc(servers-&gt;nmemb * sizeof(uchar*));
		if (pData-&gt;serverBaseUrls == NULL) {
			LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
					"for http server configuration.");
			ABORT_FINALIZE(RS_RET_ERR);
		}
		for(i = 0 ; i &lt; servers-&gt;nmemb ; ++i) {
			serverParam = es_str2cstr(servers-&gt;arr[i], NULL);
			if (serverParam == NULL) {
				LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
					"for http server configuration.");
				ABORT_FINALIZE(RS_RET_ERR);
			}
			const size_t serverParamLastChar = strlen(serverParam)-1;
			if (serverParam[serverParamLastChar] == '/') {
				serverParam[serverParamLastChar] = '\0';
			}
			CHKiRet(computeBaseUrl(serverParam, pData-&gt;defaultPort, pData-&gt;useHttps,
				pData-&gt;serverBaseUrls + i));
			free(serverParam);
			serverParam = NULL;
		}
	} else {
		LogMsg(0, RS_RET_OK, LOG_WARNING,
			"omhttp: No servers specified, using localhost");
		pData-&gt;numServers = 1;
		pData-&gt;serverBaseUrls = malloc(sizeof(uchar*));
		if (pData-&gt;serverBaseUrls == NULL) {
			LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
					"for http server configuration.");
			ABORT_FINALIZE(RS_RET_ERR);
		}
		CHKiRet(computeBaseUrl("localhost", pData-&gt;defaultPort, pData-&gt;useHttps, pData-&gt;serverBaseUrls));
	}
	if (pData-&gt;retryFailures) {
		CHKiRet(ratelimitNew(&amp;pData-&gt;ratelimiter, "omhttp", NULL));
		ratelimitSetLinuxLike(pData-&gt;ratelimiter, pData-&gt;ratelimitInterval, pData-&gt;ratelimitBurst);
		ratelimitSetNoTimeCache(pData-&gt;ratelimiter);
	}
	if(loadModConf-&gt;tail == NULL) {
		loadModConf-&gt;tail = loadModConf-&gt;root = pData;
	} else {
		loadModConf-&gt;tail-&gt;next = pData;
		loadModConf-&gt;tail = pData;
	}
CODE_STD_FINALIZERnewActInst
	cnfparamvalsDestruct(pvals, &amp;actpblk);
	if (serverParam)
		free(serverParam);
ENDnewActInst
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;root = pModConf-&gt;tail = NULL;
ENDbeginCnfLoad
BEGINendCnfLoad
CODESTARTendCnfLoad
	loadModConf = NULL; ENDendCnfLoad
BEGINcheckCnf
	instanceConf_t *inst;
CODESTARTcheckCnf
	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
		ruleset_t *pRuleset;
		rsRetVal localRet;
		if (inst-&gt;retryRulesetName) {
			localRet = ruleset.GetRuleset(pModConf-&gt;pConf, &amp;pRuleset, inst-&gt;retryRulesetName);
			if(localRet == RS_RET_NOT_FOUND) {
				LogError(0, localRet, "omhttp: retry.ruleset '%s' not found - "
						"no retry ruleset will be used", inst-&gt;retryRulesetName);
			} else {
				inst-&gt;retryRuleset = pRuleset;
			}
		}
	}
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf
BEGINdoHUP
CODESTARTdoHUP
	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
	if (pData-&gt;fdErrFile != -1) {
		close(pData-&gt;fdErrFile);
		pData-&gt;fdErrFile = -1;
	}
	pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
ENDdoHUP
BEGINdoHUPWrkr
CODESTARTdoHUPWrkr
	if (pWrkrData-&gt;pData-&gt;reloadOnHup) {
		LogMsg(0, NO_ERRCODE, LOG_INFO, "omhttp: received HUP reloading curl handles");
		curlCleanup(pWrkrData);
		CHKiRet(curlSetup(pWrkrData));
	}
finalize_it:
ENDdoHUPWrkr
BEGINmodExit
CODESTARTmodExit
	if(pInputName != NULL)
		prop.Destruct(&amp;pInputName);
	curl_global_cleanup();
	objRelease(prop, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	statsobj.Destruct(&amp;httpStats);
ENDmodExit
NO_LEGACY_CONF_parseSelectorAct
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_OMOD_QUERIES
CODEqueryEtryPt_STD_OMOD8_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
CODEqueryEtryPt_doHUP
CODEqueryEtryPt_doHUPWrkr CODEqueryEtryPt_TXIF_OMOD_QUERIES CODEqueryEtryPt_STD_CONF2_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(statsobj.Construct(&amp;httpStats));
	CHKiRet(statsobj.SetName(httpStats, (uchar *)"omhttp"));
	CHKiRet(statsobj.SetOrigin(httpStats, (uchar*)"omhttp"));
	STATSCOUNTER_INIT(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.submitted",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSubmitted));
	STATSCOUNTER_INIT(ctrMessagesSuccess, mutCtrMessagesSuccess);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.success",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSuccess));
	STATSCOUNTER_INIT(ctrMessagesFail, mutCtrMessagesFail);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.fail",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesFail));
	STATSCOUNTER_INIT(ctrMessagesRetry, mutCtrMessagesRetry);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.retry",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesRetry));
	STATSCOUNTER_INIT(ctrHttpRequestCount, mutCtrHttpRequestCount);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.count",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestCount));
	STATSCOUNTER_INIT(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.success",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestSuccess));
	STATSCOUNTER_INIT(ctrHttpRequestFail, mutCtrHttpRequestFail);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.fail",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestFail));
	STATSCOUNTER_INIT(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.status.success",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusSuccess));
	STATSCOUNTER_INIT(ctrHttpStatusFail, mutCtrHttpStatusFail);
	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.status.fail",
			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusFail));
	CHKiRet(statsobj.ConstructFinalize(httpStats));
	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
		LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -http disabled");
		ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
	}
	CHKiRet(prop.Construct(&amp;pInputName));
	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("omhttp"), sizeof("omhttp") - 1));
	CHKiRet(prop.ConstructFinalize(pInputName));
ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>immark.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include "rsyslog.h"
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include "dirty.h"
#include "cfsysline.h"
#include "module-template.h"
#include "errmsg.h"
#include "msg.h"
#include "srUtils.h"
#include "glbl.h"
#include "unicode-helper.h"
#include "ruleset.h"
#include "prop.h"
MODULE_TYPE_INPUT
MODULE_TYPE_NOKEEP
MODULE_CNFNAME("immark")
#define DEFAULT_MARK_PERIOD (20 * 60)
DEF_IMOD_STATIC_DATA
DEFobjCurrIf(glbl)
DEFobjCurrIf(prop)
DEFobjCurrIf(ruleset)
static int iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
struct modConfData_s {
	rsconf_t *pConf;		const char *pszMarkMsgText;
	size_t lenMarkMsgText;
	uchar *pszBindRuleset;
	ruleset_t *pBindRuleset;
	int flags;
	int bUseMarkFlag;
	int bUseSyslogAPI;
	int iMarkMessagePeriod;
	sbool configSetViaV2Method;
};
<a name="0"></a>
static struct cnfparamdescr modpdescr[] = {
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "ruleset", eCmdHdlrString, 0 },
	{ "markmessagetext", eCmdHdlrString, 0 },
	{ "use.syslogcall", eCmdHdlrBinary, 0 },
	{ "use.markflag", eCmdHdlrBinary, 0 },
	{ "interval", eCmdHdlrInt, 0 }
};
static struct cnfparamblk modpblk =
	{ CNFPARAMBLK_VERSION,
	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
	  modpdescr
	};
static modConfData_t *loadModConf = NULL;static int bLegacyCnfModGlobalsPermitted;static prop_t *pInternalInputName = NULL;
BEGINisCompatibleWithFeature
CODESTARTisCompatibleWithFeature
	if(eFeat == sFEATURENonCancelInputTermination)
		iRet = RS_RET_OK;
ENDisCompatibleWithFeature
BEGINafterRun
CODESTARTafterRun
ENDafterRun
BEGINbeginCnfLoad
CODESTARTbeginCnfLoad
	loadModConf = pModConf;
	pModConf-&gt;pConf = pConf;
	pModConf-&gt;pszMarkMsgText = NULL;
	pModConf-&gt;iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
	pModConf-&gt;bUseSyslogAPI = 1;
	pModConf-&gt;bUseMarkFlag = 1;
	pModConf-&gt;pszBindRuleset = NULL;
	pModConf-&gt;pBindRuleset = NULL;
	loadModConf-&gt;configSetViaV2Method = 0;
	bLegacyCnfModGlobalsPermitted = 1;
ENDbeginCnfLoad
static rsRetVal
checkRuleset(modConfData_t *modConf)
{
	ruleset_t *pRuleset;
	rsRetVal localRet;
	DEFiRet;
	if(modConf-&gt;pszBindRuleset == NULL)
		FINALIZE;
	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
	if(localRet == RS_RET_NOT_FOUND) {
		LogError(0, NO_ERRCODE, "immark: ruleset '%s' not found - "
				"using default ruleset instead", modConf-&gt;pszBindRuleset);
	}
	CHKiRet(localRet);
	modConf-&gt;pBindRuleset = pRuleset;
finalize_it:
	RETiRet;
}
BEGINsetModCnf
	struct cnfparamvals *pvals = NULL;
	int i;
CODESTARTsetModCnf
	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
				"config parameters [module(...)]");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}
	if(Debug) {
		dbgprintf("module (global) param blk for immark:\n");
		cnfparamsPrint(&amp;modpblk, pvals);
	}
	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
		if(!pvals[i].bUsed)
			continue;
		if(!strcmp(modpblk.descr[i].name, "interval")) {
			loadModConf-&gt;iMarkMessagePeriod = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "use.syslogcall")) {
<a name="1"></a>			loadModConf-&gt;bUseSyslogAPI = (int) pvals[i].val.d.n;
		} else if(!strcmp(modpblk.descr[i].name, "use.markflag")) {
			loadModConf-&gt;bUseMarkFlag = (int) pvals[i].val.d.n;
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "ruleset")) {
			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
		} else if(!strcmp(modpblk.descr[i].name, "markmessagetext")) {
			loadModConf-&gt;pszMarkMsgText = es_str2cstr(pvals[i].val.d.estr, NULL);
		} else {</b></font>
			dbgprintf("immark: program error, non-handled "
			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
		}
	}
	bLegacyCnfModGlobalsPermitted = 0;
	loadModConf-&gt;configSetViaV2Method = 1;
finalize_it:
	if(pvals != NULL)
		cnfparamvalsDestruct(pvals, &amp;modpblk);
ENDsetModCnf
BEGINendCnfLoad
CODESTARTendCnfLoad
	if(!loadModConf-&gt;configSetViaV2Method) {
		pModConf-&gt;iMarkMessagePeriod = iMarkMessagePeriod;
	}
ENDendCnfLoad
BEGINcheckCnf
CODESTARTcheckCnf
	pModConf-&gt;flags = (pModConf-&gt;bUseMarkFlag) ? MARK : 0;
	if(pModConf-&gt;pszMarkMsgText == NULL) {
		pModConf-&gt;pszMarkMsgText = strdup("-- MARK --");
	}
	pModConf-&gt;lenMarkMsgText = strlen(pModConf-&gt;pszMarkMsgText);
	if(pModConf-&gt;pszBindRuleset != NULL) {
		checkRuleset(pModConf);
		if(pModConf-&gt;bUseSyslogAPI) {
			LogError(0, NO_ERRCODE, "immark: ruleset specified, but configured to log "
				"via syslog call - switching to rsyslog-internal logging");
			pModConf-&gt;bUseSyslogAPI = 0;
		}
	}
	if(pModConf-&gt;iMarkMessagePeriod == 0) {
		LogError(0, NO_ERRCODE, "immark: mark message period must not be 0, can not run");
		ABORT_FINALIZE(RS_RET_NO_RUN);		}
finalize_it:
ENDcheckCnf
BEGINactivateCnf
CODESTARTactivateCnf
	MarkInterval = pModConf-&gt;iMarkMessagePeriod;
	DBGPRINTF("immark set MarkInterval to %d\n", MarkInterval);
ENDactivateCnf
BEGINfreeCnf
CODESTARTfreeCnf
ENDfreeCnf
static rsRetVal
injectMarkMessage(const int pri)
{
	smsg_t *pMsg;
	DEFiRet;
	CHKiRet(msgConstruct(&amp;pMsg));
	pMsg-&gt;msgFlags  = loadModConf-&gt;flags;
	MsgSetInputName(pMsg, pInternalInputName);
	MsgSetRawMsg(pMsg, loadModConf-&gt;pszMarkMsgText,loadModConf-&gt;lenMarkMsgText);
	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
	MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
	MsgSetMSGoffs(pMsg, 0);
	MsgSetTAG(pMsg, (const uchar*)"rsyslogd:", sizeof("rsyslogd:")-1);
	msgSetPRI(pMsg, pri);
	MsgSetRuleset(pMsg, loadModConf-&gt;pBindRuleset);
	submitMsg2(pMsg);
finalize_it:
	RETiRet;
}
BEGINrunInput
CODESTARTrunInput
	while(1) {
		srSleep(MarkInterval, 0); 
		if(glbl.GetGlobalInputTermState() == 1)
			break; 
		dbgprintf("immark: injecting mark message\n");
		if(loadModConf-&gt;bUseSyslogAPI) {
			logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO,
				(uchar*)loadModConf-&gt;pszMarkMsgText, loadModConf-&gt;flags);
		} else {
			injectMarkMessage(LOG_SYSLOG|LOG_INFO);
		}
	}
ENDrunInput
BEGINwillRun
CODESTARTwillRun
ENDwillRun
BEGINmodExit
CODESTARTmodExit
	if(pInternalInputName != NULL)
		prop.Destruct(&amp;pInternalInputName);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_IMOD_QUERIES
CODEqueryEtryPt_STD_CONF2_QUERIES
CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
ENDqueryEtryPt
static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
{
	iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
	return RS_RET_OK;
}
BEGINmodInit()
CODESTARTmodInit
	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(prop.Construct(&amp;pInternalInputName));
	CHKiRet(prop.SetString(pInternalInputName, UCHAR_CONSTANT("immark"), sizeof("immark") - 1));
	CHKiRet(prop.ConstructFinalize(pInternalInputName));
	CHKiRet(regCfSysLineHdlr2((uchar *)"markmessageperiod", 0, eCmdHdlrInt, NULL,
		&amp;iMarkMessagePeriod, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
