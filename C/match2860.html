<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for omhttp.c &amp; immark.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for omhttp.c &amp; immark.c
      </h3>
<h1 align="center">
        3.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>omhttp.c (1.9906323%)<th>immark.c (18.994413%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(216-228)<td><a href="#" name="0">(79-92)</a><td align="center"><font color="#ff0000">20</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(1831-1835)<td><a href="#" name="1">(171-175)</a><td align="center"><font color="#b20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>omhttp.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdio.h&gt;
4 #include &lt;stdarg.h&gt;
5 #include &lt;stdlib.h&gt;
6 #include &lt;memory.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;curl/curl.h&gt;
9 #include &lt;curl/easy.h&gt;
10 #include &lt;assert.h&gt;
11 #include &lt;signal.h&gt;
12 #include &lt;errno.h&gt;
13 #include &lt;time.h&gt;
14 #include &lt;sys/types.h&gt;
15 #include &lt;sys/stat.h&gt;
16 #include &lt;fcntl.h&gt;
17 #if defined(__FreeBSD__)
18 #include &lt;unistd.h&gt;
19 #endif
20 #include &lt;json.h&gt;
21 #include &lt;zlib.h&gt;
22 #include "conf.h"
23 #include "syslogd-types.h"
24 #include "srUtils.h"
25 #include "template.h"
26 #include "module-template.h"
27 #include "errmsg.h"
28 #include "cfsysline.h"
29 #include "unicode-helper.h"
30 #include "obj-types.h"
31 #include "ratelimit.h"
32 #include "ruleset.h"
33 #include "statsobj.h"
34 #ifndef O_LARGEFILE
35 #  define O_LARGEFILE 0
36 #endif
37 MODULE_TYPE_OUTPUT
38 MODULE_TYPE_NOKEEP
39 MODULE_CNFNAME("omhttp")
40 DEF_OMOD_STATIC_DATA
41 DEFobjCurrIf(prop)
42 DEFobjCurrIf(ruleset)
43 DEFobjCurrIf(statsobj)
44 statsobj_t *httpStats;
45 STATSCOUNTER_DEF(ctrMessagesSubmitted, mutCtrMessagesSubmitted); STATSCOUNTER_DEF(ctrMessagesSuccess, mutCtrMessagesSuccess); STATSCOUNTER_DEF(ctrMessagesFail, mutCtrMessagesFail); STATSCOUNTER_DEF(ctrMessagesRetry, mutCtrMessagesRetry); STATSCOUNTER_DEF(ctrHttpRequestCount, mutCtrHttpRequestCount); STATSCOUNTER_DEF(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess); STATSCOUNTER_DEF(ctrHttpRequestFail, mutCtrHttpRequestFail); STATSCOUNTER_DEF(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess); STATSCOUNTER_DEF(ctrHttpStatusFail, mutCtrHttpStatusFail); 
46 static prop_t *pInputName = NULL;
47 #define WRKR_DATA_TYPE_ES 0xBADF0001
48 #define HTTP_HEADER_CONTENT_JSON "Content-Type: application/json; charset=utf-8"
49 #define HTTP_HEADER_CONTENT_TEXT "Content-Type: text/plain"
50 #define HTTP_HEADER_CONTENT_KAFKA "Content-Type: application/vnd.kafka.v1+json"
51 #define HTTP_HEADER_ENCODING_GZIP "Content-Encoding: gzip"
52 #define HTTP_HEADER_EXPECT_EMPTY "Expect:"
53 #define VALID_BATCH_FORMATS "newline jsonarray kafkarest lokirest"
54 typedef enum batchFormat_e {
55 	FMT_NEWLINE,
56 	FMT_JSONARRAY,
57 	FMT_KAFKAREST,
58 	FMT_LOKIREST
59 } batchFormat_t;
60 typedef struct curl_slist HEADER;
61 typedef struct instanceConf_s {
62 	int defaultPort;
63 	int fdErrFile;			pthread_mutex_t mutErrFile;
64 	uchar **serverBaseUrls;
65 	int numServers;
66 	long healthCheckTimeout;
67 	uchar *uid;
68 	uchar *pwd;
69 	uchar *authBuf;
70 	uchar *httpcontenttype;
71 	uchar *headerContentTypeBuf;
72 	uchar *httpheaderkey;
73 	uchar *httpheadervalue;
74 	uchar *headerBuf;
75 	uchar **httpHeaders;
76 	int nHttpHeaders;
77 	uchar *restPath;
78 	uchar *checkPath;
79 	uchar *tplName;
80 	uchar *errorFile;
81 	sbool batchMode;
82 	uchar *batchFormatName;
83 	batchFormat_t batchFormat;
84 	sbool bFreeBatchFormatName;
85 	sbool dynRestPath;
86 	size_t maxBatchBytes;
87 	size_t maxBatchSize;
88 	sbool compress;
89 	sbool useHttps;
90 	sbool allowUnsignedCerts;
91 	sbool skipVerifyHost;
92 	uchar *caCertFile;
93 	uchar *myCertFile;
94 	uchar *myPrivKeyFile;
95 	sbool reloadOnHup;
96 	sbool retryFailures;
97 	unsigned int ratelimitInterval;
98 	unsigned int ratelimitBurst;
99 	ratelimit_t *ratelimiter;
100 	uchar *retryRulesetName;
101 	ruleset_t *retryRuleset;
102 	struct instanceConf_s *next;
103 } instanceData;
104 struct modConfData_s {
105 	rsconf_t *pConf;			instanceConf_t *root, *tail;
106 };
107 static modConfData_t *loadModConf = NULL;	
108 typedef struct wrkrInstanceData {
109 	PTR_ASSERT_DEF
110 	instanceData *pData;
111 	int serverIndex;
112 	int replyLen;
113 	char *reply;
114 	long httpStatusCode;		CURL	*curlCheckConnHandle;		CURL	*curlPostHandle;		HEADER	*curlHeader;		uchar *restURL;			sbool bzInitDone;
115 	z_stream zstrm; 	struct {
116 		uchar **data;				uchar *restPath;			size_t sizeBytes;			size_t nmemb;		
117 	} batch;
118 	struct {
119 		uchar *buf;
120 		size_t curLen;
121 		size_t len;
122 	} compressCtx;
123 } wrkrInstanceData_t;
124 static struct cnfparamdescr actpdescr[] = {
125 	{ "server", eCmdHdlrArray, 0 },
126 	{ "serverport", eCmdHdlrInt, 0 },
127 	{ "healthchecktimeout", eCmdHdlrInt, 0 },
128 	{ "httpcontenttype", eCmdHdlrGetWord, 0 },
129 	{ "httpheaderkey", eCmdHdlrGetWord, 0 },
130 	{ "httpheadervalue", eCmdHdlrString, 0 },
131 	{ "httpheaders", eCmdHdlrArray, 0 },
132 	{ "uid", eCmdHdlrGetWord, 0 },
133 	{ "pwd", eCmdHdlrGetWord, 0 },
134 	{ "restpath", eCmdHdlrGetWord, 0 },
135 	{ "checkpath", eCmdHdlrGetWord, 0 },
136 	{ "dynrestpath", eCmdHdlrBinary, 0 },
137 	{ "batch", eCmdHdlrBinary, 0 },
138 	{ "batch.format", eCmdHdlrGetWord, 0 },
139 	{ "batch.maxbytes", eCmdHdlrSize, 0 },
140 	{ "batch.maxsize", eCmdHdlrSize, 0 },
141 	{ "compress", eCmdHdlrBinary, 0 },
142 	{ "compress.level", eCmdHdlrInt, 0 },
143 	{ "usehttps", eCmdHdlrBinary, 0 },
144 	{ "errorfile", eCmdHdlrGetWord, 0 },
145 	{ "template", eCmdHdlrGetWord, 0 },
146 	{ "allowunsignedcerts", eCmdHdlrBinary, 0 },
147 	{ "skipverifyhost", eCmdHdlrBinary, 0 },
148 <a name="0"></a>	{ "tls.cacert", eCmdHdlrString, 0 },
149 	{ "tls.mycert", eCmdHdlrString, 0 },
150 	{ "tls.myprivkey", eCmdHdlrString, 0 },
151 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	{ "reloadonhup", eCmdHdlrBinary, 0 },
152 	{ "retry", eCmdHdlrBinary, 0 },
153 	{ "retry.ruleset", eCmdHdlrString, 0 },
154 	{ "ratelimit.interval", eCmdHdlrInt, 0 },
155 	{ "ratelimit.burst", eCmdHdlrInt, 0 },
156 };
157 static struct cnfparamblk actpblk =
158 	{ CNFPARAMBLK_VERSION,
159 	  sizeof(actpdescr)/sizeof(struct cnfparamdescr),
160 	  actpdescr
161 	};
162 static rsRetVal curlSetup(wrkrInstanceData_t *pWrkrData);</b></font>
163 static void curlCleanup(wrkrInstanceData_t *pWrkrData);
164 static void curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData);
165 static void ATTR_NONNULL()
166 initCompressCtx(wrkrInstanceData_t *pWrkrData);
167 static void ATTR_NONNULL()
168 freeCompressCtx(wrkrInstanceData_t *pWrkrData);
169 static rsRetVal ATTR_NONNULL()
170 resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len);
171 static rsRetVal ATTR_NONNULL()
172 growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen);
173 static rsRetVal ATTR_NONNULL()
174 appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen);
175 BEGINcreateInstance
176 CODESTARTcreateInstance
177 	pData-&gt;fdErrFile = -1;
178 	pthread_mutex_init(&amp;pData-&gt;mutErrFile, NULL);
179 	pData-&gt;caCertFile = NULL;
180 	pData-&gt;myCertFile = NULL;
181 	pData-&gt;myPrivKeyFile = NULL;
182 	pData-&gt;ratelimiter = NULL;
183 	pData-&gt;retryRulesetName = NULL;
184 	pData-&gt;retryRuleset = NULL;
185 ENDcreateInstance
186 BEGINcreateWrkrInstance
187 uchar **batchData;
188 CODESTARTcreateWrkrInstance
189 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
190 	pWrkrData-&gt;curlHeader = NULL;
191 	pWrkrData-&gt;curlPostHandle = NULL;
192 	pWrkrData-&gt;curlCheckConnHandle = NULL;
193 	pWrkrData-&gt;serverIndex = 0;
194 	pWrkrData-&gt;httpStatusCode = 0;
195 	pWrkrData-&gt;restURL = NULL;
196 	pWrkrData-&gt;bzInitDone = 0;
197 	if(pData-&gt;batchMode) {
198 		pWrkrData-&gt;batch.nmemb = 0;
199 		pWrkrData-&gt;batch.sizeBytes = 0;
200 		batchData = (uchar **) malloc(pData-&gt;maxBatchSize * sizeof(uchar *));
201 		if (batchData == NULL) {
202 			LogError(0, RS_RET_OUT_OF_MEMORY,
203 				"omhttp: cannot allocate memory for batch queue turning off batch mode\n");
204 			pData-&gt;batchMode = 0; 		} else {
205 			pWrkrData-&gt;batch.data = batchData;
206 			pWrkrData-&gt;batch.restPath = NULL;
207 		}
208 	}
209 	initCompressCtx(pWrkrData);
210 	iRet = curlSetup(pWrkrData);
211 ENDcreateWrkrInstance
212 BEGINisCompatibleWithFeature
213 CODESTARTisCompatibleWithFeature
214 	if(eFeat == sFEATURERepeatedMsgReduction)
215 		iRet = RS_RET_OK;
216 ENDisCompatibleWithFeature
217 BEGINfreeInstance
218 	int i;
219 CODESTARTfreeInstance
220 	if(pData-&gt;fdErrFile != -1)
221 		close(pData-&gt;fdErrFile);
222 	pthread_mutex_destroy(&amp;pData-&gt;mutErrFile);
223 	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
224 		free(pData-&gt;serverBaseUrls[i]);
225 	free(pData-&gt;serverBaseUrls);
226 	free(pData-&gt;uid);
227 	free(pData-&gt;httpcontenttype);
228 	free(pData-&gt;headerContentTypeBuf);
229 	free(pData-&gt;httpheaderkey);
230 	free(pData-&gt;httpheadervalue);
231 	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i) {
232 		free((void*) pData-&gt;httpHeaders[i]);
233 	}
234 	free(pData-&gt;httpHeaders);
235 	pData-&gt;nHttpHeaders = 0;
236 	free(pData-&gt;pwd);
237 	free(pData-&gt;authBuf);
238 	free(pData-&gt;headerBuf);
239 	free(pData-&gt;restPath);
240 	free(pData-&gt;checkPath);
241 	free(pData-&gt;tplName);
242 	free(pData-&gt;errorFile);
243 	free(pData-&gt;caCertFile);
244 	free(pData-&gt;myCertFile);
245 	free(pData-&gt;myPrivKeyFile);
246 	free(pData-&gt;retryRulesetName);
247 	if (pData-&gt;ratelimiter != NULL)
248 		ratelimitDestruct(pData-&gt;ratelimiter);
249 	if (pData-&gt;bFreeBatchFormatName)
250 		free(pData-&gt;batchFormatName);
251 ENDfreeInstance
252 BEGINfreeWrkrInstance
253 CODESTARTfreeWrkrInstance
254 	curlCleanup(pWrkrData);
255 	free(pWrkrData-&gt;restURL);
256 	pWrkrData-&gt;restURL = NULL;
257 	free(pWrkrData-&gt;batch.data);
258 	pWrkrData-&gt;batch.data = NULL;
259 	if (pWrkrData-&gt;batch.restPath != NULL)  {
260 		free(pWrkrData-&gt;batch.restPath);
261 		pWrkrData-&gt;batch.restPath = NULL;
262 	}
263 	if (pWrkrData-&gt;bzInitDone)
264 		deflateEnd(&amp;pWrkrData-&gt;zstrm);
265 	freeCompressCtx(pWrkrData);
266 ENDfreeWrkrInstance
267 BEGINdbgPrintInstInfo
268 	int i;
269 CODESTARTdbgPrintInstInfo
270 	dbgprintf("omhttp\n");
271 	dbgprintf("\ttemplate='%s'\n", pData-&gt;tplName);
272 	dbgprintf("\tnumServers=%d\n", pData-&gt;numServers);
273 	dbgprintf("\thealthCheckTimeout=%lu\n", pData-&gt;healthCheckTimeout);
274 	dbgprintf("\tserverBaseUrls=");
275 	for(i = 0 ; i &lt; pData-&gt;numServers ; ++i)
276 		dbgprintf("%c'%s'", i == 0 ? '[' : ' ', pData-&gt;serverBaseUrls[i]);
277 	dbgprintf("]\n");
278 	dbgprintf("\tdefaultPort=%d\n", pData-&gt;defaultPort);
279 	dbgprintf("\tuid='%s'\n", pData-&gt;uid == NULL ? (uchar*)"(not configured)" : pData-&gt;uid);
280 	dbgprintf("\thttpcontenttype='%s'\n", pData-&gt;httpcontenttype == NULL ?
281 		(uchar*)"(not configured)" : pData-&gt;httpcontenttype);
282 	dbgprintf("\thttpheaderkey='%s'\n", pData-&gt;httpheaderkey == NULL ?
283 		(uchar*)"(not configured)" : pData-&gt;httpheaderkey);
284 	dbgprintf("\thttpheadervalue='%s'\n", pData-&gt;httpheadervalue == NULL ?
285 		(uchar*)"(not configured)" : pData-&gt;httpheadervalue);
286 	dbgprintf("\thttpHeaders=[");
287 	for(i = 0 ; i &lt; pData-&gt;nHttpHeaders ; ++i)
288 		dbgprintf("\t%s\n",pData-&gt;httpHeaders[i]);
289 	dbgprintf("\t]\n");
290 	dbgprintf("\tpwd=(%sconfigured)\n", pData-&gt;pwd == NULL ? "not " : "");
291 	dbgprintf("\trest path='%s'\n", pData-&gt;restPath);
292 	dbgprintf("\tcheck path='%s'\n", pData-&gt;checkPath);
293 	dbgprintf("\tdynamic rest path=%d\n", pData-&gt;dynRestPath);
294 	dbgprintf("\tuse https=%d\n", pData-&gt;useHttps);
295 	dbgprintf("\tbatch=%d\n", pData-&gt;batchMode);
296 	dbgprintf("\tbatch.format='%s'\n", pData-&gt;batchFormatName);
297 	dbgprintf("\tbatch.maxbytes=%zu\n", pData-&gt;maxBatchBytes);
298 	dbgprintf("\tbatch.maxsize=%zu\n", pData-&gt;maxBatchSize);
299 	dbgprintf("\tcompress=%d\n", pData-&gt;compress);
300 	dbgprintf("\tcompress.level=%d\n", pData-&gt;compressionLevel);
301 	dbgprintf("\tallowUnsignedCerts=%d\n", pData-&gt;allowUnsignedCerts);
302 	dbgprintf("\tskipVerifyHost=%d\n", pData-&gt;skipVerifyHost);
303 	dbgprintf("\terrorfile='%s'\n", pData-&gt;errorFile == NULL ?
304 		(uchar*)"(not configured)" : pData-&gt;errorFile);
305 	dbgprintf("\ttls.cacert='%s'\n", pData-&gt;caCertFile);
306 	dbgprintf("\ttls.mycert='%s'\n", pData-&gt;myCertFile);
307 	dbgprintf("\ttls.myprivkey='%s'\n", pData-&gt;myPrivKeyFile);
308 	dbgprintf("\treloadonhup='%d'\n", pData-&gt;reloadOnHup);
309 	dbgprintf("\tretry='%d'\n", pData-&gt;retryFailures);
310 	dbgprintf("\tretry.ruleset='%s'\n", pData-&gt;retryRulesetName);
311 	dbgprintf("\tratelimit.interval='%u'\n", pData-&gt;ratelimitInterval);
312 	dbgprintf("\tratelimit.burst='%u'\n", pData-&gt;ratelimitBurst);
313 ENDdbgPrintInstInfo
314 static size_t
315 curlResult(void *ptr, size_t size, size_t nmemb, void *userdata)
316 {
317 	char *p = (char *)ptr;
318 	wrkrInstanceData_t *pWrkrData = (wrkrInstanceData_t*) userdata;
319 	char *buf;
320 	size_t newlen;
321 	PTR_ASSERT_CHK(pWrkrData, WRKR_DATA_TYPE_ES);
322 	newlen = pWrkrData-&gt;replyLen + size*nmemb;
323 	if((buf = realloc(pWrkrData-&gt;reply, newlen + 1)) == NULL) {
324 		LogError(errno, RS_RET_ERR, "omhttp: realloc failed in curlResult");
325 		return 0; 	}
326 	memcpy(buf+pWrkrData-&gt;replyLen, p, size*nmemb);
327 	pWrkrData-&gt;replyLen = newlen;
328 	pWrkrData-&gt;reply = buf;
329 	return size*nmemb;
330 }
331 static rsRetVal
332 computeBaseUrl(const char*const serverParam,
333 	const int defaultPort,
334 	const sbool useHttps,
335 	uchar **baseUrl)
336 {
337 #	define SCHEME_HTTPS "https://"
338 #	define SCHEME_HTTP "http://"
339 	char portBuf[64];
340 	int r = 0;
341 	const char *host = serverParam;
342 	DEFiRet;
343 	assert(serverParam[strlen(serverParam)-1] != '/');
344 	es_str_t *urlBuf = es_newStr(256);
345 	if (urlBuf == NULL) {
346 		LogError(0, RS_RET_OUT_OF_MEMORY,
347 		"omhttp: failed to allocate es_str urlBuf in computeBaseUrl");
348 		ABORT_FINALIZE(RS_RET_ERR);
349 	}
350 	if (strcasestr(serverParam, SCHEME_HTTP))
351 		host = serverParam + strlen(SCHEME_HTTP);
352 	else if (strcasestr(serverParam, SCHEME_HTTPS))
353 		host = serverParam + strlen(SCHEME_HTTPS);
354 	else
355 		r = useHttps ? es_addBuf(&amp;urlBuf, SCHEME_HTTPS, sizeof(SCHEME_HTTPS)-1) :
356 			es_addBuf(&amp;urlBuf, SCHEME_HTTP, sizeof(SCHEME_HTTP)-1);
357 	if (r == 0) r = es_addBuf(&amp;urlBuf, (char *)serverParam, strlen(serverParam));
358 	if (r == 0 &amp;&amp; !strchr(host, ':')) {
359 		snprintf(portBuf, sizeof(portBuf), ":%d", defaultPort);
360 		r = es_addBuf(&amp;urlBuf, portBuf, strlen(portBuf));
361 	}
362 	if (r == 0) r = es_addChar(&amp;urlBuf, '/');
363 	if (r == 0) *baseUrl = (uchar*) es_str2cstr(urlBuf, NULL);
364 	if (r != 0 || baseUrl == NULL) {
365 		LogError(0, RS_RET_ERR,
366 			"omhttp: error occurred computing baseUrl from server %s", serverParam);
367 		ABORT_FINALIZE(RS_RET_ERR);
368 	}
369 finalize_it:
370 	if (urlBuf) {
371 		es_deleteStr(urlBuf);
372 	}
373 	RETiRet;
374 }
375 static inline void
376 incrementServerIndex(wrkrInstanceData_t *pWrkrData)
377 {
378 	pWrkrData-&gt;serverIndex = (pWrkrData-&gt;serverIndex + 1) % pWrkrData-&gt;pData-&gt;numServers;
379 }
380 static rsRetVal ATTR_NONNULL()
381 checkConn(wrkrInstanceData_t *const pWrkrData)
382 {
383 	CURL *curl;
384 	CURLcode res;
385 	es_str_t *urlBuf = NULL;
386 	char* healthUrl;
387 	char* serverUrl;
388 	char* checkPath;
389 	int i;
390 	int r;
391 	DEFiRet;
392 	if (pWrkrData-&gt;pData-&gt;checkPath == NULL) {
393 		DBGPRINTF("omhttp: checkConn no health check uri configured skipping it\n");
394 		FINALIZE;
395 	}
396 	pWrkrData-&gt;reply = NULL;
397 	pWrkrData-&gt;replyLen = 0;
398 	curl = pWrkrData-&gt;curlCheckConnHandle;
399 	urlBuf = es_newStr(256);
400 	if (urlBuf == NULL) {
401 		LogError(0, RS_RET_OUT_OF_MEMORY,
402 			"omhttp: unable to allocate buffer for health check uri.");
403 		ABORT_FINALIZE(RS_RET_SUSPENDED);
404 	}
405 	for(i = 0; i &lt; pWrkrData-&gt;pData-&gt;numServers; ++i) {
406 		serverUrl = (char*) pWrkrData-&gt;pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
407 		checkPath = (char*) pWrkrData-&gt;pData-&gt;checkPath;
408 		es_emptyStr(urlBuf);
409 		r = es_addBuf(&amp;urlBuf, serverUrl, strlen(serverUrl));
410 		if(r == 0 &amp;&amp; checkPath != NULL)
411 			r = es_addBuf(&amp;urlBuf, checkPath, strlen(checkPath));
412 		if(r == 0)
413 			healthUrl = es_str2cstr(urlBuf, NULL);
414 		if(r != 0 || healthUrl == NULL) {
415 			LogError(0, RS_RET_OUT_OF_MEMORY,
416 				"omhttp: unable to allocate buffer for health check uri.");
417 			ABORT_FINALIZE(RS_RET_SUSPENDED);
418 		}
419 		curlCheckConnSetup(pWrkrData);
420 		curl_easy_setopt(curl, CURLOPT_URL, healthUrl);
421 		res = curl_easy_perform(curl);
422 		free(healthUrl);
423 		if (res == CURLE_OK) {
424 			DBGPRINTF("omhttp: checkConn %s completed with success "
425 				"on attempt %d\n", serverUrl, i);
426 			ABORT_FINALIZE(RS_RET_OK);
427 		}
428 		DBGPRINTF("omhttp: checkConn %s failed on attempt %d: %s\n",
429 			serverUrl, i, curl_easy_strerror(res));
430 		incrementServerIndex(pWrkrData);
431 	}
432 	LogMsg(0, RS_RET_SUSPENDED, LOG_WARNING,
433 		"omhttp: checkConn failed after %d attempts.", i);
434 	ABORT_FINALIZE(RS_RET_SUSPENDED);
435 finalize_it:
436 	if(urlBuf != NULL)
437 		es_deleteStr(urlBuf);
438 	free(pWrkrData-&gt;reply);
439 	pWrkrData-&gt;reply = NULL; 	RETiRet;
440 }
441 BEGINtryResume
442 CODESTARTtryResume
443 	DBGPRINTF("omhttp: tryResume called\n");
444 	iRet = checkConn(pWrkrData);
445 ENDtryResume
446 static void ATTR_NONNULL(1)
447 getRestPath(const instanceData *const pData, uchar **const tpls,
448 		      uchar **const restPath)
449 {
450 	*restPath = pData-&gt;restPath;
451 	if(tpls == NULL) {
452 		goto done;
453 	}
454 	int iNumTpls = 1;
455 	if(pData-&gt;dynRestPath) {
456 		*restPath = tpls[iNumTpls];
457 		++iNumTpls;
458 	}
459 done:
460 	assert(restPath != NULL);
461 	return;
462 }
463 static rsRetVal ATTR_NONNULL(1)
464 setPostURL(wrkrInstanceData_t *const pWrkrData, uchar **const tpls)
465 {
466 	uchar *restPath;
467 	char* baseUrl;
468 	es_str_t *url;
469 	int r;
470 	DEFiRet;
471 	instanceData *const pData = pWrkrData-&gt;pData;
472 	baseUrl = (char*)pData-&gt;serverBaseUrls[pWrkrData-&gt;serverIndex];
473 	url = es_newStrFromCStr(baseUrl, strlen(baseUrl));
474 	if (url == NULL) {
475 		LogError(0, RS_RET_OUT_OF_MEMORY,
476 			"omhttp: error allocating new estr for POST url.");
477 		ABORT_FINALIZE(RS_RET_ERR);
478 	}
479 	if (pWrkrData-&gt;batch.restPath != NULL) {
480 		restPath = pWrkrData-&gt;batch.restPath;
481 	} else {
482 		getRestPath(pData, tpls, &amp;restPath);
483 	}
484 	r = 0;
485 	if (restPath != NULL)
486 		r = es_addBuf(&amp;url, (char*)restPath, ustrlen(restPath));
487 	if(r != 0) {
488 		LogError(0, RS_RET_ERR, "omhttp: failure in creating restURL, "
489 				"error code: %d", r);
490 		ABORT_FINALIZE(RS_RET_ERR);
491 	}
492 	if(pWrkrData-&gt;restURL != NULL)
493 		free(pWrkrData-&gt;restURL);
494 	pWrkrData-&gt;restURL = (uchar*)es_str2cstr(url, NULL);
495 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_URL, pWrkrData-&gt;restURL);
496 	DBGPRINTF("omhttp: using REST URL: '%s'\n", pWrkrData-&gt;restURL);
497 finalize_it:
498 	if (url != NULL)
499 		es_deleteStr(url);
500 	RETiRet;
501 }
502 static rsRetVal
503 renderJsonErrorMessage(wrkrInstanceData_t *pWrkrData, uchar *reqmsg, char **rendered)
504 {
505 	DEFiRet;
506 	fjson_object *req = NULL;
507 	fjson_object *res = NULL;
508 	fjson_object *errRoot = NULL;
509 	if ((req = fjson_object_new_object()) == NULL)
510 		ABORT_FINALIZE(RS_RET_ERR);
511 	fjson_object_object_add(req, "url", fjson_object_new_string((char *)pWrkrData-&gt;restURL));
512 	fjson_object_object_add(req, "postdata", fjson_object_new_string((char *)reqmsg));
513 	if ((res = fjson_object_new_object()) == NULL) {
514 		fjson_object_put(req); 		ABORT_FINALIZE(RS_RET_ERR);
515 	}
516 	#define ERR_MSG_NULL "NULL: curl request failed or no response"
517 	fjson_object_object_add(res, "status", fjson_object_new_int(pWrkrData-&gt;httpStatusCode));
518 	if (pWrkrData-&gt;reply == NULL) {
519 		fjson_object_object_add(res, "message",
520 			fjson_object_new_string_len(ERR_MSG_NULL, strlen(ERR_MSG_NULL)));
521 	} else {
522 		fjson_object_object_add(res, "message",
523 			fjson_object_new_string_len(pWrkrData-&gt;reply, pWrkrData-&gt;replyLen));
524 	}
525 	if ((errRoot = fjson_object_new_object()) == NULL) {
526 		fjson_object_put(req); 		fjson_object_put(res); 		ABORT_FINALIZE(RS_RET_ERR);
527 	}
528 	fjson_object_object_add(errRoot, "request", req);
529 	fjson_object_object_add(errRoot, "response", res);
530 	*rendered = strdup((char *) fjson_object_to_json_string(errRoot));
531 finalize_it:
532 	if (errRoot != NULL)
533 		fjson_object_put(errRoot);
534 	RETiRet;
535 }
536 static rsRetVal ATTR_NONNULL()
537 writeDataError(wrkrInstanceData_t *const pWrkrData,
538 	instanceData *const pData, uchar *const reqmsg)
539 {
540 	char *rendered = NULL;
541 	size_t toWrite;
542 	ssize_t wrRet;
543 	sbool bMutLocked = 0;
544 	DEFiRet;
545 	if(pData-&gt;errorFile == NULL) {
546 		DBGPRINTF("omhttp: no local error logger defined - "
547 			"ignoring REST error information\n");
548 		FINALIZE;
549 	}
550 	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
551 	bMutLocked = 1;
552 	CHKiRet(renderJsonErrorMessage(pWrkrData, reqmsg, &amp;rendered));
553 	if(pData-&gt;fdErrFile == -1) {
554 		pData-&gt;fdErrFile = open((char*)pData-&gt;errorFile,
555 					O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,
556 					S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
557 		if(pData-&gt;fdErrFile == -1) {
558 			LogError(errno, RS_RET_ERR, "omhttp: error opening error file %s",
559 				pData-&gt;errorFile);
560 			ABORT_FINALIZE(RS_RET_ERR);
561 		}
562 	}
563 	DBGPRINTF("omhttp: error record: '%s'\n", rendered);
564 	toWrite = strlen(rendered) + 1;
565 	rendered[toWrite-1] = '\n'; 	wrRet = write(pData-&gt;fdErrFile, rendered, toWrite);
566 	if(wrRet != (ssize_t) toWrite) {
567 		LogError(errno, RS_RET_IO_ERROR,
568 			"omhttp: error writing error file %s, write returned %lld",
569 			pData-&gt;errorFile, (long long) wrRet);
570 	}
571 finalize_it:
572 	if(bMutLocked)
573 		pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
574 	free(rendered);
575 	RETiRet;
576 }
577 static rsRetVal
578 queueBatchOnRetryRuleset(wrkrInstanceData_t *const pWrkrData, instanceData *const pData)
579 {
580 	uchar *msgData;
581 	smsg_t *pMsg;
582 	DEFiRet;
583 	if (pData-&gt;retryRuleset == NULL) {
584 		LogError(0, RS_RET_ERR, "omhttp: queueBatchOnRetryRuleset invalid call with a NULL retryRuleset");
585 		ABORT_FINALIZE(RS_RET_ERR);
586 	}
587 	for (size_t i = 0; i &lt; pWrkrData-&gt;batch.nmemb; i++) {
588 		msgData = pWrkrData-&gt;batch.data[i];
589 		DBGPRINTF("omhttp: queueBatchOnRetryRuleset putting message '%s' into retry ruleset '%s'\n",
590 			msgData, pData-&gt;retryRulesetName);
591 		CHKiRet(msgConstruct(&amp;pMsg));
592 		CHKiRet(MsgSetFlowControlType(pMsg, eFLOWCTL_FULL_DELAY));
593 		MsgSetInputName(pMsg, pInputName);
594 		MsgSetRawMsg(pMsg, (const char *)msgData, ustrlen(msgData));
595 		MsgSetMSGoffs(pMsg, 0); 		MsgSetTAG(pMsg, (const uchar *)"omhttp-retry", 12);
596 		MsgSetRuleset(pMsg, pData-&gt;retryRuleset);
597 		ratelimitAddMsg(pData-&gt;ratelimiter, NULL, pMsg);
598 		STATSCOUNTER_INC(ctrMessagesRetry, mutCtrMessagesRetry);
599 	}
600 finalize_it:
601 	RETiRet;
602 }
603 static rsRetVal
604 checkResult(wrkrInstanceData_t *pWrkrData, uchar *reqmsg)
605 {
606 	instanceData *pData;
607 	long statusCode;
608 	size_t numMessages;
609 	DEFiRet;
610 	pData = pWrkrData-&gt;pData;
611 	statusCode = pWrkrData-&gt;httpStatusCode;
612 	if (pData-&gt;batchMode) {
613 		numMessages = pWrkrData-&gt;batch.nmemb;
614 	} else {
615 		numMessages = 1;
616 	}
617 	if (statusCode == 0) {
618 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
619 		iRet = RS_RET_SUSPENDED;
620 	} else if (statusCode &gt;= 500) {
621 		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
622 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
623 		iRet = RS_RET_SUSPENDED;
624 	} else if (statusCode &gt;= 300) {
625 		STATSCOUNTER_INC(ctrHttpStatusFail, mutCtrHttpStatusFail);
626 		STATSCOUNTER_ADD(ctrMessagesFail, mutCtrMessagesFail, numMessages);
627 		iRet = RS_RET_DATAFAIL;
628 	} else {
629 		STATSCOUNTER_INC(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
630 		STATSCOUNTER_ADD(ctrMessagesSuccess, mutCtrMessagesSuccess, numMessages);
631 		iRet = RS_RET_OK;
632 	}
633 	if (iRet != RS_RET_OK) {
634 		LogMsg(0, iRet, LOG_ERR, "omhttp: checkResult error http status code: %ld reply: %s",
635 			statusCode, pWrkrData-&gt;reply != NULL ? pWrkrData-&gt;reply : "NULL");
636 		writeDataError(pWrkrData, pWrkrData-&gt;pData, reqmsg);
637 		if (iRet == RS_RET_DATAFAIL)
638 			ABORT_FINALIZE(iRet);
639 		if (pData-&gt;batchMode &amp;&amp; pData-&gt;maxBatchSize &gt; 1) {
640 			if (pData-&gt;retryFailures &amp;&amp; pData-&gt;retryRuleset != NULL) {
641 				iRet = queueBatchOnRetryRuleset(pWrkrData, pData);
642 				if (iRet != RS_RET_OK) {
643 					LogMsg(0, iRet, LOG_ERR,
644 						"omhttp: checkResult error while queueing to retry ruleset"
645 						"some messages may be lost");
646 				}
647 			}
648 			iRet = RS_RET_OK; 		}
649 	}
650 finalize_it:
651 	RETiRet;
652 }
653 static rsRetVal
654 compressHttpPayload(wrkrInstanceData_t *pWrkrData, uchar *message, unsigned len)
655 {
656 	int zRet;
657 	unsigned outavail;
658 	uchar zipBuf[32*1024];
659 	DEFiRet;
660 	if (!pWrkrData-&gt;bzInitDone) {
661 		pWrkrData-&gt;zstrm.zalloc = Z_NULL;
662 		pWrkrData-&gt;zstrm.zfree = Z_NULL;
663 		pWrkrData-&gt;zstrm.opaque = Z_NULL;
664 		zRet = deflateInit2(&amp;pWrkrData-&gt;zstrm, pWrkrData-&gt;pData-&gt;compressionLevel,
665 			Z_DEFLATED, 31, 8, Z_DEFAULT_STRATEGY);
666 		if (zRet != Z_OK) {
667 			DBGPRINTF("omhttp: compressHttpPayload error %d returned from zlib/deflateInit2()\n", zRet);
668 			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
669 		}
670 		pWrkrData-&gt;bzInitDone = 1;
671 	}
672 	CHKiRet(resetCompressCtx(pWrkrData, len));
673 	pWrkrData-&gt;zstrm.next_in = (Bytef*) message;
674 	pWrkrData-&gt;zstrm.avail_in = len;
675 	do {
676 		DBGPRINTF("omhttp: compressHttpPayload in deflate() loop, avail_in %d, total_in %ld\n",
677 				pWrkrData-&gt;zstrm.avail_in, pWrkrData-&gt;zstrm.total_in);
678 		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
679 		pWrkrData-&gt;zstrm.next_out = zipBuf;
680 		zRet = deflate(&amp;pWrkrData-&gt;zstrm, Z_NO_FLUSH);
681 		DBGPRINTF("omhttp: compressHttpPayload after deflate, ret %d, avail_out %d\n",
682 				zRet, pWrkrData-&gt;zstrm.avail_out);
683 		if (zRet != Z_OK)
684 			ABORT_FINALIZE(RS_RET_ZLIB_ERR);
685 		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
686 		if (outavail != 0)
687 			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));
688 	} while (pWrkrData-&gt;zstrm.avail_out == 0);
689 	pWrkrData-&gt;zstrm.avail_in = 0;
690 	do {
691 		pWrkrData-&gt;zstrm.avail_out = sizeof(zipBuf);
692 		pWrkrData-&gt;zstrm.next_out = zipBuf;
693 		deflate(&amp;pWrkrData-&gt;zstrm, Z_FINISH); 		outavail = sizeof(zipBuf) - pWrkrData-&gt;zstrm.avail_out;
694 		if (outavail != 0)
695 			CHKiRet(appendCompressCtx(pWrkrData, zipBuf, outavail));
696 	} while (pWrkrData-&gt;zstrm.avail_out == 0);
697 finalize_it:
698 	if (pWrkrData-&gt;bzInitDone)
699 		deflateEnd(&amp;pWrkrData-&gt;zstrm);
700 	pWrkrData-&gt;bzInitDone = 0;
701 	RETiRet;
702 }
703 static void ATTR_NONNULL()
704 initCompressCtx(wrkrInstanceData_t *pWrkrData)
705 {
706 	pWrkrData-&gt;compressCtx.buf = NULL;
707 	pWrkrData-&gt;compressCtx.curLen = 0;
708 	pWrkrData-&gt;compressCtx.len = 0;
709 }
710 static void ATTR_NONNULL()
711 freeCompressCtx(wrkrInstanceData_t *pWrkrData)
712 {
713 	if (pWrkrData-&gt;compressCtx.buf != NULL) {
714 		free(pWrkrData-&gt;compressCtx.buf);
715 		pWrkrData-&gt;compressCtx.buf = NULL;
716 	}
717 }
718 static rsRetVal ATTR_NONNULL()
719 resetCompressCtx(wrkrInstanceData_t *pWrkrData, size_t len)
720 {
721 	DEFiRet;
722 	pWrkrData-&gt;compressCtx.curLen = 0;
723 	pWrkrData-&gt;compressCtx.len = len;
724 	CHKiRet(growCompressCtx(pWrkrData, len));
725 finalize_it:
726 	if (iRet != RS_RET_OK)
727 		freeCompressCtx(pWrkrData);
728 	RETiRet;
729 }
730 static rsRetVal ATTR_NONNULL()
731 growCompressCtx(wrkrInstanceData_t *pWrkrData, size_t newLen)
732 {
733 	DEFiRet;
734 	if (pWrkrData-&gt;compressCtx.buf == NULL) {
735 		CHKmalloc(pWrkrData-&gt;compressCtx.buf = (uchar *)malloc(sizeof(uchar)*newLen));
736 	} else {
737 		uchar *const newbuf = (uchar *)realloc(pWrkrData-&gt;compressCtx.buf, sizeof(uchar)*newLen);
738 		CHKmalloc(newbuf);
739 		pWrkrData-&gt;compressCtx.buf = newbuf;
740 	}
741 	pWrkrData-&gt;compressCtx.len = newLen;
742 finalize_it:
743 	RETiRet;
744 }
745 static rsRetVal ATTR_NONNULL()
746 appendCompressCtx(wrkrInstanceData_t *pWrkrData, uchar *srcBuf, size_t srcLen)
747 {
748 	size_t newLen;
749 	DEFiRet;
750 	newLen = pWrkrData-&gt;compressCtx.curLen + srcLen;
751 	if (newLen &gt; pWrkrData-&gt;compressCtx.len)
752 		CHKiRet(growCompressCtx(pWrkrData, newLen));
753 	memcpy(pWrkrData-&gt;compressCtx.buf + pWrkrData-&gt;compressCtx.curLen,
754 		srcBuf, srcLen);
755 	pWrkrData-&gt;compressCtx.curLen = newLen;
756 finalize_it:
757 	if (iRet != RS_RET_OK)
758 		freeCompressCtx(pWrkrData);
759 	RETiRet;
760 }
761 static rsRetVal ATTR_NONNULL()
762 buildCurlHeaders(wrkrInstanceData_t *pWrkrData, sbool contentEncodeGzip)
763 {
764 	struct curl_slist *slist = NULL;
765 	DEFiRet;
766 	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
767 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
768 	} else {
769 		if (pWrkrData-&gt;pData-&gt;batchMode) {
770 			switch (pWrkrData-&gt;pData-&gt;batchFormat) {
771 				case FMT_JSONARRAY:
772 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
773 					break;
774 				case FMT_KAFKAREST:
775 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_KAFKA);
776 					break;
777 				case FMT_NEWLINE:
778 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
779 					break;
780 				case FMT_LOKIREST:
781 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
782 					break;
783 				default:
784 					slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_TEXT);
785 			}
786 		} else {
787 			slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
788 		}
789 	}
790 	CHKmalloc(slist);
791 	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
792 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
793 		CHKmalloc(slist);
794 	}
795 	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
796 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
797 		CHKmalloc(slist);
798 	}
799 	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
800 	CHKmalloc(slist);
801 	if (contentEncodeGzip) {
802 		slist = curl_slist_append(slist, HTTP_HEADER_ENCODING_GZIP);
803 		CHKmalloc(slist);
804 	}
805 	if (pWrkrData-&gt;curlHeader != NULL)
806 		curl_slist_free_all(pWrkrData-&gt;curlHeader);
807 	pWrkrData-&gt;curlHeader = slist;
808 finalize_it:
809 	if (iRet != RS_RET_OK) {
810 		curl_slist_free_all(slist);
811 		LogError(0, iRet, "omhttp: error allocating curl header slist, using previous one");
812 	}
813 	RETiRet;
814 }
815 static rsRetVal ATTR_NONNULL(1, 2)
816 curlPost(wrkrInstanceData_t *pWrkrData, uchar *message, int msglen, uchar **tpls,
817 		const int nmsgs __attribute__((unused)))
818 {
819 	CURLcode curlCode;
820 	CURL *const curl = pWrkrData-&gt;curlPostHandle;
821 	char errbuf[CURL_ERROR_SIZE] = "";
822 	char *postData;
823 	int postLen;
824 	sbool compressed;
825 	DEFiRet;
826 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
827 	if(pWrkrData-&gt;pData-&gt;numServers &gt; 1) {
828 		CHKiRet(checkConn(pWrkrData));
829 	}
830 	CHKiRet(setPostURL(pWrkrData, tpls));
831 	pWrkrData-&gt;reply = NULL;
832 	pWrkrData-&gt;replyLen = 0;
833 	pWrkrData-&gt;httpStatusCode = 0;
834 	postData = (char *)message;
835 	postLen = msglen;
836 	compressed = 0;
837 	if (pWrkrData-&gt;pData-&gt;compress) {
838 		iRet = compressHttpPayload(pWrkrData, message, msglen);
839 		if (iRet != RS_RET_OK) {
840 			LogError(0, iRet, "omhttp: curlPost error while compressing, will default to uncompressed");
841 		} else {
842 			postData = (char *)pWrkrData-&gt;compressCtx.buf;
843 			postLen = pWrkrData-&gt;compressCtx.curLen;
844 			compressed = 1;
845 			DBGPRINTF("omhttp: curlPost compressed %d to %d bytes\n", msglen, postLen);
846 		}
847 	}
848 	buildCurlHeaders(pWrkrData, compressed);
849 	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postData);
850 	curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, postLen);
851 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
852 	curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errbuf);
853 	curlCode = curl_easy_perform(curl);
854 	DBGPRINTF("omhttp: curlPost curl returned %lld\n", (long long) curlCode);
855 	STATSCOUNTER_INC(ctrHttpRequestCount, mutCtrHttpRequestCount);
856 	if (curlCode != CURLE_OK) {
857 		STATSCOUNTER_INC(ctrHttpRequestFail, mutCtrHttpRequestFail);
858 		LogError(0, RS_RET_SUSPENDED,
859 			"omhttp: suspending ourselves due to server failure %lld: %s",
860 			(long long) curlCode, errbuf);
861 		checkResult(pWrkrData, message);
862 		ABORT_FINALIZE(RS_RET_SUSPENDED);
863 	} else {
864 		STATSCOUNTER_INC(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
865 	}
866 	curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &amp;pWrkrData-&gt;httpStatusCode);
867 	if(pWrkrData-&gt;reply == NULL) {
868 		DBGPRINTF("omhttp: curlPost pWrkrData reply==NULL, replyLen = '%d'\n",
869 			pWrkrData-&gt;replyLen);
870 	} else {
871 		DBGPRINTF("omhttp: curlPost pWrkrData replyLen = '%d'\n", pWrkrData-&gt;replyLen);
872 		if(pWrkrData-&gt;replyLen &gt; 0) {
873 			pWrkrData-&gt;reply[pWrkrData-&gt;replyLen] = '\0';
874 		}
875 		DBGPRINTF("omhttp: curlPost pWrkrData reply: '%s'\n", pWrkrData-&gt;reply);
876 	}
877 	CHKiRet(checkResult(pWrkrData, message));
878 finalize_it:
879 	incrementServerIndex(pWrkrData);
880 	if (pWrkrData-&gt;reply != NULL) {
881 		free(pWrkrData-&gt;reply);
882 		pWrkrData-&gt;reply = NULL; 	}
883 	RETiRet;
884 }
885 static rsRetVal
886 serializeBatchKafkaRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
887 {
888 	fjson_object *batchArray = NULL;
889 	fjson_object *recordObj = NULL;
890 	fjson_object *valueObj = NULL;
891 	fjson_object *msgObj = NULL;
892 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
893 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchKafkaRest numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
894 	DEFiRet;
895 	batchArray = fjson_object_new_array();
896 	if (batchArray == NULL) {
897 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create array");
898 		ABORT_FINALIZE(RS_RET_ERR);
899 	}
900 	for (size_t i = 0; i &lt; numMessages; i++) {
901 		valueObj = fjson_object_new_object();
902 		if (valueObj == NULL) {
903 			fjson_object_put(batchArray); 			LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create value object");
904 			ABORT_FINALIZE(RS_RET_ERR);
905 		}
906 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
907 		if (msgObj == NULL) {
908 			LogError(0, NO_ERRCODE,
909 				"omhttp: serializeBatchKafkaRest failed to parse %s as json ignoring it",
910 				pWrkrData-&gt;batch.data[i]);
911 			continue;
912 		}
913 		fjson_object_object_add(valueObj, "value", msgObj);
914 		fjson_object_array_add(batchArray, valueObj);
915 	}
916 	recordObj = fjson_object_new_object();
917 	if (recordObj == NULL) {
918 		fjson_object_put(batchArray); 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchKafkaRest failed to create record object");
919 		ABORT_FINALIZE(RS_RET_ERR);
920 	}
921 	fjson_object_object_add(recordObj, "records", batchArray);
922 	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
923 	*batchBuf = strndup(batchString, strlen(batchString));
924 finalize_it:
925 	if (recordObj != NULL) {
926 		fjson_object_put(recordObj);
927 		recordObj = NULL;
928 	}
929 	RETiRet;
930 }
931 static rsRetVal
932 serializeBatchLokiRest(wrkrInstanceData_t *pWrkrData, char **batchBuf)
933 {
934 	fjson_object *batchArray = NULL;
935 	fjson_object *recordObj = NULL;
936 	fjson_object *msgObj = NULL;
937 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
938 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchLokiRest numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
939 	DEFiRet;
940 	batchArray = fjson_object_new_array();
941 	if (batchArray == NULL) {
942 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchLokiRest failed to create array");
943 		ABORT_FINALIZE(RS_RET_ERR);
944 	}
945 	for (size_t i = 0; i &lt; numMessages; i++) {
946 		DBGPRINTF("omhttp: serializeBatchLokiRest parsing message [%s]\n",(char *) pWrkrData-&gt;batch.data[i]);
947 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
948 		if (msgObj == NULL) {
949 			LogError(0, NO_ERRCODE,
950 				"omhttp: serializeBatchLokiRest failed to parse %s as json ignoring it",
951 				pWrkrData-&gt;batch.data[i]);
952 			continue;
953 		}
954 		fjson_object_array_add(batchArray, msgObj);
955 	}
956 	recordObj = fjson_object_new_object();
957 	if (recordObj == NULL) {
958 		fjson_object_put(batchArray); 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchLokiRest failed to create record object");
959 		ABORT_FINALIZE(RS_RET_ERR);
960 	}
961 	fjson_object_object_add(recordObj, "streams", batchArray);
962 	const char *batchString = fjson_object_to_json_string_ext(recordObj, FJSON_TO_STRING_PLAIN);
963 	*batchBuf = strndup(batchString, strlen(batchString));
964 finalize_it:
965 	if (recordObj != NULL) {
966 		fjson_object_put(recordObj);
967 		recordObj = NULL;
968 	}
969 	RETiRet;
970 }
971 static rsRetVal
972 serializeBatchJsonArray(wrkrInstanceData_t *pWrkrData, char **batchBuf)
973 {
974 	fjson_object *batchArray = NULL;
975 	fjson_object *msgObj = NULL;
976 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
977 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages + 1; 	DBGPRINTF("omhttp: serializeBatchJsonArray numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
978 	DEFiRet;
979 	batchArray = fjson_object_new_array();
980 	if (batchArray == NULL) {
981 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchJsonArray failed to create array");
982 		ABORT_FINALIZE(RS_RET_ERR);
983 	}
984 	for (size_t i = 0; i &lt; numMessages; i++) {
985 		msgObj = fjson_tokener_parse((char *) pWrkrData-&gt;batch.data[i]);
986 		if (msgObj == NULL) {
987 			LogError(0, NO_ERRCODE,
988 				"omhttp: serializeBatchJsonArray failed to parse %s as json, ignoring it",
989 				pWrkrData-&gt;batch.data[i]);
990 			continue;
991 		}
992 		fjson_object_array_add(batchArray, msgObj);
993 	}
994 	const char *batchString = fjson_object_to_json_string_ext(batchArray, FJSON_TO_STRING_PLAIN);
995 	*batchBuf = strndup(batchString, strlen(batchString));
996 finalize_it:
997 	if (batchArray != NULL) {
998 		fjson_object_put(batchArray);
999 		batchArray = NULL;
1000 	}
1001 	RETiRet;
1002 }
1003 static rsRetVal
1004 serializeBatchNewline(wrkrInstanceData_t *pWrkrData, char **batchBuf)
1005 {
1006 	DEFiRet;
1007 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
1008 	size_t sizeTotal = pWrkrData-&gt;batch.sizeBytes + numMessages; 	int r = 0;
1009 	DBGPRINTF("omhttp: serializeBatchNewline numMessages=%zd sizeTotal=%zd\n", numMessages, sizeTotal);
1010 	es_str_t *batchString = es_newStr(1024);
1011 	if (batchString == NULL)
1012 		ABORT_FINALIZE(RS_RET_ERR);
1013 	for (size_t i = 0; i &lt; numMessages; i++) {
1014 		size_t nToCopy = ustrlen(pWrkrData-&gt;batch.data[i]);
1015 		if (r == 0) r = es_addBuf(&amp;batchString, (char *)pWrkrData-&gt;batch.data[i], nToCopy);
1016 		if (i == numMessages - 1) break;
1017 		if (r == 0) r = es_addChar(&amp;batchString, '\n');
1018 	}
1019 	if (r == 0) *batchBuf = (char *) es_str2cstr(batchString, NULL);
1020 	if (r != 0 || *batchBuf== NULL) {
1021 		LogError(0, RS_RET_ERR, "omhttp: serializeBatchNewline failed to build batch string");
1022 		ABORT_FINALIZE(RS_RET_ERR);
1023 	}
1024 finalize_it:
1025 	if (batchString != NULL)
1026 		es_deleteStr(batchString);
1027 	RETiRet;
1028 }
1029 static size_t
1030 computeBatchSize(wrkrInstanceData_t *pWrkrData)
1031 {
1032 	size_t extraBytes = 0;
1033 	size_t sizeBytes = pWrkrData-&gt;batch.sizeBytes;
1034 	size_t numMessages = pWrkrData-&gt;batch.nmemb;
1035 	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
1036 		case FMT_JSONARRAY:
1037 			extraBytes = numMessages &gt; 0 ? numMessages + 1 : 2;
1038 			break;
1039 		case FMT_KAFKAREST:
1040 			extraBytes = (numMessages * 10) + 14;
1041 			break;
1042 		case FMT_NEWLINE:
1043 			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
1044 			break;
1045 		case FMT_LOKIREST:
1046 			extraBytes = (numMessages * 2) + 14;
1047 			break;
1048 		default:
1049 			extraBytes = numMessages &gt; 0 ? numMessages - 1 : 0;
1050 	}
1051 	return sizeBytes + extraBytes + 1; }
1052 static void ATTR_NONNULL()
1053 initializeBatch(wrkrInstanceData_t *pWrkrData)
1054 {
1055 	pWrkrData-&gt;batch.sizeBytes = 0;
1056 	pWrkrData-&gt;batch.nmemb = 0;
1057 	if (pWrkrData-&gt;batch.restPath != NULL)  {
1058 		free(pWrkrData-&gt;batch.restPath);
1059 		pWrkrData-&gt;batch.restPath = NULL;
1060 	}
1061 }
1062 static rsRetVal
1063 buildBatch(wrkrInstanceData_t *pWrkrData, uchar *message)
1064 {
1065 	DEFiRet;
1066 	if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
1067 		LogError(0, RS_RET_ERR, "omhttp: buildBatch something has gone wrong,"
1068 			"number of messages in batch is bigger than the max batch size, bailing");
1069 		ABORT_FINALIZE(RS_RET_ERR);
1070 	}
1071 	pWrkrData-&gt;batch.data[pWrkrData-&gt;batch.nmemb] = message;
1072 	pWrkrData-&gt;batch.sizeBytes += strlen((char *)message);
1073 	pWrkrData-&gt;batch.nmemb++;
1074 finalize_it:
1075 	RETiRet;
1076 }
1077 static rsRetVal
1078 submitBatch(wrkrInstanceData_t *pWrkrData, uchar **tpls)
1079 {
1080 	DEFiRet;
1081 	char *batchBuf = NULL;
1082 	switch (pWrkrData-&gt;pData-&gt;batchFormat) {
1083 		case FMT_JSONARRAY:
1084 			iRet = serializeBatchJsonArray(pWrkrData, &amp;batchBuf);
1085 			break;
1086 		case FMT_KAFKAREST:
1087 			iRet = serializeBatchKafkaRest(pWrkrData, &amp;batchBuf);
1088 			break;
1089 		case FMT_LOKIREST:
1090 			iRet = serializeBatchLokiRest(pWrkrData, &amp;batchBuf);
1091 			break;
1092 		case FMT_NEWLINE:
1093 			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
1094 			break;
1095 		default:
1096 			iRet = serializeBatchNewline(pWrkrData, &amp;batchBuf);
1097 	}
1098 	if (iRet != RS_RET_OK || batchBuf == NULL)
1099 		ABORT_FINALIZE(iRet);
1100 	DBGPRINTF("omhttp: submitBatch, batch: '%s' tpls: '%p'\n", batchBuf, tpls);
1101 	CHKiRet(curlPost(pWrkrData, (uchar*) batchBuf, strlen(batchBuf),
1102 		tpls, pWrkrData-&gt;batch.nmemb));
1103 finalize_it:
1104 	if (batchBuf != NULL)
1105 		free(batchBuf);
1106 	RETiRet;
1107 }
1108 BEGINbeginTransaction
1109 CODESTARTbeginTransaction
1110 	if(!pWrkrData-&gt;pData-&gt;batchMode) {
1111 		FINALIZE;
1112 	}
1113 	initializeBatch(pWrkrData);
1114 finalize_it:
1115 ENDbeginTransaction
1116 BEGINdoAction
1117 size_t nBytes;
1118 sbool submit;
1119 CODESTARTdoAction
1120 	instanceData *const pData = pWrkrData-&gt;pData;
1121 	uchar *restPath = NULL;
1122 	STATSCOUNTER_INC(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
1123 	if (pWrkrData-&gt;pData-&gt;batchMode) {
1124 		if(pData-&gt;dynRestPath) {
1125 			getRestPath(pData, ppString, &amp;restPath);
1126 			if (pWrkrData-&gt;batch.restPath == NULL) {
1127 				pWrkrData-&gt;batch.restPath = (uchar*)strdup((char*)restPath);
1128 			} else if (strcmp((char*)pWrkrData-&gt;batch.restPath, (char*)restPath) != 0) {
1129 				CHKiRet(submitBatch(pWrkrData, NULL));
1130 				initializeBatch(pWrkrData);
1131 			}
1132 		}
1133 		if (pWrkrData-&gt;pData-&gt;maxBatchSize == 1) {
1134 			initializeBatch(pWrkrData);
1135 			CHKiRet(buildBatch(pWrkrData, ppString[0]));
1136 			CHKiRet(submitBatch(pWrkrData, ppString));
1137 			FINALIZE;
1138 		}
1139 		nBytes = ustrlen((char *)ppString[0]) - 1 ;
1140 		submit = 0;
1141 		if (pWrkrData-&gt;batch.nmemb &gt;= pWrkrData-&gt;pData-&gt;maxBatchSize) {
1142 			submit = 1;
1143 			DBGPRINTF("omhttp: maxbatchsize limit reached submitting batch of %zd elements.\n",
1144 				pWrkrData-&gt;batch.nmemb);
1145 		} else if (computeBatchSize(pWrkrData) + nBytes &gt; pWrkrData-&gt;pData-&gt;maxBatchBytes) {
1146 			submit = 1;
1147 			DBGPRINTF("omhttp: maxbytes limit reached submitting partial batch of %zd elements.\n",
1148 				pWrkrData-&gt;batch.nmemb);
1149 		}
1150 		if (submit) {
1151 			CHKiRet(submitBatch(pWrkrData, ppString));
1152 			initializeBatch(pWrkrData);
1153 		}
1154 		CHKiRet(buildBatch(pWrkrData, ppString[0]));
1155 		iRet = pWrkrData-&gt;batch.nmemb == 1 ? RS_RET_PREVIOUS_COMMITTED : RS_RET_DEFER_COMMIT;
1156 	} else {
1157 		CHKiRet(curlPost(pWrkrData, ppString[0], strlen((char*)ppString[0]), ppString, 1));
1158 	}
1159 finalize_it:
1160 ENDdoAction
1161 BEGINendTransaction
1162 CODESTARTendTransaction
1163 	if (pWrkrData-&gt;batch.nmemb &gt; 0) {
1164 		CHKiRet(submitBatch(pWrkrData, NULL));
1165 	} else {
1166 		dbgprintf("omhttp: endTransaction, pWrkrData-&gt;batch.nmemb = 0, "
1167 			"nothing to send. \n");
1168 	}
1169 finalize_it:
1170 ENDendTransaction
1171 static rsRetVal
1172 computeAuthHeader(char* uid, char* pwd, uchar** authBuf)
1173 {
1174 	int r;
1175 	DEFiRet;
1176 	es_str_t* auth = es_newStr(1024);
1177 	if (auth == NULL) {
1178 		LogError(0, RS_RET_OUT_OF_MEMORY,
1179 			"omhttp: failed to allocate es_str auth for auth header construction");
1180 		ABORT_FINALIZE(RS_RET_ERR);
1181 	}
1182 	r = es_addBuf(&amp;auth, uid, strlen(uid));
1183 	if(r == 0) r = es_addChar(&amp;auth, ':');
1184 	if(r == 0 &amp;&amp; pwd != NULL) r = es_addBuf(&amp;auth, pwd, strlen(pwd));
1185 	if(r == 0) *authBuf = (uchar*) es_str2cstr(auth, NULL);
1186 	if (r != 0 || *authBuf == NULL) {
1187 		LogError(0, RS_RET_ERR, "omhttp: failed to build auth header\n");
1188 		ABORT_FINALIZE(RS_RET_ERR);
1189 	}
1190 finalize_it:
1191 	if (auth != NULL)
1192 		es_deleteStr(auth);
1193 	RETiRet;
1194 }
1195 static rsRetVal
1196 computeApiHeader(char* key, char* value, uchar** headerBuf)
1197 {
1198 	int r;
1199 	DEFiRet;
1200 	es_str_t* header = es_newStr(10240);
1201 	if (header == NULL) {
1202 		LogError(0, RS_RET_OUT_OF_MEMORY,
1203 		"omhttp: failed to allocate es_str auth for api header construction");
1204 		ABORT_FINALIZE(RS_RET_ERR);
1205 	}
1206 	r = es_addBuf(&amp;header, key, strlen(key));
1207 	if(r == 0) r = es_addChar(&amp;header, ':');
1208 	if(r == 0) r = es_addChar(&amp;header, ' ');
1209 	if(r == 0 &amp;&amp; value != NULL) r = es_addBuf(&amp;header, value, strlen(value));
1210 	if(r == 0) *headerBuf = (uchar*) es_str2cstr(header, NULL);
1211 	if (r != 0 || *headerBuf == NULL) {
1212 		LogError(0, RS_RET_ERR, "omhttp: failed to build http header\n");
1213 		ABORT_FINALIZE(RS_RET_ERR);
1214 	}
1215 finalize_it:
1216 	if (header != NULL)
1217 		es_deleteStr(header);
1218 	RETiRet;
1219 }
1220 static void ATTR_NONNULL()
1221 curlSetupCommon(wrkrInstanceData_t *const pWrkrData, CURL *const handle)
1222 {
1223 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1224 	curl_easy_setopt(handle, CURLOPT_HTTPHEADER, pWrkrData-&gt;curlHeader);
1225 	curl_easy_setopt(handle, CURLOPT_NOSIGNAL, TRUE);
1226 	curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, curlResult);
1227 	curl_easy_setopt(handle, CURLOPT_WRITEDATA, pWrkrData);
1228 	if(pWrkrData-&gt;pData-&gt;allowUnsignedCerts)
1229 		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYPEER, FALSE);
1230 	if(pWrkrData-&gt;pData-&gt;skipVerifyHost)
1231 		curl_easy_setopt(handle, CURLOPT_SSL_VERIFYHOST, FALSE);
1232 	if(pWrkrData-&gt;pData-&gt;authBuf != NULL) {
1233 		curl_easy_setopt(handle, CURLOPT_USERPWD, pWrkrData-&gt;pData-&gt;authBuf);
1234 		curl_easy_setopt(handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY);
1235 	}
1236 	if(pWrkrData-&gt;pData-&gt;caCertFile)
1237 		curl_easy_setopt(handle, CURLOPT_CAINFO, pWrkrData-&gt;pData-&gt;caCertFile);
1238 	if(pWrkrData-&gt;pData-&gt;myCertFile)
1239 		curl_easy_setopt(handle, CURLOPT_SSLCERT, pWrkrData-&gt;pData-&gt;myCertFile);
1240 	if(pWrkrData-&gt;pData-&gt;myPrivKeyFile)
1241 		curl_easy_setopt(handle, CURLOPT_SSLKEY, pWrkrData-&gt;pData-&gt;myPrivKeyFile);
1242 }
1243 static void ATTR_NONNULL()
1244 curlCheckConnSetup(wrkrInstanceData_t *const pWrkrData)
1245 {
1246 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1247 	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlCheckConnHandle);
1248 	curl_easy_setopt(pWrkrData-&gt;curlCheckConnHandle,
1249 		CURLOPT_TIMEOUT_MS, pWrkrData-&gt;pData-&gt;healthCheckTimeout);
1250 }
1251 static void ATTR_NONNULL(1)
1252 curlPostSetup(wrkrInstanceData_t *const pWrkrData)
1253 {
1254 	PTR_ASSERT_SET_TYPE(pWrkrData, WRKR_DATA_TYPE_ES);
1255 	curlSetupCommon(pWrkrData, pWrkrData-&gt;curlPostHandle);
1256 	curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_POST, 1);
1257 	CURLcode cRet;
1258 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPALIVE, 1L);
1259 	if (cRet != CURLE_OK)
1260 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPALIVE\n");
1261 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPIDLE, 120L);
1262 	if (cRet != CURLE_OK)
1263 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPIDLE\n");
1264 	cRet = curl_easy_setopt(pWrkrData-&gt;curlPostHandle, CURLOPT_TCP_KEEPINTVL, 60L);
1265 	if (cRet != CURLE_OK)
1266 		DBGPRINTF("omhttp: curlPostSetup unknown option CURLOPT_TCP_KEEPINTVL\n");
1267 }
1268 static rsRetVal ATTR_NONNULL()
1269 curlSetup(wrkrInstanceData_t *const pWrkrData)
1270 {
1271 	struct curl_slist *slist = NULL;
1272 	DEFiRet;
1273 	if (pWrkrData-&gt;pData-&gt;httpcontenttype != NULL) {
1274 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerContentTypeBuf);
1275 	} else {
1276 		slist = curl_slist_append(slist, HTTP_HEADER_CONTENT_JSON);
1277 	}
1278 	if (pWrkrData-&gt;pData-&gt;headerBuf != NULL) {
1279 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;headerBuf);
1280 		CHKmalloc(slist);
1281 	}
1282 	for (int k = 0 ; k &lt; pWrkrData-&gt;pData-&gt;nHttpHeaders; k++) {
1283 		slist = curl_slist_append(slist, (char *)pWrkrData-&gt;pData-&gt;httpHeaders[k]);
1284 		CHKmalloc(slist);
1285 	}
1286 	slist = curl_slist_append(slist, HTTP_HEADER_EXPECT_EMPTY);
1287 	pWrkrData-&gt;curlHeader = slist;
1288 	CHKmalloc(pWrkrData-&gt;curlPostHandle = curl_easy_init());
1289 	curlPostSetup(pWrkrData);
1290 	CHKmalloc(pWrkrData-&gt;curlCheckConnHandle = curl_easy_init());
1291 	curlCheckConnSetup(pWrkrData);
1292 finalize_it:
1293 	if(iRet != RS_RET_OK &amp;&amp; pWrkrData-&gt;curlPostHandle != NULL) {
1294 		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
1295 		pWrkrData-&gt;curlPostHandle = NULL;
1296 	}
1297 	RETiRet;
1298 }
1299 static void ATTR_NONNULL()
1300 curlCleanup(wrkrInstanceData_t *const pWrkrData)
1301 {
1302 	if (pWrkrData-&gt;curlHeader != NULL) {
1303 		curl_slist_free_all(pWrkrData-&gt;curlHeader);
1304 		pWrkrData-&gt;curlHeader = NULL;
1305 	}
1306 	if (pWrkrData-&gt;curlCheckConnHandle != NULL) {
1307 		curl_easy_cleanup(pWrkrData-&gt;curlCheckConnHandle);
1308 		pWrkrData-&gt;curlCheckConnHandle = NULL;
1309 	}
1310 	if (pWrkrData-&gt;curlPostHandle != NULL) {
1311 		curl_easy_cleanup(pWrkrData-&gt;curlPostHandle);
1312 		pWrkrData-&gt;curlPostHandle = NULL;
1313 	}
1314 }
1315 static void ATTR_NONNULL()
1316 setInstParamDefaults(instanceData *const pData)
1317 {
1318 	pData-&gt;serverBaseUrls = NULL;
1319 	pData-&gt;defaultPort = 443;
1320 	pData-&gt;healthCheckTimeout = 3500;
1321 	pData-&gt;uid = NULL;
1322 	pData-&gt;httpcontenttype = NULL;
1323 	pData-&gt;headerContentTypeBuf = NULL;
1324 	pData-&gt;httpheaderkey = NULL;
1325 	pData-&gt;httpheadervalue = NULL;
1326 	pData-&gt;httpHeaders = NULL;
1327 	pData-&gt;nHttpHeaders = 0;
1328 	pData-&gt;pwd = NULL;
1329 	pData-&gt;authBuf = NULL;
1330 	pData-&gt;restPath = NULL;
1331 	pData-&gt;checkPath = NULL;
1332 	pData-&gt;dynRestPath = 0;
1333 	pData-&gt;batchMode = 0;
1334 	pData-&gt;batchFormatName = (uchar *)"newline";
1335 	pData-&gt;batchFormat = FMT_NEWLINE;
1336 	pData-&gt;bFreeBatchFormatName = 0;
1337 	pData-&gt;useHttps = 1;
1338 	pData-&gt;maxBatchBytes = 10485760; //i.e. 10 MB Is the default max message size for AWS API Gateway
1339 	pData-&gt;maxBatchSize = 100; 	pData-&gt;compress = 0; 	pData-&gt;compressionLevel = -1; 	pData-&gt;allowUnsignedCerts = 0;
1340 	pData-&gt;skipVerifyHost = 0;
1341 	pData-&gt;tplName = NULL;
1342 	pData-&gt;errorFile = NULL;
1343 	pData-&gt;caCertFile = NULL;
1344 	pData-&gt;myCertFile = NULL;
1345 	pData-&gt;myPrivKeyFile = NULL;
1346 	pData-&gt;reloadOnHup= 0;
1347 	pData-&gt;retryFailures = 0;
1348 	pData-&gt;ratelimitBurst = 20000;
1349 	pData-&gt;ratelimitInterval = 600;
1350 	pData-&gt;ratelimiter = NULL;
1351 	pData-&gt;retryRulesetName = NULL;
1352 	pData-&gt;retryRuleset = NULL;
1353 }
1354 static rsRetVal
1355 checkHeaderParam(char *const param)
1356 {
1357 	DEFiRet;
1358 	char *val = strstr(param, ":");
1359 	if(val == NULL) {
1360 		LogError(0, RS_RET_PARAM_ERROR, "missing ':' delimiter in "
1361 				"parameter '%s'", param);
1362 		ABORT_FINALIZE(RS_RET_PARAM_ERROR);
1363 	}
1364 finalize_it:
1365 	RETiRet;
1366 }
1367 BEGINnewActInst
1368 	struct cnfparamvals *pvals;
1369 	char* serverParam = NULL;
1370 	struct cnfarray* servers = NULL;
1371 	int i;
1372 	int iNumTpls;
1373 	FILE *fp;
1374 	char errStr[1024];
1375 	char *batchFormatName;
1376 	int compressionLevel = -1;
1377 CODESTARTnewActInst
1378 	if((pvals = nvlstGetParams(lst, &amp;actpblk, NULL)) == NULL) {
1379 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
1380 	}
1381 	CHKiRet(createInstance(&amp;pData));
1382 	setInstParamDefaults(pData);
1383 	for(i = 0 ; i &lt; actpblk.nParams ; ++i) {
1384 		if(!pvals[i].bUsed)
1385 			continue;
1386 		if(!strcmp(actpblk.descr[i].name, "server")) {
1387 			servers = pvals[i].val.d.ar;
1388 		} else if(!strcmp(actpblk.descr[i].name, "errorfile")) {
1389 			pData-&gt;errorFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1390 		} else if(!strcmp(actpblk.descr[i].name, "serverport")) {
1391 <a name="1"></a>			pData-&gt;defaultPort = (int) pvals[i].val.d.n;
1392 		} else if(!strcmp(actpblk.descr[i].name, "healthchecktimeout")) {
1393 			pData-&gt;healthCheckTimeout = (long) pvals[i].val.d.n;
1394 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>		} else if(!strcmp(actpblk.descr[i].name, "uid")) {
1395 			pData-&gt;uid = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1396 		} else if(!strcmp(actpblk.descr[i].name, "httpcontenttype")) {
1397 			pData-&gt;httpcontenttype = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1398 		} else if(!strcmp(actpblk.descr[i].name, "httpheaderkey")) {</b></font>
1399 			pData-&gt;httpheaderkey = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1400 		} else if(!strcmp(actpblk.descr[i].name, "httpheadervalue")) {
1401 			pData-&gt;httpheadervalue = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1402 		} else if(!strcmp(actpblk.descr[i].name, "httpheaders")) {
1403 			pData-&gt;nHttpHeaders = pvals[i].val.d.ar-&gt;nmemb;
1404 			CHKmalloc(pData-&gt;httpHeaders = malloc(sizeof(uchar *) * pvals[i].val.d.ar-&gt;nmemb ));
1405 			for(int j = 0 ; j &lt;  pvals[i].val.d.ar-&gt;nmemb ; ++j) {
1406 				char *cstr = es_str2cstr(pvals[i].val.d.ar-&gt;arr[j], NULL);
1407 				CHKiRet(checkHeaderParam(cstr));
1408 				pData-&gt;httpHeaders[j] = (uchar *)cstr;
1409 			}
1410 		} else if(!strcmp(actpblk.descr[i].name, "pwd")) {
1411 			pData-&gt;pwd = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1412 		} else if(!strcmp(actpblk.descr[i].name, "restpath")) {
1413 			pData-&gt;restPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1414 		} else if(!strcmp(actpblk.descr[i].name, "checkpath")) {
1415 			pData-&gt;checkPath = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1416 		} else if(!strcmp(actpblk.descr[i].name, "dynrestpath")) {
1417 			pData-&gt;dynRestPath = pvals[i].val.d.n;
1418 		} else if(!strcmp(actpblk.descr[i].name, "batch")) {
1419 			pData-&gt;batchMode = pvals[i].val.d.n;
1420 		} else if(!strcmp(actpblk.descr[i].name, "batch.format")) {
1421 			batchFormatName = es_str2cstr(pvals[i].val.d.estr, NULL);
1422 			if (strstr(VALID_BATCH_FORMATS, batchFormatName) != NULL) {
1423 				pData-&gt;batchFormatName = (uchar *)batchFormatName;
1424 				pData-&gt;bFreeBatchFormatName = 1;
1425 				if (!strcmp(batchFormatName, "newline")) {
1426 					pData-&gt;batchFormat = FMT_NEWLINE;
1427 				} else if (!strcmp(batchFormatName, "jsonarray")) {
1428 					pData-&gt;batchFormat = FMT_JSONARRAY;
1429 				} else if (!strcmp(batchFormatName, "kafkarest")) {
1430 					pData-&gt;batchFormat = FMT_KAFKAREST;
1431 				} else if (!strcmp(batchFormatName, "lokirest")) {
1432 					pData-&gt;batchFormat = FMT_LOKIREST;
1433 				}
1434 			} else {
1435 				LogError(0, NO_ERRCODE, "error: 'batch.format' %s unknown defaulting to 'newline'",
1436 					batchFormatName);
1437 			}
1438 		} else if(!strcmp(actpblk.descr[i].name, "batch.maxbytes")) {
1439 			pData-&gt;maxBatchBytes = (size_t) pvals[i].val.d.n;
1440 		} else if(!strcmp(actpblk.descr[i].name, "batch.maxsize")) {
1441 			pData-&gt;maxBatchSize = (size_t) pvals[i].val.d.n;
1442 		} else if(!strcmp(actpblk.descr[i].name, "compress")) {
1443 			pData-&gt;compress = pvals[i].val.d.n;
1444 		} else if(!strcmp(actpblk.descr[i].name, "compress.level")) {
1445 			compressionLevel = pvals[i].val.d.n;
1446 			if (compressionLevel == -1 || (compressionLevel &gt;= 0 &amp;&amp; compressionLevel &lt; 10)) {
1447 				pData-&gt;compressionLevel = compressionLevel;
1448 			} else {
1449 				LogError(0, NO_ERRCODE, "omhttp: invalid compress.level %d using default instead,"
1450 					"valid levels are -1 and 0-9",
1451 					compressionLevel);
1452 			}
1453 		} else if(!strcmp(actpblk.descr[i].name, "allowunsignedcerts")) {
1454 			pData-&gt;allowUnsignedCerts = pvals[i].val.d.n;
1455 		} else if(!strcmp(actpblk.descr[i].name, "skipverifyhost")) {
1456 			pData-&gt;skipVerifyHost = pvals[i].val.d.n;
1457 		} else if(!strcmp(actpblk.descr[i].name, "usehttps")) {
1458 			pData-&gt;useHttps = pvals[i].val.d.n;
1459 		} else if(!strcmp(actpblk.descr[i].name, "template")) {
1460 			pData-&gt;tplName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1461 		} else if(!strcmp(actpblk.descr[i].name, "tls.cacert")) {
1462 			pData-&gt;caCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1463 			fp = fopen((const char*)pData-&gt;caCertFile, "r");
1464 			if(fp == NULL) {
1465 				rs_strerror_r(errno, errStr, sizeof(errStr));
1466 				LogError(0, RS_RET_NO_FILE_ACCESS,
1467 						"error: 'tls.cacert' file %s couldn't be accessed: %s\n",
1468 						pData-&gt;caCertFile, errStr);
1469 			} else {
1470 				fclose(fp);
1471 			}
1472 		} else if(!strcmp(actpblk.descr[i].name, "tls.mycert")) {
1473 			pData-&gt;myCertFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1474 			fp = fopen((const char*)pData-&gt;myCertFile, "r");
1475 			if(fp == NULL) {
1476 				rs_strerror_r(errno, errStr, sizeof(errStr));
1477 				LogError(0, RS_RET_NO_FILE_ACCESS,
1478 						"error: 'tls.mycert' file %s couldn't be accessed: %s\n",
1479 						pData-&gt;myCertFile, errStr);
1480 			} else {
1481 				fclose(fp);
1482 			}
1483 		} else if(!strcmp(actpblk.descr[i].name, "tls.myprivkey")) {
1484 			pData-&gt;myPrivKeyFile = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1485 			fp = fopen((const char*)pData-&gt;myPrivKeyFile, "r");
1486 			if(fp == NULL) {
1487 				rs_strerror_r(errno, errStr, sizeof(errStr));
1488 				LogError(0, RS_RET_NO_FILE_ACCESS,
1489 						"error: 'tls.myprivkey' file %s couldn't be accessed: %s\n",
1490 						pData-&gt;myPrivKeyFile, errStr);
1491 			} else {
1492 				fclose(fp);
1493 			}
1494 		} else if(!strcmp(actpblk.descr[i].name, "reloadonhup")) {
1495 			pData-&gt;reloadOnHup= pvals[i].val.d.n;
1496 		} else if(!strcmp(actpblk.descr[i].name, "retry")) {
1497 			pData-&gt;retryFailures = pvals[i].val.d.n;
1498 		} else if(!strcmp(actpblk.descr[i].name, "retry.ruleset")) {
1499 			pData-&gt;retryRulesetName = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
1500 		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.burst")) {
1501 			pData-&gt;ratelimitBurst = (unsigned int) pvals[i].val.d.n;
1502 		} else if(!strcmp(actpblk.descr[i].name, "ratelimit.interval")) {
1503 			pData-&gt;ratelimitInterval = (unsigned int) pvals[i].val.d.n;
1504 		} else {
1505 			LogError(0, RS_RET_INTERNAL_ERROR, "omhttp: program error, "
1506 				"non-handled param '%s'", actpblk.descr[i].name);
1507 		}
1508 	}
1509 	if(pData-&gt;pwd != NULL &amp;&amp; pData-&gt;uid == NULL) {
1510 		LogError(0, RS_RET_UID_MISSING,
1511 			"omhttp: password is provided, but no uid "
1512 			"- action definition invalid");
1513 		ABORT_FINALIZE(RS_RET_UID_MISSING);
1514 	}
1515 	if(pData-&gt;httpheaderkey != NULL &amp;&amp; pData-&gt;httpheadervalue == NULL) {
1516 		LogError(0, RS_RET_UID_MISSING,
1517 			"omhttp: http header key is provided, but no http header value "
1518 			"- action definition invalid");
1519 		ABORT_FINALIZE(RS_RET_UID_MISSING);
1520 	}
1521 	if(pData-&gt;dynRestPath &amp;&amp; pData-&gt;restPath == NULL) {
1522 		LogError(0, RS_RET_CONFIG_ERROR,
1523 			"omhttp: requested dynamic rest path, but no name for rest "
1524 			"path template given - action definition invalid");
1525 		ABORT_FINALIZE(RS_RET_CONFIG_ERROR);
1526 	}
1527 	if (pData-&gt;uid != NULL)
1528 		CHKiRet(computeAuthHeader((char*) pData-&gt;uid, (char*) pData-&gt;pwd, &amp;pData-&gt;authBuf));
1529 	if (pData-&gt;httpcontenttype != NULL)
1530 		CHKiRet(computeApiHeader((char*) "Content-Type",
1531 				(char*) pData-&gt;httpcontenttype, &amp;pData-&gt;headerContentTypeBuf));
1532 	if (pData-&gt;httpheaderkey != NULL)
1533 		CHKiRet(computeApiHeader((char*) pData-&gt;httpheaderkey,
1534 				(char*) pData-&gt;httpheadervalue, &amp;pData-&gt;headerBuf));
1535 	iNumTpls = 1;
1536 	if(pData-&gt;dynRestPath) ++iNumTpls;
1537 	DBGPRINTF("omhttp: requesting %d templates\n", iNumTpls);
1538 	CODE_STD_STRING_REQUESTnewActInst(iNumTpls)
1539 	CHKiRet(OMSRsetEntry(*ppOMSR, 0, (uchar*)strdup((pData-&gt;tplName == NULL) ?
1540 					    " StdJSONFmt" : (char*)pData-&gt;tplName),
1541 		OMSR_NO_RQD_TPL_OPTS));
1542 	iNumTpls = 1;
1543 	if(pData-&gt;dynRestPath) {
1544 		CHKiRet(OMSRsetEntry(*ppOMSR, iNumTpls, ustrdup(pData-&gt;restPath),
1545 			OMSR_NO_RQD_TPL_OPTS));
1546 		++iNumTpls;
1547 	}
1548 	if (servers != NULL) {
1549 		pData-&gt;numServers = servers-&gt;nmemb;
1550 		pData-&gt;serverBaseUrls = malloc(servers-&gt;nmemb * sizeof(uchar*));
1551 		if (pData-&gt;serverBaseUrls == NULL) {
1552 			LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1553 					"for http server configuration.");
1554 			ABORT_FINALIZE(RS_RET_ERR);
1555 		}
1556 		for(i = 0 ; i &lt; servers-&gt;nmemb ; ++i) {
1557 			serverParam = es_str2cstr(servers-&gt;arr[i], NULL);
1558 			if (serverParam == NULL) {
1559 				LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1560 					"for http server configuration.");
1561 				ABORT_FINALIZE(RS_RET_ERR);
1562 			}
1563 			const size_t serverParamLastChar = strlen(serverParam)-1;
1564 			if (serverParam[serverParamLastChar] == '/') {
1565 				serverParam[serverParamLastChar] = '\0';
1566 			}
1567 			CHKiRet(computeBaseUrl(serverParam, pData-&gt;defaultPort, pData-&gt;useHttps,
1568 				pData-&gt;serverBaseUrls + i));
1569 			free(serverParam);
1570 			serverParam = NULL;
1571 		}
1572 	} else {
1573 		LogMsg(0, RS_RET_OK, LOG_WARNING,
1574 			"omhttp: No servers specified, using localhost");
1575 		pData-&gt;numServers = 1;
1576 		pData-&gt;serverBaseUrls = malloc(sizeof(uchar*));
1577 		if (pData-&gt;serverBaseUrls == NULL) {
1578 			LogError(0, RS_RET_ERR, "omhttp: unable to allocate buffer "
1579 					"for http server configuration.");
1580 			ABORT_FINALIZE(RS_RET_ERR);
1581 		}
1582 		CHKiRet(computeBaseUrl("localhost", pData-&gt;defaultPort, pData-&gt;useHttps, pData-&gt;serverBaseUrls));
1583 	}
1584 	if (pData-&gt;retryFailures) {
1585 		CHKiRet(ratelimitNew(&amp;pData-&gt;ratelimiter, "omhttp", NULL));
1586 		ratelimitSetLinuxLike(pData-&gt;ratelimiter, pData-&gt;ratelimitInterval, pData-&gt;ratelimitBurst);
1587 		ratelimitSetNoTimeCache(pData-&gt;ratelimiter);
1588 	}
1589 	if(loadModConf-&gt;tail == NULL) {
1590 		loadModConf-&gt;tail = loadModConf-&gt;root = pData;
1591 	} else {
1592 		loadModConf-&gt;tail-&gt;next = pData;
1593 		loadModConf-&gt;tail = pData;
1594 	}
1595 CODE_STD_FINALIZERnewActInst
1596 	cnfparamvalsDestruct(pvals, &amp;actpblk);
1597 	if (serverParam)
1598 		free(serverParam);
1599 ENDnewActInst
1600 BEGINbeginCnfLoad
1601 CODESTARTbeginCnfLoad
1602 	loadModConf = pModConf;
1603 	pModConf-&gt;pConf = pConf;
1604 	pModConf-&gt;root = pModConf-&gt;tail = NULL;
1605 ENDbeginCnfLoad
1606 BEGINendCnfLoad
1607 CODESTARTendCnfLoad
1608 	loadModConf = NULL; ENDendCnfLoad
1609 BEGINcheckCnf
1610 	instanceConf_t *inst;
1611 CODESTARTcheckCnf
1612 	for(inst = pModConf-&gt;root ; inst != NULL ; inst = inst-&gt;next) {
1613 		ruleset_t *pRuleset;
1614 		rsRetVal localRet;
1615 		if (inst-&gt;retryRulesetName) {
1616 			localRet = ruleset.GetRuleset(pModConf-&gt;pConf, &amp;pRuleset, inst-&gt;retryRulesetName);
1617 			if(localRet == RS_RET_NOT_FOUND) {
1618 				LogError(0, localRet, "omhttp: retry.ruleset '%s' not found - "
1619 						"no retry ruleset will be used", inst-&gt;retryRulesetName);
1620 			} else {
1621 				inst-&gt;retryRuleset = pRuleset;
1622 			}
1623 		}
1624 	}
1625 ENDcheckCnf
1626 BEGINactivateCnf
1627 CODESTARTactivateCnf
1628 ENDactivateCnf
1629 BEGINfreeCnf
1630 CODESTARTfreeCnf
1631 ENDfreeCnf
1632 BEGINdoHUP
1633 CODESTARTdoHUP
1634 	pthread_mutex_lock(&amp;pData-&gt;mutErrFile);
1635 	if (pData-&gt;fdErrFile != -1) {
1636 		close(pData-&gt;fdErrFile);
1637 		pData-&gt;fdErrFile = -1;
1638 	}
1639 	pthread_mutex_unlock(&amp;pData-&gt;mutErrFile);
1640 ENDdoHUP
1641 BEGINdoHUPWrkr
1642 CODESTARTdoHUPWrkr
1643 	if (pWrkrData-&gt;pData-&gt;reloadOnHup) {
1644 		LogMsg(0, NO_ERRCODE, LOG_INFO, "omhttp: received HUP reloading curl handles");
1645 		curlCleanup(pWrkrData);
1646 		CHKiRet(curlSetup(pWrkrData));
1647 	}
1648 finalize_it:
1649 ENDdoHUPWrkr
1650 BEGINmodExit
1651 CODESTARTmodExit
1652 	if(pInputName != NULL)
1653 		prop.Destruct(&amp;pInputName);
1654 	curl_global_cleanup();
1655 	objRelease(prop, CORE_COMPONENT);
1656 	objRelease(ruleset, CORE_COMPONENT);
1657 	objRelease(statsobj, CORE_COMPONENT);
1658 	statsobj.Destruct(&amp;httpStats);
1659 ENDmodExit
1660 NO_LEGACY_CONF_parseSelectorAct
1661 BEGINqueryEtryPt
1662 CODESTARTqueryEtryPt
1663 CODEqueryEtryPt_STD_OMOD_QUERIES
1664 CODEqueryEtryPt_STD_OMOD8_QUERIES
1665 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
1666 CODEqueryEtryPt_STD_CONF2_OMOD_QUERIES
1667 CODEqueryEtryPt_doHUP
1668 CODEqueryEtryPt_doHUPWrkr CODEqueryEtryPt_TXIF_OMOD_QUERIES CODEqueryEtryPt_STD_CONF2_QUERIES
1669 ENDqueryEtryPt
1670 BEGINmodInit()
1671 CODESTARTmodInit
1672 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
1673 	CHKiRet(objUse(prop, CORE_COMPONENT));
1674 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
1675 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1676 	CHKiRet(statsobj.Construct(&amp;httpStats));
1677 	CHKiRet(statsobj.SetName(httpStats, (uchar *)"omhttp"));
1678 	CHKiRet(statsobj.SetOrigin(httpStats, (uchar*)"omhttp"));
1679 	STATSCOUNTER_INIT(ctrMessagesSubmitted, mutCtrMessagesSubmitted);
1680 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.submitted",
1681 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSubmitted));
1682 	STATSCOUNTER_INIT(ctrMessagesSuccess, mutCtrMessagesSuccess);
1683 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.success",
1684 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesSuccess));
1685 	STATSCOUNTER_INIT(ctrMessagesFail, mutCtrMessagesFail);
1686 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.fail",
1687 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesFail));
1688 	STATSCOUNTER_INIT(ctrMessagesRetry, mutCtrMessagesRetry);
1689 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"messages.retry",
1690 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrMessagesRetry));
1691 	STATSCOUNTER_INIT(ctrHttpRequestCount, mutCtrHttpRequestCount);
1692 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.count",
1693 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestCount));
1694 	STATSCOUNTER_INIT(ctrHttpRequestSuccess, mutCtrHttpRequestSuccess);
1695 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.success",
1696 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestSuccess));
1697 	STATSCOUNTER_INIT(ctrHttpRequestFail, mutCtrHttpRequestFail);
1698 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.fail",
1699 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpRequestFail));
1700 	STATSCOUNTER_INIT(ctrHttpStatusSuccess, mutCtrHttpStatusSuccess);
1701 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.status.success",
1702 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusSuccess));
1703 	STATSCOUNTER_INIT(ctrHttpStatusFail, mutCtrHttpStatusFail);
1704 	CHKiRet(statsobj.AddCounter(httpStats, (uchar *)"request.status.fail",
1705 			ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;ctrHttpStatusFail));
1706 	CHKiRet(statsobj.ConstructFinalize(httpStats));
1707 	if (curl_global_init(CURL_GLOBAL_ALL) != 0) {
1708 		LogError(0, RS_RET_OBJ_CREATION_FAILED, "CURL fail. -http disabled");
1709 		ABORT_FINALIZE(RS_RET_OBJ_CREATION_FAILED);
1710 	}
1711 	CHKiRet(prop.Construct(&amp;pInputName));
1712 	CHKiRet(prop.SetString(pInputName, UCHAR_CONSTANT("omhttp"), sizeof("omhttp") - 1));
1713 	CHKiRet(prop.ConstructFinalize(pInputName));
1714 ENDmodInit
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>immark.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include "rsyslog.h"
3 #include &lt;stdlib.h&gt;
4 #include &lt;stdio.h&gt;
5 #include &lt;assert.h&gt;
6 #include &lt;signal.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;pthread.h&gt;
9 #include "dirty.h"
10 #include "cfsysline.h"
11 #include "module-template.h"
12 #include "errmsg.h"
13 #include "msg.h"
14 #include "srUtils.h"
15 #include "glbl.h"
16 #include "unicode-helper.h"
17 #include "ruleset.h"
18 #include "prop.h"
19 MODULE_TYPE_INPUT
20 MODULE_TYPE_NOKEEP
21 MODULE_CNFNAME("immark")
22 #define DEFAULT_MARK_PERIOD (20 * 60)
23 DEF_IMOD_STATIC_DATA
24 DEFobjCurrIf(glbl)
25 DEFobjCurrIf(prop)
26 DEFobjCurrIf(ruleset)
27 static int iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
28 struct modConfData_s {
29 	rsconf_t *pConf;		const char *pszMarkMsgText;
30 	size_t lenMarkMsgText;
31 	uchar *pszBindRuleset;
32 	ruleset_t *pBindRuleset;
33 	int flags;
34 	int bUseMarkFlag;
35 	int bUseSyslogAPI;
36 	int iMarkMessagePeriod;
37 	sbool configSetViaV2Method;
38 };
39 <a name="0"></a>
40 static struct cnfparamdescr modpdescr[] = {
41 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>	{ "ruleset", eCmdHdlrString, 0 },
42 	{ "markmessagetext", eCmdHdlrString, 0 },
43 	{ "use.syslogcall", eCmdHdlrBinary, 0 },
44 	{ "use.markflag", eCmdHdlrBinary, 0 },
45 	{ "interval", eCmdHdlrInt, 0 }
46 };
47 static struct cnfparamblk modpblk =
48 	{ CNFPARAMBLK_VERSION,
49 	  sizeof(modpdescr)/sizeof(struct cnfparamdescr),
50 	  modpdescr
51 	};
52 static modConfData_t *loadModConf = NULL;static int bLegacyCnfModGlobalsPermitted;static prop_t *pInternalInputName = NULL;
53 BEGINisCompatibleWithFeature
54 CODESTARTisCompatibleWithFeature
55 	if(eFeat == sFEATURENonCancelInputTermination)
56 		iRet = RS_RET_OK;
57 ENDisCompatibleWithFeature
58 BEGINafterRun
59 CODESTARTafterRun
60 ENDafterRun
61 BEGINbeginCnfLoad
62 CODESTARTbeginCnfLoad
63 	loadModConf = pModConf;
64 	pModConf-&gt;pConf = pConf;
65 	pModConf-&gt;pszMarkMsgText = NULL;
66 	pModConf-&gt;iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
67 	pModConf-&gt;bUseSyslogAPI = 1;
68 	pModConf-&gt;bUseMarkFlag = 1;
69 	pModConf-&gt;pszBindRuleset = NULL;
70 	pModConf-&gt;pBindRuleset = NULL;
71 	loadModConf-&gt;configSetViaV2Method = 0;
72 	bLegacyCnfModGlobalsPermitted = 1;
73 ENDbeginCnfLoad
74 static rsRetVal
75 checkRuleset(modConfData_t *modConf)
76 {
77 	ruleset_t *pRuleset;
78 	rsRetVal localRet;
79 	DEFiRet;
80 	if(modConf-&gt;pszBindRuleset == NULL)
81 		FINALIZE;
82 	localRet = ruleset.GetRuleset(modConf-&gt;pConf, &amp;pRuleset, modConf-&gt;pszBindRuleset);
83 	if(localRet == RS_RET_NOT_FOUND) {
84 		LogError(0, NO_ERRCODE, "immark: ruleset '%s' not found - "
85 				"using default ruleset instead", modConf-&gt;pszBindRuleset);
86 	}
87 	CHKiRet(localRet);
88 	modConf-&gt;pBindRuleset = pRuleset;
89 finalize_it:
90 	RETiRet;
91 }
92 BEGINsetModCnf
93 	struct cnfparamvals *pvals = NULL;
94 	int i;
95 CODESTARTsetModCnf
96 	pvals = nvlstGetParams(lst, &amp;modpblk, NULL);
97 	if(pvals == NULL) {
98 		LogError(0, RS_RET_MISSING_CNFPARAMS, "error processing module "
99 				"config parameters [module(...)]");
100 		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
101 	}
102 	if(Debug) {
103 		dbgprintf("module (global) param blk for immark:\n");
104 		cnfparamsPrint(&amp;modpblk, pvals);
105 	}
106 	for(i = 0 ; i &lt; modpblk.nParams ; ++i) {
107 		if(!pvals[i].bUsed)
108 			continue;
109 		if(!strcmp(modpblk.descr[i].name, "interval")) {
110 			loadModConf-&gt;iMarkMessagePeriod = (int) pvals[i].val.d.n;
111 		} else if(!strcmp(modpblk.descr[i].name, "use.syslogcall")) {
112 <a name="1"></a>			loadModConf-&gt;bUseSyslogAPI = (int) pvals[i].val.d.n;
113 		} else if(!strcmp(modpblk.descr[i].name, "use.markflag")) {
114 			loadModConf-&gt;bUseMarkFlag = (int) pvals[i].val.d.n;
115 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>		} else if(!strcmp(modpblk.descr[i].name, "ruleset")) {
116 			loadModConf-&gt;pszBindRuleset = (uchar*)es_str2cstr(pvals[i].val.d.estr, NULL);
117 		} else if(!strcmp(modpblk.descr[i].name, "markmessagetext")) {
118 			loadModConf-&gt;pszMarkMsgText = es_str2cstr(pvals[i].val.d.estr, NULL);
119 		} else {</b></font>
120 			dbgprintf("immark: program error, non-handled "
121 			  "param '%s' in beginCnfLoad\n", modpblk.descr[i].name);
122 		}
123 	}
124 	bLegacyCnfModGlobalsPermitted = 0;
125 	loadModConf-&gt;configSetViaV2Method = 1;
126 finalize_it:
127 	if(pvals != NULL)
128 		cnfparamvalsDestruct(pvals, &amp;modpblk);
129 ENDsetModCnf
130 BEGINendCnfLoad
131 CODESTARTendCnfLoad
132 	if(!loadModConf-&gt;configSetViaV2Method) {
133 		pModConf-&gt;iMarkMessagePeriod = iMarkMessagePeriod;
134 	}
135 ENDendCnfLoad
136 BEGINcheckCnf
137 CODESTARTcheckCnf
138 	pModConf-&gt;flags = (pModConf-&gt;bUseMarkFlag) ? MARK : 0;
139 	if(pModConf-&gt;pszMarkMsgText == NULL) {
140 		pModConf-&gt;pszMarkMsgText = strdup("-- MARK --");
141 	}
142 	pModConf-&gt;lenMarkMsgText = strlen(pModConf-&gt;pszMarkMsgText);
143 	if(pModConf-&gt;pszBindRuleset != NULL) {
144 		checkRuleset(pModConf);
145 		if(pModConf-&gt;bUseSyslogAPI) {
146 			LogError(0, NO_ERRCODE, "immark: ruleset specified, but configured to log "
147 				"via syslog call - switching to rsyslog-internal logging");
148 			pModConf-&gt;bUseSyslogAPI = 0;
149 		}
150 	}
151 	if(pModConf-&gt;iMarkMessagePeriod == 0) {
152 		LogError(0, NO_ERRCODE, "immark: mark message period must not be 0, can not run");
153 		ABORT_FINALIZE(RS_RET_NO_RUN);		}
154 finalize_it:
155 ENDcheckCnf
156 BEGINactivateCnf
157 CODESTARTactivateCnf
158 	MarkInterval = pModConf-&gt;iMarkMessagePeriod;
159 	DBGPRINTF("immark set MarkInterval to %d\n", MarkInterval);
160 ENDactivateCnf
161 BEGINfreeCnf
162 CODESTARTfreeCnf
163 ENDfreeCnf
164 static rsRetVal
165 injectMarkMessage(const int pri)
166 {
167 	smsg_t *pMsg;
168 	DEFiRet;
169 	CHKiRet(msgConstruct(&amp;pMsg));
170 	pMsg-&gt;msgFlags  = loadModConf-&gt;flags;
171 	MsgSetInputName(pMsg, pInternalInputName);
172 	MsgSetRawMsg(pMsg, loadModConf-&gt;pszMarkMsgText,loadModConf-&gt;lenMarkMsgText);
173 	MsgSetHOSTNAME(pMsg, glbl.GetLocalHostName(), ustrlen(glbl.GetLocalHostName()));
174 	MsgSetRcvFrom(pMsg, glbl.GetLocalHostNameProp());
175 	MsgSetRcvFromIP(pMsg, glbl.GetLocalHostIP());
176 	MsgSetMSGoffs(pMsg, 0);
177 	MsgSetTAG(pMsg, (const uchar*)"rsyslogd:", sizeof("rsyslogd:")-1);
178 	msgSetPRI(pMsg, pri);
179 	MsgSetRuleset(pMsg, loadModConf-&gt;pBindRuleset);
180 	submitMsg2(pMsg);
181 finalize_it:
182 	RETiRet;
183 }
184 BEGINrunInput
185 CODESTARTrunInput
186 	while(1) {
187 		srSleep(MarkInterval, 0); 
188 		if(glbl.GetGlobalInputTermState() == 1)
189 			break; 
190 		dbgprintf("immark: injecting mark message\n");
191 		if(loadModConf-&gt;bUseSyslogAPI) {
192 			logmsgInternal(NO_ERRCODE, LOG_SYSLOG|LOG_INFO,
193 				(uchar*)loadModConf-&gt;pszMarkMsgText, loadModConf-&gt;flags);
194 		} else {
195 			injectMarkMessage(LOG_SYSLOG|LOG_INFO);
196 		}
197 	}
198 ENDrunInput
199 BEGINwillRun
200 CODESTARTwillRun
201 ENDwillRun
202 BEGINmodExit
203 CODESTARTmodExit
204 	if(pInternalInputName != NULL)
205 		prop.Destruct(&amp;pInternalInputName);
206 	objRelease(ruleset, CORE_COMPONENT);
207 	objRelease(prop, CORE_COMPONENT);
208 ENDmodExit
209 BEGINqueryEtryPt
210 CODESTARTqueryEtryPt
211 CODEqueryEtryPt_STD_IMOD_QUERIES
212 CODEqueryEtryPt_STD_CONF2_QUERIES
213 CODEqueryEtryPt_STD_CONF2_setModCnf_QUERIES
214 CODEqueryEtryPt_IsCompatibleWithFeature_IF_OMOD_QUERIES
215 ENDqueryEtryPt
216 static rsRetVal resetConfigVariables(uchar __attribute__((unused)) *pp, void __attribute__((unused)) *pVal)
217 {
218 	iMarkMessagePeriod = DEFAULT_MARK_PERIOD;
219 	return RS_RET_OK;
220 }
221 BEGINmodInit()
222 CODESTARTmodInit
223 	*ipIFVersProvided = CURR_MOD_IF_VERSION; CODEmodInit_QueryRegCFSLineHdlr
224 	CHKiRet(objUse(glbl, CORE_COMPONENT));
225 	CHKiRet(objUse(prop, CORE_COMPONENT));
226 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
227 	CHKiRet(prop.Construct(&amp;pInternalInputName));
228 	CHKiRet(prop.SetString(pInternalInputName, UCHAR_CONSTANT("immark"), sizeof("immark") - 1));
229 	CHKiRet(prop.ConstructFinalize(pInternalInputName));
230 	CHKiRet(regCfSysLineHdlr2((uchar *)"markmessageperiod", 0, eCmdHdlrInt, NULL,
231 		&amp;iMarkMessagePeriod, STD_LOADABLE_MODULE_ID, &amp;bLegacyCnfModGlobalsPermitted));
232 	CHKiRet(omsdRegCFSLineHdlr((uchar *)"resetconfigvariables", 1, eCmdHdlrCustomHandler,
233 		resetConfigVariables, NULL, STD_LOADABLE_MODULE_ID));
234 ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
