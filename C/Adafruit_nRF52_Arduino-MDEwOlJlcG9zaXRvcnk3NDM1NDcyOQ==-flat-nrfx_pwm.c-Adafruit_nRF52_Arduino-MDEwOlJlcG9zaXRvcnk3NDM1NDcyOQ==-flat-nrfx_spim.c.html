
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 30, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_pwm.c</h3>
            <pre><code>1  #include <nrfx.h>
2  #if NRFX_CHECK(NRFX_PWM_ENABLED)
3  #if !(NRFX_CHECK(NRFX_PWM0_ENABLED) || NRFX_CHECK(NRFX_PWM1_ENABLED) || \
4        NRFX_CHECK(NRFX_PWM2_ENABLED) || NRFX_CHECK(NRFX_PWM3_ENABLED))
5  #error "No enabled PWM instances. Check <nrfx_config.h>."
6  #endif
7  #include <nrfx_pwm.h>
8  #include <hal/nrf_gpio.h>
9  #define NRFX_LOG_MODULE PWM
10  #include <nrfx_log.h>
11  #if NRFX_CHECK(NRFX_PWM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
12  #include <hal/nrf_egu.h>
13  #define USE_DMA_ISSUE_WORKAROUND
14  #endif
15  #if defined(USE_DMA_ISSUE_WORKAROUND)
16  #define EGU_IRQn(i)         EGU_IRQn_(i)
17  #define EGU_IRQn_(i)        SWI##i##_EGU##i##_IRQn
18  #define EGU_IRQHandler(i)   EGU_IRQHandler_(i)
19  #define EGU_IRQHandler_(i)  nrfx_egu_##i##_irq_handler
20  #define DMA_ISSUE_EGU_IDX           NRFX_PWM_NRF52_ANOMALY_109_EGU_INSTANCE
21  #define DMA_ISSUE_EGU               NRFX_CONCAT_2(NRF_EGU, DMA_ISSUE_EGU_IDX)
22  #define DMA_ISSUE_EGU_IRQn          EGU_IRQn(DMA_ISSUE_EGU_IDX)
23  #define DMA_ISSUE_EGU_IRQHandler    EGU_IRQHandler(DMA_ISSUE_EGU_IDX)
24  #endif
25  typedef struct
26  {
27  #if defined(USE_DMA_ISSUE_WORKAROUND)
28      uint32_t                  starting_task_address;
29  #endif
30      nrfx_pwm_handler_t        handler;
31      void *                    p_context;
32      nrfx_drv_state_t volatile state;
33      uint8_t                   flags;
34  } pwm_control_block_t;
35  static pwm_control_block_t m_cb[NRFX_PWM_ENABLED_COUNT];
36  static void configure_pins(nrfx_pwm_t const *        p_instance,
37                             nrfx_pwm_config_t const * p_config)
38  {
39      uint32_t out_pins[NRF_PWM_CHANNEL_COUNT];
40      uint8_t i;
41      for (i = 0; i < NRF_PWM_CHANNEL_COUNT; ++i)
42      {
43          uint8_t output_pin = p_config->output_pins[i];
44          if (output_pin != NRFX_PWM_PIN_NOT_USED)
45          {
46              bool inverted = output_pin &  NRFX_PWM_PIN_INVERTED;
47              out_pins[i]   = output_pin & ~NRFX_PWM_PIN_INVERTED;
48              if (!p_config->skip_gpio_cfg)
49              {
50                  if (inverted)
51                  {
52                      nrf_gpio_pin_set(out_pins[i]);
53                  }
54                  else
55                  {
56                      nrf_gpio_pin_clear(out_pins[i]);
57                  }
58                  nrf_gpio_cfg_output(out_pins[i]);
59              }
60          }
61          else
62          {
63              out_pins[i] = NRF_PWM_PIN_NOT_CONNECTED;
64          }
65      }
66      nrf_pwm_pins_set(p_instance->p_registers, out_pins);
67  }
68  nrfx_err_t nrfx_pwm_init(nrfx_pwm_t const *        p_instance,
69                           nrfx_pwm_config_t const * p_config,
70                           nrfx_pwm_handler_t        handler,
71                           void *                    p_context)
72  {
73      NRFX_ASSERT(p_config);
74      nrfx_err_t err_code;
75      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
76      if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
77      {
78          err_code = NRFX_ERROR_INVALID_STATE;
79          NRFX_LOG_WARNING("Function: %s, error code: %s.",
80                           __func__,
81                           NRFX_LOG_ERROR_STRING_GET(err_code));
82          return err_code;
83      }
84      p_cb->handler = handler;
85      p_cb->p_context = p_context;
86      configure_pins(p_instance, p_config);
87      nrf_pwm_enable(p_instance->p_registers);
88      nrf_pwm_configure(p_instance->p_registers,
89          p_config->base_clock, p_config->count_mode, p_config->top_value);
90      nrf_pwm_decoder_set(p_instance->p_registers,
91          p_config->load_mode, p_config->step_mode);
92      nrf_pwm_shorts_set(p_instance->p_registers, 0);
93      nrf_pwm_int_set(p_instance->p_registers, 0);
94      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_LOOPSDONE);
95      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_SEQEND0);
96      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_SEQEND1);
97      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_STOPPED);
98  #if defined(USE_DMA_ISSUE_WORKAROUND)
99      NRFX_IRQ_PRIORITY_SET(DMA_ISSUE_EGU_IRQn, p_config->irq_priority);
100      NRFX_IRQ_ENABLE(DMA_ISSUE_EGU_IRQn);
101  #else
102      if (p_cb->handler)
103  #endif
104      {
105          NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_registers),
106              p_config->irq_priority);
107          NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_registers));
108      }
109      p_cb->state = NRFX_DRV_STATE_INITIALIZED;
110      err_code = NRFX_SUCCESS;
111      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
112      return err_code;
113  }
<span onclick='openModal()' class='match'>114  void nrfx_pwm_uninit(nrfx_pwm_t const * p_instance)
115  {
116      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
117      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
118      NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_registers));
</span>119  #if defined(USE_DMA_ISSUE_WORKAROUND)
120      NRFX_IRQ_DISABLE(DMA_ISSUE_EGU_IRQn);
121  #endif
122      nrf_pwm_disable(p_instance->p_registers);
123      p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
124  }
125  static uint32_t start_playback(nrfx_pwm_t const * p_instance,
126                                 pwm_control_block_t * p_cb,
127                                 uint8_t               flags,
128                                 nrf_pwm_task_t        starting_task)
129  {
130      p_cb->state = NRFX_DRV_STATE_POWERED_ON;
131      p_cb->flags = flags;
132      if (p_cb->handler)
133      {
134          uint32_t int_mask = NRF_PWM_INT_LOOPSDONE_MASK |
135                              NRF_PWM_INT_STOPPED_MASK;
136  #if defined(USE_DMA_ISSUE_WORKAROUND)
137          int_mask |= NRF_PWM_INT_SEQEND0_MASK | NRF_PWM_INT_SEQEND1_MASK;
138  #else
139          if (flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ0)
140          {
141              int_mask |= NRF_PWM_INT_SEQEND0_MASK;
142          }
143          if (flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ1)
144          {
145              int_mask |= NRF_PWM_INT_SEQEND1_MASK;
146          }
147  #endif
148          if (flags & NRFX_PWM_FLAG_NO_EVT_FINISHED)
149          {
150              int_mask &= ~NRF_PWM_INT_LOOPSDONE_MASK;
151          }
152          nrf_pwm_int_set(p_instance->p_registers, int_mask);
153      }
154  #if defined(USE_DMA_ISSUE_WORKAROUND)
155      else
156      {
157          nrf_pwm_int_set(p_instance->p_registers,
158              NRF_PWM_INT_SEQEND0_MASK | NRF_PWM_INT_SEQEND1_MASK);
159      }
160  #endif
161      nrf_pwm_event_clear(p_instance->p_registers, NRF_PWM_EVENT_STOPPED);
162      if (flags & NRFX_PWM_FLAG_START_VIA_TASK)
163      {
164          uint32_t starting_task_address =
165              nrf_pwm_task_address_get(p_instance->p_registers, starting_task);
166  #if defined(USE_DMA_ISSUE_WORKAROUND)
167          p_cb->starting_task_address = starting_task_address;
168          nrf_egu_int_enable(DMA_ISSUE_EGU, nrf_egu_channel_int_get(p_instance->drv_inst_idx));
169          return nrf_egu_task_address_get(DMA_ISSUE_EGU,
170                                          nrf_egu_trigger_task_get(p_instance->drv_inst_idx));
171  #else
172          return starting_task_address;
173  #endif
174      }
175      nrf_pwm_task_trigger(p_instance->p_registers, starting_task);
176      return 0;
177  }
178  uint32_t nrfx_pwm_simple_playback(nrfx_pwm_t const *         p_instance,
179                                    nrf_pwm_sequence_t const * p_sequence,
180                                    uint16_t                   playback_count,
181                                    uint32_t                   flags)
182  {
183      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
184      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
185      NRFX_ASSERT(playback_count > 0);
186      NRFX_ASSERT(nrfx_is_in_ram(p_sequence->values.p_raw));
187      nrf_pwm_sequence_set(p_instance->p_registers, 0, p_sequence);
188      nrf_pwm_sequence_set(p_instance->p_registers, 1, p_sequence);
189      bool odd = (playback_count & 1);
190      nrf_pwm_loop_set(p_instance->p_registers,
191          (playback_count / 2) + (odd ? 1 : 0));
192      uint32_t shorts_mask;
193      if (flags & NRFX_PWM_FLAG_STOP)
194      {
195          shorts_mask = NRF_PWM_SHORT_LOOPSDONE_STOP_MASK;
196      }
197      else if (flags & NRFX_PWM_FLAG_LOOP)
198      {
199          shorts_mask = odd ? NRF_PWM_SHORT_LOOPSDONE_SEQSTART1_MASK
200                            : NRF_PWM_SHORT_LOOPSDONE_SEQSTART0_MASK;
201      }
202      else
203      {
204          shorts_mask = 0;
205      }
206      nrf_pwm_shorts_set(p_instance->p_registers, shorts_mask);
207      NRFX_LOG_INFO("Function: %s, sequence length: %d.",
208                    __func__,
209                    p_sequence->length);
210      NRFX_LOG_DEBUG("Sequence data:");
211      NRFX_LOG_HEXDUMP_DEBUG((uint8_t *)p_sequence->values.p_raw,
212                             p_sequence->length * sizeof(uint16_t));
213      return start_playback(p_instance, p_cb, flags,
214          odd ? NRF_PWM_TASK_SEQSTART1 : NRF_PWM_TASK_SEQSTART0);
215  }
216  uint32_t nrfx_pwm_complex_playback(nrfx_pwm_t const *         p_instance,
217                                     nrf_pwm_sequence_t const * p_sequence_0,
218                                     nrf_pwm_sequence_t const * p_sequence_1,
219                                     uint16_t                   playback_count,
220                                     uint32_t                   flags)
221  {
222      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
223      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
224      NRFX_ASSERT(playback_count > 0);
225      NRFX_ASSERT(nrfx_is_in_ram(p_sequence_0->values.p_raw));
226      NRFX_ASSERT(nrfx_is_in_ram(p_sequence_1->values.p_raw));
227      nrf_pwm_sequence_set(p_instance->p_registers, 0, p_sequence_0);
228      nrf_pwm_sequence_set(p_instance->p_registers, 1, p_sequence_1);
229      nrf_pwm_loop_set(p_instance->p_registers, playback_count);
230      uint32_t shorts_mask;
231      if (flags & NRFX_PWM_FLAG_STOP)
232      {
233          shorts_mask = NRF_PWM_SHORT_LOOPSDONE_STOP_MASK;
234      }
235      else if (flags & NRFX_PWM_FLAG_LOOP)
236      {
237          shorts_mask = NRF_PWM_SHORT_LOOPSDONE_SEQSTART0_MASK;
238      }
239      else
240      {
241          shorts_mask = 0;
242      }
243      nrf_pwm_shorts_set(p_instance->p_registers, shorts_mask);
244      NRFX_LOG_INFO("Function: %s, sequence 0 length: %d.",
245                    __func__,
246                    p_sequence_0->length);
247      NRFX_LOG_INFO("Function: %s, sequence 1 length: %d.",
248                    __func__,
249                    p_sequence_1->length);
250      NRFX_LOG_DEBUG("Sequence 0 data:");
251      NRFX_LOG_HEXDUMP_DEBUG(p_sequence_0->values.p_raw,
252                             p_sequence_0->length * sizeof(uint16_t));
253      NRFX_LOG_DEBUG("Sequence 1 data:");
254      NRFX_LOG_HEXDUMP_DEBUG(p_sequence_1->values.p_raw,
255                             p_sequence_1->length * sizeof(uint16_t));
256      return start_playback(p_instance, p_cb, flags, NRF_PWM_TASK_SEQSTART0);
257  }
258  bool nrfx_pwm_stop(nrfx_pwm_t const * p_instance,
259                     bool               wait_until_stopped)
260  {
261      NRFX_ASSERT(m_cb[p_instance->drv_inst_idx].state != NRFX_DRV_STATE_UNINITIALIZED);
262      bool ret_val = false;
263      nrf_pwm_shorts_set(p_instance->p_registers, 0);
264      nrf_pwm_task_trigger(p_instance->p_registers, NRF_PWM_TASK_STOP);
265      if (nrfx_pwm_is_stopped(p_instance))
266      {
267          ret_val = true;
268      }
269      else
270      {
271          do {
272              if (nrfx_pwm_is_stopped(p_instance))
273              {
274                  ret_val = true;
275                  break;
276              }
277          } while (wait_until_stopped);
278      }
279      NRFX_LOG_INFO("%s returned %d.", __func__, ret_val);
280      return ret_val;
281  }
282  bool nrfx_pwm_is_stopped(nrfx_pwm_t const * p_instance)
283  {
284      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
285      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
286      bool ret_val = false;
287      if (p_cb->state != NRFX_DRV_STATE_POWERED_ON)
288      {
289          ret_val = true;
290      }
291      if (nrf_pwm_event_check(p_instance->p_registers, NRF_PWM_EVENT_STOPPED))
292      {
293          p_cb->state = NRFX_DRV_STATE_INITIALIZED;
294          NRFX_LOG_INFO("Disabled.");
295          ret_val = true;
296      }
297      NRFX_LOG_INFO("%s returned %d.", __func__, ret_val);
298      return ret_val;
299  }
300  static void irq_handler(NRF_PWM_Type * p_pwm, pwm_control_block_t * p_cb)
301  {
302      if (nrf_pwm_event_check(p_pwm, NRF_PWM_EVENT_SEQEND0))
303      {
304          nrf_pwm_event_clear(p_pwm, NRF_PWM_EVENT_SEQEND0);
305          if ((p_cb->flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ0) && p_cb->handler)
306          {
307              p_cb->handler(NRFX_PWM_EVT_END_SEQ0, p_cb->p_context);
308          }
309      }
310      if (nrf_pwm_event_check(p_pwm, NRF_PWM_EVENT_SEQEND1))
311      {
312          nrf_pwm_event_clear(p_pwm, NRF_PWM_EVENT_SEQEND1);
313          if ((p_cb->flags & NRFX_PWM_FLAG_SIGNAL_END_SEQ1) && p_cb->handler)
314          {
315              p_cb->handler(NRFX_PWM_EVT_END_SEQ1, p_cb->p_context);
316          }
317      }
318      if (nrf_pwm_event_check(p_pwm, NRF_PWM_EVENT_LOOPSDONE))
319      {
320          nrf_pwm_event_clear(p_pwm, NRF_PWM_EVENT_LOOPSDONE);
321          if (!(p_cb->flags & NRFX_PWM_FLAG_NO_EVT_FINISHED) && p_cb->handler)
322          {
323              p_cb->handler(NRFX_PWM_EVT_FINISHED, p_cb->p_context);
324          }
325      }
326      if (nrf_pwm_event_check(p_pwm, NRF_PWM_EVENT_STOPPED))
327      {
328          nrf_pwm_event_clear(p_pwm, NRF_PWM_EVENT_STOPPED);
329          p_cb->state = NRFX_DRV_STATE_INITIALIZED;
330          if (p_cb->handler)
331          {
332              p_cb->handler(NRFX_PWM_EVT_STOPPED, p_cb->p_context);
333          }
334      }
335  }
336  #if defined(USE_DMA_ISSUE_WORKAROUND)
337  void DMA_ISSUE_EGU_IRQHandler(void)
338  {
339      for (uint8_t i = 0; i < NRFX_PWM_ENABLED_COUNT; i++)
340      {
341          nrf_egu_event_t event = nrf_egu_triggered_event_get(i);
342          if (nrf_egu_event_check(DMA_ISSUE_EGU, event))
343          {
344              nrf_egu_event_clear(DMA_ISSUE_EGU, event);
345              *(volatile uint32_t *)(m_cb[i].starting_task_address) = 1;
346          }
347      }
348  }
349  #endif
350  #if NRFX_CHECK(NRFX_PWM0_ENABLED)
351  void nrfx_pwm_0_irq_handler(void)
352  {
353      irq_handler(NRF_PWM0, &m_cb[NRFX_PWM0_INST_IDX]);
354  }
355  #endif
356  #if NRFX_CHECK(NRFX_PWM1_ENABLED)
357  void nrfx_pwm_1_irq_handler(void)
358  {
359      irq_handler(NRF_PWM1, &m_cb[NRFX_PWM1_INST_IDX]);
360  }
361  #endif
362  #if NRFX_CHECK(NRFX_PWM2_ENABLED)
363  void nrfx_pwm_2_irq_handler(void)
364  {
365      irq_handler(NRF_PWM2, &m_cb[NRFX_PWM2_INST_IDX]);
366  }
367  #endif
368  #if NRFX_CHECK(NRFX_PWM3_ENABLED)
369  void nrfx_pwm_3_irq_handler(void)
370  {
371      irq_handler(NRF_PWM3, &m_cb[NRFX_PWM3_INST_IDX]);
372  }
373  #endif
374  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_spim.c</h3>
            <pre><code>1  #include <nrfx.h>
2  #if NRFX_CHECK(NRFX_SPIM_ENABLED)
3  #if !(NRFX_CHECK(NRFX_SPIM0_ENABLED) || NRFX_CHECK(NRFX_SPIM1_ENABLED) || \
4        NRFX_CHECK(NRFX_SPIM2_ENABLED) || NRFX_CHECK(NRFX_SPIM3_ENABLED) || \
5        NRFX_CHECK(NRFX_SPIM4_ENABLED))
6  #error "No enabled SPIM instances. Check <nrfx_config.h>."
7  #endif
8  #include <nrfx_spim.h>
9  #include "prs/nrfx_prs.h"
10  #include <hal/nrf_gpio.h>
11  #define NRFX_LOG_MODULE SPIM
12  #include <nrfx_log.h>
13  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED) && \
14      ((!NRF_SPIM_HW_CSN_PRESENT) || !(NRF_SPIM_DCX_PRESENT) || !(NRF_SPIM_RXDELAY_PRESENT))
15  #error "Extended options are not available in the SoC currently in use."
16  #endif
17  #define SPIMX_LENGTH_VALIDATE(peripheral, drv_inst_idx, rx_len, tx_len) \
18      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
19       NRFX_EASYDMA_LENGTH_VALIDATE(peripheral, rx_len, tx_len))
20  #define SPIMX_HW_CSN_PRESENT_VALIDATE(peripheral, drv_inst_idx)         \
21      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
22       NRFX_CONCAT_2(peripheral, _FEATURE_HARDWARE_CSN_PRESENT))
23  #define SPIMX_DCX_PRESENT_VALIDATE(peripheral, drv_inst_idx)            \
24      (((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) && \
25      NRFX_CONCAT_2(peripheral, _FEATURE_DCX_PRESENT))
26  #define SPIMX_SUPPORTED_FREQ_VALIDATE(peripheral, drv_inst_idx, freq)                            \
27      (                                                                                            \
28      ((drv_inst_idx) == NRFX_CONCAT_3(NRFX_, peripheral, _INST_IDX)) &&                           \
29      (                                                                                            \
30          (((freq) != NRF_SPIM_FREQ_16M) && ((freq) != NRF_SPIM_FREQ_32M)) ||                      \
31          (((freq) == NRF_SPIM_FREQ_16M) && ((NRFX_CONCAT_2(peripheral, _MAX_DATARATE) >= 16))) || \
32          (((freq) == NRF_SPIM_FREQ_32M) && ((NRFX_CONCAT_2(peripheral, _MAX_DATARATE) >= 32)))    \
33      )                                                                                            \
34      )
35  #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
36  #define SPIM0_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM0, __VA_ARGS__)
37  #define SPIM0_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM0, __VA_ARGS__)
38  #define SPIM0_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM0, __VA_ARGS__)
39  #define SPIM0_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM0, __VA_ARGS__)
40  #else
41  #define SPIM0_LENGTH_VALIDATE(...)          0
42  #define SPIM0_HW_CSN_PRESENT_VALIDATE(...)  0
43  #define SPIM0_DCX_PRESENT_VALIDATE(...)     0
44  #define SPIM0_SUPPORTED_FREQ_VALIDATE(...)  0
45  #endif
46  #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
47  #define SPIM1_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM1, __VA_ARGS__)
48  #define SPIM1_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM1, __VA_ARGS__)
49  #define SPIM1_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM1, __VA_ARGS__)
50  #define SPIM1_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM1, __VA_ARGS__)
51  #else
52  #define SPIM1_LENGTH_VALIDATE(...)          0
53  #define SPIM1_HW_CSN_PRESENT_VALIDATE(...)  0
54  #define SPIM1_DCX_PRESENT_VALIDATE(...)     0
55  #define SPIM1_SUPPORTED_FREQ_VALIDATE(...)  0
56  #endif
57  #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
58  #define SPIM2_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM2, __VA_ARGS__)
59  #define SPIM2_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM2, __VA_ARGS__)
60  #define SPIM2_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM2, __VA_ARGS__)
61  #define SPIM2_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM2, __VA_ARGS__)
62  #else
63  #define SPIM2_LENGTH_VALIDATE(...)          0
64  #define SPIM2_HW_CSN_PRESENT_VALIDATE(...)  0
65  #define SPIM2_DCX_PRESENT_VALIDATE(...)     0
66  #define SPIM2_SUPPORTED_FREQ_VALIDATE(...)  0
67  #endif
68  #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
69  #define SPIM3_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM3, __VA_ARGS__)
70  #define SPIM3_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM3, __VA_ARGS__)
71  #define SPIM3_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM3, __VA_ARGS__)
72  #define SPIM3_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM3, __VA_ARGS__)
73  #else
74  #define SPIM3_LENGTH_VALIDATE(...)          0
75  #define SPIM3_HW_CSN_PRESENT_VALIDATE(...)  0
76  #define SPIM3_DCX_PRESENT_VALIDATE(...)     0
77  #define SPIM3_SUPPORTED_FREQ_VALIDATE(...)  0
78  #endif
79  #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
80  #define SPIM4_LENGTH_VALIDATE(...)          SPIMX_LENGTH_VALIDATE(SPIM4, __VA_ARGS__)
81  #define SPIM4_HW_CSN_PRESENT_VALIDATE(...)  SPIMX_HW_CSN_PRESENT_VALIDATE(SPIM4, __VA_ARGS__)
82  #define SPIM4_DCX_PRESENT_VALIDATE(...)     SPIMX_DCX_PRESENT_VALIDATE(SPIM4, __VA_ARGS__)
83  #define SPIM4_SUPPORTED_FREQ_VALIDATE(...)  SPIMX_SUPPORTED_FREQ_VALIDATE(SPIM4, __VA_ARGS__)
84  #else
85  #define SPIM4_LENGTH_VALIDATE(...)          0
86  #define SPIM4_HW_CSN_PRESENT_VALIDATE(...)  0
87  #define SPIM4_DCX_PRESENT_VALIDATE(...)     0
88  #define SPIM4_SUPPORTED_FREQ_VALIDATE(...)  0
89  #endif
90  #define SPIM_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len)  \
91      (SPIM0_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
92       SPIM1_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
93       SPIM2_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
94       SPIM3_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len) || \
95       SPIM4_LENGTH_VALIDATE(drv_inst_idx, rx_len, tx_len))
96  #define SPIM_HW_CSN_PRESENT_VALIDATE(drv_inst_idx)  \
97      (SPIM0_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
98       SPIM1_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
99       SPIM2_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
100       SPIM3_HW_CSN_PRESENT_VALIDATE(drv_inst_idx) || \
101       SPIM4_HW_CSN_PRESENT_VALIDATE(drv_inst_idx))
102  #define SPIM_DCX_PRESENT_VALIDATE(drv_inst_idx)  \
103      (SPIM0_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
104       SPIM1_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
105       SPIM2_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
106       SPIM3_DCX_PRESENT_VALIDATE(drv_inst_idx) || \
107       SPIM4_DCX_PRESENT_VALIDATE(drv_inst_idx))
108  #define SPIM_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq)  \
109      (SPIM0_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
110       SPIM1_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
111       SPIM2_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
112       SPIM3_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq) || \
113       SPIM4_SUPPORTED_FREQ_VALIDATE(drv_inst_idx, freq))
114  #if defined(NRF52840_XXAA) && (NRFX_CHECK(NRFX_SPIM3_ENABLED))
115  #define USE_WORKAROUND_FOR_ANOMALY_195
116  #endif
117  typedef struct
118  {
119      nrfx_spim_evt_handler_t handler;
120      void *                  p_context;
121      nrfx_spim_evt_t         evt;  
122      nrfx_drv_state_t        state;
123      volatile bool           transfer_in_progress;
124  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
125      bool                    use_hw_ss;
126  #endif
127      bool            ss_active_high;
128      uint8_t         ss_pin;
129      uint8_t         miso_pin;
130      uint8_t         orc;
131  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
132      size_t          tx_length;
133      size_t          rx_length;
134  #endif
135  } spim_control_block_t;
136  static spim_control_block_t m_cb[NRFX_SPIM_ENABLED_COUNT];
137  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
138  static uint32_t m_anomaly_198_preserved_value;
139  static void anomaly_198_enable(uint8_t const * p_buffer, size_t buf_len)
140  {
141      m_anomaly_198_preserved_value = *((volatile uint32_t *)0x40000E00);
142      if (buf_len == 0)
143      {
144          return;
145      }
146      uint32_t buffer_end_addr = ((uint32_t)p_buffer) + buf_len;
147      uint32_t block_addr      = ((uint32_t)p_buffer) & ~0x1FFF;
148      uint32_t block_flag      = (1UL << ((block_addr >> 13) & 0xFFFF));
149      uint32_t occupied_blocks = 0;
150      if (block_addr >= 0x20010000)
151      {
152          occupied_blocks = (1UL << 8);
153      }
154      else
155      {
156          do {
157              occupied_blocks |= block_flag;
158              block_flag <<= 1;
159              block_addr  += 0x2000;
160          } while ((block_addr < buffer_end_addr) && (block_addr < 0x20012000));
161      }
162      *((volatile uint32_t *)0x40000E00) = occupied_blocks;
163  }
164  static void anomaly_198_disable(void)
165  {
166      *((volatile uint32_t *)0x40000E00) = m_anomaly_198_preserved_value;
167  }
168  #endif 
169  nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
170                            nrfx_spim_config_t const * p_config,
171                            nrfx_spim_evt_handler_t    handler,
172                            void *                     p_context)
173  {
174      NRFX_ASSERT(p_config);
175      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
176      nrfx_err_t err_code;
177      if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
178      {
179          err_code = NRFX_ERROR_INVALID_STATE;
180          NRFX_LOG_WARNING("Function: %s, error code: %s.",
181                           __func__,
182                           NRFX_LOG_ERROR_STRING_GET(err_code));
183          return err_code;
184      }
185  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
186      if (
187          (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
188          ((p_config->use_hw_ss) &&
189           !SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx)) ||
190          ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
191           !SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
192          )
193      {
194          err_code = NRFX_ERROR_NOT_SUPPORTED;
195          NRFX_LOG_WARNING("Function: %s, error code: %s.",
196                           __func__,
197                           NRFX_LOG_ERROR_STRING_GET(err_code));
198          return err_code;
199      }
200  #endif
201      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
202  #if NRFX_CHECK(NRFX_PRS_ENABLED)
203      static nrfx_irq_handler_t const irq_handlers[NRFX_SPIM_ENABLED_COUNT] = {
204          #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
205          nrfx_spim_0_irq_handler,
206          #endif
207          #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
208          nrfx_spim_1_irq_handler,
209          #endif
210          #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
211          nrfx_spim_2_irq_handler,
212          #endif
213          #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
214          nrfx_spim_3_irq_handler,
215          #endif
216          #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
217          nrfx_spim_4_irq_handler,
218          #endif
219      };
220      if (nrfx_prs_acquire(p_instance->p_reg,
221              irq_handlers[p_instance->drv_inst_idx]) != NRFX_SUCCESS)
222      {
223          err_code = NRFX_ERROR_BUSY;
224          NRFX_LOG_WARNING("Function: %s, error code: %s.",
225                           __func__,
226                           NRFX_LOG_ERROR_STRING_GET(err_code));
227          return err_code;
228      }
229  #endif 
230      p_cb->handler = handler;
231      p_cb->p_context = p_context;
232      uint32_t mosi_pin;
233      uint32_t miso_pin;
234      if (p_config->mode <= NRF_SPIM_MODE_1)
235      {
236          nrf_gpio_pin_clear(p_config->sck_pin);
237      }
238      else
239      {
240          nrf_gpio_pin_set(p_config->sck_pin);
241      }
242      nrf_gpio_cfg(p_config->sck_pin,
243                   NRF_GPIO_PIN_DIR_OUTPUT,
244                   NRF_GPIO_PIN_INPUT_CONNECT,
245                   NRF_GPIO_PIN_NOPULL,
246                   NRF_GPIO_PIN_S0S1,
247                   NRF_GPIO_PIN_NOSENSE);
248      if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
249      {
250          mosi_pin = p_config->mosi_pin;
251          nrf_gpio_pin_clear(mosi_pin);
252          nrf_gpio_cfg_output(mosi_pin);
253      }
254      else
255      {
256          mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
257      }
258      if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
259      {
260          miso_pin = p_config->miso_pin;
261          nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
262      }
263      else
264      {
265          miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
266      }
267      p_cb->miso_pin = p_config->miso_pin;
268      p_cb->ss_pin = p_config->ss_pin;
269      if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
270      {
271          if (p_config->ss_active_high)
272          {
273              nrf_gpio_pin_clear(p_config->ss_pin);
274          }
275          else
276          {
277              nrf_gpio_pin_set(p_config->ss_pin);
278          }
279          nrf_gpio_cfg_output(p_config->ss_pin);
280  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
281          if (p_config->use_hw_ss)
282          {
283              p_cb->use_hw_ss = p_config->use_hw_ss;
284              nrf_spim_csn_configure(p_spim,
285                                     p_config->ss_pin,
286                                     (p_config->ss_active_high == true ?
287                                          NRF_SPIM_CSN_POL_HIGH : NRF_SPIM_CSN_POL_LOW),
288                                     p_config->ss_duration);
289          }
290  #endif
291          p_cb->ss_active_high = p_config->ss_active_high;
292      }
293  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
294      if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
295      {
296          nrf_gpio_pin_set(p_config->dcx_pin);
297          nrf_gpio_cfg_output(p_config->dcx_pin);
298          nrf_spim_dcx_pin_set(p_spim, p_config->dcx_pin);
299      }
300      nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
301  #endif
302      nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
303      nrf_spim_frequency_set(p_spim, p_config->frequency);
304      nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
305      nrf_spim_orc_set(p_spim, p_config->orc);
306      if (p_cb->handler)
307      {
308          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_END_MASK);
309      }
310      nrf_spim_enable(p_spim);
311      if (p_cb->handler)
312      {
313          NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
314              p_config->irq_priority);
315          NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
316      }
317      p_cb->transfer_in_progress = false;
318      p_cb->state = NRFX_DRV_STATE_INITIALIZED;
319      err_code = NRFX_SUCCESS;
320      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
321      return err_code;
322  }
323  void nrfx_spim_uninit(nrfx_spim_t const * p_instance)
324  {
325      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
326      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
327      if (p_cb->handler)
328      {
329          NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
330      }
331      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
332      if (p_cb->handler)
333      {
334          nrf_spim_int_disable(p_spim, NRF_SPIM_ALL_INTS_MASK);
335          if (p_cb->transfer_in_progress)
336          {
337              nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_STOP);
338              while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED))
339              {}
340              p_cb->transfer_in_progress = false;
341          }
342      }
343      if (p_cb->miso_pin != NRFX_SPIM_PIN_NOT_USED)
344      {
345          nrf_gpio_cfg_default(p_cb->miso_pin);
346      }
347      nrf_spim_disable(p_spim);
348  #ifdef USE_WORKAROUND_FOR_ANOMALY_195
349      if (p_spim == NRF_SPIM3)
350      {
351          *(volatile uint32_t *)0x4002F004 = 1;
352      }
353  #endif
354  #if NRFX_CHECK(NRFX_PRS_ENABLED)
355      nrfx_prs_release(p_instance->p_reg);
356  #endif
357      p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
358  }
359  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
360  nrfx_err_t nrfx_spim_xfer_dcx(nrfx_spim_t const *           p_instance,
361                                nrfx_spim_xfer_desc_t const * p_xfer_desc,
362                                uint32_t                      flags,
363                                uint8_t                       cmd_length)
364  {
365      NRFX_ASSERT(cmd_length <= NRF_SPIM_DCX_CNT_ALL_CMD);
366      nrf_spim_dcx_cnt_set((NRF_SPIM_Type *)p_instance->p_reg, cmd_length);
367      return nrfx_spim_xfer(p_instance, p_xfer_desc, 0);
368  }
369  #endif
370  static void finish_transfer(spim_control_block_t * p_cb)
371  {
372      if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
373      {
374  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
375          if (!p_cb->use_hw_ss)
376  #endif
377          {
378              if (p_cb->ss_active_high)
379              {
380                  nrf_gpio_pin_clear(p_cb->ss_pin);
381              }
382              else
383              {
384                  nrf_gpio_pin_set(p_cb->ss_pin);
385              }
386          }
387      }
388      p_cb->transfer_in_progress = false;
389      p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
390      p_cb->handler(&p_cb->evt, p_cb->p_context);
391  }
392  static void spim_int_enable(NRF_SPIM_Type * p_spim, bool enable)
393  {
394      if (!enable)
395      {
396          nrf_spim_int_disable(p_spim, NRF_SPIM_INT_END_MASK);
397      }
398      else
399      {
400          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_END_MASK);
401      }
402  }
403  static void spim_list_enable_handle(NRF_SPIM_Type * p_spim, uint32_t flags)
404  {
405      if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
406      {
407          nrf_spim_tx_list_enable(p_spim);
408      }
409      else
410      {
411          nrf_spim_tx_list_disable(p_spim);
412      }
413      if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
414      {
415          nrf_spim_rx_list_enable(p_spim);
416      }
417      else
418      {
419          nrf_spim_rx_list_disable(p_spim);
420      }
421  }
422  static nrfx_err_t spim_xfer(NRF_SPIM_Type               * p_spim,
423                              spim_control_block_t        * p_cb,
424                              nrfx_spim_xfer_desc_t const * p_xfer_desc,
425                              uint32_t                      flags)
426  {
427      nrfx_err_t err_code;
428      if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
429          (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
430      {
431          p_cb->transfer_in_progress = false;
432          err_code = NRFX_ERROR_INVALID_ADDR;
433          NRFX_LOG_WARNING("Function: %s, error code: %s.",
434                           __func__,
435                           NRFX_LOG_ERROR_STRING_GET(err_code));
436          return err_code;
437      }
438  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
439      p_cb->tx_length = 0;
440      p_cb->rx_length = 0;
441  #endif
442      nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
443      nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
444  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
445      if (p_spim == NRF_SPIM3)
446      {
447          anomaly_198_enable(p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
448      }
449  #endif
450      nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
451      spim_list_enable_handle(p_spim, flags);
452      if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
453      {
454          nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
455      }
456  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
457      if (flags & NRFX_SPIM_FLAG_HOLD_XFER)
458      {
459          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_STARTED);
460          p_cb->tx_length = p_xfer_desc->tx_length;
461          p_cb->rx_length = p_xfer_desc->rx_length;
462          nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, 0);
463          nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, 0);
464          nrf_spim_int_enable(p_spim, NRF_SPIM_INT_STARTED_MASK);
465      }
466  #endif
467      if (!p_cb->handler)
468      {
469          while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END)){}
470  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
471          if (p_spim == NRF_SPIM3)
472          {
473              anomaly_198_disable();
474          }
475  #endif
476          if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
477          {
478  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
479              if (!p_cb->use_hw_ss)
480  #endif
481              {
482                  if (p_cb->ss_active_high)
483                  {
484                      nrf_gpio_pin_clear(p_cb->ss_pin);
485                  }
486                  else
487                  {
488                      nrf_gpio_pin_set(p_cb->ss_pin);
489                  }
490              }
491          }
492      }
493      else
494      {
495          spim_int_enable(p_spim, !(flags & NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER));
496      }
497      err_code = NRFX_SUCCESS;
498      NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
499      return err_code;
500  }
501  nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
502                            nrfx_spim_xfer_desc_t const * p_xfer_desc,
503                            uint32_t                      flags)
504  {
505      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
506      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
507      NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
508      NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
509      NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
510                                       p_xfer_desc->rx_length,
511                                       p_xfer_desc->tx_length));
512      nrfx_err_t err_code = NRFX_SUCCESS;
513      if (p_cb->transfer_in_progress)
514      {
515          err_code = NRFX_ERROR_BUSY;
516          NRFX_LOG_WARNING("Function: %s, error code: %s.",
517                           __func__,
518                           NRFX_LOG_ERROR_STRING_GET(err_code));
519          return err_code;
520      }
521      else
522      {
523          if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
524                                          NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
525          {
526              p_cb->transfer_in_progress = true;
527          }
528      }
529      p_cb->evt.xfer_desc = *p_xfer_desc;
530      if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
531      {
532  #if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
533          if (!p_cb->use_hw_ss)
534  #endif
535          {
536              if (p_cb->ss_active_high)
537              {
538                  nrf_gpio_pin_set(p_cb->ss_pin);
539              }
540              else
541              {
542                  nrf_gpio_pin_clear(p_cb->ss_pin);
543              }
544          }
545      }
546      return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
547  }
<span onclick='openModal()' class='match'>548  void nrfx_spim_abort(nrfx_spim_t const * p_instance)
549  {
550      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
551      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
552      nrf_spim_task_trigger(p_instance->p_reg, NRF_SPIM_TASK_STOP);
</span>553      while (!nrf_spim_event_check(p_instance->p_reg, NRF_SPIM_EVENT_STOPPED))
554      {}
555      p_cb->transfer_in_progress = false;
556  }
557  uint32_t nrfx_spim_start_task_get(nrfx_spim_t const * p_instance)
558  {
559      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
560      return nrf_spim_task_address_get(p_spim, NRF_SPIM_TASK_START);
561  }
562  uint32_t nrfx_spim_end_event_get(nrfx_spim_t const * p_instance)
563  {
564      NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
565      return nrf_spim_event_address_get(p_spim, NRF_SPIM_EVENT_END);
566  }
567  static void irq_handler(NRF_SPIM_Type * p_spim, spim_control_block_t * p_cb)
568  {
569  #if NRFX_CHECK(NRFX_SPIM_NRF52_ANOMALY_109_WORKAROUND_ENABLED)
570      if ((nrf_spim_int_enable_check(p_spim, NRF_SPIM_INT_STARTED_MASK)) &&
571          (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STARTED)) )
572      {
573          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_STARTED);
574          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
575          NRFX_ASSERT(p_spim->TXD.MAXCNT == 0);
576          p_spim->TXD.MAXCNT = p_cb->tx_length;
577          NRFX_ASSERT(p_spim->RXD.MAXCNT == 0);
578          p_spim->RXD.MAXCNT = p_cb->rx_length;
579          nrf_spim_int_disable(p_spim, NRF_SPIM_INT_STARTED_MASK);
580          nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
581          return;
582      }
583  #endif
584      if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
585      {
586  #if NRFX_CHECK(NRFX_SPIM3_NRF52840_ANOMALY_198_WORKAROUND_ENABLED)
587          if (p_spim == NRF_SPIM3)
588          {
589              anomaly_198_disable();
590          }
591  #endif
592          nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
593          NRFX_ASSERT(p_cb->handler);
594          NRFX_LOG_DEBUG("Event: NRF_SPIM_EVENT_END.");
595          finish_transfer(p_cb);
596      }
597  }
598  #if NRFX_CHECK(NRFX_SPIM0_ENABLED)
599  void nrfx_spim_0_irq_handler(void)
600  {
601      irq_handler(NRF_SPIM0, &m_cb[NRFX_SPIM0_INST_IDX]);
602  }
603  #endif
604  #if NRFX_CHECK(NRFX_SPIM1_ENABLED)
605  void nrfx_spim_1_irq_handler(void)
606  {
607      irq_handler(NRF_SPIM1, &m_cb[NRFX_SPIM1_INST_IDX]);
608  }
609  #endif
610  #if NRFX_CHECK(NRFX_SPIM2_ENABLED)
611  void nrfx_spim_2_irq_handler(void)
612  {
613      irq_handler(NRF_SPIM2, &m_cb[NRFX_SPIM2_INST_IDX]);
614  }
615  #endif
616  #if NRFX_CHECK(NRFX_SPIM3_ENABLED)
617  void nrfx_spim_3_irq_handler(void)
618  {
619      irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
620  }
621  #endif
622  #if NRFX_CHECK(NRFX_SPIM4_ENABLED)
623  void nrfx_spim_4_irq_handler(void)
624  {
625      irq_handler(NRF_SPIM4, &m_cb[NRFX_SPIM4_INST_IDX]);
626  }
627  #endif
628  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_pwm.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Adafruit_nRF52_Arduino-MDEwOlJlcG9zaXRvcnk3NDM1NDcyOQ==-flat-nrfx_spim.c</div>
                </div>
                <div class="column column_space"><pre><code>114  void nrfx_pwm_uninit(nrfx_pwm_t const * p_instance)
115  {
116      pwm_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
117      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
118      NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_registers));
</pre></code></div>
                <div class="column column_space"><pre><code>548  void nrfx_spim_abort(nrfx_spim_t const * p_instance)
549  {
550      spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
551      NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
552      nrf_spim_task_trigger(p_instance->p_reg, NRF_SPIM_TASK_STOP);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    