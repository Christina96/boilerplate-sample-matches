
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 44, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-defrag.c</h3>
            <pre><code>1  #include "server.h"
2  #include <time.h>
3  #include <assert.h>
4  #include <stddef.h>
5  #ifdef HAVE_DEFRAG
6  int je_get_defrag_hint(void* ptr, int *bin_util, int *run_util);
7  void defragDictBucketCallback(void *privdata, dictEntry **bucketref);
8  dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, uint64_t hash, PORT_LONG *defragged);
9  void* activeDefragAlloc(void *ptr) {
10      int bin_util, run_util;
11      size_t size;
12      void *newptr;
13      if(!je_get_defrag_hint(ptr, &bin_util, &run_util)) {
14          server.stat_active_defrag_misses++;
15          return NULL;
16      }
17      if (run_util > bin_util || run_util == 1<<16) {
18          server.stat_active_defrag_misses++;
19          return NULL;
20      }
21      size = zmalloc_size(ptr);
22      newptr = zmalloc_no_tcache(size);
23      memcpy(newptr, ptr, size);
24      zfree_no_tcache(ptr);
25      return newptr;
26  }
27  sds activeDefragSds(sds sdsptr) {
28      void* ptr = sdsAllocPtr(sdsptr);
29      void* newptr = activeDefragAlloc(ptr);
30      if (newptr) {
31          size_t offset = sdsptr - (char*)ptr;
32          sdsptr = (char*)newptr + offset;
33          return sdsptr;
34      }
35      return NULL;
36  }
37  robj *activeDefragStringOb(robj* ob, PORT_LONG *defragged) {
38      robj *ret = NULL;
39      if (ob->refcount!=1)
40          return NULL;
41      if (ob->type!=OBJ_STRING || ob->encoding!=OBJ_ENCODING_EMBSTR) {
42          if ((ret = activeDefragAlloc(ob))) {
43              ob = ret;
44              (*defragged)++;
45          }
46      }
47      if (ob->type == OBJ_STRING) {
48          if(ob->encoding==OBJ_ENCODING_RAW) {
49              sds newsds = activeDefragSds((sds)ob->ptr);
50              if (newsds) {
51                  ob->ptr = newsds;
52                  (*defragged)++;
53              }
54          } else if (ob->encoding==OBJ_ENCODING_EMBSTR) {
55              PORT_LONG ofs = (intptr_t)ob->ptr - (intptr_t)ob;
56              if ((ret = activeDefragAlloc(ob))) {
57                  ret->ptr = (void*)((intptr_t)ret + ofs);
58                  (*defragged)++;
59              }
60          } else if (ob->encoding!=OBJ_ENCODING_INT) {
61              serverPanic("Unknown string encoding");
62          }
63      }
64      return ret;
65  }
66  PORT_LONG dictIterDefragEntry(dictIterator *iter) {
67      PORT_LONG defragged = 0;
68      dictht *ht;
69      if (iter->nextEntry) {
70          dictEntry *newde = activeDefragAlloc(iter->nextEntry);
71          if (newde) {
72              defragged++;
73              iter->nextEntry = newde;
74              iter->entry->next = newde;
75          }
76      }
77      ht = &iter->d->ht[iter->table];
78      if (ht->table[iter->index] == iter->entry) {
79          dictEntry *newde = activeDefragAlloc(iter->entry);
80          if (newde) {
81              iter->entry = newde;
82              ht->table[iter->index] = newde;
83              defragged++;
84          }
85      }
86      return defragged;
87  }
88  PORT_LONG dictDefragTables(dict* d) {
89      dictEntry **newtable;
90      PORT_LONG defragged = 0;
91      newtable = activeDefragAlloc(d->ht[0].table);
92      if (newtable)
93          defragged++, d->ht[0].table = newtable;
94      if (d->ht[1].table) {
95          newtable = activeDefragAlloc(d->ht[1].table);
96          if (newtable)
97              defragged++, d->ht[1].table = newtable;
98      }
99      return defragged;
100  }
101  void zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnode, zskiplistNode **update) {
102      int i;
103      for (i = 0; i < zsl->level; i++) {
104          if (update[i]->level[i].forward == oldnode)
105              update[i]->level[i].forward = newnode;
106      }
107      serverAssert(zsl->header!=oldnode);
108      if (newnode->level[0].forward) {
109          serverAssert(newnode->level[0].forward->backward==oldnode);
110          newnode->level[0].forward->backward = newnode;
111      } else {
112          serverAssert(zsl->tail==oldnode);
113          zsl->tail = newnode;
114      }
115  }
116  double *zslDefrag(zskiplist *zsl, double score, sds oldele, sds newele) {
117      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x, *newx;
118      int i;
119      sds ele = newele? newele: oldele;
120      x = zsl->header;
121      for (i = zsl->level-1; i >= 0; i--) {
122          while (x->level[i].forward &&
123              x->level[i].forward->ele != oldele && &bsol;* make sure not to access the
124                                                       ->obj pointer if it matches
125                                                       oldele */
126              (x->level[i].forward->score < score ||
127                  (x->level[i].forward->score == score &&
128                  sdscmp(x->level[i].forward->ele,ele) < 0)))
129              x = x->level[i].forward;
130          update[i] = x;
131      }
132      x = x->level[0].forward;
133      serverAssert(x && score == x->score && x->ele==oldele);
134      if (newele)
135          x->ele = newele;
136      newx = activeDefragAlloc(x);
137      if (newx) {
138          zslUpdateNode(zsl, x, newx, update);
139          return &newx->score;
140      }
141      return NULL;
142  }
143  PORT_LONG activeDefragZsetEntry(zset *zs, dictEntry *de) {
144      sds newsds;
145      double* newscore;
146      PORT_LONG defragged = 0;
147      sds sdsele = dictGetKey(de);
148      if ((newsds = activeDefragSds(sdsele)))
149          defragged++, de->key = newsds;
150      newscore = zslDefrag(zs->zsl, *(double*)dictGetVal(de), sdsele, newsds);
151      if (newscore) {
152          dictSetVal(zs->dict, de, newscore);
153          defragged++;
154      }
155      return defragged;
156  }
157  #define DEFRAG_SDS_DICT_NO_VAL 0
158  #define DEFRAG_SDS_DICT_VAL_IS_SDS 1
159  #define DEFRAG_SDS_DICT_VAL_IS_STROB 2
160  #define DEFRAG_SDS_DICT_VAL_VOID_PTR 3
161  PORT_LONG activeDefragSdsDict(dict* d, int val_type) {
162      dictIterator *di;
163      dictEntry *de;
164      PORT_LONG defragged = 0;
165      di = dictGetIterator(d);
166      while((de = dictNext(di)) != NULL) {
167          sds sdsele = dictGetKey(de), newsds;
168          if ((newsds = activeDefragSds(sdsele)))
169              de->key = newsds, defragged++;
170          if (val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {
171              sdsele = dictGetVal(de);
172              if ((newsds = activeDefragSds(sdsele)))
173                  de->v.val = newsds, defragged++;
174          } else if (val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {
175              robj *newele, *ele = dictGetVal(de);
176              if ((newele = activeDefragStringOb(ele, &defragged)))
177                  de->v.val = newele;
178          } else if (val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {
179              void *newptr, *ptr = dictGetVal(de);
180              if ((newptr = activeDefragAlloc(ptr)))
181                  de->v.val = newptr, defragged++;
182          }
183          defragged += dictIterDefragEntry(di);
184      }
185      dictReleaseIterator(di);
186      return defragged;
187  }
188  PORT_LONG activeDefragList(list *l, int val_type) {
189      PORT_LONG defragged = 0;
190      listNode *ln, *newln;
191      for (ln = l->head; ln; ln = ln->next) {
192          if ((newln = activeDefragAlloc(ln))) {
193              if (newln->prev)
194                  newln->prev->next = newln;
195              else
196                  l->head = newln;
197              if (newln->next)
198                  newln->next->prev = newln;
199              else
200                  l->tail = newln;
201              ln = newln;
202              defragged++;
203          }
204          if (val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {
205              sds newsds, sdsele = ln->value;
206              if ((newsds = activeDefragSds(sdsele)))
207                  ln->value = newsds, defragged++;
208          } else if (val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {
209              robj *newele, *ele = ln->value;
210              if ((newele = activeDefragStringOb(ele, &defragged)))
211                  ln->value = newele;
212          } else if (val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {
213              void *newptr, *ptr = ln->value;
214              if ((newptr = activeDefragAlloc(ptr)))
215                  ln->value = newptr, defragged++;
216          }
217      }
218      return defragged;
219  }
220  PORT_LONG activeDefragSdsListAndDict(list *l, dict *d, int dict_val_type) {
221      PORT_LONG defragged = 0;
222      sds newsds, sdsele;
223      listNode *ln, *newln;
224      dictIterator *di;
225      dictEntry *de;
226      for (ln = l->head; ln; ln = ln->next) {
227          if ((newln = activeDefragAlloc(ln))) {
228              if (newln->prev)
229                  newln->prev->next = newln;
230              else
231                  l->head = newln;
232              if (newln->next)
233                  newln->next->prev = newln;
234              else
235                  l->tail = newln;
236              ln = newln;
237              defragged++;
238          }
239          sdsele = ln->value;
240          if ((newsds = activeDefragSds(sdsele))) {
241              uint64_t hash = dictGetHash(d, newsds);
242              replaceSateliteDictKeyPtrAndOrDefragDictEntry(d, sdsele, newsds, hash, &defragged);
243              ln->value = newsds;
244              defragged++;
245          }
246      }
247      di = dictGetIterator(d);
248      while((de = dictNext(di)) != NULL) {
249          if (dict_val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {
250              sds newsds, sdsele = dictGetVal(de);
251              if ((newsds = activeDefragSds(sdsele)))
252                  de->v.val = newsds, defragged++;
253          } else if (dict_val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {
254              robj *newele, *ele = dictGetVal(de);
255              if ((newele = activeDefragStringOb(ele, &defragged)))
256                  de->v.val = newele, defragged++;
257          } else if (dict_val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {
258              void *newptr, *ptr = ln->value;
259              if ((newptr = activeDefragAlloc(ptr)))
260                  ln->value = newptr, defragged++;
261          }
262          defragged += dictIterDefragEntry(di);
263      }
264      dictReleaseIterator(di);
265      return defragged;
266  }
267  dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, uint64_t hash, PORT_LONG *defragged) {
268      dictEntry **deref = dictFindEntryRefByPtrAndHash(d, oldkey, hash);
269      if (deref) {
270          dictEntry *de = *deref;
271          dictEntry *newde = activeDefragAlloc(de);
272          if (newde) {
273              de = *deref = newde;
274              (*defragged)++;
275          }
276          if (newkey)
277              de->key = newkey;
278          return de;
279      }
280      return NULL;
281  }
282  PORT_LONG activeDefragQuickListNodes(quicklist *ql) {
283      quicklistNode *node = ql->head, *newnode;
284      PORT_LONG defragged = 0;
285      unsigned char *newzl;
286      while (node) {
287          if ((newnode = activeDefragAlloc(node))) {
288              if (newnode->prev)
289                  newnode->prev->next = newnode;
290              else
291                  ql->head = newnode;
292              if (newnode->next)
293                  newnode->next->prev = newnode;
294              else
295                  ql->tail = newnode;
296              node = newnode;
297              defragged++;
298          }
299          if ((newzl = activeDefragAlloc(node->zl)))
300              defragged++, node->zl = newzl;
301          node = node->next;
302      }
303      return defragged;
304  }
305  void defragLater(redisDb *db, dictEntry *kde) {
306      sds key = sdsdup(dictGetKey(kde));
307      listAddNodeTail(db->defrag_later, key);
308  }
309  PORT_LONG scanLaterList(robj *ob) {
310      quicklist *ql = ob->ptr;
311      if (ob->type != OBJ_LIST || ob->encoding != OBJ_ENCODING_QUICKLIST)
312          return 0;
313      server.stat_active_defrag_scanned+=ql->len;
314      return activeDefragQuickListNodes(ql);
315  }
316  typedef struct {
317      zset *zs;
318      PORT_LONG defragged;
319  } scanLaterZsetData;
320  void scanLaterZsetCallback(void *privdata, const dictEntry *_de) {
321      dictEntry *de = (dictEntry*)_de;
322      scanLaterZsetData *data = privdata;
323      data->defragged += activeDefragZsetEntry(data->zs, de);
324      server.stat_active_defrag_scanned++;
325  }
326  PORT_LONG scanLaterZset(robj *ob, PORT_ULONG *cursor) {
327      if (ob->type != OBJ_ZSET || ob->encoding != OBJ_ENCODING_SKIPLIST)
328          return 0;
329      zset *zs = (zset*)ob->ptr;
330      dict *d = zs->dict;
331      scanLaterZsetData data = {zs, 0};
332      *cursor = dictScan(d, *cursor, scanLaterZsetCallback, defragDictBucketCallback, &data);
333      return data.defragged;
334  }
335  void scanLaterSetCallback(void *privdata, const dictEntry *_de) {
336      dictEntry *de = (dictEntry*)_de;
337      PORT_LONG *defragged = privdata;
338      sds sdsele = dictGetKey(de), newsds;
339      if ((newsds = activeDefragSds(sdsele)))
340          (*defragged)++, de->key = newsds;
341      server.stat_active_defrag_scanned++;
342  }
343  PORT_LONG scanLaterSet(robj *ob, PORT_ULONG *cursor) {
344      PORT_LONG defragged = 0;
345      if (ob->type != OBJ_SET || ob->encoding != OBJ_ENCODING_HT)
346          return 0;
347      dict *d = ob->ptr;
348      *cursor = dictScan(d, *cursor, scanLaterSetCallback, defragDictBucketCallback, &defragged);
349      return defragged;
350  }
351  void scanLaterHashCallback(void *privdata, const dictEntry *_de) {
352      dictEntry *de = (dictEntry*)_de;
353      PORT_LONG *defragged = privdata;
354      sds sdsele = dictGetKey(de), newsds;
355      if ((newsds = activeDefragSds(sdsele)))
356          (*defragged)++, de->key = newsds;
357      sdsele = dictGetVal(de);
358      if ((newsds = activeDefragSds(sdsele)))
359          (*defragged)++, de->v.val = newsds;
360      server.stat_active_defrag_scanned++;
361  }
362  PORT_LONG scanLaterHash(robj *ob, PORT_ULONG *cursor) {
363      PORT_LONG defragged = 0;
364      if (ob->type != OBJ_HASH || ob->encoding != OBJ_ENCODING_HT)
365          return 0;
366      dict *d = ob->ptr;
367      *cursor = dictScan(d, *cursor, scanLaterHashCallback, defragDictBucketCallback, &defragged);
368      return defragged;
369  }
370  PORT_LONG defragQuicklist(redisDb *db, dictEntry *kde) {
371      robj *ob = dictGetVal(kde);
372      PORT_LONG defragged = 0;
373      quicklist *ql = ob->ptr, *newql;
374      serverAssert(ob->type == OBJ_LIST && ob->encoding == OBJ_ENCODING_QUICKLIST);
375      if ((newql = activeDefragAlloc(ql)))
376          defragged++, ob->ptr = ql = newql;
377      if (ql->len > server.active_defrag_max_scan_fields)
378          defragLater(db, kde);
379      else
380          defragged += activeDefragQuickListNodes(ql);
381      return defragged;
382  }
383  PORT_LONG defragZsetSkiplist(redisDb *db, dictEntry *kde) {
384      robj *ob = dictGetVal(kde);
385      PORT_LONG defragged = 0;
386      zset *zs = (zset*)ob->ptr;
387      zset *newzs;
388      zskiplist *newzsl;
389      dict *newdict;
390      dictEntry *de;
391      struct zskiplistNode *newheader;
392      serverAssert(ob->type == OBJ_ZSET && ob->encoding == OBJ_ENCODING_SKIPLIST);
393      if ((newzs = activeDefragAlloc(zs)))
394          defragged++, ob->ptr = zs = newzs;
395      if ((newzsl = activeDefragAlloc(zs->zsl)))
396          defragged++, zs->zsl = newzsl;
397      if ((newheader = activeDefragAlloc(zs->zsl->header)))
398          defragged++, zs->zsl->header = newheader;
399      if (dictSize(zs->dict) > server.active_defrag_max_scan_fields)
400          defragLater(db, kde);
401      else {
402          dictIterator *di = dictGetIterator(zs->dict);
403          while((de = dictNext(di)) != NULL) {
404              defragged += activeDefragZsetEntry(zs, de);
405          }
406          dictReleaseIterator(di);
407      }
408      if ((newdict = activeDefragAlloc(zs->dict)))
409          defragged++, zs->dict = newdict;
410      defragged += dictDefragTables(zs->dict);
411      return defragged;
412  }
413  PORT_LONG defragHash(redisDb *db, dictEntry *kde) {
414      PORT_LONG defragged = 0;
415      robj *ob = dictGetVal(kde);
416      dict *d, *newd;
417      serverAssert(ob->type == OBJ_HASH && ob->encoding == OBJ_ENCODING_HT);
418      d = ob->ptr;
419      if (dictSize(d) > server.active_defrag_max_scan_fields)
420          defragLater(db, kde);
421      else
422          defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_VAL_IS_SDS);
423      if ((newd = activeDefragAlloc(ob->ptr)))
424          defragged++, ob->ptr = newd;
425      defragged += dictDefragTables(ob->ptr);
426      return defragged;
427  }
428  PORT_LONG defragSet(redisDb *db, dictEntry *kde) {
429      PORT_LONG defragged = 0;
430      robj *ob = dictGetVal(kde);
431      dict *d, *newd;
432      serverAssert(ob->type == OBJ_SET && ob->encoding == OBJ_ENCODING_HT);
433      d = ob->ptr;
434      if (dictSize(d) > server.active_defrag_max_scan_fields)
435          defragLater(db, kde);
436      else
<span onclick='openModal()' class='match'>437          defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_NO_VAL);
438      if ((newd = activeDefragAlloc(ob->ptr)))
439          defragged++, ob->ptr = newd;
440      defragged += dictDefragTables(ob->ptr);
441      return defragged;
442  }
443  int defragRaxNode(raxNode **noderef) {
</span>444      raxNode *newnode = activeDefragAlloc(*noderef);
445      if (newnode) {
446          *noderef = newnode;
447          return 1;
448      }
449      return 0;
450  }
451  int scanLaterStraemListpacks(robj *ob, PORT_ULONG *cursor, PORT_LONGLONG endtime, PORT_LONGLONG *defragged) {
452      static unsigned char last[sizeof(streamID)];
453      raxIterator ri;
454      PORT_LONG iterations = 0;
455      if (ob->type != OBJ_STREAM || ob->encoding != OBJ_ENCODING_STREAM) {
456          *cursor = 0;
457          return 0;
458      }
459      stream *s = ob->ptr;
460      raxStart(&ri,s->rax);
461      if (*cursor == 0) {
462          defragRaxNode(&s->rax->head);
463          ri.node_cb = defragRaxNode;
464          raxSeek(&ri,"^",NULL,0);
465      } else {
466          if (!raxSeek(&ri,">", last, sizeof(last))) {
467              *cursor = 0;
468              return 0;
469          }
470          ri.node_cb = defragRaxNode;
471      }
472      (*cursor)++;
473      while (raxNext(&ri)) {
474          void *newdata = activeDefragAlloc(ri.data);
475          if (newdata)
476              raxSetData(ri.node, ri.data=newdata), (*defragged)++;
477          if (++iterations > 16) {
478              if (ustime() > endtime) {
479                  serverAssert(ri.key_len==sizeof(last));
480                  memcpy(last,ri.key,ri.key_len);
481                  raxStop(&ri);
482                  return 1;
483              }
484              iterations = 0;
485          }
486      }
487      raxStop(&ri);
488      *cursor = 0;
489      return 0;
490  }
491  typedef void *(raxDefragFunction)(raxIterator *ri, void *privdata, PORT_LONG *defragged);
492  PORT_LONG defragRadixTree(rax **raxref, int defrag_data, raxDefragFunction *element_cb, void *element_cb_data) {
493      PORT_LONG defragged = 0;
494      raxIterator ri;
495      rax* rax;
496      if ((rax = activeDefragAlloc(*raxref)))
497          defragged++, *raxref = rax;
498      rax = *raxref;
499      raxStart(&ri,rax);
500      ri.node_cb = defragRaxNode;
501      defragRaxNode(&rax->head);
502      raxSeek(&ri,"^",NULL,0);
503      while (raxNext(&ri)) {
504          void *newdata = NULL;
505          if (element_cb)
506              newdata = element_cb(&ri, element_cb_data, &defragged);
507          if (defrag_data && !newdata)
508              newdata = activeDefragAlloc(ri.data);
509          if (newdata)
510              raxSetData(ri.node, ri.data=newdata), defragged++;
511      }
512      raxStop(&ri);
513      return defragged;
514  }
515  typedef struct {
516      streamCG *cg;
517      streamConsumer *c;
518  } PendingEntryContext;
519  void* defragStreamConsumerPendingEntry(raxIterator *ri, void *privdata, PORT_LONG *defragged) {
520      UNUSED(defragged);
521      PendingEntryContext *ctx = privdata;
522      streamNACK *nack = ri->data, *newnack;
523      nack->consumer = ctx->c; &bsol;* update nack pointer to consumer */
524      newnack = activeDefragAlloc(nack);
525      if (newnack) {
526          void *prev;
527          raxInsert(ctx->cg->pel, ri->key, ri->key_len, newnack, &prev);
528          serverAssert(prev==nack);
529      }
530      return newnack;
531  }
532  void* defragStreamConsumer(raxIterator *ri, void *privdata, PORT_LONG *defragged) {
533      streamConsumer *c = ri->data;
534      streamCG *cg = privdata;
535      void *newc = activeDefragAlloc(c);
536      if (newc) {
537          c = newc;
538      }
539      sds newsds = activeDefragSds(c->name);
540      if (newsds)
541          (*defragged)++, c->name = newsds;
542      if (c->pel) {
543          PendingEntryContext pel_ctx = {cg, c};
544          *defragged += defragRadixTree(&c->pel, 0, defragStreamConsumerPendingEntry, &pel_ctx);
545      }
546      return newc; &bsol;* returns NULL if c was not defragged */
547  }
548  void* defragStreamConsumerGroup(raxIterator *ri, void *privdata, PORT_LONG *defragged) {
549      streamCG *cg = ri->data;
550      UNUSED(privdata);
551      if (cg->consumers)
552          *defragged += defragRadixTree(&cg->consumers, 0, defragStreamConsumer, cg);
553      if (cg->pel)
554          *defragged += defragRadixTree(&cg->pel, 0, NULL, NULL);
555      return NULL;
556  }
557  PORT_LONG defragStream(redisDb *db, dictEntry *kde) {
558      PORT_LONG defragged = 0;
559      robj *ob = dictGetVal(kde);
560      serverAssert(ob->type == OBJ_STREAM && ob->encoding == OBJ_ENCODING_STREAM);
561      stream *s = ob->ptr, *news;
562      if ((news = activeDefragAlloc(s)))
563          defragged++, ob->ptr = s = news;
564      if (raxSize(s->rax) > server.active_defrag_max_scan_fields) {
565          rax *newrax = activeDefragAlloc(s->rax);
566          if (newrax)
567              defragged++, s->rax = newrax;
568          defragLater(db, kde);
569      } else
570          defragged += defragRadixTree(&s->rax, 1, NULL, NULL);
571      if (s->cgroups)
572          defragged += defragRadixTree(&s->cgroups, 1, defragStreamConsumerGroup, NULL);
573      return defragged;
574  }
575  PORT_LONG defragKey(redisDb *db, dictEntry *de) {
576      sds keysds = dictGetKey(de);
577      robj *newob, *ob;
578      unsigned char *newzl;
579      PORT_LONG defragged = 0;
580      sds newsds;
581      newsds = activeDefragSds(keysds);
582      if (newsds)
583          defragged++, de->key = newsds;
584      if (dictSize(db->expires)) {
585          uint64_t hash = dictGetHash(db->dict, de->key);
586          replaceSateliteDictKeyPtrAndOrDefragDictEntry(db->expires, keysds, newsds, hash, &defragged);
587      }
588      ob = dictGetVal(de);
589      if ((newob = activeDefragStringOb(ob, &defragged))) {
590          de->v.val = newob;
591          ob = newob;
592      }
593      if (ob->type == OBJ_STRING) {
594      } else if (ob->type == OBJ_LIST) {
595          if (ob->encoding == OBJ_ENCODING_QUICKLIST) {
596              defragged += defragQuicklist(db, de);
597          } else if (ob->encoding == OBJ_ENCODING_ZIPLIST) {
598              if ((newzl = activeDefragAlloc(ob->ptr)))
599                  defragged++, ob->ptr = newzl;
600          } else {
601              serverPanic("Unknown list encoding");
602          }
603      } else if (ob->type == OBJ_SET) {
604          if (ob->encoding == OBJ_ENCODING_HT) {
605              defragged += defragSet(db, de);
606          } else if (ob->encoding == OBJ_ENCODING_INTSET) {
607              intset *newis, *is = ob->ptr;
608              if ((newis = activeDefragAlloc(is)))
609                  defragged++, ob->ptr = newis;
610          } else {
611              serverPanic("Unknown set encoding");
612          }
613      } else if (ob->type == OBJ_ZSET) {
614          if (ob->encoding == OBJ_ENCODING_ZIPLIST) {
615              if ((newzl = activeDefragAlloc(ob->ptr)))
616                  defragged++, ob->ptr = newzl;
617          } else if (ob->encoding == OBJ_ENCODING_SKIPLIST) {
618              defragged += defragZsetSkiplist(db, de);
619          } else {
620              serverPanic("Unknown sorted set encoding");
621          }
622      } else if (ob->type == OBJ_HASH) {
623          if (ob->encoding == OBJ_ENCODING_ZIPLIST) {
624              if ((newzl = activeDefragAlloc(ob->ptr)))
625                  defragged++, ob->ptr = newzl;
626          } else if (ob->encoding == OBJ_ENCODING_HT) {
627              defragged += defragHash(db, de);
628          } else {
629              serverPanic("Unknown hash encoding");
630          }
631      } else if (ob->type == OBJ_STREAM) {
632          defragged += defragStream(db, de);
633      } else if (ob->type == OBJ_MODULE) {
634      } else {
635          serverPanic("Unknown object type");
636      }
637      return defragged;
638  }
639  void defragScanCallback(void *privdata, const dictEntry *de) {
640      PORT_LONG defragged = defragKey((redisDb*)privdata, (dictEntry*)de);
641      server.stat_active_defrag_hits += defragged;
642      if(defragged)
643          server.stat_active_defrag_key_hits++;
644      else
645          server.stat_active_defrag_key_misses++;
646      server.stat_active_defrag_scanned++;
647  }
648  void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {
649      UNUSED(privdata); &bsol;* NOTE: this function is also used by both activeDefragCycle and scanLaterHash, etc. don't use privdata */
650      while(*bucketref) {
651          dictEntry *de = *bucketref, *newde;
652          if ((newde = activeDefragAlloc(de))) {
653              *bucketref = newde;
654          }
655          bucketref = &(*bucketref)->next;
656      }
657  }
658  float getAllocatorFragmentation(size_t *out_frag_bytes) {
659      size_t resident, active, allocated;
660      zmalloc_get_allocator_info(&allocated, &active, &resident);
661      float frag_pct = ((float)active / allocated)*100 - 100;
662      size_t frag_bytes = active - allocated;
663      float rss_pct = ((float)resident / allocated)*100 - 100;
664      size_t rss_bytes = resident - allocated;
665      if(out_frag_bytes)
666          *out_frag_bytes = frag_bytes;
667      serverLog(LL_DEBUG,
668          "allocated=%zu, active=%zu, resident=%zu, frag=%.0f%% (%.0f%% rss), frag_bytes=%zu (%zu rss)",
669          allocated, active, resident, frag_pct, rss_pct, frag_bytes, rss_bytes);
670      return frag_pct;
671  }
672  PORT_LONG defragOtherGlobals() {
673      PORT_LONG defragged = 0;
674      defragged += activeDefragSdsDict(server.lua_scripts, DEFRAG_SDS_DICT_VAL_IS_STROB);
675      defragged += activeDefragSdsListAndDict(server.repl_scriptcache_fifo, server.repl_scriptcache_dict, DEFRAG_SDS_DICT_NO_VAL);
676      return defragged;
677  }
678  int defragLaterItem(dictEntry *de, PORT_ULONG *cursor, PORT_LONGLONG endtime) {
679      if (de) {
680          robj *ob = dictGetVal(de);
681          if (ob->type == OBJ_LIST) {
682              server.stat_active_defrag_hits += scanLaterList(ob);
683              *cursor = 0; &bsol;* list has no scan, we must finish it in one go */
684          } else if (ob->type == OBJ_SET) {
685              server.stat_active_defrag_hits += scanLaterSet(ob, cursor);
686          } else if (ob->type == OBJ_ZSET) {
687              server.stat_active_defrag_hits += scanLaterZset(ob, cursor);
688          } else if (ob->type == OBJ_HASH) {
689              server.stat_active_defrag_hits += scanLaterHash(ob, cursor);
690          } else if (ob->type == OBJ_STREAM) {
691              return scanLaterStraemListpacks(ob, cursor, endtime, &server.stat_active_defrag_hits);
692          } else {
693              *cursor = 0; &bsol;* object type may have changed since we schedule it for later */
694          }
695      } else {
696          *cursor = 0; &bsol;* object may have been deleted already */
697      }
698      return 0;
699  }
700  int defragLaterStep(redisDb *db, PORT_LONGLONG endtime) {
701      static sds current_key = NULL;
702      static PORT_ULONG cursor = 0;
703      unsigned int iterations = 0;
704      PORT_ULONGLONG prev_defragged = server.stat_active_defrag_hits;
705      PORT_ULONGLONG prev_scanned = server.stat_active_defrag_scanned;
706      PORT_LONGLONG key_defragged;
707      do {
708          if (!cursor) {
709              listNode *head = listFirst(db->defrag_later);
710              if (current_key) {
711                  serverAssert(current_key == head->value);
712                  sdsfree(head->value);
713                  listDelNode(db->defrag_later, head);
714                  cursor = 0;
715                  current_key = NULL;
716              }
717              head = listFirst(db->defrag_later);
718              if (!head)
719                  return 0;
720              current_key = head->value;
721              cursor = 0;
722          }
723          dictEntry *de = dictFind(db->dict, current_key);
724          key_defragged = server.stat_active_defrag_hits;
725          do {
726              int quit = 0;
727              if (defragLaterItem(de, &cursor, endtime))
728                  quit = 1; &bsol;* time is up, we didn't finish all the work */
729              if (!cursor)
730                  quit = 1;
731              if (quit || (++iterations > 16 ||
732                              server.stat_active_defrag_hits - prev_defragged > 512 ||
733                              server.stat_active_defrag_scanned - prev_scanned > 64)) {
734                  if (quit || ustime() > endtime) {
735                      if(key_defragged != server.stat_active_defrag_hits)
736                          server.stat_active_defrag_key_hits++;
737                      else
738                          server.stat_active_defrag_key_misses++;
739                      return 1;
740                  }
741                  iterations = 0;
742                  prev_defragged = server.stat_active_defrag_hits;
743                  prev_scanned = server.stat_active_defrag_scanned;
744              }
745          } while(cursor);
746          if(key_defragged != server.stat_active_defrag_hits)
747              server.stat_active_defrag_key_hits++;
748          else
749              server.stat_active_defrag_key_misses++;
750      } while(1);
751  }
752  #define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )
753  #define LIMIT(y, min, max) ((y)<(min)? min: ((y)>(max)? max: (y)))
754  void computeDefragCycles() {
755      size_t frag_bytes;
756      float frag_pct = getAllocatorFragmentation(&frag_bytes);
757      if (!server.active_defrag_running) {
758          if(frag_pct < server.active_defrag_threshold_lower || frag_bytes < server.active_defrag_ignore_bytes)
759              return;
760      }
761      int cpu_pct = INTERPOLATE(frag_pct,
762              server.active_defrag_threshold_lower,
763              server.active_defrag_threshold_upper,
764              server.active_defrag_cycle_min,
765              server.active_defrag_cycle_max);
766      cpu_pct = LIMIT(cpu_pct,
767              server.active_defrag_cycle_min,
768              server.active_defrag_cycle_max);
769      if (!server.active_defrag_running ||
770          cpu_pct > server.active_defrag_running)
771      {
772          server.active_defrag_running = cpu_pct;
773          serverLog(LL_VERBOSE,
774              "Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%",
775              frag_pct, frag_bytes, cpu_pct);
776      }
777  }
778  void activeDefragCycle(void) {
779      static int current_db = -1;
780      static PORT_ULONG cursor = 0;
781      static redisDb *db = NULL;
782      static PORT_LONGLONG start_scan, start_stat;
783      unsigned int iterations = 0;
784      PORT_ULONGLONG prev_defragged = server.stat_active_defrag_hits;
785      PORT_ULONGLONG prev_scanned = server.stat_active_defrag_scanned;
786      PORT_LONGLONG start, timelimit, endtime;
787      mstime_t latency;
788      int quit = 0;
789      if (server.aof_child_pid!=-1 || server.rdb_child_pid!=-1)
790          return; &bsol;* Defragging memory while there's a fork will just do damage. */
791      run_with_period(1000) {
792          computeDefragCycles();
793      }
794      if (!server.active_defrag_running)
795          return;
796      start = ustime();
797      timelimit = 1000000*server.active_defrag_running/server.hz/100;
798      if (timelimit <= 0) timelimit = 1;
799      endtime = start + timelimit;
800      latencyStartMonitor(latency);
801      do {
802          if (!cursor) {
803              if (db && defragLaterStep(db, endtime)) {
804                  quit = 1; &bsol;* time is up, we didn't finish all the work */
805                  break; &bsol;* this will exit the function and we'll continue on the next cycle */
806              }
807              if (++current_db >= server.dbnum) {
808                  defragOtherGlobals();
809                  PORT_LONGLONG now = ustime();
810                  size_t frag_bytes;
811                  float frag_pct = getAllocatorFragmentation(&frag_bytes);
812                  serverLog(LL_VERBOSE,
813                      "Active defrag done in %dms, reallocated=%d, frag=%.0f%%, frag_bytes=%zu",
814                      (int)((now - start_scan)/1000), (int)(server.stat_active_defrag_hits - start_stat), frag_pct, frag_bytes);
815                  start_scan = now;
816                  current_db = -1;
817                  cursor = 0;
818                  db = NULL;
819                  server.active_defrag_running = 0;
820                  computeDefragCycles(); &bsol;* if another scan is needed, start it right away */
821                  if (server.active_defrag_running != 0 && ustime() < endtime)
822                      continue;
823                  break;
824              }
825              else if (current_db==0) {
826                  start_scan = ustime();
827                  start_stat = server.stat_active_defrag_hits;
828              }
829              db = &server.db[current_db];
830              cursor = 0;
831          }
832          do {
833              if (defragLaterStep(db, endtime)) {
834                  quit = 1; &bsol;* time is up, we didn't finish all the work */
835                  break; &bsol;* this will exit the function and we'll continue on the next cycle */
836              }
837              cursor = dictScan(db->dict, cursor, defragScanCallback, defragDictBucketCallback, db);
838              if (!cursor || (++iterations > 16 ||
839                              server.stat_active_defrag_hits - prev_defragged > 512 ||
840                              server.stat_active_defrag_scanned - prev_scanned > 64)) {
841                  if (!cursor || ustime() > endtime) {
842                      quit = 1;
843                      break;
844                  }
845                  iterations = 0;
846                  prev_defragged = server.stat_active_defrag_hits;
847                  prev_scanned = server.stat_active_defrag_scanned;
848              }
849          } while(cursor && !quit);
850      } while(!quit);
851      latencyEndMonitor(latency);
852      latencyAddSampleIfNeeded("active-defrag-cycle",latency);
853  }
854  #else &bsol;* HAVE_DEFRAG */
855  void activeDefragCycle(void) {
856  }
857  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-defrag.c</h3>
            <pre><code>1  #include "server.h"
2  #include <time.h>
3  #include <assert.h>
4  #include <stddef.h>
5  #ifdef HAVE_DEFRAG
6  int je_get_defrag_hint(void* ptr, int *bin_util, int *run_util);
7  void defragDictBucketCallback(void *privdata, dictEntry **bucketref);
8  dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, uint64_t hash, PORT_LONG *defragged);
9  void* activeDefragAlloc(void *ptr) {
10      int bin_util, run_util;
11      size_t size;
12      void *newptr;
13      if(!je_get_defrag_hint(ptr, &bin_util, &run_util)) {
14          server.stat_active_defrag_misses++;
15          return NULL;
16      }
17      if (run_util > bin_util || run_util == 1<<16) {
18          server.stat_active_defrag_misses++;
19          return NULL;
20      }
21      size = zmalloc_size(ptr);
22      newptr = zmalloc_no_tcache(size);
23      memcpy(newptr, ptr, size);
24      zfree_no_tcache(ptr);
25      return newptr;
26  }
27  sds activeDefragSds(sds sdsptr) {
28      void* ptr = sdsAllocPtr(sdsptr);
29      void* newptr = activeDefragAlloc(ptr);
30      if (newptr) {
31          size_t offset = sdsptr - (char*)ptr;
32          sdsptr = (char*)newptr + offset;
33          return sdsptr;
34      }
35      return NULL;
36  }
37  robj *activeDefragStringOb(robj* ob, PORT_LONG *defragged) {
38      robj *ret = NULL;
39      if (ob->refcount!=1)
40          return NULL;
41      if (ob->type!=OBJ_STRING || ob->encoding!=OBJ_ENCODING_EMBSTR) {
42          if ((ret = activeDefragAlloc(ob))) {
43              ob = ret;
44              (*defragged)++;
45          }
46      }
47      if (ob->type == OBJ_STRING) {
48          if(ob->encoding==OBJ_ENCODING_RAW) {
49              sds newsds = activeDefragSds((sds)ob->ptr);
50              if (newsds) {
51                  ob->ptr = newsds;
52                  (*defragged)++;
53              }
54          } else if (ob->encoding==OBJ_ENCODING_EMBSTR) {
55              PORT_LONG ofs = (intptr_t)ob->ptr - (intptr_t)ob;
56              if ((ret = activeDefragAlloc(ob))) {
57                  ret->ptr = (void*)((intptr_t)ret + ofs);
58                  (*defragged)++;
59              }
60          } else if (ob->encoding!=OBJ_ENCODING_INT) {
61              serverPanic("Unknown string encoding");
62          }
63      }
64      return ret;
65  }
66  PORT_LONG dictIterDefragEntry(dictIterator *iter) {
67      PORT_LONG defragged = 0;
68      dictht *ht;
69      if (iter->nextEntry) {
70          dictEntry *newde = activeDefragAlloc(iter->nextEntry);
71          if (newde) {
72              defragged++;
73              iter->nextEntry = newde;
74              iter->entry->next = newde;
75          }
76      }
77      ht = &iter->d->ht[iter->table];
78      if (ht->table[iter->index] == iter->entry) {
79          dictEntry *newde = activeDefragAlloc(iter->entry);
80          if (newde) {
81              iter->entry = newde;
82              ht->table[iter->index] = newde;
83              defragged++;
84          }
85      }
86      return defragged;
87  }
88  PORT_LONG dictDefragTables(dict* d) {
89      dictEntry **newtable;
90      PORT_LONG defragged = 0;
91      newtable = activeDefragAlloc(d->ht[0].table);
92      if (newtable)
93          defragged++, d->ht[0].table = newtable;
94      if (d->ht[1].table) {
95          newtable = activeDefragAlloc(d->ht[1].table);
96          if (newtable)
97              defragged++, d->ht[1].table = newtable;
98      }
99      return defragged;
100  }
101  void zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnode, zskiplistNode **update) {
102      int i;
103      for (i = 0; i < zsl->level; i++) {
104          if (update[i]->level[i].forward == oldnode)
105              update[i]->level[i].forward = newnode;
106      }
107      serverAssert(zsl->header!=oldnode);
108      if (newnode->level[0].forward) {
109          serverAssert(newnode->level[0].forward->backward==oldnode);
110          newnode->level[0].forward->backward = newnode;
111      } else {
112          serverAssert(zsl->tail==oldnode);
113          zsl->tail = newnode;
114      }
115  }
116  double *zslDefrag(zskiplist *zsl, double score, sds oldele, sds newele) {
117      zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x, *newx;
118      int i;
119      sds ele = newele? newele: oldele;
120      x = zsl->header;
121      for (i = zsl->level-1; i >= 0; i--) {
122          while (x->level[i].forward &&
123              x->level[i].forward->ele != oldele && &bsol;* make sure not to access the
124                                                       ->obj pointer if it matches
125                                                       oldele */
126              (x->level[i].forward->score < score ||
127                  (x->level[i].forward->score == score &&
128                  sdscmp(x->level[i].forward->ele,ele) < 0)))
129              x = x->level[i].forward;
130          update[i] = x;
131      }
132      x = x->level[0].forward;
133      serverAssert(x && score == x->score && x->ele==oldele);
134      if (newele)
135          x->ele = newele;
136      newx = activeDefragAlloc(x);
137      if (newx) {
138          zslUpdateNode(zsl, x, newx, update);
139          return &newx->score;
140      }
141      return NULL;
142  }
143  PORT_LONG activeDefragZsetEntry(zset *zs, dictEntry *de) {
144      sds newsds;
145      double* newscore;
146      PORT_LONG defragged = 0;
147      sds sdsele = dictGetKey(de);
148      if ((newsds = activeDefragSds(sdsele)))
149          defragged++, de->key = newsds;
150      newscore = zslDefrag(zs->zsl, *(double*)dictGetVal(de), sdsele, newsds);
151      if (newscore) {
152          dictSetVal(zs->dict, de, newscore);
153          defragged++;
154      }
155      return defragged;
156  }
157  #define DEFRAG_SDS_DICT_NO_VAL 0
158  #define DEFRAG_SDS_DICT_VAL_IS_SDS 1
159  #define DEFRAG_SDS_DICT_VAL_IS_STROB 2
160  #define DEFRAG_SDS_DICT_VAL_VOID_PTR 3
161  PORT_LONG activeDefragSdsDict(dict* d, int val_type) {
162      dictIterator *di;
163      dictEntry *de;
164      PORT_LONG defragged = 0;
165      di = dictGetIterator(d);
166      while((de = dictNext(di)) != NULL) {
167          sds sdsele = dictGetKey(de), newsds;
168          if ((newsds = activeDefragSds(sdsele)))
169              de->key = newsds, defragged++;
170          if (val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {
171              sdsele = dictGetVal(de);
172              if ((newsds = activeDefragSds(sdsele)))
173                  de->v.val = newsds, defragged++;
174          } else if (val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {
175              robj *newele, *ele = dictGetVal(de);
176              if ((newele = activeDefragStringOb(ele, &defragged)))
177                  de->v.val = newele;
178          } else if (val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {
179              void *newptr, *ptr = dictGetVal(de);
180              if ((newptr = activeDefragAlloc(ptr)))
181                  de->v.val = newptr, defragged++;
182          }
183          defragged += dictIterDefragEntry(di);
184      }
185      dictReleaseIterator(di);
186      return defragged;
187  }
188  PORT_LONG activeDefragList(list *l, int val_type) {
189      PORT_LONG defragged = 0;
190      listNode *ln, *newln;
191      for (ln = l->head; ln; ln = ln->next) {
192          if ((newln = activeDefragAlloc(ln))) {
193              if (newln->prev)
194                  newln->prev->next = newln;
195              else
196                  l->head = newln;
197              if (newln->next)
198                  newln->next->prev = newln;
199              else
200                  l->tail = newln;
201              ln = newln;
202              defragged++;
203          }
204          if (val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {
205              sds newsds, sdsele = ln->value;
206              if ((newsds = activeDefragSds(sdsele)))
207                  ln->value = newsds, defragged++;
208          } else if (val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {
209              robj *newele, *ele = ln->value;
210              if ((newele = activeDefragStringOb(ele, &defragged)))
211                  ln->value = newele;
212          } else if (val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {
213              void *newptr, *ptr = ln->value;
214              if ((newptr = activeDefragAlloc(ptr)))
215                  ln->value = newptr, defragged++;
216          }
217      }
218      return defragged;
219  }
220  PORT_LONG activeDefragSdsListAndDict(list *l, dict *d, int dict_val_type) {
221      PORT_LONG defragged = 0;
222      sds newsds, sdsele;
223      listNode *ln, *newln;
224      dictIterator *di;
225      dictEntry *de;
226      for (ln = l->head; ln; ln = ln->next) {
227          if ((newln = activeDefragAlloc(ln))) {
228              if (newln->prev)
229                  newln->prev->next = newln;
230              else
231                  l->head = newln;
232              if (newln->next)
233                  newln->next->prev = newln;
234              else
235                  l->tail = newln;
236              ln = newln;
237              defragged++;
238          }
239          sdsele = ln->value;
240          if ((newsds = activeDefragSds(sdsele))) {
241              uint64_t hash = dictGetHash(d, newsds);
242              replaceSateliteDictKeyPtrAndOrDefragDictEntry(d, sdsele, newsds, hash, &defragged);
243              ln->value = newsds;
244              defragged++;
245          }
246      }
247      di = dictGetIterator(d);
248      while((de = dictNext(di)) != NULL) {
249          if (dict_val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {
250              sds newsds, sdsele = dictGetVal(de);
251              if ((newsds = activeDefragSds(sdsele)))
252                  de->v.val = newsds, defragged++;
253          } else if (dict_val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {
254              robj *newele, *ele = dictGetVal(de);
255              if ((newele = activeDefragStringOb(ele, &defragged)))
256                  de->v.val = newele, defragged++;
257          } else if (dict_val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {
258              void *newptr, *ptr = ln->value;
259              if ((newptr = activeDefragAlloc(ptr)))
260                  ln->value = newptr, defragged++;
261          }
262          defragged += dictIterDefragEntry(di);
263      }
264      dictReleaseIterator(di);
265      return defragged;
266  }
267  dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, uint64_t hash, PORT_LONG *defragged) {
268      dictEntry **deref = dictFindEntryRefByPtrAndHash(d, oldkey, hash);
269      if (deref) {
270          dictEntry *de = *deref;
271          dictEntry *newde = activeDefragAlloc(de);
272          if (newde) {
273              de = *deref = newde;
274              (*defragged)++;
275          }
276          if (newkey)
277              de->key = newkey;
278          return de;
279      }
280      return NULL;
281  }
282  PORT_LONG activeDefragQuickListNodes(quicklist *ql) {
283      quicklistNode *node = ql->head, *newnode;
284      PORT_LONG defragged = 0;
285      unsigned char *newzl;
286      while (node) {
287          if ((newnode = activeDefragAlloc(node))) {
288              if (newnode->prev)
289                  newnode->prev->next = newnode;
290              else
291                  ql->head = newnode;
292              if (newnode->next)
293                  newnode->next->prev = newnode;
294              else
295                  ql->tail = newnode;
296              node = newnode;
297              defragged++;
298          }
299          if ((newzl = activeDefragAlloc(node->zl)))
300              defragged++, node->zl = newzl;
301          node = node->next;
302      }
303      return defragged;
304  }
305  void defragLater(redisDb *db, dictEntry *kde) {
306      sds key = sdsdup(dictGetKey(kde));
307      listAddNodeTail(db->defrag_later, key);
308  }
309  PORT_LONG scanLaterList(robj *ob) {
310      quicklist *ql = ob->ptr;
311      if (ob->type != OBJ_LIST || ob->encoding != OBJ_ENCODING_QUICKLIST)
312          return 0;
313      server.stat_active_defrag_scanned+=ql->len;
314      return activeDefragQuickListNodes(ql);
315  }
316  typedef struct {
317      zset *zs;
318      PORT_LONG defragged;
319  } scanLaterZsetData;
320  void scanLaterZsetCallback(void *privdata, const dictEntry *_de) {
321      dictEntry *de = (dictEntry*)_de;
322      scanLaterZsetData *data = privdata;
323      data->defragged += activeDefragZsetEntry(data->zs, de);
324      server.stat_active_defrag_scanned++;
325  }
326  PORT_LONG scanLaterZset(robj *ob, PORT_ULONG *cursor) {
327      if (ob->type != OBJ_ZSET || ob->encoding != OBJ_ENCODING_SKIPLIST)
328          return 0;
329      zset *zs = (zset*)ob->ptr;
330      dict *d = zs->dict;
331      scanLaterZsetData data = {zs, 0};
332      *cursor = dictScan(d, *cursor, scanLaterZsetCallback, defragDictBucketCallback, &data);
333      return data.defragged;
334  }
335  void scanLaterSetCallback(void *privdata, const dictEntry *_de) {
336      dictEntry *de = (dictEntry*)_de;
337      PORT_LONG *defragged = privdata;
338      sds sdsele = dictGetKey(de), newsds;
339      if ((newsds = activeDefragSds(sdsele)))
340          (*defragged)++, de->key = newsds;
341      server.stat_active_defrag_scanned++;
342  }
343  PORT_LONG scanLaterSet(robj *ob, PORT_ULONG *cursor) {
344      PORT_LONG defragged = 0;
345      if (ob->type != OBJ_SET || ob->encoding != OBJ_ENCODING_HT)
346          return 0;
347      dict *d = ob->ptr;
348      *cursor = dictScan(d, *cursor, scanLaterSetCallback, defragDictBucketCallback, &defragged);
349      return defragged;
350  }
351  void scanLaterHashCallback(void *privdata, const dictEntry *_de) {
352      dictEntry *de = (dictEntry*)_de;
353      PORT_LONG *defragged = privdata;
354      sds sdsele = dictGetKey(de), newsds;
355      if ((newsds = activeDefragSds(sdsele)))
356          (*defragged)++, de->key = newsds;
357      sdsele = dictGetVal(de);
358      if ((newsds = activeDefragSds(sdsele)))
359          (*defragged)++, de->v.val = newsds;
360      server.stat_active_defrag_scanned++;
361  }
362  PORT_LONG scanLaterHash(robj *ob, PORT_ULONG *cursor) {
363      PORT_LONG defragged = 0;
364      if (ob->type != OBJ_HASH || ob->encoding != OBJ_ENCODING_HT)
365          return 0;
366      dict *d = ob->ptr;
367      *cursor = dictScan(d, *cursor, scanLaterHashCallback, defragDictBucketCallback, &defragged);
368      return defragged;
369  }
370  PORT_LONG defragQuicklist(redisDb *db, dictEntry *kde) {
371      robj *ob = dictGetVal(kde);
372      PORT_LONG defragged = 0;
373      quicklist *ql = ob->ptr, *newql;
374      serverAssert(ob->type == OBJ_LIST && ob->encoding == OBJ_ENCODING_QUICKLIST);
375      if ((newql = activeDefragAlloc(ql)))
376          defragged++, ob->ptr = ql = newql;
377      if (ql->len > server.active_defrag_max_scan_fields)
378          defragLater(db, kde);
379      else
380          defragged += activeDefragQuickListNodes(ql);
381      return defragged;
382  }
383  PORT_LONG defragZsetSkiplist(redisDb *db, dictEntry *kde) {
384      robj *ob = dictGetVal(kde);
385      PORT_LONG defragged = 0;
386      zset *zs = (zset*)ob->ptr;
387      zset *newzs;
388      zskiplist *newzsl;
389      dict *newdict;
390      dictEntry *de;
391      struct zskiplistNode *newheader;
392      serverAssert(ob->type == OBJ_ZSET && ob->encoding == OBJ_ENCODING_SKIPLIST);
393      if ((newzs = activeDefragAlloc(zs)))
394          defragged++, ob->ptr = zs = newzs;
395      if ((newzsl = activeDefragAlloc(zs->zsl)))
396          defragged++, zs->zsl = newzsl;
397      if ((newheader = activeDefragAlloc(zs->zsl->header)))
398          defragged++, zs->zsl->header = newheader;
399      if (dictSize(zs->dict) > server.active_defrag_max_scan_fields)
400          defragLater(db, kde);
401      else {
402          dictIterator *di = dictGetIterator(zs->dict);
403          while((de = dictNext(di)) != NULL) {
404              defragged += activeDefragZsetEntry(zs, de);
405          }
406          dictReleaseIterator(di);
407      }
408      if ((newdict = activeDefragAlloc(zs->dict)))
409          defragged++, zs->dict = newdict;
410      defragged += dictDefragTables(zs->dict);
411      return defragged;
412  }
413  PORT_LONG defragHash(redisDb *db, dictEntry *kde) {
414      PORT_LONG defragged = 0;
415      robj *ob = dictGetVal(kde);
416      dict *d, *newd;
417      serverAssert(ob->type == OBJ_HASH && ob->encoding == OBJ_ENCODING_HT);
418      d = ob->ptr;
419      if (dictSize(d) > server.active_defrag_max_scan_fields)
420          defragLater(db, kde);
421      else
<span onclick='openModal()' class='match'>422          defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_VAL_IS_SDS);
423      if ((newd = activeDefragAlloc(ob->ptr)))
424          defragged++, ob->ptr = newd;
425      defragged += dictDefragTables(ob->ptr);
426      return defragged;
427  }
428  PORT_LONG defragSet(redisDb *db, dictEntry *kde) {
</span>429      PORT_LONG defragged = 0;
430      robj *ob = dictGetVal(kde);
431      dict *d, *newd;
432      serverAssert(ob->type == OBJ_SET && ob->encoding == OBJ_ENCODING_HT);
433      d = ob->ptr;
434      if (dictSize(d) > server.active_defrag_max_scan_fields)
435          defragLater(db, kde);
436      else
437          defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_NO_VAL);
438      if ((newd = activeDefragAlloc(ob->ptr)))
439          defragged++, ob->ptr = newd;
440      defragged += dictDefragTables(ob->ptr);
441      return defragged;
442  }
443  int defragRaxNode(raxNode **noderef) {
444      raxNode *newnode = activeDefragAlloc(*noderef);
445      if (newnode) {
446          *noderef = newnode;
447          return 1;
448      }
449      return 0;
450  }
451  int scanLaterStraemListpacks(robj *ob, PORT_ULONG *cursor, PORT_LONGLONG endtime, PORT_LONGLONG *defragged) {
452      static unsigned char last[sizeof(streamID)];
453      raxIterator ri;
454      PORT_LONG iterations = 0;
455      if (ob->type != OBJ_STREAM || ob->encoding != OBJ_ENCODING_STREAM) {
456          *cursor = 0;
457          return 0;
458      }
459      stream *s = ob->ptr;
460      raxStart(&ri,s->rax);
461      if (*cursor == 0) {
462          defragRaxNode(&s->rax->head);
463          ri.node_cb = defragRaxNode;
464          raxSeek(&ri,"^",NULL,0);
465      } else {
466          if (!raxSeek(&ri,">", last, sizeof(last))) {
467              *cursor = 0;
468              return 0;
469          }
470          ri.node_cb = defragRaxNode;
471      }
472      (*cursor)++;
473      while (raxNext(&ri)) {
474          void *newdata = activeDefragAlloc(ri.data);
475          if (newdata)
476              raxSetData(ri.node, ri.data=newdata), (*defragged)++;
477          if (++iterations > 16) {
478              if (ustime() > endtime) {
479                  serverAssert(ri.key_len==sizeof(last));
480                  memcpy(last,ri.key,ri.key_len);
481                  raxStop(&ri);
482                  return 1;
483              }
484              iterations = 0;
485          }
486      }
487      raxStop(&ri);
488      *cursor = 0;
489      return 0;
490  }
491  typedef void *(raxDefragFunction)(raxIterator *ri, void *privdata, PORT_LONG *defragged);
492  PORT_LONG defragRadixTree(rax **raxref, int defrag_data, raxDefragFunction *element_cb, void *element_cb_data) {
493      PORT_LONG defragged = 0;
494      raxIterator ri;
495      rax* rax;
496      if ((rax = activeDefragAlloc(*raxref)))
497          defragged++, *raxref = rax;
498      rax = *raxref;
499      raxStart(&ri,rax);
500      ri.node_cb = defragRaxNode;
501      defragRaxNode(&rax->head);
502      raxSeek(&ri,"^",NULL,0);
503      while (raxNext(&ri)) {
504          void *newdata = NULL;
505          if (element_cb)
506              newdata = element_cb(&ri, element_cb_data, &defragged);
507          if (defrag_data && !newdata)
508              newdata = activeDefragAlloc(ri.data);
509          if (newdata)
510              raxSetData(ri.node, ri.data=newdata), defragged++;
511      }
512      raxStop(&ri);
513      return defragged;
514  }
515  typedef struct {
516      streamCG *cg;
517      streamConsumer *c;
518  } PendingEntryContext;
519  void* defragStreamConsumerPendingEntry(raxIterator *ri, void *privdata, PORT_LONG *defragged) {
520      UNUSED(defragged);
521      PendingEntryContext *ctx = privdata;
522      streamNACK *nack = ri->data, *newnack;
523      nack->consumer = ctx->c; &bsol;* update nack pointer to consumer */
524      newnack = activeDefragAlloc(nack);
525      if (newnack) {
526          void *prev;
527          raxInsert(ctx->cg->pel, ri->key, ri->key_len, newnack, &prev);
528          serverAssert(prev==nack);
529      }
530      return newnack;
531  }
532  void* defragStreamConsumer(raxIterator *ri, void *privdata, PORT_LONG *defragged) {
533      streamConsumer *c = ri->data;
534      streamCG *cg = privdata;
535      void *newc = activeDefragAlloc(c);
536      if (newc) {
537          c = newc;
538      }
539      sds newsds = activeDefragSds(c->name);
540      if (newsds)
541          (*defragged)++, c->name = newsds;
542      if (c->pel) {
543          PendingEntryContext pel_ctx = {cg, c};
544          *defragged += defragRadixTree(&c->pel, 0, defragStreamConsumerPendingEntry, &pel_ctx);
545      }
546      return newc; &bsol;* returns NULL if c was not defragged */
547  }
548  void* defragStreamConsumerGroup(raxIterator *ri, void *privdata, PORT_LONG *defragged) {
549      streamCG *cg = ri->data;
550      UNUSED(privdata);
551      if (cg->consumers)
552          *defragged += defragRadixTree(&cg->consumers, 0, defragStreamConsumer, cg);
553      if (cg->pel)
554          *defragged += defragRadixTree(&cg->pel, 0, NULL, NULL);
555      return NULL;
556  }
557  PORT_LONG defragStream(redisDb *db, dictEntry *kde) {
558      PORT_LONG defragged = 0;
559      robj *ob = dictGetVal(kde);
560      serverAssert(ob->type == OBJ_STREAM && ob->encoding == OBJ_ENCODING_STREAM);
561      stream *s = ob->ptr, *news;
562      if ((news = activeDefragAlloc(s)))
563          defragged++, ob->ptr = s = news;
564      if (raxSize(s->rax) > server.active_defrag_max_scan_fields) {
565          rax *newrax = activeDefragAlloc(s->rax);
566          if (newrax)
567              defragged++, s->rax = newrax;
568          defragLater(db, kde);
569      } else
570          defragged += defragRadixTree(&s->rax, 1, NULL, NULL);
571      if (s->cgroups)
572          defragged += defragRadixTree(&s->cgroups, 1, defragStreamConsumerGroup, NULL);
573      return defragged;
574  }
575  PORT_LONG defragKey(redisDb *db, dictEntry *de) {
576      sds keysds = dictGetKey(de);
577      robj *newob, *ob;
578      unsigned char *newzl;
579      PORT_LONG defragged = 0;
580      sds newsds;
581      newsds = activeDefragSds(keysds);
582      if (newsds)
583          defragged++, de->key = newsds;
584      if (dictSize(db->expires)) {
585          uint64_t hash = dictGetHash(db->dict, de->key);
586          replaceSateliteDictKeyPtrAndOrDefragDictEntry(db->expires, keysds, newsds, hash, &defragged);
587      }
588      ob = dictGetVal(de);
589      if ((newob = activeDefragStringOb(ob, &defragged))) {
590          de->v.val = newob;
591          ob = newob;
592      }
593      if (ob->type == OBJ_STRING) {
594      } else if (ob->type == OBJ_LIST) {
595          if (ob->encoding == OBJ_ENCODING_QUICKLIST) {
596              defragged += defragQuicklist(db, de);
597          } else if (ob->encoding == OBJ_ENCODING_ZIPLIST) {
598              if ((newzl = activeDefragAlloc(ob->ptr)))
599                  defragged++, ob->ptr = newzl;
600          } else {
601              serverPanic("Unknown list encoding");
602          }
603      } else if (ob->type == OBJ_SET) {
604          if (ob->encoding == OBJ_ENCODING_HT) {
605              defragged += defragSet(db, de);
606          } else if (ob->encoding == OBJ_ENCODING_INTSET) {
607              intset *newis, *is = ob->ptr;
608              if ((newis = activeDefragAlloc(is)))
609                  defragged++, ob->ptr = newis;
610          } else {
611              serverPanic("Unknown set encoding");
612          }
613      } else if (ob->type == OBJ_ZSET) {
614          if (ob->encoding == OBJ_ENCODING_ZIPLIST) {
615              if ((newzl = activeDefragAlloc(ob->ptr)))
616                  defragged++, ob->ptr = newzl;
617          } else if (ob->encoding == OBJ_ENCODING_SKIPLIST) {
618              defragged += defragZsetSkiplist(db, de);
619          } else {
620              serverPanic("Unknown sorted set encoding");
621          }
622      } else if (ob->type == OBJ_HASH) {
623          if (ob->encoding == OBJ_ENCODING_ZIPLIST) {
624              if ((newzl = activeDefragAlloc(ob->ptr)))
625                  defragged++, ob->ptr = newzl;
626          } else if (ob->encoding == OBJ_ENCODING_HT) {
627              defragged += defragHash(db, de);
628          } else {
629              serverPanic("Unknown hash encoding");
630          }
631      } else if (ob->type == OBJ_STREAM) {
632          defragged += defragStream(db, de);
633      } else if (ob->type == OBJ_MODULE) {
634      } else {
635          serverPanic("Unknown object type");
636      }
637      return defragged;
638  }
639  void defragScanCallback(void *privdata, const dictEntry *de) {
640      PORT_LONG defragged = defragKey((redisDb*)privdata, (dictEntry*)de);
641      server.stat_active_defrag_hits += defragged;
642      if(defragged)
643          server.stat_active_defrag_key_hits++;
644      else
645          server.stat_active_defrag_key_misses++;
646      server.stat_active_defrag_scanned++;
647  }
648  void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {
649      UNUSED(privdata); &bsol;* NOTE: this function is also used by both activeDefragCycle and scanLaterHash, etc. don't use privdata */
650      while(*bucketref) {
651          dictEntry *de = *bucketref, *newde;
652          if ((newde = activeDefragAlloc(de))) {
653              *bucketref = newde;
654          }
655          bucketref = &(*bucketref)->next;
656      }
657  }
658  float getAllocatorFragmentation(size_t *out_frag_bytes) {
659      size_t resident, active, allocated;
660      zmalloc_get_allocator_info(&allocated, &active, &resident);
661      float frag_pct = ((float)active / allocated)*100 - 100;
662      size_t frag_bytes = active - allocated;
663      float rss_pct = ((float)resident / allocated)*100 - 100;
664      size_t rss_bytes = resident - allocated;
665      if(out_frag_bytes)
666          *out_frag_bytes = frag_bytes;
667      serverLog(LL_DEBUG,
668          "allocated=%zu, active=%zu, resident=%zu, frag=%.0f%% (%.0f%% rss), frag_bytes=%zu (%zu rss)",
669          allocated, active, resident, frag_pct, rss_pct, frag_bytes, rss_bytes);
670      return frag_pct;
671  }
672  PORT_LONG defragOtherGlobals() {
673      PORT_LONG defragged = 0;
674      defragged += activeDefragSdsDict(server.lua_scripts, DEFRAG_SDS_DICT_VAL_IS_STROB);
675      defragged += activeDefragSdsListAndDict(server.repl_scriptcache_fifo, server.repl_scriptcache_dict, DEFRAG_SDS_DICT_NO_VAL);
676      return defragged;
677  }
678  int defragLaterItem(dictEntry *de, PORT_ULONG *cursor, PORT_LONGLONG endtime) {
679      if (de) {
680          robj *ob = dictGetVal(de);
681          if (ob->type == OBJ_LIST) {
682              server.stat_active_defrag_hits += scanLaterList(ob);
683              *cursor = 0; &bsol;* list has no scan, we must finish it in one go */
684          } else if (ob->type == OBJ_SET) {
685              server.stat_active_defrag_hits += scanLaterSet(ob, cursor);
686          } else if (ob->type == OBJ_ZSET) {
687              server.stat_active_defrag_hits += scanLaterZset(ob, cursor);
688          } else if (ob->type == OBJ_HASH) {
689              server.stat_active_defrag_hits += scanLaterHash(ob, cursor);
690          } else if (ob->type == OBJ_STREAM) {
691              return scanLaterStraemListpacks(ob, cursor, endtime, &server.stat_active_defrag_hits);
692          } else {
693              *cursor = 0; &bsol;* object type may have changed since we schedule it for later */
694          }
695      } else {
696          *cursor = 0; &bsol;* object may have been deleted already */
697      }
698      return 0;
699  }
700  int defragLaterStep(redisDb *db, PORT_LONGLONG endtime) {
701      static sds current_key = NULL;
702      static PORT_ULONG cursor = 0;
703      unsigned int iterations = 0;
704      PORT_ULONGLONG prev_defragged = server.stat_active_defrag_hits;
705      PORT_ULONGLONG prev_scanned = server.stat_active_defrag_scanned;
706      PORT_LONGLONG key_defragged;
707      do {
708          if (!cursor) {
709              listNode *head = listFirst(db->defrag_later);
710              if (current_key) {
711                  serverAssert(current_key == head->value);
712                  sdsfree(head->value);
713                  listDelNode(db->defrag_later, head);
714                  cursor = 0;
715                  current_key = NULL;
716              }
717              head = listFirst(db->defrag_later);
718              if (!head)
719                  return 0;
720              current_key = head->value;
721              cursor = 0;
722          }
723          dictEntry *de = dictFind(db->dict, current_key);
724          key_defragged = server.stat_active_defrag_hits;
725          do {
726              int quit = 0;
727              if (defragLaterItem(de, &cursor, endtime))
728                  quit = 1; &bsol;* time is up, we didn't finish all the work */
729              if (!cursor)
730                  quit = 1;
731              if (quit || (++iterations > 16 ||
732                              server.stat_active_defrag_hits - prev_defragged > 512 ||
733                              server.stat_active_defrag_scanned - prev_scanned > 64)) {
734                  if (quit || ustime() > endtime) {
735                      if(key_defragged != server.stat_active_defrag_hits)
736                          server.stat_active_defrag_key_hits++;
737                      else
738                          server.stat_active_defrag_key_misses++;
739                      return 1;
740                  }
741                  iterations = 0;
742                  prev_defragged = server.stat_active_defrag_hits;
743                  prev_scanned = server.stat_active_defrag_scanned;
744              }
745          } while(cursor);
746          if(key_defragged != server.stat_active_defrag_hits)
747              server.stat_active_defrag_key_hits++;
748          else
749              server.stat_active_defrag_key_misses++;
750      } while(1);
751  }
752  #define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )
753  #define LIMIT(y, min, max) ((y)<(min)? min: ((y)>(max)? max: (y)))
754  void computeDefragCycles() {
755      size_t frag_bytes;
756      float frag_pct = getAllocatorFragmentation(&frag_bytes);
757      if (!server.active_defrag_running) {
758          if(frag_pct < server.active_defrag_threshold_lower || frag_bytes < server.active_defrag_ignore_bytes)
759              return;
760      }
761      int cpu_pct = INTERPOLATE(frag_pct,
762              server.active_defrag_threshold_lower,
763              server.active_defrag_threshold_upper,
764              server.active_defrag_cycle_min,
765              server.active_defrag_cycle_max);
766      cpu_pct = LIMIT(cpu_pct,
767              server.active_defrag_cycle_min,
768              server.active_defrag_cycle_max);
769      if (!server.active_defrag_running ||
770          cpu_pct > server.active_defrag_running)
771      {
772          server.active_defrag_running = cpu_pct;
773          serverLog(LL_VERBOSE,
774              "Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%",
775              frag_pct, frag_bytes, cpu_pct);
776      }
777  }
778  void activeDefragCycle(void) {
779      static int current_db = -1;
780      static PORT_ULONG cursor = 0;
781      static redisDb *db = NULL;
782      static PORT_LONGLONG start_scan, start_stat;
783      unsigned int iterations = 0;
784      PORT_ULONGLONG prev_defragged = server.stat_active_defrag_hits;
785      PORT_ULONGLONG prev_scanned = server.stat_active_defrag_scanned;
786      PORT_LONGLONG start, timelimit, endtime;
787      mstime_t latency;
788      int quit = 0;
789      if (server.aof_child_pid!=-1 || server.rdb_child_pid!=-1)
790          return; &bsol;* Defragging memory while there's a fork will just do damage. */
791      run_with_period(1000) {
792          computeDefragCycles();
793      }
794      if (!server.active_defrag_running)
795          return;
796      start = ustime();
797      timelimit = 1000000*server.active_defrag_running/server.hz/100;
798      if (timelimit <= 0) timelimit = 1;
799      endtime = start + timelimit;
800      latencyStartMonitor(latency);
801      do {
802          if (!cursor) {
803              if (db && defragLaterStep(db, endtime)) {
804                  quit = 1; &bsol;* time is up, we didn't finish all the work */
805                  break; &bsol;* this will exit the function and we'll continue on the next cycle */
806              }
807              if (++current_db >= server.dbnum) {
808                  defragOtherGlobals();
809                  PORT_LONGLONG now = ustime();
810                  size_t frag_bytes;
811                  float frag_pct = getAllocatorFragmentation(&frag_bytes);
812                  serverLog(LL_VERBOSE,
813                      "Active defrag done in %dms, reallocated=%d, frag=%.0f%%, frag_bytes=%zu",
814                      (int)((now - start_scan)/1000), (int)(server.stat_active_defrag_hits - start_stat), frag_pct, frag_bytes);
815                  start_scan = now;
816                  current_db = -1;
817                  cursor = 0;
818                  db = NULL;
819                  server.active_defrag_running = 0;
820                  computeDefragCycles(); &bsol;* if another scan is needed, start it right away */
821                  if (server.active_defrag_running != 0 && ustime() < endtime)
822                      continue;
823                  break;
824              }
825              else if (current_db==0) {
826                  start_scan = ustime();
827                  start_stat = server.stat_active_defrag_hits;
828              }
829              db = &server.db[current_db];
830              cursor = 0;
831          }
832          do {
833              if (defragLaterStep(db, endtime)) {
834                  quit = 1; &bsol;* time is up, we didn't finish all the work */
835                  break; &bsol;* this will exit the function and we'll continue on the next cycle */
836              }
837              cursor = dictScan(db->dict, cursor, defragScanCallback, defragDictBucketCallback, db);
838              if (!cursor || (++iterations > 16 ||
839                              server.stat_active_defrag_hits - prev_defragged > 512 ||
840                              server.stat_active_defrag_scanned - prev_scanned > 64)) {
841                  if (!cursor || ustime() > endtime) {
842                      quit = 1;
843                      break;
844                  }
845                  iterations = 0;
846                  prev_defragged = server.stat_active_defrag_hits;
847                  prev_scanned = server.stat_active_defrag_scanned;
848              }
849          } while(cursor && !quit);
850      } while(!quit);
851      latencyEndMonitor(latency);
852      latencyAddSampleIfNeeded("active-defrag-cycle",latency);
853  }
854  #else &bsol;* HAVE_DEFRAG */
855  void activeDefragCycle(void) {
856  }
857  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-defrag.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-defrag.c</div>
                </div>
                <div class="column column_space"><pre><code>437          defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_NO_VAL);
438      if ((newd = activeDefragAlloc(ob->ptr)))
439          defragged++, ob->ptr = newd;
440      defragged += dictDefragTables(ob->ptr);
441      return defragged;
442  }
443  int defragRaxNode(raxNode **noderef) {
</pre></code></div>
                <div class="column column_space"><pre><code>422          defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_VAL_IS_SDS);
423      if ((newd = activeDefragAlloc(ob->ptr)))
424          defragged++, ob->ptr = newd;
425      defragged += dictDefragTables(ob->ptr);
426      return defragged;
427  }
428  PORT_LONG defragSet(redisDb *db, dictEntry *kde) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    