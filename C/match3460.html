<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for strgen.c &amp; tcpsrv.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for strgen.c &amp; tcpsrv.c
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>strgen.c (12.745098%)<th>tcpsrv.c (1.3415892%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(210-234)<td><a href="#" name="0">(1550-1577)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>strgen.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdlib.h&gt;
3 #include &lt;string.h&gt;
4 #include &lt;assert.h&gt;
5 #include "rsyslog.h"
6 #include "msg.h"
7 #include "obj.h"
8 #include "errmsg.h"
9 #include "strgen.h"
10 #include "ruleset.h"
11 #include "unicode-helper.h"
12 #include "cfsysline.h"
13 DEFobjStaticHelpers
14 DEFobjCurrIf(glbl)
15 DEFobjCurrIf(ruleset)
16 strgenList_t *pStrgenLstRoot = NULL;
17 static rsRetVal
18 InitStrgenList(strgenList_t **pListRoot)
19 {
20 	*pListRoot = NULL;
21 	return RS_RET_OK;
22 }
23 static rsRetVal
24 DestructStrgenList(strgenList_t **ppListRoot)
25 {
26 	strgenList_t *pStrgenLst;
27 	strgenList_t *pStrgenLstDel;
28 	pStrgenLst = *ppListRoot;
29 	while(pStrgenLst != NULL) {
30 		pStrgenLstDel = pStrgenLst;
31 		pStrgenLst = pStrgenLst-&gt;pNext;
32 		free(pStrgenLstDel);
33 	}
34 	*ppListRoot = NULL;
35 	return RS_RET_OK;
36 }
37 static rsRetVal
38 AddStrgenToList(strgenList_t **ppListRoot, strgen_t *pStrgen)
39 {
40 	strgenList_t *pThis;
41 	strgenList_t *pTail;
42 	DEFiRet;
43 	CHKmalloc(pThis = malloc(sizeof(strgenList_t)));
44 	pThis-&gt;pStrgen = pStrgen;
45 	pThis-&gt;pNext = NULL;
46 	if(*ppListRoot == NULL) {
47 		pThis-&gt;pNext = *ppListRoot;
48 		*ppListRoot = pThis;
49 	} else {
50 		for(pTail = *ppListRoot ; pTail-&gt;pNext != NULL ; pTail = pTail-&gt;pNext)
51 		pTail-&gt;pNext = pThis;
52 	}
53 finalize_it:
54 	RETiRet;
55 }
56 static rsRetVal
57 FindStrgen(strgen_t **ppStrgen, uchar *pName)
58 {
59 	strgenList_t *pThis;
60 	DEFiRet;
61 	for(pThis = pStrgenLstRoot ; pThis != NULL ; pThis = pThis-&gt;pNext) {
62 		if(ustrcmp(pThis-&gt;pStrgen-&gt;pName, pName) == 0) {
63 			*ppStrgen = pThis-&gt;pStrgen;
64 			FINALIZE;			}
65 	}
66 	iRet = RS_RET_PARSER_NOT_FOUND;
67 finalize_it:
68 	RETiRet;
69 }
70 BEGINobjConstruct(strgen) ENDobjConstruct(strgen)
71 static rsRetVal
72 strgenConstructFinalize(strgen_t *pThis)
73 {
74 	DEFiRet;
75 	ISOBJ_TYPE_assert(pThis, strgen);
76 	CHKiRet(AddStrgenToList(&amp;pStrgenLstRoot, pThis));
77 	DBGPRINTF("Strgen '%s' added to list of available strgens.\n", pThis-&gt;pName);
78 finalize_it:
79 	RETiRet;
80 }
81 PROTOTYPEobjDestruct(strgen);
82 BEGINobjDestruct(strgen) CODESTARTobjDestruct(strgen)
83 	dbgprintf("destructing strgen '%s'\n", pThis-&gt;pName);
84 	free(pThis-&gt;pName);
85 ENDobjDestruct(strgen)
86 static rsRetVal
87 SetName(strgen_t *pThis, uchar *name)
88 {
89 	DEFiRet;
90 	ISOBJ_TYPE_assert(pThis, strgen);
91 	assert(name != NULL);
92 	if(pThis-&gt;pName != NULL) {
93 		free(pThis-&gt;pName);
94 		pThis-&gt;pName = NULL;
95 	}
96 	CHKmalloc(pThis-&gt;pName = ustrdup(name));
97 finalize_it:
98 	RETiRet;
99 }
100 static rsRetVal
101 SetModPtr(strgen_t *pThis, modInfo_t *pMod)
102 {
103 	ISOBJ_TYPE_assert(pThis, strgen);
104 	assert(pMod != NULL);
105 <a name="0"></a>	assert(pThis-&gt;pModule == NULL);
106 	pThis-&gt;pModule = pMod;
107 	return RS_RET_OK;
108 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
109 BEGINobjQueryInterface(strgen)
110 CODESTARTobjQueryInterface(strgen)
111 	if(pIf-&gt;ifVersion != strgenCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
112 	}
113 	pIf-&gt;Construct = strgenConstruct;
114 	pIf-&gt;ConstructFinalize = strgenConstructFinalize;
115 	pIf-&gt;Destruct = strgenDestruct;
116 	pIf-&gt;SetName = SetName;
117 	pIf-&gt;SetModPtr = SetModPtr;
118 	pIf-&gt;InitStrgenList = InitStrgenList;
119 	pIf-&gt;DestructStrgenList = DestructStrgenList;
120 	pIf-&gt;AddStrgenToList = AddStrgenToList;
121 	pIf-&gt;FindStrgen = FindStrgen;</b></font>
122 finalize_it:
123 ENDobjQueryInterface(strgen)
124 static void
125 destroyMasterStrgenList(void)
126 {
127 	strgenList_t *pStrgenLst;
128 	strgenList_t *pStrgenLstDel;
129 	pStrgenLst = pStrgenLstRoot;
130 	while(pStrgenLst != NULL) {
131 		strgenDestruct(&amp;pStrgenLst-&gt;pStrgen);
132 		pStrgenLstDel = pStrgenLst;
133 		pStrgenLst = pStrgenLst-&gt;pNext;
134 		free(pStrgenLstDel);
135 	}
136 }
137 BEGINObjClassExit(strgen, OBJ_IS_CORE_MODULE) 	destroyMasterStrgenList();
138 	objRelease(glbl, CORE_COMPONENT);
139 	objRelease(ruleset, CORE_COMPONENT);
140 ENDObjClassExit(strgen)
141 BEGINObjClassInit(strgen, 1, OBJ_IS_CORE_MODULE) 	CHKiRet(objUse(glbl, CORE_COMPONENT));
142 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
143 	InitStrgenList(&amp;pStrgenLstRoot);
144 ENDObjClassInit(strgen)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tcpsrv.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "config.h"
2 #include &lt;stdio.h&gt;
3 #include &lt;stdlib.h&gt;
4 #include &lt;assert.h&gt;
5 #include &lt;string.h&gt;
6 #include &lt;errno.h&gt;
7 #include &lt;unistd.h&gt;
8 #include &lt;stdarg.h&gt;
9 #include &lt;ctype.h&gt;
10 #include &lt;netinet/in.h&gt;
11 #include &lt;netdb.h&gt;
12 #include &lt;pthread.h&gt;
13 #include &lt;sys/types.h&gt;
14 #include &lt;signal.h&gt;
15 #include &lt;sys/socket.h&gt;
16 #if HAVE_FCNTL_H
17 #include &lt;fcntl.h&gt;
18 #endif
19 #include "rsyslog.h"
20 #include "dirty.h"
21 #include "cfsysline.h"
22 #include "module-template.h"
23 #include "net.h"
24 #include "srUtils.h"
25 #include "conf.h"
26 #include "tcpsrv.h"
27 #include "obj.h"
28 #include "glbl.h"
29 #include "netstrms.h"
30 #include "netstrm.h"
31 #include "nssel.h"
32 #include "nspoll.h"
33 #include "errmsg.h"
34 #include "ruleset.h"
35 #include "ratelimit.h"
36 #include "unicode-helper.h"
37 PRAGMA_INGORE_Wswitch_enum
38 MODULE_TYPE_LIB
39 MODULE_TYPE_NOKEEP
40 #define TCPSESS_MAX_DEFAULT 200 #define TCPLSTN_MAX_DEFAULT 20 
41 DEFobjStaticHelpers
42 DEFobjCurrIf(conf)
43 DEFobjCurrIf(glbl)
44 DEFobjCurrIf(ruleset)
45 DEFobjCurrIf(tcps_sess)
46 DEFobjCurrIf(net)
47 DEFobjCurrIf(netstrms)
48 DEFobjCurrIf(netstrm)
49 DEFobjCurrIf(nssel)
50 DEFobjCurrIf(nspoll)
51 DEFobjCurrIf(prop)
52 DEFobjCurrIf(statsobj)
53 static void startWorkerPool(void);
54 static struct wrkrInfo_s {
55 	pthread_t tid;		pthread_cond_t run;
56 	int idx;
57 	tcpsrv_t *pSrv; 	nspoll_t *pPoll;
58 	void *pUsr;
59 	sbool enabled;
60 	long long unsigned numCalled;	} wrkrInfo[4];
61 static sbool bWrkrRunning; static pthread_mutex_t wrkrMut;
62 static pthread_cond_t wrkrIdle;
63 static int wrkrMax = 4;
64 static int wrkrRunning;
65 static rsRetVal ATTR_NONNULL(1, 2)
66 addNewLstnPort(tcpsrv_t *const pThis, tcpLstnParams_t *const cnf_params)
67 {
68 	tcpLstnPortList_t *pEntry;
69 	uchar statname[64];
70 	DEFiRet;
71 	ISOBJ_TYPE_assert(pThis, tcpsrv);
72 	CHKmalloc(pEntry = (tcpLstnPortList_t*)calloc(1, sizeof(tcpLstnPortList_t)));
73 	pEntry-&gt;cnf_params = cnf_params;
74 	strcpy((char*)pEntry-&gt;cnf_params-&gt;dfltTZ, (char*)pThis-&gt;dfltTZ);
75 	pEntry-&gt;cnf_params-&gt;bSPFramingFix = pThis-&gt;bSPFramingFix;
76 	pEntry-&gt;cnf_params-&gt;bPreserveCase = pThis-&gt;bPreserveCase;
77 	pEntry-&gt;pSrv = pThis;
78 	CHKiRet(ratelimitNew(&amp;pEntry-&gt;ratelimiter, "tcperver", NULL));
79 	ratelimitSetLinuxLike(pEntry-&gt;ratelimiter, pThis-&gt;ratelimitInterval, pThis-&gt;ratelimitBurst);
80 	ratelimitSetThreadSafe(pEntry-&gt;ratelimiter);
81 	CHKiRet(statsobj.Construct(&amp;(pEntry-&gt;stats)));
82 	snprintf((char*)statname, sizeof(statname), "%s(%s)", cnf_params-&gt;pszInputName, cnf_params-&gt;pszPort);
83 	statname[sizeof(statname)-1] = '\0'; 	CHKiRet(statsobj.SetName(pEntry-&gt;stats, statname));
84 	CHKiRet(statsobj.SetOrigin(pEntry-&gt;stats, pThis-&gt;pszOrigin));
85 	STATSCOUNTER_INIT(pEntry-&gt;ctrSubmit, pEntry-&gt;mutCtrSubmit);
86 	CHKiRet(statsobj.AddCounter(pEntry-&gt;stats, UCHAR_CONSTANT("submitted"),
87 		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pEntry-&gt;ctrSubmit)));
88 	CHKiRet(statsobj.ConstructFinalize(pEntry-&gt;stats));
89 	pEntry-&gt;pNext = pThis-&gt;pLstnPorts;
90 	pThis-&gt;pLstnPorts = pEntry;
91 finalize_it:
92 	if(iRet != RS_RET_OK) {
93 		if(pEntry != NULL) {
94 			if(pEntry-&gt;cnf_params-&gt;pInputName != NULL) {
95 				prop.Destruct(&amp;pEntry-&gt;cnf_params-&gt;pInputName);
96 			}
97 			if(pEntry-&gt;ratelimiter != NULL) {
98 				ratelimitDestruct(pEntry-&gt;ratelimiter);
99 			}
100 			if(pEntry-&gt;stats != NULL) {
101 				statsobj.Destruct(&amp;pEntry-&gt;stats);
102 			}
103 			free(pEntry);
104 		}
105 	}
106 	RETiRet;
107 }
108 static rsRetVal ATTR_NONNULL(1,2)
109 configureTCPListen(tcpsrv_t *const pThis, tcpLstnParams_t *const cnf_params)
110 {
111 	assert(cnf_params-&gt;pszPort != NULL);
112 	int i;
113 	DEFiRet;
114 	ISOBJ_TYPE_assert(pThis, tcpsrv);
115 	const uchar *pPort = cnf_params-&gt;pszPort;
116 	i = 0;
117 	while(isdigit((int) *pPort)) {
118 		i = i * 10 + *pPort++ - '0';
119 	}
120 	if(i &gt;= 0 &amp;&amp; i &lt;= 65535) {
121 		CHKiRet(addNewLstnPort(pThis, cnf_params));
122 	} else {
123 		LogError(0, NO_ERRCODE, "Invalid TCP listen port %s - ignored.\n", cnf_params-&gt;pszPort);
124 	}
125 finalize_it:
126 	RETiRet;
127 }
128 static rsRetVal
129 TCPSessTblInit(tcpsrv_t *pThis)
130 {
131 	DEFiRet;
132 	ISOBJ_TYPE_assert(pThis, tcpsrv);
133 	assert(pThis-&gt;pSessions == NULL);
134 	DBGPRINTF("Allocating buffer for %d TCP sessions.\n", pThis-&gt;iSessMax);
135 	if((pThis-&gt;pSessions = (tcps_sess_t **) calloc(pThis-&gt;iSessMax, sizeof(tcps_sess_t *))) == NULL) {
136 		DBGPRINTF("Error: TCPSessInit() could not alloc memory for TCP session table.\n");
137 		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
138 	}
139 finalize_it:
140 	RETiRet;
141 }
142 static int
143 TCPSessTblFindFreeSpot(tcpsrv_t *pThis)
144 {
145 	register int i;
146 	ISOBJ_TYPE_assert(pThis, tcpsrv);
147 	for(i = 0 ; i &lt; pThis-&gt;iSessMax ; ++i) {
148 		if(pThis-&gt;pSessions[i] == NULL)
149 			break;
150 	}
151 	return((i &lt; pThis-&gt;iSessMax) ? i : -1);
152 }
153 static int
154 TCPSessGetNxtSess(tcpsrv_t *pThis, int iCurr)
155 {
156 	register int i;
157 	ISOBJ_TYPE_assert(pThis, tcpsrv);
158 	assert(pThis-&gt;pSessions != NULL);
159 	for(i = iCurr + 1 ; i &lt; pThis-&gt;iSessMax ; ++i) {
160 		if(pThis-&gt;pSessions[i] != NULL)
161 			break;
162 	}
163 	return((i &lt; pThis-&gt;iSessMax) ? i : -1);
164 }
165 static void ATTR_NONNULL()
166 deinit_tcp_listener(tcpsrv_t *const pThis)
167 {
168 	int i;
169 	tcpLstnPortList_t *pEntry;
170 	tcpLstnPortList_t *pDel;
171 	ISOBJ_TYPE_assert(pThis, tcpsrv);
172 	if(pThis-&gt;pSessions != NULL) {
173 		if(!pThis-&gt;bUsingEPoll) {
174 			i = TCPSessGetNxtSess(pThis, -1);
175 			while(i != -1) {
176 				tcps_sess.Destruct(&amp;pThis-&gt;pSessions[i]);
177 				i = TCPSessGetNxtSess(pThis, i);
178 			}
179 		}
180 		free(pThis-&gt;pSessions);
181 		pThis-&gt;pSessions = NULL; 	}
182 	pEntry = pThis-&gt;pLstnPorts;
183 	while(pEntry != NULL) {
184 		prop.Destruct(&amp;pEntry-&gt;cnf_params-&gt;pInputName);
185 		free((void*)pEntry-&gt;cnf_params-&gt;pszInputName);
186 		free((void*)pEntry-&gt;cnf_params-&gt;pszPort);
187 		free((void*)pEntry-&gt;cnf_params-&gt;pszAddr);
188 		free((void*)pEntry-&gt;cnf_params-&gt;pszLstnPortFileName);
189 		free((void*)pEntry-&gt;cnf_params);
190 		ratelimitDestruct(pEntry-&gt;ratelimiter);
191 		statsobj.Destruct(&amp;(pEntry-&gt;stats));
192 		pDel = pEntry;
193 		pEntry = pEntry-&gt;pNext;
194 		free(pDel);
195 	}
196 	for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
197 		netstrm.Destruct(pThis-&gt;ppLstn + i);
198 	}
199 }
200 static rsRetVal
201 addTcpLstn(void *pUsr, netstrm_t *pLstn)
202 {
203 	tcpLstnPortList_t *pPortList = (tcpLstnPortList_t *) pUsr;
204 	tcpsrv_t *pThis = pPortList-&gt;pSrv;
205 	DEFiRet;
206 	ISOBJ_TYPE_assert(pThis, tcpsrv);
207 	ISOBJ_TYPE_assert(pLstn, netstrm);
208 	if(pThis-&gt;iLstnCurr &gt;= pThis-&gt;iLstnMax)
209 		ABORT_FINALIZE(RS_RET_MAX_LSTN_REACHED);
210 	pThis-&gt;ppLstn[pThis-&gt;iLstnCurr] = pLstn;
211 	pThis-&gt;ppLstnPort[pThis-&gt;iLstnCurr] = pPortList;
212 	++pThis-&gt;iLstnCurr;
213 finalize_it:
214 	RETiRet;
215 }
216 static rsRetVal
217 initTCPListener(tcpsrv_t *pThis, tcpLstnPortList_t *pPortEntry)
218 {
219 	DEFiRet;
220 	ISOBJ_TYPE_assert(pThis, tcpsrv);
221 	assert(pPortEntry != NULL);
222 	CHKiRet(netstrm.LstnInit(pThis-&gt;pNS, (void*)pPortEntry, addTcpLstn,
223 		pThis-&gt;iSessMax, pPortEntry-&gt;cnf_params));
224 finalize_it:
225 	RETiRet;
226 }
227 static rsRetVal
228 create_tcp_socket(tcpsrv_t *pThis)
229 {
230 	DEFiRet;
231 	rsRetVal localRet;
232 	tcpLstnPortList_t *pEntry;
233 	ISOBJ_TYPE_assert(pThis, tcpsrv);
234 	pEntry = pThis-&gt;pLstnPorts;
235 	while(pEntry != NULL) {
236 		localRet = initTCPListener(pThis, pEntry);
237 		if(localRet != RS_RET_OK) {
238 			LogError(0, localRet, "Could not create tcp listener, ignoring port "
239 			"%s bind-address %s.",
240 			(pEntry-&gt;cnf_params-&gt;pszPort == NULL) ? "**UNSPECIFIED**"
241 				: (const char*) pEntry-&gt;cnf_params-&gt;pszPort,
242 			(pEntry-&gt;cnf_params-&gt;pszAddr == NULL) ? "**UNSPECIFIED**"
243 				: (const char*)pEntry-&gt;cnf_params-&gt;pszAddr);
244 		}
245 		pEntry = pEntry-&gt;pNext;
246 	}
247 	if(TCPSessTblInit(pThis) != 0) {
248 		LogError(0, RS_RET_ERR, "Could not initialize TCP session table, suspending TCP "
249 				"message reception.");
250 		ABORT_FINALIZE(RS_RET_ERR);
251 	}
252 finalize_it:
253 	RETiRet;
254 }
255 static rsRetVal
256 SessAccept(tcpsrv_t *pThis, tcpLstnPortList_t *pLstnInfo, tcps_sess_t **ppSess, netstrm_t *pStrm)
257 {
258 	DEFiRet;
259 	tcps_sess_t *pSess = NULL;
260 	netstrm_t *pNewStrm = NULL;
261 	const tcpLstnParams_t *const cnf_params = pLstnInfo-&gt;cnf_params;
262 	int iSess = -1;
263 	struct sockaddr_storage *addr;
264 	uchar *fromHostFQDN = NULL;
265 	prop_t *fromHostIP;
266 	ISOBJ_TYPE_assert(pThis, tcpsrv);
267 	assert(pLstnInfo != NULL);
268 	CHKiRet(netstrm.AcceptConnReq(pStrm, &amp;pNewStrm));
269 	iSess = TCPSessTblFindFreeSpot(pThis);
270 	if(iSess == -1) {
271 		errno = 0;
272 		LogError(0, RS_RET_MAX_SESS_REACHED, "too many tcp sessions - dropping incoming request");
273 		ABORT_FINALIZE(RS_RET_MAX_SESS_REACHED);
274 	}
275 	if(pThis-&gt;bUseKeepAlive) {
276 	        CHKiRet(netstrm.SetKeepAliveProbes(pNewStrm, pThis-&gt;iKeepAliveProbes));
277 	        CHKiRet(netstrm.SetKeepAliveTime(pNewStrm, pThis-&gt;iKeepAliveTime));
278 	        CHKiRet(netstrm.SetKeepAliveIntvl(pNewStrm, pThis-&gt;iKeepAliveIntvl));
279 		CHKiRet(netstrm.EnableKeepAlive(pNewStrm));
280 	}
281 	if(pThis-&gt;gnutlsPriorityString != NULL) {
282 		CHKiRet(netstrm.SetGnutlsPriorityString(pNewStrm, pThis-&gt;gnutlsPriorityString));
283 	}
284 	CHKiRet(tcps_sess.Construct(&amp;pSess));
285 	CHKiRet(tcps_sess.SetTcpsrv(pSess, pThis));
286 	CHKiRet(tcps_sess.SetLstnInfo(pSess, pLstnInfo));
287 	if(pThis-&gt;OnMsgReceive != NULL)
288 		CHKiRet(tcps_sess.SetOnMsgReceive(pSess, pThis-&gt;OnMsgReceive));
289 	CHKiRet(netstrm.GetRemoteHName(pNewStrm, &amp;fromHostFQDN));
290 	if (!cnf_params-&gt;bPreserveCase) {
291 		uchar *p;
292 		for(p = fromHostFQDN; *p; p++) {
293 			if (isupper((int) *p)) {
294 				*p = tolower((int) *p);
295 			}
296 		}
297 	}
298 	CHKiRet(netstrm.GetRemoteIP(pNewStrm, &amp;fromHostIP));
299 	CHKiRet(netstrm.GetRemAddr(pNewStrm, &amp;addr));
300 	if(!pThis-&gt;pIsPermittedHost((struct sockaddr*) addr, (char*) fromHostFQDN, pThis-&gt;pUsr, pSess-&gt;pUsr)) {
301 		DBGPRINTF("%s is not an allowed sender\n", fromHostFQDN);
302 		if(glbl.GetOptionDisallowWarning(runConf)) {
303 			errno = 0;
304 			LogError(0, RS_RET_HOST_NOT_PERMITTED, "TCP message from disallowed "
305 					"sender %s discarded", fromHostFQDN);
306 		}
307 		ABORT_FINALIZE(RS_RET_HOST_NOT_PERMITTED);
308 	}
309 	CHKiRet(tcps_sess.SetHost(pSess, fromHostFQDN));
310 	fromHostFQDN = NULL; 	CHKiRet(tcps_sess.SetHostIP(pSess, fromHostIP));
311 	CHKiRet(tcps_sess.SetStrm(pSess, pNewStrm));
312 	pNewStrm = NULL; 	CHKiRet(tcps_sess.SetMsgIdx(pSess, 0));
313 	CHKiRet(tcps_sess.ConstructFinalize(pSess));
314 	if(pThis-&gt;pOnSessAccept != NULL) {
315 		CHKiRet(pThis-&gt;pOnSessAccept(pThis, pSess));
316 	}
317 	*ppSess = pSess;
318 	if(!pThis-&gt;bUsingEPoll)
319 		pThis-&gt;pSessions[iSess] = pSess;
320 	pSess = NULL; 
321 finalize_it:
322 	if(iRet != RS_RET_OK) {
323 		if(pSess != NULL)
324 			tcps_sess.Destruct(&amp;pSess);
325 		if(pNewStrm != NULL)
326 			netstrm.Destruct(&amp;pNewStrm);
327 		free(fromHostFQDN);
328 	}
329 	RETiRet;
330 }
331 static void
332 RunCancelCleanup(void *arg)
333 {
334 	nspoll_t **ppPoll = (nspoll_t**) arg;
335 	if (*ppPoll != NULL)
336 		nspoll.Destruct(ppPoll);
337 	pthread_mutex_lock(&amp;wrkrMut);
338 	DBGPRINTF("tcpsrv terminating, waiting for %d workers\n", wrkrRunning);
339 	while(wrkrRunning &gt; 0) {
340 		pthread_cond_wait(&amp;wrkrIdle, &amp;wrkrMut);
341 	}
342 	pthread_mutex_unlock(&amp;wrkrMut);
343 }
344 static void
345 RunSelectCancelCleanup(void *arg)
346 {
347 	nssel_t **ppSel = (nssel_t**) arg;
348 	if(*ppSel != NULL)
349 		nssel.Destruct(ppSel);
350 }
351 static rsRetVal
352 closeSess(tcpsrv_t *pThis, tcps_sess_t **ppSess, nspoll_t *pPoll) {
353 	DEFiRet;
354 	if(pPoll != NULL) {
355 		CHKiRet(nspoll.Ctl(pPoll, (*ppSess)-&gt;pStrm, 0, *ppSess, NSDPOLL_IN, NSDPOLL_DEL));
356 	}
357 	pThis-&gt;pOnRegularClose(*ppSess);
358 	tcps_sess.Destruct(ppSess);
359 finalize_it:
360 	RETiRet;
361 }
362 static rsRetVal
363 doReceive(tcpsrv_t *pThis, tcps_sess_t **ppSess, nspoll_t *pPoll)
364 {
365 	char buf[128*1024]; 	ssize_t iRcvd;
366 	rsRetVal localRet;
367 	DEFiRet;
368 	uchar *pszPeer;
369 	int lenPeer;
370 	int oserr = 0;
371 	ISOBJ_TYPE_assert(pThis, tcpsrv);
372 	prop.GetString((*ppSess)-&gt;fromHostIP, &amp;pszPeer, &amp;lenPeer);
373 	DBGPRINTF("netstream %p with new data from remote peer %s\n", (*ppSess)-&gt;pStrm, pszPeer);
374 	iRet = pThis-&gt;pRcvData(*ppSess, buf, sizeof(buf), &amp;iRcvd, &amp;oserr);
375 	switch(iRet) {
376 	case RS_RET_CLOSED:
377 		if(pThis-&gt;bEmitMsgOnClose) {
378 			errno = 0;
379 			LogError(0, RS_RET_PEER_CLOSED_CONN, "Netstream session %p closed by remote "
380 				"peer %s.\n", (*ppSess)-&gt;pStrm, pszPeer);
381 		}
382 		CHKiRet(closeSess(pThis, ppSess, pPoll));
383 		break;
384 	case RS_RET_RETRY:
385 		break;
386 	case RS_RET_OK:
387 		localRet = tcps_sess.DataRcvd(*ppSess, buf, iRcvd);
388 		if(localRet != RS_RET_OK &amp;&amp; localRet != RS_RET_QUEUE_FULL) {
389 			LogError(oserr, localRet, "Tearing down TCP Session from %s", pszPeer);
390 			CHKiRet(closeSess(pThis, ppSess, pPoll));
391 		}
392 		break;
393 	default:
394 		LogError(oserr, iRet, "netstream session %p from %s will be closed due to error",
395 				(*ppSess)-&gt;pStrm, pszPeer);
396 		CHKiRet(closeSess(pThis, ppSess, pPoll));
397 		break;
398 	}
399 finalize_it:
400 	RETiRet;
401 }
402 static rsRetVal ATTR_NONNULL(1)
403 processWorksetItem(tcpsrv_t *const pThis, nspoll_t *pPoll, const int idx, void *pUsr)
404 {
405 	tcps_sess_t *pNewSess = NULL;
406 	tcpLstnParams_t *cnf_params;
407 	DEFiRet;
408 	DBGPRINTF("tcpsrv: processing item %d, pUsr %p, bAbortConn\n", idx, pUsr);
409 	if(pUsr == pThis-&gt;ppLstn) {
410 		DBGPRINTF("New connect on NSD %p.\n", pThis-&gt;ppLstn[idx]);
411 		iRet = SessAccept(pThis, pThis-&gt;ppLstnPort[idx], &amp;pNewSess, pThis-&gt;ppLstn[idx]);
412 		cnf_params = pThis-&gt;ppLstnPort[idx]-&gt;cnf_params;
413 		if(iRet == RS_RET_OK) {
414 			if(pPoll != NULL) {
415 				CHKiRet(nspoll.Ctl(pPoll, pNewSess-&gt;pStrm, 0, pNewSess, NSDPOLL_IN, NSDPOLL_ADD));
416 			}
417 			DBGPRINTF("New session created with NSD %p.\n", pNewSess);
418 		} else {
419 			DBGPRINTF("tcpsrv: error %d during accept\n", iRet);
420 		}
421 	} else {
422 		pNewSess = (tcps_sess_t*) pUsr;
423 		cnf_params = pNewSess-&gt;pLstnInfo-&gt;cnf_params;
424 		doReceive(pThis, &amp;pNewSess, pPoll);
425 		if(pPoll == NULL &amp;&amp; pNewSess == NULL) {
426 			pThis-&gt;pSessions[idx] = NULL;
427 		}
428 	}
429 finalize_it:
430 	if(iRet != RS_RET_OK) {
431 		LogError(0, iRet, "tcpsrv listener (inputname: '%s') failed "
432 			"to process incoming connection with error %d",
433 			(cnf_params-&gt;pszInputName == NULL) ? (uchar*)"*UNSET*" : cnf_params-&gt;pszInputName, iRet);
434 		srSleep(0,20000); 	}
435 	RETiRet;
436 }
437 static void * ATTR_NONNULL(1)
438 wrkr(void *const myself)
439 {
440 	struct wrkrInfo_s *const me = (struct wrkrInfo_s*) myself;
441 	pthread_mutex_lock(&amp;wrkrMut);
442 	while(1) {
443 		while(me-&gt;pSrv == NULL &amp;&amp; glbl.GetGlobalInputTermState() == 0) {
444 			pthread_cond_wait(&amp;me-&gt;run, &amp;wrkrMut);
445 		}
446 		if(me-&gt;pSrv == NULL) {
447 			assert(glbl.GetGlobalInputTermState() == 1);
448 			break;
449 		}
450 		pthread_mutex_unlock(&amp;wrkrMut);
451 		++me-&gt;numCalled;
452 		processWorksetItem(me-&gt;pSrv, me-&gt;pPoll, me-&gt;idx, me-&gt;pUsr);
453 		pthread_mutex_lock(&amp;wrkrMut);
454 		me-&gt;pSrv = NULL;			--wrkrRunning;
455 		pthread_cond_broadcast(&amp;wrkrIdle);
456 	}
457 	me-&gt;enabled = 0; 	pthread_mutex_unlock(&amp;wrkrMut);
458 	return NULL;
459 }
460 static void
461 waitForWorkers(void)
462 {
463 	pthread_mutex_lock(&amp;wrkrMut);
464 	pthread_cleanup_push(mutexCancelCleanup, &amp;wrkrMut);
465 	while(wrkrRunning &gt; 0) {
466 		pthread_cond_wait(&amp;wrkrIdle, &amp;wrkrMut);
467 	}
468 	pthread_cleanup_pop(1);
469 }
470 static rsRetVal
471 processWorkset(tcpsrv_t *pThis, nspoll_t *pPoll, int numEntries, nsd_epworkset_t workset[])
472 {
473 	int i;
474 	int origEntries = numEntries;
475 	DEFiRet;
476 	DBGPRINTF("tcpsrv: ready to process %d event entries\n", numEntries);
477 	while(numEntries &gt; 0) {
478 		if(glbl.GetGlobalInputTermState() == 1)
479 			ABORT_FINALIZE(RS_RET_FORCE_TERM);
480 		if(numEntries == 1) {
481 			iRet = processWorksetItem(pThis, pPoll, workset[numEntries-1].id, workset[numEntries-1].pUsr);
482 		} else {
483 			pthread_mutex_lock(&amp;wrkrMut);
484 			for(i = 0 ; (i &lt; wrkrMax) &amp;&amp; ((wrkrInfo[i].pSrv != NULL) || (wrkrInfo[i].enabled == 0)) ; ++i)
485 			if(i &lt; wrkrMax) {
486 				wrkrInfo[i].pSrv = pThis;
487 				wrkrInfo[i].pPoll = pPoll;
488 				wrkrInfo[i].idx = workset[numEntries -1].id;
489 				wrkrInfo[i].pUsr = workset[numEntries -1].pUsr;
490 				++wrkrRunning;
491 				pthread_cond_signal(&amp;wrkrInfo[i].run);
492 				pthread_mutex_unlock(&amp;wrkrMut);
493 			} else {
494 				pthread_mutex_unlock(&amp;wrkrMut);
495 				iRet = processWorksetItem(pThis, pPoll, workset[numEntries-1].id,
496 						   workset[numEntries-1].pUsr);
497 			}
498 		}
499 		--numEntries;
500 	}
501 	if(origEntries &gt; 1) {
502 		waitForWorkers();
503 	}
504 finalize_it:
505 	RETiRet;
506 }
507 PRAGMA_DIAGNOSTIC_PUSH
508 PRAGMA_IGNORE_Wempty_body
509 static rsRetVal
510 RunSelect(tcpsrv_t *pThis, nsd_epworkset_t workset[], size_t sizeWorkset)
511 {
512 	DEFiRet;
513 	int nfds;
514 	int i;
515 	int iWorkset;
516 	int iTCPSess;
517 	int bIsReady;
518 	nssel_t *pSel = NULL;
519 	rsRetVal localRet;
520 	ISOBJ_TYPE_assert(pThis, tcpsrv);
521 	pthread_cleanup_push(RunSelectCancelCleanup, (void*) &amp;pSel);
522 	while(1) {
523 		CHKiRet(nssel.Construct(&amp;pSel));
524 		if(pThis-&gt;pszDrvrName != NULL)
525 			CHKiRet(nssel.SetDrvrName(pSel, pThis-&gt;pszDrvrName));
526 		CHKiRet(nssel.ConstructFinalize(pSel));
527 		for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
528 			CHKiRet(nssel.Add(pSel, pThis-&gt;ppLstn[i], NSDSEL_RD));
529 		}
530 		iTCPSess = TCPSessGetNxtSess(pThis, -1);
531 		while(iTCPSess != -1) {
532 			CHKiRet(nssel.Add(pSel, pThis-&gt;pSessions[iTCPSess]-&gt;pStrm, NSDSEL_RD));
533 			DBGPRINTF("tcpsrv process session %d:\n", iTCPSess);
534 			iTCPSess = TCPSessGetNxtSess(pThis, iTCPSess);
535 		}
536 		CHKiRet(nssel.Wait(pSel, &amp;nfds));
537 		if(glbl.GetGlobalInputTermState() == 1)
538 			break; 
539 		iWorkset = 0;
540 		for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
541 			if(glbl.GetGlobalInputTermState() == 1)
542 				ABORT_FINALIZE(RS_RET_FORCE_TERM);
543 			CHKiRet(nssel.IsReady(pSel, pThis-&gt;ppLstn[i], NSDSEL_RD, &amp;bIsReady, &amp;nfds));
544 			if(bIsReady) {
545 				workset[iWorkset].id = i;
546 				workset[iWorkset].pUsr = (void*) pThis-&gt;ppLstn;
547 				++iWorkset;
548 				if(iWorkset &gt;= (int) sizeWorkset) {
549 					processWorkset(pThis, NULL, iWorkset, workset);
550 					iWorkset = 0;
551 				}
552 				--nfds; 			}
553 		}
554 		iTCPSess = TCPSessGetNxtSess(pThis, -1);
555 		while(nfds &amp;&amp; iTCPSess != -1) {
556 			if(glbl.GetGlobalInputTermState() == 1)
557 				ABORT_FINALIZE(RS_RET_FORCE_TERM);
558 			localRet = nssel.IsReady(pSel, pThis-&gt;pSessions[iTCPSess]-&gt;pStrm, NSDSEL_RD,
559 				&amp;bIsReady, &amp;nfds);
560 			if(bIsReady || localRet != RS_RET_OK) {
561 				workset[iWorkset].id = iTCPSess;
562 				workset[iWorkset].pUsr = (void*) pThis-&gt;pSessions[iTCPSess];
563 				++iWorkset;
564 				if(iWorkset &gt;= (int) sizeWorkset) {
565 					processWorkset(pThis, NULL, iWorkset, workset);
566 					iWorkset = 0;
567 				}
568 				if(bIsReady)
569 					--nfds; 			}
570 			iTCPSess = TCPSessGetNxtSess(pThis, iTCPSess);
571 		}
572 		if(iWorkset &gt; 0)
573 			processWorkset(pThis, NULL, iWorkset, workset);
574 		if(pSel != NULL) { 			nssel.Destruct(&amp;pSel);
575 		}
576 	}
577 	pthread_cleanup_pop(1); 
578 	RETiRet;
579 }
580 PRAGMA_DIAGNOSTIC_POP
581 static rsRetVal
582 DoRun(tcpsrv_t *pThis, nspoll_t **ppPoll)
583 {
584 	DEFiRet;
585 	int i;
586 	nsd_epworkset_t workset[128]; 	int numEntries;
587 	nspoll_t *pPoll = NULL;
588 	rsRetVal localRet;
589 	if((localRet = nspoll.Construct(ppPoll)) == RS_RET_OK) {
590 		pPoll = *ppPoll;
591 		if(pThis-&gt;pszDrvrName != NULL)
592 			CHKiRet(nspoll.SetDrvrName(pPoll, pThis-&gt;pszDrvrName));
593 		localRet = nspoll.ConstructFinalize(pPoll);
594 	}
595 	if(localRet != RS_RET_OK) {
596 		DBGPRINTF("tcpsrv could not use epoll() interface, iRet=%d, using select()\n", localRet);
597 		iRet = RunSelect(pThis, workset, sizeof(workset)/sizeof(nsd_epworkset_t));
598 		FINALIZE;
599 	}
600 	DBGPRINTF("tcpsrv uses epoll() interface, nsdpoll driver found\n");
601 	pThis-&gt;bUsingEPoll = RSTRUE;
602 	for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
603 		DBGPRINTF("Trying to add listener %d, pUsr=%p\n", i, pThis-&gt;ppLstn);
604 		CHKiRet(nspoll.Ctl(pPoll, pThis-&gt;ppLstn[i], i, pThis-&gt;ppLstn, NSDPOLL_IN, NSDPOLL_ADD));
605 		DBGPRINTF("Added listener %d\n", i);
606 	}
607 	while(glbl.GetGlobalInputTermState() == 0) {
608 		numEntries = sizeof(workset)/sizeof(nsd_epworkset_t);
609 		localRet = nspoll.Wait(pPoll, -1, &amp;numEntries, workset);
610 		if(glbl.GetGlobalInputTermState() == 1)
611 			break; 
612 		if(localRet != RS_RET_OK)
613 			continue;
614 		processWorkset(pThis, pPoll, numEntries, workset);
615 	}
616 	for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
617 		CHKiRet(nspoll.Ctl(pPoll, pThis-&gt;ppLstn[i], i, pThis-&gt;ppLstn, NSDPOLL_IN, NSDPOLL_DEL));
618 	}
619 finalize_it:
620 	RETiRet;
621 }
622 static rsRetVal
623 Run(tcpsrv_t *pThis)
624 {
625 	DEFiRet;
626 	nspoll_t *pPoll = NULL;
627 	ISOBJ_TYPE_assert(pThis, tcpsrv);
628 	if(pThis-&gt;iLstnCurr == 0) {
629 		dbgprintf("tcpsrv: no listeneres at all (probably init error), terminating\n");
630 		RETiRet; 	}
631 	d_pthread_mutex_lock(&amp;wrkrMut);
632 	if(!bWrkrRunning) {
633 		bWrkrRunning = 1;
634 		startWorkerPool();
635 	}
636 	d_pthread_mutex_unlock(&amp;wrkrMut);
637 	pthread_cleanup_push(RunCancelCleanup, (void*) &amp;pPoll);
638 	iRet = DoRun(pThis, &amp;pPoll);
639 	pthread_cleanup_pop(1);
640 	RETiRet;
641 }
642 BEGINobjConstruct(tcpsrv) 	pThis-&gt;iSessMax = TCPSESS_MAX_DEFAULT;
643 	pThis-&gt;iLstnMax = TCPLSTN_MAX_DEFAULT;
644 	pThis-&gt;addtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER;
645 	pThis-&gt;maxFrameSize = 200000;
646 	pThis-&gt;bDisableLFDelim = 0;
647 	pThis-&gt;discardTruncatedMsg = 0;
648 	pThis-&gt;OnMsgReceive = NULL;
649 	pThis-&gt;dfltTZ[0] = '\0';
650 	pThis-&gt;bSPFramingFix = 0;
651 	pThis-&gt;ratelimitInterval = 0;
652 	pThis-&gt;ratelimitBurst = 10000;
653 	pThis-&gt;bUseFlowControl = 1;
654 	pThis-&gt;pszDrvrName = NULL;
655 	pThis-&gt;bPreserveCase = 1; 	pThis-&gt;DrvrTlsVerifyDepth = 0;
656 ENDobjConstruct(tcpsrv)
657 static rsRetVal
658 tcpsrvConstructFinalize(tcpsrv_t *pThis)
659 {
660 	DEFiRet;
661 	ISOBJ_TYPE_assert(pThis, tcpsrv);
662 	CHKiRet(netstrms.Construct(&amp;pThis-&gt;pNS));
663 	if(pThis-&gt;pszDrvrName != NULL)
664 		CHKiRet(netstrms.SetDrvrName(pThis-&gt;pNS, pThis-&gt;pszDrvrName));
665 	CHKiRet(netstrms.SetDrvrMode(pThis-&gt;pNS, pThis-&gt;iDrvrMode));
666 	CHKiRet(netstrms.SetDrvrCheckExtendedKeyUsage(pThis-&gt;pNS, pThis-&gt;DrvrChkExtendedKeyUsage));
667 	CHKiRet(netstrms.SetDrvrPrioritizeSAN(pThis-&gt;pNS, pThis-&gt;DrvrPrioritizeSan));
668 	CHKiRet(netstrms.SetDrvrTlsVerifyDepth(pThis-&gt;pNS, pThis-&gt;DrvrTlsVerifyDepth));
669 	if(pThis-&gt;pszDrvrAuthMode != NULL)
670 		CHKiRet(netstrms.SetDrvrAuthMode(pThis-&gt;pNS, pThis-&gt;pszDrvrAuthMode));
671 	CHKiRet(netstrms.SetDrvrPermitExpiredCerts(pThis-&gt;pNS, pThis-&gt;pszDrvrPermitExpiredCerts));
672 	CHKiRet(netstrms.SetDrvrTlsCAFile(pThis-&gt;pNS, pThis-&gt;pszDrvrCAFile));
673 	CHKiRet(netstrms.SetDrvrTlsKeyFile(pThis-&gt;pNS, pThis-&gt;pszDrvrKeyFile));
674 	CHKiRet(netstrms.SetDrvrTlsCertFile(pThis-&gt;pNS, pThis-&gt;pszDrvrCertFile));
675 	if(pThis-&gt;pPermPeers != NULL)
676 		CHKiRet(netstrms.SetDrvrPermPeers(pThis-&gt;pNS, pThis-&gt;pPermPeers));
677 	if(pThis-&gt;gnutlsPriorityString != NULL)
678 		CHKiRet(netstrms.SetDrvrGnutlsPriorityString(pThis-&gt;pNS, pThis-&gt;gnutlsPriorityString));
679 	CHKiRet(netstrms.ConstructFinalize(pThis-&gt;pNS));
680 	CHKmalloc(pThis-&gt;ppLstn = calloc(pThis-&gt;iLstnMax, sizeof(netstrm_t*)));
681 	CHKmalloc(pThis-&gt;ppLstnPort = calloc(pThis-&gt;iLstnMax, sizeof(tcpLstnPortList_t*)));
682 	iRet = pThis-&gt;OpenLstnSocks(pThis);
683 finalize_it:
684 	if(iRet != RS_RET_OK) {
685 		if(pThis-&gt;pNS != NULL)
686 			netstrms.Destruct(&amp;pThis-&gt;pNS);
687 		LogError(0, iRet, "tcpsrv could not create listener (inputname: '%s')",
688 				(pThis-&gt;pszInputName == NULL) ? (uchar*)"*UNSET*" : pThis-&gt;pszInputName);
689 	}
690 	RETiRet;
691 }
692 BEGINobjDestruct(tcpsrv) CODESTARTobjDestruct(tcpsrv)
693 	if(pThis-&gt;OnDestruct != NULL)
694 		pThis-&gt;OnDestruct(pThis-&gt;pUsr);
695 	deinit_tcp_listener(pThis);
696 	if(pThis-&gt;pNS != NULL)
697 		netstrms.Destruct(&amp;pThis-&gt;pNS);
698 	free(pThis-&gt;pszDrvrName);
699 	free(pThis-&gt;pszDrvrAuthMode);
700 	free(pThis-&gt;pszDrvrPermitExpiredCerts);
701 	free(pThis-&gt;pszDrvrCAFile);
702 	free(pThis-&gt;pszDrvrKeyFile);
703 	free(pThis-&gt;pszDrvrCertFile);
704 	free(pThis-&gt;ppLstn);
705 	free(pThis-&gt;ppLstnPort);
706 	free(pThis-&gt;pszInputName);
707 	free(pThis-&gt;pszOrigin);
708 ENDobjDestruct(tcpsrv)
709 BEGINobjDebugPrint(tcpsrv) CODESTARTobjDebugPrint(tcpsrv)
710 ENDobjDebugPrint(tcpsrv)
711 static rsRetVal
712 SetCBIsPermittedHost(tcpsrv_t *pThis, int (*pCB)(struct sockaddr *addr, char *fromHostFQDN, void*, void*))
713 {
714 	DEFiRet;
715 	pThis-&gt;pIsPermittedHost = pCB;
716 	RETiRet;
717 }
718 static rsRetVal
719 SetCBRcvData(tcpsrv_t *pThis, rsRetVal (*pRcvData)(tcps_sess_t*, char*, size_t, ssize_t*, int*))
720 {
721 	DEFiRet;
722 	pThis-&gt;pRcvData = pRcvData;
723 	RETiRet;
724 }
725 static rsRetVal
726 SetCBOnListenDeinit(tcpsrv_t *pThis, rsRetVal (*pCB)(void*))
727 {
728 	DEFiRet;
729 	pThis-&gt;pOnListenDeinit = pCB;
730 	RETiRet;
731 }
732 static rsRetVal
733 SetCBOnSessAccept(tcpsrv_t *pThis, rsRetVal (*pCB)(tcpsrv_t*, tcps_sess_t*))
734 {
735 	DEFiRet;
736 	pThis-&gt;pOnSessAccept = pCB;
737 	RETiRet;
738 }
739 static rsRetVal
740 SetCBOnDestruct(tcpsrv_t *pThis, rsRetVal (*pCB)(void*))
741 {
742 	DEFiRet;
743 	pThis-&gt;OnDestruct = pCB;
744 	RETiRet;
745 }
746 static rsRetVal
747 SetCBOnSessConstructFinalize(tcpsrv_t *pThis, rsRetVal (*pCB)(void*))
748 {
749 	DEFiRet;
750 	pThis-&gt;OnSessConstructFinalize = pCB;
751 	RETiRet;
752 }
753 static rsRetVal
754 SetCBOnSessDestruct(tcpsrv_t *pThis, rsRetVal (*pCB)(void*))
755 {
756 	DEFiRet;
757 	pThis-&gt;pOnSessDestruct = pCB;
758 	RETiRet;
759 }
760 static rsRetVal
761 SetCBOnRegularClose(tcpsrv_t *pThis, rsRetVal (*pCB)(tcps_sess_t*))
762 {
763 	DEFiRet;
764 	pThis-&gt;pOnRegularClose = pCB;
765 	RETiRet;
766 }
767 static rsRetVal
768 SetCBOnErrClose(tcpsrv_t *pThis, rsRetVal (*pCB)(tcps_sess_t*))
769 {
770 	DEFiRet;
771 	pThis-&gt;pOnErrClose = pCB;
772 	RETiRet;
773 }
774 static rsRetVal
775 SetCBOpenLstnSocks(tcpsrv_t *pThis, rsRetVal (*pCB)(tcpsrv_t*))
776 {
777 	DEFiRet;
778 	pThis-&gt;OpenLstnSocks = pCB;
779 	RETiRet;
780 }
781 static rsRetVal
782 SetUsrP(tcpsrv_t *pThis, void *pUsr)
783 {
784 	DEFiRet;
785 	pThis-&gt;pUsr = pUsr;
786 	RETiRet;
787 }
788 static rsRetVal
789 SetKeepAlive(tcpsrv_t *pThis, int iVal)
790 {
791 	DEFiRet;
792 	DBGPRINTF("tcpsrv: keep-alive set to %d\n", iVal);
793 	pThis-&gt;bUseKeepAlive = iVal;
794 	RETiRet;
795 }
796 static rsRetVal
797 SetKeepAliveIntvl(tcpsrv_t *pThis, int iVal)
798 {
799 	DEFiRet;
800 	DBGPRINTF("tcpsrv: keep-alive interval set to %d\n", iVal);
801 	pThis-&gt;iKeepAliveIntvl = iVal;
802 	RETiRet;
803 }
804 static rsRetVal
805 SetKeepAliveProbes(tcpsrv_t *pThis, int iVal)
806 {
807 	DEFiRet;
808 	DBGPRINTF("tcpsrv: keep-alive probes set to %d\n", iVal);
809 	pThis-&gt;iKeepAliveProbes = iVal;
810 	RETiRet;
811 }
812 static rsRetVal
813 SetKeepAliveTime(tcpsrv_t *pThis, int iVal)
814 {
815 	DEFiRet;
816 	DBGPRINTF("tcpsrv: keep-alive timeout set to %d\n", iVal);
817 	pThis-&gt;iKeepAliveTime = iVal;
818 	RETiRet;
819 }
820 static rsRetVal
821 SetGnutlsPriorityString(tcpsrv_t *pThis, uchar *iVal)
822 {
823 	DEFiRet;
824 	DBGPRINTF("tcpsrv: gnutlsPriorityString set to %s\n",
825 		(iVal == NULL) ? "(null)" : (const char*) iVal);
826 	pThis-&gt;gnutlsPriorityString = iVal;
827 	RETiRet;
828 }
829 static rsRetVal
830 SetOnMsgReceive(tcpsrv_t *pThis, rsRetVal (*OnMsgReceive)(tcps_sess_t*, uchar*, int))
831 {
832 	DEFiRet;
833 	assert(OnMsgReceive != NULL);
834 	pThis-&gt;OnMsgReceive = OnMsgReceive;
835 	RETiRet;
836 }
837 static rsRetVal
838 SetbDisableLFDelim(tcpsrv_t *pThis, int bVal)
839 {
840 	DEFiRet;
841 	ISOBJ_TYPE_assert(pThis, tcpsrv);
842 	pThis-&gt;bDisableLFDelim = bVal;
843 	RETiRet;
844 }
845 static rsRetVal
846 SetDiscardTruncatedMsg(tcpsrv_t *pThis, int discard)
847 {
848 	DEFiRet;
849 	ISOBJ_TYPE_assert(pThis, tcpsrv);
850 	pThis-&gt;discardTruncatedMsg = discard;
851 	RETiRet;
852 }
853 static rsRetVal
854 SetAddtlFrameDelim(tcpsrv_t *pThis, int iDelim)
855 {
856 	DEFiRet;
857 	ISOBJ_TYPE_assert(pThis, tcpsrv);
858 	pThis-&gt;addtlFrameDelim = iDelim;
859 	RETiRet;
860 }
861 static rsRetVal
862 SetMaxFrameSize(tcpsrv_t *pThis, int maxFrameSize)
863 {
864 	DEFiRet;
865 	ISOBJ_TYPE_assert(pThis, tcpsrv);
866 	pThis-&gt;maxFrameSize = maxFrameSize;
867 	RETiRet;
868 }
869 static rsRetVal
870 SetDfltTZ(tcpsrv_t *const pThis, uchar *const tz)
871 {
872 	DEFiRet;
873 	ISOBJ_TYPE_assert(pThis, tcpsrv);
874 	strncpy((char*)pThis-&gt;dfltTZ, (char*)tz, sizeof(pThis-&gt;dfltTZ));
875 	pThis-&gt;dfltTZ[sizeof(pThis-&gt;dfltTZ)-1] = '\0';
876 	RETiRet;
877 }
878 static rsRetVal
879 SetbSPFramingFix(tcpsrv_t *pThis, const sbool val)
880 {
881 	DEFiRet;
882 	ISOBJ_TYPE_assert(pThis, tcpsrv);
883 	pThis-&gt;bSPFramingFix = val;
884 	RETiRet;
885 }
886 static rsRetVal
887 SetOrigin(tcpsrv_t *pThis, uchar *origin)
888 {
889 	DEFiRet;
890 	free(pThis-&gt;pszOrigin);
891 	pThis-&gt;pszOrigin = (origin == NULL) ? NULL : ustrdup(origin);
892 	RETiRet;
893 }
894 static rsRetVal
895 SetInputName(tcpsrv_t *const pThis,tcpLstnParams_t *const cnf_params, const uchar *const name)
896 {
897 	DEFiRet;
898 	ISOBJ_TYPE_assert(pThis, tcpsrv);
899 	if(name == NULL)
900 		cnf_params-&gt;pszInputName = NULL;
901 	else
902 		CHKmalloc(cnf_params-&gt;pszInputName = ustrdup(name));
903 	free(pThis-&gt;pszInputName); 	pThis-&gt;pszInputName = ustrdup("imtcp"); 
904 	CHKiRet(prop.Construct(&amp;cnf_params-&gt;pInputName));
905 	CHKiRet(prop.SetString(cnf_params-&gt;pInputName, cnf_params-&gt;pszInputName, ustrlen(cnf_params-&gt;pszInputName)));
906 	CHKiRet(prop.ConstructFinalize(cnf_params-&gt;pInputName));
907 finalize_it:
908 	RETiRet;
909 }
910 static rsRetVal
911 SetLinuxLikeRatelimiters(tcpsrv_t *pThis, unsigned int ratelimitInterval, unsigned int ratelimitBurst)
912 {
913 	DEFiRet;
914 	pThis-&gt;ratelimitInterval = ratelimitInterval;
915 	pThis-&gt;ratelimitBurst = ratelimitBurst;
916 	RETiRet;
917 }
918 static rsRetVal
919 SetNotificationOnRemoteClose(tcpsrv_t *pThis, int bNewVal)
920 {
921 	DEFiRet;
922 	pThis-&gt;bEmitMsgOnClose = bNewVal;
923 	RETiRet;
924 }
925 static rsRetVal
926 SetDrvrMode(tcpsrv_t *pThis, const int iMode)
927 {
928 	DEFiRet;
929 	ISOBJ_TYPE_assert(pThis, tcpsrv);
930 	pThis-&gt;iDrvrMode = iMode;
931 	RETiRet;
932 }
933 static rsRetVal
934 SetDrvrName(tcpsrv_t *pThis, uchar *const name)
935 {
936 	DEFiRet;
937 	ISOBJ_TYPE_assert(pThis, tcpsrv);
938 	free(pThis-&gt;pszDrvrName);
939 	CHKmalloc(pThis-&gt;pszDrvrName = ustrdup(name));
940 finalize_it:
941 	RETiRet;
942 }
943 static rsRetVal
944 SetDrvrAuthMode(tcpsrv_t *pThis, uchar *const mode)
945 {
946 	DEFiRet;
947 	ISOBJ_TYPE_assert(pThis, tcpsrv);
948 	CHKmalloc(pThis-&gt;pszDrvrAuthMode = ustrdup(mode));
949 finalize_it:
950 	RETiRet;
951 }
952 static rsRetVal
953 SetDrvrPermitExpiredCerts(tcpsrv_t *pThis, uchar *mode)
954 {
955 	DEFiRet;
956 	ISOBJ_TYPE_assert(pThis, tcpsrv);
957 	if (mode != NULL) {
958 		CHKmalloc(pThis-&gt;pszDrvrPermitExpiredCerts = ustrdup(mode));
959 	}
960 finalize_it:
961 	RETiRet;
962 }
963 static rsRetVal
964 SetDrvrCAFile(tcpsrv_t *const pThis, uchar *const mode)
965 {
966 	DEFiRet;
967 	ISOBJ_TYPE_assert(pThis, tcpsrv);
968 	if (mode != NULL) {
969 		CHKmalloc(pThis-&gt;pszDrvrCAFile = ustrdup(mode));
970 	}
971 finalize_it:
972 	RETiRet;
973 }
974 static rsRetVal
975 SetDrvrKeyFile(tcpsrv_t *pThis, uchar *mode)
976 {
977 	DEFiRet;
978 	ISOBJ_TYPE_assert(pThis, tcpsrv);
979 	if (mode != NULL) {
980 		CHKmalloc(pThis-&gt;pszDrvrKeyFile = ustrdup(mode));
981 	}
982 finalize_it:
983 	RETiRet;
984 }
985 static rsRetVal
986 SetDrvrCertFile(tcpsrv_t *pThis, uchar *mode)
987 {
988 	DEFiRet;
989 	ISOBJ_TYPE_assert(pThis, tcpsrv);
990 	if (mode != NULL) {
991 		CHKmalloc(pThis-&gt;pszDrvrCertFile = ustrdup(mode));
992 	}
993 finalize_it:
994 	RETiRet;
995 }
996 static rsRetVal
997 SetDrvrPermPeers(tcpsrv_t *pThis, permittedPeers_t *pPermPeers)
998 {
999 	DEFiRet;
1000 	ISOBJ_TYPE_assert(pThis, tcpsrv);
1001 	pThis-&gt;pPermPeers = pPermPeers;
1002 	RETiRet;
1003 }
1004 static rsRetVal
1005 SetDrvrCheckExtendedKeyUsage(tcpsrv_t *pThis, int ChkExtendedKeyUsage)
1006 {
1007 	DEFiRet;
1008 	ISOBJ_TYPE_assert(pThis, tcpsrv);
1009 	pThis-&gt;DrvrChkExtendedKeyUsage = ChkExtendedKeyUsage;
1010 	RETiRet;
1011 }
1012 static rsRetVal
1013 SetDrvrPrioritizeSAN(tcpsrv_t *pThis, int prioritizeSan)
1014 {
1015 	DEFiRet;
1016 	ISOBJ_TYPE_assert(pThis, tcpsrv);
1017 	pThis-&gt;DrvrPrioritizeSan = prioritizeSan;
1018 	RETiRet;
1019 }
1020 static rsRetVal
1021 SetDrvrTlsVerifyDepth(tcpsrv_t *pThis, int verifyDepth)
1022 {
1023 	DEFiRet;
1024 	ISOBJ_TYPE_assert(pThis, tcpsrv);
1025 	pThis-&gt;DrvrTlsVerifyDepth = verifyDepth;
1026 	RETiRet;
1027 }
1028 static rsRetVal
1029 SetLstnMax(tcpsrv_t *pThis, int iMax)
1030 {
1031 	DEFiRet;
1032 	ISOBJ_TYPE_assert(pThis, tcpsrv);
1033 	pThis-&gt;iLstnMax = iMax;
1034 	RETiRet;
1035 }
1036 static rsRetVal
1037 SetUseFlowControl(tcpsrv_t *pThis, int bUseFlowControl)
1038 {
1039 	DEFiRet;
1040 	ISOBJ_TYPE_assert(pThis, tcpsrv);
1041 	pThis-&gt;bUseFlowControl = bUseFlowControl;
1042 	RETiRet;
1043 }
1044 static rsRetVal
1045 SetSessMax(tcpsrv_t *pThis, int iMax)
1046 {
1047 	DEFiRet;
1048 	ISOBJ_TYPE_assert(pThis, tcpsrv);
1049 	pThis-&gt;iSessMax = iMax;
1050 	RETiRet;
1051 }
1052 static rsRetVal
1053 SetPreserveCase(tcpsrv_t *pThis, int bPreserveCase)
1054 {
1055 	DEFiRet;
1056 <a name="0"></a>	ISOBJ_TYPE_assert(pThis, tcpsrv);
1057 	pThis-&gt; bPreserveCase = bPreserveCase;
1058 	RETiRet;
1059 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
1060 BEGINobjQueryInterface(tcpsrv)
1061 CODESTARTobjQueryInterface(tcpsrv)
1062 	if(pIf-&gt;ifVersion != tcpsrvCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
1063 	}
1064 	pIf-&gt;DebugPrint = tcpsrvDebugPrint;
1065 	pIf-&gt;Construct = tcpsrvConstruct;
1066 	pIf-&gt;ConstructFinalize = tcpsrvConstructFinalize;
1067 	pIf-&gt;Destruct = tcpsrvDestruct;
1068 	pIf-&gt;configureTCPListen = configureTCPListen;
1069 	pIf-&gt;create_tcp_socket = create_tcp_socket;
1070 	pIf-&gt;Run = Run;
1071 	pIf-&gt;SetKeepAlive = SetKeepAlive;
1072 	pIf-&gt;SetKeepAliveIntvl = SetKeepAliveIntvl;</b></font>
1073 	pIf-&gt;SetKeepAliveProbes = SetKeepAliveProbes;
1074 	pIf-&gt;SetKeepAliveTime = SetKeepAliveTime;
1075 	pIf-&gt;SetGnutlsPriorityString = SetGnutlsPriorityString;
1076 	pIf-&gt;SetUsrP = SetUsrP;
1077 	pIf-&gt;SetInputName = SetInputName;
1078 	pIf-&gt;SetOrigin = SetOrigin;
1079 	pIf-&gt;SetDfltTZ = SetDfltTZ;
1080 	pIf-&gt;SetbSPFramingFix = SetbSPFramingFix;
1081 	pIf-&gt;SetAddtlFrameDelim = SetAddtlFrameDelim;
1082 	pIf-&gt;SetMaxFrameSize = SetMaxFrameSize;
1083 	pIf-&gt;SetbDisableLFDelim = SetbDisableLFDelim;
1084 	pIf-&gt;SetDiscardTruncatedMsg = SetDiscardTruncatedMsg;
1085 	pIf-&gt;SetSessMax = SetSessMax;
1086 	pIf-&gt;SetUseFlowControl = SetUseFlowControl;
1087 	pIf-&gt;SetLstnMax = SetLstnMax;
1088 	pIf-&gt;SetDrvrMode = SetDrvrMode;
1089 	pIf-&gt;SetDrvrAuthMode = SetDrvrAuthMode;
1090 	pIf-&gt;SetDrvrPermitExpiredCerts = SetDrvrPermitExpiredCerts;
1091 	pIf-&gt;SetDrvrCAFile = SetDrvrCAFile;
1092 	pIf-&gt;SetDrvrKeyFile = SetDrvrKeyFile;
1093 	pIf-&gt;SetDrvrCertFile = SetDrvrCertFile;
1094 	pIf-&gt;SetDrvrName = SetDrvrName;
1095 	pIf-&gt;SetDrvrPermPeers = SetDrvrPermPeers;
1096 	pIf-&gt;SetCBIsPermittedHost = SetCBIsPermittedHost;
1097 	pIf-&gt;SetCBOpenLstnSocks = SetCBOpenLstnSocks;
1098 	pIf-&gt;SetCBRcvData = SetCBRcvData;
1099 	pIf-&gt;SetCBOnListenDeinit = SetCBOnListenDeinit;
1100 	pIf-&gt;SetCBOnSessAccept = SetCBOnSessAccept;
1101 	pIf-&gt;SetCBOnSessConstructFinalize = SetCBOnSessConstructFinalize;
1102 	pIf-&gt;SetCBOnSessDestruct = SetCBOnSessDestruct;
1103 	pIf-&gt;SetCBOnDestruct = SetCBOnDestruct;
1104 	pIf-&gt;SetCBOnRegularClose = SetCBOnRegularClose;
1105 	pIf-&gt;SetCBOnErrClose = SetCBOnErrClose;
1106 	pIf-&gt;SetOnMsgReceive = SetOnMsgReceive;
1107 	pIf-&gt;SetLinuxLikeRatelimiters = SetLinuxLikeRatelimiters;
1108 	pIf-&gt;SetNotificationOnRemoteClose = SetNotificationOnRemoteClose;
1109 	pIf-&gt;SetPreserveCase = SetPreserveCase;
1110 	pIf-&gt;SetDrvrCheckExtendedKeyUsage = SetDrvrCheckExtendedKeyUsage;
1111 	pIf-&gt;SetDrvrPrioritizeSAN = SetDrvrPrioritizeSAN;
1112 	pIf-&gt;SetDrvrTlsVerifyDepth = SetDrvrTlsVerifyDepth;
1113 finalize_it:
1114 ENDobjQueryInterface(tcpsrv)
1115 BEGINObjClassExit(tcpsrv, OBJ_IS_LOADABLE_MODULE) CODESTARTObjClassExit(tcpsrv)
1116 	objRelease(tcps_sess, DONT_LOAD_LIB);
1117 	objRelease(conf, CORE_COMPONENT);
1118 	objRelease(prop, CORE_COMPONENT);
1119 	objRelease(statsobj, CORE_COMPONENT);
1120 	objRelease(ruleset, CORE_COMPONENT);
1121 	objRelease(glbl, CORE_COMPONENT);
1122 	objRelease(netstrms, DONT_LOAD_LIB);
1123 	objRelease(nssel, DONT_LOAD_LIB);
1124 	objRelease(netstrm, LM_NETSTRMS_FILENAME);
1125 	objRelease(net, LM_NET_FILENAME);
1126 ENDObjClassExit(tcpsrv)
1127 BEGINObjClassInit(tcpsrv, 1, OBJ_IS_LOADABLE_MODULE) 	CHKiRet(objUse(net, LM_NET_FILENAME));
1128 	CHKiRet(objUse(netstrms, LM_NETSTRMS_FILENAME));
1129 	CHKiRet(objUse(netstrm, DONT_LOAD_LIB));
1130 	CHKiRet(objUse(nssel, DONT_LOAD_LIB));
1131 	CHKiRet(objUse(nspoll, DONT_LOAD_LIB));
1132 	CHKiRet(objUse(tcps_sess, DONT_LOAD_LIB));
1133 	CHKiRet(objUse(conf, CORE_COMPONENT));
1134 	CHKiRet(objUse(glbl, CORE_COMPONENT));
1135 	CHKiRet(objUse(ruleset, CORE_COMPONENT));
1136 	CHKiRet(objUse(statsobj, CORE_COMPONENT));
1137 	CHKiRet(objUse(prop, CORE_COMPONENT));
1138 	OBJSetMethodHandler(objMethod_DEBUGPRINT, tcpsrvDebugPrint);
1139 	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, tcpsrvConstructFinalize);
1140 ENDObjClassInit(tcpsrv)
1141 static void
1142 startWorkerPool(void)
1143 {
1144 	int i;
1145 	int r;
1146 	pthread_attr_t sessThrdAttr;
1147 	sigset_t sigSet, sigSetSave;
1148 	sigfillset(&amp;sigSet);
1149 	pthread_sigmask(SIG_SETMASK, &amp;sigSet, &amp;sigSetSave);
1150 	wrkrRunning = 0;
1151 	pthread_cond_init(&amp;wrkrIdle, NULL);
1152 	pthread_attr_init(&amp;sessThrdAttr);
1153 	pthread_attr_setstacksize(&amp;sessThrdAttr, 4096*1024);
1154 	for(i = 0 ; i &lt; wrkrMax ; ++i) {
1155 		pthread_cond_init(&amp;wrkrInfo[i].run, NULL);
1156 		wrkrInfo[i].pSrv = NULL;
1157 		wrkrInfo[i].numCalled = 0;
1158 		r = pthread_create(&amp;wrkrInfo[i].tid, &amp;sessThrdAttr, wrkr, &amp;(wrkrInfo[i]));
1159 		if(r == 0) {
1160 			wrkrInfo[i].enabled = 1;
1161 		} else {
1162 			LogError(r, NO_ERRCODE, "tcpsrv error creating thread");
1163 		}
1164 	}
1165 	pthread_attr_destroy(&amp;sessThrdAttr);
1166 	pthread_sigmask(SIG_SETMASK, &amp;sigSetSave, NULL);
1167 }
1168 static void
1169 stopWorkerPool(void)
1170 {
1171 	int i;
1172 	for(i = 0 ; i &lt; wrkrMax ; ++i) {
1173 		pthread_mutex_lock(&amp;wrkrMut);
1174 		pthread_cond_signal(&amp;wrkrInfo[i].run); 		pthread_mutex_unlock(&amp;wrkrMut);
1175 		pthread_join(wrkrInfo[i].tid, NULL);
1176 		DBGPRINTF("tcpsrv: info: worker %d was called %llu times\n", i, wrkrInfo[i].numCalled);
1177 		pthread_cond_destroy(&amp;wrkrInfo[i].run);
1178 	}
1179 	pthread_cond_destroy(&amp;wrkrIdle);
1180 }
1181 BEGINmodExit
1182 CODESTARTmodExit
1183 	if(bWrkrRunning) {
1184 		stopWorkerPool();
1185 		bWrkrRunning = 0;
1186 	}
1187 	tcpsrvClassExit();
1188 	tcps_sessClassExit();
1189 	pthread_mutex_destroy(&amp;wrkrMut);
1190 ENDmodExit
1191 BEGINqueryEtryPt
1192 CODESTARTqueryEtryPt
1193 CODEqueryEtryPt_STD_LIB_QUERIES
1194 ENDqueryEtryPt
1195 BEGINmodInit()
1196 CODESTARTmodInit
1197 	pthread_mutex_init(&amp;wrkrMut, NULL);
1198 	bWrkrRunning = 0;
1199 	CHKiRet(tcps_sessClassInit(pModInfo));
1200 	CHKiRet(tcpsrvClassInit(pModInfo)); ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
