<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for strgen.c &amp; tcpsrv.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for strgen.c &amp; tcpsrv.c
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>strgen.c (12.745098%)<th>tcpsrv.c (1.3415892%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(210-234)<td><a href="#" name="0">(1550-1577)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>strgen.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include "rsyslog.h"
#include "msg.h"
#include "obj.h"
#include "errmsg.h"
#include "strgen.h"
#include "ruleset.h"
#include "unicode-helper.h"
#include "cfsysline.h"
DEFobjStaticHelpers
DEFobjCurrIf(glbl)
DEFobjCurrIf(ruleset)
strgenList_t *pStrgenLstRoot = NULL;
static rsRetVal
InitStrgenList(strgenList_t **pListRoot)
{
	*pListRoot = NULL;
	return RS_RET_OK;
}
static rsRetVal
DestructStrgenList(strgenList_t **ppListRoot)
{
	strgenList_t *pStrgenLst;
	strgenList_t *pStrgenLstDel;
	pStrgenLst = *ppListRoot;
	while(pStrgenLst != NULL) {
		pStrgenLstDel = pStrgenLst;
		pStrgenLst = pStrgenLst-&gt;pNext;
		free(pStrgenLstDel);
	}
	*ppListRoot = NULL;
	return RS_RET_OK;
}
static rsRetVal
AddStrgenToList(strgenList_t **ppListRoot, strgen_t *pStrgen)
{
	strgenList_t *pThis;
	strgenList_t *pTail;
	DEFiRet;
	CHKmalloc(pThis = malloc(sizeof(strgenList_t)));
	pThis-&gt;pStrgen = pStrgen;
	pThis-&gt;pNext = NULL;
	if(*ppListRoot == NULL) {
		pThis-&gt;pNext = *ppListRoot;
		*ppListRoot = pThis;
	} else {
		for(pTail = *ppListRoot ; pTail-&gt;pNext != NULL ; pTail = pTail-&gt;pNext)
		pTail-&gt;pNext = pThis;
	}
finalize_it:
	RETiRet;
}
static rsRetVal
FindStrgen(strgen_t **ppStrgen, uchar *pName)
{
	strgenList_t *pThis;
	DEFiRet;
	for(pThis = pStrgenLstRoot ; pThis != NULL ; pThis = pThis-&gt;pNext) {
		if(ustrcmp(pThis-&gt;pStrgen-&gt;pName, pName) == 0) {
			*ppStrgen = pThis-&gt;pStrgen;
			FINALIZE;			}
	}
	iRet = RS_RET_PARSER_NOT_FOUND;
finalize_it:
	RETiRet;
}
BEGINobjConstruct(strgen) ENDobjConstruct(strgen)
static rsRetVal
strgenConstructFinalize(strgen_t *pThis)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strgen);
	CHKiRet(AddStrgenToList(&amp;pStrgenLstRoot, pThis));
	DBGPRINTF("Strgen '%s' added to list of available strgens.\n", pThis-&gt;pName);
finalize_it:
	RETiRet;
}
PROTOTYPEobjDestruct(strgen);
BEGINobjDestruct(strgen) CODESTARTobjDestruct(strgen)
	dbgprintf("destructing strgen '%s'\n", pThis-&gt;pName);
	free(pThis-&gt;pName);
ENDobjDestruct(strgen)
static rsRetVal
SetName(strgen_t *pThis, uchar *name)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, strgen);
	assert(name != NULL);
	if(pThis-&gt;pName != NULL) {
		free(pThis-&gt;pName);
		pThis-&gt;pName = NULL;
	}
	CHKmalloc(pThis-&gt;pName = ustrdup(name));
finalize_it:
	RETiRet;
}
static rsRetVal
SetModPtr(strgen_t *pThis, modInfo_t *pMod)
{
	ISOBJ_TYPE_assert(pThis, strgen);
	assert(pMod != NULL);
<a name="0"></a>	assert(pThis-&gt;pModule == NULL);
	pThis-&gt;pModule = pMod;
	return RS_RET_OK;
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
BEGINobjQueryInterface(strgen)
CODESTARTobjQueryInterface(strgen)
	if(pIf-&gt;ifVersion != strgenCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;Construct = strgenConstruct;
	pIf-&gt;ConstructFinalize = strgenConstructFinalize;
	pIf-&gt;Destruct = strgenDestruct;
	pIf-&gt;SetName = SetName;
	pIf-&gt;SetModPtr = SetModPtr;
	pIf-&gt;InitStrgenList = InitStrgenList;
	pIf-&gt;DestructStrgenList = DestructStrgenList;
	pIf-&gt;AddStrgenToList = AddStrgenToList;
	pIf-&gt;FindStrgen = FindStrgen;</b></font>
finalize_it:
ENDobjQueryInterface(strgen)
static void
destroyMasterStrgenList(void)
{
	strgenList_t *pStrgenLst;
	strgenList_t *pStrgenLstDel;
	pStrgenLst = pStrgenLstRoot;
	while(pStrgenLst != NULL) {
		strgenDestruct(&amp;pStrgenLst-&gt;pStrgen);
		pStrgenLstDel = pStrgenLst;
		pStrgenLst = pStrgenLst-&gt;pNext;
		free(pStrgenLstDel);
	}
}
BEGINObjClassExit(strgen, OBJ_IS_CORE_MODULE) 	destroyMasterStrgenList();
	objRelease(glbl, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
ENDObjClassExit(strgen)
BEGINObjClassInit(strgen, 1, OBJ_IS_CORE_MODULE) 	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	InitStrgenList(&amp;pStrgenLstRoot);
ENDObjClassInit(strgen)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tcpsrv.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#include "config.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;ctype.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/socket.h&gt;
#if HAVE_FCNTL_H
#include &lt;fcntl.h&gt;
#endif
#include "rsyslog.h"
#include "dirty.h"
#include "cfsysline.h"
#include "module-template.h"
#include "net.h"
#include "srUtils.h"
#include "conf.h"
#include "tcpsrv.h"
#include "obj.h"
#include "glbl.h"
#include "netstrms.h"
#include "netstrm.h"
#include "nssel.h"
#include "nspoll.h"
#include "errmsg.h"
#include "ruleset.h"
#include "ratelimit.h"
#include "unicode-helper.h"
PRAGMA_INGORE_Wswitch_enum
MODULE_TYPE_LIB
MODULE_TYPE_NOKEEP
#define TCPSESS_MAX_DEFAULT 200 #define TCPLSTN_MAX_DEFAULT 20 
DEFobjStaticHelpers
DEFobjCurrIf(conf)
DEFobjCurrIf(glbl)
DEFobjCurrIf(ruleset)
DEFobjCurrIf(tcps_sess)
DEFobjCurrIf(net)
DEFobjCurrIf(netstrms)
DEFobjCurrIf(netstrm)
DEFobjCurrIf(nssel)
DEFobjCurrIf(nspoll)
DEFobjCurrIf(prop)
DEFobjCurrIf(statsobj)
static void startWorkerPool(void);
static struct wrkrInfo_s {
	pthread_t tid;		pthread_cond_t run;
	int idx;
	tcpsrv_t *pSrv; 	nspoll_t *pPoll;
	void *pUsr;
	sbool enabled;
	long long unsigned numCalled;	} wrkrInfo[4];
static sbool bWrkrRunning; static pthread_mutex_t wrkrMut;
static pthread_cond_t wrkrIdle;
static int wrkrMax = 4;
static int wrkrRunning;
static rsRetVal ATTR_NONNULL(1, 2)
addNewLstnPort(tcpsrv_t *const pThis, tcpLstnParams_t *const cnf_params)
{
	tcpLstnPortList_t *pEntry;
	uchar statname[64];
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	CHKmalloc(pEntry = (tcpLstnPortList_t*)calloc(1, sizeof(tcpLstnPortList_t)));
	pEntry-&gt;cnf_params = cnf_params;
	strcpy((char*)pEntry-&gt;cnf_params-&gt;dfltTZ, (char*)pThis-&gt;dfltTZ);
	pEntry-&gt;cnf_params-&gt;bSPFramingFix = pThis-&gt;bSPFramingFix;
	pEntry-&gt;cnf_params-&gt;bPreserveCase = pThis-&gt;bPreserveCase;
	pEntry-&gt;pSrv = pThis;
	CHKiRet(ratelimitNew(&amp;pEntry-&gt;ratelimiter, "tcperver", NULL));
	ratelimitSetLinuxLike(pEntry-&gt;ratelimiter, pThis-&gt;ratelimitInterval, pThis-&gt;ratelimitBurst);
	ratelimitSetThreadSafe(pEntry-&gt;ratelimiter);
	CHKiRet(statsobj.Construct(&amp;(pEntry-&gt;stats)));
	snprintf((char*)statname, sizeof(statname), "%s(%s)", cnf_params-&gt;pszInputName, cnf_params-&gt;pszPort);
	statname[sizeof(statname)-1] = '\0'; 	CHKiRet(statsobj.SetName(pEntry-&gt;stats, statname));
	CHKiRet(statsobj.SetOrigin(pEntry-&gt;stats, pThis-&gt;pszOrigin));
	STATSCOUNTER_INIT(pEntry-&gt;ctrSubmit, pEntry-&gt;mutCtrSubmit);
	CHKiRet(statsobj.AddCounter(pEntry-&gt;stats, UCHAR_CONSTANT("submitted"),
		ctrType_IntCtr, CTR_FLAG_RESETTABLE, &amp;(pEntry-&gt;ctrSubmit)));
	CHKiRet(statsobj.ConstructFinalize(pEntry-&gt;stats));
	pEntry-&gt;pNext = pThis-&gt;pLstnPorts;
	pThis-&gt;pLstnPorts = pEntry;
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pEntry != NULL) {
			if(pEntry-&gt;cnf_params-&gt;pInputName != NULL) {
				prop.Destruct(&amp;pEntry-&gt;cnf_params-&gt;pInputName);
			}
			if(pEntry-&gt;ratelimiter != NULL) {
				ratelimitDestruct(pEntry-&gt;ratelimiter);
			}
			if(pEntry-&gt;stats != NULL) {
				statsobj.Destruct(&amp;pEntry-&gt;stats);
			}
			free(pEntry);
		}
	}
	RETiRet;
}
static rsRetVal ATTR_NONNULL(1,2)
configureTCPListen(tcpsrv_t *const pThis, tcpLstnParams_t *const cnf_params)
{
	assert(cnf_params-&gt;pszPort != NULL);
	int i;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	const uchar *pPort = cnf_params-&gt;pszPort;
	i = 0;
	while(isdigit((int) *pPort)) {
		i = i * 10 + *pPort++ - '0';
	}
	if(i &gt;= 0 &amp;&amp; i &lt;= 65535) {
		CHKiRet(addNewLstnPort(pThis, cnf_params));
	} else {
		LogError(0, NO_ERRCODE, "Invalid TCP listen port %s - ignored.\n", cnf_params-&gt;pszPort);
	}
finalize_it:
	RETiRet;
}
static rsRetVal
TCPSessTblInit(tcpsrv_t *pThis)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	assert(pThis-&gt;pSessions == NULL);
	DBGPRINTF("Allocating buffer for %d TCP sessions.\n", pThis-&gt;iSessMax);
	if((pThis-&gt;pSessions = (tcps_sess_t **) calloc(pThis-&gt;iSessMax, sizeof(tcps_sess_t *))) == NULL) {
		DBGPRINTF("Error: TCPSessInit() could not alloc memory for TCP session table.\n");
		ABORT_FINALIZE(RS_RET_OUT_OF_MEMORY);
	}
finalize_it:
	RETiRet;
}
static int
TCPSessTblFindFreeSpot(tcpsrv_t *pThis)
{
	register int i;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	for(i = 0 ; i &lt; pThis-&gt;iSessMax ; ++i) {
		if(pThis-&gt;pSessions[i] == NULL)
			break;
	}
	return((i &lt; pThis-&gt;iSessMax) ? i : -1);
}
static int
TCPSessGetNxtSess(tcpsrv_t *pThis, int iCurr)
{
	register int i;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	assert(pThis-&gt;pSessions != NULL);
	for(i = iCurr + 1 ; i &lt; pThis-&gt;iSessMax ; ++i) {
		if(pThis-&gt;pSessions[i] != NULL)
			break;
	}
	return((i &lt; pThis-&gt;iSessMax) ? i : -1);
}
static void ATTR_NONNULL()
deinit_tcp_listener(tcpsrv_t *const pThis)
{
	int i;
	tcpLstnPortList_t *pEntry;
	tcpLstnPortList_t *pDel;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	if(pThis-&gt;pSessions != NULL) {
		if(!pThis-&gt;bUsingEPoll) {
			i = TCPSessGetNxtSess(pThis, -1);
			while(i != -1) {
				tcps_sess.Destruct(&amp;pThis-&gt;pSessions[i]);
				i = TCPSessGetNxtSess(pThis, i);
			}
		}
		free(pThis-&gt;pSessions);
		pThis-&gt;pSessions = NULL; 	}
	pEntry = pThis-&gt;pLstnPorts;
	while(pEntry != NULL) {
		prop.Destruct(&amp;pEntry-&gt;cnf_params-&gt;pInputName);
		free((void*)pEntry-&gt;cnf_params-&gt;pszInputName);
		free((void*)pEntry-&gt;cnf_params-&gt;pszPort);
		free((void*)pEntry-&gt;cnf_params-&gt;pszAddr);
		free((void*)pEntry-&gt;cnf_params-&gt;pszLstnPortFileName);
		free((void*)pEntry-&gt;cnf_params);
		ratelimitDestruct(pEntry-&gt;ratelimiter);
		statsobj.Destruct(&amp;(pEntry-&gt;stats));
		pDel = pEntry;
		pEntry = pEntry-&gt;pNext;
		free(pDel);
	}
	for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
		netstrm.Destruct(pThis-&gt;ppLstn + i);
	}
}
static rsRetVal
addTcpLstn(void *pUsr, netstrm_t *pLstn)
{
	tcpLstnPortList_t *pPortList = (tcpLstnPortList_t *) pUsr;
	tcpsrv_t *pThis = pPortList-&gt;pSrv;
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	ISOBJ_TYPE_assert(pLstn, netstrm);
	if(pThis-&gt;iLstnCurr &gt;= pThis-&gt;iLstnMax)
		ABORT_FINALIZE(RS_RET_MAX_LSTN_REACHED);
	pThis-&gt;ppLstn[pThis-&gt;iLstnCurr] = pLstn;
	pThis-&gt;ppLstnPort[pThis-&gt;iLstnCurr] = pPortList;
	++pThis-&gt;iLstnCurr;
finalize_it:
	RETiRet;
}
static rsRetVal
initTCPListener(tcpsrv_t *pThis, tcpLstnPortList_t *pPortEntry)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	assert(pPortEntry != NULL);
	CHKiRet(netstrm.LstnInit(pThis-&gt;pNS, (void*)pPortEntry, addTcpLstn,
		pThis-&gt;iSessMax, pPortEntry-&gt;cnf_params));
finalize_it:
	RETiRet;
}
static rsRetVal
create_tcp_socket(tcpsrv_t *pThis)
{
	DEFiRet;
	rsRetVal localRet;
	tcpLstnPortList_t *pEntry;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pEntry = pThis-&gt;pLstnPorts;
	while(pEntry != NULL) {
		localRet = initTCPListener(pThis, pEntry);
		if(localRet != RS_RET_OK) {
			LogError(0, localRet, "Could not create tcp listener, ignoring port "
			"%s bind-address %s.",
			(pEntry-&gt;cnf_params-&gt;pszPort == NULL) ? "**UNSPECIFIED**"
				: (const char*) pEntry-&gt;cnf_params-&gt;pszPort,
			(pEntry-&gt;cnf_params-&gt;pszAddr == NULL) ? "**UNSPECIFIED**"
				: (const char*)pEntry-&gt;cnf_params-&gt;pszAddr);
		}
		pEntry = pEntry-&gt;pNext;
	}
	if(TCPSessTblInit(pThis) != 0) {
		LogError(0, RS_RET_ERR, "Could not initialize TCP session table, suspending TCP "
				"message reception.");
		ABORT_FINALIZE(RS_RET_ERR);
	}
finalize_it:
	RETiRet;
}
static rsRetVal
SessAccept(tcpsrv_t *pThis, tcpLstnPortList_t *pLstnInfo, tcps_sess_t **ppSess, netstrm_t *pStrm)
{
	DEFiRet;
	tcps_sess_t *pSess = NULL;
	netstrm_t *pNewStrm = NULL;
	const tcpLstnParams_t *const cnf_params = pLstnInfo-&gt;cnf_params;
	int iSess = -1;
	struct sockaddr_storage *addr;
	uchar *fromHostFQDN = NULL;
	prop_t *fromHostIP;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	assert(pLstnInfo != NULL);
	CHKiRet(netstrm.AcceptConnReq(pStrm, &amp;pNewStrm));
	iSess = TCPSessTblFindFreeSpot(pThis);
	if(iSess == -1) {
		errno = 0;
		LogError(0, RS_RET_MAX_SESS_REACHED, "too many tcp sessions - dropping incoming request");
		ABORT_FINALIZE(RS_RET_MAX_SESS_REACHED);
	}
	if(pThis-&gt;bUseKeepAlive) {
	        CHKiRet(netstrm.SetKeepAliveProbes(pNewStrm, pThis-&gt;iKeepAliveProbes));
	        CHKiRet(netstrm.SetKeepAliveTime(pNewStrm, pThis-&gt;iKeepAliveTime));
	        CHKiRet(netstrm.SetKeepAliveIntvl(pNewStrm, pThis-&gt;iKeepAliveIntvl));
		CHKiRet(netstrm.EnableKeepAlive(pNewStrm));
	}
	if(pThis-&gt;gnutlsPriorityString != NULL) {
		CHKiRet(netstrm.SetGnutlsPriorityString(pNewStrm, pThis-&gt;gnutlsPriorityString));
	}
	CHKiRet(tcps_sess.Construct(&amp;pSess));
	CHKiRet(tcps_sess.SetTcpsrv(pSess, pThis));
	CHKiRet(tcps_sess.SetLstnInfo(pSess, pLstnInfo));
	if(pThis-&gt;OnMsgReceive != NULL)
		CHKiRet(tcps_sess.SetOnMsgReceive(pSess, pThis-&gt;OnMsgReceive));
	CHKiRet(netstrm.GetRemoteHName(pNewStrm, &amp;fromHostFQDN));
	if (!cnf_params-&gt;bPreserveCase) {
		uchar *p;
		for(p = fromHostFQDN; *p; p++) {
			if (isupper((int) *p)) {
				*p = tolower((int) *p);
			}
		}
	}
	CHKiRet(netstrm.GetRemoteIP(pNewStrm, &amp;fromHostIP));
	CHKiRet(netstrm.GetRemAddr(pNewStrm, &amp;addr));
	if(!pThis-&gt;pIsPermittedHost((struct sockaddr*) addr, (char*) fromHostFQDN, pThis-&gt;pUsr, pSess-&gt;pUsr)) {
		DBGPRINTF("%s is not an allowed sender\n", fromHostFQDN);
		if(glbl.GetOptionDisallowWarning(runConf)) {
			errno = 0;
			LogError(0, RS_RET_HOST_NOT_PERMITTED, "TCP message from disallowed "
					"sender %s discarded", fromHostFQDN);
		}
		ABORT_FINALIZE(RS_RET_HOST_NOT_PERMITTED);
	}
	CHKiRet(tcps_sess.SetHost(pSess, fromHostFQDN));
	fromHostFQDN = NULL; 	CHKiRet(tcps_sess.SetHostIP(pSess, fromHostIP));
	CHKiRet(tcps_sess.SetStrm(pSess, pNewStrm));
	pNewStrm = NULL; 	CHKiRet(tcps_sess.SetMsgIdx(pSess, 0));
	CHKiRet(tcps_sess.ConstructFinalize(pSess));
	if(pThis-&gt;pOnSessAccept != NULL) {
		CHKiRet(pThis-&gt;pOnSessAccept(pThis, pSess));
	}
	*ppSess = pSess;
	if(!pThis-&gt;bUsingEPoll)
		pThis-&gt;pSessions[iSess] = pSess;
	pSess = NULL; 
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pSess != NULL)
			tcps_sess.Destruct(&amp;pSess);
		if(pNewStrm != NULL)
			netstrm.Destruct(&amp;pNewStrm);
		free(fromHostFQDN);
	}
	RETiRet;
}
static void
RunCancelCleanup(void *arg)
{
	nspoll_t **ppPoll = (nspoll_t**) arg;
	if (*ppPoll != NULL)
		nspoll.Destruct(ppPoll);
	pthread_mutex_lock(&amp;wrkrMut);
	DBGPRINTF("tcpsrv terminating, waiting for %d workers\n", wrkrRunning);
	while(wrkrRunning &gt; 0) {
		pthread_cond_wait(&amp;wrkrIdle, &amp;wrkrMut);
	}
	pthread_mutex_unlock(&amp;wrkrMut);
}
static void
RunSelectCancelCleanup(void *arg)
{
	nssel_t **ppSel = (nssel_t**) arg;
	if(*ppSel != NULL)
		nssel.Destruct(ppSel);
}
static rsRetVal
closeSess(tcpsrv_t *pThis, tcps_sess_t **ppSess, nspoll_t *pPoll) {
	DEFiRet;
	if(pPoll != NULL) {
		CHKiRet(nspoll.Ctl(pPoll, (*ppSess)-&gt;pStrm, 0, *ppSess, NSDPOLL_IN, NSDPOLL_DEL));
	}
	pThis-&gt;pOnRegularClose(*ppSess);
	tcps_sess.Destruct(ppSess);
finalize_it:
	RETiRet;
}
static rsRetVal
doReceive(tcpsrv_t *pThis, tcps_sess_t **ppSess, nspoll_t *pPoll)
{
	char buf[128*1024]; 	ssize_t iRcvd;
	rsRetVal localRet;
	DEFiRet;
	uchar *pszPeer;
	int lenPeer;
	int oserr = 0;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	prop.GetString((*ppSess)-&gt;fromHostIP, &amp;pszPeer, &amp;lenPeer);
	DBGPRINTF("netstream %p with new data from remote peer %s\n", (*ppSess)-&gt;pStrm, pszPeer);
	iRet = pThis-&gt;pRcvData(*ppSess, buf, sizeof(buf), &amp;iRcvd, &amp;oserr);
	switch(iRet) {
	case RS_RET_CLOSED:
		if(pThis-&gt;bEmitMsgOnClose) {
			errno = 0;
			LogError(0, RS_RET_PEER_CLOSED_CONN, "Netstream session %p closed by remote "
				"peer %s.\n", (*ppSess)-&gt;pStrm, pszPeer);
		}
		CHKiRet(closeSess(pThis, ppSess, pPoll));
		break;
	case RS_RET_RETRY:
		break;
	case RS_RET_OK:
		localRet = tcps_sess.DataRcvd(*ppSess, buf, iRcvd);
		if(localRet != RS_RET_OK &amp;&amp; localRet != RS_RET_QUEUE_FULL) {
			LogError(oserr, localRet, "Tearing down TCP Session from %s", pszPeer);
			CHKiRet(closeSess(pThis, ppSess, pPoll));
		}
		break;
	default:
		LogError(oserr, iRet, "netstream session %p from %s will be closed due to error",
				(*ppSess)-&gt;pStrm, pszPeer);
		CHKiRet(closeSess(pThis, ppSess, pPoll));
		break;
	}
finalize_it:
	RETiRet;
}
static rsRetVal ATTR_NONNULL(1)
processWorksetItem(tcpsrv_t *const pThis, nspoll_t *pPoll, const int idx, void *pUsr)
{
	tcps_sess_t *pNewSess = NULL;
	tcpLstnParams_t *cnf_params;
	DEFiRet;
	DBGPRINTF("tcpsrv: processing item %d, pUsr %p, bAbortConn\n", idx, pUsr);
	if(pUsr == pThis-&gt;ppLstn) {
		DBGPRINTF("New connect on NSD %p.\n", pThis-&gt;ppLstn[idx]);
		iRet = SessAccept(pThis, pThis-&gt;ppLstnPort[idx], &amp;pNewSess, pThis-&gt;ppLstn[idx]);
		cnf_params = pThis-&gt;ppLstnPort[idx]-&gt;cnf_params;
		if(iRet == RS_RET_OK) {
			if(pPoll != NULL) {
				CHKiRet(nspoll.Ctl(pPoll, pNewSess-&gt;pStrm, 0, pNewSess, NSDPOLL_IN, NSDPOLL_ADD));
			}
			DBGPRINTF("New session created with NSD %p.\n", pNewSess);
		} else {
			DBGPRINTF("tcpsrv: error %d during accept\n", iRet);
		}
	} else {
		pNewSess = (tcps_sess_t*) pUsr;
		cnf_params = pNewSess-&gt;pLstnInfo-&gt;cnf_params;
		doReceive(pThis, &amp;pNewSess, pPoll);
		if(pPoll == NULL &amp;&amp; pNewSess == NULL) {
			pThis-&gt;pSessions[idx] = NULL;
		}
	}
finalize_it:
	if(iRet != RS_RET_OK) {
		LogError(0, iRet, "tcpsrv listener (inputname: '%s') failed "
			"to process incoming connection with error %d",
			(cnf_params-&gt;pszInputName == NULL) ? (uchar*)"*UNSET*" : cnf_params-&gt;pszInputName, iRet);
		srSleep(0,20000); 	}
	RETiRet;
}
static void * ATTR_NONNULL(1)
wrkr(void *const myself)
{
	struct wrkrInfo_s *const me = (struct wrkrInfo_s*) myself;
	pthread_mutex_lock(&amp;wrkrMut);
	while(1) {
		while(me-&gt;pSrv == NULL &amp;&amp; glbl.GetGlobalInputTermState() == 0) {
			pthread_cond_wait(&amp;me-&gt;run, &amp;wrkrMut);
		}
		if(me-&gt;pSrv == NULL) {
			assert(glbl.GetGlobalInputTermState() == 1);
			break;
		}
		pthread_mutex_unlock(&amp;wrkrMut);
		++me-&gt;numCalled;
		processWorksetItem(me-&gt;pSrv, me-&gt;pPoll, me-&gt;idx, me-&gt;pUsr);
		pthread_mutex_lock(&amp;wrkrMut);
		me-&gt;pSrv = NULL;			--wrkrRunning;
		pthread_cond_broadcast(&amp;wrkrIdle);
	}
	me-&gt;enabled = 0; 	pthread_mutex_unlock(&amp;wrkrMut);
	return NULL;
}
static void
waitForWorkers(void)
{
	pthread_mutex_lock(&amp;wrkrMut);
	pthread_cleanup_push(mutexCancelCleanup, &amp;wrkrMut);
	while(wrkrRunning &gt; 0) {
		pthread_cond_wait(&amp;wrkrIdle, &amp;wrkrMut);
	}
	pthread_cleanup_pop(1);
}
static rsRetVal
processWorkset(tcpsrv_t *pThis, nspoll_t *pPoll, int numEntries, nsd_epworkset_t workset[])
{
	int i;
	int origEntries = numEntries;
	DEFiRet;
	DBGPRINTF("tcpsrv: ready to process %d event entries\n", numEntries);
	while(numEntries &gt; 0) {
		if(glbl.GetGlobalInputTermState() == 1)
			ABORT_FINALIZE(RS_RET_FORCE_TERM);
		if(numEntries == 1) {
			iRet = processWorksetItem(pThis, pPoll, workset[numEntries-1].id, workset[numEntries-1].pUsr);
		} else {
			pthread_mutex_lock(&amp;wrkrMut);
			for(i = 0 ; (i &lt; wrkrMax) &amp;&amp; ((wrkrInfo[i].pSrv != NULL) || (wrkrInfo[i].enabled == 0)) ; ++i)
			if(i &lt; wrkrMax) {
				wrkrInfo[i].pSrv = pThis;
				wrkrInfo[i].pPoll = pPoll;
				wrkrInfo[i].idx = workset[numEntries -1].id;
				wrkrInfo[i].pUsr = workset[numEntries -1].pUsr;
				++wrkrRunning;
				pthread_cond_signal(&amp;wrkrInfo[i].run);
				pthread_mutex_unlock(&amp;wrkrMut);
			} else {
				pthread_mutex_unlock(&amp;wrkrMut);
				iRet = processWorksetItem(pThis, pPoll, workset[numEntries-1].id,
						   workset[numEntries-1].pUsr);
			}
		}
		--numEntries;
	}
	if(origEntries &gt; 1) {
		waitForWorkers();
	}
finalize_it:
	RETiRet;
}
PRAGMA_DIAGNOSTIC_PUSH
PRAGMA_IGNORE_Wempty_body
static rsRetVal
RunSelect(tcpsrv_t *pThis, nsd_epworkset_t workset[], size_t sizeWorkset)
{
	DEFiRet;
	int nfds;
	int i;
	int iWorkset;
	int iTCPSess;
	int bIsReady;
	nssel_t *pSel = NULL;
	rsRetVal localRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pthread_cleanup_push(RunSelectCancelCleanup, (void*) &amp;pSel);
	while(1) {
		CHKiRet(nssel.Construct(&amp;pSel));
		if(pThis-&gt;pszDrvrName != NULL)
			CHKiRet(nssel.SetDrvrName(pSel, pThis-&gt;pszDrvrName));
		CHKiRet(nssel.ConstructFinalize(pSel));
		for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
			CHKiRet(nssel.Add(pSel, pThis-&gt;ppLstn[i], NSDSEL_RD));
		}
		iTCPSess = TCPSessGetNxtSess(pThis, -1);
		while(iTCPSess != -1) {
			CHKiRet(nssel.Add(pSel, pThis-&gt;pSessions[iTCPSess]-&gt;pStrm, NSDSEL_RD));
			DBGPRINTF("tcpsrv process session %d:\n", iTCPSess);
			iTCPSess = TCPSessGetNxtSess(pThis, iTCPSess);
		}
		CHKiRet(nssel.Wait(pSel, &amp;nfds));
		if(glbl.GetGlobalInputTermState() == 1)
			break; 
		iWorkset = 0;
		for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
			if(glbl.GetGlobalInputTermState() == 1)
				ABORT_FINALIZE(RS_RET_FORCE_TERM);
			CHKiRet(nssel.IsReady(pSel, pThis-&gt;ppLstn[i], NSDSEL_RD, &amp;bIsReady, &amp;nfds));
			if(bIsReady) {
				workset[iWorkset].id = i;
				workset[iWorkset].pUsr = (void*) pThis-&gt;ppLstn;
				++iWorkset;
				if(iWorkset &gt;= (int) sizeWorkset) {
					processWorkset(pThis, NULL, iWorkset, workset);
					iWorkset = 0;
				}
				--nfds; 			}
		}
		iTCPSess = TCPSessGetNxtSess(pThis, -1);
		while(nfds &amp;&amp; iTCPSess != -1) {
			if(glbl.GetGlobalInputTermState() == 1)
				ABORT_FINALIZE(RS_RET_FORCE_TERM);
			localRet = nssel.IsReady(pSel, pThis-&gt;pSessions[iTCPSess]-&gt;pStrm, NSDSEL_RD,
				&amp;bIsReady, &amp;nfds);
			if(bIsReady || localRet != RS_RET_OK) {
				workset[iWorkset].id = iTCPSess;
				workset[iWorkset].pUsr = (void*) pThis-&gt;pSessions[iTCPSess];
				++iWorkset;
				if(iWorkset &gt;= (int) sizeWorkset) {
					processWorkset(pThis, NULL, iWorkset, workset);
					iWorkset = 0;
				}
				if(bIsReady)
					--nfds; 			}
			iTCPSess = TCPSessGetNxtSess(pThis, iTCPSess);
		}
		if(iWorkset &gt; 0)
			processWorkset(pThis, NULL, iWorkset, workset);
		if(pSel != NULL) { 			nssel.Destruct(&amp;pSel);
		}
	}
	pthread_cleanup_pop(1); 
	RETiRet;
}
PRAGMA_DIAGNOSTIC_POP
static rsRetVal
DoRun(tcpsrv_t *pThis, nspoll_t **ppPoll)
{
	DEFiRet;
	int i;
	nsd_epworkset_t workset[128]; 	int numEntries;
	nspoll_t *pPoll = NULL;
	rsRetVal localRet;
	if((localRet = nspoll.Construct(ppPoll)) == RS_RET_OK) {
		pPoll = *ppPoll;
		if(pThis-&gt;pszDrvrName != NULL)
			CHKiRet(nspoll.SetDrvrName(pPoll, pThis-&gt;pszDrvrName));
		localRet = nspoll.ConstructFinalize(pPoll);
	}
	if(localRet != RS_RET_OK) {
		DBGPRINTF("tcpsrv could not use epoll() interface, iRet=%d, using select()\n", localRet);
		iRet = RunSelect(pThis, workset, sizeof(workset)/sizeof(nsd_epworkset_t));
		FINALIZE;
	}
	DBGPRINTF("tcpsrv uses epoll() interface, nsdpoll driver found\n");
	pThis-&gt;bUsingEPoll = RSTRUE;
	for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
		DBGPRINTF("Trying to add listener %d, pUsr=%p\n", i, pThis-&gt;ppLstn);
		CHKiRet(nspoll.Ctl(pPoll, pThis-&gt;ppLstn[i], i, pThis-&gt;ppLstn, NSDPOLL_IN, NSDPOLL_ADD));
		DBGPRINTF("Added listener %d\n", i);
	}
	while(glbl.GetGlobalInputTermState() == 0) {
		numEntries = sizeof(workset)/sizeof(nsd_epworkset_t);
		localRet = nspoll.Wait(pPoll, -1, &amp;numEntries, workset);
		if(glbl.GetGlobalInputTermState() == 1)
			break; 
		if(localRet != RS_RET_OK)
			continue;
		processWorkset(pThis, pPoll, numEntries, workset);
	}
	for(i = 0 ; i &lt; pThis-&gt;iLstnCurr ; ++i) {
		CHKiRet(nspoll.Ctl(pPoll, pThis-&gt;ppLstn[i], i, pThis-&gt;ppLstn, NSDPOLL_IN, NSDPOLL_DEL));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
Run(tcpsrv_t *pThis)
{
	DEFiRet;
	nspoll_t *pPoll = NULL;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	if(pThis-&gt;iLstnCurr == 0) {
		dbgprintf("tcpsrv: no listeneres at all (probably init error), terminating\n");
		RETiRet; 	}
	d_pthread_mutex_lock(&amp;wrkrMut);
	if(!bWrkrRunning) {
		bWrkrRunning = 1;
		startWorkerPool();
	}
	d_pthread_mutex_unlock(&amp;wrkrMut);
	pthread_cleanup_push(RunCancelCleanup, (void*) &amp;pPoll);
	iRet = DoRun(pThis, &amp;pPoll);
	pthread_cleanup_pop(1);
	RETiRet;
}
BEGINobjConstruct(tcpsrv) 	pThis-&gt;iSessMax = TCPSESS_MAX_DEFAULT;
	pThis-&gt;iLstnMax = TCPLSTN_MAX_DEFAULT;
	pThis-&gt;addtlFrameDelim = TCPSRV_NO_ADDTL_DELIMITER;
	pThis-&gt;maxFrameSize = 200000;
	pThis-&gt;bDisableLFDelim = 0;
	pThis-&gt;discardTruncatedMsg = 0;
	pThis-&gt;OnMsgReceive = NULL;
	pThis-&gt;dfltTZ[0] = '\0';
	pThis-&gt;bSPFramingFix = 0;
	pThis-&gt;ratelimitInterval = 0;
	pThis-&gt;ratelimitBurst = 10000;
	pThis-&gt;bUseFlowControl = 1;
	pThis-&gt;pszDrvrName = NULL;
	pThis-&gt;bPreserveCase = 1; 	pThis-&gt;DrvrTlsVerifyDepth = 0;
ENDobjConstruct(tcpsrv)
static rsRetVal
tcpsrvConstructFinalize(tcpsrv_t *pThis)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	CHKiRet(netstrms.Construct(&amp;pThis-&gt;pNS));
	if(pThis-&gt;pszDrvrName != NULL)
		CHKiRet(netstrms.SetDrvrName(pThis-&gt;pNS, pThis-&gt;pszDrvrName));
	CHKiRet(netstrms.SetDrvrMode(pThis-&gt;pNS, pThis-&gt;iDrvrMode));
	CHKiRet(netstrms.SetDrvrCheckExtendedKeyUsage(pThis-&gt;pNS, pThis-&gt;DrvrChkExtendedKeyUsage));
	CHKiRet(netstrms.SetDrvrPrioritizeSAN(pThis-&gt;pNS, pThis-&gt;DrvrPrioritizeSan));
	CHKiRet(netstrms.SetDrvrTlsVerifyDepth(pThis-&gt;pNS, pThis-&gt;DrvrTlsVerifyDepth));
	if(pThis-&gt;pszDrvrAuthMode != NULL)
		CHKiRet(netstrms.SetDrvrAuthMode(pThis-&gt;pNS, pThis-&gt;pszDrvrAuthMode));
	CHKiRet(netstrms.SetDrvrPermitExpiredCerts(pThis-&gt;pNS, pThis-&gt;pszDrvrPermitExpiredCerts));
	CHKiRet(netstrms.SetDrvrTlsCAFile(pThis-&gt;pNS, pThis-&gt;pszDrvrCAFile));
	CHKiRet(netstrms.SetDrvrTlsKeyFile(pThis-&gt;pNS, pThis-&gt;pszDrvrKeyFile));
	CHKiRet(netstrms.SetDrvrTlsCertFile(pThis-&gt;pNS, pThis-&gt;pszDrvrCertFile));
	if(pThis-&gt;pPermPeers != NULL)
		CHKiRet(netstrms.SetDrvrPermPeers(pThis-&gt;pNS, pThis-&gt;pPermPeers));
	if(pThis-&gt;gnutlsPriorityString != NULL)
		CHKiRet(netstrms.SetDrvrGnutlsPriorityString(pThis-&gt;pNS, pThis-&gt;gnutlsPriorityString));
	CHKiRet(netstrms.ConstructFinalize(pThis-&gt;pNS));
	CHKmalloc(pThis-&gt;ppLstn = calloc(pThis-&gt;iLstnMax, sizeof(netstrm_t*)));
	CHKmalloc(pThis-&gt;ppLstnPort = calloc(pThis-&gt;iLstnMax, sizeof(tcpLstnPortList_t*)));
	iRet = pThis-&gt;OpenLstnSocks(pThis);
finalize_it:
	if(iRet != RS_RET_OK) {
		if(pThis-&gt;pNS != NULL)
			netstrms.Destruct(&amp;pThis-&gt;pNS);
		LogError(0, iRet, "tcpsrv could not create listener (inputname: '%s')",
				(pThis-&gt;pszInputName == NULL) ? (uchar*)"*UNSET*" : pThis-&gt;pszInputName);
	}
	RETiRet;
}
BEGINobjDestruct(tcpsrv) CODESTARTobjDestruct(tcpsrv)
	if(pThis-&gt;OnDestruct != NULL)
		pThis-&gt;OnDestruct(pThis-&gt;pUsr);
	deinit_tcp_listener(pThis);
	if(pThis-&gt;pNS != NULL)
		netstrms.Destruct(&amp;pThis-&gt;pNS);
	free(pThis-&gt;pszDrvrName);
	free(pThis-&gt;pszDrvrAuthMode);
	free(pThis-&gt;pszDrvrPermitExpiredCerts);
	free(pThis-&gt;pszDrvrCAFile);
	free(pThis-&gt;pszDrvrKeyFile);
	free(pThis-&gt;pszDrvrCertFile);
	free(pThis-&gt;ppLstn);
	free(pThis-&gt;ppLstnPort);
	free(pThis-&gt;pszInputName);
	free(pThis-&gt;pszOrigin);
ENDobjDestruct(tcpsrv)
BEGINobjDebugPrint(tcpsrv) CODESTARTobjDebugPrint(tcpsrv)
ENDobjDebugPrint(tcpsrv)
static rsRetVal
SetCBIsPermittedHost(tcpsrv_t *pThis, int (*pCB)(struct sockaddr *addr, char *fromHostFQDN, void*, void*))
{
	DEFiRet;
	pThis-&gt;pIsPermittedHost = pCB;
	RETiRet;
}
static rsRetVal
SetCBRcvData(tcpsrv_t *pThis, rsRetVal (*pRcvData)(tcps_sess_t*, char*, size_t, ssize_t*, int*))
{
	DEFiRet;
	pThis-&gt;pRcvData = pRcvData;
	RETiRet;
}
static rsRetVal
SetCBOnListenDeinit(tcpsrv_t *pThis, rsRetVal (*pCB)(void*))
{
	DEFiRet;
	pThis-&gt;pOnListenDeinit = pCB;
	RETiRet;
}
static rsRetVal
SetCBOnSessAccept(tcpsrv_t *pThis, rsRetVal (*pCB)(tcpsrv_t*, tcps_sess_t*))
{
	DEFiRet;
	pThis-&gt;pOnSessAccept = pCB;
	RETiRet;
}
static rsRetVal
SetCBOnDestruct(tcpsrv_t *pThis, rsRetVal (*pCB)(void*))
{
	DEFiRet;
	pThis-&gt;OnDestruct = pCB;
	RETiRet;
}
static rsRetVal
SetCBOnSessConstructFinalize(tcpsrv_t *pThis, rsRetVal (*pCB)(void*))
{
	DEFiRet;
	pThis-&gt;OnSessConstructFinalize = pCB;
	RETiRet;
}
static rsRetVal
SetCBOnSessDestruct(tcpsrv_t *pThis, rsRetVal (*pCB)(void*))
{
	DEFiRet;
	pThis-&gt;pOnSessDestruct = pCB;
	RETiRet;
}
static rsRetVal
SetCBOnRegularClose(tcpsrv_t *pThis, rsRetVal (*pCB)(tcps_sess_t*))
{
	DEFiRet;
	pThis-&gt;pOnRegularClose = pCB;
	RETiRet;
}
static rsRetVal
SetCBOnErrClose(tcpsrv_t *pThis, rsRetVal (*pCB)(tcps_sess_t*))
{
	DEFiRet;
	pThis-&gt;pOnErrClose = pCB;
	RETiRet;
}
static rsRetVal
SetCBOpenLstnSocks(tcpsrv_t *pThis, rsRetVal (*pCB)(tcpsrv_t*))
{
	DEFiRet;
	pThis-&gt;OpenLstnSocks = pCB;
	RETiRet;
}
static rsRetVal
SetUsrP(tcpsrv_t *pThis, void *pUsr)
{
	DEFiRet;
	pThis-&gt;pUsr = pUsr;
	RETiRet;
}
static rsRetVal
SetKeepAlive(tcpsrv_t *pThis, int iVal)
{
	DEFiRet;
	DBGPRINTF("tcpsrv: keep-alive set to %d\n", iVal);
	pThis-&gt;bUseKeepAlive = iVal;
	RETiRet;
}
static rsRetVal
SetKeepAliveIntvl(tcpsrv_t *pThis, int iVal)
{
	DEFiRet;
	DBGPRINTF("tcpsrv: keep-alive interval set to %d\n", iVal);
	pThis-&gt;iKeepAliveIntvl = iVal;
	RETiRet;
}
static rsRetVal
SetKeepAliveProbes(tcpsrv_t *pThis, int iVal)
{
	DEFiRet;
	DBGPRINTF("tcpsrv: keep-alive probes set to %d\n", iVal);
	pThis-&gt;iKeepAliveProbes = iVal;
	RETiRet;
}
static rsRetVal
SetKeepAliveTime(tcpsrv_t *pThis, int iVal)
{
	DEFiRet;
	DBGPRINTF("tcpsrv: keep-alive timeout set to %d\n", iVal);
	pThis-&gt;iKeepAliveTime = iVal;
	RETiRet;
}
static rsRetVal
SetGnutlsPriorityString(tcpsrv_t *pThis, uchar *iVal)
{
	DEFiRet;
	DBGPRINTF("tcpsrv: gnutlsPriorityString set to %s\n",
		(iVal == NULL) ? "(null)" : (const char*) iVal);
	pThis-&gt;gnutlsPriorityString = iVal;
	RETiRet;
}
static rsRetVal
SetOnMsgReceive(tcpsrv_t *pThis, rsRetVal (*OnMsgReceive)(tcps_sess_t*, uchar*, int))
{
	DEFiRet;
	assert(OnMsgReceive != NULL);
	pThis-&gt;OnMsgReceive = OnMsgReceive;
	RETiRet;
}
static rsRetVal
SetbDisableLFDelim(tcpsrv_t *pThis, int bVal)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;bDisableLFDelim = bVal;
	RETiRet;
}
static rsRetVal
SetDiscardTruncatedMsg(tcpsrv_t *pThis, int discard)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;discardTruncatedMsg = discard;
	RETiRet;
}
static rsRetVal
SetAddtlFrameDelim(tcpsrv_t *pThis, int iDelim)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;addtlFrameDelim = iDelim;
	RETiRet;
}
static rsRetVal
SetMaxFrameSize(tcpsrv_t *pThis, int maxFrameSize)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;maxFrameSize = maxFrameSize;
	RETiRet;
}
static rsRetVal
SetDfltTZ(tcpsrv_t *const pThis, uchar *const tz)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	strncpy((char*)pThis-&gt;dfltTZ, (char*)tz, sizeof(pThis-&gt;dfltTZ));
	pThis-&gt;dfltTZ[sizeof(pThis-&gt;dfltTZ)-1] = '\0';
	RETiRet;
}
static rsRetVal
SetbSPFramingFix(tcpsrv_t *pThis, const sbool val)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;bSPFramingFix = val;
	RETiRet;
}
static rsRetVal
SetOrigin(tcpsrv_t *pThis, uchar *origin)
{
	DEFiRet;
	free(pThis-&gt;pszOrigin);
	pThis-&gt;pszOrigin = (origin == NULL) ? NULL : ustrdup(origin);
	RETiRet;
}
static rsRetVal
SetInputName(tcpsrv_t *const pThis,tcpLstnParams_t *const cnf_params, const uchar *const name)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	if(name == NULL)
		cnf_params-&gt;pszInputName = NULL;
	else
		CHKmalloc(cnf_params-&gt;pszInputName = ustrdup(name));
	free(pThis-&gt;pszInputName); 	pThis-&gt;pszInputName = ustrdup("imtcp"); 
	CHKiRet(prop.Construct(&amp;cnf_params-&gt;pInputName));
	CHKiRet(prop.SetString(cnf_params-&gt;pInputName, cnf_params-&gt;pszInputName, ustrlen(cnf_params-&gt;pszInputName)));
	CHKiRet(prop.ConstructFinalize(cnf_params-&gt;pInputName));
finalize_it:
	RETiRet;
}
static rsRetVal
SetLinuxLikeRatelimiters(tcpsrv_t *pThis, unsigned int ratelimitInterval, unsigned int ratelimitBurst)
{
	DEFiRet;
	pThis-&gt;ratelimitInterval = ratelimitInterval;
	pThis-&gt;ratelimitBurst = ratelimitBurst;
	RETiRet;
}
static rsRetVal
SetNotificationOnRemoteClose(tcpsrv_t *pThis, int bNewVal)
{
	DEFiRet;
	pThis-&gt;bEmitMsgOnClose = bNewVal;
	RETiRet;
}
static rsRetVal
SetDrvrMode(tcpsrv_t *pThis, const int iMode)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;iDrvrMode = iMode;
	RETiRet;
}
static rsRetVal
SetDrvrName(tcpsrv_t *pThis, uchar *const name)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	free(pThis-&gt;pszDrvrName);
	CHKmalloc(pThis-&gt;pszDrvrName = ustrdup(name));
finalize_it:
	RETiRet;
}
static rsRetVal
SetDrvrAuthMode(tcpsrv_t *pThis, uchar *const mode)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	CHKmalloc(pThis-&gt;pszDrvrAuthMode = ustrdup(mode));
finalize_it:
	RETiRet;
}
static rsRetVal
SetDrvrPermitExpiredCerts(tcpsrv_t *pThis, uchar *mode)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	if (mode != NULL) {
		CHKmalloc(pThis-&gt;pszDrvrPermitExpiredCerts = ustrdup(mode));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
SetDrvrCAFile(tcpsrv_t *const pThis, uchar *const mode)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	if (mode != NULL) {
		CHKmalloc(pThis-&gt;pszDrvrCAFile = ustrdup(mode));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
SetDrvrKeyFile(tcpsrv_t *pThis, uchar *mode)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	if (mode != NULL) {
		CHKmalloc(pThis-&gt;pszDrvrKeyFile = ustrdup(mode));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
SetDrvrCertFile(tcpsrv_t *pThis, uchar *mode)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	if (mode != NULL) {
		CHKmalloc(pThis-&gt;pszDrvrCertFile = ustrdup(mode));
	}
finalize_it:
	RETiRet;
}
static rsRetVal
SetDrvrPermPeers(tcpsrv_t *pThis, permittedPeers_t *pPermPeers)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;pPermPeers = pPermPeers;
	RETiRet;
}
static rsRetVal
SetDrvrCheckExtendedKeyUsage(tcpsrv_t *pThis, int ChkExtendedKeyUsage)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;DrvrChkExtendedKeyUsage = ChkExtendedKeyUsage;
	RETiRet;
}
static rsRetVal
SetDrvrPrioritizeSAN(tcpsrv_t *pThis, int prioritizeSan)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;DrvrPrioritizeSan = prioritizeSan;
	RETiRet;
}
static rsRetVal
SetDrvrTlsVerifyDepth(tcpsrv_t *pThis, int verifyDepth)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;DrvrTlsVerifyDepth = verifyDepth;
	RETiRet;
}
static rsRetVal
SetLstnMax(tcpsrv_t *pThis, int iMax)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;iLstnMax = iMax;
	RETiRet;
}
static rsRetVal
SetUseFlowControl(tcpsrv_t *pThis, int bUseFlowControl)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;bUseFlowControl = bUseFlowControl;
	RETiRet;
}
static rsRetVal
SetSessMax(tcpsrv_t *pThis, int iMax)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt;iSessMax = iMax;
	RETiRet;
}
static rsRetVal
SetPreserveCase(tcpsrv_t *pThis, int bPreserveCase)
{
	DEFiRet;
<a name="0"></a>	ISOBJ_TYPE_assert(pThis, tcpsrv);
	pThis-&gt; bPreserveCase = bPreserveCase;
	RETiRet;
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
BEGINobjQueryInterface(tcpsrv)
CODESTARTobjQueryInterface(tcpsrv)
	if(pIf-&gt;ifVersion != tcpsrvCURR_IF_VERSION) { 		ABORT_FINALIZE(RS_RET_INTERFACE_NOT_SUPPORTED);
	}
	pIf-&gt;DebugPrint = tcpsrvDebugPrint;
	pIf-&gt;Construct = tcpsrvConstruct;
	pIf-&gt;ConstructFinalize = tcpsrvConstructFinalize;
	pIf-&gt;Destruct = tcpsrvDestruct;
	pIf-&gt;configureTCPListen = configureTCPListen;
	pIf-&gt;create_tcp_socket = create_tcp_socket;
	pIf-&gt;Run = Run;
	pIf-&gt;SetKeepAlive = SetKeepAlive;
	pIf-&gt;SetKeepAliveIntvl = SetKeepAliveIntvl;</b></font>
	pIf-&gt;SetKeepAliveProbes = SetKeepAliveProbes;
	pIf-&gt;SetKeepAliveTime = SetKeepAliveTime;
	pIf-&gt;SetGnutlsPriorityString = SetGnutlsPriorityString;
	pIf-&gt;SetUsrP = SetUsrP;
	pIf-&gt;SetInputName = SetInputName;
	pIf-&gt;SetOrigin = SetOrigin;
	pIf-&gt;SetDfltTZ = SetDfltTZ;
	pIf-&gt;SetbSPFramingFix = SetbSPFramingFix;
	pIf-&gt;SetAddtlFrameDelim = SetAddtlFrameDelim;
	pIf-&gt;SetMaxFrameSize = SetMaxFrameSize;
	pIf-&gt;SetbDisableLFDelim = SetbDisableLFDelim;
	pIf-&gt;SetDiscardTruncatedMsg = SetDiscardTruncatedMsg;
	pIf-&gt;SetSessMax = SetSessMax;
	pIf-&gt;SetUseFlowControl = SetUseFlowControl;
	pIf-&gt;SetLstnMax = SetLstnMax;
	pIf-&gt;SetDrvrMode = SetDrvrMode;
	pIf-&gt;SetDrvrAuthMode = SetDrvrAuthMode;
	pIf-&gt;SetDrvrPermitExpiredCerts = SetDrvrPermitExpiredCerts;
	pIf-&gt;SetDrvrCAFile = SetDrvrCAFile;
	pIf-&gt;SetDrvrKeyFile = SetDrvrKeyFile;
	pIf-&gt;SetDrvrCertFile = SetDrvrCertFile;
	pIf-&gt;SetDrvrName = SetDrvrName;
	pIf-&gt;SetDrvrPermPeers = SetDrvrPermPeers;
	pIf-&gt;SetCBIsPermittedHost = SetCBIsPermittedHost;
	pIf-&gt;SetCBOpenLstnSocks = SetCBOpenLstnSocks;
	pIf-&gt;SetCBRcvData = SetCBRcvData;
	pIf-&gt;SetCBOnListenDeinit = SetCBOnListenDeinit;
	pIf-&gt;SetCBOnSessAccept = SetCBOnSessAccept;
	pIf-&gt;SetCBOnSessConstructFinalize = SetCBOnSessConstructFinalize;
	pIf-&gt;SetCBOnSessDestruct = SetCBOnSessDestruct;
	pIf-&gt;SetCBOnDestruct = SetCBOnDestruct;
	pIf-&gt;SetCBOnRegularClose = SetCBOnRegularClose;
	pIf-&gt;SetCBOnErrClose = SetCBOnErrClose;
	pIf-&gt;SetOnMsgReceive = SetOnMsgReceive;
	pIf-&gt;SetLinuxLikeRatelimiters = SetLinuxLikeRatelimiters;
	pIf-&gt;SetNotificationOnRemoteClose = SetNotificationOnRemoteClose;
	pIf-&gt;SetPreserveCase = SetPreserveCase;
	pIf-&gt;SetDrvrCheckExtendedKeyUsage = SetDrvrCheckExtendedKeyUsage;
	pIf-&gt;SetDrvrPrioritizeSAN = SetDrvrPrioritizeSAN;
	pIf-&gt;SetDrvrTlsVerifyDepth = SetDrvrTlsVerifyDepth;
finalize_it:
ENDobjQueryInterface(tcpsrv)
BEGINObjClassExit(tcpsrv, OBJ_IS_LOADABLE_MODULE) CODESTARTObjClassExit(tcpsrv)
	objRelease(tcps_sess, DONT_LOAD_LIB);
	objRelease(conf, CORE_COMPONENT);
	objRelease(prop, CORE_COMPONENT);
	objRelease(statsobj, CORE_COMPONENT);
	objRelease(ruleset, CORE_COMPONENT);
	objRelease(glbl, CORE_COMPONENT);
	objRelease(netstrms, DONT_LOAD_LIB);
	objRelease(nssel, DONT_LOAD_LIB);
	objRelease(netstrm, LM_NETSTRMS_FILENAME);
	objRelease(net, LM_NET_FILENAME);
ENDObjClassExit(tcpsrv)
BEGINObjClassInit(tcpsrv, 1, OBJ_IS_LOADABLE_MODULE) 	CHKiRet(objUse(net, LM_NET_FILENAME));
	CHKiRet(objUse(netstrms, LM_NETSTRMS_FILENAME));
	CHKiRet(objUse(netstrm, DONT_LOAD_LIB));
	CHKiRet(objUse(nssel, DONT_LOAD_LIB));
	CHKiRet(objUse(nspoll, DONT_LOAD_LIB));
	CHKiRet(objUse(tcps_sess, DONT_LOAD_LIB));
	CHKiRet(objUse(conf, CORE_COMPONENT));
	CHKiRet(objUse(glbl, CORE_COMPONENT));
	CHKiRet(objUse(ruleset, CORE_COMPONENT));
	CHKiRet(objUse(statsobj, CORE_COMPONENT));
	CHKiRet(objUse(prop, CORE_COMPONENT));
	OBJSetMethodHandler(objMethod_DEBUGPRINT, tcpsrvDebugPrint);
	OBJSetMethodHandler(objMethod_CONSTRUCTION_FINALIZER, tcpsrvConstructFinalize);
ENDObjClassInit(tcpsrv)
static void
startWorkerPool(void)
{
	int i;
	int r;
	pthread_attr_t sessThrdAttr;
	sigset_t sigSet, sigSetSave;
	sigfillset(&amp;sigSet);
	pthread_sigmask(SIG_SETMASK, &amp;sigSet, &amp;sigSetSave);
	wrkrRunning = 0;
	pthread_cond_init(&amp;wrkrIdle, NULL);
	pthread_attr_init(&amp;sessThrdAttr);
	pthread_attr_setstacksize(&amp;sessThrdAttr, 4096*1024);
	for(i = 0 ; i &lt; wrkrMax ; ++i) {
		pthread_cond_init(&amp;wrkrInfo[i].run, NULL);
		wrkrInfo[i].pSrv = NULL;
		wrkrInfo[i].numCalled = 0;
		r = pthread_create(&amp;wrkrInfo[i].tid, &amp;sessThrdAttr, wrkr, &amp;(wrkrInfo[i]));
		if(r == 0) {
			wrkrInfo[i].enabled = 1;
		} else {
			LogError(r, NO_ERRCODE, "tcpsrv error creating thread");
		}
	}
	pthread_attr_destroy(&amp;sessThrdAttr);
	pthread_sigmask(SIG_SETMASK, &amp;sigSetSave, NULL);
}
static void
stopWorkerPool(void)
{
	int i;
	for(i = 0 ; i &lt; wrkrMax ; ++i) {
		pthread_mutex_lock(&amp;wrkrMut);
		pthread_cond_signal(&amp;wrkrInfo[i].run); 		pthread_mutex_unlock(&amp;wrkrMut);
		pthread_join(wrkrInfo[i].tid, NULL);
		DBGPRINTF("tcpsrv: info: worker %d was called %llu times\n", i, wrkrInfo[i].numCalled);
		pthread_cond_destroy(&amp;wrkrInfo[i].run);
	}
	pthread_cond_destroy(&amp;wrkrIdle);
}
BEGINmodExit
CODESTARTmodExit
	if(bWrkrRunning) {
		stopWorkerPool();
		bWrkrRunning = 0;
	}
	tcpsrvClassExit();
	tcps_sessClassExit();
	pthread_mutex_destroy(&amp;wrkrMut);
ENDmodExit
BEGINqueryEtryPt
CODESTARTqueryEtryPt
CODEqueryEtryPt_STD_LIB_QUERIES
ENDqueryEtryPt
BEGINmodInit()
CODESTARTmodInit
	pthread_mutex_init(&amp;wrkrMut, NULL);
	bWrkrRunning = 0;
	CHKiRet(tcps_sessClassInit(pModInfo));
	CHKiRet(tcpsrvClassInit(pModInfo)); ENDmodInit
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
