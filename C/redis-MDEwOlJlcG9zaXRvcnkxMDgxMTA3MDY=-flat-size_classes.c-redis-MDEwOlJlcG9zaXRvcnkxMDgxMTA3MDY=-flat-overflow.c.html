
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 44, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-size_classes.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  static size_t
3  get_max_size_class(void) {
4  	unsigned nlextents;
5  	size_t mib[4];
6  	size_t sz, miblen, max_size_class;
7  	sz = sizeof(unsigned);
8  	assert_d_eq(mallctl("arenas.nlextents", (void *)&nlextents, &sz, NULL,
9  	    0), 0, "Unexpected mallctl() error");
10  	miblen = sizeof(mib) / sizeof(size_t);
11  	assert_d_eq(mallctlnametomib("arenas.lextent.0.size", mib, &miblen), 0,
12  	    "Unexpected mallctlnametomib() error");
<span onclick='openModal()' class='match'>13  	mib[2] = nlextents - 1;
14  	sz = sizeof(size_t);
15  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&max_size_class, &sz,
16  	    NULL, 0), 0, "Unexpected mallctlbymib() error");
17  	return max_size_class;
</span>18  }
19  TEST_BEGIN(test_size_classes) {
20  	size_t size_class, max_size_class;
21  	szind_t index, max_index;
22  	max_size_class = get_max_size_class();
23  	max_index = sz_size2index(max_size_class);
24  	for (index = 0, size_class = sz_index2size(index); index < max_index ||
25  	    size_class < max_size_class; index++, size_class =
26  	    sz_index2size(index)) {
27  		assert_true(index < max_index,
28  		    "Loop conditionals should be equivalent; index=%u, "
29  		    "size_class=%zu (%#zx)", index, size_class, size_class);
30  		assert_true(size_class < max_size_class,
31  		    "Loop conditionals should be equivalent; index=%u, "
32  		    "size_class=%zu (%#zx)", index, size_class, size_class);
33  		assert_u_eq(index, sz_size2index(size_class),
34  		    "sz_size2index() does not reverse sz_index2size(): index=%u"
35  		    " --> size_class=%zu --> index=%u --> size_class=%zu",
36  		    index, size_class, sz_size2index(size_class),
37  		    sz_index2size(sz_size2index(size_class)));
38  		assert_zu_eq(size_class,
39  		    sz_index2size(sz_size2index(size_class)),
40  		    "sz_index2size() does not reverse sz_size2index(): index=%u"
41  		    " --> size_class=%zu --> index=%u --> size_class=%zu",
42  		    index, size_class, sz_size2index(size_class),
43  		    sz_index2size(sz_size2index(size_class)));
44  		assert_u_eq(index+1, sz_size2index(size_class+1),
45  		    "Next size_class does not round up properly");
46  		assert_zu_eq(size_class, (index > 0) ?
47  		    sz_s2u(sz_index2size(index-1)+1) : sz_s2u(1),
48  		    "sz_s2u() does not round up to size class");
49  		assert_zu_eq(size_class, sz_s2u(size_class-1),
50  		    "sz_s2u() does not round up to size class");
51  		assert_zu_eq(size_class, sz_s2u(size_class),
52  		    "sz_s2u() does not compute same size class");
53  		assert_zu_eq(sz_s2u(size_class+1), sz_index2size(index+1),
54  		    "sz_s2u() does not round up to next size class");
55  	}
56  	assert_u_eq(index, sz_size2index(sz_index2size(index)),
57  	    "sz_size2index() does not reverse sz_index2size()");
58  	assert_zu_eq(max_size_class, sz_index2size(
59  	    sz_size2index(max_size_class)),
60  	    "sz_index2size() does not reverse sz_size2index()");
61  	assert_zu_eq(size_class, sz_s2u(sz_index2size(index-1)+1),
62  	    "sz_s2u() does not round up to size class");
63  	assert_zu_eq(size_class, sz_s2u(size_class-1),
64  	    "sz_s2u() does not round up to size class");
65  	assert_zu_eq(size_class, sz_s2u(size_class),
66  	    "sz_s2u() does not compute same size class");
67  }
68  TEST_END
69  TEST_BEGIN(test_psize_classes) {
70  	size_t size_class, max_psz;
71  	pszind_t pind, max_pind;
72  	max_psz = get_max_size_class() + PAGE;
73  	max_pind = sz_psz2ind(max_psz);
74  	for (pind = 0, size_class = sz_pind2sz(pind);
75  	    pind < max_pind || size_class < max_psz;
76  	    pind++, size_class = sz_pind2sz(pind)) {
77  		assert_true(pind < max_pind,
78  		    "Loop conditionals should be equivalent; pind=%u, "
79  		    "size_class=%zu (%#zx)", pind, size_class, size_class);
80  		assert_true(size_class < max_psz,
81  		    "Loop conditionals should be equivalent; pind=%u, "
82  		    "size_class=%zu (%#zx)", pind, size_class, size_class);
83  		assert_u_eq(pind, sz_psz2ind(size_class),
84  		    "sz_psz2ind() does not reverse sz_pind2sz(): pind=%u -->"
85  		    " size_class=%zu --> pind=%u --> size_class=%zu", pind,
86  		    size_class, sz_psz2ind(size_class),
87  		    sz_pind2sz(sz_psz2ind(size_class)));
88  		assert_zu_eq(size_class, sz_pind2sz(sz_psz2ind(size_class)),
89  		    "sz_pind2sz() does not reverse sz_psz2ind(): pind=%u -->"
90  		    " size_class=%zu --> pind=%u --> size_class=%zu", pind,
91  		    size_class, sz_psz2ind(size_class),
92  		    sz_pind2sz(sz_psz2ind(size_class)));
93  		if (size_class == SC_LARGE_MAXCLASS) {
94  			assert_u_eq(SC_NPSIZES, sz_psz2ind(size_class + 1),
95  			    "Next size_class does not round up properly");
96  		} else {
97  			assert_u_eq(pind + 1, sz_psz2ind(size_class + 1),
98  			    "Next size_class does not round up properly");
99  		}
100  		assert_zu_eq(size_class, (pind > 0) ?
101  		    sz_psz2u(sz_pind2sz(pind-1)+1) : sz_psz2u(1),
102  		    "sz_psz2u() does not round up to size class");
103  		assert_zu_eq(size_class, sz_psz2u(size_class-1),
104  		    "sz_psz2u() does not round up to size class");
105  		assert_zu_eq(size_class, sz_psz2u(size_class),
106  		    "sz_psz2u() does not compute same size class");
107  		assert_zu_eq(sz_psz2u(size_class+1), sz_pind2sz(pind+1),
108  		    "sz_psz2u() does not round up to next size class");
109  	}
110  	assert_u_eq(pind, sz_psz2ind(sz_pind2sz(pind)),
111  	    "sz_psz2ind() does not reverse sz_pind2sz()");
112  	assert_zu_eq(max_psz, sz_pind2sz(sz_psz2ind(max_psz)),
113  	    "sz_pind2sz() does not reverse sz_psz2ind()");
114  	assert_zu_eq(size_class, sz_psz2u(sz_pind2sz(pind-1)+1),
115  	    "sz_psz2u() does not round up to size class");
116  	assert_zu_eq(size_class, sz_psz2u(size_class-1),
117  	    "sz_psz2u() does not round up to size class");
118  	assert_zu_eq(size_class, sz_psz2u(size_class),
119  	    "sz_psz2u() does not compute same size class");
120  }
121  TEST_END
122  TEST_BEGIN(test_overflow) {
123  	size_t max_size_class, max_psz;
124  	max_size_class = get_max_size_class();
125  	max_psz = max_size_class + PAGE;
126  	assert_u_eq(sz_size2index(max_size_class+1), SC_NSIZES,
127  	    "sz_size2index() should return NSIZES on overflow");
128  	assert_u_eq(sz_size2index(ZU(PTRDIFF_MAX)+1), SC_NSIZES,
129  	    "sz_size2index() should return NSIZES on overflow");
130  	assert_u_eq(sz_size2index(SIZE_T_MAX), SC_NSIZES,
131  	    "sz_size2index() should return NSIZES on overflow");
132  	assert_zu_eq(sz_s2u(max_size_class+1), 0,
133  	    "sz_s2u() should return 0 for unsupported size");
134  	assert_zu_eq(sz_s2u(ZU(PTRDIFF_MAX)+1), 0,
135  	    "sz_s2u() should return 0 for unsupported size");
136  	assert_zu_eq(sz_s2u(SIZE_T_MAX), 0,
137  	    "sz_s2u() should return 0 on overflow");
138  	assert_u_eq(sz_psz2ind(max_size_class+1), SC_NPSIZES,
139  	    "sz_psz2ind() should return NPSIZES on overflow");
140  	assert_u_eq(sz_psz2ind(ZU(PTRDIFF_MAX)+1), SC_NPSIZES,
141  	    "sz_psz2ind() should return NPSIZES on overflow");
142  	assert_u_eq(sz_psz2ind(SIZE_T_MAX), SC_NPSIZES,
143  	    "sz_psz2ind() should return NPSIZES on overflow");
144  	assert_zu_eq(sz_psz2u(max_size_class+1), max_psz,
145  	    "sz_psz2u() should return (LARGE_MAXCLASS + PAGE) for unsupported"
146  	    " size");
147  	assert_zu_eq(sz_psz2u(ZU(PTRDIFF_MAX)+1), max_psz,
148  	    "sz_psz2u() should return (LARGE_MAXCLASS + PAGE) for unsupported "
149  	    "size");
150  	assert_zu_eq(sz_psz2u(SIZE_T_MAX), max_psz,
151  	    "sz_psz2u() should return (LARGE_MAXCLASS + PAGE) on overflow");
152  }
153  TEST_END
154  int
155  main(void) {
156  	return test(
157  	    test_size_classes,
158  	    test_psize_classes,
159  	    test_overflow);
160  }
</code></pre>
        </div>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-overflow.c</h3>
            <pre><code>1  #include "test/jemalloc_test.h"
2  JEMALLOC_DIAGNOSTIC_PUSH
3  JEMALLOC_DIAGNOSTIC_IGNORE_ALLOC_SIZE_LARGER_THAN
4  TEST_BEGIN(test_overflow) {
5  	unsigned nlextents;
6  	size_t mib[4];
7  	size_t sz, miblen, max_size_class;
8  	void *p;
9  	sz = sizeof(unsigned);
10  	assert_d_eq(mallctl("arenas.nlextents", (void *)&nlextents, &sz, NULL,
11  	    0), 0, "Unexpected mallctl() error");
12  	miblen = sizeof(mib) / sizeof(size_t);
13  	assert_d_eq(mallctlnametomib("arenas.lextent.0.size", mib, &miblen), 0,
14  	    "Unexpected mallctlnametomib() error");
<span onclick='openModal()' class='match'>15  	mib[2] = nlextents - 1;
16  	sz = sizeof(size_t);
17  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&max_size_class, &sz,
18  	    NULL, 0), 0, "Unexpected mallctlbymib() error");
19  	assert_ptr_null(malloc(max_size_class + 1),
</span>20  	    "Expected OOM due to over-sized allocation request");
21  	assert_ptr_null(malloc(SIZE_T_MAX),
22  	    "Expected OOM due to over-sized allocation request");
23  	assert_ptr_null(calloc(1, max_size_class + 1),
24  	    "Expected OOM due to over-sized allocation request");
25  	assert_ptr_null(calloc(1, SIZE_T_MAX),
26  	    "Expected OOM due to over-sized allocation request");
27  	p = malloc(1);
28  	assert_ptr_not_null(p, "Unexpected malloc() OOM");
29  	assert_ptr_null(realloc(p, max_size_class + 1),
30  	    "Expected OOM due to over-sized allocation request");
31  	assert_ptr_null(realloc(p, SIZE_T_MAX),
32  	    "Expected OOM due to over-sized allocation request");
33  	free(p);
34  }
35  TEST_END
36  JEMALLOC_DIAGNOSTIC_POP
37  int
38  main(void) {
39  	return test(
40  	    test_overflow);
41  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-size_classes.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-overflow.c</div>
                </div>
                <div class="column column_space"><pre><code>13  	mib[2] = nlextents - 1;
14  	sz = sizeof(size_t);
15  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&max_size_class, &sz,
16  	    NULL, 0), 0, "Unexpected mallctlbymib() error");
17  	return max_size_class;
</pre></code></div>
                <div class="column column_space"><pre><code>15  	mib[2] = nlextents - 1;
16  	sz = sizeof(size_t);
17  	assert_d_eq(mallctlbymib(mib, miblen, (void *)&max_size_class, &sz,
18  	    NULL, 0), 0, "Unexpected mallctlbymib() error");
19  	assert_ptr_null(malloc(max_size_class + 1),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    