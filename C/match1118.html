<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for pybind11_tests.h &amp; eigen.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pybind11_tests.h &amp; eigen.h
      </h3>
<h1 align="center">
        2.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pybind11_tests.h (15.584415%)<th>eigen.h (1.6194332%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(59-62)<td><a href="#" name="0">(311-320)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pybind11_tests.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include &lt;pybind11/pybind11.h&gt;
3 #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1910
4 #  pragma warning(disable: 4503) #endif
5 namespace py = pybind11;
6 using namespace pybind11::literals;
7 class test_initializer {
8     using Initializer = void (*)(py::module &amp;);
9 public:
10     test_initializer(Initializer init);
11     test_initializer(const char *submodule_name, Initializer init);
12 };
13 #define TEST_SUBMODULE(name, variable)                   \
14     void test_submodule_##name(py::module &amp;);            \
15     test_initializer name(#name, test_submodule_##name); \
16     void test_submodule_##name(py::module &amp;variable)
17 struct UnregisteredType { };
18 class UserType {
19 public:
20     UserType() = default;
21     UserType(int i) : i(i) { }
22     int value() const { return i; }
23     void set(int set) { i = set; }
24 private:
25     int i = -1;
26 };
27 class IncType : public UserType {
28 public:
29     using UserType::UserType;
30     IncType() = default;
31     IncType(const IncType &amp;other) : IncType(other.value() + 1) { }
32     IncType(IncType &amp;&amp;) = delete;
33     IncType &amp;operator=(const IncType &amp;) = delete;
34     IncType &amp;operator=(IncType &amp;&amp;) = delete;
35 };
36 struct RValueCaster {};
37 <a name="0"></a>NAMESPACE_BEGIN(pybind11)
38 NAMESPACE_BEGIN(detail)
39 template&lt;&gt; class type_caster&lt;RValueCaster&gt; {
40 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>public:
41     PYBIND11_TYPE_CASTER(RValueCaster, _("RValueCaster"));
42     static handle cast(RValueCaster &amp;&amp;, return_value_policy, handle) { return py::str("rvalue").release(); }
43     static handle cast(const RValueCaster &amp;, return_value_policy, handle) { return py::str("lvalue").release(); }</b></font>
44 };
45 NAMESPACE_END(detail)
46 NAMESPACE_END(pybind11)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>eigen.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #pragma once
2 #include "numpy.h"
3 #if defined(__INTEL_COMPILER)
4 #  pragma warning(disable: 1682) #elif defined(__GNUG__) || defined(__clang__)
5 #  pragma GCC diagnostic push
6 #  pragma GCC diagnostic ignored "-Wconversion"
7 #  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
8 #  if __GNUC__ &gt;= 7
9 #    pragma GCC diagnostic ignored "-Wint-in-bool-context"
10 #  endif
11 #endif
12 #if defined(_MSC_VER)
13 #  pragma warning(push)
14 #  pragma warning(disable: 4127) #  pragma warning(disable: 4996) #endif
15 #include &lt;Eigen/Core&gt;
16 #include &lt;Eigen/SparseCore&gt;
17 static_assert(EIGEN_VERSION_AT_LEAST(3,2,7), "Eigen support in pybind11 requires Eigen &gt;= 3.2.7");
18 NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
19 using EigenDStride = Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;;
20 template &lt;typename MatrixType&gt; using EigenDRef = Eigen::Ref&lt;MatrixType, 0, EigenDStride&gt;;
21 template &lt;typename MatrixType&gt; using EigenDMap = Eigen::Map&lt;MatrixType, 0, EigenDStride&gt;;
22 NAMESPACE_BEGIN(detail)
23 #if EIGEN_VERSION_AT_LEAST(3,3,0)
24 using EigenIndex = Eigen::Index;
25 #else
26 using EigenIndex = EIGEN_DEFAULT_DENSE_INDEX_TYPE;
27 #endif
28 template &lt;typename T&gt; using is_eigen_dense_map = all_of&lt;is_template_base_of&lt;Eigen::DenseBase, T&gt;, std::is_base_of&lt;Eigen::MapBase&lt;T, Eigen::ReadOnlyAccessors&gt;, T&gt;&gt;;
29 template &lt;typename T&gt; using is_eigen_mutable_map = std::is_base_of&lt;Eigen::MapBase&lt;T, Eigen::WriteAccessors&gt;, T&gt;;
30 template &lt;typename T&gt; using is_eigen_dense_plain = all_of&lt;negation&lt;is_eigen_dense_map&lt;T&gt;&gt;, is_template_base_of&lt;Eigen::PlainObjectBase, T&gt;&gt;;
31 template &lt;typename T&gt; using is_eigen_sparse = is_template_base_of&lt;Eigen::SparseMatrixBase, T&gt;;
32 template &lt;typename T&gt; using is_eigen_other = all_of&lt;
33     is_template_base_of&lt;Eigen::EigenBase, T&gt;,
34     negation&lt;any_of&lt;is_eigen_dense_map&lt;T&gt;, is_eigen_dense_plain&lt;T&gt;, is_eigen_sparse&lt;T&gt;&gt;&gt;
35 &gt;;
36 template &lt;bool EigenRowMajor&gt; struct EigenConformable {
37     bool conformable = false;
38     EigenIndex rows = 0, cols = 0;
39     EigenDStride stride{0, 0};          bool negativestrides = false;   
40     EigenConformable(bool fits = false) : conformable{fits} {}
41     EigenConformable(EigenIndex r, EigenIndex c,
42             EigenIndex rstride, EigenIndex cstride) :
43         conformable{true}, rows{r}, cols{c} {
44         if (rstride &lt; 0 || cstride &lt; 0) {
45             negativestrides = true;
46         } else {
47             stride = {EigenRowMajor ? rstride : cstride                       EigenRowMajor ? cstride : rstride         }
48     }
49     EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)
50         : EigenConformable(r, c, r == 1 ? c*stride : stride, c == 1 ? r : r*stride) {}
51     template &lt;typename props&gt; bool stride_compatible() const {
52         return
53             !negativestrides &amp;&amp;
54             (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner() ||
55                 (EigenRowMajor ? cols : rows) == 1) &amp;&amp;
56             (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer() ||
57                 (EigenRowMajor ? rows : cols) == 1);
58     }
59     operator bool() const { return conformable; }
60 };
61 template &lt;typename Type&gt; struct eigen_extract_stride { using type = Type; };
62 template &lt;typename PlainObjectType, int MapOptions, typename StrideType&gt;
63 struct eigen_extract_stride&lt;Eigen::Map&lt;PlainObjectType, MapOptions, StrideType&gt;&gt; { using type = StrideType; };
64 template &lt;typename PlainObjectType, int Options, typename StrideType&gt;
65 struct eigen_extract_stride&lt;Eigen::Ref&lt;PlainObjectType, Options, StrideType&gt;&gt; { using type = StrideType; };
66 template &lt;typename Type_&gt; struct EigenProps {
67     using Type = Type_;
68     using Scalar = typename Type::Scalar;
69     using StrideType = typename eigen_extract_stride&lt;Type&gt;::type;
70     static constexpr EigenIndex
71         rows = Type::RowsAtCompileTime,
72         cols = Type::ColsAtCompileTime,
73         size = Type::SizeAtCompileTime;
74     static constexpr bool
75         row_major = Type::IsRowMajor,
76         vector = Type::IsVectorAtCompileTime,         fixed_rows = rows != Eigen::Dynamic,
77         fixed_cols = cols != Eigen::Dynamic,
78         fixed = size != Eigen::Dynamic,         dynamic = !fixed_rows &amp;&amp; !fixed_cols; 
79     template &lt;EigenIndex i, EigenIndex ifzero&gt; using if_zero = std::integral_constant&lt;EigenIndex, i == 0 ? ifzero : i&gt;;
80     static constexpr EigenIndex inner_stride = if_zero&lt;StrideType::InnerStrideAtCompileTime, 1&gt;::value,
81                                 outer_stride = if_zero&lt;StrideType::OuterStrideAtCompileTime,
82                                                        vector ? size : row_major ? cols : rows&gt;::value;
83     static constexpr bool dynamic_stride = inner_stride == Eigen::Dynamic &amp;&amp; outer_stride == Eigen::Dynamic;
84     static constexpr bool requires_row_major = !dynamic_stride &amp;&amp; !vector &amp;&amp; (row_major ? inner_stride : outer_stride) == 1;
85     static constexpr bool requires_col_major = !dynamic_stride &amp;&amp; !vector &amp;&amp; (row_major ? outer_stride : inner_stride) == 1;
86     static EigenConformable&lt;row_major&gt; conformable(const array &amp;a) {
87         const auto dims = a.ndim();
88         if (dims &lt; 1 || dims &gt; 2)
89             return false;
90         if (dims == 2) { 
91             EigenIndex
92                 np_rows = a.shape(0),
93                 np_cols = a.shape(1),
94                 np_rstride = a.strides(0) / static_cast&lt;ssize_t&gt;(sizeof(Scalar)),
95                 np_cstride = a.strides(1) / static_cast&lt;ssize_t&gt;(sizeof(Scalar));
96             if ((fixed_rows &amp;&amp; np_rows != rows) || (fixed_cols &amp;&amp; np_cols != cols))
97                 return false;
98             return {np_rows, np_cols, np_rstride, np_cstride};
99         }
100         const EigenIndex n = a.shape(0),
101               stride = a.strides(0) / static_cast&lt;ssize_t&gt;(sizeof(Scalar));
102         if (vector) {             if (fixed &amp;&amp; size != n)
103                 return false;             return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};
104         }
105         else if (fixed) {
106             return false;
107         }
108         else if (fixed_cols) {
109             if (cols != n) return false;
110             return {1, n, stride};
111         }
112         else {
113             if (fixed_rows &amp;&amp; rows != n) return false;
114             return {n, 1, stride};
115         }
116     }
117     static PYBIND11_DESCR descriptor() {
118         constexpr bool show_writeable = is_eigen_dense_map&lt;Type&gt;::value &amp;&amp; is_eigen_mutable_map&lt;Type&gt;::value;
119         constexpr bool show_order = is_eigen_dense_map&lt;Type&gt;::value;
120         constexpr bool show_c_contiguous = show_order &amp;&amp; requires_row_major;
121         constexpr bool show_f_contiguous = !show_c_contiguous &amp;&amp; show_order &amp;&amp; requires_col_major;
122         return type_descr(_("numpy.ndarray[") + npy_format_descriptor&lt;Scalar&gt;::name() +
123             _("[")  + _&lt;fixed_rows&gt;(_&lt;(size_t) rows&gt;(), _("m")) +
124             _(", ") + _&lt;fixed_cols&gt;(_&lt;(size_t) cols&gt;(), _("n")) +
125             _("]") +
126             _&lt;show_writeable&gt;(", flags.writeable", "") +
127             _&lt;show_c_contiguous&gt;(", flags.c_contiguous", "") +
128             _&lt;show_f_contiguous&gt;(", flags.f_contiguous", "") +
129             _("]")
130         );
131     }
132 };
133 template &lt;typename props&gt; handle eigen_array_cast(typename props::Type const &amp;src, handle base = handle(), bool writeable = true) {
134     constexpr ssize_t elem_size = sizeof(typename props::Scalar);
135     array a;
136     if (props::vector)
137         a = array({ src.size() }, { elem_size * src.innerStride() }, src.data(), base);
138     else
139         a = array({ src.rows(), src.cols() }, { elem_size * src.rowStride(), elem_size * src.colStride() },
140                   src.data(), base);
141     if (!writeable)
142         array_proxy(a.ptr())-&gt;flags &amp;= ~detail::npy_api::NPY_ARRAY_WRITEABLE_;
143     return a.release();
144 }
145 template &lt;typename props, typename Type&gt;
146 handle eigen_ref_array(Type &amp;src, handle parent = none()) {
147     return eigen_array_cast&lt;props&gt;(src, parent, !std::is_const&lt;Type&gt;::value);
148 }
149 template &lt;typename props, typename Type, typename = enable_if_t&lt;is_eigen_dense_plain&lt;Type&gt;::value&gt;&gt;
150 handle eigen_encapsulate(Type *src) {
151     capsule base(src, [](void *o) { delete static_cast&lt;Type *&gt;(o); });
152     return eigen_ref_array&lt;props&gt;(*src, base);
153 }
154 template&lt;typename Type&gt;
155 struct type_caster&lt;Type, enable_if_t&lt;is_eigen_dense_plain&lt;Type&gt;::value&gt;&gt; {
156     using Scalar = typename Type::Scalar;
157     using props = EigenProps&lt;Type&gt;;
158     bool load(handle src, bool convert) {
159         if (!convert &amp;&amp; !isinstance&lt;array_t&lt;Scalar&gt;&gt;(src))
160             return false;
161         auto buf = array::ensure(src);
162         if (!buf)
163             return false;
164         auto dims = buf.ndim();
165         if (dims &lt; 1 || dims &gt; 2)
166             return false;
167         auto fits = props::conformable(buf);
168         if (!fits)
169             return false;
170         value = Type(fits.rows, fits.cols);
171         auto ref = reinterpret_steal&lt;array&gt;(eigen_ref_array&lt;props&gt;(value));
172         if (dims == 1) ref = ref.squeeze();
173         else if (ref.ndim() == 1) buf = buf.squeeze();
174         int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());
175         if (result &lt; 0) {             PyErr_Clear();
176             return false;
177         }
178         return true;
179     }
180 private:
181     template &lt;typename CType&gt;
182     static handle cast_impl(CType *src, return_value_policy policy, handle parent) {
183         switch (policy) {
184             case return_value_policy::take_ownership:
185             case return_value_policy::automatic:
186                 return eigen_encapsulate&lt;props&gt;(src);
187             case return_value_policy::move:
188                 return eigen_encapsulate&lt;props&gt;(new CType(std::move(*src)));
189             case return_value_policy::copy:
190                 return eigen_array_cast&lt;props&gt;(*src);
191             case return_value_policy::reference:
192             case return_value_policy::automatic_reference:
193                 return eigen_ref_array&lt;props&gt;(*src);
194             case return_value_policy::reference_internal:
195                 return eigen_ref_array&lt;props&gt;(*src, parent);
196             default:
197                 throw cast_error("unhandled return_value_policy: should not happen!");
198 <a name="0"></a>        };
199     }
200 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>public:
201     static handle cast(Type &amp;&amp;src, return_value_policy         return cast_impl(&amp;src, return_value_policy::move, parent);
202     }
203     static handle cast(const Type &amp;&amp;src, return_value_policy         return cast_impl(&amp;src, return_value_policy::move, parent);
204     }</b></font>
205     static handle cast(Type &amp;src, return_value_policy policy, handle parent) {
206         if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
207             policy = return_value_policy::copy;
208         return cast_impl(&amp;src, policy, parent);
209     }
210     static handle cast(const Type &amp;src, return_value_policy policy, handle parent) {
211         if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
212             policy = return_value_policy::copy;
213         return cast(&amp;src, policy, parent);
214     }
215     static handle cast(Type *src, return_value_policy policy, handle parent) {
216         return cast_impl(src, policy, parent);
217     }
218     static handle cast(const Type *src, return_value_policy policy, handle parent) {
219         return cast_impl(src, policy, parent);
220     }
221     static PYBIND11_DESCR name() { return props::descriptor(); }
222     operator Type*() { return &amp;value; }
223     operator Type&amp;() { return value; }
224     operator Type&amp;&amp;() &amp;&amp; { return std::move(value); }
225     template &lt;typename T&gt; using cast_op_type = movable_cast_op_type&lt;T&gt;;
226 private:
227     Type value;
228 };
229 template &lt;typename MapType&gt; struct eigen_map_caster {
230 private:
231     using props = EigenProps&lt;MapType&gt;;
232 public:
233     static handle cast(const MapType &amp;src, return_value_policy policy, handle parent) {
234         switch (policy) {
235             case return_value_policy::copy:
236                 return eigen_array_cast&lt;props&gt;(src);
237             case return_value_policy::reference_internal:
238                 return eigen_array_cast&lt;props&gt;(src, parent, is_eigen_mutable_map&lt;MapType&gt;::value);
239             case return_value_policy::reference:
240             case return_value_policy::automatic:
241             case return_value_policy::automatic_reference:
242                 return eigen_array_cast&lt;props&gt;(src, none(), is_eigen_mutable_map&lt;MapType&gt;::value);
243             default:
244                 pybind11_fail("Invalid return_value_policy for Eigen Map/Ref/Block type");
245         }
246     }
247     static PYBIND11_DESCR name() { return props::descriptor(); }
248     bool load(handle, bool) = delete;
249     operator MapType() = delete;
250     template &lt;typename&gt; using cast_op_type = MapType;
251 };
252 template &lt;typename Type&gt; struct type_caster&lt;Type, enable_if_t&lt;is_eigen_dense_map&lt;Type&gt;::value&gt;&gt;
253     : eigen_map_caster&lt;Type&gt; {};
254 template &lt;typename PlainObjectType, typename StrideType&gt;
255 struct type_caster&lt;
256     Eigen::Ref&lt;PlainObjectType, 0, StrideType&gt;,
257     enable_if_t&lt;is_eigen_dense_map&lt;Eigen::Ref&lt;PlainObjectType, 0, StrideType&gt;&gt;::value&gt;
258 &gt; : public eigen_map_caster&lt;Eigen::Ref&lt;PlainObjectType, 0, StrideType&gt;&gt; {
259 private:
260     using Type = Eigen::Ref&lt;PlainObjectType, 0, StrideType&gt;;
261     using props = EigenProps&lt;Type&gt;;
262     using Scalar = typename props::Scalar;
263     using MapType = Eigen::Map&lt;PlainObjectType, 0, StrideType&gt;;
264     using Array = array_t&lt;Scalar, array::forcecast |
265                 ((props::row_major ? props::inner_stride : props::outer_stride) == 1 ? array::c_style :
266                  (props::row_major ? props::outer_stride : props::inner_stride) == 1 ? array::f_style : 0)&gt;;
267     static constexpr bool need_writeable = is_eigen_mutable_map&lt;Type&gt;::value;
268     std::unique_ptr&lt;MapType&gt; map;
269     std::unique_ptr&lt;Type&gt; ref;
270     Array copy_or_ref;
271 public:
272     bool load(handle src, bool convert) {
273         bool need_copy = !isinstance&lt;Array&gt;(src);
274         EigenConformable&lt;props::row_major&gt; fits;
275         if (!need_copy) {
276             Array aref = reinterpret_borrow&lt;Array&gt;(src);
277             if (aref &amp;&amp; (!need_writeable || aref.writeable())) {
278                 fits = props::conformable(aref);
279                 if (!fits) return false;                 if (!fits.template stride_compatible&lt;props&gt;())
280                     need_copy = true;
281                 else
282                     copy_or_ref = std::move(aref);
283             }
284             else {
285                 need_copy = true;
286             }
287         }
288         if (need_copy) {
289             if (!convert || need_writeable) return false;
290             Array copy = Array::ensure(src);
291             if (!copy) return false;
292             fits = props::conformable(copy);
293             if (!fits || !fits.template stride_compatible&lt;props&gt;())
294                 return false;
295             copy_or_ref = std::move(copy);
296             loader_life_support::add_patient(copy_or_ref);
297         }
298         ref.reset();
299         map.reset(new MapType(data(copy_or_ref), fits.rows, fits.cols, make_stride(fits.stride.outer(), fits.stride.inner())));
300         ref.reset(new Type(*map));
301         return true;
302     }
303     operator Type*() { return ref.get(); }
304     operator Type&amp;() { return *ref; }
305     template &lt;typename _T&gt; using cast_op_type = pybind11::detail::cast_op_type&lt;_T&gt;;
306 private:
307     template &lt;typename T = Type, enable_if_t&lt;is_eigen_mutable_map&lt;T&gt;::value, int&gt; = 0&gt;
308     Scalar *data(Array &amp;a) { return a.mutable_data(); }
309     template &lt;typename T = Type, enable_if_t&lt;!is_eigen_mutable_map&lt;T&gt;::value, int&gt; = 0&gt;
310     const Scalar *data(Array &amp;a) { return a.data(); }
311     template &lt;typename S&gt; using stride_ctor_default = bool_constant&lt;
312         S::InnerStrideAtCompileTime != Eigen::Dynamic &amp;&amp; S::OuterStrideAtCompileTime != Eigen::Dynamic &amp;&amp;
313         std::is_default_constructible&lt;S&gt;::value&gt;;
314     template &lt;typename S&gt; using stride_ctor_dual = bool_constant&lt;
315         !stride_ctor_default&lt;S&gt;::value &amp;&amp; std::is_constructible&lt;S, EigenIndex, EigenIndex&gt;::value&gt;;
316     template &lt;typename S&gt; using stride_ctor_outer = bool_constant&lt;
317         !any_of&lt;stride_ctor_default&lt;S&gt;, stride_ctor_dual&lt;S&gt;&gt;::value &amp;&amp;
318         S::OuterStrideAtCompileTime == Eigen::Dynamic &amp;&amp; S::InnerStrideAtCompileTime != Eigen::Dynamic &amp;&amp;
319         std::is_constructible&lt;S, EigenIndex&gt;::value&gt;;
320     template &lt;typename S&gt; using stride_ctor_inner = bool_constant&lt;
321         !any_of&lt;stride_ctor_default&lt;S&gt;, stride_ctor_dual&lt;S&gt;&gt;::value &amp;&amp;
322         S::InnerStrideAtCompileTime == Eigen::Dynamic &amp;&amp; S::OuterStrideAtCompileTime != Eigen::Dynamic &amp;&amp;
323         std::is_constructible&lt;S, EigenIndex&gt;::value&gt;;
324     template &lt;typename S = StrideType, enable_if_t&lt;stride_ctor_default&lt;S&gt;::value, int&gt; = 0&gt;
325     static S make_stride(EigenIndex, EigenIndex) { return S(); }
326     template &lt;typename S = StrideType, enable_if_t&lt;stride_ctor_dual&lt;S&gt;::value, int&gt; = 0&gt;
327     static S make_stride(EigenIndex outer, EigenIndex inner) { return S(outer, inner); }
328     template &lt;typename S = StrideType, enable_if_t&lt;stride_ctor_outer&lt;S&gt;::value, int&gt; = 0&gt;
329     static S make_stride(EigenIndex outer, EigenIndex) { return S(outer); }
330     template &lt;typename S = StrideType, enable_if_t&lt;stride_ctor_inner&lt;S&gt;::value, int&gt; = 0&gt;
331     static S make_stride(EigenIndex, EigenIndex inner) { return S(inner); }
332 };
333 template &lt;typename Type&gt;
334 struct type_caster&lt;Type, enable_if_t&lt;is_eigen_other&lt;Type&gt;::value&gt;&gt; {
335 protected:
336     using Matrix = Eigen::Matrix&lt;typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime&gt;;
337     using props = EigenProps&lt;Matrix&gt;;
338 public:
339     static handle cast(const Type &amp;src, return_value_policy         handle h = eigen_encapsulate&lt;props&gt;(new Matrix(src));
340         return h;
341     }
342     static handle cast(const Type *src, return_value_policy policy, handle parent) { return cast(*src, policy, parent); }
343     static PYBIND11_DESCR name() { return props::descriptor(); }
344     bool load(handle, bool) = delete;
345     operator Type() = delete;
346     template &lt;typename&gt; using cast_op_type = Type;
347 };
348 template&lt;typename Type&gt;
349 struct type_caster&lt;Type, enable_if_t&lt;is_eigen_sparse&lt;Type&gt;::value&gt;&gt; {
350     typedef typename Type::Scalar Scalar;
351     typedef remove_reference_t&lt;decltype(*std::declval&lt;Type&gt;().outerIndexPtr())&gt; StorageIndex;
352     typedef typename Type::Index Index;
353     static constexpr bool rowMajor = Type::IsRowMajor;
354     bool load(handle src, bool) {
355         if (!src)
356             return false;
357         auto obj = reinterpret_borrow&lt;object&gt;(src);
358         object sparse_module = module::import("scipy.sparse");
359         object matrix_type = sparse_module.attr(
360             rowMajor ? "csr_matrix" : "csc_matrix");
361         if (!obj.get_type().is(matrix_type)) {
362             try {
363                 obj = matrix_type(obj);
364             } catch (const error_already_set &amp;) {
365                 return false;
366             }
367         }
368         auto values = array_t&lt;Scalar&gt;((object) obj.attr("data"));
369         auto innerIndices = array_t&lt;StorageIndex&gt;((object) obj.attr("indices"));
370         auto outerIndices = array_t&lt;StorageIndex&gt;((object) obj.attr("indptr"));
371         auto shape = pybind11::tuple((pybind11::object) obj.attr("shape"));
372         auto nnz = obj.attr("nnz").cast&lt;Index&gt;();
373         if (!values || !innerIndices || !outerIndices)
374             return false;
375         value = Eigen::MappedSparseMatrix&lt;Scalar, Type::Flags, StorageIndex&gt;(
376             shape[0].cast&lt;Index&gt;(), shape[1].cast&lt;Index&gt;(), nnz,
377             outerIndices.mutable_data(), innerIndices.mutable_data(), values.mutable_data());
378         return true;
379     }
380     static handle cast(const Type &amp;src, return_value_policy         const_cast&lt;Type&amp;&gt;(src).makeCompressed();
381         object matrix_type = module::import("scipy.sparse").attr(
382             rowMajor ? "csr_matrix" : "csc_matrix");
383         array data(src.nonZeros(), src.valuePtr());
384         array outerIndices((rowMajor ? src.rows() : src.cols()) + 1, src.outerIndexPtr());
385         array innerIndices(src.nonZeros(), src.innerIndexPtr());
386         return matrix_type(
387             std::make_tuple(data, innerIndices, outerIndices),
388             std::make_pair(src.rows(), src.cols())
389         ).release();
390     }
391     PYBIND11_TYPE_CASTER(Type, _&lt;(Type::IsRowMajor) != 0&gt;("scipy.sparse.csr_matrix[", "scipy.sparse.csc_matrix[")
392             + npy_format_descriptor&lt;Scalar&gt;::name() + _("]"));
393 };
394 NAMESPACE_END(detail)
395 NAMESPACE_END(PYBIND11_NAMESPACE)
396 #if defined(__GNUG__) || defined(__clang__)
397 #  pragma GCC diagnostic pop
398 #elif defined(_MSC_VER)
399 #  pragma warning(pop)
400 #endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
