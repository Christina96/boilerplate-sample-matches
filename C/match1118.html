<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for pybind11_tests.h &amp; eigen.h</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for pybind11_tests.h &amp; eigen.h
      </h3>
<h1 align="center">
        2.9%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>pybind11_tests.h (15.584415%)<th>eigen.h (1.6194332%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(59-62)<td><a href="#" name="0">(311-320)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>pybind11_tests.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
#pragma once
#include &lt;pybind11/pybind11.h&gt;

#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1910
// We get some really long type names here which causes MSVC 2015 to emit warnings
#  pragma warning(disable: 4503) // warning C4503: decorated name length exceeded, name was truncated
#endif

namespace py = pybind11;
using namespace pybind11::literals;

class test_initializer {
    using Initializer = void (*)(py::module &amp;);

public:
    test_initializer(Initializer init);
    test_initializer(const char *submodule_name, Initializer init);
};

#define TEST_SUBMODULE(name, variable)                   \
    void test_submodule_##name(py::module &amp;);            \
    test_initializer name(#name, test_submodule_##name); \
    void test_submodule_##name(py::module &amp;variable)


/// Dummy type which is not exported anywhere -- something to trigger a conversion error
struct UnregisteredType { };

/// A user-defined type which is exported and can be used by any test
class UserType {
public:
    UserType() = default;
    UserType(int i) : i(i) { }

    int value() const { return i; }
    void set(int set) { i = set; }

private:
    int i = -1;
};

/// Like UserType, but increments `value` on copy for quick reference vs. copy tests
class IncType : public UserType {
public:
    using UserType::UserType;
    IncType() = default;
    IncType(const IncType &amp;other) : IncType(other.value() + 1) { }
    IncType(IncType &amp;&amp;) = delete;
    IncType &amp;operator=(const IncType &amp;) = delete;
    IncType &amp;operator=(IncType &amp;&amp;) = delete;
};

/// Custom cast-only type that casts to a string "rvalue" or "lvalue" depending on the cast context.
/// Used to test recursive casters (e.g. std::tuple, stl containers).
struct RValueCaster {};
<a name="0"></a>NAMESPACE_BEGIN(pybind11)
NAMESPACE_BEGIN(detail)
template&lt;&gt; class type_caster&lt;RValueCaster&gt; {
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>public:
    PYBIND11_TYPE_CASTER(RValueCaster, _("RValueCaster"));
    static handle cast(RValueCaster &amp;&amp;, return_value_policy, handle) { return py::str("rvalue").release(); }
    static handle cast(const RValueCaster &amp;, return_value_policy, handle) { return py::str("lvalue").release(); }</b></font>
};
NAMESPACE_END(detail)
NAMESPACE_END(pybind11)
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>eigen.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
    pybind11/eigen.h: Transparent conversion for dense and sparse Eigen matrices

    Copyright (c) 2016 Wenzel Jakob &lt;wenzel.jakob@epfl.ch&gt;

    All rights reserved. Use of this source code is governed by a
    BSD-style license that can be found in the LICENSE file.
*/

#pragma once

#include "numpy.h"

#if defined(__INTEL_COMPILER)
#  pragma warning(disable: 1682) // implicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem)
#elif defined(__GNUG__) || defined(__clang__)
#  pragma GCC diagnostic push
#  pragma GCC diagnostic ignored "-Wconversion"
#  pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#  if __GNUC__ &gt;= 7
#    pragma GCC diagnostic ignored "-Wint-in-bool-context"
#  endif
#endif

#if defined(_MSC_VER)
#  pragma warning(push)
#  pragma warning(disable: 4127) // warning C4127: Conditional expression is constant
#  pragma warning(disable: 4996) // warning C4996: std::unary_negate is deprecated in C++17
#endif

#include &lt;Eigen/Core&gt;
#include &lt;Eigen/SparseCore&gt;

// Eigen prior to 3.2.7 doesn't have proper move constructors--but worse, some classes get implicit
// move constructors that break things.  We could detect this an explicitly copy, but an extra copy
// of matrices seems highly undesirable.
static_assert(EIGEN_VERSION_AT_LEAST(3,2,7), "Eigen support in pybind11 requires Eigen &gt;= 3.2.7");

NAMESPACE_BEGIN(PYBIND11_NAMESPACE)

// Provide a convenience alias for easier pass-by-ref usage with fully dynamic strides:
using EigenDStride = Eigen::Stride&lt;Eigen::Dynamic, Eigen::Dynamic&gt;;
template &lt;typename MatrixType&gt; using EigenDRef = Eigen::Ref&lt;MatrixType, 0, EigenDStride&gt;;
template &lt;typename MatrixType&gt; using EigenDMap = Eigen::Map&lt;MatrixType, 0, EigenDStride&gt;;

NAMESPACE_BEGIN(detail)

#if EIGEN_VERSION_AT_LEAST(3,3,0)
using EigenIndex = Eigen::Index;
#else
using EigenIndex = EIGEN_DEFAULT_DENSE_INDEX_TYPE;
#endif

// Matches Eigen::Map, Eigen::Ref, blocks, etc:
template &lt;typename T&gt; using is_eigen_dense_map = all_of&lt;is_template_base_of&lt;Eigen::DenseBase, T&gt;, std::is_base_of&lt;Eigen::MapBase&lt;T, Eigen::ReadOnlyAccessors&gt;, T&gt;&gt;;
template &lt;typename T&gt; using is_eigen_mutable_map = std::is_base_of&lt;Eigen::MapBase&lt;T, Eigen::WriteAccessors&gt;, T&gt;;
template &lt;typename T&gt; using is_eigen_dense_plain = all_of&lt;negation&lt;is_eigen_dense_map&lt;T&gt;&gt;, is_template_base_of&lt;Eigen::PlainObjectBase, T&gt;&gt;;
template &lt;typename T&gt; using is_eigen_sparse = is_template_base_of&lt;Eigen::SparseMatrixBase, T&gt;;
// Test for objects inheriting from EigenBase&lt;Derived&gt; that aren't captured by the above.  This
// basically covers anything that can be assigned to a dense matrix but that don't have a typical
// matrix data layout that can be copied from their .data().  For example, DiagonalMatrix and
// SelfAdjointView fall into this category.
template &lt;typename T&gt; using is_eigen_other = all_of&lt;
    is_template_base_of&lt;Eigen::EigenBase, T&gt;,
    negation&lt;any_of&lt;is_eigen_dense_map&lt;T&gt;, is_eigen_dense_plain&lt;T&gt;, is_eigen_sparse&lt;T&gt;&gt;&gt;
&gt;;

// Captures numpy/eigen conformability status (returned by EigenProps::conformable()):
template &lt;bool EigenRowMajor&gt; struct EigenConformable {
    bool conformable = false;
    EigenIndex rows = 0, cols = 0;
    EigenDStride stride{0, 0};      // Only valid if negativestrides is false!
    bool negativestrides = false;   // If true, do not use stride!

    EigenConformable(bool fits = false) : conformable{fits} {}
    // Matrix type:
    EigenConformable(EigenIndex r, EigenIndex c,
            EigenIndex rstride, EigenIndex cstride) :
        conformable{true}, rows{r}, cols{c} {
        // TODO: when Eigen bug #747 is fixed, remove the tests for non-negativity. http://eigen.tuxfamily.org/bz/show_bug.cgi?id=747
        if (rstride &lt; 0 || cstride &lt; 0) {
            negativestrides = true;
        } else {
            stride = {EigenRowMajor ? rstride : cstride /* outer stride */,
                      EigenRowMajor ? cstride : rstride /* inner stride */ };
        }
    }
    // Vector type:
    EigenConformable(EigenIndex r, EigenIndex c, EigenIndex stride)
        : EigenConformable(r, c, r == 1 ? c*stride : stride, c == 1 ? r : r*stride) {}

    template &lt;typename props&gt; bool stride_compatible() const {
        // To have compatible strides, we need (on both dimensions) one of fully dynamic strides,
        // matching strides, or a dimension size of 1 (in which case the stride value is irrelevant)
        return
            !negativestrides &amp;&amp;
            (props::inner_stride == Eigen::Dynamic || props::inner_stride == stride.inner() ||
                (EigenRowMajor ? cols : rows) == 1) &amp;&amp;
            (props::outer_stride == Eigen::Dynamic || props::outer_stride == stride.outer() ||
                (EigenRowMajor ? rows : cols) == 1);
    }
    operator bool() const { return conformable; }
};

template &lt;typename Type&gt; struct eigen_extract_stride { using type = Type; };
template &lt;typename PlainObjectType, int MapOptions, typename StrideType&gt;
struct eigen_extract_stride&lt;Eigen::Map&lt;PlainObjectType, MapOptions, StrideType&gt;&gt; { using type = StrideType; };
template &lt;typename PlainObjectType, int Options, typename StrideType&gt;
struct eigen_extract_stride&lt;Eigen::Ref&lt;PlainObjectType, Options, StrideType&gt;&gt; { using type = StrideType; };

// Helper struct for extracting information from an Eigen type
template &lt;typename Type_&gt; struct EigenProps {
    using Type = Type_;
    using Scalar = typename Type::Scalar;
    using StrideType = typename eigen_extract_stride&lt;Type&gt;::type;
    static constexpr EigenIndex
        rows = Type::RowsAtCompileTime,
        cols = Type::ColsAtCompileTime,
        size = Type::SizeAtCompileTime;
    static constexpr bool
        row_major = Type::IsRowMajor,
        vector = Type::IsVectorAtCompileTime, // At least one dimension has fixed size 1
        fixed_rows = rows != Eigen::Dynamic,
        fixed_cols = cols != Eigen::Dynamic,
        fixed = size != Eigen::Dynamic, // Fully-fixed size
        dynamic = !fixed_rows &amp;&amp; !fixed_cols; // Fully-dynamic size

    template &lt;EigenIndex i, EigenIndex ifzero&gt; using if_zero = std::integral_constant&lt;EigenIndex, i == 0 ? ifzero : i&gt;;
    static constexpr EigenIndex inner_stride = if_zero&lt;StrideType::InnerStrideAtCompileTime, 1&gt;::value,
                                outer_stride = if_zero&lt;StrideType::OuterStrideAtCompileTime,
                                                       vector ? size : row_major ? cols : rows&gt;::value;
    static constexpr bool dynamic_stride = inner_stride == Eigen::Dynamic &amp;&amp; outer_stride == Eigen::Dynamic;
    static constexpr bool requires_row_major = !dynamic_stride &amp;&amp; !vector &amp;&amp; (row_major ? inner_stride : outer_stride) == 1;
    static constexpr bool requires_col_major = !dynamic_stride &amp;&amp; !vector &amp;&amp; (row_major ? outer_stride : inner_stride) == 1;

    // Takes an input array and determines whether we can make it fit into the Eigen type.  If
    // the array is a vector, we attempt to fit it into either an Eigen 1xN or Nx1 vector
    // (preferring the latter if it will fit in either, i.e. for a fully dynamic matrix type).
    static EigenConformable&lt;row_major&gt; conformable(const array &amp;a) {
        const auto dims = a.ndim();
        if (dims &lt; 1 || dims &gt; 2)
            return false;

        if (dims == 2) { // Matrix type: require exact match (or dynamic)

            EigenIndex
                np_rows = a.shape(0),
                np_cols = a.shape(1),
                np_rstride = a.strides(0) / static_cast&lt;ssize_t&gt;(sizeof(Scalar)),
                np_cstride = a.strides(1) / static_cast&lt;ssize_t&gt;(sizeof(Scalar));
            if ((fixed_rows &amp;&amp; np_rows != rows) || (fixed_cols &amp;&amp; np_cols != cols))
                return false;

            return {np_rows, np_cols, np_rstride, np_cstride};
        }

        // Otherwise we're storing an n-vector.  Only one of the strides will be used, but whichever
        // is used, we want the (single) numpy stride value.
        const EigenIndex n = a.shape(0),
              stride = a.strides(0) / static_cast&lt;ssize_t&gt;(sizeof(Scalar));

        if (vector) { // Eigen type is a compile-time vector
            if (fixed &amp;&amp; size != n)
                return false; // Vector size mismatch
            return {rows == 1 ? 1 : n, cols == 1 ? 1 : n, stride};
        }
        else if (fixed) {
            // The type has a fixed size, but is not a vector: abort
            return false;
        }
        else if (fixed_cols) {
            // Since this isn't a vector, cols must be != 1.  We allow this only if it exactly
            // equals the number of elements (rows is Dynamic, and so 1 row is allowed).
            if (cols != n) return false;
            return {1, n, stride};
        }
        else {
            // Otherwise it's either fully dynamic, or column dynamic; both become a column vector
            if (fixed_rows &amp;&amp; rows != n) return false;
            return {n, 1, stride};
        }
    }

    static PYBIND11_DESCR descriptor() {
        constexpr bool show_writeable = is_eigen_dense_map&lt;Type&gt;::value &amp;&amp; is_eigen_mutable_map&lt;Type&gt;::value;
        constexpr bool show_order = is_eigen_dense_map&lt;Type&gt;::value;
        constexpr bool show_c_contiguous = show_order &amp;&amp; requires_row_major;
        constexpr bool show_f_contiguous = !show_c_contiguous &amp;&amp; show_order &amp;&amp; requires_col_major;

        return type_descr(_("numpy.ndarray[") + npy_format_descriptor&lt;Scalar&gt;::name() +
            _("[")  + _&lt;fixed_rows&gt;(_&lt;(size_t) rows&gt;(), _("m")) +
            _(", ") + _&lt;fixed_cols&gt;(_&lt;(size_t) cols&gt;(), _("n")) +
            _("]") +
            // For a reference type (e.g. Ref&lt;MatrixXd&gt;) we have other constraints that might need to be
            // satisfied: writeable=True (for a mutable reference), and, depending on the map's stride
            // options, possibly f_contiguous or c_contiguous.  We include them in the descriptor output
            // to provide some hint as to why a TypeError is occurring (otherwise it can be confusing to
            // see that a function accepts a 'numpy.ndarray[float64[3,2]]' and an error message that you
            // *gave* a numpy.ndarray of the right type and dimensions.
            _&lt;show_writeable&gt;(", flags.writeable", "") +
            _&lt;show_c_contiguous&gt;(", flags.c_contiguous", "") +
            _&lt;show_f_contiguous&gt;(", flags.f_contiguous", "") +
            _("]")
        );
    }
};

// Casts an Eigen type to numpy array.  If given a base, the numpy array references the src data,
// otherwise it'll make a copy.  writeable lets you turn off the writeable flag for the array.
template &lt;typename props&gt; handle eigen_array_cast(typename props::Type const &amp;src, handle base = handle(), bool writeable = true) {
    constexpr ssize_t elem_size = sizeof(typename props::Scalar);
    array a;
    if (props::vector)
        a = array({ src.size() }, { elem_size * src.innerStride() }, src.data(), base);
    else
        a = array({ src.rows(), src.cols() }, { elem_size * src.rowStride(), elem_size * src.colStride() },
                  src.data(), base);

    if (!writeable)
        array_proxy(a.ptr())-&gt;flags &amp;= ~detail::npy_api::NPY_ARRAY_WRITEABLE_;

    return a.release();
}

// Takes an lvalue ref to some Eigen type and a (python) base object, creating a numpy array that
// reference the Eigen object's data with `base` as the python-registered base class (if omitted,
// the base will be set to None, and lifetime management is up to the caller).  The numpy array is
// non-writeable if the given type is const.
template &lt;typename props, typename Type&gt;
handle eigen_ref_array(Type &amp;src, handle parent = none()) {
    // none here is to get past array's should-we-copy detection, which currently always
    // copies when there is no base.  Setting the base to None should be harmless.
    return eigen_array_cast&lt;props&gt;(src, parent, !std::is_const&lt;Type&gt;::value);
}

// Takes a pointer to some dense, plain Eigen type, builds a capsule around it, then returns a numpy
// array that references the encapsulated data with a python-side reference to the capsule to tie
// its destruction to that of any dependent python objects.  Const-ness is determined by whether or
// not the Type of the pointer given is const.
template &lt;typename props, typename Type, typename = enable_if_t&lt;is_eigen_dense_plain&lt;Type&gt;::value&gt;&gt;
handle eigen_encapsulate(Type *src) {
    capsule base(src, [](void *o) { delete static_cast&lt;Type *&gt;(o); });
    return eigen_ref_array&lt;props&gt;(*src, base);
}

// Type caster for regular, dense matrix types (e.g. MatrixXd), but not maps/refs/etc. of dense
// types.
template&lt;typename Type&gt;
struct type_caster&lt;Type, enable_if_t&lt;is_eigen_dense_plain&lt;Type&gt;::value&gt;&gt; {
    using Scalar = typename Type::Scalar;
    using props = EigenProps&lt;Type&gt;;

    bool load(handle src, bool convert) {
        // If we're in no-convert mode, only load if given an array of the correct type
        if (!convert &amp;&amp; !isinstance&lt;array_t&lt;Scalar&gt;&gt;(src))
            return false;

        // Coerce into an array, but don't do type conversion yet; the copy below handles it.
        auto buf = array::ensure(src);

        if (!buf)
            return false;

        auto dims = buf.ndim();
        if (dims &lt; 1 || dims &gt; 2)
            return false;

        auto fits = props::conformable(buf);
        if (!fits)
            return false;

        // Allocate the new type, then build a numpy reference into it
        value = Type(fits.rows, fits.cols);
        auto ref = reinterpret_steal&lt;array&gt;(eigen_ref_array&lt;props&gt;(value));
        if (dims == 1) ref = ref.squeeze();
        else if (ref.ndim() == 1) buf = buf.squeeze();

        int result = detail::npy_api::get().PyArray_CopyInto_(ref.ptr(), buf.ptr());

        if (result &lt; 0) { // Copy failed!
            PyErr_Clear();
            return false;
        }

        return true;
    }

private:

    // Cast implementation
    template &lt;typename CType&gt;
    static handle cast_impl(CType *src, return_value_policy policy, handle parent) {
        switch (policy) {
            case return_value_policy::take_ownership:
            case return_value_policy::automatic:
                return eigen_encapsulate&lt;props&gt;(src);
            case return_value_policy::move:
                return eigen_encapsulate&lt;props&gt;(new CType(std::move(*src)));
            case return_value_policy::copy:
                return eigen_array_cast&lt;props&gt;(*src);
            case return_value_policy::reference:
            case return_value_policy::automatic_reference:
                return eigen_ref_array&lt;props&gt;(*src);
            case return_value_policy::reference_internal:
                return eigen_ref_array&lt;props&gt;(*src, parent);
            default:
                throw cast_error("unhandled return_value_policy: should not happen!");
<a name="0"></a>        };
    }

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>public:

    // Normal returned non-reference, non-const value:
    static handle cast(Type &amp;&amp;src, return_value_policy /* policy */, handle parent) {
        return cast_impl(&amp;src, return_value_policy::move, parent);
    }
    // If you return a non-reference const, we mark the numpy array readonly:
    static handle cast(const Type &amp;&amp;src, return_value_policy /* policy */, handle parent) {
        return cast_impl(&amp;src, return_value_policy::move, parent);
    }</b></font>
    // lvalue reference return; default (automatic) becomes copy
    static handle cast(Type &amp;src, return_value_policy policy, handle parent) {
        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
            policy = return_value_policy::copy;
        return cast_impl(&amp;src, policy, parent);
    }
    // const lvalue reference return; default (automatic) becomes copy
    static handle cast(const Type &amp;src, return_value_policy policy, handle parent) {
        if (policy == return_value_policy::automatic || policy == return_value_policy::automatic_reference)
            policy = return_value_policy::copy;
        return cast(&amp;src, policy, parent);
    }
    // non-const pointer return
    static handle cast(Type *src, return_value_policy policy, handle parent) {
        return cast_impl(src, policy, parent);
    }
    // const pointer return
    static handle cast(const Type *src, return_value_policy policy, handle parent) {
        return cast_impl(src, policy, parent);
    }

    static PYBIND11_DESCR name() { return props::descriptor(); }

    operator Type*() { return &amp;value; }
    operator Type&amp;() { return value; }
    operator Type&amp;&amp;() &amp;&amp; { return std::move(value); }
    template &lt;typename T&gt; using cast_op_type = movable_cast_op_type&lt;T&gt;;

private:
    Type value;
};

// Base class for casting reference/map/block/etc. objects back to python.
template &lt;typename MapType&gt; struct eigen_map_caster {
private:
    using props = EigenProps&lt;MapType&gt;;

public:

    // Directly referencing a ref/map's data is a bit dangerous (whatever the map/ref points to has
    // to stay around), but we'll allow it under the assumption that you know what you're doing (and
    // have an appropriate keep_alive in place).  We return a numpy array pointing directly at the
    // ref's data (The numpy array ends up read-only if the ref was to a const matrix type.) Note
    // that this means you need to ensure you don't destroy the object in some other way (e.g. with
    // an appropriate keep_alive, or with a reference to a statically allocated matrix).
    static handle cast(const MapType &amp;src, return_value_policy policy, handle parent) {
        switch (policy) {
            case return_value_policy::copy:
                return eigen_array_cast&lt;props&gt;(src);
            case return_value_policy::reference_internal:
                return eigen_array_cast&lt;props&gt;(src, parent, is_eigen_mutable_map&lt;MapType&gt;::value);
            case return_value_policy::reference:
            case return_value_policy::automatic:
            case return_value_policy::automatic_reference:
                return eigen_array_cast&lt;props&gt;(src, none(), is_eigen_mutable_map&lt;MapType&gt;::value);
            default:
                // move, take_ownership don't make any sense for a ref/map:
                pybind11_fail("Invalid return_value_policy for Eigen Map/Ref/Block type");
        }
    }

    static PYBIND11_DESCR name() { return props::descriptor(); }

    // Explicitly delete these: support python -&gt; C++ conversion on these (i.e. these can be return
    // types but not bound arguments).  We still provide them (with an explicitly delete) so that
    // you end up here if you try anyway.
    bool load(handle, bool) = delete;
    operator MapType() = delete;
    template &lt;typename&gt; using cast_op_type = MapType;
};

// We can return any map-like object (but can only load Refs, specialized next):
template &lt;typename Type&gt; struct type_caster&lt;Type, enable_if_t&lt;is_eigen_dense_map&lt;Type&gt;::value&gt;&gt;
    : eigen_map_caster&lt;Type&gt; {};

// Loader for Ref&lt;...&gt; arguments.  See the documentation for info on how to make this work without
// copying (it requires some extra effort in many cases).
template &lt;typename PlainObjectType, typename StrideType&gt;
struct type_caster&lt;
    Eigen::Ref&lt;PlainObjectType, 0, StrideType&gt;,
    enable_if_t&lt;is_eigen_dense_map&lt;Eigen::Ref&lt;PlainObjectType, 0, StrideType&gt;&gt;::value&gt;
&gt; : public eigen_map_caster&lt;Eigen::Ref&lt;PlainObjectType, 0, StrideType&gt;&gt; {
private:
    using Type = Eigen::Ref&lt;PlainObjectType, 0, StrideType&gt;;
    using props = EigenProps&lt;Type&gt;;
    using Scalar = typename props::Scalar;
    using MapType = Eigen::Map&lt;PlainObjectType, 0, StrideType&gt;;
    using Array = array_t&lt;Scalar, array::forcecast |
                ((props::row_major ? props::inner_stride : props::outer_stride) == 1 ? array::c_style :
                 (props::row_major ? props::outer_stride : props::inner_stride) == 1 ? array::f_style : 0)&gt;;
    static constexpr bool need_writeable = is_eigen_mutable_map&lt;Type&gt;::value;
    // Delay construction (these have no default constructor)
    std::unique_ptr&lt;MapType&gt; map;
    std::unique_ptr&lt;Type&gt; ref;
    // Our array.  When possible, this is just a numpy array pointing to the source data, but
    // sometimes we can't avoid copying (e.g. input is not a numpy array at all, has an incompatible
    // layout, or is an array of a type that needs to be converted).  Using a numpy temporary
    // (rather than an Eigen temporary) saves an extra copy when we need both type conversion and
    // storage order conversion.  (Note that we refuse to use this temporary copy when loading an
    // argument for a Ref&lt;M&gt; with M non-const, i.e. a read-write reference).
    Array copy_or_ref;
public:
    bool load(handle src, bool convert) {
        // First check whether what we have is already an array of the right type.  If not, we can't
        // avoid a copy (because the copy is also going to do type conversion).
        bool need_copy = !isinstance&lt;Array&gt;(src);

        EigenConformable&lt;props::row_major&gt; fits;
        if (!need_copy) {
            // We don't need a converting copy, but we also need to check whether the strides are
            // compatible with the Ref's stride requirements
            Array aref = reinterpret_borrow&lt;Array&gt;(src);

            if (aref &amp;&amp; (!need_writeable || aref.writeable())) {
                fits = props::conformable(aref);
                if (!fits) return false; // Incompatible dimensions
                if (!fits.template stride_compatible&lt;props&gt;())
                    need_copy = true;
                else
                    copy_or_ref = std::move(aref);
            }
            else {
                need_copy = true;
            }
        }

        if (need_copy) {
            // We need to copy: If we need a mutable reference, or we're not supposed to convert
            // (either because we're in the no-convert overload pass, or because we're explicitly
            // instructed not to copy (via `py::arg().noconvert()`) we have to fail loading.
            if (!convert || need_writeable) return false;

            Array copy = Array::ensure(src);
            if (!copy) return false;
            fits = props::conformable(copy);
            if (!fits || !fits.template stride_compatible&lt;props&gt;())
                return false;
            copy_or_ref = std::move(copy);
            loader_life_support::add_patient(copy_or_ref);
        }

        ref.reset();
        map.reset(new MapType(data(copy_or_ref), fits.rows, fits.cols, make_stride(fits.stride.outer(), fits.stride.inner())));
        ref.reset(new Type(*map));

        return true;
    }

    operator Type*() { return ref.get(); }
    operator Type&amp;() { return *ref; }
    template &lt;typename _T&gt; using cast_op_type = pybind11::detail::cast_op_type&lt;_T&gt;;

private:
    template &lt;typename T = Type, enable_if_t&lt;is_eigen_mutable_map&lt;T&gt;::value, int&gt; = 0&gt;
    Scalar *data(Array &amp;a) { return a.mutable_data(); }

    template &lt;typename T = Type, enable_if_t&lt;!is_eigen_mutable_map&lt;T&gt;::value, int&gt; = 0&gt;
    const Scalar *data(Array &amp;a) { return a.data(); }

    // Attempt to figure out a constructor of `Stride` that will work.
    // If both strides are fixed, use a default constructor:
    template &lt;typename S&gt; using stride_ctor_default = bool_constant&lt;
        S::InnerStrideAtCompileTime != Eigen::Dynamic &amp;&amp; S::OuterStrideAtCompileTime != Eigen::Dynamic &amp;&amp;
        std::is_default_constructible&lt;S&gt;::value&gt;;
    // Otherwise, if there is a two-index constructor, assume it is (outer,inner) like
    // Eigen::Stride, and use it:
    template &lt;typename S&gt; using stride_ctor_dual = bool_constant&lt;
        !stride_ctor_default&lt;S&gt;::value &amp;&amp; std::is_constructible&lt;S, EigenIndex, EigenIndex&gt;::value&gt;;
    // Otherwise, if there is a one-index constructor, and just one of the strides is dynamic, use
    // it (passing whichever stride is dynamic).
    template &lt;typename S&gt; using stride_ctor_outer = bool_constant&lt;
        !any_of&lt;stride_ctor_default&lt;S&gt;, stride_ctor_dual&lt;S&gt;&gt;::value &amp;&amp;
        S::OuterStrideAtCompileTime == Eigen::Dynamic &amp;&amp; S::InnerStrideAtCompileTime != Eigen::Dynamic &amp;&amp;
        std::is_constructible&lt;S, EigenIndex&gt;::value&gt;;
    template &lt;typename S&gt; using stride_ctor_inner = bool_constant&lt;
        !any_of&lt;stride_ctor_default&lt;S&gt;, stride_ctor_dual&lt;S&gt;&gt;::value &amp;&amp;
        S::InnerStrideAtCompileTime == Eigen::Dynamic &amp;&amp; S::OuterStrideAtCompileTime != Eigen::Dynamic &amp;&amp;
        std::is_constructible&lt;S, EigenIndex&gt;::value&gt;;

    template &lt;typename S = StrideType, enable_if_t&lt;stride_ctor_default&lt;S&gt;::value, int&gt; = 0&gt;
    static S make_stride(EigenIndex, EigenIndex) { return S(); }
    template &lt;typename S = StrideType, enable_if_t&lt;stride_ctor_dual&lt;S&gt;::value, int&gt; = 0&gt;
    static S make_stride(EigenIndex outer, EigenIndex inner) { return S(outer, inner); }
    template &lt;typename S = StrideType, enable_if_t&lt;stride_ctor_outer&lt;S&gt;::value, int&gt; = 0&gt;
    static S make_stride(EigenIndex outer, EigenIndex) { return S(outer); }
    template &lt;typename S = StrideType, enable_if_t&lt;stride_ctor_inner&lt;S&gt;::value, int&gt; = 0&gt;
    static S make_stride(EigenIndex, EigenIndex inner) { return S(inner); }

};

// type_caster for special matrix types (e.g. DiagonalMatrix), which are EigenBase, but not
// EigenDense (i.e. they don't have a data(), at least not with the usual matrix layout).
// load() is not supported, but we can cast them into the python domain by first copying to a
// regular Eigen::Matrix, then casting that.
template &lt;typename Type&gt;
struct type_caster&lt;Type, enable_if_t&lt;is_eigen_other&lt;Type&gt;::value&gt;&gt; {
protected:
    using Matrix = Eigen::Matrix&lt;typename Type::Scalar, Type::RowsAtCompileTime, Type::ColsAtCompileTime&gt;;
    using props = EigenProps&lt;Matrix&gt;;
public:
    static handle cast(const Type &amp;src, return_value_policy /* policy */, handle /* parent */) {
        handle h = eigen_encapsulate&lt;props&gt;(new Matrix(src));
        return h;
    }
    static handle cast(const Type *src, return_value_policy policy, handle parent) { return cast(*src, policy, parent); }

    static PYBIND11_DESCR name() { return props::descriptor(); }

    // Explicitly delete these: support python -&gt; C++ conversion on these (i.e. these can be return
    // types but not bound arguments).  We still provide them (with an explicitly delete) so that
    // you end up here if you try anyway.
    bool load(handle, bool) = delete;
    operator Type() = delete;
    template &lt;typename&gt; using cast_op_type = Type;
};

template&lt;typename Type&gt;
struct type_caster&lt;Type, enable_if_t&lt;is_eigen_sparse&lt;Type&gt;::value&gt;&gt; {
    typedef typename Type::Scalar Scalar;
    typedef remove_reference_t&lt;decltype(*std::declval&lt;Type&gt;().outerIndexPtr())&gt; StorageIndex;
    typedef typename Type::Index Index;
    static constexpr bool rowMajor = Type::IsRowMajor;

    bool load(handle src, bool) {
        if (!src)
            return false;

        auto obj = reinterpret_borrow&lt;object&gt;(src);
        object sparse_module = module::import("scipy.sparse");
        object matrix_type = sparse_module.attr(
            rowMajor ? "csr_matrix" : "csc_matrix");

        if (!obj.get_type().is(matrix_type)) {
            try {
                obj = matrix_type(obj);
            } catch (const error_already_set &amp;) {
                return false;
            }
        }

        auto values = array_t&lt;Scalar&gt;((object) obj.attr("data"));
        auto innerIndices = array_t&lt;StorageIndex&gt;((object) obj.attr("indices"));
        auto outerIndices = array_t&lt;StorageIndex&gt;((object) obj.attr("indptr"));
        auto shape = pybind11::tuple((pybind11::object) obj.attr("shape"));
        auto nnz = obj.attr("nnz").cast&lt;Index&gt;();

        if (!values || !innerIndices || !outerIndices)
            return false;

        value = Eigen::MappedSparseMatrix&lt;Scalar, Type::Flags, StorageIndex&gt;(
            shape[0].cast&lt;Index&gt;(), shape[1].cast&lt;Index&gt;(), nnz,
            outerIndices.mutable_data(), innerIndices.mutable_data(), values.mutable_data());

        return true;
    }

    static handle cast(const Type &amp;src, return_value_policy /* policy */, handle /* parent */) {
        const_cast&lt;Type&amp;&gt;(src).makeCompressed();

        object matrix_type = module::import("scipy.sparse").attr(
            rowMajor ? "csr_matrix" : "csc_matrix");

        array data(src.nonZeros(), src.valuePtr());
        array outerIndices((rowMajor ? src.rows() : src.cols()) + 1, src.outerIndexPtr());
        array innerIndices(src.nonZeros(), src.innerIndexPtr());

        return matrix_type(
            std::make_tuple(data, innerIndices, outerIndices),
            std::make_pair(src.rows(), src.cols())
        ).release();
    }

    PYBIND11_TYPE_CASTER(Type, _&lt;(Type::IsRowMajor) != 0&gt;("scipy.sparse.csr_matrix[", "scipy.sparse.csc_matrix[")
            + npy_format_descriptor&lt;Scalar&gt;::name() + _("]"));
};

NAMESPACE_END(detail)
NAMESPACE_END(PYBIND11_NAMESPACE)

#if defined(__GNUG__) || defined(__clang__)
#  pragma GCC diagnostic pop
#elif defined(_MSC_VER)
#  pragma warning(pop)
#endif
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
