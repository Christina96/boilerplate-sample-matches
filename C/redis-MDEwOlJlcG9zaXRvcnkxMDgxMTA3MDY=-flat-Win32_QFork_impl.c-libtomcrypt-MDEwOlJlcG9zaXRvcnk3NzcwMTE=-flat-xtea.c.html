
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.804804804804805%, Tokens: 8</h2>
        <div class="column">
            <h3>redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_QFork_impl.c</h3>
            <pre><code>1  #include "..\server.h"
2  #include "Win32_Portability.h"
3  void SetupRedisGlobals(LPVOID redisData, size_t redisDataSize, uint8_t *dictHashSeed, LPVOID redisModules)
4  {
5  #ifndef NO_QFORKIMPL
6      memcpy(&server, redisData, redisDataSize);
7      dictSetHashFunctionSeed(dictHashSeed);
8      modules = (dict*) redisModules;
9  #endif
10  }
11  int do_rdbSave(char* filename)
12  {
13  #ifndef NO_QFORKIMPL
14      server.rdb_child_pid = GetCurrentProcessId();
15      rdbSaveInfo rsi, *rsiptr;
16      rsiptr = rdbPopulateSaveInfo(&rsi);
17      if( rdbSave(filename, rsiptr) != C_OK ) {
18          serverLog(LL_WARNING,"rdbSave failed in qfork: %s", strerror(errno));
19          return C_ERR;
20      }
21  #endif
22      return C_OK;
23  }
24  int do_aofSave(char* filename, int aof_pipe_read_ack, int aof_pipe_read_data, int aof_pipe_write_ack)
25  {
26  #ifndef NO_QFORKIMPL
27      int rewriteAppendOnlyFile(char *filename);
28      server.aof_child_pid = GetCurrentProcessId();
29      server.aof_pipe_write_ack_to_parent = aof_pipe_write_ack;
30      server.aof_pipe_read_ack_from_parent = aof_pipe_read_ack;
31      server.aof_pipe_read_data_from_parent = aof_pipe_read_data;
32      server.aof_pipe_read_ack_from_child = -1;
33      server.aof_pipe_write_ack_to_child = -1;
34      server.aof_pipe_write_data_to_child = -1;
35      if (rewriteAppendOnlyFile(filename) != C_OK) {
36          serverLog(LL_WARNING, "rewriteAppendOnlyFile failed in qfork: %s", strerror(errno));
37          return C_ERR;
38      }
39  #endif
40      return C_OK;
41  }
42  int rdbSaveRioWithEOFMark(rio *rdb, int *error);
43  int do_rdbSaveToSlavesSockets(int *fds, int numfds, uint64_t *clientids)
44  {
45  #ifndef NO_QFORKIMPL
46      int retval;
47      rio slave_sockets;
48      server.rdb_child_pid = GetCurrentProcessId();
49      rioInitWithFdset(&slave_sockets,fds,numfds);
50      POSIX_ONLY(zfree(fds););
51      POSIX_ONLY(closeListeningSockets(0);)
52      redisSetProcTitle("redis-rdb-to-slaves");
53      retval = rdbSaveRioWithEOFMark(&slave_sockets,NULL);
54      if (retval == C_OK && rioFlush(&slave_sockets) == 0)
55          retval = C_ERR;
56      if (retval == C_OK) {
57          size_t private_dirty = zmalloc_get_private_dirty(-1);
58          if (private_dirty) {
59              serverLog(LL_NOTICE,
60                  "RDB: %Iu MB of memory used by copy-on-write",                  WIN_PORT_FIX &bsol;* %zu -> %Iu */
61                  private_dirty/(1024*1024));
62          }
63          void *msg = zmalloc(sizeof(uint64_t)*(1+2*numfds));
64          uint64_t *len = msg;
65          uint64_t *ids = len+1;
66          int j, msglen;
67          *len = numfds;
<span onclick='openModal()' class='match'>68          for (j = 0; j < numfds; j++) {
69              *ids++ = clientids[j];
70              *ids++ = slave_sockets.io.fdset.state[j];
</span>71          }
72          msglen = sizeof(uint64_t)*(1+2*numfds);
73          if (*len == 0 ||
74              write(server.rdb_pipe_write_result_to_parent,msg,msglen)
75              != msglen)
76          {
77              retval = C_ERR;
78          }
79      }
80      return retval;
81  #endif
82      return C_OK;
83  }
84  int do_socketSave(int *fds, int numfds, uint64_t *clientids, int pipe_write_fd)
85  {
86      server.rdb_pipe_write_result_to_parent = pipe_write_fd;
87      return do_rdbSaveToSlavesSockets(fds, numfds, clientids);
88  }
</code></pre>
        </div>
        <div class="column">
            <h3>libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-xtea.c</h3>
            <pre><code>1  #include "tomcrypt_private.h"
2  #ifdef LTC_XTEA
3  const struct ltc_cipher_descriptor xtea_desc =
4  {
5      "xtea",
6      1,
7      16, 16, 8, 32,
8      &xtea_setup,
9      &xtea_ecb_encrypt,
10      &xtea_ecb_decrypt,
11      &xtea_test,
12      &xtea_done,
13      &xtea_keysize,
14      NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
15  };
16  int xtea_setup(const unsigned char *key, int keylen, int num_rounds, symmetric_key *skey)
17  {
18     ulong32 x, sum, K[4];
19     LTC_ARGCHK(key != NULL);
20     LTC_ARGCHK(skey != NULL);
21     if (keylen != 16) {
22        return CRYPT_INVALID_KEYSIZE;
23     }
24     if (num_rounds != 0 && num_rounds != 32) {
25        return CRYPT_INVALID_ROUNDS;
26     }
27     LOAD32H(K[0], key+0);
28     LOAD32H(K[1], key+4);
29     LOAD32H(K[2], key+8);
30     LOAD32H(K[3], key+12);
31     for (x = sum = 0; x < 32; x++) {
32         skey->xtea.A[x] = (sum + K[sum&3]) & 0xFFFFFFFFUL;
33         sum = (sum + 0x9E3779B9UL) & 0xFFFFFFFFUL;
34         skey->xtea.B[x] = (sum + K[(sum>>11)&3]) & 0xFFFFFFFFUL;
35     }
36  #ifdef LTC_CLEAN_STACK
37     zeromem(&K, sizeof(K));
38  #endif
39     return CRYPT_OK;
40  }
41  int xtea_ecb_encrypt(const unsigned char *pt, unsigned char *ct, const symmetric_key *skey)
42  {
43     ulong32 y, z;
44     int r;
45     LTC_ARGCHK(pt   != NULL);
46     LTC_ARGCHK(ct   != NULL);
47     LTC_ARGCHK(skey != NULL);
48     LOAD32H(y, &pt[0]);
49     LOAD32H(z, &pt[4]);
<span onclick='openModal()' class='match'>50     for (r = 0; r < 32; r += 4) {
51         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r])) & 0xFFFFFFFFUL;
52         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r])) & 0xFFFFFFFFUL;
53         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r+1])) & 0xFFFFFFFFUL;
54         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r+1])) & 0xFFFFFFFFUL;
</span>55         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r+2])) & 0xFFFFFFFFUL;
56         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r+2])) & 0xFFFFFFFFUL;
57         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r+3])) & 0xFFFFFFFFUL;
58         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r+3])) & 0xFFFFFFFFUL;
59     }
60     STORE32H(y, &ct[0]);
61     STORE32H(z, &ct[4]);
62     return CRYPT_OK;
63  }
64  int xtea_ecb_decrypt(const unsigned char *ct, unsigned char *pt, const symmetric_key *skey)
65  {
66     ulong32 y, z;
67     int r;
68     LTC_ARGCHK(pt   != NULL);
69     LTC_ARGCHK(ct   != NULL);
70     LTC_ARGCHK(skey != NULL);
71     LOAD32H(y, &ct[0]);
72     LOAD32H(z, &ct[4]);
73     for (r = 31; r >= 0; r -= 4) {
74         z = (z - ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r])) & 0xFFFFFFFFUL;
75         y = (y - ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r])) & 0xFFFFFFFFUL;
76         z = (z - ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r-1])) & 0xFFFFFFFFUL;
77         y = (y - ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r-1])) & 0xFFFFFFFFUL;
78         z = (z - ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r-2])) & 0xFFFFFFFFUL;
79         y = (y - ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r-2])) & 0xFFFFFFFFUL;
80         z = (z - ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r-3])) & 0xFFFFFFFFUL;
81         y = (y - ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r-3])) & 0xFFFFFFFFUL;
82     }
83     STORE32H(y, &pt[0]);
84     STORE32H(z, &pt[4]);
85     return CRYPT_OK;
86  }
87  int xtea_test(void)
88  {
89   #ifndef LTC_TEST
90      return CRYPT_NOP;
91   #else
92      static const struct {
93          unsigned char key[16], pt[8], ct[8];
94      } tests[] = {
95         {
96           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
97             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
98           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
99           { 0xde, 0xe9, 0xd4, 0xd8, 0xf7, 0x13, 0x1e, 0xd9 }
100         }, {
101           { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02,
102             0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04 },
103           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
104           { 0xa5, 0x97, 0xab, 0x41, 0x76, 0x01, 0x4d, 0x72 }
105         }, {
106           { 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
107             0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x06 },
108           { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02 },
109           { 0xb1, 0xfd, 0x5d, 0xa9, 0xcc, 0x6d, 0xc9, 0xdc }
110         }, {
111           { 0x78, 0x69, 0x5a, 0x4b, 0x3c, 0x2d, 0x1e, 0x0f,
112             0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
113           { 0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87 },
114           { 0x70, 0x4b, 0x31, 0x34, 0x47, 0x44, 0xdf, 0xab }
115         }, {
116           { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
117             0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
118           { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48 },
119           { 0x49, 0x7d, 0xf3, 0xd0, 0x72, 0x61, 0x2c, 0xb5 }
120         }, {
121           { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
122             0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
123           { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 },
124           { 0xe7, 0x8f, 0x2d, 0x13, 0x74, 0x43, 0x41, 0xd8 }
125         }, {
126           { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
127             0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
128           { 0x5a, 0x5b, 0x6e, 0x27, 0x89, 0x48, 0xd7, 0x7f },
129           { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 }
130         }, {
131           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
132             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
133           { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48 },
134           { 0xa0, 0x39, 0x05, 0x89, 0xf8, 0xb8, 0xef, 0xa5 }
135         }, {
136           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
137             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
138           { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 },
139           { 0xed, 0x23, 0x37, 0x5a, 0x82, 0x1a, 0x8c, 0x2d }
140         }, {
141           { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
142             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
143           { 0x70, 0xe1, 0x22, 0x5d, 0x6e, 0x4e, 0x76, 0x55 },
144           { 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41 }
145         }
146      };
147     unsigned char tmp[2][8];
148     symmetric_key skey;
149     int i, err, y;
150     for (i = 0; i < (int)(sizeof(tests)/sizeof(tests[0])); i++) {
151         zeromem(&skey, sizeof(skey));
152         if ((err = xtea_setup(tests[i].key, 16, 0, &skey)) != CRYPT_OK)  {
153            return err;
154         }
155         xtea_ecb_encrypt(tests[i].pt, tmp[0], &skey);
156         xtea_ecb_decrypt(tmp[0], tmp[1], &skey);
157         if (compare_testvector(tmp[0], 8, tests[i].ct, 8, "XTEA Encrypt", i) != 0 ||
158               compare_testvector(tmp[1], 8, tests[i].pt, 8, "XTEA Decrypt", i) != 0) {
159            return CRYPT_FAIL_TESTVECTOR;
160         }
161        for (y = 0; y < 8; y++) tmp[0][y] = 0;
162        for (y = 0; y < 1000; y++) xtea_ecb_encrypt(tmp[0], tmp[0], &skey);
163        for (y = 0; y < 1000; y++) xtea_ecb_decrypt(tmp[0], tmp[0], &skey);
164        for (y = 0; y < 8; y++) if (tmp[0][y] != 0) return CRYPT_FAIL_TESTVECTOR;
165     } &bsol;* for */
166     return CRYPT_OK;
167   #endif
168  }
169  void xtea_done(symmetric_key *skey)
170  {
171    LTC_UNUSED_PARAM(skey);
172  }
173  int xtea_keysize(int *keysize)
174  {
175     LTC_ARGCHK(keysize != NULL);
176     if (*keysize < 16) {
177        return CRYPT_INVALID_KEYSIZE;
178     }
179     *keysize = 16;
180     return CRYPT_OK;
181  }
182  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from redis-MDEwOlJlcG9zaXRvcnkxMDgxMTA3MDY=-flat-Win32_QFork_impl.c</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from libtomcrypt-MDEwOlJlcG9zaXRvcnk3NzcwMTE=-flat-xtea.c</div>
                <div class="column column_space"><pre><code>68          for (j = 0; j < numfds; j++) {
69              *ids++ = clientids[j];
70              *ids++ = slave_sockets.io.fdset.state[j];
</pre></code></div>
                <div class="column column_space"><pre><code>50     for (r = 0; r < 32; r += 4) {
51         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r])) & 0xFFFFFFFFUL;
52         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r])) & 0xFFFFFFFFUL;
53         y = (y + ((((z<<4)^(z>>5)) + z) ^ skey->xtea.A[r+1])) & 0xFFFFFFFFUL;
54         z = (z + ((((y<<4)^(y>>5)) + y) ^ skey->xtea.B[r+1])) & 0xFFFFFFFFUL;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    