<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for inf-text-gtk-view.c &amp; inf-gtk-browser-store.c</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for inf-text-gtk-view.c &amp; inf-gtk-browser-store.c
      </h3>
<h1 align="center">
        8.8%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>inf-text-gtk-view.c (11.843712%)<th>inf-gtk-browser-store.c (7.0802917%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(1672-1700)<td><a href="#" name="0">(1130-1158)</a><td align="center"><font color="#ff0000">21</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(52-121)<td><a href="#" name="1">(39-95)</a><td align="center"><font color="#e60000">19</font>
<tr onclick='openModal("#980517")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#980517"><font color="#980517">-</font><td><a href="#" name="2">(1296-1328)<td><a href="#" name="2">(328-356)</a><td align="center"><font color="#ce0000">17</font>
<tr onclick='openModal("#53858b")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#53858b"><font color="#53858b">-</font><td><a href="#" name="3">(1744-1770)<td><a href="#" name="3">(1162-1188)</a><td align="center"><font color="#c20000">16</font>
<tr onclick='openModal("#6cc417")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#6cc417"><font color="#6cc417">-</font><td><a href="#" name="4">(1785-1800)<td><a href="#" name="4">(702-730)</a><td align="center"><font color="#910000">12</font>
<tr onclick='openModal("#151b8d")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#151b8d"><font color="#151b8d">-</font><td><a href="#" name="5">(1014-1033)<td><a href="#" name="5">(415-426)</a><td align="center"><font color="#910000">12</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinftextgtk/inf-text-gtk-view.h&gt;
2 <a name="1"></a>#include &lt;libinfinity/inf-signals.h&gt;
3 #include &lt;gdk/gdk.h&gt;
4 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>typedef struct _InfTextGtkViewUser InfTextGtkViewUser;
5 struct _InfTextGtkViewUser {
6   InfTextGtkView* view;
7   InfTextUser* user;
8   gboolean cursor_visible;
9   InfIoTimeout* timeout;   guint revalidate_idle;
10   GdkRectangle cursor_rect;
11   GdkRectangle selection_bound_rect;
12   gint line_y;
13   gint line_height;
14 };
15 typedef struct _InfTextGtkViewUserToggle InfTextGtkViewUserToggle;
16 struct _InfTextGtkViewUserToggle {
17   InfTextGtkViewUser* user;
18   guint pos;
19   InfTextGtkViewUserToggle* on_toggle;
20   gint x;
21   gint y;
22 };
23 typedef struct _InfTextGtkViewPrivate InfTextGtkViewPrivate;
24 struct _InfTextGtkViewPrivate {
25   InfIo* io;
26   GtkTextView* textview;
27   InfUserTable* user_table;
28   InfTextUser* active_user;
29   GSList* users;
30   gboolean show_remote_cursors;
31   gboolean show_remote_selections;
32   gboolean show_remote_current_lines;
33 };
34 enum {
35   PROP_0,
36   PROP_IO,
37   PROP_VIEW,
38   PROP_USER_TABLE,
39   PROP_ACTIVE_USER,
40   PROP_SHOW_REMOTE_CURSORS,
41   PROP_SHOW_REMOTE_SELECTIONS,
42   PROP_SHOW_REMOTE_CURRENT_LINES
43 };
44 #define INF_TEXT_GTK_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_VIEW, InfTextGtkViewPrivate))
45 G_DEFINE_TYPE_WITH_CODE(InfTextGtkView, inf_text_gtk_view, G_TYPE_OBJECT,
46   G_ADD_PRIVATE(InfTextGtkView))
47 static InfTextGtkViewUser*</b></font>
48 inf_text_gtk_view_find_user(InfTextGtkView* view,
49                             InfTextUser* user)
50 {
51   InfTextGtkViewPrivate* priv;
52   GSList* item;
53   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
54   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
55     if( ((InfTextGtkViewUser*)item-&gt;data)-&gt;user == user)
56       return (InfTextGtkViewUser*)item-&gt;data;
57   return NULL;
58 }
59 static void
60 inf_text_gtk_view_user_compute_user_area(InfTextGtkViewUser* view_user)
61 {
62   InfTextGtkViewPrivate* priv;
63   GtkTextIter iter;
64   gfloat cursor_aspect_ratio;
65   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
66   gtk_widget_style_get(
67     GTK_WIDGET(priv-&gt;textview),
68     "cursor-aspect-ratio", &amp;cursor_aspect_ratio,
69     NULL
70   );
71   gtk_text_buffer_get_iter_at_offset(
72     gtk_text_view_get_buffer(priv-&gt;textview),
73     &amp;iter,
74     inf_text_user_get_caret_position(view_user-&gt;user)
75   );
76   gtk_text_view_get_line_yrange(
77     priv-&gt;textview,
78     &amp;iter,
79     &amp;view_user-&gt;line_y,
80     &amp;view_user-&gt;line_height
81   );
82   gtk_text_view_get_iter_location(
83     priv-&gt;textview,
84     &amp;iter,
85     &amp;view_user-&gt;cursor_rect
86   );
87   view_user-&gt;cursor_rect.width = MAX(
88     (int)(view_user-&gt;cursor_rect.height * cursor_aspect_ratio),
89     1
90   );
91   gtk_text_iter_forward_chars(
92     &amp;iter,
93     inf_text_user_get_selection_length(view_user-&gt;user)
94   );
95   gtk_text_view_get_iter_location(
96     priv-&gt;textview,
97     &amp;iter,
98     &amp;view_user-&gt;selection_bound_rect
99   );
100   view_user-&gt;selection_bound_rect.width = MAX(
101     (int)(view_user-&gt;selection_bound_rect.height * cursor_aspect_ratio),
102     1
103   );
104 }
105 static guint
106 inf_text_gtk_view_get_left_margin(GtkTextView* view)
107 {
108   GtkAdjustment* hadjustment;
109   gint margin;
110   gint hadj;
111   hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));
112   margin = gtk_text_view_get_left_margin(view);
113   if(!hadjustment) return margin;
114   hadj = gtk_adjustment_get_value(hadjustment);
115   if(hadj &lt; margin) return margin - hadj;
116   return 0;
117 }
118 static guint
119 inf_text_gtk_view_get_right_margin(GtkTextView* view)
120 {
121   GtkAdjustment* hadjustment;
122   gint margin;
123   gdouble hadj;
124   gdouble hupper;
125   gdouble hpage;
126   hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));
127   margin = gtk_text_view_get_right_margin(view);
128   if(!hadjustment) return margin;
129   hadj = gtk_adjustment_get_value(hadjustment) + 1;
130   g_object_get(
131     G_OBJECT(hadjustment),
132     "upper", &amp;hupper,
133     "page-size", &amp;hpage,
134     NULL
135   );
136   if(hadj &gt; hupper - hpage - margin)
137     return margin - (gint)(hupper - hpage - hadj);
138   return 0;
139 }
140 static void
141 inf_text_gtk_view_user_invalidate_user_area(InfTextGtkViewUser* view_user)
142 {
143   InfTextGtkViewPrivate* priv;
144   GdkWindow* window;
145   GdkRectangle invalidate_rect;
146   gint selection_bound_x;
147   gint selection_bound_y;
148   gint window_width;
149   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
150   if(gtk_widget_get_realized(GTK_WIDGET(priv-&gt;textview)))
151   {
152     if(priv-&gt;show_remote_cursors || priv-&gt;show_remote_selections ||
153        priv-&gt;show_remote_current_lines)
154     {
155       window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
156       window_width = gdk_window_get_width(window);
157       gtk_text_view_buffer_to_window_coords(
158         priv-&gt;textview,
159         GTK_TEXT_WINDOW_TEXT,
160         view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
161         &amp;invalidate_rect.x, &amp;invalidate_rect.y
162       );
163       invalidate_rect.width = view_user-&gt;cursor_rect.width;
164       invalidate_rect.height = view_user-&gt;cursor_rect.height;
165       if(priv-&gt;show_remote_selections &amp;&amp;
166          (view_user-&gt;selection_bound_rect.x != view_user-&gt;cursor_rect.x ||
167           view_user-&gt;selection_bound_rect.y != view_user-&gt;cursor_rect.y))
168       {
169         gtk_text_view_buffer_to_window_coords(
170           priv-&gt;textview,
171           GTK_TEXT_WINDOW_TEXT,
172           view_user-&gt;selection_bound_rect.x,
173           view_user-&gt;selection_bound_rect.y,
174           &amp;selection_bound_x, &amp;selection_bound_y
175         );
176         if(selection_bound_y == invalidate_rect.y)
177         {
178           if(selection_bound_x &gt; invalidate_rect.x)
179           {
180             invalidate_rect.width = MAX(
181               selection_bound_x - invalidate_rect.x,
182               invalidate_rect.width
183             );
184           }
185           else
186           {
187             invalidate_rect.width += (invalidate_rect.x - selection_bound_x);
188             invalidate_rect.x = selection_bound_x;
189           }
190         }
191         else
192         {
193           invalidate_rect.width = window_width;
194           invalidate_rect.height = MAX(
195             invalidate_rect.y + invalidate_rect.height,
196             selection_bound_y + view_user-&gt;selection_bound_rect.height
197           ) - MIN(invalidate_rect.y, selection_bound_y);
198           invalidate_rect.x =
199             inf_text_gtk_view_get_left_margin(priv-&gt;textview);
200           invalidate_rect.y = MIN(invalidate_rect.y, selection_bound_y);
201           invalidate_rect.width -=
202             inf_text_gtk_view_get_left_margin(priv-&gt;textview) +
203             inf_text_gtk_view_get_right_margin(priv-&gt;textview);
204         }
205         gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
206       }
207       if(priv-&gt;show_remote_current_lines)
208       {
209         gtk_text_view_buffer_to_window_coords(
210           priv-&gt;textview,
211           GTK_TEXT_WINDOW_TEXT,
212           0, view_user-&gt;line_y,
213           NULL, &amp;invalidate_rect.y
214         );
215         invalidate_rect.x =
216           inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
217         invalidate_rect.width = window_width - invalidate_rect.x;
218         invalidate_rect.height = view_user-&gt;line_height;
219       }
220       gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
221     }
222   }
223 }
224 static gint
225 inf_text_gtk_view_user_line_position_cmp(gconstpointer first,
226                                          gconstpointer second)
227 {
228   const InfTextGtkViewUser* first_user;
229   const InfTextGtkViewUser* second_user;
230   first_user = (const InfTextGtkViewUser*)first;
231   second_user = (const InfTextGtkViewUser*)second;
232   if(second_user-&gt;line_y &lt; first_user-&gt;line_y)
233     return 1;
234   else if(second_user-&gt;line_y &gt; first_user-&gt;line_y)
235     return -1;
236   return 0;
237 }
238 static gint
239 inf_text_gtk_view_user_toggle_position_cmp(gconstpointer first,
240                                            gconstpointer second,
241                                            gpointer user_data)
242 {
243   const InfTextGtkViewUserToggle* first_toggle;
244   const InfTextGtkViewUserToggle* second_toggle;
245   first_toggle = (const InfTextGtkViewUserToggle*)first;
246   second_toggle = (const InfTextGtkViewUserToggle*)second;
247   if(second_toggle-&gt;pos &lt; first_toggle-&gt;pos)
248     return 1;
249   else if(second_toggle-&gt;pos &gt; first_toggle-&gt;pos)
250     return -1;
251   return 0;
252 }
253 static gint
254 inf_text_gtk_view_user_toggle_user_cmp(gconstpointer first,
255                                        gconstpointer second)
256 {
257   const InfTextGtkViewUserToggle* first_toggle;
258   const InfTextGtkViewUserToggle* second_toggle;
259   guint first_id;
260   guint second_id;
261   first_toggle = (const InfTextGtkViewUserToggle*)first;
262   second_toggle = (const InfTextGtkViewUserToggle*)second;
263   first_id = inf_user_get_id(INF_USER(first_toggle-&gt;user-&gt;user));
264   second_id = inf_user_get_id(INF_USER(second_toggle-&gt;user-&gt;user));
265   if(second_id &lt; first_id)
266     return 1;
267   else if(second_id &gt; first_id)
268     return -1;
269   return 0;
270 }
271 static void
272 inf_text_gtk_view_user_toggle_free(gpointer data)
273 {
274   g_slice_free(InfTextGtkViewUserToggle, data);
275 }
276 static InfTextGtkViewUserToggle*
277 inf_text_gtk_view_add_user_toggle(GSequence* sequence,
278                                   guint position,
279                                   InfTextGtkViewUser* user,
280                                   InfTextGtkViewUserToggle* on_toggle,
281                                   gint x,
282                                   gint y)
283 {
284   InfTextGtkViewUserToggle* toggle;
285   toggle = g_slice_new(InfTextGtkViewUserToggle);
286   toggle-&gt;user = user;
287   toggle-&gt;pos = position;
288   toggle-&gt;on_toggle = on_toggle;
289   toggle-&gt;x = x;
290   toggle-&gt;y = y;
291   g_sequence_insert_sorted(
292     sequence,
293     toggle,
294     inf_text_gtk_view_user_toggle_position_cmp,
295     NULL
296   );
297   return toggle;
298 }
299 static void
300 inf_text_gtk_view_add_user_toggle_pair(GSequence* sequence,
301                                        guint begin,
302                                        guint end,
303                                        InfTextGtkViewUser* user,
304                                        gint begin_x,
305                                        gint begin_y,
306                                        gint end_x,
307                                        gint end_y)
308 {
309   InfTextGtkViewUserToggle* begin_toggle;
310   g_assert(end &gt; begin);
311   begin_toggle = inf_text_gtk_view_add_user_toggle(
312     sequence,
313     begin,
314     user,
315     NULL,
316     begin_x,
317     begin_y
318   );
319   inf_text_gtk_view_add_user_toggle(
320     sequence,
321     end,
322     user,
323     begin_toggle,
324     end_x,
325     end_y
326   );
327 }
328 static gboolean
329 inf_text_gtk_view_draw_before_cb(GtkWidget* widget,
330                                  cairo_t* cr,
331                                  gpointer user_data)
332 {
333   InfTextGtkView* view;
334   InfTextGtkViewPrivate* priv;
335   GSList* item;
336   GSList* prev_item;
337   InfTextGtkViewUser* prev_user;
338   InfTextGtkViewUser* view_user;
339   GtkAdjustment* hadjustment;
340   GtkAdjustment* vadjustment;
341   GdkWindow *text_window;
342   GtkStyleContext* style;
343   GdkRGBA bg;
344   double h, s, v;
345   double r, g, b;
346   GSList* sort_users;
347   GdkRectangle rect;
348   gint window_width;
349   gint rx, ry;
350   GdkRectangle clip_area;
351   cairo_pattern_t* pattern;
352   double n, n_users;
353   cairo_matrix_t matrix;
354   view = INF_TEXT_GTK_VIEW(user_data);
355   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
356   text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
357   if(!gtk_cairo_should_draw_window(cr, text_window))
358   {
359     return FALSE;
360   }
361   if(priv-&gt;show_remote_current_lines)
362   {
363     gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
364     gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
365     window_width = gdk_window_get_width(text_window);
366     style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
367     gtk_style_context_save(style);
368     gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
369     gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &amp;bg);
370     gtk_style_context_restore(style);
371     gtk_rgb_to_hsv(bg.red, bg.green, bg.blue, &amp;h, &amp;s, &amp;v);
372     v = MAX(v, 0.3);
373     s = MAX(s, 0.1 + 0.3*(1 - v));
374     sort_users = g_slist_copy(priv-&gt;users);
375     sort_users =
376       g_slist_sort(sort_users, inf_text_gtk_view_user_line_position_cmp);
377     prev_item = sort_users;
378     if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
379     n_users = 1.0;
380     for(item = sort_users; item != NULL; item = item-&gt;next, n_users += 1.0)
381     {
382       if(item-&gt;next == NULL ||
383          ((InfTextGtkViewUser*)item-&gt;next-&gt;data)-&gt;line_y != prev_user-&gt;line_y)
384       {
385         gtk_text_view_buffer_to_window_coords(
386           priv-&gt;textview,
387           GTK_TEXT_WINDOW_TEXT,
388           0, prev_user-&gt;line_y,
389           NULL, &amp;rect.y
390         );
391         rect.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
392         rect.width = window_width - rect.x;
393         rect.height = prev_user-&gt;line_height;
394         if(gdk_rectangle_intersect(&amp;clip_area, &amp;rect, NULL))
395         {
396           hadjustment =
397             gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
398           vadjustment =
399             gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));
400           rx = gtk_adjustment_get_value(vadjustment);
401           ry = gtk_adjustment_get_value(hadjustment);
402           pattern =
403             cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
404           cairo_matrix_init_translate(&amp;matrix, rx, ry);
405           cairo_pattern_set_matrix(pattern, &amp;matrix);
406           cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
407           for(n = 0.0;
408               prev_item != item-&gt;next;
409               prev_item = prev_item-&gt;next, n += 1.0)
410           {
411             view_user = (InfTextGtkViewUser*)prev_item-&gt;data;
412             h = inf_text_user_get_hue(view_user-&gt;user);
413             gtk_hsv_to_rgb(h, s, v, &amp;r, &amp;g, &amp;b);
414             cairo_pattern_add_color_stop_rgb(
415               pattern,
416               n/n_users,
417               r, g, b
418             );
419             cairo_pattern_add_color_stop_rgb(
420               pattern,
421               (n+1.0)/n_users,
422               r, g, b
423             );
424           }
425           cairo_set_source(cr, pattern);
426           gdk_cairo_rectangle(cr, &amp;rect);
427           cairo_fill(cr);
428           cairo_pattern_destroy(pattern);
429         }
430         prev_item = item-&gt;next;
431         if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
432         n_users = 0.0;
433       }
434     }
435     g_slist_free(sort_users);
436   }
437   return FALSE;
438 }
439 static gboolean
440 inf_text_gtk_view_draw_after_cb(GtkWidget* widget,
441                                 cairo_t* cr,
442                                 gpointer user_data)
443 {
444   InfTextGtkView* view;
445   InfTextGtkViewPrivate* priv;
446   gint window_width;
447   GtkStyleContext* style;
448   GdkColor* cursor_color;
449   GdkRGBA fg;
450   double hc,sc,vc;
451   double hs,ss,vs;
452   GSList* item;
453   InfTextGtkViewUser* view_user;
454   double rc,gc,bc;
455   double rs,gs,bs;
456   GdkRectangle clip_area;
457   gint ax, ay;
458   GtkTextIter begin_iter;
459   GtkTextIter end_iter;
460   guint area_begin;
461   guint area_end;
462   guint own_sel_begin;
463   guint own_sel_end;
464   gint osbx, osby;
465   gint osex, osey;
466   gint sel;
467   guint begin;
468   guint end;
469   GSequence* toggles;
470   GSequenceIter* tog_iter;
471   InfTextGtkViewUserToggle* cur_toggle;
472   InfTextGtkViewUserToggle* prev_toggle;
473   guint n_users;
474   GSList* users;
475   cairo_pattern_t* pattern;
476   GtkAdjustment* hadjustment;
477   GtkAdjustment* vadjustment;
478   double n;
479   cairo_matrix_t matrix;
480   GdkRectangle rct;
481   gint rx, ry;
482   GdkWindow *text_window;
483   view = INF_TEXT_GTK_VIEW(user_data);
484   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
485   text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
486   if(!gtk_cairo_should_draw_window(cr, text_window))
487   {
488     return FALSE;
489   }
490   gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
491   gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);
492   style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
493   gtk_style_context_save(style);
494   gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
495   gtk_style_context_get_color(style, GTK_STATE_FLAG_NORMAL, &amp;fg);
496   gtk_style_context_restore(style);
497   if(priv-&gt;show_remote_selections)
498   {
499     window_width = gdk_window_get_width(text_window);
500     gtk_rgb_to_hsv(fg.red, fg.green, fg.blue, &amp;hs, &amp;ss, &amp;vs);
501     vs = MAX(vs, 0.5);
502     ss = 1.0 - 0.4*(vs);
503     gtk_text_view_window_to_buffer_coords(
504       priv-&gt;textview,
505       GTK_TEXT_WINDOW_TEXT,
506       clip_area.x, clip_area.y,
507       &amp;ax, &amp;ay
508     );
509     gtk_text_view_get_iter_at_location(
510       priv-&gt;textview,
511       &amp;begin_iter,
512       ax,
513       ay
514     );
515     gtk_text_view_get_iter_at_location(
516       priv-&gt;textview,
517       &amp;end_iter,
518       ax + clip_area.width,
519       ay + clip_area.height
520     );
521     area_begin = gtk_text_iter_get_offset(&amp;begin_iter);
522     area_end = gtk_text_iter_get_offset(&amp;end_iter);
523     g_assert(area_end &gt;= area_begin);
524     gtk_text_buffer_get_selection_bounds(
525       gtk_text_view_get_buffer(priv-&gt;textview),
526       &amp;begin_iter,
527       &amp;end_iter
528     );
529     own_sel_begin = gtk_text_iter_get_offset(&amp;begin_iter);
530     own_sel_end = gtk_text_iter_get_offset(&amp;end_iter);
531     if(own_sel_begin != own_sel_end)
532     {
533       gtk_text_view_get_iter_location(priv-&gt;textview, &amp;begin_iter, &amp;rct);
534       gtk_text_view_buffer_to_window_coords(
535         priv-&gt;textview,
536         GTK_TEXT_WINDOW_TEXT,
537         rct.x, rct.y,
538         &amp;osbx, &amp;osby
539       );
540       gtk_text_view_get_iter_location(priv-&gt;textview, &amp;end_iter, &amp;rct);
541       gtk_text_view_buffer_to_window_coords(
542         priv-&gt;textview,
543         GTK_TEXT_WINDOW_TEXT,
544         rct.x, rct.y,
545         &amp;osex, &amp;osey
546       );
547     }
548     toggles = g_sequence_new(inf_text_gtk_view_user_toggle_free);
549     for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
550     {
551       view_user = (InfTextGtkViewUser*)item-&gt;data;
552       if(inf_text_user_get_selection_length(view_user-&gt;user) != 0)
553       {
554         begin = inf_text_user_get_caret_position(view_user-&gt;user);
555         sel = inf_text_user_get_selection_length(view_user-&gt;user);
556         if(sel &gt; 0)
557         {
558           end = begin + sel;
559         }
560         else
561         {
562           g_assert(begin &gt;= (unsigned int)-sel);
563           end = begin;
564           begin += sel;
565         }
566         if(begin &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
567           begin = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
568         if(end &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
569           end = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
570         begin = MIN(MAX(begin, area_begin), area_end);
571         end = MIN(MAX(end, area_begin), area_end);
572         g_assert(end &gt;= begin);
573         if(begin != end)
574         {
575           if(sel &gt; 0)
576           {
577             gtk_text_view_buffer_to_window_coords(
578               priv-&gt;textview,
579               GTK_TEXT_WINDOW_TEXT,
580               view_user-&gt;cursor_rect.x,
581               view_user-&gt;cursor_rect.y,
582               &amp;rx, &amp;ry
583             );
584             gtk_text_view_buffer_to_window_coords(
585               priv-&gt;textview,
586               GTK_TEXT_WINDOW_TEXT,
587               view_user-&gt;selection_bound_rect.x,
588               view_user-&gt;selection_bound_rect.y,
589               &amp;ax, &amp;ay
590             );
591           }
592           else
593           {
594             gtk_text_view_buffer_to_window_coords(
595               priv-&gt;textview,
596               GTK_TEXT_WINDOW_TEXT,
597               view_user-&gt;selection_bound_rect.x,
598               view_user-&gt;selection_bound_rect.y,
599               &amp;rx, &amp;ry
600             );
601             gtk_text_view_buffer_to_window_coords(
602               priv-&gt;textview,
603               GTK_TEXT_WINDOW_TEXT,
604               view_user-&gt;cursor_rect.x,
605               view_user-&gt;cursor_rect.y,
606               &amp;ax, &amp;ay
607             );
608           }
609           if(own_sel_begin == own_sel_end ||
610              own_sel_end &lt;= begin || own_sel_begin &gt;= end)
611           {
612             inf_text_gtk_view_add_user_toggle_pair(
613               toggles,
614               begin, end,
615               view_user,
616               rx, ry,
617               ax, ay
618             );
619           }
620           else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &gt;= end)
621           {
622           }
623           else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &gt;= end)
624           {
625             inf_text_gtk_view_add_user_toggle_pair(
626               toggles,
627               begin, own_sel_begin,
628               view_user,
629               rx, ry,
630               osbx, osby
631             );
632           }
633           else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &lt; end)
634           {
635             inf_text_gtk_view_add_user_toggle_pair(
636               toggles,
637               own_sel_end, end,
638               view_user,
639               osex, osey,
640               ax, ay
641             );
642           }
643           else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &lt; end)
644           {
645             inf_text_gtk_view_add_user_toggle_pair(
646               toggles,
647               begin, own_sel_begin,
648               view_user,
649               rx, ry,
650               osbx, osby
651             );
652             inf_text_gtk_view_add_user_toggle_pair(
653               toggles,
654               own_sel_end, end,
655               view_user,
656               osex, osey,
657               ax, ay
658             );
659           }
660           else
661           {
662             g_assert_not_reached();
663           }
664         }
665       }
666     }
667     tog_iter = g_sequence_get_begin_iter(toggles);
668     cur_toggle = NULL;
669     prev_toggle = NULL;
670     users = NULL;
671     n_users = 0;
672     tog_iter = g_sequence_get_begin_iter(toggles);
673     while(!g_sequence_iter_is_end(tog_iter))
674     {
675       cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
676       if(users != NULL)
677       {
678         g_assert(prev_toggle != NULL);
679         g_assert(n_users &gt; 0);
680         hadjustment =
681           gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
682         vadjustment =
683           gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));
684         rx = gtk_adjustment_get_value(hadjustment);
685         ry = gtk_adjustment_get_value(vadjustment);
686         pattern =
687           cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
688         cairo_matrix_init_translate(&amp;matrix, rx, ry);
689         cairo_pattern_set_matrix(pattern, &amp;matrix);
690         cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
691         for(item = users, n = 0.0; item != NULL; item = item-&gt;next, n += 1.0)
692         {
693           view_user = ((InfTextGtkViewUserToggle*)item-&gt;data)-&gt;user;
694           hs = inf_text_user_get_hue(view_user-&gt;user);
695           gtk_hsv_to_rgb(hs, ss, vs, &amp;rs, &amp;gs, &amp;bs);
696           cairo_pattern_add_color_stop_rgba(
697             pattern,
698             n/n_users,
699             rs, gs, bs, 0.5
700           );
701           cairo_pattern_add_color_stop_rgba(
702             pattern,
703             (n+1.0)/n_users,
704             rs, gs, bs, 0.5
705           );
706         }
707         cairo_set_source(cr, pattern);
708         if(prev_toggle-&gt;y == cur_toggle-&gt;y)
709         {
710           g_assert(prev_toggle-&gt;x &lt; cur_toggle-&gt;x);
711           rct.x = prev_toggle-&gt;x;
712           rct.y = prev_toggle-&gt;y;
713           rct.width = cur_toggle-&gt;x - prev_toggle-&gt;x;
714           rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
715           gdk_cairo_rectangle(cr, &amp;rct);
716         }
717         else
718         {
719           g_assert(
720             cur_toggle-&gt;y - prev_toggle-&gt;y &gt;=
721             cur_toggle-&gt;user-&gt;selection_bound_rect.height
722           );
723           if(window_width &gt; prev_toggle-&gt;x)
724           {
725             rct.x = prev_toggle-&gt;x;
726             rct.y = prev_toggle-&gt;y;
727             rct.width = window_width - prev_toggle-&gt;x -
728               inf_text_gtk_view_get_right_margin(priv-&gt;textview);
729             rct.height = prev_toggle-&gt;user-&gt;selection_bound_rect.height;
730             gdk_cairo_rectangle(cr, &amp;rct);
731           }
732           if(cur_toggle-&gt;x &gt; 0)
733           {
734             rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
735             rct.y = cur_toggle-&gt;y;
736             rct.width = cur_toggle-&gt;x - rct.x;
737             rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
738             gdk_cairo_rectangle(cr, &amp;rct);
739           }
740           if(cur_toggle-&gt;y - prev_toggle-&gt;y &gt;
741              cur_toggle-&gt;user-&gt;selection_bound_rect.height)
742           {
743             rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
744             rct.y = prev_toggle-&gt;y +
745               prev_toggle-&gt;user-&gt;selection_bound_rect.height;
746             rct.width = window_width - rct.x -
747               inf_text_gtk_view_get_right_margin(priv-&gt;textview);
748             rct.height = cur_toggle-&gt;y - prev_toggle-&gt;y -
749               cur_toggle-&gt;user-&gt;selection_bound_rect.height;
750             gdk_cairo_rectangle(cr, &amp;rct);
751           }
752         }
753         cairo_fill(cr);
754         cairo_pattern_destroy(pattern);
755       }
756       prev_toggle = cur_toggle;
757 <a name="5"></a>            do
758       {
759 <font color="#151b8d"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>        if(cur_toggle-&gt;on_toggle == NULL)
760         {
761           users = g_slist_insert_sorted(
762             users,
763             cur_toggle,
764             inf_text_gtk_view_user_toggle_user_cmp
765           );
766           ++n_users;
767         }
768         else
769         {
770           g_assert(n_users &gt; 0);
771           users = g_slist_remove(users, cur_toggle-&gt;on_toggle);
772           --n_users;
773         }
774         tog_iter = g_sequence_iter_next(tog_iter);</b></font>
775         if(g_sequence_iter_is_end(tog_iter))
776           break;
777         cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
778       } while(cur_toggle-&gt;pos == prev_toggle-&gt;pos);
779     }
780     g_assert(n_users == 0);
781     g_assert(users == NULL);
782     g_sequence_free(toggles);
783   }
784   if(priv-&gt;show_remote_cursors)
785   {
786     gtk_widget_style_get (widget, "cursor-color", &amp;cursor_color, NULL);
787     if(cursor_color != NULL)
788     {
789       rc = cursor_color-&gt;red / 65535.0;
790       bc = cursor_color-&gt;green / 65535.0;
791       gc = cursor_color-&gt;blue / 65535.0;
792       gdk_color_free(cursor_color);
793     }
794     else
795     {
796       rc = fg.red;
797       bc = fg.green;
798       gc = fg.blue;
799     }
800     gtk_rgb_to_hsv(rc, bc, gc, &amp;hc, &amp;sc, &amp;vc);
801     sc = MIN(MAX(sc, 0.3), 0.8);
802     vc = MAX(vc, 0.7);
803     for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
804     {
805       view_user = (InfTextGtkViewUser*)item-&gt;data;
806       if(view_user-&gt;cursor_visible)
807       {
808         gtk_text_view_buffer_to_window_coords(
809           priv-&gt;textview,
810           GTK_TEXT_WINDOW_TEXT,
811           view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
812           &amp;rct.x, &amp;rct.y
813         );
814         rct.width = view_user-&gt;cursor_rect.width;
815         rct.height = view_user-&gt;cursor_rect.height;
816         if(gdk_rectangle_intersect(&amp;clip_area, &amp;rct, NULL))
817         {
818           hc = inf_text_user_get_hue(view_user-&gt;user);
819           gtk_hsv_to_rgb(hc, sc, vc, &amp;rc, &amp;gc, &amp;bc);
820           cairo_set_source_rgb(cr, rc, gc, bc);
821           gdk_cairo_rectangle(cr, &amp;rct);
822           cairo_fill(cr);
823         }
824       }
825     }
826   }
827   return FALSE;
828 }
829 static void
830 inf_text_gtk_view_style_updated_cb(GtkWidget* widget,
831                                    gpointer user_data)
832 {
833   InfTextGtkView* view;
834   InfTextGtkViewPrivate* priv;
835   GSList* item;
836   InfTextGtkViewUser* view_user;
837   view = INF_TEXT_GTK_VIEW(user_data);
838   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
839   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
840   {
841     view_user = (InfTextGtkViewUser*)item-&gt;data;
842     inf_text_gtk_view_user_compute_user_area(view_user);
843   }
844 }
845 static void
846 inf_text_gtk_view_size_allocate_cb(GtkWidget* widget,
847                                    GtkAllocation* allocation,
848                                    gpointer user_data)
849 {
850   InfTextGtkView* view;
851   InfTextGtkViewPrivate* priv;
852   GSList* item;
853   InfTextGtkViewUser* view_user;
854   view = INF_TEXT_GTK_VIEW(user_data);
855   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
856   for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
857   {
858     view_user = (InfTextGtkViewUser*)item-&gt;data;
859     inf_text_gtk_view_user_compute_user_area(view_user);
860   }
861 }
862 static void
863 inf_text_gtk_view_user_cursor_blink_timeout_func(gpointer user_data)
864 {
865   InfTextGtkViewUser* view_user;
866   InfTextGtkViewPrivate* priv;
867   GtkSettings* settings;
868   gboolean cursor_blink;
869   gint cursor_blink_time;
870   view_user = (InfTextGtkViewUser*)user_data;
871   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
872   view_user-&gt;cursor_visible = !view_user-&gt;cursor_visible;
873   inf_text_gtk_view_user_invalidate_user_area(view_user);
874   settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));
875   g_object_get(
876     G_OBJECT(settings),
877     "gtk-cursor-blink", &amp;cursor_blink,
878     "gtk-cursor-blink-time", &amp;cursor_blink_time,
879     NULL
880   );
881   if(cursor_blink)
882   {
883     if(!view_user-&gt;cursor_visible)
884       cursor_blink_time = cursor_blink_time * 1 / 3;
885     else
886       cursor_blink_time = cursor_blink_time * 2 / 3;
887     view_user-&gt;timeout = inf_io_add_timeout(
888       priv-&gt;io,
889       cursor_blink_time,
890       inf_text_gtk_view_user_cursor_blink_timeout_func,
891       view_user,
892       NULL
893     );
894   }
895   else
896   {
897     view_user-&gt;timeout = NULL;
898   }
899 }
900 static void
901 inf_text_gtk_view_user_reset_timeout(InfTextGtkViewUser* view_user)
902 {
903   InfTextGtkViewPrivate* priv;
904   GtkSettings* settings;
905   gboolean cursor_blink;
906   gint cursor_blink_time;
907   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
908   if(view_user-&gt;timeout)
909   {
910     inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
911     view_user-&gt;timeout = NULL;
912   }
913   if(!view_user-&gt;cursor_visible)
914   {
915     view_user-&gt;cursor_visible = TRUE;
916     inf_text_gtk_view_user_invalidate_user_area(view_user);
917   }
918   settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));
919   g_object_get(
920     G_OBJECT(settings),
921     "gtk-cursor-blink", &amp;cursor_blink,
922     "gtk-cursor-blink-time", &amp;cursor_blink_time,
923     NULL
924   );
925   if(cursor_blink)
926   {
927     view_user-&gt;timeout = inf_io_add_timeout(
928       priv-&gt;io,
929       cursor_blink_time,
930       inf_text_gtk_view_user_cursor_blink_timeout_func,
931       view_user,
932       NULL
933     );
934   }
935 }
936 static gboolean
937 inf_text_gtk_view_user_selection_changed_cb_idle_func(gpointer user_data)
938 {
939   InfTextGtkViewUser* view_user;
940   view_user = (InfTextGtkViewUser*)user_data;
941   g_assert(view_user-&gt;revalidate_idle != 0);
942   view_user-&gt;revalidate_idle = 0;
943   inf_text_gtk_view_user_invalidate_user_area(view_user);
944   return FALSE;
945 }
946 static void
947 inf_text_gtk_view_user_selection_changed_cb(InfTextUser* user,
948                                             guint position,
949                                             gint length,
950                                             gboolean by_request,
951                                             gpointer user_data)
952 {
953   InfTextGtkViewUser* view_user;
954   InfTextGtkViewPrivate* priv;
955   view_user = (InfTextGtkViewUser*)user_data;
956   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
957   if(by_request)
958   {
959     inf_text_gtk_view_user_invalidate_user_area(view_user);
960   }
961   inf_text_gtk_view_user_compute_user_area(view_user);
962   if(by_request)
963   {
964     inf_text_gtk_view_user_reset_timeout(view_user);
965     if(view_user-&gt;revalidate_idle == 0)
966     {
967       view_user-&gt;revalidate_idle = g_idle_add_full(
968         GTK_TEXT_VIEW_PRIORITY_VALIDATE + 1,
969         inf_text_gtk_view_user_selection_changed_cb_idle_func,
970 <a name="2"></a>        view_user,
971         NULL
972       );
973 <font color="#980517"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    }
974   }
975 }
976 static void
977 inf_text_gtk_view_user_notify_hue_cb(GObject* object,
978                                      GParamSpec* pspec,
979                                      gpointer user_data)
980 {
981   InfTextGtkViewUser* view_user;
982   InfTextGtkViewPrivate* priv;
983   view_user = (InfTextGtkViewUser*)user_data;
984   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
985   gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
986 }
987 static void
988 inf_text_gtk_view_add_user(InfTextGtkView* view,
989                            InfTextUser* user)
990 {
991   InfTextGtkViewPrivate* priv;
992   InfTextGtkViewUser* view_user;
993   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
994   view_user = g_slice_new(InfTextGtkViewUser);
995   view_user-&gt;view = view;
996   view_user-&gt;user = INF_TEXT_USER(user);
997   view_user-&gt;cursor_visible = TRUE;</b></font>
998   view_user-&gt;timeout = NULL;
999   view_user-&gt;revalidate_idle = 0;
1000   inf_text_gtk_view_user_compute_user_area(view_user);
1001   inf_text_gtk_view_user_reset_timeout(view_user);
1002   priv-&gt;users = g_slist_prepend(priv-&gt;users, view_user);
1003   g_signal_connect_after(
1004     user,
1005     "selection-changed",
1006     G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
1007     view_user
1008   );
1009   g_signal_connect(
1010     user,
1011     "notify::hue",
1012     G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
1013     view_user
1014   );
1015   inf_text_gtk_view_user_invalidate_user_area(view_user);
1016 }
1017 static void
1018 inf_text_gtk_view_remove_user(InfTextGtkViewUser* view_user)
1019 {
1020   InfTextGtkViewPrivate* priv;
1021   priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);
1022   inf_signal_handlers_disconnect_by_func(
1023     view_user-&gt;user,
1024     G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
1025     view_user
1026   );
1027   inf_signal_handlers_disconnect_by_func(
1028     view_user-&gt;user,
1029     G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
1030     view_user
1031   );
1032   if(view_user-&gt;timeout != NULL)
1033     inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
1034   if(view_user-&gt;revalidate_idle != 0)
1035     g_source_remove(view_user-&gt;revalidate_idle);
1036   inf_text_gtk_view_user_invalidate_user_area(view_user);
1037   priv-&gt;users = g_slist_remove(priv-&gt;users, view_user);
1038   g_slice_free(InfTextGtkViewUser, view_user);
1039 }
1040 static void
1041 inf_text_gtk_view_user_notify_status_cb(GObject* object,
1042                                         GParamSpec* pspec,
1043                                         gpointer user_data)
1044 {
1045   InfTextGtkView* view;
1046   InfTextGtkViewPrivate* priv;
1047   InfTextUser* user;
1048   InfTextGtkViewUser* view_user;
1049   view = INF_TEXT_GTK_VIEW(user_data);
1050   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1051   user = INF_TEXT_USER(object);
1052   g_assert(user != priv-&gt;active_user);
1053   view_user = inf_text_gtk_view_find_user(view, user);
1054   if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1055   {
1056     if(!view_user)
1057       inf_text_gtk_view_add_user(view, user);
1058   }
1059   else
1060   {
1061     if(view_user)
1062       inf_text_gtk_view_remove_user(view_user);
1063   }
1064 }
1065 static void
1066 inf_text_gtk_view_user_removed(InfTextGtkView* view,
1067                                InfTextUser* user)
1068 {
1069   InfTextGtkViewPrivate* priv;
1070   InfTextGtkViewUser* view_user;
1071   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1072   if(user == priv-&gt;active_user)
1073   {
1074     priv-&gt;active_user = NULL;
1075     g_object_notify(G_OBJECT(view), "active-user");
1076   }
1077   else
1078   {
1079     inf_signal_handlers_disconnect_by_func(
1080       user,
1081       G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
1082       view
1083     );
1084     if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1085     {
1086       view_user = inf_text_gtk_view_find_user(view, user);
1087       g_assert(view_user != NULL);
1088       inf_text_gtk_view_remove_user(view_user);
1089     }
1090   }
1091 }
1092 static void
1093 inf_text_gtk_view_user_added(InfTextGtkView* view,
1094                              InfTextUser* user)
1095 {
1096   InfTextGtkViewPrivate* priv;
1097   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1098   g_assert(user != priv-&gt;active_user);
1099   g_signal_connect(
1100     user,
1101     "notify::status",
1102     G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
1103     view
1104   );
1105   if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
1106     inf_text_gtk_view_add_user(view, user);
1107 }
1108 static void
1109 inf_text_gtk_view_add_user_cb(InfUserTable* user_table,
1110                               InfUser* user,
1111                               gpointer user_data)
1112 {
1113   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1114   g_assert(INF_TEXT_IS_USER(user));
1115   inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
1116 }
1117 static void
1118 inf_text_gtk_view_remove_user_cb(InfUserTable* user_table,
1119                                  InfUser* user,
1120                                  gpointer user_data)
1121 {
1122   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1123   g_assert(INF_TEXT_IS_USER(user));
1124   inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
1125 }
1126 static void
1127 inf_text_gtk_view_set_user_table_foreach_new_user_func(InfUser* user,
1128                                                        gpointer user_data)
1129 {
1130   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1131   g_assert(INF_TEXT_IS_USER(user));
1132   inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
1133 }
1134 static void
1135 inf_text_gtk_view_set_user_table_foreach_old_user_func(InfUser* user,
1136                                                        gpointer user_data)
1137 {
1138   InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
1139   g_assert(INF_TEXT_IS_USER(user));
1140   inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
1141 }
1142 static void
1143 inf_text_gtk_view_set_view(InfTextGtkView* view,
1144                            GtkTextView* gtk_view)
1145 {
1146   InfTextGtkViewPrivate* priv;
1147   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1148   if(priv-&gt;textview != NULL)
1149   {
1150     inf_signal_handlers_disconnect_by_func(
1151       G_OBJECT(priv-&gt;textview),
1152       G_CALLBACK(inf_text_gtk_view_draw_before_cb),
1153       view
1154     );
1155     inf_signal_handlers_disconnect_by_func(
1156       G_OBJECT(priv-&gt;textview),
1157       G_CALLBACK(inf_text_gtk_view_draw_after_cb),
1158       view
1159     );
1160     inf_signal_handlers_disconnect_by_func(
1161       G_OBJECT(priv-&gt;textview),
1162       G_CALLBACK(inf_text_gtk_view_style_updated_cb),
1163       view
1164     );
1165     inf_signal_handlers_disconnect_by_func(
1166       G_OBJECT(priv-&gt;textview),
1167       G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
1168       view
1169     );
1170     g_object_unref(priv-&gt;textview);
1171   }
1172   priv-&gt;textview = gtk_view;
1173   if(gtk_view != NULL)
1174   {
1175     g_object_ref(gtk_view);
1176     g_signal_connect(
1177       G_OBJECT(gtk_view),
1178       "draw",
1179       G_CALLBACK(inf_text_gtk_view_draw_before_cb),
1180       view
1181     );
1182     g_signal_connect_after(
1183       G_OBJECT(gtk_view),
1184       "draw",
1185       G_CALLBACK(inf_text_gtk_view_draw_after_cb),
1186       view
1187     );
1188     g_signal_connect_after(
1189       G_OBJECT(gtk_view),
1190       "style-updated",
1191       G_CALLBACK(inf_text_gtk_view_style_updated_cb),
1192       view
1193     );
1194     g_signal_connect_after(
1195       G_OBJECT(gtk_view),
1196       "size-allocate",
1197       G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
1198       view
1199     );
1200   }
1201   g_object_notify(G_OBJECT(view), "view");
1202 }
1203 static void
1204 inf_text_gtk_view_set_user_table(InfTextGtkView* view,
1205                                  InfUserTable* user_table)
1206 {
1207   InfTextGtkViewPrivate* priv;
1208   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1209   if(priv-&gt;user_table != NULL)
1210   {
1211     inf_signal_handlers_disconnect_by_func(
1212       G_OBJECT(priv-&gt;user_table),
1213       G_CALLBACK(inf_text_gtk_view_add_user_cb),
1214       view
1215     );
1216     inf_signal_handlers_disconnect_by_func(
1217       G_OBJECT(priv-&gt;user_table),
1218       G_CALLBACK(inf_text_gtk_view_remove_user_cb),
1219       view
1220     );
1221     inf_user_table_foreach_user(
1222       priv-&gt;user_table,
1223       inf_text_gtk_view_set_user_table_foreach_old_user_func,
1224       view
1225     );
1226     g_object_unref(priv-&gt;user_table);
1227   }
1228   priv-&gt;user_table = user_table;
1229   if(user_table != NULL)
1230   {
1231     g_object_ref(user_table);
1232     g_signal_connect(
1233       G_OBJECT(user_table),
1234       "add-user",
1235       G_CALLBACK(inf_text_gtk_view_add_user_cb),
1236       view
1237     );
1238     g_signal_connect(
1239       G_OBJECT(user_table),
1240       "remove-user",
1241       G_CALLBACK(inf_text_gtk_view_remove_user_cb),
1242       view
1243     );
1244     inf_user_table_foreach_user(
1245       user_table,
1246       inf_text_gtk_view_set_user_table_foreach_new_user_func,
1247       view
1248     );
1249   }
1250   g_object_notify(G_OBJECT(view), "user-table");
1251 }
1252 static void
1253 inf_text_gtk_view_init(InfTextGtkView* view)
1254 {
1255   InfTextGtkViewPrivate* priv;
1256   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1257   priv-&gt;io = NULL;
1258   priv-&gt;textview = NULL;
1259   priv-&gt;user_table = NULL;
1260   priv-&gt;active_user = NULL;
1261   priv-&gt;users = NULL;
1262   priv-&gt;show_remote_cursors = TRUE;
1263   priv-&gt;show_remote_selections = TRUE;
1264   priv-&gt;show_remote_current_lines = TRUE;
1265 }
1266 static void
1267 inf_text_gtk_view_dispose(GObject* object)
1268 {
1269   InfTextGtkView* view;
1270   InfTextGtkViewPrivate* priv;
1271   view = INF_TEXT_GTK_VIEW(object);
1272   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1273   inf_text_gtk_view_set_user_table(view, NULL);
1274   inf_text_gtk_view_set_view(view, NULL);
1275 <a name="0"></a>  g_assert(priv-&gt;active_user == NULL);
1276   g_assert(priv-&gt;users == NULL);
1277 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  if(priv-&gt;io != NULL)
1278   {
1279     g_object_unref(priv-&gt;io);
1280     priv-&gt;io = NULL;
1281   }
1282   G_OBJECT_CLASS(inf_text_gtk_view_parent_class)-&gt;dispose(object);
1283 }
1284 static void
1285 inf_text_gtk_view_set_property(GObject* object,
1286                                  guint prop_id,
1287                                  const GValue* value,
1288                                  GParamSpec* pspec)
1289 {
1290   InfTextGtkView* view;
1291   InfTextGtkViewPrivate* priv;
1292   view = INF_TEXT_GTK_VIEW(object);
1293   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1294   switch(prop_id)
1295   {
1296   case PROP_IO:
1297     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
1298     break;
1299   case PROP_VIEW:
1300     g_assert(priv-&gt;textview == NULL); 
1301     inf_text_gtk_view_set_view(
1302       view,
1303       GTK_TEXT_VIEW(g_value_get_object(value))
1304     );
1305     break;
1306   case PROP_USER_TABLE:
1307     g_assert(priv-&gt;user_table == NULL); 
1308     inf_text_gtk_view_set_user_table(
1309       view,
1310       INF_USER_TABLE(g_value_get_object(value))
1311     );
1312     break;
1313   case PROP_ACTIVE_USER:
1314     inf_text_gtk_view_set_active_user(
1315       view,
1316       INF_TEXT_USER(g_value_get_object(value))
1317     );
1318     break;
1319   case PROP_SHOW_REMOTE_CURSORS:
1320     inf_text_gtk_view_set_show_remote_cursors(
1321       view,
1322       g_value_get_boolean(value)
1323     );
1324     break;
1325   case PROP_SHOW_REMOTE_SELECTIONS:
1326     inf_text_gtk_view_set_show_remote_selections(
1327       view,
1328       g_value_get_boolean(value)
1329     );
1330     break;
1331   case PROP_SHOW_REMOTE_CURRENT_LINES:
1332     inf_text_gtk_view_set_show_remote_current_lines(
1333       view,
1334 <a name="3"></a>      g_value_get_boolean(value)
1335     );
1336 <font color="#53858b"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
1337   default:
1338     G_OBJECT_WARN_INVALID_PROPERTY_ID(value, prop_id, pspec);
1339     break;
1340   }
1341 }
1342 static void
1343 inf_text_gtk_view_get_property(GObject* object,
1344                                  guint prop_id,
1345                                  GValue* value,
1346                                  GParamSpec* pspec)
1347 {
1348   InfTextGtkView* view;
1349   InfTextGtkViewPrivate* priv;
1350   view = INF_TEXT_GTK_VIEW(object);
1351   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1352   switch(prop_id)
1353   {
1354   case PROP_IO:
1355     g_value_set_object(value, G_OBJECT(priv-&gt;io));
1356     break;
1357   case PROP_VIEW:
1358     g_value_set_object(value, G_OBJECT(priv-&gt;textview));
1359     break;</b></font>
1360   case PROP_USER_TABLE:
1361     g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
1362     break;
1363   case PROP_ACTIVE_USER:
1364     g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
1365     break;
1366   case PROP_SHOW_REMOTE_CURSORS:
1367     g_value_set_boolean(value, priv-&gt;show_remote_cursors);
1368     break;
1369   case PROP_SHOW_REMOTE_SELECTIONS:
1370     g_value_set_boolean(value, priv-&gt;show_remote_selections);
1371 <a name="4"></a>    break;
1372   case PROP_SHOW_REMOTE_CURRENT_LINES:
1373     g_value_set_boolean(value, priv-&gt;show_remote_current_lines);
1374 <font color="#6cc417"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    break;
1375   default:
1376     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
1377     break;
1378   }
1379 }
1380 static void
1381 inf_text_gtk_view_class_init(InfTextGtkViewClass* view_class)
1382 {
1383   GObjectClass* object_class;
1384   object_class = G_OBJECT_CLASS(view_class);
1385   object_class-&gt;dispose = inf_text_gtk_view_dispose;
1386   object_class-&gt;set_property = inf_text_gtk_view_set_property;
1387   object_class-&gt;get_property = inf_text_gtk_view_get_property;</b></font>
1388   g_object_class_install_property(
1389     object_class,
1390     PROP_IO,
1391     g_param_spec_object(
1392       "io",
1393       "IO",
1394       "The IO object to schedule timeouts",
1395       INF_TYPE_IO,
1396       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1397     )
1398   );
1399   g_object_class_install_property(
1400     object_class,
1401     PROP_VIEW,
1402     g_param_spec_object(
1403       "view",
1404       "View",
1405       "The underlying GtkTextView",
1406       GTK_TYPE_TEXT_VIEW,
1407       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1408     )
1409   );
1410   g_object_class_install_property(
1411     object_class,
1412     PROP_USER_TABLE,
1413     g_param_spec_object(
1414       "user-table",
1415       "User table",
1416       "The user table containing the users of the session shown in the view",
1417       INF_TYPE_USER_TABLE,
1418       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1419     )
1420   );
1421   g_object_class_install_property(
1422     object_class,
1423     PROP_ACTIVE_USER,
1424     g_param_spec_object(
1425       "active-user",
1426       "Active user",
1427       "The user for which to show the view",
1428       INF_TEXT_TYPE_USER,
1429       G_PARAM_READWRITE
1430     )
1431   );
1432   g_object_class_install_property(
1433     object_class,
1434     PROP_SHOW_REMOTE_CURSORS,
1435     g_param_spec_boolean(
1436       "show-remote-cursors",
1437       "Show remote cursors",
1438       "Whether to show cursors of non-local users",
1439       TRUE,
1440       G_PARAM_READWRITE
1441     )
1442   );
1443   g_object_class_install_property(
1444     object_class,
1445     PROP_SHOW_REMOTE_SELECTIONS,
1446     g_param_spec_boolean(
1447       "show-remote-selections",
1448       "Show remote selections",
1449       "Whether to highlight text selected by non-local users",
1450       TRUE,
1451       G_PARAM_READWRITE
1452     )
1453   );
1454   g_object_class_install_property(
1455     object_class,
1456     PROP_SHOW_REMOTE_CURRENT_LINES,
1457     g_param_spec_boolean(
1458       "show-remote-current-lines",
1459       "Show remote current lines",
1460       "Whether to highlight the line in which the cursor of non-local users is",
1461       TRUE,
1462       G_PARAM_READWRITE
1463     )
1464   );
1465 }
1466 InfTextGtkView*
1467 inf_text_gtk_view_new(InfIo* io,
1468                       GtkTextView* view,
1469                       InfUserTable* user_table)
1470 {
1471   GObject* object;
1472   g_return_val_if_fail(INF_IS_IO(io), NULL);
1473   g_return_val_if_fail(GTK_IS_TEXT_VIEW(view), NULL);
1474   g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);
1475   object = g_object_new(
1476     INF_TEXT_GTK_TYPE_VIEW,
1477     "io", io,
1478     "view", view,
1479     "user-table", user_table,
1480     NULL
1481   );
1482   return INF_TEXT_GTK_VIEW(object);
1483 }
1484 GtkTextView*
1485 inf_text_gtk_view_get_text_view(InfTextGtkView* view)
1486 {
1487   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1488   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;textview;
1489 }
1490 InfUserTable*
1491 inf_text_gtk_view_get_user_table(InfTextGtkView* view)
1492 {
1493   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1494   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;user_table;
1495 }
1496 void
1497 inf_text_gtk_view_set_active_user(InfTextGtkView* view,
1498                                   InfTextUser* user)
1499 {
1500   InfTextGtkViewPrivate* priv;
1501   InfTextUser* active_user;
1502   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1503   g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));
1504   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1505   g_return_if_fail(
1506     user == NULL ||
1507     inf_user_table_lookup_user_by_id(
1508       priv-&gt;user_table,
1509       inf_user_get_id(INF_USER(user))
1510     ) == INF_USER(user)
1511   );
1512   if(priv-&gt;active_user != NULL)
1513   {
1514     active_user = priv-&gt;active_user;
1515     priv-&gt;active_user = NULL;
1516     inf_text_gtk_view_user_added(view, active_user);
1517   }
1518   if(user != NULL)
1519   {
1520     inf_text_gtk_view_user_removed(view, user);
1521   }
1522   priv-&gt;active_user = user;
1523   g_object_notify(G_OBJECT(view), "active-user");
1524 }
1525 InfTextUser*
1526 inf_text_gtk_view_get_active_user(InfTextGtkView* view)
1527 {
1528   g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
1529   return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;active_user;
1530 }
1531 void
1532 inf_text_gtk_view_set_show_remote_cursors(InfTextGtkView* view,
1533                                           gboolean show)
1534 {
1535   InfTextGtkViewPrivate* priv;
1536   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1537   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1538   if(priv-&gt;show_remote_cursors != show)
1539   {
1540     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1541     priv-&gt;show_remote_cursors = show;
1542     g_object_notify(G_OBJECT(view), "show-remote-cursors");
1543   }
1544 }
1545 void
1546 inf_text_gtk_view_set_show_remote_selections(InfTextGtkView* view,
1547                                              gboolean show)
1548 {
1549   InfTextGtkViewPrivate* priv;
1550   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1551   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1552   if(priv-&gt;show_remote_selections != show)
1553   {
1554     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1555     priv-&gt;show_remote_selections = show;
1556     g_object_notify(G_OBJECT(view), "show-remote-selections");
1557   }
1558 }
1559 void
1560 inf_text_gtk_view_set_show_remote_current_lines(InfTextGtkView* view,
1561                                                 gboolean show)
1562 {
1563   InfTextGtkViewPrivate* priv;
1564   g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
1565   priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
1566   if(priv-&gt;show_remote_current_lines != show)
1567   {
1568     gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
1569     priv-&gt;show_remote_current_lines = show;
1570     g_object_notify(G_OBJECT(view), "show-remote-current-lines");
1571   }
1572 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-browser-store.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;libinfgtk/inf-gtk-browser-store.h&gt;
2 #include &lt;libinfgtk/inf-gtk-browser-model.h&gt;
3 #include &lt;libinfinity/client/infc-browser.h&gt;
4 #include &lt;libinfinity/inf-i18n.h&gt;
5 #include &lt;libinfinity/inf-signals.h&gt;
6 #include &lt;gtk/gtk.h&gt;
7 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>typedef struct _InfGtkBrowserStoreItem InfGtkBrowserStoreItem;
8 struct _InfGtkBrowserStoreItem {
9   gchar* name;
10   InfDiscovery* discovery;
11   InfDiscoveryInfo* info;
12   InfBrowser* browser;
13   gpointer missing;
14   GSList* requests;
15   GHashTable* node_errors;
16   InfGtkBrowserModelStatus status;
17   GError* error;
18   InfGtkBrowserStoreItem* next;
19 };
20 typedef struct _InfGtkBrowserStoreRequestData InfGtkBrowserStoreRequestData;
21 struct _InfGtkBrowserStoreRequestData {
22   InfGtkBrowserStore* store;
23   InfGtkBrowserStoreItem* item;
24 };
25 typedef struct _InfGtkBrowserStorePrivate InfGtkBrowserStorePrivate;
26 struct _InfGtkBrowserStorePrivate {
27   gint stamp;
28   InfIo* io;
29   InfCommunicationManager* communication_manager;
30   GSList* discoveries;
31   InfGtkBrowserStoreItem* first_item;
32   InfGtkBrowserStoreItem* last_item;
33 };
34 enum {
35   PROP_0,
36   PROP_IO,
37   PROP_COMMUNICATION_MANAGER
38 };
39 #define INF_GTK_BROWSER_STORE_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_BROWSER_STORE, InfGtkBrowserStorePrivate))
40 static void inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface);</b></font>
41 static void inf_gtk_browser_store_browser_model_iface_init(InfGtkBrowserModelInterface* iface);
42 G_DEFINE_TYPE_WITH_CODE(InfGtkBrowserStore, inf_gtk_browser_store, G_TYPE_OBJECT,
43   G_ADD_PRIVATE(InfGtkBrowserStore)
44   G_IMPLEMENT_INTERFACE(GTK_TYPE_TREE_MODEL, inf_gtk_browser_store_tree_model_iface_init)
45   G_IMPLEMENT_INTERFACE(INF_GTK_TYPE_BROWSER_MODEL, inf_gtk_browser_store_browser_model_iface_init))
46 static InfGtkBrowserStoreItem*
47 inf_gtk_browser_store_find_item_by_connection(InfGtkBrowserStore* store,
48                                               InfXmlConnection* connection)
49 {
50   InfGtkBrowserStorePrivate* priv;
51   InfGtkBrowserStoreItem* item;
52   InfcBrowser* browser;
53   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
54   for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
55   {
56     if(item-&gt;browser != NULL &amp;&amp; INFC_IS_BROWSER(item-&gt;browser))
57     {
58       browser = INFC_BROWSER(item-&gt;browser);
59       if(infc_browser_get_connection(browser) == connection)
60         return item;
61     }
62   }
63   return NULL;
64 }
65 static InfGtkBrowserStoreItem*
66 inf_gtk_browser_store_find_item_by_browser(InfGtkBrowserStore* store,
67                                            InfBrowser* browser)
68 {
69   InfGtkBrowserStorePrivate* priv;
70   InfGtkBrowserStoreItem* item;
71   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
72   for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
73     if(item-&gt;browser != NULL)
74       if(item-&gt;browser == browser)
75         return item;
76   return NULL;
77 }
78 static InfGtkBrowserStoreItem*
79 inf_gtk_browser_store_find_item_by_discovery_info(InfGtkBrowserStore* store,
80                                                   InfDiscoveryInfo* info)
81 {
82   InfGtkBrowserStorePrivate* priv;
83   InfGtkBrowserStoreItem* item;
84   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
85   for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
86     if(item-&gt;info != NULL)
87       if(item-&gt;info == info)
88         return item;
89   return NULL;
90 }
91 static void
92 inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
93                                                GParamSpec* pspec,
94                                                gpointer user_data);
95 static void
96 inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
97                                        const GError* error,
98                                        gpointer user_data);
99 static void
100 inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
101                                     InfBrowserIter* iter,
102                                     InfRequest* request,
103                                     gpointer user_data);
104 static void
105 inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
106                                       InfBrowserIter* iter,
107                                       InfRequest* request,
108                                       gpointer user_data);
109 static void
110 inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
111                                                     InfBrowserIter* iter,
112                                                     InfRequest* request,
113                                                     gpointer user_data);
114 static void
115 inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
116                                                          InfBrowserIter* iter,
117                                                          InfRequest* request,
118                                                          gpointer user_data);
119 static void
120 inf_gtk_browser_store_request_finished_cb(InfRequest* request,
121                                           const InfRequestResult* result,
122                                           const GError* error,
123                                           gpointer user_data);
124 static void
125 inf_gtk_browser_store_request_unrefed_func(gpointer data,
126                                            GObject* where_the_object_was);
127 static void
128 inf_gtk_browser_store_request_data_free(gpointer data,
129                                         GClosure* closure)
130 {
131   g_slice_free(InfGtkBrowserStoreRequestData, data);
132 }
133 static void
134 inf_gtk_browser_store_item_request_remove(InfGtkBrowserStoreItem* item,
135                                           InfRequest* request)
136 {
137   g_object_weak_unref(
138     G_OBJECT(request),
139     inf_gtk_browser_store_request_unrefed_func,
140     item
141   );
142   inf_signal_handlers_disconnect_by_func(
143     G_OBJECT(request),
144     G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
145     item
146   );
147   item-&gt;requests = g_slist_remove(item-&gt;requests, request);
148 }
149 static void
150 inf_gtk_browser_store_item_request_add(InfGtkBrowserStore* store,
151                                        InfGtkBrowserStoreItem* item,
152                                        InfRequest* request)
153 {
154   InfGtkBrowserStoreRequestData* data;
155   g_assert(g_slist_find(item-&gt;requests, request) == NULL);
156   item-&gt;requests = g_slist_prepend(item-&gt;requests, request);
157   data = g_slice_new(InfGtkBrowserStoreRequestData);
158   data-&gt;store = store;
159   data-&gt;item = item;
160   g_signal_connect_data(
161     G_OBJECT(request),
162     "finished",
163     G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
164     data,
165     inf_gtk_browser_store_request_data_free,
166     0
167   );
168   g_object_weak_ref(
169     G_OBJECT(request),
170     inf_gtk_browser_store_request_unrefed_func,
171     item
172   );
173 }
174 static void
175 inf_gtk_browser_store_request_finished_cb(InfRequest* request,
176                                           const InfRequestResult* result,
177                                           const GError* error,
178                                           gpointer user_data)
179 {
180   InfGtkBrowserStoreRequestData* data;
181   InfGtkBrowserStorePrivate* priv;
182   InfBrowserIter request_iter;
183   gboolean node_exists;
184   GtkTreeIter tree_iter;
185   GtkTreePath* path;
186   data = (InfGtkBrowserStoreRequestData*)user_data;
187   priv = INF_GTK_BROWSER_STORE_PRIVATE(data-&gt;store);
188   g_assert(g_slist_find(data-&gt;item-&gt;requests, request) != NULL);
189   g_assert(data-&gt;item-&gt;browser != NULL);
190   if(error != NULL)
191   {
192     node_exists = inf_browser_iter_from_request(
193       data-&gt;item-&gt;browser,
194       request,
195       &amp;request_iter
196     );
197     inf_gtk_browser_store_item_request_remove(data-&gt;item, request);
198     if(G_LIKELY(node_exists))
199     {
200       g_hash_table_insert(
201         data-&gt;item-&gt;node_errors,
202         GUINT_TO_POINTER(request_iter.node_id),
203         g_error_copy(error)
204       );
205       tree_iter.stamp = priv-&gt;stamp;
206       tree_iter.user_data = data-&gt;item;
207       tree_iter.user_data2 = GUINT_TO_POINTER(request_iter.node_id);
208       if(request_iter.node_id == 0)
209         tree_iter.user_data3 = NULL;
210       else
211         tree_iter.user_data3 = request_iter.node;
212 <a name="2"></a>      path = gtk_tree_model_get_path(GTK_TREE_MODEL(data-&gt;store), &amp;tree_iter);
213       gtk_tree_model_row_changed(GTK_TREE_MODEL(data-&gt;store), path, &amp;tree_iter);
214       gtk_tree_path_free(path);
215 <font color="#980517"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    }
216   }
217 }
218 static void
219 inf_gtk_browser_store_request_unrefed_func(gpointer data,
220                                            GObject* where_the_object_was)
221 {
222   InfGtkBrowserStoreItem* item;
223   item = (InfGtkBrowserStoreItem*)data;
224   item-&gt;requests = g_slist_remove(item-&gt;requests, where_the_object_was);
225 }
226 static void
227 inf_gtk_browser_store_item_set_browser(InfGtkBrowserStore* store,
228                                        InfGtkBrowserStoreItem* item,
229                                        GtkTreePath* path,
230                                        InfBrowser* browser)
231 {
232   GtkTreeIter tree_iter;
233   InfGtkBrowserStorePrivate* priv;
234   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
235   tree_iter.stamp = priv-&gt;stamp;
236   tree_iter.user_data = item;
237   tree_iter.user_data2 = GUINT_TO_POINTER(0);
238   tree_iter.user_data3 = NULL;</b></font>
239   inf_gtk_browser_model_set_browser(
240     INF_GTK_BROWSER_MODEL(store),
241     path,
242     &amp;tree_iter,
243     item-&gt;browser,
244     browser
245   );
246 }
247 static InfGtkBrowserStoreItem*
248 inf_gtk_browser_store_add_item_by_browser(InfGtkBrowserStore* store,
249                                           InfDiscovery* discovery,
250                                           InfDiscoveryInfo* info,
251                                           InfBrowser* browser,
252                                           gchar* name)
253 {
254   InfGtkBrowserStorePrivate* priv;
255   InfGtkBrowserStoreItem* item;
256   InfGtkBrowserStoreItem* cur;
257   GtkTreePath* path;
258   GtkTreeIter iter;
259   guint index;
260   g_assert(
261     browser == NULL ||
262     inf_gtk_browser_store_find_item_by_browser(store, browser) == NULL
263   );
264   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
265   item = g_slice_new(InfGtkBrowserStoreItem);
266   item-&gt;name = name;
267   item-&gt;discovery = discovery;
268   item-&gt;info = info;
269   item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
270   if(discovery != NULL &amp;&amp; info != NULL)
271     item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
272   item-&gt;browser = NULL;
273   item-&gt;missing = NULL;
274   item-&gt;node_errors = g_hash_table_new_full(
275     NULL,
276     NULL,
277     NULL,
278     (GDestroyNotify)g_error_free
279   );
280   item-&gt;requests = NULL;
281   item-&gt;error = NULL;
282   item-&gt;next = NULL;
283   index = 0;
284   for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
285 <a name="5"></a>    ++ index;
286 <font color="#151b8d"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(priv-&gt;first_item == NULL)
287   {
288     priv-&gt;first_item = item;
289     priv-&gt;last_item = item;
290   }
291   else
292   {
293     priv-&gt;last_item-&gt;next = item;
294     priv-&gt;last_item = item;
295   }
296   path = gtk_tree_path_new_from_indices(index, -1);</b></font>
297   iter.stamp = priv-&gt;stamp;
298   iter.user_data = item;
299   iter.user_data2 = GUINT_TO_POINTER(0);
300   iter.user_data3 = NULL;
301   gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;iter);
302   if(browser != NULL)
303     inf_gtk_browser_store_item_set_browser(store, item, path, browser);
304   gtk_tree_path_free(path);
305   return item;
306 }
307 static InfGtkBrowserStoreItem*
308 inf_gtk_browser_store_add_item_by_connection(InfGtkBrowserStore* store,
309                                              InfDiscovery* discovery,
310                                              InfDiscoveryInfo* info,
311                                              InfXmlConnection* connection,
312                                              gchar* name)
313 {
314   InfGtkBrowserStorePrivate* priv;
315   InfcBrowser* browser;
316   InfGtkBrowserStoreItem* item;
317   g_assert(
318     connection == NULL ||
319     inf_gtk_browser_store_find_item_by_connection(store, connection) == NULL
320   );
321   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
322   browser = NULL;
323   if(connection != NULL)
324   {
325     browser = infc_browser_new(
326       priv-&gt;io,
327       priv-&gt;communication_manager,
328       connection
329     );
330     if(infc_browser_get_connection(browser) == NULL)
331     {
332       g_object_unref(browser);
333       g_free(name);
334       return NULL;
335     }
336   }
337   item = inf_gtk_browser_store_add_item_by_browser(
338     store,
339     discovery,
340     info,
341     INF_BROWSER(browser),
342     name
343   );
344   if(browser != NULL)
345     g_object_unref(browser);
346   return item;
347 }
348 static void
349 inf_gtk_browser_store_remove_item(InfGtkBrowserStore* store,
350                                   InfGtkBrowserStoreItem* item)
351 {
352   InfGtkBrowserStorePrivate* priv;
353   InfGtkBrowserStoreItem* prev;
354   InfGtkBrowserStoreItem* cur;
355   GtkTreePath* path;
356   guint index;
357   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
358   prev = NULL;
359   index = 0;
360   for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
361   {
362     if(cur == item)
363       break;
364     prev = cur;
365     ++ index;
366   }
367   g_assert(cur != NULL);
368   path = gtk_tree_path_new_from_indices(index, -1);
369   if(item-&gt;browser != NULL)
370   {
371     inf_gtk_browser_store_item_set_browser(store, item, path, NULL);
372     g_assert(item-&gt;browser == NULL);   }
373   if(prev == NULL)
374     priv-&gt;first_item = item-&gt;next;
375   else
376     prev-&gt;next = item-&gt;next;
377   if(item-&gt;next == NULL)
378     priv-&gt;last_item = prev;
379   g_assert(cur != NULL);
380   gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
381   gtk_tree_path_free(path);
382   if(item-&gt;error != NULL)
383     g_error_free(item-&gt;error);
384   g_hash_table_unref(item-&gt;node_errors);
385   g_free(item-&gt;name);
386   g_slice_free(InfGtkBrowserStoreItem, item);
387 }
388 static void
389 inf_gtk_browser_store_discovered_cb(InfDiscovery* discovery,
390                                     InfDiscoveryInfo* info,
391                                     gpointer user_data)
392 {
393   inf_gtk_browser_store_add_item_by_browser(
394     INF_GTK_BROWSER_STORE(user_data),
395     discovery,
396     info,
397     NULL,
398     inf_discovery_info_get_service_name(discovery, info)
399   );
400 }
401 static void
402 inf_gtk_browser_store_undiscovered_cb(InfDiscovery* discovery,
403                                       InfDiscoveryInfo* info,
404                                       gpointer user_data)
405 {
406   InfGtkBrowserStore* store;
407   InfGtkBrowserStoreItem* item;
408   store = INF_GTK_BROWSER_STORE(user_data);
409   item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);
410   if(item != NULL)
411   {
412     if(item-&gt;browser == NULL)
413     {
414       inf_gtk_browser_store_remove_item(store, item);
415     }
416     else
417     {
418       g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_DISCOVERED &amp;&amp;
419                item-&gt;status != INF_GTK_BROWSER_MODEL_RESOLVING);
420       item-&gt;discovery = NULL;
421       item-&gt;info = NULL;
422     }
423   }
424 }
425 static void
426 inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
427                                        const GError* error,
428                                        gpointer user_data)
429 {
430   InfGtkBrowserStore* store;
431   InfGtkBrowserStoreItem* item;
432   InfGtkBrowserStorePrivate* priv;
433   GtkTreeIter iter;
434   GtkTreePath* path;
435   store = INF_GTK_BROWSER_STORE(user_data);
436   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
437   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
438   g_assert(item != NULL);
439   if(item-&gt;error != NULL)
440     g_error_free(item-&gt;error);
441   item-&gt;error = g_error_copy(error);
442   iter.stamp = priv-&gt;stamp;
443   iter.user_data = item;
444   iter.user_data2 = GUINT_TO_POINTER(0);
445   iter.user_data3 = NULL;
446   path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
447   gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
448   gtk_tree_path_free(path);
449 }
450 static void
451 inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
452                                                GParamSpec* pspec,
453                                                gpointer user_data)
454 {
455   InfGtkBrowserStore* store;
456   InfGtkBrowserStorePrivate* priv;
457   InfBrowser* browser;
458   InfBrowserStatus status;
459   InfGtkBrowserStoreItem* item;
460   GtkTreeIter iter;
461   GtkTreePath* path;
462   store = INF_GTK_BROWSER_STORE(user_data);
463   priv = INF_GTK_BROWSER_STORE_PRIVATE(user_data);  
464   browser = INF_BROWSER(object);
465   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
466   g_assert(item != NULL);
467   iter.stamp = priv-&gt;stamp;
468   iter.user_data = item;
469   iter.user_data2 = GUINT_TO_POINTER(0);
470   iter.user_data3 = NULL;
471   path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
472   g_object_get(G_OBJECT(browser), "status", &amp;status, NULL);
473   switch(status)
474   {
475   case INF_BROWSER_CLOSED:
476     item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;
477     if(item-&gt;error == NULL)
478     {
479       item-&gt;error = g_error_new_literal(
480         g_quark_from_static_string("INF_GTK_BROWSER_STORE_ERROR"),
481         0,
482         _("Disconnected")
483       );
484     }
485     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
486     break;
487   case INF_BROWSER_OPENING:
488     if(item-&gt;error != NULL) g_error_free(item-&gt;error);
489     item-&gt;error = NULL;
490     item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
491     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
492     break;
493   case INF_BROWSER_OPEN:
494     if(item-&gt;error != NULL) g_error_free(item-&gt;error);
495 <a name="4"></a>    item-&gt;error = NULL;
496     item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
497     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
498 <font color="#6cc417"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
499   default:
500     g_assert_not_reached();
501     break;
502   }
503   gtk_tree_path_free(path);
504 }
505 static void
506 inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
507                                     InfBrowserIter* iter,
508                                     InfRequest* request,
509                                     gpointer user_data)
510 {
511   InfGtkBrowserStore* store;
512   InfGtkBrowserStorePrivate* priv;
513   InfGtkBrowserStoreItem* item;
514   GtkTreeIter tree_iter;
515   GtkTreePath* path;
516   InfBrowserIter test_iter;
517   gboolean test_result;
518   store = INF_GTK_BROWSER_STORE(user_data);
519   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
520   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
521   tree_iter.stamp = priv-&gt;stamp;</b></font>
522   tree_iter.user_data = item;
523   tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
524   tree_iter.user_data3 = iter-&gt;node;
525   if(iter-&gt;node_id != 0)
526   {
527     path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
528     gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;tree_iter);
529     test_iter = *iter;
530     test_result = inf_browser_get_parent(browser, &amp;test_iter);
531     g_assert(test_result == TRUE);
532     tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);
533     gtk_tree_path_up(path);
534     if(test_iter.node_id == 0)
535       tree_iter.user_data3 = NULL;
536     else
537       tree_iter.user_data3 = test_iter.node;
538     test_result = inf_browser_get_child(browser, &amp;test_iter);
539     g_assert(test_result == TRUE);
540     if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
541     {
542       gtk_tree_model_row_has_child_toggled(
543         GTK_TREE_MODEL(store),
544         path,
545         &amp;tree_iter
546       );
547     }
548     gtk_tree_path_free(path);
549   }
550 }
551 static void
552 inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
553                                       InfBrowserIter* iter,
554                                       InfRequest* request,
555                                       gpointer user_data)
556 {
557   InfGtkBrowserStore* store;
558   InfGtkBrowserStorePrivate* priv;
559   InfGtkBrowserStoreItem* item;
560   GtkTreeIter tree_iter;
561   GtkTreePath* path;
562   InfBrowserIter test_iter;
563   gboolean test_result;
564   store = INF_GTK_BROWSER_STORE(user_data);
565   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
566   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
567   g_assert(item-&gt;missing == NULL);
568   tree_iter.stamp = priv-&gt;stamp;
569   tree_iter.user_data = item;
570   tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
571   tree_iter.user_data3 = iter-&gt;node;
572   path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
573   item-&gt;missing = iter-&gt;node;
574   if(iter-&gt;node_id != 0)
575   {
576     gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
577     test_iter = *iter;
578     test_result = inf_browser_get_parent(browser, &amp;test_iter);
579     g_assert(test_result == TRUE);
580     tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);
581     gtk_tree_path_up(path);
582     if(test_iter.node_id == 0)
583       tree_iter.user_data3 = NULL;
584     else
585       tree_iter.user_data3 = test_iter.node;
586     test_result = inf_browser_get_child(browser, &amp;test_iter);
587     g_assert(test_result == TRUE);
588     if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
589     {
590       gtk_tree_model_row_has_child_toggled(
591         GTK_TREE_MODEL(store),
592         path,
593         &amp;tree_iter
594       );
595     }
596   }
597   else
598   {
599     if(inf_browser_get_explored(browser, iter))
600     {
601       test_iter = *iter;
602       test_result = inf_browser_get_child(browser, &amp;test_iter);
603       gtk_tree_path_down(path);
604       do
605       {
606         gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
607       } while(inf_browser_get_next(browser, &amp;test_iter));
608       if(test_result == TRUE)
609       {
610         gtk_tree_path_up(path);
611         gtk_tree_model_row_has_child_toggled(
612           GTK_TREE_MODEL(store),
613           path,
614           &amp;tree_iter
615         );
616       }
617     }
618   }
619   item-&gt;missing = NULL;
620   gtk_tree_path_free(path);
621 }
622 static void
623 inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
624                                                     InfBrowserIter* iter,
625                                                     InfRequest* request,
626                                                     gpointer user_data)
627 {
628   InfGtkBrowserStore* store;
629   InfGtkBrowserStoreItem* item;
630   store = INF_GTK_BROWSER_STORE(user_data);
631   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
632   inf_gtk_browser_store_item_request_add(store, item, request);
633 }
634 static void
635 inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
636                                                          InfBrowserIter* iter,
637                                                          InfRequest* request,
638                                                          gpointer user_data)
639 {
640   InfGtkBrowserStore* store;
641   InfGtkBrowserStoreItem* item;
642   g_assert(iter != NULL);
643   store = INF_GTK_BROWSER_STORE(user_data);
644   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
645   inf_gtk_browser_store_item_request_add(store, item, request);
646 }
647 static void
648 inf_gtk_browser_store_resolv_complete_func(InfDiscoveryInfo* info,
649                                            InfXmlConnection* connection,
650                                            const GError* error,
651                                            gpointer user_data)
652 {
653   InfGtkBrowserStore* store;
654   InfGtkBrowserStorePrivate* priv;
655   InfGtkBrowserStoreItem* new_item;
656   InfGtkBrowserStoreItem* old_item;
657   GtkTreeIter tree_iter;
658   GtkTreePath* path;
659   InfcBrowser* browser;
660   InfGtkBrowserStoreItem* cur;
661   InfGtkBrowserStoreItem* prev;
662   InfGtkBrowserStoreItem* prev_new;
663   InfGtkBrowserStoreItem* prev_old;
664   gint* order;
665   guint count;
666   guint new_pos;
667   guint old_pos;
668   guint i;
669   store = INF_GTK_BROWSER_STORE(user_data);
670   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
671   new_item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);
672   g_assert(new_item != NULL);
673   g_assert(new_item-&gt;status == INF_GTK_BROWSER_MODEL_RESOLVING);
674   tree_iter.stamp = priv-&gt;stamp;
675   tree_iter.user_data = new_item;
676   tree_iter.user_data2 = GUINT_TO_POINTER(0);
677   tree_iter.user_data3 = NULL;
678   if(error != NULL)
679   {
680     new_item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;
681     new_item-&gt;error = g_error_copy(error);
682     path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
683     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;tree_iter);
684     gtk_tree_path_free(path);
685   }
686   else
687   {
688     old_item =
689       inf_gtk_browser_store_find_item_by_connection(store, connection);
690     if(old_item != NULL)
691     {
692       g_assert(old_item != new_item);
693       count = 0;
694       prev = NULL;
695       for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
696       {
697         if(cur == old_item) { old_pos = count; prev_old = prev; }
698         if(cur == new_item) { new_pos = count; prev_new = prev; }
699         ++ count;
700         prev = cur;
701       }
702       inf_gtk_browser_store_remove_item(store, new_item);
703       if(old_pos &gt; new_pos) -- old_pos;
704       else -- new_pos;
705       -- count;
706       if(new_pos != old_pos)
707       {
708         if(old_item-&gt;next == NULL)
709           priv-&gt;last_item = prev_old;
710         if(prev_old != NULL)
711           prev_old-&gt;next = old_item-&gt;next;
712         else
713           priv-&gt;first_item = old_item-&gt;next;
714         old_item-&gt;next = prev_new-&gt;next;
715         if(prev_new != NULL)
716           prev_new-&gt;next = old_item;
717         else
718           priv-&gt;first_item = old_item;
719         if(old_item-&gt;next == NULL)
720           priv-&gt;last_item = old_item;
721         order = g_malloc(sizeof(gint) * count);
722         if(new_pos &lt; old_pos)
723         {
724           for(i = 0; i &lt; new_pos; ++ i)
725             order[i] = i;
726           order[new_pos] = old_pos;
727           for(i = new_pos + 1; i &lt;= old_pos; ++ i)
728             order[i] = i - 1;
729           for(i = old_pos + 1; i &lt; count; ++ i)
730             order[i] = i;
731         }
732         else
733         {
734           for(i = 0; i &lt; old_pos; ++ i)
735             order[i] = i;
736           for(i = old_pos; i &lt; new_pos; ++ i)
737             order[i] = i + 1;
738           order[new_pos] = old_pos;
739           for(i = new_pos + 1; i &lt; count; ++ i)
740             order[i] = i;
741         }
742         path = gtk_tree_path_new();
743         gtk_tree_model_rows_reordered(
744           GTK_TREE_MODEL(store),
745           path,
746           NULL,
747           order
748         );
749         gtk_tree_path_free(path);
750         g_free(order);
751       }
752     }
753     else
754     {
755       path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
756       browser = infc_browser_new(
757         priv-&gt;io,
758         priv-&gt;communication_manager,
759         connection
760       );
761       if(infc_browser_get_connection(browser) != NULL)
762       {
763         inf_gtk_browser_store_item_set_browser(
764           store,
765           new_item,
766           path,
767           INF_BROWSER(browser)
768         );
769       }
770       g_object_unref(G_OBJECT(browser));
771       gtk_tree_path_free(path);
772     }
773   }
774 }
775 static void
776 inf_gtk_browser_store_init(InfGtkBrowserStore* store)
777 {
778   InfGtkBrowserStorePrivate* priv;
779   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
780   priv-&gt;stamp = g_random_int();
781   priv-&gt;io = NULL;
782   priv-&gt;communication_manager = NULL;
783   priv-&gt;discoveries = NULL;
784   priv-&gt;first_item = NULL;
785   priv-&gt;last_item = NULL;
786 }
787 static void
788 inf_gtk_browser_store_dispose(GObject* object)
789 {
790   InfGtkBrowserStore* store;
791   InfGtkBrowserStorePrivate* priv;
792   GSList* item;
793   store = INF_GTK_BROWSER_STORE(object);
794   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
795   while(priv-&gt;first_item != NULL)
796     inf_gtk_browser_store_remove_item(store, priv-&gt;first_item);
797   g_assert(priv-&gt;last_item == NULL);
798   for(item = priv-&gt;discoveries; item != NULL; item = g_slist_next(item))
799   {
800     inf_signal_handlers_disconnect_by_func(
801       G_OBJECT(item-&gt;data),
802       G_CALLBACK(inf_gtk_browser_store_discovered_cb),
803       store
804     );
805     inf_signal_handlers_disconnect_by_func(
806       G_OBJECT(item-&gt;data),
807       G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
808       store
809     );
810     g_object_unref(G_OBJECT(item-&gt;data));
811   }
812   g_slist_free(priv-&gt;discoveries);
813   priv-&gt;discoveries = NULL;
814   if(priv-&gt;communication_manager != NULL)
815   {
816     g_object_unref(priv-&gt;communication_manager);
817 <a name="0"></a>    priv-&gt;communication_manager = NULL;
818   }
819 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  if(priv-&gt;io != NULL)
820   {
821     g_object_unref(G_OBJECT(priv-&gt;io));
822     priv-&gt;io = NULL;
823   }
824   G_OBJECT_CLASS(inf_gtk_browser_store_parent_class)-&gt;dispose(object);
825 }
826 static void
827 inf_gtk_browser_store_set_property(GObject* object,
828                                    guint prop_id,
829                                    const GValue* value,
830                                    GParamSpec* pspec)
831 {
832   InfGtkBrowserStore* store;
833   InfGtkBrowserStorePrivate* priv;
834   store = INF_GTK_BROWSER_STORE(object);
835   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
836   switch(prop_id)
837   {
838   case PROP_IO:
839     g_assert(priv-&gt;io == NULL);     priv-&gt;io = INF_IO(g_value_dup_object(value));
840     break;
841   case PROP_COMMUNICATION_MANAGER: 
842     g_assert(priv-&gt;communication_manager == NULL); <a name="3"></a>    priv-&gt;communication_manager =
843       INF_COMMUNICATION_MANAGER(g_value_dup_object(value));
844 <font color="#53858b"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    break;
845   default:
846     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
847     break;
848   }
849 }
850 static void
851 inf_gtk_browser_store_get_property(GObject* object,
852                                    guint prop_id,
853                                    GValue* value,
854                                    GParamSpec* pspec)
855 {
856   InfGtkBrowserStore* store;
857   InfGtkBrowserStorePrivate* priv;
858   store = INF_GTK_BROWSER_STORE(object);
859   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
860   switch(prop_id)
861   {
862   case PROP_IO:
863     g_value_set_object(value, priv-&gt;io);
864     break;
865   case PROP_COMMUNICATION_MANAGER:
866     g_value_set_object(value, priv-&gt;communication_manager);
867     break;</b></font>
868   default:
869     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
870     break;
871   }
872 }
873 static GtkTreeModelFlags
874 inf_gtk_browser_store_tree_model_get_flags(GtkTreeModel* model)
875 {
876   return GTK_TREE_MODEL_ITERS_PERSIST;
877 }
878 static gint
879 inf_gtk_browser_store_tree_model_get_n_columns(GtkTreeModel* model)
880 {
881   return INF_GTK_BROWSER_MODEL_NUM_COLS;
882 }
883 static GType
884 inf_gtk_browser_store_tree_model_get_column_type(GtkTreeModel* model,
885                                                  gint index)
886 {
887   switch(index)
888   {
889   case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
890     return G_TYPE_POINTER;
891   case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
892     return INF_TYPE_DISCOVERY;
893   case INF_GTK_BROWSER_MODEL_COL_BROWSER:
894     return INFC_TYPE_BROWSER;
895   case INF_GTK_BROWSER_MODEL_COL_STATUS:
896     return INF_GTK_TYPE_BROWSER_MODEL_STATUS;
897   case INF_GTK_BROWSER_MODEL_COL_NAME:
898     return G_TYPE_STRING;
899   case INF_GTK_BROWSER_MODEL_COL_ERROR:
900     return G_TYPE_POINTER;
901   case INF_GTK_BROWSER_MODEL_COL_NODE:
902     return INF_TYPE_BROWSER_ITER;
903   default:
904     g_assert_not_reached();
905     return G_TYPE_INVALID;
906   }
907 }
908 static gboolean
909 inf_gtk_browser_store_tree_model_get_iter(GtkTreeModel* model,
910                                           GtkTreeIter* iter,
911                                           GtkTreePath* path)
912 {
913   InfGtkBrowserStorePrivate* priv;
914   InfGtkBrowserStoreItem* item;
915   InfBrowserIter browser_iter;
916   gint* indices;
917   guint i;
918   guint n;
919   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
920   if(gtk_tree_path_get_depth(path) == 0) return FALSE;
921   indices = gtk_tree_path_get_indices(path);
922   n = indices[0];
923   i = 0;
924   for(item = priv-&gt;first_item; item != NULL &amp;&amp; i &lt; n; item = item-&gt;next)
925     ++i;
926   if(item == NULL) return FALSE;
927   if(gtk_tree_path_get_depth(path) == 1)
928   {
929     iter-&gt;stamp = priv-&gt;stamp;
930     iter-&gt;user_data = item;
931     iter-&gt;user_data2 = GUINT_TO_POINTER(0);
932     iter-&gt;user_data3 = NULL;
933     return TRUE;
934   }
935   if(item-&gt;browser == NULL) return FALSE;
936   inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
937   for(n = 1; n &lt; (guint)gtk_tree_path_get_depth(path); ++ n)
938   {
939     if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
940       return FALSE;
941     if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
942       return FALSE;
943     if(browser_iter.node == item-&gt;missing)
944       ++indices[n];
945     for(i = 0; i &lt; (guint)indices[n]; ++ i)
946     {
947       if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
948         return FALSE;
949       if(browser_iter.node == item-&gt;missing)
950         ++indices[n];
951     }
952   }
953   iter-&gt;stamp = priv-&gt;stamp;
954   iter-&gt;user_data = item;
955   iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
956   iter-&gt;user_data3 = browser_iter.node;
957   return TRUE;
958 }
959 static void
960 inf_gtk_browser_store_tree_model_get_path_impl(InfGtkBrowserStore* store,
961                                                InfGtkBrowserStoreItem* item,
962                                                InfBrowserIter* iter,
963                                                GtkTreePath* path)
964 {
965   InfGtkBrowserStorePrivate* priv;
966   InfBrowserIter cur_iter;
967   InfGtkBrowserStoreItem* cur;
968   gboolean result;
969   guint n;
970   cur_iter = *iter;
971   if(inf_browser_get_parent(item-&gt;browser, &amp;cur_iter) == FALSE)
972   {
973     priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
974     n = 0;
975     for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
976       ++n;
977     gtk_tree_path_append_index(path, n);
978   }
979   else
980   {
981     inf_gtk_browser_store_tree_model_get_path_impl(
982       store,
983       item,
984       &amp;cur_iter,
985       path
986     );
987     result = inf_browser_get_child(item-&gt;browser, &amp;cur_iter);
988     g_assert(result == TRUE);
989     if(cur_iter.node == item-&gt;missing)
990     {
991       result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
992       g_assert(result == TRUE);
993     }
994     n = 0;
995     while(cur_iter.node_id != iter-&gt;node_id)
996     {
997       result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
998       g_assert(result == TRUE);
999       if(cur_iter.node == item-&gt;missing)
1000       {
1001         result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
1002         g_assert(result == TRUE);
1003       }
1004       ++n;
1005     }
1006     gtk_tree_path_append_index(path, n);
1007   }
1008 }
1009 static GtkTreePath*
1010 inf_gtk_browser_store_tree_model_get_path(GtkTreeModel* model,
1011                                           GtkTreeIter* iter)
1012 {
1013   InfGtkBrowserStorePrivate* priv;
1014   InfGtkBrowserStoreItem* item;
1015   InfGtkBrowserStoreItem* cur;
1016   GtkTreePath* path;
1017   InfBrowserIter browser_iter;
1018   guint n;
1019   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1020   g_assert(iter-&gt;stamp == priv-&gt;stamp);
1021   g_assert(iter-&gt;user_data != NULL);
1022   item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1023   path = gtk_tree_path_new();
1024   browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1025   browser_iter.node = iter-&gt;user_data3;
1026   if(browser_iter.node != NULL)
1027   {
1028     g_assert(item-&gt;browser != NULL);
1029     inf_gtk_browser_store_tree_model_get_path_impl(
1030       INF_GTK_BROWSER_STORE(model),
1031       item,
1032       &amp;browser_iter,
1033       path
1034     );
1035   }
1036   else
1037   {
1038     n = 0;
1039     for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
1040       ++n;
1041     gtk_tree_path_append_index(path, n);
1042   }
1043   return path;
1044 }
1045 static void
1046 inf_gtk_browser_store_tree_model_get_value(GtkTreeModel* model,
1047                                            GtkTreeIter* iter,
1048                                            gint column,
1049                                            GValue* value)
1050 {
1051   InfGtkBrowserStorePrivate* priv;
1052   InfGtkBrowserStoreItem* item;
1053   InfBrowserIter browser_iter;
1054   InfBrowserStatus browser_status;
1055   GError* error;
1056   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1057   g_assert(iter-&gt;stamp == priv-&gt;stamp);
1058   item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1059   browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1060   browser_iter.node = iter-&gt;user_data3;
1061   g_assert(
1062     item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1063     browser_iter.node != item-&gt;missing
1064   );
1065   switch(column)
1066   {
1067   case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
1068     g_value_init(value, G_TYPE_POINTER);
1069     g_value_set_pointer(value, item-&gt;info);
1070     break;
1071   case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
1072     g_value_init(value, G_TYPE_OBJECT);
1073     g_value_set_object(value, item-&gt;discovery);
1074     break;
1075   case INF_GTK_BROWSER_MODEL_COL_BROWSER:
1076     g_value_init(value, INF_TYPE_BROWSER);
1077     g_value_set_object(value, G_OBJECT(item-&gt;browser));
1078     break;
1079   case INF_GTK_BROWSER_MODEL_COL_STATUS:
1080     g_assert(browser_iter.node == NULL);     g_value_init(value, INF_GTK_TYPE_BROWSER_MODEL_STATUS);
1081     g_value_set_enum(value, item-&gt;status);
1082     break;
1083   case INF_GTK_BROWSER_MODEL_COL_NAME:
1084     g_value_init(value, G_TYPE_STRING);
1085     if(browser_iter.node == NULL)
1086     {
1087       g_value_set_string(value, item-&gt;name);
1088     }
1089     else
1090     {
1091       g_value_set_string(
1092         value,
1093         inf_browser_get_node_name(INF_BROWSER(item-&gt;browser), &amp;browser_iter)
1094       );
1095     }
1096     break;
1097   case INF_GTK_BROWSER_MODEL_COL_ERROR:
1098     if(browser_iter.node == NULL)
1099     {
1100       if(item-&gt;error != NULL)
1101       {
1102         error = item-&gt;error;
1103       }
1104       else if(item-&gt;browser != NULL)
1105       {
1106         g_object_get(
1107           G_OBJECT(item-&gt;browser),
1108           "status",
1109           &amp;browser_status,
1110           NULL
1111         );
1112         if(browser_status == INF_BROWSER_OPEN)
1113         {
1114           inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1115           error = g_hash_table_lookup(
1116             item-&gt;node_errors,
1117             GUINT_TO_POINTER(browser_iter.node_id)
1118           );
1119         }
1120         else
1121         {
1122           error = NULL;
1123         }
1124       }
1125       else
1126       {
1127         error = NULL;
1128       }
1129     }
1130     else
1131     {
1132       g_assert(item-&gt;browser != NULL);
1133       g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
1134       g_assert(browser_status == INF_BROWSER_OPEN);
1135       error = g_hash_table_lookup(
1136         item-&gt;node_errors,
1137         GUINT_TO_POINTER(browser_iter.node_id)
1138       );
1139     }
1140     g_value_init(value, G_TYPE_POINTER);
1141     g_value_set_pointer(value, error);
1142     break;
1143   case INF_GTK_BROWSER_MODEL_COL_NODE:
1144     g_assert(item-&gt;browser != NULL);
1145     g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
1146     g_assert(browser_status == INF_BROWSER_OPEN);
1147     if(browser_iter.node == NULL)
1148       inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1149     g_value_init(value, INF_TYPE_BROWSER_ITER);
1150     g_value_set_boxed(value, &amp;browser_iter);
1151     break;
1152   default:
1153     g_assert_not_reached();
1154     break;
1155   }
1156 }
1157 static gboolean
1158 inf_gtk_browser_store_tree_model_iter_next(GtkTreeModel* model,
1159                                            GtkTreeIter* iter)
1160 {
1161   InfGtkBrowserStorePrivate* priv;
1162   InfGtkBrowserStoreItem* item;
1163   InfBrowserIter browser_iter;
1164   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1165   g_assert(iter-&gt;stamp == priv-&gt;stamp);
1166   item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1167   browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1168   browser_iter.node = iter-&gt;user_data3;
1169   if(browser_iter.node == NULL)
1170   {
1171     if(item-&gt;next == NULL)
1172       return FALSE;
1173     iter-&gt;user_data = item-&gt;next;
1174     return TRUE;
1175   }
1176   else
1177   {
1178     g_assert(browser_iter.node != item-&gt;missing);
1179     if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
1180       return FALSE;
1181     if(browser_iter.node == item-&gt;missing)
1182       if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
1183         return FALSE;
1184     iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
1185     iter-&gt;user_data3 = browser_iter.node;
1186     return TRUE;
1187   }
1188 }
1189 static gboolean
1190 inf_gtk_browser_store_tree_model_iter_children(GtkTreeModel* model,
1191                                                GtkTreeIter* iter,
1192                                                GtkTreeIter* parent)
1193 {
1194   InfGtkBrowserStorePrivate* priv;
1195   InfGtkBrowserStoreItem* item;
1196   InfBrowserStatus browser_status;
1197   InfBrowserIter browser_iter;
1198   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1199   if(parent == NULL)
1200   {
1201     if(priv-&gt;first_item == NULL)
1202       return FALSE;
1203     iter-&gt;stamp = priv-&gt;stamp;
1204     iter-&gt;user_data = priv-&gt;first_item;
1205     iter-&gt;user_data2 = GUINT_TO_POINTER(0);
1206     iter-&gt;user_data3 = NULL;
1207     return TRUE;
1208   }
1209   else
1210   {
1211     g_assert(parent-&gt;stamp == priv-&gt;stamp);
1212     item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
1213     if(item-&gt;browser == NULL)
1214       return FALSE;
1215     g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;browser_status, NULL);
1216     if(browser_status != INF_BROWSER_OPEN)
1217       return FALSE;
1218     browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);
1219     if(browser_iter.node_id == 0)
1220       inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1221     else
1222       browser_iter.node = parent-&gt;user_data3;
1223     g_assert(
1224       item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1225       browser_iter.node != item-&gt;missing
1226     );
1227     if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
1228       return FALSE;
1229     if(!inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter))
1230       return FALSE;
1231     if(!inf_browser_get_explored(item-&gt;browser, &amp;browser_iter))
1232       return FALSE;
1233     if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
1234       return FALSE;
1235     if(browser_iter.node == item-&gt;missing)
1236       if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
1237         return FALSE;
1238     iter-&gt;stamp = priv-&gt;stamp;
1239     iter-&gt;user_data = item;
1240     iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
1241     iter-&gt;user_data3 = browser_iter.node;
1242     return TRUE;
1243   }
1244 }
1245 static gboolean
1246 inf_gtk_browser_store_tree_model_iter_has_child(GtkTreeModel* model,
1247                                                 GtkTreeIter* iter)
1248 {
1249   InfGtkBrowserStorePrivate* priv;
1250   InfGtkBrowserStoreItem* item;
1251   InfBrowserStatus status;
1252   InfBrowserIter browser_iter;
1253   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1254   g_assert(iter-&gt;stamp == priv-&gt;stamp);
1255   item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1256   if(item-&gt;browser == NULL) return FALSE;
1257   browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1258   browser_iter.node = iter-&gt;user_data3;
1259   g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
1260   if(status != INF_BROWSER_OPEN)
1261     return FALSE;
1262   if(browser_iter.node == NULL)
1263     inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1264   g_assert(
1265     item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1266     browser_iter.node != item-&gt;missing
1267   );
1268   if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
1269     return FALSE;
1270   if(inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter) == FALSE)
1271     return FALSE;
1272   if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
1273     return FALSE;
1274   if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
1275     return FALSE;
1276   if(browser_iter.node == item-&gt;missing)
1277     if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
1278       return FALSE;
1279   return TRUE;
1280 }
1281 static gint
1282 inf_gtk_browser_store_tree_model_iter_n_children(GtkTreeModel* model,
1283                                                  GtkTreeIter* iter)
1284 {
1285   InfGtkBrowserStorePrivate* priv;
1286   InfGtkBrowserStoreItem* item;
1287   InfGtkBrowserStoreItem* cur;
1288   InfBrowserIter browser_iter;
1289   gboolean result;
1290   guint n;
1291   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1292   g_assert(iter == NULL || iter-&gt;stamp == priv-&gt;stamp);
1293   if(iter == NULL)
1294   {
1295     n = 0;
1296     for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
1297       ++n;
1298     return n;
1299   }
1300   else
1301   {
1302     item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
1303     browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
1304     browser_iter.node = iter-&gt;user_data3;
1305     if(browser_iter.node == NULL)
1306       inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1307     g_assert(
1308       item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1309       browser_iter.node != item-&gt;missing
1310     );
1311     if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
1312       return 0;
1313     n = 0;
1314     for(result = inf_browser_get_child(item-&gt;browser, &amp;browser_iter);
1315         result == TRUE;
1316         result = inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
1317     {
1318       if(browser_iter.node != item-&gt;missing)
1319         ++n;
1320     }
1321     return n;
1322   }
1323 }
1324 static gboolean
1325 inf_gtk_browser_store_tree_model_iter_nth_child(GtkTreeModel* model,
1326                                                 GtkTreeIter* iter,
1327                                                 GtkTreeIter* parent,
1328                                                 gint n)
1329 {
1330   InfGtkBrowserStorePrivate* priv;
1331   InfGtkBrowserStoreItem* item;
1332   InfGtkBrowserStoreItem* cur;
1333   InfBrowserIter browser_iter;
1334   guint i;
1335   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1336   if(parent == NULL)
1337   {
1338     cur = priv-&gt;first_item;
1339     if(cur == NULL) return FALSE;
1340     for(i = 0; i &lt; (guint)n; ++ i)
1341     {
1342       cur = cur-&gt;next;
1343       if(cur == NULL) return FALSE;
1344     }
1345     iter-&gt;stamp = priv-&gt;stamp;
1346     iter-&gt;user_data = cur;
1347     iter-&gt;user_data2 = GUINT_TO_POINTER(0);
1348     iter-&gt;user_data3 = NULL;
1349     return TRUE;
1350   }
1351   else
1352   {
1353     g_assert(parent-&gt;stamp == priv-&gt;stamp);
1354     item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
1355     browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);
1356     if(browser_iter.node_id == 0)
1357       inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
1358     else
1359       browser_iter.node = parent-&gt;user_data3;
1360     g_assert(
1361       item-&gt;missing == NULL || browser_iter.node_id == 0 ||
1362       browser_iter.node != item-&gt;missing
1363     );
1364     if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
1365       return FALSE;
1366     if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
1367       return FALSE;
1368     if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
1369       return FALSE;
1370     if(browser_iter.node == item-&gt;missing)
1371       ++n;
1372     for(i = 0; i &lt; (guint)n; ++ i)
1373     {
1374       if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
1375         return FALSE;
1376       if(browser_iter.node == item-&gt;missing)
1377         ++n;
1378     }
1379     iter-&gt;stamp = priv-&gt;stamp;
1380     iter-&gt;user_data = item;
1381     iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
1382     iter-&gt;user_data3 = browser_iter.node;
1383     return TRUE;
1384   }
1385 }
1386 static gboolean
1387 inf_gtk_browser_store_tree_model_iter_parent(GtkTreeModel* model,
1388                                              GtkTreeIter* iter,
1389                                              GtkTreeIter* child)
1390 {
1391   InfGtkBrowserStorePrivate* priv;
1392   InfGtkBrowserStoreItem* item;
1393   InfBrowserIter browser_iter;
1394   gboolean result;
1395   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1396   g_assert(child-&gt;stamp == priv-&gt;stamp);
1397   item = (InfGtkBrowserStoreItem*)child-&gt;user_data;
1398   browser_iter.node_id = GPOINTER_TO_UINT(child-&gt;user_data2);
1399   browser_iter.node = child-&gt;user_data3;
1400   if(browser_iter.node == NULL)
1401     return FALSE;
1402   g_assert(browser_iter.node != item-&gt;missing);
1403   result = inf_browser_get_parent(item-&gt;browser, &amp;browser_iter);
1404   g_assert(result == TRUE);
1405   g_assert(browser_iter.node != item-&gt;missing);
1406   iter-&gt;stamp = priv-&gt;stamp;
1407   iter-&gt;user_data = item;
1408   iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
1409   iter-&gt;user_data3 = browser_iter.node;
1410   if(browser_iter.node_id == 0)
1411     iter-&gt;user_data3 = NULL;
1412   return TRUE;
1413 }
1414 static void
1415 inf_gtk_browser_store_browser_model_set_browser(InfGtkBrowserModel* model,
1416                                                 GtkTreePath* path,
1417                                                 GtkTreeIter* tree_iter,
1418                                                 InfBrowser* old_browser,
1419                                                 InfBrowser* new_browser)
1420 {
1421   InfGtkBrowserStorePrivate* priv;
1422   InfGtkBrowserStoreItem* item;
1423   InfBrowserIter iter;
1424   guint n;
1425   gboolean had_children;
1426   InfBrowserStatus status;
1427   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1428   had_children = FALSE;
1429   item = (InfGtkBrowserStoreItem*)tree_iter-&gt;user_data;
1430   g_assert(tree_iter-&gt;user_data3 == NULL);
1431   if(item-&gt;browser != NULL)
1432   {
1433     g_assert(item-&gt;browser == old_browser);
1434     g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
1435     if(status == INF_BROWSER_OPEN)
1436     {
1437       inf_browser_get_root(item-&gt;browser, &amp;iter);
1438       if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
1439          inf_browser_get_child(item-&gt;browser, &amp;iter))
1440       {
1441         n = 1;
1442         while(inf_browser_get_next(item-&gt;browser, &amp;iter))
1443           ++ n;
1444         gtk_tree_path_append_index(path, n);
1445         for(; n &gt; 0; -- n)
1446         {
1447           had_children = TRUE;
1448           gtk_tree_path_prev(path);
1449           gtk_tree_model_row_deleted(GTK_TREE_MODEL(model), path);
1450         }
1451         gtk_tree_path_up(path);
1452       }
1453     }
1454     while(item-&gt;requests != NULL)
1455       inf_gtk_browser_store_item_request_remove(item, item-&gt;requests-&gt;data);
1456     g_hash_table_remove_all(item-&gt;node_errors);
1457     inf_signal_handlers_disconnect_by_func(
1458       G_OBJECT(item-&gt;browser),
1459       G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
1460       model
1461     );
1462     inf_signal_handlers_disconnect_by_func(
1463       G_OBJECT(item-&gt;browser),
1464       G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
1465       model
1466     );
1467     inf_signal_handlers_disconnect_by_func(
1468       G_OBJECT(item-&gt;browser),
1469       G_CALLBACK(inf_gtk_browser_store_node_added_cb),
1470       model
1471     );
1472     inf_signal_handlers_disconnect_by_func(
1473       G_OBJECT(item-&gt;browser),
1474       G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
1475       model
1476     );
1477     inf_signal_handlers_disconnect_by_func(
1478       G_OBJECT(item-&gt;browser),
1479       G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
1480       model
1481     );
1482     inf_signal_handlers_disconnect_by_func(
1483       G_OBJECT(item-&gt;browser),
1484       G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
1485       model
1486     );
1487     g_object_unref(G_OBJECT(item-&gt;browser));
1488   }
1489   item-&gt;browser = NULL;
1490   if(had_children)
1491   {
1492     gtk_tree_model_row_has_child_toggled(
1493       GTK_TREE_MODEL(model),
1494       path,
1495       tree_iter
1496     );
1497   }
1498   item-&gt;browser = new_browser;
1499   if(new_browser != NULL)
1500   {
1501     g_object_ref(new_browser);
1502     g_signal_connect(
1503       G_OBJECT(item-&gt;browser),
1504       "error",
1505       G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
1506       model
1507     );
1508     g_signal_connect(
1509       G_OBJECT(item-&gt;browser),
1510       "notify::status",
1511       G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
1512       model
1513     );
1514     g_signal_connect_after(
1515       G_OBJECT(item-&gt;browser),
1516       "node-added",
1517       G_CALLBACK(inf_gtk_browser_store_node_added_cb),
1518       model
1519     );
1520     g_signal_connect_after(
1521       G_OBJECT(item-&gt;browser),
1522       "node-removed",
1523       G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
1524       model
1525     );
1526     g_signal_connect_after(
1527       G_OBJECT(item-&gt;browser),
1528       "begin-request::explore-node",
1529       G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
1530       model
1531     );
1532     g_signal_connect_after(
1533       G_OBJECT(item-&gt;browser),
1534       "begin-request::subscribe-session",
1535       G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
1536       model
1537     );
1538   }
1539   if(item-&gt;browser == NULL &amp;&amp; item-&gt;info == NULL &amp;&amp;
1540      (item-&gt;error == NULL || item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR))
1541   {
1542     g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR);
1543     if(item-&gt;error != NULL)
1544     {
1545       g_error_free(item-&gt;error);
1546       item-&gt;error = NULL;
1547     }
1548     item-&gt;status = INF_GTK_BROWSER_MODEL_INVALID;
1549   }
1550   else if(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR)
1551   {
1552     if(item-&gt;browser != NULL)
1553     {
1554       g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
1555       switch(status)
1556       {
1557       case INF_BROWSER_CLOSED:
1558         item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
1559         break;
1560       case INF_BROWSER_OPENING:
1561         item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
1562         break;
1563       case INF_BROWSER_OPEN:
1564         item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
1565         break;
1566       default:
1567         g_assert_not_reached();
1568         break;
1569       }
1570     }
1571     else
1572     {
1573       g_assert(item-&gt;info != NULL);
1574       item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
1575     }
1576   }
1577   else
1578   {
1579     g_assert(item-&gt;error != NULL);
1580   }
1581   gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, tree_iter);
1582   if(item-&gt;browser != NULL &amp;&amp; item-&gt;status == INF_GTK_BROWSER_MODEL_CONNECTED)
1583   {
1584     inf_browser_get_root(item-&gt;browser, &amp;iter);
1585     if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
1586        inf_browser_get_child(item-&gt;browser, &amp;iter))
1587     {
1588       gtk_tree_model_row_has_child_toggled(
1589         GTK_TREE_MODEL(model),
1590         path,
1591         tree_iter
1592       );
1593     }
1594   }
1595 }
1596 static void
1597 inf_gtk_browser_store_browser_model_resolve(InfGtkBrowserModel* model,
1598                                             InfDiscovery* discovery,
1599                                             InfDiscoveryInfo* info)
1600 {
1601   InfGtkBrowserStorePrivate* priv;
1602   InfGtkBrowserStoreItem* item;
1603   GtkTreeIter tree_iter;
1604   GtkTreePath* path;
1605   g_assert(INF_GTK_IS_BROWSER_STORE(model));
1606   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1607   item = inf_gtk_browser_store_find_item_by_discovery_info(
1608     INF_GTK_BROWSER_STORE(model),
1609     info
1610   );
1611   g_assert(item != NULL);
1612   g_assert(
1613     item-&gt;status == INF_GTK_BROWSER_MODEL_DISCOVERED ||
1614     item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR
1615   );
1616   if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
1617   {
1618     g_assert(item-&gt;error != NULL);
1619     g_error_free(item-&gt;error);
1620     item-&gt;error = NULL;
1621     item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
1622   }
1623   else
1624   {
1625     item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
1626   }
1627   tree_iter.stamp = priv-&gt;stamp;
1628   tree_iter.user_data = item;
1629   tree_iter.user_data2 = GUINT_TO_POINTER(0);
1630   tree_iter.user_data3 = NULL;
1631   path = gtk_tree_model_get_path(GTK_TREE_MODEL(model), &amp;tree_iter);
1632   gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, &amp;tree_iter);
1633   gtk_tree_path_free(path);
1634   inf_discovery_resolve(
1635     discovery,
1636     info,
1637     inf_gtk_browser_store_resolv_complete_func,
1638     model
1639   );
1640 }
1641 static gboolean
1642 inf_gtk_browser_store_browser_iter_to_tree_iter(InfGtkBrowserModel* model,
1643                                                 InfBrowser* browser,
1644                                                 const InfBrowserIter* iter,
1645                                                 GtkTreeIter* tree_iter)
1646 {
1647   InfGtkBrowserStorePrivate* priv;
1648   InfGtkBrowserStoreItem* item;
1649   g_assert(INF_GTK_IS_BROWSER_STORE(model));
1650   priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
1651   item = inf_gtk_browser_store_find_item_by_browser(
1652     INF_GTK_BROWSER_STORE(model),
1653     browser
1654   );
1655   if(item == NULL || (iter != NULL &amp;&amp; item-&gt;missing == iter-&gt;node))
1656     return FALSE;
1657   tree_iter-&gt;stamp = priv-&gt;stamp;
1658   tree_iter-&gt;user_data = item;
1659   if(iter != NULL &amp;&amp; iter-&gt;node_id != 0)
1660   {
1661     tree_iter-&gt;user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
1662     tree_iter-&gt;user_data3 = iter-&gt;node;
1663   }
1664   else
1665   {
1666     tree_iter-&gt;user_data2 = 0;
1667     tree_iter-&gt;user_data3 = NULL;
1668   }
1669   return TRUE;
1670 }
1671 static void
1672 inf_gtk_browser_store_class_init(InfGtkBrowserStoreClass* browser_store_class)
1673 {
1674   GObjectClass* object_class;
1675   object_class = G_OBJECT_CLASS(browser_store_class);
1676   object_class-&gt;dispose = inf_gtk_browser_store_dispose;
1677   object_class-&gt;set_property = inf_gtk_browser_store_set_property;
1678   object_class-&gt;get_property = inf_gtk_browser_store_get_property;
1679   g_object_class_install_property(
1680     object_class,
1681     PROP_IO,
1682     g_param_spec_object(
1683       "io",
1684       "IO",
1685       "The IO object used for the created browsers to schedule timeouts",
1686       INF_TYPE_IO,
1687       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1688     )
1689   );
1690   g_object_class_install_property(
1691     object_class,
1692     PROP_COMMUNICATION_MANAGER,
1693     g_param_spec_object(
1694       "communication-manager",
1695       "Communication manager", 
1696       "The communication manager used for browsing remote directories",
1697       INF_COMMUNICATION_TYPE_MANAGER,
1698       G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
1699     )
1700   );
1701 }
1702 static void
1703 inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface)
1704 {
1705   iface-&gt;get_flags = inf_gtk_browser_store_tree_model_get_flags;
1706   iface-&gt;get_n_columns = inf_gtk_browser_store_tree_model_get_n_columns;
1707   iface-&gt;get_column_type = inf_gtk_browser_store_tree_model_get_column_type;
1708   iface-&gt;get_iter = inf_gtk_browser_store_tree_model_get_iter;
1709   iface-&gt;get_path = inf_gtk_browser_store_tree_model_get_path;
1710   iface-&gt;get_value = inf_gtk_browser_store_tree_model_get_value;
1711   iface-&gt;iter_next = inf_gtk_browser_store_tree_model_iter_next;
1712   iface-&gt;iter_children = inf_gtk_browser_store_tree_model_iter_children;
1713   iface-&gt;iter_has_child = inf_gtk_browser_store_tree_model_iter_has_child;
1714   iface-&gt;iter_n_children = inf_gtk_browser_store_tree_model_iter_n_children;
1715   iface-&gt;iter_nth_child = inf_gtk_browser_store_tree_model_iter_nth_child;
1716   iface-&gt;iter_parent = inf_gtk_browser_store_tree_model_iter_parent;
1717 }
1718 static void
1719 inf_gtk_browser_store_browser_model_iface_init(
1720   InfGtkBrowserModelInterface* iface)
1721 {
1722   iface-&gt;set_browser = inf_gtk_browser_store_browser_model_set_browser;
1723   iface-&gt;resolve = inf_gtk_browser_store_browser_model_resolve;
1724   iface-&gt;browser_iter_to_tree_iter =
1725     inf_gtk_browser_store_browser_iter_to_tree_iter;
1726 }
1727 InfGtkBrowserStore*
1728 inf_gtk_browser_store_new(InfIo* io,
1729                           InfCommunicationManager* comm_manager)
1730 {
1731   GObject* object;
1732   object = g_object_new(
1733     INF_GTK_TYPE_BROWSER_STORE,
1734     "io", io,
1735     "communication-manager", comm_manager,
1736     NULL
1737   );
1738   return INF_GTK_BROWSER_STORE(object);
1739 }
1740 void
1741 inf_gtk_browser_store_add_discovery(InfGtkBrowserStore* store,
1742                                     InfDiscovery* discovery)
1743 {
1744   InfGtkBrowserStorePrivate* priv;
1745   GSList* discovered;
1746   GSList* item;
1747   InfDiscoveryInfo* info;
1748   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1749   g_return_if_fail(INF_IS_DISCOVERY(discovery));
1750   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
1751   g_return_if_fail(g_slist_find(priv-&gt;discoveries, discovery) == NULL);
1752   g_object_ref(G_OBJECT(discovery));
1753   priv-&gt;discoveries = g_slist_prepend(priv-&gt;discoveries, discovery);
1754   g_signal_connect(
1755     G_OBJECT(discovery),
1756     "discovered",
1757     G_CALLBACK(inf_gtk_browser_store_discovered_cb),
1758     store
1759   );
1760   g_signal_connect(
1761     G_OBJECT(discovery),
1762     "undiscovered",
1763     G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
1764     store
1765   );
1766   discovered = inf_discovery_get_discovered(discovery, "_infinote._tcp");
1767   for(item = discovered; item != NULL; item = g_slist_next(item))
1768   {
1769     info = (InfDiscoveryInfo*)item-&gt;data;
1770     inf_gtk_browser_store_add_item_by_browser(
1771       store,
1772       discovery,
1773       info,
1774       NULL,
1775       inf_discovery_info_get_service_name(discovery, info)
1776     );
1777   }
1778   g_slist_free(discovered);
1779   inf_discovery_discover(discovery, "_infinote._tcp");
1780 }
1781 InfBrowser*
1782 inf_gtk_browser_store_add_connection(InfGtkBrowserStore* store,
1783                                      InfXmlConnection* connection,
1784                                      const gchar* name)
1785 {
1786   InfGtkBrowserStorePrivate* priv;
1787   InfGtkBrowserStoreItem* item;
1788   gchar* remote_id;
1789   g_return_val_if_fail(INF_GTK_IS_BROWSER_STORE(store), NULL);
1790   g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), NULL);
1791   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
1792   item = inf_gtk_browser_store_find_item_by_connection(store, connection);
1793   if(item == NULL)
1794   {
1795     if(name == NULL)
1796     {
1797       g_object_get(G_OBJECT(connection), "remote-id", &amp;remote_id, NULL);
1798       item = inf_gtk_browser_store_add_item_by_connection(
1799         store,
1800         NULL,
1801         NULL,
1802         connection,
1803         remote_id
1804       );
1805     }
1806     else
1807     {
1808       item = inf_gtk_browser_store_add_item_by_connection(
1809         store,
1810         NULL,
1811         NULL,
1812         connection,
1813         g_strdup(name)
1814       );
1815     }
1816   }
1817   return item-&gt;browser;
1818 }
1819 void
1820 inf_gtk_browser_store_add_browser(InfGtkBrowserStore* store,
1821                                   InfBrowser* browser,
1822                                   const gchar* name)
1823 {
1824   InfGtkBrowserStorePrivate* priv;
1825   InfGtkBrowserStoreItem* item;
1826   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1827   g_return_if_fail(INF_IS_BROWSER(browser));
1828   g_return_if_fail(name != NULL);
1829   priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
1830   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
1831   if(item == NULL)
1832   {
1833     inf_gtk_browser_store_add_item_by_browser(
1834       store,
1835       NULL,
1836       NULL,
1837       browser,
1838       g_strdup(name)
1839     );
1840   }
1841 }
1842 void
1843 inf_gtk_browser_store_remove_browser(InfGtkBrowserStore* store,
1844                                      InfBrowser* browser)
1845 {
1846   InfGtkBrowserStoreItem* item;
1847   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1848   g_return_if_fail(INF_IS_BROWSER(browser));
1849   item = inf_gtk_browser_store_find_item_by_browser(store, browser);
1850   g_return_if_fail(item != NULL);
1851   inf_gtk_browser_store_remove_item (store, item);
1852 }
1853 void
1854 inf_gtk_browser_store_remove_connection(InfGtkBrowserStore* store,
1855                                         InfXmlConnection* connection)
1856 {
1857   InfGtkBrowserStoreItem* item;
1858   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1859   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1860   item = inf_gtk_browser_store_find_item_by_connection(store, connection);
1861   g_return_if_fail(item != NULL);
1862   inf_gtk_browser_store_remove_item (store, item);
1863 }
1864 void
1865 inf_gtk_browser_store_clear_connection_error(InfGtkBrowserStore* store,
1866                                              InfXmlConnection* connection)
1867 {
1868   InfGtkBrowserStoreItem* item;
1869   InfBrowserStatus status;
1870   GtkTreeIter iter;
1871   GtkTreePath* path;
1872   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1873   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1874   item = inf_gtk_browser_store_find_item_by_connection(store, connection);
1875   g_return_if_fail(item != NULL);
1876   if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
1877   {
1878     g_assert(item-&gt;error != NULL);
1879     g_error_free(item-&gt;error);
1880     item-&gt;error = NULL;
1881     if(item-&gt;browser != NULL)
1882     {
1883       g_object_get(G_OBJECT(item-&gt;browser), "status", &amp;status, NULL);
1884       switch(status)
1885       {
1886       case INF_BROWSER_CLOSED:
1887         item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
1888         break;
1889       case INF_BROWSER_OPENING:
1890         item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
1891         break;
1892       case INF_BROWSER_OPEN:
1893         item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
1894         break;
1895       default:
1896         g_assert_not_reached();
1897         break;
1898       }
1899     }
1900     else if(item-&gt;info != NULL)
1901     {
1902       item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
1903     }
1904     else
1905     {
1906       g_assert_not_reached();
1907     }
1908     iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
1909     iter.user_data = item;
1910     iter.user_data2 = GUINT_TO_POINTER(0);
1911     iter.user_data3 = NULL;
1912     path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
1913     gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
1914     gtk_tree_path_free (path);
1915   }
1916 }
1917 void
1918 inf_gtk_browser_store_set_connection_name(InfGtkBrowserStore* store,
1919                                           InfXmlConnection* connection,
1920                                           const gchar* name)
1921 {
1922   InfGtkBrowserStoreItem* item;
1923   GtkTreeIter iter;
1924   GtkTreePath* path;
1925   g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
1926   g_return_if_fail(INF_IS_XML_CONNECTION(connection));
1927   g_return_if_fail(name != NULL);
1928   item = inf_gtk_browser_store_find_item_by_connection(store, connection);
1929   g_return_if_fail(item != NULL);
1930   g_free (item-&gt;name);
1931   item-&gt;name = g_strdup(name);
1932   iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
1933   iter.user_data = item;
1934   iter.user_data2 = GUINT_TO_POINTER(0);
1935   iter.user_data3 = NULL;
1936   path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
1937   gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
1938   gtk_tree_path_free(path);
1939 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
