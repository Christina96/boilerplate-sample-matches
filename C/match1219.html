<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for inf-text-gtk-view.c & inf-gtk-browser-store.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for inf-text-gtk-view.c & inf-gtk-browser-store.c
      </h3>
      <h1 align="center">
        8.8%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>inf-text-gtk-view.c (11.843712%)<TH>inf-gtk-browser-store.c (7.0802917%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1219-0.html#0',2,'match1219-1.html#0',3)" NAME="0">(1672-1700)<TD><A HREF="javascript:ZweiFrames('match1219-0.html#0',2,'match1219-1.html#0',3)" NAME="0">(1130-1158)</A><TD ALIGN=center><FONT COLOR="#ff0000">21</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match1219-0.html#1',2,'match1219-1.html#1',3)" NAME="1">(52-121)<TD><A HREF="javascript:ZweiFrames('match1219-0.html#1',2,'match1219-1.html#1',3)" NAME="1">(39-95)</A><TD ALIGN=center><FONT COLOR="#e60000">19</FONT>
<TR><TD BGCOLOR="#980517"><FONT COLOR="#980517">-</FONT><TD><A HREF="javascript:ZweiFrames('match1219-0.html#2',2,'match1219-1.html#2',3)" NAME="2">(1296-1328)<TD><A HREF="javascript:ZweiFrames('match1219-0.html#2',2,'match1219-1.html#2',3)" NAME="2">(328-356)</A><TD ALIGN=center><FONT COLOR="#ce0000">17</FONT>
<TR><TD BGCOLOR="#53858b"><FONT COLOR="#53858b">-</FONT><TD><A HREF="javascript:ZweiFrames('match1219-0.html#3',2,'match1219-1.html#3',3)" NAME="3">(1744-1770)<TD><A HREF="javascript:ZweiFrames('match1219-0.html#3',2,'match1219-1.html#3',3)" NAME="3">(1162-1188)</A><TD ALIGN=center><FONT COLOR="#c20000">16</FONT>
<TR><TD BGCOLOR="#6cc417"><FONT COLOR="#6cc417">-</FONT><TD><A HREF="javascript:ZweiFrames('match1219-0.html#4',2,'match1219-1.html#4',3)" NAME="4">(1785-1800)<TD><A HREF="javascript:ZweiFrames('match1219-0.html#4',2,'match1219-1.html#4',3)" NAME="4">(702-730)</A><TD ALIGN=center><FONT COLOR="#910000">12</FONT>
<TR><TD BGCOLOR="#151b8d"><FONT COLOR="#151b8d">-</FONT><TD><A HREF="javascript:ZweiFrames('match1219-0.html#5',2,'match1219-1.html#5',3)" NAME="5">(1014-1033)<TD><A HREF="javascript:ZweiFrames('match1219-0.html#5',2,'match1219-1.html#5',3)" NAME="5">(415-426)</A><TD ALIGN=center><FONT COLOR="#910000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-text-gtk-view.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* infinote - Collaborative notetaking application
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/**
 * SECTION:inf-text-gtk-view
 * @title: InfTextGtkView
 * @short_description: Drawing remote cursors and selections in a #GtkTextView
 * @include: libinftextgtk/inf-text-gtk-view.h
 * @see_also: #InfTextGtkBuffer, #InfTextGtkViewport
 * @stability: Unstable
 *
 * #InfTextGtkView is a helper object which, as long as it is alive, draws
 * the cursor position, selected text of remote users into a #GtkTextView
 * widget. It can also highlight the current line of a remote user in a
 * similar way the #GtkSourceView widget can highlight the current line of
 * the local user.
 *
 * This functionality was not implemented by subclassing #GtkTextView such
 * that it can also be used with existing subclasses, such as #GtkSourceView.
 *
 * With the function inf_text_gtk_view_set_active_user() the local
 * #InfTextUser who is editing the text can be set, if there is any. The
 * insertion position, seleceted text or current line are not drawn for this
 * user, since the normal #GtkTextView takes care of that already. This
 * assumes the local user cursor position and selection is synchronized to the
 * corresponding #InfTextUser properties, which is automatically the case when
 * a #InfTextGtkBuffer is used for the buffer the #GtkTextView is displaying.
 *
 * See #InfTextGtkViewport for drawing a marker at remote users' location into
 * the scrollbar.
 */	

#include &lt;libinftextgtk/inf-text-gtk-view.h&gt;
<A NAME="1"></A>#include &lt;libinfinity/inf-signals.h&gt;
#include &lt;gdk/gdk.h&gt;

<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1219-1.html#1',3,'match1219-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>typedef struct _InfTextGtkViewUser InfTextGtkViewUser;
struct _InfTextGtkViewUser {
  InfTextGtkView* view;
  InfTextUser* user;
  gboolean cursor_visible;
  InfIoTimeout* timeout; /* TODO: Use glib for that; remove InfIo property */
  guint revalidate_idle;

  /* All in buffer coordinates: */

  /* The rectangular area occupied by the cursor */
  GdkRectangle cursor_rect;
  /* The position and height of the selection bound. width is ignored. */
  GdkRectangle selection_bound_rect;

  /* Current line */
  gint line_y;
  gint line_height;
};

/* Helper struct for redrawing selection area */
typedef struct _InfTextGtkViewUserToggle InfTextGtkViewUserToggle;
struct _InfTextGtkViewUserToggle {
  /* User toggled on or off at this point */
  InfTextGtkViewUser* user;
  /* Position of the toggle */
  guint pos;
  /* NULL if this toggles on, or the corresponding on
   * toggle if it toggles off. */
  InfTextGtkViewUserToggle* on_toggle;
  /* Position in textview, in window coordinates */
  gint x;
  gint y;
};

typedef struct _InfTextGtkViewPrivate InfTextGtkViewPrivate;
struct _InfTextGtkViewPrivate {
  InfIo* io;
  GtkTextView* textview;
  InfUserTable* user_table;
  InfTextUser* active_user;
  GSList* users;
  
  gboolean show_remote_cursors;
  gboolean show_remote_selections;
  gboolean show_remote_current_lines;
};

enum {
  PROP_0,

  /* construct only */
  PROP_IO,
  PROP_VIEW,
  PROP_USER_TABLE,

  /* read/write */
  PROP_ACTIVE_USER,
  
  PROP_SHOW_REMOTE_CURSORS,
  PROP_SHOW_REMOTE_SELECTIONS,
  PROP_SHOW_REMOTE_CURRENT_LINES
};

#define INF_TEXT_GTK_VIEW_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_TEXT_GTK_TYPE_VIEW, InfTextGtkViewPrivate))

G_DEFINE_TYPE_WITH_CODE(InfTextGtkView, inf_text_gtk_view, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfTextGtkView))

static InfTextGtkViewUser*</B></FONT>
inf_text_gtk_view_find_user(InfTextGtkView* view,
                            InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  GSList* item;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    if( ((InfTextGtkViewUser*)item-&gt;data)-&gt;user == user)
      return (InfTextGtkViewUser*)item-&gt;data;

  return NULL;
}

/* Compute cursor_rect, selection_bound_rect */
static void
inf_text_gtk_view_user_compute_user_area(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GtkTextIter iter;
  gfloat cursor_aspect_ratio;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  gtk_widget_style_get(
    GTK_WIDGET(priv-&gt;textview),
    &quot;cursor-aspect-ratio&quot;, &amp;cursor_aspect_ratio,
    NULL
  );

  gtk_text_buffer_get_iter_at_offset(
    gtk_text_view_get_buffer(priv-&gt;textview),
    &amp;iter,
    inf_text_user_get_caret_position(view_user-&gt;user)
  );

  /* Find current line */
  gtk_text_view_get_line_yrange(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;line_y,
    &amp;view_user-&gt;line_height
  );

  /* TODO: We don't need the cursor rect for show-remote-current-lines, and
   * we don't need the selection rect for show-remote-cursors and
   * show-remote-current-lines. So we might not even want to compute them in
   * if those are disabled. */

  /* Find cursor position */
  gtk_text_view_get_iter_location(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;cursor_rect
  );

  view_user-&gt;cursor_rect.width = MAX(
    (int)(view_user-&gt;cursor_rect.height * cursor_aspect_ratio),
    1
  );

  /* Find selection bound */
  gtk_text_iter_forward_chars(
    &amp;iter,
    inf_text_user_get_selection_length(view_user-&gt;user)
  );

  gtk_text_view_get_iter_location(
    priv-&gt;textview,
    &amp;iter,
    &amp;view_user-&gt;selection_bound_rect
  );

  view_user-&gt;selection_bound_rect.width = MAX(
    (int)(view_user-&gt;selection_bound_rect.height * cursor_aspect_ratio),
    1
  );
}

static guint
inf_text_gtk_view_get_left_margin(GtkTextView* view)
{
  GtkAdjustment* hadjustment;
  gint margin;
  gint hadj;

  hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));

  margin = gtk_text_view_get_left_margin(view);
  if(!hadjustment) return margin;

  hadj = gtk_adjustment_get_value(hadjustment);
  if(hadj &lt; margin) return margin - hadj;

  return 0;
}

static guint
inf_text_gtk_view_get_right_margin(GtkTextView* view)
{
  GtkAdjustment* hadjustment;
  gint margin;
  gdouble hadj;
  gdouble hupper;
  gdouble hpage;

  hadjustment = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(view));

  margin = gtk_text_view_get_right_margin(view);
  if(!hadjustment) return margin;

  /* TODO: I am not exactly sure where this +1 comes from, but it is required
   * so that the selection is aligned with the local selection at the right
   * margin. */
  hadj = gtk_adjustment_get_value(hadjustment) + 1;

  g_object_get(
    G_OBJECT(hadjustment),
    &quot;upper&quot;, &amp;hupper,
    &quot;page-size&quot;, &amp;hpage,
    NULL
  );

  if(hadj &gt; hupper - hpage - margin)
    return margin - (gint)(hupper - hpage - hadj);

  return 0;
}

/* Invalidate the whole area of the textview covered by the given user:
 * cursor, selection, current line */
static void
inf_text_gtk_view_user_invalidate_user_area(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GdkWindow* window;
  GdkRectangle invalidate_rect;
  gint selection_bound_x;
  gint selection_bound_y;
  gint window_width;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  if(gtk_widget_get_realized(GTK_WIDGET(priv-&gt;textview)))
  {
    /* Invalidate cursors/selections */
    if(priv-&gt;show_remote_cursors || priv-&gt;show_remote_selections ||
       priv-&gt;show_remote_current_lines)
    {
      window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);
      window_width = gdk_window_get_width(window);

      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
        &amp;invalidate_rect.x, &amp;invalidate_rect.y
      );

      invalidate_rect.width = view_user-&gt;cursor_rect.width;
      invalidate_rect.height = view_user-&gt;cursor_rect.height;

      /* Don't check for InfTextUser's selection length here so that clearing
       * a previous selection works. */
      if(priv-&gt;show_remote_selections &amp;&amp;
         (view_user-&gt;selection_bound_rect.x != view_user-&gt;cursor_rect.x ||
          view_user-&gt;selection_bound_rect.y != view_user-&gt;cursor_rect.y))
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          view_user-&gt;selection_bound_rect.x,
          view_user-&gt;selection_bound_rect.y,
          &amp;selection_bound_x, &amp;selection_bound_y
        );

        /* Invalidate the whole area between cursor and selection bound */
        if(selection_bound_y == invalidate_rect.y)
        {
          /* Cursor and selection bound are on the same line */
          if(selection_bound_x &gt; invalidate_rect.x)
          {
            /* Selection bound is to the right of cursor */
            invalidate_rect.width = MAX(
              selection_bound_x - invalidate_rect.x,
              invalidate_rect.width
            );
          }
          else
          {
            /* Selection bound is to the left of cursor */
            invalidate_rect.width += (invalidate_rect.x - selection_bound_x);
            invalidate_rect.x = selection_bound_x;
          }
        }
        else
        {
          /* Cursor and selection bound are on different lines. Could split
           * the actual area to be invalidated into three rectangles here,
           * but let's just do the union for simplicity reasons. */
          invalidate_rect.width = window_width;
          invalidate_rect.height = MAX(
            invalidate_rect.y + invalidate_rect.height,
            selection_bound_y + view_user-&gt;selection_bound_rect.height
          ) - MIN(invalidate_rect.y, selection_bound_y);

          invalidate_rect.x =
            inf_text_gtk_view_get_left_margin(priv-&gt;textview);
          invalidate_rect.y = MIN(invalidate_rect.y, selection_bound_y);

          invalidate_rect.width -=
            inf_text_gtk_view_get_left_margin(priv-&gt;textview) +
            inf_text_gtk_view_get_right_margin(priv-&gt;textview);
        }

        gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
      }

      /* Invalidate current lines */
      if(priv-&gt;show_remote_current_lines)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          0, view_user-&gt;line_y,
          NULL, &amp;invalidate_rect.y
        );

        /* -1 to stay consistent with GtkSourceView */
        invalidate_rect.x =
          inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
        invalidate_rect.width = window_width - invalidate_rect.x;
        invalidate_rect.height = view_user-&gt;line_height;
      }

      gdk_window_invalidate_rect(window, &amp;invalidate_rect, FALSE);
    }
  }
}

static gint
inf_text_gtk_view_user_line_position_cmp(gconstpointer first,
                                         gconstpointer second)
{
  const InfTextGtkViewUser* first_user;
  const InfTextGtkViewUser* second_user;

  first_user = (const InfTextGtkViewUser*)first;
  second_user = (const InfTextGtkViewUser*)second;

  if(second_user-&gt;line_y &lt; first_user-&gt;line_y)
    return 1;
  else if(second_user-&gt;line_y &gt; first_user-&gt;line_y)
    return -1;

  return 0;

}

static gint
inf_text_gtk_view_user_toggle_position_cmp(gconstpointer first,
                                           gconstpointer second,
                                           gpointer user_data)
{
  const InfTextGtkViewUserToggle* first_toggle;
  const InfTextGtkViewUserToggle* second_toggle;

  first_toggle = (const InfTextGtkViewUserToggle*)first;
  second_toggle = (const InfTextGtkViewUserToggle*)second;

  if(second_toggle-&gt;pos &lt; first_toggle-&gt;pos)
    return 1;
  else if(second_toggle-&gt;pos &gt; first_toggle-&gt;pos)
    return -1;

  return 0;
}

static gint
inf_text_gtk_view_user_toggle_user_cmp(gconstpointer first,
                                       gconstpointer second)
{
  const InfTextGtkViewUserToggle* first_toggle;
  const InfTextGtkViewUserToggle* second_toggle;
  guint first_id;
  guint second_id;

  first_toggle = (const InfTextGtkViewUserToggle*)first;
  second_toggle = (const InfTextGtkViewUserToggle*)second;
  first_id = inf_user_get_id(INF_USER(first_toggle-&gt;user-&gt;user));
  second_id = inf_user_get_id(INF_USER(second_toggle-&gt;user-&gt;user));

  if(second_id &lt; first_id)
    return 1;
  else if(second_id &gt; first_id)
    return -1;

  return 0;
}

static void
inf_text_gtk_view_user_toggle_free(gpointer data)
{
  g_slice_free(InfTextGtkViewUserToggle, data);
}

static InfTextGtkViewUserToggle*
inf_text_gtk_view_add_user_toggle(GSequence* sequence,
                                  guint position,
                                  InfTextGtkViewUser* user,
                                  InfTextGtkViewUserToggle* on_toggle,
                                  gint x,
                                  gint y)
{
  InfTextGtkViewUserToggle* toggle;
  toggle = g_slice_new(InfTextGtkViewUserToggle);
  toggle-&gt;user = user;
  toggle-&gt;pos = position;
  toggle-&gt;on_toggle = on_toggle;
  toggle-&gt;x = x;
  toggle-&gt;y = y;

  g_sequence_insert_sorted(
    sequence,
    toggle,
    inf_text_gtk_view_user_toggle_position_cmp,
    NULL
  );

  return toggle;
}

static void
inf_text_gtk_view_add_user_toggle_pair(GSequence* sequence,
                                       guint begin,
                                       guint end,
                                       InfTextGtkViewUser* user,
                                       gint begin_x,
                                       gint begin_y,
                                       gint end_x,
                                       gint end_y)
{
  InfTextGtkViewUserToggle* begin_toggle;

  g_assert(end &gt; begin);

  begin_toggle = inf_text_gtk_view_add_user_toggle(
    sequence,
    begin,
    user,
    NULL,
    begin_x,
    begin_y
  );

  inf_text_gtk_view_add_user_toggle(
    sequence,
    end,
    user,
    begin_toggle,
    end_x,
    end_y
  );
}

static gboolean
inf_text_gtk_view_draw_before_cb(GtkWidget* widget,
                                 cairo_t* cr,
                                 gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  GSList* prev_item;
  InfTextGtkViewUser* prev_user;
  InfTextGtkViewUser* view_user;
  GtkAdjustment* hadjustment;
  GtkAdjustment* vadjustment;
  GdkWindow *text_window;

  GtkStyleContext* style;
  GdkRGBA bg;
  double h, s, v;
  double r, g, b;

  GSList* sort_users;
  GdkRectangle rect;
  gint window_width;
  gint rx, ry;
  GdkRectangle clip_area;
  cairo_pattern_t* pattern;
  double n, n_users;
  cairo_matrix_t matrix;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);

  if(!gtk_cairo_should_draw_window(cr, text_window))
  {
    return FALSE;
  }

  if(priv-&gt;show_remote_current_lines)
  {
    gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);

    gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);

    window_width = gdk_window_get_width(text_window);

    /* Make current line color depend on background. */
    style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
    gtk_style_context_save(style);
    gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
    gtk_style_context_get_background_color(style, GTK_STATE_FLAG_NORMAL, &amp;bg);
    gtk_style_context_restore(style);

    gtk_rgb_to_hsv(bg.red, bg.green, bg.blue, &amp;h, &amp;s, &amp;v);
    v = MAX(v, 0.3);
    s = MAX(s, 0.1 + 0.3*(1 - v));

    sort_users = g_slist_copy(priv-&gt;users);
    sort_users =
      g_slist_sort(sort_users, inf_text_gtk_view_user_line_position_cmp);

    prev_item = sort_users;
    if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
    n_users = 1.0;

    for(item = sort_users; item != NULL; item = item-&gt;next, n_users += 1.0)
    {
      if(item-&gt;next == NULL ||
         ((InfTextGtkViewUser*)item-&gt;next-&gt;data)-&gt;line_y != prev_user-&gt;line_y)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          0, prev_user-&gt;line_y,
          NULL, &amp;rect.y
        );

        /* -1 to stay consistent with GtkSourceView */
        rect.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview) - 1;
        rect.width = window_width - rect.x;
        rect.height = prev_user-&gt;line_height;

        if(gdk_rectangle_intersect(&amp;clip_area, &amp;rect, NULL))
        {
          hadjustment =
            gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
          vadjustment =
            gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));

          /* Construct pattern */
          rx = gtk_adjustment_get_value(vadjustment);
          ry = gtk_adjustment_get_value(hadjustment);
          pattern =
            cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
          cairo_matrix_init_translate(&amp;matrix, rx, ry);
          cairo_pattern_set_matrix(pattern, &amp;matrix);
          cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);

          for(n = 0.0;
              prev_item != item-&gt;next;
              prev_item = prev_item-&gt;next, n += 1.0)
          {
            view_user = (InfTextGtkViewUser*)prev_item-&gt;data;
            h = inf_text_user_get_hue(view_user-&gt;user);
            gtk_hsv_to_rgb(h, s, v, &amp;r, &amp;g, &amp;b);

            cairo_pattern_add_color_stop_rgb(
              pattern,
              n/n_users,
              r, g, b
            );

            cairo_pattern_add_color_stop_rgb(
              pattern,
              (n+1.0)/n_users,
              r, g, b
            );
          }

          cairo_set_source(cr, pattern);
          gdk_cairo_rectangle(cr, &amp;rect);
          cairo_fill(cr);
          cairo_pattern_destroy(pattern);
        }

        prev_item = item-&gt;next;
        if(prev_item) prev_user = (InfTextGtkViewUser*)prev_item-&gt;data;
        n_users = 0.0;
      }
    }

    g_slist_free(sort_users);
  }

  return FALSE;
}

static gboolean
inf_text_gtk_view_draw_after_cb(GtkWidget* widget,
                                cairo_t* cr,
                                gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  gint window_width;
  GtkStyleContext* style;
  GdkColor* cursor_color;
  GdkRGBA fg;
  double hc,sc,vc;
  double hs,ss,vs;
  GSList* item;
  InfTextGtkViewUser* view_user;
  double rc,gc,bc;
  double rs,gs,bs;

  GdkRectangle clip_area;

  gint ax, ay;
  GtkTextIter begin_iter;
  GtkTextIter end_iter;
  guint area_begin;
  guint area_end;

  guint own_sel_begin;
  guint own_sel_end;
  gint osbx, osby;
  gint osex, osey;

  gint sel;
  guint begin;
  guint end;
  GSequence* toggles;

  GSequenceIter* tog_iter;
  InfTextGtkViewUserToggle* cur_toggle;
  InfTextGtkViewUserToggle* prev_toggle;
  guint n_users;
  GSList* users;
  cairo_pattern_t* pattern;
  GtkAdjustment* hadjustment;
  GtkAdjustment* vadjustment;
  double n;
  cairo_matrix_t matrix;

  GdkRectangle rct;
  gint rx, ry;
  GdkWindow *text_window;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  text_window = gtk_text_view_get_window(priv-&gt;textview, GTK_TEXT_WINDOW_TEXT);

  if(!gtk_cairo_should_draw_window(cr, text_window))
  {
    return FALSE;
  }

  gtk_cairo_transform_to_window(cr, GTK_WIDGET(priv-&gt;textview), text_window);
  gdk_cairo_get_clip_rectangle(cr, &amp;clip_area);

  style = gtk_widget_get_style_context(GTK_WIDGET(priv-&gt;textview));
  gtk_style_context_save(style);
  gtk_style_context_add_class(style, GTK_STYLE_CLASS_VIEW);
  gtk_style_context_get_color(style, GTK_STATE_FLAG_NORMAL, &amp;fg);
  gtk_style_context_restore(style);

  if(priv-&gt;show_remote_selections)
  {
    window_width = gdk_window_get_width(text_window);

    /* Make selection color based on text color: If text is dark, selection
     * is dark, if text is bright selection is bright. Note that we draw with
     * 50% alpha only, so text remains readable. */
    gtk_rgb_to_hsv(fg.red, fg.green, fg.blue, &amp;hs, &amp;ss, &amp;vs);
    vs = MAX(vs, 0.5);
    ss = 1.0 - 0.4*(vs);

    /* Find range of text to be updated */
    gtk_text_view_window_to_buffer_coords(
      priv-&gt;textview,
      GTK_TEXT_WINDOW_TEXT,
      clip_area.x, clip_area.y,
      &amp;ax, &amp;ay
    );

    gtk_text_view_get_iter_at_location(
      priv-&gt;textview,
      &amp;begin_iter,
      ax,
      ay
    );

    gtk_text_view_get_iter_at_location(
      priv-&gt;textview,
      &amp;end_iter,
      ax + clip_area.width,
      ay + clip_area.height
    );

    area_begin = gtk_text_iter_get_offset(&amp;begin_iter);
    area_end = gtk_text_iter_get_offset(&amp;end_iter);
    g_assert(area_end &gt;= area_begin);

    /* Find own selection (we don't draw remote
     * selections over own selection). */
    gtk_text_buffer_get_selection_bounds(
      gtk_text_view_get_buffer(priv-&gt;textview),
      &amp;begin_iter,
      &amp;end_iter
    );

    own_sel_begin = gtk_text_iter_get_offset(&amp;begin_iter);
    own_sel_end = gtk_text_iter_get_offset(&amp;end_iter);
    if(own_sel_begin != own_sel_end)
    {
      gtk_text_view_get_iter_location(priv-&gt;textview, &amp;begin_iter, &amp;rct);
      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        rct.x, rct.y,
        &amp;osbx, &amp;osby
      );

      gtk_text_view_get_iter_location(priv-&gt;textview, &amp;end_iter, &amp;rct);
      gtk_text_view_buffer_to_window_coords(
        priv-&gt;textview,
        GTK_TEXT_WINDOW_TEXT,
        rct.x, rct.y,
        &amp;osex, &amp;osey
      );
    }

    /* Build toggle list */
    toggles = g_sequence_new(inf_text_gtk_view_user_toggle_free);
    for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    {
      view_user = (InfTextGtkViewUser*)item-&gt;data;
      if(inf_text_user_get_selection_length(view_user-&gt;user) != 0)
      {
        begin = inf_text_user_get_caret_position(view_user-&gt;user);
        sel = inf_text_user_get_selection_length(view_user-&gt;user);

        if(sel &gt; 0)
        {
          end = begin + sel;
        }
        else
        {
          g_assert(begin &gt;= (unsigned int)-sel);

          end = begin;
          begin += sel;
        }

        /* This can happen if the document is not yet fully loaded, i.e. synchronization
         * is still in progress. */
        if(begin &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
          begin = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));
        if(end &gt; gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview)))
          end = gtk_text_buffer_get_char_count(gtk_text_view_get_buffer(priv-&gt;textview));

        begin = MIN(MAX(begin, area_begin), area_end);
        end = MIN(MAX(end, area_begin), area_end);
        g_assert(end &gt;= begin);

        if(begin != end)
        {
          if(sel &gt; 0)
          {
            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;cursor_rect.x,
              view_user-&gt;cursor_rect.y,
              &amp;rx, &amp;ry
            );

            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;selection_bound_rect.x,
              view_user-&gt;selection_bound_rect.y,
              &amp;ax, &amp;ay
            );
          }
          else
          {
            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;selection_bound_rect.x,
              view_user-&gt;selection_bound_rect.y,
              &amp;rx, &amp;ry
            );

            gtk_text_view_buffer_to_window_coords(
              priv-&gt;textview,
              GTK_TEXT_WINDOW_TEXT,
              view_user-&gt;cursor_rect.x,
              view_user-&gt;cursor_rect.y,
              &amp;ax, &amp;ay
            );
          }

          if(own_sel_begin == own_sel_end ||
             own_sel_end &lt;= begin || own_sel_begin &gt;= end)
          {
            /* Local selection and remote selection do not overlap */
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, end,
              view_user,
              rx, ry,
              ax, ay
            );
          }
          else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &gt;= end)
          {
            /* Whole remote selection is covered by local selection */
          }
          else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &gt;= end)
          {
            /* Last part of remote selection is covered by local selection */
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, own_sel_begin,
              view_user,
              rx, ry,
              osbx, osby
            );
          }
          else if(own_sel_begin &lt;= begin &amp;&amp; own_sel_end &lt; end)
          {
            /* First part of remote selection is covered by local selection */
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              own_sel_end, end,
              view_user,
              osex, osey,
              ax, ay
            );
          }
          else if(own_sel_begin &gt; begin &amp;&amp; own_sel_end &lt; end)
          {
            /* Local selection is in middle of remote selection */
            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              begin, own_sel_begin,
              view_user,
              rx, ry,
              osbx, osby
            );

            inf_text_gtk_view_add_user_toggle_pair(
              toggles,
              own_sel_end, end,
              view_user,
              osex, osey,
              ax, ay
            );
          }
          else
          {
            g_assert_not_reached();
          }
        }
      }
    }

    /* Walk toggle list, draw selections */
    tog_iter = g_sequence_get_begin_iter(toggles);
    cur_toggle = NULL;
    prev_toggle = NULL;
    users = NULL;
    n_users = 0;

    tog_iter = g_sequence_get_begin_iter(toggles);
    while(!g_sequence_iter_is_end(tog_iter))
    {
      cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);

      /* Draw users from prev_toggle to cur_toggle */
      if(users != NULL)
      {
        g_assert(prev_toggle != NULL);
        g_assert(n_users &gt; 0);

        hadjustment =
          gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(priv-&gt;textview));
        vadjustment =
          gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(priv-&gt;textview));

        /* Construct pattern */
        rx = gtk_adjustment_get_value(hadjustment);
        ry = gtk_adjustment_get_value(vadjustment);
        pattern =
          cairo_pattern_create_linear(0, 0, 3.5*n_users, 3.5*n_users);
        cairo_matrix_init_translate(&amp;matrix, rx, ry);
        cairo_pattern_set_matrix(pattern, &amp;matrix);
        cairo_pattern_set_extend(pattern, CAIRO_EXTEND_REPEAT);
        for(item = users, n = 0.0; item != NULL; item = item-&gt;next, n += 1.0)
        {
          view_user = ((InfTextGtkViewUserToggle*)item-&gt;data)-&gt;user;
          hs = inf_text_user_get_hue(view_user-&gt;user);
          gtk_hsv_to_rgb(hs, ss, vs, &amp;rs, &amp;gs, &amp;bs);

          cairo_pattern_add_color_stop_rgba(
            pattern,
            n/n_users,
            rs, gs, bs, 0.5
          );

          cairo_pattern_add_color_stop_rgba(
            pattern,
            (n+1.0)/n_users,
            rs, gs, bs, 0.5
          );
        }

        cairo_set_source(cr, pattern);
        if(prev_toggle-&gt;y == cur_toggle-&gt;y)
        {
          /* same line */
          g_assert(prev_toggle-&gt;x &lt; cur_toggle-&gt;x);

          rct.x = prev_toggle-&gt;x;
          rct.y = prev_toggle-&gt;y;
          rct.width = cur_toggle-&gt;x - prev_toggle-&gt;x;
          rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
          gdk_cairo_rectangle(cr, &amp;rct);
        }
        else
        {
          g_assert(
            cur_toggle-&gt;y - prev_toggle-&gt;y &gt;=
            cur_toggle-&gt;user-&gt;selection_bound_rect.height
          );

          /* multiple lines */
          if(window_width &gt; prev_toggle-&gt;x)
          {
            /* first line */
            rct.x = prev_toggle-&gt;x;
            rct.y = prev_toggle-&gt;y;
            rct.width = window_width - prev_toggle-&gt;x -
              inf_text_gtk_view_get_right_margin(priv-&gt;textview);
            rct.height = prev_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }

          if(cur_toggle-&gt;x &gt; 0)
          {
            /* last line */
            rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
            rct.y = cur_toggle-&gt;y;
            rct.width = cur_toggle-&gt;x - rct.x;
            rct.height = cur_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }

          if(cur_toggle-&gt;y - prev_toggle-&gt;y &gt;
             cur_toggle-&gt;user-&gt;selection_bound_rect.height)
          {
            /* intermediate */
            rct.x = inf_text_gtk_view_get_left_margin(priv-&gt;textview);
            rct.y = prev_toggle-&gt;y +
              prev_toggle-&gt;user-&gt;selection_bound_rect.height;
            rct.width = window_width - rct.x -
              inf_text_gtk_view_get_right_margin(priv-&gt;textview);
            rct.height = cur_toggle-&gt;y - prev_toggle-&gt;y -
              cur_toggle-&gt;user-&gt;selection_bound_rect.height;
            gdk_cairo_rectangle(cr, &amp;rct);
          }
        }

        cairo_fill(cr);
        cairo_pattern_destroy(pattern);
      }

      prev_toggle = cur_toggle;

<A NAME="5"></A>      /* advance to next position, toggle users on/off while doing so */
      do
      {
<FONT color="#151b8d"><A HREF="javascript:ZweiFrames('match1219-1.html#5',3,'match1219-top.html#5',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        if(cur_toggle-&gt;on_toggle == NULL)
        {
          /* Keep toggles in user list sorted by user ID, so that the same
           * users generate the same pattern */
          users = g_slist_insert_sorted(
            users,
            cur_toggle,
            inf_text_gtk_view_user_toggle_user_cmp
          );

          ++n_users;
        }
        else
        {
          g_assert(n_users &gt; 0);
          users = g_slist_remove(users, cur_toggle-&gt;on_toggle);
          --n_users;
        }

        tog_iter = g_sequence_iter_next(tog_iter);</B></FONT>
        if(g_sequence_iter_is_end(tog_iter))
          break;

        cur_toggle = (InfTextGtkViewUserToggle*)g_sequence_get(tog_iter);
      } while(cur_toggle-&gt;pos == prev_toggle-&gt;pos);
    }

    g_assert(n_users == 0);
    g_assert(users == NULL);
    g_sequence_free(toggles);
  }

  if(priv-&gt;show_remote_cursors)
  {
    gtk_widget_style_get (widget, &quot;cursor-color&quot;, &amp;cursor_color, NULL);
    if(cursor_color != NULL)
    {
      rc = cursor_color-&gt;red / 65535.0;
      bc = cursor_color-&gt;green / 65535.0;
      gc = cursor_color-&gt;blue / 65535.0;
      gdk_color_free(cursor_color);
    }
    else
    {
      rc = fg.red;
      bc = fg.green;
      gc = fg.blue;
    }

    gtk_rgb_to_hsv(rc, bc, gc, &amp;hc, &amp;sc, &amp;vc);
    sc = MIN(MAX(sc, 0.3), 0.8);
    vc = MAX(vc, 0.7);

    for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
    {
      view_user = (InfTextGtkViewUser*)item-&gt;data;
      if(view_user-&gt;cursor_visible)
      {
        gtk_text_view_buffer_to_window_coords(
          priv-&gt;textview,
          GTK_TEXT_WINDOW_TEXT,
          view_user-&gt;cursor_rect.x, view_user-&gt;cursor_rect.y,
          &amp;rct.x, &amp;rct.y
        );

        rct.width = view_user-&gt;cursor_rect.width;
        rct.height = view_user-&gt;cursor_rect.height;

        if(gdk_rectangle_intersect(&amp;clip_area, &amp;rct, NULL))
        {
          hc = inf_text_user_get_hue(view_user-&gt;user);
          gtk_hsv_to_rgb(hc, sc, vc, &amp;rc, &amp;gc, &amp;bc);

          cairo_set_source_rgb(cr, rc, gc, bc);
          gdk_cairo_rectangle(cr, &amp;rct);
          cairo_fill(cr);
        }
      }
    }
  }

  return FALSE;
}

static void
inf_text_gtk_view_style_updated_cb(GtkWidget* widget,
                                   gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  InfTextGtkViewUser* view_user;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    view_user = (InfTextGtkViewUser*)item-&gt;data;
    inf_text_gtk_view_user_compute_user_area(view_user);
  }
}

static void
inf_text_gtk_view_size_allocate_cb(GtkWidget* widget,
                                   GtkAllocation* allocation,
                                   gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  GSList* item;
  InfTextGtkViewUser* view_user;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  for(item = priv-&gt;users; item != NULL; item = item-&gt;next)
  {
    view_user = (InfTextGtkViewUser*)item-&gt;data;
    inf_text_gtk_view_user_compute_user_area(view_user);
  }
}

static void
inf_text_gtk_view_user_cursor_blink_timeout_func(gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;
  GtkSettings* settings;
  gboolean cursor_blink;
  gint cursor_blink_time;

  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  view_user-&gt;cursor_visible = !view_user-&gt;cursor_visible;
  inf_text_gtk_view_user_invalidate_user_area(view_user);

  /* Schedule next cursor blink */
  settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));

  /* TODO: Handle gtk-cursor-blink-timeout */
  g_object_get(
    G_OBJECT(settings),
    &quot;gtk-cursor-blink&quot;, &amp;cursor_blink,
    &quot;gtk-cursor-blink-time&quot;, &amp;cursor_blink_time,
    NULL
  );

  if(cursor_blink)
  {
    if(!view_user-&gt;cursor_visible)
      cursor_blink_time = cursor_blink_time * 1 / 3;
    else
      cursor_blink_time = cursor_blink_time * 2 / 3;

    view_user-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      cursor_blink_time,
      inf_text_gtk_view_user_cursor_blink_timeout_func,
      view_user,
      NULL
    );
  }
  else
  {
    view_user-&gt;timeout = NULL;
  }
}

static void
inf_text_gtk_view_user_reset_timeout(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  GtkSettings* settings;
  gboolean cursor_blink;
  gint cursor_blink_time;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  if(view_user-&gt;timeout)
  {
    inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);
    view_user-&gt;timeout = NULL;
  }

  if(!view_user-&gt;cursor_visible)
  {
    view_user-&gt;cursor_visible = TRUE;

    /* TODO: Only need to invalidate cursor rect, not whole user area */
    inf_text_gtk_view_user_invalidate_user_area(view_user);
  }

  settings = gtk_widget_get_settings(GTK_WIDGET(priv-&gt;textview));

  /* TODO: Reschedule timeout if these settings change */
  g_object_get(
    G_OBJECT(settings),
    &quot;gtk-cursor-blink&quot;, &amp;cursor_blink,
    &quot;gtk-cursor-blink-time&quot;, &amp;cursor_blink_time,
    NULL
  );

  if(cursor_blink)
  {
    view_user-&gt;timeout = inf_io_add_timeout(
      priv-&gt;io,
      cursor_blink_time,
      inf_text_gtk_view_user_cursor_blink_timeout_func,
      view_user,
      NULL
    );
  }
}

static gboolean
inf_text_gtk_view_user_selection_changed_cb_idle_func(gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  view_user = (InfTextGtkViewUser*)user_data;

  g_assert(view_user-&gt;revalidate_idle != 0);
  view_user-&gt;revalidate_idle = 0;

  /* Revalidate */
  inf_text_gtk_view_user_invalidate_user_area(view_user);

  return FALSE;
}

static void
inf_text_gtk_view_user_selection_changed_cb(InfTextUser* user,
                                            guint position,
                                            gint length,
                                            gboolean by_request,
                                            gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;

  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  /* We don't need to invalidate areas if the change was not made by a user
   * request. So for example if someone's cursor moved because another user
   * has inserted text somewhere before it, then we don't need to redraw that
   * cursor since it either:
   * a) was shifted to the right, in which case the underlying text was also
   * shifted and is therefore invalidated anyway.
   * b) Both text and cursor have not been shifted, no redraw necessary.
   * Note that we need to recompute the user area though because it might
   * have moved. */
  if(by_request)
  {
    /* Invalidate current user area, e.g. to get rid of cursor at previous
     * location if it moved, or if the selection area was shrinked. */
    /* TODO: Not sure whether this also needs to go to the idle handler...
     * if so make sure it is executed even if the viewuser is deleted in the
     * meanwhile. */
    inf_text_gtk_view_user_invalidate_user_area(view_user);
  }

  inf_text_gtk_view_user_compute_user_area(view_user);

  if(by_request)
  {
    inf_text_gtk_view_user_reset_timeout(view_user);

    /* We can't invalidate here because
     * gtk_text_view_buffer_to_window_coords() does not give correct
     * coordinates at this point. We need to wait for the textview to
     * revalidate onscreen lines first (which it does in an idle handler,
     * note higher numbers indicate less priority). */
    if(view_user-&gt;revalidate_idle == 0)
    {
      view_user-&gt;revalidate_idle = g_idle_add_full(
        GTK_TEXT_VIEW_PRIORITY_VALIDATE + 1,
        inf_text_gtk_view_user_selection_changed_cb_idle_func,
<A NAME="2"></A>        view_user,
        NULL
      );
<FONT color="#980517"><A HREF="javascript:ZweiFrames('match1219-1.html#2',3,'match1219-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    }
  }
}

static void
inf_text_gtk_view_user_notify_hue_cb(GObject* object,
                                     GParamSpec* pspec,
                                     gpointer user_data)
{
  InfTextGtkViewUser* view_user;
  InfTextGtkViewPrivate* priv;

  view_user = (InfTextGtkViewUser*)user_data;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  /* TODO: Might restrict this on current lines,
   * cursor rects and selection rects */
  gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));
}

static void
inf_text_gtk_view_add_user(InfTextGtkView* view,
                           InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextGtkViewUser* view_user;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  view_user = g_slice_new(InfTextGtkViewUser);

  view_user-&gt;view = view;
  view_user-&gt;user = INF_TEXT_USER(user);
  view_user-&gt;cursor_visible = TRUE;</B></FONT>
  view_user-&gt;timeout = NULL;
  view_user-&gt;revalidate_idle = 0;
  inf_text_gtk_view_user_compute_user_area(view_user);
  inf_text_gtk_view_user_reset_timeout(view_user);
  priv-&gt;users = g_slist_prepend(priv-&gt;users, view_user);

  g_signal_connect_after(
    user,
    &quot;selection-changed&quot;,
    G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
    view_user
  );

  g_signal_connect(
    user,
    &quot;notify::hue&quot;,
    G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
    view_user
  );

  inf_text_gtk_view_user_invalidate_user_area(view_user);
}

static void
inf_text_gtk_view_remove_user(InfTextGtkViewUser* view_user)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view_user-&gt;view);

  inf_signal_handlers_disconnect_by_func(
    view_user-&gt;user,
    G_CALLBACK(inf_text_gtk_view_user_selection_changed_cb),
    view_user
  );

  inf_signal_handlers_disconnect_by_func(
    view_user-&gt;user,
    G_CALLBACK(inf_text_gtk_view_user_notify_hue_cb),
    view_user
  );

  if(view_user-&gt;timeout != NULL)
    inf_io_remove_timeout(priv-&gt;io, view_user-&gt;timeout);

  if(view_user-&gt;revalidate_idle != 0)
    g_source_remove(view_user-&gt;revalidate_idle);

  inf_text_gtk_view_user_invalidate_user_area(view_user);

  priv-&gt;users = g_slist_remove(priv-&gt;users, view_user);
  g_slice_free(InfTextGtkViewUser, view_user);
}

static void
inf_text_gtk_view_user_notify_status_cb(GObject* object,
                                        GParamSpec* pspec,
                                        gpointer user_data)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;
  InfTextUser* user;
  InfTextGtkViewUser* view_user;

  view = INF_TEXT_GTK_VIEW(user_data);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  user = INF_TEXT_USER(object);

  g_assert(user != priv-&gt;active_user);
  view_user = inf_text_gtk_view_find_user(view, user);

  if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
  {
    if(!view_user)
      inf_text_gtk_view_add_user(view, user);
  }
  else
  {
    if(view_user)
      inf_text_gtk_view_remove_user(view_user);
  }
}

static void
inf_text_gtk_view_user_removed(InfTextGtkView* view,
                               InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextGtkViewUser* view_user;

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(user == priv-&gt;active_user)
  {
    priv-&gt;active_user = NULL;
    g_object_notify(G_OBJECT(view), &quot;active-user&quot;);
  }
  else
  {
    inf_signal_handlers_disconnect_by_func(
      user,
      G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
      view
    );

    if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
    {
      view_user = inf_text_gtk_view_find_user(view, user);
      g_assert(view_user != NULL);

      inf_text_gtk_view_remove_user(view_user);
    }
  }
}

static void
inf_text_gtk_view_user_added(InfTextGtkView* view,
                             InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  /* Active user is guaranteed to be contained in user table, so if user was
   * just added then it can't be set as active user already. */
  g_assert(user != priv-&gt;active_user);

  g_signal_connect(
    user,
    &quot;notify::status&quot;,
    G_CALLBACK(inf_text_gtk_view_user_notify_status_cb),
    view
  );

  if(inf_user_get_status(INF_USER(user)) == INF_USER_ACTIVE)
    inf_text_gtk_view_add_user(view, user);
}

static void
inf_text_gtk_view_add_user_cb(InfUserTable* user_table,
                              InfUser* user,
                              gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
}

static void
inf_text_gtk_view_remove_user_cb(InfUserTable* user_table,
                                 InfUser* user,
                                 gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
}

static void
inf_text_gtk_view_set_user_table_foreach_new_user_func(InfUser* user,
                                                       gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_added(view, INF_TEXT_USER(user));
}

static void
inf_text_gtk_view_set_user_table_foreach_old_user_func(InfUser* user,
                                                       gpointer user_data)
{
  InfTextGtkView* view = INF_TEXT_GTK_VIEW(user_data);
  g_assert(INF_TEXT_IS_USER(user));
  inf_text_gtk_view_user_removed(view, INF_TEXT_USER(user));
}

static void
inf_text_gtk_view_set_view(InfTextGtkView* view,
                           GtkTextView* gtk_view)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;textview != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_draw_before_cb),
      view
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_draw_after_cb),
      view
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_style_updated_cb),
      view
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;textview),
      G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
      view
    );

    g_object_unref(priv-&gt;textview);
  }

  priv-&gt;textview = gtk_view;

  if(gtk_view != NULL)
  {
    g_object_ref(gtk_view);

    g_signal_connect(
      G_OBJECT(gtk_view),
      &quot;draw&quot;,
      G_CALLBACK(inf_text_gtk_view_draw_before_cb),
      view
    );

    g_signal_connect_after(
      G_OBJECT(gtk_view),
      &quot;draw&quot;,
      G_CALLBACK(inf_text_gtk_view_draw_after_cb),
      view
    );

    g_signal_connect_after(
      G_OBJECT(gtk_view),
      &quot;style-updated&quot;,
      G_CALLBACK(inf_text_gtk_view_style_updated_cb),
      view
    );

    /* This is required for the remote cursors showing up at the correct
     * position initially. Maybe gtk_text_view_get_iter_location() seems to
     * return junk before. Note that also style-updated is not enough. */
    g_signal_connect_after(
      G_OBJECT(gtk_view),
      &quot;size-allocate&quot;,
      G_CALLBACK(inf_text_gtk_view_size_allocate_cb),
      view
    );
  }

  g_object_notify(G_OBJECT(view), &quot;view&quot;);
}

static void
inf_text_gtk_view_set_user_table(InfTextGtkView* view,
                                 InfUserTable* user_table)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;user_table != NULL)
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_text_gtk_view_add_user_cb),
      view
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(priv-&gt;user_table),
      G_CALLBACK(inf_text_gtk_view_remove_user_cb),
      view
    );

    inf_user_table_foreach_user(
      priv-&gt;user_table,
      inf_text_gtk_view_set_user_table_foreach_old_user_func,
      view
    );

    g_object_unref(priv-&gt;user_table);
  }

  priv-&gt;user_table = user_table;

  if(user_table != NULL)
  {
    g_object_ref(user_table);

    g_signal_connect(
      G_OBJECT(user_table),
      &quot;add-user&quot;,
      G_CALLBACK(inf_text_gtk_view_add_user_cb),
      view
    );

    g_signal_connect(
      G_OBJECT(user_table),
      &quot;remove-user&quot;,
      G_CALLBACK(inf_text_gtk_view_remove_user_cb),
      view
    );

    inf_user_table_foreach_user(
      user_table,
      inf_text_gtk_view_set_user_table_foreach_new_user_func,
      view
    );
  }

  g_object_notify(G_OBJECT(view), &quot;user-table&quot;);
}

static void
inf_text_gtk_view_init(InfTextGtkView* view)
{
  InfTextGtkViewPrivate* priv;
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  priv-&gt;io = NULL;
  priv-&gt;textview = NULL;
  priv-&gt;user_table = NULL;
  priv-&gt;active_user = NULL;
  priv-&gt;users = NULL;

  priv-&gt;show_remote_cursors = TRUE;
  priv-&gt;show_remote_selections = TRUE;
  priv-&gt;show_remote_current_lines = TRUE;
}

static void
inf_text_gtk_view_dispose(GObject* object)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;

  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  inf_text_gtk_view_set_user_table(view, NULL);
  inf_text_gtk_view_set_view(view, NULL);

<A NAME="0"></A>  g_assert(priv-&gt;active_user == NULL);
  g_assert(priv-&gt;users == NULL);

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1219-1.html#0',3,'match1219-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  if(priv-&gt;io != NULL)
  {
    g_object_unref(priv-&gt;io);
    priv-&gt;io = NULL;
  }

  G_OBJECT_CLASS(inf_text_gtk_view_parent_class)-&gt;dispose(object);
}

static void
inf_text_gtk_view_set_property(GObject* object,
                                 guint prop_id,
                                 const GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;

  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); /* construct only */
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_VIEW:
    g_assert(priv-&gt;textview == NULL); /* construct only */</B></FONT>

    inf_text_gtk_view_set_view(
      view,
      GTK_TEXT_VIEW(g_value_get_object(value))
    );

    break;
  case PROP_USER_TABLE:
    g_assert(priv-&gt;user_table == NULL); /* construct/only */

    inf_text_gtk_view_set_user_table(
      view,
      INF_USER_TABLE(g_value_get_object(value))
    );

    break;
  case PROP_ACTIVE_USER:
    inf_text_gtk_view_set_active_user(
      view,
      INF_TEXT_USER(g_value_get_object(value))
    );

    break;
  case PROP_SHOW_REMOTE_CURSORS:
    inf_text_gtk_view_set_show_remote_cursors(
      view,
      g_value_get_boolean(value)
    );

    break;
  case PROP_SHOW_REMOTE_SELECTIONS:
    inf_text_gtk_view_set_show_remote_selections(
      view,
      g_value_get_boolean(value)
    );

    break;
  case PROP_SHOW_REMOTE_CURRENT_LINES:
    inf_text_gtk_view_set_show_remote_current_lines(
      view,
<A NAME="3"></A>      g_value_get_boolean(value)
    );

<FONT color="#53858b"><A HREF="javascript:ZweiFrames('match1219-1.html#3',3,'match1219-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(value, prop_id, pspec);
    break;
  }
}

static void
inf_text_gtk_view_get_property(GObject* object,
                                 guint prop_id,
                                 GValue* value,
                                 GParamSpec* pspec)
{
  InfTextGtkView* view;
  InfTextGtkViewPrivate* priv;

  view = INF_TEXT_GTK_VIEW(object);
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, G_OBJECT(priv-&gt;io));
    break;
  case PROP_VIEW:
    g_value_set_object(value, G_OBJECT(priv-&gt;textview));
    break;</B></FONT>
  case PROP_USER_TABLE:
    g_value_set_object(value, G_OBJECT(priv-&gt;user_table));
    break;
  case PROP_ACTIVE_USER:
    g_value_set_object(value, G_OBJECT(priv-&gt;active_user));
    break;
  case PROP_SHOW_REMOTE_CURSORS:
    g_value_set_boolean(value, priv-&gt;show_remote_cursors);
    break;
  case PROP_SHOW_REMOTE_SELECTIONS:
    g_value_set_boolean(value, priv-&gt;show_remote_selections);
<A NAME="4"></A>    break;
  case PROP_SHOW_REMOTE_CURRENT_LINES:
    g_value_set_boolean(value, priv-&gt;show_remote_current_lines);
<FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match1219-1.html#4',3,'match1219-top.html#4',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_text_gtk_view_class_init(InfTextGtkViewClass* view_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(view_class);

  object_class-&gt;dispose = inf_text_gtk_view_dispose;
  object_class-&gt;set_property = inf_text_gtk_view_set_property;
  object_class-&gt;get_property = inf_text_gtk_view_get_property;</B></FONT>

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      &quot;io&quot;,
      &quot;IO&quot;,
      &quot;The IO object to schedule timeouts&quot;,
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_VIEW,
    g_param_spec_object(
      &quot;view&quot;,
      &quot;View&quot;,
      &quot;The underlying GtkTextView&quot;,
      GTK_TYPE_TEXT_VIEW,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_USER_TABLE,
    g_param_spec_object(
      &quot;user-table&quot;,
      &quot;User table&quot;,
      &quot;The user table containing the users of the session shown in the view&quot;,
      INF_TYPE_USER_TABLE,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_ACTIVE_USER,
    g_param_spec_object(
      &quot;active-user&quot;,
      &quot;Active user&quot;,
      &quot;The user for which to show the view&quot;,
      INF_TEXT_TYPE_USER,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_CURSORS,
    g_param_spec_boolean(
      &quot;show-remote-cursors&quot;,
      &quot;Show remote cursors&quot;,
      &quot;Whether to show cursors of non-local users&quot;,
      TRUE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_SELECTIONS,
    g_param_spec_boolean(
      &quot;show-remote-selections&quot;,
      &quot;Show remote selections&quot;,
      &quot;Whether to highlight text selected by non-local users&quot;,
      TRUE,
      G_PARAM_READWRITE
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_SHOW_REMOTE_CURRENT_LINES,
    g_param_spec_boolean(
      &quot;show-remote-current-lines&quot;,
      &quot;Show remote current lines&quot;,
      &quot;Whether to highlight the line in which the cursor of non-local users is&quot;,
      TRUE,
      G_PARAM_READWRITE
    )
  );
}

/**
 * inf_text_gtk_view_new: (constructor)
 * @io: A #InfIo.
 * @view: A #GtkTextView.
 * @user_table: The #InfUserTable for the text session displayed in @view.
 *
 * Creates a new #InfTextGtkView for @view. This draws remote user's cursors
 * and selections into the text view.
 *
 * Returns: (transfer full): A new #InfTextGtkView.
 */
InfTextGtkView*
inf_text_gtk_view_new(InfIo* io,
                      GtkTextView* view,
                      InfUserTable* user_table)
{
  GObject* object;

  g_return_val_if_fail(INF_IS_IO(io), NULL);
  g_return_val_if_fail(GTK_IS_TEXT_VIEW(view), NULL);
  g_return_val_if_fail(INF_IS_USER_TABLE(user_table), NULL);

  object = g_object_new(
    INF_TEXT_GTK_TYPE_VIEW,
    &quot;io&quot;, io,
    &quot;view&quot;, view,
    &quot;user-table&quot;, user_table,
    NULL
  );

  return INF_TEXT_GTK_VIEW(object);
}

/**
 * inf_text_gtk_view_get_text_view:
 * @view: A #InfTextGtkView.
 *
 * Returns the underlying #GtkTextView.
 *
 * Returns: (transfer none): The #InfTextGtkView's #GtkTextView.
 **/
GtkTextView*
inf_text_gtk_view_get_text_view(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;textview;
}

/**
 * inf_text_gtk_view_get_user_table:
 * @view: A #InfTextGtkView.
 *
 * Returns the #InfUserTable containing the users of the session the
 * #InfTextGtkView's #GtkTextView is displaying.
 *
 * Returns: (transfer none): The #InfTextGtkView's #InfUserTable.
 */
InfUserTable*
inf_text_gtk_view_get_user_table(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;user_table;
}

/**
 * inf_text_gtk_view_set_active_user:
 * @view: A #InfTextGtkView.
 * @user: (allow-none): A user from @view's user table, or %NULL.
 *
 * Sets the user for which perspective to draw the view. The selection and
 * cursor position is not drawn for this user since it is assumed that the
 * view's buffer cursor position and selection match the active user ones
 * (which is automatically the case if the buffer is managed by a
 * #InfTextGtkBuffer).
 */
void
inf_text_gtk_view_set_active_user(InfTextGtkView* view,
                                  InfTextUser* user)
{
  InfTextGtkViewPrivate* priv;
  InfTextUser* active_user;

  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  g_return_if_fail(user == NULL || INF_TEXT_IS_USER(user));

  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);
  g_return_if_fail(
    user == NULL ||
    inf_user_table_lookup_user_by_id(
      priv-&gt;user_table,
      inf_user_get_id(INF_USER(user))
    ) == INF_USER(user)
  );

  if(priv-&gt;active_user != NULL)
  {
    active_user = priv-&gt;active_user;
    priv-&gt;active_user = NULL;

    inf_text_gtk_view_user_added(view, active_user);
  }

  if(user != NULL)
  {
    inf_text_gtk_view_user_removed(view, user);
  }

  priv-&gt;active_user = user;
  g_object_notify(G_OBJECT(view), &quot;active-user&quot;);
}

/**
 * inf_text_gtk_view_get_active_user:
 * @view: A #InfTextGtkView.
 *
 * Returns the active user of @view. See inf_text_gtk_view_set_active_user().
 *
 * Returns: (transfer none) (allow-none): The active user of @view.
 */
InfTextUser*
inf_text_gtk_view_get_active_user(InfTextGtkView* view)
{
  g_return_val_if_fail(INF_TEXT_GTK_IS_VIEW(view), NULL);
  return INF_TEXT_GTK_VIEW_PRIVATE(view)-&gt;active_user;
}

/**
 * inf_text_gtk_view_set_show_remote_cursors:
 * @view: A #InfTextGtkView.
 * @show: Whether to show cursors of non-local users.
 *
 * If @show is %TRUE then @view draws a cursor for each non-local user in
 * %INF_USER_ACTIVE status in that user's color into its underlying
 * #GtkTextView. If it is %FALSE then remote cursors are not drawn.
 */
void
inf_text_gtk_view_set_show_remote_cursors(InfTextGtkView* view,
                                          gboolean show)
{
  InfTextGtkViewPrivate* priv;
  
  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;show_remote_cursors != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));

    priv-&gt;show_remote_cursors = show;
    g_object_notify(G_OBJECT(view), &quot;show-remote-cursors&quot;);
  }
}

/**
 * inf_text_gtk_view_set_show_remote_selections:
 * @view: A #InfTextGtkView.
 * @show: Whether to show selections of non-local users.
 *
 * If @show is %TRUE then @view draws the selection ranges for each non-local
 * user in %INF_USER_ACTIVE status. The selection range is drawn shaded in
 * that user's color on top of the author color which indicates who wrote the
 * selected text. If more than one user has a given piece of text selected
 * then an alternating stripe pattern with each of the user's colors is drawn.
 * If @show is %FALSE then selection ranges of remote users are not drawn.
 */
void
inf_text_gtk_view_set_show_remote_selections(InfTextGtkView* view,
                                             gboolean show)
{
  InfTextGtkViewPrivate* priv;
  
  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;show_remote_selections != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));

    priv-&gt;show_remote_selections = show;
    g_object_notify(G_OBJECT(view), &quot;show-remote-selections&quot;);
  }
}

/**
 * inf_text_gtk_view_set_show_remote_current_lines:
 * @view: A #InfTextGtkView.
 * @show: Whether to highlight the current line of non-local users.
 *
 * If @show is %TRUE then all lines in which the cursor of a non-local user
 * in %INF_USER_ACTIVE status is is highlighted with that user's color, similar
 * to GtkSourceView's &quot;highlight current line&quot; functionality. If it is %FALSE
 * then the current line of non-local users is not highlighted.
 */
void
inf_text_gtk_view_set_show_remote_current_lines(InfTextGtkView* view,
                                                gboolean show)
{
  InfTextGtkViewPrivate* priv;

  g_return_if_fail(INF_TEXT_GTK_IS_VIEW(view));
  priv = INF_TEXT_GTK_VIEW_PRIVATE(view);

  if(priv-&gt;show_remote_current_lines != show)
  {
    gtk_widget_queue_draw(GTK_WIDGET(priv-&gt;textview));

    priv-&gt;show_remote_current_lines = show;
    g_object_notify(G_OBJECT(view), &quot;show-remote-current-lines&quot;);
  }
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>inf-gtk-browser-store.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* libinfinity - a GObject-based infinote implementation
 * Copyright (C) 2007-2015 Armin Burgmeier &lt;armin@arbur.net&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 */

#include &lt;libinfgtk/inf-gtk-browser-store.h&gt;
#include &lt;libinfgtk/inf-gtk-browser-model.h&gt;
#include &lt;libinfinity/client/infc-browser.h&gt;
#include &lt;libinfinity/inf-i18n.h&gt;
#include &lt;libinfinity/inf-signals.h&gt;

#include &lt;gtk/gtk.h&gt;

/* The three pointers in GtkTreeIter are used as follows:
 *
 * user_data holds a pointer to the GtkTreeModelItem the iter points to.
 * user_data2 holds the node_id field of the InfBrowserIter, or 0 if the
 * iter points to the toplevel node.
 * user_data3 holds the node field of the InfcBrowser, or NULL if the iter
 * points to the toplevel node. Note that it does not hold the root node of
 * the item's browser (if present) because the iter should remain valid when
<A NAME="1"></A> * the browser is removed (we set GTK_TREE_MODEL_ITERS_PERSIST).
 */

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1219-0.html#1',2,'match1219-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>typedef struct _InfGtkBrowserStoreItem InfGtkBrowserStoreItem;
struct _InfGtkBrowserStoreItem {
  gchar* name;
  InfDiscovery* discovery;
  InfDiscoveryInfo* info;

  InfBrowser* browser;

  /* Browser node which is currently to be removed. This is required since
   * when node-removed is emitted in InfcBrowser the node is still present,
   * but we need to make sure that the GtkTreeModel functions do as if it
   * wasn't present anymore. */
  gpointer missing;

  /* Running requests */
  GSList* requests;
  /* Saved node errors (during exploration/subscription) */
  GHashTable* node_errors;

  /* TODO: Determine status at run-time? */
  InfGtkBrowserModelStatus status;

  /* Error on toplevel item */
  GError* error;

  /* Link */
  InfGtkBrowserStoreItem* next;
};

typedef struct _InfGtkBrowserStoreRequestData InfGtkBrowserStoreRequestData;
struct _InfGtkBrowserStoreRequestData {
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
};

typedef struct _InfGtkBrowserStorePrivate InfGtkBrowserStorePrivate;
struct _InfGtkBrowserStorePrivate {
  gint stamp;

  InfIo* io;
  InfCommunicationManager* communication_manager;

  GSList* discoveries;
  InfGtkBrowserStoreItem* first_item;
  InfGtkBrowserStoreItem* last_item;
};

enum {
  PROP_0,

  PROP_IO,
  PROP_COMMUNICATION_MANAGER
};

#define INF_GTK_BROWSER_STORE_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), INF_GTK_TYPE_BROWSER_STORE, InfGtkBrowserStorePrivate))

static void inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface);</B></FONT>
static void inf_gtk_browser_store_browser_model_iface_init(InfGtkBrowserModelInterface* iface);
G_DEFINE_TYPE_WITH_CODE(InfGtkBrowserStore, inf_gtk_browser_store, G_TYPE_OBJECT,
  G_ADD_PRIVATE(InfGtkBrowserStore)
  G_IMPLEMENT_INTERFACE(GTK_TYPE_TREE_MODEL, inf_gtk_browser_store_tree_model_iface_init)
  G_IMPLEMENT_INTERFACE(INF_GTK_TYPE_BROWSER_MODEL, inf_gtk_browser_store_browser_model_iface_init))

/*
 * Utility functions
 */

static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_connection(InfGtkBrowserStore* store,
                                              InfXmlConnection* connection)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfcBrowser* browser;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
  {
    if(item-&gt;browser != NULL &amp;&amp; INFC_IS_BROWSER(item-&gt;browser))
    {
      browser = INFC_BROWSER(item-&gt;browser);
      if(infc_browser_get_connection(browser) == connection)
        return item;
    }
  }

  return NULL;
}

static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_browser(InfGtkBrowserStore* store,
                                           InfBrowser* browser)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
    if(item-&gt;browser != NULL)
      if(item-&gt;browser == browser)
        return item;

  return NULL;
}

static InfGtkBrowserStoreItem*
inf_gtk_browser_store_find_item_by_discovery_info(InfGtkBrowserStore* store,
                                                  InfDiscoveryInfo* info)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  for(item = priv-&gt;first_item; item != NULL; item = item-&gt;next)
    if(item-&gt;info != NULL)
      if(item-&gt;info == info)
        return item;

  return NULL;
}

/*
 * Callback declarations
 */

static void
inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
                                               GParamSpec* pspec,
                                               gpointer user_data);

static void
inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
                                       const GError* error,
                                       gpointer user_data);

static void
inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
                                    InfBrowserIter* iter,
                                    InfRequest* request,
                                    gpointer user_data);

static void
inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
                                      InfBrowserIter* iter,
                                      InfRequest* request,
                                      gpointer user_data);

static void
inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
                                                    InfBrowserIter* iter,
                                                    InfRequest* request,
                                                    gpointer user_data);

static void
inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
                                                         InfBrowserIter* iter,
                                                         InfRequest* request,
                                                         gpointer user_data);

static void
inf_gtk_browser_store_request_finished_cb(InfRequest* request,
                                          const InfRequestResult* result,
                                          const GError* error,
                                          gpointer user_data);

static void
inf_gtk_browser_store_request_unrefed_func(gpointer data,
                                           GObject* where_the_object_was);

/*
 * InfGtkBrowserStoreItem handling
 */

static void
inf_gtk_browser_store_request_data_free(gpointer data,
                                        GClosure* closure)
{
  g_slice_free(InfGtkBrowserStoreRequestData, data);
}

static void
inf_gtk_browser_store_item_request_remove(InfGtkBrowserStoreItem* item,
                                          InfRequest* request)
{
  g_object_weak_unref(
    G_OBJECT(request),
    inf_gtk_browser_store_request_unrefed_func,
    item
  );

  inf_signal_handlers_disconnect_by_func(
    G_OBJECT(request),
    G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
    item
  );

  item-&gt;requests = g_slist_remove(item-&gt;requests, request);
}

static void
inf_gtk_browser_store_item_request_add(InfGtkBrowserStore* store,
                                       InfGtkBrowserStoreItem* item,
                                       InfRequest* request)
{
  InfGtkBrowserStoreRequestData* data;

  g_assert(g_slist_find(item-&gt;requests, request) == NULL);
  item-&gt;requests = g_slist_prepend(item-&gt;requests, request);

  data = g_slice_new(InfGtkBrowserStoreRequestData);
  data-&gt;store = store;
  data-&gt;item = item;

  g_signal_connect_data(
    G_OBJECT(request),
    &quot;finished&quot;,
    G_CALLBACK(inf_gtk_browser_store_request_finished_cb),
    data,
    inf_gtk_browser_store_request_data_free,
    0
  );
  
  g_object_weak_ref(
    G_OBJECT(request),
    inf_gtk_browser_store_request_unrefed_func,
    item
  );
}

static void
inf_gtk_browser_store_request_finished_cb(InfRequest* request,
                                          const InfRequestResult* result,
                                          const GError* error,
                                          gpointer user_data)
{
  InfGtkBrowserStoreRequestData* data;
  InfGtkBrowserStorePrivate* priv;
  InfBrowserIter request_iter;
  gboolean node_exists;
  GtkTreeIter tree_iter;
  GtkTreePath* path;

  data = (InfGtkBrowserStoreRequestData*)user_data;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(data-&gt;store);

  g_assert(g_slist_find(data-&gt;item-&gt;requests, request) != NULL);
  g_assert(data-&gt;item-&gt;browser != NULL);

  /* request can be a explore-node or subscribe-session request */

  /* TODO: Also remove the request from the store when
   * it has properly finished? */
  if(error != NULL)
  {
    node_exists = inf_browser_iter_from_request(
      data-&gt;item-&gt;browser,
      request,
      &amp;request_iter
    );

    inf_gtk_browser_store_item_request_remove(data-&gt;item, request);

    /* Ignore if node has been removed in the meanwhile */
    if(G_LIKELY(node_exists))
    {
      /* Replace previous error */
      g_hash_table_insert(
        data-&gt;item-&gt;node_errors,
        GUINT_TO_POINTER(request_iter.node_id),
        g_error_copy(error)
      );

      tree_iter.stamp = priv-&gt;stamp;
      tree_iter.user_data = data-&gt;item;
      tree_iter.user_data2 = GUINT_TO_POINTER(request_iter.node_id);

      /* Set NULL for root node because it also refers to the store item as
       * such if no browser is set. */
      if(request_iter.node_id == 0)
        tree_iter.user_data3 = NULL;
      else
        tree_iter.user_data3 = request_iter.node;

<A NAME="2"></A>      path = gtk_tree_model_get_path(GTK_TREE_MODEL(data-&gt;store), &amp;tree_iter);
      gtk_tree_model_row_changed(GTK_TREE_MODEL(data-&gt;store), path, &amp;tree_iter);
      gtk_tree_path_free(path);
<FONT color="#980517"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1219-0.html#2',2,'match1219-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    }
  }
}

static void
inf_gtk_browser_store_request_unrefed_func(gpointer data,
                                           GObject* where_the_object_was)
{
  InfGtkBrowserStoreItem* item;
  item = (InfGtkBrowserStoreItem*)data;

  /* No need to further unregister */
  item-&gt;requests = g_slist_remove(item-&gt;requests, where_the_object_was);
}

static void
inf_gtk_browser_store_item_set_browser(InfGtkBrowserStore* store,
                                       InfGtkBrowserStoreItem* item,
                                       GtkTreePath* path,
                                       InfBrowser* browser)
{
  GtkTreeIter tree_iter;
  InfGtkBrowserStorePrivate* priv;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;</B></FONT>

  /* The default signal handler sets the browser in the item and makes the
   * necessary TreeModel notifications. See
   * inf_gtk_browser_store_browser_model_set_browser(). */
  inf_gtk_browser_model_set_browser(
    INF_GTK_BROWSER_MODEL(store),
    path,
    &amp;tree_iter,
    item-&gt;browser,
    browser
  );
}

/* takes ownership of name */
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_add_item_by_browser(InfGtkBrowserStore* store,
                                          InfDiscovery* discovery,
                                          InfDiscoveryInfo* info,
                                          InfBrowser* browser,
                                          gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  GtkTreeIter iter;
  guint index;

  g_assert(
    browser == NULL ||
    inf_gtk_browser_store_find_item_by_browser(store, browser) == NULL
  );

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = g_slice_new(InfGtkBrowserStoreItem);
  item-&gt;name = name;
  item-&gt;discovery = discovery;
  item-&gt;info = info;
  item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
  if(discovery != NULL &amp;&amp; info != NULL)
    item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
  item-&gt;browser = NULL;
  item-&gt;missing = NULL;
  item-&gt;node_errors = g_hash_table_new_full(
    NULL,
    NULL,
    NULL,
    (GDestroyNotify)g_error_free
  );
  item-&gt;requests = NULL;
  item-&gt;error = NULL;
  item-&gt;next = NULL;
  
  index = 0;
  for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
<A NAME="5"></A>    ++ index;

  /* Link */
<FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1219-0.html#5',2,'match1219-top.html#5',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  if(priv-&gt;first_item == NULL)
  {
    priv-&gt;first_item = item;
    priv-&gt;last_item = item;
  }
  else
  {
    priv-&gt;last_item-&gt;next = item;
    priv-&gt;last_item = item;
  }

  path = gtk_tree_path_new_from_indices(index, -1);</B></FONT>
  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;

  gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;iter);

  if(browser != NULL)
    inf_gtk_browser_store_item_set_browser(store, item, path, browser);

  gtk_tree_path_free(path);
  return item;
}


/* takes ownership of name */
static InfGtkBrowserStoreItem*
inf_gtk_browser_store_add_item_by_connection(InfGtkBrowserStore* store,
                                             InfDiscovery* discovery,
                                             InfDiscoveryInfo* info,
                                             InfXmlConnection* connection,
                                             gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfcBrowser* browser;
  InfGtkBrowserStoreItem* item;

  g_assert(
    connection == NULL ||
    inf_gtk_browser_store_find_item_by_connection(store, connection) == NULL
  );

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  browser = NULL;

  if(connection != NULL)
  {
    browser = infc_browser_new(
      priv-&gt;io,
      priv-&gt;communication_manager,
      connection
    );

    /* The connection is not set if the browser could not find a &quot;central&quot;
     * method for the connection's network. I don't think this can happen. */
    if(infc_browser_get_connection(browser) == NULL)
    {
      g_object_unref(browser);
      g_free(name);
      return NULL;
    }
  }

  item = inf_gtk_browser_store_add_item_by_browser(
    store,
    discovery,
    info,
    INF_BROWSER(browser),
    name
  );

  if(browser != NULL)
    g_object_unref(browser);

  return item;
}

static void
inf_gtk_browser_store_remove_item(InfGtkBrowserStore* store,
                                  InfGtkBrowserStoreItem* item)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* prev;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  guint index;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  /* Determine index of item, to build a tree path to it */
  prev = NULL;
  index = 0;

  for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
  {
    if(cur == item)
      break;

    prev = cur;
    ++ index;
  }

  /* Item was present in list */
  g_assert(cur != NULL);

  path = gtk_tree_path_new_from_indices(index, -1);

  /* Note we need to reset the browser before we unlink because
   * inf_gtk_browser_store_item_set_browser() requires item still being
   * linked for change notifications. */
  /* TODO: This is a bit cumbersome. A better way might be to be able for
   * the iter parameter to be NULL to indicate that an entry with
   * its browser has been deleted. However, this would still need to do
   * lots of the unregistration that is now happening in
   * inf_gtk_browser_store_item_set_browser(). */
  if(item-&gt;browser != NULL)
  {
    inf_gtk_browser_store_item_set_browser(store, item, path, NULL);
    g_assert(item-&gt;browser == NULL); /* Default handler must run */
  }

  /* Unlink */
  if(prev == NULL)
    priv-&gt;first_item = item-&gt;next;
  else
    prev-&gt;next = item-&gt;next;

  if(item-&gt;next == NULL)
    priv-&gt;last_item = prev;

  g_assert(cur != NULL);

  gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
  gtk_tree_path_free(path);

  if(item-&gt;error != NULL)
    g_error_free(item-&gt;error);

  g_hash_table_unref(item-&gt;node_errors);
  g_free(item-&gt;name);
  g_slice_free(InfGtkBrowserStoreItem, item);
}

/*
 * Callbacks and signal handlers
 */

static void
inf_gtk_browser_store_discovered_cb(InfDiscovery* discovery,
                                    InfDiscoveryInfo* info,
                                    gpointer user_data)
{
  inf_gtk_browser_store_add_item_by_browser(
    INF_GTK_BROWSER_STORE(user_data),
    discovery,
    info,
    NULL,
    inf_discovery_info_get_service_name(discovery, info)
  );
}

static void
inf_gtk_browser_store_undiscovered_cb(InfDiscovery* discovery,
                                      InfDiscoveryInfo* info,
                                      gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;

  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);

  /* If, after a discovery resove we see that there is already an item for
   * that connection, then we remove the discovery item, and use the other
   * item instead. In that case, item can be NULL here. */
  if(item != NULL)
  {
    if(item-&gt;browser == NULL)
    {
      inf_gtk_browser_store_remove_item(store, item);
    }
    else
    {
      g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_DISCOVERED &amp;&amp;
               item-&gt;status != INF_GTK_BROWSER_MODEL_RESOLVING);

      item-&gt;discovery = NULL;
      item-&gt;info = NULL;
    }
  }
}

static void
inf_gtk_browser_store_browser_error_cb(InfBrowser* browser,
                                       const GError* error,
                                       gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStorePrivate* priv;
  GtkTreeIter iter;
  GtkTreePath* path;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  g_assert(item != NULL);

  /* Overwrite previous error */
  if(item-&gt;error != NULL)
    g_error_free(item-&gt;error);

  item-&gt;error = g_error_copy(error);
  /* Don't set error state, this could be a non-fatal error */

  /* Notify */
  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
  gtk_tree_path_free(path);
}

static void
inf_gtk_browser_store_browser_notify_status_cb(GObject* object,
                                               GParamSpec* pspec,
                                               gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfBrowser* browser;
  InfBrowserStatus status;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter iter;
  GtkTreePath* path;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(user_data);  
  browser = INF_BROWSER(object);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  g_assert(item != NULL);

  iter.stamp = priv-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  g_object_get(G_OBJECT(browser), &quot;status&quot;, &amp;status, NULL);

  switch(status)
  {
  case INF_BROWSER_CLOSED:
    /* TODO: Do we want to go to disconnected state when error is not set? */
    item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;

    /* Set a &quot;Disconnected&quot; error if there is not already one set by
     * inf_gtk_browser_store_connection_error_cb() that has a more
     * meaningful error message. */
    if(item-&gt;error == NULL)
    {
      item-&gt;error = g_error_new_literal(
        g_quark_from_static_string(&quot;INF_GTK_BROWSER_STORE_ERROR&quot;),
        0,
        _(&quot;Disconnected&quot;)
      );
    }

    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    break;
  case INF_BROWSER_OPENING:
    if(item-&gt;error != NULL) g_error_free(item-&gt;error);
    item-&gt;error = NULL;
    item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    break;
  case INF_BROWSER_OPEN:
    if(item-&gt;error != NULL) g_error_free(item-&gt;error);
<A NAME="4"></A>    item-&gt;error = NULL;
    item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1219-0.html#4',2,'match1219-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    break;
  default:
    g_assert_not_reached();
    break;
  }

  gtk_tree_path_free(path);
}

static void
inf_gtk_browser_store_node_added_cb(InfBrowser* browser,
                                    InfBrowserIter* iter,
                                    InfRequest* request,
                                    gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;

  InfBrowserIter test_iter;
  gboolean test_result;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  tree_iter.stamp = priv-&gt;stamp;</B></FONT>
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
  tree_iter.user_data3 = iter-&gt;node;

  if(iter-&gt;node_id != 0)
  {
    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
    gtk_tree_model_row_inserted(GTK_TREE_MODEL(store), path, &amp;tree_iter);

    /* If iter is the only node within its parent, we need to emit the
     * row-has-child-toggled signal. */
    test_iter = *iter;
    test_result = inf_browser_get_parent(browser, &amp;test_iter);
    g_assert(test_result == TRUE);

    /* Let tree_iter point to parent row for possible notification */
    tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);

    /* Also adjust path */
    gtk_tree_path_up(path);

    if(test_iter.node_id == 0)
      tree_iter.user_data3 = NULL;
    else
      tree_iter.user_data3 = test_iter.node;

    test_result = inf_browser_get_child(browser, &amp;test_iter);
    g_assert(test_result == TRUE);

    if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(store),
        path,
        &amp;tree_iter
      );
    }

    gtk_tree_path_free(path);
  }
}

static void
inf_gtk_browser_store_node_removed_cb(InfBrowser* browser,
                                      InfBrowserIter* iter,
                                      InfRequest* request,
                                      gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  InfBrowserIter test_iter;
  gboolean test_result;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  g_assert(item-&gt;missing == NULL);

  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
  tree_iter.user_data3 = iter-&gt;node;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);

  /* This is a small hack to have the item removed from the tree
   * model before it is removed from the InfcBrowser. */

  item-&gt;missing = iter-&gt;node;

  if(iter-&gt;node_id != 0)
  {
    gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);

  /* TODO: Remove requests and node errors from nodes below the removed one */

    /* Note that at this point removed node is still in the browser. We have
     * to emit row-has-child-toggled if it is the only one in its
     * subdirectory. */
    test_iter = *iter;
    test_result = inf_browser_get_parent(browser, &amp;test_iter);
    g_assert(test_result == TRUE);

    /* Let tree_iter point to parent row for possible notification */
    tree_iter.user_data2 = GUINT_TO_POINTER(test_iter.node_id);

    /* Also adjust path */
    gtk_tree_path_up(path);

    if(test_iter.node_id == 0)
      tree_iter.user_data3 = NULL;
    else
      tree_iter.user_data3 = test_iter.node;

    test_result = inf_browser_get_child(browser, &amp;test_iter);
    g_assert(test_result == TRUE);

    if(inf_browser_get_next(browser, &amp;test_iter) == FALSE)
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(store),
        path,
        &amp;tree_iter
      );
    }
  }
  else
  {
    /* The root node was removed. We don't remove the node from the
     * GtkTreeModel because it still represents the InfBrowser. Remove
     * all the children, however. */
    if(inf_browser_get_explored(browser, iter))
    {
      test_iter = *iter;
      test_result = inf_browser_get_child(browser, &amp;test_iter);
      gtk_tree_path_down(path);

      do
      {
        gtk_tree_model_row_deleted(GTK_TREE_MODEL(store), path);
      } while(inf_browser_get_next(browser, &amp;test_iter));

      if(test_result == TRUE)
      {
        gtk_tree_path_up(path);
        gtk_tree_model_row_has_child_toggled(
          GTK_TREE_MODEL(store),
          path,
          &amp;tree_iter
        );
      }
    }
  }

  item-&gt;missing = NULL;
  gtk_tree_path_free(path);
}

static void
inf_gtk_browser_store_begin_request_explore_node_cb(InfBrowser* browser,
                                                    InfBrowserIter* iter,
                                                    InfRequest* request,
                                                    gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;

  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  inf_gtk_browser_store_item_request_add(store, item, request);
}

static void
inf_gtk_browser_store_begin_request_subscribe_session_cb(InfBrowser* browser,
                                                         InfBrowserIter* iter,
                                                         InfRequest* request,
                                                         gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStoreItem* item;

  /* should not be a chat session, because chat session
   * has type subscribe-chat */
  g_assert(iter != NULL);

  store = INF_GTK_BROWSER_STORE(user_data);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  inf_gtk_browser_store_item_request_add(store, item, request);
}

static void
inf_gtk_browser_store_resolv_complete_func(InfDiscoveryInfo* info,
                                           InfXmlConnection* connection,
                                           const GError* error,
                                           gpointer user_data)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* new_item;
  InfGtkBrowserStoreItem* old_item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;
  InfcBrowser* browser;

  InfGtkBrowserStoreItem* cur;
  InfGtkBrowserStoreItem* prev;
  InfGtkBrowserStoreItem* prev_new;
  InfGtkBrowserStoreItem* prev_old;
  gint* order;
  guint count;
  guint new_pos;
  guint old_pos;
  guint i;

  store = INF_GTK_BROWSER_STORE(user_data);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  new_item = inf_gtk_browser_store_find_item_by_discovery_info(store, info);
  g_assert(new_item != NULL);
  g_assert(new_item-&gt;status == INF_GTK_BROWSER_MODEL_RESOLVING);

  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = new_item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;

  if(error != NULL)
  {
    new_item-&gt;status = INF_GTK_BROWSER_MODEL_ERROR;
    new_item-&gt;error = g_error_copy(error);

    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;tree_iter);
    gtk_tree_path_free(path);
  }
  else
  {
    old_item =
      inf_gtk_browser_store_find_item_by_connection(store, connection);

    if(old_item != NULL)
    {
      g_assert(old_item != new_item);

      /* There is already an item with the same connection. This is perhaps
       * from another discovery or was inserted directly. We remove the
       * current item and move the existing one to the place of it. */

      count = 0;
      prev = NULL;

      for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
      {
        if(cur == old_item) { old_pos = count; prev_old = prev; }
        if(cur == new_item) { new_pos = count; prev_new = prev; }
        ++ count;
        prev = cur;
      }

      inf_gtk_browser_store_remove_item(store, new_item);
      if(old_pos &gt; new_pos) -- old_pos;
      else -- new_pos;
      -- count;

      /* Reorder list if the two items were not adjacent */
      if(new_pos != old_pos)
      {
        /* old item is last element, but it is moved elsewhere */
        if(old_item-&gt;next == NULL)
          priv-&gt;last_item = prev_old;

        /* Unlink old_item */
        if(prev_old != NULL)
          prev_old-&gt;next = old_item-&gt;next;
        else
          priv-&gt;first_item = old_item-&gt;next;

        /* Relink */
        old_item-&gt;next = prev_new-&gt;next;

        if(prev_new != NULL)
          prev_new-&gt;next = old_item;
        else
          priv-&gt;first_item = old_item;

        /* old_item has been moved to end of list */
        if(old_item-&gt;next == NULL)
          priv-&gt;last_item = old_item;

        order = g_malloc(sizeof(gint) * count);
        if(new_pos &lt; old_pos)
        {
          for(i = 0; i &lt; new_pos; ++ i)
            order[i] = i;
          order[new_pos] = old_pos;
          for(i = new_pos + 1; i &lt;= old_pos; ++ i)
            order[i] = i - 1;
          for(i = old_pos + 1; i &lt; count; ++ i)
            order[i] = i;
        }
        else
        {
          for(i = 0; i &lt; old_pos; ++ i)
            order[i] = i;
          for(i = old_pos; i &lt; new_pos; ++ i)
            order[i] = i + 1;
          order[new_pos] = old_pos;
          for(i = new_pos + 1; i &lt; count; ++ i)
            order[i] = i;
        }

        path = gtk_tree_path_new();
        gtk_tree_model_rows_reordered(
          GTK_TREE_MODEL(store),
          path,
          NULL,
          order
        );
        gtk_tree_path_free(path);

        /* TODO: Perhaps we should emit a signal so that the view can
         * highlight and scroll to the existing item. And also so that it can
         * over initial root exploration. */

        g_free(order);
      }
    }
    else
    {
      path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;tree_iter);

      browser = infc_browser_new(
        priv-&gt;io,
        priv-&gt;communication_manager,
        connection
      );

      /* The connection is not set if the browser could not find a &quot;central&quot;
       * method for the connection's network. */
      /* TODO: Set error */
      if(infc_browser_get_connection(browser) != NULL)
      {
        inf_gtk_browser_store_item_set_browser(
          store,
          new_item,
          path,
          INF_BROWSER(browser)
        );
      }

      g_object_unref(G_OBJECT(browser));
      gtk_tree_path_free(path);
    }
  }
}

/*
 * GObject overrides
 */

static void
inf_gtk_browser_store_init(InfGtkBrowserStore* store)
{
  InfGtkBrowserStorePrivate* priv;
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  priv-&gt;stamp = g_random_int();
  priv-&gt;io = NULL;
  priv-&gt;communication_manager = NULL;
  priv-&gt;discoveries = NULL;
  priv-&gt;first_item = NULL;
  priv-&gt;last_item = NULL;
}

static void
inf_gtk_browser_store_dispose(GObject* object)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;
  GSList* item;

  store = INF_GTK_BROWSER_STORE(object);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  while(priv-&gt;first_item != NULL)
    inf_gtk_browser_store_remove_item(store, priv-&gt;first_item);
  g_assert(priv-&gt;last_item == NULL);

  for(item = priv-&gt;discoveries; item != NULL; item = g_slist_next(item))
  {
    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;data),
      G_CALLBACK(inf_gtk_browser_store_discovered_cb),
      store
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;data),
      G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
      store
    );

    g_object_unref(G_OBJECT(item-&gt;data));
  }

  g_slist_free(priv-&gt;discoveries);
  priv-&gt;discoveries = NULL;

  if(priv-&gt;communication_manager != NULL)
  {
    g_object_unref(priv-&gt;communication_manager);
<A NAME="0"></A>    priv-&gt;communication_manager = NULL;
  }

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1219-0.html#0',2,'match1219-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  if(priv-&gt;io != NULL)
  {
    g_object_unref(G_OBJECT(priv-&gt;io));
    priv-&gt;io = NULL;
  }

  G_OBJECT_CLASS(inf_gtk_browser_store_parent_class)-&gt;dispose(object);
}

static void
inf_gtk_browser_store_set_property(GObject* object,
                                   guint prop_id,
                                   const GValue* value,
                                   GParamSpec* pspec)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;

  store = INF_GTK_BROWSER_STORE(object);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  switch(prop_id)
  {
  case PROP_IO:
    g_assert(priv-&gt;io == NULL); /* construct only */
    priv-&gt;io = INF_IO(g_value_dup_object(value));
    break;
  case PROP_COMMUNICATION_MANAGER: 
    g_assert(priv-&gt;communication_manager == NULL); /* construct only */</B></FONT>
<A NAME="3"></A>    priv-&gt;communication_manager =
      INF_COMMUNICATION_MANAGER(g_value_dup_object(value));

<FONT color="#53858b"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1219-0.html#3',2,'match1219-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    break;
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

static void
inf_gtk_browser_store_get_property(GObject* object,
                                   guint prop_id,
                                   GValue* value,
                                   GParamSpec* pspec)
{
  InfGtkBrowserStore* store;
  InfGtkBrowserStorePrivate* priv;

  store = INF_GTK_BROWSER_STORE(object);
  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

  switch(prop_id)
  {
  case PROP_IO:
    g_value_set_object(value, priv-&gt;io);
    break;
  case PROP_COMMUNICATION_MANAGER:
    g_value_set_object(value, priv-&gt;communication_manager);
    break;</B></FONT>
  default:
    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
    break;
  }
}

/*
 * GtkTreeModel implementation
 */

static GtkTreeModelFlags
inf_gtk_browser_store_tree_model_get_flags(GtkTreeModel* model)
{
  return GTK_TREE_MODEL_ITERS_PERSIST;
}

static gint
inf_gtk_browser_store_tree_model_get_n_columns(GtkTreeModel* model)
{
  return INF_GTK_BROWSER_MODEL_NUM_COLS;
}

static GType
inf_gtk_browser_store_tree_model_get_column_type(GtkTreeModel* model,
                                                 gint index)
{
  switch(index)
  {
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
    return G_TYPE_POINTER;
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
    return INF_TYPE_DISCOVERY;
  case INF_GTK_BROWSER_MODEL_COL_BROWSER:
    return INFC_TYPE_BROWSER;
  case INF_GTK_BROWSER_MODEL_COL_STATUS:
    return INF_GTK_TYPE_BROWSER_MODEL_STATUS;
  case INF_GTK_BROWSER_MODEL_COL_NAME:
    return G_TYPE_STRING;
  case INF_GTK_BROWSER_MODEL_COL_ERROR:
    return G_TYPE_POINTER;
  case INF_GTK_BROWSER_MODEL_COL_NODE:
    return INF_TYPE_BROWSER_ITER;
  default:
    g_assert_not_reached();
    return G_TYPE_INVALID;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_get_iter(GtkTreeModel* model,
                                          GtkTreeIter* iter,
                                          GtkTreePath* path)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  gint* indices;

  guint i;
  guint n;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  if(gtk_tree_path_get_depth(path) == 0) return FALSE;

  indices = gtk_tree_path_get_indices(path);
  n = indices[0];

  i = 0;
  for(item = priv-&gt;first_item; item != NULL &amp;&amp; i &lt; n; item = item-&gt;next)
    ++i;

  if(item == NULL) return FALSE;

  /* Depth 1 */
  if(gtk_tree_path_get_depth(path) == 1)
  {
    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }

  if(item-&gt;browser == NULL) return FALSE;
  inf_browser_get_root(item-&gt;browser, &amp;browser_iter);

  for(n = 1; n &lt; (guint)gtk_tree_path_get_depth(path); ++ n)
  {
    if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    /* skip missing */
    if(browser_iter.node == item-&gt;missing)
      ++indices[n];

    for(i = 0; i &lt; (guint)indices[n]; ++ i)
    {
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;

      /* skip missing */
      if(browser_iter.node == item-&gt;missing)
        ++indices[n];
    }
  }

  iter-&gt;stamp = priv-&gt;stamp;
  iter-&gt;user_data = item;
  iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
  iter-&gt;user_data3 = browser_iter.node;
  return TRUE;
}

/* TODO: We can also use gtk_tree_path_prepend_index and do tail
 * recursion. We should find out which is faster. */
static void
inf_gtk_browser_store_tree_model_get_path_impl(InfGtkBrowserStore* store,
                                               InfGtkBrowserStoreItem* item,
                                               InfBrowserIter* iter,
                                               GtkTreePath* path)
{
  InfGtkBrowserStorePrivate* priv;
  InfBrowserIter cur_iter;
  InfGtkBrowserStoreItem* cur;
  gboolean result;
  guint n;

  cur_iter = *iter;
  if(inf_browser_get_parent(item-&gt;browser, &amp;cur_iter) == FALSE)
  {
    priv = INF_GTK_BROWSER_STORE_PRIVATE(store);

    /* We are on top level, but still need to find the item index */
    n = 0;
    for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
      ++n;

    gtk_tree_path_append_index(path, n);
  }
  else
  {
    inf_gtk_browser_store_tree_model_get_path_impl(
      store,
      item,
      &amp;cur_iter,
      path
    );

    result = inf_browser_get_child(item-&gt;browser, &amp;cur_iter);
    g_assert(result == TRUE);

    /* skip missing */
    if(cur_iter.node == item-&gt;missing)
    {
      result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
      g_assert(result == TRUE);
    }

    n = 0;
    while(cur_iter.node_id != iter-&gt;node_id)
    {
      result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
      g_assert(result == TRUE);

      /* skip missing */
      if(cur_iter.node == item-&gt;missing)
      {
        result = inf_browser_get_next(item-&gt;browser, &amp;cur_iter);
        g_assert(result == TRUE);
      }

      ++n;
    }

    gtk_tree_path_append_index(path, n);
  }
}

static GtkTreePath*
inf_gtk_browser_store_tree_model_get_path(GtkTreeModel* model,
                                          GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  GtkTreePath* path;
  InfBrowserIter browser_iter;
  guint n;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);
  g_assert(iter-&gt;user_data != NULL);

  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;

  path = gtk_tree_path_new();
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;

  if(browser_iter.node != NULL)
  {
    g_assert(item-&gt;browser != NULL);

    inf_gtk_browser_store_tree_model_get_path_impl(
      INF_GTK_BROWSER_STORE(model),
      item,
      &amp;browser_iter,
      path
    );
  }
  else
  {
    /* toplevel */
    n = 0;
    for(cur = priv-&gt;first_item; cur != item; cur = cur-&gt;next)
      ++n;

    gtk_tree_path_append_index(path, n);
  }

  return path;
}

static void
inf_gtk_browser_store_tree_model_get_value(GtkTreeModel* model,
                                           GtkTreeIter* iter,
                                           gint column,
                                           GValue* value)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  InfBrowserStatus browser_status;
  GError* error;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);

  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;

  /* If this iterator is the missing one, then it must be the root node,
   * otherwise this function must not have been called; it would have
   * been called on a non-existing entry. */
  g_assert(
    item-&gt;missing == NULL || browser_iter.node_id == 0 ||
    browser_iter.node != item-&gt;missing
  );

  switch(column)
  {
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY_INFO:
    g_value_init(value, G_TYPE_POINTER);
    g_value_set_pointer(value, item-&gt;info);
    break;
  case INF_GTK_BROWSER_MODEL_COL_DISCOVERY:
    g_value_init(value, G_TYPE_OBJECT);
    g_value_set_object(value, item-&gt;discovery);
    break;
  case INF_GTK_BROWSER_MODEL_COL_BROWSER:
    g_value_init(value, INF_TYPE_BROWSER);
    g_value_set_object(value, G_OBJECT(item-&gt;browser));
    break;
  case INF_GTK_BROWSER_MODEL_COL_STATUS:
    g_assert(browser_iter.node == NULL); /* only toplevel */
    g_value_init(value, INF_GTK_TYPE_BROWSER_MODEL_STATUS);
    g_value_set_enum(value, item-&gt;status);
    break;
  case INF_GTK_BROWSER_MODEL_COL_NAME:
    g_value_init(value, G_TYPE_STRING);
    if(browser_iter.node == NULL)
    {
      g_value_set_string(value, item-&gt;name);
    }
    else
    {
      g_value_set_string(
        value,
        inf_browser_get_node_name(INF_BROWSER(item-&gt;browser), &amp;browser_iter)
      );
    }
    break;
  case INF_GTK_BROWSER_MODEL_COL_ERROR:
    if(browser_iter.node == NULL)
    {
      /* toplevel */
      if(item-&gt;error != NULL)
      {
        /* not a node related error, perhaps connection error */
        error = item-&gt;error;
      }
      else if(item-&gt;browser != NULL)
      {
        /* error on root node */
        g_object_get(
          G_OBJECT(item-&gt;browser),
          &quot;status&quot;,
          &amp;browser_status,
          NULL
        );

        if(browser_status == INF_BROWSER_OPEN)
        {
          inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
          error = g_hash_table_lookup(
            item-&gt;node_errors,
            GUINT_TO_POINTER(browser_iter.node_id)
          );
        }
        else
        {
          /* Browser exists but is closed, but there is no connection error
           * set: no error */
          error = NULL;
        }
      }
      else
      {
        /* Neither error nor browser set: no error */
        error = NULL;
      }
    }
    else
    {
      g_assert(item-&gt;browser != NULL);

      g_object_get(G_OBJECT(item-&gt;browser), &quot;status&quot;, &amp;browser_status, NULL);
      g_assert(browser_status == INF_BROWSER_OPEN);

      error = g_hash_table_lookup(
        item-&gt;node_errors,
        GUINT_TO_POINTER(browser_iter.node_id)
      );
    }

    g_value_init(value, G_TYPE_POINTER);
    g_value_set_pointer(value, error);
    break;
  case INF_GTK_BROWSER_MODEL_COL_NODE:
    g_assert(item-&gt;browser != NULL);

    g_object_get(G_OBJECT(item-&gt;browser), &quot;status&quot;, &amp;browser_status, NULL);
    g_assert(browser_status == INF_BROWSER_OPEN);

    if(browser_iter.node == NULL)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);

    g_value_init(value, INF_TYPE_BROWSER_ITER);
    g_value_set_boxed(value, &amp;browser_iter);
    break;
  default:
    g_assert_not_reached();
    break;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_next(GtkTreeModel* model,
                                           GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);

  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;

  if(browser_iter.node == NULL)
  {
    if(item-&gt;next == NULL)
      return FALSE;

    iter-&gt;user_data = item-&gt;next;
    return TRUE;
  }
  else
  {
    g_assert(browser_iter.node != item-&gt;missing);

    if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    /* skip missing */
    if(browser_iter.node == item-&gt;missing)
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;

    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_children(GtkTreeModel* model,
                                               GtkTreeIter* iter,
                                               GtkTreeIter* parent)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus browser_status;
  InfBrowserIter browser_iter;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);

  if(parent == NULL)
  {
    if(priv-&gt;first_item == NULL)
      return FALSE;

    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = priv-&gt;first_item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }
  else
  {
    g_assert(parent-&gt;stamp == priv-&gt;stamp);

    item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
    if(item-&gt;browser == NULL)
      return FALSE;

    g_object_get(G_OBJECT(item-&gt;browser), &quot;status&quot;, &amp;browser_status, NULL);
    if(browser_status != INF_BROWSER_OPEN)
      return FALSE;

    browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);
    if(browser_iter.node_id == 0)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
    else
      browser_iter.node = parent-&gt;user_data3;

    /* If this iterator is the missing one, then it must be the root node,
     * otherwise this function must not have been called; it would have
     * been called on a non-existing entry. */
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );

    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return FALSE;

    if(!inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter))
      return FALSE;

    if(!inf_browser_get_explored(item-&gt;browser, &amp;browser_iter))
      return FALSE;

    if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
      return FALSE;

    if(browser_iter.node == item-&gt;missing)
      if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
        return FALSE;

    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_has_child(GtkTreeModel* model,
                                                GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus status;
  InfBrowserIter browser_iter;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter-&gt;stamp == priv-&gt;stamp);

  item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
  if(item-&gt;browser == NULL) return FALSE;

  browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
  browser_iter.node = iter-&gt;user_data3;

  g_object_get(G_OBJECT(item-&gt;browser), &quot;status&quot;, &amp;status, NULL);
  if(status != INF_BROWSER_OPEN)
    return FALSE;

  if(browser_iter.node == NULL)
    inf_browser_get_root(item-&gt;browser, &amp;browser_iter);

  /* If this iterator is the missing one, then it must be the root node,
   * otherwise this function must not have been called; it would have
   * been called on a non-existing entry. */
  g_assert(
    item-&gt;missing == NULL || browser_iter.node_id == 0 ||
    browser_iter.node != item-&gt;missing
  );

  if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
    return FALSE;

  if(inf_browser_is_subdirectory(item-&gt;browser, &amp;browser_iter) == FALSE)
    return FALSE;

  if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
    return FALSE;

  if(!inf_browser_get_child(item-&gt;browser, &amp;browser_iter))
    return FALSE;

  if(browser_iter.node == item-&gt;missing)
    if(!inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
      return FALSE;

  return TRUE;
}

static gint
inf_gtk_browser_store_tree_model_iter_n_children(GtkTreeModel* model,
                                                 GtkTreeIter* iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  InfBrowserIter browser_iter;
  gboolean result;
  guint n;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(iter == NULL || iter-&gt;stamp == priv-&gt;stamp);

  if(iter == NULL)
  {
    n = 0;
    for(cur = priv-&gt;first_item; cur != NULL; cur = cur-&gt;next)
      ++n;

    return n;
  }
  else
  {
    item = (InfGtkBrowserStoreItem*)iter-&gt;user_data;
    browser_iter.node_id = GPOINTER_TO_UINT(iter-&gt;user_data2);
    browser_iter.node = iter-&gt;user_data3;

    if(browser_iter.node == NULL)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);

    /* If this iterator is the missing one, then it must be the root node,
     * otherwise this function must not have been called; it would have
     * been called on a non-existing entry. */
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );

    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return 0;

    n = 0;
    for(result = inf_browser_get_child(item-&gt;browser, &amp;browser_iter);
        result == TRUE;
        result = inf_browser_get_next(item-&gt;browser, &amp;browser_iter))
    {
      if(browser_iter.node != item-&gt;missing)
        ++n;
    }

    return n;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_nth_child(GtkTreeModel* model,
                                                GtkTreeIter* iter,
                                                GtkTreeIter* parent,
                                                gint n)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfGtkBrowserStoreItem* cur;
  InfBrowserIter browser_iter;
  guint i;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);

  if(parent == NULL)
  {
    cur = priv-&gt;first_item;
    if(cur == NULL) return FALSE;

    for(i = 0; i &lt; (guint)n; ++ i)
    {
      cur = cur-&gt;next;
      if(cur == NULL) return FALSE;
    }

    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = cur;
    iter-&gt;user_data2 = GUINT_TO_POINTER(0);
    iter-&gt;user_data3 = NULL;
    return TRUE;
  }
  else
  {
    g_assert(parent-&gt;stamp == priv-&gt;stamp);

    item = (InfGtkBrowserStoreItem*)parent-&gt;user_data;
    browser_iter.node_id = GPOINTER_TO_UINT(parent-&gt;user_data2);

    if(browser_iter.node_id == 0)
      inf_browser_get_root(item-&gt;browser, &amp;browser_iter);
    else
      browser_iter.node = parent-&gt;user_data3;

    /* If this iterator is the missing one, then it must be the root node,
     * otherwise this function must not have been called; it would have
     * been called on a non-existing entry. */
    g_assert(
      item-&gt;missing == NULL || browser_iter.node_id == 0 ||
      browser_iter.node != item-&gt;missing
    );

    if(item-&gt;missing != NULL &amp;&amp; browser_iter.node == item-&gt;missing)
      return FALSE;

    if(inf_browser_get_explored(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    if(inf_browser_get_child(item-&gt;browser, &amp;browser_iter) == FALSE)
      return FALSE;

    /* skip missing */
    if(browser_iter.node == item-&gt;missing)
      ++n;

    for(i = 0; i &lt; (guint)n; ++ i)
    {
      if(inf_browser_get_next(item-&gt;browser, &amp;browser_iter) == FALSE)
        return FALSE;

      if(browser_iter.node == item-&gt;missing)
        ++n;
    }

    iter-&gt;stamp = priv-&gt;stamp;
    iter-&gt;user_data = item;
    iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
    iter-&gt;user_data3 = browser_iter.node;
    return TRUE;
  }
}

static gboolean
inf_gtk_browser_store_tree_model_iter_parent(GtkTreeModel* model,
                                             GtkTreeIter* iter,
                                             GtkTreeIter* child)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  InfBrowserIter browser_iter;
  gboolean result;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  g_assert(child-&gt;stamp == priv-&gt;stamp);

  item = (InfGtkBrowserStoreItem*)child-&gt;user_data;
  browser_iter.node_id = GPOINTER_TO_UINT(child-&gt;user_data2);
  browser_iter.node = child-&gt;user_data3;

  if(browser_iter.node == NULL)
    return FALSE;

  g_assert(browser_iter.node != item-&gt;missing);

  result = inf_browser_get_parent(item-&gt;browser, &amp;browser_iter);
  g_assert(result == TRUE);
  g_assert(browser_iter.node != item-&gt;missing);

  iter-&gt;stamp = priv-&gt;stamp;
  iter-&gt;user_data = item;
  iter-&gt;user_data2 = GUINT_TO_POINTER(browser_iter.node_id);
  iter-&gt;user_data3 = browser_iter.node;

  /* Root node */
  if(browser_iter.node_id == 0)
    iter-&gt;user_data3 = NULL;

  return TRUE;
}

/*
 * InfGtkBrowserModel implementation.
 */

static void
inf_gtk_browser_store_browser_model_set_browser(InfGtkBrowserModel* model,
                                                GtkTreePath* path,
                                                GtkTreeIter* tree_iter,
                                                InfBrowser* old_browser,
                                                InfBrowser* new_browser)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  InfBrowserIter iter;
  guint n;
  gboolean had_children;
  InfBrowserStatus status;

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  had_children = FALSE;

  item = (InfGtkBrowserStoreItem*)tree_iter-&gt;user_data;
  /* cannot set browser in non-toplevel entries */
  g_assert(tree_iter-&gt;user_data3 == NULL);

  if(item-&gt;browser != NULL)
  {
    g_assert(item-&gt;browser == old_browser);
    g_object_get(G_OBJECT(item-&gt;browser), &quot;status&quot;, &amp;status, NULL);
    if(status == INF_BROWSER_OPEN)
    {
      /* Notify about deleted rows. Notify in reverse order so that indexing
       * continues to work. Remember whether we had children to emit
       * row-has-child-toggled later. */
      inf_browser_get_root(item-&gt;browser, &amp;iter);
      if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
         inf_browser_get_child(item-&gt;browser, &amp;iter))
      {
        n = 1;
        while(inf_browser_get_next(item-&gt;browser, &amp;iter))
          ++ n;

        gtk_tree_path_append_index(path, n);

        for(; n &gt; 0; -- n)
        {
          had_children = TRUE;
          gtk_tree_path_prev(path);
          gtk_tree_model_row_deleted(GTK_TREE_MODEL(model), path);
        }

        gtk_tree_path_up(path);
      }
    }

    while(item-&gt;requests != NULL)
      inf_gtk_browser_store_item_request_remove(item, item-&gt;requests-&gt;data);

    g_hash_table_remove_all(item-&gt;node_errors);

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_node_added_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
      model
    );

    inf_signal_handlers_disconnect_by_func(
      G_OBJECT(item-&gt;browser),
      G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
      model
    );

    g_object_unref(G_OBJECT(item-&gt;browser));
  }

  /* Reset browser for emitting row-has-child-toggled */
  item-&gt;browser = NULL;
  if(had_children)
  {
    gtk_tree_model_row_has_child_toggled(
      GTK_TREE_MODEL(model),
      path,
      tree_iter
    );
  }

  /* Set up new browser */
  item-&gt;browser = new_browser;

  if(new_browser != NULL)
  {
    g_object_ref(new_browser);

    g_signal_connect(
      G_OBJECT(item-&gt;browser),
      &quot;error&quot;,
      G_CALLBACK(inf_gtk_browser_store_browser_error_cb),
      model
    );
      
    g_signal_connect(
      G_OBJECT(item-&gt;browser),
      &quot;notify::status&quot;,
      G_CALLBACK(inf_gtk_browser_store_browser_notify_status_cb),
      model
    );

    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      &quot;node-added&quot;,
      G_CALLBACK(inf_gtk_browser_store_node_added_cb),
      model
    );

    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      &quot;node-removed&quot;,
      G_CALLBACK(inf_gtk_browser_store_node_removed_cb),
      model
    );

    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      &quot;begin-request::explore-node&quot;,
      G_CALLBACK(inf_gtk_browser_store_begin_request_explore_node_cb),
      model
    );

    g_signal_connect_after(
      G_OBJECT(item-&gt;browser),
      &quot;begin-request::subscribe-session&quot;,
      G_CALLBACK(inf_gtk_browser_store_begin_request_subscribe_session_cb),
      model
    );

    /* TODO: Walk browser for requests */
  }

  /* Set status to invalid if there aren't any connection information anymore.
   * Keep the item if an error is set, so it can be displayed. */
  if(item-&gt;browser == NULL &amp;&amp; item-&gt;info == NULL &amp;&amp;
     (item-&gt;error == NULL || item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR))
  {
    /* This can happen when an API call leads to a browser being unset */
    /* Clear non-fatal error */
    g_assert(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR);
    if(item-&gt;error != NULL)
    {
      g_error_free(item-&gt;error);
      item-&gt;error = NULL;
    }

    item-&gt;status = INF_GTK_BROWSER_MODEL_INVALID;
  }
  else if(item-&gt;status != INF_GTK_BROWSER_MODEL_ERROR)
  {
    /* Set item status according to browser status if there is no
     * error set. */
    if(item-&gt;browser != NULL)
    {
      g_object_get(G_OBJECT(item-&gt;browser), &quot;status&quot;, &amp;status, NULL);
      switch(status)
      {
      case INF_BROWSER_CLOSED:
        item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
        break;
      case INF_BROWSER_OPENING:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
        break;
      case INF_BROWSER_OPEN:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
        break;
      default:
        g_assert_not_reached();
        break;
      }
    }
    else
    {
      /* No browser available. Discovery needs to be set now, otherwise
       * we would have set the status to invalid above. */
      g_assert(item-&gt;info != NULL);
      item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
    }
  }
  else
  {
    /* Error needs to be set in error status */
    g_assert(item-&gt;error != NULL);
  }

  /* TODO: Emit row_inserted for the whole tree in browser, and
   * row-has-child-toggled where appropriate. */
  gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, tree_iter);

  if(item-&gt;browser != NULL &amp;&amp; item-&gt;status == INF_GTK_BROWSER_MODEL_CONNECTED)
  {
    inf_browser_get_root(item-&gt;browser, &amp;iter);
    if(inf_browser_get_explored(item-&gt;browser, &amp;iter) &amp;&amp;
       inf_browser_get_child(item-&gt;browser, &amp;iter))
    {
      gtk_tree_model_row_has_child_toggled(
        GTK_TREE_MODEL(model),
        path,
        tree_iter
      );
    }
  }
}

static void
inf_gtk_browser_store_browser_model_resolve(InfGtkBrowserModel* model,
                                            InfDiscovery* discovery,
                                            InfDiscoveryInfo* info)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  GtkTreeIter tree_iter;
  GtkTreePath* path;

  g_assert(INF_GTK_IS_BROWSER_STORE(model));

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  item = inf_gtk_browser_store_find_item_by_discovery_info(
    INF_GTK_BROWSER_STORE(model),
    info
  );

  g_assert(item != NULL);
  g_assert(
    item-&gt;status == INF_GTK_BROWSER_MODEL_DISCOVERED ||
    item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR
  );

  if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
  {
    g_assert(item-&gt;error != NULL);
    g_error_free(item-&gt;error);
    item-&gt;error = NULL;

    item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
  }
  else
  {
    item-&gt;status = INF_GTK_BROWSER_MODEL_RESOLVING;
  }

  tree_iter.stamp = priv-&gt;stamp;
  tree_iter.user_data = item;
  tree_iter.user_data2 = GUINT_TO_POINTER(0);
  tree_iter.user_data3 = NULL;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(model), &amp;tree_iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(model), path, &amp;tree_iter);
  gtk_tree_path_free(path);

  inf_discovery_resolve(
    discovery,
    info,
    inf_gtk_browser_store_resolv_complete_func,
    model
  );
}

static gboolean
inf_gtk_browser_store_browser_iter_to_tree_iter(InfGtkBrowserModel* model,
                                                InfBrowser* browser,
                                                const InfBrowserIter* iter,
                                                GtkTreeIter* tree_iter)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  g_assert(INF_GTK_IS_BROWSER_STORE(model));

  priv = INF_GTK_BROWSER_STORE_PRIVATE(model);
  item = inf_gtk_browser_store_find_item_by_browser(
    INF_GTK_BROWSER_STORE(model),
    browser
  );
  if(item == NULL || (iter != NULL &amp;&amp; item-&gt;missing == iter-&gt;node))
    return FALSE;

  tree_iter-&gt;stamp = priv-&gt;stamp;
  tree_iter-&gt;user_data = item;

  if(iter != NULL &amp;&amp; iter-&gt;node_id != 0)
  {
    tree_iter-&gt;user_data2 = GUINT_TO_POINTER(iter-&gt;node_id);
    tree_iter-&gt;user_data3 = iter-&gt;node;
  }
  else
  {
    /* Root node */
    tree_iter-&gt;user_data2 = 0;
    tree_iter-&gt;user_data3 = NULL;
  }

  return TRUE;
}

/*
 * GType registration
 */

static void
inf_gtk_browser_store_class_init(InfGtkBrowserStoreClass* browser_store_class)
{
  GObjectClass* object_class;
  object_class = G_OBJECT_CLASS(browser_store_class);

  object_class-&gt;dispose = inf_gtk_browser_store_dispose;
  object_class-&gt;set_property = inf_gtk_browser_store_set_property;
  object_class-&gt;get_property = inf_gtk_browser_store_get_property;

  g_object_class_install_property(
    object_class,
    PROP_IO,
    g_param_spec_object(
      &quot;io&quot;,
      &quot;IO&quot;,
      &quot;The IO object used for the created browsers to schedule timeouts&quot;,
      INF_TYPE_IO,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );

  g_object_class_install_property(
    object_class,
    PROP_COMMUNICATION_MANAGER,
    g_param_spec_object(
      &quot;communication-manager&quot;,
      &quot;Communication manager&quot;, 
      &quot;The communication manager used for browsing remote directories&quot;,
      INF_COMMUNICATION_TYPE_MANAGER,
      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY
    )
  );
}

static void
inf_gtk_browser_store_tree_model_iface_init(GtkTreeModelIface* iface)
{
  iface-&gt;get_flags = inf_gtk_browser_store_tree_model_get_flags;
  iface-&gt;get_n_columns = inf_gtk_browser_store_tree_model_get_n_columns;
  iface-&gt;get_column_type = inf_gtk_browser_store_tree_model_get_column_type;
  iface-&gt;get_iter = inf_gtk_browser_store_tree_model_get_iter;
  iface-&gt;get_path = inf_gtk_browser_store_tree_model_get_path;
  iface-&gt;get_value = inf_gtk_browser_store_tree_model_get_value;
  iface-&gt;iter_next = inf_gtk_browser_store_tree_model_iter_next;
  iface-&gt;iter_children = inf_gtk_browser_store_tree_model_iter_children;
  iface-&gt;iter_has_child = inf_gtk_browser_store_tree_model_iter_has_child;
  iface-&gt;iter_n_children = inf_gtk_browser_store_tree_model_iter_n_children;
  iface-&gt;iter_nth_child = inf_gtk_browser_store_tree_model_iter_nth_child;
  iface-&gt;iter_parent = inf_gtk_browser_store_tree_model_iter_parent;
}

static void
inf_gtk_browser_store_browser_model_iface_init(
  InfGtkBrowserModelInterface* iface)
{
  iface-&gt;set_browser = inf_gtk_browser_store_browser_model_set_browser;
  iface-&gt;resolve = inf_gtk_browser_store_browser_model_resolve;
  /* inf_gtk_browser_store_browser_model_browser_iter_to_tree_iter would be
   * consistent, but a _bit_ too long to fit properly into 80 chars ;) */
  iface-&gt;browser_iter_to_tree_iter =
    inf_gtk_browser_store_browser_iter_to_tree_iter;
}

/*
 * Public API.
 */

/**
 * inf_gtk_browser_store_new: (constructor)
 * @io: A #InfIo object for the created #InfcBrowser to schedule timeouts.
 * @comm_manager: The #InfCommunicationManager with which to explore
 * remote directories.
 *
 * Creates a new #InfGtkBrowserStore.
 *
 * Returns: (transfer full): A new #InfGtkBrowserStore.
 **/
InfGtkBrowserStore*
inf_gtk_browser_store_new(InfIo* io,
                          InfCommunicationManager* comm_manager)
{
  GObject* object;

  object = g_object_new(
    INF_GTK_TYPE_BROWSER_STORE,
    &quot;io&quot;, io,
    &quot;communication-manager&quot;, comm_manager,
    NULL
  );

  return INF_GTK_BROWSER_STORE(object);
}

/**
 * inf_gtk_browser_store_add_discovery:
 * @store: A #InfGtkBrowserStore.
 * @discovery: A #InfDiscovery not yet added to @model.
 *
 * Adds @discovery to @model. The model will then show up discovered
 * servers.
 **/
void
inf_gtk_browser_store_add_discovery(InfGtkBrowserStore* store,
                                    InfDiscovery* discovery)
{
  InfGtkBrowserStorePrivate* priv;
  GSList* discovered;
  GSList* item;
  InfDiscoveryInfo* info;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_DISCOVERY(discovery));

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  g_return_if_fail(g_slist_find(priv-&gt;discoveries, discovery) == NULL);

  g_object_ref(G_OBJECT(discovery));
  priv-&gt;discoveries = g_slist_prepend(priv-&gt;discoveries, discovery);

  g_signal_connect(
    G_OBJECT(discovery),
    &quot;discovered&quot;,
    G_CALLBACK(inf_gtk_browser_store_discovered_cb),
    store
  );

  g_signal_connect(
    G_OBJECT(discovery),
    &quot;undiscovered&quot;,
    G_CALLBACK(inf_gtk_browser_store_undiscovered_cb),
    store
  );

  discovered = inf_discovery_get_discovered(discovery, &quot;_infinote._tcp&quot;);
  for(item = discovered; item != NULL; item = g_slist_next(item))
  {
    info = (InfDiscoveryInfo*)item-&gt;data;

    inf_gtk_browser_store_add_item_by_browser(
      store,
      discovery,
      info,
      NULL,
      inf_discovery_info_get_service_name(discovery, info)
    );
  }
  g_slist_free(discovered);

  inf_discovery_discover(discovery, &quot;_infinote._tcp&quot;);
}

/**
 * inf_gtk_browser_store_add_connection:
 * @store: A #InfGtkBrowserStore.
 * @connection: A #InfXmlConnection.
 * @name: (allow-none): Name for the item, or %NULL.
 *
 * This function adds a connection to the @store. @store will show up
 * an item for the connection if there is not already one. This allows to
 * browse the explored parts of the directory of the remote site. If @name
 * is %NULL, then the #InfXmlConnection:remote-id of the connection will be
 * used.
 *
 * The return value is the #InfBrowser for the added connection, or an
 * existing browser for the connection, if there is any.
 *
 * Returns: (transfer none): An #InfBrowser for the new connection.
 **/
InfBrowser*
inf_gtk_browser_store_add_connection(InfGtkBrowserStore* store,
                                     InfXmlConnection* connection,
                                     const gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;
  gchar* remote_id;

  g_return_val_if_fail(INF_GTK_IS_BROWSER_STORE(store), NULL);
  g_return_val_if_fail(INF_IS_XML_CONNECTION(connection), NULL);

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_connection(store, connection);

  if(item == NULL)
  {
    if(name == NULL)
    {
      g_object_get(G_OBJECT(connection), &quot;remote-id&quot;, &amp;remote_id, NULL);

      item = inf_gtk_browser_store_add_item_by_connection(
        store,
        NULL,
        NULL,
        connection,
        remote_id
      );
    }
    else
    {
      item = inf_gtk_browser_store_add_item_by_connection(
        store,
        NULL,
        NULL,
        connection,
        g_strdup(name)
      );
    }
  }

  return item-&gt;browser;
}

/**
 * inf_gtk_browser_store_add_browser:
 * @store: A #InfGtkBrowserStore.
 * @browser: A #InfBrowser.
 * @name: Name for the item.
 *
 * This function adds a browser to the @store. @store will show up
 * an item for the browser if there is not already one. This allows to
 * browse the explored part of the browser. The @name parameter must not be
 * %NULL.
 **/
void
inf_gtk_browser_store_add_browser(InfGtkBrowserStore* store,
                                  InfBrowser* browser,
                                  const gchar* name)
{
  InfGtkBrowserStorePrivate* priv;
  InfGtkBrowserStoreItem* item;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_BROWSER(browser));
  g_return_if_fail(name != NULL);

  priv = INF_GTK_BROWSER_STORE_PRIVATE(store);
  item = inf_gtk_browser_store_find_item_by_browser(store, browser);

  if(item == NULL)
  {
    inf_gtk_browser_store_add_item_by_browser(
      store,
      NULL,
      NULL,
      browser,
      g_strdup(name)
    );
  }
}

/**
 * inf_gtk_browser_store_remove_browser:
 * @store: A #InfGtkBrowserStore
 * @browser: A #InfBrowser contained in @store.
 *
 * This function removes the entry for the given browser from @store.
 */
void
inf_gtk_browser_store_remove_browser(InfGtkBrowserStore* store,
                                     InfBrowser* browser)
{
  InfGtkBrowserStoreItem* item;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_BROWSER(browser));

  item = inf_gtk_browser_store_find_item_by_browser(store, browser);
  g_return_if_fail(item != NULL);

  inf_gtk_browser_store_remove_item (store, item);
}

/**
 * inf_gtk_browser_store_remove_connection:
 * @store: A #InfGtkBrowserStore.
 * @connection: A #InfXmlConnection contained in @store.
 *
 * This function removes the entry for the given connection from @store.
 */
void
inf_gtk_browser_store_remove_connection(InfGtkBrowserStore* store,
                                        InfXmlConnection* connection)
{
  InfGtkBrowserStoreItem* item;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));

  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);

  inf_gtk_browser_store_remove_item (store, item);
}

/**
 * inf_gtk_browser_store_clear_connection_error:
 * @store: A #InfGtkBrowserStore.
 * @connection: A #InfXmlConnection contained in @store.
 *
 * This function clears the error for the entry which belongs to the given
 * connection.
 */
void
inf_gtk_browser_store_clear_connection_error(InfGtkBrowserStore* store,
                                             InfXmlConnection* connection)
{
  InfGtkBrowserStoreItem* item;
  InfBrowserStatus status;
  GtkTreeIter iter;
  GtkTreePath* path;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));

  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);

  if(item-&gt;status == INF_GTK_BROWSER_MODEL_ERROR)
  {
    g_assert(item-&gt;error != NULL);

    g_error_free(item-&gt;error);
    item-&gt;error = NULL;

    if(item-&gt;browser != NULL)
    {
      g_object_get(G_OBJECT(item-&gt;browser), &quot;status&quot;, &amp;status, NULL);
      switch(status)
      {
      case INF_BROWSER_CLOSED:
        item-&gt;status = INF_GTK_BROWSER_MODEL_DISCONNECTED;
        break;
      case INF_BROWSER_OPENING:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTING;
        break;
      case INF_BROWSER_OPEN:
        item-&gt;status = INF_GTK_BROWSER_MODEL_CONNECTED;
        break;
      default:
        g_assert_not_reached();
        break;
      }
    }
    else if(item-&gt;info != NULL)
    {
      item-&gt;status = INF_GTK_BROWSER_MODEL_DISCOVERED;
    }
    else
    {
      g_assert_not_reached();
    }

    iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
    iter.user_data = item;
    iter.user_data2 = GUINT_TO_POINTER(0);
    iter.user_data3 = NULL;

    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
    gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
    gtk_tree_path_free (path);
  }
}

/**
 * inf_gtk_browser_store_set_connection_name:
 * @store: A #InfGtkBrowserStore.
 * @connection: A #InfXmlConnection contained in @store.
 * @name: The new name to set for the connection.
 *
 * This function sets the name of @connection.
 **/
void
inf_gtk_browser_store_set_connection_name(InfGtkBrowserStore* store,
                                          InfXmlConnection* connection,
                                          const gchar* name)
{
  InfGtkBrowserStoreItem* item;
  GtkTreeIter iter;
  GtkTreePath* path;

  g_return_if_fail(INF_GTK_IS_BROWSER_STORE(store));
  g_return_if_fail(INF_IS_XML_CONNECTION(connection));
  g_return_if_fail(name != NULL);

  item = inf_gtk_browser_store_find_item_by_connection(store, connection);
  g_return_if_fail(item != NULL);

  g_free (item-&gt;name);
  item-&gt;name = g_strdup(name);

  iter.stamp = INF_GTK_BROWSER_STORE_PRIVATE(store)-&gt;stamp;
  iter.user_data = item;
  iter.user_data2 = GUINT_TO_POINTER(0);
  iter.user_data3 = NULL;

  path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &amp;iter);
  gtk_tree_model_row_changed(GTK_TREE_MODEL(store), path, &amp;iter);
  gtk_tree_path_free(path);
}

/* vim:set et sw=2 ts=2: */
</PRE>
</div>
  </div>
</body>
</html>
