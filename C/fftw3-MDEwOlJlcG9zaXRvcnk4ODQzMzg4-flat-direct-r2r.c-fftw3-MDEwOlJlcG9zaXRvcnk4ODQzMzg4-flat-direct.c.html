
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-direct-r2r.c</h3>
            <pre><code>1  #include "rdft/rdft.h"
2  typedef struct {
3       solver super;
4       const kr2r_desc *desc;
5       kr2r k;
6  } S;
7  typedef struct {
8       plan_rdft super;
9       INT vl, ivs, ovs;
10       stride is, os;
11       kr2r k;
12       const S *slv;
13  } P;
14  static void apply(const plan *ego_, R *I, R *O)
15  {
16       const P *ego = (const P *) ego_;
17       ASSERT_ALIGNED_DOUBLE;
18       ego->k(I, O, ego->is, ego->os, ego->vl, ego->ivs, ego->ovs);
19  }
20  static void destroy(plan *ego_)
21  {
22       P *ego = (P *) ego_;
23       X(stride_destroy)(ego->is);
24       X(stride_destroy)(ego->os);
25  }
26  static void print(const plan *ego_, printer *p)
27  {
28       const P *ego = (const P *) ego_;
29       const S *s = ego->slv;
30       p->print(p, "(rdft-%s-direct-r2r-%D%v \"%s\")", 
31  	      X(rdft_kind_str)(s->desc->kind), s->desc->n,
32  	      ego->vl, s->desc->nam);
33  }
34  static int applicable(const solver *ego_, const problem *p_)
35  {
36       const S *ego = (const S *) ego_;
37       const problem_rdft *p = (const problem_rdft *) p_;
38       INT vl;
39       INT ivs, ovs;
40       return (
41  	  1
42  	  && p->sz->rnk == 1
43  	  && p->vecsz->rnk <= 1
44  	  && p->sz->dims[0].n == ego->desc->n
45  	  && p->kind[0] == ego->desc->kind
46  	  && X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs)
47  	  && (0
48  	      || p->I != p->O
<span onclick='openModal()' class='match'>49  	      || vl == 1
50  	      || X(tensor_inplace_strides2)(p->sz, p->vecsz)
51  	       )
52  	  );
53  }
54  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
</span>55  {
56       const S *ego = (const S *) ego_;
57       P *pln;
58       const problem_rdft *p;
59       iodim *d;
60       static const plan_adt padt = {
61  	  X(rdft_solve), X(null_awake), print, destroy
62       };
63       UNUSED(plnr);
64       if (!applicable(ego_, p_))
65            return (plan *)0;
66       p = (const problem_rdft *) p_;
67       pln = MKPLAN_RDFT(P, &padt, apply);
68       d = p->sz->dims;
69       pln->k = ego->k;
70       pln->is = X(mkstride)(d->n, d->is);
71       pln->os = X(mkstride)(d->n, d->os);
72       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
73       pln->slv = ego;
74       X(ops_zero)(&pln->super.super.ops);
75       X(ops_madd2)(pln->vl / ego->desc->genus->vl,
76  		  &ego->desc->ops,
77  		  &pln->super.super.ops);
78       pln->super.super.could_prune_now_p = 1;
79       return &(pln->super.super);
80  }
81  solver *X(mksolver_rdft_r2r_direct)(kr2r k, const kr2r_desc *desc)
82  {
83       static const solver_adt sadt = { PROBLEM_RDFT, mkplan, 0 };
84       S *slv = MKSOLVER(S, &sadt);
85       slv->k = k;
86       slv->desc = desc;
87       return &(slv->super);
88  }
</code></pre>
        </div>
        <div class="column">
            <h3>fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-direct.c</h3>
            <pre><code>1  #include "dft/dft.h"
2  typedef struct {
3       solver super;
4       const kdft_desc *desc;
5       kdft k;
6       int bufferedp;
7  } S;
8  typedef struct {
9       plan_dft super;
10       stride is, os, bufstride;
11       INT n, vl, ivs, ovs;
12       kdft k;
13       const S *slv;
14  } P;
15  static void dobatch(const P *ego, R *ri, R *ii, R *ro, R *io, 
16  		    R *buf, INT batchsz)
17  {
18       X(cpy2d_pair_ci)(ri, ii, buf, buf+1,
19  		      ego->n, WS(ego->is, 1), WS(ego->bufstride, 1),
20  		      batchsz, ego->ivs, 2);
21       if (IABS(WS(ego->os, 1)) < IABS(ego->ovs)) {
22  	  ego->k(buf, buf+1, ro, io, 
23  		 ego->bufstride, ego->os, batchsz, 2, ego->ovs);
24       } else {
25  	  ego->k(buf, buf+1, buf, buf+1, 
26  		 ego->bufstride, ego->bufstride, batchsz, 2, 2);
27  	  X(cpy2d_pair_co)(buf, buf+1, ro, io,
28  			   ego->n, WS(ego->bufstride, 1), WS(ego->os, 1), 
29  			   batchsz, 2, ego->ovs);
30       }
31  }
32  static INT compute_batchsize(INT n)
33  {
34       n += 3;
35       n &= -4;
36       return (n + 2);
37  }
38  static void apply_buf(const plan *ego_, R *ri, R *ii, R *ro, R *io)
39  {
40       const P *ego = (const P *) ego_;
41       R *buf;
42       INT vl = ego->vl, n = ego->n, batchsz = compute_batchsize(n);
43       INT i;
44       size_t bufsz = n * batchsz * 2 * sizeof(R);
45       BUF_ALLOC(R *, buf, bufsz);
46       for (i = 0; i < vl - batchsz; i += batchsz) {
47  	  dobatch(ego, ri, ii, ro, io, buf, batchsz);
48  	  ri += batchsz * ego->ivs; ii += batchsz * ego->ivs;
49  	  ro += batchsz * ego->ovs; io += batchsz * ego->ovs;
50       }
51       dobatch(ego, ri, ii, ro, io, buf, vl - i);
52       BUF_FREE(buf, bufsz);
53  }
54  static void apply(const plan *ego_, R *ri, R *ii, R *ro, R *io)
55  {
56       const P *ego = (const P *) ego_;
57       ASSERT_ALIGNED_DOUBLE;
58       ego->k(ri, ii, ro, io, ego->is, ego->os, ego->vl, ego->ivs, ego->ovs);
59  }
60  static void apply_extra_iter(const plan *ego_, R *ri, R *ii, R *ro, R *io)
61  {
62       const P *ego = (const P *) ego_;
63       INT vl = ego->vl;
64       ASSERT_ALIGNED_DOUBLE;
65       ego->k(ri, ii, ro, io, ego->is, ego->os, vl - 1, ego->ivs, ego->ovs);
66       ego->k(ri + (vl - 1) * ego->ivs, ii + (vl - 1) * ego->ivs,
67  	    ro + (vl - 1) * ego->ovs, io + (vl - 1) * ego->ovs,
68  	    ego->is, ego->os, 1, 0, 0);
69  }
70  static void destroy(plan *ego_)
71  {
72       P *ego = (P *) ego_;
73       X(stride_destroy)(ego->is);
74       X(stride_destroy)(ego->os);
75       X(stride_destroy)(ego->bufstride);
76  }
77  static void print(const plan *ego_, printer *p)
78  {
79       const P *ego = (const P *) ego_;
80       const S *s = ego->slv;
81       const kdft_desc *d = s->desc;
82       if (ego->slv->bufferedp)
83  	  p->print(p, "(dft-directbuf/%D-%D%v \"%s\")", 
84  		   compute_batchsize(d->sz), d->sz, ego->vl, d->nam);
85       else
86  	  p->print(p, "(dft-direct-%D%v \"%s\")", d->sz, ego->vl, d->nam);
87  }
88  static int applicable_buf(const solver *ego_, const problem *p_,
89  			  const planner *plnr)
90  {
91       const S *ego = (const S *) ego_;
92       const problem_dft *p = (const problem_dft *) p_;
93       const kdft_desc *d = ego->desc;
94       INT vl;
95       INT ivs, ovs;
96       INT batchsz;
97       return (
98  	  1
99  	  && p->sz->rnk == 1
100  	  && p->vecsz->rnk == 1
101  	  && p->sz->dims[0].n == d->sz
102  	  && X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs)
103  	  && !(NO_UGLYP(plnr) &&
104  	       X(iabs)(p->sz->dims[0].is) <= X(iabs)(ivs))
105  	  && (batchsz = compute_batchsize(d->sz), 1)
106  	  && (d->genus->okp(d, 0, ((const R *)0) + 1, p->ro, p->io,
107  			    2 * batchsz, p->sz->dims[0].os,
108  			    batchsz, 2, ovs, plnr))
109  	  && (d->genus->okp(d, 0, ((const R *)0) + 1, p->ro, p->io,
110  			    2 * batchsz, p->sz->dims[0].os,
111  			    vl % batchsz, 2, ovs, plnr))
112  	  && (0
113  	      || p->ri != p->ro
114  	      || X(tensor_inplace_strides2)(p->sz, p->vecsz)
115  	      || vl <= batchsz
116  	       )
117  	  );
118  }
119  static int applicable(const solver *ego_, const problem *p_,
120  		      const planner *plnr, int *extra_iterp)
121  {
122       const S *ego = (const S *) ego_;
123       const problem_dft *p = (const problem_dft *) p_;
124       const kdft_desc *d = ego->desc;
125       INT vl;
126       INT ivs, ovs;
127       return (
128  	  1
129  	  && p->sz->rnk == 1
130  	  && p->vecsz->rnk <= 1
131  	  && p->sz->dims[0].n == d->sz
132  	  && X(tensor_tornk1)(p->vecsz, &vl, &ivs, &ovs)
133  	  && ((*extra_iterp = 0,
134  	       (d->genus->okp(d, p->ri, p->ii, p->ro, p->io,
135  			      p->sz->dims[0].is, p->sz->dims[0].os,
136  			      vl, ivs, ovs, plnr)))
137  	      ||
138  	      (*extra_iterp = 1,
139  	       ((d->genus->okp(d, p->ri, p->ii, p->ro, p->io,
140  			       p->sz->dims[0].is, p->sz->dims[0].os,
141  			       vl - 1, ivs, ovs, plnr))
142  		&&
143  		(d->genus->okp(d, p->ri, p->ii, p->ro, p->io,
144  			       p->sz->dims[0].is, p->sz->dims[0].os,
145  			       2, 0, 0, plnr)))))
146  	  && (0
147  	      || p->ri != p->ro
<span onclick='openModal()' class='match'>148  	      || vl == 1
149  	      || X(tensor_inplace_strides2)(p->sz, p->vecsz)
150  	       )
151  	  );
152  }
153  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
</span>154  {
155       const S *ego = (const S *) ego_;
156       P *pln;
157       const problem_dft *p;
158       iodim *d;
159       const kdft_desc *e = ego->desc;
160       static const plan_adt padt = {
161  	  X(dft_solve), X(null_awake), print, destroy
162       };
163       UNUSED(plnr);
164       if (ego->bufferedp) {
165  	  if (!applicable_buf(ego_, p_, plnr))
166  	       return (plan *)0;
167  	  pln = MKPLAN_DFT(P, &padt, apply_buf);
168       } else {
169  	  int extra_iterp = 0;
170  	  if (!applicable(ego_, p_, plnr, &extra_iterp))
171  	       return (plan *)0;
172  	  pln = MKPLAN_DFT(P, &padt, extra_iterp ? apply_extra_iter : apply);
173       }
174       p = (const problem_dft *) p_;
175       d = p->sz->dims;
176       pln->k = ego->k;
177       pln->n = d[0].n;
178       pln->is = X(mkstride)(pln->n, d[0].is);
179       pln->os = X(mkstride)(pln->n, d[0].os);
180       pln->bufstride = X(mkstride)(pln->n, 2 * compute_batchsize(pln->n));
181       X(tensor_tornk1)(p->vecsz, &pln->vl, &pln->ivs, &pln->ovs);
182       pln->slv = ego;
183       X(ops_zero)(&pln->super.super.ops);
184       X(ops_madd2)(pln->vl / e->genus->vl, &e->ops, &pln->super.super.ops);
185       if (ego->bufferedp) 
186  	  pln->super.super.ops.other += 4 * pln->n * pln->vl;
187       pln->super.super.could_prune_now_p = !ego->bufferedp;
188       return &(pln->super.super);
189  }
190  static solver *mksolver(kdft k, const kdft_desc *desc, int bufferedp)
191  {
192       static const solver_adt sadt = { PROBLEM_DFT, mkplan, 0 };
193       S *slv = MKSOLVER(S, &sadt);
194       slv->k = k;
195       slv->desc = desc;
196       slv->bufferedp = bufferedp;
197       return &(slv->super);
198  }
199  solver *X(mksolver_dft_direct)(kdft k, const kdft_desc *desc)
200  {
201       return mksolver(k, desc, 0);
202  }
203  solver *X(mksolver_dft_directbuf)(kdft k, const kdft_desc *desc)
204  {
205       return mksolver(k, desc, 1);
206  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-direct-r2r.c</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from fftw3-MDEwOlJlcG9zaXRvcnk4ODQzMzg4-flat-direct.c</div>
                </div>
                <div class="column column_space"><pre><code>49  	      || vl == 1
50  	      || X(tensor_inplace_strides2)(p->sz, p->vecsz)
51  	       )
52  	  );
53  }
54  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
</pre></code></div>
                <div class="column column_space"><pre><code>148  	      || vl == 1
149  	      || X(tensor_inplace_strides2)(p->sz, p->vecsz)
150  	       )
151  	  );
152  }
153  static plan *mkplan(const solver *ego_, const problem *p_, planner *plnr)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    